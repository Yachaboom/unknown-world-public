This file is a merged representation of a subset of the codebase, containing specifically included files and files not matching ignore patterns, combined into a single document by Repomix.

<file_summary>
This section contains a summary of this file.

<purpose>
This file contains a packed representation of a subset of the repository's contents that is considered the most important context.
It is designed to be easily consumable by AI systems for analysis, code review,
or other automated processes.
</purpose>

<file_format>
The content is organized as follows:
1. This summary section
2. Repository information
3. Directory structure
4. Repository files (if enabled)
5. Multiple file entries, each consisting of:
  - File path as an attribute
  - Full contents of the file
</file_format>

<usage_guidelines>
- This file should be treated as read-only. Any changes should be made to the
  original repository files, not this packed version.
- When processing this file, use the file path to distinguish
  between different files in the repository.
- Be aware that this file may contain sensitive information. Handle it with
  the same level of security as you would the original repository.
</usage_guidelines>

<notes>
- Some files may have been excluded based on .gitignore rules and Repomix's configuration
- Binary files are not included in this packed representation. Please refer to the Repository Structure section for a complete list of file paths, including binary files
- Only files matching these patterns are included: frontend/src/**/*.{ts,tsx,json}
- Files matching these patterns are excluded: **/node_modules/**, **/dist/**, **/.gemini/**, **/.cursor/**, **/.claude/**, vibe/**
- Files matching patterns in .gitignore are excluded
- Files matching default ignore patterns are excluded
- Files are sorted by Git change count (files with more changes are at the bottom)
</notes>

</file_summary>

<directory_structure>
frontend/src/api/scanner.test.ts
frontend/src/api/scanner.ts
frontend/src/api/turnStream.test.ts
frontend/src/api/turnStream.ts
frontend/src/App.test.tsx
frontend/src/App.tsx
frontend/src/components/ActionDeck.test.tsx
frontend/src/components/ActionDeck.tsx
frontend/src/components/AgentConsole.test.tsx
frontend/src/components/AgentConsole.tsx
frontend/src/components/DemoProfileSelect.tsx
frontend/src/components/DndInteraction.test.tsx
frontend/src/components/EconomyHud.test.tsx
frontend/src/components/EconomyHud.tsx
frontend/src/components/GameHeader.tsx
frontend/src/components/InventoryPanel.test.tsx
frontend/src/components/InventoryPanel.tsx
frontend/src/components/MutationTimeline.test.tsx
frontend/src/components/MutationTimeline.tsx
frontend/src/components/NarrativeFeed.tsx
frontend/src/components/Panel.tsx
frontend/src/components/QuestPanel.test.tsx
frontend/src/components/QuestPanel.tsx
frontend/src/components/ResetButton.tsx
frontend/src/components/RuleBoard.test.tsx
frontend/src/components/RuleBoard.tsx
frontend/src/components/ScannerSlot.test.tsx
frontend/src/components/ScannerSlot.tsx
frontend/src/components/SceneCanvas.hotspot.test.tsx
frontend/src/components/SceneCanvas.test.tsx
frontend/src/components/SceneCanvas.tsx
frontend/src/components/SceneImage.test.tsx
frontend/src/components/SceneImage.tsx
frontend/src/components/UIControls.tsx
frontend/src/data/demoProfiles.test.ts
frontend/src/data/demoProfiles.ts
frontend/src/demo/demoFixtures.ts
frontend/src/demo/useDemoInitializer.ts
frontend/src/dnd/types.ts
frontend/src/i18n-scenario.test.ts
frontend/src/i18n.ts
frontend/src/locales/en-US/translation.json
frontend/src/locales/ko-KR/translation.json
frontend/src/main.tsx
frontend/src/save/constants.ts
frontend/src/save/migrations.test.ts
frontend/src/save/migrations.ts
frontend/src/save/saveGame.test.ts
frontend/src/save/saveGame.ts
frontend/src/save/sessionLifecycle.test.ts
frontend/src/save/sessionLifecycle.ts
frontend/src/schemas/index.ts
frontend/src/schemas/turn.test.ts
frontend/src/schemas/turn.ts
frontend/src/schemas/verify_runbook.ts
frontend/src/setupTests.ts
frontend/src/stores/actionDeckStore.test.ts
frontend/src/stores/actionDeckStore.ts
frontend/src/stores/agentStore.test.ts
frontend/src/stores/agentStore.ts
frontend/src/stores/economyStore.test.ts
frontend/src/stores/economyStore.ts
frontend/src/stores/inventoryStore.test.ts
frontend/src/stores/inventoryStore.ts
frontend/src/stores/uiPrefsStore.test.ts
frontend/src/stores/uiPrefsStore.ts
frontend/src/stores/worldStore.test.ts
frontend/src/stores/worldStore.ts
frontend/src/turn/turnRunner.ts
frontend/src/types/scene.ts
frontend/src/types/turn_stream.ts
frontend/src/utils/box2d.test.ts
frontend/src/utils/box2d.ts
frontend/src/vite-env.d.ts
</directory_structure>

<files>
This section contains the contents of the repository's files.

<file path="frontend/src/vite-env.d.ts">
/// <reference types="vite/client" />
</file>

<file path="frontend/src/api/scanner.test.ts">
import { describe, it, expect, vi, beforeEach } from 'vitest';
import {
  scanImage,
  validateFile,
  isSupportedImageFile,
  candidateToInventoryItem,
  MAX_FILE_SIZE_BYTES,
  type ItemCandidate,
} from './scanner';

describe('Scanner API Client', () => {
  beforeEach(() => {
    vi.clearAllMocks();
    global.fetch = vi.fn();
  });

  describe('validateFile', () => {
    it('returns null for valid image files', () => {
      const file = new File([''], 'test.png', { type: 'image/png' });
      expect(validateFile(file)).toBeNull();
    });

    it('returns error for unsupported MIME types', () => {
      const file = new File([''], 'test.txt', { type: 'text/plain' });
      expect(validateFile(file)).toContain('ì§€ì›í•˜ì§€ ì•ŠëŠ” íŒŒì¼ í˜•ì‹');
    });

    it('returns error for files exceeding max size', () => {
      const largeFile = {
        size: MAX_FILE_SIZE_BYTES + 1,
        type: 'image/png',
        name: 'large.png',
      } as File;
      expect(validateFile(largeFile)).toContain('íŒŒì¼ì´ ë„ˆë¬´ í½ë‹ˆë‹¤');
    });
  });

  describe('isSupportedImageFile', () => {
    it('returns true for jpg, png, webp, gif', () => {
      expect(isSupportedImageFile(new File([''], 't.jpg', { type: 'image/jpeg' }))).toBe(true);
      expect(isSupportedImageFile(new File([''], 't.png', { type: 'image/png' }))).toBe(true);
      expect(isSupportedImageFile(new File([''], 't.webp', { type: 'image/webp' }))).toBe(true);
      expect(isSupportedImageFile(new File([''], 't.gif', { type: 'image/gif' }))).toBe(true);
    });

    it('returns false for others', () => {
      expect(isSupportedImageFile(new File([''], 't.pdf', { type: 'application/pdf' }))).toBe(
        false,
      );
    });
  });

  describe('scanImage', () => {
    const mockFile = new File(['mock content'], 'test.png', { type: 'image/png' });
    const mockSuccessResponse = {
      success: true,
      status: 'completed',
      caption: 'A test scan',
      objects: [],
      item_candidates: [{ id: 'item-1', label: 'Test Item', item_type: 'tool' }],
      analysis_time_ms: 100,
      language: 'ko-KR',
    };

    it('returns success data when API call succeeds', async () => {
      (global.fetch as unknown as ReturnType<typeof vi.fn>).mockResolvedValue({
        ok: true,
        json: async () => mockSuccessResponse,
      });

      const result = await scanImage(mockFile, 'ko-KR');

      expect(result.success).toBe(true);
      if (result.success) {
        expect(result.data.caption).toBe('A test scan');
        expect(result.data.item_candidates).toHaveLength(1);
      }
    });

    it('returns error when fetch fails', async () => {
      (global.fetch as unknown as ReturnType<typeof vi.fn>).mockResolvedValue({
        ok: false,
        status: 500,
        statusText: 'Internal Server Error',
      });

      const result = await scanImage(mockFile, 'ko-KR');

      expect(result.success).toBe(false);
      if (!result.success) {
        expect(result.error).toContain('ì„œë²„ ì˜¤ë¥˜: 500');
      }
    });

    it('returns error when response schema is invalid', async () => {
      (global.fetch as unknown as ReturnType<typeof vi.fn>).mockResolvedValue({
        ok: true,
        json: async () => ({ invalid: 'data' }),
      });

      const result = await scanImage(mockFile, 'ko-KR');

      expect(result.success).toBe(false);
      if (!result.success) {
        expect(result.error).toContain('ë°ì´í„° í˜•ì‹ì´ ì˜¬ë°”ë¥´ì§€ ì•ŠìŠµë‹ˆë‹¤');
      }
    });

    it('handles network error', async () => {
      (global.fetch as unknown as ReturnType<typeof vi.fn>).mockRejectedValue(
        new Error('Network error'),
      );

      const result = await scanImage(mockFile, 'ko-KR');

      expect(result.success).toBe(false);
      if (!result.success) {
        expect(result.error).toContain('ë„¤íŠ¸ì›Œí¬ ì˜¤ë¥˜');
      }
    });
  });

  describe('candidateToInventoryItem', () => {
    it('correctly maps ItemCandidate to InventoryItem', () => {
      const candidate = {
        id: 'c-1',
        label: 'Rusty Key',
        description: 'An old key',
        item_type: 'key',
      };
      const item = candidateToInventoryItem(candidate);

      expect(item).toEqual({
        id: 'c-1',
        name: 'Rusty Key',
        description: 'An old key',
        icon: 'ğŸ”‘',
        quantity: 1,
      });
    });

    it('uses fallback icon for unknown item types', () => {
      const candidate: ItemCandidate = {
        id: 'c-2',
        label: 'Something',
        description: '',
        item_type: 'unknown',
      };
      const item = candidateToInventoryItem(candidate);
      expect(item.icon).toBe('ğŸ“¦');
    });
  });
});
</file>

<file path="frontend/src/components/EconomyHud.test.tsx">
import { describe, it, expect, beforeEach, vi } from 'vitest';
import { render, screen } from '@testing-library/react';
import { EconomyHud } from './EconomyHud';
import { useWorldStore } from '../stores/worldStore';
import { useEconomyStore } from '../stores/economyStore';

// react-i18next ëª¨í‚¹
vi.mock('react-i18next', () => ({
  useTranslation: () => ({
    t: (key: string) => key,
  }),
}));

describe('EconomyHud', () => {
  beforeEach(() => {
    useWorldStore.getState().reset();
    useEconomyStore.getState().reset();
  });

  it('í˜„ì¬ ì”ì•¡ì„ ì˜¬ë°”ë¥´ê²Œ í‘œì‹œí•´ì•¼ í•œë‹¤', () => {
    useWorldStore.getState().setEconomy({ signal: 50, memory_shard: 5 });

    render(<EconomyHud />);

    expect(screen.getByTestId('signal-balance')).toHaveTextContent('50');
    expect(screen.getByTestId('shard-balance')).toHaveTextContent('5');
  });

  it('ì˜ˆìƒ ë¹„ìš©ì´ ìˆì„ ë•Œ í‘œì‹œí•´ì•¼ í•œë‹¤', () => {
    useEconomyStore.getState().setCostEstimate({
      min: { signal: 5, memory_shard: 0 },
      max: { signal: 10, memory_shard: 0 },
      label: 'Test Action',
    });

    render(<EconomyHud />);

    expect(screen.getByText('economy.estimated_cost')).toBeInTheDocument();
    expect(screen.getByText('Test Action')).toBeInTheDocument();
    expect(screen.getByText('5~10')).toBeInTheDocument();
  });

  it('ê°ë‹¹í•  ìˆ˜ ì—†ëŠ” ì˜ˆìƒ ë¹„ìš©ì¼ ë•Œ ê²½ê³ ë¥¼ í‘œì‹œí•´ì•¼ í•œë‹¤', () => {
    useWorldStore.getState().setEconomy({ signal: 5, memory_shard: 0 });
    useEconomyStore.getState().setCostEstimate({
      min: { signal: 10, memory_shard: 0 },
      max: { signal: 15, memory_shard: 0 },
    });

    const { container } = render(<EconomyHud />);

    expect(screen.getByText('economy.insufficient_funds')).toBeInTheDocument();
    expect(container.querySelector('.cost-unaffordable')).toBeInTheDocument();
  });

  it('ì˜ˆìƒ ë¹„ìš©ì´ ì—†ì„ ë•Œ ë§ˆì§€ë§‰ í™•ì • ë¹„ìš©ì„ í‘œì‹œí•´ì•¼ í•œë‹¤', () => {
    useEconomyStore.getState().setLastCost({
      turnId: 1,
      cost: { signal: 8, memory_shard: 1 },
      balanceAfter: { signal: 92, memory_shard: 4 },
      modelLabel: 'QUALITY',
    });

    render(<EconomyHud />);

    expect(screen.getByText('economy.confirmed_cost')).toBeInTheDocument();
    expect(screen.getByText('8')).toBeInTheDocument();
    expect(screen.getByText('1')).toBeInTheDocument();
    expect(screen.getByText('economy.model_label.QUALITY')).toBeInTheDocument();
  });

  it('ì”ì•¡ ë¶€ì¡± ì‹œ ê²½ê³  ë° ëŒ€ì•ˆì„ í‘œì‹œí•´ì•¼ í•œë‹¤', () => {
    // ì„ê³„ê°’ 10, í˜„ì¬ ì”ì•¡ 5
    useWorldStore.getState().setEconomy({ signal: 5, memory_shard: 0 });
    useEconomyStore.getState().updateBalanceLowStatus({ signal: 5, memory_shard: 0 });

    render(<EconomyHud />);

    expect(screen.getByText('economy.low_balance_warning')).toBeInTheDocument();
    expect(screen.getByText('economy.alternatives_title')).toBeInTheDocument();
    expect(screen.getByText('economy.alternative_text_only')).toBeInTheDocument();
  });

  it('compact ëª¨ë“œì—ì„œëŠ” ì”ì•¡ë§Œ í‘œì‹œí•´ì•¼ í•œë‹¤', () => {
    useEconomyStore.getState().setCostEstimate({
      min: { signal: 5, memory_shard: 0 },
      max: { signal: 10, memory_shard: 0 },
    });

    render(<EconomyHud compact />);

    // ì”ì•¡ì€ í‘œì‹œë¨
    expect(screen.getByTestId('signal-balance')).toBeInTheDocument();
    // ì˜ˆìƒ ë¹„ìš©ì€ í‘œì‹œë˜ì§€ ì•ŠìŒ
    expect(screen.queryByText('economy.estimated_cost')).not.toBeInTheDocument();
  });

  it('ì›ì¥ ì´ë ¥ì´ ìˆì„ ë•Œ í‘œì‹œí•´ì•¼ í•œë‹¤', () => {
    useEconomyStore.getState().addLedgerEntry({
      turnId: 1,
      reason: 'test reason',
      cost: { signal: 5, memory_shard: 0 },
      balanceAfter: { signal: 95, memory_shard: 5 },
      modelLabel: 'FAST',
    });

    render(<EconomyHud />);

    expect(screen.getByText('economy.ledger_title')).toBeInTheDocument();
    expect(screen.getByText('T1')).toBeInTheDocument();
    expect(screen.getByText('test reason')).toBeInTheDocument();
    expect(screen.getByText('-5')).toBeInTheDocument();
  });
});
</file>

<file path="frontend/src/components/EconomyHud.tsx">
/**
 * Unknown World - Economy HUD ì»´í¬ë„ŒíŠ¸ (U-014[Mvp]).
 *
 * Signal/Memory Shard ì¬í™” ì”ì•¡, ì˜ˆìƒ ë¹„ìš©, í™•ì • ë¹„ìš©ì„ í‘œì‹œí•˜ê³ ,
 * ì”ì•¡ ë¶€ì¡± ì‹œ ê²½ê³  ë° ëŒ€ì•ˆì„ ì•ˆë‚´í•˜ëŠ” ê²Œì„ HUD ì»´í¬ë„ŒíŠ¸ì…ë‹ˆë‹¤.
 *
 * RULE-002 ì¤€ìˆ˜: ì±„íŒ… ë²„ë¸”ì´ ì•„ë‹Œ ê²Œì„ HUD í˜•íƒœ
 * RULE-005 ì¤€ìˆ˜: ì˜ˆìƒ ë¹„ìš© ì‚¬ì „ í‘œì‹œ, ì”ì•¡ ìŒìˆ˜ í‘œì‹œ ë°©ì§€
 * RULE-008 ì¤€ìˆ˜: ë¹„ìš©/ëª¨ë¸ ì„ íƒ ì´ìœ ëŠ” ë¼ë²¨ë¡œë§Œ í‘œì‹œ (í”„ë¡¬í”„íŠ¸ ë…¸ì¶œ ê¸ˆì§€)
 *
 * @see vibe/prd.md 5ì¥ - ì¬í™” ëª©ì /UX ìš”êµ¬
 * @module components/EconomyHud
 */

import { useMemo } from 'react';
import { useTranslation } from 'react-i18next';
import { useShallow } from 'zustand/react/shallow';
import { useWorldStore } from '../stores/worldStore';
import {
  useEconomyStore,
  selectCostEstimate,
  selectLastCost,
  selectIsBalanceLow,
  selectRecentLedger,
  canAffordEstimate,
  type LedgerEntry,
} from '../stores/economyStore';
import type { CurrencyAmount } from '../schemas/turn';

// =============================================================================
// íƒ€ì… ì •ì˜
// =============================================================================

export interface EconomyHudProps {
  /** ê°„ì†Œí™” ëª¨ë“œ (í—¤ë”ìš© - ì”ì•¡ë§Œ í‘œì‹œ) */
  compact?: boolean;
  /** ì¶”ê°€ CSS í´ë˜ìŠ¤ */
  className?: string;
}

// =============================================================================
// ì•„ì´ì½˜ ì»´í¬ë„ŒíŠ¸
// =============================================================================

interface CurrencyIconProps {
  type: 'signal' | 'shard';
  size?: number;
}

function CurrencyIcon({ type, size = 20 }: CurrencyIconProps) {
  const { t } = useTranslation();

  const iconSrc = type === 'signal' ? '/ui/icons/signal-24.png' : '/ui/icons/shard-24.png';
  const fallback = type === 'signal' ? 'âš¡' : 'ğŸ’';
  const label = type === 'signal' ? t('economy.signal') : t('economy.shard');

  return (
    <span className="icon-wrapper" aria-label={label}>
      <img
        src={iconSrc}
        alt=""
        aria-hidden="true"
        className="icon-img"
        style={{ width: size, height: size }}
        onError={(e) => e.currentTarget.classList.add('hidden')}
      />
      <span className="icon-fallback">{fallback}</span>
    </span>
  );
}

// =============================================================================
// ì”ì•¡ í‘œì‹œ ì»´í¬ë„ŒíŠ¸
// =============================================================================

interface BalanceDisplayProps {
  balance: CurrencyAmount;
  isLow?: boolean;
}

function BalanceDisplay({ balance, isLow }: BalanceDisplayProps) {
  const { t } = useTranslation();

  return (
    <div className={`economy-balance ${isLow ? 'balance-low' : ''}`} data-ui-importance="critical">
      <div className="balance-item">
        <CurrencyIcon type="signal" />
        <span className="balance-value" data-testid="signal-balance">
          {balance.signal}
        </span>
        <span className="balance-label">{t('economy.signal')}</span>
      </div>
      <div className="balance-item">
        <CurrencyIcon type="shard" />
        <span className="balance-value" data-testid="shard-balance">
          {balance.memory_shard}
        </span>
        <span className="balance-label">{t('economy.shard')}</span>
      </div>
      {isLow && (
        <div className="balance-warning" aria-live="polite">
          <span className="warning-icon">âš </span>
          <span className="warning-text">{t('economy.low_balance_warning')}</span>
        </div>
      )}
    </div>
  );
}

// =============================================================================
// ë¹„ìš© í‘œì‹œ ì»´í¬ë„ŒíŠ¸
// =============================================================================

interface CostDisplayProps {
  /** ë¹„ìš© ìœ í˜• */
  type: 'estimate' | 'confirmed';
  /** ë¹„ìš© ë²”ìœ„ (ì˜ˆìƒ) */
  min?: CurrencyAmount;
  max?: CurrencyAmount;
  /** í™•ì • ë¹„ìš© */
  cost?: CurrencyAmount;
  /** ê°ë‹¹ ê°€ëŠ¥ ì—¬ë¶€ */
  affordable?: boolean;
  /** ë¼ë²¨ */
  label?: string;
}

function CostDisplay({ type, min, max, cost, affordable, label }: CostDisplayProps) {
  const { t } = useTranslation();

  const isRange =
    min && max && (min.signal !== max.signal || min.memory_shard !== max.memory_shard);

  const titleKey = type === 'estimate' ? 'economy.estimated_cost' : 'economy.confirmed_cost';
  const cssClass = type === 'estimate' ? 'cost-estimate' : 'cost-confirmed';

  return (
    <div
      className={`economy-cost ${cssClass} ${affordable === false ? 'cost-unaffordable' : ''}`}
      data-ui-importance="critical"
    >
      <div className="cost-header">
        <span className="cost-title">{t(titleKey)}</span>
        {label && <span className="cost-label">{label}</span>}
      </div>
      <div className="cost-values">
        {/* Signal ë¹„ìš© */}
        <div className="cost-item">
          <CurrencyIcon type="signal" size={14} />
          <span className="cost-value">
            {type === 'estimate' && min && max
              ? isRange
                ? `${min.signal}~${max.signal}`
                : min.signal
              : cost
                ? cost.signal
                : '-'}
          </span>
        </div>
        {/* Shard ë¹„ìš© (0ë³´ë‹¤ í´ ë•Œë§Œ í‘œì‹œ) */}
        {((type === 'estimate' && max && max.memory_shard > 0) ||
          (type === 'confirmed' && cost && cost.memory_shard > 0)) && (
          <div className="cost-item">
            <span className="cost-separator">|</span>
            <CurrencyIcon type="shard" size={14} />
            <span className="cost-value">
              {type === 'estimate' && min && max
                ? isRange
                  ? `${min.memory_shard}~${max.memory_shard}`
                  : min.memory_shard
                : cost
                  ? cost.memory_shard
                  : '-'}
            </span>
          </div>
        )}
      </div>
      {affordable === false && (
        <div className="cost-warning">
          <span className="warning-text">{t('economy.insufficient_funds')}</span>
        </div>
      )}
    </div>
  );
}

// =============================================================================
// ì›ì¥(Ledger) í•­ëª© ì»´í¬ë„ŒíŠ¸
// =============================================================================

function LedgerItem({ entry }: { entry: LedgerEntry }) {
  const { t } = useTranslation();

  return (
    <div className="ledger-item">
      <div className="ledger-info">
        <span className="ledger-turn">T{entry.turnId}</span>
        <span className="ledger-reason">{entry.reason}</span>
      </div>
      <div className="ledger-values">
        <span className="ledger-cost">
          -{entry.cost.signal}
          {entry.cost.memory_shard > 0 && ` / -${entry.cost.memory_shard}`}
        </span>
        <span
          className="ledger-model"
          title={entry.modelLabel ? t(`economy.model_label.${entry.modelLabel}`) : undefined}
        >
          {entry.modelLabel?.charAt(0)}
        </span>
      </div>
    </div>
  );
}

// =============================================================================
// ì…€ë ‰í„° ì •ì˜ (ì»´í¬ë„ŒíŠ¸ ì™¸ë¶€ì—ì„œ ìƒì„±í•˜ì—¬ ì°¸ì¡° ìœ ì§€)
// =============================================================================

const selectHistory = selectRecentLedger(5);

// =============================================================================
// ë©”ì¸ Economy HUD ì»´í¬ë„ŒíŠ¸
// =============================================================================

export function EconomyHud({ compact = false, className = '' }: EconomyHudProps) {
  const { t } = useTranslation();

  // Store ìƒíƒœ
  const economy = useWorldStore((state) => state.economy);
  const costEstimate = useEconomyStore(selectCostEstimate);
  const lastCost = useEconomyStore(selectLastCost);
  const isBalanceLow = useEconomyStore(selectIsBalanceLow);
  const recentLedger = useEconomyStore(useShallow(selectHistory));

  // ì˜ˆìƒ ë¹„ìš© ê°ë‹¹ ê°€ëŠ¥ ì—¬ë¶€ ê³„ì‚°
  const estimateAffordability = useMemo(() => {
    if (!costEstimate) return null;
    return canAffordEstimate(economy, costEstimate);
  }, [economy, costEstimate]);

  // Compact ëª¨ë“œ (í—¤ë”ìš©): ì”ì•¡ë§Œ í‘œì‹œ
  if (compact) {
    return (
      <div
        className={`economy-hud economy-hud-compact ${className}`}
        role="status"
        aria-live="polite"
      >
        <BalanceDisplay balance={economy} isLow={isBalanceLow} />
      </div>
    );
  }

  // Full ëª¨ë“œ: ì”ì•¡ + ì˜ˆìƒ ë¹„ìš© + í™•ì • ë¹„ìš© + ì›ì¥ ì´ë ¥
  return (
    <div
      className={`economy-hud economy-hud-full ${className}`}
      role="region"
      aria-label={t('economy.hud_label')}
    >
      {/* í˜„ì¬ ì”ì•¡ */}
      <BalanceDisplay balance={economy} isLow={isBalanceLow} />

      {/* ì˜ˆìƒ ë¹„ìš© (ì¹´ë“œ ì„ íƒ/í˜¸ë²„ ì‹œ) */}
      {costEstimate && (
        <CostDisplay
          type="estimate"
          min={costEstimate.min}
          max={costEstimate.max}
          affordable={estimateAffordability?.affordable}
          label={costEstimate.label}
        />
      )}

      {/* ë§ˆì§€ë§‰ í™•ì • ë¹„ìš© (ì˜ˆìƒ ë¹„ìš©ì´ ì—†ì„ ë•Œë§Œ í‘œì‹œ) */}
      {!costEstimate && lastCost && (
        <CostDisplay
          type="confirmed"
          cost={lastCost.cost}
          label={lastCost.modelLabel ? t(`economy.model_label.${lastCost.modelLabel}`) : undefined}
        />
      )}

      {/* ëŒ€ì•ˆ ì•ˆë‚´ (ì”ì•¡ ë¶€ì¡± ì‹œ) */}
      {isBalanceLow && (
        <div className="economy-alternatives" data-ui-importance="critical">
          <div className="alternatives-header">
            <span className="alternatives-icon">ğŸ’¡</span>
            <span className="alternatives-title">{t('economy.alternatives_title')}</span>
          </div>
          <ul className="alternatives-list">
            <li>{t('economy.alternative_text_only')}</li>
            <li>{t('economy.alternative_low_quality')}</li>
          </ul>
        </div>
      )}

      {/* ì›ì¥ ì´ë ¥ (Ledger) */}
      <div className="economy-ledger">
        <div className="ledger-header">
          <span className="ledger-title">{t('economy.ledger_title')}</span>
        </div>
        {recentLedger.length > 0 ? (
          <div className="ledger-list">
            {recentLedger.map((entry) => (
              <LedgerItem key={`${entry.turnId}-${entry.timestamp}`} entry={entry} />
            ))}
          </div>
        ) : (
          <div className="ledger-empty">{t('economy.ledger_empty')}</div>
        )}
      </div>
    </div>
  );
}

// =============================================================================
// í—¤ë”ìš© ê°„ì†Œí™” ì»´í¬ë„ŒíŠ¸ (GameHeader í†µí•©ìš©)
// =============================================================================

export interface EconomyHudHeaderProps {
  signal: number;
  memoryShard: number;
  isLow?: boolean;
}

/**
 * GameHeaderì—ì„œ ì‚¬ìš©í•˜ëŠ” ê°„ì†Œí™”ëœ Economy HUD.
 * ê¸°ì¡´ GameHeaderì˜ economy-hudë¥¼ ëŒ€ì²´í•©ë‹ˆë‹¤.
 */
export function EconomyHudHeader({ signal, memoryShard, isLow }: EconomyHudHeaderProps) {
  const { t } = useTranslation();
  const costEstimate = useEconomyStore(selectCostEstimate);

  // ì˜ˆìƒ ë¹„ìš© ê°ë‹¹ ê°€ëŠ¥ ì—¬ë¶€
  const estimateAffordability = useMemo(() => {
    if (!costEstimate) return null;
    const balance = { signal, memory_shard: memoryShard };
    return canAffordEstimate(balance, costEstimate);
  }, [signal, memoryShard, costEstimate]);

  return (
    <div className={`economy-hud ${isLow ? 'economy-hud-low' : ''}`} data-ui-importance="critical">
      {/* ì”ì•¡ í‘œì‹œ */}
      <span className="icon-wrapper signal-icon" aria-label={t('economy.signal')}>
        <img
          src="/ui/icons/signal-24.png"
          alt=""
          aria-hidden="true"
          className="icon-img"
          onError={(e) => e.currentTarget.classList.add('hidden')}
        />
        <span className="icon-fallback">âš¡</span>
      </span>
      <span className="currency-value" data-testid="header-signal">
        {t('economy.signal')}: {signal}
      </span>
      <span className="icon-wrapper shard-icon" aria-label={t('economy.shard')}>
        <img
          src="/ui/icons/shard-24.png"
          alt=""
          aria-hidden="true"
          className="icon-img"
          onError={(e) => e.currentTarget.classList.add('hidden')}
        />
        <span className="icon-fallback">ğŸ’</span>
      </span>
      <span className="currency-value" data-testid="header-shard">
        {t('economy.shard')}: {memoryShard}
      </span>

      {/* ì˜ˆìƒ ë¹„ìš© ë¯¸ë‹ˆ í‘œì‹œ */}
      {costEstimate && (
        <span
          className={`economy-estimate-mini ${
            estimateAffordability?.affordable === false ? 'unaffordable' : ''
          }`}
          title={t('economy.estimated_cost')}
        >
          <span className="estimate-prefix">â†’</span>
          <span className="estimate-value">
            -{costEstimate.max.signal}
            {costEstimate.max.memory_shard > 0 && `/${costEstimate.max.memory_shard}`}
          </span>
        </span>
      )}

      {/* ì”ì•¡ ë¶€ì¡± ê²½ê³  ì•„ì´ì½˜ */}
      {isLow && (
        <span className="balance-warning-icon" title={t('economy.low_balance_warning')}>
          âš 
        </span>
      )}
    </div>
  );
}

export default EconomyHud;
</file>

<file path="frontend/src/components/InventoryPanel.test.tsx">
import { describe, it, expect, vi, beforeEach } from 'vitest';
import { render, screen, fireEvent } from '@testing-library/react';
import { InventoryPanel } from './InventoryPanel';
import { useInventoryStore } from '../stores/inventoryStore';

// i18next ëª¨í‚¹
vi.mock('react-i18next', () => ({
  useTranslation: () => ({
    t: (key: string) => {
      if (key === 'inventory.empty') return 'Inventory is empty';
      if (key === 'inventory.grid_label') return 'Inventory Grid';
      return key;
    },
  }),
}));

// dnd-kit ëª¨í‚¹ (í•„ìš”ì‹œ)
// dnd-kit hooks often return attributes/listeners/setNodeRef
// For basic rendering test, we might not need to mock them if they don't crash jsdom

describe('InventoryPanel Component', () => {
  beforeEach(() => {
    useInventoryStore.getState().reset();
  });

  it('ì•„ì´í…œì´ ì—†ì„ ë•Œ ë¹ˆ ìƒíƒœ ë©”ì‹œì§€ë¥¼ í‘œì‹œí•´ì•¼ í•œë‹¤', () => {
    render(<InventoryPanel />);
    expect(screen.getByText('Inventory is empty')).toBeInTheDocument();
  });

  it('ì•„ì´í…œì´ ìˆì„ ë•Œ ëª©ë¡ì„ ë Œë”ë§í•´ì•¼ í•œë‹¤', () => {
    const { addItems } = useInventoryStore.getState();
    addItems([
      { id: 'item1', name: 'Item 1', quantity: 1, icon: 'ğŸ' },
      { id: 'item2', name: 'Item 2', quantity: 3, icon: 'ğŸ—¡ï¸' },
    ]);

    render(<InventoryPanel />);

    expect(screen.getByText('Item 1')).toBeInTheDocument();
    expect(screen.getByText('ğŸ')).toBeInTheDocument();
    expect(screen.getByText('Item 2')).toBeInTheDocument();
    expect(screen.getByText('ğŸ—¡ï¸')).toBeInTheDocument();
    expect(screen.getByText('x3')).toBeInTheDocument();
  });

  it('ì•„ì´í…œ í´ë¦­ ì‹œ ì„ íƒë˜ì–´ì•¼ í•œë‹¤', () => {
    const { addItems } = useInventoryStore.getState();
    addItems([{ id: 'item1', name: 'Item 1', quantity: 1 }]);

    render(<InventoryPanel />);

    const item = screen.getByText('Item 1').closest('.inventory-item');
    expect(item).not.toHaveClass('selected');

    fireEvent.click(screen.getByText('Item 1'));

    expect(item).toHaveClass('selected');
    expect(useInventoryStore.getState().selectedItemId).toBe('item1');
  });

  it('disabled í”„ë¡œí”„ê°€ trueì¼ ë•Œ ì•„ì´í…œ í´ë¦­ì´ ë¬´ì‹œë˜ì–´ì•¼ í•œë‹¤', () => {
    const { addItems } = useInventoryStore.getState();
    addItems([{ id: 'item1', name: 'Item 1', quantity: 1 }]);

    render(<InventoryPanel disabled={true} />);

    fireEvent.click(screen.getByText('Item 1'));

    const item = screen.getByText('Item 1').closest('.inventory-item');
    expect(item).not.toHaveClass('selected');
    expect(useInventoryStore.getState().selectedItemId).toBeNull();
  });
});
</file>

<file path="frontend/src/components/MutationTimeline.test.tsx">
import { describe, it, expect, beforeEach, vi } from 'vitest';
import { render, screen } from '@testing-library/react';
import { MutationTimeline } from './MutationTimeline';
import { useWorldStore } from '../stores/worldStore';

vi.mock('react-i18next', () => ({
  useTranslation: () => ({
    t: (key: string, options?: Record<string, unknown>) => {
      if (options?.turn !== undefined) return `T${options.turn}`;
      if (options?.count !== undefined) return `${key} (count: ${options.count})`;
      return key;
    },
  }),
}));

describe('MutationTimeline (U-013)', () => {
  beforeEach(() => {
    useWorldStore.getState().reset();
  });

  it('ë³€í˜• ì´ë ¥ì´ ì—†ì„ ë•Œ ë¹ˆ ìƒíƒœë¥¼ í‘œì‹œí•´ì•¼ í•œë‹¤', () => {
    render(<MutationTimeline />);
    expect(screen.getByText('mutation.empty')).toBeInTheDocument();
  });

  it('ë³€í˜• ì´ë²¤íŠ¸ ëª©ë¡ì„ ìµœì‹ ìˆœìœ¼ë¡œ í‘œì‹œí•´ì•¼ í•œë‹¤', () => {
    useWorldStore.setState({
      mutationTimeline: [
        {
          turn: 2,
          ruleId: 'r2',
          type: 'modified',
          label: 'ìˆ˜ì •ëœ ê·œì¹™',
          timestamp: Date.now(),
        },
        {
          turn: 1,
          ruleId: 'r1',
          type: 'added',
          label: 'ìƒˆ ê·œì¹™',
          timestamp: Date.now() - 1000,
        },
      ],
    });

    render(<MutationTimeline />);
    expect(screen.getByText('mutation.timeline_title')).toBeInTheDocument();
    expect(screen.getAllByText('T2')).toHaveLength(1);
    expect(screen.getByText('ìˆ˜ì •ëœ ê·œì¹™')).toBeInTheDocument();
    expect(screen.getByText('mutation.type.modified')).toBeInTheDocument();

    expect(screen.getAllByText('T1')).toHaveLength(1);
    expect(screen.getByText('ìƒˆ ê·œì¹™')).toBeInTheDocument();
    expect(screen.getByText('mutation.type.added')).toBeInTheDocument();
  });

  it('ì´ë²¤íŠ¸ê°€ ë§ì„ ë•Œ "ë” ë³´ê¸°" í‘œì‹œë¥¼ í•´ì•¼ í•œë‹¤ (ìµœëŒ€ 10ê°œ ê¸°ì¤€)', () => {
    const manyEvents = Array.from({ length: 12 }, (_, i) => ({
      turn: i + 1,
      ruleId: `r${i}`,
      type: 'added' as const,
      label: `ê·œì¹™ ${i}`,
      timestamp: Date.now(),
    })).reverse(); // ìµœì‹ ìˆœ

    useWorldStore.setState({ mutationTimeline: manyEvents });

    const { container } = render(<MutationTimeline />);
    // 10ê°œë§Œ ë Œë”ë§ë¨
    expect(container.getElementsByClassName('timeline-event')).toHaveLength(10);
    // +2ê°œ ë” ë³´ê¸° í‘œì‹œ
    expect(screen.getByText('mutation.more_events (count: 2)')).toBeInTheDocument();
  });
});
</file>

<file path="frontend/src/components/MutationTimeline.tsx">
/**
 * Unknown World - Mutation Timeline (U-013)
 *
 * ê·œì¹™ ë³€í˜• ì´ë²¤íŠ¸ë¥¼ ì‹œê°„ìˆœìœ¼ë¡œ í‘œì‹œí•˜ëŠ” íƒ€ì„ë¼ì¸ ì»´í¬ë„ŒíŠ¸ì…ë‹ˆë‹¤.
 * "ì„¸ê³„ê°€ ë³€í–ˆë‹¤"ë¥¼ UIë¡œ ì²´ê°í•  ìˆ˜ ìˆê²Œ í•©ë‹ˆë‹¤.
 *
 * ì„¤ê³„ ì›ì¹™:
 *   - RULE-002: ì±„íŒ… UIê°€ ì•„ë‹Œ ê²Œì„ UIë¡œ ìƒì‹œ ë…¸ì¶œ
 *   - RULE-006: i18n ê¸°ë°˜ ë¬¸ìì—´ ê´€ë¦¬
 *   - PRD 6.4: Rule Mutation Timeline
 *   - Q1 ê²°ì •: Option B - ë³„ë„ Timeline ì»´í¬ë„ŒíŠ¸ (ê°€ë…ì„±/í™•ì¥ ìš©ì´)
 *
 * @module components/MutationTimeline
 */

import { useTranslation } from 'react-i18next';
import { useWorldStore, selectMutationTimeline } from '../stores/worldStore';
import type { MutationEvent } from '../stores/worldStore';

// =============================================================================
// ìƒìˆ˜
// =============================================================================

/** í‘œì‹œí•  ìµœëŒ€ ì´ë²¤íŠ¸ ìˆ˜ (MMPì—ì„œ ìŠ¤í¬ë¡¤/ìš”ì•½ ì „ëµ ì ìš© ì˜ˆì •) */
const MAX_DISPLAY_EVENTS = 10;

// =============================================================================
// í•˜ìœ„ ì»´í¬ë„ŒíŠ¸
// =============================================================================

interface TimelineEventProps {
  event: MutationEvent;
}

/**
 * ê°œë³„ íƒ€ì„ë¼ì¸ ì´ë²¤íŠ¸ ë Œë”ë§
 */
function TimelineEvent({ event }: TimelineEventProps) {
  const { t } = useTranslation();

  // ì´ë²¤íŠ¸ ìœ í˜•ë³„ ì•„ì´ì½˜
  const typeIcon = {
    added: 'â•',
    modified: 'ğŸ”„',
    removed: 'â–',
  }[event.type];

  // ì´ë²¤íŠ¸ ìœ í˜•ë³„ CSS í´ë˜ìŠ¤
  const typeClass = `timeline-event-${event.type}`;

  return (
    <div className={`timeline-event ${typeClass}`} data-event-type={event.type}>
      <div className="timeline-event-marker">
        <span className="timeline-event-icon" aria-hidden="true">
          {typeIcon}
        </span>
        <span className="timeline-event-turn">
          {t('mutation.turn_label', { turn: event.turn })}
        </span>
      </div>
      <div className="timeline-event-content">
        <span className="timeline-event-label">{event.label}</span>
        <span className="timeline-event-type">{t(`mutation.type.${event.type}`)}</span>
        {event.description && <p className="timeline-event-description">{event.description}</p>}
      </div>
    </div>
  );
}

// =============================================================================
// ë©”ì¸ ì»´í¬ë„ŒíŠ¸
// =============================================================================

/**
 * Mutation Timeline
 *
 * ê·œì¹™ ë³€í˜• ì´ë²¤íŠ¸ë¥¼ ì‹œê°„ìˆœ(ìµœì‹  ë¨¼ì €)ìœ¼ë¡œ í‘œì‹œí•©ë‹ˆë‹¤.
 * worldStoreì˜ mutationTimeline ìƒíƒœë¥¼ êµ¬ë…í•˜ì—¬ ì‹¤ì‹œê°„ ì—…ë°ì´íŠ¸ë©ë‹ˆë‹¤.
 */
export function MutationTimeline() {
  const { t } = useTranslation();
  const mutationTimeline = useWorldStore(selectMutationTimeline);

  // í‘œì‹œí•  ì´ë²¤íŠ¸ (ìµœëŒ€ ê°œìˆ˜ ì œí•œ)
  const displayEvents = mutationTimeline.slice(0, MAX_DISPLAY_EVENTS);
  const hasMore = mutationTimeline.length > MAX_DISPLAY_EVENTS;

  // ë¹ˆ ìƒíƒœ
  if (mutationTimeline.length === 0) {
    return (
      <div className="mutation-timeline-content timeline-empty" data-ui-importance="critical">
        <div className="timeline-empty-icon" aria-hidden="true">
          ğŸ“Š
        </div>
        <p className="timeline-empty-text">{t('mutation.empty')}</p>
      </div>
    );
  }

  return (
    <div className="mutation-timeline-content" data-ui-importance="critical">
      <div className="timeline-header">
        <span className="timeline-title">{t('mutation.timeline_title')}</span>
        <span className="timeline-count">
          {t('mutation.event_count', { count: mutationTimeline.length })}
        </span>
      </div>
      <div className="timeline-events" role="list" aria-label={t('mutation.timeline_title')}>
        {displayEvents.map((event, index) => (
          <TimelineEvent key={`${event.ruleId}-${event.turn}-${index}`} event={event} />
        ))}
      </div>
      {hasMore && (
        <div className="timeline-more">
          <span className="timeline-more-text">
            {t('mutation.more_events', { count: mutationTimeline.length - MAX_DISPLAY_EVENTS })}
          </span>
        </div>
      )}
    </div>
  );
}

export default MutationTimeline;
</file>

<file path="frontend/src/components/NarrativeFeed.tsx">
import { useEffect, useRef } from 'react';
import { useTranslation } from 'react-i18next';
import type { NarrativeEntry } from '../stores/worldStore';

interface NarrativeFeedProps {
  entries: NarrativeEntry[];
  streamingText: string;
}

export function NarrativeFeed({ entries, streamingText }: NarrativeFeedProps) {
  const { t } = useTranslation();
  const feedRef = useRef<HTMLDivElement>(null);

  // ìƒˆ ì—”íŠ¸ë¦¬ ì¶”ê°€ ì‹œ ìŠ¤í¬ë¡¤
  useEffect(() => {
    if (feedRef.current) {
      feedRef.current.scrollTop = feedRef.current.scrollHeight;
    }
  }, [entries, streamingText]);

  return (
    <div className="narrative-feed" ref={feedRef}>
      {entries.map((entry, index) => (
        <div key={`${entry.turn}-${index}`} className="narrative-entry">
          <span className="narrative-timestamp">
            {t('narrative.turn_label', { turn: entry.turn })}
          </span>
          <span className="narrative-text">{entry.text}</span>
        </div>
      ))}
      {streamingText && (
        <div className="narrative-entry streaming">
          <span className="narrative-timestamp">{t('narrative.streaming_label')}</span>
          <span className="narrative-text">{streamingText}</span>
          <span className="cursor-blink">â–Œ</span>
        </div>
      )}
    </div>
  );
}
</file>

<file path="frontend/src/components/QuestPanel.test.tsx">
import { describe, it, expect, beforeEach, vi } from 'vitest';
import { render, screen } from '@testing-library/react';
import { QuestPanel } from './QuestPanel';
import { useWorldStore } from '../stores/worldStore';

// i18next ëª¨í‚¹ (t í•¨ìˆ˜ê°€ í‚¤ë¥¼ ë°˜í™˜í•˜ë„ë¡)
vi.mock('react-i18next', () => ({
  useTranslation: () => ({
    t: (key: string) => key,
  }),
}));

describe('QuestPanel (U-013)', () => {
  beforeEach(() => {
    useWorldStore.getState().reset();
  });

  it('í€˜ìŠ¤íŠ¸ê°€ ì—†ì„ ë•Œ ë¹ˆ ìƒíƒœë¥¼ í‘œì‹œí•´ì•¼ í•œë‹¤', () => {
    render(<QuestPanel />);
    expect(screen.getByText('quest.empty')).toBeInTheDocument();
  });

  it('ì§„í–‰ ì¤‘ì¸ í€˜ìŠ¤íŠ¸ë¥¼ ëª©ë¡ì— í‘œì‹œí•´ì•¼ í•œë‹¤', () => {
    useWorldStore.setState({
      quests: [{ id: 'q1', label: 'ì•¡í‹°ë¸Œ í€˜ìŠ¤íŠ¸', is_completed: false }],
    });

    render(<QuestPanel />);
    expect(screen.getByText('quest.section.active')).toBeInTheDocument();
    expect(screen.getByText('ì•¡í‹°ë¸Œ í€˜ìŠ¤íŠ¸')).toBeInTheDocument();
    expect(screen.getByText('â˜')).toBeInTheDocument();
  });

  it('ì™„ë£Œëœ í€˜ìŠ¤íŠ¸ë¥¼ ëª©ë¡ì— í‘œì‹œí•´ì•¼ í•œë‹¤', () => {
    useWorldStore.setState({
      quests: [{ id: 'q2', label: 'ì™„ë£Œëœ í€˜ìŠ¤íŠ¸', is_completed: true }],
    });

    render(<QuestPanel />);
    expect(screen.getByText('quest.section.completed')).toBeInTheDocument();
    expect(screen.getByText('ì™„ë£Œëœ í€˜ìŠ¤íŠ¸')).toBeInTheDocument();
    expect(screen.getByText('â˜‘')).toBeInTheDocument();
    expect(screen.getByText('quest.completed')).toBeInTheDocument();
  });

  it('ì§„í–‰ ì¤‘ì¸ í€˜ìŠ¤íŠ¸ì™€ ì™„ë£Œëœ í€˜ìŠ¤íŠ¸ë¥¼ ëª¨ë‘ í‘œì‹œí•´ì•¼ í•œë‹¤', () => {
    useWorldStore.setState({
      quests: [
        { id: 'q1', label: 'ì•¡í‹°ë¸Œ', is_completed: false },
        { id: 'q2', label: 'ì™„ë£Œ', is_completed: true },
      ],
    });

    render(<QuestPanel />);
    expect(screen.getByText('ì•¡í‹°ë¸Œ')).toBeInTheDocument();
    expect(screen.getByText('ì™„ë£Œ')).toBeInTheDocument();
  });
});
</file>

<file path="frontend/src/components/QuestPanel.tsx">
/**
 * Unknown World - Quest Panel (U-013)
 *
 * í”Œë ˆì´ì–´ì˜ í˜„ì¬ ëª©í‘œ/ì„œë¸Œëª©í‘œë¥¼ ì²´í¬ë¦¬ìŠ¤íŠ¸ í˜•íƒœë¡œ í‘œì‹œí•©ë‹ˆë‹¤.
 *
 * ì„¤ê³„ ì›ì¹™:
 *   - RULE-002: ì±„íŒ… UIê°€ ì•„ë‹Œ ê²Œì„ UIë¡œ ìƒì‹œ ë…¸ì¶œ
 *   - RULE-006: i18n ê¸°ë°˜ ë¬¸ìì—´ ê´€ë¦¬
 *   - PRD 6.7: Quest/Objective Panel
 *
 * @module components/QuestPanel
 */

import { useTranslation } from 'react-i18next';
import { useWorldStore, selectQuests } from '../stores/worldStore';
import type { Quest } from '../schemas/turn';

// =============================================================================
// í•˜ìœ„ ì»´í¬ë„ŒíŠ¸
// =============================================================================

interface QuestItemProps {
  quest: Quest;
}

/**
 * ê°œë³„ í€˜ìŠ¤íŠ¸ ì•„ì´í…œ ë Œë”ë§
 */
function QuestItem({ quest }: QuestItemProps) {
  const { t } = useTranslation();

  return (
    <li
      className={`quest-item ${quest.is_completed ? 'quest-completed' : 'quest-active'}`}
      data-quest-id={quest.id}
    >
      <span className="quest-checkbox" aria-hidden="true">
        {quest.is_completed ? 'â˜‘' : 'â˜'}
      </span>
      <span className="quest-label">{quest.label}</span>
      {quest.is_completed && <span className="quest-status-badge">{t('quest.completed')}</span>}
    </li>
  );
}

// =============================================================================
// ë©”ì¸ ì»´í¬ë„ŒíŠ¸
// =============================================================================

/**
 * Quest Panel
 *
 * í˜„ì¬ ëª©í‘œ/ì„œë¸Œëª©í‘œë¥¼ ì²´í¬ë¦¬ìŠ¤íŠ¸ í˜•íƒœë¡œ í‘œì‹œí•©ë‹ˆë‹¤.
 * worldStoreì˜ quests ìƒíƒœë¥¼ êµ¬ë…í•˜ì—¬ ì‹¤ì‹œê°„ ì—…ë°ì´íŠ¸ë©ë‹ˆë‹¤.
 */
export function QuestPanel() {
  const { t } = useTranslation();
  const quests = useWorldStore(selectQuests);

  // ì§„í–‰ ì¤‘ / ì™„ë£Œ ë¶„ë¦¬
  const activeQuests = quests.filter((q) => !q.is_completed);
  const completedQuests = quests.filter((q) => q.is_completed);

  // ë¹ˆ ìƒíƒœ
  if (quests.length === 0) {
    return (
      <div className="quest-panel-content quest-empty" data-ui-importance="critical">
        <div className="quest-empty-icon" aria-hidden="true">
          ğŸ“‹
        </div>
        <p className="quest-empty-text">{t('quest.empty')}</p>
      </div>
    );
  }

  return (
    <div className="quest-panel-content" data-ui-importance="critical">
      {/* ì§„í–‰ ì¤‘ì¸ í€˜ìŠ¤íŠ¸ */}
      {activeQuests.length > 0 && (
        <div className="quest-section quest-section-active">
          <h4 className="quest-section-title">{t('quest.section.active')}</h4>
          <ul className="quest-list" role="list" aria-label={t('quest.section.active')}>
            {activeQuests.map((quest) => (
              <QuestItem key={quest.id} quest={quest} />
            ))}
          </ul>
        </div>
      )}

      {/* ì™„ë£Œëœ í€˜ìŠ¤íŠ¸ */}
      {completedQuests.length > 0 && (
        <div className="quest-section quest-section-completed">
          <h4 className="quest-section-title">{t('quest.section.completed')}</h4>
          <ul
            className="quest-list quest-list-completed"
            role="list"
            aria-label={t('quest.section.completed')}
          >
            {completedQuests.map((quest) => (
              <QuestItem key={quest.id} quest={quest} />
            ))}
          </ul>
        </div>
      )}
    </div>
  );
}

export default QuestPanel;
</file>

<file path="frontend/src/components/ResetButton.tsx">
/**
 * Unknown World - ë¦¬ì…‹ ë²„íŠ¼ ì»´í¬ë„ŒíŠ¸ (U-015[Mvp]).
 *
 * 1íšŒ í´ë¦­ìœ¼ë¡œ í˜„ì¬ í”„ë¡œí•„ì˜ ì´ˆê¸° ìƒíƒœë¡œ ë³µêµ¬í•˜ëŠ” ë²„íŠ¼ì…ë‹ˆë‹¤.
 * ë°ëª¨ ë°˜ë³µ ê°€ëŠ¥ì„±ì„ ë³´ì¥í•©ë‹ˆë‹¤.
 *
 * ì„¤ê³„ ì›ì¹™:
 *   - PRD 6.9: ì¦‰ì‹œ ë¦¬ì…‹ 1íšŒë¡œ ë°ëª¨ ë°˜ë³µ ê°€ëŠ¥
 *   - RULE-006: i18n í‚¤ ê¸°ë°˜ ë‹¤êµ­ì–´ ì§€ì›
 *
 * @module components/ResetButton
 */

import { useCallback, useState } from 'react';
import { useTranslation } from 'react-i18next';

// =============================================================================
// íƒ€ì… ì •ì˜
// =============================================================================

export interface ResetButtonProps {
  /** ë¦¬ì…‹ í´ë¦­ ì‹œ í˜¸ì¶œë˜ëŠ” ì½œë°± */
  onReset: () => void;
  /** ë¹„í™œì„±í™” ì—¬ë¶€ */
  disabled?: boolean;
  /** í™•ì¸ í•„ìš” ì—¬ë¶€ (ê¸°ë³¸: true) */
  requireConfirm?: boolean;
  /** ì¶”ê°€ í´ë˜ìŠ¤ëª… */
  className?: string;
  /** ì»´íŒ©íŠ¸ ëª¨ë“œ (ì•„ì´ì½˜ë§Œ í‘œì‹œ) */
  compact?: boolean;
}

// =============================================================================
// ì»´í¬ë„ŒíŠ¸
// =============================================================================

/**
 * ê²Œì„ ë¦¬ì…‹ ë²„íŠ¼.
 * í˜„ì¬ í”„ë¡œí•„ì˜ ì´ˆê¸° ìƒíƒœë¡œ ë³µêµ¬í•©ë‹ˆë‹¤.
 */
export function ResetButton({
  onReset,
  disabled = false,
  requireConfirm = true,
  className = '',
  compact = false,
}: ResetButtonProps) {
  const { t } = useTranslation();
  const [isConfirming, setIsConfirming] = useState(false);

  const handleClick = useCallback(() => {
    if (requireConfirm && !isConfirming) {
      // í™•ì¸ ëª¨ë“œë¡œ ì „í™˜
      setIsConfirming(true);
      // 3ì´ˆ í›„ ìë™ ì·¨ì†Œ
      setTimeout(() => setIsConfirming(false), 3000);
      return;
    }

    // ë¦¬ì…‹ ì‹¤í–‰
    onReset();
    setIsConfirming(false);
  }, [onReset, requireConfirm, isConfirming]);

  const handleCancel = useCallback(() => {
    setIsConfirming(false);
  }, []);

  const buttonText = isConfirming ? t('reset.confirm') : compact ? '' : t('reset.button');

  const buttonAriaLabel = isConfirming ? t('reset.confirm') : t('reset.button');

  return (
    <div className={`reset-button-wrapper ${className}`.trim()}>
      <button
        type="button"
        className={`reset-button ${isConfirming ? 'confirming' : ''} ${compact ? 'compact' : ''}`}
        onClick={handleClick}
        disabled={disabled}
        aria-label={buttonAriaLabel}
        title={t('reset.tooltip')}
      >
        <span className="reset-icon" aria-hidden="true">
          ğŸ”„
        </span>
        {buttonText && <span className="reset-text">{buttonText}</span>}
      </button>

      {isConfirming && requireConfirm && (
        <button
          type="button"
          className="reset-cancel-button"
          onClick={handleCancel}
          aria-label={t('reset.cancel')}
        >
          âœ•
        </button>
      )}
    </div>
  );
}

// =============================================================================
// í”„ë¡œí•„ ë³€ê²½ ë²„íŠ¼ (ë³„ë„ ì»´í¬ë„ŒíŠ¸)
// =============================================================================

export interface ChangeProfileButtonProps {
  /** í´ë¦­ ì‹œ í˜¸ì¶œë˜ëŠ” ì½œë°± */
  onClick: () => void;
  /** ë¹„í™œì„±í™” ì—¬ë¶€ */
  disabled?: boolean;
  /** ì¶”ê°€ í´ë˜ìŠ¤ëª… */
  className?: string;
}

/**
 * í”„ë¡œí•„ ë³€ê²½ ë²„íŠ¼.
 * í´ë¦­ ì‹œ í”„ë¡œí•„ ì„ íƒ í™”ë©´ìœ¼ë¡œ ì´ë™í•©ë‹ˆë‹¤.
 */
export function ChangeProfileButton({
  onClick,
  disabled = false,
  className = '',
}: ChangeProfileButtonProps) {
  const { t } = useTranslation();

  return (
    <button
      type="button"
      className={`change-profile-button ${className}`.trim()}
      onClick={onClick}
      disabled={disabled}
      aria-label={t('profile.change')}
      title={t('profile.change_tooltip')}
    >
      <span className="change-profile-icon" aria-hidden="true">
        ğŸ‘¤
      </span>
      <span className="change-profile-text">{t('profile.change')}</span>
    </button>
  );
}
</file>

<file path="frontend/src/components/RuleBoard.test.tsx">
import { describe, it, expect, beforeEach, vi } from 'vitest';
import { render, screen } from '@testing-library/react';
import { RuleBoard } from './RuleBoard';
import { useWorldStore } from '../stores/worldStore';

vi.mock('react-i18next', () => ({
  useTranslation: () => ({
    t: (key: string, options?: Record<string, unknown>) => {
      if (options?.count !== undefined) return `${key} (count: ${options.count})`;
      return key;
    },
  }),
}));

describe('RuleBoard (U-013)', () => {
  beforeEach(() => {
    useWorldStore.getState().reset();
  });

  it('ê·œì¹™ì´ ì—†ì„ ë•Œ ë¹ˆ ìƒíƒœë¥¼ í‘œì‹œí•´ì•¼ í•œë‹¤', () => {
    render(<RuleBoard />);
    expect(screen.getByText('rule_board.empty')).toBeInTheDocument();
  });

  it('í™œì„± ê·œì¹™ ëª©ë¡ì„ í‘œì‹œí•´ì•¼ í•œë‹¤', () => {
    useWorldStore.setState({
      activeRules: [
        { id: 'r1', label: 'ì¤‘ë ¥', description: 'ë–¨ì–´ì§„ë‹¤' },
        { id: 'r2', label: 'ì‚°ì†Œ', description: 'í•„ìš”í•˜ë‹¤' },
      ],
    });

    render(<RuleBoard />);
    expect(screen.getByText('rule_board.active_count (count: 2)')).toBeInTheDocument();
    expect(screen.getByText('ì¤‘ë ¥')).toBeInTheDocument();
    expect(screen.getByText('ë–¨ì–´ì§„ë‹¤')).toBeInTheDocument();
    expect(screen.getByText('ì‚°ì†Œ')).toBeInTheDocument();
  });
});
</file>

<file path="frontend/src/components/RuleBoard.tsx">
/**
 * Unknown World - Rule Board (U-013)
 *
 * í˜„ì¬ ì„¸ê³„ì— ì ìš© ì¤‘ì¸ ê·œì¹™/ë¬¼ë¦¬ ë²•ì¹™ì„ "ë£° ì¹´ë“œ"ë¡œ í‘œì‹œí•©ë‹ˆë‹¤.
 *
 * ì„¤ê³„ ì›ì¹™:
 *   - RULE-002: ì±„íŒ… UIê°€ ì•„ë‹Œ ê²Œì„ UIë¡œ ìƒì‹œ ë…¸ì¶œ
 *   - RULE-006: i18n ê¸°ë°˜ ë¬¸ìì—´ ê´€ë¦¬
 *   - PRD 6.4/6.7: Rule Mutation + Rule Board
 *
 * @module components/RuleBoard
 */

import { useTranslation } from 'react-i18next';
import { useWorldStore, selectActiveRules } from '../stores/worldStore';
import type { WorldRule } from '../schemas/turn';

// =============================================================================
// í•˜ìœ„ ì»´í¬ë„ŒíŠ¸
// =============================================================================

interface RuleCardProps {
  rule: WorldRule;
}

/**
 * ê°œë³„ ë£° ì¹´ë“œ ë Œë”ë§
 */
function RuleCard({ rule }: RuleCardProps) {
  return (
    <div className="rule-card" data-rule-id={rule.id}>
      <div className="rule-card-header">
        <span className="rule-card-icon" aria-hidden="true">
          âš™
        </span>
        <span className="rule-card-label">{rule.label}</span>
      </div>
      {rule.description && <p className="rule-card-description">{rule.description}</p>}
    </div>
  );
}

// =============================================================================
// ë©”ì¸ ì»´í¬ë„ŒíŠ¸
// =============================================================================

/**
 * Rule Board
 *
 * í˜„ì¬ ì„¸ê³„ì— ì ìš© ì¤‘ì¸ ê·œì¹™ì„ ì¹´ë“œ í˜•íƒœë¡œ í‘œì‹œí•©ë‹ˆë‹¤.
 * worldStoreì˜ activeRules ìƒíƒœë¥¼ êµ¬ë…í•˜ì—¬ ì‹¤ì‹œê°„ ì—…ë°ì´íŠ¸ë©ë‹ˆë‹¤.
 */
export function RuleBoard() {
  const { t } = useTranslation();
  const activeRules = useWorldStore(selectActiveRules);

  // ë¹ˆ ìƒíƒœ
  if (activeRules.length === 0) {
    return (
      <div className="rule-board-content rule-board-empty" data-ui-importance="critical">
        <div className="rule-board-empty-icon" aria-hidden="true">
          ğŸ“œ
        </div>
        <p className="rule-board-empty-text">{t('rule_board.empty')}</p>
      </div>
    );
  }

  return (
    <div className="rule-board-content" data-ui-importance="critical">
      <div className="rule-board-header">
        <span className="rule-board-count">
          {t('rule_board.active_count', { count: activeRules.length })}
        </span>
      </div>
      <div className="rule-card-list">
        {activeRules.map((rule) => (
          <RuleCard key={rule.id} rule={rule} />
        ))}
      </div>
    </div>
  );
}

export default RuleBoard;
</file>

<file path="frontend/src/components/ScannerSlot.test.tsx">
import { describe, it, expect, vi, beforeEach } from 'vitest';
import { render, screen, fireEvent, waitFor } from '@testing-library/react';
import { ScannerSlot } from './ScannerSlot';
import * as scannerApi from '../api/scanner';
import { useInventoryStore } from '../stores/inventoryStore';
import { useAgentStore } from '../stores/agentStore';

// i18next ëª¨í‚¹
vi.mock('react-i18next', () => ({
  useTranslation: () => ({
    t: (key: string, params?: Record<string, unknown>) => {
      if (key === 'scanner.detected_objects') return `${params?.count} objects detected`;
      if (key === 'scanner.item_candidates') return `${params?.count} item candidates`;
      if (key === 'scanner.add_to_inventory') return `Add ${params?.count} items to inventory`;
      return key;
    },
  }),
}));

// URL.createObjectURL ëª¨í‚¹
global.URL.createObjectURL = vi.fn(() => 'mock-url');
global.URL.revokeObjectURL = vi.fn();

describe('ScannerSlot Component', () => {
  const mockLanguage = 'ko-KR';

  const mockScanResponse: scannerApi.ScannerResponse = {
    success: true,
    status: 'completed',
    caption: 'A mysterious artifact found in the desert.',
    objects: [
      {
        label: 'Artifact',
        box_2d: { ymin: 100, xmin: 100, ymax: 200, xmax: 200 },
        confidence: 0.9,
      },
    ],
    item_candidates: [
      {
        id: 'item-1',
        label: 'Glowing Stone',
        description: 'A stone that glows in the dark',
        item_type: 'artifact',
      },
      {
        id: 'item-2',
        label: 'Ancient Script',
        description: 'Unreadable text on a fragment',
        item_type: 'document',
      },
    ],
    analysis_time_ms: 1200,
    language: 'ko-KR',
  };

  beforeEach(() => {
    vi.clearAllMocks();
    useInventoryStore.setState({ items: [] });
    useAgentStore.setState({ isStreaming: false });
  });

  it('renders dropzone in idle state', () => {
    render(<ScannerSlot language={mockLanguage} />);
    expect(screen.getByText('scanner.dropzone_text')).toBeInTheDocument();
    expect(screen.getByText('scanner.dropzone_hint')).toBeInTheDocument();
  });

  it('handles file drop and triggers scanImage', async () => {
    const scanImageSpy = vi.spyOn(scannerApi, 'scanImage').mockResolvedValue({
      success: true,
      data: mockScanResponse,
    });

    render(<ScannerSlot language={mockLanguage} />);

    const dropzone = screen.getByRole('button', { name: /scanner.dropzone_label/i });
    const file = new File(['mock content'], 'test.png', { type: 'image/png' });

    // ë“œë¡­ ì´ë²¤íŠ¸ ì‹œë®¬ë ˆì´ì…˜
    fireEvent.drop(dropzone, {
      dataTransfer: {
        files: [file],
      },
    });

    // ì—…ë¡œë“œ/ë¶„ì„ ìƒíƒœ í™•ì¸
    expect(screen.getByText(/scanner.(uploading|analyzing)/i)).toBeInTheDocument();

    // ê²°ê³¼ ë Œë”ë§ ëŒ€ê¸°
    await waitFor(() => {
      expect(screen.getByText('A mysterious artifact found in the desert.')).toBeInTheDocument();
    });

    expect(scanImageSpy).toHaveBeenCalledWith(file, mockLanguage);
    expect(screen.getByText('Glowing Stone')).toBeInTheDocument();
    expect(screen.getByText('Ancient Script')).toBeInTheDocument();
  });

  it('allows toggling candidate selection', async () => {
    vi.spyOn(scannerApi, 'scanImage').mockResolvedValue({
      success: true,
      data: mockScanResponse,
    });

    render(<ScannerSlot language={mockLanguage} />);

    const dropzone = screen.getByRole('button', { name: /scanner.dropzone_label/i });
    const file = new File(['mock content'], 'test.png', { type: 'image/png' });
    fireEvent.drop(dropzone, { dataTransfer: { files: [file] } });

    await waitFor(() => {
      expect(screen.getByText('Glowing Stone')).toBeInTheDocument();
    });

    // ê¸°ë³¸ì ìœ¼ë¡œ ëª¨ë‘ ì„ íƒë¨ (Option B: UXëŠ” 1ë‹¨ê³„ ì¶”ê°€ë¥¼ ìœ„í•´ ê¸°ë³¸ ì„ íƒ)
    const addButton = screen.getByText('Add 2 items to inventory');
    expect(addButton).not.toBeDisabled();

    // í•˜ë‚˜ í•´ì œ
    fireEvent.click(screen.getByText('Glowing Stone'));
    expect(screen.getByText('Add 1 items to inventory')).toBeInTheDocument();

    // ëª¨ë‘ í•´ì œ
    fireEvent.click(screen.getByText('Ancient Script'));
    expect(screen.getByText('Add 0 items to inventory')).toBeInTheDocument();
    expect(screen.getByText('Add 0 items to inventory')).toBeDisabled();
  });

  it('adds selected items to inventoryStore and resets state', async () => {
    vi.spyOn(scannerApi, 'scanImage').mockResolvedValue({
      success: true,
      data: mockScanResponse,
    });
    const addItemsSpy = vi.spyOn(useInventoryStore.getState(), 'addItems');

    render(<ScannerSlot language={mockLanguage} />);

    const dropzone = screen.getByRole('button', { name: /scanner.dropzone_label/i });
    const file = new File(['mock content'], 'test.png', { type: 'image/png' });
    fireEvent.drop(dropzone, { dataTransfer: { files: [file] } });

    await waitFor(() => {
      expect(screen.getByText('Add 2 items to inventory')).toBeInTheDocument();
    });

    fireEvent.click(screen.getByText('Add 2 items to inventory'));

    expect(addItemsSpy).toHaveBeenCalledWith([
      expect.objectContaining({ id: 'item-1', name: 'Glowing Stone' }),
      expect.objectContaining({ id: 'item-2', name: 'Ancient Script' }),
    ]);

    // ìƒíƒœ ë¦¬ì…‹ í™•ì¸ (idle ìƒíƒœë¡œ ë³µê·€)
    expect(screen.getByText('scanner.dropzone_text')).toBeInTheDocument();
  });

  it('displays error message on scan failure', async () => {
    vi.spyOn(scannerApi, 'scanImage').mockResolvedValue({
      success: false,
      error: 'Analysis failed due to noise',
      status: 'failed',
    });

    render(<ScannerSlot language={mockLanguage} />);

    const dropzone = screen.getByRole('button', { name: /scanner.dropzone_label/i });
    const file = new File(['mock content'], 'test.png', { type: 'image/png' });
    fireEvent.drop(dropzone, { dataTransfer: { files: [file] } });

    await waitFor(() => {
      expect(screen.getByText('Analysis failed due to noise')).toBeInTheDocument();
    });

    expect(screen.getByText('scanner.retry')).toBeInTheDocument();
  });

  it('resets state when cancel is clicked', async () => {
    vi.spyOn(scannerApi, 'scanImage').mockResolvedValue({
      success: true,
      data: mockScanResponse,
    });

    render(<ScannerSlot language={mockLanguage} />);

    const dropzone = screen.getByRole('button', { name: /scanner.dropzone_label/i });
    const file = new File(['mock content'], 'test.png', { type: 'image/png' });
    fireEvent.drop(dropzone, { dataTransfer: { files: [file] } });

    await waitFor(() => {
      expect(screen.getByText('scanner.cancel')).toBeInTheDocument();
    });

    fireEvent.click(screen.getByText('scanner.cancel'));

    // ìƒíƒœ ë¦¬ì…‹ í™•ì¸
    expect(screen.getByText('scanner.dropzone_text')).toBeInTheDocument();
  });

  it('is disabled when isStreaming is true', () => {
    useAgentStore.setState({ isStreaming: true });
    render(<ScannerSlot language={mockLanguage} />);

    const dropzone = screen.getByRole('button', { name: /scanner.dropzone_label/i });
    expect(dropzone).toHaveClass('disabled');
  });
});
</file>

<file path="frontend/src/components/ScannerSlot.tsx">
/**
 * Unknown World - Scanner ìŠ¬ë¡¯ ì»´í¬ë„ŒíŠ¸ (U-022[Mvp]).
 *
 * ì´ë¯¸ì§€ ë“œë/ì—…ë¡œë“œ â†’ ë°±ì—”ë“œ ë¶„ì„ â†’ ì•„ì´í…œ í›„ë³´ í‘œì‹œ â†’ ì¸ë²¤í† ë¦¬ ì¶”ê°€.
 *
 * ì„¤ê³„ ì›ì¹™:
 *   - RULE-002: ì±„íŒ… UI ê¸ˆì§€, ê²Œì„ UIë¡œ í‘œì‹œ
 *   - RULE-004: ì‹¤íŒ¨ ì‹œ ì•ˆì „í•œ í´ë°± (ì—ëŸ¬ í‘œì‹œ)
 *   - PRD 6.7: Scanner ìŠ¬ë¡¯ ë©€í‹°ëª¨ë‹¬ ë°ëª¨ í•µì‹¬
 *
 * í˜ì–´ë§ ì§ˆë¬¸ ê²°ì •:
 *   - Q1: Option B - ì‚¬ìš©ì í™•ì¸ í›„ ì¸ë²¤í† ë¦¬ ì¶”ê°€ (ì˜ë„ í†µì œ)
 *
 * @module components/ScannerSlot
 */

import { useState, useCallback, useRef, type DragEvent, type ChangeEvent } from 'react';
import { useTranslation } from 'react-i18next';
import {
  scanImage,
  isSupportedImageFile,
  candidateToInventoryItem,
  type ScannerResponse,
  type ItemCandidate,
  ALLOWED_MIME_TYPES,
  MAX_FILE_SIZE_BYTES,
} from '../api/scanner';
import { useInventoryStore } from '../stores/inventoryStore';
import { useAgentStore } from '../stores/agentStore';
import type { Language } from '../schemas/turn';

// =============================================================================
// íƒ€ì… ì •ì˜
// =============================================================================

/** Scanner ìŠ¬ë¡¯ ìƒíƒœ */
type ScannerState = 'idle' | 'uploading' | 'analyzing' | 'result' | 'error';

/** ì»´í¬ë„ŒíŠ¸ Props */
interface ScannerSlotProps {
  /** ì„¸ì…˜ ì–¸ì–´ (SSOT) */
  language: Language;
  /** ë¹„í™œì„±í™” ì—¬ë¶€ (ìŠ¤íŠ¸ë¦¬ë° ì¤‘ ë“±) */
  disabled?: boolean;
}

// =============================================================================
// ì»´í¬ë„ŒíŠ¸
// =============================================================================

/**
 * Scanner ìŠ¬ë¡¯ ì»´í¬ë„ŒíŠ¸.
 *
 * ì´ë¯¸ì§€ë¥¼ ë“œë˜ê·¸/ì—…ë¡œë“œí•˜ë©´ ë°±ì—”ë“œ Scanner APIë¥¼ í˜¸ì¶œí•˜ì—¬
 * ì•„ì´í…œ í›„ë³´ë¥¼ ì¶”ì¶œí•˜ê³ , ì‚¬ìš©ìê°€ ì„ íƒí•˜ì—¬ ì¸ë²¤í† ë¦¬ì— ì¶”ê°€í•©ë‹ˆë‹¤.
 */
export function ScannerSlot({ language, disabled = false }: ScannerSlotProps) {
  const { t } = useTranslation();
  const { addItems } = useInventoryStore();
  const { isStreaming } = useAgentStore();

  // ìƒíƒœ
  const [state, setState] = useState<ScannerState>('idle');
  const [isDragOver, setIsDragOver] = useState(false);
  const [errorMessage, setErrorMessage] = useState<string | null>(null);
  const [scanResult, setScanResult] = useState<ScannerResponse | null>(null);
  const [selectedCandidates, setSelectedCandidates] = useState<Set<string>>(new Set());
  const [previewUrl, setPreviewUrl] = useState<string | null>(null);

  // íŒŒì¼ ì…ë ¥ ref
  const fileInputRef = useRef<HTMLInputElement>(null);

  // ì‹¤ì œ ë¹„í™œì„±í™” ìƒíƒœ
  const isDisabled = disabled || isStreaming;

  // =========================================================================
  // í•¸ë“¤ëŸ¬
  // =========================================================================

  /**
   * íŒŒì¼ ì²˜ë¦¬ (ì—…ë¡œë“œ ë° ë¶„ì„).
   */
  const handleFile = useCallback(
    async (file: File) => {
      if (isDisabled) return;

      // íŒŒì¼ í˜•ì‹ ê²€ì¦
      if (!isSupportedImageFile(file)) {
        setErrorMessage(t('scanner.error.unsupported_format'));
        setState('error');
        return;
      }

      // íŒŒì¼ í¬ê¸° ê²€ì¦
      if (file.size > MAX_FILE_SIZE_BYTES) {
        setErrorMessage(t('scanner.error.file_too_large'));
        setState('error');
        return;
      }

      // í”„ë¦¬ë·° ìƒì„±
      const preview = URL.createObjectURL(file);
      setPreviewUrl(preview);

      // ìƒíƒœ ì´ˆê¸°í™”
      setErrorMessage(null);
      setScanResult(null);
      setSelectedCandidates(new Set());
      setState('uploading');

      try {
        setState('analyzing');
        const result = await scanImage(file, language);

        if (result.success) {
          setScanResult(result.data);
          // ê¸°ë³¸ì ìœ¼ë¡œ ëª¨ë“  í›„ë³´ë¥¼ ì„ íƒ
          const allIds = new Set(result.data.item_candidates.map((c) => c.id));
          setSelectedCandidates(allIds);
          setState('result');
        } else {
          setErrorMessage(result.error);
          setState('error');
        }
      } catch {
        setErrorMessage(t('scanner.error.unknown'));
        setState('error');
      }
    },
    [isDisabled, language, t],
  );

  /**
   * ë“œë˜ê·¸ ì˜¤ë²„ í•¸ë“¤ëŸ¬.
   */
  const handleDragOver = useCallback(
    (e: DragEvent<HTMLDivElement>) => {
      e.preventDefault();
      e.stopPropagation();
      if (!isDisabled) {
        setIsDragOver(true);
      }
    },
    [isDisabled],
  );

  /**
   * ë“œë˜ê·¸ ì¢…ë£Œ í•¸ë“¤ëŸ¬.
   */
  const handleDragLeave = useCallback((e: DragEvent<HTMLDivElement>) => {
    e.preventDefault();
    e.stopPropagation();
    setIsDragOver(false);
  }, []);

  /**
   * ë“œë¡­ í•¸ë“¤ëŸ¬.
   */
  const handleDrop = useCallback(
    (e: DragEvent<HTMLDivElement>) => {
      e.preventDefault();
      e.stopPropagation();
      setIsDragOver(false);

      if (isDisabled) return;

      const files = e.dataTransfer.files;
      if (files.length > 0) {
        void handleFile(files[0]);
      }
    },
    [isDisabled, handleFile],
  );

  /**
   * íŒŒì¼ ì„ íƒ í•¸ë“¤ëŸ¬.
   */
  const handleFileChange = useCallback(
    (e: ChangeEvent<HTMLInputElement>) => {
      const files = e.target.files;
      if (files && files.length > 0) {
        void handleFile(files[0]);
      }
      // ì…ë ¥ ì´ˆê¸°í™” (ê°™ì€ íŒŒì¼ ì¬ì„ íƒ í—ˆìš©)
      if (fileInputRef.current) {
        fileInputRef.current.value = '';
      }
    },
    [handleFile],
  );

  /**
   * íŒŒì¼ ì„ íƒ ë²„íŠ¼ í´ë¦­.
   */
  const handleBrowseClick = useCallback(() => {
    if (!isDisabled && fileInputRef.current) {
      fileInputRef.current.click();
    }
  }, [isDisabled]);

  /**
   * í›„ë³´ ì„ íƒ í† ê¸€.
   */
  const handleCandidateToggle = useCallback((candidateId: string) => {
    setSelectedCandidates((prev) => {
      const next = new Set(prev);
      if (next.has(candidateId)) {
        next.delete(candidateId);
      } else {
        next.add(candidateId);
      }
      return next;
    });
  }, []);

  /**
   * ì„ íƒí•œ ì•„ì´í…œì„ ì¸ë²¤í† ë¦¬ì— ì¶”ê°€.
   * Q1 Option B: ì‚¬ìš©ì í™•ì¸ í›„ ì¶”ê°€.
   */
  const handleAddToInventory = useCallback(() => {
    if (!scanResult || selectedCandidates.size === 0) return;

    const selectedItems = scanResult.item_candidates
      .filter((c) => selectedCandidates.has(c.id))
      .map(candidateToInventoryItem);

    addItems(selectedItems);

    // ìƒíƒœ ì´ˆê¸°í™”
    setState('idle');
    setScanResult(null);
    setSelectedCandidates(new Set());
    if (previewUrl) {
      URL.revokeObjectURL(previewUrl);
      setPreviewUrl(null);
    }
  }, [scanResult, selectedCandidates, addItems, previewUrl]);

  /**
   * ì·¨ì†Œ/ë¦¬ì…‹.
   */
  const handleReset = useCallback(() => {
    setState('idle');
    setScanResult(null);
    setSelectedCandidates(new Set());
    setErrorMessage(null);
    if (previewUrl) {
      URL.revokeObjectURL(previewUrl);
      setPreviewUrl(null);
    }
  }, [previewUrl]);

  // =========================================================================
  // ë Œë”ë§
  // =========================================================================

  return (
    <div className="scanner-slot-container">
      {/* ìˆ¨ê²¨ì§„ íŒŒì¼ ì…ë ¥ */}
      <input
        ref={fileInputRef}
        type="file"
        accept={ALLOWED_MIME_TYPES.join(',')}
        onChange={handleFileChange}
        className="visually-hidden"
        aria-label={t('scanner.upload_label')}
      />

      {/* ìƒíƒœë³„ ë Œë”ë§ */}
      {state === 'idle' && (
        <div
          className={`scanner-dropzone ${isDragOver ? 'drag-over' : ''} ${isDisabled ? 'disabled' : ''}`}
          onDragOver={handleDragOver}
          onDragLeave={handleDragLeave}
          onDrop={handleDrop}
          onClick={handleBrowseClick}
          role="button"
          tabIndex={isDisabled ? -1 : 0}
          aria-label={t('scanner.dropzone_label')}
          onKeyDown={(e) => {
            if (e.key === 'Enter' || e.key === ' ') {
              e.preventDefault();
              handleBrowseClick();
            }
          }}
        >
          <div className="scanner-dropzone-icon">ğŸ“·</div>
          <div className="scanner-dropzone-text">{t('scanner.dropzone_text')}</div>
          <div className="scanner-dropzone-hint">{t('scanner.dropzone_hint')}</div>
        </div>
      )}

      {(state === 'uploading' || state === 'analyzing') && (
        <div className="scanner-loading">
          {previewUrl && (
            <div className="scanner-preview">
              <img
                src={previewUrl}
                alt={t('scanner.preview_alt')}
                className="scanner-preview-img"
              />
            </div>
          )}
          <div className="scanner-loading-content">
            <div className="scanner-loading-spinner" />
            <div className="scanner-loading-text">
              {state === 'uploading' ? t('scanner.uploading') : t('scanner.analyzing')}
            </div>
          </div>
        </div>
      )}

      {state === 'error' && (
        <div className="scanner-error">
          {previewUrl && (
            <div className="scanner-preview">
              <img
                src={previewUrl}
                alt={t('scanner.preview_alt')}
                className="scanner-preview-img"
              />
            </div>
          )}
          <div className="scanner-error-content">
            <div className="scanner-error-icon">âš ï¸</div>
            <div className="scanner-error-message">{errorMessage}</div>
            <button type="button" className="scanner-btn scanner-btn-retry" onClick={handleReset}>
              {t('scanner.retry')}
            </button>
          </div>
        </div>
      )}

      {state === 'result' && scanResult && (
        <div className="scanner-result">
          {/* í”„ë¦¬ë·° + ìº¡ì…˜ */}
          <div className="scanner-result-header">
            {previewUrl && (
              <div className="scanner-preview-small">
                <img
                  src={previewUrl}
                  alt={t('scanner.preview_alt')}
                  className="scanner-preview-img-small"
                />
              </div>
            )}
            <div className="scanner-result-info">
              <div className="scanner-caption">{scanResult.caption}</div>
              <div className="scanner-stats">
                {t('scanner.detected_objects', { count: scanResult.objects.length })} â€¢{' '}
                {t('scanner.item_candidates', { count: scanResult.item_candidates.length })}
              </div>
            </div>
          </div>

          {/* ì•„ì´í…œ í›„ë³´ ëª©ë¡ */}
          {scanResult.item_candidates.length > 0 ? (
            <div className="scanner-candidates">
              <div className="scanner-candidates-title">{t('scanner.select_items')}</div>
              <div className="scanner-candidates-list">
                {scanResult.item_candidates.map((candidate) => (
                  <CandidateItem
                    key={candidate.id}
                    candidate={candidate}
                    selected={selectedCandidates.has(candidate.id)}
                    onToggle={() => handleCandidateToggle(candidate.id)}
                  />
                ))}
              </div>
            </div>
          ) : (
            <div className="scanner-no-candidates">{t('scanner.no_candidates')}</div>
          )}

          {/* ì•¡ì…˜ ë²„íŠ¼ */}
          <div className="scanner-actions">
            <button type="button" className="scanner-btn scanner-btn-cancel" onClick={handleReset}>
              {t('scanner.cancel')}
            </button>
            <button
              type="button"
              className="scanner-btn scanner-btn-add"
              onClick={handleAddToInventory}
              disabled={selectedCandidates.size === 0}
            >
              {t('scanner.add_to_inventory', { count: selectedCandidates.size })}
            </button>
          </div>
        </div>
      )}
    </div>
  );
}

// =============================================================================
// ì„œë¸Œ ì»´í¬ë„ŒíŠ¸
// =============================================================================

interface CandidateItemProps {
  candidate: ItemCandidate;
  selected: boolean;
  onToggle: () => void;
}

/**
 * ì•„ì´í…œ í›„ë³´ ì»´í¬ë„ŒíŠ¸.
 */
function CandidateItem({ candidate, selected, onToggle }: CandidateItemProps) {
  const { t } = useTranslation();

  // ì•„ì´í…œ íƒ€ì…ì— ë”°ë¥¸ ì´ëª¨ì§€
  const emoji = getItemTypeEmoji(candidate.item_type);

  return (
    <button
      type="button"
      className={`scanner-candidate ${selected ? 'selected' : ''}`}
      onClick={onToggle}
      aria-pressed={selected}
    >
      <span className="scanner-candidate-checkbox">{selected ? 'â˜‘' : 'â˜'}</span>
      <span className="scanner-candidate-icon">{emoji}</span>
      <span className="scanner-candidate-info">
        <span className="scanner-candidate-name">{candidate.label}</span>
        {candidate.description && (
          <span className="scanner-candidate-desc">{candidate.description}</span>
        )}
        <span className="scanner-candidate-type">
          {t(`scanner.item_type.${candidate.item_type}`, { defaultValue: candidate.item_type })}
        </span>
      </span>
    </button>
  );
}

// =============================================================================
// ìœ í‹¸ë¦¬í‹°
// =============================================================================

function getItemTypeEmoji(itemType: string): string {
  const emojiMap: Record<string, string> = {
    key: 'ğŸ”‘',
    weapon: 'âš”ï¸',
    tool: 'ğŸ”§',
    clue: 'ğŸ”',
    material: 'ğŸ“¦',
    consumable: 'ğŸ’Š',
    document: 'ğŸ“„',
    artifact: 'ğŸ’',
  };
  return emojiMap[itemType] ?? 'ğŸ“¦';
}
</file>

<file path="frontend/src/components/SceneImage.test.tsx">
import { describe, it, expect, vi, beforeEach, afterEach } from 'vitest';
import { render, screen, act } from '@testing-library/react';
import { SceneImage } from './SceneImage';

// react-i18next ëª¨í‚¹
vi.mock('react-i18next', () => ({
  useTranslation: () => ({
    t: (key: string) => key,
  }),
}));

// ì „ì—­ì ìœ¼ë¡œ ì¸ìŠ¤í„´ìŠ¤ë¥¼ ì¶”ì í•˜ê¸° ìœ„í•œ ë°°ì—´
let imageInstances: Array<MockImage> = [];

// Image ê°ì²´ ëª¨í‚¹
class MockImage {
  onload: (() => void) | null = null;
  onerror: (() => void) | null = null;
  _src: string = '';

  constructor() {
    imageInstances.push(this);
  }

  addEventListener(event: string, cb: () => void) {
    if (event === 'load') this.onload = cb;
    if (event === 'error') this.onerror = cb;
  }

  removeEventListener() {}

  set src(val: string) {
    this._src = val;
  }

  get src() {
    return this._src;
  }
}

describe('SceneImage Component (U-020)', () => {
  const originalImage = global.Image;

  beforeEach(() => {
    imageInstances = [];
    global.Image = MockImage as unknown as typeof Image;
  });

  afterEach(() => {
    global.Image = originalImage;
  });

  it('ì´ë¯¸ì§€ URLì´ ì—†ì„ ë•Œ placeholderë¥¼ í‘œì‹œí•´ì•¼ í•¨', () => {
    render(<SceneImage status="default" />);
    expect(screen.getByText('scene.status.default')).toBeInTheDocument();
  });

  it('ìƒˆë¡œìš´ ì´ë¯¸ì§€ URLì´ ì˜¤ë©´ ë¡œë”© ì¸ë””ì¼€ì´í„°ë¥¼ í‘œì‹œí•˜ê³  ì´ì „ ì´ë¯¸ì§€ë¥¼ ìœ ì§€í•´ì•¼ í•¨ (Option A)', async () => {
    const { rerender } = render(<SceneImage status="scene" imageUrl="url-1.png" />);

    // ë¡œë”© ì¤‘ í™•ì¸
    expect(screen.getByText('scene.status.image_loading')).toBeInTheDocument();

    // ì²« ë²ˆì§¸ ì´ë¯¸ì§€ ë¡œë“œ ì™„ë£Œ ì‹œë®¬ë ˆì´ì…˜
    await act(async () => {
      if (imageInstances[0]?.onload) imageInstances[0].onload();
    });

    const img = screen.getByAltText('scene.status.alt');
    expect(img).toHaveAttribute('src', 'url-1.png');

    // ë‘ ë²ˆì§¸ ì´ë¯¸ì§€ ìš”ì²­
    await act(async () => {
      rerender(<SceneImage status="scene" imageUrl="url-2.png" />);
    });

    // ë¡œë”© ì¤‘ í‘œì‹œ í™•ì¸
    expect(screen.getByText('scene.status.image_loading')).toBeInTheDocument();
    // ì´ì „ ì´ë¯¸ì§€(url-1)ê°€ ì—¬ì „íˆ ë³´ì—¬ì•¼ í•¨
    expect(screen.getByAltText('scene.status.alt')).toHaveAttribute('src', 'url-1.png');
  });

  it('ì´ë¯¸ì§€ ë¡œë”©ì´ ì™„ë£Œë˜ë©´ ìƒˆë¡œìš´ ì´ë¯¸ì§€ë¡œ êµì²´ë˜ì–´ì•¼ í•¨', async () => {
    const { rerender } = render(<SceneImage status="scene" imageUrl="url-1.png" />);

    await act(async () => {
      if (imageInstances[0]?.onload) imageInstances[0].onload();
    });

    await act(async () => {
      rerender(<SceneImage status="scene" imageUrl="url-2.png" />);
    });

    // ë‘ ë²ˆì§¸ ì´ë¯¸ì§€ ë¡œë“œ ì™„ë£Œ ì‹œë®¬ë ˆì´ì…˜
    await act(async () => {
      // ìƒˆë¡œìš´ Image ì¸ìŠ¤í„´ìŠ¤ê°€ ìƒì„±ë˜ì—ˆì„ ê²ƒì„
      const secondInstance = imageInstances.find((inst) => inst.src === 'url-2.png');
      if (secondInstance?.onload) secondInstance.onload();
    });

    const img = screen.getByAltText('scene.status.alt');
    expect(img).toHaveAttribute('src', 'url-2.png');
    expect(screen.queryByText('scene.status.image_loading')).not.toBeInTheDocument();
  });

  it('ì´ë¯¸ì§€ ë¡œë”© ì‹¤íŒ¨ ì‹œ ì—ëŸ¬ ë°°ì§€ë¥¼ í‘œì‹œí•˜ê³  ì´ì „ ì´ë¯¸ì§€ë¥¼ ìœ ì§€í•´ì•¼ í•¨ (RULE-004)', async () => {
    const { rerender } = render(<SceneImage status="scene" imageUrl="url-1.png" />);

    await act(async () => {
      if (imageInstances[0]?.onload) imageInstances[0].onload();
    });

    await act(async () => {
      rerender(<SceneImage status="scene" imageUrl="url-2.png" />);
    });

    // ë‘ ë²ˆì§¸ ì´ë¯¸ì§€ ë¡œë“œ ì‹¤íŒ¨ ì‹œë®¬ë ˆì´ì…˜
    await act(async () => {
      const secondInstance = imageInstances.find((inst) => inst.src === 'url-2.png');
      if (secondInstance?.onerror) secondInstance.onerror();
    });

    expect(screen.getByText('scene.status.image_error')).toBeInTheDocument();
    expect(screen.getByAltText('scene.status.alt')).toHaveAttribute('src', 'url-1.png');
  });

  it('ì´ë¯¸ì§€ê°€ ì „í˜€ ì—†ëŠ” ìƒíƒœì—ì„œ ì—ëŸ¬ ë°œìƒ ì‹œ placeholderë¥¼ í‘œì‹œí•´ì•¼ í•¨', async () => {
    render(<SceneImage status="scene" imageUrl="invalid.png" />);

    await act(async () => {
      if (imageInstances[0]?.onerror) imageInstances[0].onerror();
    });

    expect(screen.getByText('scene.status.default')).toBeInTheDocument();
    expect(screen.getByText('âš ï¸')).toBeInTheDocument();
  });
});
</file>

<file path="frontend/src/components/UIControls.tsx">
import { useTranslation } from 'react-i18next';
import { UI_SCALES, type UIScale } from '../stores/uiPrefsStore';

interface UIControlsProps {
  uiScale: UIScale;
  onIncreaseScale: () => void;
  onDecreaseScale: () => void;
}

export function UIControls({ uiScale, onIncreaseScale, onDecreaseScale }: UIControlsProps) {
  const { t } = useTranslation();
  const isMinScale = uiScale === UI_SCALES[0];
  const isMaxScale = uiScale === UI_SCALES[UI_SCALES.length - 1];

  return (
    <div className="ui-controls" role="group" aria-label={t('ui.scale_label')}>
      {/* UI ìŠ¤ì¼€ì¼ ì¡°ì ˆ */}
      <button
        type="button"
        className="ui-scale-btn"
        onClick={onDecreaseScale}
        disabled={isMinScale}
        aria-label={t('ui.scale_decrease')}
        title={`${t('ui.scale_decrease')} (A-)`}
      >
        A-
      </button>
      <span className="ui-scale-display" aria-live="polite">
        {Math.round(uiScale * 100)}%
      </span>
      <button
        type="button"
        className="ui-scale-btn"
        onClick={onIncreaseScale}
        disabled={isMaxScale}
        aria-label={t('ui.scale_increase')}
        title={`${t('ui.scale_increase')} (A+)`}
      >
        A+
      </button>
    </div>
  );
}
</file>

<file path="frontend/src/data/demoProfiles.test.ts">
import { describe, it, expect, vi } from 'vitest';
import { PROFILE_EXPLORER, createSaveGameFromProfile, findProfileById } from './demoProfiles';
import { SAVEGAME_VERSION } from '../save/saveGame';

describe('demoProfiles (U-015[Mvp])', () => {
  const mockT = vi.fn((key: string) => `translated-${key}`);

  it('findProfileByIdëŠ” ì˜¬ë°”ë¥¸ í”„ë¡œí•„ì„ ë°˜í™˜í•´ì•¼ í•œë‹¤', () => {
    const profile = findProfileById('explorer');
    expect(profile).toBeDefined();
    expect(profile?.id).toBe('explorer');
    expect(profile?.icon).toBe('ğŸ§­');
  });

  it('ì¡´ì¬í•˜ì§€ ì•ŠëŠ” IDì— ëŒ€í•´ findProfileByIdëŠ” undefinedë¥¼ ë°˜í™˜í•´ì•¼ í•œë‹¤', () => {
    const profile = findProfileById('non-existent');
    expect(profile).toBeUndefined();
  });

  it('createSaveGameFromProfileì€ í”„ë¡œí•„ ì´ˆê¸° ìƒíƒœë¥¼ SaveGameìœ¼ë¡œ ì˜¬ë°”ë¥´ê²Œ ë³€í™˜í•´ì•¼ í•œë‹¤', () => {
    const saveGame = createSaveGameFromProfile(PROFILE_EXPLORER, 'ko-KR', mockT);

    // ê¸°ë³¸ ë©”íƒ€ë°ì´í„°
    expect(saveGame.version).toBe(SAVEGAME_VERSION);
    expect(saveGame.profileId).toBe('explorer');
    expect(saveGame.language).toBe('ko-KR');
    expect(saveGame.seed).toContain('demo-explorer-');

    // ê²½ì œ ìƒíƒœ
    expect(saveGame.economy.signal).toBe(PROFILE_EXPLORER.initialState.economy.signal);
    expect(saveGame.economy.memory_shard).toBe(PROFILE_EXPLORER.initialState.economy.memory_shard);

    // ì¸ë²¤í† ë¦¬ (ë²ˆì—­ ì ìš© í™•ì¸)
    expect(saveGame.inventory).toHaveLength(PROFILE_EXPLORER.initialState.inventoryDefs.length);
    expect(saveGame.inventory[0].name).toBe(
      `translated-${PROFILE_EXPLORER.initialState.inventoryDefs[0].nameKey}`,
    );

    // í€˜ìŠ¤íŠ¸
    expect(saveGame.quests).toHaveLength(PROFILE_EXPLORER.initialState.questDefs.length);
    expect(saveGame.quests[0].label).toBe(
      `translated-${PROFILE_EXPLORER.initialState.questDefs[0].labelKey}`,
    );

    // ê·œì¹™ ë° íƒ€ì„ë¼ì¸
    expect(saveGame.activeRules).toHaveLength(PROFILE_EXPLORER.initialState.ruleDefs.length);
    expect(saveGame.mutationTimeline).toHaveLength(PROFILE_EXPLORER.initialState.ruleDefs.length);
    expect(saveGame.mutationTimeline[0].type).toBe('added');

    // ë‚´ëŸ¬í‹°ë¸Œ (í™˜ì˜ ë©”ì‹œì§€)
    expect(saveGame.narrativeHistory).toHaveLength(1);
    expect(saveGame.narrativeHistory[0].turn).toBe(0);
    expect(saveGame.narrativeHistory[0].text).toBe(
      `translated-${PROFILE_EXPLORER.initialState.welcomeMessageKey}`,
    );

    // Scene Objects
    expect(saveGame.sceneObjects).toHaveLength(
      PROFILE_EXPLORER.initialState.sceneObjectDefs.length,
    );
    expect(saveGame.sceneObjects[0].box_2d).toEqual(
      PROFILE_EXPLORER.initialState.sceneObjectDefs[0].box_2d,
    );
  });
});
</file>

<file path="frontend/src/main.tsx">
import { StrictMode } from 'react';
import { createRoot } from 'react-dom/client';
import './i18n'; // i18n ì´ˆê¸°í™”
import './style.css';
import App from './App.tsx';

createRoot(document.getElementById('root')!).render(
  <StrictMode>
    <App />
  </StrictMode>,
);
</file>

<file path="frontend/src/save/migrations.test.ts">
import { describe, it, expect } from 'vitest';
import { extractVersion, upgradeToLatest, isMigratableVersion } from './migrations';
import { SAVEGAME_VERSION } from './constants';

describe('SaveGame Migrations (U-041[Mvp])', () => {
  describe('extractVersion', () => {
    it('ê°ì²´ì—ì„œ version í•„ë“œë¥¼ ì˜¬ë°”ë¥´ê²Œ ì¶”ì¶œí•´ì•¼ í•œë‹¤', () => {
      expect(extractVersion({ version: '1.0.0' })).toBe('1.0.0');
      expect(extractVersion({ version: '0.9.0' })).toBe('0.9.0');
    });

    it('ìœ íš¨í•˜ì§€ ì•Šì€ ì…ë ¥ì— ëŒ€í•´ nullì„ ë°˜í™˜í•´ì•¼ í•œë‹¤', () => {
      expect(extractVersion(null)).toBeNull();
      expect(extractVersion(undefined)).toBeNull();
      expect(extractVersion('string')).toBeNull();
      expect(extractVersion({})).toBeNull();
      expect(extractVersion({ ver: '1.0.0' })).toBeNull();
    });
  });

  describe('isMigratableVersion', () => {
    it('ì§€ì›ë˜ëŠ” ë²„ì „ì— ëŒ€í•´ trueë¥¼ ë°˜í™˜í•´ì•¼ í•œë‹¤', () => {
      expect(isMigratableVersion('0.9.0')).toBe(true);
      expect(isMigratableVersion('1.0.0')).toBe(true);
    });

    it('ì§€ì›ë˜ì§€ ì•ŠëŠ” ë²„ì „ì— ëŒ€í•´ falseë¥¼ ë°˜í™˜í•´ì•¼ í•œë‹¤', () => {
      expect(isMigratableVersion('0.1.0')).toBe(false);
      expect(isMigratableVersion('unknown')).toBe(false);
    });
  });

  describe('upgradeToLatest (0.9.0 -> 1.0.0)', () => {
    it('0.9.0 ë°ì´í„°ë¥¼ 1.0.0ìœ¼ë¡œ ì˜¬ë°”ë¥´ê²Œ ë³€í™˜í•´ì•¼ í•œë‹¤', () => {
      const oldData = {
        version: '0.9.0',
        language: 'ko-KR',
        economy: {
          signal: 50,
          memory_shards: 3, // êµ¬ë²„ì „ ì˜¤íƒ€ í•„ë“œ
        },
        // sceneObjects, economyLedger, mutationTimeline ëˆ„ë½ë¨
      };

      const result = upgradeToLatest(oldData, '0.9.0');

      expect(result.success).toBe(true);
      if (result.success) {
        const migrated = result.data as Record<string, unknown>;
        const economy = migrated.economy as Record<string, unknown>;
        expect(migrated.version).toBe('1.0.0');
        expect(economy.signal).toBe(50);
        expect(economy.memory_shard).toBe(3); // ì˜¤íƒ€ ìˆ˜ì •ë¨
        expect(economy.memory_shards).toBeUndefined();
        expect(migrated.sceneObjects).toEqual([]);
        expect(migrated.economyLedger).toEqual([]);
        expect(migrated.mutationTimeline).toEqual([]);
        expect(result.appliedMigrations).toContain('0.9.0 â†’ 1.0.0');
      }
    });

    it('ì˜ëª»ëœ economy ë°ì´í„°ê°€ ìˆì„ ê²½ìš° ê¸°ë³¸ê°’ìœ¼ë¡œ ë³´ì •í•´ì•¼ í•œë‹¤', () => {
      const brokenData = {
        version: '0.9.0',
        economy: {
          signal: -10, // ìŒìˆ˜
          memory_shard: 'invalid', // íƒ€ì… ì˜¤ë¥˜
        },
      };

      const result = upgradeToLatest(brokenData, '0.9.0');

      expect(result.success).toBe(true);
      if (result.success) {
        const migrated = result.data as Record<string, unknown>;
        const economy = migrated.economy as Record<string, unknown>;
        expect(economy.signal).toBe(100); // ê¸°ë³¸ê°’
        expect(economy.memory_shard).toBe(5); // ê¸°ë³¸ê°’
      }
    });

    it('ì´ë¯¸ ìµœì‹  ë²„ì „ì¸ ê²½ìš° ê·¸ëŒ€ë¡œ ë°˜í™˜í•´ì•¼ í•œë‹¤', () => {
      const currentData = { version: SAVEGAME_VERSION, language: 'en-US' };
      const result = upgradeToLatest(currentData, SAVEGAME_VERSION);

      expect(result.success).toBe(true);
      if (result.success) {
        expect(result.data).toBe(currentData);
        expect(result.appliedMigrations).toHaveLength(0);
      }
    });

    it('ì§€ì›ë˜ì§€ ì•ŠëŠ” ë²„ì „ì¸ ê²½ìš° ì‹¤íŒ¨ë¥¼ ë°˜í™˜í•´ì•¼ í•œë‹¤', () => {
      const result = upgradeToLatest({ version: '0.1.0' }, '0.1.0');
      expect(result.success).toBe(false);
      if (!result.success) {
        expect(result.error).toContain('Unsupported version');
      }
    });
  });
});
</file>

<file path="frontend/src/save/migrations.ts">
/**
 * Unknown World - SaveGame ë²„ì „ ë§ˆì´ê·¸ë ˆì´ì…˜ ëª¨ë“ˆ (U-041[Mvp]).
 *
 * SaveGame ìŠ¤í‚¤ë§ˆê°€ ë³€ê²½ë˜ì–´ë„ ê¸°ì¡´ ì €ì¥ ë°ì´í„°ë¥¼ ìµœì‹  ë²„ì „ìœ¼ë¡œ ë³€í™˜í•˜ì—¬
 * ë°ëª¨ ë£¨í”„ê°€ ëŠê¸°ì§€ ì•Šë„ë¡ í•©ë‹ˆë‹¤.
 *
 * ì„¤ê³„ ì›ì¹™:
 *   - RULE-005: economy ë§ˆì´ê·¸ë ˆì´ì…˜ ì‹œ ì”ì•¡ ìŒìˆ˜ ê¸ˆì§€
 *   - RULE-010: ë²„ì „/ìŠ¤íƒ ê³ ì •, ì„ì˜ ë³€ê²½ ê¸ˆì§€
 *   - U-041: "ë²„ì „ íŒë³„ â†’ ë§ˆì´ê·¸ë ˆì´ì…˜ â†’ ê²€ì¦" íë¦„
 *
 * @module save/migrations
 */

import { SAVEGAME_VERSION, SUPPORTED_SAVEGAME_VERSIONS } from './constants';

// =============================================================================
// íƒ€ì… ì •ì˜
// =============================================================================

/**
 * ë‹¨ì¼ ë§ˆì´ê·¸ë ˆì´ì…˜ ë‹¨ê³„.
 *
 * from ë²„ì „ì—ì„œ to ë²„ì „ìœ¼ë¡œ SaveGame ë°ì´í„°ë¥¼ ë³€í™˜í•©ë‹ˆë‹¤.
 */
export interface Migration {
  /** ì†ŒìŠ¤ ë²„ì „ */
  from: string;
  /** íƒ€ê²Ÿ ë²„ì „ */
  to: string;
  /** ë³€í™˜ í•¨ìˆ˜ - unknown ì…ë ¥ì„ ë°›ì•„ unknown ì¶œë ¥ (ìŠ¤í‚¤ë§ˆ ê²€ì¦ì€ ìµœì¢… ë‹¨ê³„ì—ì„œ) */
  migrate: (input: unknown) => unknown;
  /** ë§ˆì´ê·¸ë ˆì´ì…˜ ì„¤ëª… (ë¡œê¹…/ë””ë²„ê·¸ìš©) */
  description: string;
}

/**
 * ë§ˆì´ê·¸ë ˆì´ì…˜ ê²°ê³¼.
 */
export interface MigrationResult {
  success: true;
  data: unknown;
  migratedFrom: string;
  migratedTo: string;
  appliedMigrations: string[];
}

/**
 * ë§ˆì´ê·¸ë ˆì´ì…˜ ì‹¤íŒ¨ ê²°ê³¼.
 */
export interface MigrationFailure {
  success: false;
  error: string;
  originalVersion: string;
}

export type MigrationOutcome = MigrationResult | MigrationFailure;

// =============================================================================
// ë§ˆì´ê·¸ë ˆì´ì…˜ ì²´ì¸ ì •ì˜
// =============================================================================

/**
 * ë²„ì „ ìˆœì„œ ë§µ.
 *
 * ë§ˆì´ê·¸ë ˆì´ì…˜ ê²½ë¡œë¥¼ ê²°ì •í•˜ê¸° ìœ„í•œ ë²„ì „ ìˆœì„œì…ë‹ˆë‹¤.
 * ë‚®ì€ ì¸ë±ìŠ¤ = ë” ì˜¤ë˜ëœ ë²„ì „
 */
const VERSION_ORDER: readonly string[] = [
  '0.9.0', // ì˜ˆì‹œ êµ¬ë²„ì „ (í…ŒìŠ¤íŠ¸/ë°ëª¨ìš©)
  '1.0.0', // í˜„ì¬ ë²„ì „
] as const;

/**
 * ë²„ì „ë³„ ë§ˆì´ê·¸ë ˆì´ì…˜ ì •ì˜.
 *
 * ê° ë§ˆì´ê·¸ë ˆì´ì…˜ì€ from â†’ to ë³€í™˜ì„ ì •ì˜í•©ë‹ˆë‹¤.
 * ì²´ì¸ìœ¼ë¡œ ì—°ê²°ë˜ì–´ ì—¬ëŸ¬ ë²„ì „ì„ ê±´ë„ˆë›°ì–´ë„ ìˆœì°¨ ì ìš©ë©ë‹ˆë‹¤.
 */
const MIGRATIONS: readonly Migration[] = [
  {
    from: '0.9.0',
    to: '1.0.0',
    description: '0.9.0 â†’ 1.0.0: sceneObjects í•„ë“œ ì¶”ê°€, economy í•„ë“œëª… ì •ê·œí™”',
    migrate: (input: unknown): unknown => {
      const data = input as Record<string, unknown>;

      // 1. sceneObjects í•„ë“œê°€ ì—†ìœ¼ë©´ ë¹ˆ ë°°ì—´ë¡œ ì¶”ê°€
      if (!Array.isArray(data.sceneObjects)) {
        data.sceneObjects = [];
      }

      // 2. economy í•„ë“œ ì •ê·œí™” (legacy í˜•ì‹ ì§€ì›)
      if (data.economy && typeof data.economy === 'object') {
        const economy = data.economy as Record<string, unknown>;

        // legacy: memory_shards â†’ memory_shard (ì˜¤íƒ€ ìˆ˜ì •)
        if ('memory_shards' in economy && !('memory_shard' in economy)) {
          economy.memory_shard = economy.memory_shards;
          delete economy.memory_shards;
        }

        // ê¸°ë³¸ê°’ ë³´ì¥ (RULE-005: ì”ì•¡ ìŒìˆ˜ ê¸ˆì§€)
        if (typeof economy.signal !== 'number' || economy.signal < 0) {
          economy.signal = 100;
        }
        if (typeof economy.memory_shard !== 'number' || economy.memory_shard < 0) {
          economy.memory_shard = 5;
        }
      }

      // 3. economyLedger í•„ë“œê°€ ì—†ìœ¼ë©´ ë¹ˆ ë°°ì—´ë¡œ ì¶”ê°€
      if (!Array.isArray(data.economyLedger)) {
        data.economyLedger = [];
      }

      // 4. mutationTimeline í•„ë“œê°€ ì—†ìœ¼ë©´ ë¹ˆ ë°°ì—´ë¡œ ì¶”ê°€
      if (!Array.isArray(data.mutationTimeline)) {
        data.mutationTimeline = [];
      }

      // 5. ë²„ì „ ì—…ë°ì´íŠ¸
      data.version = '1.0.0';

      return data;
    },
  },
] as const;

// =============================================================================
// ë§ˆì´ê·¸ë ˆì´ì…˜ ìœ í‹¸ë¦¬í‹°
// =============================================================================

/**
 * ë²„ì „ ì¸ë±ìŠ¤ë¥¼ ë°˜í™˜í•©ë‹ˆë‹¤.
 *
 * @param version - ë²„ì „ ë¬¸ìì—´
 * @returns ë²„ì „ ì¸ë±ìŠ¤ ë˜ëŠ” -1 (ì•Œ ìˆ˜ ì—†ëŠ” ë²„ì „)
 */
function getVersionIndex(version: string): number {
  return VERSION_ORDER.indexOf(version);
}

/**
 * ë²„ì „ì´ ë§ˆì´ê·¸ë ˆì´ì…˜ ê°€ëŠ¥í•œì§€ í™•ì¸í•©ë‹ˆë‹¤.
 *
 * @param version - í™•ì¸í•  ë²„ì „
 * @returns ë§ˆì´ê·¸ë ˆì´ì…˜ ê°€ëŠ¥ ì—¬ë¶€
 */
export function isMigratableVersion(version: string): boolean {
  return VERSION_ORDER.includes(version);
}

/**
 * ë²„ì „ì´ ì§€ì›ë˜ëŠ” ë²„ì „ì¸ì§€ í™•ì¸í•©ë‹ˆë‹¤.
 *
 * @param version - í™•ì¸í•  ë²„ì „
 * @returns ì§€ì› ì—¬ë¶€
 */
export function isSupportedVersion(version: string): boolean {
  return SUPPORTED_SAVEGAME_VERSIONS.includes(version);
}

/**
 * ë²„ì „ ê°„ ë§ˆì´ê·¸ë ˆì´ì…˜ ê²½ë¡œë¥¼ ì°¾ìŠµë‹ˆë‹¤.
 *
 * @param fromVersion - ì†ŒìŠ¤ ë²„ì „
 * @param toVersion - íƒ€ê²Ÿ ë²„ì „
 * @returns ì ìš©í•  ë§ˆì´ê·¸ë ˆì´ì…˜ ëª©ë¡ (ìˆœì„œëŒ€ë¡œ)
 */
function findMigrationPath(fromVersion: string, toVersion: string): Migration[] {
  const fromIndex = getVersionIndex(fromVersion);
  const toIndex = getVersionIndex(toVersion);

  if (fromIndex === -1 || toIndex === -1) {
    return [];
  }

  if (fromIndex >= toIndex) {
    // ë‹¤ìš´ê·¸ë ˆì´ë“œëŠ” ì§€ì›í•˜ì§€ ì•ŠìŒ
    return [];
  }

  const path: Migration[] = [];
  let currentVersion = fromVersion;

  while (currentVersion !== toVersion) {
    const migration = MIGRATIONS.find((m) => m.from === currentVersion);
    if (!migration) {
      // ë§ˆì´ê·¸ë ˆì´ì…˜ ê²½ë¡œê°€ ëŠê¹€
      break;
    }
    path.push(migration);
    currentVersion = migration.to;
  }

  return path;
}

// =============================================================================
// ê³µê°œ API
// =============================================================================

/**
 * SaveGameì„ ìµœì‹  ë²„ì „ìœ¼ë¡œ ì—…ê·¸ë ˆì´ë“œí•©ë‹ˆë‹¤.
 *
 * @param input - ë§ˆì´ê·¸ë ˆì´ì…˜í•  SaveGame ë°ì´í„° (unknown)
 * @param fromVersion - í˜„ì¬ ë²„ì „
 * @returns ë§ˆì´ê·¸ë ˆì´ì…˜ ê²°ê³¼
 */
export function upgradeToLatest(input: unknown, fromVersion: string): MigrationOutcome {
  // ì´ë¯¸ ìµœì‹  ë²„ì „ì´ë©´ ê·¸ëŒ€ë¡œ ë°˜í™˜
  if (fromVersion === SAVEGAME_VERSION) {
    return {
      success: true,
      data: input,
      migratedFrom: fromVersion,
      migratedTo: SAVEGAME_VERSION,
      appliedMigrations: [],
    };
  }

  // ë§ˆì´ê·¸ë ˆì´ì…˜ ê°€ëŠ¥í•œ ë²„ì „ì¸ì§€ í™•ì¸
  if (!isMigratableVersion(fromVersion)) {
    return {
      success: false,
      error: `Unsupported version: ${fromVersion}. Cannot migrate.`,
      originalVersion: fromVersion,
    };
  }

  // ë§ˆì´ê·¸ë ˆì´ì…˜ ê²½ë¡œ ì°¾ê¸°
  const migrationPath = findMigrationPath(fromVersion, SAVEGAME_VERSION);
  if (migrationPath.length === 0) {
    return {
      success: false,
      error: `No migration path found from ${fromVersion} to ${SAVEGAME_VERSION}`,
      originalVersion: fromVersion,
    };
  }

  // ë§ˆì´ê·¸ë ˆì´ì…˜ ìˆœì°¨ ì ìš©
  let currentData: unknown = input;
  const appliedMigrations: string[] = [];

  for (const migration of migrationPath) {
    try {
      console.log(`[Migration] Applying: ${migration.description}`);
      currentData = migration.migrate(currentData);
      appliedMigrations.push(`${migration.from} â†’ ${migration.to}`);
    } catch (error) {
      return {
        success: false,
        error: `Migration failed at ${migration.from} â†’ ${migration.to}: ${error}`,
        originalVersion: fromVersion,
      };
    }
  }

  return {
    success: true,
    data: currentData,
    migratedFrom: fromVersion,
    migratedTo: SAVEGAME_VERSION,
    appliedMigrations,
  };
}

/**
 * JSON ë°ì´í„°ì—ì„œ ë²„ì „ì„ ì•ˆì „í•˜ê²Œ ì¶”ì¶œí•©ë‹ˆë‹¤.
 *
 * ìµœì†Œí•œì˜ íŒŒì‹±ë§Œ ìˆ˜í–‰í•˜ì—¬ ë²„ì „ì„ í™•ì¸í•©ë‹ˆë‹¤.
 * ì „ì²´ ìŠ¤í‚¤ë§ˆ ê²€ì¦ ì „ì— ë²„ì „ì„ ë¨¼ì € í™•ì¸í•˜ê¸° ìœ„í•œ í—¬í¼ì…ë‹ˆë‹¤.
 *
 * @param data - íŒŒì‹±ëœ JSON ë°ì´í„° (unknown)
 * @returns ë²„ì „ ë¬¸ìì—´ ë˜ëŠ” null
 */
export function extractVersion(data: unknown): string | null {
  if (typeof data !== 'object' || data === null) {
    return null;
  }

  const obj = data as Record<string, unknown>;
  if (typeof obj.version === 'string' && obj.version.length > 0) {
    return obj.version;
  }

  return null;
}

/**
 * ë§ˆì´ê·¸ë ˆì´ì…˜ í†µê³„ë¥¼ ë°˜í™˜í•©ë‹ˆë‹¤.
 *
 * ë””ë²„ê·¸/ë¡œê¹…ìš©ìœ¼ë¡œ í˜„ì¬ ë§ˆì´ê·¸ë ˆì´ì…˜ ì‹œìŠ¤í…œì˜ ìƒíƒœë¥¼ í™•ì¸í•©ë‹ˆë‹¤.
 */
export function getMigrationStats(): {
  currentVersion: string;
  supportedVersions: readonly string[];
  migratableVersions: readonly string[];
  migrationCount: number;
} {
  return {
    currentVersion: SAVEGAME_VERSION,
    supportedVersions: SUPPORTED_SAVEGAME_VERSIONS,
    migratableVersions: VERSION_ORDER,
    migrationCount: MIGRATIONS.length,
  };
}
</file>

<file path="frontend/src/save/sessionLifecycle.test.ts">
import { describe, it, expect, beforeEach, vi } from 'vitest';
import {
  bootstrapSession,
  startSessionFromProfile,
  continueSession,
  resetToCurrentProfile,
  clearSessionAndReturnToSelect,
  saveCurrentSession,
  getInitialProfileId,
} from './sessionLifecycle';
import { useWorldStore } from '../stores/worldStore';
import { useInventoryStore } from '../stores/inventoryStore';
import { useEconomyStore } from '../stores/economyStore';
import { SAVEGAME_STORAGE_KEY, CURRENT_PROFILE_KEY, SAVEGAME_VERSION } from './constants';
import { PROFILE_EXPLORER } from '../data/demoProfiles';
import * as i18nModule from '../i18n';

// i18n ëª¨ë“ˆ mock
vi.mock('../i18n', async () => {
  const actual = await vi.importActual('../i18n');
  return {
    ...actual,
    changeLanguage: vi.fn().mockResolvedValue(undefined),
    getResolvedLanguage: vi.fn().mockReturnValue('ko-KR'),
  };
});

describe('sessionLifecycle (RU-004[Mvp])', () => {
  const mockT = (key: string) => `translated-${key}`;

  beforeEach(() => {
    localStorage.clear();
    vi.clearAllMocks();

    // Store ì´ˆê¸°í™”
    useWorldStore.getState().reset();
    useInventoryStore.getState().reset();
    useEconomyStore.getState().reset();
  });

  describe('bootstrapSession', () => {
    it('ì„¸ì´ë¸Œ ë°ì´í„°ê°€ ì—†ìœ¼ë©´ profile_select phaseë¥¼ ë°˜í™˜í•´ì•¼ í•œë‹¤', () => {
      const result = bootstrapSession();
      expect(result.phase).toBe('profile_select');
      if (result.phase === 'profile_select') {
        expect(result.savedGameAvailable).toBe(false);
      }
    });

    it('ìœ íš¨í•œ ì„¸ì´ë¸Œ ë°ì´í„°ê°€ ìˆìœ¼ë©´ playing phaseë¥¼ ë°˜í™˜í•´ì•¼ í•œë‹¤', () => {
      // ìœ íš¨í•œ ì„¸ì´ë¸Œ ìƒì„± ë° ì €ì¥
      const saveGame = {
        version: SAVEGAME_VERSION,
        language: 'ko-KR',
        profileId: 'explorer',
        savedAt: new Date().toISOString(),
        economy: { signal: 100, memory_shard: 5 },
        economyLedger: [],
        turnCount: 1,
        narrativeHistory: [],
        inventory: [],
        quests: [],
        activeRules: [],
        mutationTimeline: [],
        sceneObjects: [],
      };
      localStorage.setItem(SAVEGAME_STORAGE_KEY, JSON.stringify(saveGame));

      const result = bootstrapSession();
      expect(result.phase).toBe('playing');
      if (result.phase === 'playing') {
        expect(result.profileId).toBe('explorer');
      }
    });
  });

  describe('startSessionFromProfile', () => {
    it('í”„ë¡œí•„ ê¸°ë°˜ìœ¼ë¡œ ì„¸ì…˜ì„ ì‹œì‘í•˜ê³  storeì™€ localStorageë¥¼ ì—…ë°ì´íŠ¸í•´ì•¼ í•œë‹¤', () => {
      const result = startSessionFromProfile({
        profile: PROFILE_EXPLORER,
        t: mockT,
      });

      expect(result.success).toBe(true);
      expect(result.profileId).toBe(PROFILE_EXPLORER.id);

      // Store ìƒíƒœ í™•ì¸
      const worldState = useWorldStore.getState();
      expect(worldState.economy.signal).toBe(PROFILE_EXPLORER.initialState.economy.signal);
      expect(worldState.turnCount).toBe(0);
      expect(worldState.narrativeEntries).toHaveLength(1);

      const inventoryState = useInventoryStore.getState();
      expect(inventoryState.items).toHaveLength(PROFILE_EXPLORER.initialState.inventoryDefs.length);

      // localStorage í™•ì¸
      expect(localStorage.getItem(CURRENT_PROFILE_KEY)).toBe(PROFILE_EXPLORER.id);
      expect(localStorage.getItem(SAVEGAME_STORAGE_KEY)).not.toBeNull();
    });
  });

  describe('continueSession', () => {
    it('ì €ì¥ëœ ë°ì´í„°ë¥¼ ë¡œë“œí•˜ê³  storeë¥¼ ë³µì›í•´ì•¼ í•œë‹¤', async () => {
      const saveGame = {
        version: SAVEGAME_VERSION,
        language: 'en-US',
        profileId: 'explorer',
        savedAt: new Date().toISOString(),
        economy: { signal: 123, memory_shard: 45 },
        economyLedger: [],
        turnCount: 5,
        narrativeHistory: [{ turn: 1, text: 'old message' }],
        inventory: [{ id: 'item1', name: 'Item 1', quantity: 2 }],
        quests: [],
        activeRules: [],
        mutationTimeline: [],
        sceneObjects: [],
      };
      localStorage.setItem(SAVEGAME_STORAGE_KEY, JSON.stringify(saveGame));

      const result = await continueSession();

      expect(result?.success).toBe(true);
      expect(result?.profileId).toBe('explorer');

      // ì–¸ì–´ ë³€ê²½ í˜¸ì¶œ í™•ì¸
      expect(i18nModule.changeLanguage).toHaveBeenCalledWith('en-US');

      // Store ìƒíƒœ í™•ì¸
      const worldState = useWorldStore.getState();
      expect(worldState.economy.signal).toBe(123);
      expect(worldState.turnCount).toBe(5);
      expect(worldState.narrativeEntries).toHaveLength(1);

      const inventoryState = useInventoryStore.getState();
      expect(inventoryState.items).toHaveLength(1);
      expect(inventoryState.items[0].id).toBe('item1');
    });

    it('ë°ì´í„°ê°€ ì—†ìœ¼ë©´ nullì„ ë°˜í™˜í•˜ê³  í´ë¦°ì—…í•´ì•¼ í•œë‹¤', async () => {
      localStorage.setItem(CURRENT_PROFILE_KEY, 'some-profile');

      const result = await continueSession();

      expect(result).toBeNull();
      expect(localStorage.getItem(SAVEGAME_STORAGE_KEY)).toBeNull();
      expect(localStorage.getItem(CURRENT_PROFILE_KEY)).toBeNull();
    });
  });

  describe('resetToCurrentProfile', () => {
    it('í˜„ì¬ í”„ë¡œí•„ë¡œ ì„¸ì…˜ì„ ë¦¬ì…‹í•´ì•¼ í•œë‹¤', () => {
      // ë¨¼ì € ì„¸ì…˜ ì‹œì‘
      startSessionFromProfile({
        profile: PROFILE_EXPLORER,
        t: mockT,
      });

      // ìƒíƒœ ë³€ê²½ ì‹œë®¬ë ˆì´ì…˜
      useWorldStore.setState({ turnCount: 10, economy: { signal: 0, memory_shard: 0 } });

      const result = resetToCurrentProfile({
        t: mockT,
        currentProfileId: PROFILE_EXPLORER.id,
      });

      expect(result.success).toBe(true);
      expect(result.profileId).toBe(PROFILE_EXPLORER.id);

      // ì´ˆê¸° ìƒíƒœë¡œ ë³µì›ë˜ì—ˆëŠ”ì§€ í™•ì¸
      const worldState = useWorldStore.getState();
      expect(worldState.turnCount).toBe(0);
      expect(worldState.economy.signal).toBe(PROFILE_EXPLORER.initialState.economy.signal);
    });
  });

  describe('clearSessionAndReturnToSelect', () => {
    it('ëª¨ë“  ë°ì´í„°ë¥¼ ì‚­ì œí•˜ê³  storeë¥¼ ì´ˆê¸°í™”í•´ì•¼ í•œë‹¤', () => {
      // ë°ì´í„° ì±„ìš°ê¸°
      startSessionFromProfile({
        profile: PROFILE_EXPLORER,
        t: mockT,
      });

      clearSessionAndReturnToSelect();

      expect(localStorage.getItem(SAVEGAME_STORAGE_KEY)).toBeNull();
      expect(localStorage.getItem(CURRENT_PROFILE_KEY)).toBeNull();

      const worldState = useWorldStore.getState();
      expect(worldState.narrativeEntries).toHaveLength(0);
    });
  });

  describe('saveCurrentSession', () => {
    it('í˜„ì¬ ìƒíƒœë¥¼ localStorageì— ì €ì¥í•´ì•¼ í•œë‹¤', () => {
      startSessionFromProfile({
        profile: PROFILE_EXPLORER,
        t: mockT,
      });

      // ìƒíƒœ ë³€ê²½
      useWorldStore.setState({ turnCount: 1 });

      const success = saveCurrentSession(PROFILE_EXPLORER.id);
      expect(success).toBe(true);

      const saved = JSON.parse(localStorage.getItem(SAVEGAME_STORAGE_KEY)!);
      expect(saved.turnCount).toBe(1);
    });
  });

  describe('getInitialProfileId', () => {
    it('ì„¸ì´ë¸Œ ë°ì´í„°ê°€ ìˆìœ¼ë©´ ê·¸ ì•ˆì˜ profileIdë¥¼ ìš°ì„ í•´ì•¼ í•œë‹¤', () => {
      localStorage.setItem(
        SAVEGAME_STORAGE_KEY,
        JSON.stringify({
          version: SAVEGAME_VERSION,
          language: 'ko-KR',
          profileId: 'saved-profile',
          savedAt: new Date().toISOString(),
          economy: { signal: 100, memory_shard: 5 },
          economyLedger: [],
          turnCount: 1,
          narrativeHistory: [],
          inventory: [],
          quests: [],
          activeRules: [],
          mutationTimeline: [],
          sceneObjects: [],
        }),
      );
      localStorage.setItem(CURRENT_PROFILE_KEY, 'fallback-profile');

      expect(getInitialProfileId()).toBe('saved-profile');
    });

    it('ì„¸ì´ë¸Œ ë°ì´í„°ê°€ ì—†ìœ¼ë©´ CURRENT_PROFILE_KEYë¥¼ ì‚¬ìš©í•´ì•¼ í•œë‹¤', () => {
      localStorage.setItem(CURRENT_PROFILE_KEY, 'fallback-profile');
      expect(getInitialProfileId()).toBe('fallback-profile');
    });
  });
});
</file>

<file path="frontend/src/schemas/index.ts">
/**
 * Unknown World - ìŠ¤í‚¤ë§ˆ ëª¨ë“ˆ ì§„ì…ì .
 *
 * TurnInput/TurnOutput Zod ìŠ¤í‚¤ë§ˆ ë° ê´€ë ¨ ìœ í‹¸ë¦¬í‹°ë¥¼ ì¬ë‚´ë³´ë‚´ê¸°í•©ë‹ˆë‹¤.
 *
 * @module schemas
 */

// =============================================================================
// ìŠ¤í‚¤ë§ˆ ë²„ì „
// =============================================================================

export { SCHEMA_VERSION } from './turn';

// =============================================================================
// Enum ìŠ¤í‚¤ë§ˆ ë° íƒ€ì…
// =============================================================================

export {
  LanguageSchema,
  ThemeSchema,
  AgentPhaseSchema,
  ValidationBadgeSchema,
  ModelLabelSchema,
  RiskLevelSchema,
} from './turn';

export type { Language, Theme, AgentPhase, ValidationBadge, ModelLabel, RiskLevel } from './turn';

// =============================================================================
// ê³µí†µ í•˜ìœ„ íƒ€ì… ìŠ¤í‚¤ë§ˆ ë° íƒ€ì…
// =============================================================================

export { CoordinateSchema, Box2DSchema, CurrencyAmountSchema } from './turn';

export type { Coordinate, Box2D, CurrencyAmount } from './turn';

// =============================================================================
// TurnInput ê´€ë ¨ ìŠ¤í‚¤ë§ˆ ë° íƒ€ì…
// =============================================================================

export { ClickInputSchema, ClientInfoSchema, EconomySnapshotSchema, TurnInputSchema } from './turn';

export type { ClickInput, ClientInfo, EconomySnapshot, TurnInput } from './turn';

// =============================================================================
// TurnOutput ê´€ë ¨ ìŠ¤í‚¤ë§ˆ ë° íƒ€ì…
// =============================================================================

export {
  // UI
  ActionCardSchema,
  SceneObjectSchema,
  ActionDeckSchema,
  UIOutputSchema,
  // World
  MemoryPinSchema,
  WorldRuleSchema,
  QuestSchema,
  WorldDeltaSchema,
  // Render
  ImageJobSchema,
  RenderOutputSchema,
  // Economy
  EconomyOutputSchema,
  // Safety
  SafetyOutputSchema,
  // Agent Console
  AgentConsoleSchema,
  // Main
  TurnOutputSchema,
} from './turn';

export type {
  // UI
  ActionCard,
  SceneObject,
  ActionDeck,
  UIOutput,
  // World
  MemoryPin,
  WorldRule,
  Quest,
  WorldDelta,
  // Render
  ImageJob,
  RenderOutput,
  // Economy
  EconomyOutput,
  // Safety
  SafetyOutput,
  // Agent Console
  AgentConsole,
  // Main
  TurnOutput,
} from './turn';

// =============================================================================
// ìœ í‹¸ë¦¬í‹° í•¨ìˆ˜
// =============================================================================

export {
  createFallbackTurnOutput,
  safeParseTurnOutput,
  parseTurnInput,
  safeParseTurnInput,
} from './turn';

export type { TurnOutputParseResult, TurnInputSafeParseResult } from './turn';
</file>

<file path="frontend/src/schemas/turn.test.ts">
import { describe, it, expect } from 'vitest';
import {
  TurnInputSchema,
  TurnOutputSchema,
  safeParseTurnOutput,
  parseTurnInput,
  safeParseTurnInput,
  SCHEMA_VERSION,
} from './turn';

describe('Turn schemas', () => {
  describe('SCHEMA_VERSION', () => {
    it('should have correct version', () => {
      expect(SCHEMA_VERSION).toBe('1.0.0');
    });
  });

  describe('TurnInputSchema', () => {
    const validTurnInput = {
      language: 'ko-KR',
      text: 'í…ŒìŠ¤íŠ¸ ì…ë ¥',
      client: {
        viewport_w: 1920,
        viewport_h: 1080,
        theme: 'dark',
      },
      economy_snapshot: {
        signal: 100,
        memory_shard: 5,
      },
    };

    it('should validate a valid TurnInput', () => {
      const result = TurnInputSchema.safeParse(validTurnInput);
      expect(result.success).toBe(true);
    });

    it('should fail on invalid language', () => {
      const result = TurnInputSchema.safeParse({
        ...validTurnInput,
        language: 'fr-FR',
      });
      expect(result.success).toBe(false);
    });

    it('should fail on negative economy values', () => {
      const result = TurnInputSchema.safeParse({
        ...validTurnInput,
        economy_snapshot: {
          signal: -1,
          memory_shard: 0,
        },
      });
      expect(result.success).toBe(false);
    });

    it('should fail on extra fields (strict)', () => {
      const result = TurnInputSchema.safeParse({
        ...validTurnInput,
        extra_field: 'not allowed',
      });
      expect(result.success).toBe(false);
    });

    it('should validate click input with bbox', () => {
      const result = TurnInputSchema.safeParse({
        ...validTurnInput,
        click: {
          object_id: 'door_01',
          box_2d: {
            ymin: 100,
            xmin: 100,
            ymax: 500,
            xmax: 500,
          },
        },
      });
      expect(result.success).toBe(true);
    });

    it('should fail on invalid bbox coordinates (out of range 0-1000)', () => {
      const result = TurnInputSchema.safeParse({
        ...validTurnInput,
        click: {
          object_id: 'door_01',
          box_2d: {
            ymin: -1,
            xmin: 0,
            ymax: 1001,
            xmax: 500,
          },
        },
      });
      expect(result.success).toBe(false);
    });

    it('should fail on non-positive viewport dimensions', () => {
      const result = TurnInputSchema.safeParse({
        ...validTurnInput,
        client: {
          viewport_w: 0,
          viewport_h: -100,
          theme: 'dark',
        },
      });
      expect(result.success).toBe(false);
    });

    it('should fail on non-integer coordinates', () => {
      const result = TurnInputSchema.safeParse({
        ...validTurnInput,
        click: {
          object_id: 'obj',
          box_2d: {
            ymin: 10.5,
            xmin: 20,
            ymax: 30,
            xmax: 40,
          },
        },
      });
      expect(result.success).toBe(false);
    });
  });

  describe('TurnOutputSchema', () => {
    const validTurnOutput = {
      language: 'ko-KR',
      narrative: 'í…ŒìŠ¤íŠ¸ ë‚´ëŸ¬í‹°ë¸Œ',
      economy: {
        cost: { signal: 5, memory_shard: 0 },
        balance_after: { signal: 95, memory_shard: 5 },
      },
      safety: {
        blocked: false,
      },
      agent_console: {
        current_phase: 'commit',
        badges: ['schema_ok', 'economy_ok'],
        repair_count: 0,
      },
    };

    it('should validate a valid TurnOutput', () => {
      const result = TurnOutputSchema.safeParse(validTurnOutput);
      expect(result.success).toBe(true);
    });

    it('should fail if required fields are missing', () => {
      const { narrative: _narrative, ...invalidOutput } = validTurnOutput;
      const result = TurnOutputSchema.safeParse(invalidOutput);
      expect(result.success).toBe(false);
    });

    it('should handle default values for optional fields', () => {
      const result = TurnOutputSchema.safeParse(validTurnOutput);
      if (result.success) {
        expect(result.data.ui).toBeDefined();
        expect(result.data.ui.action_deck.cards).toEqual([]);
        expect(result.data.world.rules_changed).toEqual([]);
      } else {
        throw new Error('Validation failed');
      }
    });

    it('should fail if there are too many action cards (max 10)', () => {
      const cards = Array.from({ length: 11 }, (_, i) => ({
        id: `card_${i}`,
        label: `Card ${i}`,
        cost: { signal: 0, memory_shard: 0 },
        risk: 'low',
      }));
      const result = TurnOutputSchema.safeParse({
        ...validTurnOutput,
        ui: {
          action_deck: { cards },
        },
      });
      expect(result.success).toBe(false);
    });

    it('should fail on negative repair_count', () => {
      const result = TurnOutputSchema.safeParse({
        ...validTurnOutput,
        agent_console: {
          current_phase: 'commit',
          badges: [],
          repair_count: -1,
        },
      });
      expect(result.success).toBe(false);
    });
  });

  describe('safeParseTurnOutput', () => {
    it('should return success for valid data', () => {
      const validTurnOutput = {
        language: 'en-US',
        narrative: 'Test narrative',
        economy: {
          cost: { signal: 0, memory_shard: 0 },
          balance_after: { signal: 100, memory_shard: 0 },
        },
        safety: { blocked: false },
      };
      const result = safeParseTurnOutput(validTurnOutput);
      expect(result.success).toBe(true);
      if (result.success) {
        expect(result.data.language).toBe('en-US');
      }
    });

    it('should return fallback for invalid data', () => {
      const invalidData = { some: 'garbage' };
      const result = safeParseTurnOutput(invalidData, 'ko-KR', 1);
      expect(result.success).toBe(false);
      if (!result.success) {
        expect(result.fallback).toBeDefined();
        expect(result.fallback.language).toBe('ko-KR');
        expect(result.fallback.agent_console.badges).toContain('schema_fail');
        expect(result.fallback.agent_console.repair_count).toBe(1);
      }
    });
  });

  describe('Input Parsing Utilities', () => {
    const validTurnInput = {
      language: 'ko-KR',
      text: 'í…ŒìŠ¤íŠ¸ ì…ë ¥',
      client: {
        viewport_w: 1920,
        viewport_h: 1080,
        theme: 'dark',
      },
      economy_snapshot: {
        signal: 100,
        memory_shard: 5,
      },
    };

    describe('parseTurnInput', () => {
      it('should parse valid input', () => {
        const result = parseTurnInput(validTurnInput);
        expect(result.text).toBe('í…ŒìŠ¤íŠ¸ ì…ë ¥');
      });

      it('should throw error for invalid input', () => {
        expect(() => parseTurnInput({})).toThrow();
      });
    });

    describe('safeParseTurnInput', () => {
      it('should return success for valid input', () => {
        const result = safeParseTurnInput(validTurnInput);
        expect(result.success).toBe(true);
      });

      it('should return failure for invalid input', () => {
        const result = safeParseTurnInput({});
        expect(result.success).toBe(false);
      });
    });
  });
});
</file>

<file path="frontend/src/schemas/verify_runbook.ts">
import {
  TurnOutputSchema,
  safeParseTurnOutput,
  Box2DSchema,
  CurrencyAmountSchema,
  LanguageSchema,
  parseTurnInput,
} from './turn.js';

console.log('--- Scenario A: TurnOutput ìŠ¤í‚¤ë§ˆ ê²€ì¦ (ì •ìƒ ì¼€ì´ìŠ¤) ---');
const validOutput = {
  language: 'ko-KR',
  narrative: 'ë¬¸ì´ ì‚ê±±ê±°ë¦¬ë©° ì—´ë¦½ë‹ˆë‹¤...',
  economy: {
    cost: { signal: 5, memory_shard: 0 },
    balance_after: { signal: 95, memory_shard: 5 },
  },
  safety: { blocked: false, message: null },
};
const resultA = safeParseTurnOutput(validOutput);
console.log('Success:', resultA.success);
if (resultA.success) {
  console.log('Data (sample):', resultA.data.narrative);
}

console.log('\n--- Scenario B: TurnOutput ìŠ¤í‚¤ë§ˆ ê²€ì¦ ì‹¤íŒ¨ â†’ í´ë°± ---');
const invalidOutput = {
  language: 'ko-KR',
  narrative: 'í…ŒìŠ¤íŠ¸',
};
// eslint-disable-next-line @typescript-eslint/no-explicit-any
const resultB = safeParseTurnOutput(invalidOutput as any);
console.log('Success:', resultB.success);
if (!resultB.success) {
  console.log('Error count:', resultB.error.issues.length);
  console.log('Fallback exists:', !!resultB.fallback);
  console.log(
    'Fallback badges has schema_fail:',
    resultB.fallback?.agent_console?.badges?.includes('schema_fail'),
  );
}

console.log('\n--- Scenario C: ì¢Œí‘œ ë²”ìœ„ ê²€ì¦ (RULE-009) ---');
const validBox = { ymin: 100, xmin: 200, ymax: 300, xmax: 400 };
console.log('Valid box:', Box2DSchema.safeParse(validBox).success);
const invalidBox = { ymin: 100, xmin: 200, ymax: 1500, xmax: 400 };
console.log('Invalid box (1500):', Box2DSchema.safeParse(invalidBox).success);
const negativeBox = { ymin: -10, xmin: 200, ymax: 300, xmax: 400 };
console.log('Negative box:', Box2DSchema.safeParse(negativeBox).success);

console.log('\n--- Scenario D: ì¬í™” ì¸ë°”ë¦¬ì–¸íŠ¸ ê²€ì¦ (RULE-005) ---');
const validCurrency = { signal: 100, memory_shard: 5 };
console.log('Valid currency:', CurrencyAmountSchema.safeParse(validCurrency).success);
const negativeCurrency = { signal: -10, memory_shard: 5 };
console.log('Negative signal:', CurrencyAmountSchema.safeParse(negativeCurrency).success);

console.log('\n--- Scenario E: ì–¸ì–´ ì •ì±… ê²€ì¦ (RULE-006) ---');
console.log('ko-KR:', LanguageSchema.safeParse('ko-KR').success);
console.log('en-US:', LanguageSchema.safeParse('en-US').success);
console.log('ja-JP (invalid):', LanguageSchema.safeParse('ja-JP').success);
console.log('ko (invalid format):', LanguageSchema.safeParse('ko').success);

console.log('\n--- Scenario F: TurnInput ê²€ì¦ ---');
const validInput = {
  language: 'ko-KR',
  text: 'ë¬¸ì„ ì—´ì–´ë³¸ë‹¤',
  client: {
    viewport_w: 1920,
    viewport_h: 1080,
    theme: 'dark',
  },
  economy_snapshot: {
    signal: 100,
    memory_shard: 5,
  },
};
try {
  // eslint-disable-next-line @typescript-eslint/no-explicit-any
  const parsed = parseTurnInput(validInput as any);
  console.log('Parsed successfully:', parsed.text);
} catch (e) {
  console.log('Parse error:', e);
}

console.log('\n--- Scenario G: Strict ëª¨ë“œ ê²€ì¦ ---');
const outputWithExtra = {
  language: 'ko-KR',
  narrative: 'í…ŒìŠ¤íŠ¸',
  economy: {
    cost: { signal: 0, memory_shard: 0 },
    balance_after: { signal: 100, memory_shard: 5 },
  },
  safety: { blocked: false, message: null },
  unknown_field: 'ì´ í•„ë“œëŠ” ìŠ¤í‚¤ë§ˆì— ì—†ìŒ',
};
const resultG = TurnOutputSchema.safeParse(outputWithExtra);
console.log('With extra field success:', resultG.success);
if (!resultG.success) {
  console.log('Error code:', resultG.error.issues[0].code);
}
</file>

<file path="frontend/src/setupTests.ts">
import '@testing-library/jest-dom';
</file>

<file path="frontend/src/stores/actionDeckStore.test.ts">
import { describe, it, expect, beforeEach } from 'vitest';
import { useActionDeckStore, filterAffordableCards } from './actionDeckStore';
import type { ActionCard } from '../schemas/turn';

describe('actionDeckStore', () => {
  beforeEach(() => {
    useActionDeckStore.getState().reset();
  });

  const mockCards: ActionCard[] = [
    {
      id: 'card-1',
      label: 'Card 1',
      description: null,
      cost: { signal: 10, memory_shard: 0 },
      cost_estimate: null,
      risk: 'low',
      hint: null,
      reward_hint: null,
      enabled: true,
      disabled_reason: null,
      is_alternative: false,
    },
    {
      id: 'card-2',
      label: 'Card 2',
      description: null,
      cost: { signal: 50, memory_shard: 1 },
      cost_estimate: null,
      risk: 'high',
      hint: null,
      reward_hint: null,
      enabled: true,
      disabled_reason: null,
      is_alternative: false,
    },
  ];

  it('sets cards and resets selected card', () => {
    const store = useActionDeckStore.getState();
    store.selectCard('some-id');
    expect(useActionDeckStore.getState().selectedCardId).toBe('some-id');

    store.setCards(mockCards);
    expect(useActionDeckStore.getState().cards).toEqual(mockCards);
    expect(useActionDeckStore.getState().selectedCardId).toBeNull();
  });

  it('marks a card as executed', () => {
    const store = useActionDeckStore.getState();
    store.selectCard('card-1');
    store.markExecuted('card-1');

    expect(useActionDeckStore.getState().lastExecutedCardId).toBe('card-1');
    expect(useActionDeckStore.getState().selectedCardId).toBeNull();
  });

  it('filters affordable cards correctly', () => {
    const balance = { signal: 20, memory_shard: 0 };
    const affordable = filterAffordableCards(mockCards, balance);

    expect(affordable).toHaveLength(1);
    expect(affordable[0].id).toBe('card-1');
  });

  it('respects server enabled flag in filterAffordableCards', () => {
    const disabledCards: ActionCard[] = [
      {
        ...mockCards[0],
        enabled: false,
      },
    ];
    const balance = { signal: 100, memory_shard: 100 };
    const affordable = filterAffordableCards(disabledCards, balance);

    expect(affordable).toHaveLength(0);
  });
});
</file>

<file path="frontend/src/stores/actionDeckStore.ts">
/**
 * Unknown World - Action Deck ìƒíƒœ ê´€ë¦¬ (Zustand) (U-009[Mvp]).
 *
 * Action Deckì˜ ì¹´ë“œ ëª©ë¡, ì„ íƒ ìƒíƒœ, ì”ì•¡ ê¸°ë°˜ í•„í„°ë§ì„ ê´€ë¦¬í•©ë‹ˆë‹¤.
 *
 * ì„¤ê³„ ì›ì¹™:
 *   - RULE-005: ì”ì•¡ ë¶€ì¡± ì‹œ ì‹¤í–‰ ë¶ˆê°€ í‘œì‹œ + ëŒ€ì•ˆ ì œê³µ
 *   - RULE-008: ì¹´ë“œ í´ë¦­ â†’ TurnInput ì—°ê²°
 *
 * @module stores/actionDeckStore
 */

import { create } from 'zustand';
import type { ActionCard } from '../schemas/turn';

// =============================================================================
// ìƒíƒœ íƒ€ì… ì •ì˜
// =============================================================================

/** Action Deck ìƒíƒœ */
export interface ActionDeckState {
  /** í˜„ì¬ ì¹´ë“œ ëª©ë¡ (ì„œë²„ì—ì„œ ë°›ì€ ì›ë³¸) */
  cards: ActionCard[];
  /** ì„ íƒëœ ì¹´ë“œ ID (í´ë¦­ í›„ ì‹¤í–‰ ì „ê¹Œì§€) */
  selectedCardId: string | null;
  /** ë§ˆì§€ë§‰ìœ¼ë¡œ ì‹¤í–‰ëœ ì¹´ë“œ ID */
  lastExecutedCardId: string | null;
}

/** Action Deck ì•¡ì…˜ */
export interface ActionDeckActions {
  /** ì¹´ë“œ ëª©ë¡ ì„¤ì • (TurnOutput ìˆ˜ì‹  ì‹œ) */
  setCards: (cards: ActionCard[]) => void;
  /** ì¹´ë“œ ì„ íƒ */
  selectCard: (cardId: string | null) => void;
  /** ì¹´ë“œ ì‹¤í–‰ ì™„ë£Œ ê¸°ë¡ */
  markExecuted: (cardId: string) => void;
  /** ìƒíƒœ ì´ˆê¸°í™” */
  reset: () => void;
}

export type ActionDeckStore = ActionDeckState & ActionDeckActions;

// =============================================================================
// ì´ˆê¸° ìƒíƒœ
// =============================================================================

function createInitialState(): ActionDeckState {
  return {
    cards: [],
    selectedCardId: null,
    lastExecutedCardId: null,
  };
}

// =============================================================================
// Zustand Store
// =============================================================================

/**
 * Action Deck ìƒíƒœ ìŠ¤í† ì–´.
 *
 * @example
 * ```tsx
 * const { cards, setCards, selectCard } = useActionDeckStore();
 *
 * // TurnOutput ìˆ˜ì‹  ì‹œ
 * setCards(turnOutput.ui.action_deck.cards);
 *
 * // ì¹´ë“œ í´ë¦­ ì‹œ
 * selectCard(card.id);
 * ```
 */
export const useActionDeckStore = create<ActionDeckStore>((set) => ({
  // ì´ˆê¸° ìƒíƒœ
  ...createInitialState(),

  // ì•¡ì…˜
  setCards: (cards) => {
    set({
      cards,
      selectedCardId: null, // ìƒˆ ì¹´ë“œ ëª©ë¡ ìˆ˜ì‹  ì‹œ ì„ íƒ ì´ˆê¸°í™”
    });
  },

  selectCard: (cardId) => {
    set({ selectedCardId: cardId });
  },

  markExecuted: (cardId) => {
    set({
      lastExecutedCardId: cardId,
      selectedCardId: null,
    });
  },

  reset: () => {
    set(createInitialState());
  },
}));

// =============================================================================
// ì…€ë ‰í„° (ì„±ëŠ¥ ìµœì í™”ìš©)
// =============================================================================

/** ì¹´ë“œ ëª©ë¡ ì…€ë ‰í„° */
export const selectCards = (state: ActionDeckStore) => state.cards;

/** ì„ íƒëœ ì¹´ë“œ ID ì…€ë ‰í„° */
export const selectSelectedCardId = (state: ActionDeckStore) => state.selectedCardId;

/** ì„ íƒëœ ì¹´ë“œ ê°ì²´ ì…€ë ‰í„° */
export const selectSelectedCard = (state: ActionDeckStore) =>
  state.cards.find((c) => c.id === state.selectedCardId) ?? null;

/** ë§ˆì§€ë§‰ ì‹¤í–‰ ì¹´ë“œ ID ì…€ë ‰í„° */
export const selectLastExecutedCardId = (state: ActionDeckStore) => state.lastExecutedCardId;

// =============================================================================
// ìœ í‹¸ë¦¬í‹° í•¨ìˆ˜
// =============================================================================

/**
 * ì”ì•¡ ê¸°ë°˜ìœ¼ë¡œ ì‹¤í–‰ ê°€ëŠ¥í•œ ì¹´ë“œë§Œ í•„í„°ë§í•©ë‹ˆë‹¤.
 * (ì»´í¬ë„ŒíŠ¸ì—ì„œ ì‚¬ìš©í•˜ê±°ë‚˜, ì„œë²„ ì‘ë‹µì´ enabledë¥¼ ì œê³µí•˜ì§€ ì•Šì„ ë•Œ í´ë°±ìœ¼ë¡œ ì‚¬ìš©)
 *
 * @param cards - ì›ë³¸ ì¹´ë“œ ëª©ë¡
 * @param balance - í˜„ì¬ ì”ì•¡
 * @returns ì‹¤í–‰ ê°€ëŠ¥í•œ ì¹´ë“œ ëª©ë¡
 */
export function filterAffordableCards(
  cards: ActionCard[],
  balance: { signal: number; memory_shard: number },
): ActionCard[] {
  return cards.filter((card) => {
    // ì„œë²„ì—ì„œ ì´ë¯¸ enabled=falseë¡œ íŒë‹¨í–ˆìœ¼ë©´ ì œì™¸
    if (!card.enabled) return false;

    // ë¹„ìš© ì¶”ì •ì¹˜ê°€ ìˆìœ¼ë©´ ìµœëŒ€ ë¹„ìš©ìœ¼ë¡œ íŒë‹¨
    const cost = card.cost_estimate?.max ?? card.cost;
    return balance.signal >= cost.signal && balance.memory_shard >= cost.memory_shard;
  });
}

/**
 * ëŒ€ì•ˆ ì¹´ë“œ(is_alternative=true)ë§Œ í•„í„°ë§í•©ë‹ˆë‹¤.
 *
 * @param cards - ì›ë³¸ ì¹´ë“œ ëª©ë¡
 * @returns ëŒ€ì•ˆ ì¹´ë“œ ëª©ë¡
 */
export function filterAlternativeCards(cards: ActionCard[]): ActionCard[] {
  return cards.filter((card) => card.is_alternative);
}

/**
 * ì¼ë°˜ ì¹´ë“œ(is_alternative=false)ë§Œ í•„í„°ë§í•©ë‹ˆë‹¤.
 *
 * @param cards - ì›ë³¸ ì¹´ë“œ ëª©ë¡
 * @returns ì¼ë°˜ ì¹´ë“œ ëª©ë¡
 */
export function filterRegularCards(cards: ActionCard[]): ActionCard[] {
  return cards.filter((card) => !card.is_alternative);
}
</file>

<file path="frontend/src/stores/economyStore.test.ts">
import { describe, it, expect, beforeEach } from 'vitest';
import {
  useEconomyStore,
  LEDGER_MAX_ENTRIES,
  canAffordCost,
  canAffordEstimate,
} from './economyStore';
import type { CurrencyAmount, CostEstimate } from '../schemas/turn';

describe('economyStore', () => {
  beforeEach(() => {
    useEconomyStore.getState().reset();
  });

  it('ì´ˆê¸° ìƒíƒœê°€ ì˜¬ë°”ë¥´ê²Œ ì„¤ì •ë˜ì–´ì•¼ í•œë‹¤', () => {
    const state = useEconomyStore.getState();
    expect(state.ledger).toEqual([]);
    expect(state.costEstimate).toBeNull();
    expect(state.lastCost).toBeNull();
    expect(state.isBalanceLow).toBe(false);
    expect(state.lowBalanceThreshold).toBe(10);
  });

  it('addLedgerEntryê°€ ì—”íŠ¸ë¦¬ë¥¼ ì¶”ê°€í•˜ê³  lastCostë¥¼ ì—…ë°ì´íŠ¸í•´ì•¼ í•œë‹¤', () => {
    const entry = {
      turnId: 1,
      reason: 'explore',
      cost: { signal: 5, memory_shard: 0 },
      balanceAfter: { signal: 95, memory_shard: 10 },
      modelLabel: 'FAST' as const,
    };

    useEconomyStore.getState().addLedgerEntry(entry);

    const state = useEconomyStore.getState();
    expect(state.ledger.length).toBe(1);
    expect(state.ledger[0].turnId).toBe(1);
    expect(state.ledger[0].timestamp).toBeDefined();
    expect(state.lastCost).toEqual({
      cost: entry.cost,
      balanceAfter: entry.balanceAfter,
      turnId: entry.turnId,
      modelLabel: entry.modelLabel,
    });
  });

  it(`LedgerëŠ” ìµœëŒ€ ${LEDGER_MAX_ENTRIES}ê°œê¹Œì§€ë§Œ ë³´ê´€í•´ì•¼ í•œë‹¤`, () => {
    const store = useEconomyStore.getState();

    // 25ê°œ ì—”íŠ¸ë¦¬ ì¶”ê°€
    for (let i = 1; i <= 25; i++) {
      store.addLedgerEntry({
        turnId: i,
        reason: `test-${i}`,
        cost: { signal: 1, memory_shard: 0 },
        balanceAfter: { signal: 100 - i, memory_shard: 0 },
      });
    }

    const state = useEconomyStore.getState();
    expect(state.ledger.length).toBe(LEDGER_MAX_ENTRIES);
    // ìµœì‹ ìˆœ(ë‚´ë¦¼ì°¨ìˆœ) ì •ë ¬ í™•ì¸
    expect(state.ledger[0].turnId).toBe(25);
    expect(state.ledger[LEDGER_MAX_ENTRIES - 1].turnId).toBe(25 - LEDGER_MAX_ENTRIES + 1);
  });

  it('setCostEstimateFromCardê°€ ì˜ˆìƒ ë¹„ìš©ì„ ì˜¬ë°”ë¥´ê²Œ ì„¤ì •í•´ì•¼ í•œë‹¤', () => {
    const cost: CurrencyAmount = { signal: 5, memory_shard: 0 };
    const estimate: CostEstimate = {
      min: { signal: 3, memory_shard: 0 },
      max: { signal: 7, memory_shard: 0 },
    };

    // 1. cost_estimateê°€ ì œê³µëœ ê²½ìš°
    useEconomyStore.getState().setCostEstimateFromCard(cost, estimate, 'action-1', 'Test Label');
    let state = useEconomyStore.getState();
    expect(state.costEstimate).toEqual({
      min: estimate.min,
      max: estimate.max,
      actionId: 'action-1',
      label: 'Test Label',
    });

    // 2. cost_estimateê°€ nullì¸ ê²½ìš° (ê¸°ë³¸ cost ì‚¬ìš©)
    useEconomyStore.getState().setCostEstimateFromCard(cost, null, 'action-2');
    state = useEconomyStore.getState();
    expect(state.costEstimate).toEqual({
      min: cost,
      max: cost,
      actionId: 'action-2',
      label: undefined,
    });
  });

  it('updateBalanceLowStatusê°€ ì„ê³„ê°’ì— ë”°ë¼ ìƒíƒœë¥¼ ì—…ë°ì´íŠ¸í•´ì•¼ í•œë‹¤', () => {
    const store = useEconomyStore.getState();

    // ê¸°ë³¸ ì„ê³„ê°’ 10
    store.updateBalanceLowStatus({ signal: 15, memory_shard: 0 });
    expect(useEconomyStore.getState().isBalanceLow).toBe(false);

    store.updateBalanceLowStatus({ signal: 5, memory_shard: 0 });
    expect(useEconomyStore.getState().isBalanceLow).toBe(true);

    // ì„ê³„ê°’ ë³€ê²½ í…ŒìŠ¤íŠ¸
    store.setLowBalanceThreshold(20);
    store.updateBalanceLowStatus({ signal: 15, memory_shard: 0 });
    expect(useEconomyStore.getState().isBalanceLow).toBe(true);
  });

  describe('Utility: canAffordCost & canAffordEstimate', () => {
    const balance: CurrencyAmount = { signal: 10, memory_shard: 2 };

    it('canAffordCost: ì”ì•¡ì´ ì¶©ë¶„í•  ë•Œ', () => {
      const cost: CurrencyAmount = { signal: 5, memory_shard: 1 };
      const result = canAffordCost(balance, cost);
      expect(result.affordable).toBe(true);
      expect(result.shortfall).toEqual({ signal: 0, memory_shard: 0 });
    });

    it('canAffordCost: ì”ì•¡ì´ ë¶€ì¡±í•  ë•Œ (Signal)', () => {
      const cost: CurrencyAmount = { signal: 15, memory_shard: 1 };
      const result = canAffordCost(balance, cost);
      expect(result.affordable).toBe(false);
      expect(result.shortfall.signal).toBe(5);
    });

    it('canAffordCost: ì”ì•¡ì´ ë¶€ì¡±í•  ë•Œ (Shard)', () => {
      const cost: CurrencyAmount = { signal: 5, memory_shard: 5 };
      const result = canAffordCost(balance, cost);
      expect(result.affordable).toBe(false);
      expect(result.shortfall.memory_shard).toBe(3);
    });

    it('canAffordEstimate: ìµœëŒ€ ì˜ˆìƒ ë¹„ìš© ê¸°ì¤€ìœ¼ë¡œ ì²´í¬í•´ì•¼ í•œë‹¤', () => {
      const estimate = {
        min: { signal: 5, memory_shard: 0 },
        max: { signal: 15, memory_shard: 0 },
      };
      // Signal 10 < Max 15 ì´ë¯€ë¡œ ê°ë‹¹ ë¶ˆê°€
      const result = canAffordEstimate(balance, estimate);
      expect(result.affordable).toBe(false);
      expect(result.shortfall.signal).toBe(5);
    });
  });
});
</file>

<file path="frontend/src/stores/inventoryStore.test.ts">
import { describe, it, expect, beforeEach } from 'vitest';
import { useInventoryStore, parseInventoryAdded } from './inventoryStore';

describe('inventoryStore', () => {
  beforeEach(() => {
    useInventoryStore.getState().reset();
  });

  it('ì´ˆê¸° ìƒíƒœëŠ” ë¹„ì–´ ìˆì–´ì•¼ í•œë‹¤', () => {
    const state = useInventoryStore.getState();
    expect(state.items).toEqual([]);
    expect(state.draggingItemId).toBeNull();
    expect(state.selectedItemId).toBeNull();
  });

  it('addItems: ìƒˆ ì•„ì´í…œì„ ì¶”ê°€í•  ìˆ˜ ìˆì–´ì•¼ í•œë‹¤', () => {
    const { addItems } = useInventoryStore.getState();
    const newItem = { id: 'item1', name: 'Item 1', quantity: 1 };

    addItems([newItem]);

    const state = useInventoryStore.getState();
    expect(state.items).toHaveLength(1);
    expect(state.items[0]).toEqual(newItem);
  });

  it('addItems: ì¤‘ë³µëœ IDì˜ ì•„ì´í…œ ì¶”ê°€ ì‹œ ìˆ˜ëŸ‰ì´ ì¦ê°€í•´ì•¼ í•œë‹¤', () => {
    const { addItems } = useInventoryStore.getState();
    const item1 = { id: 'item1', name: 'Item 1', quantity: 1 };

    addItems([item1]);
    addItems([{ id: 'item1', name: 'Item 1', quantity: 2 }]);

    const state = useInventoryStore.getState();
    expect(state.items).toHaveLength(1);
    expect(state.items[0].quantity).toBe(3);
  });

  it('removeItems: ì•„ì´í…œì„ ì œê±°í•  ìˆ˜ ìˆì–´ì•¼ í•œë‹¤', () => {
    const { addItems, removeItems } = useInventoryStore.getState();
    addItems([
      { id: 'item1', name: 'Item 1', quantity: 1 },
      { id: 'item2', name: 'Item 2', quantity: 1 },
    ]);

    removeItems(['item1']);

    const state = useInventoryStore.getState();
    expect(state.items).toHaveLength(1);
    expect(state.items[0].id).toBe('item2');
  });

  it('removeItems: ì œê±°ëœ ì•„ì´í…œì´ ì„ íƒ/ë“œë˜ê·¸ ì¤‘ì´ë©´ ì´ˆê¸°í™”í•´ì•¼ í•œë‹¤', () => {
    const { addItems, removeItems, selectItem, startDrag } = useInventoryStore.getState();
    addItems([{ id: 'item1', name: 'Item 1', quantity: 1 }]);

    selectItem('item1');
    startDrag('item1');

    removeItems(['item1']);

    const state = useInventoryStore.getState();
    expect(state.selectedItemId).toBeNull();
    expect(state.draggingItemId).toBeNull();
  });

  it('startDrag/endDrag: ë“œë˜ê·¸ ìƒíƒœë¥¼ ê´€ë¦¬í•´ì•¼ í•œë‹¤', () => {
    const { startDrag, endDrag } = useInventoryStore.getState();

    startDrag('item1');
    expect(useInventoryStore.getState().draggingItemId).toBe('item1');

    endDrag();
    expect(useInventoryStore.getState().draggingItemId).toBeNull();
  });

  it('parseInventoryAdded: ë¬¸ìì—´ ID ëª©ë¡ì„ InventoryItem ë°°ì—´ë¡œ ë³€í™˜í•´ì•¼ í•œë‹¤', () => {
    const addedIds = ['item-a', 'item-b'];
    const parsed = parseInventoryAdded(addedIds);

    expect(parsed).toHaveLength(2);
    expect(parsed[0]).toEqual({ id: 'item-a', name: 'item-a', quantity: 1 });
    expect(parsed[1]).toEqual({ id: 'item-b', name: 'item-b', quantity: 1 });
  });
});
</file>

<file path="frontend/src/stores/inventoryStore.ts">
/**
 * Unknown World - Inventory ìƒíƒœ ê´€ë¦¬ (Zustand) (U-011[Mvp]).
 *
 * Inventoryì˜ ì•„ì´í…œ ëª©ë¡, ë“œë˜ê·¸ ìƒíƒœ, ì„ íƒ ìƒíƒœë¥¼ ê´€ë¦¬í•©ë‹ˆë‹¤.
 *
 * ì„¤ê³„ ì›ì¹™:
 *   - RULE-002: InventoryëŠ” ê²Œì„ UIë¡œ ìƒì‹œ ë…¸ì¶œ
 *   - U-006 ì˜ì¡´: WorldDelta.inventory_added / inventory_removed í•„ë“œ ì—°ë™
 *   - U-012 ì—°ê²°: ë“œë˜ê·¸ ë°ì´í„°ì— item_idë¥¼ ì‹¤ì–´ ë“œë¡­ íƒ€ê²Ÿ(í•«ìŠ¤íŒŸ)ì— ì „ë‹¬
 *
 * @module stores/inventoryStore
 */

import { create } from 'zustand';

// =============================================================================
// íƒ€ì… ì •ì˜
// =============================================================================

/**
 * ì¸ë²¤í† ë¦¬ ì•„ì´í…œ.
 * MVPì—ì„œëŠ” ìµœì†Œ í•„ë“œë§Œ ì •ì˜í•©ë‹ˆë‹¤.
 */
export interface InventoryItem {
  /** ì•„ì´í…œ ê³ ìœ  ID */
  id: string;
  /** ì•„ì´í…œ ì´ë¦„ (í‘œì‹œìš©) */
  name: string;
  /** ì•„ì´í…œ ì„¤ëª… (ì„ íƒ) */
  description?: string;
  /** ì•„ì´í…œ ì•„ì´ì½˜ URL ë˜ëŠ” ì´ëª¨ì§€ (ì„ íƒ) */
  icon?: string;
  /** ì•„ì´í…œ ìˆ˜ëŸ‰ (ê¸°ë³¸ê°’: 1) */
  quantity: number;
}

/** Inventory ìƒíƒœ */
export interface InventoryState {
  /** í˜„ì¬ ì•„ì´í…œ ëª©ë¡ */
  items: InventoryItem[];
  /** í˜„ì¬ ë“œë˜ê·¸ ì¤‘ì¸ ì•„ì´í…œ ID (nullì´ë©´ ë“œë˜ê·¸ ì¤‘ ì•„ë‹˜) */
  draggingItemId: string | null;
  /** ì„ íƒëœ ì•„ì´í…œ ID (í´ë¦­ ì„ íƒ, ë“œë˜ê·¸ì™€ ë³„ê°œ) */
  selectedItemId: string | null;
}

/** Inventory ì•¡ì…˜ */
export interface InventoryActions {
  /** ì•„ì´í…œ ëª©ë¡ ì„¤ì • (ì „ì²´ êµì²´) */
  setItems: (items: InventoryItem[]) => void;
  /** ì•„ì´í…œ ì¶”ê°€ (ì¤‘ë³µ IDë©´ ìˆ˜ëŸ‰ ì¦ê°€) */
  addItems: (items: InventoryItem[]) => void;
  /** ì•„ì´í…œ ì œê±° (ID ëª©ë¡) */
  removeItems: (itemIds: string[]) => void;
  /** ë“œë˜ê·¸ ì‹œì‘ */
  startDrag: (itemId: string) => void;
  /** ë“œë˜ê·¸ ì¢…ë£Œ */
  endDrag: () => void;
  /** ì•„ì´í…œ ì„ íƒ */
  selectItem: (itemId: string | null) => void;
  /** ìƒíƒœ ì´ˆê¸°í™” */
  reset: () => void;
}

export type InventoryStore = InventoryState & InventoryActions;

// =============================================================================
// ì´ˆê¸° ìƒíƒœ
// =============================================================================

function createInitialState(): InventoryState {
  return {
    items: [],
    draggingItemId: null,
    selectedItemId: null,
  };
}

// =============================================================================
// Zustand Store
// =============================================================================

/**
 * Inventory ìƒíƒœ ìŠ¤í† ì–´.
 *
 * @example
 * ```tsx
 * const { items, addItems, removeItems, startDrag, endDrag } = useInventoryStore();
 *
 * // TurnOutput.world.inventory_added ìˆ˜ì‹  ì‹œ
 * addItems(inventoryAddedItems);
 *
 * // TurnOutput.world.inventory_removed ìˆ˜ì‹  ì‹œ
 * removeItems(inventoryRemovedIds);
 *
 * // dnd-kit onDragStart
 * startDrag(itemId);
 *
 * // dnd-kit onDragEnd
 * endDrag();
 * ```
 */
export const useInventoryStore = create<InventoryStore>((set) => ({
  // ì´ˆê¸° ìƒíƒœ
  ...createInitialState(),

  // ì•¡ì…˜
  setItems: (items) => {
    set({
      items,
      draggingItemId: null,
      selectedItemId: null,
    });
  },

  addItems: (newItems) => {
    set((state) => {
      const itemsMap = new Map(state.items.map((item) => [item.id, item]));

      for (const newItem of newItems) {
        const existing = itemsMap.get(newItem.id);
        if (existing) {
          // ê¸°ì¡´ ì•„ì´í…œì´ë©´ ìˆ˜ëŸ‰ ì¦ê°€
          itemsMap.set(newItem.id, {
            ...existing,
            quantity: existing.quantity + newItem.quantity,
          });
        } else {
          // ìƒˆ ì•„ì´í…œ ì¶”ê°€
          itemsMap.set(newItem.id, newItem);
        }
      }

      return { items: Array.from(itemsMap.values()) };
    });
  },

  removeItems: (itemIds) => {
    set((state) => {
      const removeSet = new Set(itemIds);
      return {
        items: state.items.filter((item) => !removeSet.has(item.id)),
        // ì œê±°ëœ ì•„ì´í…œì´ ì„ íƒ/ë“œë˜ê·¸ ì¤‘ì´ì—ˆë‹¤ë©´ ì´ˆê¸°í™”
        selectedItemId: removeSet.has(state.selectedItemId ?? '') ? null : state.selectedItemId,
        draggingItemId: removeSet.has(state.draggingItemId ?? '') ? null : state.draggingItemId,
      };
    });
  },

  startDrag: (itemId) => {
    set({ draggingItemId: itemId });
  },

  endDrag: () => {
    set({ draggingItemId: null });
  },

  selectItem: (itemId) => {
    set({ selectedItemId: itemId });
  },

  reset: () => {
    set(createInitialState());
  },
}));

// =============================================================================
// ì…€ë ‰í„° (ì„±ëŠ¥ ìµœì í™”ìš©)
// =============================================================================

/** ì•„ì´í…œ ëª©ë¡ ì…€ë ‰í„° */
export const selectItems = (state: InventoryStore) => state.items;

/** ë“œë˜ê·¸ ì¤‘ì¸ ì•„ì´í…œ ID ì…€ë ‰í„° */
export const selectDraggingItemId = (state: InventoryStore) => state.draggingItemId;

/** ë“œë˜ê·¸ ì¤‘ì¸ ì•„ì´í…œ ê°ì²´ ì…€ë ‰í„° */
export const selectDraggingItem = (state: InventoryStore) =>
  state.items.find((item) => item.id === state.draggingItemId) ?? null;

/** ì„ íƒëœ ì•„ì´í…œ ID ì…€ë ‰í„° */
export const selectSelectedItemId = (state: InventoryStore) => state.selectedItemId;

/** ì„ íƒëœ ì•„ì´í…œ ê°ì²´ ì…€ë ‰í„° */
export const selectSelectedItem = (state: InventoryStore) =>
  state.items.find((item) => item.id === state.selectedItemId) ?? null;

/** ì•„ì´í…œ ê°œìˆ˜ ì…€ë ‰í„° */
export const selectItemCount = (state: InventoryStore) => state.items.length;

// =============================================================================
// ìœ í‹¸ë¦¬í‹° í•¨ìˆ˜
// =============================================================================

/**
 * ì„œë²„ ì‘ë‹µ(inventory_added ë¬¸ìì—´ ë°°ì—´)ì„ InventoryItem ë°°ì—´ë¡œ ë³€í™˜í•©ë‹ˆë‹¤.
 * MVPì—ì„œëŠ” ë¬¸ìì—´ IDë¥¼ ê¸°ë³¸ ì•„ì´í…œìœ¼ë¡œ ë³€í™˜í•©ë‹ˆë‹¤.
 *
 * @param addedIds - ì¶”ê°€ëœ ì•„ì´í…œ ID ëª©ë¡ (ì„œë²„ ì‘ë‹µ)
 * @returns InventoryItem ë°°ì—´
 */
export function parseInventoryAdded(addedIds: string[]): InventoryItem[] {
  return addedIds.map((id) => ({
    id,
    name: id, // MVP: IDë¥¼ ì´ë¦„ìœ¼ë¡œ ì‚¬ìš©
    quantity: 1,
  }));
}

/**
 * ì•„ì´í…œ IDë¡œ ì•„ì´í…œì„ ì°¾ìŠµë‹ˆë‹¤.
 *
 * @param items - ì•„ì´í…œ ëª©ë¡
 * @param itemId - ì°¾ì„ ì•„ì´í…œ ID
 * @returns ì•„ì´í…œ ë˜ëŠ” undefined
 */
export function findItemById(items: InventoryItem[], itemId: string): InventoryItem | undefined {
  return items.find((item) => item.id === itemId);
}
</file>

<file path="frontend/src/utils/box2d.test.ts">
import { describe, it, expect } from 'vitest';
import {
  box2dToPixel,
  pixelToBox2d,
  isValidBox2D,
  box2dArea,
  box2dCenter,
  NORMALIZED_MAX,
} from './box2d';
import type { Box2D } from '../schemas/turn';

describe('box2d utils', () => {
  const canvas = { width: 800, height: 600 };

  describe('box2dToPixel', () => {
    it('should correctly convert normalized coordinates to pixels', () => {
      const normalized: Box2D = { ymin: 100, xmin: 200, ymax: 500, xmax: 800 };
      const pixel = box2dToPixel(normalized, canvas);

      // top = 100 * (600 / 1000) = 60
      // left = 200 * (800 / 1000) = 160
      // bottom = 500 * (600 / 1000) = 300
      // right = 800 * (800 / 1000) = 640
      // width = 640 - 160 = 480
      // height = 300 - 60 = 240

      expect(pixel).toEqual({
        top: 60,
        left: 160,
        width: 480,
        height: 240,
      });
    });

    it('should handle full canvas size', () => {
      const normalized: Box2D = { ymin: 0, xmin: 0, ymax: 1000, xmax: 1000 };
      const pixel = box2dToPixel(normalized, canvas);

      expect(pixel).toEqual({
        top: 0,
        left: 0,
        width: 800,
        height: 600,
      });
    });
  });

  describe('pixelToBox2d', () => {
    it('should correctly convert pixels back to normalized coordinates', () => {
      const pixel = { top: 60, left: 160, width: 480, height: 240 };
      const normalized = pixelToBox2d(pixel, canvas);

      expect(normalized).toEqual({
        ymin: 100,
        xmin: 200,
        ymax: 500,
        xmax: 800,
      });
    });

    it('should round and clamp values', () => {
      const pixel = { top: -10, left: -20, width: 900, height: 700 };
      const normalized = pixelToBox2d(pixel, canvas);

      expect(normalized.ymin).toBe(0);
      expect(normalized.xmin).toBe(0);
      expect(normalized.ymax).toBe(NORMALIZED_MAX);
      expect(normalized.xmax).toBe(NORMALIZED_MAX);
    });
  });

  describe('isValidBox2D', () => {
    it('should return true for valid boxes', () => {
      expect(isValidBox2D({ ymin: 100, xmin: 100, ymax: 200, xmax: 200 })).toBe(true);
      expect(isValidBox2D({ ymin: 0, xmin: 0, ymax: 1000, xmax: 1000 })).toBe(true);
    });

    it('should return false for out of range values', () => {
      expect(isValidBox2D({ ymin: -1, xmin: 0, ymax: 100, xmax: 100 })).toBe(false);
      expect(isValidBox2D({ ymin: 0, xmin: 0, ymax: 1001, xmax: 100 })).toBe(false);
    });

    it('should return false for invalid order', () => {
      expect(isValidBox2D({ ymin: 500, xmin: 100, ymax: 400, xmax: 200 })).toBe(false);
      expect(isValidBox2D({ ymin: 100, xmin: 500, ymax: 200, xmax: 400 })).toBe(false);
    });
  });

  describe('box2dArea', () => {
    it('should calculate area correctly', () => {
      const box = { ymin: 100, xmin: 100, ymax: 200, xmax: 300 };
      expect(box2dArea(box)).toBe(20000); // (200-100) * (300-100) = 100 * 200
    });
  });

  describe('box2dCenter', () => {
    it('should calculate center correctly', () => {
      const box = { ymin: 100, xmin: 100, ymax: 300, xmax: 500 };
      expect(box2dCenter(box)).toEqual({ x: 300, y: 200 });
    });
  });
});
</file>

<file path="frontend/src/utils/box2d.ts">
/**
 * Unknown World - Box2D ì¢Œí‘œ ë³€í™˜ ìœ í‹¸ë¦¬í‹°
 *
 * RULE-009 ì¤€ìˆ˜: ì¢Œí‘œ ê·œì•½ (0~1000 ì •ê·œí™”, bbox=[ymin,xmin,ymax,xmax])
 * - ì„œë²„/ì„¸ì´ë¸Œì—ëŠ” í•­ìƒ box_2d(0~1000)ë¥¼ ìœ ì§€
 * - ë Œë”ì—ì„œë§Œ viewport í¬ê¸°(canvasW/H)ì— ë§ì¶° pxë¡œ ë³€í™˜
 *
 * @module utils/box2d
 */

import type { Box2D } from '../schemas/turn';

// =============================================================================
// ìƒìˆ˜ ì •ì˜
// =============================================================================

/**
 * ì •ê·œí™” ì¢Œí‘œê³„ ìµœëŒ“ê°’ (0~1000).
 * RULE-009: ì¢Œí‘œ ê·œì•½
 */
export const NORMALIZED_MAX = 1000;

// =============================================================================
// íƒ€ì… ì •ì˜
// =============================================================================

/**
 * í”½ì…€ ë‹¨ìœ„ ë°”ìš´ë”© ë°•ìŠ¤.
 * ë Œë”ë§ìš©ìœ¼ë¡œë§Œ ì‚¬ìš©ë©ë‹ˆë‹¤.
 */
export interface Box2DPixel {
  /** Y ìµœì†Œê°’ (ìƒë‹¨, í”½ì…€) */
  top: number;
  /** X ìµœì†Œê°’ (ì¢Œì¸¡, í”½ì…€) */
  left: number;
  /** ë„ˆë¹„ (í”½ì…€) */
  width: number;
  /** ë†’ì´ (í”½ì…€) */
  height: number;
}

/**
 * ìº”ë²„ìŠ¤ í¬ê¸° ì •ë³´.
 */
export interface CanvasSize {
  /** ìº”ë²„ìŠ¤ ë„ˆë¹„ (í”½ì…€) */
  width: number;
  /** ìº”ë²„ìŠ¤ ë†’ì´ (í”½ì…€) */
  height: number;
}

// =============================================================================
// ë³€í™˜ í•¨ìˆ˜
// =============================================================================

/**
 * ì •ê·œí™” ì¢Œí‘œ(0~1000)ë¥¼ í”½ì…€ ì¢Œí‘œë¡œ ë³€í™˜í•©ë‹ˆë‹¤.
 *
 * RULE-009: bbox ìˆœì„œëŠ” [ymin, xmin, ymax, xmax]
 *
 * @param box - ì •ê·œí™” ì¢Œí‘œ ë°”ìš´ë”© ë°•ìŠ¤
 * @param canvas - ìº”ë²„ìŠ¤ í¬ê¸°
 * @returns í”½ì…€ ë‹¨ìœ„ ë°”ìš´ë”© ë°•ìŠ¤
 *
 * @example
 * ```ts
 * const normalized: Box2D = { ymin: 100, xmin: 200, ymax: 500, xmax: 800 };
 * const canvas = { width: 800, height: 600 };
 * const pixel = box2dToPixel(normalized, canvas);
 * // pixel = { top: 60, left: 160, width: 480, height: 240 }
 * ```
 */
export function box2dToPixel(box: Box2D, canvas: CanvasSize): Box2DPixel {
  const scaleX = canvas.width / NORMALIZED_MAX;
  const scaleY = canvas.height / NORMALIZED_MAX;

  const top = box.ymin * scaleY;
  const left = box.xmin * scaleX;
  const bottom = box.ymax * scaleY;
  const right = box.xmax * scaleX;

  return {
    top,
    left,
    width: right - left,
    height: bottom - top,
  };
}

/**
 * í”½ì…€ ì¢Œí‘œë¥¼ ì •ê·œí™” ì¢Œí‘œ(0~1000)ë¡œ ë³€í™˜í•©ë‹ˆë‹¤.
 *
 * ì—­ë³€í™˜ì´ í•„ìš”í•œ ê²½ìš° ì‚¬ìš©í•©ë‹ˆë‹¤ (ì˜ˆ: í´ë¦­ ìœ„ì¹˜ â†’ ì •ê·œí™” ì¢Œí‘œ).
 *
 * @param pixel - í”½ì…€ ë‹¨ìœ„ ë°”ìš´ë”© ë°•ìŠ¤
 * @param canvas - ìº”ë²„ìŠ¤ í¬ê¸°
 * @returns ì •ê·œí™” ì¢Œí‘œ ë°”ìš´ë”© ë°•ìŠ¤
 */
export function pixelToBox2d(pixel: Box2DPixel, canvas: CanvasSize): Box2D {
  const scaleX = NORMALIZED_MAX / canvas.width;
  const scaleY = NORMALIZED_MAX / canvas.height;

  const ymin = Math.round(pixel.top * scaleY);
  const xmin = Math.round(pixel.left * scaleX);
  const ymax = Math.round((pixel.top + pixel.height) * scaleY);
  const xmax = Math.round((pixel.left + pixel.width) * scaleX);

  // RULE-009: 0~1000 ë²”ìœ„ ë³´ì¥
  return {
    ymin: Math.max(0, Math.min(NORMALIZED_MAX, ymin)),
    xmin: Math.max(0, Math.min(NORMALIZED_MAX, xmin)),
    ymax: Math.max(0, Math.min(NORMALIZED_MAX, ymax)),
    xmax: Math.max(0, Math.min(NORMALIZED_MAX, xmax)),
  };
}

/**
 * Box2Dê°€ ìœ íš¨í•œì§€ ê²€ì¦í•©ë‹ˆë‹¤.
 *
 * @param box - ê²€ì¦í•  ë°”ìš´ë”© ë°•ìŠ¤
 * @returns ìœ íš¨ ì—¬ë¶€
 */
export function isValidBox2D(box: Box2D): boolean {
  // 0~1000 ë²”ìœ„ ì²´í¬
  if (
    box.ymin < 0 ||
    box.ymin > NORMALIZED_MAX ||
    box.xmin < 0 ||
    box.xmin > NORMALIZED_MAX ||
    box.ymax < 0 ||
    box.ymax > NORMALIZED_MAX ||
    box.xmax < 0 ||
    box.xmax > NORMALIZED_MAX
  ) {
    return false;
  }

  // ymin < ymax, xmin < xmax ì²´í¬
  if (box.ymin >= box.ymax || box.xmin >= box.xmax) {
    return false;
  }

  return true;
}

/**
 * Box2Dì˜ ë©´ì ì„ ê³„ì‚°í•©ë‹ˆë‹¤ (ì •ê·œí™” ì¢Œí‘œ ê¸°ì¤€).
 *
 * @param box - ë°”ìš´ë”© ë°•ìŠ¤
 * @returns ë©´ì  (0~1000000)
 */
export function box2dArea(box: Box2D): number {
  return (box.ymax - box.ymin) * (box.xmax - box.xmin);
}

/**
 * Box2Dì˜ ì¤‘ì‹¬ì ì„ ê³„ì‚°í•©ë‹ˆë‹¤ (ì •ê·œí™” ì¢Œí‘œ ê¸°ì¤€).
 *
 * @param box - ë°”ìš´ë”© ë°•ìŠ¤
 * @returns ì¤‘ì‹¬ì  ì¢Œí‘œ {x, y}
 */
export function box2dCenter(box: Box2D): { x: number; y: number } {
  return {
    x: (box.xmin + box.xmax) / 2,
    y: (box.ymin + box.ymax) / 2,
  };
}
</file>

<file path="frontend/src/api/scanner.ts">
/**
 * Unknown World - Scanner(ì´ë¯¸ì§€ ì´í•´) API í´ë¼ì´ì–¸íŠ¸.
 *
 * U-022[Mvp]: Scanner ìŠ¬ë¡¯ UIì—ì„œ ì´ë¯¸ì§€ ì—…ë¡œë“œ ì‹œ ë°±ì—”ë“œ `/api/scan` í˜¸ì¶œ.
 * U-021 ì˜ì¡´: ë°±ì—”ë“œ Scanner ì—”ë“œí¬ì¸íŠ¸ì™€ ì—°ë™.
 *
 * ì„¤ê³„ ì›ì¹™:
 *   - RULE-004: ì‹¤íŒ¨ ì‹œ ì•ˆì „í•œ í´ë°± (ì—ëŸ¬ ë©”ì‹œì§€ ë°˜í™˜)
 *   - RULE-007: íŒŒì¼ ë‚´ìš©/í”„ë¡¬í”„íŠ¸ ë¡œê¹… ê¸ˆì§€
 *   - RULE-009: bboxëŠ” 0~1000 ì •ê·œí™” + [ymin, xmin, ymax, xmax]
 *
 * @module api/scanner
 */

import { z } from 'zod';
import { Box2DSchema, type Language } from '../schemas/turn';

// =============================================================================
// ìƒìˆ˜
// =============================================================================

/** Scanner API ì—”ë“œí¬ì¸íŠ¸ ê¸°ë³¸ URL */
const SCANNER_API_BASE = '/api/scan';

/** ì§€ì›í•˜ëŠ” ì´ë¯¸ì§€ MIME íƒ€ì… */
export const ALLOWED_MIME_TYPES = ['image/jpeg', 'image/png', 'image/gif', 'image/webp'] as const;

/** ìµœëŒ€ íŒŒì¼ í¬ê¸° (20MB) */
export const MAX_FILE_SIZE_BYTES = 20 * 1024 * 1024;

// =============================================================================
// Zod ìŠ¤í‚¤ë§ˆ ì •ì˜ (ë°±ì—”ë“œ ì‘ë‹µê³¼ 1:1 ëŒ€ì‘)
// =============================================================================

/**
 * ìŠ¤ìº” ìƒíƒœ Enum.
 */
export const ScanStatusSchema = z.enum(['completed', 'partial', 'failed', 'blocked']);
export type ScanStatus = z.infer<typeof ScanStatusSchema>;

/**
 * ê°ì§€ëœ ì˜¤ë¸Œì íŠ¸.
 * RULE-009: bboxëŠ” 0~1000 ì •ê·œí™”.
 */
export const DetectedObjectSchema = z.object({
  label: z.string(),
  box_2d: Box2DSchema,
  confidence: z.number().min(0).max(1).nullable().optional(),
  suggested_item_type: z.string().nullable().optional(),
});
export type DetectedObject = z.infer<typeof DetectedObjectSchema>;

/**
 * ì•„ì´í…œ í›„ë³´.
 * ìŠ¤ìº” ê²°ê³¼ë¡œ ìƒì„±ë˜ëŠ” ê²Œì„ ì•„ì´í…œ í›„ë³´.
 */
export const ItemCandidateSchema = z.object({
  id: z.string(),
  label: z.string(),
  description: z.string().default(''),
  item_type: z.string().default('material'),
  source_object_index: z.number().int().min(0).nullable().optional(),
});
export type ItemCandidate = z.infer<typeof ItemCandidateSchema>;

/**
 * Scanner API ì‘ë‹µ.
 * RU-006-S1: original_image_key, original_image_url ì¶”ê°€
 */
export const ScannerResponseSchema = z.object({
  success: z.boolean(),
  status: ScanStatusSchema,
  caption: z.string().default(''),
  objects: z.array(DetectedObjectSchema).default([]),
  item_candidates: z.array(ItemCandidateSchema).default([]),
  message: z.string().nullable().optional(),
  analysis_time_ms: z.number().int().min(0).default(0),
  language: z.enum(['ko-KR', 'en-US']),
  original_image_key: z.string().nullable().optional(),
  original_image_url: z.string().nullable().optional(),
});
export type ScannerResponse = z.infer<typeof ScannerResponseSchema>;

// =============================================================================
// API í´ë¼ì´ì–¸íŠ¸ í•¨ìˆ˜
// =============================================================================

/**
 * ìŠ¤ìº” ê²°ê³¼ íƒ€ì….
 */
export type ScanResult =
  | { success: true; data: ScannerResponse }
  | { success: false; error: string; status: ScanStatus };

/**
 * ìŠ¤ìº” ì˜µì…˜.
 * RU-006-S1: preserve_original ì˜µì…˜ ì¶”ê°€
 */
export interface ScanOptions {
  /** ì›ë³¸ ì´ë¯¸ì§€ ì €ì¥ ì—¬ë¶€ (ë””ë²„ê¹…/ì¬ë¶„ì„ìš©) */
  preserveOriginal?: boolean;
  /** ì„¸ì…˜ ID (ì´ë¯¸ì§€ ê·¸ë£¹í™”ìš©) */
  sessionId?: string;
}

/**
 * ì´ë¯¸ì§€ë¥¼ ìŠ¤ìº”í•˜ì—¬ ì˜¤ë¸Œì íŠ¸ì™€ ì•„ì´í…œ í›„ë³´ë¥¼ ì¶”ì¶œí•©ë‹ˆë‹¤.
 *
 * @param file - ë¶„ì„í•  ì´ë¯¸ì§€ íŒŒì¼
 * @param language - ì‘ë‹µ ì–¸ì–´
 * @param options - ìŠ¤ìº” ì˜µì…˜ (RU-006-S1)
 * @returns ìŠ¤ìº” ê²°ê³¼
 */
export async function scanImage(
  file: File,
  language: Language,
  options?: ScanOptions,
): Promise<ScanResult> {
  // í´ë¼ì´ì–¸íŠ¸ ì¸¡ íŒŒì¼ ê²€ì¦
  const validationError = validateFile(file);
  if (validationError) {
    return {
      success: false,
      error: validationError,
      status: 'failed',
    };
  }

  // FormData ìƒì„±
  const formData = new FormData();
  formData.append('file', file);
  formData.append('language', language);

  // RU-006-S1: ì„ íƒì  íŒŒë¼ë¯¸í„° ì¶”ê°€
  if (options?.preserveOriginal) {
    formData.append('preserve_original', 'true');
  }
  if (options?.sessionId) {
    formData.append('session_id', options.sessionId);
  }

  try {
    const response = await fetch(SCANNER_API_BASE, {
      method: 'POST',
      body: formData,
    });

    if (!response.ok) {
      console.error('[ScannerAPI] HTTP error', {
        status: response.status,
        statusText: response.statusText,
      });
      return {
        success: false,
        error:
          language === 'ko-KR'
            ? `ì„œë²„ ì˜¤ë¥˜: ${response.status}`
            : `Server error: ${response.status}`,
        status: 'failed',
      };
    }

    const json = await response.json();
    const parseResult = ScannerResponseSchema.safeParse(json);

    if (!parseResult.success) {
      console.error('[ScannerAPI] Response validation failed', parseResult.error);
      return {
        success: false,
        error:
          language === 'ko-KR'
            ? 'ì‘ë‹µ ë°ì´í„° í˜•ì‹ì´ ì˜¬ë°”ë¥´ì§€ ì•ŠìŠµë‹ˆë‹¤.'
            : 'Invalid response data format.',
        status: 'failed',
      };
    }

    const data = parseResult.data;

    // ì„±ê³µ/ë¶€ë¶„ ì„±ê³µ ì—¬ë¶€ í™•ì¸
    if (data.status === 'completed' || data.status === 'partial') {
      return { success: true, data };
    }

    // ì‹¤íŒ¨/ì°¨ë‹¨ ì‘ë‹µ
    return {
      success: false,
      error: data.message ?? (language === 'ko-KR' ? 'ë¶„ì„ ì‹¤íŒ¨' : 'Analysis failed'),
      status: data.status,
    };
  } catch (error) {
    console.error('[ScannerAPI] Network error', { errorType: (error as Error).name });
    return {
      success: false,
      error:
        language === 'ko-KR'
          ? 'ë„¤íŠ¸ì›Œí¬ ì˜¤ë¥˜ê°€ ë°œìƒí–ˆìŠµë‹ˆë‹¤. ë‹¤ì‹œ ì‹œë„í•´ ì£¼ì„¸ìš”.'
          : 'Network error occurred. Please try again.',
      status: 'failed',
    };
  }
}

// =============================================================================
// ìœ í‹¸ë¦¬í‹° í•¨ìˆ˜
// =============================================================================

/**
 * íŒŒì¼ ìœ íš¨ì„± ê²€ì‚¬.
 *
 * @param file - ê²€ì¦í•  íŒŒì¼
 * @returns ì˜¤ë¥˜ ë©”ì‹œì§€ (ì—†ìœ¼ë©´ null)
 */
export function validateFile(file: File): string | null {
  // MIME íƒ€ì… ê²€ì¦
  if (!ALLOWED_MIME_TYPES.includes(file.type as (typeof ALLOWED_MIME_TYPES)[number])) {
    return `ì§€ì›í•˜ì§€ ì•ŠëŠ” íŒŒì¼ í˜•ì‹ì…ë‹ˆë‹¤: ${file.type || 'ì•Œ ìˆ˜ ì—†ìŒ'}`;
  }

  // íŒŒì¼ í¬ê¸° ê²€ì¦
  if (file.size > MAX_FILE_SIZE_BYTES) {
    const sizeMB = (file.size / (1024 * 1024)).toFixed(1);
    return `íŒŒì¼ì´ ë„ˆë¬´ í½ë‹ˆë‹¤: ${sizeMB}MB (ìµœëŒ€ 20MB)`;
  }

  return null;
}

/**
 * ì§€ì› íŒŒì¼ í˜•ì‹ì¸ì§€ í™•ì¸.
 *
 * @param file - í™•ì¸í•  íŒŒì¼
 * @returns ì§€ì› ì—¬ë¶€
 */
export function isSupportedImageFile(file: File): boolean {
  return ALLOWED_MIME_TYPES.includes(file.type as (typeof ALLOWED_MIME_TYPES)[number]);
}

/**
 * ItemCandidateë¥¼ InventoryItemìœ¼ë¡œ ë³€í™˜í•©ë‹ˆë‹¤.
 *
 * @param candidate - ì•„ì´í…œ í›„ë³´
 * @returns InventoryItem í˜•íƒœì˜ ê°ì²´
 */
export function candidateToInventoryItem(candidate: ItemCandidate) {
  return {
    id: candidate.id,
    name: candidate.label,
    description: candidate.description,
    icon: getItemTypeEmoji(candidate.item_type),
    quantity: 1,
  };
}

/**
 * ì•„ì´í…œ ìœ í˜•ì— ë”°ë¥¸ ì´ëª¨ì§€ ë°˜í™˜.
 *
 * @param itemType - ì•„ì´í…œ ìœ í˜•
 * @returns ì´ëª¨ì§€
 */
function getItemTypeEmoji(itemType: string): string {
  const emojiMap: Record<string, string> = {
    key: 'ğŸ”‘',
    weapon: 'âš”ï¸',
    tool: 'ğŸ”§',
    clue: 'ğŸ”',
    material: 'ğŸ“¦',
    consumable: 'ğŸ’Š',
    document: 'ğŸ“„',
    artifact: 'ğŸ’',
  };
  return emojiMap[itemType] ?? 'ğŸ“¦';
}
</file>

<file path="frontend/src/components/AgentConsole.test.tsx">
import { describe, it, expect, vi } from 'vitest';
import { render, screen } from '@testing-library/react';
import { AgentConsole } from './AgentConsole';

// Mock i18n
vi.mock('react-i18next', () => ({
  useTranslation: () => ({
    t: (key: string) => key,
  }),
}));

// Mock dependencies
type MockSelector<T> = (state: unknown) => T;

vi.mock('../stores/agentStore', () => ({
  useAgentStore: <T,>(selector: MockSelector<T>) =>
    selector({
      phases: [],
      badges: [],
      repairCount: 0,
      error: null,
      isStreaming: false,
    }),
  selectIsStreaming: (state: { isStreaming: boolean }) => state.isStreaming,
  selectPhases: (state: { phases: unknown[] }) => state.phases,
  selectBadges: (state: { badges: unknown[] }) => state.badges,
  selectRepairCount: (state: { repairCount: number }) => state.repairCount,
  selectError: (state: { error: unknown }) => state.error,
}));

describe('AgentConsole (U-037)', () => {
  it('should render with "critical" importance attribute', () => {
    const { container } = render(<AgentConsole />);

    // The root element of AgentConsole should have data-ui-importance="critical"
    const consoleElement = container.firstChild as HTMLElement;

    expect(consoleElement).toHaveAttribute('data-ui-importance', 'critical');
  });

  it('should render streaming status', () => {
    render(<AgentConsole />);
    // Verify that the correct i18n key is used
    expect(screen.getByText('agent.console.status.idle')).toBeInTheDocument();
  });
});
</file>

<file path="frontend/src/components/DemoProfileSelect.tsx">
/**
 * Unknown World - ë°ëª¨ í”„ë¡œí•„ ì„ íƒ ì»´í¬ë„ŒíŠ¸ (U-015[Mvp]).
 *
 * ì²« í™”ë©´ì—ì„œ 3ì¢…ì˜ ë°ëª¨ í”„ë¡œí•„ì„ ì„ íƒí•  ìˆ˜ ìˆëŠ” UIë¥¼ ì œê³µí•©ë‹ˆë‹¤.
 * í”„ë¡œí•„ ì„ íƒ ì‹œ í•´ë‹¹ SaveGameì„ ì¦‰ì‹œ ë¡œë“œí•˜ê³  ê²Œì„ì„ ì‹œì‘í•©ë‹ˆë‹¤.
 *
 * ì„¤ê³„ ì›ì¹™:
 *   - RULE-002: ì±„íŒ… UI ê¸ˆì§€, ê²Œì„ UIë¡œ ìƒì‹œ ë…¸ì¶œ
 *   - RULE-006: i18n í‚¤ ê¸°ë°˜ ë‹¤êµ­ì–´ ì§€ì›
 *   - PRD 6.9: ë°ëª¨ í”„ë¡œí•„ ì„ íƒë§Œìœ¼ë¡œ ì¦‰ì‹œ ì‹œì‘
 *
 * @module components/DemoProfileSelect
 */

import { useCallback } from 'react';
import { useTranslation } from 'react-i18next';
import { DEMO_PROFILES, type DemoProfile } from '../data/demoProfiles';
import { SUPPORTED_LANGUAGES, type SupportedLanguage } from '../i18n';

// =============================================================================
// íƒ€ì… ì •ì˜
// =============================================================================

export interface DemoProfileSelectProps {
  /** í”„ë¡œí•„ ì„ íƒ ì‹œ í˜¸ì¶œë˜ëŠ” ì½œë°± */
  onSelectProfile: (profile: DemoProfile) => void;
  /** ê¸°ì¡´ ì„¸ì´ë¸Œ ë¡œë“œ ì‹œ í˜¸ì¶œë˜ëŠ” ì½œë°± (ì„¸ì´ë¸Œê°€ ìˆëŠ” ê²½ìš°) */
  onContinue?: () => void;
  /** ê¸°ì¡´ ì„¸ì´ë¸Œê°€ ìˆëŠ”ì§€ ì—¬ë¶€ */
  hasSavedGame?: boolean;
  /** U-044: í˜„ì¬ ì„ íƒëœ ì–¸ì–´ */
  currentLanguage?: SupportedLanguage;
  /** U-044: ì–¸ì–´ ë³€ê²½ ì½œë°± (profile_selectì—ì„œë§Œ í—ˆìš©) */
  onLanguageChange?: (language: SupportedLanguage) => void;
}

// =============================================================================
// ì»´í¬ë„ŒíŠ¸
// =============================================================================

/** U-044: ì–¸ì–´ í‘œì‹œ ë ˆì´ë¸” ë§¤í•‘ */
const LANGUAGE_LABELS: Record<SupportedLanguage, string> = {
  'ko-KR': 'í•œêµ­ì–´',
  'en-US': 'English',
};

/**
 * ë°ëª¨ í”„ë¡œí•„ ì„ íƒ í™”ë©´.
 * ê²Œì„ ì‹œì‘ ì „ì— 3ì¢…ì˜ í”„ë¡œí•„ ì¤‘ í•˜ë‚˜ë¥¼ ì„ íƒí•©ë‹ˆë‹¤.
 * U-044: ì–¸ì–´ ì„ íƒ UI í¬í•¨ (profile_selectì—ì„œë§Œ ë³€ê²½ ê°€ëŠ¥).
 */
export function DemoProfileSelect({
  onSelectProfile,
  onContinue,
  hasSavedGame = false,
  currentLanguage = 'ko-KR',
  onLanguageChange,
}: DemoProfileSelectProps) {
  const { t } = useTranslation();

  const handleSelectProfile = useCallback(
    (profile: DemoProfile) => {
      onSelectProfile(profile);
    },
    [onSelectProfile],
  );

  const handleContinue = useCallback(() => {
    onContinue?.();
  }, [onContinue]);

  /** U-044: ì–¸ì–´ í† ê¸€ í•¸ë“¤ëŸ¬ */
  const handleLanguageToggle = useCallback(() => {
    if (!onLanguageChange) return;
    // í˜„ì¬ ì–¸ì–´ì˜ ë‹¤ìŒ ì–¸ì–´ë¡œ ì „í™˜ (2ê°œ ì–¸ì–´ë§Œ ì§€ì›í•˜ë¯€ë¡œ í† ê¸€)
    const currentIndex = SUPPORTED_LANGUAGES.indexOf(currentLanguage);
    const nextIndex = (currentIndex + 1) % SUPPORTED_LANGUAGES.length;
    onLanguageChange(SUPPORTED_LANGUAGES[nextIndex]);
  }, [currentLanguage, onLanguageChange]);

  return (
    <div className="profile-select-container" data-ui-importance="critical">
      {/* U-044: ì–¸ì–´ ì„ íƒ í† ê¸€ (ìš°ì¸¡ ìƒë‹¨) */}
      {onLanguageChange && (
        <div className="language-toggle-container">
          <button
            type="button"
            className="language-toggle-btn"
            onClick={handleLanguageToggle}
            aria-label={t('language.toggle')}
            title={t('language.toggle_tooltip')}
          >
            <span className="language-toggle-icon" aria-hidden="true">
              ğŸŒ
            </span>
            <span className="language-toggle-label">{LANGUAGE_LABELS[currentLanguage]}</span>
          </button>
        </div>
      )}

      {/* íƒ€ì´í‹€ */}
      <header className="profile-select-header">
        <h1 className="profile-select-title glitch" data-text={t('ui.logo')}>
          {t('ui.logo')}
        </h1>
        <p className="profile-select-subtitle">{t('profile.select_title')}</p>
      </header>

      {/* í”„ë¡œí•„ ì¹´ë“œ ëª©ë¡ */}
      <div className="profile-card-grid">
        {DEMO_PROFILES.map((profile) => (
          <button
            key={profile.id}
            type="button"
            className="profile-card"
            onClick={() => handleSelectProfile(profile)}
            style={{ '--profile-accent': profile.themeColor } as React.CSSProperties}
            aria-label={t(profile.nameKey)}
          >
            <span className="profile-card-icon" aria-hidden="true">
              {profile.icon}
            </span>
            <span className="profile-card-name">{t(profile.nameKey)}</span>
            <span className="profile-card-description">{t(profile.descriptionKey)}</span>
          </button>
        ))}
      </div>

      {/* ê¸°ì¡´ ì„¸ì´ë¸Œ ê³„ì†í•˜ê¸° (ìˆëŠ” ê²½ìš°) */}
      {hasSavedGame && onContinue && (
        <div className="profile-continue-section">
          <div className="profile-continue-divider">
            <span>{t('profile.or')}</span>
          </div>
          <button type="button" className="profile-continue-btn" onClick={handleContinue}>
            {t('profile.continue_saved')}
          </button>
        </div>
      )}

      {/* ì•ˆë‚´ ë¬¸êµ¬ */}
      <footer className="profile-select-footer">
        <p className="profile-select-hint">{t('profile.select_hint')}</p>
      </footer>
    </div>
  );
}
</file>

<file path="frontend/src/components/Panel.tsx">
import { useTranslation } from 'react-i18next';

interface PanelProps {
  title: string;
  children?: React.ReactNode;
  className?: string;
  /** U-032: Chrome ì¥ì‹ ì ìš© ì—¬ë¶€ */
  hasChrome?: boolean;
  /** ê¸°ë³¸ placeholder i18n í‚¤ (childrenì´ ì—†ì„ ë•Œ ì‚¬ìš©) */
  placeholderKey?: string;
}

export function Panel({
  title,
  children,
  className = '',
  hasChrome = false,
  placeholderKey,
}: PanelProps) {
  const { t } = useTranslation();
  const panelClass = `panel ${className} ${hasChrome ? 'has-chrome' : ''}`.trim();
  const headerClass = `panel-header ${hasChrome ? 'has-chrome' : ''}`.trim();

  return (
    <div className={panelClass}>
      <div className={headerClass}>
        <span className="panel-title">{title}</span>
      </div>
      <div className="panel-content">
        {children || (
          <p className="panel-placeholder">
            {placeholderKey ? t(placeholderKey) : t('ui.panel_placeholder')}
          </p>
        )}
      </div>
    </div>
  );
}
</file>

<file path="frontend/src/components/SceneCanvas.test.tsx">
import { describe, it, expect } from 'vitest';
import { SCENE_PLACEHOLDERS } from './SceneImage';

describe('SCENE_PLACEHOLDERS', () => {
  it('should have all required statuses', () => {
    const statuses = ['default', 'loading', 'offline', 'blocked', 'low_signal'];
    statuses.forEach((status) => {
      expect(SCENE_PLACEHOLDERS).toHaveProperty(status);
    });
  });

  it('should have correct image paths', () => {
    expect(SCENE_PLACEHOLDERS.default.imagePath).toBe(
      '/ui/placeholders/scene-placeholder-default.png',
    );
    expect(SCENE_PLACEHOLDERS.loading.imagePath).toBe('/ui/placeholders/scene-loading.webp');
    expect(SCENE_PLACEHOLDERS.offline.imagePath).toBe('/ui/placeholders/scene-offline.webp');
    expect(SCENE_PLACEHOLDERS.blocked.imagePath).toBe('/ui/placeholders/scene-blocked.webp');
    expect(SCENE_PLACEHOLDERS.low_signal.imagePath).toBe('/ui/placeholders/scene-low-signal.webp');
  });

  it('should have correct i18n label keys', () => {
    expect(SCENE_PLACEHOLDERS.default.labelKey).toBe('scene.status.default');
    expect(SCENE_PLACEHOLDERS.loading.labelKey).toBe('scene.status.loading');
    expect(SCENE_PLACEHOLDERS.offline.labelKey).toBe('scene.status.offline');
    expect(SCENE_PLACEHOLDERS.blocked.labelKey).toBe('scene.status.blocked');
    expect(SCENE_PLACEHOLDERS.low_signal.labelKey).toBe('scene.status.low_signal');
  });
});
</file>

<file path="frontend/src/components/SceneImage.tsx">
/**
 * Unknown World - Scene Image ì»´í¬ë„ŒíŠ¸ (U-020: Lazy Render)
 *
 * RULE-004 ì¤€ìˆ˜: ì‹¤íŒ¨ ì‹œì—ë„ ì•ˆì „í•œ í´ë°± ì œê³µ
 * RULE-008 ì¤€ìˆ˜: í…ìŠ¤íŠ¸ ìš°ì„  + Lazy ì´ë¯¸ì§€ ì •ì±…
 *
 * @module components/SceneImage
 */

import { useState, useEffect, useMemo } from 'react';
import { useTranslation } from 'react-i18next';
import type { SceneCanvasStatus, PlaceholderInfo, ImageLoadingState } from '../types/scene';

// =============================================================================
// ìƒìˆ˜ ì •ì˜
// =============================================================================

export const SCENE_PLACEHOLDERS: Record<Exclude<SceneCanvasStatus, 'scene'>, PlaceholderInfo> = {
  default: {
    imagePath: '/ui/placeholders/scene-placeholder-default.png',
    fallbackEmoji: 'ğŸ“¡',
    labelKey: 'scene.status.default',
  },
  loading: {
    imagePath: '/ui/placeholders/scene-loading.webp',
    fallbackEmoji: 'â³',
    labelKey: 'scene.status.loading',
  },
  offline: {
    imagePath: '/ui/placeholders/scene-offline.webp',
    fallbackEmoji: 'ğŸ”Œ',
    labelKey: 'scene.status.offline',
  },
  blocked: {
    imagePath: '/ui/placeholders/scene-blocked.webp',
    fallbackEmoji: 'ğŸš«',
    labelKey: 'scene.status.blocked',
  },
  low_signal: {
    imagePath: '/ui/placeholders/scene-low-signal.webp',
    fallbackEmoji: 'ğŸ“‰',
    labelKey: 'scene.status.low_signal',
  },
};

// =============================================================================
// íƒ€ì… ì •ì˜
// =============================================================================

interface SceneImageProps {
  status: SceneCanvasStatus;
  imageUrl?: string;
  message?: string;
  className?: string;
}

// =============================================================================
// ì»´í¬ë„ŒíŠ¸ êµ¬í˜„
// =============================================================================

/**
 * ì¥ë©´ ì´ë¯¸ì§€ ë Œë”ë§ ì»´í¬ë„ŒíŠ¸
 *
 * - Lazy loading: ìƒˆ ì´ë¯¸ì§€ë¥¼ í”„ë¦¬ë¡œë“œí•˜ê³  ì™„ë£Œ ì‹œ êµì²´í•©ë‹ˆë‹¤.
 * - Option A: ìƒˆ ì´ë¯¸ì§€ ë¡œë”© ì¤‘ì—ë„ ì´ì „ ì´ë¯¸ì§€ë¥¼ ìœ ì§€í•©ë‹ˆë‹¤.
 * - í´ë°±: ë¡œë“œ ì‹¤íŒ¨ ì‹œ ì—ëŸ¬ ë°°ì§€ë¥¼ í‘œì‹œí•˜ê³  ì´ì „ ì´ë¯¸ì§€ë¥¼ ìœ ì§€í•©ë‹ˆë‹¤.
 */
export function SceneImage({ status, imageUrl, message, className = '' }: SceneImageProps) {
  const { t } = useTranslation();

  // ë‚´ë¶€ ìƒíƒœ ê´€ë¦¬
  const [imageError, setImageError] = useState(false);
  const [displayImageUrl, setDisplayImageUrl] = useState<string | null>(null);

  // íŒŒìƒ ìƒíƒœ: ë¡œë”© ì¤‘ ì—¬ë¶€
  // - ëª©í‘œ URL(imageUrl)ì´ ì¡´ì¬í•˜ê³ , í˜„ì¬ í‘œì‹œ ì¤‘ì¸ ì´ë¯¸ì§€ì™€ ë‹¤ë¥´ë©°, ì—ëŸ¬ê°€ ì•„ë‹Œ ê²½ìš°
  const isImageLoading = useMemo(() => {
    return !!imageUrl && imageUrl !== displayImageUrl && !imageError;
  }, [imageUrl, displayImageUrl, imageError]);

  // ì´ë¯¸ì§€ URL ë³€ê²½ ì‹œ ë¡œë”© í”„ë¡œì„¸ìŠ¤ ì‹œì‘
  useEffect(() => {
    // 1. URLì´ ì—†ê±°ë‚˜ ì´ë¯¸ í‘œì‹œ ì¤‘ì¸ ê²½ìš° ì´ˆê¸°í™” ë° ì¢…ë£Œ
    if (!imageUrl || imageUrl === displayImageUrl) {
      // eslint-disable-next-line react-hooks/set-state-in-effect
      setImageError(false);
      return;
    }

    // 2. ìƒˆ ì´ë¯¸ì§€ í”„ë¦¬ë¡œë“œ ì‹œì‘

    setImageError(false);

    let isMounted = true;
    const img = new Image();
    const currentUrl = imageUrl;

    const handleLoad = () => {
      if (!isMounted) return;
      setDisplayImageUrl(currentUrl);
      setImageError(false);
    };

    const handleError = () => {
      if (!isMounted) return;
      setImageError(true);
    };

    img.addEventListener('load', handleLoad);
    img.addEventListener('error', handleError);
    img.src = imageUrl;

    return () => {
      isMounted = false;
      img.removeEventListener('load', handleLoad);
      img.removeEventListener('error', handleError);
    };
  }, [imageUrl, displayImageUrl]);

  // ì´ë¯¸ì§€ ë¡œë”© ìƒíƒœ íƒ€ì… íŒŒìƒ (CSS í´ë˜ìŠ¤ìš©)
  const imageLoadingState: ImageLoadingState = useMemo(() => {
    if (isImageLoading) return 'loading';
    if (imageError) return 'error';
    if (displayImageUrl) return 'loaded';
    return 'idle';
  }, [isImageLoading, imageError, displayImageUrl]);

  const hasDisplayImage = !!displayImageUrl;
  const isSceneActive = status === 'scene' && hasDisplayImage && !imageError;

  // placeholder ì •ë³´ ê²°ì •
  const effectiveStatus = status === 'scene' && !hasDisplayImage ? 'default' : status;

  const isPlaceholderVisible = !hasDisplayImage;

  const placeholder = isPlaceholderVisible
    ? SCENE_PLACEHOLDERS[effectiveStatus as Exclude<SceneCanvasStatus, 'scene'>]
    : null;

  return (
    <div
      className={`scene-image-container ${isSceneActive ? 'scene-active' : `scene-status-${effectiveStatus}`} ${isImageLoading ? 'image-loading' : ''} ${className}`}
      style={placeholder ? { backgroundImage: `url('${placeholder.imagePath}')` } : {}}
    >
      {/* ì¥ë©´ ì´ë¯¸ì§€ */}
      {hasDisplayImage && (
        <img
          src={displayImageUrl}
          alt={t('scene.status.alt')}
          className={`scene-image ${imageLoadingState === 'loaded' ? 'scene-image-loaded' : ''}`}
        />
      )}

      {/* ë¡œë”© ì¸ë””ì¼€ì´í„° */}
      {isImageLoading && (
        <div className="scene-loading-indicator" aria-live="polite">
          <div className="scene-loading-spinner" aria-hidden="true" />
          <span className="scene-loading-text">{t('scene.status.image_loading')}</span>
        </div>
      )}

      {/* ì´ë¯¸ì§€ ì—ëŸ¬ ë°°ì§€ */}
      {imageError && (
        <div className="scene-error-badge" role="alert">
          <span className="scene-error-icon" aria-hidden="true">
            âš ï¸
          </span>
          <span className="scene-error-text">{t('scene.status.image_error')}</span>
        </div>
      )}

      {/* Placeholder ì˜ì—­ */}
      {isPlaceholderVisible && placeholder && (
        <div className="scene-placeholder">
          <p className="text-glow scene-status-label">
            <span className="scene-status-emoji" aria-hidden="true">
              {placeholder.fallbackEmoji}
            </span>{' '}
            {t(placeholder.labelKey)}
          </p>
          {message && <p className="scene-status-message">{message}</p>}
        </div>
      )}
    </div>
  );
}
</file>

<file path="frontend/src/demo/demoFixtures.ts">
/**
 * Unknown World - ë°ëª¨ìš© Fixtures (RU-003-Q5)
 *
 * DEV í™˜ê²½ì—ì„œ ì‚¬ìš©í•˜ëŠ” ë°ëª¨ ì´ˆê¸° ë°ì´í„°ì…ë‹ˆë‹¤.
 * ì–¸ì–´ ì¤‘ë¦½ì ì¸ ê°’(ID/ì•„ì´ì½˜/ìˆ˜ëŸ‰/ì¢Œí‘œ)ë§Œ í¬í•¨í•˜ë©°,
 * í‘œì‹œ ë¬¸ìì—´(name/label/hint)ì€ i18n í‚¤ë¥¼ í†µí•´ ë Œë”ë§í•©ë‹ˆë‹¤.
 *
 * ì„¤ê³„ ì›ì¹™:
 *   - RULE-006: ko/en í˜¼í•© ì¶œë ¥ ê¸ˆì§€ (i18n í‚¤ ê¸°ë°˜)
 *   - PRD 6.9: ë°ëª¨ í”„ë¡œí•„ ê²½ê³„ í™•ë³´
 *   - ì„œë²„ TurnOutput ëŒ€ì²´ ì‹œ ì´ ëª¨ë“ˆ ë¹„í™œì„±í™” ê°€ëŠ¥
 *
 * @module demo/demoFixtures
 */

import type { Box2D } from '../schemas/turn';

// =============================================================================
// íƒ€ì… ì •ì˜
// =============================================================================

/**
 * ë°ëª¨ ì¸ë²¤í† ë¦¬ ì•„ì´í…œ ì •ì˜ (ì–¸ì–´ ì¤‘ë¦½)
 *
 * nameì€ i18n í‚¤(`demo.items.{id}.name`)ë¡œ ë Œë”ë§í•©ë‹ˆë‹¤.
 */
export interface DemoInventoryItemDef {
  /** ì•„ì´í…œ ê³ ìœ  ID */
  id: string;
  /** ì•„ì´í…œ ì•„ì´ì½˜ (ì´ëª¨ì§€ ë˜ëŠ” URL) */
  icon: string;
  /** ì´ˆê¸° ìˆ˜ëŸ‰ */
  quantity: number;
}

/**
 * ë°ëª¨ ì”¬ ì˜¤ë¸Œì íŠ¸ ì •ì˜ (ì–¸ì–´ ì¤‘ë¦½)
 *
 * label/hintëŠ” i18n í‚¤ë¡œ ë Œë”ë§í•©ë‹ˆë‹¤:
 * - labelKey: `demo.scene.{id}.label`
 * - hintKey: `demo.scene.{id}.hint`
 */
export interface DemoSceneObjectDef {
  /** ì˜¤ë¸Œì íŠ¸ ê³ ìœ  ID */
  id: string;
  /** ë°”ìš´ë”© ë°•ìŠ¤ (0~1000 ì •ê·œí™”) */
  box_2d: Box2D;
  /** i18n ë¼ë²¨ í‚¤ */
  labelKey: string;
  /** i18n íŒíŠ¸ í‚¤ */
  hintKey: string;
}

// =============================================================================
// ë°ëª¨ ì¸ë²¤í† ë¦¬ ì•„ì´í…œ
// =============================================================================

/**
 * ë°ëª¨ìš© ì¸ë²¤í† ë¦¬ ì•„ì´í…œ ëª©ë¡.
 *
 * @remarks
 * - ID/ì•„ì´ì½˜/ìˆ˜ëŸ‰ë§Œ ì •ì˜ (ì–¸ì–´ ì¤‘ë¦½)
 * - í‘œì‹œ ì´ë¦„ì€ `demo.items.{id}.name` í‚¤ë¡œ i18n ì²˜ë¦¬
 */
export const DEMO_INVENTORY_ITEMS: readonly DemoInventoryItemDef[] = [
  { id: 'keycard-alpha', icon: 'ğŸ”‘', quantity: 1 },
  { id: 'medkit', icon: 'ğŸ©¹', quantity: 2 },
  { id: 'flashlight', icon: 'ğŸ”¦', quantity: 1 },
  { id: 'data-chip', icon: 'ğŸ’¾', quantity: 3 },
] as const;

// =============================================================================
// ë°ëª¨ ì”¬ ì˜¤ë¸Œì íŠ¸
// =============================================================================

/**
 * ë°ëª¨ìš© ì”¬ ì˜¤ë¸Œì íŠ¸ ëª©ë¡.
 *
 * @remarks
 * - ID/ì¢Œí‘œë§Œ ì •ì˜ (ì–¸ì–´ ì¤‘ë¦½)
 * - í‘œì‹œ ë¼ë²¨/íŒíŠ¸ëŠ” i18n í‚¤ë¡œ ì²˜ë¦¬
 */
export const DEMO_SCENE_OBJECTS: readonly DemoSceneObjectDef[] = [
  {
    id: 'demo-terminal',
    box_2d: { ymin: 300, xmin: 100, ymax: 600, xmax: 400 },
    labelKey: 'demo.scene.terminal.label',
    hintKey: 'demo.scene.terminal.hint',
  },
  {
    id: 'demo-door',
    box_2d: { ymin: 200, xmin: 600, ymax: 800, xmax: 900 },
    labelKey: 'demo.scene.door.label',
    hintKey: 'demo.scene.door.hint',
  },
] as const;

// =============================================================================
// ë°ëª¨ í€˜ìŠ¤íŠ¸ (U-013)
// =============================================================================

/**
 * ë°ëª¨ í€˜ìŠ¤íŠ¸ ì •ì˜ (ì–¸ì–´ ì¤‘ë¦½)
 *
 * labelì€ i18n í‚¤(`demo.quest.{id}.label`)ë¡œ ë Œë”ë§í•©ë‹ˆë‹¤.
 */
export interface DemoQuestDef {
  /** í€˜ìŠ¤íŠ¸ ê³ ìœ  ID */
  id: string;
  /** i18n ë¼ë²¨ í‚¤ */
  labelKey: string;
  /** ì™„ë£Œ ì—¬ë¶€ */
  is_completed: boolean;
}

/**
 * ë°ëª¨ìš© í€˜ìŠ¤íŠ¸ ëª©ë¡.
 */
export const DEMO_QUESTS: readonly DemoQuestDef[] = [
  {
    id: 'demo-quest-terminal',
    labelKey: 'demo.quest.terminal.label',
    is_completed: false,
  },
  {
    id: 'demo-quest-escape',
    labelKey: 'demo.quest.escape.label',
    is_completed: false,
  },
  {
    id: 'demo-quest-collect',
    labelKey: 'demo.quest.collect.label',
    is_completed: true,
  },
] as const;

// =============================================================================
// ë°ëª¨ ê·œì¹™ (U-013)
// =============================================================================

/**
 * ë°ëª¨ ê·œì¹™ ì •ì˜ (ì–¸ì–´ ì¤‘ë¦½)
 *
 * label/descriptionì€ i18n í‚¤ë¡œ ë Œë”ë§í•©ë‹ˆë‹¤.
 */
export interface DemoRuleDef {
  /** ê·œì¹™ ê³ ìœ  ID */
  id: string;
  /** i18n ë¼ë²¨ í‚¤ */
  labelKey: string;
  /** i18n ì„¤ëª… í‚¤ (ì„ íƒ) */
  descriptionKey?: string;
}

/**
 * ë°ëª¨ìš© ê·œì¹™ ëª©ë¡.
 */
export const DEMO_RULES: readonly DemoRuleDef[] = [
  {
    id: 'demo-rule-gravity',
    labelKey: 'demo.rule.gravity.label',
    descriptionKey: 'demo.rule.gravity.description',
  },
  {
    id: 'demo-rule-time',
    labelKey: 'demo.rule.time.label',
    descriptionKey: 'demo.rule.time.description',
  },
] as const;

// =============================================================================
// í—¬í¼ í•¨ìˆ˜
// =============================================================================

/**
 * ë°ëª¨ ì¸ë²¤í† ë¦¬ ì•„ì´í…œì˜ i18n ì´ë¦„ í‚¤ë¥¼ ìƒì„±í•©ë‹ˆë‹¤.
 *
 * @param itemId - ì•„ì´í…œ ID
 * @returns i18n í‚¤ (ì˜ˆ: `demo.items.keycard-alpha.name`)
 */
export function getDemoItemNameKey(itemId: string): string {
  return `demo.items.${itemId}.name`;
}

/**
 * ë°ëª¨ í™˜ê²½ì¸ì§€ í™•ì¸í•©ë‹ˆë‹¤ (DEV ê°€ë“œ).
 *
 * @returns DEV í™˜ê²½ ì—¬ë¶€
 */
export function isDemoEnvironment(): boolean {
  return import.meta.env.DEV;
}

/**
 * DOMì—ì„œ í˜„ì¬ í…Œë§ˆë¥¼ ì½ìŠµë‹ˆë‹¤.
 *
 * RU-003-Q5: 'dark' í•˜ë“œì½”ë”© ì œê±°
 * - data-theme ì†ì„±ì„ í™•ì¸í•˜ì—¬ í…Œë§ˆ ê²°ì •
 * - 'crt', 'dark' ë˜ëŠ” ë¯¸ì§€ì • â†’ 'dark'
 * - 'light' â†’ 'light'
 *
 * @returns í˜„ì¬ í…Œë§ˆ ('dark' | 'light')
 */
export function getCurrentThemeFromDOM(): 'dark' | 'light' {
  const dataTheme = document.documentElement.getAttribute('data-theme');

  // 'crt' í…Œë§ˆëŠ” dark ê³„ì—´ë¡œ ì·¨ê¸‰
  if (dataTheme === 'light') {
    return 'light';
  }
  return 'dark';
}
</file>

<file path="frontend/src/dnd/types.ts">
/**
 * Unknown World - DnD íƒ€ì… ë° ìƒìˆ˜ ì •ì˜ (RU-003-Q1).
 *
 * DnD ë°ì´í„° ê³„ì•½ì„ SSOTë¡œ ê´€ë¦¬í•˜ì—¬ íƒ€ì… ì•ˆì „ì„±ì„ í™•ë³´í•©ë‹ˆë‹¤.
 * ëª¨ë“  ë“œë˜ê·¸/ë“œë¡­ ì´ë²¤íŠ¸ì—ì„œ ë™ì¼í•œ ìƒìˆ˜/íƒ€ì…ì„ ì‚¬ìš©í•©ë‹ˆë‹¤.
 *
 * ì„¤ê³„ ì›ì¹™:
 *   - SSOT: ë“œë˜ê·¸/ë“œë¡­ íƒ€ì… ë¬¸ìì—´ì€ ì´ ëª¨ë“ˆì—ì„œë§Œ ì •ì˜
 *   - íƒ€ì… ì•ˆì „ì„±: dnd-kitì˜ data.currentë¥¼ íƒ€ì… ê°€ë“œë¡œ ê²€ì¦
 *   - ê³¼ë„í•œ ì¶”ìƒí™” ê¸ˆì§€: ìƒìˆ˜/íƒ€ì…ë§Œ ì œê³µ, ë¡œì§ì€ ì»´í¬ë„ŒíŠ¸ì— ìœ ì§€
 *
 * @module dnd/types
 */

import type { Box2D } from '../schemas/turn';
import type { InventoryItem } from '../stores/inventoryStore';

// =============================================================================
// DnD íƒ€ì… ìƒìˆ˜ (SSOT)
// =============================================================================

/**
 * DnD íƒ€ì… ìƒìˆ˜.
 * ë“œë˜ê·¸/ë“œë¡­ ë°ì´í„°ì˜ type í•„ë“œì— ì‚¬ìš©ë©ë‹ˆë‹¤.
 */
export const DND_TYPE = {
  /** ì¸ë²¤í† ë¦¬ ì•„ì´í…œ ë“œë˜ê·¸ */
  INVENTORY_ITEM: 'inventory-item',
  /** í•«ìŠ¤íŒŸ ë“œë¡­ íƒ€ê²Ÿ */
  HOTSPOT: 'hotspot',
} as const;

// =============================================================================
// RU-003-S2: ì¸í„°ë™ì…˜ í—ˆìš© ì •ì±… (SSOT)
// =============================================================================

/**
 * í•«ìŠ¤íŒŸ ì¸í„°ë™ì…˜ì´ í—ˆìš©ë˜ëŠ” Scene ìƒíƒœ ëª©ë¡.
 *
 * RU-003-S2 Step 1: Option A(ë°ëª¨ ìœ ì§€) ê²°ì •
 * - 'scene': ì‹¤ì œ ì¥ë©´ í™œì„±í™” ìƒíƒœ
 * - 'default': ë°ëª¨/í”Œë ˆì´ìŠ¤í™€ë” ìƒíƒœ (ì‹œê°ì  íŒíŠ¸ í•„ìš”)
 *
 * @see SceneCanvas.tsxì˜ shouldRenderHotspots ì¡°ê±´
 */
export const HOTSPOT_INTERACTION_ALLOWED_STATES = ['scene', 'default'] as const;

/**
 * ì¸í„°ë™ì…˜ í—ˆìš© ìƒíƒœ íƒ€ì….
 */
export type HotspotInteractionState = (typeof HOTSPOT_INTERACTION_ALLOWED_STATES)[number];

/**
 * ì£¼ì–´ì§„ ìƒíƒœì—ì„œ í•«ìŠ¤íŒŸ ì¸í„°ë™ì…˜ì´ í—ˆìš©ë˜ëŠ”ì§€ ê²€ì‚¬í•©ë‹ˆë‹¤.
 *
 * RU-003-S2: ì¸í„°ë™ì…˜ ê°€ëŠ¥ ì¡°ê±´ì„ SSOTë¡œ ê³ ì •
 *
 * @param status - Scene ìƒíƒœ
 * @returns ì¸í„°ë™ì…˜ í—ˆìš© ì—¬ë¶€
 */
export function isHotspotInteractionAllowed(status: string): boolean {
  return HOTSPOT_INTERACTION_ALLOWED_STATES.includes(status as HotspotInteractionState);
}

// =============================================================================
// RU-003-S2 Step 4: ìŠ¤íŠ¸ë¦¬ë° ë¹„í™œì„±í™” ì •ì±… (SSOT)
// =============================================================================

/**
 * ìŠ¤íŠ¸ë¦¬ë° ë¹„í™œì„±í™” ì •ì±….
 *
 * RU-003-S2 Step 4: disabled í”Œë˜ê·¸ì˜ SSOT ê³ ì •
 * - isStreamingì€ agentStoreì—ì„œë§Œ ì œê³µ
 * - ëª¨ë“  ì¸í„°ë™ì…˜ ì»´í¬ë„ŒíŠ¸(SceneCanvas, InventoryPanel, ActionDeck)ëŠ”
 *   ë™ì¼í•œ disabled í”Œë˜ê·¸ë¥¼ ê³µìœ í•´ì•¼ í•¨
 * - í–¥í›„ worldStore/Turn Runner ë„ì… ì‹œì—ë„ ì´ ì›ì¹™ì„ ìœ ì§€
 *
 * @see App.tsxì˜ isStreaming ì‚¬ìš© íŒ¨í„´
 * @see agentStore.tsì˜ isStreaming ìƒíƒœ
 */
export const STREAMING_DISABLED_POLICY = {
  /** ìŠ¤íŠ¸ë¦¬ë° ìƒíƒœ SSOT ì¶œì²˜ */
  source: 'agentStore.isStreaming',
  /** ë¹„í™œì„±í™” ì ìš© ëŒ€ìƒ ì»´í¬ë„ŒíŠ¸ */
  affectedComponents: ['SceneCanvas', 'InventoryPanel', 'ActionDeck', 'CommandInput'],
} as const;

/**
 * DnD íƒ€ì… ìœ ë‹ˆì˜¨.
 */
export type DndType = (typeof DND_TYPE)[keyof typeof DND_TYPE];

// =============================================================================
// ë“œë˜ê·¸ ë°ì´í„° íƒ€ì…
// =============================================================================

/**
 * ì¸ë²¤í† ë¦¬ ì•„ì´í…œ ë“œë˜ê·¸ ë°ì´í„°.
 * InventoryPanelì—ì„œ ë“œë˜ê·¸ ì‹œì‘ ì‹œ ì„¤ì •ë©ë‹ˆë‹¤.
 */
export interface InventoryDragData {
  /** ë“œë˜ê·¸ íƒ€ì… (í•­ìƒ 'inventory-item') */
  type: typeof DND_TYPE.INVENTORY_ITEM;
  /** ë“œë˜ê·¸ ì¤‘ì¸ ì•„ì´í…œ ID */
  item_id: string;
  /** ë“œë˜ê·¸ ì¤‘ì¸ ì•„ì´í…œ ê°ì²´ */
  item: InventoryItem;
}

// =============================================================================
// ë“œë¡­ ë°ì´í„° íƒ€ì…
// =============================================================================

/**
 * í•«ìŠ¤íŒŸ ë“œë¡­ íƒ€ê²Ÿ ë°ì´í„°.
 * SceneCanvasì˜ í•«ìŠ¤íŒŸì—ì„œ ì„¤ì •ë©ë‹ˆë‹¤.
 */
export interface HotspotDropData {
  /** ë“œë¡­ íƒ€ê²Ÿ íƒ€ì… (í•­ìƒ 'hotspot') */
  type: typeof DND_TYPE.HOTSPOT;
  /** í•«ìŠ¤íŒŸ ì˜¤ë¸Œì íŠ¸ ID */
  object_id: string;
  /** í•«ìŠ¤íŒŸ ë°”ìš´ë”© ë°•ìŠ¤ (0~1000 ì •ê·œí™”) */
  box_2d: Box2D;
  /** í•«ìŠ¤íŒŸ ë¼ë²¨ (í‘œì‹œìš©) */
  label: string;
}

// =============================================================================
// íƒ€ì… ê°€ë“œ í•¨ìˆ˜
// =============================================================================

/**
 * ë°ì´í„°ê°€ InventoryDragDataì¸ì§€ ê²€ì‚¬í•©ë‹ˆë‹¤.
 *
 * @param data - dnd-kitì˜ active.data.current
 * @returns InventoryDragDataì´ë©´ true
 */
export function isInventoryDragData(data: unknown): data is InventoryDragData {
  if (typeof data !== 'object' || data === null) {
    return false;
  }
  const obj = data as Record<string, unknown>;
  return (
    obj.type === DND_TYPE.INVENTORY_ITEM &&
    typeof obj.item_id === 'string' &&
    typeof obj.item === 'object' &&
    obj.item !== null
  );
}

/**
 * ë°ì´í„°ê°€ HotspotDropDataì¸ì§€ ê²€ì‚¬í•©ë‹ˆë‹¤.
 *
 * @param data - dnd-kitì˜ over.data.current
 * @returns HotspotDropDataì´ë©´ true
 */
export function isHotspotDropData(data: unknown): data is HotspotDropData {
  if (typeof data !== 'object' || data === null) {
    return false;
  }
  const obj = data as Record<string, unknown>;
  return (
    obj.type === DND_TYPE.HOTSPOT &&
    typeof obj.object_id === 'string' &&
    typeof obj.box_2d === 'object' &&
    obj.box_2d !== null &&
    typeof obj.label === 'string'
  );
}

// =============================================================================
// RU-003-S2 Step 2: í•«ìŠ¤íŒŸ ìš°ì„ ìˆœìœ„ ì •ì±… (SSOT)
// =============================================================================

/**
 * ë°”ìš´ë”© ë°•ìŠ¤ì˜ ë©´ì ì„ ê³„ì‚°í•©ë‹ˆë‹¤.
 *
 * @param box - { ymin, xmin, ymax, xmax } í˜•ì‹ì˜ ë°”ìš´ë”© ë°•ìŠ¤
 * @returns ë°•ìŠ¤ ë©´ì 
 */
export function calculateBoxArea(box: Box2D): number {
  const { ymin, xmin, ymax, xmax } = box;
  return Math.abs(ymax - ymin) * Math.abs(xmax - xmin);
}

/**
 * í•«ìŠ¤íŒŸ ìš°ì„ ìˆœìœ„ ê³„ì‚°ì„ ìœ„í•œ ë¹„êµ í•¨ìˆ˜.
 *
 * RU-003-S2 Step 2: ì‘ì€ bboxê°€ ë” ë†’ì€ ìš°ì„ ìˆœìœ„ë¥¼ ê°€ì§
 * - ë” ì‘ì€ ì˜¤ë¸Œì íŠ¸ê°€ ë” êµ¬ì²´ì ì¸ íƒ€ê²Ÿì´ë¼ê³  ê°€ì •
 * - z-index ê´€ì ì—ì„œ ì‘ì€ ê²ƒì´ ìœ„ì— ë Œë”ë˜ì–´ì•¼ í•¨
 *
 * @param a - ì²« ë²ˆì§¸ ë°”ìš´ë”© ë°•ìŠ¤
 * @param b - ë‘ ë²ˆì§¸ ë°”ìš´ë”© ë°•ìŠ¤
 * @returns ì •ë ¬ ìˆœì„œ (ì‘ì€ ê²ƒì´ ë’¤ë¡œ ê°€ì„œ z-indexê°€ ë†’ì•„ì§)
 */
export function compareHotspotPriority(a: Box2D, b: Box2D): number {
  return calculateBoxArea(b) - calculateBoxArea(a);
}
</file>

<file path="frontend/src/i18n-scenario.test.ts">
import { describe, it, expect, beforeEach, vi } from 'vitest';
import { getSessionLanguage, startSessionFromProfile } from './save/sessionLifecycle';
import { buildTurnInput } from './turn/turnRunner';
import { SAVEGAME_STORAGE_KEY, SAVEGAME_VERSION } from './save/constants';
import { PROFILE_EXPLORER } from './data/demoProfiles';
import { useWorldStore } from './stores/worldStore';
import { useInventoryStore } from './stores/inventoryStore';
import { useEconomyStore } from './stores/economyStore';

// i18n ëª¨ë“ˆ mock
vi.mock('./i18n', async () => {
  const actual = await vi.importActual('./i18n');
  return {
    ...actual,
    changeLanguage: vi.fn().mockResolvedValue(undefined),
    getResolvedLanguage: vi.fn().mockReturnValue('ko-KR'),
  };
});

describe('U-044[Mvp] i18n Session SSOT Scenario', () => {
  const mockT = (key: string) => `translated-${key}`;

  beforeEach(() => {
    localStorage.clear();
    vi.clearAllMocks();

    // Store ì´ˆê¸°í™”
    useWorldStore.getState().reset();
    useInventoryStore.getState().reset();
    useEconomyStore.getState().reset();
  });

  describe('Language SSOT (getSessionLanguage)', () => {
    it('SaveGameì´ ì—†ì„ ë•ŒëŠ” ê¸°ë³¸ ì–¸ì–´(ko-KR)ë¥¼ ë°˜í™˜í•´ì•¼ í•œë‹¤', () => {
      expect(getSessionLanguage()).toBe('ko-KR');
    });

    it('SaveGameì— ì €ì¥ëœ ì–¸ì–´ê°€ ìˆìœ¼ë©´ í•´ë‹¹ ì–¸ì–´ë¥¼ ë°˜í™˜í•´ì•¼ í•œë‹¤ (en-US)', () => {
      const saveGame = {
        version: SAVEGAME_VERSION,
        language: 'en-US',
        profileId: 'explorer',
        savedAt: new Date().toISOString(),
        economy: { signal: 100, memory_shard: 5 },
        economyLedger: [],
        turnCount: 1,
        narrativeHistory: [],
        inventory: [],
        quests: [],
        activeRules: [],
        mutationTimeline: [],
        sceneObjects: [],
      };
      localStorage.setItem(SAVEGAME_STORAGE_KEY, JSON.stringify(saveGame));

      expect(getSessionLanguage()).toBe('en-US');
    });

    it('i18n resolvedLanguageê°€ ë³€ê²½ë˜ì–´ë„ SaveGame ì–¸ì–´ë¥¼ ìš°ì„ í•´ì•¼ í•œë‹¤ (ë“œë¦¬í”„íŠ¸ ë°©ì§€)', () => {
      const saveGame = {
        version: SAVEGAME_VERSION,
        language: 'ko-KR',
        profileId: 'explorer',
        savedAt: new Date().toISOString(),
        economy: { signal: 100, memory_shard: 5 },
        economyLedger: [],
        turnCount: 1,
        narrativeHistory: [],
        inventory: [],
        quests: [],
        activeRules: [],
        mutationTimeline: [],
        sceneObjects: [],
      };
      localStorage.setItem(SAVEGAME_STORAGE_KEY, JSON.stringify(saveGame));

      // i18n.getResolvedLanguage()ê°€ 'en-US'ë¥¼ ë°˜í™˜í•˜ë„ë¡ ìƒí™© ê°€ì • (ë“œë¦¬í”„íŠ¸)
      // ì‹¤ì œë¡œëŠ” mockì´ë¯€ë¡œ ì§ì ‘ ë¹„êµëŠ” ì–´ë µì§€ë§Œ logicìƒ validSaveGame í™•ì¸ ìš°ì„ ìˆœìœ„ ê²€ì¦
      expect(getSessionLanguage()).toBe('ko-KR');
    });
  });

  describe('TurnInput Language Injection', () => {
    it('buildTurnInputì€ ì™¸ë¶€ì—ì„œ ì£¼ì…ëœ ì–¸ì–´ë¥¼ ì‚¬ìš©í•´ì•¼ í•œë‹¤', () => {
      const turnInput = buildTurnInput({
        text: 'hello',
        economySnapshot: { signal: 100, memory_shard: 0 },
        theme: 'dark',
        language: 'en-US', // ì£¼ì…ëœ ì–¸ì–´
      });

      expect(turnInput.language).toBe('en-US');
    });
  });

  describe('Session Language Policy (Toggle = Reset)', () => {
    it('startSessionFromProfile í˜¸ì¶œ ì‹œ ëª…ì‹œì  ì–¸ì–´ë¥¼ SaveGameì— ë°˜ì˜í•´ì•¼ í•œë‹¤', () => {
      startSessionFromProfile({
        profile: PROFILE_EXPLORER,

        t: mockT,

        language: 'en-US',
      });

      const saved = JSON.parse(localStorage.getItem(SAVEGAME_STORAGE_KEY)!);

      expect(saved.language).toBe('en-US');

      expect(getSessionLanguage()).toBe('en-US');
    });
  });

  describe('turnStream Error Message Language', () => {
    it('ë„¤íŠ¸ì›Œí¬ ì—ëŸ¬ ì‹œ ì…ë ¥ ì–¸ì–´ì— ë§ëŠ” í•œêµ­ì–´ ë©”ì‹œì§€ë¥¼ ë°˜í™˜í•´ì•¼ í•œë‹¤ (ko-KR)', async () => {
      const { executeTurnStream } = await import('./api/turnStream');

      const mockInput = {
        language: 'ko-KR' as const,

        text: 'Hello',

        action_id: null,

        click: null,

        drop: null,

        client: { viewport_w: 100, viewport_h: 100, theme: 'dark' as const },

        economy_snapshot: { signal: 100, memory_shard: 0 },
      };

      const onError = vi.fn();

      const onFinal = vi.fn();

      // fetch ì‹¤íŒ¨ ìœ ë„

      vi.stubGlobal('fetch', vi.fn().mockRejectedValue(new Error('Network Error')));

      await executeTurnStream(mockInput, { onError, onFinal });

      // onError ë³´ë‹¤ëŠ” onFinalì˜ narrativeë¥¼ ê²€ì¦ (createClientFallbackTurnOutput)

      // onErrorëŠ” error.messageë¥¼ ê·¸ëŒ€ë¡œ ì“°ë¯€ë¡œ 'Network Error'ê°€ ë‚˜ì˜´

      expect(onFinal).toHaveBeenCalledWith(
        expect.objectContaining({
          data: expect.objectContaining({
            language: 'ko-KR',

            narrative: '[ì‹œìŠ¤í…œ] ì„œë²„ ì—°ê²°ì— ì‹¤íŒ¨í–ˆìŠµë‹ˆë‹¤. ë‹¤ì‹œ ì‹œë„í•´ ì£¼ì„¸ìš”.',
          }),
        }),
      );

      vi.unstubAllGlobals();
    });

    it('ë„¤íŠ¸ì›Œí¬ ì—ëŸ¬ ì‹œ ì…ë ¥ ì–¸ì–´ì— ë§ëŠ” ì˜ì–´ ë©”ì‹œì§€ë¥¼ ë°˜í™˜í•´ì•¼ í•œë‹¤ (en-US)', async () => {
      const { executeTurnStream } = await import('./api/turnStream');

      const mockInput = {
        language: 'en-US' as const,

        text: 'Hello',

        action_id: null,

        click: null,

        drop: null,

        client: { viewport_w: 100, viewport_h: 100, theme: 'dark' as const },

        economy_snapshot: { signal: 100, memory_shard: 0 },
      };

      const onFinal = vi.fn();

      // fetch ì‹¤íŒ¨ ìœ ë„

      vi.stubGlobal('fetch', vi.fn().mockRejectedValue(new Error('Network Error')));

      await executeTurnStream(mockInput, { onFinal });

      expect(onFinal).toHaveBeenCalledWith(
        expect.objectContaining({
          data: expect.objectContaining({
            language: 'en-US',

            narrative: '[System] Failed to connect to server. Please try again.',
          }),
        }),
      );

      vi.unstubAllGlobals();
    });
  });
});
</file>

<file path="frontend/src/i18n.ts">
/**
 * Unknown World - i18n ì´ˆê¸°í™” ëª¨ë“ˆ
 *
 * ì–¸ì–´ ë¦¬ì†ŒìŠ¤ë¥¼ JSON íŒŒì¼ êµ¬ì¡°ë¡œ ê´€ë¦¬í•©ë‹ˆë‹¤.
 * RULE-006 ì¤€ìˆ˜: ko/en í˜¼í•© ì¶œë ¥ ê¸ˆì§€, i18n í‚¤ ê¸°ë°˜ SSOT
 *
 * ì–¸ì–´ ì½”ë“œ: BCP-47 í˜•ì‹ (ko-KR, en-US)
 * - TurnInput/SaveGameì˜ language í•„ë“œì™€ ë™ì¼í•œ ì¶•
 *
 * @see vibe/prd.md 3.1(ì§€ì› ì–¸ì–´), 8.7(TurnInput.language)
 * @see frontend/src/locales/README.md
 */

import i18n from 'i18next';
import { initReactI18next } from 'react-i18next';

// JSON ì–¸ì–´ ë¦¬ì†ŒìŠ¤ import (SSOT: locales/{lang}/translation.json)
import koKR from './locales/ko-KR/translation.json';
import enUS from './locales/en-US/translation.json';

/** ì§€ì› ì–¸ì–´ íƒ€ì… (TurnInput.languageì™€ ë™ê¸°í™”) */
export type SupportedLanguage = 'ko-KR' | 'en-US';

/** ê¸°ë³¸ ì–¸ì–´ (ë°ëª¨ ì¼ê´€ì„±ì„ ìœ„í•´ ko-KR ê³ ì •) */
export const DEFAULT_LANGUAGE: SupportedLanguage = 'ko-KR';

/** í´ë°± ì–¸ì–´ */
export const FALLBACK_LANGUAGE: SupportedLanguage = 'en-US';

/** ì§€ì› ì–¸ì–´ ëª©ë¡ */
export const SUPPORTED_LANGUAGES: SupportedLanguage[] = ['ko-KR', 'en-US'];

// i18n ë¦¬ì†ŒìŠ¤ ì •ì˜ (BCP-47 í˜•ì‹ ì–¸ì–´ ì½”ë“œ)
const resources = {
  'ko-KR': {
    translation: koKR,
  },
  'en-US': {
    translation: enUS,
  },
};

i18n.use(initReactI18next).init({
  resources,
  lng: DEFAULT_LANGUAGE,
  fallbackLng: FALLBACK_LANGUAGE,
  supportedLngs: SUPPORTED_LANGUAGES,
  interpolation: {
    escapeValue: false, // Reactì—ì„œ ì´ë¯¸ XSS ë°©ì§€
  },
  // ëˆ„ë½ í‚¤ ì²˜ë¦¬ (ê°œë°œ ëª¨ë“œì—ì„œ ê²½ê³ )
  saveMissing: false,
  missingKeyHandler: (_lngs, _ns, key) => {
    if (import.meta.env.DEV) {
      console.warn(`[i18n] Missing translation key: "${key}"`);
    }
  },
});

/**
 * í˜„ì¬ í•´ê²°ëœ ì–¸ì–´ ì½”ë“œë¥¼ ë°˜í™˜í•©ë‹ˆë‹¤.
 * TurnInput.languageì™€ ë™ê¸°í™”í•  ë•Œ ì‚¬ìš©í•©ë‹ˆë‹¤.
 */
export function getResolvedLanguage(): SupportedLanguage {
  return (i18n.resolvedLanguage as SupportedLanguage) || DEFAULT_LANGUAGE;
}

/**
 * ì–¸ì–´ë¥¼ ë³€ê²½í•©ë‹ˆë‹¤.
 * í–¥í›„ U-036 ì™„ë£Œ í›„ ì‚¬ìš©ìì—ê²Œ ë…¸ì¶œí•  í† ê¸€ì—ì„œ ì‚¬ìš©í•©ë‹ˆë‹¤.
 */
export async function changeLanguage(lang: SupportedLanguage): Promise<void> {
  await i18n.changeLanguage(lang);
}

export default i18n;
</file>

<file path="frontend/src/save/constants.ts">
/**
 * Unknown World - SaveGame/ì„¸ì…˜ ê´€ë ¨ ìƒìˆ˜ SSOT (RU-004-Q5).
 *
 * ì •ì±…/ì´ˆê¸°ê°’ì„ í•œ ê³³ìœ¼ë¡œ ëª¨ì•„ ë³€ê²½ ì‹œ ëˆ„ë½ ìœ„í—˜ì„ ë°©ì§€í•©ë‹ˆë‹¤.
 * ëª¨ë“  SaveGame/ì„¸ì…˜ ê´€ë ¨ ìƒìˆ˜ëŠ” ì´ íŒŒì¼ì—ì„œ ê´€ë¦¬í•©ë‹ˆë‹¤.
 *
 * ì„¤ê³„ ì›ì¹™:
 *   - RU-004-Q5: í•˜ë“œì½”ë”© ì •ë¦¬ - ìƒìˆ˜ ì¤‘ì•™í™”
 *   - RULE-010: DB ë„ì… ê¸ˆì§€, SaveGame JSON ì§ë ¬í™” ê¸°ë°˜
 *   - í–¥í›„ í™•ì¥: U-026(ë¦¬í”Œë ˆì´), U-025(ì—”ë”© ë¦¬í¬íŠ¸) í˜¸í™˜
 *
 * @module save/constants
 */

// =============================================================================
// SaveGame ë²„ì „ ê´€ë¦¬
// =============================================================================

/**
 * í˜„ì¬ SaveGame ìŠ¤í‚¤ë§ˆ ë²„ì „.
 *
 * ë²„ì „ ë³€ê²½ ì‹œ:
 * 1. migrations.tsì— ë§ˆì´ê·¸ë ˆì´ì…˜ í•¨ìˆ˜ ì¶”ê°€
 * 2. SUPPORTED_SAVEGAME_VERSIONSì— ì´ì „ ë²„ì „ ì¶”ê°€
 * 3. migrations.tsì˜ VERSION_ORDERì— ìƒˆ ë²„ì „ ì¶”ê°€
 *
 * ë²„ì „ í˜•ì‹: semver (major.minor.patch)
 *
 * @see saveGame.ts#migrateSaveGame
 * @see migrations.ts#upgradeToLatest
 */
export const SAVEGAME_VERSION = '1.0.0' as const;

/**
 * ì§€ì›í•˜ëŠ” SaveGame ë²„ì „ ëª©ë¡.
 *
 * ë§ˆì´ê·¸ë ˆì´ì…˜ ê°€ëŠ¥í•œ ì´ì „ ë²„ì „ë“¤ì„ í¬í•¨í•©ë‹ˆë‹¤.
 * ì´ ëª©ë¡ì— ì—†ëŠ” ë²„ì „ì€ ë§ˆì´ê·¸ë ˆì´ì…˜ ë¶ˆê°€ë¡œ ì²˜ë¦¬ë©ë‹ˆë‹¤.
 *
 * U-041: ë§ˆì´ê·¸ë ˆì´ì…˜ ì²´ì¸ì´ ìˆëŠ” ëª¨ë“  ë²„ì „ì„ í¬í•¨
 * - 0.9.0: í…ŒìŠ¤íŠ¸/ë°ëª¨ìš© êµ¬ë²„ì „ (sceneObjects, economyLedger ë“± ëˆ„ë½)
 * - 1.0.0: í˜„ì¬ ë²„ì „
 */
export const SUPPORTED_SAVEGAME_VERSIONS: readonly string[] = ['0.9.0', '1.0.0'] as const;

/**
 * ë§ˆì´ê·¸ë ˆì´ì…˜ ê°€ëŠ¥í•œ ìµœì†Œ ë²„ì „.
 *
 * ì´ ë²„ì „ë³´ë‹¤ ë‚®ì€ ë²„ì „ì€ ë§ˆì´ê·¸ë ˆì´ì…˜ì´ ë¶ˆê°€ëŠ¥í•˜ë©°,
 * ì €ì¥ ë°ì´í„°ê°€ íê¸°ë˜ê³  ìƒˆë¡œ ì‹œì‘í•´ì•¼ í•©ë‹ˆë‹¤.
 *
 * U-041: migrations.tsì˜ VERSION_ORDERì™€ ë™ê¸°í™” í•„ìš”
 */
export const MIN_MIGRATABLE_VERSION = '0.9.0' as const;

// =============================================================================
// localStorage í‚¤ (Storage Keys)
// =============================================================================

/**
 * SaveGame ì €ì¥ í‚¤.
 *
 * localStorageì—ì„œ ì„¸ì´ë¸Œ ë°ì´í„°ë¥¼ ì €ì¥/ë¡œë“œí•  ë•Œ ì‚¬ìš©í•©ë‹ˆë‹¤.
 * ì´ í‚¤ë¥¼ ë³€ê²½í•˜ë©´ ê¸°ì¡´ ì„¸ì´ë¸Œ ë°ì´í„°ê°€ ë¬´íš¨í™”ë©ë‹ˆë‹¤.
 */
export const SAVEGAME_STORAGE_KEY = 'unknown_world_savegame' as const;

/**
 * í˜„ì¬ ì„ íƒëœ í”„ë¡œí•„ ID ì €ì¥ í‚¤.
 *
 * localStorageì—ì„œ í˜„ì¬ í”„ë¡œí•„ IDë¥¼ ì €ì¥/ë¡œë“œí•  ë•Œ ì‚¬ìš©í•©ë‹ˆë‹¤.
 * SaveGame.profileIdê°€ SSOTì´ë©°, ì´ í‚¤ëŠ” í´ë°±/í˜¸í™˜ì„±ìš©ì…ë‹ˆë‹¤.
 *
 * @see sessionLifecycle.ts#getInitialProfileId
 */
export const CURRENT_PROFILE_KEY = 'unknown_world_current_profile' as const;

// =============================================================================
// Seed ìƒì„± ì •ì±…
// =============================================================================

/**
 * ë°ëª¨ seed ì ‘ë‘ì‚¬.
 *
 * ë°ëª¨ í”„ë¡œí•„ì—ì„œ ìƒì„±ë˜ëŠ” seedì˜ ì ‘ë‘ì‚¬ì…ë‹ˆë‹¤.
 * seed í˜•ì‹: `{DEMO_SEED_PREFIX}-{profileId}-{timestamp}`
 *
 * @example 'demo-narrator-1706000000000'
 */
export const DEMO_SEED_PREFIX = 'demo' as const;

/**
 * Seed ìƒì„± ì •ì±… (ë¬¸ì„œí™”ìš© ì£¼ì„).
 *
 * ## í˜„ì¬ ì •ì±…: now ê¸°ë°˜ seed (ì„¸ì…˜ ë‹¤ì–‘ì„± ì¤‘ì‹œ)
 *
 * í”„ë¡œí•„ ì‹œì‘ ì‹œë§ˆë‹¤ ìƒˆë¡œìš´ seedê°€ ìƒì„±ë©ë‹ˆë‹¤.
 * - ì¥ì : ë§¤ ì„¸ì…˜ë§ˆë‹¤ ë‹¤ë¥¸ ì´ˆê¸° ìƒíƒœ/ì´ë²¤íŠ¸ ê°€ëŠ¥
 * - ë‹¨ì : ë°ëª¨ ë°˜ë³µì„±(ë™ì¼ ì‹œì‘) ë³´ì¥ ì–´ë ¤ì›€
 *
 * ## ëŒ€ì•ˆ: ê³ ì • seed (ë°ëª¨ ë°˜ë³µì„± ì¤‘ì‹œ)
 *
 * í”„ë¡œí•„ IDë§Œìœ¼ë¡œ seedë¥¼ ìƒì„±í•©ë‹ˆë‹¤.
 * - ì¥ì : ë™ì¼ í”„ë¡œí•„ì€ í•­ìƒ ë™ì¼í•œ ì‹œì‘ ìƒíƒœ
 * - ë‹¨ì : ì„¸ì…˜ ë‹¤ì–‘ì„± ë¶€ì¡±
 *
 * ## í–¥í›„ í™•ì¥ (U-026: ë¦¬í”Œë ˆì´)
 *
 * seedë¥¼ SaveGameì— ì €ì¥í•˜ì—¬ ë¦¬í”Œë ˆì´ ì‹œ ë™ì¼ ê²°ê³¼ ì¬í˜„ ê°€ëŠ¥.
 * ì—”ë”© ë¦¬í¬íŠ¸(U-025)ì—ì„œë„ seedë¥¼ ê¸°ë¡í•˜ì—¬ ê²°ê³¼ ë¶„ì„ì— í™œìš©.
 *
 * @see demoProfiles.ts#profileToSaveGameInput
 */
export const SEED_POLICY = {
  /** í˜„ì¬ ì ìš© ì¤‘ì¸ ì •ì±… */
  current: 'timestamp' as const,
  /** ê°€ëŠ¥í•œ ì •ì±… ëª©ë¡ */
  options: ['timestamp', 'fixed', 'hybrid'] as const,
} as const;

/**
 * Seedë¥¼ ìƒì„±í•©ë‹ˆë‹¤.
 *
 * í˜„ì¬ ì •ì±…(now ê¸°ë°˜)ì— ë”°ë¼ seed ë¬¸ìì—´ì„ ìƒì„±í•©ë‹ˆë‹¤.
 *
 * @param profileId - í”„ë¡œí•„ ID
 * @returns seed ë¬¸ìì—´
 */
export function generateDemoSeed(profileId: string): string {
  const now = Date.now();
  return `${DEMO_SEED_PREFIX}-${profileId}-${now}`;
}

// =============================================================================
// Economy ì •ì±… ìƒìˆ˜
// =============================================================================

/**
 * ì”ì•¡ ë¶€ì¡± ê²½ê³  ì„ê³„ê°’ (Signal ê¸°ì¤€).
 *
 * Signal ì”ì•¡ì´ ì´ ê°’ ë¯¸ë§Œì´ë©´ isBalanceLowê°€ trueê°€ ë©ë‹ˆë‹¤.
 * HUDì—ì„œ ê²½ê³  í‘œì‹œ ë° ëŒ€ì²´ í–‰ë™ ì œì•ˆì— ì‚¬ìš©ë©ë‹ˆë‹¤.
 *
 * @see economyStore.ts#updateBalanceLowStatus
 */
export const LOW_BALANCE_THRESHOLD = 10 as const;

/**
 * ì›ì¥(Ledger) ìµœëŒ€ ë³´ê´€ ê°œìˆ˜.
 *
 * ìµœê·¼ Nê°œì˜ í„´ ì›ì¥ë§Œ ë³´ê´€í•©ë‹ˆë‹¤ (ë©”ëª¨ë¦¬ ìµœì í™”).
 * ì„¸ì…˜ ë‚´ì—ì„œë§Œ ìœ ì§€ë˜ë©°, SaveGameì— í•¨ê»˜ ì €ì¥ë©ë‹ˆë‹¤.
 *
 * @see economyStore.ts#addLedgerEntry
 */
export const LEDGER_MAX_ENTRIES = 20 as const;

// =============================================================================
// ì´ˆê¸°ê°’ ì •ì±… (Placeholder vs ì£¼ì…)
// =============================================================================

/**
 * World/Economy ì´ˆê¸°ê°’ ì •ì±… (ë¬¸ì„œí™”ìš© ì£¼ì„).
 *
 * ## ì„¤ê³„ ì›ì¹™
 *
 * Storeì˜ createInitialState()ì—ì„œ ì •ì˜í•˜ëŠ” economy ë“±ì˜ ê°’ì€
 * **"í”Œë ˆì´ ì „ placeholder"**ë¡œ ì·¨ê¸‰í•©ë‹ˆë‹¤.
 *
 * ì‹¤ì œ ê²Œì„ ì‹œì‘ ê°’ì€ í•­ìƒ ë‹¤ìŒ ì¤‘ í•˜ë‚˜ì—ì„œ ì£¼ì…ë©ë‹ˆë‹¤:
 * 1. í”„ë¡œí•„ ì´ˆê¸° SaveGame (startSessionFromProfile)
 * 2. ì €ì¥ëœ SaveGame ë³µì› (continueSession)
 *
 * ## Placeholder ê°’ì˜ ì˜ë¯¸
 *
 * - worldStore.economy: { signal: 100, memory_shard: 5 }
 *   â†’ playing ì§„ì… ì „ profile_select ìƒíƒœì—ì„œëŠ” HUDê°€ ë…¸ì¶œë˜ì§€ ì•ŠìŒ
 *   â†’ ë”°ë¼ì„œ ì´ ê°’ì´ í™”ë©´ì— í‘œì‹œë  ì¼ì€ ì—†ìŒ
 *
 * ## í–¥í›„ ê°œì„  (S2 ì„ í–‰ í•„ìš”)
 *
 * S2(ì˜ëª»ëœ playing ì§„ì…)ê°€ í•´ê²°ë˜ë©´:
 * - economy: null ê°™ì€ "ë¯¸ì´ˆê¸°í™” ìƒíƒœ"ë¡œ ë³€ê²½ ê°€ëŠ¥
 * - playing ì§„ì… ì „ì— ë°˜ë“œì‹œ í”„ë¡œí•„/ì„¸ì´ë¸Œ ì£¼ì…ì„ ê°•ì œ
 * - "placeholderê°€ í™”ë©´ì— ë³´ì´ëŠ”" ë¬¸ì œë¥¼ ì›ì²œ ì°¨ë‹¨
 *
 * @see worldStore.ts#createInitialState
 * @see sessionLifecycle.ts
 */
export const INITIAL_VALUE_POLICY = {
  description: 'Placeholder values for pre-play state',
  worldEconomy: {
    signal: 100,
    memory_shard: 5,
  },
} as const;

// =============================================================================
// ë°ëª¨ í”„ë¡œí•„ ê¸°ë³¸ ì¬í™” ë²”ìœ„ (ì°¸ê³ ìš©)
// =============================================================================

/**
 * ë°ëª¨ í”„ë¡œí•„ ì¬í™” ë²”ìœ„ ì°¸ê³  (ë¬¸ì„œí™”ìš©).
 *
 * ê° í”„ë¡œí•„ì˜ ì´ˆê¸° ì¬í™”ëŠ” demoProfiles.tsì—ì„œ ì§ì ‘ ì •ì˜í•©ë‹ˆë‹¤.
 * ì´ ìƒìˆ˜ëŠ” "ì •ì±… ë²”ìœ„"ë¥¼ ë¬¸ì„œí™”í•˜ê¸° ìœ„í•œ ì°¸ê³ ìš©ì…ë‹ˆë‹¤.
 *
 * - Narrator: í’ë¶€í•œ ì¬í™” (ë‹¤ì–‘í•œ ì„ íƒì§€ íƒìƒ‰)
 * - Explorer: ì ë‹¹í•œ ì¬í™” (ê· í˜• ì¡íŒ í”Œë ˆì´)
 * - Tech: ì œí•œëœ ì¬í™” (íš¨ìœ¨ì  ì „ëµ í•„ìš”)
 *
 * @see demoProfiles.ts
 */
export const DEMO_PROFILE_ECONOMY_REFERENCE = {
  narrator: { signal: 200, memory_shard: 10 },
  explorer: { signal: 150, memory_shard: 5 },
  tech: { signal: 80, memory_shard: 15 },
} as const;
</file>

<file path="frontend/src/save/saveGame.test.ts">
import { describe, it, expect, beforeEach, vi } from 'vitest';
import {
  SaveGameSchema,
  createSaveGame,
  saveSaveGame,
  loadSaveGame,
  clearSaveGame,
  hasSaveGame,
  SAVEGAME_STORAGE_KEY,
  SAVEGAME_VERSION,
  type SaveGameInput,
} from './saveGame';

describe('saveGame utility (U-015[Mvp])', () => {
  beforeEach(() => {
    // localStorage ì´ˆê¸°í™”
    localStorage.clear();
    vi.clearAllMocks();
  });

  const mockInput: SaveGameInput = {
    language: 'ko-KR',
    profileId: 'explorer',
    seed: 'test-seed',
    economy: { signal: 100, memory_shard: 5 },
    economyLedger: [],
    turnCount: 1,
    narrativeHistory: [{ turn: 1, text: 'í…ŒìŠ¤íŠ¸ ë‚´ëŸ¬í‹°ë¸Œ' }],
    inventory: [{ id: 'item1', name: 'ì•„ì´í…œ1', quantity: 1 }],
    quests: [{ id: 'q1', label: 'í€˜ìŠ¤íŠ¸1', is_completed: false }],
    activeRules: [{ id: 'r1', label: 'ê·œì¹™1', description: 'ì„¤ëª…1' }],
    mutationTimeline: [],
    sceneObjects: [],
  };

  it('createSaveGameì€ ì˜¬ë°”ë¥¸ ìŠ¤í‚¤ë§ˆë¥¼ ê°€ì§„ ê°ì²´ë¥¼ ìƒì„±í•´ì•¼ í•œë‹¤', () => {
    const saveGame = createSaveGame(mockInput);

    expect(saveGame.version).toBe(SAVEGAME_VERSION);
    expect(saveGame.language).toBe('ko-KR');
    expect(saveGame.profileId).toBe('explorer');
    expect(saveGame.economy.signal).toBe(100);
    expect(saveGame.inventory).toHaveLength(1);
    expect(saveGame.inventory[0].name).toBe('ì•„ì´í…œ1');

    // Zod ìŠ¤í‚¤ë§ˆ ê²€ì¦
    const result = SaveGameSchema.safeParse(saveGame);
    expect(result.success).toBe(true);
  });

  it('saveSaveGameì€ ë°ì´í„°ë¥¼ localStorageì— ì €ì¥í•´ì•¼ í•œë‹¤', () => {
    const saveGame = createSaveGame(mockInput);
    const success = saveSaveGame(saveGame);

    expect(success).toBe(true);
    expect(localStorage.getItem(SAVEGAME_STORAGE_KEY)).not.toBeNull();

    const storedData = JSON.parse(localStorage.getItem(SAVEGAME_STORAGE_KEY)!);
    expect(storedData.profileId).toBe('explorer');
  });

  it('loadSaveGameì€ ì €ì¥ëœ ë°ì´í„°ë¥¼ ì˜¬ë°”ë¥´ê²Œ ë¡œë“œí•´ì•¼ í•œë‹¤', () => {
    const saveGame = createSaveGame(mockInput);
    saveSaveGame(saveGame);

    const loaded = loadSaveGame();
    expect(loaded).not.toBeNull();
    expect(loaded?.profileId).toBe('explorer');
    expect(loaded?.version).toBe(SAVEGAME_VERSION);
  });

  it('ë°ì´í„°ê°€ ì—†ì„ ë•Œ loadSaveGameì€ nullì„ ë°˜í™˜í•´ì•¼ í•œë‹¤', () => {
    const loaded = loadSaveGame();
    expect(loaded).toBeNull();
  });

  it('ìœ íš¨í•˜ì§€ ì•Šì€ ë°ì´í„°ê°€ ì €ì¥ë˜ì–´ ìˆìœ¼ë©´ loadSaveGameì€ nullì„ ë°˜í™˜í•´ì•¼ í•œë‹¤', () => {
    localStorage.setItem(SAVEGAME_STORAGE_KEY, JSON.stringify({ version: 'unknown' }));

    // safeParse ì‹¤íŒ¨ë¡œ ì¸í•´ null ë°˜í™˜ ì˜ˆìƒ
    const loaded = loadSaveGame();
    expect(loaded).toBeNull();
  });

  it('êµ¬ë²„ì „(0.9.0) ë°ì´í„°ê°€ ì €ì¥ë˜ì–´ ìˆìœ¼ë©´ ë§ˆì´ê·¸ë ˆì´ì…˜ í›„ ë¡œë“œí•´ì•¼ í•œë‹¤', () => {
    const oldSave = {
      version: '0.9.0',
      language: 'ko-KR',
      seed: 'old-seed',
      profileId: 'narrator',
      savedAt: new Date().toISOString(),
      economy: {
        signal: 120,
        memory_shards: 8, // êµ¬ë²„ì „ ì˜¤íƒ€ í•„ë“œ
      },
      turnCount: 5,
      narrativeHistory: [],
      inventory: [],
      quests: [],
      activeRules: [],
      mutationTimeline: [],
      // sceneObjects ëˆ„ë½
    };

    localStorage.setItem(SAVEGAME_STORAGE_KEY, JSON.stringify(oldSave));

    const loaded = loadSaveGame();
    expect(loaded).not.toBeNull();
    expect(loaded?.version).toBe(SAVEGAME_VERSION);
    expect(loaded?.economy.memory_shard).toBe(8); // ë§ˆì´ê·¸ë ˆì´ì…˜ í™•ì¸
    expect(Array.isArray(loaded?.sceneObjects)).toBe(true); // í•„ë“œ ì¶”ê°€ í™•ì¸
    expect(loaded?.sceneObjects).toHaveLength(0);

    // ì €ì¥ì†Œì—ë„ ìµœì‹  ë°ì´í„°ë¡œ ì—…ë°ì´íŠ¸ë˜ì—ˆëŠ”ì§€ í™•ì¸ (ì„ íƒ ì‚¬í•­: í˜„ì¬ loadSaveGameì€ ë©”ëª¨ë¦¬ì—ì„œë§Œ ë³€í™˜í•˜ê³  ì €ì¥ì†Œ ì—…ë°ì´íŠ¸ëŠ” í•˜ì§€ ì•ŠìŒ)
    // ë§Œì•½ loadSaveGameì´ ì €ì¥ì†Œ ì—…ë°ì´íŠ¸ê¹Œì§€ ìˆ˜í–‰í•œë‹¤ë©´ ì•„ë˜ ê²€ì¦ ì¶”ê°€ ê°€ëŠ¥
  });

  it('clearSaveGameì€ ì €ì¥ëœ ë°ì´í„°ë¥¼ ì‚­ì œí•´ì•¼ í•œë‹¤', () => {
    const saveGame = createSaveGame(mockInput);
    saveSaveGame(saveGame);
    expect(hasSaveGame()).toBe(true);

    clearSaveGame();
    expect(hasSaveGame()).toBe(false);
    expect(localStorage.getItem(SAVEGAME_STORAGE_KEY)).toBeNull();
  });

  it('hasSaveGameì€ ë°ì´í„° ì¡´ì¬ ì—¬ë¶€ë¥¼ ì •í™•íˆ ë°˜í™˜í•´ì•¼ í•œë‹¤', () => {
    expect(hasSaveGame()).toBe(false);

    const saveGame = createSaveGame(mockInput);
    saveSaveGame(saveGame);
    expect(hasSaveGame()).toBe(true);
  });
});
</file>

<file path="frontend/src/stores/agentStore.test.ts">
import { describe, it, expect, beforeEach } from 'vitest';
import { useAgentStore } from './agentStore';
import { StreamEventType, StageStatus } from '../api/turnStream';
import type { TurnOutput } from '../schemas/turn';

describe('agentStore', () => {
  beforeEach(() => {
    useAgentStore.getState().reset();
  });

  it('should have correct initial state', () => {
    const state = useAgentStore.getState();
    expect(state.isStreaming).toBe(false);
    expect(state.phases).toHaveLength(7);
    expect(state.phases[0].status).toBe('pending');
    expect(state.badges).toEqual([]);
    expect(state.repairCount).toBe(0);
  });

  it('should handle startStream', () => {
    useAgentStore.getState().startStream();
    const state = useAgentStore.getState();
    expect(state.isStreaming).toBe(true);
  });

  it('should handle handleStage events', () => {
    const store = useAgentStore.getState();

    // Start parse phase
    store.handleStage({
      type: StreamEventType.STAGE,
      name: 'parse',
      status: StageStatus.START,
    });

    let state = useAgentStore.getState();
    expect(state.currentPhase).toBe('parse');
    expect(state.phases.find((p) => p.name === 'parse')?.status).toBe('in_progress');

    // Complete parse phase
    store.handleStage({
      type: StreamEventType.STAGE,
      name: 'parse',
      status: StageStatus.COMPLETE,
    });

    state = useAgentStore.getState();
    expect(state.phases.find((p) => p.name === 'parse')?.status).toBe('completed');
  });

  it('should handle handleBadges events', () => {
    const store = useAgentStore.getState();
    store.handleBadges({
      type: StreamEventType.BADGES,
      badges: ['schema_ok', 'economy_ok'],
    });

    const state = useAgentStore.getState();
    expect(state.badges).toEqual(['schema_ok', 'economy_ok']);
  });

  it('should handle handleNarrativeDelta events', () => {
    const store = useAgentStore.getState();
    store.handleNarrativeDelta({
      type: StreamEventType.NARRATIVE_DELTA,
      text: 'Hello ',
    });
    store.handleNarrativeDelta({
      type: StreamEventType.NARRATIVE_DELTA,
      text: 'World',
    });

    const state = useAgentStore.getState();
    expect(state.narrativeBuffer).toBe('Hello World');
  });

  it('should handle handleFinal events', () => {
    const store = useAgentStore.getState();
    const mockOutput = {
      language: 'ko-KR',
      narrative: 'Final message',
      economy: {
        cost: { signal: 0, memory_shard: 0 },
        balance_after: { signal: 100, memory_shard: 0 },
      },
      safety: { blocked: false, message: null },
      ui: { action_deck: { cards: [] }, objects: [], scene: { image_url: null, alt_text: null } },
      world: {
        rules_changed: [],
        inventory_added: [],
        inventory_removed: [],
        quests_updated: [],
        relationships_changed: [],
        memory_pins: [],
      },
      render: { image_job: null },
      agent_console: {
        repair_count: 2,
        current_phase: 'commit',
        badges: [],
      },
    } as TurnOutput;

    store.handleFinal({
      type: StreamEventType.FINAL,
      data: mockOutput,
    });

    const state = useAgentStore.getState();
    expect(state.finalOutput).toEqual(mockOutput);
    expect(state.repairCount).toBe(2);
  });

  it('should handle handleError events', () => {
    const store = useAgentStore.getState();
    store.handleError({
      type: StreamEventType.ERROR,
      message: 'Network error',
      code: 'ERR_NET',
    });

    const state = useAgentStore.getState();
    expect(state.error).toEqual({
      message: 'Network error',
      code: 'ERR_NET',
    });
  });

  it('should reset state on completeStream', () => {
    const store = useAgentStore.getState();
    store.handleNarrativeDelta({ type: StreamEventType.NARRATIVE_DELTA, text: 'Some text' });
    store.startStream();

    store.completeStream();

    const state = useAgentStore.getState();
    expect(state.isStreaming).toBe(false);
    expect(state.narrativeBuffer).toBe('');
  });
});
</file>

<file path="frontend/src/stores/uiPrefsStore.test.ts">
import { describe, it, expect, beforeEach } from 'vitest';
import { useUIPrefsStore, DEFAULT_UI_SCALE, migrateUIPrefs } from './uiPrefsStore';

// Mock localStorage for non-browser environment
// Note: With jsdom environment configured in vite.config.ts, this might not be strictly necessary
// if we trust jsdom's localStorage, but keeping it explicit is fine.
// However, since we are moving to direct function testing for migration, we rely less on persist middleware internals.

describe('uiPrefsStore', () => {
  beforeEach(() => {
    useUIPrefsStore.getState().resetPrefs();
    localStorage.clear();
  });

  it('should have default initial state', () => {
    const state = useUIPrefsStore.getState();
    expect(state.uiScale).toBe(DEFAULT_UI_SCALE);
  });

  it('should increase ui scale within limit', () => {
    const { increaseUIScale } = useUIPrefsStore.getState();

    // 1.0 -> 1.1
    increaseUIScale();
    expect(useUIPrefsStore.getState().uiScale).toBe(1.1);

    // 1.1 -> 1.2
    increaseUIScale();
    expect(useUIPrefsStore.getState().uiScale).toBe(1.2);

    // 1.2 -> 1.2 (Max)
    increaseUIScale();
    expect(useUIPrefsStore.getState().uiScale).toBe(1.2);
  });

  it('should decrease ui scale within limit', () => {
    const { decreaseUIScale, setUIScale } = useUIPrefsStore.getState();

    // Start at max
    setUIScale(1.2);

    // 1.2 -> 1.1
    decreaseUIScale();
    expect(useUIPrefsStore.getState().uiScale).toBe(1.1);

    // ... -> 0.9 (Min)
    setUIScale(0.9);
    decreaseUIScale();
    expect(useUIPrefsStore.getState().uiScale).toBe(0.9);
  });

  it('should set valid ui scale', () => {
    const { setUIScale } = useUIPrefsStore.getState();

    setUIScale(1.1);
    expect(useUIPrefsStore.getState().uiScale).toBe(1.1);
  });

  it('should ignore invalid ui scale', () => {
    const { setUIScale } = useUIPrefsStore.getState();

    // @ts-expect-error Testing invalid input
    setUIScale(2.0);
    expect(useUIPrefsStore.getState().uiScale).toBe(DEFAULT_UI_SCALE);
  });

  describe('migration (U-037)', () => {
    it('should remove readableMode from legacy storage', () => {
      // Legacy state simulation
      const legacyState = {
        uiScale: 1.1,
        readableMode: true,
      };

      // Call migrate function directly
      const migratedState = migrateUIPrefs(legacyState, 0);

      // Verify
      expect(migratedState).toHaveProperty('uiScale', 1.1);
      expect(migratedState).not.toHaveProperty('readableMode');
    });

    it('should handle undefined version (very old legacy)', () => {
      const legacyState = {
        uiScale: 0.9,
        readableMode: false,
      };

      // Call migrate function directly with undefined version
      const migratedState = migrateUIPrefs(legacyState, undefined);

      expect(migratedState).toHaveProperty('uiScale', 0.9);
      expect(migratedState).not.toHaveProperty('readableMode');
    });

    it('should pass through already migrated state', () => {
      const modernState = {
        uiScale: 1.0,
      };

      const migratedState = migrateUIPrefs(modernState, 1);
      expect(migratedState).toEqual(modernState);
    });
  });
});
</file>

<file path="frontend/src/stores/uiPrefsStore.ts">
/**
 * Unknown World - UI ì„¤ì • ìƒíƒœ ê´€ë¦¬ (Zustand + persist).
 *
 * UI ìŠ¤ì¼€ì¼ ì„¤ì •ì„ ì €ì¥í•˜ê³ , SaveGame êµ¬ì¡°ì™€ í†µí•© ê°€ëŠ¥í•˜ë„ë¡ ì§ë ¬í™” ì¸í„°í˜ì´ìŠ¤ë¥¼ ì œê³µí•©ë‹ˆë‹¤.
 *
 * ì„¤ê³„ ì›ì¹™:
 *   - PRD 9.4: ê°€ë…ì„±(í•„ìˆ˜) - ì „ì—­ UI ìŠ¤ì¼€ì¼ ì¡°ì ˆ ì œê³µ
 *   - U-037: Readable ëª¨ë“œ ì œê±° â†’ critical/ambient ì¤‘ìš”ë„ ê¸°ë°˜ ìŠ¤íƒ€ì¼ë¡œ ëŒ€ì²´
 *   - Q1 ê²°ì •: Option B (SaveGameì— í¬í•¨) - persist + ì§ë ¬í™”
 *
 * @module stores/uiPrefsStore
 */

import { create } from 'zustand';
import { persist, createJSONStorage } from 'zustand/middleware';

// =============================================================================
// ìƒìˆ˜ ì •ì˜
// =============================================================================

/** ì§€ì›í•˜ëŠ” UI ìŠ¤ì¼€ì¼ ê°’ */
export const UI_SCALES = [0.9, 1.0, 1.1, 1.2] as const;
export type UIScale = (typeof UI_SCALES)[number];

/** ê¸°ë³¸ UI ìŠ¤ì¼€ì¼ */
export const DEFAULT_UI_SCALE: UIScale = 1.0;

/** localStorage í‚¤ (SaveGame í†µí•© ì‹œì—ë„ ì‚¬ìš© ê°€ëŠ¥) */
export const UI_PREFS_STORAGE_KEY = 'unknown-world-ui-prefs';

// =============================================================================
// ìƒíƒœ íƒ€ì… ì •ì˜
// =============================================================================

/** UI ì„¤ì • ìƒíƒœ (SaveGame ì§ë ¬í™” ëŒ€ìƒ) */
export interface UIPrefsState {
  /**
   * UI ìŠ¤ì¼€ì¼ (0.9 ~ 1.2)
   * - 0.9: ì‘ì€ UI (ì •ë³´ ë°€ë„ ë†’ìŒ)
   * - 1.0: ê¸°ë³¸
   * - 1.1: ì•½ê°„ í™•ëŒ€
   * - 1.2: í° UI (ê°€ë…ì„± ìš°ì„ )
   */
  uiScale: UIScale;
}

/** UI ì„¤ì • ì•¡ì…˜ */
export interface UIPrefsActions {
  /** UI ìŠ¤ì¼€ì¼ ì„¤ì • */
  setUIScale: (scale: UIScale) => void;

  /** UI ìŠ¤ì¼€ì¼ ì¦ê°€ (ìµœëŒ€ 1.2) */
  increaseUIScale: () => void;

  /** UI ìŠ¤ì¼€ì¼ ê°ì†Œ (ìµœì†Œ 0.9) */
  decreaseUIScale: () => void;

  /** ì„¤ì • ì´ˆê¸°í™” */
  resetPrefs: () => void;

  /**
   * SaveGame ì§ë ¬í™”ìš© ìƒíƒœ ì¶”ì¶œ
   * (ì¶”í›„ SaveGame í†µí•© ì‹œ ì‚¬ìš©)
   */
  getSerializableState: () => UIPrefsState;

  /**
   * SaveGame ì—­ì§ë ¬í™”ìš© ìƒíƒœ ë³µì›
   * (ì¶”í›„ SaveGame í†µí•© ì‹œ ì‚¬ìš©)
   */
  restoreState: (state: Partial<UIPrefsState>) => void;
}

export type UIPrefsStore = UIPrefsState & UIPrefsActions;

// =============================================================================
// ì´ˆê¸° ìƒíƒœ
// =============================================================================

/** ì´ˆê¸° ìƒíƒœ ìƒì„± */
function createInitialState(): UIPrefsState {
  return {
    uiScale: DEFAULT_UI_SCALE,
  };
}

// =============================================================================
// ìœ í‹¸ë¦¬í‹° í•¨ìˆ˜
// =============================================================================

/**
 * ì£¼ì–´ì§„ ìŠ¤ì¼€ì¼ì´ ìœ íš¨í•œì§€ í™•ì¸
 */
function isValidScale(scale: number): scale is UIScale {
  return UI_SCALES.includes(scale as UIScale);
}

/**
 * ìŠ¤ì¼€ì¼ ì¸ë±ìŠ¤ ë°˜í™˜
 */
function getScaleIndex(scale: UIScale): number {
  return UI_SCALES.indexOf(scale);
}

/**
 * U-037: legacy ì €ì¥ê°’(readableMode) ë§ˆì´ê·¸ë ˆì´ì…˜/ë¬´ì‹œ
 * @internal exported for testing
 */
export function migrateUIPrefs(persistedState: unknown, version: number | undefined): UIPrefsState {
  // version 0 ë˜ëŠ” undefinedì—ì„œ version 1ë¡œ ë§ˆì´ê·¸ë ˆì´ì…˜
  // readableMode í•„ë“œê°€ ìˆìœ¼ë©´ ì œê±°
  if (version === 0 || version === undefined) {
    const state = persistedState as Record<string, unknown>;
    // readableMode í•„ë“œ ì œê±° (ë¬´ì‹œ)
    if ('readableMode' in state) {
      const { readableMode: _, ...rest } = state;
      return { ...rest, uiScale: state.uiScale ?? DEFAULT_UI_SCALE } as UIPrefsState;
    }
    return { ...state, uiScale: state.uiScale ?? DEFAULT_UI_SCALE } as UIPrefsState;
  }
  return persistedState as UIPrefsState;
}

// =============================================================================
// Zustand Store with persist
// =============================================================================

/**
 * UI ì„¤ì • ìŠ¤í† ì–´.
 *
 * U-037: Readable ëª¨ë“œ ì œê±°ë¨. CRT íš¨ê³¼ëŠ” critical/ambient ì¤‘ìš”ë„ ê¸°ë°˜ìœ¼ë¡œ ìë™ ì ìš©ë©ë‹ˆë‹¤.
 *
 * @example
 * ```tsx
 * // ì»´í¬ë„ŒíŠ¸ì—ì„œ ì‚¬ìš©
 * const { uiScale, setUIScale } = useUIPrefsStore();
 *
 * // DOM ì ìš© (App.tsxì—ì„œ)
 * useEffect(() => {
 *   document.documentElement.dataset.uiScale = uiScale.toString();
 *   document.documentElement.style.setProperty('--ui-scale-factor', uiScale.toString());
 * }, [uiScale]);
 * ```
 */
export const useUIPrefsStore = create<UIPrefsStore>()(
  persist(
    (set, get) => ({
      // ì´ˆê¸° ìƒíƒœ
      ...createInitialState(),

      // ì•¡ì…˜
      setUIScale: (scale) => {
        if (isValidScale(scale)) {
          set({ uiScale: scale });
        }
      },

      increaseUIScale: () => {
        const currentIndex = getScaleIndex(get().uiScale);
        const nextIndex = Math.min(currentIndex + 1, UI_SCALES.length - 1);
        set({ uiScale: UI_SCALES[nextIndex] });
      },

      decreaseUIScale: () => {
        const currentIndex = getScaleIndex(get().uiScale);
        const prevIndex = Math.max(currentIndex - 1, 0);
        set({ uiScale: UI_SCALES[prevIndex] });
      },

      resetPrefs: () => {
        set(createInitialState());
      },

      getSerializableState: () => {
        const { uiScale } = get();
        return { uiScale };
      },

      restoreState: (state) => {
        const updates: Partial<UIPrefsState> = {};

        if (state.uiScale !== undefined && isValidScale(state.uiScale)) {
          updates.uiScale = state.uiScale;
        }

        if (Object.keys(updates).length > 0) {
          set(updates);
        }
      },
    }),
    {
      name: UI_PREFS_STORAGE_KEY,
      storage: createJSONStorage(() => localStorage),
      // ì§ë ¬í™”í•  í•„ë“œ ì§€ì • (ì•¡ì…˜ ì œì™¸)
      partialize: (state) => ({
        uiScale: state.uiScale,
      }),
      // U-037: legacy ì €ì¥ê°’(readableMode) ë§ˆì´ê·¸ë ˆì´ì…˜/ë¬´ì‹œ
      version: 1,
      migrate: migrateUIPrefs,
    },
  ),
);

// =============================================================================
// ì…€ë ‰í„° (ì„±ëŠ¥ ìµœì í™”ìš©)
// =============================================================================

/** UI ìŠ¤ì¼€ì¼ ì…€ë ‰í„° */
export const selectUIScale = (state: UIPrefsStore) => state.uiScale;

// =============================================================================
// DOM ì ìš© í—¬í¼
// =============================================================================

/**
 * CSS ë³€ìˆ˜ë¡œ UI ìŠ¤ì¼€ì¼ ì ìš©
 * í˜¸ì¶œ ì‹œ html ìš”ì†Œì— --ui-scale-factor ë³€ìˆ˜ë¥¼ ì„¤ì •
 */
export function applyUIScaleToDOM(scale: UIScale): void {
  document.documentElement.style.setProperty('--ui-scale-factor', scale.toString());
  document.documentElement.dataset.uiScale = scale.toString();
}

/**
 * ì „ì²´ UI ì„¤ì • DOM ì ìš©
 * U-037: readableMode ì œê±°ë¨ - ìŠ¤ì¼€ì¼ë§Œ ì ìš©
 */
export function applyUIPrefsToDOM(state: UIPrefsState): void {
  applyUIScaleToDOM(state.uiScale);
}
</file>

<file path="frontend/src/stores/worldStore.test.ts">
import { describe, it, expect, beforeEach, vi } from 'vitest';
import { useWorldStore } from './worldStore';
import type { TurnOutput } from '../schemas/turn';

// í•˜ìœ„ ìŠ¤í† ì–´ ëª¨í‚¹ (ìˆœí™˜ import ë°©ì§€ ë¡œì§ ëŒ€ì‘)
vi.mock('./actionDeckStore', () => ({
  useActionDeckStore: {
    getState: () => ({
      setCards: vi.fn(),
    }),
  },
}));

vi.mock('./inventoryStore', () => ({
  useInventoryStore: {
    getState: () => ({
      addItems: vi.fn(),
      removeItems: vi.fn(),
    }),
  },
  parseInventoryAdded: (items: unknown) => items,
}));

describe('worldStore (U-013: Quest + Rules)', () => {
  beforeEach(() => {
    useWorldStore.getState().reset();
  });

  it('ì´ˆê¸° ìƒíƒœê°€ ì˜¬ë°”ë¼ì•¼ í•œë‹¤', () => {
    const state = useWorldStore.getState();
    expect(state.quests).toEqual([]);
    expect(state.activeRules).toEqual([]);
    expect(state.mutationTimeline).toEqual([]);
  });

  it('applyTurnOutputì„ í†µí•´ ìƒˆ í€˜ìŠ¤íŠ¸ê°€ ì¶”ê°€ë˜ì–´ì•¼ í•œë‹¤', () => {
    const mockOutput: Partial<TurnOutput> = {
      narrative: 'ìƒˆ í€˜ìŠ¤íŠ¸ ë°œìƒ',
      economy: {
        cost: { signal: 0, memory_shard: 0 },
        balance_after: { signal: 100, memory_shard: 5 },
      },
      ui: {
        scene: { image_url: '', alt_text: '' },
        action_deck: { cards: [] },
        objects: [],
      },
      world: {
        inventory_added: [],
        inventory_removed: [],
        quests_updated: [
          {
            id: 'q1',
            label: 'ì²« ë²ˆì§¸ ì„ë¬´',
            is_completed: false,
          },
        ],
        rules_changed: [],
        relationships_changed: [],
        memory_pins: [],
      },
      agent_console: {
        current_phase: 'commit',
        badges: ['schema_ok'],
        repair_count: 0,
      },
      safety: { blocked: false, message: null },
    };

    useWorldStore.getState().applyTurnOutput(mockOutput as TurnOutput);

    const state = useWorldStore.getState();
    expect(state.quests).toHaveLength(1);
    expect(state.quests[0].id).toBe('q1');
    expect(state.quests[0].is_completed).toBe(false);
  });

  it('ê¸°ì¡´ í€˜ìŠ¤íŠ¸ê°€ ì—…ë°ì´íŠ¸(ì™„ë£Œ)ë˜ì–´ì•¼ í•œë‹¤', () => {
    // 1. ì´ˆê¸° í€˜ìŠ¤íŠ¸ ì¶”ê°€
    const initialState: Partial<TurnOutput> = {
      narrative: 'ì´ˆê¸°í™”',
      economy: {
        cost: { signal: 0, memory_shard: 0 },
        balance_after: { signal: 100, memory_shard: 5 },
      },
      ui: {
        scene: { image_url: '', alt_text: '' },
        action_deck: { cards: [] },
        objects: [],
      },
      world: {
        inventory_added: [],
        inventory_removed: [],
        quests_updated: [{ id: 'q1', label: 'ì„ë¬´', is_completed: false }],
        rules_changed: [],
        relationships_changed: [],
        memory_pins: [],
      },
      agent_console: {
        current_phase: 'commit',
        badges: ['schema_ok'],
        repair_count: 0,
      },
      safety: { blocked: false, message: null },
    };
    useWorldStore.getState().applyTurnOutput(initialState as TurnOutput);

    // 2. í€˜ìŠ¤íŠ¸ ì™„ë£Œ ì—…ë°ì´íŠ¸
    const updateOutput: Partial<TurnOutput> = {
      narrative: 'ì„ë¬´ ì™„ë£Œ!',
      economy: {
        cost: { signal: 0, memory_shard: 0 },
        balance_after: { signal: 100, memory_shard: 5 },
      },
      ui: {
        scene: { image_url: '', alt_text: '' },
        action_deck: { cards: [] },
        objects: [],
      },
      world: {
        inventory_added: [],
        inventory_removed: [],
        quests_updated: [{ id: 'q1', label: 'ì„ë¬´', is_completed: true }],
        rules_changed: [],
        relationships_changed: [],
        memory_pins: [],
      },
      agent_console: {
        current_phase: 'commit',
        badges: ['schema_ok'],
        repair_count: 0,
      },
      safety: { blocked: false, message: null },
    };
    useWorldStore.getState().applyTurnOutput(updateOutput as TurnOutput);

    const state = useWorldStore.getState();
    expect(state.quests).toHaveLength(1);
    expect(state.quests[0].is_completed).toBe(true);
  });

  it('ìƒˆ ê·œì¹™ì´ ì¶”ê°€ë˜ê³  íƒ€ì„ë¼ì¸ì— ê¸°ë¡ë˜ì–´ì•¼ í•œë‹¤', () => {
    const mockOutput: Partial<TurnOutput> = {
      narrative: 'ìƒˆ ê·œì¹™ ì ìš©',
      economy: {
        cost: { signal: 0, memory_shard: 0 },
        balance_after: { signal: 100, memory_shard: 5 },
      },
      ui: {
        scene: { image_url: '', alt_text: '' },
        action_deck: { cards: [] },
        objects: [],
      },
      world: {
        inventory_added: [],
        inventory_removed: [],
        quests_updated: [],
        rules_changed: [
          {
            id: 'rule1',
            label: 'ì¤‘ë ¥ ê°•í™”',
            description: 'ì í”„ ë†’ì´ê°€ ì ˆë°˜ìœ¼ë¡œ ê°ì†Œí•©ë‹ˆë‹¤.',
          },
        ],
        relationships_changed: [],
        memory_pins: [],
      },
      agent_console: {
        current_phase: 'commit',
        badges: ['schema_ok'],
        repair_count: 0,
      },
      safety: { blocked: false, message: null },
    };

    useWorldStore.getState().applyTurnOutput(mockOutput as TurnOutput);

    const state = useWorldStore.getState();
    expect(state.activeRules).toHaveLength(1);
    expect(state.activeRules[0].id).toBe('rule1');

    expect(state.mutationTimeline).toHaveLength(1);
    expect(state.mutationTimeline[0].ruleId).toBe('rule1');
    expect(state.mutationTimeline[0].type).toBe('added');
  });

  it('ê¸°ì¡´ ê·œì¹™ ìˆ˜ì • ì‹œ íƒ€ì„ë¼ì¸ì— ê¸°ë¡ë˜ì–´ì•¼ í•œë‹¤', () => {
    // 1. ì´ˆê¸° ê·œì¹™ ì¶”ê°€
    const initialState: Partial<TurnOutput> = {
      narrative: 'ì´ˆê¸°í™”',
      economy: {
        cost: { signal: 0, memory_shard: 0 },
        balance_after: { signal: 100, memory_shard: 5 },
      },
      ui: {
        scene: { image_url: '', alt_text: '' },
        action_deck: { cards: [] },
        objects: [],
      },
      world: {
        inventory_added: [],
        inventory_removed: [],
        quests_updated: [],
        rules_changed: [{ id: 'rule1', label: 'ê·œì¹™', description: 'ê¸°ì¡´' }],
        relationships_changed: [],
        memory_pins: [],
      },
      agent_console: {
        current_phase: 'commit',
        badges: ['schema_ok'],
        repair_count: 0,
      },
      safety: { blocked: false, message: null },
    };
    useWorldStore.getState().applyTurnOutput(initialState as TurnOutput);

    // 2. ê·œì¹™ ìˆ˜ì •
    const updateOutput: Partial<TurnOutput> = {
      narrative: 'ê·œì¹™ ìˆ˜ì •',
      economy: {
        cost: { signal: 0, memory_shard: 0 },
        balance_after: { signal: 100, memory_shard: 5 },
      },
      ui: {
        scene: { image_url: '', alt_text: '' },
        action_deck: { cards: [] },
        objects: [],
      },
      world: {
        inventory_added: [],
        inventory_removed: [],
        quests_updated: [],
        rules_changed: [{ id: 'rule1', label: 'ê·œì¹™', description: 'ìˆ˜ì •ë¨' }],
        relationships_changed: [],
        memory_pins: [],
      },
      agent_console: {
        current_phase: 'commit',
        badges: ['schema_ok'],
        repair_count: 0,
      },
      safety: { blocked: false, message: null },
    };
    useWorldStore.getState().applyTurnOutput(updateOutput as TurnOutput);

    const state = useWorldStore.getState();
    expect(state.activeRules[0].description).toBe('ìˆ˜ì •ë¨');
    expect(state.mutationTimeline).toHaveLength(2);
    expect(state.mutationTimeline[0].type).toBe('modified');
  });

  describe('Initialization and Reset (U-015[Mvp])', () => {
    it('reset ì•¡ì…˜ì€ ëª¨ë“  ìƒíƒœë¥¼ ì´ˆê¸°ê°’ìœ¼ë¡œ ë˜ëŒë ¤ì•¼ í•œë‹¤', () => {
      // 1. ì„ì˜ì˜ ìƒíƒœ ì„¤ì •
      useWorldStore.setState({
        turnCount: 10,
        economy: { signal: 50, memory_shard: 0 },
        quests: [{ id: 'q1', label: 'í€˜ìŠ¤íŠ¸', is_completed: false }],
      });

      // 2. ë¦¬ì…‹ ì‹¤í–‰
      useWorldStore.getState().reset();

      // 3. ê²€ì¦
      const state = useWorldStore.getState();
      expect(state.turnCount).toBe(0);
      expect(state.economy.signal).toBe(100);
      expect(state.quests).toEqual([]);
      expect(state.narrativeEntries).toEqual([]);
    });

    it('initialize ì•¡ì…˜ì€ ì›°ì»´ ë©”ì‹œì§€ì™€ í•¨ê»˜ ì´ˆê¸° ìƒíƒœë¥¼ ì„¤ì •í•´ì•¼ í•œë‹¤', () => {
      const welcomeMsg = 'í™˜ì˜í•©ë‹ˆë‹¤!';
      useWorldStore.getState().initialize(welcomeMsg);

      const state = useWorldStore.getState();
      expect(state.turnCount).toBe(0);
      expect(state.narrativeEntries).toHaveLength(1);
      expect(state.narrativeEntries[0].text).toBe(welcomeMsg);
      expect(state.narrativeEntries[0].turn).toBe(0);
    });
  });
});
</file>

<file path="frontend/src/types/scene.ts">
/**
 * Scene Canvas ê´€ë ¨ íƒ€ì… ì •ì˜ (U-031: Placeholder Pack, U-020: Lazy Render)
 */

/**
 * Scene Canvas ìƒíƒœ íƒ€ì…
 * - default: ê¸°ë³¸ ìƒíƒœ (ì¥ë©´ ì´ë¯¸ì§€ ì—†ìŒ)
 * - loading: ë°ì´í„° ë¡œë”© ì¤‘
 * - offline: ì˜¤í”„ë¼ì¸/ì—°ê²° ëŠê¹€
 * - blocked: ì•ˆì „/ì •ì±… ì°¨ë‹¨
 * - low_signal: ì¬í™”/ì‹ í˜¸ ë¶€ì¡±
 * - scene: ì •ìƒ ì¥ë©´ í‘œì‹œ (ì´ë¯¸ì§€ URL í¬í•¨)
 */
export type SceneCanvasStatus =
  | 'default'
  | 'loading'
  | 'offline'
  | 'blocked'
  | 'low_signal'
  | 'scene';

/**
 * ì´ë¯¸ì§€ ë¡œë”© ìƒíƒœ (U-020: Lazy Render)
 * - idle: ì´ë¯¸ì§€ ì—†ìŒ/ëŒ€ê¸°
 * - loading: ì´ë¯¸ì§€ ë¡œë”© ì¤‘
 * - loaded: ì´ë¯¸ì§€ ë¡œë“œ ì™„ë£Œ
 * - error: ì´ë¯¸ì§€ ë¡œë“œ ì‹¤íŒ¨
 */
export type ImageLoadingState = 'idle' | 'loading' | 'loaded' | 'error';

/**
 * Scene Canvas ìƒíƒœ ë°ì´í„° êµ¬ì¡°
 *
 * U-020[Mvp] í™•ì¥:
 * - imageLoading: ì´ë¯¸ì§€ ë¡œë”© ìƒíƒœ í”Œë˜ê·¸ (ë¡œë”© ì¸ë””ì¼€ì´í„° í‘œì‹œìš©)
 * - previousImageUrl: ì´ì „ ì´ë¯¸ì§€ URL (Option A: ì´ì „ ì´ë¯¸ì§€ ìœ ì§€)
 */
export interface SceneCanvasState {
  status: SceneCanvasStatus;
  imageUrl?: string;
  message?: string;
  /** U-020: ì´ë¯¸ì§€ ë¡œë”© ì¤‘ ì—¬ë¶€ (ë¡œë”© ì¸ë””ì¼€ì´í„° í‘œì‹œìš©) */
  imageLoading?: boolean;
  /** U-020: ì´ì „ ì´ë¯¸ì§€ URL (ìƒˆ ì´ë¯¸ì§€ ë¡œë”© ì¤‘ í‘œì‹œìš©) */
  previousImageUrl?: string;
}

/**
 * ìƒíƒœë³„ placeholder ì •ë³´ êµ¬ì¡°
 */
export interface PlaceholderInfo {
  imagePath: string;
  fallbackEmoji: string;
  labelKey: string;
}
</file>

<file path="frontend/src/App.test.tsx">
import { describe, it, expect, vi, beforeEach } from 'vitest';
import { render, screen, fireEvent } from '@testing-library/react';
import App from './App';
import * as turnStream from './api/turnStream';

// i18next ëª¨í‚¹ (RU-003-Q5: ë°ëª¨ i18n í‚¤ ì§€ì›)
vi.mock('react-i18next', () => ({
  useTranslation: () => ({
    t: (key: string, options?: Record<string, unknown>) => {
      // ë°ëª¨ ì•„ì´í…œ ì´ë¦„
      if (key === 'demo.items.keycard-alpha.name') return 'í‚¤ì¹´ë“œ A';
      if (key === 'demo.items.medkit.name') return 'ì‘ê¸‰ í‚¤íŠ¸';
      if (key === 'demo.items.flashlight.name') return 'ì†ì „ë“±';
      if (key === 'demo.items.data-chip.name') return 'ë°ì´í„°ì¹©';
      // ë°ëª¨ ì”¬ ì˜¤ë¸Œì íŠ¸
      if (key === 'demo.scene.terminal.label') return 'í„°ë¯¸ë„';
      if (key === 'demo.scene.terminal.hint') return 'í™œì„±í™”ëœ í„°ë¯¸ë„ì´ë‹¤';
      if (key === 'demo.scene.door.label') return 'ë¬¸';
      if (key === 'demo.scene.door.hint') return 'ì ê²¨ìˆëŠ” ê²ƒ ê°™ë‹¤';
      // ì•¡ì…˜ í…œí”Œë¦¿
      if (key === 'scene.hotspot.click_action') {
        return `Click: ${options?.label}`;
      }
      return key;
    },
    i18n: {
      changeLanguage: () => Promise.resolve(),
      resolvedLanguage: 'ko-KR',
    },
  }),
  initReactI18next: {
    type: '3rdParty',
    init: () => {},
  },
}));

// ResizeObserver ëª¨í‚¹
class MockResizeObserver {
  observe = vi.fn();
  unobserve = vi.fn();
  disconnect = vi.fn();
}
global.ResizeObserver = MockResizeObserver as unknown as typeof ResizeObserver;

// getBoundingClientRect ëª¨í‚¹
Element.prototype.getBoundingClientRect = vi.fn(() => ({
  width: 800,
  height: 600,
  top: 0,
  left: 0,
  bottom: 600,
  right: 800,
  x: 0,
  y: 0,
  toJSON: () => {},
})) as unknown as () => DOMRect;

// api ëª¨í‚¹
vi.mock('./api/turnStream', () => ({
  startTurnStream: vi.fn(),
}));

describe('App Integration - Hotspot Click', () => {
  beforeEach(() => {
    vi.clearAllMocks();
  });

  it('should trigger startTurnStream when a hotspot is clicked', async () => {
    render(<App />);

    // ë°ëª¨ìš©ìœ¼ë¡œ App.tsxì— í•˜ë“œì½”ë”©ëœ 'í„°ë¯¸ë„' í•«ìŠ¤íŒŸ ì°¾ê¸°
    const terminalHotspot = screen.getByLabelText('í„°ë¯¸ë„');
    expect(terminalHotspot).toBeInTheDocument();

    // í´ë¦­ ì‹œë®¬ë ˆì´ì…˜
    fireEvent.click(terminalHotspot);

    // startTurnStream í˜¸ì¶œ í™•ì¸
    expect(turnStream.startTurnStream).toHaveBeenCalled();

    const [input] = vi.mocked(turnStream.startTurnStream).mock.calls[0];

    // TurnInput ê²€ì¦
    expect(input.text).toBe('Click: í„°ë¯¸ë„');
    expect(input.click).toEqual({
      object_id: 'demo-terminal',
      box_2d: { ymin: 300, xmin: 100, ymax: 600, xmax: 400 },
    });
  });
});
</file>

<file path="frontend/src/components/ActionDeck.test.tsx">
import { describe, it, expect, vi, beforeEach } from 'vitest';
import { render, screen, fireEvent } from '@testing-library/react';
import { ActionDeck } from './ActionDeck';
import type { ActionCard } from '../schemas/turn';
import { useActionDeckStore } from '../stores/actionDeckStore';
import { useWorldStore } from '../stores/worldStore';
import { useAgentStore } from '../stores/agentStore';

// i18next ëª¨í‚¹
vi.mock('react-i18next', () => ({
  useTranslation: () => ({
    t: (key: string, params?: Record<string, unknown>) => {
      if (params?.turn !== undefined) return `Turn ${params.turn}`;
      if (key === 'action.risk.low') return 'Low';
      if (key === 'action.risk.medium') return 'Medium';
      if (key === 'action.risk.high') return 'High';
      if (key === 'action.insufficient_balance') return 'Insufficient Balance';
      if (key === 'action.alternative') return 'Alt';
      return key;
    },
  }),
}));

describe('ActionDeck Component', () => {
  const mockCards: ActionCard[] = [
    {
      id: 'card-1',
      label: 'Regular Action',
      description: 'Test Description',
      cost: { signal: 10, memory_shard: 0 },
      cost_estimate: {
        min: { signal: 8, memory_shard: 0 },
        max: { signal: 12, memory_shard: 0 },
      },
      risk: 'low',
      hint: 'Positive hint',
      reward_hint: 'Bonus item',
      enabled: true,
      disabled_reason: null,
      is_alternative: false,
    },
    {
      id: 'card-2',
      label: 'Expensive Action',
      description: null,
      cost: { signal: 50, memory_shard: 1 },
      cost_estimate: null,
      risk: 'high',
      hint: 'Risky hint',
      reward_hint: null,
      enabled: true,
      disabled_reason: null,
      is_alternative: false,
    },
    {
      id: 'card-alt',
      label: 'Alternative Action',
      description: null,
      cost: { signal: 2, memory_shard: 0 },
      cost_estimate: null,
      risk: 'low',
      hint: null,
      reward_hint: null,
      enabled: true,
      disabled_reason: null,
      is_alternative: true,
    },
  ];

  beforeEach(() => {
    // ìŠ¤í† ì–´ ì´ˆê¸°í™”
    useActionDeckStore.setState({ cards: [] });
    useWorldStore.setState({ economy: { signal: 100, memory_shard: 5 } });
    useAgentStore.setState({ isStreaming: false });
  });

  it('renders provided cards from store', () => {
    useActionDeckStore.setState({ cards: mockCards });
    render(<ActionDeck />);
    expect(screen.getByText('Regular Action')).toBeInTheDocument();
    expect(screen.getByText('Expensive Action')).toBeInTheDocument();
    expect(screen.getByText('Alternative Action')).toBeInTheDocument();
  });

  it('displays cost estimates as ranges when available', () => {
    useActionDeckStore.setState({ cards: mockCards });
    render(<ActionDeck />);
    // card-1 has cost_estimate: 8~12
    expect(screen.getByText('8~12')).toBeInTheDocument();
    // card-2 has cost: 50
    expect(screen.getByText('50')).toBeInTheDocument();
  });

  it('disables cards when balance is insufficient in worldStore', () => {
    useActionDeckStore.setState({ cards: mockCards });
    useWorldStore.setState({ economy: { signal: 5, memory_shard: 0 } });

    render(<ActionDeck />);

    // Regular Action (cost 10/estimate max 12) -> disabled
    const card1 = screen.getByRole('button', { name: /Regular Action/i });
    expect(card1).toBeDisabled();
    expect(screen.getAllByText('Insufficient Balance').length).toBeGreaterThan(0);

    // Alternative Action (cost 2) -> enabled
    const cardAlt = screen.getByRole('button', { name: /Alternative Action/i });
    expect(cardAlt).not.toBeDisabled();
  });

  it('renders alternative badge for alternative cards', () => {
    useActionDeckStore.setState({ cards: mockCards });
    render(<ActionDeck />);
    expect(screen.getByText('Alt')).toBeInTheDocument();
  });

  it('calls onCardClick when an enabled card is clicked', () => {
    const onCardClick = vi.fn();
    useActionDeckStore.setState({ cards: mockCards });
    render(<ActionDeck onCardClick={onCardClick} />);

    fireEvent.click(screen.getByText('Regular Action'));
    expect(onCardClick).toHaveBeenCalledWith(expect.objectContaining({ id: 'card-1' }));
  });

  it('displays server-provided disabled reason', () => {
    const disabledCard: ActionCard[] = [
      {
        ...mockCards[0],
        enabled: false,
        disabled_reason: 'Locked by story',
      },
    ];
    useActionDeckStore.setState({ cards: disabledCard });
    render(<ActionDeck />);
    expect(screen.getByText('Locked by story')).toBeInTheDocument();
  });

  it('renders default cards when store cards are empty', () => {
    useActionDeckStore.setState({ cards: [] });
    render(<ActionDeck />);
    // useDefaultCards should provide some default labels
    expect(screen.getByText('action.default.explore.label')).toBeInTheDocument();
  });

  it('disables all cards when isStreaming is true in agentStore', () => {
    useActionDeckStore.setState({ cards: mockCards });
    useAgentStore.setState({ isStreaming: true });

    render(<ActionDeck />);

    const card1 = screen.getByRole('button', { name: /Regular Action/i });
    const cardAlt = screen.getByRole('button', { name: /Alternative Action/i });

    expect(card1).toBeDisabled();
    expect(cardAlt).toBeDisabled();
  });
});
</file>

<file path="frontend/src/components/DndInteraction.test.tsx">
import React from 'react';
import { describe, it, expect, vi, beforeEach } from 'vitest';
import { render, screen, act } from '@testing-library/react';
import App from '../App';
import * as turnStream from '../api/turnStream';

// dnd-kit ëª¨í‚¹ìš© íƒ€ì…
interface MockDndCallbacks {
  onDragEnd: (event: {
    active: { id: string; data: { current: unknown } };
    over: { id: string; data: { current: unknown } } | null;
  }) => void;
}

// dnd-kit ëª¨í‚¹ (ì½œë°± ê°€ë¡œì±„ê¸°ìš©)
vi.mock('@dnd-kit/core', async () => {
  const actual = (await vi.importActual('@dnd-kit/core')) as Record<string, unknown>;
  return {
    ...actual,
    DndContext: (props: MockDndCallbacks & { children: React.ReactNode }) => {
      // ì½œë°± ì €ì¥ (í…ŒìŠ¤íŠ¸ì—ì„œ ì ‘ê·¼ ê°€ëŠ¥í•˜ë„ë¡ globalì— ì €ì¥)
      (global as unknown as Record<string, unknown>).dndCallbacks = props;
      return <div data-testid="mock-dnd-context">{props.children}</div>;
    },
  };
});

// i18next ëª¨í‚¹ (RU-003-Q5: ë°ëª¨ i18n í‚¤ ì§€ì›)
vi.mock('react-i18next', () => ({
  useTranslation: () => ({
    t: (key: string, options?: Record<string, unknown>) => {
      // ë°ëª¨ ì•„ì´í…œ ì´ë¦„
      if (key === 'demo.items.keycard-alpha.name') return 'í‚¤ì¹´ë“œ A';
      if (key === 'demo.items.medkit.name') return 'ì‘ê¸‰ í‚¤íŠ¸';
      if (key === 'demo.items.flashlight.name') return 'ì†ì „ë“±';
      if (key === 'demo.items.data-chip.name') return 'ë°ì´í„°ì¹©';
      // ë°ëª¨ ì”¬ ì˜¤ë¸Œì íŠ¸
      if (key === 'demo.scene.terminal.label') return 'í„°ë¯¸ë„';
      if (key === 'demo.scene.terminal.hint') return 'í™œì„±í™”ëœ í„°ë¯¸ë„ì´ë‹¤';
      if (key === 'demo.scene.door.label') return 'ë¬¸';
      if (key === 'demo.scene.door.hint') return 'ì ê²¨ìˆëŠ” ê²ƒ ê°™ë‹¤';
      // ì•¡ì…˜ í…œí”Œë¦¿
      if (key === 'inventory.item_label') return `Item: ${options?.name}`;
      if (key === 'scene.hotspot.drop_action') {
        return `Drop: ${options?.item} on ${options?.target}`;
      }
      if (key === 'scene.hotspot.drop_invalid') {
        return `Invalid: ${options?.item}`;
      }
      if (key === 'connection.online') return 'ONLINE';
      return key;
    },
    i18n: {
      changeLanguage: () => Promise.resolve(),
      resolvedLanguage: 'ko-KR',
    },
  }),
  initReactI18next: {
    type: '3rdParty',
    init: () => {},
  },
}));

// ResizeObserver ëª¨í‚¹
class MockResizeObserver {
  observe = vi.fn();
  unobserve = vi.fn();
  disconnect = vi.fn();
}
global.ResizeObserver = MockResizeObserver as unknown as typeof ResizeObserver;
window.ResizeObserver = MockResizeObserver as unknown as typeof ResizeObserver;

// api ëª¨í‚¹
vi.mock('../api/turnStream', () => ({
  startTurnStream: vi.fn(),
}));

describe('DnD Interaction - Logic Test', () => {
  beforeEach(() => {
    vi.clearAllMocks();
  });

  it('should trigger turn execution when handleDragEnd is called with a hotspot target', async () => {
    render(<App />);
    const dndCallbacks = (global as unknown as Record<string, MockDndCallbacks>).dndCallbacks;

    // RU-003-Q1: ë“œë˜ê·¸ ë°ì´í„°ì— item ê°ì²´ í¬í•¨ (íƒ€ì… ê°€ë“œ ìš”êµ¬ì‚¬í•­)
    const mockItem = {
      id: 'keycard-alpha',
      name: 'í‚¤ì¹´ë“œ A',
      icon: 'ğŸ”‘',
      quantity: 1,
    };

    // ì„±ê³µ ì‹œë‚˜ë¦¬ì˜¤ ì‹œë®¬ë ˆì´ì…˜
    act(() => {
      dndCallbacks.onDragEnd({
        active: {
          id: 'keycard-alpha',
          data: {
            current: {
              type: 'inventory-item',
              item_id: 'keycard-alpha',
              item: mockItem,
            },
          },
        },
        over: {
          id: 'hotspot-demo-terminal',
          data: {
            current: {
              type: 'hotspot',
              object_id: 'demo-terminal',
              label: 'í„°ë¯¸ë„',
              box_2d: { ymin: 300, xmin: 100, ymax: 600, xmax: 400 },
            },
          },
        },
      });
    });

    // startTurnStream í˜¸ì¶œ í™•ì¸
    expect(turnStream.startTurnStream).toHaveBeenCalled();
    const [input] = vi.mocked(turnStream.startTurnStream).mock.calls[0];

    expect(input.text).toBe('Drop: í‚¤ì¹´ë“œ A on í„°ë¯¸ë„');
    expect(input.drop).toEqual({
      item_id: 'keycard-alpha',
      target_object_id: 'demo-terminal',
      target_box_2d: { ymin: 300, xmin: 100, ymax: 600, xmax: 400 },
    });
  });

  it('should show failure feedback when handleDragEnd is called with an invalid target', async () => {
    render(<App />);
    const dndCallbacks = (global as unknown as Record<string, MockDndCallbacks>).dndCallbacks;

    // RU-003-Q1: ë“œë˜ê·¸ ë°ì´í„°ì— item ê°ì²´ í¬í•¨ (íƒ€ì… ê°€ë“œ ìš”êµ¬ì‚¬í•­)
    const mockItem = {
      id: 'keycard-alpha',
      name: 'í‚¤ì¹´ë“œ A',
      icon: 'ğŸ”‘',
      quantity: 1,
    };

    // ì‹¤íŒ¨ ì‹œë‚˜ë¦¬ì˜¤ ì‹œë®¬ë ˆì´ì…˜ (overê°€ null)
    act(() => {
      dndCallbacks.onDragEnd({
        active: {
          id: 'keycard-alpha',
          data: {
            current: {
              type: 'inventory-item',
              item_id: 'keycard-alpha',
              item: mockItem,
            },
          },
        },
        over: null,
      });
    });

    // turn ì‹¤í–‰ì€ ë°œìƒí•˜ì§€ ì•Šì•„ì•¼ í•¨
    expect(turnStream.startTurnStream).not.toHaveBeenCalled();

    // ë‚´ëŸ¬í‹°ë¸Œ í”¼ë“œì— ì‹¤íŒ¨ ë©”ì‹œì§€ê°€ ë‚˜íƒ€ë‚˜ì•¼ í•¨
    const failureMessage = await screen.findByText(/Invalid: í‚¤ì¹´ë“œ A/);
    expect(failureMessage).toBeInTheDocument();
  });
});
</file>

<file path="frontend/src/components/GameHeader.tsx">
import type { ReactNode } from 'react';
import { useTranslation } from 'react-i18next';
import { UIControls } from './UIControls';
import { EconomyHudHeader } from './EconomyHud';
import type { UIScale } from '../stores/uiPrefsStore';
import { useEconomyStore, selectIsBalanceLow } from '../stores/economyStore';

interface GameHeaderProps {
  signal: number;
  memoryShard: number;
  isConnected: boolean;
  uiScale: UIScale;
  onIncreaseScale: () => void;
  onDecreaseScale: () => void;
  /** U-015: ì¶”ê°€ ì»¨íŠ¸ë¡¤ (ë¦¬ì…‹/í”„ë¡œí•„ ë³€ê²½ ë²„íŠ¼ ë“±) */
  children?: ReactNode;
}

export function GameHeader({
  signal,
  memoryShard,
  isConnected,
  uiScale,
  onIncreaseScale,
  onDecreaseScale,
  children,
}: GameHeaderProps) {
  const { t } = useTranslation();
  const isBalanceLow = useEconomyStore(selectIsBalanceLow);

  return (
    <header className="game-header has-chrome">
      <h1 className="game-title glitch" data-text={t('ui.logo')}>
        {t('ui.logo')}
      </h1>
      <div className="header-controls">
        {/* U-015: ë¦¬ì…‹/í”„ë¡œí•„ ë³€ê²½ ë“± ì¶”ê°€ ì»¨íŠ¸ë¡¤ */}
        {children}
        {/* UI ìŠ¤ì¼€ì¼ ì»¨íŠ¸ë¡¤ (U-028â†’U-037: Readable ì œê±°) */}
        <UIControls
          uiScale={uiScale}
          onIncreaseScale={onIncreaseScale}
          onDecreaseScale={onDecreaseScale}
        />
        {/* Economy HUD (U-014: ì˜ˆìƒ ë¹„ìš©/í™•ì • ë¹„ìš© í‘œì‹œ í¬í•¨) */}
        <EconomyHudHeader signal={signal} memoryShard={memoryShard} isLow={isBalanceLow} />
        <div className="connection-status">
          <span className={`status-indicator ${isConnected ? '' : 'offline'}`} />
          <span>{isConnected ? t('connection.online') : t('connection.offline')}</span>
        </div>
      </div>
    </header>
  );
}
</file>

<file path="frontend/src/components/InventoryPanel.tsx">
/**
 * Unknown World - Inventory Panel ì»´í¬ë„ŒíŠ¸ (U-011[Mvp]).
 *
 * dnd-kit ê¸°ë°˜ ë“œë˜ê·¸ ê°€ëŠ¥í•œ ì¸ë²¤í† ë¦¬ ì•„ì´í…œ UIë¥¼ ì œê³µí•©ë‹ˆë‹¤.
 *
 * ì„¤ê³„ ì›ì¹™:
 *   - RULE-002: InventoryëŠ” ê²Œì„ UIë¡œ ìƒì‹œ ë…¸ì¶œ (ì±„íŒ… ì…ë ¥ ëŒ€ì²´ ê¸ˆì§€)
 *   - tech-stack: dnd-kit ê¸°ë°˜ draggable êµ¬í˜„
 *   - U-012 ì—°ê²°: ë“œë˜ê·¸ ë°ì´í„°ì— item_id í¬í•¨í•˜ì—¬ ë“œë¡­ íƒ€ê²Ÿì— ì „ë‹¬
 *
 * @module components/InventoryPanel
 */

import { useCallback, useMemo } from 'react';
import { useDraggable, DragOverlay } from '@dnd-kit/core';
import { CSS } from '@dnd-kit/utilities';
import { useTranslation } from 'react-i18next';
import {
  useInventoryStore,
  type InventoryItem,
  selectItems,
  selectDraggingItem,
  selectSelectedItemId,
} from '../stores/inventoryStore';
import { DND_TYPE, type InventoryDragData } from '../dnd/types';

// =============================================================================
// ë“œë˜ê·¸ ê°€ëŠ¥í•œ ì•„ì´í…œ ì»´í¬ë„ŒíŠ¸
// =============================================================================

interface DraggableItemProps {
  item: InventoryItem;
  isSelected: boolean;
  onSelect: (itemId: string) => void;
  disabled?: boolean;
}

/**
 * ë“œë˜ê·¸ ê°€ëŠ¥í•œ ì¸ë²¤í† ë¦¬ ì•„ì´í…œ.
 * dnd-kitì˜ useDraggable í›…ì„ ì‚¬ìš©í•©ë‹ˆë‹¤.
 */
function DraggableItem({ item, isSelected, onSelect, disabled = false }: DraggableItemProps) {
  const { t } = useTranslation();

  // dnd-kit ë“œë˜ê·¸ ì„¤ì • (RU-003-Q1: ìƒìˆ˜/íƒ€ì… ê¸°ë°˜)
  const dragData: InventoryDragData = {
    type: DND_TYPE.INVENTORY_ITEM,
    item_id: item.id,
    item,
  };
  const { attributes, listeners, setNodeRef, transform, isDragging } = useDraggable({
    id: item.id,
    data: dragData,
    disabled,
  });

  // ë³€í™˜ ìŠ¤íƒ€ì¼ ê³„ì‚°
  // ë“œë˜ê·¸ ì¤‘ì¼ ë•ŒëŠ” ì›ë³¸ ì•„ì´í…œì´ ì œìë¦¬ì— ìˆë„ë¡ transform ì ìš©í•˜ì§€ ì•ŠìŒ
  // DragOverlayê°€ ë³„ë„ë¡œ ë Œë”ë§ë˜ë¯€ë¡œ ì›ë³¸ì€ ìœ„ì¹˜ ê³ ì •
  const style = useMemo(
    () => ({
      transform: isDragging ? undefined : CSS.Translate.toString(transform),
      opacity: isDragging ? 0.3 : 1,
    }),
    [transform, isDragging],
  );

  // í´ë¦­ í•¸ë“¤ëŸ¬ (ì„ íƒ)
  const handleClick = useCallback(() => {
    if (!disabled) {
      onSelect(item.id);
    }
  }, [disabled, item.id, onSelect]);

  // ì•„ì´ì½˜ ë Œë”ë§ (ì´ëª¨ì§€ ë˜ëŠ” ì´ë¯¸ì§€)
  const renderIcon = () => {
    if (item.icon) {
      // URL í˜•íƒœë©´ ì´ë¯¸ì§€, ì•„ë‹ˆë©´ ì´ëª¨ì§€
      if (item.icon.startsWith('http') || item.icon.startsWith('/')) {
        return (
          <img
            src={item.icon}
            alt={item.name}
            className="inventory-item-icon-img"
            onError={(e) => {
              e.currentTarget.style.display = 'none';
            }}
          />
        );
      }
      return <span className="inventory-item-icon-emoji">{item.icon}</span>;
    }
    // ê¸°ë³¸ ì•„ì´ì½˜ (ğŸ“¦)
    return <span className="inventory-item-icon-emoji">ğŸ“¦</span>;
  };

  return (
    <div
      ref={setNodeRef}
      style={style}
      className={`inventory-item ${isSelected ? 'selected' : ''} ${isDragging ? 'dragging' : ''} ${disabled ? 'disabled' : ''}`}
      onClick={handleClick}
      aria-label={t('inventory.item_label', { name: item.name, quantity: item.quantity })}
      aria-selected={isSelected}
      {...attributes}
      {...listeners}
    >
      <div className="inventory-item-icon">{renderIcon()}</div>
      <div className="inventory-item-info">
        <span className="inventory-item-name">{item.name}</span>
        {item.quantity > 1 && <span className="inventory-item-quantity">x{item.quantity}</span>}
      </div>
    </div>
  );
}

// =============================================================================
// ë“œë˜ê·¸ ì˜¤ë²„ë ˆì´ (ë“œë˜ê·¸ ì¤‘ í‘œì‹œë˜ëŠ” ì•„ì´í…œ)
// =============================================================================

interface ItemOverlayProps {
  item: InventoryItem;
}

/**
 * ë“œë˜ê·¸ ì˜¤ë²„ë ˆì´ ì•„ì´í…œ.
 * ë“œë˜ê·¸ ì¤‘ì¼ ë•Œ ì»¤ì„œë¥¼ ë”°ë¼ë‹¤ë‹ˆëŠ” ì•„ì´í…œ í‘œì‹œì…ë‹ˆë‹¤.
 */
function ItemOverlay({ item }: ItemOverlayProps) {
  // ì•„ì´ì½˜ ë Œë”ë§
  const renderIcon = () => {
    if (item.icon) {
      if (item.icon.startsWith('http') || item.icon.startsWith('/')) {
        return <img src={item.icon} alt={item.name} className="inventory-item-icon-img" />;
      }
      return <span className="inventory-item-icon-emoji">{item.icon}</span>;
    }
    return <span className="inventory-item-icon-emoji">ğŸ“¦</span>;
  };

  return (
    <div className="inventory-item overlay">
      <div className="inventory-item-icon">{renderIcon()}</div>
      <div className="inventory-item-info">
        <span className="inventory-item-name">{item.name}</span>
        {item.quantity > 1 && <span className="inventory-item-quantity">x{item.quantity}</span>}
      </div>
    </div>
  );
}

// =============================================================================
// ë©”ì¸ Inventory Panel ì»´í¬ë„ŒíŠ¸
// =============================================================================

interface InventoryPanelProps {
  /** ìƒí˜¸ì‘ìš© ë¹„í™œì„±í™” (ìŠ¤íŠ¸ë¦¬ë° ì¤‘ ë“±) */
  disabled?: boolean;
}

/**
 * Inventory Panel ì»´í¬ë„ŒíŠ¸.
 *
 * ì¸ë²¤í† ë¦¬ ì•„ì´í…œì„ ê·¸ë¦¬ë“œë¡œ í‘œì‹œí•˜ê³ , ë“œë˜ê·¸ ê°€ëŠ¥í•˜ê²Œ í•©ë‹ˆë‹¤.
 * DndContextëŠ” App ìµœìƒë‹¨ì— ë°°ì¹˜ë©ë‹ˆë‹¤ (Q1: Option A).
 *
 * @example
 * ```tsx
 * <InventoryPanel disabled={isStreaming} />
 * ```
 */
export function InventoryPanel({ disabled = false }: InventoryPanelProps) {
  const { t } = useTranslation();

  // Store ìƒíƒœ
  const items = useInventoryStore(selectItems);
  const draggingItem = useInventoryStore(selectDraggingItem);
  const selectedItemId = useInventoryStore(selectSelectedItemId);
  const selectItem = useInventoryStore((state) => state.selectItem);

  // ì•„ì´í…œ ì„ íƒ í•¸ë“¤ëŸ¬
  const handleSelect = useCallback(
    (itemId: string) => {
      // ì´ë¯¸ ì„ íƒëœ ì•„ì´í…œ í´ë¦­ ì‹œ ì„ íƒ í•´ì œ
      selectItem(selectedItemId === itemId ? null : itemId);
    },
    [selectedItemId, selectItem],
  );

  // ë¹ˆ ì¸ë²¤í† ë¦¬
  if (items.length === 0) {
    return (
      <div className="inventory-panel-content">
        <div className="inventory-empty">
          <span className="inventory-empty-icon">ğŸ“¦</span>
          <span className="inventory-empty-text">{t('inventory.empty')}</span>
        </div>
      </div>
    );
  }

  return (
    <div className="inventory-panel-content" data-ui-importance="critical">
      <div
        className="inventory-grid"
        role="listbox"
        aria-label={t('inventory.grid_label')}
        aria-multiselectable={false}
      >
        {items.map((item) => (
          <DraggableItem
            key={item.id}
            item={item}
            isSelected={selectedItemId === item.id}
            onSelect={handleSelect}
            disabled={disabled}
          />
        ))}
      </div>

      {/* ë“œë˜ê·¸ ì˜¤ë²„ë ˆì´ */}
      <DragOverlay dropAnimation={null}>
        {draggingItem ? <ItemOverlay item={draggingItem} /> : null}
      </DragOverlay>
    </div>
  );
}

export default InventoryPanel;
</file>

<file path="frontend/src/data/demoProfiles.ts">
/**
 * Unknown World - ë°ëª¨ í”„ë¡œí•„ ì •ì˜ (U-015[Mvp]).
 *
 * ë¡œê·¸ì¸ ì—†ì´ ì¦‰ì‹œ ì‹œì‘ ê°€ëŠ¥í•œ ë°ëª¨ í”„ë¡œí•„ 3ì¢…ì„ ì •ì˜í•©ë‹ˆë‹¤.
 * ê° í”„ë¡œí•„ì€ ì„œë¡œ ë‹¤ë¥¸ ì´ˆê¸° ìƒíƒœ(ì¬í™”/ì¸ë²¤í† ë¦¬/í€˜ìŠ¤íŠ¸/ë£°)ë¥¼ ê°€ì§‘ë‹ˆë‹¤.
 *
 * í”„ë¡œí•„:
 *   1. Narrator: ë‚´ëŸ¬í‹°ë¸Œ/ìŠ¤í† ë¦¬ ì¤‘ì‹¬ ì²´í—˜
 *   2. Explorer: íƒìƒ‰/ë°œê²¬ ì¤‘ì‹¬ ì²´í—˜
 *   3. Tech Enthusiast: ì‹œìŠ¤í…œ/ë©”ì»¤ë‹‰ ì¤‘ì‹¬ ì²´í—˜
 *
 * ì„¤ê³„ ì›ì¹™:
 *   - RULE-006: í‘œì‹œ ë¬¸ìì—´ì€ i18n í‚¤ ê¸°ë°˜
 *   - RULE-010: SaveGame JSON ì§ë ¬í™”ë¡œ ì €ì¥
 *   - PRD 6.9: ë°ëª¨ í”„ë¡œí•„ 3ì¢… + ì¦‰ì‹œ ë¦¬ì…‹
 *   - RU-004-Q5: seed ìƒì„±ì€ constants.ts SSOT ì‚¬ìš©
 *
 * @module data/demoProfiles
 */

import type { SupportedLanguage } from '../i18n';
import type { SaveGame, SaveGameInput } from '../save/saveGame';
import { createSaveGame } from '../save/saveGame';
// RU-004-Q5: seed ìƒì„± ì •ì±… SSOT
import { generateDemoSeed } from '../save/constants';

// =============================================================================
// í”„ë¡œí•„ íƒ€ì… ì •ì˜
// =============================================================================

/**
 * ë°ëª¨ í”„ë¡œí•„ ì •ì˜ (ì–¸ì–´ ì¤‘ë¦½).
 * í‘œì‹œìš© ë¬¸ìì—´ì€ i18n í‚¤ë¡œ ì°¸ì¡°í•©ë‹ˆë‹¤.
 */
export interface DemoProfileDef {
  /** í”„ë¡œí•„ ê³ ìœ  ID */
  id: string;
  /** í”„ë¡œí•„ ì´ë¦„ i18n í‚¤ */
  nameKey: string;
  /** í”„ë¡œí•„ ì„¤ëª… i18n í‚¤ */
  descriptionKey: string;
  /** í”„ë¡œí•„ ì•„ì´ì½˜ (ì´ëª¨ì§€) */
  icon: string;
  /** í”„ë¡œí•„ í…Œë§ˆ ìƒ‰ìƒ (CSS ë³€ìˆ˜ëª… ë˜ëŠ” hex) */
  themeColor: string;
}

/**
 * í”„ë¡œí•„ ì´ˆê¸° ìƒíƒœ.
 * SaveGameìœ¼ë¡œ ë³€í™˜ ê°€ëŠ¥í•œ êµ¬ì¡°ì…ë‹ˆë‹¤.
 */
export interface DemoProfileInitialState {
  /** ì´ˆê¸° ì¬í™” */
  economy: {
    signal: number;
    memory_shard: number;
  };
  /** ì´ˆê¸° ì¸ë²¤í† ë¦¬ ì•„ì´í…œ ì •ì˜ (IDì™€ i18n í‚¤) */
  inventoryDefs: Array<{
    id: string;
    nameKey: string;
    icon: string;
    quantity: number;
  }>;
  /** ì´ˆê¸° í€˜ìŠ¤íŠ¸ ì •ì˜ */
  questDefs: Array<{
    id: string;
    labelKey: string;
    is_completed: boolean;
  }>;
  /** ì´ˆê¸° ê·œì¹™ ì •ì˜ */
  ruleDefs: Array<{
    id: string;
    labelKey: string;
    descriptionKey?: string;
  }>;
  /** ì´ˆê¸° Scene Objects ì •ì˜ */
  sceneObjectDefs: Array<{
    id: string;
    labelKey: string;
    hintKey: string;
    box_2d: {
      ymin: number;
      xmin: number;
      ymax: number;
      xmax: number;
    };
  }>;
  /** í™˜ì˜ ë©”ì‹œì§€ i18n í‚¤ */
  welcomeMessageKey: string;
}

/**
 * ë°ëª¨ í”„ë¡œí•„ ì „ì²´ ì •ì˜.
 */
export interface DemoProfile extends DemoProfileDef {
  initialState: DemoProfileInitialState;
}

// =============================================================================
// ë°ëª¨ í”„ë¡œí•„ ì •ì˜ (3ì¢…)
// =============================================================================

/**
 * Narrator í”„ë¡œí•„: ë‚´ëŸ¬í‹°ë¸Œ/ìŠ¤í† ë¦¬ ì¤‘ì‹¬ ì²´í—˜.
 * í’ë¶€í•œ ì¬í™”ë¡œ ë‹¤ì–‘í•œ ì„ íƒì§€ë¥¼ íƒìƒ‰í•  ìˆ˜ ìˆìŠµë‹ˆë‹¤.
 */
export const PROFILE_NARRATOR: DemoProfile = {
  id: 'narrator',
  nameKey: 'profile.narrator.name',
  descriptionKey: 'profile.narrator.description',
  icon: 'ğŸ“–',
  themeColor: 'var(--accent-color)',
  initialState: {
    economy: {
      signal: 200,
      memory_shard: 10,
    },
    inventoryDefs: [
      {
        id: 'ancient-tome',
        nameKey: 'profile.narrator.items.ancient_tome',
        icon: 'ğŸ“•',
        quantity: 1,
      },
      { id: 'quill-pen', nameKey: 'profile.narrator.items.quill_pen', icon: 'ğŸ–‹ï¸', quantity: 1 },
      {
        id: 'memory-fragment',
        nameKey: 'profile.narrator.items.memory_fragment',
        icon: 'ğŸ’ ',
        quantity: 3,
      },
    ],
    questDefs: [
      {
        id: 'quest-discover-origin',
        labelKey: 'profile.narrator.quest.discover_origin',
        is_completed: false,
      },
      {
        id: 'quest-collect-memories',
        labelKey: 'profile.narrator.quest.collect_memories',
        is_completed: false,
      },
    ],
    ruleDefs: [
      {
        id: 'rule-time-flows',
        labelKey: 'profile.narrator.rule.time_flows',
        descriptionKey: 'profile.narrator.rule.time_flows_desc',
      },
      {
        id: 'rule-memories-persist',
        labelKey: 'profile.narrator.rule.memories_persist',
        descriptionKey: 'profile.narrator.rule.memories_persist_desc',
      },
    ],
    sceneObjectDefs: [
      {
        id: 'mysterious-bookshelf',
        labelKey: 'profile.narrator.scene.bookshelf',
        hintKey: 'profile.narrator.scene.bookshelf_hint',
        box_2d: { ymin: 200, xmin: 100, ymax: 700, xmax: 400 },
      },
      {
        id: 'glowing-portal',
        labelKey: 'profile.narrator.scene.portal',
        hintKey: 'profile.narrator.scene.portal_hint',
        box_2d: { ymin: 300, xmin: 600, ymax: 800, xmax: 900 },
      },
    ],
    welcomeMessageKey: 'profile.narrator.welcome',
  },
};

/**
 * Explorer í”„ë¡œí•„: íƒìƒ‰/ë°œê²¬ ì¤‘ì‹¬ ì²´í—˜.
 * ì ë‹¹í•œ ì¬í™”ì™€ íƒìƒ‰ ë„êµ¬ë¡œ ìƒˆë¡œìš´ ì˜ì—­ì„ ë°œê²¬í•©ë‹ˆë‹¤.
 */
export const PROFILE_EXPLORER: DemoProfile = {
  id: 'explorer',
  nameKey: 'profile.explorer.name',
  descriptionKey: 'profile.explorer.description',
  icon: 'ğŸ§­',
  themeColor: 'var(--text-color)',
  initialState: {
    economy: {
      signal: 150,
      memory_shard: 5,
    },
    inventoryDefs: [
      { id: 'compass', nameKey: 'profile.explorer.items.compass', icon: 'ğŸ§­', quantity: 1 },
      { id: 'rope', nameKey: 'profile.explorer.items.rope', icon: 'ğŸª¢', quantity: 2 },
      { id: 'lantern', nameKey: 'profile.explorer.items.lantern', icon: 'ğŸ®', quantity: 1 },
      {
        id: 'map-fragment',
        nameKey: 'profile.explorer.items.map_fragment',
        icon: 'ğŸ—ºï¸',
        quantity: 1,
      },
    ],
    questDefs: [
      { id: 'quest-find-exit', labelKey: 'profile.explorer.quest.find_exit', is_completed: false },
      {
        id: 'quest-explore-areas',
        labelKey: 'profile.explorer.quest.explore_areas',
        is_completed: false,
      },
      {
        id: 'quest-gather-supplies',
        labelKey: 'profile.explorer.quest.gather_supplies',
        is_completed: true,
      },
    ],
    ruleDefs: [
      {
        id: 'rule-gravity',
        labelKey: 'profile.explorer.rule.gravity',
        descriptionKey: 'profile.explorer.rule.gravity_desc',
      },
      {
        id: 'rule-darkness',
        labelKey: 'profile.explorer.rule.darkness',
        descriptionKey: 'profile.explorer.rule.darkness_desc',
      },
    ],
    sceneObjectDefs: [
      {
        id: 'ancient-door',
        labelKey: 'profile.explorer.scene.door',
        hintKey: 'profile.explorer.scene.door_hint',
        box_2d: { ymin: 150, xmin: 400, ymax: 850, xmax: 600 },
      },
      {
        id: 'strange-mechanism',
        labelKey: 'profile.explorer.scene.mechanism',
        hintKey: 'profile.explorer.scene.mechanism_hint',
        box_2d: { ymin: 500, xmin: 100, ymax: 700, xmax: 300 },
      },
      {
        id: 'hidden-passage',
        labelKey: 'profile.explorer.scene.passage',
        hintKey: 'profile.explorer.scene.passage_hint',
        box_2d: { ymin: 600, xmin: 700, ymax: 800, xmax: 950 },
      },
    ],
    welcomeMessageKey: 'profile.explorer.welcome',
  },
};

/**
 * Tech Enthusiast í”„ë¡œí•„: ì‹œìŠ¤í…œ/ë©”ì»¤ë‹‰ ì¤‘ì‹¬ ì²´í—˜.
 * ì œí•œëœ ì¬í™”ë¡œ íš¨ìœ¨ì ì¸ ì „ëµì„ ì„¸ì›Œì•¼ í•©ë‹ˆë‹¤.
 */
export const PROFILE_TECH: DemoProfile = {
  id: 'tech',
  nameKey: 'profile.tech.name',
  descriptionKey: 'profile.tech.description',
  icon: 'âš™ï¸',
  themeColor: 'var(--warning-color)',
  initialState: {
    economy: {
      signal: 80,
      memory_shard: 15,
    },
    inventoryDefs: [
      { id: 'data-core', nameKey: 'profile.tech.items.data_core', icon: 'ğŸ’¿', quantity: 1 },
      { id: 'circuit-board', nameKey: 'profile.tech.items.circuit_board', icon: 'ğŸ”Œ', quantity: 2 },
      { id: 'energy-cell', nameKey: 'profile.tech.items.energy_cell', icon: 'ğŸ”‹', quantity: 3 },
      { id: 'scanner-device', nameKey: 'profile.tech.items.scanner', icon: 'ğŸ“¡', quantity: 1 },
    ],
    questDefs: [
      {
        id: 'quest-analyze-system',
        labelKey: 'profile.tech.quest.analyze_system',
        is_completed: false,
      },
      {
        id: 'quest-optimize-resources',
        labelKey: 'profile.tech.quest.optimize_resources',
        is_completed: false,
      },
    ],
    ruleDefs: [
      {
        id: 'rule-energy-conservation',
        labelKey: 'profile.tech.rule.energy_conservation',
        descriptionKey: 'profile.tech.rule.energy_conservation_desc',
      },
      {
        id: 'rule-data-integrity',
        labelKey: 'profile.tech.rule.data_integrity',
        descriptionKey: 'profile.tech.rule.data_integrity_desc',
      },
      {
        id: 'rule-system-limits',
        labelKey: 'profile.tech.rule.system_limits',
        descriptionKey: 'profile.tech.rule.system_limits_desc',
      },
    ],
    sceneObjectDefs: [
      {
        id: 'main-terminal',
        labelKey: 'profile.tech.scene.terminal',
        hintKey: 'profile.tech.scene.terminal_hint',
        box_2d: { ymin: 200, xmin: 300, ymax: 600, xmax: 700 },
      },
      {
        id: 'power-conduit',
        labelKey: 'profile.tech.scene.conduit',
        hintKey: 'profile.tech.scene.conduit_hint',
        box_2d: { ymin: 100, xmin: 50, ymax: 400, xmax: 200 },
      },
    ],
    welcomeMessageKey: 'profile.tech.welcome',
  },
};

/**
 * ëª¨ë“  ë°ëª¨ í”„ë¡œí•„ ëª©ë¡.
 */
export const DEMO_PROFILES: readonly DemoProfile[] = [
  PROFILE_NARRATOR,
  PROFILE_EXPLORER,
  PROFILE_TECH,
] as const;

/**
 * í”„ë¡œí•„ IDë¡œ í”„ë¡œí•„ì„ ì°¾ìŠµë‹ˆë‹¤.
 */
export function findProfileById(profileId: string): DemoProfile | undefined {
  return DEMO_PROFILES.find((p) => p.id === profileId);
}

// =============================================================================
// í”„ë¡œí•„ â†’ SaveGameInput ë³€í™˜ (RU-004-Q1: SSOT ë‹¨ì¼í™”)
// =============================================================================

/**
 * ë°ëª¨ í”„ë¡œí•„ì„ SaveGameInputìœ¼ë¡œ ë³€í™˜í•©ë‹ˆë‹¤.
 *
 * RU-004-Q1: SaveGame ìƒì„±ì€ createSaveGame(SSOT)ë§Œ ìˆ˜í–‰í•˜ë„ë¡ ë¶„ë¦¬.
 * ì´ í•¨ìˆ˜ëŠ” "ì…ë ¥ ë³€í™˜(input adapter)" ì—­í• ë§Œ ë‹´ë‹¹í•©ë‹ˆë‹¤.
 *
 * @param profile - ë°ëª¨ í”„ë¡œí•„
 * @param language - ì–¸ì–´ ì„¤ì •
 * @param t - i18n ë²ˆì—­ í•¨ìˆ˜
 * @returns SaveGameInput ê°ì²´ (createSaveGameì— ì „ë‹¬ ê°€ëŠ¥)
 */
export function profileToSaveGameInput(
  profile: DemoProfile,
  language: SupportedLanguage,
  t: (key: string) => string,
): SaveGameInput {
  const now = Date.now();

  return {
    language,
    profileId: profile.id,
    // RU-004-Q5: seed ìƒì„± ì •ì±… SSOT (constants.ts)
    seed: generateDemoSeed(profile.id),
    economy: {
      signal: profile.initialState.economy.signal,
      memory_shard: profile.initialState.economy.memory_shard,
    },
    economyLedger: [],
    turnCount: 0,
    narrativeHistory: [
      {
        turn: 0,
        text: t(profile.initialState.welcomeMessageKey),
      },
    ],
    inventory: profile.initialState.inventoryDefs.map((item) => ({
      id: item.id,
      name: t(item.nameKey),
      icon: item.icon,
      quantity: item.quantity,
    })),
    quests: profile.initialState.questDefs.map((quest) => ({
      id: quest.id,
      label: t(quest.labelKey),
      is_completed: quest.is_completed,
    })),
    activeRules: profile.initialState.ruleDefs.map((rule) => ({
      id: rule.id,
      label: t(rule.labelKey),
      description: rule.descriptionKey ? t(rule.descriptionKey) : null,
    })),
    mutationTimeline: profile.initialState.ruleDefs.map((rule, index) => ({
      turn: 0,
      ruleId: rule.id,
      type: 'added' as const,
      label: t(rule.labelKey),
      description: rule.descriptionKey ? t(rule.descriptionKey) : undefined,
      timestamp: now - index * 1000,
    })),
    sceneObjects: profile.initialState.sceneObjectDefs.map((obj) => ({
      id: obj.id,
      label: t(obj.labelKey),
      box_2d: obj.box_2d,
      interaction_hint: t(obj.hintKey),
    })),
  };
}

/**
 * ë°ëª¨ í”„ë¡œí•„ì„ SaveGame í˜•íƒœë¡œ ë³€í™˜í•©ë‹ˆë‹¤.
 *
 * RU-004-Q1: createSaveGame(SSOT)ë¥¼ í˜¸ì¶œí•˜ëŠ” ì–‡ì€ wrapperì…ë‹ˆë‹¤.
 * ê¸°ì¡´ í˜¸ì¶œìì™€ì˜ í˜¸í™˜ì„±ì„ ìœ ì§€í•©ë‹ˆë‹¤.
 *
 * @param profile - ë°ëª¨ í”„ë¡œí•„
 * @param language - ì–¸ì–´ ì„¤ì •
 * @param t - i18n ë²ˆì—­ í•¨ìˆ˜
 * @returns SaveGame ê°ì²´
 */
export function createSaveGameFromProfile(
  profile: DemoProfile,
  language: SupportedLanguage,
  t: (key: string) => string,
): SaveGame {
  return createSaveGame(profileToSaveGameInput(profile, language, t));
}

/**
 * í”„ë¡œí•„ ëª©ë¡ ì •ë³´ë§Œ ê°€ì ¸ì˜µë‹ˆë‹¤ (ì„ íƒ UIìš©).
 */
export function getProfileSummaries(): Array<DemoProfileDef> {
  return DEMO_PROFILES.map((p) => ({
    id: p.id,
    nameKey: p.nameKey,
    descriptionKey: p.descriptionKey,
    icon: p.icon,
    themeColor: p.themeColor,
  }));
}
</file>

<file path="frontend/src/demo/useDemoInitializer.ts">
import { useEffect } from 'react';
import { useTranslation } from 'react-i18next';
import { useInventoryStore } from '../stores/inventoryStore';
import { useWorldStore } from '../stores/worldStore';
import type { Quest, WorldRule } from '../schemas/turn';
import type { MutationEvent } from '../stores/worldStore';
import {
  DEMO_INVENTORY_ITEMS,
  DEMO_SCENE_OBJECTS,
  DEMO_QUESTS,
  DEMO_RULES,
  getDemoItemNameKey,
  isDemoEnvironment,
} from '../demo/demoFixtures';

/**
 * ë°ëª¨ í™˜ê²½ì—ì„œ ì´ˆê¸° mock ë°ì´í„°ë¥¼ ë¡œë“œí•˜ëŠ” í›… (RU-003-Q5, U-013).
 */
export function useDemoInitializer() {
  const { t } = useTranslation();
  const { items: inventoryItems, addItems: addInventoryItems } = useInventoryStore();
  const worldStore = useWorldStore();
  const {
    sceneObjects,
    setSceneObjects,
    narrativeEntries,
    initialize: initializeWorld,
    quests,
    activeRules,
  } = worldStore;

  useEffect(() => {
    // ì›”ë“œ ì´ˆê¸°í™” (í™˜ì˜ ë©”ì‹œì§€)
    if (narrativeEntries.length === 0) {
      initializeWorld(t('narrative.welcome'));
    }

    // DEV: ë°ëª¨ìš© mock ë°ì´í„° ì´ˆê¸°í™” (RU-003-Q5: DEV ê°€ë“œ + i18n í‚¤ ê¸°ë°˜)
    if (isDemoEnvironment()) {
      // ë°ëª¨ìš© mock ì¸ë²¤í† ë¦¬ ì´ˆê¸°í™” (U-011)
      if (inventoryItems.length === 0) {
        const demoInventory = DEMO_INVENTORY_ITEMS.map((item) => ({
          id: item.id,
          name: t(getDemoItemNameKey(item.id)),
          icon: item.icon,
          quantity: item.quantity,
        }));
        addInventoryItems(demoInventory);
      }

      // ë°ëª¨ìš© mock Scene Objects ì´ˆê¸°í™” (U-010)
      if (sceneObjects.length === 0) {
        const demoSceneObjects = DEMO_SCENE_OBJECTS.map((obj) => ({
          id: obj.id,
          label: t(obj.labelKey),
          box_2d: obj.box_2d,
          interaction_hint: t(obj.hintKey),
        }));
        setSceneObjects(demoSceneObjects);
      }

      // ë°ëª¨ìš© mock í€˜ìŠ¤íŠ¸ ì´ˆê¸°í™” (U-013)
      if (quests.length === 0) {
        const demoQuests: Quest[] = DEMO_QUESTS.map((q) => ({
          id: q.id,
          label: t(q.labelKey),
          is_completed: q.is_completed,
        }));
        useWorldStore.setState({ quests: demoQuests });
      }

      // ë°ëª¨ìš© mock ê·œì¹™ ì´ˆê¸°í™” (U-013)
      if (activeRules.length === 0) {
        const demoRules: WorldRule[] = DEMO_RULES.map((r) => ({
          id: r.id,
          label: t(r.labelKey),
          description: r.descriptionKey ? t(r.descriptionKey) : null,
        }));
        // ë°ëª¨ ë®¤í…Œì´ì…˜ íƒ€ì„ë¼ì¸ ìƒì„± (ê·œì¹™ ì¶”ê°€ ì´ë²¤íŠ¸)
        const now = Date.now();
        const demoMutations: MutationEvent[] = DEMO_RULES.map((r, index) => ({
          turn: 0,
          ruleId: r.id,
          type: 'added' as const,
          label: t(r.labelKey),
          description: r.descriptionKey ? t(r.descriptionKey) : undefined,
          timestamp: now - index * 1000, // ì‹œê°„ ìˆœì„œ êµ¬ë¶„ìš©
        }));
        useWorldStore.setState({
          activeRules: demoRules,
          mutationTimeline: demoMutations,
        });
      }
    }
    // eslint-disable-next-line react-hooks/exhaustive-deps
  }, [t]);
}
</file>

<file path="frontend/src/save/sessionLifecycle.ts">
/**
 * Unknown World - ì„¸ì…˜ ë¼ì´í”„ì‚¬ì´í´ ê´€ë¦¬ ëª¨ë“ˆ (RU-004-Q4).
 *
 * ì„¸ì…˜ ì´ˆê¸°í™”/ë³µì›/ë¦¬ì…‹/ë³€ê²½ì„ SSOTë¡œ ê´€ë¦¬í•©ë‹ˆë‹¤.
 * App.tsxì˜ ì„¸ì…˜ ê´€ë ¨ ë¡œì§ì„ ì´ ëª¨ë“ˆë¡œ ì´ë™í•˜ì—¬ ì±…ì„ ê²½ê³„ë¥¼ ëª…í™•íˆ í•©ë‹ˆë‹¤.
 *
 * ì„¤ê³„ ì›ì¹™:
 *   - RULE-005: Economy ì¸ë°”ë¦¬ì–¸íŠ¸ (ì”ì•¡ ìŒìˆ˜ ê¸ˆì§€)
 *   - RULE-006: ko/en i18n ì •ì±… ì¤€ìˆ˜ (ì–¸ì–´ ì ìš© í›„ UI ë Œë”ë§)
 *   - RU-004-S1: ì–¸ì–´ async ì ìš© ì™„ë£Œ í›„ store ì£¼ì…
 *   - RU-004-S2: profileId SSOT + ìœ íš¨ SaveGameë§Œ Continue
 *
 * @module save/sessionLifecycle
 */

import {
  loadSaveGame,
  saveSaveGame,
  clearSaveGame,
  getValidSaveGameOrNull,
  createSaveGame,
  loadCurrentProfileId,
  saveCurrentProfileId,
  clearCurrentProfileId,
} from './saveGame';
import { findProfileById, createSaveGameFromProfile, type DemoProfile } from '../data/demoProfiles';
import {
  getResolvedLanguage,
  changeLanguage,
  type SupportedLanguage,
  DEFAULT_LANGUAGE,
} from '../i18n';
import { useWorldStore } from '../stores/worldStore';
import { useInventoryStore } from '../stores/inventoryStore';
import { useEconomyStore } from '../stores/economyStore';
import { useActionDeckStore } from '../stores/actionDeckStore';
import { useAgentStore } from '../stores/agentStore';

// =============================================================================
// íƒ€ì… ì •ì˜
// =============================================================================

/**
 * ë¶€íŒ… ê²°ê³¼ íƒ€ì….
 * ì•± ì‹œì‘ ì‹œ ì–´ë–¤ phaseë¡œ ì‹œì‘í• ì§€ ê²°ì •í•©ë‹ˆë‹¤.
 */
export type SessionBootstrap =
  | { phase: 'profile_select'; savedGameAvailable: boolean }
  | { phase: 'playing'; profileId: string | null };

/**
 * ì„¸ì…˜ ì‹œì‘ ê²°ê³¼ íƒ€ì….
 */
export interface SessionStartResult {
  success: true;
  profileId: string;
}

/**
 * ì„¸ì…˜ ë³µì› ê²°ê³¼ íƒ€ì….
 */
export interface SessionContinueResult {
  success: true;
  profileId: string;
}

/**
 * ì„¸ì…˜ ë¦¬ì…‹ ê²°ê³¼ íƒ€ì….
 */
export interface SessionResetResult {
  success: boolean;
  profileId: string | null;
}

// =============================================================================
// ë‚´ë¶€ í—¬í¼: ëª¨ë“  ì„¸ì…˜ ê´€ë ¨ storeë¥¼ ì´ˆê¸°í™”
// =============================================================================

/**
 * ëª¨ë“  ì„¸ì…˜ ê´€ë ¨ storeë¥¼ ì´ˆê¸°í™”í•©ë‹ˆë‹¤.
 *
 * RU-004-Q4 Step 2: store reset/hydrate ë²”ìœ„ í‘œì¤€í™”
 * - worldStore, inventoryStore, economyStore, actionDeckStore, agentStore
 *
 * ì„¸ì…˜ ê²½ê³„ì—ì„œ í•­ìƒ ì´ í•¨ìˆ˜ë¥¼ í˜¸ì¶œí•˜ì—¬ ì´ì „ ì„¸ì…˜ ì”ì¬ë¥¼ ì™„ì „íˆ ì œê±°í•©ë‹ˆë‹¤.
 */
function resetAllSessionStores(): void {
  useWorldStore.getState().reset();
  useInventoryStore.getState().reset();
  useEconomyStore.getState().reset();
  useActionDeckStore.getState().reset();
  useAgentStore.getState().reset();
}

// =============================================================================
// ì„¸ì…˜ ë¼ì´í”„ì‚¬ì´í´ API
// =============================================================================

/**
 * ë¶€íŒ… ì‹œ ì„¸ì…˜ ìƒíƒœë¥¼ í™•ì¸í•˜ê³  ì‹œì‘ phaseë¥¼ ê²°ì •í•©ë‹ˆë‹¤.
 *
 * RU-004-S2: hasSaveGame() ëŒ€ì‹  getValidSaveGameOrNull()ë¡œ "ìœ íš¨í•œ ì„¸ì´ë¸Œë§Œ" íŒë‹¨
 *
 * @returns SessionBootstrap - ì‹œì‘ phaseì™€ ê´€ë ¨ ì •ë³´
 */
export function bootstrapSession(): SessionBootstrap {
  const validSaveGame = getValidSaveGameOrNull();

  if (validSaveGame) {
    // ìœ íš¨í•œ ì„¸ì´ë¸Œê°€ ìˆìœ¼ë©´ playing ìƒíƒœë¡œ ì‹œì‘
    return {
      phase: 'playing',
      profileId: validSaveGame.profileId,
    };
  }

  // ìœ íš¨í•œ ì„¸ì´ë¸Œê°€ ì—†ìœ¼ë©´ profile_selectë¡œ ì‹œì‘
  // ë‹¨, localStorageì— ê¹¨ì§„ ì„¸ì´ë¸Œê°€ ìˆì„ ìˆ˜ ìˆìœ¼ë¯€ë¡œ savedGameAvailableì€ false
  return {
    phase: 'profile_select',
    savedGameAvailable: false,
  };
}

/**
 * ì €ì¥ëœ ê²Œì„ì´ ìˆëŠ”ì§€ í™•ì¸í•©ë‹ˆë‹¤ (Continue ë²„íŠ¼ í‘œì‹œìš©).
 *
 * RU-004-S2: ìœ íš¨í•œ ì„¸ì´ë¸Œë§Œ "ìˆìŒ"ìœ¼ë¡œ íŒë‹¨
 *
 * @returns ìœ íš¨í•œ ì„¸ì´ë¸Œê°€ ìˆìœ¼ë©´ true
 */
export function hasValidSaveGame(): boolean {
  return getValidSaveGameOrNull() !== null;
}

/**
 * í”„ë¡œí•„ì„ ì„ íƒí•˜ê³  ìƒˆ ì„¸ì…˜ì„ ì‹œì‘í•©ë‹ˆë‹¤.
 *
 * RU-004-Q4 Step 1: startSessionFromProfile
 * U-044: ì„¸ì…˜ ì–¸ì–´ë¥¼ ëª…ì‹œì ìœ¼ë¡œ ë°›ì•„ SSOT ìœ ì§€
 * - ëª¨ë“  storeë¥¼ ì´ˆê¸°í™”
 * - í”„ë¡œí•„ ê¸°ë°˜ SaveGame ìƒì„±
 * - storeì— ì´ˆê¸° ìƒíƒœ ì£¼ì…
 * - localStorageì— ì €ì¥
 *
 * @param args.profile - ì„ íƒí•œ ë°ëª¨ í”„ë¡œí•„
 * @param args.t - i18n ë²ˆì—­ í•¨ìˆ˜
 * @param args.language - ì„¸ì…˜ ì–¸ì–´ (U-044: ëª…ì‹œì  ì „ë‹¬ë¡œ SSOT ìœ ì§€)
 * @returns ì„¸ì…˜ ì‹œì‘ ê²°ê³¼
 */
export function startSessionFromProfile(args: {
  profile: DemoProfile;
  t: (key: string) => string;
  language?: SupportedLanguage;
}): SessionStartResult {
  const { profile, t, language: explicitLanguage } = args;

  // U-044: ëª…ì‹œì  ì–¸ì–´ê°€ ìˆìœ¼ë©´ ì‚¬ìš©, ì—†ìœ¼ë©´ i18n í˜„ì¬ ê°’ ì‚¬ìš©
  const language = explicitLanguage ?? getResolvedLanguage();

  // í”„ë¡œí•„ì—ì„œ SaveGame ìƒì„±
  const saveGame = createSaveGameFromProfile(profile, language, t);

  // ëª¨ë“  ì„¸ì…˜ store ì´ˆê¸°í™” (ì´ì „ ì„¸ì…˜ ì”ì¬ ì œê±°)
  resetAllSessionStores();

  // Storeì— ì´ˆê¸° ìƒíƒœ ì£¼ì…
  useWorldStore.setState({
    economy: {
      signal: saveGame.economy.signal,
      memory_shard: saveGame.economy.memory_shard,
    },
    turnCount: 0,
    narrativeEntries: saveGame.narrativeHistory,
    quests: saveGame.quests,
    activeRules: saveGame.activeRules,
    mutationTimeline: saveGame.mutationTimeline,
    sceneObjects: saveGame.sceneObjects,
  });

  useInventoryStore.getState().setItems(saveGame.inventory);

  // í”„ë¡œí•„ ID ì €ì¥ (localStorage)
  saveCurrentProfileId(profile.id);

  // SaveGame ì €ì¥ (localStorage)
  saveSaveGame(saveGame);

  return {
    success: true,
    profileId: profile.id,
  };
}

/**
 * ì €ì¥ëœ ê²Œì„ì„ ë³µì›í•˜ì—¬ ì„¸ì…˜ì„ ê³„ì†í•©ë‹ˆë‹¤.
 *
 * RU-004-Q4 Step 1: continueSession
 * RU-004-S1: asyncë¡œ ì–¸ì–´ ì ìš© ì™„ë£Œ í›„ store ì£¼ì…
 * RU-004-S2: profileId SSOT + ë¡œë“œ ì‹¤íŒ¨ ì‹œ null ë°˜í™˜
 *
 * @returns ì„¸ì…˜ ë³µì› ê²°ê³¼ ë˜ëŠ” null (ì‹¤íŒ¨ ì‹œ)
 */
export async function continueSession(): Promise<SessionContinueResult | null> {
  const saveGame = loadSaveGame();
  if (!saveGame) {
    // ë¡œë“œ ì‹¤íŒ¨ ì‹œ í´ë¦°ì—…
    clearSaveGame();
    clearCurrentProfileId();
    console.warn('[SessionLifecycle] SaveGame ë¡œë“œ ì‹¤íŒ¨, ìƒˆë¡œ ì‹œì‘ í•„ìš”');
    return null;
  }

  // RU-004-S1: ì–¸ì–´ ì„¤ì • ë¹„ë™ê¸° ì ìš© ì™„ë£Œ í›„ ì§„í–‰ (RULE-006)
  await changeLanguage(saveGame.language as SupportedLanguage);

  // ëª¨ë“  ì„¸ì…˜ store ì´ˆê¸°í™” (ì´ì „ ì„¸ì…˜ ì”ì¬ ì œê±°)
  resetAllSessionStores();

  // Storeì— ì €ì¥ëœ ìƒíƒœ ë³µì›
  useWorldStore.setState({
    economy: {
      signal: saveGame.economy.signal,
      memory_shard: saveGame.economy.memory_shard,
    },
    turnCount: saveGame.turnCount,
    narrativeEntries: saveGame.narrativeHistory,
    quests: saveGame.quests,
    activeRules: saveGame.activeRules,
    mutationTimeline: saveGame.mutationTimeline,
    sceneObjects: saveGame.sceneObjects,
  });

  // ì¸ë²¤í† ë¦¬ ë³µì›
  useInventoryStore.getState().setItems(saveGame.inventory);

  // Economy ë³µì› (RU-004-S1: hydrateLedgerë¡œ ìˆœì„œ/timestamp/lastCost/isBalanceLow ì •í•©ì„± ë³´ì¥)
  useEconomyStore.getState().hydrateLedger(saveGame.economyLedger, saveGame.economy);

  // RU-004-S2: profileId SSOT - SaveGame.profileIdë¥¼ ê¶Œìœ„ìë¡œ ì‚¬ìš©
  const profileId = saveGame.profileId;
  if (profileId) {
    saveCurrentProfileId(profileId); // localStorage ë™ê¸°í™” (ë“œë¦¬í”„íŠ¸ ë°©ì§€)
  }

  return {
    success: true,
    profileId: profileId ?? loadCurrentProfileId() ?? '',
  };
}

/**
 * í˜„ì¬ í”„ë¡œí•„ì˜ ì´ˆê¸° ìƒíƒœë¡œ ë¦¬ì…‹í•©ë‹ˆë‹¤.
 *
 * RU-004-Q4 Step 1: resetToCurrentProfile
 *
 * @param args.t - i18n ë²ˆì—­ í•¨ìˆ˜
 * @param args.currentProfileId - í˜„ì¬ í”„ë¡œí•„ ID
 * @returns ë¦¬ì…‹ ì„±ê³µ ì—¬ë¶€
 */
export function resetToCurrentProfile(args: {
  t: (key: string) => string;
  currentProfileId: string | null;
}): SessionResetResult {
  const { t, currentProfileId } = args;

  if (!currentProfileId) {
    return { success: false, profileId: null };
  }

  const profile = findProfileById(currentProfileId);
  if (!profile) {
    return { success: false, profileId: null };
  }

  // ë™ì¼ í”„ë¡œí•„ë¡œ ìƒˆ ì„¸ì…˜ ì‹œì‘
  const result = startSessionFromProfile({ profile, t });

  return {
    success: result.success,
    profileId: result.profileId,
  };
}

/**
 * ì„¸ì…˜ì„ ì¢…ë£Œí•˜ê³  í”„ë¡œí•„ ì„ íƒ í™”ë©´ìœ¼ë¡œ ëŒì•„ê°‘ë‹ˆë‹¤.
 *
 * RU-004-Q4 Step 1: clearSessionAndReturnToSelect
 * - ëª¨ë“  ì„¸ì…˜ ë°ì´í„° í´ë¦°ì—… (localStorage + store)
 */
export function clearSessionAndReturnToSelect(): void {
  // localStorage í´ë¦°ì—…
  clearSaveGame();
  clearCurrentProfileId();

  // ëª¨ë“  ì„¸ì…˜ store ì´ˆê¸°í™”
  resetAllSessionStores();
}

/**
 * í˜„ì¬ ìƒíƒœë¥¼ ì €ì¥í•©ë‹ˆë‹¤.
 *
 * í„´ ì™„ë£Œ ì‹œ ìë™ ì €ì¥ì— ì‚¬ìš©ë©ë‹ˆë‹¤.
 *
 * RU-004-Q5: seedëŠ” ì„¸ì…˜ ì‹œì‘ ì‹œ ìƒì„±ë˜ê³ , ì´í›„ ë³€ê²½ë˜ì§€ ì•Šì•„ì•¼ í•©ë‹ˆë‹¤.
 * ê¸°ì¡´ SaveGameì—ì„œ seedë¥¼ ì½ì–´ì™€ì„œ ìœ ì§€í•©ë‹ˆë‹¤.
 *
 * @param profileId - í˜„ì¬ í”„ë¡œí•„ ID
 * @returns ì €ì¥ ì„±ê³µ ì—¬ë¶€
 */
export function saveCurrentSession(profileId: string | null): boolean {
  if (!profileId) return false;

  const worldState = useWorldStore.getState();
  const economyState = useEconomyStore.getState();
  const inventoryState = useInventoryStore.getState();

  // RU-004-Q5: ê¸°ì¡´ SaveGameì—ì„œ seedë¥¼ ê°€ì ¸ì™€ ìœ ì§€ (SSOT)
  const existingSaveGame = getValidSaveGameOrNull();
  const seed = existingSaveGame?.seed ?? null;

  const saveGame = createSaveGame({
    language: getResolvedLanguage(),
    profileId,
    seed, // RU-004-Q5: seed ìœ ì§€
    economy: worldState.economy,
    economyLedger: economyState.ledger,
    turnCount: worldState.turnCount,
    narrativeHistory: worldState.narrativeEntries,
    inventory: inventoryState.items,
    quests: worldState.quests,
    activeRules: worldState.activeRules,
    mutationTimeline: worldState.mutationTimeline,
    sceneObjects: worldState.sceneObjects,
  });

  return saveSaveGame(saveGame);
}

/**
 * ì´ˆê¸° profileIdë¥¼ ê²°ì •í•©ë‹ˆë‹¤.
 *
 * RU-004-S2: SaveGame.profileIdê°€ SSOT, CURRENT_PROFILE_KEYëŠ” í´ë°±
 *
 * @returns ì´ˆê¸° profileId ë˜ëŠ” null
 */
export function getInitialProfileId(): string | null {
  // ìœ íš¨í•œ SaveGameì´ ìˆìœ¼ë©´ ê·¸ profileIdë¥¼ ì‚¬ìš©
  const validSaveGame = getValidSaveGameOrNull();
  if (validSaveGame?.profileId) {
    return validSaveGame.profileId;
  }
  // í´ë°±: CURRENT_PROFILE_KEY (í˜¸í™˜ì„±)
  return loadCurrentProfileId();
}

// =============================================================================
// U-044: ì„¸ì…˜ ì–¸ì–´ SSOT API
// =============================================================================

/**
 * í˜„ì¬ ì„¸ì…˜ ì–¸ì–´ë¥¼ ë°˜í™˜í•©ë‹ˆë‹¤ (SSOT).
 *
 * U-044: SaveGame.languageë¥¼ ê¶Œìœ„ìë¡œ ì‚¬ìš©í•˜ì—¬ ì–¸ì–´ ë“œë¦¬í”„íŠ¸ë¥¼ ë°©ì§€í•©ë‹ˆë‹¤.
 * - ìœ íš¨í•œ SaveGameì´ ìˆìœ¼ë©´ í•´ë‹¹ ì–¸ì–´ ë°˜í™˜
 * - ì—†ìœ¼ë©´ i18nì˜ í˜„ì¬ ì–¸ì–´ ë°˜í™˜ (í´ë°±)
 *
 * TurnRunnerì—ì„œ TurnInput.languageë¥¼ ìƒì„±í•  ë•Œ ì´ í•¨ìˆ˜ë¥¼ ì‚¬ìš©í•©ë‹ˆë‹¤.
 *
 * @returns í˜„ì¬ ì„¸ì…˜ ì–¸ì–´ (ko-KR | en-US)
 */
export function getSessionLanguage(): SupportedLanguage {
  const validSaveGame = getValidSaveGameOrNull();
  if (validSaveGame?.language) {
    return validSaveGame.language as SupportedLanguage;
  }
  // í´ë°±: i18nì˜ í˜„ì¬ ì–¸ì–´
  return getResolvedLanguage();
}

/**
 * ì„¸ì…˜ ì–¸ì–´ë¥¼ ë³€ê²½í•©ë‹ˆë‹¤.
 *
 * U-044: ì–¸ì–´ ë³€ê²½ì€ ì„¸ì…˜ ê²½ê³„ì—ì„œë§Œ í—ˆìš© (í† ê¸€=ë¦¬ì…‹ ì •ì±…).
 * ì´ í•¨ìˆ˜ëŠ” i18n ì–¸ì–´ë¥¼ ë³€ê²½í•˜ê³ , ì´í›„ startSessionFromProfile ì‹œ
 * ìƒˆ SaveGameì— í•´ë‹¹ ì–¸ì–´ê°€ ì €ì¥ë©ë‹ˆë‹¤.
 *
 * ì£¼ì˜: playing ìƒíƒœì—ì„œëŠ” ì´ í•¨ìˆ˜ë¥¼ í˜¸ì¶œí•˜ì§€ ë§ˆì„¸ìš”.
 * ì–¸ì–´ ë³€ê²½ì€ profile_selectì—ì„œë§Œ í—ˆìš©ë©ë‹ˆë‹¤.
 *
 * @param language - ë³€ê²½í•  ì–¸ì–´
 */
export async function setSessionLanguage(language: SupportedLanguage): Promise<void> {
  await changeLanguage(language);
}

/**
 * ì´ˆê¸° ì„¸ì…˜ ì–¸ì–´ë¥¼ ê²°ì •í•©ë‹ˆë‹¤.
 *
 * U-044: ì•± ë¶€íŒ… ì‹œ ì‚¬ìš©í•©ë‹ˆë‹¤.
 * - ìœ íš¨í•œ SaveGameì´ ìˆìœ¼ë©´ í•´ë‹¹ ì–¸ì–´
 * - ì—†ìœ¼ë©´ DEFAULT_LANGUAGE
 *
 * @returns ì´ˆê¸° ì„¸ì…˜ ì–¸ì–´
 */
export function getInitialSessionLanguage(): SupportedLanguage {
  const validSaveGame = getValidSaveGameOrNull();
  if (validSaveGame?.language) {
    return validSaveGame.language as SupportedLanguage;
  }
  return DEFAULT_LANGUAGE;
}
</file>

<file path="frontend/src/stores/agentStore.ts">
/**
 * Unknown World - Agent Console ìƒíƒœ ê´€ë¦¬ (Zustand).
 *
 * ìŠ¤íŠ¸ë¦¬ë° ì¤‘ ìˆ˜ì‹ ë˜ëŠ” ë‹¨ê³„/ë°°ì§€/ë‚´ëŸ¬í‹°ë¸Œ/ë³µêµ¬ ì •ë³´ë¥¼ ì €ì¥í•˜ê³ ,
 * AgentConsole ì»´í¬ë„ŒíŠ¸ì—ì„œ êµ¬ë…í•  ìˆ˜ ìˆë„ë¡ í•©ë‹ˆë‹¤.
 *
 * ì„¤ê³„ ì›ì¹™:
 *   - RULE-008: ë‹¨ê³„/ë°°ì§€ ê°€ì‹œí™” (í”„ë¡¬í”„íŠ¸/ë‚´ë¶€ ì¶”ë¡  ë…¸ì¶œ ê¸ˆì§€)
 *   - RULE-003/004: ê²€ì¦ í›„ ìƒíƒœ ë°˜ì˜, ì‹¤íŒ¨ ì‹œ í´ë°±
 *
 * @module stores/agentStore
 */

import { create } from 'zustand';
import type { AgentPhase, ValidationBadge, TurnOutput } from '../schemas/turn';
import type {
  StageEvent,
  BadgesEvent,
  NarrativeDeltaEvent,
  FinalEvent,
  ErrorEvent,
} from '../types/turn_stream';
import { StageStatus } from '../types/turn_stream';

// =============================================================================
// ìƒíƒœ íƒ€ì… ì •ì˜
// =============================================================================

/** ë‹¨ê³„ ìƒíƒœ */
export type PhaseStatus = 'pending' | 'in_progress' | 'completed' | 'failed';

/** ë‹¨ê³„ ì •ë³´ */
export interface PhaseInfo {
  name: AgentPhase;
  status: PhaseStatus;
}

/** ì—ëŸ¬ ì •ë³´ */
export interface AgentError {
  message: string;
  code?: string;
}

/** Agent Console ìƒíƒœ */
export interface AgentState {
  /** í˜„ì¬ ìŠ¤íŠ¸ë¦¬ë° ì¤‘ì¸ì§€ */
  isStreaming: boolean;
  /** í˜„ì¬ ë‹¨ê³„ */
  currentPhase: AgentPhase | null;
  /** ë‹¨ê³„ë³„ ìƒíƒœ */
  phases: PhaseInfo[];
  /** ê²€ì¦ ë°°ì§€ ëª©ë¡ */
  badges: ValidationBadge[];
  /** ëˆ„ì  ë‚´ëŸ¬í‹°ë¸Œ í…ìŠ¤íŠ¸ (íƒ€ì íš¨ê³¼ìš©) */
  narrativeBuffer: string;
  /** ìë™ ë³µêµ¬ íšŸìˆ˜ */
  repairCount: number;
  /** ìµœì¢… TurnOutput */
  finalOutput: TurnOutput | null;
  /** ì—ëŸ¬ ì •ë³´ */
  error: AgentError | null;
}

/** Agent Console ì•¡ì…˜ */
export interface AgentActions {
  /** ìŠ¤íŠ¸ë¦¼ ì‹œì‘ */
  startStream: () => void;
  /** ë‹¨ê³„ ì´ë²¤íŠ¸ ì²˜ë¦¬ */
  handleStage: (event: StageEvent) => void;
  /** ë°°ì§€ ì´ë²¤íŠ¸ ì²˜ë¦¬ */
  handleBadges: (event: BadgesEvent) => void;
  /** ë‚´ëŸ¬í‹°ë¸Œ ë¸íƒ€ ì´ë²¤íŠ¸ ì²˜ë¦¬ */
  handleNarrativeDelta: (event: NarrativeDeltaEvent) => void;
  /** ìµœì¢… ì¶œë ¥ ì´ë²¤íŠ¸ ì²˜ë¦¬ */
  handleFinal: (event: FinalEvent) => void;
  /** ì—ëŸ¬ ì´ë²¤íŠ¸ ì²˜ë¦¬ */
  handleError: (event: ErrorEvent) => void;
  /** ìŠ¤íŠ¸ë¦¼ ì™„ë£Œ */
  completeStream: () => void;
  /** ìƒíƒœ ì´ˆê¸°í™” */
  reset: () => void;
}

export type AgentStore = AgentState & AgentActions;

// =============================================================================
// ì´ˆê¸° ìƒíƒœ
// =============================================================================

/** ê¸°ë³¸ ë‹¨ê³„ ëª©ë¡ (PRD ì˜ˆì‹œ) */
const DEFAULT_PHASES: AgentPhase[] = [
  'parse',
  'validate',
  'plan',
  'resolve',
  'render',
  'verify',
  'commit',
];

/** ì´ˆê¸° ìƒíƒœ ìƒì„± */
function createInitialState(): AgentState {
  return {
    isStreaming: false,
    currentPhase: null,
    phases: DEFAULT_PHASES.map((name) => ({
      name,
      status: 'pending' as const,
    })),
    badges: [],
    narrativeBuffer: '',
    repairCount: 0,
    finalOutput: null,
    error: null,
  };
}

// =============================================================================
// Zustand Store
// =============================================================================

/**
 * Agent Console ìƒíƒœ ìŠ¤í† ì–´.
 *
 * @example
 * ```tsx
 * // ì»´í¬ë„ŒíŠ¸ì—ì„œ ì‚¬ìš©
 * const { isStreaming, phases, badges } = useAgentStore();
 * const startStream = useAgentStore((state) => state.startStream);
 * ```
 */
export const useAgentStore = create<AgentStore>((set) => ({
  // ì´ˆê¸° ìƒíƒœ
  ...createInitialState(),

  // ì•¡ì…˜
  startStream: () => {
    set({
      ...createInitialState(),
      isStreaming: true,
    });
  },

  handleStage: (event) => {
    set((state) => {
      const phaseName = event.name;
      const eventStatus = event.status;

      // RU-002-S2: status ê°’ì— ë”°ë¥¸ ë‹¨ê³„ ìƒíƒœ ê²°ì •
      // 'start' â†’ in_progress
      // 'complete' ë˜ëŠ” 'ok' (ì •ê·œí™”ë¨) â†’ completed
      // 'fail' â†’ failed
      let newStatus: PhaseStatus;
      if (eventStatus === StageStatus.START) {
        newStatus = 'in_progress';
      } else if (eventStatus === 'fail') {
        newStatus = 'failed';
      } else {
        // 'complete' (ì •ê·œí™”ëœ 'ok' í¬í•¨)
        newStatus = 'completed';
      }

      // ë‹¨ê³„ ìƒíƒœ ì—…ë°ì´íŠ¸
      const phases = state.phases.map((phase) => {
        if (phase.name === phaseName) {
          return {
            ...phase,
            status: newStatus,
          };
        }
        return phase;
      });

      return {
        phases,
        currentPhase: eventStatus === StageStatus.START ? phaseName : state.currentPhase,
      };
    });
  },

  handleBadges: (event) => {
    set({
      badges: event.badges,
    });
  },

  handleNarrativeDelta: (event) => {
    set((state) => ({
      narrativeBuffer: state.narrativeBuffer + event.text,
    }));
  },

  handleFinal: (event) => {
    set({
      finalOutput: event.data,
      repairCount: event.data.agent_console?.repair_count ?? 0,
    });
  },

  handleError: (event) => {
    set({
      error: {
        message: event.message,
        code: event.code,
      },
    });
  },

  completeStream: () => {
    set({
      isStreaming: false,
      narrativeBuffer: '', // ìŠ¤íŠ¸ë¦¼ ì™„ë£Œ ì‹œ ë²„í¼ ì´ˆê¸°í™”
    });
  },

  reset: () => {
    set(createInitialState());
  },
}));

// =============================================================================
// ì…€ë ‰í„° (ì„±ëŠ¥ ìµœì í™”ìš©)
// =============================================================================

/** ìŠ¤íŠ¸ë¦¬ë° ìƒíƒœ ì…€ë ‰í„° */
export const selectIsStreaming = (state: AgentStore) => state.isStreaming;

/** í˜„ì¬ ë‹¨ê³„ ì…€ë ‰í„° */
export const selectCurrentPhase = (state: AgentStore) => state.currentPhase;

/** ë‹¨ê³„ ëª©ë¡ ì…€ë ‰í„° */
export const selectPhases = (state: AgentStore) => state.phases;

/** ë°°ì§€ ëª©ë¡ ì…€ë ‰í„° */
export const selectBadges = (state: AgentStore) => state.badges;

/** ë‚´ëŸ¬í‹°ë¸Œ ë²„í¼ ì…€ë ‰í„° */
export const selectNarrativeBuffer = (state: AgentStore) => state.narrativeBuffer;

/** ë³µêµ¬ íšŸìˆ˜ ì…€ë ‰í„° */
export const selectRepairCount = (state: AgentStore) => state.repairCount;

/** ìµœì¢… ì¶œë ¥ ì…€ë ‰í„° */
export const selectFinalOutput = (state: AgentStore) => state.finalOutput;

/** ì—ëŸ¬ ì…€ë ‰í„° */
export const selectError = (state: AgentStore) => state.error;
</file>

<file path="frontend/src/api/turnStream.test.ts">
import { describe, it, expect, vi, beforeEach } from 'vitest';
import { NDJSONParser } from './turnStream';

describe('NDJSONParser', () => {
  let parser: NDJSONParser;

  beforeEach(() => {
    parser = new NDJSONParser();
  });

  it('should parse a single complete line', () => {
    const chunk = JSON.stringify({ type: 'test', value: 1 }) + '\n';
    const results = parser.parse(chunk);
    expect(results).toHaveLength(1);
    expect(results[0]).toEqual({ type: 'test', value: 1 });
  });

  it('should parse multiple complete lines in one chunk', () => {
    const chunk = JSON.stringify({ id: 1 }) + '\n' + JSON.stringify({ id: 2 }) + '\n';
    const results = parser.parse(chunk);
    expect(results).toHaveLength(2);
    expect(results[0]).toEqual({ id: 1 });
    expect(results[1]).toEqual({ id: 2 });
  });

  it('should buffer partial lines and parse them when completed', () => {
    const chunk1 = '{"id": 1';
    const chunk2 = ', "val": "ok"}\n';

    const results1 = parser.parse(chunk1);
    expect(results1).toHaveLength(0);

    const results2 = parser.parse(chunk2);
    expect(results2).toHaveLength(1);
    expect(results2[0]).toEqual({ id: 1, val: 'ok' });
  });

  it('should ignore empty lines', () => {
    const chunk = '\n\n{"a":1}\n\n';
    const results = parser.parse(chunk);
    expect(results).toHaveLength(1);
  });

  it('should not crash on invalid JSON and continue', () => {
    const consoleSpy = vi.spyOn(console, 'warn').mockImplementation(() => {});
    const chunk = 'invalid json\n{"valid": true}\n';
    const results = parser.parse(chunk);

    expect(results).toHaveLength(1);
    expect(results[0]).toEqual({ valid: true });
    expect(consoleSpy).toHaveBeenCalled();
    consoleSpy.mockRestore();
  });

  it('should flush remaining buffer', () => {
    parser.parse('{"id": 1}'); // No newline
    const result = parser.flush();
    expect(result).toEqual({ id: 1 });
  });

  it('should return null on flush with empty buffer', () => {
    const result = parser.flush();
    expect(result).toBeNull();
  });
});

describe('executeTurnStream', () => {
  const mockInput = {
    language: 'ko-KR' as const,
    text: 'Hello',
    action_id: null,
    click: null,
    drop: null, // U-012: ë“œë¡­ ì…ë ¥ í•„ë“œ ì¶”ê°€
    client: { viewport_w: 100, viewport_h: 100, theme: 'dark' as const },
    economy_snapshot: { signal: 100, memory_shard: 0 },
  };

  const mockCallbacks = {
    onStage: vi.fn(),
    onRepair: vi.fn(),
    onBadges: vi.fn(),
    onNarrativeDelta: vi.fn(),
    onFinal: vi.fn(),
    onError: vi.fn(),
    onComplete: vi.fn(),
  };

  beforeEach(() => {
    vi.clearAllMocks();
    global.fetch = vi.fn();
  });

  it('should process stream events correctly (including repair)', async () => {
    const encoder = new TextEncoder();
    const stream = new ReadableStream({
      start(controller) {
        controller.enqueue(
          encoder.encode(JSON.stringify({ type: 'stage', name: 'parse', status: 'start' }) + '\n'),
        );
        controller.enqueue(
          encoder.encode(
            JSON.stringify({ type: 'repair', attempt: 1, message: 'Schema fail, retrying' }) + '\n',
          ),
        );
        controller.enqueue(
          encoder.encode(JSON.stringify({ type: 'narrative_delta', text: 'Hello' }) + '\n'),
        );
        controller.enqueue(
          encoder.encode(
            JSON.stringify({
              type: 'final',
              data: {
                language: 'ko-KR',
                narrative: 'Hello',
                economy: {
                  cost: { signal: 0, memory_shard: 0 },
                  balance_after: { signal: 100, memory_shard: 0 },
                },
                safety: { blocked: false },
              },
            }) + '\n',
          ),
        );
        controller.close();
      },
    });

    (global.fetch as unknown as ReturnType<typeof vi.fn>).mockResolvedValue({
      ok: true,
      body: stream,
    });

    const { executeTurnStream } = await import('./turnStream');
    await executeTurnStream(mockInput, mockCallbacks);

    expect(mockCallbacks.onStage).toHaveBeenCalledWith(expect.objectContaining({ name: 'parse' }));
    expect(mockCallbacks.onRepair).toHaveBeenCalledWith(
      expect.objectContaining({ attempt: 1, message: 'Schema fail, retrying' }),
    );
    expect(mockCallbacks.onNarrativeDelta).toHaveBeenCalledWith(
      expect.objectContaining({ text: 'Hello' }),
    );
    expect(mockCallbacks.onFinal).toHaveBeenCalled();
    expect(mockCallbacks.onComplete).toHaveBeenCalled();
  });

  it('should handle HTTP errors', async () => {
    (global.fetch as unknown as ReturnType<typeof vi.fn>).mockResolvedValue({
      ok: false,
      status: 500,
      statusText: 'Internal Server Error',
    });

    const { executeTurnStream } = await import('./turnStream');
    await executeTurnStream(mockInput, mockCallbacks);

    expect(mockCallbacks.onError).toHaveBeenCalledWith(
      expect.objectContaining({
        code: 'STREAM_ERROR',
        message: expect.stringContaining('500'),
      }),
    );
  });

  it('should handle fetch rejection', async () => {
    (global.fetch as unknown as ReturnType<typeof vi.fn>).mockRejectedValue(
      new Error('Network failure'),
    );

    const { executeTurnStream } = await import('./turnStream');
    await executeTurnStream(mockInput, mockCallbacks);

    expect(mockCallbacks.onError).toHaveBeenCalledWith(
      expect.objectContaining({
        message: 'Network failure',
      }),
    );
  });
});
</file>

<file path="frontend/src/components/ActionDeck.tsx">
/**
 * Unknown World - Action Deck ì»´í¬ë„ŒíŠ¸ (U-009[Mvp]).
 *
 * PRD ìš”êµ¬ì‚¬í•­:
 *   - Action Deck(3~6ì¥ ì¹´ë“œ)ì„ Footer ì˜ì—­ì— ìƒì‹œ ë…¸ì¶œ
 *   - ê° ì¹´ë“œì— ì˜ˆìƒ ë¹„ìš©(ìµœì†Œ/ìµœëŒ€), ìœ„í—˜ë„, ë³´ìƒ íŒíŠ¸ í‘œê¸° (RULE-005)
 *   - ì¹´ë“œ í´ë¦­ ì‹œ TurnInputìœ¼ë¡œ ì„ íƒëœ í–‰ë™ ì „ì†¡ (RULE-008)
 *   - ì”ì•¡ ë¶€ì¡± ì‹œ ì‹¤í–‰ ë¶ˆê°€ í‘œì‹œ + ì €ë¹„ìš© ëŒ€ì•ˆ ë…¸ì¶œ (RULE-005)
 *
 * RULE-002 ì¤€ìˆ˜: ì±„íŒ… ë²„ë¸”/ë©”ì‹œì§€ ë²„íŠ¼ì´ ì•„ë‹Œ "ê²Œì„ ì¹´ë“œ" UI
 *
 * @see vibe/prd.md 6.7 - Action Deck ìš”êµ¬ì‚¬í•­
 * @see .cursor/rules/10-frontend-game-ui.mdc
 * @module components/ActionDeck
 */

import { useMemo, useCallback } from 'react';
import { useTranslation } from 'react-i18next';
import type { ActionCard } from '../schemas/turn';
import { useActionDeckStore } from '../stores/actionDeckStore';
import { useWorldStore } from '../stores/worldStore';
import { useAgentStore } from '../stores/agentStore';
import { useEconomyStore } from '../stores/economyStore';

// =============================================================================
// íƒ€ì… ì •ì˜
// =============================================================================

export interface ActionDeckProps {
  /** ì¹´ë“œ í´ë¦­ ì½œë°± */
  onCardClick?: (card: ActionCard) => void;
  /** ì „ì²´ ë¹„í™œì„±í™” (ìŠ¤íŠ¸ë¦¬ë° ì¤‘ ë“±, ìƒëµ ì‹œ agentStore.isStreaming ì‚¬ìš©) */
  disabled?: boolean;
}

interface CardDisplayInfo extends ActionCard {
  /** í´ë¼ì´ì–¸íŠ¸ ì¸¡ ì‹¤í–‰ ê°€ëŠ¥ ì—¬ë¶€ (ì„œë²„ enabledê°€ ì—†ì„ ë•Œ í´ë°±) */
  isAffordable: boolean;
  /** ìµœì¢… ë¹„í™œì„±í™” ì—¬ë¶€ */
  isDisabled: boolean;
  /** ìµœì¢… ë¹„í™œì„±í™” ì‚¬ìœ  */
  finalDisabledReason: string | null;
}

// =============================================================================
// ê¸°ë³¸ ì¹´ë“œ ìƒì„± (i18n ê¸°ë°˜)
// =============================================================================

function useDefaultCards(): ActionCard[] {
  const { t } = useTranslation();

  return useMemo(
    () => [
      {
        id: 'default-explore',
        label: t('action.default.explore.label'),
        description: t('action.default.explore.description'),
        cost: { signal: 1, memory_shard: 0 },
        cost_estimate: null,
        risk: 'low' as const,
        hint: null,
        reward_hint: null,
        enabled: true,
        disabled_reason: null,
        is_alternative: false,
      },
      {
        id: 'default-investigate',
        label: t('action.default.investigate.label'),
        description: t('action.default.investigate.description'),
        cost: { signal: 2, memory_shard: 0 },
        cost_estimate: null,
        risk: 'medium' as const,
        hint: null,
        reward_hint: null,
        enabled: true,
        disabled_reason: null,
        is_alternative: false,
      },
      {
        id: 'default-talk',
        label: t('action.default.talk.label'),
        description: t('action.default.talk.description'),
        cost: { signal: 1, memory_shard: 0 },
        cost_estimate: null,
        risk: 'low' as const,
        hint: null,
        reward_hint: null,
        enabled: true,
        disabled_reason: null,
        is_alternative: false,
      },
    ],
    [t],
  );
}

// =============================================================================
// ì¹´ë“œ ë¹„ìš© í‘œì‹œ ì»´í¬ë„ŒíŠ¸
// =============================================================================

interface CardCostDisplayProps {
  card: CardDisplayInfo;
}

function CardCostDisplay({ card }: CardCostDisplayProps) {
  const { t } = useTranslation();

  // ë¹„ìš© ì¶”ì • ë²”ìœ„ê°€ ìˆìœ¼ë©´ min~max í‘œì‹œ, ì—†ìœ¼ë©´ ê¸°ë³¸ cost í‘œì‹œ
  const costDisplay = card.cost_estimate
    ? `${card.cost_estimate.min.signal}~${card.cost_estimate.max.signal}`
    : `${card.cost.signal}`;

  const shardCost = card.cost_estimate
    ? card.cost_estimate.max.memory_shard
    : card.cost.memory_shard;

  return (
    <div className="action-card-cost" data-ui-importance="critical">
      {/* Signal ë¹„ìš© */}
      <span className="cost-item">
        <span className="icon-wrapper" aria-label={t('economy.signal_cost')}>
          <img
            src="/ui/icons/signal-16.png"
            alt=""
            aria-hidden="true"
            className="icon-img"
            style={{ width: 14, height: 14 }}
            onError={(e) => e.currentTarget.classList.add('hidden')}
          />
          <span className="icon-fallback">âš¡</span>
        </span>
        <span className="cost-value">{costDisplay}</span>
      </span>

      {/* Shard ë¹„ìš© (0ë³´ë‹¤ í´ ë•Œë§Œ í‘œì‹œ) */}
      {shardCost > 0 && (
        <span className="cost-item">
          <span className="cost-separator">|</span>
          <span className="icon-wrapper" aria-label={t('economy.shard_cost')}>
            <img
              src="/ui/icons/shard-16.png"
              alt=""
              aria-hidden="true"
              className="icon-img"
              style={{ width: 14, height: 14 }}
              onError={(e) => e.currentTarget.classList.add('hidden')}
            />
            <span className="icon-fallback">ğŸ’</span>
          </span>
          <span className="cost-value">
            {card.cost_estimate
              ? `${card.cost_estimate.min.memory_shard}~${card.cost_estimate.max.memory_shard}`
              : card.cost.memory_shard}
          </span>
        </span>
      )}

      {/* ìœ„í—˜ë„ */}
      <span className="cost-item">
        <span className="cost-separator">|</span>
        <span className="icon-wrapper" aria-label={t('economy.risk_level')}>
          <img
            src={`/ui/icons/risk-${card.risk}-16.png`}
            alt=""
            aria-hidden="true"
            className={`icon-img risk-${card.risk}`}
            style={{ width: 14, height: 14 }}
            onError={(e) => e.currentTarget.classList.add('hidden')}
          />
          <span className="icon-fallback">âš </span>
        </span>
        <span className={`risk-label risk-${card.risk}`}>{t(`action.risk.${card.risk}`)}</span>
      </span>
    </div>
  );
}

// =============================================================================
// ë‹¨ì¼ ì¹´ë“œ ì»´í¬ë„ŒíŠ¸
// =============================================================================

interface ActionCardItemProps {
  card: CardDisplayInfo;
  onClick: () => void;
  onHover: (card: CardDisplayInfo | null) => void;
  disabled: boolean;
}

function ActionCardItem({ card, onClick, onHover, disabled }: ActionCardItemProps) {
  const { t } = useTranslation();

  const cardClasses = [
    'action-card',
    'has-chrome',
    card.isDisabled ? 'card-disabled' : '',
    card.is_alternative ? 'card-alternative' : '',
    `risk-border-${card.risk}`,
  ]
    .filter(Boolean)
    .join(' ');

  return (
    <button
      type="button"
      className={cardClasses}
      onClick={onClick}
      onMouseEnter={() => onHover(card)}
      onMouseLeave={() => onHover(null)}
      onFocus={() => onHover(card)}
      onBlur={() => onHover(null)}
      disabled={disabled || card.isDisabled}
      aria-disabled={disabled || card.isDisabled}
      title={card.finalDisabledReason ?? card.description ?? undefined}
    >
      {/* ëŒ€ì•ˆ ì¹´ë“œ í‘œì‹œ */}
      {card.is_alternative && <span className="alternative-badge">{t('action.alternative')}</span>}

      {/* ì¹´ë“œ íƒ€ì´í‹€ */}
      <div className="action-card-title">{card.label}</div>

      {/* ì¹´ë“œ ì„¤ëª… (ìˆì„ ë•Œë§Œ) */}
      {card.description && <div className="action-card-description">{card.description}</div>}

      {/* ë¹„ìš©/ìœ„í—˜ë„ ì •ë³´ */}
      <CardCostDisplay card={card} />

      {/* íŒíŠ¸ ì˜ì—­ */}
      {(card.hint || card.reward_hint) && (
        <div className="action-card-hints">
          {card.hint && (
            <div className="hint-item hint-risk">
              <span className="hint-icon">âš </span>
              <span className="hint-text">{card.hint}</span>
            </div>
          )}
          {card.reward_hint && (
            <div className="hint-item hint-reward">
              <span className="hint-icon">â˜…</span>
              <span className="hint-text">{card.reward_hint}</span>
            </div>
          )}
        </div>
      )}

      {/* ë¹„í™œì„±í™” ì˜¤ë²„ë ˆì´ */}
      {card.isDisabled && (
        <div className="card-disabled-overlay">
          <span className="disabled-reason">
            {card.finalDisabledReason ?? t('action.insufficient_balance')}
          </span>
        </div>
      )}
    </button>
  );
}

// =============================================================================
// ë©”ì¸ Action Deck ì»´í¬ë„ŒíŠ¸
// =============================================================================

export function ActionDeck({ onCardClick, disabled: propsDisabled }: ActionDeckProps) {
  const { t } = useTranslation();
  const defaultCards = useDefaultCards();

  // Store ìƒíƒœ (RU-003: ì»´í¬ë„ŒíŠ¸ ë‚´ì—ì„œ ì§ì ‘ êµ¬ë…)
  const cards = useActionDeckStore((state) => state.cards);
  const currentBalance = useWorldStore((state) => state.economy);
  const isStreaming = useAgentStore((state) => state.isStreaming);
  const setCostEstimateFromCard = useEconomyStore((state) => state.setCostEstimateFromCard);
  const setCostEstimate = useEconomyStore((state) => state.setCostEstimate);

  const disabled = propsDisabled ?? isStreaming;

  // ì¹´ë“œ í˜¸ë²„ í•¸ë“¤ëŸ¬ (U-014: ì˜ˆìƒ ë¹„ìš© í‘œì‹œ)
  const handleCardHover = useCallback(
    (card: CardDisplayInfo | null) => {
      if (card) {
        setCostEstimateFromCard(card.cost, card.cost_estimate, card.id, card.label);
      } else {
        setCostEstimate(null);
      }
    },
    [setCostEstimateFromCard, setCostEstimate],
  );

  // ì¹´ë“œê°€ ì—†ìœ¼ë©´ ê¸°ë³¸ ì¹´ë“œ ì‚¬ìš©
  const displayCards = cards.length > 0 ? cards : defaultCards;

  // ì¹´ë“œë³„ ì‹¤í–‰ ê°€ëŠ¥ ì—¬ë¶€ ê³„ì‚° (Q1: Option A - ì„œë²„ ìš°ì„ , í´ë¼ì´ì–¸íŠ¸ í´ë°±)
  const processedCards: CardDisplayInfo[] = useMemo(() => {
    return displayCards.map((card) => {
      // ì„œë²„ì—ì„œ enabledë¥¼ ëª…ì‹œì ìœ¼ë¡œ falseë¡œ ë³´ëƒˆìœ¼ë©´ ê·¸ëŒ€ë¡œ ì‚¬ìš©
      const serverEnabled = card.enabled;

      // í´ë¼ì´ì–¸íŠ¸ ì¸¡ ì”ì•¡ ì²´í¬ (ì„œë²„ê°€ íŒë‹¨í•˜ì§€ ì•Šì•˜ì„ ë•Œ í´ë°±)
      const costToCheck = card.cost_estimate?.max ?? card.cost;
      const isAffordable =
        currentBalance.signal >= costToCheck.signal &&
        currentBalance.memory_shard >= costToCheck.memory_shard;

      // ìµœì¢… ë¹„í™œì„±í™” ì—¬ë¶€: ì„œë²„ íŒë‹¨ ìš°ì„ , ì—†ìœ¼ë©´ í´ë¼ì´ì–¸íŠ¸ íŒë‹¨
      const isDisabled = !serverEnabled || !isAffordable;

      // ë¹„í™œì„±í™” ì‚¬ìœ  ê²°ì •
      let finalDisabledReason: string | null = null;
      if (!serverEnabled && card.disabled_reason) {
        finalDisabledReason = card.disabled_reason;
      } else if (!isAffordable) {
        finalDisabledReason = t('action.insufficient_balance');
      }

      return {
        ...card,
        isAffordable,
        isDisabled,
        finalDisabledReason,
      };
    });
  }, [displayCards, currentBalance, t]);

  // ì¼ë°˜ ì¹´ë“œì™€ ëŒ€ì•ˆ ì¹´ë“œ ë¶„ë¦¬ (ëŒ€ì•ˆ ì¹´ë“œëŠ” ë’¤ì— ë°°ì¹˜)
  const sortedCards = useMemo(() => {
    const regular = processedCards.filter((c) => !c.is_alternative);
    const alternatives = processedCards.filter((c) => c.is_alternative);
    return [...regular, ...alternatives];
  }, [processedCards]);

  return (
    <div className="action-deck" role="group" aria-label={t('action.deck_label')}>
      {sortedCards.map((card) => (
        <ActionCardItem
          key={card.id}
          card={card}
          onClick={() => onCardClick?.(card)}
          onHover={handleCardHover}
          disabled={disabled}
        />
      ))}

      {/* ëª¨ë“  ì¹´ë“œê°€ ë¹„í™œì„±í™”ë˜ì—ˆì„ ë•Œ ì•ˆë‚´ */}
      {sortedCards.every((c) => c.isDisabled) && !disabled && (
        <div className="deck-empty-notice">{t('action.all_disabled_notice')}</div>
      )}
    </div>
  );
}

export default ActionDeck;
</file>

<file path="frontend/src/components/AgentConsole.tsx">
/**
 * Unknown World - Agent Console ì»´í¬ë„ŒíŠ¸.
 *
 * ì—ì´ì „íŠ¸í˜• ì‹œìŠ¤í…œì„ì„ UIë¡œ ì¦ëª…í•˜ê¸° ìœ„í•œ ì»´í¬ë„ŒíŠ¸ì…ë‹ˆë‹¤.
 * Plan/Queue/Badges/Auto-repair íŠ¸ë ˆì´ìŠ¤ë¥¼ ì‹¤ì‹œê°„ìœ¼ë¡œ í‘œì‹œí•©ë‹ˆë‹¤.
 *
 * ì„¤ê³„ ì›ì¹™:
 *   - RULE-008: ë‹¨ê³„/ë°°ì§€/ë³µêµ¬ë§Œ ë³´ì—¬ì¤Œ (í”„ë¡¬í”„íŠ¸/ë‚´ë¶€ ì¶”ë¡  ë…¸ì¶œ ê¸ˆì§€)
 *   - RULE-002: ê²Œì„ UIë¡œ í‘œí˜„ (ì±„íŒ… ë²„ë¸” ê¸ˆì§€)
 *
 * @module components/AgentConsole
 */

import { useTranslation } from 'react-i18next';
import {
  useAgentStore,
  selectIsStreaming,
  selectPhases,
  selectBadges,
  selectRepairCount,
  selectError,
  type PhaseInfo,
} from '../stores/agentStore';
import type { ValidationBadge } from '../schemas/turn';

// =============================================================================
// ìƒìˆ˜ ì •ì˜
// =============================================================================

/** ë‹¨ê³„ í‘œì‹œ ì´ë¦„ i18n í‚¤ */
const PHASE_KEYS: Record<string, string> = {
  parse: 'agent.console.phase.parse',
  validate: 'agent.console.phase.validate',
  plan: 'agent.console.phase.plan',
  resolve: 'agent.console.phase.resolve',
  render: 'agent.console.phase.render',
  verify: 'agent.console.phase.verify',
  commit: 'agent.console.phase.commit',
};

/** ë°°ì§€ í‘œì‹œ ì •ë³´ (i18n í‚¤ ê¸°ë°˜) */
const BADGE_INFO: Record<ValidationBadge, { labelKey: string; isOk: boolean }> = {
  schema_ok: { labelKey: 'agent.console.badge.schema', isOk: true },
  schema_fail: { labelKey: 'agent.console.badge.schema', isOk: false },
  economy_ok: { labelKey: 'agent.console.badge.economy', isOk: true },
  economy_fail: { labelKey: 'agent.console.badge.economy', isOk: false },
  safety_ok: { labelKey: 'agent.console.badge.safety', isOk: true },
  safety_blocked: { labelKey: 'agent.console.badge.safety', isOk: false },
  consistency_ok: { labelKey: 'agent.console.badge.consistency', isOk: true },
  consistency_fail: { labelKey: 'agent.console.badge.consistency', isOk: false },
};

// =============================================================================
// í•˜ìœ„ ì»´í¬ë„ŒíŠ¸
// =============================================================================

/** ë‹¨ê³„ ìƒíƒœ ì•„ì´ì½˜ */
function PhaseIcon({ status }: { status: PhaseInfo['status'] }) {
  switch (status) {
    case 'pending':
      return <span className="phase-icon pending">â—‹</span>;
    case 'in_progress':
      return <span className="phase-icon in-progress">â—</span>;
    case 'completed':
      return <span className="phase-icon completed">â—</span>;
    case 'failed':
      return <span className="phase-icon failed">âœ•</span>;
    default:
      return <span className="phase-icon">â—‹</span>;
  }
}

/** ë‹¨ê³„ í í•­ëª© */
function PhaseQueueItem({ phase }: { phase: PhaseInfo }) {
  const { t } = useTranslation();
  const key = PHASE_KEYS[phase.name];
  const label = key ? t(key) : phase.name;
  const statusClass = `phase-item ${phase.status}`;

  return (
    <div className={statusClass}>
      <PhaseIcon status={phase.status} />
      <span className="phase-label">{label}</span>
    </div>
  );
}

/** ë‹¨ê³„ í */
function PhaseQueue() {
  const { t } = useTranslation();
  const phases = useAgentStore(selectPhases);

  return (
    <div className="phase-queue">
      <div className="queue-label">{t('agent.console.queue')}</div>
      <div className="queue-items">
        {phases.map((phase) => (
          <PhaseQueueItem key={phase.name} phase={phase} />
        ))}
      </div>
    </div>
  );
}

/** ë°°ì§€ ì•„ì´í…œ */
function BadgeItem({ badge }: { badge: ValidationBadge }) {
  const { t } = useTranslation();
  const info = BADGE_INFO[badge];
  if (!info) return null;

  const statusClass = info.isOk ? 'badge-ok' : 'badge-fail';
  const statusText = info.isOk ? t('agent.console.badge.ok') : t('agent.console.badge.fail');
  const iconName = info.isOk ? 'badge-ok-24.png' : 'badge-fail-24.png';
  const fallbackIcon = info.isOk ? 'âœ“' : 'âœ—';

  return (
    <div className={`badge-item ${statusClass}`}>
      <span className="badge-label">{t(info.labelKey)}</span>
      <span className="badge-status">
        <span className="icon-wrapper">
          <img
            src={`/ui/icons/${iconName}`}
            alt=""
            aria-hidden="true"
            className="badge-icon-img"
            onError={(e) => e.currentTarget.classList.add('hidden')}
          />
          <span className="icon-fallback" style={{ fontSize: '0.625rem' }}>
            {fallbackIcon}
          </span>
        </span>
        {statusText}
      </span>
    </div>
  );
}

/** ë°°ì§€ íŒ¨ë„ */
function BadgesPanel() {
  const { t } = useTranslation();
  const badges = useAgentStore(selectBadges);

  if (badges.length === 0) {
    return (
      <div className="badges-panel">
        <div className="badges-label">{t('agent.console.badges')}</div>
        <div className="badges-empty">{t('agent.console.badges_empty')}</div>
      </div>
    );
  }

  return (
    <div className="badges-panel">
      <div className="badges-label">{t('agent.console.badges')}</div>
      <div className="badges-grid">
        {badges.map((badge, index) => (
          <BadgeItem key={`${badge}-${index}`} badge={badge} />
        ))}
      </div>
    </div>
  );
}

/** Auto-repair íŠ¸ë ˆì´ìŠ¤ */
function RepairTrace() {
  const { t } = useTranslation();
  const repairCount = useAgentStore(selectRepairCount);
  const isStreaming = useAgentStore(selectIsStreaming);

  if (repairCount === 0 && !isStreaming) {
    return null;
  }

  return (
    <div className="repair-trace">
      <span className="repair-label">{t('agent.console.repair')}</span>
      <span className="repair-count">#{repairCount}</span>
      {repairCount > 0 && (
        <span className="repair-status text-warning"> {t('agent.console.repaired')}</span>
      )}
    </div>
  );
}

/** ì—ëŸ¬ í‘œì‹œ */
function ErrorDisplay() {
  const error = useAgentStore(selectError);

  if (!error) return null;

  return (
    <div className="agent-error">
      <span className="error-icon">âš </span>
      <span className="error-message">{error.message}</span>
      {error.code && <span className="error-code">[{error.code}]</span>}
    </div>
  );
}

/** ìŠ¤íŠ¸ë¦¬ë° ìƒíƒœ í‘œì‹œ */
function StreamingStatus() {
  const { t } = useTranslation();
  const isStreaming = useAgentStore(selectIsStreaming);

  return (
    <div className="streaming-status">
      <span className={`status-dot ${isStreaming ? 'active' : ''}`} />
      <span className="status-text">
        {isStreaming ? t('agent.console.status.processing') : t('agent.console.status.idle')}
      </span>
    </div>
  );
}

// =============================================================================
// ë©”ì¸ ì»´í¬ë„ŒíŠ¸
// =============================================================================

/**
 * Agent Console ì»´í¬ë„ŒíŠ¸.
 *
 * Plan/Queue/Badges/Auto-repairë¥¼ ì‹¤ì‹œê°„ìœ¼ë¡œ í‘œì‹œí•©ë‹ˆë‹¤.
 * RULE-008ì— ë”°ë¼ í”„ë¡¬í”„íŠ¸/ë‚´ë¶€ ì¶”ë¡ ì€ ë…¸ì¶œí•˜ì§€ ì•ŠìŠµë‹ˆë‹¤.
 *
 * U-037: data-ui-importance="critical" ë§ˆí‚¹ìœ¼ë¡œ ê°€ë…ì„± ë³´ì¥
 */
export function AgentConsole() {
  return (
    <div className="agent-console-content" data-ui-importance="critical">
      <StreamingStatus />
      <PhaseQueue />
      <BadgesPanel />
      <RepairTrace />
      <ErrorDisplay />
    </div>
  );
}

export default AgentConsole;
</file>

<file path="frontend/src/components/SceneCanvas.hotspot.test.tsx">
import { describe, it, expect, vi, beforeEach } from 'vitest';
import { render, screen, fireEvent, act } from '@testing-library/react';
import { SceneCanvas } from './SceneCanvas';
import type { SceneObject } from '../schemas/turn';
import type { SceneCanvasState } from '../types/scene';
import { useWorldStore } from '../stores/worldStore';
import { useAgentStore } from '../stores/agentStore';

// i18next ëª¨í‚¹
vi.mock('react-i18next', () => ({
  useTranslation: () => ({
    t: (key: string) => key,
  }),
}));

// ResizeObserver ëª¨í‚¹
let resizeCallback: (entries: ResizeObserverEntry[]) => void;
class MockResizeObserver {
  constructor(callback: (entries: ResizeObserverEntry[]) => void) {
    resizeCallback = callback;
  }
  observe = vi.fn();
  unobserve = vi.fn();
  disconnect = vi.fn();
}

global.ResizeObserver = MockResizeObserver as unknown as typeof ResizeObserver;

/**
 * ë¦¬ì‚¬ì´ì¦ˆ ì´ë²¤íŠ¸ë¥¼ ìˆ˜ë™ìœ¼ë¡œ íŠ¸ë¦¬ê±°í•©ë‹ˆë‹¤.
 */
function triggerResize(width: number, height: number) {
  if (resizeCallback) {
    act(() => {
      resizeCallback([
        {
          contentRect: { width, height } as DOMRectReadOnly,
          target: document.querySelector('.scene-canvas') as Element,
        } as ResizeObserverEntry,
      ]);
    });
  }
}

// getBoundingClientRect ëª¨í‚¹
Element.prototype.getBoundingClientRect = vi.fn(() => ({
  width: 800,
  height: 600,
  top: 0,
  left: 0,
  bottom: 600,
  right: 800,
  x: 0,
  y: 0,
  toJSON: () => {},
})) as unknown as () => DOMRect;

describe('SceneCanvas Hotspots', () => {
  const defaultState: SceneCanvasState = {
    status: 'scene',
    imageUrl: 'https://example.com/scene.png',
  };

  const mockObjects: SceneObject[] = [
    {
      id: 'obj-1',
      label: 'Object 1',
      box_2d: { ymin: 100, xmin: 100, ymax: 200, xmax: 200 },
      interaction_hint: 'Click me',
    },
    {
      id: 'obj-2',
      label: 'Object 2',
      box_2d: { ymin: 500, xmin: 500, ymax: 700, xmax: 700 },
      interaction_hint: null,
    },
  ];

  beforeEach(() => {
    vi.clearAllMocks();
    // ìŠ¤í† ì–´ ì´ˆê¸°í™”
    useWorldStore.setState({
      sceneState: { status: 'default', message: '' },
      sceneObjects: [],
    });
    useAgentStore.setState({ isStreaming: false });
  });

  it('should render hotspots when objects are provided in worldStore and status is scene (sorted by area)', () => {
    useWorldStore.setState({
      sceneState: defaultState,
      sceneObjects: mockObjects,
    });

    render(<SceneCanvas />);

    // í•«ìŠ¤íŒŸ ë ˆì´ì–´ í™•ì¸
    const layer = screen.getByLabelText('scene.hotspot.layer_label');
    expect(layer).toBeInTheDocument();

    // ê°œë³„ í•«ìŠ¤íŒŸ í™•ì¸ (role="button")
    // RU-003-S2: ë©´ì  ê¸°ë°˜ ì •ë ¬ - í° ê²ƒì´ ë¨¼ì € ë Œë”ë§ë˜ì–´ ë‚®ì€ z-indexë¥¼ ê°€ì§
    // Object 1: 100x100 = 10,000
    // Object 2: 200x200 = 40,000
    // ë”°ë¼ì„œ Object 2ê°€ ë¨¼ì € ì˜¤ê³  Object 1ì´ ë‚˜ì¤‘ì— ì˜´
    const buttons = screen.getAllByRole('button');
    expect(buttons).toHaveLength(mockObjects.length);
    expect(buttons[0]).toHaveAttribute('aria-label', 'Object 2');
    expect(buttons[1]).toHaveAttribute('aria-label', 'Object 1');

    // z-index í™•ì¸ (RU-003-S2: HotspotOverlay ìì²´ì— styleë¡œ ì ìš©ë¨)
    expect(buttons[0]).toHaveStyle({ zIndex: '1' });
    expect(buttons[1]).toHaveStyle({ zIndex: '2' });
  });

  it('should not render hotspots when status is loading', () => {
    useWorldStore.setState({
      sceneState: { status: 'loading' },
      sceneObjects: mockObjects,
    });

    render(<SceneCanvas />);

    const layer = screen.queryByLabelText('scene.hotspot.layer_label');
    expect(layer).not.toBeInTheDocument();
  });

  it('should call onHotspotClick when a hotspot is clicked', () => {
    const onHotspotClick = vi.fn();
    useWorldStore.setState({
      sceneState: defaultState,
      sceneObjects: mockObjects,
    });

    render(<SceneCanvas onHotspotClick={onHotspotClick} />);

    const firstHotspot = screen.getByLabelText('Object 1');
    fireEvent.click(firstHotspot);

    expect(onHotspotClick).toHaveBeenCalledWith({
      object_id: 'obj-1',
      box_2d: mockObjects[0].box_2d,
    });
  });

  it('should show tooltip on hover', async () => {
    useWorldStore.setState({
      sceneState: defaultState,
      sceneObjects: mockObjects,
    });

    render(<SceneCanvas />);

    const firstHotspot = screen.getByLabelText('Object 1');

    // Hover ì‹œì‘
    fireEvent.mouseEnter(firstHotspot);

    // íˆ´íŒ ë¼ë²¨ í™•ì¸
    expect(screen.getByText('Object 1')).toBeInTheDocument();
    expect(screen.getByText(/scene.hotspot.hint_prefix/)).toBeInTheDocument();
    expect(screen.getByText(/Click me/)).toBeInTheDocument();

    // Hover ì¢…ë£Œ
    fireEvent.mouseLeave(firstHotspot);
    expect(screen.queryByText('Object 1')).not.toBeInTheDocument();
  });

  it('should be disabled when agentStore.isStreaming is true', () => {
    const onHotspotClick = vi.fn();
    useWorldStore.setState({
      sceneState: defaultState,
      sceneObjects: mockObjects,
    });
    useAgentStore.setState({ isStreaming: true });

    render(<SceneCanvas onHotspotClick={onHotspotClick} />);

    const firstHotspot = screen.getByLabelText('Object 1');
    expect(firstHotspot).toHaveAttribute('aria-disabled', 'true');
    expect(firstHotspot).toHaveAttribute('tabindex', '-1');

    fireEvent.click(firstHotspot);
    expect(onHotspotClick).not.toHaveBeenCalled();
  });

  it('should reposition hotspots when canvas size changes (reactive resize)', async () => {
    vi.useFakeTimers();
    useWorldStore.setState({
      sceneState: defaultState,
      sceneObjects: mockObjects,
    });

    render(<SceneCanvas />);

    // Object 1 ì°¾ê¸° (ì •ë ¬ì— ì˜í•´ ë‘ ë²ˆì§¸ ë²„íŠ¼ì¼ ìˆ˜ ìˆìŒ)
    const firstHotspot = screen.getByLabelText('Object 1');

    // ì´ˆê¸° í¬ê¸° (800x600) ê¸°ë°˜ ìœ„ì¹˜ í™•ì¸
    expect(firstHotspot).toHaveStyle({
      top: '60px',
      left: '80px',
      width: '80px',
      height: '60px',
    });

    // í¬ê¸° ë³€ê²½ íŠ¸ë¦¬ê±° (400x300)
    triggerResize(400, 300);

    // RU-003-S2: ResizeObserver ë””ë°”ìš´ìŠ¤(100ms) ëŒ€ê¸°
    act(() => {
      vi.advanceTimersByTime(150);
    });

    // ë³€ê²½ëœ í¬ê¸° ê¸°ë°˜ ìœ„ì¹˜ í™•ì¸
    expect(firstHotspot).toHaveStyle({
      top: '30px',
      left: '40px',
      width: '40px',
      height: '30px',
    });

    vi.useRealTimers();
  });
});
</file>

<file path="frontend/src/stores/economyStore.ts">
/**
 * Unknown World - Economy ìƒíƒœ ê´€ë¦¬ (Zustand) (U-014[Mvp]).
 *
 * Signal/Memory Shard ì¬í™” HUDì™€ í„´ë³„ ë¹„ìš©/ì”ì•¡ ë³€í™”ë¥¼
 * **ì›ì¥(ledger)**ìœ¼ë¡œ ì¶”ì í•˜ì—¬ "ë¹„ìš©/ì§€ì—°ì„ ê²Œì„ ë©”ì»¤ë‹‰"ìœ¼ë¡œ UXì— ë°˜ì˜í•©ë‹ˆë‹¤.
 *
 * ì„¤ê³„ ì›ì¹™:
 *   - RULE-005: Economy ì¸ë°”ë¦¬ì–¸íŠ¸ (ì”ì•¡ ìŒìˆ˜ ê¸ˆì§€, ì˜ˆìƒ ë¹„ìš© ì‚¬ì „ í‘œì‹œ)
 *   - RULE-008: ë¹„ìš©/ëª¨ë¸ ì„ íƒ ì´ìœ ëŠ” ë¼ë²¨(FAST/QUALITY/REF)ë¡œë§Œ ì„¤ëª…
 *   - Q1 ê²°ì •: Option A - ìµœê·¼ Ní„´ë§Œ ë³´ê´€ (UI/ë©”ëª¨ë¦¬ ì ˆê°)
 *   - RU-004-Q5: ìƒìˆ˜ëŠ” save/constants.tsì—ì„œ ì¤‘ì•™ ê´€ë¦¬
 *
 * @module stores/economyStore
 */

import { create } from 'zustand';
import type { CurrencyAmount, ModelLabel, CostEstimate } from '../schemas/turn';
// RU-004-Q5: ìƒìˆ˜ ì¤‘ì•™í™” - constants.tsì—ì„œ import
import { LEDGER_MAX_ENTRIES, LOW_BALANCE_THRESHOLD } from '../save/constants';

// RU-004-Q5: ìƒìˆ˜ re-export (ê¸°ì¡´ í˜¸ì¶œì í˜¸í™˜ì„± ìœ ì§€)
export { LEDGER_MAX_ENTRIES };

// =============================================================================
// íƒ€ì… ì •ì˜
// =============================================================================

/**
 * ì›ì¥(Ledger) ì—”íŠ¸ë¦¬.
 * ê° í„´ì—ì„œ ë°œìƒí•œ ë¹„ìš©ê³¼ ì”ì•¡ ë³€í™”ë¥¼ ê¸°ë¡í•©ë‹ˆë‹¤.
 */
export interface LedgerEntry {
  /** í„´ ID (í„´ ì¹´ìš´íŠ¸) */
  turnId: number;
  /** ì•¡ì…˜ ID (ì„ íƒëœ ì¹´ë“œ ID, ì„ íƒì‚¬í•­) */
  actionId?: string;
  /** ë¹„ìš© ì‚¬ìœ  (ì˜ˆ: "íƒìƒ‰", "ì´ë¯¸ì§€ ìƒì„±") */
  reason: string;
  /** ì†Œë¹„ëœ ë¹„ìš© */
  cost: CurrencyAmount;
  /** ì†Œë¹„ í›„ ì”ì•¡ */
  balanceAfter: CurrencyAmount;
  /** ëª¨ë¸ ë¼ë²¨ (FAST/QUALITY/CHEAP/REF) */
  modelLabel?: ModelLabel;
  /** ê¸°ë¡ ì‹œê°„ */
  timestamp: number;
}

/**
 * ì˜ˆìƒ ë¹„ìš© ìƒíƒœ.
 * í˜„ì¬ ì„ íƒëœ ì•¡ì…˜ì˜ ì˜ˆìƒ ë¹„ìš©ì„ ì¶”ì í•©ë‹ˆë‹¤.
 */
export interface CostEstimateState {
  /** ìµœì†Œ ì˜ˆìƒ ë¹„ìš© */
  min: CurrencyAmount;
  /** ìµœëŒ€ ì˜ˆìƒ ë¹„ìš© */
  max: CurrencyAmount;
  /** ì˜ˆìƒ ë¹„ìš©ì„ ê³„ì‚°í•œ ì•¡ì…˜ ID */
  actionId?: string;
  /** ì˜ˆìƒ ë¹„ìš© ë¼ë²¨/ì„¤ëª… */
  label?: string;
}

/**
 * ë§ˆì§€ë§‰ í™•ì • ë¹„ìš© ìƒíƒœ.
 * ê°€ì¥ ìµœê·¼ í„´ì—ì„œ í™•ì •ëœ ë¹„ìš© ì •ë³´ì…ë‹ˆë‹¤.
 */
export interface LastCostState {
  /** í™•ì •ëœ ë¹„ìš© */
  cost: CurrencyAmount;
  /** í™•ì • í›„ ì”ì•¡ */
  balanceAfter: CurrencyAmount;
  /** í„´ ID */
  turnId: number;
  /** ëª¨ë¸ ë¼ë²¨ */
  modelLabel?: ModelLabel;
}

/** Economy Store ìƒíƒœ */
export interface EconomyStoreState {
  /** ì›ì¥ (ìµœê·¼ Nê°œ ì—”íŠ¸ë¦¬, ìµœì‹ ìˆœ) */
  ledger: LedgerEntry[];
  /** í˜„ì¬ ì˜ˆìƒ ë¹„ìš© (ì„ íƒí•œ ì•¡ì…˜ ê¸°ë°˜) */
  costEstimate: CostEstimateState | null;
  /** ë§ˆì§€ë§‰ í™•ì • ë¹„ìš© */
  lastCost: LastCostState | null;
  /** ì”ì•¡ ë¶€ì¡± ê²½ê³  ì—¬ë¶€ */
  isBalanceLow: boolean;
  /** ì”ì•¡ ë¶€ì¡± ì„ê³„ê°’ (Signal ê¸°ì¤€) */
  lowBalanceThreshold: number;
}

/** Economy Store ì•¡ì…˜ */
export interface EconomyStoreActions {
  /**
   * í„´ ì™„ë£Œ ì‹œ ì›ì¥ì— ì—”íŠ¸ë¦¬ë¥¼ ì¶”ê°€í•©ë‹ˆë‹¤.
   */
  addLedgerEntry: (entry: Omit<LedgerEntry, 'timestamp'>) => void;

  /**
   * SaveGame ë³µì› ì‹œ ì›ì¥ì„ ê·¸ëŒ€ë¡œ ì£¼ì…í•©ë‹ˆë‹¤ (RU-004-S1).
   *
   * - ledgerëŠ” ì €ì¥ëœ ìˆœì„œ(ìµœì‹ ìˆœ)ë¥¼ ìœ ì§€í•©ë‹ˆë‹¤.
   * - timestampëŠ” ì €ì¥ëœ ê°’ì„ ë³´ì¡´í•©ë‹ˆë‹¤.
   * - lastCostëŠ” ìµœì‹  ì—”íŠ¸ë¦¬(ì²« ì›ì†Œ) ê¸°ì¤€ìœ¼ë¡œ ì„¤ì •í•©ë‹ˆë‹¤.
   * - isBalanceLowëŠ” ì „ë‹¬ëœ currentBalanceë¡œ ì¬ê³„ì‚°í•©ë‹ˆë‹¤.
   *
   * @param ledger - ì €ì¥ëœ ì›ì¥ ë°°ì—´ (ìµœì‹ ìˆœ, timestamp í¬í•¨)
   * @param currentBalance - ë³µì›ëœ ì”ì•¡ (isBalanceLow ê³„ì‚°ìš©)
   */
  hydrateLedger: (ledger: LedgerEntry[], currentBalance: CurrencyAmount) => void;

  /**
   * ì˜ˆìƒ ë¹„ìš©ì„ ì„¤ì •í•©ë‹ˆë‹¤ (ì¹´ë“œ ì„ íƒ/í˜¸ë²„ ì‹œ).
   */
  setCostEstimate: (estimate: CostEstimateState | null) => void;

  /**
   * ì¹´ë“œì˜ ë¹„ìš© ì •ë³´ë¡œ ì˜ˆìƒ ë¹„ìš©ì„ ì„¤ì •í•©ë‹ˆë‹¤.
   */
  setCostEstimateFromCard: (
    cost: CurrencyAmount,
    costEstimate: CostEstimate | null,
    actionId: string,
    label?: string,
  ) => void;

  /**
   * ë§ˆì§€ë§‰ í™•ì • ë¹„ìš©ì„ ì„¤ì •í•©ë‹ˆë‹¤ (TurnOutput ë°˜ì˜ ì‹œ).
   */
  setLastCost: (lastCost: LastCostState) => void;

  /**
   * ì”ì•¡ ë¶€ì¡± ìƒíƒœë¥¼ ì—…ë°ì´íŠ¸í•©ë‹ˆë‹¤.
   */
  updateBalanceLowStatus: (currentBalance: CurrencyAmount) => void;

  /**
   * ì”ì•¡ ë¶€ì¡± ì„ê³„ê°’ì„ ì„¤ì •í•©ë‹ˆë‹¤.
   */
  setLowBalanceThreshold: (threshold: number) => void;

  /**
   * ì›ì¥ì„ ì´ˆê¸°í™”í•©ë‹ˆë‹¤.
   */
  clearLedger: () => void;

  /**
   * ì „ì²´ ìƒíƒœë¥¼ ì´ˆê¸°í™”í•©ë‹ˆë‹¤.
   */
  reset: () => void;
}

export type EconomyStore = EconomyStoreState & EconomyStoreActions;

// =============================================================================
// ì´ˆê¸° ìƒíƒœ
// =============================================================================

function createInitialState(): EconomyStoreState {
  return {
    ledger: [],
    costEstimate: null,
    lastCost: null,
    isBalanceLow: false,
    // RU-004-Q5: ì„ê³„ê°’ ìƒìˆ˜ SSOT (save/constants.ts)
    lowBalanceThreshold: LOW_BALANCE_THRESHOLD,
  };
}

// =============================================================================
// Zustand Store
// =============================================================================

/**
 * Economy ìƒíƒœ ìŠ¤í† ì–´.
 *
 * í„´ë³„ ë¹„ìš©/ì”ì•¡ ë³€í™”ë¥¼ ì›ì¥(ledger)ìœ¼ë¡œ ì¶”ì í•˜ê³ ,
 * ì˜ˆìƒ ë¹„ìš©ê³¼ í™•ì • ë¹„ìš©ì„ UIì— ì œê³µí•©ë‹ˆë‹¤.
 *
 * @example
 * ```tsx
 * // ì˜ˆìƒ ë¹„ìš© ì„¤ì • (ì¹´ë“œ í˜¸ë²„ ì‹œ)
 * const setCostEstimateFromCard = useEconomyStore(s => s.setCostEstimateFromCard);
 * setCostEstimateFromCard(card.cost, card.cost_estimate, card.id, card.label);
 *
 * // í„´ ì™„ë£Œ ì‹œ ì›ì¥ ê¸°ë¡
 * const addLedgerEntry = useEconomyStore(s => s.addLedgerEntry);
 * addLedgerEntry({
 *   turnId: turnCount,
 *   reason: 'explore',
 *   cost: turnOutput.economy.cost,
 *   balanceAfter: turnOutput.economy.balance_after,
 * });
 * ```
 */
export const useEconomyStore = create<EconomyStore>((set, get) => ({
  // ì´ˆê¸° ìƒíƒœ
  ...createInitialState(),

  // ì•¡ì…˜

  addLedgerEntry: (entry) => {
    const timestamp = Date.now();
    const newEntry: LedgerEntry = { ...entry, timestamp };

    set((state) => {
      // ìµœì‹ ìˆœìœ¼ë¡œ ì¶”ê°€í•˜ê³  ìµœëŒ€ ê°œìˆ˜ ìœ ì§€ (Q1: Option A)
      const updatedLedger = [newEntry, ...state.ledger].slice(0, LEDGER_MAX_ENTRIES);

      return {
        ledger: updatedLedger,
        lastCost: {
          cost: entry.cost,
          balanceAfter: entry.balanceAfter,
          turnId: entry.turnId,
          modelLabel: entry.modelLabel,
        },
        // í„´ ì™„ë£Œ í›„ ì˜ˆìƒ ë¹„ìš© ì´ˆê¸°í™”
        costEstimate: null,
      };
    });
  },

  hydrateLedger: (ledger, currentBalance) => {
    const { lowBalanceThreshold } = get();

    // LEDGER_MAX_ENTRIES ì •ì±… ì ìš© (ì €ì¥ëœ ê²ƒì´ ë” ë§ì„ ê²½ìš° ëŒ€ë¹„)
    const hydratedLedger = ledger.slice(0, LEDGER_MAX_ENTRIES);

    // lastCostëŠ” ê°€ì¥ ìµœì‹  ì—”íŠ¸ë¦¬(ì²« ì›ì†Œ) ê¸°ì¤€ìœ¼ë¡œ ì„¤ì •
    const latestEntry = hydratedLedger[0] ?? null;
    const lastCost: LastCostState | null = latestEntry
      ? {
          cost: latestEntry.cost,
          balanceAfter: latestEntry.balanceAfter,
          turnId: latestEntry.turnId,
          modelLabel: latestEntry.modelLabel,
        }
      : null;

    // isBalanceLowëŠ” ë³µì›ëœ ì”ì•¡ ê¸°ì¤€ìœ¼ë¡œ ì¬ê³„ì‚°
    const isBalanceLow = currentBalance.signal < lowBalanceThreshold;

    set({
      ledger: hydratedLedger,
      lastCost,
      isBalanceLow,
      costEstimate: null,
    });
  },

  setCostEstimate: (estimate) => {
    set({ costEstimate: estimate });
  },

  setCostEstimateFromCard: (cost, costEstimate, actionId, label) => {
    if (costEstimate) {
      set({
        costEstimate: {
          min: costEstimate.min,
          max: costEstimate.max,
          actionId,
          label,
        },
      });
    } else {
      // cost_estimateê°€ ì—†ìœ¼ë©´ ê¸°ë³¸ costë¥¼ min/maxë¡œ ì‚¬ìš©
      set({
        costEstimate: {
          min: cost,
          max: cost,
          actionId,
          label,
        },
      });
    }
  },

  setLastCost: (lastCost) => {
    set({ lastCost });
  },

  updateBalanceLowStatus: (currentBalance) => {
    const { lowBalanceThreshold } = get();
    const isLow = currentBalance.signal < lowBalanceThreshold;
    set({ isBalanceLow: isLow });
  },

  setLowBalanceThreshold: (threshold) => {
    set({ lowBalanceThreshold: threshold });
  },

  clearLedger: () => {
    set({ ledger: [], lastCost: null });
  },

  reset: () => {
    set(createInitialState());
  },
}));

// =============================================================================
// ì…€ë ‰í„° (ì„±ëŠ¥ ìµœì í™”ìš©)
// =============================================================================

/** ì›ì¥ ì…€ë ‰í„° */
export const selectLedger = (state: EconomyStore) => state.ledger;

/** ì˜ˆìƒ ë¹„ìš© ì…€ë ‰í„° */
export const selectCostEstimate = (state: EconomyStore) => state.costEstimate;

/** ë§ˆì§€ë§‰ í™•ì • ë¹„ìš© ì…€ë ‰í„° */
export const selectLastCost = (state: EconomyStore) => state.lastCost;

/** ì”ì•¡ ë¶€ì¡± ìƒíƒœ ì…€ë ‰í„° */
export const selectIsBalanceLow = (state: EconomyStore) => state.isBalanceLow;

/** ìµœê·¼ Nê°œ ì›ì¥ ì—”íŠ¸ë¦¬ ì…€ë ‰í„° */
export const selectRecentLedger =
  (count: number) =>
  (state: EconomyStore): LedgerEntry[] =>
    state.ledger.slice(0, count);

/** ì´ ì†Œë¹„ ë¹„ìš© ê³„ì‚° ì…€ë ‰í„° (í˜„ì¬ ì„¸ì…˜) */
export const selectTotalSpent = (state: EconomyStore): CurrencyAmount => {
  return state.ledger.reduce(
    (acc, entry) => ({
      signal: acc.signal + entry.cost.signal,
      memory_shard: acc.memory_shard + entry.cost.memory_shard,
    }),
    { signal: 0, memory_shard: 0 },
  );
};

// =============================================================================
// ìœ í‹¸ë¦¬í‹° í•¨ìˆ˜
// =============================================================================

/**
 * í˜„ì¬ ì”ì•¡ìœ¼ë¡œ ì˜ˆìƒ ë¹„ìš©ì„ ê°ë‹¹í•  ìˆ˜ ìˆëŠ”ì§€ í™•ì¸í•©ë‹ˆë‹¤.
 * RULE-005: ì”ì•¡ ë¶€ì¡± ì‹œ ì‹¤í–‰ ê°•í–‰ì´ ì•„ë‹ˆë¼ ëŒ€ì²´ í–‰ë™ì„ ì œì•ˆ.
 */
export function canAffordCost(
  balance: CurrencyAmount,
  cost: CurrencyAmount,
): { affordable: boolean; shortfall: CurrencyAmount } {
  const signalShortfall = Math.max(0, cost.signal - balance.signal);
  const shardShortfall = Math.max(0, cost.memory_shard - balance.memory_shard);

  return {
    affordable: signalShortfall === 0 && shardShortfall === 0,
    shortfall: { signal: signalShortfall, memory_shard: shardShortfall },
  };
}

/**
 * ì˜ˆìƒ ë¹„ìš©ì˜ ìµœëŒ€ê°’ìœ¼ë¡œ ê°ë‹¹ ê°€ëŠ¥ ì—¬ë¶€ë¥¼ í™•ì¸í•©ë‹ˆë‹¤.
 */
export function canAffordEstimate(
  balance: CurrencyAmount,
  estimate: CostEstimateState,
): { affordable: boolean; shortfall: CurrencyAmount } {
  return canAffordCost(balance, estimate.max);
}
</file>

<file path="frontend/src/types/turn_stream.ts">
/**
 * Unknown World - Turn Stream ì´ë²¤íŠ¸ ê³„ì•½(Contract).
 *
 * NDJSON ìŠ¤íŠ¸ë¦¬ë°ì—ì„œ ì‚¬ìš©ë˜ëŠ” ì´ë²¤íŠ¸ íƒ€ì…, ì¸í„°í˜ì´ìŠ¤ë¥¼ ì •ì˜í•©ë‹ˆë‹¤.
 * ì´ ëª¨ë“ˆì€ ë°±ì—”ë“œì™€ í”„ë¡ íŠ¸ì—”ë“œ ê°„ì˜ ìŠ¤íŠ¸ë¦¼ ì´ë²¤íŠ¸ ê³„ì•½ SSOTì…ë‹ˆë‹¤.
 *
 * ì„¤ê³„ ì›ì¹™:
 *   - RU-002-Q4: ì´ë²¤íŠ¸ ê³„ì•½ì„ transport ê³„ì¸µìœ¼ë¡œ ë¶„ë¦¬
 *   - RU-002-S2: ì´ë²¤íŠ¸ë³„ Zod ê²€ì¦ + Unknown/í™•ì¥ ì´ë²¤íŠ¸ í´ë°±
 *   - RULE-003: êµ¬ì¡°í™” ì¶œë ¥(JSON Schema) ìš°ì„  + ì´ì¤‘ ê²€ì¦
 *   - RULE-008: ë‹¨ê³„/ë°°ì§€ ê°€ì‹œí™”
 *
 * ì°¸ì¡°:
 *   - vibe/unit-plans/U-007[Mvp].md
 *   - vibe/refactors/RU-002-Q4.md
 *   - vibe/refactors/RU-002-S2.md
 *
 * @module types/turn_stream
 */

import { z } from 'zod';
import {
  AgentPhaseSchema,
  ValidationBadgeSchema,
  type TurnOutput,
  type AgentPhase,
  type ValidationBadge,
} from '../schemas/turn';

// =============================================================================
// ìŠ¤íŠ¸ë¦¼ ì´ë²¤íŠ¸ íƒ€ì… ìƒìˆ˜ (ì„œë²„ ê³„ì•½ê³¼ ì¼ì¹˜)
// =============================================================================

/** ìŠ¤íŠ¸ë¦¼ ì´ë²¤íŠ¸ íƒ€ì… ìƒìˆ˜ */
export const StreamEventType = {
  STAGE: 'stage',
  BADGES: 'badges',
  NARRATIVE_DELTA: 'narrative_delta',
  FINAL: 'final',
  ERROR: 'error',
  REPAIR: 'repair',
} as const;

export type StreamEventTypeName = (typeof StreamEventType)[keyof typeof StreamEventType];

/**
 * ë‹¨ê³„ ìƒíƒœ ìƒìˆ˜.
 * RU-002-S2/RU-002-Q2: v1(complete) ë° v2(ok/fail) ë³„ì¹­ ëª¨ë‘ ì§€ì›.
 */
export const StageStatus = {
  START: 'start',
  COMPLETE: 'complete',
  /** ë‹¨ê³„ ì‹¤íŒ¨ */
  FAIL: 'fail',
} as const;

export type StageStatusName = (typeof StageStatus)[keyof typeof StageStatus];

// =============================================================================
// RU-002-S2: ì´ë²¤íŠ¸ë³„ Zod ìŠ¤í‚¤ë§ˆ (ê²½ëŸ‰ ê²€ì¦ + í´ë°±)
// =============================================================================

/**
 * stage.status ìŠ¤í‚¤ë§ˆ.
 * v1(complete) ë° v2(ok/fail) ë³„ì¹­ ëª¨ë‘ í—ˆìš©.
 */
export const StageStatusSchema = z.enum(['start', 'complete', 'ok', 'fail']);

/**
 * StageEvent Zod ìŠ¤í‚¤ë§ˆ.
 * ë‹¨ê³„ ì§„í–‰ ì´ë²¤íŠ¸ ê²€ì¦ìš©.
 */
export const StageEventSchema = z.object({
  type: z.literal(StreamEventType.STAGE),
  name: AgentPhaseSchema,
  status: StageStatusSchema,
});

/**
 * RepairEvent Zod ìŠ¤í‚¤ë§ˆ.
 * ìë™ ë³µêµ¬ ì‹œë„ ì´ë²¤íŠ¸ ê²€ì¦ìš©.
 */
export const RepairEventSchema = z.object({
  type: z.literal(StreamEventType.REPAIR),
  attempt: z.number(),
  message: z.string().optional(),
});

/**
 * BadgesEvent Zod ìŠ¤í‚¤ë§ˆ (v1: ë°°ì—´).
 * v1ì€ badges: string[] í˜•ì‹.
 */
export const BadgesEventSchemaV1 = z.object({
  type: z.literal(StreamEventType.BADGES),
  badges: z.array(ValidationBadgeSchema),
});

/**
 * BadgesEvent Zod ìŠ¤í‚¤ë§ˆ (v2: ê°ì²´/ë§µ).
 * í–¥í›„ v2ëŠ” badges: { [key]: status } í˜•ì‹ì„ ì§€ì›í•  ìˆ˜ ìˆìŒ.
 * í˜„ì¬ëŠ” v1ë§Œ ì‚¬ìš©í•˜ë¯€ë¡œ ì´ ìŠ¤í‚¤ë§ˆëŠ” í™•ì¥ì„±ì„ ìœ„í•´ ì •ì˜.
 */
export const BadgesEventSchemaV2 = z.object({
  type: z.literal(StreamEventType.BADGES),
  badges: z.record(z.string(), z.boolean()),
});

/**
 * BadgesEvent í†µí•© ìŠ¤í‚¤ë§ˆ.
 * v1(ë°°ì—´) ë˜ëŠ” v2(ê°ì²´) ëª¨ë‘ í—ˆìš©.
 */
export const BadgesEventSchema = z.union([BadgesEventSchemaV1, BadgesEventSchemaV2]);

/**
 * NarrativeDeltaEvent Zod ìŠ¤í‚¤ë§ˆ.
 * íƒ€ì íš¨ê³¼ìš© ë‚´ëŸ¬í‹°ë¸Œ ë¸íƒ€ ì´ë²¤íŠ¸ ê²€ì¦ìš©.
 */
export const NarrativeDeltaEventSchema = z.object({
  type: z.literal(StreamEventType.NARRATIVE_DELTA),
  text: z.string(),
});

/**
 * FinalEvent ì›ì‹œ ìŠ¤í‚¤ë§ˆ.
 * v1(data) ë° v2(turn_output) ë³„ì¹­ ëª¨ë‘ í—ˆìš©.
 * TurnOutput ìì²´ ê²€ì¦ì€ turnStream.tsì—ì„œ safeParseTurnOutputìœ¼ë¡œ ìˆ˜í–‰.
 */
export const FinalEventRawSchema = z.object({
  type: z.literal(StreamEventType.FINAL),
  data: z.unknown(),
});

/**
 * ErrorEvent Zod ìŠ¤í‚¤ë§ˆ.
 * ì—ëŸ¬ ì´ë²¤íŠ¸ ê²€ì¦ìš©.
 */
export const ErrorEventSchema = z.object({
  type: z.literal(StreamEventType.ERROR),
  message: z.string(),
  code: z.string().optional(),
});

/**
 * ì´ë²¤íŠ¸ íƒ€ì… ì¶”ì¶œìš© ìµœì†Œ ìŠ¤í‚¤ë§ˆ.
 * Unknown ì´ë²¤íŠ¸ íŒë³„ì— ì‚¬ìš©.
 */
export const BaseEventSchema = z.object({
  type: z.string(),
});

// =============================================================================
// ì´ë²¤íŠ¸ íŒŒì‹± ìœ í‹¸ë¦¬í‹° (RU-002-S2)
// =============================================================================

/** ì´ë²¤íŠ¸ ê²€ì¦ ê²°ê³¼ íƒ€ì… */
export type EventParseResult<T> =
  | { success: true; data: T }
  | { success: false; error: z.ZodError };

/**
 * StageEventë¥¼ ì•ˆì „í•˜ê²Œ íŒŒì‹±í•©ë‹ˆë‹¤.
 */
export function safeParseStageEvent(
  data: unknown,
): EventParseResult<z.infer<typeof StageEventSchema>> {
  const result = StageEventSchema.safeParse(data);
  return result.success
    ? { success: true, data: result.data }
    : { success: false, error: result.error };
}

/**
 * RepairEventë¥¼ ì•ˆì „í•˜ê²Œ íŒŒì‹±í•©ë‹ˆë‹¤.
 */
export function safeParseRepairEvent(
  data: unknown,
): EventParseResult<z.infer<typeof RepairEventSchema>> {
  const result = RepairEventSchema.safeParse(data);
  return result.success
    ? { success: true, data: result.data }
    : { success: false, error: result.error };
}

/**
 * BadgesEventë¥¼ ì•ˆì „í•˜ê²Œ íŒŒì‹±í•©ë‹ˆë‹¤.
 * v1(ë°°ì—´) í˜•íƒœë¡œ ì •ê·œí™”í•˜ì—¬ ë°˜í™˜í•©ë‹ˆë‹¤.
 */
export function safeParseBadgesEvent(data: unknown): EventParseResult<BadgesEvent> {
  const result = BadgesEventSchema.safeParse(data);
  if (!result.success) {
    return { success: false, error: result.error };
  }

  // v2(ê°ì²´) í˜•íƒœì¸ ê²½ìš° v1(ë°°ì—´)ë¡œ ì •ê·œí™”
  const parsed = result.data;
  if (Array.isArray(parsed.badges)) {
    // v1 í˜•íƒœ: ê·¸ëŒ€ë¡œ ë°˜í™˜
    return {
      success: true,
      data: { type: StreamEventType.BADGES, badges: parsed.badges as ValidationBadge[] },
    };
  } else {
    // v2 í˜•íƒœ: trueì¸ í‚¤ë§Œ ì¶”ì¶œí•˜ì—¬ ë°°ì—´ë¡œ ë³€í™˜
    const badgeArray = Object.entries(parsed.badges)
      .filter(([, value]) => value)
      .map(([key]) => key as ValidationBadge);
    return {
      success: true,
      data: { type: StreamEventType.BADGES, badges: badgeArray },
    };
  }
}

/**
 * NarrativeDeltaEventë¥¼ ì•ˆì „í•˜ê²Œ íŒŒì‹±í•©ë‹ˆë‹¤.
 */
export function safeParseNarrativeDeltaEvent(
  data: unknown,
): EventParseResult<z.infer<typeof NarrativeDeltaEventSchema>> {
  const result = NarrativeDeltaEventSchema.safeParse(data);
  return result.success
    ? { success: true, data: result.data }
    : { success: false, error: result.error };
}

/**
 * FinalEvent ì›ì‹œ í˜•íƒœë¥¼ ì•ˆì „í•˜ê²Œ íŒŒì‹±í•©ë‹ˆë‹¤.
 * TurnOutput ìì²´ ê²€ì¦ì€ ë³„ë„ë¡œ ìˆ˜í–‰í•´ì•¼ í•©ë‹ˆë‹¤.
 */
export function safeParseFinalEventRaw(
  data: unknown,
): EventParseResult<z.infer<typeof FinalEventRawSchema>> {
  const result = FinalEventRawSchema.safeParse(data);
  return result.success
    ? { success: true, data: result.data }
    : { success: false, error: result.error };
}

/**
 * ErrorEventë¥¼ ì•ˆì „í•˜ê²Œ íŒŒì‹±í•©ë‹ˆë‹¤.
 */
export function safeParseErrorEvent(
  data: unknown,
): EventParseResult<z.infer<typeof ErrorEventSchema>> {
  const result = ErrorEventSchema.safeParse(data);
  return result.success
    ? { success: true, data: result.data }
    : { success: false, error: result.error };
}

/**
 * stage.status ì •ê·œí™” í—¬í¼.
 * 'ok'ë¥¼ 'complete'ë¡œ, 'fail'ì€ ê·¸ëŒ€ë¡œ ìœ ì§€.
 */
export function normalizeStageStatus(status: string): 'start' | 'complete' | 'fail' {
  if (status === 'ok') return 'complete';
  if (status === 'fail') return 'fail';
  if (status === 'start') return 'start';
  return 'complete';
}

// =============================================================================
// ìŠ¤íŠ¸ë¦¼ ì´ë²¤íŠ¸ ì¸í„°í˜ì´ìŠ¤
// =============================================================================

/**
 * ë‹¨ê³„ ì§„í–‰ ì´ë²¤íŠ¸.
 * RU-002-S2: statusì— 'fail' ì¶”ê°€í•˜ì—¬ ë‹¨ê³„ ì‹¤íŒ¨ í‘œí˜„ ì§€ì›.
 */
export interface StageEvent {
  type: typeof StreamEventType.STAGE;
  name: AgentPhase;
  /** 'start' | 'complete' | 'ok' | 'fail'. okëŠ” completeë¡œ ì •ê·œí™”ë¨. */
  status: StageStatusName;
}

/** ìë™ ë³µêµ¬(Repair) ì´ë²¤íŠ¸ */
export interface RepairEvent {
  type: typeof StreamEventType.REPAIR;
  attempt: number;
  message?: string;
}

/** ë°°ì§€ ì´ë²¤íŠ¸ */
export interface BadgesEvent {
  type: typeof StreamEventType.BADGES;
  badges: ValidationBadge[];
}

/** ë‚´ëŸ¬í‹°ë¸Œ ë¸íƒ€ ì´ë²¤íŠ¸ (íƒ€ì íš¨ê³¼ìš©) */
export interface NarrativeDeltaEvent {
  type: typeof StreamEventType.NARRATIVE_DELTA;
  text: string;
}

/** ìµœì¢… TurnOutput ì´ë²¤íŠ¸
 *
 * RU-002-Q2: v1ì€ `data`, v2ëŠ” `turn_output` ì‚¬ìš©.
 * í•˜ìœ„í˜¸í™˜ì„ ìœ„í•´ ë‘ í•„ë“œ ëª¨ë‘ ì„ ì–¸í•˜ë˜, ì •ê·œí™”ëœ ì¸í„°í˜ì´ìŠ¤ëŠ” `data`ë¥¼ ì‚¬ìš©.
 */
export interface FinalEvent {
  type: typeof StreamEventType.FINAL;
  /** v1 í˜„í–‰ ê³„ì•½: TurnOutput í˜ì´ë¡œë“œ */
  data: TurnOutput;
}

/** FinalEvent ì›ì‹œ ìˆ˜ì‹  í˜•íƒœ */
export interface FinalEventRaw {
  type: typeof StreamEventType.FINAL;
  /** TurnOutput í˜ì´ë¡œë“œ */
  data: TurnOutput;
}

/** ì—ëŸ¬ ì´ë²¤íŠ¸ */
export interface ErrorEvent {
  type: typeof StreamEventType.ERROR;
  message: string;
  code?: string;
}

/** ìŠ¤íŠ¸ë¦¼ ì´ë²¤íŠ¸ ìœ ë‹ˆì˜¨ íƒ€ì… */
export type StreamEvent =
  | StageEvent
  | RepairEvent
  | BadgesEvent
  | NarrativeDeltaEvent
  | FinalEvent
  | ErrorEvent;

// =============================================================================
// ìŠ¤íŠ¸ë¦¼ ì½œë°± ì¸í„°í˜ì´ìŠ¤
// =============================================================================

/** ìŠ¤íŠ¸ë¦¼ ì´ë²¤íŠ¸ ì½œë°± */
export interface StreamCallbacks {
  /** ë‹¨ê³„ ì§„í–‰ ì´ë²¤íŠ¸ */
  onStage?: (event: StageEvent) => void;
  /** ìë™ ë³µêµ¬ ì´ë²¤íŠ¸ */
  onRepair?: (event: RepairEvent) => void;
  /** ë°°ì§€ ì´ë²¤íŠ¸ */
  onBadges?: (event: BadgesEvent) => void;
  /** ë‚´ëŸ¬í‹°ë¸Œ ë¸íƒ€ ì´ë²¤íŠ¸ */
  onNarrativeDelta?: (event: NarrativeDeltaEvent) => void;
  /** ìµœì¢… TurnOutput ì´ë²¤íŠ¸ */
  onFinal?: (event: FinalEvent) => void;
  /** ì—ëŸ¬ ì´ë²¤íŠ¸ */
  onError?: (event: ErrorEvent) => void;
  /** ìŠ¤íŠ¸ë¦¼ ì™„ë£Œ */
  onComplete?: () => void;
}
</file>

<file path="frontend/src/save/saveGame.ts">
/**
 * Unknown World - SaveGame ì €ì¥/ë³µì› ëª¨ë“ˆ (U-015[Mvp]).
 *
 * ë¡œê·¸ì¸ ì—†ì´ ì¦‰ì‹œ ì‹œì‘ ê°€ëŠ¥í•œ ë°ëª¨ í”„ë¡œí•„ê³¼ ì„¸ì´ë¸Œ/ë¡œë“œ ê¸°ëŠ¥ì„ ì œê³µí•©ë‹ˆë‹¤.
 * DB ì—†ì´ SaveGame JSON ì§ë ¬í™” ê¸°ë°˜ìœ¼ë¡œ localStorageì— ì €ì¥í•©ë‹ˆë‹¤.
 *
 * ì„¤ê³„ ì›ì¹™:
 *   - RULE-010: DB/ORM ë„ì… ê¸ˆì§€ (SaveGame JSON ì§ë ¬í™” ê¸°ë°˜)
 *   - RULE-006: language í•„ë“œë¡œ ko/en í˜¼í•© ë°©ì§€
 *   - Q1 ê²°ì •: Option A - localStorage ì‚¬ìš© (ë‹¨ìˆœ/ë°ëª¨ ì í•©)
 *   - RU-004-Q5: ìƒìˆ˜ëŠ” constants.tsì—ì„œ ì¤‘ì•™ ê´€ë¦¬
 *
 * @module save/saveGame
 */

import { z } from 'zod';
import type { SupportedLanguage } from '../i18n';
import type { LedgerEntry } from '../stores/economyStore';
import type { Quest, WorldRule } from '../schemas/turn';
import type { InventoryItem } from '../stores/inventoryStore';
import type { MutationEvent, NarrativeEntry, EconomyState } from '../stores/worldStore';
import type { SceneObject } from '../schemas/turn';

// RU-004-Q5: ìƒìˆ˜ ì¤‘ì•™í™” - constants.tsì—ì„œ import
import { SAVEGAME_VERSION, SAVEGAME_STORAGE_KEY, CURRENT_PROFILE_KEY } from './constants';

// U-041: ë§ˆì´ê·¸ë ˆì´ì…˜ ëª¨ë“ˆ
import {
  upgradeToLatest,
  extractVersion,
  isMigratableVersion,
  type MigrationResult,
} from './migrations';

// RU-004-Q5: ìƒìˆ˜ re-export (ê¸°ì¡´ í˜¸ì¶œì í˜¸í™˜ì„± ìœ ì§€)
export { SAVEGAME_VERSION, SAVEGAME_STORAGE_KEY, CURRENT_PROFILE_KEY };

// =============================================================================
// SaveGame ìŠ¤í‚¤ë§ˆ ì •ì˜
// =============================================================================

/**
 * SaveGame Zod ìŠ¤í‚¤ë§ˆ.
 * ìµœì†Œ í•„ë“œë§Œ í¬í•¨í•˜ì—¬ MVP ìš”êµ¬ì‚¬í•­ì„ ì¶©ì¡±í•©ë‹ˆë‹¤.
 */
export const SaveGameSchema = z
  .object({
    /** ìŠ¤í‚¤ë§ˆ ë²„ì „ (ë§ˆì´ê·¸ë ˆì´ì…˜ìš©) */
    version: z.string().describe('SaveGame ìŠ¤í‚¤ë§ˆ ë²„ì „'),
    /** ì„¸ì…˜ ì‹œë“œ (ë¦¬í”Œë ˆì´ ì¬í˜„ìš©, ì„ íƒ) */
    seed: z.string().nullable().default(null).describe('ì„¸ì…˜ ì‹œë“œ'),
    /** ì–¸ì–´ ì„¤ì • (RULE-006: ë³µì› ì‹œ UI i18nì—ë„ ì ìš©) */
    language: z.enum(['ko-KR', 'en-US']).describe('ì–¸ì–´ ì„¤ì •'),
    /** ì‚¬ìš©ëœ ë°ëª¨ í”„ë¡œí•„ ID */
    profileId: z.string().nullable().default(null).describe('ë°ëª¨ í”„ë¡œí•„ ID'),
    /** ì €ì¥ ì‹œê° (ISO 8601) */
    savedAt: z.string().describe('ì €ì¥ ì‹œê°'),

    /** ì¬í™” ìƒíƒœ */
    economy: z
      .object({
        signal: z.number().int().min(0),
        memory_shard: z.number().int().min(0),
      })
      .describe('ì¬í™” ìƒíƒœ'),

    /** ê²½ì œ ì›ì¥ ì´ë ¥ */
    economyLedger: z
      .array(
        z.object({
          turnId: z.number().int(),
          actionId: z.string().optional(),
          reason: z.string(),
          cost: z.object({
            signal: z.number().int().min(0),
            memory_shard: z.number().int().min(0),
          }),
          balanceAfter: z.object({
            signal: z.number().int().min(0),
            memory_shard: z.number().int().min(0),
          }),
          modelLabel: z.enum(['FAST', 'QUALITY', 'CHEAP', 'REF']).optional(),
          timestamp: z.number(),
        }),
      )
      .default([])
      .describe('ê²½ì œ ì›ì¥ ì´ë ¥'),

    /** í˜„ì¬ í„´ ì¹´ìš´íŠ¸ */
    turnCount: z.number().int().min(0).default(0).describe('í˜„ì¬ í„´ ì¹´ìš´íŠ¸'),

    /** ë‚´ëŸ¬í‹°ë¸Œ íˆìŠ¤í† ë¦¬ */
    narrativeHistory: z
      .array(
        z.object({
          turn: z.number().int(),
          text: z.string(),
        }),
      )
      .default([])
      .describe('ë‚´ëŸ¬í‹°ë¸Œ íˆìŠ¤í† ë¦¬'),

    /** ì¸ë²¤í† ë¦¬ ì•„ì´í…œ */
    inventory: z
      .array(
        z.object({
          id: z.string(),
          name: z.string(),
          description: z.string().optional(),
          icon: z.string().optional(),
          quantity: z.number().int().min(1),
        }),
      )
      .default([])
      .describe('ì¸ë²¤í† ë¦¬ ì•„ì´í…œ'),

    /** í™œì„± í€˜ìŠ¤íŠ¸ */
    quests: z
      .array(
        z.object({
          id: z.string(),
          label: z.string(),
          is_completed: z.boolean().default(false),
        }),
      )
      .default([])
      .describe('í™œì„± í€˜ìŠ¤íŠ¸'),

    /** í™œì„± ê·œì¹™ */
    activeRules: z
      .array(
        z.object({
          id: z.string(),
          label: z.string(),
          description: z.string().nullable().default(null),
        }),
      )
      .default([])
      .describe('í™œì„± ê·œì¹™'),

    /** ë£° ë³€í˜• íƒ€ì„ë¼ì¸ */
    mutationTimeline: z
      .array(
        z.object({
          turn: z.number().int(),
          ruleId: z.string(),
          type: z.enum(['added', 'modified', 'removed']),
          label: z.string(),
          description: z.string().optional(),
          timestamp: z.number(),
        }),
      )
      .default([])
      .describe('ë£° ë³€í˜• íƒ€ì„ë¼ì¸'),

    /** Scene Objects (í•«ìŠ¤íŒŸ) */
    sceneObjects: z
      .array(
        z.object({
          id: z.string(),
          label: z.string(),
          box_2d: z.object({
            ymin: z.number().int().min(0).max(1000),
            xmin: z.number().int().min(0).max(1000),
            ymax: z.number().int().min(0).max(1000),
            xmax: z.number().int().min(0).max(1000),
          }),
          interaction_hint: z.string().nullable().default(null),
        }),
      )
      .default([])
      .describe('Scene Objects'),
  })
  .strict();

export type SaveGame = z.infer<typeof SaveGameSchema>;

// =============================================================================
// ì €ì¥/ë³µì› í•¨ìˆ˜
// =============================================================================

/**
 * SaveGame ì¸í„°í˜ì´ìŠ¤ (ì €ì¥í•  ìƒíƒœ ì „ì²´ë¥¼ ìº¡ì²˜).
 */
export interface SaveGameInput {
  language: SupportedLanguage;
  profileId?: string | null;
  seed?: string | null;
  economy: EconomyState;
  economyLedger: LedgerEntry[];
  turnCount: number;
  narrativeHistory: NarrativeEntry[];
  inventory: InventoryItem[];
  quests: Quest[];
  activeRules: WorldRule[];
  mutationTimeline: MutationEvent[];
  sceneObjects: SceneObject[];
}

/**
 * í˜„ì¬ ìƒíƒœë¥¼ SaveGame ê°ì²´ë¡œ ì§ë ¬í™”í•©ë‹ˆë‹¤.
 */
export function createSaveGame(input: SaveGameInput): SaveGame {
  return {
    version: SAVEGAME_VERSION,
    seed: input.seed ?? null,
    language: input.language,
    profileId: input.profileId ?? null,
    savedAt: new Date().toISOString(),
    economy: {
      signal: input.economy.signal,
      memory_shard: input.economy.memory_shard,
    },
    economyLedger: input.economyLedger.map((entry) => ({
      turnId: entry.turnId,
      actionId: entry.actionId,
      reason: entry.reason,
      cost: {
        signal: entry.cost.signal,
        memory_shard: entry.cost.memory_shard,
      },
      balanceAfter: {
        signal: entry.balanceAfter.signal,
        memory_shard: entry.balanceAfter.memory_shard,
      },
      modelLabel: entry.modelLabel,
      timestamp: entry.timestamp,
    })),
    turnCount: input.turnCount,
    narrativeHistory: input.narrativeHistory.map((entry) => ({
      turn: entry.turn,
      text: entry.text,
    })),
    inventory: input.inventory.map((item) => ({
      id: item.id,
      name: item.name,
      description: item.description,
      icon: item.icon,
      quantity: item.quantity,
    })),
    quests: input.quests.map((quest) => ({
      id: quest.id,
      label: quest.label,
      is_completed: quest.is_completed,
    })),
    activeRules: input.activeRules.map((rule) => ({
      id: rule.id,
      label: rule.label,
      description: rule.description,
    })),
    mutationTimeline: input.mutationTimeline.map((event) => ({
      turn: event.turn,
      ruleId: event.ruleId,
      type: event.type,
      label: event.label,
      description: event.description,
      timestamp: event.timestamp,
    })),
    sceneObjects: input.sceneObjects.map((obj) => ({
      id: obj.id,
      label: obj.label,
      box_2d: {
        ymin: obj.box_2d.ymin,
        xmin: obj.box_2d.xmin,
        ymax: obj.box_2d.ymax,
        xmax: obj.box_2d.xmax,
      },
      interaction_hint: obj.interaction_hint,
    })),
  };
}

/**
 * SaveGameì„ localStorageì— ì €ì¥í•©ë‹ˆë‹¤.
 *
 * @returns ì €ì¥ ì„±ê³µ ì—¬ë¶€
 */
export function saveSaveGame(saveGame: SaveGame): boolean {
  try {
    const json = JSON.stringify(saveGame);
    localStorage.setItem(SAVEGAME_STORAGE_KEY, json);
    return true;
  } catch (error) {
    console.error('[SaveGame] ì €ì¥ ì‹¤íŒ¨:', error);
    return false;
  }
}

/**
 * localStorageì—ì„œ SaveGameì„ ë¡œë“œí•©ë‹ˆë‹¤.
 *
 * U-041: "ë²„ì „ íŒë³„ â†’ ë§ˆì´ê·¸ë ˆì´ì…˜ â†’ ê²€ì¦" íë¦„ìœ¼ë¡œ ë³€ê²½
 * - êµ¬ë²„ì „ SaveGameë„ ë§ˆì´ê·¸ë ˆì´ì…˜ í›„ ìµœì‹  ìŠ¤í‚¤ë§ˆë¥¼ í†µê³¼í•  ìˆ˜ ìˆìŒ
 * - ìŠ¤í‚¤ë§ˆ ê²€ì¦ì€ ë§ˆì´ê·¸ë ˆì´ì…˜ ì™„ë£Œ í›„ ìˆ˜í–‰
 *
 * @returns SaveGame ê°ì²´ ë˜ëŠ” null (ì—†ê±°ë‚˜ ìœ íš¨í•˜ì§€ ì•Šì€ ê²½ìš°)
 */
export function loadSaveGame(): SaveGame | null {
  try {
    const json = localStorage.getItem(SAVEGAME_STORAGE_KEY);
    if (!json) {
      return null;
    }

    // Step 1: JSON íŒŒì‹±
    let parsed: unknown;
    try {
      parsed = JSON.parse(json);
    } catch {
      console.warn('[SaveGame] JSON íŒŒì‹± ì‹¤íŒ¨');
      return null;
    }

    // Step 2: ë²„ì „ ì¶”ì¶œ (U-041: ìµœì†Œ íŒŒì„œë¡œ ë²„ì „ë§Œ ë¨¼ì € í™•ì¸)
    const version = extractVersion(parsed);
    if (!version) {
      console.warn('[SaveGame] ë²„ì „ ì •ë³´ ì—†ìŒ');
      return null;
    }

    // Step 3: ë§ˆì´ê·¸ë ˆì´ì…˜ ìˆ˜í–‰ (ë²„ì „ ë¶ˆì¼ì¹˜ ì‹œ)
    let dataToValidate: unknown = parsed;

    if (version !== SAVEGAME_VERSION) {
      // ë§ˆì´ê·¸ë ˆì´ì…˜ ì‹œë„
      const migrationResult = migrateSaveGame(parsed, version);
      if (!migrationResult) {
        console.warn('[SaveGame] ë§ˆì´ê·¸ë ˆì´ì…˜ ì‹¤íŒ¨, ìƒˆë¡œ ì‹œì‘ í•„ìš”');
        return null;
      }
      dataToValidate = migrationResult;
    }

    // Step 4: ìµœì¢… ìŠ¤í‚¤ë§ˆ ê²€ì¦ (ë§ˆì´ê·¸ë ˆì´ì…˜ í›„)
    const result = SaveGameSchema.safeParse(dataToValidate);
    if (!result.success) {
      console.warn('[SaveGame] ìŠ¤í‚¤ë§ˆ ê²€ì¦ ì‹¤íŒ¨:', result.error);
      return null;
    }

    return result.data;
  } catch (error) {
    console.error('[SaveGame] ë¡œë“œ ì‹¤íŒ¨:', error);
    return null;
  }
}

/**
 * ì €ì¥ëœ SaveGameì„ ì‚­ì œí•©ë‹ˆë‹¤.
 */
export function clearSaveGame(): void {
  try {
    localStorage.removeItem(SAVEGAME_STORAGE_KEY);
  } catch (error) {
    console.error('[SaveGame] ì‚­ì œ ì‹¤íŒ¨:', error);
  }
}

/**
 * SaveGameì´ ì¡´ì¬í•˜ëŠ”ì§€ í™•ì¸í•©ë‹ˆë‹¤.
 *
 * @deprecated RU-004-S2: ì´ í•¨ìˆ˜ëŠ” í‚¤ ì¡´ì¬ë§Œ í™•ì¸í•˜ë¯€ë¡œ "ìœ íš¨í•œ ì„¸ì´ë¸Œ" íŒë‹¨ì— ë¶€ì í•©í•©ë‹ˆë‹¤.
 *             ëŒ€ì‹  `getValidSaveGameOrNull()`ì„ ì‚¬ìš©í•˜ì„¸ìš”.
 */
export function hasSaveGame(): boolean {
  try {
    return localStorage.getItem(SAVEGAME_STORAGE_KEY) !== null;
  } catch {
    return false;
  }
}

/**
 * ìœ íš¨í•œ SaveGameì„ ë°˜í™˜í•©ë‹ˆë‹¤. ì—†ê±°ë‚˜ ê²€ì¦/ë§ˆì´ê·¸ë ˆì´ì…˜ ì‹¤íŒ¨ ì‹œ nullì„ ë°˜í™˜í•©ë‹ˆë‹¤ (RU-004-S2).
 *
 * `hasSaveGame()` ëŒ€ì‹  ì´ í•¨ìˆ˜ë¥¼ ì‚¬ìš©í•˜ë©´ "Continue ë²„íŠ¼ ë…¸ì¶œ" íŒë‹¨ì´ ì •í™•í•´ì§‘ë‹ˆë‹¤:
 * - localStorageì— ë°ì´í„°ê°€ ìˆì–´ë„ ìŠ¤í‚¤ë§ˆ ê²€ì¦ ì‹¤íŒ¨ ì‹œ null ë°˜í™˜
 * - ë²„ì „ ë¶ˆì¼ì¹˜ë¡œ ë§ˆì´ê·¸ë ˆì´ì…˜ ì‹¤íŒ¨ ì‹œ null ë°˜í™˜
 *
 * @returns ìœ íš¨í•œ SaveGame ë˜ëŠ” null
 */
export function getValidSaveGameOrNull(): SaveGame | null {
  return loadSaveGame();
}

// =============================================================================
// í”„ë¡œí•„ ê´€ë ¨ ìœ í‹¸ë¦¬í‹°
// =============================================================================

/**
 * í˜„ì¬ ì„ íƒëœ í”„ë¡œí•„ IDë¥¼ ì €ì¥í•©ë‹ˆë‹¤.
 */
export function saveCurrentProfileId(profileId: string): void {
  try {
    localStorage.setItem(CURRENT_PROFILE_KEY, profileId);
  } catch (error) {
    console.error('[SaveGame] í”„ë¡œí•„ ID ì €ì¥ ì‹¤íŒ¨:', error);
  }
}

/**
 * í˜„ì¬ ì„ íƒëœ í”„ë¡œí•„ IDë¥¼ ë¡œë“œí•©ë‹ˆë‹¤.
 */
export function loadCurrentProfileId(): string | null {
  try {
    return localStorage.getItem(CURRENT_PROFILE_KEY);
  } catch {
    return null;
  }
}

/**
 * í˜„ì¬ ì„ íƒëœ í”„ë¡œí•„ IDë¥¼ ì‚­ì œí•©ë‹ˆë‹¤.
 */
export function clearCurrentProfileId(): void {
  try {
    localStorage.removeItem(CURRENT_PROFILE_KEY);
  } catch (error) {
    console.error('[SaveGame] í”„ë¡œí•„ ID ì‚­ì œ ì‹¤íŒ¨:', error);
  }
}

// =============================================================================
// ë²„ì „ ë§ˆì´ê·¸ë ˆì´ì…˜ (U-041)
// =============================================================================

/**
 * SaveGame ë°ì´í„°ë¥¼ ìµœì‹  ë²„ì „ìœ¼ë¡œ ë§ˆì´ê·¸ë ˆì´ì…˜í•©ë‹ˆë‹¤.
 *
 * U-041: migrations.tsì˜ upgradeToLatestë¥¼ ì‚¬ìš©í•˜ì—¬ ë²„ì „ë³„ ë³€í™˜ ìˆ˜í–‰
 *
 * @param data - ë§ˆì´ê·¸ë ˆì´ì…˜í•  SaveGame ë°ì´í„° (unknown - ìŠ¤í‚¤ë§ˆ ê²€ì¦ ì „)
 * @param version - í˜„ì¬ ë°ì´í„°ì˜ ë²„ì „
 * @returns ë§ˆì´ê·¸ë ˆì´ì…˜ëœ ë°ì´í„° ë˜ëŠ” null (ë§ˆì´ê·¸ë ˆì´ì…˜ ë¶ˆê°€)
 */
export function migrateSaveGame(data: unknown, version: string): unknown | null {
  // í˜„ì¬ ë²„ì „ì´ë©´ ê·¸ëŒ€ë¡œ ë°˜í™˜
  if (version === SAVEGAME_VERSION) {
    return data;
  }

  // ë§ˆì´ê·¸ë ˆì´ì…˜ ê°€ëŠ¥í•œ ë²„ì „ì¸ì§€ í™•ì¸
  if (!isMigratableVersion(version)) {
    console.warn(`[SaveGame] ì§€ì›í•˜ì§€ ì•ŠëŠ” ë²„ì „: ${version}`);
    return null;
  }

  // ë§ˆì´ê·¸ë ˆì´ì…˜ ìˆ˜í–‰
  console.log(`[SaveGame] ë§ˆì´ê·¸ë ˆì´ì…˜ ì‹œì‘: ${version} â†’ ${SAVEGAME_VERSION}`);
  const result = upgradeToLatest(data, version);

  if (!result.success) {
    console.warn(`[SaveGame] ë§ˆì´ê·¸ë ˆì´ì…˜ ì‹¤íŒ¨: ${result.error}`);
    return null;
  }

  // ì„±ê³µ ë¡œê·¸
  const migrationResult = result as MigrationResult;
  console.log(`[SaveGame] ë§ˆì´ê·¸ë ˆì´ì…˜ ì™„ë£Œ: ${migrationResult.appliedMigrations.join(' â†’ ')}`);

  return migrationResult.data;
}

/**
 * @deprecated U-041: ì´ì „ ë²„ì „ í˜¸í™˜ì„±ì„ ìœ„í•œ ë˜í¼.
 *             ìƒˆ ì½”ë“œì—ì„œëŠ” migrateSaveGame(data, version)ì„ ì§ì ‘ ì‚¬ìš©í•˜ì„¸ìš”.
 *
 * SaveGame íƒ€ì…ì´ ì´ë¯¸ í™•ì •ëœ ê²½ìš° (ìµœì‹  ìŠ¤í‚¤ë§ˆë¡œ ê²€ì¦ëœ ê²½ìš°)ì—ë§Œ ì‚¬ìš©í•©ë‹ˆë‹¤.
 */
export function migrateSaveGameLegacy(saveGame: SaveGame): SaveGame | null {
  if (saveGame.version === SAVEGAME_VERSION) {
    return saveGame;
  }
  // ì´ë¯¸ SaveGame íƒ€ì…ì´ë©´ ìµœì‹  ìŠ¤í‚¤ë§ˆë¥¼ í†µê³¼í•œ ê²ƒì´ë¯€ë¡œ ë²„ì „ë§Œ ì²´í¬
  console.warn(`[SaveGame] ë²„ì „ ë¶ˆì¼ì¹˜ (legacy): ${saveGame.version}`);
  return null;
}
</file>

<file path="frontend/src/stores/worldStore.ts">
/**
 * Unknown World - World/Session ìƒíƒœ ê´€ë¦¬ (Zustand) (RU-003-Q4).
 *
 * TurnOutput ë°˜ì˜ìœ¼ë¡œ ê°±ì‹ ë˜ëŠ” ì„¸ì…˜ ì›”ë“œ/UI ìƒíƒœë¥¼ SSOTë¡œ ê´€ë¦¬í•©ë‹ˆë‹¤.
 * App.tsxì˜ ë¡œì»¬ ìƒíƒœë¥¼ ì´ ìŠ¤í† ì–´ë¡œ ì´ë™í•˜ì—¬ ì±…ì„ ê²½ê³„ë¥¼ ëª…í™•íˆ í•©ë‹ˆë‹¤.
 *
 * ì„¤ê³„ ì›ì¹™:
 *   - RU-003 Q1 ê²°ì •: ë„ë©”ì¸ë³„ store ë¶„ë¦¬ (Option A)
 *   - RULE-005: Economy ì¸ë°”ë¦¬ì–¸íŠ¸ (ì”ì•¡ ìŒìˆ˜ ê¸ˆì§€)
 *   - RULE-006: ko/en i18n ì •ì±… ì¤€ìˆ˜
 *
 * í™•ì¥ (U-013):
 *   - Quest/Rules/MutationEvent ìƒíƒœ ì¶”ê°€
 *   - applyTurnOutputì—ì„œ quests_updated, rules_changed ë°˜ì˜
 *
 * ìˆœí™˜ import ë°©ì§€:
 *   - worldStore â†’ (actionDeckStore/inventoryStore) ë‹¨ë°©í–¥ë§Œ í—ˆìš©
 *   - ì—­ë°©í–¥ import ê¸ˆì§€
 *
 * @module stores/worldStore
 */

import { create } from 'zustand';
import type { TurnOutput, SceneObject, Quest, WorldRule } from '../schemas/turn';
import type { SceneCanvasState } from '../types/scene';
import { useActionDeckStore } from './actionDeckStore';
import { useInventoryStore, parseInventoryAdded } from './inventoryStore';
import { useEconomyStore } from './economyStore';

// =============================================================================
// íƒ€ì… ì •ì˜
// =============================================================================

/** ì¬í™” ìƒíƒœ */
export interface EconomyState {
  signal: number;
  memory_shard: number;
}

/** ë‚´ëŸ¬í‹°ë¸Œ ì—”íŠ¸ë¦¬ */
export interface NarrativeEntry {
  turn: number;
  text: string;
}

/**
 * ë£° ë³€í˜• ì´ë²¤íŠ¸ (U-013: Mutation Timeline)
 * ê·œì¹™ì´ ë³€ê²½ëœ ì‹œì ê³¼ ë‚´ìš©ì„ ê¸°ë¡í•©ë‹ˆë‹¤.
 */
export interface MutationEvent {
  /** ë³€í˜• ë°œìƒ í„´ */
  turn: number;
  /** ë³€í˜•ëœ ê·œì¹™ ID */
  ruleId: string;
  /** ë³€í˜• ìœ í˜•: ì¶”ê°€/ìˆ˜ì •/ì œê±° */
  type: 'added' | 'modified' | 'removed';
  /** ê·œì¹™ ë¼ë²¨ (í‘œì‹œìš©) */
  label: string;
  /** ê·œì¹™ ì„¤ëª… (ì„ íƒ) */
  description?: string;
  /** íƒ€ì„ìŠ¤íƒ¬í”„ */
  timestamp: number;
}

/** World/Session ìƒíƒœ */
export interface WorldState {
  /** ì¬í™” ìƒíƒœ (RULE-005) */
  economy: EconomyState;
  /** ì—°ê²° ìƒíƒœ */
  isConnected: boolean;
  /** Scene Canvas ìƒíƒœ (U-031) */
  sceneState: SceneCanvasState;
  /** Scene Objects (U-010: í•«ìŠ¤íŒŸ ì˜¤ë²„ë ˆì´) */
  sceneObjects: SceneObject[];
  /** ë‚´ëŸ¬í‹°ë¸Œ íˆìŠ¤í† ë¦¬ */
  narrativeEntries: NarrativeEntry[];
  /** í˜„ì¬ í„´ ì¹´ìš´íŠ¸ */
  turnCount: number;

  // ============ U-013: Quest + Rule Board í™•ì¥ ============

  /** í˜„ì¬ í€˜ìŠ¤íŠ¸/ëª©í‘œ ëª©ë¡ */
  quests: Quest[];
  /** í˜„ì¬ ì ìš© ì¤‘ì¸ ê·œì¹™ ëª©ë¡ */
  activeRules: WorldRule[];
  /** ë£° ë³€í˜• ì´ë²¤íŠ¸ íƒ€ì„ë¼ì¸ (ìµœì‹ ìˆœ) */
  mutationTimeline: MutationEvent[];
}

/** World Store ì•¡ì…˜ */
export interface WorldActions {
  /**
   * TurnOutputì„ ë°›ì•„ ëª¨ë“  ê´€ë ¨ ìƒíƒœë¥¼ ì—…ë°ì´íŠ¸í•©ë‹ˆë‹¤.
   * ì´ ë©”ì„œë“œê°€ TurnOutput ë°˜ì˜ì˜ SSOTì…ë‹ˆë‹¤.
   */
  applyTurnOutput: (output: TurnOutput) => void;

  /**
   * ì‹œìŠ¤í…œ ë‚´ëŸ¬í‹°ë¸Œë¥¼ ì¶”ê°€í•©ë‹ˆë‹¤ (í„´ ë¯¸ë°œìƒ í”¼ë“œë°±ìš©).
   * ë“œë¡­ ì‹¤íŒ¨ ë“± í„´ì„ ë°œìƒì‹œí‚¤ì§€ ì•ŠëŠ” í”¼ë“œë°±ì— ì‚¬ìš©í•©ë‹ˆë‹¤.
   */
  appendSystemNarrative: (text: string) => void;

  /** Scene ìƒíƒœ ì„¤ì • */
  setSceneState: (state: SceneCanvasState) => void;

  /** ì—°ê²° ìƒíƒœ ì„¤ì • */
  setConnected: (connected: boolean) => void;

  /** ê²½ì œ ìƒíƒœ ì„¤ì • (ì§ì ‘ ì¡°ì‘ìš©, ì¼ë°˜ì ìœ¼ë¡œ applyTurnOutput ì‚¬ìš©) */
  setEconomy: (economy: EconomyState) => void;

  /** Scene Objects ì„¤ì • (ì§ì ‘ ì¡°ì‘ìš©) */
  setSceneObjects: (objects: SceneObject[]) => void;

  /** ì´ˆê¸°í™” (ì´ˆê¸° ë‚´ëŸ¬í‹°ë¸Œ ë©”ì‹œì§€ í¬í•¨) */
  initialize: (welcomeMessage: string) => void;

  /** ìƒíƒœ ì™„ì „ ì´ˆê¸°í™” */
  reset: () => void;
}

export type WorldStore = WorldState & WorldActions;

// =============================================================================
// ì´ˆê¸° ìƒíƒœ
// =============================================================================

/**
 * ì´ˆê¸° ìƒíƒœë¥¼ ìƒì„±í•©ë‹ˆë‹¤.
 *
 * RU-004-Q5: ì´ˆê¸°ê°’ ì •ì±… SSOT
 *
 * ## ì¤‘ìš”: ì´ ê°’ë“¤ì€ "í”Œë ˆì´ ì „ placeholder"ì…ë‹ˆë‹¤.
 *
 * ì‹¤ì œ ê²Œì„ ì‹œì‘ ê°’ì€ í•­ìƒ ë‹¤ìŒ ì¤‘ í•˜ë‚˜ì—ì„œ ì£¼ì…ë©ë‹ˆë‹¤:
 * 1. í”„ë¡œí•„ ì´ˆê¸° SaveGame (startSessionFromProfile)
 * 2. ì €ì¥ëœ SaveGame ë³µì› (continueSession)
 *
 * profile_select ìƒíƒœì—ì„œëŠ” HUDê°€ ë…¸ì¶œë˜ì§€ ì•Šìœ¼ë¯€ë¡œ
 * ì´ placeholder ê°’ì´ í™”ë©´ì— í‘œì‹œë  ì¼ì€ ì—†ìŠµë‹ˆë‹¤.
 *
 * @see save/constants.ts#INITIAL_VALUE_POLICY
 * @see save/sessionLifecycle.ts
 */
function createInitialState(): WorldState {
  return {
    // RU-004-Q5: Placeholder - ì‹¤ì œ ê°’ì€ í”„ë¡œí•„/ì„¸ì´ë¸Œì—ì„œ ì£¼ì…ë¨
    economy: { signal: 100, memory_shard: 5 },
    isConnected: true,
    sceneState: { status: 'default', message: '' },
    sceneObjects: [],
    narrativeEntries: [],
    turnCount: 0,
    // U-013: Quest + Rule Board ì´ˆê¸° ìƒíƒœ
    quests: [],
    activeRules: [],
    mutationTimeline: [],
  };
}

// =============================================================================
// Zustand Store
// =============================================================================

/**
 * World/Session ìƒíƒœ ìŠ¤í† ì–´.
 *
 * TurnOutput ë°˜ì˜ì˜ SSOTë¡œ, App.tsxì˜ ë¡œì»¬ ìƒíƒœë¥¼ ëŒ€ì²´í•©ë‹ˆë‹¤.
 *
 * @example
 * ```tsx
 * // ì»´í¬ë„ŒíŠ¸ì—ì„œ ìƒíƒœ êµ¬ë…
 * const { economy, narrativeEntries } = useWorldStore();
 *
 * // TurnOutput ë°˜ì˜ (ìŠ¤íŠ¸ë¦¼ ì™„ë£Œ ì‹œ)
 * const applyTurnOutput = useWorldStore((state) => state.applyTurnOutput);
 * applyTurnOutput(turnOutput);
 *
 * // ì‹œìŠ¤í…œ í”¼ë“œë°± ì¶”ê°€ (ë“œë¡­ ì‹¤íŒ¨ ë“±)
 * const appendSystemNarrative = useWorldStore((state) => state.appendSystemNarrative);
 * appendSystemNarrative('ì•„ì´í…œì„ ì‚¬ìš©í•  ìˆ˜ ì—†ìŠµë‹ˆë‹¤.');
 * ```
 */
export const useWorldStore = create<WorldStore>((set, get) => ({
  // ì´ˆê¸° ìƒíƒœ
  ...createInitialState(),

  // ì•¡ì…˜

  applyTurnOutput: (output) => {
    const state = get();

    // 1. í„´ ì¹´ìš´íŠ¸ ì¦ê°€
    const newTurnCount = state.turnCount + 1;

    // 2. ë‚´ëŸ¬í‹°ë¸Œ ì¶”ê°€
    const newNarrativeEntry: NarrativeEntry = {
      turn: newTurnCount,
      text: output.narrative,
    };

    // 3. ê²½ì œ ìƒíƒœ ì—…ë°ì´íŠ¸ (RULE-005: balance_after ë°˜ì˜)
    const newEconomy: EconomyState = {
      signal: output.economy.balance_after.signal,
      memory_shard: output.economy.balance_after.memory_shard,
    };

    // 4. Scene Objects ì—…ë°ì´íŠ¸ (U-010: í•«ìŠ¤íŒŸ ì˜¤ë²„ë ˆì´)
    const newSceneObjects = output.ui.objects;

    // 5. Scene ìƒíƒœ ì „ì´ (RU-003-T1: Scene ì´ë¯¸ì§€ SSOT)
    // - output.ui.scene.image_urlì´ ì¡´ì¬í•˜ë©´ 'scene' ìƒíƒœë¡œ ì „í™˜
    // - ì—†ìœ¼ë©´ 'default' ìƒíƒœ ìœ ì§€
    // - safety.blockedì¸ ê²½ìš° 'blocked' ìƒíƒœë¡œ ì „í™˜
    let newSceneState: SceneCanvasState;
    if (output.safety.blocked) {
      newSceneState = {
        status: 'blocked',
        message: output.safety.message ?? undefined,
      };
    } else if (output.ui.scene?.image_url) {
      newSceneState = {
        status: 'scene',
        imageUrl: output.ui.scene.image_url,
        message: output.ui.scene.alt_text ?? undefined,
      };
    } else {
      newSceneState = {
        status: 'default',
        message: '',
      };
    }

    // 7. í•˜ìœ„ ìŠ¤í† ì–´ ì—…ë°ì´íŠ¸ (ìˆœí™˜ import ë°©ì§€: worldStore â†’ í•˜ìœ„ store ë‹¨ë°©í–¥)
    // Action Deck ì¹´ë“œ ì—…ë°ì´íŠ¸ (U-009)
    useActionDeckStore.getState().setCards(output.ui.action_deck.cards);

    // Inventory ì—…ë°ì´íŠ¸ (U-011)
    if (output.world.inventory_added.length > 0) {
      useInventoryStore.getState().addItems(parseInventoryAdded(output.world.inventory_added));
    }
    if (output.world.inventory_removed.length > 0) {
      useInventoryStore.getState().removeItems(output.world.inventory_removed);
    }

    // Economy Store ì—…ë°ì´íŠ¸ (U-014: Ledger ê¸°ë¡)
    const economyStore = useEconomyStore.getState();
    economyStore.addLedgerEntry({
      turnId: newTurnCount,
      reason: output.narrative.slice(0, 50), // ë‚´ëŸ¬í‹°ë¸Œ ì• 50ìë¥¼ ì‚¬ìœ ë¡œ ì‚¬ìš©
      cost: output.economy.cost,
      balanceAfter: output.economy.balance_after,
      modelLabel: output.agent_console.badges.includes('schema_ok') ? 'QUALITY' : 'FAST',
    });
    // ì”ì•¡ ë¶€ì¡± ìƒíƒœ ì—…ë°ì´íŠ¸
    economyStore.updateBalanceLowStatus(newEconomy);

    // 6. Quest ìƒíƒœ ì—…ë°ì´íŠ¸ (U-013)
    // quests_updatedëŠ” ì „ì²´ í€˜ìŠ¤íŠ¸ ëª©ë¡ì´ ì•„ë‹Œ "ì—…ë°ì´íŠ¸ëœ" í€˜ìŠ¤íŠ¸ë§Œ í¬í•¨
    // ê¸°ì¡´ í€˜ìŠ¤íŠ¸ë¥¼ ì—…ë°ì´íŠ¸í•˜ê±°ë‚˜ ìƒˆ í€˜ìŠ¤íŠ¸ë¥¼ ì¶”ê°€
    const newQuests = [...state.quests];
    for (const updatedQuest of output.world.quests_updated) {
      const existingIndex = newQuests.findIndex((q) => q.id === updatedQuest.id);
      if (existingIndex >= 0) {
        // ê¸°ì¡´ í€˜ìŠ¤íŠ¸ ì—…ë°ì´íŠ¸
        newQuests[existingIndex] = updatedQuest;
      } else {
        // ìƒˆ í€˜ìŠ¤íŠ¸ ì¶”ê°€
        newQuests.push(updatedQuest);
      }
    }

    // 7. Rules ìƒíƒœ ì—…ë°ì´íŠ¸ + Mutation Timeline ê¸°ë¡ (U-013)
    const newActiveRules = [...state.activeRules];
    const newMutationEvents: MutationEvent[] = [];
    const now = Date.now();

    for (const changedRule of output.world.rules_changed) {
      const existingIndex = newActiveRules.findIndex((r) => r.id === changedRule.id);
      if (existingIndex >= 0) {
        // ê¸°ì¡´ ê·œì¹™ ìˆ˜ì •
        newActiveRules[existingIndex] = changedRule;
        newMutationEvents.push({
          turn: newTurnCount,
          ruleId: changedRule.id,
          type: 'modified',
          label: changedRule.label,
          description: changedRule.description ?? undefined,
          timestamp: now,
        });
      } else {
        // ìƒˆ ê·œì¹™ ì¶”ê°€
        newActiveRules.push(changedRule);
        newMutationEvents.push({
          turn: newTurnCount,
          ruleId: changedRule.id,
          type: 'added',
          label: changedRule.label,
          description: changedRule.description ?? undefined,
          timestamp: now,
        });
      }
    }

    // íƒ€ì„ë¼ì¸ì— ìƒˆ ì´ë²¤íŠ¸ ì¶”ê°€ (ìµœì‹ ìˆœ ì •ë ¬)
    const updatedTimeline = [...newMutationEvents, ...state.mutationTimeline];

    // 8. ìƒíƒœ ì—…ë°ì´íŠ¸ (RU-003-T1: sceneState í¬í•¨, U-013: quest/rules)
    set({
      turnCount: newTurnCount,
      narrativeEntries: [...state.narrativeEntries, newNarrativeEntry],
      economy: newEconomy,
      sceneObjects: newSceneObjects,
      sceneState: newSceneState,
      // U-013 í™•ì¥
      quests: newQuests,
      activeRules: newActiveRules,
      mutationTimeline: updatedTimeline,
    });

    // === í–¥í›„ í™•ì¥ ìŠ¬ë¡¯ (RU-003-Q4 Step 4) ===
    // TODO: output.world.memory_pins â†’ Memory Pin íŒ¨ë„ ì—…ë°ì´íŠ¸
  },

  appendSystemNarrative: (text) => {
    set((state) => ({
      narrativeEntries: [
        ...state.narrativeEntries,
        {
          turn: state.turnCount, // í˜„ì¬ í„´ìœ¼ë¡œ ê¸°ë¡ (í„´ ì¦ê°€ ì—†ìŒ)
          text,
        },
      ],
    }));
  },

  setSceneState: (sceneState) => {
    set({ sceneState });
  },

  setConnected: (isConnected) => {
    set({ isConnected });
  },

  setEconomy: (economy) => {
    set({ economy });
  },

  setSceneObjects: (sceneObjects) => {
    set({ sceneObjects });
  },

  initialize: (welcomeMessage) => {
    set({
      ...createInitialState(),
      narrativeEntries: [{ turn: 0, text: welcomeMessage }],
    });
  },

  reset: () => {
    set(createInitialState());
  },
}));

// =============================================================================
// ì…€ë ‰í„° (ì„±ëŠ¥ ìµœì í™”ìš©)
// =============================================================================

/** ê²½ì œ ìƒíƒœ ì…€ë ‰í„° */
export const selectEconomy = (state: WorldStore) => state.economy;

/** Signal ì”ì•¡ ì…€ë ‰í„° */
export const selectSignal = (state: WorldStore) => state.economy.signal;

/** Memory Shard ì”ì•¡ ì…€ë ‰í„° */
export const selectMemoryShard = (state: WorldStore) => state.economy.memory_shard;

/** ì—°ê²° ìƒíƒœ ì…€ë ‰í„° */
export const selectIsConnected = (state: WorldStore) => state.isConnected;

/** Scene ìƒíƒœ ì…€ë ‰í„° */
export const selectSceneState = (state: WorldStore) => state.sceneState;

/** Scene Objects ì…€ë ‰í„° */
export const selectSceneObjects = (state: WorldStore) => state.sceneObjects;

/** ë‚´ëŸ¬í‹°ë¸Œ ì—”íŠ¸ë¦¬ ì…€ë ‰í„° */
export const selectNarrativeEntries = (state: WorldStore) => state.narrativeEntries;

/** í„´ ì¹´ìš´íŠ¸ ì…€ë ‰í„° */
export const selectTurnCount = (state: WorldStore) => state.turnCount;

// ============ U-013: Quest + Rule Board ì…€ë ‰í„° ============

/** í€˜ìŠ¤íŠ¸ ëª©ë¡ ì…€ë ‰í„° */
export const selectQuests = (state: WorldStore) => state.quests;

/** í™œì„± ê·œì¹™ ëª©ë¡ ì…€ë ‰í„° */
export const selectActiveRules = (state: WorldStore) => state.activeRules;

/** ë®¤í…Œì´ì…˜ íƒ€ì„ë¼ì¸ ì…€ë ‰í„° */
export const selectMutationTimeline = (state: WorldStore) => state.mutationTimeline;

/** ì§„í–‰ ì¤‘ì¸ í€˜ìŠ¤íŠ¸ ì…€ë ‰í„° */
export const selectActiveQuests = (state: WorldStore) =>
  state.quests.filter((q) => !q.is_completed);

/** ì™„ë£Œëœ í€˜ìŠ¤íŠ¸ ì…€ë ‰í„° */
export const selectCompletedQuests = (state: WorldStore) =>
  state.quests.filter((q) => q.is_completed);
</file>

<file path="frontend/src/turn/turnRunner.ts">
/**
 * Unknown World - Turn Runner ëª¨ë“ˆ
 *
 * RU-003-Q3: Turn ì‹¤í–‰/ìŠ¤íŠ¸ë¦¬ë° ê²°í•©ì„ App.tsxì—ì„œ ë¶„ë¦¬í•˜ì—¬
 * "ë ˆì´ì•„ì›ƒ + ì´ë²¤íŠ¸ ë¼ìš°íŒ…"ê³¼ "ì˜¤ì¼€ìŠ¤íŠ¸ë ˆì´ì…˜"ì„ ëª…í™•íˆ ë¶„ë¦¬í•©ë‹ˆë‹¤.
 *
 * ì±…ì„:
 *   - TurnInput ìƒì„± (ì–¸ì–´/í´ë¦­/ë“œë¡­/í´ë¼ì´ì–¸íŠ¸ ì •ë³´/ì¬í™” ìŠ¤ëƒ…ìƒ·)
 *   - ìŠ¤íŠ¸ë¦¼ ì‹œì‘/ì·¨ì†Œ/ì½œë°± ë¼ìš°íŒ…
 *   - agentStore/worldStoreë¡œ ì´ë²¤íŠ¸ ë¶„ë°°
 *
 * ì„¤ê³„ ì›ì¹™:
 *   - RULE-002: ì±„íŒ… ì•±ì´ ì•„ë‹Œ ìƒíƒœ ê¸°ë°˜ ê²Œì„ ì‹œìŠ¤í…œ
 *   - RULE-003/004: êµ¬ì¡°í™” ì¶œë ¥ + ê²€ì¦/ë³µêµ¬
 *   - RULE-006: ko/en i18n ì •ì±… ì¤€ìˆ˜
 *
 * @module turn/turnRunner
 */

import type { TurnInput, DropInput, Language } from '../schemas/turn';
import type { HotspotClickData } from '../components/SceneCanvas';
import { startTurnStream, type StreamCallbacks } from '../api/turnStream';
import { useAgentStore } from '../stores/agentStore';
import { useWorldStore } from '../stores/worldStore';

// =============================================================================
// íƒ€ì… ì •ì˜
// =============================================================================

/** TurnInput ìƒì„±ì„ ìœ„í•œ íŒŒë¼ë¯¸í„° */
export interface BuildTurnInputParams {
  /** ì‚¬ìš©ì ì…ë ¥ í…ìŠ¤íŠ¸ */
  text: string;
  /** ì•¡ì…˜ ì¹´ë“œ ID (ì„ íƒ) */
  actionId?: string;
  /** í•«ìŠ¤íŒŸ í´ë¦­ ë°ì´í„° (U-010) */
  click?: HotspotClickData;
  /** ë“œë¡­ ë°ì´í„° (U-012) */
  drop?: DropInput;
  /** ì¬í™” ìŠ¤ëƒ…ìƒ· */
  economySnapshot: { signal: number; memory_shard: number };
  /** UI í…Œë§ˆ */
  theme: 'dark' | 'light';
  /** U-044: ì„¸ì…˜ ì–¸ì–´ (ì™¸ë¶€ ì£¼ì…, SSOT) */
  language: Language;
}

/** Turn ì‹¤í–‰ì„ ìœ„í•œ íŒŒë¼ë¯¸í„° (Appì—ì„œ í˜¸ì¶œ ì‹œ ì‚¬ìš©) */
export interface RunTurnParams {
  /** ì‚¬ìš©ì ì…ë ¥ í…ìŠ¤íŠ¸ */
  text: string;
  /** ì•¡ì…˜ ì¹´ë“œ ID (ì„ íƒ) */
  actionId?: string;
  /** í•«ìŠ¤íŒŸ í´ë¦­ ë°ì´í„° (U-010) */
  click?: HotspotClickData;
  /** ë“œë¡­ ë°ì´í„° (U-012) */
  drop?: DropInput;
}

/** Turn Runner ì¸í„°í˜ì´ìŠ¤ */
export interface TurnRunner {
  /** í„´ ì‹¤í–‰ (ìŠ¤íŠ¸ë¦¼ ì‹œì‘) */
  runTurn: (params: RunTurnParams) => void;
  /** ìŠ¤íŠ¸ë¦¼ ì·¨ì†Œ */
  cancel: () => void;
}

// =============================================================================
// TurnInput ìƒì„±
// =============================================================================

/**
 * TurnInputì„ ìƒì„±í•©ë‹ˆë‹¤.
 *
 * U-044: ì–¸ì–´ëŠ” ì™¸ë¶€ì—ì„œ ì£¼ì…ë°›ì•„ SSOT ìœ ì§€ (getResolvedLanguage() ì§ì ‘ í˜¸ì¶œ ì œê±°).
 * í´ë¦­, ë“œë¡­, í´ë¼ì´ì–¸íŠ¸ ì •ë³´, ì¬í™” ìŠ¤ëƒ…ìƒ·ì„ ì¡°í•©í•˜ì—¬
 * ì„œë²„ë¡œ ì „ì†¡í•  TurnInputì„ ìƒì„±í•©ë‹ˆë‹¤.
 */
export function buildTurnInput(params: BuildTurnInputParams): TurnInput {
  const { text, actionId, click, drop, economySnapshot, theme, language } = params;

  return {
    language,
    text,
    action_id: actionId ?? null,
    // U-010: í•«ìŠ¤íŒŸ í´ë¦­ ë°ì´í„° í¬í•¨ (Q1: Option B)
    click: click
      ? {
          object_id: click.object_id,
          box_2d: click.box_2d,
        }
      : null,
    // U-012: ì•„ì´í…œ ë“œë¡­ ë°ì´í„° í¬í•¨ (Q1: Option B - target_box_2d í¬í•¨)
    drop: drop ?? null,
    client: {
      viewport_w: window.innerWidth,
      viewport_h: window.innerHeight,
      theme,
    },
    economy_snapshot: economySnapshot,
  };
}

// =============================================================================
// Turn Runner ìƒì„±
// =============================================================================

/**
 * Turn Runnerë¥¼ ìƒì„±í•©ë‹ˆë‹¤.
 *
 * RU-003-Q3: Appì—ì„œ Turn Runner ì¸ìŠ¤í„´ìŠ¤ë¥¼ ìƒì„±í•˜ì—¬ ì‚¬ìš©í•©ë‹ˆë‹¤.
 * U-044: ì„¸ì…˜ ì–¸ì–´ë¥¼ ì™¸ë¶€ì—ì„œ ì£¼ì…ë°›ì•„ TurnInput ìƒì„± ì‹œ SSOT ìœ ì§€.
 * ìŠ¤íŠ¸ë¦¼ ì½œë°±ì€ agentStoreì™€ worldStoreë¡œ ë¼ìš°íŒ…ë©ë‹ˆë‹¤.
 *
 * @param deps - ì˜ì¡´ì„± (i18n ë²ˆì—­ í•¨ìˆ˜, í…Œë§ˆ, ì„¸ì…˜ ì–¸ì–´)
 * @returns Turn Runner ì¸í„°í˜ì´ìŠ¤
 *
 * @example
 * ```tsx
 * // App.tsxì—ì„œ ì‚¬ìš©
 * const runner = useMemo(() => createTurnRunner({
 *   t,
 *   theme: 'dark',
 *   language: sessionLanguage, // U-044: ì„¸ì…˜ ì–¸ì–´ SSOT
 * }), [t, sessionLanguage]);
 *
 * runner.runTurn({ text: 'hello' });
 * ```
 */
export function createTurnRunner(deps: {
  /** i18n ë²ˆì—­ í•¨ìˆ˜ */
  t: (key: string, options?: Record<string, unknown>) => string;
  /** UI í…Œë§ˆ */
  theme: 'dark' | 'light';
  /** U-044: ì„¸ì…˜ ì–¸ì–´ (SSOT) */
  language: Language;
}): TurnRunner {
  const { t, theme, language } = deps;

  // ì·¨ì†Œ í•¨ìˆ˜ ì €ì¥
  let cancelFn: (() => void) | null = null;

  /**
   * í„´ì„ ì‹¤í–‰í•©ë‹ˆë‹¤.
   */
  const runTurn = (params: RunTurnParams): void => {
    // ìŠ¤íŠ¸ë¦¬ë° ì¤‘ì´ë©´ ë¬´ì‹œ
    const isStreaming = useAgentStore.getState().isStreaming;
    if (isStreaming) return;

    // Store ì•¡ì…˜ ê°€ì ¸ì˜¤ê¸° (í´ë¡œì € ì™¸ë¶€ì—ì„œ í˜¸ì¶œ ì‹œì ì— ìµœì‹  ìƒíƒœ ì°¸ì¡°)
    const agentStore = useAgentStore.getState();
    const worldStore = useWorldStore.getState();

    // ì¬í™” ìŠ¤ëƒ…ìƒ· ê°€ì ¸ì˜¤ê¸°
    const economySnapshot = worldStore.economy;

    // TurnInput ìƒì„± (U-044: ì£¼ì…ëœ ì„¸ì…˜ ì–¸ì–´ ì‚¬ìš©)
    const turnInput = buildTurnInput({
      text:
        params.text ||
        (params.actionId ? t('action.card_select', { cardId: params.actionId }) : ''),
      actionId: params.actionId,
      click: params.click,
      drop: params.drop,
      economySnapshot,
      theme,
      language,
    });

    // Agent Store ì‹œì‘
    agentStore.startStream();

    // Scene Canvasë¥¼ ë¡œë”© ìƒíƒœë¡œ ì „í™˜ (U-031)
    worldStore.setSceneState({ status: 'loading', message: t('scene.status.syncing') });

    // ìŠ¤íŠ¸ë¦¼ ì½œë°± ì„¤ì • (RU-003-Q3: agentStore + worldStoreë¡œ ë¼ìš°íŒ…)
    // RU-003-T1: sceneState ì „ì´ëŠ” worldStore.applyTurnOutputì—ì„œ SSOTë¡œ ì²˜ë¦¬
    const callbacks: StreamCallbacks = {
      // Stage/Badges/NarrativeDelta â†’ agentStoreë¡œë§Œ ì „ë‹¬
      onStage: (event) => {
        useAgentStore.getState().handleStage(event);
      },
      onBadges: (event) => {
        useAgentStore.getState().handleBadges(event);
      },
      onNarrativeDelta: (event) => {
        useAgentStore.getState().handleNarrativeDelta(event);
      },
      // Final â†’ agentStore.handleFinal + worldStore.applyTurnOutput
      onFinal: (event) => {
        useAgentStore.getState().handleFinal(event);
        // RU-003-Q4: TurnOutput ë°˜ì˜ SSOT
        useWorldStore.getState().applyTurnOutput(event.data);
        // RU-003-S1: ì„±ê³µì ì¸ final ìˆ˜ì‹  ì‹œ ì—°ê²° ìƒíƒœ ë‚™ê´€ì  ë³µêµ¬
        useWorldStore.getState().setConnected(true);
      },
      // Error â†’ agentStore.handleError + worldStore ìƒíƒœ ë³µêµ¬
      onError: (event) => {
        useAgentStore.getState().handleError(event);
        useWorldStore.getState().setConnected(false);
        // Scene Canvasë¥¼ ì˜¤í”„ë¼ì¸/ì—ëŸ¬ ìƒíƒœë¡œ ì „í™˜ (U-031)
        const errorCode = event.code;
        if (errorCode === 'SAFETY_BLOCKED') {
          useWorldStore.getState().setSceneState({ status: 'blocked', message: event.message });
        } else if (errorCode === 'INSUFFICIENT_BALANCE') {
          useWorldStore.getState().setSceneState({ status: 'low_signal', message: event.message });
        } else {
          useWorldStore.getState().setSceneState({ status: 'offline', message: event.message });
        }
      },
      // Complete â†’ agentStore.completeStream
      // RU-003-T1: sceneState ì „ì´ëŠ” worldStore.applyTurnOutputì—ì„œ SSOTë¡œ ì²˜ë¦¬
      // - ì„±ê³µ ì‹œ: onFinal â†’ applyTurnOutputì—ì„œ ui.scene.image_url ê¸°ë°˜ìœ¼ë¡œ ì„¤ì •
      // - ì—ëŸ¬ ì‹œ: onErrorì—ì„œ ì´ë¯¸ offline/blocked/low_signalìœ¼ë¡œ ì„¤ì •ë¨
      onComplete: () => {
        useAgentStore.getState().completeStream();
        // RU-003-T1: sceneStateëŠ” applyTurnOutput(ì„±ê³µ) ë˜ëŠ” onError(ì‹¤íŒ¨)ì—ì„œ ì´ë¯¸ ì„¤ì •ë¨
        // ì—¬ê¸°ì„œ ì¶”ê°€ë¡œ ì„¤ì •í•˜ë©´ applyTurnOutputì˜ ì„¤ì •ì„ ë®ì–´ì“°ê²Œ ë˜ë¯€ë¡œ ì œê±°
      },
    };

    // ìŠ¤íŠ¸ë¦¼ ì‹œì‘
    cancelFn = startTurnStream(turnInput, callbacks);
  };

  /**
   * ìŠ¤íŠ¸ë¦¼ì„ ì·¨ì†Œí•©ë‹ˆë‹¤.
   *
   * ì¶”í›„ Cancel/Pause/Autopilot UXë¥¼ ìœ„í•œ ê¸°ë³¸ ê³¨ê²©ì…ë‹ˆë‹¤.
   * í˜„ì¬ executeTurnStreamì€ Abort ì‹œ onCompleteë¥¼ í˜¸ì¶œí•˜ì§€ ì•Šìœ¼ë¯€ë¡œ,
   * Cancel ë²„íŠ¼ì„ ë„£ì„ ê³„íšì´ë¼ë©´ "ì·¨ì†Œ ì‹œ UI ë³µêµ¬ ì •ì±…"ì„ ë³„ë„ë¡œ ëª…ì‹œí•´ì•¼ í•©ë‹ˆë‹¤.
   */
  const cancel = (): void => {
    cancelFn?.();
    cancelFn = null;
  };

  return {
    runTurn,
    cancel,
  };
}

// =============================================================================
// React Hook (ì„ íƒì  ì‚¬ìš©)
// =============================================================================

/**
 * Turn Runnerë¥¼ React ì»´í¬ë„ŒíŠ¸ì—ì„œ ì‚¬ìš©í•˜ê¸° ìœ„í•œ í›….
 *
 * U-044: ì„¸ì…˜ ì–¸ì–´ë¥¼ ì™¸ë¶€ì—ì„œ ì£¼ì…ë°›ì•„ TurnInput ìƒì„± ì‹œ SSOT ìœ ì§€.
 *
 * @param deps - ì˜ì¡´ì„± (i18n ë²ˆì—­ í•¨ìˆ˜, í…Œë§ˆ, ì„¸ì…˜ ì–¸ì–´)
 * @returns Turn Runner ì¸í„°í˜ì´ìŠ¤ ë° ì·¨ì†Œ íš¨ê³¼
 *
 * @example
 * ```tsx
 * // ì»´í¬ë„ŒíŠ¸ì—ì„œ ì‚¬ìš©
 * const { runTurn, cancel } = useTurnRunner({
 *   t,
 *   theme: 'dark',
 *   language: sessionLanguage, // U-044: ì„¸ì…˜ ì–¸ì–´ SSOT
 * });
 * ```
 */
import { useCallback, useEffect, useRef } from 'react';

export function useTurnRunner(deps: {
  t: (key: string, options?: Record<string, unknown>) => string;
  theme: 'dark' | 'light';
  /** U-044: ì„¸ì…˜ ì–¸ì–´ (SSOT) */
  language: Language;
}): TurnRunner {
  const { t, theme, language } = deps;

  // ì·¨ì†Œ í•¨ìˆ˜ ì €ì¥ ref
  const cancelFnRef = useRef<(() => void) | null>(null);

  // runTurnì„ useCallbackìœ¼ë¡œ ì •ì˜
  const runTurn = useCallback(
    (params: RunTurnParams): void => {
      // ìŠ¤íŠ¸ë¦¬ë° ì¤‘ì´ë©´ ë¬´ì‹œ
      const isStreaming = useAgentStore.getState().isStreaming;
      if (isStreaming) return;

      // Store ì•¡ì…˜ ê°€ì ¸ì˜¤ê¸°
      const agentStore = useAgentStore.getState();
      const worldStore = useWorldStore.getState();

      // ì¬í™” ìŠ¤ëƒ…ìƒ· ê°€ì ¸ì˜¤ê¸°
      const economySnapshot = worldStore.economy;

      // TurnInput ìƒì„± (U-044: ì£¼ì…ëœ ì„¸ì…˜ ì–¸ì–´ ì‚¬ìš©)
      const turnInput = buildTurnInput({
        text:
          params.text ||
          (params.actionId ? t('action.card_select', { cardId: params.actionId }) : ''),
        actionId: params.actionId,
        click: params.click,
        drop: params.drop,
        economySnapshot,
        theme,
        language,
      });

      // Agent Store ì‹œì‘
      agentStore.startStream();

      // Scene Canvasë¥¼ ë¡œë”© ìƒíƒœë¡œ ì „í™˜ (U-031)
      worldStore.setSceneState({ status: 'loading', message: t('scene.status.syncing') });

      // ìŠ¤íŠ¸ë¦¼ ì½œë°± ì„¤ì • (RU-003-Q3: agentStore + worldStoreë¡œ ë¼ìš°íŒ…)
      // RU-003-T1: sceneState ì „ì´ëŠ” worldStore.applyTurnOutputì—ì„œ SSOTë¡œ ì²˜ë¦¬
      const callbacks: StreamCallbacks = {
        onStage: (event) => {
          useAgentStore.getState().handleStage(event);
        },
        onBadges: (event) => {
          useAgentStore.getState().handleBadges(event);
        },
        onNarrativeDelta: (event) => {
          useAgentStore.getState().handleNarrativeDelta(event);
        },
        onFinal: (event) => {
          useAgentStore.getState().handleFinal(event);
          useWorldStore.getState().applyTurnOutput(event.data);
          // RU-003-S1: ì„±ê³µì ì¸ final ìˆ˜ì‹  ì‹œ ì—°ê²° ìƒíƒœ ë‚™ê´€ì  ë³µêµ¬
          useWorldStore.getState().setConnected(true);
        },
        onError: (event) => {
          useAgentStore.getState().handleError(event);
          useWorldStore.getState().setConnected(false);
          // Scene Canvasë¥¼ ì˜¤í”„ë¼ì¸/ì—ëŸ¬ ìƒíƒœë¡œ ì „í™˜ (U-031)
          const errorCode = event.code;
          if (errorCode === 'SAFETY_BLOCKED') {
            useWorldStore.getState().setSceneState({ status: 'blocked', message: event.message });
          } else if (errorCode === 'INSUFFICIENT_BALANCE') {
            useWorldStore
              .getState()
              .setSceneState({ status: 'low_signal', message: event.message });
          } else {
            useWorldStore.getState().setSceneState({ status: 'offline', message: event.message });
          }
        },
        // Complete â†’ agentStore.completeStream
        // RU-003-T1: sceneState ì „ì´ëŠ” worldStore.applyTurnOutputì—ì„œ SSOTë¡œ ì²˜ë¦¬
        // - ì„±ê³µ ì‹œ: onFinal â†’ applyTurnOutputì—ì„œ ui.scene.image_url ê¸°ë°˜ìœ¼ë¡œ ì„¤ì •
        // - ì—ëŸ¬ ì‹œ: onErrorì—ì„œ ì´ë¯¸ offline/blocked/low_signalìœ¼ë¡œ ì„¤ì •ë¨
        onComplete: () => {
          useAgentStore.getState().completeStream();
          // RU-003-T1: sceneStateëŠ” applyTurnOutput(ì„±ê³µ) ë˜ëŠ” onError(ì‹¤íŒ¨)ì—ì„œ ì´ë¯¸ ì„¤ì •ë¨
          // ì—¬ê¸°ì„œ ì¶”ê°€ë¡œ ì„¤ì •í•˜ë©´ applyTurnOutputì˜ ì„¤ì •ì„ ë®ì–´ì“°ê²Œ ë˜ë¯€ë¡œ ì œê±°
        },
      };

      // ìŠ¤íŠ¸ë¦¼ ì‹œì‘ ë° ì·¨ì†Œ í•¨ìˆ˜ ì €ì¥
      cancelFnRef.current = startTurnStream(turnInput, callbacks);
    },
    [t, theme, language],
  );

  // cancel í•¨ìˆ˜
  const cancel = useCallback((): void => {
    cancelFnRef.current?.();
    cancelFnRef.current = null;
  }, []);

  // ì»´í¬ë„ŒíŠ¸ ì–¸ë§ˆìš´íŠ¸ ì‹œ ìŠ¤íŠ¸ë¦¼ ì·¨ì†Œ
  useEffect(() => {
    return () => {
      cancelFnRef.current?.();
    };
  }, []);

  return { runTurn, cancel };
}
</file>

<file path="frontend/src/schemas/turn.ts">
/**
 * Unknown World - TurnInput/TurnOutput Zod ìŠ¤í‚¤ë§ˆ.
 *
 * ì´ ëª¨ë“ˆì€ ë°±ì—”ë“œ Pydantic ëª¨ë¸(U-005)ê³¼ 1:1 ëŒ€ì‘í•˜ëŠ” Zod ìŠ¤í‚¤ë§ˆë¥¼ ì •ì˜í•©ë‹ˆë‹¤.
 * í´ë¼ì´ì–¸íŠ¸ ì¸¡ ê²€ì¦ ë° íƒ€ì… ì•ˆì „ì„±ì„ ì œê³µí•©ë‹ˆë‹¤.
 *
 * ì„¤ê³„ ì›ì¹™:
 *   - RULE-003: êµ¬ì¡°í™” ì¶œë ¥(JSON Schema) ìš°ì„  + ì´ì¤‘ ê²€ì¦ (ì„œë²„ Pydantic + í´ë¼ Zod)
 *   - RULE-004: ê²€ì¦ ì‹¤íŒ¨ ì‹œ ì•ˆì „ í´ë°± ì œê³µ (UI ë©ˆì¶¤ ë°©ì§€)
 *   - RULE-005: ì¬í™” ì¸ë°”ë¦¬ì–¸íŠ¸ (cost, balance_after í•„ìˆ˜, ì”ì•¡ ìŒìˆ˜ ê¸ˆì§€)
 *   - RULE-006: ko/en ì–¸ì–´ ì •ì±… (Language enumìœ¼ë¡œ ê³ ì •)
 *   - RULE-009: ì¢Œí‘œ ê·œì•½ (0~1000, bbox [ymin,xmin,ymax,xmax])
 *
 * Q1 ê²°ì • ì‚¬í•­:
 *   - schema_version í¬í•¨ (Option A): SaveGame/ë§ˆì´ê·¸ë ˆì´ì…˜/ê²€ì¦ì— ìœ ë¦¬
 *
 * @module schemas/turn
 */

import { z } from 'zod';

// =============================================================================
// ìŠ¤í‚¤ë§ˆ ë²„ì „ (Q1 ê²°ì •: Option A - í¬í•¨)
// =============================================================================

/**
 * í˜„ì¬ ìŠ¤í‚¤ë§ˆ ë²„ì „.
 * SaveGame/ë§ˆì´ê·¸ë ˆì´ì…˜/ê²€ì¦ì— ì‚¬ìš©ë©ë‹ˆë‹¤.
 */
export const SCHEMA_VERSION = '1.0.0' as const;

// =============================================================================
// ê³µí†µ Enum íƒ€ì…
// =============================================================================

/**
 * ì§€ì› ì–¸ì–´ (RULE-006).
 * ko/en í˜¼í•© ì¶œë ¥ ê¸ˆì§€. TurnInput.languageë¥¼ SSOTë¡œ ì‚¼ì•„
 * ëª¨ë“  UI/ë‚´ëŸ¬í‹°ë¸Œ/ì‹œìŠ¤í…œ ë©”ì‹œì§€ëŠ” ë™ì¼ ì–¸ì–´ë¡œ ê³ ì •í•©ë‹ˆë‹¤.
 */
export const LanguageSchema = z.enum(['ko-KR', 'en-US']);
export type Language = z.infer<typeof LanguageSchema>;

/**
 * í…Œë§ˆ ì„¤ì •.
 */
export const ThemeSchema = z.enum(['dark', 'light']);
export type Theme = z.infer<typeof ThemeSchema>;

/**
 * ì—ì´ì „íŠ¸ ì‹¤í–‰ ë‹¨ê³„ (RULE-008).
 * ì—ì´ì „íŠ¸í˜• ì‹œìŠ¤í…œì„ì„ UIë¡œ ì¦ëª…í•˜ê¸° ìœ„í•œ ë‹¨ê³„ í‘œì‹œ.
 */
export const AgentPhaseSchema = z.enum([
  'parse',
  'validate',
  'plan',
  'resolve',
  'render',
  'verify',
  'commit',
]);
export type AgentPhase = z.infer<typeof AgentPhaseSchema>;

/**
 * ê²€ì¦ ë°°ì§€ (RULE-008).
 * í„´ ê²°ê³¼ì— ëŒ€í•œ ê²€ì¦ ìƒíƒœë¥¼ í‘œì‹œí•©ë‹ˆë‹¤.
 */
export const ValidationBadgeSchema = z.enum([
  'schema_ok',
  'schema_fail',
  'economy_ok',
  'economy_fail',
  'safety_ok',
  'safety_blocked',
  'consistency_ok',
  'consistency_fail',
]);
export type ValidationBadge = z.infer<typeof ValidationBadgeSchema>;

/**
 * ëª¨ë¸/í’ˆì§ˆ ì„ íƒ ë¼ë²¨ (RULE-008).
 * í”„ë¡¬í”„íŠ¸ ë…¸ì¶œ ì—†ì´ "ì™œ ì´ ì„ íƒì´ì—ˆëŠ”ì§€"ë¥¼ ì‚¬ìš©ì ì¹œí™” ë¼ë²¨ë¡œ í‘œì‹œ.
 */
export const ModelLabelSchema = z.enum(['FAST', 'QUALITY', 'CHEAP', 'REF']);
export type ModelLabel = z.infer<typeof ModelLabelSchema>;

/**
 * í–‰ë™ ìœ„í—˜ë„ ìˆ˜ì¤€.
 */
export const RiskLevelSchema = z.enum(['low', 'medium', 'high']);
export type RiskLevel = z.infer<typeof RiskLevelSchema>;

// =============================================================================
// ê³µí†µ í•˜ìœ„ íƒ€ì…
// =============================================================================

/**
 * ì •ê·œí™” ì¢Œí‘œ (RULE-009).
 * 0~1000 ë²”ìœ„ì˜ ì •ìˆ˜ì…ë‹ˆë‹¤.
 */
export const CoordinateSchema = z.number().int().min(0).max(1000).describe('ì •ê·œí™” ì¢Œí‘œ (0~1000)');
export type Coordinate = z.infer<typeof CoordinateSchema>;

/**
 * 2D ë°”ìš´ë”© ë°•ìŠ¤ (RULE-009).
 * ì¢Œí‘œëŠ” 0~1000 ì •ê·œí™” ì¢Œí‘œê³„ì´ë©°, bboxëŠ” [ymin, xmin, ymax, xmax] ìˆœì„œì…ë‹ˆë‹¤.
 * ì´ë¯¸ì§€ ì´í•´ bbox í¬ë§·ê³¼ í˜¸í™˜ë©ë‹ˆë‹¤.
 */
export const Box2DSchema = z
  .object({
    ymin: CoordinateSchema.describe('Y ìµœì†Œê°’ (ìƒë‹¨)'),
    xmin: CoordinateSchema.describe('X ìµœì†Œê°’ (ì¢Œì¸¡)'),
    ymax: CoordinateSchema.describe('Y ìµœëŒ€ê°’ (í•˜ë‹¨)'),
    xmax: CoordinateSchema.describe('X ìµœëŒ€ê°’ (ìš°ì¸¡)'),
  })
  .strict();
export type Box2D = z.infer<typeof Box2DSchema>;

/**
 * ì¬í™” ìˆ˜ëŸ‰.
 * signalê³¼ memory_shardëŠ” 0 ì´ìƒì´ì–´ì•¼ í•©ë‹ˆë‹¤ (RULE-005).
 */
export const CurrencyAmountSchema = z
  .object({
    signal: z.number().int().min(0).describe('ì‹œê·¸ë„ (ê¸°ë³¸ ì¬í™”, 0 ì´ìƒ)'),
    memory_shard: z.number().int().min(0).describe('ê¸°ì–µ íŒŒí¸ (í¬ê·€ ì¬í™”, 0 ì´ìƒ)'),
  })
  .strict();
export type CurrencyAmount = z.infer<typeof CurrencyAmountSchema>;

// =============================================================================
// TurnInput ê´€ë ¨ íƒ€ì…
// =============================================================================

/**
 * í´ë¦­ ì…ë ¥ ì •ë³´.
 * í™”ë©´ ì˜¤ë¸Œì íŠ¸ í´ë¦­ ì‹œ ì „ë‹¬ë˜ëŠ” ì •ë³´ì…ë‹ˆë‹¤.
 */
export const ClickInputSchema = z
  .object({
    object_id: z.string().describe('í´ë¦­í•œ ì˜¤ë¸Œì íŠ¸ ID'),
    box_2d: Box2DSchema.nullable().default(null).describe('í´ë¦­ ìœ„ì¹˜ ë°”ìš´ë”© ë°•ìŠ¤ (ì„ íƒ)'),
  })
  .strict();
export type ClickInput = z.infer<typeof ClickInputSchema>;

/**
 * ë“œë¡­ ì…ë ¥ ì •ë³´ (U-012).
 * ì¸ë²¤í† ë¦¬ ì•„ì´í…œì„ í•«ìŠ¤íŒŸì— ë“œë¡­í•  ë•Œ ì „ë‹¬ë˜ëŠ” ì •ë³´ì…ë‹ˆë‹¤.
 * Q1 ê²°ì •: Option B - target_box_2d í¬í•¨í•˜ì—¬ ì„œë²„ê°€ ì •í™•í•œ ìœ„ì¹˜ í•´ì„ ê°€ëŠ¥.
 */
export const DropInputSchema = z
  .object({
    item_id: z.string().describe('ë“œë¡­í•œ ì¸ë²¤í† ë¦¬ ì•„ì´í…œ ID'),
    target_object_id: z.string().describe('ë“œë¡­ ëŒ€ìƒ í•«ìŠ¤íŒŸ ì˜¤ë¸Œì íŠ¸ ID'),
    target_box_2d: Box2DSchema.describe('ë“œë¡­ ëŒ€ìƒì˜ ë°”ìš´ë”© ë°•ìŠ¤ (0~1000 ì •ê·œí™”)'),
  })
  .strict();
export type DropInput = z.infer<typeof DropInputSchema>;

/**
 * í´ë¼ì´ì–¸íŠ¸ ì •ë³´.
 */
export const ClientInfoSchema = z
  .object({
    viewport_w: z.number().int().positive().describe('ë·°í¬íŠ¸ ë„ˆë¹„ (í”½ì…€, ì–‘ìˆ˜)'),
    viewport_h: z.number().int().positive().describe('ë·°í¬íŠ¸ ë†’ì´ (í”½ì…€, ì–‘ìˆ˜)'),
    theme: ThemeSchema.default('dark').describe('í˜„ì¬ í…Œë§ˆ'),
  })
  .strict();
export type ClientInfo = z.infer<typeof ClientInfoSchema>;

/**
 * ì¬í™” ìŠ¤ëƒ…ìƒ· (í´ë¼ì´ì–¸íŠ¸ â†’ ì„œë²„).
 * í´ë¼ì´ì–¸íŠ¸ê°€ ë³´ìœ í•œ í˜„ì¬ ì¬í™” ìƒíƒœì…ë‹ˆë‹¤.
 */
export const EconomySnapshotSchema = z
  .object({
    signal: z.number().int().min(0).describe('í˜„ì¬ ì‹œê·¸ë„ ì”ì•¡ (0 ì´ìƒ)'),
    memory_shard: z.number().int().min(0).describe('í˜„ì¬ ê¸°ì–µ íŒŒí¸ ì”ì•¡ (0 ì´ìƒ)'),
  })
  .strict();
export type EconomySnapshot = z.infer<typeof EconomySnapshotSchema>;

/**
 * í„´ ì…ë ¥ (í´ë¼ì´ì–¸íŠ¸ â†’ ì„œë²„).
 * ì‚¬ìš©ìê°€ í„´ì„ ì§„í–‰í•  ë•Œ ì„œë²„ë¡œ ì „ì†¡í•˜ëŠ” ì…ë ¥ ë°ì´í„°ì…ë‹ˆë‹¤.
 *
 * U-012: drop í•„ë“œ ì¶”ê°€ - ì¸ë²¤í† ë¦¬ ì•„ì´í…œì„ í•«ìŠ¤íŒŸì— ë“œë¡­í•  ë•Œ ì‚¬ìš©.
 */
export const TurnInputSchema = z
  .object({
    language: LanguageSchema.describe('ìš”ì²­ ì–¸ì–´ (ì‘ë‹µë„ ë™ì¼ ì–¸ì–´ë¡œ ê³ ì •)'),
    text: z.string().default('').describe('ì‚¬ìš©ì ìì—°ì–´ ì…ë ¥'),
    action_id: z.string().nullable().default(null).describe('ì„ íƒí•œ ì•¡ì…˜ ì¹´ë“œ ID (ì„ íƒ)'),
    click: ClickInputSchema.nullable().default(null).describe('ì˜¤ë¸Œì íŠ¸ í´ë¦­ ì •ë³´ (ì„ íƒ)'),
    drop: DropInputSchema.nullable().default(null).describe('ì•„ì´í…œ ë“œë¡­ ì •ë³´ (ì„ íƒ, U-012)'),
    client: ClientInfoSchema.describe('í´ë¼ì´ì–¸íŠ¸ í™˜ê²½ ì •ë³´'),
    economy_snapshot: EconomySnapshotSchema.describe('í˜„ì¬ ì¬í™” ìƒíƒœ'),
  })
  .strict();
export type TurnInput = z.infer<typeof TurnInputSchema>;

// =============================================================================
// TurnOutput ê´€ë ¨ íƒ€ì… - UI
// =============================================================================

/**
 * ë¹„ìš© ì¶”ì •ì¹˜ (U-009: ìµœì†Œ/ìµœëŒ€ ë²”ìœ„).
 * í–‰ë™ì˜ ì˜ˆìƒ ë¹„ìš© ë²”ìœ„ë¥¼ í‘œì‹œí•©ë‹ˆë‹¤.
 */
export const CostEstimateSchema = z
  .object({
    min: CurrencyAmountSchema.describe('ìµœì†Œ ì˜ˆìƒ ë¹„ìš©'),
    max: CurrencyAmountSchema.describe('ìµœëŒ€ ì˜ˆìƒ ë¹„ìš©'),
  })
  .strict();
export type CostEstimate = z.infer<typeof CostEstimateSchema>;

/**
 * ì•¡ì…˜ ì¹´ë“œ (Action Deck).
 * ë§¤ í„´ AIê°€ ì¶”ì²œí•˜ëŠ” í–‰ë™ ì¹´ë“œì…ë‹ˆë‹¤.
 *
 * U-009 í™•ì¥:
 *   - cost_estimate: ìµœì†Œ/ìµœëŒ€ ë¹„ìš© ë²”ìœ„ (RULE-005)
 *   - enabled: ì„œë²„ ì¸¡ ì‹¤í–‰ ê°€ëŠ¥ ì—¬ë¶€ íŒë‹¨ (Q1: Option A)
 *   - disabled_reason: ë¹„í™œì„±í™” ì‚¬ìœ  (ì”ì•¡ ë¶€ì¡± ë“±)
 *   - is_alternative: ì €ë¹„ìš©/í…ìŠ¤íŠ¸-only ëŒ€ì•ˆ ì¹´ë“œ ì—¬ë¶€
 */
export const ActionCardSchema = z
  .object({
    id: z.string().describe('ì¹´ë“œ ê³ ìœ  ID'),
    label: z.string().describe('ì¹´ë“œ ë¼ë²¨ (í‘œì‹œìš©)'),
    description: z.string().nullable().default(null).describe('ì¹´ë“œ ì„¤ëª… (ì„ íƒ)'),
    cost: CurrencyAmountSchema.describe('ì˜ˆìƒ ë¹„ìš© (ê¸°ë³¸)'),
    cost_estimate: CostEstimateSchema.nullable().default(null).describe('ë¹„ìš© ì¶”ì • ë²”ìœ„ (ì„ íƒ)'),
    risk: RiskLevelSchema.default('low').describe('ìœ„í—˜ë„'),
    hint: z.string().nullable().default(null).describe('ì˜ˆìƒ ê²°ê³¼ íŒíŠ¸ (ì„ íƒ)'),
    reward_hint: z.string().nullable().default(null).describe('ë³´ìƒ íŒíŠ¸ (ì„ íƒ)'),
    enabled: z.boolean().default(true).describe('ì‹¤í–‰ ê°€ëŠ¥ ì—¬ë¶€ (ì„œë²„ íŒë‹¨)'),
    disabled_reason: z.string().nullable().default(null).describe('ë¹„í™œì„±í™” ì‚¬ìœ  (ì„ íƒ)'),
    is_alternative: z.boolean().default(false).describe('ì €ë¹„ìš© ëŒ€ì•ˆ ì¹´ë“œ ì—¬ë¶€'),
  })
  .strict();
export type ActionCard = z.infer<typeof ActionCardSchema>;

/**
 * ì¥ë©´ ì˜¤ë¸Œì íŠ¸ (í´ë¦­ ê°€ëŠ¥í•œ í•«ìŠ¤íŒŸ).
 * ì¢Œí‘œëŠ” 0~1000 ì •ê·œí™” ì¢Œí‘œê³„ë¥¼ ì‚¬ìš©í•©ë‹ˆë‹¤ (RULE-009).
 */
export const SceneObjectSchema = z
  .object({
    id: z.string().describe('ì˜¤ë¸Œì íŠ¸ ê³ ìœ  ID'),
    label: z.string().describe('ì˜¤ë¸Œì íŠ¸ ë¼ë²¨ (í‘œì‹œìš©)'),
    box_2d: Box2DSchema.describe('ë°”ìš´ë”© ë°•ìŠ¤'),
    interaction_hint: z.string().nullable().default(null).describe('ìƒí˜¸ì‘ìš© íŒíŠ¸ (ì„ íƒ)'),
  })
  .strict();
export type SceneObject = z.infer<typeof SceneObjectSchema>;

/**
 * ì•¡ì…˜ ë± (Q1 ê²°ì •: ui.action_deck.cards[] êµ¬ì¡°).
 * ë§¤ í„´ AIê°€ ì œì‹œí•˜ëŠ” ì¶”ì²œ í–‰ë™ ì¹´ë“œ ë±ì…ë‹ˆë‹¤.
 */
export const ActionDeckSchema = z
  .object({
    cards: z.array(ActionCardSchema).max(10).default([]).describe('ì•¡ì…˜ ì¹´ë“œ ëª©ë¡ (3~6ì¥ ê¶Œì¥)'),
  })
  .strict();
export type ActionDeck = z.infer<typeof ActionDeckSchema>;

/**
 * Scene í‘œì‹œ ì •ë³´ (RU-003-T1: Scene ì´ë¯¸ì§€ SSOT).
 *
 * TurnOutputì—ì„œ Scene Canvasì— í‘œì‹œí•  ì´ë¯¸ì§€ ì •ë³´ë¥¼ ì œê³µí•©ë‹ˆë‹¤.
 * image_urlì´ ì¡´ì¬í•˜ë©´ SceneCanvasëŠ” 'scene' ìƒíƒœë¡œ ì „í™˜ë©ë‹ˆë‹¤.
 * image_urlì´ ì—†ìœ¼ë©´ 'default' ìƒíƒœë¥¼ ìœ ì§€í•©ë‹ˆë‹¤.
 */
export const SceneOutputSchema = z
  .object({
    image_url: z
      .string()
      .nullable()
      .default(null)
      .describe('Scene ì´ë¯¸ì§€ URL (ì¡´ì¬ ì‹œ scene ìƒíƒœë¡œ ì „í™˜)'),
    alt_text: z.string().nullable().default(null).describe('ì´ë¯¸ì§€ ëŒ€ì²´ í…ìŠ¤íŠ¸ (ì ‘ê·¼ì„±ìš©, ì„ íƒ)'),
  })
  .strict();
export type SceneOutput = z.infer<typeof SceneOutputSchema>;

/**
 * Scene ê¸°ë³¸ê°’ (null ëŒ€ì‘).
 */
const DEFAULT_SCENE_OUTPUT: SceneOutput = { image_url: null, alt_text: null };

/**
 * UI ì¶œë ¥ ë°ì´í„°.
 * AIê°€ ìƒì„±í•œ UI ìš”ì†Œë“¤ì…ë‹ˆë‹¤.
 * ì±„íŒ… ë²„ë¸”ì´ ì•„ë‹Œ ê²Œì„ UIë¡œ í‘œí˜„ë©ë‹ˆë‹¤ (RULE-002).
 *
 * RU-003-T1: scene í•„ë“œ ì¶”ê°€ - Scene Canvasì˜ ì´ë¯¸ì§€ í‘œì‹œ ì •ë³´ SSOT.
 *
 * ìˆ˜ì •: scene í•„ë“œëŠ” ë°±ì—”ë“œì—ì„œ nullë¡œ ì˜¬ ìˆ˜ ìˆìœ¼ë¯€ë¡œ nullish()ë¥¼ ì‚¬ìš©í•˜ì—¬
 * null/undefined ì‹œ ê¸°ë³¸ê°’ìœ¼ë¡œ ë³€í™˜í•©ë‹ˆë‹¤.
 */
export const UIOutputSchema = z
  .object({
    action_deck: ActionDeckSchema.default({ cards: [] }).describe('ì•¡ì…˜ ì¹´ë“œ ë±'),
    objects: z.array(SceneObjectSchema).default([]).describe('í´ë¦­ ê°€ëŠ¥í•œ ì¥ë©´ ì˜¤ë¸Œì íŠ¸ ëª©ë¡'),
    scene: SceneOutputSchema.nullish()
      .transform((val) => val ?? DEFAULT_SCENE_OUTPUT)
      .describe('Scene í‘œì‹œ ì •ë³´ (RU-003-T1, null í—ˆìš©)'),
  })
  .strict();
export type UIOutput = z.infer<typeof UIOutputSchema>;

// =============================================================================
// TurnOutput ê´€ë ¨ íƒ€ì… - World
// =============================================================================

/**
 * ì¤‘ìš” ì„¤ì • ê³ ì • í›„ë³´.
 * ì‚¬ìš©ìê°€ Memory Shardë¥¼ ì†Œë¹„í•´ ê³ ì •í•  ìˆ˜ ìˆëŠ” ì¤‘ìš” ì„¤ì •ì…ë‹ˆë‹¤.
 */
export const MemoryPinSchema = z
  .object({
    id: z.string().describe('í•€ ê³ ìœ  ID'),
    content: z.string().describe('ê³ ì •í•  ë‚´ìš©'),
    cost: CurrencyAmountSchema.describe('ê³ ì •ì— í•„ìš”í•œ ë¹„ìš©'),
  })
  .strict();
export type MemoryPin = z.infer<typeof MemoryPinSchema>;

/**
 * ì„¸ê³„ ê·œì¹™ (Rule Board).
 * í˜„ì¬ ì„¸ê³„ì— ì ìš© ì¤‘ì¸ ë¬¼ë¦¬ ë²•ì¹™ì´ë‚˜ ë©”íƒ€ ê·œì¹™ì…ë‹ˆë‹¤.
 */
export const WorldRuleSchema = z
  .object({
    id: z.string().describe('ê·œì¹™ ê³ ìœ  ID'),
    label: z.string().describe('ê·œì¹™ ì´ë¦„'),
    description: z.string().nullable().default(null).describe('ê·œì¹™ ìƒì„¸ ì„¤ëª… (ì„ íƒ)'),
  })
  .strict();
export type WorldRule = z.infer<typeof WorldRuleSchema>;

/**
 * í€˜ìŠ¤íŠ¸/ëª©í‘œ (Quest Panel).
 * í”Œë ˆì´ì–´ê°€ ë‹¬ì„±í•´ì•¼ í•˜ëŠ” í˜„ì¬ ëª©í‘œì…ë‹ˆë‹¤.
 */
export const QuestSchema = z
  .object({
    id: z.string().describe('í€˜ìŠ¤íŠ¸ ê³ ìœ  ID'),
    label: z.string().describe('í€˜ìŠ¤íŠ¸ ì´ë¦„'),
    is_completed: z.boolean().default(false).describe('ë‹¬ì„± ì—¬ë¶€'),
  })
  .strict();
export type Quest = z.infer<typeof QuestSchema>;

/**
 * ì„¸ê³„ ìƒíƒœ ë³€í™” (Q2 ê²°ì •: Option A - delta ì¤‘ì‹¬).
 * ì´ë²ˆ í„´ì—ì„œ ë³€ê²½ëœ ì„¸ê³„ ìƒíƒœë¥¼ ë‚˜íƒ€ëƒ…ë‹ˆë‹¤.
 */
export const WorldDeltaSchema = z
  .object({
    rules_changed: z.array(WorldRuleSchema).default([]).describe('ë³€ê²½ëœ ê·œì¹™ ëª©ë¡'),
    inventory_added: z.array(z.string()).default([]).describe('ì¶”ê°€ëœ ì¸ë²¤í† ë¦¬ ì•„ì´í…œ'),
    inventory_removed: z.array(z.string()).default([]).describe('ì œê±°ëœ ì¸ë²¤í† ë¦¬ ì•„ì´í…œ'),
    quests_updated: z.array(QuestSchema).default([]).describe('ì—…ë°ì´íŠ¸ëœ í€˜ìŠ¤íŠ¸/ëª©í‘œ ëª©ë¡'),
    relationships_changed: z.array(z.string()).default([]).describe('ë³€ê²½ëœ ê´€ê³„'),
    memory_pins: z.array(MemoryPinSchema).default([]).describe('ì¤‘ìš” ì„¤ì • ê³ ì • í›„ë³´'),
  })
  .strict();
export type WorldDelta = z.infer<typeof WorldDeltaSchema>;

// =============================================================================
// TurnOutput ê´€ë ¨ íƒ€ì… - Render
// =============================================================================

/**
 * ì´ë¯¸ì§€ ìƒì„± ì‘ì—….
 * ì¡°ê±´ë¶€ ì´ë¯¸ì§€ ìƒì„±/í¸ì§‘ ìš”ì²­ì…ë‹ˆë‹¤.
 *
 * U-035: remove_background, image_type_hint í•„ë“œ ì¶”ê°€ (rembg ë°°ê²½ ì œê±°)
 */
export const ImageJobSchema = z
  .object({
    should_generate: z.boolean().describe('ì´ë¯¸ì§€ë¥¼ ìƒì„±í•´ì•¼ í•˜ëŠ”ì§€'),
    prompt: z.string().default('').describe('ì´ë¯¸ì§€ ìƒì„± í”„ë¡¬í”„íŠ¸'),
    model_label: ModelLabelSchema.default('FAST').describe('ëª¨ë¸ ì„ íƒ ë¼ë²¨'),
    aspect_ratio: z.string().default('16:9').describe('ê°€ë¡œì„¸ë¡œ ë¹„ìœ¨'),
    image_size: z.string().default('1024x1024').describe('ì´ë¯¸ì§€ í¬ê¸°'),
    reference_image_ids: z.array(z.string()).default([]).describe('ì°¸ì¡° ì´ë¯¸ì§€ ID ëª©ë¡ (ì„ íƒ)'),
    remove_background: z.boolean().default(false).describe('ë°°ê²½ ì œê±° ì—¬ë¶€ (U-035, rembg ì‚¬ìš©)'),
    image_type_hint: z
      .string()
      .nullable()
      .default(null)
      .describe('ì´ë¯¸ì§€ ìœ í˜• íŒíŠ¸ (object/character/icon ë“±, rembg ëª¨ë¸ ì„ íƒìš©)'),
  })
  .strict();
export type ImageJob = z.infer<typeof ImageJobSchema>;

/**
 * ë Œë”ë§ ì¶œë ¥ ë°ì´í„°.
 * ì´ë¯¸ì§€ ìƒì„±/í¸ì§‘ ê´€ë ¨ ì •ë³´ì…ë‹ˆë‹¤.
 */
export const RenderOutputSchema = z
  .object({
    image_job: ImageJobSchema.nullable().default(null).describe('ì´ë¯¸ì§€ ìƒì„± ì‘ì—… (ì„ íƒ)'),
  })
  .strict();
export type RenderOutput = z.infer<typeof RenderOutputSchema>;

// =============================================================================
// TurnOutput ê´€ë ¨ íƒ€ì… - Economy
// =============================================================================

/**
 * ê²½ì œ ì¶œë ¥ ë°ì´í„° (RULE-005).
 * ì´ë²ˆ í„´ì˜ ë¹„ìš©ê³¼ ì”ì•¡ ì •ë³´ì…ë‹ˆë‹¤.
 * ì”ì•¡ ìŒìˆ˜ëŠ” ì ˆëŒ€ ë¶ˆê°€ (ì„œë²„ Hard gate).
 */
export const EconomyOutputSchema = z
  .object({
    cost: CurrencyAmountSchema.describe('ì´ë²ˆ í„´ì— ì†Œë¹„ëœ ë¹„ìš©'),
    balance_after: CurrencyAmountSchema.describe('ì†Œë¹„ í›„ ì”ì•¡'),
  })
  .strict();
export type EconomyOutput = z.infer<typeof EconomyOutputSchema>;

// =============================================================================
// TurnOutput ê´€ë ¨ íƒ€ì… - Safety
// =============================================================================

/**
 * ì•ˆì „ ì¶œë ¥ ë°ì´í„°.
 * ì•ˆì „ ì •ì±… ê´€ë ¨ ì •ë³´ì…ë‹ˆë‹¤.
 * ì°¨ë‹¨ ì‹œ ëª…ì‹œì  ë©”ì‹œì§€ì™€ í•¨ê»˜ ì•ˆì „í•œ ëŒ€ì²´ ê²°ê³¼ë¥¼ ì œê³µí•©ë‹ˆë‹¤.
 */
export const SafetyOutputSchema = z
  .object({
    blocked: z.boolean().default(false).describe('ì•ˆì „ ì •ì±…ì— ì˜í•´ ì°¨ë‹¨ë˜ì—ˆëŠ”ì§€'),
    message: z
      .string()
      .nullable()
      .default(null)
      .describe('ì°¨ë‹¨ ì‹œ ì‚¬ìš©ìì—ê²Œ í‘œì‹œí•  ë©”ì‹œì§€ (ì„ íƒ)'),
  })
  .strict();
export type SafetyOutput = z.infer<typeof SafetyOutputSchema>;

// =============================================================================
// TurnOutput ê´€ë ¨ íƒ€ì… - Agent Console
// =============================================================================

/**
 * ì—ì´ì „íŠ¸ ì½˜ì†” ë°ì´í„° (RULE-008).
 * ì—ì´ì „íŠ¸í˜• ì‹œìŠ¤í…œì„ì„ UIë¡œ ì¦ëª…í•˜ê¸° ìœ„í•œ ì •ë³´ì…ë‹ˆë‹¤.
 */
export const AgentConsoleSchema = z
  .object({
    current_phase: AgentPhaseSchema.default('commit').describe('í˜„ì¬ ì‹¤í–‰ ë‹¨ê³„'),
    badges: z.array(ValidationBadgeSchema).default([]).describe('ê²€ì¦ ë°°ì§€ ëª©ë¡'),
    repair_count: z.number().int().min(0).default(0).describe('ìë™ ë³µêµ¬ ì‹œë„ íšŸìˆ˜'),
  })
  .strict();
export type AgentConsole = z.infer<typeof AgentConsoleSchema>;

// =============================================================================
// TurnOutput (ë©”ì¸ ì‘ë‹µ ìŠ¤í‚¤ë§ˆ)
// =============================================================================

/**
 * í„´ ì¶œë ¥ (ì„œë²„ â†’ í´ë¼ì´ì–¸íŠ¸).
 * ì„œë²„ê°€ í„´ ì²˜ë¦¬ í›„ í´ë¼ì´ì–¸íŠ¸ë¡œ ë°˜í™˜í•˜ëŠ” êµ¬ì¡°í™”ëœ ì‘ë‹µì…ë‹ˆë‹¤.
 *
 * Hard Gate í•„ë“œ (RULE-003/004/005):
 *   - economy: costì™€ balance_after í•„ìˆ˜, ì”ì•¡ ìŒìˆ˜ ê¸ˆì§€
 *   - safety: blocked ì‹œ ì•ˆì „í•œ ëŒ€ì²´ ê²°ê³¼ ì œê³µ
 *   - language: ìš”ì²­ ì–¸ì–´ì™€ ë™ì¼í•˜ê²Œ ê³ ì • (í˜¼í•© ì¶œë ¥ ê¸ˆì§€)
 */
export const TurnOutputSchema = z
  .object({
    // í•„ìˆ˜ í•„ë“œ (Hard Gate)
    language: LanguageSchema.describe('ì‘ë‹µ ì–¸ì–´ (ìš”ì²­ê³¼ ë™ì¼)'),
    narrative: z.string().describe('ë‚´ëŸ¬í‹°ë¸Œ í…ìŠ¤íŠ¸ (í‘œì‹œìš©)'),
    economy: EconomyOutputSchema.describe('ê²½ì œ ì •ë³´ (ë¹„ìš©, ì”ì•¡)'),
    safety: SafetyOutputSchema.describe('ì•ˆì „ ì •ì±… ì •ë³´'),

    // UI ê´€ë ¨ í•„ë“œ (RU-003-T1: scene í•„ë“œ ì¶”ê°€)
    ui: UIOutputSchema.default({
      action_deck: { cards: [] },
      objects: [],
      scene: { image_url: null, alt_text: null },
    }).describe('UI ìš”ì†Œ'),

    // ì„¸ê³„ ìƒíƒœ í•„ë“œ
    world: WorldDeltaSchema.default({
      rules_changed: [],
      inventory_added: [],
      inventory_removed: [],
      quests_updated: [],
      relationships_changed: [],
      memory_pins: [],
    }).describe('ì„¸ê³„ ìƒíƒœ ë³€í™” (delta)'),

    // ë Œë”ë§ í•„ë“œ
    render: RenderOutputSchema.default({ image_job: null }).describe('ë Œë”ë§ ì •ë³´'),

    // ì—ì´ì „íŠ¸ ì½˜ì†” í•„ë“œ
    agent_console: AgentConsoleSchema.default({
      current_phase: 'commit',
      badges: [],
      repair_count: 0,
    }).describe('ì—ì´ì „íŠ¸ ì‹¤í–‰ ì •ë³´'),
  })
  .strict();
export type TurnOutput = z.infer<typeof TurnOutputSchema>;

// =============================================================================
// ì•ˆì „ í´ë°± (RULE-004)
// =============================================================================

/**
 * ê²€ì¦ ì‹¤íŒ¨ ì‹œ ì œê³µë˜ëŠ” ì•ˆì „ í´ë°± TurnOutput.
 * UIê°€ ë©ˆì¶”ì§€ ì•Šë„ë¡ ìµœì†Œí•œì˜ ì •ë³´ë¥¼ ì œê³µí•©ë‹ˆë‹¤.
 *
 * @param language - ìš”ì²­ ì–¸ì–´
 * @param repairCount - ë³µêµ¬ ì‹œë„ íšŸìˆ˜
 * @param errorMessage - ì˜¤ë¥˜ ë©”ì‹œì§€ (ì„ íƒ)
 */
export function createFallbackTurnOutput(
  language: Language,
  repairCount: number = 0,
  errorMessage?: string,
): TurnOutput {
  const fallbackNarrative =
    language === 'ko-KR'
      ? '[ì‹œìŠ¤í…œ] ì‘ë‹µì„ ì²˜ë¦¬í•˜ëŠ” ì¤‘ ë¬¸ì œê°€ ë°œìƒí–ˆìŠµë‹ˆë‹¤. ë‹¤ì‹œ ì‹œë„í•´ ì£¼ì„¸ìš”.'
      : '[System] An error occurred while processing the response. Please try again.';

  const safetyMessage =
    language === 'ko-KR'
      ? 'ìŠ¤í‚¤ë§ˆ ê²€ì¦ ì‹¤íŒ¨ë¡œ ì¸í•œ í´ë°± ì‘ë‹µì…ë‹ˆë‹¤.'
      : 'This is a fallback response due to schema validation failure.';

  return {
    language,
    narrative: errorMessage ?? fallbackNarrative,
    economy: {
      cost: { signal: 0, memory_shard: 0 },
      balance_after: { signal: 0, memory_shard: 0 },
    },
    safety: {
      blocked: false,
      message: safetyMessage,
    },
    ui: {
      action_deck: { cards: [] },
      objects: [],
      scene: { image_url: null, alt_text: null },
    },
    world: {
      rules_changed: [],
      inventory_added: [],
      inventory_removed: [],
      quests_updated: [],
      relationships_changed: [],
      memory_pins: [],
    },
    render: {
      image_job: null,
    },
    agent_console: {
      current_phase: 'commit',
      badges: ['schema_fail'],
      repair_count: repairCount,
    },
  };
}

// =============================================================================
// ê²€ì¦ í—¬í¼ í•¨ìˆ˜
// =============================================================================

/**
 * TurnOutput ê²€ì¦ ê²°ê³¼ íƒ€ì….
 */
export type TurnOutputParseResult =
  | { success: true; data: TurnOutput }
  | { success: false; error: z.ZodError; fallback: TurnOutput };

/**
 * TurnOutputì„ ì•ˆì „í•˜ê²Œ íŒŒì‹±í•©ë‹ˆë‹¤.
 * ì‹¤íŒ¨ ì‹œ í´ë°± TurnOutputì„ ë°˜í™˜í•©ë‹ˆë‹¤ (RULE-004).
 *
 * @param data - íŒŒì‹±í•  ë°ì´í„°
 * @param language - í´ë°± ì‹œ ì‚¬ìš©í•  ì–¸ì–´ (ê¸°ë³¸: ko-KR)
 * @param repairCount - í˜„ì¬ ë³µêµ¬ ì‹œë„ íšŸìˆ˜
 */
export function safeParseTurnOutput(
  data: unknown,
  language: Language = 'ko-KR',
  repairCount: number = 0,
): TurnOutputParseResult {
  const result = TurnOutputSchema.safeParse(data);

  if (result.success) {
    return { success: true, data: result.data };
  }

  return {
    success: false,
    error: result.error,
    fallback: createFallbackTurnOutput(language, repairCount),
  };
}

/**
 * TurnInputì„ ê²€ì¦í•©ë‹ˆë‹¤.
 * ì…ë ¥ ë°ì´í„°ì˜ ìœ íš¨ì„±ì„ ì—„ê²©í•˜ê²Œ ê²€ì‚¬í•©ë‹ˆë‹¤.
 *
 * @param data - ê²€ì¦í•  ë°ì´í„°
 * @throws {z.ZodError} ê²€ì¦ ì‹¤íŒ¨ ì‹œ
 */
export function parseTurnInput(data: unknown): TurnInput {
  return TurnInputSchema.parse(data);
}

/**
 * TurnInput ì•ˆì „ íŒŒì‹± ê²°ê³¼ íƒ€ì….
 */
export type TurnInputSafeParseResult = ReturnType<typeof TurnInputSchema.safeParse>;

/**
 * TurnInputì„ ì•ˆì „í•˜ê²Œ íŒŒì‹±í•©ë‹ˆë‹¤.
 *
 * @param data - íŒŒì‹±í•  ë°ì´í„°
 */
export function safeParseTurnInput(data: unknown): TurnInputSafeParseResult {
  return TurnInputSchema.safeParse(data);
}
</file>

<file path="frontend/src/api/turnStream.ts">
/**
 * Unknown World - HTTP Streaming í´ë¼ì´ì–¸íŠ¸ + NDJSON íŒŒì„œ.
 *
 * fetch ê¸°ë°˜ìœ¼ë¡œ POST ìš”ì²­ì„ ë³´ë‚´ê³  ì‘ë‹µ ìŠ¤íŠ¸ë¦¼ì„ NDJSONìœ¼ë¡œ íŒŒì‹±í•©ë‹ˆë‹¤.
 * ì¤‘ê°„ ì²­í¬ íŒŒì‹± ì‹¤íŒ¨ê°€ ì „ì²´ UIë¥¼ ë©ˆì¶”ì§€ ì•Šë„ë¡ ì„¤ê³„ë˜ì—ˆìŠµë‹ˆë‹¤.
 *
 * ì„¤ê³„ ì›ì¹™:
 *   - RULE-003: êµ¬ì¡°í™” ì¶œë ¥(JSON Schema) ìš°ì„  + ì´ì¤‘ ê²€ì¦
 *   - RULE-004: ê²€ì¦ ì‹¤íŒ¨ ì‹œ ì•ˆì „ í´ë°± ì œê³µ
 *   - RULE-008: ë‹¨ê³„/ë°°ì§€ ê°€ì‹œí™” (í”„ë¡¬í”„íŠ¸/ë‚´ë¶€ ì¶”ë¡  ë…¸ì¶œ ê¸ˆì§€)
 *   - RULE-011: ë°±ì—”ë“œ í¬íŠ¸ 8011 ì‚¬ìš©
 *
 * @module api/turnStream
 */

import type { TurnInput, TurnOutput, Language } from '../schemas/turn';
import { safeParseTurnOutput } from '../schemas/turn';
import type { StreamCallbacks } from '../types/turn_stream';
import {
  StreamEventType,
  BaseEventSchema,
  safeParseStageEvent,
  safeParseRepairEvent,
  safeParseBadgesEvent,
  safeParseNarrativeDeltaEvent,
  safeParseFinalEventRaw,
  safeParseErrorEvent,
  normalizeStageStatus,
} from '../types/turn_stream';

// Re-export ìŠ¤íŠ¸ë¦¼ ì´ë²¤íŠ¸ íƒ€ì…ë“¤ (í•˜ìœ„ í˜¸í™˜ì„± ìœ ì§€)
export type {
  StreamEventTypeName,
  StageStatusName,
  StageEvent,
  RepairEvent,
  BadgesEvent,
  NarrativeDeltaEvent,
  FinalEvent,
  ErrorEvent,
  StreamEvent,
  StreamCallbacks,
} from '../types/turn_stream';
export { StreamEventType, StageStatus } from '../types/turn_stream';

// =============================================================================
// NDJSON íŒŒì„œ (Q1 ê²°ì •: Option A - ì§ì ‘ êµ¬í˜„)
// =============================================================================

/**
 * NDJSON ë¼ì¸ íŒŒì„œ.
 * ë¶€ë¶„ ì²­í¬ë¥¼ ë²„í¼ë§í•˜ê³  ì™„ì „í•œ ë¼ì¸ì„ íŒŒì‹±í•©ë‹ˆë‹¤.
 */
export class NDJSONParser {
  private buffer = '';

  /**
   * ì²­í¬ë¥¼ íŒŒì‹±í•˜ê³  ì™„ì „í•œ JSON ê°ì²´ë“¤ì„ ë°˜í™˜í•©ë‹ˆë‹¤.
   *
   * @param chunk - ìˆ˜ì‹ ëœ í…ìŠ¤íŠ¸ ì²­í¬
   * @returns íŒŒì‹±ëœ JSON ê°ì²´ ë°°ì—´
   */
  parse(chunk: string): unknown[] {
    this.buffer += chunk;
    const results: unknown[] = [];

    // ì¤„ë°”ê¿ˆìœ¼ë¡œ ë¶„í• 
    const lines = this.buffer.split('\n');

    // ë§ˆì§€ë§‰ ë¼ì¸ì€ ë¶ˆì™„ì „í•  ìˆ˜ ìˆìœ¼ë¯€ë¡œ ë²„í¼ì— ìœ ì§€
    this.buffer = lines.pop() ?? '';

    for (const line of lines) {
      const trimmed = line.trim();
      if (trimmed === '') continue;

      try {
        const parsed = JSON.parse(trimmed);
        results.push(parsed);
      } catch {
        // íŒŒì‹± ì‹¤íŒ¨ ì‹œ í•´ë‹¹ ë¼ì¸ ë¬´ì‹œ (RULE-004: ì „ì²´ ì¤‘ë‹¨ ë°©ì§€)
        console.warn('[NDJSON] Failed to parse line:', trimmed);
      }
    }

    return results;
  }

  /**
   * ë²„í¼ë¥¼ ì´ˆê¸°í™”í•©ë‹ˆë‹¤.
   */
  reset(): void {
    this.buffer = '';
  }

  /**
   * ë‚¨ì€ ë²„í¼ë¥¼ í”ŒëŸ¬ì‹œí•˜ê³  ë§ˆì§€ë§‰ ê°ì²´ë¥¼ íŒŒì‹±í•©ë‹ˆë‹¤.
   */
  flush(): unknown | null {
    const trimmed = this.buffer.trim();
    this.buffer = '';

    if (trimmed === '') return null;

    try {
      return JSON.parse(trimmed);
    } catch {
      console.warn('[NDJSON] Failed to parse remaining buffer:', trimmed);
      return null;
    }
  }
}

// =============================================================================
// ìŠ¤íŠ¸ë¦¼ ì´ë²¤íŠ¸ í•¸ë“¤ëŸ¬
// =============================================================================

/**
 * íŒŒì‹±ëœ ì´ë²¤íŠ¸ë¥¼ íƒ€ì…ë³„ë¡œ ë¶„ë°°í•©ë‹ˆë‹¤.
 *
 * RU-002-S2: ìºìŠ¤íŒ… ëŒ€ì‹  Zod safeParseë¥¼ ì ìš©í•˜ì—¬ ê²€ì¦ ê°•í™”.
 * Unknown/í™•ì¥ ì´ë²¤íŠ¸ëŠ” UIë¥¼ ë©ˆì¶”ì§€ ì•Šê³  ê²½ê³ ë§Œ ì¶œë ¥.
 *
 * @param event - íŒŒì‹±ëœ ì´ë²¤íŠ¸ ê°ì²´
 * @param callbacks - ì½œë°± í•¨ìˆ˜ë“¤
 * @param language - í´ë°± ì–¸ì–´
 */
function dispatchEvent(event: unknown, callbacks: StreamCallbacks, language: Language): void {
  if (!event || typeof event !== 'object') return;

  // ê¸°ë³¸ ì´ë²¤íŠ¸ íƒ€ì… ì¶”ì¶œ
  const baseResult = BaseEventSchema.safeParse(event);
  if (!baseResult.success) {
    console.warn('[TurnStream] Invalid event format (no type field):', event);
    return;
  }

  const type = baseResult.data.type;

  switch (type) {
    case StreamEventType.STAGE: {
      // RU-002-S2: stage ì´ë²¤íŠ¸ ê²€ì¦
      const stageResult = safeParseStageEvent(event);
      if (stageResult.success) {
        // status ì •ê·œí™”: 'ok' â†’ 'complete'
        const normalizedStatus = normalizeStageStatus(stageResult.data.status);
        callbacks.onStage?.({
          type: StreamEventType.STAGE,
          name: stageResult.data.name,
          status: normalizedStatus,
        });
      } else {
        console.warn('[TurnStream] Invalid stage event:', stageResult.error.message);
      }
      break;
    }

    case StreamEventType.REPAIR: {
      // RU-002-S2: repair ì´ë²¤íŠ¸ ê²€ì¦
      const repairResult = safeParseRepairEvent(event);
      if (repairResult.success) {
        callbacks.onRepair?.(repairResult.data);
      } else {
        console.warn('[TurnStream] Invalid repair event:', repairResult.error.message);
      }
      break;
    }

    case StreamEventType.BADGES: {
      // RU-002-S2: badges ì´ë²¤íŠ¸ ê²€ì¦ (v1/v2 ì •ê·œí™” í¬í•¨)
      const badgesResult = safeParseBadgesEvent(event);
      if (badgesResult.success) {
        callbacks.onBadges?.(badgesResult.data);
      } else {
        console.warn('[TurnStream] Invalid badges event:', badgesResult.error.message);
      }
      break;
    }

    case StreamEventType.NARRATIVE_DELTA: {
      // RU-002-S2: narrative_delta ì´ë²¤íŠ¸ ê²€ì¦
      const narrativeResult = safeParseNarrativeDeltaEvent(event);
      if (narrativeResult.success) {
        callbacks.onNarrativeDelta?.(narrativeResult.data);
      } else {
        console.warn('[TurnStream] Invalid narrative_delta event:', narrativeResult.error.message);
      }
      break;
    }

    case StreamEventType.FINAL: {
      // RU-002-S2: final ì´ë²¤íŠ¸ êµ¬ì¡° ê²€ì¦
      const finalRawResult = safeParseFinalEventRaw(event);
      if (!finalRawResult.success) {
        console.warn('[TurnStream] Invalid final event structure:', finalRawResult.error.message);
        // êµ¬ì¡°ê°€ ì˜ëª»ë˜ì–´ë„ í´ë°± ì œê³µ
        callbacks.onFinal?.({
          type: StreamEventType.FINAL,
          data: createFallbackTurnOutput(language),
        });
        break;
      }

      // RULE-003/004: Zod strict parse + í´ë°±
      const turnOutputPayload = finalRawResult.data.data;
      const parseResult = safeParseTurnOutput(turnOutputPayload, language);

      if (parseResult.success) {
        callbacks.onFinal?.({
          type: StreamEventType.FINAL,
          data: parseResult.data,
        });
      } else {
        console.warn('[TurnStream] TurnOutput validation failed:', parseResult.error);
        callbacks.onFinal?.({
          type: StreamEventType.FINAL,
          data: parseResult.fallback,
        });
      }
      break;
    }

    case StreamEventType.ERROR: {
      // RU-002-S2: error ì´ë²¤íŠ¸ ê²€ì¦
      const errorResult = safeParseErrorEvent(event);
      if (errorResult.success) {
        callbacks.onError?.(errorResult.data);
      } else {
        console.warn('[TurnStream] Invalid error event:', errorResult.error.message);
        // U-044: ì—ëŸ¬ ì´ë²¤íŠ¸ê°€ ê¹¨ì§„ ê²½ìš°ì—ë„ ê¸°ë³¸ ì—ëŸ¬ ì „ë‹¬ (i18n ë©”ì‹œì§€ ì‚¬ìš©)
        callbacks.onError?.({
          type: StreamEventType.ERROR,
          message: getErrorMessage('unknown_error', language),
          code: 'INVALID_ERROR_EVENT',
        });
      }
      break;
    }

    default:
      // RU-002-S2: Unknown/í™•ì¥ ì´ë²¤íŠ¸ëŠ” UIë¥¼ ë©ˆì¶”ì§€ ì•Šê³  ê²½ê³ ë§Œ ì¶œë ¥
      // í–¥í›„ protocol, repair, telemetry ë“± í™•ì¥ ì´ë²¤íŠ¸ ë„ì… ì‹œ ì—¬ê¸°ì„œ ì²˜ë¦¬ ê°€ëŠ¥
      console.warn('[TurnStream] Unknown/ignored event type:', type, event);
  }
}

// =============================================================================
// U-044: i18n ì—ëŸ¬/í´ë°± ë©”ì‹œì§€ (Q2: Option B - translation.json í‚¤ ì‚¬ìš©)
// =============================================================================

/**
 * U-044: ì—ëŸ¬ ë©”ì‹œì§€ ë²ˆì—­ ë¦¬ì†ŒìŠ¤.
 * í´ë¼ì´ì–¸íŠ¸ì—ì„œ ë°œìƒí•˜ëŠ” ì—ëŸ¬ ë©”ì‹œì§€ë¥¼ ì–¸ì–´ë³„ë¡œ ì œê³µí•©ë‹ˆë‹¤.
 *
 * ì£¼ì˜: turnStream.tsëŠ” React ì»´í¬ë„ŒíŠ¸ê°€ ì•„ë‹ˆë¯€ë¡œ useTranslation ì‚¬ìš© ë¶ˆê°€.
 * ëŒ€ì‹  language ë§¤ê°œë³€ìˆ˜ë¡œ ë¶„ê¸° ì²˜ë¦¬í•©ë‹ˆë‹¤.
 * translation.jsonì˜ í‚¤ì™€ ë™ê¸°í™” ìœ ì§€ í•„ìš” (error.* ë„¤ì„ìŠ¤í˜ì´ìŠ¤).
 */
const ERROR_MESSAGES: Record<string, Record<Language, string>> = {
  // ì—ëŸ¬ ì´ë²¤íŠ¸ íŒŒì‹± ì‹¤íŒ¨
  unknown_error: {
    'ko-KR': 'ì•Œ ìˆ˜ ì—†ëŠ” ì˜¤ë¥˜ê°€ ë°œìƒí–ˆìŠµë‹ˆë‹¤.',
    'en-US': 'An unknown error occurred.',
  },
  // ì‘ë‹µ ë°ì´í„° ì²˜ë¦¬ ì‹¤íŒ¨ (final ì´ë²¤íŠ¸ ìŠ¤í‚¤ë§ˆ ê²€ì¦ ì‹¤íŒ¨)
  response_processing: {
    'ko-KR': '[ì‹œìŠ¤í…œ] ì‘ë‹µ ë°ì´í„°ë¥¼ ì²˜ë¦¬í•˜ëŠ” ì¤‘ ë¬¸ì œê°€ ë°œìƒí–ˆìŠµë‹ˆë‹¤.',
    'en-US': '[System] An error occurred while processing response data.',
  },
  // ì„œë²„ ì—°ê²° ì‹¤íŒ¨ (ë„¤íŠ¸ì›Œí¬ ì—ëŸ¬)
  connection_failed: {
    'ko-KR': '[ì‹œìŠ¤í…œ] ì„œë²„ ì—°ê²°ì— ì‹¤íŒ¨í–ˆìŠµë‹ˆë‹¤. ë‹¤ì‹œ ì‹œë„í•´ ì£¼ì„¸ìš”.',
    'en-US': '[System] Failed to connect to server. Please try again.',
  },
};

/**
 * U-044: ì—ëŸ¬ ë©”ì‹œì§€ë¥¼ ì–¸ì–´ì— ë§ê²Œ ë°˜í™˜í•©ë‹ˆë‹¤.
 */
function getErrorMessage(key: string, language: Language): string {
  return ERROR_MESSAGES[key]?.[language] ?? ERROR_MESSAGES[key]?.['en-US'] ?? key;
}

/**
 * í´ë¼ì´ì–¸íŠ¸ ì¸¡ í´ë°± TurnOutput ìƒì„± (ì–¸ì–´ë§Œ ì§€ì •).
 * dispatchEvent ë‚´ë¶€ì—ì„œ ì‚¬ìš©í•˜ëŠ” ê°„ë‹¨í•œ í´ë°±.
 * U-044: í•˜ë“œì½”ë”© ë©”ì‹œì§€ ì œê±°, i18n ë¦¬ì†ŒìŠ¤ ì‚¬ìš©.
 */
function createFallbackTurnOutput(language: Language): TurnOutput {
  const fallbackNarrative = getErrorMessage('response_processing', language);

  return {
    language,
    narrative: fallbackNarrative,
    economy: {
      cost: { signal: 0, memory_shard: 0 },
      balance_after: { signal: 0, memory_shard: 0 },
    },
    safety: {
      blocked: false,
      message: null,
    },
    ui: {
      action_deck: { cards: [] },
      objects: [],
      scene: { image_url: null, alt_text: null },
    },
    world: {
      rules_changed: [],
      inventory_added: [],
      inventory_removed: [],
      quests_updated: [],
      relationships_changed: [],
      memory_pins: [],
    },
    render: {
      image_job: null,
    },
    agent_console: {
      current_phase: 'commit',
      badges: ['schema_fail'],
      repair_count: 1,
    },
  };
}

// =============================================================================
// API ì„¤ì •
// =============================================================================

/** ë°±ì—”ë“œ API URL (RULE-011: í¬íŠ¸ 8011) */
const API_BASE_URL = 'http://localhost:8011';

/** í„´ ìŠ¤íŠ¸ë¦¼ API ì—”ë“œí¬ì¸íŠ¸ */
const TURN_ENDPOINT = `${API_BASE_URL}/api/turn`;

// =============================================================================
// ìŠ¤íŠ¸ë¦¼ í´ë¼ì´ì–¸íŠ¸
// =============================================================================

/** ìŠ¤íŠ¸ë¦¼ ìš”ì²­ ì˜µì…˜ */
export interface TurnStreamOptions {
  /** ìš”ì²­ íƒ€ì„ì•„ì›ƒ (ms) */
  timeout?: number;
  /** AbortSignal */
  signal?: AbortSignal;
}

/**
 * í„´ ìŠ¤íŠ¸ë¦¼ ìš”ì²­ì„ ì‹¤í–‰í•©ë‹ˆë‹¤.
 *
 * @param input - í„´ ì…ë ¥ ë°ì´í„°
 * @param callbacks - ì´ë²¤íŠ¸ ì½œë°±
 * @param options - ìš”ì²­ ì˜µì…˜
 * @returns ì·¨ì†Œ í•¨ìˆ˜
 */
export async function executeTurnStream(
  input: TurnInput,
  callbacks: StreamCallbacks,
  options?: TurnStreamOptions,
): Promise<void> {
  const parser = new NDJSONParser();
  const controller = new AbortController();
  const signal = options?.signal ?? controller.signal;

  // RU-002-S1: AbortError ë°œìƒ ì‹œ onComplete í˜¸ì¶œ ì—¬ë¶€ ì¶”ì 
  let aborted = false;

  try {
    const response = await fetch(TURN_ENDPOINT, {
      method: 'POST',
      headers: {
        'Content-Type': 'application/json',
        Accept: 'application/x-ndjson',
      },
      body: JSON.stringify(input),
      signal,
    });

    if (!response.ok) {
      throw new Error(`HTTP ${response.status}: ${response.statusText}`);
    }

    if (!response.body) {
      throw new Error('Response body is null');
    }

    const reader = response.body.getReader();
    const decoder = new TextDecoder('utf-8');

    // ìŠ¤íŠ¸ë¦¼ ì½ê¸° ë£¨í”„
    while (true) {
      const { done, value } = await reader.read();

      if (done) break;

      const chunk = decoder.decode(value, { stream: true });
      const events = parser.parse(chunk);

      for (const event of events) {
        dispatchEvent(event, callbacks, input.language);
      }
    }

    // ë‚¨ì€ ë²„í¼ í”ŒëŸ¬ì‹œ
    const remaining = parser.flush();
    if (remaining) {
      dispatchEvent(remaining, callbacks, input.language);
    }
  } catch (error) {
    if (error instanceof DOMException && error.name === 'AbortError') {
      // RU-003-S1: Abort(ì·¨ì†Œ) ì •ì±…
      // =========================================================================
      // í˜„ì¬ ì •ì±…(Option B): Abort ì‹œ onCompleteë¥¼ í˜¸ì¶œí•˜ì§€ ì•ŠìŒ
      // - ì´ìœ : ì·¨ì†ŒëŠ” "ì‚¬ìš©ì ì˜ë„"ì´ë¯€ë¡œ ì‹¤íŒ¨ì™€ êµ¬ë¶„í•´ì•¼ í•¨
      // - ì£¼ì˜: ì´ ì •ì±…ì—ì„œëŠ” Cancel ë²„íŠ¼ êµ¬í˜„ ì‹œ í˜¸ì¶œìê°€ ì§ì ‘ UI ë³µêµ¬ í•„ìš”
      //
      // í–¥í›„ Option Aë¡œ ì „í™˜ ê°€ëŠ¥:
      // - Abort ì‹œì—ë„ onComplete í˜¸ì¶œ + ë³„ë„ í”Œë˜ê·¸ë¡œ "ì·¨ì†Œ ì¢…ë£Œ" êµ¬ë¶„
      // - ì¥ì : UIê°€ ë©ˆì¶”ì§€ ì•ŠìŒ (ë³µêµ¬ ì¼ê´€ì„±)
      // - ë‹¨ì : ì·¨ì†Œì™€ ì‹¤íŒ¨ë¥¼ êµ¬ë¶„í•˜ë ¤ë©´ ì´ë²¤íŠ¸ ëª¨ë¸ í™•ì¥ í•„ìš”
      //
      // ê²°ì • ê·¼ê±°: RU-003-S1 Step 3
      // =========================================================================
      aborted = true;
      return;
    }

    const errorMessage = error instanceof Error ? error.message : 'Unknown error occurred';

    // RU-002-S1: ë„¤íŠ¸ì›Œí¬ ì—ëŸ¬ ì‹œì—ë„ onError í˜¸ì¶œ
    callbacks.onError?.({
      type: StreamEventType.ERROR,
      message: errorMessage,
      code: 'STREAM_ERROR',
    });

    // RU-002-S1: ë„¤íŠ¸ì›Œí¬ ì—ëŸ¬ ì‹œ í´ë¼ì´ì–¸íŠ¸ ì¸¡ í´ë°± final ìƒì„±
    // ì„œë²„ì—ì„œ finalì´ ì˜¤ì§€ ëª»í•œ ê²½ìš° UIê°€ ë©ˆì¶”ì§€ ì•Šë„ë¡ í•¨
    const fallback = createClientFallbackTurnOutput(input.language, input.economy_snapshot);
    callbacks.onFinal?.({
      type: StreamEventType.FINAL,
      data: fallback,
    });
  } finally {
    // RU-002-S1: ìŠ¤íŠ¸ë¦¼ ì¢…ë£Œ ì¸ë°”ë¦¬ì–¸íŠ¸ - ì„±ê³µ/ì‹¤íŒ¨ ëª¨ë‘ì—ì„œ onComplete í˜¸ì¶œ ë³´ì¥
    if (!aborted) {
      callbacks.onComplete?.();
    }
  }
}

/**
 * í´ë¼ì´ì–¸íŠ¸ ì¸¡ í´ë°± TurnOutput ìƒì„± (RU-002-S1).
 * ì„œë²„ì—ì„œ finalì´ ì˜¤ì§€ ëª»í•œ ê²½ìš° (ë„¤íŠ¸ì›Œí¬ ì—ëŸ¬ ë“±) ì‚¬ìš©í•©ë‹ˆë‹¤.
 * EconomyëŠ” ìš”ì²­ ì§ì „ ìŠ¤ëƒ…ìƒ·ì„ ê·¸ëŒ€ë¡œ ìœ ì§€í•©ë‹ˆë‹¤.
 * U-044: í•˜ë“œì½”ë”© ë©”ì‹œì§€ ì œê±°, i18n ë¦¬ì†ŒìŠ¤ ì‚¬ìš©.
 */
function createClientFallbackTurnOutput(
  language: Language,
  economySnapshot: { signal: number; memory_shard: number },
): TurnOutput {
  const fallbackNarrative = getErrorMessage('connection_failed', language);

  return {
    language,
    narrative: fallbackNarrative,
    economy: {
      cost: { signal: 0, memory_shard: 0 },
      // RU-002-S1: ì…ë ¥ ìŠ¤ëƒ…ìƒ· ê·¸ëŒ€ë¡œ ìœ ì§€ (ë¹„ìš© 0, ì”ì•¡ ë³€í™” ì—†ìŒ)
      balance_after: {
        signal: economySnapshot.signal,
        memory_shard: economySnapshot.memory_shard,
      },
    },
    safety: {
      blocked: false,
      message: null,
    },
    ui: {
      action_deck: { cards: [] },
      objects: [],
      scene: { image_url: null, alt_text: null },
    },
    world: {
      rules_changed: [],
      inventory_added: [],
      inventory_removed: [],
      quests_updated: [],
      relationships_changed: [],
      memory_pins: [],
    },
    render: {
      image_job: null,
    },
    agent_console: {
      current_phase: 'commit',
      badges: ['schema_fail'],
      repair_count: 1,
    },
  };
}

/**
 * í„´ ìŠ¤íŠ¸ë¦¼ì„ ì‹œì‘í•˜ê³  ì·¨ì†Œ í•¨ìˆ˜ë¥¼ ë°˜í™˜í•©ë‹ˆë‹¤.
 *
 * @param input - í„´ ì…ë ¥ ë°ì´í„°
 * @param callbacks - ì´ë²¤íŠ¸ ì½œë°±
 * @returns ì·¨ì†Œ í•¨ìˆ˜
 */
export function startTurnStream(input: TurnInput, callbacks: StreamCallbacks): () => void {
  const controller = new AbortController();

  executeTurnStream(input, callbacks, { signal: controller.signal });

  return () => controller.abort();
}
</file>

<file path="frontend/src/components/SceneCanvas.tsx">
/**
 * Unknown World - Scene Canvas ì»´í¬ë„ŒíŠ¸
 *
 * RULE-002 ì¤€ìˆ˜: ì±„íŒ… ë²„ë¸”ì´ ì•„ë‹Œ ê²Œì„ UI
 * RULE-009 ì¤€ìˆ˜: ì¢Œí‘œ ê·œì•½ (0~1000 ì •ê·œí™”, bbox=[ymin,xmin,ymax,xmax])
 *
 * U-010[Mvp]: í•«ìŠ¤íŒŸ ì˜¤ë²„ë ˆì´ + í´ë¦­ ì²˜ë¦¬
 * - TurnOutputì˜ objects[]/hotspots[]ë¥¼ ê¸°ë°˜ìœ¼ë¡œ ì˜¤ë²„ë ˆì´ ë Œë”
 * - hover ì‹œ í•˜ì´ë¼ì´íŠ¸/íˆ´íŒ í‘œì‹œ
 * - click ì‹œ object_id + box_2dë¥¼ TurnInputì— í¬í•¨í•´ ì „ì†¡
 *
 * U-012[Mvp]: DnD ë“œë¡­ íƒ€ê²Ÿ í™•ì¥
 * - í•«ìŠ¤íŒŸì„ droppable ì˜ì—­ìœ¼ë¡œ ë§Œë“¤ì–´ ì¸ë²¤í† ë¦¬ ì•„ì´í…œ ë“œë¡­ ì²˜ë¦¬
 * - ë“œë˜ê·¸ ì˜¤ë²„ ì‹œ í•˜ì´ë¼ì´íŠ¸ ê°•í™”
 * - ë“œë¡­ ì„±ê³µ/ì‹¤íŒ¨ ì¦‰ì‹œ ì‹œê°í™”
 *
 * U-020[Mvp]: ì´ë¯¸ì§€ Lazy Render (placeholder/í´ë°±)
 * - RULE-004/008 ì¤€ìˆ˜: í…ìŠ¤íŠ¸ ìš°ì„  + Lazy ì´ë¯¸ì§€ ì •ì±…
 * - Q1 Option A: ì´ì „ ì´ë¯¸ì§€ ìœ ì§€ + ë¡œë”© ì¸ë””ì¼€ì´í„° í‘œì‹œ
 * - ì´ë¯¸ì§€ ì‹¤íŒ¨ ì‹œì—ë„ í•«ìŠ¤íŒŸ/íŒ¨ë„/ë¡œê·¸ëŠ” ê³„ì† ë™ì‘ (í…ìŠ¤íŠ¸-only ì§„í–‰)
 *
 * @module components/SceneCanvas
 */

import { useState, useRef, useCallback, useEffect, useMemo } from 'react';
import { useTranslation } from 'react-i18next';
import { useDroppable } from '@dnd-kit/core';
import type { SceneObject, Box2D } from '../schemas/turn';
import { box2dToPixel, type CanvasSize } from '../utils/box2d';
import {
  DND_TYPE,
  type HotspotDropData,
  isHotspotInteractionAllowed,
  compareHotspotPriority,
} from '../dnd/types';
import { useWorldStore } from '../stores/worldStore';
import { useAgentStore } from '../stores/agentStore';
import { SceneImage } from './SceneImage';

// =============================================================================
// íƒ€ì… ì •ì˜
// =============================================================================

/**
 * í•«ìŠ¤íŒŸ í´ë¦­ ì´ë²¤íŠ¸ ë°ì´í„° (Q1 ê²°ì •: Option B - object_id + box_2d)
 */
export interface HotspotClickData {
  /** í´ë¦­í•œ ì˜¤ë¸Œì íŠ¸ ID */
  object_id: string;
  /** í´ë¦­í•œ ì˜¤ë¸Œì íŠ¸ì˜ ë°”ìš´ë”© ë°•ìŠ¤ (0~1000 ì •ê·œí™”) */
  box_2d: Box2D;
}

interface SceneCanvasProps {
  /** í•«ìŠ¤íŒŸ í´ë¦­ ì½œë°± */
  onHotspotClick?: (data: HotspotClickData) => void;
  /** ìŠ¤íŠ¸ë¦¬ë° ì¤‘ ì—¬ë¶€ (ë¹„í™œì„±í™”ìš©, ìƒëµ ì‹œ agentStore.isStreaming ì‚¬ìš©) */
  disabled?: boolean;
}

// =============================================================================
// ë‚´ë¶€ ì»´í¬ë„ŒíŠ¸: í•«ìŠ¤íŒŸ ì˜¤ë²„ë ˆì´
// =============================================================================

interface HotspotOverlayProps {
  object: SceneObject;
  canvasSize: CanvasSize;
  onClick: (data: HotspotClickData) => void;
  disabled: boolean;
  /** RU-003-S2: ë°ëª¨ ìƒíƒœ ì—¬ë¶€ (ì‹œê°ì  íŒíŠ¸ í•„ìš”) */
  isDemoState?: boolean;
  /** RU-003-S2 Step 2: ìš°ì„ ìˆœìœ„ ê¸°ë°˜ z-index ìŠ¤íƒ€ì¼ */
  style?: React.CSSProperties;
}

/**
 * ê°œë³„ í•«ìŠ¤íŒŸ ì˜¤ë²„ë ˆì´ ì»´í¬ë„ŒíŠ¸ (U-010 + U-012)
 *
 * - í´ë¦­ ì‹œ object_id + box_2d ì „ì†¡ (U-010)
 * - ë“œë¡­ íƒ€ê²Ÿìœ¼ë¡œ ë™ì‘ - dnd-kit useDroppable ì‚¬ìš© (U-012)
 */
function HotspotOverlay({
  object,
  canvasSize,
  onClick,
  disabled,
  isDemoState = false,
  style,
}: HotspotOverlayProps) {
  const [isHovered, setIsHovered] = useState(false);
  const { t } = useTranslation();

  // U-012: useDroppable í›…ìœ¼ë¡œ ë“œë¡­ íƒ€ê²Ÿ ì„¤ì • (RU-003-Q1: ìƒìˆ˜/íƒ€ì… ê¸°ë°˜)
  const dropData: HotspotDropData = {
    type: DND_TYPE.HOTSPOT,
    object_id: object.id,
    box_2d: object.box_2d,
    label: object.label,
  };
  const { isOver, setNodeRef } = useDroppable({
    id: `hotspot-${object.id}`,
    data: dropData,
    disabled,
  });

  // box_2d(0~1000) â†’ px ë³€í™˜
  const pixelBox = box2dToPixel(object.box_2d, canvasSize);

  const handleClick = useCallback(() => {
    if (disabled) return;
    onClick({
      object_id: object.id,
      box_2d: object.box_2d,
    });
  }, [disabled, onClick, object.id, object.box_2d]);

  const handleKeyDown = useCallback(
    (e: React.KeyboardEvent) => {
      if (disabled) return;
      if (e.key === 'Enter' || e.key === ' ') {
        e.preventDefault();
        handleClick();
      }
    },
    [disabled, handleClick],
  );

  // ë“œë˜ê·¸ ì˜¤ë²„ ìƒíƒœ ë˜ëŠ” ë§ˆìš°ìŠ¤ í˜¸ë²„ ìƒíƒœ
  const isHighlighted = isHovered || isOver;

  // RU-003-S2: ë°ëª¨ ìƒíƒœ í´ë˜ìŠ¤ ì¶”ê°€
  const demoClass = isDemoState ? 'demo-target' : '';

  return (
    <div
      ref={setNodeRef}
      className={`hotspot-overlay ${isHighlighted ? 'hovered' : ''} ${disabled ? 'disabled' : ''} ${isOver ? 'drop-target-active' : ''} ${demoClass}`}
      style={{
        position: 'absolute',
        top: `${pixelBox.top}px`,
        left: `${pixelBox.left}px`,
        width: `${pixelBox.width}px`,
        height: `${pixelBox.height}px`,
        ...style,
      }}
      onClick={handleClick}
      onMouseEnter={() => setIsHovered(true)}
      onMouseLeave={() => setIsHovered(false)}
      onKeyDown={handleKeyDown}
      role="button"
      tabIndex={disabled ? -1 : 0}
      aria-label={object.label}
      aria-disabled={disabled}
      data-drop-target={!disabled}
      data-demo-state={isDemoState}
    >
      {/* í˜¸ë²„ ë˜ëŠ” ë“œë˜ê·¸ ì˜¤ë²„ ì‹œ íˆ´íŒ í‘œì‹œ */}
      {isHighlighted && !disabled && (
        <div className="hotspot-tooltip">
          <span className="hotspot-tooltip-label">{object.label}</span>
          {/* RU-003-S2: ë°ëª¨ ìƒíƒœ í‘œì‹œ */}
          {isDemoState && (
            <span className="hotspot-tooltip-demo">{t('scene.hotspot.demo_hint')}</span>
          )}
          {/* U-012: ë“œë˜ê·¸ ì˜¤ë²„ ì‹œ ë“œë¡­ íŒíŠ¸ í‘œì‹œ */}
          {isOver && (
            <span className="hotspot-tooltip-drop-hint">{t('scene.hotspot.drop_hint')}</span>
          )}
          {!isOver && !isDemoState && object.interaction_hint && (
            <span className="hotspot-tooltip-hint">
              {t('scene.hotspot.hint_prefix')}: {object.interaction_hint}
            </span>
          )}
        </div>
      )}
    </div>
  );
}

// =============================================================================
// ë©”ì¸ ì»´í¬ë„ŒíŠ¸
// =============================================================================

/**
 * Scene Canvas ì»´í¬ë„ŒíŠ¸
 *
 * U-010[Mvp]: í•«ìŠ¤íŒŸ ì˜¤ë²„ë ˆì´ + í´ë¦­ ì²˜ë¦¬
 * U-020[Mvp]: Lazy Render (placeholder/í´ë°±)
 * U-031[Mvp]: Placeholder Pack
 *
 * - ìƒíƒœì— ë”°ë¼ placeholder ì´ë¯¸ì§€ì™€ ë¼ë²¨ì„ í‘œì‹œí•©ë‹ˆë‹¤.
 * - 'scene' ìƒíƒœì—ì„œëŠ” ì‹¤ì œ ì´ë¯¸ì§€ë¥¼ ë Œë”ë§í•˜ë©°, ë¡œë“œ ì‹¤íŒ¨ ì‹œ í´ë°±ì„ ì œê³µí•©ë‹ˆë‹¤.
 * - U-020: Q1 Option A - ì´ì „ ì´ë¯¸ì§€ ìœ ì§€ + ë¡œë”© ì¸ë””ì¼€ì´í„° í‘œì‹œ
 * - objects ë°°ì—´ì´ ìˆìœ¼ë©´ í•«ìŠ¤íŒŸ ì˜¤ë²„ë ˆì´ë¥¼ ë Œë”ë§í•©ë‹ˆë‹¤.
 */
export function SceneCanvas({ onHotspotClick, disabled: propsDisabled }: SceneCanvasProps) {
  const { t } = useTranslation();

  // Store ìƒíƒœ (RU-003: ì»´í¬ë„ŒíŠ¸ ë‚´ì—ì„œ ì§ì ‘ êµ¬ë…)
  const state = useWorldStore((state) => state.sceneState);
  const objects = useWorldStore((state) => state.sceneObjects);
  const isStreaming = useAgentStore((state) => state.isStreaming);

  const disabled = propsDisabled ?? isStreaming;

  const { status, imageUrl, message } = state;

  const [canvasSize, setCanvasSize] = useState<CanvasSize>({ width: 0, height: 0 });
  const canvasRef = useRef<HTMLDivElement>(null);

  // RU-003-S2 Step 3: ResizeObserverì— ë””ë°”ìš´ìŠ¤ ì ìš©
  // ë“œë˜ê·¸ ì¤‘ í•«ìŠ¤íŒŸ ì˜ì—­ì´ ê³¼ë„í•˜ê²Œ í”ë“¤ë¦¬ëŠ” ê²ƒì„ ë°©ì§€
  useEffect(() => {
    const element = canvasRef.current;
    if (!element) return;

    let resizeTimeout: ReturnType<typeof setTimeout> | null = null;
    const RESIZE_DEBOUNCE_MS = 100; // ë””ë°”ìš´ìŠ¤ ê°„ê²©

    const resizeObserver = new ResizeObserver((entries) => {
      // ë””ë°”ìš´ìŠ¤: ë§ˆì§€ë§‰ ë¦¬ì‚¬ì´ì¦ˆ ì´ë²¤íŠ¸ í›„ ì¼ì • ì‹œê°„ í›„ì—ë§Œ ì—…ë°ì´íŠ¸
      if (resizeTimeout) {
        clearTimeout(resizeTimeout);
      }
      resizeTimeout = setTimeout(() => {
        for (const entry of entries) {
          const { width, height } = entry.contentRect;
          // ì˜ë¯¸ ìˆëŠ” í¬ê¸° ë³€í™”ë§Œ ì ìš© (5px ì´ìƒ ì°¨ì´)
          setCanvasSize((prev) => {
            if (Math.abs(prev.width - width) > 5 || Math.abs(prev.height - height) > 5) {
              return { width, height };
            }
            return prev;
          });
        }
      }, RESIZE_DEBOUNCE_MS);
    });

    resizeObserver.observe(element);

    // ì´ˆê¸° í¬ê¸° ì„¤ì •
    const rect = element.getBoundingClientRect();
    setCanvasSize({ width: rect.width, height: rect.height });

    return () => {
      if (resizeTimeout) {
        clearTimeout(resizeTimeout);
      }
      resizeObserver.disconnect();
    };
  }, []);

  // í•«ìŠ¤íŒŸ í´ë¦­ í•¸ë“¤ëŸ¬
  const handleHotspotClick = useCallback(
    (data: HotspotClickData) => {
      if (onHotspotClick) {
        onHotspotClick(data);
      }
    },
    [onHotspotClick],
  );

  // RU-003-S2 Step 1: í•«ìŠ¤íŒŸ ë Œë”ë§ ì¡°ê±´ì„ SSOTë¡œ ê³ ì •
  // - isHotspotInteractionAllowed()ë¡œ í—ˆìš© ìƒíƒœ ê²€ì‚¬ (scene, default)
  // - objects ì¡´ì¬ + ìº”ë²„ìŠ¤ í¬ê¸° í™•ë³´
  // U-020: ì´ë¯¸ì§€ ìœ ë¬´ì™€ ë¬´ê´€í•˜ê²Œ í•«ìŠ¤íŒŸì€ ë™ì‘ (RULE-004)
  const isInteractionAllowed = isHotspotInteractionAllowed(status);
  const shouldRenderHotspots = isInteractionAllowed && objects.length > 0 && canvasSize.width > 0;

  // RU-003-S2: ë°ëª¨ ìƒíƒœ ì—¬ë¶€ (ì‹œê°ì  íŒíŠ¸ í•„ìš”)
  const isDemoState = status === 'default';

  // RU-003-S2 Step 2: í•«ìŠ¤íŒŸì„ ë©´ì  ê¸°ì¤€ìœ¼ë¡œ ì •ë ¬ (ì‘ì€ ê²ƒì´ ë’¤ì— = ë†’ì€ z-index)
  const sortedObjects = useMemo(() => {
    if (objects.length <= 1) return objects;
    return [...objects].sort((a, b) => compareHotspotPriority(a.box_2d, b.box_2d));
  }, [objects]);

  return (
    <div ref={canvasRef} className="scene-canvas">
      {/* U-020: ì¥ë©´ ì´ë¯¸ì§€ (Lazy loading + placeholder/í´ë°± í¬í•¨) */}
      <SceneImage status={status} imageUrl={imageUrl} message={message} />

      {/* í•«ìŠ¤íŒŸ ì˜¤ë²„ë ˆì´ ë ˆì´ì–´ (RU-003-S2: ë©´ì ìˆœ ì •ë ¬) */}
      {/* U-020: ì´ë¯¸ì§€ ìœ ë¬´ì™€ ë¬´ê´€í•˜ê²Œ í•«ìŠ¤íŒŸì€ í•­ìƒ ë Œë” (RULE-004) */}
      {shouldRenderHotspots && (
        <div className="hotspot-layer" aria-label={t('scene.hotspot.layer_label')}>
          {sortedObjects.map((obj, index) => (
            <HotspotOverlay
              key={obj.id}
              object={obj}
              canvasSize={canvasSize}
              onClick={handleHotspotClick}
              disabled={disabled}
              isDemoState={isDemoState}
              // RU-003-S2 Step 2: ì¸ë±ìŠ¤ ê¸°ë°˜ z-indexë¡œ ì‘ì€ ê²ƒì´ ìœ„ì— í‘œì‹œ
              style={{ zIndex: index + 1 }}
            />
          ))}
        </div>
      )}
    </div>
  );
}
</file>

<file path="frontend/src/locales/en-US/translation.json">
{
  "language": {
    "toggle": "Change Language",
    "toggle_tooltip": "Click to change language. A new game will start after change.",
    "ko-KR": "í•œêµ­ì–´",
    "en-US": "English"
  },
  "error": {
    "unknown_error": "An unknown error occurred.",
    "response_processing": "[System] An error occurred while processing response data.",
    "connection_failed": "[System] Failed to connect to server. Please try again."
  },
  "profile": {
    "select_title": "Select Your Profile",
    "select_hint": "Each profile has different starting conditions and objectives",
    "or": "or",
    "continue_saved": "Continue Saved Game",
    "change": "Change Profile",
    "change_tooltip": "Start a new game with a different profile",
    "narrator": {
      "name": "Narrator",
      "description": "Explore diverse stories with abundant resources",
      "welcome": "Welcome to the Ancient Library. Forgotten tales slumber within these walls...",
      "items": {
        "ancient_tome": "Ancient Tome",
        "quill_pen": "Quill Pen",
        "memory_fragment": "Memory Fragment"
      },
      "quest": {
        "discover_origin": "Discover the World's Origin",
        "collect_memories": "Collect 3 Memory Fragments"
      },
      "rule": {
        "time_flows": "Flow of Time",
        "time_flows_desc": "Time flows normally",
        "memories_persist": "Memory Persistence",
        "memories_persist_desc": "Once obtained, memories never fade"
      },
      "scene": {
        "bookshelf": "Mysterious Bookshelf",
        "bookshelf_hint": "Ancient books are glowing",
        "portal": "Glowing Portal",
        "portal_hint": "It seems to lead somewhere"
      }
    },
    "explorer": {
      "name": "Explorer",
      "description": "Explore unknown territories and uncover secrets",
      "welcome": "You wake up in a dark maze. You must find the exit and escape...",
      "items": {
        "compass": "Compass",
        "rope": "Rope",
        "lantern": "Lantern",
        "map_fragment": "Map Fragment"
      },
      "quest": {
        "find_exit": "Find the Exit",
        "explore_areas": "Explore 3 Areas",
        "gather_supplies": "Gather Supplies"
      },
      "rule": {
        "gravity": "Gravity Law",
        "gravity_desc": "Objects fall downward",
        "darkness": "Darkness Law",
        "darkness_desc": "You cannot see without light"
      },
      "scene": {
        "door": "Ancient Door",
        "door_hint": "Looks like it needs a key",
        "mechanism": "Strange Mechanism",
        "mechanism_hint": "It might be operable",
        "passage": "Hidden Passage",
        "passage_hint": "Where does it lead?"
      }
    },
    "tech": {
      "name": "Tech Expert",
      "description": "Strategize efficiently with limited resources",
      "welcome": "System boot complete. Find the optimal path with limited energy...",
      "items": {
        "data_core": "Data Core",
        "circuit_board": "Circuit Board",
        "energy_cell": "Energy Cell",
        "scanner": "Scanner Device"
      },
      "quest": {
        "analyze_system": "Complete System Analysis",
        "optimize_resources": "Optimize Resource Efficiency"
      },
      "rule": {
        "energy_conservation": "Energy Conservation",
        "energy_conservation_desc": "Energy is neither created nor destroyed",
        "data_integrity": "Data Integrity",
        "data_integrity_desc": "Corrupted data cannot be recovered",
        "system_limits": "System Limits",
        "system_limits_desc": "There are limits to concurrent processing"
      },
      "scene": {
        "terminal": "Main Terminal",
        "terminal_hint": "You can access the system",
        "conduit": "Power Conduit",
        "conduit_hint": "Energy is flowing through it"
      }
    }
  },
  "reset": {
    "button": "Reset",
    "confirm": "Click again to confirm",
    "cancel": "Cancel",
    "tooltip": "Return to the initial state of current profile"
  },
  "demo": {
    "items": {
      "keycard-alpha": {
        "name": "Keycard A"
      },
      "medkit": {
        "name": "Medkit"
      },
      "flashlight": {
        "name": "Flashlight"
      },
      "data-chip": {
        "name": "Data Chip"
      }
    },
    "scene": {
      "terminal": {
        "label": "Terminal",
        "hint": "An active terminal"
      },
      "door": {
        "label": "Door",
        "hint": "It appears to be locked"
      }
    },
    "quest": {
      "terminal": {
        "label": "Access the terminal"
      },
      "escape": {
        "label": "Find facility exit"
      },
      "collect": {
        "label": "Collect data chips"
      }
    },
    "rule": {
      "gravity": {
        "label": "Gravity Law",
        "description": "Objects fall downward"
      },
      "time": {
        "label": "Time Flow",
        "description": "Time flows at normal speed"
      }
    }
  },
  "quest": {
    "empty": "[ NO OBJECTIVES ]",
    "completed": "DONE",
    "section": {
      "active": "Active",
      "completed": "Completed"
    }
  },
  "rule_board": {
    "empty": "[ NO RULES ]",
    "active_count": "Active Rules: {{count}}"
  },
  "mutation": {
    "empty": "[ NO MUTATIONS ]",
    "timeline_title": "Mutation Timeline",
    "event_count": "{{count}} events",
    "more_events": "+{{count}} more",
    "turn_label": "T{{turn}}",
    "type": {
      "added": "Added",
      "modified": "Modified",
      "removed": "Removed"
    }
  },
  "scene": {
    "status": {
      "default": "NO SIGNAL DATA",
      "loading": "SYNCHRONIZING...",
      "offline": "CONNECTION LOST",
      "blocked": "ACCESS RESTRICTED",
      "low_signal": "LOW SIGNAL",
      "image_error": "Unable to load scene image.",
      "image_loading": "Loading scene image...",
      "image_generating": "Generating new scene...",
      "initial_sync": "Awaiting global data synchronization...",
      "syncing": "Synchronizing data...",
      "alt": "Scene Image"
    },
    "hotspot": {
      "layer_label": "Clickable Objects Area",
      "hint_prefix": "Hint",
      "click_action": "Click {{label}}",
      "drop_hint": "Drop here to use",
      "drop_action": "Use {{item}} on {{target}}",
      "drop_invalid": "You cannot use {{item}} there.",
      "demo_hint": "[DEMO TARGET]"
    }
  },
  "agent": {
    "console": {
      "queue": "Queue",
      "badges": "Badges",
      "repair": "Auto-repair",
      "status": {
        "idle": "IDLE",
        "processing": "PROCESSING"
      },
      "badges_empty": "[ Awaiting Validation ]",
      "repaired": "(Repaired)",
      "phase": {
        "parse": "Parse",
        "validate": "Validate",
        "plan": "Plan",
        "resolve": "Resolve",
        "render": "Render",
        "verify": "Verify",
        "commit": "Commit"
      },
      "badge": {
        "schema": "Schema",
        "economy": "Economy",
        "safety": "Safety",
        "consistency": "Consistency",
        "ok": "OK",
        "fail": "FAIL"
      }
    }
  },
  "ui": {
    "logo": "UNKNOWN WORLD",
    "command_placeholder": "Enter command...",
    "processing": "Processing...",
    "execute": "EXECUTE",
    "wait": "WAIT",
    "panel_placeholder": "[ Ready ]",
    "scale_decrease": "Decrease text size",
    "scale_increase": "Increase text size",
    "scale_label": "UI Scale Settings"
  },
  "economy": {
    "signal": "Signal",
    "shard": "Shard",
    "signal_cost": "Signal cost",
    "shard_cost": "Shard cost",
    "risk_level": "Risk level",
    "hud_label": "Economy Status",
    "estimated_cost": "Est. Cost",
    "confirmed_cost": "Confirmed",
    "insufficient_funds": "Insufficient funds",
    "low_balance_warning": "Low balance",
    "alternatives_title": "Alternatives",
    "alternative_text_only": "Text-only (no images)",
    "alternative_low_quality": "Low quality / Fast response",
    "ledger_title": "Recent Ledger",
    "ledger_empty": "[ NO HISTORY ]",
    "model_label": {
      "FAST": "Fast",
      "QUALITY": "Quality",
      "CHEAP": "Cheap",
      "REF": "Ref"
    }
  },
  "connection": {
    "online": "ONLINE",
    "offline": "OFFLINE"
  },
  "inventory": {
    "empty": "[ NO ITEMS ]",
    "grid_label": "Inventory Items",
    "item_label": "{{name}} (Qty: {{quantity}})",
    "drag_hint": "Drag to use"
  },
  "panel": {
    "inventory": {
      "title": "Inventory",
      "placeholder": "[ Drag & Drop Area ]"
    },
    "quest": {
      "title": "Quest",
      "placeholder": "[ Objectives / Quest List ]"
    },
    "rule_board": {
      "title": "Rule Board",
      "placeholder": "[ World Rules / Mutation Timeline ]"
    },
    "agent_console": {
      "title": "Agent Console"
    },
    "memory_pin": {
      "title": "Memory Pin",
      "placeholder": "[ Pinned Memories / Clues ]"
    },
    "scanner": {
      "title": "Scanner",
      "placeholder": "[ Image Upload Slot ]"
    }
  },
  "scanner": {
    "dropzone_label": "Drop image or click to upload",
    "dropzone_text": "Drop Image Here",
    "dropzone_hint": "Or click to browse files",
    "upload_label": "Upload image",
    "preview_alt": "Upload image preview",
    "uploading": "Uploading...",
    "analyzing": "Analyzing...",
    "retry": "Retry",
    "cancel": "Cancel",
    "select_items": "Select items to add to inventory",
    "add_to_inventory": "Add ({{count}})",
    "detected_objects": "Objects detected: {{count}}",
    "item_candidates": "Item candidates: {{count}}",
    "no_candidates": "No item candidates found",
    "error": {
      "unsupported_format": "Unsupported image format",
      "file_too_large": "File too large (max 20MB)",
      "unknown": "An unknown error occurred"
    },
    "item_type": {
      "key": "Key",
      "weapon": "Weapon",
      "tool": "Tool",
      "clue": "Clue",
      "material": "Material",
      "consumable": "Consumable",
      "document": "Document",
      "artifact": "Artifact"
    }
  },
  "action": {
    "default": {
      "explore": {
        "label": "Explore",
        "description": "Look around"
      },
      "investigate": {
        "label": "Investigate",
        "description": "Examine closely"
      },
      "talk": {
        "label": "Talk",
        "description": "Start a conversation"
      }
    },
    "card_select": "Card selected: {{cardId}}",
    "deck_label": "Action Cards",
    "alternative": "ALT",
    "insufficient_balance": "Insufficient balance",
    "all_disabled_notice": "No actions available. Check alternatives.",
    "risk": {
      "low": "Low",
      "medium": "Med",
      "high": "High"
    },
    "cost_range": "{{min}}~{{max}}"
  },
  "narrative": {
    "welcome": "Welcome to the Unknown World...",
    "turn_label": "[TURN {{turn}}]",
    "streaming_label": "[STREAMING]"
  }
}
</file>

<file path="frontend/src/locales/ko-KR/translation.json">
{
  "language": {
    "toggle": "ì–¸ì–´ ë³€ê²½",
    "toggle_tooltip": "í´ë¦­í•˜ì—¬ ì–¸ì–´ë¥¼ ë³€ê²½í•©ë‹ˆë‹¤. ë³€ê²½ í›„ ìƒˆ ê²Œì„ì´ ì‹œì‘ë©ë‹ˆë‹¤.",
    "ko-KR": "í•œêµ­ì–´",
    "en-US": "English"
  },
  "error": {
    "unknown_error": "ì•Œ ìˆ˜ ì—†ëŠ” ì˜¤ë¥˜ê°€ ë°œìƒí–ˆìŠµë‹ˆë‹¤.",
    "response_processing": "[ì‹œìŠ¤í…œ] ì‘ë‹µ ë°ì´í„°ë¥¼ ì²˜ë¦¬í•˜ëŠ” ì¤‘ ë¬¸ì œê°€ ë°œìƒí–ˆìŠµë‹ˆë‹¤.",
    "connection_failed": "[ì‹œìŠ¤í…œ] ì„œë²„ ì—°ê²°ì— ì‹¤íŒ¨í–ˆìŠµë‹ˆë‹¤. ë‹¤ì‹œ ì‹œë„í•´ ì£¼ì„¸ìš”."
  },
  "profile": {
    "select_title": "í”„ë¡œí•„ì„ ì„ íƒí•˜ì„¸ìš”",
    "select_hint": "í”„ë¡œí•„ë§ˆë‹¤ ë‹¤ë¥¸ ì‹œì‘ ì¡°ê±´ê³¼ ëª©í‘œê°€ ìˆìŠµë‹ˆë‹¤",
    "or": "ë˜ëŠ”",
    "continue_saved": "ì €ì¥ëœ ê²Œì„ ê³„ì†í•˜ê¸°",
    "change": "í”„ë¡œí•„ ë³€ê²½",
    "change_tooltip": "ë‹¤ë¥¸ í”„ë¡œí•„ë¡œ ìƒˆ ê²Œì„ ì‹œì‘",
    "narrator": {
      "name": "ì„œì‚¬ê¾¼",
      "description": "í’ë¶€í•œ ìì›ìœ¼ë¡œ ë‹¤ì–‘í•œ ì´ì•¼ê¸°ë¥¼ íƒí—˜í•˜ì„¸ìš”",
      "welcome": "ê³ ëŒ€ì˜ ë„ì„œê´€ì— ì˜¤ì‹  ê²ƒì„ í™˜ì˜í•©ë‹ˆë‹¤. ì´ê³³ì—ëŠ” ìŠí˜€ì§„ ì´ì•¼ê¸°ë“¤ì´ ì ë“¤ì–´ ìˆìŠµë‹ˆë‹¤...",
      "items": {
        "ancient_tome": "ê³ ëŒ€ ì„œì±…",
        "quill_pen": "ê¹ƒíœ",
        "memory_fragment": "ê¸°ì–µ ì¡°ê°"
      },
      "quest": {
        "discover_origin": "ì„¸ê³„ì˜ ê¸°ì›ì„ ë°œê²¬í•˜ê¸°",
        "collect_memories": "ê¸°ì–µ ì¡°ê° 3ê°œ ìˆ˜ì§‘í•˜ê¸°"
      },
      "rule": {
        "time_flows": "ì‹œê°„ì˜ íë¦„",
        "time_flows_desc": "ì‹œê°„ì€ ì •ìƒì ìœ¼ë¡œ íë¦…ë‹ˆë‹¤",
        "memories_persist": "ê¸°ì–µì˜ ì§€ì†",
        "memories_persist_desc": "í•œë²ˆ ì–»ì€ ê¸°ì–µì€ ì‚¬ë¼ì§€ì§€ ì•ŠìŠµë‹ˆë‹¤"
      },
      "scene": {
        "bookshelf": "ì‹ ë¹„í•œ ì±…ì¥",
        "bookshelf_hint": "ì˜¤ë˜ëœ ì±…ë“¤ì´ ë¹›ë‚˜ê³  ìˆë‹¤",
        "portal": "ë¹›ë‚˜ëŠ” í¬íƒˆ",
        "portal_hint": "ì–´ë”˜ê°€ë¡œ í†µí•˜ëŠ” ê²ƒ ê°™ë‹¤"
      }
    },
    "explorer": {
      "name": "íƒí—˜ê°€",
      "description": "ë¯¸ì§€ì˜ ì˜ì—­ì„ íƒí—˜í•˜ê³  ë¹„ë°€ì„ ë°œê²¬í•˜ì„¸ìš”",
      "welcome": "ì–´ë‘ìš´ ë¯¸ë¡œì—ì„œ ëˆˆì„ ë–´ìŠµë‹ˆë‹¤. ì¶œêµ¬ë¥¼ ì°¾ì•„ ì´ê³³ì„ íƒˆì¶œí•´ì•¼ í•©ë‹ˆë‹¤...",
      "items": {
        "compass": "ë‚˜ì¹¨ë°˜",
        "rope": "ë°§ì¤„",
        "lantern": "ëœí„´",
        "map_fragment": "ì§€ë„ ì¡°ê°"
      },
      "quest": {
        "find_exit": "íƒˆì¶œêµ¬ ì°¾ê¸°",
        "explore_areas": "3ê°œ êµ¬ì—­ íƒí—˜í•˜ê¸°",
        "gather_supplies": "ë³´ê¸‰í’ˆ ìˆ˜ì§‘"
      },
      "rule": {
        "gravity": "ì¤‘ë ¥ ë²•ì¹™",
        "gravity_desc": "ë¬¼ì²´ëŠ” ì•„ë˜ë¡œ ë–¨ì–´ì§‘ë‹ˆë‹¤",
        "darkness": "ì–´ë‘ ì˜ ë²•ì¹™",
        "darkness_desc": "ë¹› ì—†ì´ëŠ” ì•ì„ ë³¼ ìˆ˜ ì—†ìŠµë‹ˆë‹¤"
      },
      "scene": {
        "door": "ê³ ëŒ€ì˜ ë¬¸",
        "door_hint": "ì—´ì‡ ê°€ í•„ìš”í•´ ë³´ì¸ë‹¤",
        "mechanism": "ì´ìƒí•œ ì¥ì¹˜",
        "mechanism_hint": "ì‘ë™ì‹œí‚¬ ìˆ˜ ìˆì„ ê²ƒ ê°™ë‹¤",
        "passage": "ìˆ¨ê²¨ì§„ í†µë¡œ",
        "passage_hint": "ì–´ë””ë¡œ ì´ì–´ì§ˆê¹Œ?"
      }
    },
    "tech": {
      "name": "ê¸°ìˆ  ì „ë¬¸ê°€",
      "description": "ì œí•œëœ ìì›ìœ¼ë¡œ íš¨ìœ¨ì ì¸ ì „ëµì„ ì„¸ìš°ì„¸ìš”",
      "welcome": "ì‹œìŠ¤í…œ ë¶€íŒ… ì™„ë£Œ. ì œí•œëœ ì—ë„ˆì§€ë¡œ ìµœì ì˜ ê²½ë¡œë¥¼ ì°¾ì•„ì•¼ í•©ë‹ˆë‹¤...",
      "items": {
        "data_core": "ë°ì´í„° ì½”ì–´",
        "circuit_board": "íšŒë¡œ ê¸°íŒ",
        "energy_cell": "ì—ë„ˆì§€ ì…€",
        "scanner": "ìŠ¤ìºë„ˆ ì¥ì¹˜"
      },
      "quest": {
        "analyze_system": "ì‹œìŠ¤í…œ ë¶„ì„ ì™„ë£Œí•˜ê¸°",
        "optimize_resources": "ìì› íš¨ìœ¨ ìµœì í™”í•˜ê¸°"
      },
      "rule": {
        "energy_conservation": "ì—ë„ˆì§€ ë³´ì¡´",
        "energy_conservation_desc": "ì—ë„ˆì§€ëŠ” ìƒì„±ë˜ê±°ë‚˜ ì†Œë©¸ë˜ì§€ ì•ŠìŠµë‹ˆë‹¤",
        "data_integrity": "ë°ì´í„° ë¬´ê²°ì„±",
        "data_integrity_desc": "ì†ìƒëœ ë°ì´í„°ëŠ” ë³µêµ¬í•  ìˆ˜ ì—†ìŠµë‹ˆë‹¤",
        "system_limits": "ì‹œìŠ¤í…œ í•œê³„",
        "system_limits_desc": "ë™ì‹œ ì²˜ë¦¬ëŸ‰ì— ì œí•œì´ ìˆìŠµë‹ˆë‹¤"
      },
      "scene": {
        "terminal": "ë©”ì¸ í„°ë¯¸ë„",
        "terminal_hint": "ì‹œìŠ¤í…œì— ì ‘ì†í•  ìˆ˜ ìˆë‹¤",
        "conduit": "ì „ë ¥ ë„ê´€",
        "conduit_hint": "ì—ë„ˆì§€ê°€ íë¥´ê³  ìˆë‹¤"
      }
    }
  },
  "reset": {
    "button": "ë¦¬ì…‹",
    "confirm": "ë‹¤ì‹œ í´ë¦­í•˜ì—¬ í™•ì¸",
    "cancel": "ì·¨ì†Œ",
    "tooltip": "í˜„ì¬ í”„ë¡œí•„ì˜ ì´ˆê¸° ìƒíƒœë¡œ ë˜ëŒë¦½ë‹ˆë‹¤"
  },
  "demo": {
    "items": {
      "keycard-alpha": {
        "name": "í‚¤ì¹´ë“œ A"
      },
      "medkit": {
        "name": "ì‘ê¸‰ í‚¤íŠ¸"
      },
      "flashlight": {
        "name": "ì†ì „ë“±"
      },
      "data-chip": {
        "name": "ë°ì´í„°ì¹©"
      }
    },
    "scene": {
      "terminal": {
        "label": "í„°ë¯¸ë„",
        "hint": "í™œì„±í™”ëœ í„°ë¯¸ë„ì´ë‹¤"
      },
      "door": {
        "label": "ë¬¸",
        "hint": "ì ê²¨ìˆëŠ” ê²ƒ ê°™ë‹¤"
      }
    },
    "quest": {
      "terminal": {
        "label": "í„°ë¯¸ë„ì— ì ‘ì†í•˜ê¸°"
      },
      "escape": {
        "label": "ì‹œì„¤ íƒˆì¶œêµ¬ ì°¾ê¸°"
      },
      "collect": {
        "label": "ë°ì´í„°ì¹© ìˆ˜ì§‘"
      }
    },
    "rule": {
      "gravity": {
        "label": "ì¤‘ë ¥ ë²•ì¹™",
        "description": "ë¬¼ì²´ëŠ” ì•„ë˜ë¡œ ë–¨ì–´ì§„ë‹¤"
      },
      "time": {
        "label": "ì‹œê°„ íë¦„",
        "description": "ì‹œê°„ì€ ì •ìƒ ì†ë„ë¡œ íë¥¸ë‹¤"
      }
    }
  },
  "quest": {
    "empty": "[ ëª©í‘œ ì—†ìŒ ]",
    "completed": "ì™„ë£Œ",
    "section": {
      "active": "ì§„í–‰ ì¤‘",
      "completed": "ì™„ë£Œë¨"
    }
  },
  "rule_board": {
    "empty": "[ ê·œì¹™ ì—†ìŒ ]",
    "active_count": "í™œì„± ê·œì¹™: {{count}}ê°œ"
  },
  "mutation": {
    "empty": "[ ë³€í˜• ì´ë ¥ ì—†ìŒ ]",
    "timeline_title": "ë³€í˜• íƒ€ì„ë¼ì¸",
    "event_count": "{{count}}ê°œ ì´ë²¤íŠ¸",
    "more_events": "+{{count}}ê°œ ë” ë³´ê¸°",
    "turn_label": "T{{turn}}",
    "type": {
      "added": "ì¶”ê°€ë¨",
      "modified": "ìˆ˜ì •ë¨",
      "removed": "ì œê±°ë¨"
    }
  },
  "scene": {
    "status": {
      "default": "ë°ì´í„° ëŒ€ê¸° ì¤‘",
      "loading": "ë™ê¸°í™” ì¤‘...",
      "offline": "ì—°ê²° ëŠê¹€",
      "blocked": "ì ‘ê·¼ ì œí•œë¨",
      "low_signal": "ì‹ í˜¸ ì•½í•¨",
      "image_error": "ì¥ë©´ ì´ë¯¸ì§€ë¥¼ ë¶ˆëŸ¬ì˜¬ ìˆ˜ ì—†ìŠµë‹ˆë‹¤.",
      "image_loading": "ì¥ë©´ ì´ë¯¸ì§€ ë¡œë”© ì¤‘...",
      "image_generating": "ìƒˆ ì¥ë©´ ìƒì„± ì¤‘...",
      "initial_sync": "ì „ì—­ ë°ì´í„° ë™ê¸°í™” ëŒ€ê¸° ì¤‘...",
      "syncing": "ë°ì´í„° ë™ê¸°í™” ì¤‘...",
      "alt": "ì¥ë©´ ì´ë¯¸ì§€"
    },
    "hotspot": {
      "layer_label": "í´ë¦­ ê°€ëŠ¥í•œ ì˜¤ë¸Œì íŠ¸ ì˜ì—­",
      "hint_prefix": "íŒíŠ¸",
      "click_action": "{{label}} í´ë¦­",
      "drop_hint": "ì—¬ê¸°ì— ë“œë¡­í•˜ì—¬ ì‚¬ìš©",
      "drop_action": "{{item}}ì„(ë¥¼) {{target}}ì— ì‚¬ìš©",
      "drop_invalid": "ê·¸ê³³ì—ëŠ” {{item}}ì„(ë¥¼) ì‚¬ìš©í•  ìˆ˜ ì—†ìŠµë‹ˆë‹¤.",
      "demo_hint": "[ë°ëª¨ ëŒ€ìƒ]"
    }
  },
  "agent": {
    "console": {
      "queue": "ëŒ€ê¸°ì—´",
      "badges": "ê²€ì¦ ë°°ì§€",
      "repair": "ìë™ ë³µêµ¬",
      "status": {
        "idle": "ëŒ€ê¸° ì¤‘",
        "processing": "ì²˜ë¦¬ ì¤‘"
      },
      "badges_empty": "[ ê²€ì¦ ëŒ€ê¸° ì¤‘ ]",
      "repaired": "(ë³µêµ¬ë¨)",
      "phase": {
        "parse": "Parse",
        "validate": "Validate",
        "plan": "Plan",
        "resolve": "Resolve",
        "render": "Render",
        "verify": "Verify",
        "commit": "Commit"
      },
      "badge": {
        "schema": "Schema",
        "economy": "Economy",
        "safety": "Safety",
        "consistency": "Consistency",
        "ok": "OK",
        "fail": "FAIL"
      }
    }
  },
  "ui": {
    "logo": "UNKNOWN WORLD",
    "command_placeholder": "ëª…ë ¹ì„ ì…ë ¥í•˜ì„¸ìš”...",
    "processing": "ì²˜ë¦¬ ì¤‘...",
    "execute": "ì‹¤í–‰",
    "wait": "ëŒ€ê¸°",
    "panel_placeholder": "[ ì¤€ë¹„ ì¤‘ ]",
    "scale_decrease": "ê¸€ì í¬ê¸° ì¤„ì´ê¸°",
    "scale_increase": "ê¸€ì í¬ê¸° ëŠ˜ë¦¬ê¸°",
    "scale_label": "UI ìŠ¤ì¼€ì¼ ì„¤ì •"
  },
  "economy": {
    "signal": "Signal",
    "shard": "Shard",
    "signal_cost": "Signal ì†Œëª¨",
    "shard_cost": "Shard ì†Œëª¨",
    "risk_level": "ìœ„í—˜ë„",
    "hud_label": "ì¬í™” í˜„í™©",
    "estimated_cost": "ì˜ˆìƒ ë¹„ìš©",
    "confirmed_cost": "í™•ì • ë¹„ìš©",
    "insufficient_funds": "ì”ì•¡ ë¶€ì¡±",
    "low_balance_warning": "ì”ì•¡ì´ ë¶€ì¡±í•©ë‹ˆë‹¤",
    "alternatives_title": "ëŒ€ì•ˆ í–‰ë™",
    "alternative_text_only": "í…ìŠ¤íŠ¸ë§Œ ìƒì„± (ì´ë¯¸ì§€ ì—†ìŒ)",
    "alternative_low_quality": "ì €í’ˆì§ˆ/ë¹ ë¥¸ ì‘ë‹µ ì„ íƒ",
    "ledger_title": "ìµœê·¼ ì›ì¥ ì´ë ¥",
    "ledger_empty": "[ ì´ë ¥ ì—†ìŒ ]",
    "model_label": {
      "FAST": "ë¹ ë¦„",
      "QUALITY": "ê³ í’ˆì§ˆ",
      "CHEAP": "ì €ë¹„ìš©",
      "REF": "ì°¸ì¡°"
    }
  },
  "connection": {
    "online": "ì˜¨ë¼ì¸",
    "offline": "ì˜¤í”„ë¼ì¸"
  },
  "inventory": {
    "empty": "[ ì•„ì´í…œ ì—†ìŒ ]",
    "grid_label": "ì¸ë²¤í† ë¦¬ ì•„ì´í…œ ëª©ë¡",
    "item_label": "{{name}} (ìˆ˜ëŸ‰: {{quantity}})",
    "drag_hint": "ë“œë˜ê·¸í•˜ì—¬ ì‚¬ìš©"
  },
  "panel": {
    "inventory": {
      "title": "Inventory",
      "placeholder": "[ ë“œë˜ê·¸ ì•¤ ë“œë¡­ ì˜ì—­ ]"
    },
    "quest": {
      "title": "Quest",
      "placeholder": "[ ëª©í‘œ/í€˜ìŠ¤íŠ¸ ëª©ë¡ ]"
    },
    "rule_board": {
      "title": "Rule Board",
      "placeholder": "[ ì›”ë“œ ê·œì¹™/ë³€í˜• íƒ€ì„ë¼ì¸ ]"
    },
    "agent_console": {
      "title": "Agent Console"
    },
    "memory_pin": {
      "title": "Memory Pin",
      "placeholder": "[ ê³ ì •ëœ ê¸°ì–µ/ë‹¨ì„œ ]"
    },
    "scanner": {
      "title": "Scanner",
      "placeholder": "[ ì´ë¯¸ì§€ ì—…ë¡œë“œ ìŠ¬ë¡¯ ]"
    }
  },
  "scanner": {
    "dropzone_label": "ì´ë¯¸ì§€ë¥¼ ë“œë¡­í•˜ê±°ë‚˜ í´ë¦­í•˜ì—¬ ì—…ë¡œë“œ",
    "dropzone_text": "ì´ë¯¸ì§€ë¥¼ ë“œë¡­í•˜ì„¸ìš”",
    "dropzone_hint": "ë˜ëŠ” í´ë¦­í•˜ì—¬ íŒŒì¼ ì„ íƒ",
    "upload_label": "ì´ë¯¸ì§€ ì—…ë¡œë“œ",
    "preview_alt": "ì—…ë¡œë“œ ì´ë¯¸ì§€ ë¯¸ë¦¬ë³´ê¸°",
    "uploading": "ì—…ë¡œë“œ ì¤‘...",
    "analyzing": "ë¶„ì„ ì¤‘...",
    "retry": "ë‹¤ì‹œ ì‹œë„",
    "cancel": "ì·¨ì†Œ",
    "select_items": "ì¸ë²¤í† ë¦¬ì— ì¶”ê°€í•  ì•„ì´í…œì„ ì„ íƒí•˜ì„¸ìš”",
    "add_to_inventory": "ì¶”ê°€ ({{count}}ê°œ)",
    "detected_objects": "ê°ì§€ëœ ì˜¤ë¸Œì íŠ¸: {{count}}ê°œ",
    "item_candidates": "ì•„ì´í…œ í›„ë³´: {{count}}ê°œ",
    "no_candidates": "ì•„ì´í…œ í›„ë³´ë¥¼ ì°¾ì§€ ëª»í–ˆìŠµë‹ˆë‹¤",
    "error": {
      "unsupported_format": "ì§€ì›í•˜ì§€ ì•ŠëŠ” ì´ë¯¸ì§€ í˜•ì‹ì…ë‹ˆë‹¤",
      "file_too_large": "íŒŒì¼ì´ ë„ˆë¬´ í½ë‹ˆë‹¤ (ìµœëŒ€ 20MB)",
      "unknown": "ì•Œ ìˆ˜ ì—†ëŠ” ì˜¤ë¥˜ê°€ ë°œìƒí–ˆìŠµë‹ˆë‹¤"
    },
    "item_type": {
      "key": "ì—´ì‡ ",
      "weapon": "ë¬´ê¸°",
      "tool": "ë„êµ¬",
      "clue": "ë‹¨ì„œ",
      "material": "ì¬ë£Œ",
      "consumable": "ì†Œëª¨í’ˆ",
      "document": "ë¬¸ì„œ",
      "artifact": "ìœ ë¬¼"
    }
  },
  "action": {
    "default": {
      "explore": {
        "label": "íƒìƒ‰í•˜ê¸°",
        "description": "ì£¼ë³€ì„ ì‚´í´ë³¸ë‹¤"
      },
      "investigate": {
        "label": "ì¡°ì‚¬í•˜ê¸°",
        "description": "ìì„¸íˆ ì‚´í´ë³¸ë‹¤"
      },
      "talk": {
        "label": "ëŒ€í™”í•˜ê¸°",
        "description": "ë§ì„ ê±¸ì–´ë³¸ë‹¤"
      }
    },
    "card_select": "ì¹´ë“œ ì„ íƒ: {{cardId}}",
    "deck_label": "í–‰ë™ ì„ íƒ ì¹´ë“œ",
    "alternative": "ëŒ€ì•ˆ",
    "insufficient_balance": "ì”ì•¡ ë¶€ì¡±",
    "all_disabled_notice": "ì‹¤í–‰ ê°€ëŠ¥í•œ í–‰ë™ì´ ì—†ìŠµë‹ˆë‹¤. ëŒ€ì•ˆì„ í™•ì¸í•˜ì„¸ìš”.",
    "risk": {
      "low": "ë‚®ìŒ",
      "medium": "ë³´í†µ",
      "high": "ë†’ìŒ"
    },
    "cost_range": "{{min}}~{{max}}"
  },
  "narrative": {
    "welcome": "ë¯¸ì§€ì˜ ì„¸ê³„ì— ì˜¤ì‹  ê²ƒì„ í™˜ì˜í•©ë‹ˆë‹¤...",
    "turn_label": "[TURN {{turn}}]",
    "streaming_label": "[STREAMING]"
  }
}
</file>

<file path="frontend/src/App.tsx">
/**
 * Unknown World - ë©”ì¸ ê²Œì„ UI ë ˆì´ì•„ì›ƒ
 *
 * RULE-002 ì¤€ìˆ˜: ì±„íŒ… ë²„ë¸” UI ê¸ˆì§€
 * - ë‚´ëŸ¬í‹°ë¸ŒëŠ” "ì±„íŒ…"ì´ ì•„ë‹ˆë¼ "ê²Œì„ ë¡œê·¸/ë‚´ëŸ¬í‹°ë¸Œ í”¼ë“œ" í˜•íƒœ
 * - ê³ ì • íŒ¨ë„: Scene Canvas, Action Deck, Inventory, Quest,
 *   Rule Board, Economy HUD, Agent Console, Scanner Slot
 *
 * RULE-008: Agent Consoleì—ì„œ ë‹¨ê³„/ë°°ì§€/ë³µêµ¬ë§Œ í‘œì‹œ (í”„ë¡¬í”„íŠ¸ ë…¸ì¶œ ê¸ˆì§€)
 *
 * RU-003-Q4: App.tsxëŠ” "ë ˆì´ì•„ì›ƒ + ì´ë²¤íŠ¸ ë¼ìš°íŒ…"ì— ì§‘ì¤‘
 * - ì„¸ì…˜/ì›”ë“œ ìƒíƒœëŠ” worldStoreë¡œ ì´ë™
 * - TurnOutput ë°˜ì˜ì€ worldStore.applyTurnOutputìœ¼ë¡œ ë‹¨ì¼í™”
 *
 * RU-004-Q4: ì„¸ì…˜ ë¼ì´í”„ì‚¬ì´í´ SSOT
 * - ì„¸ì…˜ ì´ˆê¸°í™”/ë³µì›/ë¦¬ì…‹/ë³€ê²½ì€ sessionLifecycle ëª¨ë“ˆë¡œ ë‹¨ì¼í™”
 * - App.tsxëŠ” ì„¸ì…˜ API í˜¸ì¶œ + UI ì „í™˜ë§Œ ë‹´ë‹¹
 *
 * U-015[Mvp]: SaveGame + Reset + Demo Profiles
 * - í”„ë¡œí•„ ì„ íƒ í™”ë©´ â†’ ê²Œì„ ì‹œì‘ í”Œë¡œìš°
 * - ë¦¬ì…‹ ë²„íŠ¼ìœ¼ë¡œ í”„ë¡œí•„ ì´ˆê¸° ìƒíƒœë¡œ ë³µêµ¬
 * - localStorage ê¸°ë°˜ ì„¸ì´ë¸Œ/ë¡œë“œ
 *
 * @see vibe/ref/frontend-style-guide.md
 * @see vibe/prd.md 6.7/6.8/9ì¥
 */

import { useState, useCallback, useEffect, useMemo } from 'react';
import { useTranslation } from 'react-i18next';
import {
  DndContext,
  DragEndEvent,
  DragStartEvent,
  useSensor,
  useSensors,
  PointerSensor,
  KeyboardSensor,
} from '@dnd-kit/core';
import { Panel } from './components/Panel';
import { GameHeader } from './components/GameHeader';
import { NarrativeFeed } from './components/NarrativeFeed';
import { AgentConsole } from './components/AgentConsole';
import { EconomyHud } from './components/EconomyHud';
import { SceneCanvas, type HotspotClickData } from './components/SceneCanvas';
import { ActionDeck } from './components/ActionDeck';
import { InventoryPanel } from './components/InventoryPanel';
// U-013: Quest + Rule Board + Mutation Timeline
import { QuestPanel } from './components/QuestPanel';
import { RuleBoard } from './components/RuleBoard';
import { MutationTimeline } from './components/MutationTimeline';
// U-022: Scanner Slot
import { ScannerSlot } from './components/ScannerSlot';
// U-015: SaveGame + Demo Profiles
import { DemoProfileSelect } from './components/DemoProfileSelect';
import { ResetButton, ChangeProfileButton } from './components/ResetButton';
import { useAgentStore } from './stores/agentStore';
import { useInventoryStore } from './stores/inventoryStore';
import { useUIPrefsStore, applyUIPrefsToDOM } from './stores/uiPrefsStore';
import { useWorldStore } from './stores/worldStore';
import { useTurnRunner } from './turn/turnRunner';
import type { ActionCard, DropInput } from './schemas/turn';
import { getCurrentThemeFromDOM } from './demo/demoFixtures';
import { isInventoryDragData, isHotspotDropData } from './dnd/types';
// RU-004-Q4: ì„¸ì…˜ ë¼ì´í”„ì‚¬ì´í´ SSOT
// U-044: ì„¸ì…˜ ì–¸ì–´ SSOT API ì¶”ê°€
import {
  bootstrapSession,
  hasValidSaveGame,
  startSessionFromProfile,
  continueSession,
  resetToCurrentProfile,
  clearSessionAndReturnToSelect,
  saveCurrentSession,
  getInitialProfileId,
  getSessionLanguage,
  setSessionLanguage,
  getInitialSessionLanguage,
} from './save/sessionLifecycle';
import type { DemoProfile } from './data/demoProfiles';
import type { SupportedLanguage } from './i18n';

// =============================================================================
// ê²Œì„ ìƒíƒœ íƒ€ì…
// =============================================================================

type GamePhase = 'profile_select' | 'playing';

// =============================================================================
// ë©”ì¸ App ì»´í¬ë„ŒíŠ¸
// =============================================================================

function App() {
  const { t } = useTranslation();

  // U-015: ê²Œì„ ì§„í–‰ ìƒíƒœ (í”„ë¡œí•„ ì„ íƒ vs í”Œë ˆì´ ì¤‘)
  // RU-004-Q4: bootstrapSession()ìœ¼ë¡œ ì´ˆê¸° phase ê²°ì • (SSOT)
  const [gamePhase, setGamePhase] = useState<GamePhase>(() => {
    const bootstrap = bootstrapSession();
    return bootstrap.phase;
  });

  // í˜„ì¬ ì„ íƒëœ í”„ë¡œí•„ ID
  // RU-004-Q4: getInitialProfileId()ë¡œ ì´ˆê¸° profileId ê²°ì • (SSOT)
  const [currentProfileId, setCurrentProfileId] = useState<string | null>(() => {
    return getInitialProfileId();
  });

  // U-044: ì„¸ì…˜ ì–¸ì–´ SSOT
  // - SaveGame.languageë¥¼ ê¶Œìœ„ìë¡œ ì‚¬ìš©í•˜ì—¬ ë“œë¦¬í”„íŠ¸ ë°©ì§€
  // - profile_selectì—ì„œë§Œ ë³€ê²½ ê°€ëŠ¥ (í† ê¸€=ë¦¬ì…‹ ì •ì±…)
  const [sessionLanguage, setSessionLanguageState] = useState<SupportedLanguage>(() => {
    return getInitialSessionLanguage();
  });

  // ë¡œì»¬ UI ìƒíƒœ
  const [inputText, setInputText] = useState('');

  // Store ìƒíƒœ
  const worldStore = useWorldStore();
  const { economy, isConnected, sceneObjects, narrativeEntries, appendSystemNarrative } =
    worldStore;

  const { startDrag, endDrag } = useInventoryStore();
  const { isStreaming, narrativeBuffer } = useAgentStore();
  const { uiScale, increaseUIScale, decreaseUIScale } = useUIPrefsStore();

  // DOMì— UI ì„¤ì • ì ìš© (U-028â†’U-037)
  useEffect(() => {
    applyUIPrefsToDOM({ uiScale });
  }, [uiScale]);

  // ==========================================================================
  // U-015 + RU-004-Q4: í”„ë¡œí•„/ì„¸ì´ë¸Œ ê´€ë ¨ ë¡œì§ (sessionLifecycle SSOT)
  // ==========================================================================

  /**
   * í”„ë¡œí•„ì„ ì„ íƒí•˜ê³  ê²Œì„ì„ ì‹œì‘í•©ë‹ˆë‹¤.
   *
   * RU-004-Q4: sessionLifecycle.startSessionFromProfile í˜¸ì¶œ
   * U-044: ì„¸ì…˜ ì–¸ì–´ë¥¼ ëª…ì‹œì ìœ¼ë¡œ ì „ë‹¬í•˜ì—¬ SSOT ìœ ì§€
   */
  const handleSelectProfile = useCallback(
    (profile: DemoProfile) => {
      const result = startSessionFromProfile({ profile, t, language: sessionLanguage });
      if (result.success) {
        setCurrentProfileId(result.profileId);
        setGamePhase('playing');
      }
    },
    [t, sessionLanguage],
  );

  /**
   * U-044: profile_selectì—ì„œ ì–¸ì–´ë¥¼ ë³€ê²½í•©ë‹ˆë‹¤.
   * í† ê¸€=ë¦¬ì…‹ ì •ì±…ì— ë”°ë¼ profile_selectì—ì„œë§Œ í˜¸ì¶œ ê°€ëŠ¥í•©ë‹ˆë‹¤.
   */
  const handleLanguageChange = useCallback(async (language: SupportedLanguage) => {
    await setSessionLanguage(language);
    setSessionLanguageState(language);
  }, []);

  /**
   * ì €ì¥ëœ ê²Œì„ì„ ê³„ì†í•©ë‹ˆë‹¤.
   *
   * RU-004-Q4: sessionLifecycle.continueSession í˜¸ì¶œ
   * U-044: ì„¸ì…˜ ë³µì› í›„ ì–¸ì–´ ìƒíƒœë„ ë™ê¸°í™”
   */
  const handleContinue = useCallback(async () => {
    const result = await continueSession();
    if (result) {
      setCurrentProfileId(result.profileId);
      // U-044: ì„¸ì…˜ ë³µì› í›„ ì–¸ì–´ ìƒíƒœ ë™ê¸°í™” (SaveGame.languageê°€ SSOT)
      setSessionLanguageState(getSessionLanguage());
      setGamePhase('playing');
    } else {
      // ë¡œë“œ ì‹¤íŒ¨ ì‹œ profile_selectë¡œ í´ë°±
      setCurrentProfileId(null);
      setGamePhase('profile_select');
      console.warn('[App] SaveGame ë³µì› ì‹¤íŒ¨, ìƒˆë¡œ ì‹œì‘');
    }
  }, []);

  /**
   * í˜„ì¬ í”„ë¡œí•„ì˜ ì´ˆê¸° ìƒíƒœë¡œ ë¦¬ì…‹í•©ë‹ˆë‹¤.
   *
   * RU-004-Q4: sessionLifecycle.resetToCurrentProfile í˜¸ì¶œ
   */
  const handleReset = useCallback(() => {
    const result = resetToCurrentProfile({ t, currentProfileId });
    if (result.success && result.profileId) {
      setCurrentProfileId(result.profileId);
      // ê²Œì„ ìƒíƒœëŠ” ì´ë¯¸ playingì´ë¯€ë¡œ ë³„ë„ ì„¤ì • ë¶ˆí•„ìš”
    }
  }, [t, currentProfileId]);

  /**
   * í”„ë¡œí•„ ì„ íƒ í™”ë©´ìœ¼ë¡œ ëŒì•„ê°‘ë‹ˆë‹¤.
   *
   * RU-004-Q4: sessionLifecycle.clearSessionAndReturnToSelect í˜¸ì¶œ
   */
  const handleChangeProfile = useCallback(() => {
    clearSessionAndReturnToSelect();
    setCurrentProfileId(null);
    setGamePhase('profile_select');
  }, []);

  // ê²Œì„ ì‹œì‘ ì‹œ ì €ì¥ëœ ê²Œì„ ë³µì›
  // RU-004-Q4: sessionLifecycle.continueSession í˜¸ì¶œ
  useEffect(() => {
    if (gamePhase === 'playing' && currentProfileId) {
      void continueSession().then((result) => {
        if (result) {
          setCurrentProfileId(result.profileId);
        }
      });
    }
    // eslint-disable-next-line react-hooks/exhaustive-deps
  }, []);

  // í„´ ì™„ë£Œ ì‹œ ìë™ ì €ì¥ (turnCount ë³€í™” ê°ì§€)
  // RU-004-Q4: sessionLifecycle.saveCurrentSession í˜¸ì¶œ
  useEffect(() => {
    if (gamePhase === 'playing' && narrativeEntries.length > 0) {
      saveCurrentSession(currentProfileId);
    }
  }, [gamePhase, narrativeEntries.length, currentProfileId]);

  // RU-003-Q3: Turn Runner (ìŠ¤íŠ¸ë¦¼ ì‹œì‘/ì·¨ì†Œ/ì½œë°± ë¼ìš°íŒ… ë‹´ë‹¹)
  // U-044: ì„¸ì…˜ ì–¸ì–´ë¥¼ SSOTë¡œ ì£¼ì…í•˜ì—¬ ë“œë¦¬í”„íŠ¸ ë°©ì§€
  const turnRunnerDeps = useMemo(
    () => ({
      t,
      theme: getCurrentThemeFromDOM(),
      language: sessionLanguage,
    }),
    [t, sessionLanguage],
  );
  const turnRunner = useTurnRunner(turnRunnerDeps);

  /**
   * í„´ì„ ì‹¤í–‰í•©ë‹ˆë‹¤.
   */
  const executeTurn = useCallback(
    (text: string, actionId?: string, clickData?: HotspotClickData, dropData?: DropInput) => {
      turnRunner.runTurn({
        text,
        actionId,
        click: clickData,
        drop: dropData,
      });
      setInputText('');
    },
    [turnRunner],
  );

  /**
   * ì…ë ¥ ì œì¶œ í•¸ë“¤ëŸ¬
   */
  const handleSubmit = useCallback(() => {
    if (inputText.trim()) {
      executeTurn(inputText.trim());
    }
  }, [inputText, executeTurn]);

  /**
   * ì¹´ë“œ í´ë¦­ í•¸ë“¤ëŸ¬
   */
  const handleCardClick = useCallback(
    (card: ActionCard) => {
      executeTurn(card.label, card.id);
    },
    [executeTurn],
  );

  /**
   * í•«ìŠ¤íŒŸ í´ë¦­ í•¸ë“¤ëŸ¬ (U-010)
   */
  const handleHotspotClick = useCallback(
    (data: HotspotClickData) => {
      const clickedObject = sceneObjects.find((obj) => obj.id === data.object_id);
      const clickText = clickedObject
        ? t('scene.hotspot.click_action', { label: clickedObject.label })
        : data.object_id;

      executeTurn(clickText, undefined, data);
    },
    [executeTurn, sceneObjects, t],
  );

  /**
   * í‚¤ë³´ë“œ ì´ë²¤íŠ¸ í•¸ë“¤ëŸ¬
   */
  const handleKeyDown = useCallback(
    (e: React.KeyboardEvent) => {
      if (e.key === 'Enter' && !e.shiftKey) {
        e.preventDefault();
        handleSubmit();
      }
    },
    [handleSubmit],
  );

  /**
   * ë“œë˜ê·¸ ì‹œì‘ í•¸ë“¤ëŸ¬ (U-011)
   */
  const handleDragStart = useCallback(
    (event: DragStartEvent) => {
      const { active } = event;
      if (isInventoryDragData(active.data.current)) {
        startDrag(active.data.current.item_id);
      }
    },
    [startDrag],
  );

  /**
   * ë“œë˜ê·¸ ì¢…ë£Œ í•¸ë“¤ëŸ¬ (U-011 + U-012)
   */
  const handleDragEnd = useCallback(
    (event: DragEndEvent) => {
      const { active, over } = event;
      endDrag();

      const activeData = active.data.current;
      if (!isInventoryDragData(activeData)) {
        return;
      }

      const itemId = activeData.item_id;
      const itemName = activeData.item.name;

      const overData = over?.data.current;
      if (!over || !isHotspotDropData(overData)) {
        appendSystemNarrative(
          `[${t('connection.online')}] ${t('scene.hotspot.drop_invalid', { item: itemName })}`,
        );
        return;
      }

      const { object_id: targetObjectId, box_2d: targetBox2d, label: targetLabel } = overData;

      const dropText = t('scene.hotspot.drop_action', {
        item: itemName,
        target: targetLabel,
      });

      const dropInput: DropInput = {
        item_id: itemId,
        target_object_id: targetObjectId,
        target_box_2d: targetBox2d,
      };

      executeTurn(dropText, undefined, undefined, dropInput);
    },
    [endDrag, executeTurn, appendSystemNarrative, t],
  );

  // dnd-kit ì„¼ì„œ ì„¤ì •
  const sensors = useSensors(
    useSensor(PointerSensor, {
      activationConstraint: {
        distance: 8,
      },
    }),
    useSensor(KeyboardSensor),
  );

  // ==========================================================================
  // ë Œë”ë§: í”„ë¡œí•„ ì„ íƒ í™”ë©´
  // RU-004-Q4: hasValidSaveGame()ìœ¼ë¡œ "ìœ íš¨í•œ ì„¸ì´ë¸Œë§Œ" Continue ë…¸ì¶œ
  // U-044: ì–¸ì–´ ì„ íƒ UI ì¶”ê°€ (profile_selectì—ì„œë§Œ, Q1: Option A)
  // ==========================================================================
  if (gamePhase === 'profile_select') {
    const hasSavedGame = hasValidSaveGame();
    return (
      <>
        <div className="crt-overlay" aria-hidden="true" />
        <DemoProfileSelect
          onSelectProfile={handleSelectProfile}
          onContinue={hasSavedGame ? handleContinue : undefined}
          hasSavedGame={hasSavedGame}
          currentLanguage={sessionLanguage}
          onLanguageChange={handleLanguageChange}
        />
      </>
    );
  }

  // ==========================================================================
  // ë Œë”ë§: ê²Œì„ í”Œë ˆì´ í™”ë©´
  // ==========================================================================
  return (
    <>
      <div className="crt-overlay" aria-hidden="true" />

      <DndContext sensors={sensors} onDragStart={handleDragStart} onDragEnd={handleDragEnd}>
        <div className="game-container">
          <GameHeader
            signal={economy.signal}
            memoryShard={economy.memory_shard}
            isConnected={isConnected}
            uiScale={uiScale}
            onIncreaseScale={increaseUIScale}
            onDecreaseScale={decreaseUIScale}
          >
            {/* U-015: ë¦¬ì…‹/í”„ë¡œí•„ ë³€ê²½ ë²„íŠ¼ */}
            <ResetButton onReset={handleReset} disabled={isStreaming} compact requireConfirm />
            <ChangeProfileButton onClick={handleChangeProfile} disabled={isStreaming} />
          </GameHeader>

          <aside className="sidebar-left">
            <Panel title={t('panel.inventory.title')} className="flex-1">
              <InventoryPanel />
            </Panel>
            {/* U-013: Quest Panel */}
            <Panel title={t('panel.quest.title')}>
              <QuestPanel />
            </Panel>
            {/* U-013: Rule Board + Mutation Timeline (ë³„ë„ ì»´í¬ë„ŒíŠ¸) */}
            <Panel title={t('panel.rule_board.title')}>
              <RuleBoard />
              <MutationTimeline />
            </Panel>
          </aside>

          <main className="game-center">
            <SceneCanvas onHotspotClick={handleHotspotClick} />
            <NarrativeFeed entries={narrativeEntries} streamingText={narrativeBuffer} />
          </main>

          <aside className="sidebar-right">
            <Panel title={t('panel.agent_console.title')} className="flex-1" hasChrome>
              <AgentConsole />
            </Panel>
            <Panel title={t('economy.hud_label')} hasChrome>
              <EconomyHud />
            </Panel>
            <Panel title={t('panel.scanner.title')} hasChrome>
              <ScannerSlot language={sessionLanguage} disabled={isStreaming} />
            </Panel>
          </aside>

          <footer className="game-footer">
            <ActionDeck onCardClick={handleCardClick} />
            <div className="command-input-area">
              <span className="command-prompt">&gt;</span>
              <input
                type="text"
                className="command-input"
                placeholder={isStreaming ? t('ui.processing') : t('ui.command_placeholder')}
                aria-label={t('ui.command_placeholder')}
                value={inputText}
                onChange={(e) => setInputText(e.target.value)}
                onKeyDown={handleKeyDown}
                disabled={isStreaming}
              />
              <button type="button" onClick={handleSubmit} disabled={isStreaming}>
                {isStreaming ? t('ui.wait') : t('ui.execute')}
              </button>
            </div>
          </footer>
        </div>
      </DndContext>
    </>
  );
}

export default App;
</file>

</files>
