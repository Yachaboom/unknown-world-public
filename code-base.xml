This file is a merged representation of a subset of the codebase, containing specifically included files and files not matching ignore patterns, combined into a single document by Repomix.

<file_summary>
This section contains a summary of this file.

<purpose>
This file contains a packed representation of a subset of the repository's contents that is considered the most important context.
It is designed to be easily consumable by AI systems for analysis, code review,
or other automated processes.
</purpose>

<file_format>
The content is organized as follows:
1. This summary section
2. Repository information
3. Directory structure
4. Repository files (if enabled)
5. Multiple file entries, each consisting of:
  - File path as an attribute
  - Full contents of the file
</file_format>

<usage_guidelines>
- This file should be treated as read-only. Any changes should be made to the
  original repository files, not this packed version.
- When processing this file, use the file path to distinguish
  between different files in the repository.
- Be aware that this file may contain sensitive information. Handle it with
  the same level of security as you would the original repository.
</usage_guidelines>

<notes>
- Some files may have been excluded based on .gitignore rules and Repomix's configuration
- Binary files are not included in this packed representation. Please refer to the Repository Structure section for a complete list of file paths, including binary files
- Only files matching these patterns are included: **/*.{ts,py,js,json,md}
- Files matching these patterns are excluded: .claude/**, .cursor/**, .gemini/**, .vscode/**, vibe/**
- Files matching patterns in .gitignore are excluded
- Files matching default ignore patterns are excluded
- Files are sorted by Git change count (files with more changes are at the bottom)
</notes>

</file_summary>

<directory_structure>
backend/prompts/image/scene_prompt.en.md
backend/prompts/image/scene_prompt.ko.md
backend/prompts/system/game_master.en.md
backend/prompts/system/game_master.ko.md
backend/prompts/turn/turn_output_instructions.en.md
backend/prompts/turn/turn_output_instructions.ko.md
backend/src/unknown_world/__init__.py
backend/src/unknown_world/api/__init__.py
backend/src/unknown_world/api/image.py
backend/src/unknown_world/api/scanner.py
backend/src/unknown_world/api/turn_stream_events.py
backend/src/unknown_world/api/turn_streaming_helpers.py
backend/src/unknown_world/api/turn.py
backend/src/unknown_world/config/__init__.py
backend/src/unknown_world/config/models.py
backend/src/unknown_world/main.py
backend/src/unknown_world/models/__init__.py
backend/src/unknown_world/models/scanner.py
backend/src/unknown_world/models/turn.py
backend/src/unknown_world/orchestrator/__init__.py
backend/src/unknown_world/orchestrator/fallback.py
backend/src/unknown_world/orchestrator/generate_turn_output.py
backend/src/unknown_world/orchestrator/mock.py
backend/src/unknown_world/orchestrator/pipeline.py
backend/src/unknown_world/orchestrator/prompt_loader.py
backend/src/unknown_world/orchestrator/repair_loop.py
backend/src/unknown_world/orchestrator/stages/__init__.py
backend/src/unknown_world/orchestrator/stages/commit.py
backend/src/unknown_world/orchestrator/stages/parse.py
backend/src/unknown_world/orchestrator/stages/plan.py
backend/src/unknown_world/orchestrator/stages/render.py
backend/src/unknown_world/orchestrator/stages/resolve.py
backend/src/unknown_world/orchestrator/stages/types.py
backend/src/unknown_world/orchestrator/stages/validate.py
backend/src/unknown_world/orchestrator/stages/verify.py
backend/src/unknown_world/services/__init__.py
backend/src/unknown_world/services/genai_client.py
backend/src/unknown_world/services/image_generation.py
backend/src/unknown_world/services/image_postprocess.py
backend/src/unknown_world/services/image_understanding.py
backend/src/unknown_world/services/rembg_preflight.py
backend/src/unknown_world/storage/__init__.py
backend/src/unknown_world/storage/local_storage.py
backend/src/unknown_world/storage/paths.py
backend/src/unknown_world/storage/storage.py
backend/src/unknown_world/storage/validation.py
backend/src/unknown_world/validation/__init__.py
backend/src/unknown_world/validation/business_rules.py
backend/src/unknown_world/validation/language_gate.py
backend/tests/integration/test_api.py
backend/tests/integration/test_real_mode_gate.py
backend/tests/integration/test_scanner_api.py
backend/tests/integration/test_turn_streaming.py
backend/tests/manual_test_image.py
backend/tests/manual_test_rembg.py
backend/tests/qa/test_asset_manifest.py
backend/tests/unit/api/test_image.py
backend/tests/unit/models/test_turn.py
backend/tests/unit/orchestrator/test_generate_turn_output.py
backend/tests/unit/orchestrator/test_mock_orchestrator.py
backend/tests/unit/orchestrator/test_pipeline.py
backend/tests/unit/orchestrator/test_prompt_loader.py
backend/tests/unit/services/test_genai_client.py
backend/tests/unit/services/test_image_generation.py
backend/tests/unit/services/test_rembg_preflight.py
backend/tests/unit/services/test_scanner_service.py
backend/tests/unit/test_dotenv_autoload.py
backend/tests/unit/test_image_generation_integration.py
backend/tests/unit/test_image_postprocess.py
backend/tests/unit/test_orchestrator_repair.py
backend/tests/unit/test_u034_verification.py
backend/tests/unit/test_u043_language_gate.py
CLAUDE.md
frontend/coverage/block-navigation.js
frontend/coverage/coverage-final.json
frontend/coverage/prettify.js
frontend/coverage/sorter.js
frontend/package.json
frontend/public/ui/manifest.json
frontend/public/ui/manifest.schema.json
frontend/public/ui/QA_CHECKLIST.md
frontend/public/ui/README.md
frontend/src/api/scanner.test.ts
frontend/src/api/scanner.ts
frontend/src/api/turnStream.test.ts
frontend/src/api/turnStream.ts
frontend/src/data/demoProfiles.test.ts
frontend/src/data/demoProfiles.ts
frontend/src/demo/demoFixtures.ts
frontend/src/demo/useDemoInitializer.ts
frontend/src/dnd/types.ts
frontend/src/i18n-scenario.test.ts
frontend/src/i18n.ts
frontend/src/locales/en-US/translation.json
frontend/src/locales/ko-KR/translation.json
frontend/src/locales/README.md
frontend/src/save/constants.ts
frontend/src/save/saveGame.test.ts
frontend/src/save/saveGame.ts
frontend/src/save/sessionLifecycle.test.ts
frontend/src/save/sessionLifecycle.ts
frontend/src/schemas/index.ts
frontend/src/schemas/turn.test.ts
frontend/src/schemas/turn.ts
frontend/src/schemas/verify_runbook.ts
frontend/src/setupTests.ts
frontend/src/stores/actionDeckStore.test.ts
frontend/src/stores/actionDeckStore.ts
frontend/src/stores/agentStore.test.ts
frontend/src/stores/agentStore.ts
frontend/src/stores/economyStore.test.ts
frontend/src/stores/economyStore.ts
frontend/src/stores/inventoryStore.test.ts
frontend/src/stores/inventoryStore.ts
frontend/src/stores/uiPrefsStore.test.ts
frontend/src/stores/uiPrefsStore.ts
frontend/src/stores/worldStore.test.ts
frontend/src/stores/worldStore.ts
frontend/src/turn/turnRunner.ts
frontend/src/types/scene.ts
frontend/src/types/turn_stream.ts
frontend/src/utils/box2d.test.ts
frontend/src/utils/box2d.ts
frontend/src/vite-env.d.ts
frontend/tsconfig.json
frontend/tsconfig.node.json
frontend/vite.config.ts
package.json
request.json
shared/README.md
shared/schemas/turn/turn_input.schema.json
shared/schemas/turn/turn_output.schema.json
</directory_structure>

<files>
This section contains the contents of the repository's files.

<file path="backend/src/unknown_world/__init__.py">
"""Unknown World - Backend Package

This is the main package for the Unknown World backend.
Architecture: FastAPI + Pydantic + SSE streaming

Reference:
- vibe/tech-stack.md (Python 3.14, FastAPI 0.128.0, Pydantic 2.12.5)
- vibe/prd.md (Agent-based Game Master Engine)
"""

__version__ = "0.1.0"
</file>

<file path="backend/tests/integration/test_api.py">
from fastapi.testclient import TestClient

from unknown_world.main import app

client = TestClient(app)


def test_health_check():
    """/health ì—”ë“œí¬ì¸íŠ¸ê°€ ì˜¬ë°”ë¥¸ ìŠ¤í‚¤ë§ˆì™€ ìƒíƒœë¥¼ ë°˜í™˜í•˜ëŠ”ì§€ í…ŒìŠ¤íŠ¸í•©ë‹ˆë‹¤."""
    response = client.get("/health")
    assert response.status_code == 200
    data = response.json()
    assert data["status"] == "ok"
    assert "version" in data
    assert data["service"] == "unknown-world-backend"


def test_root_endpoint():
    """ë£¨íŠ¸ ì—”ë“œí¬ì¸íŠ¸ê°€ ì •ìƒ ì‘ë™í•˜ëŠ”ì§€ í…ŒìŠ¤íŠ¸í•©ë‹ˆë‹¤."""
    response = client.get("/")
    assert response.status_code == 200
    assert "message" in response.json()


def test_cors_policy():
    """RULE-011ì— ë”°ë¥¸ CORS ì •ì±…ì´ ì˜¬ë°”ë¥´ê²Œ ì„¤ì •ë˜ì—ˆëŠ”ì§€ í…ŒìŠ¤íŠ¸í•©ë‹ˆë‹¤."""
    # í—ˆìš©ëœ ì˜¤ë¦¬ì§„ í…ŒìŠ¤íŠ¸ (í¬íŠ¸ 8001)
    headers = {
        "Origin": "http://localhost:8001",
        "Access-Control-Request-Method": "GET",
    }
    response = client.options("/health", headers=headers)
    assert response.status_code == 200
    assert response.headers.get("access-control-allow-origin") == "http://localhost:8001"

    # í—ˆìš©ë˜ì§€ ì•Šì€ ì˜¤ë¦¬ì§„ í…ŒìŠ¤íŠ¸ (í¬íŠ¸ 9000)
    headers = {
        "Origin": "http://localhost:9000",
        "Access-Control-Request-Method": "GET",
    }
    response = client.options("/health", headers=headers)
    # FastAPI/Starlette CORS ë¯¸ë“¤ì›¨ì–´ëŠ” í—ˆìš©ë˜ì§€ ì•Šì€ ê²½ìš° origin í—¤ë”ë¥¼ ë°˜í™˜í•˜ì§€ ì•ŠìŒ
    assert "access-control-allow-origin" not in response.headers
</file>

<file path="CLAUDE.md">
# AI ì—ì´ì „íŠ¸ ì „ì—­ ì§€ì¹¨ (Unknown World)

ì´ ë¬¸ì„œëŠ” Unknown World ë ˆí¬ì—ì„œ ì‘ì—…í•˜ëŠ” ëª¨ë“  AI ì—ì´ì „íŠ¸(Claude/Cursor í¬í•¨)ê°€ **ì¼ê´€ë˜ê³  íš¨ìœ¨ì ìœ¼ë¡œ** ì¼í•  ìˆ˜ ìˆë„ë¡ í•˜ëŠ” ì „ì—­ ê·œì¹™ì…ë‹ˆë‹¤.

---

## í”„ë¡œì íŠ¸ ê°œìš”

**Unknown World**ëŠ” Gemini ê¸°ë°˜ì˜ **ì—ì´ì „íŠ¸í˜•(Game Master) ì„¸ê³„ ì—”ì§„**ê³¼ ë©€í‹°ëª¨ë‹¬(í…ìŠ¤íŠ¸/ì´ë¯¸ì§€/ë¹„ì „) íŒŒì´í”„ë¼ì¸ì„ ê²°í•©í•œ **ë¬´í•œ ìƒì„± ë¡œê·¸ë¼ì´í¬ ë‚´ëŸ¬í‹°ë¸Œ ì›¹ê²Œì„**ì…ë‹ˆë‹¤.

- â€œëŒ€í™” ì•±â€ì´ ì•„ë‹ˆë¼ **ìƒíƒœë¥¼ ê°€ì§„ ì‹œìŠ¤í…œ**ì…ë‹ˆë‹¤.
- ì¶œë ¥ì€ ë‚´ëŸ¬í‹°ë¸Œ í…ìŠ¤íŠ¸ë¿ ì•„ë‹ˆë¼ **UI/ìƒíƒœ ë³€í™”/ë¹„ìš©/ì´ë¯¸ì§€ ì‘ì—…**ê¹Œì§€ í¬í•¨í•œ **êµ¬ì¡°í™” ê²°ê³¼(JSON Schema)** ì—¬ì•¼ í•©ë‹ˆë‹¤.
- ì‹¤íŒ¨/ë¶ˆì™„ì „ ì¶œë ¥ì— ëŒ€ë¹„í•´ **ê²€ì¦ + ìë™ ë³µêµ¬(Repair loop) + ì•ˆì „í•œ í´ë°±**ì„ ë‚´ì¥í•©ë‹ˆë‹¤.

---

## SSOT(ë‹¨ì¼ ì¶œì²˜) ë° ì¶©ëŒ í•´ê²° ìš°ì„ ìˆœìœ„

ë¬¸ì„œ/ê·œì¹™ì´ ì¶©ëŒí•  ë•ŒëŠ” ì•„ë˜ ìˆœì„œë¡œ ê²°ì •í•©ë‹ˆë‹¤.

1. `vibe/prd.md` (ì œí’ˆ/UX/ì„±ê³µ ì§€í‘œ/ê¸ˆì§€ì‚¬í•­)
2. `vibe/tech-stack.md` (ê¸°ìˆ  ìŠ¤íƒ/ë²„ì „/ì•„í‚¤í…ì²˜ ì„ íƒ)
3. `vibe/ref/*` (í‘œì¤€/ìŠ¤íƒ€ì¼/êµ¬ì¡°í™” ì¶œë ¥ ê°€ì´ë“œ)
4. `.cursor/rules/*.mdc` (êµ¬ì²´ì  ì‹¤í–‰ ê·œì¹™)
5. `.gemini/rules/*` (ì¡´ì¬í•˜ëŠ” ê²½ìš°ì— í•œí•´ ì°¸ê³ ; í”„ë¡œì íŠ¸ì™€ ë¶ˆì¼ì¹˜ ì‹œ ì ìš© ê¸ˆì§€)

ë¶ˆí™•ì‹¤í•˜ë©´ **ì¶”ì¸¡í•˜ì§€ ë§ê³  ì§ˆë¬¸**í•©ë‹ˆë‹¤.

---

## í•µì‹¬ ì›ì¹™ (Nonâ€‘Negotiable)

### 1) Prompt-only wrapper / Generic chatbot íšŒí”¼

- â€œí”„ë¡¬í”„íŠ¸ 1ì¥ + ì±„íŒ… UIâ€ í˜•íƒœë¥¼ ê¸ˆì§€í•©ë‹ˆë‹¤.
- ë°˜ë“œì‹œ ë‹¤ìŒì´ ì¡´ì¬í•´ì•¼ í•©ë‹ˆë‹¤:
  - **ìƒíƒœ(State)**: WorldState / Inventory / Rules / Economy / History
  - **ì˜¤ì¼€ìŠ¤íŠ¸ë ˆì´í„°(Orchestrator)**: ë‹¨ê³„ ì‹¤í–‰, ê²€ì¦, ì¬ì‹œë„, ë¹„ìš© ì œì–´
  - **ì•„í‹°íŒ©íŠ¸(Artifacts)**: SaveGame, ì—”ë”© ë¦¬í¬íŠ¸, ë¡œê·¸/ì´ë¯¸ì§€

### 2) ì±„íŒ… ë²„ë¸” UI ê¸ˆì§€, ê²Œì„ UI ê³ ì •

- ë©”ì‹ ì €í˜• **ì±„íŒ… ë²„ë¸” UI ê¸ˆì§€**(ì‹¬ì‚¬ì ì˜¤í•´ ë°©ì§€).
- ë°ëª¨ì—ì„œ ìµœì†Œ ë‹¤ìŒ UIëŠ” í•­ìƒ â€œê²Œì„ìŠ¤ëŸ½ê²Œâ€ ë³´ì´ë„ë¡ ê³ ì •í•©ë‹ˆë‹¤:
  - Action Deck(ë¹„ìš©/ìœ„í—˜/ë³´ìƒ í¬í•¨), Inventory(DnD), Quest/Objective, Rule Board/Mutation Timeline,
    Economy HUD(ì˜ˆìƒ/í™•ì • ë¹„ìš©), Memory Pin, Scene Canvas(í•«ìŠ¤íŒŸ), Agent Console(Plan/Queue/Badges)

### 3) êµ¬ì¡°í™” ì¶œë ¥(JSON Schema) ìš°ì„  + ì´ì¤‘ ê²€ì¦

- ëª¨ë¸ ì¶œë ¥ì€ ê¸°ë³¸ì ìœ¼ë¡œ `application/json` + JSON Schemaë¥¼ ê°•ì œí•©ë‹ˆë‹¤.
- **ì„œë²„(Pydantic) + í´ë¼ì´ì–¸íŠ¸(Zod)** ì´ì¤‘ ê²€ì¦ì„ ì „ì œë¡œ ì„¤ê³„í•©ë‹ˆë‹¤.

### 4) ê²€ì¦/ë³µêµ¬(Repair loop)ì™€ í´ë°±ì€ â€œí•„ìˆ˜ ê¸°ëŠ¥â€

- ìŠ¤í‚¤ë§ˆ ë¶ˆì¼ì¹˜/ë¹„ì¦ˆë‹ˆìŠ¤ ë£° ìœ„ë°˜/ë¹„ìš© ì´ˆê³¼/ì•ˆì „ ì°¨ë‹¨ ë“±ì€ **ìë™ ë³µêµ¬ ë£¨í”„**ë¡œ ì²˜ë¦¬í•©ë‹ˆë‹¤.
- ë³µêµ¬ ì‹¤íŒ¨ ì‹œì—ë„ **í…ìŠ¤íŠ¸-only ë“± ì•ˆì „í•œ ëŒ€ì²´ ê²°ê³¼**ë¥¼ ì œê³µí•©ë‹ˆë‹¤.

### 5) ë¹„ìš©/ì§€ì—°ì€ UX/ê²Œì„ ë©”ì»¤ë‹‰ìœ¼ë¡œ ì œì–´

- í–‰ë™ ì „ì— **ì˜ˆìƒ ë¹„ìš©(ìµœì†Œ/ìµœëŒ€)** ë…¸ì¶œ, ë¶€ì¡± ì‹œ **ëŒ€ì²´ í–‰ë™** ì œì•ˆ(í…ìŠ¤íŠ¸ë§Œ/ì €í•´ìƒë„/Thinking ë‚®ì¶¤).
- EconomyëŠ” **ì›ì¥(ledger)** ìœ¼ë¡œ ì¶”ì  ê°€ëŠ¥í•´ì•¼ í•˜ë©° ì”ì•¡ ìŒìˆ˜ëŠ” ê¸ˆì§€ì…ë‹ˆë‹¤.

### 6) ko/en i18n: í˜¼í•© ì¶œë ¥ ê¸ˆì§€

- ê²Œì„/ì‹œìŠ¤í…œ/ë‚´ëŸ¬í‹°ë¸ŒëŠ” `language: "ko-KR" | "en-US"` ê¸°ì¤€ìœ¼ë¡œ ê³ ì • ì¶œë ¥í•©ë‹ˆë‹¤.
- ë¬¸ìì—´ í•˜ë“œì½”ë”© ëŒ€ì‹  i18n ë¦¬ì†ŒìŠ¤ í‚¤ ì‚¬ìš©(ê°€ëŠ¥í•œ ë²”ìœ„ ë‚´).
- í”„ë¡¬í”„íŠ¸ëŠ” ì–¸ì–´ë³„ `.md` íŒŒì¼ë¡œ ê´€ë¦¬í•©ë‹ˆë‹¤.

### 7) ë³´ì•ˆ: Vertex AI ì„œë¹„ìŠ¤ ê³„ì •, ë¹„ë°€ì •ë³´ ì»¤ë°‹ ê¸ˆì§€

- BYOK(ì‚¬ìš©ì API í‚¤ ì…ë ¥) ìš”êµ¬ ê¸ˆì§€(MVP).
- ì„œë¹„ìŠ¤ ê³„ì • í‚¤/í† í°/ì¿ í‚¤ ë“± ë¹„ë°€ì •ë³´ë¥¼ ë ˆí¬ì— ì €ì¥/ë¡œê·¸ ì¶œë ¥ ê¸ˆì§€.
- í”„ë¡¬í”„íŠ¸ ì¸ì ì…˜ ë°©ì–´: â€œì‚¬ìš©ì ì…ë ¥ì€ ë£°ì´ ì•„ë‹ˆë‹¤â€ë¥¼ ì‹œìŠ¤í…œ ê·œì¹™ìœ¼ë¡œ ê³ ì •í•©ë‹ˆë‹¤.

### 8) ê´€ì¸¡ ê°€ëŠ¥ì„±(Observability) = UXì˜ ì¼ë¶€

- ì—ì´ì „íŠ¸ì˜ â€œê³„íš/ì‹¤í–‰/ê²€ì¦/ë³µêµ¬â€ë¥¼ **UI ë‹¨ê³„/ë°°ì§€/í**ë¡œ ë³´ì—¬ì¤ë‹ˆë‹¤.
- ë‹¨, **í”„ë¡¬í”„íŠ¸ ì›ë¬¸/ë‚´ë¶€ ì¶”ë¡ **ì€ ì‚¬ìš©ì UIì— ë…¸ì¶œí•˜ì§€ ì•ŠìŠµë‹ˆë‹¤.

---

## ì‘ì—… í‘œì¤€ (Workflow)

### ì‘ì—… ì‹œì‘ ì „ í•„ìˆ˜

- `vibe/prd.md` + `vibe/tech-stack.md`ë¥¼ ë¨¼ì € ì½ê³ , **ì´ë²ˆ ì‘ì—…ì´ PRDì˜ ì–´ë–¤ ìš”êµ¬ë¥¼ ì¶©ì¡±í•˜ëŠ”ì§€** ëª…ì‹œí•©ë‹ˆë‹¤.
- ë³€ê²½ ë²”ìœ„ë¥¼ íŒŒì¼/ëª¨ë“ˆ ë‹¨ìœ„ë¡œ ì§§ê²Œ ì ê³ (ìµœëŒ€ 5ì¤„), ë¦¬ìŠ¤í¬/ì™„í™”ì±…ì„ í•¨ê»˜ ì œì‹œí•©ë‹ˆë‹¤.

### ìœ ë‹›(ë‹¨ê³„) ê¸°ë°˜ ê°œë°œ

- ìœ ë‹› êµ¬í˜„ ì§€ì‹œì„œëŠ” `vibe/commands/unit-impl.md`(ë˜ëŠ” `.cursor/commands/unit-impl.md`)ì˜ íë¦„ì„ ë”°ë¦…ë‹ˆë‹¤.
- â€œí˜„ì¬ ë‹¨ê³„ ë²”ìœ„â€ ë°–ì˜ êµ¬í˜„/ì•„ì´ë””ì–´ í™•ì¥ì€ ê¸ˆì§€í•©ë‹ˆë‹¤(ìš”ì²­ì´ ì˜¤ë©´ ì§ˆë¬¸ìœ¼ë¡œ ìŠ¹ê²©).
- ê¸°ëŠ¥ êµ¬í˜„ í›„ **ëŸ°ë¶**ì„ ì‘ì„±í•´ ì¬í˜„ ê°€ëŠ¥í•œ ìˆ˜ë™ ê²€ì¦ ì‹œë‚˜ë¦¬ì˜¤ë¥¼ ë‚¨ê¹ë‹ˆë‹¤.

### ë¬¸ì„œ ë™ê¸°í™”

- êµ¬í˜„ ì™„ë£Œ í›„ ë¬¸ì„œ ë™ê¸°í™”ëŠ” `vibe/commands/doc-update.md` ê¸°ì¤€ìœ¼ë¡œ ìˆ˜í–‰í•©ë‹ˆë‹¤.
- Progress/Roadmap/Architecture/PRD/Tech-stack ë¬¸ì„œì˜ ë™ê¸°í™” ê·œì¹™(ìµœì‹  í•­ëª© ìµœìƒë‹¨ ë“±)ì„ ì¤€ìˆ˜í•©ë‹ˆë‹¤.

### ë¦¬íŒ©í† ë§

- ë¦¬íŒ©í† ë§ì€ `vibe/commands/refactor-impl.md` ê¸°ì¤€ìœ¼ë¡œ **Behavior Preservation**ì„ ìµœìš°ì„ í•©ë‹ˆë‹¤.

### í…ŒìŠ¤íŠ¸

- í…ŒìŠ¤íŠ¸ ì‘ì—…ì„ ëª…ì‹œì ìœ¼ë¡œ ìš”ì²­ë°›ì•˜ê±°ë‚˜, `test-exec` íë¦„ì„ ìˆ˜í–‰í•  ë•ŒëŠ” `vibe/commands/test-exec.md`ì˜ ì ˆì°¨(TDD, ì›ì¸ íŒë³„ í”„ë¡œí† ì½œ ë“±)ë¥¼ ë”°ë¦…ë‹ˆë‹¤.
- ê·¸ ì™¸ì˜ ì¼ë°˜ ê¸°ëŠ¥ êµ¬í˜„ì—ì„œëŠ” â€œìë™ í…ŒìŠ¤íŠ¸ ë„ì… ì—¬ë¶€â€ë¥¼ ì¶”ì¸¡í•´ ì¶”ê°€í•˜ì§€ ë§ê³ , ëŸ°ë¶/ë¦¬í”Œë ˆì´ ê¸°ë°˜ ê²€ì¦ì„ ìš°ì„ í•©ë‹ˆë‹¤.

### ì»¤ë°‹ ë©”ì‹œì§€

- ì»¤ë°‹ ë©”ì‹œì§€ëŠ” `.gemini/rules/commit-rules.md` í¬ë§·ì„ ìš°ì„  ì¤€ìˆ˜í•©ë‹ˆë‹¤(í•œê¸€, Progress ë¸”ë¡ í¬í•¨).
- ë‹¨, `vibe/roadmap.md`ê°€ ë¹„ì–´ìˆëŠ” ê²½ìš° Progress ìˆ˜ì¹˜ëŠ” ì„ì˜ë¡œ ë§Œë“¤ì§€ ë§ê³  ë³´ë¥˜/ì§ˆë¬¸í•©ë‹ˆë‹¤.

---

## í’ˆì§ˆ ê¸°ì¤€ (ì¶œì‹œ/ë°ëª¨ ê´€ì )

### Hard Gate (í•„ìˆ˜ í†µê³¼)

- **Schema OK**: TurnOutput JSONì´ ìŠ¤í‚¤ë§ˆë¥¼ í†µê³¼
- **Economy OK**: ë¹„ìš©/ì”ì•¡ ë¶ˆì¼ì¹˜ ì—†ìŒ, ì”ì•¡ ìŒìˆ˜ ê¸ˆì§€
- **Safety OK**: ì°¨ë‹¨ ì‹œ ëª…ì‹œ + ì•ˆì „í•œ ëŒ€ì²´ ê²°ê³¼ ì œê³µ
- **Consistency OK**: WorldState/Rule Board/Memory Pin ì¼ê´€ì„± ìœ ì§€

### Soft Gate (ê´€ì¸¡/íŠœë‹)

- **Streaming TTFB**: 2ì´ˆ ì´ë‚´ ëª©í‘œ(ë°ëª¨ ì²´ê° ìš°ì„ )
- ì´ë¯¸ì§€ ìƒì„±: ì„ íƒì /ì§€ì—° í—ˆìš©(Lazy loading), ì‹¤íŒ¨ ì‹œ í…ìŠ¤íŠ¸ ëŒ€ì²´

---

## ê¸ˆì§€ì‚¬í•­ (ì ˆëŒ€ ê¸ˆì§€)

- âŒ ì±„íŒ… ë²„ë¸”/ë©”ì‹ ì € UXë¡œ íšŒê·€ì‹œí‚¤ëŠ” ë³€ê²½
- âŒ êµ¬ì¡°í™” ì¶œë ¥ ì—†ì´ â€œí…ìŠ¤íŠ¸ë§Œâ€ ë°˜í™˜í•˜ëŠ” API/ë¡œì§(íŠ¹ìˆ˜í•œ ì˜ˆì™¸ë¥¼ ì œì™¸)
- âŒ í”„ë¡¬í”„íŠ¸ ì›ë¬¸/ë‚´ë¶€ ì¶”ë¡ /ë¹„ë°€ì •ë³´ë¥¼ UI ë˜ëŠ” ë¡œê·¸ë¡œ ë…¸ì¶œ
- âŒ ì„œë¹„ìŠ¤ ê³„ì • í‚¤/í† í° ë“± ë¹„ë°€ì •ë³´ë¥¼ ë ˆí¬ì— ì»¤ë°‹
- âŒ `language` ì •ì±…ì„ ë¬´ì‹œí•˜ê³  ko/en í˜¼í•© ì¶œë ¥
- âŒ ì¢Œí‘œ ê·œì•½(0~1000, bbox [ymin,xmin,ymax,xmax])ì„ ê¹¨ëŠ” ë³€ê²½
- âŒ ì¬í™” ì”ì•¡ ìŒìˆ˜/ë¹„ìš© ëˆ„ë½/ì˜ˆìƒë¹„ìš© ë¯¸í‘œê¸°

---

## ì§€ì¹¨ ìš´ì˜/ì‚¬ìš© ê°€ì´ë“œ

### Cursor ê·œì¹™ ì ìš© ë°©ì‹

- `.cursor/rules/*.mdc`ëŠ” **íŒŒì¼ íŒ¨í„´(`applyTo`)**ì— ë”°ë¼ ìë™ ì ìš©ë©ë‹ˆë‹¤.
- ê·œì¹™ì´ ë¶€ì¡±/ì¶©ëŒí•˜ë©´:
  - PRD/Tech-stack ê·¼ê±°ë¥¼ ì²¨ë¶€í•´ ê·œì¹™ì„ ì—…ë°ì´íŠ¸í•˜ê³ ,
  - íŒŒì¼ í•˜ë‚˜ê°€ 500ì¤„ì„ ë„˜ì§€ ì•Šê²Œ ëª¨ë“ˆë¡œ ë¶„ë¦¬í•©ë‹ˆë‹¤.

### ì˜¨ë³´ë”©(ì‹ ê·œ í•©ë¥˜ì/ì—ì´ì „íŠ¸) 10ë¶„ ë£¨í”„

- `vibe/prd.md` 6~9ì¥(ê²Œì„ UI/ê²½ì œ/Autopilot) â†’ â€œì±„íŒ… UI ê¸ˆì§€â€ í•©ì˜
- `vibe/tech-stack.md`(ë²„ì „/ëª¨ë¸ ID ê³ ì •) í™•ì¸
- `vibe/ref/frontend-style-guide.md`ë¡œ CRT í…Œë§ˆ ê·œì¹™ ìˆ™ì§€
- `vibe/ref/structured-outputs-guide.md`ë¡œ JSON Schema ì œì•½ ì´í•´

### ì§€ì¹¨ ì—…ë°ì´íŠ¸ í”„ë¡œì„¸ìŠ¤(ê¶Œì¥)

- ë³€ê²½ í•„ìš” ì‹ í˜¸: ê·œì¹™ ì˜¤í•´/ì¤‘ë³µ/ì¶©ëŒ/500ì¤„ ì´ˆê³¼/6ê°œì›” ë¯¸ì‚¬ìš©
- ì ˆì°¨: ë¬¸ì œ ì¬í˜„ â†’ ì›ì¸(ê·œì¹™ ë¶€ì¬/ëª¨í˜¸í•¨) â†’ ê·œì¹™ ìˆ˜ì •/ë¶„ë¦¬ â†’ PRD/Tech-stackì™€ ì •í•©ì„± í™•ì¸ â†’ ì ìš© ë²”ìœ„(applyTo) ì¢íˆê¸°

---

## ì°¸ì¡° ë¬¸ì„œ

- `vibe/prd.md`
- `vibe/tech-stack.md`
- `vibe/ref/frontend-style-guide.md`
- `vibe/ref/structured-outputs-guide.md`
- `vibe/commands/*.md` / `.cursor/commands/*.md`
- `.gemini/rules/commit-rules.md`
</file>

<file path="frontend/src/vite-env.d.ts">
/// <reference types="vite/client" />
</file>

<file path="frontend/tsconfig.json">
{
  "compilerOptions": {
    "target": "ES2022",
    "useDefineForClassFields": true,
    "lib": ["ES2022", "DOM", "DOM.Iterable"],
    "module": "ESNext",
    "skipLibCheck": true,

    /* Bundler mode */
    "moduleResolution": "Bundler",
    "allowImportingTsExtensions": true,
    "isolatedModules": true,
    "moduleDetection": "force",
    "noEmit": true,
    "jsx": "react-jsx",

    /* Linting (ì—„ê²© ëª¨ë“œ) */
    "strict": true,
    "noUnusedLocals": true,
    "noUnusedParameters": true,
    "noFallthroughCasesInSwitch": true,
    "noUncheckedSideEffectImports": true
  },
  "include": ["src"],
  "references": [{ "path": "./tsconfig.node.json" }]
}
</file>

<file path="frontend/tsconfig.node.json">
{
  "compilerOptions": {
    "target": "ES2022",
    "lib": ["ES2022"],
    "module": "ESNext",
    "skipLibCheck": true,

    /* Bundler mode */
    "moduleResolution": "Bundler",
    "allowImportingTsExtensions": true,
    "isolatedModules": true,
    "moduleDetection": "force",

    /* Composite for project references */
    "composite": true,
    "emitDeclarationOnly": true,
    "declaration": true,
    "declarationMap": true,

    /* Linting (ì—„ê²© ëª¨ë“œ) */
    "strict": true,
    "noUnusedLocals": true,
    "noUnusedParameters": true,
    "noFallthroughCasesInSwitch": true,
    "noUncheckedSideEffectImports": true
  },
  "include": ["vite.config.ts"]
}
</file>

<file path="shared/README.md">
# shared/

ì´ ë””ë ‰í† ë¦¬ëŠ” **í”„ë¡ íŠ¸ì—”ë“œì™€ ë°±ì—”ë“œ ê°„ ê³µìœ ë˜ëŠ” ìŠ¤í‚¤ë§ˆ/íƒ€ì… ì •ì˜**ë¥¼ ìœ„í•œ SSOT(Single Source of Truth) ë””ë ‰í† ë¦¬ì…ë‹ˆë‹¤.

## ğŸ“ êµ¬ì¡°

```
shared/
â”œâ”€â”€ schemas/
â”‚   â””â”€â”€ turn/                         # Turn ê³„ì•½ ìŠ¤í‚¤ë§ˆ (TurnInput/TurnOutput)
â”‚       â”œâ”€â”€ turn_input.schema.json    # Client â†’ Server ìš”ì²­ ìŠ¤í‚¤ë§ˆ
â”‚       â””â”€â”€ turn_output.schema.json   # Server â†’ Client ì‘ë‹µ ìŠ¤í‚¤ë§ˆ
â””â”€â”€ README.md
```

## ğŸ”„ SSOT ì›ì¹™ (RU-001-Q4)

- **SSOTëŠ” `shared/schemas/`ì˜ JSON Schema íŒŒì¼**ì…ë‹ˆë‹¤.
- ë°±ì—”ë“œ(Python/Pydantic)ì™€ í”„ë¡ íŠ¸ì—”ë“œ(TS/Zod)ì˜ íƒ€ì…/ê²€ì¦ ì½”ë“œëŠ” **ì´ ìŠ¤í‚¤ë§ˆë¡œë¶€í„° ìƒì„± ë˜ëŠ” ë™ê¸°í™”**ë©ë‹ˆë‹¤.
- ìŠ¤í‚¤ë§ˆ ë³€ê²½ ì‹œ ì–‘ìª½(backend/frontend)ì— ì˜í–¥ì´ ìˆìŒì„ ë°˜ë“œì‹œ ì¸ì§€í•´ì•¼ í•©ë‹ˆë‹¤.

### ì†Œë¹„ ì „ëµ (Option B: ìƒì„±ë¬¼ ê¸°ë°˜ ë™ê¸°í™”)

| ì†Œë¹„ì | ë„êµ¬/ë°©ì‹ | ìƒì„±ë¬¼ ê²½ë¡œ (ê¶Œì¥) |
|--------|-----------|-------------------|
| **Backend (Python)** | `datamodel-code-generator` ë˜ëŠ” ìˆ˜ë™ ë™ê¸°í™” | `backend/src/unknown_world/schemas/generated/` |
| **Frontend (TS)** | `json-schema-to-zod` ë˜ëŠ” ìˆ˜ë™ ë™ê¸°í™” | `frontend/src/schemas/generated/` |

> **MVP ë‹¨ê³„ì—ì„œëŠ” ìˆ˜ë™ ë™ê¸°í™”**ë¡œ ì‹œì‘í•˜ê³ , driftê°€ ë°œìƒí•˜ë©´ ìƒì„± ìŠ¤í¬ë¦½íŠ¸ë¥¼ ë„ì…í•©ë‹ˆë‹¤.

## ğŸ“‹ ìŠ¤í‚¤ë§ˆ íŒŒì¼ ëª©ë¡

### Turn ê³„ì•½ (MVP)

| íŒŒì¼ | ìš©ë„ | PRD ì°¸ì¡° |
|------|------|----------|
| `turn/turn_input.schema.json` | Client â†’ Server í„´ ìš”ì²­ | PRD 8.7ì ˆ TurnInput |
| `turn/turn_output.schema.json` | Server â†’ Client í„´ ì‘ë‹µ | PRD 8.7ì ˆ TurnOutput |

## âœ… ìŠ¤í‚¤ë§ˆ ì‘ì„± ê°€ì´ë“œë¼ì¸

- **ì§€ì› íƒ€ì…**: `string`, `number`, `integer`, `boolean`, `object`, `array`, `null`
- **ê¶Œì¥ ì†ì„±**: `required`, `enum`, `description`ì„ ì ê·¹ ì‚¬ìš©
- **ì—„ê²© ëª¨ë“œ**: `additionalProperties: false`ë¡œ ì˜ˆì¸¡ ê°€ëŠ¥ì„± í™•ë³´
- **í‰í‰í•œ êµ¬ì¡°**: ê³¼ë„í•œ ì¤‘ì²©ì„ í”¼í•˜ê³  ë‹¨ìˆœí•œ ìŠ¤í‚¤ë§ˆ ìœ ì§€
- **ì°¸ì¡°**: `vibe/ref/structured-outputs-guide.md`

## âš ï¸ ë³´ì•ˆ ì£¼ì˜ì‚¬í•­ (RULE-007)

- **ì ˆëŒ€ë¡œ ì„œë¹„ìŠ¤ ê³„ì • í‚¤, í¬ë¦¬ë´ì…œ, ë¹„ë°€ì •ë³´ë¥¼ ì´ ë””ë ‰í† ë¦¬ì— ë°°ì¹˜í•˜ì§€ ë§ˆì„¸ìš”.**
- í‚¤ íŒŒì¼ì€ ë°˜ë“œì‹œ `secrets/` ë””ë ‰í† ë¦¬ì—ë§Œ ë°°ì¹˜í•©ë‹ˆë‹¤ (`.gitignore`ë¡œ ì°¨ë‹¨ë¨).
- ìŠ¤í‚¤ë§ˆ íŒŒì¼ì€ "ê³„ì•½ ë¬¸ì„œ"ì´ë¯€ë¡œ ì»¤ë°‹í•´ë„ ë³´ì•ˆ ìœ„í—˜ì´ ì—†ìŠµë‹ˆë‹¤ (ë‹¨, ë¹„ë°€ê°’ í¬í•¨ ê¸ˆì§€).

## ğŸ“š ê´€ë ¨ ë¬¸ì„œ

- `vibe/refactors/RU-001-Q4.md` - JSON Schema SSOT ë„ì… ê·¼ê±°
- `vibe/refactors/RU-001-S1.md` - .gitignore JSON ì •ì±… ë³€ê²½ ê·¼ê±°
- `vibe/ref/structured-outputs-guide.md` - Gemini Structured Output ê°€ì´ë“œ
- `vibe/prd.md` (8.7ì ˆ) - TurnInput/TurnOutput ì„¤ê³„ ë°©í–¥
- `.cursor/rules/00-core-critical.mdc` - RULE-003 (ì´ì¤‘ ê²€ì¦), RULE-007 (ë³´ì•ˆ)
</file>

<file path="backend/src/unknown_world/api/turn_streaming_helpers.py">
"""Unknown World - Turn ìŠ¤íŠ¸ë¦¬ë° ê³µí†µ í—¬í¼.

NDJSON ìŠ¤íŠ¸ë¦¬ë°ì—ì„œ ë°˜ë³µë˜ëŠ” íŒ¨í„´ì„ ì¶”ì¶œí•œ í—¬í¼ í•¨ìˆ˜ë“¤ì…ë‹ˆë‹¤.

ì„¤ê³„ ì›ì¹™:
    - RU-005-Q3: ì¤‘ë³µë˜ëŠ” ìŠ¤íŠ¸ë¦¬ë° ì¡°ê°ì„ helperë¡œ ì¶”ì¶œ
    - RULE-004: ì—ëŸ¬ ê²½ë¡œì—ì„œë„ final 1íšŒ ì¢…ë£Œ ì¸ë°”ë¦¬ì–¸íŠ¸ ìœ ì§€
    - RULE-007/008: í”„ë¡¬í”„íŠ¸/ë‚´ë¶€ ì¶”ë¡  ë…¸ì¶œ ê¸ˆì§€

ì°¸ì¡°:
    - vibe/refactors/RU-005-Q3.md
    - vibe/unit-plans/U-007[Mvp].md
"""

from __future__ import annotations

import asyncio
from collections.abc import AsyncGenerator

from unknown_world.api.turn_stream_events import (
    ErrorEvent,
    FinalEvent,
    NarrativeDeltaEvent,
    StreamEventType,
    serialize_event,
)
from unknown_world.models.turn import (
    CurrencyAmount,
    Language,
    TurnOutput,
)
from unknown_world.orchestrator.fallback import create_safe_fallback

# =============================================================================
# ìŠ¤íŠ¸ë¦¬ë° í—¬í¼ ìƒìˆ˜
# =============================================================================

DEFAULT_CHUNK_SIZE = 20
"""ë‚´ëŸ¬í‹°ë¸Œ ë¸íƒ€ ì²­í¬ í¬ê¸° (ë¬¸ì ìˆ˜)."""

DEFAULT_TYPING_DELAY_SEC = 0.02
"""íƒ€ì íš¨ê³¼ ë”œë ˆì´ (ì´ˆ)."""

# =============================================================================
# ì—ëŸ¬ ë©”ì‹œì§€ (i18n)
# =============================================================================

ERROR_MESSAGES = {
    Language.KO: {
        "internal_error": "ì²˜ë¦¬ ì¤‘ ì˜¤ë¥˜ê°€ ë°œìƒí–ˆìŠµë‹ˆë‹¤",
        "validation_error": "ì…ë ¥ ê²€ì¦ì— ì‹¤íŒ¨í–ˆìŠµë‹ˆë‹¤",
    },
    Language.EN: {
        "internal_error": "An error occurred during processing",
        "validation_error": "Input validation failed",
    },
}


# =============================================================================
# ë‚´ëŸ¬í‹°ë¸Œ ë¸íƒ€ ìŠ¤íŠ¸ë¦¬ë° í—¬í¼
# =============================================================================


async def stream_narrative_delta(
    narrative: str,
    *,
    chunk_size: int = DEFAULT_CHUNK_SIZE,
    delay_sec: float = DEFAULT_TYPING_DELAY_SEC,
) -> AsyncGenerator[str]:
    """ë‚´ëŸ¬í‹°ë¸Œ í…ìŠ¤íŠ¸ë¥¼ íƒ€ì íš¨ê³¼ë¡œ ìŠ¤íŠ¸ë¦¬ë°í•©ë‹ˆë‹¤.

    Args:
        narrative: ì „ì²´ ë‚´ëŸ¬í‹°ë¸Œ í…ìŠ¤íŠ¸
        chunk_size: ì²­í¬ë‹¹ ë¬¸ì ìˆ˜ (ê¸°ë³¸ 20)
        delay_sec: ì²­í¬ ê°„ ë”œë ˆì´ (ì´ˆ, ê¸°ë³¸ 0.02)

    Yields:
        str: NDJSON ë¼ì¸ (narrative_delta ì´ë²¤íŠ¸)

    Example:
        >>> async for line in stream_narrative_delta("ì•ˆë…•í•˜ì„¸ìš”"):
        ...     print(line)
    """
    for i in range(0, len(narrative), chunk_size):
        chunk = narrative[i : i + chunk_size]
        yield serialize_event(
            NarrativeDeltaEvent(
                type=StreamEventType.NARRATIVE_DELTA,
                text=chunk,
            ).model_dump()
        )
        await asyncio.sleep(delay_sec)


# =============================================================================
# Error + Final í´ë°± í—¬í¼
# =============================================================================


async def emit_error_with_fallback(
    language: Language,
    *,
    error_message: str | None = None,
    error_code: str = "INTERNAL_ERROR",
    economy_snapshot: CurrencyAmount | None = None,
    repair_count: int = 0,
    is_blocked: bool = False,
) -> AsyncGenerator[str]:
    """ì—ëŸ¬ ì´ë²¤íŠ¸ì™€ ì•ˆì „í•œ í´ë°± finalì„ ìˆœì„œëŒ€ë¡œ ì†¡ì¶œí•©ë‹ˆë‹¤.

    RULE-004: ì—ëŸ¬ ê²½ë¡œì—ì„œë„ ë°˜ë“œì‹œ final 1íšŒ ì¢…ë£Œ ì¸ë°”ë¦¬ì–¸íŠ¸ë¥¼ ìœ ì§€í•©ë‹ˆë‹¤.

    Args:
        language: ì‘ë‹µ ì–¸ì–´
        error_message: ì—ëŸ¬ ë©”ì‹œì§€ (Noneì´ë©´ ê¸°ë³¸ ë©”ì‹œì§€ ì‚¬ìš©)
        error_code: ì—ëŸ¬ ì½”ë“œ (ê¸°ë³¸ "INTERNAL_ERROR")
        economy_snapshot: í˜„ì¬ ì¬í™” ìƒíƒœ
        repair_count: ë³µêµ¬ ì‹œë„ íšŸìˆ˜
        is_blocked: ì•ˆì „ ì •ì±…ì— ì˜í•´ ì°¨ë‹¨ë˜ì—ˆëŠ”ì§€

    Yields:
        str: NDJSON ë¼ì¸ (error ì´ë²¤íŠ¸ â†’ final ì´ë²¤íŠ¸)

    Example:
        >>> async for line in emit_error_with_fallback(Language.KO):
        ...     print(line)
    """
    # ì—ëŸ¬ ë©”ì‹œì§€ ê²°ì •
    messages = ERROR_MESSAGES[language]
    message = error_message or messages.get("internal_error", "Error occurred")

    # ì—ëŸ¬ ì´ë²¤íŠ¸ ì†¡ì¶œ
    yield serialize_event(
        ErrorEvent(
            type=StreamEventType.ERROR,
            message=message,
            code=error_code,
        ).model_dump()
    )

    # ì•ˆì „í•œ í´ë°± ìƒì„± ë° ì†¡ì¶œ
    fallback = create_safe_fallback(
        language=language,
        economy_snapshot=economy_snapshot,
        repair_count=repair_count,
        is_blocked=is_blocked,
    )
    yield serialize_event(
        FinalEvent(
            type=StreamEventType.FINAL,
            data=fallback,
        ).model_dump(mode="json")
    )


async def emit_final(output: TurnOutput) -> AsyncGenerator[str]:
    """ìµœì¢… TurnOutputì„ final ì´ë²¤íŠ¸ë¡œ ì†¡ì¶œí•©ë‹ˆë‹¤.

    Args:
        output: ìµœì¢… TurnOutput

    Yields:
        str: NDJSON ë¼ì¸ (final ì´ë²¤íŠ¸)
    """
    yield serialize_event(
        FinalEvent(
            type=StreamEventType.FINAL,
            data=output,
        ).model_dump(mode="json")
    )


# =============================================================================
# ë³µí•© í—¬í¼ (ë‚´ëŸ¬í‹°ë¸Œ + final)
# =============================================================================


async def stream_output_with_narrative(
    output: TurnOutput,
    *,
    chunk_size: int = DEFAULT_CHUNK_SIZE,
    delay_sec: float = DEFAULT_TYPING_DELAY_SEC,
) -> AsyncGenerator[str]:
    """ë‚´ëŸ¬í‹°ë¸Œ ë¸íƒ€ ìŠ¤íŠ¸ë¦¬ë° í›„ final ì´ë²¤íŠ¸ë¥¼ ì†¡ì¶œí•©ë‹ˆë‹¤.

    Args:
        output: ìµœì¢… TurnOutput
        chunk_size: ì²­í¬ë‹¹ ë¬¸ì ìˆ˜
        delay_sec: ì²­í¬ ê°„ ë”œë ˆì´ (ì´ˆ)

    Yields:
        str: NDJSON ë¼ì¸ (narrative_delta ì´ë²¤íŠ¸ë“¤ â†’ final ì´ë²¤íŠ¸)
    """
    # ë‚´ëŸ¬í‹°ë¸Œ ë¸íƒ€ ìŠ¤íŠ¸ë¦¬ë°
    async for line in stream_narrative_delta(
        output.narrative,
        chunk_size=chunk_size,
        delay_sec=delay_sec,
    ):
        yield line

    # final ì´ë²¤íŠ¸ ì†¡ì¶œ
    async for line in emit_final(output):
        yield line


# =============================================================================
# ëª¨ë“ˆ ê³µê°œ API
# =============================================================================

__all__ = [
    "DEFAULT_CHUNK_SIZE",
    "DEFAULT_TYPING_DELAY_SEC",
    "ERROR_MESSAGES",
    "stream_narrative_delta",
    "emit_error_with_fallback",
    "emit_final",
    "stream_output_with_narrative",
]
</file>

<file path="backend/src/unknown_world/config/__init__.py">
"""Unknown World - ì„¤ì • ë° ìƒìˆ˜ íŒ¨í‚¤ì§€.

ì´ íŒ¨í‚¤ì§€ëŠ” í”„ë¡œì íŠ¸ ì „ì—­ì—ì„œ ì‚¬ìš©í•˜ëŠ” ì„¤ì •ê°’ê³¼ ìƒìˆ˜ë¥¼ ê´€ë¦¬í•©ë‹ˆë‹¤.
ëª¨ë¸ ID, í™˜ê²½ ì„¤ì •, ì •ì±… ë“± SSOTë¥¼ ìœ ì§€í•˜ê¸° ìœ„í•œ ì¤‘ì•™ ì €ì¥ì†Œì…ë‹ˆë‹¤.

ì°¸ì¡°:
    - vibe/tech-stack.md (ë²„ì „/ëª¨ë¸ SSOT)
    - .cursor/rules/00-core-critical.mdc (RULE-010: ë²„ì „/ìŠ¤íƒ ê³ ì •)
"""

from unknown_world.config.models import (
    MODEL_FAST,
    MODEL_IMAGE,
    MODEL_QUALITY,
    ModelLabel,
    get_model_id,
)

__all__ = [
    "MODEL_FAST",
    "MODEL_QUALITY",
    "MODEL_IMAGE",
    "ModelLabel",
    "get_model_id",
]
</file>

<file path="backend/src/unknown_world/config/models.py">
"""Unknown World - ëª¨ë¸ ë¼ë²¨ ë° ID ìƒìˆ˜ ì •ì˜.

ì´ ëª¨ë“ˆì€ Gemini ëª¨ë¸ IDì™€ ë¼ë²¨ì„ SSOTë¡œ ê´€ë¦¬í•©ë‹ˆë‹¤.
tech-stack.md ê¸°ì¤€ìœ¼ë¡œ ë²„ì „/ëª¨ë¸ IDê°€ ê³ ì •ë˜ì–´ ìˆìœ¼ë©°,
ì„ì˜ ë³€ê²½ì€ RULE-010 ìœ„ë°˜ì…ë‹ˆë‹¤.

ëª¨ë¸ ë¼ì¸ì—… (tech-stack.md ê¸°ì¤€):
    - í…ìŠ¤íŠ¸ FAST: gemini-3-flash-preview
    - í…ìŠ¤íŠ¸ QUALITY: gemini-3-pro-preview
    - ì´ë¯¸ì§€(ìƒì„±/í¸ì§‘): gemini-3-pro-image-preview (ê³ ì •)

ì°¸ì¡°:
    - vibe/tech-stack.md (ë²„ì „ ê¸°ì¤€ì¼: 2026-01-01)
    - .cursor/rules/00-core-critical.mdc (RULE-007/010)
"""

from enum import StrEnum
from typing import Final


class ModelLabel(StrEnum):
    """ëª¨ë¸ ë¼ë²¨ ì—´ê±°í˜•.

    UI/ë¡œê·¸ì—ëŠ” ëª¨ë¸ ID ì›ë¬¸ ëŒ€ì‹  ì´ ë¼ë²¨ì„ ìš°ì„  ë…¸ì¶œí•©ë‹ˆë‹¤. (RULE-008)
    """

    FAST = "FAST"
    """ë¹ ë¥¸ ì‘ë‹µìš© í…ìŠ¤íŠ¸ ëª¨ë¸ (gemini-3-flash-preview)"""

    QUALITY = "QUALITY"
    """ê³ í’ˆì§ˆ í…ìŠ¤íŠ¸ ëª¨ë¸ (gemini-3-pro-preview)"""

    IMAGE = "IMAGE"
    """ì´ë¯¸ì§€ ìƒì„±/í¸ì§‘ ëª¨ë¸ (gemini-3-pro-image-preview, ê³ ì •)"""

    VISION = "VISION"
    """ë¹„ì „/ê³µê°„ ë¶„ì„ ëª¨ë¸ (bbox/segmentationìš©, gemini-3-flash-preview)"""


# =============================================================================
# ëª¨ë¸ ID ìƒìˆ˜ (tech-stack.md SSOT)
# =============================================================================
# ì£¼ì˜: ì´ ê°’ë“¤ì€ tech-stack.mdì™€ 1:1ë¡œ ì¼ì¹˜í•´ì•¼ í•©ë‹ˆë‹¤.
# ì„ì˜ ë³€ê²½ ê¸ˆì§€ (RULE-010)

MODEL_FAST: Final[str] = "gemini-3-flash-preview"
"""FAST ë¼ë²¨ ëª¨ë¸ ID - ë¹ ë¥¸ í…ìŠ¤íŠ¸ ìƒì„±ìš©"""

MODEL_QUALITY: Final[str] = "gemini-3-pro-preview"
"""QUALITY ë¼ë²¨ ëª¨ë¸ ID - ê³ í’ˆì§ˆ í…ìŠ¤íŠ¸ ìƒì„±ìš©"""

MODEL_IMAGE: Final[str] = "gemini-3-pro-image-preview"
"""IMAGE ë¼ë²¨ ëª¨ë¸ ID - ì´ë¯¸ì§€ ìƒì„±/í¸ì§‘ìš© (ê³ ì •, RULE-010)"""

MODEL_VISION: Final[str] = "gemini-3-flash-preview"
"""VISION ë¼ë²¨ ëª¨ë¸ ID - ë¹„ì „/ê³µê°„ ë¶„ì„ìš© (bbox/segmentation)"""


# ë¼ë²¨-ID ë§¤í•‘ í…Œì´ë¸”
_MODEL_MAP: Final[dict[ModelLabel, str]] = {
    ModelLabel.FAST: MODEL_FAST,
    ModelLabel.QUALITY: MODEL_QUALITY,
    ModelLabel.IMAGE: MODEL_IMAGE,
    ModelLabel.VISION: MODEL_VISION,
}


def get_model_id(label: ModelLabel) -> str:
    """ë¼ë²¨ë¡œ ëª¨ë¸ IDë¥¼ ì¡°íšŒí•©ë‹ˆë‹¤.

    Args:
        label: ëª¨ë¸ ë¼ë²¨ (FAST, QUALITY, IMAGE, VISION)

    Returns:
        í•´ë‹¹ ë¼ë²¨ì— ë§¤í•‘ëœ ëª¨ë¸ ID ë¬¸ìì—´

    Example:
        >>> get_model_id(ModelLabel.FAST)
        'gemini-3-flash-preview'
    """
    return _MODEL_MAP[label]
</file>

<file path="backend/src/unknown_world/orchestrator/pipeline.py">
"""Unknown World - Pipeline ì‹¤í–‰ê¸°.

Stage í•¨ìˆ˜ë“¤ì„ ì²´ì¸ìœ¼ë¡œ ì¡°í•©í•˜ì—¬ ì‹¤í–‰í•˜ëŠ” íŒŒì´í”„ë¼ì¸ì…ë‹ˆë‹¤.

ì„¤ê³„ ì›ì¹™:
    - Option A (RU-005 Q1 ê²°ì •): í•¨ìˆ˜ ì²´ì¸ ë°©ì‹, í´ë˜ìŠ¤ ë„ì… ì—†ìŒ
    - ë™ì‘ ë³´ì¡´: ê¸°ì¡´ mock/real ê²½ë¡œì˜ ê²°ê³¼(JSON) ì˜ë¯¸ ìœ ì§€
    - ê´€ì¸¡ ê°€ëŠ¥ì„± SSOT: stage start/complete/fail, badges, repairë¥¼ ì¼ê´€ë˜ê²Œ ìƒì„±
    - ë ˆì´ì–´ë§ ë³´í˜¸: ì˜¤ì¼€ìŠ¤íŠ¸ë ˆì´í„°ê°€ FastAPIì— ì§ì ‘ ì˜ì¡´í•˜ì§€ ì•ŠìŒ

ì°¸ì¡°:
    - vibe/refactors/RU-005-Q4.md
    - vibe/refactors/RU-005-SUMMARY.md
"""

from __future__ import annotations

import os
from collections.abc import Sequence

from unknown_world.models.turn import CurrencyAmount, TurnInput
from unknown_world.orchestrator.fallback import create_safe_fallback
from unknown_world.orchestrator.stages.commit import commit_stage
from unknown_world.orchestrator.stages.parse import parse_stage
from unknown_world.orchestrator.stages.plan import plan_stage
from unknown_world.orchestrator.stages.render import render_stage
from unknown_world.orchestrator.stages.resolve import resolve_stage
from unknown_world.orchestrator.stages.types import (
    EmitFn,
    PipelineContext,
    StageFn,
)
from unknown_world.orchestrator.stages.validate import validate_stage
from unknown_world.orchestrator.stages.verify import verify_stage

# =============================================================================
# ê¸°ë³¸ Stage ìˆœì„œ (PRD ê¸°ì¤€)
# =============================================================================

DEFAULT_STAGES: Sequence[StageFn] = [
    parse_stage,
    validate_stage,
    plan_stage,
    resolve_stage,
    render_stage,
    verify_stage,
    commit_stage,
]
"""ê¸°ë³¸ íŒŒì´í”„ë¼ì¸ ë‹¨ê³„ ìˆœì„œ.

Parse â†’ Validate â†’ Plan â†’ Resolve â†’ Render â†’ Verify â†’ Commit
"""


# =============================================================================
# Pipeline ì‹¤í–‰ í•¨ìˆ˜
# =============================================================================


def _is_mock_mode() -> bool:
    """Mock ëª¨ë“œ ì—¬ë¶€ë¥¼ í™•ì¸í•©ë‹ˆë‹¤.

    UW_MODE í™˜ê²½ë³€ìˆ˜ê°€ 'mock'ì´ë©´ Mock ëª¨ë“œë¡œ ë™ì‘í•©ë‹ˆë‹¤.
    ê¸°ë³¸ê°’ì€ 'mock'ì…ë‹ˆë‹¤ (MVP ë‹¨ê³„).
    """
    return os.environ.get("UW_MODE", "mock").lower() == "mock"


def create_pipeline_context(
    turn_input: TurnInput,
    *,
    seed: int | None = None,
    is_mock: bool | None = None,
) -> PipelineContext:
    """íŒŒì´í”„ë¼ì¸ ì»¨í…ìŠ¤íŠ¸ë¥¼ ìƒì„±í•©ë‹ˆë‹¤.

    Args:
        turn_input: ì‚¬ìš©ì í„´ ì…ë ¥
        seed: Mock ëª¨ë“œ ì‹œë“œ (ì¬í˜„ì„± ë³´ì¥)
        is_mock: Mock ëª¨ë“œ ì—¬ë¶€ (Noneì´ë©´ í™˜ê²½ë³€ìˆ˜ ê¸°ì¤€)

    Returns:
        ì´ˆê¸°í™”ëœ íŒŒì´í”„ë¼ì¸ ì»¨í…ìŠ¤íŠ¸
    """
    economy_snapshot = CurrencyAmount(
        signal=turn_input.economy_snapshot.signal,
        memory_shard=turn_input.economy_snapshot.memory_shard,
    )

    return PipelineContext(
        turn_input=turn_input,
        economy_snapshot=economy_snapshot,
        is_mock=is_mock if is_mock is not None else _is_mock_mode(),
        seed=seed,
    )


async def run_pipeline(
    ctx: PipelineContext,
    *,
    emit: EmitFn,
    stages: Sequence[StageFn] | None = None,
) -> PipelineContext:
    """íŒŒì´í”„ë¼ì¸ì„ ì‹¤í–‰í•©ë‹ˆë‹¤.

    Stage í•¨ìˆ˜ë“¤ì„ ìˆœì„œëŒ€ë¡œ ì‹¤í–‰í•˜ê³ , ê° ë‹¨ê³„ì—ì„œ emit ì½œë°±ì„ í†µí•´
    ë„ë©”ì¸ ì´ë²¤íŠ¸ë¥¼ ì „ë‹¬í•©ë‹ˆë‹¤.

    ì˜ˆì™¸ê°€ ë°œìƒí•˜ë©´ ì•ˆì „í•œ í´ë°±ìœ¼ë¡œ ì¢…ë£Œí•©ë‹ˆë‹¤ (RULE-004).

    Args:
        ctx: íŒŒì´í”„ë¼ì¸ ì»¨í…ìŠ¤íŠ¸
        emit: ì´ë²¤íŠ¸ emit ì½œë°±
        stages: ì‹¤í–‰í•  stage ëª©ë¡ (Noneì´ë©´ ê¸°ë³¸ ìˆœì„œ)

    Returns:
        ìµœì¢… íŒŒì´í”„ë¼ì¸ ì»¨í…ìŠ¤íŠ¸

    Example:
        >>> ctx = create_pipeline_context(turn_input, seed=42)
        >>> ctx = await run_pipeline(ctx, emit=my_emit_fn)
        >>> print(ctx.output.narrative)
    """
    if stages is None:
        stages = DEFAULT_STAGES

    try:
        for stage in stages:
            ctx = await stage(ctx, emit=emit)

            # outputì´ Noneì´ë©´ validate ì‹¤íŒ¨ ë“± â†’ ì´í›„ ë‹¨ê³„ëŠ” ìŠ¤í‚µ
            # (ë‹¨, parse ë‹¨ê³„ëŠ” outputì´ ì—†ì–´ë„ ì •ìƒ)
            if ctx.output is None and stage != parse_stage:
                # í´ë°± ìƒì„±
                ctx.output = create_safe_fallback(
                    language=ctx.turn_input.language,
                    economy_snapshot=ctx.economy_snapshot,
                    repair_count=ctx.repair_attempts,
                )
                ctx.is_fallback = True
                break

    except Exception:
        # ì˜ˆì™¸ ë°œìƒ ì‹œ ì•ˆì „í•œ í´ë°± (RULE-004)
        ctx.output = create_safe_fallback(
            language=ctx.turn_input.language,
            economy_snapshot=ctx.economy_snapshot,
            repair_count=ctx.repair_attempts,
        )
        ctx.is_fallback = True

    return ctx
</file>

<file path="backend/src/unknown_world/orchestrator/stages/__init__.py">
"""Unknown World - Pipeline Stages íŒ¨í‚¤ì§€.

ì˜¤ì¼€ìŠ¤íŠ¸ë ˆì´í„° íŒŒì´í”„ë¼ì¸ì˜ ê° ë‹¨ê³„(stage)ë¥¼ ëª¨ë“ˆë¡œ ë¶„ë¦¬í•©ë‹ˆë‹¤.

ë‹¨ê³„ ëª©ë¡ (PRD ê¸°ì¤€):
    - parse: ì…ë ¥ íŒŒì‹± (ì´ë¯¸ TurnInputìœ¼ë¡œ ë³€í™˜ë¨, phase ì „ì´ë§Œ ë‹´ë‹¹)
    - validate: ë¹„ì¦ˆë‹ˆìŠ¤ ë£° ê²€ì¦ + Repair loop (í•µì‹¬)
    - plan: ê³„íš ìˆ˜ë¦½ (í˜„ì¬ pass-through)
    - resolve: í•´ê²° (í˜„ì¬ pass-through)
    - render: ë Œë”ë§ (í˜„ì¬ pass-through)
    - verify: ê²€ì¦ (í˜„ì¬ pass-through)
    - commit: ì»¤ë°‹ (ìµœì¢… í™•ì •)

ì„¤ê³„ ì›ì¹™:
    - Option A (RU-005 Q1 ê²°ì •): í•¨ìˆ˜ ì²´ì¸ ë°©ì‹, í´ë˜ìŠ¤ ë„ì… ì—†ìŒ
    - ë™ì‘ ë³´ì¡´: ê¸°ì¡´ mock/real ê²½ë¡œì˜ ê²°ê³¼(JSON) ì˜ë¯¸ ìœ ì§€
    - ê´€ì¸¡ ê°€ëŠ¥ì„± SSOT: stage start/complete/fail, badges, repairë¥¼ pipelineì—ì„œ ì¼ê´€ë˜ê²Œ ìƒì„±

ì°¸ì¡°:
    - vibe/refactors/RU-005-Q4.md
    - vibe/refactors/RU-005-SUMMARY.md
"""

from unknown_world.orchestrator.stages.commit import commit_stage
from unknown_world.orchestrator.stages.parse import parse_stage
from unknown_world.orchestrator.stages.plan import plan_stage
from unknown_world.orchestrator.stages.render import render_stage
from unknown_world.orchestrator.stages.resolve import resolve_stage
from unknown_world.orchestrator.stages.types import (
    EmitFn,
    PipelineContext,
    PipelineEvent,
    PipelineEventType,
    StageFn,
)
from unknown_world.orchestrator.stages.validate import validate_stage
from unknown_world.orchestrator.stages.verify import verify_stage

__all__ = [
    # Types
    "PipelineContext",
    "PipelineEvent",
    "PipelineEventType",
    "EmitFn",
    "StageFn",
    # Stages
    "parse_stage",
    "validate_stage",
    "plan_stage",
    "resolve_stage",
    "render_stage",
    "verify_stage",
    "commit_stage",
]
</file>

<file path="backend/src/unknown_world/orchestrator/stages/commit.py">
"""Unknown World - Commit Stage.

ì»¤ë°‹ ë‹¨ê³„ì…ë‹ˆë‹¤.
íŒŒì´í”„ë¼ì¸ì˜ ìµœì¢… ë‹¨ê³„ë¡œ, TurnOutputì„ í™•ì •í•©ë‹ˆë‹¤.

ì„¤ê³„ ì›ì¹™:
    - RULE-008: ë‹¨ê³„ ì´ë²¤íŠ¸ ì¼ê´€ì„±
    - ë™ì‘ ë³´ì¡´: ê¸°ì¡´ ì‹œë®¬ë ˆì´ì…˜ ì§€ì—° ìœ ì§€

ì°¸ì¡°:
    - vibe/refactors/RU-005-Q4.md
"""

from __future__ import annotations

import asyncio

from unknown_world.models.turn import AgentPhase
from unknown_world.orchestrator.stages.types import (
    EmitFn,
    PipelineContext,
    PipelineEvent,
    PipelineEventType,
)

# ëª¨ì˜ ì²˜ë¦¬ ì§€ì—° ì‹œê°„ (ms)
COMMIT_DELAY_MS = 20


async def commit_stage(ctx: PipelineContext, *, emit: EmitFn) -> PipelineContext:
    """Commit ë‹¨ê³„ë¥¼ ì‹¤í–‰í•©ë‹ˆë‹¤.

    íŒŒì´í”„ë¼ì¸ì˜ ìµœì¢… ë‹¨ê³„ë¡œ, TurnOutputì„ í™•ì •í•©ë‹ˆë‹¤.

    Args:
        ctx: íŒŒì´í”„ë¼ì¸ ì»¨í…ìŠ¤íŠ¸
        emit: ì´ë²¤íŠ¸ emit ì½œë°±

    Returns:
        ì—…ë°ì´íŠ¸ëœ ì»¨í…ìŠ¤íŠ¸
    """
    ctx.current_phase = AgentPhase.COMMIT

    # Stage ì‹œì‘ ì´ë²¤íŠ¸
    await emit(
        PipelineEvent(
            event_type=PipelineEventType.STAGE_START,
            phase=AgentPhase.COMMIT,
        )
    )

    # ëª¨ì˜ ì²˜ë¦¬ ì§€ì—° (ê¸°ì¡´ ë™ì‘ ë³´ì¡´)
    await asyncio.sleep(COMMIT_DELAY_MS / 1000.0)

    # Stage ì™„ë£Œ ì´ë²¤íŠ¸
    await emit(
        PipelineEvent(
            event_type=PipelineEventType.STAGE_COMPLETE,
            phase=AgentPhase.COMMIT,
        )
    )

    return ctx
</file>

<file path="backend/src/unknown_world/orchestrator/stages/parse.py">
"""Unknown World - Parse Stage.

ì…ë ¥ íŒŒì‹± ë‹¨ê³„ì…ë‹ˆë‹¤.
TurnInputì€ ì´ë¯¸ API ë ˆì´ì–´ì—ì„œ íŒŒì‹±ë˜ì—ˆìœ¼ë¯€ë¡œ, phase ì „ì´ë§Œ ë‹´ë‹¹í•©ë‹ˆë‹¤.

ì„¤ê³„ ì›ì¹™:
    - RULE-008: ë‹¨ê³„ ì´ë²¤íŠ¸ ì¼ê´€ì„± (stage start/complete)
    - ë™ì‘ ë³´ì¡´: ê¸°ì¡´ ë™ì‘ ìœ ì§€

ì°¸ì¡°:
    - vibe/refactors/RU-005-Q4.md
"""

from __future__ import annotations

from unknown_world.models.turn import AgentPhase
from unknown_world.orchestrator.stages.types import (
    EmitFn,
    PipelineContext,
    PipelineEvent,
    PipelineEventType,
)


async def parse_stage(ctx: PipelineContext, *, emit: EmitFn) -> PipelineContext:
    """Parse ë‹¨ê³„ë¥¼ ì‹¤í–‰í•©ë‹ˆë‹¤.

    ì…ë ¥ì€ ì´ë¯¸ TurnInputìœ¼ë¡œ íŒŒì‹±ë˜ì—ˆìœ¼ë¯€ë¡œ, phase ì „ì´ë§Œ ë‹´ë‹¹í•©ë‹ˆë‹¤.
    TTFBë¥¼ ìœ„í•´ ê°€ì¥ ë¨¼ì € stage ì´ë²¤íŠ¸ë¥¼ ì „ì†¡í•©ë‹ˆë‹¤.

    Args:
        ctx: íŒŒì´í”„ë¼ì¸ ì»¨í…ìŠ¤íŠ¸
        emit: ì´ë²¤íŠ¸ emit ì½œë°±

    Returns:
        ì—…ë°ì´íŠ¸ëœ ì»¨í…ìŠ¤íŠ¸
    """
    ctx.current_phase = AgentPhase.PARSE

    # Stage ì‹œì‘ ì´ë²¤íŠ¸ (TTFBë¥¼ ìœ„í•´ ì¦‰ì‹œ ì „ì†¡)
    await emit(
        PipelineEvent(
            event_type=PipelineEventType.STAGE_START,
            phase=AgentPhase.PARSE,
        )
    )

    # Parse ë‹¨ê³„ëŠ” ì´ë¯¸ API ë ˆì´ì–´ì—ì„œ ì™„ë£Œë¨
    # (TurnInput ê²€ì¦ì€ FastAPI/Pydanticì—ì„œ ì²˜ë¦¬)

    # Stage ì™„ë£Œ ì´ë²¤íŠ¸
    await emit(
        PipelineEvent(
            event_type=PipelineEventType.STAGE_COMPLETE,
            phase=AgentPhase.PARSE,
        )
    )

    return ctx
</file>

<file path="backend/src/unknown_world/orchestrator/stages/plan.py">
"""Unknown World - Plan Stage.

ê³„íš ìˆ˜ë¦½ ë‹¨ê³„ì…ë‹ˆë‹¤.
í˜„ì¬ MVPì—ì„œëŠ” ì‹¤ì œ ì²˜ë¦¬ ì—†ì´ pass-throughë¡œ ë™ì‘í•©ë‹ˆë‹¤.
ì¶”í›„ Autopilot(U-024) ë“±ì—ì„œ ë¡œì§ì„ ì¶”ê°€í•  ìë¦¬ì…ë‹ˆë‹¤.

ì„¤ê³„ ì›ì¹™:
    - RULE-008: ë‹¨ê³„ ì´ë²¤íŠ¸ ì¼ê´€ì„±
    - ë™ì‘ ë³´ì¡´: ê¸°ì¡´ ì‹œë®¬ë ˆì´ì…˜ ì§€ì—° ìœ ì§€

ì°¸ì¡°:
    - vibe/refactors/RU-005-Q4.md
"""

from __future__ import annotations

import asyncio

from unknown_world.models.turn import AgentPhase
from unknown_world.orchestrator.stages.types import (
    EmitFn,
    PipelineContext,
    PipelineEvent,
    PipelineEventType,
)

# ëª¨ì˜ ì²˜ë¦¬ ì§€ì—° ì‹œê°„ (ms)
PLAN_DELAY_MS = 100


async def plan_stage(ctx: PipelineContext, *, emit: EmitFn) -> PipelineContext:
    """Plan ë‹¨ê³„ë¥¼ ì‹¤í–‰í•©ë‹ˆë‹¤.

    í˜„ì¬ëŠ” pass-throughë¡œ ë™ì‘í•©ë‹ˆë‹¤.
    ì¶”í›„ Autopilot ë“±ì—ì„œ ê³„íš ìˆ˜ë¦½ ë¡œì§ì„ ì¶”ê°€í•©ë‹ˆë‹¤.

    Args:
        ctx: íŒŒì´í”„ë¼ì¸ ì»¨í…ìŠ¤íŠ¸
        emit: ì´ë²¤íŠ¸ emit ì½œë°±

    Returns:
        ì—…ë°ì´íŠ¸ëœ ì»¨í…ìŠ¤íŠ¸
    """
    ctx.current_phase = AgentPhase.PLAN

    # Stage ì‹œì‘ ì´ë²¤íŠ¸
    await emit(
        PipelineEvent(
            event_type=PipelineEventType.STAGE_START,
            phase=AgentPhase.PLAN,
        )
    )

    # ëª¨ì˜ ì²˜ë¦¬ ì§€ì—° (ê¸°ì¡´ ë™ì‘ ë³´ì¡´)
    await asyncio.sleep(PLAN_DELAY_MS / 1000.0)

    # Stage ì™„ë£Œ ì´ë²¤íŠ¸
    await emit(
        PipelineEvent(
            event_type=PipelineEventType.STAGE_COMPLETE,
            phase=AgentPhase.PLAN,
        )
    )

    return ctx
</file>

<file path="backend/src/unknown_world/orchestrator/stages/render.py">
"""Unknown World - Render Stage.

ë Œë”ë§ ë‹¨ê³„ì…ë‹ˆë‹¤.
í˜„ì¬ MVPì—ì„œëŠ” ì‹¤ì œ ì´ë¯¸ì§€ ìƒì„± ì—†ì´ pass-throughë¡œ ë™ì‘í•©ë‹ˆë‹¤.
ì¶”í›„ ì´ë¯¸ì§€ íŒŒì´í”„ë¼ì¸(U-019~)ì—ì„œ ë¡œì§ì„ ì¶”ê°€í•  ìë¦¬ì…ë‹ˆë‹¤.

ì„¤ê³„ ì›ì¹™:
    - RULE-008: ë‹¨ê³„ ì´ë²¤íŠ¸ ì¼ê´€ì„±
    - ë™ì‘ ë³´ì¡´: ê¸°ì¡´ ì‹œë®¬ë ˆì´ì…˜ ì§€ì—° ìœ ì§€

ì°¸ì¡°:
    - vibe/refactors/RU-005-Q4.md
"""

from __future__ import annotations

import asyncio

from unknown_world.models.turn import AgentPhase
from unknown_world.orchestrator.stages.types import (
    EmitFn,
    PipelineContext,
    PipelineEvent,
    PipelineEventType,
)

# ëª¨ì˜ ì²˜ë¦¬ ì§€ì—° ì‹œê°„ (ms)
RENDER_DELAY_MS = 80


async def render_stage(ctx: PipelineContext, *, emit: EmitFn) -> PipelineContext:
    """Render ë‹¨ê³„ë¥¼ ì‹¤í–‰í•©ë‹ˆë‹¤.

    í˜„ì¬ëŠ” pass-throughë¡œ ë™ì‘í•©ë‹ˆë‹¤.
    ì¶”í›„ ì´ë¯¸ì§€ ìƒì„±/í¸ì§‘ íŒŒì´í”„ë¼ì¸ì´ ì¶”ê°€ë©ë‹ˆë‹¤.

    Args:
        ctx: íŒŒì´í”„ë¼ì¸ ì»¨í…ìŠ¤íŠ¸
        emit: ì´ë²¤íŠ¸ emit ì½œë°±

    Returns:
        ì—…ë°ì´íŠ¸ëœ ì»¨í…ìŠ¤íŠ¸
    """
    ctx.current_phase = AgentPhase.RENDER

    # Stage ì‹œì‘ ì´ë²¤íŠ¸
    await emit(
        PipelineEvent(
            event_type=PipelineEventType.STAGE_START,
            phase=AgentPhase.RENDER,
        )
    )

    # ëª¨ì˜ ì²˜ë¦¬ ì§€ì—° (ê¸°ì¡´ ë™ì‘ ë³´ì¡´)
    await asyncio.sleep(RENDER_DELAY_MS / 1000.0)

    # Stage ì™„ë£Œ ì´ë²¤íŠ¸
    await emit(
        PipelineEvent(
            event_type=PipelineEventType.STAGE_COMPLETE,
            phase=AgentPhase.RENDER,
        )
    )

    return ctx
</file>

<file path="backend/src/unknown_world/orchestrator/stages/resolve.py">
"""Unknown World - Resolve Stage.

í•´ê²° ë‹¨ê³„ì…ë‹ˆë‹¤.
í˜„ì¬ MVPì—ì„œëŠ” ì‹¤ì œ ì²˜ë¦¬ ì—†ì´ pass-throughë¡œ ë™ì‘í•©ë‹ˆë‹¤.

ì„¤ê³„ ì›ì¹™:
    - RULE-008: ë‹¨ê³„ ì´ë²¤íŠ¸ ì¼ê´€ì„±
    - ë™ì‘ ë³´ì¡´: ê¸°ì¡´ ì‹œë®¬ë ˆì´ì…˜ ì§€ì—° ìœ ì§€

ì°¸ì¡°:
    - vibe/refactors/RU-005-Q4.md
"""

from __future__ import annotations

import asyncio

from unknown_world.models.turn import AgentPhase
from unknown_world.orchestrator.stages.types import (
    EmitFn,
    PipelineContext,
    PipelineEvent,
    PipelineEventType,
)

# ëª¨ì˜ ì²˜ë¦¬ ì§€ì—° ì‹œê°„ (ms)
RESOLVE_DELAY_MS = 150


async def resolve_stage(ctx: PipelineContext, *, emit: EmitFn) -> PipelineContext:
    """Resolve ë‹¨ê³„ë¥¼ ì‹¤í–‰í•©ë‹ˆë‹¤.

    í˜„ì¬ëŠ” pass-throughë¡œ ë™ì‘í•©ë‹ˆë‹¤.

    Args:
        ctx: íŒŒì´í”„ë¼ì¸ ì»¨í…ìŠ¤íŠ¸
        emit: ì´ë²¤íŠ¸ emit ì½œë°±

    Returns:
        ì—…ë°ì´íŠ¸ëœ ì»¨í…ìŠ¤íŠ¸
    """
    ctx.current_phase = AgentPhase.RESOLVE

    # Stage ì‹œì‘ ì´ë²¤íŠ¸
    await emit(
        PipelineEvent(
            event_type=PipelineEventType.STAGE_START,
            phase=AgentPhase.RESOLVE,
        )
    )

    # ëª¨ì˜ ì²˜ë¦¬ ì§€ì—° (ê¸°ì¡´ ë™ì‘ ë³´ì¡´)
    await asyncio.sleep(RESOLVE_DELAY_MS / 1000.0)

    # Stage ì™„ë£Œ ì´ë²¤íŠ¸
    await emit(
        PipelineEvent(
            event_type=PipelineEventType.STAGE_COMPLETE,
            phase=AgentPhase.RESOLVE,
        )
    )

    return ctx
</file>

<file path="backend/src/unknown_world/orchestrator/stages/types.py">
"""Unknown World - Pipeline Stage íƒ€ì… ì •ì˜.

Pipelineì—ì„œ ì‚¬ìš©í•˜ëŠ” ì»¨í…ìŠ¤íŠ¸ì™€ emit ì½œë°± ì¸í„°í˜ì´ìŠ¤ë¥¼ ì •ì˜í•©ë‹ˆë‹¤.

ì„¤ê³„ ì›ì¹™:
    - Option A (RU-005 Q1 ê²°ì •): í´ë˜ìŠ¤ ë„ì… ì—†ì´ í•¨ìˆ˜ ì²´ì¸ ë°©ì‹
    - ë ˆì´ì–´ë§ ë³´í˜¸: ì˜¤ì¼€ìŠ¤íŠ¸ë ˆì´í„°ê°€ FastAPIì— ì§ì ‘ ì˜ì¡´í•˜ì§€ ì•Šë„ë¡ emit ì½œë°± ì‚¬ìš©
    - RULE-007/008: í”„ë¡¬í”„íŠ¸/ë‚´ë¶€ ì¶”ë¡  ë…¸ì¶œ ê¸ˆì§€, ë‹¨ê³„/ë°°ì§€ë§Œ í‘œì‹œ

ì°¸ì¡°:
    - vibe/refactors/RU-005-Q4.md
    - vibe/unit-results/U-018[Mvp].md
"""

from __future__ import annotations

from collections.abc import Awaitable, Callable
from dataclasses import dataclass, field
from enum import Enum
from typing import TYPE_CHECKING, Any, Protocol

from unknown_world.models.turn import (
    AgentPhase,
    CurrencyAmount,
    TurnInput,
    TurnOutput,
    ValidationBadge,
)

if TYPE_CHECKING:
    pass

# =============================================================================
# Emit ì½œë°± íƒ€ì… (ì˜¤ì¼€ìŠ¤íŠ¸ë ˆì´í„° â†’ API ë ˆì´ì–´)
# =============================================================================


class PipelineEventType(str, Enum):
    """íŒŒì´í”„ë¼ì¸ ì´ë²¤íŠ¸ íƒ€ì….

    ì˜¤ì¼€ìŠ¤íŠ¸ë ˆì´í„°ê°€ API ë ˆì´ì–´ë¡œ ì „ë‹¬í•˜ëŠ” ë„ë©”ì¸ ì´ë²¤íŠ¸ íƒ€ì…ì…ë‹ˆë‹¤.
    API ë ˆì´ì–´ëŠ” ì´ë¥¼ StageEvent/BadgesEvent/RepairEvent ë“±ìœ¼ë¡œ ë³€í™˜í•©ë‹ˆë‹¤.
    """

    STAGE_START = "stage_start"
    STAGE_COMPLETE = "stage_complete"
    STAGE_FAIL = "stage_fail"
    BADGES = "badges"
    REPAIR = "repair"
    NARRATIVE_DELTA = "narrative_delta"


@dataclass
class PipelineEvent:
    """íŒŒì´í”„ë¼ì¸ ì´ë²¤íŠ¸.

    ì˜¤ì¼€ìŠ¤íŠ¸ë ˆì´í„°ê°€ emit ì½œë°±ìœ¼ë¡œ ì „ë‹¬í•˜ëŠ” ë„ë©”ì¸ ì´ë²¤íŠ¸ì…ë‹ˆë‹¤.
    API ë ˆì´ì–´ì—ì„œ ìŠ¤íŠ¸ë¦¼ ì´ë²¤íŠ¸ë¡œ ë³€í™˜ë©ë‹ˆë‹¤.

    Attributes:
        event_type: ì´ë²¤íŠ¸ íƒ€ì…
        phase: ê´€ë ¨ ë‹¨ê³„ (stage ì´ë²¤íŠ¸ìš©)
        badges: ë°°ì§€ ëª©ë¡ (badges ì´ë²¤íŠ¸ìš©)
        repair_attempt: ë³µêµ¬ ì‹œë„ íšŸìˆ˜ (repair ì´ë²¤íŠ¸ìš©)
        repair_message: ë³µêµ¬ ë©”ì‹œì§€ (repair ì´ë²¤íŠ¸ìš©)
        text: í…ìŠ¤íŠ¸ (narrative_delta ì´ë²¤íŠ¸ìš©)
        extra: ì¶”ê°€ ë°ì´í„°
    """

    event_type: PipelineEventType
    phase: AgentPhase | None = None
    badges: list[ValidationBadge] | None = None
    repair_attempt: int = 0
    repair_message: str | None = None
    text: str | None = None
    extra: dict[str, Any] = field(default_factory=lambda: {})


# Emit í•¨ìˆ˜ íƒ€ì…: async callableë¡œ ë„ë©”ì¸ ì´ë²¤íŠ¸ë¥¼ ì „ë‹¬
EmitFn = Callable[[PipelineEvent], Awaitable[None]]


# =============================================================================
# Pipeline Context
# =============================================================================


@dataclass
class PipelineContext:
    """íŒŒì´í”„ë¼ì¸ ì»¨í…ìŠ¤íŠ¸.

    Stage í•¨ìˆ˜ë“¤ì´ ê³µìœ í•˜ëŠ” ì»¨í…ìŠ¤íŠ¸ì…ë‹ˆë‹¤.
    ê° stageëŠ” ctxë¥¼ ë°›ì•„ ìˆ˜ì •í•˜ê³  ë°˜í™˜í•©ë‹ˆë‹¤ (Option A: í•¨ìˆ˜ ì²´ì¸).

    Attributes:
        turn_input: ì‚¬ìš©ì í„´ ì…ë ¥
        economy_snapshot: ìš”ì²­ ì‹œì  ì¬í™” ìŠ¤ëƒ…ìƒ· (í´ë°± ì‹œ ë³´ì¡´ìš©)
        output: ìƒì„±ëœ TurnOutput (validate stage ì´í›„)
        badges: í˜„ì¬ê¹Œì§€ ìˆ˜ì§‘ëœ ë°°ì§€ ëª©ë¡
        repair_messages: ë³µêµ¬ ì‹œë„ ì‹œ ë°œìƒí•œ ë©”ì‹œì§€ ëª©ë¡
        repair_attempts: ë³µêµ¬ ì‹œë„ íšŸìˆ˜
        current_phase: í˜„ì¬ ë‹¨ê³„
        is_fallback: í´ë°±ìœ¼ë¡œ ì¢…ë£Œë˜ì—ˆëŠ”ì§€
        is_mock: Mock ëª¨ë“œì¸ì§€
        seed: Mock ëª¨ë“œ ì‹œë“œ (ì¬í˜„ì„± ë³´ì¥)
    """

    turn_input: TurnInput
    economy_snapshot: CurrencyAmount
    output: TurnOutput | None = None
    badges: list[ValidationBadge] = field(default_factory=lambda: [])
    repair_messages: list[str] = field(default_factory=lambda: [])
    repair_attempts: int = 0
    current_phase: AgentPhase = AgentPhase.PARSE
    is_fallback: bool = False
    is_mock: bool = False
    seed: int | None = None


# =============================================================================
# Stage í•¨ìˆ˜ íƒ€ì…
# =============================================================================


class StageFn(Protocol):
    """Stage í•¨ìˆ˜ í”„ë¡œí† ì½œ.

    ê° stage í•¨ìˆ˜ëŠ” ì´ í”„ë¡œí† ì½œì„ ë”°ë¦…ë‹ˆë‹¤.
    ctxë¥¼ ë°›ì•„ ìˆ˜ì •í•˜ê³  ë°˜í™˜í•˜ë©°, emit ì½œë°±ìœ¼ë¡œ ì´ë²¤íŠ¸ë¥¼ ì „ë‹¬í•©ë‹ˆë‹¤.
    """

    async def __call__(self, ctx: PipelineContext, *, emit: EmitFn) -> PipelineContext: ...
</file>

<file path="backend/src/unknown_world/orchestrator/stages/verify.py">
"""Unknown World - Verify Stage.

ê²€ì¦ ë‹¨ê³„ì…ë‹ˆë‹¤.
í˜„ì¬ MVPì—ì„œëŠ” ì‹¤ì œ ì²˜ë¦¬ ì—†ì´ pass-throughë¡œ ë™ì‘í•©ë‹ˆë‹¤.

ì„¤ê³„ ì›ì¹™:
    - RULE-008: ë‹¨ê³„ ì´ë²¤íŠ¸ ì¼ê´€ì„±
    - ë™ì‘ ë³´ì¡´: ê¸°ì¡´ ì‹œë®¬ë ˆì´ì…˜ ì§€ì—° ìœ ì§€

ì°¸ì¡°:
    - vibe/refactors/RU-005-Q4.md
"""

from __future__ import annotations

import asyncio

from unknown_world.models.turn import AgentPhase
from unknown_world.orchestrator.stages.types import (
    EmitFn,
    PipelineContext,
    PipelineEvent,
    PipelineEventType,
)

# ëª¨ì˜ ì²˜ë¦¬ ì§€ì—° ì‹œê°„ (ms)
VERIFY_DELAY_MS = 40


async def verify_stage(ctx: PipelineContext, *, emit: EmitFn) -> PipelineContext:
    """Verify ë‹¨ê³„ë¥¼ ì‹¤í–‰í•©ë‹ˆë‹¤.

    í˜„ì¬ëŠ” pass-throughë¡œ ë™ì‘í•©ë‹ˆë‹¤.

    Args:
        ctx: íŒŒì´í”„ë¼ì¸ ì»¨í…ìŠ¤íŠ¸
        emit: ì´ë²¤íŠ¸ emit ì½œë°±

    Returns:
        ì—…ë°ì´íŠ¸ëœ ì»¨í…ìŠ¤íŠ¸
    """
    ctx.current_phase = AgentPhase.VERIFY

    # Stage ì‹œì‘ ì´ë²¤íŠ¸
    await emit(
        PipelineEvent(
            event_type=PipelineEventType.STAGE_START,
            phase=AgentPhase.VERIFY,
        )
    )

    # ëª¨ì˜ ì²˜ë¦¬ ì§€ì—° (ê¸°ì¡´ ë™ì‘ ë³´ì¡´)
    await asyncio.sleep(VERIFY_DELAY_MS / 1000.0)

    # Stage ì™„ë£Œ ì´ë²¤íŠ¸
    await emit(
        PipelineEvent(
            event_type=PipelineEventType.STAGE_COMPLETE,
            phase=AgentPhase.VERIFY,
        )
    )

    return ctx
</file>

<file path="backend/src/unknown_world/services/rembg_preflight.py">
"""Unknown World - rembg ì‚¬ì „ ì ê²€ ì„œë¹„ìŠ¤ (preflight).

ì´ ëª¨ë“ˆì€ ì„œë²„ ì‹œì‘ ì‹œ rembg ì„¤ì¹˜ ì—¬ë¶€ì™€ ëª¨ë¸ ìºì‹œë¥¼ ì‚¬ì „ ì ê²€í•˜ê³ ,
í•„ìš”í•œ ê²½ìš° ëª¨ë¸ì„ ë¯¸ë¦¬ ë‹¤ìš´ë¡œë“œí•˜ì—¬ ì²« rembg í˜¸ì¶œì—ì„œ ë°œìƒí•˜ëŠ” ì§€ì—°ì„ ë°©ì§€í•©ë‹ˆë‹¤.

ì„¤ê³„ ì›ì¹™:
    - RULE-004: ì‹¤íŒ¨í•´ë„ ì„œë¹„ìŠ¤ ì¤‘ë‹¨ ì—†ì´ degraded ëª¨ë“œë¡œ ìš´ì˜
    - Q1 ê²°ì •: Option A (íƒ€ì„ì•„ì›ƒ ì§§ê²Œ + ì‹¤íŒ¨ ì‹œ degraded)
    - Q2 ê²°ì •: Option A (birefnet-generalë§Œ ê¸°ë³¸ prefetch)

ì°¸ì¡°:
    - vibe/ref/rembg-guide.md (ëª¨ë¸ ì„ íƒ/ë‹¤ìš´ë¡œë“œ ê°€ì´ë“œ SSOT)
    - vibe/unit-plans/U-045[Mvp].md
    - vibe/tech-stack.md (rembg ë²„ì „ ê³ ì •)
"""

from __future__ import annotations

import asyncio
import logging
import os
import subprocess
from dataclasses import dataclass, field
from datetime import UTC, datetime
from enum import StrEnum
from pathlib import Path

from pydantic import BaseModel, ConfigDict, Field

# =============================================================================
# ë¡œê±° ì„¤ì •
# =============================================================================

logger = logging.getLogger(__name__)


# =============================================================================
# ìƒìˆ˜ ë° í™˜ê²½ë³€ìˆ˜
# =============================================================================

# ê¸°ë³¸ prefetch ëª¨ë¸ (Q2: Option A - birefnet-generalë§Œ)
DEFAULT_PREFETCH_MODELS: list[str] = ["birefnet-general"]

# í™˜ê²½ë³€ìˆ˜ë¡œ í™•ì¥ ëª¨ë¸ ëª©ë¡ ì£¼ì… ê°€ëŠ¥
# ì˜ˆ: UW_REMBG_PREFETCH_MODELS=birefnet-general,birefnet-portrait
ENV_PREFETCH_MODELS = "UW_REMBG_PREFETCH_MODELS"

# preflight íƒ€ì„ì•„ì›ƒ (Q1: Option A - ì§§ì€ íƒ€ì„ì•„ì›ƒ)
# ëª¨ë¸ ë‹¤ìš´ë¡œë“œëŠ” 100~200MBë¡œ ë„¤íŠ¸ì›Œí¬ì— ë”°ë¼ ì‹œê°„ì´ ê±¸ë¦´ ìˆ˜ ìˆìŒ
DEFAULT_PREFLIGHT_TIMEOUT_SECONDS = 120  # 2ë¶„
ENV_PREFLIGHT_TIMEOUT = "UW_REMBG_PREFLIGHT_TIMEOUT"

# ê°œë³„ ëª¨ë¸ ë‹¤ìš´ë¡œë“œ íƒ€ì„ì•„ì›ƒ
DEFAULT_MODEL_DOWNLOAD_TIMEOUT_SECONDS = 90  # 1.5ë¶„
ENV_MODEL_DOWNLOAD_TIMEOUT = "UW_REMBG_MODEL_DOWNLOAD_TIMEOUT"


# =============================================================================
# ìƒíƒœ íƒ€ì… ì •ì˜
# =============================================================================


class RembgReadyStatus(StrEnum):
    """rembg ì¤€ë¹„ ìƒíƒœ."""

    READY = "ready"
    """rembg ì„¤ì¹˜ë¨, í•„ìˆ˜ ëª¨ë¸ ì‚¬ìš© ê°€ëŠ¥"""

    DEGRADED = "degraded"
    """rembg ì„¤ì¹˜ë¨, ì¼ë¶€ ëª¨ë¸ ëˆ„ë½/ë‹¤ìš´ë¡œë“œ ì‹¤íŒ¨"""

    UNAVAILABLE = "unavailable"
    """rembg ë¯¸ì„¤ì¹˜ ë˜ëŠ” ì‚¬ìš© ë¶ˆê°€"""

    PENDING = "pending"
    """preflight ì•„ì§ ì‹¤í–‰ë˜ì§€ ì•ŠìŒ"""


@dataclass
class ModelStatus:
    """ê°œë³„ ëª¨ë¸ ìƒíƒœ.

    Attributes:
        name: ëª¨ë¸ ì´ë¦„
        available: ì‚¬ìš© ê°€ëŠ¥ ì—¬ë¶€
        download_attempted: ë‹¤ìš´ë¡œë“œ ì‹œë„ ì—¬ë¶€
        error: ì—ëŸ¬ ë©”ì‹œì§€ (ìˆì„ ê²½ìš°)
    """

    name: str
    available: bool = False
    download_attempted: bool = False
    error: str | None = None


class RembgPreflightResult(BaseModel):
    """rembg preflight ê²°ê³¼.

    Attributes:
        status: ì „ì²´ ì¤€ë¹„ ìƒíƒœ
        installed: rembg ì„¤ì¹˜ ì—¬ë¶€
        version: rembg ë²„ì „ (ì„¤ì¹˜ëœ ê²½ìš°)
        preloaded_models: ì‚¬ìš© ê°€ëŠ¥í•œ ëª¨ë¸ ëª©ë¡
        missing_models: ëˆ„ë½ëœ ëª¨ë¸ ëª©ë¡
        last_error: ë§ˆì§€ë§‰ ì—ëŸ¬ ë©”ì‹œì§€
        preflight_time_ms: preflight ì†Œìš” ì‹œê°„ (ë°€ë¦¬ì´ˆ)
        timestamp: preflight ì‹¤í–‰ ì‹œê°
    """

    model_config = ConfigDict(extra="forbid")

    status: RembgReadyStatus = Field(default=RembgReadyStatus.PENDING)
    installed: bool = Field(default=False)
    version: str | None = Field(default=None)
    preloaded_models: list[str] = Field(default_factory=list)
    missing_models: list[str] = Field(default_factory=list)
    last_error: str | None = Field(default=None)
    preflight_time_ms: int = Field(default=0)
    timestamp: str | None = Field(default=None)


@dataclass
class PreflightConfig:
    """preflight ì„¤ì •.

    Attributes:
        models_to_prefetch: prefetchí•  ëª¨ë¸ ëª©ë¡
        preflight_timeout_seconds: ì „ì²´ preflight íƒ€ì„ì•„ì›ƒ
        model_download_timeout_seconds: ê°œë³„ ëª¨ë¸ ë‹¤ìš´ë¡œë“œ íƒ€ì„ì•„ì›ƒ
    """

    models_to_prefetch: list[str] = field(default_factory=lambda: DEFAULT_PREFETCH_MODELS.copy())
    preflight_timeout_seconds: int = DEFAULT_PREFLIGHT_TIMEOUT_SECONDS
    model_download_timeout_seconds: int = DEFAULT_MODEL_DOWNLOAD_TIMEOUT_SECONDS

    @classmethod
    def from_env(cls) -> PreflightConfig:
        """í™˜ê²½ë³€ìˆ˜ì—ì„œ ì„¤ì •ì„ ë¡œë“œí•©ë‹ˆë‹¤."""
        # ëª¨ë¸ ëª©ë¡
        models_env = os.environ.get(ENV_PREFETCH_MODELS)
        if models_env:
            models = [m.strip() for m in models_env.split(",") if m.strip()]
        else:
            models = DEFAULT_PREFETCH_MODELS.copy()

        # íƒ€ì„ì•„ì›ƒ
        try:
            preflight_timeout = int(
                os.environ.get(ENV_PREFLIGHT_TIMEOUT, DEFAULT_PREFLIGHT_TIMEOUT_SECONDS)
            )
        except ValueError:
            preflight_timeout = DEFAULT_PREFLIGHT_TIMEOUT_SECONDS

        try:
            download_timeout = int(
                os.environ.get(ENV_MODEL_DOWNLOAD_TIMEOUT, DEFAULT_MODEL_DOWNLOAD_TIMEOUT_SECONDS)
            )
        except ValueError:
            download_timeout = DEFAULT_MODEL_DOWNLOAD_TIMEOUT_SECONDS

        return cls(
            models_to_prefetch=models,
            preflight_timeout_seconds=preflight_timeout,
            model_download_timeout_seconds=download_timeout,
        )


# =============================================================================
# Preflight ì„œë¹„ìŠ¤ í´ë˜ìŠ¤
# =============================================================================


class RembgPreflight:
    """rembg ì‚¬ì „ ì ê²€ ì„œë¹„ìŠ¤.

    ì„œë²„ ì‹œì‘ ì‹œ rembg ì„¤ì¹˜ ì—¬ë¶€ì™€ ëª¨ë¸ ìºì‹œë¥¼ ì ê²€í•˜ê³ ,
    í•„ìš”í•œ ê²½ìš° ëª¨ë¸ì„ ë¯¸ë¦¬ ë‹¤ìš´ë¡œë“œí•©ë‹ˆë‹¤.
    """

    def __init__(self, config: PreflightConfig | None = None) -> None:
        """RembgPreflightë¥¼ ì´ˆê¸°í™”í•©ë‹ˆë‹¤.

        Args:
            config: preflight ì„¤ì • (Noneì´ë©´ í™˜ê²½ë³€ìˆ˜ì—ì„œ ë¡œë“œ)
        """
        self._config = config or PreflightConfig.from_env()
        self._result: RembgPreflightResult = RembgPreflightResult()
        self._model_statuses: dict[str, ModelStatus] = {}
        self._executed = False

    @property
    def result(self) -> RembgPreflightResult:
        """í˜„ì¬ preflight ê²°ê³¼ë¥¼ ë°˜í™˜í•©ë‹ˆë‹¤."""
        return self._result

    def set_result(self, result: RembgPreflightResult) -> None:
        """preflight ê²°ê³¼ë¥¼ ì„¤ì •í•©ë‹ˆë‹¤ (í…ŒìŠ¤íŠ¸ìš©)."""
        self._result = result

    @property
    def is_ready(self) -> bool:
        """rembgê°€ ì‚¬ìš© ì¤€ë¹„ë˜ì—ˆëŠ”ì§€ í™•ì¸í•©ë‹ˆë‹¤."""
        return self._result.status == RembgReadyStatus.READY

    @property
    def is_available(self) -> bool:
        """rembgê°€ ì‚¬ìš© ê°€ëŠ¥í•œì§€ í™•ì¸í•©ë‹ˆë‹¤ (degraded í¬í•¨)."""
        return self._result.status in (RembgReadyStatus.READY, RembgReadyStatus.DEGRADED)

    def _check_rembg_installed(self) -> tuple[bool, str | None]:
        """rembg ì„¤ì¹˜ ì—¬ë¶€ë¥¼ í™•ì¸í•©ë‹ˆë‹¤.

        Returns:
            (ì„¤ì¹˜ ì—¬ë¶€, ë²„ì „ ë˜ëŠ” None)
        """
        try:
            result = subprocess.run(
                ["rembg", "--version"],
                capture_output=True,
                text=True,
                timeout=10,
            )
            if result.returncode == 0:
                version = result.stdout.strip()
                logger.info("[Preflight] rembg ì„¤ì¹˜ í™•ì¸", extra={"version": version})
                return True, version
            else:
                logger.warning(
                    "[Preflight] rembg ë²„ì „ í™•ì¸ ì‹¤íŒ¨", extra={"returncode": result.returncode}
                )
                return False, None
        except FileNotFoundError:
            logger.warning("[Preflight] rembgê°€ ì„¤ì¹˜ë˜ì–´ ìˆì§€ ì•ŠìŠµë‹ˆë‹¤")
            return False, None
        except subprocess.TimeoutExpired:
            logger.warning("[Preflight] rembg ë²„ì „ í™•ì¸ íƒ€ì„ì•„ì›ƒ")
            return False, None
        except Exception as e:
            logger.warning("[Preflight] rembg í™•ì¸ ì¤‘ ì˜¤ë¥˜", extra={"error": str(e)[:100]})
            return False, None

    def _check_model_available(self, model: str) -> bool:
        """íŠ¹ì • ëª¨ë¸ì´ ìºì‹œì— ìˆëŠ”ì§€ í™•ì¸í•©ë‹ˆë‹¤.

        rembgëŠ” ëª¨ë¸ì„ ì²˜ìŒ ì‚¬ìš©í•  ë•Œ ìë™ìœ¼ë¡œ ë‹¤ìš´ë¡œë“œí•©ë‹ˆë‹¤.
        ëª¨ë¸ ìºì‹œ ìœ„ì¹˜: ~/.u2net/ (ê¸°ë³¸)

        Args:
            model: í™•ì¸í•  ëª¨ë¸ ì´ë¦„

        Returns:
            ëª¨ë¸ ì‚¬ìš© ê°€ëŠ¥ ì—¬ë¶€
        """
        # rembg ëª¨ë¸ ìºì‹œ ë””ë ‰í† ë¦¬ í™•ì¸
        # ê¸°ë³¸ ê²½ë¡œ: ~/.u2net/{model}.onnx
        home = Path.home()
        u2net_dir = home / ".u2net"

        # ëª¨ë¸ íŒŒì¼ íŒ¨í„´ (ëª¨ë¸ë§ˆë‹¤ íŒŒì¼ëª…ì´ ë‹¤ë¥¼ ìˆ˜ ìˆìŒ)
        # birefnet-general â†’ birefnet-general.onnx
        model_file = u2net_dir / f"{model}.onnx"

        if model_file.exists():
            logger.debug(
                "[Preflight] ëª¨ë¸ ìºì‹œ ë°œê²¬", extra={"model": model, "path": str(model_file)}
            )
            return True

        logger.debug("[Preflight] ëª¨ë¸ ìºì‹œ ì—†ìŒ", extra={"model": model})
        return False

    def _download_model(self, model: str) -> bool:
        """ëª¨ë¸ì„ ë‹¤ìš´ë¡œë“œí•©ë‹ˆë‹¤.

        Args:
            model: ë‹¤ìš´ë¡œë“œí•  ëª¨ë¸ ì´ë¦„

        Returns:
            ë‹¤ìš´ë¡œë“œ ì„±ê³µ ì—¬ë¶€
        """
        timeout = self._config.model_download_timeout_seconds

        logger.info("[Preflight] ëª¨ë¸ ë‹¤ìš´ë¡œë“œ ì‹œì‘", extra={"model": model, "timeout": timeout})

        try:
            # rembg d <model> ëª…ë ¹ìœ¼ë¡œ ë‹¤ìš´ë¡œë“œ
            result = subprocess.run(
                ["rembg", "d", model],
                capture_output=True,
                text=True,
                timeout=timeout,
            )

            if result.returncode == 0:
                logger.info("[Preflight] ëª¨ë¸ ë‹¤ìš´ë¡œë“œ ì™„ë£Œ", extra={"model": model})
                return True
            else:
                stderr_preview = result.stderr[:200] if result.stderr else "N/A"
                logger.warning(
                    "[Preflight] ëª¨ë¸ ë‹¤ìš´ë¡œë“œ ì‹¤íŒ¨",
                    extra={
                        "model": model,
                        "returncode": result.returncode,
                        "stderr": stderr_preview,
                    },
                )
                return False

        except subprocess.TimeoutExpired:
            logger.warning(
                "[Preflight] ëª¨ë¸ ë‹¤ìš´ë¡œë“œ íƒ€ì„ì•„ì›ƒ", extra={"model": model, "timeout": timeout}
            )
            return False
        except Exception as e:
            logger.warning(
                "[Preflight] ëª¨ë¸ ë‹¤ìš´ë¡œë“œ ì¤‘ ì˜¤ë¥˜", extra={"model": model, "error": str(e)[:100]}
            )
            return False

    def _process_model(self, model: str) -> ModelStatus:
        """ëª¨ë¸ ìƒíƒœë¥¼ í™•ì¸í•˜ê³  í•„ìš”ì‹œ ë‹¤ìš´ë¡œë“œí•©ë‹ˆë‹¤.

        Args:
            model: ì²˜ë¦¬í•  ëª¨ë¸ ì´ë¦„

        Returns:
            ModelStatus ê°ì²´
        """
        status = ModelStatus(name=model)

        # 1. ìºì‹œ í™•ì¸
        if self._check_model_available(model):
            status.available = True
            return status

        # 2. ìºì‹œ ì—†ìœ¼ë©´ ë‹¤ìš´ë¡œë“œ ì‹œë„
        status.download_attempted = True
        if self._download_model(model):
            # ë‹¤ìš´ë¡œë“œ í›„ ì¬í™•ì¸
            if self._check_model_available(model):
                status.available = True
            else:
                status.error = "ë‹¤ìš´ë¡œë“œ ì™„ë£Œí–ˆìœ¼ë‚˜ ëª¨ë¸ íŒŒì¼ì„ ì°¾ì„ ìˆ˜ ì—†ìŒ"
        else:
            status.error = "ë‹¤ìš´ë¡œë“œ ì‹¤íŒ¨"

        return status

    async def run_async(self) -> RembgPreflightResult:
        """ë¹„ë™ê¸°ë¡œ preflightë¥¼ ì‹¤í–‰í•©ë‹ˆë‹¤.

        Returns:
            RembgPreflightResult ê°ì²´
        """
        # ë™ê¸° ì‘ì—…ì„ ë³„ë„ ìŠ¤ë ˆë“œì—ì„œ ì‹¤í–‰
        loop = asyncio.get_event_loop()
        return await loop.run_in_executor(None, self.run)

    def run(self) -> RembgPreflightResult:
        """preflightë¥¼ ì‹¤í–‰í•©ë‹ˆë‹¤.

        Returns:
            RembgPreflightResult ê°ì²´
        """
        start_time = datetime.now(UTC)
        self._executed = True

        logger.info(
            "[Preflight] rembg preflight ì‹œì‘",
            extra={
                "models": self._config.models_to_prefetch,
                "timeout": self._config.preflight_timeout_seconds,
            },
        )

        # 1. rembg ì„¤ì¹˜ í™•ì¸
        installed, version = self._check_rembg_installed()
        self._result.installed = installed
        self._result.version = version

        if not installed:
            self._result.status = RembgReadyStatus.UNAVAILABLE
            self._result.last_error = "rembgê°€ ì„¤ì¹˜ë˜ì–´ ìˆì§€ ì•ŠìŠµë‹ˆë‹¤"
            self._result.timestamp = datetime.now(UTC).isoformat()
            self._result.preflight_time_ms = int(
                (datetime.now(UTC) - start_time).total_seconds() * 1000
            )

            logger.warning("[Preflight] rembg ë¯¸ì„¤ì¹˜, UNAVAILABLE ìƒíƒœë¡œ ì™„ë£Œ")
            return self._result

        # 2. ê° ëª¨ë¸ ì ê²€ ë° ë‹¤ìš´ë¡œë“œ
        preloaded: list[str] = []
        missing: list[str] = []

        for model in self._config.models_to_prefetch:
            # ì „ì²´ íƒ€ì„ì•„ì›ƒ ì²´í¬
            elapsed = (datetime.now(UTC) - start_time).total_seconds()
            if elapsed > self._config.preflight_timeout_seconds:
                logger.warning("[Preflight] ì „ì²´ íƒ€ì„ì•„ì›ƒ ë„ë‹¬, ë‚¨ì€ ëª¨ë¸ ìŠ¤í‚µ")
                # ë‚¨ì€ ëª¨ë¸ì€ missingìœ¼ë¡œ ì²˜ë¦¬
                remaining_models = self._config.models_to_prefetch[
                    self._config.models_to_prefetch.index(model) :
                ]
                for remaining in remaining_models:
                    if remaining not in [s.name for s in self._model_statuses.values()]:
                        status = ModelStatus(name=remaining, error="preflight íƒ€ì„ì•„ì›ƒìœ¼ë¡œ ìŠ¤í‚µë¨")
                        self._model_statuses[remaining] = status
                        missing.append(remaining)
                break

            status = self._process_model(model)
            self._model_statuses[model] = status

            if status.available:
                preloaded.append(model)
            else:
                missing.append(model)

        # 3. ê²°ê³¼ ì •ë¦¬
        self._result.preloaded_models = preloaded
        self._result.missing_models = missing
        self._result.preflight_time_ms = int(
            (datetime.now(UTC) - start_time).total_seconds() * 1000
        )
        self._result.timestamp = datetime.now(UTC).isoformat()

        # ìƒíƒœ ê²°ì •
        if not missing:
            self._result.status = RembgReadyStatus.READY
            logger.info(
                "[Preflight] rembg READY",
                extra={"preloaded": preloaded, "elapsed_ms": self._result.preflight_time_ms},
            )
        elif preloaded:
            self._result.status = RembgReadyStatus.DEGRADED
            self._result.last_error = f"ì¼ë¶€ ëª¨ë¸ ëˆ„ë½: {', '.join(missing)}"
            logger.warning(
                "[Preflight] rembg DEGRADED",
                extra={
                    "preloaded": preloaded,
                    "missing": missing,
                    "elapsed_ms": self._result.preflight_time_ms,
                },
            )
        else:
            self._result.status = RembgReadyStatus.DEGRADED
            self._result.last_error = f"ëª¨ë“  prefetch ëª¨ë¸ ëˆ„ë½: {', '.join(missing)}"
            logger.warning(
                "[Preflight] rembg DEGRADED (ëª¨ë“  ëª¨ë¸ ëˆ„ë½)",
                extra={"missing": missing, "elapsed_ms": self._result.preflight_time_ms},
            )

        return self._result


# =============================================================================
# ì „ì—­ ì¸ìŠ¤í„´ìŠ¤ ë° ì ‘ê·¼ì
# =============================================================================

_preflight_instance: RembgPreflight | None = None
_preflight_result: RembgPreflightResult = RembgPreflightResult()


def get_rembg_preflight() -> RembgPreflight:
    """RembgPreflight ì‹±ê¸€í†¤ ì¸ìŠ¤í„´ìŠ¤ë¥¼ ë°˜í™˜í•©ë‹ˆë‹¤."""
    global _preflight_instance
    if _preflight_instance is None:
        _preflight_instance = RembgPreflight()
    return _preflight_instance


def get_rembg_status() -> RembgPreflightResult:
    """í˜„ì¬ rembg preflight ê²°ê³¼ë¥¼ ë°˜í™˜í•©ë‹ˆë‹¤."""
    global _preflight_result
    if _preflight_instance is not None:
        return _preflight_instance.result
    return _preflight_result


def set_rembg_status(result: RembgPreflightResult) -> None:
    """rembg preflight ê²°ê³¼ë¥¼ ì„¤ì •í•©ë‹ˆë‹¤ (í…ŒìŠ¤íŠ¸ìš©)."""
    global _preflight_result, _preflight_instance
    _preflight_result = result
    # ì¸ìŠ¤í„´ìŠ¤ê°€ ìˆìœ¼ë©´ ê³µê°œ ë©”ì„œë“œë¡œ ê²°ê³¼ ì—…ë°ì´íŠ¸
    if _preflight_instance is not None:
        _preflight_instance.set_result(result)


def is_rembg_ready() -> bool:
    """rembgê°€ ì¤€ë¹„ë˜ì—ˆëŠ”ì§€ í™•ì¸í•©ë‹ˆë‹¤ (ë°”ë¡œ ì‚¬ìš© ê°€ëŠ¥)."""
    status = get_rembg_status()
    return status.status == RembgReadyStatus.READY


def is_rembg_available() -> bool:
    """rembgê°€ ì‚¬ìš© ê°€ëŠ¥í•œì§€ í™•ì¸í•©ë‹ˆë‹¤ (degraded í¬í•¨)."""
    status = get_rembg_status()
    return status.status in (RembgReadyStatus.READY, RembgReadyStatus.DEGRADED)


def reset_rembg_preflight() -> None:
    """í…ŒìŠ¤íŠ¸ìš© ì‹±ê¸€í†¤ ë¦¬ì…‹."""
    global _preflight_instance, _preflight_result
    _preflight_instance = None
    _preflight_result = RembgPreflightResult()


async def run_preflight_async(config: PreflightConfig | None = None) -> RembgPreflightResult:
    """ë¹„ë™ê¸°ë¡œ preflightë¥¼ ì‹¤í–‰í•˜ê³  ì „ì—­ ìƒíƒœë¥¼ ì—…ë°ì´íŠ¸í•©ë‹ˆë‹¤.

    Args:
        config: preflight ì„¤ì • (Noneì´ë©´ í™˜ê²½ë³€ìˆ˜ì—ì„œ ë¡œë“œ)

    Returns:
        RembgPreflightResult ê°ì²´
    """
    global _preflight_instance, _preflight_result

    _preflight_instance = RembgPreflight(config)
    result = await _preflight_instance.run_async()
    _preflight_result = result

    return result
</file>

<file path="backend/src/unknown_world/storage/paths.py">
"""Unknown World - ìŠ¤í† ë¦¬ì§€ ê²½ë¡œ ìƒìˆ˜.

ëª¨ë“  ì €ì¥ ê²½ë¡œ ë° URL ê´€ë ¨ ìƒìˆ˜ë¥¼ ì¤‘ì•™ ê´€ë¦¬í•©ë‹ˆë‹¤.
MVP: ë¡œì»¬ íŒŒì¼ ì‹œìŠ¤í…œ ê²½ë¡œ
MMP: GCS ë²„í‚· ê²½ë¡œë¡œ í™•ì¥ ì˜ˆì •

í˜ì–´ë§ ì§ˆë¬¸ Q1 ê²°ì •: Option A (backend/.data/ ì „ìš© í´ë”)

ì°¸ì¡°:
    - vibe/refactors/RU-006-Q5.md
"""

from __future__ import annotations

from pathlib import Path
from typing import Final

# =============================================================================
# ê¸°ë³¸ ë””ë ‰í† ë¦¬ (MVP: ë¡œì»¬)
# =============================================================================

# í˜ì–´ë§ ì§ˆë¬¸ Q1: Option A - backend/.data/ ì „ìš© í´ë”
# .gitignoreì— backend/.data/ ì¶”ê°€ í•„ìˆ˜
BASE_DATA_DIR: Final[Path] = Path(".data")
"""ëª¨ë“  ë°ì´í„° íŒŒì¼ì˜ ë£¨íŠ¸ ë””ë ‰í† ë¦¬."""

# í•˜ìœ„ í˜¸í™˜ì„±ì„ ìœ„í•œ ë ˆê±°ì‹œ ê²½ë¡œ (deprecated, ë§ˆì´ê·¸ë ˆì´ì…˜ìš©)
LEGACY_OUTPUT_DIR: Final[Path] = Path("generated_images")
"""[Deprecated] ê¸°ì¡´ ì´ë¯¸ì§€ ì €ì¥ ê²½ë¡œ. .data/ë¡œ ë§ˆì´ê·¸ë ˆì´ì…˜ ê¶Œì¥."""

# =============================================================================
# ì¹´í…Œê³ ë¦¬ë³„ ì„œë¸Œ ê²½ë¡œ
# =============================================================================

IMAGES_GENERATED_SUBDIR: Final[str] = "images/generated"
"""ìƒì„±ëœ ì´ë¯¸ì§€ ì €ì¥ ì„œë¸Œ ë””ë ‰í† ë¦¬."""

IMAGES_UPLOADED_SUBDIR: Final[str] = "images/uploaded"
"""ì—…ë¡œë“œëœ ì´ë¯¸ì§€ ì €ì¥ ì„œë¸Œ ë””ë ‰í† ë¦¬."""

ARTIFACTS_SUBDIR: Final[str] = "artifacts"
"""ê²Œì„ ì•„í‹°íŒ©íŠ¸ ì €ì¥ ì„œë¸Œ ë””ë ‰í† ë¦¬."""

# =============================================================================
# URL í”„ë¦¬í”½ìŠ¤
# =============================================================================

STATIC_URL_PREFIX: Final[str] = "/static"
"""ì •ì  íŒŒì¼ ì„œë¹™ URL í”„ë¦¬í”½ìŠ¤."""

# ì „ì²´ ê²½ë¡œ (ìì£¼ ì‚¬ìš©ë˜ëŠ” ì¡°í•©)
STATIC_IMAGES_URL_PREFIX: Final[str] = f"{STATIC_URL_PREFIX}/images"
"""ì´ë¯¸ì§€ íŒŒì¼ URL í”„ë¦¬í”½ìŠ¤ (ì˜ˆ: /static/images/generated/xxx.png)."""

# =============================================================================
# íŒŒì¼ í™•ì¥ì
# =============================================================================

DEFAULT_IMAGE_EXTENSION: Final[str] = "png"
"""ê¸°ë³¸ ì´ë¯¸ì§€ íŒŒì¼ í™•ì¥ì."""

# =============================================================================
# ê²½ë¡œ í—¬í¼ í•¨ìˆ˜
# =============================================================================


def get_generated_images_dir() -> Path:
    """ìƒì„±ëœ ì´ë¯¸ì§€ ì €ì¥ ë””ë ‰í† ë¦¬ ê²½ë¡œë¥¼ ë°˜í™˜í•©ë‹ˆë‹¤."""
    return BASE_DATA_DIR / IMAGES_GENERATED_SUBDIR


def get_uploaded_images_dir() -> Path:
    """ì—…ë¡œë“œëœ ì´ë¯¸ì§€ ì €ì¥ ë””ë ‰í† ë¦¬ ê²½ë¡œë¥¼ ë°˜í™˜í•©ë‹ˆë‹¤."""
    return BASE_DATA_DIR / IMAGES_UPLOADED_SUBDIR


def get_artifacts_dir() -> Path:
    """ì•„í‹°íŒ©íŠ¸ ì €ì¥ ë””ë ‰í† ë¦¬ ê²½ë¡œë¥¼ ë°˜í™˜í•©ë‹ˆë‹¤."""
    return BASE_DATA_DIR / ARTIFACTS_SUBDIR


def build_image_url(
    filename: str,
    *,
    category: str = "generated",
) -> str:
    """ì´ë¯¸ì§€ íŒŒì¼ì˜ ì„œë¹™ URLì„ ìƒì„±í•©ë‹ˆë‹¤.

    Args:
        filename: íŒŒì¼ëª… (í™•ì¥ì í¬í•¨)
        category: ì´ë¯¸ì§€ ì¹´í…Œê³ ë¦¬ ("generated" ë˜ëŠ” "uploaded")

    Returns:
        ì„œë¹™ URL (ì˜ˆ: /static/images/generated/img_abc123.png)
    """
    return f"{STATIC_URL_PREFIX}/images/{category}/{filename}"


def build_legacy_image_url(filename: str) -> str:
    """[Deprecated] ë ˆê±°ì‹œ ì´ë¯¸ì§€ URLì„ ìƒì„±í•©ë‹ˆë‹¤.

    ê¸°ì¡´ ì½”ë“œ í˜¸í™˜ì„±ì„ ìœ„í•´ ìœ ì§€. ì‹ ê·œ ì½”ë“œì—ì„œëŠ” build_image_url() ì‚¬ìš©.

    Args:
        filename: íŒŒì¼ëª… (í™•ì¥ì í¬í•¨)

    Returns:
        ë ˆê±°ì‹œ URL (ì˜ˆ: /static/images/img_abc123.png)
    """
    return f"/static/images/{filename}"
</file>

<file path="backend/src/unknown_world/storage/storage.py">
"""Unknown World - ìŠ¤í† ë¦¬ì§€ ì¶”ìƒí™” ì¸í„°í˜ì´ìŠ¤.

MVPì—ì„œëŠ” ë¡œì»¬ íŒŒì¼ ì‹œìŠ¤í…œ, MMPì—ì„œëŠ” GCSë¡œ í™•ì¥ ê°€ëŠ¥í•œ êµ¬ì¡°.

ì„¤ê³„ ì›ì¹™:
    - RULE-007: íŒŒì¼ ë‚´ìš©/ê²½ë¡œ ë¡œê¹… ì‹œ ë©”íƒ€ë§Œ ê¸°ë¡
    - RULE-010: DB ëŒ€ì‹  íŒŒì¼ ê¸°ë°˜ ì €ì¥ ìš°ì„ 

ì°¸ì¡°:
    - vibe/refactors/RU-006-Q4.md
"""

from __future__ import annotations

from abc import ABC, abstractmethod
from dataclasses import dataclass
from datetime import datetime
from enum import StrEnum


class StorageCategory(StrEnum):
    """ì €ì¥ ì¹´í…Œê³ ë¦¬."""

    GENERATED_IMAGE = "generated_image"
    """ìƒì„±ëœ ì´ë¯¸ì§€ (U-019)"""

    UPLOADED_IMAGE = "uploaded_image"
    """ì—…ë¡œë“œëœ ì´ë¯¸ì§€ (U-021, ì„ íƒì )"""

    ARTIFACT = "artifact"
    """ê²Œì„ ì•„í‹°íŒ©íŠ¸ (ì—”ë”© ë¦¬í¬íŠ¸, ë¦¬í”Œë ˆì´ ë“±)"""


@dataclass
class StorageMetadata:
    """ì €ì¥ëœ íŒŒì¼ ë©”íƒ€ë°ì´í„°."""

    key: str
    """ìŠ¤í† ë¦¬ì§€ ë‚´ ê³ ìœ  í‚¤"""

    category: StorageCategory
    """ì €ì¥ ì¹´í…Œê³ ë¦¬"""

    size_bytes: int
    """íŒŒì¼ í¬ê¸°"""

    content_type: str
    """MIME íƒ€ì…"""

    created_at: datetime
    """ìƒì„± ì‹œê°"""

    url: str
    """ì ‘ê·¼ URL"""

    session_id: str | None = None
    """ì„¸ì…˜ ID (ì„ íƒ)"""


@dataclass
class PutResult:
    """ì €ì¥ ê²°ê³¼."""

    success: bool
    key: str
    url: str
    metadata: StorageMetadata | None = None
    error: str | None = None


class StorageInterface(ABC):
    """ìŠ¤í† ë¦¬ì§€ ì¸í„°í˜ì´ìŠ¤ (ì¶”ìƒ í´ë˜ìŠ¤).

    MVP: LocalStorage êµ¬í˜„
    MMP: GCSStorage êµ¬í˜„ ì˜ˆì •
    """

    @abstractmethod
    async def put(
        self,
        data: bytes,
        *,
        category: StorageCategory,
        content_type: str = "image/png",
        file_id: str | None = None,
        session_id: str | None = None,
    ) -> PutResult:
        """íŒŒì¼ì„ ì €ì¥í•©ë‹ˆë‹¤.

        Args:
            data: íŒŒì¼ ë°”ì´íŠ¸ ë°ì´í„°
            category: ì €ì¥ ì¹´í…Œê³ ë¦¬
            content_type: MIME íƒ€ì…
            file_id: íŒŒì¼ ID (ì—†ìœ¼ë©´ ìë™ ìƒì„±)
            session_id: ì„¸ì…˜ ID (ê²½ë¡œ ë¶„ë¥˜ìš©)

        Returns:
            PutResult: ì €ì¥ ê²°ê³¼
        """
        ...

    @abstractmethod
    async def get(self, key: str) -> bytes | None:
        """íŒŒì¼ì„ ì¡°íšŒí•©ë‹ˆë‹¤.

        Args:
            key: ìŠ¤í† ë¦¬ì§€ í‚¤

        Returns:
            íŒŒì¼ ë°”ì´íŠ¸ ë°ì´í„° (ì—†ìœ¼ë©´ None)
        """
        ...

    @abstractmethod
    async def exists(self, key: str) -> bool:
        """íŒŒì¼ ì¡´ì¬ ì—¬ë¶€ë¥¼ í™•ì¸í•©ë‹ˆë‹¤.

        Args:
            key: ìŠ¤í† ë¦¬ì§€ í‚¤

        Returns:
            ì¡´ì¬ ì—¬ë¶€
        """
        ...

    @abstractmethod
    async def delete(self, key: str) -> bool:
        """íŒŒì¼ì„ ì‚­ì œí•©ë‹ˆë‹¤.

        Args:
            key: ìŠ¤í† ë¦¬ì§€ í‚¤

        Returns:
            ì‚­ì œ ì„±ê³µ ì—¬ë¶€
        """
        ...

    @abstractmethod
    def get_url(self, key: str) -> str:
        """íŒŒì¼ ì ‘ê·¼ URLì„ ë°˜í™˜í•©ë‹ˆë‹¤.

        Args:
            key: ìŠ¤í† ë¦¬ì§€ í‚¤

        Returns:
            ì ‘ê·¼ URL
        """
        ...
</file>

<file path="backend/src/unknown_world/storage/validation.py">
"""Unknown World - íŒŒì¼ ê²€ì¦ ë° ì œí•œ ì •ì±….

ëª¨ë“  ì´ë¯¸ì§€/ì•„í‹°íŒ©íŠ¸ ê´€ë ¨ ê²€ì¦ ë¡œì§ê³¼ ìƒìˆ˜ë¥¼ ì¤‘ì•™ ê´€ë¦¬í•©ë‹ˆë‹¤.

ì„¤ê³„ ì›ì¹™:
    - RULE-007: ì—ëŸ¬ ë©”ì‹œì§€ì— íŒŒì¼ ë‚´ìš© ë…¸ì¶œ ê¸ˆì§€
    - RULE-004: ê²€ì¦ ì‹¤íŒ¨ ì‹œ ëª…í™•í•œ ì—ëŸ¬ ë©”ì‹œì§€ ë°˜í™˜

ì°¸ì¡°:
    - vibe/refactors/RU-006-Q1.md
"""

from __future__ import annotations

from typing import Final

# =============================================================================
# ì´ë¯¸ì§€ ì—…ë¡œë“œ ì œí•œ (Scanner/Vision ê³µí†µ)
# =============================================================================

ALLOWED_IMAGE_MIME_TYPES: Final[frozenset[str]] = frozenset(
    {
        "image/jpeg",
        "image/jpg",
        "image/png",
        "image/gif",
        "image/webp",
    }
)
"""ì§€ì›í•˜ëŠ” ì´ë¯¸ì§€ MIME íƒ€ì…."""

MAX_IMAGE_FILE_SIZE_BYTES: Final[int] = 20 * 1024 * 1024  # 20MB
"""ìµœëŒ€ ì´ë¯¸ì§€ íŒŒì¼ í¬ê¸° (ë°”ì´íŠ¸)."""

MIN_IMAGE_FILE_SIZE_BYTES: Final[int] = 100
"""ìµœì†Œ ì´ë¯¸ì§€ íŒŒì¼ í¬ê¸° (ì†ìƒ íŒŒì¼ ê°ì§€ìš©)."""

# =============================================================================
# ì´ë¯¸ì§€ ìƒì„± ì œí•œ
# =============================================================================

SUPPORTED_IMAGE_SIZES: Final[dict[str, tuple[int, int]]] = {
    "1024x1024": (1024, 1024),
    "1280x768": (1280, 768),
    "768x1280": (768, 1280),
    "1536x1024": (1536, 1024),
    "1024x1536": (1024, 1536),
}
"""ì§€ì›í•˜ëŠ” ì´ë¯¸ì§€ ìƒì„± í¬ê¸°."""

DEFAULT_IMAGE_SIZE: Final[str] = "1024x1024"
"""ê¸°ë³¸ ì´ë¯¸ì§€ ìƒì„± í¬ê¸°."""

DEFAULT_ASPECT_RATIO: Final[str] = "1:1"
"""ê¸°ë³¸ ê°€ë¡œì„¸ë¡œ ë¹„ìœ¨."""

MIN_PROMPT_LENGTH: Final[int] = 3
"""ìµœì†Œ í”„ë¡¬í”„íŠ¸ ê¸¸ì´."""

MAX_PROMPT_LENGTH: Final[int] = 2000
"""ìµœëŒ€ í”„ë¡¬í”„íŠ¸ ê¸¸ì´."""

# =============================================================================
# bbox ì •ê·œí™” ë²”ìœ„ (RULE-009)
# =============================================================================

BBOX_MIN: Final[int] = 0
"""bbox ìµœì†Œê°’."""

BBOX_MAX: Final[int] = 1000
"""bbox ìµœëŒ€ê°’."""


# =============================================================================
# ê²€ì¦ í•¨ìˆ˜
# =============================================================================


def validate_image_upload(
    content: bytes,
    content_type: str,
    *,
    language: str = "ko-KR",
) -> str | None:
    """ì—…ë¡œë“œ ì´ë¯¸ì§€ë¥¼ ê²€ì¦í•©ë‹ˆë‹¤.

    Args:
        content: ì´ë¯¸ì§€ ë°”ì´íŠ¸ ë°ì´í„°
        content_type: MIME íƒ€ì…
        language: ì—ëŸ¬ ë©”ì‹œì§€ ì–¸ì–´

    Returns:
        ì—ëŸ¬ ë©”ì‹œì§€ (ì—†ìœ¼ë©´ None)
    """
    is_ko = language == "ko-KR"

    # MIME íƒ€ì… ê²€ì¦
    if content_type.lower() not in ALLOWED_IMAGE_MIME_TYPES:
        return (
            f"ì§€ì›í•˜ì§€ ì•ŠëŠ” ì´ë¯¸ì§€ í˜•ì‹ì…ë‹ˆë‹¤: {content_type}"
            if is_ko
            else f"Unsupported image format: {content_type}"
        )

    # íŒŒì¼ í¬ê¸° ê²€ì¦ (ìµœëŒ€)
    if len(content) > MAX_IMAGE_FILE_SIZE_BYTES:
        size_mb = len(content) / (1024 * 1024)
        return (
            f"íŒŒì¼ì´ ë„ˆë¬´ í½ë‹ˆë‹¤: {size_mb:.1f}MB (ìµœëŒ€ 20MB)"
            if is_ko
            else f"File too large: {size_mb:.1f}MB (max 20MB)"
        )

    # íŒŒì¼ í¬ê¸° ê²€ì¦ (ìµœì†Œ - ì†ìƒ íŒŒì¼ ê°ì§€)
    if len(content) < MIN_IMAGE_FILE_SIZE_BYTES:
        return (
            "ì´ë¯¸ì§€ íŒŒì¼ì´ ì†ìƒë˜ì—ˆê±°ë‚˜ ë¹„ì–´ìˆìŠµë‹ˆë‹¤"
            if is_ko
            else "Image file is corrupted or empty"
        )

    return None


def validate_image_generation_request(
    prompt: str,
    image_size: str,
    *,
    language: str = "ko-KR",
) -> str | None:
    """ì´ë¯¸ì§€ ìƒì„± ìš”ì²­ì„ ê²€ì¦í•©ë‹ˆë‹¤.

    Args:
        prompt: ì´ë¯¸ì§€ ìƒì„± í”„ë¡¬í”„íŠ¸
        image_size: ìš”ì²­ëœ ì´ë¯¸ì§€ í¬ê¸°
        language: ì—ëŸ¬ ë©”ì‹œì§€ ì–¸ì–´

    Returns:
        ì—ëŸ¬ ë©”ì‹œì§€ (ì—†ìœ¼ë©´ None)
    """
    is_ko = language == "ko-KR"

    # ì´ë¯¸ì§€ í¬ê¸° ê²€ì¦
    if image_size not in SUPPORTED_IMAGE_SIZES:
        return (
            f"ì§€ì›í•˜ì§€ ì•ŠëŠ” ì´ë¯¸ì§€ í¬ê¸°: {image_size}"
            if is_ko
            else f"Unsupported image size: {image_size}"
        )

    # í”„ë¡¬í”„íŠ¸ ê¸¸ì´ ê²€ì¦ (ë„ˆë¬´ ì§§ìŒ)
    if len(prompt) < MIN_PROMPT_LENGTH:
        return "í”„ë¡¬í”„íŠ¸ê°€ ë„ˆë¬´ ì§§ìŠµë‹ˆë‹¤." if is_ko else "Prompt is too short."

    # í”„ë¡¬í”„íŠ¸ ê¸¸ì´ ê²€ì¦ (ë„ˆë¬´ ê¹€)
    if len(prompt) > MAX_PROMPT_LENGTH:
        return (
            f"í”„ë¡¬í”„íŠ¸ê°€ ë„ˆë¬´ ê¹ë‹ˆë‹¤ (ìµœëŒ€ {MAX_PROMPT_LENGTH}ì)."
            if is_ko
            else f"Prompt is too long (max {MAX_PROMPT_LENGTH} chars)."
        )

    return None


def get_max_file_size_mb() -> int:
    """ìµœëŒ€ íŒŒì¼ í¬ê¸°ë¥¼ MB ë‹¨ìœ„ë¡œ ë°˜í™˜í•©ë‹ˆë‹¤."""
    return MAX_IMAGE_FILE_SIZE_BYTES // (1024 * 1024)
</file>

<file path="backend/src/unknown_world/validation/language_gate.py">
"""Unknown World - ì–¸ì–´ í˜¼í•© ê²€ì¦ ê²Œì´íŠ¸ (RULE-006).

ko/en í˜¼í•© ì¶œë ¥ì„ ê°ì§€í•˜ê³  ì°¨ë‹¨í•˜ëŠ” Hard Gateì…ë‹ˆë‹¤.
TurnInput.languageë¥¼ SSOTë¡œ ì‚¼ì•„ TurnOutputì˜ ì‚¬ìš©ì ë…¸ì¶œ í…ìŠ¤íŠ¸ê°€
ë™ì¼ ì–¸ì–´ë¡œ ìˆ˜ë ´í•˜ëŠ”ì§€ ê²€ì¦í•©ë‹ˆë‹¤.

ì„¤ê³„ ì›ì¹™:
    - RULE-006: ko/en ì–¸ì–´ ì •ì±… ì¤€ìˆ˜ (í˜¼í•© ì¶œë ¥ ê¸ˆì§€)
    - RULE-004: ê²€ì¦ ì‹¤íŒ¨ ì‹œ Repair loopë¡œ ë³µêµ¬
    - CP-MVP-05: ì–¸ì–´ í˜¼í•© ê¸ˆì§€ ê²€ì¦

í˜ì–´ë§ ê²°ì •:
    - Q1: Option A (ë³´ìˆ˜ì  - ì˜¤íƒ ìµœì†Œ, CPì—ì„œ íŠœë‹)
    - Q2: Option A (ê³ ìœ ëª… ìµœì†Œì¹˜ë§Œ í—ˆìš©)

ì°¸ì¡°:
    - vibe/unit-plans/U-043[Mvp].md
    - vibe/ref/en-ko-issue.png (í˜¼í•© ì¶œë ¥ ì‚¬ë¡€)
    - .cursor/rules/00-core-critical.mdc
"""

from __future__ import annotations

import logging
import re
import unicodedata
from dataclasses import dataclass, field
from typing import TYPE_CHECKING

from unknown_world.models.turn import Language

if TYPE_CHECKING:
    from unknown_world.models.turn import TurnOutput

# =============================================================================
# ë¡œê±° ì„¤ì •
# =============================================================================

logger = logging.getLogger(__name__)

# =============================================================================
# ìƒìˆ˜ ë° ì„¤ì •
# =============================================================================

# í˜ì–´ë§ ê²°ì • Q1: Option A (ë³´ìˆ˜ì  - ì˜¤íƒ ìµœì†Œ)
# í˜¼í•© íŒì • ì„ê³„ê°’ (ì´ ë¹„ìœ¨ ì´ìƒì´ë©´ "ì˜ëª»ëœ ì–¸ì–´"ë¡œ íŒì •)
MIXED_THRESHOLD_RATIO = 0.15  # 15% ì´ìƒì˜ ë°˜ëŒ€ ì–¸ì–´ ë¬¸ì â†’ í˜¼í•©ìœ¼ë¡œ íŒì •

# í˜ì–´ë§ ê²°ì • Q2: Option A (ê³ ìœ ëª… ìµœì†Œì¹˜ë§Œ í—ˆìš©)
# í—ˆìš© í™”ì´íŠ¸ë¦¬ìŠ¤íŠ¸ (ì˜ì–´ ê³ ìœ ëª… - ì¬í™”/ëª¨ë¸ ë¼ë²¨ ë“±)
# ì£¼ì˜: ë³µí•©ì–´ëŠ” ê°œë³„ ë‹¨ì–´ë„ í•¨ê»˜ ë“±ë¡í•´ì•¼ í•©ë‹ˆë‹¤ (í•œê¸€ ë¶™ì€ ê²½ìš° ë‹¨ì–´ ê²½ê³„ ë§¤ì¹­ ë¬¸ì œ)
ALLOWED_ENGLISH_TERMS: set[str] = {
    # ì¬í™” ì´ë¦„ (RULE-005)
    "signal",
    "shard",
    "memory",
    "memory shard",
    # ëª¨ë¸ ë¼ë²¨ (RULE-008)
    "fast",
    "quality",
    "cheap",
    "ref",
    # ì‹œìŠ¤í…œ ìƒìˆ˜
    "ok",
    "fail",
    "blocked",
    # ê¸°íƒ€ í—ˆìš© ì•½ì–´
    "ui",
    "api",
    "id",
    "json",
    "schema",
}

# í•œê¸€ ìœ ë‹ˆì½”ë“œ ë²”ìœ„
HANGUL_JAMO_START = 0x1100
HANGUL_JAMO_END = 0x11FF
HANGUL_SYLLABLES_START = 0xAC00
HANGUL_SYLLABLES_END = 0xD7AF
HANGUL_COMPAT_JAMO_START = 0x3130
HANGUL_COMPAT_JAMO_END = 0x318F


# =============================================================================
# ì–¸ì–´ ê°ì§€ íœ´ë¦¬ìŠ¤í‹±
# =============================================================================


def _is_hangul(char: str) -> bool:
    """í•œê¸€ ë¬¸ìì¸ì§€ í™•ì¸í•©ë‹ˆë‹¤."""
    code = ord(char)
    return (
        (HANGUL_SYLLABLES_START <= code <= HANGUL_SYLLABLES_END)
        or (HANGUL_JAMO_START <= code <= HANGUL_JAMO_END)
        or (HANGUL_COMPAT_JAMO_START <= code <= HANGUL_COMPAT_JAMO_END)
    )


def _is_latin(char: str) -> bool:
    """ë¼í‹´ ì•ŒíŒŒë²³ì¸ì§€ í™•ì¸í•©ë‹ˆë‹¤ (a-z, A-Z)."""
    return char.isalpha() and unicodedata.category(char).startswith("L") and not _is_hangul(char)


def _normalize_text_for_check(text: str) -> str:
    """ê²€ì‚¬ìš©ìœ¼ë¡œ í…ìŠ¤íŠ¸ë¥¼ ì •ê·œí™”í•©ë‹ˆë‹¤.

    - ì†Œë¬¸ì ë³€í™˜
    - í™”ì´íŠ¸ë¦¬ìŠ¤íŠ¸ ë‹¨ì–´ ì œê±°
    - ìˆ«ì/ê¸°í˜¸/ê³µë°±/ì´ëª¨ì§€ ì œê±°
    """
    normalized = text.lower()

    # í™”ì´íŠ¸ë¦¬ìŠ¤íŠ¸ ë‹¨ì–´ ì œê±° (ëŒ€ì†Œë¬¸ì ë¬´ì‹œ)
    # ë³µí•©ì–´ë¥¼ ë¨¼ì € ì²˜ë¦¬ (ê¸´ ê²ƒë¶€í„°)
    sorted_terms = sorted(ALLOWED_ENGLISH_TERMS, key=len, reverse=True)
    for term in sorted_terms:
        # í•œê¸€ì´ ë¶™ì–´ìˆëŠ” ê²½ìš°ë„ ì²˜ë¦¬í•˜ê¸° ìœ„í•´ ë‹¨ì–´ ê²½ê³„ ëŒ€ì‹ 
        # ì•ŒíŒŒë²³ì´ ì•„ë‹Œ ë¬¸ì ë˜ëŠ” ë¬¸ìì—´ ê²½ê³„ë¡œ ë§¤ì¹­
        # ì˜ˆ: "Signalê°€", "Memory Shardë¥¼" ë“±
        pattern = rf"(?<![a-zA-Z]){re.escape(term)}(?![a-zA-Z])"
        normalized = re.sub(pattern, "", normalized, flags=re.IGNORECASE)

    return normalized


@dataclass
class LanguageRatio:
    """ì–¸ì–´ ë¹„ìœ¨ ì¸¡ì • ê²°ê³¼.

    Attributes:
        hangul_count: í•œê¸€ ë¬¸ì ìˆ˜
        latin_count: ë¼í‹´ ë¬¸ì ìˆ˜
        total_alpha: ì´ ì•ŒíŒŒë²³ ë¬¸ì ìˆ˜ (í•œê¸€ + ë¼í‹´)
        hangul_ratio: í•œê¸€ ë¹„ìœ¨ (0.0 ~ 1.0)
        latin_ratio: ë¼í‹´ ë¹„ìœ¨ (0.0 ~ 1.0)
    """

    hangul_count: int = 0
    latin_count: int = 0
    total_alpha: int = 0
    hangul_ratio: float = 0.0
    latin_ratio: float = 0.0


def measure_language_ratio(text: str) -> LanguageRatio:
    """í…ìŠ¤íŠ¸ì˜ í•œê¸€/ë¼í‹´ ë¹„ìœ¨ì„ ì¸¡ì •í•©ë‹ˆë‹¤.

    í™”ì´íŠ¸ë¦¬ìŠ¤íŠ¸ ë‹¨ì–´ëŠ” ì œê±°í•œ í›„ ì¸¡ì •í•©ë‹ˆë‹¤.

    Args:
        text: ì¸¡ì •í•  í…ìŠ¤íŠ¸

    Returns:
        LanguageRatio: ì–¸ì–´ ë¹„ìœ¨ ì¸¡ì • ê²°ê³¼
    """
    if not text:
        return LanguageRatio()

    # ì •ê·œí™” (í™”ì´íŠ¸ë¦¬ìŠ¤íŠ¸ ì œê±°)
    normalized = _normalize_text_for_check(text)

    hangul_count = 0
    latin_count = 0

    for char in normalized:
        if _is_hangul(char):
            hangul_count += 1
        elif _is_latin(char):
            latin_count += 1

    total = hangul_count + latin_count

    if total == 0:
        return LanguageRatio()

    return LanguageRatio(
        hangul_count=hangul_count,
        latin_count=latin_count,
        total_alpha=total,
        hangul_ratio=hangul_count / total,
        latin_ratio=latin_count / total,
    )


def is_language_mixed(text: str, expected_language: Language) -> bool:
    """í…ìŠ¤íŠ¸ê°€ ì˜ˆìƒ ì–¸ì–´ì™€ ë‹¤ë¥¸ ì–¸ì–´ê°€ í˜¼í•©ë˜ì—ˆëŠ”ì§€ í™•ì¸í•©ë‹ˆë‹¤.

    Args:
        text: ê²€ì‚¬í•  í…ìŠ¤íŠ¸
        expected_language: ì˜ˆìƒ ì–¸ì–´ (TurnInput.language)

    Returns:
        bool: í˜¼í•©ë˜ì—ˆìœ¼ë©´ True
    """
    if not text or len(text.strip()) == 0:
        return False

    ratio = measure_language_ratio(text)

    # ì•ŒíŒŒë²³ì´ ê±°ì˜ ì—†ëŠ” ê²½ìš° (ìˆ«ì/ê¸°í˜¸ë§Œ) â†’ í˜¼í•© ì•„ë‹˜
    if ratio.total_alpha < 3:
        return False

    # ì˜ˆìƒ ì–¸ì–´ì— ë”°ë¼ ë°˜ëŒ€ ì–¸ì–´ ë¹„ìœ¨ ì²´í¬
    if expected_language == Language.KO:
        # í•œêµ­ì–´ ì˜ˆìƒì¸ë° ë¼í‹´ ë¹„ìœ¨ì´ ì„ê³„ê°’ ì´ìƒì´ë©´ í˜¼í•©
        return ratio.latin_ratio >= MIXED_THRESHOLD_RATIO
    else:
        # ì˜ì–´ ì˜ˆìƒì¸ë° í•œê¸€ ë¹„ìœ¨ì´ ì„ê³„ê°’ ì´ìƒì´ë©´ í˜¼í•©
        return ratio.hangul_ratio >= MIXED_THRESHOLD_RATIO


# =============================================================================
# TurnOutput í…ìŠ¤íŠ¸ ì¶”ì¶œ
# =============================================================================


@dataclass
class ExtractedText:
    """ì¶”ì¶œëœ ì‚¬ìš©ì ë…¸ì¶œ í…ìŠ¤íŠ¸.

    Attributes:
        field_path: í•„ë“œ ê²½ë¡œ (ì˜ˆ: "narrative", "ui.action_deck.cards[0].label")
        text: í…ìŠ¤íŠ¸ ë‚´ìš©
    """

    field_path: str
    text: str


def extract_user_facing_texts(turn_output: TurnOutput) -> list[ExtractedText]:
    """TurnOutputì—ì„œ ì‚¬ìš©ì ë…¸ì¶œ í…ìŠ¤íŠ¸ë¥¼ ì¶”ì¶œí•©ë‹ˆë‹¤.

    ê²€ì‚¬ ë²”ìœ„ (ìš°ì„ ìˆœìœ„):
        - narrative
        - ui.action_deck.cards[].label, description, hint, reward_hint, disabled_reason
        - ui.objects[].label, interaction_hint
        - world.quests_updated[].label
        - world.rules_changed[].label, description
        - world.memory_pins[].content

    Args:
        turn_output: ê²€ì‚¬í•  TurnOutput

    Returns:
        list[ExtractedText]: ì¶”ì¶œëœ í…ìŠ¤íŠ¸ ëª©ë¡
    """
    texts: list[ExtractedText] = []

    # 1. narrative (ê°€ì¥ ì¤‘ìš”)
    if turn_output.narrative:
        texts.append(ExtractedText(field_path="narrative", text=turn_output.narrative))

    # 2. ui.action_deck.cards[]
    for i, card in enumerate(turn_output.ui.action_deck.cards):
        texts.append(ExtractedText(field_path=f"ui.action_deck.cards[{i}].label", text=card.label))
        if card.description:
            texts.append(
                ExtractedText(
                    field_path=f"ui.action_deck.cards[{i}].description",
                    text=card.description,
                )
            )
        if card.hint:
            texts.append(
                ExtractedText(field_path=f"ui.action_deck.cards[{i}].hint", text=card.hint)
            )
        if card.reward_hint:
            texts.append(
                ExtractedText(
                    field_path=f"ui.action_deck.cards[{i}].reward_hint",
                    text=card.reward_hint,
                )
            )
        if card.disabled_reason:
            texts.append(
                ExtractedText(
                    field_path=f"ui.action_deck.cards[{i}].disabled_reason",
                    text=card.disabled_reason,
                )
            )

    # 3. ui.objects[]
    for i, obj in enumerate(turn_output.ui.objects):
        texts.append(ExtractedText(field_path=f"ui.objects[{i}].label", text=obj.label))
        if obj.interaction_hint:
            texts.append(
                ExtractedText(
                    field_path=f"ui.objects[{i}].interaction_hint",
                    text=obj.interaction_hint,
                )
            )

    # 4. world.quests_updated[]
    for i, quest in enumerate(turn_output.world.quests_updated):
        texts.append(ExtractedText(field_path=f"world.quests_updated[{i}].label", text=quest.label))

    # 5. world.rules_changed[]
    for i, rule in enumerate(turn_output.world.rules_changed):
        texts.append(ExtractedText(field_path=f"world.rules_changed[{i}].label", text=rule.label))
        if rule.description:
            texts.append(
                ExtractedText(
                    field_path=f"world.rules_changed[{i}].description",
                    text=rule.description,
                )
            )

    # 6. world.memory_pins[]
    for i, pin in enumerate(turn_output.world.memory_pins):
        texts.append(ExtractedText(field_path=f"world.memory_pins[{i}].content", text=pin.content))

    # 7. safety.message
    if turn_output.safety.message:
        texts.append(ExtractedText(field_path="safety.message", text=turn_output.safety.message))

    return texts


# =============================================================================
# ì–¸ì–´ í˜¼í•© ê²€ì¦ ê²°ê³¼
# =============================================================================


@dataclass
class LanguageGateResult:
    """ì–¸ì–´ í˜¼í•© ê²€ì¦ ê²°ê³¼.

    Attributes:
        is_valid: ê²€ì¦ í†µê³¼ ì—¬ë¶€ (í˜¼í•© ì—†ìŒ)
        violations: ìœ„ë°˜ ì‚¬í•­ ëª©ë¡ (í•„ë“œ ê²½ë¡œ + ìƒ˜í”Œ í† í°)
        expected_language: ì˜ˆìƒ ì–¸ì–´
    """

    is_valid: bool = True
    violations: list[dict[str, str]] = field(default_factory=lambda: [])
    expected_language: Language = Language.KO

    def add_violation(self, field_path: str, sample_text: str) -> None:
        """ìœ„ë°˜ ì‚¬í•­ì„ ì¶”ê°€í•©ë‹ˆë‹¤."""
        self.is_valid = False
        # ë¡œê·¸ì— ì „ì²´ í…ìŠ¤íŠ¸ ë…¸ì¶œ ë°©ì§€ - ì• 50ìë§Œ ìƒ˜í”Œë§
        truncated = sample_text[:50] + "..." if len(sample_text) > 50 else sample_text
        self.violations.append({"field": field_path, "sample": truncated})


def validate_language_consistency(
    turn_output: TurnOutput,
    expected_language: Language,
) -> LanguageGateResult:
    """TurnOutputì˜ ì–¸ì–´ ì¼ê´€ì„±ì„ ê²€ì¦í•©ë‹ˆë‹¤.

    ì‚¬ìš©ì ë…¸ì¶œ í…ìŠ¤íŠ¸ê°€ expected_languageì™€ ì¼ì¹˜í•˜ëŠ”ì§€ í™•ì¸í•©ë‹ˆë‹¤.
    í˜¼í•© ë°œê²¬ ì‹œ ìœ„ë°˜ ëª©ë¡ì„ ë°˜í™˜í•©ë‹ˆë‹¤.

    Args:
        turn_output: ê²€ì‚¬í•  TurnOutput
        expected_language: ì˜ˆìƒ ì–¸ì–´ (TurnInput.language)

    Returns:
        LanguageGateResult: ê²€ì¦ ê²°ê³¼

    Example:
        >>> result = validate_language_consistency(turn_output, Language.KO)
        >>> if not result.is_valid:
        ...     print(f"í˜¼í•© ë°œê²¬: {len(result.violations)}ê±´")
    """
    result = LanguageGateResult(expected_language=expected_language)

    # ì‚¬ìš©ì ë…¸ì¶œ í…ìŠ¤íŠ¸ ì¶”ì¶œ
    texts = extract_user_facing_texts(turn_output)

    # ê° í…ìŠ¤íŠ¸ ê²€ì‚¬
    for extracted in texts:
        if is_language_mixed(extracted.text, expected_language):
            result.add_violation(extracted.field_path, extracted.text)

    if not result.is_valid:
        logger.warning(
            "[LanguageGate] ì–¸ì–´ í˜¼í•© ê°ì§€",
            extra={
                "expected_language": expected_language.value,
                "violation_count": len(result.violations),
            },
        )

    return result


# =============================================================================
# i18n ì—ëŸ¬ ë©”ì‹œì§€ (RULE-006)
# =============================================================================

LANGUAGE_GATE_MESSAGES: dict[Language, dict[str, str]] = {
    Language.KO: {
        "summary_header": "ì–¸ì–´ í˜¼í•©ì´ ê°ì§€ë˜ì—ˆìŠµë‹ˆë‹¤ (RULE-006 ìœ„ë°˜):",
        "violation_item": "- í•„ë“œ '{field}': í•œêµ­ì–´ë¡œ ì‘ì„±í•´ì•¼ í•©ë‹ˆë‹¤",
        "instruction": "ëª¨ë“  ì‚¬ìš©ì ë…¸ì¶œ í…ìŠ¤íŠ¸ë¥¼ í•œêµ­ì–´(ko-KR)ë¡œ ë‹¤ì‹œ ì‘ì„±í•˜ì„¸ìš”.",
    },
    Language.EN: {
        "summary_header": "Language mixing detected (RULE-006 violation):",
        "violation_item": "- Field '{field}': Must be written in English",
        "instruction": "Rewrite all user-facing text in English (en-US).",
    },
}


def build_language_error_summary(result: LanguageGateResult) -> str:
    """ì–¸ì–´ í˜¼í•© ê²€ì¦ ì‹¤íŒ¨ì— ëŒ€í•œ ì—ëŸ¬ ìš”ì•½ì„ ìƒì„±í•©ë‹ˆë‹¤.

    Repair í”„ë¡¬í”„íŠ¸ì— í¬í•¨í•  ìš”ì•½ì…ë‹ˆë‹¤.
    ì „ì²´ í…ìŠ¤íŠ¸ëŠ” ë…¸ì¶œí•˜ì§€ ì•Šê³  í•„ë“œ ê²½ë¡œë§Œ í‘œì‹œí•©ë‹ˆë‹¤.

    Args:
        result: ì–¸ì–´ ê²€ì¦ ê²°ê³¼

    Returns:
        str: ì—ëŸ¬ ìš”ì•½ ë¬¸ìì—´
    """
    if result.is_valid:
        return ""

    messages = LANGUAGE_GATE_MESSAGES[result.expected_language]
    lines = [messages["summary_header"]]

    # ìµœëŒ€ 5ê°œê¹Œì§€ë§Œ í‘œì‹œ (ë„ˆë¬´ ë§ìœ¼ë©´ í”„ë¡¬í”„íŠ¸ ë¹„ëŒ€)
    for violation in result.violations[:5]:
        lines.append(messages["violation_item"].format(field=violation["field"]))

    if len(result.violations) > 5:
        remaining = len(result.violations) - 5
        if result.expected_language == Language.KO:
            lines.append(f"- (ì™¸ {remaining}ê±´ ì¶”ê°€ ìœ„ë°˜)")
        else:
            lines.append(f"- (and {remaining} more violations)")

    lines.append("")
    lines.append(messages["instruction"])

    return "\n".join(lines)
</file>

<file path="backend/tests/integration/test_real_mode_gate.py">
"""CP-MVP-07: real ëª¨ë“œ ë¡œì»¬ ì‹¤í–‰ ê²Œì´íŠ¸ í†µí•© í…ŒìŠ¤íŠ¸.

ë¡œì»¬ ê°œë°œ í™˜ê²½ì—ì„œ `.env` ê¸°ë°˜ ì„¤ì •ìœ¼ë¡œ **real ëª¨ë“œ(ì‹¤ëª¨ë¸) ì‹¤í–‰**ì´
ì•ˆì •ì ìœ¼ë¡œ ì¬í˜„ë˜ëŠ”ì§€ ê²€ì¦í•©ë‹ˆë‹¤.

ì™„ë£Œ ê¸°ì¤€:
- `.env`ê°€ ë¡œë“œëœ ìƒíƒœì—ì„œ ì„œë²„ê°€ real ëª¨ë“œë¡œ ì‹¤í–‰ë˜ë©°, `/health`ê°€ ì •ìƒ ì‘ë‹µí•œë‹¤.
- í„´ 1íšŒ ì‹¤í–‰ ì‹œ NDJSON ìŠ¤íŠ¸ë¦¼ì´ ì •ìƒì ìœ¼ë¡œ íë¥´ê³  ìµœì¢… `final`ì´ ìŠ¤í‚¤ë§ˆ/ë¹„ì¦ˆë‹ˆìŠ¤ ë£°ì„ í†µê³¼í•œë‹¤.
- ì¸ì¦/í™˜ê²½ë³€ìˆ˜ ëˆ„ë½ ì¼€ì´ìŠ¤ì—ì„œë„ ì„œë²„ê°€ í¬ë˜ì‹œí•˜ì§€ ì•Šê³ , ì•ˆì „ í´ë°±ìœ¼ë¡œ ì¢…ë£Œí•œë‹¤. (RULE-004)
- mock ê³ ì • ë‚´ëŸ¬í‹°ë¸Œê°€ real ëª¨ë“œì—ì„œ ë°˜ë³µ ë…¸ì¶œë˜ì§€ ì•ŠëŠ”ë‹¤(ëª¨ë“œ ë“œë¦¬í”„íŠ¸ ë°©ì§€).
- ë¯¼ê° ì •ë³´ê°€ ë¡œê·¸ì— ë…¸ì¶œë˜ì§€ ì•ŠëŠ”ë‹¤ (RULE-007).

ì°¸ì¡°:
- vibe/unit-plans/CP-MVP-07.md
- vibe/unit-results/U-047[Mvp].md
- vibe/unit-results/CP-MVP-04.md
"""

from __future__ import annotations

import json
import os
from collections.abc import Generator
from pathlib import Path
from typing import Any

import pytest
from dotenv import load_dotenv
from fastapi.testclient import TestClient

from unknown_world.main import app
from unknown_world.models.turn import Language, TurnOutput
from unknown_world.services.genai_client import (
    GenAIMode,
    get_genai_client,
    reset_genai_client,
)

# =============================================================================
# Fixtures
# =============================================================================


@pytest.fixture
def client() -> TestClient:
    """FastAPI í…ŒìŠ¤íŠ¸ í´ë¼ì´ì–¸íŠ¸."""
    return TestClient(app)


@pytest.fixture
def mock_mode_env() -> Generator[None]:
    """UW_MODE=mock í™˜ê²½ì„ ì„¤ì •í•©ë‹ˆë‹¤."""
    original = os.environ.get("UW_MODE")
    os.environ["UW_MODE"] = "mock"
    reset_genai_client()  # í´ë¼ì´ì–¸íŠ¸ ìºì‹œ ì´ˆê¸°í™”

    yield

    if original is not None:
        os.environ["UW_MODE"] = original
    elif "UW_MODE" in os.environ:
        del os.environ["UW_MODE"]
    reset_genai_client()


@pytest.fixture
def real_mode_env() -> Generator[None]:
    """UW_MODE=real í™˜ê²½ì„ ì„¤ì •í•©ë‹ˆë‹¤ (ì‹¤ì œ API í˜¸ì¶œ ì—†ì´ í´ë¼ì´ì–¸íŠ¸ ëª¨ë“œë§Œ ë³€ê²½)."""
    original = os.environ.get("UW_MODE")
    os.environ["UW_MODE"] = "real"
    reset_genai_client()  # í´ë¼ì´ì–¸íŠ¸ ìºì‹œ ì´ˆê¸°í™”

    yield

    if original is not None:
        os.environ["UW_MODE"] = original
    elif "UW_MODE" in os.environ:
        del os.environ["UW_MODE"]
    reset_genai_client()


# =============================================================================
# ì‹œë‚˜ë¦¬ì˜¤ A: ì„œë²„ ê¸°ë™ ë° ìƒíƒœ í™•ì¸ (Health Check)
# =============================================================================


class TestServerHealthWithEnv:
    """ì„œë²„ ê¸°ë™ ë° ìƒíƒœ í™•ì¸ í…ŒìŠ¤íŠ¸ (ì‹œë‚˜ë¦¬ì˜¤ A)."""

    def test_health_endpoint_returns_ok(self, client: TestClient) -> None:
        """[Happy] /health ì—”ë“œí¬ì¸íŠ¸ê°€ ì •ìƒ ì‘ë‹µí•©ë‹ˆë‹¤."""
        # When: í—¬ìŠ¤ì²´í¬ ìš”ì²­
        response = client.get("/health")

        # Then: ì •ìƒ ì‘ë‹µ
        assert response.status_code == 200
        data = response.json()
        assert data["status"] in ("ok", "degraded")
        assert data["service"] == "unknown-world-backend"
        assert "version" in data

    def test_health_includes_rembg_status(self, client: TestClient) -> None:
        """[Happy] /health ì‘ë‹µì— rembg ìƒíƒœê°€ í¬í•¨ë©ë‹ˆë‹¤."""
        # When: í—¬ìŠ¤ì²´í¬ ìš”ì²­
        response = client.get("/health")

        # Then: rembg ì •ë³´ í¬í•¨
        data = response.json()
        assert "rembg" in data
        rembg_info = data["rembg"]
        assert rembg_info["status"] in ("ready", "degraded", "unavailable", "pending")
        assert "installed" in rembg_info

    def test_uw_mode_environment_variable_loaded(self) -> None:
        """[Happy] UW_MODE í™˜ê²½ë³€ìˆ˜ê°€ ì˜¬ë°”ë¥´ê²Œ ë¡œë“œë©ë‹ˆë‹¤."""
        # Given: í˜„ì¬ í™˜ê²½ì˜ UW_MODE ê°’
        uw_mode = os.environ.get("UW_MODE", "mock")

        # Then: ìœ íš¨í•œ ê°’ì´ì–´ì•¼ í•¨
        assert uw_mode in ("mock", "real")


# =============================================================================
# ì‹œë‚˜ë¦¬ì˜¤ B: real ëª¨ë“œ í„´ ìŠ¤ëª¨í¬ í…ŒìŠ¤íŠ¸ (ìŠ¤íŠ¸ë¦¬ë°)
# =============================================================================


class TestTurnStreamingInMockMode:
    """í„´ ìŠ¤íŠ¸ë¦¬ë° í…ŒìŠ¤íŠ¸ (Mock ëª¨ë“œ, ì‹œë‚˜ë¦¬ì˜¤ Bì˜ ê¸°ë³¸ ê²½ë¡œ)."""

    def test_stage_events_order(self, client: TestClient, mock_mode_env: None) -> None:
        """[Happy] stage ì´ë²¤íŠ¸ê°€ ì˜¬ë°”ë¥¸ ìˆœì„œë¡œ ë°œìƒí•©ë‹ˆë‹¤."""
        # Given: ìœ íš¨í•œ í„´ ì…ë ¥
        payload = {
            "language": "ko-KR",
            "text": "í…ŒìŠ¤íŠ¸ ì…ë ¥",
            "client": {"viewport_w": 1920, "viewport_h": 1080, "theme": "dark"},
            "economy_snapshot": {"signal": 100, "memory_shard": 5},
        }

        # When: í„´ ìš”ì²­
        response = client.post("/api/turn", json=payload)

        # Then: ì •ìƒ ìŠ¤íŠ¸ë¦¬ë° ì‘ë‹µ
        assert response.status_code == 200
        assert response.headers["content-type"] == "application/x-ndjson"

        events = [json.loads(line) for line in response.iter_lines() if line]

        # stage ì´ë²¤íŠ¸ ìˆœì„œ í™•ì¸
        stages = [e["name"] for e in events if e["type"] == "stage" and e["status"] == "start"]
        expected_stages = [
            "parse",
            "validate",
            "plan",
            "resolve",
            "render",
            "verify",
            "commit",
        ]
        assert stages == expected_stages

    def test_final_event_has_valid_turn_output(
        self, client: TestClient, mock_mode_env: None
    ) -> None:
        """[Happy] final ì´ë²¤íŠ¸ê°€ ìœ íš¨í•œ TurnOutputì„ í¬í•¨í•©ë‹ˆë‹¤."""
        # Given: ìœ íš¨í•œ í„´ ì…ë ¥
        payload = {
            "language": "ko-KR",
            "text": "ë¬¸ì„ ì—´ì–´ë³¸ë‹¤",
            "client": {"viewport_w": 1920, "viewport_h": 1080},
            "economy_snapshot": {"signal": 100, "memory_shard": 5},
        }

        # When: í„´ ìš”ì²­
        response = client.post("/api/turn", json=payload)
        events = [json.loads(line) for line in response.iter_lines() if line]

        # Then: final ì´ë²¤íŠ¸ í™•ì¸
        final_events = [e for e in events if e["type"] == "final"]
        assert len(final_events) == 1

        # Pydantic ê²€ì¦ (RULE-003)
        turn_output = TurnOutput.model_validate(final_events[0]["data"])
        assert turn_output.language == Language.KO

    def test_badges_contain_all_categories(self, client: TestClient, mock_mode_env: None) -> None:
        """[Happy] badgesê°€ ëª¨ë“  ì¹´í…Œê³ ë¦¬(Schema/Economy/Safety/Consistency)ë¥¼ í¬í•¨í•©ë‹ˆë‹¤."""
        # Given: ìœ íš¨í•œ í„´ ì…ë ¥
        payload = {
            "language": "ko-KR",
            "text": "íƒìƒ‰í•œë‹¤",
            "client": {"viewport_w": 1920, "viewport_h": 1080},
            "economy_snapshot": {"signal": 100, "memory_shard": 5},
        }

        # When: í„´ ìš”ì²­
        response = client.post("/api/turn", json=payload)
        events = [json.loads(line) for line in response.iter_lines() if line]

        # Then: badges ì´ë²¤íŠ¸ í™•ì¸
        badges_events = [e for e in events if e["type"] == "badges"]
        assert len(badges_events) >= 1

        # ìµœì¢… badgesì— ëª¨ë“  ì¹´í…Œê³ ë¦¬ê°€ í¬í•¨ë˜ì–´ì•¼ í•¨
        final_badges = badges_events[-1]["badges"]
        badge_categories = {b.split("_")[0] for b in final_badges}

        # Schema, Economy, Safety, Consistency ì¤‘ ìµœì†Œ 3ê°œ ì´ìƒ
        expected_categories = {"schema", "economy", "safety", "consistency"}
        assert len(badge_categories.intersection(expected_categories)) >= 3


# =============================================================================
# ì‹œë‚˜ë¦¬ì˜¤ C: Hard Gate ì¸ë°”ë¦¬ì–¸íŠ¸ ê²€ì¦
# =============================================================================


class TestHardGateInvariants:
    """Hard Gate ì¸ë°”ë¦¬ì–¸íŠ¸ ê²€ì¦ í…ŒìŠ¤íŠ¸ (ì‹œë‚˜ë¦¬ì˜¤ C)."""

    def test_schema_ok_in_successful_turn(self, client: TestClient, mock_mode_env: None) -> None:
        """[Happy] ì„±ê³µì ì¸ í„´ì—ì„œ schema_ok ë°°ì§€ê°€ í¬í•¨ë©ë‹ˆë‹¤."""
        # Given: ìœ íš¨í•œ í„´ ì…ë ¥
        payload = {
            "language": "ko-KR",
            "text": "ì •ìƒ ì…ë ¥",
            "client": {"viewport_w": 1920, "viewport_h": 1080},
            "economy_snapshot": {"signal": 100, "memory_shard": 5},
        }

        # When: í„´ ìš”ì²­
        response = client.post("/api/turn", json=payload)
        events = [json.loads(line) for line in response.iter_lines() if line]

        # Then: finalì˜ ë°°ì§€ì— schema_ok í¬í•¨
        final_event = next(e for e in events if e["type"] == "final")
        badges = final_event["data"]["agent_console"]["badges"]
        assert "schema_ok" in badges

    def test_economy_ok_and_no_negative_balance(
        self, client: TestClient, mock_mode_env: None
    ) -> None:
        """[Happy] economy_ok ë°°ì§€ì™€ ì”ì•¡ ìŒìˆ˜ ê¸ˆì§€ (RULE-005)."""
        # Given: ìœ íš¨í•œ í„´ ì…ë ¥
        payload = {
            "language": "ko-KR",
            "text": "í–‰ë™",
            "client": {"viewport_w": 1920, "viewport_h": 1080},
            "economy_snapshot": {"signal": 50, "memory_shard": 2},
        }

        # When: í„´ ìš”ì²­
        response = client.post("/api/turn", json=payload)
        events = [json.loads(line) for line in response.iter_lines() if line]

        # Then: economy í™•ì¸
        final_event = next(e for e in events if e["type"] == "final")
        economy = final_event["data"]["economy"]

        # ì”ì•¡ì€ ìŒìˆ˜ê°€ ì•„ë‹ˆì–´ì•¼ í•¨
        assert economy["balance_after"]["signal"] >= 0
        assert economy["balance_after"]["memory_shard"] >= 0

        # economy_ok ë°°ì§€ í¬í•¨
        badges = final_event["data"]["agent_console"]["badges"]
        assert "economy_ok" in badges

    def test_language_consistency(self, client: TestClient, mock_mode_env: None) -> None:
        """[Happy] ì–¸ì–´ ì¼ê´€ì„± ìœ ì§€ (RULE-006)."""
        # Given: í•œêµ­ì–´ ìš”ì²­
        payload = {
            "language": "ko-KR",
            "text": "í…ŒìŠ¤íŠ¸",
            "client": {"viewport_w": 1920, "viewport_h": 1080},
            "economy_snapshot": {"signal": 100, "memory_shard": 5},
        }

        # When: í„´ ìš”ì²­
        response = client.post("/api/turn", json=payload)
        events = [json.loads(line) for line in response.iter_lines() if line]

        # Then: ì‘ë‹µ ì–¸ì–´ê°€ ìš”ì²­ê³¼ ì¼ì¹˜
        final_event = next(e for e in events if e["type"] == "final")
        assert final_event["data"]["language"] == "ko-KR"


# =============================================================================
# ì‹œë‚˜ë¦¬ì˜¤ D: ì¸ì¦ ì‹¤íŒ¨ ì¼€ì´ìŠ¤ (ì•ˆì „ í´ë°±)
# =============================================================================


class TestSafeFallback:
    """ì•ˆì „ í´ë°± í…ŒìŠ¤íŠ¸ (ì‹œë‚˜ë¦¬ì˜¤ D)."""

    def test_invalid_input_returns_error_and_fallback(self, client: TestClient) -> None:
        """[Error] ì˜ëª»ëœ ì…ë ¥ ì‹œ error + final(í´ë°±) ì´ë²¤íŠ¸ê°€ ë°˜í™˜ë©ë‹ˆë‹¤."""
        # Given: ì˜ëª»ëœ ì–¸ì–´ ì½”ë“œ
        payload = {
            "language": "invalid-lang",
            "text": "",
        }

        # When: í„´ ìš”ì²­
        response = client.post("/api/turn", json=payload)

        # Then: 200 ì‘ë‹µ (ìŠ¤íŠ¸ë¦¬ë°ì´ë¯€ë¡œ)
        assert response.status_code == 200

        events = [json.loads(line) for line in response.iter_lines() if line]

        # error ì´ë²¤íŠ¸ í¬í•¨
        error_events = [e for e in events if e["type"] == "error"]
        assert len(error_events) >= 1
        assert error_events[0]["code"] == "VALIDATION_ERROR"

        # final(í´ë°±) ì´ë²¤íŠ¸ í¬í•¨
        final_events = [e for e in events if e["type"] == "final"]
        assert len(final_events) == 1

    def test_fallback_has_zero_cost(self, client: TestClient) -> None:
        """[Error] í´ë°± ì‘ë‹µì˜ ë¹„ìš©ì€ 0ì…ë‹ˆë‹¤ (RULE-005)."""
        # Given: ì˜ëª»ëœ ì…ë ¥ìœ¼ë¡œ í´ë°± ìœ ë„
        payload = {
            "language": "invalid",
            "text": "",
        }

        # When: í„´ ìš”ì²­
        response = client.post("/api/turn", json=payload)
        events = [json.loads(line) for line in response.iter_lines() if line]

        # Then: í´ë°± ë¹„ìš© 0
        final_event = next(e for e in events if e["type"] == "final")
        economy = final_event["data"]["economy"]
        assert economy["cost"]["signal"] == 0
        assert economy["cost"]["memory_shard"] == 0

    def test_fallback_includes_all_badge_categories(self, client: TestClient) -> None:
        """[Error] í´ë°± ì‘ë‹µë„ ëª¨ë“  ë°°ì§€ ì¹´í…Œê³ ë¦¬ë¥¼ í¬í•¨í•©ë‹ˆë‹¤ (RU-005-S1)."""
        # Given: ì˜ëª»ëœ ì…ë ¥ìœ¼ë¡œ í´ë°± ìœ ë„
        payload = {
            "language": "invalid",
            "text": "",
        }

        # When: í„´ ìš”ì²­
        response = client.post("/api/turn", json=payload)
        events = [json.loads(line) for line in response.iter_lines() if line]

        # Then: í´ë°±ì˜ ë°°ì§€ í™•ì¸
        final_event = next(e for e in events if e["type"] == "final")
        badges = final_event["data"]["agent_console"]["badges"]

        # ëª¨ë“  ì¹´í…Œê³ ë¦¬ í¬í•¨ í™•ì¸
        badge_prefixes = {b.split("_")[0] for b in badges}
        expected_prefixes = {"schema", "economy", "safety", "consistency"}
        assert badge_prefixes == expected_prefixes


# =============================================================================
# ì‹œë‚˜ë¦¬ì˜¤: Mock í…œí”Œë¦¿ ë°˜ë³µ ë°©ì§€ (ëª¨ë“œ ë“œë¦¬í”„íŠ¸)
# =============================================================================


class TestModeDriftPrevention:
    """ëª¨ë“œ ë“œë¦¬í”„íŠ¸ ë°©ì§€ í…ŒìŠ¤íŠ¸."""

    def test_mock_mode_client_returns_mock(self, mock_mode_env: None) -> None:
        """[Happy] UW_MODE=mockì¼ ë•Œ Mock í´ë¼ì´ì–¸íŠ¸ê°€ ë°˜í™˜ë©ë‹ˆë‹¤."""
        # When: í´ë¼ì´ì–¸íŠ¸ ì¡°íšŒ
        client = get_genai_client()

        # Then: Mock ëª¨ë“œ
        assert client.mode == GenAIMode.MOCK

    def test_real_mode_setting_respected(self, real_mode_env: None) -> None:
        """[Happy] UW_MODE=realì¼ ë•Œ real ëª¨ë“œê°€ ì„¤ì •ë©ë‹ˆë‹¤.

        Note: ì‹¤ì œ Vertex AI ì—°ê²°ì´ ì—†ìœ¼ë©´ Mockìœ¼ë¡œ í´ë°±í•  ìˆ˜ ìˆì§€ë§Œ,
        í™˜ê²½ë³€ìˆ˜ ì„¤ì •ì€ ì˜¬ë°”ë¥´ê²Œ ë°˜ì˜ë˜ì–´ì•¼ í•©ë‹ˆë‹¤.
        """
        # When: í™˜ê²½ë³€ìˆ˜ í™•ì¸
        uw_mode = os.environ.get("UW_MODE")

        # Then: real ëª¨ë“œ ì„¤ì •ë¨
        assert uw_mode == "real"


# =============================================================================
# ì‹œë‚˜ë¦¬ì˜¤: ë³´ì•ˆ ê²€ì¦ (RULE-007)
# =============================================================================


class TestSecurityCompliance:
    """ë³´ì•ˆ ê·œì¹™ ì¤€ìˆ˜ í…ŒìŠ¤íŠ¸."""

    def test_sensitive_info_not_in_health_response(self, client: TestClient) -> None:
        """[Security] /health ì‘ë‹µì— ë¯¼ê° ì •ë³´ê°€ í¬í•¨ë˜ì§€ ì•ŠìŠµë‹ˆë‹¤."""
        # When: í—¬ìŠ¤ì²´í¬ ìš”ì²­
        response = client.get("/health")
        data = response.json()

        # Then: ë¯¼ê° ì •ë³´ ë¯¸í¬í•¨
        response_text = json.dumps(data)
        assert "GOOGLE_APPLICATION_CREDENTIALS" not in response_text
        assert ".key" not in response_text.lower() or "key" in data.get("rembg", {}).get(
            "status", ""
        )
        assert "token" not in response_text.lower()
        assert "secret" not in response_text.lower()

    def test_error_response_no_internal_details(self, client: TestClient) -> None:
        """[Security] ì—ëŸ¬ ì‘ë‹µì— ë‚´ë¶€ êµ¬í˜„ ì„¸ë¶€ì‚¬í•­ì´ ë…¸ì¶œë˜ì§€ ì•ŠìŠµë‹ˆë‹¤."""
        # Given: ì˜ëª»ëœ ì…ë ¥
        payload = {"invalid": "data"}

        # When: í„´ ìš”ì²­
        response = client.post("/api/turn", json=payload)
        events = [json.loads(line) for line in response.iter_lines() if line]

        # Then: ì—ëŸ¬ ë©”ì‹œì§€ì— ìŠ¤íƒ íŠ¸ë ˆì´ìŠ¤ ì—†ìŒ
        error_events = [e for e in events if e["type"] == "error"]
        if error_events:
            error_message = str(error_events[0])
            assert "Traceback" not in error_message
            assert "File " not in error_message


# =============================================================================
# ì‹œë‚˜ë¦¬ì˜¤: .env ë¡œë”© ì •ì±… ê²€ì¦
# =============================================================================


class TestEnvLoadingPolicy:
    """í™˜ê²½ë³€ìˆ˜ ë¡œë”© ì •ì±… í…ŒìŠ¤íŠ¸."""

    def test_dotenv_override_false_policy(self) -> None:
        """[Policy] override=False ì •ì±…ì´ ì ìš©ë©ë‹ˆë‹¤.

        ìš´ì˜ í™˜ê²½ì˜ í™˜ê²½ë³€ìˆ˜ê°€ .env íŒŒì¼ë³´ë‹¤ ìš°ì„ í•©ë‹ˆë‹¤.
        """
        # Given: í™˜ê²½ë³€ìˆ˜ê°€ ì´ë¯¸ ì„¤ì •ë¨
        original = os.environ.get("TEST_OVERRIDE_VAR")
        os.environ["TEST_OVERRIDE_VAR"] = "production_value"

        try:
            # When: .env íŒŒì¼ ë¡œë“œ ì‹œë®¬ë ˆì´ì…˜ (override=False)
            from tempfile import NamedTemporaryFile

            with NamedTemporaryFile(mode="w", suffix=".env", delete=False) as f:
                f.write("TEST_OVERRIDE_VAR=dev_value\n")
                temp_path = Path(f.name)

            load_dotenv(dotenv_path=temp_path, override=False)

            # Then: ê¸°ì¡´ ê°’ ìœ ì§€
            assert os.environ.get("TEST_OVERRIDE_VAR") == "production_value"

        finally:
            temp_path.unlink()
            if original is not None:
                os.environ["TEST_OVERRIDE_VAR"] = original
            elif "TEST_OVERRIDE_VAR" in os.environ:
                del os.environ["TEST_OVERRIDE_VAR"]

    def test_server_works_without_env_file(self, client: TestClient) -> None:
        """[Policy] .env íŒŒì¼ ì—†ì´ë„ ì„œë²„ê°€ ì •ìƒ ì‘ë™í•©ë‹ˆë‹¤."""
        # When: í—¬ìŠ¤ì²´í¬ ìš”ì²­
        response = client.get("/health")

        # Then: ì •ìƒ ì‘ë‹µ (ì–´ë–¤ í™˜ê²½ì—ì„œë“ )
        assert response.status_code == 200


# =============================================================================
# ì‹œë‚˜ë¦¬ì˜¤: ìŠ¤íŠ¸ë¦¬ë° ë¬´ê²°ì„± ê²€ì¦
# =============================================================================


class TestStreamingIntegrity:
    """ìŠ¤íŠ¸ë¦¬ë° ë¬´ê²°ì„± í…ŒìŠ¤íŠ¸."""

    def test_first_event_is_stage_parse_start(
        self, client: TestClient, mock_mode_env: None
    ) -> None:
        """[Happy] ì²« ë²ˆì§¸ ì´ë²¤íŠ¸ëŠ” í•­ìƒ stage: parse: startì…ë‹ˆë‹¤ (TTFB)."""
        # Given: ìœ íš¨í•œ í„´ ì…ë ¥
        payload = {
            "language": "ko-KR",
            "text": "í…ŒìŠ¤íŠ¸",
            "client": {"viewport_w": 1920, "viewport_h": 1080},
            "economy_snapshot": {"signal": 100, "memory_shard": 5},
        }

        # When: í„´ ìš”ì²­
        response = client.post("/api/turn", json=payload)
        events = [json.loads(line) for line in response.iter_lines() if line]

        # Then: ì²« ì´ë²¤íŠ¸ í™•ì¸
        assert events[0]["type"] == "stage"
        assert events[0]["name"] == "parse"
        assert events[0]["status"] == "start"

    def test_final_event_is_last(self, client: TestClient, mock_mode_env: None) -> None:
        """[Happy] final ì´ë²¤íŠ¸ê°€ ë§ˆì§€ë§‰ì— ì˜µë‹ˆë‹¤."""
        # Given: ìœ íš¨í•œ í„´ ì…ë ¥
        payload = {
            "language": "ko-KR",
            "text": "í…ŒìŠ¤íŠ¸",
            "client": {"viewport_w": 1920, "viewport_h": 1080},
            "economy_snapshot": {"signal": 100, "memory_shard": 5},
        }

        # When: í„´ ìš”ì²­
        response = client.post("/api/turn", json=payload)
        events = [json.loads(line) for line in response.iter_lines() if line]

        # Then: ë§ˆì§€ë§‰ ì´ë²¤íŠ¸ê°€ final
        assert events[-1]["type"] == "final"

    def test_content_type_is_ndjson(self, client: TestClient, mock_mode_env: None) -> None:
        """[Happy] Content-Typeì´ application/x-ndjsonì…ë‹ˆë‹¤."""
        # Given: ìœ íš¨í•œ í„´ ì…ë ¥
        payload = {
            "language": "ko-KR",
            "text": "í…ŒìŠ¤íŠ¸",
            "client": {"viewport_w": 1920, "viewport_h": 1080},
            "economy_snapshot": {"signal": 100, "memory_shard": 5},
        }

        # When: í„´ ìš”ì²­
        response = client.post("/api/turn", json=payload)

        # Then: ì˜¬ë°”ë¥¸ Content-Type
        assert response.headers["content-type"] == "application/x-ndjson"

    def test_deterministic_with_seed(self, client: TestClient, mock_mode_env: None) -> None:
        """[Happy] seed ì‚¬ìš© ì‹œ ê²°ê³¼ê°€ ê²°ì •ì ì…ë‹ˆë‹¤."""
        # Given: ë™ì¼í•œ ì…ë ¥ê³¼ ì‹œë“œ
        payload = {
            "language": "en-US",
            "text": "Test",
            "client": {"viewport_w": 1920, "viewport_h": 1080},
            "economy_snapshot": {"signal": 100, "memory_shard": 5},
        }
        seed = 42

        # When: ë™ì¼í•œ ì‹œë“œë¡œ ë‘ ë²ˆ ìš”ì²­
        def get_final(s: int) -> dict[str, Any]:
            resp = client.post(f"/api/turn?seed={s}", json=payload)
            events = [json.loads(line) for line in resp.iter_lines() if line]
            return next(e["data"] for e in events if e["type"] == "final")

        output1 = get_final(seed)
        output2 = get_final(seed)

        # Then: ë™ì¼í•œ ê²°ê³¼
        assert output1 == output2
</file>

<file path="backend/tests/integration/test_scanner_api.py">
"""U-021 ì´ë¯¸ì§€ ì´í•´(Scanner) API í†µí•© í…ŒìŠ¤íŠ¸."""

from fastapi.testclient import TestClient

from unknown_world.main import app
from unknown_world.models.scanner import ScanStatus

client = TestClient(app)


def test_scanner_health():
    """Scanner í—¬ìŠ¤ì²´í¬ ì—”ë“œí¬ì¸íŠ¸ í…ŒìŠ¤íŠ¸."""
    response = client.get("/api/scan/health")
    assert response.status_code == 200
    data = response.json()
    assert data["status"] == "ok"
    assert "mode" in data
    assert "supported_formats" in data


def test_scan_image_mock_ko():
    """ì´ë¯¸ì§€ ìŠ¤ìº” í…ŒìŠ¤íŠ¸ (Mock ëª¨ë“œ, í•œêµ­ì–´)."""
    # í…ŒìŠ¤íŠ¸ìš© ì´ë¯¸ì§€ ë°ì´í„° (100ë°”ì´íŠ¸ ì´ìƒ í•„ìš”)
    file_content = b"fake image content" * 10
    files = {"file": ("test.png", file_content, "image/png")}
    data = {"language": "ko-KR"}

    # UW_MODE=mock í™˜ê²½ì—ì„œ ì‹¤í–‰ëœë‹¤ê³  ê°€ì •
    response = client.post("/api/scan", files=files, data=data)

    assert response.status_code == 200
    res_data = response.json()
    assert res_data["success"] is True
    assert res_data["status"] == ScanStatus.COMPLETED
    assert "[Mock]" in res_data["caption"]
    assert res_data["language"] == "ko-KR"
    assert len(res_data["objects"]) > 0
    assert len(res_data["item_candidates"]) > 0


def test_scan_image_mock_en():
    """ì´ë¯¸ì§€ ìŠ¤ìº” í…ŒìŠ¤íŠ¸ (Mock ëª¨ë“œ, ì˜ì–´)."""
    file_content = b"fake image content" * 10
    files = {"file": ("test.png", file_content, "image/png")}
    data = {"language": "en-US"}

    response = client.post("/api/scan", files=files, data=data)

    assert response.status_code == 200
    res_data = response.json()
    assert res_data["success"] is True
    assert "[Mock]" in res_data["caption"]
    assert res_data["language"] == "en-US"


def test_scan_image_invalid_type():
    """ì§€ì›í•˜ì§€ ì•ŠëŠ” íŒŒì¼ í˜•ì‹ í…ŒìŠ¤íŠ¸."""
    file_content = b"some text"
    files = {"file": ("test.txt", file_content, "text/plain")}

    response = client.post("/api/scan", files=files)

    assert response.status_code == 200  # ì‹¤íŒ¨í•˜ë”ë¼ë„ 200 ì‘ë‹µ + success=False (RULE-004)
    res_data = response.json()
    assert res_data["success"] is False
    assert res_data["status"] == ScanStatus.FAILED
    assert "ì§€ì›í•˜ì§€ ì•ŠëŠ” ì´ë¯¸ì§€ í˜•ì‹" in res_data["message"]


def test_scan_image_too_large():
    """íŒŒì¼ í¬ê¸° ì´ˆê³¼ í…ŒìŠ¤íŠ¸."""
    # 20MB + 1 byte
    large_content = b"a" * (20 * 1024 * 1024 + 1)
    files = {"file": ("large.png", large_content, "image/png")}

    response = client.post("/api/scan", files=files)

    assert response.status_code == 200
    res_data = response.json()
    assert res_data["success"] is False
    assert "íŒŒì¼ì´ ë„ˆë¬´ í½ë‹ˆë‹¤" in res_data["message"]
</file>

<file path="backend/tests/manual_test_image.py">
"""Unknown World - ì´ë¯¸ì§€ ìƒì„± API ìˆ˜ë™ ê²€ì¦ ìŠ¤í¬ë¦½íŠ¸."""

import json
import os

from fastapi.testclient import TestClient

from unknown_world.main import app


def run_manual_test():
    # UW_MODEë¥¼ mockìœ¼ë¡œ ê°•ì œ ì„¤ì •í•˜ì—¬ API í˜¸ì¶œ ì—†ì´ ë¡œì§ ê²€ì¦
    os.environ["UW_MODE"] = "mock"
    client = TestClient(app)

    print("=== [1] ì´ë¯¸ì§€ ìƒì„± ìš”ì²­ í…ŒìŠ¤íŠ¸ ===")
    payload = {
        "prompt": "A retro-future computer terminal with green text",
        "aspect_ratio": "1:1",
        "image_size": "1024x1024",
    }

    response = client.post("/api/image/generate", json=payload)
    print(f"Status Code: {response.status_code}")
    print(f"Response: {json.dumps(response.json(), indent=2, ensure_ascii=False)}")

    if response.status_code == 200:
        data = response.json()
        image_url = data["image_url"]
        image_id = data["image_id"]

        print(f"\n=== [2] ì •ì  íŒŒì¼ ì„œë¹™ í…ŒìŠ¤íŠ¸ ({image_url}) ===")
        static_resp = client.get(image_url)
        print(f"Static Content-Type: {static_resp.headers.get('content-type')}")
        print(f"Static Success: {static_resp.status_code == 200}")

        print(f"\n=== [3] ì´ë¯¸ì§€ ìƒíƒœ ì¡°íšŒ í…ŒìŠ¤íŠ¸ ({image_id}) ===")
        status_resp = client.get(f"/api/image/status/{image_id}")
        print(f"Status Response: {json.dumps(status_resp.json(), indent=2, ensure_ascii=False)}")

        print(f"\n=== [4] ì´ë¯¸ì§€ íŒŒì¼ ì§ì ‘ ì¡°íšŒ í…ŒìŠ¤íŠ¸ (/api/image/file/{image_id}) ===")
        file_resp = client.get(f"/api/image/file/{image_id}")
        print(f"File Content-Type: {file_resp.headers.get('content-type')}")
        print(f"File Success: {file_resp.status_code == 200}")


if __name__ == "__main__":
    run_manual_test()
</file>

<file path="backend/tests/manual_test_rembg.py">
#!/usr/bin/env python3
"""U-035 rembg ë°°ê²½ ì œê±° í†µí•© ìˆ˜ë™ í…ŒìŠ¤íŠ¸ ìŠ¤í¬ë¦½íŠ¸.

ì´ ìŠ¤í¬ë¦½íŠ¸ëŠ” image_postprocess ëª¨ë“ˆì˜ ê¸°ëŠ¥ì„ í…ŒìŠ¤íŠ¸í•©ë‹ˆë‹¤.
ì‹¤í–‰: cd backend && python tests/manual_test_rembg.py
"""

from __future__ import annotations

import sys
from pathlib import Path

# í”„ë¡œì íŠ¸ ë£¨íŠ¸ë¥¼ Python ê²½ë¡œì— ì¶”ê°€
project_root = Path(__file__).parent.parent / "src"
sys.path.insert(0, str(project_root))


def test_model_selection():
    """ì´ë¯¸ì§€ ìœ í˜• íŒíŠ¸ì— ë”°ë¥¸ ëª¨ë¸ ì„ íƒ í…ŒìŠ¤íŠ¸."""
    from unknown_world.services.image_postprocess import (
        RembgModel,
        select_model_from_hint,
    )

    print("=" * 60)
    print("í…ŒìŠ¤íŠ¸ 1: ëª¨ë¸ ì„ íƒ ë¡œì§")
    print("=" * 60)

    test_cases = [
        (None, RembgModel.BIREFNET_GENERAL, False),
        ("object", RembgModel.BIREFNET_GENERAL, False),
        ("icon", RembgModel.BIREFNET_GENERAL, False),
        ("character", RembgModel.ISNET_ANIME, False),
        ("anime", RembgModel.ISNET_ANIME, False),
        ("portrait", RembgModel.BIREFNET_PORTRAIT, True),
        ("human", RembgModel.U2NET_HUMAN_SEG, True),
        ("unknown_type", RembgModel.BIREFNET_GENERAL, False),
    ]

    all_passed = True
    for hint, expected_model, expected_alpha in test_cases:
        model, alpha = select_model_from_hint(hint)
        passed = model == expected_model and alpha == expected_alpha
        status = "[OK]" if passed else "[NG]"
        if not passed:
            all_passed = False
        print(f"  {status} hint='{hint}' -> model={model.value}, alpha={alpha}")
        print(f"      (expected: {expected_model.value}, {expected_alpha})")

    return all_passed


def test_postprocessor_availability():
    """ImagePostprocessor ì‚¬ìš© ê°€ëŠ¥ ì—¬ë¶€ í…ŒìŠ¤íŠ¸."""
    from unknown_world.services.image_postprocess import get_image_postprocessor

    print()
    print("=" * 60)
    print("í…ŒìŠ¤íŠ¸ 2: rembg ì‚¬ìš© ê°€ëŠ¥ ì—¬ë¶€")
    print("=" * 60)

    postprocessor = get_image_postprocessor()
    available = postprocessor.is_available()
    status = "[OK]" if available else "[WARN]"
    print(f"  {status} rembg available: {available}")

    if not available:
        print("  [WARN] rembg is not installed. Install: pip install rembg")
        return False

    return True


def test_image_generation_request():
    """ImageGenerationRequestì— ìƒˆ í•„ë“œê°€ ì¶”ê°€ë˜ì—ˆëŠ”ì§€ í™•ì¸."""
    from unknown_world.services.image_generation import ImageGenerationRequest

    print()
    print("=" * 60)
    print("í…ŒìŠ¤íŠ¸ 3: ImageGenerationRequest ìŠ¤í‚¤ë§ˆ í™•ì¥")
    print("=" * 60)

    # ìƒˆ í•„ë“œë¡œ ì¸ìŠ¤í„´ìŠ¤ ìƒì„± í…ŒìŠ¤íŠ¸
    request = ImageGenerationRequest(
        prompt="A magical sword with glowing runes",
        remove_background=True,
        image_type_hint="object",
    )

    checks = [
        ("remove_background í•„ë“œ", hasattr(request, "remove_background")),
        ("image_type_hint í•„ë“œ", hasattr(request, "image_type_hint")),
        ("remove_background=True", request.remove_background is True),
        ("image_type_hint='object'", request.image_type_hint == "object"),
    ]

    all_passed = True
    for desc, passed in checks:
        status = "[OK]" if passed else "[NG]"
        if not passed:
            all_passed = False
        print(f"  {status} {desc}")

    return all_passed


def test_image_job_schema():
    """ImageJob ìŠ¤í‚¤ë§ˆì— ìƒˆ í•„ë“œê°€ ì¶”ê°€ë˜ì—ˆëŠ”ì§€ í™•ì¸."""
    from unknown_world.models.turn import ImageJob

    print()
    print("=" * 60)
    print("í…ŒìŠ¤íŠ¸ 4: ImageJob ìŠ¤í‚¤ë§ˆ í™•ì¥ (TurnOutput.render.image_job)")
    print("=" * 60)

    # ìƒˆ í•„ë“œë¡œ ì¸ìŠ¤í„´ìŠ¤ ìƒì„± í…ŒìŠ¤íŠ¸
    image_job = ImageJob(
        should_generate=True,
        prompt="A glowing crystal",
        remove_background=True,
        image_type_hint="object",
    )

    checks = [
        ("remove_background í•„ë“œ", hasattr(image_job, "remove_background")),
        ("image_type_hint í•„ë“œ", hasattr(image_job, "image_type_hint")),
        ("remove_background=True", image_job.remove_background is True),
        ("image_type_hint='object'", image_job.image_type_hint == "object"),
    ]

    all_passed = True
    for desc, passed in checks:
        status = "[OK]" if passed else "[NG]"
        if not passed:
            all_passed = False
        print(f"  {status} {desc}")

    return all_passed


def main():
    """ëª¨ë“  í…ŒìŠ¤íŠ¸ ì‹¤í–‰."""
    print()
    print("[TEST] U-035 rembg Background Removal Integration Test")
    print("=" * 60)

    results = []

    try:
        results.append(("Model Selection Logic", test_model_selection()))
    except Exception as e:
        print(f"  [NG] Model selection test error: {e}")
        results.append(("Model Selection Logic", False))

    try:
        results.append(("rembg Availability", test_postprocessor_availability()))
    except Exception as e:
        print(f"  [NG] rembg availability test error: {e}")
        results.append(("rembg Availability", False))

    try:
        results.append(("ImageGenerationRequest Schema", test_image_generation_request()))
    except Exception as e:
        print(f"  [NG] ImageGenerationRequest test error: {e}")
        results.append(("ImageGenerationRequest Schema", False))

    try:
        results.append(("ImageJob Schema", test_image_job_schema()))
    except Exception as e:
        print(f"  [NG] ImageJob test error: {e}")
        results.append(("ImageJob Schema", False))

    # ê²°ê³¼ ìš”ì•½
    print()
    print("=" * 60)
    print("[SUMMARY] Test Results")
    print("=" * 60)

    all_passed = True
    for name, passed in results:
        status = "[PASS]" if passed else "[FAIL]"
        if not passed:
            all_passed = False
        print(f"  {status}: {name}")

    print()
    if all_passed:
        print("[OK] All tests passed!")
        return 0
    else:
        print("[ERROR] Some tests failed")
        return 1


if __name__ == "__main__":
    sys.exit(main())
</file>

<file path="backend/tests/qa/test_asset_manifest.py">
import json
import os

import pytest
from jsonschema import validate

# Paths
# This file is in backend/tests/qa/
# We go up 3 levels to get to backend root: backend/tests/qa -> backend/tests -> backend -> root (wait, backend is in root)
# Actually:
# __file__ = D:\Dev\unknown-world\backend\tests\qa\test_asset_manifest.py
# os.path.dirname(__file__) = D:\Dev\unknown-world\backend\tests\qa
# ... up 1 = tests
# ... up 2 = backend
# ... up 3 = unknown-world (project root)

CURRENT_DIR = os.path.dirname(os.path.abspath(__file__))
PROJECT_ROOT = os.path.dirname(os.path.dirname(os.path.dirname(CURRENT_DIR)))

# If PROJECT_ROOT is correct, it should contain frontend/
FRONTEND_UI_DIR = os.path.join(PROJECT_ROOT, "frontend", "public", "ui")
MANIFEST_PATH = os.path.join(FRONTEND_UI_DIR, "manifest.json")
SCHEMA_PATH = os.path.join(FRONTEND_UI_DIR, "manifest.schema.json")


def test_manifest_schema_validation():
    """Validates manifest.json against manifest.schema.json"""
    if not os.path.exists(MANIFEST_PATH):
        pytest.fail(f"Manifest not found at {MANIFEST_PATH}")
    if not os.path.exists(SCHEMA_PATH):
        pytest.fail(f"Schema not found at {SCHEMA_PATH}")

    with open(MANIFEST_PATH, encoding="utf-8") as f:
        manifest = json.load(f)

    with open(SCHEMA_PATH, encoding="utf-8") as f:
        schema = json.load(f)

    # validate raises ValidationError on failure
    validate(instance=manifest, schema=schema)


def test_asset_files_existence_and_size():
    """Checks if assets listed in manifest exist and sizes match/budget"""
    with open(MANIFEST_PATH, encoding="utf-8") as f:
        manifest = json.load(f)

    assets = manifest.get("assets", [])
    total_bytes_calculated = 0

    for asset in assets:
        rel_path = asset["path"]
        abs_path = os.path.join(FRONTEND_UI_DIR, rel_path)

        # 1. Existence Check
        assert os.path.exists(abs_path), f"Asset file missing: {rel_path} (full: {abs_path})"

        # 2. Size Check
        actual_size = os.path.getsize(abs_path)
        recorded_size = asset.get("bytes")

        # Note: If size mismatches, we print a helpful message.
        # In a real QA scenario, we might want to auto-update, but for this test we fail.
        if recorded_size is not None:
            assert actual_size == recorded_size, (
                f"Size mismatch for {rel_path}: actual {actual_size} != manifest {recorded_size}"
            )

        total_bytes_calculated += actual_size

        # 3. Individual Budget Check (from QA_CHECKLIST.md)
        asset_type = asset["type"]
        if asset_type == "icon":
            # 30KB limit
            assert actual_size <= 30 * 1024, (
                f"Icon {rel_path} exceeds 30KB budget ({actual_size} bytes)"
            )
        elif asset_type == "placeholder":
            # 300KB limit
            assert actual_size <= 300 * 1024, (
                f"Placeholder {rel_path} exceeds 300KB budget ({actual_size} bytes)"
            )
        elif asset_type == "chrome":
            # 120KB limit (increased for scanner-frame)
            assert actual_size <= 120 * 1024, (
                f"Chrome asset {rel_path} exceeds 120KB budget ({actual_size} bytes)"
            )

    # 4. Total Budget Check
    recorded_total = manifest.get("totalBytes")
    if recorded_total is not None:
        assert total_bytes_calculated == recorded_total, (
            f"Total bytes mismatch: calculated {total_bytes_calculated} != manifest {recorded_total}"
        )

    budget_total = manifest.get("budgetBytes", 1572864)
    assert total_bytes_calculated <= budget_total, (
        f"Total size {total_bytes_calculated} exceeds budget {budget_total}"
    )


def test_asset_naming_convention():
    """Checks if asset IDs and paths use kebab-case"""
    with open(MANIFEST_PATH, encoding="utf-8") as f:
        manifest = json.load(f)

    for asset in manifest["assets"]:
        asset_id = asset["id"]
        # Check for lowercase and kebab-case (allow numbers)
        assert asset_id.islower(), f"Asset ID {asset_id} should be lowercase"
        assert " " not in asset_id, f"Asset ID {asset_id} should not contain spaces"
        assert "_" not in asset_id, (
            f"Asset ID {asset_id} should not contain underscores (use kebab-case)"
        )
</file>

<file path="backend/tests/unit/api/test_image.py">
"""Unknown World - ì´ë¯¸ì§€ ìƒì„± API ì—”ë“œí¬ì¸íŠ¸ ë‹¨ìœ„ í…ŒìŠ¤íŠ¸."""

import pytest
from fastapi.testclient import TestClient

from unknown_world.main import app
from unknown_world.services.image_generation import (
    ImageGenerationStatus,
    get_image_generator,
    reset_image_generator,
)


@pytest.fixture
def client():
    """FastAPI TestClient í”½ìŠ¤ì²˜."""
    return TestClient(app)


@pytest.fixture(autouse=True)
def setup_mock_generator():
    """ëª¨ë“  í…ŒìŠ¤íŠ¸ì—ì„œ Mock ìƒì„±ê¸°ë¥¼ ì‚¬ìš©í•˜ë„ë¡ ì„¤ì •."""
    reset_image_generator()
    get_image_generator(force_mock=True)
    yield
    reset_image_generator()


def test_generate_image_success(client):
    """ì´ë¯¸ì§€ ìƒì„± ì„±ê³µ ì¼€ì´ìŠ¤ í…ŒìŠ¤íŠ¸."""
    payload = {
        "prompt": "A futuristic laboratory with glowing screens",
        "aspect_ratio": "1:1",
        "image_size": "1024x1024",
        "skip_on_failure": True,
    }

    response = client.post("/api/image/generate", json=payload)

    assert response.status_code == 200
    data = response.json()
    assert data["success"] is True
    assert data["status"] == ImageGenerationStatus.COMPLETED
    assert data["image_id"] is not None
    assert data["image_url"] is not None


def test_generate_image_validation_error(client):
    """ì´ë¯¸ì§€ ìƒì„± ìš”ì²­ ê²€ì¦ ì‹¤íŒ¨ í…ŒìŠ¤íŠ¸."""
    # ë„ˆë¬´ ì§§ì€ í”„ë¡¬í”„íŠ¸
    payload = {"prompt": "A", "skip_on_failure": False}

    response = client.post("/api/image/generate", json=payload)

    assert response.status_code == 400
    assert "í”„ë¡¬í”„íŠ¸ê°€ ë„ˆë¬´ ì§§ìŠµë‹ˆë‹¤" in response.json()["detail"]


def test_generate_image_fallback_on_error(client):
    """ê²€ì¦ ì‹¤íŒ¨ ì‹œ skip_on_failure=Trueì¼ ë•Œ í´ë°± ë™ì‘ í…ŒìŠ¤íŠ¸."""
    payload = {"prompt": "A", "skip_on_failure": True}

    response = client.post("/api/image/generate", json=payload)

    assert response.status_code == 200
    data = response.json()
    assert data["success"] is False
    assert data["status"] == "skipped"
    assert "í”„ë¡¬í”„íŠ¸ê°€ ë„ˆë¬´ ì§§ìŠµë‹ˆë‹¤" in data["message"]


def test_get_image_status(client):
    """ì´ë¯¸ì§€ ìƒíƒœ ì¡°íšŒ í…ŒìŠ¤íŠ¸."""
    # ë¨¼ì € ìƒì„±
    gen_resp = client.post("/api/image/generate", json={"prompt": "Test status"})
    image_id = gen_resp.json()["image_id"]

    # ìƒíƒœ ì¡°íšŒ
    status_resp = client.get(f"/api/image/status/{image_id}")
    assert status_resp.status_code == 200
    assert status_resp.json()["exists"] is True
    assert status_resp.json()["image_url"] is not None


def test_static_image_access(client):
    """ì •ì  íŒŒì¼ ê²½ë¡œë¥¼ í†µí•œ ì´ë¯¸ì§€ ì ‘ê·¼ í…ŒìŠ¤íŠ¸."""
    # ì´ë¯¸ì§€ ìƒì„±
    gen_resp = client.post("/api/image/generate", json={"prompt": "Test static access"})
    image_url = gen_resp.json()["image_url"]

    # ì •ì  ê²½ë¡œë¡œ ì ‘ê·¼
    response = client.get(image_url)
    assert response.status_code == 200
    assert response.headers["content-type"] == "image/png"


def test_get_image_file_not_found(client):
    """ì¡´ì¬í•˜ì§€ ì•ŠëŠ” ì´ë¯¸ì§€ íŒŒì¼ ìš”ì²­ ì‹œ 404 í…ŒìŠ¤íŠ¸."""
    response = client.get("/api/image/file/non_existent_id")
    assert response.status_code == 404
</file>

<file path="backend/tests/unit/models/test_turn.py">
"""TurnInput/TurnOutput ëª¨ë¸ ë‹¨ìœ„ í…ŒìŠ¤íŠ¸."""

import pytest
from pydantic import ValidationError

from unknown_world.models.turn import (
    AgentConsole,
    Box2D,
    CurrencyAmount,
    EconomyOutput,
    Language,
    RenderOutput,
    TurnInput,
    TurnOutput,
    UIOutput,
    WorldDelta,
)

# =============================================================================
# Fixtures
# =============================================================================


@pytest.fixture
def valid_box_2d():
    return {"ymin": 100, "xmin": 200, "ymax": 300, "xmax": 400}


@pytest.fixture
def valid_currency_amount():
    return {"signal": 100, "memory_shard": 5}


@pytest.fixture
def valid_client_info():
    return {"viewport_w": 1920, "viewport_h": 1080, "theme": "dark"}


@pytest.fixture
def valid_turn_input_data(valid_client_info, valid_currency_amount):
    return {
        "language": "ko-KR",
        "text": "Hello",
        "client": valid_client_info,
        "economy_snapshot": valid_currency_amount,
    }


@pytest.fixture
def valid_turn_output_data(valid_currency_amount):
    return {
        "language": "ko-KR",
        "narrative": "Story continues...",
        "economy": {
            "cost": {"signal": 10, "memory_shard": 0},
            "balance_after": {"signal": 90, "memory_shard": 5},
        },
        "safety": {"blocked": False},
    }


# =============================================================================
# Coordinate & Box2D Tests
# =============================================================================


def test_box_2d_valid(valid_box_2d):
    box = Box2D(**valid_box_2d)
    assert box.ymin == 100
    assert box.xmax == 400


def test_box_2d_invalid_coordinate():
    with pytest.raises(ValidationError):
        # Out of range (ge=0, le=1000)
        Box2D(ymin=-1, xmin=0, ymax=1001, xmax=500)


def test_box_2d_extra_forbidden():
    with pytest.raises(ValidationError):
        Box2D(ymin=0, xmin=0, ymax=100, xmax=100, extra_field="not allowed")


# =============================================================================
# Currency & Economy Tests
# =============================================================================


def test_currency_amount_valid(valid_currency_amount):
    amount = CurrencyAmount(**valid_currency_amount)
    assert amount.signal == 100


def test_currency_amount_negative_fails():
    with pytest.raises(ValidationError):
        CurrencyAmount(signal=-1, memory_shard=0)


def test_economy_output_valid():
    data = {
        "cost": {"signal": 5, "memory_shard": 0},
        "balance_after": {"signal": 95, "memory_shard": 5},
    }
    economy = EconomyOutput(**data)
    assert economy.cost.signal == 5
    assert economy.balance_after.signal == 95


# =============================================================================
# TurnInput Tests
# =============================================================================


def test_turn_input_valid(valid_turn_input_data):
    turn_input = TurnInput(**valid_turn_input_data)
    assert turn_input.language == Language.KO
    assert turn_input.text == "Hello"


def test_turn_input_with_click(valid_turn_input_data, valid_box_2d):
    data = valid_turn_input_data.copy()
    data["click"] = {"object_id": "door_01", "box_2d": valid_box_2d}
    turn_input = TurnInput(**data)
    assert turn_input.click.object_id == "door_01"
    assert turn_input.click.box_2d.ymin == 100


def test_turn_input_invalid_language():
    with pytest.raises(ValidationError):
        TurnInput(
            language="fr-FR",  # Not in Language enum
            text="...",
            client={"viewport_w": 800, "viewport_h": 600},
            economy_snapshot={"signal": 0, "memory_shard": 0},
        )


# =============================================================================
# TurnOutput Tests
# =============================================================================


def test_turn_output_valid_minimal(valid_turn_output_data):
    turn_output = TurnOutput(**valid_turn_output_data)
    assert turn_output.language == Language.KO
    assert turn_output.narrative == "Story continues..."
    # Check defaults
    assert isinstance(turn_output.ui, UIOutput)
    assert isinstance(turn_output.world, WorldDelta)
    assert isinstance(turn_output.render, RenderOutput)
    assert isinstance(turn_output.agent_console, AgentConsole)


def test_turn_output_full(valid_currency_amount, valid_box_2d):
    data = {
        "language": "en-US",
        "narrative": "Narrative text",
        "ui": {
            "action_deck": {
                "cards": [
                    {
                        "id": "c1",
                        "label": "Action 1",
                        "cost": {"signal": 5, "memory_shard": 0},
                    }
                ]
            },
            "objects": [{"id": "obj1", "label": "Object 1", "box_2d": valid_box_2d}],
        },
        "world": {
            "inventory_added": ["key"],
            "rules_changed": [{"id": "r1", "label": "Gravity", "description": "Low gravity"}],
            "quests_updated": [{"id": "q1", "label": "Find key", "is_completed": False}],
            "memory_pins": [
                {"id": "p1", "content": "Fact", "cost": {"signal": 1, "memory_shard": 0}}
            ],
        },
        "render": {
            "image_job": {
                "should_generate": True,
                "prompt": "A landscape",
                "model_label": "QUALITY",
            }
        },
        "economy": {
            "cost": {"signal": 10, "memory_shard": 0},
            "balance_after": {"signal": 90, "memory_shard": 5},
        },
        "safety": {"blocked": False},
        "agent_console": {"repair_count": 1, "badges": ["schema_ok", "economy_ok"]},
    }
    turn_output = TurnOutput(**data)
    assert turn_output.language == Language.EN
    assert len(turn_output.ui.action_deck.cards) == 1
    assert turn_output.render.image_job.should_generate is True


def test_turn_output_missing_required():
    with pytest.raises(ValidationError):
        # Missing economy and safety
        TurnOutput(language="ko-KR", narrative="...")


# =============================================================================
# JSON Schema Tests
# =============================================================================


def test_turn_output_json_schema():
    schema = TurnOutput.model_json_schema()
    assert schema["type"] == "object"
    assert "language" in schema["required"]
    assert "narrative" in schema["required"]
    assert "economy" in schema["required"]
    assert "safety" in schema["required"]

    # Check Coordinate constraints in schema
    # Pydantic 2 schema structure: properties -> language -> ...
    # Coordinate might be in $defs or inline depending on how it's used
    ui_props = schema["$defs"]["UIOutput"]["properties"]
    assert "action_deck" in ui_props

    # Verify that Coordinate (int with ge/le) is correctly represented
    # Box2D uses Coordinate
    box_props = schema["$defs"]["Box2D"]["properties"]
    assert box_props["ymin"]["maximum"] == 1000
    assert box_props["ymin"]["minimum"] == 0
</file>

<file path="backend/tests/unit/orchestrator/test_generate_turn_output.py">
"""Unknown World - TurnOutputGenerator ë‹¨ìœ„ í…ŒìŠ¤íŠ¸.

U-017[Mvp] ì™„ë£Œ ê¸°ì¤€ ê²€ì¦:
    - Structured Outputs í˜¸ì¶œ êµ¬ì„± (application/json, response_schema)
    - Pydantic ê²€ì¦ (model_validate_json)
    - ì‹¤íŒ¨ ë¶„ê¸° ì²˜ë¦¬ (SCHEMA_FAILURE)
    - language ì •ì±… ì¤€ìˆ˜
"""

import json
from unittest.mock import AsyncMock, patch

import pytest

from unknown_world.models.turn import (
    ClientInfo,
    CurrencyAmount,
    EconomySnapshot,
    Language,
    Theme,
    TurnInput,
    TurnOutput,
)
from unknown_world.orchestrator.generate_turn_output import (
    GenerationStatus,
    TurnOutputGenerator,
)
from unknown_world.services.genai_client import GenerateResponse


@pytest.fixture
def turn_input() -> TurnInput:
    """ê¸°ë³¸ í„´ ì…ë ¥ í”½ìŠ¤ì²˜."""
    return TurnInput(
        language=Language.KO,
        text="ë¬¸ì„ ì—´ì–´ë³¸ë‹¤",
        client=ClientInfo(viewport_w=1920, viewport_h=1080, theme=Theme.DARK),
        economy_snapshot=EconomySnapshot(signal=100, memory_shard=5),
    )


@pytest.fixture
def valid_turn_output_json() -> str:
    """ìœ íš¨í•œ TurnOutput JSON ë¬¸ìì—´ í”½ìŠ¤ì²˜."""
    return json.dumps(
        {
            "language": "ko-KR",
            "narrative": "ë‚¡ì€ ë¬¸ì´ ì—´ë¦¬ê³  ë¨¼ì§€ê°€ ë‚ ë¦½ë‹ˆë‹¤.",
            "economy": {
                "cost": {"signal": 5, "memory_shard": 0},
                "balance_after": {"signal": 95, "memory_shard": 5},
            },
            "safety": {"blocked": False, "message": None},
            "ui": {"action_deck": {"cards": []}, "objects": []},
            "world": {
                "rules_changed": [],
                "inventory_added": [],
                "inventory_removed": [],
                "quests_updated": [],
                "memory_pins": [],
            },
            "render": {"image_job": None},
            "agent_console": {
                "current_phase": "commit",
                "badges": ["schema_ok", "economy_ok", "safety_ok"],
                "repair_count": 0,
            },
        }
    )


@pytest.mark.asyncio
async def test_generate_success(turn_input, valid_turn_output_json):
    """ì„±ê³µì ì¸ ìƒì„± ë° Pydantic ê²€ì¦ í…ŒìŠ¤íŠ¸."""
    generator = TurnOutputGenerator(force_mock=True)

    # Mock GenAIClient.generate
    mock_response = GenerateResponse(text=valid_turn_output_json, model_label="fast")

    with patch(
        "unknown_world.orchestrator.generate_turn_output.get_genai_client"
    ) as mock_get_client:
        mock_client = AsyncMock()
        mock_client.generate.return_value = mock_response
        mock_get_client.return_value = mock_client

        result = await generator.generate(turn_input)

        assert result.status == GenerationStatus.SUCCESS
        assert isinstance(result.output, TurnOutput)
        assert result.output.narrative == "ë‚¡ì€ ë¬¸ì´ ì—´ë¦¬ê³  ë¨¼ì§€ê°€ ë‚ ë¦½ë‹ˆë‹¤."
        assert result.output.language == Language.KO

        # API í˜¸ì¶œ ì¸ì ê²€ì¦ (Structured Outputs ì„¤ì • í™•ì¸)
        call_args = mock_client.generate.call_args[0][0]
        assert call_args.response_mime_type == "application/json"
        assert call_args.response_schema is not None
        assert "narrative" in call_args.response_schema["properties"]


@pytest.mark.asyncio
async def test_generate_schema_validation_failure(turn_input):
    """Pydantic ê²€ì¦ ì‹¤íŒ¨(SCHEMA_FAILURE) í…ŒìŠ¤íŠ¸."""
    generator = TurnOutputGenerator(force_mock=True)

    # í•„ìˆ˜ í•„ë“œ(narrative)ê°€ ëˆ„ë½ëœ ì˜ëª»ëœ JSON
    invalid_json = json.dumps(
        {
            "language": "ko-KR",
            # "narrative" í•„ë“œ ëˆ„ë½
            "economy": {
                "cost": {"signal": 5, "memory_shard": 0},
                "balance_after": {"signal": 95, "memory_shard": 5},
            },
            "safety": {"blocked": False, "message": None},
        }
    )

    mock_response = GenerateResponse(text=invalid_json, model_label="fast")

    with patch(
        "unknown_world.orchestrator.generate_turn_output.get_genai_client"
    ) as mock_get_client:
        mock_client = AsyncMock()
        mock_client.generate.return_value = mock_response
        mock_get_client.return_value = mock_client

        result = await generator.generate(turn_input)

        assert result.status == GenerationStatus.SCHEMA_FAILURE
        assert result.output is None
        assert "validation_errors" in result.error_details


@pytest.mark.asyncio
async def test_generate_json_decode_error(turn_input):
    """JSON íŒŒì‹± ì‹¤íŒ¨ í…ŒìŠ¤íŠ¸."""
    generator = TurnOutputGenerator(force_mock=True)

    # ìœ íš¨í•˜ì§€ ì•Šì€ JSON í˜•ì‹
    invalid_text = "ì´ê²ƒì€ JSONì´ ì•„ë‹™ë‹ˆë‹¤ { narrative: ... "

    mock_response = GenerateResponse(text=invalid_text, model_label="fast")

    with patch(
        "unknown_world.orchestrator.generate_turn_output.get_genai_client"
    ) as mock_get_client:
        mock_client = AsyncMock()
        mock_client.generate.return_value = mock_response
        mock_get_client.return_value = mock_client

        result = await generator.generate(turn_input)

        assert result.status == GenerationStatus.SCHEMA_FAILURE
        # Pydantic model_validate_jsonì€ JSON íŒŒì‹± ì‹¤íŒ¨ë„ ValidationError(type=json_invalid)ë¡œ ë³´ê³ í•¨
        errors = result.error_details.get("validation_errors", [])
        assert any(err["type"] == "json_invalid" for err in errors)


@pytest.mark.asyncio
async def test_generate_markdown_json_extraction(turn_input, valid_turn_output_json):
    """ë§ˆí¬ë‹¤ìš´ ì½”ë“œ ë¸”ë¡ ë‚´ì˜ JSON ì¶”ì¶œ í…ŒìŠ¤íŠ¸."""
    generator = TurnOutputGenerator(force_mock=True)

    # ë§ˆí¬ë‹¤ìš´ ì½”ë“œ ë¸”ë¡ìœ¼ë¡œ ê°ì‹¸ì§„ ì‘ë‹µ
    markdown_text = f"```json\n{valid_turn_output_json}\n```"

    mock_response = GenerateResponse(text=markdown_text, model_label="fast")

    with patch(
        "unknown_world.orchestrator.generate_turn_output.get_genai_client"
    ) as mock_get_client:
        mock_client = AsyncMock()
        mock_client.generate.return_value = mock_response
        mock_get_client.return_value = mock_client

        result = await generator.generate(turn_input)

        assert result.status == GenerationStatus.SUCCESS
        assert result.output.narrative == "ë‚¡ì€ ë¬¸ì´ ì—´ë¦¬ê³  ë¨¼ì§€ê°€ ë‚ ë¦½ë‹ˆë‹¤."


@pytest.mark.asyncio
async def test_generate_api_error(turn_input):
    """API í˜¸ì¶œ ì—ëŸ¬ ì²˜ë¦¬ í…ŒìŠ¤íŠ¸."""
    generator = TurnOutputGenerator(force_mock=True)

    with patch(
        "unknown_world.orchestrator.generate_turn_output.get_genai_client"
    ) as mock_get_client:
        mock_client = AsyncMock()
        mock_client.generate.side_effect = RuntimeError("API connection failed")
        mock_get_client.return_value = mock_client

        result = await generator.generate(turn_input)

        assert result.status == GenerationStatus.API_ERROR
        assert "API connection failed" in result.error_details["api_error"]


def test_create_safe_fallback():
    """ì•ˆì „í•œ í´ë°± ìƒì„± í…ŒìŠ¤íŠ¸ (RULE-004)."""
    generator = TurnOutputGenerator()

    economy_snapshot = CurrencyAmount(signal=80, memory_shard=3)
    fallback = generator.create_safe_fallback(
        language=Language.KO, error_message="Test Error", economy_snapshot=economy_snapshot
    )

    assert isinstance(fallback, TurnOutput)
    assert fallback.language == Language.KO
    assert fallback.economy.cost.signal == 0
    assert fallback.economy.balance_after.signal == 80
    assert "í˜¼ë€ìŠ¤ëŸ¬ìš´" in fallback.narrative
</file>

<file path="backend/tests/unit/orchestrator/test_mock_orchestrator.py">
"""Unknown World - MockOrchestrator ë‹¨ìœ„ í…ŒìŠ¤íŠ¸.

U-048[Mvp] ì™„ë£Œ ê¸°ì¤€ ê²€ì¦:
    - action_id ì…ë ¥ ì‹œ "ë§í–ˆìŠµë‹ˆë‹¤" ëŒ€ì‹  í–‰ë™ ë¡œê·¸ í”„ë¦¬í”½ìŠ¤ ì ìš©
    - click ì…ë ¥ ì‹œ ì¡°ì‚¬/íƒìƒ‰ í–‰ë™ ë¡œê·¸ í”„ë¦¬í”½ìŠ¤ ì ìš©
    - drop ì…ë ¥ ì‹œ ì‚¬ìš©/ì¡°í•© í–‰ë™ ë¡œê·¸ í”„ë¦¬í”½ìŠ¤ ì ìš©
    - free text ì…ë ¥ ì‹œ ì…ë ¥/ëª…ë ¹ í–‰ë™ ë¡œê·¸ í”„ë¦¬í”½ìŠ¤ ì ìš© (Q1: Option B)
    - per-turn ê²°ì •ì  RNGë¡œ ë‹¤ì–‘ì„± í™•ë³´ (ë‹¤ë¥¸ ì…ë ¥ â†’ ë‹¤ë¥¸ ê²°ê³¼)
    - ë™ì¼ ì…ë ¥ â†’ ë™ì¼ ê²°ê³¼ (ì¬í˜„ì„± ìœ ì§€)

ì°¸ì¡°:
    - vibe/unit-plans/U-048[Mvp].md
    - vibe/unit-runbooks/U-048-mock-narrative-improvement-runbook.md
"""

import random

import pytest

from unknown_world.models.turn import (
    Box2D,
    ClickInput,
    ClientInfo,
    DropInput,
    EconomySnapshot,
    Language,
    Theme,
    TurnInput,
    TurnOutput,
)
from unknown_world.orchestrator.mock import (
    EN_ACTION_LOG_PREFIXES,
    KO_ACTION_LOG_PREFIXES,
    InputType,
    MockOrchestrator,
    _compute_turn_seed,
    _detect_input_type,
    _format_action_log_prefix,
)

# =============================================================================
# í”½ìŠ¤ì²˜
# =============================================================================


@pytest.fixture
def base_client_info() -> ClientInfo:
    """ê¸°ë³¸ í´ë¼ì´ì–¸íŠ¸ ì •ë³´ í”½ìŠ¤ì²˜."""
    return ClientInfo(viewport_w=1920, viewport_h=1080, theme=Theme.DARK)


@pytest.fixture
def base_economy_snapshot() -> EconomySnapshot:
    """ê¸°ë³¸ ê²½ì œ ìŠ¤ëƒ…ìƒ· í”½ìŠ¤ì²˜."""
    return EconomySnapshot(signal=100, memory_shard=5)


@pytest.fixture
def ko_action_input(base_client_info, base_economy_snapshot) -> TurnInput:
    """í•œêµ­ì–´ ì•¡ì…˜ ì¹´ë“œ ì…ë ¥ í”½ìŠ¤ì²˜."""
    return TurnInput(
        language=Language.KO,
        text="ë¬¸ì„ ì—´ì–´ë³¸ë‹¤",
        action_id="action_1",
        client=base_client_info,
        economy_snapshot=base_economy_snapshot,
    )


@pytest.fixture
def ko_click_input(base_client_info, base_economy_snapshot) -> TurnInput:
    """í•œêµ­ì–´ í´ë¦­ ì…ë ¥ í”½ìŠ¤ì²˜."""
    return TurnInput(
        language=Language.KO,
        click=ClickInput(object_id="obj_door"),
        client=base_client_info,
        economy_snapshot=base_economy_snapshot,
    )


@pytest.fixture
def ko_drop_input(base_client_info, base_economy_snapshot) -> TurnInput:
    """í•œêµ­ì–´ ë“œë¡­ ì…ë ¥ í”½ìŠ¤ì²˜."""
    return TurnInput(
        language=Language.KO,
        drop=DropInput(
            item_id="key_001",
            target_object_id="obj_lock",
            target_box_2d=Box2D(ymin=100, xmin=200, ymax=300, xmax=400),
        ),
        client=base_client_info,
        economy_snapshot=base_economy_snapshot,
    )


@pytest.fixture
def ko_free_text_input(base_client_info, base_economy_snapshot) -> TurnInput:
    """í•œêµ­ì–´ ììœ  í…ìŠ¤íŠ¸ ì…ë ¥ í”½ìŠ¤ì²˜."""
    return TurnInput(
        language=Language.KO,
        text="ì£¼ë³€ì„ ì‚´í´ë³¸ë‹¤",
        client=base_client_info,
        economy_snapshot=base_economy_snapshot,
    )


@pytest.fixture
def en_action_input(base_client_info, base_economy_snapshot) -> TurnInput:
    """ì˜ì–´ ì•¡ì…˜ ì¹´ë“œ ì…ë ¥ í”½ìŠ¤ì²˜."""
    return TurnInput(
        language=Language.EN,
        text="Open the door",
        action_id="action_1",
        client=base_client_info,
        economy_snapshot=base_economy_snapshot,
    )


# =============================================================================
# _detect_input_type í…ŒìŠ¤íŠ¸
# =============================================================================


class TestDetectInputType:
    """ì…ë ¥ íƒ€ì… ê°ì§€ í•¨ìˆ˜ í…ŒìŠ¤íŠ¸."""

    def test_detect_drop_input(self, ko_drop_input):
        """drop ì…ë ¥ ê°ì§€ í…ŒìŠ¤íŠ¸ (ìµœê³  ìš°ì„ ìˆœìœ„)."""
        result = _detect_input_type(ko_drop_input)
        assert result == InputType.DROP

    def test_detect_click_input(self, ko_click_input):
        """click ì…ë ¥ ê°ì§€ í…ŒìŠ¤íŠ¸."""
        result = _detect_input_type(ko_click_input)
        assert result == InputType.CLICK

    def test_detect_action_input(self, ko_action_input):
        """action_id ì…ë ¥ ê°ì§€ í…ŒìŠ¤íŠ¸."""
        result = _detect_input_type(ko_action_input)
        assert result == InputType.ACTION

    def test_detect_free_text_input(self, ko_free_text_input):
        """free text ì…ë ¥ ê°ì§€ í…ŒìŠ¤íŠ¸."""
        result = _detect_input_type(ko_free_text_input)
        assert result == InputType.FREE_TEXT

    def test_priority_drop_over_click(self, base_client_info, base_economy_snapshot):
        """dropì´ clickë³´ë‹¤ ìš°ì„ ìˆœìœ„ê°€ ë†’ì€ì§€ í…ŒìŠ¤íŠ¸."""
        turn_input = TurnInput(
            language=Language.KO,
            drop=DropInput(
                item_id="key_001",
                target_object_id="obj_lock",
                target_box_2d=Box2D(ymin=100, xmin=200, ymax=300, xmax=400),
            ),
            click=ClickInput(object_id="obj_door"),
            client=base_client_info,
            economy_snapshot=base_economy_snapshot,
        )
        result = _detect_input_type(turn_input)
        assert result == InputType.DROP

    def test_priority_click_over_action(self, base_client_info, base_economy_snapshot):
        """clickì´ action_idë³´ë‹¤ ìš°ì„ ìˆœìœ„ê°€ ë†’ì€ì§€ í…ŒìŠ¤íŠ¸."""
        turn_input = TurnInput(
            language=Language.KO,
            click=ClickInput(object_id="obj_door"),
            action_id="action_1",
            text="ë¬¸ì„ ì—´ì–´ë³¸ë‹¤",
            client=base_client_info,
            economy_snapshot=base_economy_snapshot,
        )
        result = _detect_input_type(turn_input)
        assert result == InputType.CLICK

    def test_priority_action_over_free_text(self, ko_action_input):
        """action_idê°€ free textë³´ë‹¤ ìš°ì„ ìˆœìœ„ê°€ ë†’ì€ì§€ í…ŒìŠ¤íŠ¸."""
        # ko_action_inputì€ action_idì™€ text ë‘˜ ë‹¤ ìˆìŒ
        result = _detect_input_type(ko_action_input)
        assert result == InputType.ACTION


# =============================================================================
# _compute_turn_seed í…ŒìŠ¤íŠ¸
# =============================================================================


class TestComputeTurnSeed:
    """per-turn ì‹œë“œ ê³„ì‚° í•¨ìˆ˜ í…ŒìŠ¤íŠ¸."""

    def test_same_input_same_seed(self, ko_action_input):
        """ë™ì¼ ì…ë ¥ â†’ ë™ì¼ ì‹œë“œ (ì¬í˜„ì„±)."""
        base_seed = 42
        seed1 = _compute_turn_seed(base_seed, ko_action_input)
        seed2 = _compute_turn_seed(base_seed, ko_action_input)
        assert seed1 == seed2

    def test_different_text_different_seed(self, base_client_info, base_economy_snapshot):
        """ë‹¤ë¥¸ í…ìŠ¤íŠ¸ â†’ ë‹¤ë¥¸ ì‹œë“œ (ë‹¤ì–‘ì„±)."""
        base_seed = 42
        input1 = TurnInput(
            language=Language.KO,
            text="ë¬¸ì„ ì—´ì–´ë³¸ë‹¤",
            client=base_client_info,
            economy_snapshot=base_economy_snapshot,
        )
        input2 = TurnInput(
            language=Language.KO,
            text="ì£¼ë³€ì„ íƒìƒ‰í•œë‹¤",
            client=base_client_info,
            economy_snapshot=base_economy_snapshot,
        )
        seed1 = _compute_turn_seed(base_seed, input1)
        seed2 = _compute_turn_seed(base_seed, input2)
        assert seed1 != seed2

    def test_different_action_id_different_seed(self, base_client_info, base_economy_snapshot):
        """ë‹¤ë¥¸ action_id â†’ ë‹¤ë¥¸ ì‹œë“œ."""
        base_seed = 42
        input1 = TurnInput(
            language=Language.KO,
            action_id="action_1",
            client=base_client_info,
            economy_snapshot=base_economy_snapshot,
        )
        input2 = TurnInput(
            language=Language.KO,
            action_id="action_2",
            client=base_client_info,
            economy_snapshot=base_economy_snapshot,
        )
        seed1 = _compute_turn_seed(base_seed, input1)
        seed2 = _compute_turn_seed(base_seed, input2)
        assert seed1 != seed2

    def test_different_click_object_different_seed(self, base_client_info, base_economy_snapshot):
        """ë‹¤ë¥¸ í´ë¦­ ì˜¤ë¸Œì íŠ¸ â†’ ë‹¤ë¥¸ ì‹œë“œ."""
        base_seed = 42
        input1 = TurnInput(
            language=Language.KO,
            click=ClickInput(object_id="obj_door"),
            client=base_client_info,
            economy_snapshot=base_economy_snapshot,
        )
        input2 = TurnInput(
            language=Language.KO,
            click=ClickInput(object_id="obj_chest"),
            client=base_client_info,
            economy_snapshot=base_economy_snapshot,
        )
        seed1 = _compute_turn_seed(base_seed, input1)
        seed2 = _compute_turn_seed(base_seed, input2)
        assert seed1 != seed2

    def test_different_drop_different_seed(self, base_client_info, base_economy_snapshot):
        """ë‹¤ë¥¸ ë“œë¡­ ì •ë³´ â†’ ë‹¤ë¥¸ ì‹œë“œ."""
        base_seed = 42
        input1 = TurnInput(
            language=Language.KO,
            drop=DropInput(
                item_id="key_001",
                target_object_id="obj_lock",
                target_box_2d=Box2D(ymin=100, xmin=200, ymax=300, xmax=400),
            ),
            client=base_client_info,
            economy_snapshot=base_economy_snapshot,
        )
        input2 = TurnInput(
            language=Language.KO,
            drop=DropInput(
                item_id="sword_001",
                target_object_id="obj_enemy",
                target_box_2d=Box2D(ymin=100, xmin=200, ymax=300, xmax=400),
            ),
            client=base_client_info,
            economy_snapshot=base_economy_snapshot,
        )
        seed1 = _compute_turn_seed(base_seed, input1)
        seed2 = _compute_turn_seed(base_seed, input2)
        assert seed1 != seed2

    def test_seed_within_valid_range(self, ko_action_input):
        """ì‹œë“œê°€ ìœ íš¨í•œ ë²”ìœ„ ë‚´ì¸ì§€ í…ŒìŠ¤íŠ¸."""
        base_seed = 42
        seed = _compute_turn_seed(base_seed, ko_action_input)
        assert 0 <= seed < 2**32


# =============================================================================
# _format_action_log_prefix í…ŒìŠ¤íŠ¸
# =============================================================================


class TestFormatActionLogPrefix:
    """í–‰ë™ ë¡œê·¸ í”„ë¦¬í”½ìŠ¤ í¬ë§· í•¨ìˆ˜ í…ŒìŠ¤íŠ¸."""

    def test_ko_action_prefix(self, ko_action_input):
        """í•œêµ­ì–´ ì•¡ì…˜ í”„ë¦¬í”½ìŠ¤ í…ŒìŠ¤íŠ¸."""
        rng = random.Random(42)
        prefix = _format_action_log_prefix(rng, InputType.ACTION, ko_action_input, is_korean=True)

        # í•œêµ­ì–´ ì•¡ì…˜ í”„ë¦¬í”½ìŠ¤ ì¤‘ í•˜ë‚˜ì—¬ì•¼ í•¨
        expected_patterns = ["[í–‰ë™]", "[ì‹¤í–‰]", "[ì‹œë„]"]
        assert any(pattern in prefix for pattern in expected_patterns)
        # ì•¡ì…˜ í…ìŠ¤íŠ¸ê°€ í¬í•¨ë˜ì–´ì•¼ í•¨
        assert "ë¬¸ì„ ì—´ì–´ë³¸ë‹¤" in prefix

    def test_ko_click_prefix(self, ko_click_input):
        """í•œêµ­ì–´ í´ë¦­ í”„ë¦¬í”½ìŠ¤ í…ŒìŠ¤íŠ¸."""
        rng = random.Random(42)
        prefix = _format_action_log_prefix(rng, InputType.CLICK, ko_click_input, is_korean=True)

        expected_patterns = ["[ì¡°ì‚¬]", "[íƒìƒ‰]", "[ìƒí˜¸ì‘ìš©]"]
        assert any(pattern in prefix for pattern in expected_patterns)
        # ì˜¤ë¸Œì íŠ¸ IDê°€ í¬í•¨ë˜ì–´ì•¼ í•¨
        assert "obj_door" in prefix

    def test_ko_drop_prefix(self, ko_drop_input):
        """í•œêµ­ì–´ ë“œë¡­ í”„ë¦¬í”½ìŠ¤ í…ŒìŠ¤íŠ¸."""
        rng = random.Random(42)
        prefix = _format_action_log_prefix(rng, InputType.DROP, ko_drop_input, is_korean=True)

        expected_patterns = ["[ì‚¬ìš©]", "[ì¡°í•©]", "[ì ìš©]"]
        assert any(pattern in prefix for pattern in expected_patterns)
        # ì•„ì´í…œ IDì™€ ëŒ€ìƒ IDê°€ í¬í•¨ë˜ì–´ì•¼ í•¨
        assert "key_001" in prefix
        assert "obj_lock" in prefix

    def test_ko_free_text_prefix(self, ko_free_text_input):
        """í•œêµ­ì–´ ììœ  í…ìŠ¤íŠ¸ í”„ë¦¬í”½ìŠ¤ í…ŒìŠ¤íŠ¸."""
        rng = random.Random(42)
        prefix = _format_action_log_prefix(
            rng, InputType.FREE_TEXT, ko_free_text_input, is_korean=True
        )

        expected_patterns = ["[ì…ë ¥]", "[ëª…ë ¹]", "[ì§€ì‹œ]"]
        assert any(pattern in prefix for pattern in expected_patterns)
        # í…ìŠ¤íŠ¸ê°€ í¬í•¨ë˜ì–´ì•¼ í•¨
        assert "ì£¼ë³€ì„ ì‚´í´ë³¸ë‹¤" in prefix

    def test_en_action_prefix(self, en_action_input):
        """ì˜ì–´ ì•¡ì…˜ í”„ë¦¬í”½ìŠ¤ í…ŒìŠ¤íŠ¸."""
        rng = random.Random(42)
        prefix = _format_action_log_prefix(rng, InputType.ACTION, en_action_input, is_korean=False)

        expected_patterns = ["[ACTION]", "[EXECUTE]", "[ATTEMPT]"]
        assert any(pattern in prefix for pattern in expected_patterns)
        assert "Open the door" in prefix

    def test_long_text_truncation(self, base_client_info, base_economy_snapshot):
        """ê¸´ í…ìŠ¤íŠ¸ ìë¥´ê¸° í…ŒìŠ¤íŠ¸ (30ì ì´ˆê³¼)."""
        long_text = "ì´ê²ƒì€ ë§¤ìš° ë§¤ìš° ë§¤ìš° ë§¤ìš° ë§¤ìš° ë§¤ìš° ê¸´ í…ìŠ¤íŠ¸ì…ë‹ˆë‹¤ ì–´ì©Œê³  ì €ì©Œê³ "
        assert len(long_text) > 30

        turn_input = TurnInput(
            language=Language.KO,
            text=long_text,
            client=base_client_info,
            economy_snapshot=base_economy_snapshot,
        )

        rng = random.Random(42)
        prefix = _format_action_log_prefix(rng, InputType.FREE_TEXT, turn_input, is_korean=True)

        # í…ìŠ¤íŠ¸ê°€ ì˜ë ¤ì„œ "..." ìœ¼ë¡œ ëë‚˜ì•¼ í•¨
        assert "..." in prefix
        # ì „ì²´ í…ìŠ¤íŠ¸ê°€ í¬í•¨ë˜ì§€ ì•Šì•„ì•¼ í•¨
        assert long_text not in prefix

    def test_deterministic_with_same_rng_state(self, ko_action_input):
        """ë™ì¼ RNG ìƒíƒœì—ì„œ ê²°ì •ì  ê²°ê³¼ í…ŒìŠ¤íŠ¸."""
        prefix1 = _format_action_log_prefix(
            random.Random(42), InputType.ACTION, ko_action_input, is_korean=True
        )
        prefix2 = _format_action_log_prefix(
            random.Random(42), InputType.ACTION, ko_action_input, is_korean=True
        )
        assert prefix1 == prefix2


# =============================================================================
# MockOrchestrator í†µí•© í…ŒìŠ¤íŠ¸
# =============================================================================


class TestMockOrchestratorNarrativePrefix:
    """MockOrchestrator ë‚´ëŸ¬í‹°ë¸Œ í”„ë¦¬í”½ìŠ¤ í†µí•© í…ŒìŠ¤íŠ¸."""

    def test_action_input_no_said_ko(self, ko_action_input):
        """í•œêµ­ì–´ ì•¡ì…˜ ì…ë ¥ ì‹œ 'ë§í–ˆìŠµë‹ˆë‹¤' ì—†ìŒ í…ŒìŠ¤íŠ¸."""
        orchestrator = MockOrchestrator(seed=42)
        output = orchestrator.generate_turn_output(ko_action_input)

        assert isinstance(output, TurnOutput)
        assert "ë§í–ˆìŠµë‹ˆë‹¤" not in output.narrative
        assert "ë¼ê³  ë§í–ˆìŠµë‹ˆë‹¤" not in output.narrative

        # í–‰ë™ ë¡œê·¸ í”„ë¦¬í”½ìŠ¤ê°€ ìˆì–´ì•¼ í•¨
        expected_prefixes = ["[í–‰ë™]", "[ì‹¤í–‰]", "[ì‹œë„]"]
        assert any(prefix in output.narrative for prefix in expected_prefixes)

    def test_click_input_no_said_ko(self, ko_click_input):
        """í•œêµ­ì–´ í´ë¦­ ì…ë ¥ ì‹œ 'ë§í–ˆìŠµë‹ˆë‹¤' ì—†ìŒ í…ŒìŠ¤íŠ¸."""
        orchestrator = MockOrchestrator(seed=42)
        output = orchestrator.generate_turn_output(ko_click_input)

        assert "ë§í–ˆìŠµë‹ˆë‹¤" not in output.narrative

        expected_prefixes = ["[ì¡°ì‚¬]", "[íƒìƒ‰]", "[ìƒí˜¸ì‘ìš©]"]
        assert any(prefix in output.narrative for prefix in expected_prefixes)
        # ì˜¤ë¸Œì íŠ¸ ID í¬í•¨ í™•ì¸
        assert "obj_door" in output.narrative

    def test_drop_input_no_said_ko(self, ko_drop_input):
        """í•œêµ­ì–´ ë“œë¡­ ì…ë ¥ ì‹œ 'ë§í–ˆìŠµë‹ˆë‹¤' ì—†ìŒ í…ŒìŠ¤íŠ¸."""
        orchestrator = MockOrchestrator(seed=42)
        output = orchestrator.generate_turn_output(ko_drop_input)

        assert "ë§í–ˆìŠµë‹ˆë‹¤" not in output.narrative

        expected_prefixes = ["[ì‚¬ìš©]", "[ì¡°í•©]", "[ì ìš©]"]
        assert any(prefix in output.narrative for prefix in expected_prefixes)
        # ì•„ì´í…œ ë° ëŒ€ìƒ ID í¬í•¨ í™•ì¸
        assert "key_001" in output.narrative
        assert "obj_lock" in output.narrative

    def test_free_text_input_no_said_ko(self, ko_free_text_input):
        """í•œêµ­ì–´ ììœ  í…ìŠ¤íŠ¸ ì…ë ¥ ì‹œ 'ë§í–ˆìŠµë‹ˆë‹¤' ì—†ìŒ í…ŒìŠ¤íŠ¸ (Q1: Option B)."""
        orchestrator = MockOrchestrator(seed=42)
        output = orchestrator.generate_turn_output(ko_free_text_input)

        assert "ë§í–ˆìŠµë‹ˆë‹¤" not in output.narrative

        # í–‰ë™ ë¡œê·¸ í”„ë¦¬í”½ìŠ¤ê°€ ìˆì–´ì•¼ í•¨ (Q1: Option B ê²°ì •)
        expected_prefixes = ["[ì…ë ¥]", "[ëª…ë ¹]", "[ì§€ì‹œ]"]
        assert any(prefix in output.narrative for prefix in expected_prefixes)

    def test_action_input_no_said_en(self, en_action_input):
        """ì˜ì–´ ì•¡ì…˜ ì…ë ¥ ì‹œ 'You said' ì—†ìŒ í…ŒìŠ¤íŠ¸."""
        orchestrator = MockOrchestrator(seed=42)
        output = orchestrator.generate_turn_output(en_action_input)

        assert "You said" not in output.narrative
        assert "said" not in output.narrative.lower() or "[" in output.narrative[:10]

        expected_prefixes = ["[ACTION]", "[EXECUTE]", "[ATTEMPT]"]
        assert any(prefix in output.narrative for prefix in expected_prefixes)

    def test_empty_text_no_prefix(self, base_client_info, base_economy_snapshot):
        """ì˜ë¯¸ ì—†ëŠ” ì…ë ¥ ì‹œ í”„ë¦¬í”½ìŠ¤ ì—†ìŒ í…ŒìŠ¤íŠ¸."""
        turn_input = TurnInput(
            language=Language.KO,
            text="",  # ë¹ˆ í…ìŠ¤íŠ¸
            client=base_client_info,
            economy_snapshot=base_economy_snapshot,
        )

        orchestrator = MockOrchestrator(seed=42)
        output = orchestrator.generate_turn_output(turn_input)

        # ë¹ˆ ì…ë ¥ì´ë¯€ë¡œ í”„ë¦¬í”½ìŠ¤ê°€ ì—†ì–´ì•¼ í•¨
        assert not output.narrative.startswith("[")


# =============================================================================
# ê²°ì •ì  ë‹¤ì–‘ì„± í…ŒìŠ¤íŠ¸
# =============================================================================


class TestDeterministicDiversity:
    """ê²°ì •ì  ë‹¤ì–‘ì„± í…ŒìŠ¤íŠ¸."""

    def test_same_input_same_output(self, ko_action_input):
        """ë™ì¼ ì…ë ¥ â†’ ë™ì¼ ì¶œë ¥ (ì¬í˜„ì„±)."""
        orchestrator1 = MockOrchestrator(seed=42)
        orchestrator2 = MockOrchestrator(seed=42)

        output1 = orchestrator1.generate_turn_output(ko_action_input)
        output2 = orchestrator2.generate_turn_output(ko_action_input)

        assert output1.narrative == output2.narrative
        assert len(output1.ui.action_deck.cards) == len(output2.ui.action_deck.cards)

    def test_different_input_different_output(self, base_client_info, base_economy_snapshot):
        """ë‹¤ë¥¸ ì…ë ¥ â†’ ë‹¤ë¥¸ ì¶œë ¥ (ë‹¤ì–‘ì„±)."""
        input1 = TurnInput(
            language=Language.KO,
            text="ë¬¸ì„ ì—´ì–´ë³¸ë‹¤",
            client=base_client_info,
            economy_snapshot=base_economy_snapshot,
        )
        input2 = TurnInput(
            language=Language.KO,
            text="ì£¼ë³€ì„ íƒìƒ‰í•œë‹¤",
            client=base_client_info,
            economy_snapshot=base_economy_snapshot,
        )

        # ê°™ì€ seedì˜ ì˜¤ì¼€ìŠ¤íŠ¸ë ˆì´í„° ì‚¬ìš©
        orchestrator = MockOrchestrator(seed=42)

        output1 = orchestrator.generate_turn_output(input1)
        output2 = orchestrator.generate_turn_output(input2)

        # í”„ë¦¬í”½ìŠ¤ ë¶€ë¶„ì€ ë‹¤ë¥¼ ìˆ˜ ìˆìŒ (ë‹¤ë¥¸ ì…ë ¥ì´ë¯€ë¡œ)
        # ì ì–´ë„ í”„ë¦¬í”½ìŠ¤ê°€ ë‹¤ë¥´ê±°ë‚˜ ë‚´ëŸ¬í‹°ë¸Œ ë³¸ë¬¸ì´ ë‹¤ë¥¼ ìˆ˜ ìˆìŒ
        # per-turn RNGì´ë¯€ë¡œ ë‹¤ë¥¸ ê²°ê³¼ê°€ ë‚˜ì™€ì•¼ í•¨
        # ì°¸ê³ : í”„ë¦¬í”½ìŠ¤ì˜ í…ìŠ¤íŠ¸ ë¶€ë¶„ì€ ë¶„ëª…íˆ ë‹¤ë¦„
        assert "ë¬¸ì„ ì—´ì–´ë³¸ë‹¤" in output1.narrative
        assert "ì£¼ë³€ì„ íƒìƒ‰í•œë‹¤" in output2.narrative

    def test_multiple_calls_deterministic(self, ko_action_input):
        """ì—¬ëŸ¬ ë²ˆ í˜¸ì¶œí•´ë„ ê°™ì€ ê²°ê³¼ (ë™ì¼ ì…ë ¥ì— ëŒ€í•´)."""
        orchestrator = MockOrchestrator(seed=42)

        outputs = [orchestrator.generate_turn_output(ko_action_input) for _ in range(3)]

        # ëª¨ë“  ì¶œë ¥ì´ ë™ì¼í•´ì•¼ í•¨
        for i in range(1, len(outputs)):
            assert outputs[0].narrative == outputs[i].narrative


# =============================================================================
# ìŠ¤í‚¤ë§ˆ/ì¸ë°”ë¦¬ì–¸íŠ¸ í…ŒìŠ¤íŠ¸
# =============================================================================


class TestSchemaAndInvariants:
    """ìŠ¤í‚¤ë§ˆ ë° ì¸ë°”ë¦¬ì–¸íŠ¸ í…ŒìŠ¤íŠ¸."""

    def test_output_is_valid_turn_output(self, ko_action_input):
        """ì¶œë ¥ì´ ìœ íš¨í•œ TurnOutputì¸ì§€ í…ŒìŠ¤íŠ¸."""
        orchestrator = MockOrchestrator(seed=42)
        output = orchestrator.generate_turn_output(ko_action_input)

        assert isinstance(output, TurnOutput)
        assert output.language == Language.KO
        assert output.narrative is not None
        assert output.economy is not None
        assert output.safety is not None

    def test_economy_invariant_no_negative_balance(self, base_client_info):
        """ê²½ì œ ì¸ë°”ë¦¬ì–¸íŠ¸: ì”ì•¡ ìŒìˆ˜ ê¸ˆì§€ (RULE-005)."""
        # ì”ì•¡ì´ ë§¤ìš° ì ì€ ê²½ìš°
        economy_snapshot = EconomySnapshot(signal=1, memory_shard=0)
        turn_input = TurnInput(
            language=Language.KO,
            text="ë¹„ì‹¼ í–‰ë™",
            client=base_client_info,
            economy_snapshot=economy_snapshot,
        )

        orchestrator = MockOrchestrator(seed=42)
        output = orchestrator.generate_turn_output(turn_input)

        # ì”ì•¡ì€ 0 ì´ìƒì´ì–´ì•¼ í•¨
        assert output.economy.balance_after.signal >= 0
        assert output.economy.balance_after.memory_shard >= 0

    def test_coordinate_invariant_0_to_1000(self, ko_action_input):
        """ì¢Œí‘œ ì¸ë°”ë¦¬ì–¸íŠ¸: 0~1000 ë²”ìœ„ (RULE-009)."""
        orchestrator = MockOrchestrator(seed=42)
        output = orchestrator.generate_turn_output(ko_action_input)

        for obj in output.ui.objects:
            assert 0 <= obj.box_2d.ymin <= 1000
            assert 0 <= obj.box_2d.xmin <= 1000
            assert 0 <= obj.box_2d.ymax <= 1000
            assert 0 <= obj.box_2d.xmax <= 1000
            # ymin < ymax, xmin < xmax
            assert obj.box_2d.ymin < obj.box_2d.ymax
            assert obj.box_2d.xmin < obj.box_2d.xmax

    def test_language_consistency(self, ko_action_input, en_action_input):
        """ì–¸ì–´ ì¼ê´€ì„± í…ŒìŠ¤íŠ¸ (RULE-006)."""
        orchestrator = MockOrchestrator(seed=42)

        ko_output = orchestrator.generate_turn_output(ko_action_input)
        en_output = orchestrator.generate_turn_output(en_action_input)

        assert ko_output.language == Language.KO
        assert en_output.language == Language.EN


# =============================================================================
# í…œí”Œë¦¿ ìƒìˆ˜ í…ŒìŠ¤íŠ¸
# =============================================================================


class TestTemplateConstants:
    """í…œí”Œë¦¿ ìƒìˆ˜ ê²€ì¦ í…ŒìŠ¤íŠ¸."""

    def test_ko_prefixes_have_all_input_types(self):
        """í•œêµ­ì–´ í”„ë¦¬í”½ìŠ¤ì— ëª¨ë“  ì…ë ¥ íƒ€ì…ì´ ìˆëŠ”ì§€ í…ŒìŠ¤íŠ¸."""
        for input_type in InputType:
            assert input_type in KO_ACTION_LOG_PREFIXES
            assert len(KO_ACTION_LOG_PREFIXES[input_type]) >= 1

    def test_en_prefixes_have_all_input_types(self):
        """ì˜ì–´ í”„ë¦¬í”½ìŠ¤ì— ëª¨ë“  ì…ë ¥ íƒ€ì…ì´ ìˆëŠ”ì§€ í…ŒìŠ¤íŠ¸."""
        for input_type in InputType:
            assert input_type in EN_ACTION_LOG_PREFIXES
            assert len(EN_ACTION_LOG_PREFIXES[input_type]) >= 1

    def test_ko_prefixes_no_said(self):
        """í•œêµ­ì–´ í”„ë¦¬í”½ìŠ¤ì— 'ë§í–ˆìŠµë‹ˆë‹¤'ê°€ ì—†ëŠ”ì§€ í…ŒìŠ¤íŠ¸."""
        for _input_type, templates in KO_ACTION_LOG_PREFIXES.items():
            for template in templates:
                assert "ë§í–ˆìŠµë‹ˆë‹¤" not in template

    def test_en_prefixes_no_said(self):
        """ì˜ì–´ í”„ë¦¬í”½ìŠ¤ì— 'said'ê°€ ì—†ëŠ”ì§€ í…ŒìŠ¤íŠ¸."""
        for _input_type, templates in EN_ACTION_LOG_PREFIXES.items():
            for template in templates:
                assert "said" not in template.lower()
</file>

<file path="backend/tests/unit/orchestrator/test_pipeline.py">
"""Unknown World - Pipeline ë‹¨ìœ„/í†µí•© í…ŒìŠ¤íŠ¸.

RU-005[Mvp] ë¦¬íŒ©í† ë§ ê²€ì¦:
    - Stage ê¸°ë°˜ ëª¨ë“ˆí™” ë™ì‘ ë³´ì¡´
    - PipelineContext ìƒíƒœ ì „ì´ í™•ì¸
    - ì´ë²¤íŠ¸ emit ìˆœì„œ ë° ì •í•©ì„± (RULE-008)
    - U-018 ë¹„ì¦ˆë‹ˆìŠ¤ ë£° ê²€ì¦ ë° Repair ë£¨í”„ í†µí•© í™•ì¸
"""

from unittest.mock import AsyncMock, patch

import pytest

from unknown_world.models.turn import (
    AgentPhase,
    ClientInfo,
    EconomySnapshot,
    Language,
    Theme,
    TurnInput,
    TurnOutput,
    ValidationBadge,
)
from unknown_world.orchestrator.pipeline import (
    create_pipeline_context,
    run_pipeline,
)
from unknown_world.orchestrator.stages.types import (
    PipelineEvent,
    PipelineEventType,
)


@pytest.fixture
def turn_input() -> TurnInput:
    """ê¸°ë³¸ í„´ ì…ë ¥ í”½ìŠ¤ì²˜."""
    return TurnInput(
        language=Language.KO,
        text="ë¬¸ì„ ì—´ì–´ë³¸ë‹¤",
        client=ClientInfo(viewport_w=1920, viewport_h=1080, theme=Theme.DARK),
        economy_snapshot=EconomySnapshot(signal=100, memory_shard=5),
    )


def test_create_pipeline_context(turn_input):
    """ì»¨í…ìŠ¤íŠ¸ ì´ˆê¸°í™” ê²€ì¦."""
    ctx = create_pipeline_context(turn_input, seed=42, is_mock=True)

    assert ctx.turn_input == turn_input
    assert ctx.economy_snapshot.signal == 100
    assert ctx.economy_snapshot.memory_shard == 5
    assert ctx.is_mock is True
    assert ctx.seed == 42
    assert ctx.output is None
    assert ctx.badges == []


@pytest.mark.asyncio
async def test_run_pipeline_happy_path_mock(turn_input):
    """Mock ëª¨ë“œì—ì„œ ì •ìƒì ì¸ íŒŒì´í”„ë¼ì¸ ì‹¤í–‰ í™•ì¸ (Happy Path)."""
    ctx = create_pipeline_context(turn_input, seed=42, is_mock=True)
    events = []

    async def emit(event: PipelineEvent):
        events.append(event)

    ctx = await run_pipeline(ctx, emit=emit)

    # 1. ìµœì¢… ê²°ê³¼ í™•ì¸
    assert ctx.output is not None
    assert isinstance(ctx.output, TurnOutput)
    assert ctx.is_fallback is False
    assert ctx.repair_attempts == 0

    # 2. ì´ë²¤íŠ¸ ìˆœì„œ í™•ì¸ (ì¼ë¶€ í•µì‹¬ ë‹¨ê³„ë§Œ)
    event_types = [e.event_type for e in events]
    phases = [e.phase for e in events if e.phase is not None]

    assert PipelineEventType.STAGE_START in event_types
    assert PipelineEventType.STAGE_COMPLETE in event_types
    assert PipelineEventType.BADGES in event_types

    # PRD ìˆœì„œ: Parse -> Validate -> ... -> Commit
    assert AgentPhase.PARSE in phases
    assert AgentPhase.VALIDATE in phases
    assert AgentPhase.COMMIT in phases

    # 3. ë°°ì§€ í™•ì¸
    badges_events = [e for e in events if e.event_type == PipelineEventType.BADGES]
    assert len(badges_events) > 0
    assert ValidationBadge.SCHEMA_OK in badges_events[0].badges


@pytest.mark.asyncio
async def test_run_pipeline_validation_failure_repair_mock(turn_input):
    """ë¹„ì¦ˆë‹ˆìŠ¤ ë£° ìœ„ë°˜ ì‹œ Repair ë£¨í”„ ë°œìƒ í™•ì¸ (Mock)."""
    ctx = create_pipeline_context(turn_input, seed=42, is_mock=True)
    events = []

    async def emit(event: PipelineEvent):
        events.append(event)

    # validate_business_rulesë¥¼ ëª¨í‚¹í•˜ì—¬ ì²« ë²ˆì§¸ ì‹œë„ì—ì„œ ì‹¤íŒ¨í•˜ê²Œ í•¨
    with patch(
        "unknown_world.orchestrator.stages.validate.validate_business_rules"
    ) as mock_validate:
        from unknown_world.validation.business_rules import BusinessRuleValidationResult

        mock_validate.side_effect = [
            BusinessRuleValidationResult(
                is_valid=False, errors=[{"type": "economy_insufficient", "message": "error"}]
            ),
            BusinessRuleValidationResult(is_valid=True, errors=[]),
        ]

        ctx = await run_pipeline(ctx, emit=emit)

    # Repair ì´ë²¤íŠ¸ê°€ ë°œìƒí–ˆëŠ”ì§€ í™•ì¸
    repair_events = [e for e in events if e.event_type == PipelineEventType.REPAIR]
    assert len(repair_events) == 1
    assert repair_events[0].repair_attempt == 1
    assert ctx.repair_attempts == 1
    assert ctx.is_fallback is False


@pytest.mark.asyncio
async def test_run_pipeline_exception_fallback(turn_input):
    """ìŠ¤í…Œì´ì§€ ì‹¤í–‰ ì¤‘ ì˜ˆì™¸ ë°œìƒ ì‹œ í´ë°± í™•ì¸."""
    ctx = create_pipeline_context(turn_input, is_mock=True)

    async def emit(event: PipelineEvent):
        pass

    # ì˜ˆì™¸ë¥¼ ë˜ì§€ëŠ” ê°€ì§œ ìŠ¤í…Œì´ì§€
    async def failing_stage(c, *, emit):
        raise RuntimeError("Unexpected error")

    # ê°€ì§œ ìŠ¤í…Œì´ì§€ë¥¼ ì§ì ‘ ì „ë‹¬í•˜ì—¬ ì‹¤í–‰
    ctx = await run_pipeline(ctx, emit=emit, stages=[failing_stage])

    assert ctx.is_fallback is True
    assert ctx.output is not None
    assert "í˜¼ë€ìŠ¤ëŸ¬ìš´ ìˆœê°„" in ctx.output.narrative
    # í´ë°± ì‹œ ë¹„ìš© 0 í™•ì¸ (RULE-005)
    assert ctx.output.economy.cost.signal == 0
    assert ctx.output.economy.balance_after.signal == 100


@pytest.mark.asyncio
async def test_validate_stage_real_delegation(turn_input):
    """validate_stageê°€ Real ëª¨ë“œì—ì„œ run_repair_loopë¥¼ í˜¸ì¶œí•˜ëŠ”ì§€ í™•ì¸."""
    from unknown_world.models.turn import AgentConsole, TurnOutput
    from unknown_world.orchestrator.repair_loop import RepairLoopResult
    from unknown_world.orchestrator.stages.validate import validate_stage

    ctx = create_pipeline_context(turn_input, is_mock=False)
    events = []

    async def emit(event: PipelineEvent):
        events.append(event)

    # ì‹¤ì œ ê°ì²´ ìƒì„± í›„ í•„ìš”í•œ í•„ë“œë§Œ ëª¨í‚¹
    mock_output = AsyncMock(spec=TurnOutput)
    # dataclass í•„ë“œë“¤ì— ëŒ€í•œ attribute ì—ëŸ¬ ë°©ì§€ë¥¼ ìœ„í•´ ìˆ˜ë™ ì„¤ì •
    mock_output.agent_console = AgentConsole(
        badges=[ValidationBadge.SCHEMA_OK], current_phase=AgentPhase.VALIDATE
    )

    with patch("unknown_world.orchestrator.stages.validate.run_repair_loop") as mock_run:
        mock_run.return_value = RepairLoopResult(
            output=mock_output,
            repair_attempts=1,
            is_fallback=False,
            badges=[ValidationBadge.SCHEMA_OK],
            error_messages=["repair test"],
        )

        ctx = await validate_stage(ctx, emit=emit)

    assert mock_run.called
    assert ctx.repair_attempts == 1
    assert PipelineEventType.REPAIR in [e.event_type for e in events]
    assert ctx.output == mock_output


@pytest.mark.asyncio
async def test_validate_stage_mock_max_retries_fallback(turn_input):
    """Mock ëª¨ë“œì—ì„œ ìµœëŒ€ ì¬ì‹œë„ íšŸìˆ˜ ì´ˆê³¼ ì‹œ í´ë°± í™•ì¸."""
    from unknown_world.orchestrator.repair_loop import MAX_REPAIR_ATTEMPTS
    from unknown_world.orchestrator.stages.validate import validate_stage

    ctx = create_pipeline_context(turn_input, seed=42, is_mock=True)
    events = []

    async def emit(event: PipelineEvent):
        events.append(event)

    # í•­ìƒ ì‹¤íŒ¨í•˜ëŠ” ë¹„ì¦ˆë‹ˆìŠ¤ ë£° ê²€ì¦ ê²°ê³¼ ë°˜í™˜
    with patch(
        "unknown_world.orchestrator.stages.validate.validate_business_rules"
    ) as mock_validate:
        from unknown_world.validation.business_rules import BusinessRuleValidationResult

        mock_validate.return_value = BusinessRuleValidationResult(
            is_valid=False, errors=[{"type": "economy_insufficient", "message": "error"}]
        )

        ctx = await validate_stage(ctx, emit=emit)

    assert ctx.is_fallback is True
    assert ctx.repair_attempts == MAX_REPAIR_ATTEMPTS + 1  # 0íšŒì°¨ + 1íšŒì°¨ + 2íšŒì°¨ ì‹œë„ í›„ ì‹¤íŒ¨
    assert ValidationBadge.ECONOMY_FAIL in ctx.badges
    assert ctx.output.economy.cost.signal == 0


@pytest.mark.asyncio
async def test_validate_stage_mock_unexpected_exception(turn_input):
    """Mock ê²€ì¦ ë£¨í”„ ë‚´ì—ì„œ ì˜ˆì™¸ ë°œìƒ ì‹œ í´ë°± í™•ì¸."""
    from unknown_world.orchestrator.stages.validate import validate_stage

    ctx = create_pipeline_context(turn_input, seed=42, is_mock=True)
    events = []

    async def emit(event: PipelineEvent):
        events.append(event)

    # generate_turn_output í˜¸ì¶œ ì‹œ ì˜ˆì™¸ ë°œìƒ
    with patch(
        "unknown_world.orchestrator.mock.MockOrchestrator.generate_turn_output",
        side_effect=RuntimeError("Mock error"),
    ):
        ctx = await validate_stage(ctx, emit=emit)

    assert ctx.is_fallback is True
    # _validate_mock ë‚´ë¶€ try-except ë£¨í”„ê°€ MAX_REPAIR_ATTEMPTSë§Œí¼ ëŒê³  ê²°êµ­ í´ë°±
    assert ctx.repair_attempts > 0
</file>

<file path="backend/tests/unit/services/test_image_generation.py">
"""Unknown World - ì´ë¯¸ì§€ ìƒì„± ì„œë¹„ìŠ¤ ë‹¨ìœ„ í…ŒìŠ¤íŠ¸."""

from unittest.mock import patch

import pytest

from unknown_world.services.image_generation import (
    ImageGenerationRequest,
    ImageGenerationStatus,
    ImageGenerator,
    MockImageGenerator,
    get_image_generator,
    reset_image_generator,
)


@pytest.fixture
def temp_output_dir(tmp_path):
    """ì„ì‹œ ì¶œë ¥ ë””ë ‰í† ë¦¬ í”½ìŠ¤ì²˜."""
    return tmp_path / "test_images"


@pytest.mark.asyncio
async def test_mock_image_generator_success(temp_output_dir):
    """Mock ì´ë¯¸ì§€ ìƒì„±ê¸° ì„±ê³µ ì¼€ì´ìŠ¤ í…ŒìŠ¤íŠ¸."""
    generator = MockImageGenerator(output_dir=temp_output_dir)
    request = ImageGenerationRequest(
        prompt="A beautiful sunset over a cyberpunk city",
        aspect_ratio="1:1",
        image_size="1024x1024",
    )

    response = await generator.generate(request)

    assert response.status == ImageGenerationStatus.COMPLETED
    assert response.image_id is not None
    assert response.image_url is not None
    assert (temp_output_dir / f"{response.image_id}.png").exists()


@pytest.mark.asyncio
async def test_image_generator_initialization_failure():
    """ì‹¤ì œ ì´ë¯¸ì§€ ìƒì„±ê¸° ì´ˆê¸°í™” ì‹¤íŒ¨ ì‹œ ì²˜ë¦¬ í…ŒìŠ¤íŠ¸."""
    with patch("google.genai.Client", side_effect=Exception("Auth error")):
        generator = ImageGenerator()
        assert generator.is_available() is False


@pytest.mark.asyncio
async def test_get_image_generator_singleton():
    """íŒ©í† ë¦¬ í•¨ìˆ˜ë¥¼ í†µí•œ ì‹±ê¸€í†¤ ì¸ìŠ¤í„´ìŠ¤ ë°˜í™˜ í…ŒìŠ¤íŠ¸."""
    reset_image_generator()
    gen1 = get_image_generator(force_mock=True)
    gen2 = get_image_generator(force_mock=True)

    assert gen1 is gen2


@pytest.mark.asyncio
async def test_image_request_validation():
    """ì´ë¯¸ì§€ ìƒì„± ìš”ì²­ ê²€ì¦ ë¡œì§ í…ŒìŠ¤íŠ¸."""
    from unknown_world.services.image_generation import validate_image_request

    # ì„±ê³µ ì¼€ì´ìŠ¤
    valid_request = ImageGenerationRequest(prompt="Test prompt")
    assert validate_image_request(valid_request) is None

    # ì‹¤íŒ¨ ì¼€ì´ìŠ¤: ì§€ì›í•˜ì§€ ì•ŠëŠ” í¬ê¸°
    invalid_size = ImageGenerationRequest(prompt="Test", image_size="invalid")
    assert validate_image_request(invalid_size) == "ì§€ì›í•˜ì§€ ì•ŠëŠ” ì´ë¯¸ì§€ í¬ê¸°: invalid"

    # ì‹¤íŒ¨ ì¼€ì´ìŠ¤: ë„ˆë¬´ ì§§ì€ í”„ë¡¬í”„íŠ¸
    short_prompt = ImageGenerationRequest(prompt="A")
    assert validate_image_request(short_prompt) == "í”„ë¡¬í”„íŠ¸ê°€ ë„ˆë¬´ ì§§ìŠµë‹ˆë‹¤."
</file>

<file path="backend/tests/unit/services/test_rembg_preflight.py">
"""U-045[Mvp] rembg preflight ì„œë¹„ìŠ¤ ë‹¨ìœ„ í…ŒìŠ¤íŠ¸.

ì´ í…ŒìŠ¤íŠ¸ëŠ” ì„œë²„ ì‹œì‘ ì‹œ rembg ì„¤ì¹˜ ì—¬ë¶€ì™€ ëª¨ë¸ ìºì‹œë¥¼ ì ê²€í•˜ê³ 
í•„ìš”í•œ ê²½ìš° ë‹¤ìš´ë¡œë“œí•˜ëŠ” ë¡œì§ì„ ê²€ì¦í•©ë‹ˆë‹¤.
"""

import unittest
from pathlib import Path
from unittest.mock import MagicMock, patch

from unknown_world.services.rembg_preflight import (
    PreflightConfig,
    RembgPreflight,
    RembgReadyStatus,
)


class TestRembgPreflight(unittest.TestCase):
    """RembgPreflight ë‹¨ìœ„ í…ŒìŠ¤íŠ¸."""

    def setUp(self) -> None:
        self.config = PreflightConfig(
            models_to_prefetch=["test-model"],
            preflight_timeout_seconds=5,
            model_download_timeout_seconds=2,
        )
        self.preflight = RembgPreflight(self.config)

    @patch("unknown_world.services.rembg_preflight.subprocess.run")
    def test_check_rembg_installed_success(self, mock_run: MagicMock) -> None:
        """rembg ì„¤ì¹˜ í™•ì¸ ì„±ê³µ í…ŒìŠ¤íŠ¸."""
        mock_run.return_value = MagicMock(returncode=0, stdout="rembg 2.0.67")
        installed, version = self.preflight._check_rembg_installed()
        self.assertTrue(installed)
        self.assertEqual(version, "rembg 2.0.67")

    @patch("unknown_world.services.rembg_preflight.subprocess.run")
    def test_check_rembg_installed_failure(self, mock_run: MagicMock) -> None:
        """rembg ë¯¸ì„¤ì¹˜ í™•ì¸ í…ŒìŠ¤íŠ¸."""
        mock_run.side_effect = FileNotFoundError()
        installed, version = self.preflight._check_rembg_installed()
        self.assertFalse(installed)
        self.assertIsNone(version)

    @patch("unknown_world.services.rembg_preflight.Path.exists")
    @patch("unknown_world.services.rembg_preflight.Path.home")
    def test_check_model_available(self, mock_home: MagicMock, mock_exists: MagicMock) -> None:
        """ëª¨ë¸ ìºì‹œ ì¡´ì¬ ì—¬ë¶€ í™•ì¸ í…ŒìŠ¤íŠ¸."""
        mock_home.return_value = Path("/home/user")

        # 1. ëª¨ë¸ ìˆìŒ
        mock_exists.return_value = True
        self.assertTrue(self.preflight._check_model_available("test-model"))

        # 2. ëª¨ë¸ ì—†ìŒ
        mock_exists.return_value = False
        self.assertFalse(self.preflight._check_model_available("test-model"))

    @patch("unknown_world.services.rembg_preflight.subprocess.run")
    def test_download_model_success(self, mock_run: MagicMock) -> None:
        """ëª¨ë¸ ë‹¤ìš´ë¡œë“œ ì„±ê³µ í…ŒìŠ¤íŠ¸."""
        mock_run.return_value = MagicMock(returncode=0)
        self.assertTrue(self.preflight._download_model("test-model"))
        mock_run.assert_called_with(
            ["rembg", "d", "test-model"], capture_output=True, text=True, timeout=2
        )

    @patch("unknown_world.services.rembg_preflight.subprocess.run")
    def test_download_model_failure(self, mock_run: MagicMock) -> None:
        """ëª¨ë¸ ë‹¤ìš´ë¡œë“œ ì‹¤íŒ¨ í…ŒìŠ¤íŠ¸."""
        mock_run.return_value = MagicMock(returncode=1, stderr="network error")
        self.assertFalse(self.preflight._download_model("test-model"))

    @patch("unknown_world.services.rembg_preflight.RembgPreflight._process_model")
    @patch("unknown_world.services.rembg_preflight.RembgPreflight._check_rembg_installed")
    def test_run_ready(self, mock_check_installed: MagicMock, mock_process: MagicMock) -> None:
        """ì „ì²´ ì‹¤í–‰ ì„±ê³µ (READY) í…ŒìŠ¤íŠ¸."""
        mock_check_installed.return_value = (True, "2.0.67")
        mock_process.return_value = MagicMock(name="test-model", available=True)

        result = self.preflight.run()

        self.assertEqual(result.status, RembgReadyStatus.READY)
        self.assertTrue(result.installed)
        self.assertIn("test-model", result.preloaded_models)
        self.assertEqual(len(result.missing_models), 0)

    @patch("unknown_world.services.rembg_preflight.RembgPreflight._process_model")
    @patch("unknown_world.services.rembg_preflight.RembgPreflight._check_rembg_installed")
    def test_run_degraded(self, mock_check_installed: MagicMock, mock_process: MagicMock) -> None:
        """ì¼ë¶€ ëª¨ë¸ ëˆ„ë½ ì‹œ DEGRADED í…ŒìŠ¤íŠ¸."""
        mock_check_installed.return_value = (True, "2.0.67")
        mock_process.return_value = MagicMock(name="test-model", available=False)

        result = self.preflight.run()

        self.assertEqual(result.status, RembgReadyStatus.DEGRADED)
        self.assertIn("test-model", result.missing_models)

    @patch("unknown_world.services.rembg_preflight.RembgPreflight._check_rembg_installed")
    def test_run_unavailable(self, mock_check_installed: MagicMock) -> None:
        """rembg ë¯¸ì„¤ì¹˜ ì‹œ UNAVAILABLE í…ŒìŠ¤íŠ¸."""
        mock_check_installed.return_value = (False, None)

        result = self.preflight.run()

        self.assertEqual(result.status, RembgReadyStatus.UNAVAILABLE)
        self.assertFalse(result.installed)


if __name__ == "__main__":
    unittest.main()
</file>

<file path="backend/tests/unit/services/test_scanner_service.py">
"""U-021 ì´ë¯¸ì§€ ì´í•´(Scanner) ì„œë¹„ìŠ¤ ë‹¨ìœ„ í…ŒìŠ¤íŠ¸."""

import pytest

from unknown_world.models.scanner import ScanStatus
from unknown_world.models.turn import Language
from unknown_world.services.image_understanding import (
    MAX_FILE_SIZE_BYTES,
    ImageUnderstandingService,
    _parse_vision_response,
    normalize_bbox,
    validate_image,
)


def test_validate_image_valid():
    """ì •ìƒì ì¸ ì´ë¯¸ì§€ ê²€ì¦ í…ŒìŠ¤íŠ¸."""
    content = b"a" * 1000
    assert validate_image(content, "image/png") is None
    assert validate_image(content, "image/jpeg") is None
    assert validate_image(content, "image/webp") is None


def test_validate_image_invalid_type():
    """ì§€ì›í•˜ì§€ ì•ŠëŠ” íŒŒì¼ í˜•ì‹ ê²€ì¦ í…ŒìŠ¤íŠ¸."""
    content = b"a" * 1000
    error = validate_image(content, "text/plain")
    assert "ì§€ì›í•˜ì§€ ì•ŠëŠ” ì´ë¯¸ì§€ í˜•ì‹" in error


def test_validate_image_too_large():
    """íŒŒì¼ í¬ê¸° ì´ˆê³¼ ê²€ì¦ í…ŒìŠ¤íŠ¸."""
    content = b"a" * (MAX_FILE_SIZE_BYTES + 1)
    error = validate_image(content, "image/png")
    assert "íŒŒì¼ì´ ë„ˆë¬´ í½ë‹ˆë‹¤" in error


def test_validate_image_too_small():
    """ë„ˆë¬´ ì‘ì€ íŒŒì¼ ê²€ì¦ í…ŒìŠ¤íŠ¸."""
    content = b"a" * 10
    error = validate_image(content, "image/png")
    assert "ì´ë¯¸ì§€ íŒŒì¼ì´ ì†ìƒë˜ì—ˆê±°ë‚˜ ë¹„ì–´ìˆìŠµë‹ˆë‹¤" in error


def test_normalize_bbox_valid():
    """bbox ì •ê·œí™” í…ŒìŠ¤íŠ¸ (ì •ìƒ ë²”ìœ„)."""
    bbox = {"ymin": 100, "xmin": 200, "ymax": 300, "xmax": 400}
    normalized = normalize_bbox(bbox)
    assert normalized.ymin == 100
    assert normalized.xmin == 200
    assert normalized.ymax == 300
    assert normalized.xmax == 400


def test_normalize_bbox_clamping():
    """bbox ì •ê·œí™” í…ŒìŠ¤íŠ¸ (ë²”ìœ„ ì´ˆê³¼ í´ë¨í•‘)."""
    bbox = {"ymin": -100, "xmin": 1200, "ymax": 1500, "xmax": 500}
    normalized = normalize_bbox(bbox)
    assert normalized.ymin == 0
    assert normalized.xmin == 1000  # xminì´ xmaxë³´ë‹¤ ì»¤ì§€ëŠ” ê²½ìš° normalize_bbox ë¡œì§ í™•ì¸ í•„ìš”
    # xmaxê°€ 500ì´ë¯€ë¡œ xminì´ 1000ìœ¼ë¡œ í´ë¨í•‘ë˜ë©´ xmin > xmaxê°€ ë¨
    # normalize_bbox êµ¬í˜„:
    # xmin_val = max(0, min(1000, 1200)) -> 1000
    # xmax_val = max(0, min(1000, 500)) -> 500
    # if xmin_val >= xmax_val: xmax_val = min(xmin_val + 100, 1000) -> 1000
    assert normalized.xmax == 1000
    assert normalized.xmin == 1000


def test_normalize_bbox_order_correction():
    """bbox ì •ê·œí™” í…ŒìŠ¤íŠ¸ (ìˆœì„œ ë³´ì •)."""
    bbox = {"ymin": 500, "xmin": 500, "ymax": 200, "xmax": 200}
    normalized = normalize_bbox(bbox)
    assert normalized.ymin == 500
    assert normalized.ymax == 600  # 500 + 100
    assert normalized.xmin == 500
    assert normalized.xmax == 600  # 500 + 100


def test_parse_vision_response_valid():
    """ë¹„ì „ ëª¨ë¸ ì‘ë‹µ íŒŒì‹± í…ŒìŠ¤íŠ¸ (ì •ìƒ JSON)."""
    response_text = """
    {
      "caption": "A test image",
      "objects": [
        {
          "label": "Key",
          "box_2d": {"ymin": 100, "xmin": 100, "ymax": 200, "xmax": 200},
          "suggested_item_type": "key"
        }
      ],
      "item_candidates": [
        {
          "id": "item_1",
          "label": "Old Key",
          "description": "An old key",
          "item_type": "key",
          "source_object_index": 0
        }
      ]
    }
    """
    result = _parse_vision_response(response_text, Language.EN)
    assert result.status == ScanStatus.COMPLETED
    assert result.caption == "A test image"
    assert len(result.objects) == 1
    assert result.objects[0].label == "Key"
    assert result.objects[0].box_2d.ymin == 100
    assert len(result.item_candidates) == 1
    assert result.item_candidates[0].label == "Old Key"


def test_parse_vision_response_markdown():
    """ë¹„ì „ ëª¨ë¸ ì‘ë‹µ íŒŒì‹± í…ŒìŠ¤íŠ¸ (ë§ˆí¬ë‹¤ìš´ í¬í•¨)."""
    response_text = """```json
    {
      "caption": "Markdown test",
      "objects": []
    }
    ```"""
    result = _parse_vision_response(response_text, Language.KO)
    assert result.status == ScanStatus.COMPLETED
    assert result.caption == "Markdown test"


def test_parse_vision_response_invalid_json():
    """ë¹„ì „ ëª¨ë¸ ì‘ë‹µ íŒŒì‹± í…ŒìŠ¤íŠ¸ (ì˜ëª»ëœ JSON)."""
    response_text = "This is not JSON"
    result = _parse_vision_response(response_text, Language.KO)
    assert result.status == ScanStatus.PARTIAL
    assert result.caption == "This is not JSON"
    assert "íŒŒì‹±í•  ìˆ˜ ì—†ìŠµë‹ˆë‹¤" in result.message


@pytest.mark.asyncio
async def test_service_analyze_mock():
    """ì„œë¹„ìŠ¤ analyze ë©”ì„œë“œ í…ŒìŠ¤íŠ¸ (Mock ëª¨ë“œ)."""
    service = ImageUnderstandingService(force_mock=True)
    content = b"a" * 1000
    result = await service.analyze(content, "image/png", Language.KO)

    assert result.status == ScanStatus.COMPLETED
    assert "[Mock]" in result.caption
    assert len(result.objects) > 0
    assert result.analysis_time_ms >= 0
    assert result.message is None
</file>

<file path="backend/tests/unit/test_dotenv_autoload.py">
"""U-047: Backend .env ìë™ ë¡œë”© í…ŒìŠ¤íŠ¸

ì´ ëª¨ë“ˆì€ backend/.env íŒŒì¼ì˜ ìë™ ë¡œë”© ê¸°ëŠ¥ì„ ê²€ì¦í•©ë‹ˆë‹¤.

ì™„ë£Œ ê¸°ì¤€:
- ë¡œì»¬ì—ì„œ .env ì¡´ì¬ ì‹œ ìë™ ë¡œë”©ë¨ (ì¶”ê°€ export ë¶ˆí•„ìš”)
- UW_MODE/ENVIRONMENTê°€ .env ê¸°ì¤€ìœ¼ë¡œ ë°˜ì˜ë¨
- .env ë¯¸ì¡´ì¬ ì‹œ ì„œë²„ ì •ìƒ ì‹œì‘ (no-op)
- ë¯¼ê° ì •ë³´(í‚¤/í† í°/í”„ë¡¬í”„íŠ¸)ëŠ” ë¡œê·¸/ìŠ¤íŠ¸ë¦¼ì— ë…¸ì¶œë˜ì§€ ì•ŠìŒ (RULE-007)

í…ŒìŠ¤íŠ¸ ì‹œë‚˜ë¦¬ì˜¤:
1. .env íŒŒì¼ ì¡´ì¬ ì‹œ ë¡œë”© ì„±ê³µ
2. .env íŒŒì¼ ë¯¸ì¡´ì¬ ì‹œ ê¸°ë³¸ê°’ ì‚¬ìš© (ì •ìƒ ì‹œì‘)
3. override=False ì •ì±… ê²€ì¦ (ê¸°ì¡´ í™˜ê²½ë³€ìˆ˜ ìš°ì„ )
4. ë¡œê¹…ì— ë¯¼ê° ì •ë³´ ë¯¸í¬í•¨ ê²€ì¦
"""

import logging
import os
import tempfile
from collections.abc import Generator
from pathlib import Path

import pytest
from dotenv import load_dotenv


class TestDotenvAutoload:
    """dotenv ìë™ ë¡œë”© ê¸°ëŠ¥ í…ŒìŠ¤íŠ¸ ìŠ¤ìœ„íŠ¸."""

    # =========================================================================
    # Fixtures
    # =========================================================================

    @pytest.fixture
    def temp_env_file(self, tmp_path: Path) -> Generator[Path]:
        """ì„ì‹œ .env íŒŒì¼ì„ ìƒì„±í•˜ê³  ê²½ë¡œë¥¼ ë°˜í™˜í•©ë‹ˆë‹¤."""
        env_file = tmp_path / ".env"
        env_file.write_text(
            "UW_MODE=real\nENVIRONMENT=development\nGOOGLE_APPLICATION_CREDENTIALS=./test-key.key\n"
        )
        yield env_file
        # cleanup
        if env_file.exists():
            env_file.unlink()

    @pytest.fixture
    def clean_env(self) -> Generator[None]:
        """í…ŒìŠ¤íŠ¸ ì „ ê´€ë ¨ í™˜ê²½ë³€ìˆ˜ë¥¼ ì •ë¦¬í•©ë‹ˆë‹¤."""
        # ì €ì¥í•  ì›ë˜ ê°’ë“¤
        original_values: dict[str, str | None] = {}
        keys_to_clean = ["UW_MODE", "ENVIRONMENT", "GOOGLE_APPLICATION_CREDENTIALS"]

        for key in keys_to_clean:
            original_values[key] = os.environ.pop(key, None)

        yield

        # ë³µì›
        for key, value in original_values.items():
            if value is not None:
                os.environ[key] = value
            elif key in os.environ:
                del os.environ[key]

    # =========================================================================
    # 1. ì„±ê³µ ì‹œë‚˜ë¦¬ì˜¤ (Happy Path)
    # =========================================================================

    def test_dotenv_loads_when_file_exists(self, temp_env_file: Path, clean_env: None) -> None:
        """[Happy] .env íŒŒì¼ ì¡´ì¬ ì‹œ í™˜ê²½ë³€ìˆ˜ê°€ ë¡œë“œë©ë‹ˆë‹¤."""
        # Given: .env íŒŒì¼ì´ ì¡´ì¬í•˜ê³  í™˜ê²½ë³€ìˆ˜ê°€ ì„¤ì •ë˜ì–´ ìˆì§€ ì•ŠìŒ
        assert "UW_MODE" not in os.environ
        assert "ENVIRONMENT" not in os.environ

        # When: load_dotenv í˜¸ì¶œ
        result = load_dotenv(dotenv_path=temp_env_file, override=False)

        # Then: í™˜ê²½ë³€ìˆ˜ê°€ ë¡œë“œë¨
        assert result is True
        assert os.environ.get("UW_MODE") == "real"
        assert os.environ.get("ENVIRONMENT") == "development"

    def test_uw_mode_reflects_env_value(self, temp_env_file: Path, clean_env: None) -> None:
        """[Happy] UW_MODEê°€ .envì—ì„œ ë¡œë“œëœ ê°’ìœ¼ë¡œ ì„¤ì •ë©ë‹ˆë‹¤."""
        # Given: clean env + temp .env file
        load_dotenv(dotenv_path=temp_env_file, override=False)

        # When/Then: UW_MODE ê°’ í™•ì¸
        assert os.environ.get("UW_MODE") == "real"

    def test_environment_reflects_env_value(self, temp_env_file: Path, clean_env: None) -> None:
        """[Happy] ENVIRONMENTê°€ .envì—ì„œ ë¡œë“œëœ ê°’ìœ¼ë¡œ ì„¤ì •ë©ë‹ˆë‹¤."""
        # Given: clean env + temp .env file
        load_dotenv(dotenv_path=temp_env_file, override=False)

        # When/Then: ENVIRONMENT ê°’ í™•ì¸
        assert os.environ.get("ENVIRONMENT") == "development"

    # =========================================================================
    # 2. ì‹¤íŒ¨/ì˜ˆì™¸ ì‹œë‚˜ë¦¬ì˜¤ (Error Cases)
    # =========================================================================

    def test_server_starts_without_env_file(self, clean_env: None) -> None:
        """[Error] .env íŒŒì¼ ë¯¸ì¡´ì¬ ì‹œ load_dotenvëŠ” Falseë¥¼ ë°˜í™˜í•˜ê³  ì„œë²„ëŠ” ì •ìƒ ì‹œì‘í•©ë‹ˆë‹¤."""
        # Given: ì¡´ì¬í•˜ì§€ ì•ŠëŠ” ê²½ë¡œ
        non_existent_path = Path("/non/existent/path/.env")

        # When: load_dotenv í˜¸ì¶œ
        result = load_dotenv(dotenv_path=non_existent_path, override=False)

        # Then: False ë°˜í™˜ (ì—ëŸ¬ ì—†ì´)
        assert result is False

    def test_default_values_when_env_missing(self, clean_env: None) -> None:
        """[Error] .env ë¯¸ì¡´ì¬ ì‹œ ê¸°ë³¸ê°’ì„ ì‚¬ìš©í•©ë‹ˆë‹¤."""
        # Given: .env ì—†ì´ í™˜ê²½ë³€ìˆ˜ë„ ì—†ìŒ
        # When: ê¸°ë³¸ê°’ ì¡°íšŒ
        uw_mode = os.environ.get("UW_MODE", "mock")
        environment = os.environ.get("ENVIRONMENT", "development")

        # Then: ê¸°ë³¸ê°’ ì‚¬ìš©
        assert uw_mode == "mock"  # genai_client.pyì˜ ê¸°ë³¸ê°’
        assert environment == "development"

    # =========================================================================
    # 3. ê²½ê³„ê°’ í…ŒìŠ¤íŠ¸ (Boundary Conditions)
    # =========================================================================

    def test_override_false_preserves_existing_env(
        self, temp_env_file: Path, clean_env: None
    ) -> None:
        """[Boundary] override=False: ê¸°ì¡´ í™˜ê²½ë³€ìˆ˜ê°€ ìˆìœ¼ë©´ ë®ì–´ì“°ì§€ ì•ŠìŠµë‹ˆë‹¤."""
        # Given: í™˜ê²½ë³€ìˆ˜ê°€ ì´ë¯¸ ì„¤ì •ë¨
        os.environ["UW_MODE"] = "mock"
        os.environ["ENVIRONMENT"] = "production"

        # When: load_dotenv(override=False) í˜¸ì¶œ
        load_dotenv(dotenv_path=temp_env_file, override=False)

        # Then: ê¸°ì¡´ ê°’ ìœ ì§€ (ë®ì–´ì“°ì§€ ì•ŠìŒ)
        assert os.environ.get("UW_MODE") == "mock"  # .envì˜ "real"ë¡œ ë³€ê²½ë˜ì§€ ì•ŠìŒ
        assert os.environ.get("ENVIRONMENT") == "production"

    def test_override_true_overwrites_existing_env(
        self, temp_env_file: Path, clean_env: None
    ) -> None:
        """[Boundary] override=True: ê¸°ì¡´ í™˜ê²½ë³€ìˆ˜ë¥¼ ë®ì–´ì”ë‹ˆë‹¤ (ì°¸ì¡°ìš©, í”„ë¡œë•ì…˜ì—ì„œëŠ” ì‚¬ìš© ê¸ˆì§€)."""
        # Given: í™˜ê²½ë³€ìˆ˜ê°€ ì´ë¯¸ ì„¤ì •ë¨
        os.environ["UW_MODE"] = "mock"

        # When: load_dotenv(override=True) í˜¸ì¶œ - ì£¼ì˜: í”„ë¡œë•ì…˜ì—ì„œëŠ” ê¸ˆì§€
        load_dotenv(dotenv_path=temp_env_file, override=True)

        # Then: ìƒˆ ê°’ìœ¼ë¡œ ë®ì–´ì”€
        assert os.environ.get("UW_MODE") == "real"

    def test_empty_env_file_no_error(self, tmp_path: Path, clean_env: None) -> None:
        """[Boundary] ë¹ˆ .env íŒŒì¼ë„ ì—ëŸ¬ ì—†ì´ ì²˜ë¦¬ë©ë‹ˆë‹¤."""
        # Given: ë¹ˆ .env íŒŒì¼
        empty_env = tmp_path / ".env"
        empty_env.write_text("")

        # When: load_dotenv í˜¸ì¶œ
        # Note: python-dotenvëŠ” ë¹ˆ íŒŒì¼ì—ì„œë„ ì—ëŸ¬ë¥¼ ë°œìƒì‹œí‚¤ì§€ ì•ŠìŒ
        # ë°˜í™˜ê°’ì€ íŒŒì¼ ì¡´ì¬ ì—¬ë¶€ë³´ë‹¤ëŠ” "ë³€ìˆ˜ê°€ ë¡œë“œë˜ì—ˆëŠ”ì§€"ë¥¼ ë‚˜íƒ€ë‚¼ ìˆ˜ ìˆìŒ
        try:
            result = load_dotenv(dotenv_path=empty_env, override=False)
            # Then: ì—ëŸ¬ ì—†ì´ ì™„ë£Œë¨ (ë°˜í™˜ê°’ì€ êµ¬í˜„ì— ë”°ë¼ ë‹¤ë¦„)
            assert isinstance(result, bool)
        except Exception as e:
            pytest.fail(f"ë¹ˆ .env íŒŒì¼ ì²˜ë¦¬ ì¤‘ ì˜ˆì™¸ ë°œìƒ: {e}")

    def test_env_with_comments_and_whitespace(self, tmp_path: Path, clean_env: None) -> None:
        """[Boundary] ì£¼ì„ê³¼ ê³µë°±ì´ ìˆëŠ” .env íŒŒì¼ì„ ì˜¬ë°”ë¥´ê²Œ íŒŒì‹±í•©ë‹ˆë‹¤."""
        # Given: ì£¼ì„ê³¼ ê³µë°±ì´ ìˆëŠ” .env íŒŒì¼
        env_file = tmp_path / ".env"
        env_file.write_text(
            "# This is a comment\n\nUW_MODE=real\n  \n# Another comment\nENVIRONMENT=staging\n"
        )

        # When: load_dotenv í˜¸ì¶œ
        load_dotenv(dotenv_path=env_file, override=False)

        # Then: ì£¼ì„/ê³µë°± ë¬´ì‹œ, ê°’ë§Œ ë¡œë“œ
        assert os.environ.get("UW_MODE") == "real"
        assert os.environ.get("ENVIRONMENT") == "staging"

    # =========================================================================
    # 4. ë³´ì•ˆ í…ŒìŠ¤íŠ¸ (Security) - RULE-007
    # =========================================================================

    def test_sensitive_info_not_in_logs(
        self, temp_env_file: Path, clean_env: None, caplog: pytest.LogCaptureFixture
    ) -> None:
        """[Security] ë¯¼ê° ì •ë³´(í‚¤/í† í°/ê²½ë¡œ)ê°€ ë¡œê·¸ì— ë…¸ì¶œë˜ì§€ ì•ŠìŠµë‹ˆë‹¤.

        ì´ í…ŒìŠ¤íŠ¸ëŠ” main.pyì˜ ë¡œê¹… ì •ì±…(RULE-007)ì„ ê²€ì¦í•©ë‹ˆë‹¤:
        - ë¯¼ê° ì •ë³´(í‚¤/í† í°/ê²½ë¡œ)ëŠ” ë¡œê·¸ì— ì¶œë ¥í•˜ì§€ ì•ŠìŒ
        - ëª¨ë“œ/í™˜ê²½ ì •ë³´ ì •ë„ë§Œ ë¡œê¹…
        """
        # Given: .envì— ë¯¼ê° ì •ë³´ í¬í•¨
        load_dotenv(dotenv_path=temp_env_file, override=False)

        # When: main.pyì˜ ë¡œê¹… ë¡œì§ì„ ì‹œë®¬ë ˆì´ì…˜
        with caplog.at_level(logging.INFO):
            # ë¡œê·¸ ì¶œë ¥ ì‹œë®¬ë ˆì´ì…˜ (main.py ìŠ¤íƒ€ì¼)
            uw_mode = os.environ.get("UW_MODE", "mock")
            environment = os.environ.get("ENVIRONMENT", "development")

            logger = logging.getLogger("test_security")
            # ì˜¬ë°”ë¥¸ ë°©ì‹: ë©”ì‹œì§€ì— ì•ˆì „í•œ ì •ë³´ë§Œ í¬í•¨
            logger.info(
                f"[Config] .env íŒŒì¼ ë¡œë“œ ì™„ë£Œ - UW_MODE={uw_mode}, ENVIRONMENT={environment}"
            )

        # Then: ë¯¼ê° ì •ë³´ê°€ ë¡œê·¸ì— ì—†ìŒ
        log_text = caplog.text

        # í‚¤ íŒŒì¼ ê²½ë¡œê°€ ì—†ì–´ì•¼ í•¨ (RULE-007 ìœ„ë°˜ ì‹œ ì‹¤íŒ¨)
        assert "test-key.key" not in log_text, "ë¯¼ê° ì •ë³´(í‚¤ íŒŒì¼ ê²½ë¡œ)ê°€ ë¡œê·¸ì— ë…¸ì¶œë¨"
        assert "GOOGLE_APPLICATION_CREDENTIALS" not in log_text, (
            "ë¯¼ê° ì •ë³´(í™˜ê²½ë³€ìˆ˜ëª…)ê°€ ë¡œê·¸ì— ë…¸ì¶œë¨"
        )

        # í—ˆìš©ëœ ì •ë³´ëŠ” ë¡œê·¸ì— ìˆì–´ì•¼ í•¨ (ì˜¬ë°”ë¥¸ ë¡œê¹… í™•ì¸)
        assert "UW_MODE" in log_text, "ëª¨ë“œ ì •ë³´ê°€ ë¡œê·¸ì— ìˆì–´ì•¼ í•¨"
        assert "ENVIRONMENT" in log_text or "development" in log_text, (
            "í™˜ê²½ ì •ë³´ê°€ ë¡œê·¸ì— ìˆì–´ì•¼ í•¨"
        )


class TestMainModuleDotenvIntegration:
    """main.py ëª¨ë“ˆì˜ dotenv í†µí•© í…ŒìŠ¤íŠ¸."""

    @pytest.fixture
    def clean_env(self) -> Generator[None]:
        """í…ŒìŠ¤íŠ¸ ì „ ê´€ë ¨ í™˜ê²½ë³€ìˆ˜ë¥¼ ì •ë¦¬í•©ë‹ˆë‹¤."""
        original_values: dict[str, str | None] = {}
        keys_to_clean = ["UW_MODE", "ENVIRONMENT"]

        for key in keys_to_clean:
            original_values[key] = os.environ.pop(key, None)

        yield

        for key, value in original_values.items():
            if value is not None:
                os.environ[key] = value
            elif key in os.environ:
                del os.environ[key]

    def test_main_module_dotenv_path_calculation(self) -> None:
        """[Integration] main.pyì˜ .env ê²½ë¡œ ê³„ì‚°ì´ ì˜¬ë°”ë¦…ë‹ˆë‹¤."""
        # Given: main.pyì˜ ê²½ë¡œ ê³„ì‚° ë¡œì§ ì¬í˜„
        # main.py ìœ„ì¹˜: backend/src/unknown_world/main.py
        # .env ìœ„ì¹˜: backend/.env
        # ë”°ë¼ì„œ: main.py -> parent(unknown_world) -> parent(src) -> parent(backend) -> .env

        # ì‹¤ì œ main.py ê²½ë¡œ ê¸°ì¤€ìœ¼ë¡œ ê³„ì‚°
        main_py_path = Path(__file__).parent.parent.parent / "src" / "unknown_world" / "main.py"
        expected_dotenv_path = main_py_path.parent.parent.parent.parent / ".env"

        # When: ê³„ì‚°ëœ ê²½ë¡œ í™•ì¸
        actual_backend_dir = expected_dotenv_path.parent

        # Then: backend ë””ë ‰í† ë¦¬ë¥¼ ê°€ë¦¬í‚´
        assert actual_backend_dir.name == "backend" or ".env" in str(expected_dotenv_path)

    def test_load_dotenv_returns_boolean(self) -> None:
        """[Integration] load_dotenvëŠ” booleanì„ ë°˜í™˜í•˜ì—¬ ë¡œë”© ìƒíƒœë¥¼ ì•Œ ìˆ˜ ìˆìŠµë‹ˆë‹¤."""
        # Given: ì„ì‹œ íŒŒì¼
        with tempfile.NamedTemporaryFile(mode="w", suffix=".env", delete=False) as f:
            f.write("TEST_VAR=test_value\n")
            temp_path = Path(f.name)

        try:
            # When: load_dotenv í˜¸ì¶œ
            result = load_dotenv(dotenv_path=temp_path, override=False)

            # Then: boolean ë°˜í™˜
            assert isinstance(result, bool)
            assert result is True
        finally:
            temp_path.unlink()


class TestDotenvPolicyCompliance:
    """dotenv ì •ì±… ì¤€ìˆ˜ í…ŒìŠ¤íŠ¸."""

    def test_policy_local_development_autoload(self) -> None:
        """[Policy] ë¡œì»¬ ê°œë°œì—ì„œ .env ìë™ ë¡œë”© ì •ì±…ì´ ì¤€ìˆ˜ë©ë‹ˆë‹¤.

        U-047 ì™„ë£Œ ê¸°ì¤€:
        - ë¡œì»¬ì—ì„œ `cd backend && cp .env.example .env` í›„
          `uv run uvicorn unknown_world.main:app ...` ì‹¤í–‰ ì‹œ
          .envê°€ ìë™ ë¡œë”©ëœë‹¤(ì¶”ê°€ export ë¶ˆí•„ìš”).
        """
        # Given: python-dotenvê°€ ì„¤ì¹˜ë˜ì–´ ìˆìŒ (pyproject.tomlì— ëª…ì‹œ)
        # When: load_dotenv í•¨ìˆ˜ê°€ ì‚¬ìš© ê°€ëŠ¥í•œì§€ í™•ì¸
        from dotenv import load_dotenv

        # Then: í•¨ìˆ˜ê°€ ì¡´ì¬í•˜ê³  í˜¸ì¶œ ê°€ëŠ¥
        assert callable(load_dotenv)

    def test_policy_override_false_for_production_safety(self) -> None:
        """[Policy] override=False ì •ì±…ìœ¼ë¡œ ìš´ì˜ í™˜ê²½ SSOTê°€ ë³´ì¥ë©ë‹ˆë‹¤.

        U-047 ì •ì±…:
        - ìš´ì˜(Cloud Run ë“±)ì€ ëŸ°íƒ€ì„ envë¥¼ SSOTë¡œ ì‚¬ìš©(override ê¸ˆì§€)
        """
        # Given: ìš´ì˜ í™˜ê²½ì—ì„œ í™˜ê²½ë³€ìˆ˜ê°€ ì´ë¯¸ ì„¤ì •ë¨
        os.environ["POLICY_TEST_VAR"] = "production_value"

        with tempfile.NamedTemporaryFile(mode="w", suffix=".env", delete=False) as f:
            f.write("POLICY_TEST_VAR=dev_value\n")
            temp_path = Path(f.name)

        try:
            # When: override=Falseë¡œ ë¡œë“œ
            load_dotenv(dotenv_path=temp_path, override=False)

            # Then: ê¸°ì¡´ ê°’ ìœ ì§€ (ìš´ì˜ SSOT ë³´ì¥)
            assert os.environ.get("POLICY_TEST_VAR") == "production_value"
        finally:
            temp_path.unlink()
            del os.environ["POLICY_TEST_VAR"]

    def test_policy_no_crash_without_env_file(self) -> None:
        """[Policy] .env íŒŒì¼ ë¯¸ì¡´ì¬ ì‹œ ì„œë²„ê°€ ì •ìƒ ì‹œì‘í•©ë‹ˆë‹¤.

        U-047 ì™„ë£Œ ê¸°ì¤€:
        - .envëŠ” ì¡´ì¬í•˜ì§€ ì•Šì•„ë„ ì„œë²„ê°€ ì •ìƒì ìœ¼ë¡œ ì‹œì‘í•œë‹¤
          (ìš´ì˜/CIì—ì„œ íŒŒì¼ ë¯¸ì¡´ì¬ë¥¼ ê¸°ë³¸ìœ¼ë¡œ í—ˆìš©)
        """
        # Given: ì¡´ì¬í•˜ì§€ ì•ŠëŠ” .env ê²½ë¡œ
        non_existent = Path("/definitely/not/a/real/path/.env")

        # When/Then: ì—ëŸ¬ ì—†ì´ False ë°˜í™˜
        try:
            result = load_dotenv(dotenv_path=non_existent, override=False)
            assert result is False  # íŒŒì¼ ì—†ìŒ
        except Exception as e:
            pytest.fail(f"load_dotenv raised an exception: {e}")
</file>

<file path="backend/tests/unit/test_image_generation_integration.py">
"""U-035[Mvp] ì´ë¯¸ì§€ ìƒì„± ì„œë¹„ìŠ¤ì™€ ë°°ê²½ ì œê±° í†µí•© í…ŒìŠ¤íŠ¸.

ImageGenerator ë° MockImageGeneratorê°€ ë°°ê²½ ì œê±° ì˜µì…˜ì„ ì˜¬ë°”ë¥´ê²Œ ì²˜ë¦¬í•˜ëŠ”ì§€ ê²€ì¦í•©ë‹ˆë‹¤.
"""

import unittest
from pathlib import Path
from unittest.mock import AsyncMock, MagicMock, patch

from unknown_world.services.image_generation import (
    ImageGenerationRequest,
    ImageGenerationStatus,
    MockImageGenerator,
)


class TestImageGenerationIntegration(unittest.IsolatedAsyncioTestCase):
    """ì´ë¯¸ì§€ ìƒì„± ë° ë°°ê²½ ì œê±° í†µí•© í…ŒìŠ¤íŠ¸."""

    @patch("unknown_world.services.image_postprocess.ImagePostprocessor.remove_background")
    @patch("unknown_world.services.image_postprocess.ImagePostprocessor.is_available")
    async def test_mock_generator_rembg_integration(
        self, mock_available: MagicMock, mock_remove: MagicMock
    ) -> None:
        """MockImageGeneratorê°€ ë°°ê²½ ì œê±°ë¥¼ í˜¸ì¶œí•˜ëŠ”ì§€ í…ŒìŠ¤íŠ¸í•©ë‹ˆë‹¤."""
        mock_available.return_value = True
        mock_remove.return_value = MagicMock(
            status=MagicMock(value="success"),
            model_used="birefnet-general",
            output_path=Path("img_123_nobg.png"),
            processing_time_ms=100,
        )

        generator = MockImageGenerator(output_dir=Path("test_output"))

        # 1. ë°°ê²½ ì œê±° í™œì„±í™” ìš”ì²­
        request = ImageGenerationRequest(
            prompt="A cute cat", remove_background=True, image_type_hint="object"
        )

        # Path.write_bytes ëª¨í‚¹ (íŒŒì¼ ìƒì„± ë°©ì§€)
        with patch.object(Path, "write_bytes"):
            response = await generator.generate(request)

            self.assertEqual(response.status, ImageGenerationStatus.COMPLETED)
            self.assertTrue(response.background_removed)
            self.assertEqual(response.rembg_model_used, "birefnet-general")
            self.assertIn("_nobg.png", response.image_url)

            # rembg í›„ì²˜ë¦¬ê°€ í˜¸ì¶œë˜ì—ˆëŠ”ì§€ í™•ì¸
            mock_remove.assert_called_once()

    @patch("unknown_world.services.image_postprocess.ImagePostprocessor.remove_background")
    @patch("unknown_world.services.image_postprocess.ImagePostprocessor.is_available")
    async def test_mock_generator_no_rembg(
        self, mock_available: MagicMock, mock_remove: MagicMock
    ) -> None:
        """ë°°ê²½ ì œê±° ì˜µì…˜ì´ êº¼ì ¸ìˆì„ ë•Œ í˜¸ì¶œë˜ì§€ ì•ŠëŠ”ì§€ í…ŒìŠ¤íŠ¸í•©ë‹ˆë‹¤."""
        generator = MockImageGenerator(output_dir=Path("test_output"))

        request = ImageGenerationRequest(prompt="A landscape", remove_background=False)

        with patch.object(Path, "write_bytes"):
            response = await generator.generate(request)

            self.assertEqual(response.status, ImageGenerationStatus.COMPLETED)
            self.assertFalse(response.background_removed)
            self.assertNotIn("_nobg.png", response.image_url)

            # rembg í›„ì²˜ë¦¬ê°€ í˜¸ì¶œë˜ì§€ ì•Šì•„ì•¼ í•¨
            mock_remove.assert_not_called()

    @patch("unknown_world.services.image_generation.ImageGenerator._initialize_client")
    @patch("unknown_world.services.image_postprocess.ImagePostprocessor.remove_background")
    async def test_real_generator_rembg_integration(
        self, mock_remove: MagicMock, mock_init: MagicMock
    ) -> None:
        """ì‹¤ì œ ImageGenerator(Vertex AI)ì™€ rembg í†µí•©ì„ í…ŒìŠ¤íŠ¸í•©ë‹ˆë‹¤."""
        from unknown_world.services.image_generation import ImageGenerator

        # í´ë¼ì´ì–¸íŠ¸ ëª¨í‚¹
        mock_client = MagicMock()
        mock_client.aio.models.generate_images = AsyncMock()

        # ëª¨ì˜ ì´ë¯¸ì§€ ìƒì„± ê²°ê³¼
        mock_image = MagicMock()
        mock_image.image.image_bytes = b"fake_png_data"
        mock_resp = MagicMock()
        mock_resp.generated_images = [mock_image]
        mock_client.aio.models.generate_images.return_value = mock_resp

        generator = ImageGenerator(output_dir=Path("test_output"))
        generator._client = mock_client
        generator._available = True

        mock_remove.return_value = MagicMock(
            status=MagicMock(value="success"),
            model_used="birefnet-general",
            output_path=Path("img_real_nobg.png"),
            processing_time_ms=150,
        )

        request = ImageGenerationRequest(
            prompt="A high quality product photo", remove_background=True, image_type_hint="product"
        )

        with patch.object(Path, "write_bytes"):
            response = await generator.generate(request)

            self.assertEqual(response.status, ImageGenerationStatus.COMPLETED)
            self.assertTrue(response.background_removed)
            mock_remove.assert_called_once()


if __name__ == "__main__":
    unittest.main()
</file>

<file path="backend/tests/unit/test_orchestrator_repair.py">
"""U-018: Repair Loop ë° ë¹„ì¦ˆë‹ˆìŠ¤ ë£° ê²€ì¦ ë‹¨ìœ„ í…ŒìŠ¤íŠ¸."""

from unittest.mock import AsyncMock, patch

import pytest

from unknown_world.models.turn import (
    ActionDeck,
    AgentConsole,
    AgentPhase,
    ClientInfo,
    CurrencyAmount,
    EconomyOutput,
    EconomySnapshot,
    Language,
    RenderOutput,
    SafetyOutput,
    TurnInput,
    TurnOutput,
    UIOutput,
    ValidationBadge,
    WorldDelta,
)
from unknown_world.orchestrator.generate_turn_output import GenerationResult, GenerationStatus
from unknown_world.orchestrator.repair_loop import MAX_REPAIR_ATTEMPTS, run_repair_loop
from unknown_world.validation.business_rules import validate_business_rules


@pytest.fixture
def sample_turn_input() -> TurnInput:
    return TurnInput(
        language=Language.KO,
        text="í…ŒìŠ¤íŠ¸ ì…ë ¥",
        client=ClientInfo(viewport_w=1920, viewport_h=1080),
        economy_snapshot=EconomySnapshot(signal=100, memory_shard=5),
    )


@pytest.fixture
def valid_turn_output(sample_turn_input: TurnInput) -> TurnOutput:
    return TurnOutput(
        language=Language.KO,
        narrative="ì„±ê³µì ì¸ ë‚´ëŸ¬í‹°ë¸Œ",
        ui=UIOutput(action_deck=ActionDeck(cards=[]), objects=[]),
        world=WorldDelta(),
        render=RenderOutput(image_job=None),
        economy=EconomyOutput(
            cost=CurrencyAmount(signal=10, memory_shard=1),
            balance_after=CurrencyAmount(signal=90, memory_shard=4),
        ),
        safety=SafetyOutput(blocked=False),
        agent_console=AgentConsole(
            current_phase=AgentPhase.COMMIT,
            badges=[ValidationBadge.SCHEMA_OK],
            repair_count=0,
        ),
    )


@pytest.mark.asyncio
async def test_repair_loop_success_first_time(
    sample_turn_input: TurnInput, valid_turn_output: TurnOutput
) -> None:
    """ì´ˆê¸° ì‹œë„ì— ë°”ë¡œ ì„±ê³µí•˜ëŠ” ì¼€ì´ìŠ¤."""
    with patch("unknown_world.orchestrator.repair_loop.get_turn_output_generator") as mock_get_gen:
        mock_gen = mock_get_gen.return_value
        mock_gen.generate = AsyncMock(
            return_value=GenerationResult(status=GenerationStatus.SUCCESS, output=valid_turn_output)
        )

        result = await run_repair_loop(sample_turn_input)

        assert result.is_fallback is False
        assert result.repair_attempts == 0
        assert result.output.narrative == valid_turn_output.narrative
        assert ValidationBadge.SCHEMA_OK in result.badges


@pytest.mark.asyncio
async def test_repair_loop_schema_failure_then_success(
    sample_turn_input: TurnInput, valid_turn_output: TurnOutput
) -> None:
    """ìŠ¤í‚¤ë§ˆ ì‹¤íŒ¨ í›„ ë‘ ë²ˆì§¸ ì‹œë„ì— ì„±ê³µí•˜ëŠ” ì¼€ì´ìŠ¤."""
    with patch("unknown_world.orchestrator.repair_loop.get_turn_output_generator") as mock_get_gen:
        mock_gen = mock_get_gen.return_value
        # ì²« ë²ˆì§¸ëŠ” ì‹¤íŒ¨, ë‘ ë²ˆì§¸ëŠ” ì„±ê³µ
        mock_gen.generate = AsyncMock(
            side_effect=[
                GenerationResult(
                    status=GenerationStatus.SCHEMA_FAILURE, error_message="Invalid JSON"
                ),
                GenerationResult(status=GenerationStatus.SUCCESS, output=valid_turn_output),
            ]
        )

        result = await run_repair_loop(sample_turn_input)

        assert result.is_fallback is False
        assert result.repair_attempts == 1
        assert ValidationBadge.SCHEMA_FAIL not in result.badges
        assert ValidationBadge.SCHEMA_OK in result.badges


@pytest.mark.asyncio
async def test_repair_loop_business_failure_then_success(
    sample_turn_input: TurnInput, valid_turn_output: TurnOutput
) -> None:
    """ë¹„ì¦ˆë‹ˆìŠ¤ ë£°(ì–¸ì–´ ë¶ˆì¼ì¹˜) ì‹¤íŒ¨ í›„ ë‘ ë²ˆì§¸ ì‹œë„ì— ì„±ê³µí•˜ëŠ” ì¼€ì´ìŠ¤."""
    invalid_lang_output = valid_turn_output.model_copy(deep=True)
    invalid_lang_output.language = Language.EN  # KO ì…ë ¥ì— EN ì¶œë ¥ (ìœ„ë°˜)

    with patch("unknown_world.orchestrator.repair_loop.get_turn_output_generator") as mock_get_gen:
        mock_gen = mock_get_gen.return_value
        mock_gen.generate = AsyncMock(
            side_effect=[
                GenerationResult(status=GenerationStatus.SUCCESS, output=invalid_lang_output),
                GenerationResult(status=GenerationStatus.SUCCESS, output=valid_turn_output),
            ]
        )

        result = await run_repair_loop(sample_turn_input)

        assert result.is_fallback is False
        assert result.repair_attempts == 1
        # ì²« ì‹œë„ì—ì„œ SCHEMA_OKëŠ” ë°›ì•˜ì§€ë§Œ ë¹„ì¦ˆë‹ˆìŠ¤ ë£°ì—ì„œ ê±¸ë ¤ì•¼ í•¨
        assert result.repair_attempts == 1


@pytest.mark.asyncio
async def test_repair_loop_max_attempts_fallback(sample_turn_input: TurnInput) -> None:
    """ëª¨ë“  ì‹œë„ê°€ ì‹¤íŒ¨í•˜ì—¬ í´ë°±ì´ ë°˜í™˜ë˜ëŠ” ì¼€ì´ìŠ¤."""
    with patch("unknown_world.orchestrator.repair_loop.get_turn_output_generator") as mock_get_gen:
        mock_gen = mock_get_gen.return_value
        # ê³„ì† ìŠ¤í‚¤ë§ˆ ì‹¤íŒ¨
        mock_gen.generate = AsyncMock(
            return_value=GenerationResult(
                status=GenerationStatus.SCHEMA_FAILURE, error_message="Constant failure"
            )
        )

        result = await run_repair_loop(sample_turn_input)

        assert result.is_fallback is True
        assert result.repair_attempts == MAX_REPAIR_ATTEMPTS
        assert ValidationBadge.SCHEMA_FAIL in result.badges
        # í´ë°± ë‚´ëŸ¬í‹°ë¸Œ í™•ì¸
        assert "í˜¼ë€ìŠ¤ëŸ¬ìš´ ìˆœê°„" in result.output.narrative


@pytest.mark.asyncio
async def test_repair_loop_safety_blocked_immediate_fallback(sample_turn_input: TurnInput) -> None:
    """ì•ˆì „ ì°¨ë‹¨ ì‹œ ì¦‰ì‹œ í´ë°±ë˜ëŠ” ì¼€ì´ìŠ¤."""
    with patch("unknown_world.orchestrator.repair_loop.get_turn_output_generator") as mock_get_gen:
        mock_gen = mock_get_gen.return_value
        mock_gen.generate = AsyncMock(
            return_value=GenerationResult(
                status=GenerationStatus.SAFETY_BLOCKED, error_message="Safety block"
            )
        )

        result = await run_repair_loop(sample_turn_input)

        assert result.is_fallback is True
        assert result.repair_attempts == 0  # ì¦‰ì‹œ ì¤‘ë‹¨
        assert ValidationBadge.SAFETY_BLOCKED in result.badges
        assert result.output.safety.blocked is True


@pytest.mark.asyncio
async def test_validate_economy_negative_attempt(sample_turn_input: TurnInput) -> None:
    """ì¬í™”ê°€ ë¶€ì¡±í•œë° ë¹„ìš©ì„ ì²­êµ¬í•˜ì—¬ ìŒìˆ˜ ì”ì•¡ì„ ë§Œë“¤ë ¤ê³  ì‹œë„í•˜ëŠ” ê²½ìš°."""
    # snapshot: signal=100
    # cost: signal=120
    # balance_after: signal=-20 (ìœ„ë°˜)

    invalid_output = TurnOutput(
        language=Language.KO,
        narrative="ë¹„ì‹¼ í–‰ë™",
        ui=UIOutput(action_deck=ActionDeck(cards=[]), objects=[]),
        world=WorldDelta(),
        render=RenderOutput(image_job=None),
        economy=EconomyOutput(
            cost=CurrencyAmount(signal=120, memory_shard=0),
            balance_after=CurrencyAmount(
                signal=0, memory_shard=5
            ),  # 0ìœ¼ë¡œ ì–µì§€ ë³´ì • ë˜ëŠ” ìŒìˆ˜ í•„ë“œ ì˜¤ë¥˜
        ),
        safety=SafetyOutput(blocked=False),
        agent_console=AgentConsole(repair_count=0),
    )

    result = validate_business_rules(sample_turn_input, invalid_output)

    assert result.is_valid is False
    # Signal ì”ì•¡ ë¶ˆì¼ì¹˜ (100 - 120 = -20 ì¸ë° ì‹¤ì œ 0ì´ë¯€ë¡œ mismatch)
    assert any("signal" in err["message"].lower() for err in result.errors)
</file>

<file path="backend/tests/unit/test_u043_language_gate.py">
"""U-043: ì–¸ì–´ í˜¼í•© ê²€ì¦ ë° Repair ë£¨í”„ ë‹¨ìœ„ í…ŒìŠ¤íŠ¸."""

from unittest.mock import AsyncMock, patch

import pytest

from unknown_world.models.turn import (
    ActionCard,
    ActionDeck,
    AgentConsole,
    ClientInfo,
    CurrencyAmount,
    EconomyOutput,
    EconomySnapshot,
    Language,
    RenderOutput,
    SafetyOutput,
    TurnInput,
    TurnOutput,
    UIOutput,
    ValidationBadge,
    WorldDelta,
)
from unknown_world.orchestrator.generate_turn_output import GenerationResult, GenerationStatus
from unknown_world.orchestrator.repair_loop import run_repair_loop
from unknown_world.validation.business_rules import BusinessRuleError, validate_business_rules
from unknown_world.validation.language_gate import (
    measure_language_ratio,
    validate_language_consistency,
)


@pytest.fixture
def sample_turn_input() -> TurnInput:
    return TurnInput(
        language=Language.KO,
        text="í…ŒìŠ¤íŠ¸ ì…ë ¥",
        client=ClientInfo(viewport_w=1920, viewport_h=1080),
        economy_snapshot=EconomySnapshot(signal=100, memory_shard=5),
    )


@pytest.fixture
def base_turn_output(sample_turn_input: TurnInput) -> TurnOutput:
    return TurnOutput(
        language=Language.KO,
        narrative="ì •ìƒì ì¸ í•œêµ­ì–´ ë‚´ëŸ¬í‹°ë¸Œì…ë‹ˆë‹¤.",
        ui=UIOutput(
            action_deck=ActionDeck(
                cards=[
                    ActionCard(
                        id="test",
                        label="í…ŒìŠ¤íŠ¸ ì¹´ë“œ",
                        cost=CurrencyAmount(signal=10, memory_shard=0),
                    )
                ]
            ),
            objects=[],
        ),
        world=WorldDelta(),
        render=RenderOutput(image_job=None),
        economy=EconomyOutput(
            cost=CurrencyAmount(signal=10, memory_shard=0),
            balance_after=CurrencyAmount(signal=90, memory_shard=5),
        ),
        safety=SafetyOutput(blocked=False),
        agent_console=AgentConsole(repair_count=0),
    )


def test_measure_language_ratio_ko():
    """í•œêµ­ì–´ í…ìŠ¤íŠ¸ì˜ ì–¸ì–´ ë¹„ìœ¨ ì¸¡ì • í…ŒìŠ¤íŠ¸."""
    text = "ì•ˆë…•í•˜ì„¸ìš”. ì´ê²ƒì€ í…ŒìŠ¤íŠ¸ì…ë‹ˆë‹¤."
    ratio = measure_language_ratio(text)
    assert ratio.hangul_ratio > 0.8
    assert ratio.latin_ratio < 0.2


def test_measure_language_ratio_en():
    """ì˜ì–´ í…ìŠ¤íŠ¸ì˜ ì–¸ì–´ ë¹„ìœ¨ ì¸¡ì • í…ŒìŠ¤íŠ¸."""
    text = "Hello. This is a test."
    ratio = measure_language_ratio(text)
    assert ratio.latin_ratio > 0.8
    assert ratio.hangul_ratio == 0.0


def test_measure_language_ratio_mixed():
    """í˜¼í•©ëœ í…ìŠ¤íŠ¸ì˜ ì–¸ì–´ ë¹„ìœ¨ ì¸¡ì • í…ŒìŠ¤íŠ¸."""
    text = "ì•ˆë…•í•˜ì„¸ìš”. This is a mixed text."
    ratio = measure_language_ratio(text)
    assert ratio.hangul_count > 0
    assert ratio.latin_count > 0


def test_measure_language_ratio_whitelist():
    """í™”ì´íŠ¸ë¦¬ìŠ¤íŠ¸ ë‹¨ì–´ê°€ ë¹„ìœ¨ ì¸¡ì •ì—ì„œ ì œì™¸ë˜ëŠ”ì§€ í…ŒìŠ¤íŠ¸."""
    # "Signal"ì€ í™”ì´íŠ¸ë¦¬ìŠ¤íŠ¸ì— ìˆìœ¼ë¯€ë¡œ ë¼í‹´ ì¹´ìš´íŠ¸ì—ì„œ ì œì™¸ë˜ì–´ì•¼ í•¨
    text = "Signalì´ ê°ì§€ë˜ì—ˆìŠµë‹ˆë‹¤."
    ratio = measure_language_ratio(text)
    # "ì´ ê°ì§€ë˜ì—ˆìŠµë‹ˆë‹¤" (í•œê¸€ 7ì + ê³µë°± 1ì) -> í•œê¸€ 7
    # "signal" ì œê±°ë¨. "i" ë‚¨ìŒ?
    # re.sub(rf"(?<![a-zA-Z]){re.escape(term)}(?![a-zA-Z])", "", ...)
    # "signal" -> ""
    # "ì´ ê°ì§€ë˜ì—ˆìŠµë‹ˆë‹¤." ë§Œ ë‚¨ìŒ
    assert ratio.latin_count == 0
    assert ratio.hangul_count > 0


def test_validate_language_consistency_mixed_ko(base_turn_output):
    """í•œêµ­ì–´ ìš”ì²­ì— ì˜ì–´ê°€ ì„ì¸ ê²½ìš° ê²€ì¦ í…ŒìŠ¤íŠ¸."""
    # 1. narrative
    mixed_output = base_turn_output.model_copy(deep=True)
    mixed_output.narrative = "ì´ê²ƒì€ í•œêµ­ì–´ì¸ë° Suddenly English appeared."
    result = validate_language_consistency(mixed_output, Language.KO)
    assert result.is_valid is False
    assert any(v["field"] == "narrative" for v in result.violations)

    # 2. action_deck.cards[0].label
    mixed_output = base_turn_output.model_copy(deep=True)
    mixed_output.ui.action_deck.cards[0].label = "Mixed Label ì˜ì–´"
    result = validate_language_consistency(mixed_output, Language.KO)
    assert result.is_valid is False
    assert any(v["field"] == "ui.action_deck.cards[0].label" for v in result.violations)

    # 3. safety.message
    mixed_output = base_turn_output.model_copy(deep=True)
    mixed_output.safety.message = "This is a blocked message in English."
    result = validate_language_consistency(mixed_output, Language.KO)
    assert result.is_valid is False
    assert any(v["field"] == "safety.message" for v in result.violations)


def test_validate_language_consistency_en_with_ko(base_turn_output):
    """ì˜ì–´ ìš”ì²­ì— í•œêµ­ì–´ê°€ ì„ì¸ ê²½ìš° ê²€ì¦ í…ŒìŠ¤íŠ¸."""
    en_input_lang = Language.EN
    en_output = base_turn_output.model_copy(deep=True)
    en_output.language = Language.EN
    en_output.narrative = "This is English but í•œêµ­ì–´ê°€ ì„ì„."

    result = validate_language_consistency(en_output, en_input_lang)
    assert result.is_valid is False
    assert any(v["field"] == "narrative" for v in result.violations)


def test_build_language_error_summary_ko(base_turn_output):
    """í•œêµ­ì–´ ì—ëŸ¬ ìš”ì•½ ìƒì„± í…ŒìŠ¤íŠ¸."""
    from unknown_world.validation.language_gate import build_language_error_summary

    mixed_output = base_turn_output.model_copy(deep=True)
    mixed_output.narrative = "Mixed English."
    result = validate_language_consistency(mixed_output, Language.KO)

    summary = build_language_error_summary(result)
    assert "ì–¸ì–´ í˜¼í•©ì´ ê°ì§€ë˜ì—ˆìŠµë‹ˆë‹¤" in summary
    assert "narrative" in summary
    assert "í•œêµ­ì–´(ko-KR)ë¡œ ë‹¤ì‹œ ì‘ì„±í•˜ì„¸ìš”" in summary


def test_validate_business_rules_language_content_mixed(sample_turn_input, base_turn_output):
    """ë¹„ì¦ˆë‹ˆìŠ¤ ë£° ê²€ì¦ì—ì„œ ì–¸ì–´ í˜¼í•© ê°ì§€ í…ŒìŠ¤íŠ¸."""
    mixed_output = base_turn_output.model_copy(deep=True)
    mixed_output.narrative = "í•œêµ­ì–´ì™€ Englishê°€ ì„ì—¬ ìˆìŠµë‹ˆë‹¤. This should fail."

    result = validate_business_rules(sample_turn_input, mixed_output)
    assert result.is_valid is False
    assert any(err["type"] == BusinessRuleError.LANGUAGE_CONTENT_MIXED for err in result.errors)


@pytest.mark.asyncio
async def test_repair_loop_fixes_language_mixing(sample_turn_input, base_turn_output):
    """ì–¸ì–´ í˜¼í•© ì‹œ Repair ë£¨í”„ê°€ ì‘ë™í•˜ì—¬ ìˆ˜ì •ë˜ëŠ”ì§€ í…ŒìŠ¤íŠ¸."""
    mixed_output = base_turn_output.model_copy(deep=True)
    mixed_output.narrative = "í˜¼í•©ëœ ì–¸ì–´ English Mixed."

    valid_output = base_turn_output.model_copy(deep=True)
    valid_output.narrative = "ìˆ˜ì •ëœ í•œêµ­ì–´ ë‚´ëŸ¬í‹°ë¸Œ"

    with patch("unknown_world.orchestrator.repair_loop.get_turn_output_generator") as mock_get_gen:
        mock_gen = mock_get_gen.return_value
        # ì²« ë²ˆì§¸ëŠ” í˜¼í•© ì¶œë ¥, ë‘ ë²ˆì§¸ëŠ” ì •ìƒ ì¶œë ¥ ë°˜í™˜
        mock_gen.generate = AsyncMock(
            side_effect=[
                GenerationResult(status=GenerationStatus.SUCCESS, output=mixed_output),
                GenerationResult(status=GenerationStatus.SUCCESS, output=valid_output),
            ]
        )

        result = await run_repair_loop(sample_turn_input)

        assert result.repair_attempts == 1
        assert result.output.narrative == "ìˆ˜ì •ëœ í•œêµ­ì–´ ë‚´ëŸ¬í‹°ë¸Œ"
        assert ValidationBadge.CONSISTENCY_OK in result.badges
        assert ValidationBadge.CONSISTENCY_FAIL not in result.badges  # ìµœì¢… ë°°ì§€ëŠ” OKì—¬ì•¼ í•¨
</file>

<file path="frontend/coverage/block-navigation.js">
/* eslint-disable */
var jumpToCode = (function init() {
    // Classes of code we would like to highlight in the file view
    var missingCoverageClasses = ['.cbranch-no', '.cstat-no', '.fstat-no'];

    // Elements to highlight in the file listing view
    var fileListingElements = ['td.pct.low'];

    // We don't want to select elements that are direct descendants of another match
    var notSelector = ':not(' + missingCoverageClasses.join('):not(') + ') > '; // becomes `:not(a):not(b) > `

    // Selector that finds elements on the page to which we can jump
    var selector =
        fileListingElements.join(', ') +
        ', ' +
        notSelector +
        missingCoverageClasses.join(', ' + notSelector); // becomes `:not(a):not(b) > a, :not(a):not(b) > b`

    // The NodeList of matching elements
    var missingCoverageElements = document.querySelectorAll(selector);

    var currentIndex;

    function toggleClass(index) {
        missingCoverageElements
            .item(currentIndex)
            .classList.remove('highlighted');
        missingCoverageElements.item(index).classList.add('highlighted');
    }

    function makeCurrent(index) {
        toggleClass(index);
        currentIndex = index;
        missingCoverageElements.item(index).scrollIntoView({
            behavior: 'smooth',
            block: 'center',
            inline: 'center'
        });
    }

    function goToPrevious() {
        var nextIndex = 0;
        if (typeof currentIndex !== 'number' || currentIndex === 0) {
            nextIndex = missingCoverageElements.length - 1;
        } else if (missingCoverageElements.length > 1) {
            nextIndex = currentIndex - 1;
        }

        makeCurrent(nextIndex);
    }

    function goToNext() {
        var nextIndex = 0;

        if (
            typeof currentIndex === 'number' &&
            currentIndex < missingCoverageElements.length - 1
        ) {
            nextIndex = currentIndex + 1;
        }

        makeCurrent(nextIndex);
    }

    return function jump(event) {
        if (
            document.getElementById('fileSearch') === document.activeElement &&
            document.activeElement != null
        ) {
            // if we're currently focused on the search input, we don't want to navigate
            return;
        }

        switch (event.which) {
            case 78: // n
            case 74: // j
                goToNext();
                break;
            case 66: // b
            case 75: // k
            case 80: // p
                goToPrevious();
                break;
        }
    };
})();
window.addEventListener('keydown', jumpToCode);
</file>

<file path="frontend/coverage/coverage-final.json">
{"D:\\Dev\\unknown-world\\frontend\\src\\schemas\\turn.ts": {"path":"D:\\Dev\\unknown-world\\frontend\\src\\schemas\\turn.ts","statementMap":{"0":{"start":{"line":30,"column":30},"end":{"line":30,"column":null}},"1":{"start":{"line":41,"column":30},"end":{"line":41,"column":null}},"2":{"start":{"line":47,"column":27},"end":{"line":47,"column":null}},"3":{"start":{"line":54,"column":32},"end":{"line":62,"column":null}},"4":{"start":{"line":69,"column":37},"end":{"line":78,"column":null}},"5":{"start":{"line":85,"column":32},"end":{"line":85,"column":null}},"6":{"start":{"line":91,"column":31},"end":{"line":91,"column":null}},"7":{"start":{"line":102,"column":32},"end":{"line":107,"column":null}},"8":{"start":{"line":115,"column":27},"end":{"line":122,"column":null}},"9":{"start":{"line":129,"column":36},"end":{"line":138,"column":null}},"10":{"start":{"line":149,"column":32},"end":{"line":156,"column":null}},"11":{"start":{"line":162,"column":32},"end":{"line":176,"column":null}},"12":{"start":{"line":183,"column":37},"end":{"line":192,"column":null}},"13":{"start":{"line":199,"column":31},"end":{"line":209,"column":null}},"14":{"start":{"line":220,"column":32},"end":{"line":229,"column":null}},"15":{"start":{"line":236,"column":33},"end":{"line":247,"column":null}},"16":{"start":{"line":254,"column":32},"end":{"line":262,"column":null}},"17":{"start":{"line":270,"column":30},"end":{"line":278,"column":null}},"18":{"start":{"line":289,"column":31},"end":{"line":295,"column":null}},"19":{"start":{"line":302,"column":31},"end":{"line":312,"column":null}},"20":{"start":{"line":319,"column":27},"end":{"line":325,"column":null}},"21":{"start":{"line":332,"column":32},"end":{"line":359,"column":null}},"22":{"start":{"line":370,"column":30},"end":{"line":382,"column":null}},"23":{"start":{"line":389,"column":34},"end":{"line":395,"column":null}},"24":{"start":{"line":407,"column":35},"end":{"line":412,"column":null}},"25":{"start":{"line":424,"column":34},"end":{"line":436,"column":null}},"26":{"start":{"line":447,"column":34},"end":{"line":453,"column":null}},"27":{"start":{"line":469,"column":32},"end":{"line":502,"column":null}},"28":{"start":{"line":523,"column":4},"end":{"line":525,"column":null}},"29":{"start":{"line":528,"column":4},"end":{"line":530,"column":null}},"30":{"start":{"line":532,"column":2},"end":{"line":563,"column":null}},"31":{"start":{"line":590,"column":17},"end":{"line":590,"column":null}},"32":{"start":{"line":592,"column":2},"end":{"line":594,"column":null}},"33":{"start":{"line":593,"column":4},"end":{"line":593,"column":null}},"34":{"start":{"line":596,"column":2},"end":{"line":600,"column":null}},"35":{"start":{"line":611,"column":2},"end":{"line":611,"column":null}},"36":{"start":{"line":625,"column":2},"end":{"line":625,"column":null}}},"fnMap":{"0":{"name":"createFallbackTurnOutput","decl":{"start":{"line":517,"column":16},"end":{"line":517,"column":null}},"loc":{"start":{"line":521,"column":14},"end":{"line":564,"column":null}},"line":521},"1":{"name":"safeParseTurnOutput","decl":{"start":{"line":585,"column":16},"end":{"line":585,"column":null}},"loc":{"start":{"line":589,"column":25},"end":{"line":601,"column":null}},"line":589},"2":{"name":"parseTurnInput","decl":{"start":{"line":610,"column":16},"end":{"line":610,"column":31}},"loc":{"start":{"line":610,"column":57},"end":{"line":612,"column":null}},"line":610},"3":{"name":"safeParseTurnInput","decl":{"start":{"line":624,"column":16},"end":{"line":624,"column":35}},"loc":{"start":{"line":624,"column":76},"end":{"line":626,"column":null}},"line":624}},"branchMap":{"0":{"loc":{"start":{"line":519,"column":2},"end":{"line":519,"column":null}},"type":"default-arg","locations":[{"start":{"line":519,"column":24},"end":{"line":519,"column":null}}],"line":519},"1":{"loc":{"start":{"line":523,"column":4},"end":{"line":525,"column":null}},"type":"cond-expr","locations":[{"start":{"line":524,"column":8},"end":{"line":524,"column":null}},{"start":{"line":525,"column":8},"end":{"line":525,"column":null}}],"line":523},"2":{"loc":{"start":{"line":528,"column":4},"end":{"line":530,"column":null}},"type":"cond-expr","locations":[{"start":{"line":529,"column":8},"end":{"line":529,"column":null}},{"start":{"line":530,"column":8},"end":{"line":530,"column":null}}],"line":528},"3":{"loc":{"start":{"line":534,"column":15},"end":{"line":534,"column":null}},"type":"binary-expr","locations":[{"start":{"line":534,"column":15},"end":{"line":534,"column":31}},{"start":{"line":534,"column":31},"end":{"line":534,"column":null}}],"line":534},"4":{"loc":{"start":{"line":587,"column":2},"end":{"line":587,"column":null}},"type":"default-arg","locations":[{"start":{"line":587,"column":23},"end":{"line":587,"column":null}}],"line":587},"5":{"loc":{"start":{"line":588,"column":2},"end":{"line":588,"column":null}},"type":"default-arg","locations":[{"start":{"line":588,"column":24},"end":{"line":588,"column":null}}],"line":588},"6":{"loc":{"start":{"line":592,"column":2},"end":{"line":594,"column":null}},"type":"if","locations":[{"start":{"line":592,"column":2},"end":{"line":594,"column":null}},{"start":{},"end":{}}],"line":592}},"s":{"0":1,"1":1,"2":1,"3":1,"4":1,"5":1,"6":1,"7":1,"8":1,"9":1,"10":1,"11":1,"12":1,"13":1,"14":1,"15":1,"16":1,"17":1,"18":1,"19":1,"20":1,"21":1,"22":1,"23":1,"24":1,"25":1,"26":1,"27":1,"28":1,"29":1,"30":1,"31":2,"32":2,"33":1,"34":1,"35":2,"36":2},"f":{"0":1,"1":2,"2":2,"3":2},"b":{"0":[1],"1":[1,0],"2":[1,0],"3":[1,1],"4":[2],"5":[2],"6":[1,1]},"meta":{"lastBranch":7,"lastFunction":4,"lastStatement":37,"seen":{"s:30:30:30:Infinity":0,"s:41:30:41:Infinity":1,"s:47:27:47:Infinity":2,"s:54:32:62:Infinity":3,"s:69:37:78:Infinity":4,"s:85:32:85:Infinity":5,"s:91:31:91:Infinity":6,"s:102:32:107:Infinity":7,"s:115:27:122:Infinity":8,"s:129:36:138:Infinity":9,"s:149:32:156:Infinity":10,"s:162:32:176:Infinity":11,"s:183:37:192:Infinity":12,"s:199:31:209:Infinity":13,"s:220:32:229:Infinity":14,"s:236:33:247:Infinity":15,"s:254:32:262:Infinity":16,"s:270:30:278:Infinity":17,"s:289:31:295:Infinity":18,"s:302:31:312:Infinity":19,"s:319:27:325:Infinity":20,"s:332:32:359:Infinity":21,"s:370:30:382:Infinity":22,"s:389:34:395:Infinity":23,"s:407:35:412:Infinity":24,"s:424:34:436:Infinity":25,"s:447:34:453:Infinity":26,"s:469:32:502:Infinity":27,"f:517:16:517:Infinity":0,"b:519:24:519:Infinity":0,"s:523:4:525:Infinity":28,"b:524:8:524:Infinity:525:8:525:Infinity":1,"s:528:4:530:Infinity":29,"b:529:8:529:Infinity:530:8:530:Infinity":2,"s:532:2:563:Infinity":30,"b:534:15:534:31:534:31:534:Infinity":3,"f:585:16:585:Infinity":1,"b:587:23:587:Infinity":4,"b:588:24:588:Infinity":5,"s:590:17:590:Infinity":31,"b:592:2:594:Infinity:undefined:undefined:undefined:undefined":6,"s:592:2:594:Infinity":32,"s:593:4:593:Infinity":33,"s:596:2:600:Infinity":34,"f:610:16:610:31":2,"s:611:2:611:Infinity":35,"f:624:16:624:35":3,"s:625:2:625:Infinity":36}}}
}
</file>

<file path="frontend/coverage/prettify.js">
/* eslint-disable */
window.PR_SHOULD_USE_CONTINUATION=true;(function(){var h=["break,continue,do,else,for,if,return,while"];var u=[h,"auto,case,char,const,default,double,enum,extern,float,goto,int,long,register,short,signed,sizeof,static,struct,switch,typedef,union,unsigned,void,volatile"];var p=[u,"catch,class,delete,false,import,new,operator,private,protected,public,this,throw,true,try,typeof"];var l=[p,"alignof,align_union,asm,axiom,bool,concept,concept_map,const_cast,constexpr,decltype,dynamic_cast,explicit,export,friend,inline,late_check,mutable,namespace,nullptr,reinterpret_cast,static_assert,static_cast,template,typeid,typename,using,virtual,where"];var x=[p,"abstract,boolean,byte,extends,final,finally,implements,import,instanceof,null,native,package,strictfp,super,synchronized,throws,transient"];var R=[x,"as,base,by,checked,decimal,delegate,descending,dynamic,event,fixed,foreach,from,group,implicit,in,interface,internal,into,is,lock,object,out,override,orderby,params,partial,readonly,ref,sbyte,sealed,stackalloc,string,select,uint,ulong,unchecked,unsafe,ushort,var"];var r="all,and,by,catch,class,else,extends,false,finally,for,if,in,is,isnt,loop,new,no,not,null,of,off,on,or,return,super,then,true,try,unless,until,when,while,yes";var w=[p,"debugger,eval,export,function,get,null,set,undefined,var,with,Infinity,NaN"];var s="caller,delete,die,do,dump,elsif,eval,exit,foreach,for,goto,if,import,last,local,my,next,no,our,print,package,redo,require,sub,undef,unless,until,use,wantarray,while,BEGIN,END";var I=[h,"and,as,assert,class,def,del,elif,except,exec,finally,from,global,import,in,is,lambda,nonlocal,not,or,pass,print,raise,try,with,yield,False,True,None"];var f=[h,"alias,and,begin,case,class,def,defined,elsif,end,ensure,false,in,module,next,nil,not,or,redo,rescue,retry,self,super,then,true,undef,unless,until,when,yield,BEGIN,END"];var H=[h,"case,done,elif,esac,eval,fi,function,in,local,set,then,until"];var A=[l,R,w,s+I,f,H];var e=/^(DIR|FILE|vector|(de|priority_)?queue|list|stack|(const_)?iterator|(multi)?(set|map)|bitset|u?(int|float)\d*)/;var C="str";var z="kwd";var j="com";var O="typ";var G="lit";var L="pun";var F="pln";var m="tag";var E="dec";var J="src";var P="atn";var n="atv";var N="nocode";var M="(?:^^\\.?|[+-]|\\!|\\!=|\\!==|\\#|\\%|\\%=|&|&&|&&=|&=|\\(|\\*|\\*=|\\+=|\\,|\\-=|\\->|\\/|\\/=|:|::|\\;|<|<<|<<=|<=|=|==|===|>|>=|>>|>>=|>>>|>>>=|\\?|\\@|\\[|\\^|\\^=|\\^\\^|\\^\\^=|\\{|\\||\\|=|\\|\\||\\|\\|=|\\~|break|case|continue|delete|do|else|finally|instanceof|return|throw|try|typeof)\\s*";function k(Z){var ad=0;var S=false;var ac=false;for(var V=0,U=Z.length;V<U;++V){var ae=Z[V];if(ae.ignoreCase){ac=true}else{if(/[a-z]/i.test(ae.source.replace(/\\u[0-9a-f]{4}|\\x[0-9a-f]{2}|\\[^ux]/gi,""))){S=true;ac=false;break}}}var Y={b:8,t:9,n:10,v:11,f:12,r:13};function ab(ah){var ag=ah.charCodeAt(0);if(ag!==92){return ag}var af=ah.charAt(1);ag=Y[af];if(ag){return ag}else{if("0"<=af&&af<="7"){return parseInt(ah.substring(1),8)}else{if(af==="u"||af==="x"){return parseInt(ah.substring(2),16)}else{return ah.charCodeAt(1)}}}}function T(af){if(af<32){return(af<16?"\\x0":"\\x")+af.toString(16)}var ag=String.fromCharCode(af);if(ag==="\\"||ag==="-"||ag==="["||ag==="]"){ag="\\"+ag}return ag}function X(am){var aq=am.substring(1,am.length-1).match(new RegExp("\\\\u[0-9A-Fa-f]{4}|\\\\x[0-9A-Fa-f]{2}|\\\\[0-3][0-7]{0,2}|\\\\[0-7]{1,2}|\\\\[\\s\\S]|-|[^-\\\\]","g"));var ak=[];var af=[];var ao=aq[0]==="^";for(var ar=ao?1:0,aj=aq.length;ar<aj;++ar){var ah=aq[ar];if(/\\[bdsw]/i.test(ah)){ak.push(ah)}else{var ag=ab(ah);var al;if(ar+2<aj&&"-"===aq[ar+1]){al=ab(aq[ar+2]);ar+=2}else{al=ag}af.push([ag,al]);if(!(al<65||ag>122)){if(!(al<65||ag>90)){af.push([Math.max(65,ag)|32,Math.min(al,90)|32])}if(!(al<97||ag>122)){af.push([Math.max(97,ag)&~32,Math.min(al,122)&~32])}}}}af.sort(function(av,au){return(av[0]-au[0])||(au[1]-av[1])});var ai=[];var ap=[NaN,NaN];for(var ar=0;ar<af.length;++ar){var at=af[ar];if(at[0]<=ap[1]+1){ap[1]=Math.max(ap[1],at[1])}else{ai.push(ap=at)}}var an=["["];if(ao){an.push("^")}an.push.apply(an,ak);for(var ar=0;ar<ai.length;++ar){var at=ai[ar];an.push(T(at[0]));if(at[1]>at[0]){if(at[1]+1>at[0]){an.push("-")}an.push(T(at[1]))}}an.push("]");return an.join("")}function W(al){var aj=al.source.match(new RegExp("(?:\\[(?:[^\\x5C\\x5D]|\\\\[\\s\\S])*\\]|\\\\u[A-Fa-f0-9]{4}|\\\\x[A-Fa-f0-9]{2}|\\\\[0-9]+|\\\\[^ux0-9]|\\(\\?[:!=]|[\\(\\)\\^]|[^\\x5B\\x5C\\(\\)\\^]+)","g"));var ah=aj.length;var an=[];for(var ak=0,am=0;ak<ah;++ak){var ag=aj[ak];if(ag==="("){++am}else{if("\\"===ag.charAt(0)){var af=+ag.substring(1);if(af&&af<=am){an[af]=-1}}}}for(var ak=1;ak<an.length;++ak){if(-1===an[ak]){an[ak]=++ad}}for(var ak=0,am=0;ak<ah;++ak){var ag=aj[ak];if(ag==="("){++am;if(an[am]===undefined){aj[ak]="(?:"}}else{if("\\"===ag.charAt(0)){var af=+ag.substring(1);if(af&&af<=am){aj[ak]="\\"+an[am]}}}}for(var ak=0,am=0;ak<ah;++ak){if("^"===aj[ak]&&"^"!==aj[ak+1]){aj[ak]=""}}if(al.ignoreCase&&S){for(var ak=0;ak<ah;++ak){var ag=aj[ak];var ai=ag.charAt(0);if(ag.length>=2&&ai==="["){aj[ak]=X(ag)}else{if(ai!=="\\"){aj[ak]=ag.replace(/[a-zA-Z]/g,function(ao){var ap=ao.charCodeAt(0);return"["+String.fromCharCode(ap&~32,ap|32)+"]"})}}}}return aj.join("")}var aa=[];for(var V=0,U=Z.length;V<U;++V){var ae=Z[V];if(ae.global||ae.multiline){throw new Error(""+ae)}aa.push("(?:"+W(ae)+")")}return new RegExp(aa.join("|"),ac?"gi":"g")}function a(V){var U=/(?:^|\s)nocode(?:\s|$)/;var X=[];var T=0;var Z=[];var W=0;var S;if(V.currentStyle){S=V.currentStyle.whiteSpace}else{if(window.getComputedStyle){S=document.defaultView.getComputedStyle(V,null).getPropertyValue("white-space")}}var Y=S&&"pre"===S.substring(0,3);function aa(ab){switch(ab.nodeType){case 1:if(U.test(ab.className)){return}for(var ae=ab.firstChild;ae;ae=ae.nextSibling){aa(ae)}var ad=ab.nodeName;if("BR"===ad||"LI"===ad){X[W]="\n";Z[W<<1]=T++;Z[(W++<<1)|1]=ab}break;case 3:case 4:var ac=ab.nodeValue;if(ac.length){if(!Y){ac=ac.replace(/[ \t\r\n]+/g," ")}else{ac=ac.replace(/\r\n?/g,"\n")}X[W]=ac;Z[W<<1]=T;T+=ac.length;Z[(W++<<1)|1]=ab}break}}aa(V);return{sourceCode:X.join("").replace(/\n$/,""),spans:Z}}function B(S,U,W,T){if(!U){return}var V={sourceCode:U,basePos:S};W(V);T.push.apply(T,V.decorations)}var v=/\S/;function o(S){var V=undefined;for(var U=S.firstChild;U;U=U.nextSibling){var T=U.nodeType;V=(T===1)?(V?S:U):(T===3)?(v.test(U.nodeValue)?S:V):V}return V===S?undefined:V}function g(U,T){var S={};var V;(function(){var ad=U.concat(T);var ah=[];var ag={};for(var ab=0,Z=ad.length;ab<Z;++ab){var Y=ad[ab];var ac=Y[3];if(ac){for(var ae=ac.length;--ae>=0;){S[ac.charAt(ae)]=Y}}var af=Y[1];var aa=""+af;if(!ag.hasOwnProperty(aa)){ah.push(af);ag[aa]=null}}ah.push(/[\0-\uffff]/);V=k(ah)})();var X=T.length;var W=function(ah){var Z=ah.sourceCode,Y=ah.basePos;var ad=[Y,F];var af=0;var an=Z.match(V)||[];var aj={};for(var ae=0,aq=an.length;ae<aq;++ae){var ag=an[ae];var ap=aj[ag];var ai=void 0;var am;if(typeof ap==="string"){am=false}else{var aa=S[ag.charAt(0)];if(aa){ai=ag.match(aa[1]);ap=aa[0]}else{for(var ao=0;ao<X;++ao){aa=T[ao];ai=ag.match(aa[1]);if(ai){ap=aa[0];break}}if(!ai){ap=F}}am=ap.length>=5&&"lang-"===ap.substring(0,5);if(am&&!(ai&&typeof ai[1]==="string")){am=false;ap=J}if(!am){aj[ag]=ap}}var ab=af;af+=ag.length;if(!am){ad.push(Y+ab,ap)}else{var al=ai[1];var ak=ag.indexOf(al);var ac=ak+al.length;if(ai[2]){ac=ag.length-ai[2].length;ak=ac-al.length}var ar=ap.substring(5);B(Y+ab,ag.substring(0,ak),W,ad);B(Y+ab+ak,al,q(ar,al),ad);B(Y+ab+ac,ag.substring(ac),W,ad)}}ah.decorations=ad};return W}function i(T){var W=[],S=[];if(T.tripleQuotedStrings){W.push([C,/^(?:\'\'\'(?:[^\'\\]|\\[\s\S]|\'{1,2}(?=[^\']))*(?:\'\'\'|$)|\"\"\"(?:[^\"\\]|\\[\s\S]|\"{1,2}(?=[^\"]))*(?:\"\"\"|$)|\'(?:[^\\\']|\\[\s\S])*(?:\'|$)|\"(?:[^\\\"]|\\[\s\S])*(?:\"|$))/,null,"'\""])}else{if(T.multiLineStrings){W.push([C,/^(?:\'(?:[^\\\']|\\[\s\S])*(?:\'|$)|\"(?:[^\\\"]|\\[\s\S])*(?:\"|$)|\`(?:[^\\\`]|\\[\s\S])*(?:\`|$))/,null,"'\"`"])}else{W.push([C,/^(?:\'(?:[^\\\'\r\n]|\\.)*(?:\'|$)|\"(?:[^\\\"\r\n]|\\.)*(?:\"|$))/,null,"\"'"])}}if(T.verbatimStrings){S.push([C,/^@\"(?:[^\"]|\"\")*(?:\"|$)/,null])}var Y=T.hashComments;if(Y){if(T.cStyleComments){if(Y>1){W.push([j,/^#(?:##(?:[^#]|#(?!##))*(?:###|$)|.*)/,null,"#"])}else{W.push([j,/^#(?:(?:define|elif|else|endif|error|ifdef|include|ifndef|line|pragma|undef|warning)\b|[^\r\n]*)/,null,"#"])}S.push([C,/^<(?:(?:(?:\.\.\/)*|\/?)(?:[\w-]+(?:\/[\w-]+)+)?[\w-]+\.h|[a-z]\w*)>/,null])}else{W.push([j,/^#[^\r\n]*/,null,"#"])}}if(T.cStyleComments){S.push([j,/^\/\/[^\r\n]*/,null]);S.push([j,/^\/\*[\s\S]*?(?:\*\/|$)/,null])}if(T.regexLiterals){var X=("/(?=[^/*])(?:[^/\\x5B\\x5C]|\\x5C[\\s\\S]|\\x5B(?:[^\\x5C\\x5D]|\\x5C[\\s\\S])*(?:\\x5D|$))+/");S.push(["lang-regex",new RegExp("^"+M+"("+X+")")])}var V=T.types;if(V){S.push([O,V])}var U=(""+T.keywords).replace(/^ | $/g,"");if(U.length){S.push([z,new RegExp("^(?:"+U.replace(/[\s,]+/g,"|")+")\\b"),null])}W.push([F,/^\s+/,null," \r\n\t\xA0"]);S.push([G,/^@[a-z_$][a-z_$@0-9]*/i,null],[O,/^(?:[@_]?[A-Z]+[a-z][A-Za-z_$@0-9]*|\w+_t\b)/,null],[F,/^[a-z_$][a-z_$@0-9]*/i,null],[G,new RegExp("^(?:0x[a-f0-9]+|(?:\\d(?:_\\d+)*\\d*(?:\\.\\d*)?|\\.\\d\\+)(?:e[+\\-]?\\d+)?)[a-z]*","i"),null,"0123456789"],[F,/^\\[\s\S]?/,null],[L,/^.[^\s\w\.$@\'\"\`\/\#\\]*/,null]);return g(W,S)}var K=i({keywords:A,hashComments:true,cStyleComments:true,multiLineStrings:true,regexLiterals:true});function Q(V,ag){var U=/(?:^|\s)nocode(?:\s|$)/;var ab=/\r\n?|\n/;var ac=V.ownerDocument;var S;if(V.currentStyle){S=V.currentStyle.whiteSpace}else{if(window.getComputedStyle){S=ac.defaultView.getComputedStyle(V,null).getPropertyValue("white-space")}}var Z=S&&"pre"===S.substring(0,3);var af=ac.createElement("LI");while(V.firstChild){af.appendChild(V.firstChild)}var W=[af];function ae(al){switch(al.nodeType){case 1:if(U.test(al.className)){break}if("BR"===al.nodeName){ad(al);if(al.parentNode){al.parentNode.removeChild(al)}}else{for(var an=al.firstChild;an;an=an.nextSibling){ae(an)}}break;case 3:case 4:if(Z){var am=al.nodeValue;var aj=am.match(ab);if(aj){var ai=am.substring(0,aj.index);al.nodeValue=ai;var ah=am.substring(aj.index+aj[0].length);if(ah){var ak=al.parentNode;ak.insertBefore(ac.createTextNode(ah),al.nextSibling)}ad(al);if(!ai){al.parentNode.removeChild(al)}}}break}}function ad(ak){while(!ak.nextSibling){ak=ak.parentNode;if(!ak){return}}function ai(al,ar){var aq=ar?al.cloneNode(false):al;var ao=al.parentNode;if(ao){var ap=ai(ao,1);var an=al.nextSibling;ap.appendChild(aq);for(var am=an;am;am=an){an=am.nextSibling;ap.appendChild(am)}}return aq}var ah=ai(ak.nextSibling,0);for(var aj;(aj=ah.parentNode)&&aj.nodeType===1;){ah=aj}W.push(ah)}for(var Y=0;Y<W.length;++Y){ae(W[Y])}if(ag===(ag|0)){W[0].setAttribute("value",ag)}var aa=ac.createElement("OL");aa.className="linenums";var X=Math.max(0,((ag-1))|0)||0;for(var Y=0,T=W.length;Y<T;++Y){af=W[Y];af.className="L"+((Y+X)%10);if(!af.firstChild){af.appendChild(ac.createTextNode("\xA0"))}aa.appendChild(af)}V.appendChild(aa)}function D(ac){var aj=/\bMSIE\b/.test(navigator.userAgent);var am=/\n/g;var al=ac.sourceCode;var an=al.length;var V=0;var aa=ac.spans;var T=aa.length;var ah=0;var X=ac.decorations;var Y=X.length;var Z=0;X[Y]=an;var ar,aq;for(aq=ar=0;aq<Y;){if(X[aq]!==X[aq+2]){X[ar++]=X[aq++];X[ar++]=X[aq++]}else{aq+=2}}Y=ar;for(aq=ar=0;aq<Y;){var at=X[aq];var ab=X[aq+1];var W=aq+2;while(W+2<=Y&&X[W+1]===ab){W+=2}X[ar++]=at;X[ar++]=ab;aq=W}Y=X.length=ar;var ae=null;while(ah<T){var af=aa[ah];var S=aa[ah+2]||an;var ag=X[Z];var ap=X[Z+2]||an;var W=Math.min(S,ap);var ak=aa[ah+1];var U;if(ak.nodeType!==1&&(U=al.substring(V,W))){if(aj){U=U.replace(am,"\r")}ak.nodeValue=U;var ai=ak.ownerDocument;var ao=ai.createElement("SPAN");ao.className=X[Z+1];var ad=ak.parentNode;ad.replaceChild(ao,ak);ao.appendChild(ak);if(V<S){aa[ah+1]=ak=ai.createTextNode(al.substring(W,S));ad.insertBefore(ak,ao.nextSibling)}}V=W;if(V>=S){ah+=2}if(V>=ap){Z+=2}}}var t={};function c(U,V){for(var S=V.length;--S>=0;){var T=V[S];if(!t.hasOwnProperty(T)){t[T]=U}else{if(window.console){console.warn("cannot override language handler %s",T)}}}}function q(T,S){if(!(T&&t.hasOwnProperty(T))){T=/^\s*</.test(S)?"default-markup":"default-code"}return t[T]}c(K,["default-code"]);c(g([],[[F,/^[^<?]+/],[E,/^<!\w[^>]*(?:>|$)/],[j,/^<\!--[\s\S]*?(?:-\->|$)/],["lang-",/^<\?([\s\S]+?)(?:\?>|$)/],["lang-",/^<%([\s\S]+?)(?:%>|$)/],[L,/^(?:<[%?]|[%?]>)/],["lang-",/^<xmp\b[^>]*>([\s\S]+?)<\/xmp\b[^>]*>/i],["lang-js",/^<script\b[^>]*>([\s\S]*?)(<\/script\b[^>]*>)/i],["lang-css",/^<style\b[^>]*>([\s\S]*?)(<\/style\b[^>]*>)/i],["lang-in.tag",/^(<\/?[a-z][^<>]*>)/i]]),["default-markup","htm","html","mxml","xhtml","xml","xsl"]);c(g([[F,/^[\s]+/,null," \t\r\n"],[n,/^(?:\"[^\"]*\"?|\'[^\']*\'?)/,null,"\"'"]],[[m,/^^<\/?[a-z](?:[\w.:-]*\w)?|\/?>$/i],[P,/^(?!style[\s=]|on)[a-z](?:[\w:-]*\w)?/i],["lang-uq.val",/^=\s*([^>\'\"\s]*(?:[^>\'\"\s\/]|\/(?=\s)))/],[L,/^[=<>\/]+/],["lang-js",/^on\w+\s*=\s*\"([^\"]+)\"/i],["lang-js",/^on\w+\s*=\s*\'([^\']+)\'/i],["lang-js",/^on\w+\s*=\s*([^\"\'>\s]+)/i],["lang-css",/^style\s*=\s*\"([^\"]+)\"/i],["lang-css",/^style\s*=\s*\'([^\']+)\'/i],["lang-css",/^style\s*=\s*([^\"\'>\s]+)/i]]),["in.tag"]);c(g([],[[n,/^[\s\S]+/]]),["uq.val"]);c(i({keywords:l,hashComments:true,cStyleComments:true,types:e}),["c","cc","cpp","cxx","cyc","m"]);c(i({keywords:"null,true,false"}),["json"]);c(i({keywords:R,hashComments:true,cStyleComments:true,verbatimStrings:true,types:e}),["cs"]);c(i({keywords:x,cStyleComments:true}),["java"]);c(i({keywords:H,hashComments:true,multiLineStrings:true}),["bsh","csh","sh"]);c(i({keywords:I,hashComments:true,multiLineStrings:true,tripleQuotedStrings:true}),["cv","py"]);c(i({keywords:s,hashComments:true,multiLineStrings:true,regexLiterals:true}),["perl","pl","pm"]);c(i({keywords:f,hashComments:true,multiLineStrings:true,regexLiterals:true}),["rb"]);c(i({keywords:w,cStyleComments:true,regexLiterals:true}),["js"]);c(i({keywords:r,hashComments:3,cStyleComments:true,multilineStrings:true,tripleQuotedStrings:true,regexLiterals:true}),["coffee"]);c(g([],[[C,/^[\s\S]+/]]),["regex"]);function d(V){var U=V.langExtension;try{var S=a(V.sourceNode);var T=S.sourceCode;V.sourceCode=T;V.spans=S.spans;V.basePos=0;q(U,T)(V);D(V)}catch(W){if("console" in window){console.log(W&&W.stack?W.stack:W)}}}function y(W,V,U){var S=document.createElement("PRE");S.innerHTML=W;if(U){Q(S,U)}var T={langExtension:V,numberLines:U,sourceNode:S};d(T);return S.innerHTML}function b(ad){function Y(af){return document.getElementsByTagName(af)}var ac=[Y("pre"),Y("code"),Y("xmp")];var T=[];for(var aa=0;aa<ac.length;++aa){for(var Z=0,V=ac[aa].length;Z<V;++Z){T.push(ac[aa][Z])}}ac=null;var W=Date;if(!W.now){W={now:function(){return +(new Date)}}}var X=0;var S;var ab=/\blang(?:uage)?-([\w.]+)(?!\S)/;var ae=/\bprettyprint\b/;function U(){var ag=(window.PR_SHOULD_USE_CONTINUATION?W.now()+250:Infinity);for(;X<T.length&&W.now()<ag;X++){var aj=T[X];var ai=aj.className;if(ai.indexOf("prettyprint")>=0){var ah=ai.match(ab);var am;if(!ah&&(am=o(aj))&&"CODE"===am.tagName){ah=am.className.match(ab)}if(ah){ah=ah[1]}var al=false;for(var ak=aj.parentNode;ak;ak=ak.parentNode){if((ak.tagName==="pre"||ak.tagName==="code"||ak.tagName==="xmp")&&ak.className&&ak.className.indexOf("prettyprint")>=0){al=true;break}}if(!al){var af=aj.className.match(/\blinenums\b(?::(\d+))?/);af=af?af[1]&&af[1].length?+af[1]:true:false;if(af){Q(aj,af)}S={langExtension:ah,sourceNode:aj,numberLines:af};d(S)}}}if(X<T.length){setTimeout(U,250)}else{if(ad){ad()}}}U()}window.prettyPrintOne=y;window.prettyPrint=b;window.PR={createSimpleLexer:g,registerLangHandler:c,sourceDecorator:i,PR_ATTRIB_NAME:P,PR_ATTRIB_VALUE:n,PR_COMMENT:j,PR_DECLARATION:E,PR_KEYWORD:z,PR_LITERAL:G,PR_NOCODE:N,PR_PLAIN:F,PR_PUNCTUATION:L,PR_SOURCE:J,PR_STRING:C,PR_TAG:m,PR_TYPE:O}})();PR.registerLangHandler(PR.createSimpleLexer([],[[PR.PR_DECLARATION,/^<!\w[^>]*(?:>|$)/],[PR.PR_COMMENT,/^<\!--[\s\S]*?(?:-\->|$)/],[PR.PR_PUNCTUATION,/^(?:<[%?]|[%?]>)/],["lang-",/^<\?([\s\S]+?)(?:\?>|$)/],["lang-",/^<%([\s\S]+?)(?:%>|$)/],["lang-",/^<xmp\b[^>]*>([\s\S]+?)<\/xmp\b[^>]*>/i],["lang-handlebars",/^<script\b[^>]*type\s*=\s*['"]?text\/x-handlebars-template['"]?\b[^>]*>([\s\S]*?)(<\/script\b[^>]*>)/i],["lang-js",/^<script\b[^>]*>([\s\S]*?)(<\/script\b[^>]*>)/i],["lang-css",/^<style\b[^>]*>([\s\S]*?)(<\/style\b[^>]*>)/i],["lang-in.tag",/^(<\/?[a-z][^<>]*>)/i],[PR.PR_DECLARATION,/^{{[#^>/]?\s*[\w.][^}]*}}/],[PR.PR_DECLARATION,/^{{&?\s*[\w.][^}]*}}/],[PR.PR_DECLARATION,/^{{{>?\s*[\w.][^}]*}}}/],[PR.PR_COMMENT,/^{{![^}]*}}/]]),["handlebars","hbs"]);PR.registerLangHandler(PR.createSimpleLexer([[PR.PR_PLAIN,/^[ \t\r\n\f]+/,null," \t\r\n\f"]],[[PR.PR_STRING,/^\"(?:[^\n\r\f\\\"]|\\(?:\r\n?|\n|\f)|\\[\s\S])*\"/,null],[PR.PR_STRING,/^\'(?:[^\n\r\f\\\']|\\(?:\r\n?|\n|\f)|\\[\s\S])*\'/,null],["lang-css-str",/^url\(([^\)\"\']*)\)/i],[PR.PR_KEYWORD,/^(?:url|rgb|\!important|@import|@page|@media|@charset|inherit)(?=[^\-\w]|$)/i,null],["lang-css-kw",/^(-?(?:[_a-z]|(?:\\[0-9a-f]+ ?))(?:[_a-z0-9\-]|\\(?:\\[0-9a-f]+ ?))*)\s*:/i],[PR.PR_COMMENT,/^\/\*[^*]*\*+(?:[^\/*][^*]*\*+)*\//],[PR.PR_COMMENT,/^(?:<!--|-->)/],[PR.PR_LITERAL,/^(?:\d+|\d*\.\d+)(?:%|[a-z]+)?/i],[PR.PR_LITERAL,/^#(?:[0-9a-f]{3}){1,2}/i],[PR.PR_PLAIN,/^-?(?:[_a-z]|(?:\\[\da-f]+ ?))(?:[_a-z\d\-]|\\(?:\\[\da-f]+ ?))*/i],[PR.PR_PUNCTUATION,/^[^\s\w\'\"]+/]]),["css"]);PR.registerLangHandler(PR.createSimpleLexer([],[[PR.PR_KEYWORD,/^-?(?:[_a-z]|(?:\\[\da-f]+ ?))(?:[_a-z\d\-]|\\(?:\\[\da-f]+ ?))*/i]]),["css-kw"]);PR.registerLangHandler(PR.createSimpleLexer([],[[PR.PR_STRING,/^[^\)\"\']+/]]),["css-str"]);
</file>

<file path="frontend/coverage/sorter.js">
/* eslint-disable */
var addSorting = (function() {
    'use strict';
    var cols,
        currentSort = {
            index: 0,
            desc: false
        };

    // returns the summary table element
    function getTable() {
        return document.querySelector('.coverage-summary');
    }
    // returns the thead element of the summary table
    function getTableHeader() {
        return getTable().querySelector('thead tr');
    }
    // returns the tbody element of the summary table
    function getTableBody() {
        return getTable().querySelector('tbody');
    }
    // returns the th element for nth column
    function getNthColumn(n) {
        return getTableHeader().querySelectorAll('th')[n];
    }

    function onFilterInput() {
        const searchValue = document.getElementById('fileSearch').value;
        const rows = document.getElementsByTagName('tbody')[0].children;

        // Try to create a RegExp from the searchValue. If it fails (invalid regex),
        // it will be treated as a plain text search
        let searchRegex;
        try {
            searchRegex = new RegExp(searchValue, 'i'); // 'i' for case-insensitive
        } catch (error) {
            searchRegex = null;
        }

        for (let i = 0; i < rows.length; i++) {
            const row = rows[i];
            let isMatch = false;

            if (searchRegex) {
                // If a valid regex was created, use it for matching
                isMatch = searchRegex.test(row.textContent);
            } else {
                // Otherwise, fall back to the original plain text search
                isMatch = row.textContent
                    .toLowerCase()
                    .includes(searchValue.toLowerCase());
            }

            row.style.display = isMatch ? '' : 'none';
        }
    }

    // loads the search box
    function addSearchBox() {
        var template = document.getElementById('filterTemplate');
        var templateClone = template.content.cloneNode(true);
        templateClone.getElementById('fileSearch').oninput = onFilterInput;
        template.parentElement.appendChild(templateClone);
    }

    // loads all columns
    function loadColumns() {
        var colNodes = getTableHeader().querySelectorAll('th'),
            colNode,
            cols = [],
            col,
            i;

        for (i = 0; i < colNodes.length; i += 1) {
            colNode = colNodes[i];
            col = {
                key: colNode.getAttribute('data-col'),
                sortable: !colNode.getAttribute('data-nosort'),
                type: colNode.getAttribute('data-type') || 'string'
            };
            cols.push(col);
            if (col.sortable) {
                col.defaultDescSort = col.type === 'number';
                colNode.innerHTML =
                    colNode.innerHTML + '<span class="sorter"></span>';
            }
        }
        return cols;
    }
    // attaches a data attribute to every tr element with an object
    // of data values keyed by column name
    function loadRowData(tableRow) {
        var tableCols = tableRow.querySelectorAll('td'),
            colNode,
            col,
            data = {},
            i,
            val;
        for (i = 0; i < tableCols.length; i += 1) {
            colNode = tableCols[i];
            col = cols[i];
            val = colNode.getAttribute('data-value');
            if (col.type === 'number') {
                val = Number(val);
            }
            data[col.key] = val;
        }
        return data;
    }
    // loads all row data
    function loadData() {
        var rows = getTableBody().querySelectorAll('tr'),
            i;

        for (i = 0; i < rows.length; i += 1) {
            rows[i].data = loadRowData(rows[i]);
        }
    }
    // sorts the table using the data for the ith column
    function sortByIndex(index, desc) {
        var key = cols[index].key,
            sorter = function(a, b) {
                a = a.data[key];
                b = b.data[key];
                return a < b ? -1 : a > b ? 1 : 0;
            },
            finalSorter = sorter,
            tableBody = document.querySelector('.coverage-summary tbody'),
            rowNodes = tableBody.querySelectorAll('tr'),
            rows = [],
            i;

        if (desc) {
            finalSorter = function(a, b) {
                return -1 * sorter(a, b);
            };
        }

        for (i = 0; i < rowNodes.length; i += 1) {
            rows.push(rowNodes[i]);
            tableBody.removeChild(rowNodes[i]);
        }

        rows.sort(finalSorter);

        for (i = 0; i < rows.length; i += 1) {
            tableBody.appendChild(rows[i]);
        }
    }
    // removes sort indicators for current column being sorted
    function removeSortIndicators() {
        var col = getNthColumn(currentSort.index),
            cls = col.className;

        cls = cls.replace(/ sorted$/, '').replace(/ sorted-desc$/, '');
        col.className = cls;
    }
    // adds sort indicators for current column being sorted
    function addSortIndicators() {
        getNthColumn(currentSort.index).className += currentSort.desc
            ? ' sorted-desc'
            : ' sorted';
    }
    // adds event listeners for all sorter widgets
    function enableUI() {
        var i,
            el,
            ithSorter = function ithSorter(i) {
                var col = cols[i];

                return function() {
                    var desc = col.defaultDescSort;

                    if (currentSort.index === i) {
                        desc = !currentSort.desc;
                    }
                    sortByIndex(i, desc);
                    removeSortIndicators();
                    currentSort.index = i;
                    currentSort.desc = desc;
                    addSortIndicators();
                };
            };
        for (i = 0; i < cols.length; i += 1) {
            if (cols[i].sortable) {
                // add the click event handler on the th so users
                // dont have to click on those tiny arrows
                el = getNthColumn(i).querySelector('.sorter').parentElement;
                if (el.addEventListener) {
                    el.addEventListener('click', ithSorter(i));
                } else {
                    el.attachEvent('onclick', ithSorter(i));
                }
            }
        }
    }
    // adds sorting functionality to the UI
    return function() {
        if (!getTable()) {
            return;
        }
        cols = loadColumns();
        loadData();
        addSearchBox();
        addSortIndicators();
        enableUI();
    };
})();

window.addEventListener('load', addSorting);
</file>

<file path="frontend/public/ui/QA_CHECKLIST.md">
# UI ì—ì…‹ QA ì²´í¬ë¦¬ìŠ¤íŠ¸

> **ì°¸ì¡°**: `frontend/public/ui/README.md` (SSOT ê·œì¹™), `vibe/ref/rembg-guide.md` (ë°°ê²½ ì œê±°)  
> **ëª©ì **: nanobanana mcpë¡œ ìƒì„±í•œ ì—ì…‹ì˜ í’ˆì§ˆ/ì¼ê´€ì„± ë³´ì¥  
> **ì ìš© ì‹œì **: ì—ì…‹ ì¶”ê°€/ìˆ˜ì • ì‹œ ë°˜ë“œì‹œ ì²´í¬

---

## 1. ìš©ëŸ‰ ì˜ˆì‚° (Performance Budget)

### 1.1 ê°œë³„ ì—ì…‹ ìƒí•œ

| ìœ í˜•            | ìƒí•œ  | ê¶Œì¥       | ì²´í¬ í•­ëª©         |
| --------------- | ----- | ---------- | ----------------- |
| **ì•„ì´ì½˜**      | 30KB  | 20KB ì´í•˜  | `bytes` í•„ë“œ í™•ì¸ |
| **placeholder** | 300KB | 200KB ì´í•˜ | `bytes` í•„ë“œ í™•ì¸ |
| **chrome**      | 120KB | 30KB ì´í•˜  | `bytes` í•„ë“œ í™•ì¸ |

### 1.2 ì´í•© ì˜ˆì‚°

| í•­ëª©     | ê°’                                  |
| -------- | ----------------------------------- |
| **ìƒí•œ** | 1.5MB (1,572,864 bytes)             |
| **ê¶Œì¥** | 1MB (1,048,576 bytes) ì´í•˜          |
| **í˜„ì¬** | `manifest.json`ì˜ `totalBytes` í™•ì¸ |

### 1.3 ìš©ëŸ‰ ì´ˆê³¼ ì‹œ ëŒ€ì‘

1. **ì••ì¶•/ìµœì í™”**: TinyPNG, ImageMagick, WebP ë³€í™˜
2. **í•´ìƒë„/ìƒ‰ìƒ ì¶•ì†Œ**: í•„ìš” ì‚¬ì´ì¦ˆë§Œ ìœ ì§€
3. **ë¶ˆí•„ìš” ì—ì…‹ ì œê±°**: ì‚¬ìš©ì²˜ ì—†ëŠ” ì—ì…‹ ì •ë¦¬
4. **ì˜ˆì‚° ìƒí–¥**: ê·¼ê±° ë¬¸ì„œí™” í›„ `budgetBytes` ì¡°ì •

---

## 2. ì‚¬ì´ì¦ˆ/ê·œê²© (Size)

### 2.1 ì•„ì´ì½˜ ì‚¬ì´ì¦ˆ ì²´í¬

| í•­ëª©            | ìš”êµ¬                 | ì²´í¬ |
| --------------- | -------------------- | ---- |
| **í•„ìˆ˜ ì‚¬ì´ì¦ˆ** | 16px, 24px ìµœì†Œ 2ì¢…  | â˜    |
| **ì„ íƒ ì‚¬ì´ì¦ˆ** | 32px, 64px (í•„ìš” ì‹œ) | â˜    |
| **ì •ë°©í˜•**      | ê°€ë¡œ = ì„¸ë¡œ          | â˜    |

### 2.2 16px ì‹¤ë£¨ì—£ í…ŒìŠ¤íŠ¸ âš ï¸

> **ì¤‘ìš”**: 16pxì—ì„œë„ í˜•íƒœê°€ êµ¬ë¶„ë˜ì–´ì•¼ í•©ë‹ˆë‹¤.

**í…ŒìŠ¤íŠ¸ ë°©ë²•**:

1. 16px ì•„ì´ì½˜ì„ 100% ë°°ìœ¨ë¡œ í‘œì‹œ
2. 2m ê±°ë¦¬ì—ì„œ í˜•íƒœ êµ¬ë¶„ ê°€ëŠ¥ ì—¬ë¶€ í™•ì¸
3. ë‹¤ë¥¸ ì•„ì´ì½˜ê³¼ í˜¼ë™ë˜ì§€ ì•ŠëŠ”ì§€ í™•ì¸

**ì‹¤íŒ¨ ì‹œ ëŒ€ì‘**:

- ë””í…Œì¼ ë‹¨ìˆœí™”
- ì™¸ê³½ì„ /ì‹¤ë£¨ì—£ ê°•í™”
- 16px/24px ë³„ë„ ë””ìì¸ (ì‚¬ìš©ì²˜ ë¶„ë¦¬)

### 2.3 placeholder/chrome ì‚¬ì´ì¦ˆ

| í•­ëª©            | ê¶Œì¥                     | ë¹„ê³                |
| --------------- | ------------------------ | ------------------ |
| **placeholder** | 512x384 ë˜ëŠ” ìš©ë„ë³„ ì ì • | ê°€ë¡œì„¸ë¡œ ë¹„ìœ¨ ìœ ì§€ |
| **chrome**      | íƒ€ì¼ë§ ê°€ëŠ¥ ì‚¬ì´ì¦ˆ       | 48px, 64px ë“±      |

---

## 3. ëŒ€ë¹„/ê°€ë…ì„± (Contrast)

### 3.1 ê¸°ë³¸ ëŒ€ë¹„ í…ŒìŠ¤íŠ¸

| ëª¨ë“œ         | ë°°ê²½                    | ìš”êµ¬ ëŒ€ë¹„               | ì²´í¬ |
| ------------ | ----------------------- | ----------------------- | ---- |
| **ê¸°ë³¸**     | `#0d0d0d` (ì–´ë‘ìš´ ë°°ê²½) | ì¸ê´‘ ë…¹ìƒ‰(#33ff00) ëŒ€ë¹„ | â˜    |
| **Readable** | ëŒ€ë¹„ ê°•í™” ëª¨ë“œ          | 4.5:1 ì´ìƒ              | â˜    |

### 3.2 ëŒ€ë¹„ ê²€ì¦ ë°©ë²•

```
ë„êµ¬: WebAIM Contrast Checker
URL: https://webaim.org/resources/contrastchecker/

ì „ê²½ìƒ‰: ì•„ì´ì½˜ ì£¼ìš” ìƒ‰ìƒ
ë°°ê²½ìƒ‰: #0d0d0d (CRT ë°°ê²½)
ëª©í‘œ: 4.5:1 ì´ìƒ (AA ê¸°ì¤€)
```

### 3.3 Readable ëª¨ë“œ í˜¸í™˜

- [ ] CRT ê¸€ë¡œìš°/ìŠ¤ìº”ë¼ì¸ OFF ì‹œì—ë„ ì‹ë³„ ê°€ëŠ¥
- [ ] í…ìŠ¤íŠ¸ ë¼ë²¨ì´ ì´ë¯¸ì§€ë¥¼ ë°©í•´í•˜ì§€ ì•ŠìŒ
- [ ] ìƒ‰ì•½/ìƒ‰ë§¹ ì ‘ê·¼ì„± ê³ ë ¤ (ìƒ‰ìƒë§Œìœ¼ë¡œ ì˜ë¯¸ ì „ë‹¬ ê¸ˆì§€)

---

## 4. íˆ¬ëª… ë°°ê²½ (Alpha Channel)

### 4.1 íˆ¬ëª… ë°°ê²½ í•„ìš” ì—¬ë¶€

| ìœ í˜•            | íˆ¬ëª… í•„ìˆ˜ | ë°°ê²½ ìƒ‰ìƒ        |
| --------------- | --------- | ---------------- |
| **ì•„ì´ì½˜**      | âœ… í•„ìˆ˜   | íˆ¬ëª… (ì•ŒíŒŒ ì±„ë„) |
| **placeholder** | âŒ ì„ íƒ   | ë¶ˆíˆ¬ëª… í—ˆìš©      |
| **chrome**      | âœ… í•„ìˆ˜   | íˆ¬ëª… (ì•ŒíŒŒ ì±„ë„) |

### 4.2 ë°°ê²½ ì œê±° ì²´í¬ (rembg)

> **ì°¸ì¡°**: `vibe/ref/rembg-guide.md`

**ìƒì„± ë‹¨ê³„ ìš”êµ¬ (ì¡°ê±´ë¶€)**:

- [ ] ë°°ê²½ ì œê±° ì˜ˆì •ì¸ ì—ì…‹ì€ **ìˆœë°±(#FFFFFF) ë‹¨ìƒ‰ ë°°ê²½**ìœ¼ë¡œ ìƒì„±
- [ ] ê·¸ë¼ë°ì´ì…˜/í…ìŠ¤ì²˜/ê·¸ë¦¼ì ë°°ê²½ ê¸ˆì§€

**ë°°ê²½ ì œê±° ì‹¤í–‰**:

- [ ] `rembg i -m birefnet-general <input> <output>` ì‹¤í–‰
- [ ] ì•ŒíŒŒ ì±„ë„ ì¡´ì¬ í™•ì¸ (GIMP/Photoshop/Preview)
- [ ] ê²½ê³„ ë¶€ë¶„ ì”ì—¬ ë°°ê²½ ì—†ìŒ í™•ì¸

### 4.3 íˆ¬ëª…ë„ ê²€ì¦ ëª…ë ¹ì–´

```bash
# ImageMagickìœ¼ë¡œ ì•ŒíŒŒ ì±„ë„ í™•ì¸
magick identify -verbose <image.png> | grep -i alpha

# ë˜ëŠ” íŒŒì¼ ì •ë³´ í™•ì¸ (PNG í¬ë§·)
file <image.png>  # PNG image data, ... RGBA
```

---

## 5. í´ë°± (Fallback)

### 5.1 í´ë°± í…ìŠ¤íŠ¸/ì´ëª¨ì§€ ì²´í¬

| ì²´í¬ í•­ëª©         | ìš”êµ¬  | ì„¤ëª…                               |
| ----------------- | ----- | ---------------------------------- |
| **fallback í•„ë“œ** | í•„ìˆ˜  | manifest.jsonì— `fallback` ê°’ ì¡´ì¬ |
| **ì´ëª¨ì§€/í…ìŠ¤íŠ¸** | 1~2ì | ì˜ˆ: `ğŸ“¡`, `âš `, `âœ“`, `OK`           |
| **ì˜ë¯¸ ì „ë‹¬**     | ëª…í™•  | ì›ë³¸ ì•„ì´ì½˜ê³¼ ë™ì¼í•œ ì˜ë¯¸          |

### 5.2 í´ë°± ë™ì‘ í…ŒìŠ¤íŠ¸

**í…ŒìŠ¤íŠ¸ ì‹œë‚˜ë¦¬ì˜¤**:

1. ì—ì…‹ íŒŒì¼ì„ ì„ì‹œë¡œ ì‚­ì œ/ì´ë¦„ ë³€ê²½
2. ë¸Œë¼ìš°ì €ì—ì„œ UI ë¡œë“œ
3. í´ë°± í…ìŠ¤íŠ¸/ì´ëª¨ì§€ê°€ í‘œì‹œë˜ëŠ”ì§€ í™•ì¸
4. UIê°€ ê¹¨ì§€ì§€ ì•ŠëŠ”ì§€ í™•ì¸

**ì½”ë“œ êµ¬í˜„ í™•ì¸**:

```tsx
// ì˜ˆìƒ íŒ¨í„´
<img
  src="/ui/icons/signal-24.png"
  alt=""
  aria-hidden="true"
  onError={(e) => (e.currentTarget.style.display = 'none')}
/>
<span className="icon-fallback">ğŸ“¡</span>
```

---

## 6. ë§¤ë‹ˆí˜ìŠ¤íŠ¸ ë™ê¸°í™” (manifest.json)

### 6.1 í•„ìˆ˜ í•„ë“œ ì²´í¬

| í•„ë“œ       | í•„ìˆ˜ | ì²´í¬                              |
| ---------- | ---- | --------------------------------- |
| `id`       | âœ…   | kebab-case, ê³ ìœ ê°’                |
| `path`     | âœ…   | `ui/` ê¸°ì¤€ ìƒëŒ€ ê²½ë¡œ              |
| `type`     | âœ…   | `icon` / `placeholder` / `chrome` |
| `fallback` | ê¶Œì¥ | ì´ëª¨ì§€/í…ìŠ¤íŠ¸                     |
| `bytes`    | ê¶Œì¥ | íŒŒì¼ í¬ê¸°                         |
| `usedIn`   | ê¶Œì¥ | ì‚¬ìš©ì²˜ ì»´í¬ë„ŒíŠ¸ ëª©ë¡              |
| `notes`    | ì„ íƒ | QA/ìƒì„± ê´€ë ¨ ë©”ëª¨                 |

### 6.2 ì‹¤ì œ íŒŒì¼ê³¼ ë§¤ë‹ˆí˜ìŠ¤íŠ¸ ì •í•©ì„±

- [ ] manifest.jsonì˜ ëª¨ë“  ì—ì…‹ì´ ì‹¤ì œ íŒŒì¼ë¡œ ì¡´ì¬
- [ ] ì‹¤ì œ ë””ë ‰í† ë¦¬ì˜ ëª¨ë“  ì—ì…‹ì´ manifest.jsonì— ë“±ë¡ë¨
- [ ] `path` ê²½ë¡œê°€ ì‹¤ì œ íŒŒì¼ ìœ„ì¹˜ì™€ ì¼ì¹˜
- [ ] `bytes` ê°’ì´ ì‹¤ì œ íŒŒì¼ í¬ê¸°ì™€ ì¼ì¹˜

### 6.3 ì •í•©ì„± ê²€ì¦ ìŠ¤í¬ë¦½íŠ¸ (ì°¸ê³ )

```bash
# manifest.jsonì— ìˆëŠ” pathë“¤ì´ ì‹¤ì œë¡œ ì¡´ì¬í•˜ëŠ”ì§€ í™•ì¸
cd frontend/public/ui
cat manifest.json | jq -r '.assets[].path' | while read p; do
  [ -f "$p" ] || echo "MISSING: $p"
done

# ì‹¤ì œ íŒŒì¼ì´ manifestì— ìˆëŠ”ì§€ í™•ì¸
find icons placeholders chrome -type f \( -name "*.png" -o -name "*.webp" \) | while read f; do
  grep -q "\"$f\"" manifest.json || echo "NOT IN MANIFEST: $f"
done
```

---

## 7. ìŠ¤íƒ€ì¼ ì¼ê´€ì„± (CRT Theme)

### 7.1 ìƒ‰ìƒ íŒ”ë ˆíŠ¸ ì¤€ìˆ˜

| ìƒ‰ìƒ        | Hex       | ìš©ë„        | ì²´í¬ |
| ----------- | --------- | ----------- | ---- |
| ì¸ê´‘ ë…¹ìƒ‰   | `#33ff00` | ì£¼ìš” ìƒ‰ìƒ   | â˜    |
| ì–´ë‘ìš´ ë…¹ìƒ‰ | `#1a8000` | ë³´ì¡° ìƒ‰ìƒ   | â˜    |
| ë§ˆì  íƒ€      | `#ff00ff` | í¬ì¸íŠ¸/ê²½ê³  | â˜    |
| ì£¼í™©ìƒ‰      | `#ffaa00` | ê²½ê³         | â˜    |
| ë¶‰ì€ìƒ‰      | `#ff3333` | ì—ëŸ¬        | â˜    |
| ë°°ê²½        | `#0d0d0d` | ë°°ê²½        | â˜    |

### 7.2 ìŠ¤íƒ€ì¼ ê¸ˆì§€ ì‚¬í•­

- [ ] ì™¸ë¶€ ë¡œê³ /ìƒí‘œ ë³µì œ ê¸ˆì§€
- [ ] CRT í…Œë§ˆì™€ ì¶©ëŒí•˜ëŠ” ìƒ‰ìƒ ê¸ˆì§€ (ë°ì€ íŒŒìŠ¤í…”, ë‚œìƒ‰ ë‚¨ìš©)
- [ ] ë³µì¡í•œ ê·¸ë¼ë°ì´ì…˜/ì‚¬ì§„ ìŠ¤íƒ€ì¼ ê¸ˆì§€

---

## 8. Retina ëŒ€ì‘ (ì„ íƒ)

### 8.1 Retina í•„ìš” ì—¬ë¶€ íŒë‹¨

| ìƒí™©             | Retina í•„ìš” | ë¹„ê³                   |
| ---------------- | ----------- | --------------------- |
| **16px ì•„ì´ì½˜**  | ì„ íƒ        | HiDPIì—ì„œ ì„ ëª…ë„ í–¥ìƒ |
| **24px+ ì•„ì´ì½˜** | ë‚®ìŒ        | ê¸°ë³¸ í•´ìƒë„ë¡œ ì¶©ë¶„    |
| **placeholder**  | ë‚®ìŒ        | ì´ë¯¸ ì¶©ë¶„í•œ í•´ìƒë„    |

### 8.2 Retina íŒŒì¼ ê·œì¹™

- íŒŒì¼ëª…: `{name}-24.png` â†’ `{name}-24@2x.png`
- CSS: `image-set()`ìœ¼ë¡œ 1x/2x ì œê³µ
- manifest.json: `retina: true` í‘œê¸°

---

## 9. ì¢…í•© ì²´í¬ë¦¬ìŠ¤íŠ¸ (Quick Reference)

ì—ì…‹ ì¶”ê°€/ìˆ˜ì • ì‹œ ì•„ë˜ í•­ëª©ì„ ìˆœì„œëŒ€ë¡œ ì²´í¬í•˜ì„¸ìš”:

### ğŸ“¦ ì¶”ê°€ ì „

- [ ] ë„¤ì´ë° ê·œì¹™ ì¤€ìˆ˜ (`kebab-case` + ìš©ë„ + í¬ê¸°)
- [ ] í¬ë§· ê·œì¹™ ì¤€ìˆ˜ (ì•„ì´ì½˜=PNG, placeholder=WebP)
- [ ] CRT í…Œë§ˆ ìƒ‰ìƒê³¼ ì¡°í™”

### ğŸ¨ ìƒì„± ì‹œ

- [ ] (ì¡°ê±´ë¶€) ë°°ê²½ ì œê±° í•„ìš” ì‹œ ìˆœë°±(#FFFFFF) ë°°ê²½ìœ¼ë¡œ ìƒì„±
- [ ] í•„ìš” ì‚¬ì´ì¦ˆë¡œ ë¦¬ì‚¬ì´ì¦ˆ
- [ ] (ì¡°ê±´ë¶€) `rembg`ë¡œ ë°°ê²½ ì œê±°

### âœ… ì¶”ê°€ í›„

- [ ] ê°œë³„ ìš©ëŸ‰ ì˜ˆì‚° ì¤€ìˆ˜ í™•ì¸
- [ ] ì´í•© ì˜ˆì‚° ì¤€ìˆ˜ í™•ì¸ (`totalBytes` < `budgetBytes`)
- [ ] 16px ì‹¤ë£¨ì—£ êµ¬ë¶„ ê°€ëŠ¥ ì—¬ë¶€ (ì•„ì´ì½˜)
- [ ] ê¸°ë³¸/Readable ëª¨ë“œ ëŒ€ë¹„ í™•ì¸
- [ ] (ì¡°ê±´ë¶€) ì•ŒíŒŒ ì±„ë„ ì¡´ì¬ í™•ì¸ (íˆ¬ëª… í•„ìš” ì—ì…‹)
- [ ] í´ë°± í…ìŠ¤íŠ¸/ì´ëª¨ì§€ ì§€ì •
- [ ] manifest.json ì—…ë°ì´íŠ¸
- [ ] ì‹¤ì œ íŒŒì¼ê³¼ ë§¤ë‹ˆí˜ìŠ¤íŠ¸ ì •í•©ì„± í™•ì¸

---

## 10. ì°¸ê³  ìë£Œ

- **SSOT ê·œì¹™**: `frontend/public/ui/README.md`
- **ë°°ê²½ ì œê±° ê°€ì´ë“œ**: `vibe/ref/rembg-guide.md`
- **ë§¤ë‹ˆí˜ìŠ¤íŠ¸ ìŠ¤í‚¤ë§ˆ**: `frontend/public/ui/manifest.schema.json`
- **ìŠ¤íƒ€ì¼ ê°€ì´ë“œ**: `vibe/ref/frontend-style-guide.md`
- **ê°€ë…ì„± íŒ¨ìŠ¤**: U-028[Mvp] (Readable ëª¨ë“œ)

---

_ë§ˆì§€ë§‰ ì—…ë°ì´íŠ¸: 2026-01-12_  
_ë¬¸ì„œ ë²„ì „: 1.0.0_
</file>

<file path="frontend/src/api/scanner.test.ts">
import { describe, it, expect, vi, beforeEach } from 'vitest';
import {
  scanImage,
  validateFile,
  isSupportedImageFile,
  candidateToInventoryItem,
  MAX_FILE_SIZE_BYTES,
  type ItemCandidate,
} from './scanner';

describe('Scanner API Client', () => {
  beforeEach(() => {
    vi.clearAllMocks();
    global.fetch = vi.fn();
  });

  describe('validateFile', () => {
    it('returns null for valid image files', () => {
      const file = new File([''], 'test.png', { type: 'image/png' });
      expect(validateFile(file)).toBeNull();
    });

    it('returns error for unsupported MIME types', () => {
      const file = new File([''], 'test.txt', { type: 'text/plain' });
      expect(validateFile(file)).toContain('ì§€ì›í•˜ì§€ ì•ŠëŠ” íŒŒì¼ í˜•ì‹');
    });

    it('returns error for files exceeding max size', () => {
      const largeFile = {
        size: MAX_FILE_SIZE_BYTES + 1,
        type: 'image/png',
        name: 'large.png',
      } as File;
      expect(validateFile(largeFile)).toContain('íŒŒì¼ì´ ë„ˆë¬´ í½ë‹ˆë‹¤');
    });
  });

  describe('isSupportedImageFile', () => {
    it('returns true for jpg, png, webp, gif', () => {
      expect(isSupportedImageFile(new File([''], 't.jpg', { type: 'image/jpeg' }))).toBe(true);
      expect(isSupportedImageFile(new File([''], 't.png', { type: 'image/png' }))).toBe(true);
      expect(isSupportedImageFile(new File([''], 't.webp', { type: 'image/webp' }))).toBe(true);
      expect(isSupportedImageFile(new File([''], 't.gif', { type: 'image/gif' }))).toBe(true);
    });

    it('returns false for others', () => {
      expect(isSupportedImageFile(new File([''], 't.pdf', { type: 'application/pdf' }))).toBe(
        false,
      );
    });
  });

  describe('scanImage', () => {
    const mockFile = new File(['mock content'], 'test.png', { type: 'image/png' });
    const mockSuccessResponse = {
      success: true,
      status: 'completed',
      caption: 'A test scan',
      objects: [],
      item_candidates: [{ id: 'item-1', label: 'Test Item', item_type: 'tool' }],
      analysis_time_ms: 100,
      language: 'ko-KR',
    };

    it('returns success data when API call succeeds', async () => {
      (global.fetch as unknown as ReturnType<typeof vi.fn>).mockResolvedValue({
        ok: true,
        json: async () => mockSuccessResponse,
      });

      const result = await scanImage(mockFile, 'ko-KR');

      expect(result.success).toBe(true);
      if (result.success) {
        expect(result.data.caption).toBe('A test scan');
        expect(result.data.item_candidates).toHaveLength(1);
      }
    });

    it('returns error when fetch fails', async () => {
      (global.fetch as unknown as ReturnType<typeof vi.fn>).mockResolvedValue({
        ok: false,
        status: 500,
        statusText: 'Internal Server Error',
      });

      const result = await scanImage(mockFile, 'ko-KR');

      expect(result.success).toBe(false);
      if (!result.success) {
        expect(result.error).toContain('ì„œë²„ ì˜¤ë¥˜: 500');
      }
    });

    it('returns error when response schema is invalid', async () => {
      (global.fetch as unknown as ReturnType<typeof vi.fn>).mockResolvedValue({
        ok: true,
        json: async () => ({ invalid: 'data' }),
      });

      const result = await scanImage(mockFile, 'ko-KR');

      expect(result.success).toBe(false);
      if (!result.success) {
        expect(result.error).toContain('ë°ì´í„° í˜•ì‹ì´ ì˜¬ë°”ë¥´ì§€ ì•ŠìŠµë‹ˆë‹¤');
      }
    });

    it('handles network error', async () => {
      (global.fetch as unknown as ReturnType<typeof vi.fn>).mockRejectedValue(
        new Error('Network error'),
      );

      const result = await scanImage(mockFile, 'ko-KR');

      expect(result.success).toBe(false);
      if (!result.success) {
        expect(result.error).toContain('ë„¤íŠ¸ì›Œí¬ ì˜¤ë¥˜');
      }
    });
  });

  describe('candidateToInventoryItem', () => {
    it('correctly maps ItemCandidate to InventoryItem', () => {
      const candidate = {
        id: 'c-1',
        label: 'Rusty Key',
        description: 'An old key',
        item_type: 'key',
      };
      const item = candidateToInventoryItem(candidate);

      expect(item).toEqual({
        id: 'c-1',
        name: 'Rusty Key',
        description: 'An old key',
        icon: 'ğŸ”‘',
        quantity: 1,
      });
    });

    it('uses fallback icon for unknown item types', () => {
      const candidate: ItemCandidate = {
        id: 'c-2',
        label: 'Something',
        description: '',
        item_type: 'unknown',
      };
      const item = candidateToInventoryItem(candidate);
      expect(item.icon).toBe('ğŸ“¦');
    });
  });
});
</file>

<file path="frontend/src/data/demoProfiles.test.ts">
import { describe, it, expect, vi } from 'vitest';
import { PROFILE_EXPLORER, createSaveGameFromProfile, findProfileById } from './demoProfiles';
import { SAVEGAME_VERSION } from '../save/saveGame';

describe('demoProfiles (U-015[Mvp])', () => {
  const mockT = vi.fn((key: string) => `translated-${key}`);

  it('findProfileByIdëŠ” ì˜¬ë°”ë¥¸ í”„ë¡œí•„ì„ ë°˜í™˜í•´ì•¼ í•œë‹¤', () => {
    const profile = findProfileById('explorer');
    expect(profile).toBeDefined();
    expect(profile?.id).toBe('explorer');
    expect(profile?.icon).toBe('ğŸ§­');
  });

  it('ì¡´ì¬í•˜ì§€ ì•ŠëŠ” IDì— ëŒ€í•´ findProfileByIdëŠ” undefinedë¥¼ ë°˜í™˜í•´ì•¼ í•œë‹¤', () => {
    const profile = findProfileById('non-existent');
    expect(profile).toBeUndefined();
  });

  it('createSaveGameFromProfileì€ í”„ë¡œí•„ ì´ˆê¸° ìƒíƒœë¥¼ SaveGameìœ¼ë¡œ ì˜¬ë°”ë¥´ê²Œ ë³€í™˜í•´ì•¼ í•œë‹¤', () => {
    const saveGame = createSaveGameFromProfile(PROFILE_EXPLORER, 'ko-KR', mockT);

    // ê¸°ë³¸ ë©”íƒ€ë°ì´í„°
    expect(saveGame.version).toBe(SAVEGAME_VERSION);
    expect(saveGame.profileId).toBe('explorer');
    expect(saveGame.language).toBe('ko-KR');
    expect(saveGame.seed).toContain('demo-explorer-');

    // ê²½ì œ ìƒíƒœ
    expect(saveGame.economy.signal).toBe(PROFILE_EXPLORER.initialState.economy.signal);
    expect(saveGame.economy.memory_shard).toBe(PROFILE_EXPLORER.initialState.economy.memory_shard);

    // ì¸ë²¤í† ë¦¬ (ë²ˆì—­ ì ìš© í™•ì¸)
    expect(saveGame.inventory).toHaveLength(PROFILE_EXPLORER.initialState.inventoryDefs.length);
    expect(saveGame.inventory[0].name).toBe(
      `translated-${PROFILE_EXPLORER.initialState.inventoryDefs[0].nameKey}`,
    );

    // í€˜ìŠ¤íŠ¸
    expect(saveGame.quests).toHaveLength(PROFILE_EXPLORER.initialState.questDefs.length);
    expect(saveGame.quests[0].label).toBe(
      `translated-${PROFILE_EXPLORER.initialState.questDefs[0].labelKey}`,
    );

    // ê·œì¹™ ë° íƒ€ì„ë¼ì¸
    expect(saveGame.activeRules).toHaveLength(PROFILE_EXPLORER.initialState.ruleDefs.length);
    expect(saveGame.mutationTimeline).toHaveLength(PROFILE_EXPLORER.initialState.ruleDefs.length);
    expect(saveGame.mutationTimeline[0].type).toBe('added');

    // ë‚´ëŸ¬í‹°ë¸Œ (í™˜ì˜ ë©”ì‹œì§€)
    expect(saveGame.narrativeHistory).toHaveLength(1);
    expect(saveGame.narrativeHistory[0].turn).toBe(0);
    expect(saveGame.narrativeHistory[0].text).toBe(
      `translated-${PROFILE_EXPLORER.initialState.welcomeMessageKey}`,
    );

    // Scene Objects
    expect(saveGame.sceneObjects).toHaveLength(
      PROFILE_EXPLORER.initialState.sceneObjectDefs.length,
    );
    expect(saveGame.sceneObjects[0].box_2d).toEqual(
      PROFILE_EXPLORER.initialState.sceneObjectDefs[0].box_2d,
    );
  });
});
</file>

<file path="frontend/src/locales/README.md">
# i18n ì–¸ì–´ ë¦¬ì†ŒìŠ¤ ê°€ì´ë“œ (Unknown World)

ì´ ë””ë ‰í† ë¦¬ëŠ” Unknown Worldì˜ **í”„ë¡ íŠ¸ì—”ë“œ UI ë¬¸ìì—´ ë¦¬ì†ŒìŠ¤**ë¥¼ ê´€ë¦¬í•˜ëŠ” SSOT(Single Source of Truth)ì…ë‹ˆë‹¤.

## ë””ë ‰í† ë¦¬ êµ¬ì¡°

```
locales/
â”œâ”€â”€ ko-KR/
â”‚   â””â”€â”€ translation.json    # í•œêµ­ì–´ ë¦¬ì†ŒìŠ¤
â”œâ”€â”€ en-US/
â”‚   â””â”€â”€ translation.json    # ì˜ì–´ ë¦¬ì†ŒìŠ¤
â””â”€â”€ README.md               # ì´ ë¬¸ì„œ
```

## ì§€ì› ì–¸ì–´

| ì½”ë“œ    | ì–¸ì–´   | ìƒíƒœ | ë¹„ê³            |
| ------- | ------ | ---- | -------------- |
| `ko-KR` | í•œêµ­ì–´ | ê¸°ë³¸ | ë°ëª¨ ê¸°ì¤€ ì–¸ì–´ |
| `en-US` | ì˜ì–´   | í´ë°± | fallbackLng    |

> **ì–¸ì–´ ì½”ë“œ ê·œì¹™**: BCP-47 í˜•ì‹ì„ ì‚¬ìš©í•©ë‹ˆë‹¤ (`ko-KR`, `en-US`).  
> TurnInput/SaveGameì˜ `language` í•„ë“œì™€ ë™ì¼í•œ ì¶•ì…ë‹ˆë‹¤.

## í‚¤ ë„¤ì´ë° ê·œì¹™

í‚¤ëŠ” **ë„ë©”ì¸.ì„¹ì…˜.í•­ëª©** í˜•íƒœì˜ ê³„ì¸µ êµ¬ì¡°ë¥¼ ë”°ë¦…ë‹ˆë‹¤.

### ë„ë©”ì¸ ëª©ë¡

| ë„ë©”ì¸       | ìš©ë„                                    |
| ------------ | --------------------------------------- |
| `scene`      | Scene Canvas ê´€ë ¨ ë©”ì‹œì§€                |
| `agent`      | Agent Console ê´€ë ¨ ë¼ë²¨/ìƒíƒœ            |
| `ui`         | ê³µí†µ UI ìš”ì†Œ (ë²„íŠ¼, ì…ë ¥, í”Œë ˆì´ìŠ¤í™€ë”) |
| `economy`    | ì¬í™” ê´€ë ¨ ë¼ë²¨                          |
| `connection` | ì—°ê²° ìƒíƒœ                               |
| `panel`      | íŒ¨ë„ë³„ íƒ€ì´í‹€/í”Œë ˆì´ìŠ¤í™€ë”              |
| `action`     | ì•¡ì…˜ ì¹´ë“œ/ì„ íƒì§€                        |
| `narrative`  | ë‚´ëŸ¬í‹°ë¸Œ/ê²Œì„ ë¡œê·¸                      |

### ì˜ˆì‹œ

```json
{
  "scene.status.loading": "ë™ê¸°í™” ì¤‘...",
  "agent.console.badges": "ê²€ì¦ ë°°ì§€",
  "ui.execute": "ì‹¤í–‰",
  "panel.inventory.placeholder": "[ ë“œë˜ê·¸ ì•¤ ë“œë¡­ ì˜ì—­ ]"
}
```

## ìƒˆ ì–¸ì–´ ì¶”ê°€ ì ˆì°¨

1. **ë””ë ‰í† ë¦¬ ìƒì„±**: `locales/{ì–¸ì–´ì½”ë“œ}/` ìƒì„± (ì˜ˆ: `ja-JP`)
2. **translation.json ë³µì‚¬**: `ko-KR/translation.json`ì„ ë³µì‚¬í•˜ì—¬ ì‹œì‘ì ìœ¼ë¡œ ì‚¬ìš©
3. **ë²ˆì—­ ì‘ì—…**: ëª¨ë“  ê°’ì„ í•´ë‹¹ ì–¸ì–´ë¡œ ë²ˆì—­
4. **i18n.ts ë“±ë¡**: `frontend/src/i18n.ts`ì— ìƒˆ ì–¸ì–´ ë¦¬ì†ŒìŠ¤ import ë° ë“±ë¡
5. **ê²€ì¦**: ëˆ„ë½ëœ í‚¤ê°€ ì—†ëŠ”ì§€ í™•ì¸ (i18nextì˜ `missingKeyHandler` í™œìš©)

```typescript
// frontend/src/i18n.ts
import jaJP from './locales/ja-JP/translation.json';

const resources = {
  'ko-KR': { translation: koKR },
  'en-US': { translation: enUS },
  'ja-JP': { translation: jaJP }, // ìƒˆ ì–¸ì–´ ì¶”ê°€
};
```

## ì‚¬ìš© ë°©ë²•

### ê¸°ë³¸ ì‚¬ìš©

```tsx
import { useTranslation } from 'react-i18next';

function MyComponent() {
  const { t } = useTranslation();

  return <button>{t('ui.execute')}</button>;
}
```

### ë³´ê°„ (Interpolation)

```tsx
// JSON
{ "narrative.turn_label": "[TURN {{turn}}]" }

// ì»´í¬ë„ŒíŠ¸
<span>{t('narrative.turn_label', { turn: 5 })}</span>
// ê²°ê³¼: "[TURN 5]"
```

### ì–¸ì–´ ë³€ê²½ (í–¥í›„)

```tsx
import { useTranslation } from 'react-i18next';

function LanguageToggle() {
  const { i18n } = useTranslation();

  const toggleLanguage = () => {
    const newLang = i18n.resolvedLanguage === 'ko-KR' ? 'en-US' : 'ko-KR';
    i18n.changeLanguage(newLang);
  };

  return <button onClick={toggleLanguage}>ğŸŒ</button>;
}
```

## ê¸ˆì§€ì‚¬í•­

### âŒ í…ìŠ¤íŠ¸ë¥¼ ì´ë¯¸ì§€ì— í¬í•¨í•˜ì§€ ë§ˆì„¸ìš”

ì´ë¯¸ì§€ì— í…ìŠ¤íŠ¸ë¥¼ ë°•ìœ¼ë©´:

- ì–¸ì–´ ë³€ê²½ ì‹œ ì´ë¯¸ì§€ë¥¼ êµì²´í•´ì•¼ í•¨
- ë¦¬ì‚¬ì´ì¦ˆ ì‹œ ê°€ë…ì„± ì €í•˜
- ì ‘ê·¼ì„± ë¬¸ì œ (ìŠ¤í¬ë¦° ë¦¬ë”)

**ëŒ€ì‹ **: ì´ë¯¸ì§€ì™€ í…ìŠ¤íŠ¸ë¥¼ ë¶„ë¦¬í•˜ê³ , í…ìŠ¤íŠ¸ëŠ” i18n í‚¤ë¡œ ê´€ë¦¬

### âŒ í•˜ë“œì½”ë”© ë¬¸ìì—´ ê¸ˆì§€

```tsx
// âŒ Bad
<button>ì‹¤í–‰</button>

// âœ… Good
<button>{t('ui.execute')}</button>
```

### âŒ ko/en í˜¼í•© ì¶œë ¥ ê¸ˆì§€ (RULE-006)

ë™ì¼ í™”ë©´ì—ì„œ í•œêµ­ì–´ì™€ ì˜ì–´ê°€ ì„ì—¬ ë‚˜ì˜¤ë©´ ì•ˆ ë©ë‹ˆë‹¤.
ëª¨ë“  UI ë¬¸ìì—´ì€ í˜„ì¬ ì„ íƒëœ ì–¸ì–´ë¡œ ì¼ê´€ë˜ê²Œ í‘œì‹œë˜ì–´ì•¼ í•©ë‹ˆë‹¤.

### âŒ í‚¤ ì„ì˜ ì‚­ì œ/ë³€ê²½ ê¸ˆì§€

í‚¤ë¥¼ ì‚­ì œí•˜ê±°ë‚˜ ì´ë¦„ì„ ë³€ê²½í•˜ë©´ ê¸°ì¡´ ì½”ë“œì—ì„œ ì°¸ì¡° ì˜¤ë¥˜ê°€ ë°œìƒí•©ë‹ˆë‹¤.

- ì‚­ì œ: deprecated ë§ˆí‚¹ í›„ ì¶©ë¶„í•œ ê¸°ê°„ì„ ë‘ê³  ì œê±°
- ë³€ê²½: ìƒˆ í‚¤ ì¶”ê°€ â†’ ë§ˆì´ê·¸ë ˆì´ì…˜ â†’ êµ¬ í‚¤ ì œê±°

## ê²€ì¦ ì²´í¬ë¦¬ìŠ¤íŠ¸

ìƒˆ ë¦¬ì†ŒìŠ¤ ì¶”ê°€/ìˆ˜ì • ì‹œ:

- [ ] ëª¨ë“  ì§€ì› ì–¸ì–´ì— ë™ì¼í•œ í‚¤ê°€ ì¡´ì¬í•˜ëŠ”ì§€ í™•ì¸
- [ ] ë³´ê°„ ë³€ìˆ˜ëª…ì´ ì¼ì¹˜í•˜ëŠ”ì§€ í™•ì¸ (`{{variable}}`)
- [ ] ë¹Œë“œ ë° ë¦°íŠ¸ í†µê³¼
- [ ] ì‹¤ì œ UIì—ì„œ ë¬¸ìì—´ì´ ì˜¬ë°”ë¥´ê²Œ í‘œì‹œë˜ëŠ”ì§€ í™•ì¸

## ì°¸ê³  ë¬¸ì„œ

- `vibe/prd.md` - 3.1(ì§€ì› ì–¸ì–´), 8.7(TurnInput.language)
- `vibe/tech-stack.md` - i18next/react-i18next ë²„ì „
- `.cursor/rules/00-core-critical.mdc` - RULE-006(i18n/ì–¸ì–´ í˜¼í•© ê¸ˆì§€)
- [i18next ê³µì‹ ë¬¸ì„œ](https://www.i18next.com/)
- [react-i18next ê³µì‹ ë¬¸ì„œ](https://react.i18next.com/)
</file>

<file path="frontend/src/save/constants.ts">
/**
 * Unknown World - SaveGame/ì„¸ì…˜ ê´€ë ¨ ìƒìˆ˜ SSOT (RU-004-Q5).
 *
 * ì •ì±…/ì´ˆê¸°ê°’ì„ í•œ ê³³ìœ¼ë¡œ ëª¨ì•„ ë³€ê²½ ì‹œ ëˆ„ë½ ìœ„í—˜ì„ ë°©ì§€í•©ë‹ˆë‹¤.
 * ëª¨ë“  SaveGame/ì„¸ì…˜ ê´€ë ¨ ìƒìˆ˜ëŠ” ì´ íŒŒì¼ì—ì„œ ê´€ë¦¬í•©ë‹ˆë‹¤.
 *
 * ì„¤ê³„ ì›ì¹™:
 *   - RU-004-Q5: í•˜ë“œì½”ë”© ì •ë¦¬ - ìƒìˆ˜ ì¤‘ì•™í™”
 *   - RULE-010: DB ë„ì… ê¸ˆì§€, SaveGame JSON ì§ë ¬í™” ê¸°ë°˜
 *   - í–¥í›„ í™•ì¥: U-026(ë¦¬í”Œë ˆì´), U-025(ì—”ë”© ë¦¬í¬íŠ¸) í˜¸í™˜
 *
 * @module save/constants
 */

// =============================================================================
// SaveGame ë²„ì „ ê´€ë¦¬
// =============================================================================

/**
 * í˜„ì¬ SaveGame ìŠ¤í‚¤ë§ˆ ë²„ì „.
 *
 * ë²„ì „ ë³€ê²½ ì‹œ `migrateSaveGame()`ì— ë§ˆì´ê·¸ë ˆì´ì…˜ ë¡œì§ì„ ì¶”ê°€í•´ì•¼ í•©ë‹ˆë‹¤.
 * ë²„ì „ í˜•ì‹: semver (major.minor.patch)
 *
 * @see saveGame.ts#migrateSaveGame
 */
export const SAVEGAME_VERSION = '1.0.0' as const;

/**
 * ì§€ì›í•˜ëŠ” SaveGame ë²„ì „ ëª©ë¡.
 *
 * ë§ˆì´ê·¸ë ˆì´ì…˜ ê°€ëŠ¥í•œ ì´ì „ ë²„ì „ë“¤ì„ í¬í•¨í•©ë‹ˆë‹¤.
 * ì´ ëª©ë¡ì— ì—†ëŠ” ë²„ì „ì€ ë§ˆì´ê·¸ë ˆì´ì…˜ ë¶ˆê°€ë¡œ ì²˜ë¦¬ë©ë‹ˆë‹¤.
 */
export const SUPPORTED_SAVEGAME_VERSIONS: readonly string[] = ['1.0.0'] as const;

// =============================================================================
// localStorage í‚¤ (Storage Keys)
// =============================================================================

/**
 * SaveGame ì €ì¥ í‚¤.
 *
 * localStorageì—ì„œ ì„¸ì´ë¸Œ ë°ì´í„°ë¥¼ ì €ì¥/ë¡œë“œí•  ë•Œ ì‚¬ìš©í•©ë‹ˆë‹¤.
 * ì´ í‚¤ë¥¼ ë³€ê²½í•˜ë©´ ê¸°ì¡´ ì„¸ì´ë¸Œ ë°ì´í„°ê°€ ë¬´íš¨í™”ë©ë‹ˆë‹¤.
 */
export const SAVEGAME_STORAGE_KEY = 'unknown_world_savegame' as const;

/**
 * í˜„ì¬ ì„ íƒëœ í”„ë¡œí•„ ID ì €ì¥ í‚¤.
 *
 * localStorageì—ì„œ í˜„ì¬ í”„ë¡œí•„ IDë¥¼ ì €ì¥/ë¡œë“œí•  ë•Œ ì‚¬ìš©í•©ë‹ˆë‹¤.
 * SaveGame.profileIdê°€ SSOTì´ë©°, ì´ í‚¤ëŠ” í´ë°±/í˜¸í™˜ì„±ìš©ì…ë‹ˆë‹¤.
 *
 * @see sessionLifecycle.ts#getInitialProfileId
 */
export const CURRENT_PROFILE_KEY = 'unknown_world_current_profile' as const;

// =============================================================================
// Seed ìƒì„± ì •ì±…
// =============================================================================

/**
 * ë°ëª¨ seed ì ‘ë‘ì‚¬.
 *
 * ë°ëª¨ í”„ë¡œí•„ì—ì„œ ìƒì„±ë˜ëŠ” seedì˜ ì ‘ë‘ì‚¬ì…ë‹ˆë‹¤.
 * seed í˜•ì‹: `{DEMO_SEED_PREFIX}-{profileId}-{timestamp}`
 *
 * @example 'demo-narrator-1706000000000'
 */
export const DEMO_SEED_PREFIX = 'demo' as const;

/**
 * Seed ìƒì„± ì •ì±… (ë¬¸ì„œí™”ìš© ì£¼ì„).
 *
 * ## í˜„ì¬ ì •ì±…: now ê¸°ë°˜ seed (ì„¸ì…˜ ë‹¤ì–‘ì„± ì¤‘ì‹œ)
 *
 * í”„ë¡œí•„ ì‹œì‘ ì‹œë§ˆë‹¤ ìƒˆë¡œìš´ seedê°€ ìƒì„±ë©ë‹ˆë‹¤.
 * - ì¥ì : ë§¤ ì„¸ì…˜ë§ˆë‹¤ ë‹¤ë¥¸ ì´ˆê¸° ìƒíƒœ/ì´ë²¤íŠ¸ ê°€ëŠ¥
 * - ë‹¨ì : ë°ëª¨ ë°˜ë³µì„±(ë™ì¼ ì‹œì‘) ë³´ì¥ ì–´ë ¤ì›€
 *
 * ## ëŒ€ì•ˆ: ê³ ì • seed (ë°ëª¨ ë°˜ë³µì„± ì¤‘ì‹œ)
 *
 * í”„ë¡œí•„ IDë§Œìœ¼ë¡œ seedë¥¼ ìƒì„±í•©ë‹ˆë‹¤.
 * - ì¥ì : ë™ì¼ í”„ë¡œí•„ì€ í•­ìƒ ë™ì¼í•œ ì‹œì‘ ìƒíƒœ
 * - ë‹¨ì : ì„¸ì…˜ ë‹¤ì–‘ì„± ë¶€ì¡±
 *
 * ## í–¥í›„ í™•ì¥ (U-026: ë¦¬í”Œë ˆì´)
 *
 * seedë¥¼ SaveGameì— ì €ì¥í•˜ì—¬ ë¦¬í”Œë ˆì´ ì‹œ ë™ì¼ ê²°ê³¼ ì¬í˜„ ê°€ëŠ¥.
 * ì—”ë”© ë¦¬í¬íŠ¸(U-025)ì—ì„œë„ seedë¥¼ ê¸°ë¡í•˜ì—¬ ê²°ê³¼ ë¶„ì„ì— í™œìš©.
 *
 * @see demoProfiles.ts#profileToSaveGameInput
 */
export const SEED_POLICY = {
  /** í˜„ì¬ ì ìš© ì¤‘ì¸ ì •ì±… */
  current: 'timestamp' as const,
  /** ê°€ëŠ¥í•œ ì •ì±… ëª©ë¡ */
  options: ['timestamp', 'fixed', 'hybrid'] as const,
} as const;

/**
 * Seedë¥¼ ìƒì„±í•©ë‹ˆë‹¤.
 *
 * í˜„ì¬ ì •ì±…(now ê¸°ë°˜)ì— ë”°ë¼ seed ë¬¸ìì—´ì„ ìƒì„±í•©ë‹ˆë‹¤.
 *
 * @param profileId - í”„ë¡œí•„ ID
 * @returns seed ë¬¸ìì—´
 */
export function generateDemoSeed(profileId: string): string {
  const now = Date.now();
  return `${DEMO_SEED_PREFIX}-${profileId}-${now}`;
}

// =============================================================================
// Economy ì •ì±… ìƒìˆ˜
// =============================================================================

/**
 * ì”ì•¡ ë¶€ì¡± ê²½ê³  ì„ê³„ê°’ (Signal ê¸°ì¤€).
 *
 * Signal ì”ì•¡ì´ ì´ ê°’ ë¯¸ë§Œì´ë©´ isBalanceLowê°€ trueê°€ ë©ë‹ˆë‹¤.
 * HUDì—ì„œ ê²½ê³  í‘œì‹œ ë° ëŒ€ì²´ í–‰ë™ ì œì•ˆì— ì‚¬ìš©ë©ë‹ˆë‹¤.
 *
 * @see economyStore.ts#updateBalanceLowStatus
 */
export const LOW_BALANCE_THRESHOLD = 10 as const;

/**
 * ì›ì¥(Ledger) ìµœëŒ€ ë³´ê´€ ê°œìˆ˜.
 *
 * ìµœê·¼ Nê°œì˜ í„´ ì›ì¥ë§Œ ë³´ê´€í•©ë‹ˆë‹¤ (ë©”ëª¨ë¦¬ ìµœì í™”).
 * ì„¸ì…˜ ë‚´ì—ì„œë§Œ ìœ ì§€ë˜ë©°, SaveGameì— í•¨ê»˜ ì €ì¥ë©ë‹ˆë‹¤.
 *
 * @see economyStore.ts#addLedgerEntry
 */
export const LEDGER_MAX_ENTRIES = 20 as const;

// =============================================================================
// ì´ˆê¸°ê°’ ì •ì±… (Placeholder vs ì£¼ì…)
// =============================================================================

/**
 * World/Economy ì´ˆê¸°ê°’ ì •ì±… (ë¬¸ì„œí™”ìš© ì£¼ì„).
 *
 * ## ì„¤ê³„ ì›ì¹™
 *
 * Storeì˜ createInitialState()ì—ì„œ ì •ì˜í•˜ëŠ” economy ë“±ì˜ ê°’ì€
 * **"í”Œë ˆì´ ì „ placeholder"**ë¡œ ì·¨ê¸‰í•©ë‹ˆë‹¤.
 *
 * ì‹¤ì œ ê²Œì„ ì‹œì‘ ê°’ì€ í•­ìƒ ë‹¤ìŒ ì¤‘ í•˜ë‚˜ì—ì„œ ì£¼ì…ë©ë‹ˆë‹¤:
 * 1. í”„ë¡œí•„ ì´ˆê¸° SaveGame (startSessionFromProfile)
 * 2. ì €ì¥ëœ SaveGame ë³µì› (continueSession)
 *
 * ## Placeholder ê°’ì˜ ì˜ë¯¸
 *
 * - worldStore.economy: { signal: 100, memory_shard: 5 }
 *   â†’ playing ì§„ì… ì „ profile_select ìƒíƒœì—ì„œëŠ” HUDê°€ ë…¸ì¶œë˜ì§€ ì•ŠìŒ
 *   â†’ ë”°ë¼ì„œ ì´ ê°’ì´ í™”ë©´ì— í‘œì‹œë  ì¼ì€ ì—†ìŒ
 *
 * ## í–¥í›„ ê°œì„  (S2 ì„ í–‰ í•„ìš”)
 *
 * S2(ì˜ëª»ëœ playing ì§„ì…)ê°€ í•´ê²°ë˜ë©´:
 * - economy: null ê°™ì€ "ë¯¸ì´ˆê¸°í™” ìƒíƒœ"ë¡œ ë³€ê²½ ê°€ëŠ¥
 * - playing ì§„ì… ì „ì— ë°˜ë“œì‹œ í”„ë¡œí•„/ì„¸ì´ë¸Œ ì£¼ì…ì„ ê°•ì œ
 * - "placeholderê°€ í™”ë©´ì— ë³´ì´ëŠ”" ë¬¸ì œë¥¼ ì›ì²œ ì°¨ë‹¨
 *
 * @see worldStore.ts#createInitialState
 * @see sessionLifecycle.ts
 */
export const INITIAL_VALUE_POLICY = {
  description: 'Placeholder values for pre-play state',
  worldEconomy: {
    signal: 100,
    memory_shard: 5,
  },
} as const;

// =============================================================================
// ë°ëª¨ í”„ë¡œí•„ ê¸°ë³¸ ì¬í™” ë²”ìœ„ (ì°¸ê³ ìš©)
// =============================================================================

/**
 * ë°ëª¨ í”„ë¡œí•„ ì¬í™” ë²”ìœ„ ì°¸ê³  (ë¬¸ì„œí™”ìš©).
 *
 * ê° í”„ë¡œí•„ì˜ ì´ˆê¸° ì¬í™”ëŠ” demoProfiles.tsì—ì„œ ì§ì ‘ ì •ì˜í•©ë‹ˆë‹¤.
 * ì´ ìƒìˆ˜ëŠ” "ì •ì±… ë²”ìœ„"ë¥¼ ë¬¸ì„œí™”í•˜ê¸° ìœ„í•œ ì°¸ê³ ìš©ì…ë‹ˆë‹¤.
 *
 * - Narrator: í’ë¶€í•œ ì¬í™” (ë‹¤ì–‘í•œ ì„ íƒì§€ íƒìƒ‰)
 * - Explorer: ì ë‹¹í•œ ì¬í™” (ê· í˜• ì¡íŒ í”Œë ˆì´)
 * - Tech: ì œí•œëœ ì¬í™” (íš¨ìœ¨ì  ì „ëµ í•„ìš”)
 *
 * @see demoProfiles.ts
 */
export const DEMO_PROFILE_ECONOMY_REFERENCE = {
  narrator: { signal: 200, memory_shard: 10 },
  explorer: { signal: 150, memory_shard: 5 },
  tech: { signal: 80, memory_shard: 15 },
} as const;
</file>

<file path="frontend/src/save/saveGame.test.ts">
import { describe, it, expect, beforeEach, vi } from 'vitest';
import {
  SaveGameSchema,
  createSaveGame,
  saveSaveGame,
  loadSaveGame,
  clearSaveGame,
  hasSaveGame,
  SAVEGAME_STORAGE_KEY,
  SAVEGAME_VERSION,
  type SaveGameInput,
} from './saveGame';

describe('saveGame utility (U-015[Mvp])', () => {
  beforeEach(() => {
    // localStorage ì´ˆê¸°í™”
    localStorage.clear();
    vi.clearAllMocks();
  });

  const mockInput: SaveGameInput = {
    language: 'ko-KR',
    profileId: 'explorer',
    seed: 'test-seed',
    economy: { signal: 100, memory_shard: 5 },
    economyLedger: [],
    turnCount: 1,
    narrativeHistory: [{ turn: 1, text: 'í…ŒìŠ¤íŠ¸ ë‚´ëŸ¬í‹°ë¸Œ' }],
    inventory: [{ id: 'item1', name: 'ì•„ì´í…œ1', quantity: 1 }],
    quests: [{ id: 'q1', label: 'í€˜ìŠ¤íŠ¸1', is_completed: false }],
    activeRules: [{ id: 'r1', label: 'ê·œì¹™1', description: 'ì„¤ëª…1' }],
    mutationTimeline: [],
    sceneObjects: [],
  };

  it('createSaveGameì€ ì˜¬ë°”ë¥¸ ìŠ¤í‚¤ë§ˆë¥¼ ê°€ì§„ ê°ì²´ë¥¼ ìƒì„±í•´ì•¼ í•œë‹¤', () => {
    const saveGame = createSaveGame(mockInput);

    expect(saveGame.version).toBe(SAVEGAME_VERSION);
    expect(saveGame.language).toBe('ko-KR');
    expect(saveGame.profileId).toBe('explorer');
    expect(saveGame.economy.signal).toBe(100);
    expect(saveGame.inventory).toHaveLength(1);
    expect(saveGame.inventory[0].name).toBe('ì•„ì´í…œ1');

    // Zod ìŠ¤í‚¤ë§ˆ ê²€ì¦
    const result = SaveGameSchema.safeParse(saveGame);
    expect(result.success).toBe(true);
  });

  it('saveSaveGameì€ ë°ì´í„°ë¥¼ localStorageì— ì €ì¥í•´ì•¼ í•œë‹¤', () => {
    const saveGame = createSaveGame(mockInput);
    const success = saveSaveGame(saveGame);

    expect(success).toBe(true);
    expect(localStorage.getItem(SAVEGAME_STORAGE_KEY)).not.toBeNull();

    const storedData = JSON.parse(localStorage.getItem(SAVEGAME_STORAGE_KEY)!);
    expect(storedData.profileId).toBe('explorer');
  });

  it('loadSaveGameì€ ì €ì¥ëœ ë°ì´í„°ë¥¼ ì˜¬ë°”ë¥´ê²Œ ë¡œë“œí•´ì•¼ í•œë‹¤', () => {
    const saveGame = createSaveGame(mockInput);
    saveSaveGame(saveGame);

    const loaded = loadSaveGame();
    expect(loaded).not.toBeNull();
    expect(loaded?.profileId).toBe('explorer');
    expect(loaded?.version).toBe(SAVEGAME_VERSION);
  });

  it('ë°ì´í„°ê°€ ì—†ì„ ë•Œ loadSaveGameì€ nullì„ ë°˜í™˜í•´ì•¼ í•œë‹¤', () => {
    const loaded = loadSaveGame();
    expect(loaded).toBeNull();
  });

  it('ìœ íš¨í•˜ì§€ ì•Šì€ ë°ì´í„°ê°€ ì €ì¥ë˜ì–´ ìˆìœ¼ë©´ loadSaveGameì€ nullì„ ë°˜í™˜í•´ì•¼ í•œë‹¤', () => {
    localStorage.setItem(SAVEGAME_STORAGE_KEY, JSON.stringify({ version: 'unknown' }));

    // safeParse ì‹¤íŒ¨ë¡œ ì¸í•´ null ë°˜í™˜ ì˜ˆìƒ
    const loaded = loadSaveGame();
    expect(loaded).toBeNull();
  });

  it('clearSaveGameì€ ì €ì¥ëœ ë°ì´í„°ë¥¼ ì‚­ì œí•´ì•¼ í•œë‹¤', () => {
    const saveGame = createSaveGame(mockInput);
    saveSaveGame(saveGame);
    expect(hasSaveGame()).toBe(true);

    clearSaveGame();
    expect(hasSaveGame()).toBe(false);
    expect(localStorage.getItem(SAVEGAME_STORAGE_KEY)).toBeNull();
  });

  it('hasSaveGameì€ ë°ì´í„° ì¡´ì¬ ì—¬ë¶€ë¥¼ ì •í™•íˆ ë°˜í™˜í•´ì•¼ í•œë‹¤', () => {
    expect(hasSaveGame()).toBe(false);

    const saveGame = createSaveGame(mockInput);
    saveSaveGame(saveGame);
    expect(hasSaveGame()).toBe(true);
  });
});
</file>

<file path="frontend/src/save/sessionLifecycle.test.ts">
import { describe, it, expect, beforeEach, vi } from 'vitest';
import {
  bootstrapSession,
  startSessionFromProfile,
  continueSession,
  resetToCurrentProfile,
  clearSessionAndReturnToSelect,
  saveCurrentSession,
  getInitialProfileId,
} from './sessionLifecycle';
import { useWorldStore } from '../stores/worldStore';
import { useInventoryStore } from '../stores/inventoryStore';
import { useEconomyStore } from '../stores/economyStore';
import { SAVEGAME_STORAGE_KEY, CURRENT_PROFILE_KEY, SAVEGAME_VERSION } from './constants';
import { PROFILE_EXPLORER } from '../data/demoProfiles';
import * as i18nModule from '../i18n';

// i18n ëª¨ë“ˆ mock
vi.mock('../i18n', async () => {
  const actual = await vi.importActual('../i18n');
  return {
    ...actual,
    changeLanguage: vi.fn().mockResolvedValue(undefined),
    getResolvedLanguage: vi.fn().mockReturnValue('ko-KR'),
  };
});

describe('sessionLifecycle (RU-004[Mvp])', () => {
  const mockT = (key: string) => `translated-${key}`;

  beforeEach(() => {
    localStorage.clear();
    vi.clearAllMocks();

    // Store ì´ˆê¸°í™”
    useWorldStore.getState().reset();
    useInventoryStore.getState().reset();
    useEconomyStore.getState().reset();
  });

  describe('bootstrapSession', () => {
    it('ì„¸ì´ë¸Œ ë°ì´í„°ê°€ ì—†ìœ¼ë©´ profile_select phaseë¥¼ ë°˜í™˜í•´ì•¼ í•œë‹¤', () => {
      const result = bootstrapSession();
      expect(result.phase).toBe('profile_select');
      if (result.phase === 'profile_select') {
        expect(result.savedGameAvailable).toBe(false);
      }
    });

    it('ìœ íš¨í•œ ì„¸ì´ë¸Œ ë°ì´í„°ê°€ ìˆìœ¼ë©´ playing phaseë¥¼ ë°˜í™˜í•´ì•¼ í•œë‹¤', () => {
      // ìœ íš¨í•œ ì„¸ì´ë¸Œ ìƒì„± ë° ì €ì¥
      const saveGame = {
        version: SAVEGAME_VERSION,
        language: 'ko-KR',
        profileId: 'explorer',
        savedAt: new Date().toISOString(),
        economy: { signal: 100, memory_shard: 5 },
        economyLedger: [],
        turnCount: 1,
        narrativeHistory: [],
        inventory: [],
        quests: [],
        activeRules: [],
        mutationTimeline: [],
        sceneObjects: [],
      };
      localStorage.setItem(SAVEGAME_STORAGE_KEY, JSON.stringify(saveGame));

      const result = bootstrapSession();
      expect(result.phase).toBe('playing');
      if (result.phase === 'playing') {
        expect(result.profileId).toBe('explorer');
      }
    });
  });

  describe('startSessionFromProfile', () => {
    it('í”„ë¡œí•„ ê¸°ë°˜ìœ¼ë¡œ ì„¸ì…˜ì„ ì‹œì‘í•˜ê³  storeì™€ localStorageë¥¼ ì—…ë°ì´íŠ¸í•´ì•¼ í•œë‹¤', () => {
      const result = startSessionFromProfile({
        profile: PROFILE_EXPLORER,
        t: mockT,
      });

      expect(result.success).toBe(true);
      expect(result.profileId).toBe(PROFILE_EXPLORER.id);

      // Store ìƒíƒœ í™•ì¸
      const worldState = useWorldStore.getState();
      expect(worldState.economy.signal).toBe(PROFILE_EXPLORER.initialState.economy.signal);
      expect(worldState.turnCount).toBe(0);
      expect(worldState.narrativeEntries).toHaveLength(1);

      const inventoryState = useInventoryStore.getState();
      expect(inventoryState.items).toHaveLength(PROFILE_EXPLORER.initialState.inventoryDefs.length);

      // localStorage í™•ì¸
      expect(localStorage.getItem(CURRENT_PROFILE_KEY)).toBe(PROFILE_EXPLORER.id);
      expect(localStorage.getItem(SAVEGAME_STORAGE_KEY)).not.toBeNull();
    });
  });

  describe('continueSession', () => {
    it('ì €ì¥ëœ ë°ì´í„°ë¥¼ ë¡œë“œí•˜ê³  storeë¥¼ ë³µì›í•´ì•¼ í•œë‹¤', async () => {
      const saveGame = {
        version: SAVEGAME_VERSION,
        language: 'en-US',
        profileId: 'explorer',
        savedAt: new Date().toISOString(),
        economy: { signal: 123, memory_shard: 45 },
        economyLedger: [],
        turnCount: 5,
        narrativeHistory: [{ turn: 1, text: 'old message' }],
        inventory: [{ id: 'item1', name: 'Item 1', quantity: 2 }],
        quests: [],
        activeRules: [],
        mutationTimeline: [],
        sceneObjects: [],
      };
      localStorage.setItem(SAVEGAME_STORAGE_KEY, JSON.stringify(saveGame));

      const result = await continueSession();

      expect(result?.success).toBe(true);
      expect(result?.profileId).toBe('explorer');

      // ì–¸ì–´ ë³€ê²½ í˜¸ì¶œ í™•ì¸
      expect(i18nModule.changeLanguage).toHaveBeenCalledWith('en-US');

      // Store ìƒíƒœ í™•ì¸
      const worldState = useWorldStore.getState();
      expect(worldState.economy.signal).toBe(123);
      expect(worldState.turnCount).toBe(5);
      expect(worldState.narrativeEntries).toHaveLength(1);

      const inventoryState = useInventoryStore.getState();
      expect(inventoryState.items).toHaveLength(1);
      expect(inventoryState.items[0].id).toBe('item1');
    });

    it('ë°ì´í„°ê°€ ì—†ìœ¼ë©´ nullì„ ë°˜í™˜í•˜ê³  í´ë¦°ì—…í•´ì•¼ í•œë‹¤', async () => {
      localStorage.setItem(CURRENT_PROFILE_KEY, 'some-profile');

      const result = await continueSession();

      expect(result).toBeNull();
      expect(localStorage.getItem(SAVEGAME_STORAGE_KEY)).toBeNull();
      expect(localStorage.getItem(CURRENT_PROFILE_KEY)).toBeNull();
    });
  });

  describe('resetToCurrentProfile', () => {
    it('í˜„ì¬ í”„ë¡œí•„ë¡œ ì„¸ì…˜ì„ ë¦¬ì…‹í•´ì•¼ í•œë‹¤', () => {
      // ë¨¼ì € ì„¸ì…˜ ì‹œì‘
      startSessionFromProfile({
        profile: PROFILE_EXPLORER,
        t: mockT,
      });

      // ìƒíƒœ ë³€ê²½ ì‹œë®¬ë ˆì´ì…˜
      useWorldStore.setState({ turnCount: 10, economy: { signal: 0, memory_shard: 0 } });

      const result = resetToCurrentProfile({
        t: mockT,
        currentProfileId: PROFILE_EXPLORER.id,
      });

      expect(result.success).toBe(true);
      expect(result.profileId).toBe(PROFILE_EXPLORER.id);

      // ì´ˆê¸° ìƒíƒœë¡œ ë³µì›ë˜ì—ˆëŠ”ì§€ í™•ì¸
      const worldState = useWorldStore.getState();
      expect(worldState.turnCount).toBe(0);
      expect(worldState.economy.signal).toBe(PROFILE_EXPLORER.initialState.economy.signal);
    });
  });

  describe('clearSessionAndReturnToSelect', () => {
    it('ëª¨ë“  ë°ì´í„°ë¥¼ ì‚­ì œí•˜ê³  storeë¥¼ ì´ˆê¸°í™”í•´ì•¼ í•œë‹¤', () => {
      // ë°ì´í„° ì±„ìš°ê¸°
      startSessionFromProfile({
        profile: PROFILE_EXPLORER,
        t: mockT,
      });

      clearSessionAndReturnToSelect();

      expect(localStorage.getItem(SAVEGAME_STORAGE_KEY)).toBeNull();
      expect(localStorage.getItem(CURRENT_PROFILE_KEY)).toBeNull();

      const worldState = useWorldStore.getState();
      expect(worldState.narrativeEntries).toHaveLength(0);
    });
  });

  describe('saveCurrentSession', () => {
    it('í˜„ì¬ ìƒíƒœë¥¼ localStorageì— ì €ì¥í•´ì•¼ í•œë‹¤', () => {
      startSessionFromProfile({
        profile: PROFILE_EXPLORER,
        t: mockT,
      });

      // ìƒíƒœ ë³€ê²½
      useWorldStore.setState({ turnCount: 1 });

      const success = saveCurrentSession(PROFILE_EXPLORER.id);
      expect(success).toBe(true);

      const saved = JSON.parse(localStorage.getItem(SAVEGAME_STORAGE_KEY)!);
      expect(saved.turnCount).toBe(1);
    });
  });

  describe('getInitialProfileId', () => {
    it('ì„¸ì´ë¸Œ ë°ì´í„°ê°€ ìˆìœ¼ë©´ ê·¸ ì•ˆì˜ profileIdë¥¼ ìš°ì„ í•´ì•¼ í•œë‹¤', () => {
      localStorage.setItem(
        SAVEGAME_STORAGE_KEY,
        JSON.stringify({
          version: SAVEGAME_VERSION,
          language: 'ko-KR',
          profileId: 'saved-profile',
          savedAt: new Date().toISOString(),
          economy: { signal: 100, memory_shard: 5 },
          economyLedger: [],
          turnCount: 1,
          narrativeHistory: [],
          inventory: [],
          quests: [],
          activeRules: [],
          mutationTimeline: [],
          sceneObjects: [],
        }),
      );
      localStorage.setItem(CURRENT_PROFILE_KEY, 'fallback-profile');

      expect(getInitialProfileId()).toBe('saved-profile');
    });

    it('ì„¸ì´ë¸Œ ë°ì´í„°ê°€ ì—†ìœ¼ë©´ CURRENT_PROFILE_KEYë¥¼ ì‚¬ìš©í•´ì•¼ í•œë‹¤', () => {
      localStorage.setItem(CURRENT_PROFILE_KEY, 'fallback-profile');
      expect(getInitialProfileId()).toBe('fallback-profile');
    });
  });
});
</file>

<file path="frontend/src/schemas/index.ts">
/**
 * Unknown World - ìŠ¤í‚¤ë§ˆ ëª¨ë“ˆ ì§„ì…ì .
 *
 * TurnInput/TurnOutput Zod ìŠ¤í‚¤ë§ˆ ë° ê´€ë ¨ ìœ í‹¸ë¦¬í‹°ë¥¼ ì¬ë‚´ë³´ë‚´ê¸°í•©ë‹ˆë‹¤.
 *
 * @module schemas
 */

// =============================================================================
// ìŠ¤í‚¤ë§ˆ ë²„ì „
// =============================================================================

export { SCHEMA_VERSION } from './turn';

// =============================================================================
// Enum ìŠ¤í‚¤ë§ˆ ë° íƒ€ì…
// =============================================================================

export {
  LanguageSchema,
  ThemeSchema,
  AgentPhaseSchema,
  ValidationBadgeSchema,
  ModelLabelSchema,
  RiskLevelSchema,
} from './turn';

export type { Language, Theme, AgentPhase, ValidationBadge, ModelLabel, RiskLevel } from './turn';

// =============================================================================
// ê³µí†µ í•˜ìœ„ íƒ€ì… ìŠ¤í‚¤ë§ˆ ë° íƒ€ì…
// =============================================================================

export { CoordinateSchema, Box2DSchema, CurrencyAmountSchema } from './turn';

export type { Coordinate, Box2D, CurrencyAmount } from './turn';

// =============================================================================
// TurnInput ê´€ë ¨ ìŠ¤í‚¤ë§ˆ ë° íƒ€ì…
// =============================================================================

export { ClickInputSchema, ClientInfoSchema, EconomySnapshotSchema, TurnInputSchema } from './turn';

export type { ClickInput, ClientInfo, EconomySnapshot, TurnInput } from './turn';

// =============================================================================
// TurnOutput ê´€ë ¨ ìŠ¤í‚¤ë§ˆ ë° íƒ€ì…
// =============================================================================

export {
  // UI
  ActionCardSchema,
  SceneObjectSchema,
  ActionDeckSchema,
  UIOutputSchema,
  // World
  MemoryPinSchema,
  WorldRuleSchema,
  QuestSchema,
  WorldDeltaSchema,
  // Render
  ImageJobSchema,
  RenderOutputSchema,
  // Economy
  EconomyOutputSchema,
  // Safety
  SafetyOutputSchema,
  // Agent Console
  AgentConsoleSchema,
  // Main
  TurnOutputSchema,
} from './turn';

export type {
  // UI
  ActionCard,
  SceneObject,
  ActionDeck,
  UIOutput,
  // World
  MemoryPin,
  WorldRule,
  Quest,
  WorldDelta,
  // Render
  ImageJob,
  RenderOutput,
  // Economy
  EconomyOutput,
  // Safety
  SafetyOutput,
  // Agent Console
  AgentConsole,
  // Main
  TurnOutput,
} from './turn';

// =============================================================================
// ìœ í‹¸ë¦¬í‹° í•¨ìˆ˜
// =============================================================================

export {
  createFallbackTurnOutput,
  safeParseTurnOutput,
  parseTurnInput,
  safeParseTurnInput,
} from './turn';

export type { TurnOutputParseResult, TurnInputSafeParseResult } from './turn';
</file>

<file path="frontend/src/schemas/turn.test.ts">
import { describe, it, expect } from 'vitest';
import {
  TurnInputSchema,
  TurnOutputSchema,
  safeParseTurnOutput,
  parseTurnInput,
  safeParseTurnInput,
  SCHEMA_VERSION,
} from './turn';

describe('Turn schemas', () => {
  describe('SCHEMA_VERSION', () => {
    it('should have correct version', () => {
      expect(SCHEMA_VERSION).toBe('1.0.0');
    });
  });

  describe('TurnInputSchema', () => {
    const validTurnInput = {
      language: 'ko-KR',
      text: 'í…ŒìŠ¤íŠ¸ ì…ë ¥',
      client: {
        viewport_w: 1920,
        viewport_h: 1080,
        theme: 'dark',
      },
      economy_snapshot: {
        signal: 100,
        memory_shard: 5,
      },
    };

    it('should validate a valid TurnInput', () => {
      const result = TurnInputSchema.safeParse(validTurnInput);
      expect(result.success).toBe(true);
    });

    it('should fail on invalid language', () => {
      const result = TurnInputSchema.safeParse({
        ...validTurnInput,
        language: 'fr-FR',
      });
      expect(result.success).toBe(false);
    });

    it('should fail on negative economy values', () => {
      const result = TurnInputSchema.safeParse({
        ...validTurnInput,
        economy_snapshot: {
          signal: -1,
          memory_shard: 0,
        },
      });
      expect(result.success).toBe(false);
    });

    it('should fail on extra fields (strict)', () => {
      const result = TurnInputSchema.safeParse({
        ...validTurnInput,
        extra_field: 'not allowed',
      });
      expect(result.success).toBe(false);
    });

    it('should validate click input with bbox', () => {
      const result = TurnInputSchema.safeParse({
        ...validTurnInput,
        click: {
          object_id: 'door_01',
          box_2d: {
            ymin: 100,
            xmin: 100,
            ymax: 500,
            xmax: 500,
          },
        },
      });
      expect(result.success).toBe(true);
    });

    it('should fail on invalid bbox coordinates (out of range 0-1000)', () => {
      const result = TurnInputSchema.safeParse({
        ...validTurnInput,
        click: {
          object_id: 'door_01',
          box_2d: {
            ymin: -1,
            xmin: 0,
            ymax: 1001,
            xmax: 500,
          },
        },
      });
      expect(result.success).toBe(false);
    });

    it('should fail on non-positive viewport dimensions', () => {
      const result = TurnInputSchema.safeParse({
        ...validTurnInput,
        client: {
          viewport_w: 0,
          viewport_h: -100,
          theme: 'dark',
        },
      });
      expect(result.success).toBe(false);
    });

    it('should fail on non-integer coordinates', () => {
      const result = TurnInputSchema.safeParse({
        ...validTurnInput,
        click: {
          object_id: 'obj',
          box_2d: {
            ymin: 10.5,
            xmin: 20,
            ymax: 30,
            xmax: 40,
          },
        },
      });
      expect(result.success).toBe(false);
    });
  });

  describe('TurnOutputSchema', () => {
    const validTurnOutput = {
      language: 'ko-KR',
      narrative: 'í…ŒìŠ¤íŠ¸ ë‚´ëŸ¬í‹°ë¸Œ',
      economy: {
        cost: { signal: 5, memory_shard: 0 },
        balance_after: { signal: 95, memory_shard: 5 },
      },
      safety: {
        blocked: false,
      },
      agent_console: {
        current_phase: 'commit',
        badges: ['schema_ok', 'economy_ok'],
        repair_count: 0,
      },
    };

    it('should validate a valid TurnOutput', () => {
      const result = TurnOutputSchema.safeParse(validTurnOutput);
      expect(result.success).toBe(true);
    });

    it('should fail if required fields are missing', () => {
      const { narrative: _narrative, ...invalidOutput } = validTurnOutput;
      const result = TurnOutputSchema.safeParse(invalidOutput);
      expect(result.success).toBe(false);
    });

    it('should handle default values for optional fields', () => {
      const result = TurnOutputSchema.safeParse(validTurnOutput);
      if (result.success) {
        expect(result.data.ui).toBeDefined();
        expect(result.data.ui.action_deck.cards).toEqual([]);
        expect(result.data.world.rules_changed).toEqual([]);
      } else {
        throw new Error('Validation failed');
      }
    });

    it('should fail if there are too many action cards (max 10)', () => {
      const cards = Array.from({ length: 11 }, (_, i) => ({
        id: `card_${i}`,
        label: `Card ${i}`,
        cost: { signal: 0, memory_shard: 0 },
        risk: 'low',
      }));
      const result = TurnOutputSchema.safeParse({
        ...validTurnOutput,
        ui: {
          action_deck: { cards },
        },
      });
      expect(result.success).toBe(false);
    });

    it('should fail on negative repair_count', () => {
      const result = TurnOutputSchema.safeParse({
        ...validTurnOutput,
        agent_console: {
          current_phase: 'commit',
          badges: [],
          repair_count: -1,
        },
      });
      expect(result.success).toBe(false);
    });
  });

  describe('safeParseTurnOutput', () => {
    it('should return success for valid data', () => {
      const validTurnOutput = {
        language: 'en-US',
        narrative: 'Test narrative',
        economy: {
          cost: { signal: 0, memory_shard: 0 },
          balance_after: { signal: 100, memory_shard: 0 },
        },
        safety: { blocked: false },
      };
      const result = safeParseTurnOutput(validTurnOutput);
      expect(result.success).toBe(true);
      if (result.success) {
        expect(result.data.language).toBe('en-US');
      }
    });

    it('should return fallback for invalid data', () => {
      const invalidData = { some: 'garbage' };
      const result = safeParseTurnOutput(invalidData, 'ko-KR', 1);
      expect(result.success).toBe(false);
      if (!result.success) {
        expect(result.fallback).toBeDefined();
        expect(result.fallback.language).toBe('ko-KR');
        expect(result.fallback.agent_console.badges).toContain('schema_fail');
        expect(result.fallback.agent_console.repair_count).toBe(1);
      }
    });
  });

  describe('Input Parsing Utilities', () => {
    const validTurnInput = {
      language: 'ko-KR',
      text: 'í…ŒìŠ¤íŠ¸ ì…ë ¥',
      client: {
        viewport_w: 1920,
        viewport_h: 1080,
        theme: 'dark',
      },
      economy_snapshot: {
        signal: 100,
        memory_shard: 5,
      },
    };

    describe('parseTurnInput', () => {
      it('should parse valid input', () => {
        const result = parseTurnInput(validTurnInput);
        expect(result.text).toBe('í…ŒìŠ¤íŠ¸ ì…ë ¥');
      });

      it('should throw error for invalid input', () => {
        expect(() => parseTurnInput({})).toThrow();
      });
    });

    describe('safeParseTurnInput', () => {
      it('should return success for valid input', () => {
        const result = safeParseTurnInput(validTurnInput);
        expect(result.success).toBe(true);
      });

      it('should return failure for invalid input', () => {
        const result = safeParseTurnInput({});
        expect(result.success).toBe(false);
      });
    });
  });
});
</file>

<file path="frontend/src/schemas/verify_runbook.ts">
import {
  TurnOutputSchema,
  safeParseTurnOutput,
  Box2DSchema,
  CurrencyAmountSchema,
  LanguageSchema,
  parseTurnInput,
} from './turn.js';

console.log('--- Scenario A: TurnOutput ìŠ¤í‚¤ë§ˆ ê²€ì¦ (ì •ìƒ ì¼€ì´ìŠ¤) ---');
const validOutput = {
  language: 'ko-KR',
  narrative: 'ë¬¸ì´ ì‚ê±±ê±°ë¦¬ë©° ì—´ë¦½ë‹ˆë‹¤...',
  economy: {
    cost: { signal: 5, memory_shard: 0 },
    balance_after: { signal: 95, memory_shard: 5 },
  },
  safety: { blocked: false, message: null },
};
const resultA = safeParseTurnOutput(validOutput);
console.log('Success:', resultA.success);
if (resultA.success) {
  console.log('Data (sample):', resultA.data.narrative);
}

console.log('\n--- Scenario B: TurnOutput ìŠ¤í‚¤ë§ˆ ê²€ì¦ ì‹¤íŒ¨ â†’ í´ë°± ---');
const invalidOutput = {
  language: 'ko-KR',
  narrative: 'í…ŒìŠ¤íŠ¸',
};
// eslint-disable-next-line @typescript-eslint/no-explicit-any
const resultB = safeParseTurnOutput(invalidOutput as any);
console.log('Success:', resultB.success);
if (!resultB.success) {
  console.log('Error count:', resultB.error.issues.length);
  console.log('Fallback exists:', !!resultB.fallback);
  console.log(
    'Fallback badges has schema_fail:',
    resultB.fallback?.agent_console?.badges?.includes('schema_fail'),
  );
}

console.log('\n--- Scenario C: ì¢Œí‘œ ë²”ìœ„ ê²€ì¦ (RULE-009) ---');
const validBox = { ymin: 100, xmin: 200, ymax: 300, xmax: 400 };
console.log('Valid box:', Box2DSchema.safeParse(validBox).success);
const invalidBox = { ymin: 100, xmin: 200, ymax: 1500, xmax: 400 };
console.log('Invalid box (1500):', Box2DSchema.safeParse(invalidBox).success);
const negativeBox = { ymin: -10, xmin: 200, ymax: 300, xmax: 400 };
console.log('Negative box:', Box2DSchema.safeParse(negativeBox).success);

console.log('\n--- Scenario D: ì¬í™” ì¸ë°”ë¦¬ì–¸íŠ¸ ê²€ì¦ (RULE-005) ---');
const validCurrency = { signal: 100, memory_shard: 5 };
console.log('Valid currency:', CurrencyAmountSchema.safeParse(validCurrency).success);
const negativeCurrency = { signal: -10, memory_shard: 5 };
console.log('Negative signal:', CurrencyAmountSchema.safeParse(negativeCurrency).success);

console.log('\n--- Scenario E: ì–¸ì–´ ì •ì±… ê²€ì¦ (RULE-006) ---');
console.log('ko-KR:', LanguageSchema.safeParse('ko-KR').success);
console.log('en-US:', LanguageSchema.safeParse('en-US').success);
console.log('ja-JP (invalid):', LanguageSchema.safeParse('ja-JP').success);
console.log('ko (invalid format):', LanguageSchema.safeParse('ko').success);

console.log('\n--- Scenario F: TurnInput ê²€ì¦ ---');
const validInput = {
  language: 'ko-KR',
  text: 'ë¬¸ì„ ì—´ì–´ë³¸ë‹¤',
  client: {
    viewport_w: 1920,
    viewport_h: 1080,
    theme: 'dark',
  },
  economy_snapshot: {
    signal: 100,
    memory_shard: 5,
  },
};
try {
  // eslint-disable-next-line @typescript-eslint/no-explicit-any
  const parsed = parseTurnInput(validInput as any);
  console.log('Parsed successfully:', parsed.text);
} catch (e) {
  console.log('Parse error:', e);
}

console.log('\n--- Scenario G: Strict ëª¨ë“œ ê²€ì¦ ---');
const outputWithExtra = {
  language: 'ko-KR',
  narrative: 'í…ŒìŠ¤íŠ¸',
  economy: {
    cost: { signal: 0, memory_shard: 0 },
    balance_after: { signal: 100, memory_shard: 5 },
  },
  safety: { blocked: false, message: null },
  unknown_field: 'ì´ í•„ë“œëŠ” ìŠ¤í‚¤ë§ˆì— ì—†ìŒ',
};
const resultG = TurnOutputSchema.safeParse(outputWithExtra);
console.log('With extra field success:', resultG.success);
if (!resultG.success) {
  console.log('Error code:', resultG.error.issues[0].code);
}
</file>

<file path="frontend/src/setupTests.ts">
import '@testing-library/jest-dom';
</file>

<file path="frontend/src/stores/actionDeckStore.test.ts">
import { describe, it, expect, beforeEach } from 'vitest';
import { useActionDeckStore, filterAffordableCards } from './actionDeckStore';
import type { ActionCard } from '../schemas/turn';

describe('actionDeckStore', () => {
  beforeEach(() => {
    useActionDeckStore.getState().reset();
  });

  const mockCards: ActionCard[] = [
    {
      id: 'card-1',
      label: 'Card 1',
      description: null,
      cost: { signal: 10, memory_shard: 0 },
      cost_estimate: null,
      risk: 'low',
      hint: null,
      reward_hint: null,
      enabled: true,
      disabled_reason: null,
      is_alternative: false,
    },
    {
      id: 'card-2',
      label: 'Card 2',
      description: null,
      cost: { signal: 50, memory_shard: 1 },
      cost_estimate: null,
      risk: 'high',
      hint: null,
      reward_hint: null,
      enabled: true,
      disabled_reason: null,
      is_alternative: false,
    },
  ];

  it('sets cards and resets selected card', () => {
    const store = useActionDeckStore.getState();
    store.selectCard('some-id');
    expect(useActionDeckStore.getState().selectedCardId).toBe('some-id');

    store.setCards(mockCards);
    expect(useActionDeckStore.getState().cards).toEqual(mockCards);
    expect(useActionDeckStore.getState().selectedCardId).toBeNull();
  });

  it('marks a card as executed', () => {
    const store = useActionDeckStore.getState();
    store.selectCard('card-1');
    store.markExecuted('card-1');

    expect(useActionDeckStore.getState().lastExecutedCardId).toBe('card-1');
    expect(useActionDeckStore.getState().selectedCardId).toBeNull();
  });

  it('filters affordable cards correctly', () => {
    const balance = { signal: 20, memory_shard: 0 };
    const affordable = filterAffordableCards(mockCards, balance);

    expect(affordable).toHaveLength(1);
    expect(affordable[0].id).toBe('card-1');
  });

  it('respects server enabled flag in filterAffordableCards', () => {
    const disabledCards: ActionCard[] = [
      {
        ...mockCards[0],
        enabled: false,
      },
    ];
    const balance = { signal: 100, memory_shard: 100 };
    const affordable = filterAffordableCards(disabledCards, balance);

    expect(affordable).toHaveLength(0);
  });
});
</file>

<file path="frontend/src/stores/actionDeckStore.ts">
/**
 * Unknown World - Action Deck ìƒíƒœ ê´€ë¦¬ (Zustand) (U-009[Mvp]).
 *
 * Action Deckì˜ ì¹´ë“œ ëª©ë¡, ì„ íƒ ìƒíƒœ, ì”ì•¡ ê¸°ë°˜ í•„í„°ë§ì„ ê´€ë¦¬í•©ë‹ˆë‹¤.
 *
 * ì„¤ê³„ ì›ì¹™:
 *   - RULE-005: ì”ì•¡ ë¶€ì¡± ì‹œ ì‹¤í–‰ ë¶ˆê°€ í‘œì‹œ + ëŒ€ì•ˆ ì œê³µ
 *   - RULE-008: ì¹´ë“œ í´ë¦­ â†’ TurnInput ì—°ê²°
 *
 * @module stores/actionDeckStore
 */

import { create } from 'zustand';
import type { ActionCard } from '../schemas/turn';

// =============================================================================
// ìƒíƒœ íƒ€ì… ì •ì˜
// =============================================================================

/** Action Deck ìƒíƒœ */
export interface ActionDeckState {
  /** í˜„ì¬ ì¹´ë“œ ëª©ë¡ (ì„œë²„ì—ì„œ ë°›ì€ ì›ë³¸) */
  cards: ActionCard[];
  /** ì„ íƒëœ ì¹´ë“œ ID (í´ë¦­ í›„ ì‹¤í–‰ ì „ê¹Œì§€) */
  selectedCardId: string | null;
  /** ë§ˆì§€ë§‰ìœ¼ë¡œ ì‹¤í–‰ëœ ì¹´ë“œ ID */
  lastExecutedCardId: string | null;
}

/** Action Deck ì•¡ì…˜ */
export interface ActionDeckActions {
  /** ì¹´ë“œ ëª©ë¡ ì„¤ì • (TurnOutput ìˆ˜ì‹  ì‹œ) */
  setCards: (cards: ActionCard[]) => void;
  /** ì¹´ë“œ ì„ íƒ */
  selectCard: (cardId: string | null) => void;
  /** ì¹´ë“œ ì‹¤í–‰ ì™„ë£Œ ê¸°ë¡ */
  markExecuted: (cardId: string) => void;
  /** ìƒíƒœ ì´ˆê¸°í™” */
  reset: () => void;
}

export type ActionDeckStore = ActionDeckState & ActionDeckActions;

// =============================================================================
// ì´ˆê¸° ìƒíƒœ
// =============================================================================

function createInitialState(): ActionDeckState {
  return {
    cards: [],
    selectedCardId: null,
    lastExecutedCardId: null,
  };
}

// =============================================================================
// Zustand Store
// =============================================================================

/**
 * Action Deck ìƒíƒœ ìŠ¤í† ì–´.
 *
 * @example
 * ```tsx
 * const { cards, setCards, selectCard } = useActionDeckStore();
 *
 * // TurnOutput ìˆ˜ì‹  ì‹œ
 * setCards(turnOutput.ui.action_deck.cards);
 *
 * // ì¹´ë“œ í´ë¦­ ì‹œ
 * selectCard(card.id);
 * ```
 */
export const useActionDeckStore = create<ActionDeckStore>((set) => ({
  // ì´ˆê¸° ìƒíƒœ
  ...createInitialState(),

  // ì•¡ì…˜
  setCards: (cards) => {
    set({
      cards,
      selectedCardId: null, // ìƒˆ ì¹´ë“œ ëª©ë¡ ìˆ˜ì‹  ì‹œ ì„ íƒ ì´ˆê¸°í™”
    });
  },

  selectCard: (cardId) => {
    set({ selectedCardId: cardId });
  },

  markExecuted: (cardId) => {
    set({
      lastExecutedCardId: cardId,
      selectedCardId: null,
    });
  },

  reset: () => {
    set(createInitialState());
  },
}));

// =============================================================================
// ì…€ë ‰í„° (ì„±ëŠ¥ ìµœì í™”ìš©)
// =============================================================================

/** ì¹´ë“œ ëª©ë¡ ì…€ë ‰í„° */
export const selectCards = (state: ActionDeckStore) => state.cards;

/** ì„ íƒëœ ì¹´ë“œ ID ì…€ë ‰í„° */
export const selectSelectedCardId = (state: ActionDeckStore) => state.selectedCardId;

/** ì„ íƒëœ ì¹´ë“œ ê°ì²´ ì…€ë ‰í„° */
export const selectSelectedCard = (state: ActionDeckStore) =>
  state.cards.find((c) => c.id === state.selectedCardId) ?? null;

/** ë§ˆì§€ë§‰ ì‹¤í–‰ ì¹´ë“œ ID ì…€ë ‰í„° */
export const selectLastExecutedCardId = (state: ActionDeckStore) => state.lastExecutedCardId;

// =============================================================================
// ìœ í‹¸ë¦¬í‹° í•¨ìˆ˜
// =============================================================================

/**
 * ì”ì•¡ ê¸°ë°˜ìœ¼ë¡œ ì‹¤í–‰ ê°€ëŠ¥í•œ ì¹´ë“œë§Œ í•„í„°ë§í•©ë‹ˆë‹¤.
 * (ì»´í¬ë„ŒíŠ¸ì—ì„œ ì‚¬ìš©í•˜ê±°ë‚˜, ì„œë²„ ì‘ë‹µì´ enabledë¥¼ ì œê³µí•˜ì§€ ì•Šì„ ë•Œ í´ë°±ìœ¼ë¡œ ì‚¬ìš©)
 *
 * @param cards - ì›ë³¸ ì¹´ë“œ ëª©ë¡
 * @param balance - í˜„ì¬ ì”ì•¡
 * @returns ì‹¤í–‰ ê°€ëŠ¥í•œ ì¹´ë“œ ëª©ë¡
 */
export function filterAffordableCards(
  cards: ActionCard[],
  balance: { signal: number; memory_shard: number },
): ActionCard[] {
  return cards.filter((card) => {
    // ì„œë²„ì—ì„œ ì´ë¯¸ enabled=falseë¡œ íŒë‹¨í–ˆìœ¼ë©´ ì œì™¸
    if (!card.enabled) return false;

    // ë¹„ìš© ì¶”ì •ì¹˜ê°€ ìˆìœ¼ë©´ ìµœëŒ€ ë¹„ìš©ìœ¼ë¡œ íŒë‹¨
    const cost = card.cost_estimate?.max ?? card.cost;
    return balance.signal >= cost.signal && balance.memory_shard >= cost.memory_shard;
  });
}

/**
 * ëŒ€ì•ˆ ì¹´ë“œ(is_alternative=true)ë§Œ í•„í„°ë§í•©ë‹ˆë‹¤.
 *
 * @param cards - ì›ë³¸ ì¹´ë“œ ëª©ë¡
 * @returns ëŒ€ì•ˆ ì¹´ë“œ ëª©ë¡
 */
export function filterAlternativeCards(cards: ActionCard[]): ActionCard[] {
  return cards.filter((card) => card.is_alternative);
}

/**
 * ì¼ë°˜ ì¹´ë“œ(is_alternative=false)ë§Œ í•„í„°ë§í•©ë‹ˆë‹¤.
 *
 * @param cards - ì›ë³¸ ì¹´ë“œ ëª©ë¡
 * @returns ì¼ë°˜ ì¹´ë“œ ëª©ë¡
 */
export function filterRegularCards(cards: ActionCard[]): ActionCard[] {
  return cards.filter((card) => !card.is_alternative);
}
</file>

<file path="frontend/src/stores/economyStore.test.ts">
import { describe, it, expect, beforeEach } from 'vitest';
import {
  useEconomyStore,
  LEDGER_MAX_ENTRIES,
  canAffordCost,
  canAffordEstimate,
} from './economyStore';
import type { CurrencyAmount, CostEstimate } from '../schemas/turn';

describe('economyStore', () => {
  beforeEach(() => {
    useEconomyStore.getState().reset();
  });

  it('ì´ˆê¸° ìƒíƒœê°€ ì˜¬ë°”ë¥´ê²Œ ì„¤ì •ë˜ì–´ì•¼ í•œë‹¤', () => {
    const state = useEconomyStore.getState();
    expect(state.ledger).toEqual([]);
    expect(state.costEstimate).toBeNull();
    expect(state.lastCost).toBeNull();
    expect(state.isBalanceLow).toBe(false);
    expect(state.lowBalanceThreshold).toBe(10);
  });

  it('addLedgerEntryê°€ ì—”íŠ¸ë¦¬ë¥¼ ì¶”ê°€í•˜ê³  lastCostë¥¼ ì—…ë°ì´íŠ¸í•´ì•¼ í•œë‹¤', () => {
    const entry = {
      turnId: 1,
      reason: 'explore',
      cost: { signal: 5, memory_shard: 0 },
      balanceAfter: { signal: 95, memory_shard: 10 },
      modelLabel: 'FAST' as const,
    };

    useEconomyStore.getState().addLedgerEntry(entry);

    const state = useEconomyStore.getState();
    expect(state.ledger.length).toBe(1);
    expect(state.ledger[0].turnId).toBe(1);
    expect(state.ledger[0].timestamp).toBeDefined();
    expect(state.lastCost).toEqual({
      cost: entry.cost,
      balanceAfter: entry.balanceAfter,
      turnId: entry.turnId,
      modelLabel: entry.modelLabel,
    });
  });

  it(`LedgerëŠ” ìµœëŒ€ ${LEDGER_MAX_ENTRIES}ê°œê¹Œì§€ë§Œ ë³´ê´€í•´ì•¼ í•œë‹¤`, () => {
    const store = useEconomyStore.getState();

    // 25ê°œ ì—”íŠ¸ë¦¬ ì¶”ê°€
    for (let i = 1; i <= 25; i++) {
      store.addLedgerEntry({
        turnId: i,
        reason: `test-${i}`,
        cost: { signal: 1, memory_shard: 0 },
        balanceAfter: { signal: 100 - i, memory_shard: 0 },
      });
    }

    const state = useEconomyStore.getState();
    expect(state.ledger.length).toBe(LEDGER_MAX_ENTRIES);
    // ìµœì‹ ìˆœ(ë‚´ë¦¼ì°¨ìˆœ) ì •ë ¬ í™•ì¸
    expect(state.ledger[0].turnId).toBe(25);
    expect(state.ledger[LEDGER_MAX_ENTRIES - 1].turnId).toBe(25 - LEDGER_MAX_ENTRIES + 1);
  });

  it('setCostEstimateFromCardê°€ ì˜ˆìƒ ë¹„ìš©ì„ ì˜¬ë°”ë¥´ê²Œ ì„¤ì •í•´ì•¼ í•œë‹¤', () => {
    const cost: CurrencyAmount = { signal: 5, memory_shard: 0 };
    const estimate: CostEstimate = {
      min: { signal: 3, memory_shard: 0 },
      max: { signal: 7, memory_shard: 0 },
    };

    // 1. cost_estimateê°€ ì œê³µëœ ê²½ìš°
    useEconomyStore.getState().setCostEstimateFromCard(cost, estimate, 'action-1', 'Test Label');
    let state = useEconomyStore.getState();
    expect(state.costEstimate).toEqual({
      min: estimate.min,
      max: estimate.max,
      actionId: 'action-1',
      label: 'Test Label',
    });

    // 2. cost_estimateê°€ nullì¸ ê²½ìš° (ê¸°ë³¸ cost ì‚¬ìš©)
    useEconomyStore.getState().setCostEstimateFromCard(cost, null, 'action-2');
    state = useEconomyStore.getState();
    expect(state.costEstimate).toEqual({
      min: cost,
      max: cost,
      actionId: 'action-2',
      label: undefined,
    });
  });

  it('updateBalanceLowStatusê°€ ì„ê³„ê°’ì— ë”°ë¼ ìƒíƒœë¥¼ ì—…ë°ì´íŠ¸í•´ì•¼ í•œë‹¤', () => {
    const store = useEconomyStore.getState();

    // ê¸°ë³¸ ì„ê³„ê°’ 10
    store.updateBalanceLowStatus({ signal: 15, memory_shard: 0 });
    expect(useEconomyStore.getState().isBalanceLow).toBe(false);

    store.updateBalanceLowStatus({ signal: 5, memory_shard: 0 });
    expect(useEconomyStore.getState().isBalanceLow).toBe(true);

    // ì„ê³„ê°’ ë³€ê²½ í…ŒìŠ¤íŠ¸
    store.setLowBalanceThreshold(20);
    store.updateBalanceLowStatus({ signal: 15, memory_shard: 0 });
    expect(useEconomyStore.getState().isBalanceLow).toBe(true);
  });

  describe('Utility: canAffordCost & canAffordEstimate', () => {
    const balance: CurrencyAmount = { signal: 10, memory_shard: 2 };

    it('canAffordCost: ì”ì•¡ì´ ì¶©ë¶„í•  ë•Œ', () => {
      const cost: CurrencyAmount = { signal: 5, memory_shard: 1 };
      const result = canAffordCost(balance, cost);
      expect(result.affordable).toBe(true);
      expect(result.shortfall).toEqual({ signal: 0, memory_shard: 0 });
    });

    it('canAffordCost: ì”ì•¡ì´ ë¶€ì¡±í•  ë•Œ (Signal)', () => {
      const cost: CurrencyAmount = { signal: 15, memory_shard: 1 };
      const result = canAffordCost(balance, cost);
      expect(result.affordable).toBe(false);
      expect(result.shortfall.signal).toBe(5);
    });

    it('canAffordCost: ì”ì•¡ì´ ë¶€ì¡±í•  ë•Œ (Shard)', () => {
      const cost: CurrencyAmount = { signal: 5, memory_shard: 5 };
      const result = canAffordCost(balance, cost);
      expect(result.affordable).toBe(false);
      expect(result.shortfall.memory_shard).toBe(3);
    });

    it('canAffordEstimate: ìµœëŒ€ ì˜ˆìƒ ë¹„ìš© ê¸°ì¤€ìœ¼ë¡œ ì²´í¬í•´ì•¼ í•œë‹¤', () => {
      const estimate = {
        min: { signal: 5, memory_shard: 0 },
        max: { signal: 15, memory_shard: 0 },
      };
      // Signal 10 < Max 15 ì´ë¯€ë¡œ ê°ë‹¹ ë¶ˆê°€
      const result = canAffordEstimate(balance, estimate);
      expect(result.affordable).toBe(false);
      expect(result.shortfall.signal).toBe(5);
    });
  });
});
</file>

<file path="frontend/src/stores/inventoryStore.test.ts">
import { describe, it, expect, beforeEach } from 'vitest';
import { useInventoryStore, parseInventoryAdded } from './inventoryStore';

describe('inventoryStore', () => {
  beforeEach(() => {
    useInventoryStore.getState().reset();
  });

  it('ì´ˆê¸° ìƒíƒœëŠ” ë¹„ì–´ ìˆì–´ì•¼ í•œë‹¤', () => {
    const state = useInventoryStore.getState();
    expect(state.items).toEqual([]);
    expect(state.draggingItemId).toBeNull();
    expect(state.selectedItemId).toBeNull();
  });

  it('addItems: ìƒˆ ì•„ì´í…œì„ ì¶”ê°€í•  ìˆ˜ ìˆì–´ì•¼ í•œë‹¤', () => {
    const { addItems } = useInventoryStore.getState();
    const newItem = { id: 'item1', name: 'Item 1', quantity: 1 };

    addItems([newItem]);

    const state = useInventoryStore.getState();
    expect(state.items).toHaveLength(1);
    expect(state.items[0]).toEqual(newItem);
  });

  it('addItems: ì¤‘ë³µëœ IDì˜ ì•„ì´í…œ ì¶”ê°€ ì‹œ ìˆ˜ëŸ‰ì´ ì¦ê°€í•´ì•¼ í•œë‹¤', () => {
    const { addItems } = useInventoryStore.getState();
    const item1 = { id: 'item1', name: 'Item 1', quantity: 1 };

    addItems([item1]);
    addItems([{ id: 'item1', name: 'Item 1', quantity: 2 }]);

    const state = useInventoryStore.getState();
    expect(state.items).toHaveLength(1);
    expect(state.items[0].quantity).toBe(3);
  });

  it('removeItems: ì•„ì´í…œì„ ì œê±°í•  ìˆ˜ ìˆì–´ì•¼ í•œë‹¤', () => {
    const { addItems, removeItems } = useInventoryStore.getState();
    addItems([
      { id: 'item1', name: 'Item 1', quantity: 1 },
      { id: 'item2', name: 'Item 2', quantity: 1 },
    ]);

    removeItems(['item1']);

    const state = useInventoryStore.getState();
    expect(state.items).toHaveLength(1);
    expect(state.items[0].id).toBe('item2');
  });

  it('removeItems: ì œê±°ëœ ì•„ì´í…œì´ ì„ íƒ/ë“œë˜ê·¸ ì¤‘ì´ë©´ ì´ˆê¸°í™”í•´ì•¼ í•œë‹¤', () => {
    const { addItems, removeItems, selectItem, startDrag } = useInventoryStore.getState();
    addItems([{ id: 'item1', name: 'Item 1', quantity: 1 }]);

    selectItem('item1');
    startDrag('item1');

    removeItems(['item1']);

    const state = useInventoryStore.getState();
    expect(state.selectedItemId).toBeNull();
    expect(state.draggingItemId).toBeNull();
  });

  it('startDrag/endDrag: ë“œë˜ê·¸ ìƒíƒœë¥¼ ê´€ë¦¬í•´ì•¼ í•œë‹¤', () => {
    const { startDrag, endDrag } = useInventoryStore.getState();

    startDrag('item1');
    expect(useInventoryStore.getState().draggingItemId).toBe('item1');

    endDrag();
    expect(useInventoryStore.getState().draggingItemId).toBeNull();
  });

  it('parseInventoryAdded: ë¬¸ìì—´ ID ëª©ë¡ì„ InventoryItem ë°°ì—´ë¡œ ë³€í™˜í•´ì•¼ í•œë‹¤', () => {
    const addedIds = ['item-a', 'item-b'];
    const parsed = parseInventoryAdded(addedIds);

    expect(parsed).toHaveLength(2);
    expect(parsed[0]).toEqual({ id: 'item-a', name: 'item-a', quantity: 1 });
    expect(parsed[1]).toEqual({ id: 'item-b', name: 'item-b', quantity: 1 });
  });
});
</file>

<file path="frontend/src/stores/inventoryStore.ts">
/**
 * Unknown World - Inventory ìƒíƒœ ê´€ë¦¬ (Zustand) (U-011[Mvp]).
 *
 * Inventoryì˜ ì•„ì´í…œ ëª©ë¡, ë“œë˜ê·¸ ìƒíƒœ, ì„ íƒ ìƒíƒœë¥¼ ê´€ë¦¬í•©ë‹ˆë‹¤.
 *
 * ì„¤ê³„ ì›ì¹™:
 *   - RULE-002: InventoryëŠ” ê²Œì„ UIë¡œ ìƒì‹œ ë…¸ì¶œ
 *   - U-006 ì˜ì¡´: WorldDelta.inventory_added / inventory_removed í•„ë“œ ì—°ë™
 *   - U-012 ì—°ê²°: ë“œë˜ê·¸ ë°ì´í„°ì— item_idë¥¼ ì‹¤ì–´ ë“œë¡­ íƒ€ê²Ÿ(í•«ìŠ¤íŒŸ)ì— ì „ë‹¬
 *
 * @module stores/inventoryStore
 */

import { create } from 'zustand';

// =============================================================================
// íƒ€ì… ì •ì˜
// =============================================================================

/**
 * ì¸ë²¤í† ë¦¬ ì•„ì´í…œ.
 * MVPì—ì„œëŠ” ìµœì†Œ í•„ë“œë§Œ ì •ì˜í•©ë‹ˆë‹¤.
 */
export interface InventoryItem {
  /** ì•„ì´í…œ ê³ ìœ  ID */
  id: string;
  /** ì•„ì´í…œ ì´ë¦„ (í‘œì‹œìš©) */
  name: string;
  /** ì•„ì´í…œ ì„¤ëª… (ì„ íƒ) */
  description?: string;
  /** ì•„ì´í…œ ì•„ì´ì½˜ URL ë˜ëŠ” ì´ëª¨ì§€ (ì„ íƒ) */
  icon?: string;
  /** ì•„ì´í…œ ìˆ˜ëŸ‰ (ê¸°ë³¸ê°’: 1) */
  quantity: number;
}

/** Inventory ìƒíƒœ */
export interface InventoryState {
  /** í˜„ì¬ ì•„ì´í…œ ëª©ë¡ */
  items: InventoryItem[];
  /** í˜„ì¬ ë“œë˜ê·¸ ì¤‘ì¸ ì•„ì´í…œ ID (nullì´ë©´ ë“œë˜ê·¸ ì¤‘ ì•„ë‹˜) */
  draggingItemId: string | null;
  /** ì„ íƒëœ ì•„ì´í…œ ID (í´ë¦­ ì„ íƒ, ë“œë˜ê·¸ì™€ ë³„ê°œ) */
  selectedItemId: string | null;
}

/** Inventory ì•¡ì…˜ */
export interface InventoryActions {
  /** ì•„ì´í…œ ëª©ë¡ ì„¤ì • (ì „ì²´ êµì²´) */
  setItems: (items: InventoryItem[]) => void;
  /** ì•„ì´í…œ ì¶”ê°€ (ì¤‘ë³µ IDë©´ ìˆ˜ëŸ‰ ì¦ê°€) */
  addItems: (items: InventoryItem[]) => void;
  /** ì•„ì´í…œ ì œê±° (ID ëª©ë¡) */
  removeItems: (itemIds: string[]) => void;
  /** ë“œë˜ê·¸ ì‹œì‘ */
  startDrag: (itemId: string) => void;
  /** ë“œë˜ê·¸ ì¢…ë£Œ */
  endDrag: () => void;
  /** ì•„ì´í…œ ì„ íƒ */
  selectItem: (itemId: string | null) => void;
  /** ìƒíƒœ ì´ˆê¸°í™” */
  reset: () => void;
}

export type InventoryStore = InventoryState & InventoryActions;

// =============================================================================
// ì´ˆê¸° ìƒíƒœ
// =============================================================================

function createInitialState(): InventoryState {
  return {
    items: [],
    draggingItemId: null,
    selectedItemId: null,
  };
}

// =============================================================================
// Zustand Store
// =============================================================================

/**
 * Inventory ìƒíƒœ ìŠ¤í† ì–´.
 *
 * @example
 * ```tsx
 * const { items, addItems, removeItems, startDrag, endDrag } = useInventoryStore();
 *
 * // TurnOutput.world.inventory_added ìˆ˜ì‹  ì‹œ
 * addItems(inventoryAddedItems);
 *
 * // TurnOutput.world.inventory_removed ìˆ˜ì‹  ì‹œ
 * removeItems(inventoryRemovedIds);
 *
 * // dnd-kit onDragStart
 * startDrag(itemId);
 *
 * // dnd-kit onDragEnd
 * endDrag();
 * ```
 */
export const useInventoryStore = create<InventoryStore>((set) => ({
  // ì´ˆê¸° ìƒíƒœ
  ...createInitialState(),

  // ì•¡ì…˜
  setItems: (items) => {
    set({
      items,
      draggingItemId: null,
      selectedItemId: null,
    });
  },

  addItems: (newItems) => {
    set((state) => {
      const itemsMap = new Map(state.items.map((item) => [item.id, item]));

      for (const newItem of newItems) {
        const existing = itemsMap.get(newItem.id);
        if (existing) {
          // ê¸°ì¡´ ì•„ì´í…œì´ë©´ ìˆ˜ëŸ‰ ì¦ê°€
          itemsMap.set(newItem.id, {
            ...existing,
            quantity: existing.quantity + newItem.quantity,
          });
        } else {
          // ìƒˆ ì•„ì´í…œ ì¶”ê°€
          itemsMap.set(newItem.id, newItem);
        }
      }

      return { items: Array.from(itemsMap.values()) };
    });
  },

  removeItems: (itemIds) => {
    set((state) => {
      const removeSet = new Set(itemIds);
      return {
        items: state.items.filter((item) => !removeSet.has(item.id)),
        // ì œê±°ëœ ì•„ì´í…œì´ ì„ íƒ/ë“œë˜ê·¸ ì¤‘ì´ì—ˆë‹¤ë©´ ì´ˆê¸°í™”
        selectedItemId: removeSet.has(state.selectedItemId ?? '') ? null : state.selectedItemId,
        draggingItemId: removeSet.has(state.draggingItemId ?? '') ? null : state.draggingItemId,
      };
    });
  },

  startDrag: (itemId) => {
    set({ draggingItemId: itemId });
  },

  endDrag: () => {
    set({ draggingItemId: null });
  },

  selectItem: (itemId) => {
    set({ selectedItemId: itemId });
  },

  reset: () => {
    set(createInitialState());
  },
}));

// =============================================================================
// ì…€ë ‰í„° (ì„±ëŠ¥ ìµœì í™”ìš©)
// =============================================================================

/** ì•„ì´í…œ ëª©ë¡ ì…€ë ‰í„° */
export const selectItems = (state: InventoryStore) => state.items;

/** ë“œë˜ê·¸ ì¤‘ì¸ ì•„ì´í…œ ID ì…€ë ‰í„° */
export const selectDraggingItemId = (state: InventoryStore) => state.draggingItemId;

/** ë“œë˜ê·¸ ì¤‘ì¸ ì•„ì´í…œ ê°ì²´ ì…€ë ‰í„° */
export const selectDraggingItem = (state: InventoryStore) =>
  state.items.find((item) => item.id === state.draggingItemId) ?? null;

/** ì„ íƒëœ ì•„ì´í…œ ID ì…€ë ‰í„° */
export const selectSelectedItemId = (state: InventoryStore) => state.selectedItemId;

/** ì„ íƒëœ ì•„ì´í…œ ê°ì²´ ì…€ë ‰í„° */
export const selectSelectedItem = (state: InventoryStore) =>
  state.items.find((item) => item.id === state.selectedItemId) ?? null;

/** ì•„ì´í…œ ê°œìˆ˜ ì…€ë ‰í„° */
export const selectItemCount = (state: InventoryStore) => state.items.length;

// =============================================================================
// ìœ í‹¸ë¦¬í‹° í•¨ìˆ˜
// =============================================================================

/**
 * ì„œë²„ ì‘ë‹µ(inventory_added ë¬¸ìì—´ ë°°ì—´)ì„ InventoryItem ë°°ì—´ë¡œ ë³€í™˜í•©ë‹ˆë‹¤.
 * MVPì—ì„œëŠ” ë¬¸ìì—´ IDë¥¼ ê¸°ë³¸ ì•„ì´í…œìœ¼ë¡œ ë³€í™˜í•©ë‹ˆë‹¤.
 *
 * @param addedIds - ì¶”ê°€ëœ ì•„ì´í…œ ID ëª©ë¡ (ì„œë²„ ì‘ë‹µ)
 * @returns InventoryItem ë°°ì—´
 */
export function parseInventoryAdded(addedIds: string[]): InventoryItem[] {
  return addedIds.map((id) => ({
    id,
    name: id, // MVP: IDë¥¼ ì´ë¦„ìœ¼ë¡œ ì‚¬ìš©
    quantity: 1,
  }));
}

/**
 * ì•„ì´í…œ IDë¡œ ì•„ì´í…œì„ ì°¾ìŠµë‹ˆë‹¤.
 *
 * @param items - ì•„ì´í…œ ëª©ë¡
 * @param itemId - ì°¾ì„ ì•„ì´í…œ ID
 * @returns ì•„ì´í…œ ë˜ëŠ” undefined
 */
export function findItemById(items: InventoryItem[], itemId: string): InventoryItem | undefined {
  return items.find((item) => item.id === itemId);
}
</file>

<file path="frontend/src/utils/box2d.test.ts">
import { describe, it, expect } from 'vitest';
import {
  box2dToPixel,
  pixelToBox2d,
  isValidBox2D,
  box2dArea,
  box2dCenter,
  NORMALIZED_MAX,
} from './box2d';
import type { Box2D } from '../schemas/turn';

describe('box2d utils', () => {
  const canvas = { width: 800, height: 600 };

  describe('box2dToPixel', () => {
    it('should correctly convert normalized coordinates to pixels', () => {
      const normalized: Box2D = { ymin: 100, xmin: 200, ymax: 500, xmax: 800 };
      const pixel = box2dToPixel(normalized, canvas);

      // top = 100 * (600 / 1000) = 60
      // left = 200 * (800 / 1000) = 160
      // bottom = 500 * (600 / 1000) = 300
      // right = 800 * (800 / 1000) = 640
      // width = 640 - 160 = 480
      // height = 300 - 60 = 240

      expect(pixel).toEqual({
        top: 60,
        left: 160,
        width: 480,
        height: 240,
      });
    });

    it('should handle full canvas size', () => {
      const normalized: Box2D = { ymin: 0, xmin: 0, ymax: 1000, xmax: 1000 };
      const pixel = box2dToPixel(normalized, canvas);

      expect(pixel).toEqual({
        top: 0,
        left: 0,
        width: 800,
        height: 600,
      });
    });
  });

  describe('pixelToBox2d', () => {
    it('should correctly convert pixels back to normalized coordinates', () => {
      const pixel = { top: 60, left: 160, width: 480, height: 240 };
      const normalized = pixelToBox2d(pixel, canvas);

      expect(normalized).toEqual({
        ymin: 100,
        xmin: 200,
        ymax: 500,
        xmax: 800,
      });
    });

    it('should round and clamp values', () => {
      const pixel = { top: -10, left: -20, width: 900, height: 700 };
      const normalized = pixelToBox2d(pixel, canvas);

      expect(normalized.ymin).toBe(0);
      expect(normalized.xmin).toBe(0);
      expect(normalized.ymax).toBe(NORMALIZED_MAX);
      expect(normalized.xmax).toBe(NORMALIZED_MAX);
    });
  });

  describe('isValidBox2D', () => {
    it('should return true for valid boxes', () => {
      expect(isValidBox2D({ ymin: 100, xmin: 100, ymax: 200, xmax: 200 })).toBe(true);
      expect(isValidBox2D({ ymin: 0, xmin: 0, ymax: 1000, xmax: 1000 })).toBe(true);
    });

    it('should return false for out of range values', () => {
      expect(isValidBox2D({ ymin: -1, xmin: 0, ymax: 100, xmax: 100 })).toBe(false);
      expect(isValidBox2D({ ymin: 0, xmin: 0, ymax: 1001, xmax: 100 })).toBe(false);
    });

    it('should return false for invalid order', () => {
      expect(isValidBox2D({ ymin: 500, xmin: 100, ymax: 400, xmax: 200 })).toBe(false);
      expect(isValidBox2D({ ymin: 100, xmin: 500, ymax: 200, xmax: 400 })).toBe(false);
    });
  });

  describe('box2dArea', () => {
    it('should calculate area correctly', () => {
      const box = { ymin: 100, xmin: 100, ymax: 200, xmax: 300 };
      expect(box2dArea(box)).toBe(20000); // (200-100) * (300-100) = 100 * 200
    });
  });

  describe('box2dCenter', () => {
    it('should calculate center correctly', () => {
      const box = { ymin: 100, xmin: 100, ymax: 300, xmax: 500 };
      expect(box2dCenter(box)).toEqual({ x: 300, y: 200 });
    });
  });
});
</file>

<file path="frontend/src/utils/box2d.ts">
/**
 * Unknown World - Box2D ì¢Œí‘œ ë³€í™˜ ìœ í‹¸ë¦¬í‹°
 *
 * RULE-009 ì¤€ìˆ˜: ì¢Œí‘œ ê·œì•½ (0~1000 ì •ê·œí™”, bbox=[ymin,xmin,ymax,xmax])
 * - ì„œë²„/ì„¸ì´ë¸Œì—ëŠ” í•­ìƒ box_2d(0~1000)ë¥¼ ìœ ì§€
 * - ë Œë”ì—ì„œë§Œ viewport í¬ê¸°(canvasW/H)ì— ë§ì¶° pxë¡œ ë³€í™˜
 *
 * @module utils/box2d
 */

import type { Box2D } from '../schemas/turn';

// =============================================================================
// ìƒìˆ˜ ì •ì˜
// =============================================================================

/**
 * ì •ê·œí™” ì¢Œí‘œê³„ ìµœëŒ“ê°’ (0~1000).
 * RULE-009: ì¢Œí‘œ ê·œì•½
 */
export const NORMALIZED_MAX = 1000;

// =============================================================================
// íƒ€ì… ì •ì˜
// =============================================================================

/**
 * í”½ì…€ ë‹¨ìœ„ ë°”ìš´ë”© ë°•ìŠ¤.
 * ë Œë”ë§ìš©ìœ¼ë¡œë§Œ ì‚¬ìš©ë©ë‹ˆë‹¤.
 */
export interface Box2DPixel {
  /** Y ìµœì†Œê°’ (ìƒë‹¨, í”½ì…€) */
  top: number;
  /** X ìµœì†Œê°’ (ì¢Œì¸¡, í”½ì…€) */
  left: number;
  /** ë„ˆë¹„ (í”½ì…€) */
  width: number;
  /** ë†’ì´ (í”½ì…€) */
  height: number;
}

/**
 * ìº”ë²„ìŠ¤ í¬ê¸° ì •ë³´.
 */
export interface CanvasSize {
  /** ìº”ë²„ìŠ¤ ë„ˆë¹„ (í”½ì…€) */
  width: number;
  /** ìº”ë²„ìŠ¤ ë†’ì´ (í”½ì…€) */
  height: number;
}

// =============================================================================
// ë³€í™˜ í•¨ìˆ˜
// =============================================================================

/**
 * ì •ê·œí™” ì¢Œí‘œ(0~1000)ë¥¼ í”½ì…€ ì¢Œí‘œë¡œ ë³€í™˜í•©ë‹ˆë‹¤.
 *
 * RULE-009: bbox ìˆœì„œëŠ” [ymin, xmin, ymax, xmax]
 *
 * @param box - ì •ê·œí™” ì¢Œí‘œ ë°”ìš´ë”© ë°•ìŠ¤
 * @param canvas - ìº”ë²„ìŠ¤ í¬ê¸°
 * @returns í”½ì…€ ë‹¨ìœ„ ë°”ìš´ë”© ë°•ìŠ¤
 *
 * @example
 * ```ts
 * const normalized: Box2D = { ymin: 100, xmin: 200, ymax: 500, xmax: 800 };
 * const canvas = { width: 800, height: 600 };
 * const pixel = box2dToPixel(normalized, canvas);
 * // pixel = { top: 60, left: 160, width: 480, height: 240 }
 * ```
 */
export function box2dToPixel(box: Box2D, canvas: CanvasSize): Box2DPixel {
  const scaleX = canvas.width / NORMALIZED_MAX;
  const scaleY = canvas.height / NORMALIZED_MAX;

  const top = box.ymin * scaleY;
  const left = box.xmin * scaleX;
  const bottom = box.ymax * scaleY;
  const right = box.xmax * scaleX;

  return {
    top,
    left,
    width: right - left,
    height: bottom - top,
  };
}

/**
 * í”½ì…€ ì¢Œí‘œë¥¼ ì •ê·œí™” ì¢Œí‘œ(0~1000)ë¡œ ë³€í™˜í•©ë‹ˆë‹¤.
 *
 * ì—­ë³€í™˜ì´ í•„ìš”í•œ ê²½ìš° ì‚¬ìš©í•©ë‹ˆë‹¤ (ì˜ˆ: í´ë¦­ ìœ„ì¹˜ â†’ ì •ê·œí™” ì¢Œí‘œ).
 *
 * @param pixel - í”½ì…€ ë‹¨ìœ„ ë°”ìš´ë”© ë°•ìŠ¤
 * @param canvas - ìº”ë²„ìŠ¤ í¬ê¸°
 * @returns ì •ê·œí™” ì¢Œí‘œ ë°”ìš´ë”© ë°•ìŠ¤
 */
export function pixelToBox2d(pixel: Box2DPixel, canvas: CanvasSize): Box2D {
  const scaleX = NORMALIZED_MAX / canvas.width;
  const scaleY = NORMALIZED_MAX / canvas.height;

  const ymin = Math.round(pixel.top * scaleY);
  const xmin = Math.round(pixel.left * scaleX);
  const ymax = Math.round((pixel.top + pixel.height) * scaleY);
  const xmax = Math.round((pixel.left + pixel.width) * scaleX);

  // RULE-009: 0~1000 ë²”ìœ„ ë³´ì¥
  return {
    ymin: Math.max(0, Math.min(NORMALIZED_MAX, ymin)),
    xmin: Math.max(0, Math.min(NORMALIZED_MAX, xmin)),
    ymax: Math.max(0, Math.min(NORMALIZED_MAX, ymax)),
    xmax: Math.max(0, Math.min(NORMALIZED_MAX, xmax)),
  };
}

/**
 * Box2Dê°€ ìœ íš¨í•œì§€ ê²€ì¦í•©ë‹ˆë‹¤.
 *
 * @param box - ê²€ì¦í•  ë°”ìš´ë”© ë°•ìŠ¤
 * @returns ìœ íš¨ ì—¬ë¶€
 */
export function isValidBox2D(box: Box2D): boolean {
  // 0~1000 ë²”ìœ„ ì²´í¬
  if (
    box.ymin < 0 ||
    box.ymin > NORMALIZED_MAX ||
    box.xmin < 0 ||
    box.xmin > NORMALIZED_MAX ||
    box.ymax < 0 ||
    box.ymax > NORMALIZED_MAX ||
    box.xmax < 0 ||
    box.xmax > NORMALIZED_MAX
  ) {
    return false;
  }

  // ymin < ymax, xmin < xmax ì²´í¬
  if (box.ymin >= box.ymax || box.xmin >= box.xmax) {
    return false;
  }

  return true;
}

/**
 * Box2Dì˜ ë©´ì ì„ ê³„ì‚°í•©ë‹ˆë‹¤ (ì •ê·œí™” ì¢Œí‘œ ê¸°ì¤€).
 *
 * @param box - ë°”ìš´ë”© ë°•ìŠ¤
 * @returns ë©´ì  (0~1000000)
 */
export function box2dArea(box: Box2D): number {
  return (box.ymax - box.ymin) * (box.xmax - box.xmin);
}

/**
 * Box2Dì˜ ì¤‘ì‹¬ì ì„ ê³„ì‚°í•©ë‹ˆë‹¤ (ì •ê·œí™” ì¢Œí‘œ ê¸°ì¤€).
 *
 * @param box - ë°”ìš´ë”© ë°•ìŠ¤
 * @returns ì¤‘ì‹¬ì  ì¢Œí‘œ {x, y}
 */
export function box2dCenter(box: Box2D): { x: number; y: number } {
  return {
    x: (box.xmin + box.xmax) / 2,
    y: (box.ymin + box.ymax) / 2,
  };
}
</file>

<file path="request.json">
{"language": "ko-KR", "text": "ëª¨í—˜ì„ ì‹œì‘í•œë‹¤", "client": {"viewport_w": 1920, "viewport_h": 1080, "theme": "dark"}, "economy_snapshot": {"signal": 5, "memory_shard": 0}}
</file>

<file path="backend/prompts/image/scene_prompt.en.md">
<prompt_meta>
  <prompt_id>scene_image_generation</prompt_id>
  <language>en-US</language>
  <version>0.2.0</version>
  <last_updated>2026-01-28</last_updated>
  <policy_preset>default</policy_preset>
</prompt_meta>

<prompt_body>
## Purpose

Prompt template for generating in-game scene images.
Creates visual representations that match the text narrative in a consistent style.

## Inputs

- narrative: Current turn's narrative text
- scene_description: Scene description (optional)
- style_hints: Style hints (optional)
- previous_scene_context: Previous scene context (for consistency)

## Output Contract (Summary)

- Image generation prompts are written in **English** (model optimization).
- Always include base style keywords for consistency.
- Minimize negative prompts; describe the desired scene positively.

---

## System Instructions

You are the image prompt generator for "Unknown World" game.
Based on the given narrative and scene description, create prompts for the Gemini image generation model.

### Base Style Guidelines

1. **Art Style**: Dark fantasy, mystery, roguelike atmosphere
2. **Color Palette**: Dark and muted tones, neon accents (harmonizing with CRT theme)
3. **Lighting**: Dramatic contrast, rim lighting, atmospheric illumination
4. **Composition**: Cinematic, prefer wide or medium shots

### Prompt Structure

```
[Subject/Scene Description], [Art Style], [Lighting/Mood], [Color Tones], [Camera/Composition], [Quality Keywords]
```

### Quality Keywords (Always Include)

- highly detailed
- cinematic lighting
- atmospheric
- dark fantasy aesthetic
- 4k quality

### Prohibited Elements

- Avoid photorealistic style (difficult to maintain consistency)
- No violent/sexual/discriminatory imagery
- Avoid text/letters in images (readability issues)

---

## Example Prompts

### Example 1: Mysterious Forest Entrance

**Input Narrative**: "The old door creaks open. Cold air rushes out from within."

**Generated Prompt**:
```
An ancient wooden door creaking open in a misty forest, cold air flowing out, dark fantasy style, dramatic rim lighting, deep shadows, muted colors with cyan accents, wide shot, atmospheric fog, highly detailed, cinematic composition, 4k quality
```

### Example 2: Interior of a Ruined Castle

**Input Narrative**: "The throne of the crumbling castle gleams under the moonlight."

**Generated Prompt**:
```
A crumbling throne in a ruined castle bathed in moonlight, broken pillars and debris, dark fantasy aesthetic, silver and blue tones, dramatic chiaroscuro lighting, medium shot from below, dust particles in light beams, highly detailed, cinematic atmosphere, 4k quality
```

---

## Important Constraints

- **Prompts in English**: For image generation model optimization
- **Maintain Consistent Style**: Always include base style keywords
- **Safety Policy Compliance**: Exclude inappropriate content elements
</prompt_body>
</file>

<file path="backend/prompts/image/scene_prompt.ko.md">
<prompt_meta>
  <prompt_id>scene_image_generation</prompt_id>
  <language>ko-KR</language>
  <version>0.2.0</version>
  <last_updated>2026-01-28</last_updated>
  <policy_preset>default</policy_preset>
</prompt_meta>

<prompt_body>
## ëª©ì 

ê²Œì„ ë‚´ ì¥ë©´(Scene) ì´ë¯¸ì§€ë¥¼ ìƒì„±í•˜ê¸° ìœ„í•œ í”„ë¡¬í”„íŠ¸ í…œí”Œë¦¿ì…ë‹ˆë‹¤.
í…ìŠ¤íŠ¸ ë‚´ëŸ¬í‹°ë¸Œì— ë§ëŠ” ì‹œê°ì  í‘œí˜„ì„ ì¼ê´€ëœ ìŠ¤íƒ€ì¼ë¡œ ìƒì„±í•©ë‹ˆë‹¤.

## ì…ë ¥

- narrative: í˜„ì¬ í„´ì˜ ë‚´ëŸ¬í‹°ë¸Œ í…ìŠ¤íŠ¸
- scene_description: ì¥ë©´ ì„¤ëª… (ì„ íƒ)
- style_hints: ìŠ¤íƒ€ì¼ íŒíŠ¸ (ì„ íƒ)
- previous_scene_context: ì´ì „ ì¥ë©´ ë§¥ë½ (ì¼ê´€ì„± ìœ ì§€ìš©)

## ì¶œë ¥ ê³„ì•½ (ìš”ì•½)

- ì´ë¯¸ì§€ ìƒì„± í”„ë¡¬í”„íŠ¸ëŠ” **ì˜ì–´**ë¡œ ì‘ì„±ë©ë‹ˆë‹¤ (ëª¨ë¸ ìµœì í™”).
- ìŠ¤íƒ€ì¼ ì¼ê´€ì„±ì„ ìœ„í•´ ê¸°ë³¸ ìŠ¤íƒ€ì¼ í‚¤ì›Œë“œë¥¼ í•­ìƒ í¬í•¨í•©ë‹ˆë‹¤.
- ë¶€ì • í”„ë¡¬í”„íŠ¸ëŠ” ìµœì†Œí™”í•˜ê³ , ì›í•˜ëŠ” ì¥ë©´ì„ ê¸ì •ì ìœ¼ë¡œ ì„œìˆ í•©ë‹ˆë‹¤.

---

## ì‹œìŠ¤í…œ ì§€ì‹œ

ë‹¹ì‹ ì€ "Unknown World" ê²Œì„ì˜ ì´ë¯¸ì§€ í”„ë¡¬í”„íŠ¸ ìƒì„±ê¸°ì…ë‹ˆë‹¤.
ì£¼ì–´ì§„ ë‚´ëŸ¬í‹°ë¸Œì™€ ì¥ë©´ ì„¤ëª…ì„ ë°”íƒ•ìœ¼ë¡œ Gemini ì´ë¯¸ì§€ ìƒì„± ëª¨ë¸ì— ì „ë‹¬í•  í”„ë¡¬í”„íŠ¸ë¥¼ ì‘ì„±í•©ë‹ˆë‹¤.

### ê¸°ë³¸ ìŠ¤íƒ€ì¼ ê°€ì´ë“œë¼ì¸

1. **ì•„íŠ¸ ìŠ¤íƒ€ì¼**: ë‹¤í¬ íŒíƒ€ì§€, ë¯¸ìŠ¤í„°ë¦¬, ë¡œê·¸ë¼ì´í¬ ë¶„ìœ„ê¸°
2. **ìƒ‰ìƒ íŒ”ë ˆíŠ¸**: ì–´ë‘¡ê³  ì°¨ë¶„í•œ í†¤, ë„¤ì˜¨ ì•…ì„¼íŠ¸ (CRT í…Œë§ˆì™€ ì¡°í™”)
3. **ì¡°ëª…**: ê·¹ì ì¸ ëª…ì•” ëŒ€ë¹„, ë¦¼ ë¼ì´íŠ¸, ë¶„ìœ„ê¸° ìˆëŠ” ì¡°ëª…
4. **êµ¬ë„**: ì‹œë„¤ë§ˆí‹±, ì™€ì´ë“œ ìƒ· ë˜ëŠ” ì¤‘ê°„ ìƒ· ì„ í˜¸

### í”„ë¡¬í”„íŠ¸ êµ¬ì¡°

```
[ì£¼ì œ/ì¥ë©´ ì„¤ëª…], [ì•„íŠ¸ ìŠ¤íƒ€ì¼], [ì¡°ëª…/ë¶„ìœ„ê¸°], [ìƒ‰ìƒ í†¤], [ì¹´ë©”ë¼/êµ¬ë„], [í’ˆì§ˆ í‚¤ì›Œë“œ]
```

### í’ˆì§ˆ í‚¤ì›Œë“œ (ê¸°ë³¸ í¬í•¨)

- highly detailed
- cinematic lighting
- atmospheric
- dark fantasy aesthetic
- 4k quality

### ê¸ˆì§€ ì‚¬í•­

- ì‹¤ì‚¬ ìŠ¤íƒ€ì¼ (photorealistic) ì§€ì–‘ (ì¼ê´€ì„± ìœ ì§€ ì–´ë ¤ì›€)
- í­ë ¥ì /ì„±ì /ì°¨ë³„ì  ì´ë¯¸ì§€ ìš”ì†Œ ê¸ˆì§€
- í…ìŠ¤íŠ¸/ê¸€ì í¬í•¨ ì§€ì–‘ (ê°€ë…ì„± ë¬¸ì œ)

---

## ì˜ˆì‹œ í”„ë¡¬í”„íŠ¸

### ì˜ˆì‹œ 1: ì‹ ë¹„ë¡œìš´ ìˆ² ì…êµ¬

**ì…ë ¥ ë‚´ëŸ¬í‹°ë¸Œ**: "ë‚¡ì€ ë¬¸ì´ ì‚ê±±ê±°ë¦¬ë©° ì—´ë¦½ë‹ˆë‹¤. ì•ˆìª½ì—ì„œ ì°¨ê°€ìš´ ê³µê¸°ê°€ ë°€ë ¤ì˜µë‹ˆë‹¤."

**ìƒì„±ëœ í”„ë¡¬í”„íŠ¸**:
```
An ancient wooden door creaking open in a misty forest, cold air flowing out, dark fantasy style, dramatic rim lighting, deep shadows, muted colors with cyan accents, wide shot, atmospheric fog, highly detailed, cinematic composition, 4k quality
```

### ì˜ˆì‹œ 2: íí—ˆê°€ ëœ ì„±ì˜ ë‚´ë¶€

**ì…ë ¥ ë‚´ëŸ¬í‹°ë¸Œ**: "ë¬´ë„ˆì§„ ì„±ì˜ ì™•ì¢Œê°€ ë‹¬ë¹› ì•„ë˜ ë¹›ë‚˜ê³  ìˆìŠµë‹ˆë‹¤."

**ìƒì„±ëœ í”„ë¡¬í”„íŠ¸**:
```
A crumbling throne in a ruined castle bathed in moonlight, broken pillars and debris, dark fantasy aesthetic, silver and blue tones, dramatic chiaroscuro lighting, medium shot from below, dust particles in light beams, highly detailed, cinematic atmosphere, 4k quality
```

---

## ì¤‘ìš” ì œì•½

- **í”„ë¡¬í”„íŠ¸ëŠ” ì˜ì–´ë¡œ ì‘ì„±**: ì´ë¯¸ì§€ ìƒì„± ëª¨ë¸ ìµœì í™”ë¥¼ ìœ„í•´
- **ì¼ê´€ëœ ìŠ¤íƒ€ì¼ ìœ ì§€**: ê¸°ë³¸ ìŠ¤íƒ€ì¼ í‚¤ì›Œë“œë¥¼ í•­ìƒ í¬í•¨
- **ì•ˆì „ ì •ì±… ì¤€ìˆ˜**: ë¶€ì ì ˆí•œ ì½˜í…ì¸  ìƒì„± ìš”ì†Œ ë°°ì œ
</prompt_body>
</file>

<file path="backend/prompts/system/game_master.en.md">
<prompt_meta>
  <prompt_id>game_master_system</prompt_id>
  <language>en-US</language>
  <version>0.2.0</version>
  <last_updated>2026-01-28</last_updated>
  <policy_preset>default</policy_preset>
</prompt_meta>

<prompt_body>
## Purpose

Act as an agent-style Game Master to generate TurnOutput (JSON).
"Unknown World" is an infinite generative roguelike narrative web game.

## Input

- TurnInput: language, text, action_id, click, client, economy_snapshot
- WorldState: world rules, inventory, quests, relationships, history summary

## Output Contract (Summary)

- Output must satisfy the TurnOutput JSON Schema.
- language is fixed to "en-US" matching the input.
- All text (narrative, label, description, etc.) must be in English.

---

## System Instructions

You are the Game Master of "Unknown World". React to player actions, evolve the world, and generate engaging narratives.

### Core Principles

1. **Consistency**: Adhere to world rules and established settings.
2. **Creativity**: Create unpredictable yet logical developments.
3. **Responsiveness**: Provide meaningful consequences for player choices.
4. **Economy**: Calculate cost and balance_after accurately.

### Narrative Style

- 2-3 sentences of concise, immersive description
- Use present tense
- Include sensory details (sounds, smells, textures)
- Address the player as "you"

### Action Card Generation Rules

- Provide 3-6 choice cards
- Include cost, risk level, and hint for each card
- At least 1 low-cost alternative (is_alternative: true)
- Disable cards (enabled: false) when balance is insufficient

### Safety Policy

- Do not generate violent/sexual/discriminatory content
- On violation requests: safety.blocked=true, provide safe alternative narrative

---

## Critical Constraints

- **Output must be valid JSON.**
- **language field is fixed to "en-US".**
- **economy.cost and economy.balance_after are required.**
- **balance_after must be >= 0.**
</prompt_body>
</file>

<file path="backend/prompts/system/game_master.ko.md">
<prompt_meta>
  <prompt_id>game_master_system</prompt_id>
  <language>ko-KR</language>
  <version>0.2.0</version>
  <last_updated>2026-01-28</last_updated>
  <policy_preset>default</policy_preset>
</prompt_meta>

<prompt_body>
## ëª©ì 

ì—ì´ì „íŠ¸í˜• Game Masterë¡œì„œ TurnOutput(JSON)ì„ ìƒì„±í•©ë‹ˆë‹¤.
"Unknown World"ëŠ” ë¬´í•œ ìƒì„± ë¡œê·¸ë¼ì´í¬ ë‚´ëŸ¬í‹°ë¸Œ ì›¹ê²Œì„ì…ë‹ˆë‹¤.

## ì…ë ¥

- TurnInput: language, text, action_id, click, client, economy_snapshot
- WorldState: ì„¸ê³„ ê·œì¹™, ì¸ë²¤í† ë¦¬, í€˜ìŠ¤íŠ¸, ê´€ê³„, íˆìŠ¤í† ë¦¬ ìš”ì•½

## ì¶œë ¥ ê³„ì•½ (ìš”ì•½)

- ë°˜ë“œì‹œ JSON Schemaë¥¼ ë§Œì¡±í•˜ëŠ” TurnOutputë§Œ ì¶œë ¥í•©ë‹ˆë‹¤.
- languageëŠ” ì…ë ¥ê³¼ ë™ì¼í•˜ê²Œ "ko-KR"ë¡œ ê³ ì •í•©ë‹ˆë‹¤.
- ëª¨ë“  í…ìŠ¤íŠ¸(narrative, label, description ë“±)ëŠ” í•œêµ­ì–´ë¡œ ì‘ì„±í•©ë‹ˆë‹¤.

---

## ì‹œìŠ¤í…œ ì§€ì‹œ

ë‹¹ì‹ ì€ "Unknown World"ì˜ Game Masterì…ë‹ˆë‹¤. í”Œë ˆì´ì–´ì˜ í–‰ë™ì— ë°˜ì‘í•˜ì—¬ ì„¸ê³„ë¥¼ ë³€í™”ì‹œí‚¤ê³ , í¥ë¯¸ë¡œìš´ ë‚´ëŸ¬í‹°ë¸Œë¥¼ ìƒì„±í•©ë‹ˆë‹¤.

### í•µì‹¬ ì›ì¹™

1. **ì¼ê´€ì„±**: ì„¸ê³„ ê·œì¹™(rules)ê³¼ ê¸°ì¡´ ì„¤ì •ì„ ì¤€ìˆ˜í•©ë‹ˆë‹¤.
2. **ì°½ì˜ì„±**: ì˜ˆì¸¡ ë¶ˆê°€ëŠ¥í•˜ë˜ ë…¼ë¦¬ì ì¸ ì „ê°œë¥¼ ë§Œë“¤ì–´ëƒ…ë‹ˆë‹¤.
3. **ë°˜ì‘ì„±**: í”Œë ˆì´ì–´ì˜ ì„ íƒì— ì˜ë¯¸ ìˆëŠ” ê²°ê³¼ë¥¼ ì œê³µí•©ë‹ˆë‹¤.
4. **ê²½ì œì„±**: ë¹„ìš©(cost)ê³¼ ì”ì•¡(balance_after)ì„ ì •í™•íˆ ê³„ì‚°í•©ë‹ˆë‹¤.

### ë‚´ëŸ¬í‹°ë¸Œ ìŠ¤íƒ€ì¼

- 2~3ë¬¸ì¥ì˜ ê°„ê²°í•˜ê³  ëª°ì…ê° ìˆëŠ” ë¬˜ì‚¬
- í˜„ì¬ ì‹œì œ ì‚¬ìš©
- ê°ê°ì  ë””í…Œì¼ í¬í•¨ (ì†Œë¦¬, ëƒ„ìƒˆ, ì´‰ê° ë“±)
- í”Œë ˆì´ì–´ë¥¼ "ë‹¹ì‹ "ìœ¼ë¡œ ì§€ì¹­

### ì•¡ì…˜ ì¹´ë“œ ìƒì„± ê·œì¹™

- 3~6ì¥ì˜ ì„ íƒì§€ ì œê³µ
- ê° ì¹´ë“œì— ë¹„ìš©(cost), ìœ„í—˜ë„(risk), íŒíŠ¸(hint) í¬í•¨
- ìµœì†Œ 1ì¥ì€ ì €ë¹„ìš© ëŒ€ì•ˆ(is_alternative: true) í¬í•¨
- ì”ì•¡ ë¶€ì¡± ì‹œ í•´ë‹¹ ì¹´ë“œ ë¹„í™œì„±í™”(enabled: false)

### ì•ˆì „ ì •ì±…

- í­ë ¥ì /ì„±ì /ì°¨ë³„ì  ì½˜í…ì¸  ìƒì„± ê¸ˆì§€
- ìœ„ë°˜ ìš”ì²­ ì‹œ safety.blocked=true, ì•ˆì „í•œ ëŒ€ì²´ ë‚´ëŸ¬í‹°ë¸Œ ì œê³µ

---

## ì¤‘ìš” ì œì•½

- **ì¶œë ¥ì€ ë°˜ë“œì‹œ ìœ íš¨í•œ JSONì´ì–´ì•¼ í•©ë‹ˆë‹¤.**
- **language í•„ë“œëŠ” "ko-KR"ë¡œ ê³ ì •í•©ë‹ˆë‹¤.**
- **economy.costì™€ economy.balance_afterëŠ” í•„ìˆ˜ì…ë‹ˆë‹¤.**
- **ì”ì•¡(balance_after)ì€ 0 ì´ìƒì´ì–´ì•¼ í•©ë‹ˆë‹¤.**
</prompt_body>
</file>

<file path="backend/prompts/turn/turn_output_instructions.en.md">
<prompt_meta>
  <prompt_id>turn_output_instructions</prompt_id>
  <language>en-US</language>
  <version>0.2.0</version>
  <last_updated>2026-01-28</last_updated>
  <policy_preset>default</policy_preset>
</prompt_meta>

<prompt_body>
## Purpose

Specify the rules for each field in the TurnOutput JSON schema.

---

## Required Fields (Hard Gate)

### language
- Value: "en-US" (fixed to match input)
- No mixed language output

### narrative
- Type: string (required)
- Narrative text shown to the player
- 2-3 sentences, written in English
- Present tense, address as "you"

### economy
- Type: object (required)
- cost: Resources consumed this turn {signal: int, memory_shard: int}
- balance_after: Balance after consumption {signal: int, memory_shard: int}
- **Important**: balance_after.signal >= 0, balance_after.memory_shard >= 0

### safety
- Type: object (required)
- blocked: boolean (whether blocked by safety policy)
- message: string | null (message to display when blocked)

---

## Optional Fields

### ui
- action_deck.cards[]: Action card array (3-6 recommended)
  - id: Unique card ID
  - label: Display label (English)
  - cost: {signal, memory_shard}
  - risk: "low" | "medium" | "high"
  - enabled: boolean
  - is_alternative: boolean (low-cost alternative flag)
- objects[]: Clickable scene objects
  - box_2d: {ymin, xmin, ymax, xmax} (0-1000 normalized coordinates)

### world
- rules_changed[]: Changed world rules
- inventory_added[]: Added item IDs
- inventory_removed[]: Removed item IDs
- quests_updated[]: Updated quests
- memory_pins[]: Pin candidates

### render
- image_job: Image generation job (optional)
  - should_generate: boolean
  - prompt: Image prompt (English preferred)

### agent_console
- current_phase: Current phase
- badges[]: Validation badges
- repair_count: Number of repair attempts

---

## Coordinate Convention (RULE-009)

- All coordinates use 0-1000 normalized coordinate system
- bbox order: [ymin, xmin, ymax, xmax]
- Do not use pixel coordinates

---

## Example Output

```json
{
  "language": "en-US",
  "narrative": "The old door creaks open. Cold air rushes out from within.",
  "economy": {
    "cost": {"signal": 5, "memory_shard": 0},
    "balance_after": {"signal": 95, "memory_shard": 5}
  },
  "safety": {"blocked": false, "message": null},
  "ui": {
    "action_deck": {
      "cards": [
        {"id": "enter", "label": "Step inside", "cost": {"signal": 10, "memory_shard": 0}, "risk": "medium", "enabled": true, "is_alternative": false},
        {"id": "peek", "label": "Peek cautiously", "cost": {"signal": 3, "memory_shard": 0}, "risk": "low", "enabled": true, "is_alternative": true}
      ]
    },
    "objects": []
  },
  "world": {"rules_changed": [], "inventory_added": [], "inventory_removed": [], "quests_updated": [], "memory_pins": []},
  "render": {"image_job": null},
  "agent_console": {"current_phase": "commit", "badges": ["schema_ok", "economy_ok", "safety_ok"], "repair_count": 0}
}
```
</prompt_body>
</file>

<file path="backend/prompts/turn/turn_output_instructions.ko.md">
<prompt_meta>
  <prompt_id>turn_output_instructions</prompt_id>
  <language>ko-KR</language>
  <version>0.2.0</version>
  <last_updated>2026-01-28</last_updated>
  <policy_preset>default</policy_preset>
</prompt_meta>

<prompt_body>
## ëª©ì 

TurnOutput JSON ìŠ¤í‚¤ë§ˆì˜ ê° í•„ë“œ ì‘ì„± ê·œì¹™ì„ ëª…ì‹œí•©ë‹ˆë‹¤.

---

## í•„ìˆ˜ í•„ë“œ (Hard Gate)

### language
- ê°’: "ko-KR" (ì…ë ¥ê³¼ ë™ì¼í•˜ê²Œ ê³ ì •)
- í˜¼í•© ì¶œë ¥ ê¸ˆì§€

### narrative
- íƒ€ì…: string (í•„ìˆ˜)
- í”Œë ˆì´ì–´ì—ê²Œ ë³´ì—¬ì¤„ ë‚´ëŸ¬í‹°ë¸Œ í…ìŠ¤íŠ¸
- 2~3ë¬¸ì¥, í•œêµ­ì–´ë¡œ ì‘ì„±
- í˜„ì¬ ì‹œì œ, "ë‹¹ì‹ " ì§€ì¹­

### economy
- íƒ€ì…: object (í•„ìˆ˜)
- cost: ì´ë²ˆ í„´ì— ì†Œë¹„ëœ ë¹„ìš© {signal: int, memory_shard: int}
- balance_after: ì†Œë¹„ í›„ ì”ì•¡ {signal: int, memory_shard: int}
- **ì¤‘ìš”**: balance_after.signal >= 0, balance_after.memory_shard >= 0

### safety
- íƒ€ì…: object (í•„ìˆ˜)
- blocked: boolean (ì•ˆì „ ì •ì±… ì°¨ë‹¨ ì—¬ë¶€)
- message: string | null (ì°¨ë‹¨ ì‹œ í‘œì‹œí•  ë©”ì‹œì§€)

---

## ì„ íƒ í•„ë“œ

### ui
- action_deck.cards[]: ì•¡ì…˜ ì¹´ë“œ ë°°ì—´ (3~6ì¥ ê¶Œì¥)
  - id: ì¹´ë“œ ê³ ìœ  ID
  - label: í‘œì‹œ ë¼ë²¨ (í•œêµ­ì–´)
  - cost: {signal, memory_shard}
  - risk: "low" | "medium" | "high"
  - enabled: boolean
  - is_alternative: boolean (ì €ë¹„ìš© ëŒ€ì•ˆ ì—¬ë¶€)
- objects[]: í´ë¦­ ê°€ëŠ¥í•œ ì¥ë©´ ì˜¤ë¸Œì íŠ¸
  - box_2d: {ymin, xmin, ymax, xmax} (0~1000 ì •ê·œí™” ì¢Œí‘œ)

### world
- rules_changed[]: ë³€ê²½ëœ ì„¸ê³„ ê·œì¹™
- inventory_added[]: ì¶”ê°€ëœ ì•„ì´í…œ ID
- inventory_removed[]: ì œê±°ëœ ì•„ì´í…œ ID
- quests_updated[]: ì—…ë°ì´íŠ¸ëœ í€˜ìŠ¤íŠ¸
- memory_pins[]: ê³ ì • í›„ë³´

### render
- image_job: ì´ë¯¸ì§€ ìƒì„± ì‘ì—… (ì„ íƒ)
  - should_generate: boolean
  - prompt: ì´ë¯¸ì§€ í”„ë¡¬í”„íŠ¸ (ì˜ì–´ ê¶Œì¥)

### agent_console
- current_phase: í˜„ì¬ ë‹¨ê³„
- badges[]: ê²€ì¦ ë°°ì§€
- repair_count: ë³µêµ¬ ì‹œë„ íšŸìˆ˜

---

## ì¢Œí‘œ ê·œì•½ (RULE-009)

- ëª¨ë“  ì¢Œí‘œëŠ” 0~1000 ì •ê·œí™” ì¢Œí‘œê³„
- bbox ìˆœì„œ: [ymin, xmin, ymax, xmax]
- í”½ì…€ ì¢Œí‘œ ì‚¬ìš© ê¸ˆì§€

---

## ì˜ˆì‹œ ì¶œë ¥

```json
{
  "language": "ko-KR",
  "narrative": "ë‚¡ì€ ë¬¸ì´ ì‚ê±±ê±°ë¦¬ë©° ì—´ë¦½ë‹ˆë‹¤. ì•ˆìª½ì—ì„œ ì°¨ê°€ìš´ ê³µê¸°ê°€ ë°€ë ¤ì˜µë‹ˆë‹¤.",
  "economy": {
    "cost": {"signal": 5, "memory_shard": 0},
    "balance_after": {"signal": 95, "memory_shard": 5}
  },
  "safety": {"blocked": false, "message": null},
  "ui": {
    "action_deck": {
      "cards": [
        {"id": "enter", "label": "ì•ˆìœ¼ë¡œ ë“¤ì–´ê°„ë‹¤", "cost": {"signal": 10, "memory_shard": 0}, "risk": "medium", "enabled": true, "is_alternative": false},
        {"id": "peek", "label": "ì¡°ì‹¬ìŠ¤ëŸ½ê²Œ ì—¿ë³¸ë‹¤", "cost": {"signal": 3, "memory_shard": 0}, "risk": "low", "enabled": true, "is_alternative": true}
      ]
    },
    "objects": []
  },
  "world": {"rules_changed": [], "inventory_added": [], "inventory_removed": [], "quests_updated": [], "memory_pins": []},
  "render": {"image_job": null},
  "agent_console": {"current_phase": "commit", "badges": ["schema_ok", "economy_ok", "safety_ok"], "repair_count": 0}
}
```
</prompt_body>
</file>

<file path="backend/src/unknown_world/api/image.py">
"""Unknown World - ì´ë¯¸ì§€ ìƒì„± API ì—”ë“œí¬ì¸íŠ¸.

ì´ ëª¨ë“ˆì€ ì¥ë©´ ì´ë¯¸ì§€ë¥¼ ì¡°ê±´ë¶€ë¡œ ìƒì„±í•˜ëŠ” ì—”ë“œí¬ì¸íŠ¸ë¥¼ ì œê³µí•©ë‹ˆë‹¤.
í…ìŠ¤íŠ¸ í„´ì˜ TTFBë¥¼ ë¸”ë¡œí‚¹í•˜ì§€ ì•Šë„ë¡ ë¶„ë¦¬ëœ ê²½ë¡œë¡œ ë™ì‘í•©ë‹ˆë‹¤.

ì„¤ê³„ ì›ì¹™:
    - RULE-004: ì‹¤íŒ¨ ì‹œ ì•ˆì „í•œ í´ë°± (í…ìŠ¤íŠ¸-only ì§„í–‰ ê°€ëŠ¥)
    - RULE-008: í…ìŠ¤íŠ¸ ìš°ì„  + Lazy ì´ë¯¸ì§€ ì›ì¹™
    - RULE-010: ì´ë¯¸ì§€ ëª¨ë¸ ID ê³ ì • (gemini-3-pro-image-preview)
    - RULE-007: í”„ë¡¬í”„íŠ¸ ì›ë¬¸/ë¹„ë°€ì •ë³´ ë…¸ì¶œ ê¸ˆì§€

í˜ì–´ë§ ì§ˆë¬¸ ê²°ì •:
    - Q1: Option A (ë¡œì»¬ íŒŒì¼ë¡œ ì €ì¥ í›„ image_urlë¡œ ì„œë¹™)

ì°¸ì¡°:
    - vibe/unit-plans/U-019[Mvp].md
    - .cursor/rules/20-backend-orchestrator.mdc
"""

from __future__ import annotations

import logging

from fastapi import APIRouter, Depends, HTTPException
from fastapi.responses import FileResponse
from pydantic import BaseModel, ConfigDict, Field

from unknown_world.services.image_generation import (
    ImageGenerationRequest,
    ImageGenerationStatus,
    ImageGeneratorType,
    create_fallback_response,
    get_image_generator,
    validate_image_request,
)
from unknown_world.storage.paths import (
    DEFAULT_IMAGE_EXTENSION,
    build_image_url,
    get_generated_images_dir,
)

# =============================================================================
# ë¡œê±° ì„¤ì •
# =============================================================================

logger = logging.getLogger(__name__)

# =============================================================================
# ë¼ìš°í„° ì •ì˜
# =============================================================================

router = APIRouter(
    prefix="/api/image",
    tags=["Image Generation"],
)


# =============================================================================
# ì˜ì¡´ì„± ì£¼ì…
# =============================================================================


async def get_generator():
    """ì´ë¯¸ì§€ ìƒì„±ê¸° ì˜ì¡´ì„±."""
    return get_image_generator()


# =============================================================================
# ìš”ì²­/ì‘ë‹µ ìŠ¤í‚¤ë§ˆ (API ê³„ì¸µìš©)
# =============================================================================


class GenerateImageRequest(BaseModel):
    """ì´ë¯¸ì§€ ìƒì„± API ìš”ì²­.

    TurnOutput.render.image_jobê³¼ ì •í•©ë˜ë„ë¡ ì„¤ê³„í•©ë‹ˆë‹¤.

    Attributes:
        prompt: ì´ë¯¸ì§€ ìƒì„± í”„ë¡¬í”„íŠ¸ (í•„ìˆ˜)
        aspect_ratio: ê°€ë¡œì„¸ë¡œ ë¹„ìœ¨
        image_size: ì´ë¯¸ì§€ í¬ê¸°
        reference_image_ids: ì°¸ì¡° ì´ë¯¸ì§€ ID ëª©ë¡ (í¸ì§‘ìš©)
        session_id: ì„¸ì…˜ ID (íŒŒì¼ ê·¸ë£¹í™”ìš©)
        skip_on_failure: ì‹¤íŒ¨ ì‹œ ê±´ë„ˆë›°ê¸° (í…ìŠ¤íŠ¸-only ì§„í–‰)
    """

    model_config = ConfigDict(extra="forbid")

    prompt: str = Field(min_length=1, max_length=2000, description="ì´ë¯¸ì§€ ìƒì„± í”„ë¡¬í”„íŠ¸")
    aspect_ratio: str = Field(default="1:1", description="ê°€ë¡œì„¸ë¡œ ë¹„ìœ¨")
    image_size: str = Field(default="1024x1024", description="ì´ë¯¸ì§€ í¬ê¸°")
    reference_image_ids: list[str] = Field(default_factory=list, description="ì°¸ì¡° ì´ë¯¸ì§€ ID ëª©ë¡")
    session_id: str | None = Field(default=None, description="ì„¸ì…˜ ID")
    skip_on_failure: bool = Field(default=True, description="ì‹¤íŒ¨ ì‹œ ê±´ë„ˆë›°ê¸° (í…ìŠ¤íŠ¸-only ì§„í–‰)")


class GenerateImageResponse(BaseModel):
    """ì´ë¯¸ì§€ ìƒì„± API ì‘ë‹µ.

    Attributes:
        success: ì„±ê³µ ì—¬ë¶€
        status: ìƒì„± ìƒíƒœ
        image_id: ìƒì„±ëœ ì´ë¯¸ì§€ ID
        image_url: ìƒì„±ëœ ì´ë¯¸ì§€ URL
        message: ìƒíƒœ ë©”ì‹œì§€
        generation_time_ms: ìƒì„± ì†Œìš” ì‹œê°„
    """

    model_config = ConfigDict(extra="forbid")

    success: bool = Field(description="ì„±ê³µ ì—¬ë¶€")
    status: ImageGenerationStatus = Field(description="ìƒì„± ìƒíƒœ")
    image_id: str | None = Field(default=None, description="ìƒì„±ëœ ì´ë¯¸ì§€ ID")
    image_url: str | None = Field(default=None, description="ìƒì„±ëœ ì´ë¯¸ì§€ URL")
    message: str | None = Field(default=None, description="ìƒíƒœ ë©”ì‹œì§€")
    generation_time_ms: int = Field(default=0, description="ìƒì„± ì†Œìš” ì‹œê°„ (ms)")


class ImageStatusResponse(BaseModel):
    """ì´ë¯¸ì§€ ìƒíƒœ ì¡°íšŒ ì‘ë‹µ.

    Attributes:
        image_id: ì´ë¯¸ì§€ ID
        exists: ì´ë¯¸ì§€ ì¡´ì¬ ì—¬ë¶€
        image_url: ì´ë¯¸ì§€ URL (ì¡´ì¬í•˜ëŠ” ê²½ìš°)
    """

    model_config = ConfigDict(extra="forbid")

    image_id: str = Field(description="ì´ë¯¸ì§€ ID")
    exists: bool = Field(description="ì´ë¯¸ì§€ ì¡´ì¬ ì—¬ë¶€")
    image_url: str | None = Field(default=None, description="ì´ë¯¸ì§€ URL")


# =============================================================================
# ì—”ë“œí¬ì¸íŠ¸ ì •ì˜
# =============================================================================


@router.post(
    "/generate",
    response_model=GenerateImageResponse,
    summary="ì´ë¯¸ì§€ ìƒì„±",
    description="ì¥ë©´ ì´ë¯¸ì§€ë¥¼ ìƒì„±í•©ë‹ˆë‹¤. í…ìŠ¤íŠ¸ í„´ê³¼ ë³„ê°œë¡œ ë¹„ë™ê¸°ì ìœ¼ë¡œ í˜¸ì¶œë©ë‹ˆë‹¤.",
)
async def generate_image(
    request: GenerateImageRequest,
    generator: ImageGeneratorType = Depends(get_generator),
) -> GenerateImageResponse:
    """ì´ë¯¸ì§€ë¥¼ ìƒì„±í•©ë‹ˆë‹¤.

    ì´ ì—”ë“œí¬ì¸íŠ¸ëŠ” TurnOutputì˜ render.image_jobì—ì„œ should_generate=trueì¸ ê²½ìš°
    í”„ë¡ íŠ¸ì—”ë“œì—ì„œ ë³„ë„ë¡œ í˜¸ì¶œí•©ë‹ˆë‹¤.

    í…ìŠ¤íŠ¸ í„´ì˜ TTFBë¥¼ ë¸”ë¡œí‚¹í•˜ì§€ ì•ŠìŠµë‹ˆë‹¤ (RULE-008).

    Args:
        request: ì´ë¯¸ì§€ ìƒì„± ìš”ì²­
        generator: ì´ë¯¸ì§€ ìƒì„±ê¸° (ì˜ì¡´ì„± ì£¼ì…)

    Returns:
        GenerateImageResponse: ìƒì„± ê²°ê³¼
    """
    # ìš”ì²­ ê²€ì¦
    validation_error = validate_image_request(
        ImageGenerationRequest(
            prompt=request.prompt,
            aspect_ratio=request.aspect_ratio,
            image_size=request.image_size,
            reference_image_ids=request.reference_image_ids,
            session_id=request.session_id,
        )
    )

    if validation_error:
        logger.warning(
            "[ImageAPI] ìš”ì²­ ê²€ì¦ ì‹¤íŒ¨",
            extra={"error": validation_error},
        )

        if request.skip_on_failure:
            # ì‹¤íŒ¨ ì‹œì—ë„ í…ìŠ¤íŠ¸-onlyë¡œ ì§„í–‰ ê°€ëŠ¥í•˜ë„ë¡ í´ë°± (RULE-004)
            fallback = create_fallback_response(validation_error)
            return GenerateImageResponse(
                success=False,
                status=fallback.status,
                message=fallback.message,
            )
        else:
            raise HTTPException(status_code=400, detail=validation_error)

    # ì´ë¯¸ì§€ ìƒì„± ì‹¤í–‰
    try:
        result = await generator.generate(
            ImageGenerationRequest(
                prompt=request.prompt,
                aspect_ratio=request.aspect_ratio,
                image_size=request.image_size,
                reference_image_ids=request.reference_image_ids,
                session_id=request.session_id,
            )
        )

        success = result.status == ImageGenerationStatus.COMPLETED

        return GenerateImageResponse(
            success=success,
            status=result.status,
            image_id=result.image_id,
            image_url=result.image_url,
            message=result.message,
            generation_time_ms=result.generation_time_ms,
        )

    except Exception as e:
        error_type = type(e).__name__
        logger.error(
            "[ImageAPI] ì´ë¯¸ì§€ ìƒì„± ì¤‘ ì˜ˆì™¸ ë°œìƒ",
            extra={"error_type": error_type},
        )

        if request.skip_on_failure:
            # ì˜ˆì™¸ ë°œìƒ ì‹œì—ë„ ì•ˆì „í•œ í´ë°± (RULE-004)
            return GenerateImageResponse(
                success=False,
                status=ImageGenerationStatus.FAILED,
                message=f"ì´ë¯¸ì§€ ìƒì„± ì¤‘ ì˜¤ë¥˜ê°€ ë°œìƒí–ˆìŠµë‹ˆë‹¤: {error_type}",
            )
        else:
            raise HTTPException(
                status_code=500,
                detail=f"ì´ë¯¸ì§€ ìƒì„± ì‹¤íŒ¨: {error_type}",
            ) from e


@router.get(
    "/status/{image_id}",
    response_model=ImageStatusResponse,
    summary="ì´ë¯¸ì§€ ìƒíƒœ ì¡°íšŒ",
    description="ìƒì„±ëœ ì´ë¯¸ì§€ì˜ ì¡´ì¬ ì—¬ë¶€ì™€ URLì„ ì¡°íšŒí•©ë‹ˆë‹¤.",
)
async def get_image_status(
    image_id: str,
) -> ImageStatusResponse:
    """ì´ë¯¸ì§€ ìƒíƒœë¥¼ ì¡°íšŒí•©ë‹ˆë‹¤.

    Args:
        image_id: ì´ë¯¸ì§€ ID

    Returns:
        ImageStatusResponse: ì´ë¯¸ì§€ ìƒíƒœ
    """
    # íŒŒì¼ ì¡´ì¬ í™•ì¸ (RU-006-Q5: ì¤‘ì•™í™”ëœ ê²½ë¡œ í•¨ìˆ˜ ì‚¬ìš©)
    output_dir = get_generated_images_dir()
    filename = f"{image_id}.{DEFAULT_IMAGE_EXTENSION}"
    file_path = output_dir / filename
    exists = file_path.exists()

    return ImageStatusResponse(
        image_id=image_id,
        exists=exists,
        image_url=build_image_url(filename, category="generated") if exists else None,
    )


@router.get(
    "/file/{image_id}",
    summary="ì´ë¯¸ì§€ íŒŒì¼ ì¡°íšŒ",
    description="ìƒì„±ëœ ì´ë¯¸ì§€ íŒŒì¼ì„ ë°˜í™˜í•©ë‹ˆë‹¤.",
    response_class=FileResponse,
)
async def get_image_file(
    image_id: str,
) -> FileResponse:
    """ì´ë¯¸ì§€ íŒŒì¼ì„ ë°˜í™˜í•©ë‹ˆë‹¤.

    MVPì—ì„œëŠ” ë¡œì»¬ íŒŒì¼ì„ ì§ì ‘ ì„œë¹™í•©ë‹ˆë‹¤.
    MMPì—ì„œ GCS URL ë¦¬ë‹¤ì´ë ‰íŠ¸ë¡œ ë³€ê²½ ì˜ˆì •.

    Args:
        image_id: ì´ë¯¸ì§€ ID

    Returns:
        FileResponse: ì´ë¯¸ì§€ íŒŒì¼
    """
    # RU-006-Q5: ì¤‘ì•™í™”ëœ ê²½ë¡œ í•¨ìˆ˜ ì‚¬ìš©
    output_dir = get_generated_images_dir()
    filename = f"{image_id}.{DEFAULT_IMAGE_EXTENSION}"
    file_path = output_dir / filename

    if not file_path.exists():
        raise HTTPException(status_code=404, detail="ì´ë¯¸ì§€ë¥¼ ì°¾ì„ ìˆ˜ ì—†ìŠµë‹ˆë‹¤.")

    return FileResponse(
        path=str(file_path),
        media_type="image/png",
        filename=filename,
    )


@router.get(
    "/health",
    summary="ì´ë¯¸ì§€ ì„œë¹„ìŠ¤ í—¬ìŠ¤ì²´í¬",
    description="ì´ë¯¸ì§€ ìƒì„± ì„œë¹„ìŠ¤ì˜ ìƒíƒœë¥¼ í™•ì¸í•©ë‹ˆë‹¤.",
)
async def image_health(
    generator: ImageGeneratorType = Depends(get_generator),
) -> dict[str, str | bool]:
    """ì´ë¯¸ì§€ ì„œë¹„ìŠ¤ í—¬ìŠ¤ì²´í¬.

    Args:
        generator: ì´ë¯¸ì§€ ìƒì„±ê¸°

    Returns:
        í—¬ìŠ¤ ìƒíƒœ ì •ë³´
    """
    is_available = generator.is_available()
    mode = (
        "mock"
        if hasattr(generator, "_output_dir")
        and isinstance(generator, type(get_image_generator(force_mock=True)))
        else "real"
    )

    return {
        "status": "ok" if is_available else "degraded",
        "available": is_available,
        "mode": mode,
        "model": "gemini-3-pro-image-preview",
    }
</file>

<file path="backend/src/unknown_world/api/scanner.py">
"""Unknown World - Scanner(ì´ë¯¸ì§€ ì´í•´) API ì—”ë“œí¬ì¸íŠ¸.

ì´ ëª¨ë“ˆì€ ì‚¬ìš©ìê°€ ì—…ë¡œë“œí•œ ì´ë¯¸ì§€ë¥¼ ë¶„ì„í•˜ì—¬ "ë‹¨ì„œ/ì•„ì´í…œ í›„ë³´"ë¡œ
ë³€í™˜í•˜ëŠ” API ì—”ë“œí¬ì¸íŠ¸ë¥¼ ì œê³µí•©ë‹ˆë‹¤.

ì„¤ê³„ ì›ì¹™:
    - RULE-004: ì‹¤íŒ¨ ì‹œ ì•ˆì „í•œ í´ë°± (í…ìŠ¤íŠ¸-only ìº¡ì…˜)
    - RULE-007: í”„ë¡¬í”„íŠ¸ ì›ë¬¸/ì—…ë¡œë“œ íŒŒì¼ ë‚´ìš© ë¡œê¹… ê¸ˆì§€
    - RULE-009: bboxëŠ” 0~1000 ì •ê·œí™” + [ymin, xmin, ymax, xmax]

í˜ì–´ë§ ì§ˆë¬¸ ê²°ì •:
    - Q1: Option A (multipart ì—…ë¡œë“œë¡œ ì²˜ë¦¬)

ì°¸ì¡°:
    - vibe/unit-plans/U-021[Mvp].md
    - vibe/prd.md 6.7 (Scanner ìŠ¬ë¡¯)
    - .cursor/rules/00-core-critical.mdc
"""

from __future__ import annotations

import logging
from typing import Annotated

from fastapi import APIRouter, Depends, File, Form, UploadFile
from pydantic import BaseModel, ConfigDict, Field

from unknown_world.models.scanner import (
    DetectedObject,
    ItemCandidate,
    ScanResult,
    ScanStatus,
)
from unknown_world.models.turn import Language
from unknown_world.services.image_understanding import (
    ALLOWED_MIME_TYPES,
    MAX_FILE_SIZE_BYTES,
    ImageUnderstandingService,
    get_image_understanding_service,
)

# =============================================================================
# ë¡œê±° ì„¤ì •
# =============================================================================

logger = logging.getLogger(__name__)

# =============================================================================
# ë¼ìš°í„° ì •ì˜
# =============================================================================

router = APIRouter(
    prefix="/api/scan",
    tags=["Scanner"],
)


# =============================================================================
# ì˜ì¡´ì„± ì£¼ì…
# =============================================================================


async def get_scanner_service() -> ImageUnderstandingService:
    """Scanner ì„œë¹„ìŠ¤ ì˜ì¡´ì„±."""
    return get_image_understanding_service()


# =============================================================================
# ì‘ë‹µ ìŠ¤í‚¤ë§ˆ (API ê³„ì¸µìš©)
# =============================================================================


class ScannerResponse(BaseModel):
    """Scanner API ì‘ë‹µ.

    Attributes:
        success: ì„±ê³µ ì—¬ë¶€
        status: ìŠ¤ìº” ìƒíƒœ
        caption: ì´ë¯¸ì§€ ìº¡ì…˜
        objects: ê°ì§€ëœ ì˜¤ë¸Œì íŠ¸ ëª©ë¡
        item_candidates: ì•„ì´í…œ í›„ë³´ ëª©ë¡
        message: ìƒíƒœ/ì—ëŸ¬ ë©”ì‹œì§€
        analysis_time_ms: ë¶„ì„ ì†Œìš” ì‹œê°„ (ms)
        language: ì‘ë‹µ ì–¸ì–´
        original_image_key: ì €ì¥ëœ ì›ë³¸ ì´ë¯¸ì§€ ìŠ¤í† ë¦¬ì§€ í‚¤ (RU-006-S1)
        original_image_url: ì €ì¥ëœ ì›ë³¸ ì´ë¯¸ì§€ URL (RU-006-S1)
    """

    model_config = ConfigDict(extra="forbid")

    success: bool = Field(description="ì„±ê³µ ì—¬ë¶€")
    status: ScanStatus = Field(description="ìŠ¤ìº” ìƒíƒœ")
    caption: str = Field(default="", description="ì´ë¯¸ì§€ ìº¡ì…˜")
    objects: list[DetectedObject] = Field(
        default_factory=lambda: [],
        description="ê°ì§€ëœ ì˜¤ë¸Œì íŠ¸ ëª©ë¡",
    )
    item_candidates: list[ItemCandidate] = Field(
        default_factory=lambda: [],
        description="ì•„ì´í…œ í›„ë³´ ëª©ë¡",
    )
    message: str | None = Field(default=None, description="ìƒíƒœ/ì—ëŸ¬ ë©”ì‹œì§€")
    analysis_time_ms: int = Field(default=0, description="ë¶„ì„ ì†Œìš” ì‹œê°„ (ms)")
    language: Language = Field(description="ì‘ë‹µ ì–¸ì–´")
    original_image_key: str | None = Field(
        default=None,
        description="ì €ì¥ëœ ì›ë³¸ ì´ë¯¸ì§€ ìŠ¤í† ë¦¬ì§€ í‚¤",
    )
    original_image_url: str | None = Field(
        default=None,
        description="ì €ì¥ëœ ì›ë³¸ ì´ë¯¸ì§€ URL",
    )


class ScannerHealthResponse(BaseModel):
    """Scanner ì„œë¹„ìŠ¤ í—¬ìŠ¤ì²´í¬ ì‘ë‹µ.

    Attributes:
        status: ì„œë¹„ìŠ¤ ìƒíƒœ
        mode: ë™ì‘ ëª¨ë“œ (mock/real)
        model: ì‚¬ìš© ì¤‘ì¸ ëª¨ë¸ ë¼ë²¨
        supported_formats: ì§€ì›í•˜ëŠ” ì´ë¯¸ì§€ í˜•ì‹
        max_file_size_mb: ìµœëŒ€ íŒŒì¼ í¬ê¸° (MB)
    """

    model_config = ConfigDict(extra="forbid")

    status: str = Field(description="ì„œë¹„ìŠ¤ ìƒíƒœ")
    mode: str = Field(description="ë™ì‘ ëª¨ë“œ")
    model: str = Field(description="ì‚¬ìš© ì¤‘ì¸ ëª¨ë¸")
    supported_formats: list[str] = Field(description="ì§€ì›í•˜ëŠ” ì´ë¯¸ì§€ í˜•ì‹")
    max_file_size_mb: int = Field(description="ìµœëŒ€ íŒŒì¼ í¬ê¸° (MB)")


# =============================================================================
# ì—”ë“œí¬ì¸íŠ¸ ì •ì˜
# =============================================================================


@router.post(
    "",
    response_model=ScannerResponse,
    summary="ì´ë¯¸ì§€ ìŠ¤ìº”",
    description="ì´ë¯¸ì§€ë¥¼ ì—…ë¡œë“œí•˜ì—¬ ì˜¤ë¸Œì íŠ¸ì™€ ì•„ì´í…œ í›„ë³´ë¥¼ ì¶”ì¶œí•©ë‹ˆë‹¤.",
)
async def scan_image(
    file: Annotated[UploadFile, File(description="ë¶„ì„í•  ì´ë¯¸ì§€ íŒŒì¼")],
    language: Annotated[
        str,
        Form(description="ì‘ë‹µ ì–¸ì–´ (ko-KR ë˜ëŠ” en-US)"),
    ] = "ko-KR",
    preserve_original: Annotated[
        bool,
        Form(description="ì›ë³¸ ì´ë¯¸ì§€ ì €ì¥ ì—¬ë¶€ (ë””ë²„ê¹…/ì¬ë¶„ì„ìš©, RU-006-S1)"),
    ] = False,
    session_id: Annotated[
        str | None,
        Form(description="ì„¸ì…˜ ID (ì´ë¯¸ì§€ ê·¸ë£¹í™”ìš©)"),
    ] = None,
    service: ImageUnderstandingService = Depends(get_scanner_service),
) -> ScannerResponse:
    """ì´ë¯¸ì§€ë¥¼ ìŠ¤ìº”í•˜ì—¬ ì˜¤ë¸Œì íŠ¸ì™€ ì•„ì´í…œ í›„ë³´ë¥¼ ì¶”ì¶œí•©ë‹ˆë‹¤.

    ì´ ì—”ë“œí¬ì¸íŠ¸ëŠ” Scanner ìŠ¬ë¡¯ UIì—ì„œ ì´ë¯¸ì§€ë¥¼ ë“œë¡­/ì—…ë¡œë“œí•  ë•Œ í˜¸ì¶œë©ë‹ˆë‹¤.
    ì¶”ì¶œëœ ì•„ì´í…œ í›„ë³´ëŠ” ì¸ë²¤í† ë¦¬ì— ì¶”ê°€í•˜ê±°ë‚˜ ì„¸ê³„ì— ë°°ì¹˜í•  ìˆ˜ ìˆìŠµë‹ˆë‹¤.

    Args:
        file: ë¶„ì„í•  ì´ë¯¸ì§€ íŒŒì¼ (multipart/form-data)
        language: ì‘ë‹µ ì–¸ì–´ (ko-KR ë˜ëŠ” en-US)
        preserve_original: ì›ë³¸ ì´ë¯¸ì§€ ì €ì¥ ì—¬ë¶€ (RU-006-S1)
        session_id: ì„¸ì…˜ ID (ì´ë¯¸ì§€ ê·¸ë£¹í™”ìš©)
        service: Scanner ì„œë¹„ìŠ¤ (ì˜ì¡´ì„± ì£¼ì…)

    Returns:
        ScannerResponse: ìŠ¤ìº” ê²°ê³¼

    Raises:
        HTTPException: íŒŒì¼ í˜•ì‹ì´ ì˜ëª»ë˜ì—ˆê±°ë‚˜ í¬ê¸° ì´ˆê³¼ ì‹œ
    """
    # ì–¸ì–´ íŒŒì‹±
    try:
        lang = Language(language)
    except ValueError:
        lang = Language.KO

    # íŒŒì¼ ê²€ì¦: Content-Type
    content_type = file.content_type or "application/octet-stream"
    if content_type.lower() not in ALLOWED_MIME_TYPES:
        logger.warning(
            "[ScannerAPI] ì§€ì›í•˜ì§€ ì•ŠëŠ” íŒŒì¼ í˜•ì‹",
            extra={"content_type": content_type},
        )
        return ScannerResponse(
            success=False,
            status=ScanStatus.FAILED,
            message=f"ì§€ì›í•˜ì§€ ì•ŠëŠ” ì´ë¯¸ì§€ í˜•ì‹ì…ë‹ˆë‹¤: {content_type}",
            language=lang,
        )

    # íŒŒì¼ ì½ê¸°
    try:
        content = await file.read()
    except Exception as e:
        logger.error(
            "[ScannerAPI] íŒŒì¼ ì½ê¸° ì‹¤íŒ¨",
            extra={"error_type": type(e).__name__},
        )
        return ScannerResponse(
            success=False,
            status=ScanStatus.FAILED,
            message="íŒŒì¼ì„ ì½ì„ ìˆ˜ ì—†ìŠµë‹ˆë‹¤",
            language=lang,
        )

    # íŒŒì¼ í¬ê¸° ê²€ì¦
    if len(content) > MAX_FILE_SIZE_BYTES:
        size_mb = len(content) / (1024 * 1024)
        logger.warning(
            "[ScannerAPI] íŒŒì¼ í¬ê¸° ì´ˆê³¼",
            extra={"size_mb": size_mb},
        )
        return ScannerResponse(
            success=False,
            status=ScanStatus.FAILED,
            message=f"íŒŒì¼ì´ ë„ˆë¬´ í½ë‹ˆë‹¤: {size_mb:.1f}MB (ìµœëŒ€ 20MB)",
            language=lang,
        )

    # ë¡œê·¸: ë©”íƒ€ ì •ë³´ë§Œ ê¸°ë¡ (RULE-007: íŒŒì¼ ë‚´ìš© ë¡œê¹… ê¸ˆì§€)
    logger.info(
        "[ScannerAPI] ìŠ¤ìº” ìš”ì²­",
        extra={
            "filename": file.filename,
            "content_type": content_type,
            "size_kb": len(content) // 1024,
            "language": lang.value,
        },
    )

    # ì´ë¯¸ì§€ ë¶„ì„ ìˆ˜í–‰
    try:
        result: ScanResult = await service.analyze(
            image_content=content,
            content_type=content_type,
            language=lang,
            preserve_original=preserve_original,
            session_id=session_id,
        )

        # ì„±ê³µ ì—¬ë¶€ ê²°ì •
        success = result.status in (ScanStatus.COMPLETED, ScanStatus.PARTIAL)

        return ScannerResponse(
            success=success,
            status=result.status,
            caption=result.caption,
            objects=result.objects,
            item_candidates=result.item_candidates,
            message=result.message,
            analysis_time_ms=result.analysis_time_ms,
            language=lang,
            original_image_key=result.original_image_key,
            original_image_url=result.original_image_url,
        )

    except Exception as e:
        error_type = type(e).__name__
        logger.error(
            "[ScannerAPI] ìŠ¤ìº” ì¤‘ ì˜ˆì™¸ ë°œìƒ",
            extra={"error_type": error_type},
        )

        # ì•ˆì „í•œ í´ë°± ì‘ë‹µ (RULE-004)
        return ScannerResponse(
            success=False,
            status=ScanStatus.FAILED,
            message=f"ì´ë¯¸ì§€ ë¶„ì„ ì¤‘ ì˜¤ë¥˜ê°€ ë°œìƒí–ˆìŠµë‹ˆë‹¤: {error_type}",
            language=lang,
        )


@router.get(
    "/health",
    response_model=ScannerHealthResponse,
    summary="Scanner ì„œë¹„ìŠ¤ í—¬ìŠ¤ì²´í¬",
    description="Scanner ì„œë¹„ìŠ¤ì˜ ìƒíƒœë¥¼ í™•ì¸í•©ë‹ˆë‹¤.",
)
async def scanner_health(
    service: ImageUnderstandingService = Depends(get_scanner_service),
) -> ScannerHealthResponse:
    """Scanner ì„œë¹„ìŠ¤ í—¬ìŠ¤ì²´í¬.

    Args:
        service: Scanner ì„œë¹„ìŠ¤

    Returns:
        ScannerHealthResponse: ì„œë¹„ìŠ¤ ìƒíƒœ ì •ë³´
    """
    return ScannerHealthResponse(
        status="ok",
        mode="mock" if service.is_mock else "real",
        model="VISION (gemini-3-flash-preview)",
        supported_formats=list(ALLOWED_MIME_TYPES),
        max_file_size_mb=MAX_FILE_SIZE_BYTES // (1024 * 1024),
    )
</file>

<file path="backend/src/unknown_world/api/turn_stream_events.py">
"""Unknown World - Turn Stream ì´ë²¤íŠ¸ ê³„ì•½(Contract).

NDJSON ìŠ¤íŠ¸ë¦¬ë°ì—ì„œ ì‚¬ìš©ë˜ëŠ” ì´ë²¤íŠ¸ íƒ€ì…, ëª¨ë¸, ìœ í‹¸ë¦¬í‹°ë¥¼ ì •ì˜í•©ë‹ˆë‹¤.
ì´ ëª¨ë“ˆì€ Orchestrator â†” API â†” Frontend ê°„ì˜ ìŠ¤íŠ¸ë¦¼ ì´ë²¤íŠ¸ ê³„ì•½ SSOTì…ë‹ˆë‹¤.

ì„¤ê³„ ì›ì¹™:
    - RU-002-Q4: ì´ë²¤íŠ¸ ê³„ì•½ì„ transport ê³„ì¸µìœ¼ë¡œ ë¶„ë¦¬
    - RULE-003: êµ¬ì¡°í™” ì¶œë ¥(JSON Schema) ìš°ì„  + Pydantic ê²€ì¦
    - RULE-008: ë‹¨ê³„/ë°°ì§€ ê°€ì‹œí™”

ì°¸ì¡°:
    - vibe/unit-plans/U-007[Mvp].md
    - vibe/refactors/RU-002-Q4.md
"""

from __future__ import annotations

import json
from typing import Annotated, Any

from pydantic import BaseModel, Field

# =============================================================================
# ìŠ¤íŠ¸ë¦¼ ì´ë²¤íŠ¸ íƒ€ì… ìƒìˆ˜
# =============================================================================


class StreamEventType:
    """ìŠ¤íŠ¸ë¦¼ ì´ë²¤íŠ¸ íƒ€ì… ìƒìˆ˜.

    NDJSON ìŠ¤íŠ¸ë¦¬ë°ì—ì„œ ì‚¬ìš©ë˜ëŠ” ì´ë²¤íŠ¸ íƒ€ì…ì…ë‹ˆë‹¤.
    PRD ì˜ˆì‹œ ë‹¨ê³„: Parseâ†’Validateâ†’Planâ†’Resolveâ†’Renderâ†’Verifyâ†’Commit
    """

    STAGE = "stage"
    BADGES = "badges"
    NARRATIVE_DELTA = "narrative_delta"
    FINAL = "final"
    ERROR = "error"
    REPAIR = "repair"


class StageStatus:
    """ë‹¨ê³„ ìƒíƒœ ìƒìˆ˜."""

    START = "start"
    COMPLETE = "complete"
    FAIL = "fail"


# =============================================================================
# ìŠ¤íŠ¸ë¦¼ ì´ë²¤íŠ¸ ëª¨ë¸ (Pydantic)
# =============================================================================


class StageEvent(BaseModel):
    """ë‹¨ê³„ ì§„í–‰ ì´ë²¤íŠ¸.

    Attributes:
        type: ì´ë²¤íŠ¸ íƒ€ì… ("stage")
        name: ë‹¨ê³„ ì´ë¦„ (Parse, Validate, Plan, Resolve, Render, Verify, Commit)
        status: ìƒíƒœ (start, complete)
    """

    type: Annotated[str, Field(default=StreamEventType.STAGE)]
    name: str
    status: str


class RepairEvent(BaseModel):
    """ìë™ ë³µêµ¬(Repair) ì´ë²¤íŠ¸.

    Attributes:
        type: ì´ë²¤íŠ¸ íƒ€ì… ("repair")
        attempt: í˜„ì¬ ì‹œë„ íšŸìˆ˜
        message: ë³µêµ¬ ë©”ì‹œì§€ (ì„ íƒ)
    """

    type: Annotated[str, Field(default=StreamEventType.REPAIR)]
    attempt: int
    message: str | None = None


class BadgesEvent(BaseModel):
    """ë°°ì§€ ì´ë²¤íŠ¸.

    Attributes:
        type: ì´ë²¤íŠ¸ íƒ€ì… ("badges")
        badges: ê²€ì¦ ë°°ì§€ ëª©ë¡
    """

    type: Annotated[str, Field(default=StreamEventType.BADGES)]
    badges: list[str]


class NarrativeDeltaEvent(BaseModel):
    """ë‚´ëŸ¬í‹°ë¸Œ ë¸íƒ€ ì´ë²¤íŠ¸ (íƒ€ì íš¨ê³¼ìš©).

    Attributes:
        type: ì´ë²¤íŠ¸ íƒ€ì… ("narrative_delta")
        text: ì¶”ê°€ëœ í…ìŠ¤íŠ¸ ì¡°ê°
    """

    type: Annotated[str, Field(default=StreamEventType.NARRATIVE_DELTA)]
    text: str


class FinalEvent(BaseModel):
    """ìµœì¢… TurnOutput ì´ë²¤íŠ¸.

    Attributes:
        type: ì´ë²¤íŠ¸ íƒ€ì… ("final")
        data: ì™„ì „í•œ TurnOutput

    Note:
        TurnOutputì€ TYPE_CHECKING ë¸”ë¡ì—ì„œ importë˜ë©°,
        ëŸ°íƒ€ì„ì—ëŠ” Anyë¡œ ì²˜ë¦¬ë©ë‹ˆë‹¤.
    """

    type: Annotated[str, Field(default=StreamEventType.FINAL)]
    data: Any  # TurnOutput (ìˆœí™˜ import ë°©ì§€)


class ErrorEvent(BaseModel):
    """ì—ëŸ¬ ì´ë²¤íŠ¸.

    Attributes:
        type: ì´ë²¤íŠ¸ íƒ€ì… ("error")
        message: ì—ëŸ¬ ë©”ì‹œì§€ (í”„ë¡¬í”„íŠ¸/ë‚´ë¶€ ì¶”ë¡  ë…¸ì¶œ ê¸ˆì§€)
        code: ì—ëŸ¬ ì½”ë“œ (ì„ íƒ)
    """

    type: Annotated[str, Field(default=StreamEventType.ERROR)]
    message: str
    code: str | None = None


# =============================================================================
# ìœ í‹¸ë¦¬í‹° í•¨ìˆ˜
# =============================================================================


def serialize_event(event: dict[str, Any]) -> str:
    """ì´ë²¤íŠ¸ë¥¼ NDJSON ë¼ì¸ìœ¼ë¡œ ì§ë ¬í™”í•©ë‹ˆë‹¤.

    Args:
        event: ì§ë ¬í™”í•  ì´ë²¤íŠ¸ ë”•ì…”ë„ˆë¦¬

    Returns:
        str: NDJSON í˜•ì‹ ë¬¸ìì—´ (ì¤„ë°”ê¿ˆ í¬í•¨)
    """
    return json.dumps(event, ensure_ascii=False) + "\n"


# =============================================================================
# ëª¨ë“ˆ ê³µê°œ API
# =============================================================================

__all__ = [
    "StreamEventType",
    "StageStatus",
    "StageEvent",
    "RepairEvent",
    "BadgesEvent",
    "NarrativeDeltaEvent",
    "FinalEvent",
    "ErrorEvent",
    "serialize_event",
]
</file>

<file path="backend/src/unknown_world/models/__init__.py">
"""Unknown World - ëª¨ë¸ íŒ¨í‚¤ì§€.

ì´ íŒ¨í‚¤ì§€ëŠ” TurnInput/TurnOutput ìŠ¤í‚¤ë§ˆ ë° í•˜ìœ„ íƒ€ì…ì„ ì •ì˜í•©ë‹ˆë‹¤.
Gemini Structured Outputs(JSON Schema)ìš©ìœ¼ë¡œ ì„¤ê³„ë˜ì—ˆìŠµë‹ˆë‹¤.

ì‚¬ìš© ì˜ˆì‹œ:
    from unknown_world.models import TurnInput, TurnOutput

    # Pydantic â†’ JSON Schema ë³€í™˜ (Gemini response_json_schemaìš©)
    schema = TurnOutput.model_json_schema()

    # ì‘ë‹µ ê²€ì¦
    output = TurnOutput.model_validate_json(response_text)

ì°¸ì¡°:
    - vibe/prd.md 8.7 (ë°ì´í„° ëª¨ë¸ ì„¤ê³„)
    - vibe/ref/structured-outputs-guide.md
    - .cursor/rules/00-core-critical.mdc (RULE-003, RULE-005)
"""

from unknown_world.models.scanner import (
    DetectedObject,
    ItemCandidate,
    ScanRequest,
    ScanResponse,
    ScanResult,
    ScanStatus,
)
from unknown_world.models.turn import (
    ActionCard,
    ActionDeck,
    AgentConsole,
    AgentPhase,
    Box2D,
    ClickInput,
    ClientInfo,
    Coordinate,
    CurrencyAmount,
    EconomyOutput,
    EconomySnapshot,
    ImageJob,
    Language,
    MemoryPin,
    ModelLabel,
    Quest,
    RenderOutput,
    RiskLevel,
    SafetyOutput,
    SceneObject,
    Theme,
    TurnInput,
    TurnOutput,
    UIOutput,
    ValidationBadge,
    WorldDelta,
    WorldRule,
)

__all__ = [
    # Enum íƒ€ì…
    "Language",
    "Theme",
    "AgentPhase",
    "ValidationBadge",
    "ModelLabel",
    "RiskLevel",
    # ê³µí†µ í•˜ìœ„ íƒ€ì…
    "Coordinate",
    "Box2D",
    "CurrencyAmount",
    # TurnInput ê´€ë ¨
    "TurnInput",
    "ClickInput",
    "ClientInfo",
    "EconomySnapshot",
    # TurnOutput ê´€ë ¨
    "TurnOutput",
    "UIOutput",
    "ActionDeck",
    "ActionCard",
    "SceneObject",
    "WorldDelta",
    "WorldRule",
    "Quest",
    "MemoryPin",
    "RenderOutput",
    "ImageJob",
    "EconomyOutput",
    "SafetyOutput",
    "AgentConsole",
    # Scanner ê´€ë ¨ (U-021)
    "ScanStatus",
    "DetectedObject",
    "ItemCandidate",
    "ScanResult",
    "ScanRequest",
    "ScanResponse",
]
</file>

<file path="backend/src/unknown_world/models/scanner.py">
"""Unknown World - Scanner(ì´ë¯¸ì§€ ì´í•´) ìŠ¤í‚¤ë§ˆ.

ì´ ëª¨ë“ˆì€ ì´ë¯¸ì§€ ì—…ë¡œë“œ/ë¶„ì„ APIì˜ ìš”ì²­/ì‘ë‹µ ìŠ¤í‚¤ë§ˆë¥¼ ì •ì˜í•©ë‹ˆë‹¤.
ì‚¬ìš©ìê°€ ì—…ë¡œë“œí•œ ì´ë¯¸ì§€ë¥¼ ë¶„ì„í•˜ì—¬ "ë‹¨ì„œ/ì•„ì´í…œ í›„ë³´"ë¡œ ë³€í™˜í•©ë‹ˆë‹¤.

ì„¤ê³„ ì›ì¹™:
    - RULE-004: ì‹¤íŒ¨ ì‹œ ì•ˆì „í•œ í´ë°± (í…ìŠ¤íŠ¸-only ìº¡ì…˜)
    - RULE-009: bboxëŠ” 0~1000 ì •ê·œí™” + [ymin, xmin, ymax, xmax]

í˜ì–´ë§ ì§ˆë¬¸ ê²°ì •:
    - Q1: Option A (multipart ì—…ë¡œë“œë¡œ ì²˜ë¦¬, ë‹¨ìˆœ)

ì°¸ì¡°:
    - vibe/unit-plans/U-021[Mvp].md
    - vibe/prd.md 8.6 (ì´ë¯¸ì§€ ì´í•´ ìš”êµ¬)
    - .cursor/rules/00-core-critical.mdc (RULE-004, RULE-009)
"""

from enum import StrEnum

from pydantic import BaseModel, ConfigDict, Field

from unknown_world.models.turn import Box2D, Language


class ScanStatus(StrEnum):
    """ìŠ¤ìº” ìƒíƒœ.

    Attributes:
        COMPLETED: ë¶„ì„ ì„±ê³µ
        PARTIAL: ë¶€ë¶„ ì„±ê³µ (ì¼ë¶€ ì •ë³´ë§Œ ì¶”ì¶œë¨)
        FAILED: ë¶„ì„ ì‹¤íŒ¨
        BLOCKED: ì•ˆì „ ì •ì±…ì— ì˜í•´ ì°¨ë‹¨ë¨
    """

    COMPLETED = "completed"
    PARTIAL = "partial"
    FAILED = "failed"
    BLOCKED = "blocked"


class DetectedObject(BaseModel):
    """ê°ì§€ëœ ì˜¤ë¸Œì íŠ¸.

    ì´ë¯¸ì§€ì—ì„œ ê°ì§€ëœ ì˜¤ë¸Œì íŠ¸ ì •ë³´ì…ë‹ˆë‹¤.
    bboxëŠ” 0~1000 ì •ê·œí™” + [ymin, xmin, ymax, xmax] ê·œì•½ì„ ì¤€ìˆ˜í•©ë‹ˆë‹¤ (RULE-009).

    Attributes:
        label: ì˜¤ë¸Œì íŠ¸ ë¼ë²¨ (ì˜ˆ: "ì—´ì‡ ", "ë¬¸", "ìƒì")
        box_2d: ë°”ìš´ë”© ë°•ìŠ¤ (0~1000 ì •ê·œí™”)
        confidence: ì‹ ë¢°ë„ (0.0~1.0, ì„ íƒ)
        suggested_item_type: ì¶”ì²œ ì•„ì´í…œ ìœ í˜• (ì˜ˆ: "key", "weapon", "clue")
    """

    model_config = ConfigDict(extra="forbid")

    label: str = Field(description="ì˜¤ë¸Œì íŠ¸ ë¼ë²¨")
    box_2d: Box2D = Field(description="ë°”ìš´ë”© ë°•ìŠ¤ (0~1000 ì •ê·œí™”)")
    confidence: float | None = Field(
        default=None,
        ge=0.0,
        le=1.0,
        description="ì‹ ë¢°ë„ (0.0~1.0)",
    )
    suggested_item_type: str | None = Field(
        default=None,
        description="ì¶”ì²œ ì•„ì´í…œ ìœ í˜• (ì˜ˆ: key, weapon, clue)",
    )


class ItemCandidate(BaseModel):
    """ì•„ì´í…œ í›„ë³´.

    ê°ì§€ëœ ì˜¤ë¸Œì íŠ¸ë¥¼ ê¸°ë°˜ìœ¼ë¡œ ìƒì„±ëœ ê²Œì„ ì•„ì´í…œ í›„ë³´ì…ë‹ˆë‹¤.

    Attributes:
        id: ì•„ì´í…œ í›„ë³´ ID
        label: ì•„ì´í…œ ì´ë¦„
        description: ì•„ì´í…œ ì„¤ëª…
        item_type: ì•„ì´í…œ ìœ í˜• (ì˜ˆ: "key", "weapon", "clue", "material")
        source_object_index: ì›ë³¸ ì˜¤ë¸Œì íŠ¸ ì¸ë±ìŠ¤ (objects[] ê¸°ì¤€)
    """

    model_config = ConfigDict(extra="forbid")

    id: str = Field(description="ì•„ì´í…œ í›„ë³´ ID")
    label: str = Field(description="ì•„ì´í…œ ì´ë¦„")
    description: str = Field(default="", description="ì•„ì´í…œ ì„¤ëª…")
    item_type: str = Field(default="material", description="ì•„ì´í…œ ìœ í˜•")
    source_object_index: int | None = Field(
        default=None,
        ge=0,
        description="ì›ë³¸ ì˜¤ë¸Œì íŠ¸ ì¸ë±ìŠ¤",
    )


class ScanResult(BaseModel):
    """ìŠ¤ìº” ê²°ê³¼.

    ì´ë¯¸ì§€ ë¶„ì„ ê²°ê³¼ ì „ì²´ë¥¼ ë‹´ëŠ” ëª¨ë¸ì…ë‹ˆë‹¤.

    Attributes:
        status: ìŠ¤ìº” ìƒíƒœ
        caption: ì´ë¯¸ì§€ ì „ì²´ ìº¡ì…˜
        objects: ê°ì§€ëœ ì˜¤ë¸Œì íŠ¸ ëª©ë¡
        item_candidates: ì•„ì´í…œ í›„ë³´ ëª©ë¡
        message: ìƒíƒœ ë©”ì‹œì§€ (ì—ëŸ¬/ê²½ê³  ì‹œ)
        analysis_time_ms: ë¶„ì„ ì†Œìš” ì‹œê°„ (ms)
        original_image_key: ì €ì¥ëœ ì›ë³¸ ì´ë¯¸ì§€ì˜ ìŠ¤í† ë¦¬ì§€ í‚¤ (RU-006-S1)
        original_image_url: ì €ì¥ëœ ì›ë³¸ ì´ë¯¸ì§€ì˜ ì ‘ê·¼ URL (RU-006-S1)
    """

    model_config = ConfigDict(extra="forbid")

    status: ScanStatus = Field(description="ìŠ¤ìº” ìƒíƒœ")
    caption: str = Field(default="", description="ì´ë¯¸ì§€ ì „ì²´ ìº¡ì…˜")
    objects: list[DetectedObject] = Field(
        default_factory=lambda: [],
        description="ê°ì§€ëœ ì˜¤ë¸Œì íŠ¸ ëª©ë¡",
    )
    item_candidates: list[ItemCandidate] = Field(
        default_factory=lambda: [],
        description="ì•„ì´í…œ í›„ë³´ ëª©ë¡",
    )
    message: str | None = Field(default=None, description="ìƒíƒœ ë©”ì‹œì§€")
    analysis_time_ms: int = Field(default=0, description="ë¶„ì„ ì†Œìš” ì‹œê°„ (ms)")
    original_image_key: str | None = Field(
        default=None,
        description="ì €ì¥ëœ ì›ë³¸ ì´ë¯¸ì§€ì˜ ìŠ¤í† ë¦¬ì§€ í‚¤ (ì„ íƒì  ì €ì¥ ì‹œ)",
    )
    original_image_url: str | None = Field(
        default=None,
        description="ì €ì¥ëœ ì›ë³¸ ì´ë¯¸ì§€ì˜ ì ‘ê·¼ URL (ì„ íƒì  ì €ì¥ ì‹œ)",
    )


class ScanRequest(BaseModel):
    """ìŠ¤ìº” ìš”ì²­ (API ê³„ì¸µìš©).

    Attributes:
        language: ì‘ë‹µ ì–¸ì–´ (ìº¡ì…˜/ë¼ë²¨ì— ì ìš©)
    """

    model_config = ConfigDict(extra="forbid")

    language: Language = Field(
        default=Language.KO,
        description="ì‘ë‹µ ì–¸ì–´ (ìº¡ì…˜/ë¼ë²¨ì— ì ìš©)",
    )


class ScanResponse(BaseModel):
    """ìŠ¤ìº” ì‘ë‹µ (API ê³„ì¸µìš©).

    Attributes:
        success: ì„±ê³µ ì—¬ë¶€
        result: ìŠ¤ìº” ê²°ê³¼
        language: ì‘ë‹µ ì–¸ì–´
    """

    model_config = ConfigDict(extra="forbid")

    success: bool = Field(description="ì„±ê³µ ì—¬ë¶€")
    result: ScanResult = Field(description="ìŠ¤ìº” ê²°ê³¼")
    language: Language = Field(description="ì‘ë‹µ ì–¸ì–´")
</file>

<file path="backend/src/unknown_world/orchestrator/fallback.py">
"""Unknown World - ì•ˆì „í•œ í´ë°± TurnOutput ìƒì„±ê¸°.

ìµœì¢… ë³µêµ¬ ì‹¤íŒ¨ ì‹œì—ë„ UIê°€ ë¹ˆ í™”ë©´ì´ ë˜ì§€ ì•Šë„ë¡
ìŠ¤í‚¤ë§ˆë¥¼ ë§Œì¡±í•˜ëŠ” ì•ˆì „í•œ TurnOutputì„ ìƒì„±í•©ë‹ˆë‹¤.

ì„¤ê³„ ì›ì¹™:
    - RULE-004: ê²€ì¦ ì‹¤íŒ¨ ì‹œ ì•ˆì „í•œ í´ë°± ì œê³µ
    - RULE-005: ì¬í™” ì¸ë°”ë¦¬ì–¸íŠ¸ (ë¹„ìš© 0, ì”ì•¡ ìœ ì§€)
    - RULE-006: ko/en ì–¸ì–´ ì •ì±… ì¤€ìˆ˜

ì°¸ì¡°:
    - vibe/unit-plans/U-018[Mvp].md
    - vibe/prd.md 8.7 (TurnOutput ìŠ¤í‚¤ë§ˆ)
"""

from __future__ import annotations

from unknown_world.models.turn import (
    ActionCard,
    ActionDeck,
    AgentConsole,
    AgentPhase,
    CurrencyAmount,
    EconomyOutput,
    Language,
    RenderOutput,
    RiskLevel,
    SafetyOutput,
    TurnOutput,
    UIOutput,
    ValidationBadge,
    WorldDelta,
)

# =============================================================================
# í´ë°± ë©”ì‹œì§€ (i18n)
# =============================================================================

FALLBACK_MESSAGES = {
    Language.KO: {
        "narrative": "ì ì‹œ í˜¼ë€ìŠ¤ëŸ¬ìš´ ìˆœê°„ì´ ì§€ë‚˜ê°‘ë‹ˆë‹¤. ë‹¤ì‹œ ì§‘ì¤‘í•´ë´…ì‹œë‹¤.",
        "narrative_blocked": "ì•ˆì „ ì •ì±…ì— ë”°ë¼ ì´ ìš”ì²­ì„ ì²˜ë¦¬í•  ìˆ˜ ì—†ìŠµë‹ˆë‹¤. ë‹¤ë¥¸ í–‰ë™ì„ ì‹œë„í•´ë³´ì„¸ìš”.",
        "alternative_label": "í…ìŠ¤íŠ¸ë¡œ ì§„í–‰í•˜ê¸°",
        "alternative_desc": "ì´ë¯¸ì§€ ìƒì„± ì—†ì´ ì €ë¹„ìš©ìœ¼ë¡œ ì§„í–‰í•©ë‹ˆë‹¤",
    },
    Language.EN: {
        "narrative": "A moment of confusion passes. Let's focus again.",
        "narrative_blocked": "This request cannot be processed due to safety policies. Please try a different action.",
        "alternative_label": "Continue with text",
        "alternative_desc": "Proceed at low cost without image generation",
    },
}


# =============================================================================
# í´ë°± ìƒì„± í•¨ìˆ˜
# =============================================================================


def create_safe_fallback(
    language: Language,
    economy_snapshot: CurrencyAmount | None = None,
    repair_count: int = 0,
    is_blocked: bool = False,
) -> TurnOutput:
    """ì•ˆì „í•œ í´ë°± TurnOutputì„ ìƒì„±í•©ë‹ˆë‹¤.

    ìµœì¢… ë³µêµ¬ ì‹¤íŒ¨ ì‹œ ì‚¬ìš©í•©ë‹ˆë‹¤.
    ìŠ¤í‚¤ë§ˆë¥¼ ë§Œì¡±í•˜ê³ , ë¹„ìš© 0ìœ¼ë¡œ ì”ì•¡ì„ ìœ ì§€í•©ë‹ˆë‹¤.

    Args:
        language: ì‘ë‹µ ì–¸ì–´
        economy_snapshot: í˜„ì¬ ì¬í™” ìƒíƒœ (ë¹„ìš© 0ìœ¼ë¡œ ìœ ì§€)
        repair_count: ë³µêµ¬ ì‹œë„ íšŸìˆ˜
        is_blocked: ì•ˆì „ ì •ì±…ì— ì˜í•´ ì°¨ë‹¨ë˜ì—ˆëŠ”ì§€

    Returns:
        ì•ˆì „í•œ í´ë°± TurnOutput

    Example:
        >>> fallback = create_safe_fallback(
        ...     language=Language.KO,
        ...     economy_snapshot=CurrencyAmount(signal=50, memory_shard=3),
        ...     repair_count=2,
        ... )
        >>> print(fallback.narrative)
    """
    messages = FALLBACK_MESSAGES[language]

    # ë‚´ëŸ¬í‹°ë¸Œ ì„ íƒ
    narrative = messages["narrative_blocked"] if is_blocked else messages["narrative"]

    # ì¬í™” ìœ ì§€ (ë¹„ìš© 0)
    balance = economy_snapshot or CurrencyAmount(signal=100, memory_shard=5)

    # ì €ë¹„ìš© ëŒ€ì•ˆ ì¹´ë“œ ì œê³µ (RULE-005)
    alternative_card = ActionCard(
        id="fallback_text_only",
        label=messages["alternative_label"],
        description=messages["alternative_desc"],
        cost=CurrencyAmount(signal=1, memory_shard=0),
        risk=RiskLevel.LOW,
        enabled=True,
        is_alternative=True,
    )

    # ë°°ì§€ ê²°ì • (RU-005-S1: í´ë°±ì—ì„œë„ ëª¨ë“  ì¹´í…Œê³ ë¦¬ì˜ ë°°ì§€ë¥¼ ì¼ê´€ë˜ê²Œ ì„¤ì •)
    badges: list[ValidationBadge] = []

    # Schema: í´ë°±ì´ë¯€ë¡œ SCHEMA_FAIL (ë‹¨, ì•ˆì „ ì°¨ë‹¨ì€ ìŠ¤í‚¤ë§ˆ ë¬¸ì œê°€ ì•„ë‹˜)
    if not is_blocked:
        badges.append(ValidationBadge.SCHEMA_FAIL)
    else:
        badges.append(ValidationBadge.SCHEMA_OK)

    # Economy: í´ë°±ì—ì„œëŠ” ë¹„ìš© 0ì´ë¯€ë¡œ ECONOMY_OK
    badges.append(ValidationBadge.ECONOMY_OK)

    # Safety: is_blockedì— ë”°ë¼ ê²°ì •
    if is_blocked:
        badges.append(ValidationBadge.SAFETY_BLOCKED)
    else:
        badges.append(ValidationBadge.SAFETY_OK)

    # Consistency: í´ë°±ì—ì„œëŠ” ì–¸ì–´/ì¢Œí‘œ ë¬¸ì œê°€ ì—†ìœ¼ë¯€ë¡œ CONSISTENCY_OK
    badges.append(ValidationBadge.CONSISTENCY_OK)

    return TurnOutput(
        language=language,
        narrative=narrative,
        ui=UIOutput(
            action_deck=ActionDeck(cards=[alternative_card]),
            objects=[],
        ),
        world=WorldDelta(),
        render=RenderOutput(image_job=None),  # ì´ë¯¸ì§€ ìƒì„± ì•ˆ í•¨
        economy=EconomyOutput(
            cost=CurrencyAmount(signal=0, memory_shard=0),
            balance_after=balance,
        ),
        safety=SafetyOutput(
            blocked=is_blocked,
            message=messages["narrative_blocked"] if is_blocked else None,
        ),
        agent_console=AgentConsole(
            current_phase=AgentPhase.COMMIT,
            badges=badges,
            repair_count=repair_count,
        ),
    )
</file>

<file path="backend/src/unknown_world/orchestrator/generate_turn_output.py">
"""Unknown World - TurnOutput ìƒì„± ëª¨ë“ˆ (Structured Outputs).

ì´ ëª¨ë“ˆì€ Gemini í…ìŠ¤íŠ¸ ëª¨ë¸ì„ Structured Outputs(JSON Schema) ëª¨ë“œë¡œ í˜¸ì¶œí•´
TurnOutputì„ ìƒì„±í•˜ê³ , Pydantic ê²€ì¦ì„ í†µê³¼í•œ ê²°ê³¼ë§Œ ë°˜í™˜í•©ë‹ˆë‹¤.

ì„¤ê³„ ì›ì¹™:
    - RULE-003: êµ¬ì¡°í™” ì¶œë ¥(JSON Schema) ìš°ì„  + ì´ì¤‘ ê²€ì¦(Pydantic+Zod)
    - RULE-004: ê²€ì¦ ì‹¤íŒ¨ ì‹œ ìë™ ë³µêµ¬(Repair loop) + ì•ˆì „í•œ í´ë°±
    - RULE-005: ì¬í™” ì¸ë°”ë¦¬ì–¸íŠ¸ (ì”ì•¡ ìŒìˆ˜ ê¸ˆì§€)
    - RULE-006: ko/en ì–¸ì–´ ì •ì±… ì¤€ìˆ˜
    - RULE-007/008: í”„ë¡¬í”„íŠ¸/ë‚´ë¶€ ì¶”ë¡  ë…¸ì¶œ ê¸ˆì§€

í˜ì–´ë§ ì§ˆë¬¸ ê²°ì •:
    - Q1: ê¸°ë³¸ í…ìŠ¤íŠ¸ ìƒì„± ëª¨ë¸ ë¼ë²¨ = FAST (Option A)

ì°¸ì¡°:
    - vibe/unit-plans/U-017[Mvp].md
    - vibe/unit-results/U-016[Mvp].md
    - vibe/unit-results/U-005[Mvp].md
    - .cursor/rules/20-backend-orchestrator.mdc
"""

from __future__ import annotations

import json
import logging
from dataclasses import dataclass, field
from enum import StrEnum
from typing import Any

from pydantic import ValidationError

from unknown_world.config.models import ModelLabel
from unknown_world.models.turn import (
    CurrencyAmount,
    Language,
    TurnInput,
    TurnOutput,
)
from unknown_world.orchestrator.fallback import create_safe_fallback
from unknown_world.orchestrator.prompt_loader import (
    load_system_prompt,
    load_turn_instructions,
)
from unknown_world.services.genai_client import (
    GenerateRequest,
    get_genai_client,
)

# =============================================================================
# ë¡œê±° ì„¤ì • (í”„ë¡¬í”„íŠ¸/ë‚´ë¶€ ì¶”ë¡  ë…¸ì¶œ ê¸ˆì§€ - RULE-007/008)
# =============================================================================

logger = logging.getLogger(__name__)


# =============================================================================
# ìƒì„± ê²°ê³¼ íƒ€ì…
# =============================================================================


class GenerationStatus(StrEnum):
    """ìƒì„± ê²°ê³¼ ìƒíƒœ."""

    SUCCESS = "success"
    """Pydantic ê²€ì¦ í†µê³¼"""

    SCHEMA_FAILURE = "schema_failure"
    """JSON íŒŒì‹± ë˜ëŠ” ìŠ¤í‚¤ë§ˆ ê²€ì¦ ì‹¤íŒ¨ (ë³µêµ¬ ëŒ€ìƒ)"""

    BUSINESS_FAILURE = "business_failure"
    """ë¹„ì¦ˆë‹ˆìŠ¤ ë£° ìœ„ë°˜ (U-018ì—ì„œ ì²˜ë¦¬)"""

    SAFETY_BLOCKED = "safety_blocked"
    """ì•ˆì „ ì •ì±…ì— ì˜í•´ ì°¨ë‹¨ë¨"""

    API_ERROR = "api_error"
    """API í˜¸ì¶œ ì‹¤íŒ¨"""


@dataclass
class GenerationResult:
    """TurnOutput ìƒì„± ê²°ê³¼.

    Attributes:
        status: ìƒì„± ìƒíƒœ
        output: ìƒì„±ëœ TurnOutput (ì„±ê³µ ì‹œ)
        error_message: ì—ëŸ¬ ë©”ì‹œì§€ (ì‹¤íŒ¨ ì‹œ, ì‚¬ìš©ì í‘œì‹œìš©)
        error_details: ìƒì„¸ ì—ëŸ¬ ì •ë³´ (ë‚´ë¶€ìš©, UI ë…¸ì¶œ ê¸ˆì§€)
        model_label: ì‚¬ìš©ëœ ëª¨ë¸ ë¼ë²¨
        raw_response: ì›ë³¸ ì‘ë‹µ í…ìŠ¤íŠ¸ (ë””ë²„ê·¸ìš©, UI ë…¸ì¶œ ê¸ˆì§€)
    """

    status: GenerationStatus
    output: TurnOutput | None = None
    error_message: str = ""
    error_details: dict[str, Any] = field(default_factory=lambda: {})
    model_label: ModelLabel = ModelLabel.FAST
    raw_response: str = ""


# =============================================================================
# TurnOutput ìƒì„±ê¸°
# =============================================================================


class TurnOutputGenerator:
    """Structured Outputsë¥¼ ì‚¬ìš©í•œ TurnOutput ìƒì„±ê¸°.

    Gemini ëª¨ë¸ì„ JSON Schema ëª¨ë“œë¡œ í˜¸ì¶œí•˜ê³ ,
    Pydanticìœ¼ë¡œ ì‘ë‹µì„ ê²€ì¦í•©ë‹ˆë‹¤.

    Example:
        >>> generator = TurnOutputGenerator()
        >>> result = await generator.generate(turn_input)
        >>> if result.status == GenerationStatus.SUCCESS:
        ...     print(result.output.narrative)
    """

    def __init__(
        self,
        *,
        default_model_label: ModelLabel = ModelLabel.FAST,
        force_mock: bool = False,
    ) -> None:
        """TurnOutputGeneratorë¥¼ ì´ˆê¸°í™”í•©ë‹ˆë‹¤.

        Args:
            default_model_label: ê¸°ë³¸ ëª¨ë¸ ë¼ë²¨ (Q1 ê²°ì •: FAST)
            force_mock: Mock í´ë¼ì´ì–¸íŠ¸ ê°•ì œ ì‚¬ìš© ì—¬ë¶€
        """
        self._default_model_label = default_model_label
        self._force_mock = force_mock
        self._json_schema: dict[str, Any] | None = None

    def _get_json_schema(self) -> dict[str, Any]:
        """TurnOutput JSON Schemaë¥¼ ë°˜í™˜í•©ë‹ˆë‹¤ (ìºì‹±)."""
        if self._json_schema is None:
            self._json_schema = TurnOutput.model_json_schema()
        return self._json_schema

    def _build_prompt(
        self,
        turn_input: TurnInput,
        world_context: str = "",
    ) -> str:
        """ì „ì²´ í”„ë¡¬í”„íŠ¸ë¥¼ êµ¬ì„±í•©ë‹ˆë‹¤.

        Args:
            turn_input: ì‚¬ìš©ì í„´ ì…ë ¥
            world_context: í˜„ì¬ ì„¸ê³„ ìƒíƒœ ìš”ì•½ (ì„ íƒ)

        Returns:
            ì¡°í•©ëœ í”„ë¡¬í”„íŠ¸ ë¬¸ìì—´
        """
        # ì–¸ì–´ë³„ í”„ë¡¬í”„íŠ¸ ë¡œë“œ
        system_prompt = load_system_prompt(turn_input.language)
        turn_instructions = load_turn_instructions(turn_input.language)

        # ì…ë ¥ ì •ë³´ êµ¬ì„± (í”„ë¡¬í”„íŠ¸ì— í¬í•¨)
        input_summary = f"""
## í˜„ì¬ í„´ ì…ë ¥

- language: {turn_input.language.value}
- text: "{turn_input.text}"
- action_id: {turn_input.action_id or "ì—†ìŒ"}
- economy_snapshot:
  - signal: {turn_input.economy_snapshot.signal}
  - memory_shard: {turn_input.economy_snapshot.memory_shard}
"""

        # ì„¸ê³„ ìƒíƒœ ì»¨í…ìŠ¤íŠ¸ (ìˆëŠ” ê²½ìš°)
        world_section = ""
        if world_context:
            world_section = f"""
## í˜„ì¬ ì„¸ê³„ ìƒíƒœ

{world_context}
"""

        # ì „ì²´ í”„ë¡¬í”„íŠ¸ ì¡°í•©
        full_prompt = f"""{system_prompt}

---

{turn_instructions}

---

{input_summary}
{world_section}

---

ìœ„ ì§€ì‹œì— ë”°ë¼ TurnOutput JSONì„ ìƒì„±í•˜ì„¸ìš”.
"""
        return full_prompt

    async def generate(
        self,
        turn_input: TurnInput,
        *,
        model_label: ModelLabel | None = None,
        world_context: str = "",
    ) -> GenerationResult:
        """TurnOutputì„ ìƒì„±í•©ë‹ˆë‹¤.

        Structured Outputs(JSON Schema) ëª¨ë“œë¡œ Geminië¥¼ í˜¸ì¶œí•˜ê³ ,
        Pydanticìœ¼ë¡œ ì‘ë‹µì„ ê²€ì¦í•©ë‹ˆë‹¤.

        Args:
            turn_input: ì‚¬ìš©ì í„´ ì…ë ¥
            model_label: ì‚¬ìš©í•  ëª¨ë¸ ë¼ë²¨ (Noneì´ë©´ ê¸°ë³¸ê°’ FAST)
            world_context: í˜„ì¬ ì„¸ê³„ ìƒíƒœ ìš”ì•½ (ì„ íƒ)

        Returns:
            GenerationResult: ìƒì„± ê²°ê³¼ (status, output, error ë“±)
        """
        label = model_label or self._default_model_label

        # ë¡œê·¸ì—ëŠ” ë©”íƒ€ë§Œ ê¸°ë¡ (í”„ë¡¬í”„íŠ¸ ì›ë¬¸ ê¸ˆì§€ - RULE-007/008)
        logger.info(
            "[TurnOutputGenerator] ìƒì„± ìš”ì²­",
            extra={
                "language": turn_input.language.value,
                "model_label": label,
                "has_text": bool(turn_input.text),
                "has_action_id": bool(turn_input.action_id),
            },
        )

        try:
            # GenAI í´ë¼ì´ì–¸íŠ¸ ê°€ì ¸ì˜¤ê¸°
            client = get_genai_client(force_mock=self._force_mock)

            # í”„ë¡¬í”„íŠ¸ êµ¬ì„±
            prompt = self._build_prompt(turn_input, world_context)

            # Structured Outputs ìš”ì²­ êµ¬ì„± (RULE-003)
            # SDK ë ˆë²¨ì—ì„œ JSON Schemaë¥¼ ê°•ì œí•˜ì—¬ íŒŒì‹± ì˜¤ë¥˜ë¥¼ ìµœì†Œí™”í•©ë‹ˆë‹¤.
            json_schema = self._get_json_schema()
            request = GenerateRequest(
                prompt=prompt,
                model_label=label,
                temperature=0.7,  # ì°½ì˜ì„± ì ë‹¹íˆ
                response_mime_type="application/json",
                response_schema=json_schema,
            )

            # API í˜¸ì¶œ
            response = await client.generate(request)
            raw_text = response.text

            # Pydantic ê²€ì¦ (model_validate_json ì‚¬ìš© - U-017 ì™„ë£Œ ê¸°ì¤€)
            # Structured Outputsë¡œ ì¸í•´ ì‘ë‹µì´ ì´ë¯¸ JSONì´ë¯€ë¡œ
            # ë§ˆí¬ë‹¤ìš´ ì½”ë“œë¸”ë¡ ì²˜ë¦¬ í›„ ì§ì ‘ ê²€ì¦í•©ë‹ˆë‹¤.
            try:
                # ì‘ë‹µì—ì„œ JSON ë¶€ë¶„ ì¶”ì¶œ (ë§ˆí¬ë‹¤ìš´ ì½”ë“œë¸”ë¡ ì²˜ë¦¬)
                json_text = self._extract_json(raw_text)

                # model_validate_json: JSON ë¬¸ìì—´ì„ ì§ì ‘ íŒŒì‹±+ê²€ì¦ (U-017 ì™„ë£Œ ê¸°ì¤€)
                turn_output = TurnOutput.model_validate_json(json_text)

                # ì„±ê³µ
                logger.info(
                    "[TurnOutputGenerator] ìƒì„± ì„±ê³µ",
                    extra={
                        "model_label": label,
                        "has_narrative": bool(turn_output.narrative),
                        "cost_signal": turn_output.economy.cost.signal,
                    },
                )

                return GenerationResult(
                    status=GenerationStatus.SUCCESS,
                    output=turn_output,
                    model_label=label,
                    raw_response=raw_text,
                )

            except ValidationError as e:
                # ìŠ¤í‚¤ë§ˆ ê²€ì¦ ì‹¤íŒ¨ (ë³µêµ¬ ëŒ€ìƒ - U-018ì—ì„œ ì²˜ë¦¬)
                logger.warning(
                    "[TurnOutputGenerator] Pydantic ê²€ì¦ ì‹¤íŒ¨ (ë³µêµ¬ ëŒ€ìƒ)",
                    extra={
                        "error_count": len(e.errors()),
                        "model_label": label,
                    },
                )
                return GenerationResult(
                    status=GenerationStatus.SCHEMA_FAILURE,
                    error_message="ì‘ë‹µ í˜•ì‹ì´ ì˜¬ë°”ë¥´ì§€ ì•ŠìŠµë‹ˆë‹¤"
                    if turn_input.language == Language.KO
                    else "Invalid response format",
                    error_details={
                        "validation_errors": [
                            {"loc": err["loc"], "type": err["type"]} for err in e.errors()
                        ]
                    },
                    model_label=label,
                    raw_response=raw_text,
                )
            except json.JSONDecodeError as e:
                # JSON íŒŒì‹± ì‹¤íŒ¨ (ë³µêµ¬ ëŒ€ìƒ)
                logger.warning(
                    "[TurnOutputGenerator] JSON íŒŒì‹± ì‹¤íŒ¨ (ë³µêµ¬ ëŒ€ìƒ)",
                    extra={"error_type": "JSONDecodeError"},
                )
                return GenerationResult(
                    status=GenerationStatus.SCHEMA_FAILURE,
                    error_message="ì‘ë‹µì„ íŒŒì‹±í•  ìˆ˜ ì—†ìŠµë‹ˆë‹¤"
                    if turn_input.language == Language.KO
                    else "Failed to parse response",
                    error_details={"json_error": str(e)},
                    model_label=label,
                    raw_response=raw_text,
                )

        except RuntimeError as e:
            # API í˜¸ì¶œ ì‹¤íŒ¨
            logger.error(
                "[TurnOutputGenerator] API í˜¸ì¶œ ì‹¤íŒ¨",
                extra={"error_type": type(e).__name__},
            )
            return GenerationResult(
                status=GenerationStatus.API_ERROR,
                error_message="ì„œë¹„ìŠ¤ì— ì—°ê²°í•  ìˆ˜ ì—†ìŠµë‹ˆë‹¤"
                if turn_input.language == Language.KO
                else "Unable to connect to service",
                error_details={"api_error": str(e)},
                model_label=label,
            )

        except Exception as e:
            # ì˜ˆìƒì¹˜ ëª»í•œ ì˜¤ë¥˜
            logger.exception(
                "[TurnOutputGenerator] ì˜ˆìƒì¹˜ ëª»í•œ ì˜¤ë¥˜",
                extra={"error_type": type(e).__name__},
            )
            return GenerationResult(
                status=GenerationStatus.API_ERROR,
                error_message="ì²˜ë¦¬ ì¤‘ ì˜¤ë¥˜ê°€ ë°œìƒí–ˆìŠµë‹ˆë‹¤"
                if turn_input.language == Language.KO
                else "An error occurred during processing",
                error_details={"unexpected_error": type(e).__name__},
                model_label=label,
            )

    def _extract_json(self, text: str) -> str:
        """ì‘ë‹µ í…ìŠ¤íŠ¸ì—ì„œ JSON ë¶€ë¶„ì„ ì¶”ì¶œí•©ë‹ˆë‹¤.

        ë§ˆí¬ë‹¤ìš´ ì½”ë“œë¸”ë¡ìœ¼ë¡œ ê°ì‹¸ì§„ ê²½ìš°ë¥¼ ì²˜ë¦¬í•©ë‹ˆë‹¤.

        Args:
            text: ì›ë³¸ ì‘ë‹µ í…ìŠ¤íŠ¸

        Returns:
            JSON ë¬¸ìì—´
        """
        text = text.strip()

        # ë§ˆí¬ë‹¤ìš´ ì½”ë“œë¸”ë¡ ì²˜ë¦¬ (```json ... ```)
        if text.startswith("```"):
            lines = text.split("\n")
            # ì²« ì¤„(```json)ê³¼ ë§ˆì§€ë§‰ ì¤„(```) ì œê±°
            if lines[0].startswith("```"):
                lines = lines[1:]
            if lines and lines[-1].strip() == "```":
                lines = lines[:-1]
            text = "\n".join(lines)

        return text.strip()

    def create_safe_fallback(
        self,
        language: Language,
        error_message: str,  # noqa: ARG002 - í•˜ìœ„ í˜¸í™˜ìš© (ì‹¤ì œë¡œ ì‚¬ìš©í•˜ì§€ ì•ŠìŒ)
        economy_snapshot: CurrencyAmount | None = None,
    ) -> TurnOutput:
        """ì•ˆì „í•œ í´ë°± TurnOutputì„ ìƒì„±í•©ë‹ˆë‹¤.

        ê²€ì¦ ì‹¤íŒ¨ ë˜ëŠ” ì—ëŸ¬ ë°œìƒ ì‹œ ì‚¬ìš©í•©ë‹ˆë‹¤.
        (RULE-004: ì•ˆì „í•œ í´ë°± ì œê³µ)

        Note:
            ì´ ë©”ì„œë“œëŠ” fallback.create_safe_fallback SSOTë¡œ ìœ„ì„í•©ë‹ˆë‹¤ (RU-005-Q1).

        Args:
            language: ì–¸ì–´
            error_message: ì—ëŸ¬ ë©”ì‹œì§€ (í•˜ìœ„ í˜¸í™˜ìš©, ì‹¤ì œ ë¯¸ì‚¬ìš©)
            economy_snapshot: í˜„ì¬ ì¬í™” ìƒíƒœ (ë¹„ìš© 0ìœ¼ë¡œ ìœ ì§€)

        Returns:
            ì•ˆì „í•œ í´ë°± TurnOutput
        """
        # RU-005-Q1: fallback SSOTë¡œ ìœ„ì„
        return create_safe_fallback(
            language=language,
            economy_snapshot=economy_snapshot,
            repair_count=0,
            is_blocked=False,
        )


# =============================================================================
# í¸ì˜ í•¨ìˆ˜
# =============================================================================

# ê¸°ë³¸ ìƒì„±ê¸° ì¸ìŠ¤í„´ìŠ¤ (ì‹±ê¸€í†¤)
_default_generator: TurnOutputGenerator | None = None


def get_turn_output_generator(
    *,
    force_mock: bool = False,
    force_new: bool = False,
) -> TurnOutputGenerator:
    """TurnOutputGenerator ì¸ìŠ¤í„´ìŠ¤ë¥¼ ë°˜í™˜í•©ë‹ˆë‹¤.

    Args:
        force_mock: Mock í´ë¼ì´ì–¸íŠ¸ ê°•ì œ ì‚¬ìš© ì—¬ë¶€
        force_new: ìƒˆ ì¸ìŠ¤í„´ìŠ¤ ìƒì„± ì—¬ë¶€

    Returns:
        TurnOutputGenerator ì¸ìŠ¤í„´ìŠ¤
    """
    global _default_generator

    if force_new or _default_generator is None or force_mock:
        _default_generator = TurnOutputGenerator(
            default_model_label=ModelLabel.FAST,  # Q1 ê²°ì •: FAST ê¸°ë³¸
            force_mock=force_mock,
        )

    return _default_generator


async def generate_turn_output(
    turn_input: TurnInput,
    *,
    model_label: ModelLabel | None = None,
    world_context: str = "",
    force_mock: bool = False,
) -> GenerationResult:
    """TurnOutputì„ ìƒì„±í•˜ëŠ” í¸ì˜ í•¨ìˆ˜.

    Args:
        turn_input: ì‚¬ìš©ì í„´ ì…ë ¥
        model_label: ì‚¬ìš©í•  ëª¨ë¸ ë¼ë²¨ (Noneì´ë©´ ê¸°ë³¸ê°’ FAST)
        world_context: í˜„ì¬ ì„¸ê³„ ìƒíƒœ ìš”ì•½ (ì„ íƒ)
        force_mock: Mock í´ë¼ì´ì–¸íŠ¸ ê°•ì œ ì‚¬ìš© ì—¬ë¶€

    Returns:
        GenerationResult: ìƒì„± ê²°ê³¼

    Example:
        >>> result = await generate_turn_output(turn_input)
        >>> if result.status == GenerationStatus.SUCCESS:
        ...     print(result.output.narrative)
    """
    generator = get_turn_output_generator(force_mock=force_mock)
    return await generator.generate(
        turn_input,
        model_label=model_label,
        world_context=world_context,
    )
</file>

<file path="backend/src/unknown_world/orchestrator/stages/validate.py">
"""Unknown World - Validate Stage.

ë¹„ì¦ˆë‹ˆìŠ¤ ë£° ê²€ì¦ + Repair loop ë‹¨ê³„ì…ë‹ˆë‹¤.
U-018ì˜ run_repair_loop()ë¥¼ í˜¸ì¶œí•´ output/badges/repair_countë¥¼ ê²°ì •í•©ë‹ˆë‹¤.

ì„¤ê³„ ì›ì¹™:
    - RULE-003: êµ¬ì¡°í™” ì¶œë ¥(JSON Schema) + ì´ì¤‘ ê²€ì¦
    - RULE-004: ê²€ì¦ ì‹¤íŒ¨ ì‹œ Repair loop + ì•ˆì „í•œ í´ë°±
    - RULE-005: ì¬í™” ì¸ë°”ë¦¬ì–¸íŠ¸ (ì”ì•¡ ìŒìˆ˜ ê¸ˆì§€)
    - RULE-008: ë‹¨ê³„/ë°°ì§€ ê°€ì‹œí™”

ì°¸ì¡°:
    - vibe/refactors/RU-005-Q4.md
    - vibe/unit-plans/U-018[Mvp].md
"""

from __future__ import annotations

from unknown_world.models.turn import AgentPhase, Language, ValidationBadge
from unknown_world.orchestrator.fallback import create_safe_fallback
from unknown_world.orchestrator.mock import MockOrchestrator
from unknown_world.orchestrator.repair_loop import (
    MAX_REPAIR_ATTEMPTS,
    add_business_badges,
    run_repair_loop,
)
from unknown_world.orchestrator.stages.types import (
    EmitFn,
    PipelineContext,
    PipelineEvent,
    PipelineEventType,
)
from unknown_world.validation.business_rules import validate_business_rules


async def validate_stage(ctx: PipelineContext, *, emit: EmitFn) -> PipelineContext:
    """Validate ë‹¨ê³„ë¥¼ ì‹¤í–‰í•©ë‹ˆë‹¤.

    Mock ëª¨ë“œì™€ Real ëª¨ë“œë¥¼ êµ¬ë¶„í•˜ì—¬ ì²˜ë¦¬í•©ë‹ˆë‹¤.
    - Mock: MockOrchestratorë¡œ ìƒì„± + ë¹„ì¦ˆë‹ˆìŠ¤ ë£° ê²€ì¦
    - Real: run_repair_loop() í˜¸ì¶œ (Gemini API + Repair loop)

    Args:
        ctx: íŒŒì´í”„ë¼ì¸ ì»¨í…ìŠ¤íŠ¸
        emit: ì´ë²¤íŠ¸ emit ì½œë°±

    Returns:
        ì—…ë°ì´íŠ¸ëœ ì»¨í…ìŠ¤íŠ¸ (output, badges, repair_attempts í¬í•¨)
    """
    ctx.current_phase = AgentPhase.VALIDATE

    # Stage ì‹œì‘ ì´ë²¤íŠ¸
    await emit(
        PipelineEvent(
            event_type=PipelineEventType.STAGE_START,
            phase=AgentPhase.VALIDATE,
        )
    )

    try:
        if ctx.is_mock:
            await _validate_mock(ctx, emit)
        else:
            await _validate_real(ctx, emit)
    except Exception:
        # ì˜ˆì™¸ ë°œìƒ ì‹œ í´ë°± (RULE-004, RU-005-S1)
        ctx.output = create_safe_fallback(
            language=ctx.turn_input.language,
            economy_snapshot=ctx.economy_snapshot,
            repair_count=ctx.repair_attempts,
        )
        ctx.is_fallback = True
        # RU-005-S1: í´ë°±ì˜ ë°°ì§€ë¥¼ ìŠ¤íŠ¸ë¦¼ ì´ë²¤íŠ¸ì™€ ë™ê¸°í™”
        ctx.badges = list(ctx.output.agent_console.badges)

    # Stage ì™„ë£Œ ì´ë²¤íŠ¸
    await emit(
        PipelineEvent(
            event_type=PipelineEventType.STAGE_COMPLETE,
            phase=AgentPhase.VALIDATE,
        )
    )

    # ë°°ì§€ ì´ë²¤íŠ¸ ì „ì†¡
    if ctx.badges:
        await emit(
            PipelineEvent(
                event_type=PipelineEventType.BADGES,
                badges=ctx.badges,
            )
        )

    return ctx


async def _validate_mock(ctx: PipelineContext, emit: EmitFn) -> None:
    """Mock ëª¨ë“œ ê²€ì¦ì„ ìˆ˜í–‰í•©ë‹ˆë‹¤."""
    orchestrator = MockOrchestrator(seed=ctx.seed)
    repair_attempt = 0

    while repair_attempt <= MAX_REPAIR_ATTEMPTS:
        # 0íšŒì°¨ëŠ” ì •ìƒ ì‹œë„, 1íšŒì°¨ë¶€í„°ëŠ” repair
        if repair_attempt > 0:
            await emit(
                PipelineEvent(
                    event_type=PipelineEventType.REPAIR,
                    repair_attempt=repair_attempt,
                    repair_message=(
                        "ê²€ì¦ ì‹¤íŒ¨ë¡œ ì¸í•´ ë‹¤ì‹œ ì‹œë„ ì¤‘ì…ë‹ˆë‹¤..."
                        if ctx.turn_input.language == Language.KO
                        else "Retrying due to validation failure..."
                    ),
                )
            )
            ctx.repair_messages.append(
                "ê²€ì¦ ì‹¤íŒ¨ë¡œ ì¸í•´ ë‹¤ì‹œ ì‹œë„ ì¤‘ì…ë‹ˆë‹¤..."
                if ctx.turn_input.language == Language.KO
                else "Retrying due to validation failure..."
            )

        try:
            # Mock ìƒì„±
            turn_output = orchestrator.generate_turn_output(ctx.turn_input)

            # ë¹„ì¦ˆë‹ˆìŠ¤ ë£° ê²€ì¦ (U-018)
            biz_result = validate_business_rules(ctx.turn_input, turn_output)
            if not biz_result.is_valid:
                # ë¹„ì¦ˆë‹ˆìŠ¤ ë£° ì‹¤íŒ¨ â†’ ì¬ì‹œë„
                repair_attempt += 1
                ctx.repair_attempts = repair_attempt
                if repair_attempt > MAX_REPAIR_ATTEMPTS:
                    # ìµœì¢… ì‹¤íŒ¨ ì‹œ í´ë°± (RULE-004, RU-005-S1)
                    ctx.output = create_safe_fallback(
                        language=ctx.turn_input.language,
                        economy_snapshot=ctx.economy_snapshot,
                        repair_count=repair_attempt,
                    )
                    ctx.is_fallback = True
                    # RU-005-S1: ë¹„ì¦ˆë‹ˆìŠ¤ ë£° ì‹¤íŒ¨ ë°°ì§€ë¥¼ ì •í™•íˆ ì„¤ì •í•˜ê³ 
                    # outputê³¼ ctx ë°°ì§€ë¥¼ ë™ê¸°í™”
                    failure_badges: list[ValidationBadge] = [ValidationBadge.SCHEMA_OK]
                    add_business_badges(biz_result, failure_badges)
                    ctx.output.agent_console.badges = failure_badges
                    ctx.badges = list(failure_badges)
                    return
                continue

            # ëª¨ë“  ê²€ì¦ í†µê³¼
            ctx.output = turn_output
            ctx.badges = [
                ValidationBadge.SCHEMA_OK,
                ValidationBadge.ECONOMY_OK,
                ValidationBadge.SAFETY_OK,
                ValidationBadge.CONSISTENCY_OK,
            ]
            ctx.repair_attempts = repair_attempt
            return

        except Exception:
            repair_attempt += 1
            ctx.repair_attempts = repair_attempt
            if repair_attempt > MAX_REPAIR_ATTEMPTS:
                # ìµœì¢… ì‹¤íŒ¨ ì‹œ í´ë°± (RULE-004, RU-005-S1)
                ctx.output = create_safe_fallback(
                    language=ctx.turn_input.language,
                    economy_snapshot=ctx.economy_snapshot,
                    repair_count=repair_attempt,
                )
                ctx.is_fallback = True
                # RU-005-S1: í´ë°±ì˜ ë°°ì§€ë¥¼ ìŠ¤íŠ¸ë¦¼ ì´ë²¤íŠ¸ì™€ ë™ê¸°í™”
                ctx.badges = list(ctx.output.agent_console.badges)
                return
            continue

    # ë£¨í”„ ì¢…ë£Œ ì‹œì—ë„ í´ë°± (RU-005-S1)
    ctx.output = create_safe_fallback(
        language=ctx.turn_input.language,
        economy_snapshot=ctx.economy_snapshot,
        repair_count=repair_attempt,
    )
    ctx.is_fallback = True
    # RU-005-S1: í´ë°±ì˜ ë°°ì§€ë¥¼ ìŠ¤íŠ¸ë¦¼ ì´ë²¤íŠ¸ì™€ ë™ê¸°í™”
    ctx.badges = list(ctx.output.agent_console.badges)


async def _validate_real(ctx: PipelineContext, emit: EmitFn) -> None:
    """Real ëª¨ë“œ ê²€ì¦ì„ ìˆ˜í–‰í•©ë‹ˆë‹¤ (Gemini API + Repair loop)."""
    result = await run_repair_loop(ctx.turn_input)

    # Repair ì´ë²¤íŠ¸ ì†¡ì¶œ (ì‹œë„ê°€ ìˆì—ˆë‹¤ë©´)
    for i in range(result.repair_attempts):
        message = result.error_messages[i] if i < len(result.error_messages) else ""
        await emit(
            PipelineEvent(
                event_type=PipelineEventType.REPAIR,
                repair_attempt=i + 1,
                repair_message=message[:100] if message else None,
            )
        )
        if message:
            ctx.repair_messages.append(message[:100])

    ctx.output = result.output
    ctx.badges = list(result.badges)
    ctx.repair_attempts = result.repair_attempts
    ctx.is_fallback = result.is_fallback
</file>

<file path="backend/src/unknown_world/services/image_postprocess.py">
"""Unknown World - ì´ë¯¸ì§€ í›„ì²˜ë¦¬ ì„œë¹„ìŠ¤ (rembg ë°°ê²½ ì œê±°).

ì´ ëª¨ë“ˆì€ rembgë¥¼ ì‚¬ìš©í•˜ì—¬ ìƒì„±ëœ ì´ë¯¸ì§€ì˜ ë°°ê²½ì„ ì œê±°í•˜ëŠ” í›„ì²˜ë¦¬ ì„œë¹„ìŠ¤ì…ë‹ˆë‹¤.
ì´ë¯¸ì§€ ìœ í˜• íŒíŠ¸ì— ë”°ë¼ ìµœì ì˜ ëª¨ë¸ì„ ìë™ ì„ íƒí•©ë‹ˆë‹¤.

ì„¤ê³„ ì›ì¹™:
    - RULE-004: ì‹¤íŒ¨ ì‹œ ì•ˆì „í•œ í´ë°± ì œê³µ (ì›ë³¸ ì´ë¯¸ì§€ ë°˜í™˜)
    - RULE-008: í…ìŠ¤íŠ¸ ìš°ì„  + Lazy ì´ë¯¸ì§€ ì›ì¹™
    - Q1 ê²°ì •: Option A (ë™ê¸° ì²˜ë¦¬)
    - Q2 ê²°ì •: Option B (íŒíŠ¸ ê¸°ë°˜ ìë™ ëª¨ë¸ ì„ íƒ)
    - U-045: preflight ìƒíƒœ ì°¸ì¡° â†’ ë¯¸ì¤€ë¹„ ì‹œ ì¦‰ì‹œ ì›ë³¸ ë°˜í™˜ (ìš”ì²­ ì¤‘ ë‹¤ìš´ë¡œë“œ ì°¨ë‹¨)

ì°¸ì¡°:
    - vibe/ref/rembg-guide.md (ëª¨ë¸ ì„ íƒ/ì˜µì…˜ ê°€ì´ë“œ SSOT)
    - vibe/unit-plans/U-035[Mvp].md
    - vibe/unit-plans/U-045[Mvp].md
    - vibe/tech-stack.md (rembg ë²„ì „ ê³ ì •)
"""

from __future__ import annotations

import hashlib
import logging
import subprocess
from dataclasses import dataclass
from datetime import UTC, datetime
from enum import StrEnum
from pathlib import Path

from pydantic import BaseModel, ConfigDict, Field

from unknown_world.services.rembg_preflight import is_rembg_available as preflight_is_available

# =============================================================================
# ë¡œê±° ì„¤ì •
# =============================================================================

logger = logging.getLogger(__name__)


# =============================================================================
# ìƒìˆ˜ ì •ì˜ (rembg-guide.md ê¸°ì¤€)
# =============================================================================


class RembgModel(StrEnum):
    """rembg ì§€ì› ëª¨ë¸ (vibe/ref/rembg-guide.md ê¸°ì¤€).

    ëª¨ë¸ ì„ íƒ ìš°ì„ ìˆœìœ„:
    1. ì‚¬ìš©ìê°€ ëª¨ë¸ ëª…ì‹œ â†’ í•´ë‹¹ ëª¨ë¸ ì‚¬ìš©
    2. UI ì•„ì´ì½˜/ë¡œê³ /í”½ì…€ ì•„íŠ¸ â†’ birefnet-general
    3. ì œí’ˆ/ì˜¤ë¸Œì íŠ¸/ì¼ë°˜ ì‚¬ë¬¼ â†’ birefnet-general
    4. ì‹¤ì‚¬ ì¸ë¬¼/ì‚¬ì§„ â†’ birefnet-portrait + -a
    5. ì¼ë³¸ ì• ë‹ˆë©”ì´ì…˜ ìŠ¤íƒ€ì¼ ìºë¦­í„° â†’ isnet-anime
    6. ì†ë„ ìš°ì„  â†’ u2netp
    7. ë¶ˆëª…í™• â†’ birefnet-general (ê¸°ë³¸ê°’)
    """

    # ë²”ìš©/ê¸°ë³¸
    BIREFNET_GENERAL = "birefnet-general"
    """ì œí’ˆ/ì˜¤ë¸Œì íŠ¸/UI ì•„ì´ì½˜/ì¼ë°˜ (ê¸°ë³¸ê°’)"""

    ISNET_GENERAL_USE = "isnet-general-use"
    """ë²”ìš©/ê°œì„ ëœ í’ˆì§ˆ"""

    # ì¸ë¬¼
    BIREFNET_PORTRAIT = "birefnet-portrait"
    """ì‹¤ì‚¬ ì¸ë¬¼ ì´ˆìƒí™”/ì…€ì¹´/í”„ë¡œí•„"""

    U2NET_HUMAN_SEG = "u2net_human_seg"
    """ì¸ë¬¼ ì „ì‹ /ë‹¨ì²´ ì‚¬ì§„"""

    # ìºë¦­í„°/ì¼ëŸ¬ìŠ¤íŠ¸
    ISNET_ANIME = "isnet-anime"
    """ì¼ë³¸ ì• ë‹ˆë©”ì´ì…˜ ìºë¦­í„° (ëª…í™•í•œ ê²½ìš°ë§Œ)"""

    # íŠ¹ìˆ˜
    BIREFNET_DIS = "birefnet-dis"
    """ë³µì¡í•œ ë°°ê²½/ê³ í•´ìƒë„"""

    BIREFNET_MASSIVE = "birefnet-massive"
    """ìµœê³  í’ˆì§ˆ í•„ìš”"""

    U2NET_CLOTH_SEG = "u2net_cloth_seg"
    """ì˜ë¥˜/íŒ¨ì…˜/ì˜·"""

    # ì†ë„/ê²½ëŸ‰
    U2NETP = "u2netp"
    """ì†ë„ ìš°ì„ /ëŒ€ëŸ‰ ì²˜ë¦¬"""

    SILUETA = "silueta"
    """ê²½ëŸ‰/ì €ì‚¬ì–‘"""


# ì´ë¯¸ì§€ ìœ í˜• â†’ ëª¨ë¸ ë§¤í•‘ (rembg-guide.md ê¸°ì¤€)
IMAGE_TYPE_MODEL_MAP: dict[str, tuple[RembgModel, bool]] = {
    # (ëª¨ë¸, alpha_matting ì‚¬ìš© ì—¬ë¶€)
    "icon": (RembgModel.BIREFNET_GENERAL, False),
    "logo": (RembgModel.BIREFNET_GENERAL, False),
    "pixel_art": (RembgModel.BIREFNET_GENERAL, False),
    "ui": (RembgModel.BIREFNET_GENERAL, False),
    "asset": (RembgModel.BIREFNET_GENERAL, False),
    "object": (RembgModel.BIREFNET_GENERAL, False),
    "product": (RembgModel.BIREFNET_GENERAL, False),
    "item": (RembgModel.BIREFNET_GENERAL, False),
    "character": (RembgModel.ISNET_ANIME, False),
    "anime": (RembgModel.ISNET_ANIME, False),
    "illustration": (RembgModel.ISNET_ANIME, False),
    "portrait": (RembgModel.BIREFNET_PORTRAIT, True),
    "selfie": (RembgModel.BIREFNET_PORTRAIT, True),
    "human": (RembgModel.U2NET_HUMAN_SEG, True),
    "person": (RembgModel.U2NET_HUMAN_SEG, True),
    "clothing": (RembgModel.U2NET_CLOTH_SEG, False),
    "fashion": (RembgModel.U2NET_CLOTH_SEG, False),
    "complex": (RembgModel.BIREFNET_DIS, False),
    "detailed": (RembgModel.BIREFNET_DIS, False),
    "best_quality": (RembgModel.BIREFNET_MASSIVE, False),
    "fast": (RembgModel.U2NETP, False),
}

# ê¸°ë³¸ ì„¤ì •
DEFAULT_MODEL = RembgModel.BIREFNET_GENERAL
DEFAULT_ALPHA_MATTING = False


# =============================================================================
# ê²°ê³¼ íƒ€ì… ì •ì˜
# =============================================================================


class BackgroundRemovalStatus(StrEnum):
    """ë°°ê²½ ì œê±° ìƒíƒœ."""

    SUCCESS = "success"
    """ë°°ê²½ ì œê±° ì„±ê³µ"""

    FAILED = "failed"
    """ë°°ê²½ ì œê±° ì‹¤íŒ¨ (ì›ë³¸ ë°˜í™˜)"""

    SKIPPED = "skipped"
    """ë°°ê²½ ì œê±° ê±´ë„ˆëœ€ (ë¹„í™œì„±í™”)"""


class BackgroundRemovalResult(BaseModel):
    """ë°°ê²½ ì œê±° ê²°ê³¼.

    Attributes:
        status: ì²˜ë¦¬ ìƒíƒœ
        output_path: ì¶œë ¥ íŒŒì¼ ê²½ë¡œ (ì„±ê³µ/ì‹¤íŒ¨ ì‹œ ëª¨ë‘ ì¡´ì¬)
        original_path: ì›ë³¸ íŒŒì¼ ê²½ë¡œ
        model_used: ì‚¬ìš©ëœ rembg ëª¨ë¸
        alpha_matting: alpha matting ì‚¬ìš© ì—¬ë¶€
        processing_time_ms: ì²˜ë¦¬ ì‹œê°„ (ë°€ë¦¬ì´ˆ)
        message: ìƒíƒœ ë©”ì‹œì§€
    """

    model_config = ConfigDict(extra="forbid")

    status: BackgroundRemovalStatus
    output_path: Path
    original_path: Path
    model_used: str | None = Field(default=None)
    alpha_matting: bool = Field(default=False)
    processing_time_ms: int = Field(default=0)
    message: str | None = Field(default=None)


@dataclass
class RembgConfig:
    """rembg ì²˜ë¦¬ ì„¤ì •.

    Attributes:
        model: ì‚¬ìš©í•  ëª¨ë¸
        alpha_matting: alpha matting ì‚¬ìš© ì—¬ë¶€
        output_suffix: ì¶œë ¥ íŒŒì¼ ì ‘ë¯¸ì‚¬
    """

    model: RembgModel = DEFAULT_MODEL
    alpha_matting: bool = DEFAULT_ALPHA_MATTING
    output_suffix: str = "_nobg"


# =============================================================================
# í—¬í¼ í•¨ìˆ˜
# =============================================================================


def select_model_from_hint(image_type_hint: str | None) -> tuple[RembgModel, bool]:
    """ì´ë¯¸ì§€ ìœ í˜• íŒíŠ¸ë¡œë¶€í„° ìµœì ì˜ rembg ëª¨ë¸ì„ ì„ íƒí•©ë‹ˆë‹¤.

    Args:
        image_type_hint: ì´ë¯¸ì§€ ìœ í˜• íŒíŠ¸ (ì˜ˆ: "object", "character", "icon")

    Returns:
        (ëª¨ë¸, alpha_matting ì‚¬ìš© ì—¬ë¶€) íŠœí”Œ
    """
    if not image_type_hint:
        return DEFAULT_MODEL, DEFAULT_ALPHA_MATTING

    # íŒíŠ¸ë¥¼ ì†Œë¬¸ìë¡œ ì •ê·œí™”
    hint_lower = image_type_hint.lower().strip()

    # ì§ì ‘ ë§¤ì¹­
    if hint_lower in IMAGE_TYPE_MODEL_MAP:
        return IMAGE_TYPE_MODEL_MAP[hint_lower]

    # í‚¤ì›Œë“œ í¬í•¨ ê²€ìƒ‰
    for keyword, (model, alpha) in IMAGE_TYPE_MODEL_MAP.items():
        if keyword in hint_lower:
            return model, alpha

    # ê¸°ë³¸ê°’ ë°˜í™˜
    logger.debug(
        "[Rembg] ì•Œ ìˆ˜ ì—†ëŠ” ì´ë¯¸ì§€ ìœ í˜•, ê¸°ë³¸ ëª¨ë¸ ì‚¬ìš©",
        extra={"hint": image_type_hint, "default_model": DEFAULT_MODEL},
    )
    return DEFAULT_MODEL, DEFAULT_ALPHA_MATTING


def _create_output_path(input_path: Path, suffix: str = "_nobg") -> Path:
    """ì¶œë ¥ íŒŒì¼ ê²½ë¡œë¥¼ ìƒì„±í•©ë‹ˆë‹¤.

    Args:
        input_path: ì…ë ¥ íŒŒì¼ ê²½ë¡œ
        suffix: íŒŒì¼ëª… ì ‘ë¯¸ì‚¬

    Returns:
        ì¶œë ¥ íŒŒì¼ ê²½ë¡œ
    """
    stem = input_path.stem
    return input_path.parent / f"{stem}{suffix}.png"


# =============================================================================
# ë©”ì¸ ì„œë¹„ìŠ¤ í´ë˜ìŠ¤
# =============================================================================


class ImagePostprocessor:
    """ì´ë¯¸ì§€ í›„ì²˜ë¦¬ ì„œë¹„ìŠ¤ (rembg ë°°ê²½ ì œê±°).

    rembg CLIë¥¼ ì‚¬ìš©í•˜ì—¬ ì´ë¯¸ì§€ ë°°ê²½ì„ ì œê±°í•©ë‹ˆë‹¤.
    ì‹¤íŒ¨ ì‹œ ì›ë³¸ ì´ë¯¸ì§€ë¥¼ ë°˜í™˜í•˜ëŠ” ì•ˆì „ í´ë°±ì„ ì œê³µí•©ë‹ˆë‹¤ (RULE-004).
    """

    def __init__(self, timeout_seconds: int = 60) -> None:
        """ImagePostprocessorë¥¼ ì´ˆê¸°í™”í•©ë‹ˆë‹¤.

        Args:
            timeout_seconds: rembg ì‹¤í–‰ íƒ€ì„ì•„ì›ƒ (ì´ˆ)
        """
        self._timeout = timeout_seconds
        self._available: bool | None = None

    def is_available(self) -> bool:
        """rembgê°€ ì‹œìŠ¤í…œì— ì„¤ì¹˜ë˜ì–´ ìˆëŠ”ì§€ í™•ì¸í•©ë‹ˆë‹¤."""
        if self._available is not None:
            return self._available

        try:
            result = subprocess.run(
                ["rembg", "--version"],
                capture_output=True,
                text=True,
                timeout=5,
            )
            self._available = result.returncode == 0
            if self._available:
                logger.info(
                    "[Rembg] rembg ì‚¬ìš© ê°€ëŠ¥",
                    extra={"version": result.stdout.strip()},
                )
            else:
                logger.warning("[Rembg] rembg ë²„ì „ í™•ì¸ ì‹¤íŒ¨")
        except FileNotFoundError:
            logger.warning("[Rembg] rembgê°€ ì„¤ì¹˜ë˜ì–´ ìˆì§€ ì•ŠìŠµë‹ˆë‹¤")
            self._available = False
        except Exception as e:
            logger.warning(
                "[Rembg] rembg í™•ì¸ ì¤‘ ì˜¤ë¥˜",
                extra={"error_type": type(e).__name__},
            )
            self._available = False

        return self._available

    def remove_background(
        self,
        input_path: Path,
        image_type_hint: str | None = None,
        output_path: Path | None = None,
        config: RembgConfig | None = None,
    ) -> BackgroundRemovalResult:
        """ì´ë¯¸ì§€ì˜ ë°°ê²½ì„ ì œê±°í•©ë‹ˆë‹¤.

        Args:
            input_path: ì…ë ¥ ì´ë¯¸ì§€ íŒŒì¼ ê²½ë¡œ
            image_type_hint: ì´ë¯¸ì§€ ìœ í˜• íŒíŠ¸ (ëª¨ë¸ ìë™ ì„ íƒìš©)
            output_path: ì¶œë ¥ íŒŒì¼ ê²½ë¡œ (ê¸°ë³¸: ì…ë ¥íŒŒì¼_nobg.png)
            config: rembg ì„¤ì • (íŒíŠ¸ ëŒ€ì‹  ì§ì ‘ ì„¤ì •í•  ë•Œ ì‚¬ìš©)

        Returns:
            BackgroundRemovalResult: ì²˜ë¦¬ ê²°ê³¼
        """
        start_time = datetime.now(UTC)

        # ì…ë ¥ íŒŒì¼ ì¡´ì¬ í™•ì¸
        if not input_path.exists():
            return BackgroundRemovalResult(
                status=BackgroundRemovalStatus.FAILED,
                output_path=input_path,
                original_path=input_path,
                message=f"ì…ë ¥ íŒŒì¼ì´ ì¡´ì¬í•˜ì§€ ì•ŠìŠµë‹ˆë‹¤: {input_path}",
            )

        # ì¶œë ¥ ê²½ë¡œ ì„¤ì •
        if output_path is None:
            output_path = _create_output_path(input_path)

        # ëª¨ë¸/ì˜µì…˜ ê²°ì •
        if config is not None:
            model = config.model
            alpha_matting = config.alpha_matting
        else:
            model, alpha_matting = select_model_from_hint(image_type_hint)

        # U-045: preflight ìƒíƒœ í™•ì¸ (ìš”ì²­ ì¤‘ ë‹¤ìš´ë¡œë“œ ì°¨ë‹¨)
        # preflightê°€ ì‹¤íŒ¨/ë¯¸ì™„ë£Œì¸ ê²½ìš° ì¦‰ì‹œ ì›ë³¸ ë°˜í™˜
        if not preflight_is_available():
            logger.warning(
                "[Rembg] preflight ë¯¸ì™„ë£Œ ë˜ëŠ” ì‹¤íŒ¨, ì›ë³¸ ì´ë¯¸ì§€ ì‚¬ìš© (ìš”ì²­ ì¤‘ ë‹¤ìš´ë¡œë“œ ë°©ì§€)"
            )
            import shutil

            shutil.copy(input_path, output_path)
            return BackgroundRemovalResult(
                status=BackgroundRemovalStatus.FAILED,
                output_path=output_path,
                original_path=input_path,
                message="rembg preflightê°€ ì™„ë£Œë˜ì§€ ì•Šì•˜ìŠµë‹ˆë‹¤. ì›ë³¸ ì´ë¯¸ì§€ë¥¼ ì‚¬ìš©í•©ë‹ˆë‹¤.",
            )

        # rembg ì‚¬ìš© ê°€ëŠ¥ ì—¬ë¶€ í™•ì¸ (CLI ì‹¤í–‰ ê°€ëŠ¥ ì—¬ë¶€)
        if not self.is_available():
            # í´ë°±: ì›ë³¸ ë³µì‚¬
            logger.warning("[Rembg] rembg ë¯¸ì„¤ì¹˜, ì›ë³¸ ì´ë¯¸ì§€ ì‚¬ìš©")
            import shutil

            shutil.copy(input_path, output_path)
            return BackgroundRemovalResult(
                status=BackgroundRemovalStatus.FAILED,
                output_path=output_path,
                original_path=input_path,
                message="rembgê°€ ì„¤ì¹˜ë˜ì–´ ìˆì§€ ì•ŠìŠµë‹ˆë‹¤. ì›ë³¸ ì´ë¯¸ì§€ë¥¼ ì‚¬ìš©í•©ë‹ˆë‹¤.",
            )

        # ë¡œê·¸ìš© í•´ì‹œ ìƒì„± (íŒŒì¼ëª… ë…¸ì¶œ ìµœì†Œí™”)
        path_hash = hashlib.sha256(str(input_path).encode()).hexdigest()[:8]

        logger.debug(
            "[Rembg] ë°°ê²½ ì œê±° ì‹œì‘",
            extra={
                "path_hash": path_hash,
                "model": model,
                "alpha_matting": alpha_matting,
            },
        )

        try:
            # rembg CLI ëª…ë ¹ì–´ êµ¬ì„±
            cmd = ["rembg", "i", "-m", model]
            if alpha_matting:
                cmd.append("-a")
            cmd.extend([str(input_path), str(output_path)])

            # rembg ì‹¤í–‰
            result = subprocess.run(
                cmd,
                capture_output=True,
                text=True,
                timeout=self._timeout,
            )

            elapsed_ms = int((datetime.now(UTC) - start_time).total_seconds() * 1000)

            if result.returncode == 0 and output_path.exists():
                # íŒŒì¼ í¬ê¸° ì¸¡ì • (ì‹¤íŒ¨ ì‹œ 0)
                try:
                    output_size = output_path.stat().st_size
                except Exception:
                    output_size = 0

                logger.info(
                    "[Rembg] ë°°ê²½ ì œê±° ì™„ë£Œ",
                    extra={
                        "path_hash": path_hash,
                        "model": model,
                        "elapsed_ms": elapsed_ms,
                        "output_size": output_size,
                    },
                )
                return BackgroundRemovalResult(
                    status=BackgroundRemovalStatus.SUCCESS,
                    output_path=output_path,
                    original_path=input_path,
                    model_used=model,
                    alpha_matting=alpha_matting,
                    processing_time_ms=elapsed_ms,
                    message="ë°°ê²½ì´ ì„±ê³µì ìœ¼ë¡œ ì œê±°ë˜ì—ˆìŠµë‹ˆë‹¤.",
                )
            else:
                # ì‹¤íŒ¨ ì‹œ ì›ë³¸ ë³µì‚¬ (í´ë°±)
                logger.warning(
                    "[Rembg] ë°°ê²½ ì œê±° ì‹¤íŒ¨, ì›ë³¸ ì‚¬ìš©",
                    extra={
                        "path_hash": path_hash,
                        "returncode": result.returncode,
                        "stderr": result.stderr[:200] if result.stderr else None,
                    },
                )
                import shutil

                shutil.copy(input_path, output_path)
                return BackgroundRemovalResult(
                    status=BackgroundRemovalStatus.FAILED,
                    output_path=output_path,
                    original_path=input_path,
                    model_used=model,
                    processing_time_ms=elapsed_ms,
                    message=f"rembg ì‹¤í–‰ ì‹¤íŒ¨. ì›ë³¸ ì´ë¯¸ì§€ë¥¼ ì‚¬ìš©í•©ë‹ˆë‹¤. (exit: {result.returncode})",
                )

        except subprocess.TimeoutExpired:
            elapsed_ms = int((datetime.now(UTC) - start_time).total_seconds() * 1000)
            logger.error(
                "[Rembg] ë°°ê²½ ì œê±° íƒ€ì„ì•„ì›ƒ",
                extra={"path_hash": path_hash, "timeout": self._timeout},
            )
            # í´ë°±: ì›ë³¸ ë³µì‚¬
            import shutil

            shutil.copy(input_path, output_path)
            return BackgroundRemovalResult(
                status=BackgroundRemovalStatus.FAILED,
                output_path=output_path,
                original_path=input_path,
                model_used=model,
                processing_time_ms=elapsed_ms,
                message=f"rembg ì‹¤í–‰ íƒ€ì„ì•„ì›ƒ ({self._timeout}ì´ˆ). ì›ë³¸ ì´ë¯¸ì§€ë¥¼ ì‚¬ìš©í•©ë‹ˆë‹¤.",
            )

        except Exception as e:
            elapsed_ms = int((datetime.now(UTC) - start_time).total_seconds() * 1000)
            error_type = type(e).__name__
            logger.exception(
                "[Rembg] ë°°ê²½ ì œê±° ì¤‘ ì˜¤ë¥˜",
                extra={"path_hash": path_hash, "error_type": error_type},
            )
            # í´ë°±: ì›ë³¸ ë³µì‚¬
            import shutil

            try:
                shutil.copy(input_path, output_path)
            except Exception:
                output_path = input_path

            return BackgroundRemovalResult(
                status=BackgroundRemovalStatus.FAILED,
                output_path=output_path,
                original_path=input_path,
                processing_time_ms=elapsed_ms,
                message=f"ë°°ê²½ ì œê±° ì¤‘ ì˜¤ë¥˜ê°€ ë°œìƒí–ˆìŠµë‹ˆë‹¤: {error_type}. ì›ë³¸ ì´ë¯¸ì§€ë¥¼ ì‚¬ìš©í•©ë‹ˆë‹¤.",
            )


# =============================================================================
# ì‹±ê¸€í†¤ ì¸ìŠ¤í„´ìŠ¤
# =============================================================================

_postprocessor_instance: ImagePostprocessor | None = None


def get_image_postprocessor() -> ImagePostprocessor:
    """ImagePostprocessor ì‹±ê¸€í†¤ ì¸ìŠ¤í„´ìŠ¤ë¥¼ ë°˜í™˜í•©ë‹ˆë‹¤."""
    global _postprocessor_instance
    if _postprocessor_instance is None:
        _postprocessor_instance = ImagePostprocessor()
    return _postprocessor_instance


def reset_image_postprocessor() -> None:
    """í…ŒìŠ¤íŠ¸ìš© ì‹±ê¸€í†¤ ë¦¬ì…‹."""
    global _postprocessor_instance
    _postprocessor_instance = None


# =============================================================================
# í¸ì˜ í•¨ìˆ˜
# =============================================================================


async def remove_background_if_needed(
    image_path: Path,
    remove_background: bool,
    image_type_hint: str | None = None,
) -> Path:
    """ì¡°ê±´ë¶€ ë°°ê²½ ì œê±°ë¥¼ ìˆ˜í–‰í•˜ê³  ê²°ê³¼ ê²½ë¡œë¥¼ ë°˜í™˜í•©ë‹ˆë‹¤.

    Args:
        image_path: ì´ë¯¸ì§€ íŒŒì¼ ê²½ë¡œ
        remove_background: ë°°ê²½ ì œê±° ìˆ˜í–‰ ì—¬ë¶€
        image_type_hint: ì´ë¯¸ì§€ ìœ í˜• íŒíŠ¸

    Returns:
        ì²˜ë¦¬ëœ ì´ë¯¸ì§€ íŒŒì¼ ê²½ë¡œ (ë°°ê²½ ì œê±° ì•ˆ í•¨ ì‹œ ì›ë³¸ ê²½ë¡œ)
    """
    if not remove_background:
        return image_path

    postprocessor = get_image_postprocessor()
    result = postprocessor.remove_background(
        input_path=image_path,
        image_type_hint=image_type_hint,
    )

    # ì„±ê³µ/ì‹¤íŒ¨ ëª¨ë‘ output_path ë°˜í™˜ (í´ë°± í¬í•¨)
    return result.output_path
</file>

<file path="backend/src/unknown_world/storage/local_storage.py">
"""Unknown World - ë¡œì»¬ íŒŒì¼ ì‹œìŠ¤í…œ ìŠ¤í† ë¦¬ì§€ êµ¬í˜„.

MVP ë‹¨ê³„ì—ì„œ ì‚¬ìš©í•˜ëŠ” ë¡œì»¬ ì €ì¥ì†Œ êµ¬í˜„ì²´.
í˜ì–´ë§ ì§ˆë¬¸ Q1: Option A (backend/.data/ ì „ìš© í´ë”)

ì°¸ì¡°:
    - vibe/refactors/RU-006-Q4.md
    - vibe/refactors/RU-006-Q5.md
"""

from __future__ import annotations

import logging
import uuid
from datetime import UTC, datetime
from pathlib import Path

from unknown_world.storage.paths import (
    ARTIFACTS_SUBDIR,
    BASE_DATA_DIR,
    IMAGES_GENERATED_SUBDIR,
    IMAGES_UPLOADED_SUBDIR,
    STATIC_URL_PREFIX,
)
from unknown_world.storage.storage import (
    PutResult,
    StorageCategory,
    StorageInterface,
    StorageMetadata,
)

logger = logging.getLogger(__name__)

# ì¹´í…Œê³ ë¦¬ë³„ ì„œë¸Œë””ë ‰í† ë¦¬ ë§¤í•‘ (RU-006-Q5: paths.py ìƒìˆ˜ ì°¸ì¡°)
CATEGORY_DIRS: dict[StorageCategory, str] = {
    StorageCategory.GENERATED_IMAGE: IMAGES_GENERATED_SUBDIR,
    StorageCategory.UPLOADED_IMAGE: IMAGES_UPLOADED_SUBDIR,
    StorageCategory.ARTIFACT: ARTIFACTS_SUBDIR,
}


class LocalStorage(StorageInterface):
    """ë¡œì»¬ íŒŒì¼ ì‹œìŠ¤í…œ ìŠ¤í† ë¦¬ì§€.

    MVPì—ì„œ ì‚¬ìš©í•˜ëŠ” ë¡œì»¬ ì €ì¥ì†Œ êµ¬í˜„ì²´.
    """

    def __init__(self, base_dir: Path | None = None) -> None:
        """LocalStorageë¥¼ ì´ˆê¸°í™”í•©ë‹ˆë‹¤.

        Args:
            base_dir: ê¸°ë³¸ ì €ì¥ ë””ë ‰í† ë¦¬ (ê¸°ë³¸ê°’: .data)
        """
        self._base_dir = base_dir or BASE_DATA_DIR
        self._ensure_directories()

        logger.info(
            "[LocalStorage] ì´ˆê¸°í™” ì™„ë£Œ",
            extra={"base_dir": str(self._base_dir)},
        )

    def _ensure_directories(self) -> None:
        """ì¹´í…Œê³ ë¦¬ë³„ ë””ë ‰í† ë¦¬ë¥¼ ìƒì„±í•©ë‹ˆë‹¤."""
        for subdir in CATEGORY_DIRS.values():
            dir_path = self._base_dir / subdir
            dir_path.mkdir(parents=True, exist_ok=True)

    def _get_category_dir(self, category: StorageCategory) -> Path:
        """ì¹´í…Œê³ ë¦¬ì— í•´ë‹¹í•˜ëŠ” ë””ë ‰í† ë¦¬ ê²½ë¡œë¥¼ ë°˜í™˜í•©ë‹ˆë‹¤."""
        subdir = CATEGORY_DIRS.get(category, "misc")
        return self._base_dir / subdir

    def _generate_key(
        self,
        category: StorageCategory,
        file_id: str | None,
        extension: str = "png",
    ) -> str:
        """ìŠ¤í† ë¦¬ì§€ í‚¤ë¥¼ ìƒì„±í•©ë‹ˆë‹¤."""
        actual_id = file_id or f"file_{uuid.uuid4().hex[:12]}"
        subdir = CATEGORY_DIRS.get(category, "misc")
        return f"{subdir}/{actual_id}.{extension}"

    async def put(
        self,
        data: bytes,
        *,
        category: StorageCategory,
        content_type: str = "image/png",
        file_id: str | None = None,
        session_id: str | None = None,
    ) -> PutResult:
        """íŒŒì¼ì„ ì €ì¥í•©ë‹ˆë‹¤."""
        try:
            # í™•ì¥ì ì¶”ì¶œ
            ext_map = {
                "image/png": "png",
                "image/jpeg": "jpg",
                "image/gif": "gif",
                "image/webp": "webp",
                "application/json": "json",
            }
            extension = ext_map.get(content_type, "bin")

            # í‚¤ ë° ê²½ë¡œ ìƒì„±
            key = self._generate_key(category, file_id, extension)
            file_path = self._base_dir / key
            file_path.parent.mkdir(parents=True, exist_ok=True)

            # íŒŒì¼ ì €ì¥
            file_path.write_bytes(data)

            # URL ìƒì„±
            url = self.get_url(key)

            # ë©”íƒ€ë°ì´í„° ìƒì„±
            metadata = StorageMetadata(
                key=key,
                category=category,
                size_bytes=len(data),
                content_type=content_type,
                created_at=datetime.now(UTC),
                url=url,
                session_id=session_id,
            )

            logger.debug(
                "[LocalStorage] íŒŒì¼ ì €ì¥ ì™„ë£Œ",
                extra={
                    "key": key,
                    "size_bytes": len(data),
                    "category": category.value,
                },
            )

            return PutResult(
                success=True,
                key=key,
                url=url,
                metadata=metadata,
            )

        except Exception as e:
            error_msg = f"íŒŒì¼ ì €ì¥ ì‹¤íŒ¨: {type(e).__name__}"
            logger.error(
                "[LocalStorage] ì €ì¥ ì‹¤íŒ¨",
                extra={"error_type": type(e).__name__},
            )
            return PutResult(
                success=False,
                key="",
                url="",
                error=error_msg,
            )

    async def get(self, key: str) -> bytes | None:
        """íŒŒì¼ì„ ì¡°íšŒí•©ë‹ˆë‹¤."""
        file_path = self._base_dir / key
        if not file_path.exists():
            return None
        return file_path.read_bytes()

    async def exists(self, key: str) -> bool:
        """íŒŒì¼ ì¡´ì¬ ì—¬ë¶€ë¥¼ í™•ì¸í•©ë‹ˆë‹¤."""
        file_path = self._base_dir / key
        return file_path.exists()

    async def delete(self, key: str) -> bool:
        """íŒŒì¼ì„ ì‚­ì œí•©ë‹ˆë‹¤."""
        file_path = self._base_dir / key
        if not file_path.exists():
            return False
        file_path.unlink()
        return True

    def get_url(self, key: str) -> str:
        """íŒŒì¼ ì ‘ê·¼ URLì„ ë°˜í™˜í•©ë‹ˆë‹¤."""
        # ë¡œì»¬ í™˜ê²½ì—ì„œëŠ” /static í”„ë¦¬í”½ìŠ¤ë¡œ ì„œë¹™
        return f"{STATIC_URL_PREFIX}/{key}"

    @property
    def base_dir(self) -> Path:
        """ê¸°ë³¸ ì €ì¥ ë””ë ‰í† ë¦¬."""
        return self._base_dir
</file>

<file path="backend/src/unknown_world/validation/__init__.py">
"""Unknown World - ê²€ì¦ ëª¨ë“ˆ.

ë¹„ì¦ˆë‹ˆìŠ¤ ë£° ê²€ì¦ê¸° ë° ì–¸ì–´ í˜¼í•© ê²€ì¦ ê²Œì´íŠ¸ë¥¼ ì œê³µí•©ë‹ˆë‹¤.
"""

from unknown_world.validation.business_rules import (
    BusinessRuleError,
    BusinessRuleValidationResult,
    validate_business_rules,
)
from unknown_world.validation.language_gate import (
    MIXED_THRESHOLD_RATIO,
    LanguageGateResult,
    LanguageRatio,
    build_language_error_summary,
    is_language_mixed,
    measure_language_ratio,
    validate_language_consistency,
)

__all__ = [
    # Business Rules
    "BusinessRuleError",
    "BusinessRuleValidationResult",
    "validate_business_rules",
    # Language Gate (U-043)
    "MIXED_THRESHOLD_RATIO",
    "LanguageGateResult",
    "LanguageRatio",
    "build_language_error_summary",
    "is_language_mixed",
    "measure_language_ratio",
    "validate_language_consistency",
]
</file>

<file path="backend/tests/unit/orchestrator/test_prompt_loader.py">
"""Unit tests for prompt_loader.py.

U-036: í”„ë¡¬í”„íŠ¸ ë¡œë” í•«ë¦¬ë¡œë“œ í…ŒìŠ¤íŠ¸
U-046: XML íƒœê·¸ íŒŒì‹± + ë ˆê±°ì‹œ í´ë°± í…ŒìŠ¤íŠ¸
"""

from __future__ import annotations

import os
import unittest

from unknown_world.models.turn import Language
from unknown_world.orchestrator.prompt_loader import (
    _parse_frontmatter,
    _parse_legacy_frontmatter,
    _parse_xml_meta,
    clear_prompt_cache,
    is_hot_reload_enabled,
    load_prompt,
    load_prompt_with_metadata,
)


class TestPromptLoader(unittest.TestCase):
    def setUp(self) -> None:
        # Clear cache before each test
        clear_prompt_cache()
        # Backup environment
        self._old_env = os.environ.get("ENVIRONMENT")

    def tearDown(self) -> None:
        # Restore environment
        if self._old_env is None:
            if "ENVIRONMENT" in os.environ:
                del os.environ["ENVIRONMENT"]
        else:
            os.environ["ENVIRONMENT"] = self._old_env
        # Clear cache
        clear_prompt_cache()

    def test_load_prompt_ko(self) -> None:
        """Verify loading Korean prompt."""
        # This assumes the file exists in backend/prompts/system/game_master.ko.md
        prompt = load_prompt("system", "game_master", Language.KO)
        self.assertGreater(len(prompt), 0)
        self.assertIn("#", prompt)  # Should be markdown

    def test_load_prompt_en(self) -> None:
        """Verify loading English prompt."""
        prompt = load_prompt("system", "game_master", Language.EN)
        self.assertGreater(len(prompt), 0)

    def test_load_with_metadata(self) -> None:
        """Verify frontmatter parsing."""
        data = load_prompt_with_metadata("system", "game_master", Language.KO)
        self.assertIsNotNone(data.content)
        self.assertIsInstance(data.metadata, dict)
        # Check for typical metadata fields if they exist in the file
        if "prompt_id" in data.metadata:
            self.assertGreater(len(data.metadata["prompt_id"]), 0)

    def test_hot_reload_development(self) -> None:
        """Verify hot-reload works in development mode."""
        os.environ["ENVIRONMENT"] = "development"
        self.assertTrue(is_hot_reload_enabled())

        # Use a temporary file to test hot-reload
        test_category = "system"
        test_name = "test_hot_reload"
        test_lang = Language.KO

        # Determine prompt path
        # In prompt_loader.py, _PROMPTS_ROOT is Path(__file__).parent.parent.parent.parent / "prompts"
        # Since we are in tests/unit/orchestrator/, we need to find the prompts root.
        # But let's mock _get_prompt_path or just use an existing one if possible.
        # Actually, creating a real file is better for verifying "hot-reload" of file system.

        from unknown_world.orchestrator.prompt_loader import _PROMPTS_ROOT

        test_dir = _PROMPTS_ROOT / test_category
        test_dir.mkdir(parents=True, exist_ok=True)
        test_file = test_dir / f"{test_name}.ko.md"

        try:
            # Initial content
            test_file.write_text("# Test\n\nContent 1", encoding="utf-8")

            p1 = load_prompt(test_category, test_name, test_lang)
            self.assertIn("Content 1", p1)

            # Modify file
            test_file.write_text("# Test\n\nContent 2", encoding="utf-8")

            # Load again - should be updated in dev mode
            p2 = load_prompt(test_category, test_name, test_lang)
            self.assertIn("Content 2", p2)
            self.assertNotEqual(p1, p2)

        finally:
            if test_file.exists():
                test_file.unlink()

    def test_caching_production(self) -> None:
        """Verify caching works in production mode (no hot-reload)."""
        os.environ["ENVIRONMENT"] = "production"
        self.assertFalse(is_hot_reload_enabled())

        test_category = "system"
        test_name = "test_caching"
        test_lang = Language.KO

        from unknown_world.orchestrator.prompt_loader import _PROMPTS_ROOT

        test_dir = _PROMPTS_ROOT / test_category
        test_dir.mkdir(parents=True, exist_ok=True)
        test_file = test_dir / f"{test_name}.ko.md"

        try:
            # Initial content
            test_file.write_text("# Test\n\nInitial", encoding="utf-8")

            p1 = load_prompt(test_category, test_name, test_lang)
            self.assertIn("Initial", p1)

            # Modify file
            test_file.write_text("# Test\n\nModified", encoding="utf-8")

            # Load again - should STILL be Initial because of caching
            p2 = load_prompt(test_category, test_name, test_lang)
            self.assertEqual(p1, p2)
            self.assertIn("Initial", p2)

            # After clearing cache, it should be updated
            clear_prompt_cache()
            p3 = load_prompt(test_category, test_name, test_lang)
            self.assertIn("Modified", p3)

        finally:
            if test_file.exists():
                test_file.unlink()

    def test_fallback_language(self) -> None:
        """Verify fallback to other language if requested file is missing."""
        # Create ONLY English version
        test_category = "system"
        test_name = "test_fallback"

        from unknown_world.orchestrator.prompt_loader import _PROMPTS_ROOT

        test_dir = _PROMPTS_ROOT / test_category
        test_dir.mkdir(parents=True, exist_ok=True)
        en_file = test_dir / f"{test_name}.en.md"
        ko_file = test_dir / f"{test_name}.ko.md"

        try:
            en_file.write_text("# English Content", encoding="utf-8")
            if ko_file.exists():
                ko_file.unlink()

            # Request KO, should get EN
            prompt = load_prompt(test_category, test_name, Language.KO)
            self.assertIn("English Content", prompt)

        finally:
            if en_file.exists():
                en_file.unlink()


class TestXmlParsing(unittest.TestCase):
    """U-046: XML íƒœê·¸ íŒŒì‹± í…ŒìŠ¤íŠ¸."""

    def test_parse_xml_meta_valid(self) -> None:
        """Valid XML meta tags should be parsed correctly."""
        text = """<prompt_meta>
  <prompt_id>test_prompt</prompt_id>
  <language>ko-KR</language>
  <version>0.2.0</version>
  <last_updated>2026-01-28</last_updated>
  <policy_preset>default</policy_preset>
</prompt_meta>

<prompt_body>
## ëª©ì 
í…ŒìŠ¤íŠ¸ í”„ë¡¬í”„íŠ¸ì…ë‹ˆë‹¤.

## ë‚´ìš©
ë³¸ë¬¸ ë‚´ìš©ì´ ì—¬ê¸°ì— ë“¤ì–´ê°‘ë‹ˆë‹¤.
</prompt_body>
"""
        result = _parse_xml_meta(text)
        self.assertIsNotNone(result)
        metadata, content = result  # type: ignore

        # ë©”íƒ€ë°ì´í„° ê²€ì¦
        self.assertEqual(metadata["prompt_id"], "test_prompt")
        self.assertEqual(metadata["language"], "ko-KR")
        self.assertEqual(metadata["version"], "0.2.0")
        self.assertEqual(metadata["last_updated"], "2026-01-28")
        self.assertEqual(metadata["policy_preset"], "default")

        # ë³¸ë¬¸ ê²€ì¦ (ë©”íƒ€ ë¸”ë¡ ì œì™¸)
        self.assertIn("## ëª©ì ", content)
        self.assertIn("í…ŒìŠ¤íŠ¸ í”„ë¡¬í”„íŠ¸ì…ë‹ˆë‹¤.", content)
        self.assertNotIn("<prompt_meta>", content)
        self.assertNotIn("<prompt_body>", content)

    def test_parse_xml_meta_no_body_tag(self) -> None:
        """XML meta without body tag should use remaining text as content."""
        text = """<prompt_meta>
  <prompt_id>test</prompt_id>
  <version>0.1.0</version>
</prompt_meta>

## Content Section
This is the content without body tag.
"""
        result = _parse_xml_meta(text)
        self.assertIsNotNone(result)
        metadata, content = result  # type: ignore

        self.assertEqual(metadata["prompt_id"], "test")
        self.assertIn("## Content Section", content)

    def test_parse_xml_meta_returns_none_for_legacy(self) -> None:
        """Legacy format should return None from _parse_xml_meta."""
        text = """# [Prompt] Test

- prompt_id: legacy_test
- version: 0.1.0

## Content
Legacy content here.
"""
        result = _parse_xml_meta(text)
        self.assertIsNone(result)

    def test_parse_legacy_frontmatter(self) -> None:
        """Legacy frontmatter should be parsed correctly."""
        text = """# [Prompt] Test

- prompt_id: legacy_test
- language: en-US
- version: 0.1.0

## Content
Legacy content here.
"""
        metadata, content = _parse_legacy_frontmatter(text)

        self.assertEqual(metadata["prompt_id"], "legacy_test")
        self.assertEqual(metadata["language"], "en-US")
        self.assertEqual(metadata["version"], "0.1.0")
        self.assertIn("## Content", content)
        self.assertIn("Legacy content here.", content)

    def test_parse_frontmatter_prefers_xml(self) -> None:
        """_parse_frontmatter should prefer XML format when available."""
        xml_text = """<prompt_meta>
  <prompt_id>xml_test</prompt_id>
  <version>0.2.0</version>
</prompt_meta>

<prompt_body>
## XML Content
This is XML format.
</prompt_body>
"""
        metadata, content = _parse_frontmatter(xml_text)

        self.assertEqual(metadata["prompt_id"], "xml_test")
        self.assertEqual(metadata["version"], "0.2.0")
        self.assertIn("## XML Content", content)

    def test_parse_frontmatter_fallback_to_legacy(self) -> None:
        """_parse_frontmatter should fallback to legacy when XML is missing."""
        legacy_text = """# [Prompt] Test

- prompt_id: fallback_test
- version: 0.1.0

## Content
Fallback content.
"""
        metadata, content = _parse_frontmatter(legacy_text)

        self.assertEqual(metadata["prompt_id"], "fallback_test")
        self.assertIn("## Content", content)

    def test_load_prompt_with_xml_metadata(self) -> None:
        """Integration test: load_prompt_with_metadata with XML format."""
        # Load actual prompt file (migrated to XML format)
        data = load_prompt_with_metadata("system", "game_master", Language.KO)

        self.assertIsNotNone(data.content)
        self.assertIsInstance(data.metadata, dict)

        # Check metadata fields
        self.assertEqual(data.metadata.get("prompt_id"), "game_master_system")
        self.assertEqual(data.metadata.get("language"), "ko-KR")
        self.assertIn("version", data.metadata)

        # Content should not contain meta tags
        self.assertNotIn("<prompt_meta>", data.content)
        self.assertNotIn("<prompt_body>", data.content)
        self.assertIn("## ëª©ì ", data.content)

    def test_load_prompt_with_xml_metadata_en(self) -> None:
        """Integration test: English XML format."""
        data = load_prompt_with_metadata("system", "game_master", Language.EN)

        self.assertEqual(data.metadata.get("prompt_id"), "game_master_system")
        self.assertEqual(data.metadata.get("language"), "en-US")
        self.assertIn("## Purpose", data.content)


if __name__ == "__main__":
    unittest.main()
</file>

<file path="backend/tests/unit/services/test_genai_client.py">
import os
from unittest.mock import AsyncMock, MagicMock, patch

import pytest

from unknown_world.config.models import (
    MODEL_FAST,
    MODEL_IMAGE,
    MODEL_QUALITY,
    MODEL_VISION,
    ModelLabel,
    get_model_id,
)
from unknown_world.services.genai_client import (
    ENV_UW_MODE,
    GenAIClient,
    GenAIMode,
    GenerateRequest,
    GenerateResponse,
    MockGenAIClient,
    get_genai_client,
    reset_genai_client,
)


def test_model_id_mapping():
    """ModelLabelì´ tech-stack.mdì˜ IDì™€ ì˜¬ë°”ë¥´ê²Œ ë§¤í•‘ë˜ëŠ”ì§€ í™•ì¸í•©ë‹ˆë‹¤."""
    assert get_model_id(ModelLabel.FAST) == MODEL_FAST
    assert get_model_id(ModelLabel.QUALITY) == MODEL_QUALITY
    assert get_model_id(ModelLabel.IMAGE) == MODEL_IMAGE
    assert get_model_id(ModelLabel.VISION) == MODEL_VISION

    assert MODEL_FAST == "gemini-3-flash-preview"
    assert MODEL_QUALITY == "gemini-3-pro-preview"
    assert MODEL_IMAGE == "gemini-3-pro-image-preview"


def test_get_genai_client_mock_mode():
    """UW_MODE=mockì¼ ë•Œ MockGenAIClientê°€ ë°˜í™˜ë˜ëŠ”ì§€ í™•ì¸í•©ë‹ˆë‹¤."""
    reset_genai_client()
    with patch.dict(os.environ, {ENV_UW_MODE: "mock"}):
        client = get_genai_client(force_new=True)
        assert isinstance(client, MockGenAIClient)
        assert client.mode == GenAIMode.MOCK


@pytest.mark.asyncio
async def test_mock_client_generate():
    """MockGenAIClientì˜ generate ë©”ì„œë“œ ë™ì‘ì„ í™•ì¸í•©ë‹ˆë‹¤."""
    client = MockGenAIClient()
    request = GenerateRequest(prompt="test prompt", model_label=ModelLabel.FAST)
    response = await client.generate(request)

    assert isinstance(response, GenerateResponse)
    assert "[Mock Response]" in response.text
    assert response.model_label == ModelLabel.FAST
    assert "total_tokens" in response.usage


@pytest.mark.asyncio
async def test_mock_client_generate_stream():
    """MockGenAIClientì˜ generate_stream ë©”ì„œë“œ ë™ì‘ì„ í™•ì¸í•©ë‹ˆë‹¤."""
    client = MockGenAIClient()
    request = GenerateRequest(prompt="test prompt", model_label=ModelLabel.QUALITY)

    chunks = []
    async for chunk in client.generate_stream(request):
        chunks.append(chunk)

    assert len(chunks) > 0
    assert any(ModelLabel.QUALITY in c for c in chunks)


def test_singleton_pattern():
    """get_genai_clientê°€ ì‹±ê¸€í†¤ìœ¼ë¡œ ë™ì‘í•˜ëŠ”ì§€ í™•ì¸í•©ë‹ˆë‹¤."""
    reset_genai_client()
    with patch.dict(os.environ, {ENV_UW_MODE: "mock"}):
        client1 = get_genai_client()
        client2 = get_genai_client()
        assert client1 is client2


def test_genai_client_initialization():
    """GenAIClient(real)ê°€ SDKë¥¼ ì˜¬ë°”ë¥´ê²Œ ì´ˆê¸°í™”í•˜ëŠ”ì§€ í™•ì¸í•©ë‹ˆë‹¤."""
    with patch("google.genai.Client") as mock_genai_client:
        # VERTEX_PROJECTì™€ LOCATION ì„¤ì •
        project = "test-project"
        location = "global"

        client = GenAIClient(project=project, location=location)

        # genai.Clientê°€ vertexai=Trueì™€ í•¨ê»˜ í˜¸ì¶œë˜ì—ˆëŠ”ì§€ í™•ì¸
        mock_genai_client.assert_called_once()
        args, kwargs = mock_genai_client.call_args
        assert kwargs["vertexai"] is True
        assert kwargs["project"] == project
        assert kwargs["location"] == location
        assert client.is_available() is True


@pytest.mark.asyncio
async def test_genai_client_generate_real_call():
    """GenAIClientê°€ SDKì˜ generate_contentë¥¼ ì˜¬ë°”ë¥´ê²Œ í˜¸ì¶œí•˜ëŠ”ì§€ í™•ì¸í•©ë‹ˆë‹¤."""
    with patch("google.genai.Client") as mock_client_class:
        mock_instance = mock_client_class.return_value
        # mock aio.models.generate_content
        mock_response = MagicMock()
        mock_response.text = "Actual response"
        mock_response.candidates = [MagicMock(finish_reason="STOP")]
        mock_response.usage_metadata = MagicMock(
            prompt_token_count=10, candidates_token_count=20, total_token_count=30
        )

        mock_instance.aio.models.generate_content = AsyncMock(return_value=mock_response)

        client = GenAIClient(project="p", location="l")
        request = GenerateRequest(prompt="hello", model_label=ModelLabel.QUALITY, max_tokens=100)

        response = await client.generate(request)

        # í˜¸ì¶œ ì¸ì í™•ì¸
        mock_instance.aio.models.generate_content.assert_called_once_with(
            model=MODEL_QUALITY, contents="hello", config={"max_output_tokens": 100}
        )
        assert response.text == "Actual response"
        assert response.usage["total_tokens"] == 30


def test_genai_client_initialization_failure():
    """ì¸ì¦ ì˜¤ë¥˜ ë“±ìœ¼ë¡œ SDK ì´ˆê¸°í™” ì‹¤íŒ¨ ì‹œ ë™ì‘ì„ í™•ì¸í•©ë‹ˆë‹¤."""
    with patch("google.genai.Client", side_effect=Exception("Auth error")):
        client = GenAIClient()
        assert client.is_available() is False
        assert client.mode == GenAIMode.REAL


def test_get_genai_client_force_new():
    """force_new=Trueì¼ ë•Œ ìƒˆ ì¸ìŠ¤í„´ìŠ¤ê°€ ìƒì„±ë˜ëŠ”ì§€ í™•ì¸í•©ë‹ˆë‹¤."""
    reset_genai_client()
    with patch.dict(os.environ, {ENV_UW_MODE: "mock"}):
        client1 = get_genai_client()
        client2 = get_genai_client(force_new=True)
        assert client1 is not client2


@pytest.mark.asyncio
async def test_genai_client_generate_stream_real_call():
    """GenAIClientê°€ ìŠ¤íŠ¸ë¦¬ë° í˜¸ì¶œì„ ì˜¬ë°”ë¥´ê²Œ ìˆ˜í–‰í•˜ëŠ”ì§€ í™•ì¸í•©ë‹ˆë‹¤."""
    with patch("google.genai.Client") as mock_client_class:
        mock_instance = mock_client_class.return_value

        # mock aio.models.generate_content_stream
        async def mock_stream():
            yield MagicMock(text="chunk1")
            yield MagicMock(text="chunk2")

        mock_instance.aio.models.generate_content_stream = AsyncMock(return_value=mock_stream())

        client = GenAIClient(project="p", location="l")
        request = GenerateRequest(prompt="hello", model_label=ModelLabel.FAST)

        chunks = []
        async for chunk in client.generate_stream(request):
            chunks.append(chunk)

        assert chunks == ["chunk1", "chunk2"]
        mock_instance.aio.models.generate_content_stream.assert_called_once()


@pytest.mark.asyncio
async def test_genai_client_unavailable_raises_error():
    """ì‚¬ìš© ë¶ˆê°€ëŠ¥í•œ í´ë¼ì´ì–¸íŠ¸ í˜¸ì¶œ ì‹œ RuntimeErrorê°€ ë°œìƒí•˜ëŠ”ì§€ í™•ì¸í•©ë‹ˆë‹¤."""
    with patch("google.genai.Client", side_effect=Exception("Init error")):
        client = GenAIClient()
        assert client.is_available() is False

        request = GenerateRequest(prompt="hi")
        with pytest.raises(RuntimeError, match="ì´ˆê¸°í™”ë˜ì§€ ì•Šì•˜ìŠµë‹ˆë‹¤"):
            await client.generate(request)

        with pytest.raises(RuntimeError, match="ì´ˆê¸°í™”ë˜ì§€ ì•Šì•˜ìŠµë‹ˆë‹¤"):
            async for _ in client.generate_stream(request):
                pass


@pytest.mark.asyncio
async def test_genai_client_full_config():
    """max_tokensì™€ temperatureê°€ SDK í˜¸ì¶œ ì‹œ ì˜¬ë°”ë¥´ê²Œ ì „ë‹¬ë˜ëŠ”ì§€ í™•ì¸í•©ë‹ˆë‹¤."""
    with patch("google.genai.Client") as mock_client_class:
        mock_instance = mock_client_class.return_value
        mock_instance.aio.models.generate_content = AsyncMock(return_value=MagicMock(text="ok"))

        async def mock_stream():
            yield MagicMock(text="ok")

        mock_instance.aio.models.generate_content_stream = AsyncMock(return_value=mock_stream())

        client = GenAIClient(project="p")
        request = GenerateRequest(prompt="hi", max_tokens=50, temperature=0.7)

        # generate í˜¸ì¶œ ê²€ì¦
        await client.generate(request)
        mock_instance.aio.models.generate_content.assert_called_with(
            model=MODEL_FAST, contents="hi", config={"max_output_tokens": 50, "temperature": 0.7}
        )

        # generate_stream í˜¸ì¶œ ê²€ì¦
        async for _ in client.generate_stream(request):
            pass
        mock_instance.aio.models.generate_content_stream.assert_called_with(
            model=MODEL_FAST, contents="hi", config={"max_output_tokens": 50, "temperature": 0.7}
        )


def test_get_genai_client_real_init_failure_fallback():
    """ì‹¤ì œ í´ë¼ì´ì–¸íŠ¸ ì´ˆê¸°í™” ì‹¤íŒ¨ ì‹œ Mock í´ë¼ì´ì–¸íŠ¸ë¡œ í´ë°±ë˜ëŠ”ì§€ í™•ì¸í•©ë‹ˆë‹¤."""
    reset_genai_client()
    with (
        patch.dict(os.environ, {ENV_UW_MODE: "real"}),
        patch("unknown_world.services.genai_client.GenAIClient.is_available", return_value=False),
    ):
        client = get_genai_client(force_new=True)
        assert isinstance(client, MockGenAIClient)


def test_reset_genai_client():
    """reset_genai_clientê°€ ìºì‹œë¥¼ ì˜¬ë°”ë¥´ê²Œ ë¹„ìš°ëŠ”ì§€ í™•ì¸í•©ë‹ˆë‹¤."""
    reset_genai_client()
    with patch.dict(os.environ, {ENV_UW_MODE: "mock"}):
        client1 = get_genai_client()
        reset_genai_client()
        client2 = get_genai_client()
        assert client1 is not client2


def test_mock_client_is_available():
    """MockGenAIClientê°€ í•­ìƒ ì‚¬ìš© ê°€ëŠ¥í•œì§€ í™•ì¸í•©ë‹ˆë‹¤."""
    client = MockGenAIClient()
    assert client.is_available() is True


def test_get_genai_client_invalid_mode():
    """ìœ íš¨í•˜ì§€ ì•Šì€ UW_MODEì¼ ë•Œ ê¸°ë³¸ê°’(REAL)ìœ¼ë¡œ ë™ì‘í•˜ëŠ”ì§€ í™•ì¸í•©ë‹ˆë‹¤."""
    reset_genai_client()
    with (
        patch.dict(os.environ, {ENV_UW_MODE: "invalid"}),
        patch(
            "unknown_world.services.genai_client.GenAIClient", return_value=MagicMock()
        ) as mock_real,
    ):
        get_genai_client(force_new=True)
        mock_real.assert_called_once()


def test_get_genai_client_force_mock():
    """force_mock=Trueì¼ ë•Œ í™˜ê²½ë³€ìˆ˜ì™€ ë¬´ê´€í•˜ê²Œ Mock í´ë¼ì´ì–¸íŠ¸ë¥¼ ë°˜í™˜í•˜ëŠ”ì§€ í™•ì¸í•©ë‹ˆë‹¤."""
    reset_genai_client()
    with patch.dict(os.environ, {ENV_UW_MODE: "real"}):
        client = get_genai_client(force_mock=True, force_new=True)
        assert isinstance(client, MockGenAIClient)
</file>

<file path="backend/tests/unit/test_image_postprocess.py">
"""U-035[Mvp] ì´ë¯¸ì§€ í›„ì²˜ë¦¬ ì„œë¹„ìŠ¤ ë‹¨ìœ„ í…ŒìŠ¤íŠ¸.

ì´ í…ŒìŠ¤íŠ¸ëŠ” rembg ë°°ê²½ ì œê±° ë¡œì§ì˜ ëª¨ë¸ ì„ íƒ ë° í´ë°± ë™ì‘ì„ ê²€ì¦í•©ë‹ˆë‹¤.
"""

import unittest
from pathlib import Path
from unittest.mock import MagicMock, patch

from unknown_world.services.image_postprocess import (
    BackgroundRemovalStatus,
    ImagePostprocessor,
    RembgModel,
    _create_output_path,
    select_model_from_hint,
)


class TestImagePostprocess(unittest.TestCase):
    """ImagePostprocess ë‹¨ìœ„ í…ŒìŠ¤íŠ¸."""

    def test_select_model_from_hint(self) -> None:
        """íŒíŠ¸ì— ë”°ë¥¸ ëª¨ë¸ ì„ íƒ ë¡œì§ì„ í…ŒìŠ¤íŠ¸í•©ë‹ˆë‹¤."""
        # 1. ëª…í™•í•œ ë§¤ì¹­
        model, alpha = select_model_from_hint("object")
        self.assertEqual(model, RembgModel.BIREFNET_GENERAL)
        self.assertFalse(alpha)

        model, alpha = select_model_from_hint("character")
        self.assertEqual(model, RembgModel.ISNET_ANIME)
        self.assertFalse(alpha)

        model, alpha = select_model_from_hint("portrait")
        self.assertEqual(model, RembgModel.BIREFNET_PORTRAIT)
        self.assertTrue(alpha)

        # 2. ëŒ€ì†Œë¬¸ì ë° ê³µë°± ì²˜ë¦¬
        model, _ = select_model_from_hint("  ANIME  ")
        self.assertEqual(model, RembgModel.ISNET_ANIME)

        # 3. í‚¤ì›Œë“œ í¬í•¨ ê²€ìƒ‰
        model, _ = select_model_from_hint("game_item_icon")
        self.assertEqual(model, RembgModel.BIREFNET_GENERAL)

        # 4. ê¸°ë³¸ê°’ (ì•Œ ìˆ˜ ì—†ëŠ” íŒíŠ¸)
        model, alpha = select_model_from_hint("unknown_hint")
        self.assertEqual(model, RembgModel.BIREFNET_GENERAL)
        self.assertFalse(alpha)

        # 5. None ì²˜ë¦¬
        model, alpha = select_model_from_hint(None)
        self.assertEqual(model, RembgModel.BIREFNET_GENERAL)
        self.assertFalse(alpha)

    def test_create_output_path(self) -> None:
        """ì¶œë ¥ ê²½ë¡œ ìƒì„± ê·œì¹™ì„ í…ŒìŠ¤íŠ¸í•©ë‹ˆë‹¤."""
        input_path = Path("test/image.png")
        output_path = _create_output_path(input_path)
        self.assertEqual(output_path, Path("test/image_nobg.png"))

        input_path = Path("asset.jpg")
        output_path = _create_output_path(input_path, suffix="_clean")
        self.assertEqual(output_path, Path("asset_clean.png"))  # í™•ì¥ìëŠ” í•­ìƒ pngë¡œ ë³€í™˜

    @patch("unknown_world.services.image_postprocess.subprocess.run")
    def test_is_available_success(self, mock_run: MagicMock) -> None:
        """rembg ì„¤ì¹˜ í™•ì¸ ì„±ê³µ ì‹œë‚˜ë¦¬ì˜¤."""
        mock_run.return_value = MagicMock(returncode=0, stdout="rembg 2.0.67")

        processor = ImagePostprocessor()
        self.assertTrue(processor.is_available())
        mock_run.assert_called_with(
            ["rembg", "--version"], capture_output=True, text=True, timeout=5
        )

    @patch("unknown_world.services.image_postprocess.subprocess.run")
    def test_is_available_failure(self, mock_run: MagicMock) -> None:
        """rembg ë¯¸ì„¤ì¹˜ ë˜ëŠ” ì‹¤í–‰ ì‹¤íŒ¨ ì‹œë‚˜ë¦¬ì˜¤."""
        mock_run.side_effect = FileNotFoundError()

        processor = ImagePostprocessor()
        self.assertFalse(processor.is_available())

        @patch("shutil.copy")
        @patch("unknown_world.services.image_postprocess.preflight_is_available")
        @patch("unknown_world.services.image_postprocess.ImagePostprocessor.is_available")
        def test_remove_background_fallback(
            self,
            mock_available: MagicMock,
            mock_preflight_available: MagicMock,
            mock_copy: MagicMock,
        ) -> None:
            """rembg ì‚¬ìš© ë¶ˆê°€ ì‹œ ì›ë³¸ì„ ë³µì‚¬í•˜ëŠ” í´ë°± ì‹œë‚˜ë¦¬ì˜¤."""
            mock_preflight_available.return_value = True
            mock_available.return_value = False
            processor = ImagePostprocessor()

            input_path = Path("dummy.png")
            with patch.object(Path, "exists", return_value=True):
                result = processor.remove_background(input_path)

                self.assertEqual(result.status, BackgroundRemovalStatus.FAILED)
                self.assertEqual(result.output_path, Path("dummy_nobg.png"))
                mock_copy.assert_called_once()

        @patch("unknown_world.services.image_postprocess.preflight_is_available")
        @patch("unknown_world.services.image_postprocess.subprocess.run")
        @patch("unknown_world.services.image_postprocess.ImagePostprocessor.is_available")
        def test_remove_background_success(
            self,
            mock_available: MagicMock,
            mock_run: MagicMock,
            mock_preflight_available: MagicMock,
        ) -> None:
            """rembg ì‹¤í–‰ ì„±ê³µ ì‹œë‚˜ë¦¬ì˜¤."""
            mock_preflight_available.return_value = True
            mock_available.return_value = True
            mock_run.return_value = MagicMock(returncode=0)

            processor = ImagePostprocessor()
            input_path = Path("input.png")

            with patch.object(Path, "exists", side_effect=[True, True, True]):
                result = processor.remove_background(input_path, image_type_hint="character")
                self.assertEqual(result.status, BackgroundRemovalStatus.SUCCESS)
            self.assertEqual(result.model_used, RembgModel.ISNET_ANIME)
            # ëª…ë ¹ì–´ì— ëª¨ë¸ ì¸ìê°€ í¬í•¨ë˜ì—ˆëŠ”ì§€ í™•ì¸
            args, _ = mock_run.call_args
            self.assertIn(RembgModel.ISNET_ANIME, args[0])

    @patch("shutil.copy")
    @patch("unknown_world.services.image_postprocess.preflight_is_available")
    def test_remove_background_preflight_not_available(
        self, mock_preflight_available: MagicMock, mock_copy: MagicMock
    ) -> None:
        """U-045: preflightê°€ ì¤€ë¹„ë˜ì§€ ì•Šì•˜ì„ ë•Œ ì¦‰ì‹œ ì›ë³¸ì„ ë°˜í™˜í•˜ëŠ”ì§€ í…ŒìŠ¤íŠ¸í•©ë‹ˆë‹¤."""
        # preflight ë¯¸ì¤€ë¹„ ìƒíƒœ ì„¤ì •
        mock_preflight_available.return_value = False

        processor = ImagePostprocessor()
        input_path = Path("input.png")
        output_path = Path("output.png")

        with patch.object(Path, "exists", return_value=True):
            result = processor.remove_background(input_path, output_path=output_path)

            # ê²°ê³¼ê°€ FAILED(ë˜ëŠ” SKIPPED)ì´ê³  ë©”ì‹œì§€ì— preflight ê´€ë ¨ ë‚´ìš©ì´ í¬í•¨ë˜ì–´ì•¼ í•¨
            self.assertEqual(result.status, BackgroundRemovalStatus.FAILED)
            self.assertIn("preflight", result.message)
            # ì›ë³¸ì„ ê²°ê³¼ ê²½ë¡œë¡œ ë³µì‚¬í–ˆëŠ”ì§€ í™•ì¸
            mock_copy.assert_called_once_with(input_path, output_path)


if __name__ == "__main__":
    unittest.main()
</file>

<file path="frontend/public/ui/manifest.schema.json">
{
  "$schema": "http://json-schema.org/draft-07/schema#",
  "$id": "https://unknown-world.dev/schemas/ui-asset-manifest.json",
  "title": "UI Asset Manifest",
  "description": "nanobanana mcpë¡œ ì œì‘ëœ UI ì—ì…‹ì˜ ë§¤ë‹ˆí˜ìŠ¤íŠ¸ ìŠ¤í‚¤ë§ˆ",
  "type": "object",
  "required": ["version", "assets"],
  "additionalProperties": false,
  "properties": {
    "$schema": {
      "type": "string",
      "description": "JSON Schema ì°¸ì¡°"
    },
    "version": {
      "type": "string",
      "pattern": "^\\d+\\.\\d+\\.\\d+$",
      "description": "ë§¤ë‹ˆí˜ìŠ¤íŠ¸ ë²„ì „ (SemVer)",
      "examples": ["1.0.0"]
    },
    "generatedAt": {
      "type": "string",
      "format": "date-time",
      "description": "ë§¤ë‹ˆí˜ìŠ¤íŠ¸ ìƒì„± ì‹œê° (ISO 8601)"
    },
    "totalBytes": {
      "type": "integer",
      "minimum": 0,
      "description": "ëª¨ë“  ì—ì…‹ì˜ ì´ ë°”ì´íŠ¸ ìˆ˜"
    },
    "budgetBytes": {
      "type": "integer",
      "minimum": 0,
      "default": 1572864,
      "description": "ì„±ëŠ¥ ì˜ˆì‚° ìƒí•œ (ê¸°ë³¸: 1.5MB = 1572864 bytes)"
    },
    "assets": {
      "type": "array",
      "description": "ì—ì…‹ ëª©ë¡",
      "items": {
        "$ref": "#/$defs/Asset"
      }
    }
  },
  "$defs": {
    "Asset": {
      "type": "object",
      "required": ["id", "path", "type"],
      "additionalProperties": false,
      "properties": {
        "id": {
          "type": "string",
          "pattern": "^[a-z0-9]+(-[a-z0-9]+)*$",
          "description": "ì—ì…‹ ê³ ìœ  ID (kebab-case)",
          "examples": ["signal-24", "badge-ok-16", "scene-loading"]
        },
        "path": {
          "type": "string",
          "pattern": "^[a-z0-9-/]+\\.(png|webp|svg)$",
          "description": "ui/ ë””ë ‰í† ë¦¬ ê¸°ì¤€ ìƒëŒ€ ê²½ë¡œ",
          "examples": ["icons/signal-24.png", "placeholders/scene-loading.webp"]
        },
        "type": {
          "type": "string",
          "enum": ["icon", "placeholder", "chrome"],
          "description": "ì—ì…‹ ìœ í˜•"
        },
        "size": {
          "type": "integer",
          "enum": [16, 24, 32, 64, 128, 256, 512],
          "description": "í”½ì…€ ì‚¬ì´ì¦ˆ (ì•„ì´ì½˜ìš©)"
        },
        "width": {
          "type": "integer",
          "minimum": 1,
          "description": "ê°€ë¡œ í”½ì…€ (placeholder/chromeìš©)"
        },
        "height": {
          "type": "integer",
          "minimum": 1,
          "description": "ì„¸ë¡œ í”½ì…€ (placeholder/chromeìš©)"
        },
        "fallback": {
          "type": "string",
          "maxLength": 10,
          "description": "ë¡œë”© ì‹¤íŒ¨ ì‹œ ëŒ€ì²´ ì´ëª¨ì§€/í…ìŠ¤íŠ¸",
          "examples": ["ğŸ“¡", "âš ï¸", "OK"]
        },
        "usedIn": {
          "type": "array",
          "items": {
            "type": "string"
          },
          "description": "ì‚¬ìš©ì²˜ ì»´í¬ë„ŒíŠ¸ ëª©ë¡",
          "examples": [["EconomyHUD", "AgentConsole"]]
        },
        "bytes": {
          "type": "integer",
          "minimum": 0,
          "description": "íŒŒì¼ í¬ê¸° (bytes)"
        },
        "format": {
          "type": "string",
          "enum": ["png", "webp", "svg"],
          "description": "íŒŒì¼ í¬ë§·"
        },
        "retina": {
          "type": "boolean",
          "default": false,
          "description": "@2x Retina ë²„ì „ ì¡´ì¬ ì—¬ë¶€"
        },
        "description": {
          "type": "string",
          "maxLength": 200,
          "description": "ì—ì…‹ ì„¤ëª…"
        },
        "createdAt": {
          "type": "string",
          "format": "date-time",
          "description": "ìƒì„± ì‹œê° (ISO 8601)"
        },
        "promptHash": {
          "type": "string",
          "pattern": "^[a-f0-9]{8}$",
          "description": "ìƒì„± í”„ë¡¬í”„íŠ¸ í•´ì‹œ (ì¬í˜„ì„±, 8ì)"
        },
        "notes": {
          "type": "string",
          "maxLength": 500,
          "description": "ì—ì…‹ ê´€ë ¨ ë©”ëª¨ (ìƒì„± ë„êµ¬, ë°°ê²½ ì œê±°, ìµœì í™” ë“± QA ê´€ë ¨ ê¸°ë¡)"
        }
      }
    }
  }
}
</file>

<file path="frontend/src/api/scanner.ts">
/**
 * Unknown World - Scanner(ì´ë¯¸ì§€ ì´í•´) API í´ë¼ì´ì–¸íŠ¸.
 *
 * U-022[Mvp]: Scanner ìŠ¬ë¡¯ UIì—ì„œ ì´ë¯¸ì§€ ì—…ë¡œë“œ ì‹œ ë°±ì—”ë“œ `/api/scan` í˜¸ì¶œ.
 * U-021 ì˜ì¡´: ë°±ì—”ë“œ Scanner ì—”ë“œí¬ì¸íŠ¸ì™€ ì—°ë™.
 *
 * ì„¤ê³„ ì›ì¹™:
 *   - RULE-004: ì‹¤íŒ¨ ì‹œ ì•ˆì „í•œ í´ë°± (ì—ëŸ¬ ë©”ì‹œì§€ ë°˜í™˜)
 *   - RULE-007: íŒŒì¼ ë‚´ìš©/í”„ë¡¬í”„íŠ¸ ë¡œê¹… ê¸ˆì§€
 *   - RULE-009: bboxëŠ” 0~1000 ì •ê·œí™” + [ymin, xmin, ymax, xmax]
 *
 * @module api/scanner
 */

import { z } from 'zod';
import { Box2DSchema, type Language } from '../schemas/turn';

// =============================================================================
// ìƒìˆ˜
// =============================================================================

/** Scanner API ì—”ë“œí¬ì¸íŠ¸ ê¸°ë³¸ URL */
const SCANNER_API_BASE = '/api/scan';

/** ì§€ì›í•˜ëŠ” ì´ë¯¸ì§€ MIME íƒ€ì… */
export const ALLOWED_MIME_TYPES = ['image/jpeg', 'image/png', 'image/gif', 'image/webp'] as const;

/** ìµœëŒ€ íŒŒì¼ í¬ê¸° (20MB) */
export const MAX_FILE_SIZE_BYTES = 20 * 1024 * 1024;

// =============================================================================
// Zod ìŠ¤í‚¤ë§ˆ ì •ì˜ (ë°±ì—”ë“œ ì‘ë‹µê³¼ 1:1 ëŒ€ì‘)
// =============================================================================

/**
 * ìŠ¤ìº” ìƒíƒœ Enum.
 */
export const ScanStatusSchema = z.enum(['completed', 'partial', 'failed', 'blocked']);
export type ScanStatus = z.infer<typeof ScanStatusSchema>;

/**
 * ê°ì§€ëœ ì˜¤ë¸Œì íŠ¸.
 * RULE-009: bboxëŠ” 0~1000 ì •ê·œí™”.
 */
export const DetectedObjectSchema = z.object({
  label: z.string(),
  box_2d: Box2DSchema,
  confidence: z.number().min(0).max(1).nullable().optional(),
  suggested_item_type: z.string().nullable().optional(),
});
export type DetectedObject = z.infer<typeof DetectedObjectSchema>;

/**
 * ì•„ì´í…œ í›„ë³´.
 * ìŠ¤ìº” ê²°ê³¼ë¡œ ìƒì„±ë˜ëŠ” ê²Œì„ ì•„ì´í…œ í›„ë³´.
 */
export const ItemCandidateSchema = z.object({
  id: z.string(),
  label: z.string(),
  description: z.string().default(''),
  item_type: z.string().default('material'),
  source_object_index: z.number().int().min(0).nullable().optional(),
});
export type ItemCandidate = z.infer<typeof ItemCandidateSchema>;

/**
 * Scanner API ì‘ë‹µ.
 * RU-006-S1: original_image_key, original_image_url ì¶”ê°€
 */
export const ScannerResponseSchema = z.object({
  success: z.boolean(),
  status: ScanStatusSchema,
  caption: z.string().default(''),
  objects: z.array(DetectedObjectSchema).default([]),
  item_candidates: z.array(ItemCandidateSchema).default([]),
  message: z.string().nullable().optional(),
  analysis_time_ms: z.number().int().min(0).default(0),
  language: z.enum(['ko-KR', 'en-US']),
  original_image_key: z.string().nullable().optional(),
  original_image_url: z.string().nullable().optional(),
});
export type ScannerResponse = z.infer<typeof ScannerResponseSchema>;

// =============================================================================
// API í´ë¼ì´ì–¸íŠ¸ í•¨ìˆ˜
// =============================================================================

/**
 * ìŠ¤ìº” ê²°ê³¼ íƒ€ì….
 */
export type ScanResult =
  | { success: true; data: ScannerResponse }
  | { success: false; error: string; status: ScanStatus };

/**
 * ìŠ¤ìº” ì˜µì…˜.
 * RU-006-S1: preserve_original ì˜µì…˜ ì¶”ê°€
 */
export interface ScanOptions {
  /** ì›ë³¸ ì´ë¯¸ì§€ ì €ì¥ ì—¬ë¶€ (ë””ë²„ê¹…/ì¬ë¶„ì„ìš©) */
  preserveOriginal?: boolean;
  /** ì„¸ì…˜ ID (ì´ë¯¸ì§€ ê·¸ë£¹í™”ìš©) */
  sessionId?: string;
}

/**
 * ì´ë¯¸ì§€ë¥¼ ìŠ¤ìº”í•˜ì—¬ ì˜¤ë¸Œì íŠ¸ì™€ ì•„ì´í…œ í›„ë³´ë¥¼ ì¶”ì¶œí•©ë‹ˆë‹¤.
 *
 * @param file - ë¶„ì„í•  ì´ë¯¸ì§€ íŒŒì¼
 * @param language - ì‘ë‹µ ì–¸ì–´
 * @param options - ìŠ¤ìº” ì˜µì…˜ (RU-006-S1)
 * @returns ìŠ¤ìº” ê²°ê³¼
 */
export async function scanImage(
  file: File,
  language: Language,
  options?: ScanOptions,
): Promise<ScanResult> {
  // í´ë¼ì´ì–¸íŠ¸ ì¸¡ íŒŒì¼ ê²€ì¦
  const validationError = validateFile(file);
  if (validationError) {
    return {
      success: false,
      error: validationError,
      status: 'failed',
    };
  }

  // FormData ìƒì„±
  const formData = new FormData();
  formData.append('file', file);
  formData.append('language', language);

  // RU-006-S1: ì„ íƒì  íŒŒë¼ë¯¸í„° ì¶”ê°€
  if (options?.preserveOriginal) {
    formData.append('preserve_original', 'true');
  }
  if (options?.sessionId) {
    formData.append('session_id', options.sessionId);
  }

  try {
    const response = await fetch(SCANNER_API_BASE, {
      method: 'POST',
      body: formData,
    });

    if (!response.ok) {
      console.error('[ScannerAPI] HTTP error', {
        status: response.status,
        statusText: response.statusText,
      });
      return {
        success: false,
        error:
          language === 'ko-KR'
            ? `ì„œë²„ ì˜¤ë¥˜: ${response.status}`
            : `Server error: ${response.status}`,
        status: 'failed',
      };
    }

    const json = await response.json();
    const parseResult = ScannerResponseSchema.safeParse(json);

    if (!parseResult.success) {
      console.error('[ScannerAPI] Response validation failed', parseResult.error);
      return {
        success: false,
        error:
          language === 'ko-KR'
            ? 'ì‘ë‹µ ë°ì´í„° í˜•ì‹ì´ ì˜¬ë°”ë¥´ì§€ ì•ŠìŠµë‹ˆë‹¤.'
            : 'Invalid response data format.',
        status: 'failed',
      };
    }

    const data = parseResult.data;

    // ì„±ê³µ/ë¶€ë¶„ ì„±ê³µ ì—¬ë¶€ í™•ì¸
    if (data.status === 'completed' || data.status === 'partial') {
      return { success: true, data };
    }

    // ì‹¤íŒ¨/ì°¨ë‹¨ ì‘ë‹µ
    return {
      success: false,
      error: data.message ?? (language === 'ko-KR' ? 'ë¶„ì„ ì‹¤íŒ¨' : 'Analysis failed'),
      status: data.status,
    };
  } catch (error) {
    console.error('[ScannerAPI] Network error', { errorType: (error as Error).name });
    return {
      success: false,
      error:
        language === 'ko-KR'
          ? 'ë„¤íŠ¸ì›Œí¬ ì˜¤ë¥˜ê°€ ë°œìƒí–ˆìŠµë‹ˆë‹¤. ë‹¤ì‹œ ì‹œë„í•´ ì£¼ì„¸ìš”.'
          : 'Network error occurred. Please try again.',
      status: 'failed',
    };
  }
}

// =============================================================================
// ìœ í‹¸ë¦¬í‹° í•¨ìˆ˜
// =============================================================================

/**
 * íŒŒì¼ ìœ íš¨ì„± ê²€ì‚¬.
 *
 * @param file - ê²€ì¦í•  íŒŒì¼
 * @returns ì˜¤ë¥˜ ë©”ì‹œì§€ (ì—†ìœ¼ë©´ null)
 */
export function validateFile(file: File): string | null {
  // MIME íƒ€ì… ê²€ì¦
  if (!ALLOWED_MIME_TYPES.includes(file.type as (typeof ALLOWED_MIME_TYPES)[number])) {
    return `ì§€ì›í•˜ì§€ ì•ŠëŠ” íŒŒì¼ í˜•ì‹ì…ë‹ˆë‹¤: ${file.type || 'ì•Œ ìˆ˜ ì—†ìŒ'}`;
  }

  // íŒŒì¼ í¬ê¸° ê²€ì¦
  if (file.size > MAX_FILE_SIZE_BYTES) {
    const sizeMB = (file.size / (1024 * 1024)).toFixed(1);
    return `íŒŒì¼ì´ ë„ˆë¬´ í½ë‹ˆë‹¤: ${sizeMB}MB (ìµœëŒ€ 20MB)`;
  }

  return null;
}

/**
 * ì§€ì› íŒŒì¼ í˜•ì‹ì¸ì§€ í™•ì¸.
 *
 * @param file - í™•ì¸í•  íŒŒì¼
 * @returns ì§€ì› ì—¬ë¶€
 */
export function isSupportedImageFile(file: File): boolean {
  return ALLOWED_MIME_TYPES.includes(file.type as (typeof ALLOWED_MIME_TYPES)[number]);
}

/**
 * ItemCandidateë¥¼ InventoryItemìœ¼ë¡œ ë³€í™˜í•©ë‹ˆë‹¤.
 *
 * @param candidate - ì•„ì´í…œ í›„ë³´
 * @returns InventoryItem í˜•íƒœì˜ ê°ì²´
 */
export function candidateToInventoryItem(candidate: ItemCandidate) {
  return {
    id: candidate.id,
    name: candidate.label,
    description: candidate.description,
    icon: getItemTypeEmoji(candidate.item_type),
    quantity: 1,
  };
}

/**
 * ì•„ì´í…œ ìœ í˜•ì— ë”°ë¥¸ ì´ëª¨ì§€ ë°˜í™˜.
 *
 * @param itemType - ì•„ì´í…œ ìœ í˜•
 * @returns ì´ëª¨ì§€
 */
function getItemTypeEmoji(itemType: string): string {
  const emojiMap: Record<string, string> = {
    key: 'ğŸ”‘',
    weapon: 'âš”ï¸',
    tool: 'ğŸ”§',
    clue: 'ğŸ”',
    material: 'ğŸ“¦',
    consumable: 'ğŸ’Š',
    document: 'ğŸ“„',
    artifact: 'ğŸ’',
  };
  return emojiMap[itemType] ?? 'ğŸ“¦';
}
</file>

<file path="frontend/src/demo/demoFixtures.ts">
/**
 * Unknown World - ë°ëª¨ìš© Fixtures (RU-003-Q5)
 *
 * DEV í™˜ê²½ì—ì„œ ì‚¬ìš©í•˜ëŠ” ë°ëª¨ ì´ˆê¸° ë°ì´í„°ì…ë‹ˆë‹¤.
 * ì–¸ì–´ ì¤‘ë¦½ì ì¸ ê°’(ID/ì•„ì´ì½˜/ìˆ˜ëŸ‰/ì¢Œí‘œ)ë§Œ í¬í•¨í•˜ë©°,
 * í‘œì‹œ ë¬¸ìì—´(name/label/hint)ì€ i18n í‚¤ë¥¼ í†µí•´ ë Œë”ë§í•©ë‹ˆë‹¤.
 *
 * ì„¤ê³„ ì›ì¹™:
 *   - RULE-006: ko/en í˜¼í•© ì¶œë ¥ ê¸ˆì§€ (i18n í‚¤ ê¸°ë°˜)
 *   - PRD 6.9: ë°ëª¨ í”„ë¡œí•„ ê²½ê³„ í™•ë³´
 *   - ì„œë²„ TurnOutput ëŒ€ì²´ ì‹œ ì´ ëª¨ë“ˆ ë¹„í™œì„±í™” ê°€ëŠ¥
 *
 * @module demo/demoFixtures
 */

import type { Box2D } from '../schemas/turn';

// =============================================================================
// íƒ€ì… ì •ì˜
// =============================================================================

/**
 * ë°ëª¨ ì¸ë²¤í† ë¦¬ ì•„ì´í…œ ì •ì˜ (ì–¸ì–´ ì¤‘ë¦½)
 *
 * nameì€ i18n í‚¤(`demo.items.{id}.name`)ë¡œ ë Œë”ë§í•©ë‹ˆë‹¤.
 */
export interface DemoInventoryItemDef {
  /** ì•„ì´í…œ ê³ ìœ  ID */
  id: string;
  /** ì•„ì´í…œ ì•„ì´ì½˜ (ì´ëª¨ì§€ ë˜ëŠ” URL) */
  icon: string;
  /** ì´ˆê¸° ìˆ˜ëŸ‰ */
  quantity: number;
}

/**
 * ë°ëª¨ ì”¬ ì˜¤ë¸Œì íŠ¸ ì •ì˜ (ì–¸ì–´ ì¤‘ë¦½)
 *
 * label/hintëŠ” i18n í‚¤ë¡œ ë Œë”ë§í•©ë‹ˆë‹¤:
 * - labelKey: `demo.scene.{id}.label`
 * - hintKey: `demo.scene.{id}.hint`
 */
export interface DemoSceneObjectDef {
  /** ì˜¤ë¸Œì íŠ¸ ê³ ìœ  ID */
  id: string;
  /** ë°”ìš´ë”© ë°•ìŠ¤ (0~1000 ì •ê·œí™”) */
  box_2d: Box2D;
  /** i18n ë¼ë²¨ í‚¤ */
  labelKey: string;
  /** i18n íŒíŠ¸ í‚¤ */
  hintKey: string;
}

// =============================================================================
// ë°ëª¨ ì¸ë²¤í† ë¦¬ ì•„ì´í…œ
// =============================================================================

/**
 * ë°ëª¨ìš© ì¸ë²¤í† ë¦¬ ì•„ì´í…œ ëª©ë¡.
 *
 * @remarks
 * - ID/ì•„ì´ì½˜/ìˆ˜ëŸ‰ë§Œ ì •ì˜ (ì–¸ì–´ ì¤‘ë¦½)
 * - í‘œì‹œ ì´ë¦„ì€ `demo.items.{id}.name` í‚¤ë¡œ i18n ì²˜ë¦¬
 */
export const DEMO_INVENTORY_ITEMS: readonly DemoInventoryItemDef[] = [
  { id: 'keycard-alpha', icon: 'ğŸ”‘', quantity: 1 },
  { id: 'medkit', icon: 'ğŸ©¹', quantity: 2 },
  { id: 'flashlight', icon: 'ğŸ”¦', quantity: 1 },
  { id: 'data-chip', icon: 'ğŸ’¾', quantity: 3 },
] as const;

// =============================================================================
// ë°ëª¨ ì”¬ ì˜¤ë¸Œì íŠ¸
// =============================================================================

/**
 * ë°ëª¨ìš© ì”¬ ì˜¤ë¸Œì íŠ¸ ëª©ë¡.
 *
 * @remarks
 * - ID/ì¢Œí‘œë§Œ ì •ì˜ (ì–¸ì–´ ì¤‘ë¦½)
 * - í‘œì‹œ ë¼ë²¨/íŒíŠ¸ëŠ” i18n í‚¤ë¡œ ì²˜ë¦¬
 */
export const DEMO_SCENE_OBJECTS: readonly DemoSceneObjectDef[] = [
  {
    id: 'demo-terminal',
    box_2d: { ymin: 300, xmin: 100, ymax: 600, xmax: 400 },
    labelKey: 'demo.scene.terminal.label',
    hintKey: 'demo.scene.terminal.hint',
  },
  {
    id: 'demo-door',
    box_2d: { ymin: 200, xmin: 600, ymax: 800, xmax: 900 },
    labelKey: 'demo.scene.door.label',
    hintKey: 'demo.scene.door.hint',
  },
] as const;

// =============================================================================
// ë°ëª¨ í€˜ìŠ¤íŠ¸ (U-013)
// =============================================================================

/**
 * ë°ëª¨ í€˜ìŠ¤íŠ¸ ì •ì˜ (ì–¸ì–´ ì¤‘ë¦½)
 *
 * labelì€ i18n í‚¤(`demo.quest.{id}.label`)ë¡œ ë Œë”ë§í•©ë‹ˆë‹¤.
 */
export interface DemoQuestDef {
  /** í€˜ìŠ¤íŠ¸ ê³ ìœ  ID */
  id: string;
  /** i18n ë¼ë²¨ í‚¤ */
  labelKey: string;
  /** ì™„ë£Œ ì—¬ë¶€ */
  is_completed: boolean;
}

/**
 * ë°ëª¨ìš© í€˜ìŠ¤íŠ¸ ëª©ë¡.
 */
export const DEMO_QUESTS: readonly DemoQuestDef[] = [
  {
    id: 'demo-quest-terminal',
    labelKey: 'demo.quest.terminal.label',
    is_completed: false,
  },
  {
    id: 'demo-quest-escape',
    labelKey: 'demo.quest.escape.label',
    is_completed: false,
  },
  {
    id: 'demo-quest-collect',
    labelKey: 'demo.quest.collect.label',
    is_completed: true,
  },
] as const;

// =============================================================================
// ë°ëª¨ ê·œì¹™ (U-013)
// =============================================================================

/**
 * ë°ëª¨ ê·œì¹™ ì •ì˜ (ì–¸ì–´ ì¤‘ë¦½)
 *
 * label/descriptionì€ i18n í‚¤ë¡œ ë Œë”ë§í•©ë‹ˆë‹¤.
 */
export interface DemoRuleDef {
  /** ê·œì¹™ ê³ ìœ  ID */
  id: string;
  /** i18n ë¼ë²¨ í‚¤ */
  labelKey: string;
  /** i18n ì„¤ëª… í‚¤ (ì„ íƒ) */
  descriptionKey?: string;
}

/**
 * ë°ëª¨ìš© ê·œì¹™ ëª©ë¡.
 */
export const DEMO_RULES: readonly DemoRuleDef[] = [
  {
    id: 'demo-rule-gravity',
    labelKey: 'demo.rule.gravity.label',
    descriptionKey: 'demo.rule.gravity.description',
  },
  {
    id: 'demo-rule-time',
    labelKey: 'demo.rule.time.label',
    descriptionKey: 'demo.rule.time.description',
  },
] as const;

// =============================================================================
// í—¬í¼ í•¨ìˆ˜
// =============================================================================

/**
 * ë°ëª¨ ì¸ë²¤í† ë¦¬ ì•„ì´í…œì˜ i18n ì´ë¦„ í‚¤ë¥¼ ìƒì„±í•©ë‹ˆë‹¤.
 *
 * @param itemId - ì•„ì´í…œ ID
 * @returns i18n í‚¤ (ì˜ˆ: `demo.items.keycard-alpha.name`)
 */
export function getDemoItemNameKey(itemId: string): string {
  return `demo.items.${itemId}.name`;
}

/**
 * ë°ëª¨ í™˜ê²½ì¸ì§€ í™•ì¸í•©ë‹ˆë‹¤ (DEV ê°€ë“œ).
 *
 * @returns DEV í™˜ê²½ ì—¬ë¶€
 */
export function isDemoEnvironment(): boolean {
  return import.meta.env.DEV;
}

/**
 * DOMì—ì„œ í˜„ì¬ í…Œë§ˆë¥¼ ì½ìŠµë‹ˆë‹¤.
 *
 * RU-003-Q5: 'dark' í•˜ë“œì½”ë”© ì œê±°
 * - data-theme ì†ì„±ì„ í™•ì¸í•˜ì—¬ í…Œë§ˆ ê²°ì •
 * - 'crt', 'dark' ë˜ëŠ” ë¯¸ì§€ì • â†’ 'dark'
 * - 'light' â†’ 'light'
 *
 * @returns í˜„ì¬ í…Œë§ˆ ('dark' | 'light')
 */
export function getCurrentThemeFromDOM(): 'dark' | 'light' {
  const dataTheme = document.documentElement.getAttribute('data-theme');

  // 'crt' í…Œë§ˆëŠ” dark ê³„ì—´ë¡œ ì·¨ê¸‰
  if (dataTheme === 'light') {
    return 'light';
  }
  return 'dark';
}
</file>

<file path="frontend/src/dnd/types.ts">
/**
 * Unknown World - DnD íƒ€ì… ë° ìƒìˆ˜ ì •ì˜ (RU-003-Q1).
 *
 * DnD ë°ì´í„° ê³„ì•½ì„ SSOTë¡œ ê´€ë¦¬í•˜ì—¬ íƒ€ì… ì•ˆì „ì„±ì„ í™•ë³´í•©ë‹ˆë‹¤.
 * ëª¨ë“  ë“œë˜ê·¸/ë“œë¡­ ì´ë²¤íŠ¸ì—ì„œ ë™ì¼í•œ ìƒìˆ˜/íƒ€ì…ì„ ì‚¬ìš©í•©ë‹ˆë‹¤.
 *
 * ì„¤ê³„ ì›ì¹™:
 *   - SSOT: ë“œë˜ê·¸/ë“œë¡­ íƒ€ì… ë¬¸ìì—´ì€ ì´ ëª¨ë“ˆì—ì„œë§Œ ì •ì˜
 *   - íƒ€ì… ì•ˆì „ì„±: dnd-kitì˜ data.currentë¥¼ íƒ€ì… ê°€ë“œë¡œ ê²€ì¦
 *   - ê³¼ë„í•œ ì¶”ìƒí™” ê¸ˆì§€: ìƒìˆ˜/íƒ€ì…ë§Œ ì œê³µ, ë¡œì§ì€ ì»´í¬ë„ŒíŠ¸ì— ìœ ì§€
 *
 * @module dnd/types
 */

import type { Box2D } from '../schemas/turn';
import type { InventoryItem } from '../stores/inventoryStore';

// =============================================================================
// DnD íƒ€ì… ìƒìˆ˜ (SSOT)
// =============================================================================

/**
 * DnD íƒ€ì… ìƒìˆ˜.
 * ë“œë˜ê·¸/ë“œë¡­ ë°ì´í„°ì˜ type í•„ë“œì— ì‚¬ìš©ë©ë‹ˆë‹¤.
 */
export const DND_TYPE = {
  /** ì¸ë²¤í† ë¦¬ ì•„ì´í…œ ë“œë˜ê·¸ */
  INVENTORY_ITEM: 'inventory-item',
  /** í•«ìŠ¤íŒŸ ë“œë¡­ íƒ€ê²Ÿ */
  HOTSPOT: 'hotspot',
} as const;

// =============================================================================
// RU-003-S2: ì¸í„°ë™ì…˜ í—ˆìš© ì •ì±… (SSOT)
// =============================================================================

/**
 * í•«ìŠ¤íŒŸ ì¸í„°ë™ì…˜ì´ í—ˆìš©ë˜ëŠ” Scene ìƒíƒœ ëª©ë¡.
 *
 * RU-003-S2 Step 1: Option A(ë°ëª¨ ìœ ì§€) ê²°ì •
 * - 'scene': ì‹¤ì œ ì¥ë©´ í™œì„±í™” ìƒíƒœ
 * - 'default': ë°ëª¨/í”Œë ˆì´ìŠ¤í™€ë” ìƒíƒœ (ì‹œê°ì  íŒíŠ¸ í•„ìš”)
 *
 * @see SceneCanvas.tsxì˜ shouldRenderHotspots ì¡°ê±´
 */
export const HOTSPOT_INTERACTION_ALLOWED_STATES = ['scene', 'default'] as const;

/**
 * ì¸í„°ë™ì…˜ í—ˆìš© ìƒíƒœ íƒ€ì….
 */
export type HotspotInteractionState = (typeof HOTSPOT_INTERACTION_ALLOWED_STATES)[number];

/**
 * ì£¼ì–´ì§„ ìƒíƒœì—ì„œ í•«ìŠ¤íŒŸ ì¸í„°ë™ì…˜ì´ í—ˆìš©ë˜ëŠ”ì§€ ê²€ì‚¬í•©ë‹ˆë‹¤.
 *
 * RU-003-S2: ì¸í„°ë™ì…˜ ê°€ëŠ¥ ì¡°ê±´ì„ SSOTë¡œ ê³ ì •
 *
 * @param status - Scene ìƒíƒœ
 * @returns ì¸í„°ë™ì…˜ í—ˆìš© ì—¬ë¶€
 */
export function isHotspotInteractionAllowed(status: string): boolean {
  return HOTSPOT_INTERACTION_ALLOWED_STATES.includes(status as HotspotInteractionState);
}

// =============================================================================
// RU-003-S2 Step 4: ìŠ¤íŠ¸ë¦¬ë° ë¹„í™œì„±í™” ì •ì±… (SSOT)
// =============================================================================

/**
 * ìŠ¤íŠ¸ë¦¬ë° ë¹„í™œì„±í™” ì •ì±….
 *
 * RU-003-S2 Step 4: disabled í”Œë˜ê·¸ì˜ SSOT ê³ ì •
 * - isStreamingì€ agentStoreì—ì„œë§Œ ì œê³µ
 * - ëª¨ë“  ì¸í„°ë™ì…˜ ì»´í¬ë„ŒíŠ¸(SceneCanvas, InventoryPanel, ActionDeck)ëŠ”
 *   ë™ì¼í•œ disabled í”Œë˜ê·¸ë¥¼ ê³µìœ í•´ì•¼ í•¨
 * - í–¥í›„ worldStore/Turn Runner ë„ì… ì‹œì—ë„ ì´ ì›ì¹™ì„ ìœ ì§€
 *
 * @see App.tsxì˜ isStreaming ì‚¬ìš© íŒ¨í„´
 * @see agentStore.tsì˜ isStreaming ìƒíƒœ
 */
export const STREAMING_DISABLED_POLICY = {
  /** ìŠ¤íŠ¸ë¦¬ë° ìƒíƒœ SSOT ì¶œì²˜ */
  source: 'agentStore.isStreaming',
  /** ë¹„í™œì„±í™” ì ìš© ëŒ€ìƒ ì»´í¬ë„ŒíŠ¸ */
  affectedComponents: ['SceneCanvas', 'InventoryPanel', 'ActionDeck', 'CommandInput'],
} as const;

/**
 * DnD íƒ€ì… ìœ ë‹ˆì˜¨.
 */
export type DndType = (typeof DND_TYPE)[keyof typeof DND_TYPE];

// =============================================================================
// ë“œë˜ê·¸ ë°ì´í„° íƒ€ì…
// =============================================================================

/**
 * ì¸ë²¤í† ë¦¬ ì•„ì´í…œ ë“œë˜ê·¸ ë°ì´í„°.
 * InventoryPanelì—ì„œ ë“œë˜ê·¸ ì‹œì‘ ì‹œ ì„¤ì •ë©ë‹ˆë‹¤.
 */
export interface InventoryDragData {
  /** ë“œë˜ê·¸ íƒ€ì… (í•­ìƒ 'inventory-item') */
  type: typeof DND_TYPE.INVENTORY_ITEM;
  /** ë“œë˜ê·¸ ì¤‘ì¸ ì•„ì´í…œ ID */
  item_id: string;
  /** ë“œë˜ê·¸ ì¤‘ì¸ ì•„ì´í…œ ê°ì²´ */
  item: InventoryItem;
}

// =============================================================================
// ë“œë¡­ ë°ì´í„° íƒ€ì…
// =============================================================================

/**
 * í•«ìŠ¤íŒŸ ë“œë¡­ íƒ€ê²Ÿ ë°ì´í„°.
 * SceneCanvasì˜ í•«ìŠ¤íŒŸì—ì„œ ì„¤ì •ë©ë‹ˆë‹¤.
 */
export interface HotspotDropData {
  /** ë“œë¡­ íƒ€ê²Ÿ íƒ€ì… (í•­ìƒ 'hotspot') */
  type: typeof DND_TYPE.HOTSPOT;
  /** í•«ìŠ¤íŒŸ ì˜¤ë¸Œì íŠ¸ ID */
  object_id: string;
  /** í•«ìŠ¤íŒŸ ë°”ìš´ë”© ë°•ìŠ¤ (0~1000 ì •ê·œí™”) */
  box_2d: Box2D;
  /** í•«ìŠ¤íŒŸ ë¼ë²¨ (í‘œì‹œìš©) */
  label: string;
}

// =============================================================================
// íƒ€ì… ê°€ë“œ í•¨ìˆ˜
// =============================================================================

/**
 * ë°ì´í„°ê°€ InventoryDragDataì¸ì§€ ê²€ì‚¬í•©ë‹ˆë‹¤.
 *
 * @param data - dnd-kitì˜ active.data.current
 * @returns InventoryDragDataì´ë©´ true
 */
export function isInventoryDragData(data: unknown): data is InventoryDragData {
  if (typeof data !== 'object' || data === null) {
    return false;
  }
  const obj = data as Record<string, unknown>;
  return (
    obj.type === DND_TYPE.INVENTORY_ITEM &&
    typeof obj.item_id === 'string' &&
    typeof obj.item === 'object' &&
    obj.item !== null
  );
}

/**
 * ë°ì´í„°ê°€ HotspotDropDataì¸ì§€ ê²€ì‚¬í•©ë‹ˆë‹¤.
 *
 * @param data - dnd-kitì˜ over.data.current
 * @returns HotspotDropDataì´ë©´ true
 */
export function isHotspotDropData(data: unknown): data is HotspotDropData {
  if (typeof data !== 'object' || data === null) {
    return false;
  }
  const obj = data as Record<string, unknown>;
  return (
    obj.type === DND_TYPE.HOTSPOT &&
    typeof obj.object_id === 'string' &&
    typeof obj.box_2d === 'object' &&
    obj.box_2d !== null &&
    typeof obj.label === 'string'
  );
}

// =============================================================================
// RU-003-S2 Step 2: í•«ìŠ¤íŒŸ ìš°ì„ ìˆœìœ„ ì •ì±… (SSOT)
// =============================================================================

/**
 * ë°”ìš´ë”© ë°•ìŠ¤ì˜ ë©´ì ì„ ê³„ì‚°í•©ë‹ˆë‹¤.
 *
 * @param box - { ymin, xmin, ymax, xmax } í˜•ì‹ì˜ ë°”ìš´ë”© ë°•ìŠ¤
 * @returns ë°•ìŠ¤ ë©´ì 
 */
export function calculateBoxArea(box: Box2D): number {
  const { ymin, xmin, ymax, xmax } = box;
  return Math.abs(ymax - ymin) * Math.abs(xmax - xmin);
}

/**
 * í•«ìŠ¤íŒŸ ìš°ì„ ìˆœìœ„ ê³„ì‚°ì„ ìœ„í•œ ë¹„êµ í•¨ìˆ˜.
 *
 * RU-003-S2 Step 2: ì‘ì€ bboxê°€ ë” ë†’ì€ ìš°ì„ ìˆœìœ„ë¥¼ ê°€ì§
 * - ë” ì‘ì€ ì˜¤ë¸Œì íŠ¸ê°€ ë” êµ¬ì²´ì ì¸ íƒ€ê²Ÿì´ë¼ê³  ê°€ì •
 * - z-index ê´€ì ì—ì„œ ì‘ì€ ê²ƒì´ ìœ„ì— ë Œë”ë˜ì–´ì•¼ í•¨
 *
 * @param a - ì²« ë²ˆì§¸ ë°”ìš´ë”© ë°•ìŠ¤
 * @param b - ë‘ ë²ˆì§¸ ë°”ìš´ë”© ë°•ìŠ¤
 * @returns ì •ë ¬ ìˆœì„œ (ì‘ì€ ê²ƒì´ ë’¤ë¡œ ê°€ì„œ z-indexê°€ ë†’ì•„ì§)
 */
export function compareHotspotPriority(a: Box2D, b: Box2D): number {
  return calculateBoxArea(b) - calculateBoxArea(a);
}
</file>

<file path="frontend/src/i18n-scenario.test.ts">
import { describe, it, expect, beforeEach, vi } from 'vitest';
import { getSessionLanguage, startSessionFromProfile } from './save/sessionLifecycle';
import { buildTurnInput } from './turn/turnRunner';
import { SAVEGAME_STORAGE_KEY, SAVEGAME_VERSION } from './save/constants';
import { PROFILE_EXPLORER } from './data/demoProfiles';
import { useWorldStore } from './stores/worldStore';
import { useInventoryStore } from './stores/inventoryStore';
import { useEconomyStore } from './stores/economyStore';

// i18n ëª¨ë“ˆ mock
vi.mock('./i18n', async () => {
  const actual = await vi.importActual('./i18n');
  return {
    ...actual,
    changeLanguage: vi.fn().mockResolvedValue(undefined),
    getResolvedLanguage: vi.fn().mockReturnValue('ko-KR'),
  };
});

describe('U-044[Mvp] i18n Session SSOT Scenario', () => {
  const mockT = (key: string) => `translated-${key}`;

  beforeEach(() => {
    localStorage.clear();
    vi.clearAllMocks();

    // Store ì´ˆê¸°í™”
    useWorldStore.getState().reset();
    useInventoryStore.getState().reset();
    useEconomyStore.getState().reset();
  });

  describe('Language SSOT (getSessionLanguage)', () => {
    it('SaveGameì´ ì—†ì„ ë•ŒëŠ” ê¸°ë³¸ ì–¸ì–´(ko-KR)ë¥¼ ë°˜í™˜í•´ì•¼ í•œë‹¤', () => {
      expect(getSessionLanguage()).toBe('ko-KR');
    });

    it('SaveGameì— ì €ì¥ëœ ì–¸ì–´ê°€ ìˆìœ¼ë©´ í•´ë‹¹ ì–¸ì–´ë¥¼ ë°˜í™˜í•´ì•¼ í•œë‹¤ (en-US)', () => {
      const saveGame = {
        version: SAVEGAME_VERSION,
        language: 'en-US',
        profileId: 'explorer',
        savedAt: new Date().toISOString(),
        economy: { signal: 100, memory_shard: 5 },
        economyLedger: [],
        turnCount: 1,
        narrativeHistory: [],
        inventory: [],
        quests: [],
        activeRules: [],
        mutationTimeline: [],
        sceneObjects: [],
      };
      localStorage.setItem(SAVEGAME_STORAGE_KEY, JSON.stringify(saveGame));

      expect(getSessionLanguage()).toBe('en-US');
    });

    it('i18n resolvedLanguageê°€ ë³€ê²½ë˜ì–´ë„ SaveGame ì–¸ì–´ë¥¼ ìš°ì„ í•´ì•¼ í•œë‹¤ (ë“œë¦¬í”„íŠ¸ ë°©ì§€)', () => {
      const saveGame = {
        version: SAVEGAME_VERSION,
        language: 'ko-KR',
        profileId: 'explorer',
        savedAt: new Date().toISOString(),
        economy: { signal: 100, memory_shard: 5 },
        economyLedger: [],
        turnCount: 1,
        narrativeHistory: [],
        inventory: [],
        quests: [],
        activeRules: [],
        mutationTimeline: [],
        sceneObjects: [],
      };
      localStorage.setItem(SAVEGAME_STORAGE_KEY, JSON.stringify(saveGame));

      // i18n.getResolvedLanguage()ê°€ 'en-US'ë¥¼ ë°˜í™˜í•˜ë„ë¡ ìƒí™© ê°€ì • (ë“œë¦¬í”„íŠ¸)
      // ì‹¤ì œë¡œëŠ” mockì´ë¯€ë¡œ ì§ì ‘ ë¹„êµëŠ” ì–´ë µì§€ë§Œ logicìƒ validSaveGame í™•ì¸ ìš°ì„ ìˆœìœ„ ê²€ì¦
      expect(getSessionLanguage()).toBe('ko-KR');
    });
  });

  describe('TurnInput Language Injection', () => {
    it('buildTurnInputì€ ì™¸ë¶€ì—ì„œ ì£¼ì…ëœ ì–¸ì–´ë¥¼ ì‚¬ìš©í•´ì•¼ í•œë‹¤', () => {
      const turnInput = buildTurnInput({
        text: 'hello',
        economySnapshot: { signal: 100, memory_shard: 0 },
        theme: 'dark',
        language: 'en-US', // ì£¼ì…ëœ ì–¸ì–´
      });

      expect(turnInput.language).toBe('en-US');
    });
  });

  describe('Session Language Policy (Toggle = Reset)', () => {
    it('startSessionFromProfile í˜¸ì¶œ ì‹œ ëª…ì‹œì  ì–¸ì–´ë¥¼ SaveGameì— ë°˜ì˜í•´ì•¼ í•œë‹¤', () => {
      startSessionFromProfile({
        profile: PROFILE_EXPLORER,

        t: mockT,

        language: 'en-US',
      });

      const saved = JSON.parse(localStorage.getItem(SAVEGAME_STORAGE_KEY)!);

      expect(saved.language).toBe('en-US');

      expect(getSessionLanguage()).toBe('en-US');
    });
  });

  describe('turnStream Error Message Language', () => {
    it('ë„¤íŠ¸ì›Œí¬ ì—ëŸ¬ ì‹œ ì…ë ¥ ì–¸ì–´ì— ë§ëŠ” í•œêµ­ì–´ ë©”ì‹œì§€ë¥¼ ë°˜í™˜í•´ì•¼ í•œë‹¤ (ko-KR)', async () => {
      const { executeTurnStream } = await import('./api/turnStream');

      const mockInput = {
        language: 'ko-KR' as const,

        text: 'Hello',

        action_id: null,

        click: null,

        drop: null,

        client: { viewport_w: 100, viewport_h: 100, theme: 'dark' as const },

        economy_snapshot: { signal: 100, memory_shard: 0 },
      };

      const onError = vi.fn();

      const onFinal = vi.fn();

      // fetch ì‹¤íŒ¨ ìœ ë„

      vi.stubGlobal('fetch', vi.fn().mockRejectedValue(new Error('Network Error')));

      await executeTurnStream(mockInput, { onError, onFinal });

      // onError ë³´ë‹¤ëŠ” onFinalì˜ narrativeë¥¼ ê²€ì¦ (createClientFallbackTurnOutput)

      // onErrorëŠ” error.messageë¥¼ ê·¸ëŒ€ë¡œ ì“°ë¯€ë¡œ 'Network Error'ê°€ ë‚˜ì˜´

      expect(onFinal).toHaveBeenCalledWith(
        expect.objectContaining({
          data: expect.objectContaining({
            language: 'ko-KR',

            narrative: '[ì‹œìŠ¤í…œ] ì„œë²„ ì—°ê²°ì— ì‹¤íŒ¨í–ˆìŠµë‹ˆë‹¤. ë‹¤ì‹œ ì‹œë„í•´ ì£¼ì„¸ìš”.',
          }),
        }),
      );

      vi.unstubAllGlobals();
    });

    it('ë„¤íŠ¸ì›Œí¬ ì—ëŸ¬ ì‹œ ì…ë ¥ ì–¸ì–´ì— ë§ëŠ” ì˜ì–´ ë©”ì‹œì§€ë¥¼ ë°˜í™˜í•´ì•¼ í•œë‹¤ (en-US)', async () => {
      const { executeTurnStream } = await import('./api/turnStream');

      const mockInput = {
        language: 'en-US' as const,

        text: 'Hello',

        action_id: null,

        click: null,

        drop: null,

        client: { viewport_w: 100, viewport_h: 100, theme: 'dark' as const },

        economy_snapshot: { signal: 100, memory_shard: 0 },
      };

      const onFinal = vi.fn();

      // fetch ì‹¤íŒ¨ ìœ ë„

      vi.stubGlobal('fetch', vi.fn().mockRejectedValue(new Error('Network Error')));

      await executeTurnStream(mockInput, { onFinal });

      expect(onFinal).toHaveBeenCalledWith(
        expect.objectContaining({
          data: expect.objectContaining({
            language: 'en-US',

            narrative: '[System] Failed to connect to server. Please try again.',
          }),
        }),
      );

      vi.unstubAllGlobals();
    });
  });
});
</file>

<file path="frontend/src/i18n.ts">
/**
 * Unknown World - i18n ì´ˆê¸°í™” ëª¨ë“ˆ
 *
 * ì–¸ì–´ ë¦¬ì†ŒìŠ¤ë¥¼ JSON íŒŒì¼ êµ¬ì¡°ë¡œ ê´€ë¦¬í•©ë‹ˆë‹¤.
 * RULE-006 ì¤€ìˆ˜: ko/en í˜¼í•© ì¶œë ¥ ê¸ˆì§€, i18n í‚¤ ê¸°ë°˜ SSOT
 *
 * ì–¸ì–´ ì½”ë“œ: BCP-47 í˜•ì‹ (ko-KR, en-US)
 * - TurnInput/SaveGameì˜ language í•„ë“œì™€ ë™ì¼í•œ ì¶•
 *
 * @see vibe/prd.md 3.1(ì§€ì› ì–¸ì–´), 8.7(TurnInput.language)
 * @see frontend/src/locales/README.md
 */

import i18n from 'i18next';
import { initReactI18next } from 'react-i18next';

// JSON ì–¸ì–´ ë¦¬ì†ŒìŠ¤ import (SSOT: locales/{lang}/translation.json)
import koKR from './locales/ko-KR/translation.json';
import enUS from './locales/en-US/translation.json';

/** ì§€ì› ì–¸ì–´ íƒ€ì… (TurnInput.languageì™€ ë™ê¸°í™”) */
export type SupportedLanguage = 'ko-KR' | 'en-US';

/** ê¸°ë³¸ ì–¸ì–´ (ë°ëª¨ ì¼ê´€ì„±ì„ ìœ„í•´ ko-KR ê³ ì •) */
export const DEFAULT_LANGUAGE: SupportedLanguage = 'ko-KR';

/** í´ë°± ì–¸ì–´ */
export const FALLBACK_LANGUAGE: SupportedLanguage = 'en-US';

/** ì§€ì› ì–¸ì–´ ëª©ë¡ */
export const SUPPORTED_LANGUAGES: SupportedLanguage[] = ['ko-KR', 'en-US'];

// i18n ë¦¬ì†ŒìŠ¤ ì •ì˜ (BCP-47 í˜•ì‹ ì–¸ì–´ ì½”ë“œ)
const resources = {
  'ko-KR': {
    translation: koKR,
  },
  'en-US': {
    translation: enUS,
  },
};

i18n.use(initReactI18next).init({
  resources,
  lng: DEFAULT_LANGUAGE,
  fallbackLng: FALLBACK_LANGUAGE,
  supportedLngs: SUPPORTED_LANGUAGES,
  interpolation: {
    escapeValue: false, // Reactì—ì„œ ì´ë¯¸ XSS ë°©ì§€
  },
  // ëˆ„ë½ í‚¤ ì²˜ë¦¬ (ê°œë°œ ëª¨ë“œì—ì„œ ê²½ê³ )
  saveMissing: false,
  missingKeyHandler: (_lngs, _ns, key) => {
    if (import.meta.env.DEV) {
      console.warn(`[i18n] Missing translation key: "${key}"`);
    }
  },
});

/**
 * í˜„ì¬ í•´ê²°ëœ ì–¸ì–´ ì½”ë“œë¥¼ ë°˜í™˜í•©ë‹ˆë‹¤.
 * TurnInput.languageì™€ ë™ê¸°í™”í•  ë•Œ ì‚¬ìš©í•©ë‹ˆë‹¤.
 */
export function getResolvedLanguage(): SupportedLanguage {
  return (i18n.resolvedLanguage as SupportedLanguage) || DEFAULT_LANGUAGE;
}

/**
 * ì–¸ì–´ë¥¼ ë³€ê²½í•©ë‹ˆë‹¤.
 * í–¥í›„ U-036 ì™„ë£Œ í›„ ì‚¬ìš©ìì—ê²Œ ë…¸ì¶œí•  í† ê¸€ì—ì„œ ì‚¬ìš©í•©ë‹ˆë‹¤.
 */
export async function changeLanguage(lang: SupportedLanguage): Promise<void> {
  await i18n.changeLanguage(lang);
}

export default i18n;
</file>

<file path="frontend/src/stores/agentStore.test.ts">
import { describe, it, expect, beforeEach } from 'vitest';
import { useAgentStore } from './agentStore';
import { StreamEventType, StageStatus } from '../api/turnStream';
import type { TurnOutput } from '../schemas/turn';

describe('agentStore', () => {
  beforeEach(() => {
    useAgentStore.getState().reset();
  });

  it('should have correct initial state', () => {
    const state = useAgentStore.getState();
    expect(state.isStreaming).toBe(false);
    expect(state.phases).toHaveLength(7);
    expect(state.phases[0].status).toBe('pending');
    expect(state.badges).toEqual([]);
    expect(state.repairCount).toBe(0);
  });

  it('should handle startStream', () => {
    useAgentStore.getState().startStream();
    const state = useAgentStore.getState();
    expect(state.isStreaming).toBe(true);
  });

  it('should handle handleStage events', () => {
    const store = useAgentStore.getState();

    // Start parse phase
    store.handleStage({
      type: StreamEventType.STAGE,
      name: 'parse',
      status: StageStatus.START,
    });

    let state = useAgentStore.getState();
    expect(state.currentPhase).toBe('parse');
    expect(state.phases.find((p) => p.name === 'parse')?.status).toBe('in_progress');

    // Complete parse phase
    store.handleStage({
      type: StreamEventType.STAGE,
      name: 'parse',
      status: StageStatus.COMPLETE,
    });

    state = useAgentStore.getState();
    expect(state.phases.find((p) => p.name === 'parse')?.status).toBe('completed');
  });

  it('should handle handleBadges events', () => {
    const store = useAgentStore.getState();
    store.handleBadges({
      type: StreamEventType.BADGES,
      badges: ['schema_ok', 'economy_ok'],
    });

    const state = useAgentStore.getState();
    expect(state.badges).toEqual(['schema_ok', 'economy_ok']);
  });

  it('should handle handleNarrativeDelta events', () => {
    const store = useAgentStore.getState();
    store.handleNarrativeDelta({
      type: StreamEventType.NARRATIVE_DELTA,
      text: 'Hello ',
    });
    store.handleNarrativeDelta({
      type: StreamEventType.NARRATIVE_DELTA,
      text: 'World',
    });

    const state = useAgentStore.getState();
    expect(state.narrativeBuffer).toBe('Hello World');
  });

  it('should handle handleFinal events', () => {
    const store = useAgentStore.getState();
    const mockOutput = {
      language: 'ko-KR',
      narrative: 'Final message',
      economy: {
        cost: { signal: 0, memory_shard: 0 },
        balance_after: { signal: 100, memory_shard: 0 },
      },
      safety: { blocked: false, message: null },
      ui: { action_deck: { cards: [] }, objects: [], scene: { image_url: null, alt_text: null } },
      world: {
        rules_changed: [],
        inventory_added: [],
        inventory_removed: [],
        quests_updated: [],
        relationships_changed: [],
        memory_pins: [],
      },
      render: { image_job: null },
      agent_console: {
        repair_count: 2,
        current_phase: 'commit',
        badges: [],
      },
    } as TurnOutput;

    store.handleFinal({
      type: StreamEventType.FINAL,
      data: mockOutput,
    });

    const state = useAgentStore.getState();
    expect(state.finalOutput).toEqual(mockOutput);
    expect(state.repairCount).toBe(2);
  });

  it('should handle handleError events', () => {
    const store = useAgentStore.getState();
    store.handleError({
      type: StreamEventType.ERROR,
      message: 'Network error',
      code: 'ERR_NET',
    });

    const state = useAgentStore.getState();
    expect(state.error).toEqual({
      message: 'Network error',
      code: 'ERR_NET',
    });
  });

  it('should reset state on completeStream', () => {
    const store = useAgentStore.getState();
    store.handleNarrativeDelta({ type: StreamEventType.NARRATIVE_DELTA, text: 'Some text' });
    store.startStream();

    store.completeStream();

    const state = useAgentStore.getState();
    expect(state.isStreaming).toBe(false);
    expect(state.narrativeBuffer).toBe('');
  });
});
</file>

<file path="frontend/src/stores/uiPrefsStore.test.ts">
import { describe, it, expect, beforeEach } from 'vitest';
import { useUIPrefsStore, DEFAULT_UI_SCALE, migrateUIPrefs } from './uiPrefsStore';

// Mock localStorage for non-browser environment
// Note: With jsdom environment configured in vite.config.ts, this might not be strictly necessary
// if we trust jsdom's localStorage, but keeping it explicit is fine.
// However, since we are moving to direct function testing for migration, we rely less on persist middleware internals.

describe('uiPrefsStore', () => {
  beforeEach(() => {
    useUIPrefsStore.getState().resetPrefs();
    localStorage.clear();
  });

  it('should have default initial state', () => {
    const state = useUIPrefsStore.getState();
    expect(state.uiScale).toBe(DEFAULT_UI_SCALE);
  });

  it('should increase ui scale within limit', () => {
    const { increaseUIScale } = useUIPrefsStore.getState();

    // 1.0 -> 1.1
    increaseUIScale();
    expect(useUIPrefsStore.getState().uiScale).toBe(1.1);

    // 1.1 -> 1.2
    increaseUIScale();
    expect(useUIPrefsStore.getState().uiScale).toBe(1.2);

    // 1.2 -> 1.2 (Max)
    increaseUIScale();
    expect(useUIPrefsStore.getState().uiScale).toBe(1.2);
  });

  it('should decrease ui scale within limit', () => {
    const { decreaseUIScale, setUIScale } = useUIPrefsStore.getState();

    // Start at max
    setUIScale(1.2);

    // 1.2 -> 1.1
    decreaseUIScale();
    expect(useUIPrefsStore.getState().uiScale).toBe(1.1);

    // ... -> 0.9 (Min)
    setUIScale(0.9);
    decreaseUIScale();
    expect(useUIPrefsStore.getState().uiScale).toBe(0.9);
  });

  it('should set valid ui scale', () => {
    const { setUIScale } = useUIPrefsStore.getState();

    setUIScale(1.1);
    expect(useUIPrefsStore.getState().uiScale).toBe(1.1);
  });

  it('should ignore invalid ui scale', () => {
    const { setUIScale } = useUIPrefsStore.getState();

    // @ts-expect-error Testing invalid input
    setUIScale(2.0);
    expect(useUIPrefsStore.getState().uiScale).toBe(DEFAULT_UI_SCALE);
  });

  describe('migration (U-037)', () => {
    it('should remove readableMode from legacy storage', () => {
      // Legacy state simulation
      const legacyState = {
        uiScale: 1.1,
        readableMode: true,
      };

      // Call migrate function directly
      const migratedState = migrateUIPrefs(legacyState, 0);

      // Verify
      expect(migratedState).toHaveProperty('uiScale', 1.1);
      expect(migratedState).not.toHaveProperty('readableMode');
    });

    it('should handle undefined version (very old legacy)', () => {
      const legacyState = {
        uiScale: 0.9,
        readableMode: false,
      };

      // Call migrate function directly with undefined version
      const migratedState = migrateUIPrefs(legacyState, undefined);

      expect(migratedState).toHaveProperty('uiScale', 0.9);
      expect(migratedState).not.toHaveProperty('readableMode');
    });

    it('should pass through already migrated state', () => {
      const modernState = {
        uiScale: 1.0,
      };

      const migratedState = migrateUIPrefs(modernState, 1);
      expect(migratedState).toEqual(modernState);
    });
  });
});
</file>

<file path="frontend/src/stores/uiPrefsStore.ts">
/**
 * Unknown World - UI ì„¤ì • ìƒíƒœ ê´€ë¦¬ (Zustand + persist).
 *
 * UI ìŠ¤ì¼€ì¼ ì„¤ì •ì„ ì €ì¥í•˜ê³ , SaveGame êµ¬ì¡°ì™€ í†µí•© ê°€ëŠ¥í•˜ë„ë¡ ì§ë ¬í™” ì¸í„°í˜ì´ìŠ¤ë¥¼ ì œê³µí•©ë‹ˆë‹¤.
 *
 * ì„¤ê³„ ì›ì¹™:
 *   - PRD 9.4: ê°€ë…ì„±(í•„ìˆ˜) - ì „ì—­ UI ìŠ¤ì¼€ì¼ ì¡°ì ˆ ì œê³µ
 *   - U-037: Readable ëª¨ë“œ ì œê±° â†’ critical/ambient ì¤‘ìš”ë„ ê¸°ë°˜ ìŠ¤íƒ€ì¼ë¡œ ëŒ€ì²´
 *   - Q1 ê²°ì •: Option B (SaveGameì— í¬í•¨) - persist + ì§ë ¬í™”
 *
 * @module stores/uiPrefsStore
 */

import { create } from 'zustand';
import { persist, createJSONStorage } from 'zustand/middleware';

// =============================================================================
// ìƒìˆ˜ ì •ì˜
// =============================================================================

/** ì§€ì›í•˜ëŠ” UI ìŠ¤ì¼€ì¼ ê°’ */
export const UI_SCALES = [0.9, 1.0, 1.1, 1.2] as const;
export type UIScale = (typeof UI_SCALES)[number];

/** ê¸°ë³¸ UI ìŠ¤ì¼€ì¼ */
export const DEFAULT_UI_SCALE: UIScale = 1.0;

/** localStorage í‚¤ (SaveGame í†µí•© ì‹œì—ë„ ì‚¬ìš© ê°€ëŠ¥) */
export const UI_PREFS_STORAGE_KEY = 'unknown-world-ui-prefs';

// =============================================================================
// ìƒíƒœ íƒ€ì… ì •ì˜
// =============================================================================

/** UI ì„¤ì • ìƒíƒœ (SaveGame ì§ë ¬í™” ëŒ€ìƒ) */
export interface UIPrefsState {
  /**
   * UI ìŠ¤ì¼€ì¼ (0.9 ~ 1.2)
   * - 0.9: ì‘ì€ UI (ì •ë³´ ë°€ë„ ë†’ìŒ)
   * - 1.0: ê¸°ë³¸
   * - 1.1: ì•½ê°„ í™•ëŒ€
   * - 1.2: í° UI (ê°€ë…ì„± ìš°ì„ )
   */
  uiScale: UIScale;
}

/** UI ì„¤ì • ì•¡ì…˜ */
export interface UIPrefsActions {
  /** UI ìŠ¤ì¼€ì¼ ì„¤ì • */
  setUIScale: (scale: UIScale) => void;

  /** UI ìŠ¤ì¼€ì¼ ì¦ê°€ (ìµœëŒ€ 1.2) */
  increaseUIScale: () => void;

  /** UI ìŠ¤ì¼€ì¼ ê°ì†Œ (ìµœì†Œ 0.9) */
  decreaseUIScale: () => void;

  /** ì„¤ì • ì´ˆê¸°í™” */
  resetPrefs: () => void;

  /**
   * SaveGame ì§ë ¬í™”ìš© ìƒíƒœ ì¶”ì¶œ
   * (ì¶”í›„ SaveGame í†µí•© ì‹œ ì‚¬ìš©)
   */
  getSerializableState: () => UIPrefsState;

  /**
   * SaveGame ì—­ì§ë ¬í™”ìš© ìƒíƒœ ë³µì›
   * (ì¶”í›„ SaveGame í†µí•© ì‹œ ì‚¬ìš©)
   */
  restoreState: (state: Partial<UIPrefsState>) => void;
}

export type UIPrefsStore = UIPrefsState & UIPrefsActions;

// =============================================================================
// ì´ˆê¸° ìƒíƒœ
// =============================================================================

/** ì´ˆê¸° ìƒíƒœ ìƒì„± */
function createInitialState(): UIPrefsState {
  return {
    uiScale: DEFAULT_UI_SCALE,
  };
}

// =============================================================================
// ìœ í‹¸ë¦¬í‹° í•¨ìˆ˜
// =============================================================================

/**
 * ì£¼ì–´ì§„ ìŠ¤ì¼€ì¼ì´ ìœ íš¨í•œì§€ í™•ì¸
 */
function isValidScale(scale: number): scale is UIScale {
  return UI_SCALES.includes(scale as UIScale);
}

/**
 * ìŠ¤ì¼€ì¼ ì¸ë±ìŠ¤ ë°˜í™˜
 */
function getScaleIndex(scale: UIScale): number {
  return UI_SCALES.indexOf(scale);
}

/**
 * U-037: legacy ì €ì¥ê°’(readableMode) ë§ˆì´ê·¸ë ˆì´ì…˜/ë¬´ì‹œ
 * @internal exported for testing
 */
export function migrateUIPrefs(persistedState: unknown, version: number | undefined): UIPrefsState {
  // version 0 ë˜ëŠ” undefinedì—ì„œ version 1ë¡œ ë§ˆì´ê·¸ë ˆì´ì…˜
  // readableMode í•„ë“œê°€ ìˆìœ¼ë©´ ì œê±°
  if (version === 0 || version === undefined) {
    const state = persistedState as Record<string, unknown>;
    // readableMode í•„ë“œ ì œê±° (ë¬´ì‹œ)
    if ('readableMode' in state) {
      const { readableMode: _, ...rest } = state;
      return { ...rest, uiScale: state.uiScale ?? DEFAULT_UI_SCALE } as UIPrefsState;
    }
    return { ...state, uiScale: state.uiScale ?? DEFAULT_UI_SCALE } as UIPrefsState;
  }
  return persistedState as UIPrefsState;
}

// =============================================================================
// Zustand Store with persist
// =============================================================================

/**
 * UI ì„¤ì • ìŠ¤í† ì–´.
 *
 * U-037: Readable ëª¨ë“œ ì œê±°ë¨. CRT íš¨ê³¼ëŠ” critical/ambient ì¤‘ìš”ë„ ê¸°ë°˜ìœ¼ë¡œ ìë™ ì ìš©ë©ë‹ˆë‹¤.
 *
 * @example
 * ```tsx
 * // ì»´í¬ë„ŒíŠ¸ì—ì„œ ì‚¬ìš©
 * const { uiScale, setUIScale } = useUIPrefsStore();
 *
 * // DOM ì ìš© (App.tsxì—ì„œ)
 * useEffect(() => {
 *   document.documentElement.dataset.uiScale = uiScale.toString();
 *   document.documentElement.style.setProperty('--ui-scale-factor', uiScale.toString());
 * }, [uiScale]);
 * ```
 */
export const useUIPrefsStore = create<UIPrefsStore>()(
  persist(
    (set, get) => ({
      // ì´ˆê¸° ìƒíƒœ
      ...createInitialState(),

      // ì•¡ì…˜
      setUIScale: (scale) => {
        if (isValidScale(scale)) {
          set({ uiScale: scale });
        }
      },

      increaseUIScale: () => {
        const currentIndex = getScaleIndex(get().uiScale);
        const nextIndex = Math.min(currentIndex + 1, UI_SCALES.length - 1);
        set({ uiScale: UI_SCALES[nextIndex] });
      },

      decreaseUIScale: () => {
        const currentIndex = getScaleIndex(get().uiScale);
        const prevIndex = Math.max(currentIndex - 1, 0);
        set({ uiScale: UI_SCALES[prevIndex] });
      },

      resetPrefs: () => {
        set(createInitialState());
      },

      getSerializableState: () => {
        const { uiScale } = get();
        return { uiScale };
      },

      restoreState: (state) => {
        const updates: Partial<UIPrefsState> = {};

        if (state.uiScale !== undefined && isValidScale(state.uiScale)) {
          updates.uiScale = state.uiScale;
        }

        if (Object.keys(updates).length > 0) {
          set(updates);
        }
      },
    }),
    {
      name: UI_PREFS_STORAGE_KEY,
      storage: createJSONStorage(() => localStorage),
      // ì§ë ¬í™”í•  í•„ë“œ ì§€ì • (ì•¡ì…˜ ì œì™¸)
      partialize: (state) => ({
        uiScale: state.uiScale,
      }),
      // U-037: legacy ì €ì¥ê°’(readableMode) ë§ˆì´ê·¸ë ˆì´ì…˜/ë¬´ì‹œ
      version: 1,
      migrate: migrateUIPrefs,
    },
  ),
);

// =============================================================================
// ì…€ë ‰í„° (ì„±ëŠ¥ ìµœì í™”ìš©)
// =============================================================================

/** UI ìŠ¤ì¼€ì¼ ì…€ë ‰í„° */
export const selectUIScale = (state: UIPrefsStore) => state.uiScale;

// =============================================================================
// DOM ì ìš© í—¬í¼
// =============================================================================

/**
 * CSS ë³€ìˆ˜ë¡œ UI ìŠ¤ì¼€ì¼ ì ìš©
 * í˜¸ì¶œ ì‹œ html ìš”ì†Œì— --ui-scale-factor ë³€ìˆ˜ë¥¼ ì„¤ì •
 */
export function applyUIScaleToDOM(scale: UIScale): void {
  document.documentElement.style.setProperty('--ui-scale-factor', scale.toString());
  document.documentElement.dataset.uiScale = scale.toString();
}

/**
 * ì „ì²´ UI ì„¤ì • DOM ì ìš©
 * U-037: readableMode ì œê±°ë¨ - ìŠ¤ì¼€ì¼ë§Œ ì ìš©
 */
export function applyUIPrefsToDOM(state: UIPrefsState): void {
  applyUIScaleToDOM(state.uiScale);
}
</file>

<file path="frontend/src/stores/worldStore.test.ts">
import { describe, it, expect, beforeEach, vi } from 'vitest';
import { useWorldStore } from './worldStore';
import type { TurnOutput } from '../schemas/turn';

// í•˜ìœ„ ìŠ¤í† ì–´ ëª¨í‚¹ (ìˆœí™˜ import ë°©ì§€ ë¡œì§ ëŒ€ì‘)
vi.mock('./actionDeckStore', () => ({
  useActionDeckStore: {
    getState: () => ({
      setCards: vi.fn(),
    }),
  },
}));

vi.mock('./inventoryStore', () => ({
  useInventoryStore: {
    getState: () => ({
      addItems: vi.fn(),
      removeItems: vi.fn(),
    }),
  },
  parseInventoryAdded: (items: unknown) => items,
}));

describe('worldStore (U-013: Quest + Rules)', () => {
  beforeEach(() => {
    useWorldStore.getState().reset();
  });

  it('ì´ˆê¸° ìƒíƒœê°€ ì˜¬ë°”ë¼ì•¼ í•œë‹¤', () => {
    const state = useWorldStore.getState();
    expect(state.quests).toEqual([]);
    expect(state.activeRules).toEqual([]);
    expect(state.mutationTimeline).toEqual([]);
  });

  it('applyTurnOutputì„ í†µí•´ ìƒˆ í€˜ìŠ¤íŠ¸ê°€ ì¶”ê°€ë˜ì–´ì•¼ í•œë‹¤', () => {
    const mockOutput: Partial<TurnOutput> = {
      narrative: 'ìƒˆ í€˜ìŠ¤íŠ¸ ë°œìƒ',
      economy: {
        cost: { signal: 0, memory_shard: 0 },
        balance_after: { signal: 100, memory_shard: 5 },
      },
      ui: {
        scene: { image_url: '', alt_text: '' },
        action_deck: { cards: [] },
        objects: [],
      },
      world: {
        inventory_added: [],
        inventory_removed: [],
        quests_updated: [
          {
            id: 'q1',
            label: 'ì²« ë²ˆì§¸ ì„ë¬´',
            is_completed: false,
          },
        ],
        rules_changed: [],
        relationships_changed: [],
        memory_pins: [],
      },
      agent_console: {
        current_phase: 'commit',
        badges: ['schema_ok'],
        repair_count: 0,
      },
      safety: { blocked: false, message: null },
    };

    useWorldStore.getState().applyTurnOutput(mockOutput as TurnOutput);

    const state = useWorldStore.getState();
    expect(state.quests).toHaveLength(1);
    expect(state.quests[0].id).toBe('q1');
    expect(state.quests[0].is_completed).toBe(false);
  });

  it('ê¸°ì¡´ í€˜ìŠ¤íŠ¸ê°€ ì—…ë°ì´íŠ¸(ì™„ë£Œ)ë˜ì–´ì•¼ í•œë‹¤', () => {
    // 1. ì´ˆê¸° í€˜ìŠ¤íŠ¸ ì¶”ê°€
    const initialState: Partial<TurnOutput> = {
      narrative: 'ì´ˆê¸°í™”',
      economy: {
        cost: { signal: 0, memory_shard: 0 },
        balance_after: { signal: 100, memory_shard: 5 },
      },
      ui: {
        scene: { image_url: '', alt_text: '' },
        action_deck: { cards: [] },
        objects: [],
      },
      world: {
        inventory_added: [],
        inventory_removed: [],
        quests_updated: [{ id: 'q1', label: 'ì„ë¬´', is_completed: false }],
        rules_changed: [],
        relationships_changed: [],
        memory_pins: [],
      },
      agent_console: {
        current_phase: 'commit',
        badges: ['schema_ok'],
        repair_count: 0,
      },
      safety: { blocked: false, message: null },
    };
    useWorldStore.getState().applyTurnOutput(initialState as TurnOutput);

    // 2. í€˜ìŠ¤íŠ¸ ì™„ë£Œ ì—…ë°ì´íŠ¸
    const updateOutput: Partial<TurnOutput> = {
      narrative: 'ì„ë¬´ ì™„ë£Œ!',
      economy: {
        cost: { signal: 0, memory_shard: 0 },
        balance_after: { signal: 100, memory_shard: 5 },
      },
      ui: {
        scene: { image_url: '', alt_text: '' },
        action_deck: { cards: [] },
        objects: [],
      },
      world: {
        inventory_added: [],
        inventory_removed: [],
        quests_updated: [{ id: 'q1', label: 'ì„ë¬´', is_completed: true }],
        rules_changed: [],
        relationships_changed: [],
        memory_pins: [],
      },
      agent_console: {
        current_phase: 'commit',
        badges: ['schema_ok'],
        repair_count: 0,
      },
      safety: { blocked: false, message: null },
    };
    useWorldStore.getState().applyTurnOutput(updateOutput as TurnOutput);

    const state = useWorldStore.getState();
    expect(state.quests).toHaveLength(1);
    expect(state.quests[0].is_completed).toBe(true);
  });

  it('ìƒˆ ê·œì¹™ì´ ì¶”ê°€ë˜ê³  íƒ€ì„ë¼ì¸ì— ê¸°ë¡ë˜ì–´ì•¼ í•œë‹¤', () => {
    const mockOutput: Partial<TurnOutput> = {
      narrative: 'ìƒˆ ê·œì¹™ ì ìš©',
      economy: {
        cost: { signal: 0, memory_shard: 0 },
        balance_after: { signal: 100, memory_shard: 5 },
      },
      ui: {
        scene: { image_url: '', alt_text: '' },
        action_deck: { cards: [] },
        objects: [],
      },
      world: {
        inventory_added: [],
        inventory_removed: [],
        quests_updated: [],
        rules_changed: [
          {
            id: 'rule1',
            label: 'ì¤‘ë ¥ ê°•í™”',
            description: 'ì í”„ ë†’ì´ê°€ ì ˆë°˜ìœ¼ë¡œ ê°ì†Œí•©ë‹ˆë‹¤.',
          },
        ],
        relationships_changed: [],
        memory_pins: [],
      },
      agent_console: {
        current_phase: 'commit',
        badges: ['schema_ok'],
        repair_count: 0,
      },
      safety: { blocked: false, message: null },
    };

    useWorldStore.getState().applyTurnOutput(mockOutput as TurnOutput);

    const state = useWorldStore.getState();
    expect(state.activeRules).toHaveLength(1);
    expect(state.activeRules[0].id).toBe('rule1');

    expect(state.mutationTimeline).toHaveLength(1);
    expect(state.mutationTimeline[0].ruleId).toBe('rule1');
    expect(state.mutationTimeline[0].type).toBe('added');
  });

  it('ê¸°ì¡´ ê·œì¹™ ìˆ˜ì • ì‹œ íƒ€ì„ë¼ì¸ì— ê¸°ë¡ë˜ì–´ì•¼ í•œë‹¤', () => {
    // 1. ì´ˆê¸° ê·œì¹™ ì¶”ê°€
    const initialState: Partial<TurnOutput> = {
      narrative: 'ì´ˆê¸°í™”',
      economy: {
        cost: { signal: 0, memory_shard: 0 },
        balance_after: { signal: 100, memory_shard: 5 },
      },
      ui: {
        scene: { image_url: '', alt_text: '' },
        action_deck: { cards: [] },
        objects: [],
      },
      world: {
        inventory_added: [],
        inventory_removed: [],
        quests_updated: [],
        rules_changed: [{ id: 'rule1', label: 'ê·œì¹™', description: 'ê¸°ì¡´' }],
        relationships_changed: [],
        memory_pins: [],
      },
      agent_console: {
        current_phase: 'commit',
        badges: ['schema_ok'],
        repair_count: 0,
      },
      safety: { blocked: false, message: null },
    };
    useWorldStore.getState().applyTurnOutput(initialState as TurnOutput);

    // 2. ê·œì¹™ ìˆ˜ì •
    const updateOutput: Partial<TurnOutput> = {
      narrative: 'ê·œì¹™ ìˆ˜ì •',
      economy: {
        cost: { signal: 0, memory_shard: 0 },
        balance_after: { signal: 100, memory_shard: 5 },
      },
      ui: {
        scene: { image_url: '', alt_text: '' },
        action_deck: { cards: [] },
        objects: [],
      },
      world: {
        inventory_added: [],
        inventory_removed: [],
        quests_updated: [],
        rules_changed: [{ id: 'rule1', label: 'ê·œì¹™', description: 'ìˆ˜ì •ë¨' }],
        relationships_changed: [],
        memory_pins: [],
      },
      agent_console: {
        current_phase: 'commit',
        badges: ['schema_ok'],
        repair_count: 0,
      },
      safety: { blocked: false, message: null },
    };
    useWorldStore.getState().applyTurnOutput(updateOutput as TurnOutput);

    const state = useWorldStore.getState();
    expect(state.activeRules[0].description).toBe('ìˆ˜ì •ë¨');
    expect(state.mutationTimeline).toHaveLength(2);
    expect(state.mutationTimeline[0].type).toBe('modified');
  });

  describe('Initialization and Reset (U-015[Mvp])', () => {
    it('reset ì•¡ì…˜ì€ ëª¨ë“  ìƒíƒœë¥¼ ì´ˆê¸°ê°’ìœ¼ë¡œ ë˜ëŒë ¤ì•¼ í•œë‹¤', () => {
      // 1. ì„ì˜ì˜ ìƒíƒœ ì„¤ì •
      useWorldStore.setState({
        turnCount: 10,
        economy: { signal: 50, memory_shard: 0 },
        quests: [{ id: 'q1', label: 'í€˜ìŠ¤íŠ¸', is_completed: false }],
      });

      // 2. ë¦¬ì…‹ ì‹¤í–‰
      useWorldStore.getState().reset();

      // 3. ê²€ì¦
      const state = useWorldStore.getState();
      expect(state.turnCount).toBe(0);
      expect(state.economy.signal).toBe(100);
      expect(state.quests).toEqual([]);
      expect(state.narrativeEntries).toEqual([]);
    });

    it('initialize ì•¡ì…˜ì€ ì›°ì»´ ë©”ì‹œì§€ì™€ í•¨ê»˜ ì´ˆê¸° ìƒíƒœë¥¼ ì„¤ì •í•´ì•¼ í•œë‹¤', () => {
      const welcomeMsg = 'í™˜ì˜í•©ë‹ˆë‹¤!';
      useWorldStore.getState().initialize(welcomeMsg);

      const state = useWorldStore.getState();
      expect(state.turnCount).toBe(0);
      expect(state.narrativeEntries).toHaveLength(1);
      expect(state.narrativeEntries[0].text).toBe(welcomeMsg);
      expect(state.narrativeEntries[0].turn).toBe(0);
    });
  });
});
</file>

<file path="frontend/src/types/scene.ts">
/**
 * Scene Canvas ê´€ë ¨ íƒ€ì… ì •ì˜ (U-031: Placeholder Pack, U-020: Lazy Render)
 */

/**
 * Scene Canvas ìƒíƒœ íƒ€ì…
 * - default: ê¸°ë³¸ ìƒíƒœ (ì¥ë©´ ì´ë¯¸ì§€ ì—†ìŒ)
 * - loading: ë°ì´í„° ë¡œë”© ì¤‘
 * - offline: ì˜¤í”„ë¼ì¸/ì—°ê²° ëŠê¹€
 * - blocked: ì•ˆì „/ì •ì±… ì°¨ë‹¨
 * - low_signal: ì¬í™”/ì‹ í˜¸ ë¶€ì¡±
 * - scene: ì •ìƒ ì¥ë©´ í‘œì‹œ (ì´ë¯¸ì§€ URL í¬í•¨)
 */
export type SceneCanvasStatus =
  | 'default'
  | 'loading'
  | 'offline'
  | 'blocked'
  | 'low_signal'
  | 'scene';

/**
 * ì´ë¯¸ì§€ ë¡œë”© ìƒíƒœ (U-020: Lazy Render)
 * - idle: ì´ë¯¸ì§€ ì—†ìŒ/ëŒ€ê¸°
 * - loading: ì´ë¯¸ì§€ ë¡œë”© ì¤‘
 * - loaded: ì´ë¯¸ì§€ ë¡œë“œ ì™„ë£Œ
 * - error: ì´ë¯¸ì§€ ë¡œë“œ ì‹¤íŒ¨
 */
export type ImageLoadingState = 'idle' | 'loading' | 'loaded' | 'error';

/**
 * Scene Canvas ìƒíƒœ ë°ì´í„° êµ¬ì¡°
 *
 * U-020[Mvp] í™•ì¥:
 * - imageLoading: ì´ë¯¸ì§€ ë¡œë”© ìƒíƒœ í”Œë˜ê·¸ (ë¡œë”© ì¸ë””ì¼€ì´í„° í‘œì‹œìš©)
 * - previousImageUrl: ì´ì „ ì´ë¯¸ì§€ URL (Option A: ì´ì „ ì´ë¯¸ì§€ ìœ ì§€)
 */
export interface SceneCanvasState {
  status: SceneCanvasStatus;
  imageUrl?: string;
  message?: string;
  /** U-020: ì´ë¯¸ì§€ ë¡œë”© ì¤‘ ì—¬ë¶€ (ë¡œë”© ì¸ë””ì¼€ì´í„° í‘œì‹œìš©) */
  imageLoading?: boolean;
  /** U-020: ì´ì „ ì´ë¯¸ì§€ URL (ìƒˆ ì´ë¯¸ì§€ ë¡œë”© ì¤‘ í‘œì‹œìš©) */
  previousImageUrl?: string;
}

/**
 * ìƒíƒœë³„ placeholder ì •ë³´ êµ¬ì¡°
 */
export interface PlaceholderInfo {
  imagePath: string;
  fallbackEmoji: string;
  labelKey: string;
}
</file>

<file path="shared/schemas/turn/turn_input.schema.json">
{
  "$schema": "http://json-schema.org/draft-07/schema#",
  "$id": "https://unknown-world.dev/schemas/turn/turn_input.schema.json",
  "title": "TurnInput",
  "description": "Client â†’ Server í„´ ìš”ì²­ ìŠ¤í‚¤ë§ˆ (MVP). PRD 8.7ì ˆ ê¸°ë°˜.",
  "type": "object",
  "properties": {
    "language": {
      "type": "string",
      "enum": ["ko-KR", "en-US"],
      "description": "ê²Œì„ ì–¸ì–´ ì„¤ì • (ko-KR ë˜ëŠ” en-US)"
    },
    "text": {
      "type": "string",
      "description": "ì‚¬ìš©ì ì…ë ¥ (ìì—°ì–´)"
    },
    "click": {
      "type": ["object", "null"],
      "description": "í´ë¦­ëœ ì˜¤ë¸Œì íŠ¸ ì •ë³´ (ì„ íƒ)",
      "properties": {
        "object_id": {
          "type": "string",
          "description": "í´ë¦­ëœ ì˜¤ë¸Œì íŠ¸ ID"
        },
        "box_2d": {
          "type": ["array", "null"],
          "description": "bbox [ymin, xmin, ymax, xmax] (0~1000 ì •ê·œí™”)",
          "items": {
            "type": "integer",
            "minimum": 0,
            "maximum": 1000
          },
          "minItems": 4,
          "maxItems": 4
        }
      },
      "required": ["object_id"]
    },
    "client": {
      "type": "object",
      "description": "í´ë¼ì´ì–¸íŠ¸ í™˜ê²½ ì •ë³´",
      "properties": {
        "viewport_w": {
          "type": "integer",
          "description": "ë·°í¬íŠ¸ ë„ˆë¹„ (px)"
        },
        "viewport_h": {
          "type": "integer",
          "description": "ë·°í¬íŠ¸ ë†’ì´ (px)"
        },
        "theme": {
          "type": "string",
          "enum": ["dark", "light"],
          "description": "í…Œë§ˆ ì„¤ì •"
        }
      },
      "required": ["viewport_w", "viewport_h", "theme"]
    },
    "economy_snapshot": {
      "type": "object",
      "description": "í˜„ì¬ ì¬í™” ìƒíƒœ ìŠ¤ëƒ…ìƒ·",
      "properties": {
        "signal": {
          "type": "integer",
          "minimum": 0,
          "description": "Signal ì¬í™” ì”ì•¡"
        },
        "memory_shard": {
          "type": "integer",
          "minimum": 0,
          "description": "Memory Shard ì¬í™” ì”ì•¡"
        }
      },
      "required": ["signal", "memory_shard"]
    }
  },
  "required": ["language", "text", "client", "economy_snapshot"],
  "additionalProperties": false
}
</file>

<file path="backend/src/unknown_world/api/__init__.py">
"""Unknown World - API íŒ¨í‚¤ì§€.

ì´ íŒ¨í‚¤ì§€ëŠ” FastAPI ë¼ìš°í„°ë“¤ì„ í¬í•¨í•©ë‹ˆë‹¤.
"""

from unknown_world.api.image import router as image_router
from unknown_world.api.scanner import router as scanner_router
from unknown_world.api.turn import router as turn_router

__all__ = ["image_router", "scanner_router", "turn_router"]
</file>

<file path="backend/src/unknown_world/orchestrator/__init__.py">
"""Unknown World - Orchestrator íŒ¨í‚¤ì§€.

ì´ íŒ¨í‚¤ì§€ëŠ” í„´ ì²˜ë¦¬ ì˜¤ì¼€ìŠ¤íŠ¸ë ˆì´í„°ë¥¼ í¬í•¨í•©ë‹ˆë‹¤.
"""

from unknown_world.orchestrator.fallback import create_safe_fallback
from unknown_world.orchestrator.generate_turn_output import (
    GenerationResult,
    GenerationStatus,
    TurnOutputGenerator,
    generate_turn_output,
    get_turn_output_generator,
)
from unknown_world.orchestrator.mock import MockOrchestrator
from unknown_world.orchestrator.prompt_loader import (
    clear_prompt_cache,
    load_prompt,
    load_system_prompt,
    load_turn_instructions,
)
from unknown_world.orchestrator.repair_loop import (
    MAX_REPAIR_ATTEMPTS,
    RepairLoopResult,
    run_repair_loop,
)

__all__ = [
    # Mock Orchestrator
    "MockOrchestrator",
    # TurnOutput ìƒì„±
    "GenerationResult",
    "GenerationStatus",
    "TurnOutputGenerator",
    "generate_turn_output",
    "get_turn_output_generator",
    # Repair Loop (U-018)
    "MAX_REPAIR_ATTEMPTS",
    "RepairLoopResult",
    "run_repair_loop",
    # Fallback (U-018)
    "create_safe_fallback",
    # í”„ë¡¬í”„íŠ¸ ë¡œë”
    "clear_prompt_cache",
    "load_prompt",
    "load_system_prompt",
    "load_turn_instructions",
]
</file>

<file path="backend/src/unknown_world/orchestrator/prompt_loader.py">
"""Unknown World - í”„ë¡¬í”„íŠ¸ ë¡œë” ìœ í‹¸ë¦¬í‹°.

ì´ ëª¨ë“ˆì€ ì–¸ì–´ë³„ë¡œ ë¶„ë¦¬ëœ í”„ë¡¬í”„íŠ¸ íŒŒì¼ì„ ë¡œë“œí•©ë‹ˆë‹¤.
XML íƒœê·¸ ê¸°ë°˜ ë©”íƒ€ë°ì´í„° íŒŒì‹± ë° í•«ë¦¬ë¡œë“œë¥¼ ì§€ì›í•©ë‹ˆë‹¤.

ì„¤ê³„ ì›ì¹™:
    - RULE-006: ko/en ì–¸ì–´ ì •ì±… ì¤€ìˆ˜ (í˜¼í•© ì¶œë ¥ ê¸ˆì§€)
    - RULE-007/008: í”„ë¡¬í”„íŠ¸ ì›ë¬¸ UI/ë¡œê·¸ ë…¸ì¶œ ê¸ˆì§€
    - U-036: í•«ë¦¬ë¡œë“œ (ê°œë°œ ëª¨ë“œ), í”„ë¡ íŠ¸ë§¤í„° íŒŒì‹± ì§€ì›
    - U-046: XML íƒœê·¸ ê·œê²© í†µì¼ (ë©”íƒ€/ì„¹ì…˜) + ë ˆê±°ì‹œ í´ë°±

í”„ë¡¬í”„íŠ¸ ë””ë ‰í† ë¦¬ êµ¬ì¡°:
    backend/prompts/
    â”œâ”€â”€ system/
    â”‚   â”œâ”€â”€ game_master.ko.md
    â”‚   â””â”€â”€ game_master.en.md
    â”œâ”€â”€ turn/
    â”‚   â”œâ”€â”€ turn_output_instructions.ko.md
    â”‚   â””â”€â”€ turn_output_instructions.en.md
    â””â”€â”€ image/
        â”œâ”€â”€ scene_prompt.ko.md
        â””â”€â”€ scene_prompt.en.md

XML íƒœê·¸ ê·œê²© (U-046):
    <prompt_meta>
      <prompt_id>game_master_system</prompt_id>
      <language>ko-KR</language>
      <version>0.1.0</version>
      <last_updated>YYYY-MM-DD</last_updated>
      <policy_preset>default</policy_preset>
    </prompt_meta>

    <prompt_body>
    ## ëª©ì 
    ...
    </prompt_body>

í˜ì–´ë§ ì§ˆë¬¸ ê²°ì •:
    - U-036 Q1: Option A (ê°œë°œ ëª¨ë“œì—ì„œë§Œ ë§¤ í˜¸ì¶œ ì‹œ ë¦¬ë¡œë“œ)
    - U-036 Q2: Option B (í”„ë¡ íŠ¸ë§¤í„° í¬í•¨ ë§ˆí¬ë‹¤ìš´)
    - U-046 Q1: Option A (ë©”íƒ€ ë¸”ë¡ì„ ëª¨ë¸ ì…ë ¥ì—ì„œ ì œê±°)
    - U-046 Q2: Option A (XML íŒŒì‹± ì‹¤íŒ¨ ì‹œ ë ˆê±°ì‹œ í´ë°±)

ì°¸ì¡°:
    - vibe/prd.md 3.2 (í”„ë¡¬í”„íŠ¸ íŒŒì¼ ê´€ë¦¬)
    - vibe/prd.md 10.4 (í”„ë¡¬í”„íŠ¸ í•«ë¦¬ë¡œë“œ)
    - .cursor/rules/30-prompts-i18n.mdc
"""

from __future__ import annotations

import logging
import os
import re
from dataclasses import dataclass, field
from functools import lru_cache
from pathlib import Path
from typing import Literal

from unknown_world.models.turn import Language

# =============================================================================
# ë¡œê±° ì„¤ì • (í”„ë¡¬í”„íŠ¸ ì›ë¬¸ ë¡œê¹… ê¸ˆì§€ - RULE-007/008)
# =============================================================================

logger = logging.getLogger(__name__)

# =============================================================================
# ê²½ë¡œ ìƒìˆ˜
# =============================================================================

# í”„ë¡¬í”„íŠ¸ ë£¨íŠ¸ ë””ë ‰í† ë¦¬ (backend/prompts/)
_PROMPTS_ROOT = Path(__file__).parent.parent.parent.parent / "prompts"

# í”„ë¡¬í”„íŠ¸ ì¹´í…Œê³ ë¦¬
PromptCategory = Literal["system", "turn", "image"]

# ì–¸ì–´ ì½”ë“œ ë§¤í•‘
_LANGUAGE_CODE_MAP: dict[Language, str] = {
    Language.KO: "ko",
    Language.EN: "en",
}

# =============================================================================
# í”„ë¡ íŠ¸ë§¤í„° íŒŒì‹± ê²°ê³¼ íƒ€ì…
# =============================================================================


@dataclass
class PromptData:
    """í”„ë¡ íŠ¸ë§¤í„°ê°€ íŒŒì‹±ëœ í”„ë¡¬í”„íŠ¸ ë°ì´í„°.

    Attributes:
        content: í”„ë¡¬í”„íŠ¸ ë³¸ë¬¸ (í”„ë¡ íŠ¸ë§¤í„° ì œì™¸)
        metadata: í”„ë¡ íŠ¸ë§¤í„°ì—ì„œ ì¶”ì¶œí•œ ë©”íƒ€ë°ì´í„°
        raw: ì›ë³¸ ì „ì²´ í…ìŠ¤íŠ¸
    """

    content: str
    metadata: dict[str, str] = field(default_factory=lambda: {})
    raw: str = ""

    def to_dict(self) -> dict[str, str | dict[str, str]]:
        """JSON ì§ë ¬í™” ê°€ëŠ¥í•œ ë”•ì…”ë„ˆë¦¬ë¡œ ë³€í™˜í•©ë‹ˆë‹¤.

        Returns:
            í”„ë¡¬í”„íŠ¸ ë°ì´í„° ë”•ì…”ë„ˆë¦¬
        """
        return {
            "content": self.content,
            "metadata": self.metadata,
        }


# =============================================================================
# í™˜ê²½ ëª¨ë“œ í™•ì¸
# =============================================================================


def _is_development_mode() -> bool:
    """ê°œë°œ ëª¨ë“œì¸ì§€ í™•ì¸í•©ë‹ˆë‹¤.

    ENVIRONMENT í™˜ê²½ë³€ìˆ˜ê°€ 'development'ì´ë©´ ê°œë°œ ëª¨ë“œì…ë‹ˆë‹¤.
    ê°œë°œ ëª¨ë“œì—ì„œëŠ” í”„ë¡¬í”„íŠ¸ í•«ë¦¬ë¡œë“œê°€ í™œì„±í™”ë©ë‹ˆë‹¤.

    Returns:
        ê°œë°œ ëª¨ë“œ ì—¬ë¶€
    """
    return os.environ.get("ENVIRONMENT", "production").lower() == "development"


# =============================================================================
# XML íƒœê·¸ ë° í”„ë¡ íŠ¸ë§¤í„° íŒŒì‹± (U-046)
# =============================================================================

# XML íƒœê·¸ íŒ¨í„´ (U-046 í‘œì¤€)
_XML_META_PATTERN = re.compile(
    r"<prompt_meta>\s*(.*?)\s*</prompt_meta>",
    re.DOTALL,
)
_XML_BODY_PATTERN = re.compile(
    r"<prompt_body>\s*(.*?)\s*</prompt_body>",
    re.DOTALL,
)
_XML_TAG_PATTERN = re.compile(r"<(\w+)>([^<]*)</\1>")

# ë ˆê±°ì‹œ í”„ë¡ íŠ¸ë§¤í„° íŒ¨í„´: íŒŒì¼ ì‹œì‘ ë¶€ë¶„ì˜ "- key: value" í˜•íƒœ
_FRONTMATTER_LINE_PATTERN = re.compile(r"^-\s*(\w+):\s*(.+)$")


def _parse_xml_meta(text: str) -> tuple[dict[str, str], str] | None:
    """XML íƒœê·¸ ê¸°ë°˜ ë©”íƒ€ë°ì´í„°ì™€ ë³¸ë¬¸ì„ íŒŒì‹±í•©ë‹ˆë‹¤.

    U-046 í‘œì¤€ XML íƒœê·¸ ê·œê²©:
        <prompt_meta>
          <prompt_id>game_master_system</prompt_id>
          <language>ko-KR</language>
          <version>0.1.0</version>
          <last_updated>YYYY-MM-DD</last_updated>
          <policy_preset>default</policy_preset>
        </prompt_meta>

        <prompt_body>
        ## ëª©ì 
        ...
        </prompt_body>

    Args:
        text: ì›ë³¸ í…ìŠ¤íŠ¸

    Returns:
        (ë©”íƒ€ë°ì´í„° ë”•ì…”ë„ˆë¦¬, ë³¸ë¬¸ í…ìŠ¤íŠ¸) íŠœí”Œ
        XML íƒœê·¸ê°€ ì—†ìœ¼ë©´ None ë°˜í™˜ (ë ˆê±°ì‹œ í´ë°± í•„ìš”)
    """
    meta_match = _XML_META_PATTERN.search(text)
    body_match = _XML_BODY_PATTERN.search(text)

    # XML íƒœê·¸ê°€ ì—†ìœ¼ë©´ None ë°˜í™˜
    if not meta_match:
        return None

    # ë©”íƒ€ë°ì´í„° íŒŒì‹±
    meta_content = meta_match.group(1)
    metadata: dict[str, str] = {}
    for tag_match in _XML_TAG_PATTERN.finditer(meta_content):
        key = tag_match.group(1)
        value = tag_match.group(2).strip()
        metadata[key] = value

    # ë³¸ë¬¸ ì¶”ì¶œ (U-046 Q1: ë©”íƒ€ ë¸”ë¡ì„ ëª¨ë¸ ì…ë ¥ì—ì„œ ì œê±°)
    if body_match:
        content = body_match.group(1).strip()
    else:
        # <prompt_body>ê°€ ì—†ìœ¼ë©´ <prompt_meta> ì´í›„ ì „ì²´ë¥¼ ë³¸ë¬¸ìœ¼ë¡œ ì·¨ê¸‰
        meta_end = meta_match.end()
        content = text[meta_end:].strip()

    return metadata, content


def _parse_legacy_frontmatter(text: str) -> tuple[dict[str, str], str]:
    """ë ˆê±°ì‹œ í”„ë¡ íŠ¸ë§¤í„°ë¥¼ íŒŒì‹±í•©ë‹ˆë‹¤ (U-036 í˜¸í™˜).

    í”„ë¡ íŠ¸ë§¤í„°ëŠ” ì²« ë²ˆì§¸ ì œëª©(#) ì´í›„, ë‘ ë²ˆì§¸ ì œëª©(##) ì´ì „ì˜
    "- key: value" í˜•íƒœì˜ ë¼ì¸ë“¤ì…ë‹ˆë‹¤.

    ì˜ˆì‹œ êµ¬ì¡°:
        # [Prompt] Title

        - prompt_id: xxx
        - version: 0.1.0

        ## ë³¸ë¬¸ ì„¹ì…˜
        ...

    Args:
        text: ì›ë³¸ ë§ˆí¬ë‹¤ìš´ í…ìŠ¤íŠ¸

    Returns:
        (ë©”íƒ€ë°ì´í„° ë”•ì…”ë„ˆë¦¬, ë³¸ë¬¸ í…ìŠ¤íŠ¸) íŠœí”Œ
    """
    lines = text.split("\n")
    metadata: dict[str, str] = {}
    content_start_idx = 0
    found_first_heading = False

    for i, line in enumerate(lines):
        stripped = line.strip()

        # ë¹ˆ ì¤„ì€ ê±´ë„ˆëœ€
        if not stripped:
            continue

        # ì²« ë²ˆì§¸ ì œëª©(#) ë°œê²¬
        if stripped.startswith("#") and not stripped.startswith("##"):
            found_first_heading = True
            continue

        # ë‘ ë²ˆì§¸ ì œëª©(##) ë°œê²¬ ì‹œ í”„ë¡ íŠ¸ë§¤í„° ì˜ì—­ ì¢…ë£Œ, ë³¸ë¬¸ ì‹œì‘
        if stripped.startswith("##"):
            content_start_idx = i
            break

        # í”„ë¡ íŠ¸ë§¤í„° ë¼ì¸ ë§¤ì¹­ (ì²« ë²ˆì§¸ ì œëª© ì´í›„)
        if found_first_heading:
            match = _FRONTMATTER_LINE_PATTERN.match(stripped)
            if match:
                key = match.group(1)
                value = match.group(2).strip()
                metadata[key] = value

    # ë³¸ë¬¸ ì¶”ì¶œ (ë‘ ë²ˆì§¸ ì œëª©ë¶€í„°)
    content = "\n".join(lines[content_start_idx:]).strip()

    return metadata, content


def _parse_frontmatter(text: str) -> tuple[dict[str, str], str]:
    """ë©”íƒ€ë°ì´í„°ì™€ ë³¸ë¬¸ì„ íŒŒì‹±í•©ë‹ˆë‹¤ (XML ìš°ì„ , ë ˆê±°ì‹œ í´ë°±).

    U-046 Q2 ê²°ì •: XML íƒœê·¸ íŒŒì‹± ì‹¤íŒ¨ ì‹œ ë ˆê±°ì‹œ í´ë°± í›„ ì§„í–‰

    íŒŒì‹± ìš°ì„ ìˆœìœ„:
        1. XML íƒœê·¸ ê¸°ë°˜ (<prompt_meta>, <prompt_body>)
        2. ë ˆê±°ì‹œ í”„ë¡ íŠ¸ë§¤í„° (- key: value)

    Args:
        text: ì›ë³¸ í…ìŠ¤íŠ¸

    Returns:
        (ë©”íƒ€ë°ì´í„° ë”•ì…”ë„ˆë¦¬, ë³¸ë¬¸ í…ìŠ¤íŠ¸) íŠœí”Œ
    """
    # 1. XML íƒœê·¸ íŒŒì‹± ì‹œë„
    xml_result = _parse_xml_meta(text)
    if xml_result is not None:
        metadata, content = xml_result
        logger.debug(
            "[PromptLoader] XML íƒœê·¸ ê¸°ë°˜ íŒŒì‹± ì™„ë£Œ",
            extra={"format": "xml", "meta_keys": list(metadata.keys())},
        )
        return metadata, content

    # 2. ë ˆê±°ì‹œ í´ë°± (U-046 Q2: Option A)
    logger.debug(
        "[PromptLoader] ë ˆê±°ì‹œ í”„ë¡ íŠ¸ë§¤í„° íŒŒì‹±ìœ¼ë¡œ í´ë°±",
        extra={"format": "legacy"},
    )
    return _parse_legacy_frontmatter(text)


# =============================================================================
# í”„ë¡¬í”„íŠ¸ ë¡œë” í•¨ìˆ˜
# =============================================================================


def _get_prompt_path(
    category: PromptCategory,
    name: str,
    language: Language,
) -> Path:
    """í”„ë¡¬í”„íŠ¸ íŒŒì¼ ê²½ë¡œë¥¼ ë°˜í™˜í•©ë‹ˆë‹¤.

    Args:
        category: í”„ë¡¬í”„íŠ¸ ì¹´í…Œê³ ë¦¬ (system, turn, image)
        name: í”„ë¡¬í”„íŠ¸ íŒŒì¼ ì´ë¦„ (í™•ì¥ì ì œì™¸)
        language: ì–¸ì–´ (ko-KR, en-US)

    Returns:
        í”„ë¡¬í”„íŠ¸ íŒŒì¼ ê²½ë¡œ

    Example:
        >>> _get_prompt_path("system", "game_master", Language.KO)
        Path(".../prompts/system/game_master.ko.md")
    """
    lang_code = _LANGUAGE_CODE_MAP.get(language, "ko")
    return _PROMPTS_ROOT / category / f"{name}.{lang_code}.md"


def _load_prompt_file(
    category: PromptCategory,
    name: str,
    language: Language,
) -> str:
    """í”„ë¡¬í”„íŠ¸ íŒŒì¼ì„ ì§ì ‘ ë¡œë“œí•©ë‹ˆë‹¤ (ìºì‹± ì—†ìŒ).

    í•«ë¦¬ë¡œë“œ ëª¨ë“œì—ì„œ ì‚¬ìš©ë©ë‹ˆë‹¤.

    Args:
        category: í”„ë¡¬í”„íŠ¸ ì¹´í…Œê³ ë¦¬
        name: í”„ë¡¬í”„íŠ¸ ì´ë¦„
        language: ì–¸ì–´

    Returns:
        í”„ë¡¬í”„íŠ¸ í…ìŠ¤íŠ¸

    Raises:
        FileNotFoundError: í”„ë¡¬í”„íŠ¸ íŒŒì¼ì´ ì—†ëŠ” ê²½ìš°
    """
    path = _get_prompt_path(category, name, language)

    if not path.exists():
        # í´ë°±: ë°˜ëŒ€ ì–¸ì–´ ì‹œë„
        fallback_lang = Language.EN if language == Language.KO else Language.KO
        fallback_path = _get_prompt_path(category, name, fallback_lang)

        if fallback_path.exists():
            logger.warning(
                "[PromptLoader] í´ë°± ì–¸ì–´ ì‚¬ìš©",
                extra={
                    "original_language": language.value,
                    "fallback_language": fallback_lang.value,
                },
            )
            return fallback_path.read_text(encoding="utf-8")

        raise FileNotFoundError(f"í”„ë¡¬í”„íŠ¸ íŒŒì¼ì„ ì°¾ì„ ìˆ˜ ì—†ìŠµë‹ˆë‹¤: {path}")

    return path.read_text(encoding="utf-8")


@lru_cache(maxsize=32)
def _load_prompt_cached(
    category: PromptCategory,
    name: str,
    language: Language,
) -> str:
    """í”„ë¡¬í”„íŠ¸ íŒŒì¼ì„ ìºì‹±í•˜ì—¬ ë¡œë“œí•©ë‹ˆë‹¤.

    ìš´ì˜ ëª¨ë“œì—ì„œ ì‚¬ìš©ë©ë‹ˆë‹¤.

    Args:
        category: í”„ë¡¬í”„íŠ¸ ì¹´í…Œê³ ë¦¬
        name: í”„ë¡¬í”„íŠ¸ ì´ë¦„
        language: ì–¸ì–´

    Returns:
        í”„ë¡¬í”„íŠ¸ í…ìŠ¤íŠ¸
    """
    return _load_prompt_file(category, name, language)


def load_prompt(
    category: PromptCategory,
    name: str,
    language: Language,
) -> str:
    """í”„ë¡¬í”„íŠ¸ íŒŒì¼ì„ ë¡œë“œí•©ë‹ˆë‹¤.

    ê°œë°œ ëª¨ë“œ(ENVIRONMENT=development)ì—ì„œëŠ” ë§¤ í˜¸ì¶œ ì‹œ íŒŒì¼ì„ ë‹¤ì‹œ ì½ìŠµë‹ˆë‹¤ (í•«ë¦¬ë¡œë“œ).
    ìš´ì˜ ëª¨ë“œì—ì„œëŠ” ìºì‹±ì„ í†µí•´ ë°˜ë³µ ë¡œë“œë¥¼ ë°©ì§€í•©ë‹ˆë‹¤.
    í”„ë¡¬í”„íŠ¸ ì›ë¬¸ì€ ë¡œê·¸ì— ê¸°ë¡í•˜ì§€ ì•ŠìŠµë‹ˆë‹¤ (RULE-007/008).

    Args:
        category: í”„ë¡¬í”„íŠ¸ ì¹´í…Œê³ ë¦¬ (system, turn, image)
        name: í”„ë¡¬í”„íŠ¸ íŒŒì¼ ì´ë¦„ (í™•ì¥ì ì œì™¸)
        language: ì–¸ì–´ (ko-KR, en-US)

    Returns:
        í”„ë¡¬í”„íŠ¸ í…ìŠ¤íŠ¸

    Raises:
        FileNotFoundError: í”„ë¡¬í”„íŠ¸ íŒŒì¼ì´ ì—†ëŠ” ê²½ìš°

    Example:
        >>> prompt = load_prompt("system", "game_master", Language.KO)
    """
    # ë¡œê·¸ì—ëŠ” ê²½ë¡œ/ë©”íƒ€ë§Œ ê¸°ë¡ (ì›ë¬¸ ê¸ˆì§€)
    logger.debug(
        "[PromptLoader] í”„ë¡¬í”„íŠ¸ ë¡œë“œ",
        extra={
            "category": category,
            "name": name,
            "language": language.value,
            "hot_reload": _is_development_mode(),
        },
    )

    # U-036 Q1 ê²°ì •: ê°œë°œ ëª¨ë“œì—ì„œë§Œ í•«ë¦¬ë¡œë“œ
    if _is_development_mode():
        return _load_prompt_file(category, name, language)
    else:
        return _load_prompt_cached(category, name, language)


def load_prompt_with_metadata(
    category: PromptCategory,
    name: str,
    language: Language,
) -> PromptData:
    """í”„ë¡¬í”„íŠ¸ íŒŒì¼ì„ ë©”íƒ€ë°ì´í„°ì™€ í•¨ê»˜ ë¡œë“œí•©ë‹ˆë‹¤.

    í”„ë¡ íŠ¸ë§¤í„°ë¥¼ íŒŒì‹±í•˜ì—¬ ë©”íƒ€ë°ì´í„°ì™€ ë³¸ë¬¸ì„ ë¶„ë¦¬í•©ë‹ˆë‹¤.
    JSON í˜•íƒœë¡œ í”„ë¡¬í”„íŠ¸ë¥¼ ì „ë‹¬í•  ë•Œ ìœ ìš©í•©ë‹ˆë‹¤.

    Args:
        category: í”„ë¡¬í”„íŠ¸ ì¹´í…Œê³ ë¦¬ (system, turn, image)
        name: í”„ë¡¬í”„íŠ¸ íŒŒì¼ ì´ë¦„ (í™•ì¥ì ì œì™¸)
        language: ì–¸ì–´ (ko-KR, en-US)

    Returns:
        PromptData: ë©”íƒ€ë°ì´í„°ì™€ ë³¸ë¬¸ì´ ë¶„ë¦¬ëœ í”„ë¡¬í”„íŠ¸ ë°ì´í„°

    Example:
        >>> data = load_prompt_with_metadata("system", "game_master", Language.KO)
        >>> print(data.metadata.get("version"))
        >>> print(data.content[:100])
    """
    raw_text = load_prompt(category, name, language)
    metadata, content = _parse_frontmatter(raw_text)

    logger.debug(
        "[PromptLoader] í”„ë¡¬í”„íŠ¸ ë©”íƒ€ë°ì´í„° íŒŒì‹± ì™„ë£Œ",
        extra={
            "category": category,
            "name": name,
            "language": language.value,
            "prompt_id": metadata.get("prompt_id", "unknown"),
            "version": metadata.get("version", "unknown"),
        },
    )

    return PromptData(
        content=content,
        metadata=metadata,
        raw=raw_text,
    )


def load_prompt_as_json(
    category: PromptCategory,
    name: str,
    language: Language,
) -> dict[str, str | dict[str, str]]:
    """í”„ë¡¬í”„íŠ¸ë¥¼ JSON ì§ë ¬í™” ê°€ëŠ¥í•œ ë”•ì…”ë„ˆë¦¬ë¡œ ë¡œë“œí•©ë‹ˆë‹¤.

    API ì‘ë‹µì´ë‚˜ ëª¨ë¸ ì…ë ¥ìœ¼ë¡œ í”„ë¡¬í”„íŠ¸ë¥¼ ì „ë‹¬í•  ë•Œ ìœ ìš©í•©ë‹ˆë‹¤.

    Args:
        category: í”„ë¡¬í”„íŠ¸ ì¹´í…Œê³ ë¦¬ (system, turn, image)
        name: í”„ë¡¬í”„íŠ¸ íŒŒì¼ ì´ë¦„ (í™•ì¥ì ì œì™¸)
        language: ì–¸ì–´ (ko-KR, en-US)

    Returns:
        í”„ë¡¬í”„íŠ¸ ë”•ì…”ë„ˆë¦¬ (content, metadata í¬í•¨)

    Example:
        >>> prompt_json = load_prompt_as_json("image", "scene_prompt", Language.KO)
        >>> print(prompt_json["metadata"]["prompt_id"])
    """
    data = load_prompt_with_metadata(category, name, language)
    return data.to_dict()


def load_system_prompt(language: Language) -> str:
    """Game Master ì‹œìŠ¤í…œ í”„ë¡¬í”„íŠ¸ë¥¼ ë¡œë“œí•©ë‹ˆë‹¤.

    Args:
        language: ì–¸ì–´ (ko-KR, en-US)

    Returns:
        ì‹œìŠ¤í…œ í”„ë¡¬í”„íŠ¸ í…ìŠ¤íŠ¸
    """
    return load_prompt("system", "game_master", language)


def load_turn_instructions(language: Language) -> str:
    """TurnOutput ì§€ì‹œ í”„ë¡¬í”„íŠ¸ë¥¼ ë¡œë“œí•©ë‹ˆë‹¤.

    Args:
        language: ì–¸ì–´ (ko-KR, en-US)

    Returns:
        TurnOutput ì§€ì‹œ í…ìŠ¤íŠ¸
    """
    return load_prompt("turn", "turn_output_instructions", language)


def load_image_prompt(language: Language) -> str:
    """ì´ë¯¸ì§€ ìƒì„± í”„ë¡¬í”„íŠ¸ë¥¼ ë¡œë“œí•©ë‹ˆë‹¤.

    Args:
        language: ì–¸ì–´ (ko-KR, en-US)

    Returns:
        ì´ë¯¸ì§€ ìƒì„± í”„ë¡¬í”„íŠ¸ í…ìŠ¤íŠ¸
    """
    return load_prompt("image", "scene_prompt", language)


def load_image_prompt_with_metadata(language: Language) -> PromptData:
    """ì´ë¯¸ì§€ ìƒì„± í”„ë¡¬í”„íŠ¸ë¥¼ ë©”íƒ€ë°ì´í„°ì™€ í•¨ê»˜ ë¡œë“œí•©ë‹ˆë‹¤.

    Args:
        language: ì–¸ì–´ (ko-KR, en-US)

    Returns:
        PromptData: ë©”íƒ€ë°ì´í„°ì™€ ë³¸ë¬¸ì´ ë¶„ë¦¬ëœ ì´ë¯¸ì§€ í”„ë¡¬í”„íŠ¸ ë°ì´í„°
    """
    return load_prompt_with_metadata("image", "scene_prompt", language)


def clear_prompt_cache() -> None:
    """í”„ë¡¬í”„íŠ¸ ìºì‹œë¥¼ ì´ˆê¸°í™”í•©ë‹ˆë‹¤.

    ê°œë°œ ì¤‘ í•«ë¦¬ë¡œë“œ ë˜ëŠ” í…ŒìŠ¤íŠ¸ ì‹œ ì‚¬ìš©í•©ë‹ˆë‹¤.
    """
    _load_prompt_cached.cache_clear()
    logger.info("[PromptLoader] í”„ë¡¬í”„íŠ¸ ìºì‹œ ì´ˆê¸°í™”ë¨")


def get_prompt_metadata(
    category: PromptCategory,
    name: str,
    language: Language,
) -> dict[str, str]:
    """í”„ë¡¬í”„íŠ¸ì˜ ë©”íƒ€ë°ì´í„°ë§Œ ë°˜í™˜í•©ë‹ˆë‹¤.

    ë³¸ë¬¸ ì—†ì´ ë²„ì „, ì–¸ì–´, ì—…ë°ì´íŠ¸ ë‚ ì§œ ë“± ë©”íƒ€ì •ë³´ë§Œ í•„ìš”í•  ë•Œ ì‚¬ìš©í•©ë‹ˆë‹¤.

    Args:
        category: í”„ë¡¬í”„íŠ¸ ì¹´í…Œê³ ë¦¬
        name: í”„ë¡¬í”„íŠ¸ ì´ë¦„
        language: ì–¸ì–´

    Returns:
        ë©”íƒ€ë°ì´í„° ë”•ì…”ë„ˆë¦¬
    """
    data = load_prompt_with_metadata(category, name, language)
    return data.metadata


def is_hot_reload_enabled() -> bool:
    """í•«ë¦¬ë¡œë“œê°€ í™œì„±í™”ë˜ì–´ ìˆëŠ”ì§€ í™•ì¸í•©ë‹ˆë‹¤.

    Returns:
        í•«ë¦¬ë¡œë“œ í™œì„±í™” ì—¬ë¶€
    """
    return _is_development_mode()
</file>

<file path="backend/src/unknown_world/services/__init__.py">
"""Unknown World - ì„œë¹„ìŠ¤ ë ˆì´ì–´ íŒ¨í‚¤ì§€.

ì´ íŒ¨í‚¤ì§€ëŠ” ì™¸ë¶€ ì„œë¹„ìŠ¤ì™€ì˜ í†µì‹ ì„ ë‹´ë‹¹í•˜ëŠ” ëª¨ë“ˆì„ ê´€ë¦¬í•©ë‹ˆë‹¤.
GenAI í´ë¼ì´ì–¸íŠ¸, ì´ë¯¸ì§€ ìƒì„±ê¸°, ìŠ¤í† ë¦¬ì§€ í´ë¼ì´ì–¸íŠ¸ ë“±ì´ í¬í•¨ë©ë‹ˆë‹¤.

ì°¸ì¡°:
    - vibe/tech-stack.md (google-genai ë²„ì „, Vertex AI ì¸ì¦)
    - .cursor/rules/20-backend-orchestrator.mdc (Vertex ì¸ì¦/ë¹„ë°€ì •ë³´ ê¸ˆì§€)
"""

from unknown_world.services.genai_client import (
    GenAIClient,
    GenAIClientType,
    GenAIMode,
    GenerateRequest,
    GenerateResponse,
    MockGenAIClient,
    get_genai_client,
    reset_genai_client,
)
from unknown_world.services.image_generation import (
    ImageGenerationRequest,
    ImageGenerationResponse,
    ImageGenerationStatus,
    ImageGenerator,
    ImageGeneratorType,
    MockImageGenerator,
    create_fallback_response,
    get_image_generator,
    reset_image_generator,
)
from unknown_world.services.image_understanding import (
    ImageUnderstandingService,
    get_image_understanding_service,
    reset_image_understanding_service,
)

__all__ = [
    # GenAI í´ë¼ì´ì–¸íŠ¸
    "GenAIClient",
    "GenAIClientType",
    "GenAIMode",
    "GenerateRequest",
    "GenerateResponse",
    "MockGenAIClient",
    "get_genai_client",
    "reset_genai_client",
    # ì´ë¯¸ì§€ ìƒì„± (U-019)
    "ImageGenerationRequest",
    "ImageGenerationResponse",
    "ImageGenerationStatus",
    "ImageGenerator",
    "ImageGeneratorType",
    "MockImageGenerator",
    "create_fallback_response",
    "get_image_generator",
    "reset_image_generator",
    # ì´ë¯¸ì§€ ì´í•´/Scanner (U-021)
    "ImageUnderstandingService",
    "get_image_understanding_service",
    "reset_image_understanding_service",
]
</file>

<file path="backend/src/unknown_world/services/genai_client.py">
"""Unknown World - GenAI í´ë¼ì´ì–¸íŠ¸ ë˜í¼.

ì´ ëª¨ë“ˆì€ Vertex AI ì„œë¹„ìŠ¤ ê³„ì • ì¸ì¦ ê¸°ë°˜ì˜ google-genai í´ë¼ì´ì–¸íŠ¸ë¥¼ ì œê³µí•©ë‹ˆë‹¤.
í™˜ê²½ë³€ìˆ˜ë¡œ ì‹¤ì œ ëª¨ë¸ê³¼ mock ëª¨ë“œë¥¼ ì „í™˜í•  ìˆ˜ ìˆìŠµë‹ˆë‹¤.

ì¸ì¦ ë°©ì‹:
    - ë¡œì»¬: ADC ë˜ëŠ” GOOGLE_APPLICATION_CREDENTIALS í™˜ê²½ë³€ìˆ˜
    - ë°°í¬: Cloud Run ì„œë¹„ìŠ¤ ê³„ì • ê¶Œí•œ (í‚¤ íŒŒì¼ ì»¤ë°‹ ì—†ìŒ)

ëª¨ë“œ ì „í™˜ (í˜ì–´ë§ ì§ˆë¬¸ Q1 ê²°ì •: Option A):
    - í™˜ê²½ë³€ìˆ˜ UW_MODE=mock â†’ MockGenAIClient (í…ŒìŠ¤íŠ¸/ê°œë°œìš©)
    - í™˜ê²½ë³€ìˆ˜ UW_MODE=real â†’ ì‹¤ì œ Vertex AI í˜¸ì¶œ (ê¸°ë³¸ê°’)

ë³´ì•ˆ ê·œì¹™:
    - BYOK(ì‚¬ìš©ì API í‚¤ ì…ë ¥) ê¸ˆì§€ (RULE-007)
    - í”„ë¡¬í”„íŠ¸ ì›ë¬¸/ë¹„ë°€ì •ë³´ ë¡œê¹… ê¸ˆì§€ (RULE-007/008)
    - ë¡œê·¸ì—ëŠ” ë¼ë²¨/ë²„ì „/ì •ì±… ë©”íƒ€ë§Œ ë…¸ì¶œ

ì°¸ì¡°:
    - vibe/tech-stack.md (google-genai==1.56.0)
    - .cursor/rules/20-backend-orchestrator.mdc
    - .cursor/rules/00-core-critical.mdc (RULE-007/010)
"""

from __future__ import annotations

import logging
import os
from collections.abc import AsyncGenerator
from dataclasses import dataclass, field
from enum import StrEnum
from typing import TYPE_CHECKING, Any

from unknown_world.config.models import ModelLabel, get_model_id

if TYPE_CHECKING:
    from google.genai import Client
    from google.genai.types import GenerateContentConfig

# =============================================================================
# ë¡œê±° ì„¤ì • (í”„ë¡¬í”„íŠ¸/ë¹„ë°€ì •ë³´ ë…¸ì¶œ ê¸ˆì§€)
# =============================================================================

logger = logging.getLogger(__name__)


class GenAIMode(StrEnum):
    """GenAI í´ë¼ì´ì–¸íŠ¸ ë™ì‘ ëª¨ë“œ.

    í™˜ê²½ë³€ìˆ˜ UW_MODEë¡œ ì œì–´í•©ë‹ˆë‹¤.
    """

    MOCK = "mock"
    """í…ŒìŠ¤íŠ¸/ê°œë°œìš© ëª¨ì˜ ëª¨ë“œ - ì‹¤ì œ API í˜¸ì¶œ ì—†ìŒ"""

    REAL = "real"
    """ì‹¤ì œ Vertex AI í˜¸ì¶œ ëª¨ë“œ (ê¸°ë³¸ê°’)"""


# =============================================================================
# í™˜ê²½ë³€ìˆ˜ í‚¤ ìƒìˆ˜
# =============================================================================

ENV_UW_MODE = "UW_MODE"
"""ë™ì‘ ëª¨ë“œ í™˜ê²½ë³€ìˆ˜ (mock|real)"""

ENV_VERTEX_PROJECT = "VERTEX_PROJECT"
"""Vertex AI í”„ë¡œì íŠ¸ ID í™˜ê²½ë³€ìˆ˜"""

ENV_VERTEX_LOCATION = "VERTEX_LOCATION"
"""Vertex AI ë¦¬ì „ í™˜ê²½ë³€ìˆ˜ (ê¸°ë³¸ê°’: us-central1)"""


# =============================================================================
# ìš”ì²­/ì‘ë‹µ ë°ì´í„° í´ë˜ìŠ¤
# =============================================================================


@dataclass
class GenerateRequest:
    """í…ìŠ¤íŠ¸ ìƒì„± ìš”ì²­.

    Attributes:
        prompt: ìƒì„± í”„ë¡¬í”„íŠ¸ (ì£¼ì˜: ë¡œê¹… ê¸ˆì§€)
        model_label: ëª¨ë¸ ë¼ë²¨ (FAST, QUALITY ë“±)
        max_tokens: ìµœëŒ€ í† í° ìˆ˜ (ì„ íƒ)
        temperature: ì˜¨ë„ ì„¤ì • (ì„ íƒ, 0.0~1.0)
        response_mime_type: ì‘ë‹µ MIME íƒ€ì… (ì˜ˆ: "application/json")
        response_schema: ì‘ë‹µ JSON ìŠ¤í‚¤ë§ˆ (dict ë˜ëŠ” Pydantic ëª¨ë¸ íƒ€ì…)
    """

    prompt: str
    model_label: ModelLabel = ModelLabel.FAST
    max_tokens: int | None = None
    temperature: float | None = None
    response_mime_type: str | None = None
    response_schema: Any | None = None


@dataclass
class GenerateResponse:
    """í…ìŠ¤íŠ¸ ìƒì„± ì‘ë‹µ.

    Attributes:
        text: ìƒì„±ëœ í…ìŠ¤íŠ¸
        model_label: ì‚¬ìš©ëœ ëª¨ë¸ ë¼ë²¨
        finish_reason: ì¢…ë£Œ ì´ìœ  (stop, length ë“±)
        usage: í† í° ì‚¬ìš©ëŸ‰ ì •ë³´ (ì„ íƒ)
    """

    text: str
    model_label: ModelLabel
    finish_reason: str = "stop"
    usage: dict[str, int] = field(default_factory=lambda: {})


# =============================================================================
# Mock í´ë¼ì´ì–¸íŠ¸ êµ¬í˜„
# =============================================================================


class MockGenAIClient:
    """í…ŒìŠ¤íŠ¸/ê°œë°œìš© ëª¨ì˜ GenAI í´ë¼ì´ì–¸íŠ¸.

    ì‹¤ì œ APIë¥¼ í˜¸ì¶œí•˜ì§€ ì•Šê³  ê³ ì •ëœ ì‘ë‹µì„ ë°˜í™˜í•©ë‹ˆë‹¤.
    ìê²© ì¦ëª… ë¯¸ì„¤ì • ì‹œ ìë™ìœ¼ë¡œ ì´ í´ë¼ì´ì–¸íŠ¸ê°€ ì‚¬ìš©ë©ë‹ˆë‹¤.
    """

    def __init__(self) -> None:
        """MockGenAIClientë¥¼ ì´ˆê¸°í™”í•©ë‹ˆë‹¤."""
        logger.info(
            "[GenAI] Mock ëª¨ë“œë¡œ ì´ˆê¸°í™”ë¨ (ì‹¤ì œ API í˜¸ì¶œ ì—†ìŒ)",
            extra={"mode": GenAIMode.MOCK},
        )

    @property
    def mode(self) -> GenAIMode:
        """í˜„ì¬ ë™ì‘ ëª¨ë“œ."""
        return GenAIMode.MOCK

    async def generate(self, request: GenerateRequest) -> GenerateResponse:
        """ëª¨ì˜ í…ìŠ¤íŠ¸ë¥¼ ìƒì„±í•©ë‹ˆë‹¤.

        Args:
            request: ìƒì„± ìš”ì²­

        Returns:
            ê³ ì •ëœ ëª¨ì˜ ì‘ë‹µ
        """
        # ë¡œê·¸ì—ëŠ” ë©”íƒ€ ì •ë³´ë§Œ ê¸°ë¡ (í”„ë¡¬í”„íŠ¸ ì›ë¬¸ ê¸ˆì§€ - RULE-007/008)
        logger.debug(
            "[GenAI] Mock ìƒì„± ìš”ì²­",
            extra={
                "model_label": request.model_label,
                "max_tokens": request.max_tokens,
            },
        )

        return GenerateResponse(
            text=f"[Mock Response] ì´ê²ƒì€ {request.model_label} ëª¨ë¸ì˜ ëª¨ì˜ ì‘ë‹µì…ë‹ˆë‹¤.",
            model_label=request.model_label,
            finish_reason="stop",
            usage={"prompt_tokens": 10, "completion_tokens": 20, "total_tokens": 30},
        )

    async def generate_stream(self, request: GenerateRequest) -> AsyncGenerator[str]:
        """ëª¨ì˜ í…ìŠ¤íŠ¸ë¥¼ ìŠ¤íŠ¸ë¦¬ë°ìœ¼ë¡œ ìƒì„±í•©ë‹ˆë‹¤.

        Args:
            request: ìƒì„± ìš”ì²­

        Yields:
            ê³ ì •ëœ ëª¨ì˜ í…ìŠ¤íŠ¸ ì²­í¬
        """
        logger.debug(
            "[GenAI] Mock ìŠ¤íŠ¸ë¦¬ë° ìš”ì²­",
            extra={"model_label": request.model_label},
        )

        chunks = [
            "[Mock] ",
            "ì´ê²ƒì€ ",
            f"{request.model_label} ",
            "ëª¨ë¸ì˜ ",
            "ìŠ¤íŠ¸ë¦¬ë° ",
            "ëª¨ì˜ ì‘ë‹µì…ë‹ˆë‹¤.",
        ]
        for chunk in chunks:
            yield chunk

    def is_available(self) -> bool:
        """Mock í´ë¼ì´ì–¸íŠ¸ëŠ” í•­ìƒ ì‚¬ìš© ê°€ëŠ¥í•©ë‹ˆë‹¤."""
        return True


# =============================================================================
# ì‹¤ì œ GenAI í´ë¼ì´ì–¸íŠ¸ êµ¬í˜„
# =============================================================================


class GenAIClient:
    """Vertex AI ê¸°ë°˜ ì‹¤ì œ GenAI í´ë¼ì´ì–¸íŠ¸.

    google-genai SDKë¥¼ ì‚¬ìš©í•˜ì—¬ Gemini ëª¨ë¸ì„ í˜¸ì¶œí•©ë‹ˆë‹¤.
    ì„œë¹„ìŠ¤ ê³„ì • ì¸ì¦(ADC)ì„ ì‚¬ìš©í•˜ë©°, BYOKëŠ” ê¸ˆì§€ë©ë‹ˆë‹¤.
    """

    def __init__(
        self,
        project: str | None = None,
        location: str | None = None,
    ) -> None:
        """GenAIClientë¥¼ ì´ˆê¸°í™”í•©ë‹ˆë‹¤.

        Args:
            project: Vertex AI í”„ë¡œì íŠ¸ ID (í™˜ê²½ë³€ìˆ˜ VERTEX_PROJECT ì‚¬ìš© ê°€ëŠ¥)
            location: Vertex AI ë¦¬ì „ (ê¸°ë³¸ê°’: us-central1)

        Raises:
            RuntimeError: ì¸ì¦ ì„¤ì •ì´ ì˜¬ë°”ë¥´ì§€ ì•Šì€ ê²½ìš°
        """
        self._project = project or os.environ.get(ENV_VERTEX_PROJECT)
        self._location = location or os.environ.get(ENV_VERTEX_LOCATION, "us-central1")
        self._client: Client | None = None
        self._available = False

        self._initialize_client()

    def _initialize_client(self) -> None:
        """google-genai í´ë¼ì´ì–¸íŠ¸ë¥¼ ì´ˆê¸°í™”í•©ë‹ˆë‹¤."""
        try:
            from google.genai import Client

            # Vertex AI ëª¨ë“œë¡œ í´ë¼ì´ì–¸íŠ¸ ì´ˆê¸°í™”
            # ì¸ì¦ì€ ADC(Application Default Credentials)ë¥¼ ì‚¬ìš©
            # - ë¡œì»¬: gcloud auth application-default login
            # - ë°°í¬: Cloud Run ì„œë¹„ìŠ¤ ê³„ì • ìë™ ì¸ì¦
            client_options: dict[str, Any] = {}
            if self._project:
                client_options["project"] = self._project
            if self._location:
                client_options["location"] = self._location

            # vertexai=Trueë¡œ Vertex AI ëª¨ë“œ í™œì„±í™”
            self._client = Client(vertexai=True, **client_options)
            self._available = True

            # ë¡œê·¸ì—ëŠ” í”„ë¡œì íŠ¸/ë¦¬ì „ë§Œ ê¸°ë¡ (í‚¤/í† í° ë…¸ì¶œ ê¸ˆì§€)
            logger.info(
                "[GenAI] Vertex AI í´ë¼ì´ì–¸íŠ¸ ì´ˆê¸°í™” ì™„ë£Œ",
                extra={
                    "mode": GenAIMode.REAL,
                    "project": self._project or "(ADC ê¸°ë³¸)",
                    "location": self._location,
                },
            )
        except Exception as e:
            # ì¸ì¦ ì‹¤íŒ¨ ì‹œì—ë„ ì•±ì´ ë©ˆì¶”ì§€ ì•Šë„ë¡ ë¡œê¹…ë§Œ ìˆ˜í–‰
            # ì˜¤ë¥˜ ìƒì„¸(ìŠ¤íƒíŠ¸ë ˆì´ìŠ¤)ì— ë¹„ë°€ì •ë³´ê°€ í¬í•¨ë  ìˆ˜ ìˆìœ¼ë¯€ë¡œ exc_info=False
            logger.warning(
                "[GenAI] Vertex AI í´ë¼ì´ì–¸íŠ¸ ì´ˆê¸°í™” ì‹¤íŒ¨ - Mock ëª¨ë“œë¡œ ì „í™˜ ê¶Œì¥",
                extra={"error_type": type(e).__name__},
            )
            self._available = False

    @property
    def mode(self) -> GenAIMode:
        """í˜„ì¬ ë™ì‘ ëª¨ë“œ."""
        return GenAIMode.REAL

    async def generate(self, request: GenerateRequest) -> GenerateResponse:
        """í…ìŠ¤íŠ¸ë¥¼ ìƒì„±í•©ë‹ˆë‹¤.

        Args:
            request: ìƒì„± ìš”ì²­

        Returns:
            ìƒì„±ëœ í…ìŠ¤íŠ¸ ì‘ë‹µ

        Raises:
            RuntimeError: í´ë¼ì´ì–¸íŠ¸ê°€ ì‚¬ìš© ë¶ˆê°€ëŠ¥í•œ ê²½ìš°
        """
        if not self._available or self._client is None:
            raise RuntimeError("GenAI í´ë¼ì´ì–¸íŠ¸ê°€ ì´ˆê¸°í™”ë˜ì§€ ì•Šì•˜ìŠµë‹ˆë‹¤.")

        model_id = get_model_id(request.model_label)

        # ë¡œê·¸ì—ëŠ” ë©”íƒ€ ì •ë³´ë§Œ ê¸°ë¡ (í”„ë¡¬í”„íŠ¸ ì›ë¬¸ ê¸ˆì§€ - RULE-007/008)
        logger.debug(
            "[GenAI] ìƒì„± ìš”ì²­",
            extra={
                "model_label": request.model_label,
                "model_id": model_id,
                "max_tokens": request.max_tokens,
            },
        )

        # google-genai SDK í˜¸ì¶œ
        from google.genai.types import GenerateContentConfig

        config_dict: dict[str, Any] = {}
        if request.max_tokens:
            config_dict["max_output_tokens"] = request.max_tokens
        if request.temperature is not None:
            config_dict["temperature"] = request.temperature
        if request.response_mime_type:
            config_dict["response_mime_type"] = request.response_mime_type
        if request.response_schema:
            config_dict["response_schema"] = request.response_schema

        config: GenerateContentConfig | None = (
            GenerateContentConfig(**config_dict) if config_dict else None
        )

        response = await self._client.aio.models.generate_content(  # type: ignore[reportUnknownMemberType]
            model=model_id,
            contents=request.prompt,
            config=config,
        )

        # ì‘ë‹µ íŒŒì‹±
        text = response.text if hasattr(response, "text") and response.text else str(response)
        finish_reason = "stop"
        if hasattr(response, "candidates") and response.candidates:
            candidate = response.candidates[0]
            if hasattr(candidate, "finish_reason"):
                finish_reason = str(candidate.finish_reason)

        # í† í° ì‚¬ìš©ëŸ‰ ì¶”ì¶œ
        usage: dict[str, int] = {}
        if hasattr(response, "usage_metadata") and response.usage_metadata:
            meta = response.usage_metadata
            if hasattr(meta, "prompt_token_count") and meta.prompt_token_count is not None:
                usage["prompt_tokens"] = meta.prompt_token_count
            if hasattr(meta, "candidates_token_count") and meta.candidates_token_count is not None:
                usage["completion_tokens"] = meta.candidates_token_count
            if hasattr(meta, "total_token_count") and meta.total_token_count is not None:
                usage["total_tokens"] = meta.total_token_count

        return GenerateResponse(
            text=text,
            model_label=request.model_label,
            finish_reason=finish_reason,
            usage=usage,
        )

    async def generate_stream(self, request: GenerateRequest) -> AsyncGenerator[str]:
        """í…ìŠ¤íŠ¸ë¥¼ ìŠ¤íŠ¸ë¦¬ë°ìœ¼ë¡œ ìƒì„±í•©ë‹ˆë‹¤.

        Args:
            request: ìƒì„± ìš”ì²­

        Yields:
            ìƒì„±ëœ í…ìŠ¤íŠ¸ ì²­í¬

        Raises:
            RuntimeError: í´ë¼ì´ì–¸íŠ¸ê°€ ì‚¬ìš© ë¶ˆê°€ëŠ¥í•œ ê²½ìš°
        """
        if not self._available or self._client is None:
            raise RuntimeError("GenAI í´ë¼ì´ì–¸íŠ¸ê°€ ì´ˆê¸°í™”ë˜ì§€ ì•Šì•˜ìŠµë‹ˆë‹¤.")

        model_id = get_model_id(request.model_label)

        logger.debug(
            "[GenAI] ìŠ¤íŠ¸ë¦¬ë° ìš”ì²­",
            extra={
                "model_label": request.model_label,
                "model_id": model_id,
            },
        )

        from google.genai.types import GenerateContentConfig

        config_dict: dict[str, Any] = {}
        if request.max_tokens:
            config_dict["max_output_tokens"] = request.max_tokens
        if request.temperature is not None:
            config_dict["temperature"] = request.temperature
        if request.response_mime_type:
            config_dict["response_mime_type"] = request.response_mime_type
        if request.response_schema:
            config_dict["response_schema"] = request.response_schema

        config: GenerateContentConfig | None = (
            GenerateContentConfig(**config_dict) if config_dict else None
        )

        stream = await self._client.aio.models.generate_content_stream(  # type: ignore[reportUnknownMemberType]
            model=model_id,
            contents=request.prompt,
            config=config,
        )
        async for chunk in stream:
            if hasattr(chunk, "text") and chunk.text:
                yield chunk.text

    def is_available(self) -> bool:
        """í´ë¼ì´ì–¸íŠ¸ê°€ ì‚¬ìš© ê°€ëŠ¥í•œ ìƒíƒœì¸ì§€ í™•ì¸í•©ë‹ˆë‹¤."""
        return self._available


# =============================================================================
# íŒ©í† ë¦¬ í•¨ìˆ˜
# =============================================================================

# í´ë¼ì´ì–¸íŠ¸ íƒ€ì… (Protocol ëŒ€ì‹  Union ì‚¬ìš© - pyright í˜¸í™˜ì„±)
GenAIClientType = MockGenAIClient | GenAIClient

# ì‹±ê¸€í†¤ í´ë¼ì´ì–¸íŠ¸ ì¸ìŠ¤í„´ìŠ¤ ìºì‹œ
_client_instance: GenAIClientType | None = None


def get_genai_client(
    *,
    force_mock: bool = False,
    force_new: bool = False,
) -> GenAIClientType:
    """GenAI í´ë¼ì´ì–¸íŠ¸ ì¸ìŠ¤í„´ìŠ¤ë¥¼ ë°˜í™˜í•©ë‹ˆë‹¤.

    í™˜ê²½ë³€ìˆ˜ UW_MODEì— ë”°ë¼ ì‹¤ì œ í´ë¼ì´ì–¸íŠ¸ ë˜ëŠ” Mock í´ë¼ì´ì–¸íŠ¸ë¥¼ ë°˜í™˜í•©ë‹ˆë‹¤.
    ê¸°ë³¸ì ìœ¼ë¡œ ì‹±ê¸€í†¤ íŒ¨í„´ìœ¼ë¡œ ë™ì‘í•©ë‹ˆë‹¤.

    Args:
        force_mock: Trueë©´ í™˜ê²½ë³€ìˆ˜ì™€ ë¬´ê´€í•˜ê²Œ Mock í´ë¼ì´ì–¸íŠ¸ ë°˜í™˜
        force_new: Trueë©´ ìºì‹œë¥¼ ë¬´ì‹œí•˜ê³  ìƒˆ ì¸ìŠ¤í„´ìŠ¤ ìƒì„±

    Returns:
        GenAI í´ë¼ì´ì–¸íŠ¸ ì¸ìŠ¤í„´ìŠ¤

    Example:
        >>> client = get_genai_client()
        >>> response = await client.generate(GenerateRequest(prompt="Hello"))
    """
    global _client_instance

    if not force_new and _client_instance is not None:
        return _client_instance

    # ëª¨ë“œ ê²°ì •: force_mock > í™˜ê²½ë³€ìˆ˜ > ê¸°ë³¸ê°’(real)
    if force_mock:
        mode = GenAIMode.MOCK
    else:
        mode_str = os.environ.get(ENV_UW_MODE, GenAIMode.REAL)
        mode = GenAIMode(mode_str) if mode_str in GenAIMode.__members__.values() else GenAIMode.REAL

    # í´ë¼ì´ì–¸íŠ¸ ìƒì„±
    client_result: GenAIClientType
    if mode == GenAIMode.MOCK:
        client_result = MockGenAIClient()
    else:
        client = GenAIClient()
        # ì‹¤ì œ í´ë¼ì´ì–¸íŠ¸ ì´ˆê¸°í™” ì‹¤íŒ¨ ì‹œ Mockìœ¼ë¡œ í´ë°±
        if not client.is_available():
            logger.warning(
                "[GenAI] ì‹¤ì œ í´ë¼ì´ì–¸íŠ¸ ì´ˆê¸°í™” ì‹¤íŒ¨, Mock ëª¨ë“œë¡œ í´ë°±",
            )
            client_result = MockGenAIClient()
        else:
            client_result = client

    _client_instance = client_result
    return client_result


def reset_genai_client() -> None:
    """GenAI í´ë¼ì´ì–¸íŠ¸ ìºì‹œë¥¼ ì´ˆê¸°í™”í•©ë‹ˆë‹¤.

    í…ŒìŠ¤íŠ¸ ì‹œ í´ë¼ì´ì–¸íŠ¸ë¥¼ ì¬ì„¤ì •í•  ë•Œ ì‚¬ìš©í•©ë‹ˆë‹¤.
    """
    global _client_instance
    _client_instance = None
</file>

<file path="backend/src/unknown_world/services/image_understanding.py">
"""Unknown World - ì´ë¯¸ì§€ ì´í•´(Scanner) ì„œë¹„ìŠ¤.

ì´ ëª¨ë“ˆì€ ì‚¬ìš©ìê°€ ì—…ë¡œë“œí•œ ì´ë¯¸ì§€ë¥¼ ë¶„ì„í•˜ì—¬ ìº¡ì…˜, ì˜¤ë¸Œì íŠ¸(bbox),
ì•„ì´í…œ í›„ë³´ë¥¼ ì¶”ì¶œí•˜ëŠ” ì„œë¹„ìŠ¤ë¥¼ ì œê³µí•©ë‹ˆë‹¤.

ì„¤ê³„ ì›ì¹™:
    - RULE-004: ì‹¤íŒ¨ ì‹œ ì•ˆì „í•œ í´ë°± (í…ìŠ¤íŠ¸-only ìº¡ì…˜)
    - RULE-007: í”„ë¡¬í”„íŠ¸ ì›ë¬¸/ë¹„ë°€ì •ë³´ ë…¸ì¶œ ê¸ˆì§€
    - RULE-009: bboxëŠ” 0~1000 ì •ê·œí™” + [ymin, xmin, ymax, xmax]

í˜ì–´ë§ ì§ˆë¬¸ ê²°ì •:
    - Q1: Option A (multipart ì—…ë¡œë“œë¡œ ì²˜ë¦¬)

ì°¸ì¡°:
    - vibe/unit-plans/U-021[Mvp].md
    - vibe/tech-stack.md (ë¹„ì „ ëª¨ë¸: gemini-3-flash-preview)
    - .cursor/rules/00-core-critical.mdc
"""

from __future__ import annotations

import json
import logging
import os
import time
import uuid
from typing import TYPE_CHECKING, Any

from unknown_world.config.models import ModelLabel, get_model_id
from unknown_world.models.scanner import (
    DetectedObject,
    ItemCandidate,
    ScanResult,
    ScanStatus,
)
from unknown_world.models.turn import Box2D, Language
from unknown_world.services.genai_client import ENV_UW_MODE, GenAIMode
from unknown_world.storage.validation import (
    ALLOWED_IMAGE_MIME_TYPES,
    BBOX_MAX,
    BBOX_MIN,
    MAX_IMAGE_FILE_SIZE_BYTES,
    validate_image_upload,
)

if TYPE_CHECKING:
    from google.genai import Client

# =============================================================================
# ë¡œê±° ì„¤ì • (í”„ë¡¬í”„íŠ¸/ë¹„ë°€ì •ë³´ ë…¸ì¶œ ê¸ˆì§€)
# =============================================================================

logger = logging.getLogger(__name__)

# =============================================================================
# í˜¸í™˜ì„±ì„ ìœ„í•œ ìƒìˆ˜ ë³„ì¹­ (api/scanner.pyì—ì„œ import)
# =============================================================================

ALLOWED_MIME_TYPES = ALLOWED_IMAGE_MIME_TYPES
"""ì§€ì›í•˜ëŠ” ì´ë¯¸ì§€ MIME íƒ€ì… (í˜¸í™˜ì„± ë³„ì¹­)."""

MAX_FILE_SIZE_BYTES = MAX_IMAGE_FILE_SIZE_BYTES
"""ìµœëŒ€ ì´ë¯¸ì§€ íŒŒì¼ í¬ê¸° (í˜¸í™˜ì„± ë³„ì¹­)."""

# =============================================================================
# í”„ë¡¬í”„íŠ¸ í…œí”Œë¦¿ (ì–¸ì–´ë³„)
# =============================================================================

SCAN_PROMPT_KO = """ë‹¹ì‹ ì€ ì´ë¯¸ì§€ ë¶„ì„ ì „ë¬¸ê°€ì…ë‹ˆë‹¤. ì£¼ì–´ì§„ ì´ë¯¸ì§€ë¥¼ ë¶„ì„í•˜ì—¬ ë‹¤ìŒ ì •ë³´ë¥¼ JSON í˜•ì‹ìœ¼ë¡œ ì¶”ì¶œí•˜ì„¸ìš”.

## ì‘ì—… ì§€ì‹œ

1. **ìº¡ì…˜ (caption)**: ì´ë¯¸ì§€ ì „ì²´ë¥¼ ì„¤ëª…í•˜ëŠ” í•œêµ­ì–´ ë¬¸ì¥ (1-2ë¬¸ì¥)
2. **ì˜¤ë¸Œì íŠ¸ (objects)**: ì´ë¯¸ì§€ì—ì„œ ë°œê²¬ëœ ì£¼ìš” ì˜¤ë¸Œì íŠ¸ ëª©ë¡
   - label: ì˜¤ë¸Œì íŠ¸ ì´ë¦„ (í•œêµ­ì–´)
   - box_2d: ë°”ìš´ë”© ë°•ìŠ¤ ì¢Œí‘œ [ymin, xmin, ymax, xmax] (0~1000 ì •ê·œí™”)
   - suggested_item_type: ê²Œì„ ì•„ì´í…œìœ¼ë¡œ ë³€í™˜ ì‹œ ì í•©í•œ ìœ í˜• (key, weapon, tool, clue, material, container ë“±)
3. **ì•„ì´í…œ í›„ë³´ (item_candidates)**: ê²Œì„ì—ì„œ ì‚¬ìš© ê°€ëŠ¥í•œ ì•„ì´í…œìœ¼ë¡œ ë³€í™˜ëœ ëª©ë¡
   - id: ê³ ìœ  ID (ì˜ˆ: "item_001")
   - label: ì•„ì´í…œ ì´ë¦„ (í•œêµ­ì–´)
   - description: ì•„ì´í…œ ì„¤ëª… (í•œêµ­ì–´, 1ë¬¸ì¥)
   - item_type: ì•„ì´í…œ ìœ í˜•
   - source_object_index: ì›ë³¸ ì˜¤ë¸Œì íŠ¸ ì¸ë±ìŠ¤

## ì¶œë ¥ í˜•ì‹ (JSON)

```json
{
  "caption": "ì´ë¯¸ì§€ ì„¤ëª…...",
  "objects": [
    {
      "label": "ì˜¤ë¸Œì íŠ¸ëª…",
      "box_2d": {"ymin": 100, "xmin": 200, "ymax": 400, "xmax": 500},
      "suggested_item_type": "key"
    }
  ],
  "item_candidates": [
    {
      "id": "item_001",
      "label": "ì•„ì´í…œëª…",
      "description": "ì•„ì´í…œ ì„¤ëª…",
      "item_type": "key",
      "source_object_index": 0
    }
  ]
}
```

## ì£¼ì˜ì‚¬í•­

- bbox ì¢Œí‘œëŠ” ë°˜ë“œì‹œ 0~1000 ë²”ìœ„ ë‚´ì—ì„œ ì •ê·œí™”í•˜ì„¸ìš”.
- ê²Œì„ì— ì í•©í•˜ì§€ ì•Šì€ ì˜¤ë¸Œì íŠ¸(ì‚¬ëŒ ì–¼êµ´, ë¯¼ê°í•œ ì½˜í…ì¸  ë“±)ëŠ” ì œì™¸í•˜ì„¸ìš”.
- ìµœëŒ€ 10ê°œì˜ ì˜¤ë¸Œì íŠ¸ì™€ ì•„ì´í…œ í›„ë³´ë¥¼ ì¶”ì¶œí•˜ì„¸ìš”.
"""

SCAN_PROMPT_EN = """You are an image analysis expert. Analyze the given image and extract the following information in JSON format.

## Task Instructions

1. **Caption**: A description of the entire image in English (1-2 sentences)
2. **Objects**: List of main objects found in the image
   - label: Object name (English)
   - box_2d: Bounding box coordinates [ymin, xmin, ymax, xmax] (0~1000 normalized)
   - suggested_item_type: Suitable type for game item conversion (key, weapon, tool, clue, material, container, etc.)
3. **Item Candidates**: List of items converted for game use
   - id: Unique ID (e.g., "item_001")
   - label: Item name (English)
   - description: Item description (English, 1 sentence)
   - item_type: Item type
   - source_object_index: Original object index

## Output Format (JSON)

```json
{
  "caption": "Image description...",
  "objects": [
    {
      "label": "object_name",
      "box_2d": {"ymin": 100, "xmin": 200, "ymax": 400, "xmax": 500},
      "suggested_item_type": "key"
    }
  ],
  "item_candidates": [
    {
      "id": "item_001",
      "label": "item_name",
      "description": "Item description",
      "item_type": "key",
      "source_object_index": 0
    }
  ]
}
```

## Notes

- bbox coordinates must be normalized within 0~1000 range.
- Exclude objects not suitable for games (human faces, sensitive content, etc.).
- Extract up to 10 objects and item candidates.
"""

SCAN_PROMPTS: dict[Language, str] = {
    Language.KO: SCAN_PROMPT_KO,
    Language.EN: SCAN_PROMPT_EN,
}


# =============================================================================
# Mock ì„œë¹„ìŠ¤ êµ¬í˜„
# =============================================================================


def _create_mock_scan_result(language: Language) -> ScanResult:
    """Mock ìŠ¤ìº” ê²°ê³¼ë¥¼ ìƒì„±í•©ë‹ˆë‹¤.

    Args:
        language: ì‘ë‹µ ì–¸ì–´

    Returns:
        ê³ ì •ëœ Mock ìŠ¤ìº” ê²°ê³¼
    """
    if language == Language.KO:
        return ScanResult(
            status=ScanStatus.COMPLETED,
            caption="[Mock] í…ŒìŠ¤íŠ¸ ì´ë¯¸ì§€ì…ë‹ˆë‹¤. ì—¬ëŸ¬ ì˜¤ë¸Œì íŠ¸ê°€ ê°ì§€ë˜ì—ˆìŠµë‹ˆë‹¤.",
            objects=[
                DetectedObject(
                    label="ì—´ì‡ ",
                    box_2d=Box2D(ymin=100, xmin=200, ymax=300, xmax=400),
                    confidence=0.95,
                    suggested_item_type="key",
                ),
                DetectedObject(
                    label="ìƒì",
                    box_2d=Box2D(ymin=400, xmin=100, ymax=700, xmax=500),
                    confidence=0.88,
                    suggested_item_type="container",
                ),
            ],
            item_candidates=[
                ItemCandidate(
                    id="item_001",
                    label="ë…¹ìŠ¨ ì—´ì‡ ",
                    description="ì˜¤ë˜ëœ ìë¬¼ì‡ ë¥¼ ì—´ ìˆ˜ ìˆì„ ê²ƒ ê°™ì€ ì—´ì‡ ì…ë‹ˆë‹¤.",
                    item_type="key",
                    source_object_index=0,
                ),
                ItemCandidate(
                    id="item_002",
                    label="ë‚˜ë¬´ ìƒì",
                    description="ë¬´ì–¸ê°€ ë“¤ì–´ìˆì„ ê²ƒ ê°™ì€ ì‘ì€ ìƒìì…ë‹ˆë‹¤.",
                    item_type="container",
                    source_object_index=1,
                ),
            ],
            message=None,
            analysis_time_ms=150,
        )
    else:
        return ScanResult(
            status=ScanStatus.COMPLETED,
            caption="[Mock] Test image. Multiple objects detected.",
            objects=[
                DetectedObject(
                    label="Key",
                    box_2d=Box2D(ymin=100, xmin=200, ymax=300, xmax=400),
                    confidence=0.95,
                    suggested_item_type="key",
                ),
                DetectedObject(
                    label="Box",
                    box_2d=Box2D(ymin=400, xmin=100, ymax=700, xmax=500),
                    confidence=0.88,
                    suggested_item_type="container",
                ),
            ],
            item_candidates=[
                ItemCandidate(
                    id="item_001",
                    label="Rusty Key",
                    description="An old key that might open an ancient lock.",
                    item_type="key",
                    source_object_index=0,
                ),
                ItemCandidate(
                    id="item_002",
                    label="Wooden Box",
                    description="A small box that might contain something.",
                    item_type="container",
                    source_object_index=1,
                ),
            ],
            message=None,
            analysis_time_ms=150,
        )


# =============================================================================
# ìœ í‹¸ë¦¬í‹° í•¨ìˆ˜
# =============================================================================


def validate_image(
    content: bytes,
    content_type: str,
) -> str | None:
    """ì´ë¯¸ì§€ íŒŒì¼ì„ ê²€ì¦í•©ë‹ˆë‹¤.

    NOTE: ì´ í•¨ìˆ˜ëŠ” í˜¸í™˜ì„±ì„ ìœ„í•´ ìœ ì§€ë˜ë©°, ë‚´ë¶€ì ìœ¼ë¡œ
    ì¤‘ì•™í™”ëœ validate_image_uploadë¥¼ í˜¸ì¶œí•©ë‹ˆë‹¤.

    Args:
        content: ì´ë¯¸ì§€ ë°”ì´íŠ¸ ë°ì´í„°
        content_type: MIME íƒ€ì…

    Returns:
        ì—ëŸ¬ ë©”ì‹œì§€ (ì—†ìœ¼ë©´ None)
    """
    return validate_image_upload(content, content_type, language="ko-KR")


def normalize_bbox(bbox: dict[str, Any]) -> Box2D:
    """bboxë¥¼ 0~1000 ë²”ìœ„ë¡œ ì •ê·œí™”í•©ë‹ˆë‹¤.

    Args:
        bbox: ì›ë³¸ bbox dict

    Returns:
        ì •ê·œí™”ëœ Box2D
    """
    # ê¸°ë³¸ê°’
    ymin_val: int = int(bbox.get("ymin", 0) or 0)
    xmin_val: int = int(bbox.get("xmin", 0) or 0)
    ymax_val: int = int(bbox.get("ymax", BBOX_MAX) or BBOX_MAX)
    xmax_val: int = int(bbox.get("xmax", BBOX_MAX) or BBOX_MAX)

    # ë²”ìœ„ í´ë¨í•‘ (RULE-009)
    ymin_val = max(BBOX_MIN, min(BBOX_MAX, ymin_val))
    xmin_val = max(BBOX_MIN, min(BBOX_MAX, xmin_val))
    ymax_val = max(BBOX_MIN, min(BBOX_MAX, ymax_val))
    xmax_val = max(BBOX_MIN, min(BBOX_MAX, xmax_val))

    # ymin < ymax, xmin < xmax ë³´ì¥
    if ymin_val >= ymax_val:
        ymax_val = min(ymin_val + 100, BBOX_MAX)
    if xmin_val >= xmax_val:
        xmax_val = min(xmin_val + 100, BBOX_MAX)

    return Box2D(ymin=ymin_val, xmin=xmin_val, ymax=ymax_val, xmax=xmax_val)


def _create_fallback_result(
    message: str,
    status: ScanStatus = ScanStatus.FAILED,
) -> ScanResult:
    """ì•ˆì „í•œ í´ë°± ê²°ê³¼ë¥¼ ìƒì„±í•©ë‹ˆë‹¤ (RULE-004).

    Args:
        message: ì—ëŸ¬/ìƒíƒœ ë©”ì‹œì§€
        status: ìŠ¤ìº” ìƒíƒœ

    Returns:
        ìŠ¤í‚¤ë§ˆë¥¼ ì¤€ìˆ˜í•˜ëŠ” í´ë°± ScanResult
    """
    return ScanResult(
        status=status,
        caption="",
        objects=[],
        item_candidates=[],
        message=message,
        analysis_time_ms=0,
    )


def _parse_vision_response(
    response_text: str,
    language: Language,  # noqa: ARG001
) -> ScanResult:
    """ë¹„ì „ ëª¨ë¸ ì‘ë‹µì„ íŒŒì‹±í•©ë‹ˆë‹¤.

    Args:
        response_text: ëª¨ë¸ ì‘ë‹µ í…ìŠ¤íŠ¸ (JSON ì˜ˆìƒ)
        language: ì‘ë‹µ ì–¸ì–´ (í˜„ì¬ ì‚¬ìš©ë˜ì§€ ì•ŠìŒ)

    Returns:
        íŒŒì‹±ëœ ScanResult
    """
    try:
        # JSON íŒŒì‹±
        # ì‘ë‹µì— ```json ... ``` ë§ˆí¬ë‹¤ìš´ì´ í¬í•¨ëœ ê²½ìš° ì²˜ë¦¬
        text = response_text.strip()
        if text.startswith("```"):
            # ì²« ë²ˆì§¸ ì¤„ ì œê±° (```json)
            lines = text.split("\n")
            if lines[0].startswith("```"):
                lines = lines[1:]
            # ë§ˆì§€ë§‰ ì¤„ ì œê±° (```)
            if lines and lines[-1].strip() == "```":
                lines = lines[:-1]
            text = "\n".join(lines)

        data: dict[str, Any] = json.loads(text)

        # caption ì¶”ì¶œ
        caption: str = str(data.get("caption", "") or "")

        # objects ì¶”ì¶œ ë° ì •ê·œí™”
        objects: list[DetectedObject] = []
        raw_objects: list[dict[str, Any]] = data.get("objects") or []  # type: ignore[assignment]
        for i, obj in enumerate(raw_objects[:10]):  # ìµœëŒ€ 10ê°œ
            if not isinstance(obj, dict):  # type: ignore[reportUnnecessaryIsInstance]
                continue

            label_val = obj.get("label")
            label: str = str(label_val) if label_val else f"Object_{i}"
            bbox_raw: dict[str, Any] = obj.get("box_2d") or {}  # type: ignore[assignment]
            bbox = normalize_bbox(bbox_raw)
            confidence_raw = obj.get("confidence")
            suggested_type_raw = obj.get("suggested_item_type")

            objects.append(
                DetectedObject(
                    label=label,
                    box_2d=bbox,
                    confidence=float(confidence_raw) if confidence_raw is not None else None,  # type: ignore[arg-type]
                    suggested_item_type=str(suggested_type_raw) if suggested_type_raw else None,  # type: ignore[arg-type]
                )
            )

        # item_candidates ì¶”ì¶œ
        item_candidates: list[ItemCandidate] = []
        raw_items: list[dict[str, Any]] = data.get("item_candidates") or []  # type: ignore[assignment]
        for i, item in enumerate(raw_items[:10]):  # ìµœëŒ€ 10ê°œ
            if not isinstance(item, dict):  # type: ignore[reportUnnecessaryIsInstance]
                continue

            id_val = item.get("id")
            label_val = item.get("label")
            desc_val = item.get("description")
            type_val = item.get("item_type")
            source_idx = item.get("source_object_index")

            item_candidates.append(
                ItemCandidate(
                    id=str(id_val) if id_val else f"item_{uuid.uuid4().hex[:8]}",
                    label=str(label_val) if label_val else f"Item_{i}",
                    description=str(desc_val) if desc_val else "",
                    item_type=str(type_val) if type_val else "material",
                    source_object_index=int(source_idx) if source_idx is not None else None,  # type: ignore[arg-type]
                )
            )

        return ScanResult(
            status=ScanStatus.COMPLETED,
            caption=caption,
            objects=objects,
            item_candidates=item_candidates,
            message=None,
            analysis_time_ms=0,  # í˜¸ì¶œìì—ì„œ ì„¤ì •
        )

    except json.JSONDecodeError as e:
        logger.warning(
            "[ImageUnderstanding] JSON íŒŒì‹± ì‹¤íŒ¨",
            extra={"error": str(e)},
        )
        # ë¶€ë¶„ ê²°ê³¼ë¡œ ìº¡ì…˜ë§Œ ë°˜í™˜ (RULE-004)
        return ScanResult(
            status=ScanStatus.PARTIAL,
            caption=response_text[:500] if response_text else "",
            objects=[],
            item_candidates=[],
            message="ì˜¤ë¸Œì íŠ¸ ê°ì§€ ê²°ê³¼ë¥¼ íŒŒì‹±í•  ìˆ˜ ì—†ìŠµë‹ˆë‹¤. ìº¡ì…˜ë§Œ ì œê³µë©ë‹ˆë‹¤.",
            analysis_time_ms=0,
        )
    except Exception as e:
        logger.error(
            "[ImageUnderstanding] ì‘ë‹µ íŒŒì‹± ì¤‘ ì˜ˆì™¸",
            extra={"error_type": type(e).__name__},
        )
        return _create_fallback_result(f"ì‘ë‹µ ì²˜ë¦¬ ì¤‘ ì˜¤ë¥˜: {type(e).__name__}")


# =============================================================================
# ì´ë¯¸ì§€ ì´í•´ ì„œë¹„ìŠ¤ í´ë˜ìŠ¤
# =============================================================================


class ImageUnderstandingService:
    """ì´ë¯¸ì§€ ì´í•´ ì„œë¹„ìŠ¤.

    ë¹„ì „ ëª¨ë¸ì„ ì‚¬ìš©í•˜ì—¬ ì´ë¯¸ì§€ë¥¼ ë¶„ì„í•˜ê³ 
    ìº¡ì…˜, ì˜¤ë¸Œì íŠ¸, ì•„ì´í…œ í›„ë³´ë¥¼ ì¶”ì¶œí•©ë‹ˆë‹¤.
    """

    def __init__(
        self,
        *,
        force_mock: bool = False,
    ) -> None:
        """ImageUnderstandingServiceë¥¼ ì´ˆê¸°í™”í•©ë‹ˆë‹¤.

        Args:
            force_mock: Trueë©´ Mock ëª¨ë“œ ê°•ì œ
        """
        # ëª¨ë“œ ê²°ì •
        if force_mock:
            self._is_mock = True
        else:
            mode_str = os.environ.get(ENV_UW_MODE, GenAIMode.REAL)
            self._is_mock = mode_str == GenAIMode.MOCK

        self._genai_client: Client | None = None

        # Real ëª¨ë“œì—ì„œë§Œ í´ë¼ì´ì–¸íŠ¸ ì´ˆê¸°í™”
        if not self._is_mock:
            self._initialize_client()

        logger.info(
            "[ImageUnderstanding] ì„œë¹„ìŠ¤ ì´ˆê¸°í™”",
            extra={"mode": "mock" if self._is_mock else "real"},
        )

    def _initialize_client(self) -> None:
        """google-genai í´ë¼ì´ì–¸íŠ¸ë¥¼ ì´ˆê¸°í™”í•©ë‹ˆë‹¤."""
        try:
            from google.genai import Client

            # Vertex AI ëª¨ë“œë¡œ í´ë¼ì´ì–¸íŠ¸ ì´ˆê¸°í™”
            project = os.environ.get("VERTEX_PROJECT")
            location = os.environ.get("VERTEX_LOCATION", "us-central1")

            client_options: dict[str, Any] = {}
            if project:
                client_options["project"] = project
            if location:
                client_options["location"] = location

            self._genai_client = Client(vertexai=True, **client_options)

            logger.info(
                "[ImageUnderstanding] Vertex AI í´ë¼ì´ì–¸íŠ¸ ì´ˆê¸°í™” ì™„ë£Œ",
                extra={
                    "project": project or "(ADC ê¸°ë³¸)",
                    "location": location,
                },
            )
        except Exception as e:
            logger.warning(
                "[ImageUnderstanding] í´ë¼ì´ì–¸íŠ¸ ì´ˆê¸°í™” ì‹¤íŒ¨ - Mock ëª¨ë“œë¡œ ì „í™˜",
                extra={"error_type": type(e).__name__},
            )
            self._is_mock = True
            self._genai_client = None

    @property
    def is_mock(self) -> bool:
        """Mock ëª¨ë“œ ì—¬ë¶€."""
        return self._is_mock

    async def analyze(
        self,
        image_content: bytes,
        content_type: str,
        language: Language = Language.KO,
        *,
        preserve_original: bool = False,
        session_id: str | None = None,
    ) -> ScanResult:
        """ì´ë¯¸ì§€ë¥¼ ë¶„ì„í•©ë‹ˆë‹¤.

        Args:
            image_content: ì´ë¯¸ì§€ ë°”ì´íŠ¸ ë°ì´í„°
            content_type: MIME íƒ€ì…
            language: ì‘ë‹µ ì–¸ì–´
            preserve_original: ì›ë³¸ ì´ë¯¸ì§€ ì €ì¥ ì—¬ë¶€ (RU-006-S1)
            session_id: ì„¸ì…˜ ID (ì €ì¥ ì‹œ ê·¸ë£¹í™”ìš©)

        Returns:
            ScanResult: ë¶„ì„ ê²°ê³¼ (ì €ì¥ ì‹œ original_image_key/url í¬í•¨)
        """
        start_time = time.time()

        # ì´ë¯¸ì§€ ê²€ì¦
        validation_error = validate_image(image_content, content_type)
        if validation_error:
            return _create_fallback_result(validation_error)

        # ì›ë³¸ ì´ë¯¸ì§€ ì €ì¥ (ì„ íƒì , RU-006-S1)
        original_image_key: str | None = None
        original_image_url: str | None = None

        if preserve_original:
            try:
                from unknown_world.storage import StorageCategory, get_storage

                storage = get_storage()
                put_result = await storage.put(
                    data=image_content,
                    category=StorageCategory.UPLOADED_IMAGE,
                    content_type=content_type,
                    session_id=session_id,
                )

                if put_result.success:
                    original_image_key = put_result.key
                    original_image_url = put_result.url
                    logger.debug(
                        "[ImageUnderstanding] ì›ë³¸ ì´ë¯¸ì§€ ì €ì¥ ì™„ë£Œ",
                        extra={
                            "key": original_image_key,
                            "size_kb": len(image_content) // 1024,
                        },
                    )
            except Exception as e:
                # ì €ì¥ ì‹¤íŒ¨í•´ë„ ë¶„ì„ì€ ê³„ì† (RULE-004)
                logger.warning(
                    "[ImageUnderstanding] ì›ë³¸ ì´ë¯¸ì§€ ì €ì¥ ì‹¤íŒ¨",
                    extra={"error_type": type(e).__name__},
                )

        # Mock ëª¨ë“œ ì²˜ë¦¬
        if self._is_mock:
            logger.debug("[ImageUnderstanding] Mock ë¶„ì„ ìˆ˜í–‰")
            result = _create_mock_scan_result(language)
            result.analysis_time_ms = int((time.time() - start_time) * 1000)
            result.original_image_key = original_image_key
            result.original_image_url = original_image_url
            return result

        # ì‹¤ì œ ë¹„ì „ ëª¨ë¸ í˜¸ì¶œ
        try:
            result = await self._call_vision_model(
                image_content,
                content_type,
                language,
            )
            result.analysis_time_ms = int((time.time() - start_time) * 1000)
            result.original_image_key = original_image_key
            result.original_image_url = original_image_url
            return result

        except Exception as e:
            error_type = type(e).__name__
            logger.error(
                "[ImageUnderstanding] ë¹„ì „ ëª¨ë¸ í˜¸ì¶œ ì‹¤íŒ¨",
                extra={"error_type": error_type},
            )
            # ì•ˆì „í•œ í´ë°± (RULE-004)
            return _create_fallback_result(f"ì´ë¯¸ì§€ ë¶„ì„ ì¤‘ ì˜¤ë¥˜ê°€ ë°œìƒí–ˆìŠµë‹ˆë‹¤: {error_type}")

    async def _call_vision_model(
        self,
        image_content: bytes,
        content_type: str,
        language: Language,
    ) -> ScanResult:
        """ë¹„ì „ ëª¨ë¸ì„ í˜¸ì¶œí•©ë‹ˆë‹¤.

        Args:
            image_content: ì´ë¯¸ì§€ ë°”ì´íŠ¸ ë°ì´í„°
            content_type: MIME íƒ€ì…
            language: ì‘ë‹µ ì–¸ì–´

        Returns:
            ScanResult: ë¶„ì„ ê²°ê³¼
        """
        if self._genai_client is None:
            return _create_fallback_result("ë¹„ì „ í´ë¼ì´ì–¸íŠ¸ê°€ ì´ˆê¸°í™”ë˜ì§€ ì•Šì•˜ìŠµë‹ˆë‹¤")

        # í”„ë¡¬í”„íŠ¸ ì„ íƒ
        prompt_text = SCAN_PROMPTS.get(language, SCAN_PROMPT_KO)

        # ëª¨ë¸ ID ì¡°íšŒ
        model_id = get_model_id(ModelLabel.VISION)

        logger.debug(
            "[ImageUnderstanding] ë¹„ì „ ëª¨ë¸ í˜¸ì¶œ",
            extra={
                "model_id": model_id,
                "language": language.value,
                "image_size_kb": len(image_content) // 1024,
            },
        )

        # google-genai SDK í˜¸ì¶œ (ë©€í‹°ëª¨ë‹¬ ì…ë ¥)
        from google.genai.types import Content, GenerateContentConfig, Part

        # ë©€í‹°ëª¨ë‹¬ ì…ë ¥ êµ¬ì„± (ì´ë¯¸ì§€ ë¨¼ì €, í…ìŠ¤íŠ¸ ë’¤ì— - PRD 8.6 ê¶Œì¥)
        contents = [
            Content(
                parts=[
                    Part.from_bytes(
                        data=image_content,
                        mime_type=content_type,
                    ),
                    Part.from_text(text=prompt_text),
                ]
            )
        ]

        # JSON ì‘ë‹µ ê°•ì œ
        config = GenerateContentConfig(
            response_mime_type="application/json",
        )

        response = await self._genai_client.aio.models.generate_content(  # type: ignore[reportUnknownMemberType]
            model=model_id,
            contents=contents,
            config=config,
        )

        # ì‘ë‹µ í…ìŠ¤íŠ¸ ì¶”ì¶œ
        response_text: str = ""
        if hasattr(response, "text") and response.text:
            response_text = str(response.text)
        else:
            response_text = str(response)

        if not response_text:
            return _create_fallback_result("ëª¨ë¸ ì‘ë‹µì´ ë¹„ì–´ìˆìŠµë‹ˆë‹¤")

        # ì‘ë‹µ íŒŒì‹±
        return _parse_vision_response(response_text, language)


# =============================================================================
# íŒ©í† ë¦¬ í•¨ìˆ˜
# =============================================================================

# ì‹±ê¸€í†¤ ì¸ìŠ¤í„´ìŠ¤ ìºì‹œ
_service_instance: ImageUnderstandingService | None = None


def get_image_understanding_service(
    *,
    force_new: bool = False,
) -> ImageUnderstandingService:
    """ImageUnderstandingService ì¸ìŠ¤í„´ìŠ¤ë¥¼ ë°˜í™˜í•©ë‹ˆë‹¤.

    ì‹±ê¸€í†¤ íŒ¨í„´ìœ¼ë¡œ ë™ì‘í•©ë‹ˆë‹¤.

    Args:
        force_new: Trueë©´ ìºì‹œë¥¼ ë¬´ì‹œí•˜ê³  ìƒˆ ì¸ìŠ¤í„´ìŠ¤ ìƒì„±

    Returns:
        ImageUnderstandingService ì¸ìŠ¤í„´ìŠ¤
    """
    global _service_instance

    if not force_new and _service_instance is not None:
        return _service_instance

    _service_instance = ImageUnderstandingService()
    return _service_instance


def reset_image_understanding_service() -> None:
    """ImageUnderstandingService ìºì‹œë¥¼ ì´ˆê¸°í™”í•©ë‹ˆë‹¤.

    í…ŒìŠ¤íŠ¸ ì‹œ ì„œë¹„ìŠ¤ë¥¼ ì¬ì„¤ì •í•  ë•Œ ì‚¬ìš©í•©ë‹ˆë‹¤.
    """
    global _service_instance
    _service_instance = None
</file>

<file path="backend/src/unknown_world/storage/__init__.py">
"""Unknown World - ìŠ¤í† ë¦¬ì§€ ëª¨ë“ˆ.

ìŠ¤í† ë¦¬ì§€ ì¶”ìƒí™” ê³„ì¸µì„ ì œê³µí•©ë‹ˆë‹¤.
MVP: LocalStorage, MMP: GCSStorage(ì˜ˆì •)

ì°¸ì¡°:
    - vibe/refactors/RU-006-Q4.md
    - vibe/refactors/RU-006-Q5.md
"""

from unknown_world.storage.local_storage import LocalStorage
from unknown_world.storage.paths import (
    ARTIFACTS_SUBDIR,
    BASE_DATA_DIR,
    DEFAULT_IMAGE_EXTENSION,
    IMAGES_GENERATED_SUBDIR,
    IMAGES_UPLOADED_SUBDIR,
    LEGACY_OUTPUT_DIR,
    STATIC_IMAGES_URL_PREFIX,
    STATIC_URL_PREFIX,
    build_image_url,
    build_legacy_image_url,
    get_artifacts_dir,
    get_generated_images_dir,
    get_uploaded_images_dir,
)
from unknown_world.storage.storage import (
    PutResult,
    StorageCategory,
    StorageInterface,
    StorageMetadata,
)
from unknown_world.storage.validation import (
    ALLOWED_IMAGE_MIME_TYPES,
    BBOX_MAX,
    BBOX_MIN,
    DEFAULT_ASPECT_RATIO,
    DEFAULT_IMAGE_SIZE,
    MAX_IMAGE_FILE_SIZE_BYTES,
    MAX_PROMPT_LENGTH,
    MIN_IMAGE_FILE_SIZE_BYTES,
    MIN_PROMPT_LENGTH,
    SUPPORTED_IMAGE_SIZES,
    get_max_file_size_mb,
    validate_image_generation_request,
    validate_image_upload,
)

__all__ = [
    # Storage
    "LocalStorage",
    "PutResult",
    "StorageCategory",
    "StorageInterface",
    "StorageMetadata",
    "get_storage",
    "reset_storage",
    # Paths (RU-006-Q5)
    "ARTIFACTS_SUBDIR",
    "BASE_DATA_DIR",
    "DEFAULT_IMAGE_EXTENSION",
    "IMAGES_GENERATED_SUBDIR",
    "IMAGES_UPLOADED_SUBDIR",
    "LEGACY_OUTPUT_DIR",
    "STATIC_IMAGES_URL_PREFIX",
    "STATIC_URL_PREFIX",
    "build_image_url",
    "build_legacy_image_url",
    "get_artifacts_dir",
    "get_generated_images_dir",
    "get_uploaded_images_dir",
    # Validation constants
    "ALLOWED_IMAGE_MIME_TYPES",
    "BBOX_MAX",
    "BBOX_MIN",
    "DEFAULT_ASPECT_RATIO",
    "DEFAULT_IMAGE_SIZE",
    "MAX_IMAGE_FILE_SIZE_BYTES",
    "MAX_PROMPT_LENGTH",
    "MIN_IMAGE_FILE_SIZE_BYTES",
    "MIN_PROMPT_LENGTH",
    "SUPPORTED_IMAGE_SIZES",
    # Validation functions
    "get_max_file_size_mb",
    "validate_image_generation_request",
    "validate_image_upload",
]

# ì‹±ê¸€í†¤ ì¸ìŠ¤í„´ìŠ¤ ìºì‹œ
_storage_instance: StorageInterface | None = None


def get_storage(*, force_new: bool = False) -> StorageInterface:
    """ìŠ¤í† ë¦¬ì§€ ì¸ìŠ¤í„´ìŠ¤ë¥¼ ë°˜í™˜í•©ë‹ˆë‹¤.

    í™˜ê²½ë³€ìˆ˜ì— ë”°ë¼ LocalStorage ë˜ëŠ” GCSStorageë¥¼ ë°˜í™˜í•©ë‹ˆë‹¤.
    MVPì—ì„œëŠ” LocalStorageë§Œ ì‚¬ìš©í•©ë‹ˆë‹¤.

    Args:
        force_new: Trueë©´ ìºì‹œë¥¼ ë¬´ì‹œí•˜ê³  ìƒˆ ì¸ìŠ¤í„´ìŠ¤ ìƒì„±

    Returns:
        StorageInterface êµ¬í˜„ì²´
    """
    global _storage_instance

    if not force_new and _storage_instance is not None:
        return _storage_instance

    # MVP: LocalStorageë§Œ ì‚¬ìš©
    # MMP: í™˜ê²½ë³€ìˆ˜ë¡œ GCS ì „í™˜ ì˜ˆì •
    _storage_instance = LocalStorage()
    return _storage_instance


def reset_storage() -> None:
    """ìŠ¤í† ë¦¬ì§€ ìºì‹œë¥¼ ì´ˆê¸°í™”í•©ë‹ˆë‹¤.

    í…ŒìŠ¤íŠ¸ ì‹œ ìŠ¤í† ë¦¬ì§€ë¥¼ ì¬ì„¤ì •í•  ë•Œ ì‚¬ìš©í•©ë‹ˆë‹¤.
    """
    global _storage_instance
    _storage_instance = None
</file>

<file path="backend/src/unknown_world/validation/business_rules.py">
"""Unknown World - ë¹„ì¦ˆë‹ˆìŠ¤ ë£° ê²€ì¦ê¸° (Hard Gate).

ìŠ¤í‚¤ë§ˆ ê²€ì¦ ì´í›„ì—ë„ ë‚¨ëŠ” "ì˜ë¯¸ì  ì‹¤íŒ¨"ë¥¼ ê²€ì¦í•©ë‹ˆë‹¤:
- Economy: cost/balance_after ì¼ê´€ì„±, ì”ì•¡ ìŒìˆ˜ ê¸ˆì§€
- Language: TurnInput.languageì™€ TurnOutput.language ë¶ˆì¼ì¹˜ ì°¨ë‹¨
- Box2D: 0~1000 ë²”ìœ„ + [ymin,xmin,ymax,xmax] ìˆœì„œ ê²€ì¦
- Safety: blocked ì‹œ ì•ˆì „í•œ ëŒ€ì²´ ê²°ê³¼ ì œê³µ í™•ì¸

ì„¤ê³„ ì›ì¹™:
    - RULE-003: êµ¬ì¡°í™” ì¶œë ¥(JSON Schema) ìš°ì„  + ì´ì¤‘ ê²€ì¦
    - RULE-004: ê²€ì¦ ì‹¤íŒ¨ ì‹œ Repair loop + ì•ˆì „í•œ í´ë°±
    - RULE-005: ì¬í™” ì¸ë°”ë¦¬ì–¸íŠ¸ (ì”ì•¡ ìŒìˆ˜ ê¸ˆì§€)
    - RULE-006: ko/en ì–¸ì–´ ì •ì±… ì¤€ìˆ˜
    - RULE-009: ì¢Œí‘œ ê·œì•½ (0~1000, bbox [ymin,xmin,ymax,xmax])

ì°¸ì¡°:
    - vibe/unit-plans/U-018[Mvp].md
    - vibe/unit-results/U-017[Mvp].md
"""

from __future__ import annotations

import logging
from dataclasses import dataclass, field
from enum import StrEnum
from typing import TYPE_CHECKING

from unknown_world.models.turn import Language
from unknown_world.validation.language_gate import (
    LanguageGateResult,
    build_language_error_summary,
    validate_language_consistency,
)

if TYPE_CHECKING:
    from unknown_world.models.turn import TurnInput, TurnOutput

# =============================================================================
# ë¡œê±° ì„¤ì •
# =============================================================================

logger = logging.getLogger(__name__)


# =============================================================================
# i18n ì—ëŸ¬ ë©”ì‹œì§€ (RULE-006: ko/en ì–¸ì–´ ì •ì±… ì¤€ìˆ˜)
# =============================================================================

BUSINESS_RULE_MESSAGES: dict[Language, dict[str, str]] = {
    Language.KO: {
        "summary_header": "ë‹¤ìŒ ë¹„ì¦ˆë‹ˆìŠ¤ ë£°ì„ ìœ„ë°˜í–ˆìŠµë‹ˆë‹¤:",
        "signal_insufficient": "Signal ì¬í™”ê°€ ë¶€ì¡±í•©ë‹ˆë‹¤: ë³´ìœ  {have}, í•„ìš” {need}",
        "memory_shard_insufficient": "Memory Shard ì¬í™”ê°€ ë¶€ì¡±í•©ë‹ˆë‹¤: ë³´ìœ  {have}, í•„ìš” {need}",
        "signal_negative": "Signal ì”ì•¡ì´ ìŒìˆ˜ì…ë‹ˆë‹¤: {value}",
        "memory_shard_negative": "Memory Shard ì”ì•¡ì´ ìŒìˆ˜ì…ë‹ˆë‹¤: {value}",
        "signal_mismatch": "Signal ì”ì•¡ ë¶ˆì¼ì¹˜: ì˜ˆìƒ {expected}, ì‹¤ì œ {actual}",
        "memory_shard_mismatch": "Memory Shard ì”ì•¡ ë¶ˆì¼ì¹˜: ì˜ˆìƒ {expected}, ì‹¤ì œ {actual}",
        "language_mismatch": "ì–¸ì–´ ë¶ˆì¼ì¹˜: ì…ë ¥ {input_lang}, ì¶œë ¥ {output_lang}",
        "language_content_mixed": "ì–¸ì–´ í˜¼í•© ê°ì§€: {violation_count}ê°œ í•„ë“œì—ì„œ ko/en í˜¼í•© ë°œê²¬",
        "box2d_out_of_range": "ì˜¤ë¸Œì íŠ¸ '{obj_id}'ì˜ ì¢Œí‘œê°€ ë²”ìœ„ë¥¼ ë²—ì–´ë‚¨: {coord}",
        "box2d_invalid_yorder": "ì˜¤ë¸Œì íŠ¸ '{obj_id}'ì˜ ymin({ymin}) >= ymax({ymax})",
        "box2d_invalid_xorder": "ì˜¤ë¸Œì íŠ¸ '{obj_id}'ì˜ xmin({xmin}) >= xmax({xmax})",
        "safety_blocked_no_fallback": "ì•ˆì „ ì •ì±…ì— ì˜í•´ ì°¨ë‹¨ë˜ì—ˆì§€ë§Œ ëŒ€ì²´ í…ìŠ¤íŠ¸ê°€ ì—†ìŠµë‹ˆë‹¤",
    },
    Language.EN: {
        "summary_header": "The following business rules were violated:",
        "signal_insufficient": "Insufficient Signal: have {have}, need {need}",
        "memory_shard_insufficient": "Insufficient Memory Shard: have {have}, need {need}",
        "signal_negative": "Signal balance is negative: {value}",
        "memory_shard_negative": "Memory Shard balance is negative: {value}",
        "signal_mismatch": "Signal balance mismatch: expected {expected}, actual {actual}",
        "memory_shard_mismatch": "Memory Shard balance mismatch: expected {expected}, actual {actual}",
        "language_mismatch": "Language mismatch: input {input_lang}, output {output_lang}",
        "language_content_mixed": "Language mixing detected: {violation_count} fields contain ko/en mixing",
        "box2d_out_of_range": "Object '{obj_id}' coordinate out of range: {coord}",
        "box2d_invalid_yorder": "Object '{obj_id}' ymin({ymin}) >= ymax({ymax})",
        "box2d_invalid_xorder": "Object '{obj_id}' xmin({xmin}) >= xmax({xmax})",
        "safety_blocked_no_fallback": "Blocked by safety policy but no fallback text provided",
    },
}


# =============================================================================
# ì—ëŸ¬ íƒ€ì…
# =============================================================================


class BusinessRuleError(StrEnum):
    """ë¹„ì¦ˆë‹ˆìŠ¤ ë£° ìœ„ë°˜ íƒ€ì…."""

    # Economy ê·œì¹™ (RULE-005)
    ECONOMY_NEGATIVE_BALANCE = "economy_negative_balance"
    """ì”ì•¡ì´ ìŒìˆ˜ì…ë‹ˆë‹¤ (ê¸ˆì§€)"""

    ECONOMY_COST_MISMATCH = "economy_cost_mismatch"
    """ë¹„ìš©ê³¼ ì”ì•¡ ë³€í™”ê°€ ì¼ì¹˜í•˜ì§€ ì•ŠìŠµë‹ˆë‹¤"""

    ECONOMY_COST_MISSING = "economy_cost_missing"
    """ë¹„ìš© ì •ë³´ê°€ ëˆ„ë½ë˜ì—ˆìŠµë‹ˆë‹¤"""

    # Language ê·œì¹™ (RULE-006)
    LANGUAGE_MISMATCH = "language_mismatch"
    """ì…ë ¥ê³¼ ì¶œë ¥ ì–¸ì–´ê°€ ì¼ì¹˜í•˜ì§€ ì•ŠìŠµë‹ˆë‹¤"""

    LANGUAGE_CONTENT_MIXED = "language_content_mixed"
    """ì‚¬ìš©ì ë…¸ì¶œ í…ìŠ¤íŠ¸ì— ko/enì´ í˜¼í•©ë˜ì–´ ìˆìŠµë‹ˆë‹¤ (U-043)"""

    # Box2D ê·œì¹™ (RULE-009)
    BOX2D_OUT_OF_RANGE = "box2d_out_of_range"
    """ì¢Œí‘œê°€ 0~1000 ë²”ìœ„ë¥¼ ë²—ì–´ë‚¬ìŠµë‹ˆë‹¤"""

    BOX2D_INVALID_ORDER = "box2d_invalid_order"
    """bbox ìˆœì„œê°€ ì˜¬ë°”ë¥´ì§€ ì•ŠìŠµë‹ˆë‹¤ (ymin < ymax, xmin < xmax í•„ìš”)"""

    # Safety ê·œì¹™
    SAFETY_BLOCKED_NO_FALLBACK = "safety_blocked_no_fallback"
    """ì°¨ë‹¨ë˜ì—ˆì§€ë§Œ ì•ˆì „í•œ ëŒ€ì²´ ê²°ê³¼ê°€ ì œê³µë˜ì§€ ì•Šì•˜ìŠµë‹ˆë‹¤"""


# =============================================================================
# ê²€ì¦ ê²°ê³¼ íƒ€ì…
# =============================================================================


@dataclass
class BusinessRuleValidationResult:
    """ë¹„ì¦ˆë‹ˆìŠ¤ ë£° ê²€ì¦ ê²°ê³¼.

    Attributes:
        is_valid: ëª¨ë“  ê²€ì¦ í†µê³¼ ì—¬ë¶€
        errors: ë°œê²¬ëœ ìœ„ë°˜ ëª©ë¡
        error_summary: ì—ëŸ¬ ìš”ì•½ (Repair í”„ë¡¬í”„íŠ¸ìš©)
        language: ì‘ë‹µ ì–¸ì–´ (RULE-006)
        language_gate_result: ì–¸ì–´ í˜¼í•© ê²€ì¦ ê²°ê³¼ (U-043)
    """

    is_valid: bool = True
    errors: list[dict[str, str]] = field(default_factory=lambda: [])
    error_summary: str = ""
    language: Language = Language.KO
    language_gate_result: LanguageGateResult | None = None

    def add_error(self, error_type: BusinessRuleError, message: str) -> None:
        """ì—ëŸ¬ë¥¼ ì¶”ê°€í•©ë‹ˆë‹¤."""
        self.is_valid = False
        self.errors.append({"type": error_type.value, "message": message})

    def build_summary(self) -> str:
        """ì—ëŸ¬ ìš”ì•½ì„ ìƒì„±í•©ë‹ˆë‹¤ (Repair í”„ë¡¬í”„íŠ¸ìš©).

        ì–¸ì–´ì— ë”°ë¼ í—¤ë” ë©”ì‹œì§€ë¥¼ ë¶„ê¸°í•©ë‹ˆë‹¤ (RULE-006).
        ì–¸ì–´ í˜¼í•© ì—ëŸ¬ê°€ ìˆìœ¼ë©´ ìƒì„¸ ì§€ì‹œë¥¼ ì¶”ê°€í•©ë‹ˆë‹¤ (U-043).
        """
        if not self.errors:
            self.error_summary = ""
            return ""

        messages = BUSINESS_RULE_MESSAGES[self.language]
        summary_lines = [messages["summary_header"]]
        for err in self.errors:
            summary_lines.append(f"- {err['message']}")

        # U-043: ì–¸ì–´ í˜¼í•© ì—ëŸ¬ê°€ ìˆìœ¼ë©´ ìƒì„¸ ì§€ì‹œ ì¶”ê°€
        if self.language_gate_result and not self.language_gate_result.is_valid:
            summary_lines.append("")
            summary_lines.append(build_language_error_summary(self.language_gate_result))

        self.error_summary = "\n".join(summary_lines)
        return self.error_summary


# =============================================================================
# ê°œë³„ ê²€ì¦ í•¨ìˆ˜
# =============================================================================


def _validate_economy(
    turn_input: TurnInput,
    turn_output: TurnOutput,
    result: BusinessRuleValidationResult,
) -> None:
    """Economy ê·œì¹™ì„ ê²€ì¦í•©ë‹ˆë‹¤ (RULE-005).

    ê²€ì¦ í•­ëª©:
    - ì”ì•¡ ìŒìˆ˜ ê¸ˆì§€
    - snapshot ëŒ€ë¹„ ê³¼ë„í•œ ë¹„ìš© ì²­êµ¬ ê¸ˆì§€
    - costì™€ balance_after ì¼ê´€ì„±
    """
    economy = turn_output.economy
    snapshot = turn_input.economy_snapshot
    messages = BUSINESS_RULE_MESSAGES[result.language]

    # 1. ê³¼ë„í•œ ë¹„ìš© ì²­êµ¬ ê¸ˆì§€ (snapshot < cost)
    if snapshot.signal < economy.cost.signal:
        result.add_error(
            BusinessRuleError.ECONOMY_NEGATIVE_BALANCE,
            messages["signal_insufficient"].format(have=snapshot.signal, need=economy.cost.signal),
        )

    if snapshot.memory_shard < economy.cost.memory_shard:
        result.add_error(
            BusinessRuleError.ECONOMY_NEGATIVE_BALANCE,
            messages["memory_shard_insufficient"].format(
                have=snapshot.memory_shard, need=economy.cost.memory_shard
            ),
        )

    # 2. ì”ì•¡ ìŒìˆ˜ ê¸ˆì§€ (ì´ë¯¸ í•„ë“œ ìˆ˜ì¤€ ge=0 ê²€ì¦ì´ ìˆì§€ë§Œ, ë¹„ì¦ˆë‹ˆìŠ¤ ë£°ì—ì„œë„ ëª…ì‹œ)
    if economy.balance_after.signal < 0:
        result.add_error(
            BusinessRuleError.ECONOMY_NEGATIVE_BALANCE,
            messages["signal_negative"].format(value=economy.balance_after.signal),
        )

    if economy.balance_after.memory_shard < 0:
        result.add_error(
            BusinessRuleError.ECONOMY_NEGATIVE_BALANCE,
            messages["memory_shard_negative"].format(value=economy.balance_after.memory_shard),
        )

    # 3. costì™€ balance_after ì¼ê´€ì„± ê²€ì¦
    # balance_after = snapshot - cost ì—¬ì•¼ í•¨
    expected_signal = snapshot.signal - economy.cost.signal
    expected_shard = snapshot.memory_shard - economy.cost.memory_shard

    # ì´ë¯¸ ìœ„ì—ì„œ snapshot < cost ì²´í¬ë¥¼ í–ˆìœ¼ë¯€ë¡œ,
    # ì—¬ê¸°ì„œëŠ” ë‹¨ìˆœ ì¼ì¹˜ ì—¬ë¶€ë§Œ í™•ì¸ (ìŒìˆ˜ ê²°ê³¼ëŠ” ìœ„ì—ì„œ ì°¨ë‹¨ë¨)
    if economy.balance_after.signal != expected_signal:
        result.add_error(
            BusinessRuleError.ECONOMY_COST_MISMATCH,
            messages["signal_mismatch"].format(
                expected=expected_signal, actual=economy.balance_after.signal
            ),
        )

    if economy.balance_after.memory_shard != expected_shard:
        result.add_error(
            BusinessRuleError.ECONOMY_COST_MISMATCH,
            messages["memory_shard_mismatch"].format(
                expected=expected_shard, actual=economy.balance_after.memory_shard
            ),
        )


def _validate_language(
    turn_input: TurnInput,
    turn_output: TurnOutput,
    result: BusinessRuleValidationResult,
) -> None:
    """Language ê·œì¹™ì„ ê²€ì¦í•©ë‹ˆë‹¤ (RULE-006).

    ê²€ì¦ í•­ëª©:
    - TurnInput.languageì™€ TurnOutput.language ì¼ì¹˜
    """
    if turn_input.language != turn_output.language:
        messages = BUSINESS_RULE_MESSAGES[result.language]
        result.add_error(
            BusinessRuleError.LANGUAGE_MISMATCH,
            messages["language_mismatch"].format(
                input_lang=turn_input.language.value,
                output_lang=turn_output.language.value,
            ),
        )


def _validate_language_content(
    turn_input: TurnInput,
    turn_output: TurnOutput,
    result: BusinessRuleValidationResult,
) -> None:
    """Language ì½˜í…ì¸  í˜¼í•©ì„ ê²€ì¦í•©ë‹ˆë‹¤ (RULE-006, U-043).

    ê²€ì¦ í•­ëª©:
    - ì‚¬ìš©ì ë…¸ì¶œ í…ìŠ¤íŠ¸ê°€ TurnInput.languageì™€ ë™ì¼ ì–¸ì–´ì¸ì§€ í™•ì¸
    - ko/en í˜¼í•© ì‹œ LANGUAGE_CONTENT_MIXED ì—ëŸ¬ ì¶”ê°€
    """
    # ì–¸ì–´ í˜¼í•© ê²€ì¦ (U-043)
    lang_result = validate_language_consistency(turn_output, turn_input.language)

    if not lang_result.is_valid:
        messages = BUSINESS_RULE_MESSAGES[result.language]
        result.add_error(
            BusinessRuleError.LANGUAGE_CONTENT_MIXED,
            messages["language_content_mixed"].format(violation_count=len(lang_result.violations)),
        )
        # ìƒì„¸ ì—ëŸ¬ ìš”ì•½ ìƒì„±ì„ ìœ„í•´ ê²°ê³¼ ì €ì¥
        result.language_gate_result = lang_result


def _validate_box2d(
    turn_output: TurnOutput,
    result: BusinessRuleValidationResult,
) -> None:
    """Box2D ì¢Œí‘œ ê·œì¹™ì„ ê²€ì¦í•©ë‹ˆë‹¤ (RULE-009).

    ê²€ì¦ í•­ëª©:
    - 0~1000 ë²”ìœ„
    - ymin < ymax, xmin < xmax ìˆœì„œ
    """
    messages = BUSINESS_RULE_MESSAGES[result.language]

    # UI ì˜¤ë¸Œì íŠ¸ì˜ box2d ê²€ì¦
    for obj in turn_output.ui.objects:
        box = obj.box_2d

        # ë²”ìœ„ ê²€ì¦ (0~1000)
        coords = [box.ymin, box.xmin, box.ymax, box.xmax]
        for coord in coords:
            if coord < 0 or coord > 1000:
                result.add_error(
                    BusinessRuleError.BOX2D_OUT_OF_RANGE,
                    messages["box2d_out_of_range"].format(obj_id=obj.id, coord=coord),
                )
                break  # í•œ ì˜¤ë¸Œì íŠ¸ì— ëŒ€í•´ í•œ ë²ˆë§Œ ë³´ê³ 

        # ìˆœì„œ ê²€ì¦ (ymin < ymax, xmin < xmax)
        if box.ymin >= box.ymax:
            result.add_error(
                BusinessRuleError.BOX2D_INVALID_ORDER,
                messages["box2d_invalid_yorder"].format(
                    obj_id=obj.id, ymin=box.ymin, ymax=box.ymax
                ),
            )

        if box.xmin >= box.xmax:
            result.add_error(
                BusinessRuleError.BOX2D_INVALID_ORDER,
                messages["box2d_invalid_xorder"].format(
                    obj_id=obj.id, xmin=box.xmin, xmax=box.xmax
                ),
            )


def _validate_safety(
    turn_output: TurnOutput,
    result: BusinessRuleValidationResult,
) -> None:
    """Safety ê·œì¹™ì„ ê²€ì¦í•©ë‹ˆë‹¤.

    ê²€ì¦ í•­ëª©:
    - blocked ì‹œ ì•ˆì „í•œ ëŒ€ì²´ ê²°ê³¼(narrative) ì œê³µ í™•ì¸
    """
    safety = turn_output.safety
    messages = BUSINESS_RULE_MESSAGES[result.language]

    # ì°¨ë‹¨ ì‹œì—ë„ narrativeê°€ ìˆì–´ì•¼ í•¨ (ì•ˆì „í•œ ëŒ€ì²´ ê²°ê³¼)
    if safety.blocked and (not turn_output.narrative or len(turn_output.narrative.strip()) == 0):
        result.add_error(
            BusinessRuleError.SAFETY_BLOCKED_NO_FALLBACK,
            messages["safety_blocked_no_fallback"],
        )


# =============================================================================
# ë©”ì¸ ê²€ì¦ í•¨ìˆ˜
# =============================================================================


def validate_business_rules(
    turn_input: TurnInput,
    turn_output: TurnOutput,
) -> BusinessRuleValidationResult:
    """ë¹„ì¦ˆë‹ˆìŠ¤ ë£°ì„ ê²€ì¦í•©ë‹ˆë‹¤.

    ìŠ¤í‚¤ë§ˆ ê²€ì¦ ì´í›„ í˜¸ì¶œë˜ë©°, ì˜ë¯¸ì  ê·œì¹™ì„ ê²€ì¦í•©ë‹ˆë‹¤.
    ì—ëŸ¬ ë©”ì‹œì§€ëŠ” turn_input.languageì— ë”°ë¼ ë¶„ê¸°ë©ë‹ˆë‹¤ (RULE-006).

    Args:
        turn_input: ì‚¬ìš©ì í„´ ì…ë ¥
        turn_output: ìƒì„±ëœ í„´ ì¶œë ¥

    Returns:
        BusinessRuleValidationResult: ê²€ì¦ ê²°ê³¼

    Example:
        >>> result = validate_business_rules(turn_input, turn_output)
        >>> if not result.is_valid:
        ...     print(result.build_summary())
    """
    # RU-005-S2: turn_input.languageì— ë”°ë¼ ì—ëŸ¬ ë©”ì‹œì§€ i18n ë¶„ê¸°
    result = BusinessRuleValidationResult(language=turn_input.language)

    # 1. Economy ê²€ì¦ (RULE-005)
    _validate_economy(turn_input, turn_output, result)

    # 2. Language enum ê²€ì¦ (RULE-006)
    _validate_language(turn_input, turn_output, result)

    # 3. Language ì½˜í…ì¸  í˜¼í•© ê²€ì¦ (RULE-006, U-043)
    _validate_language_content(turn_input, turn_output, result)

    # 4. Box2D ê²€ì¦ (RULE-009)
    _validate_box2d(turn_output, result)

    # 5. Safety ê²€ì¦
    _validate_safety(turn_output, result)

    # ì—ëŸ¬ ìš”ì•½ ìƒì„±
    if not result.is_valid:
        result.build_summary()
        logger.warning(
            "[BusinessRules] ê²€ì¦ ì‹¤íŒ¨",
            extra={"error_count": len(result.errors)},
        )

    return result
</file>

<file path="backend/tests/integration/test_turn_streaming.py">
"""Unknown World - /api/turn HTTP Streaming í†µí•© í…ŒìŠ¤íŠ¸.

NDJSON ìŠ¤íŠ¸ë¦¬ë° ì´ë²¤íŠ¸ì˜ ìˆœì„œ, êµ¬ì¡°, ë°ì´í„° ì •ë°€ë„ë¥¼ ê²€ì¦í•©ë‹ˆë‹¤.
"""

import json

from fastapi.testclient import TestClient

from unknown_world.main import app
from unknown_world.models.turn import Language, TurnOutput

client = TestClient(app)


def test_turn_streaming_success():
    """ì •ìƒì ì¸ í„´ ìš”ì²­ ì‹œ NDJSON ìŠ¤íŠ¸ë¦¼ì´ ì˜¬ë°”ë¥¸ ìˆœì„œë¡œ ë°˜í™˜ë˜ëŠ”ì§€ í…ŒìŠ¤íŠ¸í•©ë‹ˆë‹¤."""
    payload = {
        "language": "ko-KR",
        "text": "í…ŒìŠ¤íŠ¸ ì…ë ¥",
        "client": {"viewport_w": 1920, "viewport_h": 1080, "theme": "dark"},
        "economy_snapshot": {"signal": 100, "memory_shard": 5},
    }

    # StreamingResponse í…ŒìŠ¤íŠ¸
    response = client.post("/api/turn", json=payload)
    assert response.status_code == 200
    assert response.headers["content-type"] == "application/x-ndjson"

    events = []
    for line in response.iter_lines():
        if line:
            events.append(json.loads(line))

    # 1. ì´ë²¤íŠ¸ ì¡´ì¬ ì—¬ë¶€ í™•ì¸
    assert len(events) > 0

    # 2. ì²« ë²ˆì§¸ ì´ë²¤íŠ¸ëŠ” í•­ìƒ stage: parse: start ì—¬ì•¼ í•¨ (TTFB)
    assert events[0]["type"] == "stage"
    assert events[0]["name"] == "parse"
    assert events[0]["status"] == "start"

    # 3. ë‹¨ê³„ë³„ ì´ë²¤íŠ¸ ìˆœì„œ í™•ì¸
    stages = [e["name"] for e in events if e["type"] == "stage" and e["status"] == "start"]
    expected_stages = ["parse", "validate", "plan", "resolve", "render", "verify", "commit"]
    assert stages == expected_stages

    # 4. ë°°ì§€ ì´ë²¤íŠ¸ í¬í•¨ ì—¬ë¶€ í™•ì¸
    badges_events = [e for e in events if e["type"] == "badges"]
    assert len(badges_events) >= 2
    assert "schema_ok" in badges_events[0]["badges"]

    # 5. ìµœì¢… ê²°ê³¼ë¬¼ í™•ì¸
    final_events = [e for e in events if e["type"] == "final"]
    assert len(final_events) == 1

    turn_output_data = final_events[0]["data"]
    # Pydantic ëª¨ë¸ë¡œ ë‹¤ì‹œ ê²€ì¦ (RULE-003)
    turn_output = TurnOutput.model_validate(turn_output_data)
    assert turn_output.language == Language.KO
    assert len(turn_output.narrative) > 0


def test_turn_streaming_invalid_input():
    """ì˜ëª»ëœ ì…ë ¥ ìš”ì²­ ì‹œ ì—ëŸ¬ ì´ë²¤íŠ¸ê°€ ìŠ¤íŠ¸ë¦¬ë°ë˜ëŠ”ì§€ í…ŒìŠ¤íŠ¸í•©ë‹ˆë‹¤."""
    payload = {
        "language": "invalid-lang",  # ì˜ëª»ëœ ì–¸ì–´ ì½”ë“œ
        "text": "",
    }

    response = client.post("/api/turn", json=payload)
    # ì…ë ¥ ê²€ì¦ ì‹¤íŒ¨ ì‹œì—ë„ 200 OK ìŠ¤íŠ¸ë¦¼ìœ¼ë¡œ ì—ëŸ¬ë¥¼ ë³´ë‚¼ ìˆ˜ë„ ìˆê³ ,
    # 400 Bad Requestë¥¼ ë³´ë‚¼ ìˆ˜ë„ ìˆìŒ. í˜„ì¬ êµ¬í˜„ì€ 200 OK + type: error ì„.
    assert response.status_code == 200

    events = [json.loads(line) for line in response.iter_lines() if line]
    assert any(e["type"] == "error" for e in events)
    assert any(e["code"] == "VALIDATION_ERROR" for e in events)


def test_turn_streaming_deterministic_seed():
    """seed íŒŒë¼ë¯¸í„° ì‚¬ìš© ì‹œ ê²°ê³¼ê°€ ê²°ì •ì ì¸ì§€ í…ŒìŠ¤íŠ¸í•©ë‹ˆë‹¤."""
    payload = {
        "language": "en-US",
        "text": "Hello",
        "client": {"viewport_w": 1920, "viewport_h": 1080},
        "economy_snapshot": {"signal": 100, "memory_shard": 5},
    }

    # ë™ì¼í•œ ì‹œë“œë¡œ ë‘ ë²ˆ ìš”ì²­
    seed = 12345

    def get_final_output(s):
        resp = client.post(f"/api/turn?seed={s}", json=payload)
        events = [json.loads(line) for line in resp.iter_lines() if line]
        return next(e["data"] for e in events if e["type"] == "final")

    output1 = get_final_output(seed)
    output2 = get_final_output(seed)

    assert output1 == output2
    assert output1["language"] == "en-US"


def test_turn_streaming_generation_fallback(monkeypatch):
    """ìƒì„± ì¤‘ ValidationError ë°œìƒ ì‹œ ì•ˆì „í•œ í´ë°±ì´ ë°˜í™˜ë˜ëŠ”ì§€ í…ŒìŠ¤íŠ¸í•©ë‹ˆë‹¤."""
    from pydantic import ValidationError

    from unknown_world.orchestrator.mock import MockOrchestrator

    def mock_generate_failure(self, turn_input):
        # Pydantic ValidationErrorë¥¼ ìˆ˜ë™ìœ¼ë¡œ ìƒì„±í•˜ëŠ” ê²ƒì€ ë³µì¡í•˜ë¯€ë¡œ
        # ê°„ë‹¨í•œ í•„ë“œ ê²€ì¦ ì˜¤ë¥˜ë¥¼ ì‹œë®¬ë ˆì´ì…˜í•˜ê±°ë‚˜ ì§ì ‘ raise í•¨
        # ì—¬ê¸°ì„œëŠ” í…ŒìŠ¤íŠ¸ë¥¼ ìœ„í•´ ì„ì˜ì˜ í•„ë“œ ëˆ„ë½ ë“±ìœ¼ë¡œ ë°œìƒí•œë‹¤ê³  ê°€ì •
        raise ValidationError.from_exception_data(title="MockError", line_errors=[])

    monkeypatch.setattr(MockOrchestrator, "generate_turn_output", mock_generate_failure)

    payload = {
        "language": "ko-KR",
        "text": "í…ŒìŠ¤íŠ¸",
        "client": {"viewport_w": 1920, "viewport_h": 1080},
        "economy_snapshot": {"signal": 100, "memory_shard": 5},
    }

    response = client.post("/api/turn", json=payload)
    events = [json.loads(line) for line in response.iter_lines() if line]

    final_event = next(e for e in events if e["type"] == "final")
    turn_output = final_event["data"]

    # í´ë°± ì‘ë‹µì˜ íŠ¹ì§• í™•ì¸
    # RU-005-Q1: SSOT fallbackì€ ëª¨ë“  ì¹´í…Œê³ ë¦¬ì˜ ë°°ì§€ë¥¼ ì¼ê´€ë˜ê²Œ í¬í•¨ (RU-005-S1)
    badges = turn_output["agent_console"]["badges"]
    assert "schema_fail" in badges, "í´ë°±ì€ schema_fail ë°°ì§€ë¥¼ í¬í•¨í•´ì•¼ í•¨"
    assert "economy_ok" in badges, "í´ë°±ì€ economy_ok ë°°ì§€ë¥¼ í¬í•¨í•´ì•¼ í•¨ (ë¹„ìš© 0)"
    assert "safety_ok" in badges, "í´ë°±ì€ safety_ok ë°°ì§€ë¥¼ í¬í•¨í•´ì•¼ í•¨"
    assert "consistency_ok" in badges, "í´ë°±ì€ consistency_ok ë°°ì§€ë¥¼ í¬í•¨í•´ì•¼ í•¨"
    assert turn_output["agent_console"]["repair_count"] >= 1
    assert "í˜¼ë€" in turn_output["narrative"] or "confusion" in turn_output["narrative"]


def test_turn_streaming_repair_loop(monkeypatch):
    """ê²€ì¦ ì‹¤íŒ¨ ì‹œ repair ì´ë²¤íŠ¸ê°€ ìŠ¤íŠ¸ë¦¼ì— í¬í•¨ë˜ëŠ”ì§€ í…ŒìŠ¤íŠ¸í•©ë‹ˆë‹¤ (RU-002)."""
    from pydantic import ValidationError

    from unknown_world.orchestrator.mock import MockOrchestrator

    # ì²« ë²ˆì§¸ í˜¸ì¶œì—ì„œ ì‹¤íŒ¨í•˜ì—¬ repair íŠ¸ë¦¬ê±° ì‹œë®¬ë ˆì´ì…˜
    # (ì‹¤ì œ êµ¬í˜„ì—ì„œëŠ” NíšŒ ì¬ì‹œë„ ë¡œì§ì´ turn.pyì— ìˆì–´ì•¼ í•¨)
    call_count = 0

    def mock_generate_with_repair(self, turn_input):
        nonlocal call_count
        call_count += 1
        if call_count == 1:
            raise ValidationError.from_exception_data(title="MockSchemaError", line_errors=[])
        return orchestrator_orig_generate(self, turn_input)

    import unknown_world.orchestrator.mock as mock_mod

    orchestrator_orig_generate = mock_mod.MockOrchestrator.generate_turn_output
    monkeypatch.setattr(MockOrchestrator, "generate_turn_output", mock_generate_with_repair)

    payload = {
        "language": "ko-KR",
        "text": "ë¦¬í˜ì–´ í…ŒìŠ¤íŠ¸",
        "client": {"viewport_w": 1920, "viewport_h": 1080},
        "economy_snapshot": {"signal": 100, "memory_shard": 5},
    }

    response = client.post("/api/turn", json=payload)
    events = [json.loads(line) for line in response.iter_lines() if line]

    # RU-002 ìš”êµ¬ì‚¬í•­: repair ì´ë²¤íŠ¸ê°€ ëª…ì‹œì ìœ¼ë¡œ ì¡´ì¬í•´ì•¼ í•¨
    repair_events = [e for e in events if e["type"] == "repair"]
    assert len(repair_events) >= 1
    assert "attempt" in repair_events[0]
    assert repair_events[0]["attempt"] == 1
</file>

<file path="backend/tests/unit/test_u034_verification.py">
import json
from pathlib import Path

# í”„ë¡œì íŠ¸ ë£¨íŠ¸ ê²½ë¡œ ì„¤ì • (backend/tests/unit/ ìœ„ì¹˜ ê¸°ì¤€)
ROOT_DIR = Path(__file__).parent.parent.parent.parent
SCHEMA_PATH = ROOT_DIR / "vibe/ref/nanobanana-asset-request.schema.json"
GUIDE_PATH = ROOT_DIR / "vibe/ref/nanobanana-mcp.md"


def test_schema_file_exists():
    """ìŠ¤í‚¤ë§ˆ íŒŒì¼ì´ ì§€ì •ëœ ìœ„ì¹˜ì— ì¡´ì¬í•˜ëŠ”ì§€ í™•ì¸"""
    assert SCHEMA_PATH.exists(), f"Schema file not found at {SCHEMA_PATH}"


def test_schema_is_valid_json():
    """ìŠ¤í‚¤ë§ˆ íŒŒì¼ì´ ìœ íš¨í•œ JSON í˜•ì‹ì¸ì§€ í™•ì¸"""
    with open(SCHEMA_PATH, encoding="utf-8") as f:
        schema = json.load(f)
    assert schema["title"] == "nanobanana mcp Asset Request Schema"


def test_schema_required_properties():
    """ìŠ¤í‚¤ë§ˆì˜ JSON Schema required í•„ë“œê°€ ì •ì˜ë˜ì–´ ìˆëŠ”ì§€ í™•ì¸

    NOTE: JSON Schemaì˜ `required` ë°°ì—´ê³¼ "ì›Œí¬í”Œë¡œìš° í•„ìˆ˜(ì¡°ê±´ë¶€)" í•„ë“œëŠ” êµ¬ë¶„ë¨.
    - Schema required: ["id", "category", "purpose", "size_px"] (SSOT)
    - Workflow required: requires_rembg, rembg_options.model ë“±ì€ ì¡°ê±´ë¶€ í•„ë“œ
    """
    with open(SCHEMA_PATH, encoding="utf-8") as f:
        schema = json.load(f)

    properties = schema.get("properties", {})
    # JSON Schemaì˜ required í•„ë“œë§Œ ê²€ì¦ (ìŠ¤í‚¤ë§ˆ SSOT ê¸°ì¤€)
    schema_required_fields = ["id", "category", "purpose", "size_px"]
    # ì›Œí¬í”Œë¡œìš°ì—ì„œ ìì£¼ ì‚¬ìš©í•˜ëŠ” ì„ íƒì  í•„ë“œ (propertiesì— ì •ì˜ë˜ì–´ ìˆì–´ì•¼ í•¨)
    optional_workflow_fields = ["requires_rembg", "rembg_options"]

    for field in schema_required_fields:
        assert field in properties, f"Schema required field '{field}' missing in properties"

    for field in optional_workflow_fields:
        assert field in properties, f"Workflow field '{field}' missing in properties"


def test_schema_rembg_options_model():
    """rembg ëª¨ë¸ ì„ íƒì˜ SSOTê°€ rembg_options.modelì¸ì§€ í™•ì¸

    NOTE: ì´ì „ì— top-level rembg_model í•„ë“œê°€ ë…¼ì˜ë˜ì—ˆìœ¼ë‚˜,
    SSOTëŠ” rembg_options.modelë¡œ í™•ì •ë¨ (U-040 í˜ì–´ë§ ê²°ì •).
    """
    with open(SCHEMA_PATH, encoding="utf-8") as f:
        schema = json.load(f)

    # rembg_optionsê°€ ì¡´ì¬í•˜ê³  model ì„œë¸Œí•„ë“œê°€ ìˆì–´ì•¼ í•¨
    rembg_options = schema["properties"].get("rembg_options", {})
    assert rembg_options.get("type") == "object", "rembg_options should be an object"

    rembg_options_props = rembg_options.get("properties", {})
    assert "model" in rembg_options_props, (
        "SSOT field 'rembg_options.model' missing - "
        "rembg ëª¨ë¸ ì„ íƒì€ top-level 'rembg_model'ì´ ì•„ë‹Œ 'rembg_options.model'ì´ SSOTì…ë‹ˆë‹¤"
    )

    # model í•„ë“œì˜ enumì´ ìœ íš¨í•œ rembg ëª¨ë¸ ëª©ë¡ì„ í¬í•¨í•˜ëŠ”ì§€ í™•ì¸
    model_field = rembg_options_props["model"]
    assert "enum" in model_field, "rembg_options.model should have enum constraint"
    assert "birefnet-general" in model_field["enum"], (
        "Default model 'birefnet-general' should be in enum"
    )


def test_guide_file_exists():
    """ê°€ì´ë“œ ë¬¸ì„œ íŒŒì¼ì´ ì¡´ì¬í•˜ëŠ”ì§€ í™•ì¸"""
    assert GUIDE_PATH.exists(), f"Guide file not found at {GUIDE_PATH}"


def test_guide_content_completeness():
    """ê°€ì´ë“œ ë¬¸ì„œì— í•„ìˆ˜ ì„¹ì…˜(ì•„íŠ¸ ë””ë ‰ì…˜, ì¹´í…Œê³ ë¦¬ë³„ í…œí”Œë¦¿)ì´ í¬í•¨ë˜ì–´ ìˆëŠ”ì§€ í™•ì¸"""
    with open(GUIDE_PATH, encoding="utf-8") as f:
        content = f.read()

    # ê³„íšì„œ êµ¬í˜„ íë¦„ 2ë‹¨ê³„, 3ë‹¨ê³„ ê´€ë ¨ í‚¤ì›Œë“œ ê²€ì‚¬
    required_keywords = ["ì•„íŠ¸ ë””ë ‰ì…˜", "ìŠ¤íƒ€ì¼", "ì•„ì´ì½˜", "placeholder", "chrome", "í…œí”Œë¦¿"]

    missing_keywords = [kw for kw in required_keywords if kw.lower() not in content.lower()]

    # í˜„ì¬ nanobanana-mcp.mdì—ëŠ” rembg ë‚´ìš©ë§Œ ìˆìœ¼ë¯€ë¡œ ì‹¤íŒ¨í•  ê°€ëŠ¥ì„±ì´ í¼
    assert not missing_keywords, (
        f"Guide document is missing sections for: {', '.join(missing_keywords)}"
    )


def test_schema_rembg_rules():
    """ë°°ê²½ ì œê±°(rembg) ê´€ë ¨ ê°•ì œ ê·œì¹™(ìˆœë°± ë°°ê²½)ì´ ìŠ¤í‚¤ë§ˆ/ì„¤ëª…ì— í¬í•¨ë˜ì–´ ìˆëŠ”ì§€ í™•ì¸"""
    with open(SCHEMA_PATH, encoding="utf-8") as f:
        schema = json.load(f)

    # background í•„ë“œì™€ requires_rembg í•„ë“œ ì„¤ëª… í™•ì¸
    background_desc = schema["properties"]["background"].get("description", "")
    rembg_desc = schema["properties"]["requires_rembg"].get("description", "")

    assert "solid_white" in str(schema["properties"]["background"].get("enum", [])), (
        "background enum should include solid_white"
    )
    assert "rembg" in background_desc.lower(), "background description should mention rembg"
    assert "solid_white" in rembg_desc.lower(), (
        "requires_rembg description should recommend solid_white"
    )
</file>

<file path="frontend/src/data/demoProfiles.ts">
/**
 * Unknown World - ë°ëª¨ í”„ë¡œí•„ ì •ì˜ (U-015[Mvp]).
 *
 * ë¡œê·¸ì¸ ì—†ì´ ì¦‰ì‹œ ì‹œì‘ ê°€ëŠ¥í•œ ë°ëª¨ í”„ë¡œí•„ 3ì¢…ì„ ì •ì˜í•©ë‹ˆë‹¤.
 * ê° í”„ë¡œí•„ì€ ì„œë¡œ ë‹¤ë¥¸ ì´ˆê¸° ìƒíƒœ(ì¬í™”/ì¸ë²¤í† ë¦¬/í€˜ìŠ¤íŠ¸/ë£°)ë¥¼ ê°€ì§‘ë‹ˆë‹¤.
 *
 * í”„ë¡œí•„:
 *   1. Narrator: ë‚´ëŸ¬í‹°ë¸Œ/ìŠ¤í† ë¦¬ ì¤‘ì‹¬ ì²´í—˜
 *   2. Explorer: íƒìƒ‰/ë°œê²¬ ì¤‘ì‹¬ ì²´í—˜
 *   3. Tech Enthusiast: ì‹œìŠ¤í…œ/ë©”ì»¤ë‹‰ ì¤‘ì‹¬ ì²´í—˜
 *
 * ì„¤ê³„ ì›ì¹™:
 *   - RULE-006: í‘œì‹œ ë¬¸ìì—´ì€ i18n í‚¤ ê¸°ë°˜
 *   - RULE-010: SaveGame JSON ì§ë ¬í™”ë¡œ ì €ì¥
 *   - PRD 6.9: ë°ëª¨ í”„ë¡œí•„ 3ì¢… + ì¦‰ì‹œ ë¦¬ì…‹
 *   - RU-004-Q5: seed ìƒì„±ì€ constants.ts SSOT ì‚¬ìš©
 *
 * @module data/demoProfiles
 */

import type { SupportedLanguage } from '../i18n';
import type { SaveGame, SaveGameInput } from '../save/saveGame';
import { createSaveGame } from '../save/saveGame';
// RU-004-Q5: seed ìƒì„± ì •ì±… SSOT
import { generateDemoSeed } from '../save/constants';

// =============================================================================
// í”„ë¡œí•„ íƒ€ì… ì •ì˜
// =============================================================================

/**
 * ë°ëª¨ í”„ë¡œí•„ ì •ì˜ (ì–¸ì–´ ì¤‘ë¦½).
 * í‘œì‹œìš© ë¬¸ìì—´ì€ i18n í‚¤ë¡œ ì°¸ì¡°í•©ë‹ˆë‹¤.
 */
export interface DemoProfileDef {
  /** í”„ë¡œí•„ ê³ ìœ  ID */
  id: string;
  /** í”„ë¡œí•„ ì´ë¦„ i18n í‚¤ */
  nameKey: string;
  /** í”„ë¡œí•„ ì„¤ëª… i18n í‚¤ */
  descriptionKey: string;
  /** í”„ë¡œí•„ ì•„ì´ì½˜ (ì´ëª¨ì§€) */
  icon: string;
  /** í”„ë¡œí•„ í…Œë§ˆ ìƒ‰ìƒ (CSS ë³€ìˆ˜ëª… ë˜ëŠ” hex) */
  themeColor: string;
}

/**
 * í”„ë¡œí•„ ì´ˆê¸° ìƒíƒœ.
 * SaveGameìœ¼ë¡œ ë³€í™˜ ê°€ëŠ¥í•œ êµ¬ì¡°ì…ë‹ˆë‹¤.
 */
export interface DemoProfileInitialState {
  /** ì´ˆê¸° ì¬í™” */
  economy: {
    signal: number;
    memory_shard: number;
  };
  /** ì´ˆê¸° ì¸ë²¤í† ë¦¬ ì•„ì´í…œ ì •ì˜ (IDì™€ i18n í‚¤) */
  inventoryDefs: Array<{
    id: string;
    nameKey: string;
    icon: string;
    quantity: number;
  }>;
  /** ì´ˆê¸° í€˜ìŠ¤íŠ¸ ì •ì˜ */
  questDefs: Array<{
    id: string;
    labelKey: string;
    is_completed: boolean;
  }>;
  /** ì´ˆê¸° ê·œì¹™ ì •ì˜ */
  ruleDefs: Array<{
    id: string;
    labelKey: string;
    descriptionKey?: string;
  }>;
  /** ì´ˆê¸° Scene Objects ì •ì˜ */
  sceneObjectDefs: Array<{
    id: string;
    labelKey: string;
    hintKey: string;
    box_2d: {
      ymin: number;
      xmin: number;
      ymax: number;
      xmax: number;
    };
  }>;
  /** í™˜ì˜ ë©”ì‹œì§€ i18n í‚¤ */
  welcomeMessageKey: string;
}

/**
 * ë°ëª¨ í”„ë¡œí•„ ì „ì²´ ì •ì˜.
 */
export interface DemoProfile extends DemoProfileDef {
  initialState: DemoProfileInitialState;
}

// =============================================================================
// ë°ëª¨ í”„ë¡œí•„ ì •ì˜ (3ì¢…)
// =============================================================================

/**
 * Narrator í”„ë¡œí•„: ë‚´ëŸ¬í‹°ë¸Œ/ìŠ¤í† ë¦¬ ì¤‘ì‹¬ ì²´í—˜.
 * í’ë¶€í•œ ì¬í™”ë¡œ ë‹¤ì–‘í•œ ì„ íƒì§€ë¥¼ íƒìƒ‰í•  ìˆ˜ ìˆìŠµë‹ˆë‹¤.
 */
export const PROFILE_NARRATOR: DemoProfile = {
  id: 'narrator',
  nameKey: 'profile.narrator.name',
  descriptionKey: 'profile.narrator.description',
  icon: 'ğŸ“–',
  themeColor: 'var(--accent-color)',
  initialState: {
    economy: {
      signal: 200,
      memory_shard: 10,
    },
    inventoryDefs: [
      {
        id: 'ancient-tome',
        nameKey: 'profile.narrator.items.ancient_tome',
        icon: 'ğŸ“•',
        quantity: 1,
      },
      { id: 'quill-pen', nameKey: 'profile.narrator.items.quill_pen', icon: 'ğŸ–‹ï¸', quantity: 1 },
      {
        id: 'memory-fragment',
        nameKey: 'profile.narrator.items.memory_fragment',
        icon: 'ğŸ’ ',
        quantity: 3,
      },
    ],
    questDefs: [
      {
        id: 'quest-discover-origin',
        labelKey: 'profile.narrator.quest.discover_origin',
        is_completed: false,
      },
      {
        id: 'quest-collect-memories',
        labelKey: 'profile.narrator.quest.collect_memories',
        is_completed: false,
      },
    ],
    ruleDefs: [
      {
        id: 'rule-time-flows',
        labelKey: 'profile.narrator.rule.time_flows',
        descriptionKey: 'profile.narrator.rule.time_flows_desc',
      },
      {
        id: 'rule-memories-persist',
        labelKey: 'profile.narrator.rule.memories_persist',
        descriptionKey: 'profile.narrator.rule.memories_persist_desc',
      },
    ],
    sceneObjectDefs: [
      {
        id: 'mysterious-bookshelf',
        labelKey: 'profile.narrator.scene.bookshelf',
        hintKey: 'profile.narrator.scene.bookshelf_hint',
        box_2d: { ymin: 200, xmin: 100, ymax: 700, xmax: 400 },
      },
      {
        id: 'glowing-portal',
        labelKey: 'profile.narrator.scene.portal',
        hintKey: 'profile.narrator.scene.portal_hint',
        box_2d: { ymin: 300, xmin: 600, ymax: 800, xmax: 900 },
      },
    ],
    welcomeMessageKey: 'profile.narrator.welcome',
  },
};

/**
 * Explorer í”„ë¡œí•„: íƒìƒ‰/ë°œê²¬ ì¤‘ì‹¬ ì²´í—˜.
 * ì ë‹¹í•œ ì¬í™”ì™€ íƒìƒ‰ ë„êµ¬ë¡œ ìƒˆë¡œìš´ ì˜ì—­ì„ ë°œê²¬í•©ë‹ˆë‹¤.
 */
export const PROFILE_EXPLORER: DemoProfile = {
  id: 'explorer',
  nameKey: 'profile.explorer.name',
  descriptionKey: 'profile.explorer.description',
  icon: 'ğŸ§­',
  themeColor: 'var(--text-color)',
  initialState: {
    economy: {
      signal: 150,
      memory_shard: 5,
    },
    inventoryDefs: [
      { id: 'compass', nameKey: 'profile.explorer.items.compass', icon: 'ğŸ§­', quantity: 1 },
      { id: 'rope', nameKey: 'profile.explorer.items.rope', icon: 'ğŸª¢', quantity: 2 },
      { id: 'lantern', nameKey: 'profile.explorer.items.lantern', icon: 'ğŸ®', quantity: 1 },
      {
        id: 'map-fragment',
        nameKey: 'profile.explorer.items.map_fragment',
        icon: 'ğŸ—ºï¸',
        quantity: 1,
      },
    ],
    questDefs: [
      { id: 'quest-find-exit', labelKey: 'profile.explorer.quest.find_exit', is_completed: false },
      {
        id: 'quest-explore-areas',
        labelKey: 'profile.explorer.quest.explore_areas',
        is_completed: false,
      },
      {
        id: 'quest-gather-supplies',
        labelKey: 'profile.explorer.quest.gather_supplies',
        is_completed: true,
      },
    ],
    ruleDefs: [
      {
        id: 'rule-gravity',
        labelKey: 'profile.explorer.rule.gravity',
        descriptionKey: 'profile.explorer.rule.gravity_desc',
      },
      {
        id: 'rule-darkness',
        labelKey: 'profile.explorer.rule.darkness',
        descriptionKey: 'profile.explorer.rule.darkness_desc',
      },
    ],
    sceneObjectDefs: [
      {
        id: 'ancient-door',
        labelKey: 'profile.explorer.scene.door',
        hintKey: 'profile.explorer.scene.door_hint',
        box_2d: { ymin: 150, xmin: 400, ymax: 850, xmax: 600 },
      },
      {
        id: 'strange-mechanism',
        labelKey: 'profile.explorer.scene.mechanism',
        hintKey: 'profile.explorer.scene.mechanism_hint',
        box_2d: { ymin: 500, xmin: 100, ymax: 700, xmax: 300 },
      },
      {
        id: 'hidden-passage',
        labelKey: 'profile.explorer.scene.passage',
        hintKey: 'profile.explorer.scene.passage_hint',
        box_2d: { ymin: 600, xmin: 700, ymax: 800, xmax: 950 },
      },
    ],
    welcomeMessageKey: 'profile.explorer.welcome',
  },
};

/**
 * Tech Enthusiast í”„ë¡œí•„: ì‹œìŠ¤í…œ/ë©”ì»¤ë‹‰ ì¤‘ì‹¬ ì²´í—˜.
 * ì œí•œëœ ì¬í™”ë¡œ íš¨ìœ¨ì ì¸ ì „ëµì„ ì„¸ì›Œì•¼ í•©ë‹ˆë‹¤.
 */
export const PROFILE_TECH: DemoProfile = {
  id: 'tech',
  nameKey: 'profile.tech.name',
  descriptionKey: 'profile.tech.description',
  icon: 'âš™ï¸',
  themeColor: 'var(--warning-color)',
  initialState: {
    economy: {
      signal: 80,
      memory_shard: 15,
    },
    inventoryDefs: [
      { id: 'data-core', nameKey: 'profile.tech.items.data_core', icon: 'ğŸ’¿', quantity: 1 },
      { id: 'circuit-board', nameKey: 'profile.tech.items.circuit_board', icon: 'ğŸ”Œ', quantity: 2 },
      { id: 'energy-cell', nameKey: 'profile.tech.items.energy_cell', icon: 'ğŸ”‹', quantity: 3 },
      { id: 'scanner-device', nameKey: 'profile.tech.items.scanner', icon: 'ğŸ“¡', quantity: 1 },
    ],
    questDefs: [
      {
        id: 'quest-analyze-system',
        labelKey: 'profile.tech.quest.analyze_system',
        is_completed: false,
      },
      {
        id: 'quest-optimize-resources',
        labelKey: 'profile.tech.quest.optimize_resources',
        is_completed: false,
      },
    ],
    ruleDefs: [
      {
        id: 'rule-energy-conservation',
        labelKey: 'profile.tech.rule.energy_conservation',
        descriptionKey: 'profile.tech.rule.energy_conservation_desc',
      },
      {
        id: 'rule-data-integrity',
        labelKey: 'profile.tech.rule.data_integrity',
        descriptionKey: 'profile.tech.rule.data_integrity_desc',
      },
      {
        id: 'rule-system-limits',
        labelKey: 'profile.tech.rule.system_limits',
        descriptionKey: 'profile.tech.rule.system_limits_desc',
      },
    ],
    sceneObjectDefs: [
      {
        id: 'main-terminal',
        labelKey: 'profile.tech.scene.terminal',
        hintKey: 'profile.tech.scene.terminal_hint',
        box_2d: { ymin: 200, xmin: 300, ymax: 600, xmax: 700 },
      },
      {
        id: 'power-conduit',
        labelKey: 'profile.tech.scene.conduit',
        hintKey: 'profile.tech.scene.conduit_hint',
        box_2d: { ymin: 100, xmin: 50, ymax: 400, xmax: 200 },
      },
    ],
    welcomeMessageKey: 'profile.tech.welcome',
  },
};

/**
 * ëª¨ë“  ë°ëª¨ í”„ë¡œí•„ ëª©ë¡.
 */
export const DEMO_PROFILES: readonly DemoProfile[] = [
  PROFILE_NARRATOR,
  PROFILE_EXPLORER,
  PROFILE_TECH,
] as const;

/**
 * í”„ë¡œí•„ IDë¡œ í”„ë¡œí•„ì„ ì°¾ìŠµë‹ˆë‹¤.
 */
export function findProfileById(profileId: string): DemoProfile | undefined {
  return DEMO_PROFILES.find((p) => p.id === profileId);
}

// =============================================================================
// í”„ë¡œí•„ â†’ SaveGameInput ë³€í™˜ (RU-004-Q1: SSOT ë‹¨ì¼í™”)
// =============================================================================

/**
 * ë°ëª¨ í”„ë¡œí•„ì„ SaveGameInputìœ¼ë¡œ ë³€í™˜í•©ë‹ˆë‹¤.
 *
 * RU-004-Q1: SaveGame ìƒì„±ì€ createSaveGame(SSOT)ë§Œ ìˆ˜í–‰í•˜ë„ë¡ ë¶„ë¦¬.
 * ì´ í•¨ìˆ˜ëŠ” "ì…ë ¥ ë³€í™˜(input adapter)" ì—­í• ë§Œ ë‹´ë‹¹í•©ë‹ˆë‹¤.
 *
 * @param profile - ë°ëª¨ í”„ë¡œí•„
 * @param language - ì–¸ì–´ ì„¤ì •
 * @param t - i18n ë²ˆì—­ í•¨ìˆ˜
 * @returns SaveGameInput ê°ì²´ (createSaveGameì— ì „ë‹¬ ê°€ëŠ¥)
 */
export function profileToSaveGameInput(
  profile: DemoProfile,
  language: SupportedLanguage,
  t: (key: string) => string,
): SaveGameInput {
  const now = Date.now();

  return {
    language,
    profileId: profile.id,
    // RU-004-Q5: seed ìƒì„± ì •ì±… SSOT (constants.ts)
    seed: generateDemoSeed(profile.id),
    economy: {
      signal: profile.initialState.economy.signal,
      memory_shard: profile.initialState.economy.memory_shard,
    },
    economyLedger: [],
    turnCount: 0,
    narrativeHistory: [
      {
        turn: 0,
        text: t(profile.initialState.welcomeMessageKey),
      },
    ],
    inventory: profile.initialState.inventoryDefs.map((item) => ({
      id: item.id,
      name: t(item.nameKey),
      icon: item.icon,
      quantity: item.quantity,
    })),
    quests: profile.initialState.questDefs.map((quest) => ({
      id: quest.id,
      label: t(quest.labelKey),
      is_completed: quest.is_completed,
    })),
    activeRules: profile.initialState.ruleDefs.map((rule) => ({
      id: rule.id,
      label: t(rule.labelKey),
      description: rule.descriptionKey ? t(rule.descriptionKey) : null,
    })),
    mutationTimeline: profile.initialState.ruleDefs.map((rule, index) => ({
      turn: 0,
      ruleId: rule.id,
      type: 'added' as const,
      label: t(rule.labelKey),
      description: rule.descriptionKey ? t(rule.descriptionKey) : undefined,
      timestamp: now - index * 1000,
    })),
    sceneObjects: profile.initialState.sceneObjectDefs.map((obj) => ({
      id: obj.id,
      label: t(obj.labelKey),
      box_2d: obj.box_2d,
      interaction_hint: t(obj.hintKey),
    })),
  };
}

/**
 * ë°ëª¨ í”„ë¡œí•„ì„ SaveGame í˜•íƒœë¡œ ë³€í™˜í•©ë‹ˆë‹¤.
 *
 * RU-004-Q1: createSaveGame(SSOT)ë¥¼ í˜¸ì¶œí•˜ëŠ” ì–‡ì€ wrapperì…ë‹ˆë‹¤.
 * ê¸°ì¡´ í˜¸ì¶œìì™€ì˜ í˜¸í™˜ì„±ì„ ìœ ì§€í•©ë‹ˆë‹¤.
 *
 * @param profile - ë°ëª¨ í”„ë¡œí•„
 * @param language - ì–¸ì–´ ì„¤ì •
 * @param t - i18n ë²ˆì—­ í•¨ìˆ˜
 * @returns SaveGame ê°ì²´
 */
export function createSaveGameFromProfile(
  profile: DemoProfile,
  language: SupportedLanguage,
  t: (key: string) => string,
): SaveGame {
  return createSaveGame(profileToSaveGameInput(profile, language, t));
}

/**
 * í”„ë¡œí•„ ëª©ë¡ ì •ë³´ë§Œ ê°€ì ¸ì˜µë‹ˆë‹¤ (ì„ íƒ UIìš©).
 */
export function getProfileSummaries(): Array<DemoProfileDef> {
  return DEMO_PROFILES.map((p) => ({
    id: p.id,
    nameKey: p.nameKey,
    descriptionKey: p.descriptionKey,
    icon: p.icon,
    themeColor: p.themeColor,
  }));
}
</file>

<file path="frontend/src/demo/useDemoInitializer.ts">
import { useEffect } from 'react';
import { useTranslation } from 'react-i18next';
import { useInventoryStore } from '../stores/inventoryStore';
import { useWorldStore } from '../stores/worldStore';
import type { Quest, WorldRule } from '../schemas/turn';
import type { MutationEvent } from '../stores/worldStore';
import {
  DEMO_INVENTORY_ITEMS,
  DEMO_SCENE_OBJECTS,
  DEMO_QUESTS,
  DEMO_RULES,
  getDemoItemNameKey,
  isDemoEnvironment,
} from '../demo/demoFixtures';

/**
 * ë°ëª¨ í™˜ê²½ì—ì„œ ì´ˆê¸° mock ë°ì´í„°ë¥¼ ë¡œë“œí•˜ëŠ” í›… (RU-003-Q5, U-013).
 */
export function useDemoInitializer() {
  const { t } = useTranslation();
  const { items: inventoryItems, addItems: addInventoryItems } = useInventoryStore();
  const worldStore = useWorldStore();
  const {
    sceneObjects,
    setSceneObjects,
    narrativeEntries,
    initialize: initializeWorld,
    quests,
    activeRules,
  } = worldStore;

  useEffect(() => {
    // ì›”ë“œ ì´ˆê¸°í™” (í™˜ì˜ ë©”ì‹œì§€)
    if (narrativeEntries.length === 0) {
      initializeWorld(t('narrative.welcome'));
    }

    // DEV: ë°ëª¨ìš© mock ë°ì´í„° ì´ˆê¸°í™” (RU-003-Q5: DEV ê°€ë“œ + i18n í‚¤ ê¸°ë°˜)
    if (isDemoEnvironment()) {
      // ë°ëª¨ìš© mock ì¸ë²¤í† ë¦¬ ì´ˆê¸°í™” (U-011)
      if (inventoryItems.length === 0) {
        const demoInventory = DEMO_INVENTORY_ITEMS.map((item) => ({
          id: item.id,
          name: t(getDemoItemNameKey(item.id)),
          icon: item.icon,
          quantity: item.quantity,
        }));
        addInventoryItems(demoInventory);
      }

      // ë°ëª¨ìš© mock Scene Objects ì´ˆê¸°í™” (U-010)
      if (sceneObjects.length === 0) {
        const demoSceneObjects = DEMO_SCENE_OBJECTS.map((obj) => ({
          id: obj.id,
          label: t(obj.labelKey),
          box_2d: obj.box_2d,
          interaction_hint: t(obj.hintKey),
        }));
        setSceneObjects(demoSceneObjects);
      }

      // ë°ëª¨ìš© mock í€˜ìŠ¤íŠ¸ ì´ˆê¸°í™” (U-013)
      if (quests.length === 0) {
        const demoQuests: Quest[] = DEMO_QUESTS.map((q) => ({
          id: q.id,
          label: t(q.labelKey),
          is_completed: q.is_completed,
        }));
        useWorldStore.setState({ quests: demoQuests });
      }

      // ë°ëª¨ìš© mock ê·œì¹™ ì´ˆê¸°í™” (U-013)
      if (activeRules.length === 0) {
        const demoRules: WorldRule[] = DEMO_RULES.map((r) => ({
          id: r.id,
          label: t(r.labelKey),
          description: r.descriptionKey ? t(r.descriptionKey) : null,
        }));
        // ë°ëª¨ ë®¤í…Œì´ì…˜ íƒ€ì„ë¼ì¸ ìƒì„± (ê·œì¹™ ì¶”ê°€ ì´ë²¤íŠ¸)
        const now = Date.now();
        const demoMutations: MutationEvent[] = DEMO_RULES.map((r, index) => ({
          turn: 0,
          ruleId: r.id,
          type: 'added' as const,
          label: t(r.labelKey),
          description: r.descriptionKey ? t(r.descriptionKey) : undefined,
          timestamp: now - index * 1000, // ì‹œê°„ ìˆœì„œ êµ¬ë¶„ìš©
        }));
        useWorldStore.setState({
          activeRules: demoRules,
          mutationTimeline: demoMutations,
        });
      }
    }
    // eslint-disable-next-line react-hooks/exhaustive-deps
  }, [t]);
}
</file>

<file path="frontend/src/save/sessionLifecycle.ts">
/**
 * Unknown World - ì„¸ì…˜ ë¼ì´í”„ì‚¬ì´í´ ê´€ë¦¬ ëª¨ë“ˆ (RU-004-Q4).
 *
 * ì„¸ì…˜ ì´ˆê¸°í™”/ë³µì›/ë¦¬ì…‹/ë³€ê²½ì„ SSOTë¡œ ê´€ë¦¬í•©ë‹ˆë‹¤.
 * App.tsxì˜ ì„¸ì…˜ ê´€ë ¨ ë¡œì§ì„ ì´ ëª¨ë“ˆë¡œ ì´ë™í•˜ì—¬ ì±…ì„ ê²½ê³„ë¥¼ ëª…í™•íˆ í•©ë‹ˆë‹¤.
 *
 * ì„¤ê³„ ì›ì¹™:
 *   - RULE-005: Economy ì¸ë°”ë¦¬ì–¸íŠ¸ (ì”ì•¡ ìŒìˆ˜ ê¸ˆì§€)
 *   - RULE-006: ko/en i18n ì •ì±… ì¤€ìˆ˜ (ì–¸ì–´ ì ìš© í›„ UI ë Œë”ë§)
 *   - RU-004-S1: ì–¸ì–´ async ì ìš© ì™„ë£Œ í›„ store ì£¼ì…
 *   - RU-004-S2: profileId SSOT + ìœ íš¨ SaveGameë§Œ Continue
 *
 * @module save/sessionLifecycle
 */

import {
  loadSaveGame,
  saveSaveGame,
  clearSaveGame,
  getValidSaveGameOrNull,
  createSaveGame,
  loadCurrentProfileId,
  saveCurrentProfileId,
  clearCurrentProfileId,
} from './saveGame';
import { findProfileById, createSaveGameFromProfile, type DemoProfile } from '../data/demoProfiles';
import {
  getResolvedLanguage,
  changeLanguage,
  type SupportedLanguage,
  DEFAULT_LANGUAGE,
} from '../i18n';
import { useWorldStore } from '../stores/worldStore';
import { useInventoryStore } from '../stores/inventoryStore';
import { useEconomyStore } from '../stores/economyStore';
import { useActionDeckStore } from '../stores/actionDeckStore';
import { useAgentStore } from '../stores/agentStore';

// =============================================================================
// íƒ€ì… ì •ì˜
// =============================================================================

/**
 * ë¶€íŒ… ê²°ê³¼ íƒ€ì….
 * ì•± ì‹œì‘ ì‹œ ì–´ë–¤ phaseë¡œ ì‹œì‘í• ì§€ ê²°ì •í•©ë‹ˆë‹¤.
 */
export type SessionBootstrap =
  | { phase: 'profile_select'; savedGameAvailable: boolean }
  | { phase: 'playing'; profileId: string | null };

/**
 * ì„¸ì…˜ ì‹œì‘ ê²°ê³¼ íƒ€ì….
 */
export interface SessionStartResult {
  success: true;
  profileId: string;
}

/**
 * ì„¸ì…˜ ë³µì› ê²°ê³¼ íƒ€ì….
 */
export interface SessionContinueResult {
  success: true;
  profileId: string;
}

/**
 * ì„¸ì…˜ ë¦¬ì…‹ ê²°ê³¼ íƒ€ì….
 */
export interface SessionResetResult {
  success: boolean;
  profileId: string | null;
}

// =============================================================================
// ë‚´ë¶€ í—¬í¼: ëª¨ë“  ì„¸ì…˜ ê´€ë ¨ storeë¥¼ ì´ˆê¸°í™”
// =============================================================================

/**
 * ëª¨ë“  ì„¸ì…˜ ê´€ë ¨ storeë¥¼ ì´ˆê¸°í™”í•©ë‹ˆë‹¤.
 *
 * RU-004-Q4 Step 2: store reset/hydrate ë²”ìœ„ í‘œì¤€í™”
 * - worldStore, inventoryStore, economyStore, actionDeckStore, agentStore
 *
 * ì„¸ì…˜ ê²½ê³„ì—ì„œ í•­ìƒ ì´ í•¨ìˆ˜ë¥¼ í˜¸ì¶œí•˜ì—¬ ì´ì „ ì„¸ì…˜ ì”ì¬ë¥¼ ì™„ì „íˆ ì œê±°í•©ë‹ˆë‹¤.
 */
function resetAllSessionStores(): void {
  useWorldStore.getState().reset();
  useInventoryStore.getState().reset();
  useEconomyStore.getState().reset();
  useActionDeckStore.getState().reset();
  useAgentStore.getState().reset();
}

// =============================================================================
// ì„¸ì…˜ ë¼ì´í”„ì‚¬ì´í´ API
// =============================================================================

/**
 * ë¶€íŒ… ì‹œ ì„¸ì…˜ ìƒíƒœë¥¼ í™•ì¸í•˜ê³  ì‹œì‘ phaseë¥¼ ê²°ì •í•©ë‹ˆë‹¤.
 *
 * RU-004-S2: hasSaveGame() ëŒ€ì‹  getValidSaveGameOrNull()ë¡œ "ìœ íš¨í•œ ì„¸ì´ë¸Œë§Œ" íŒë‹¨
 *
 * @returns SessionBootstrap - ì‹œì‘ phaseì™€ ê´€ë ¨ ì •ë³´
 */
export function bootstrapSession(): SessionBootstrap {
  const validSaveGame = getValidSaveGameOrNull();

  if (validSaveGame) {
    // ìœ íš¨í•œ ì„¸ì´ë¸Œê°€ ìˆìœ¼ë©´ playing ìƒíƒœë¡œ ì‹œì‘
    return {
      phase: 'playing',
      profileId: validSaveGame.profileId,
    };
  }

  // ìœ íš¨í•œ ì„¸ì´ë¸Œê°€ ì—†ìœ¼ë©´ profile_selectë¡œ ì‹œì‘
  // ë‹¨, localStorageì— ê¹¨ì§„ ì„¸ì´ë¸Œê°€ ìˆì„ ìˆ˜ ìˆìœ¼ë¯€ë¡œ savedGameAvailableì€ false
  return {
    phase: 'profile_select',
    savedGameAvailable: false,
  };
}

/**
 * ì €ì¥ëœ ê²Œì„ì´ ìˆëŠ”ì§€ í™•ì¸í•©ë‹ˆë‹¤ (Continue ë²„íŠ¼ í‘œì‹œìš©).
 *
 * RU-004-S2: ìœ íš¨í•œ ì„¸ì´ë¸Œë§Œ "ìˆìŒ"ìœ¼ë¡œ íŒë‹¨
 *
 * @returns ìœ íš¨í•œ ì„¸ì´ë¸Œê°€ ìˆìœ¼ë©´ true
 */
export function hasValidSaveGame(): boolean {
  return getValidSaveGameOrNull() !== null;
}

/**
 * í”„ë¡œí•„ì„ ì„ íƒí•˜ê³  ìƒˆ ì„¸ì…˜ì„ ì‹œì‘í•©ë‹ˆë‹¤.
 *
 * RU-004-Q4 Step 1: startSessionFromProfile
 * U-044: ì„¸ì…˜ ì–¸ì–´ë¥¼ ëª…ì‹œì ìœ¼ë¡œ ë°›ì•„ SSOT ìœ ì§€
 * - ëª¨ë“  storeë¥¼ ì´ˆê¸°í™”
 * - í”„ë¡œí•„ ê¸°ë°˜ SaveGame ìƒì„±
 * - storeì— ì´ˆê¸° ìƒíƒœ ì£¼ì…
 * - localStorageì— ì €ì¥
 *
 * @param args.profile - ì„ íƒí•œ ë°ëª¨ í”„ë¡œí•„
 * @param args.t - i18n ë²ˆì—­ í•¨ìˆ˜
 * @param args.language - ì„¸ì…˜ ì–¸ì–´ (U-044: ëª…ì‹œì  ì „ë‹¬ë¡œ SSOT ìœ ì§€)
 * @returns ì„¸ì…˜ ì‹œì‘ ê²°ê³¼
 */
export function startSessionFromProfile(args: {
  profile: DemoProfile;
  t: (key: string) => string;
  language?: SupportedLanguage;
}): SessionStartResult {
  const { profile, t, language: explicitLanguage } = args;

  // U-044: ëª…ì‹œì  ì–¸ì–´ê°€ ìˆìœ¼ë©´ ì‚¬ìš©, ì—†ìœ¼ë©´ i18n í˜„ì¬ ê°’ ì‚¬ìš©
  const language = explicitLanguage ?? getResolvedLanguage();

  // í”„ë¡œí•„ì—ì„œ SaveGame ìƒì„±
  const saveGame = createSaveGameFromProfile(profile, language, t);

  // ëª¨ë“  ì„¸ì…˜ store ì´ˆê¸°í™” (ì´ì „ ì„¸ì…˜ ì”ì¬ ì œê±°)
  resetAllSessionStores();

  // Storeì— ì´ˆê¸° ìƒíƒœ ì£¼ì…
  useWorldStore.setState({
    economy: {
      signal: saveGame.economy.signal,
      memory_shard: saveGame.economy.memory_shard,
    },
    turnCount: 0,
    narrativeEntries: saveGame.narrativeHistory,
    quests: saveGame.quests,
    activeRules: saveGame.activeRules,
    mutationTimeline: saveGame.mutationTimeline,
    sceneObjects: saveGame.sceneObjects,
  });

  useInventoryStore.getState().setItems(saveGame.inventory);

  // í”„ë¡œí•„ ID ì €ì¥ (localStorage)
  saveCurrentProfileId(profile.id);

  // SaveGame ì €ì¥ (localStorage)
  saveSaveGame(saveGame);

  return {
    success: true,
    profileId: profile.id,
  };
}

/**
 * ì €ì¥ëœ ê²Œì„ì„ ë³µì›í•˜ì—¬ ì„¸ì…˜ì„ ê³„ì†í•©ë‹ˆë‹¤.
 *
 * RU-004-Q4 Step 1: continueSession
 * RU-004-S1: asyncë¡œ ì–¸ì–´ ì ìš© ì™„ë£Œ í›„ store ì£¼ì…
 * RU-004-S2: profileId SSOT + ë¡œë“œ ì‹¤íŒ¨ ì‹œ null ë°˜í™˜
 *
 * @returns ì„¸ì…˜ ë³µì› ê²°ê³¼ ë˜ëŠ” null (ì‹¤íŒ¨ ì‹œ)
 */
export async function continueSession(): Promise<SessionContinueResult | null> {
  const saveGame = loadSaveGame();
  if (!saveGame) {
    // ë¡œë“œ ì‹¤íŒ¨ ì‹œ í´ë¦°ì—…
    clearSaveGame();
    clearCurrentProfileId();
    console.warn('[SessionLifecycle] SaveGame ë¡œë“œ ì‹¤íŒ¨, ìƒˆë¡œ ì‹œì‘ í•„ìš”');
    return null;
  }

  // RU-004-S1: ì–¸ì–´ ì„¤ì • ë¹„ë™ê¸° ì ìš© ì™„ë£Œ í›„ ì§„í–‰ (RULE-006)
  await changeLanguage(saveGame.language as SupportedLanguage);

  // ëª¨ë“  ì„¸ì…˜ store ì´ˆê¸°í™” (ì´ì „ ì„¸ì…˜ ì”ì¬ ì œê±°)
  resetAllSessionStores();

  // Storeì— ì €ì¥ëœ ìƒíƒœ ë³µì›
  useWorldStore.setState({
    economy: {
      signal: saveGame.economy.signal,
      memory_shard: saveGame.economy.memory_shard,
    },
    turnCount: saveGame.turnCount,
    narrativeEntries: saveGame.narrativeHistory,
    quests: saveGame.quests,
    activeRules: saveGame.activeRules,
    mutationTimeline: saveGame.mutationTimeline,
    sceneObjects: saveGame.sceneObjects,
  });

  // ì¸ë²¤í† ë¦¬ ë³µì›
  useInventoryStore.getState().setItems(saveGame.inventory);

  // Economy ë³µì› (RU-004-S1: hydrateLedgerë¡œ ìˆœì„œ/timestamp/lastCost/isBalanceLow ì •í•©ì„± ë³´ì¥)
  useEconomyStore.getState().hydrateLedger(saveGame.economyLedger, saveGame.economy);

  // RU-004-S2: profileId SSOT - SaveGame.profileIdë¥¼ ê¶Œìœ„ìë¡œ ì‚¬ìš©
  const profileId = saveGame.profileId;
  if (profileId) {
    saveCurrentProfileId(profileId); // localStorage ë™ê¸°í™” (ë“œë¦¬í”„íŠ¸ ë°©ì§€)
  }

  return {
    success: true,
    profileId: profileId ?? loadCurrentProfileId() ?? '',
  };
}

/**
 * í˜„ì¬ í”„ë¡œí•„ì˜ ì´ˆê¸° ìƒíƒœë¡œ ë¦¬ì…‹í•©ë‹ˆë‹¤.
 *
 * RU-004-Q4 Step 1: resetToCurrentProfile
 *
 * @param args.t - i18n ë²ˆì—­ í•¨ìˆ˜
 * @param args.currentProfileId - í˜„ì¬ í”„ë¡œí•„ ID
 * @returns ë¦¬ì…‹ ì„±ê³µ ì—¬ë¶€
 */
export function resetToCurrentProfile(args: {
  t: (key: string) => string;
  currentProfileId: string | null;
}): SessionResetResult {
  const { t, currentProfileId } = args;

  if (!currentProfileId) {
    return { success: false, profileId: null };
  }

  const profile = findProfileById(currentProfileId);
  if (!profile) {
    return { success: false, profileId: null };
  }

  // ë™ì¼ í”„ë¡œí•„ë¡œ ìƒˆ ì„¸ì…˜ ì‹œì‘
  const result = startSessionFromProfile({ profile, t });

  return {
    success: result.success,
    profileId: result.profileId,
  };
}

/**
 * ì„¸ì…˜ì„ ì¢…ë£Œí•˜ê³  í”„ë¡œí•„ ì„ íƒ í™”ë©´ìœ¼ë¡œ ëŒì•„ê°‘ë‹ˆë‹¤.
 *
 * RU-004-Q4 Step 1: clearSessionAndReturnToSelect
 * - ëª¨ë“  ì„¸ì…˜ ë°ì´í„° í´ë¦°ì—… (localStorage + store)
 */
export function clearSessionAndReturnToSelect(): void {
  // localStorage í´ë¦°ì—…
  clearSaveGame();
  clearCurrentProfileId();

  // ëª¨ë“  ì„¸ì…˜ store ì´ˆê¸°í™”
  resetAllSessionStores();
}

/**
 * í˜„ì¬ ìƒíƒœë¥¼ ì €ì¥í•©ë‹ˆë‹¤.
 *
 * í„´ ì™„ë£Œ ì‹œ ìë™ ì €ì¥ì— ì‚¬ìš©ë©ë‹ˆë‹¤.
 *
 * RU-004-Q5: seedëŠ” ì„¸ì…˜ ì‹œì‘ ì‹œ ìƒì„±ë˜ê³ , ì´í›„ ë³€ê²½ë˜ì§€ ì•Šì•„ì•¼ í•©ë‹ˆë‹¤.
 * ê¸°ì¡´ SaveGameì—ì„œ seedë¥¼ ì½ì–´ì™€ì„œ ìœ ì§€í•©ë‹ˆë‹¤.
 *
 * @param profileId - í˜„ì¬ í”„ë¡œí•„ ID
 * @returns ì €ì¥ ì„±ê³µ ì—¬ë¶€
 */
export function saveCurrentSession(profileId: string | null): boolean {
  if (!profileId) return false;

  const worldState = useWorldStore.getState();
  const economyState = useEconomyStore.getState();
  const inventoryState = useInventoryStore.getState();

  // RU-004-Q5: ê¸°ì¡´ SaveGameì—ì„œ seedë¥¼ ê°€ì ¸ì™€ ìœ ì§€ (SSOT)
  const existingSaveGame = getValidSaveGameOrNull();
  const seed = existingSaveGame?.seed ?? null;

  const saveGame = createSaveGame({
    language: getResolvedLanguage(),
    profileId,
    seed, // RU-004-Q5: seed ìœ ì§€
    economy: worldState.economy,
    economyLedger: economyState.ledger,
    turnCount: worldState.turnCount,
    narrativeHistory: worldState.narrativeEntries,
    inventory: inventoryState.items,
    quests: worldState.quests,
    activeRules: worldState.activeRules,
    mutationTimeline: worldState.mutationTimeline,
    sceneObjects: worldState.sceneObjects,
  });

  return saveSaveGame(saveGame);
}

/**
 * ì´ˆê¸° profileIdë¥¼ ê²°ì •í•©ë‹ˆë‹¤.
 *
 * RU-004-S2: SaveGame.profileIdê°€ SSOT, CURRENT_PROFILE_KEYëŠ” í´ë°±
 *
 * @returns ì´ˆê¸° profileId ë˜ëŠ” null
 */
export function getInitialProfileId(): string | null {
  // ìœ íš¨í•œ SaveGameì´ ìˆìœ¼ë©´ ê·¸ profileIdë¥¼ ì‚¬ìš©
  const validSaveGame = getValidSaveGameOrNull();
  if (validSaveGame?.profileId) {
    return validSaveGame.profileId;
  }
  // í´ë°±: CURRENT_PROFILE_KEY (í˜¸í™˜ì„±)
  return loadCurrentProfileId();
}

// =============================================================================
// U-044: ì„¸ì…˜ ì–¸ì–´ SSOT API
// =============================================================================

/**
 * í˜„ì¬ ì„¸ì…˜ ì–¸ì–´ë¥¼ ë°˜í™˜í•©ë‹ˆë‹¤ (SSOT).
 *
 * U-044: SaveGame.languageë¥¼ ê¶Œìœ„ìë¡œ ì‚¬ìš©í•˜ì—¬ ì–¸ì–´ ë“œë¦¬í”„íŠ¸ë¥¼ ë°©ì§€í•©ë‹ˆë‹¤.
 * - ìœ íš¨í•œ SaveGameì´ ìˆìœ¼ë©´ í•´ë‹¹ ì–¸ì–´ ë°˜í™˜
 * - ì—†ìœ¼ë©´ i18nì˜ í˜„ì¬ ì–¸ì–´ ë°˜í™˜ (í´ë°±)
 *
 * TurnRunnerì—ì„œ TurnInput.languageë¥¼ ìƒì„±í•  ë•Œ ì´ í•¨ìˆ˜ë¥¼ ì‚¬ìš©í•©ë‹ˆë‹¤.
 *
 * @returns í˜„ì¬ ì„¸ì…˜ ì–¸ì–´ (ko-KR | en-US)
 */
export function getSessionLanguage(): SupportedLanguage {
  const validSaveGame = getValidSaveGameOrNull();
  if (validSaveGame?.language) {
    return validSaveGame.language as SupportedLanguage;
  }
  // í´ë°±: i18nì˜ í˜„ì¬ ì–¸ì–´
  return getResolvedLanguage();
}

/**
 * ì„¸ì…˜ ì–¸ì–´ë¥¼ ë³€ê²½í•©ë‹ˆë‹¤.
 *
 * U-044: ì–¸ì–´ ë³€ê²½ì€ ì„¸ì…˜ ê²½ê³„ì—ì„œë§Œ í—ˆìš© (í† ê¸€=ë¦¬ì…‹ ì •ì±…).
 * ì´ í•¨ìˆ˜ëŠ” i18n ì–¸ì–´ë¥¼ ë³€ê²½í•˜ê³ , ì´í›„ startSessionFromProfile ì‹œ
 * ìƒˆ SaveGameì— í•´ë‹¹ ì–¸ì–´ê°€ ì €ì¥ë©ë‹ˆë‹¤.
 *
 * ì£¼ì˜: playing ìƒíƒœì—ì„œëŠ” ì´ í•¨ìˆ˜ë¥¼ í˜¸ì¶œí•˜ì§€ ë§ˆì„¸ìš”.
 * ì–¸ì–´ ë³€ê²½ì€ profile_selectì—ì„œë§Œ í—ˆìš©ë©ë‹ˆë‹¤.
 *
 * @param language - ë³€ê²½í•  ì–¸ì–´
 */
export async function setSessionLanguage(language: SupportedLanguage): Promise<void> {
  await changeLanguage(language);
}

/**
 * ì´ˆê¸° ì„¸ì…˜ ì–¸ì–´ë¥¼ ê²°ì •í•©ë‹ˆë‹¤.
 *
 * U-044: ì•± ë¶€íŒ… ì‹œ ì‚¬ìš©í•©ë‹ˆë‹¤.
 * - ìœ íš¨í•œ SaveGameì´ ìˆìœ¼ë©´ í•´ë‹¹ ì–¸ì–´
 * - ì—†ìœ¼ë©´ DEFAULT_LANGUAGE
 *
 * @returns ì´ˆê¸° ì„¸ì…˜ ì–¸ì–´
 */
export function getInitialSessionLanguage(): SupportedLanguage {
  const validSaveGame = getValidSaveGameOrNull();
  if (validSaveGame?.language) {
    return validSaveGame.language as SupportedLanguage;
  }
  return DEFAULT_LANGUAGE;
}
</file>

<file path="frontend/src/stores/agentStore.ts">
/**
 * Unknown World - Agent Console ìƒíƒœ ê´€ë¦¬ (Zustand).
 *
 * ìŠ¤íŠ¸ë¦¬ë° ì¤‘ ìˆ˜ì‹ ë˜ëŠ” ë‹¨ê³„/ë°°ì§€/ë‚´ëŸ¬í‹°ë¸Œ/ë³µêµ¬ ì •ë³´ë¥¼ ì €ì¥í•˜ê³ ,
 * AgentConsole ì»´í¬ë„ŒíŠ¸ì—ì„œ êµ¬ë…í•  ìˆ˜ ìˆë„ë¡ í•©ë‹ˆë‹¤.
 *
 * ì„¤ê³„ ì›ì¹™:
 *   - RULE-008: ë‹¨ê³„/ë°°ì§€ ê°€ì‹œí™” (í”„ë¡¬í”„íŠ¸/ë‚´ë¶€ ì¶”ë¡  ë…¸ì¶œ ê¸ˆì§€)
 *   - RULE-003/004: ê²€ì¦ í›„ ìƒíƒœ ë°˜ì˜, ì‹¤íŒ¨ ì‹œ í´ë°±
 *
 * @module stores/agentStore
 */

import { create } from 'zustand';
import type { AgentPhase, ValidationBadge, TurnOutput } from '../schemas/turn';
import type {
  StageEvent,
  BadgesEvent,
  NarrativeDeltaEvent,
  FinalEvent,
  ErrorEvent,
} from '../types/turn_stream';
import { StageStatus } from '../types/turn_stream';

// =============================================================================
// ìƒíƒœ íƒ€ì… ì •ì˜
// =============================================================================

/** ë‹¨ê³„ ìƒíƒœ */
export type PhaseStatus = 'pending' | 'in_progress' | 'completed' | 'failed';

/** ë‹¨ê³„ ì •ë³´ */
export interface PhaseInfo {
  name: AgentPhase;
  status: PhaseStatus;
}

/** ì—ëŸ¬ ì •ë³´ */
export interface AgentError {
  message: string;
  code?: string;
}

/** Agent Console ìƒíƒœ */
export interface AgentState {
  /** í˜„ì¬ ìŠ¤íŠ¸ë¦¬ë° ì¤‘ì¸ì§€ */
  isStreaming: boolean;
  /** í˜„ì¬ ë‹¨ê³„ */
  currentPhase: AgentPhase | null;
  /** ë‹¨ê³„ë³„ ìƒíƒœ */
  phases: PhaseInfo[];
  /** ê²€ì¦ ë°°ì§€ ëª©ë¡ */
  badges: ValidationBadge[];
  /** ëˆ„ì  ë‚´ëŸ¬í‹°ë¸Œ í…ìŠ¤íŠ¸ (íƒ€ì íš¨ê³¼ìš©) */
  narrativeBuffer: string;
  /** ìë™ ë³µêµ¬ íšŸìˆ˜ */
  repairCount: number;
  /** ìµœì¢… TurnOutput */
  finalOutput: TurnOutput | null;
  /** ì—ëŸ¬ ì •ë³´ */
  error: AgentError | null;
}

/** Agent Console ì•¡ì…˜ */
export interface AgentActions {
  /** ìŠ¤íŠ¸ë¦¼ ì‹œì‘ */
  startStream: () => void;
  /** ë‹¨ê³„ ì´ë²¤íŠ¸ ì²˜ë¦¬ */
  handleStage: (event: StageEvent) => void;
  /** ë°°ì§€ ì´ë²¤íŠ¸ ì²˜ë¦¬ */
  handleBadges: (event: BadgesEvent) => void;
  /** ë‚´ëŸ¬í‹°ë¸Œ ë¸íƒ€ ì´ë²¤íŠ¸ ì²˜ë¦¬ */
  handleNarrativeDelta: (event: NarrativeDeltaEvent) => void;
  /** ìµœì¢… ì¶œë ¥ ì´ë²¤íŠ¸ ì²˜ë¦¬ */
  handleFinal: (event: FinalEvent) => void;
  /** ì—ëŸ¬ ì´ë²¤íŠ¸ ì²˜ë¦¬ */
  handleError: (event: ErrorEvent) => void;
  /** ìŠ¤íŠ¸ë¦¼ ì™„ë£Œ */
  completeStream: () => void;
  /** ìƒíƒœ ì´ˆê¸°í™” */
  reset: () => void;
}

export type AgentStore = AgentState & AgentActions;

// =============================================================================
// ì´ˆê¸° ìƒíƒœ
// =============================================================================

/** ê¸°ë³¸ ë‹¨ê³„ ëª©ë¡ (PRD ì˜ˆì‹œ) */
const DEFAULT_PHASES: AgentPhase[] = [
  'parse',
  'validate',
  'plan',
  'resolve',
  'render',
  'verify',
  'commit',
];

/** ì´ˆê¸° ìƒíƒœ ìƒì„± */
function createInitialState(): AgentState {
  return {
    isStreaming: false,
    currentPhase: null,
    phases: DEFAULT_PHASES.map((name) => ({
      name,
      status: 'pending' as const,
    })),
    badges: [],
    narrativeBuffer: '',
    repairCount: 0,
    finalOutput: null,
    error: null,
  };
}

// =============================================================================
// Zustand Store
// =============================================================================

/**
 * Agent Console ìƒíƒœ ìŠ¤í† ì–´.
 *
 * @example
 * ```tsx
 * // ì»´í¬ë„ŒíŠ¸ì—ì„œ ì‚¬ìš©
 * const { isStreaming, phases, badges } = useAgentStore();
 * const startStream = useAgentStore((state) => state.startStream);
 * ```
 */
export const useAgentStore = create<AgentStore>((set) => ({
  // ì´ˆê¸° ìƒíƒœ
  ...createInitialState(),

  // ì•¡ì…˜
  startStream: () => {
    set({
      ...createInitialState(),
      isStreaming: true,
    });
  },

  handleStage: (event) => {
    set((state) => {
      const phaseName = event.name;
      const eventStatus = event.status;

      // RU-002-S2: status ê°’ì— ë”°ë¥¸ ë‹¨ê³„ ìƒíƒœ ê²°ì •
      // 'start' â†’ in_progress
      // 'complete' ë˜ëŠ” 'ok' (ì •ê·œí™”ë¨) â†’ completed
      // 'fail' â†’ failed
      let newStatus: PhaseStatus;
      if (eventStatus === StageStatus.START) {
        newStatus = 'in_progress';
      } else if (eventStatus === 'fail') {
        newStatus = 'failed';
      } else {
        // 'complete' (ì •ê·œí™”ëœ 'ok' í¬í•¨)
        newStatus = 'completed';
      }

      // ë‹¨ê³„ ìƒíƒœ ì—…ë°ì´íŠ¸
      const phases = state.phases.map((phase) => {
        if (phase.name === phaseName) {
          return {
            ...phase,
            status: newStatus,
          };
        }
        return phase;
      });

      return {
        phases,
        currentPhase: eventStatus === StageStatus.START ? phaseName : state.currentPhase,
      };
    });
  },

  handleBadges: (event) => {
    set({
      badges: event.badges,
    });
  },

  handleNarrativeDelta: (event) => {
    set((state) => ({
      narrativeBuffer: state.narrativeBuffer + event.text,
    }));
  },

  handleFinal: (event) => {
    set({
      finalOutput: event.data,
      repairCount: event.data.agent_console?.repair_count ?? 0,
    });
  },

  handleError: (event) => {
    set({
      error: {
        message: event.message,
        code: event.code,
      },
    });
  },

  completeStream: () => {
    set({
      isStreaming: false,
      narrativeBuffer: '', // ìŠ¤íŠ¸ë¦¼ ì™„ë£Œ ì‹œ ë²„í¼ ì´ˆê¸°í™”
    });
  },

  reset: () => {
    set(createInitialState());
  },
}));

// =============================================================================
// ì…€ë ‰í„° (ì„±ëŠ¥ ìµœì í™”ìš©)
// =============================================================================

/** ìŠ¤íŠ¸ë¦¬ë° ìƒíƒœ ì…€ë ‰í„° */
export const selectIsStreaming = (state: AgentStore) => state.isStreaming;

/** í˜„ì¬ ë‹¨ê³„ ì…€ë ‰í„° */
export const selectCurrentPhase = (state: AgentStore) => state.currentPhase;

/** ë‹¨ê³„ ëª©ë¡ ì…€ë ‰í„° */
export const selectPhases = (state: AgentStore) => state.phases;

/** ë°°ì§€ ëª©ë¡ ì…€ë ‰í„° */
export const selectBadges = (state: AgentStore) => state.badges;

/** ë‚´ëŸ¬í‹°ë¸Œ ë²„í¼ ì…€ë ‰í„° */
export const selectNarrativeBuffer = (state: AgentStore) => state.narrativeBuffer;

/** ë³µêµ¬ íšŸìˆ˜ ì…€ë ‰í„° */
export const selectRepairCount = (state: AgentStore) => state.repairCount;

/** ìµœì¢… ì¶œë ¥ ì…€ë ‰í„° */
export const selectFinalOutput = (state: AgentStore) => state.finalOutput;

/** ì—ëŸ¬ ì…€ë ‰í„° */
export const selectError = (state: AgentStore) => state.error;
</file>

<file path="frontend/vite.config.ts">
/// <reference types="vitest" />
import { defineConfig } from 'vite';
import react from '@vitejs/plugin-react';

// https://vite.dev/config/
export default defineConfig({
  plugins: [react()],
  server: {
    port: 8001, // RULE-011: í”„ë¡ íŠ¸ì—”ë“œëŠ” 8001~8010 ì‚¬ìš©
    strictPort: true, // í¬íŠ¸ ì¶©ëŒ ì‹œ fail-fast (ëŒ€ì—­ ë°– ì´ë™ ë°©ì§€)
    // ì¶©ëŒ ì‹œ: pnpm -C frontend dev --port 8002 (8002~8010 ì¤‘ ì„ íƒ)
    proxy: {
      // ë°±ì—”ë“œ API í”„ë¡ì‹œ (RULE-011: ë°±ì—”ë“œëŠ” 8011~8020)
      '/api': {
        target: 'http://localhost:8011',
        changeOrigin: true,
      },
    },
  },
  build: {
    outDir: 'dist',
    sourcemap: true,
  },
  test: {
    globals: true,
    environment: 'jsdom',
    setupFiles: './src/setupTests.ts',
  },
});
</file>

<file path="package.json">
{
  "name": "unknown-world",
  "version": "0.1.0",
  "private": true,
  "description": "Unknown World - Gemini ê¸°ë°˜ ì—ì´ì „íŠ¸í˜• ê²Œì„ ì—”ì§„",
  "packageManager": "pnpm@10.27.0",
  "engines": {
    "node": "24.12.0"
  },
  "scripts": {
    "kill": "pnpm kill:port",
    "kill:port": "npx --yes kill-port 8001 8002 8003 8004 8005 8006 8007 8008 8009 8010 8011 8012 8013 8014 8015 8016 8017 8018 8019 8020",
    "kill:front": "npx --yes kill-port 8001 8002 8003 8004 8005 8006 8007 8008 8009 8010",
    "kill:back": "npx --yes kill-port 8011 8012 8013 8014 8015 8016 8017 8018 8019 8020",
    "dev:back": "cd backend && uv run uvicorn unknown_world.main:app --reload --port 8011",
    "dev:front": "pnpm -C frontend dev"
  }
}
</file>

<file path="backend/src/unknown_world/models/turn.py">
"""Unknown World - TurnInput/TurnOutput Pydantic ìŠ¤í‚¤ë§ˆ.

ì´ ëª¨ë“ˆì€ Unknown Worldì˜ í•µì‹¬ ë°ì´í„° ëª¨ë¸ì„ ì •ì˜í•©ë‹ˆë‹¤.
Gemini Structured Outputsì— íˆ¬ì… ê°€ëŠ¥í•œ JSON Schema(ë¶€ë¶„ì§‘í•©)ë¥¼ ìƒì„±í•  ìˆ˜ ìˆìŠµë‹ˆë‹¤.

ì„¤ê³„ ì›ì¹™:
    - RULE-003: êµ¬ì¡°í™” ì¶œë ¥(JSON Schema) ìš°ì„  + ì´ì¤‘ ê²€ì¦
    - RULE-005: ì¬í™” ì¸ë°”ë¦¬ì–¸íŠ¸ (cost, balance_after í•„ìˆ˜, ì”ì•¡ ìŒìˆ˜ ê¸ˆì§€)
    - RULE-006: ko/en ì–¸ì–´ ì •ì±… (Language enumìœ¼ë¡œ ê³ ì •)
    - RULE-009: ì¢Œí‘œ ê·œì•½ (0~1000, bbox [ymin,xmin,ymax,xmax])

ì‚¬ìš© ì˜ˆì‹œ:
    # Gemini Structured Outputsìš© JSON Schema ìƒì„±
    schema = TurnOutput.model_json_schema()

    # ì‘ë‹µ ê²€ì¦
    output = TurnOutput.model_validate_json(gemini_response_text)

ì°¸ì¡°:
    - vibe/prd.md 8.7 (ë°ì´í„° ëª¨ë¸ ì„¤ê³„)
    - vibe/ref/structured-outputs-guide.md
    - .cursor/rules/00-core-critical.mdc
"""

from enum import Enum
from typing import Annotated

from pydantic import BaseModel, ConfigDict, Field

# =============================================================================
# ê³µí†µ Enum íƒ€ì…
# =============================================================================


class Language(str, Enum):
    """ì§€ì› ì–¸ì–´ (RULE-006).

    ko/en í˜¼í•© ì¶œë ¥ ê¸ˆì§€. TurnInput.languageë¥¼ SSOTë¡œ ì‚¼ì•„
    ëª¨ë“  UI/ë‚´ëŸ¬í‹°ë¸Œ/ì‹œìŠ¤í…œ ë©”ì‹œì§€ëŠ” ë™ì¼ ì–¸ì–´ë¡œ ê³ ì •í•©ë‹ˆë‹¤.
    """

    KO = "ko-KR"
    EN = "en-US"


class Theme(str, Enum):
    """í…Œë§ˆ ì„¤ì •."""

    DARK = "dark"
    LIGHT = "light"


class AgentPhase(str, Enum):
    """ì—ì´ì „íŠ¸ ì‹¤í–‰ ë‹¨ê³„ (RULE-008).

    ì—ì´ì „íŠ¸í˜• ì‹œìŠ¤í…œì„ì„ UIë¡œ ì¦ëª…í•˜ê¸° ìœ„í•œ ë‹¨ê³„ í‘œì‹œ.
    """

    PARSE = "parse"
    VALIDATE = "validate"
    PLAN = "plan"
    RESOLVE = "resolve"
    RENDER = "render"
    VERIFY = "verify"
    COMMIT = "commit"


class ValidationBadge(str, Enum):
    """ê²€ì¦ ë°°ì§€ (RULE-008).

    í„´ ê²°ê³¼ì— ëŒ€í•œ ê²€ì¦ ìƒíƒœë¥¼ í‘œì‹œí•©ë‹ˆë‹¤.
    """

    SCHEMA_OK = "schema_ok"
    SCHEMA_FAIL = "schema_fail"
    ECONOMY_OK = "economy_ok"
    ECONOMY_FAIL = "economy_fail"
    SAFETY_OK = "safety_ok"
    SAFETY_BLOCKED = "safety_blocked"
    CONSISTENCY_OK = "consistency_ok"
    CONSISTENCY_FAIL = "consistency_fail"


class ModelLabel(str, Enum):
    """ëª¨ë¸/í’ˆì§ˆ ì„ íƒ ë¼ë²¨ (RULE-008).

    í”„ë¡¬í”„íŠ¸ ë…¸ì¶œ ì—†ì´ "ì™œ ì´ ì„ íƒì´ì—ˆëŠ”ì§€"ë¥¼ ì‚¬ìš©ì ì¹œí™” ë¼ë²¨ë¡œ í‘œì‹œ.
    """

    FAST = "FAST"
    QUALITY = "QUALITY"
    CHEAP = "CHEAP"
    REF = "REF"


class RiskLevel(str, Enum):
    """í–‰ë™ ìœ„í—˜ë„ ìˆ˜ì¤€."""

    LOW = "low"
    MEDIUM = "medium"
    HIGH = "high"


# =============================================================================
# ê³µí†µ í•˜ìœ„ íƒ€ì…
# =============================================================================

# RULE-009: ì¢Œí‘œëŠ” 0~1000 ì •ê·œí™” ì¢Œí‘œê³„ (ì´ë¯¸ì§€ ì´í•´ bbox í¬ë§·ê³¼ í˜¸í™˜)
Coordinate = Annotated[int, Field(ge=0, le=1000, description="ì •ê·œí™” ì¢Œí‘œ (0~1000)")]


class Box2D(BaseModel):
    """2D ë°”ìš´ë”© ë°•ìŠ¤ (RULE-009).

    ì¢Œí‘œëŠ” 0~1000 ì •ê·œí™” ì¢Œí‘œê³„ì´ë©°, bboxëŠ” [ymin, xmin, ymax, xmax] ìˆœì„œì…ë‹ˆë‹¤.
    ì´ë¯¸ì§€ ì´í•´ bbox í¬ë§·ê³¼ í˜¸í™˜ë©ë‹ˆë‹¤.

    Attributes:
        ymin: Y ìµœì†Œê°’ (ìƒë‹¨)
        xmin: X ìµœì†Œê°’ (ì¢Œì¸¡)
        ymax: Y ìµœëŒ€ê°’ (í•˜ë‹¨)
        xmax: X ìµœëŒ€ê°’ (ìš°ì¸¡)
    """

    model_config = ConfigDict(extra="forbid")

    ymin: Coordinate
    xmin: Coordinate
    ymax: Coordinate
    xmax: Coordinate


class CurrencyAmount(BaseModel):
    """ì¬í™” ìˆ˜ëŸ‰.

    Attributes:
        signal: ê¸°ë³¸ ì¬í™” (í…ìŠ¤íŠ¸ í„´/ì´ë¯¸ì§€ ìƒì„±/ê³ ê¸‰ ê¸°ëŠ¥ì— ì†Œë¹„)
        memory_shard: í¬ê·€ ì¬í™” (ì¤‘ìš” ì„¤ì • ê³ ì •, ê³ í•´ìƒë„ ì´ë¯¸ì§€ ë“±ì— ì†Œë¹„)
    """

    model_config = ConfigDict(extra="forbid")

    signal: Annotated[int, Field(ge=0, description="ì‹œê·¸ë„ (ê¸°ë³¸ ì¬í™”, 0 ì´ìƒ)")]
    memory_shard: Annotated[int, Field(ge=0, description="ê¸°ì–µ íŒŒí¸ (í¬ê·€ ì¬í™”, 0 ì´ìƒ)")]


# =============================================================================
# TurnInput ê´€ë ¨ íƒ€ì…
# =============================================================================


class ClickInput(BaseModel):
    """í´ë¦­ ì…ë ¥ ì •ë³´.

    í™”ë©´ ì˜¤ë¸Œì íŠ¸ í´ë¦­ ì‹œ ì „ë‹¬ë˜ëŠ” ì •ë³´ì…ë‹ˆë‹¤.

    Attributes:
        object_id: í´ë¦­í•œ ì˜¤ë¸Œì íŠ¸ ID
        box_2d: í´ë¦­ ìœ„ì¹˜ì˜ ë°”ìš´ë”© ë°•ìŠ¤ (ì„ íƒ)
    """

    model_config = ConfigDict(extra="forbid")

    object_id: str = Field(description="í´ë¦­í•œ ì˜¤ë¸Œì íŠ¸ ID")
    box_2d: Box2D | None = Field(default=None, description="í´ë¦­ ìœ„ì¹˜ ë°”ìš´ë”© ë°•ìŠ¤ (ì„ íƒ)")


class DropInput(BaseModel):
    """ë“œë¡­ ì…ë ¥ ì •ë³´ (U-012).

    ì¸ë²¤í† ë¦¬ ì•„ì´í…œì„ í•«ìŠ¤íŒŸì— ë“œë¡­í•  ë•Œ ì „ë‹¬ë˜ëŠ” ì •ë³´ì…ë‹ˆë‹¤.

    Attributes:
        item_id: ë“œë¡­í•œ ì¸ë²¤í† ë¦¬ ì•„ì´í…œ ID
        target_object_id: ë“œë¡­ ëŒ€ìƒ í•«ìŠ¤íŒŸ ì˜¤ë¸Œì íŠ¸ ID
        target_box_2d: ë“œë¡­ ëŒ€ìƒì˜ ë°”ìš´ë”© ë°•ìŠ¤ (0~1000 ì •ê·œí™”)
    """

    model_config = ConfigDict(extra="forbid")

    item_id: str = Field(description="ë“œë¡­í•œ ì¸ë²¤í† ë¦¬ ì•„ì´í…œ ID")
    target_object_id: str = Field(description="ë“œë¡­ ëŒ€ìƒ í•«ìŠ¤íŒŸ ì˜¤ë¸Œì íŠ¸ ID")
    target_box_2d: Box2D = Field(description="ë“œë¡­ ëŒ€ìƒì˜ ë°”ìš´ë”© ë°•ìŠ¤ (0~1000 ì •ê·œí™”)")


class ClientInfo(BaseModel):
    """í´ë¼ì´ì–¸íŠ¸ ì •ë³´.

    Attributes:
        viewport_w: ë·°í¬íŠ¸ ë„ˆë¹„ (í”½ì…€)
        viewport_h: ë·°í¬íŠ¸ ë†’ì´ (í”½ì…€)
        theme: í˜„ì¬ í…Œë§ˆ (dark/light)
    """

    model_config = ConfigDict(extra="forbid")

    viewport_w: Annotated[int, Field(gt=0, description="ë·°í¬íŠ¸ ë„ˆë¹„ (í”½ì…€)")]
    viewport_h: Annotated[int, Field(gt=0, description="ë·°í¬íŠ¸ ë†’ì´ (í”½ì…€)")]
    theme: Theme = Field(default=Theme.DARK, description="í˜„ì¬ í…Œë§ˆ")


class EconomySnapshot(BaseModel):
    """ì¬í™” ìŠ¤ëƒ…ìƒ· (í´ë¼ì´ì–¸íŠ¸ â†’ ì„œë²„).

    í´ë¼ì´ì–¸íŠ¸ê°€ ë³´ìœ í•œ í˜„ì¬ ì¬í™” ìƒíƒœì…ë‹ˆë‹¤.
    ì„œë²„ëŠ” ì´ë¥¼ ê²€ì¦í•˜ê³  ë¹„ìš© ê³„ì‚°ì— ì‚¬ìš©í•©ë‹ˆë‹¤.

    Attributes:
        signal: í˜„ì¬ ì‹œê·¸ë„ ì”ì•¡
        memory_shard: í˜„ì¬ ê¸°ì–µ íŒŒí¸ ì”ì•¡
    """

    model_config = ConfigDict(extra="forbid")

    signal: Annotated[int, Field(ge=0, description="í˜„ì¬ ì‹œê·¸ë„ ì”ì•¡ (0 ì´ìƒ)")]
    memory_shard: Annotated[int, Field(ge=0, description="í˜„ì¬ ê¸°ì–µ íŒŒí¸ ì”ì•¡ (0 ì´ìƒ)")]


class TurnInput(BaseModel):
    """í„´ ì…ë ¥ (í´ë¼ì´ì–¸íŠ¸ â†’ ì„œë²„).

    ì‚¬ìš©ìê°€ í„´ì„ ì§„í–‰í•  ë•Œ ì„œë²„ë¡œ ì „ì†¡í•˜ëŠ” ì…ë ¥ ë°ì´í„°ì…ë‹ˆë‹¤.

    Attributes:
        language: ìš”ì²­ ì–¸ì–´ (ì‘ë‹µë„ ë™ì¼ ì–¸ì–´ë¡œ ê³ ì •)
        text: ì‚¬ìš©ì ìì—°ì–´ ì…ë ¥
        action_id: ì„ íƒí•œ ì•¡ì…˜ ì¹´ë“œ ID (ì„ íƒ)
        click: ì˜¤ë¸Œì íŠ¸ í´ë¦­ ì •ë³´ (ì„ íƒ)
        client: í´ë¼ì´ì–¸íŠ¸ í™˜ê²½ ì •ë³´
        economy_snapshot: í˜„ì¬ ì¬í™” ìƒíƒœ

    Example:
        >>> input_data = TurnInput(
        ...     language=Language.KO,
        ...     text="ë¬¸ì„ ì—´ì–´ë³¸ë‹¤",
        ...     economy_snapshot=EconomySnapshot(signal=100, memory_shard=5),
        ...     client=ClientInfo(viewport_w=1920, viewport_h=1080),
        ... )
    """

    model_config = ConfigDict(extra="forbid")

    language: Language = Field(description="ìš”ì²­ ì–¸ì–´ (ì‘ë‹µë„ ë™ì¼ ì–¸ì–´ë¡œ ê³ ì •)")
    text: str = Field(default="", description="ì‚¬ìš©ì ìì—°ì–´ ì…ë ¥")
    action_id: str | None = Field(default=None, description="ì„ íƒí•œ ì•¡ì…˜ ì¹´ë“œ ID (ì„ íƒ)")
    click: ClickInput | None = Field(default=None, description="ì˜¤ë¸Œì íŠ¸ í´ë¦­ ì •ë³´ (ì„ íƒ)")
    drop: DropInput | None = Field(default=None, description="ì•„ì´í…œ ë“œë¡­ ì •ë³´ (ì„ íƒ, U-012)")
    client: ClientInfo = Field(description="í´ë¼ì´ì–¸íŠ¸ í™˜ê²½ ì •ë³´")
    economy_snapshot: EconomySnapshot = Field(description="í˜„ì¬ ì¬í™” ìƒíƒœ")


# =============================================================================
# TurnOutput ê´€ë ¨ íƒ€ì… - UI
# =============================================================================


class CostEstimate(BaseModel):
    """ë¹„ìš© ì¶”ì •ì¹˜ (ìµœì†Œ/ìµœëŒ€ ë²”ìœ„)."""

    model_config = ConfigDict(extra="forbid")

    min: CurrencyAmount = Field(description="ìµœì†Œ ì˜ˆìƒ ë¹„ìš©")
    max: CurrencyAmount = Field(description="ìµœëŒ€ ì˜ˆìƒ ë¹„ìš©")


class ActionCard(BaseModel):
    """ì•¡ì…˜ ì¹´ë“œ (Action Deck).

    ë§¤ í„´ AIê°€ ì¶”ì²œí•˜ëŠ” í–‰ë™ ì¹´ë“œì…ë‹ˆë‹¤.
    ê° ì¹´ë“œì— ë¹„ìš©/ìœ„í—˜/ë³´ìƒ íŒíŠ¸ê°€ í¬í•¨ë©ë‹ˆë‹¤.

    Attributes:
        id: ì¹´ë“œ ê³ ìœ  ID
        label: ì¹´ë“œ ë¼ë²¨ (í‘œì‹œìš©)
        description: ì¹´ë“œ ì„¤ëª… (ì„ íƒ)
        cost: ì˜ˆìƒ ë¹„ìš© (ê¸°ë³¸)
        cost_estimate: ë¹„ìš© ì¶”ì • ë²”ìœ„ (ì„ íƒ)
        risk: ìœ„í—˜ë„
        hint: ì˜ˆìƒ ê²°ê³¼ íŒíŠ¸ (ì„ íƒ)
        reward_hint: ë³´ìƒ íŒíŠ¸ (ì„ íƒ)
        enabled: ì‹¤í–‰ ê°€ëŠ¥ ì—¬ë¶€ (ì„œë²„ íŒë‹¨)
        disabled_reason: ë¹„í™œì„±í™” ì‚¬ìœ  (ì„ íƒ)
        is_alternative: ì €ë¹„ìš© ëŒ€ì•ˆ ì¹´ë“œ ì—¬ë¶€
    """

    model_config = ConfigDict(extra="forbid")

    id: str = Field(description="ì¹´ë“œ ê³ ìœ  ID")
    label: str = Field(description="ì¹´ë“œ ë¼ë²¨ (í‘œì‹œìš©)")
    description: str | None = Field(default=None, description="ì¹´ë“œ ì„¤ëª… (ì„ íƒ)")
    cost: CurrencyAmount = Field(description="ì˜ˆìƒ ë¹„ìš© (ê¸°ë³¸)")
    cost_estimate: CostEstimate | None = Field(default=None, description="ë¹„ìš© ì¶”ì • ë²”ìœ„ (ì„ íƒ)")
    risk: RiskLevel = Field(default=RiskLevel.LOW, description="ìœ„í—˜ë„")
    hint: str | None = Field(default=None, description="ì˜ˆìƒ ê²°ê³¼ íŒíŠ¸ (ì„ íƒ)")
    reward_hint: str | None = Field(default=None, description="ë³´ìƒ íŒíŠ¸ (ì„ íƒ)")
    enabled: bool = Field(default=True, description="ì‹¤í–‰ ê°€ëŠ¥ ì—¬ë¶€ (ì„œë²„ íŒë‹¨)")
    disabled_reason: str | None = Field(default=None, description="ë¹„í™œì„±í™” ì‚¬ìœ  (ì„ íƒ)")
    is_alternative: bool = Field(default=False, description="ì €ë¹„ìš© ëŒ€ì•ˆ ì¹´ë“œ ì—¬ë¶€")


class SceneObject(BaseModel):
    """ì¥ë©´ ì˜¤ë¸Œì íŠ¸ (í´ë¦­ ê°€ëŠ¥í•œ í•«ìŠ¤íŒŸ).

    í™”ë©´ì—ì„œ í´ë¦­ ê°€ëŠ¥í•œ ì˜¤ë¸Œì íŠ¸ì…ë‹ˆë‹¤.
    ì¢Œí‘œëŠ” 0~1000 ì •ê·œí™” ì¢Œí‘œê³„ë¥¼ ì‚¬ìš©í•©ë‹ˆë‹¤ (RULE-009).

    Attributes:
        id: ì˜¤ë¸Œì íŠ¸ ê³ ìœ  ID
        label: ì˜¤ë¸Œì íŠ¸ ë¼ë²¨ (í‘œì‹œìš©)
        box_2d: ë°”ìš´ë”© ë°•ìŠ¤ [ymin, xmin, ymax, xmax]
        interaction_hint: ìƒí˜¸ì‘ìš© íŒíŠ¸ (ì„ íƒ)
    """

    model_config = ConfigDict(extra="forbid")

    id: str = Field(description="ì˜¤ë¸Œì íŠ¸ ê³ ìœ  ID")
    label: str = Field(description="ì˜¤ë¸Œì íŠ¸ ë¼ë²¨ (í‘œì‹œìš©)")
    box_2d: Box2D = Field(description="ë°”ìš´ë”© ë°•ìŠ¤")
    interaction_hint: str | None = Field(default=None, description="ìƒí˜¸ì‘ìš© íŒíŠ¸ (ì„ íƒ)")


class ActionDeck(BaseModel):
    """ì•¡ì…˜ ë± (Q1 ê²°ì •: ui.action_deck.cards[] êµ¬ì¡°).

    ë§¤ í„´ AIê°€ ì œì‹œí•˜ëŠ” ì¶”ì²œ í–‰ë™ ì¹´ë“œ ë±ì…ë‹ˆë‹¤.

    Attributes:
        cards: ì•¡ì…˜ ì¹´ë“œ ëª©ë¡ (3~6ì¥ ê¶Œì¥)
    """

    model_config = ConfigDict(extra="forbid")

    cards: list[ActionCard] = Field(
        default=[],
        min_length=0,
        max_length=10,
        description="ì•¡ì…˜ ì¹´ë“œ ëª©ë¡ (3~6ì¥ ê¶Œì¥)",
    )


class UIOutput(BaseModel):
    """UI ì¶œë ¥ ë°ì´í„°.

    AIê°€ ìƒì„±í•œ UI ìš”ì†Œë“¤ì…ë‹ˆë‹¤.
    ì±„íŒ… ë²„ë¸”ì´ ì•„ë‹Œ ê²Œì„ UIë¡œ í‘œí˜„ë©ë‹ˆë‹¤ (RULE-002).

    Attributes:
        action_deck: ì•¡ì…˜ ì¹´ë“œ ë± (Q1 ê²°ì •: Option A ì±„íƒ)
        objects: í´ë¦­ ê°€ëŠ¥í•œ ì¥ë©´ ì˜¤ë¸Œì íŠ¸ ëª©ë¡
    """

    model_config = ConfigDict(extra="forbid")

    action_deck: ActionDeck = Field(default_factory=ActionDeck, description="ì•¡ì…˜ ì¹´ë“œ ë±")
    objects: list[SceneObject] = Field(default=[], description="í´ë¦­ ê°€ëŠ¥í•œ ì¥ë©´ ì˜¤ë¸Œì íŠ¸ ëª©ë¡")


# =============================================================================
# TurnOutput ê´€ë ¨ íƒ€ì… - World
# =============================================================================


class MemoryPin(BaseModel):
    """ì¤‘ìš” ì„¤ì • ê³ ì • í›„ë³´.

    ì‚¬ìš©ìê°€ Memory Shardë¥¼ ì†Œë¹„í•´ ê³ ì •í•  ìˆ˜ ìˆëŠ” ì¤‘ìš” ì„¤ì •ì…ë‹ˆë‹¤.

    Attributes:
        id: í•€ ê³ ìœ  ID
        content: ê³ ì •í•  ë‚´ìš©
        cost: ê³ ì •ì— í•„ìš”í•œ ë¹„ìš©
    """

    model_config = ConfigDict(extra="forbid")

    id: str = Field(description="í•€ ê³ ìœ  ID")
    content: str = Field(description="ê³ ì •í•  ë‚´ìš©")
    cost: CurrencyAmount = Field(description="ê³ ì •ì— í•„ìš”í•œ ë¹„ìš©")


class WorldRule(BaseModel):
    """ì„¸ê³„ ê·œì¹™ (Rule Board).

    í˜„ì¬ ì„¸ê³„ì— ì ìš© ì¤‘ì¸ ë¬¼ë¦¬ ë²•ì¹™ì´ë‚˜ ë©”íƒ€ ê·œì¹™ì…ë‹ˆë‹¤.

    Attributes:
        id: ê·œì¹™ ê³ ìœ  ID
        label: ê·œì¹™ ì´ë¦„
        description: ê·œì¹™ ìƒì„¸ ì„¤ëª… (ì„ íƒ)
    """

    model_config = ConfigDict(extra="forbid")

    id: str = Field(description="ê·œì¹™ ê³ ìœ  ID")
    label: str = Field(description="ê·œì¹™ ì´ë¦„")
    description: str | None = Field(default=None, description="ê·œì¹™ ìƒì„¸ ì„¤ëª… (ì„ íƒ)")


class Quest(BaseModel):
    """í€˜ìŠ¤íŠ¸/ëª©í‘œ (Quest Panel).

    í”Œë ˆì´ì–´ê°€ ë‹¬ì„±í•´ì•¼ í•˜ëŠ” í˜„ì¬ ëª©í‘œì…ë‹ˆë‹¤.

    Attributes:
        id: í€˜ìŠ¤íŠ¸ ê³ ìœ  ID
        label: í€˜ìŠ¤íŠ¸ ì´ë¦„
        is_completed: ë‹¬ì„± ì—¬ë¶€
    """

    model_config = ConfigDict(extra="forbid")

    id: str = Field(description="í€˜ìŠ¤íŠ¸ ê³ ìœ  ID")
    label: str = Field(description="í€˜ìŠ¤íŠ¸ ì´ë¦„")
    is_completed: bool = Field(default=False, description="ë‹¬ì„± ì—¬ë¶€")


class WorldDelta(BaseModel):
    """ì„¸ê³„ ìƒíƒœ ë³€í™” (Q2 ê²°ì •: Option A - delta ì¤‘ì‹¬).

    ì´ë²ˆ í„´ì—ì„œ ë³€ê²½ëœ ì„¸ê³„ ìƒíƒœë¥¼ ë‚˜íƒ€ëƒ…ë‹ˆë‹¤.
    snapshotì€ SaveGameì—ë§Œ ì €ì¥í•˜ê³ , ë§¤ í„´ì€ deltaë§Œ ì „ì†¡í•©ë‹ˆë‹¤.

    Attributes:
        rules_changed: ë³€ê²½ë˜ê±°ë‚˜ ì¶”ê°€ëœ ê·œì¹™ ëª©ë¡
        inventory_added: ì¶”ê°€ëœ ì¸ë²¤í† ë¦¬ ì•„ì´í…œ
        inventory_removed: ì œê±°ëœ ì¸ë²¤í† ë¦¬ ì•„ì´í…œ
        quests_updated: ì—…ë°ì´íŠ¸ëœ í€˜ìŠ¤íŠ¸(ëª©í‘œ) ëª©ë¡
        relationships_changed: ë³€ê²½ëœ ê´€ê³„
        memory_pins: ì¤‘ìš” ì„¤ì • ê³ ì • í›„ë³´
    """

    model_config = ConfigDict(extra="forbid")

    rules_changed: list[WorldRule] = Field(default=[], description="ë³€ê²½ëœ ê·œì¹™ ëª©ë¡")
    inventory_added: list[str] = Field(default=[], description="ì¶”ê°€ëœ ì¸ë²¤í† ë¦¬ ì•„ì´í…œ")
    inventory_removed: list[str] = Field(default=[], description="ì œê±°ëœ ì¸ë²¤í† ë¦¬ ì•„ì´í…œ")
    quests_updated: list[Quest] = Field(default=[], description="ì—…ë°ì´íŠ¸ëœ í€˜ìŠ¤íŠ¸/ëª©í‘œ ëª©ë¡")
    relationships_changed: list[str] = Field(default=[], description="ë³€ê²½ëœ ê´€ê³„")
    memory_pins: list[MemoryPin] = Field(default=[], description="ì¤‘ìš” ì„¤ì • ê³ ì • í›„ë³´")


# =============================================================================
# TurnOutput ê´€ë ¨ íƒ€ì… - Render
# =============================================================================


class ImageJob(BaseModel):
    """ì´ë¯¸ì§€ ìƒì„± ì‘ì—….

    ì¡°ê±´ë¶€ ì´ë¯¸ì§€ ìƒì„±/í¸ì§‘ ìš”ì²­ì…ë‹ˆë‹¤.
    ì´ë¯¸ì§€ ìƒì„±ì´ ëŠë¦´ ê²½ìš° í…ìŠ¤íŠ¸ ìš°ì„  ì¶œë ¥ + Lazy Loadingì„ ì‚¬ìš©í•©ë‹ˆë‹¤.

    Attributes:
        should_generate: ì´ë¯¸ì§€ë¥¼ ìƒì„±í•´ì•¼ í•˜ëŠ”ì§€
        prompt: ì´ë¯¸ì§€ ìƒì„± í”„ë¡¬í”„íŠ¸
        model_label: ëª¨ë¸ ì„ íƒ ë¼ë²¨ (FAST/QUALITY/CHEAP/REF)
        aspect_ratio: ê°€ë¡œì„¸ë¡œ ë¹„ìœ¨ (ì˜ˆ: "16:9", "1:1")
        image_size: ì´ë¯¸ì§€ í¬ê¸° (ì˜ˆ: "1024x1024")
        reference_image_ids: ì°¸ì¡° ì´ë¯¸ì§€ ID ëª©ë¡ (ì„ íƒ)
        remove_background: ë°°ê²½ ì œê±° ì—¬ë¶€ (U-035, rembg ì‚¬ìš©)
        image_type_hint: ì´ë¯¸ì§€ ìœ í˜• íŒíŠ¸ (rembg ëª¨ë¸ ìë™ ì„ íƒìš©)
    """

    model_config = ConfigDict(extra="forbid")

    should_generate: bool = Field(description="ì´ë¯¸ì§€ë¥¼ ìƒì„±í•´ì•¼ í•˜ëŠ”ì§€")
    prompt: str = Field(default="", description="ì´ë¯¸ì§€ ìƒì„± í”„ë¡¬í”„íŠ¸")
    model_label: ModelLabel = Field(default=ModelLabel.FAST, description="ëª¨ë¸ ì„ íƒ ë¼ë²¨")
    aspect_ratio: str = Field(default="16:9", description="ê°€ë¡œì„¸ë¡œ ë¹„ìœ¨")
    image_size: str = Field(default="1024x1024", description="ì´ë¯¸ì§€ í¬ê¸°")
    reference_image_ids: list[str] = Field(default=[], description="ì°¸ì¡° ì´ë¯¸ì§€ ID ëª©ë¡ (ì„ íƒ)")
    remove_background: bool = Field(default=False, description="ë°°ê²½ ì œê±° ì—¬ë¶€ (U-035, rembg ì‚¬ìš©)")
    image_type_hint: str | None = Field(
        default=None,
        description="ì´ë¯¸ì§€ ìœ í˜• íŒíŠ¸ (object/character/icon/portrait ë“±, rembg ëª¨ë¸ ìë™ ì„ íƒìš©)",
    )


class RenderOutput(BaseModel):
    """ë Œë”ë§ ì¶œë ¥ ë°ì´í„°.

    ì´ë¯¸ì§€ ìƒì„±/í¸ì§‘ ê´€ë ¨ ì •ë³´ì…ë‹ˆë‹¤.

    Attributes:
        image_job: ì´ë¯¸ì§€ ìƒì„± ì‘ì—… (ì„ íƒ)
    """

    model_config = ConfigDict(extra="forbid")

    image_job: ImageJob | None = Field(default=None, description="ì´ë¯¸ì§€ ìƒì„± ì‘ì—… (ì„ íƒ)")


# =============================================================================
# TurnOutput ê´€ë ¨ íƒ€ì… - Economy
# =============================================================================


class EconomyOutput(BaseModel):
    """ê²½ì œ ì¶œë ¥ ë°ì´í„° (RULE-005).

    ì´ë²ˆ í„´ì˜ ë¹„ìš©ê³¼ ì”ì•¡ ì •ë³´ì…ë‹ˆë‹¤.
    ì”ì•¡ ìŒìˆ˜ëŠ” ì ˆëŒ€ ë¶ˆê°€ (ì„œë²„ Hard gate).

    Attributes:
        cost: ì´ë²ˆ í„´ì— ì†Œë¹„ëœ ë¹„ìš©
        balance_after: ì†Œë¹„ í›„ ì”ì•¡

    Important:
        - costì™€ balance_afterëŠ” í•­ìƒ í¬í•¨ë˜ì–´ì•¼ í•©ë‹ˆë‹¤.
        - balance_afterì˜ signalê³¼ memory_shardëŠ” 0 ì´ìƒì´ì–´ì•¼ í•©ë‹ˆë‹¤.
    """

    model_config = ConfigDict(extra="forbid")

    cost: CurrencyAmount = Field(description="ì´ë²ˆ í„´ì— ì†Œë¹„ëœ ë¹„ìš©")
    balance_after: CurrencyAmount = Field(description="ì†Œë¹„ í›„ ì”ì•¡")


# =============================================================================
# TurnOutput ê´€ë ¨ íƒ€ì… - Safety
# =============================================================================


class SafetyOutput(BaseModel):
    """ì•ˆì „ ì¶œë ¥ ë°ì´í„°.

    ì•ˆì „ ì •ì±… ê´€ë ¨ ì •ë³´ì…ë‹ˆë‹¤.
    ì°¨ë‹¨ ì‹œ ëª…ì‹œì  ë©”ì‹œì§€ì™€ í•¨ê»˜ ì•ˆì „í•œ ëŒ€ì²´ ê²°ê³¼ë¥¼ ì œê³µí•©ë‹ˆë‹¤.

    Attributes:
        blocked: ì•ˆì „ ì •ì±…ì— ì˜í•´ ì°¨ë‹¨ë˜ì—ˆëŠ”ì§€
        message: ì°¨ë‹¨ ì‹œ ì‚¬ìš©ìì—ê²Œ í‘œì‹œí•  ë©”ì‹œì§€ (ì„ íƒ)
    """

    model_config = ConfigDict(extra="forbid")

    blocked: bool = Field(default=False, description="ì•ˆì „ ì •ì±…ì— ì˜í•´ ì°¨ë‹¨ë˜ì—ˆëŠ”ì§€")
    message: str | None = Field(default=None, description="ì°¨ë‹¨ ì‹œ ì‚¬ìš©ìì—ê²Œ í‘œì‹œí•  ë©”ì‹œì§€ (ì„ íƒ)")


# =============================================================================
# TurnOutput ê´€ë ¨ íƒ€ì… - Agent Console
# =============================================================================


class AgentConsole(BaseModel):
    """ì—ì´ì „íŠ¸ ì½˜ì†” ë°ì´í„° (RULE-008).

    ì—ì´ì „íŠ¸í˜• ì‹œìŠ¤í…œì„ì„ UIë¡œ ì¦ëª…í•˜ê¸° ìœ„í•œ ì •ë³´ì…ë‹ˆë‹¤.
    ê³„íš/ì‹¤í–‰/ê²€ì¦/ë³µêµ¬ì˜ í”ì ì„ í‘œì‹œí•©ë‹ˆë‹¤.

    Attributes:
        current_phase: í˜„ì¬ ì‹¤í–‰ ë‹¨ê³„
        badges: ê²€ì¦ ë°°ì§€ ëª©ë¡
        repair_count: ìë™ ë³µêµ¬ ì‹œë„ íšŸìˆ˜
    """

    model_config = ConfigDict(extra="forbid")

    current_phase: AgentPhase = Field(default=AgentPhase.COMMIT, description="í˜„ì¬ ì‹¤í–‰ ë‹¨ê³„")
    badges: list[ValidationBadge] = Field(default=[], description="ê²€ì¦ ë°°ì§€ ëª©ë¡")
    repair_count: Annotated[int, Field(ge=0, description="ìë™ ë³µêµ¬ ì‹œë„ íšŸìˆ˜")] = 0


# =============================================================================
# TurnOutput (ë©”ì¸ ì‘ë‹µ ìŠ¤í‚¤ë§ˆ)
# =============================================================================


class TurnOutput(BaseModel):
    """í„´ ì¶œë ¥ (ì„œë²„ â†’ í´ë¼ì´ì–¸íŠ¸).

    ì„œë²„ê°€ í„´ ì²˜ë¦¬ í›„ í´ë¼ì´ì–¸íŠ¸ë¡œ ë°˜í™˜í•˜ëŠ” êµ¬ì¡°í™”ëœ ì‘ë‹µì…ë‹ˆë‹¤.
    Gemini Structured Outputs(JSON Schema)ë¡œ ê°•ì œë©ë‹ˆë‹¤.

    Hard Gate í•„ë“œ (RULE-003/004/005):
        - economy: costì™€ balance_after í•„ìˆ˜, ì”ì•¡ ìŒìˆ˜ ê¸ˆì§€
        - safety: blocked ì‹œ ì•ˆì „í•œ ëŒ€ì²´ ê²°ê³¼ ì œê³µ
        - language: ìš”ì²­ ì–¸ì–´ì™€ ë™ì¼í•˜ê²Œ ê³ ì • (í˜¼í•© ì¶œë ¥ ê¸ˆì§€)

    Attributes:
        language: ì‘ë‹µ ì–¸ì–´ (ìš”ì²­ê³¼ ë™ì¼)
        narrative: ë‚´ëŸ¬í‹°ë¸Œ í…ìŠ¤íŠ¸ (í‘œì‹œìš©)
        ui: UI ìš”ì†Œ (ì•¡ì…˜ ë±, ì˜¤ë¸Œì íŠ¸)
        world: ì„¸ê³„ ìƒíƒœ ë³€í™” (delta ì¤‘ì‹¬)
        render: ë Œë”ë§ ì •ë³´ (ì´ë¯¸ì§€ ìƒì„± ì‘ì—…)
        economy: ê²½ì œ ì •ë³´ (ë¹„ìš©, ì”ì•¡)
        safety: ì•ˆì „ ì •ì±… ì •ë³´
        agent_console: ì—ì´ì „íŠ¸ ì‹¤í–‰ ì •ë³´ (ë‹¨ê³„, ë°°ì§€, ë³µêµ¬ íšŸìˆ˜)

    Example:
        >>> output = TurnOutput(
        ...     language=Language.KO,
        ...     narrative="ë¬¸ì´ ì‚ê±±ê±°ë¦¬ë©° ì—´ë¦½ë‹ˆë‹¤...",
        ...     economy=EconomyOutput(
        ...         cost=CurrencyAmount(signal=5, memory_shard=0),
        ...         balance_after=CurrencyAmount(signal=95, memory_shard=5),
        ...     ),
        ...     safety=SafetyOutput(blocked=False),
        ... )
        >>> schema = TurnOutput.model_json_schema()

    Schema Generation:
        >>> # Gemini Structured Outputsìš© JSON Schema ìƒì„±
        >>> json_schema = TurnOutput.model_json_schema()
        >>> # response_json_schema íŒŒë¼ë¯¸í„°ì— ì „ë‹¬
        >>> config = {
        ...     "response_mime_type": "application/json",
        ...     "response_json_schema": json_schema,
        ... }
    """

    model_config = ConfigDict(extra="forbid")

    # í•„ìˆ˜ í•„ë“œ (Hard Gate)
    language: Language = Field(description="ì‘ë‹µ ì–¸ì–´ (ìš”ì²­ê³¼ ë™ì¼)")
    narrative: str = Field(description="ë‚´ëŸ¬í‹°ë¸Œ í…ìŠ¤íŠ¸ (í‘œì‹œìš©)")
    economy: EconomyOutput = Field(description="ê²½ì œ ì •ë³´ (ë¹„ìš©, ì”ì•¡)")
    safety: SafetyOutput = Field(description="ì•ˆì „ ì •ì±… ì •ë³´")

    # UI ê´€ë ¨ í•„ë“œ
    ui: UIOutput = Field(default_factory=UIOutput, description="UI ìš”ì†Œ")

    # ì„¸ê³„ ìƒíƒœ í•„ë“œ
    world: WorldDelta = Field(default_factory=WorldDelta, description="ì„¸ê³„ ìƒíƒœ ë³€í™” (delta)")

    # ë Œë”ë§ í•„ë“œ
    render: RenderOutput = Field(default_factory=RenderOutput, description="ë Œë”ë§ ì •ë³´")

    # ì—ì´ì „íŠ¸ ì½˜ì†” í•„ë“œ
    agent_console: AgentConsole = Field(
        default_factory=AgentConsole, description="ì—ì´ì „íŠ¸ ì‹¤í–‰ ì •ë³´"
    )
</file>

<file path="backend/src/unknown_world/orchestrator/repair_loop.py">
"""Unknown World - Repair Loop (ì œí•œëœ ì¬ì‹œë„).

ìŠ¤í‚¤ë§ˆ/ë¹„ì¦ˆë‹ˆìŠ¤ ë£° ê²€ì¦ ì‹¤íŒ¨ ì‹œ ìë™ìœ¼ë¡œ ì¬ì‹œë„í•˜ëŠ” ë£¨í”„ì…ë‹ˆë‹¤.
max_repair_attempts ë‚´ì—ì„œ repair ì¬ìš”ì²­ì„ ìˆ˜í–‰í•˜ê³ ,
ìµœì¢… ì‹¤íŒ¨ ì‹œ ì•ˆì „í•œ í´ë°±ìœ¼ë¡œ ì¢…ë£Œí•©ë‹ˆë‹¤.

ì„¤ê³„ ì›ì¹™:
    - RULE-004: ê²€ì¦ ì‹¤íŒ¨ ì‹œ Repair loop + ì•ˆì „í•œ í´ë°±
    - RULE-007/008: í”„ë¡¬í”„íŠ¸ ì›ë¬¸/ë‚´ë¶€ ì¶”ë¡  ë…¸ì¶œ ê¸ˆì§€, ê²°ê³¼/íšŸìˆ˜ë§Œ í‘œì‹œ

í˜ì–´ë§ ê²°ì •:
    - Q1: max_repair_attempts = 2 (Option A)

ì°¸ì¡°:
    - vibe/unit-plans/U-018[Mvp].md
    - vibe/unit-results/U-017[Mvp].md
"""

from __future__ import annotations

import logging
from dataclasses import dataclass, field
from typing import TYPE_CHECKING

from unknown_world.config.models import ModelLabel
from unknown_world.models.turn import (
    CurrencyAmount,
    Language,
    TurnInput,
    TurnOutput,
    ValidationBadge,
)
from unknown_world.orchestrator.fallback import create_safe_fallback
from unknown_world.orchestrator.generate_turn_output import (
    GenerationResult,
    GenerationStatus,
    get_turn_output_generator,
)
from unknown_world.validation.business_rules import (
    BusinessRuleValidationResult,
    validate_business_rules,
)

if TYPE_CHECKING:
    pass

# =============================================================================
# ë¡œê±° ì„¤ì • (í”„ë¡¬í”„íŠ¸/ë‚´ë¶€ ì¶”ë¡  ë…¸ì¶œ ê¸ˆì§€ - RULE-007/008)
# =============================================================================

logger = logging.getLogger(__name__)


# =============================================================================
# ì„¤ì • ìƒìˆ˜
# =============================================================================

# í˜ì–´ë§ ê²°ì •: Q1 = Option A (2íšŒ)
MAX_REPAIR_ATTEMPTS = 2
"""ìµœëŒ€ ë³µêµ¬ ì‹œë„ íšŸìˆ˜."""


# =============================================================================
# i18n Repair ì»¨í…ìŠ¤íŠ¸ ë©”ì‹œì§€ (RULE-006, RU-005-S2)
# =============================================================================

REPAIR_CONTEXT_MESSAGES: dict[Language, dict[str, str]] = {
    Language.KO: {
        "schema_header": "## ì´ì „ ì‹œë„ ê²°ê³¼",
        "schema_error": "ì‘ë‹µ í˜•ì‹ì´ ì˜¬ë°”ë¥´ì§€ ì•Šì•˜ìŠµë‹ˆë‹¤.",
        "schema_instruction": "TurnOutput JSON Schemaë¥¼ ì •í™•íˆ ì¤€ìˆ˜í•˜ì—¬ ë‹¤ì‹œ ìƒì„±í•˜ì„¸ìš”.",
        "business_header": "## ì´ì „ ì‹œë„ ê²°ê³¼",
        "business_instruction": "ìœ„ ê·œì¹™ì„ ì¤€ìˆ˜í•˜ì—¬ ë‹¤ì‹œ ìƒì„±í•˜ì„¸ìš”.",
        # U-043: ì–¸ì–´ êµì • ì „ìš© í”¼ë“œë°±
        "language_header": "## ì–¸ì–´ í˜¼í•© ì˜¤ë¥˜",
        "language_instruction": (
            "ì‚¬ìš©ì ë…¸ì¶œ í…ìŠ¤íŠ¸ì— ì˜ì–´ê°€ ì„ì—¬ ìˆìŠµë‹ˆë‹¤. "
            "ëª¨ë“  í…ìŠ¤íŠ¸ë¥¼ í•œêµ­ì–´(ko-KR)ë¡œë§Œ ì‘ì„±í•˜ì„¸ìš”. "
            "ìŠ¤í‚¤ë§ˆ êµ¬ì¡°ëŠ” ìœ ì§€í•˜ê³  í…ìŠ¤íŠ¸ ê°’ë§Œ í•œêµ­ì–´ë¡œ ìˆ˜ì •í•©ë‹ˆë‹¤. "
            "ì˜ˆì™¸: Signal, Shard ë“± ì¬í™” ì´ë¦„ì€ ì˜ì–´ë¡œ ìœ ì§€ ê°€ëŠ¥í•©ë‹ˆë‹¤."
        ),
    },
    Language.EN: {
        "schema_header": "## Previous Attempt Result",
        "schema_error": "The response format was invalid.",
        "schema_instruction": "Please regenerate following the TurnOutput JSON Schema exactly.",
        "business_header": "## Previous Attempt Result",
        "business_instruction": "Please regenerate following the rules above.",
        # U-043: ì–¸ì–´ êµì • ì „ìš© í”¼ë“œë°±
        "language_header": "## Language Mixing Error",
        "language_instruction": (
            "User-facing text contains Korean characters. "
            "Rewrite all text in English (en-US) only. "
            "Keep the schema structure intact and only modify text values to English. "
            "Exception: Currency names like Signal, Shard may remain in English."
        ),
    },
}


# =============================================================================
# Repair Loop ê²°ê³¼ íƒ€ì…
# =============================================================================


@dataclass
class RepairLoopResult:
    """Repair Loop ê²°ê³¼.

    Attributes:
        output: ìµœì¢… TurnOutput (ì„±ê³µ ë˜ëŠ” í´ë°±)
        total_attempts: ì´ ì‹œë„ íšŸìˆ˜ (ì´ˆê¸° ì‹œë„ í¬í•¨)
        repair_attempts: ë³µêµ¬ ì‹œë„ íšŸìˆ˜ (ì´ˆê¸° ì‹œë„ ì œì™¸)
        is_fallback: í´ë°±ìœ¼ë¡œ ì¢…ë£Œë˜ì—ˆëŠ”ì§€
        badges: ê²€ì¦ ë°°ì§€ ëª©ë¡
        error_messages: ê° ì‹œë„ì˜ ì—ëŸ¬ ë©”ì‹œì§€ (UI ë…¸ì¶œìš©)
    """

    output: TurnOutput
    total_attempts: int = 1
    repair_attempts: int = 0
    is_fallback: bool = False
    badges: list[ValidationBadge] = field(default_factory=lambda: [])
    error_messages: list[str] = field(default_factory=lambda: [])


# =============================================================================
# Repair Loop í•¨ìˆ˜
# =============================================================================


async def run_repair_loop(
    turn_input: TurnInput,
    *,
    model_label: ModelLabel | None = None,
    world_context: str = "",
    force_mock: bool = False,
    max_attempts: int = MAX_REPAIR_ATTEMPTS,
) -> RepairLoopResult:
    """Repair Loopë¥¼ ì‹¤í–‰í•©ë‹ˆë‹¤.

    ì´ˆê¸° ìƒì„±ì„ ì‹œë„í•˜ê³ , ì‹¤íŒ¨ ì‹œ max_attemptsê¹Œì§€ ì¬ì‹œë„í•©ë‹ˆë‹¤.
    ìµœì¢… ì‹¤íŒ¨ ì‹œ ì•ˆì „í•œ í´ë°±ì„ ë°˜í™˜í•©ë‹ˆë‹¤.

    Args:
        turn_input: ì‚¬ìš©ì í„´ ì…ë ¥
        model_label: ì‚¬ìš©í•  ëª¨ë¸ ë¼ë²¨ (Noneì´ë©´ ê¸°ë³¸ê°’ FAST)
        world_context: í˜„ì¬ ì„¸ê³„ ìƒíƒœ ìš”ì•½ (ì„ íƒ)
        force_mock: Mock í´ë¼ì´ì–¸íŠ¸ ê°•ì œ ì‚¬ìš© ì—¬ë¶€
        max_attempts: ìµœëŒ€ ë³µêµ¬ ì‹œë„ íšŸìˆ˜

    Returns:
        RepairLoopResult: ìµœì¢… ê²°ê³¼ (ì„±ê³µ ë˜ëŠ” í´ë°±)

    Example:
        >>> result = await run_repair_loop(turn_input)
        >>> if result.is_fallback:
        ...     print(f"í´ë°±ìœ¼ë¡œ ì¢…ë£Œ (ì‹œë„: {result.repair_attempts})")
        >>> print(result.output.narrative)
    """
    generator = get_turn_output_generator(force_mock=force_mock)
    economy_snapshot = CurrencyAmount(
        signal=turn_input.economy_snapshot.signal,
        memory_shard=turn_input.economy_snapshot.memory_shard,
    )

    error_messages: list[str] = []
    badges: list[ValidationBadge] = []
    repair_context = ""  # ì¬ì‹œë„ ì‹œ ì¶”ê°€í•  ì»¨í…ìŠ¤íŠ¸

    last_attempt = 0
    for attempt in range(max_attempts + 1):  # 0 = ì´ˆê¸° ì‹œë„, 1~max = ë³µêµ¬ ì‹œë„
        badges = []  # ë§¤ ì‹œë„ë§ˆë‹¤ ë°°ì§€ ì´ˆê¸°í™” (ìµœì¢… ì‹œë„ ìƒíƒœë§Œ ìœ ì§€)
        last_attempt = attempt
        is_repair = attempt > 0

        # ë¡œê·¸ ê¸°ë¡ (í”„ë¡¬í”„íŠ¸ ë…¸ì¶œ ê¸ˆì§€)
        logger.info(
            "[RepairLoop] ì‹œë„",
            extra={
                "attempt": attempt,
                "is_repair": is_repair,
                "language": turn_input.language.value,
            },
        )

        # ì»¨í…ìŠ¤íŠ¸ êµ¬ì„± (ë³µêµ¬ ì‹œ ì—ëŸ¬ ìš”ì•½ ì¶”ê°€)
        current_context = world_context
        if is_repair and repair_context:
            current_context = f"{world_context}\n\n{repair_context}"

        # ìƒì„± ì‹œë„
        gen_result = await generator.generate(
            turn_input,
            model_label=model_label,
            world_context=current_context,
        )

        # 1. ìŠ¤í‚¤ë§ˆ ê²€ì¦ ì‹¤íŒ¨ (JSON íŒŒì‹±/Pydantic ì‹¤íŒ¨)
        if gen_result.status == GenerationStatus.SCHEMA_FAILURE:
            badges.append(ValidationBadge.SCHEMA_FAIL)
            error_messages.append(gen_result.error_message)
            # RU-005-S2: languageì— ë”°ë¼ repair ë©”ì‹œì§€ ë¶„ê¸°
            repair_context = _build_repair_context_schema(gen_result, turn_input.language)
            continue

        # 2. API ì—ëŸ¬
        if gen_result.status == GenerationStatus.API_ERROR:
            badges.append(ValidationBadge.SCHEMA_FAIL)
            error_messages.append(gen_result.error_message)
            # API ì—ëŸ¬ëŠ” ì¬ì‹œë„í•´ë„ ë™ì¼í•œ ê²°ê³¼ì¼ ê°€ëŠ¥ì„±ì´ ë†’ìŒ
            # í•˜ì§€ë§Œ ì¼ì‹œì  ì˜¤ë¥˜ì¼ ìˆ˜ ìˆìœ¼ë¯€ë¡œ ì¬ì‹œë„ í—ˆìš©
            repair_context = ""
            continue

        # 3. ìŠ¤í‚¤ë§ˆ ê²€ì¦ ì„±ê³µ â†’ ë¹„ì¦ˆë‹ˆìŠ¤ ë£° ê²€ì¦
        if gen_result.status == GenerationStatus.SUCCESS and gen_result.output:
            badges.append(ValidationBadge.SCHEMA_OK)

            # ë¹„ì¦ˆë‹ˆìŠ¤ ë£° ê²€ì¦
            biz_result = validate_business_rules(turn_input, gen_result.output)

            if biz_result.is_valid:
                # ëª¨ë“  ê²€ì¦ í†µê³¼
                badges.extend(
                    [
                        ValidationBadge.ECONOMY_OK,
                        ValidationBadge.SAFETY_OK,
                        ValidationBadge.CONSISTENCY_OK,
                    ]
                )

                # ì„œë²„ ê²€ì¦ ê²°ê³¼ë¡œ ì—…ë°ì´íŠ¸ (RULE-003/004/008)
                gen_result.output.agent_console.badges = badges
                gen_result.output.agent_console.repair_count = attempt

                logger.info(
                    "[RepairLoop] ì„±ê³µ",
                    extra={
                        "total_attempts": attempt + 1,
                        "repair_attempts": attempt,
                    },
                )

                return RepairLoopResult(
                    output=gen_result.output,
                    total_attempts=attempt + 1,
                    repair_attempts=attempt,
                    is_fallback=False,
                    badges=badges,
                    error_messages=error_messages,
                )

            # ë¹„ì¦ˆë‹ˆìŠ¤ ë£° ì‹¤íŒ¨
            add_business_badges(biz_result, badges)
            error_messages.append(biz_result.error_summary)
            # RU-005-S2: languageì— ë”°ë¼ repair ë©”ì‹œì§€ ë¶„ê¸°
            repair_context = _build_repair_context_business(biz_result, turn_input.language)
            continue

        # 4. ì•ˆì „ ì°¨ë‹¨
        if gen_result.status == GenerationStatus.SAFETY_BLOCKED:
            badges.append(ValidationBadge.SAFETY_BLOCKED)
            # ì•ˆì „ ì°¨ë‹¨ì€ ì¬ì‹œë„ ë¶ˆê°€ â†’ ì¦‰ì‹œ í´ë°±
            logger.warning(
                "[RepairLoop] ì•ˆì „ ì°¨ë‹¨ìœ¼ë¡œ í´ë°±",
                extra={"attempt": attempt},
            )
            break

    # ìµœì¢… ì‹¤íŒ¨ â†’ ì•ˆì „í•œ í´ë°± ë°˜í™˜
    logger.warning(
        "[RepairLoop] ìµœì¢… í´ë°± ë°˜í™˜",
        extra={
            "max_attempts": max_attempts,
            "actual_attempts": last_attempt,
        },
    )

    fallback = create_safe_fallback(
        language=turn_input.language,
        economy_snapshot=economy_snapshot,
        repair_count=last_attempt,
        is_blocked=ValidationBadge.SAFETY_BLOCKED in badges,
    )

    return RepairLoopResult(
        output=fallback,
        total_attempts=last_attempt + 1,
        repair_attempts=last_attempt,
        is_fallback=True,
        badges=badges,
        error_messages=error_messages,
    )


# =============================================================================
# í—¬í¼ í•¨ìˆ˜
# =============================================================================


def _build_repair_context_schema(gen_result: GenerationResult, language: Language) -> str:
    """ìŠ¤í‚¤ë§ˆ ì‹¤íŒ¨ì— ëŒ€í•œ Repair ì»¨í…ìŠ¤íŠ¸ë¥¼ êµ¬ì„±í•©ë‹ˆë‹¤.

    í”„ë¡¬í”„íŠ¸ ì›ë¬¸/ìƒì„¸ ì˜¤ë¥˜ëŠ” ë…¸ì¶œí•˜ì§€ ì•Šê³ , ê°„ë‹¨í•œ ì§€ì‹œë§Œ í¬í•¨í•©ë‹ˆë‹¤.
    ì–¸ì–´ì— ë”°ë¼ ë©”ì‹œì§€ë¥¼ ë¶„ê¸°í•©ë‹ˆë‹¤ (RULE-006, RU-005-S2).

    Args:
        gen_result: ìƒì„± ê²°ê³¼
        language: ì‘ë‹µ ì–¸ì–´
    """
    # ì§§ì€ ìš”ì•½ë§Œ í¬í•¨ (RULE-007/008)
    messages = REPAIR_CONTEXT_MESSAGES[language]
    return f"""
{messages["schema_header"]}

{messages["schema_error"]}
{messages["schema_instruction"]}
"""


def _build_repair_context_business(
    biz_result: BusinessRuleValidationResult, language: Language
) -> str:
    """ë¹„ì¦ˆë‹ˆìŠ¤ ë£° ì‹¤íŒ¨ì— ëŒ€í•œ Repair ì»¨í…ìŠ¤íŠ¸ë¥¼ êµ¬ì„±í•©ë‹ˆë‹¤.

    ì–¸ì–´ì— ë”°ë¼ ë©”ì‹œì§€ë¥¼ ë¶„ê¸°í•©ë‹ˆë‹¤ (RULE-006, RU-005-S2).
    ì–¸ì–´ í˜¼í•© ì—ëŸ¬ê°€ ìˆìœ¼ë©´ íŠ¹ë³„í•œ ì§€ì‹œë¥¼ ì¶”ê°€í•©ë‹ˆë‹¤ (U-043).

    Args:
        biz_result: ë¹„ì¦ˆë‹ˆìŠ¤ ë£° ê²€ì¦ ê²°ê³¼
        language: ì‘ë‹µ ì–¸ì–´
    """
    messages = REPAIR_CONTEXT_MESSAGES[language]

    # U-043: ì–¸ì–´ í˜¼í•© ì—ëŸ¬ê°€ ìˆëŠ”ì§€ í™•ì¸
    has_language_content_error = any(
        "language_content_mixed" in err["type"] for err in biz_result.errors
    )

    # ì–¸ì–´ í˜¼í•© ì—ëŸ¬ê°€ ìˆìœ¼ë©´ íŠ¹ë³„í•œ ì§€ì‹œ ì¶”ê°€
    if has_language_content_error:
        return f"""
{messages["language_header"]}

{biz_result.error_summary}

{messages["language_instruction"]}
"""

    # ì¼ë°˜ ë¹„ì¦ˆë‹ˆìŠ¤ ë£° ì—ëŸ¬
    return f"""
{messages["business_header"]}

{biz_result.error_summary}

{messages["business_instruction"]}
"""


def add_business_badges(
    biz_result: BusinessRuleValidationResult,
    badges: list[ValidationBadge],
) -> None:
    """ë¹„ì¦ˆë‹ˆìŠ¤ ë£° ê²€ì¦ ê²°ê³¼ì— ë”°ë¼ ë°°ì§€ë¥¼ ì¶”ê°€í•©ë‹ˆë‹¤.

    ì—ëŸ¬ íƒ€ì… ì ‘ë‘ì–´ â†’ ë°°ì§€ ë§¤í•‘:
        - economy_* â†’ ECONOMY_FAIL
        - safety_* â†’ SAFETY_BLOCKED
        - language_* (mismatch/content_mixed) ë˜ëŠ” box2d_* â†’ CONSISTENCY_FAIL

    RU-005-S1: consistency ì—ëŸ¬ê°€ ëˆ„ë½ë˜ì§€ ì•Šë„ë¡ ë§¤í•‘ì„ ì™„ì „í•˜ê²Œ êµ¬í˜„.
    U-043: language_content_mixedë„ CONSISTENCY_FAILë¡œ ë§¤í•‘.

    Args:
        biz_result: ë¹„ì¦ˆë‹ˆìŠ¤ ë£° ê²€ì¦ ê²°ê³¼
        badges: ë°°ì§€ ëª©ë¡ (in-place ìˆ˜ì •)
    """
    # ì—ëŸ¬ íƒ€ì…ë³„ ë°°ì§€ ë§¤í•‘ (RU-005-S1, U-043)
    has_economy_error = any("economy" in err["type"] for err in biz_result.errors)
    has_safety_error = any("safety" in err["type"] for err in biz_result.errors)
    # U-043: language_mismatch, language_content_mixed, box2d_* ëª¨ë‘ consistencyë¡œ ë§¤í•‘
    has_consistency_error = any(
        "language" in err["type"] or "box2d" in err["type"] for err in biz_result.errors
    )

    # Economy ë°°ì§€
    if has_economy_error:
        badges.append(ValidationBadge.ECONOMY_FAIL)
    else:
        badges.append(ValidationBadge.ECONOMY_OK)

    # Safety ë°°ì§€
    if has_safety_error:
        badges.append(ValidationBadge.SAFETY_BLOCKED)
    else:
        badges.append(ValidationBadge.SAFETY_OK)

    # Consistency ë°°ì§€ (RU-005-S1: ì–¸ì–´/ì¢Œí‘œ ê·œì•½ ìœ„ë°˜ í‘œì‹œ)
    if has_consistency_error:
        badges.append(ValidationBadge.CONSISTENCY_FAIL)
    else:
        badges.append(ValidationBadge.CONSISTENCY_OK)
</file>

<file path="frontend/public/ui/README.md">
# UI ì—ì…‹ ê°€ì´ë“œ (nanobanana mcp SSOT)

> **SSOT ê²½ë¡œ**: `frontend/public/ui/`  
> **ë„êµ¬**: `nanobanana mcp` (ê°œë°œ ì „ìš©, ëŸ°íƒ€ì„ ì˜ì¡´ ê¸ˆì§€)  
> **ì°¸ì¡°**: `.gemini/rules/red-line.md` RULE-006/007, `vibe/prd.md` 9.7, `vibe/ref/rembg-guide.md`

---

## 1. í•µì‹¬ ì›ì¹™

### 1.1 Dev-only ì›ì¹™ (RULE-007)

- `nanobanana mcp`ëŠ” **ê°œë°œ ê³¼ì •ì—ì„œ ì •ì  ì—ì…‹ì„ ì œì‘**í•˜ëŠ” ë„êµ¬ì…ë‹ˆë‹¤.
- ì œí’ˆ ëŸ°íƒ€ì„(í”„ë¡ íŠ¸/ë°±ì—”ë“œ)ì—ì„œ MCPì— ì˜ì¡´í•˜ëŠ” ì„¤ê³„ëŠ” **ê¸ˆì§€**í•©ë‹ˆë‹¤.
- ìƒì„±ëœ ì—ì…‹ì€ ì´ ë””ë ‰í† ë¦¬(`frontend/public/ui/`)ì— ì»¤ë°‹í•˜ì—¬ ì •ì  ë°°í¬í•©ë‹ˆë‹¤.

### 1.2 ìš©ì–´ SSOT (RULE-006)

- ì´ ë„êµ¬ëŠ” ë°˜ë“œì‹œ **`nanobanana mcp`** ë¡œ í‘œê¸°í•©ë‹ˆë‹¤.
- "ë‚˜ë…¸ë°”ë‚˜ë‚˜ MCP", "Nano Banana MCP", "banana mcp" ë“± í˜¼ìš© ê¸ˆì§€.
- ëª¨ë¸ ë³„ì¹­("Nano Banana / Nano Banana Pro")ì€ ë¬¸ì„œ ì¸ìš© ì‹œì—ë§Œ ì œí•œì  ì‚¬ìš©.

### 1.3 ë³´ì•ˆ (RULE-005)

- í‚¤/í† í° ë“± ë¹„ë°€ì •ë³´ë¥¼ ë ˆí¬/ë¡œê·¸/ë¬¸ì„œì— ë‚¨ê¸°ì§€ ì•ŠìŠµë‹ˆë‹¤.
- ìƒì„± ê³¼ì •ì—ì„œ ì‚¬ìš©í•œ API í‚¤ë‚˜ ì¸ì¦ ì •ë³´ëŠ” ì ˆëŒ€ ì»¤ë°‹í•˜ì§€ ì•ŠìŠµë‹ˆë‹¤.

---

## 2. ë””ë ‰í† ë¦¬ êµ¬ì¡°

```
frontend/public/ui/
â”œâ”€â”€ README.md              # ì´ íŒŒì¼ (SSOT ê·œì¹™)
â”œâ”€â”€ manifest.schema.json   # ì—ì…‹ ë§¤ë‹ˆí˜ìŠ¤íŠ¸ ìŠ¤í‚¤ë§ˆ
â”œâ”€â”€ manifest.json          # (ìƒì„± ì‹œ) ì‹¤ì œ ì—ì…‹ ëª©ë¡
â”œâ”€â”€ icons/                 # ì•„ì´ì½˜ ì—ì…‹
â”‚   â”œâ”€â”€ signal-16.png
â”‚   â”œâ”€â”€ signal-24.png
â”‚   â”œâ”€â”€ badge-ok-16.png
â”‚   â””â”€â”€ ...
â”œâ”€â”€ placeholders/          # ìƒíƒœ/ì¥ë©´ placeholder
â”‚   â”œâ”€â”€ scene-loading.webp
â”‚   â”œâ”€â”€ scene-error.webp
â”‚   â””â”€â”€ ...
â””â”€â”€ chrome/                # UI í”„ë ˆì„/ì¥ì‹
    â”œâ”€â”€ panel-corner-tl.png
    â”œâ”€â”€ panel-border-h.png
    â””â”€â”€ ...
```

---

## 3. ë„¤ì´ë° ê·œì¹™

### 3.1 ê¸°ë³¸ í¬ë§·

```
{ìš©ë„}-{í¬ê¸°}.{í™•ì¥ì}
{ìš©ë„}-{ìƒíƒœ}-{í¬ê¸°}.{í™•ì¥ì}
```

**ì˜ˆì‹œ**:

- `signal-24.png` â€” Signal ì•„ì´ì½˜, 24px
- `badge-ok-16.png` â€” OK ë°°ì§€, 16px
- `scene-loading.webp` â€” ë¡œë”© ìƒíƒœ placeholder

### 3.2 ê·œì¹™

| í•­ëª©       | ê·œì¹™                                              |
| ---------- | ------------------------------------------------- |
| **ì¼€ì´ìŠ¤** | `kebab-case` (ì†Œë¬¸ì + í•˜ì´í”ˆ)                    |
| **ìš©ë„**   | ëª…í™•í•œ ì—­í•  í‘œí˜„ (signal, badge, scene, panel ë“±) |
| **ìƒíƒœ**   | í•„ìš” ì‹œ ìƒíƒœ í¬í•¨ (ok, fail, loading, error ë“±)   |
| **í¬ê¸°**   | í”½ì…€ ë‹¨ìœ„ ìˆ«ì (16, 24, 32, 64 ë“±)                |
| **í™•ì¥ì** | ìš©ë„ì— ë§ê²Œ ì„ íƒ (ì•„ë˜ ì°¸ì¡°)                      |

---

## 4. í¬ë§· ë° ì‚¬ì´ì¦ˆ ê·œì¹™

### 4.1 í¬ë§· ì„ íƒ

| ìš©ë„            | ê¸°ë³¸ í¬ë§·  | ëŒ€ì•ˆ | ë¹„ê³                                |
| --------------- | ---------- | ---- | ---------------------------------- |
| **ì•„ì´ì½˜**      | PNG (íˆ¬ëª…) | -    | ì‘ì€ í¬ê¸°, íˆ¬ëª…ë„ í•„ìˆ˜             |
| **placeholder** | WebP       | PNG  | ìš©ëŸ‰ ì ˆê° ìš°ì„  (Q1 ê²°ì •: Option B) |
| **chrome**      | PNG (íˆ¬ëª…) | -    | í”„ë ˆì„/ì¥ì‹, íˆ¬ëª…ë„ í•„ìˆ˜           |

> **ë°°ê²½ ì œê±°(í•„ìˆ˜ ì¡°ê±´ë¶€)**: ì•„ì´ì½˜/chrome ë“± íˆ¬ëª… ë°°ê²½ì´ í•„ìš”í•œ ì—ì…‹ì€ ìƒì„± ê²°ê³¼ì— ë°°ê²½ì´ ë‚¨ì•„ ìˆìœ¼ë©´ `rembg`ë¡œ ë°°ê²½ì„ ì œê±°í•´ íˆ¬ëª… PNGë¡œ ì •ë¦¬í•©ë‹ˆë‹¤. (ê°€ì´ë“œ: `vibe/ref/rembg-guide.md`)

### 4.2 ì‚¬ì´ì¦ˆ ê·œê²©

| ìš©ë„            | í•„ìˆ˜ ì‚¬ì´ì¦ˆ | ì„ íƒ ì‚¬ì´ì¦ˆ | ë¹„ê³              |
| --------------- | ----------- | ----------- | ---------------- |
| **ì•„ì´ì½˜**      | 16, 24      | 32, 64      | ìµœì†Œ 2ì¢… í•„ìˆ˜    |
| **placeholder** | ê°€ë³€        | -           | ìš©ë„ë³„ ì ì • í¬ê¸° |
| **chrome**      | ê°€ë³€        | -           | íƒ€ì¼ë§/ë°˜ë³µ ê³ ë ¤ |

### 4.3 Retina ëŒ€ì‘ (ì„ íƒ)

- í•„ìš” ì‹œ `image-set()`ìœ¼ë¡œ 1x/2x ì œê³µ
- íŒŒì¼ëª…: `{name}-24.png`, `{name}-24@2x.png`

---

## 5. ì„±ëŠ¥ ì˜ˆì‚°

| í•­ëª©                | ìƒí•œ  | ê¶Œì¥       |
| ------------------- | ----- | ---------- |
| **ì•„ì´ì½˜ 1ê°œ**      | 30KB  | 20KB ì´í•˜  |
| **placeholder 1ê°œ** | 300KB | 200KB ì´í•˜ |
| **chrome 1ê°œ**      | 50KB  | 30KB ì´í•˜  |
| **`ui/` í´ë” ì´í•©** | 1.5MB | 1MB ì´í•˜   |

**ì´ˆê³¼ ì‹œ ëŒ€ì‘**:

1. ì••ì¶•/ìµœì í™” (TinyPNG, ImageOptim ë“±)
2. í•´ìƒë„/ìƒ‰ìƒ ì¶•ì†Œ
3. ë¶ˆí•„ìš” ì—ì…‹ ì œê±°
4. ì˜ˆì‚° ìƒí–¥ ì‹œ ê·¼ê±° ë¬¸ì„œí™” í•„ìš”

---

## 6. ìŠ¤íƒ€ì¼ ê°€ì´ë“œ

### 6.1 CRT í…Œë§ˆ ì—°ë™

ì—ì…‹ì€ `frontend/src/style.css`ì˜ CSS ë³€ìˆ˜/í…Œë§ˆì™€ ì¡°í™”ë¥¼ ì´ë¤„ì•¼ í•©ë‹ˆë‹¤.

```css
/* ì°¸ì¡°: CRT í…Œë§ˆ ìƒ‰ìƒ */
--bg-color: #0d0d0d; /* ë°°ê²½ */
--text-color: #33ff00; /* ì¸ê´‘ ë…¹ìƒ‰ */
--text-dim: #1a8000; /* ì–´ë‘ìš´ ë…¹ìƒ‰ */
--accent-color: #ff00ff; /* ë§ˆì  íƒ€ */
--warning-color: #ffaa00; /* ì£¼í™©ìƒ‰ */
--error-color: #ff3333; /* ë¶‰ì€ìƒ‰ */
```

### 6.2 ìŠ¤íƒ€ì¼ ì›ì¹™

| ì›ì¹™                  | ì„¤ëª…                          |
| --------------------- | ----------------------------- |
| **ë ˆíŠ¸ë¡œ í“¨ì²˜ë¦¬ì¦˜**   | CRT/í„°ë¯¸ë„ ë¯¸í•™ê³¼ ì¡°í™”        |
| **ê¸°ëŠ¥ì  ë¯¸ë‹ˆë©€ë¦¬ì¦˜** | ë¶ˆí•„ìš”í•œ ì¥ì‹ ë°°ì œ            |
| **í†¤ ì¼ê´€ì„±**         | ì¸ê´‘ ë…¹ìƒ‰ ê¸°ë°˜, ë§ˆì  íƒ€ í¬ì¸íŠ¸ |
| **ê³ ëŒ€ë¹„**            | Readable ëª¨ë“œì—ì„œë„ ì‹ë³„ ê°€ëŠ¥ |

### 6.3 ê¸ˆì§€ ì‚¬í•­

- âŒ í”„ë¡œì íŠ¸ ì™¸ë¶€ ë¡œê³ /ìƒí‘œ ë³µì œ
- âŒ CRT í…Œë§ˆì™€ ì¶©ëŒí•˜ëŠ” ìƒ‰ìƒ (ë°ì€ íŒŒìŠ¤í…”, ë‚œìƒ‰ ê³„ì—´ ë‚¨ìš©)
- âŒ ë³µì¡í•œ ê·¸ë¼ë°ì´ì…˜/ì‚¬ì§„ ìŠ¤íƒ€ì¼

---

## 7. í´ë°± ì›ì¹™ (í•„ìˆ˜)

### 7.1 í…ìŠ¤íŠ¸/ì´ëª¨ì§€ í´ë°± ìœ ì§€

ì—ì…‹ ë¡œë”© ì‹¤íŒ¨/ë¯¸ì§€ì› ì‹œì—ë„ **UIê°€ ê¹¨ì§€ì§€ ì•Šë„ë¡** í…ìŠ¤íŠ¸/ì´ëª¨ì§€ ë¼ë²¨ì„ ìœ ì§€í•´ì•¼ í•©ë‹ˆë‹¤.

**ì˜ˆì‹œ** (React):

```tsx
<span className="icon-wrapper" aria-label="Signal">
  <img
    src="/ui/icons/signal-24.png"
    alt=""
    aria-hidden="true"
    onError={(e) => (e.currentTarget.style.display = 'none')}
  />
  <span className="icon-fallback">ğŸ“¡</span>
</span>
```

**CSS**:

```css
.icon-wrapper {
  display: inline-flex;
  align-items: center;
}
.icon-wrapper img + .icon-fallback {
  display: none;
}
.icon-wrapper img[style*='display: none'] + .icon-fallback {
  display: inline;
}
```

### 7.2 í´ë°± ìš”êµ¬ì‚¬í•­

| ì—ì…‹ ìœ í˜•       | í´ë°± ë°©ì‹                |
| --------------- | ------------------------ |
| **ì•„ì´ì½˜**      | ì´ëª¨ì§€ ë˜ëŠ” í…ìŠ¤íŠ¸ ë¼ë²¨  |
| **placeholder** | CSS ë°°ê²½ìƒ‰ + í…ìŠ¤íŠ¸      |
| **chrome**      | CSS border/shadowë¡œ ëŒ€ì²´ |

---

## 8. ì ‘ê·¼ì„± ê°€ì´ë“œ

### 8.1 í•„ìˆ˜ ì‚¬í•­

| í•­ëª©                          | ìš”êµ¬ì‚¬í•­                            |
| ----------------------------- | ----------------------------------- |
| **ìƒ‰ìƒë§Œìœ¼ë¡œ ì˜ë¯¸ ì „ë‹¬ ê¸ˆì§€** | í…ìŠ¤íŠ¸/ë¼ë²¨ ë³‘í–‰                    |
| **ì¥ì‹ì„± ì´ë¯¸ì§€**             | `aria-hidden="true"` ì ìš©           |
| **ê¸°ëŠ¥ì„± ì´ë¯¸ì§€**             | `alt` í…ìŠ¤íŠ¸ ì œê³µ ë˜ëŠ” `aria-label` |
| **ëŒ€ë¹„**                      | Readable ëª¨ë“œì—ì„œë„ 4.5:1 ì´ìƒ      |

### 8.2 ì˜ˆì‹œ

```html
<!-- ì¥ì‹ìš© ì•„ì´ì½˜ (ì˜ë¯¸ ì—†ìŒ) -->
<img src="/ui/chrome/corner.png" alt="" aria-hidden="true" />

<!-- ê¸°ëŠ¥ìš© ì•„ì´ì½˜ (ì˜ë¯¸ ìˆìŒ) -->
<button aria-label="ì‹ í˜¸ ì „ì†¡">
  <img src="/ui/icons/signal-24.png" alt="Signal" />
</button>
```

---

## 9. ì—ì…‹ ì œì‘ ì›Œí¬í”Œë¡œìš°

### 9.1 ìš”ì²­ â†’ ì œì‘ â†’ ì ìš©

```
1. ìš”ì²­ ì •ì˜
   â””â”€â”€ ìš©ë„, ì‚¬ì´ì¦ˆ, ìŠ¤íƒ€ì¼ ëª…ì„¸ ì‘ì„±

2. nanobanana mcpë¡œ ì œì‘
   â””â”€â”€ í”„ë¡¬í”„íŠ¸ì— CRT ìŠ¤íƒ€ì¼ í‚¤ì›Œë“œ í¬í•¨
   â””â”€â”€ ìƒ‰ìƒ íŒ”ë ˆíŠ¸ ì¤€ìˆ˜
   â””â”€â”€ (í•„ìˆ˜ ì¡°ê±´ë¶€) ë°°ê²½ ì œê±°(rembg) ì˜ˆì •ì´ë©´ **ë°°ê²½ì€ ìˆœë°±(#FFFFFF) ë‹¨ìƒ‰**ìœ¼ë¡œ ìƒì„±(ê·¸ë¼ë°ì´ì…˜/í…ìŠ¤ì²˜/ê·¸ë¦¼ì ê¸ˆì§€)

3. (í•„ìˆ˜ ì¡°ê±´ë¶€) rembgë¡œ ë°°ê²½ ì œê±°
   â””â”€â”€ ì•„ì´ì½˜/chrome ë“± íˆ¬ëª… ë°°ê²½ì´ í•„ìš”í•œ ì—ì…‹ì—ì„œ ë°°ê²½ì´ ë‚¨ì•„ ìˆìœ¼ë©´ rembgë¡œ ì œê±°
   â””â”€â”€ ëª¨ë¸ ì„ íƒ/ì˜µì…˜ì€ `vibe/ref/rembg-guide.md` ì¤€ìˆ˜

4. ë¦¬ì‚¬ì´ì¦ˆ/ì••ì¶•
   â””â”€â”€ ì„±ëŠ¥ ì˜ˆì‚° í™•ì¸
   â””â”€â”€ í•„ìš” ì‚¬ì´ì¦ˆë¡œ ë¦¬ì‚¬ì´ì¦ˆ

5. ë””ë ‰í† ë¦¬ ë°˜ì˜
   â””â”€â”€ ë„¤ì´ë° ê·œì¹™ ì¤€ìˆ˜
   â””â”€â”€ manifest.json ì—…ë°ì´íŠ¸

6. UI ì ìš© + í´ë°± í™•ì¸
   â””â”€â”€ ì»´í¬ë„ŒíŠ¸ì— ì ìš©
   â””â”€â”€ í´ë°± ë™ì‘ í…ŒìŠ¤íŠ¸

7. QA
   â””â”€â”€ í¬ê¸°/ëŒ€ë¹„/í´ë°±/Readable ëª¨ë“œ í™•ì¸
```

### 9.2 í”„ë¡¬í”„íŠ¸ ê°€ì´ë“œ (ì˜ˆì‹œ)

```
CRT í„°ë¯¸ë„ ìŠ¤íƒ€ì¼ ì•„ì´ì½˜,
ì¸ê´‘ ë…¹ìƒ‰(#33ff00) ê¸°ë°˜,
ê²€ì€ ë°°ê²½(#0d0d0d)ì— ì–´ìš¸ë¦¬ëŠ” í†¤,
ì‹¬í”Œí•œ ë¼ì¸ ì•„íŠ¸,
í”½ì…€ ì•„íŠ¸ ë˜ëŠ” ë ˆíŠ¸ë¡œ ìŠ¤íƒ€ì¼,
24x24 í”½ì…€, íˆ¬ëª… ë°°ê²½
(ë°°ê²½ ì œê±° í•„ìš” ì‹œ) solid white background (#FFFFFF), no gradient/texture/shadow
```

---

## 10. ë§¤ë‹ˆí˜ìŠ¤íŠ¸ ê´€ë¦¬

### 10.1 manifest.json

ëª¨ë“  ì—ì…‹ì€ `manifest.json`ì— ë“±ë¡í•˜ì—¬ ì¶”ì í•©ë‹ˆë‹¤.

```json
{
  "$schema": "./manifest.schema.json",
  "version": "1.0.0",
  "assets": [
    {
      "id": "signal-24",
      "path": "icons/signal-24.png",
      "type": "icon",
      "size": 24,
      "fallback": "ğŸ“¡",
      "usedIn": ["EconomyHUD"],
      "bytes": 1234
    }
  ]
}
```

### 10.2 ì—…ë°ì´íŠ¸ ì‹œì 

- ì—ì…‹ ì¶”ê°€/ì œê±° ì‹œ manifest.json ë™ê¸°í™”
- U-033ì—ì„œ QA ìë™í™” ì˜ˆì •

---

## 11. ë¼ì´ì„ ìŠ¤

- ëª¨ë“  ì—ì…‹ì€ **í”„ë¡œì íŠ¸ ë‚´ë¶€ ìš©ë„**ë¡œ ì œì‘ë©ë‹ˆë‹¤.
- ì™¸ë¶€ ë¡œê³ /ìƒí‘œë¥¼ ë³µì œí•˜ì§€ ì•ŠìŠµë‹ˆë‹¤.
- `nanobanana mcp`ë¡œ ìƒì„±ëœ ì—ì…‹ì€ ë„êµ¬ì˜ ë¼ì´ì„ ìŠ¤ ì •ì±…ì„ ë”°ë¦…ë‹ˆë‹¤.
- ì—ì…‹ì— **SynthID ì›Œí„°ë§ˆí¬**ê°€ í¬í•¨ë  ìˆ˜ ìˆìŠµë‹ˆë‹¤ (AI ìƒì„± í‘œê¸°).

---

## 12. ì²´í¬ë¦¬ìŠ¤íŠ¸ (ì—ì…‹ ì¶”ê°€ ì‹œ)

- [ ] ë„¤ì´ë° ê·œì¹™ ì¤€ìˆ˜ (`kebab-case` + ìš©ë„ + í¬ê¸°)
- [ ] í¬ë§· ê·œì¹™ ì¤€ìˆ˜ (ì•„ì´ì½˜=PNG, placeholder=WebP)
- [ ] ì„±ëŠ¥ ì˜ˆì‚° ì¤€ìˆ˜ (ê°œë³„/ì´í•©)
- [ ] (ì¡°ê±´ë¶€) íˆ¬ëª… ë°°ê²½ì´ í•„ìš”í•œ ì—ì…‹ì€ `rembg`ë¡œ ë°°ê²½ ì œê±° ì™„ë£Œ(ì•ŒíŒŒ ì±„ë„ í™•ì¸)
- [ ] (ì¡°ê±´ë¶€) ë°°ê²½ ì œê±°(rembg) ì˜ˆì •ì´ë©´ ì›ë³¸ ìƒì„± ë‹¨ê³„ì—ì„œ ë°°ê²½ì´ ìˆœë°±(#FFFFFF) ë‹¨ìƒ‰ì¸ì§€ í™•ì¸(ê·¸ë¼ë°ì´ì…˜/í…ìŠ¤ì²˜/ê·¸ë¦¼ì ê¸ˆì§€)
- [ ] CRT í…Œë§ˆ ìƒ‰ìƒê³¼ ì¡°í™”
- [ ] í´ë°± êµ¬í˜„ í™•ì¸
- [ ] ì ‘ê·¼ì„± ì†ì„± ì ìš© (`aria-hidden` ë˜ëŠ” `alt`)
- [ ] manifest.json ì—…ë°ì´íŠ¸
- [ ] Readable ëª¨ë“œì—ì„œ ëŒ€ë¹„ í™•ì¸

---

_ë§ˆì§€ë§‰ ì—…ë°ì´íŠ¸: 2026-01-11_
_ë¬¸ì„œ ë²„ì „: 1.1.0_
</file>

<file path="frontend/src/api/turnStream.test.ts">
import { describe, it, expect, vi, beforeEach } from 'vitest';
import { NDJSONParser } from './turnStream';

describe('NDJSONParser', () => {
  let parser: NDJSONParser;

  beforeEach(() => {
    parser = new NDJSONParser();
  });

  it('should parse a single complete line', () => {
    const chunk = JSON.stringify({ type: 'test', value: 1 }) + '\n';
    const results = parser.parse(chunk);
    expect(results).toHaveLength(1);
    expect(results[0]).toEqual({ type: 'test', value: 1 });
  });

  it('should parse multiple complete lines in one chunk', () => {
    const chunk = JSON.stringify({ id: 1 }) + '\n' + JSON.stringify({ id: 2 }) + '\n';
    const results = parser.parse(chunk);
    expect(results).toHaveLength(2);
    expect(results[0]).toEqual({ id: 1 });
    expect(results[1]).toEqual({ id: 2 });
  });

  it('should buffer partial lines and parse them when completed', () => {
    const chunk1 = '{"id": 1';
    const chunk2 = ', "val": "ok"}\n';

    const results1 = parser.parse(chunk1);
    expect(results1).toHaveLength(0);

    const results2 = parser.parse(chunk2);
    expect(results2).toHaveLength(1);
    expect(results2[0]).toEqual({ id: 1, val: 'ok' });
  });

  it('should ignore empty lines', () => {
    const chunk = '\n\n{"a":1}\n\n';
    const results = parser.parse(chunk);
    expect(results).toHaveLength(1);
  });

  it('should not crash on invalid JSON and continue', () => {
    const consoleSpy = vi.spyOn(console, 'warn').mockImplementation(() => {});
    const chunk = 'invalid json\n{"valid": true}\n';
    const results = parser.parse(chunk);

    expect(results).toHaveLength(1);
    expect(results[0]).toEqual({ valid: true });
    expect(consoleSpy).toHaveBeenCalled();
    consoleSpy.mockRestore();
  });

  it('should flush remaining buffer', () => {
    parser.parse('{"id": 1}'); // No newline
    const result = parser.flush();
    expect(result).toEqual({ id: 1 });
  });

  it('should return null on flush with empty buffer', () => {
    const result = parser.flush();
    expect(result).toBeNull();
  });
});

describe('executeTurnStream', () => {
  const mockInput = {
    language: 'ko-KR' as const,
    text: 'Hello',
    action_id: null,
    click: null,
    drop: null, // U-012: ë“œë¡­ ì…ë ¥ í•„ë“œ ì¶”ê°€
    client: { viewport_w: 100, viewport_h: 100, theme: 'dark' as const },
    economy_snapshot: { signal: 100, memory_shard: 0 },
  };

  const mockCallbacks = {
    onStage: vi.fn(),
    onRepair: vi.fn(),
    onBadges: vi.fn(),
    onNarrativeDelta: vi.fn(),
    onFinal: vi.fn(),
    onError: vi.fn(),
    onComplete: vi.fn(),
  };

  beforeEach(() => {
    vi.clearAllMocks();
    global.fetch = vi.fn();
  });

  it('should process stream events correctly (including repair)', async () => {
    const encoder = new TextEncoder();
    const stream = new ReadableStream({
      start(controller) {
        controller.enqueue(
          encoder.encode(JSON.stringify({ type: 'stage', name: 'parse', status: 'start' }) + '\n'),
        );
        controller.enqueue(
          encoder.encode(
            JSON.stringify({ type: 'repair', attempt: 1, message: 'Schema fail, retrying' }) + '\n',
          ),
        );
        controller.enqueue(
          encoder.encode(JSON.stringify({ type: 'narrative_delta', text: 'Hello' }) + '\n'),
        );
        controller.enqueue(
          encoder.encode(
            JSON.stringify({
              type: 'final',
              data: {
                language: 'ko-KR',
                narrative: 'Hello',
                economy: {
                  cost: { signal: 0, memory_shard: 0 },
                  balance_after: { signal: 100, memory_shard: 0 },
                },
                safety: { blocked: false },
              },
            }) + '\n',
          ),
        );
        controller.close();
      },
    });

    (global.fetch as unknown as ReturnType<typeof vi.fn>).mockResolvedValue({
      ok: true,
      body: stream,
    });

    const { executeTurnStream } = await import('./turnStream');
    await executeTurnStream(mockInput, mockCallbacks);

    expect(mockCallbacks.onStage).toHaveBeenCalledWith(expect.objectContaining({ name: 'parse' }));
    expect(mockCallbacks.onRepair).toHaveBeenCalledWith(
      expect.objectContaining({ attempt: 1, message: 'Schema fail, retrying' }),
    );
    expect(mockCallbacks.onNarrativeDelta).toHaveBeenCalledWith(
      expect.objectContaining({ text: 'Hello' }),
    );
    expect(mockCallbacks.onFinal).toHaveBeenCalled();
    expect(mockCallbacks.onComplete).toHaveBeenCalled();
  });

  it('should handle HTTP errors', async () => {
    (global.fetch as unknown as ReturnType<typeof vi.fn>).mockResolvedValue({
      ok: false,
      status: 500,
      statusText: 'Internal Server Error',
    });

    const { executeTurnStream } = await import('./turnStream');
    await executeTurnStream(mockInput, mockCallbacks);

    expect(mockCallbacks.onError).toHaveBeenCalledWith(
      expect.objectContaining({
        code: 'STREAM_ERROR',
        message: expect.stringContaining('500'),
      }),
    );
  });

  it('should handle fetch rejection', async () => {
    (global.fetch as unknown as ReturnType<typeof vi.fn>).mockRejectedValue(
      new Error('Network failure'),
    );

    const { executeTurnStream } = await import('./turnStream');
    await executeTurnStream(mockInput, mockCallbacks);

    expect(mockCallbacks.onError).toHaveBeenCalledWith(
      expect.objectContaining({
        message: 'Network failure',
      }),
    );
  });
});
</file>

<file path="frontend/src/save/saveGame.ts">
/**
 * Unknown World - SaveGame ì €ì¥/ë³µì› ëª¨ë“ˆ (U-015[Mvp]).
 *
 * ë¡œê·¸ì¸ ì—†ì´ ì¦‰ì‹œ ì‹œì‘ ê°€ëŠ¥í•œ ë°ëª¨ í”„ë¡œí•„ê³¼ ì„¸ì´ë¸Œ/ë¡œë“œ ê¸°ëŠ¥ì„ ì œê³µí•©ë‹ˆë‹¤.
 * DB ì—†ì´ SaveGame JSON ì§ë ¬í™” ê¸°ë°˜ìœ¼ë¡œ localStorageì— ì €ì¥í•©ë‹ˆë‹¤.
 *
 * ì„¤ê³„ ì›ì¹™:
 *   - RULE-010: DB/ORM ë„ì… ê¸ˆì§€ (SaveGame JSON ì§ë ¬í™” ê¸°ë°˜)
 *   - RULE-006: language í•„ë“œë¡œ ko/en í˜¼í•© ë°©ì§€
 *   - Q1 ê²°ì •: Option A - localStorage ì‚¬ìš© (ë‹¨ìˆœ/ë°ëª¨ ì í•©)
 *   - RU-004-Q5: ìƒìˆ˜ëŠ” constants.tsì—ì„œ ì¤‘ì•™ ê´€ë¦¬
 *
 * @module save/saveGame
 */

import { z } from 'zod';
import type { SupportedLanguage } from '../i18n';
import type { LedgerEntry } from '../stores/economyStore';
import type { Quest, WorldRule } from '../schemas/turn';
import type { InventoryItem } from '../stores/inventoryStore';
import type { MutationEvent, NarrativeEntry, EconomyState } from '../stores/worldStore';
import type { SceneObject } from '../schemas/turn';

// RU-004-Q5: ìƒìˆ˜ ì¤‘ì•™í™” - constants.tsì—ì„œ import
import { SAVEGAME_VERSION, SAVEGAME_STORAGE_KEY, CURRENT_PROFILE_KEY } from './constants';

// RU-004-Q5: ìƒìˆ˜ re-export (ê¸°ì¡´ í˜¸ì¶œì í˜¸í™˜ì„± ìœ ì§€)
export { SAVEGAME_VERSION, SAVEGAME_STORAGE_KEY, CURRENT_PROFILE_KEY };

// =============================================================================
// SaveGame ìŠ¤í‚¤ë§ˆ ì •ì˜
// =============================================================================

/**
 * SaveGame Zod ìŠ¤í‚¤ë§ˆ.
 * ìµœì†Œ í•„ë“œë§Œ í¬í•¨í•˜ì—¬ MVP ìš”êµ¬ì‚¬í•­ì„ ì¶©ì¡±í•©ë‹ˆë‹¤.
 */
export const SaveGameSchema = z
  .object({
    /** ìŠ¤í‚¤ë§ˆ ë²„ì „ (ë§ˆì´ê·¸ë ˆì´ì…˜ìš©) */
    version: z.string().describe('SaveGame ìŠ¤í‚¤ë§ˆ ë²„ì „'),
    /** ì„¸ì…˜ ì‹œë“œ (ë¦¬í”Œë ˆì´ ì¬í˜„ìš©, ì„ íƒ) */
    seed: z.string().nullable().default(null).describe('ì„¸ì…˜ ì‹œë“œ'),
    /** ì–¸ì–´ ì„¤ì • (RULE-006: ë³µì› ì‹œ UI i18nì—ë„ ì ìš©) */
    language: z.enum(['ko-KR', 'en-US']).describe('ì–¸ì–´ ì„¤ì •'),
    /** ì‚¬ìš©ëœ ë°ëª¨ í”„ë¡œí•„ ID */
    profileId: z.string().nullable().default(null).describe('ë°ëª¨ í”„ë¡œí•„ ID'),
    /** ì €ì¥ ì‹œê° (ISO 8601) */
    savedAt: z.string().describe('ì €ì¥ ì‹œê°'),

    /** ì¬í™” ìƒíƒœ */
    economy: z
      .object({
        signal: z.number().int().min(0),
        memory_shard: z.number().int().min(0),
      })
      .describe('ì¬í™” ìƒíƒœ'),

    /** ê²½ì œ ì›ì¥ ì´ë ¥ */
    economyLedger: z
      .array(
        z.object({
          turnId: z.number().int(),
          actionId: z.string().optional(),
          reason: z.string(),
          cost: z.object({
            signal: z.number().int().min(0),
            memory_shard: z.number().int().min(0),
          }),
          balanceAfter: z.object({
            signal: z.number().int().min(0),
            memory_shard: z.number().int().min(0),
          }),
          modelLabel: z.enum(['FAST', 'QUALITY', 'CHEAP', 'REF']).optional(),
          timestamp: z.number(),
        }),
      )
      .default([])
      .describe('ê²½ì œ ì›ì¥ ì´ë ¥'),

    /** í˜„ì¬ í„´ ì¹´ìš´íŠ¸ */
    turnCount: z.number().int().min(0).default(0).describe('í˜„ì¬ í„´ ì¹´ìš´íŠ¸'),

    /** ë‚´ëŸ¬í‹°ë¸Œ íˆìŠ¤í† ë¦¬ */
    narrativeHistory: z
      .array(
        z.object({
          turn: z.number().int(),
          text: z.string(),
        }),
      )
      .default([])
      .describe('ë‚´ëŸ¬í‹°ë¸Œ íˆìŠ¤í† ë¦¬'),

    /** ì¸ë²¤í† ë¦¬ ì•„ì´í…œ */
    inventory: z
      .array(
        z.object({
          id: z.string(),
          name: z.string(),
          description: z.string().optional(),
          icon: z.string().optional(),
          quantity: z.number().int().min(1),
        }),
      )
      .default([])
      .describe('ì¸ë²¤í† ë¦¬ ì•„ì´í…œ'),

    /** í™œì„± í€˜ìŠ¤íŠ¸ */
    quests: z
      .array(
        z.object({
          id: z.string(),
          label: z.string(),
          is_completed: z.boolean().default(false),
        }),
      )
      .default([])
      .describe('í™œì„± í€˜ìŠ¤íŠ¸'),

    /** í™œì„± ê·œì¹™ */
    activeRules: z
      .array(
        z.object({
          id: z.string(),
          label: z.string(),
          description: z.string().nullable().default(null),
        }),
      )
      .default([])
      .describe('í™œì„± ê·œì¹™'),

    /** ë£° ë³€í˜• íƒ€ì„ë¼ì¸ */
    mutationTimeline: z
      .array(
        z.object({
          turn: z.number().int(),
          ruleId: z.string(),
          type: z.enum(['added', 'modified', 'removed']),
          label: z.string(),
          description: z.string().optional(),
          timestamp: z.number(),
        }),
      )
      .default([])
      .describe('ë£° ë³€í˜• íƒ€ì„ë¼ì¸'),

    /** Scene Objects (í•«ìŠ¤íŒŸ) */
    sceneObjects: z
      .array(
        z.object({
          id: z.string(),
          label: z.string(),
          box_2d: z.object({
            ymin: z.number().int().min(0).max(1000),
            xmin: z.number().int().min(0).max(1000),
            ymax: z.number().int().min(0).max(1000),
            xmax: z.number().int().min(0).max(1000),
          }),
          interaction_hint: z.string().nullable().default(null),
        }),
      )
      .default([])
      .describe('Scene Objects'),
  })
  .strict();

export type SaveGame = z.infer<typeof SaveGameSchema>;

// =============================================================================
// ì €ì¥/ë³µì› í•¨ìˆ˜
// =============================================================================

/**
 * SaveGame ì¸í„°í˜ì´ìŠ¤ (ì €ì¥í•  ìƒíƒœ ì „ì²´ë¥¼ ìº¡ì²˜).
 */
export interface SaveGameInput {
  language: SupportedLanguage;
  profileId?: string | null;
  seed?: string | null;
  economy: EconomyState;
  economyLedger: LedgerEntry[];
  turnCount: number;
  narrativeHistory: NarrativeEntry[];
  inventory: InventoryItem[];
  quests: Quest[];
  activeRules: WorldRule[];
  mutationTimeline: MutationEvent[];
  sceneObjects: SceneObject[];
}

/**
 * í˜„ì¬ ìƒíƒœë¥¼ SaveGame ê°ì²´ë¡œ ì§ë ¬í™”í•©ë‹ˆë‹¤.
 */
export function createSaveGame(input: SaveGameInput): SaveGame {
  return {
    version: SAVEGAME_VERSION,
    seed: input.seed ?? null,
    language: input.language,
    profileId: input.profileId ?? null,
    savedAt: new Date().toISOString(),
    economy: {
      signal: input.economy.signal,
      memory_shard: input.economy.memory_shard,
    },
    economyLedger: input.economyLedger.map((entry) => ({
      turnId: entry.turnId,
      actionId: entry.actionId,
      reason: entry.reason,
      cost: {
        signal: entry.cost.signal,
        memory_shard: entry.cost.memory_shard,
      },
      balanceAfter: {
        signal: entry.balanceAfter.signal,
        memory_shard: entry.balanceAfter.memory_shard,
      },
      modelLabel: entry.modelLabel,
      timestamp: entry.timestamp,
    })),
    turnCount: input.turnCount,
    narrativeHistory: input.narrativeHistory.map((entry) => ({
      turn: entry.turn,
      text: entry.text,
    })),
    inventory: input.inventory.map((item) => ({
      id: item.id,
      name: item.name,
      description: item.description,
      icon: item.icon,
      quantity: item.quantity,
    })),
    quests: input.quests.map((quest) => ({
      id: quest.id,
      label: quest.label,
      is_completed: quest.is_completed,
    })),
    activeRules: input.activeRules.map((rule) => ({
      id: rule.id,
      label: rule.label,
      description: rule.description,
    })),
    mutationTimeline: input.mutationTimeline.map((event) => ({
      turn: event.turn,
      ruleId: event.ruleId,
      type: event.type,
      label: event.label,
      description: event.description,
      timestamp: event.timestamp,
    })),
    sceneObjects: input.sceneObjects.map((obj) => ({
      id: obj.id,
      label: obj.label,
      box_2d: {
        ymin: obj.box_2d.ymin,
        xmin: obj.box_2d.xmin,
        ymax: obj.box_2d.ymax,
        xmax: obj.box_2d.xmax,
      },
      interaction_hint: obj.interaction_hint,
    })),
  };
}

/**
 * SaveGameì„ localStorageì— ì €ì¥í•©ë‹ˆë‹¤.
 *
 * @returns ì €ì¥ ì„±ê³µ ì—¬ë¶€
 */
export function saveSaveGame(saveGame: SaveGame): boolean {
  try {
    const json = JSON.stringify(saveGame);
    localStorage.setItem(SAVEGAME_STORAGE_KEY, json);
    return true;
  } catch (error) {
    console.error('[SaveGame] ì €ì¥ ì‹¤íŒ¨:', error);
    return false;
  }
}

/**
 * localStorageì—ì„œ SaveGameì„ ë¡œë“œí•©ë‹ˆë‹¤.
 * ë§ˆì´ê·¸ë ˆì´ì…˜ì´ í•„ìš”í•œ ê²½ìš° ìë™ìœ¼ë¡œ ì ìš©í•©ë‹ˆë‹¤ (RU-004-S2).
 *
 * @returns SaveGame ê°ì²´ ë˜ëŠ” null (ì—†ê±°ë‚˜ ìœ íš¨í•˜ì§€ ì•Šì€ ê²½ìš°)
 */
export function loadSaveGame(): SaveGame | null {
  try {
    const json = localStorage.getItem(SAVEGAME_STORAGE_KEY);
    if (!json) {
      return null;
    }

    const parsed = JSON.parse(json);
    const result = SaveGameSchema.safeParse(parsed);

    if (!result.success) {
      console.warn('[SaveGame] ìŠ¤í‚¤ë§ˆ ê²€ì¦ ì‹¤íŒ¨:', result.error);
      return null;
    }

    // RU-004-S2: ë²„ì „ ë§ˆì´ê·¸ë ˆì´ì…˜ ì ìš©
    const migrated = migrateSaveGame(result.data);
    if (!migrated) {
      console.warn('[SaveGame] ë§ˆì´ê·¸ë ˆì´ì…˜ ì‹¤íŒ¨, ìƒˆë¡œ ì‹œì‘ í•„ìš”');
      return null;
    }

    return migrated;
  } catch (error) {
    console.error('[SaveGame] ë¡œë“œ ì‹¤íŒ¨:', error);
    return null;
  }
}

/**
 * ì €ì¥ëœ SaveGameì„ ì‚­ì œí•©ë‹ˆë‹¤.
 */
export function clearSaveGame(): void {
  try {
    localStorage.removeItem(SAVEGAME_STORAGE_KEY);
  } catch (error) {
    console.error('[SaveGame] ì‚­ì œ ì‹¤íŒ¨:', error);
  }
}

/**
 * SaveGameì´ ì¡´ì¬í•˜ëŠ”ì§€ í™•ì¸í•©ë‹ˆë‹¤.
 *
 * @deprecated RU-004-S2: ì´ í•¨ìˆ˜ëŠ” í‚¤ ì¡´ì¬ë§Œ í™•ì¸í•˜ë¯€ë¡œ "ìœ íš¨í•œ ì„¸ì´ë¸Œ" íŒë‹¨ì— ë¶€ì í•©í•©ë‹ˆë‹¤.
 *             ëŒ€ì‹  `getValidSaveGameOrNull()`ì„ ì‚¬ìš©í•˜ì„¸ìš”.
 */
export function hasSaveGame(): boolean {
  try {
    return localStorage.getItem(SAVEGAME_STORAGE_KEY) !== null;
  } catch {
    return false;
  }
}

/**
 * ìœ íš¨í•œ SaveGameì„ ë°˜í™˜í•©ë‹ˆë‹¤. ì—†ê±°ë‚˜ ê²€ì¦/ë§ˆì´ê·¸ë ˆì´ì…˜ ì‹¤íŒ¨ ì‹œ nullì„ ë°˜í™˜í•©ë‹ˆë‹¤ (RU-004-S2).
 *
 * `hasSaveGame()` ëŒ€ì‹  ì´ í•¨ìˆ˜ë¥¼ ì‚¬ìš©í•˜ë©´ "Continue ë²„íŠ¼ ë…¸ì¶œ" íŒë‹¨ì´ ì •í™•í•´ì§‘ë‹ˆë‹¤:
 * - localStorageì— ë°ì´í„°ê°€ ìˆì–´ë„ ìŠ¤í‚¤ë§ˆ ê²€ì¦ ì‹¤íŒ¨ ì‹œ null ë°˜í™˜
 * - ë²„ì „ ë¶ˆì¼ì¹˜ë¡œ ë§ˆì´ê·¸ë ˆì´ì…˜ ì‹¤íŒ¨ ì‹œ null ë°˜í™˜
 *
 * @returns ìœ íš¨í•œ SaveGame ë˜ëŠ” null
 */
export function getValidSaveGameOrNull(): SaveGame | null {
  return loadSaveGame();
}

// =============================================================================
// í”„ë¡œí•„ ê´€ë ¨ ìœ í‹¸ë¦¬í‹°
// =============================================================================

/**
 * í˜„ì¬ ì„ íƒëœ í”„ë¡œí•„ IDë¥¼ ì €ì¥í•©ë‹ˆë‹¤.
 */
export function saveCurrentProfileId(profileId: string): void {
  try {
    localStorage.setItem(CURRENT_PROFILE_KEY, profileId);
  } catch (error) {
    console.error('[SaveGame] í”„ë¡œí•„ ID ì €ì¥ ì‹¤íŒ¨:', error);
  }
}

/**
 * í˜„ì¬ ì„ íƒëœ í”„ë¡œí•„ IDë¥¼ ë¡œë“œí•©ë‹ˆë‹¤.
 */
export function loadCurrentProfileId(): string | null {
  try {
    return localStorage.getItem(CURRENT_PROFILE_KEY);
  } catch {
    return null;
  }
}

/**
 * í˜„ì¬ ì„ íƒëœ í”„ë¡œí•„ IDë¥¼ ì‚­ì œí•©ë‹ˆë‹¤.
 */
export function clearCurrentProfileId(): void {
  try {
    localStorage.removeItem(CURRENT_PROFILE_KEY);
  } catch (error) {
    console.error('[SaveGame] í”„ë¡œí•„ ID ì‚­ì œ ì‹¤íŒ¨:', error);
  }
}

// =============================================================================
// ë²„ì „ ë§ˆì´ê·¸ë ˆì´ì…˜ (í–¥í›„ í™•ì¥)
// =============================================================================

/**
 * SaveGame ë²„ì „ì„ í™•ì¸í•˜ê³  í•„ìš” ì‹œ ë§ˆì´ê·¸ë ˆì´ì…˜í•©ë‹ˆë‹¤.
 * í˜„ì¬ëŠ” v1.0.0ë§Œ ì§€ì›í•˜ë¯€ë¡œ íŒ¨ìŠ¤ìŠ¤ë£¨ì…ë‹ˆë‹¤.
 *
 * @param saveGame - ë¡œë“œëœ SaveGame
 * @returns ë§ˆì´ê·¸ë ˆì´ì…˜ëœ SaveGame ë˜ëŠ” null (ë§ˆì´ê·¸ë ˆì´ì…˜ ë¶ˆê°€)
 */
export function migrateSaveGame(saveGame: SaveGame): SaveGame | null {
  // í˜„ì¬ ë²„ì „ì´ë©´ ê·¸ëŒ€ë¡œ ë°˜í™˜
  if (saveGame.version === SAVEGAME_VERSION) {
    return saveGame;
  }

  // í–¥í›„ ë²„ì „ ì—…ê·¸ë ˆì´ë“œ ì‹œ ë§ˆì´ê·¸ë ˆì´ì…˜ ë¡œì§ ì¶”ê°€
  console.warn(`[SaveGame] ë²„ì „ ë¶ˆì¼ì¹˜: ${saveGame.version} -> ${SAVEGAME_VERSION}`);

  // MVPì—ì„œëŠ” ë²„ì „ ë¶ˆì¼ì¹˜ ì‹œ null ë°˜í™˜ (ìƒˆë¡œ ì‹œì‘ ìœ ë„)
  return null;
}
</file>

<file path="frontend/src/stores/economyStore.ts">
/**
 * Unknown World - Economy ìƒíƒœ ê´€ë¦¬ (Zustand) (U-014[Mvp]).
 *
 * Signal/Memory Shard ì¬í™” HUDì™€ í„´ë³„ ë¹„ìš©/ì”ì•¡ ë³€í™”ë¥¼
 * **ì›ì¥(ledger)**ìœ¼ë¡œ ì¶”ì í•˜ì—¬ "ë¹„ìš©/ì§€ì—°ì„ ê²Œì„ ë©”ì»¤ë‹‰"ìœ¼ë¡œ UXì— ë°˜ì˜í•©ë‹ˆë‹¤.
 *
 * ì„¤ê³„ ì›ì¹™:
 *   - RULE-005: Economy ì¸ë°”ë¦¬ì–¸íŠ¸ (ì”ì•¡ ìŒìˆ˜ ê¸ˆì§€, ì˜ˆìƒ ë¹„ìš© ì‚¬ì „ í‘œì‹œ)
 *   - RULE-008: ë¹„ìš©/ëª¨ë¸ ì„ íƒ ì´ìœ ëŠ” ë¼ë²¨(FAST/QUALITY/REF)ë¡œë§Œ ì„¤ëª…
 *   - Q1 ê²°ì •: Option A - ìµœê·¼ Ní„´ë§Œ ë³´ê´€ (UI/ë©”ëª¨ë¦¬ ì ˆê°)
 *   - RU-004-Q5: ìƒìˆ˜ëŠ” save/constants.tsì—ì„œ ì¤‘ì•™ ê´€ë¦¬
 *
 * @module stores/economyStore
 */

import { create } from 'zustand';
import type { CurrencyAmount, ModelLabel, CostEstimate } from '../schemas/turn';
// RU-004-Q5: ìƒìˆ˜ ì¤‘ì•™í™” - constants.tsì—ì„œ import
import { LEDGER_MAX_ENTRIES, LOW_BALANCE_THRESHOLD } from '../save/constants';

// RU-004-Q5: ìƒìˆ˜ re-export (ê¸°ì¡´ í˜¸ì¶œì í˜¸í™˜ì„± ìœ ì§€)
export { LEDGER_MAX_ENTRIES };

// =============================================================================
// íƒ€ì… ì •ì˜
// =============================================================================

/**
 * ì›ì¥(Ledger) ì—”íŠ¸ë¦¬.
 * ê° í„´ì—ì„œ ë°œìƒí•œ ë¹„ìš©ê³¼ ì”ì•¡ ë³€í™”ë¥¼ ê¸°ë¡í•©ë‹ˆë‹¤.
 */
export interface LedgerEntry {
  /** í„´ ID (í„´ ì¹´ìš´íŠ¸) */
  turnId: number;
  /** ì•¡ì…˜ ID (ì„ íƒëœ ì¹´ë“œ ID, ì„ íƒì‚¬í•­) */
  actionId?: string;
  /** ë¹„ìš© ì‚¬ìœ  (ì˜ˆ: "íƒìƒ‰", "ì´ë¯¸ì§€ ìƒì„±") */
  reason: string;
  /** ì†Œë¹„ëœ ë¹„ìš© */
  cost: CurrencyAmount;
  /** ì†Œë¹„ í›„ ì”ì•¡ */
  balanceAfter: CurrencyAmount;
  /** ëª¨ë¸ ë¼ë²¨ (FAST/QUALITY/CHEAP/REF) */
  modelLabel?: ModelLabel;
  /** ê¸°ë¡ ì‹œê°„ */
  timestamp: number;
}

/**
 * ì˜ˆìƒ ë¹„ìš© ìƒíƒœ.
 * í˜„ì¬ ì„ íƒëœ ì•¡ì…˜ì˜ ì˜ˆìƒ ë¹„ìš©ì„ ì¶”ì í•©ë‹ˆë‹¤.
 */
export interface CostEstimateState {
  /** ìµœì†Œ ì˜ˆìƒ ë¹„ìš© */
  min: CurrencyAmount;
  /** ìµœëŒ€ ì˜ˆìƒ ë¹„ìš© */
  max: CurrencyAmount;
  /** ì˜ˆìƒ ë¹„ìš©ì„ ê³„ì‚°í•œ ì•¡ì…˜ ID */
  actionId?: string;
  /** ì˜ˆìƒ ë¹„ìš© ë¼ë²¨/ì„¤ëª… */
  label?: string;
}

/**
 * ë§ˆì§€ë§‰ í™•ì • ë¹„ìš© ìƒíƒœ.
 * ê°€ì¥ ìµœê·¼ í„´ì—ì„œ í™•ì •ëœ ë¹„ìš© ì •ë³´ì…ë‹ˆë‹¤.
 */
export interface LastCostState {
  /** í™•ì •ëœ ë¹„ìš© */
  cost: CurrencyAmount;
  /** í™•ì • í›„ ì”ì•¡ */
  balanceAfter: CurrencyAmount;
  /** í„´ ID */
  turnId: number;
  /** ëª¨ë¸ ë¼ë²¨ */
  modelLabel?: ModelLabel;
}

/** Economy Store ìƒíƒœ */
export interface EconomyStoreState {
  /** ì›ì¥ (ìµœê·¼ Nê°œ ì—”íŠ¸ë¦¬, ìµœì‹ ìˆœ) */
  ledger: LedgerEntry[];
  /** í˜„ì¬ ì˜ˆìƒ ë¹„ìš© (ì„ íƒí•œ ì•¡ì…˜ ê¸°ë°˜) */
  costEstimate: CostEstimateState | null;
  /** ë§ˆì§€ë§‰ í™•ì • ë¹„ìš© */
  lastCost: LastCostState | null;
  /** ì”ì•¡ ë¶€ì¡± ê²½ê³  ì—¬ë¶€ */
  isBalanceLow: boolean;
  /** ì”ì•¡ ë¶€ì¡± ì„ê³„ê°’ (Signal ê¸°ì¤€) */
  lowBalanceThreshold: number;
}

/** Economy Store ì•¡ì…˜ */
export interface EconomyStoreActions {
  /**
   * í„´ ì™„ë£Œ ì‹œ ì›ì¥ì— ì—”íŠ¸ë¦¬ë¥¼ ì¶”ê°€í•©ë‹ˆë‹¤.
   */
  addLedgerEntry: (entry: Omit<LedgerEntry, 'timestamp'>) => void;

  /**
   * SaveGame ë³µì› ì‹œ ì›ì¥ì„ ê·¸ëŒ€ë¡œ ì£¼ì…í•©ë‹ˆë‹¤ (RU-004-S1).
   *
   * - ledgerëŠ” ì €ì¥ëœ ìˆœì„œ(ìµœì‹ ìˆœ)ë¥¼ ìœ ì§€í•©ë‹ˆë‹¤.
   * - timestampëŠ” ì €ì¥ëœ ê°’ì„ ë³´ì¡´í•©ë‹ˆë‹¤.
   * - lastCostëŠ” ìµœì‹  ì—”íŠ¸ë¦¬(ì²« ì›ì†Œ) ê¸°ì¤€ìœ¼ë¡œ ì„¤ì •í•©ë‹ˆë‹¤.
   * - isBalanceLowëŠ” ì „ë‹¬ëœ currentBalanceë¡œ ì¬ê³„ì‚°í•©ë‹ˆë‹¤.
   *
   * @param ledger - ì €ì¥ëœ ì›ì¥ ë°°ì—´ (ìµœì‹ ìˆœ, timestamp í¬í•¨)
   * @param currentBalance - ë³µì›ëœ ì”ì•¡ (isBalanceLow ê³„ì‚°ìš©)
   */
  hydrateLedger: (ledger: LedgerEntry[], currentBalance: CurrencyAmount) => void;

  /**
   * ì˜ˆìƒ ë¹„ìš©ì„ ì„¤ì •í•©ë‹ˆë‹¤ (ì¹´ë“œ ì„ íƒ/í˜¸ë²„ ì‹œ).
   */
  setCostEstimate: (estimate: CostEstimateState | null) => void;

  /**
   * ì¹´ë“œì˜ ë¹„ìš© ì •ë³´ë¡œ ì˜ˆìƒ ë¹„ìš©ì„ ì„¤ì •í•©ë‹ˆë‹¤.
   */
  setCostEstimateFromCard: (
    cost: CurrencyAmount,
    costEstimate: CostEstimate | null,
    actionId: string,
    label?: string,
  ) => void;

  /**
   * ë§ˆì§€ë§‰ í™•ì • ë¹„ìš©ì„ ì„¤ì •í•©ë‹ˆë‹¤ (TurnOutput ë°˜ì˜ ì‹œ).
   */
  setLastCost: (lastCost: LastCostState) => void;

  /**
   * ì”ì•¡ ë¶€ì¡± ìƒíƒœë¥¼ ì—…ë°ì´íŠ¸í•©ë‹ˆë‹¤.
   */
  updateBalanceLowStatus: (currentBalance: CurrencyAmount) => void;

  /**
   * ì”ì•¡ ë¶€ì¡± ì„ê³„ê°’ì„ ì„¤ì •í•©ë‹ˆë‹¤.
   */
  setLowBalanceThreshold: (threshold: number) => void;

  /**
   * ì›ì¥ì„ ì´ˆê¸°í™”í•©ë‹ˆë‹¤.
   */
  clearLedger: () => void;

  /**
   * ì „ì²´ ìƒíƒœë¥¼ ì´ˆê¸°í™”í•©ë‹ˆë‹¤.
   */
  reset: () => void;
}

export type EconomyStore = EconomyStoreState & EconomyStoreActions;

// =============================================================================
// ì´ˆê¸° ìƒíƒœ
// =============================================================================

function createInitialState(): EconomyStoreState {
  return {
    ledger: [],
    costEstimate: null,
    lastCost: null,
    isBalanceLow: false,
    // RU-004-Q5: ì„ê³„ê°’ ìƒìˆ˜ SSOT (save/constants.ts)
    lowBalanceThreshold: LOW_BALANCE_THRESHOLD,
  };
}

// =============================================================================
// Zustand Store
// =============================================================================

/**
 * Economy ìƒíƒœ ìŠ¤í† ì–´.
 *
 * í„´ë³„ ë¹„ìš©/ì”ì•¡ ë³€í™”ë¥¼ ì›ì¥(ledger)ìœ¼ë¡œ ì¶”ì í•˜ê³ ,
 * ì˜ˆìƒ ë¹„ìš©ê³¼ í™•ì • ë¹„ìš©ì„ UIì— ì œê³µí•©ë‹ˆë‹¤.
 *
 * @example
 * ```tsx
 * // ì˜ˆìƒ ë¹„ìš© ì„¤ì • (ì¹´ë“œ í˜¸ë²„ ì‹œ)
 * const setCostEstimateFromCard = useEconomyStore(s => s.setCostEstimateFromCard);
 * setCostEstimateFromCard(card.cost, card.cost_estimate, card.id, card.label);
 *
 * // í„´ ì™„ë£Œ ì‹œ ì›ì¥ ê¸°ë¡
 * const addLedgerEntry = useEconomyStore(s => s.addLedgerEntry);
 * addLedgerEntry({
 *   turnId: turnCount,
 *   reason: 'explore',
 *   cost: turnOutput.economy.cost,
 *   balanceAfter: turnOutput.economy.balance_after,
 * });
 * ```
 */
export const useEconomyStore = create<EconomyStore>((set, get) => ({
  // ì´ˆê¸° ìƒíƒœ
  ...createInitialState(),

  // ì•¡ì…˜

  addLedgerEntry: (entry) => {
    const timestamp = Date.now();
    const newEntry: LedgerEntry = { ...entry, timestamp };

    set((state) => {
      // ìµœì‹ ìˆœìœ¼ë¡œ ì¶”ê°€í•˜ê³  ìµœëŒ€ ê°œìˆ˜ ìœ ì§€ (Q1: Option A)
      const updatedLedger = [newEntry, ...state.ledger].slice(0, LEDGER_MAX_ENTRIES);

      return {
        ledger: updatedLedger,
        lastCost: {
          cost: entry.cost,
          balanceAfter: entry.balanceAfter,
          turnId: entry.turnId,
          modelLabel: entry.modelLabel,
        },
        // í„´ ì™„ë£Œ í›„ ì˜ˆìƒ ë¹„ìš© ì´ˆê¸°í™”
        costEstimate: null,
      };
    });
  },

  hydrateLedger: (ledger, currentBalance) => {
    const { lowBalanceThreshold } = get();

    // LEDGER_MAX_ENTRIES ì •ì±… ì ìš© (ì €ì¥ëœ ê²ƒì´ ë” ë§ì„ ê²½ìš° ëŒ€ë¹„)
    const hydratedLedger = ledger.slice(0, LEDGER_MAX_ENTRIES);

    // lastCostëŠ” ê°€ì¥ ìµœì‹  ì—”íŠ¸ë¦¬(ì²« ì›ì†Œ) ê¸°ì¤€ìœ¼ë¡œ ì„¤ì •
    const latestEntry = hydratedLedger[0] ?? null;
    const lastCost: LastCostState | null = latestEntry
      ? {
          cost: latestEntry.cost,
          balanceAfter: latestEntry.balanceAfter,
          turnId: latestEntry.turnId,
          modelLabel: latestEntry.modelLabel,
        }
      : null;

    // isBalanceLowëŠ” ë³µì›ëœ ì”ì•¡ ê¸°ì¤€ìœ¼ë¡œ ì¬ê³„ì‚°
    const isBalanceLow = currentBalance.signal < lowBalanceThreshold;

    set({
      ledger: hydratedLedger,
      lastCost,
      isBalanceLow,
      costEstimate: null,
    });
  },

  setCostEstimate: (estimate) => {
    set({ costEstimate: estimate });
  },

  setCostEstimateFromCard: (cost, costEstimate, actionId, label) => {
    if (costEstimate) {
      set({
        costEstimate: {
          min: costEstimate.min,
          max: costEstimate.max,
          actionId,
          label,
        },
      });
    } else {
      // cost_estimateê°€ ì—†ìœ¼ë©´ ê¸°ë³¸ costë¥¼ min/maxë¡œ ì‚¬ìš©
      set({
        costEstimate: {
          min: cost,
          max: cost,
          actionId,
          label,
        },
      });
    }
  },

  setLastCost: (lastCost) => {
    set({ lastCost });
  },

  updateBalanceLowStatus: (currentBalance) => {
    const { lowBalanceThreshold } = get();
    const isLow = currentBalance.signal < lowBalanceThreshold;
    set({ isBalanceLow: isLow });
  },

  setLowBalanceThreshold: (threshold) => {
    set({ lowBalanceThreshold: threshold });
  },

  clearLedger: () => {
    set({ ledger: [], lastCost: null });
  },

  reset: () => {
    set(createInitialState());
  },
}));

// =============================================================================
// ì…€ë ‰í„° (ì„±ëŠ¥ ìµœì í™”ìš©)
// =============================================================================

/** ì›ì¥ ì…€ë ‰í„° */
export const selectLedger = (state: EconomyStore) => state.ledger;

/** ì˜ˆìƒ ë¹„ìš© ì…€ë ‰í„° */
export const selectCostEstimate = (state: EconomyStore) => state.costEstimate;

/** ë§ˆì§€ë§‰ í™•ì • ë¹„ìš© ì…€ë ‰í„° */
export const selectLastCost = (state: EconomyStore) => state.lastCost;

/** ì”ì•¡ ë¶€ì¡± ìƒíƒœ ì…€ë ‰í„° */
export const selectIsBalanceLow = (state: EconomyStore) => state.isBalanceLow;

/** ìµœê·¼ Nê°œ ì›ì¥ ì—”íŠ¸ë¦¬ ì…€ë ‰í„° */
export const selectRecentLedger =
  (count: number) =>
  (state: EconomyStore): LedgerEntry[] =>
    state.ledger.slice(0, count);

/** ì´ ì†Œë¹„ ë¹„ìš© ê³„ì‚° ì…€ë ‰í„° (í˜„ì¬ ì„¸ì…˜) */
export const selectTotalSpent = (state: EconomyStore): CurrencyAmount => {
  return state.ledger.reduce(
    (acc, entry) => ({
      signal: acc.signal + entry.cost.signal,
      memory_shard: acc.memory_shard + entry.cost.memory_shard,
    }),
    { signal: 0, memory_shard: 0 },
  );
};

// =============================================================================
// ìœ í‹¸ë¦¬í‹° í•¨ìˆ˜
// =============================================================================

/**
 * í˜„ì¬ ì”ì•¡ìœ¼ë¡œ ì˜ˆìƒ ë¹„ìš©ì„ ê°ë‹¹í•  ìˆ˜ ìˆëŠ”ì§€ í™•ì¸í•©ë‹ˆë‹¤.
 * RULE-005: ì”ì•¡ ë¶€ì¡± ì‹œ ì‹¤í–‰ ê°•í–‰ì´ ì•„ë‹ˆë¼ ëŒ€ì²´ í–‰ë™ì„ ì œì•ˆ.
 */
export function canAffordCost(
  balance: CurrencyAmount,
  cost: CurrencyAmount,
): { affordable: boolean; shortfall: CurrencyAmount } {
  const signalShortfall = Math.max(0, cost.signal - balance.signal);
  const shardShortfall = Math.max(0, cost.memory_shard - balance.memory_shard);

  return {
    affordable: signalShortfall === 0 && shardShortfall === 0,
    shortfall: { signal: signalShortfall, memory_shard: shardShortfall },
  };
}

/**
 * ì˜ˆìƒ ë¹„ìš©ì˜ ìµœëŒ€ê°’ìœ¼ë¡œ ê°ë‹¹ ê°€ëŠ¥ ì—¬ë¶€ë¥¼ í™•ì¸í•©ë‹ˆë‹¤.
 */
export function canAffordEstimate(
  balance: CurrencyAmount,
  estimate: CostEstimateState,
): { affordable: boolean; shortfall: CurrencyAmount } {
  return canAffordCost(balance, estimate.max);
}
</file>

<file path="frontend/src/types/turn_stream.ts">
/**
 * Unknown World - Turn Stream ì´ë²¤íŠ¸ ê³„ì•½(Contract).
 *
 * NDJSON ìŠ¤íŠ¸ë¦¬ë°ì—ì„œ ì‚¬ìš©ë˜ëŠ” ì´ë²¤íŠ¸ íƒ€ì…, ì¸í„°í˜ì´ìŠ¤ë¥¼ ì •ì˜í•©ë‹ˆë‹¤.
 * ì´ ëª¨ë“ˆì€ ë°±ì—”ë“œì™€ í”„ë¡ íŠ¸ì—”ë“œ ê°„ì˜ ìŠ¤íŠ¸ë¦¼ ì´ë²¤íŠ¸ ê³„ì•½ SSOTì…ë‹ˆë‹¤.
 *
 * ì„¤ê³„ ì›ì¹™:
 *   - RU-002-Q4: ì´ë²¤íŠ¸ ê³„ì•½ì„ transport ê³„ì¸µìœ¼ë¡œ ë¶„ë¦¬
 *   - RU-002-S2: ì´ë²¤íŠ¸ë³„ Zod ê²€ì¦ + Unknown/í™•ì¥ ì´ë²¤íŠ¸ í´ë°±
 *   - RULE-003: êµ¬ì¡°í™” ì¶œë ¥(JSON Schema) ìš°ì„  + ì´ì¤‘ ê²€ì¦
 *   - RULE-008: ë‹¨ê³„/ë°°ì§€ ê°€ì‹œí™”
 *
 * ì°¸ì¡°:
 *   - vibe/unit-plans/U-007[Mvp].md
 *   - vibe/refactors/RU-002-Q4.md
 *   - vibe/refactors/RU-002-S2.md
 *
 * @module types/turn_stream
 */

import { z } from 'zod';
import {
  AgentPhaseSchema,
  ValidationBadgeSchema,
  type TurnOutput,
  type AgentPhase,
  type ValidationBadge,
} from '../schemas/turn';

// =============================================================================
// ìŠ¤íŠ¸ë¦¼ ì´ë²¤íŠ¸ íƒ€ì… ìƒìˆ˜ (ì„œë²„ ê³„ì•½ê³¼ ì¼ì¹˜)
// =============================================================================

/** ìŠ¤íŠ¸ë¦¼ ì´ë²¤íŠ¸ íƒ€ì… ìƒìˆ˜ */
export const StreamEventType = {
  STAGE: 'stage',
  BADGES: 'badges',
  NARRATIVE_DELTA: 'narrative_delta',
  FINAL: 'final',
  ERROR: 'error',
  REPAIR: 'repair',
} as const;

export type StreamEventTypeName = (typeof StreamEventType)[keyof typeof StreamEventType];

/**
 * ë‹¨ê³„ ìƒíƒœ ìƒìˆ˜.
 * RU-002-S2/RU-002-Q2: v1(complete) ë° v2(ok/fail) ë³„ì¹­ ëª¨ë‘ ì§€ì›.
 */
export const StageStatus = {
  START: 'start',
  COMPLETE: 'complete',
  /** ë‹¨ê³„ ì‹¤íŒ¨ */
  FAIL: 'fail',
} as const;

export type StageStatusName = (typeof StageStatus)[keyof typeof StageStatus];

// =============================================================================
// RU-002-S2: ì´ë²¤íŠ¸ë³„ Zod ìŠ¤í‚¤ë§ˆ (ê²½ëŸ‰ ê²€ì¦ + í´ë°±)
// =============================================================================

/**
 * stage.status ìŠ¤í‚¤ë§ˆ.
 * v1(complete) ë° v2(ok/fail) ë³„ì¹­ ëª¨ë‘ í—ˆìš©.
 */
export const StageStatusSchema = z.enum(['start', 'complete', 'ok', 'fail']);

/**
 * StageEvent Zod ìŠ¤í‚¤ë§ˆ.
 * ë‹¨ê³„ ì§„í–‰ ì´ë²¤íŠ¸ ê²€ì¦ìš©.
 */
export const StageEventSchema = z.object({
  type: z.literal(StreamEventType.STAGE),
  name: AgentPhaseSchema,
  status: StageStatusSchema,
});

/**
 * RepairEvent Zod ìŠ¤í‚¤ë§ˆ.
 * ìë™ ë³µêµ¬ ì‹œë„ ì´ë²¤íŠ¸ ê²€ì¦ìš©.
 */
export const RepairEventSchema = z.object({
  type: z.literal(StreamEventType.REPAIR),
  attempt: z.number(),
  message: z.string().optional(),
});

/**
 * BadgesEvent Zod ìŠ¤í‚¤ë§ˆ (v1: ë°°ì—´).
 * v1ì€ badges: string[] í˜•ì‹.
 */
export const BadgesEventSchemaV1 = z.object({
  type: z.literal(StreamEventType.BADGES),
  badges: z.array(ValidationBadgeSchema),
});

/**
 * BadgesEvent Zod ìŠ¤í‚¤ë§ˆ (v2: ê°ì²´/ë§µ).
 * í–¥í›„ v2ëŠ” badges: { [key]: status } í˜•ì‹ì„ ì§€ì›í•  ìˆ˜ ìˆìŒ.
 * í˜„ì¬ëŠ” v1ë§Œ ì‚¬ìš©í•˜ë¯€ë¡œ ì´ ìŠ¤í‚¤ë§ˆëŠ” í™•ì¥ì„±ì„ ìœ„í•´ ì •ì˜.
 */
export const BadgesEventSchemaV2 = z.object({
  type: z.literal(StreamEventType.BADGES),
  badges: z.record(z.string(), z.boolean()),
});

/**
 * BadgesEvent í†µí•© ìŠ¤í‚¤ë§ˆ.
 * v1(ë°°ì—´) ë˜ëŠ” v2(ê°ì²´) ëª¨ë‘ í—ˆìš©.
 */
export const BadgesEventSchema = z.union([BadgesEventSchemaV1, BadgesEventSchemaV2]);

/**
 * NarrativeDeltaEvent Zod ìŠ¤í‚¤ë§ˆ.
 * íƒ€ì íš¨ê³¼ìš© ë‚´ëŸ¬í‹°ë¸Œ ë¸íƒ€ ì´ë²¤íŠ¸ ê²€ì¦ìš©.
 */
export const NarrativeDeltaEventSchema = z.object({
  type: z.literal(StreamEventType.NARRATIVE_DELTA),
  text: z.string(),
});

/**
 * FinalEvent ì›ì‹œ ìŠ¤í‚¤ë§ˆ.
 * v1(data) ë° v2(turn_output) ë³„ì¹­ ëª¨ë‘ í—ˆìš©.
 * TurnOutput ìì²´ ê²€ì¦ì€ turnStream.tsì—ì„œ safeParseTurnOutputìœ¼ë¡œ ìˆ˜í–‰.
 */
export const FinalEventRawSchema = z.object({
  type: z.literal(StreamEventType.FINAL),
  data: z.unknown(),
});

/**
 * ErrorEvent Zod ìŠ¤í‚¤ë§ˆ.
 * ì—ëŸ¬ ì´ë²¤íŠ¸ ê²€ì¦ìš©.
 */
export const ErrorEventSchema = z.object({
  type: z.literal(StreamEventType.ERROR),
  message: z.string(),
  code: z.string().optional(),
});

/**
 * ì´ë²¤íŠ¸ íƒ€ì… ì¶”ì¶œìš© ìµœì†Œ ìŠ¤í‚¤ë§ˆ.
 * Unknown ì´ë²¤íŠ¸ íŒë³„ì— ì‚¬ìš©.
 */
export const BaseEventSchema = z.object({
  type: z.string(),
});

// =============================================================================
// ì´ë²¤íŠ¸ íŒŒì‹± ìœ í‹¸ë¦¬í‹° (RU-002-S2)
// =============================================================================

/** ì´ë²¤íŠ¸ ê²€ì¦ ê²°ê³¼ íƒ€ì… */
export type EventParseResult<T> =
  | { success: true; data: T }
  | { success: false; error: z.ZodError };

/**
 * StageEventë¥¼ ì•ˆì „í•˜ê²Œ íŒŒì‹±í•©ë‹ˆë‹¤.
 */
export function safeParseStageEvent(
  data: unknown,
): EventParseResult<z.infer<typeof StageEventSchema>> {
  const result = StageEventSchema.safeParse(data);
  return result.success
    ? { success: true, data: result.data }
    : { success: false, error: result.error };
}

/**
 * RepairEventë¥¼ ì•ˆì „í•˜ê²Œ íŒŒì‹±í•©ë‹ˆë‹¤.
 */
export function safeParseRepairEvent(
  data: unknown,
): EventParseResult<z.infer<typeof RepairEventSchema>> {
  const result = RepairEventSchema.safeParse(data);
  return result.success
    ? { success: true, data: result.data }
    : { success: false, error: result.error };
}

/**
 * BadgesEventë¥¼ ì•ˆì „í•˜ê²Œ íŒŒì‹±í•©ë‹ˆë‹¤.
 * v1(ë°°ì—´) í˜•íƒœë¡œ ì •ê·œí™”í•˜ì—¬ ë°˜í™˜í•©ë‹ˆë‹¤.
 */
export function safeParseBadgesEvent(data: unknown): EventParseResult<BadgesEvent> {
  const result = BadgesEventSchema.safeParse(data);
  if (!result.success) {
    return { success: false, error: result.error };
  }

  // v2(ê°ì²´) í˜•íƒœì¸ ê²½ìš° v1(ë°°ì—´)ë¡œ ì •ê·œí™”
  const parsed = result.data;
  if (Array.isArray(parsed.badges)) {
    // v1 í˜•íƒœ: ê·¸ëŒ€ë¡œ ë°˜í™˜
    return {
      success: true,
      data: { type: StreamEventType.BADGES, badges: parsed.badges as ValidationBadge[] },
    };
  } else {
    // v2 í˜•íƒœ: trueì¸ í‚¤ë§Œ ì¶”ì¶œí•˜ì—¬ ë°°ì—´ë¡œ ë³€í™˜
    const badgeArray = Object.entries(parsed.badges)
      .filter(([, value]) => value)
      .map(([key]) => key as ValidationBadge);
    return {
      success: true,
      data: { type: StreamEventType.BADGES, badges: badgeArray },
    };
  }
}

/**
 * NarrativeDeltaEventë¥¼ ì•ˆì „í•˜ê²Œ íŒŒì‹±í•©ë‹ˆë‹¤.
 */
export function safeParseNarrativeDeltaEvent(
  data: unknown,
): EventParseResult<z.infer<typeof NarrativeDeltaEventSchema>> {
  const result = NarrativeDeltaEventSchema.safeParse(data);
  return result.success
    ? { success: true, data: result.data }
    : { success: false, error: result.error };
}

/**
 * FinalEvent ì›ì‹œ í˜•íƒœë¥¼ ì•ˆì „í•˜ê²Œ íŒŒì‹±í•©ë‹ˆë‹¤.
 * TurnOutput ìì²´ ê²€ì¦ì€ ë³„ë„ë¡œ ìˆ˜í–‰í•´ì•¼ í•©ë‹ˆë‹¤.
 */
export function safeParseFinalEventRaw(
  data: unknown,
): EventParseResult<z.infer<typeof FinalEventRawSchema>> {
  const result = FinalEventRawSchema.safeParse(data);
  return result.success
    ? { success: true, data: result.data }
    : { success: false, error: result.error };
}

/**
 * ErrorEventë¥¼ ì•ˆì „í•˜ê²Œ íŒŒì‹±í•©ë‹ˆë‹¤.
 */
export function safeParseErrorEvent(
  data: unknown,
): EventParseResult<z.infer<typeof ErrorEventSchema>> {
  const result = ErrorEventSchema.safeParse(data);
  return result.success
    ? { success: true, data: result.data }
    : { success: false, error: result.error };
}

/**
 * stage.status ì •ê·œí™” í—¬í¼.
 * 'ok'ë¥¼ 'complete'ë¡œ, 'fail'ì€ ê·¸ëŒ€ë¡œ ìœ ì§€.
 */
export function normalizeStageStatus(status: string): 'start' | 'complete' | 'fail' {
  if (status === 'ok') return 'complete';
  if (status === 'fail') return 'fail';
  if (status === 'start') return 'start';
  return 'complete';
}

// =============================================================================
// ìŠ¤íŠ¸ë¦¼ ì´ë²¤íŠ¸ ì¸í„°í˜ì´ìŠ¤
// =============================================================================

/**
 * ë‹¨ê³„ ì§„í–‰ ì´ë²¤íŠ¸.
 * RU-002-S2: statusì— 'fail' ì¶”ê°€í•˜ì—¬ ë‹¨ê³„ ì‹¤íŒ¨ í‘œí˜„ ì§€ì›.
 */
export interface StageEvent {
  type: typeof StreamEventType.STAGE;
  name: AgentPhase;
  /** 'start' | 'complete' | 'ok' | 'fail'. okëŠ” completeë¡œ ì •ê·œí™”ë¨. */
  status: StageStatusName;
}

/** ìë™ ë³µêµ¬(Repair) ì´ë²¤íŠ¸ */
export interface RepairEvent {
  type: typeof StreamEventType.REPAIR;
  attempt: number;
  message?: string;
}

/** ë°°ì§€ ì´ë²¤íŠ¸ */
export interface BadgesEvent {
  type: typeof StreamEventType.BADGES;
  badges: ValidationBadge[];
}

/** ë‚´ëŸ¬í‹°ë¸Œ ë¸íƒ€ ì´ë²¤íŠ¸ (íƒ€ì íš¨ê³¼ìš©) */
export interface NarrativeDeltaEvent {
  type: typeof StreamEventType.NARRATIVE_DELTA;
  text: string;
}

/** ìµœì¢… TurnOutput ì´ë²¤íŠ¸
 *
 * RU-002-Q2: v1ì€ `data`, v2ëŠ” `turn_output` ì‚¬ìš©.
 * í•˜ìœ„í˜¸í™˜ì„ ìœ„í•´ ë‘ í•„ë“œ ëª¨ë‘ ì„ ì–¸í•˜ë˜, ì •ê·œí™”ëœ ì¸í„°í˜ì´ìŠ¤ëŠ” `data`ë¥¼ ì‚¬ìš©.
 */
export interface FinalEvent {
  type: typeof StreamEventType.FINAL;
  /** v1 í˜„í–‰ ê³„ì•½: TurnOutput í˜ì´ë¡œë“œ */
  data: TurnOutput;
}

/** FinalEvent ì›ì‹œ ìˆ˜ì‹  í˜•íƒœ */
export interface FinalEventRaw {
  type: typeof StreamEventType.FINAL;
  /** TurnOutput í˜ì´ë¡œë“œ */
  data: TurnOutput;
}

/** ì—ëŸ¬ ì´ë²¤íŠ¸ */
export interface ErrorEvent {
  type: typeof StreamEventType.ERROR;
  message: string;
  code?: string;
}

/** ìŠ¤íŠ¸ë¦¼ ì´ë²¤íŠ¸ ìœ ë‹ˆì˜¨ íƒ€ì… */
export type StreamEvent =
  | StageEvent
  | RepairEvent
  | BadgesEvent
  | NarrativeDeltaEvent
  | FinalEvent
  | ErrorEvent;

// =============================================================================
// ìŠ¤íŠ¸ë¦¼ ì½œë°± ì¸í„°í˜ì´ìŠ¤
// =============================================================================

/** ìŠ¤íŠ¸ë¦¼ ì´ë²¤íŠ¸ ì½œë°± */
export interface StreamCallbacks {
  /** ë‹¨ê³„ ì§„í–‰ ì´ë²¤íŠ¸ */
  onStage?: (event: StageEvent) => void;
  /** ìë™ ë³µêµ¬ ì´ë²¤íŠ¸ */
  onRepair?: (event: RepairEvent) => void;
  /** ë°°ì§€ ì´ë²¤íŠ¸ */
  onBadges?: (event: BadgesEvent) => void;
  /** ë‚´ëŸ¬í‹°ë¸Œ ë¸íƒ€ ì´ë²¤íŠ¸ */
  onNarrativeDelta?: (event: NarrativeDeltaEvent) => void;
  /** ìµœì¢… TurnOutput ì´ë²¤íŠ¸ */
  onFinal?: (event: FinalEvent) => void;
  /** ì—ëŸ¬ ì´ë²¤íŠ¸ */
  onError?: (event: ErrorEvent) => void;
  /** ìŠ¤íŠ¸ë¦¼ ì™„ë£Œ */
  onComplete?: () => void;
}
</file>

<file path="shared/schemas/turn/turn_output.schema.json">
{
  "$defs": {
    "ActionCard": {
      "additionalProperties": false,
      "description": "ì•¡ì…˜ ì¹´ë“œ (Action Deck).\n\në§¤ í„´ AIê°€ ì¶”ì²œí•˜ëŠ” í–‰ë™ ì¹´ë“œì…ë‹ˆë‹¤.\nê° ì¹´ë“œì— ë¹„ìš©/ìœ„í—˜/ë³´ìƒ íŒíŠ¸ê°€ í¬í•¨ë©ë‹ˆë‹¤.\n\nAttributes:\n    id: ì¹´ë“œ ê³ ìœ  ID\n    label: ì¹´ë“œ ë¼ë²¨ (í‘œì‹œìš©)\n    description: ì¹´ë“œ ì„¤ëª… (ì„ íƒ)\n    cost: ì˜ˆìƒ ë¹„ìš©\n    risk: ìœ„í—˜ë„\n    hint: ì˜ˆìƒ ê²°ê³¼ íŒíŠ¸ (ì„ íƒ)",
      "properties": {
        "id": {
          "description": "ì¹´ë“œ ê³ ìœ  ID",
          "title": "Id",
          "type": "string"
        },
        "label": {
          "description": "ì¹´ë“œ ë¼ë²¨ (í‘œì‹œìš©)",
          "title": "Label",
          "type": "string"
        },
        "description": {
          "anyOf": [
            {
              "type": "string"
            },
            {
              "type": "null"
            }
          ],
          "default": null,
          "description": "ì¹´ë“œ ì„¤ëª… (ì„ íƒ)",
          "title": "Description"
        },
        "cost": {
          "$ref": "#/$defs/CurrencyAmount",
          "description": "ì˜ˆìƒ ë¹„ìš©"
        },
        "risk": {
          "$ref": "#/$defs/RiskLevel",
          "default": "low",
          "description": "ìœ„í—˜ë„"
        },
        "hint": {
          "anyOf": [
            {
              "type": "string"
            },
            {
              "type": "null"
            }
          ],
          "default": null,
          "description": "ì˜ˆìƒ ê²°ê³¼ íŒíŠ¸ (ì„ íƒ)",
          "title": "Hint"
        }
      },
      "required": [
        "id",
        "label",
        "cost"
      ],
      "title": "ActionCard",
      "type": "object"
    },
    "ActionDeck": {
      "additionalProperties": false,
      "description": "ì•¡ì…˜ ë± (Q1 ê²°ì •: ui.action_deck.cards[] êµ¬ì¡°).\n\në§¤ í„´ AIê°€ ì œì‹œí•˜ëŠ” ì¶”ì²œ í–‰ë™ ì¹´ë“œ ë±ì…ë‹ˆë‹¤.\n\nAttributes:\n    cards: ì•¡ì…˜ ì¹´ë“œ ëª©ë¡ (3~6ì¥ ê¶Œì¥)",
      "properties": {
        "cards": {
          "default": [],
          "description": "ì•¡ì…˜ ì¹´ë“œ ëª©ë¡ (3~6ì¥ ê¶Œì¥)",
          "items": {
            "$ref": "#/$defs/ActionCard"
          },
          "maxItems": 10,
          "minItems": 0,
          "title": "Cards",
          "type": "array"
        }
      },
      "title": "ActionDeck",
      "type": "object"
    },
    "AgentConsole": {
      "additionalProperties": false,
      "description": "ì—ì´ì „íŠ¸ ì½˜ì†” ë°ì´í„° (RULE-008).\n\nì—ì´ì „íŠ¸í˜• ì‹œìŠ¤í…œì„ì„ UIë¡œ ì¦ëª…í•˜ê¸° ìœ„í•œ ì •ë³´ì…ë‹ˆë‹¤.\nê³„íš/ì‹¤í–‰/ê²€ì¦/ë³µêµ¬ì˜ í”ì ì„ í‘œì‹œí•©ë‹ˆë‹¤.\n\nAttributes:\n    current_phase: í˜„ì¬ ì‹¤í–‰ ë‹¨ê³„\n    badges: ê²€ì¦ ë°°ì§€ ëª©ë¡\n    repair_count: ìë™ ë³µêµ¬ ì‹œë„ íšŸìˆ˜",
      "properties": {
        "current_phase": {
          "$ref": "#/$defs/AgentPhase",
          "default": "commit",
          "description": "í˜„ì¬ ì‹¤í–‰ ë‹¨ê³„"
        },
        "badges": {
          "default": [],
          "description": "ê²€ì¦ ë°°ì§€ ëª©ë¡",
          "items": {
            "$ref": "#/$defs/ValidationBadge"
          },
          "title": "Badges",
          "type": "array"
        },
        "repair_count": {
          "default": 0,
          "description": "ìë™ ë³µêµ¬ ì‹œë„ íšŸìˆ˜",
          "minimum": 0,
          "title": "Repair Count",
          "type": "integer"
        }
      },
      "title": "AgentConsole",
      "type": "object"
    },
    "AgentPhase": {
      "description": "ì—ì´ì „íŠ¸ ì‹¤í–‰ ë‹¨ê³„ (RULE-008).\n\nì—ì´ì „íŠ¸í˜• ì‹œìŠ¤í…œì„ì„ UIë¡œ ì¦ëª…í•˜ê¸° ìœ„í•œ ë‹¨ê³„ í‘œì‹œ.",
      "enum": [
        "parse",
        "validate",
        "plan",
        "resolve",
        "render",
        "verify",
        "commit"
      ],
      "title": "AgentPhase",
      "type": "string"
    },
    "Box2D": {
      "additionalProperties": false,
      "description": "2D ë°”ìš´ë”© ë°•ìŠ¤ (RULE-009).\n\nì¢Œí‘œëŠ” 0~1000 ì •ê·œí™” ì¢Œí‘œê³„ì´ë©°, bboxëŠ” [ymin, xmin, ymax, xmax] ìˆœì„œì…ë‹ˆë‹¤.\nì´ë¯¸ì§€ ì´í•´ bbox í¬ë§·ê³¼ í˜¸í™˜ë©ë‹ˆë‹¤.\n\nAttributes:\n    ymin: Y ìµœì†Œê°’ (ìƒë‹¨)\n    xmin: X ìµœì†Œê°’ (ì¢Œì¸¡)\n    ymax: Y ìµœëŒ€ê°’ (í•˜ë‹¨)\n    xmax: X ìµœëŒ€ê°’ (ìš°ì¸¡)",
      "properties": {
        "ymin": {
          "description": "ì •ê·œí™” ì¢Œí‘œ (0~1000)",
          "maximum": 1000,
          "minimum": 0,
          "title": "Ymin",
          "type": "integer"
        },
        "xmin": {
          "description": "ì •ê·œí™” ì¢Œí‘œ (0~1000)",
          "maximum": 1000,
          "minimum": 0,
          "title": "Xmin",
          "type": "integer"
        },
        "ymax": {
          "description": "ì •ê·œí™” ì¢Œí‘œ (0~1000)",
          "maximum": 1000,
          "minimum": 0,
          "title": "Ymax",
          "type": "integer"
        },
        "xmax": {
          "description": "ì •ê·œí™” ì¢Œí‘œ (0~1000)",
          "maximum": 1000,
          "minimum": 0,
          "title": "Xmax",
          "type": "integer"
        }
      },
      "required": [
        "ymin",
        "xmin",
        "ymax",
        "xmax"
      ],
      "title": "Box2D",
      "type": "object"
    },
    "CurrencyAmount": {
      "additionalProperties": false,
      "description": "ì¬í™” ìˆ˜ëŸ‰.\n\nAttributes:\n    signal: ê¸°ë³¸ ì¬í™” (í…ìŠ¤íŠ¸ í„´/ì´ë¯¸ì§€ ìƒì„±/ê³ ê¸‰ ê¸°ëŠ¥ì— ì†Œë¹„)\n    memory_shard: í¬ê·€ ì¬í™” (ì¤‘ìš” ì„¤ì • ê³ ì •, ê³ í•´ìƒë„ ì´ë¯¸ì§€ ë“±ì— ì†Œë¹„)",
      "properties": {
        "signal": {
          "description": "ì‹œê·¸ë„ (ê¸°ë³¸ ì¬í™”, 0 ì´ìƒ)",
          "minimum": 0,
          "title": "Signal",
          "type": "integer"
        },
        "memory_shard": {
          "description": "ê¸°ì–µ íŒŒí¸ (í¬ê·€ ì¬í™”, 0 ì´ìƒ)",
          "minimum": 0,
          "title": "Memory Shard",
          "type": "integer"
        }
      },
      "required": [
        "signal",
        "memory_shard"
      ],
      "title": "CurrencyAmount",
      "type": "object"
    },
    "EconomyOutput": {
      "additionalProperties": false,
      "description": "ê²½ì œ ì¶œë ¥ ë°ì´í„° (RULE-005).\n\nì´ë²ˆ í„´ì˜ ë¹„ìš©ê³¼ ì”ì•¡ ì •ë³´ì…ë‹ˆë‹¤.\nì”ì•¡ ìŒìˆ˜ëŠ” ì ˆëŒ€ ë¶ˆê°€ (ì„œë²„ Hard gate).\n\nAttributes:\n    cost: ì´ë²ˆ í„´ì— ì†Œë¹„ëœ ë¹„ìš©\n    balance_after: ì†Œë¹„ í›„ ì”ì•¡\n\nImportant:\n    - costì™€ balance_afterëŠ” í•­ìƒ í¬í•¨ë˜ì–´ì•¼ í•©ë‹ˆë‹¤.\n    - balance_afterì˜ signalê³¼ memory_shardëŠ” 0 ì´ìƒì´ì–´ì•¼ í•©ë‹ˆë‹¤.",
      "properties": {
        "cost": {
          "$ref": "#/$defs/CurrencyAmount",
          "description": "ì´ë²ˆ í„´ì— ì†Œë¹„ëœ ë¹„ìš©"
        },
        "balance_after": {
          "$ref": "#/$defs/CurrencyAmount",
          "description": "ì†Œë¹„ í›„ ì”ì•¡"
        }
      },
      "required": [
        "cost",
        "balance_after"
      ],
      "title": "EconomyOutput",
      "type": "object"
    },
    "ImageJob": {
      "additionalProperties": false,
      "description": "ì´ë¯¸ì§€ ìƒì„± ì‘ì—….\n\nì¡°ê±´ë¶€ ì´ë¯¸ì§€ ìƒì„±/í¸ì§‘ ìš”ì²­ì…ë‹ˆë‹¤.\nì´ë¯¸ì§€ ìƒì„±ì´ ëŠë¦´ ê²½ìš° í…ìŠ¤íŠ¸ ìš°ì„  ì¶œë ¥ + Lazy Loadingì„ ì‚¬ìš©í•©ë‹ˆë‹¤.\n\nAttributes:\n    should_generate: ì´ë¯¸ì§€ë¥¼ ìƒì„±í•´ì•¼ í•˜ëŠ”ì§€\n    prompt: ì´ë¯¸ì§€ ìƒì„± í”„ë¡¬í”„íŠ¸\n    model_label: ëª¨ë¸ ì„ íƒ ë¼ë²¨ (FAST/QUALITY/CHEAP/REF)\n    aspect_ratio: ê°€ë¡œì„¸ë¡œ ë¹„ìœ¨ (ì˜ˆ: \"16:9\", \"1:1\")\n    image_size: ì´ë¯¸ì§€ í¬ê¸° (ì˜ˆ: \"1024x1024\")\n    reference_image_ids: ì°¸ì¡° ì´ë¯¸ì§€ ID ëª©ë¡ (ì„ íƒ)",
      "properties": {
        "should_generate": {
          "description": "ì´ë¯¸ì§€ë¥¼ ìƒì„±í•´ì•¼ í•˜ëŠ”ì§€",
          "title": "Should Generate",
          "type": "boolean"
        },
        "prompt": {
          "default": "",
          "description": "ì´ë¯¸ì§€ ìƒì„± í”„ë¡¬í”„íŠ¸",
          "title": "Prompt",
          "type": "string"
        },
        "model_label": {
          "$ref": "#/$defs/ModelLabel",
          "default": "FAST",
          "description": "ëª¨ë¸ ì„ íƒ ë¼ë²¨"
        },
        "aspect_ratio": {
          "default": "16:9",
          "description": "ê°€ë¡œì„¸ë¡œ ë¹„ìœ¨",
          "title": "Aspect Ratio",
          "type": "string"
        },
        "image_size": {
          "default": "1024x1024",
          "description": "ì´ë¯¸ì§€ í¬ê¸°",
          "title": "Image Size",
          "type": "string"
        },
        "reference_image_ids": {
          "default": [],
          "description": "ì°¸ì¡° ì´ë¯¸ì§€ ID ëª©ë¡ (ì„ íƒ)",
          "items": {
            "type": "string"
          },
          "title": "Reference Image Ids",
          "type": "array"
        }
      },
      "required": [
        "should_generate"
      ],
      "title": "ImageJob",
      "type": "object"
    },
    "Language": {
      "description": "ì§€ì› ì–¸ì–´ (RULE-006).\n\nko/en í˜¼í•© ì¶œë ¥ ê¸ˆì§€. TurnInput.languageë¥¼ SSOTë¡œ ì‚¼ì•„\nëª¨ë“  UI/ë‚´ëŸ¬í‹°ë¸Œ/ì‹œìŠ¤í…œ ë©”ì‹œì§€ëŠ” ë™ì¼ ì–¸ì–´ë¡œ ê³ ì •í•©ë‹ˆë‹¤.",
      "enum": [
        "ko-KR",
        "en-US"
      ],
      "title": "Language",
      "type": "string"
    },
    "MemoryPin": {
      "additionalProperties": false,
      "description": "ì¤‘ìš” ì„¤ì • ê³ ì • í›„ë³´.\n\nì‚¬ìš©ìê°€ Memory Shardë¥¼ ì†Œë¹„í•´ ê³ ì •í•  ìˆ˜ ìˆëŠ” ì¤‘ìš” ì„¤ì •ì…ë‹ˆë‹¤.\n\nAttributes:\n    id: í•€ ê³ ìœ  ID\n    content: ê³ ì •í•  ë‚´ìš©\n    cost: ê³ ì •ì— í•„ìš”í•œ ë¹„ìš©",
      "properties": {
        "id": {
          "description": "í•€ ê³ ìœ  ID",
          "title": "Id",
          "type": "string"
        },
        "content": {
          "description": "ê³ ì •í•  ë‚´ìš©",
          "title": "Content",
          "type": "string"
        },
        "cost": {
          "$ref": "#/$defs/CurrencyAmount",
          "description": "ê³ ì •ì— í•„ìš”í•œ ë¹„ìš©"
        }
      },
      "required": [
        "id",
        "content",
        "cost"
      ],
      "title": "MemoryPin",
      "type": "object"
    },
    "ModelLabel": {
      "description": "ëª¨ë¸/í’ˆì§ˆ ì„ íƒ ë¼ë²¨ (RULE-008).\n\ní”„ë¡¬í”„íŠ¸ ë…¸ì¶œ ì—†ì´ \"ì™œ ì´ ì„ íƒì´ì—ˆëŠ”ì§€\"ë¥¼ ì‚¬ìš©ì ì¹œí™” ë¼ë²¨ë¡œ í‘œì‹œ.",
      "enum": [
        "FAST",
        "QUALITY",
        "CHEAP",
        "REF"
      ],
      "title": "ModelLabel",
      "type": "string"
    },
    "Quest": {
      "additionalProperties": false,
      "description": "í€˜ìŠ¤íŠ¸/ëª©í‘œ (Quest Panel).\n\ní”Œë ˆì´ì–´ê°€ ë‹¬ì„±í•´ì•¼ í•˜ëŠ” í˜„ì¬ ëª©í‘œì…ë‹ˆë‹¤.\n\nAttributes:\n    id: í€˜ìŠ¤íŠ¸ ê³ ìœ  ID\n    label: í€˜ìŠ¤íŠ¸ ì´ë¦„\n    is_completed: ë‹¬ì„± ì—¬ë¶€",
      "properties": {
        "id": {
          "description": "í€˜ìŠ¤íŠ¸ ê³ ìœ  ID",
          "title": "Id",
          "type": "string"
        },
        "label": {
          "description": "í€˜ìŠ¤íŠ¸ ì´ë¦„",
          "title": "Label",
          "type": "string"
        },
        "is_completed": {
          "default": false,
          "description": "ë‹¬ì„± ì—¬ë¶€",
          "title": "Is Completed",
          "type": "boolean"
        }
      },
      "required": [
        "id",
        "label"
      ],
      "title": "Quest",
      "type": "object"
    },
    "RenderOutput": {
      "additionalProperties": false,
      "description": "ë Œë”ë§ ì¶œë ¥ ë°ì´í„°.\n\nì´ë¯¸ì§€ ìƒì„±/í¸ì§‘ ê´€ë ¨ ì •ë³´ì…ë‹ˆë‹¤.\n\nAttributes:\n    image_job: ì´ë¯¸ì§€ ìƒì„± ì‘ì—… (ì„ íƒ)",
      "properties": {
        "image_job": {
          "anyOf": [
            {
              "$ref": "#/$defs/ImageJob"
            },
            {
              "type": "null"
            }
          ],
          "default": null,
          "description": "ì´ë¯¸ì§€ ìƒì„± ì‘ì—… (ì„ íƒ)"
        }
      },
      "title": "RenderOutput",
      "type": "object"
    },
    "RiskLevel": {
      "description": "í–‰ë™ ìœ„í—˜ë„ ìˆ˜ì¤€.",
      "enum": [
        "low",
        "medium",
        "high"
      ],
      "title": "RiskLevel",
      "type": "string"
    },
    "SafetyOutput": {
      "additionalProperties": false,
      "description": "ì•ˆì „ ì¶œë ¥ ë°ì´í„°.\n\nì•ˆì „ ì •ì±… ê´€ë ¨ ì •ë³´ì…ë‹ˆë‹¤.\nì°¨ë‹¨ ì‹œ ëª…ì‹œì  ë©”ì‹œì§€ì™€ í•¨ê»˜ ì•ˆì „í•œ ëŒ€ì²´ ê²°ê³¼ë¥¼ ì œê³µí•©ë‹ˆë‹¤.\n\nAttributes:\n    blocked: ì•ˆì „ ì •ì±…ì— ì˜í•´ ì°¨ë‹¨ë˜ì—ˆëŠ”ì§€\n    message: ì°¨ë‹¨ ì‹œ ì‚¬ìš©ìì—ê²Œ í‘œì‹œí•  ë©”ì‹œì§€ (ì„ íƒ)",
      "properties": {
        "blocked": {
          "default": false,
          "description": "ì•ˆì „ ì •ì±…ì— ì˜í•´ ì°¨ë‹¨ë˜ì—ˆëŠ”ì§€",
          "title": "Blocked",
          "type": "boolean"
        },
        "message": {
          "anyOf": [
            {
              "type": "string"
            },
            {
              "type": "null"
            }
          ],
          "default": null,
          "description": "ì°¨ë‹¨ ì‹œ ì‚¬ìš©ìì—ê²Œ í‘œì‹œí•  ë©”ì‹œì§€ (ì„ íƒ)",
          "title": "Message"
        }
      },
      "title": "SafetyOutput",
      "type": "object"
    },
    "SceneObject": {
      "additionalProperties": false,
      "description": "ì¥ë©´ ì˜¤ë¸Œì íŠ¸ (í´ë¦­ ê°€ëŠ¥í•œ í•«ìŠ¤íŒŸ).\n\ní™”ë©´ì—ì„œ í´ë¦­ ê°€ëŠ¥í•œ ì˜¤ë¸Œì íŠ¸ì…ë‹ˆë‹¤.\nì¢Œí‘œëŠ” 0~1000 ì •ê·œí™” ì¢Œí‘œê³„ë¥¼ ì‚¬ìš©í•©ë‹ˆë‹¤ (RULE-009).\n\nAttributes:\n    id: ì˜¤ë¸Œì íŠ¸ ê³ ìœ  ID\n    label: ì˜¤ë¸Œì íŠ¸ ë¼ë²¨ (í‘œì‹œìš©)\n    box_2d: ë°”ìš´ë”© ë°•ìŠ¤ [ymin, xmin, ymax, xmax]\n    interaction_hint: ìƒí˜¸ì‘ìš© íŒíŠ¸ (ì„ íƒ)",
      "properties": {
        "id": {
          "description": "ì˜¤ë¸Œì íŠ¸ ê³ ìœ  ID",
          "title": "Id",
          "type": "string"
        },
        "label": {
          "description": "ì˜¤ë¸Œì íŠ¸ ë¼ë²¨ (í‘œì‹œìš©)",
          "title": "Label",
          "type": "string"
        },
        "box_2d": {
          "$ref": "#/$defs/Box2D",
          "description": "ë°”ìš´ë”© ë°•ìŠ¤"
        },
        "interaction_hint": {
          "anyOf": [
            {
              "type": "string"
            },
            {
              "type": "null"
            }
          ],
          "default": null,
          "description": "ìƒí˜¸ì‘ìš© íŒíŠ¸ (ì„ íƒ)",
          "title": "Interaction Hint"
        }
      },
      "required": [
        "id",
        "label",
        "box_2d"
      ],
      "title": "SceneObject",
      "type": "object"
    },
    "SceneOutput": {
      "additionalProperties": false,
      "description": "Scene í‘œì‹œ ì •ë³´ (RU-003-T1: Scene ì´ë¯¸ì§€ SSOT).\n\nTurnOutputì—ì„œ Scene Canvasì— í‘œì‹œí•  ì´ë¯¸ì§€ ì •ë³´ë¥¼ ì œê³µí•©ë‹ˆë‹¤.\nimage_urlì´ ì¡´ì¬í•˜ë©´ SceneCanvasëŠ” 'scene' ìƒíƒœë¡œ ì „í™˜ë©ë‹ˆë‹¤.\nimage_urlì´ ì—†ìœ¼ë©´ 'default' ìƒíƒœë¥¼ ìœ ì§€í•©ë‹ˆë‹¤.\n\nAttributes:\n    image_url: Scene ì´ë¯¸ì§€ URL (ì¡´ì¬ ì‹œ scene ìƒíƒœë¡œ ì „í™˜)\n    alt_text: ì´ë¯¸ì§€ ëŒ€ì²´ í…ìŠ¤íŠ¸ (ì ‘ê·¼ì„±ìš©, ì„ íƒ)",
      "properties": {
        "image_url": {
          "anyOf": [
            {
              "type": "string"
            },
            {
              "type": "null"
            }
          ],
          "default": null,
          "description": "Scene ì´ë¯¸ì§€ URL (ì¡´ì¬ ì‹œ scene ìƒíƒœë¡œ ì „í™˜)",
          "title": "Image Url"
        },
        "alt_text": {
          "anyOf": [
            {
              "type": "string"
            },
            {
              "type": "null"
            }
          ],
          "default": null,
          "description": "ì´ë¯¸ì§€ ëŒ€ì²´ í…ìŠ¤íŠ¸ (ì ‘ê·¼ì„±ìš©, ì„ íƒ)",
          "title": "Alt Text"
        }
      },
      "title": "SceneOutput",
      "type": "object"
    },
    "UIOutput": {
      "additionalProperties": false,
      "description": "UI ì¶œë ¥ ë°ì´í„°.\n\nAIê°€ ìƒì„±í•œ UI ìš”ì†Œë“¤ì…ë‹ˆë‹¤.\nì±„íŒ… ë²„ë¸”ì´ ì•„ë‹Œ ê²Œì„ UIë¡œ í‘œí˜„ë©ë‹ˆë‹¤ (RULE-002).\n\nRU-003-T1: scene í•„ë“œ ì¶”ê°€ - Scene Canvasì˜ ì´ë¯¸ì§€ í‘œì‹œ ì •ë³´ SSOT.\n\nAttributes:\n    action_deck: ì•¡ì…˜ ì¹´ë“œ ë± (Q1 ê²°ì •: Option A ì±„íƒ)\n    objects: í´ë¦­ ê°€ëŠ¥í•œ ì¥ë©´ ì˜¤ë¸Œì íŠ¸ ëª©ë¡\n    scene: Scene í‘œì‹œ ì •ë³´ (RU-003-T1)",
      "properties": {
        "action_deck": {
          "$ref": "#/$defs/ActionDeck",
          "description": "ì•¡ì…˜ ì¹´ë“œ ë±"
        },
        "objects": {
          "default": [],
          "description": "í´ë¦­ ê°€ëŠ¥í•œ ì¥ë©´ ì˜¤ë¸Œì íŠ¸ ëª©ë¡",
          "items": {
            "$ref": "#/$defs/SceneObject"
          },
          "title": "Objects",
          "type": "array"
        },
        "scene": {
          "$ref": "#/$defs/SceneOutput",
          "default": {
            "image_url": null,
            "alt_text": null
          },
          "description": "Scene í‘œì‹œ ì •ë³´ (RU-003-T1)"
        }
      },
      "title": "UIOutput",
      "type": "object"
    },
    "ValidationBadge": {
      "description": "ê²€ì¦ ë°°ì§€ (RULE-008).\n\ní„´ ê²°ê³¼ì— ëŒ€í•œ ê²€ì¦ ìƒíƒœë¥¼ í‘œì‹œí•©ë‹ˆë‹¤.",
      "enum": [
        "schema_ok",
        "schema_fail",
        "economy_ok",
        "economy_fail",
        "safety_ok",
        "safety_blocked",
        "consistency_ok",
        "consistency_fail"
      ],
      "title": "ValidationBadge",
      "type": "string"
    },
    "WorldDelta": {
      "additionalProperties": false,
      "description": "ì„¸ê³„ ìƒíƒœ ë³€í™” (Q2 ê²°ì •: Option A - delta ì¤‘ì‹¬).\n\nì´ë²ˆ í„´ì—ì„œ ë³€ê²½ëœ ì„¸ê³„ ìƒíƒœë¥¼ ë‚˜íƒ€ëƒ…ë‹ˆë‹¤.\nsnapshotì€ SaveGameì—ë§Œ ì €ì¥í•˜ê³ , ë§¤ í„´ì€ deltaë§Œ ì „ì†¡í•©ë‹ˆë‹¤.\n\nAttributes:\n    rules_changed: ë³€ê²½ë˜ê±°ë‚˜ ì¶”ê°€ëœ ê·œì¹™ ëª©ë¡\n    inventory_added: ì¶”ê°€ëœ ì¸ë²¤í† ë¦¬ ì•„ì´í…œ\n    inventory_removed: ì œê±°ëœ ì¸ë²¤í† ë¦¬ ì•„ì´í…œ\n    quests_updated: ì—…ë°ì´íŠ¸ëœ í€˜ìŠ¤íŠ¸(ëª©í‘œ) ëª©ë¡\n    relationships_changed: ë³€ê²½ëœ ê´€ê³„\n    memory_pins: ì¤‘ìš” ì„¤ì • ê³ ì • í›„ë³´",
      "properties": {
        "rules_changed": {
          "default": [],
          "description": "ë³€ê²½ëœ ê·œì¹™ ëª©ë¡",
          "items": {
            "$ref": "#/$defs/WorldRule"
          },
          "title": "Rules Changed",
          "type": "array"
        },
        "inventory_added": {
          "default": [],
          "description": "ì¶”ê°€ëœ ì¸ë²¤í† ë¦¬ ì•„ì´í…œ",
          "items": {
            "type": "string"
          },
          "title": "Inventory Added",
          "type": "array"
        },
        "inventory_removed": {
          "default": [],
          "description": "ì œê±°ëœ ì¸ë²¤í† ë¦¬ ì•„ì´í…œ",
          "items": {
            "type": "string"
          },
          "title": "Inventory Removed",
          "type": "array"
        },
        "quests_updated": {
          "default": [],
          "description": "ì—…ë°ì´íŠ¸ëœ í€˜ìŠ¤íŠ¸/ëª©í‘œ ëª©ë¡",
          "items": {
            "$ref": "#/$defs/Quest"
          },
          "title": "Quests Updated",
          "type": "array"
        },
        "relationships_changed": {
          "default": [],
          "description": "ë³€ê²½ëœ ê´€ê³„",
          "items": {
            "type": "string"
          },
          "title": "Relationships Changed",
          "type": "array"
        },
        "memory_pins": {
          "default": [],
          "description": "ì¤‘ìš” ì„¤ì • ê³ ì • í›„ë³´",
          "items": {
            "$ref": "#/$defs/MemoryPin"
          },
          "title": "Memory Pins",
          "type": "array"
        }
      },
      "title": "WorldDelta",
      "type": "object"
    },
    "WorldRule": {
      "additionalProperties": false,
      "description": "ì„¸ê³„ ê·œì¹™ (Rule Board).\n\ní˜„ì¬ ì„¸ê³„ì— ì ìš© ì¤‘ì¸ ë¬¼ë¦¬ ë²•ì¹™ì´ë‚˜ ë©”íƒ€ ê·œì¹™ì…ë‹ˆë‹¤.\n\nAttributes:\n    id: ê·œì¹™ ê³ ìœ  ID\n    label: ê·œì¹™ ì´ë¦„\n    description: ê·œì¹™ ìƒì„¸ ì„¤ëª… (ì„ íƒ)",
      "properties": {
        "id": {
          "description": "ê·œì¹™ ê³ ìœ  ID",
          "title": "Id",
          "type": "string"
        },
        "label": {
          "description": "ê·œì¹™ ì´ë¦„",
          "title": "Label",
          "type": "string"
        },
        "description": {
          "anyOf": [
            {
              "type": "string"
            },
            {
              "type": "null"
            }
          ],
          "default": null,
          "description": "ê·œì¹™ ìƒì„¸ ì„¤ëª… (ì„ íƒ)",
          "title": "Description"
        }
      },
      "required": [
        "id",
        "label"
      ],
      "title": "WorldRule",
      "type": "object"
    }
  },
  "additionalProperties": false,
  "description": "í„´ ì¶œë ¥ (ì„œë²„ â†’ í´ë¼ì´ì–¸íŠ¸).\n\nì„œë²„ê°€ í„´ ì²˜ë¦¬ í›„ í´ë¼ì´ì–¸íŠ¸ë¡œ ë°˜í™˜í•˜ëŠ” êµ¬ì¡°í™”ëœ ì‘ë‹µì…ë‹ˆë‹¤.\nGemini Structured Outputs(JSON Schema)ë¡œ ê°•ì œë©ë‹ˆë‹¤.\n\nHard Gate í•„ë“œ (RULE-003/004/005):\n    - economy: costì™€ balance_after í•„ìˆ˜, ì”ì•¡ ìŒìˆ˜ ê¸ˆì§€\n    - safety: blocked ì‹œ ì•ˆì „í•œ ëŒ€ì²´ ê²°ê³¼ ì œê³µ\n    - language: ìš”ì²­ ì–¸ì–´ì™€ ë™ì¼í•˜ê²Œ ê³ ì • (í˜¼í•© ì¶œë ¥ ê¸ˆì§€)\n\nAttributes:\n    language: ì‘ë‹µ ì–¸ì–´ (ìš”ì²­ê³¼ ë™ì¼)\n    narrative: ë‚´ëŸ¬í‹°ë¸Œ í…ìŠ¤íŠ¸ (í‘œì‹œìš©)\n    ui: UI ìš”ì†Œ (ì•¡ì…˜ ë±, ì˜¤ë¸Œì íŠ¸)\n    world: ì„¸ê³„ ìƒíƒœ ë³€í™” (delta ì¤‘ì‹¬)\n    render: ë Œë”ë§ ì •ë³´ (ì´ë¯¸ì§€ ìƒì„± ì‘ì—…)\n    economy: ê²½ì œ ì •ë³´ (ë¹„ìš©, ì”ì•¡)\n    safety: ì•ˆì „ ì •ì±… ì •ë³´\n    agent_console: ì—ì´ì „íŠ¸ ì‹¤í–‰ ì •ë³´ (ë‹¨ê³„, ë°°ì§€, ë³µêµ¬ íšŸìˆ˜)\n\nExample:\n    >>> output = TurnOutput(\n    ...     language=Language.KO,\n    ...     narrative=\"ë¬¸ì´ ì‚ê±±ê±°ë¦¬ë©° ì—´ë¦½ë‹ˆë‹¤...\",\n    ...     economy=EconomyOutput(\n    ...         cost=CurrencyAmount(signal=5, memory_shard=0),\n    ...         balance_after=CurrencyAmount(signal=95, memory_shard=5),\n    ...     ),\n    ...     safety=SafetyOutput(blocked=False),\n    ... )\n    >>> schema = TurnOutput.model_json_schema()\n\nSchema Generation:\n    >>> # Gemini Structured Outputsìš© JSON Schema ìƒì„±\n    >>> json_schema = TurnOutput.model_json_schema()\n    >>> # response_json_schema íŒŒë¼ë¯¸í„°ì— ì „ë‹¬\n    >>> config = {\n    ...     \"response_mime_type\": \"application/json\",\n    ...     \"response_json_schema\": json_schema,\n    ... }",
  "properties": {
    "language": {
      "$ref": "#/$defs/Language",
      "description": "ì‘ë‹µ ì–¸ì–´ (ìš”ì²­ê³¼ ë™ì¼)"
    },
    "narrative": {
      "description": "ë‚´ëŸ¬í‹°ë¸Œ í…ìŠ¤íŠ¸ (í‘œì‹œìš©)",
      "title": "Narrative",
      "type": "string"
    },
    "economy": {
      "$ref": "#/$defs/EconomyOutput",
      "description": "ê²½ì œ ì •ë³´ (ë¹„ìš©, ì”ì•¡)"
    },
    "safety": {
      "$ref": "#/$defs/SafetyOutput",
      "description": "ì•ˆì „ ì •ì±… ì •ë³´"
    },
    "ui": {
      "$ref": "#/$defs/UIOutput",
      "description": "UI ìš”ì†Œ"
    },
    "world": {
      "$ref": "#/$defs/WorldDelta",
      "description": "ì„¸ê³„ ìƒíƒœ ë³€í™” (delta)"
    },
    "render": {
      "$ref": "#/$defs/RenderOutput",
      "description": "ë Œë”ë§ ì •ë³´"
    },
    "agent_console": {
      "$ref": "#/$defs/AgentConsole",
      "description": "ì—ì´ì „íŠ¸ ì‹¤í–‰ ì •ë³´"
    }
  },
  "required": [
    "language",
    "narrative",
    "economy",
    "safety"
  ],
  "title": "TurnOutput",
  "type": "object"
}
</file>

<file path="backend/src/unknown_world/orchestrator/mock.py">
"""Unknown World - ëª¨ì˜ Orchestrator.

ì‹¤ëª¨ë¸(Gemini) ì—†ì´ í”„ë¡ íŠ¸ì—”ë“œ ê°œë°œ/ë°ëª¨ë¥¼ ì§€ì†í•  ìˆ˜ ìˆë„ë¡
ê²°ì •ì (seed ê¸°ë°˜) TurnOutputì„ ìƒì„±í•˜ëŠ” ëª¨ì˜ Orchestratorì…ë‹ˆë‹¤.

ì„¤ê³„ ì›ì¹™:
    - RULE-004: ê²€ì¦ ì‹¤íŒ¨ ì‹œ ì•ˆì „í•œ í´ë°± ì œê³µ
    - RULE-005: ì¬í™” ì¸ë°”ë¦¬ì–¸íŠ¸ (ì”ì•¡ ìŒìˆ˜ ê¸ˆì§€)
    - RULE-008: ë‹¨ê³„/ë°°ì§€ ê°€ì‹œí™”
    - RULE-009: ì¢Œí‘œ ê·œì•½ (0~1000, bbox [ymin,xmin,ymax,xmax])

ì°¸ì¡°:
    - vibe/unit-plans/U-007[Mvp].md
    - vibe/unit-plans/U-048[Mvp].md
    - .cursor/rules/20-backend-orchestrator.mdc
"""

import hashlib
import random
from enum import Enum

from unknown_world.models.turn import (
    ActionCard,
    ActionDeck,
    AgentConsole,
    AgentPhase,
    Box2D,
    CurrencyAmount,
    EconomyOutput,
    ImageJob,
    Language,
    MemoryPin,
    ModelLabel,
    Quest,
    RenderOutput,
    RiskLevel,
    SafetyOutput,
    SceneObject,
    TurnInput,
    TurnOutput,
    UIOutput,
    ValidationBadge,
    WorldDelta,
    WorldRule,
)
from unknown_world.orchestrator.fallback import (
    create_safe_fallback as _create_safe_fallback,
)

# =============================================================================
# ì…ë ¥ íƒ€ì… ë¶„ë¥˜ (U-048: í–‰ë™ ë¡œê·¸ í…œí”Œë¦¿ ë¶„ê¸°ìš©)
# =============================================================================


class InputType(str, Enum):
    """ì…ë ¥ íƒ€ì… ë¶„ë¥˜ (ìš°ì„ ìˆœìœ„: DROP > CLICK > ACTION > FREE_TEXT)."""

    DROP = "drop"  # ì•„ì´í…œ ë“œë¡­ (ì‚¬ìš©/ì¡°í•©)
    CLICK = "click"  # í•«ìŠ¤íŒŸ í´ë¦­ (ì¡°ì‚¬/ìƒí˜¸ì‘ìš©)
    ACTION = "action"  # ì•¡ì…˜ ì¹´ë“œ ì‹¤í–‰
    FREE_TEXT = "free_text"  # ììœ  ì…ë ¥


def _detect_input_type(turn_input: TurnInput) -> InputType:
    """TurnInputì—ì„œ ì…ë ¥ íƒ€ì…ì„ ê°ì§€ (ìš°ì„ ìˆœìœ„ ê¸°ë°˜).

    ìš°ì„ ìˆœìœ„: drop > click > action_id > free_text

    Args:
        turn_input: ì‚¬ìš©ì ì…ë ¥

    Returns:
        InputType: ê°ì§€ëœ ì…ë ¥ íƒ€ì…
    """
    if turn_input.drop is not None:
        return InputType.DROP
    if turn_input.click is not None:
        return InputType.CLICK
    if turn_input.action_id is not None:
        return InputType.ACTION
    return InputType.FREE_TEXT


def _compute_turn_seed(base_seed: int, turn_input: TurnInput) -> int:
    """per-turn ê²°ì •ì  ì‹œë“œ ìƒì„± (ì…ë ¥ íŠ¹ì§• í•´ì‹œ ê¸°ë°˜).

    base_seedì™€ ì…ë ¥ì˜ ì£¼ìš” íŠ¹ì§•ì„ í•´ì‹œí•˜ì—¬ í„´ë§ˆë‹¤ ë‹¤ë¥¸ ê²°ê³¼ë¥¼
    ìƒì„±í•˜ë©´ì„œë„ ì¬í˜„ì„±ì„ ìœ ì§€í•©ë‹ˆë‹¤.

    Args:
        base_seed: ê¸°ë³¸ ì‹œë“œ
        turn_input: ì‚¬ìš©ì ì…ë ¥

    Returns:
        int: per-turn ì‹œë“œ
    """
    # ì…ë ¥ íŠ¹ì§• ë¬¸ìì—´ ìƒì„±
    features: list[str] = [str(base_seed)]

    if turn_input.text:
        features.append(turn_input.text)
    if turn_input.action_id:
        features.append(turn_input.action_id)
    if turn_input.click:
        features.append(turn_input.click.object_id)
    if turn_input.drop:
        features.append(turn_input.drop.item_id)
        features.append(turn_input.drop.target_object_id)

    # íŠ¹ì§• ë¬¸ìì—´ì„ í•´ì‹œí•˜ì—¬ ì‹œë“œ ìƒì„±
    feature_str = "|".join(features)
    hash_bytes = hashlib.sha256(feature_str.encode("utf-8")).digest()
    # í•´ì‹œì˜ ì²˜ìŒ 8ë°”ì´íŠ¸ë¥¼ ì •ìˆ˜ë¡œ ë³€í™˜
    return int.from_bytes(hash_bytes[:8], byteorder="big") % (2**32)


# =============================================================================
# í–‰ë™ ë¡œê·¸ í”„ë¦¬í”½ìŠ¤ í…œí”Œë¦¿ (U-048: "ë§í–ˆìŠµë‹ˆë‹¤" ì œê±°)
# =============================================================================

# í•œêµ­ì–´ í–‰ë™ ë¡œê·¸ í”„ë¦¬í”½ìŠ¤ (ì…ë ¥ íƒ€ì…ë³„)
KO_ACTION_LOG_PREFIXES: dict[InputType, list[str]] = {
    InputType.DROP: [
        "[ì‚¬ìš©] {item} â†’ {target}:",
        "[ì¡°í•©] {item}ì„(ë¥¼) {target}ì— ì‚¬ìš©:",
        "[ì ìš©] {item} â†’ {target}:",
    ],
    InputType.CLICK: [
        "[ì¡°ì‚¬] {object}:",
        "[íƒìƒ‰] {object}ì„(ë¥¼) ì‚´í´ë´„:",
        "[ìƒí˜¸ì‘ìš©] {object}:",
    ],
    InputType.ACTION: [
        "[í–‰ë™] {action}:",
        "[ì‹¤í–‰] {action}:",
        "[ì‹œë„] {action}:",
    ],
    InputType.FREE_TEXT: [
        "[ì…ë ¥] {text}:",
        "[ëª…ë ¹] {text}:",
        "[ì§€ì‹œ] {text}:",
    ],
}

# ì˜ì–´ í–‰ë™ ë¡œê·¸ í”„ë¦¬í”½ìŠ¤ (ì…ë ¥ íƒ€ì…ë³„)
EN_ACTION_LOG_PREFIXES: dict[InputType, list[str]] = {
    InputType.DROP: [
        "[USE] {item} â†’ {target}:",
        "[APPLY] {item} on {target}:",
        "[COMBINE] {item} with {target}:",
    ],
    InputType.CLICK: [
        "[EXAMINE] {object}:",
        "[INSPECT] {object}:",
        "[INTERACT] {object}:",
    ],
    InputType.ACTION: [
        "[ACTION] {action}:",
        "[EXECUTE] {action}:",
        "[ATTEMPT] {action}:",
    ],
    InputType.FREE_TEXT: [
        "[INPUT] {text}:",
        "[COMMAND] {text}:",
        "[DIRECTIVE] {text}:",
    ],
}


def _format_action_log_prefix(
    rng: random.Random,
    input_type: InputType,
    turn_input: TurnInput,
    is_korean: bool,
) -> str:
    """ì…ë ¥ íƒ€ì…ì— ë§ëŠ” í–‰ë™ ë¡œê·¸ í”„ë¦¬í”½ìŠ¤ ìƒì„±.

    Args:
        rng: ëœë¤ ìƒì„±ê¸°
        input_type: ì…ë ¥ íƒ€ì…
        turn_input: ì‚¬ìš©ì ì…ë ¥
        is_korean: í•œêµ­ì–´ ì—¬ë¶€

    Returns:
        str: í¬ë§·ëœ í–‰ë™ ë¡œê·¸ í”„ë¦¬í”½ìŠ¤
    """
    templates = KO_ACTION_LOG_PREFIXES if is_korean else EN_ACTION_LOG_PREFIXES
    template = rng.choice(templates[input_type])

    # ì…ë ¥ íƒ€ì…ë³„ í¬ë§· ì¸ì ì¤€ë¹„
    format_args: dict[str, str] = {}

    if input_type == InputType.DROP and turn_input.drop:
        format_args["item"] = turn_input.drop.item_id
        format_args["target"] = turn_input.drop.target_object_id
    elif input_type == InputType.CLICK and turn_input.click:
        format_args["object"] = turn_input.click.object_id
    elif input_type == InputType.ACTION:
        format_args["action"] = turn_input.text or turn_input.action_id or ""
    elif input_type == InputType.FREE_TEXT:
        # ê¸´ í…ìŠ¤íŠ¸ëŠ” ì•ë¶€ë¶„ë§Œ í‘œì‹œ
        text = turn_input.text or ""
        if len(text) > 30:
            text = text[:27] + "..."
        format_args["text"] = text

    return template.format(**format_args)


# =============================================================================
# ëª¨ì˜ ë°ì´í„° ìƒì„± í—¬í¼
# =============================================================================

# í•œêµ­ì–´ ë‚´ëŸ¬í‹°ë¸Œ í…œí”Œë¦¿
KO_NARRATIVES = [
    "ì–´ë‘  ì†ì—ì„œ í¬ë¯¸í•œ ë¹›ì´ ìƒˆì–´ë‚˜ì˜µë‹ˆë‹¤. ì˜¤ë˜ëœ ë¬¸ì´ ì‚ê±±ê±°ë¦¬ë©° ì—´ë¦¬ê³ , ê·¸ ë„ˆë¨¸ë¡œ ì•Œ ìˆ˜ ì—†ëŠ” ì„¸ê³„ê°€ í¼ì³ì§‘ë‹ˆë‹¤.",
    "ë°œê±¸ìŒ ì†Œë¦¬ê°€ í…… ë¹ˆ ë³µë„ì— ë©”ì•„ë¦¬ì¹©ë‹ˆë‹¤. ë²½ì— ê±¸ë¦° ì´ˆìƒí™”ë“¤ì˜ ëˆˆì´ ë‹¹ì‹ ì„ ë”°ë¼ ì›€ì§ì´ëŠ” ê²ƒ ê°™ìŠµë‹ˆë‹¤.",
    "ê°‘ìê¸° ë°”ë‹¥ì´ í”ë“¤ë¦¬ë©°, ë²½ì—ì„œ ê³ ëŒ€ì˜ ë¬¸ìë“¤ì´ ë¹›ë‚˜ê¸° ì‹œì‘í•©ë‹ˆë‹¤. ë¬´ì–¸ê°€ê°€ ê¹¨ì–´ë‚˜ê³  ìˆìŠµë‹ˆë‹¤.",
    "ì•ˆê°œê°€ ê±·íˆì, ê±°ëŒ€í•œ íƒ‘ì´ ëª¨ìŠµì„ ë“œëŸ¬ëƒ…ë‹ˆë‹¤. íƒ‘ ê¼­ëŒ€ê¸°ì—ì„œ ì´ìƒí•œ ë¹›ì´ ê¹œë¹¡ì´ê³  ìˆìŠµë‹ˆë‹¤.",
    "ë‚¡ì€ ì±…ì¥ì„ ë°€ì, ìˆ¨ê²¨ì§„ í†µë¡œê°€ ë‚˜íƒ€ë‚¬ìŠµë‹ˆë‹¤. í†µë¡œ ëì—ì„œ ê¸°ë¬˜í•œ ë…¸ë˜ê°€ ë“¤ë ¤ì˜µë‹ˆë‹¤.",
]

# ì˜ì–´ ë‚´ëŸ¬í‹°ë¸Œ í…œí”Œë¦¿
EN_NARRATIVES = [
    "A faint light seeps through the darkness. An ancient door creaks open, revealing an unknown world beyond.",
    "Footsteps echo through the empty corridor. The eyes of the portraits on the walls seem to follow you.",
    "Suddenly, the ground shakes and ancient runes on the walls begin to glow. Something is awakening.",
    "As the fog lifts, a massive tower reveals itself. A strange light flickers at its peak.",
    "Pushing aside the old bookshelf, you discover a hidden passage. An eerie song emanates from its depths.",
]

# í•œêµ­ì–´ ì•¡ì…˜ ì¹´ë“œ í…œí”Œë¦¿
KO_ACTION_CARDS = [
    {"label": "ë¬¸ì„ ì—´ì–´ë³¸ë‹¤", "description": "ì¡°ì‹¬ìŠ¤ëŸ½ê²Œ ë¬¸ì„ ì—´ì–´ ì•ˆì„ ì‚´í´ë³¸ë‹¤"},
    {"label": "ì£¼ë³€ì„ íƒìƒ‰í•œë‹¤", "description": "ì£¼ë³€ì— ìœ ìš©í•œ ë¬¼ê±´ì´ ìˆëŠ”ì§€ ì°¾ì•„ë³¸ë‹¤"},
    {"label": "ë’¤ë¡œ ë¬¼ëŸ¬ì„ ë‹¤", "description": "ìœ„í—˜ì„ í”¼í•´ ì•ˆì „í•œ ê³³ìœ¼ë¡œ ë¬¼ëŸ¬ì„ ë‹¤"},
    {"label": "ë§ì„ ê±¸ì–´ë³¸ë‹¤", "description": "ìƒëŒ€ë°©ì—ê²Œ ì¡°ì‹¬ìŠ¤ëŸ½ê²Œ ë§ì„ ê±´ë‹¤"},
    {"label": "ìˆ¨ì–´ì„œ ì§€ì¼œë³¸ë‹¤", "description": "ì€ì‹ í•˜ì—¬ ìƒí™©ì„ ê´€ì°°í•œë‹¤"},
    {"label": "ê³µê²©í•œë‹¤", "description": "ìœ„í˜‘ì— ë§ì„œ ê³µê²©ì„ ì‹œë„í•œë‹¤"},
]

# ì˜ì–´ ì•¡ì…˜ ì¹´ë“œ í…œí”Œë¦¿
EN_ACTION_CARDS = [
    {"label": "Open the door", "description": "Carefully open the door and look inside"},
    {"label": "Search the area", "description": "Look for useful items nearby"},
    {"label": "Step back", "description": "Retreat to a safe place to avoid danger"},
    {"label": "Speak to them", "description": "Cautiously initiate conversation"},
    {"label": "Hide and observe", "description": "Conceal yourself and watch the situation"},
    {"label": "Attack", "description": "Confront the threat with an attack"},
]

# ì¥ë©´ ì˜¤ë¸Œì íŠ¸ í…œí”Œë¦¿
SCENE_OBJECTS_KO = [
    {"label": "ë‚¡ì€ ë¬¸", "hint": "í´ë¦­í•˜ì—¬ ì—´ì–´ë³¼ ìˆ˜ ìˆìŠµë‹ˆë‹¤"},
    {"label": "ë¹›ë‚˜ëŠ” ë³´ì„", "hint": "ìˆ˜ì§‘í•  ìˆ˜ ìˆì„ ê²ƒ ê°™ìŠµë‹ˆë‹¤"},
    {"label": "ìˆ˜ìƒí•œ ìƒì", "hint": "ë¬´ì–¸ê°€ ë“¤ì–´ìˆì„ ìˆ˜ ìˆìŠµë‹ˆë‹¤"},
    {"label": "ë²½ì˜ ìŠ¤ìœ„ì¹˜", "hint": "ì‘ë™ì‹œí‚¬ ìˆ˜ ìˆìŠµë‹ˆë‹¤"},
]

SCENE_OBJECTS_EN = [
    {"label": "Old door", "hint": "Click to open"},
    {"label": "Glowing gem", "hint": "It looks collectible"},
    {"label": "Suspicious chest", "hint": "Something might be inside"},
    {"label": "Wall switch", "hint": "Can be activated"},
]


def _generate_random_box(rng: random.Random) -> Box2D:
    """ëœë¤ ë°”ìš´ë”© ë°•ìŠ¤ ìƒì„± (0~1000 ì¢Œí‘œê³„)."""
    ymin = rng.randint(0, 700)
    xmin = rng.randint(0, 700)
    ymax = ymin + rng.randint(50, 250)
    xmax = xmin + rng.randint(50, 250)
    # ë²”ìœ„ ë³´ì •
    ymax = min(ymax, 1000)
    xmax = min(xmax, 1000)
    return Box2D(ymin=ymin, xmin=xmin, ymax=ymax, xmax=xmax)


# =============================================================================
# MockOrchestrator í´ë˜ìŠ¤
# =============================================================================


class MockOrchestrator:
    """ëª¨ì˜ Orchestrator.

    ì‹¤ëª¨ë¸(Gemini) ì—†ì´ TurnOutputì„ ìƒì„±í•˜ëŠ” ëª¨ì˜ ì˜¤ì¼€ìŠ¤íŠ¸ë ˆì´í„°ì…ë‹ˆë‹¤.
    seed ê¸°ë°˜ìœ¼ë¡œ ê²°ì •ì (ì¬í˜„ ê°€ëŠ¥)ì¸ ê²°ê³¼ë¥¼ ìƒì„±í•©ë‹ˆë‹¤.

    Note:
        Phase ìˆœì„œëŠ” pipeline.pyì˜ DEFAULT_STAGESê°€ SSOTì…ë‹ˆë‹¤ (RU-005-Q1).

    Attributes:
        seed: ëœë¤ ì‹œë“œ (ì¬í˜„ì„± ë³´ì¥)

    Example:
        >>> orchestrator = MockOrchestrator(seed=42)
        >>> turn_input = TurnInput(
        ...     language=Language.KO,
        ...     text="ë¬¸ì„ ì—´ì–´ë³¸ë‹¤",
        ...     client=ClientInfo(viewport_w=1920, viewport_h=1080),
        ...     economy_snapshot=EconomySnapshot(signal=100, memory_shard=5),
        ... )
        >>> output = orchestrator.generate_turn_output(turn_input)
    """

    def __init__(self, seed: int | None = None) -> None:
        """MockOrchestrator ì´ˆê¸°í™”.

        Args:
            seed: ëœë¤ ì‹œë“œ. Noneì´ë©´ ëœë¤í•˜ê²Œ ìƒì„±.
        """
        self.seed = seed if seed is not None else random.randint(0, 2**32 - 1)
        self._rng = random.Random(self.seed)

    def generate_turn_output(self, turn_input: TurnInput) -> TurnOutput:
        """TurnInputì„ ë°›ì•„ TurnOutputì„ ìƒì„±í•©ë‹ˆë‹¤.

        Args:
            turn_input: ì‚¬ìš©ì ì…ë ¥

        Returns:
            TurnOutput: ëª¨ì˜ í„´ ê²°ê³¼
        """
        is_korean = turn_input.language == Language.KO

        # U-048: per-turn ê²°ì •ì  RNG ìƒì„± (ì…ë ¥ì— ë”°ë¼ ë‹¤ë¥¸ ê²°ê³¼)
        turn_seed = _compute_turn_seed(self.seed, turn_input)
        turn_rng = random.Random(turn_seed)

        # ë‚´ëŸ¬í‹°ë¸Œ ìƒì„± (per-turn RNG ì‚¬ìš©ìœ¼ë¡œ ì…ë ¥ë³„ ë‹¤ì–‘ì„± í™•ë³´)
        narratives = KO_NARRATIVES if is_korean else EN_NARRATIVES
        narrative = turn_rng.choice(narratives)

        # U-048: ì…ë ¥ íƒ€ì…ë³„ í–‰ë™ ë¡œê·¸ í”„ë¦¬í”½ìŠ¤ ì ìš© ("ë§í–ˆìŠµë‹ˆë‹¤" ì œê±°)
        input_type = _detect_input_type(turn_input)
        has_meaningful_input = (
            turn_input.drop is not None
            or turn_input.click is not None
            or turn_input.action_id is not None
            or (turn_input.text and turn_input.text.strip())
        )

        if has_meaningful_input:
            prefix = _format_action_log_prefix(turn_rng, input_type, turn_input, is_korean)
            narrative = f"{prefix} {narrative}"

        # U-048: ëª¨ë“  ìƒì„±ì— turn_rng ì‚¬ìš© (ì…ë ¥ë³„ ê²°ì •ì  ë‹¤ì–‘ì„±)
        # ì•¡ì…˜ ë± ìƒì„± (3~6ì¥)
        action_templates = KO_ACTION_CARDS if is_korean else EN_ACTION_CARDS
        num_cards = turn_rng.randint(3, 6)
        selected_templates = turn_rng.sample(
            action_templates, min(num_cards, len(action_templates))
        )

        action_cards: list[ActionCard] = []
        for i, template in enumerate(selected_templates):
            cost_signal = turn_rng.randint(1, 10)
            cost_shard = 1 if turn_rng.random() < 0.2 else 0  # 20% í™•ë¥ ë¡œ shard ì†Œë¹„

            action_cards.append(
                ActionCard(
                    id=f"action_{i + 1}",
                    label=template["label"],
                    description=template["description"],
                    cost=CurrencyAmount(signal=cost_signal, memory_shard=cost_shard),
                    risk=turn_rng.choice(list(RiskLevel)),
                    hint=None,
                )
            )

        action_deck = ActionDeck(cards=action_cards)

        # ì¥ë©´ ì˜¤ë¸Œì íŠ¸ ìƒì„± (1~3ê°œ)
        object_templates = SCENE_OBJECTS_KO if is_korean else SCENE_OBJECTS_EN
        num_objects = turn_rng.randint(1, 3)
        selected_objects = turn_rng.sample(
            object_templates, min(num_objects, len(object_templates))
        )

        scene_objects: list[SceneObject] = []
        for i, template in enumerate(selected_objects):
            scene_objects.append(
                SceneObject(
                    id=f"obj_{i + 1}",
                    label=template["label"],
                    box_2d=_generate_random_box(turn_rng),
                    interaction_hint=template["hint"],
                )
            )

        ui_output = UIOutput(action_deck=action_deck, objects=scene_objects)

        # ì„¸ê³„ ìƒíƒœ ë³€í™” (delta) - turn_rng ì „ë‹¬
        world_delta = self._generate_world_delta(is_korean, turn_rng)

        # ë Œë”ë§ ì¶œë ¥ (ì´ë¯¸ì§€ ìƒì„±ì€ ì„ íƒì )
        should_generate_image = turn_rng.random() < 0.3  # 30% í™•ë¥ ë¡œ ì´ë¯¸ì§€ ìƒì„±
        render_output = RenderOutput(
            image_job=ImageJob(
                should_generate=should_generate_image,
                prompt="A mysterious dungeon scene" if should_generate_image else "",
                model_label=ModelLabel.FAST,
                aspect_ratio="16:9",
                image_size="1024x576",
            )
            if should_generate_image
            else None
        )

        # ê²½ì œ ì¶œë ¥ (ë¹„ìš© ê³„ì‚°)
        turn_cost = CurrencyAmount(
            signal=turn_rng.randint(1, 5),
            memory_shard=0,
        )

        # ì”ì•¡ ê³„ì‚° (ìŒìˆ˜ ë°©ì§€ - RULE-005)
        balance_signal = max(0, turn_input.economy_snapshot.signal - turn_cost.signal)
        balance_shard = max(0, turn_input.economy_snapshot.memory_shard - turn_cost.memory_shard)

        economy_output = EconomyOutput(
            cost=turn_cost,
            balance_after=CurrencyAmount(signal=balance_signal, memory_shard=balance_shard),
        )

        # ì•ˆì „ ì¶œë ¥
        safety_output = SafetyOutput(blocked=False, message=None)

        # ì—ì´ì „íŠ¸ ì½˜ì†”
        agent_console = AgentConsole(
            current_phase=AgentPhase.COMMIT,
            badges=[
                ValidationBadge.SCHEMA_OK,
                ValidationBadge.ECONOMY_OK,
                ValidationBadge.SAFETY_OK,
                ValidationBadge.CONSISTENCY_OK,
            ],
            repair_count=0,
        )

        return TurnOutput(
            language=turn_input.language,
            narrative=narrative,
            ui=ui_output,
            world=world_delta,
            render=render_output,
            economy=economy_output,
            safety=safety_output,
            agent_console=agent_console,
        )

    def _generate_world_delta(
        self, is_korean: bool, rng: random.Random | None = None
    ) -> WorldDelta:
        """ì„¸ê³„ ìƒíƒœ ë³€í™” ìƒì„±.

        Args:
            is_korean: í•œêµ­ì–´ ì—¬ë¶€
            rng: ì‚¬ìš©í•  RNG (Noneì´ë©´ self._rng ì‚¬ìš©, U-048 í•˜ìœ„í˜¸í™˜)

        Returns:
            WorldDelta: ìƒì„±ëœ ì„¸ê³„ ìƒíƒœ ë³€í™”
        """
        # U-048: per-turn RNG ì§€ì› (í•˜ìœ„í˜¸í™˜ ìœ ì§€)
        use_rng = rng if rng is not None else self._rng

        # ê·œì¹™ ë³€ê²½ (20% í™•ë¥ )
        rules_changed: list[WorldRule] = []
        if use_rng.random() < 0.2:
            rules_changed.append(
                WorldRule(
                    id="rule_gravity",
                    label="ì¤‘ë ¥ ë°˜ì „" if is_korean else "Gravity Inversion",
                    description=(
                        "ì´ êµ¬ì—­ì—ì„œëŠ” ì¤‘ë ¥ì´ ë°˜ëŒ€ë¡œ ì‘ìš©í•©ë‹ˆë‹¤"
                        if is_korean
                        else "Gravity works in reverse in this area"
                    ),
                )
            )

        # ì¸ë²¤í† ë¦¬ ì¶”ê°€ (30% í™•ë¥ )
        inventory_added: list[str] = []
        if use_rng.random() < 0.3:
            items_ko = ["ë‚¡ì€ ì—´ì‡ ", "ì‹ ë¹„ë¡œìš´ êµ¬ìŠ¬", "ê³ ëŒ€ì˜ ë‘ë£¨ë§ˆë¦¬"]
            items_en = ["Old Key", "Mysterious Orb", "Ancient Scroll"]
            items = items_ko if is_korean else items_en
            inventory_added.append(use_rng.choice(items))

        # í€˜ìŠ¤íŠ¸ ì—…ë°ì´íŠ¸ (25% í™•ë¥ )
        quests_updated: list[Quest] = []
        if use_rng.random() < 0.25:
            quests_updated.append(
                Quest(
                    id="quest_explore",
                    label="ë¯¸ì§€ì˜ ì˜ì—­ íƒí—˜" if is_korean else "Explore Unknown Territory",
                    is_completed=use_rng.random() < 0.3,
                )
            )

        # ë©”ëª¨ë¦¬ í•€ (15% í™•ë¥ )
        memory_pins: list[MemoryPin] = []
        if use_rng.random() < 0.15:
            memory_pins.append(
                MemoryPin(
                    id="pin_1",
                    content="ì´ ì¥ì†Œì˜ ì´ë¦„ì€ 'ìŠí˜€ì§„ ì„±ì†Œ'"
                    if is_korean
                    else "This place is called 'Forgotten Sanctuary'",
                    cost=CurrencyAmount(signal=0, memory_shard=1),
                )
            )

        return WorldDelta(
            rules_changed=rules_changed,
            inventory_added=inventory_added,
            inventory_removed=[],
            quests_updated=quests_updated,
            relationships_changed=[],
            memory_pins=memory_pins,
        )

    def create_safe_fallback(
        self,
        language: Language,
        error_message: str | None = None,  # noqa: ARG002 - í•˜ìœ„ í˜¸í™˜ìš© (ì‹¤ì œë¡œ ì‚¬ìš©í•˜ì§€ ì•ŠìŒ)
        economy_snapshot: CurrencyAmount | None = None,
    ) -> TurnOutput:
        """ì•ˆì „í•œ í´ë°± TurnOutput ìƒì„± (RULE-004, RU-002-S1).

        ìŠ¤í‚¤ë§ˆ ê²€ì¦ ì‹¤íŒ¨ ì‹œ ë°˜í™˜í•  ì•ˆì „í•œ ê¸°ë³¸ ì‘ë‹µì…ë‹ˆë‹¤.
        í´ë°± ì‹œ economy.balance_afterëŠ” ì…ë ¥ ìŠ¤ëƒ…ìƒ·ì„ ê·¸ëŒ€ë¡œ ìœ ì§€í•©ë‹ˆë‹¤ (ë¹„ìš© 0, ì”ì•¡ ë³€í™” ì—†ìŒ).

        Note:
            ì´ ë©”ì„œë“œëŠ” fallback.create_safe_fallback SSOTë¡œ ìœ„ì„í•©ë‹ˆë‹¤ (RU-005-Q1).

        Args:
            language: ì‘ë‹µ ì–¸ì–´
            error_message: ì—ëŸ¬ ë©”ì‹œì§€ (í•˜ìœ„ í˜¸í™˜ìš©, ì‹¤ì œ ë¯¸ì‚¬ìš©)
            economy_snapshot: ìš”ì²­ ì§ì „ ì¬í™” ìŠ¤ëƒ…ìƒ· (í´ë°± ì‹œ ì”ì•¡ ìœ ì§€ìš©)

        Returns:
            TurnOutput: ì•ˆì „í•œ í´ë°± ì‘ë‹µ
        """
        # RU-005-Q1: fallback SSOTë¡œ ìœ„ì„
        return _create_safe_fallback(
            language=language,
            economy_snapshot=economy_snapshot,
            repair_count=1,  # Mockì—ì„œëŠ” ê¸°ë³¸ ë³µêµ¬ ì‹œë„ 1íšŒë¡œ í‘œì‹œ
            is_blocked=False,
        )
</file>

<file path="frontend/package.json">
{
  "name": "unknown-world-frontend",
  "private": true,
  "version": "0.0.0",
  "type": "module",
  "packageManager": "pnpm@10.27.0",
  "scripts": {
    "dev": "vite",
    "build": "tsc -b && vite build",
    "preview": "vite preview",
    "format": "prettier . --write",
    "format:check": "prettier . --check",
    "lint": "eslint .",
    "lint:fix": "eslint . --fix",
    "typecheck": "tsc --noEmit",
    "test": "vitest run",
    "test:watch": "vitest",
    "test:coverage": "vitest run --coverage"
  },
  "dependencies": {
    "@dnd-kit/core": "6.3.1",
    "@dnd-kit/sortable": "10.0.0",
    "@dnd-kit/utilities": "^3.2.2",
    "i18next": "25.7.3",
    "react": "19.2.3",
    "react-dom": "19.2.3",
    "react-i18next": "16.5.1",
    "zod": "4.3.4",
    "zustand": "5.0.9"
  },
  "devDependencies": {
    "@eslint/js": "9.39.2",
    "@testing-library/jest-dom": "^6.9.1",
    "@testing-library/react": "^16.3.1",
    "@types/node": "25.0.3",
    "@types/react": "19.2.7",
    "@types/react-dom": "19.2.3",
    "@vitejs/plugin-react": "5.1.2",
    "@vitest/coverage-v8": "^4.0.16",
    "eslint": "9.39.2",
    "eslint-config-prettier": "10.1.8",
    "eslint-plugin-react": "7.37.5",
    "eslint-plugin-react-hooks": "7.0.1",
    "eslint-plugin-unused-imports": "4.3.0",
    "globals": "16.5.0",
    "jsdom": "^27.4.0",
    "prettier": "3.7.4",
    "typescript": "5.9.3",
    "typescript-eslint": "8.51.0",
    "vite": "7.3.0",
    "vitest": "^4.0.16"
  },
  "pnpm": {
    "onlyBuiltDependencies": [
      "esbuild"
    ]
  }
}
</file>

<file path="frontend/src/stores/worldStore.ts">
/**
 * Unknown World - World/Session ìƒíƒœ ê´€ë¦¬ (Zustand) (RU-003-Q4).
 *
 * TurnOutput ë°˜ì˜ìœ¼ë¡œ ê°±ì‹ ë˜ëŠ” ì„¸ì…˜ ì›”ë“œ/UI ìƒíƒœë¥¼ SSOTë¡œ ê´€ë¦¬í•©ë‹ˆë‹¤.
 * App.tsxì˜ ë¡œì»¬ ìƒíƒœë¥¼ ì´ ìŠ¤í† ì–´ë¡œ ì´ë™í•˜ì—¬ ì±…ì„ ê²½ê³„ë¥¼ ëª…í™•íˆ í•©ë‹ˆë‹¤.
 *
 * ì„¤ê³„ ì›ì¹™:
 *   - RU-003 Q1 ê²°ì •: ë„ë©”ì¸ë³„ store ë¶„ë¦¬ (Option A)
 *   - RULE-005: Economy ì¸ë°”ë¦¬ì–¸íŠ¸ (ì”ì•¡ ìŒìˆ˜ ê¸ˆì§€)
 *   - RULE-006: ko/en i18n ì •ì±… ì¤€ìˆ˜
 *
 * í™•ì¥ (U-013):
 *   - Quest/Rules/MutationEvent ìƒíƒœ ì¶”ê°€
 *   - applyTurnOutputì—ì„œ quests_updated, rules_changed ë°˜ì˜
 *
 * ìˆœí™˜ import ë°©ì§€:
 *   - worldStore â†’ (actionDeckStore/inventoryStore) ë‹¨ë°©í–¥ë§Œ í—ˆìš©
 *   - ì—­ë°©í–¥ import ê¸ˆì§€
 *
 * @module stores/worldStore
 */

import { create } from 'zustand';
import type { TurnOutput, SceneObject, Quest, WorldRule } from '../schemas/turn';
import type { SceneCanvasState } from '../types/scene';
import { useActionDeckStore } from './actionDeckStore';
import { useInventoryStore, parseInventoryAdded } from './inventoryStore';
import { useEconomyStore } from './economyStore';

// =============================================================================
// íƒ€ì… ì •ì˜
// =============================================================================

/** ì¬í™” ìƒíƒœ */
export interface EconomyState {
  signal: number;
  memory_shard: number;
}

/** ë‚´ëŸ¬í‹°ë¸Œ ì—”íŠ¸ë¦¬ */
export interface NarrativeEntry {
  turn: number;
  text: string;
}

/**
 * ë£° ë³€í˜• ì´ë²¤íŠ¸ (U-013: Mutation Timeline)
 * ê·œì¹™ì´ ë³€ê²½ëœ ì‹œì ê³¼ ë‚´ìš©ì„ ê¸°ë¡í•©ë‹ˆë‹¤.
 */
export interface MutationEvent {
  /** ë³€í˜• ë°œìƒ í„´ */
  turn: number;
  /** ë³€í˜•ëœ ê·œì¹™ ID */
  ruleId: string;
  /** ë³€í˜• ìœ í˜•: ì¶”ê°€/ìˆ˜ì •/ì œê±° */
  type: 'added' | 'modified' | 'removed';
  /** ê·œì¹™ ë¼ë²¨ (í‘œì‹œìš©) */
  label: string;
  /** ê·œì¹™ ì„¤ëª… (ì„ íƒ) */
  description?: string;
  /** íƒ€ì„ìŠ¤íƒ¬í”„ */
  timestamp: number;
}

/** World/Session ìƒíƒœ */
export interface WorldState {
  /** ì¬í™” ìƒíƒœ (RULE-005) */
  economy: EconomyState;
  /** ì—°ê²° ìƒíƒœ */
  isConnected: boolean;
  /** Scene Canvas ìƒíƒœ (U-031) */
  sceneState: SceneCanvasState;
  /** Scene Objects (U-010: í•«ìŠ¤íŒŸ ì˜¤ë²„ë ˆì´) */
  sceneObjects: SceneObject[];
  /** ë‚´ëŸ¬í‹°ë¸Œ íˆìŠ¤í† ë¦¬ */
  narrativeEntries: NarrativeEntry[];
  /** í˜„ì¬ í„´ ì¹´ìš´íŠ¸ */
  turnCount: number;

  // ============ U-013: Quest + Rule Board í™•ì¥ ============

  /** í˜„ì¬ í€˜ìŠ¤íŠ¸/ëª©í‘œ ëª©ë¡ */
  quests: Quest[];
  /** í˜„ì¬ ì ìš© ì¤‘ì¸ ê·œì¹™ ëª©ë¡ */
  activeRules: WorldRule[];
  /** ë£° ë³€í˜• ì´ë²¤íŠ¸ íƒ€ì„ë¼ì¸ (ìµœì‹ ìˆœ) */
  mutationTimeline: MutationEvent[];
}

/** World Store ì•¡ì…˜ */
export interface WorldActions {
  /**
   * TurnOutputì„ ë°›ì•„ ëª¨ë“  ê´€ë ¨ ìƒíƒœë¥¼ ì—…ë°ì´íŠ¸í•©ë‹ˆë‹¤.
   * ì´ ë©”ì„œë“œê°€ TurnOutput ë°˜ì˜ì˜ SSOTì…ë‹ˆë‹¤.
   */
  applyTurnOutput: (output: TurnOutput) => void;

  /**
   * ì‹œìŠ¤í…œ ë‚´ëŸ¬í‹°ë¸Œë¥¼ ì¶”ê°€í•©ë‹ˆë‹¤ (í„´ ë¯¸ë°œìƒ í”¼ë“œë°±ìš©).
   * ë“œë¡­ ì‹¤íŒ¨ ë“± í„´ì„ ë°œìƒì‹œí‚¤ì§€ ì•ŠëŠ” í”¼ë“œë°±ì— ì‚¬ìš©í•©ë‹ˆë‹¤.
   */
  appendSystemNarrative: (text: string) => void;

  /** Scene ìƒíƒœ ì„¤ì • */
  setSceneState: (state: SceneCanvasState) => void;

  /** ì—°ê²° ìƒíƒœ ì„¤ì • */
  setConnected: (connected: boolean) => void;

  /** ê²½ì œ ìƒíƒœ ì„¤ì • (ì§ì ‘ ì¡°ì‘ìš©, ì¼ë°˜ì ìœ¼ë¡œ applyTurnOutput ì‚¬ìš©) */
  setEconomy: (economy: EconomyState) => void;

  /** Scene Objects ì„¤ì • (ì§ì ‘ ì¡°ì‘ìš©) */
  setSceneObjects: (objects: SceneObject[]) => void;

  /** ì´ˆê¸°í™” (ì´ˆê¸° ë‚´ëŸ¬í‹°ë¸Œ ë©”ì‹œì§€ í¬í•¨) */
  initialize: (welcomeMessage: string) => void;

  /** ìƒíƒœ ì™„ì „ ì´ˆê¸°í™” */
  reset: () => void;
}

export type WorldStore = WorldState & WorldActions;

// =============================================================================
// ì´ˆê¸° ìƒíƒœ
// =============================================================================

/**
 * ì´ˆê¸° ìƒíƒœë¥¼ ìƒì„±í•©ë‹ˆë‹¤.
 *
 * RU-004-Q5: ì´ˆê¸°ê°’ ì •ì±… SSOT
 *
 * ## ì¤‘ìš”: ì´ ê°’ë“¤ì€ "í”Œë ˆì´ ì „ placeholder"ì…ë‹ˆë‹¤.
 *
 * ì‹¤ì œ ê²Œì„ ì‹œì‘ ê°’ì€ í•­ìƒ ë‹¤ìŒ ì¤‘ í•˜ë‚˜ì—ì„œ ì£¼ì…ë©ë‹ˆë‹¤:
 * 1. í”„ë¡œí•„ ì´ˆê¸° SaveGame (startSessionFromProfile)
 * 2. ì €ì¥ëœ SaveGame ë³µì› (continueSession)
 *
 * profile_select ìƒíƒœì—ì„œëŠ” HUDê°€ ë…¸ì¶œë˜ì§€ ì•Šìœ¼ë¯€ë¡œ
 * ì´ placeholder ê°’ì´ í™”ë©´ì— í‘œì‹œë  ì¼ì€ ì—†ìŠµë‹ˆë‹¤.
 *
 * @see save/constants.ts#INITIAL_VALUE_POLICY
 * @see save/sessionLifecycle.ts
 */
function createInitialState(): WorldState {
  return {
    // RU-004-Q5: Placeholder - ì‹¤ì œ ê°’ì€ í”„ë¡œí•„/ì„¸ì´ë¸Œì—ì„œ ì£¼ì…ë¨
    economy: { signal: 100, memory_shard: 5 },
    isConnected: true,
    sceneState: { status: 'default', message: '' },
    sceneObjects: [],
    narrativeEntries: [],
    turnCount: 0,
    // U-013: Quest + Rule Board ì´ˆê¸° ìƒíƒœ
    quests: [],
    activeRules: [],
    mutationTimeline: [],
  };
}

// =============================================================================
// Zustand Store
// =============================================================================

/**
 * World/Session ìƒíƒœ ìŠ¤í† ì–´.
 *
 * TurnOutput ë°˜ì˜ì˜ SSOTë¡œ, App.tsxì˜ ë¡œì»¬ ìƒíƒœë¥¼ ëŒ€ì²´í•©ë‹ˆë‹¤.
 *
 * @example
 * ```tsx
 * // ì»´í¬ë„ŒíŠ¸ì—ì„œ ìƒíƒœ êµ¬ë…
 * const { economy, narrativeEntries } = useWorldStore();
 *
 * // TurnOutput ë°˜ì˜ (ìŠ¤íŠ¸ë¦¼ ì™„ë£Œ ì‹œ)
 * const applyTurnOutput = useWorldStore((state) => state.applyTurnOutput);
 * applyTurnOutput(turnOutput);
 *
 * // ì‹œìŠ¤í…œ í”¼ë“œë°± ì¶”ê°€ (ë“œë¡­ ì‹¤íŒ¨ ë“±)
 * const appendSystemNarrative = useWorldStore((state) => state.appendSystemNarrative);
 * appendSystemNarrative('ì•„ì´í…œì„ ì‚¬ìš©í•  ìˆ˜ ì—†ìŠµë‹ˆë‹¤.');
 * ```
 */
export const useWorldStore = create<WorldStore>((set, get) => ({
  // ì´ˆê¸° ìƒíƒœ
  ...createInitialState(),

  // ì•¡ì…˜

  applyTurnOutput: (output) => {
    const state = get();

    // 1. í„´ ì¹´ìš´íŠ¸ ì¦ê°€
    const newTurnCount = state.turnCount + 1;

    // 2. ë‚´ëŸ¬í‹°ë¸Œ ì¶”ê°€
    const newNarrativeEntry: NarrativeEntry = {
      turn: newTurnCount,
      text: output.narrative,
    };

    // 3. ê²½ì œ ìƒíƒœ ì—…ë°ì´íŠ¸ (RULE-005: balance_after ë°˜ì˜)
    const newEconomy: EconomyState = {
      signal: output.economy.balance_after.signal,
      memory_shard: output.economy.balance_after.memory_shard,
    };

    // 4. Scene Objects ì—…ë°ì´íŠ¸ (U-010: í•«ìŠ¤íŒŸ ì˜¤ë²„ë ˆì´)
    const newSceneObjects = output.ui.objects;

    // 5. Scene ìƒíƒœ ì „ì´ (RU-003-T1: Scene ì´ë¯¸ì§€ SSOT)
    // - output.ui.scene.image_urlì´ ì¡´ì¬í•˜ë©´ 'scene' ìƒíƒœë¡œ ì „í™˜
    // - ì—†ìœ¼ë©´ 'default' ìƒíƒœ ìœ ì§€
    // - safety.blockedì¸ ê²½ìš° 'blocked' ìƒíƒœë¡œ ì „í™˜
    let newSceneState: SceneCanvasState;
    if (output.safety.blocked) {
      newSceneState = {
        status: 'blocked',
        message: output.safety.message ?? undefined,
      };
    } else if (output.ui.scene?.image_url) {
      newSceneState = {
        status: 'scene',
        imageUrl: output.ui.scene.image_url,
        message: output.ui.scene.alt_text ?? undefined,
      };
    } else {
      newSceneState = {
        status: 'default',
        message: '',
      };
    }

    // 7. í•˜ìœ„ ìŠ¤í† ì–´ ì—…ë°ì´íŠ¸ (ìˆœí™˜ import ë°©ì§€: worldStore â†’ í•˜ìœ„ store ë‹¨ë°©í–¥)
    // Action Deck ì¹´ë“œ ì—…ë°ì´íŠ¸ (U-009)
    useActionDeckStore.getState().setCards(output.ui.action_deck.cards);

    // Inventory ì—…ë°ì´íŠ¸ (U-011)
    if (output.world.inventory_added.length > 0) {
      useInventoryStore.getState().addItems(parseInventoryAdded(output.world.inventory_added));
    }
    if (output.world.inventory_removed.length > 0) {
      useInventoryStore.getState().removeItems(output.world.inventory_removed);
    }

    // Economy Store ì—…ë°ì´íŠ¸ (U-014: Ledger ê¸°ë¡)
    const economyStore = useEconomyStore.getState();
    economyStore.addLedgerEntry({
      turnId: newTurnCount,
      reason: output.narrative.slice(0, 50), // ë‚´ëŸ¬í‹°ë¸Œ ì• 50ìë¥¼ ì‚¬ìœ ë¡œ ì‚¬ìš©
      cost: output.economy.cost,
      balanceAfter: output.economy.balance_after,
      modelLabel: output.agent_console.badges.includes('schema_ok') ? 'QUALITY' : 'FAST',
    });
    // ì”ì•¡ ë¶€ì¡± ìƒíƒœ ì—…ë°ì´íŠ¸
    economyStore.updateBalanceLowStatus(newEconomy);

    // 6. Quest ìƒíƒœ ì—…ë°ì´íŠ¸ (U-013)
    // quests_updatedëŠ” ì „ì²´ í€˜ìŠ¤íŠ¸ ëª©ë¡ì´ ì•„ë‹Œ "ì—…ë°ì´íŠ¸ëœ" í€˜ìŠ¤íŠ¸ë§Œ í¬í•¨
    // ê¸°ì¡´ í€˜ìŠ¤íŠ¸ë¥¼ ì—…ë°ì´íŠ¸í•˜ê±°ë‚˜ ìƒˆ í€˜ìŠ¤íŠ¸ë¥¼ ì¶”ê°€
    const newQuests = [...state.quests];
    for (const updatedQuest of output.world.quests_updated) {
      const existingIndex = newQuests.findIndex((q) => q.id === updatedQuest.id);
      if (existingIndex >= 0) {
        // ê¸°ì¡´ í€˜ìŠ¤íŠ¸ ì—…ë°ì´íŠ¸
        newQuests[existingIndex] = updatedQuest;
      } else {
        // ìƒˆ í€˜ìŠ¤íŠ¸ ì¶”ê°€
        newQuests.push(updatedQuest);
      }
    }

    // 7. Rules ìƒíƒœ ì—…ë°ì´íŠ¸ + Mutation Timeline ê¸°ë¡ (U-013)
    const newActiveRules = [...state.activeRules];
    const newMutationEvents: MutationEvent[] = [];
    const now = Date.now();

    for (const changedRule of output.world.rules_changed) {
      const existingIndex = newActiveRules.findIndex((r) => r.id === changedRule.id);
      if (existingIndex >= 0) {
        // ê¸°ì¡´ ê·œì¹™ ìˆ˜ì •
        newActiveRules[existingIndex] = changedRule;
        newMutationEvents.push({
          turn: newTurnCount,
          ruleId: changedRule.id,
          type: 'modified',
          label: changedRule.label,
          description: changedRule.description ?? undefined,
          timestamp: now,
        });
      } else {
        // ìƒˆ ê·œì¹™ ì¶”ê°€
        newActiveRules.push(changedRule);
        newMutationEvents.push({
          turn: newTurnCount,
          ruleId: changedRule.id,
          type: 'added',
          label: changedRule.label,
          description: changedRule.description ?? undefined,
          timestamp: now,
        });
      }
    }

    // íƒ€ì„ë¼ì¸ì— ìƒˆ ì´ë²¤íŠ¸ ì¶”ê°€ (ìµœì‹ ìˆœ ì •ë ¬)
    const updatedTimeline = [...newMutationEvents, ...state.mutationTimeline];

    // 8. ìƒíƒœ ì—…ë°ì´íŠ¸ (RU-003-T1: sceneState í¬í•¨, U-013: quest/rules)
    set({
      turnCount: newTurnCount,
      narrativeEntries: [...state.narrativeEntries, newNarrativeEntry],
      economy: newEconomy,
      sceneObjects: newSceneObjects,
      sceneState: newSceneState,
      // U-013 í™•ì¥
      quests: newQuests,
      activeRules: newActiveRules,
      mutationTimeline: updatedTimeline,
    });

    // === í–¥í›„ í™•ì¥ ìŠ¬ë¡¯ (RU-003-Q4 Step 4) ===
    // TODO: output.world.memory_pins â†’ Memory Pin íŒ¨ë„ ì—…ë°ì´íŠ¸
  },

  appendSystemNarrative: (text) => {
    set((state) => ({
      narrativeEntries: [
        ...state.narrativeEntries,
        {
          turn: state.turnCount, // í˜„ì¬ í„´ìœ¼ë¡œ ê¸°ë¡ (í„´ ì¦ê°€ ì—†ìŒ)
          text,
        },
      ],
    }));
  },

  setSceneState: (sceneState) => {
    set({ sceneState });
  },

  setConnected: (isConnected) => {
    set({ isConnected });
  },

  setEconomy: (economy) => {
    set({ economy });
  },

  setSceneObjects: (sceneObjects) => {
    set({ sceneObjects });
  },

  initialize: (welcomeMessage) => {
    set({
      ...createInitialState(),
      narrativeEntries: [{ turn: 0, text: welcomeMessage }],
    });
  },

  reset: () => {
    set(createInitialState());
  },
}));

// =============================================================================
// ì…€ë ‰í„° (ì„±ëŠ¥ ìµœì í™”ìš©)
// =============================================================================

/** ê²½ì œ ìƒíƒœ ì…€ë ‰í„° */
export const selectEconomy = (state: WorldStore) => state.economy;

/** Signal ì”ì•¡ ì…€ë ‰í„° */
export const selectSignal = (state: WorldStore) => state.economy.signal;

/** Memory Shard ì”ì•¡ ì…€ë ‰í„° */
export const selectMemoryShard = (state: WorldStore) => state.economy.memory_shard;

/** ì—°ê²° ìƒíƒœ ì…€ë ‰í„° */
export const selectIsConnected = (state: WorldStore) => state.isConnected;

/** Scene ìƒíƒœ ì…€ë ‰í„° */
export const selectSceneState = (state: WorldStore) => state.sceneState;

/** Scene Objects ì…€ë ‰í„° */
export const selectSceneObjects = (state: WorldStore) => state.sceneObjects;

/** ë‚´ëŸ¬í‹°ë¸Œ ì—”íŠ¸ë¦¬ ì…€ë ‰í„° */
export const selectNarrativeEntries = (state: WorldStore) => state.narrativeEntries;

/** í„´ ì¹´ìš´íŠ¸ ì…€ë ‰í„° */
export const selectTurnCount = (state: WorldStore) => state.turnCount;

// ============ U-013: Quest + Rule Board ì…€ë ‰í„° ============

/** í€˜ìŠ¤íŠ¸ ëª©ë¡ ì…€ë ‰í„° */
export const selectQuests = (state: WorldStore) => state.quests;

/** í™œì„± ê·œì¹™ ëª©ë¡ ì…€ë ‰í„° */
export const selectActiveRules = (state: WorldStore) => state.activeRules;

/** ë®¤í…Œì´ì…˜ íƒ€ì„ë¼ì¸ ì…€ë ‰í„° */
export const selectMutationTimeline = (state: WorldStore) => state.mutationTimeline;

/** ì§„í–‰ ì¤‘ì¸ í€˜ìŠ¤íŠ¸ ì…€ë ‰í„° */
export const selectActiveQuests = (state: WorldStore) =>
  state.quests.filter((q) => !q.is_completed);

/** ì™„ë£Œëœ í€˜ìŠ¤íŠ¸ ì…€ë ‰í„° */
export const selectCompletedQuests = (state: WorldStore) =>
  state.quests.filter((q) => q.is_completed);
</file>

<file path="frontend/src/turn/turnRunner.ts">
/**
 * Unknown World - Turn Runner ëª¨ë“ˆ
 *
 * RU-003-Q3: Turn ì‹¤í–‰/ìŠ¤íŠ¸ë¦¬ë° ê²°í•©ì„ App.tsxì—ì„œ ë¶„ë¦¬í•˜ì—¬
 * "ë ˆì´ì•„ì›ƒ + ì´ë²¤íŠ¸ ë¼ìš°íŒ…"ê³¼ "ì˜¤ì¼€ìŠ¤íŠ¸ë ˆì´ì…˜"ì„ ëª…í™•íˆ ë¶„ë¦¬í•©ë‹ˆë‹¤.
 *
 * ì±…ì„:
 *   - TurnInput ìƒì„± (ì–¸ì–´/í´ë¦­/ë“œë¡­/í´ë¼ì´ì–¸íŠ¸ ì •ë³´/ì¬í™” ìŠ¤ëƒ…ìƒ·)
 *   - ìŠ¤íŠ¸ë¦¼ ì‹œì‘/ì·¨ì†Œ/ì½œë°± ë¼ìš°íŒ…
 *   - agentStore/worldStoreë¡œ ì´ë²¤íŠ¸ ë¶„ë°°
 *
 * ì„¤ê³„ ì›ì¹™:
 *   - RULE-002: ì±„íŒ… ì•±ì´ ì•„ë‹Œ ìƒíƒœ ê¸°ë°˜ ê²Œì„ ì‹œìŠ¤í…œ
 *   - RULE-003/004: êµ¬ì¡°í™” ì¶œë ¥ + ê²€ì¦/ë³µêµ¬
 *   - RULE-006: ko/en i18n ì •ì±… ì¤€ìˆ˜
 *
 * @module turn/turnRunner
 */

import type { TurnInput, DropInput, Language } from '../schemas/turn';
import type { HotspotClickData } from '../components/SceneCanvas';
import { startTurnStream, type StreamCallbacks } from '../api/turnStream';
import { useAgentStore } from '../stores/agentStore';
import { useWorldStore } from '../stores/worldStore';

// =============================================================================
// íƒ€ì… ì •ì˜
// =============================================================================

/** TurnInput ìƒì„±ì„ ìœ„í•œ íŒŒë¼ë¯¸í„° */
export interface BuildTurnInputParams {
  /** ì‚¬ìš©ì ì…ë ¥ í…ìŠ¤íŠ¸ */
  text: string;
  /** ì•¡ì…˜ ì¹´ë“œ ID (ì„ íƒ) */
  actionId?: string;
  /** í•«ìŠ¤íŒŸ í´ë¦­ ë°ì´í„° (U-010) */
  click?: HotspotClickData;
  /** ë“œë¡­ ë°ì´í„° (U-012) */
  drop?: DropInput;
  /** ì¬í™” ìŠ¤ëƒ…ìƒ· */
  economySnapshot: { signal: number; memory_shard: number };
  /** UI í…Œë§ˆ */
  theme: 'dark' | 'light';
  /** U-044: ì„¸ì…˜ ì–¸ì–´ (ì™¸ë¶€ ì£¼ì…, SSOT) */
  language: Language;
}

/** Turn ì‹¤í–‰ì„ ìœ„í•œ íŒŒë¼ë¯¸í„° (Appì—ì„œ í˜¸ì¶œ ì‹œ ì‚¬ìš©) */
export interface RunTurnParams {
  /** ì‚¬ìš©ì ì…ë ¥ í…ìŠ¤íŠ¸ */
  text: string;
  /** ì•¡ì…˜ ì¹´ë“œ ID (ì„ íƒ) */
  actionId?: string;
  /** í•«ìŠ¤íŒŸ í´ë¦­ ë°ì´í„° (U-010) */
  click?: HotspotClickData;
  /** ë“œë¡­ ë°ì´í„° (U-012) */
  drop?: DropInput;
}

/** Turn Runner ì¸í„°í˜ì´ìŠ¤ */
export interface TurnRunner {
  /** í„´ ì‹¤í–‰ (ìŠ¤íŠ¸ë¦¼ ì‹œì‘) */
  runTurn: (params: RunTurnParams) => void;
  /** ìŠ¤íŠ¸ë¦¼ ì·¨ì†Œ */
  cancel: () => void;
}

// =============================================================================
// TurnInput ìƒì„±
// =============================================================================

/**
 * TurnInputì„ ìƒì„±í•©ë‹ˆë‹¤.
 *
 * U-044: ì–¸ì–´ëŠ” ì™¸ë¶€ì—ì„œ ì£¼ì…ë°›ì•„ SSOT ìœ ì§€ (getResolvedLanguage() ì§ì ‘ í˜¸ì¶œ ì œê±°).
 * í´ë¦­, ë“œë¡­, í´ë¼ì´ì–¸íŠ¸ ì •ë³´, ì¬í™” ìŠ¤ëƒ…ìƒ·ì„ ì¡°í•©í•˜ì—¬
 * ì„œë²„ë¡œ ì „ì†¡í•  TurnInputì„ ìƒì„±í•©ë‹ˆë‹¤.
 */
export function buildTurnInput(params: BuildTurnInputParams): TurnInput {
  const { text, actionId, click, drop, economySnapshot, theme, language } = params;

  return {
    language,
    text,
    action_id: actionId ?? null,
    // U-010: í•«ìŠ¤íŒŸ í´ë¦­ ë°ì´í„° í¬í•¨ (Q1: Option B)
    click: click
      ? {
          object_id: click.object_id,
          box_2d: click.box_2d,
        }
      : null,
    // U-012: ì•„ì´í…œ ë“œë¡­ ë°ì´í„° í¬í•¨ (Q1: Option B - target_box_2d í¬í•¨)
    drop: drop ?? null,
    client: {
      viewport_w: window.innerWidth,
      viewport_h: window.innerHeight,
      theme,
    },
    economy_snapshot: economySnapshot,
  };
}

// =============================================================================
// Turn Runner ìƒì„±
// =============================================================================

/**
 * Turn Runnerë¥¼ ìƒì„±í•©ë‹ˆë‹¤.
 *
 * RU-003-Q3: Appì—ì„œ Turn Runner ì¸ìŠ¤í„´ìŠ¤ë¥¼ ìƒì„±í•˜ì—¬ ì‚¬ìš©í•©ë‹ˆë‹¤.
 * U-044: ì„¸ì…˜ ì–¸ì–´ë¥¼ ì™¸ë¶€ì—ì„œ ì£¼ì…ë°›ì•„ TurnInput ìƒì„± ì‹œ SSOT ìœ ì§€.
 * ìŠ¤íŠ¸ë¦¼ ì½œë°±ì€ agentStoreì™€ worldStoreë¡œ ë¼ìš°íŒ…ë©ë‹ˆë‹¤.
 *
 * @param deps - ì˜ì¡´ì„± (i18n ë²ˆì—­ í•¨ìˆ˜, í…Œë§ˆ, ì„¸ì…˜ ì–¸ì–´)
 * @returns Turn Runner ì¸í„°í˜ì´ìŠ¤
 *
 * @example
 * ```tsx
 * // App.tsxì—ì„œ ì‚¬ìš©
 * const runner = useMemo(() => createTurnRunner({
 *   t,
 *   theme: 'dark',
 *   language: sessionLanguage, // U-044: ì„¸ì…˜ ì–¸ì–´ SSOT
 * }), [t, sessionLanguage]);
 *
 * runner.runTurn({ text: 'hello' });
 * ```
 */
export function createTurnRunner(deps: {
  /** i18n ë²ˆì—­ í•¨ìˆ˜ */
  t: (key: string, options?: Record<string, unknown>) => string;
  /** UI í…Œë§ˆ */
  theme: 'dark' | 'light';
  /** U-044: ì„¸ì…˜ ì–¸ì–´ (SSOT) */
  language: Language;
}): TurnRunner {
  const { t, theme, language } = deps;

  // ì·¨ì†Œ í•¨ìˆ˜ ì €ì¥
  let cancelFn: (() => void) | null = null;

  /**
   * í„´ì„ ì‹¤í–‰í•©ë‹ˆë‹¤.
   */
  const runTurn = (params: RunTurnParams): void => {
    // ìŠ¤íŠ¸ë¦¬ë° ì¤‘ì´ë©´ ë¬´ì‹œ
    const isStreaming = useAgentStore.getState().isStreaming;
    if (isStreaming) return;

    // Store ì•¡ì…˜ ê°€ì ¸ì˜¤ê¸° (í´ë¡œì € ì™¸ë¶€ì—ì„œ í˜¸ì¶œ ì‹œì ì— ìµœì‹  ìƒíƒœ ì°¸ì¡°)
    const agentStore = useAgentStore.getState();
    const worldStore = useWorldStore.getState();

    // ì¬í™” ìŠ¤ëƒ…ìƒ· ê°€ì ¸ì˜¤ê¸°
    const economySnapshot = worldStore.economy;

    // TurnInput ìƒì„± (U-044: ì£¼ì…ëœ ì„¸ì…˜ ì–¸ì–´ ì‚¬ìš©)
    const turnInput = buildTurnInput({
      text:
        params.text ||
        (params.actionId ? t('action.card_select', { cardId: params.actionId }) : ''),
      actionId: params.actionId,
      click: params.click,
      drop: params.drop,
      economySnapshot,
      theme,
      language,
    });

    // Agent Store ì‹œì‘
    agentStore.startStream();

    // Scene Canvasë¥¼ ë¡œë”© ìƒíƒœë¡œ ì „í™˜ (U-031)
    worldStore.setSceneState({ status: 'loading', message: t('scene.status.syncing') });

    // ìŠ¤íŠ¸ë¦¼ ì½œë°± ì„¤ì • (RU-003-Q3: agentStore + worldStoreë¡œ ë¼ìš°íŒ…)
    // RU-003-T1: sceneState ì „ì´ëŠ” worldStore.applyTurnOutputì—ì„œ SSOTë¡œ ì²˜ë¦¬
    const callbacks: StreamCallbacks = {
      // Stage/Badges/NarrativeDelta â†’ agentStoreë¡œë§Œ ì „ë‹¬
      onStage: (event) => {
        useAgentStore.getState().handleStage(event);
      },
      onBadges: (event) => {
        useAgentStore.getState().handleBadges(event);
      },
      onNarrativeDelta: (event) => {
        useAgentStore.getState().handleNarrativeDelta(event);
      },
      // Final â†’ agentStore.handleFinal + worldStore.applyTurnOutput
      onFinal: (event) => {
        useAgentStore.getState().handleFinal(event);
        // RU-003-Q4: TurnOutput ë°˜ì˜ SSOT
        useWorldStore.getState().applyTurnOutput(event.data);
        // RU-003-S1: ì„±ê³µì ì¸ final ìˆ˜ì‹  ì‹œ ì—°ê²° ìƒíƒœ ë‚™ê´€ì  ë³µêµ¬
        useWorldStore.getState().setConnected(true);
      },
      // Error â†’ agentStore.handleError + worldStore ìƒíƒœ ë³µêµ¬
      onError: (event) => {
        useAgentStore.getState().handleError(event);
        useWorldStore.getState().setConnected(false);
        // Scene Canvasë¥¼ ì˜¤í”„ë¼ì¸/ì—ëŸ¬ ìƒíƒœë¡œ ì „í™˜ (U-031)
        const errorCode = event.code;
        if (errorCode === 'SAFETY_BLOCKED') {
          useWorldStore.getState().setSceneState({ status: 'blocked', message: event.message });
        } else if (errorCode === 'INSUFFICIENT_BALANCE') {
          useWorldStore.getState().setSceneState({ status: 'low_signal', message: event.message });
        } else {
          useWorldStore.getState().setSceneState({ status: 'offline', message: event.message });
        }
      },
      // Complete â†’ agentStore.completeStream
      // RU-003-T1: sceneState ì „ì´ëŠ” worldStore.applyTurnOutputì—ì„œ SSOTë¡œ ì²˜ë¦¬
      // - ì„±ê³µ ì‹œ: onFinal â†’ applyTurnOutputì—ì„œ ui.scene.image_url ê¸°ë°˜ìœ¼ë¡œ ì„¤ì •
      // - ì—ëŸ¬ ì‹œ: onErrorì—ì„œ ì´ë¯¸ offline/blocked/low_signalìœ¼ë¡œ ì„¤ì •ë¨
      onComplete: () => {
        useAgentStore.getState().completeStream();
        // RU-003-T1: sceneStateëŠ” applyTurnOutput(ì„±ê³µ) ë˜ëŠ” onError(ì‹¤íŒ¨)ì—ì„œ ì´ë¯¸ ì„¤ì •ë¨
        // ì—¬ê¸°ì„œ ì¶”ê°€ë¡œ ì„¤ì •í•˜ë©´ applyTurnOutputì˜ ì„¤ì •ì„ ë®ì–´ì“°ê²Œ ë˜ë¯€ë¡œ ì œê±°
      },
    };

    // ìŠ¤íŠ¸ë¦¼ ì‹œì‘
    cancelFn = startTurnStream(turnInput, callbacks);
  };

  /**
   * ìŠ¤íŠ¸ë¦¼ì„ ì·¨ì†Œí•©ë‹ˆë‹¤.
   *
   * ì¶”í›„ Cancel/Pause/Autopilot UXë¥¼ ìœ„í•œ ê¸°ë³¸ ê³¨ê²©ì…ë‹ˆë‹¤.
   * í˜„ì¬ executeTurnStreamì€ Abort ì‹œ onCompleteë¥¼ í˜¸ì¶œí•˜ì§€ ì•Šìœ¼ë¯€ë¡œ,
   * Cancel ë²„íŠ¼ì„ ë„£ì„ ê³„íšì´ë¼ë©´ "ì·¨ì†Œ ì‹œ UI ë³µêµ¬ ì •ì±…"ì„ ë³„ë„ë¡œ ëª…ì‹œí•´ì•¼ í•©ë‹ˆë‹¤.
   */
  const cancel = (): void => {
    cancelFn?.();
    cancelFn = null;
  };

  return {
    runTurn,
    cancel,
  };
}

// =============================================================================
// React Hook (ì„ íƒì  ì‚¬ìš©)
// =============================================================================

/**
 * Turn Runnerë¥¼ React ì»´í¬ë„ŒíŠ¸ì—ì„œ ì‚¬ìš©í•˜ê¸° ìœ„í•œ í›….
 *
 * U-044: ì„¸ì…˜ ì–¸ì–´ë¥¼ ì™¸ë¶€ì—ì„œ ì£¼ì…ë°›ì•„ TurnInput ìƒì„± ì‹œ SSOT ìœ ì§€.
 *
 * @param deps - ì˜ì¡´ì„± (i18n ë²ˆì—­ í•¨ìˆ˜, í…Œë§ˆ, ì„¸ì…˜ ì–¸ì–´)
 * @returns Turn Runner ì¸í„°í˜ì´ìŠ¤ ë° ì·¨ì†Œ íš¨ê³¼
 *
 * @example
 * ```tsx
 * // ì»´í¬ë„ŒíŠ¸ì—ì„œ ì‚¬ìš©
 * const { runTurn, cancel } = useTurnRunner({
 *   t,
 *   theme: 'dark',
 *   language: sessionLanguage, // U-044: ì„¸ì…˜ ì–¸ì–´ SSOT
 * });
 * ```
 */
import { useCallback, useEffect, useRef } from 'react';

export function useTurnRunner(deps: {
  t: (key: string, options?: Record<string, unknown>) => string;
  theme: 'dark' | 'light';
  /** U-044: ì„¸ì…˜ ì–¸ì–´ (SSOT) */
  language: Language;
}): TurnRunner {
  const { t, theme, language } = deps;

  // ì·¨ì†Œ í•¨ìˆ˜ ì €ì¥ ref
  const cancelFnRef = useRef<(() => void) | null>(null);

  // runTurnì„ useCallbackìœ¼ë¡œ ì •ì˜
  const runTurn = useCallback(
    (params: RunTurnParams): void => {
      // ìŠ¤íŠ¸ë¦¬ë° ì¤‘ì´ë©´ ë¬´ì‹œ
      const isStreaming = useAgentStore.getState().isStreaming;
      if (isStreaming) return;

      // Store ì•¡ì…˜ ê°€ì ¸ì˜¤ê¸°
      const agentStore = useAgentStore.getState();
      const worldStore = useWorldStore.getState();

      // ì¬í™” ìŠ¤ëƒ…ìƒ· ê°€ì ¸ì˜¤ê¸°
      const economySnapshot = worldStore.economy;

      // TurnInput ìƒì„± (U-044: ì£¼ì…ëœ ì„¸ì…˜ ì–¸ì–´ ì‚¬ìš©)
      const turnInput = buildTurnInput({
        text:
          params.text ||
          (params.actionId ? t('action.card_select', { cardId: params.actionId }) : ''),
        actionId: params.actionId,
        click: params.click,
        drop: params.drop,
        economySnapshot,
        theme,
        language,
      });

      // Agent Store ì‹œì‘
      agentStore.startStream();

      // Scene Canvasë¥¼ ë¡œë”© ìƒíƒœë¡œ ì „í™˜ (U-031)
      worldStore.setSceneState({ status: 'loading', message: t('scene.status.syncing') });

      // ìŠ¤íŠ¸ë¦¼ ì½œë°± ì„¤ì • (RU-003-Q3: agentStore + worldStoreë¡œ ë¼ìš°íŒ…)
      // RU-003-T1: sceneState ì „ì´ëŠ” worldStore.applyTurnOutputì—ì„œ SSOTë¡œ ì²˜ë¦¬
      const callbacks: StreamCallbacks = {
        onStage: (event) => {
          useAgentStore.getState().handleStage(event);
        },
        onBadges: (event) => {
          useAgentStore.getState().handleBadges(event);
        },
        onNarrativeDelta: (event) => {
          useAgentStore.getState().handleNarrativeDelta(event);
        },
        onFinal: (event) => {
          useAgentStore.getState().handleFinal(event);
          useWorldStore.getState().applyTurnOutput(event.data);
          // RU-003-S1: ì„±ê³µì ì¸ final ìˆ˜ì‹  ì‹œ ì—°ê²° ìƒíƒœ ë‚™ê´€ì  ë³µêµ¬
          useWorldStore.getState().setConnected(true);
        },
        onError: (event) => {
          useAgentStore.getState().handleError(event);
          useWorldStore.getState().setConnected(false);
          // Scene Canvasë¥¼ ì˜¤í”„ë¼ì¸/ì—ëŸ¬ ìƒíƒœë¡œ ì „í™˜ (U-031)
          const errorCode = event.code;
          if (errorCode === 'SAFETY_BLOCKED') {
            useWorldStore.getState().setSceneState({ status: 'blocked', message: event.message });
          } else if (errorCode === 'INSUFFICIENT_BALANCE') {
            useWorldStore
              .getState()
              .setSceneState({ status: 'low_signal', message: event.message });
          } else {
            useWorldStore.getState().setSceneState({ status: 'offline', message: event.message });
          }
        },
        // Complete â†’ agentStore.completeStream
        // RU-003-T1: sceneState ì „ì´ëŠ” worldStore.applyTurnOutputì—ì„œ SSOTë¡œ ì²˜ë¦¬
        // - ì„±ê³µ ì‹œ: onFinal â†’ applyTurnOutputì—ì„œ ui.scene.image_url ê¸°ë°˜ìœ¼ë¡œ ì„¤ì •
        // - ì—ëŸ¬ ì‹œ: onErrorì—ì„œ ì´ë¯¸ offline/blocked/low_signalìœ¼ë¡œ ì„¤ì •ë¨
        onComplete: () => {
          useAgentStore.getState().completeStream();
          // RU-003-T1: sceneStateëŠ” applyTurnOutput(ì„±ê³µ) ë˜ëŠ” onError(ì‹¤íŒ¨)ì—ì„œ ì´ë¯¸ ì„¤ì •ë¨
          // ì—¬ê¸°ì„œ ì¶”ê°€ë¡œ ì„¤ì •í•˜ë©´ applyTurnOutputì˜ ì„¤ì •ì„ ë®ì–´ì“°ê²Œ ë˜ë¯€ë¡œ ì œê±°
        },
      };

      // ìŠ¤íŠ¸ë¦¼ ì‹œì‘ ë° ì·¨ì†Œ í•¨ìˆ˜ ì €ì¥
      cancelFnRef.current = startTurnStream(turnInput, callbacks);
    },
    [t, theme, language],
  );

  // cancel í•¨ìˆ˜
  const cancel = useCallback((): void => {
    cancelFnRef.current?.();
    cancelFnRef.current = null;
  }, []);

  // ì»´í¬ë„ŒíŠ¸ ì–¸ë§ˆìš´íŠ¸ ì‹œ ìŠ¤íŠ¸ë¦¼ ì·¨ì†Œ
  useEffect(() => {
    return () => {
      cancelFnRef.current?.();
    };
  }, []);

  return { runTurn, cancel };
}
</file>

<file path="backend/src/unknown_world/services/image_generation.py">
"""Unknown World - ì´ë¯¸ì§€ ìƒì„± ì„œë¹„ìŠ¤.

ì´ ëª¨ë“ˆì€ Gemini ì´ë¯¸ì§€ ìƒì„± ëª¨ë¸ì„ í˜¸ì¶œí•˜ê³  ê²°ê³¼ë¥¼ ë¡œì»¬ì— ì €ì¥í•˜ëŠ” ì„œë¹„ìŠ¤ì…ë‹ˆë‹¤.
í…ìŠ¤íŠ¸ í„´ì˜ TTFBë¥¼ ë¸”ë¡œí‚¹í•˜ì§€ ì•Šë„ë¡ ë¶„ë¦¬ëœ ê²½ë¡œë¡œ ë™ì‘í•©ë‹ˆë‹¤.

ì„¤ê³„ ì›ì¹™:
    - RULE-004: ì‹¤íŒ¨ ì‹œ ì•ˆì „í•œ í´ë°± ì œê³µ (should_generate=false)
    - RULE-008: í…ìŠ¤íŠ¸ ìš°ì„  + Lazy ì´ë¯¸ì§€ ì›ì¹™
    - RULE-010: ì´ë¯¸ì§€ ëª¨ë¸ ID ê³ ì • (gemini-3-pro-image-preview)
    - RULE-007: í”„ë¡¬í”„íŠ¸ ì›ë¬¸ ë…¸ì¶œ ê¸ˆì§€

í˜ì–´ë§ ì§ˆë¬¸ ê²°ì •:
    - Q1: Option A (ë¡œì»¬ íŒŒì¼ë¡œ ì €ì¥ í›„ image_urlë¡œ ì„œë¹™)

ì°¸ì¡°:
    - vibe/tech-stack.md (ëª¨ë¸ ID ê³ ì •)
    - vibe/unit-plans/U-019[Mvp].md
    - .cursor/rules/20-backend-orchestrator.mdc
"""

from __future__ import annotations

import base64
import hashlib
import logging
import os
import uuid
from dataclasses import dataclass
from datetime import UTC, datetime
from enum import StrEnum
from pathlib import Path
from typing import TYPE_CHECKING, Any

from pydantic import BaseModel, ConfigDict, Field

from unknown_world.config.models import MODEL_IMAGE, ModelLabel, get_model_id
from unknown_world.models.turn import Language
from unknown_world.orchestrator.prompt_loader import load_image_prompt
from unknown_world.storage.paths import (
    LEGACY_OUTPUT_DIR,
    build_image_url,
    get_generated_images_dir,
)
from unknown_world.storage.validation import (
    DEFAULT_ASPECT_RATIO,
    DEFAULT_IMAGE_SIZE,
    SUPPORTED_IMAGE_SIZES,
    validate_image_generation_request,
)

if TYPE_CHECKING:
    from google.genai import Client

# =============================================================================
# ë¡œê±° ì„¤ì • (í”„ë¡¬í”„íŠ¸/ë¹„ë°€ì •ë³´ ë…¸ì¶œ ê¸ˆì§€ - RULE-007/008)
# =============================================================================

logger = logging.getLogger(__name__)


# =============================================================================
# ìƒìˆ˜ ì •ì˜
# =============================================================================

# í•˜ìœ„ í˜¸í™˜ì„±ì„ ìœ„í•œ ë ˆê±°ì‹œ ê²½ë¡œ ë³„ì¹­ (RU-006-Q5)
# ì‹ ê·œ ì½”ë“œì—ì„œëŠ” get_generated_images_dir() ì‚¬ìš© ê¶Œì¥
DEFAULT_OUTPUT_DIR = LEGACY_OUTPUT_DIR

# í˜¸í™˜ì„±ì„ ìœ„í•œ ìƒìˆ˜ ë³„ì¹­
SUPPORTED_SIZES = SUPPORTED_IMAGE_SIZES
"""ì§€ì› ì´ë¯¸ì§€ í¬ê¸° (í˜¸í™˜ì„± ë³„ì¹­)."""

DEFAULT_SIZE = DEFAULT_IMAGE_SIZE
"""ê¸°ë³¸ ì´ë¯¸ì§€ í¬ê¸° (í˜¸í™˜ì„± ë³„ì¹­)."""


class ImageGenerationStatus(StrEnum):
    """ì´ë¯¸ì§€ ìƒì„± ìƒíƒœ."""

    PENDING = "pending"
    """ìƒì„± ëŒ€ê¸° ì¤‘"""

    GENERATING = "generating"
    """ìƒì„± ì¤‘"""

    COMPLETED = "completed"
    """ìƒì„± ì™„ë£Œ"""

    FAILED = "failed"
    """ìƒì„± ì‹¤íŒ¨"""

    SKIPPED = "skipped"
    """ìƒì„± ê±´ë„ˆëœ€ (ì”ì•¡ ë¶€ì¡± ë“±)"""


# =============================================================================
# ìš”ì²­/ì‘ë‹µ Pydantic ëª¨ë¸
# =============================================================================


class ImageGenerationRequest(BaseModel):
    """ì´ë¯¸ì§€ ìƒì„± ìš”ì²­.

    TurnOutputì˜ render.image_jobê³¼ ì •í•©ë˜ë„ë¡ í•„ë“œë¥¼ ì„¤ê³„í•©ë‹ˆë‹¤.

    Attributes:
        prompt: ì´ë¯¸ì§€ ìƒì„± í”„ë¡¬í”„íŠ¸ (í•„ìˆ˜)
        aspect_ratio: ê°€ë¡œì„¸ë¡œ ë¹„ìœ¨ (ì˜ˆ: "16:9", "1:1")
        image_size: ì´ë¯¸ì§€ í¬ê¸° (ì˜ˆ: "1024x1024")
        reference_image_ids: ì°¸ì¡° ì´ë¯¸ì§€ ID ëª©ë¡ (ì„ íƒ, í¸ì§‘ìš©)
        session_id: ì„¸ì…˜ ID (íŒŒì¼ ê·¸ë£¹í™”ìš©)
        remove_background: ë°°ê²½ ì œê±° ì—¬ë¶€ (U-035, rembg ì‚¬ìš©)
        image_type_hint: ì´ë¯¸ì§€ ìœ í˜• íŒíŠ¸ (rembg ëª¨ë¸ ìë™ ì„ íƒìš©)
    """

    model_config = ConfigDict(extra="forbid")

    prompt: str = Field(min_length=1, description="ì´ë¯¸ì§€ ìƒì„± í”„ë¡¬í”„íŠ¸")
    aspect_ratio: str = Field(default=DEFAULT_ASPECT_RATIO, description="ê°€ë¡œì„¸ë¡œ ë¹„ìœ¨")
    image_size: str = Field(default=DEFAULT_SIZE, description="ì´ë¯¸ì§€ í¬ê¸°")
    reference_image_ids: list[str] = Field(default_factory=list, description="ì°¸ì¡° ì´ë¯¸ì§€ ID ëª©ë¡")
    session_id: str | None = Field(default=None, description="ì„¸ì…˜ ID")
    remove_background: bool = Field(default=False, description="ë°°ê²½ ì œê±° ì—¬ë¶€ (U-035, rembg ì‚¬ìš©)")
    image_type_hint: str | None = Field(
        default=None,
        description="ì´ë¯¸ì§€ ìœ í˜• íŒíŠ¸ (object/character/icon ë“±, rembg ëª¨ë¸ ì„ íƒìš©)",
    )


class ImageGenerationResponse(BaseModel):
    """ì´ë¯¸ì§€ ìƒì„± ì‘ë‹µ.

    Attributes:
        status: ìƒì„± ìƒíƒœ
        image_id: ìƒì„±ëœ ì´ë¯¸ì§€ ID (ì„±ê³µ ì‹œ)
        image_url: ìƒì„±ëœ ì´ë¯¸ì§€ URL (ì„±ê³µ ì‹œ)
        message: ìƒíƒœ ë©”ì‹œì§€ (ì‹¤íŒ¨ ì‹œ ì˜¤ë¥˜ ì„¤ëª…)
        generation_time_ms: ìƒì„± ì†Œìš” ì‹œê°„ (ë°€ë¦¬ì´ˆ)
        background_removed: ë°°ê²½ ì œê±° ìˆ˜í–‰ ì—¬ë¶€ (U-035)
        rembg_model_used: ì‚¬ìš©ëœ rembg ëª¨ë¸ (ë°°ê²½ ì œê±° ì‹œ)
    """

    model_config = ConfigDict(extra="forbid")

    status: ImageGenerationStatus
    image_id: str | None = Field(default=None, description="ìƒì„±ëœ ì´ë¯¸ì§€ ID")
    image_url: str | None = Field(default=None, description="ìƒì„±ëœ ì´ë¯¸ì§€ URL")
    message: str | None = Field(default=None, description="ìƒíƒœ ë©”ì‹œì§€")
    generation_time_ms: int = Field(default=0, description="ìƒì„± ì†Œìš” ì‹œê°„ (ms)")
    background_removed: bool = Field(default=False, description="ë°°ê²½ ì œê±° ìˆ˜í–‰ ì—¬ë¶€ (U-035)")
    rembg_model_used: str | None = Field(default=None, description="ì‚¬ìš©ëœ rembg ëª¨ë¸")


# =============================================================================
# ë‚´ë¶€ ë°ì´í„° í´ë˜ìŠ¤
# =============================================================================


@dataclass
class GeneratedImage:
    """ìƒì„±ëœ ì´ë¯¸ì§€ ì •ë³´.

    Attributes:
        id: ì´ë¯¸ì§€ ê³ ìœ  ID
        path: ë¡œì»¬ íŒŒì¼ ê²½ë¡œ
        url: ì„œë¹™ URL
        prompt_hash: í”„ë¡¬í”„íŠ¸ í•´ì‹œ (ë¡œê·¸ìš©, ì›ë¬¸ ë…¸ì¶œ ê¸ˆì§€)
        created_at: ìƒì„± ì‹œê°
        size: íŒŒì¼ í¬ê¸° (bytes)
        metadata: ì¶”ê°€ ë©”íƒ€ë°ì´í„°
    """

    id: str
    path: Path
    url: str
    prompt_hash: str
    created_at: datetime
    size: int = 0

    def __post_init__(self) -> None:
        """ì´ˆê¸°í™” í›„ ë©”íƒ€ë°ì´í„° í•„ë“œ ì„¤ì •."""
        self._metadata: dict[str, str] = {}

    @property
    def metadata(self) -> dict[str, str]:
        """ì¶”ê°€ ë©”íƒ€ë°ì´í„°."""
        if not hasattr(self, "_metadata"):
            self._metadata = {}
        return self._metadata


# =============================================================================
# Mock ì´ë¯¸ì§€ ìƒì„±ê¸°
# =============================================================================


class MockImageGenerator:
    """í…ŒìŠ¤íŠ¸/ê°œë°œìš© ëª¨ì˜ ì´ë¯¸ì§€ ìƒì„±ê¸°.

    ì‹¤ì œ APIë¥¼ í˜¸ì¶œí•˜ì§€ ì•Šê³  í”Œë ˆì´ìŠ¤í™€ë” ì´ë¯¸ì§€ë¥¼ ìƒì„±í•©ë‹ˆë‹¤.
    """

    def __init__(self, output_dir: Path | None = None) -> None:
        """MockImageGeneratorë¥¼ ì´ˆê¸°í™”í•©ë‹ˆë‹¤.

        Args:
            output_dir: ì´ë¯¸ì§€ ì €ì¥ ë””ë ‰í† ë¦¬ (ê¸°ë³¸ê°’: .data/images/generated)
        """
        self._output_dir = output_dir or get_generated_images_dir()
        self._output_dir.mkdir(parents=True, exist_ok=True)
        logger.info(
            "[ImageGen] Mock ëª¨ë“œë¡œ ì´ˆê¸°í™”ë¨",
            extra={"output_dir": str(self._output_dir)},
        )

    async def generate(self, request: ImageGenerationRequest) -> ImageGenerationResponse:
        """ëª¨ì˜ ì´ë¯¸ì§€ë¥¼ ìƒì„±í•©ë‹ˆë‹¤.

        Args:
            request: ì´ë¯¸ì§€ ìƒì„± ìš”ì²­

        Returns:
            ImageGenerationResponse: ìƒì„± ê²°ê³¼
        """
        start_time = datetime.now(UTC)

        # í”„ë¡¬í”„íŠ¸ í•´ì‹œ ìƒì„± (ì›ë¬¸ ë¡œê¹… ê¸ˆì§€ - RULE-007)
        prompt_hash = hashlib.sha256(request.prompt.encode()).hexdigest()[:8]
        logger.debug(
            "[ImageGen] Mock ì´ë¯¸ì§€ ìƒì„± ìš”ì²­",
            extra={
                "prompt_hash": prompt_hash,
                "size": request.image_size,
                "aspect_ratio": request.aspect_ratio,
                "remove_background": request.remove_background,
            },
        )

        # ê³ ìœ  ì´ë¯¸ì§€ ID ìƒì„±
        image_id = f"img_{uuid.uuid4().hex[:12]}"

        # í”Œë ˆì´ìŠ¤í™€ë” ì´ë¯¸ì§€ ìƒì„± (1x1 íˆ¬ëª… PNG)
        # ì‹¤ì œ í™˜ê²½ì—ì„œëŠ” Gemini API ì‘ë‹µìœ¼ë¡œ ëŒ€ì²´ë¨
        placeholder_png = self._create_placeholder_png(request.image_size)

        # íŒŒì¼ ì €ì¥
        file_name = f"{image_id}.png"
        file_path = self._output_dir / file_name
        file_path.write_bytes(placeholder_png)

        # U-035: ë°°ê²½ ì œê±° í›„ì²˜ë¦¬ (ì¡°ê±´ë¶€)
        background_removed = False
        rembg_model_used: str | None = None
        final_file_path = file_path
        final_file_name = file_name

        if request.remove_background:
            from unknown_world.services.image_postprocess import get_image_postprocessor

            postprocessor = get_image_postprocessor()
            result = postprocessor.remove_background(
                input_path=file_path,
                image_type_hint=request.image_type_hint,
            )

            if result.status.value == "success":
                background_removed = True
                rembg_model_used = result.model_used
                final_file_path = result.output_path
                final_file_name = final_file_path.name

                logger.debug(
                    "[ImageGen] Mock ì´ë¯¸ì§€ ë°°ê²½ ì œê±° ì™„ë£Œ",
                    extra={
                        "image_id": image_id,
                        "model": rembg_model_used,
                        "rembg_time_ms": result.processing_time_ms,
                    },
                )
            else:
                logger.warning(
                    "[ImageGen] Mock ì´ë¯¸ì§€ ë°°ê²½ ì œê±° ì‹¤íŒ¨, ì›ë³¸ ì‚¬ìš©",
                    extra={"image_id": image_id, "message": result.message},
                )
                final_file_path = result.output_path
                final_file_name = final_file_path.name

        # ì„œë¹™ URL ìƒì„± (RU-006-Q5: ì¤‘ì•™í™”ëœ URL ë¹Œë” ì‚¬ìš©)
        image_url = build_image_url(final_file_name, category="generated")

        elapsed_ms = int((datetime.now(UTC) - start_time).total_seconds() * 1000)

        logger.info(
            "[ImageGen] Mock ì´ë¯¸ì§€ ìƒì„± ì™„ë£Œ",
            extra={
                "image_id": image_id,
                "elapsed_ms": elapsed_ms,
                "background_removed": background_removed,
            },
        )

        return ImageGenerationResponse(
            status=ImageGenerationStatus.COMPLETED,
            image_id=image_id,
            image_url=image_url,
            message="Mock ì´ë¯¸ì§€ê°€ ìƒì„±ë˜ì—ˆìŠµë‹ˆë‹¤.",
            generation_time_ms=elapsed_ms,
            background_removed=background_removed,
            rembg_model_used=rembg_model_used,
        )

    def _create_placeholder_png(self, size_str: str) -> bytes:
        """í”Œë ˆì´ìŠ¤í™€ë” PNGë¥¼ ìƒì„±í•©ë‹ˆë‹¤.

        Args:
            size_str: ì´ë¯¸ì§€ í¬ê¸° ë¬¸ìì—´ (ì˜ˆ: "1024x1024")

        Returns:
            PNG ë°”ì´íŠ¸ ë°ì´í„°
        """
        # ìµœì†Œí•œì˜ ìœ íš¨í•œ PNG (1x1 íšŒìƒ‰ í”½ì…€)
        # ì‹¤ì œ í¬ê¸°ëŠ” ë¬´ì‹œí•˜ê³  í”Œë ˆì´ìŠ¤í™€ë”ë§Œ ë°˜í™˜
        # 16x16 íšŒìƒ‰ PNG (mock ì‹ë³„ìš©)
        # Base64ë¡œ ì¸ì½”ë”©ëœ ë¯¸ë‹ˆë©€ PNG
        minimal_png = base64.b64decode(
            "iVBORw0KGgoAAAANSUhEUgAAABAAAAAQCAYAAAAf8/9hAAAADklEQVQ4y2NgGAWjAAcA"
            "CHABAMXKQ5oAAAAASUVORK5CYII="
        )
        return minimal_png

    def is_available(self) -> bool:
        """Mock ìƒì„±ê¸°ëŠ” í•­ìƒ ì‚¬ìš© ê°€ëŠ¥í•©ë‹ˆë‹¤."""
        return True


# =============================================================================
# ì‹¤ì œ ì´ë¯¸ì§€ ìƒì„±ê¸°
# =============================================================================


class ImageGenerator:
    """Gemini ê¸°ë°˜ ì‹¤ì œ ì´ë¯¸ì§€ ìƒì„±ê¸°.

    gemini-3-pro-image-preview ëª¨ë¸ì„ ì‚¬ìš©í•˜ì—¬ ì´ë¯¸ì§€ë¥¼ ìƒì„±í•©ë‹ˆë‹¤.
    ëª¨ë¸ IDëŠ” RULE-010ì— ë”°ë¼ ê³ ì •ë©ë‹ˆë‹¤.
    """

    def __init__(
        self,
        output_dir: Path | None = None,
        project: str | None = None,
        location: str | None = None,
    ) -> None:
        """ImageGeneratorë¥¼ ì´ˆê¸°í™”í•©ë‹ˆë‹¤.

        Args:
            output_dir: ì´ë¯¸ì§€ ì €ì¥ ë””ë ‰í† ë¦¬ (ê¸°ë³¸ê°’: .data/images/generated)
            project: Vertex AI í”„ë¡œì íŠ¸ ID
            location: Vertex AI ë¦¬ì „
        """
        self._output_dir = output_dir or get_generated_images_dir()
        self._output_dir.mkdir(parents=True, exist_ok=True)
        self._project = project or os.environ.get("VERTEX_PROJECT")
        self._location = location or os.environ.get("VERTEX_LOCATION", "us-central1")
        self._client: Client | None = None
        self._available = False

        self._initialize_client()

    def _initialize_client(self) -> None:
        """google-genai í´ë¼ì´ì–¸íŠ¸ë¥¼ ì´ˆê¸°í™”í•©ë‹ˆë‹¤."""
        try:
            from google.genai import Client

            client_options: dict[str, Any] = {}
            if self._project:
                client_options["project"] = self._project
            if self._location:
                client_options["location"] = self._location

            self._client = Client(vertexai=True, **client_options)
            self._available = True

            logger.info(
                "[ImageGen] Vertex AI ì´ë¯¸ì§€ ìƒì„±ê¸° ì´ˆê¸°í™” ì™„ë£Œ",
                extra={
                    "model": MODEL_IMAGE,
                    "project": self._project or "(ADC ê¸°ë³¸)",
                    "location": self._location,
                },
            )
        except Exception as e:
            logger.warning(
                "[ImageGen] Vertex AI í´ë¼ì´ì–¸íŠ¸ ì´ˆê¸°í™” ì‹¤íŒ¨ - Mock ëª¨ë“œ ê¶Œì¥",
                extra={"error_type": type(e).__name__},
            )
            self._available = False

    async def generate(self, request: ImageGenerationRequest) -> ImageGenerationResponse:
        """ì´ë¯¸ì§€ë¥¼ ìƒì„±í•©ë‹ˆë‹¤.

        Args:
            request: ì´ë¯¸ì§€ ìƒì„± ìš”ì²­

        Returns:
            ImageGenerationResponse: ìƒì„± ê²°ê³¼
        """
        if not self._available or self._client is None:
            return ImageGenerationResponse(
                status=ImageGenerationStatus.FAILED,
                message="ì´ë¯¸ì§€ ìƒì„± í´ë¼ì´ì–¸íŠ¸ê°€ ì´ˆê¸°í™”ë˜ì§€ ì•Šì•˜ìŠµë‹ˆë‹¤.",
            )

        start_time = datetime.now(UTC)

        # í”„ë¡¬í”„íŠ¸ í•´ì‹œ (ì›ë¬¸ ë¡œê¹… ê¸ˆì§€ - RULE-007)
        prompt_hash = hashlib.sha256(request.prompt.encode()).hexdigest()[:8]

        # U-036: í”„ë¡¬í”„íŠ¸ ë¡œë”ì—ì„œ ìŠ¤íƒ€ì¼ ê°€ì´ë“œë¼ì¸ ë¡œë“œ (ì„ íƒì  ì°¸ê³ ìš©)
        # ì‹¤ì œ ëª¨ë¸ì€ Imagenì´ë¯€ë¡œ ì§€ì‹œì‚¬í•­ë³´ë‹¤ëŠ” í…ìŠ¤íŠ¸ ìƒì„± ëª¨ë¸(U-019)ì—ì„œ ì´ ê°€ì´ë“œë¼ì¸ì„ í™œìš©í•´
        # ìµœì í™”ëœ ì˜ì–´ í”„ë¡¬í”„íŠ¸ë¥¼ ìƒì„±í•˜ëŠ” ê²ƒì´ ê¶Œì¥ë©ë‹ˆë‹¤.
        try:
            # í˜„ì¬ ìš”ì²­ì˜ ì–¸ì–´ ì •ë³´ë¥¼ ì•Œ ìˆ˜ ì—†ìœ¼ë¯€ë¡œ ê¸°ë³¸ KO ì‚¬ìš© (ë˜ëŠ” ìš”ì²­ì— ì–¸ì–´ ì¶”ê°€ í•„ìš”)
            _style_guidelines = load_image_prompt(Language.KO)
            logger.debug("[ImageGen] ìŠ¤íƒ€ì¼ ê°€ì´ë“œë¼ì¸ ë¡œë“œ ì™„ë£Œ (U-036)")
        except Exception:
            logger.warning("[ImageGen] ìŠ¤íƒ€ì¼ ê°€ì´ë“œë¼ì¸ ë¡œë“œ ì‹¤íŒ¨")

        logger.debug(
            "[ImageGen] ì´ë¯¸ì§€ ìƒì„± ìš”ì²­",
            extra={
                "prompt_hash": prompt_hash,
                "size": request.image_size,
                "model": MODEL_IMAGE,
                "remove_background": request.remove_background,
            },
        )

        try:
            from google.genai.types import GenerateImagesConfig

            # ì´ë¯¸ì§€ í¬ê¸° ê²€ì¦ (í˜„ì¬ APIì—ì„œ í¬ê¸° ì§€ì •ì€ ì œí•œì )
            _ = SUPPORTED_SIZES.get(request.image_size, SUPPORTED_SIZES[DEFAULT_SIZE])

            # Gemini ì´ë¯¸ì§€ ìƒì„± í˜¸ì¶œ
            # ì°¸ê³ : gemini-3-pro-image-preview ëª¨ë¸ ì‚¬ìš© (RULE-010 ê³ ì •)
            response = await self._client.aio.models.generate_images(
                model=get_model_id(ModelLabel.IMAGE),
                prompt=request.prompt,
                config=GenerateImagesConfig(
                    number_of_images=1,
                    output_mime_type="image/png",
                    # Gemini ì´ë¯¸ì§€ ìƒì„± APIëŠ” í¬ê¸° ì§€ì • ë°©ì‹ì´ ë‹¤ë¥¼ ìˆ˜ ìˆìŒ
                    # ì‹¤ì œ API ìŠ¤í™ì— ë§ê²Œ ì¡°ì • í•„ìš”
                ),
            )

            # ì´ë¯¸ì§€ ë°ì´í„° ì¶”ì¶œ ë° ì €ì¥
            if response and hasattr(response, "generated_images") and response.generated_images:
                image_data = response.generated_images[0]
                image_bytes: bytes | None = None
                if (
                    hasattr(image_data, "image")
                    and image_data.image
                    and hasattr(image_data.image, "image_bytes")
                ):
                    image_bytes = image_data.image.image_bytes

                if image_bytes is None:
                    raise ValueError("ì´ë¯¸ì§€ ë°ì´í„°ë¥¼ ì¶”ì¶œí•  ìˆ˜ ì—†ìŠµë‹ˆë‹¤.")

                # ê³ ìœ  ID ë° íŒŒì¼ ì €ì¥
                image_id = f"img_{uuid.uuid4().hex[:12]}"
                file_name = f"{image_id}.png"
                file_path = self._output_dir / file_name
                file_path.write_bytes(image_bytes)

                # U-035: ë°°ê²½ ì œê±° í›„ì²˜ë¦¬ (ì¡°ê±´ë¶€)
                background_removed = False
                rembg_model_used: str | None = None
                final_file_path = file_path
                final_file_name = file_name

                if request.remove_background:
                    from unknown_world.services.image_postprocess import (
                        get_image_postprocessor,
                    )

                    postprocessor = get_image_postprocessor()
                    result = postprocessor.remove_background(
                        input_path=file_path,
                        image_type_hint=request.image_type_hint,
                    )

                    if result.status.value == "success":
                        background_removed = True
                        rembg_model_used = result.model_used
                        final_file_path = result.output_path
                        final_file_name = final_file_path.name

                        logger.debug(
                            "[ImageGen] ì´ë¯¸ì§€ ë°°ê²½ ì œê±° ì™„ë£Œ",
                            extra={
                                "image_id": image_id,
                                "model": rembg_model_used,
                                "rembg_time_ms": result.processing_time_ms,
                            },
                        )
                    else:
                        logger.warning(
                            "[ImageGen] ì´ë¯¸ì§€ ë°°ê²½ ì œê±° ì‹¤íŒ¨, ì›ë³¸ ì‚¬ìš©",
                            extra={"image_id": image_id, "message": result.message},
                        )
                        final_file_path = result.output_path
                        final_file_name = final_file_path.name

                # ì„œë¹™ URL ìƒì„± (RU-006-Q5: ì¤‘ì•™í™”ëœ URL ë¹Œë” ì‚¬ìš©)
                image_url = build_image_url(final_file_name, category="generated")
                elapsed_ms = int((datetime.now(UTC) - start_time).total_seconds() * 1000)

                logger.info(
                    "[ImageGen] ì´ë¯¸ì§€ ìƒì„± ì™„ë£Œ",
                    extra={
                        "image_id": image_id,
                        "elapsed_ms": elapsed_ms,
                        "size_bytes": len(image_bytes),
                        "background_removed": background_removed,
                    },
                )

                return ImageGenerationResponse(
                    status=ImageGenerationStatus.COMPLETED,
                    image_id=image_id,
                    image_url=image_url,
                    message="ì´ë¯¸ì§€ê°€ ì„±ê³µì ìœ¼ë¡œ ìƒì„±ë˜ì—ˆìŠµë‹ˆë‹¤.",
                    generation_time_ms=elapsed_ms,
                    background_removed=background_removed,
                    rembg_model_used=rembg_model_used,
                )
            else:
                return ImageGenerationResponse(
                    status=ImageGenerationStatus.FAILED,
                    message="ì´ë¯¸ì§€ ìƒì„± ì‘ë‹µì´ ë¹„ì–´ìˆìŠµë‹ˆë‹¤.",
                )

        except Exception as e:
            elapsed_ms = int((datetime.now(UTC) - start_time).total_seconds() * 1000)
            error_type = type(e).__name__

            logger.error(
                "[ImageGen] ì´ë¯¸ì§€ ìƒì„± ì‹¤íŒ¨",
                extra={
                    "error_type": error_type,
                    "elapsed_ms": elapsed_ms,
                },
            )

            # ì‹¤íŒ¨ ì‹œì—ë„ ì•ˆì „í•œ ì‘ë‹µ ë°˜í™˜ (RULE-004)
            return ImageGenerationResponse(
                status=ImageGenerationStatus.FAILED,
                message=f"ì´ë¯¸ì§€ ìƒì„± ì¤‘ ì˜¤ë¥˜ê°€ ë°œìƒí–ˆìŠµë‹ˆë‹¤: {error_type}",
                generation_time_ms=elapsed_ms,
            )

    def is_available(self) -> bool:
        """ìƒì„±ê¸°ê°€ ì‚¬ìš© ê°€ëŠ¥í•œ ìƒíƒœì¸ì§€ í™•ì¸í•©ë‹ˆë‹¤."""
        return self._available


# =============================================================================
# íŒ©í† ë¦¬ í•¨ìˆ˜
# =============================================================================

# ìƒì„±ê¸° íƒ€ì…
ImageGeneratorType = MockImageGenerator | ImageGenerator

# ì‹±ê¸€í†¤ ì¸ìŠ¤í„´ìŠ¤ ìºì‹œ
_generator_instance: ImageGeneratorType | None = None


def get_image_generator(
    *,
    force_mock: bool = False,
    force_new: bool = False,
    output_dir: Path | None = None,
) -> ImageGeneratorType:
    """ì´ë¯¸ì§€ ìƒì„±ê¸° ì¸ìŠ¤í„´ìŠ¤ë¥¼ ë°˜í™˜í•©ë‹ˆë‹¤.

    í™˜ê²½ë³€ìˆ˜ UW_MODEì— ë”°ë¼ ì‹¤ì œ ìƒì„±ê¸° ë˜ëŠ” Mock ìƒì„±ê¸°ë¥¼ ë°˜í™˜í•©ë‹ˆë‹¤.

    Args:
        force_mock: Trueë©´ í™˜ê²½ë³€ìˆ˜ì™€ ë¬´ê´€í•˜ê²Œ Mock ìƒì„±ê¸° ë°˜í™˜
        force_new: Trueë©´ ìºì‹œë¥¼ ë¬´ì‹œí•˜ê³  ìƒˆ ì¸ìŠ¤í„´ìŠ¤ ìƒì„±
        output_dir: ì´ë¯¸ì§€ ì €ì¥ ë””ë ‰í† ë¦¬

    Returns:
        ì´ë¯¸ì§€ ìƒì„±ê¸° ì¸ìŠ¤í„´ìŠ¤
    """
    global _generator_instance

    if not force_new and _generator_instance is not None:
        return _generator_instance

    # ëª¨ë“œ ê²°ì •
    mode = os.environ.get("UW_MODE", "real")

    if force_mock or mode == "mock":
        generator: ImageGeneratorType = MockImageGenerator(output_dir)
    else:
        real_gen = ImageGenerator(output_dir)
        # ì‹¤ì œ ìƒì„±ê¸° ì´ˆê¸°í™” ì‹¤íŒ¨ ì‹œ Mockìœ¼ë¡œ í´ë°±
        if not real_gen.is_available():
            logger.warning("[ImageGen] ì‹¤ì œ ìƒì„±ê¸° ì´ˆê¸°í™” ì‹¤íŒ¨, Mock ëª¨ë“œë¡œ í´ë°±")
            generator = MockImageGenerator(output_dir)
        else:
            generator = real_gen

    _generator_instance = generator
    return generator


def reset_image_generator() -> None:
    """ì´ë¯¸ì§€ ìƒì„±ê¸° ìºì‹œë¥¼ ì´ˆê¸°í™”í•©ë‹ˆë‹¤.

    í…ŒìŠ¤íŠ¸ ì‹œ ìƒì„±ê¸°ë¥¼ ì¬ì„¤ì •í•  ë•Œ ì‚¬ìš©í•©ë‹ˆë‹¤.
    """
    global _generator_instance
    _generator_instance = None


# =============================================================================
# í—¬í¼ í•¨ìˆ˜
# =============================================================================


def create_fallback_response(message: str | None = None) -> ImageGenerationResponse:
    """ì‹¤íŒ¨ ì‹œ ì•ˆì „í•œ í´ë°± ì‘ë‹µì„ ìƒì„±í•©ë‹ˆë‹¤.

    RULE-004: ê²€ì¦ ì‹¤íŒ¨ë‚˜ ì˜¤ë¥˜ ì‹œì—ë„ ì•ˆì „í•œ ì‘ë‹µ ì œê³µ

    Args:
        message: ì˜¤ë¥˜ ë©”ì‹œì§€ (ì„ íƒ)

    Returns:
        ImageGenerationResponse: í´ë°± ì‘ë‹µ
    """
    return ImageGenerationResponse(
        status=ImageGenerationStatus.SKIPPED,
        message=message or "ì´ë¯¸ì§€ ìƒì„±ì„ ê±´ë„ˆë›°ì—ˆìŠµë‹ˆë‹¤. í…ìŠ¤íŠ¸ë¡œ ì§„í–‰í•©ë‹ˆë‹¤.",
    )


def validate_image_request(request: ImageGenerationRequest) -> str | None:
    """ì´ë¯¸ì§€ ìƒì„± ìš”ì²­ì„ ê²€ì¦í•©ë‹ˆë‹¤.

    NOTE: ì´ í•¨ìˆ˜ëŠ” í˜¸í™˜ì„±ì„ ìœ„í•´ ìœ ì§€ë˜ë©°, ë‚´ë¶€ì ìœ¼ë¡œ
    ì¤‘ì•™í™”ëœ validate_image_generation_requestë¥¼ í˜¸ì¶œí•©ë‹ˆë‹¤.

    Args:
        request: ê²€ì¦í•  ìš”ì²­

    Returns:
        ì˜¤ë¥˜ ë©”ì‹œì§€ (ìœ íš¨í•˜ë©´ None)
    """
    return validate_image_generation_request(
        prompt=request.prompt,
        image_size=request.image_size,
        language="ko-KR",
    )
</file>

<file path="frontend/public/ui/manifest.json">
{
  "$schema": "./manifest.schema.json",
  "version": "1.4.0",
  "generatedAt": "2026-01-14T14:55:00Z",
  "totalBytes": 570867,
  "budgetBytes": 1572864,
  "assets": [
    {
      "id": "signal-24",
      "path": "icons/signal-24.png",
      "type": "icon",
      "size": 24,
      "fallback": "âš¡",
      "usedIn": ["EconomyHUD"],
      "bytes": 1573,
      "notes": "U-038: v2 ì¬ìƒì„±, nanobanana mcp(í”½ì…€ì•„íŠ¸), rembg(birefnet-general), ImageMagick ìµœì í™”"
    },
    {
      "id": "signal-16",
      "path": "icons/signal-16.png",
      "type": "icon",
      "size": 16,
      "fallback": "âš¡",
      "usedIn": ["ActionDeck"],
      "bytes": 1012,
      "notes": "U-038: v2 ì¬ìƒì„±, nanobanana mcp(í”½ì…€ì•„íŠ¸), rembg(birefnet-general), ImageMagick ìµœì í™”"
    },
    {
      "id": "shard-24",
      "path": "icons/shard-24.png",
      "type": "icon",
      "size": 24,
      "fallback": "ğŸ’",
      "usedIn": ["EconomyHUD"],
      "bytes": 1362,
      "notes": "U-038: v2 ì¬ìƒì„±, nanobanana mcp(í”½ì…€ì•„íŠ¸), rembg(birefnet-general), ImageMagick ìµœì í™”"
    },
    {
      "id": "shard-16",
      "path": "icons/shard-16.png",
      "type": "icon",
      "size": 16,
      "fallback": "ğŸ’",
      "usedIn": ["ActionDeck"],
      "bytes": 1147,
      "notes": "U-038: shard-24ì—ì„œ ë¦¬ì‚¬ì´ì¦ˆ, 16px ìµœì í™”"
    },
    {
      "id": "badge-ok-24",
      "path": "icons/badge-ok-24.png",
      "type": "icon",
      "size": 24,
      "fallback": "âœ“",
      "usedIn": ["AgentConsole"],
      "bytes": 1461,
      "notes": "U-038: v2 ì¬ìƒì„±, nanobanana mcp(í”½ì…€ì•„íŠ¸), rembg(birefnet-general), ImageMagick ìµœì í™”"
    },
    {
      "id": "badge-ok-16",
      "path": "icons/badge-ok-16.png",
      "type": "icon",
      "size": 16,
      "fallback": "âœ“",
      "usedIn": [],
      "bytes": 1096,
      "notes": "U-038: v2 ì¬ìƒì„±, nanobanana mcp(í”½ì…€ì•„íŠ¸), rembg(birefnet-general), ImageMagick ìµœì í™”"
    },
    {
      "id": "badge-fail-24",
      "path": "icons/badge-fail-24.png",
      "type": "icon",
      "size": 24,
      "fallback": "âœ—",
      "usedIn": ["AgentConsole"],
      "bytes": 2006,
      "notes": "U-038: v2 ì¬ìƒì„±, nanobanana mcp(í”½ì…€ì•„íŠ¸), rembg(birefnet-general), ImageMagick ìµœì í™”"
    },
    {
      "id": "risk-medium-24",
      "path": "icons/risk-medium-24.png",
      "type": "icon",
      "size": 24,
      "fallback": "âš ",
      "usedIn": [],
      "bytes": 1594,
      "notes": "U-038: 24px í˜ì–´ ë³´ê°•, nanobanana mcp ìƒì„±"
    },
    {
      "id": "risk-medium-16",
      "path": "icons/risk-medium-16.png",
      "type": "icon",
      "size": 16,
      "fallback": "âš ",
      "usedIn": ["ActionDeck"],
      "bytes": 1256,
      "notes": "U-038: v2 ì¬ìƒì„±, nanobanana mcp(í”½ì…€ì•„íŠ¸), rembg(birefnet-general), ImageMagick ìµœì í™”"
    },
    {
      "id": "risk-low-24",
      "path": "icons/risk-low-24.png",
      "type": "icon",
      "size": 24,
      "fallback": "âœ“",
      "usedIn": [],
      "bytes": 1838,
      "notes": "U-038: v2 ì¬ìƒì„±, nanobanana mcp(í”½ì…€ì•„íŠ¸), rembg(birefnet-general), ImageMagick ìµœì í™”"
    },
    {
      "id": "risk-low-16",
      "path": "icons/risk-low-16.png",
      "type": "icon",
      "size": 16,
      "fallback": "âœ“",
      "usedIn": ["ActionDeck"],
      "bytes": 1331,
      "notes": "U-038: v2 ì¬ìƒì„±, nanobanana mcp(í”½ì…€ì•„íŠ¸), rembg(birefnet-general), ImageMagick ìµœì í™”"
    },
    {
      "id": "risk-high-24",
      "path": "icons/risk-high-24.png",
      "type": "icon",
      "size": 24,
      "fallback": "âš ",
      "usedIn": [],
      "bytes": 1737,
      "notes": "U-038: v2 ì¬ìƒì„±, nanobanana mcp(í”½ì…€ì•„íŠ¸), rembg(birefnet-general), ImageMagick ìµœì í™”"
    },
    {
      "id": "risk-high-16",
      "path": "icons/risk-high-16.png",
      "type": "icon",
      "size": 16,
      "fallback": "âš ",
      "usedIn": ["ActionDeck"],
      "bytes": 1227,
      "notes": "U-038: v2 ì¬ìƒì„±, nanobanana mcp(í”½ì…€ì•„íŠ¸), rembg(birefnet-general), ImageMagick ìµœì í™”"
    },
    {
      "id": "status-online-16",
      "path": "icons/status-online-16.png",
      "type": "icon",
      "size": 16,
      "fallback": "â—",
      "usedIn": [],
      "bytes": 1375,
      "notes": "U-038: v2 ì¬ìƒì„±, nanobanana mcp(í”½ì…€ì•„íŠ¸), rembg(birefnet-general), ImageMagick ìµœì í™”"
    },
    {
      "id": "scene-placeholder-default",
      "path": "placeholders/scene-placeholder-default.png",
      "type": "placeholder",
      "fallback": "[SCENE]",
      "usedIn": ["SceneCanvas"],
      "bytes": 261407,
      "notes": "nanobanana mcp ìƒì„±, ë ˆíŠ¸ë¡œ í„°ë¯¸ë„ ìŠ¤íƒ€ì¼"
    },
    {
      "id": "scene-loading",
      "path": "placeholders/scene-loading.webp",
      "type": "placeholder",
      "fallback": "â³",
      "usedIn": ["SceneCanvas"],
      "bytes": 47850,
      "notes": "U-031: ë¡œë”© ìƒíƒœ placeholder, nanobanana mcp ìƒì„±, ImageMagick(magick) ìµœì í™”"
    },
    {
      "id": "scene-offline",
      "path": "placeholders/scene-offline.webp",
      "type": "placeholder",
      "fallback": "ğŸ”Œ",
      "usedIn": ["SceneCanvas"],
      "bytes": 44658,
      "notes": "U-031: ì˜¤í”„ë¼ì¸ ìƒíƒœ placeholder, nanobanana mcp ìƒì„±, ImageMagick(magick) ìµœì í™”"
    },
    {
      "id": "scene-blocked",
      "path": "placeholders/scene-blocked.webp",
      "type": "placeholder",
      "fallback": "ğŸš«",
      "usedIn": ["SceneCanvas"],
      "bytes": 17318,
      "notes": "U-031: ì°¨ë‹¨ ìƒíƒœ placeholder, nanobanana mcp ìƒì„±, ImageMagick(magick) ìµœì í™”"
    },
    {
      "id": "scene-low-signal",
      "path": "placeholders/scene-low-signal.webp",
      "type": "placeholder",
      "fallback": "ğŸ“‰",
      "usedIn": ["SceneCanvas"],
      "bytes": 68454,
      "notes": "U-031: ì €ì‹ í˜¸ ìƒíƒœ placeholder, nanobanana mcp ìƒì„±, ImageMagick(magick) ìµœì í™”"
    },
    {
      "id": "panel-corner-br",
      "path": "chrome/panel-corner-br.png",
      "type": "chrome",
      "fallback": "",
      "usedIn": ["PanelHeader"],
      "bytes": 1899,
      "notes": "U-032: íŒ¨ë„ ì½”ë„ˆ ì¥ì‹, nanobanana mcp ìƒì„±, rembg ë°°ê²½ ì œê±°, ImageMagick ìµœì í™”(48x48), CSS transformìœ¼ë¡œ 4ë°©í–¥ ì ìš©"
    },
    {
      "id": "card-frame",
      "path": "chrome/card-frame.png",
      "type": "chrome",
      "fallback": "",
      "usedIn": ["ActionCard"],
      "bytes": 9101,
      "notes": "U-032: ì•¡ì…˜ ì¹´ë“œ í”„ë ˆì„, nanobanana mcp ìƒì„±, rembg ë°°ê²½ ì œê±°, ImageMagick ìµœì í™”(160x80)"
    },
    {
      "id": "scanner-frame",
      "path": "chrome/scanner-frame.png",
      "type": "chrome",
      "fallback": "",
      "usedIn": ["Scanner"],
      "bytes": 100165,
      "notes": "U-032: ìŠ¤ìºë„ˆ ìŠ¬ë¡¯ í”„ë ˆì„, nanobanana mcp ìƒì„±, rembg(birefnet-general) ë°°ê²½ ì œê±°, ImageMagick ìµœì í™”(346x200) ì™„ë£Œ"
    }
  ]
}
</file>

<file path="backend/src/unknown_world/main.py">
"""Unknown World - FastAPI ì• í”Œë¦¬ì¼€ì´ì…˜ ì—”íŠ¸ë¦¬í¬ì¸íŠ¸

ì´ ëª¨ë“ˆì€ Unknown World ë°±ì—”ë“œì˜ FastAPI ì•±ì„ ì •ì˜í•©ë‹ˆë‹¤.
MVP ë‹¨ê³„ì—ì„œëŠ” ê¸°ë³¸ í—¬ìŠ¤ì²´í¬ì™€ ê°œë°œìš© CORS ì„¤ì •ë§Œ í¬í•¨í•©ë‹ˆë‹¤.

ì‹¤í–‰ ë°©ë²•:
    cd backend
    uv sync
    uv run uvicorn unknown_world.main:app --reload --port 8011

ì°¸ì¡°:
    - vibe/tech-stack.md (ë²„ì „ SSOT)
    - vibe/prd.md (ì—ì´ì „íŠ¸í˜• ê²Œì„ ì—”ì§„ ìš”êµ¬ì‚¬í•­)
    - .cursor/rules/20-backend-orchestrator.mdc (SSE/ê²€ì¦/ë³µêµ¬ ê·œì¹™)
"""

# ruff: noqa: E402
# E402 ë¬´ì‹œ: .env ë¡œë”©ì€ ì˜ë„ì ìœ¼ë¡œ ë‹¤ë¥¸ importë³´ë‹¤ ë¨¼ì € ì‹¤í–‰ë˜ì–´ì•¼ í•¨ (U-047)

# =============================================================================
# .env ìë™ ë¡œë”© (U-047)
# =============================================================================
# ë¡œì»¬ ê°œë°œì—ì„œ backend/.env íŒŒì¼ì´ ìˆìœ¼ë©´ ìë™ ë¡œë”©í•©ë‹ˆë‹¤.
# - override=False: ì´ë¯¸ ì„¤ì •ëœ í™˜ê²½ë³€ìˆ˜ëŠ” ë®ì–´ì“°ì§€ ì•ŠìŒ (ìš´ì˜ í™˜ê²½ SSOT ë³´ì¥)
# - íŒŒì¼ ë¯¸ì¡´ì¬ ì‹œ no-op (ìš´ì˜/CIì—ì„œ íŒŒì¼ ë¯¸ì¡´ì¬ë¥¼ ê¸°ë³¸ìœ¼ë¡œ í—ˆìš©)
# - í˜ì–´ë§ ì§ˆë¬¸ Q1 ê²°ì •: Option A (import ì‹œì ì— ë¡œë“œ)
#
# ë³´ì•ˆ ê·œì¹™:
#   - .env íŒŒì¼ì€ ë ˆí¬ì— ì»¤ë°‹ ê¸ˆì§€ (.gitignore í•„ìˆ˜)
#   - ë¯¼ê° ì •ë³´(í‚¤/í† í°/í”„ë¡¬í”„íŠ¸)ëŠ” ë¡œê·¸/ìŠ¤íŠ¸ë¦¼/UIì— ë…¸ì¶œ ê¸ˆì§€ (RULE-007)
import os
from pathlib import Path

from dotenv import load_dotenv

# .env íŒŒì¼ ê²½ë¡œ (backend ë””ë ‰í† ë¦¬ ê¸°ì¤€)
# main.py ìœ„ì¹˜: backend/src/unknown_world/main.py
# backend/.env ìœ„ì¹˜: backend/.env (3ë‹¨ê³„ ìƒìœ„)
# resolve()ë¡œ ì ˆëŒ€ ê²½ë¡œ ë³´ì¥
_DOTENV_PATH = Path(__file__).resolve().parent.parent.parent / ".env"

# .env ë¡œë”© (override=False: ê¸°ì¡´ í™˜ê²½ë³€ìˆ˜ ìš°ì„ )
_dotenv_loaded = load_dotenv(dotenv_path=_DOTENV_PATH, override=False)

# ë””ë²„ê·¸: .env ë¡œë”© ìƒíƒœ ì¦‰ì‹œ ì¶œë ¥ (U-047 ê²€ì¦ìš©)
import sys

print(f"[Startup] .env path: {_DOTENV_PATH}", file=sys.stderr)
print(f"[Startup] .env exists: {_DOTENV_PATH.exists()}", file=sys.stderr)
print(f"[Startup] dotenv loaded: {_dotenv_loaded}", file=sys.stderr)
import os as _os_temp

print(f"[Startup] UW_MODE: {_os_temp.environ.get('UW_MODE', 'NOT_SET')}", file=sys.stderr)

import logging
from collections.abc import AsyncGenerator
from contextlib import asynccontextmanager
from typing import Literal

from fastapi import FastAPI
from fastapi.middleware.cors import CORSMiddleware
from fastapi.staticfiles import StaticFiles
from pydantic import BaseModel, Field

from unknown_world import __version__
from unknown_world.api import image_router, scanner_router, turn_router
from unknown_world.services.rembg_preflight import (
    RembgPreflightResult,
    RembgReadyStatus,
    get_rembg_status,
    run_preflight_async,
)
from unknown_world.storage.paths import BASE_DATA_DIR, STATIC_URL_PREFIX

# =============================================================================
# ë¡œê±° ì„¤ì •
# =============================================================================

logger = logging.getLogger(__name__)

# =============================================================================
# .env ë¡œë”© ìƒíƒœ ë¡œê¹… (U-047)
# =============================================================================
# ë¯¼ê° ì •ë³´(í‚¤/í† í°/ê²½ë¡œ)ëŠ” ì¶œë ¥í•˜ì§€ ì•ŠìŒ (RULE-007/008)
# ëª¨ë“œ/í™˜ê²½ ì •ë„ë§Œ ë¡œê¹…í•˜ì—¬ ë””ë²„ê¹… ìš©ì´ì„± í™•ë³´

_uw_mode = os.environ.get("UW_MODE", "mock")  # ê¸°ë³¸ê°’: mock (genai_client.py ì •ì±…)
_environment = os.environ.get("ENVIRONMENT", "development")

if _dotenv_loaded:
    logger.info(
        "[Config] .env íŒŒì¼ ë¡œë“œ ì™„ë£Œ",
        extra={
            "dotenv_path": str(_DOTENV_PATH),
            "UW_MODE": _uw_mode,
            "ENVIRONMENT": _environment,
        },
    )
else:
    logger.debug(
        "[Config] .env íŒŒì¼ ë¯¸ì¡´ì¬ ë˜ëŠ” ë¡œë“œ ì‹¤íŒ¨ (ê¸°ë³¸ê°’ ì‚¬ìš©)",
        extra={
            "UW_MODE": _uw_mode,
            "ENVIRONMENT": _environment,
        },
    )

# =============================================================================
# Lifespan (ì„œë²„ ì‹œì‘/ì¢…ë£Œ ì´ë²¤íŠ¸)
# =============================================================================


@asynccontextmanager
async def lifespan(app: FastAPI) -> AsyncGenerator[None]:
    """FastAPI ì•± lifespan ê´€ë¦¬.

    ì„œë²„ ì‹œì‘ ì‹œ:
        - rembg preflight ì‹¤í–‰ (ëª¨ë¸ ì‚¬ì „ ì ê²€/ë‹¤ìš´ë¡œë“œ)

    ì„œë²„ ì¢…ë£Œ ì‹œ:
        - í•„ìš”í•œ ì •ë¦¬ ì‘ì—… ìˆ˜í–‰
    """
    # =========================================================================
    # Startup
    # =========================================================================
    logger.info("[Startup] Unknown World ë°±ì—”ë“œ ì‹œì‘")

    # rembg preflight ì‹¤í–‰ (U-045)
    # Q1: Option A - íƒ€ì„ì•„ì›ƒ ì§§ê²Œ + ì‹¤íŒ¨ ì‹œ degraded ëª¨ë“œë¡œ ê³„ì†
    try:
        logger.info("[Startup] rembg preflight ì‹œì‘")
        result = await run_preflight_async()

        if result.status == RembgReadyStatus.READY:
            logger.info(
                "[Startup] rembg READY",
                extra={
                    "preloaded_models": result.preloaded_models,
                    "elapsed_ms": result.preflight_time_ms,
                },
            )
        elif result.status == RembgReadyStatus.DEGRADED:
            logger.warning(
                "[Startup] rembg DEGRADED - ì¼ë¶€ ê¸°ëŠ¥ì´ ì œí•œë  ìˆ˜ ìˆìŠµë‹ˆë‹¤",
                extra={
                    "preloaded_models": result.preloaded_models,
                    "missing_models": result.missing_models,
                    "last_error": result.last_error,
                },
            )
        else:
            logger.warning(
                "[Startup] rembg UNAVAILABLE - ë°°ê²½ ì œê±° ê¸°ëŠ¥ì´ ë¹„í™œì„±í™”ë©ë‹ˆë‹¤",
                extra={"last_error": result.last_error},
            )

        # app.stateì— ì €ì¥
        app.state.rembg_status = result

    except Exception as e:
        # preflight ì‹¤íŒ¨í•´ë„ ì„œë¹„ìŠ¤ëŠ” ê³„ì† (RULE-004)
        logger.exception("[Startup] rembg preflight ì‹¤íŒ¨, degraded ëª¨ë“œë¡œ ì‹œì‘")
        app.state.rembg_status = RembgPreflightResult(
            status=RembgReadyStatus.UNAVAILABLE,
            installed=False,
            last_error=f"preflight ì˜ˆì™¸: {type(e).__name__}",
        )

    logger.info("[Startup] Unknown World ë°±ì—”ë“œ ì‹œì‘ ì™„ë£Œ")

    yield

    # =========================================================================
    # Shutdown
    # =========================================================================
    logger.info("[Shutdown] Unknown World ë°±ì—”ë“œ ì¢…ë£Œ")


# =============================================================================
# FastAPI ì•± ì¸ìŠ¤í„´ìŠ¤
# =============================================================================

app = FastAPI(
    title="Unknown World API",
    description="Gemini ê¸°ë°˜ ì—ì´ì „íŠ¸í˜• ê²Œì„ ì—”ì§„ ì˜¤ì¼€ìŠ¤íŠ¸ë ˆì´í„°",
    version=__version__,
    docs_url="/docs",
    redoc_url="/redoc",
    lifespan=lifespan,
)

# =============================================================================
# ì •ì  íŒŒì¼ ì„œë¹™ (U-019, RU-006-Q5)
# =============================================================================
# ë°ì´í„° ë””ë ‰í† ë¦¬ ìƒì„± ë° ì •ì  íŒŒì¼ ì„œë¹™
# ì „ì²´ .data ë””ë ‰í† ë¦¬ë¥¼ /staticìœ¼ë¡œ ì„œë¹™í•˜ì—¬ ì¹´í…Œê³ ë¦¬ë³„ ê²½ë¡œ ì§€ì›
# ì˜ˆ: /static/images/generated/img_xxx.png
BASE_DATA_DIR.mkdir(parents=True, exist_ok=True)
app.mount(STATIC_URL_PREFIX, StaticFiles(directory=str(BASE_DATA_DIR)), name="static")

# =============================================================================
# CORS ì„¤ì • (ê°œë°œ í™˜ê²½ìš©)
# =============================================================================
# PRD ìš”êµ¬: ë¡œì»¬ ê°œë°œì—ì„œ í”„ë¡ íŠ¸ì™€ í†µì‹ í•  ìˆ˜ ìˆë„ë¡ CORS ê¸°ë³¸ ì •ì±… ì¤€ë¹„
# RULE-011: í”„ë¡ íŠ¸ì—”ë“œëŠ” 8001~8010 í¬íŠ¸ ì‚¬ìš©
# ì£¼ì˜: í”„ë¡œë•ì…˜ì—ì„œëŠ” MMP ë‹¨ê³„ì—ì„œ ì—„ê²©í•œ ì •ì±…ìœ¼ë¡œ ë³€ê²½í•´ì•¼ í•¨

ALLOWED_ORIGINS = [
    # í”„ë¡ íŠ¸ì—”ë“œ ê°œë°œ ì„œë²„ í¬íŠ¸ ë²”ìœ„ (RULE-011: 8001~8010)
    *[f"http://localhost:{port}" for port in range(8001, 8011)],
    *[f"http://127.0.0.1:{port}" for port in range(8001, 8011)],
]

app.add_middleware(
    CORSMiddleware,
    allow_origins=ALLOWED_ORIGINS,
    allow_credentials=True,
    allow_methods=["*"],
    allow_headers=["*"],
)

# =============================================================================
# ë¼ìš°í„° ë“±ë¡
# =============================================================================

# U-007: /api/turn HTTP Streaming ì—”ë“œí¬ì¸íŠ¸
app.include_router(turn_router)

# U-019: /api/image ì´ë¯¸ì§€ ìƒì„± ì—”ë“œí¬ì¸íŠ¸
app.include_router(image_router)

# U-021: /api/scan ì´ë¯¸ì§€ ì´í•´(Scanner) ì—”ë“œí¬ì¸íŠ¸
app.include_router(scanner_router)


# =============================================================================
# ì‘ë‹µ ìŠ¤í‚¤ë§ˆ (Pydantic)
# =============================================================================


class RembgHealthInfo(BaseModel):
    """rembg ìƒíƒœ ì •ë³´ (í—¬ìŠ¤ì²´í¬ìš©).

    Attributes:
        status: rembg ì¤€ë¹„ ìƒíƒœ
        installed: ì„¤ì¹˜ ì—¬ë¶€
        preloaded_models: ì‚¬ìš© ê°€ëŠ¥í•œ ëª¨ë¸ ëª©ë¡
        missing_models: ëˆ„ë½ëœ ëª¨ë¸ ëª©ë¡
        last_error: ë§ˆì§€ë§‰ ì—ëŸ¬ (ìˆì„ ê²½ìš°)
    """

    status: str = Field(description="rembg ì¤€ë¹„ ìƒíƒœ (ready/degraded/unavailable/pending)")
    installed: bool = Field(description="rembg ì„¤ì¹˜ ì—¬ë¶€")
    preloaded_models: list[str] = Field(default_factory=list, description="ì‚¬ìš© ê°€ëŠ¥í•œ ëª¨ë¸ ëª©ë¡")
    missing_models: list[str] = Field(default_factory=list, description="ëˆ„ë½ëœ ëª¨ë¸ ëª©ë¡")
    last_error: str | None = Field(default=None, description="ë§ˆì§€ë§‰ ì—ëŸ¬ ë©”ì‹œì§€")


class HealthResponse(BaseModel):
    """í—¬ìŠ¤ì²´í¬ ì‘ë‹µ ìŠ¤í‚¤ë§ˆ.

    Attributes:
        status: ì„œë²„ ìƒíƒœ ("ok" ë˜ëŠ” "degraded")
        version: ë°±ì—”ë“œ ë²„ì „
        service: ì„œë¹„ìŠ¤ ì´ë¦„
        rembg: rembg ìƒíƒœ ì •ë³´ (ì„ íƒ)
    """

    status: Literal["ok", "degraded"]
    version: str
    service: str
    rembg: RembgHealthInfo | None = Field(default=None, description="rembg ìƒíƒœ ì •ë³´")


# =============================================================================
# ë¼ìš°íŠ¸ ì •ì˜
# =============================================================================


@app.get("/health", response_model=HealthResponse, tags=["System"])
async def health_check() -> HealthResponse:
    """ì„œë²„ í—¬ìŠ¤ì²´í¬ ì—”ë“œí¬ì¸íŠ¸.

    ì„œë²„ê°€ ì •ìƒì ìœ¼ë¡œ ì‘ë™ ì¤‘ì¸ì§€ í™•ì¸í•©ë‹ˆë‹¤.
    ì´ ì—”ë“œí¬ì¸íŠ¸ëŠ” ë¡œë“œë°¸ëŸ°ì„œ, ëª¨ë‹ˆí„°ë§ ì‹œìŠ¤í…œ, í´ë¼ì´ì–¸íŠ¸ ì—°ê²° í™•ì¸ì— ì‚¬ìš©ë©ë‹ˆë‹¤.

    rembg ìƒíƒœ:
        - ready: rembg ì„¤ì¹˜ + í•„ìˆ˜ ëª¨ë¸ ìºì‹œ ì™„ë£Œ
        - degraded: rembg ì„¤ì¹˜ + ì¼ë¶€ ëª¨ë¸ ëˆ„ë½
        - unavailable: rembg ë¯¸ì„¤ì¹˜ ë˜ëŠ” ì‚¬ìš© ë¶ˆê°€
        - pending: preflight ì•„ì§ ì‹¤í–‰ë˜ì§€ ì•ŠìŒ

    Returns:
        HealthResponse: ì„œë²„ ìƒíƒœ ì •ë³´
    """
    # rembg ìƒíƒœ ì¡°íšŒ
    rembg_result = get_rembg_status()

    # ì „ì²´ ì„œë²„ ìƒíƒœ ê²°ì •
    # rembgê°€ unavailableì´ì–´ë„ ì„œë²„ëŠ” ok (ë°°ê²½ ì œê±°ë§Œ ë¹„í™œì„±í™”)
    server_status: Literal["ok", "degraded"] = "ok"
    if rembg_result.status == RembgReadyStatus.UNAVAILABLE:
        # rembg ë¯¸ì‚¬ìš© ê°€ëŠ¥ ì‹œ degradedë¡œ í‘œì‹œ (ì„ íƒì )
        # í˜„ì¬ëŠ” rembg ì—†ì–´ë„ okë¡œ ìœ ì§€ (ì´ë¯¸ì§€ í›„ì²˜ë¦¬ë§Œ ìŠ¤í‚µ)
        server_status = "ok"

    # rembg ì •ë³´ êµ¬ì„±
    rembg_info = RembgHealthInfo(
        status=rembg_result.status.value,
        installed=rembg_result.installed,
        preloaded_models=rembg_result.preloaded_models,
        missing_models=rembg_result.missing_models,
        last_error=rembg_result.last_error,
    )

    return HealthResponse(
        status=server_status,
        version=__version__,
        service="unknown-world-backend",
        rembg=rembg_info,
    )


@app.get("/", tags=["System"])
async def root() -> dict[str, str]:
    """ë£¨íŠ¸ ì—”ë“œí¬ì¸íŠ¸.

    API ì •ë³´ë¥¼ ê°„ëµíˆ ì•ˆë‚´í•©ë‹ˆë‹¤.

    Returns:
        dict: ê¸°ë³¸ ì•ˆë‚´ ë©”ì‹œì§€
    """
    return {
        "message": "Unknown World API",
        "docs": "/docs",
        "health": "/health",
    }
</file>

<file path="frontend/src/schemas/turn.ts">
/**
 * Unknown World - TurnInput/TurnOutput Zod ìŠ¤í‚¤ë§ˆ.
 *
 * ì´ ëª¨ë“ˆì€ ë°±ì—”ë“œ Pydantic ëª¨ë¸(U-005)ê³¼ 1:1 ëŒ€ì‘í•˜ëŠ” Zod ìŠ¤í‚¤ë§ˆë¥¼ ì •ì˜í•©ë‹ˆë‹¤.
 * í´ë¼ì´ì–¸íŠ¸ ì¸¡ ê²€ì¦ ë° íƒ€ì… ì•ˆì „ì„±ì„ ì œê³µí•©ë‹ˆë‹¤.
 *
 * ì„¤ê³„ ì›ì¹™:
 *   - RULE-003: êµ¬ì¡°í™” ì¶œë ¥(JSON Schema) ìš°ì„  + ì´ì¤‘ ê²€ì¦ (ì„œë²„ Pydantic + í´ë¼ Zod)
 *   - RULE-004: ê²€ì¦ ì‹¤íŒ¨ ì‹œ ì•ˆì „ í´ë°± ì œê³µ (UI ë©ˆì¶¤ ë°©ì§€)
 *   - RULE-005: ì¬í™” ì¸ë°”ë¦¬ì–¸íŠ¸ (cost, balance_after í•„ìˆ˜, ì”ì•¡ ìŒìˆ˜ ê¸ˆì§€)
 *   - RULE-006: ko/en ì–¸ì–´ ì •ì±… (Language enumìœ¼ë¡œ ê³ ì •)
 *   - RULE-009: ì¢Œí‘œ ê·œì•½ (0~1000, bbox [ymin,xmin,ymax,xmax])
 *
 * Q1 ê²°ì • ì‚¬í•­:
 *   - schema_version í¬í•¨ (Option A): SaveGame/ë§ˆì´ê·¸ë ˆì´ì…˜/ê²€ì¦ì— ìœ ë¦¬
 *
 * @module schemas/turn
 */

import { z } from 'zod';

// =============================================================================
// ìŠ¤í‚¤ë§ˆ ë²„ì „ (Q1 ê²°ì •: Option A - í¬í•¨)
// =============================================================================

/**
 * í˜„ì¬ ìŠ¤í‚¤ë§ˆ ë²„ì „.
 * SaveGame/ë§ˆì´ê·¸ë ˆì´ì…˜/ê²€ì¦ì— ì‚¬ìš©ë©ë‹ˆë‹¤.
 */
export const SCHEMA_VERSION = '1.0.0' as const;

// =============================================================================
// ê³µí†µ Enum íƒ€ì…
// =============================================================================

/**
 * ì§€ì› ì–¸ì–´ (RULE-006).
 * ko/en í˜¼í•© ì¶œë ¥ ê¸ˆì§€. TurnInput.languageë¥¼ SSOTë¡œ ì‚¼ì•„
 * ëª¨ë“  UI/ë‚´ëŸ¬í‹°ë¸Œ/ì‹œìŠ¤í…œ ë©”ì‹œì§€ëŠ” ë™ì¼ ì–¸ì–´ë¡œ ê³ ì •í•©ë‹ˆë‹¤.
 */
export const LanguageSchema = z.enum(['ko-KR', 'en-US']);
export type Language = z.infer<typeof LanguageSchema>;

/**
 * í…Œë§ˆ ì„¤ì •.
 */
export const ThemeSchema = z.enum(['dark', 'light']);
export type Theme = z.infer<typeof ThemeSchema>;

/**
 * ì—ì´ì „íŠ¸ ì‹¤í–‰ ë‹¨ê³„ (RULE-008).
 * ì—ì´ì „íŠ¸í˜• ì‹œìŠ¤í…œì„ì„ UIë¡œ ì¦ëª…í•˜ê¸° ìœ„í•œ ë‹¨ê³„ í‘œì‹œ.
 */
export const AgentPhaseSchema = z.enum([
  'parse',
  'validate',
  'plan',
  'resolve',
  'render',
  'verify',
  'commit',
]);
export type AgentPhase = z.infer<typeof AgentPhaseSchema>;

/**
 * ê²€ì¦ ë°°ì§€ (RULE-008).
 * í„´ ê²°ê³¼ì— ëŒ€í•œ ê²€ì¦ ìƒíƒœë¥¼ í‘œì‹œí•©ë‹ˆë‹¤.
 */
export const ValidationBadgeSchema = z.enum([
  'schema_ok',
  'schema_fail',
  'economy_ok',
  'economy_fail',
  'safety_ok',
  'safety_blocked',
  'consistency_ok',
  'consistency_fail',
]);
export type ValidationBadge = z.infer<typeof ValidationBadgeSchema>;

/**
 * ëª¨ë¸/í’ˆì§ˆ ì„ íƒ ë¼ë²¨ (RULE-008).
 * í”„ë¡¬í”„íŠ¸ ë…¸ì¶œ ì—†ì´ "ì™œ ì´ ì„ íƒì´ì—ˆëŠ”ì§€"ë¥¼ ì‚¬ìš©ì ì¹œí™” ë¼ë²¨ë¡œ í‘œì‹œ.
 */
export const ModelLabelSchema = z.enum(['FAST', 'QUALITY', 'CHEAP', 'REF']);
export type ModelLabel = z.infer<typeof ModelLabelSchema>;

/**
 * í–‰ë™ ìœ„í—˜ë„ ìˆ˜ì¤€.
 */
export const RiskLevelSchema = z.enum(['low', 'medium', 'high']);
export type RiskLevel = z.infer<typeof RiskLevelSchema>;

// =============================================================================
// ê³µí†µ í•˜ìœ„ íƒ€ì…
// =============================================================================

/**
 * ì •ê·œí™” ì¢Œí‘œ (RULE-009).
 * 0~1000 ë²”ìœ„ì˜ ì •ìˆ˜ì…ë‹ˆë‹¤.
 */
export const CoordinateSchema = z.number().int().min(0).max(1000).describe('ì •ê·œí™” ì¢Œí‘œ (0~1000)');
export type Coordinate = z.infer<typeof CoordinateSchema>;

/**
 * 2D ë°”ìš´ë”© ë°•ìŠ¤ (RULE-009).
 * ì¢Œí‘œëŠ” 0~1000 ì •ê·œí™” ì¢Œí‘œê³„ì´ë©°, bboxëŠ” [ymin, xmin, ymax, xmax] ìˆœì„œì…ë‹ˆë‹¤.
 * ì´ë¯¸ì§€ ì´í•´ bbox í¬ë§·ê³¼ í˜¸í™˜ë©ë‹ˆë‹¤.
 */
export const Box2DSchema = z
  .object({
    ymin: CoordinateSchema.describe('Y ìµœì†Œê°’ (ìƒë‹¨)'),
    xmin: CoordinateSchema.describe('X ìµœì†Œê°’ (ì¢Œì¸¡)'),
    ymax: CoordinateSchema.describe('Y ìµœëŒ€ê°’ (í•˜ë‹¨)'),
    xmax: CoordinateSchema.describe('X ìµœëŒ€ê°’ (ìš°ì¸¡)'),
  })
  .strict();
export type Box2D = z.infer<typeof Box2DSchema>;

/**
 * ì¬í™” ìˆ˜ëŸ‰.
 * signalê³¼ memory_shardëŠ” 0 ì´ìƒì´ì–´ì•¼ í•©ë‹ˆë‹¤ (RULE-005).
 */
export const CurrencyAmountSchema = z
  .object({
    signal: z.number().int().min(0).describe('ì‹œê·¸ë„ (ê¸°ë³¸ ì¬í™”, 0 ì´ìƒ)'),
    memory_shard: z.number().int().min(0).describe('ê¸°ì–µ íŒŒí¸ (í¬ê·€ ì¬í™”, 0 ì´ìƒ)'),
  })
  .strict();
export type CurrencyAmount = z.infer<typeof CurrencyAmountSchema>;

// =============================================================================
// TurnInput ê´€ë ¨ íƒ€ì…
// =============================================================================

/**
 * í´ë¦­ ì…ë ¥ ì •ë³´.
 * í™”ë©´ ì˜¤ë¸Œì íŠ¸ í´ë¦­ ì‹œ ì „ë‹¬ë˜ëŠ” ì •ë³´ì…ë‹ˆë‹¤.
 */
export const ClickInputSchema = z
  .object({
    object_id: z.string().describe('í´ë¦­í•œ ì˜¤ë¸Œì íŠ¸ ID'),
    box_2d: Box2DSchema.nullable().default(null).describe('í´ë¦­ ìœ„ì¹˜ ë°”ìš´ë”© ë°•ìŠ¤ (ì„ íƒ)'),
  })
  .strict();
export type ClickInput = z.infer<typeof ClickInputSchema>;

/**
 * ë“œë¡­ ì…ë ¥ ì •ë³´ (U-012).
 * ì¸ë²¤í† ë¦¬ ì•„ì´í…œì„ í•«ìŠ¤íŒŸì— ë“œë¡­í•  ë•Œ ì „ë‹¬ë˜ëŠ” ì •ë³´ì…ë‹ˆë‹¤.
 * Q1 ê²°ì •: Option B - target_box_2d í¬í•¨í•˜ì—¬ ì„œë²„ê°€ ì •í™•í•œ ìœ„ì¹˜ í•´ì„ ê°€ëŠ¥.
 */
export const DropInputSchema = z
  .object({
    item_id: z.string().describe('ë“œë¡­í•œ ì¸ë²¤í† ë¦¬ ì•„ì´í…œ ID'),
    target_object_id: z.string().describe('ë“œë¡­ ëŒ€ìƒ í•«ìŠ¤íŒŸ ì˜¤ë¸Œì íŠ¸ ID'),
    target_box_2d: Box2DSchema.describe('ë“œë¡­ ëŒ€ìƒì˜ ë°”ìš´ë”© ë°•ìŠ¤ (0~1000 ì •ê·œí™”)'),
  })
  .strict();
export type DropInput = z.infer<typeof DropInputSchema>;

/**
 * í´ë¼ì´ì–¸íŠ¸ ì •ë³´.
 */
export const ClientInfoSchema = z
  .object({
    viewport_w: z.number().int().positive().describe('ë·°í¬íŠ¸ ë„ˆë¹„ (í”½ì…€, ì–‘ìˆ˜)'),
    viewport_h: z.number().int().positive().describe('ë·°í¬íŠ¸ ë†’ì´ (í”½ì…€, ì–‘ìˆ˜)'),
    theme: ThemeSchema.default('dark').describe('í˜„ì¬ í…Œë§ˆ'),
  })
  .strict();
export type ClientInfo = z.infer<typeof ClientInfoSchema>;

/**
 * ì¬í™” ìŠ¤ëƒ…ìƒ· (í´ë¼ì´ì–¸íŠ¸ â†’ ì„œë²„).
 * í´ë¼ì´ì–¸íŠ¸ê°€ ë³´ìœ í•œ í˜„ì¬ ì¬í™” ìƒíƒœì…ë‹ˆë‹¤.
 */
export const EconomySnapshotSchema = z
  .object({
    signal: z.number().int().min(0).describe('í˜„ì¬ ì‹œê·¸ë„ ì”ì•¡ (0 ì´ìƒ)'),
    memory_shard: z.number().int().min(0).describe('í˜„ì¬ ê¸°ì–µ íŒŒí¸ ì”ì•¡ (0 ì´ìƒ)'),
  })
  .strict();
export type EconomySnapshot = z.infer<typeof EconomySnapshotSchema>;

/**
 * í„´ ì…ë ¥ (í´ë¼ì´ì–¸íŠ¸ â†’ ì„œë²„).
 * ì‚¬ìš©ìê°€ í„´ì„ ì§„í–‰í•  ë•Œ ì„œë²„ë¡œ ì „ì†¡í•˜ëŠ” ì…ë ¥ ë°ì´í„°ì…ë‹ˆë‹¤.
 *
 * U-012: drop í•„ë“œ ì¶”ê°€ - ì¸ë²¤í† ë¦¬ ì•„ì´í…œì„ í•«ìŠ¤íŒŸì— ë“œë¡­í•  ë•Œ ì‚¬ìš©.
 */
export const TurnInputSchema = z
  .object({
    language: LanguageSchema.describe('ìš”ì²­ ì–¸ì–´ (ì‘ë‹µë„ ë™ì¼ ì–¸ì–´ë¡œ ê³ ì •)'),
    text: z.string().default('').describe('ì‚¬ìš©ì ìì—°ì–´ ì…ë ¥'),
    action_id: z.string().nullable().default(null).describe('ì„ íƒí•œ ì•¡ì…˜ ì¹´ë“œ ID (ì„ íƒ)'),
    click: ClickInputSchema.nullable().default(null).describe('ì˜¤ë¸Œì íŠ¸ í´ë¦­ ì •ë³´ (ì„ íƒ)'),
    drop: DropInputSchema.nullable().default(null).describe('ì•„ì´í…œ ë“œë¡­ ì •ë³´ (ì„ íƒ, U-012)'),
    client: ClientInfoSchema.describe('í´ë¼ì´ì–¸íŠ¸ í™˜ê²½ ì •ë³´'),
    economy_snapshot: EconomySnapshotSchema.describe('í˜„ì¬ ì¬í™” ìƒíƒœ'),
  })
  .strict();
export type TurnInput = z.infer<typeof TurnInputSchema>;

// =============================================================================
// TurnOutput ê´€ë ¨ íƒ€ì… - UI
// =============================================================================

/**
 * ë¹„ìš© ì¶”ì •ì¹˜ (U-009: ìµœì†Œ/ìµœëŒ€ ë²”ìœ„).
 * í–‰ë™ì˜ ì˜ˆìƒ ë¹„ìš© ë²”ìœ„ë¥¼ í‘œì‹œí•©ë‹ˆë‹¤.
 */
export const CostEstimateSchema = z
  .object({
    min: CurrencyAmountSchema.describe('ìµœì†Œ ì˜ˆìƒ ë¹„ìš©'),
    max: CurrencyAmountSchema.describe('ìµœëŒ€ ì˜ˆìƒ ë¹„ìš©'),
  })
  .strict();
export type CostEstimate = z.infer<typeof CostEstimateSchema>;

/**
 * ì•¡ì…˜ ì¹´ë“œ (Action Deck).
 * ë§¤ í„´ AIê°€ ì¶”ì²œí•˜ëŠ” í–‰ë™ ì¹´ë“œì…ë‹ˆë‹¤.
 *
 * U-009 í™•ì¥:
 *   - cost_estimate: ìµœì†Œ/ìµœëŒ€ ë¹„ìš© ë²”ìœ„ (RULE-005)
 *   - enabled: ì„œë²„ ì¸¡ ì‹¤í–‰ ê°€ëŠ¥ ì—¬ë¶€ íŒë‹¨ (Q1: Option A)
 *   - disabled_reason: ë¹„í™œì„±í™” ì‚¬ìœ  (ì”ì•¡ ë¶€ì¡± ë“±)
 *   - is_alternative: ì €ë¹„ìš©/í…ìŠ¤íŠ¸-only ëŒ€ì•ˆ ì¹´ë“œ ì—¬ë¶€
 */
export const ActionCardSchema = z
  .object({
    id: z.string().describe('ì¹´ë“œ ê³ ìœ  ID'),
    label: z.string().describe('ì¹´ë“œ ë¼ë²¨ (í‘œì‹œìš©)'),
    description: z.string().nullable().default(null).describe('ì¹´ë“œ ì„¤ëª… (ì„ íƒ)'),
    cost: CurrencyAmountSchema.describe('ì˜ˆìƒ ë¹„ìš© (ê¸°ë³¸)'),
    cost_estimate: CostEstimateSchema.nullable().default(null).describe('ë¹„ìš© ì¶”ì • ë²”ìœ„ (ì„ íƒ)'),
    risk: RiskLevelSchema.default('low').describe('ìœ„í—˜ë„'),
    hint: z.string().nullable().default(null).describe('ì˜ˆìƒ ê²°ê³¼ íŒíŠ¸ (ì„ íƒ)'),
    reward_hint: z.string().nullable().default(null).describe('ë³´ìƒ íŒíŠ¸ (ì„ íƒ)'),
    enabled: z.boolean().default(true).describe('ì‹¤í–‰ ê°€ëŠ¥ ì—¬ë¶€ (ì„œë²„ íŒë‹¨)'),
    disabled_reason: z.string().nullable().default(null).describe('ë¹„í™œì„±í™” ì‚¬ìœ  (ì„ íƒ)'),
    is_alternative: z.boolean().default(false).describe('ì €ë¹„ìš© ëŒ€ì•ˆ ì¹´ë“œ ì—¬ë¶€'),
  })
  .strict();
export type ActionCard = z.infer<typeof ActionCardSchema>;

/**
 * ì¥ë©´ ì˜¤ë¸Œì íŠ¸ (í´ë¦­ ê°€ëŠ¥í•œ í•«ìŠ¤íŒŸ).
 * ì¢Œí‘œëŠ” 0~1000 ì •ê·œí™” ì¢Œí‘œê³„ë¥¼ ì‚¬ìš©í•©ë‹ˆë‹¤ (RULE-009).
 */
export const SceneObjectSchema = z
  .object({
    id: z.string().describe('ì˜¤ë¸Œì íŠ¸ ê³ ìœ  ID'),
    label: z.string().describe('ì˜¤ë¸Œì íŠ¸ ë¼ë²¨ (í‘œì‹œìš©)'),
    box_2d: Box2DSchema.describe('ë°”ìš´ë”© ë°•ìŠ¤'),
    interaction_hint: z.string().nullable().default(null).describe('ìƒí˜¸ì‘ìš© íŒíŠ¸ (ì„ íƒ)'),
  })
  .strict();
export type SceneObject = z.infer<typeof SceneObjectSchema>;

/**
 * ì•¡ì…˜ ë± (Q1 ê²°ì •: ui.action_deck.cards[] êµ¬ì¡°).
 * ë§¤ í„´ AIê°€ ì œì‹œí•˜ëŠ” ì¶”ì²œ í–‰ë™ ì¹´ë“œ ë±ì…ë‹ˆë‹¤.
 */
export const ActionDeckSchema = z
  .object({
    cards: z.array(ActionCardSchema).max(10).default([]).describe('ì•¡ì…˜ ì¹´ë“œ ëª©ë¡ (3~6ì¥ ê¶Œì¥)'),
  })
  .strict();
export type ActionDeck = z.infer<typeof ActionDeckSchema>;

/**
 * Scene í‘œì‹œ ì •ë³´ (RU-003-T1: Scene ì´ë¯¸ì§€ SSOT).
 *
 * TurnOutputì—ì„œ Scene Canvasì— í‘œì‹œí•  ì´ë¯¸ì§€ ì •ë³´ë¥¼ ì œê³µí•©ë‹ˆë‹¤.
 * image_urlì´ ì¡´ì¬í•˜ë©´ SceneCanvasëŠ” 'scene' ìƒíƒœë¡œ ì „í™˜ë©ë‹ˆë‹¤.
 * image_urlì´ ì—†ìœ¼ë©´ 'default' ìƒíƒœë¥¼ ìœ ì§€í•©ë‹ˆë‹¤.
 */
export const SceneOutputSchema = z
  .object({
    image_url: z
      .string()
      .nullable()
      .default(null)
      .describe('Scene ì´ë¯¸ì§€ URL (ì¡´ì¬ ì‹œ scene ìƒíƒœë¡œ ì „í™˜)'),
    alt_text: z.string().nullable().default(null).describe('ì´ë¯¸ì§€ ëŒ€ì²´ í…ìŠ¤íŠ¸ (ì ‘ê·¼ì„±ìš©, ì„ íƒ)'),
  })
  .strict();
export type SceneOutput = z.infer<typeof SceneOutputSchema>;

/**
 * Scene ê¸°ë³¸ê°’ (null ëŒ€ì‘).
 */
const DEFAULT_SCENE_OUTPUT: SceneOutput = { image_url: null, alt_text: null };

/**
 * UI ì¶œë ¥ ë°ì´í„°.
 * AIê°€ ìƒì„±í•œ UI ìš”ì†Œë“¤ì…ë‹ˆë‹¤.
 * ì±„íŒ… ë²„ë¸”ì´ ì•„ë‹Œ ê²Œì„ UIë¡œ í‘œí˜„ë©ë‹ˆë‹¤ (RULE-002).
 *
 * RU-003-T1: scene í•„ë“œ ì¶”ê°€ - Scene Canvasì˜ ì´ë¯¸ì§€ í‘œì‹œ ì •ë³´ SSOT.
 *
 * ìˆ˜ì •: scene í•„ë“œëŠ” ë°±ì—”ë“œì—ì„œ nullë¡œ ì˜¬ ìˆ˜ ìˆìœ¼ë¯€ë¡œ nullish()ë¥¼ ì‚¬ìš©í•˜ì—¬
 * null/undefined ì‹œ ê¸°ë³¸ê°’ìœ¼ë¡œ ë³€í™˜í•©ë‹ˆë‹¤.
 */
export const UIOutputSchema = z
  .object({
    action_deck: ActionDeckSchema.default({ cards: [] }).describe('ì•¡ì…˜ ì¹´ë“œ ë±'),
    objects: z.array(SceneObjectSchema).default([]).describe('í´ë¦­ ê°€ëŠ¥í•œ ì¥ë©´ ì˜¤ë¸Œì íŠ¸ ëª©ë¡'),
    scene: SceneOutputSchema.nullish()
      .transform((val) => val ?? DEFAULT_SCENE_OUTPUT)
      .describe('Scene í‘œì‹œ ì •ë³´ (RU-003-T1, null í—ˆìš©)'),
  })
  .strict();
export type UIOutput = z.infer<typeof UIOutputSchema>;

// =============================================================================
// TurnOutput ê´€ë ¨ íƒ€ì… - World
// =============================================================================

/**
 * ì¤‘ìš” ì„¤ì • ê³ ì • í›„ë³´.
 * ì‚¬ìš©ìê°€ Memory Shardë¥¼ ì†Œë¹„í•´ ê³ ì •í•  ìˆ˜ ìˆëŠ” ì¤‘ìš” ì„¤ì •ì…ë‹ˆë‹¤.
 */
export const MemoryPinSchema = z
  .object({
    id: z.string().describe('í•€ ê³ ìœ  ID'),
    content: z.string().describe('ê³ ì •í•  ë‚´ìš©'),
    cost: CurrencyAmountSchema.describe('ê³ ì •ì— í•„ìš”í•œ ë¹„ìš©'),
  })
  .strict();
export type MemoryPin = z.infer<typeof MemoryPinSchema>;

/**
 * ì„¸ê³„ ê·œì¹™ (Rule Board).
 * í˜„ì¬ ì„¸ê³„ì— ì ìš© ì¤‘ì¸ ë¬¼ë¦¬ ë²•ì¹™ì´ë‚˜ ë©”íƒ€ ê·œì¹™ì…ë‹ˆë‹¤.
 */
export const WorldRuleSchema = z
  .object({
    id: z.string().describe('ê·œì¹™ ê³ ìœ  ID'),
    label: z.string().describe('ê·œì¹™ ì´ë¦„'),
    description: z.string().nullable().default(null).describe('ê·œì¹™ ìƒì„¸ ì„¤ëª… (ì„ íƒ)'),
  })
  .strict();
export type WorldRule = z.infer<typeof WorldRuleSchema>;

/**
 * í€˜ìŠ¤íŠ¸/ëª©í‘œ (Quest Panel).
 * í”Œë ˆì´ì–´ê°€ ë‹¬ì„±í•´ì•¼ í•˜ëŠ” í˜„ì¬ ëª©í‘œì…ë‹ˆë‹¤.
 */
export const QuestSchema = z
  .object({
    id: z.string().describe('í€˜ìŠ¤íŠ¸ ê³ ìœ  ID'),
    label: z.string().describe('í€˜ìŠ¤íŠ¸ ì´ë¦„'),
    is_completed: z.boolean().default(false).describe('ë‹¬ì„± ì—¬ë¶€'),
  })
  .strict();
export type Quest = z.infer<typeof QuestSchema>;

/**
 * ì„¸ê³„ ìƒíƒœ ë³€í™” (Q2 ê²°ì •: Option A - delta ì¤‘ì‹¬).
 * ì´ë²ˆ í„´ì—ì„œ ë³€ê²½ëœ ì„¸ê³„ ìƒíƒœë¥¼ ë‚˜íƒ€ëƒ…ë‹ˆë‹¤.
 */
export const WorldDeltaSchema = z
  .object({
    rules_changed: z.array(WorldRuleSchema).default([]).describe('ë³€ê²½ëœ ê·œì¹™ ëª©ë¡'),
    inventory_added: z.array(z.string()).default([]).describe('ì¶”ê°€ëœ ì¸ë²¤í† ë¦¬ ì•„ì´í…œ'),
    inventory_removed: z.array(z.string()).default([]).describe('ì œê±°ëœ ì¸ë²¤í† ë¦¬ ì•„ì´í…œ'),
    quests_updated: z.array(QuestSchema).default([]).describe('ì—…ë°ì´íŠ¸ëœ í€˜ìŠ¤íŠ¸/ëª©í‘œ ëª©ë¡'),
    relationships_changed: z.array(z.string()).default([]).describe('ë³€ê²½ëœ ê´€ê³„'),
    memory_pins: z.array(MemoryPinSchema).default([]).describe('ì¤‘ìš” ì„¤ì • ê³ ì • í›„ë³´'),
  })
  .strict();
export type WorldDelta = z.infer<typeof WorldDeltaSchema>;

// =============================================================================
// TurnOutput ê´€ë ¨ íƒ€ì… - Render
// =============================================================================

/**
 * ì´ë¯¸ì§€ ìƒì„± ì‘ì—….
 * ì¡°ê±´ë¶€ ì´ë¯¸ì§€ ìƒì„±/í¸ì§‘ ìš”ì²­ì…ë‹ˆë‹¤.
 *
 * U-035: remove_background, image_type_hint í•„ë“œ ì¶”ê°€ (rembg ë°°ê²½ ì œê±°)
 */
export const ImageJobSchema = z
  .object({
    should_generate: z.boolean().describe('ì´ë¯¸ì§€ë¥¼ ìƒì„±í•´ì•¼ í•˜ëŠ”ì§€'),
    prompt: z.string().default('').describe('ì´ë¯¸ì§€ ìƒì„± í”„ë¡¬í”„íŠ¸'),
    model_label: ModelLabelSchema.default('FAST').describe('ëª¨ë¸ ì„ íƒ ë¼ë²¨'),
    aspect_ratio: z.string().default('16:9').describe('ê°€ë¡œì„¸ë¡œ ë¹„ìœ¨'),
    image_size: z.string().default('1024x1024').describe('ì´ë¯¸ì§€ í¬ê¸°'),
    reference_image_ids: z.array(z.string()).default([]).describe('ì°¸ì¡° ì´ë¯¸ì§€ ID ëª©ë¡ (ì„ íƒ)'),
    remove_background: z.boolean().default(false).describe('ë°°ê²½ ì œê±° ì—¬ë¶€ (U-035, rembg ì‚¬ìš©)'),
    image_type_hint: z
      .string()
      .nullable()
      .default(null)
      .describe('ì´ë¯¸ì§€ ìœ í˜• íŒíŠ¸ (object/character/icon ë“±, rembg ëª¨ë¸ ì„ íƒìš©)'),
  })
  .strict();
export type ImageJob = z.infer<typeof ImageJobSchema>;

/**
 * ë Œë”ë§ ì¶œë ¥ ë°ì´í„°.
 * ì´ë¯¸ì§€ ìƒì„±/í¸ì§‘ ê´€ë ¨ ì •ë³´ì…ë‹ˆë‹¤.
 */
export const RenderOutputSchema = z
  .object({
    image_job: ImageJobSchema.nullable().default(null).describe('ì´ë¯¸ì§€ ìƒì„± ì‘ì—… (ì„ íƒ)'),
  })
  .strict();
export type RenderOutput = z.infer<typeof RenderOutputSchema>;

// =============================================================================
// TurnOutput ê´€ë ¨ íƒ€ì… - Economy
// =============================================================================

/**
 * ê²½ì œ ì¶œë ¥ ë°ì´í„° (RULE-005).
 * ì´ë²ˆ í„´ì˜ ë¹„ìš©ê³¼ ì”ì•¡ ì •ë³´ì…ë‹ˆë‹¤.
 * ì”ì•¡ ìŒìˆ˜ëŠ” ì ˆëŒ€ ë¶ˆê°€ (ì„œë²„ Hard gate).
 */
export const EconomyOutputSchema = z
  .object({
    cost: CurrencyAmountSchema.describe('ì´ë²ˆ í„´ì— ì†Œë¹„ëœ ë¹„ìš©'),
    balance_after: CurrencyAmountSchema.describe('ì†Œë¹„ í›„ ì”ì•¡'),
  })
  .strict();
export type EconomyOutput = z.infer<typeof EconomyOutputSchema>;

// =============================================================================
// TurnOutput ê´€ë ¨ íƒ€ì… - Safety
// =============================================================================

/**
 * ì•ˆì „ ì¶œë ¥ ë°ì´í„°.
 * ì•ˆì „ ì •ì±… ê´€ë ¨ ì •ë³´ì…ë‹ˆë‹¤.
 * ì°¨ë‹¨ ì‹œ ëª…ì‹œì  ë©”ì‹œì§€ì™€ í•¨ê»˜ ì•ˆì „í•œ ëŒ€ì²´ ê²°ê³¼ë¥¼ ì œê³µí•©ë‹ˆë‹¤.
 */
export const SafetyOutputSchema = z
  .object({
    blocked: z.boolean().default(false).describe('ì•ˆì „ ì •ì±…ì— ì˜í•´ ì°¨ë‹¨ë˜ì—ˆëŠ”ì§€'),
    message: z
      .string()
      .nullable()
      .default(null)
      .describe('ì°¨ë‹¨ ì‹œ ì‚¬ìš©ìì—ê²Œ í‘œì‹œí•  ë©”ì‹œì§€ (ì„ íƒ)'),
  })
  .strict();
export type SafetyOutput = z.infer<typeof SafetyOutputSchema>;

// =============================================================================
// TurnOutput ê´€ë ¨ íƒ€ì… - Agent Console
// =============================================================================

/**
 * ì—ì´ì „íŠ¸ ì½˜ì†” ë°ì´í„° (RULE-008).
 * ì—ì´ì „íŠ¸í˜• ì‹œìŠ¤í…œì„ì„ UIë¡œ ì¦ëª…í•˜ê¸° ìœ„í•œ ì •ë³´ì…ë‹ˆë‹¤.
 */
export const AgentConsoleSchema = z
  .object({
    current_phase: AgentPhaseSchema.default('commit').describe('í˜„ì¬ ì‹¤í–‰ ë‹¨ê³„'),
    badges: z.array(ValidationBadgeSchema).default([]).describe('ê²€ì¦ ë°°ì§€ ëª©ë¡'),
    repair_count: z.number().int().min(0).default(0).describe('ìë™ ë³µêµ¬ ì‹œë„ íšŸìˆ˜'),
  })
  .strict();
export type AgentConsole = z.infer<typeof AgentConsoleSchema>;

// =============================================================================
// TurnOutput (ë©”ì¸ ì‘ë‹µ ìŠ¤í‚¤ë§ˆ)
// =============================================================================

/**
 * í„´ ì¶œë ¥ (ì„œë²„ â†’ í´ë¼ì´ì–¸íŠ¸).
 * ì„œë²„ê°€ í„´ ì²˜ë¦¬ í›„ í´ë¼ì´ì–¸íŠ¸ë¡œ ë°˜í™˜í•˜ëŠ” êµ¬ì¡°í™”ëœ ì‘ë‹µì…ë‹ˆë‹¤.
 *
 * Hard Gate í•„ë“œ (RULE-003/004/005):
 *   - economy: costì™€ balance_after í•„ìˆ˜, ì”ì•¡ ìŒìˆ˜ ê¸ˆì§€
 *   - safety: blocked ì‹œ ì•ˆì „í•œ ëŒ€ì²´ ê²°ê³¼ ì œê³µ
 *   - language: ìš”ì²­ ì–¸ì–´ì™€ ë™ì¼í•˜ê²Œ ê³ ì • (í˜¼í•© ì¶œë ¥ ê¸ˆì§€)
 */
export const TurnOutputSchema = z
  .object({
    // í•„ìˆ˜ í•„ë“œ (Hard Gate)
    language: LanguageSchema.describe('ì‘ë‹µ ì–¸ì–´ (ìš”ì²­ê³¼ ë™ì¼)'),
    narrative: z.string().describe('ë‚´ëŸ¬í‹°ë¸Œ í…ìŠ¤íŠ¸ (í‘œì‹œìš©)'),
    economy: EconomyOutputSchema.describe('ê²½ì œ ì •ë³´ (ë¹„ìš©, ì”ì•¡)'),
    safety: SafetyOutputSchema.describe('ì•ˆì „ ì •ì±… ì •ë³´'),

    // UI ê´€ë ¨ í•„ë“œ (RU-003-T1: scene í•„ë“œ ì¶”ê°€)
    ui: UIOutputSchema.default({
      action_deck: { cards: [] },
      objects: [],
      scene: { image_url: null, alt_text: null },
    }).describe('UI ìš”ì†Œ'),

    // ì„¸ê³„ ìƒíƒœ í•„ë“œ
    world: WorldDeltaSchema.default({
      rules_changed: [],
      inventory_added: [],
      inventory_removed: [],
      quests_updated: [],
      relationships_changed: [],
      memory_pins: [],
    }).describe('ì„¸ê³„ ìƒíƒœ ë³€í™” (delta)'),

    // ë Œë”ë§ í•„ë“œ
    render: RenderOutputSchema.default({ image_job: null }).describe('ë Œë”ë§ ì •ë³´'),

    // ì—ì´ì „íŠ¸ ì½˜ì†” í•„ë“œ
    agent_console: AgentConsoleSchema.default({
      current_phase: 'commit',
      badges: [],
      repair_count: 0,
    }).describe('ì—ì´ì „íŠ¸ ì‹¤í–‰ ì •ë³´'),
  })
  .strict();
export type TurnOutput = z.infer<typeof TurnOutputSchema>;

// =============================================================================
// ì•ˆì „ í´ë°± (RULE-004)
// =============================================================================

/**
 * ê²€ì¦ ì‹¤íŒ¨ ì‹œ ì œê³µë˜ëŠ” ì•ˆì „ í´ë°± TurnOutput.
 * UIê°€ ë©ˆì¶”ì§€ ì•Šë„ë¡ ìµœì†Œí•œì˜ ì •ë³´ë¥¼ ì œê³µí•©ë‹ˆë‹¤.
 *
 * @param language - ìš”ì²­ ì–¸ì–´
 * @param repairCount - ë³µêµ¬ ì‹œë„ íšŸìˆ˜
 * @param errorMessage - ì˜¤ë¥˜ ë©”ì‹œì§€ (ì„ íƒ)
 */
export function createFallbackTurnOutput(
  language: Language,
  repairCount: number = 0,
  errorMessage?: string,
): TurnOutput {
  const fallbackNarrative =
    language === 'ko-KR'
      ? '[ì‹œìŠ¤í…œ] ì‘ë‹µì„ ì²˜ë¦¬í•˜ëŠ” ì¤‘ ë¬¸ì œê°€ ë°œìƒí–ˆìŠµë‹ˆë‹¤. ë‹¤ì‹œ ì‹œë„í•´ ì£¼ì„¸ìš”.'
      : '[System] An error occurred while processing the response. Please try again.';

  const safetyMessage =
    language === 'ko-KR'
      ? 'ìŠ¤í‚¤ë§ˆ ê²€ì¦ ì‹¤íŒ¨ë¡œ ì¸í•œ í´ë°± ì‘ë‹µì…ë‹ˆë‹¤.'
      : 'This is a fallback response due to schema validation failure.';

  return {
    language,
    narrative: errorMessage ?? fallbackNarrative,
    economy: {
      cost: { signal: 0, memory_shard: 0 },
      balance_after: { signal: 0, memory_shard: 0 },
    },
    safety: {
      blocked: false,
      message: safetyMessage,
    },
    ui: {
      action_deck: { cards: [] },
      objects: [],
      scene: { image_url: null, alt_text: null },
    },
    world: {
      rules_changed: [],
      inventory_added: [],
      inventory_removed: [],
      quests_updated: [],
      relationships_changed: [],
      memory_pins: [],
    },
    render: {
      image_job: null,
    },
    agent_console: {
      current_phase: 'commit',
      badges: ['schema_fail'],
      repair_count: repairCount,
    },
  };
}

// =============================================================================
// ê²€ì¦ í—¬í¼ í•¨ìˆ˜
// =============================================================================

/**
 * TurnOutput ê²€ì¦ ê²°ê³¼ íƒ€ì….
 */
export type TurnOutputParseResult =
  | { success: true; data: TurnOutput }
  | { success: false; error: z.ZodError; fallback: TurnOutput };

/**
 * TurnOutputì„ ì•ˆì „í•˜ê²Œ íŒŒì‹±í•©ë‹ˆë‹¤.
 * ì‹¤íŒ¨ ì‹œ í´ë°± TurnOutputì„ ë°˜í™˜í•©ë‹ˆë‹¤ (RULE-004).
 *
 * @param data - íŒŒì‹±í•  ë°ì´í„°
 * @param language - í´ë°± ì‹œ ì‚¬ìš©í•  ì–¸ì–´ (ê¸°ë³¸: ko-KR)
 * @param repairCount - í˜„ì¬ ë³µêµ¬ ì‹œë„ íšŸìˆ˜
 */
export function safeParseTurnOutput(
  data: unknown,
  language: Language = 'ko-KR',
  repairCount: number = 0,
): TurnOutputParseResult {
  const result = TurnOutputSchema.safeParse(data);

  if (result.success) {
    return { success: true, data: result.data };
  }

  return {
    success: false,
    error: result.error,
    fallback: createFallbackTurnOutput(language, repairCount),
  };
}

/**
 * TurnInputì„ ê²€ì¦í•©ë‹ˆë‹¤.
 * ì…ë ¥ ë°ì´í„°ì˜ ìœ íš¨ì„±ì„ ì—„ê²©í•˜ê²Œ ê²€ì‚¬í•©ë‹ˆë‹¤.
 *
 * @param data - ê²€ì¦í•  ë°ì´í„°
 * @throws {z.ZodError} ê²€ì¦ ì‹¤íŒ¨ ì‹œ
 */
export function parseTurnInput(data: unknown): TurnInput {
  return TurnInputSchema.parse(data);
}

/**
 * TurnInput ì•ˆì „ íŒŒì‹± ê²°ê³¼ íƒ€ì….
 */
export type TurnInputSafeParseResult = ReturnType<typeof TurnInputSchema.safeParse>;

/**
 * TurnInputì„ ì•ˆì „í•˜ê²Œ íŒŒì‹±í•©ë‹ˆë‹¤.
 *
 * @param data - íŒŒì‹±í•  ë°ì´í„°
 */
export function safeParseTurnInput(data: unknown): TurnInputSafeParseResult {
  return TurnInputSchema.safeParse(data);
}
</file>

<file path="backend/src/unknown_world/api/turn.py">
"""Unknown World - /api/turn HTTP Streaming ì—”ë“œí¬ì¸íŠ¸.

POST ìš”ì²­ì„ ë°›ì•„ NDJSON(ë¼ì¸ ë‹¨ìœ„ JSON) ìŠ¤íŠ¸ë¦¬ë°ìœ¼ë¡œ í„´ ê²°ê³¼ë¥¼ ë°˜í™˜í•©ë‹ˆë‹¤.

ì„¤ê³„ ì›ì¹™:
    - RULE-003: êµ¬ì¡°í™” ì¶œë ¥(JSON Schema) ìš°ì„  + Pydantic ê²€ì¦
    - RULE-004: ê²€ì¦ ì‹¤íŒ¨ ì‹œ Repair loop + ì•ˆì „í•œ í´ë°±
    - RULE-005: ì¬í™” ì¸ë°”ë¦¬ì–¸íŠ¸ (ì”ì•¡ ìŒìˆ˜ ê¸ˆì§€)
    - RULE-007: í”„ë¡¬í”„íŠ¸/ë‚´ë¶€ ì¶”ë¡  ë…¸ì¶œ ê¸ˆì§€
    - RULE-008: ë‹¨ê³„/ë°°ì§€ ê°€ì‹œí™”, TTFB 2ì´ˆ ëª©í‘œ

ìŠ¤íŠ¸ë¦¼ ì´ë²¤íŠ¸ íƒ€ì…:
    - stage: ë‹¨ê³„ ì§„í–‰ ìƒíƒœ (Parseâ†’Validateâ†’Planâ†’Resolveâ†’Renderâ†’Verifyâ†’Commit)
    - badges: ê²€ì¦ ë°°ì§€ ëª©ë¡
    - narrative_delta: ë‚´ëŸ¬í‹°ë¸Œ í…ìŠ¤íŠ¸ ì¡°ê° (íƒ€ì íš¨ê³¼ìš©)
    - repair: Auto-repair ì´ë²¤íŠ¸ (U-018)
    - final: ìµœì¢… TurnOutput
    - error: ì—ëŸ¬ ë°œìƒ ì‹œ

ë¦¬íŒ©í† ë§ (RU-005-Q4):
    - ê¸°ì¡´ _stream_turn_events_mock/_realì„ pipeline ê¸°ë°˜ìœ¼ë¡œ í†µí•©
    - API ë ˆì´ì–´ëŠ” ìŠ¤íŠ¸ë¦¬ë° ì§ë ¬í™”/ì „ì†¡ì— ì§‘ì¤‘
    - ì˜¤ì¼€ìŠ¤íŠ¸ë ˆì´ì…˜ ë¡œì§ì€ pipeline.pyë¡œ ìœ„ì„

ì°¸ì¡°:
    - vibe/unit-plans/U-007[Mvp].md
    - vibe/unit-plans/U-018[Mvp].md
    - vibe/refactors/RU-005-Q4.md
    - .cursor/rules/20-backend-orchestrator.mdc
"""

from __future__ import annotations

import asyncio
import contextlib
import time
from collections.abc import AsyncGenerator
from typing import Any, cast

from fastapi import APIRouter, Request
from fastapi.responses import StreamingResponse
from pydantic import ValidationError

from unknown_world.api.turn_stream_events import (
    BadgesEvent,
    NarrativeDeltaEvent,
    RepairEvent,
    StageEvent,
    StageStatus,
    StreamEventType,
    serialize_event,
)
from unknown_world.api.turn_streaming_helpers import (
    emit_error_with_fallback,
    stream_output_with_narrative,
)
from unknown_world.models.turn import (
    CurrencyAmount,
    Language,
    TurnInput,
)
from unknown_world.orchestrator.fallback import create_safe_fallback
from unknown_world.orchestrator.pipeline import create_pipeline_context, run_pipeline
from unknown_world.orchestrator.repair_loop import MAX_REPAIR_ATTEMPTS
from unknown_world.orchestrator.stages.types import (
    PipelineEvent,
    PipelineEventType,
)

# =============================================================================
# ë¼ìš°í„° ì •ì˜
# =============================================================================

router = APIRouter(prefix="/api", tags=["Turn"])


# =============================================================================
# Pipeline Event â†’ Stream Event ë³€í™˜
# =============================================================================


def _convert_pipeline_event(event: PipelineEvent) -> dict[str, Any] | None:
    """íŒŒì´í”„ë¼ì¸ ì´ë²¤íŠ¸ë¥¼ ìŠ¤íŠ¸ë¦¼ ì´ë²¤íŠ¸ë¡œ ë³€í™˜í•©ë‹ˆë‹¤.

    Args:
        event: íŒŒì´í”„ë¼ì¸ ë„ë©”ì¸ ì´ë²¤íŠ¸

    Returns:
        ìŠ¤íŠ¸ë¦¼ ì´ë²¤íŠ¸ dict (serialize_eventì— ì „ë‹¬) ë˜ëŠ” None
    """
    if event.event_type == PipelineEventType.STAGE_START:
        if event.phase is None:
            return None
        return StageEvent(
            type=StreamEventType.STAGE,
            name=event.phase.value,
            status=StageStatus.START,
        ).model_dump()

    if event.event_type == PipelineEventType.STAGE_COMPLETE:
        if event.phase is None:
            return None
        return StageEvent(
            type=StreamEventType.STAGE,
            name=event.phase.value,
            status=StageStatus.COMPLETE,
        ).model_dump()

    if event.event_type == PipelineEventType.STAGE_FAIL:
        if event.phase is None:
            return None
        return StageEvent(
            type=StreamEventType.STAGE,
            name=event.phase.value,
            status=StageStatus.FAIL,
        ).model_dump()

    if event.event_type == PipelineEventType.BADGES:
        if event.badges is None:
            return None
        return BadgesEvent(
            type=StreamEventType.BADGES,
            badges=[b.value for b in event.badges],
        ).model_dump()

    if event.event_type == PipelineEventType.REPAIR:
        return RepairEvent(
            type=StreamEventType.REPAIR,
            attempt=event.repair_attempt,
            message=event.repair_message,
        ).model_dump()

    if event.event_type == PipelineEventType.NARRATIVE_DELTA:
        if event.text is None:
            return None
        return NarrativeDeltaEvent(
            type=StreamEventType.NARRATIVE_DELTA,
            text=event.text,
        ).model_dump()

    return None


# =============================================================================
# ìŠ¤íŠ¸ë¦¬ë° ìƒì„±ê¸°
# =============================================================================


async def _stream_turn_events(
    turn_input: TurnInput, seed: int | None = None
) -> AsyncGenerator[str]:
    """í„´ ì²˜ë¦¬ ì´ë²¤íŠ¸ë¥¼ NDJSON ìŠ¤íŠ¸ë¦¼ìœ¼ë¡œ ìƒì„±í•©ë‹ˆë‹¤.

    Pipelineì„ ì‹¤í–‰í•˜ê³ , ë„ë©”ì¸ ì´ë²¤íŠ¸ë¥¼ ìŠ¤íŠ¸ë¦¼ ì´ë²¤íŠ¸ë¡œ ë³€í™˜í•˜ì—¬ ì „ì†¡í•©ë‹ˆë‹¤.

    Args:
        turn_input: ì‚¬ìš©ì í„´ ì…ë ¥
        seed: Mock ëª¨ë“œ ì‹œë“œ (ì¬í˜„ì„± ë³´ì¥)

    Yields:
        str: NDJSON ë¼ì¸
    """
    # ì´ë²¤íŠ¸ í (emit ì½œë°±ì—ì„œ ì´ë²¤íŠ¸ë¥¼ ìŒ“ê³ , ë©”ì¸ ë£¨í”„ì—ì„œ ì†Œë¹„)
    event_queue: asyncio.Queue[PipelineEvent | None] = asyncio.Queue()

    async def emit(event: PipelineEvent) -> None:
        """íŒŒì´í”„ë¼ì¸ ì´ë²¤íŠ¸ë¥¼ íì— ì¶”ê°€í•©ë‹ˆë‹¤."""
        await event_queue.put(event)

    # Pipeline ì»¨í…ìŠ¤íŠ¸ ìƒì„±
    ctx = create_pipeline_context(turn_input, seed=seed)

    # Pipeline ì‹¤í–‰ì„ ë°±ê·¸ë¼ìš´ë“œ íƒœìŠ¤í¬ë¡œ ì‹œì‘
    async def run_pipeline_task() -> None:
        nonlocal ctx
        try:
            ctx = await run_pipeline(ctx, emit=emit)
        except asyncio.CancelledError:
            # RU-005-S2: í´ë¼ì´ì–¸íŠ¸ Abort ì‹œ íƒœìŠ¤í¬ë„ ì·¨ì†Œë¨
            # - í´ë°± ìƒì„± ì—†ì´ ì¦‰ì‹œ ì¢…ë£Œ (í”„ë¡ íŠ¸ ì •ì±…ê³¼ ë§ì¶¤)
            raise  # finally ë¸”ë¡ì€ ì‹¤í–‰, ì¢…ë£Œ ì‹ í˜¸ë§Œ ë³´ëƒ„
        except Exception:
            # ì˜ˆì™¸ ë°œìƒ ì‹œ í´ë°± (RULE-004)
            ctx.output = create_safe_fallback(
                language=turn_input.language,
                economy_snapshot=ctx.economy_snapshot,
                repair_count=ctx.repair_attempts,
            )
            ctx.is_fallback = True
        finally:
            # ì¢…ë£Œ ì‹ í˜¸ (CancelledError í¬í•¨ ëª¨ë“  ê²½ìš°ì— ì „ì†¡)
            await event_queue.put(None)

    pipeline_task = asyncio.create_task(run_pipeline_task())

    # ì´ë²¤íŠ¸ ì†Œë¹„ ë£¨í”„
    try:
        while True:
            event = await event_queue.get()
            if event is None:
                # Pipeline ì¢…ë£Œ
                break

            stream_event = _convert_pipeline_event(event)
            if stream_event is not None:
                yield serialize_event(stream_event)

        # Pipeline ì™„ë£Œ í›„ ë‚´ëŸ¬í‹°ë¸Œ + final ì „ì†¡ (RU-005-Q3: í—¬í¼ ì‚¬ìš©)
        if ctx.output is not None:
            async for line in stream_output_with_narrative(ctx.output):
                yield line

    except asyncio.CancelledError:
        # RU-005-S2: í´ë¼ì´ì–¸íŠ¸ Abort(ì—°ê²° ì·¨ì†Œ) ì‹œ ì¡°ìš©íˆ ì¢…ë£Œ
        # - ì¶”ê°€ ì´ë²¤íŠ¸(error/final) ì†¡ì¶œí•˜ì§€ ì•ŠìŒ
        # - ë¡œê·¸ë„ noisyí•˜ì§€ ì•Šê²Œ ë‚¨ê¸°ì§€ ì•ŠìŒ (í”„ë¡ íŠ¸ ì •ì±…ê³¼ ë§ì¶¤)
        pass

    except Exception:
        # ì˜ˆì™¸ ë°œìƒ ì‹œ error + final(í´ë°±) ìˆœì„œë¡œ ì†¡ì¶œ (RULE-004, RU-005-Q3: í—¬í¼ ì‚¬ìš©)
        async for line in emit_error_with_fallback(
            turn_input.language,
            economy_snapshot=ctx.economy_snapshot,
            repair_count=MAX_REPAIR_ATTEMPTS,
        ):
            yield line

    finally:
        # Pipeline íƒœìŠ¤í¬ ì •ë¦¬
        if not pipeline_task.done():
            pipeline_task.cancel()
            with contextlib.suppress(asyncio.CancelledError):
                await pipeline_task


# =============================================================================
# ì…ë ¥ ê²€ì¦
# =============================================================================


async def _validate_and_parse_input(request: Request) -> TurnInput | dict[str, Any]:
    """ìš”ì²­ ë³¸ë¬¸ì„ TurnInputìœ¼ë¡œ ê²€ì¦ ë° íŒŒì‹±í•©ë‹ˆë‹¤.

    Returns:
        TurnInput ë˜ëŠ” ì—ëŸ¬ ì •ë³´ dict (language, economy_snapshot í¬í•¨)
    """
    body: dict[str, Any] | None = None
    try:
        body = await request.json()
        return TurnInput.model_validate(body)
    except ValidationError as e:
        # RU-002-S1: ì…ë ¥ ê²€ì¦ ì‹¤íŒ¨ ì‹œì—ë„ language/economy ì¶”ì¶œ ì‹œë„
        raw_language = body.get("language") if isinstance(body, dict) else None
        raw_economy = body.get("economy_snapshot") if isinstance(body, dict) else None
        return {
            "error": True,
            "message": "Invalid input",
            "details": e.errors(),
            "language": raw_language if raw_language in ("ko-KR", "en-US") else "ko-KR",
            "economy_snapshot": raw_economy,
        }
    except Exception:
        return {
            "error": True,
            "message": "Failed to parse request body",
            "details": None,
            "language": "ko-KR",
            "economy_snapshot": None,
        }


# =============================================================================
# API ì—”ë“œí¬ì¸íŠ¸
# =============================================================================


@router.post(
    "/turn",
    response_class=StreamingResponse,
    summary="í„´ ì²˜ë¦¬ (HTTP Streaming)",
    description="""
í„´ ì…ë ¥ì„ ë°›ì•„ NDJSON ìŠ¤íŠ¸ë¦¬ë°ìœ¼ë¡œ ê²°ê³¼ë¥¼ ë°˜í™˜í•©ë‹ˆë‹¤.

**ìŠ¤íŠ¸ë¦¼ ì´ë²¤íŠ¸ íƒ€ì…**:
- `stage`: ì²˜ë¦¬ ë‹¨ê³„ ì§„í–‰ ìƒíƒœ
- `badges`: ê²€ì¦ ë°°ì§€ ëª©ë¡
- `narrative_delta`: ë‚´ëŸ¬í‹°ë¸Œ í…ìŠ¤íŠ¸ ì¡°ê° (íƒ€ì íš¨ê³¼)
- `final`: ìµœì¢… TurnOutput
- `error`: ì—ëŸ¬ ë°œìƒ ì‹œ

**ì˜ˆì‹œ ìš”ì²­**:
```json
{
    "language": "ko-KR",
    "text": "ë¬¸ì„ ì—´ì–´ë³¸ë‹¤",
    "client": {"viewport_w": 1920, "viewport_h": 1080, "theme": "dark"},
    "economy_snapshot": {"signal": 100, "memory_shard": 5}
}
```
""",
    responses={
        200: {
            "description": "NDJSON ìŠ¤íŠ¸ë¦¼",
            "content": {
                "application/x-ndjson": {
                    "example": '{"type":"stage","name":"parse","status":"start"}\n'
                }
            },
        },
        400: {"description": "ì˜ëª»ëœ ìš”ì²­"},
    },
)
async def turn_stream(request: Request) -> StreamingResponse:
    """í„´ ì²˜ë¦¬ HTTP Streaming ì—”ë“œí¬ì¸íŠ¸.

    POST ìš”ì²­ìœ¼ë¡œ TurnInputì„ ë°›ì•„ NDJSON ìŠ¤íŠ¸ë¦¬ë°ìœ¼ë¡œ ê²°ê³¼ë¥¼ ë°˜í™˜í•©ë‹ˆë‹¤.
    TTFBë¥¼ ì¤„ì´ê¸° ìœ„í•´ ì²« stage ì´ë²¤íŠ¸ë¥¼ ì¦‰ì‹œ ì „ì†¡í•©ë‹ˆë‹¤.

    Args:
        request: FastAPI Request ê°ì²´

    Returns:
        StreamingResponse: NDJSON ìŠ¤íŠ¸ë¦¼
    """
    # ì…ë ¥ ê²€ì¦
    parse_result = await _validate_and_parse_input(request)

    if isinstance(parse_result, dict) and parse_result.get("error"):
        # RU-002-S1: ì…ë ¥ ê²€ì¦ ì‹¤íŒ¨ ì‹œì—ë„ error + final(í´ë°±) ìˆœì„œë¡œ ì†¡ì¶œ
        error_language = parse_result.get("language", "ko-KR")
        error_economy = parse_result.get("economy_snapshot")

        # economy_snapshotì´ ìœ íš¨í•œì§€ í™•ì¸
        economy_snapshot: CurrencyAmount | None = None
        if isinstance(error_economy, dict):
            try:
                # ëª…ì‹œì  íƒ€ì… ìºìŠ¤íŒ…ìœ¼ë¡œ Pyright ê²½ê³  í•´ì†Œ
                eco_dict = cast(dict[str, Any], error_economy)
                economy_snapshot = CurrencyAmount(
                    signal=int(eco_dict.get("signal", 100)),
                    memory_shard=int(eco_dict.get("memory_shard", 5)),
                )
            except (ValueError, TypeError):
                economy_snapshot = None

        async def error_stream() -> AsyncGenerator[str]:
            # RU-005-Q3: í—¬í¼ë¥¼ ì‚¬ìš©í•˜ì—¬ error + final(í´ë°±) ì†¡ì¶œ
            async for line in emit_error_with_fallback(
                Language.KO if error_language == "ko-KR" else Language.EN,
                error_message=parse_result.get("message", "Invalid input"),
                error_code="VALIDATION_ERROR",
                economy_snapshot=economy_snapshot,
                repair_count=0,
            ):
                yield line

        return StreamingResponse(
            error_stream(),
            media_type="application/x-ndjson",
            headers={
                "Cache-Control": "no-cache",
                "X-Accel-Buffering": "no",  # nginx ë²„í¼ë§ ë¹„í™œì„±í™”
            },
        )

    turn_input: TurnInput = parse_result  # type: ignore[assignment]

    # ì‹œë“œ ì¶”ì¶œ (ì¿¼ë¦¬ íŒŒë¼ë¯¸í„°ì—ì„œ, í…ŒìŠ¤íŠ¸/ì¬í˜„ìš©)
    seed_param = request.query_params.get("seed")
    seed = int(seed_param) if seed_param else None

    # NDJSON ìŠ¤íŠ¸ë¦¬ë° ì‘ë‹µ
    return StreamingResponse(
        _stream_turn_events(turn_input, seed=seed),
        media_type="application/x-ndjson",
        headers={
            "Cache-Control": "no-cache",
            "X-Accel-Buffering": "no",  # nginx ë²„í¼ë§ ë¹„í™œì„±í™”
            "X-Request-Time": str(int(time.time() * 1000)),
        },
    )
</file>

<file path="frontend/src/api/turnStream.ts">
/**
 * Unknown World - HTTP Streaming í´ë¼ì´ì–¸íŠ¸ + NDJSON íŒŒì„œ.
 *
 * fetch ê¸°ë°˜ìœ¼ë¡œ POST ìš”ì²­ì„ ë³´ë‚´ê³  ì‘ë‹µ ìŠ¤íŠ¸ë¦¼ì„ NDJSONìœ¼ë¡œ íŒŒì‹±í•©ë‹ˆë‹¤.
 * ì¤‘ê°„ ì²­í¬ íŒŒì‹± ì‹¤íŒ¨ê°€ ì „ì²´ UIë¥¼ ë©ˆì¶”ì§€ ì•Šë„ë¡ ì„¤ê³„ë˜ì—ˆìŠµë‹ˆë‹¤.
 *
 * ì„¤ê³„ ì›ì¹™:
 *   - RULE-003: êµ¬ì¡°í™” ì¶œë ¥(JSON Schema) ìš°ì„  + ì´ì¤‘ ê²€ì¦
 *   - RULE-004: ê²€ì¦ ì‹¤íŒ¨ ì‹œ ì•ˆì „ í´ë°± ì œê³µ
 *   - RULE-008: ë‹¨ê³„/ë°°ì§€ ê°€ì‹œí™” (í”„ë¡¬í”„íŠ¸/ë‚´ë¶€ ì¶”ë¡  ë…¸ì¶œ ê¸ˆì§€)
 *   - RULE-011: ë°±ì—”ë“œ í¬íŠ¸ 8011 ì‚¬ìš©
 *
 * @module api/turnStream
 */

import type { TurnInput, TurnOutput, Language } from '../schemas/turn';
import { safeParseTurnOutput } from '../schemas/turn';
import type { StreamCallbacks } from '../types/turn_stream';
import {
  StreamEventType,
  BaseEventSchema,
  safeParseStageEvent,
  safeParseRepairEvent,
  safeParseBadgesEvent,
  safeParseNarrativeDeltaEvent,
  safeParseFinalEventRaw,
  safeParseErrorEvent,
  normalizeStageStatus,
} from '../types/turn_stream';

// Re-export ìŠ¤íŠ¸ë¦¼ ì´ë²¤íŠ¸ íƒ€ì…ë“¤ (í•˜ìœ„ í˜¸í™˜ì„± ìœ ì§€)
export type {
  StreamEventTypeName,
  StageStatusName,
  StageEvent,
  RepairEvent,
  BadgesEvent,
  NarrativeDeltaEvent,
  FinalEvent,
  ErrorEvent,
  StreamEvent,
  StreamCallbacks,
} from '../types/turn_stream';
export { StreamEventType, StageStatus } from '../types/turn_stream';

// =============================================================================
// NDJSON íŒŒì„œ (Q1 ê²°ì •: Option A - ì§ì ‘ êµ¬í˜„)
// =============================================================================

/**
 * NDJSON ë¼ì¸ íŒŒì„œ.
 * ë¶€ë¶„ ì²­í¬ë¥¼ ë²„í¼ë§í•˜ê³  ì™„ì „í•œ ë¼ì¸ì„ íŒŒì‹±í•©ë‹ˆë‹¤.
 */
export class NDJSONParser {
  private buffer = '';

  /**
   * ì²­í¬ë¥¼ íŒŒì‹±í•˜ê³  ì™„ì „í•œ JSON ê°ì²´ë“¤ì„ ë°˜í™˜í•©ë‹ˆë‹¤.
   *
   * @param chunk - ìˆ˜ì‹ ëœ í…ìŠ¤íŠ¸ ì²­í¬
   * @returns íŒŒì‹±ëœ JSON ê°ì²´ ë°°ì—´
   */
  parse(chunk: string): unknown[] {
    this.buffer += chunk;
    const results: unknown[] = [];

    // ì¤„ë°”ê¿ˆìœ¼ë¡œ ë¶„í• 
    const lines = this.buffer.split('\n');

    // ë§ˆì§€ë§‰ ë¼ì¸ì€ ë¶ˆì™„ì „í•  ìˆ˜ ìˆìœ¼ë¯€ë¡œ ë²„í¼ì— ìœ ì§€
    this.buffer = lines.pop() ?? '';

    for (const line of lines) {
      const trimmed = line.trim();
      if (trimmed === '') continue;

      try {
        const parsed = JSON.parse(trimmed);
        results.push(parsed);
      } catch {
        // íŒŒì‹± ì‹¤íŒ¨ ì‹œ í•´ë‹¹ ë¼ì¸ ë¬´ì‹œ (RULE-004: ì „ì²´ ì¤‘ë‹¨ ë°©ì§€)
        console.warn('[NDJSON] Failed to parse line:', trimmed);
      }
    }

    return results;
  }

  /**
   * ë²„í¼ë¥¼ ì´ˆê¸°í™”í•©ë‹ˆë‹¤.
   */
  reset(): void {
    this.buffer = '';
  }

  /**
   * ë‚¨ì€ ë²„í¼ë¥¼ í”ŒëŸ¬ì‹œí•˜ê³  ë§ˆì§€ë§‰ ê°ì²´ë¥¼ íŒŒì‹±í•©ë‹ˆë‹¤.
   */
  flush(): unknown | null {
    const trimmed = this.buffer.trim();
    this.buffer = '';

    if (trimmed === '') return null;

    try {
      return JSON.parse(trimmed);
    } catch {
      console.warn('[NDJSON] Failed to parse remaining buffer:', trimmed);
      return null;
    }
  }
}

// =============================================================================
// ìŠ¤íŠ¸ë¦¼ ì´ë²¤íŠ¸ í•¸ë“¤ëŸ¬
// =============================================================================

/**
 * íŒŒì‹±ëœ ì´ë²¤íŠ¸ë¥¼ íƒ€ì…ë³„ë¡œ ë¶„ë°°í•©ë‹ˆë‹¤.
 *
 * RU-002-S2: ìºìŠ¤íŒ… ëŒ€ì‹  Zod safeParseë¥¼ ì ìš©í•˜ì—¬ ê²€ì¦ ê°•í™”.
 * Unknown/í™•ì¥ ì´ë²¤íŠ¸ëŠ” UIë¥¼ ë©ˆì¶”ì§€ ì•Šê³  ê²½ê³ ë§Œ ì¶œë ¥.
 *
 * @param event - íŒŒì‹±ëœ ì´ë²¤íŠ¸ ê°ì²´
 * @param callbacks - ì½œë°± í•¨ìˆ˜ë“¤
 * @param language - í´ë°± ì–¸ì–´
 */
function dispatchEvent(event: unknown, callbacks: StreamCallbacks, language: Language): void {
  if (!event || typeof event !== 'object') return;

  // ê¸°ë³¸ ì´ë²¤íŠ¸ íƒ€ì… ì¶”ì¶œ
  const baseResult = BaseEventSchema.safeParse(event);
  if (!baseResult.success) {
    console.warn('[TurnStream] Invalid event format (no type field):', event);
    return;
  }

  const type = baseResult.data.type;

  switch (type) {
    case StreamEventType.STAGE: {
      // RU-002-S2: stage ì´ë²¤íŠ¸ ê²€ì¦
      const stageResult = safeParseStageEvent(event);
      if (stageResult.success) {
        // status ì •ê·œí™”: 'ok' â†’ 'complete'
        const normalizedStatus = normalizeStageStatus(stageResult.data.status);
        callbacks.onStage?.({
          type: StreamEventType.STAGE,
          name: stageResult.data.name,
          status: normalizedStatus,
        });
      } else {
        console.warn('[TurnStream] Invalid stage event:', stageResult.error.message);
      }
      break;
    }

    case StreamEventType.REPAIR: {
      // RU-002-S2: repair ì´ë²¤íŠ¸ ê²€ì¦
      const repairResult = safeParseRepairEvent(event);
      if (repairResult.success) {
        callbacks.onRepair?.(repairResult.data);
      } else {
        console.warn('[TurnStream] Invalid repair event:', repairResult.error.message);
      }
      break;
    }

    case StreamEventType.BADGES: {
      // RU-002-S2: badges ì´ë²¤íŠ¸ ê²€ì¦ (v1/v2 ì •ê·œí™” í¬í•¨)
      const badgesResult = safeParseBadgesEvent(event);
      if (badgesResult.success) {
        callbacks.onBadges?.(badgesResult.data);
      } else {
        console.warn('[TurnStream] Invalid badges event:', badgesResult.error.message);
      }
      break;
    }

    case StreamEventType.NARRATIVE_DELTA: {
      // RU-002-S2: narrative_delta ì´ë²¤íŠ¸ ê²€ì¦
      const narrativeResult = safeParseNarrativeDeltaEvent(event);
      if (narrativeResult.success) {
        callbacks.onNarrativeDelta?.(narrativeResult.data);
      } else {
        console.warn('[TurnStream] Invalid narrative_delta event:', narrativeResult.error.message);
      }
      break;
    }

    case StreamEventType.FINAL: {
      // RU-002-S2: final ì´ë²¤íŠ¸ êµ¬ì¡° ê²€ì¦
      const finalRawResult = safeParseFinalEventRaw(event);
      if (!finalRawResult.success) {
        console.warn('[TurnStream] Invalid final event structure:', finalRawResult.error.message);
        // êµ¬ì¡°ê°€ ì˜ëª»ë˜ì–´ë„ í´ë°± ì œê³µ
        callbacks.onFinal?.({
          type: StreamEventType.FINAL,
          data: createFallbackTurnOutput(language),
        });
        break;
      }

      // RULE-003/004: Zod strict parse + í´ë°±
      const turnOutputPayload = finalRawResult.data.data;
      const parseResult = safeParseTurnOutput(turnOutputPayload, language);

      if (parseResult.success) {
        callbacks.onFinal?.({
          type: StreamEventType.FINAL,
          data: parseResult.data,
        });
      } else {
        console.warn('[TurnStream] TurnOutput validation failed:', parseResult.error);
        callbacks.onFinal?.({
          type: StreamEventType.FINAL,
          data: parseResult.fallback,
        });
      }
      break;
    }

    case StreamEventType.ERROR: {
      // RU-002-S2: error ì´ë²¤íŠ¸ ê²€ì¦
      const errorResult = safeParseErrorEvent(event);
      if (errorResult.success) {
        callbacks.onError?.(errorResult.data);
      } else {
        console.warn('[TurnStream] Invalid error event:', errorResult.error.message);
        // U-044: ì—ëŸ¬ ì´ë²¤íŠ¸ê°€ ê¹¨ì§„ ê²½ìš°ì—ë„ ê¸°ë³¸ ì—ëŸ¬ ì „ë‹¬ (i18n ë©”ì‹œì§€ ì‚¬ìš©)
        callbacks.onError?.({
          type: StreamEventType.ERROR,
          message: getErrorMessage('unknown_error', language),
          code: 'INVALID_ERROR_EVENT',
        });
      }
      break;
    }

    default:
      // RU-002-S2: Unknown/í™•ì¥ ì´ë²¤íŠ¸ëŠ” UIë¥¼ ë©ˆì¶”ì§€ ì•Šê³  ê²½ê³ ë§Œ ì¶œë ¥
      // í–¥í›„ protocol, repair, telemetry ë“± í™•ì¥ ì´ë²¤íŠ¸ ë„ì… ì‹œ ì—¬ê¸°ì„œ ì²˜ë¦¬ ê°€ëŠ¥
      console.warn('[TurnStream] Unknown/ignored event type:', type, event);
  }
}

// =============================================================================
// U-044: i18n ì—ëŸ¬/í´ë°± ë©”ì‹œì§€ (Q2: Option B - translation.json í‚¤ ì‚¬ìš©)
// =============================================================================

/**
 * U-044: ì—ëŸ¬ ë©”ì‹œì§€ ë²ˆì—­ ë¦¬ì†ŒìŠ¤.
 * í´ë¼ì´ì–¸íŠ¸ì—ì„œ ë°œìƒí•˜ëŠ” ì—ëŸ¬ ë©”ì‹œì§€ë¥¼ ì–¸ì–´ë³„ë¡œ ì œê³µí•©ë‹ˆë‹¤.
 *
 * ì£¼ì˜: turnStream.tsëŠ” React ì»´í¬ë„ŒíŠ¸ê°€ ì•„ë‹ˆë¯€ë¡œ useTranslation ì‚¬ìš© ë¶ˆê°€.
 * ëŒ€ì‹  language ë§¤ê°œë³€ìˆ˜ë¡œ ë¶„ê¸° ì²˜ë¦¬í•©ë‹ˆë‹¤.
 * translation.jsonì˜ í‚¤ì™€ ë™ê¸°í™” ìœ ì§€ í•„ìš” (error.* ë„¤ì„ìŠ¤í˜ì´ìŠ¤).
 */
const ERROR_MESSAGES: Record<string, Record<Language, string>> = {
  // ì—ëŸ¬ ì´ë²¤íŠ¸ íŒŒì‹± ì‹¤íŒ¨
  unknown_error: {
    'ko-KR': 'ì•Œ ìˆ˜ ì—†ëŠ” ì˜¤ë¥˜ê°€ ë°œìƒí–ˆìŠµë‹ˆë‹¤.',
    'en-US': 'An unknown error occurred.',
  },
  // ì‘ë‹µ ë°ì´í„° ì²˜ë¦¬ ì‹¤íŒ¨ (final ì´ë²¤íŠ¸ ìŠ¤í‚¤ë§ˆ ê²€ì¦ ì‹¤íŒ¨)
  response_processing: {
    'ko-KR': '[ì‹œìŠ¤í…œ] ì‘ë‹µ ë°ì´í„°ë¥¼ ì²˜ë¦¬í•˜ëŠ” ì¤‘ ë¬¸ì œê°€ ë°œìƒí–ˆìŠµë‹ˆë‹¤.',
    'en-US': '[System] An error occurred while processing response data.',
  },
  // ì„œë²„ ì—°ê²° ì‹¤íŒ¨ (ë„¤íŠ¸ì›Œí¬ ì—ëŸ¬)
  connection_failed: {
    'ko-KR': '[ì‹œìŠ¤í…œ] ì„œë²„ ì—°ê²°ì— ì‹¤íŒ¨í–ˆìŠµë‹ˆë‹¤. ë‹¤ì‹œ ì‹œë„í•´ ì£¼ì„¸ìš”.',
    'en-US': '[System] Failed to connect to server. Please try again.',
  },
};

/**
 * U-044: ì—ëŸ¬ ë©”ì‹œì§€ë¥¼ ì–¸ì–´ì— ë§ê²Œ ë°˜í™˜í•©ë‹ˆë‹¤.
 */
function getErrorMessage(key: string, language: Language): string {
  return ERROR_MESSAGES[key]?.[language] ?? ERROR_MESSAGES[key]?.['en-US'] ?? key;
}

/**
 * í´ë¼ì´ì–¸íŠ¸ ì¸¡ í´ë°± TurnOutput ìƒì„± (ì–¸ì–´ë§Œ ì§€ì •).
 * dispatchEvent ë‚´ë¶€ì—ì„œ ì‚¬ìš©í•˜ëŠ” ê°„ë‹¨í•œ í´ë°±.
 * U-044: í•˜ë“œì½”ë”© ë©”ì‹œì§€ ì œê±°, i18n ë¦¬ì†ŒìŠ¤ ì‚¬ìš©.
 */
function createFallbackTurnOutput(language: Language): TurnOutput {
  const fallbackNarrative = getErrorMessage('response_processing', language);

  return {
    language,
    narrative: fallbackNarrative,
    economy: {
      cost: { signal: 0, memory_shard: 0 },
      balance_after: { signal: 0, memory_shard: 0 },
    },
    safety: {
      blocked: false,
      message: null,
    },
    ui: {
      action_deck: { cards: [] },
      objects: [],
      scene: { image_url: null, alt_text: null },
    },
    world: {
      rules_changed: [],
      inventory_added: [],
      inventory_removed: [],
      quests_updated: [],
      relationships_changed: [],
      memory_pins: [],
    },
    render: {
      image_job: null,
    },
    agent_console: {
      current_phase: 'commit',
      badges: ['schema_fail'],
      repair_count: 1,
    },
  };
}

// =============================================================================
// API ì„¤ì •
// =============================================================================

/** ë°±ì—”ë“œ API URL (RULE-011: í¬íŠ¸ 8011) */
const API_BASE_URL = 'http://localhost:8011';

/** í„´ ìŠ¤íŠ¸ë¦¼ API ì—”ë“œí¬ì¸íŠ¸ */
const TURN_ENDPOINT = `${API_BASE_URL}/api/turn`;

// =============================================================================
// ìŠ¤íŠ¸ë¦¼ í´ë¼ì´ì–¸íŠ¸
// =============================================================================

/** ìŠ¤íŠ¸ë¦¼ ìš”ì²­ ì˜µì…˜ */
export interface TurnStreamOptions {
  /** ìš”ì²­ íƒ€ì„ì•„ì›ƒ (ms) */
  timeout?: number;
  /** AbortSignal */
  signal?: AbortSignal;
}

/**
 * í„´ ìŠ¤íŠ¸ë¦¼ ìš”ì²­ì„ ì‹¤í–‰í•©ë‹ˆë‹¤.
 *
 * @param input - í„´ ì…ë ¥ ë°ì´í„°
 * @param callbacks - ì´ë²¤íŠ¸ ì½œë°±
 * @param options - ìš”ì²­ ì˜µì…˜
 * @returns ì·¨ì†Œ í•¨ìˆ˜
 */
export async function executeTurnStream(
  input: TurnInput,
  callbacks: StreamCallbacks,
  options?: TurnStreamOptions,
): Promise<void> {
  const parser = new NDJSONParser();
  const controller = new AbortController();
  const signal = options?.signal ?? controller.signal;

  // RU-002-S1: AbortError ë°œìƒ ì‹œ onComplete í˜¸ì¶œ ì—¬ë¶€ ì¶”ì 
  let aborted = false;

  try {
    const response = await fetch(TURN_ENDPOINT, {
      method: 'POST',
      headers: {
        'Content-Type': 'application/json',
        Accept: 'application/x-ndjson',
      },
      body: JSON.stringify(input),
      signal,
    });

    if (!response.ok) {
      throw new Error(`HTTP ${response.status}: ${response.statusText}`);
    }

    if (!response.body) {
      throw new Error('Response body is null');
    }

    const reader = response.body.getReader();
    const decoder = new TextDecoder('utf-8');

    // ìŠ¤íŠ¸ë¦¼ ì½ê¸° ë£¨í”„
    while (true) {
      const { done, value } = await reader.read();

      if (done) break;

      const chunk = decoder.decode(value, { stream: true });
      const events = parser.parse(chunk);

      for (const event of events) {
        dispatchEvent(event, callbacks, input.language);
      }
    }

    // ë‚¨ì€ ë²„í¼ í”ŒëŸ¬ì‹œ
    const remaining = parser.flush();
    if (remaining) {
      dispatchEvent(remaining, callbacks, input.language);
    }
  } catch (error) {
    if (error instanceof DOMException && error.name === 'AbortError') {
      // RU-003-S1: Abort(ì·¨ì†Œ) ì •ì±…
      // =========================================================================
      // í˜„ì¬ ì •ì±…(Option B): Abort ì‹œ onCompleteë¥¼ í˜¸ì¶œí•˜ì§€ ì•ŠìŒ
      // - ì´ìœ : ì·¨ì†ŒëŠ” "ì‚¬ìš©ì ì˜ë„"ì´ë¯€ë¡œ ì‹¤íŒ¨ì™€ êµ¬ë¶„í•´ì•¼ í•¨
      // - ì£¼ì˜: ì´ ì •ì±…ì—ì„œëŠ” Cancel ë²„íŠ¼ êµ¬í˜„ ì‹œ í˜¸ì¶œìê°€ ì§ì ‘ UI ë³µêµ¬ í•„ìš”
      //
      // í–¥í›„ Option Aë¡œ ì „í™˜ ê°€ëŠ¥:
      // - Abort ì‹œì—ë„ onComplete í˜¸ì¶œ + ë³„ë„ í”Œë˜ê·¸ë¡œ "ì·¨ì†Œ ì¢…ë£Œ" êµ¬ë¶„
      // - ì¥ì : UIê°€ ë©ˆì¶”ì§€ ì•ŠìŒ (ë³µêµ¬ ì¼ê´€ì„±)
      // - ë‹¨ì : ì·¨ì†Œì™€ ì‹¤íŒ¨ë¥¼ êµ¬ë¶„í•˜ë ¤ë©´ ì´ë²¤íŠ¸ ëª¨ë¸ í™•ì¥ í•„ìš”
      //
      // ê²°ì • ê·¼ê±°: RU-003-S1 Step 3
      // =========================================================================
      aborted = true;
      return;
    }

    const errorMessage = error instanceof Error ? error.message : 'Unknown error occurred';

    // RU-002-S1: ë„¤íŠ¸ì›Œí¬ ì—ëŸ¬ ì‹œì—ë„ onError í˜¸ì¶œ
    callbacks.onError?.({
      type: StreamEventType.ERROR,
      message: errorMessage,
      code: 'STREAM_ERROR',
    });

    // RU-002-S1: ë„¤íŠ¸ì›Œí¬ ì—ëŸ¬ ì‹œ í´ë¼ì´ì–¸íŠ¸ ì¸¡ í´ë°± final ìƒì„±
    // ì„œë²„ì—ì„œ finalì´ ì˜¤ì§€ ëª»í•œ ê²½ìš° UIê°€ ë©ˆì¶”ì§€ ì•Šë„ë¡ í•¨
    const fallback = createClientFallbackTurnOutput(input.language, input.economy_snapshot);
    callbacks.onFinal?.({
      type: StreamEventType.FINAL,
      data: fallback,
    });
  } finally {
    // RU-002-S1: ìŠ¤íŠ¸ë¦¼ ì¢…ë£Œ ì¸ë°”ë¦¬ì–¸íŠ¸ - ì„±ê³µ/ì‹¤íŒ¨ ëª¨ë‘ì—ì„œ onComplete í˜¸ì¶œ ë³´ì¥
    if (!aborted) {
      callbacks.onComplete?.();
    }
  }
}

/**
 * í´ë¼ì´ì–¸íŠ¸ ì¸¡ í´ë°± TurnOutput ìƒì„± (RU-002-S1).
 * ì„œë²„ì—ì„œ finalì´ ì˜¤ì§€ ëª»í•œ ê²½ìš° (ë„¤íŠ¸ì›Œí¬ ì—ëŸ¬ ë“±) ì‚¬ìš©í•©ë‹ˆë‹¤.
 * EconomyëŠ” ìš”ì²­ ì§ì „ ìŠ¤ëƒ…ìƒ·ì„ ê·¸ëŒ€ë¡œ ìœ ì§€í•©ë‹ˆë‹¤.
 * U-044: í•˜ë“œì½”ë”© ë©”ì‹œì§€ ì œê±°, i18n ë¦¬ì†ŒìŠ¤ ì‚¬ìš©.
 */
function createClientFallbackTurnOutput(
  language: Language,
  economySnapshot: { signal: number; memory_shard: number },
): TurnOutput {
  const fallbackNarrative = getErrorMessage('connection_failed', language);

  return {
    language,
    narrative: fallbackNarrative,
    economy: {
      cost: { signal: 0, memory_shard: 0 },
      // RU-002-S1: ì…ë ¥ ìŠ¤ëƒ…ìƒ· ê·¸ëŒ€ë¡œ ìœ ì§€ (ë¹„ìš© 0, ì”ì•¡ ë³€í™” ì—†ìŒ)
      balance_after: {
        signal: economySnapshot.signal,
        memory_shard: economySnapshot.memory_shard,
      },
    },
    safety: {
      blocked: false,
      message: null,
    },
    ui: {
      action_deck: { cards: [] },
      objects: [],
      scene: { image_url: null, alt_text: null },
    },
    world: {
      rules_changed: [],
      inventory_added: [],
      inventory_removed: [],
      quests_updated: [],
      relationships_changed: [],
      memory_pins: [],
    },
    render: {
      image_job: null,
    },
    agent_console: {
      current_phase: 'commit',
      badges: ['schema_fail'],
      repair_count: 1,
    },
  };
}

/**
 * í„´ ìŠ¤íŠ¸ë¦¼ì„ ì‹œì‘í•˜ê³  ì·¨ì†Œ í•¨ìˆ˜ë¥¼ ë°˜í™˜í•©ë‹ˆë‹¤.
 *
 * @param input - í„´ ì…ë ¥ ë°ì´í„°
 * @param callbacks - ì´ë²¤íŠ¸ ì½œë°±
 * @returns ì·¨ì†Œ í•¨ìˆ˜
 */
export function startTurnStream(input: TurnInput, callbacks: StreamCallbacks): () => void {
  const controller = new AbortController();

  executeTurnStream(input, callbacks, { signal: controller.signal });

  return () => controller.abort();
}
</file>

<file path="frontend/src/locales/en-US/translation.json">
{
  "language": {
    "toggle": "Change Language",
    "toggle_tooltip": "Click to change language. A new game will start after change.",
    "ko-KR": "í•œêµ­ì–´",
    "en-US": "English"
  },
  "error": {
    "unknown_error": "An unknown error occurred.",
    "response_processing": "[System] An error occurred while processing response data.",
    "connection_failed": "[System] Failed to connect to server. Please try again."
  },
  "profile": {
    "select_title": "Select Your Profile",
    "select_hint": "Each profile has different starting conditions and objectives",
    "or": "or",
    "continue_saved": "Continue Saved Game",
    "change": "Change Profile",
    "change_tooltip": "Start a new game with a different profile",
    "narrator": {
      "name": "Narrator",
      "description": "Explore diverse stories with abundant resources",
      "welcome": "Welcome to the Ancient Library. Forgotten tales slumber within these walls...",
      "items": {
        "ancient_tome": "Ancient Tome",
        "quill_pen": "Quill Pen",
        "memory_fragment": "Memory Fragment"
      },
      "quest": {
        "discover_origin": "Discover the World's Origin",
        "collect_memories": "Collect 3 Memory Fragments"
      },
      "rule": {
        "time_flows": "Flow of Time",
        "time_flows_desc": "Time flows normally",
        "memories_persist": "Memory Persistence",
        "memories_persist_desc": "Once obtained, memories never fade"
      },
      "scene": {
        "bookshelf": "Mysterious Bookshelf",
        "bookshelf_hint": "Ancient books are glowing",
        "portal": "Glowing Portal",
        "portal_hint": "It seems to lead somewhere"
      }
    },
    "explorer": {
      "name": "Explorer",
      "description": "Explore unknown territories and uncover secrets",
      "welcome": "You wake up in a dark maze. You must find the exit and escape...",
      "items": {
        "compass": "Compass",
        "rope": "Rope",
        "lantern": "Lantern",
        "map_fragment": "Map Fragment"
      },
      "quest": {
        "find_exit": "Find the Exit",
        "explore_areas": "Explore 3 Areas",
        "gather_supplies": "Gather Supplies"
      },
      "rule": {
        "gravity": "Gravity Law",
        "gravity_desc": "Objects fall downward",
        "darkness": "Darkness Law",
        "darkness_desc": "You cannot see without light"
      },
      "scene": {
        "door": "Ancient Door",
        "door_hint": "Looks like it needs a key",
        "mechanism": "Strange Mechanism",
        "mechanism_hint": "It might be operable",
        "passage": "Hidden Passage",
        "passage_hint": "Where does it lead?"
      }
    },
    "tech": {
      "name": "Tech Expert",
      "description": "Strategize efficiently with limited resources",
      "welcome": "System boot complete. Find the optimal path with limited energy...",
      "items": {
        "data_core": "Data Core",
        "circuit_board": "Circuit Board",
        "energy_cell": "Energy Cell",
        "scanner": "Scanner Device"
      },
      "quest": {
        "analyze_system": "Complete System Analysis",
        "optimize_resources": "Optimize Resource Efficiency"
      },
      "rule": {
        "energy_conservation": "Energy Conservation",
        "energy_conservation_desc": "Energy is neither created nor destroyed",
        "data_integrity": "Data Integrity",
        "data_integrity_desc": "Corrupted data cannot be recovered",
        "system_limits": "System Limits",
        "system_limits_desc": "There are limits to concurrent processing"
      },
      "scene": {
        "terminal": "Main Terminal",
        "terminal_hint": "You can access the system",
        "conduit": "Power Conduit",
        "conduit_hint": "Energy is flowing through it"
      }
    }
  },
  "reset": {
    "button": "Reset",
    "confirm": "Click again to confirm",
    "cancel": "Cancel",
    "tooltip": "Return to the initial state of current profile"
  },
  "demo": {
    "items": {
      "keycard-alpha": {
        "name": "Keycard A"
      },
      "medkit": {
        "name": "Medkit"
      },
      "flashlight": {
        "name": "Flashlight"
      },
      "data-chip": {
        "name": "Data Chip"
      }
    },
    "scene": {
      "terminal": {
        "label": "Terminal",
        "hint": "An active terminal"
      },
      "door": {
        "label": "Door",
        "hint": "It appears to be locked"
      }
    },
    "quest": {
      "terminal": {
        "label": "Access the terminal"
      },
      "escape": {
        "label": "Find facility exit"
      },
      "collect": {
        "label": "Collect data chips"
      }
    },
    "rule": {
      "gravity": {
        "label": "Gravity Law",
        "description": "Objects fall downward"
      },
      "time": {
        "label": "Time Flow",
        "description": "Time flows at normal speed"
      }
    }
  },
  "quest": {
    "empty": "[ NO OBJECTIVES ]",
    "completed": "DONE",
    "section": {
      "active": "Active",
      "completed": "Completed"
    }
  },
  "rule_board": {
    "empty": "[ NO RULES ]",
    "active_count": "Active Rules: {{count}}"
  },
  "mutation": {
    "empty": "[ NO MUTATIONS ]",
    "timeline_title": "Mutation Timeline",
    "event_count": "{{count}} events",
    "more_events": "+{{count}} more",
    "turn_label": "T{{turn}}",
    "type": {
      "added": "Added",
      "modified": "Modified",
      "removed": "Removed"
    }
  },
  "scene": {
    "status": {
      "default": "NO SIGNAL DATA",
      "loading": "SYNCHRONIZING...",
      "offline": "CONNECTION LOST",
      "blocked": "ACCESS RESTRICTED",
      "low_signal": "LOW SIGNAL",
      "image_error": "Unable to load scene image.",
      "image_loading": "Loading scene image...",
      "image_generating": "Generating new scene...",
      "initial_sync": "Awaiting global data synchronization...",
      "syncing": "Synchronizing data...",
      "alt": "Scene Image"
    },
    "hotspot": {
      "layer_label": "Clickable Objects Area",
      "hint_prefix": "Hint",
      "click_action": "Click {{label}}",
      "drop_hint": "Drop here to use",
      "drop_action": "Use {{item}} on {{target}}",
      "drop_invalid": "You cannot use {{item}} there.",
      "demo_hint": "[DEMO TARGET]"
    }
  },
  "agent": {
    "console": {
      "queue": "Queue",
      "badges": "Badges",
      "repair": "Auto-repair",
      "status": {
        "idle": "IDLE",
        "processing": "PROCESSING"
      },
      "badges_empty": "[ Awaiting Validation ]",
      "repaired": "(Repaired)",
      "phase": {
        "parse": "Parse",
        "validate": "Validate",
        "plan": "Plan",
        "resolve": "Resolve",
        "render": "Render",
        "verify": "Verify",
        "commit": "Commit"
      },
      "badge": {
        "schema": "Schema",
        "economy": "Economy",
        "safety": "Safety",
        "consistency": "Consistency",
        "ok": "OK",
        "fail": "FAIL"
      }
    }
  },
  "ui": {
    "logo": "UNKNOWN WORLD",
    "command_placeholder": "Enter command...",
    "processing": "Processing...",
    "execute": "EXECUTE",
    "wait": "WAIT",
    "panel_placeholder": "[ Ready ]",
    "scale_decrease": "Decrease text size",
    "scale_increase": "Increase text size",
    "scale_label": "UI Scale Settings"
  },
  "economy": {
    "signal": "Signal",
    "shard": "Shard",
    "signal_cost": "Signal cost",
    "shard_cost": "Shard cost",
    "risk_level": "Risk level",
    "hud_label": "Economy Status",
    "estimated_cost": "Est. Cost",
    "confirmed_cost": "Confirmed",
    "insufficient_funds": "Insufficient funds",
    "low_balance_warning": "Low balance",
    "alternatives_title": "Alternatives",
    "alternative_text_only": "Text-only (no images)",
    "alternative_low_quality": "Low quality / Fast response",
    "ledger_title": "Recent Ledger",
    "ledger_empty": "[ NO HISTORY ]",
    "model_label": {
      "FAST": "Fast",
      "QUALITY": "Quality",
      "CHEAP": "Cheap",
      "REF": "Ref"
    }
  },
  "connection": {
    "online": "ONLINE",
    "offline": "OFFLINE"
  },
  "inventory": {
    "empty": "[ NO ITEMS ]",
    "grid_label": "Inventory Items",
    "item_label": "{{name}} (Qty: {{quantity}})",
    "drag_hint": "Drag to use"
  },
  "panel": {
    "inventory": {
      "title": "Inventory",
      "placeholder": "[ Drag & Drop Area ]"
    },
    "quest": {
      "title": "Quest",
      "placeholder": "[ Objectives / Quest List ]"
    },
    "rule_board": {
      "title": "Rule Board",
      "placeholder": "[ World Rules / Mutation Timeline ]"
    },
    "agent_console": {
      "title": "Agent Console"
    },
    "memory_pin": {
      "title": "Memory Pin",
      "placeholder": "[ Pinned Memories / Clues ]"
    },
    "scanner": {
      "title": "Scanner",
      "placeholder": "[ Image Upload Slot ]"
    }
  },
  "scanner": {
    "dropzone_label": "Drop image or click to upload",
    "dropzone_text": "Drop Image Here",
    "dropzone_hint": "Or click to browse files",
    "upload_label": "Upload image",
    "preview_alt": "Upload image preview",
    "uploading": "Uploading...",
    "analyzing": "Analyzing...",
    "retry": "Retry",
    "cancel": "Cancel",
    "select_items": "Select items to add to inventory",
    "add_to_inventory": "Add ({{count}})",
    "detected_objects": "Objects detected: {{count}}",
    "item_candidates": "Item candidates: {{count}}",
    "no_candidates": "No item candidates found",
    "error": {
      "unsupported_format": "Unsupported image format",
      "file_too_large": "File too large (max 20MB)",
      "unknown": "An unknown error occurred"
    },
    "item_type": {
      "key": "Key",
      "weapon": "Weapon",
      "tool": "Tool",
      "clue": "Clue",
      "material": "Material",
      "consumable": "Consumable",
      "document": "Document",
      "artifact": "Artifact"
    }
  },
  "action": {
    "default": {
      "explore": {
        "label": "Explore",
        "description": "Look around"
      },
      "investigate": {
        "label": "Investigate",
        "description": "Examine closely"
      },
      "talk": {
        "label": "Talk",
        "description": "Start a conversation"
      }
    },
    "card_select": "Card selected: {{cardId}}",
    "deck_label": "Action Cards",
    "alternative": "ALT",
    "insufficient_balance": "Insufficient balance",
    "all_disabled_notice": "No actions available. Check alternatives.",
    "risk": {
      "low": "Low",
      "medium": "Med",
      "high": "High"
    },
    "cost_range": "{{min}}~{{max}}"
  },
  "narrative": {
    "welcome": "Welcome to the Unknown World...",
    "turn_label": "[TURN {{turn}}]",
    "streaming_label": "[STREAMING]"
  }
}
</file>

<file path="frontend/src/locales/ko-KR/translation.json">
{
  "language": {
    "toggle": "ì–¸ì–´ ë³€ê²½",
    "toggle_tooltip": "í´ë¦­í•˜ì—¬ ì–¸ì–´ë¥¼ ë³€ê²½í•©ë‹ˆë‹¤. ë³€ê²½ í›„ ìƒˆ ê²Œì„ì´ ì‹œì‘ë©ë‹ˆë‹¤.",
    "ko-KR": "í•œêµ­ì–´",
    "en-US": "English"
  },
  "error": {
    "unknown_error": "ì•Œ ìˆ˜ ì—†ëŠ” ì˜¤ë¥˜ê°€ ë°œìƒí–ˆìŠµë‹ˆë‹¤.",
    "response_processing": "[ì‹œìŠ¤í…œ] ì‘ë‹µ ë°ì´í„°ë¥¼ ì²˜ë¦¬í•˜ëŠ” ì¤‘ ë¬¸ì œê°€ ë°œìƒí–ˆìŠµë‹ˆë‹¤.",
    "connection_failed": "[ì‹œìŠ¤í…œ] ì„œë²„ ì—°ê²°ì— ì‹¤íŒ¨í–ˆìŠµë‹ˆë‹¤. ë‹¤ì‹œ ì‹œë„í•´ ì£¼ì„¸ìš”."
  },
  "profile": {
    "select_title": "í”„ë¡œí•„ì„ ì„ íƒí•˜ì„¸ìš”",
    "select_hint": "í”„ë¡œí•„ë§ˆë‹¤ ë‹¤ë¥¸ ì‹œì‘ ì¡°ê±´ê³¼ ëª©í‘œê°€ ìˆìŠµë‹ˆë‹¤",
    "or": "ë˜ëŠ”",
    "continue_saved": "ì €ì¥ëœ ê²Œì„ ê³„ì†í•˜ê¸°",
    "change": "í”„ë¡œí•„ ë³€ê²½",
    "change_tooltip": "ë‹¤ë¥¸ í”„ë¡œí•„ë¡œ ìƒˆ ê²Œì„ ì‹œì‘",
    "narrator": {
      "name": "ì„œì‚¬ê¾¼",
      "description": "í’ë¶€í•œ ìì›ìœ¼ë¡œ ë‹¤ì–‘í•œ ì´ì•¼ê¸°ë¥¼ íƒí—˜í•˜ì„¸ìš”",
      "welcome": "ê³ ëŒ€ì˜ ë„ì„œê´€ì— ì˜¤ì‹  ê²ƒì„ í™˜ì˜í•©ë‹ˆë‹¤. ì´ê³³ì—ëŠ” ìŠí˜€ì§„ ì´ì•¼ê¸°ë“¤ì´ ì ë“¤ì–´ ìˆìŠµë‹ˆë‹¤...",
      "items": {
        "ancient_tome": "ê³ ëŒ€ ì„œì±…",
        "quill_pen": "ê¹ƒíœ",
        "memory_fragment": "ê¸°ì–µ ì¡°ê°"
      },
      "quest": {
        "discover_origin": "ì„¸ê³„ì˜ ê¸°ì›ì„ ë°œê²¬í•˜ê¸°",
        "collect_memories": "ê¸°ì–µ ì¡°ê° 3ê°œ ìˆ˜ì§‘í•˜ê¸°"
      },
      "rule": {
        "time_flows": "ì‹œê°„ì˜ íë¦„",
        "time_flows_desc": "ì‹œê°„ì€ ì •ìƒì ìœ¼ë¡œ íë¦…ë‹ˆë‹¤",
        "memories_persist": "ê¸°ì–µì˜ ì§€ì†",
        "memories_persist_desc": "í•œë²ˆ ì–»ì€ ê¸°ì–µì€ ì‚¬ë¼ì§€ì§€ ì•ŠìŠµë‹ˆë‹¤"
      },
      "scene": {
        "bookshelf": "ì‹ ë¹„í•œ ì±…ì¥",
        "bookshelf_hint": "ì˜¤ë˜ëœ ì±…ë“¤ì´ ë¹›ë‚˜ê³  ìˆë‹¤",
        "portal": "ë¹›ë‚˜ëŠ” í¬íƒˆ",
        "portal_hint": "ì–´ë”˜ê°€ë¡œ í†µí•˜ëŠ” ê²ƒ ê°™ë‹¤"
      }
    },
    "explorer": {
      "name": "íƒí—˜ê°€",
      "description": "ë¯¸ì§€ì˜ ì˜ì—­ì„ íƒí—˜í•˜ê³  ë¹„ë°€ì„ ë°œê²¬í•˜ì„¸ìš”",
      "welcome": "ì–´ë‘ìš´ ë¯¸ë¡œì—ì„œ ëˆˆì„ ë–´ìŠµë‹ˆë‹¤. ì¶œêµ¬ë¥¼ ì°¾ì•„ ì´ê³³ì„ íƒˆì¶œí•´ì•¼ í•©ë‹ˆë‹¤...",
      "items": {
        "compass": "ë‚˜ì¹¨ë°˜",
        "rope": "ë°§ì¤„",
        "lantern": "ëœí„´",
        "map_fragment": "ì§€ë„ ì¡°ê°"
      },
      "quest": {
        "find_exit": "íƒˆì¶œêµ¬ ì°¾ê¸°",
        "explore_areas": "3ê°œ êµ¬ì—­ íƒí—˜í•˜ê¸°",
        "gather_supplies": "ë³´ê¸‰í’ˆ ìˆ˜ì§‘"
      },
      "rule": {
        "gravity": "ì¤‘ë ¥ ë²•ì¹™",
        "gravity_desc": "ë¬¼ì²´ëŠ” ì•„ë˜ë¡œ ë–¨ì–´ì§‘ë‹ˆë‹¤",
        "darkness": "ì–´ë‘ ì˜ ë²•ì¹™",
        "darkness_desc": "ë¹› ì—†ì´ëŠ” ì•ì„ ë³¼ ìˆ˜ ì—†ìŠµë‹ˆë‹¤"
      },
      "scene": {
        "door": "ê³ ëŒ€ì˜ ë¬¸",
        "door_hint": "ì—´ì‡ ê°€ í•„ìš”í•´ ë³´ì¸ë‹¤",
        "mechanism": "ì´ìƒí•œ ì¥ì¹˜",
        "mechanism_hint": "ì‘ë™ì‹œí‚¬ ìˆ˜ ìˆì„ ê²ƒ ê°™ë‹¤",
        "passage": "ìˆ¨ê²¨ì§„ í†µë¡œ",
        "passage_hint": "ì–´ë””ë¡œ ì´ì–´ì§ˆê¹Œ?"
      }
    },
    "tech": {
      "name": "ê¸°ìˆ  ì „ë¬¸ê°€",
      "description": "ì œí•œëœ ìì›ìœ¼ë¡œ íš¨ìœ¨ì ì¸ ì „ëµì„ ì„¸ìš°ì„¸ìš”",
      "welcome": "ì‹œìŠ¤í…œ ë¶€íŒ… ì™„ë£Œ. ì œí•œëœ ì—ë„ˆì§€ë¡œ ìµœì ì˜ ê²½ë¡œë¥¼ ì°¾ì•„ì•¼ í•©ë‹ˆë‹¤...",
      "items": {
        "data_core": "ë°ì´í„° ì½”ì–´",
        "circuit_board": "íšŒë¡œ ê¸°íŒ",
        "energy_cell": "ì—ë„ˆì§€ ì…€",
        "scanner": "ìŠ¤ìºë„ˆ ì¥ì¹˜"
      },
      "quest": {
        "analyze_system": "ì‹œìŠ¤í…œ ë¶„ì„ ì™„ë£Œí•˜ê¸°",
        "optimize_resources": "ìì› íš¨ìœ¨ ìµœì í™”í•˜ê¸°"
      },
      "rule": {
        "energy_conservation": "ì—ë„ˆì§€ ë³´ì¡´",
        "energy_conservation_desc": "ì—ë„ˆì§€ëŠ” ìƒì„±ë˜ê±°ë‚˜ ì†Œë©¸ë˜ì§€ ì•ŠìŠµë‹ˆë‹¤",
        "data_integrity": "ë°ì´í„° ë¬´ê²°ì„±",
        "data_integrity_desc": "ì†ìƒëœ ë°ì´í„°ëŠ” ë³µêµ¬í•  ìˆ˜ ì—†ìŠµë‹ˆë‹¤",
        "system_limits": "ì‹œìŠ¤í…œ í•œê³„",
        "system_limits_desc": "ë™ì‹œ ì²˜ë¦¬ëŸ‰ì— ì œí•œì´ ìˆìŠµë‹ˆë‹¤"
      },
      "scene": {
        "terminal": "ë©”ì¸ í„°ë¯¸ë„",
        "terminal_hint": "ì‹œìŠ¤í…œì— ì ‘ì†í•  ìˆ˜ ìˆë‹¤",
        "conduit": "ì „ë ¥ ë„ê´€",
        "conduit_hint": "ì—ë„ˆì§€ê°€ íë¥´ê³  ìˆë‹¤"
      }
    }
  },
  "reset": {
    "button": "ë¦¬ì…‹",
    "confirm": "ë‹¤ì‹œ í´ë¦­í•˜ì—¬ í™•ì¸",
    "cancel": "ì·¨ì†Œ",
    "tooltip": "í˜„ì¬ í”„ë¡œí•„ì˜ ì´ˆê¸° ìƒíƒœë¡œ ë˜ëŒë¦½ë‹ˆë‹¤"
  },
  "demo": {
    "items": {
      "keycard-alpha": {
        "name": "í‚¤ì¹´ë“œ A"
      },
      "medkit": {
        "name": "ì‘ê¸‰ í‚¤íŠ¸"
      },
      "flashlight": {
        "name": "ì†ì „ë“±"
      },
      "data-chip": {
        "name": "ë°ì´í„°ì¹©"
      }
    },
    "scene": {
      "terminal": {
        "label": "í„°ë¯¸ë„",
        "hint": "í™œì„±í™”ëœ í„°ë¯¸ë„ì´ë‹¤"
      },
      "door": {
        "label": "ë¬¸",
        "hint": "ì ê²¨ìˆëŠ” ê²ƒ ê°™ë‹¤"
      }
    },
    "quest": {
      "terminal": {
        "label": "í„°ë¯¸ë„ì— ì ‘ì†í•˜ê¸°"
      },
      "escape": {
        "label": "ì‹œì„¤ íƒˆì¶œêµ¬ ì°¾ê¸°"
      },
      "collect": {
        "label": "ë°ì´í„°ì¹© ìˆ˜ì§‘"
      }
    },
    "rule": {
      "gravity": {
        "label": "ì¤‘ë ¥ ë²•ì¹™",
        "description": "ë¬¼ì²´ëŠ” ì•„ë˜ë¡œ ë–¨ì–´ì§„ë‹¤"
      },
      "time": {
        "label": "ì‹œê°„ íë¦„",
        "description": "ì‹œê°„ì€ ì •ìƒ ì†ë„ë¡œ íë¥¸ë‹¤"
      }
    }
  },
  "quest": {
    "empty": "[ ëª©í‘œ ì—†ìŒ ]",
    "completed": "ì™„ë£Œ",
    "section": {
      "active": "ì§„í–‰ ì¤‘",
      "completed": "ì™„ë£Œë¨"
    }
  },
  "rule_board": {
    "empty": "[ ê·œì¹™ ì—†ìŒ ]",
    "active_count": "í™œì„± ê·œì¹™: {{count}}ê°œ"
  },
  "mutation": {
    "empty": "[ ë³€í˜• ì´ë ¥ ì—†ìŒ ]",
    "timeline_title": "ë³€í˜• íƒ€ì„ë¼ì¸",
    "event_count": "{{count}}ê°œ ì´ë²¤íŠ¸",
    "more_events": "+{{count}}ê°œ ë” ë³´ê¸°",
    "turn_label": "T{{turn}}",
    "type": {
      "added": "ì¶”ê°€ë¨",
      "modified": "ìˆ˜ì •ë¨",
      "removed": "ì œê±°ë¨"
    }
  },
  "scene": {
    "status": {
      "default": "ë°ì´í„° ëŒ€ê¸° ì¤‘",
      "loading": "ë™ê¸°í™” ì¤‘...",
      "offline": "ì—°ê²° ëŠê¹€",
      "blocked": "ì ‘ê·¼ ì œí•œë¨",
      "low_signal": "ì‹ í˜¸ ì•½í•¨",
      "image_error": "ì¥ë©´ ì´ë¯¸ì§€ë¥¼ ë¶ˆëŸ¬ì˜¬ ìˆ˜ ì—†ìŠµë‹ˆë‹¤.",
      "image_loading": "ì¥ë©´ ì´ë¯¸ì§€ ë¡œë”© ì¤‘...",
      "image_generating": "ìƒˆ ì¥ë©´ ìƒì„± ì¤‘...",
      "initial_sync": "ì „ì—­ ë°ì´í„° ë™ê¸°í™” ëŒ€ê¸° ì¤‘...",
      "syncing": "ë°ì´í„° ë™ê¸°í™” ì¤‘...",
      "alt": "ì¥ë©´ ì´ë¯¸ì§€"
    },
    "hotspot": {
      "layer_label": "í´ë¦­ ê°€ëŠ¥í•œ ì˜¤ë¸Œì íŠ¸ ì˜ì—­",
      "hint_prefix": "íŒíŠ¸",
      "click_action": "{{label}} í´ë¦­",
      "drop_hint": "ì—¬ê¸°ì— ë“œë¡­í•˜ì—¬ ì‚¬ìš©",
      "drop_action": "{{item}}ì„(ë¥¼) {{target}}ì— ì‚¬ìš©",
      "drop_invalid": "ê·¸ê³³ì—ëŠ” {{item}}ì„(ë¥¼) ì‚¬ìš©í•  ìˆ˜ ì—†ìŠµë‹ˆë‹¤.",
      "demo_hint": "[ë°ëª¨ ëŒ€ìƒ]"
    }
  },
  "agent": {
    "console": {
      "queue": "ëŒ€ê¸°ì—´",
      "badges": "ê²€ì¦ ë°°ì§€",
      "repair": "ìë™ ë³µêµ¬",
      "status": {
        "idle": "ëŒ€ê¸° ì¤‘",
        "processing": "ì²˜ë¦¬ ì¤‘"
      },
      "badges_empty": "[ ê²€ì¦ ëŒ€ê¸° ì¤‘ ]",
      "repaired": "(ë³µêµ¬ë¨)",
      "phase": {
        "parse": "Parse",
        "validate": "Validate",
        "plan": "Plan",
        "resolve": "Resolve",
        "render": "Render",
        "verify": "Verify",
        "commit": "Commit"
      },
      "badge": {
        "schema": "Schema",
        "economy": "Economy",
        "safety": "Safety",
        "consistency": "Consistency",
        "ok": "OK",
        "fail": "FAIL"
      }
    }
  },
  "ui": {
    "logo": "UNKNOWN WORLD",
    "command_placeholder": "ëª…ë ¹ì„ ì…ë ¥í•˜ì„¸ìš”...",
    "processing": "ì²˜ë¦¬ ì¤‘...",
    "execute": "ì‹¤í–‰",
    "wait": "ëŒ€ê¸°",
    "panel_placeholder": "[ ì¤€ë¹„ ì¤‘ ]",
    "scale_decrease": "ê¸€ì í¬ê¸° ì¤„ì´ê¸°",
    "scale_increase": "ê¸€ì í¬ê¸° ëŠ˜ë¦¬ê¸°",
    "scale_label": "UI ìŠ¤ì¼€ì¼ ì„¤ì •"
  },
  "economy": {
    "signal": "Signal",
    "shard": "Shard",
    "signal_cost": "Signal ì†Œëª¨",
    "shard_cost": "Shard ì†Œëª¨",
    "risk_level": "ìœ„í—˜ë„",
    "hud_label": "ì¬í™” í˜„í™©",
    "estimated_cost": "ì˜ˆìƒ ë¹„ìš©",
    "confirmed_cost": "í™•ì • ë¹„ìš©",
    "insufficient_funds": "ì”ì•¡ ë¶€ì¡±",
    "low_balance_warning": "ì”ì•¡ì´ ë¶€ì¡±í•©ë‹ˆë‹¤",
    "alternatives_title": "ëŒ€ì•ˆ í–‰ë™",
    "alternative_text_only": "í…ìŠ¤íŠ¸ë§Œ ìƒì„± (ì´ë¯¸ì§€ ì—†ìŒ)",
    "alternative_low_quality": "ì €í’ˆì§ˆ/ë¹ ë¥¸ ì‘ë‹µ ì„ íƒ",
    "ledger_title": "ìµœê·¼ ì›ì¥ ì´ë ¥",
    "ledger_empty": "[ ì´ë ¥ ì—†ìŒ ]",
    "model_label": {
      "FAST": "ë¹ ë¦„",
      "QUALITY": "ê³ í’ˆì§ˆ",
      "CHEAP": "ì €ë¹„ìš©",
      "REF": "ì°¸ì¡°"
    }
  },
  "connection": {
    "online": "ì˜¨ë¼ì¸",
    "offline": "ì˜¤í”„ë¼ì¸"
  },
  "inventory": {
    "empty": "[ ì•„ì´í…œ ì—†ìŒ ]",
    "grid_label": "ì¸ë²¤í† ë¦¬ ì•„ì´í…œ ëª©ë¡",
    "item_label": "{{name}} (ìˆ˜ëŸ‰: {{quantity}})",
    "drag_hint": "ë“œë˜ê·¸í•˜ì—¬ ì‚¬ìš©"
  },
  "panel": {
    "inventory": {
      "title": "Inventory",
      "placeholder": "[ ë“œë˜ê·¸ ì•¤ ë“œë¡­ ì˜ì—­ ]"
    },
    "quest": {
      "title": "Quest",
      "placeholder": "[ ëª©í‘œ/í€˜ìŠ¤íŠ¸ ëª©ë¡ ]"
    },
    "rule_board": {
      "title": "Rule Board",
      "placeholder": "[ ì›”ë“œ ê·œì¹™/ë³€í˜• íƒ€ì„ë¼ì¸ ]"
    },
    "agent_console": {
      "title": "Agent Console"
    },
    "memory_pin": {
      "title": "Memory Pin",
      "placeholder": "[ ê³ ì •ëœ ê¸°ì–µ/ë‹¨ì„œ ]"
    },
    "scanner": {
      "title": "Scanner",
      "placeholder": "[ ì´ë¯¸ì§€ ì—…ë¡œë“œ ìŠ¬ë¡¯ ]"
    }
  },
  "scanner": {
    "dropzone_label": "ì´ë¯¸ì§€ë¥¼ ë“œë¡­í•˜ê±°ë‚˜ í´ë¦­í•˜ì—¬ ì—…ë¡œë“œ",
    "dropzone_text": "ì´ë¯¸ì§€ë¥¼ ë“œë¡­í•˜ì„¸ìš”",
    "dropzone_hint": "ë˜ëŠ” í´ë¦­í•˜ì—¬ íŒŒì¼ ì„ íƒ",
    "upload_label": "ì´ë¯¸ì§€ ì—…ë¡œë“œ",
    "preview_alt": "ì—…ë¡œë“œ ì´ë¯¸ì§€ ë¯¸ë¦¬ë³´ê¸°",
    "uploading": "ì—…ë¡œë“œ ì¤‘...",
    "analyzing": "ë¶„ì„ ì¤‘...",
    "retry": "ë‹¤ì‹œ ì‹œë„",
    "cancel": "ì·¨ì†Œ",
    "select_items": "ì¸ë²¤í† ë¦¬ì— ì¶”ê°€í•  ì•„ì´í…œì„ ì„ íƒí•˜ì„¸ìš”",
    "add_to_inventory": "ì¶”ê°€ ({{count}}ê°œ)",
    "detected_objects": "ê°ì§€ëœ ì˜¤ë¸Œì íŠ¸: {{count}}ê°œ",
    "item_candidates": "ì•„ì´í…œ í›„ë³´: {{count}}ê°œ",
    "no_candidates": "ì•„ì´í…œ í›„ë³´ë¥¼ ì°¾ì§€ ëª»í–ˆìŠµë‹ˆë‹¤",
    "error": {
      "unsupported_format": "ì§€ì›í•˜ì§€ ì•ŠëŠ” ì´ë¯¸ì§€ í˜•ì‹ì…ë‹ˆë‹¤",
      "file_too_large": "íŒŒì¼ì´ ë„ˆë¬´ í½ë‹ˆë‹¤ (ìµœëŒ€ 20MB)",
      "unknown": "ì•Œ ìˆ˜ ì—†ëŠ” ì˜¤ë¥˜ê°€ ë°œìƒí–ˆìŠµë‹ˆë‹¤"
    },
    "item_type": {
      "key": "ì—´ì‡ ",
      "weapon": "ë¬´ê¸°",
      "tool": "ë„êµ¬",
      "clue": "ë‹¨ì„œ",
      "material": "ì¬ë£Œ",
      "consumable": "ì†Œëª¨í’ˆ",
      "document": "ë¬¸ì„œ",
      "artifact": "ìœ ë¬¼"
    }
  },
  "action": {
    "default": {
      "explore": {
        "label": "íƒìƒ‰í•˜ê¸°",
        "description": "ì£¼ë³€ì„ ì‚´í´ë³¸ë‹¤"
      },
      "investigate": {
        "label": "ì¡°ì‚¬í•˜ê¸°",
        "description": "ìì„¸íˆ ì‚´í´ë³¸ë‹¤"
      },
      "talk": {
        "label": "ëŒ€í™”í•˜ê¸°",
        "description": "ë§ì„ ê±¸ì–´ë³¸ë‹¤"
      }
    },
    "card_select": "ì¹´ë“œ ì„ íƒ: {{cardId}}",
    "deck_label": "í–‰ë™ ì„ íƒ ì¹´ë“œ",
    "alternative": "ëŒ€ì•ˆ",
    "insufficient_balance": "ì”ì•¡ ë¶€ì¡±",
    "all_disabled_notice": "ì‹¤í–‰ ê°€ëŠ¥í•œ í–‰ë™ì´ ì—†ìŠµë‹ˆë‹¤. ëŒ€ì•ˆì„ í™•ì¸í•˜ì„¸ìš”.",
    "risk": {
      "low": "ë‚®ìŒ",
      "medium": "ë³´í†µ",
      "high": "ë†’ìŒ"
    },
    "cost_range": "{{min}}~{{max}}"
  },
  "narrative": {
    "welcome": "ë¯¸ì§€ì˜ ì„¸ê³„ì— ì˜¤ì‹  ê²ƒì„ í™˜ì˜í•©ë‹ˆë‹¤...",
    "turn_label": "[TURN {{turn}}]",
    "streaming_label": "[STREAMING]"
  }
}
</file>

</files>
