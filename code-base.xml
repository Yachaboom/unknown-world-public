This file is a merged representation of a subset of the codebase, containing specifically included files and files not matching ignore patterns, combined into a single document by Repomix.

<file_summary>
This section contains a summary of this file.

<purpose>
This file contains a packed representation of a subset of the repository's contents that is considered the most important context.
It is designed to be easily consumable by AI systems for analysis, code review,
or other automated processes.
</purpose>

<file_format>
The content is organized as follows:
1. This summary section
2. Repository information
3. Directory structure
4. Repository files (if enabled)
5. Multiple file entries, each consisting of:
  - File path as an attribute
  - Full contents of the file
</file_format>

<usage_guidelines>
- This file should be treated as read-only. Any changes should be made to the
  original repository files, not this packed version.
- When processing this file, use the file path to distinguish
  between different files in the repository.
- Be aware that this file may contain sensitive information. Handle it with
  the same level of security as you would the original repository.
</usage_guidelines>

<notes>
- Some files may have been excluded based on .gitignore rules and Repomix's configuration
- Binary files are not included in this packed representation. Please refer to the Repository Structure section for a complete list of file paths, including binary files
- Only files matching these patterns are included: **/*.{py,toml,json,yaml}
- Files matching these patterns are excluded: .claude/**, .cursor/**, .gemini/**, .vscode/**, vibe/**, backend/.venv/**, frontend/node_modules/**
- Files matching patterns in .gitignore are excluded
- Files matching default ignore patterns are excluded
- Files are sorted by Git change count (files with more changes are at the bottom)
</notes>

</file_summary>

<directory_structure>
backend/pyproject.toml
backend/src/unknown_world/__init__.py
backend/src/unknown_world/api/__init__.py
backend/src/unknown_world/api/image.py
backend/src/unknown_world/api/turn_stream_events.py
backend/src/unknown_world/api/turn_streaming_helpers.py
backend/src/unknown_world/api/turn.py
backend/src/unknown_world/config/__init__.py
backend/src/unknown_world/config/models.py
backend/src/unknown_world/main.py
backend/src/unknown_world/models/__init__.py
backend/src/unknown_world/models/turn.py
backend/src/unknown_world/orchestrator/__init__.py
backend/src/unknown_world/orchestrator/fallback.py
backend/src/unknown_world/orchestrator/generate_turn_output.py
backend/src/unknown_world/orchestrator/mock.py
backend/src/unknown_world/orchestrator/pipeline.py
backend/src/unknown_world/orchestrator/prompt_loader.py
backend/src/unknown_world/orchestrator/repair_loop.py
backend/src/unknown_world/orchestrator/stages/__init__.py
backend/src/unknown_world/orchestrator/stages/commit.py
backend/src/unknown_world/orchestrator/stages/parse.py
backend/src/unknown_world/orchestrator/stages/plan.py
backend/src/unknown_world/orchestrator/stages/render.py
backend/src/unknown_world/orchestrator/stages/resolve.py
backend/src/unknown_world/orchestrator/stages/types.py
backend/src/unknown_world/orchestrator/stages/validate.py
backend/src/unknown_world/orchestrator/stages/verify.py
backend/src/unknown_world/services/__init__.py
backend/src/unknown_world/services/genai_client.py
backend/src/unknown_world/services/image_generation.py
backend/src/unknown_world/services/image_postprocess.py
backend/src/unknown_world/services/rembg_preflight.py
backend/src/unknown_world/validation/__init__.py
backend/src/unknown_world/validation/business_rules.py
backend/src/unknown_world/validation/language_gate.py
backend/tests/integration/test_api.py
backend/tests/integration/test_turn_streaming.py
backend/tests/manual_test_image.py
backend/tests/manual_test_rembg.py
backend/tests/qa/test_asset_manifest.py
backend/tests/unit/api/test_image.py
backend/tests/unit/models/test_turn.py
backend/tests/unit/orchestrator/test_generate_turn_output.py
backend/tests/unit/orchestrator/test_pipeline.py
backend/tests/unit/orchestrator/test_prompt_loader.py
backend/tests/unit/services/test_genai_client.py
backend/tests/unit/services/test_image_generation.py
backend/tests/unit/services/test_rembg_preflight.py
backend/tests/unit/test_dotenv_autoload.py
backend/tests/unit/test_image_generation_integration.py
backend/tests/unit/test_image_postprocess.py
backend/tests/unit/test_orchestrator_repair.py
backend/tests/unit/test_u034_verification.py
backend/tests/unit/test_u043_language_gate.py
frontend/coverage/coverage-final.json
frontend/package.json
frontend/public/ui/manifest.json
frontend/public/ui/manifest.schema.json
frontend/src/locales/en-US/translation.json
frontend/src/locales/ko-KR/translation.json
frontend/tsconfig.json
frontend/tsconfig.node.json
package.json
request.json
shared/schemas/turn/turn_input.schema.json
shared/schemas/turn/turn_output.schema.json
</directory_structure>

<files>
This section contains the contents of the repository's files.

<file path="backend/src/unknown_world/api/image.py">
"""Unknown World - 이미지 생성 API 엔드포인트.

이 모듈은 장면 이미지를 조건부로 생성하는 엔드포인트를 제공합니다.
텍스트 턴의 TTFB를 블로킹하지 않도록 분리된 경로로 동작합니다.

설계 원칙:
    - RULE-004: 실패 시 안전한 폴백 (텍스트-only 진행 가능)
    - RULE-008: 텍스트 우선 + Lazy 이미지 원칙
    - RULE-010: 이미지 모델 ID 고정 (gemini-3-pro-image-preview)
    - RULE-007: 프롬프트 원문/비밀정보 노출 금지

페어링 질문 결정:
    - Q1: Option A (로컬 파일로 저장 후 image_url로 서빙)

참조:
    - vibe/unit-plans/U-019[Mvp].md
    - .cursor/rules/20-backend-orchestrator.mdc
"""

from __future__ import annotations

import logging

from fastapi import APIRouter, Depends, HTTPException
from fastapi.responses import FileResponse
from pydantic import BaseModel, ConfigDict, Field

from unknown_world.services.image_generation import (
    DEFAULT_OUTPUT_DIR,
    ImageGenerationRequest,
    ImageGenerationStatus,
    ImageGeneratorType,
    create_fallback_response,
    get_image_generator,
    validate_image_request,
)

# =============================================================================
# 로거 설정
# =============================================================================

logger = logging.getLogger(__name__)

# =============================================================================
# 라우터 정의
# =============================================================================

router = APIRouter(
    prefix="/api/image",
    tags=["Image Generation"],
)


# =============================================================================
# 의존성 주입
# =============================================================================


async def get_generator():
    """이미지 생성기 의존성."""
    return get_image_generator()


# =============================================================================
# 요청/응답 스키마 (API 계층용)
# =============================================================================


class GenerateImageRequest(BaseModel):
    """이미지 생성 API 요청.

    TurnOutput.render.image_job과 정합되도록 설계합니다.

    Attributes:
        prompt: 이미지 생성 프롬프트 (필수)
        aspect_ratio: 가로세로 비율
        image_size: 이미지 크기
        reference_image_ids: 참조 이미지 ID 목록 (편집용)
        session_id: 세션 ID (파일 그룹화용)
        skip_on_failure: 실패 시 건너뛰기 (텍스트-only 진행)
    """

    model_config = ConfigDict(extra="forbid")

    prompt: str = Field(min_length=1, max_length=2000, description="이미지 생성 프롬프트")
    aspect_ratio: str = Field(default="1:1", description="가로세로 비율")
    image_size: str = Field(default="1024x1024", description="이미지 크기")
    reference_image_ids: list[str] = Field(default_factory=list, description="참조 이미지 ID 목록")
    session_id: str | None = Field(default=None, description="세션 ID")
    skip_on_failure: bool = Field(default=True, description="실패 시 건너뛰기 (텍스트-only 진행)")


class GenerateImageResponse(BaseModel):
    """이미지 생성 API 응답.

    Attributes:
        success: 성공 여부
        status: 생성 상태
        image_id: 생성된 이미지 ID
        image_url: 생성된 이미지 URL
        message: 상태 메시지
        generation_time_ms: 생성 소요 시간
    """

    model_config = ConfigDict(extra="forbid")

    success: bool = Field(description="성공 여부")
    status: ImageGenerationStatus = Field(description="생성 상태")
    image_id: str | None = Field(default=None, description="생성된 이미지 ID")
    image_url: str | None = Field(default=None, description="생성된 이미지 URL")
    message: str | None = Field(default=None, description="상태 메시지")
    generation_time_ms: int = Field(default=0, description="생성 소요 시간 (ms)")


class ImageStatusResponse(BaseModel):
    """이미지 상태 조회 응답.

    Attributes:
        image_id: 이미지 ID
        exists: 이미지 존재 여부
        image_url: 이미지 URL (존재하는 경우)
    """

    model_config = ConfigDict(extra="forbid")

    image_id: str = Field(description="이미지 ID")
    exists: bool = Field(description="이미지 존재 여부")
    image_url: str | None = Field(default=None, description="이미지 URL")


# =============================================================================
# 엔드포인트 정의
# =============================================================================


@router.post(
    "/generate",
    response_model=GenerateImageResponse,
    summary="이미지 생성",
    description="장면 이미지를 생성합니다. 텍스트 턴과 별개로 비동기적으로 호출됩니다.",
)
async def generate_image(
    request: GenerateImageRequest,
    generator: ImageGeneratorType = Depends(get_generator),
) -> GenerateImageResponse:
    """이미지를 생성합니다.

    이 엔드포인트는 TurnOutput의 render.image_job에서 should_generate=true인 경우
    프론트엔드에서 별도로 호출합니다.

    텍스트 턴의 TTFB를 블로킹하지 않습니다 (RULE-008).

    Args:
        request: 이미지 생성 요청
        generator: 이미지 생성기 (의존성 주입)

    Returns:
        GenerateImageResponse: 생성 결과
    """
    # 요청 검증
    validation_error = validate_image_request(
        ImageGenerationRequest(
            prompt=request.prompt,
            aspect_ratio=request.aspect_ratio,
            image_size=request.image_size,
            reference_image_ids=request.reference_image_ids,
            session_id=request.session_id,
        )
    )

    if validation_error:
        logger.warning(
            "[ImageAPI] 요청 검증 실패",
            extra={"error": validation_error},
        )

        if request.skip_on_failure:
            # 실패 시에도 텍스트-only로 진행 가능하도록 폴백 (RULE-004)
            fallback = create_fallback_response(validation_error)
            return GenerateImageResponse(
                success=False,
                status=fallback.status,
                message=fallback.message,
            )
        else:
            raise HTTPException(status_code=400, detail=validation_error)

    # 이미지 생성 실행
    try:
        result = await generator.generate(
            ImageGenerationRequest(
                prompt=request.prompt,
                aspect_ratio=request.aspect_ratio,
                image_size=request.image_size,
                reference_image_ids=request.reference_image_ids,
                session_id=request.session_id,
            )
        )

        success = result.status == ImageGenerationStatus.COMPLETED

        return GenerateImageResponse(
            success=success,
            status=result.status,
            image_id=result.image_id,
            image_url=result.image_url,
            message=result.message,
            generation_time_ms=result.generation_time_ms,
        )

    except Exception as e:
        error_type = type(e).__name__
        logger.error(
            "[ImageAPI] 이미지 생성 중 예외 발생",
            extra={"error_type": error_type},
        )

        if request.skip_on_failure:
            # 예외 발생 시에도 안전한 폴백 (RULE-004)
            return GenerateImageResponse(
                success=False,
                status=ImageGenerationStatus.FAILED,
                message=f"이미지 생성 중 오류가 발생했습니다: {error_type}",
            )
        else:
            raise HTTPException(
                status_code=500,
                detail=f"이미지 생성 실패: {error_type}",
            ) from e


@router.get(
    "/status/{image_id}",
    response_model=ImageStatusResponse,
    summary="이미지 상태 조회",
    description="생성된 이미지의 존재 여부와 URL을 조회합니다.",
)
async def get_image_status(
    image_id: str,
) -> ImageStatusResponse:
    """이미지 상태를 조회합니다.

    Args:
        image_id: 이미지 ID

    Returns:
        ImageStatusResponse: 이미지 상태
    """
    # 파일 존재 확인
    file_path = DEFAULT_OUTPUT_DIR / f"{image_id}.png"
    exists = file_path.exists()

    return ImageStatusResponse(
        image_id=image_id,
        exists=exists,
        image_url=f"/static/images/{image_id}.png" if exists else None,
    )


@router.get(
    "/file/{image_id}",
    summary="이미지 파일 조회",
    description="생성된 이미지 파일을 반환합니다.",
    response_class=FileResponse,
)
async def get_image_file(
    image_id: str,
) -> FileResponse:
    """이미지 파일을 반환합니다.

    MVP에서는 로컬 파일을 직접 서빙합니다.
    MMP에서 GCS URL 리다이렉트로 변경 예정.

    Args:
        image_id: 이미지 ID

    Returns:
        FileResponse: 이미지 파일
    """
    file_path = DEFAULT_OUTPUT_DIR / f"{image_id}.png"

    if not file_path.exists():
        raise HTTPException(status_code=404, detail="이미지를 찾을 수 없습니다.")

    return FileResponse(
        path=str(file_path),
        media_type="image/png",
        filename=f"{image_id}.png",
    )


@router.get(
    "/health",
    summary="이미지 서비스 헬스체크",
    description="이미지 생성 서비스의 상태를 확인합니다.",
)
async def image_health(
    generator: ImageGeneratorType = Depends(get_generator),
) -> dict[str, str | bool]:
    """이미지 서비스 헬스체크.

    Args:
        generator: 이미지 생성기

    Returns:
        헬스 상태 정보
    """
    is_available = generator.is_available()
    mode = (
        "mock"
        if hasattr(generator, "_output_dir")
        and isinstance(generator, type(get_image_generator(force_mock=True)))
        else "real"
    )

    return {
        "status": "ok" if is_available else "degraded",
        "available": is_available,
        "mode": mode,
        "model": "gemini-3-pro-image-preview",
    }
</file>

<file path="backend/src/unknown_world/api/turn_streaming_helpers.py">
"""Unknown World - Turn 스트리밍 공통 헬퍼.

NDJSON 스트리밍에서 반복되는 패턴을 추출한 헬퍼 함수들입니다.

설계 원칙:
    - RU-005-Q3: 중복되는 스트리밍 조각을 helper로 추출
    - RULE-004: 에러 경로에서도 final 1회 종료 인바리언트 유지
    - RULE-007/008: 프롬프트/내부 추론 노출 금지

참조:
    - vibe/refactors/RU-005-Q3.md
    - vibe/unit-plans/U-007[Mvp].md
"""

from __future__ import annotations

import asyncio
from collections.abc import AsyncGenerator

from unknown_world.api.turn_stream_events import (
    ErrorEvent,
    FinalEvent,
    NarrativeDeltaEvent,
    StreamEventType,
    serialize_event,
)
from unknown_world.models.turn import (
    CurrencyAmount,
    Language,
    TurnOutput,
)
from unknown_world.orchestrator.fallback import create_safe_fallback

# =============================================================================
# 스트리밍 헬퍼 상수
# =============================================================================

DEFAULT_CHUNK_SIZE = 20
"""내러티브 델타 청크 크기 (문자 수)."""

DEFAULT_TYPING_DELAY_SEC = 0.02
"""타자 효과 딜레이 (초)."""

# =============================================================================
# 에러 메시지 (i18n)
# =============================================================================

ERROR_MESSAGES = {
    Language.KO: {
        "internal_error": "처리 중 오류가 발생했습니다",
        "validation_error": "입력 검증에 실패했습니다",
    },
    Language.EN: {
        "internal_error": "An error occurred during processing",
        "validation_error": "Input validation failed",
    },
}


# =============================================================================
# 내러티브 델타 스트리밍 헬퍼
# =============================================================================


async def stream_narrative_delta(
    narrative: str,
    *,
    chunk_size: int = DEFAULT_CHUNK_SIZE,
    delay_sec: float = DEFAULT_TYPING_DELAY_SEC,
) -> AsyncGenerator[str]:
    """내러티브 텍스트를 타자 효과로 스트리밍합니다.

    Args:
        narrative: 전체 내러티브 텍스트
        chunk_size: 청크당 문자 수 (기본 20)
        delay_sec: 청크 간 딜레이 (초, 기본 0.02)

    Yields:
        str: NDJSON 라인 (narrative_delta 이벤트)

    Example:
        >>> async for line in stream_narrative_delta("안녕하세요"):
        ...     print(line)
    """
    for i in range(0, len(narrative), chunk_size):
        chunk = narrative[i : i + chunk_size]
        yield serialize_event(
            NarrativeDeltaEvent(
                type=StreamEventType.NARRATIVE_DELTA,
                text=chunk,
            ).model_dump()
        )
        await asyncio.sleep(delay_sec)


# =============================================================================
# Error + Final 폴백 헬퍼
# =============================================================================


async def emit_error_with_fallback(
    language: Language,
    *,
    error_message: str | None = None,
    error_code: str = "INTERNAL_ERROR",
    economy_snapshot: CurrencyAmount | None = None,
    repair_count: int = 0,
    is_blocked: bool = False,
) -> AsyncGenerator[str]:
    """에러 이벤트와 안전한 폴백 final을 순서대로 송출합니다.

    RULE-004: 에러 경로에서도 반드시 final 1회 종료 인바리언트를 유지합니다.

    Args:
        language: 응답 언어
        error_message: 에러 메시지 (None이면 기본 메시지 사용)
        error_code: 에러 코드 (기본 "INTERNAL_ERROR")
        economy_snapshot: 현재 재화 상태
        repair_count: 복구 시도 횟수
        is_blocked: 안전 정책에 의해 차단되었는지

    Yields:
        str: NDJSON 라인 (error 이벤트 → final 이벤트)

    Example:
        >>> async for line in emit_error_with_fallback(Language.KO):
        ...     print(line)
    """
    # 에러 메시지 결정
    messages = ERROR_MESSAGES[language]
    message = error_message or messages.get("internal_error", "Error occurred")

    # 에러 이벤트 송출
    yield serialize_event(
        ErrorEvent(
            type=StreamEventType.ERROR,
            message=message,
            code=error_code,
        ).model_dump()
    )

    # 안전한 폴백 생성 및 송출
    fallback = create_safe_fallback(
        language=language,
        economy_snapshot=economy_snapshot,
        repair_count=repair_count,
        is_blocked=is_blocked,
    )
    yield serialize_event(
        FinalEvent(
            type=StreamEventType.FINAL,
            data=fallback,
        ).model_dump(mode="json")
    )


async def emit_final(output: TurnOutput) -> AsyncGenerator[str]:
    """최종 TurnOutput을 final 이벤트로 송출합니다.

    Args:
        output: 최종 TurnOutput

    Yields:
        str: NDJSON 라인 (final 이벤트)
    """
    yield serialize_event(
        FinalEvent(
            type=StreamEventType.FINAL,
            data=output,
        ).model_dump(mode="json")
    )


# =============================================================================
# 복합 헬퍼 (내러티브 + final)
# =============================================================================


async def stream_output_with_narrative(
    output: TurnOutput,
    *,
    chunk_size: int = DEFAULT_CHUNK_SIZE,
    delay_sec: float = DEFAULT_TYPING_DELAY_SEC,
) -> AsyncGenerator[str]:
    """내러티브 델타 스트리밍 후 final 이벤트를 송출합니다.

    Args:
        output: 최종 TurnOutput
        chunk_size: 청크당 문자 수
        delay_sec: 청크 간 딜레이 (초)

    Yields:
        str: NDJSON 라인 (narrative_delta 이벤트들 → final 이벤트)
    """
    # 내러티브 델타 스트리밍
    async for line in stream_narrative_delta(
        output.narrative,
        chunk_size=chunk_size,
        delay_sec=delay_sec,
    ):
        yield line

    # final 이벤트 송출
    async for line in emit_final(output):
        yield line


# =============================================================================
# 모듈 공개 API
# =============================================================================

__all__ = [
    "DEFAULT_CHUNK_SIZE",
    "DEFAULT_TYPING_DELAY_SEC",
    "ERROR_MESSAGES",
    "stream_narrative_delta",
    "emit_error_with_fallback",
    "emit_final",
    "stream_output_with_narrative",
]
</file>

<file path="backend/src/unknown_world/config/__init__.py">
"""Unknown World - 설정 및 상수 패키지.

이 패키지는 프로젝트 전역에서 사용하는 설정값과 상수를 관리합니다.
모델 ID, 환경 설정, 정책 등 SSOT를 유지하기 위한 중앙 저장소입니다.

참조:
    - vibe/tech-stack.md (버전/모델 SSOT)
    - .cursor/rules/00-core-critical.mdc (RULE-010: 버전/스택 고정)
"""

from unknown_world.config.models import (
    MODEL_FAST,
    MODEL_IMAGE,
    MODEL_QUALITY,
    ModelLabel,
    get_model_id,
)

__all__ = [
    "MODEL_FAST",
    "MODEL_QUALITY",
    "MODEL_IMAGE",
    "ModelLabel",
    "get_model_id",
]
</file>

<file path="backend/src/unknown_world/config/models.py">
"""Unknown World - 모델 라벨 및 ID 상수 정의.

이 모듈은 Gemini 모델 ID와 라벨을 SSOT로 관리합니다.
tech-stack.md 기준으로 버전/모델 ID가 고정되어 있으며,
임의 변경은 RULE-010 위반입니다.

모델 라인업 (tech-stack.md 기준):
    - 텍스트 FAST: gemini-3-flash-preview
    - 텍스트 QUALITY: gemini-3-pro-preview
    - 이미지(생성/편집): gemini-3-pro-image-preview (고정)

참조:
    - vibe/tech-stack.md (버전 기준일: 2026-01-01)
    - .cursor/rules/00-core-critical.mdc (RULE-007/010)
"""

from enum import StrEnum
from typing import Final


class ModelLabel(StrEnum):
    """모델 라벨 열거형.

    UI/로그에는 모델 ID 원문 대신 이 라벨을 우선 노출합니다. (RULE-008)
    """

    FAST = "FAST"
    """빠른 응답용 텍스트 모델 (gemini-3-flash-preview)"""

    QUALITY = "QUALITY"
    """고품질 텍스트 모델 (gemini-3-pro-preview)"""

    IMAGE = "IMAGE"
    """이미지 생성/편집 모델 (gemini-3-pro-image-preview, 고정)"""

    VISION = "VISION"
    """비전/공간 분석 모델 (bbox/segmentation용, gemini-3-flash-preview)"""


# =============================================================================
# 모델 ID 상수 (tech-stack.md SSOT)
# =============================================================================
# 주의: 이 값들은 tech-stack.md와 1:1로 일치해야 합니다.
# 임의 변경 금지 (RULE-010)

MODEL_FAST: Final[str] = "gemini-3-flash-preview"
"""FAST 라벨 모델 ID - 빠른 텍스트 생성용"""

MODEL_QUALITY: Final[str] = "gemini-3-pro-preview"
"""QUALITY 라벨 모델 ID - 고품질 텍스트 생성용"""

MODEL_IMAGE: Final[str] = "gemini-3-pro-image-preview"
"""IMAGE 라벨 모델 ID - 이미지 생성/편집용 (고정, RULE-010)"""

MODEL_VISION: Final[str] = "gemini-3-flash-preview"
"""VISION 라벨 모델 ID - 비전/공간 분석용 (bbox/segmentation)"""


# 라벨-ID 매핑 테이블
_MODEL_MAP: Final[dict[ModelLabel, str]] = {
    ModelLabel.FAST: MODEL_FAST,
    ModelLabel.QUALITY: MODEL_QUALITY,
    ModelLabel.IMAGE: MODEL_IMAGE,
    ModelLabel.VISION: MODEL_VISION,
}


def get_model_id(label: ModelLabel) -> str:
    """라벨로 모델 ID를 조회합니다.

    Args:
        label: 모델 라벨 (FAST, QUALITY, IMAGE, VISION)

    Returns:
        해당 라벨에 매핑된 모델 ID 문자열

    Example:
        >>> get_model_id(ModelLabel.FAST)
        'gemini-3-flash-preview'
    """
    return _MODEL_MAP[label]
</file>

<file path="backend/src/unknown_world/models/__init__.py">
"""Unknown World - 모델 패키지.

이 패키지는 TurnInput/TurnOutput 스키마 및 하위 타입을 정의합니다.
Gemini Structured Outputs(JSON Schema)용으로 설계되었습니다.

사용 예시:
    from unknown_world.models import TurnInput, TurnOutput

    # Pydantic → JSON Schema 변환 (Gemini response_json_schema용)
    schema = TurnOutput.model_json_schema()

    # 응답 검증
    output = TurnOutput.model_validate_json(response_text)

참조:
    - vibe/prd.md 8.7 (데이터 모델 설계)
    - vibe/ref/structured-outputs-guide.md
    - .cursor/rules/00-core-critical.mdc (RULE-003, RULE-005)
"""

from unknown_world.models.turn import (
    ActionCard,
    ActionDeck,
    AgentConsole,
    AgentPhase,
    Box2D,
    ClickInput,
    ClientInfo,
    Coordinate,
    CurrencyAmount,
    EconomyOutput,
    EconomySnapshot,
    ImageJob,
    Language,
    MemoryPin,
    ModelLabel,
    Quest,
    RenderOutput,
    RiskLevel,
    SafetyOutput,
    SceneObject,
    Theme,
    TurnInput,
    TurnOutput,
    UIOutput,
    ValidationBadge,
    WorldDelta,
    WorldRule,
)

__all__ = [
    # Enum 타입
    "Language",
    "Theme",
    "AgentPhase",
    "ValidationBadge",
    "ModelLabel",
    "RiskLevel",
    # 공통 하위 타입
    "Coordinate",
    "Box2D",
    "CurrencyAmount",
    # TurnInput 관련
    "TurnInput",
    "ClickInput",
    "ClientInfo",
    "EconomySnapshot",
    # TurnOutput 관련
    "TurnOutput",
    "UIOutput",
    "ActionDeck",
    "ActionCard",
    "SceneObject",
    "WorldDelta",
    "WorldRule",
    "Quest",
    "MemoryPin",
    "RenderOutput",
    "ImageJob",
    "EconomyOutput",
    "SafetyOutput",
    "AgentConsole",
]
</file>

<file path="backend/src/unknown_world/orchestrator/pipeline.py">
"""Unknown World - Pipeline 실행기.

Stage 함수들을 체인으로 조합하여 실행하는 파이프라인입니다.

설계 원칙:
    - Option A (RU-005 Q1 결정): 함수 체인 방식, 클래스 도입 없음
    - 동작 보존: 기존 mock/real 경로의 결과(JSON) 의미 유지
    - 관측 가능성 SSOT: stage start/complete/fail, badges, repair를 일관되게 생성
    - 레이어링 보호: 오케스트레이터가 FastAPI에 직접 의존하지 않음

참조:
    - vibe/refactors/RU-005-Q4.md
    - vibe/refactors/RU-005-SUMMARY.md
"""

from __future__ import annotations

import os
from collections.abc import Sequence

from unknown_world.models.turn import CurrencyAmount, TurnInput
from unknown_world.orchestrator.fallback import create_safe_fallback
from unknown_world.orchestrator.stages.commit import commit_stage
from unknown_world.orchestrator.stages.parse import parse_stage
from unknown_world.orchestrator.stages.plan import plan_stage
from unknown_world.orchestrator.stages.render import render_stage
from unknown_world.orchestrator.stages.resolve import resolve_stage
from unknown_world.orchestrator.stages.types import (
    EmitFn,
    PipelineContext,
    StageFn,
)
from unknown_world.orchestrator.stages.validate import validate_stage
from unknown_world.orchestrator.stages.verify import verify_stage

# =============================================================================
# 기본 Stage 순서 (PRD 기준)
# =============================================================================

DEFAULT_STAGES: Sequence[StageFn] = [
    parse_stage,
    validate_stage,
    plan_stage,
    resolve_stage,
    render_stage,
    verify_stage,
    commit_stage,
]
"""기본 파이프라인 단계 순서.

Parse → Validate → Plan → Resolve → Render → Verify → Commit
"""


# =============================================================================
# Pipeline 실행 함수
# =============================================================================


def _is_mock_mode() -> bool:
    """Mock 모드 여부를 확인합니다.

    UW_MODE 환경변수가 'mock'이면 Mock 모드로 동작합니다.
    기본값은 'mock'입니다 (MVP 단계).
    """
    return os.environ.get("UW_MODE", "mock").lower() == "mock"


def create_pipeline_context(
    turn_input: TurnInput,
    *,
    seed: int | None = None,
    is_mock: bool | None = None,
) -> PipelineContext:
    """파이프라인 컨텍스트를 생성합니다.

    Args:
        turn_input: 사용자 턴 입력
        seed: Mock 모드 시드 (재현성 보장)
        is_mock: Mock 모드 여부 (None이면 환경변수 기준)

    Returns:
        초기화된 파이프라인 컨텍스트
    """
    economy_snapshot = CurrencyAmount(
        signal=turn_input.economy_snapshot.signal,
        memory_shard=turn_input.economy_snapshot.memory_shard,
    )

    return PipelineContext(
        turn_input=turn_input,
        economy_snapshot=economy_snapshot,
        is_mock=is_mock if is_mock is not None else _is_mock_mode(),
        seed=seed,
    )


async def run_pipeline(
    ctx: PipelineContext,
    *,
    emit: EmitFn,
    stages: Sequence[StageFn] | None = None,
) -> PipelineContext:
    """파이프라인을 실행합니다.

    Stage 함수들을 순서대로 실행하고, 각 단계에서 emit 콜백을 통해
    도메인 이벤트를 전달합니다.

    예외가 발생하면 안전한 폴백으로 종료합니다 (RULE-004).

    Args:
        ctx: 파이프라인 컨텍스트
        emit: 이벤트 emit 콜백
        stages: 실행할 stage 목록 (None이면 기본 순서)

    Returns:
        최종 파이프라인 컨텍스트

    Example:
        >>> ctx = create_pipeline_context(turn_input, seed=42)
        >>> ctx = await run_pipeline(ctx, emit=my_emit_fn)
        >>> print(ctx.output.narrative)
    """
    if stages is None:
        stages = DEFAULT_STAGES

    try:
        for stage in stages:
            ctx = await stage(ctx, emit=emit)

            # output이 None이면 validate 실패 등 → 이후 단계는 스킵
            # (단, parse 단계는 output이 없어도 정상)
            if ctx.output is None and stage != parse_stage:
                # 폴백 생성
                ctx.output = create_safe_fallback(
                    language=ctx.turn_input.language,
                    economy_snapshot=ctx.economy_snapshot,
                    repair_count=ctx.repair_attempts,
                )
                ctx.is_fallback = True
                break

    except Exception:
        # 예외 발생 시 안전한 폴백 (RULE-004)
        ctx.output = create_safe_fallback(
            language=ctx.turn_input.language,
            economy_snapshot=ctx.economy_snapshot,
            repair_count=ctx.repair_attempts,
        )
        ctx.is_fallback = True

    return ctx
</file>

<file path="backend/src/unknown_world/orchestrator/stages/__init__.py">
"""Unknown World - Pipeline Stages 패키지.

오케스트레이터 파이프라인의 각 단계(stage)를 모듈로 분리합니다.

단계 목록 (PRD 기준):
    - parse: 입력 파싱 (이미 TurnInput으로 변환됨, phase 전이만 담당)
    - validate: 비즈니스 룰 검증 + Repair loop (핵심)
    - plan: 계획 수립 (현재 pass-through)
    - resolve: 해결 (현재 pass-through)
    - render: 렌더링 (현재 pass-through)
    - verify: 검증 (현재 pass-through)
    - commit: 커밋 (최종 확정)

설계 원칙:
    - Option A (RU-005 Q1 결정): 함수 체인 방식, 클래스 도입 없음
    - 동작 보존: 기존 mock/real 경로의 결과(JSON) 의미 유지
    - 관측 가능성 SSOT: stage start/complete/fail, badges, repair를 pipeline에서 일관되게 생성

참조:
    - vibe/refactors/RU-005-Q4.md
    - vibe/refactors/RU-005-SUMMARY.md
"""

from unknown_world.orchestrator.stages.commit import commit_stage
from unknown_world.orchestrator.stages.parse import parse_stage
from unknown_world.orchestrator.stages.plan import plan_stage
from unknown_world.orchestrator.stages.render import render_stage
from unknown_world.orchestrator.stages.resolve import resolve_stage
from unknown_world.orchestrator.stages.types import (
    EmitFn,
    PipelineContext,
    PipelineEvent,
    PipelineEventType,
    StageFn,
)
from unknown_world.orchestrator.stages.validate import validate_stage
from unknown_world.orchestrator.stages.verify import verify_stage

__all__ = [
    # Types
    "PipelineContext",
    "PipelineEvent",
    "PipelineEventType",
    "EmitFn",
    "StageFn",
    # Stages
    "parse_stage",
    "validate_stage",
    "plan_stage",
    "resolve_stage",
    "render_stage",
    "verify_stage",
    "commit_stage",
]
</file>

<file path="backend/src/unknown_world/orchestrator/stages/commit.py">
"""Unknown World - Commit Stage.

커밋 단계입니다.
파이프라인의 최종 단계로, TurnOutput을 확정합니다.

설계 원칙:
    - RULE-008: 단계 이벤트 일관성
    - 동작 보존: 기존 시뮬레이션 지연 유지

참조:
    - vibe/refactors/RU-005-Q4.md
"""

from __future__ import annotations

import asyncio

from unknown_world.models.turn import AgentPhase
from unknown_world.orchestrator.stages.types import (
    EmitFn,
    PipelineContext,
    PipelineEvent,
    PipelineEventType,
)

# 모의 처리 지연 시간 (ms)
COMMIT_DELAY_MS = 20


async def commit_stage(ctx: PipelineContext, *, emit: EmitFn) -> PipelineContext:
    """Commit 단계를 실행합니다.

    파이프라인의 최종 단계로, TurnOutput을 확정합니다.

    Args:
        ctx: 파이프라인 컨텍스트
        emit: 이벤트 emit 콜백

    Returns:
        업데이트된 컨텍스트
    """
    ctx.current_phase = AgentPhase.COMMIT

    # Stage 시작 이벤트
    await emit(
        PipelineEvent(
            event_type=PipelineEventType.STAGE_START,
            phase=AgentPhase.COMMIT,
        )
    )

    # 모의 처리 지연 (기존 동작 보존)
    await asyncio.sleep(COMMIT_DELAY_MS / 1000.0)

    # Stage 완료 이벤트
    await emit(
        PipelineEvent(
            event_type=PipelineEventType.STAGE_COMPLETE,
            phase=AgentPhase.COMMIT,
        )
    )

    return ctx
</file>

<file path="backend/src/unknown_world/orchestrator/stages/parse.py">
"""Unknown World - Parse Stage.

입력 파싱 단계입니다.
TurnInput은 이미 API 레이어에서 파싱되었으므로, phase 전이만 담당합니다.

설계 원칙:
    - RULE-008: 단계 이벤트 일관성 (stage start/complete)
    - 동작 보존: 기존 동작 유지

참조:
    - vibe/refactors/RU-005-Q4.md
"""

from __future__ import annotations

from unknown_world.models.turn import AgentPhase
from unknown_world.orchestrator.stages.types import (
    EmitFn,
    PipelineContext,
    PipelineEvent,
    PipelineEventType,
)


async def parse_stage(ctx: PipelineContext, *, emit: EmitFn) -> PipelineContext:
    """Parse 단계를 실행합니다.

    입력은 이미 TurnInput으로 파싱되었으므로, phase 전이만 담당합니다.
    TTFB를 위해 가장 먼저 stage 이벤트를 전송합니다.

    Args:
        ctx: 파이프라인 컨텍스트
        emit: 이벤트 emit 콜백

    Returns:
        업데이트된 컨텍스트
    """
    ctx.current_phase = AgentPhase.PARSE

    # Stage 시작 이벤트 (TTFB를 위해 즉시 전송)
    await emit(
        PipelineEvent(
            event_type=PipelineEventType.STAGE_START,
            phase=AgentPhase.PARSE,
        )
    )

    # Parse 단계는 이미 API 레이어에서 완료됨
    # (TurnInput 검증은 FastAPI/Pydantic에서 처리)

    # Stage 완료 이벤트
    await emit(
        PipelineEvent(
            event_type=PipelineEventType.STAGE_COMPLETE,
            phase=AgentPhase.PARSE,
        )
    )

    return ctx
</file>

<file path="backend/src/unknown_world/orchestrator/stages/plan.py">
"""Unknown World - Plan Stage.

계획 수립 단계입니다.
현재 MVP에서는 실제 처리 없이 pass-through로 동작합니다.
추후 Autopilot(U-024) 등에서 로직을 추가할 자리입니다.

설계 원칙:
    - RULE-008: 단계 이벤트 일관성
    - 동작 보존: 기존 시뮬레이션 지연 유지

참조:
    - vibe/refactors/RU-005-Q4.md
"""

from __future__ import annotations

import asyncio

from unknown_world.models.turn import AgentPhase
from unknown_world.orchestrator.stages.types import (
    EmitFn,
    PipelineContext,
    PipelineEvent,
    PipelineEventType,
)

# 모의 처리 지연 시간 (ms)
PLAN_DELAY_MS = 100


async def plan_stage(ctx: PipelineContext, *, emit: EmitFn) -> PipelineContext:
    """Plan 단계를 실행합니다.

    현재는 pass-through로 동작합니다.
    추후 Autopilot 등에서 계획 수립 로직을 추가합니다.

    Args:
        ctx: 파이프라인 컨텍스트
        emit: 이벤트 emit 콜백

    Returns:
        업데이트된 컨텍스트
    """
    ctx.current_phase = AgentPhase.PLAN

    # Stage 시작 이벤트
    await emit(
        PipelineEvent(
            event_type=PipelineEventType.STAGE_START,
            phase=AgentPhase.PLAN,
        )
    )

    # 모의 처리 지연 (기존 동작 보존)
    await asyncio.sleep(PLAN_DELAY_MS / 1000.0)

    # Stage 완료 이벤트
    await emit(
        PipelineEvent(
            event_type=PipelineEventType.STAGE_COMPLETE,
            phase=AgentPhase.PLAN,
        )
    )

    return ctx
</file>

<file path="backend/src/unknown_world/orchestrator/stages/render.py">
"""Unknown World - Render Stage.

렌더링 단계입니다.
현재 MVP에서는 실제 이미지 생성 없이 pass-through로 동작합니다.
추후 이미지 파이프라인(U-019~)에서 로직을 추가할 자리입니다.

설계 원칙:
    - RULE-008: 단계 이벤트 일관성
    - 동작 보존: 기존 시뮬레이션 지연 유지

참조:
    - vibe/refactors/RU-005-Q4.md
"""

from __future__ import annotations

import asyncio

from unknown_world.models.turn import AgentPhase
from unknown_world.orchestrator.stages.types import (
    EmitFn,
    PipelineContext,
    PipelineEvent,
    PipelineEventType,
)

# 모의 처리 지연 시간 (ms)
RENDER_DELAY_MS = 80


async def render_stage(ctx: PipelineContext, *, emit: EmitFn) -> PipelineContext:
    """Render 단계를 실행합니다.

    현재는 pass-through로 동작합니다.
    추후 이미지 생성/편집 파이프라인이 추가됩니다.

    Args:
        ctx: 파이프라인 컨텍스트
        emit: 이벤트 emit 콜백

    Returns:
        업데이트된 컨텍스트
    """
    ctx.current_phase = AgentPhase.RENDER

    # Stage 시작 이벤트
    await emit(
        PipelineEvent(
            event_type=PipelineEventType.STAGE_START,
            phase=AgentPhase.RENDER,
        )
    )

    # 모의 처리 지연 (기존 동작 보존)
    await asyncio.sleep(RENDER_DELAY_MS / 1000.0)

    # Stage 완료 이벤트
    await emit(
        PipelineEvent(
            event_type=PipelineEventType.STAGE_COMPLETE,
            phase=AgentPhase.RENDER,
        )
    )

    return ctx
</file>

<file path="backend/src/unknown_world/orchestrator/stages/resolve.py">
"""Unknown World - Resolve Stage.

해결 단계입니다.
현재 MVP에서는 실제 처리 없이 pass-through로 동작합니다.

설계 원칙:
    - RULE-008: 단계 이벤트 일관성
    - 동작 보존: 기존 시뮬레이션 지연 유지

참조:
    - vibe/refactors/RU-005-Q4.md
"""

from __future__ import annotations

import asyncio

from unknown_world.models.turn import AgentPhase
from unknown_world.orchestrator.stages.types import (
    EmitFn,
    PipelineContext,
    PipelineEvent,
    PipelineEventType,
)

# 모의 처리 지연 시간 (ms)
RESOLVE_DELAY_MS = 150


async def resolve_stage(ctx: PipelineContext, *, emit: EmitFn) -> PipelineContext:
    """Resolve 단계를 실행합니다.

    현재는 pass-through로 동작합니다.

    Args:
        ctx: 파이프라인 컨텍스트
        emit: 이벤트 emit 콜백

    Returns:
        업데이트된 컨텍스트
    """
    ctx.current_phase = AgentPhase.RESOLVE

    # Stage 시작 이벤트
    await emit(
        PipelineEvent(
            event_type=PipelineEventType.STAGE_START,
            phase=AgentPhase.RESOLVE,
        )
    )

    # 모의 처리 지연 (기존 동작 보존)
    await asyncio.sleep(RESOLVE_DELAY_MS / 1000.0)

    # Stage 완료 이벤트
    await emit(
        PipelineEvent(
            event_type=PipelineEventType.STAGE_COMPLETE,
            phase=AgentPhase.RESOLVE,
        )
    )

    return ctx
</file>

<file path="backend/src/unknown_world/orchestrator/stages/types.py">
"""Unknown World - Pipeline Stage 타입 정의.

Pipeline에서 사용하는 컨텍스트와 emit 콜백 인터페이스를 정의합니다.

설계 원칙:
    - Option A (RU-005 Q1 결정): 클래스 도입 없이 함수 체인 방식
    - 레이어링 보호: 오케스트레이터가 FastAPI에 직접 의존하지 않도록 emit 콜백 사용
    - RULE-007/008: 프롬프트/내부 추론 노출 금지, 단계/배지만 표시

참조:
    - vibe/refactors/RU-005-Q4.md
    - vibe/unit-results/U-018[Mvp].md
"""

from __future__ import annotations

from collections.abc import Awaitable, Callable
from dataclasses import dataclass, field
from enum import Enum
from typing import TYPE_CHECKING, Any, Protocol

from unknown_world.models.turn import (
    AgentPhase,
    CurrencyAmount,
    TurnInput,
    TurnOutput,
    ValidationBadge,
)

if TYPE_CHECKING:
    pass

# =============================================================================
# Emit 콜백 타입 (오케스트레이터 → API 레이어)
# =============================================================================


class PipelineEventType(str, Enum):
    """파이프라인 이벤트 타입.

    오케스트레이터가 API 레이어로 전달하는 도메인 이벤트 타입입니다.
    API 레이어는 이를 StageEvent/BadgesEvent/RepairEvent 등으로 변환합니다.
    """

    STAGE_START = "stage_start"
    STAGE_COMPLETE = "stage_complete"
    STAGE_FAIL = "stage_fail"
    BADGES = "badges"
    REPAIR = "repair"
    NARRATIVE_DELTA = "narrative_delta"


@dataclass
class PipelineEvent:
    """파이프라인 이벤트.

    오케스트레이터가 emit 콜백으로 전달하는 도메인 이벤트입니다.
    API 레이어에서 스트림 이벤트로 변환됩니다.

    Attributes:
        event_type: 이벤트 타입
        phase: 관련 단계 (stage 이벤트용)
        badges: 배지 목록 (badges 이벤트용)
        repair_attempt: 복구 시도 횟수 (repair 이벤트용)
        repair_message: 복구 메시지 (repair 이벤트용)
        text: 텍스트 (narrative_delta 이벤트용)
        extra: 추가 데이터
    """

    event_type: PipelineEventType
    phase: AgentPhase | None = None
    badges: list[ValidationBadge] | None = None
    repair_attempt: int = 0
    repair_message: str | None = None
    text: str | None = None
    extra: dict[str, Any] = field(default_factory=lambda: {})


# Emit 함수 타입: async callable로 도메인 이벤트를 전달
EmitFn = Callable[[PipelineEvent], Awaitable[None]]


# =============================================================================
# Pipeline Context
# =============================================================================


@dataclass
class PipelineContext:
    """파이프라인 컨텍스트.

    Stage 함수들이 공유하는 컨텍스트입니다.
    각 stage는 ctx를 받아 수정하고 반환합니다 (Option A: 함수 체인).

    Attributes:
        turn_input: 사용자 턴 입력
        economy_snapshot: 요청 시점 재화 스냅샷 (폴백 시 보존용)
        output: 생성된 TurnOutput (validate stage 이후)
        badges: 현재까지 수집된 배지 목록
        repair_messages: 복구 시도 시 발생한 메시지 목록
        repair_attempts: 복구 시도 횟수
        current_phase: 현재 단계
        is_fallback: 폴백으로 종료되었는지
        is_mock: Mock 모드인지
        seed: Mock 모드 시드 (재현성 보장)
    """

    turn_input: TurnInput
    economy_snapshot: CurrencyAmount
    output: TurnOutput | None = None
    badges: list[ValidationBadge] = field(default_factory=lambda: [])
    repair_messages: list[str] = field(default_factory=lambda: [])
    repair_attempts: int = 0
    current_phase: AgentPhase = AgentPhase.PARSE
    is_fallback: bool = False
    is_mock: bool = False
    seed: int | None = None


# =============================================================================
# Stage 함수 타입
# =============================================================================


class StageFn(Protocol):
    """Stage 함수 프로토콜.

    각 stage 함수는 이 프로토콜을 따릅니다.
    ctx를 받아 수정하고 반환하며, emit 콜백으로 이벤트를 전달합니다.
    """

    async def __call__(self, ctx: PipelineContext, *, emit: EmitFn) -> PipelineContext: ...
</file>

<file path="backend/src/unknown_world/orchestrator/stages/verify.py">
"""Unknown World - Verify Stage.

검증 단계입니다.
현재 MVP에서는 실제 처리 없이 pass-through로 동작합니다.

설계 원칙:
    - RULE-008: 단계 이벤트 일관성
    - 동작 보존: 기존 시뮬레이션 지연 유지

참조:
    - vibe/refactors/RU-005-Q4.md
"""

from __future__ import annotations

import asyncio

from unknown_world.models.turn import AgentPhase
from unknown_world.orchestrator.stages.types import (
    EmitFn,
    PipelineContext,
    PipelineEvent,
    PipelineEventType,
)

# 모의 처리 지연 시간 (ms)
VERIFY_DELAY_MS = 40


async def verify_stage(ctx: PipelineContext, *, emit: EmitFn) -> PipelineContext:
    """Verify 단계를 실행합니다.

    현재는 pass-through로 동작합니다.

    Args:
        ctx: 파이프라인 컨텍스트
        emit: 이벤트 emit 콜백

    Returns:
        업데이트된 컨텍스트
    """
    ctx.current_phase = AgentPhase.VERIFY

    # Stage 시작 이벤트
    await emit(
        PipelineEvent(
            event_type=PipelineEventType.STAGE_START,
            phase=AgentPhase.VERIFY,
        )
    )

    # 모의 처리 지연 (기존 동작 보존)
    await asyncio.sleep(VERIFY_DELAY_MS / 1000.0)

    # Stage 완료 이벤트
    await emit(
        PipelineEvent(
            event_type=PipelineEventType.STAGE_COMPLETE,
            phase=AgentPhase.VERIFY,
        )
    )

    return ctx
</file>

<file path="backend/src/unknown_world/services/rembg_preflight.py">
"""Unknown World - rembg 사전 점검 서비스 (preflight).

이 모듈은 서버 시작 시 rembg 설치 여부와 모델 캐시를 사전 점검하고,
필요한 경우 모델을 미리 다운로드하여 첫 rembg 호출에서 발생하는 지연을 방지합니다.

설계 원칙:
    - RULE-004: 실패해도 서비스 중단 없이 degraded 모드로 운영
    - Q1 결정: Option A (타임아웃 짧게 + 실패 시 degraded)
    - Q2 결정: Option A (birefnet-general만 기본 prefetch)

참조:
    - vibe/ref/rembg-guide.md (모델 선택/다운로드 가이드 SSOT)
    - vibe/unit-plans/U-045[Mvp].md
    - vibe/tech-stack.md (rembg 버전 고정)
"""

from __future__ import annotations

import asyncio
import logging
import os
import subprocess
from dataclasses import dataclass, field
from datetime import UTC, datetime
from enum import StrEnum
from pathlib import Path

from pydantic import BaseModel, ConfigDict, Field

# =============================================================================
# 로거 설정
# =============================================================================

logger = logging.getLogger(__name__)


# =============================================================================
# 상수 및 환경변수
# =============================================================================

# 기본 prefetch 모델 (Q2: Option A - birefnet-general만)
DEFAULT_PREFETCH_MODELS: list[str] = ["birefnet-general"]

# 환경변수로 확장 모델 목록 주입 가능
# 예: UW_REMBG_PREFETCH_MODELS=birefnet-general,birefnet-portrait
ENV_PREFETCH_MODELS = "UW_REMBG_PREFETCH_MODELS"

# preflight 타임아웃 (Q1: Option A - 짧은 타임아웃)
# 모델 다운로드는 100~200MB로 네트워크에 따라 시간이 걸릴 수 있음
DEFAULT_PREFLIGHT_TIMEOUT_SECONDS = 120  # 2분
ENV_PREFLIGHT_TIMEOUT = "UW_REMBG_PREFLIGHT_TIMEOUT"

# 개별 모델 다운로드 타임아웃
DEFAULT_MODEL_DOWNLOAD_TIMEOUT_SECONDS = 90  # 1.5분
ENV_MODEL_DOWNLOAD_TIMEOUT = "UW_REMBG_MODEL_DOWNLOAD_TIMEOUT"


# =============================================================================
# 상태 타입 정의
# =============================================================================


class RembgReadyStatus(StrEnum):
    """rembg 준비 상태."""

    READY = "ready"
    """rembg 설치됨, 필수 모델 사용 가능"""

    DEGRADED = "degraded"
    """rembg 설치됨, 일부 모델 누락/다운로드 실패"""

    UNAVAILABLE = "unavailable"
    """rembg 미설치 또는 사용 불가"""

    PENDING = "pending"
    """preflight 아직 실행되지 않음"""


@dataclass
class ModelStatus:
    """개별 모델 상태.

    Attributes:
        name: 모델 이름
        available: 사용 가능 여부
        download_attempted: 다운로드 시도 여부
        error: 에러 메시지 (있을 경우)
    """

    name: str
    available: bool = False
    download_attempted: bool = False
    error: str | None = None


class RembgPreflightResult(BaseModel):
    """rembg preflight 결과.

    Attributes:
        status: 전체 준비 상태
        installed: rembg 설치 여부
        version: rembg 버전 (설치된 경우)
        preloaded_models: 사용 가능한 모델 목록
        missing_models: 누락된 모델 목록
        last_error: 마지막 에러 메시지
        preflight_time_ms: preflight 소요 시간 (밀리초)
        timestamp: preflight 실행 시각
    """

    model_config = ConfigDict(extra="forbid")

    status: RembgReadyStatus = Field(default=RembgReadyStatus.PENDING)
    installed: bool = Field(default=False)
    version: str | None = Field(default=None)
    preloaded_models: list[str] = Field(default_factory=list)
    missing_models: list[str] = Field(default_factory=list)
    last_error: str | None = Field(default=None)
    preflight_time_ms: int = Field(default=0)
    timestamp: str | None = Field(default=None)


@dataclass
class PreflightConfig:
    """preflight 설정.

    Attributes:
        models_to_prefetch: prefetch할 모델 목록
        preflight_timeout_seconds: 전체 preflight 타임아웃
        model_download_timeout_seconds: 개별 모델 다운로드 타임아웃
    """

    models_to_prefetch: list[str] = field(default_factory=lambda: DEFAULT_PREFETCH_MODELS.copy())
    preflight_timeout_seconds: int = DEFAULT_PREFLIGHT_TIMEOUT_SECONDS
    model_download_timeout_seconds: int = DEFAULT_MODEL_DOWNLOAD_TIMEOUT_SECONDS

    @classmethod
    def from_env(cls) -> PreflightConfig:
        """환경변수에서 설정을 로드합니다."""
        # 모델 목록
        models_env = os.environ.get(ENV_PREFETCH_MODELS)
        if models_env:
            models = [m.strip() for m in models_env.split(",") if m.strip()]
        else:
            models = DEFAULT_PREFETCH_MODELS.copy()

        # 타임아웃
        try:
            preflight_timeout = int(
                os.environ.get(ENV_PREFLIGHT_TIMEOUT, DEFAULT_PREFLIGHT_TIMEOUT_SECONDS)
            )
        except ValueError:
            preflight_timeout = DEFAULT_PREFLIGHT_TIMEOUT_SECONDS

        try:
            download_timeout = int(
                os.environ.get(ENV_MODEL_DOWNLOAD_TIMEOUT, DEFAULT_MODEL_DOWNLOAD_TIMEOUT_SECONDS)
            )
        except ValueError:
            download_timeout = DEFAULT_MODEL_DOWNLOAD_TIMEOUT_SECONDS

        return cls(
            models_to_prefetch=models,
            preflight_timeout_seconds=preflight_timeout,
            model_download_timeout_seconds=download_timeout,
        )


# =============================================================================
# Preflight 서비스 클래스
# =============================================================================


class RembgPreflight:
    """rembg 사전 점검 서비스.

    서버 시작 시 rembg 설치 여부와 모델 캐시를 점검하고,
    필요한 경우 모델을 미리 다운로드합니다.
    """

    def __init__(self, config: PreflightConfig | None = None) -> None:
        """RembgPreflight를 초기화합니다.

        Args:
            config: preflight 설정 (None이면 환경변수에서 로드)
        """
        self._config = config or PreflightConfig.from_env()
        self._result: RembgPreflightResult = RembgPreflightResult()
        self._model_statuses: dict[str, ModelStatus] = {}
        self._executed = False

    @property
    def result(self) -> RembgPreflightResult:
        """현재 preflight 결과를 반환합니다."""
        return self._result

    def set_result(self, result: RembgPreflightResult) -> None:
        """preflight 결과를 설정합니다 (테스트용)."""
        self._result = result

    @property
    def is_ready(self) -> bool:
        """rembg가 사용 준비되었는지 확인합니다."""
        return self._result.status == RembgReadyStatus.READY

    @property
    def is_available(self) -> bool:
        """rembg가 사용 가능한지 확인합니다 (degraded 포함)."""
        return self._result.status in (RembgReadyStatus.READY, RembgReadyStatus.DEGRADED)

    def _check_rembg_installed(self) -> tuple[bool, str | None]:
        """rembg 설치 여부를 확인합니다.

        Returns:
            (설치 여부, 버전 또는 None)
        """
        try:
            result = subprocess.run(
                ["rembg", "--version"],
                capture_output=True,
                text=True,
                timeout=10,
            )
            if result.returncode == 0:
                version = result.stdout.strip()
                logger.info("[Preflight] rembg 설치 확인", extra={"version": version})
                return True, version
            else:
                logger.warning(
                    "[Preflight] rembg 버전 확인 실패", extra={"returncode": result.returncode}
                )
                return False, None
        except FileNotFoundError:
            logger.warning("[Preflight] rembg가 설치되어 있지 않습니다")
            return False, None
        except subprocess.TimeoutExpired:
            logger.warning("[Preflight] rembg 버전 확인 타임아웃")
            return False, None
        except Exception as e:
            logger.warning("[Preflight] rembg 확인 중 오류", extra={"error": str(e)[:100]})
            return False, None

    def _check_model_available(self, model: str) -> bool:
        """특정 모델이 캐시에 있는지 확인합니다.

        rembg는 모델을 처음 사용할 때 자동으로 다운로드합니다.
        모델 캐시 위치: ~/.u2net/ (기본)

        Args:
            model: 확인할 모델 이름

        Returns:
            모델 사용 가능 여부
        """
        # rembg 모델 캐시 디렉토리 확인
        # 기본 경로: ~/.u2net/{model}.onnx
        home = Path.home()
        u2net_dir = home / ".u2net"

        # 모델 파일 패턴 (모델마다 파일명이 다를 수 있음)
        # birefnet-general → birefnet-general.onnx
        model_file = u2net_dir / f"{model}.onnx"

        if model_file.exists():
            logger.debug(
                "[Preflight] 모델 캐시 발견", extra={"model": model, "path": str(model_file)}
            )
            return True

        logger.debug("[Preflight] 모델 캐시 없음", extra={"model": model})
        return False

    def _download_model(self, model: str) -> bool:
        """모델을 다운로드합니다.

        Args:
            model: 다운로드할 모델 이름

        Returns:
            다운로드 성공 여부
        """
        timeout = self._config.model_download_timeout_seconds

        logger.info("[Preflight] 모델 다운로드 시작", extra={"model": model, "timeout": timeout})

        try:
            # rembg d <model> 명령으로 다운로드
            result = subprocess.run(
                ["rembg", "d", model],
                capture_output=True,
                text=True,
                timeout=timeout,
            )

            if result.returncode == 0:
                logger.info("[Preflight] 모델 다운로드 완료", extra={"model": model})
                return True
            else:
                stderr_preview = result.stderr[:200] if result.stderr else "N/A"
                logger.warning(
                    "[Preflight] 모델 다운로드 실패",
                    extra={
                        "model": model,
                        "returncode": result.returncode,
                        "stderr": stderr_preview,
                    },
                )
                return False

        except subprocess.TimeoutExpired:
            logger.warning(
                "[Preflight] 모델 다운로드 타임아웃", extra={"model": model, "timeout": timeout}
            )
            return False
        except Exception as e:
            logger.warning(
                "[Preflight] 모델 다운로드 중 오류", extra={"model": model, "error": str(e)[:100]}
            )
            return False

    def _process_model(self, model: str) -> ModelStatus:
        """모델 상태를 확인하고 필요시 다운로드합니다.

        Args:
            model: 처리할 모델 이름

        Returns:
            ModelStatus 객체
        """
        status = ModelStatus(name=model)

        # 1. 캐시 확인
        if self._check_model_available(model):
            status.available = True
            return status

        # 2. 캐시 없으면 다운로드 시도
        status.download_attempted = True
        if self._download_model(model):
            # 다운로드 후 재확인
            if self._check_model_available(model):
                status.available = True
            else:
                status.error = "다운로드 완료했으나 모델 파일을 찾을 수 없음"
        else:
            status.error = "다운로드 실패"

        return status

    async def run_async(self) -> RembgPreflightResult:
        """비동기로 preflight를 실행합니다.

        Returns:
            RembgPreflightResult 객체
        """
        # 동기 작업을 별도 스레드에서 실행
        loop = asyncio.get_event_loop()
        return await loop.run_in_executor(None, self.run)

    def run(self) -> RembgPreflightResult:
        """preflight를 실행합니다.

        Returns:
            RembgPreflightResult 객체
        """
        start_time = datetime.now(UTC)
        self._executed = True

        logger.info(
            "[Preflight] rembg preflight 시작",
            extra={
                "models": self._config.models_to_prefetch,
                "timeout": self._config.preflight_timeout_seconds,
            },
        )

        # 1. rembg 설치 확인
        installed, version = self._check_rembg_installed()
        self._result.installed = installed
        self._result.version = version

        if not installed:
            self._result.status = RembgReadyStatus.UNAVAILABLE
            self._result.last_error = "rembg가 설치되어 있지 않습니다"
            self._result.timestamp = datetime.now(UTC).isoformat()
            self._result.preflight_time_ms = int(
                (datetime.now(UTC) - start_time).total_seconds() * 1000
            )

            logger.warning("[Preflight] rembg 미설치, UNAVAILABLE 상태로 완료")
            return self._result

        # 2. 각 모델 점검 및 다운로드
        preloaded: list[str] = []
        missing: list[str] = []

        for model in self._config.models_to_prefetch:
            # 전체 타임아웃 체크
            elapsed = (datetime.now(UTC) - start_time).total_seconds()
            if elapsed > self._config.preflight_timeout_seconds:
                logger.warning("[Preflight] 전체 타임아웃 도달, 남은 모델 스킵")
                # 남은 모델은 missing으로 처리
                remaining_models = self._config.models_to_prefetch[
                    self._config.models_to_prefetch.index(model) :
                ]
                for remaining in remaining_models:
                    if remaining not in [s.name for s in self._model_statuses.values()]:
                        status = ModelStatus(name=remaining, error="preflight 타임아웃으로 스킵됨")
                        self._model_statuses[remaining] = status
                        missing.append(remaining)
                break

            status = self._process_model(model)
            self._model_statuses[model] = status

            if status.available:
                preloaded.append(model)
            else:
                missing.append(model)

        # 3. 결과 정리
        self._result.preloaded_models = preloaded
        self._result.missing_models = missing
        self._result.preflight_time_ms = int(
            (datetime.now(UTC) - start_time).total_seconds() * 1000
        )
        self._result.timestamp = datetime.now(UTC).isoformat()

        # 상태 결정
        if not missing:
            self._result.status = RembgReadyStatus.READY
            logger.info(
                "[Preflight] rembg READY",
                extra={"preloaded": preloaded, "elapsed_ms": self._result.preflight_time_ms},
            )
        elif preloaded:
            self._result.status = RembgReadyStatus.DEGRADED
            self._result.last_error = f"일부 모델 누락: {', '.join(missing)}"
            logger.warning(
                "[Preflight] rembg DEGRADED",
                extra={
                    "preloaded": preloaded,
                    "missing": missing,
                    "elapsed_ms": self._result.preflight_time_ms,
                },
            )
        else:
            self._result.status = RembgReadyStatus.DEGRADED
            self._result.last_error = f"모든 prefetch 모델 누락: {', '.join(missing)}"
            logger.warning(
                "[Preflight] rembg DEGRADED (모든 모델 누락)",
                extra={"missing": missing, "elapsed_ms": self._result.preflight_time_ms},
            )

        return self._result


# =============================================================================
# 전역 인스턴스 및 접근자
# =============================================================================

_preflight_instance: RembgPreflight | None = None
_preflight_result: RembgPreflightResult = RembgPreflightResult()


def get_rembg_preflight() -> RembgPreflight:
    """RembgPreflight 싱글톤 인스턴스를 반환합니다."""
    global _preflight_instance
    if _preflight_instance is None:
        _preflight_instance = RembgPreflight()
    return _preflight_instance


def get_rembg_status() -> RembgPreflightResult:
    """현재 rembg preflight 결과를 반환합니다."""
    global _preflight_result
    if _preflight_instance is not None:
        return _preflight_instance.result
    return _preflight_result


def set_rembg_status(result: RembgPreflightResult) -> None:
    """rembg preflight 결과를 설정합니다 (테스트용)."""
    global _preflight_result, _preflight_instance
    _preflight_result = result
    # 인스턴스가 있으면 공개 메서드로 결과 업데이트
    if _preflight_instance is not None:
        _preflight_instance.set_result(result)


def is_rembg_ready() -> bool:
    """rembg가 준비되었는지 확인합니다 (바로 사용 가능)."""
    status = get_rembg_status()
    return status.status == RembgReadyStatus.READY


def is_rembg_available() -> bool:
    """rembg가 사용 가능한지 확인합니다 (degraded 포함)."""
    status = get_rembg_status()
    return status.status in (RembgReadyStatus.READY, RembgReadyStatus.DEGRADED)


def reset_rembg_preflight() -> None:
    """테스트용 싱글톤 리셋."""
    global _preflight_instance, _preflight_result
    _preflight_instance = None
    _preflight_result = RembgPreflightResult()


async def run_preflight_async(config: PreflightConfig | None = None) -> RembgPreflightResult:
    """비동기로 preflight를 실행하고 전역 상태를 업데이트합니다.

    Args:
        config: preflight 설정 (None이면 환경변수에서 로드)

    Returns:
        RembgPreflightResult 객체
    """
    global _preflight_instance, _preflight_result

    _preflight_instance = RembgPreflight(config)
    result = await _preflight_instance.run_async()
    _preflight_result = result

    return result
</file>

<file path="backend/src/unknown_world/validation/language_gate.py">
"""Unknown World - 언어 혼합 검증 게이트 (RULE-006).

ko/en 혼합 출력을 감지하고 차단하는 Hard Gate입니다.
TurnInput.language를 SSOT로 삼아 TurnOutput의 사용자 노출 텍스트가
동일 언어로 수렴하는지 검증합니다.

설계 원칙:
    - RULE-006: ko/en 언어 정책 준수 (혼합 출력 금지)
    - RULE-004: 검증 실패 시 Repair loop로 복구
    - CP-MVP-05: 언어 혼합 금지 검증

페어링 결정:
    - Q1: Option A (보수적 - 오탐 최소, CP에서 튜닝)
    - Q2: Option A (고유명 최소치만 허용)

참조:
    - vibe/unit-plans/U-043[Mvp].md
    - vibe/ref/en-ko-issue.png (혼합 출력 사례)
    - .cursor/rules/00-core-critical.mdc
"""

from __future__ import annotations

import logging
import re
import unicodedata
from dataclasses import dataclass, field
from typing import TYPE_CHECKING

from unknown_world.models.turn import Language

if TYPE_CHECKING:
    from unknown_world.models.turn import TurnOutput

# =============================================================================
# 로거 설정
# =============================================================================

logger = logging.getLogger(__name__)

# =============================================================================
# 상수 및 설정
# =============================================================================

# 페어링 결정 Q1: Option A (보수적 - 오탐 최소)
# 혼합 판정 임계값 (이 비율 이상이면 "잘못된 언어"로 판정)
MIXED_THRESHOLD_RATIO = 0.15  # 15% 이상의 반대 언어 문자 → 혼합으로 판정

# 페어링 결정 Q2: Option A (고유명 최소치만 허용)
# 허용 화이트리스트 (영어 고유명 - 재화/모델 라벨 등)
# 주의: 복합어는 개별 단어도 함께 등록해야 합니다 (한글 붙은 경우 단어 경계 매칭 문제)
ALLOWED_ENGLISH_TERMS: set[str] = {
    # 재화 이름 (RULE-005)
    "signal",
    "shard",
    "memory",
    "memory shard",
    # 모델 라벨 (RULE-008)
    "fast",
    "quality",
    "cheap",
    "ref",
    # 시스템 상수
    "ok",
    "fail",
    "blocked",
    # 기타 허용 약어
    "ui",
    "api",
    "id",
    "json",
    "schema",
}

# 한글 유니코드 범위
HANGUL_JAMO_START = 0x1100
HANGUL_JAMO_END = 0x11FF
HANGUL_SYLLABLES_START = 0xAC00
HANGUL_SYLLABLES_END = 0xD7AF
HANGUL_COMPAT_JAMO_START = 0x3130
HANGUL_COMPAT_JAMO_END = 0x318F


# =============================================================================
# 언어 감지 휴리스틱
# =============================================================================


def _is_hangul(char: str) -> bool:
    """한글 문자인지 확인합니다."""
    code = ord(char)
    return (
        (HANGUL_SYLLABLES_START <= code <= HANGUL_SYLLABLES_END)
        or (HANGUL_JAMO_START <= code <= HANGUL_JAMO_END)
        or (HANGUL_COMPAT_JAMO_START <= code <= HANGUL_COMPAT_JAMO_END)
    )


def _is_latin(char: str) -> bool:
    """라틴 알파벳인지 확인합니다 (a-z, A-Z)."""
    return char.isalpha() and unicodedata.category(char).startswith("L") and not _is_hangul(char)


def _normalize_text_for_check(text: str) -> str:
    """검사용으로 텍스트를 정규화합니다.

    - 소문자 변환
    - 화이트리스트 단어 제거
    - 숫자/기호/공백/이모지 제거
    """
    normalized = text.lower()

    # 화이트리스트 단어 제거 (대소문자 무시)
    # 복합어를 먼저 처리 (긴 것부터)
    sorted_terms = sorted(ALLOWED_ENGLISH_TERMS, key=len, reverse=True)
    for term in sorted_terms:
        # 한글이 붙어있는 경우도 처리하기 위해 단어 경계 대신
        # 알파벳이 아닌 문자 또는 문자열 경계로 매칭
        # 예: "Signal가", "Memory Shard를" 등
        pattern = rf"(?<![a-zA-Z]){re.escape(term)}(?![a-zA-Z])"
        normalized = re.sub(pattern, "", normalized, flags=re.IGNORECASE)

    return normalized


@dataclass
class LanguageRatio:
    """언어 비율 측정 결과.

    Attributes:
        hangul_count: 한글 문자 수
        latin_count: 라틴 문자 수
        total_alpha: 총 알파벳 문자 수 (한글 + 라틴)
        hangul_ratio: 한글 비율 (0.0 ~ 1.0)
        latin_ratio: 라틴 비율 (0.0 ~ 1.0)
    """

    hangul_count: int = 0
    latin_count: int = 0
    total_alpha: int = 0
    hangul_ratio: float = 0.0
    latin_ratio: float = 0.0


def measure_language_ratio(text: str) -> LanguageRatio:
    """텍스트의 한글/라틴 비율을 측정합니다.

    화이트리스트 단어는 제거한 후 측정합니다.

    Args:
        text: 측정할 텍스트

    Returns:
        LanguageRatio: 언어 비율 측정 결과
    """
    if not text:
        return LanguageRatio()

    # 정규화 (화이트리스트 제거)
    normalized = _normalize_text_for_check(text)

    hangul_count = 0
    latin_count = 0

    for char in normalized:
        if _is_hangul(char):
            hangul_count += 1
        elif _is_latin(char):
            latin_count += 1

    total = hangul_count + latin_count

    if total == 0:
        return LanguageRatio()

    return LanguageRatio(
        hangul_count=hangul_count,
        latin_count=latin_count,
        total_alpha=total,
        hangul_ratio=hangul_count / total,
        latin_ratio=latin_count / total,
    )


def is_language_mixed(text: str, expected_language: Language) -> bool:
    """텍스트가 예상 언어와 다른 언어가 혼합되었는지 확인합니다.

    Args:
        text: 검사할 텍스트
        expected_language: 예상 언어 (TurnInput.language)

    Returns:
        bool: 혼합되었으면 True
    """
    if not text or len(text.strip()) == 0:
        return False

    ratio = measure_language_ratio(text)

    # 알파벳이 거의 없는 경우 (숫자/기호만) → 혼합 아님
    if ratio.total_alpha < 3:
        return False

    # 예상 언어에 따라 반대 언어 비율 체크
    if expected_language == Language.KO:
        # 한국어 예상인데 라틴 비율이 임계값 이상이면 혼합
        return ratio.latin_ratio >= MIXED_THRESHOLD_RATIO
    else:
        # 영어 예상인데 한글 비율이 임계값 이상이면 혼합
        return ratio.hangul_ratio >= MIXED_THRESHOLD_RATIO


# =============================================================================
# TurnOutput 텍스트 추출
# =============================================================================


@dataclass
class ExtractedText:
    """추출된 사용자 노출 텍스트.

    Attributes:
        field_path: 필드 경로 (예: "narrative", "ui.action_deck.cards[0].label")
        text: 텍스트 내용
    """

    field_path: str
    text: str


def extract_user_facing_texts(turn_output: TurnOutput) -> list[ExtractedText]:
    """TurnOutput에서 사용자 노출 텍스트를 추출합니다.

    검사 범위 (우선순위):
        - narrative
        - ui.action_deck.cards[].label, description, hint, reward_hint, disabled_reason
        - ui.objects[].label, interaction_hint
        - world.quests_updated[].label
        - world.rules_changed[].label, description
        - world.memory_pins[].content

    Args:
        turn_output: 검사할 TurnOutput

    Returns:
        list[ExtractedText]: 추출된 텍스트 목록
    """
    texts: list[ExtractedText] = []

    # 1. narrative (가장 중요)
    if turn_output.narrative:
        texts.append(ExtractedText(field_path="narrative", text=turn_output.narrative))

    # 2. ui.action_deck.cards[]
    for i, card in enumerate(turn_output.ui.action_deck.cards):
        texts.append(ExtractedText(field_path=f"ui.action_deck.cards[{i}].label", text=card.label))
        if card.description:
            texts.append(
                ExtractedText(
                    field_path=f"ui.action_deck.cards[{i}].description",
                    text=card.description,
                )
            )
        if card.hint:
            texts.append(
                ExtractedText(field_path=f"ui.action_deck.cards[{i}].hint", text=card.hint)
            )
        if card.reward_hint:
            texts.append(
                ExtractedText(
                    field_path=f"ui.action_deck.cards[{i}].reward_hint",
                    text=card.reward_hint,
                )
            )
        if card.disabled_reason:
            texts.append(
                ExtractedText(
                    field_path=f"ui.action_deck.cards[{i}].disabled_reason",
                    text=card.disabled_reason,
                )
            )

    # 3. ui.objects[]
    for i, obj in enumerate(turn_output.ui.objects):
        texts.append(ExtractedText(field_path=f"ui.objects[{i}].label", text=obj.label))
        if obj.interaction_hint:
            texts.append(
                ExtractedText(
                    field_path=f"ui.objects[{i}].interaction_hint",
                    text=obj.interaction_hint,
                )
            )

    # 4. world.quests_updated[]
    for i, quest in enumerate(turn_output.world.quests_updated):
        texts.append(ExtractedText(field_path=f"world.quests_updated[{i}].label", text=quest.label))

    # 5. world.rules_changed[]
    for i, rule in enumerate(turn_output.world.rules_changed):
        texts.append(ExtractedText(field_path=f"world.rules_changed[{i}].label", text=rule.label))
        if rule.description:
            texts.append(
                ExtractedText(
                    field_path=f"world.rules_changed[{i}].description",
                    text=rule.description,
                )
            )

    # 6. world.memory_pins[]
    for i, pin in enumerate(turn_output.world.memory_pins):
        texts.append(ExtractedText(field_path=f"world.memory_pins[{i}].content", text=pin.content))

    # 7. safety.message
    if turn_output.safety.message:
        texts.append(ExtractedText(field_path="safety.message", text=turn_output.safety.message))

    return texts


# =============================================================================
# 언어 혼합 검증 결과
# =============================================================================


@dataclass
class LanguageGateResult:
    """언어 혼합 검증 결과.

    Attributes:
        is_valid: 검증 통과 여부 (혼합 없음)
        violations: 위반 사항 목록 (필드 경로 + 샘플 토큰)
        expected_language: 예상 언어
    """

    is_valid: bool = True
    violations: list[dict[str, str]] = field(default_factory=lambda: [])
    expected_language: Language = Language.KO

    def add_violation(self, field_path: str, sample_text: str) -> None:
        """위반 사항을 추가합니다."""
        self.is_valid = False
        # 로그에 전체 텍스트 노출 방지 - 앞 50자만 샘플링
        truncated = sample_text[:50] + "..." if len(sample_text) > 50 else sample_text
        self.violations.append({"field": field_path, "sample": truncated})


def validate_language_consistency(
    turn_output: TurnOutput,
    expected_language: Language,
) -> LanguageGateResult:
    """TurnOutput의 언어 일관성을 검증합니다.

    사용자 노출 텍스트가 expected_language와 일치하는지 확인합니다.
    혼합 발견 시 위반 목록을 반환합니다.

    Args:
        turn_output: 검사할 TurnOutput
        expected_language: 예상 언어 (TurnInput.language)

    Returns:
        LanguageGateResult: 검증 결과

    Example:
        >>> result = validate_language_consistency(turn_output, Language.KO)
        >>> if not result.is_valid:
        ...     print(f"혼합 발견: {len(result.violations)}건")
    """
    result = LanguageGateResult(expected_language=expected_language)

    # 사용자 노출 텍스트 추출
    texts = extract_user_facing_texts(turn_output)

    # 각 텍스트 검사
    for extracted in texts:
        if is_language_mixed(extracted.text, expected_language):
            result.add_violation(extracted.field_path, extracted.text)

    if not result.is_valid:
        logger.warning(
            "[LanguageGate] 언어 혼합 감지",
            extra={
                "expected_language": expected_language.value,
                "violation_count": len(result.violations),
            },
        )

    return result


# =============================================================================
# i18n 에러 메시지 (RULE-006)
# =============================================================================

LANGUAGE_GATE_MESSAGES: dict[Language, dict[str, str]] = {
    Language.KO: {
        "summary_header": "언어 혼합이 감지되었습니다 (RULE-006 위반):",
        "violation_item": "- 필드 '{field}': 한국어로 작성해야 합니다",
        "instruction": "모든 사용자 노출 텍스트를 한국어(ko-KR)로 다시 작성하세요.",
    },
    Language.EN: {
        "summary_header": "Language mixing detected (RULE-006 violation):",
        "violation_item": "- Field '{field}': Must be written in English",
        "instruction": "Rewrite all user-facing text in English (en-US).",
    },
}


def build_language_error_summary(result: LanguageGateResult) -> str:
    """언어 혼합 검증 실패에 대한 에러 요약을 생성합니다.

    Repair 프롬프트에 포함할 요약입니다.
    전체 텍스트는 노출하지 않고 필드 경로만 표시합니다.

    Args:
        result: 언어 검증 결과

    Returns:
        str: 에러 요약 문자열
    """
    if result.is_valid:
        return ""

    messages = LANGUAGE_GATE_MESSAGES[result.expected_language]
    lines = [messages["summary_header"]]

    # 최대 5개까지만 표시 (너무 많으면 프롬프트 비대)
    for violation in result.violations[:5]:
        lines.append(messages["violation_item"].format(field=violation["field"]))

    if len(result.violations) > 5:
        remaining = len(result.violations) - 5
        if result.expected_language == Language.KO:
            lines.append(f"- (외 {remaining}건 추가 위반)")
        else:
            lines.append(f"- (and {remaining} more violations)")

    lines.append("")
    lines.append(messages["instruction"])

    return "\n".join(lines)
</file>

<file path="backend/tests/integration/test_api.py">
from fastapi.testclient import TestClient

from unknown_world.main import app

client = TestClient(app)


def test_health_check():
    """/health 엔드포인트가 올바른 스키마와 상태를 반환하는지 테스트합니다."""
    response = client.get("/health")
    assert response.status_code == 200
    data = response.json()
    assert data["status"] == "ok"
    assert "version" in data
    assert data["service"] == "unknown-world-backend"


def test_root_endpoint():
    """루트 엔드포인트가 정상 작동하는지 테스트합니다."""
    response = client.get("/")
    assert response.status_code == 200
    assert "message" in response.json()


def test_cors_policy():
    """RULE-011에 따른 CORS 정책이 올바르게 설정되었는지 테스트합니다."""
    # 허용된 오리진 테스트 (포트 8001)
    headers = {
        "Origin": "http://localhost:8001",
        "Access-Control-Request-Method": "GET",
    }
    response = client.options("/health", headers=headers)
    assert response.status_code == 200
    assert response.headers.get("access-control-allow-origin") == "http://localhost:8001"

    # 허용되지 않은 오리진 테스트 (포트 9000)
    headers = {
        "Origin": "http://localhost:9000",
        "Access-Control-Request-Method": "GET",
    }
    response = client.options("/health", headers=headers)
    # FastAPI/Starlette CORS 미들웨어는 허용되지 않은 경우 origin 헤더를 반환하지 않음
    assert "access-control-allow-origin" not in response.headers
</file>

<file path="backend/tests/manual_test_image.py">
"""Unknown World - 이미지 생성 API 수동 검증 스크립트."""

import json
import os

from fastapi.testclient import TestClient

from unknown_world.main import app


def run_manual_test():
    # UW_MODE를 mock으로 강제 설정하여 API 호출 없이 로직 검증
    os.environ["UW_MODE"] = "mock"
    client = TestClient(app)

    print("=== [1] 이미지 생성 요청 테스트 ===")
    payload = {
        "prompt": "A retro-future computer terminal with green text",
        "aspect_ratio": "1:1",
        "image_size": "1024x1024",
    }

    response = client.post("/api/image/generate", json=payload)
    print(f"Status Code: {response.status_code}")
    print(f"Response: {json.dumps(response.json(), indent=2, ensure_ascii=False)}")

    if response.status_code == 200:
        data = response.json()
        image_url = data["image_url"]
        image_id = data["image_id"]

        print(f"\n=== [2] 정적 파일 서빙 테스트 ({image_url}) ===")
        static_resp = client.get(image_url)
        print(f"Static Content-Type: {static_resp.headers.get('content-type')}")
        print(f"Static Success: {static_resp.status_code == 200}")

        print(f"\n=== [3] 이미지 상태 조회 테스트 ({image_id}) ===")
        status_resp = client.get(f"/api/image/status/{image_id}")
        print(f"Status Response: {json.dumps(status_resp.json(), indent=2, ensure_ascii=False)}")

        print(f"\n=== [4] 이미지 파일 직접 조회 테스트 (/api/image/file/{image_id}) ===")
        file_resp = client.get(f"/api/image/file/{image_id}")
        print(f"File Content-Type: {file_resp.headers.get('content-type')}")
        print(f"File Success: {file_resp.status_code == 200}")


if __name__ == "__main__":
    run_manual_test()
</file>

<file path="backend/tests/manual_test_rembg.py">
#!/usr/bin/env python3
"""U-035 rembg 배경 제거 통합 수동 테스트 스크립트.

이 스크립트는 image_postprocess 모듈의 기능을 테스트합니다.
실행: cd backend && python tests/manual_test_rembg.py
"""

from __future__ import annotations

import sys
from pathlib import Path

# 프로젝트 루트를 Python 경로에 추가
project_root = Path(__file__).parent.parent / "src"
sys.path.insert(0, str(project_root))


def test_model_selection():
    """이미지 유형 힌트에 따른 모델 선택 테스트."""
    from unknown_world.services.image_postprocess import (
        RembgModel,
        select_model_from_hint,
    )

    print("=" * 60)
    print("테스트 1: 모델 선택 로직")
    print("=" * 60)

    test_cases = [
        (None, RembgModel.BIREFNET_GENERAL, False),
        ("object", RembgModel.BIREFNET_GENERAL, False),
        ("icon", RembgModel.BIREFNET_GENERAL, False),
        ("character", RembgModel.ISNET_ANIME, False),
        ("anime", RembgModel.ISNET_ANIME, False),
        ("portrait", RembgModel.BIREFNET_PORTRAIT, True),
        ("human", RembgModel.U2NET_HUMAN_SEG, True),
        ("unknown_type", RembgModel.BIREFNET_GENERAL, False),
    ]

    all_passed = True
    for hint, expected_model, expected_alpha in test_cases:
        model, alpha = select_model_from_hint(hint)
        passed = model == expected_model and alpha == expected_alpha
        status = "[OK]" if passed else "[NG]"
        if not passed:
            all_passed = False
        print(f"  {status} hint='{hint}' -> model={model.value}, alpha={alpha}")
        print(f"      (expected: {expected_model.value}, {expected_alpha})")

    return all_passed


def test_postprocessor_availability():
    """ImagePostprocessor 사용 가능 여부 테스트."""
    from unknown_world.services.image_postprocess import get_image_postprocessor

    print()
    print("=" * 60)
    print("테스트 2: rembg 사용 가능 여부")
    print("=" * 60)

    postprocessor = get_image_postprocessor()
    available = postprocessor.is_available()
    status = "[OK]" if available else "[WARN]"
    print(f"  {status} rembg available: {available}")

    if not available:
        print("  [WARN] rembg is not installed. Install: pip install rembg")
        return False

    return True


def test_image_generation_request():
    """ImageGenerationRequest에 새 필드가 추가되었는지 확인."""
    from unknown_world.services.image_generation import ImageGenerationRequest

    print()
    print("=" * 60)
    print("테스트 3: ImageGenerationRequest 스키마 확장")
    print("=" * 60)

    # 새 필드로 인스턴스 생성 테스트
    request = ImageGenerationRequest(
        prompt="A magical sword with glowing runes",
        remove_background=True,
        image_type_hint="object",
    )

    checks = [
        ("remove_background 필드", hasattr(request, "remove_background")),
        ("image_type_hint 필드", hasattr(request, "image_type_hint")),
        ("remove_background=True", request.remove_background is True),
        ("image_type_hint='object'", request.image_type_hint == "object"),
    ]

    all_passed = True
    for desc, passed in checks:
        status = "[OK]" if passed else "[NG]"
        if not passed:
            all_passed = False
        print(f"  {status} {desc}")

    return all_passed


def test_image_job_schema():
    """ImageJob 스키마에 새 필드가 추가되었는지 확인."""
    from unknown_world.models.turn import ImageJob

    print()
    print("=" * 60)
    print("테스트 4: ImageJob 스키마 확장 (TurnOutput.render.image_job)")
    print("=" * 60)

    # 새 필드로 인스턴스 생성 테스트
    image_job = ImageJob(
        should_generate=True,
        prompt="A glowing crystal",
        remove_background=True,
        image_type_hint="object",
    )

    checks = [
        ("remove_background 필드", hasattr(image_job, "remove_background")),
        ("image_type_hint 필드", hasattr(image_job, "image_type_hint")),
        ("remove_background=True", image_job.remove_background is True),
        ("image_type_hint='object'", image_job.image_type_hint == "object"),
    ]

    all_passed = True
    for desc, passed in checks:
        status = "[OK]" if passed else "[NG]"
        if not passed:
            all_passed = False
        print(f"  {status} {desc}")

    return all_passed


def main():
    """모든 테스트 실행."""
    print()
    print("[TEST] U-035 rembg Background Removal Integration Test")
    print("=" * 60)

    results = []

    try:
        results.append(("Model Selection Logic", test_model_selection()))
    except Exception as e:
        print(f"  [NG] Model selection test error: {e}")
        results.append(("Model Selection Logic", False))

    try:
        results.append(("rembg Availability", test_postprocessor_availability()))
    except Exception as e:
        print(f"  [NG] rembg availability test error: {e}")
        results.append(("rembg Availability", False))

    try:
        results.append(("ImageGenerationRequest Schema", test_image_generation_request()))
    except Exception as e:
        print(f"  [NG] ImageGenerationRequest test error: {e}")
        results.append(("ImageGenerationRequest Schema", False))

    try:
        results.append(("ImageJob Schema", test_image_job_schema()))
    except Exception as e:
        print(f"  [NG] ImageJob test error: {e}")
        results.append(("ImageJob Schema", False))

    # 결과 요약
    print()
    print("=" * 60)
    print("[SUMMARY] Test Results")
    print("=" * 60)

    all_passed = True
    for name, passed in results:
        status = "[PASS]" if passed else "[FAIL]"
        if not passed:
            all_passed = False
        print(f"  {status}: {name}")

    print()
    if all_passed:
        print("[OK] All tests passed!")
        return 0
    else:
        print("[ERROR] Some tests failed")
        return 1


if __name__ == "__main__":
    sys.exit(main())
</file>

<file path="backend/tests/qa/test_asset_manifest.py">
import json
import os

import pytest
from jsonschema import validate

# Paths
# This file is in backend/tests/qa/
# We go up 3 levels to get to backend root: backend/tests/qa -> backend/tests -> backend -> root (wait, backend is in root)
# Actually:
# __file__ = D:\Dev\unknown-world\backend\tests\qa\test_asset_manifest.py
# os.path.dirname(__file__) = D:\Dev\unknown-world\backend\tests\qa
# ... up 1 = tests
# ... up 2 = backend
# ... up 3 = unknown-world (project root)

CURRENT_DIR = os.path.dirname(os.path.abspath(__file__))
PROJECT_ROOT = os.path.dirname(os.path.dirname(os.path.dirname(CURRENT_DIR)))

# If PROJECT_ROOT is correct, it should contain frontend/
FRONTEND_UI_DIR = os.path.join(PROJECT_ROOT, "frontend", "public", "ui")
MANIFEST_PATH = os.path.join(FRONTEND_UI_DIR, "manifest.json")
SCHEMA_PATH = os.path.join(FRONTEND_UI_DIR, "manifest.schema.json")


def test_manifest_schema_validation():
    """Validates manifest.json against manifest.schema.json"""
    if not os.path.exists(MANIFEST_PATH):
        pytest.fail(f"Manifest not found at {MANIFEST_PATH}")
    if not os.path.exists(SCHEMA_PATH):
        pytest.fail(f"Schema not found at {SCHEMA_PATH}")

    with open(MANIFEST_PATH, encoding="utf-8") as f:
        manifest = json.load(f)

    with open(SCHEMA_PATH, encoding="utf-8") as f:
        schema = json.load(f)

    # validate raises ValidationError on failure
    validate(instance=manifest, schema=schema)


def test_asset_files_existence_and_size():
    """Checks if assets listed in manifest exist and sizes match/budget"""
    with open(MANIFEST_PATH, encoding="utf-8") as f:
        manifest = json.load(f)

    assets = manifest.get("assets", [])
    total_bytes_calculated = 0

    for asset in assets:
        rel_path = asset["path"]
        abs_path = os.path.join(FRONTEND_UI_DIR, rel_path)

        # 1. Existence Check
        assert os.path.exists(abs_path), f"Asset file missing: {rel_path} (full: {abs_path})"

        # 2. Size Check
        actual_size = os.path.getsize(abs_path)
        recorded_size = asset.get("bytes")

        # Note: If size mismatches, we print a helpful message.
        # In a real QA scenario, we might want to auto-update, but for this test we fail.
        if recorded_size is not None:
            assert actual_size == recorded_size, (
                f"Size mismatch for {rel_path}: actual {actual_size} != manifest {recorded_size}"
            )

        total_bytes_calculated += actual_size

        # 3. Individual Budget Check (from QA_CHECKLIST.md)
        asset_type = asset["type"]
        if asset_type == "icon":
            # 30KB limit
            assert actual_size <= 30 * 1024, (
                f"Icon {rel_path} exceeds 30KB budget ({actual_size} bytes)"
            )
        elif asset_type == "placeholder":
            # 300KB limit
            assert actual_size <= 300 * 1024, (
                f"Placeholder {rel_path} exceeds 300KB budget ({actual_size} bytes)"
            )
        elif asset_type == "chrome":
            # 120KB limit (increased for scanner-frame)
            assert actual_size <= 120 * 1024, (
                f"Chrome asset {rel_path} exceeds 120KB budget ({actual_size} bytes)"
            )

    # 4. Total Budget Check
    recorded_total = manifest.get("totalBytes")
    if recorded_total is not None:
        assert total_bytes_calculated == recorded_total, (
            f"Total bytes mismatch: calculated {total_bytes_calculated} != manifest {recorded_total}"
        )

    budget_total = manifest.get("budgetBytes", 1572864)
    assert total_bytes_calculated <= budget_total, (
        f"Total size {total_bytes_calculated} exceeds budget {budget_total}"
    )


def test_asset_naming_convention():
    """Checks if asset IDs and paths use kebab-case"""
    with open(MANIFEST_PATH, encoding="utf-8") as f:
        manifest = json.load(f)

    for asset in manifest["assets"]:
        asset_id = asset["id"]
        # Check for lowercase and kebab-case (allow numbers)
        assert asset_id.islower(), f"Asset ID {asset_id} should be lowercase"
        assert " " not in asset_id, f"Asset ID {asset_id} should not contain spaces"
        assert "_" not in asset_id, (
            f"Asset ID {asset_id} should not contain underscores (use kebab-case)"
        )
</file>

<file path="backend/tests/unit/api/test_image.py">
"""Unknown World - 이미지 생성 API 엔드포인트 단위 테스트."""

import pytest
from fastapi.testclient import TestClient

from unknown_world.main import app
from unknown_world.services.image_generation import (
    ImageGenerationStatus,
    get_image_generator,
    reset_image_generator,
)


@pytest.fixture
def client():
    """FastAPI TestClient 픽스처."""
    return TestClient(app)


@pytest.fixture(autouse=True)
def setup_mock_generator():
    """모든 테스트에서 Mock 생성기를 사용하도록 설정."""
    reset_image_generator()
    get_image_generator(force_mock=True)
    yield
    reset_image_generator()


def test_generate_image_success(client):
    """이미지 생성 성공 케이스 테스트."""
    payload = {
        "prompt": "A futuristic laboratory with glowing screens",
        "aspect_ratio": "1:1",
        "image_size": "1024x1024",
        "skip_on_failure": True,
    }

    response = client.post("/api/image/generate", json=payload)

    assert response.status_code == 200
    data = response.json()
    assert data["success"] is True
    assert data["status"] == ImageGenerationStatus.COMPLETED
    assert data["image_id"] is not None
    assert data["image_url"] is not None


def test_generate_image_validation_error(client):
    """이미지 생성 요청 검증 실패 테스트."""
    # 너무 짧은 프롬프트
    payload = {"prompt": "A", "skip_on_failure": False}

    response = client.post("/api/image/generate", json=payload)

    assert response.status_code == 400
    assert "프롬프트가 너무 짧습니다" in response.json()["detail"]


def test_generate_image_fallback_on_error(client):
    """검증 실패 시 skip_on_failure=True일 때 폴백 동작 테스트."""
    payload = {"prompt": "A", "skip_on_failure": True}

    response = client.post("/api/image/generate", json=payload)

    assert response.status_code == 200
    data = response.json()
    assert data["success"] is False
    assert data["status"] == "skipped"
    assert "프롬프트가 너무 짧습니다" in data["message"]


def test_get_image_status(client):
    """이미지 상태 조회 테스트."""
    # 먼저 생성
    gen_resp = client.post("/api/image/generate", json={"prompt": "Test status"})
    image_id = gen_resp.json()["image_id"]

    # 상태 조회
    status_resp = client.get(f"/api/image/status/{image_id}")
    assert status_resp.status_code == 200
    assert status_resp.json()["exists"] is True
    assert status_resp.json()["image_url"] is not None


def test_static_image_access(client):
    """정적 파일 경로를 통한 이미지 접근 테스트."""
    # 이미지 생성
    gen_resp = client.post("/api/image/generate", json={"prompt": "Test static access"})
    image_url = gen_resp.json()["image_url"]

    # 정적 경로로 접근
    response = client.get(image_url)
    assert response.status_code == 200
    assert response.headers["content-type"] == "image/png"


def test_get_image_file_not_found(client):
    """존재하지 않는 이미지 파일 요청 시 404 테스트."""
    response = client.get("/api/image/file/non_existent_id")
    assert response.status_code == 404
</file>

<file path="backend/tests/unit/models/test_turn.py">
"""TurnInput/TurnOutput 모델 단위 테스트."""

import pytest
from pydantic import ValidationError

from unknown_world.models.turn import (
    AgentConsole,
    Box2D,
    CurrencyAmount,
    EconomyOutput,
    Language,
    RenderOutput,
    TurnInput,
    TurnOutput,
    UIOutput,
    WorldDelta,
)

# =============================================================================
# Fixtures
# =============================================================================


@pytest.fixture
def valid_box_2d():
    return {"ymin": 100, "xmin": 200, "ymax": 300, "xmax": 400}


@pytest.fixture
def valid_currency_amount():
    return {"signal": 100, "memory_shard": 5}


@pytest.fixture
def valid_client_info():
    return {"viewport_w": 1920, "viewport_h": 1080, "theme": "dark"}


@pytest.fixture
def valid_turn_input_data(valid_client_info, valid_currency_amount):
    return {
        "language": "ko-KR",
        "text": "Hello",
        "client": valid_client_info,
        "economy_snapshot": valid_currency_amount,
    }


@pytest.fixture
def valid_turn_output_data(valid_currency_amount):
    return {
        "language": "ko-KR",
        "narrative": "Story continues...",
        "economy": {
            "cost": {"signal": 10, "memory_shard": 0},
            "balance_after": {"signal": 90, "memory_shard": 5},
        },
        "safety": {"blocked": False},
    }


# =============================================================================
# Coordinate & Box2D Tests
# =============================================================================


def test_box_2d_valid(valid_box_2d):
    box = Box2D(**valid_box_2d)
    assert box.ymin == 100
    assert box.xmax == 400


def test_box_2d_invalid_coordinate():
    with pytest.raises(ValidationError):
        # Out of range (ge=0, le=1000)
        Box2D(ymin=-1, xmin=0, ymax=1001, xmax=500)


def test_box_2d_extra_forbidden():
    with pytest.raises(ValidationError):
        Box2D(ymin=0, xmin=0, ymax=100, xmax=100, extra_field="not allowed")


# =============================================================================
# Currency & Economy Tests
# =============================================================================


def test_currency_amount_valid(valid_currency_amount):
    amount = CurrencyAmount(**valid_currency_amount)
    assert amount.signal == 100


def test_currency_amount_negative_fails():
    with pytest.raises(ValidationError):
        CurrencyAmount(signal=-1, memory_shard=0)


def test_economy_output_valid():
    data = {
        "cost": {"signal": 5, "memory_shard": 0},
        "balance_after": {"signal": 95, "memory_shard": 5},
    }
    economy = EconomyOutput(**data)
    assert economy.cost.signal == 5
    assert economy.balance_after.signal == 95


# =============================================================================
# TurnInput Tests
# =============================================================================


def test_turn_input_valid(valid_turn_input_data):
    turn_input = TurnInput(**valid_turn_input_data)
    assert turn_input.language == Language.KO
    assert turn_input.text == "Hello"


def test_turn_input_with_click(valid_turn_input_data, valid_box_2d):
    data = valid_turn_input_data.copy()
    data["click"] = {"object_id": "door_01", "box_2d": valid_box_2d}
    turn_input = TurnInput(**data)
    assert turn_input.click.object_id == "door_01"
    assert turn_input.click.box_2d.ymin == 100


def test_turn_input_invalid_language():
    with pytest.raises(ValidationError):
        TurnInput(
            language="fr-FR",  # Not in Language enum
            text="...",
            client={"viewport_w": 800, "viewport_h": 600},
            economy_snapshot={"signal": 0, "memory_shard": 0},
        )


# =============================================================================
# TurnOutput Tests
# =============================================================================


def test_turn_output_valid_minimal(valid_turn_output_data):
    turn_output = TurnOutput(**valid_turn_output_data)
    assert turn_output.language == Language.KO
    assert turn_output.narrative == "Story continues..."
    # Check defaults
    assert isinstance(turn_output.ui, UIOutput)
    assert isinstance(turn_output.world, WorldDelta)
    assert isinstance(turn_output.render, RenderOutput)
    assert isinstance(turn_output.agent_console, AgentConsole)


def test_turn_output_full(valid_currency_amount, valid_box_2d):
    data = {
        "language": "en-US",
        "narrative": "Narrative text",
        "ui": {
            "action_deck": {
                "cards": [
                    {
                        "id": "c1",
                        "label": "Action 1",
                        "cost": {"signal": 5, "memory_shard": 0},
                    }
                ]
            },
            "objects": [{"id": "obj1", "label": "Object 1", "box_2d": valid_box_2d}],
        },
        "world": {
            "inventory_added": ["key"],
            "rules_changed": [{"id": "r1", "label": "Gravity", "description": "Low gravity"}],
            "quests_updated": [{"id": "q1", "label": "Find key", "is_completed": False}],
            "memory_pins": [
                {"id": "p1", "content": "Fact", "cost": {"signal": 1, "memory_shard": 0}}
            ],
        },
        "render": {
            "image_job": {
                "should_generate": True,
                "prompt": "A landscape",
                "model_label": "QUALITY",
            }
        },
        "economy": {
            "cost": {"signal": 10, "memory_shard": 0},
            "balance_after": {"signal": 90, "memory_shard": 5},
        },
        "safety": {"blocked": False},
        "agent_console": {"repair_count": 1, "badges": ["schema_ok", "economy_ok"]},
    }
    turn_output = TurnOutput(**data)
    assert turn_output.language == Language.EN
    assert len(turn_output.ui.action_deck.cards) == 1
    assert turn_output.render.image_job.should_generate is True


def test_turn_output_missing_required():
    with pytest.raises(ValidationError):
        # Missing economy and safety
        TurnOutput(language="ko-KR", narrative="...")


# =============================================================================
# JSON Schema Tests
# =============================================================================


def test_turn_output_json_schema():
    schema = TurnOutput.model_json_schema()
    assert schema["type"] == "object"
    assert "language" in schema["required"]
    assert "narrative" in schema["required"]
    assert "economy" in schema["required"]
    assert "safety" in schema["required"]

    # Check Coordinate constraints in schema
    # Pydantic 2 schema structure: properties -> language -> ...
    # Coordinate might be in $defs or inline depending on how it's used
    ui_props = schema["$defs"]["UIOutput"]["properties"]
    assert "action_deck" in ui_props

    # Verify that Coordinate (int with ge/le) is correctly represented
    # Box2D uses Coordinate
    box_props = schema["$defs"]["Box2D"]["properties"]
    assert box_props["ymin"]["maximum"] == 1000
    assert box_props["ymin"]["minimum"] == 0
</file>

<file path="backend/tests/unit/orchestrator/test_generate_turn_output.py">
"""Unknown World - TurnOutputGenerator 단위 테스트.

U-017[Mvp] 완료 기준 검증:
    - Structured Outputs 호출 구성 (application/json, response_schema)
    - Pydantic 검증 (model_validate_json)
    - 실패 분기 처리 (SCHEMA_FAILURE)
    - language 정책 준수
"""

import json
from unittest.mock import AsyncMock, patch

import pytest

from unknown_world.models.turn import (
    ClientInfo,
    CurrencyAmount,
    EconomySnapshot,
    Language,
    Theme,
    TurnInput,
    TurnOutput,
)
from unknown_world.orchestrator.generate_turn_output import (
    GenerationStatus,
    TurnOutputGenerator,
)
from unknown_world.services.genai_client import GenerateResponse


@pytest.fixture
def turn_input() -> TurnInput:
    """기본 턴 입력 픽스처."""
    return TurnInput(
        language=Language.KO,
        text="문을 열어본다",
        client=ClientInfo(viewport_w=1920, viewport_h=1080, theme=Theme.DARK),
        economy_snapshot=EconomySnapshot(signal=100, memory_shard=5),
    )


@pytest.fixture
def valid_turn_output_json() -> str:
    """유효한 TurnOutput JSON 문자열 픽스처."""
    return json.dumps(
        {
            "language": "ko-KR",
            "narrative": "낡은 문이 열리고 먼지가 날립니다.",
            "economy": {
                "cost": {"signal": 5, "memory_shard": 0},
                "balance_after": {"signal": 95, "memory_shard": 5},
            },
            "safety": {"blocked": False, "message": None},
            "ui": {"action_deck": {"cards": []}, "objects": []},
            "world": {
                "rules_changed": [],
                "inventory_added": [],
                "inventory_removed": [],
                "quests_updated": [],
                "memory_pins": [],
            },
            "render": {"image_job": None},
            "agent_console": {
                "current_phase": "commit",
                "badges": ["schema_ok", "economy_ok", "safety_ok"],
                "repair_count": 0,
            },
        }
    )


@pytest.mark.asyncio
async def test_generate_success(turn_input, valid_turn_output_json):
    """성공적인 생성 및 Pydantic 검증 테스트."""
    generator = TurnOutputGenerator(force_mock=True)

    # Mock GenAIClient.generate
    mock_response = GenerateResponse(text=valid_turn_output_json, model_label="fast")

    with patch(
        "unknown_world.orchestrator.generate_turn_output.get_genai_client"
    ) as mock_get_client:
        mock_client = AsyncMock()
        mock_client.generate.return_value = mock_response
        mock_get_client.return_value = mock_client

        result = await generator.generate(turn_input)

        assert result.status == GenerationStatus.SUCCESS
        assert isinstance(result.output, TurnOutput)
        assert result.output.narrative == "낡은 문이 열리고 먼지가 날립니다."
        assert result.output.language == Language.KO

        # API 호출 인자 검증 (Structured Outputs 설정 확인)
        call_args = mock_client.generate.call_args[0][0]
        assert call_args.response_mime_type == "application/json"
        assert call_args.response_schema is not None
        assert "narrative" in call_args.response_schema["properties"]


@pytest.mark.asyncio
async def test_generate_schema_validation_failure(turn_input):
    """Pydantic 검증 실패(SCHEMA_FAILURE) 테스트."""
    generator = TurnOutputGenerator(force_mock=True)

    # 필수 필드(narrative)가 누락된 잘못된 JSON
    invalid_json = json.dumps(
        {
            "language": "ko-KR",
            # "narrative" 필드 누락
            "economy": {
                "cost": {"signal": 5, "memory_shard": 0},
                "balance_after": {"signal": 95, "memory_shard": 5},
            },
            "safety": {"blocked": False, "message": None},
        }
    )

    mock_response = GenerateResponse(text=invalid_json, model_label="fast")

    with patch(
        "unknown_world.orchestrator.generate_turn_output.get_genai_client"
    ) as mock_get_client:
        mock_client = AsyncMock()
        mock_client.generate.return_value = mock_response
        mock_get_client.return_value = mock_client

        result = await generator.generate(turn_input)

        assert result.status == GenerationStatus.SCHEMA_FAILURE
        assert result.output is None
        assert "validation_errors" in result.error_details


@pytest.mark.asyncio
async def test_generate_json_decode_error(turn_input):
    """JSON 파싱 실패 테스트."""
    generator = TurnOutputGenerator(force_mock=True)

    # 유효하지 않은 JSON 형식
    invalid_text = "이것은 JSON이 아닙니다 { narrative: ... "

    mock_response = GenerateResponse(text=invalid_text, model_label="fast")

    with patch(
        "unknown_world.orchestrator.generate_turn_output.get_genai_client"
    ) as mock_get_client:
        mock_client = AsyncMock()
        mock_client.generate.return_value = mock_response
        mock_get_client.return_value = mock_client

        result = await generator.generate(turn_input)

        assert result.status == GenerationStatus.SCHEMA_FAILURE
        # Pydantic model_validate_json은 JSON 파싱 실패도 ValidationError(type=json_invalid)로 보고함
        errors = result.error_details.get("validation_errors", [])
        assert any(err["type"] == "json_invalid" for err in errors)


@pytest.mark.asyncio
async def test_generate_markdown_json_extraction(turn_input, valid_turn_output_json):
    """마크다운 코드 블록 내의 JSON 추출 테스트."""
    generator = TurnOutputGenerator(force_mock=True)

    # 마크다운 코드 블록으로 감싸진 응답
    markdown_text = f"```json\n{valid_turn_output_json}\n```"

    mock_response = GenerateResponse(text=markdown_text, model_label="fast")

    with patch(
        "unknown_world.orchestrator.generate_turn_output.get_genai_client"
    ) as mock_get_client:
        mock_client = AsyncMock()
        mock_client.generate.return_value = mock_response
        mock_get_client.return_value = mock_client

        result = await generator.generate(turn_input)

        assert result.status == GenerationStatus.SUCCESS
        assert result.output.narrative == "낡은 문이 열리고 먼지가 날립니다."


@pytest.mark.asyncio
async def test_generate_api_error(turn_input):
    """API 호출 에러 처리 테스트."""
    generator = TurnOutputGenerator(force_mock=True)

    with patch(
        "unknown_world.orchestrator.generate_turn_output.get_genai_client"
    ) as mock_get_client:
        mock_client = AsyncMock()
        mock_client.generate.side_effect = RuntimeError("API connection failed")
        mock_get_client.return_value = mock_client

        result = await generator.generate(turn_input)

        assert result.status == GenerationStatus.API_ERROR
        assert "API connection failed" in result.error_details["api_error"]


def test_create_safe_fallback():
    """안전한 폴백 생성 테스트 (RULE-004)."""
    generator = TurnOutputGenerator()

    economy_snapshot = CurrencyAmount(signal=80, memory_shard=3)
    fallback = generator.create_safe_fallback(
        language=Language.KO, error_message="Test Error", economy_snapshot=economy_snapshot
    )

    assert isinstance(fallback, TurnOutput)
    assert fallback.language == Language.KO
    assert fallback.economy.cost.signal == 0
    assert fallback.economy.balance_after.signal == 80
    assert "혼란스러운" in fallback.narrative
</file>

<file path="backend/tests/unit/orchestrator/test_pipeline.py">
"""Unknown World - Pipeline 단위/통합 테스트.

RU-005[Mvp] 리팩토링 검증:
    - Stage 기반 모듈화 동작 보존
    - PipelineContext 상태 전이 확인
    - 이벤트 emit 순서 및 정합성 (RULE-008)
    - U-018 비즈니스 룰 검증 및 Repair 루프 통합 확인
"""

from unittest.mock import AsyncMock, patch

import pytest

from unknown_world.models.turn import (
    AgentPhase,
    ClientInfo,
    EconomySnapshot,
    Language,
    Theme,
    TurnInput,
    TurnOutput,
    ValidationBadge,
)
from unknown_world.orchestrator.pipeline import (
    create_pipeline_context,
    run_pipeline,
)
from unknown_world.orchestrator.stages.types import (
    PipelineEvent,
    PipelineEventType,
)


@pytest.fixture
def turn_input() -> TurnInput:
    """기본 턴 입력 픽스처."""
    return TurnInput(
        language=Language.KO,
        text="문을 열어본다",
        client=ClientInfo(viewport_w=1920, viewport_h=1080, theme=Theme.DARK),
        economy_snapshot=EconomySnapshot(signal=100, memory_shard=5),
    )


def test_create_pipeline_context(turn_input):
    """컨텍스트 초기화 검증."""
    ctx = create_pipeline_context(turn_input, seed=42, is_mock=True)

    assert ctx.turn_input == turn_input
    assert ctx.economy_snapshot.signal == 100
    assert ctx.economy_snapshot.memory_shard == 5
    assert ctx.is_mock is True
    assert ctx.seed == 42
    assert ctx.output is None
    assert ctx.badges == []


@pytest.mark.asyncio
async def test_run_pipeline_happy_path_mock(turn_input):
    """Mock 모드에서 정상적인 파이프라인 실행 확인 (Happy Path)."""
    ctx = create_pipeline_context(turn_input, seed=42, is_mock=True)
    events = []

    async def emit(event: PipelineEvent):
        events.append(event)

    ctx = await run_pipeline(ctx, emit=emit)

    # 1. 최종 결과 확인
    assert ctx.output is not None
    assert isinstance(ctx.output, TurnOutput)
    assert ctx.is_fallback is False
    assert ctx.repair_attempts == 0

    # 2. 이벤트 순서 확인 (일부 핵심 단계만)
    event_types = [e.event_type for e in events]
    phases = [e.phase for e in events if e.phase is not None]

    assert PipelineEventType.STAGE_START in event_types
    assert PipelineEventType.STAGE_COMPLETE in event_types
    assert PipelineEventType.BADGES in event_types

    # PRD 순서: Parse -> Validate -> ... -> Commit
    assert AgentPhase.PARSE in phases
    assert AgentPhase.VALIDATE in phases
    assert AgentPhase.COMMIT in phases

    # 3. 배지 확인
    badges_events = [e for e in events if e.event_type == PipelineEventType.BADGES]
    assert len(badges_events) > 0
    assert ValidationBadge.SCHEMA_OK in badges_events[0].badges


@pytest.mark.asyncio
async def test_run_pipeline_validation_failure_repair_mock(turn_input):
    """비즈니스 룰 위반 시 Repair 루프 발생 확인 (Mock)."""
    ctx = create_pipeline_context(turn_input, seed=42, is_mock=True)
    events = []

    async def emit(event: PipelineEvent):
        events.append(event)

    # validate_business_rules를 모킹하여 첫 번째 시도에서 실패하게 함
    with patch(
        "unknown_world.orchestrator.stages.validate.validate_business_rules"
    ) as mock_validate:
        from unknown_world.validation.business_rules import BusinessRuleValidationResult

        mock_validate.side_effect = [
            BusinessRuleValidationResult(
                is_valid=False, errors=[{"type": "economy_insufficient", "message": "error"}]
            ),
            BusinessRuleValidationResult(is_valid=True, errors=[]),
        ]

        ctx = await run_pipeline(ctx, emit=emit)

    # Repair 이벤트가 발생했는지 확인
    repair_events = [e for e in events if e.event_type == PipelineEventType.REPAIR]
    assert len(repair_events) == 1
    assert repair_events[0].repair_attempt == 1
    assert ctx.repair_attempts == 1
    assert ctx.is_fallback is False


@pytest.mark.asyncio
async def test_run_pipeline_exception_fallback(turn_input):
    """스테이지 실행 중 예외 발생 시 폴백 확인."""
    ctx = create_pipeline_context(turn_input, is_mock=True)

    async def emit(event: PipelineEvent):
        pass

    # 예외를 던지는 가짜 스테이지
    async def failing_stage(c, *, emit):
        raise RuntimeError("Unexpected error")

    # 가짜 스테이지를 직접 전달하여 실행
    ctx = await run_pipeline(ctx, emit=emit, stages=[failing_stage])

    assert ctx.is_fallback is True
    assert ctx.output is not None
    assert "혼란스러운 순간" in ctx.output.narrative
    # 폴백 시 비용 0 확인 (RULE-005)
    assert ctx.output.economy.cost.signal == 0
    assert ctx.output.economy.balance_after.signal == 100


@pytest.mark.asyncio
async def test_validate_stage_real_delegation(turn_input):
    """validate_stage가 Real 모드에서 run_repair_loop를 호출하는지 확인."""
    from unknown_world.models.turn import AgentConsole, TurnOutput
    from unknown_world.orchestrator.repair_loop import RepairLoopResult
    from unknown_world.orchestrator.stages.validate import validate_stage

    ctx = create_pipeline_context(turn_input, is_mock=False)
    events = []

    async def emit(event: PipelineEvent):
        events.append(event)

    # 실제 객체 생성 후 필요한 필드만 모킹
    mock_output = AsyncMock(spec=TurnOutput)
    # dataclass 필드들에 대한 attribute 에러 방지를 위해 수동 설정
    mock_output.agent_console = AgentConsole(
        badges=[ValidationBadge.SCHEMA_OK], current_phase=AgentPhase.VALIDATE
    )

    with patch("unknown_world.orchestrator.stages.validate.run_repair_loop") as mock_run:
        mock_run.return_value = RepairLoopResult(
            output=mock_output,
            repair_attempts=1,
            is_fallback=False,
            badges=[ValidationBadge.SCHEMA_OK],
            error_messages=["repair test"],
        )

        ctx = await validate_stage(ctx, emit=emit)

    assert mock_run.called
    assert ctx.repair_attempts == 1
    assert PipelineEventType.REPAIR in [e.event_type for e in events]
    assert ctx.output == mock_output


@pytest.mark.asyncio
async def test_validate_stage_mock_max_retries_fallback(turn_input):
    """Mock 모드에서 최대 재시도 횟수 초과 시 폴백 확인."""
    from unknown_world.orchestrator.repair_loop import MAX_REPAIR_ATTEMPTS
    from unknown_world.orchestrator.stages.validate import validate_stage

    ctx = create_pipeline_context(turn_input, seed=42, is_mock=True)
    events = []

    async def emit(event: PipelineEvent):
        events.append(event)

    # 항상 실패하는 비즈니스 룰 검증 결과 반환
    with patch(
        "unknown_world.orchestrator.stages.validate.validate_business_rules"
    ) as mock_validate:
        from unknown_world.validation.business_rules import BusinessRuleValidationResult

        mock_validate.return_value = BusinessRuleValidationResult(
            is_valid=False, errors=[{"type": "economy_insufficient", "message": "error"}]
        )

        ctx = await validate_stage(ctx, emit=emit)

    assert ctx.is_fallback is True
    assert ctx.repair_attempts == MAX_REPAIR_ATTEMPTS + 1  # 0회차 + 1회차 + 2회차 시도 후 실패
    assert ValidationBadge.ECONOMY_FAIL in ctx.badges
    assert ctx.output.economy.cost.signal == 0


@pytest.mark.asyncio
async def test_validate_stage_mock_unexpected_exception(turn_input):
    """Mock 검증 루프 내에서 예외 발생 시 폴백 확인."""
    from unknown_world.orchestrator.stages.validate import validate_stage

    ctx = create_pipeline_context(turn_input, seed=42, is_mock=True)
    events = []

    async def emit(event: PipelineEvent):
        events.append(event)

    # generate_turn_output 호출 시 예외 발생
    with patch(
        "unknown_world.orchestrator.mock.MockOrchestrator.generate_turn_output",
        side_effect=RuntimeError("Mock error"),
    ):
        ctx = await validate_stage(ctx, emit=emit)

    assert ctx.is_fallback is True
    # _validate_mock 내부 try-except 루프가 MAX_REPAIR_ATTEMPTS만큼 돌고 결국 폴백
    assert ctx.repair_attempts > 0
</file>

<file path="backend/tests/unit/services/test_image_generation.py">
"""Unknown World - 이미지 생성 서비스 단위 테스트."""

from unittest.mock import patch

import pytest

from unknown_world.services.image_generation import (
    ImageGenerationRequest,
    ImageGenerationStatus,
    ImageGenerator,
    MockImageGenerator,
    get_image_generator,
    reset_image_generator,
)


@pytest.fixture
def temp_output_dir(tmp_path):
    """임시 출력 디렉토리 픽스처."""
    return tmp_path / "test_images"


@pytest.mark.asyncio
async def test_mock_image_generator_success(temp_output_dir):
    """Mock 이미지 생성기 성공 케이스 테스트."""
    generator = MockImageGenerator(output_dir=temp_output_dir)
    request = ImageGenerationRequest(
        prompt="A beautiful sunset over a cyberpunk city",
        aspect_ratio="1:1",
        image_size="1024x1024",
    )

    response = await generator.generate(request)

    assert response.status == ImageGenerationStatus.COMPLETED
    assert response.image_id is not None
    assert response.image_url is not None
    assert (temp_output_dir / f"{response.image_id}.png").exists()


@pytest.mark.asyncio
async def test_image_generator_initialization_failure():
    """실제 이미지 생성기 초기화 실패 시 처리 테스트."""
    with patch("google.genai.Client", side_effect=Exception("Auth error")):
        generator = ImageGenerator()
        assert generator.is_available() is False


@pytest.mark.asyncio
async def test_get_image_generator_singleton():
    """팩토리 함수를 통한 싱글톤 인스턴스 반환 테스트."""
    reset_image_generator()
    gen1 = get_image_generator(force_mock=True)
    gen2 = get_image_generator(force_mock=True)

    assert gen1 is gen2


@pytest.mark.asyncio
async def test_image_request_validation():
    """이미지 생성 요청 검증 로직 테스트."""
    from unknown_world.services.image_generation import validate_image_request

    # 성공 케이스
    valid_request = ImageGenerationRequest(prompt="Test prompt")
    assert validate_image_request(valid_request) is None

    # 실패 케이스: 지원하지 않는 크기
    invalid_size = ImageGenerationRequest(prompt="Test", image_size="invalid")
    assert validate_image_request(invalid_size) == "지원하지 않는 이미지 크기: invalid"

    # 실패 케이스: 너무 짧은 프롬프트
    short_prompt = ImageGenerationRequest(prompt="A")
    assert validate_image_request(short_prompt) == "프롬프트가 너무 짧습니다."
</file>

<file path="backend/tests/unit/services/test_rembg_preflight.py">
"""U-045[Mvp] rembg preflight 서비스 단위 테스트.

이 테스트는 서버 시작 시 rembg 설치 여부와 모델 캐시를 점검하고
필요한 경우 다운로드하는 로직을 검증합니다.
"""

import unittest
from pathlib import Path
from unittest.mock import MagicMock, patch

from unknown_world.services.rembg_preflight import (
    PreflightConfig,
    RembgPreflight,
    RembgReadyStatus,
)


class TestRembgPreflight(unittest.TestCase):
    """RembgPreflight 단위 테스트."""

    def setUp(self) -> None:
        self.config = PreflightConfig(
            models_to_prefetch=["test-model"],
            preflight_timeout_seconds=5,
            model_download_timeout_seconds=2,
        )
        self.preflight = RembgPreflight(self.config)

    @patch("unknown_world.services.rembg_preflight.subprocess.run")
    def test_check_rembg_installed_success(self, mock_run: MagicMock) -> None:
        """rembg 설치 확인 성공 테스트."""
        mock_run.return_value = MagicMock(returncode=0, stdout="rembg 2.0.67")
        installed, version = self.preflight._check_rembg_installed()
        self.assertTrue(installed)
        self.assertEqual(version, "rembg 2.0.67")

    @patch("unknown_world.services.rembg_preflight.subprocess.run")
    def test_check_rembg_installed_failure(self, mock_run: MagicMock) -> None:
        """rembg 미설치 확인 테스트."""
        mock_run.side_effect = FileNotFoundError()
        installed, version = self.preflight._check_rembg_installed()
        self.assertFalse(installed)
        self.assertIsNone(version)

    @patch("unknown_world.services.rembg_preflight.Path.exists")
    @patch("unknown_world.services.rembg_preflight.Path.home")
    def test_check_model_available(self, mock_home: MagicMock, mock_exists: MagicMock) -> None:
        """모델 캐시 존재 여부 확인 테스트."""
        mock_home.return_value = Path("/home/user")

        # 1. 모델 있음
        mock_exists.return_value = True
        self.assertTrue(self.preflight._check_model_available("test-model"))

        # 2. 모델 없음
        mock_exists.return_value = False
        self.assertFalse(self.preflight._check_model_available("test-model"))

    @patch("unknown_world.services.rembg_preflight.subprocess.run")
    def test_download_model_success(self, mock_run: MagicMock) -> None:
        """모델 다운로드 성공 테스트."""
        mock_run.return_value = MagicMock(returncode=0)
        self.assertTrue(self.preflight._download_model("test-model"))
        mock_run.assert_called_with(
            ["rembg", "d", "test-model"], capture_output=True, text=True, timeout=2
        )

    @patch("unknown_world.services.rembg_preflight.subprocess.run")
    def test_download_model_failure(self, mock_run: MagicMock) -> None:
        """모델 다운로드 실패 테스트."""
        mock_run.return_value = MagicMock(returncode=1, stderr="network error")
        self.assertFalse(self.preflight._download_model("test-model"))

    @patch("unknown_world.services.rembg_preflight.RembgPreflight._process_model")
    @patch("unknown_world.services.rembg_preflight.RembgPreflight._check_rembg_installed")
    def test_run_ready(self, mock_check_installed: MagicMock, mock_process: MagicMock) -> None:
        """전체 실행 성공 (READY) 테스트."""
        mock_check_installed.return_value = (True, "2.0.67")
        mock_process.return_value = MagicMock(name="test-model", available=True)

        result = self.preflight.run()

        self.assertEqual(result.status, RembgReadyStatus.READY)
        self.assertTrue(result.installed)
        self.assertIn("test-model", result.preloaded_models)
        self.assertEqual(len(result.missing_models), 0)

    @patch("unknown_world.services.rembg_preflight.RembgPreflight._process_model")
    @patch("unknown_world.services.rembg_preflight.RembgPreflight._check_rembg_installed")
    def test_run_degraded(self, mock_check_installed: MagicMock, mock_process: MagicMock) -> None:
        """일부 모델 누락 시 DEGRADED 테스트."""
        mock_check_installed.return_value = (True, "2.0.67")
        mock_process.return_value = MagicMock(name="test-model", available=False)

        result = self.preflight.run()

        self.assertEqual(result.status, RembgReadyStatus.DEGRADED)
        self.assertIn("test-model", result.missing_models)

    @patch("unknown_world.services.rembg_preflight.RembgPreflight._check_rembg_installed")
    def test_run_unavailable(self, mock_check_installed: MagicMock) -> None:
        """rembg 미설치 시 UNAVAILABLE 테스트."""
        mock_check_installed.return_value = (False, None)

        result = self.preflight.run()

        self.assertEqual(result.status, RembgReadyStatus.UNAVAILABLE)
        self.assertFalse(result.installed)


if __name__ == "__main__":
    unittest.main()
</file>

<file path="backend/tests/unit/test_dotenv_autoload.py">
"""U-047: Backend .env 자동 로딩 테스트

이 모듈은 backend/.env 파일의 자동 로딩 기능을 검증합니다.

완료 기준:
- 로컬에서 .env 존재 시 자동 로딩됨 (추가 export 불필요)
- UW_MODE/ENVIRONMENT가 .env 기준으로 반영됨
- .env 미존재 시 서버 정상 시작 (no-op)
- 민감 정보(키/토큰/프롬프트)는 로그/스트림에 노출되지 않음 (RULE-007)

테스트 시나리오:
1. .env 파일 존재 시 로딩 성공
2. .env 파일 미존재 시 기본값 사용 (정상 시작)
3. override=False 정책 검증 (기존 환경변수 우선)
4. 로깅에 민감 정보 미포함 검증
"""

import logging
import os
import tempfile
from collections.abc import Generator
from pathlib import Path

import pytest
from dotenv import load_dotenv


class TestDotenvAutoload:
    """dotenv 자동 로딩 기능 테스트 스위트."""

    # =========================================================================
    # Fixtures
    # =========================================================================

    @pytest.fixture
    def temp_env_file(self, tmp_path: Path) -> Generator[Path]:
        """임시 .env 파일을 생성하고 경로를 반환합니다."""
        env_file = tmp_path / ".env"
        env_file.write_text(
            "UW_MODE=real\nENVIRONMENT=development\nGOOGLE_APPLICATION_CREDENTIALS=./test-key.key\n"
        )
        yield env_file
        # cleanup
        if env_file.exists():
            env_file.unlink()

    @pytest.fixture
    def clean_env(self) -> Generator[None]:
        """테스트 전 관련 환경변수를 정리합니다."""
        # 저장할 원래 값들
        original_values: dict[str, str | None] = {}
        keys_to_clean = ["UW_MODE", "ENVIRONMENT", "GOOGLE_APPLICATION_CREDENTIALS"]

        for key in keys_to_clean:
            original_values[key] = os.environ.pop(key, None)

        yield

        # 복원
        for key, value in original_values.items():
            if value is not None:
                os.environ[key] = value
            elif key in os.environ:
                del os.environ[key]

    # =========================================================================
    # 1. 성공 시나리오 (Happy Path)
    # =========================================================================

    def test_dotenv_loads_when_file_exists(self, temp_env_file: Path, clean_env: None) -> None:
        """[Happy] .env 파일 존재 시 환경변수가 로드됩니다."""
        # Given: .env 파일이 존재하고 환경변수가 설정되어 있지 않음
        assert "UW_MODE" not in os.environ
        assert "ENVIRONMENT" not in os.environ

        # When: load_dotenv 호출
        result = load_dotenv(dotenv_path=temp_env_file, override=False)

        # Then: 환경변수가 로드됨
        assert result is True
        assert os.environ.get("UW_MODE") == "real"
        assert os.environ.get("ENVIRONMENT") == "development"

    def test_uw_mode_reflects_env_value(self, temp_env_file: Path, clean_env: None) -> None:
        """[Happy] UW_MODE가 .env에서 로드된 값으로 설정됩니다."""
        # Given: clean env + temp .env file
        load_dotenv(dotenv_path=temp_env_file, override=False)

        # When/Then: UW_MODE 값 확인
        assert os.environ.get("UW_MODE") == "real"

    def test_environment_reflects_env_value(self, temp_env_file: Path, clean_env: None) -> None:
        """[Happy] ENVIRONMENT가 .env에서 로드된 값으로 설정됩니다."""
        # Given: clean env + temp .env file
        load_dotenv(dotenv_path=temp_env_file, override=False)

        # When/Then: ENVIRONMENT 값 확인
        assert os.environ.get("ENVIRONMENT") == "development"

    # =========================================================================
    # 2. 실패/예외 시나리오 (Error Cases)
    # =========================================================================

    def test_server_starts_without_env_file(self, clean_env: None) -> None:
        """[Error] .env 파일 미존재 시 load_dotenv는 False를 반환하고 서버는 정상 시작합니다."""
        # Given: 존재하지 않는 경로
        non_existent_path = Path("/non/existent/path/.env")

        # When: load_dotenv 호출
        result = load_dotenv(dotenv_path=non_existent_path, override=False)

        # Then: False 반환 (에러 없이)
        assert result is False

    def test_default_values_when_env_missing(self, clean_env: None) -> None:
        """[Error] .env 미존재 시 기본값을 사용합니다."""
        # Given: .env 없이 환경변수도 없음
        # When: 기본값 조회
        uw_mode = os.environ.get("UW_MODE", "mock")
        environment = os.environ.get("ENVIRONMENT", "development")

        # Then: 기본값 사용
        assert uw_mode == "mock"  # genai_client.py의 기본값
        assert environment == "development"

    # =========================================================================
    # 3. 경계값 테스트 (Boundary Conditions)
    # =========================================================================

    def test_override_false_preserves_existing_env(
        self, temp_env_file: Path, clean_env: None
    ) -> None:
        """[Boundary] override=False: 기존 환경변수가 있으면 덮어쓰지 않습니다."""
        # Given: 환경변수가 이미 설정됨
        os.environ["UW_MODE"] = "mock"
        os.environ["ENVIRONMENT"] = "production"

        # When: load_dotenv(override=False) 호출
        load_dotenv(dotenv_path=temp_env_file, override=False)

        # Then: 기존 값 유지 (덮어쓰지 않음)
        assert os.environ.get("UW_MODE") == "mock"  # .env의 "real"로 변경되지 않음
        assert os.environ.get("ENVIRONMENT") == "production"

    def test_override_true_overwrites_existing_env(
        self, temp_env_file: Path, clean_env: None
    ) -> None:
        """[Boundary] override=True: 기존 환경변수를 덮어씁니다 (참조용, 프로덕션에서는 사용 금지)."""
        # Given: 환경변수가 이미 설정됨
        os.environ["UW_MODE"] = "mock"

        # When: load_dotenv(override=True) 호출 - 주의: 프로덕션에서는 금지
        load_dotenv(dotenv_path=temp_env_file, override=True)

        # Then: 새 값으로 덮어씀
        assert os.environ.get("UW_MODE") == "real"

    def test_empty_env_file_no_error(self, tmp_path: Path, clean_env: None) -> None:
        """[Boundary] 빈 .env 파일도 에러 없이 처리됩니다."""
        # Given: 빈 .env 파일
        empty_env = tmp_path / ".env"
        empty_env.write_text("")

        # When: load_dotenv 호출
        # Note: python-dotenv는 빈 파일에서도 에러를 발생시키지 않음
        # 반환값은 파일 존재 여부보다는 "변수가 로드되었는지"를 나타낼 수 있음
        try:
            result = load_dotenv(dotenv_path=empty_env, override=False)
            # Then: 에러 없이 완료됨 (반환값은 구현에 따라 다름)
            assert isinstance(result, bool)
        except Exception as e:
            pytest.fail(f"빈 .env 파일 처리 중 예외 발생: {e}")

    def test_env_with_comments_and_whitespace(self, tmp_path: Path, clean_env: None) -> None:
        """[Boundary] 주석과 공백이 있는 .env 파일을 올바르게 파싱합니다."""
        # Given: 주석과 공백이 있는 .env 파일
        env_file = tmp_path / ".env"
        env_file.write_text(
            "# This is a comment\n\nUW_MODE=real\n  \n# Another comment\nENVIRONMENT=staging\n"
        )

        # When: load_dotenv 호출
        load_dotenv(dotenv_path=env_file, override=False)

        # Then: 주석/공백 무시, 값만 로드
        assert os.environ.get("UW_MODE") == "real"
        assert os.environ.get("ENVIRONMENT") == "staging"

    # =========================================================================
    # 4. 보안 테스트 (Security) - RULE-007
    # =========================================================================

    def test_sensitive_info_not_in_logs(
        self, temp_env_file: Path, clean_env: None, caplog: pytest.LogCaptureFixture
    ) -> None:
        """[Security] 민감 정보(키/토큰/경로)가 로그에 노출되지 않습니다.

        이 테스트는 main.py의 로깅 정책(RULE-007)을 검증합니다:
        - 민감 정보(키/토큰/경로)는 로그에 출력하지 않음
        - 모드/환경 정보 정도만 로깅
        """
        # Given: .env에 민감 정보 포함
        load_dotenv(dotenv_path=temp_env_file, override=False)

        # When: main.py의 로깅 로직을 시뮬레이션
        with caplog.at_level(logging.INFO):
            # 로그 출력 시뮬레이션 (main.py 스타일)
            uw_mode = os.environ.get("UW_MODE", "mock")
            environment = os.environ.get("ENVIRONMENT", "development")

            logger = logging.getLogger("test_security")
            # 올바른 방식: 메시지에 안전한 정보만 포함
            logger.info(
                f"[Config] .env 파일 로드 완료 - UW_MODE={uw_mode}, ENVIRONMENT={environment}"
            )

        # Then: 민감 정보가 로그에 없음
        log_text = caplog.text

        # 키 파일 경로가 없어야 함 (RULE-007 위반 시 실패)
        assert "test-key.key" not in log_text, "민감 정보(키 파일 경로)가 로그에 노출됨"
        assert "GOOGLE_APPLICATION_CREDENTIALS" not in log_text, (
            "민감 정보(환경변수명)가 로그에 노출됨"
        )

        # 허용된 정보는 로그에 있어야 함 (올바른 로깅 확인)
        assert "UW_MODE" in log_text, "모드 정보가 로그에 있어야 함"
        assert "ENVIRONMENT" in log_text or "development" in log_text, (
            "환경 정보가 로그에 있어야 함"
        )


class TestMainModuleDotenvIntegration:
    """main.py 모듈의 dotenv 통합 테스트."""

    @pytest.fixture
    def clean_env(self) -> Generator[None]:
        """테스트 전 관련 환경변수를 정리합니다."""
        original_values: dict[str, str | None] = {}
        keys_to_clean = ["UW_MODE", "ENVIRONMENT"]

        for key in keys_to_clean:
            original_values[key] = os.environ.pop(key, None)

        yield

        for key, value in original_values.items():
            if value is not None:
                os.environ[key] = value
            elif key in os.environ:
                del os.environ[key]

    def test_main_module_dotenv_path_calculation(self) -> None:
        """[Integration] main.py의 .env 경로 계산이 올바릅니다."""
        # Given: main.py의 경로 계산 로직 재현
        # main.py 위치: backend/src/unknown_world/main.py
        # .env 위치: backend/.env
        # 따라서: main.py -> parent(unknown_world) -> parent(src) -> parent(backend) -> .env

        # 실제 main.py 경로 기준으로 계산
        main_py_path = Path(__file__).parent.parent.parent / "src" / "unknown_world" / "main.py"
        expected_dotenv_path = main_py_path.parent.parent.parent.parent / ".env"

        # When: 계산된 경로 확인
        actual_backend_dir = expected_dotenv_path.parent

        # Then: backend 디렉토리를 가리킴
        assert actual_backend_dir.name == "backend" or ".env" in str(expected_dotenv_path)

    def test_load_dotenv_returns_boolean(self) -> None:
        """[Integration] load_dotenv는 boolean을 반환하여 로딩 상태를 알 수 있습니다."""
        # Given: 임시 파일
        with tempfile.NamedTemporaryFile(mode="w", suffix=".env", delete=False) as f:
            f.write("TEST_VAR=test_value\n")
            temp_path = Path(f.name)

        try:
            # When: load_dotenv 호출
            result = load_dotenv(dotenv_path=temp_path, override=False)

            # Then: boolean 반환
            assert isinstance(result, bool)
            assert result is True
        finally:
            temp_path.unlink()


class TestDotenvPolicyCompliance:
    """dotenv 정책 준수 테스트."""

    def test_policy_local_development_autoload(self) -> None:
        """[Policy] 로컬 개발에서 .env 자동 로딩 정책이 준수됩니다.

        U-047 완료 기준:
        - 로컬에서 `cd backend && cp .env.example .env` 후
          `uv run uvicorn unknown_world.main:app ...` 실행 시
          .env가 자동 로딩된다(추가 export 불필요).
        """
        # Given: python-dotenv가 설치되어 있음 (pyproject.toml에 명시)
        # When: load_dotenv 함수가 사용 가능한지 확인
        from dotenv import load_dotenv

        # Then: 함수가 존재하고 호출 가능
        assert callable(load_dotenv)

    def test_policy_override_false_for_production_safety(self) -> None:
        """[Policy] override=False 정책으로 운영 환경 SSOT가 보장됩니다.

        U-047 정책:
        - 운영(Cloud Run 등)은 런타임 env를 SSOT로 사용(override 금지)
        """
        # Given: 운영 환경에서 환경변수가 이미 설정됨
        os.environ["POLICY_TEST_VAR"] = "production_value"

        with tempfile.NamedTemporaryFile(mode="w", suffix=".env", delete=False) as f:
            f.write("POLICY_TEST_VAR=dev_value\n")
            temp_path = Path(f.name)

        try:
            # When: override=False로 로드
            load_dotenv(dotenv_path=temp_path, override=False)

            # Then: 기존 값 유지 (운영 SSOT 보장)
            assert os.environ.get("POLICY_TEST_VAR") == "production_value"
        finally:
            temp_path.unlink()
            del os.environ["POLICY_TEST_VAR"]

    def test_policy_no_crash_without_env_file(self) -> None:
        """[Policy] .env 파일 미존재 시 서버가 정상 시작합니다.

        U-047 완료 기준:
        - .env는 존재하지 않아도 서버가 정상적으로 시작한다
          (운영/CI에서 파일 미존재를 기본으로 허용)
        """
        # Given: 존재하지 않는 .env 경로
        non_existent = Path("/definitely/not/a/real/path/.env")

        # When/Then: 에러 없이 False 반환
        try:
            result = load_dotenv(dotenv_path=non_existent, override=False)
            assert result is False  # 파일 없음
        except Exception as e:
            pytest.fail(f"load_dotenv raised an exception: {e}")
</file>

<file path="backend/tests/unit/test_image_generation_integration.py">
"""U-035[Mvp] 이미지 생성 서비스와 배경 제거 통합 테스트.

ImageGenerator 및 MockImageGenerator가 배경 제거 옵션을 올바르게 처리하는지 검증합니다.
"""

import unittest
from pathlib import Path
from unittest.mock import AsyncMock, MagicMock, patch

from unknown_world.services.image_generation import (
    ImageGenerationRequest,
    ImageGenerationStatus,
    MockImageGenerator,
)


class TestImageGenerationIntegration(unittest.IsolatedAsyncioTestCase):
    """이미지 생성 및 배경 제거 통합 테스트."""

    @patch("unknown_world.services.image_postprocess.ImagePostprocessor.remove_background")
    @patch("unknown_world.services.image_postprocess.ImagePostprocessor.is_available")
    async def test_mock_generator_rembg_integration(
        self, mock_available: MagicMock, mock_remove: MagicMock
    ) -> None:
        """MockImageGenerator가 배경 제거를 호출하는지 테스트합니다."""
        mock_available.return_value = True
        mock_remove.return_value = MagicMock(
            status=MagicMock(value="success"),
            model_used="birefnet-general",
            output_path=Path("img_123_nobg.png"),
            processing_time_ms=100,
        )

        generator = MockImageGenerator(output_dir=Path("test_output"))

        # 1. 배경 제거 활성화 요청
        request = ImageGenerationRequest(
            prompt="A cute cat", remove_background=True, image_type_hint="object"
        )

        # Path.write_bytes 모킹 (파일 생성 방지)
        with patch.object(Path, "write_bytes"):
            response = await generator.generate(request)

            self.assertEqual(response.status, ImageGenerationStatus.COMPLETED)
            self.assertTrue(response.background_removed)
            self.assertEqual(response.rembg_model_used, "birefnet-general")
            self.assertIn("_nobg.png", response.image_url)

            # rembg 후처리가 호출되었는지 확인
            mock_remove.assert_called_once()

    @patch("unknown_world.services.image_postprocess.ImagePostprocessor.remove_background")
    @patch("unknown_world.services.image_postprocess.ImagePostprocessor.is_available")
    async def test_mock_generator_no_rembg(
        self, mock_available: MagicMock, mock_remove: MagicMock
    ) -> None:
        """배경 제거 옵션이 꺼져있을 때 호출되지 않는지 테스트합니다."""
        generator = MockImageGenerator(output_dir=Path("test_output"))

        request = ImageGenerationRequest(prompt="A landscape", remove_background=False)

        with patch.object(Path, "write_bytes"):
            response = await generator.generate(request)

            self.assertEqual(response.status, ImageGenerationStatus.COMPLETED)
            self.assertFalse(response.background_removed)
            self.assertNotIn("_nobg.png", response.image_url)

            # rembg 후처리가 호출되지 않아야 함
            mock_remove.assert_not_called()

    @patch("unknown_world.services.image_generation.ImageGenerator._initialize_client")
    @patch("unknown_world.services.image_postprocess.ImagePostprocessor.remove_background")
    async def test_real_generator_rembg_integration(
        self, mock_remove: MagicMock, mock_init: MagicMock
    ) -> None:
        """실제 ImageGenerator(Vertex AI)와 rembg 통합을 테스트합니다."""
        from unknown_world.services.image_generation import ImageGenerator

        # 클라이언트 모킹
        mock_client = MagicMock()
        mock_client.aio.models.generate_images = AsyncMock()

        # 모의 이미지 생성 결과
        mock_image = MagicMock()
        mock_image.image.image_bytes = b"fake_png_data"
        mock_resp = MagicMock()
        mock_resp.generated_images = [mock_image]
        mock_client.aio.models.generate_images.return_value = mock_resp

        generator = ImageGenerator(output_dir=Path("test_output"))
        generator._client = mock_client
        generator._available = True

        mock_remove.return_value = MagicMock(
            status=MagicMock(value="success"),
            model_used="birefnet-general",
            output_path=Path("img_real_nobg.png"),
            processing_time_ms=150,
        )

        request = ImageGenerationRequest(
            prompt="A high quality product photo", remove_background=True, image_type_hint="product"
        )

        with patch.object(Path, "write_bytes"):
            response = await generator.generate(request)

            self.assertEqual(response.status, ImageGenerationStatus.COMPLETED)
            self.assertTrue(response.background_removed)
            mock_remove.assert_called_once()


if __name__ == "__main__":
    unittest.main()
</file>

<file path="backend/tests/unit/test_orchestrator_repair.py">
"""U-018: Repair Loop 및 비즈니스 룰 검증 단위 테스트."""

from unittest.mock import AsyncMock, patch

import pytest

from unknown_world.models.turn import (
    ActionDeck,
    AgentConsole,
    AgentPhase,
    ClientInfo,
    CurrencyAmount,
    EconomyOutput,
    EconomySnapshot,
    Language,
    RenderOutput,
    SafetyOutput,
    TurnInput,
    TurnOutput,
    UIOutput,
    ValidationBadge,
    WorldDelta,
)
from unknown_world.orchestrator.generate_turn_output import GenerationResult, GenerationStatus
from unknown_world.orchestrator.repair_loop import MAX_REPAIR_ATTEMPTS, run_repair_loop
from unknown_world.validation.business_rules import validate_business_rules


@pytest.fixture
def sample_turn_input() -> TurnInput:
    return TurnInput(
        language=Language.KO,
        text="테스트 입력",
        client=ClientInfo(viewport_w=1920, viewport_h=1080),
        economy_snapshot=EconomySnapshot(signal=100, memory_shard=5),
    )


@pytest.fixture
def valid_turn_output(sample_turn_input: TurnInput) -> TurnOutput:
    return TurnOutput(
        language=Language.KO,
        narrative="성공적인 내러티브",
        ui=UIOutput(action_deck=ActionDeck(cards=[]), objects=[]),
        world=WorldDelta(),
        render=RenderOutput(image_job=None),
        economy=EconomyOutput(
            cost=CurrencyAmount(signal=10, memory_shard=1),
            balance_after=CurrencyAmount(signal=90, memory_shard=4),
        ),
        safety=SafetyOutput(blocked=False),
        agent_console=AgentConsole(
            current_phase=AgentPhase.COMMIT,
            badges=[ValidationBadge.SCHEMA_OK],
            repair_count=0,
        ),
    )


@pytest.mark.asyncio
async def test_repair_loop_success_first_time(
    sample_turn_input: TurnInput, valid_turn_output: TurnOutput
) -> None:
    """초기 시도에 바로 성공하는 케이스."""
    with patch("unknown_world.orchestrator.repair_loop.get_turn_output_generator") as mock_get_gen:
        mock_gen = mock_get_gen.return_value
        mock_gen.generate = AsyncMock(
            return_value=GenerationResult(status=GenerationStatus.SUCCESS, output=valid_turn_output)
        )

        result = await run_repair_loop(sample_turn_input)

        assert result.is_fallback is False
        assert result.repair_attempts == 0
        assert result.output.narrative == valid_turn_output.narrative
        assert ValidationBadge.SCHEMA_OK in result.badges


@pytest.mark.asyncio
async def test_repair_loop_schema_failure_then_success(
    sample_turn_input: TurnInput, valid_turn_output: TurnOutput
) -> None:
    """스키마 실패 후 두 번째 시도에 성공하는 케이스."""
    with patch("unknown_world.orchestrator.repair_loop.get_turn_output_generator") as mock_get_gen:
        mock_gen = mock_get_gen.return_value
        # 첫 번째는 실패, 두 번째는 성공
        mock_gen.generate = AsyncMock(
            side_effect=[
                GenerationResult(
                    status=GenerationStatus.SCHEMA_FAILURE, error_message="Invalid JSON"
                ),
                GenerationResult(status=GenerationStatus.SUCCESS, output=valid_turn_output),
            ]
        )

        result = await run_repair_loop(sample_turn_input)

        assert result.is_fallback is False
        assert result.repair_attempts == 1
        assert ValidationBadge.SCHEMA_FAIL not in result.badges
        assert ValidationBadge.SCHEMA_OK in result.badges


@pytest.mark.asyncio
async def test_repair_loop_business_failure_then_success(
    sample_turn_input: TurnInput, valid_turn_output: TurnOutput
) -> None:
    """비즈니스 룰(언어 불일치) 실패 후 두 번째 시도에 성공하는 케이스."""
    invalid_lang_output = valid_turn_output.model_copy(deep=True)
    invalid_lang_output.language = Language.EN  # KO 입력에 EN 출력 (위반)

    with patch("unknown_world.orchestrator.repair_loop.get_turn_output_generator") as mock_get_gen:
        mock_gen = mock_get_gen.return_value
        mock_gen.generate = AsyncMock(
            side_effect=[
                GenerationResult(status=GenerationStatus.SUCCESS, output=invalid_lang_output),
                GenerationResult(status=GenerationStatus.SUCCESS, output=valid_turn_output),
            ]
        )

        result = await run_repair_loop(sample_turn_input)

        assert result.is_fallback is False
        assert result.repair_attempts == 1
        # 첫 시도에서 SCHEMA_OK는 받았지만 비즈니스 룰에서 걸려야 함
        assert result.repair_attempts == 1


@pytest.mark.asyncio
async def test_repair_loop_max_attempts_fallback(sample_turn_input: TurnInput) -> None:
    """모든 시도가 실패하여 폴백이 반환되는 케이스."""
    with patch("unknown_world.orchestrator.repair_loop.get_turn_output_generator") as mock_get_gen:
        mock_gen = mock_get_gen.return_value
        # 계속 스키마 실패
        mock_gen.generate = AsyncMock(
            return_value=GenerationResult(
                status=GenerationStatus.SCHEMA_FAILURE, error_message="Constant failure"
            )
        )

        result = await run_repair_loop(sample_turn_input)

        assert result.is_fallback is True
        assert result.repair_attempts == MAX_REPAIR_ATTEMPTS
        assert ValidationBadge.SCHEMA_FAIL in result.badges
        # 폴백 내러티브 확인
        assert "혼란스러운 순간" in result.output.narrative


@pytest.mark.asyncio
async def test_repair_loop_safety_blocked_immediate_fallback(sample_turn_input: TurnInput) -> None:
    """안전 차단 시 즉시 폴백되는 케이스."""
    with patch("unknown_world.orchestrator.repair_loop.get_turn_output_generator") as mock_get_gen:
        mock_gen = mock_get_gen.return_value
        mock_gen.generate = AsyncMock(
            return_value=GenerationResult(
                status=GenerationStatus.SAFETY_BLOCKED, error_message="Safety block"
            )
        )

        result = await run_repair_loop(sample_turn_input)

        assert result.is_fallback is True
        assert result.repair_attempts == 0  # 즉시 중단
        assert ValidationBadge.SAFETY_BLOCKED in result.badges
        assert result.output.safety.blocked is True


@pytest.mark.asyncio
async def test_validate_economy_negative_attempt(sample_turn_input: TurnInput) -> None:
    """재화가 부족한데 비용을 청구하여 음수 잔액을 만들려고 시도하는 경우."""
    # snapshot: signal=100
    # cost: signal=120
    # balance_after: signal=-20 (위반)

    invalid_output = TurnOutput(
        language=Language.KO,
        narrative="비싼 행동",
        ui=UIOutput(action_deck=ActionDeck(cards=[]), objects=[]),
        world=WorldDelta(),
        render=RenderOutput(image_job=None),
        economy=EconomyOutput(
            cost=CurrencyAmount(signal=120, memory_shard=0),
            balance_after=CurrencyAmount(
                signal=0, memory_shard=5
            ),  # 0으로 억지 보정 또는 음수 필드 오류
        ),
        safety=SafetyOutput(blocked=False),
        agent_console=AgentConsole(repair_count=0),
    )

    result = validate_business_rules(sample_turn_input, invalid_output)

    assert result.is_valid is False
    # Signal 잔액 불일치 (100 - 120 = -20 인데 실제 0이므로 mismatch)
    assert any("signal" in err["message"].lower() for err in result.errors)
</file>

<file path="backend/tests/unit/test_u043_language_gate.py">
"""U-043: 언어 혼합 검증 및 Repair 루프 단위 테스트."""

from unittest.mock import AsyncMock, patch

import pytest

from unknown_world.models.turn import (
    ActionCard,
    ActionDeck,
    AgentConsole,
    ClientInfo,
    CurrencyAmount,
    EconomyOutput,
    EconomySnapshot,
    Language,
    RenderOutput,
    SafetyOutput,
    TurnInput,
    TurnOutput,
    UIOutput,
    ValidationBadge,
    WorldDelta,
)
from unknown_world.orchestrator.generate_turn_output import GenerationResult, GenerationStatus
from unknown_world.orchestrator.repair_loop import run_repair_loop
from unknown_world.validation.business_rules import BusinessRuleError, validate_business_rules
from unknown_world.validation.language_gate import (
    measure_language_ratio,
    validate_language_consistency,
)


@pytest.fixture
def sample_turn_input() -> TurnInput:
    return TurnInput(
        language=Language.KO,
        text="테스트 입력",
        client=ClientInfo(viewport_w=1920, viewport_h=1080),
        economy_snapshot=EconomySnapshot(signal=100, memory_shard=5),
    )


@pytest.fixture
def base_turn_output(sample_turn_input: TurnInput) -> TurnOutput:
    return TurnOutput(
        language=Language.KO,
        narrative="정상적인 한국어 내러티브입니다.",
        ui=UIOutput(
            action_deck=ActionDeck(
                cards=[
                    ActionCard(
                        id="test",
                        label="테스트 카드",
                        cost=CurrencyAmount(signal=10, memory_shard=0),
                    )
                ]
            ),
            objects=[],
        ),
        world=WorldDelta(),
        render=RenderOutput(image_job=None),
        economy=EconomyOutput(
            cost=CurrencyAmount(signal=10, memory_shard=0),
            balance_after=CurrencyAmount(signal=90, memory_shard=5),
        ),
        safety=SafetyOutput(blocked=False),
        agent_console=AgentConsole(repair_count=0),
    )


def test_measure_language_ratio_ko():
    """한국어 텍스트의 언어 비율 측정 테스트."""
    text = "안녕하세요. 이것은 테스트입니다."
    ratio = measure_language_ratio(text)
    assert ratio.hangul_ratio > 0.8
    assert ratio.latin_ratio < 0.2


def test_measure_language_ratio_en():
    """영어 텍스트의 언어 비율 측정 테스트."""
    text = "Hello. This is a test."
    ratio = measure_language_ratio(text)
    assert ratio.latin_ratio > 0.8
    assert ratio.hangul_ratio == 0.0


def test_measure_language_ratio_mixed():
    """혼합된 텍스트의 언어 비율 측정 테스트."""
    text = "안녕하세요. This is a mixed text."
    ratio = measure_language_ratio(text)
    assert ratio.hangul_count > 0
    assert ratio.latin_count > 0


def test_measure_language_ratio_whitelist():
    """화이트리스트 단어가 비율 측정에서 제외되는지 테스트."""
    # "Signal"은 화이트리스트에 있으므로 라틴 카운트에서 제외되어야 함
    text = "Signal이 감지되었습니다."
    ratio = measure_language_ratio(text)
    # "이 감지되었습니다" (한글 7자 + 공백 1자) -> 한글 7
    # "signal" 제거됨. "i" 남음?
    # re.sub(rf"(?<![a-zA-Z]){re.escape(term)}(?![a-zA-Z])", "", ...)
    # "signal" -> ""
    # "이 감지되었습니다." 만 남음
    assert ratio.latin_count == 0
    assert ratio.hangul_count > 0


def test_validate_language_consistency_mixed_ko(base_turn_output):
    """한국어 요청에 영어가 섞인 경우 검증 테스트."""
    # 1. narrative
    mixed_output = base_turn_output.model_copy(deep=True)
    mixed_output.narrative = "이것은 한국어인데 Suddenly English appeared."
    result = validate_language_consistency(mixed_output, Language.KO)
    assert result.is_valid is False
    assert any(v["field"] == "narrative" for v in result.violations)

    # 2. action_deck.cards[0].label
    mixed_output = base_turn_output.model_copy(deep=True)
    mixed_output.ui.action_deck.cards[0].label = "Mixed Label 영어"
    result = validate_language_consistency(mixed_output, Language.KO)
    assert result.is_valid is False
    assert any(v["field"] == "ui.action_deck.cards[0].label" for v in result.violations)

    # 3. safety.message
    mixed_output = base_turn_output.model_copy(deep=True)
    mixed_output.safety.message = "This is a blocked message in English."
    result = validate_language_consistency(mixed_output, Language.KO)
    assert result.is_valid is False
    assert any(v["field"] == "safety.message" for v in result.violations)


def test_validate_language_consistency_en_with_ko(base_turn_output):
    """영어 요청에 한국어가 섞인 경우 검증 테스트."""
    en_input_lang = Language.EN
    en_output = base_turn_output.model_copy(deep=True)
    en_output.language = Language.EN
    en_output.narrative = "This is English but 한국어가 섞임."

    result = validate_language_consistency(en_output, en_input_lang)
    assert result.is_valid is False
    assert any(v["field"] == "narrative" for v in result.violations)


def test_build_language_error_summary_ko(base_turn_output):
    """한국어 에러 요약 생성 테스트."""
    from unknown_world.validation.language_gate import build_language_error_summary

    mixed_output = base_turn_output.model_copy(deep=True)
    mixed_output.narrative = "Mixed English."
    result = validate_language_consistency(mixed_output, Language.KO)

    summary = build_language_error_summary(result)
    assert "언어 혼합이 감지되었습니다" in summary
    assert "narrative" in summary
    assert "한국어(ko-KR)로 다시 작성하세요" in summary


def test_validate_business_rules_language_content_mixed(sample_turn_input, base_turn_output):
    """비즈니스 룰 검증에서 언어 혼합 감지 테스트."""
    mixed_output = base_turn_output.model_copy(deep=True)
    mixed_output.narrative = "한국어와 English가 섞여 있습니다. This should fail."

    result = validate_business_rules(sample_turn_input, mixed_output)
    assert result.is_valid is False
    assert any(err["type"] == BusinessRuleError.LANGUAGE_CONTENT_MIXED for err in result.errors)


@pytest.mark.asyncio
async def test_repair_loop_fixes_language_mixing(sample_turn_input, base_turn_output):
    """언어 혼합 시 Repair 루프가 작동하여 수정되는지 테스트."""
    mixed_output = base_turn_output.model_copy(deep=True)
    mixed_output.narrative = "혼합된 언어 English Mixed."

    valid_output = base_turn_output.model_copy(deep=True)
    valid_output.narrative = "수정된 한국어 내러티브"

    with patch("unknown_world.orchestrator.repair_loop.get_turn_output_generator") as mock_get_gen:
        mock_gen = mock_get_gen.return_value
        # 첫 번째는 혼합 출력, 두 번째는 정상 출력 반환
        mock_gen.generate = AsyncMock(
            side_effect=[
                GenerationResult(status=GenerationStatus.SUCCESS, output=mixed_output),
                GenerationResult(status=GenerationStatus.SUCCESS, output=valid_output),
            ]
        )

        result = await run_repair_loop(sample_turn_input)

        assert result.repair_attempts == 1
        assert result.output.narrative == "수정된 한국어 내러티브"
        assert ValidationBadge.CONSISTENCY_OK in result.badges
        assert ValidationBadge.CONSISTENCY_FAIL not in result.badges  # 최종 배지는 OK여야 함
</file>

<file path="frontend/coverage/coverage-final.json">
{"D:\\Dev\\unknown-world\\frontend\\src\\schemas\\turn.ts": {"path":"D:\\Dev\\unknown-world\\frontend\\src\\schemas\\turn.ts","statementMap":{"0":{"start":{"line":30,"column":30},"end":{"line":30,"column":null}},"1":{"start":{"line":41,"column":30},"end":{"line":41,"column":null}},"2":{"start":{"line":47,"column":27},"end":{"line":47,"column":null}},"3":{"start":{"line":54,"column":32},"end":{"line":62,"column":null}},"4":{"start":{"line":69,"column":37},"end":{"line":78,"column":null}},"5":{"start":{"line":85,"column":32},"end":{"line":85,"column":null}},"6":{"start":{"line":91,"column":31},"end":{"line":91,"column":null}},"7":{"start":{"line":102,"column":32},"end":{"line":107,"column":null}},"8":{"start":{"line":115,"column":27},"end":{"line":122,"column":null}},"9":{"start":{"line":129,"column":36},"end":{"line":138,"column":null}},"10":{"start":{"line":149,"column":32},"end":{"line":156,"column":null}},"11":{"start":{"line":162,"column":32},"end":{"line":176,"column":null}},"12":{"start":{"line":183,"column":37},"end":{"line":192,"column":null}},"13":{"start":{"line":199,"column":31},"end":{"line":209,"column":null}},"14":{"start":{"line":220,"column":32},"end":{"line":229,"column":null}},"15":{"start":{"line":236,"column":33},"end":{"line":247,"column":null}},"16":{"start":{"line":254,"column":32},"end":{"line":262,"column":null}},"17":{"start":{"line":270,"column":30},"end":{"line":278,"column":null}},"18":{"start":{"line":289,"column":31},"end":{"line":295,"column":null}},"19":{"start":{"line":302,"column":31},"end":{"line":312,"column":null}},"20":{"start":{"line":319,"column":27},"end":{"line":325,"column":null}},"21":{"start":{"line":332,"column":32},"end":{"line":359,"column":null}},"22":{"start":{"line":370,"column":30},"end":{"line":382,"column":null}},"23":{"start":{"line":389,"column":34},"end":{"line":395,"column":null}},"24":{"start":{"line":407,"column":35},"end":{"line":412,"column":null}},"25":{"start":{"line":424,"column":34},"end":{"line":436,"column":null}},"26":{"start":{"line":447,"column":34},"end":{"line":453,"column":null}},"27":{"start":{"line":469,"column":32},"end":{"line":502,"column":null}},"28":{"start":{"line":523,"column":4},"end":{"line":525,"column":null}},"29":{"start":{"line":528,"column":4},"end":{"line":530,"column":null}},"30":{"start":{"line":532,"column":2},"end":{"line":563,"column":null}},"31":{"start":{"line":590,"column":17},"end":{"line":590,"column":null}},"32":{"start":{"line":592,"column":2},"end":{"line":594,"column":null}},"33":{"start":{"line":593,"column":4},"end":{"line":593,"column":null}},"34":{"start":{"line":596,"column":2},"end":{"line":600,"column":null}},"35":{"start":{"line":611,"column":2},"end":{"line":611,"column":null}},"36":{"start":{"line":625,"column":2},"end":{"line":625,"column":null}}},"fnMap":{"0":{"name":"createFallbackTurnOutput","decl":{"start":{"line":517,"column":16},"end":{"line":517,"column":null}},"loc":{"start":{"line":521,"column":14},"end":{"line":564,"column":null}},"line":521},"1":{"name":"safeParseTurnOutput","decl":{"start":{"line":585,"column":16},"end":{"line":585,"column":null}},"loc":{"start":{"line":589,"column":25},"end":{"line":601,"column":null}},"line":589},"2":{"name":"parseTurnInput","decl":{"start":{"line":610,"column":16},"end":{"line":610,"column":31}},"loc":{"start":{"line":610,"column":57},"end":{"line":612,"column":null}},"line":610},"3":{"name":"safeParseTurnInput","decl":{"start":{"line":624,"column":16},"end":{"line":624,"column":35}},"loc":{"start":{"line":624,"column":76},"end":{"line":626,"column":null}},"line":624}},"branchMap":{"0":{"loc":{"start":{"line":519,"column":2},"end":{"line":519,"column":null}},"type":"default-arg","locations":[{"start":{"line":519,"column":24},"end":{"line":519,"column":null}}],"line":519},"1":{"loc":{"start":{"line":523,"column":4},"end":{"line":525,"column":null}},"type":"cond-expr","locations":[{"start":{"line":524,"column":8},"end":{"line":524,"column":null}},{"start":{"line":525,"column":8},"end":{"line":525,"column":null}}],"line":523},"2":{"loc":{"start":{"line":528,"column":4},"end":{"line":530,"column":null}},"type":"cond-expr","locations":[{"start":{"line":529,"column":8},"end":{"line":529,"column":null}},{"start":{"line":530,"column":8},"end":{"line":530,"column":null}}],"line":528},"3":{"loc":{"start":{"line":534,"column":15},"end":{"line":534,"column":null}},"type":"binary-expr","locations":[{"start":{"line":534,"column":15},"end":{"line":534,"column":31}},{"start":{"line":534,"column":31},"end":{"line":534,"column":null}}],"line":534},"4":{"loc":{"start":{"line":587,"column":2},"end":{"line":587,"column":null}},"type":"default-arg","locations":[{"start":{"line":587,"column":23},"end":{"line":587,"column":null}}],"line":587},"5":{"loc":{"start":{"line":588,"column":2},"end":{"line":588,"column":null}},"type":"default-arg","locations":[{"start":{"line":588,"column":24},"end":{"line":588,"column":null}}],"line":588},"6":{"loc":{"start":{"line":592,"column":2},"end":{"line":594,"column":null}},"type":"if","locations":[{"start":{"line":592,"column":2},"end":{"line":594,"column":null}},{"start":{},"end":{}}],"line":592}},"s":{"0":1,"1":1,"2":1,"3":1,"4":1,"5":1,"6":1,"7":1,"8":1,"9":1,"10":1,"11":1,"12":1,"13":1,"14":1,"15":1,"16":1,"17":1,"18":1,"19":1,"20":1,"21":1,"22":1,"23":1,"24":1,"25":1,"26":1,"27":1,"28":1,"29":1,"30":1,"31":2,"32":2,"33":1,"34":1,"35":2,"36":2},"f":{"0":1,"1":2,"2":2,"3":2},"b":{"0":[1],"1":[1,0],"2":[1,0],"3":[1,1],"4":[2],"5":[2],"6":[1,1]},"meta":{"lastBranch":7,"lastFunction":4,"lastStatement":37,"seen":{"s:30:30:30:Infinity":0,"s:41:30:41:Infinity":1,"s:47:27:47:Infinity":2,"s:54:32:62:Infinity":3,"s:69:37:78:Infinity":4,"s:85:32:85:Infinity":5,"s:91:31:91:Infinity":6,"s:102:32:107:Infinity":7,"s:115:27:122:Infinity":8,"s:129:36:138:Infinity":9,"s:149:32:156:Infinity":10,"s:162:32:176:Infinity":11,"s:183:37:192:Infinity":12,"s:199:31:209:Infinity":13,"s:220:32:229:Infinity":14,"s:236:33:247:Infinity":15,"s:254:32:262:Infinity":16,"s:270:30:278:Infinity":17,"s:289:31:295:Infinity":18,"s:302:31:312:Infinity":19,"s:319:27:325:Infinity":20,"s:332:32:359:Infinity":21,"s:370:30:382:Infinity":22,"s:389:34:395:Infinity":23,"s:407:35:412:Infinity":24,"s:424:34:436:Infinity":25,"s:447:34:453:Infinity":26,"s:469:32:502:Infinity":27,"f:517:16:517:Infinity":0,"b:519:24:519:Infinity":0,"s:523:4:525:Infinity":28,"b:524:8:524:Infinity:525:8:525:Infinity":1,"s:528:4:530:Infinity":29,"b:529:8:529:Infinity:530:8:530:Infinity":2,"s:532:2:563:Infinity":30,"b:534:15:534:31:534:31:534:Infinity":3,"f:585:16:585:Infinity":1,"b:587:23:587:Infinity":4,"b:588:24:588:Infinity":5,"s:590:17:590:Infinity":31,"b:592:2:594:Infinity:undefined:undefined:undefined:undefined":6,"s:592:2:594:Infinity":32,"s:593:4:593:Infinity":33,"s:596:2:600:Infinity":34,"f:610:16:610:31":2,"s:611:2:611:Infinity":35,"f:624:16:624:35":3,"s:625:2:625:Infinity":36}}}
}
</file>

<file path="frontend/tsconfig.node.json">
{
  "compilerOptions": {
    "target": "ES2022",
    "lib": ["ES2022"],
    "module": "ESNext",
    "skipLibCheck": true,

    /* Bundler mode */
    "moduleResolution": "Bundler",
    "allowImportingTsExtensions": true,
    "isolatedModules": true,
    "moduleDetection": "force",

    /* Composite for project references */
    "composite": true,
    "emitDeclarationOnly": true,
    "declaration": true,
    "declarationMap": true,

    /* Linting (엄격 모드) */
    "strict": true,
    "noUnusedLocals": true,
    "noUnusedParameters": true,
    "noFallthroughCasesInSwitch": true,
    "noUncheckedSideEffectImports": true
  },
  "include": ["vite.config.ts"]
}
</file>

<file path="request.json">
{"language": "ko-KR", "text": "모험을 시작한다", "client": {"viewport_w": 1920, "viewport_h": 1080, "theme": "dark"}, "economy_snapshot": {"signal": 5, "memory_shard": 0}}
</file>

<file path="backend/src/unknown_world/api/__init__.py">
"""Unknown World - API 패키지.

이 패키지는 FastAPI 라우터들을 포함합니다.
"""

from unknown_world.api.image import router as image_router
from unknown_world.api.turn import router as turn_router

__all__ = ["image_router", "turn_router"]
</file>

<file path="backend/src/unknown_world/api/turn_stream_events.py">
"""Unknown World - Turn Stream 이벤트 계약(Contract).

NDJSON 스트리밍에서 사용되는 이벤트 타입, 모델, 유틸리티를 정의합니다.
이 모듈은 Orchestrator ↔ API ↔ Frontend 간의 스트림 이벤트 계약 SSOT입니다.

설계 원칙:
    - RU-002-Q4: 이벤트 계약을 transport 계층으로 분리
    - RULE-003: 구조화 출력(JSON Schema) 우선 + Pydantic 검증
    - RULE-008: 단계/배지 가시화

참조:
    - vibe/unit-plans/U-007[Mvp].md
    - vibe/refactors/RU-002-Q4.md
"""

from __future__ import annotations

import json
from typing import Annotated, Any

from pydantic import BaseModel, Field

# =============================================================================
# 스트림 이벤트 타입 상수
# =============================================================================


class StreamEventType:
    """스트림 이벤트 타입 상수.

    NDJSON 스트리밍에서 사용되는 이벤트 타입입니다.
    PRD 예시 단계: Parse→Validate→Plan→Resolve→Render→Verify→Commit
    """

    STAGE = "stage"
    BADGES = "badges"
    NARRATIVE_DELTA = "narrative_delta"
    FINAL = "final"
    ERROR = "error"
    REPAIR = "repair"


class StageStatus:
    """단계 상태 상수."""

    START = "start"
    COMPLETE = "complete"
    FAIL = "fail"


# =============================================================================
# 스트림 이벤트 모델 (Pydantic)
# =============================================================================


class StageEvent(BaseModel):
    """단계 진행 이벤트.

    Attributes:
        type: 이벤트 타입 ("stage")
        name: 단계 이름 (Parse, Validate, Plan, Resolve, Render, Verify, Commit)
        status: 상태 (start, complete)
    """

    type: Annotated[str, Field(default=StreamEventType.STAGE)]
    name: str
    status: str


class RepairEvent(BaseModel):
    """자동 복구(Repair) 이벤트.

    Attributes:
        type: 이벤트 타입 ("repair")
        attempt: 현재 시도 횟수
        message: 복구 메시지 (선택)
    """

    type: Annotated[str, Field(default=StreamEventType.REPAIR)]
    attempt: int
    message: str | None = None


class BadgesEvent(BaseModel):
    """배지 이벤트.

    Attributes:
        type: 이벤트 타입 ("badges")
        badges: 검증 배지 목록
    """

    type: Annotated[str, Field(default=StreamEventType.BADGES)]
    badges: list[str]


class NarrativeDeltaEvent(BaseModel):
    """내러티브 델타 이벤트 (타자 효과용).

    Attributes:
        type: 이벤트 타입 ("narrative_delta")
        text: 추가된 텍스트 조각
    """

    type: Annotated[str, Field(default=StreamEventType.NARRATIVE_DELTA)]
    text: str


class FinalEvent(BaseModel):
    """최종 TurnOutput 이벤트.

    Attributes:
        type: 이벤트 타입 ("final")
        data: 완전한 TurnOutput

    Note:
        TurnOutput은 TYPE_CHECKING 블록에서 import되며,
        런타임에는 Any로 처리됩니다.
    """

    type: Annotated[str, Field(default=StreamEventType.FINAL)]
    data: Any  # TurnOutput (순환 import 방지)


class ErrorEvent(BaseModel):
    """에러 이벤트.

    Attributes:
        type: 이벤트 타입 ("error")
        message: 에러 메시지 (프롬프트/내부 추론 노출 금지)
        code: 에러 코드 (선택)
    """

    type: Annotated[str, Field(default=StreamEventType.ERROR)]
    message: str
    code: str | None = None


# =============================================================================
# 유틸리티 함수
# =============================================================================


def serialize_event(event: dict[str, Any]) -> str:
    """이벤트를 NDJSON 라인으로 직렬화합니다.

    Args:
        event: 직렬화할 이벤트 딕셔너리

    Returns:
        str: NDJSON 형식 문자열 (줄바꿈 포함)
    """
    return json.dumps(event, ensure_ascii=False) + "\n"


# =============================================================================
# 모듈 공개 API
# =============================================================================

__all__ = [
    "StreamEventType",
    "StageStatus",
    "StageEvent",
    "RepairEvent",
    "BadgesEvent",
    "NarrativeDeltaEvent",
    "FinalEvent",
    "ErrorEvent",
    "serialize_event",
]
</file>

<file path="backend/src/unknown_world/orchestrator/fallback.py">
"""Unknown World - 안전한 폴백 TurnOutput 생성기.

최종 복구 실패 시에도 UI가 빈 화면이 되지 않도록
스키마를 만족하는 안전한 TurnOutput을 생성합니다.

설계 원칙:
    - RULE-004: 검증 실패 시 안전한 폴백 제공
    - RULE-005: 재화 인바리언트 (비용 0, 잔액 유지)
    - RULE-006: ko/en 언어 정책 준수

참조:
    - vibe/unit-plans/U-018[Mvp].md
    - vibe/prd.md 8.7 (TurnOutput 스키마)
"""

from __future__ import annotations

from unknown_world.models.turn import (
    ActionCard,
    ActionDeck,
    AgentConsole,
    AgentPhase,
    CurrencyAmount,
    EconomyOutput,
    Language,
    RenderOutput,
    RiskLevel,
    SafetyOutput,
    TurnOutput,
    UIOutput,
    ValidationBadge,
    WorldDelta,
)

# =============================================================================
# 폴백 메시지 (i18n)
# =============================================================================

FALLBACK_MESSAGES = {
    Language.KO: {
        "narrative": "잠시 혼란스러운 순간이 지나갑니다. 다시 집중해봅시다.",
        "narrative_blocked": "안전 정책에 따라 이 요청을 처리할 수 없습니다. 다른 행동을 시도해보세요.",
        "alternative_label": "텍스트로 진행하기",
        "alternative_desc": "이미지 생성 없이 저비용으로 진행합니다",
    },
    Language.EN: {
        "narrative": "A moment of confusion passes. Let's focus again.",
        "narrative_blocked": "This request cannot be processed due to safety policies. Please try a different action.",
        "alternative_label": "Continue with text",
        "alternative_desc": "Proceed at low cost without image generation",
    },
}


# =============================================================================
# 폴백 생성 함수
# =============================================================================


def create_safe_fallback(
    language: Language,
    economy_snapshot: CurrencyAmount | None = None,
    repair_count: int = 0,
    is_blocked: bool = False,
) -> TurnOutput:
    """안전한 폴백 TurnOutput을 생성합니다.

    최종 복구 실패 시 사용합니다.
    스키마를 만족하고, 비용 0으로 잔액을 유지합니다.

    Args:
        language: 응답 언어
        economy_snapshot: 현재 재화 상태 (비용 0으로 유지)
        repair_count: 복구 시도 횟수
        is_blocked: 안전 정책에 의해 차단되었는지

    Returns:
        안전한 폴백 TurnOutput

    Example:
        >>> fallback = create_safe_fallback(
        ...     language=Language.KO,
        ...     economy_snapshot=CurrencyAmount(signal=50, memory_shard=3),
        ...     repair_count=2,
        ... )
        >>> print(fallback.narrative)
    """
    messages = FALLBACK_MESSAGES[language]

    # 내러티브 선택
    narrative = messages["narrative_blocked"] if is_blocked else messages["narrative"]

    # 재화 유지 (비용 0)
    balance = economy_snapshot or CurrencyAmount(signal=100, memory_shard=5)

    # 저비용 대안 카드 제공 (RULE-005)
    alternative_card = ActionCard(
        id="fallback_text_only",
        label=messages["alternative_label"],
        description=messages["alternative_desc"],
        cost=CurrencyAmount(signal=1, memory_shard=0),
        risk=RiskLevel.LOW,
        enabled=True,
        is_alternative=True,
    )

    # 배지 결정 (RU-005-S1: 폴백에서도 모든 카테고리의 배지를 일관되게 설정)
    badges: list[ValidationBadge] = []

    # Schema: 폴백이므로 SCHEMA_FAIL (단, 안전 차단은 스키마 문제가 아님)
    if not is_blocked:
        badges.append(ValidationBadge.SCHEMA_FAIL)
    else:
        badges.append(ValidationBadge.SCHEMA_OK)

    # Economy: 폴백에서는 비용 0이므로 ECONOMY_OK
    badges.append(ValidationBadge.ECONOMY_OK)

    # Safety: is_blocked에 따라 결정
    if is_blocked:
        badges.append(ValidationBadge.SAFETY_BLOCKED)
    else:
        badges.append(ValidationBadge.SAFETY_OK)

    # Consistency: 폴백에서는 언어/좌표 문제가 없으므로 CONSISTENCY_OK
    badges.append(ValidationBadge.CONSISTENCY_OK)

    return TurnOutput(
        language=language,
        narrative=narrative,
        ui=UIOutput(
            action_deck=ActionDeck(cards=[alternative_card]),
            objects=[],
        ),
        world=WorldDelta(),
        render=RenderOutput(image_job=None),  # 이미지 생성 안 함
        economy=EconomyOutput(
            cost=CurrencyAmount(signal=0, memory_shard=0),
            balance_after=balance,
        ),
        safety=SafetyOutput(
            blocked=is_blocked,
            message=messages["narrative_blocked"] if is_blocked else None,
        ),
        agent_console=AgentConsole(
            current_phase=AgentPhase.COMMIT,
            badges=badges,
            repair_count=repair_count,
        ),
    )
</file>

<file path="backend/src/unknown_world/orchestrator/generate_turn_output.py">
"""Unknown World - TurnOutput 생성 모듈 (Structured Outputs).

이 모듈은 Gemini 텍스트 모델을 Structured Outputs(JSON Schema) 모드로 호출해
TurnOutput을 생성하고, Pydantic 검증을 통과한 결과만 반환합니다.

설계 원칙:
    - RULE-003: 구조화 출력(JSON Schema) 우선 + 이중 검증(Pydantic+Zod)
    - RULE-004: 검증 실패 시 자동 복구(Repair loop) + 안전한 폴백
    - RULE-005: 재화 인바리언트 (잔액 음수 금지)
    - RULE-006: ko/en 언어 정책 준수
    - RULE-007/008: 프롬프트/내부 추론 노출 금지

페어링 질문 결정:
    - Q1: 기본 텍스트 생성 모델 라벨 = FAST (Option A)

참조:
    - vibe/unit-plans/U-017[Mvp].md
    - vibe/unit-results/U-016[Mvp].md
    - vibe/unit-results/U-005[Mvp].md
    - .cursor/rules/20-backend-orchestrator.mdc
"""

from __future__ import annotations

import json
import logging
from dataclasses import dataclass, field
from enum import StrEnum
from typing import Any

from pydantic import ValidationError

from unknown_world.config.models import ModelLabel
from unknown_world.models.turn import (
    CurrencyAmount,
    Language,
    TurnInput,
    TurnOutput,
)
from unknown_world.orchestrator.fallback import create_safe_fallback
from unknown_world.orchestrator.prompt_loader import (
    load_system_prompt,
    load_turn_instructions,
)
from unknown_world.services.genai_client import (
    GenerateRequest,
    get_genai_client,
)

# =============================================================================
# 로거 설정 (프롬프트/내부 추론 노출 금지 - RULE-007/008)
# =============================================================================

logger = logging.getLogger(__name__)


# =============================================================================
# 생성 결과 타입
# =============================================================================


class GenerationStatus(StrEnum):
    """생성 결과 상태."""

    SUCCESS = "success"
    """Pydantic 검증 통과"""

    SCHEMA_FAILURE = "schema_failure"
    """JSON 파싱 또는 스키마 검증 실패 (복구 대상)"""

    BUSINESS_FAILURE = "business_failure"
    """비즈니스 룰 위반 (U-018에서 처리)"""

    SAFETY_BLOCKED = "safety_blocked"
    """안전 정책에 의해 차단됨"""

    API_ERROR = "api_error"
    """API 호출 실패"""


@dataclass
class GenerationResult:
    """TurnOutput 생성 결과.

    Attributes:
        status: 생성 상태
        output: 생성된 TurnOutput (성공 시)
        error_message: 에러 메시지 (실패 시, 사용자 표시용)
        error_details: 상세 에러 정보 (내부용, UI 노출 금지)
        model_label: 사용된 모델 라벨
        raw_response: 원본 응답 텍스트 (디버그용, UI 노출 금지)
    """

    status: GenerationStatus
    output: TurnOutput | None = None
    error_message: str = ""
    error_details: dict[str, Any] = field(default_factory=lambda: {})
    model_label: ModelLabel = ModelLabel.FAST
    raw_response: str = ""


# =============================================================================
# TurnOutput 생성기
# =============================================================================


class TurnOutputGenerator:
    """Structured Outputs를 사용한 TurnOutput 생성기.

    Gemini 모델을 JSON Schema 모드로 호출하고,
    Pydantic으로 응답을 검증합니다.

    Example:
        >>> generator = TurnOutputGenerator()
        >>> result = await generator.generate(turn_input)
        >>> if result.status == GenerationStatus.SUCCESS:
        ...     print(result.output.narrative)
    """

    def __init__(
        self,
        *,
        default_model_label: ModelLabel = ModelLabel.FAST,
        force_mock: bool = False,
    ) -> None:
        """TurnOutputGenerator를 초기화합니다.

        Args:
            default_model_label: 기본 모델 라벨 (Q1 결정: FAST)
            force_mock: Mock 클라이언트 강제 사용 여부
        """
        self._default_model_label = default_model_label
        self._force_mock = force_mock
        self._json_schema: dict[str, Any] | None = None

    def _get_json_schema(self) -> dict[str, Any]:
        """TurnOutput JSON Schema를 반환합니다 (캐싱)."""
        if self._json_schema is None:
            self._json_schema = TurnOutput.model_json_schema()
        return self._json_schema

    def _build_prompt(
        self,
        turn_input: TurnInput,
        world_context: str = "",
    ) -> str:
        """전체 프롬프트를 구성합니다.

        Args:
            turn_input: 사용자 턴 입력
            world_context: 현재 세계 상태 요약 (선택)

        Returns:
            조합된 프롬프트 문자열
        """
        # 언어별 프롬프트 로드
        system_prompt = load_system_prompt(turn_input.language)
        turn_instructions = load_turn_instructions(turn_input.language)

        # 입력 정보 구성 (프롬프트에 포함)
        input_summary = f"""
## 현재 턴 입력

- language: {turn_input.language.value}
- text: "{turn_input.text}"
- action_id: {turn_input.action_id or "없음"}
- economy_snapshot:
  - signal: {turn_input.economy_snapshot.signal}
  - memory_shard: {turn_input.economy_snapshot.memory_shard}
"""

        # 세계 상태 컨텍스트 (있는 경우)
        world_section = ""
        if world_context:
            world_section = f"""
## 현재 세계 상태

{world_context}
"""

        # 전체 프롬프트 조합
        full_prompt = f"""{system_prompt}

---

{turn_instructions}

---

{input_summary}
{world_section}

---

위 지시에 따라 TurnOutput JSON을 생성하세요.
"""
        return full_prompt

    async def generate(
        self,
        turn_input: TurnInput,
        *,
        model_label: ModelLabel | None = None,
        world_context: str = "",
    ) -> GenerationResult:
        """TurnOutput을 생성합니다.

        Structured Outputs(JSON Schema) 모드로 Gemini를 호출하고,
        Pydantic으로 응답을 검증합니다.

        Args:
            turn_input: 사용자 턴 입력
            model_label: 사용할 모델 라벨 (None이면 기본값 FAST)
            world_context: 현재 세계 상태 요약 (선택)

        Returns:
            GenerationResult: 생성 결과 (status, output, error 등)
        """
        label = model_label or self._default_model_label

        # 로그에는 메타만 기록 (프롬프트 원문 금지 - RULE-007/008)
        logger.info(
            "[TurnOutputGenerator] 생성 요청",
            extra={
                "language": turn_input.language.value,
                "model_label": label,
                "has_text": bool(turn_input.text),
                "has_action_id": bool(turn_input.action_id),
            },
        )

        try:
            # GenAI 클라이언트 가져오기
            client = get_genai_client(force_mock=self._force_mock)

            # 프롬프트 구성
            prompt = self._build_prompt(turn_input, world_context)

            # Structured Outputs 요청 구성 (RULE-003)
            # SDK 레벨에서 JSON Schema를 강제하여 파싱 오류를 최소화합니다.
            json_schema = self._get_json_schema()
            request = GenerateRequest(
                prompt=prompt,
                model_label=label,
                temperature=0.7,  # 창의성 적당히
                response_mime_type="application/json",
                response_schema=json_schema,
            )

            # API 호출
            response = await client.generate(request)
            raw_text = response.text

            # Pydantic 검증 (model_validate_json 사용 - U-017 완료 기준)
            # Structured Outputs로 인해 응답이 이미 JSON이므로
            # 마크다운 코드블록 처리 후 직접 검증합니다.
            try:
                # 응답에서 JSON 부분 추출 (마크다운 코드블록 처리)
                json_text = self._extract_json(raw_text)

                # model_validate_json: JSON 문자열을 직접 파싱+검증 (U-017 완료 기준)
                turn_output = TurnOutput.model_validate_json(json_text)

                # 성공
                logger.info(
                    "[TurnOutputGenerator] 생성 성공",
                    extra={
                        "model_label": label,
                        "has_narrative": bool(turn_output.narrative),
                        "cost_signal": turn_output.economy.cost.signal,
                    },
                )

                return GenerationResult(
                    status=GenerationStatus.SUCCESS,
                    output=turn_output,
                    model_label=label,
                    raw_response=raw_text,
                )

            except ValidationError as e:
                # 스키마 검증 실패 (복구 대상 - U-018에서 처리)
                logger.warning(
                    "[TurnOutputGenerator] Pydantic 검증 실패 (복구 대상)",
                    extra={
                        "error_count": len(e.errors()),
                        "model_label": label,
                    },
                )
                return GenerationResult(
                    status=GenerationStatus.SCHEMA_FAILURE,
                    error_message="응답 형식이 올바르지 않습니다"
                    if turn_input.language == Language.KO
                    else "Invalid response format",
                    error_details={
                        "validation_errors": [
                            {"loc": err["loc"], "type": err["type"]} for err in e.errors()
                        ]
                    },
                    model_label=label,
                    raw_response=raw_text,
                )
            except json.JSONDecodeError as e:
                # JSON 파싱 실패 (복구 대상)
                logger.warning(
                    "[TurnOutputGenerator] JSON 파싱 실패 (복구 대상)",
                    extra={"error_type": "JSONDecodeError"},
                )
                return GenerationResult(
                    status=GenerationStatus.SCHEMA_FAILURE,
                    error_message="응답을 파싱할 수 없습니다"
                    if turn_input.language == Language.KO
                    else "Failed to parse response",
                    error_details={"json_error": str(e)},
                    model_label=label,
                    raw_response=raw_text,
                )

        except RuntimeError as e:
            # API 호출 실패
            logger.error(
                "[TurnOutputGenerator] API 호출 실패",
                extra={"error_type": type(e).__name__},
            )
            return GenerationResult(
                status=GenerationStatus.API_ERROR,
                error_message="서비스에 연결할 수 없습니다"
                if turn_input.language == Language.KO
                else "Unable to connect to service",
                error_details={"api_error": str(e)},
                model_label=label,
            )

        except Exception as e:
            # 예상치 못한 오류
            logger.exception(
                "[TurnOutputGenerator] 예상치 못한 오류",
                extra={"error_type": type(e).__name__},
            )
            return GenerationResult(
                status=GenerationStatus.API_ERROR,
                error_message="처리 중 오류가 발생했습니다"
                if turn_input.language == Language.KO
                else "An error occurred during processing",
                error_details={"unexpected_error": type(e).__name__},
                model_label=label,
            )

    def _extract_json(self, text: str) -> str:
        """응답 텍스트에서 JSON 부분을 추출합니다.

        마크다운 코드블록으로 감싸진 경우를 처리합니다.

        Args:
            text: 원본 응답 텍스트

        Returns:
            JSON 문자열
        """
        text = text.strip()

        # 마크다운 코드블록 처리 (```json ... ```)
        if text.startswith("```"):
            lines = text.split("\n")
            # 첫 줄(```json)과 마지막 줄(```) 제거
            if lines[0].startswith("```"):
                lines = lines[1:]
            if lines and lines[-1].strip() == "```":
                lines = lines[:-1]
            text = "\n".join(lines)

        return text.strip()

    def create_safe_fallback(
        self,
        language: Language,
        error_message: str,  # noqa: ARG002 - 하위 호환용 (실제로 사용하지 않음)
        economy_snapshot: CurrencyAmount | None = None,
    ) -> TurnOutput:
        """안전한 폴백 TurnOutput을 생성합니다.

        검증 실패 또는 에러 발생 시 사용합니다.
        (RULE-004: 안전한 폴백 제공)

        Note:
            이 메서드는 fallback.create_safe_fallback SSOT로 위임합니다 (RU-005-Q1).

        Args:
            language: 언어
            error_message: 에러 메시지 (하위 호환용, 실제 미사용)
            economy_snapshot: 현재 재화 상태 (비용 0으로 유지)

        Returns:
            안전한 폴백 TurnOutput
        """
        # RU-005-Q1: fallback SSOT로 위임
        return create_safe_fallback(
            language=language,
            economy_snapshot=economy_snapshot,
            repair_count=0,
            is_blocked=False,
        )


# =============================================================================
# 편의 함수
# =============================================================================

# 기본 생성기 인스턴스 (싱글톤)
_default_generator: TurnOutputGenerator | None = None


def get_turn_output_generator(
    *,
    force_mock: bool = False,
    force_new: bool = False,
) -> TurnOutputGenerator:
    """TurnOutputGenerator 인스턴스를 반환합니다.

    Args:
        force_mock: Mock 클라이언트 강제 사용 여부
        force_new: 새 인스턴스 생성 여부

    Returns:
        TurnOutputGenerator 인스턴스
    """
    global _default_generator

    if force_new or _default_generator is None or force_mock:
        _default_generator = TurnOutputGenerator(
            default_model_label=ModelLabel.FAST,  # Q1 결정: FAST 기본
            force_mock=force_mock,
        )

    return _default_generator


async def generate_turn_output(
    turn_input: TurnInput,
    *,
    model_label: ModelLabel | None = None,
    world_context: str = "",
    force_mock: bool = False,
) -> GenerationResult:
    """TurnOutput을 생성하는 편의 함수.

    Args:
        turn_input: 사용자 턴 입력
        model_label: 사용할 모델 라벨 (None이면 기본값 FAST)
        world_context: 현재 세계 상태 요약 (선택)
        force_mock: Mock 클라이언트 강제 사용 여부

    Returns:
        GenerationResult: 생성 결과

    Example:
        >>> result = await generate_turn_output(turn_input)
        >>> if result.status == GenerationStatus.SUCCESS:
        ...     print(result.output.narrative)
    """
    generator = get_turn_output_generator(force_mock=force_mock)
    return await generator.generate(
        turn_input,
        model_label=model_label,
        world_context=world_context,
    )
</file>

<file path="backend/src/unknown_world/orchestrator/stages/validate.py">
"""Unknown World - Validate Stage.

비즈니스 룰 검증 + Repair loop 단계입니다.
U-018의 run_repair_loop()를 호출해 output/badges/repair_count를 결정합니다.

설계 원칙:
    - RULE-003: 구조화 출력(JSON Schema) + 이중 검증
    - RULE-004: 검증 실패 시 Repair loop + 안전한 폴백
    - RULE-005: 재화 인바리언트 (잔액 음수 금지)
    - RULE-008: 단계/배지 가시화

참조:
    - vibe/refactors/RU-005-Q4.md
    - vibe/unit-plans/U-018[Mvp].md
"""

from __future__ import annotations

from unknown_world.models.turn import AgentPhase, Language, ValidationBadge
from unknown_world.orchestrator.fallback import create_safe_fallback
from unknown_world.orchestrator.mock import MockOrchestrator
from unknown_world.orchestrator.repair_loop import (
    MAX_REPAIR_ATTEMPTS,
    add_business_badges,
    run_repair_loop,
)
from unknown_world.orchestrator.stages.types import (
    EmitFn,
    PipelineContext,
    PipelineEvent,
    PipelineEventType,
)
from unknown_world.validation.business_rules import validate_business_rules


async def validate_stage(ctx: PipelineContext, *, emit: EmitFn) -> PipelineContext:
    """Validate 단계를 실행합니다.

    Mock 모드와 Real 모드를 구분하여 처리합니다.
    - Mock: MockOrchestrator로 생성 + 비즈니스 룰 검증
    - Real: run_repair_loop() 호출 (Gemini API + Repair loop)

    Args:
        ctx: 파이프라인 컨텍스트
        emit: 이벤트 emit 콜백

    Returns:
        업데이트된 컨텍스트 (output, badges, repair_attempts 포함)
    """
    ctx.current_phase = AgentPhase.VALIDATE

    # Stage 시작 이벤트
    await emit(
        PipelineEvent(
            event_type=PipelineEventType.STAGE_START,
            phase=AgentPhase.VALIDATE,
        )
    )

    try:
        if ctx.is_mock:
            await _validate_mock(ctx, emit)
        else:
            await _validate_real(ctx, emit)
    except Exception:
        # 예외 발생 시 폴백 (RULE-004, RU-005-S1)
        ctx.output = create_safe_fallback(
            language=ctx.turn_input.language,
            economy_snapshot=ctx.economy_snapshot,
            repair_count=ctx.repair_attempts,
        )
        ctx.is_fallback = True
        # RU-005-S1: 폴백의 배지를 스트림 이벤트와 동기화
        ctx.badges = list(ctx.output.agent_console.badges)

    # Stage 완료 이벤트
    await emit(
        PipelineEvent(
            event_type=PipelineEventType.STAGE_COMPLETE,
            phase=AgentPhase.VALIDATE,
        )
    )

    # 배지 이벤트 전송
    if ctx.badges:
        await emit(
            PipelineEvent(
                event_type=PipelineEventType.BADGES,
                badges=ctx.badges,
            )
        )

    return ctx


async def _validate_mock(ctx: PipelineContext, emit: EmitFn) -> None:
    """Mock 모드 검증을 수행합니다."""
    orchestrator = MockOrchestrator(seed=ctx.seed)
    repair_attempt = 0

    while repair_attempt <= MAX_REPAIR_ATTEMPTS:
        # 0회차는 정상 시도, 1회차부터는 repair
        if repair_attempt > 0:
            await emit(
                PipelineEvent(
                    event_type=PipelineEventType.REPAIR,
                    repair_attempt=repair_attempt,
                    repair_message=(
                        "검증 실패로 인해 다시 시도 중입니다..."
                        if ctx.turn_input.language == Language.KO
                        else "Retrying due to validation failure..."
                    ),
                )
            )
            ctx.repair_messages.append(
                "검증 실패로 인해 다시 시도 중입니다..."
                if ctx.turn_input.language == Language.KO
                else "Retrying due to validation failure..."
            )

        try:
            # Mock 생성
            turn_output = orchestrator.generate_turn_output(ctx.turn_input)

            # 비즈니스 룰 검증 (U-018)
            biz_result = validate_business_rules(ctx.turn_input, turn_output)
            if not biz_result.is_valid:
                # 비즈니스 룰 실패 → 재시도
                repair_attempt += 1
                ctx.repair_attempts = repair_attempt
                if repair_attempt > MAX_REPAIR_ATTEMPTS:
                    # 최종 실패 시 폴백 (RULE-004, RU-005-S1)
                    ctx.output = create_safe_fallback(
                        language=ctx.turn_input.language,
                        economy_snapshot=ctx.economy_snapshot,
                        repair_count=repair_attempt,
                    )
                    ctx.is_fallback = True
                    # RU-005-S1: 비즈니스 룰 실패 배지를 정확히 설정하고
                    # output과 ctx 배지를 동기화
                    failure_badges: list[ValidationBadge] = [ValidationBadge.SCHEMA_OK]
                    add_business_badges(biz_result, failure_badges)
                    ctx.output.agent_console.badges = failure_badges
                    ctx.badges = list(failure_badges)
                    return
                continue

            # 모든 검증 통과
            ctx.output = turn_output
            ctx.badges = [
                ValidationBadge.SCHEMA_OK,
                ValidationBadge.ECONOMY_OK,
                ValidationBadge.SAFETY_OK,
                ValidationBadge.CONSISTENCY_OK,
            ]
            ctx.repair_attempts = repair_attempt
            return

        except Exception:
            repair_attempt += 1
            ctx.repair_attempts = repair_attempt
            if repair_attempt > MAX_REPAIR_ATTEMPTS:
                # 최종 실패 시 폴백 (RULE-004, RU-005-S1)
                ctx.output = create_safe_fallback(
                    language=ctx.turn_input.language,
                    economy_snapshot=ctx.economy_snapshot,
                    repair_count=repair_attempt,
                )
                ctx.is_fallback = True
                # RU-005-S1: 폴백의 배지를 스트림 이벤트와 동기화
                ctx.badges = list(ctx.output.agent_console.badges)
                return
            continue

    # 루프 종료 시에도 폴백 (RU-005-S1)
    ctx.output = create_safe_fallback(
        language=ctx.turn_input.language,
        economy_snapshot=ctx.economy_snapshot,
        repair_count=repair_attempt,
    )
    ctx.is_fallback = True
    # RU-005-S1: 폴백의 배지를 스트림 이벤트와 동기화
    ctx.badges = list(ctx.output.agent_console.badges)


async def _validate_real(ctx: PipelineContext, emit: EmitFn) -> None:
    """Real 모드 검증을 수행합니다 (Gemini API + Repair loop)."""
    result = await run_repair_loop(ctx.turn_input)

    # Repair 이벤트 송출 (시도가 있었다면)
    for i in range(result.repair_attempts):
        message = result.error_messages[i] if i < len(result.error_messages) else ""
        await emit(
            PipelineEvent(
                event_type=PipelineEventType.REPAIR,
                repair_attempt=i + 1,
                repair_message=message[:100] if message else None,
            )
        )
        if message:
            ctx.repair_messages.append(message[:100])

    ctx.output = result.output
    ctx.badges = list(result.badges)
    ctx.repair_attempts = result.repair_attempts
    ctx.is_fallback = result.is_fallback
</file>

<file path="backend/src/unknown_world/services/__init__.py">
"""Unknown World - 서비스 레이어 패키지.

이 패키지는 외부 서비스와의 통신을 담당하는 모듈을 관리합니다.
GenAI 클라이언트, 이미지 생성기, 스토리지 클라이언트 등이 포함됩니다.

참조:
    - vibe/tech-stack.md (google-genai 버전, Vertex AI 인증)
    - .cursor/rules/20-backend-orchestrator.mdc (Vertex 인증/비밀정보 금지)
"""

from unknown_world.services.genai_client import (
    GenAIClient,
    GenAIClientType,
    GenAIMode,
    GenerateRequest,
    GenerateResponse,
    MockGenAIClient,
    get_genai_client,
    reset_genai_client,
)
from unknown_world.services.image_generation import (
    ImageGenerationRequest,
    ImageGenerationResponse,
    ImageGenerationStatus,
    ImageGenerator,
    ImageGeneratorType,
    MockImageGenerator,
    create_fallback_response,
    get_image_generator,
    reset_image_generator,
)

__all__ = [
    # GenAI 클라이언트
    "GenAIClient",
    "GenAIClientType",
    "GenAIMode",
    "GenerateRequest",
    "GenerateResponse",
    "MockGenAIClient",
    "get_genai_client",
    "reset_genai_client",
    # 이미지 생성 (U-019)
    "ImageGenerationRequest",
    "ImageGenerationResponse",
    "ImageGenerationStatus",
    "ImageGenerator",
    "ImageGeneratorType",
    "MockImageGenerator",
    "create_fallback_response",
    "get_image_generator",
    "reset_image_generator",
]
</file>

<file path="backend/src/unknown_world/services/image_postprocess.py">
"""Unknown World - 이미지 후처리 서비스 (rembg 배경 제거).

이 모듈은 rembg를 사용하여 생성된 이미지의 배경을 제거하는 후처리 서비스입니다.
이미지 유형 힌트에 따라 최적의 모델을 자동 선택합니다.

설계 원칙:
    - RULE-004: 실패 시 안전한 폴백 제공 (원본 이미지 반환)
    - RULE-008: 텍스트 우선 + Lazy 이미지 원칙
    - Q1 결정: Option A (동기 처리)
    - Q2 결정: Option B (힌트 기반 자동 모델 선택)
    - U-045: preflight 상태 참조 → 미준비 시 즉시 원본 반환 (요청 중 다운로드 차단)

참조:
    - vibe/ref/rembg-guide.md (모델 선택/옵션 가이드 SSOT)
    - vibe/unit-plans/U-035[Mvp].md
    - vibe/unit-plans/U-045[Mvp].md
    - vibe/tech-stack.md (rembg 버전 고정)
"""

from __future__ import annotations

import hashlib
import logging
import subprocess
from dataclasses import dataclass
from datetime import UTC, datetime
from enum import StrEnum
from pathlib import Path

from pydantic import BaseModel, ConfigDict, Field

from unknown_world.services.rembg_preflight import is_rembg_available as preflight_is_available

# =============================================================================
# 로거 설정
# =============================================================================

logger = logging.getLogger(__name__)


# =============================================================================
# 상수 정의 (rembg-guide.md 기준)
# =============================================================================


class RembgModel(StrEnum):
    """rembg 지원 모델 (vibe/ref/rembg-guide.md 기준).

    모델 선택 우선순위:
    1. 사용자가 모델 명시 → 해당 모델 사용
    2. UI 아이콘/로고/픽셀 아트 → birefnet-general
    3. 제품/오브젝트/일반 사물 → birefnet-general
    4. 실사 인물/사진 → birefnet-portrait + -a
    5. 일본 애니메이션 스타일 캐릭터 → isnet-anime
    6. 속도 우선 → u2netp
    7. 불명확 → birefnet-general (기본값)
    """

    # 범용/기본
    BIREFNET_GENERAL = "birefnet-general"
    """제품/오브젝트/UI 아이콘/일반 (기본값)"""

    ISNET_GENERAL_USE = "isnet-general-use"
    """범용/개선된 품질"""

    # 인물
    BIREFNET_PORTRAIT = "birefnet-portrait"
    """실사 인물 초상화/셀카/프로필"""

    U2NET_HUMAN_SEG = "u2net_human_seg"
    """인물 전신/단체 사진"""

    # 캐릭터/일러스트
    ISNET_ANIME = "isnet-anime"
    """일본 애니메이션 캐릭터 (명확한 경우만)"""

    # 특수
    BIREFNET_DIS = "birefnet-dis"
    """복잡한 배경/고해상도"""

    BIREFNET_MASSIVE = "birefnet-massive"
    """최고 품질 필요"""

    U2NET_CLOTH_SEG = "u2net_cloth_seg"
    """의류/패션/옷"""

    # 속도/경량
    U2NETP = "u2netp"
    """속도 우선/대량 처리"""

    SILUETA = "silueta"
    """경량/저사양"""


# 이미지 유형 → 모델 매핑 (rembg-guide.md 기준)
IMAGE_TYPE_MODEL_MAP: dict[str, tuple[RembgModel, bool]] = {
    # (모델, alpha_matting 사용 여부)
    "icon": (RembgModel.BIREFNET_GENERAL, False),
    "logo": (RembgModel.BIREFNET_GENERAL, False),
    "pixel_art": (RembgModel.BIREFNET_GENERAL, False),
    "ui": (RembgModel.BIREFNET_GENERAL, False),
    "asset": (RembgModel.BIREFNET_GENERAL, False),
    "object": (RembgModel.BIREFNET_GENERAL, False),
    "product": (RembgModel.BIREFNET_GENERAL, False),
    "item": (RembgModel.BIREFNET_GENERAL, False),
    "character": (RembgModel.ISNET_ANIME, False),
    "anime": (RembgModel.ISNET_ANIME, False),
    "illustration": (RembgModel.ISNET_ANIME, False),
    "portrait": (RembgModel.BIREFNET_PORTRAIT, True),
    "selfie": (RembgModel.BIREFNET_PORTRAIT, True),
    "human": (RembgModel.U2NET_HUMAN_SEG, True),
    "person": (RembgModel.U2NET_HUMAN_SEG, True),
    "clothing": (RembgModel.U2NET_CLOTH_SEG, False),
    "fashion": (RembgModel.U2NET_CLOTH_SEG, False),
    "complex": (RembgModel.BIREFNET_DIS, False),
    "detailed": (RembgModel.BIREFNET_DIS, False),
    "best_quality": (RembgModel.BIREFNET_MASSIVE, False),
    "fast": (RembgModel.U2NETP, False),
}

# 기본 설정
DEFAULT_MODEL = RembgModel.BIREFNET_GENERAL
DEFAULT_ALPHA_MATTING = False


# =============================================================================
# 결과 타입 정의
# =============================================================================


class BackgroundRemovalStatus(StrEnum):
    """배경 제거 상태."""

    SUCCESS = "success"
    """배경 제거 성공"""

    FAILED = "failed"
    """배경 제거 실패 (원본 반환)"""

    SKIPPED = "skipped"
    """배경 제거 건너뜀 (비활성화)"""


class BackgroundRemovalResult(BaseModel):
    """배경 제거 결과.

    Attributes:
        status: 처리 상태
        output_path: 출력 파일 경로 (성공/실패 시 모두 존재)
        original_path: 원본 파일 경로
        model_used: 사용된 rembg 모델
        alpha_matting: alpha matting 사용 여부
        processing_time_ms: 처리 시간 (밀리초)
        message: 상태 메시지
    """

    model_config = ConfigDict(extra="forbid")

    status: BackgroundRemovalStatus
    output_path: Path
    original_path: Path
    model_used: str | None = Field(default=None)
    alpha_matting: bool = Field(default=False)
    processing_time_ms: int = Field(default=0)
    message: str | None = Field(default=None)


@dataclass
class RembgConfig:
    """rembg 처리 설정.

    Attributes:
        model: 사용할 모델
        alpha_matting: alpha matting 사용 여부
        output_suffix: 출력 파일 접미사
    """

    model: RembgModel = DEFAULT_MODEL
    alpha_matting: bool = DEFAULT_ALPHA_MATTING
    output_suffix: str = "_nobg"


# =============================================================================
# 헬퍼 함수
# =============================================================================


def select_model_from_hint(image_type_hint: str | None) -> tuple[RembgModel, bool]:
    """이미지 유형 힌트로부터 최적의 rembg 모델을 선택합니다.

    Args:
        image_type_hint: 이미지 유형 힌트 (예: "object", "character", "icon")

    Returns:
        (모델, alpha_matting 사용 여부) 튜플
    """
    if not image_type_hint:
        return DEFAULT_MODEL, DEFAULT_ALPHA_MATTING

    # 힌트를 소문자로 정규화
    hint_lower = image_type_hint.lower().strip()

    # 직접 매칭
    if hint_lower in IMAGE_TYPE_MODEL_MAP:
        return IMAGE_TYPE_MODEL_MAP[hint_lower]

    # 키워드 포함 검색
    for keyword, (model, alpha) in IMAGE_TYPE_MODEL_MAP.items():
        if keyword in hint_lower:
            return model, alpha

    # 기본값 반환
    logger.debug(
        "[Rembg] 알 수 없는 이미지 유형, 기본 모델 사용",
        extra={"hint": image_type_hint, "default_model": DEFAULT_MODEL},
    )
    return DEFAULT_MODEL, DEFAULT_ALPHA_MATTING


def _create_output_path(input_path: Path, suffix: str = "_nobg") -> Path:
    """출력 파일 경로를 생성합니다.

    Args:
        input_path: 입력 파일 경로
        suffix: 파일명 접미사

    Returns:
        출력 파일 경로
    """
    stem = input_path.stem
    return input_path.parent / f"{stem}{suffix}.png"


# =============================================================================
# 메인 서비스 클래스
# =============================================================================


class ImagePostprocessor:
    """이미지 후처리 서비스 (rembg 배경 제거).

    rembg CLI를 사용하여 이미지 배경을 제거합니다.
    실패 시 원본 이미지를 반환하는 안전 폴백을 제공합니다 (RULE-004).
    """

    def __init__(self, timeout_seconds: int = 60) -> None:
        """ImagePostprocessor를 초기화합니다.

        Args:
            timeout_seconds: rembg 실행 타임아웃 (초)
        """
        self._timeout = timeout_seconds
        self._available: bool | None = None

    def is_available(self) -> bool:
        """rembg가 시스템에 설치되어 있는지 확인합니다."""
        if self._available is not None:
            return self._available

        try:
            result = subprocess.run(
                ["rembg", "--version"],
                capture_output=True,
                text=True,
                timeout=5,
            )
            self._available = result.returncode == 0
            if self._available:
                logger.info(
                    "[Rembg] rembg 사용 가능",
                    extra={"version": result.stdout.strip()},
                )
            else:
                logger.warning("[Rembg] rembg 버전 확인 실패")
        except FileNotFoundError:
            logger.warning("[Rembg] rembg가 설치되어 있지 않습니다")
            self._available = False
        except Exception as e:
            logger.warning(
                "[Rembg] rembg 확인 중 오류",
                extra={"error_type": type(e).__name__},
            )
            self._available = False

        return self._available

    def remove_background(
        self,
        input_path: Path,
        image_type_hint: str | None = None,
        output_path: Path | None = None,
        config: RembgConfig | None = None,
    ) -> BackgroundRemovalResult:
        """이미지의 배경을 제거합니다.

        Args:
            input_path: 입력 이미지 파일 경로
            image_type_hint: 이미지 유형 힌트 (모델 자동 선택용)
            output_path: 출력 파일 경로 (기본: 입력파일_nobg.png)
            config: rembg 설정 (힌트 대신 직접 설정할 때 사용)

        Returns:
            BackgroundRemovalResult: 처리 결과
        """
        start_time = datetime.now(UTC)

        # 입력 파일 존재 확인
        if not input_path.exists():
            return BackgroundRemovalResult(
                status=BackgroundRemovalStatus.FAILED,
                output_path=input_path,
                original_path=input_path,
                message=f"입력 파일이 존재하지 않습니다: {input_path}",
            )

        # 출력 경로 설정
        if output_path is None:
            output_path = _create_output_path(input_path)

        # 모델/옵션 결정
        if config is not None:
            model = config.model
            alpha_matting = config.alpha_matting
        else:
            model, alpha_matting = select_model_from_hint(image_type_hint)

        # U-045: preflight 상태 확인 (요청 중 다운로드 차단)
        # preflight가 실패/미완료인 경우 즉시 원본 반환
        if not preflight_is_available():
            logger.warning(
                "[Rembg] preflight 미완료 또는 실패, 원본 이미지 사용 (요청 중 다운로드 방지)"
            )
            import shutil

            shutil.copy(input_path, output_path)
            return BackgroundRemovalResult(
                status=BackgroundRemovalStatus.FAILED,
                output_path=output_path,
                original_path=input_path,
                message="rembg preflight가 완료되지 않았습니다. 원본 이미지를 사용합니다.",
            )

        # rembg 사용 가능 여부 확인 (CLI 실행 가능 여부)
        if not self.is_available():
            # 폴백: 원본 복사
            logger.warning("[Rembg] rembg 미설치, 원본 이미지 사용")
            import shutil

            shutil.copy(input_path, output_path)
            return BackgroundRemovalResult(
                status=BackgroundRemovalStatus.FAILED,
                output_path=output_path,
                original_path=input_path,
                message="rembg가 설치되어 있지 않습니다. 원본 이미지를 사용합니다.",
            )

        # 로그용 해시 생성 (파일명 노출 최소화)
        path_hash = hashlib.sha256(str(input_path).encode()).hexdigest()[:8]

        logger.debug(
            "[Rembg] 배경 제거 시작",
            extra={
                "path_hash": path_hash,
                "model": model,
                "alpha_matting": alpha_matting,
            },
        )

        try:
            # rembg CLI 명령어 구성
            cmd = ["rembg", "i", "-m", model]
            if alpha_matting:
                cmd.append("-a")
            cmd.extend([str(input_path), str(output_path)])

            # rembg 실행
            result = subprocess.run(
                cmd,
                capture_output=True,
                text=True,
                timeout=self._timeout,
            )

            elapsed_ms = int((datetime.now(UTC) - start_time).total_seconds() * 1000)

            if result.returncode == 0 and output_path.exists():
                # 파일 크기 측정 (실패 시 0)
                try:
                    output_size = output_path.stat().st_size
                except Exception:
                    output_size = 0

                logger.info(
                    "[Rembg] 배경 제거 완료",
                    extra={
                        "path_hash": path_hash,
                        "model": model,
                        "elapsed_ms": elapsed_ms,
                        "output_size": output_size,
                    },
                )
                return BackgroundRemovalResult(
                    status=BackgroundRemovalStatus.SUCCESS,
                    output_path=output_path,
                    original_path=input_path,
                    model_used=model,
                    alpha_matting=alpha_matting,
                    processing_time_ms=elapsed_ms,
                    message="배경이 성공적으로 제거되었습니다.",
                )
            else:
                # 실패 시 원본 복사 (폴백)
                logger.warning(
                    "[Rembg] 배경 제거 실패, 원본 사용",
                    extra={
                        "path_hash": path_hash,
                        "returncode": result.returncode,
                        "stderr": result.stderr[:200] if result.stderr else None,
                    },
                )
                import shutil

                shutil.copy(input_path, output_path)
                return BackgroundRemovalResult(
                    status=BackgroundRemovalStatus.FAILED,
                    output_path=output_path,
                    original_path=input_path,
                    model_used=model,
                    processing_time_ms=elapsed_ms,
                    message=f"rembg 실행 실패. 원본 이미지를 사용합니다. (exit: {result.returncode})",
                )

        except subprocess.TimeoutExpired:
            elapsed_ms = int((datetime.now(UTC) - start_time).total_seconds() * 1000)
            logger.error(
                "[Rembg] 배경 제거 타임아웃",
                extra={"path_hash": path_hash, "timeout": self._timeout},
            )
            # 폴백: 원본 복사
            import shutil

            shutil.copy(input_path, output_path)
            return BackgroundRemovalResult(
                status=BackgroundRemovalStatus.FAILED,
                output_path=output_path,
                original_path=input_path,
                model_used=model,
                processing_time_ms=elapsed_ms,
                message=f"rembg 실행 타임아웃 ({self._timeout}초). 원본 이미지를 사용합니다.",
            )

        except Exception as e:
            elapsed_ms = int((datetime.now(UTC) - start_time).total_seconds() * 1000)
            error_type = type(e).__name__
            logger.exception(
                "[Rembg] 배경 제거 중 오류",
                extra={"path_hash": path_hash, "error_type": error_type},
            )
            # 폴백: 원본 복사
            import shutil

            try:
                shutil.copy(input_path, output_path)
            except Exception:
                output_path = input_path

            return BackgroundRemovalResult(
                status=BackgroundRemovalStatus.FAILED,
                output_path=output_path,
                original_path=input_path,
                processing_time_ms=elapsed_ms,
                message=f"배경 제거 중 오류가 발생했습니다: {error_type}. 원본 이미지를 사용합니다.",
            )


# =============================================================================
# 싱글톤 인스턴스
# =============================================================================

_postprocessor_instance: ImagePostprocessor | None = None


def get_image_postprocessor() -> ImagePostprocessor:
    """ImagePostprocessor 싱글톤 인스턴스를 반환합니다."""
    global _postprocessor_instance
    if _postprocessor_instance is None:
        _postprocessor_instance = ImagePostprocessor()
    return _postprocessor_instance


def reset_image_postprocessor() -> None:
    """테스트용 싱글톤 리셋."""
    global _postprocessor_instance
    _postprocessor_instance = None


# =============================================================================
# 편의 함수
# =============================================================================


async def remove_background_if_needed(
    image_path: Path,
    remove_background: bool,
    image_type_hint: str | None = None,
) -> Path:
    """조건부 배경 제거를 수행하고 결과 경로를 반환합니다.

    Args:
        image_path: 이미지 파일 경로
        remove_background: 배경 제거 수행 여부
        image_type_hint: 이미지 유형 힌트

    Returns:
        처리된 이미지 파일 경로 (배경 제거 안 함 시 원본 경로)
    """
    if not remove_background:
        return image_path

    postprocessor = get_image_postprocessor()
    result = postprocessor.remove_background(
        input_path=image_path,
        image_type_hint=image_type_hint,
    )

    # 성공/실패 모두 output_path 반환 (폴백 포함)
    return result.output_path
</file>

<file path="backend/src/unknown_world/validation/__init__.py">
"""Unknown World - 검증 모듈.

비즈니스 룰 검증기 및 언어 혼합 검증 게이트를 제공합니다.
"""

from unknown_world.validation.business_rules import (
    BusinessRuleError,
    BusinessRuleValidationResult,
    validate_business_rules,
)
from unknown_world.validation.language_gate import (
    MIXED_THRESHOLD_RATIO,
    LanguageGateResult,
    LanguageRatio,
    build_language_error_summary,
    is_language_mixed,
    measure_language_ratio,
    validate_language_consistency,
)

__all__ = [
    # Business Rules
    "BusinessRuleError",
    "BusinessRuleValidationResult",
    "validate_business_rules",
    # Language Gate (U-043)
    "MIXED_THRESHOLD_RATIO",
    "LanguageGateResult",
    "LanguageRatio",
    "build_language_error_summary",
    "is_language_mixed",
    "measure_language_ratio",
    "validate_language_consistency",
]
</file>

<file path="backend/tests/unit/orchestrator/test_prompt_loader.py">
"""Unit tests for prompt_loader.py.

U-036: 프롬프트 로더 핫리로드 테스트
U-046: XML 태그 파싱 + 레거시 폴백 테스트
"""

from __future__ import annotations

import os
import unittest

from unknown_world.models.turn import Language
from unknown_world.orchestrator.prompt_loader import (
    _parse_frontmatter,
    _parse_legacy_frontmatter,
    _parse_xml_meta,
    clear_prompt_cache,
    is_hot_reload_enabled,
    load_prompt,
    load_prompt_with_metadata,
)


class TestPromptLoader(unittest.TestCase):
    def setUp(self) -> None:
        # Clear cache before each test
        clear_prompt_cache()
        # Backup environment
        self._old_env = os.environ.get("ENVIRONMENT")

    def tearDown(self) -> None:
        # Restore environment
        if self._old_env is None:
            if "ENVIRONMENT" in os.environ:
                del os.environ["ENVIRONMENT"]
        else:
            os.environ["ENVIRONMENT"] = self._old_env
        # Clear cache
        clear_prompt_cache()

    def test_load_prompt_ko(self) -> None:
        """Verify loading Korean prompt."""
        # This assumes the file exists in backend/prompts/system/game_master.ko.md
        prompt = load_prompt("system", "game_master", Language.KO)
        self.assertGreater(len(prompt), 0)
        self.assertIn("#", prompt)  # Should be markdown

    def test_load_prompt_en(self) -> None:
        """Verify loading English prompt."""
        prompt = load_prompt("system", "game_master", Language.EN)
        self.assertGreater(len(prompt), 0)

    def test_load_with_metadata(self) -> None:
        """Verify frontmatter parsing."""
        data = load_prompt_with_metadata("system", "game_master", Language.KO)
        self.assertIsNotNone(data.content)
        self.assertIsInstance(data.metadata, dict)
        # Check for typical metadata fields if they exist in the file
        if "prompt_id" in data.metadata:
            self.assertGreater(len(data.metadata["prompt_id"]), 0)

    def test_hot_reload_development(self) -> None:
        """Verify hot-reload works in development mode."""
        os.environ["ENVIRONMENT"] = "development"
        self.assertTrue(is_hot_reload_enabled())

        # Use a temporary file to test hot-reload
        test_category = "system"
        test_name = "test_hot_reload"
        test_lang = Language.KO

        # Determine prompt path
        # In prompt_loader.py, _PROMPTS_ROOT is Path(__file__).parent.parent.parent.parent / "prompts"
        # Since we are in tests/unit/orchestrator/, we need to find the prompts root.
        # But let's mock _get_prompt_path or just use an existing one if possible.
        # Actually, creating a real file is better for verifying "hot-reload" of file system.

        from unknown_world.orchestrator.prompt_loader import _PROMPTS_ROOT

        test_dir = _PROMPTS_ROOT / test_category
        test_dir.mkdir(parents=True, exist_ok=True)
        test_file = test_dir / f"{test_name}.ko.md"

        try:
            # Initial content
            test_file.write_text("# Test\n\nContent 1", encoding="utf-8")

            p1 = load_prompt(test_category, test_name, test_lang)
            self.assertIn("Content 1", p1)

            # Modify file
            test_file.write_text("# Test\n\nContent 2", encoding="utf-8")

            # Load again - should be updated in dev mode
            p2 = load_prompt(test_category, test_name, test_lang)
            self.assertIn("Content 2", p2)
            self.assertNotEqual(p1, p2)

        finally:
            if test_file.exists():
                test_file.unlink()

    def test_caching_production(self) -> None:
        """Verify caching works in production mode (no hot-reload)."""
        os.environ["ENVIRONMENT"] = "production"
        self.assertFalse(is_hot_reload_enabled())

        test_category = "system"
        test_name = "test_caching"
        test_lang = Language.KO

        from unknown_world.orchestrator.prompt_loader import _PROMPTS_ROOT

        test_dir = _PROMPTS_ROOT / test_category
        test_dir.mkdir(parents=True, exist_ok=True)
        test_file = test_dir / f"{test_name}.ko.md"

        try:
            # Initial content
            test_file.write_text("# Test\n\nInitial", encoding="utf-8")

            p1 = load_prompt(test_category, test_name, test_lang)
            self.assertIn("Initial", p1)

            # Modify file
            test_file.write_text("# Test\n\nModified", encoding="utf-8")

            # Load again - should STILL be Initial because of caching
            p2 = load_prompt(test_category, test_name, test_lang)
            self.assertEqual(p1, p2)
            self.assertIn("Initial", p2)

            # After clearing cache, it should be updated
            clear_prompt_cache()
            p3 = load_prompt(test_category, test_name, test_lang)
            self.assertIn("Modified", p3)

        finally:
            if test_file.exists():
                test_file.unlink()

    def test_fallback_language(self) -> None:
        """Verify fallback to other language if requested file is missing."""
        # Create ONLY English version
        test_category = "system"
        test_name = "test_fallback"

        from unknown_world.orchestrator.prompt_loader import _PROMPTS_ROOT

        test_dir = _PROMPTS_ROOT / test_category
        test_dir.mkdir(parents=True, exist_ok=True)
        en_file = test_dir / f"{test_name}.en.md"
        ko_file = test_dir / f"{test_name}.ko.md"

        try:
            en_file.write_text("# English Content", encoding="utf-8")
            if ko_file.exists():
                ko_file.unlink()

            # Request KO, should get EN
            prompt = load_prompt(test_category, test_name, Language.KO)
            self.assertIn("English Content", prompt)

        finally:
            if en_file.exists():
                en_file.unlink()


class TestXmlParsing(unittest.TestCase):
    """U-046: XML 태그 파싱 테스트."""

    def test_parse_xml_meta_valid(self) -> None:
        """Valid XML meta tags should be parsed correctly."""
        text = """<prompt_meta>
  <prompt_id>test_prompt</prompt_id>
  <language>ko-KR</language>
  <version>0.2.0</version>
  <last_updated>2026-01-28</last_updated>
  <policy_preset>default</policy_preset>
</prompt_meta>

<prompt_body>
## 목적
테스트 프롬프트입니다.

## 내용
본문 내용이 여기에 들어갑니다.
</prompt_body>
"""
        result = _parse_xml_meta(text)
        self.assertIsNotNone(result)
        metadata, content = result  # type: ignore

        # 메타데이터 검증
        self.assertEqual(metadata["prompt_id"], "test_prompt")
        self.assertEqual(metadata["language"], "ko-KR")
        self.assertEqual(metadata["version"], "0.2.0")
        self.assertEqual(metadata["last_updated"], "2026-01-28")
        self.assertEqual(metadata["policy_preset"], "default")

        # 본문 검증 (메타 블록 제외)
        self.assertIn("## 목적", content)
        self.assertIn("테스트 프롬프트입니다.", content)
        self.assertNotIn("<prompt_meta>", content)
        self.assertNotIn("<prompt_body>", content)

    def test_parse_xml_meta_no_body_tag(self) -> None:
        """XML meta without body tag should use remaining text as content."""
        text = """<prompt_meta>
  <prompt_id>test</prompt_id>
  <version>0.1.0</version>
</prompt_meta>

## Content Section
This is the content without body tag.
"""
        result = _parse_xml_meta(text)
        self.assertIsNotNone(result)
        metadata, content = result  # type: ignore

        self.assertEqual(metadata["prompt_id"], "test")
        self.assertIn("## Content Section", content)

    def test_parse_xml_meta_returns_none_for_legacy(self) -> None:
        """Legacy format should return None from _parse_xml_meta."""
        text = """# [Prompt] Test

- prompt_id: legacy_test
- version: 0.1.0

## Content
Legacy content here.
"""
        result = _parse_xml_meta(text)
        self.assertIsNone(result)

    def test_parse_legacy_frontmatter(self) -> None:
        """Legacy frontmatter should be parsed correctly."""
        text = """# [Prompt] Test

- prompt_id: legacy_test
- language: en-US
- version: 0.1.0

## Content
Legacy content here.
"""
        metadata, content = _parse_legacy_frontmatter(text)

        self.assertEqual(metadata["prompt_id"], "legacy_test")
        self.assertEqual(metadata["language"], "en-US")
        self.assertEqual(metadata["version"], "0.1.0")
        self.assertIn("## Content", content)
        self.assertIn("Legacy content here.", content)

    def test_parse_frontmatter_prefers_xml(self) -> None:
        """_parse_frontmatter should prefer XML format when available."""
        xml_text = """<prompt_meta>
  <prompt_id>xml_test</prompt_id>
  <version>0.2.0</version>
</prompt_meta>

<prompt_body>
## XML Content
This is XML format.
</prompt_body>
"""
        metadata, content = _parse_frontmatter(xml_text)

        self.assertEqual(metadata["prompt_id"], "xml_test")
        self.assertEqual(metadata["version"], "0.2.0")
        self.assertIn("## XML Content", content)

    def test_parse_frontmatter_fallback_to_legacy(self) -> None:
        """_parse_frontmatter should fallback to legacy when XML is missing."""
        legacy_text = """# [Prompt] Test

- prompt_id: fallback_test
- version: 0.1.0

## Content
Fallback content.
"""
        metadata, content = _parse_frontmatter(legacy_text)

        self.assertEqual(metadata["prompt_id"], "fallback_test")
        self.assertIn("## Content", content)

    def test_load_prompt_with_xml_metadata(self) -> None:
        """Integration test: load_prompt_with_metadata with XML format."""
        # Load actual prompt file (migrated to XML format)
        data = load_prompt_with_metadata("system", "game_master", Language.KO)

        self.assertIsNotNone(data.content)
        self.assertIsInstance(data.metadata, dict)

        # Check metadata fields
        self.assertEqual(data.metadata.get("prompt_id"), "game_master_system")
        self.assertEqual(data.metadata.get("language"), "ko-KR")
        self.assertIn("version", data.metadata)

        # Content should not contain meta tags
        self.assertNotIn("<prompt_meta>", data.content)
        self.assertNotIn("<prompt_body>", data.content)
        self.assertIn("## 목적", data.content)

    def test_load_prompt_with_xml_metadata_en(self) -> None:
        """Integration test: English XML format."""
        data = load_prompt_with_metadata("system", "game_master", Language.EN)

        self.assertEqual(data.metadata.get("prompt_id"), "game_master_system")
        self.assertEqual(data.metadata.get("language"), "en-US")
        self.assertIn("## Purpose", data.content)


if __name__ == "__main__":
    unittest.main()
</file>

<file path="backend/tests/unit/services/test_genai_client.py">
import os
from unittest.mock import AsyncMock, MagicMock, patch

import pytest

from unknown_world.config.models import (
    MODEL_FAST,
    MODEL_IMAGE,
    MODEL_QUALITY,
    MODEL_VISION,
    ModelLabel,
    get_model_id,
)
from unknown_world.services.genai_client import (
    ENV_UW_MODE,
    GenAIClient,
    GenAIMode,
    GenerateRequest,
    GenerateResponse,
    MockGenAIClient,
    get_genai_client,
    reset_genai_client,
)


def test_model_id_mapping():
    """ModelLabel이 tech-stack.md의 ID와 올바르게 매핑되는지 확인합니다."""
    assert get_model_id(ModelLabel.FAST) == MODEL_FAST
    assert get_model_id(ModelLabel.QUALITY) == MODEL_QUALITY
    assert get_model_id(ModelLabel.IMAGE) == MODEL_IMAGE
    assert get_model_id(ModelLabel.VISION) == MODEL_VISION

    assert MODEL_FAST == "gemini-3-flash-preview"
    assert MODEL_QUALITY == "gemini-3-pro-preview"
    assert MODEL_IMAGE == "gemini-3-pro-image-preview"


def test_get_genai_client_mock_mode():
    """UW_MODE=mock일 때 MockGenAIClient가 반환되는지 확인합니다."""
    reset_genai_client()
    with patch.dict(os.environ, {ENV_UW_MODE: "mock"}):
        client = get_genai_client(force_new=True)
        assert isinstance(client, MockGenAIClient)
        assert client.mode == GenAIMode.MOCK


@pytest.mark.asyncio
async def test_mock_client_generate():
    """MockGenAIClient의 generate 메서드 동작을 확인합니다."""
    client = MockGenAIClient()
    request = GenerateRequest(prompt="test prompt", model_label=ModelLabel.FAST)
    response = await client.generate(request)

    assert isinstance(response, GenerateResponse)
    assert "[Mock Response]" in response.text
    assert response.model_label == ModelLabel.FAST
    assert "total_tokens" in response.usage


@pytest.mark.asyncio
async def test_mock_client_generate_stream():
    """MockGenAIClient의 generate_stream 메서드 동작을 확인합니다."""
    client = MockGenAIClient()
    request = GenerateRequest(prompt="test prompt", model_label=ModelLabel.QUALITY)

    chunks = []
    async for chunk in client.generate_stream(request):
        chunks.append(chunk)

    assert len(chunks) > 0
    assert any(ModelLabel.QUALITY in c for c in chunks)


def test_singleton_pattern():
    """get_genai_client가 싱글톤으로 동작하는지 확인합니다."""
    reset_genai_client()
    with patch.dict(os.environ, {ENV_UW_MODE: "mock"}):
        client1 = get_genai_client()
        client2 = get_genai_client()
        assert client1 is client2


def test_genai_client_initialization():
    """GenAIClient(real)가 SDK를 올바르게 초기화하는지 확인합니다."""
    with patch("google.genai.Client") as mock_genai_client:
        # VERTEX_PROJECT와 LOCATION 설정
        project = "test-project"
        location = "global"

        client = GenAIClient(project=project, location=location)

        # genai.Client가 vertexai=True와 함께 호출되었는지 확인
        mock_genai_client.assert_called_once()
        args, kwargs = mock_genai_client.call_args
        assert kwargs["vertexai"] is True
        assert kwargs["project"] == project
        assert kwargs["location"] == location
        assert client.is_available() is True


@pytest.mark.asyncio
async def test_genai_client_generate_real_call():
    """GenAIClient가 SDK의 generate_content를 올바르게 호출하는지 확인합니다."""
    with patch("google.genai.Client") as mock_client_class:
        mock_instance = mock_client_class.return_value
        # mock aio.models.generate_content
        mock_response = MagicMock()
        mock_response.text = "Actual response"
        mock_response.candidates = [MagicMock(finish_reason="STOP")]
        mock_response.usage_metadata = MagicMock(
            prompt_token_count=10, candidates_token_count=20, total_token_count=30
        )

        mock_instance.aio.models.generate_content = AsyncMock(return_value=mock_response)

        client = GenAIClient(project="p", location="l")
        request = GenerateRequest(prompt="hello", model_label=ModelLabel.QUALITY, max_tokens=100)

        response = await client.generate(request)

        # 호출 인자 확인
        mock_instance.aio.models.generate_content.assert_called_once_with(
            model=MODEL_QUALITY, contents="hello", config={"max_output_tokens": 100}
        )
        assert response.text == "Actual response"
        assert response.usage["total_tokens"] == 30


def test_genai_client_initialization_failure():
    """인증 오류 등으로 SDK 초기화 실패 시 동작을 확인합니다."""
    with patch("google.genai.Client", side_effect=Exception("Auth error")):
        client = GenAIClient()
        assert client.is_available() is False
        assert client.mode == GenAIMode.REAL


def test_get_genai_client_force_new():
    """force_new=True일 때 새 인스턴스가 생성되는지 확인합니다."""
    reset_genai_client()
    with patch.dict(os.environ, {ENV_UW_MODE: "mock"}):
        client1 = get_genai_client()
        client2 = get_genai_client(force_new=True)
        assert client1 is not client2


@pytest.mark.asyncio
async def test_genai_client_generate_stream_real_call():
    """GenAIClient가 스트리밍 호출을 올바르게 수행하는지 확인합니다."""
    with patch("google.genai.Client") as mock_client_class:
        mock_instance = mock_client_class.return_value

        # mock aio.models.generate_content_stream
        async def mock_stream():
            yield MagicMock(text="chunk1")
            yield MagicMock(text="chunk2")

        mock_instance.aio.models.generate_content_stream = AsyncMock(return_value=mock_stream())

        client = GenAIClient(project="p", location="l")
        request = GenerateRequest(prompt="hello", model_label=ModelLabel.FAST)

        chunks = []
        async for chunk in client.generate_stream(request):
            chunks.append(chunk)

        assert chunks == ["chunk1", "chunk2"]
        mock_instance.aio.models.generate_content_stream.assert_called_once()


@pytest.mark.asyncio
async def test_genai_client_unavailable_raises_error():
    """사용 불가능한 클라이언트 호출 시 RuntimeError가 발생하는지 확인합니다."""
    with patch("google.genai.Client", side_effect=Exception("Init error")):
        client = GenAIClient()
        assert client.is_available() is False

        request = GenerateRequest(prompt="hi")
        with pytest.raises(RuntimeError, match="초기화되지 않았습니다"):
            await client.generate(request)

        with pytest.raises(RuntimeError, match="초기화되지 않았습니다"):
            async for _ in client.generate_stream(request):
                pass


@pytest.mark.asyncio
async def test_genai_client_full_config():
    """max_tokens와 temperature가 SDK 호출 시 올바르게 전달되는지 확인합니다."""
    with patch("google.genai.Client") as mock_client_class:
        mock_instance = mock_client_class.return_value
        mock_instance.aio.models.generate_content = AsyncMock(return_value=MagicMock(text="ok"))

        async def mock_stream():
            yield MagicMock(text="ok")

        mock_instance.aio.models.generate_content_stream = AsyncMock(return_value=mock_stream())

        client = GenAIClient(project="p")
        request = GenerateRequest(prompt="hi", max_tokens=50, temperature=0.7)

        # generate 호출 검증
        await client.generate(request)
        mock_instance.aio.models.generate_content.assert_called_with(
            model=MODEL_FAST, contents="hi", config={"max_output_tokens": 50, "temperature": 0.7}
        )

        # generate_stream 호출 검증
        async for _ in client.generate_stream(request):
            pass
        mock_instance.aio.models.generate_content_stream.assert_called_with(
            model=MODEL_FAST, contents="hi", config={"max_output_tokens": 50, "temperature": 0.7}
        )


def test_get_genai_client_real_init_failure_fallback():
    """실제 클라이언트 초기화 실패 시 Mock 클라이언트로 폴백되는지 확인합니다."""
    reset_genai_client()
    with (
        patch.dict(os.environ, {ENV_UW_MODE: "real"}),
        patch("unknown_world.services.genai_client.GenAIClient.is_available", return_value=False),
    ):
        client = get_genai_client(force_new=True)
        assert isinstance(client, MockGenAIClient)


def test_reset_genai_client():
    """reset_genai_client가 캐시를 올바르게 비우는지 확인합니다."""
    reset_genai_client()
    with patch.dict(os.environ, {ENV_UW_MODE: "mock"}):
        client1 = get_genai_client()
        reset_genai_client()
        client2 = get_genai_client()
        assert client1 is not client2


def test_mock_client_is_available():
    """MockGenAIClient가 항상 사용 가능한지 확인합니다."""
    client = MockGenAIClient()
    assert client.is_available() is True


def test_get_genai_client_invalid_mode():
    """유효하지 않은 UW_MODE일 때 기본값(REAL)으로 동작하는지 확인합니다."""
    reset_genai_client()
    with (
        patch.dict(os.environ, {ENV_UW_MODE: "invalid"}),
        patch(
            "unknown_world.services.genai_client.GenAIClient", return_value=MagicMock()
        ) as mock_real,
    ):
        get_genai_client(force_new=True)
        mock_real.assert_called_once()


def test_get_genai_client_force_mock():
    """force_mock=True일 때 환경변수와 무관하게 Mock 클라이언트를 반환하는지 확인합니다."""
    reset_genai_client()
    with patch.dict(os.environ, {ENV_UW_MODE: "real"}):
        client = get_genai_client(force_mock=True, force_new=True)
        assert isinstance(client, MockGenAIClient)
</file>

<file path="backend/tests/unit/test_image_postprocess.py">
"""U-035[Mvp] 이미지 후처리 서비스 단위 테스트.

이 테스트는 rembg 배경 제거 로직의 모델 선택 및 폴백 동작을 검증합니다.
"""

import unittest
from pathlib import Path
from unittest.mock import MagicMock, patch

from unknown_world.services.image_postprocess import (
    BackgroundRemovalStatus,
    ImagePostprocessor,
    RembgModel,
    _create_output_path,
    select_model_from_hint,
)


class TestImagePostprocess(unittest.TestCase):
    """ImagePostprocess 단위 테스트."""

    def test_select_model_from_hint(self) -> None:
        """힌트에 따른 모델 선택 로직을 테스트합니다."""
        # 1. 명확한 매칭
        model, alpha = select_model_from_hint("object")
        self.assertEqual(model, RembgModel.BIREFNET_GENERAL)
        self.assertFalse(alpha)

        model, alpha = select_model_from_hint("character")
        self.assertEqual(model, RembgModel.ISNET_ANIME)
        self.assertFalse(alpha)

        model, alpha = select_model_from_hint("portrait")
        self.assertEqual(model, RembgModel.BIREFNET_PORTRAIT)
        self.assertTrue(alpha)

        # 2. 대소문자 및 공백 처리
        model, _ = select_model_from_hint("  ANIME  ")
        self.assertEqual(model, RembgModel.ISNET_ANIME)

        # 3. 키워드 포함 검색
        model, _ = select_model_from_hint("game_item_icon")
        self.assertEqual(model, RembgModel.BIREFNET_GENERAL)

        # 4. 기본값 (알 수 없는 힌트)
        model, alpha = select_model_from_hint("unknown_hint")
        self.assertEqual(model, RembgModel.BIREFNET_GENERAL)
        self.assertFalse(alpha)

        # 5. None 처리
        model, alpha = select_model_from_hint(None)
        self.assertEqual(model, RembgModel.BIREFNET_GENERAL)
        self.assertFalse(alpha)

    def test_create_output_path(self) -> None:
        """출력 경로 생성 규칙을 테스트합니다."""
        input_path = Path("test/image.png")
        output_path = _create_output_path(input_path)
        self.assertEqual(output_path, Path("test/image_nobg.png"))

        input_path = Path("asset.jpg")
        output_path = _create_output_path(input_path, suffix="_clean")
        self.assertEqual(output_path, Path("asset_clean.png"))  # 확장자는 항상 png로 변환

    @patch("unknown_world.services.image_postprocess.subprocess.run")
    def test_is_available_success(self, mock_run: MagicMock) -> None:
        """rembg 설치 확인 성공 시나리오."""
        mock_run.return_value = MagicMock(returncode=0, stdout="rembg 2.0.67")

        processor = ImagePostprocessor()
        self.assertTrue(processor.is_available())
        mock_run.assert_called_with(
            ["rembg", "--version"], capture_output=True, text=True, timeout=5
        )

    @patch("unknown_world.services.image_postprocess.subprocess.run")
    def test_is_available_failure(self, mock_run: MagicMock) -> None:
        """rembg 미설치 또는 실행 실패 시나리오."""
        mock_run.side_effect = FileNotFoundError()

        processor = ImagePostprocessor()
        self.assertFalse(processor.is_available())

        @patch("shutil.copy")
        @patch("unknown_world.services.image_postprocess.preflight_is_available")
        @patch("unknown_world.services.image_postprocess.ImagePostprocessor.is_available")
        def test_remove_background_fallback(
            self,
            mock_available: MagicMock,
            mock_preflight_available: MagicMock,
            mock_copy: MagicMock,
        ) -> None:
            """rembg 사용 불가 시 원본을 복사하는 폴백 시나리오."""
            mock_preflight_available.return_value = True
            mock_available.return_value = False
            processor = ImagePostprocessor()

            input_path = Path("dummy.png")
            with patch.object(Path, "exists", return_value=True):
                result = processor.remove_background(input_path)

                self.assertEqual(result.status, BackgroundRemovalStatus.FAILED)
                self.assertEqual(result.output_path, Path("dummy_nobg.png"))
                mock_copy.assert_called_once()

        @patch("unknown_world.services.image_postprocess.preflight_is_available")
        @patch("unknown_world.services.image_postprocess.subprocess.run")
        @patch("unknown_world.services.image_postprocess.ImagePostprocessor.is_available")
        def test_remove_background_success(
            self,
            mock_available: MagicMock,
            mock_run: MagicMock,
            mock_preflight_available: MagicMock,
        ) -> None:
            """rembg 실행 성공 시나리오."""
            mock_preflight_available.return_value = True
            mock_available.return_value = True
            mock_run.return_value = MagicMock(returncode=0)

            processor = ImagePostprocessor()
            input_path = Path("input.png")

            with patch.object(Path, "exists", side_effect=[True, True, True]):
                result = processor.remove_background(input_path, image_type_hint="character")
                self.assertEqual(result.status, BackgroundRemovalStatus.SUCCESS)
            self.assertEqual(result.model_used, RembgModel.ISNET_ANIME)
            # 명령어에 모델 인자가 포함되었는지 확인
            args, _ = mock_run.call_args
            self.assertIn(RembgModel.ISNET_ANIME, args[0])

    @patch("shutil.copy")
    @patch("unknown_world.services.image_postprocess.preflight_is_available")
    def test_remove_background_preflight_not_available(
        self, mock_preflight_available: MagicMock, mock_copy: MagicMock
    ) -> None:
        """U-045: preflight가 준비되지 않았을 때 즉시 원본을 반환하는지 테스트합니다."""
        # preflight 미준비 상태 설정
        mock_preflight_available.return_value = False

        processor = ImagePostprocessor()
        input_path = Path("input.png")
        output_path = Path("output.png")

        with patch.object(Path, "exists", return_value=True):
            result = processor.remove_background(input_path, output_path=output_path)

            # 결과가 FAILED(또는 SKIPPED)이고 메시지에 preflight 관련 내용이 포함되어야 함
            self.assertEqual(result.status, BackgroundRemovalStatus.FAILED)
            self.assertIn("preflight", result.message)
            # 원본을 결과 경로로 복사했는지 확인
            mock_copy.assert_called_once_with(input_path, output_path)


if __name__ == "__main__":
    unittest.main()
</file>

<file path="frontend/public/ui/manifest.schema.json">
{
  "$schema": "http://json-schema.org/draft-07/schema#",
  "$id": "https://unknown-world.dev/schemas/ui-asset-manifest.json",
  "title": "UI Asset Manifest",
  "description": "nanobanana mcp로 제작된 UI 에셋의 매니페스트 스키마",
  "type": "object",
  "required": ["version", "assets"],
  "additionalProperties": false,
  "properties": {
    "$schema": {
      "type": "string",
      "description": "JSON Schema 참조"
    },
    "version": {
      "type": "string",
      "pattern": "^\\d+\\.\\d+\\.\\d+$",
      "description": "매니페스트 버전 (SemVer)",
      "examples": ["1.0.0"]
    },
    "generatedAt": {
      "type": "string",
      "format": "date-time",
      "description": "매니페스트 생성 시각 (ISO 8601)"
    },
    "totalBytes": {
      "type": "integer",
      "minimum": 0,
      "description": "모든 에셋의 총 바이트 수"
    },
    "budgetBytes": {
      "type": "integer",
      "minimum": 0,
      "default": 1572864,
      "description": "성능 예산 상한 (기본: 1.5MB = 1572864 bytes)"
    },
    "assets": {
      "type": "array",
      "description": "에셋 목록",
      "items": {
        "$ref": "#/$defs/Asset"
      }
    }
  },
  "$defs": {
    "Asset": {
      "type": "object",
      "required": ["id", "path", "type"],
      "additionalProperties": false,
      "properties": {
        "id": {
          "type": "string",
          "pattern": "^[a-z0-9]+(-[a-z0-9]+)*$",
          "description": "에셋 고유 ID (kebab-case)",
          "examples": ["signal-24", "badge-ok-16", "scene-loading"]
        },
        "path": {
          "type": "string",
          "pattern": "^[a-z0-9-/]+\\.(png|webp|svg)$",
          "description": "ui/ 디렉토리 기준 상대 경로",
          "examples": ["icons/signal-24.png", "placeholders/scene-loading.webp"]
        },
        "type": {
          "type": "string",
          "enum": ["icon", "placeholder", "chrome"],
          "description": "에셋 유형"
        },
        "size": {
          "type": "integer",
          "enum": [16, 24, 32, 64, 128, 256, 512],
          "description": "픽셀 사이즈 (아이콘용)"
        },
        "width": {
          "type": "integer",
          "minimum": 1,
          "description": "가로 픽셀 (placeholder/chrome용)"
        },
        "height": {
          "type": "integer",
          "minimum": 1,
          "description": "세로 픽셀 (placeholder/chrome용)"
        },
        "fallback": {
          "type": "string",
          "maxLength": 10,
          "description": "로딩 실패 시 대체 이모지/텍스트",
          "examples": ["📡", "⚠️", "OK"]
        },
        "usedIn": {
          "type": "array",
          "items": {
            "type": "string"
          },
          "description": "사용처 컴포넌트 목록",
          "examples": [["EconomyHUD", "AgentConsole"]]
        },
        "bytes": {
          "type": "integer",
          "minimum": 0,
          "description": "파일 크기 (bytes)"
        },
        "format": {
          "type": "string",
          "enum": ["png", "webp", "svg"],
          "description": "파일 포맷"
        },
        "retina": {
          "type": "boolean",
          "default": false,
          "description": "@2x Retina 버전 존재 여부"
        },
        "description": {
          "type": "string",
          "maxLength": 200,
          "description": "에셋 설명"
        },
        "createdAt": {
          "type": "string",
          "format": "date-time",
          "description": "생성 시각 (ISO 8601)"
        },
        "promptHash": {
          "type": "string",
          "pattern": "^[a-f0-9]{8}$",
          "description": "생성 프롬프트 해시 (재현성, 8자)"
        },
        "notes": {
          "type": "string",
          "maxLength": 500,
          "description": "에셋 관련 메모 (생성 도구, 배경 제거, 최적화 등 QA 관련 기록)"
        }
      }
    }
  }
}
</file>

<file path="frontend/tsconfig.json">
{
  "compilerOptions": {
    "target": "ES2022",
    "useDefineForClassFields": true,
    "lib": ["ES2022", "DOM", "DOM.Iterable"],
    "module": "ESNext",
    "skipLibCheck": true,

    /* Bundler mode */
    "moduleResolution": "Bundler",
    "allowImportingTsExtensions": true,
    "isolatedModules": true,
    "moduleDetection": "force",
    "noEmit": true,
    "jsx": "react-jsx",

    /* Linting (엄격 모드) */
    "strict": true,
    "noUnusedLocals": true,
    "noUnusedParameters": true,
    "noFallthroughCasesInSwitch": true,
    "noUncheckedSideEffectImports": true
  },
  "include": ["src"],
  "references": [{ "path": "./tsconfig.node.json" }]
}
</file>

<file path="backend/src/unknown_world/__init__.py">
"""Unknown World - Backend Package

This is the main package for the Unknown World backend.
Architecture: FastAPI + Pydantic + SSE streaming

Reference:
- vibe/tech-stack.md (Python 3.14, FastAPI 0.128.0, Pydantic 2.12.5)
- vibe/prd.md (Agent-based Game Master Engine)
"""

__version__ = "0.1.0"
</file>

<file path="backend/src/unknown_world/orchestrator/__init__.py">
"""Unknown World - Orchestrator 패키지.

이 패키지는 턴 처리 오케스트레이터를 포함합니다.
"""

from unknown_world.orchestrator.fallback import create_safe_fallback
from unknown_world.orchestrator.generate_turn_output import (
    GenerationResult,
    GenerationStatus,
    TurnOutputGenerator,
    generate_turn_output,
    get_turn_output_generator,
)
from unknown_world.orchestrator.mock import MockOrchestrator
from unknown_world.orchestrator.prompt_loader import (
    clear_prompt_cache,
    load_prompt,
    load_system_prompt,
    load_turn_instructions,
)
from unknown_world.orchestrator.repair_loop import (
    MAX_REPAIR_ATTEMPTS,
    RepairLoopResult,
    run_repair_loop,
)

__all__ = [
    # Mock Orchestrator
    "MockOrchestrator",
    # TurnOutput 생성
    "GenerationResult",
    "GenerationStatus",
    "TurnOutputGenerator",
    "generate_turn_output",
    "get_turn_output_generator",
    # Repair Loop (U-018)
    "MAX_REPAIR_ATTEMPTS",
    "RepairLoopResult",
    "run_repair_loop",
    # Fallback (U-018)
    "create_safe_fallback",
    # 프롬프트 로더
    "clear_prompt_cache",
    "load_prompt",
    "load_system_prompt",
    "load_turn_instructions",
]
</file>

<file path="backend/src/unknown_world/orchestrator/prompt_loader.py">
"""Unknown World - 프롬프트 로더 유틸리티.

이 모듈은 언어별로 분리된 프롬프트 파일을 로드합니다.
XML 태그 기반 메타데이터 파싱 및 핫리로드를 지원합니다.

설계 원칙:
    - RULE-006: ko/en 언어 정책 준수 (혼합 출력 금지)
    - RULE-007/008: 프롬프트 원문 UI/로그 노출 금지
    - U-036: 핫리로드 (개발 모드), 프론트매터 파싱 지원
    - U-046: XML 태그 규격 통일 (메타/섹션) + 레거시 폴백

프롬프트 디렉토리 구조:
    backend/prompts/
    ├── system/
    │   ├── game_master.ko.md
    │   └── game_master.en.md
    ├── turn/
    │   ├── turn_output_instructions.ko.md
    │   └── turn_output_instructions.en.md
    └── image/
        ├── scene_prompt.ko.md
        └── scene_prompt.en.md

XML 태그 규격 (U-046):
    <prompt_meta>
      <prompt_id>game_master_system</prompt_id>
      <language>ko-KR</language>
      <version>0.1.0</version>
      <last_updated>YYYY-MM-DD</last_updated>
      <policy_preset>default</policy_preset>
    </prompt_meta>

    <prompt_body>
    ## 목적
    ...
    </prompt_body>

페어링 질문 결정:
    - U-036 Q1: Option A (개발 모드에서만 매 호출 시 리로드)
    - U-036 Q2: Option B (프론트매터 포함 마크다운)
    - U-046 Q1: Option A (메타 블록을 모델 입력에서 제거)
    - U-046 Q2: Option A (XML 파싱 실패 시 레거시 폴백)

참조:
    - vibe/prd.md 3.2 (프롬프트 파일 관리)
    - vibe/prd.md 10.4 (프롬프트 핫리로드)
    - .cursor/rules/30-prompts-i18n.mdc
"""

from __future__ import annotations

import logging
import os
import re
from dataclasses import dataclass, field
from functools import lru_cache
from pathlib import Path
from typing import Literal

from unknown_world.models.turn import Language

# =============================================================================
# 로거 설정 (프롬프트 원문 로깅 금지 - RULE-007/008)
# =============================================================================

logger = logging.getLogger(__name__)

# =============================================================================
# 경로 상수
# =============================================================================

# 프롬프트 루트 디렉토리 (backend/prompts/)
_PROMPTS_ROOT = Path(__file__).parent.parent.parent.parent / "prompts"

# 프롬프트 카테고리
PromptCategory = Literal["system", "turn", "image"]

# 언어 코드 매핑
_LANGUAGE_CODE_MAP: dict[Language, str] = {
    Language.KO: "ko",
    Language.EN: "en",
}

# =============================================================================
# 프론트매터 파싱 결과 타입
# =============================================================================


@dataclass
class PromptData:
    """프론트매터가 파싱된 프롬프트 데이터.

    Attributes:
        content: 프롬프트 본문 (프론트매터 제외)
        metadata: 프론트매터에서 추출한 메타데이터
        raw: 원본 전체 텍스트
    """

    content: str
    metadata: dict[str, str] = field(default_factory=lambda: {})
    raw: str = ""

    def to_dict(self) -> dict[str, str | dict[str, str]]:
        """JSON 직렬화 가능한 딕셔너리로 변환합니다.

        Returns:
            프롬프트 데이터 딕셔너리
        """
        return {
            "content": self.content,
            "metadata": self.metadata,
        }


# =============================================================================
# 환경 모드 확인
# =============================================================================


def _is_development_mode() -> bool:
    """개발 모드인지 확인합니다.

    ENVIRONMENT 환경변수가 'development'이면 개발 모드입니다.
    개발 모드에서는 프롬프트 핫리로드가 활성화됩니다.

    Returns:
        개발 모드 여부
    """
    return os.environ.get("ENVIRONMENT", "production").lower() == "development"


# =============================================================================
# XML 태그 및 프론트매터 파싱 (U-046)
# =============================================================================

# XML 태그 패턴 (U-046 표준)
_XML_META_PATTERN = re.compile(
    r"<prompt_meta>\s*(.*?)\s*</prompt_meta>",
    re.DOTALL,
)
_XML_BODY_PATTERN = re.compile(
    r"<prompt_body>\s*(.*?)\s*</prompt_body>",
    re.DOTALL,
)
_XML_TAG_PATTERN = re.compile(r"<(\w+)>([^<]*)</\1>")

# 레거시 프론트매터 패턴: 파일 시작 부분의 "- key: value" 형태
_FRONTMATTER_LINE_PATTERN = re.compile(r"^-\s*(\w+):\s*(.+)$")


def _parse_xml_meta(text: str) -> tuple[dict[str, str], str] | None:
    """XML 태그 기반 메타데이터와 본문을 파싱합니다.

    U-046 표준 XML 태그 규격:
        <prompt_meta>
          <prompt_id>game_master_system</prompt_id>
          <language>ko-KR</language>
          <version>0.1.0</version>
          <last_updated>YYYY-MM-DD</last_updated>
          <policy_preset>default</policy_preset>
        </prompt_meta>

        <prompt_body>
        ## 목적
        ...
        </prompt_body>

    Args:
        text: 원본 텍스트

    Returns:
        (메타데이터 딕셔너리, 본문 텍스트) 튜플
        XML 태그가 없으면 None 반환 (레거시 폴백 필요)
    """
    meta_match = _XML_META_PATTERN.search(text)
    body_match = _XML_BODY_PATTERN.search(text)

    # XML 태그가 없으면 None 반환
    if not meta_match:
        return None

    # 메타데이터 파싱
    meta_content = meta_match.group(1)
    metadata: dict[str, str] = {}
    for tag_match in _XML_TAG_PATTERN.finditer(meta_content):
        key = tag_match.group(1)
        value = tag_match.group(2).strip()
        metadata[key] = value

    # 본문 추출 (U-046 Q1: 메타 블록을 모델 입력에서 제거)
    if body_match:
        content = body_match.group(1).strip()
    else:
        # <prompt_body>가 없으면 <prompt_meta> 이후 전체를 본문으로 취급
        meta_end = meta_match.end()
        content = text[meta_end:].strip()

    return metadata, content


def _parse_legacy_frontmatter(text: str) -> tuple[dict[str, str], str]:
    """레거시 프론트매터를 파싱합니다 (U-036 호환).

    프론트매터는 첫 번째 제목(#) 이후, 두 번째 제목(##) 이전의
    "- key: value" 형태의 라인들입니다.

    예시 구조:
        # [Prompt] Title

        - prompt_id: xxx
        - version: 0.1.0

        ## 본문 섹션
        ...

    Args:
        text: 원본 마크다운 텍스트

    Returns:
        (메타데이터 딕셔너리, 본문 텍스트) 튜플
    """
    lines = text.split("\n")
    metadata: dict[str, str] = {}
    content_start_idx = 0
    found_first_heading = False

    for i, line in enumerate(lines):
        stripped = line.strip()

        # 빈 줄은 건너뜀
        if not stripped:
            continue

        # 첫 번째 제목(#) 발견
        if stripped.startswith("#") and not stripped.startswith("##"):
            found_first_heading = True
            continue

        # 두 번째 제목(##) 발견 시 프론트매터 영역 종료, 본문 시작
        if stripped.startswith("##"):
            content_start_idx = i
            break

        # 프론트매터 라인 매칭 (첫 번째 제목 이후)
        if found_first_heading:
            match = _FRONTMATTER_LINE_PATTERN.match(stripped)
            if match:
                key = match.group(1)
                value = match.group(2).strip()
                metadata[key] = value

    # 본문 추출 (두 번째 제목부터)
    content = "\n".join(lines[content_start_idx:]).strip()

    return metadata, content


def _parse_frontmatter(text: str) -> tuple[dict[str, str], str]:
    """메타데이터와 본문을 파싱합니다 (XML 우선, 레거시 폴백).

    U-046 Q2 결정: XML 태그 파싱 실패 시 레거시 폴백 후 진행

    파싱 우선순위:
        1. XML 태그 기반 (<prompt_meta>, <prompt_body>)
        2. 레거시 프론트매터 (- key: value)

    Args:
        text: 원본 텍스트

    Returns:
        (메타데이터 딕셔너리, 본문 텍스트) 튜플
    """
    # 1. XML 태그 파싱 시도
    xml_result = _parse_xml_meta(text)
    if xml_result is not None:
        metadata, content = xml_result
        logger.debug(
            "[PromptLoader] XML 태그 기반 파싱 완료",
            extra={"format": "xml", "meta_keys": list(metadata.keys())},
        )
        return metadata, content

    # 2. 레거시 폴백 (U-046 Q2: Option A)
    logger.debug(
        "[PromptLoader] 레거시 프론트매터 파싱으로 폴백",
        extra={"format": "legacy"},
    )
    return _parse_legacy_frontmatter(text)


# =============================================================================
# 프롬프트 로더 함수
# =============================================================================


def _get_prompt_path(
    category: PromptCategory,
    name: str,
    language: Language,
) -> Path:
    """프롬프트 파일 경로를 반환합니다.

    Args:
        category: 프롬프트 카테고리 (system, turn, image)
        name: 프롬프트 파일 이름 (확장자 제외)
        language: 언어 (ko-KR, en-US)

    Returns:
        프롬프트 파일 경로

    Example:
        >>> _get_prompt_path("system", "game_master", Language.KO)
        Path(".../prompts/system/game_master.ko.md")
    """
    lang_code = _LANGUAGE_CODE_MAP.get(language, "ko")
    return _PROMPTS_ROOT / category / f"{name}.{lang_code}.md"


def _load_prompt_file(
    category: PromptCategory,
    name: str,
    language: Language,
) -> str:
    """프롬프트 파일을 직접 로드합니다 (캐싱 없음).

    핫리로드 모드에서 사용됩니다.

    Args:
        category: 프롬프트 카테고리
        name: 프롬프트 이름
        language: 언어

    Returns:
        프롬프트 텍스트

    Raises:
        FileNotFoundError: 프롬프트 파일이 없는 경우
    """
    path = _get_prompt_path(category, name, language)

    if not path.exists():
        # 폴백: 반대 언어 시도
        fallback_lang = Language.EN if language == Language.KO else Language.KO
        fallback_path = _get_prompt_path(category, name, fallback_lang)

        if fallback_path.exists():
            logger.warning(
                "[PromptLoader] 폴백 언어 사용",
                extra={
                    "original_language": language.value,
                    "fallback_language": fallback_lang.value,
                },
            )
            return fallback_path.read_text(encoding="utf-8")

        raise FileNotFoundError(f"프롬프트 파일을 찾을 수 없습니다: {path}")

    return path.read_text(encoding="utf-8")


@lru_cache(maxsize=32)
def _load_prompt_cached(
    category: PromptCategory,
    name: str,
    language: Language,
) -> str:
    """프롬프트 파일을 캐싱하여 로드합니다.

    운영 모드에서 사용됩니다.

    Args:
        category: 프롬프트 카테고리
        name: 프롬프트 이름
        language: 언어

    Returns:
        프롬프트 텍스트
    """
    return _load_prompt_file(category, name, language)


def load_prompt(
    category: PromptCategory,
    name: str,
    language: Language,
) -> str:
    """프롬프트 파일을 로드합니다.

    개발 모드(ENVIRONMENT=development)에서는 매 호출 시 파일을 다시 읽습니다 (핫리로드).
    운영 모드에서는 캐싱을 통해 반복 로드를 방지합니다.
    프롬프트 원문은 로그에 기록하지 않습니다 (RULE-007/008).

    Args:
        category: 프롬프트 카테고리 (system, turn, image)
        name: 프롬프트 파일 이름 (확장자 제외)
        language: 언어 (ko-KR, en-US)

    Returns:
        프롬프트 텍스트

    Raises:
        FileNotFoundError: 프롬프트 파일이 없는 경우

    Example:
        >>> prompt = load_prompt("system", "game_master", Language.KO)
    """
    # 로그에는 경로/메타만 기록 (원문 금지)
    logger.debug(
        "[PromptLoader] 프롬프트 로드",
        extra={
            "category": category,
            "name": name,
            "language": language.value,
            "hot_reload": _is_development_mode(),
        },
    )

    # U-036 Q1 결정: 개발 모드에서만 핫리로드
    if _is_development_mode():
        return _load_prompt_file(category, name, language)
    else:
        return _load_prompt_cached(category, name, language)


def load_prompt_with_metadata(
    category: PromptCategory,
    name: str,
    language: Language,
) -> PromptData:
    """프롬프트 파일을 메타데이터와 함께 로드합니다.

    프론트매터를 파싱하여 메타데이터와 본문을 분리합니다.
    JSON 형태로 프롬프트를 전달할 때 유용합니다.

    Args:
        category: 프롬프트 카테고리 (system, turn, image)
        name: 프롬프트 파일 이름 (확장자 제외)
        language: 언어 (ko-KR, en-US)

    Returns:
        PromptData: 메타데이터와 본문이 분리된 프롬프트 데이터

    Example:
        >>> data = load_prompt_with_metadata("system", "game_master", Language.KO)
        >>> print(data.metadata.get("version"))
        >>> print(data.content[:100])
    """
    raw_text = load_prompt(category, name, language)
    metadata, content = _parse_frontmatter(raw_text)

    logger.debug(
        "[PromptLoader] 프롬프트 메타데이터 파싱 완료",
        extra={
            "category": category,
            "name": name,
            "language": language.value,
            "prompt_id": metadata.get("prompt_id", "unknown"),
            "version": metadata.get("version", "unknown"),
        },
    )

    return PromptData(
        content=content,
        metadata=metadata,
        raw=raw_text,
    )


def load_prompt_as_json(
    category: PromptCategory,
    name: str,
    language: Language,
) -> dict[str, str | dict[str, str]]:
    """프롬프트를 JSON 직렬화 가능한 딕셔너리로 로드합니다.

    API 응답이나 모델 입력으로 프롬프트를 전달할 때 유용합니다.

    Args:
        category: 프롬프트 카테고리 (system, turn, image)
        name: 프롬프트 파일 이름 (확장자 제외)
        language: 언어 (ko-KR, en-US)

    Returns:
        프롬프트 딕셔너리 (content, metadata 포함)

    Example:
        >>> prompt_json = load_prompt_as_json("image", "scene_prompt", Language.KO)
        >>> print(prompt_json["metadata"]["prompt_id"])
    """
    data = load_prompt_with_metadata(category, name, language)
    return data.to_dict()


def load_system_prompt(language: Language) -> str:
    """Game Master 시스템 프롬프트를 로드합니다.

    Args:
        language: 언어 (ko-KR, en-US)

    Returns:
        시스템 프롬프트 텍스트
    """
    return load_prompt("system", "game_master", language)


def load_turn_instructions(language: Language) -> str:
    """TurnOutput 지시 프롬프트를 로드합니다.

    Args:
        language: 언어 (ko-KR, en-US)

    Returns:
        TurnOutput 지시 텍스트
    """
    return load_prompt("turn", "turn_output_instructions", language)


def load_image_prompt(language: Language) -> str:
    """이미지 생성 프롬프트를 로드합니다.

    Args:
        language: 언어 (ko-KR, en-US)

    Returns:
        이미지 생성 프롬프트 텍스트
    """
    return load_prompt("image", "scene_prompt", language)


def load_image_prompt_with_metadata(language: Language) -> PromptData:
    """이미지 생성 프롬프트를 메타데이터와 함께 로드합니다.

    Args:
        language: 언어 (ko-KR, en-US)

    Returns:
        PromptData: 메타데이터와 본문이 분리된 이미지 프롬프트 데이터
    """
    return load_prompt_with_metadata("image", "scene_prompt", language)


def clear_prompt_cache() -> None:
    """프롬프트 캐시를 초기화합니다.

    개발 중 핫리로드 또는 테스트 시 사용합니다.
    """
    _load_prompt_cached.cache_clear()
    logger.info("[PromptLoader] 프롬프트 캐시 초기화됨")


def get_prompt_metadata(
    category: PromptCategory,
    name: str,
    language: Language,
) -> dict[str, str]:
    """프롬프트의 메타데이터만 반환합니다.

    본문 없이 버전, 언어, 업데이트 날짜 등 메타정보만 필요할 때 사용합니다.

    Args:
        category: 프롬프트 카테고리
        name: 프롬프트 이름
        language: 언어

    Returns:
        메타데이터 딕셔너리
    """
    data = load_prompt_with_metadata(category, name, language)
    return data.metadata


def is_hot_reload_enabled() -> bool:
    """핫리로드가 활성화되어 있는지 확인합니다.

    Returns:
        핫리로드 활성화 여부
    """
    return _is_development_mode()
</file>

<file path="backend/src/unknown_world/services/genai_client.py">
"""Unknown World - GenAI 클라이언트 래퍼.

이 모듈은 Vertex AI 서비스 계정 인증 기반의 google-genai 클라이언트를 제공합니다.
환경변수로 실제 모델과 mock 모드를 전환할 수 있습니다.

인증 방식:
    - 로컬: ADC 또는 GOOGLE_APPLICATION_CREDENTIALS 환경변수
    - 배포: Cloud Run 서비스 계정 권한 (키 파일 커밋 없음)

모드 전환 (페어링 질문 Q1 결정: Option A):
    - 환경변수 UW_MODE=mock → MockGenAIClient (테스트/개발용)
    - 환경변수 UW_MODE=real → 실제 Vertex AI 호출 (기본값)

보안 규칙:
    - BYOK(사용자 API 키 입력) 금지 (RULE-007)
    - 프롬프트 원문/비밀정보 로깅 금지 (RULE-007/008)
    - 로그에는 라벨/버전/정책 메타만 노출

참조:
    - vibe/tech-stack.md (google-genai==1.56.0)
    - .cursor/rules/20-backend-orchestrator.mdc
    - .cursor/rules/00-core-critical.mdc (RULE-007/010)
"""

from __future__ import annotations

import logging
import os
from collections.abc import AsyncGenerator
from dataclasses import dataclass, field
from enum import StrEnum
from typing import TYPE_CHECKING, Any

from unknown_world.config.models import ModelLabel, get_model_id

if TYPE_CHECKING:
    from google.genai import Client
    from google.genai.types import GenerateContentConfig

# =============================================================================
# 로거 설정 (프롬프트/비밀정보 노출 금지)
# =============================================================================

logger = logging.getLogger(__name__)


class GenAIMode(StrEnum):
    """GenAI 클라이언트 동작 모드.

    환경변수 UW_MODE로 제어합니다.
    """

    MOCK = "mock"
    """테스트/개발용 모의 모드 - 실제 API 호출 없음"""

    REAL = "real"
    """실제 Vertex AI 호출 모드 (기본값)"""


# =============================================================================
# 환경변수 키 상수
# =============================================================================

ENV_UW_MODE = "UW_MODE"
"""동작 모드 환경변수 (mock|real)"""

ENV_VERTEX_PROJECT = "VERTEX_PROJECT"
"""Vertex AI 프로젝트 ID 환경변수"""

ENV_VERTEX_LOCATION = "VERTEX_LOCATION"
"""Vertex AI 리전 환경변수 (기본값: us-central1)"""


# =============================================================================
# 요청/응답 데이터 클래스
# =============================================================================


@dataclass
class GenerateRequest:
    """텍스트 생성 요청.

    Attributes:
        prompt: 생성 프롬프트 (주의: 로깅 금지)
        model_label: 모델 라벨 (FAST, QUALITY 등)
        max_tokens: 최대 토큰 수 (선택)
        temperature: 온도 설정 (선택, 0.0~1.0)
        response_mime_type: 응답 MIME 타입 (예: "application/json")
        response_schema: 응답 JSON 스키마 (dict 또는 Pydantic 모델 타입)
    """

    prompt: str
    model_label: ModelLabel = ModelLabel.FAST
    max_tokens: int | None = None
    temperature: float | None = None
    response_mime_type: str | None = None
    response_schema: Any | None = None


@dataclass
class GenerateResponse:
    """텍스트 생성 응답.

    Attributes:
        text: 생성된 텍스트
        model_label: 사용된 모델 라벨
        finish_reason: 종료 이유 (stop, length 등)
        usage: 토큰 사용량 정보 (선택)
    """

    text: str
    model_label: ModelLabel
    finish_reason: str = "stop"
    usage: dict[str, int] = field(default_factory=lambda: {})


# =============================================================================
# Mock 클라이언트 구현
# =============================================================================


class MockGenAIClient:
    """테스트/개발용 모의 GenAI 클라이언트.

    실제 API를 호출하지 않고 고정된 응답을 반환합니다.
    자격 증명 미설정 시 자동으로 이 클라이언트가 사용됩니다.
    """

    def __init__(self) -> None:
        """MockGenAIClient를 초기화합니다."""
        logger.info(
            "[GenAI] Mock 모드로 초기화됨 (실제 API 호출 없음)",
            extra={"mode": GenAIMode.MOCK},
        )

    @property
    def mode(self) -> GenAIMode:
        """현재 동작 모드."""
        return GenAIMode.MOCK

    async def generate(self, request: GenerateRequest) -> GenerateResponse:
        """모의 텍스트를 생성합니다.

        Args:
            request: 생성 요청

        Returns:
            고정된 모의 응답
        """
        # 로그에는 메타 정보만 기록 (프롬프트 원문 금지 - RULE-007/008)
        logger.debug(
            "[GenAI] Mock 생성 요청",
            extra={
                "model_label": request.model_label,
                "max_tokens": request.max_tokens,
            },
        )

        return GenerateResponse(
            text=f"[Mock Response] 이것은 {request.model_label} 모델의 모의 응답입니다.",
            model_label=request.model_label,
            finish_reason="stop",
            usage={"prompt_tokens": 10, "completion_tokens": 20, "total_tokens": 30},
        )

    async def generate_stream(self, request: GenerateRequest) -> AsyncGenerator[str]:
        """모의 텍스트를 스트리밍으로 생성합니다.

        Args:
            request: 생성 요청

        Yields:
            고정된 모의 텍스트 청크
        """
        logger.debug(
            "[GenAI] Mock 스트리밍 요청",
            extra={"model_label": request.model_label},
        )

        chunks = [
            "[Mock] ",
            "이것은 ",
            f"{request.model_label} ",
            "모델의 ",
            "스트리밍 ",
            "모의 응답입니다.",
        ]
        for chunk in chunks:
            yield chunk

    def is_available(self) -> bool:
        """Mock 클라이언트는 항상 사용 가능합니다."""
        return True


# =============================================================================
# 실제 GenAI 클라이언트 구현
# =============================================================================


class GenAIClient:
    """Vertex AI 기반 실제 GenAI 클라이언트.

    google-genai SDK를 사용하여 Gemini 모델을 호출합니다.
    서비스 계정 인증(ADC)을 사용하며, BYOK는 금지됩니다.
    """

    def __init__(
        self,
        project: str | None = None,
        location: str | None = None,
    ) -> None:
        """GenAIClient를 초기화합니다.

        Args:
            project: Vertex AI 프로젝트 ID (환경변수 VERTEX_PROJECT 사용 가능)
            location: Vertex AI 리전 (기본값: us-central1)

        Raises:
            RuntimeError: 인증 설정이 올바르지 않은 경우
        """
        self._project = project or os.environ.get(ENV_VERTEX_PROJECT)
        self._location = location or os.environ.get(ENV_VERTEX_LOCATION, "us-central1")
        self._client: Client | None = None
        self._available = False

        self._initialize_client()

    def _initialize_client(self) -> None:
        """google-genai 클라이언트를 초기화합니다."""
        try:
            from google.genai import Client

            # Vertex AI 모드로 클라이언트 초기화
            # 인증은 ADC(Application Default Credentials)를 사용
            # - 로컬: gcloud auth application-default login
            # - 배포: Cloud Run 서비스 계정 자동 인증
            client_options: dict[str, Any] = {}
            if self._project:
                client_options["project"] = self._project
            if self._location:
                client_options["location"] = self._location

            # vertexai=True로 Vertex AI 모드 활성화
            self._client = Client(vertexai=True, **client_options)
            self._available = True

            # 로그에는 프로젝트/리전만 기록 (키/토큰 노출 금지)
            logger.info(
                "[GenAI] Vertex AI 클라이언트 초기화 완료",
                extra={
                    "mode": GenAIMode.REAL,
                    "project": self._project or "(ADC 기본)",
                    "location": self._location,
                },
            )
        except Exception as e:
            # 인증 실패 시에도 앱이 멈추지 않도록 로깅만 수행
            # 오류 상세(스택트레이스)에 비밀정보가 포함될 수 있으므로 exc_info=False
            logger.warning(
                "[GenAI] Vertex AI 클라이언트 초기화 실패 - Mock 모드로 전환 권장",
                extra={"error_type": type(e).__name__},
            )
            self._available = False

    @property
    def mode(self) -> GenAIMode:
        """현재 동작 모드."""
        return GenAIMode.REAL

    async def generate(self, request: GenerateRequest) -> GenerateResponse:
        """텍스트를 생성합니다.

        Args:
            request: 생성 요청

        Returns:
            생성된 텍스트 응답

        Raises:
            RuntimeError: 클라이언트가 사용 불가능한 경우
        """
        if not self._available or self._client is None:
            raise RuntimeError("GenAI 클라이언트가 초기화되지 않았습니다.")

        model_id = get_model_id(request.model_label)

        # 로그에는 메타 정보만 기록 (프롬프트 원문 금지 - RULE-007/008)
        logger.debug(
            "[GenAI] 생성 요청",
            extra={
                "model_label": request.model_label,
                "model_id": model_id,
                "max_tokens": request.max_tokens,
            },
        )

        # google-genai SDK 호출
        from google.genai.types import GenerateContentConfig

        config_dict: dict[str, Any] = {}
        if request.max_tokens:
            config_dict["max_output_tokens"] = request.max_tokens
        if request.temperature is not None:
            config_dict["temperature"] = request.temperature
        if request.response_mime_type:
            config_dict["response_mime_type"] = request.response_mime_type
        if request.response_schema:
            config_dict["response_schema"] = request.response_schema

        config: GenerateContentConfig | None = (
            GenerateContentConfig(**config_dict) if config_dict else None
        )

        response = await self._client.aio.models.generate_content(  # type: ignore[reportUnknownMemberType]
            model=model_id,
            contents=request.prompt,
            config=config,
        )

        # 응답 파싱
        text = response.text if hasattr(response, "text") and response.text else str(response)
        finish_reason = "stop"
        if hasattr(response, "candidates") and response.candidates:
            candidate = response.candidates[0]
            if hasattr(candidate, "finish_reason"):
                finish_reason = str(candidate.finish_reason)

        # 토큰 사용량 추출
        usage: dict[str, int] = {}
        if hasattr(response, "usage_metadata") and response.usage_metadata:
            meta = response.usage_metadata
            if hasattr(meta, "prompt_token_count") and meta.prompt_token_count is not None:
                usage["prompt_tokens"] = meta.prompt_token_count
            if hasattr(meta, "candidates_token_count") and meta.candidates_token_count is not None:
                usage["completion_tokens"] = meta.candidates_token_count
            if hasattr(meta, "total_token_count") and meta.total_token_count is not None:
                usage["total_tokens"] = meta.total_token_count

        return GenerateResponse(
            text=text,
            model_label=request.model_label,
            finish_reason=finish_reason,
            usage=usage,
        )

    async def generate_stream(self, request: GenerateRequest) -> AsyncGenerator[str]:
        """텍스트를 스트리밍으로 생성합니다.

        Args:
            request: 생성 요청

        Yields:
            생성된 텍스트 청크

        Raises:
            RuntimeError: 클라이언트가 사용 불가능한 경우
        """
        if not self._available or self._client is None:
            raise RuntimeError("GenAI 클라이언트가 초기화되지 않았습니다.")

        model_id = get_model_id(request.model_label)

        logger.debug(
            "[GenAI] 스트리밍 요청",
            extra={
                "model_label": request.model_label,
                "model_id": model_id,
            },
        )

        from google.genai.types import GenerateContentConfig

        config_dict: dict[str, Any] = {}
        if request.max_tokens:
            config_dict["max_output_tokens"] = request.max_tokens
        if request.temperature is not None:
            config_dict["temperature"] = request.temperature
        if request.response_mime_type:
            config_dict["response_mime_type"] = request.response_mime_type
        if request.response_schema:
            config_dict["response_schema"] = request.response_schema

        config: GenerateContentConfig | None = (
            GenerateContentConfig(**config_dict) if config_dict else None
        )

        stream = await self._client.aio.models.generate_content_stream(  # type: ignore[reportUnknownMemberType]
            model=model_id,
            contents=request.prompt,
            config=config,
        )
        async for chunk in stream:
            if hasattr(chunk, "text") and chunk.text:
                yield chunk.text

    def is_available(self) -> bool:
        """클라이언트가 사용 가능한 상태인지 확인합니다."""
        return self._available


# =============================================================================
# 팩토리 함수
# =============================================================================

# 클라이언트 타입 (Protocol 대신 Union 사용 - pyright 호환성)
GenAIClientType = MockGenAIClient | GenAIClient

# 싱글톤 클라이언트 인스턴스 캐시
_client_instance: GenAIClientType | None = None


def get_genai_client(
    *,
    force_mock: bool = False,
    force_new: bool = False,
) -> GenAIClientType:
    """GenAI 클라이언트 인스턴스를 반환합니다.

    환경변수 UW_MODE에 따라 실제 클라이언트 또는 Mock 클라이언트를 반환합니다.
    기본적으로 싱글톤 패턴으로 동작합니다.

    Args:
        force_mock: True면 환경변수와 무관하게 Mock 클라이언트 반환
        force_new: True면 캐시를 무시하고 새 인스턴스 생성

    Returns:
        GenAI 클라이언트 인스턴스

    Example:
        >>> client = get_genai_client()
        >>> response = await client.generate(GenerateRequest(prompt="Hello"))
    """
    global _client_instance

    if not force_new and _client_instance is not None:
        return _client_instance

    # 모드 결정: force_mock > 환경변수 > 기본값(real)
    if force_mock:
        mode = GenAIMode.MOCK
    else:
        mode_str = os.environ.get(ENV_UW_MODE, GenAIMode.REAL)
        mode = GenAIMode(mode_str) if mode_str in GenAIMode.__members__.values() else GenAIMode.REAL

    # 클라이언트 생성
    client_result: GenAIClientType
    if mode == GenAIMode.MOCK:
        client_result = MockGenAIClient()
    else:
        client = GenAIClient()
        # 실제 클라이언트 초기화 실패 시 Mock으로 폴백
        if not client.is_available():
            logger.warning(
                "[GenAI] 실제 클라이언트 초기화 실패, Mock 모드로 폴백",
            )
            client_result = MockGenAIClient()
        else:
            client_result = client

    _client_instance = client_result
    return client_result


def reset_genai_client() -> None:
    """GenAI 클라이언트 캐시를 초기화합니다.

    테스트 시 클라이언트를 재설정할 때 사용합니다.
    """
    global _client_instance
    _client_instance = None
</file>

<file path="backend/src/unknown_world/validation/business_rules.py">
"""Unknown World - 비즈니스 룰 검증기 (Hard Gate).

스키마 검증 이후에도 남는 "의미적 실패"를 검증합니다:
- Economy: cost/balance_after 일관성, 잔액 음수 금지
- Language: TurnInput.language와 TurnOutput.language 불일치 차단
- Box2D: 0~1000 범위 + [ymin,xmin,ymax,xmax] 순서 검증
- Safety: blocked 시 안전한 대체 결과 제공 확인

설계 원칙:
    - RULE-003: 구조화 출력(JSON Schema) 우선 + 이중 검증
    - RULE-004: 검증 실패 시 Repair loop + 안전한 폴백
    - RULE-005: 재화 인바리언트 (잔액 음수 금지)
    - RULE-006: ko/en 언어 정책 준수
    - RULE-009: 좌표 규약 (0~1000, bbox [ymin,xmin,ymax,xmax])

참조:
    - vibe/unit-plans/U-018[Mvp].md
    - vibe/unit-results/U-017[Mvp].md
"""

from __future__ import annotations

import logging
from dataclasses import dataclass, field
from enum import StrEnum
from typing import TYPE_CHECKING

from unknown_world.models.turn import Language
from unknown_world.validation.language_gate import (
    LanguageGateResult,
    build_language_error_summary,
    validate_language_consistency,
)

if TYPE_CHECKING:
    from unknown_world.models.turn import TurnInput, TurnOutput

# =============================================================================
# 로거 설정
# =============================================================================

logger = logging.getLogger(__name__)


# =============================================================================
# i18n 에러 메시지 (RULE-006: ko/en 언어 정책 준수)
# =============================================================================

BUSINESS_RULE_MESSAGES: dict[Language, dict[str, str]] = {
    Language.KO: {
        "summary_header": "다음 비즈니스 룰을 위반했습니다:",
        "signal_insufficient": "Signal 재화가 부족합니다: 보유 {have}, 필요 {need}",
        "memory_shard_insufficient": "Memory Shard 재화가 부족합니다: 보유 {have}, 필요 {need}",
        "signal_negative": "Signal 잔액이 음수입니다: {value}",
        "memory_shard_negative": "Memory Shard 잔액이 음수입니다: {value}",
        "signal_mismatch": "Signal 잔액 불일치: 예상 {expected}, 실제 {actual}",
        "memory_shard_mismatch": "Memory Shard 잔액 불일치: 예상 {expected}, 실제 {actual}",
        "language_mismatch": "언어 불일치: 입력 {input_lang}, 출력 {output_lang}",
        "language_content_mixed": "언어 혼합 감지: {violation_count}개 필드에서 ko/en 혼합 발견",
        "box2d_out_of_range": "오브젝트 '{obj_id}'의 좌표가 범위를 벗어남: {coord}",
        "box2d_invalid_yorder": "오브젝트 '{obj_id}'의 ymin({ymin}) >= ymax({ymax})",
        "box2d_invalid_xorder": "오브젝트 '{obj_id}'의 xmin({xmin}) >= xmax({xmax})",
        "safety_blocked_no_fallback": "안전 정책에 의해 차단되었지만 대체 텍스트가 없습니다",
    },
    Language.EN: {
        "summary_header": "The following business rules were violated:",
        "signal_insufficient": "Insufficient Signal: have {have}, need {need}",
        "memory_shard_insufficient": "Insufficient Memory Shard: have {have}, need {need}",
        "signal_negative": "Signal balance is negative: {value}",
        "memory_shard_negative": "Memory Shard balance is negative: {value}",
        "signal_mismatch": "Signal balance mismatch: expected {expected}, actual {actual}",
        "memory_shard_mismatch": "Memory Shard balance mismatch: expected {expected}, actual {actual}",
        "language_mismatch": "Language mismatch: input {input_lang}, output {output_lang}",
        "language_content_mixed": "Language mixing detected: {violation_count} fields contain ko/en mixing",
        "box2d_out_of_range": "Object '{obj_id}' coordinate out of range: {coord}",
        "box2d_invalid_yorder": "Object '{obj_id}' ymin({ymin}) >= ymax({ymax})",
        "box2d_invalid_xorder": "Object '{obj_id}' xmin({xmin}) >= xmax({xmax})",
        "safety_blocked_no_fallback": "Blocked by safety policy but no fallback text provided",
    },
}


# =============================================================================
# 에러 타입
# =============================================================================


class BusinessRuleError(StrEnum):
    """비즈니스 룰 위반 타입."""

    # Economy 규칙 (RULE-005)
    ECONOMY_NEGATIVE_BALANCE = "economy_negative_balance"
    """잔액이 음수입니다 (금지)"""

    ECONOMY_COST_MISMATCH = "economy_cost_mismatch"
    """비용과 잔액 변화가 일치하지 않습니다"""

    ECONOMY_COST_MISSING = "economy_cost_missing"
    """비용 정보가 누락되었습니다"""

    # Language 규칙 (RULE-006)
    LANGUAGE_MISMATCH = "language_mismatch"
    """입력과 출력 언어가 일치하지 않습니다"""

    LANGUAGE_CONTENT_MIXED = "language_content_mixed"
    """사용자 노출 텍스트에 ko/en이 혼합되어 있습니다 (U-043)"""

    # Box2D 규칙 (RULE-009)
    BOX2D_OUT_OF_RANGE = "box2d_out_of_range"
    """좌표가 0~1000 범위를 벗어났습니다"""

    BOX2D_INVALID_ORDER = "box2d_invalid_order"
    """bbox 순서가 올바르지 않습니다 (ymin < ymax, xmin < xmax 필요)"""

    # Safety 규칙
    SAFETY_BLOCKED_NO_FALLBACK = "safety_blocked_no_fallback"
    """차단되었지만 안전한 대체 결과가 제공되지 않았습니다"""


# =============================================================================
# 검증 결과 타입
# =============================================================================


@dataclass
class BusinessRuleValidationResult:
    """비즈니스 룰 검증 결과.

    Attributes:
        is_valid: 모든 검증 통과 여부
        errors: 발견된 위반 목록
        error_summary: 에러 요약 (Repair 프롬프트용)
        language: 응답 언어 (RULE-006)
        language_gate_result: 언어 혼합 검증 결과 (U-043)
    """

    is_valid: bool = True
    errors: list[dict[str, str]] = field(default_factory=lambda: [])
    error_summary: str = ""
    language: Language = Language.KO
    language_gate_result: LanguageGateResult | None = None

    def add_error(self, error_type: BusinessRuleError, message: str) -> None:
        """에러를 추가합니다."""
        self.is_valid = False
        self.errors.append({"type": error_type.value, "message": message})

    def build_summary(self) -> str:
        """에러 요약을 생성합니다 (Repair 프롬프트용).

        언어에 따라 헤더 메시지를 분기합니다 (RULE-006).
        언어 혼합 에러가 있으면 상세 지시를 추가합니다 (U-043).
        """
        if not self.errors:
            self.error_summary = ""
            return ""

        messages = BUSINESS_RULE_MESSAGES[self.language]
        summary_lines = [messages["summary_header"]]
        for err in self.errors:
            summary_lines.append(f"- {err['message']}")

        # U-043: 언어 혼합 에러가 있으면 상세 지시 추가
        if self.language_gate_result and not self.language_gate_result.is_valid:
            summary_lines.append("")
            summary_lines.append(build_language_error_summary(self.language_gate_result))

        self.error_summary = "\n".join(summary_lines)
        return self.error_summary


# =============================================================================
# 개별 검증 함수
# =============================================================================


def _validate_economy(
    turn_input: TurnInput,
    turn_output: TurnOutput,
    result: BusinessRuleValidationResult,
) -> None:
    """Economy 규칙을 검증합니다 (RULE-005).

    검증 항목:
    - 잔액 음수 금지
    - snapshot 대비 과도한 비용 청구 금지
    - cost와 balance_after 일관성
    """
    economy = turn_output.economy
    snapshot = turn_input.economy_snapshot
    messages = BUSINESS_RULE_MESSAGES[result.language]

    # 1. 과도한 비용 청구 금지 (snapshot < cost)
    if snapshot.signal < economy.cost.signal:
        result.add_error(
            BusinessRuleError.ECONOMY_NEGATIVE_BALANCE,
            messages["signal_insufficient"].format(have=snapshot.signal, need=economy.cost.signal),
        )

    if snapshot.memory_shard < economy.cost.memory_shard:
        result.add_error(
            BusinessRuleError.ECONOMY_NEGATIVE_BALANCE,
            messages["memory_shard_insufficient"].format(
                have=snapshot.memory_shard, need=economy.cost.memory_shard
            ),
        )

    # 2. 잔액 음수 금지 (이미 필드 수준 ge=0 검증이 있지만, 비즈니스 룰에서도 명시)
    if economy.balance_after.signal < 0:
        result.add_error(
            BusinessRuleError.ECONOMY_NEGATIVE_BALANCE,
            messages["signal_negative"].format(value=economy.balance_after.signal),
        )

    if economy.balance_after.memory_shard < 0:
        result.add_error(
            BusinessRuleError.ECONOMY_NEGATIVE_BALANCE,
            messages["memory_shard_negative"].format(value=economy.balance_after.memory_shard),
        )

    # 3. cost와 balance_after 일관성 검증
    # balance_after = snapshot - cost 여야 함
    expected_signal = snapshot.signal - economy.cost.signal
    expected_shard = snapshot.memory_shard - economy.cost.memory_shard

    # 이미 위에서 snapshot < cost 체크를 했으므로,
    # 여기서는 단순 일치 여부만 확인 (음수 결과는 위에서 차단됨)
    if economy.balance_after.signal != expected_signal:
        result.add_error(
            BusinessRuleError.ECONOMY_COST_MISMATCH,
            messages["signal_mismatch"].format(
                expected=expected_signal, actual=economy.balance_after.signal
            ),
        )

    if economy.balance_after.memory_shard != expected_shard:
        result.add_error(
            BusinessRuleError.ECONOMY_COST_MISMATCH,
            messages["memory_shard_mismatch"].format(
                expected=expected_shard, actual=economy.balance_after.memory_shard
            ),
        )


def _validate_language(
    turn_input: TurnInput,
    turn_output: TurnOutput,
    result: BusinessRuleValidationResult,
) -> None:
    """Language 규칙을 검증합니다 (RULE-006).

    검증 항목:
    - TurnInput.language와 TurnOutput.language 일치
    """
    if turn_input.language != turn_output.language:
        messages = BUSINESS_RULE_MESSAGES[result.language]
        result.add_error(
            BusinessRuleError.LANGUAGE_MISMATCH,
            messages["language_mismatch"].format(
                input_lang=turn_input.language.value,
                output_lang=turn_output.language.value,
            ),
        )


def _validate_language_content(
    turn_input: TurnInput,
    turn_output: TurnOutput,
    result: BusinessRuleValidationResult,
) -> None:
    """Language 콘텐츠 혼합을 검증합니다 (RULE-006, U-043).

    검증 항목:
    - 사용자 노출 텍스트가 TurnInput.language와 동일 언어인지 확인
    - ko/en 혼합 시 LANGUAGE_CONTENT_MIXED 에러 추가
    """
    # 언어 혼합 검증 (U-043)
    lang_result = validate_language_consistency(turn_output, turn_input.language)

    if not lang_result.is_valid:
        messages = BUSINESS_RULE_MESSAGES[result.language]
        result.add_error(
            BusinessRuleError.LANGUAGE_CONTENT_MIXED,
            messages["language_content_mixed"].format(violation_count=len(lang_result.violations)),
        )
        # 상세 에러 요약 생성을 위해 결과 저장
        result.language_gate_result = lang_result


def _validate_box2d(
    turn_output: TurnOutput,
    result: BusinessRuleValidationResult,
) -> None:
    """Box2D 좌표 규칙을 검증합니다 (RULE-009).

    검증 항목:
    - 0~1000 범위
    - ymin < ymax, xmin < xmax 순서
    """
    messages = BUSINESS_RULE_MESSAGES[result.language]

    # UI 오브젝트의 box2d 검증
    for obj in turn_output.ui.objects:
        box = obj.box_2d

        # 범위 검증 (0~1000)
        coords = [box.ymin, box.xmin, box.ymax, box.xmax]
        for coord in coords:
            if coord < 0 or coord > 1000:
                result.add_error(
                    BusinessRuleError.BOX2D_OUT_OF_RANGE,
                    messages["box2d_out_of_range"].format(obj_id=obj.id, coord=coord),
                )
                break  # 한 오브젝트에 대해 한 번만 보고

        # 순서 검증 (ymin < ymax, xmin < xmax)
        if box.ymin >= box.ymax:
            result.add_error(
                BusinessRuleError.BOX2D_INVALID_ORDER,
                messages["box2d_invalid_yorder"].format(
                    obj_id=obj.id, ymin=box.ymin, ymax=box.ymax
                ),
            )

        if box.xmin >= box.xmax:
            result.add_error(
                BusinessRuleError.BOX2D_INVALID_ORDER,
                messages["box2d_invalid_xorder"].format(
                    obj_id=obj.id, xmin=box.xmin, xmax=box.xmax
                ),
            )


def _validate_safety(
    turn_output: TurnOutput,
    result: BusinessRuleValidationResult,
) -> None:
    """Safety 규칙을 검증합니다.

    검증 항목:
    - blocked 시 안전한 대체 결과(narrative) 제공 확인
    """
    safety = turn_output.safety
    messages = BUSINESS_RULE_MESSAGES[result.language]

    # 차단 시에도 narrative가 있어야 함 (안전한 대체 결과)
    if safety.blocked and (not turn_output.narrative or len(turn_output.narrative.strip()) == 0):
        result.add_error(
            BusinessRuleError.SAFETY_BLOCKED_NO_FALLBACK,
            messages["safety_blocked_no_fallback"],
        )


# =============================================================================
# 메인 검증 함수
# =============================================================================


def validate_business_rules(
    turn_input: TurnInput,
    turn_output: TurnOutput,
) -> BusinessRuleValidationResult:
    """비즈니스 룰을 검증합니다.

    스키마 검증 이후 호출되며, 의미적 규칙을 검증합니다.
    에러 메시지는 turn_input.language에 따라 분기됩니다 (RULE-006).

    Args:
        turn_input: 사용자 턴 입력
        turn_output: 생성된 턴 출력

    Returns:
        BusinessRuleValidationResult: 검증 결과

    Example:
        >>> result = validate_business_rules(turn_input, turn_output)
        >>> if not result.is_valid:
        ...     print(result.build_summary())
    """
    # RU-005-S2: turn_input.language에 따라 에러 메시지 i18n 분기
    result = BusinessRuleValidationResult(language=turn_input.language)

    # 1. Economy 검증 (RULE-005)
    _validate_economy(turn_input, turn_output, result)

    # 2. Language enum 검증 (RULE-006)
    _validate_language(turn_input, turn_output, result)

    # 3. Language 콘텐츠 혼합 검증 (RULE-006, U-043)
    _validate_language_content(turn_input, turn_output, result)

    # 4. Box2D 검증 (RULE-009)
    _validate_box2d(turn_output, result)

    # 5. Safety 검증
    _validate_safety(turn_output, result)

    # 에러 요약 생성
    if not result.is_valid:
        result.build_summary()
        logger.warning(
            "[BusinessRules] 검증 실패",
            extra={"error_count": len(result.errors)},
        )

    return result
</file>

<file path="backend/tests/integration/test_turn_streaming.py">
"""Unknown World - /api/turn HTTP Streaming 통합 테스트.

NDJSON 스트리밍 이벤트의 순서, 구조, 데이터 정밀도를 검증합니다.
"""

import json

from fastapi.testclient import TestClient

from unknown_world.main import app
from unknown_world.models.turn import Language, TurnOutput

client = TestClient(app)


def test_turn_streaming_success():
    """정상적인 턴 요청 시 NDJSON 스트림이 올바른 순서로 반환되는지 테스트합니다."""
    payload = {
        "language": "ko-KR",
        "text": "테스트 입력",
        "client": {"viewport_w": 1920, "viewport_h": 1080, "theme": "dark"},
        "economy_snapshot": {"signal": 100, "memory_shard": 5},
    }

    # StreamingResponse 테스트
    response = client.post("/api/turn", json=payload)
    assert response.status_code == 200
    assert response.headers["content-type"] == "application/x-ndjson"

    events = []
    for line in response.iter_lines():
        if line:
            events.append(json.loads(line))

    # 1. 이벤트 존재 여부 확인
    assert len(events) > 0

    # 2. 첫 번째 이벤트는 항상 stage: parse: start 여야 함 (TTFB)
    assert events[0]["type"] == "stage"
    assert events[0]["name"] == "parse"
    assert events[0]["status"] == "start"

    # 3. 단계별 이벤트 순서 확인
    stages = [e["name"] for e in events if e["type"] == "stage" and e["status"] == "start"]
    expected_stages = ["parse", "validate", "plan", "resolve", "render", "verify", "commit"]
    assert stages == expected_stages

    # 4. 배지 이벤트 포함 여부 확인
    badges_events = [e for e in events if e["type"] == "badges"]
    assert len(badges_events) >= 2
    assert "schema_ok" in badges_events[0]["badges"]

    # 5. 최종 결과물 확인
    final_events = [e for e in events if e["type"] == "final"]
    assert len(final_events) == 1

    turn_output_data = final_events[0]["data"]
    # Pydantic 모델로 다시 검증 (RULE-003)
    turn_output = TurnOutput.model_validate(turn_output_data)
    assert turn_output.language == Language.KO
    assert len(turn_output.narrative) > 0


def test_turn_streaming_invalid_input():
    """잘못된 입력 요청 시 에러 이벤트가 스트리밍되는지 테스트합니다."""
    payload = {
        "language": "invalid-lang",  # 잘못된 언어 코드
        "text": "",
    }

    response = client.post("/api/turn", json=payload)
    # 입력 검증 실패 시에도 200 OK 스트림으로 에러를 보낼 수도 있고,
    # 400 Bad Request를 보낼 수도 있음. 현재 구현은 200 OK + type: error 임.
    assert response.status_code == 200

    events = [json.loads(line) for line in response.iter_lines() if line]
    assert any(e["type"] == "error" for e in events)
    assert any(e["code"] == "VALIDATION_ERROR" for e in events)


def test_turn_streaming_deterministic_seed():
    """seed 파라미터 사용 시 결과가 결정적인지 테스트합니다."""
    payload = {
        "language": "en-US",
        "text": "Hello",
        "client": {"viewport_w": 1920, "viewport_h": 1080},
        "economy_snapshot": {"signal": 100, "memory_shard": 5},
    }

    # 동일한 시드로 두 번 요청
    seed = 12345

    def get_final_output(s):
        resp = client.post(f"/api/turn?seed={s}", json=payload)
        events = [json.loads(line) for line in resp.iter_lines() if line]
        return next(e["data"] for e in events if e["type"] == "final")

    output1 = get_final_output(seed)
    output2 = get_final_output(seed)

    assert output1 == output2
    assert output1["language"] == "en-US"


def test_turn_streaming_generation_fallback(monkeypatch):
    """생성 중 ValidationError 발생 시 안전한 폴백이 반환되는지 테스트합니다."""
    from pydantic import ValidationError

    from unknown_world.orchestrator.mock import MockOrchestrator

    def mock_generate_failure(self, turn_input):
        # Pydantic ValidationError를 수동으로 생성하는 것은 복잡하므로
        # 간단한 필드 검증 오류를 시뮬레이션하거나 직접 raise 함
        # 여기서는 테스트를 위해 임의의 필드 누락 등으로 발생한다고 가정
        raise ValidationError.from_exception_data(title="MockError", line_errors=[])

    monkeypatch.setattr(MockOrchestrator, "generate_turn_output", mock_generate_failure)

    payload = {
        "language": "ko-KR",
        "text": "테스트",
        "client": {"viewport_w": 1920, "viewport_h": 1080},
        "economy_snapshot": {"signal": 100, "memory_shard": 5},
    }

    response = client.post("/api/turn", json=payload)
    events = [json.loads(line) for line in response.iter_lines() if line]

    final_event = next(e for e in events if e["type"] == "final")
    turn_output = final_event["data"]

    # 폴백 응답의 특징 확인
    # RU-005-Q1: SSOT fallback은 모든 카테고리의 배지를 일관되게 포함 (RU-005-S1)
    badges = turn_output["agent_console"]["badges"]
    assert "schema_fail" in badges, "폴백은 schema_fail 배지를 포함해야 함"
    assert "economy_ok" in badges, "폴백은 economy_ok 배지를 포함해야 함 (비용 0)"
    assert "safety_ok" in badges, "폴백은 safety_ok 배지를 포함해야 함"
    assert "consistency_ok" in badges, "폴백은 consistency_ok 배지를 포함해야 함"
    assert turn_output["agent_console"]["repair_count"] >= 1
    assert "혼란" in turn_output["narrative"] or "confusion" in turn_output["narrative"]


def test_turn_streaming_repair_loop(monkeypatch):
    """검증 실패 시 repair 이벤트가 스트림에 포함되는지 테스트합니다 (RU-002)."""
    from pydantic import ValidationError

    from unknown_world.orchestrator.mock import MockOrchestrator

    # 첫 번째 호출에서 실패하여 repair 트리거 시뮬레이션
    # (실제 구현에서는 N회 재시도 로직이 turn.py에 있어야 함)
    call_count = 0

    def mock_generate_with_repair(self, turn_input):
        nonlocal call_count
        call_count += 1
        if call_count == 1:
            raise ValidationError.from_exception_data(title="MockSchemaError", line_errors=[])
        return orchestrator_orig_generate(self, turn_input)

    import unknown_world.orchestrator.mock as mock_mod

    orchestrator_orig_generate = mock_mod.MockOrchestrator.generate_turn_output
    monkeypatch.setattr(MockOrchestrator, "generate_turn_output", mock_generate_with_repair)

    payload = {
        "language": "ko-KR",
        "text": "리페어 테스트",
        "client": {"viewport_w": 1920, "viewport_h": 1080},
        "economy_snapshot": {"signal": 100, "memory_shard": 5},
    }

    response = client.post("/api/turn", json=payload)
    events = [json.loads(line) for line in response.iter_lines() if line]

    # RU-002 요구사항: repair 이벤트가 명시적으로 존재해야 함
    repair_events = [e for e in events if e["type"] == "repair"]
    assert len(repair_events) >= 1
    assert "attempt" in repair_events[0]
    assert repair_events[0]["attempt"] == 1
</file>

<file path="backend/tests/unit/test_u034_verification.py">
import json
from pathlib import Path

# 프로젝트 루트 경로 설정 (backend/tests/unit/ 위치 기준)
ROOT_DIR = Path(__file__).parent.parent.parent.parent
SCHEMA_PATH = ROOT_DIR / "vibe/ref/nanobanana-asset-request.schema.json"
GUIDE_PATH = ROOT_DIR / "vibe/ref/nanobanana-mcp.md"


def test_schema_file_exists():
    """스키마 파일이 지정된 위치에 존재하는지 확인"""
    assert SCHEMA_PATH.exists(), f"Schema file not found at {SCHEMA_PATH}"


def test_schema_is_valid_json():
    """스키마 파일이 유효한 JSON 형식인지 확인"""
    with open(SCHEMA_PATH, encoding="utf-8") as f:
        schema = json.load(f)
    assert schema["title"] == "nanobanana mcp Asset Request Schema"


def test_schema_required_properties():
    """스키마의 JSON Schema required 필드가 정의되어 있는지 확인

    NOTE: JSON Schema의 `required` 배열과 "워크플로우 필수(조건부)" 필드는 구분됨.
    - Schema required: ["id", "category", "purpose", "size_px"] (SSOT)
    - Workflow required: requires_rembg, rembg_options.model 등은 조건부 필드
    """
    with open(SCHEMA_PATH, encoding="utf-8") as f:
        schema = json.load(f)

    properties = schema.get("properties", {})
    # JSON Schema의 required 필드만 검증 (스키마 SSOT 기준)
    schema_required_fields = ["id", "category", "purpose", "size_px"]
    # 워크플로우에서 자주 사용하는 선택적 필드 (properties에 정의되어 있어야 함)
    optional_workflow_fields = ["requires_rembg", "rembg_options"]

    for field in schema_required_fields:
        assert field in properties, f"Schema required field '{field}' missing in properties"

    for field in optional_workflow_fields:
        assert field in properties, f"Workflow field '{field}' missing in properties"


def test_schema_rembg_options_model():
    """rembg 모델 선택의 SSOT가 rembg_options.model인지 확인

    NOTE: 이전에 top-level rembg_model 필드가 논의되었으나,
    SSOT는 rembg_options.model로 확정됨 (U-040 페어링 결정).
    """
    with open(SCHEMA_PATH, encoding="utf-8") as f:
        schema = json.load(f)

    # rembg_options가 존재하고 model 서브필드가 있어야 함
    rembg_options = schema["properties"].get("rembg_options", {})
    assert rembg_options.get("type") == "object", "rembg_options should be an object"

    rembg_options_props = rembg_options.get("properties", {})
    assert "model" in rembg_options_props, (
        "SSOT field 'rembg_options.model' missing - "
        "rembg 모델 선택은 top-level 'rembg_model'이 아닌 'rembg_options.model'이 SSOT입니다"
    )

    # model 필드의 enum이 유효한 rembg 모델 목록을 포함하는지 확인
    model_field = rembg_options_props["model"]
    assert "enum" in model_field, "rembg_options.model should have enum constraint"
    assert "birefnet-general" in model_field["enum"], (
        "Default model 'birefnet-general' should be in enum"
    )


def test_guide_file_exists():
    """가이드 문서 파일이 존재하는지 확인"""
    assert GUIDE_PATH.exists(), f"Guide file not found at {GUIDE_PATH}"


def test_guide_content_completeness():
    """가이드 문서에 필수 섹션(아트 디렉션, 카테고리별 템플릿)이 포함되어 있는지 확인"""
    with open(GUIDE_PATH, encoding="utf-8") as f:
        content = f.read()

    # 계획서 구현 흐름 2단계, 3단계 관련 키워드 검사
    required_keywords = ["아트 디렉션", "스타일", "아이콘", "placeholder", "chrome", "템플릿"]

    missing_keywords = [kw for kw in required_keywords if kw.lower() not in content.lower()]

    # 현재 nanobanana-mcp.md에는 rembg 내용만 있으므로 실패할 가능성이 큼
    assert not missing_keywords, (
        f"Guide document is missing sections for: {', '.join(missing_keywords)}"
    )


def test_schema_rembg_rules():
    """배경 제거(rembg) 관련 강제 규칙(순백 배경)이 스키마/설명에 포함되어 있는지 확인"""
    with open(SCHEMA_PATH, encoding="utf-8") as f:
        schema = json.load(f)

    # background 필드와 requires_rembg 필드 설명 확인
    background_desc = schema["properties"]["background"].get("description", "")
    rembg_desc = schema["properties"]["requires_rembg"].get("description", "")

    assert "solid_white" in str(schema["properties"]["background"].get("enum", [])), (
        "background enum should include solid_white"
    )
    assert "rembg" in background_desc.lower(), "background description should mention rembg"
    assert "solid_white" in rembg_desc.lower(), (
        "requires_rembg description should recommend solid_white"
    )
</file>

<file path="shared/schemas/turn/turn_input.schema.json">
{
  "$schema": "http://json-schema.org/draft-07/schema#",
  "$id": "https://unknown-world.dev/schemas/turn/turn_input.schema.json",
  "title": "TurnInput",
  "description": "Client → Server 턴 요청 스키마 (MVP). PRD 8.7절 기반.",
  "type": "object",
  "properties": {
    "language": {
      "type": "string",
      "enum": ["ko-KR", "en-US"],
      "description": "게임 언어 설정 (ko-KR 또는 en-US)"
    },
    "text": {
      "type": "string",
      "description": "사용자 입력 (자연어)"
    },
    "click": {
      "type": ["object", "null"],
      "description": "클릭된 오브젝트 정보 (선택)",
      "properties": {
        "object_id": {
          "type": "string",
          "description": "클릭된 오브젝트 ID"
        },
        "box_2d": {
          "type": ["array", "null"],
          "description": "bbox [ymin, xmin, ymax, xmax] (0~1000 정규화)",
          "items": {
            "type": "integer",
            "minimum": 0,
            "maximum": 1000
          },
          "minItems": 4,
          "maxItems": 4
        }
      },
      "required": ["object_id"]
    },
    "client": {
      "type": "object",
      "description": "클라이언트 환경 정보",
      "properties": {
        "viewport_w": {
          "type": "integer",
          "description": "뷰포트 너비 (px)"
        },
        "viewport_h": {
          "type": "integer",
          "description": "뷰포트 높이 (px)"
        },
        "theme": {
          "type": "string",
          "enum": ["dark", "light"],
          "description": "테마 설정"
        }
      },
      "required": ["viewport_w", "viewport_h", "theme"]
    },
    "economy_snapshot": {
      "type": "object",
      "description": "현재 재화 상태 스냅샷",
      "properties": {
        "signal": {
          "type": "integer",
          "minimum": 0,
          "description": "Signal 재화 잔액"
        },
        "memory_shard": {
          "type": "integer",
          "minimum": 0,
          "description": "Memory Shard 재화 잔액"
        }
      },
      "required": ["signal", "memory_shard"]
    }
  },
  "required": ["language", "text", "client", "economy_snapshot"],
  "additionalProperties": false
}
</file>

<file path="backend/src/unknown_world/models/turn.py">
"""Unknown World - TurnInput/TurnOutput Pydantic 스키마.

이 모듈은 Unknown World의 핵심 데이터 모델을 정의합니다.
Gemini Structured Outputs에 투입 가능한 JSON Schema(부분집합)를 생성할 수 있습니다.

설계 원칙:
    - RULE-003: 구조화 출력(JSON Schema) 우선 + 이중 검증
    - RULE-005: 재화 인바리언트 (cost, balance_after 필수, 잔액 음수 금지)
    - RULE-006: ko/en 언어 정책 (Language enum으로 고정)
    - RULE-009: 좌표 규약 (0~1000, bbox [ymin,xmin,ymax,xmax])

사용 예시:
    # Gemini Structured Outputs용 JSON Schema 생성
    schema = TurnOutput.model_json_schema()

    # 응답 검증
    output = TurnOutput.model_validate_json(gemini_response_text)

참조:
    - vibe/prd.md 8.7 (데이터 모델 설계)
    - vibe/ref/structured-outputs-guide.md
    - .cursor/rules/00-core-critical.mdc
"""

from enum import Enum
from typing import Annotated

from pydantic import BaseModel, ConfigDict, Field

# =============================================================================
# 공통 Enum 타입
# =============================================================================


class Language(str, Enum):
    """지원 언어 (RULE-006).

    ko/en 혼합 출력 금지. TurnInput.language를 SSOT로 삼아
    모든 UI/내러티브/시스템 메시지는 동일 언어로 고정합니다.
    """

    KO = "ko-KR"
    EN = "en-US"


class Theme(str, Enum):
    """테마 설정."""

    DARK = "dark"
    LIGHT = "light"


class AgentPhase(str, Enum):
    """에이전트 실행 단계 (RULE-008).

    에이전트형 시스템임을 UI로 증명하기 위한 단계 표시.
    """

    PARSE = "parse"
    VALIDATE = "validate"
    PLAN = "plan"
    RESOLVE = "resolve"
    RENDER = "render"
    VERIFY = "verify"
    COMMIT = "commit"


class ValidationBadge(str, Enum):
    """검증 배지 (RULE-008).

    턴 결과에 대한 검증 상태를 표시합니다.
    """

    SCHEMA_OK = "schema_ok"
    SCHEMA_FAIL = "schema_fail"
    ECONOMY_OK = "economy_ok"
    ECONOMY_FAIL = "economy_fail"
    SAFETY_OK = "safety_ok"
    SAFETY_BLOCKED = "safety_blocked"
    CONSISTENCY_OK = "consistency_ok"
    CONSISTENCY_FAIL = "consistency_fail"


class ModelLabel(str, Enum):
    """모델/품질 선택 라벨 (RULE-008).

    프롬프트 노출 없이 "왜 이 선택이었는지"를 사용자 친화 라벨로 표시.
    """

    FAST = "FAST"
    QUALITY = "QUALITY"
    CHEAP = "CHEAP"
    REF = "REF"


class RiskLevel(str, Enum):
    """행동 위험도 수준."""

    LOW = "low"
    MEDIUM = "medium"
    HIGH = "high"


# =============================================================================
# 공통 하위 타입
# =============================================================================

# RULE-009: 좌표는 0~1000 정규화 좌표계 (이미지 이해 bbox 포맷과 호환)
Coordinate = Annotated[int, Field(ge=0, le=1000, description="정규화 좌표 (0~1000)")]


class Box2D(BaseModel):
    """2D 바운딩 박스 (RULE-009).

    좌표는 0~1000 정규화 좌표계이며, bbox는 [ymin, xmin, ymax, xmax] 순서입니다.
    이미지 이해 bbox 포맷과 호환됩니다.

    Attributes:
        ymin: Y 최소값 (상단)
        xmin: X 최소값 (좌측)
        ymax: Y 최대값 (하단)
        xmax: X 최대값 (우측)
    """

    model_config = ConfigDict(extra="forbid")

    ymin: Coordinate
    xmin: Coordinate
    ymax: Coordinate
    xmax: Coordinate


class CurrencyAmount(BaseModel):
    """재화 수량.

    Attributes:
        signal: 기본 재화 (텍스트 턴/이미지 생성/고급 기능에 소비)
        memory_shard: 희귀 재화 (중요 설정 고정, 고해상도 이미지 등에 소비)
    """

    model_config = ConfigDict(extra="forbid")

    signal: Annotated[int, Field(ge=0, description="시그널 (기본 재화, 0 이상)")]
    memory_shard: Annotated[int, Field(ge=0, description="기억 파편 (희귀 재화, 0 이상)")]


# =============================================================================
# TurnInput 관련 타입
# =============================================================================


class ClickInput(BaseModel):
    """클릭 입력 정보.

    화면 오브젝트 클릭 시 전달되는 정보입니다.

    Attributes:
        object_id: 클릭한 오브젝트 ID
        box_2d: 클릭 위치의 바운딩 박스 (선택)
    """

    model_config = ConfigDict(extra="forbid")

    object_id: str = Field(description="클릭한 오브젝트 ID")
    box_2d: Box2D | None = Field(default=None, description="클릭 위치 바운딩 박스 (선택)")


class DropInput(BaseModel):
    """드롭 입력 정보 (U-012).

    인벤토리 아이템을 핫스팟에 드롭할 때 전달되는 정보입니다.

    Attributes:
        item_id: 드롭한 인벤토리 아이템 ID
        target_object_id: 드롭 대상 핫스팟 오브젝트 ID
        target_box_2d: 드롭 대상의 바운딩 박스 (0~1000 정규화)
    """

    model_config = ConfigDict(extra="forbid")

    item_id: str = Field(description="드롭한 인벤토리 아이템 ID")
    target_object_id: str = Field(description="드롭 대상 핫스팟 오브젝트 ID")
    target_box_2d: Box2D = Field(description="드롭 대상의 바운딩 박스 (0~1000 정규화)")


class ClientInfo(BaseModel):
    """클라이언트 정보.

    Attributes:
        viewport_w: 뷰포트 너비 (픽셀)
        viewport_h: 뷰포트 높이 (픽셀)
        theme: 현재 테마 (dark/light)
    """

    model_config = ConfigDict(extra="forbid")

    viewport_w: Annotated[int, Field(gt=0, description="뷰포트 너비 (픽셀)")]
    viewport_h: Annotated[int, Field(gt=0, description="뷰포트 높이 (픽셀)")]
    theme: Theme = Field(default=Theme.DARK, description="현재 테마")


class EconomySnapshot(BaseModel):
    """재화 스냅샷 (클라이언트 → 서버).

    클라이언트가 보유한 현재 재화 상태입니다.
    서버는 이를 검증하고 비용 계산에 사용합니다.

    Attributes:
        signal: 현재 시그널 잔액
        memory_shard: 현재 기억 파편 잔액
    """

    model_config = ConfigDict(extra="forbid")

    signal: Annotated[int, Field(ge=0, description="현재 시그널 잔액 (0 이상)")]
    memory_shard: Annotated[int, Field(ge=0, description="현재 기억 파편 잔액 (0 이상)")]


class TurnInput(BaseModel):
    """턴 입력 (클라이언트 → 서버).

    사용자가 턴을 진행할 때 서버로 전송하는 입력 데이터입니다.

    Attributes:
        language: 요청 언어 (응답도 동일 언어로 고정)
        text: 사용자 자연어 입력
        action_id: 선택한 액션 카드 ID (선택)
        click: 오브젝트 클릭 정보 (선택)
        client: 클라이언트 환경 정보
        economy_snapshot: 현재 재화 상태

    Example:
        >>> input_data = TurnInput(
        ...     language=Language.KO,
        ...     text="문을 열어본다",
        ...     economy_snapshot=EconomySnapshot(signal=100, memory_shard=5),
        ...     client=ClientInfo(viewport_w=1920, viewport_h=1080),
        ... )
    """

    model_config = ConfigDict(extra="forbid")

    language: Language = Field(description="요청 언어 (응답도 동일 언어로 고정)")
    text: str = Field(default="", description="사용자 자연어 입력")
    action_id: str | None = Field(default=None, description="선택한 액션 카드 ID (선택)")
    click: ClickInput | None = Field(default=None, description="오브젝트 클릭 정보 (선택)")
    drop: DropInput | None = Field(default=None, description="아이템 드롭 정보 (선택, U-012)")
    client: ClientInfo = Field(description="클라이언트 환경 정보")
    economy_snapshot: EconomySnapshot = Field(description="현재 재화 상태")


# =============================================================================
# TurnOutput 관련 타입 - UI
# =============================================================================


class CostEstimate(BaseModel):
    """비용 추정치 (최소/최대 범위)."""

    model_config = ConfigDict(extra="forbid")

    min: CurrencyAmount = Field(description="최소 예상 비용")
    max: CurrencyAmount = Field(description="최대 예상 비용")


class ActionCard(BaseModel):
    """액션 카드 (Action Deck).

    매 턴 AI가 추천하는 행동 카드입니다.
    각 카드에 비용/위험/보상 힌트가 포함됩니다.

    Attributes:
        id: 카드 고유 ID
        label: 카드 라벨 (표시용)
        description: 카드 설명 (선택)
        cost: 예상 비용 (기본)
        cost_estimate: 비용 추정 범위 (선택)
        risk: 위험도
        hint: 예상 결과 힌트 (선택)
        reward_hint: 보상 힌트 (선택)
        enabled: 실행 가능 여부 (서버 판단)
        disabled_reason: 비활성화 사유 (선택)
        is_alternative: 저비용 대안 카드 여부
    """

    model_config = ConfigDict(extra="forbid")

    id: str = Field(description="카드 고유 ID")
    label: str = Field(description="카드 라벨 (표시용)")
    description: str | None = Field(default=None, description="카드 설명 (선택)")
    cost: CurrencyAmount = Field(description="예상 비용 (기본)")
    cost_estimate: CostEstimate | None = Field(default=None, description="비용 추정 범위 (선택)")
    risk: RiskLevel = Field(default=RiskLevel.LOW, description="위험도")
    hint: str | None = Field(default=None, description="예상 결과 힌트 (선택)")
    reward_hint: str | None = Field(default=None, description="보상 힌트 (선택)")
    enabled: bool = Field(default=True, description="실행 가능 여부 (서버 판단)")
    disabled_reason: str | None = Field(default=None, description="비활성화 사유 (선택)")
    is_alternative: bool = Field(default=False, description="저비용 대안 카드 여부")


class SceneObject(BaseModel):
    """장면 오브젝트 (클릭 가능한 핫스팟).

    화면에서 클릭 가능한 오브젝트입니다.
    좌표는 0~1000 정규화 좌표계를 사용합니다 (RULE-009).

    Attributes:
        id: 오브젝트 고유 ID
        label: 오브젝트 라벨 (표시용)
        box_2d: 바운딩 박스 [ymin, xmin, ymax, xmax]
        interaction_hint: 상호작용 힌트 (선택)
    """

    model_config = ConfigDict(extra="forbid")

    id: str = Field(description="오브젝트 고유 ID")
    label: str = Field(description="오브젝트 라벨 (표시용)")
    box_2d: Box2D = Field(description="바운딩 박스")
    interaction_hint: str | None = Field(default=None, description="상호작용 힌트 (선택)")


class ActionDeck(BaseModel):
    """액션 덱 (Q1 결정: ui.action_deck.cards[] 구조).

    매 턴 AI가 제시하는 추천 행동 카드 덱입니다.

    Attributes:
        cards: 액션 카드 목록 (3~6장 권장)
    """

    model_config = ConfigDict(extra="forbid")

    cards: list[ActionCard] = Field(
        default=[],
        min_length=0,
        max_length=10,
        description="액션 카드 목록 (3~6장 권장)",
    )


class UIOutput(BaseModel):
    """UI 출력 데이터.

    AI가 생성한 UI 요소들입니다.
    채팅 버블이 아닌 게임 UI로 표현됩니다 (RULE-002).

    Attributes:
        action_deck: 액션 카드 덱 (Q1 결정: Option A 채택)
        objects: 클릭 가능한 장면 오브젝트 목록
    """

    model_config = ConfigDict(extra="forbid")

    action_deck: ActionDeck = Field(default_factory=ActionDeck, description="액션 카드 덱")
    objects: list[SceneObject] = Field(default=[], description="클릭 가능한 장면 오브젝트 목록")


# =============================================================================
# TurnOutput 관련 타입 - World
# =============================================================================


class MemoryPin(BaseModel):
    """중요 설정 고정 후보.

    사용자가 Memory Shard를 소비해 고정할 수 있는 중요 설정입니다.

    Attributes:
        id: 핀 고유 ID
        content: 고정할 내용
        cost: 고정에 필요한 비용
    """

    model_config = ConfigDict(extra="forbid")

    id: str = Field(description="핀 고유 ID")
    content: str = Field(description="고정할 내용")
    cost: CurrencyAmount = Field(description="고정에 필요한 비용")


class WorldRule(BaseModel):
    """세계 규칙 (Rule Board).

    현재 세계에 적용 중인 물리 법칙이나 메타 규칙입니다.

    Attributes:
        id: 규칙 고유 ID
        label: 규칙 이름
        description: 규칙 상세 설명 (선택)
    """

    model_config = ConfigDict(extra="forbid")

    id: str = Field(description="규칙 고유 ID")
    label: str = Field(description="규칙 이름")
    description: str | None = Field(default=None, description="규칙 상세 설명 (선택)")


class Quest(BaseModel):
    """퀘스트/목표 (Quest Panel).

    플레이어가 달성해야 하는 현재 목표입니다.

    Attributes:
        id: 퀘스트 고유 ID
        label: 퀘스트 이름
        is_completed: 달성 여부
    """

    model_config = ConfigDict(extra="forbid")

    id: str = Field(description="퀘스트 고유 ID")
    label: str = Field(description="퀘스트 이름")
    is_completed: bool = Field(default=False, description="달성 여부")


class WorldDelta(BaseModel):
    """세계 상태 변화 (Q2 결정: Option A - delta 중심).

    이번 턴에서 변경된 세계 상태를 나타냅니다.
    snapshot은 SaveGame에만 저장하고, 매 턴은 delta만 전송합니다.

    Attributes:
        rules_changed: 변경되거나 추가된 규칙 목록
        inventory_added: 추가된 인벤토리 아이템
        inventory_removed: 제거된 인벤토리 아이템
        quests_updated: 업데이트된 퀘스트(목표) 목록
        relationships_changed: 변경된 관계
        memory_pins: 중요 설정 고정 후보
    """

    model_config = ConfigDict(extra="forbid")

    rules_changed: list[WorldRule] = Field(default=[], description="변경된 규칙 목록")
    inventory_added: list[str] = Field(default=[], description="추가된 인벤토리 아이템")
    inventory_removed: list[str] = Field(default=[], description="제거된 인벤토리 아이템")
    quests_updated: list[Quest] = Field(default=[], description="업데이트된 퀘스트/목표 목록")
    relationships_changed: list[str] = Field(default=[], description="변경된 관계")
    memory_pins: list[MemoryPin] = Field(default=[], description="중요 설정 고정 후보")


# =============================================================================
# TurnOutput 관련 타입 - Render
# =============================================================================


class ImageJob(BaseModel):
    """이미지 생성 작업.

    조건부 이미지 생성/편집 요청입니다.
    이미지 생성이 느릴 경우 텍스트 우선 출력 + Lazy Loading을 사용합니다.

    Attributes:
        should_generate: 이미지를 생성해야 하는지
        prompt: 이미지 생성 프롬프트
        model_label: 모델 선택 라벨 (FAST/QUALITY/CHEAP/REF)
        aspect_ratio: 가로세로 비율 (예: "16:9", "1:1")
        image_size: 이미지 크기 (예: "1024x1024")
        reference_image_ids: 참조 이미지 ID 목록 (선택)
        remove_background: 배경 제거 여부 (U-035, rembg 사용)
        image_type_hint: 이미지 유형 힌트 (rembg 모델 자동 선택용)
    """

    model_config = ConfigDict(extra="forbid")

    should_generate: bool = Field(description="이미지를 생성해야 하는지")
    prompt: str = Field(default="", description="이미지 생성 프롬프트")
    model_label: ModelLabel = Field(default=ModelLabel.FAST, description="모델 선택 라벨")
    aspect_ratio: str = Field(default="16:9", description="가로세로 비율")
    image_size: str = Field(default="1024x1024", description="이미지 크기")
    reference_image_ids: list[str] = Field(default=[], description="참조 이미지 ID 목록 (선택)")
    remove_background: bool = Field(default=False, description="배경 제거 여부 (U-035, rembg 사용)")
    image_type_hint: str | None = Field(
        default=None,
        description="이미지 유형 힌트 (object/character/icon/portrait 등, rembg 모델 자동 선택용)",
    )


class RenderOutput(BaseModel):
    """렌더링 출력 데이터.

    이미지 생성/편집 관련 정보입니다.

    Attributes:
        image_job: 이미지 생성 작업 (선택)
    """

    model_config = ConfigDict(extra="forbid")

    image_job: ImageJob | None = Field(default=None, description="이미지 생성 작업 (선택)")


# =============================================================================
# TurnOutput 관련 타입 - Economy
# =============================================================================


class EconomyOutput(BaseModel):
    """경제 출력 데이터 (RULE-005).

    이번 턴의 비용과 잔액 정보입니다.
    잔액 음수는 절대 불가 (서버 Hard gate).

    Attributes:
        cost: 이번 턴에 소비된 비용
        balance_after: 소비 후 잔액

    Important:
        - cost와 balance_after는 항상 포함되어야 합니다.
        - balance_after의 signal과 memory_shard는 0 이상이어야 합니다.
    """

    model_config = ConfigDict(extra="forbid")

    cost: CurrencyAmount = Field(description="이번 턴에 소비된 비용")
    balance_after: CurrencyAmount = Field(description="소비 후 잔액")


# =============================================================================
# TurnOutput 관련 타입 - Safety
# =============================================================================


class SafetyOutput(BaseModel):
    """안전 출력 데이터.

    안전 정책 관련 정보입니다.
    차단 시 명시적 메시지와 함께 안전한 대체 결과를 제공합니다.

    Attributes:
        blocked: 안전 정책에 의해 차단되었는지
        message: 차단 시 사용자에게 표시할 메시지 (선택)
    """

    model_config = ConfigDict(extra="forbid")

    blocked: bool = Field(default=False, description="안전 정책에 의해 차단되었는지")
    message: str | None = Field(default=None, description="차단 시 사용자에게 표시할 메시지 (선택)")


# =============================================================================
# TurnOutput 관련 타입 - Agent Console
# =============================================================================


class AgentConsole(BaseModel):
    """에이전트 콘솔 데이터 (RULE-008).

    에이전트형 시스템임을 UI로 증명하기 위한 정보입니다.
    계획/실행/검증/복구의 흔적을 표시합니다.

    Attributes:
        current_phase: 현재 실행 단계
        badges: 검증 배지 목록
        repair_count: 자동 복구 시도 횟수
    """

    model_config = ConfigDict(extra="forbid")

    current_phase: AgentPhase = Field(default=AgentPhase.COMMIT, description="현재 실행 단계")
    badges: list[ValidationBadge] = Field(default=[], description="검증 배지 목록")
    repair_count: Annotated[int, Field(ge=0, description="자동 복구 시도 횟수")] = 0


# =============================================================================
# TurnOutput (메인 응답 스키마)
# =============================================================================


class TurnOutput(BaseModel):
    """턴 출력 (서버 → 클라이언트).

    서버가 턴 처리 후 클라이언트로 반환하는 구조화된 응답입니다.
    Gemini Structured Outputs(JSON Schema)로 강제됩니다.

    Hard Gate 필드 (RULE-003/004/005):
        - economy: cost와 balance_after 필수, 잔액 음수 금지
        - safety: blocked 시 안전한 대체 결과 제공
        - language: 요청 언어와 동일하게 고정 (혼합 출력 금지)

    Attributes:
        language: 응답 언어 (요청과 동일)
        narrative: 내러티브 텍스트 (표시용)
        ui: UI 요소 (액션 덱, 오브젝트)
        world: 세계 상태 변화 (delta 중심)
        render: 렌더링 정보 (이미지 생성 작업)
        economy: 경제 정보 (비용, 잔액)
        safety: 안전 정책 정보
        agent_console: 에이전트 실행 정보 (단계, 배지, 복구 횟수)

    Example:
        >>> output = TurnOutput(
        ...     language=Language.KO,
        ...     narrative="문이 삐걱거리며 열립니다...",
        ...     economy=EconomyOutput(
        ...         cost=CurrencyAmount(signal=5, memory_shard=0),
        ...         balance_after=CurrencyAmount(signal=95, memory_shard=5),
        ...     ),
        ...     safety=SafetyOutput(blocked=False),
        ... )
        >>> schema = TurnOutput.model_json_schema()

    Schema Generation:
        >>> # Gemini Structured Outputs용 JSON Schema 생성
        >>> json_schema = TurnOutput.model_json_schema()
        >>> # response_json_schema 파라미터에 전달
        >>> config = {
        ...     "response_mime_type": "application/json",
        ...     "response_json_schema": json_schema,
        ... }
    """

    model_config = ConfigDict(extra="forbid")

    # 필수 필드 (Hard Gate)
    language: Language = Field(description="응답 언어 (요청과 동일)")
    narrative: str = Field(description="내러티브 텍스트 (표시용)")
    economy: EconomyOutput = Field(description="경제 정보 (비용, 잔액)")
    safety: SafetyOutput = Field(description="안전 정책 정보")

    # UI 관련 필드
    ui: UIOutput = Field(default_factory=UIOutput, description="UI 요소")

    # 세계 상태 필드
    world: WorldDelta = Field(default_factory=WorldDelta, description="세계 상태 변화 (delta)")

    # 렌더링 필드
    render: RenderOutput = Field(default_factory=RenderOutput, description="렌더링 정보")

    # 에이전트 콘솔 필드
    agent_console: AgentConsole = Field(
        default_factory=AgentConsole, description="에이전트 실행 정보"
    )
</file>

<file path="backend/src/unknown_world/orchestrator/mock.py">
"""Unknown World - 모의 Orchestrator.

실모델(Gemini) 없이 프론트엔드 개발/데모를 지속할 수 있도록
결정적(seed 기반) TurnOutput을 생성하는 모의 Orchestrator입니다.

설계 원칙:
    - RULE-004: 검증 실패 시 안전한 폴백 제공
    - RULE-005: 재화 인바리언트 (잔액 음수 금지)
    - RULE-008: 단계/배지 가시화
    - RULE-009: 좌표 규약 (0~1000, bbox [ymin,xmin,ymax,xmax])

참조:
    - vibe/unit-plans/U-007[Mvp].md
    - .cursor/rules/20-backend-orchestrator.mdc
"""

import random

from unknown_world.models.turn import (
    ActionCard,
    ActionDeck,
    AgentConsole,
    AgentPhase,
    Box2D,
    CurrencyAmount,
    EconomyOutput,
    ImageJob,
    Language,
    MemoryPin,
    ModelLabel,
    Quest,
    RenderOutput,
    RiskLevel,
    SafetyOutput,
    SceneObject,
    TurnInput,
    TurnOutput,
    UIOutput,
    ValidationBadge,
    WorldDelta,
    WorldRule,
)
from unknown_world.orchestrator.fallback import (
    create_safe_fallback as _create_safe_fallback,
)

# =============================================================================
# 모의 데이터 생성 헬퍼
# =============================================================================

# 한국어 내러티브 템플릿
KO_NARRATIVES = [
    "어둠 속에서 희미한 빛이 새어나옵니다. 오래된 문이 삐걱거리며 열리고, 그 너머로 알 수 없는 세계가 펼쳐집니다.",
    "발걸음 소리가 텅 빈 복도에 메아리칩니다. 벽에 걸린 초상화들의 눈이 당신을 따라 움직이는 것 같습니다.",
    "갑자기 바닥이 흔들리며, 벽에서 고대의 문자들이 빛나기 시작합니다. 무언가가 깨어나고 있습니다.",
    "안개가 걷히자, 거대한 탑이 모습을 드러냅니다. 탑 꼭대기에서 이상한 빛이 깜빡이고 있습니다.",
    "낡은 책장을 밀자, 숨겨진 통로가 나타났습니다. 통로 끝에서 기묘한 노래가 들려옵니다.",
]

# 영어 내러티브 템플릿
EN_NARRATIVES = [
    "A faint light seeps through the darkness. An ancient door creaks open, revealing an unknown world beyond.",
    "Footsteps echo through the empty corridor. The eyes of the portraits on the walls seem to follow you.",
    "Suddenly, the ground shakes and ancient runes on the walls begin to glow. Something is awakening.",
    "As the fog lifts, a massive tower reveals itself. A strange light flickers at its peak.",
    "Pushing aside the old bookshelf, you discover a hidden passage. An eerie song emanates from its depths.",
]

# 한국어 액션 카드 템플릿
KO_ACTION_CARDS = [
    {"label": "문을 열어본다", "description": "조심스럽게 문을 열어 안을 살펴본다"},
    {"label": "주변을 탐색한다", "description": "주변에 유용한 물건이 있는지 찾아본다"},
    {"label": "뒤로 물러선다", "description": "위험을 피해 안전한 곳으로 물러선다"},
    {"label": "말을 걸어본다", "description": "상대방에게 조심스럽게 말을 건다"},
    {"label": "숨어서 지켜본다", "description": "은신하여 상황을 관찰한다"},
    {"label": "공격한다", "description": "위협에 맞서 공격을 시도한다"},
]

# 영어 액션 카드 템플릿
EN_ACTION_CARDS = [
    {"label": "Open the door", "description": "Carefully open the door and look inside"},
    {"label": "Search the area", "description": "Look for useful items nearby"},
    {"label": "Step back", "description": "Retreat to a safe place to avoid danger"},
    {"label": "Speak to them", "description": "Cautiously initiate conversation"},
    {"label": "Hide and observe", "description": "Conceal yourself and watch the situation"},
    {"label": "Attack", "description": "Confront the threat with an attack"},
]

# 장면 오브젝트 템플릿
SCENE_OBJECTS_KO = [
    {"label": "낡은 문", "hint": "클릭하여 열어볼 수 있습니다"},
    {"label": "빛나는 보석", "hint": "수집할 수 있을 것 같습니다"},
    {"label": "수상한 상자", "hint": "무언가 들어있을 수 있습니다"},
    {"label": "벽의 스위치", "hint": "작동시킬 수 있습니다"},
]

SCENE_OBJECTS_EN = [
    {"label": "Old door", "hint": "Click to open"},
    {"label": "Glowing gem", "hint": "It looks collectible"},
    {"label": "Suspicious chest", "hint": "Something might be inside"},
    {"label": "Wall switch", "hint": "Can be activated"},
]


def _generate_random_box(rng: random.Random) -> Box2D:
    """랜덤 바운딩 박스 생성 (0~1000 좌표계)."""
    ymin = rng.randint(0, 700)
    xmin = rng.randint(0, 700)
    ymax = ymin + rng.randint(50, 250)
    xmax = xmin + rng.randint(50, 250)
    # 범위 보정
    ymax = min(ymax, 1000)
    xmax = min(xmax, 1000)
    return Box2D(ymin=ymin, xmin=xmin, ymax=ymax, xmax=xmax)


# =============================================================================
# MockOrchestrator 클래스
# =============================================================================


class MockOrchestrator:
    """모의 Orchestrator.

    실모델(Gemini) 없이 TurnOutput을 생성하는 모의 오케스트레이터입니다.
    seed 기반으로 결정적(재현 가능)인 결과를 생성합니다.

    Note:
        Phase 순서는 pipeline.py의 DEFAULT_STAGES가 SSOT입니다 (RU-005-Q1).

    Attributes:
        seed: 랜덤 시드 (재현성 보장)

    Example:
        >>> orchestrator = MockOrchestrator(seed=42)
        >>> turn_input = TurnInput(
        ...     language=Language.KO,
        ...     text="문을 열어본다",
        ...     client=ClientInfo(viewport_w=1920, viewport_h=1080),
        ...     economy_snapshot=EconomySnapshot(signal=100, memory_shard=5),
        ... )
        >>> output = orchestrator.generate_turn_output(turn_input)
    """

    def __init__(self, seed: int | None = None) -> None:
        """MockOrchestrator 초기화.

        Args:
            seed: 랜덤 시드. None이면 랜덤하게 생성.
        """
        self.seed = seed if seed is not None else random.randint(0, 2**32 - 1)
        self._rng = random.Random(self.seed)

    def generate_turn_output(self, turn_input: TurnInput) -> TurnOutput:
        """TurnInput을 받아 TurnOutput을 생성합니다.

        Args:
            turn_input: 사용자 입력

        Returns:
            TurnOutput: 모의 턴 결과
        """
        is_korean = turn_input.language == Language.KO

        # 내러티브 생성
        narratives = KO_NARRATIVES if is_korean else EN_NARRATIVES
        narrative = self._rng.choice(narratives)

        # 사용자 텍스트가 있으면 반영
        if turn_input.text:
            prefix = (
                f'당신은 "{turn_input.text}"라고 말했습니다. '
                if is_korean
                else f'You said "{turn_input.text}". '
            )
            narrative = prefix + narrative

        # 액션 덱 생성 (3~6장)
        action_templates = KO_ACTION_CARDS if is_korean else EN_ACTION_CARDS
        num_cards = self._rng.randint(3, 6)
        selected_templates = self._rng.sample(
            action_templates, min(num_cards, len(action_templates))
        )

        action_cards: list[ActionCard] = []
        for i, template in enumerate(selected_templates):
            cost_signal = self._rng.randint(1, 10)
            cost_shard = 1 if self._rng.random() < 0.2 else 0  # 20% 확률로 shard 소비

            action_cards.append(
                ActionCard(
                    id=f"action_{i + 1}",
                    label=template["label"],
                    description=template["description"],
                    cost=CurrencyAmount(signal=cost_signal, memory_shard=cost_shard),
                    risk=self._rng.choice(list(RiskLevel)),
                    hint=None,
                )
            )

        action_deck = ActionDeck(cards=action_cards)

        # 장면 오브젝트 생성 (1~3개)
        object_templates = SCENE_OBJECTS_KO if is_korean else SCENE_OBJECTS_EN
        num_objects = self._rng.randint(1, 3)
        selected_objects = self._rng.sample(
            object_templates, min(num_objects, len(object_templates))
        )

        scene_objects: list[SceneObject] = []
        for i, template in enumerate(selected_objects):
            scene_objects.append(
                SceneObject(
                    id=f"obj_{i + 1}",
                    label=template["label"],
                    box_2d=_generate_random_box(self._rng),
                    interaction_hint=template["hint"],
                )
            )

        ui_output = UIOutput(action_deck=action_deck, objects=scene_objects)

        # 세계 상태 변화 (delta)
        world_delta = self._generate_world_delta(is_korean)

        # 렌더링 출력 (이미지 생성은 선택적)
        should_generate_image = self._rng.random() < 0.3  # 30% 확률로 이미지 생성
        render_output = RenderOutput(
            image_job=ImageJob(
                should_generate=should_generate_image,
                prompt="A mysterious dungeon scene" if should_generate_image else "",
                model_label=ModelLabel.FAST,
                aspect_ratio="16:9",
                image_size="1024x576",
            )
            if should_generate_image
            else None
        )

        # 경제 출력 (비용 계산)
        turn_cost = CurrencyAmount(
            signal=self._rng.randint(1, 5),
            memory_shard=0,
        )

        # 잔액 계산 (음수 방지 - RULE-005)
        balance_signal = max(0, turn_input.economy_snapshot.signal - turn_cost.signal)
        balance_shard = max(0, turn_input.economy_snapshot.memory_shard - turn_cost.memory_shard)

        economy_output = EconomyOutput(
            cost=turn_cost,
            balance_after=CurrencyAmount(signal=balance_signal, memory_shard=balance_shard),
        )

        # 안전 출력
        safety_output = SafetyOutput(blocked=False, message=None)

        # 에이전트 콘솔
        agent_console = AgentConsole(
            current_phase=AgentPhase.COMMIT,
            badges=[
                ValidationBadge.SCHEMA_OK,
                ValidationBadge.ECONOMY_OK,
                ValidationBadge.SAFETY_OK,
                ValidationBadge.CONSISTENCY_OK,
            ],
            repair_count=0,
        )

        return TurnOutput(
            language=turn_input.language,
            narrative=narrative,
            ui=ui_output,
            world=world_delta,
            render=render_output,
            economy=economy_output,
            safety=safety_output,
            agent_console=agent_console,
        )

    def _generate_world_delta(self, is_korean: bool) -> WorldDelta:
        """세계 상태 변화 생성."""
        # 규칙 변경 (20% 확률)
        rules_changed: list[WorldRule] = []
        if self._rng.random() < 0.2:
            rules_changed.append(
                WorldRule(
                    id="rule_gravity",
                    label="중력 반전" if is_korean else "Gravity Inversion",
                    description=(
                        "이 구역에서는 중력이 반대로 작용합니다"
                        if is_korean
                        else "Gravity works in reverse in this area"
                    ),
                )
            )

        # 인벤토리 추가 (30% 확률)
        inventory_added: list[str] = []
        if self._rng.random() < 0.3:
            items_ko = ["낡은 열쇠", "신비로운 구슬", "고대의 두루마리"]
            items_en = ["Old Key", "Mysterious Orb", "Ancient Scroll"]
            items = items_ko if is_korean else items_en
            inventory_added.append(self._rng.choice(items))

        # 퀘스트 업데이트 (25% 확률)
        quests_updated: list[Quest] = []
        if self._rng.random() < 0.25:
            quests_updated.append(
                Quest(
                    id="quest_explore",
                    label="미지의 영역 탐험" if is_korean else "Explore Unknown Territory",
                    is_completed=self._rng.random() < 0.3,
                )
            )

        # 메모리 핀 (15% 확률)
        memory_pins: list[MemoryPin] = []
        if self._rng.random() < 0.15:
            memory_pins.append(
                MemoryPin(
                    id="pin_1",
                    content="이 장소의 이름은 '잊혀진 성소'"
                    if is_korean
                    else "This place is called 'Forgotten Sanctuary'",
                    cost=CurrencyAmount(signal=0, memory_shard=1),
                )
            )

        return WorldDelta(
            rules_changed=rules_changed,
            inventory_added=inventory_added,
            inventory_removed=[],
            quests_updated=quests_updated,
            relationships_changed=[],
            memory_pins=memory_pins,
        )

    def create_safe_fallback(
        self,
        language: Language,
        error_message: str | None = None,  # noqa: ARG002 - 하위 호환용 (실제로 사용하지 않음)
        economy_snapshot: CurrencyAmount | None = None,
    ) -> TurnOutput:
        """안전한 폴백 TurnOutput 생성 (RULE-004, RU-002-S1).

        스키마 검증 실패 시 반환할 안전한 기본 응답입니다.
        폴백 시 economy.balance_after는 입력 스냅샷을 그대로 유지합니다 (비용 0, 잔액 변화 없음).

        Note:
            이 메서드는 fallback.create_safe_fallback SSOT로 위임합니다 (RU-005-Q1).

        Args:
            language: 응답 언어
            error_message: 에러 메시지 (하위 호환용, 실제 미사용)
            economy_snapshot: 요청 직전 재화 스냅샷 (폴백 시 잔액 유지용)

        Returns:
            TurnOutput: 안전한 폴백 응답
        """
        # RU-005-Q1: fallback SSOT로 위임
        return _create_safe_fallback(
            language=language,
            economy_snapshot=economy_snapshot,
            repair_count=1,  # Mock에서는 기본 복구 시도 1회로 표시
            is_blocked=False,
        )
</file>

<file path="backend/src/unknown_world/orchestrator/repair_loop.py">
"""Unknown World - Repair Loop (제한된 재시도).

스키마/비즈니스 룰 검증 실패 시 자동으로 재시도하는 루프입니다.
max_repair_attempts 내에서 repair 재요청을 수행하고,
최종 실패 시 안전한 폴백으로 종료합니다.

설계 원칙:
    - RULE-004: 검증 실패 시 Repair loop + 안전한 폴백
    - RULE-007/008: 프롬프트 원문/내부 추론 노출 금지, 결과/횟수만 표시

페어링 결정:
    - Q1: max_repair_attempts = 2 (Option A)

참조:
    - vibe/unit-plans/U-018[Mvp].md
    - vibe/unit-results/U-017[Mvp].md
"""

from __future__ import annotations

import logging
from dataclasses import dataclass, field
from typing import TYPE_CHECKING

from unknown_world.config.models import ModelLabel
from unknown_world.models.turn import (
    CurrencyAmount,
    Language,
    TurnInput,
    TurnOutput,
    ValidationBadge,
)
from unknown_world.orchestrator.fallback import create_safe_fallback
from unknown_world.orchestrator.generate_turn_output import (
    GenerationResult,
    GenerationStatus,
    get_turn_output_generator,
)
from unknown_world.validation.business_rules import (
    BusinessRuleValidationResult,
    validate_business_rules,
)

if TYPE_CHECKING:
    pass

# =============================================================================
# 로거 설정 (프롬프트/내부 추론 노출 금지 - RULE-007/008)
# =============================================================================

logger = logging.getLogger(__name__)


# =============================================================================
# 설정 상수
# =============================================================================

# 페어링 결정: Q1 = Option A (2회)
MAX_REPAIR_ATTEMPTS = 2
"""최대 복구 시도 횟수."""


# =============================================================================
# i18n Repair 컨텍스트 메시지 (RULE-006, RU-005-S2)
# =============================================================================

REPAIR_CONTEXT_MESSAGES: dict[Language, dict[str, str]] = {
    Language.KO: {
        "schema_header": "## 이전 시도 결과",
        "schema_error": "응답 형식이 올바르지 않았습니다.",
        "schema_instruction": "TurnOutput JSON Schema를 정확히 준수하여 다시 생성하세요.",
        "business_header": "## 이전 시도 결과",
        "business_instruction": "위 규칙을 준수하여 다시 생성하세요.",
        # U-043: 언어 교정 전용 피드백
        "language_header": "## 언어 혼합 오류",
        "language_instruction": (
            "사용자 노출 텍스트에 영어가 섞여 있습니다. "
            "모든 텍스트를 한국어(ko-KR)로만 작성하세요. "
            "스키마 구조는 유지하고 텍스트 값만 한국어로 수정합니다. "
            "예외: Signal, Shard 등 재화 이름은 영어로 유지 가능합니다."
        ),
    },
    Language.EN: {
        "schema_header": "## Previous Attempt Result",
        "schema_error": "The response format was invalid.",
        "schema_instruction": "Please regenerate following the TurnOutput JSON Schema exactly.",
        "business_header": "## Previous Attempt Result",
        "business_instruction": "Please regenerate following the rules above.",
        # U-043: 언어 교정 전용 피드백
        "language_header": "## Language Mixing Error",
        "language_instruction": (
            "User-facing text contains Korean characters. "
            "Rewrite all text in English (en-US) only. "
            "Keep the schema structure intact and only modify text values to English. "
            "Exception: Currency names like Signal, Shard may remain in English."
        ),
    },
}


# =============================================================================
# Repair Loop 결과 타입
# =============================================================================


@dataclass
class RepairLoopResult:
    """Repair Loop 결과.

    Attributes:
        output: 최종 TurnOutput (성공 또는 폴백)
        total_attempts: 총 시도 횟수 (초기 시도 포함)
        repair_attempts: 복구 시도 횟수 (초기 시도 제외)
        is_fallback: 폴백으로 종료되었는지
        badges: 검증 배지 목록
        error_messages: 각 시도의 에러 메시지 (UI 노출용)
    """

    output: TurnOutput
    total_attempts: int = 1
    repair_attempts: int = 0
    is_fallback: bool = False
    badges: list[ValidationBadge] = field(default_factory=lambda: [])
    error_messages: list[str] = field(default_factory=lambda: [])


# =============================================================================
# Repair Loop 함수
# =============================================================================


async def run_repair_loop(
    turn_input: TurnInput,
    *,
    model_label: ModelLabel | None = None,
    world_context: str = "",
    force_mock: bool = False,
    max_attempts: int = MAX_REPAIR_ATTEMPTS,
) -> RepairLoopResult:
    """Repair Loop를 실행합니다.

    초기 생성을 시도하고, 실패 시 max_attempts까지 재시도합니다.
    최종 실패 시 안전한 폴백을 반환합니다.

    Args:
        turn_input: 사용자 턴 입력
        model_label: 사용할 모델 라벨 (None이면 기본값 FAST)
        world_context: 현재 세계 상태 요약 (선택)
        force_mock: Mock 클라이언트 강제 사용 여부
        max_attempts: 최대 복구 시도 횟수

    Returns:
        RepairLoopResult: 최종 결과 (성공 또는 폴백)

    Example:
        >>> result = await run_repair_loop(turn_input)
        >>> if result.is_fallback:
        ...     print(f"폴백으로 종료 (시도: {result.repair_attempts})")
        >>> print(result.output.narrative)
    """
    generator = get_turn_output_generator(force_mock=force_mock)
    economy_snapshot = CurrencyAmount(
        signal=turn_input.economy_snapshot.signal,
        memory_shard=turn_input.economy_snapshot.memory_shard,
    )

    error_messages: list[str] = []
    badges: list[ValidationBadge] = []
    repair_context = ""  # 재시도 시 추가할 컨텍스트

    last_attempt = 0
    for attempt in range(max_attempts + 1):  # 0 = 초기 시도, 1~max = 복구 시도
        badges = []  # 매 시도마다 배지 초기화 (최종 시도 상태만 유지)
        last_attempt = attempt
        is_repair = attempt > 0

        # 로그 기록 (프롬프트 노출 금지)
        logger.info(
            "[RepairLoop] 시도",
            extra={
                "attempt": attempt,
                "is_repair": is_repair,
                "language": turn_input.language.value,
            },
        )

        # 컨텍스트 구성 (복구 시 에러 요약 추가)
        current_context = world_context
        if is_repair and repair_context:
            current_context = f"{world_context}\n\n{repair_context}"

        # 생성 시도
        gen_result = await generator.generate(
            turn_input,
            model_label=model_label,
            world_context=current_context,
        )

        # 1. 스키마 검증 실패 (JSON 파싱/Pydantic 실패)
        if gen_result.status == GenerationStatus.SCHEMA_FAILURE:
            badges.append(ValidationBadge.SCHEMA_FAIL)
            error_messages.append(gen_result.error_message)
            # RU-005-S2: language에 따라 repair 메시지 분기
            repair_context = _build_repair_context_schema(gen_result, turn_input.language)
            continue

        # 2. API 에러
        if gen_result.status == GenerationStatus.API_ERROR:
            badges.append(ValidationBadge.SCHEMA_FAIL)
            error_messages.append(gen_result.error_message)
            # API 에러는 재시도해도 동일한 결과일 가능성이 높음
            # 하지만 일시적 오류일 수 있으므로 재시도 허용
            repair_context = ""
            continue

        # 3. 스키마 검증 성공 → 비즈니스 룰 검증
        if gen_result.status == GenerationStatus.SUCCESS and gen_result.output:
            badges.append(ValidationBadge.SCHEMA_OK)

            # 비즈니스 룰 검증
            biz_result = validate_business_rules(turn_input, gen_result.output)

            if biz_result.is_valid:
                # 모든 검증 통과
                badges.extend(
                    [
                        ValidationBadge.ECONOMY_OK,
                        ValidationBadge.SAFETY_OK,
                        ValidationBadge.CONSISTENCY_OK,
                    ]
                )

                # 서버 검증 결과로 업데이트 (RULE-003/004/008)
                gen_result.output.agent_console.badges = badges
                gen_result.output.agent_console.repair_count = attempt

                logger.info(
                    "[RepairLoop] 성공",
                    extra={
                        "total_attempts": attempt + 1,
                        "repair_attempts": attempt,
                    },
                )

                return RepairLoopResult(
                    output=gen_result.output,
                    total_attempts=attempt + 1,
                    repair_attempts=attempt,
                    is_fallback=False,
                    badges=badges,
                    error_messages=error_messages,
                )

            # 비즈니스 룰 실패
            add_business_badges(biz_result, badges)
            error_messages.append(biz_result.error_summary)
            # RU-005-S2: language에 따라 repair 메시지 분기
            repair_context = _build_repair_context_business(biz_result, turn_input.language)
            continue

        # 4. 안전 차단
        if gen_result.status == GenerationStatus.SAFETY_BLOCKED:
            badges.append(ValidationBadge.SAFETY_BLOCKED)
            # 안전 차단은 재시도 불가 → 즉시 폴백
            logger.warning(
                "[RepairLoop] 안전 차단으로 폴백",
                extra={"attempt": attempt},
            )
            break

    # 최종 실패 → 안전한 폴백 반환
    logger.warning(
        "[RepairLoop] 최종 폴백 반환",
        extra={
            "max_attempts": max_attempts,
            "actual_attempts": last_attempt,
        },
    )

    fallback = create_safe_fallback(
        language=turn_input.language,
        economy_snapshot=economy_snapshot,
        repair_count=last_attempt,
        is_blocked=ValidationBadge.SAFETY_BLOCKED in badges,
    )

    return RepairLoopResult(
        output=fallback,
        total_attempts=last_attempt + 1,
        repair_attempts=last_attempt,
        is_fallback=True,
        badges=badges,
        error_messages=error_messages,
    )


# =============================================================================
# 헬퍼 함수
# =============================================================================


def _build_repair_context_schema(gen_result: GenerationResult, language: Language) -> str:
    """스키마 실패에 대한 Repair 컨텍스트를 구성합니다.

    프롬프트 원문/상세 오류는 노출하지 않고, 간단한 지시만 포함합니다.
    언어에 따라 메시지를 분기합니다 (RULE-006, RU-005-S2).

    Args:
        gen_result: 생성 결과
        language: 응답 언어
    """
    # 짧은 요약만 포함 (RULE-007/008)
    messages = REPAIR_CONTEXT_MESSAGES[language]
    return f"""
{messages["schema_header"]}

{messages["schema_error"]}
{messages["schema_instruction"]}
"""


def _build_repair_context_business(
    biz_result: BusinessRuleValidationResult, language: Language
) -> str:
    """비즈니스 룰 실패에 대한 Repair 컨텍스트를 구성합니다.

    언어에 따라 메시지를 분기합니다 (RULE-006, RU-005-S2).
    언어 혼합 에러가 있으면 특별한 지시를 추가합니다 (U-043).

    Args:
        biz_result: 비즈니스 룰 검증 결과
        language: 응답 언어
    """
    messages = REPAIR_CONTEXT_MESSAGES[language]

    # U-043: 언어 혼합 에러가 있는지 확인
    has_language_content_error = any(
        "language_content_mixed" in err["type"] for err in biz_result.errors
    )

    # 언어 혼합 에러가 있으면 특별한 지시 추가
    if has_language_content_error:
        return f"""
{messages["language_header"]}

{biz_result.error_summary}

{messages["language_instruction"]}
"""

    # 일반 비즈니스 룰 에러
    return f"""
{messages["business_header"]}

{biz_result.error_summary}

{messages["business_instruction"]}
"""


def add_business_badges(
    biz_result: BusinessRuleValidationResult,
    badges: list[ValidationBadge],
) -> None:
    """비즈니스 룰 검증 결과에 따라 배지를 추가합니다.

    에러 타입 접두어 → 배지 매핑:
        - economy_* → ECONOMY_FAIL
        - safety_* → SAFETY_BLOCKED
        - language_* (mismatch/content_mixed) 또는 box2d_* → CONSISTENCY_FAIL

    RU-005-S1: consistency 에러가 누락되지 않도록 매핑을 완전하게 구현.
    U-043: language_content_mixed도 CONSISTENCY_FAIL로 매핑.

    Args:
        biz_result: 비즈니스 룰 검증 결과
        badges: 배지 목록 (in-place 수정)
    """
    # 에러 타입별 배지 매핑 (RU-005-S1, U-043)
    has_economy_error = any("economy" in err["type"] for err in biz_result.errors)
    has_safety_error = any("safety" in err["type"] for err in biz_result.errors)
    # U-043: language_mismatch, language_content_mixed, box2d_* 모두 consistency로 매핑
    has_consistency_error = any(
        "language" in err["type"] or "box2d" in err["type"] for err in biz_result.errors
    )

    # Economy 배지
    if has_economy_error:
        badges.append(ValidationBadge.ECONOMY_FAIL)
    else:
        badges.append(ValidationBadge.ECONOMY_OK)

    # Safety 배지
    if has_safety_error:
        badges.append(ValidationBadge.SAFETY_BLOCKED)
    else:
        badges.append(ValidationBadge.SAFETY_OK)

    # Consistency 배지 (RU-005-S1: 언어/좌표 규약 위반 표시)
    if has_consistency_error:
        badges.append(ValidationBadge.CONSISTENCY_FAIL)
    else:
        badges.append(ValidationBadge.CONSISTENCY_OK)
</file>

<file path="backend/src/unknown_world/services/image_generation.py">
"""Unknown World - 이미지 생성 서비스.

이 모듈은 Gemini 이미지 생성 모델을 호출하고 결과를 로컬에 저장하는 서비스입니다.
텍스트 턴의 TTFB를 블로킹하지 않도록 분리된 경로로 동작합니다.

설계 원칙:
    - RULE-004: 실패 시 안전한 폴백 제공 (should_generate=false)
    - RULE-008: 텍스트 우선 + Lazy 이미지 원칙
    - RULE-010: 이미지 모델 ID 고정 (gemini-3-pro-image-preview)
    - RULE-007: 프롬프트 원문 노출 금지

페어링 질문 결정:
    - Q1: Option A (로컬 파일로 저장 후 image_url로 서빙)

참조:
    - vibe/tech-stack.md (모델 ID 고정)
    - vibe/unit-plans/U-019[Mvp].md
    - .cursor/rules/20-backend-orchestrator.mdc
"""

from __future__ import annotations

import base64
import hashlib
import logging
import os
import uuid
from dataclasses import dataclass
from datetime import UTC, datetime
from enum import StrEnum
from pathlib import Path
from typing import TYPE_CHECKING, Any

from pydantic import BaseModel, ConfigDict, Field

from unknown_world.config.models import MODEL_IMAGE, ModelLabel, get_model_id

if TYPE_CHECKING:
    from google.genai import Client
from unknown_world.models.turn import Language
from unknown_world.orchestrator.prompt_loader import load_image_prompt

# =============================================================================
# 로거 설정 (프롬프트/비밀정보 노출 금지 - RULE-007/008)
# =============================================================================

logger = logging.getLogger(__name__)


# =============================================================================
# 상수 정의
# =============================================================================

# MVP에서는 로컬 디렉토리에 저장 (MMP에서 GCS 확장 예정)
DEFAULT_OUTPUT_DIR = Path("generated_images")

# 지원 이미지 크기 (Gemini 이미지 생성 지원 크기)
SUPPORTED_SIZES: dict[str, tuple[int, int]] = {
    "1024x1024": (1024, 1024),
    "1280x768": (1280, 768),
    "768x1280": (768, 1280),
    "1536x1024": (1536, 1024),
    "1024x1536": (1024, 1536),
}

# 기본 설정
DEFAULT_SIZE = "1024x1024"
DEFAULT_ASPECT_RATIO = "1:1"


class ImageGenerationStatus(StrEnum):
    """이미지 생성 상태."""

    PENDING = "pending"
    """생성 대기 중"""

    GENERATING = "generating"
    """생성 중"""

    COMPLETED = "completed"
    """생성 완료"""

    FAILED = "failed"
    """생성 실패"""

    SKIPPED = "skipped"
    """생성 건너뜀 (잔액 부족 등)"""


# =============================================================================
# 요청/응답 Pydantic 모델
# =============================================================================


class ImageGenerationRequest(BaseModel):
    """이미지 생성 요청.

    TurnOutput의 render.image_job과 정합되도록 필드를 설계합니다.

    Attributes:
        prompt: 이미지 생성 프롬프트 (필수)
        aspect_ratio: 가로세로 비율 (예: "16:9", "1:1")
        image_size: 이미지 크기 (예: "1024x1024")
        reference_image_ids: 참조 이미지 ID 목록 (선택, 편집용)
        session_id: 세션 ID (파일 그룹화용)
        remove_background: 배경 제거 여부 (U-035, rembg 사용)
        image_type_hint: 이미지 유형 힌트 (rembg 모델 자동 선택용)
    """

    model_config = ConfigDict(extra="forbid")

    prompt: str = Field(min_length=1, description="이미지 생성 프롬프트")
    aspect_ratio: str = Field(default=DEFAULT_ASPECT_RATIO, description="가로세로 비율")
    image_size: str = Field(default=DEFAULT_SIZE, description="이미지 크기")
    reference_image_ids: list[str] = Field(default_factory=list, description="참조 이미지 ID 목록")
    session_id: str | None = Field(default=None, description="세션 ID")
    remove_background: bool = Field(default=False, description="배경 제거 여부 (U-035, rembg 사용)")
    image_type_hint: str | None = Field(
        default=None,
        description="이미지 유형 힌트 (object/character/icon 등, rembg 모델 선택용)",
    )


class ImageGenerationResponse(BaseModel):
    """이미지 생성 응답.

    Attributes:
        status: 생성 상태
        image_id: 생성된 이미지 ID (성공 시)
        image_url: 생성된 이미지 URL (성공 시)
        message: 상태 메시지 (실패 시 오류 설명)
        generation_time_ms: 생성 소요 시간 (밀리초)
        background_removed: 배경 제거 수행 여부 (U-035)
        rembg_model_used: 사용된 rembg 모델 (배경 제거 시)
    """

    model_config = ConfigDict(extra="forbid")

    status: ImageGenerationStatus
    image_id: str | None = Field(default=None, description="생성된 이미지 ID")
    image_url: str | None = Field(default=None, description="생성된 이미지 URL")
    message: str | None = Field(default=None, description="상태 메시지")
    generation_time_ms: int = Field(default=0, description="생성 소요 시간 (ms)")
    background_removed: bool = Field(default=False, description="배경 제거 수행 여부 (U-035)")
    rembg_model_used: str | None = Field(default=None, description="사용된 rembg 모델")


# =============================================================================
# 내부 데이터 클래스
# =============================================================================


@dataclass
class GeneratedImage:
    """생성된 이미지 정보.

    Attributes:
        id: 이미지 고유 ID
        path: 로컬 파일 경로
        url: 서빙 URL
        prompt_hash: 프롬프트 해시 (로그용, 원문 노출 금지)
        created_at: 생성 시각
        size: 파일 크기 (bytes)
        metadata: 추가 메타데이터
    """

    id: str
    path: Path
    url: str
    prompt_hash: str
    created_at: datetime
    size: int = 0

    def __post_init__(self) -> None:
        """초기화 후 메타데이터 필드 설정."""
        self._metadata: dict[str, str] = {}

    @property
    def metadata(self) -> dict[str, str]:
        """추가 메타데이터."""
        if not hasattr(self, "_metadata"):
            self._metadata = {}
        return self._metadata


# =============================================================================
# Mock 이미지 생성기
# =============================================================================


class MockImageGenerator:
    """테스트/개발용 모의 이미지 생성기.

    실제 API를 호출하지 않고 플레이스홀더 이미지를 생성합니다.
    """

    def __init__(self, output_dir: Path | None = None) -> None:
        """MockImageGenerator를 초기화합니다.

        Args:
            output_dir: 이미지 저장 디렉토리 (기본값: generated_images)
        """
        self._output_dir = output_dir or DEFAULT_OUTPUT_DIR
        self._output_dir.mkdir(parents=True, exist_ok=True)
        logger.info(
            "[ImageGen] Mock 모드로 초기화됨",
            extra={"output_dir": str(self._output_dir)},
        )

    async def generate(self, request: ImageGenerationRequest) -> ImageGenerationResponse:
        """모의 이미지를 생성합니다.

        Args:
            request: 이미지 생성 요청

        Returns:
            ImageGenerationResponse: 생성 결과
        """
        start_time = datetime.now(UTC)

        # 프롬프트 해시 생성 (원문 로깅 금지 - RULE-007)
        prompt_hash = hashlib.sha256(request.prompt.encode()).hexdigest()[:8]
        logger.debug(
            "[ImageGen] Mock 이미지 생성 요청",
            extra={
                "prompt_hash": prompt_hash,
                "size": request.image_size,
                "aspect_ratio": request.aspect_ratio,
                "remove_background": request.remove_background,
            },
        )

        # 고유 이미지 ID 생성
        image_id = f"img_{uuid.uuid4().hex[:12]}"

        # 플레이스홀더 이미지 생성 (1x1 투명 PNG)
        # 실제 환경에서는 Gemini API 응답으로 대체됨
        placeholder_png = self._create_placeholder_png(request.image_size)

        # 파일 저장
        file_name = f"{image_id}.png"
        file_path = self._output_dir / file_name
        file_path.write_bytes(placeholder_png)

        # U-035: 배경 제거 후처리 (조건부)
        background_removed = False
        rembg_model_used: str | None = None
        final_file_path = file_path
        final_file_name = file_name

        if request.remove_background:
            from unknown_world.services.image_postprocess import get_image_postprocessor

            postprocessor = get_image_postprocessor()
            result = postprocessor.remove_background(
                input_path=file_path,
                image_type_hint=request.image_type_hint,
            )

            if result.status.value == "success":
                background_removed = True
                rembg_model_used = result.model_used
                final_file_path = result.output_path
                final_file_name = final_file_path.name

                logger.debug(
                    "[ImageGen] Mock 이미지 배경 제거 완료",
                    extra={
                        "image_id": image_id,
                        "model": rembg_model_used,
                        "rembg_time_ms": result.processing_time_ms,
                    },
                )
            else:
                logger.warning(
                    "[ImageGen] Mock 이미지 배경 제거 실패, 원본 사용",
                    extra={"image_id": image_id, "message": result.message},
                )
                final_file_path = result.output_path
                final_file_name = final_file_path.name

        # 서빙 URL 생성 (MVP: 로컬 static 경로)
        image_url = f"/static/images/{final_file_name}"

        elapsed_ms = int((datetime.now(UTC) - start_time).total_seconds() * 1000)

        logger.info(
            "[ImageGen] Mock 이미지 생성 완료",
            extra={
                "image_id": image_id,
                "elapsed_ms": elapsed_ms,
                "background_removed": background_removed,
            },
        )

        return ImageGenerationResponse(
            status=ImageGenerationStatus.COMPLETED,
            image_id=image_id,
            image_url=image_url,
            message="Mock 이미지가 생성되었습니다.",
            generation_time_ms=elapsed_ms,
            background_removed=background_removed,
            rembg_model_used=rembg_model_used,
        )

    def _create_placeholder_png(self, size_str: str) -> bytes:
        """플레이스홀더 PNG를 생성합니다.

        Args:
            size_str: 이미지 크기 문자열 (예: "1024x1024")

        Returns:
            PNG 바이트 데이터
        """
        # 최소한의 유효한 PNG (1x1 회색 픽셀)
        # 실제 크기는 무시하고 플레이스홀더만 반환
        # 16x16 회색 PNG (mock 식별용)
        # Base64로 인코딩된 미니멀 PNG
        minimal_png = base64.b64decode(
            "iVBORw0KGgoAAAANSUhEUgAAABAAAAAQCAYAAAAf8/9hAAAADklEQVQ4y2NgGAWjAAcA"
            "CHABAMXKQ5oAAAAASUVORK5CYII="
        )
        return minimal_png

    def is_available(self) -> bool:
        """Mock 생성기는 항상 사용 가능합니다."""
        return True


# =============================================================================
# 실제 이미지 생성기
# =============================================================================


class ImageGenerator:
    """Gemini 기반 실제 이미지 생성기.

    gemini-3-pro-image-preview 모델을 사용하여 이미지를 생성합니다.
    모델 ID는 RULE-010에 따라 고정됩니다.
    """

    def __init__(
        self,
        output_dir: Path | None = None,
        project: str | None = None,
        location: str | None = None,
    ) -> None:
        """ImageGenerator를 초기화합니다.

        Args:
            output_dir: 이미지 저장 디렉토리
            project: Vertex AI 프로젝트 ID
            location: Vertex AI 리전
        """
        self._output_dir = output_dir or DEFAULT_OUTPUT_DIR
        self._output_dir.mkdir(parents=True, exist_ok=True)
        self._project = project or os.environ.get("VERTEX_PROJECT")
        self._location = location or os.environ.get("VERTEX_LOCATION", "us-central1")
        self._client: Client | None = None
        self._available = False

        self._initialize_client()

    def _initialize_client(self) -> None:
        """google-genai 클라이언트를 초기화합니다."""
        try:
            from google.genai import Client

            client_options: dict[str, Any] = {}
            if self._project:
                client_options["project"] = self._project
            if self._location:
                client_options["location"] = self._location

            self._client = Client(vertexai=True, **client_options)
            self._available = True

            logger.info(
                "[ImageGen] Vertex AI 이미지 생성기 초기화 완료",
                extra={
                    "model": MODEL_IMAGE,
                    "project": self._project or "(ADC 기본)",
                    "location": self._location,
                },
            )
        except Exception as e:
            logger.warning(
                "[ImageGen] Vertex AI 클라이언트 초기화 실패 - Mock 모드 권장",
                extra={"error_type": type(e).__name__},
            )
            self._available = False

    async def generate(self, request: ImageGenerationRequest) -> ImageGenerationResponse:
        """이미지를 생성합니다.

        Args:
            request: 이미지 생성 요청

        Returns:
            ImageGenerationResponse: 생성 결과
        """
        if not self._available or self._client is None:
            return ImageGenerationResponse(
                status=ImageGenerationStatus.FAILED,
                message="이미지 생성 클라이언트가 초기화되지 않았습니다.",
            )

        start_time = datetime.now(UTC)

        # 프롬프트 해시 (원문 로깅 금지 - RULE-007)
        prompt_hash = hashlib.sha256(request.prompt.encode()).hexdigest()[:8]

        # U-036: 프롬프트 로더에서 스타일 가이드라인 로드 (선택적 참고용)
        # 실제 모델은 Imagen이므로 지시사항보다는 텍스트 생성 모델(U-019)에서 이 가이드라인을 활용해
        # 최적화된 영어 프롬프트를 생성하는 것이 권장됩니다.
        try:
            # 현재 요청의 언어 정보를 알 수 없으므로 기본 KO 사용 (또는 요청에 언어 추가 필요)
            _style_guidelines = load_image_prompt(Language.KO)
            logger.debug("[ImageGen] 스타일 가이드라인 로드 완료 (U-036)")
        except Exception:
            logger.warning("[ImageGen] 스타일 가이드라인 로드 실패")

        logger.debug(
            "[ImageGen] 이미지 생성 요청",
            extra={
                "prompt_hash": prompt_hash,
                "size": request.image_size,
                "model": MODEL_IMAGE,
                "remove_background": request.remove_background,
            },
        )

        try:
            from google.genai.types import GenerateImagesConfig

            # 이미지 크기 검증 (현재 API에서 크기 지정은 제한적)
            _ = SUPPORTED_SIZES.get(request.image_size, SUPPORTED_SIZES[DEFAULT_SIZE])

            # Gemini 이미지 생성 호출
            # 참고: gemini-3-pro-image-preview 모델 사용 (RULE-010 고정)
            response = await self._client.aio.models.generate_images(
                model=get_model_id(ModelLabel.IMAGE),
                prompt=request.prompt,
                config=GenerateImagesConfig(
                    number_of_images=1,
                    output_mime_type="image/png",
                    # Gemini 이미지 생성 API는 크기 지정 방식이 다를 수 있음
                    # 실제 API 스펙에 맞게 조정 필요
                ),
            )

            # 이미지 데이터 추출 및 저장
            if response and hasattr(response, "generated_images") and response.generated_images:
                image_data = response.generated_images[0]
                image_bytes: bytes | None = None
                if (
                    hasattr(image_data, "image")
                    and image_data.image
                    and hasattr(image_data.image, "image_bytes")
                ):
                    image_bytes = image_data.image.image_bytes

                if image_bytes is None:
                    raise ValueError("이미지 데이터를 추출할 수 없습니다.")

                # 고유 ID 및 파일 저장
                image_id = f"img_{uuid.uuid4().hex[:12]}"
                file_name = f"{image_id}.png"
                file_path = self._output_dir / file_name
                file_path.write_bytes(image_bytes)

                # U-035: 배경 제거 후처리 (조건부)
                background_removed = False
                rembg_model_used: str | None = None
                final_file_path = file_path
                final_file_name = file_name

                if request.remove_background:
                    from unknown_world.services.image_postprocess import (
                        get_image_postprocessor,
                    )

                    postprocessor = get_image_postprocessor()
                    result = postprocessor.remove_background(
                        input_path=file_path,
                        image_type_hint=request.image_type_hint,
                    )

                    if result.status.value == "success":
                        background_removed = True
                        rembg_model_used = result.model_used
                        final_file_path = result.output_path
                        final_file_name = final_file_path.name

                        logger.debug(
                            "[ImageGen] 이미지 배경 제거 완료",
                            extra={
                                "image_id": image_id,
                                "model": rembg_model_used,
                                "rembg_time_ms": result.processing_time_ms,
                            },
                        )
                    else:
                        logger.warning(
                            "[ImageGen] 이미지 배경 제거 실패, 원본 사용",
                            extra={"image_id": image_id, "message": result.message},
                        )
                        final_file_path = result.output_path
                        final_file_name = final_file_path.name

                image_url = f"/static/images/{final_file_name}"
                elapsed_ms = int((datetime.now(UTC) - start_time).total_seconds() * 1000)

                logger.info(
                    "[ImageGen] 이미지 생성 완료",
                    extra={
                        "image_id": image_id,
                        "elapsed_ms": elapsed_ms,
                        "size_bytes": len(image_bytes),
                        "background_removed": background_removed,
                    },
                )

                return ImageGenerationResponse(
                    status=ImageGenerationStatus.COMPLETED,
                    image_id=image_id,
                    image_url=image_url,
                    message="이미지가 성공적으로 생성되었습니다.",
                    generation_time_ms=elapsed_ms,
                    background_removed=background_removed,
                    rembg_model_used=rembg_model_used,
                )
            else:
                return ImageGenerationResponse(
                    status=ImageGenerationStatus.FAILED,
                    message="이미지 생성 응답이 비어있습니다.",
                )

        except Exception as e:
            elapsed_ms = int((datetime.now(UTC) - start_time).total_seconds() * 1000)
            error_type = type(e).__name__

            logger.error(
                "[ImageGen] 이미지 생성 실패",
                extra={
                    "error_type": error_type,
                    "elapsed_ms": elapsed_ms,
                },
            )

            # 실패 시에도 안전한 응답 반환 (RULE-004)
            return ImageGenerationResponse(
                status=ImageGenerationStatus.FAILED,
                message=f"이미지 생성 중 오류가 발생했습니다: {error_type}",
                generation_time_ms=elapsed_ms,
            )

    def is_available(self) -> bool:
        """생성기가 사용 가능한 상태인지 확인합니다."""
        return self._available


# =============================================================================
# 팩토리 함수
# =============================================================================

# 생성기 타입
ImageGeneratorType = MockImageGenerator | ImageGenerator

# 싱글톤 인스턴스 캐시
_generator_instance: ImageGeneratorType | None = None


def get_image_generator(
    *,
    force_mock: bool = False,
    force_new: bool = False,
    output_dir: Path | None = None,
) -> ImageGeneratorType:
    """이미지 생성기 인스턴스를 반환합니다.

    환경변수 UW_MODE에 따라 실제 생성기 또는 Mock 생성기를 반환합니다.

    Args:
        force_mock: True면 환경변수와 무관하게 Mock 생성기 반환
        force_new: True면 캐시를 무시하고 새 인스턴스 생성
        output_dir: 이미지 저장 디렉토리

    Returns:
        이미지 생성기 인스턴스
    """
    global _generator_instance

    if not force_new and _generator_instance is not None:
        return _generator_instance

    # 모드 결정
    mode = os.environ.get("UW_MODE", "real")

    if force_mock or mode == "mock":
        generator: ImageGeneratorType = MockImageGenerator(output_dir)
    else:
        real_gen = ImageGenerator(output_dir)
        # 실제 생성기 초기화 실패 시 Mock으로 폴백
        if not real_gen.is_available():
            logger.warning("[ImageGen] 실제 생성기 초기화 실패, Mock 모드로 폴백")
            generator = MockImageGenerator(output_dir)
        else:
            generator = real_gen

    _generator_instance = generator
    return generator


def reset_image_generator() -> None:
    """이미지 생성기 캐시를 초기화합니다.

    테스트 시 생성기를 재설정할 때 사용합니다.
    """
    global _generator_instance
    _generator_instance = None


# =============================================================================
# 헬퍼 함수
# =============================================================================


def create_fallback_response(message: str | None = None) -> ImageGenerationResponse:
    """실패 시 안전한 폴백 응답을 생성합니다.

    RULE-004: 검증 실패나 오류 시에도 안전한 응답 제공

    Args:
        message: 오류 메시지 (선택)

    Returns:
        ImageGenerationResponse: 폴백 응답
    """
    return ImageGenerationResponse(
        status=ImageGenerationStatus.SKIPPED,
        message=message or "이미지 생성을 건너뛰었습니다. 텍스트로 진행합니다.",
    )


def validate_image_request(request: ImageGenerationRequest) -> str | None:
    """이미지 생성 요청을 검증합니다.

    Args:
        request: 검증할 요청

    Returns:
        오류 메시지 (유효하면 None)
    """
    # 이미지 크기 검증
    if request.image_size not in SUPPORTED_SIZES:
        return f"지원하지 않는 이미지 크기: {request.image_size}"

    # 프롬프트 길이 검증 (너무 짧거나 긴 경우)
    if len(request.prompt) < 3:
        return "프롬프트가 너무 짧습니다."

    if len(request.prompt) > 2000:
        return "프롬프트가 너무 깁니다 (최대 2000자)."

    return None
</file>

<file path="package.json">
{
  "name": "unknown-world",
  "version": "0.1.0",
  "private": true,
  "description": "Unknown World - Gemini 기반 에이전트형 게임 엔진",
  "packageManager": "pnpm@10.27.0",
  "engines": {
    "node": "24.12.0"
  },
  "scripts": {
    "kill": "pnpm kill:port",
    "kill:port": "npx --yes kill-port 8001 8002 8003 8004 8005 8006 8007 8008 8009 8010 8011 8012 8013 8014 8015 8016 8017 8018 8019 8020",
    "kill:front": "npx --yes kill-port 8001 8002 8003 8004 8005 8006 8007 8008 8009 8010",
    "kill:back": "npx --yes kill-port 8011 8012 8013 8014 8015 8016 8017 8018 8019 8020",
    "dev:back": "cd backend && uv run uvicorn unknown_world.main:app --reload --port 8011",
    "dev:front": "pnpm -C frontend dev"
  }
}
</file>

<file path="shared/schemas/turn/turn_output.schema.json">
{
  "$defs": {
    "ActionCard": {
      "additionalProperties": false,
      "description": "액션 카드 (Action Deck).\n\n매 턴 AI가 추천하는 행동 카드입니다.\n각 카드에 비용/위험/보상 힌트가 포함됩니다.\n\nAttributes:\n    id: 카드 고유 ID\n    label: 카드 라벨 (표시용)\n    description: 카드 설명 (선택)\n    cost: 예상 비용\n    risk: 위험도\n    hint: 예상 결과 힌트 (선택)",
      "properties": {
        "id": {
          "description": "카드 고유 ID",
          "title": "Id",
          "type": "string"
        },
        "label": {
          "description": "카드 라벨 (표시용)",
          "title": "Label",
          "type": "string"
        },
        "description": {
          "anyOf": [
            {
              "type": "string"
            },
            {
              "type": "null"
            }
          ],
          "default": null,
          "description": "카드 설명 (선택)",
          "title": "Description"
        },
        "cost": {
          "$ref": "#/$defs/CurrencyAmount",
          "description": "예상 비용"
        },
        "risk": {
          "$ref": "#/$defs/RiskLevel",
          "default": "low",
          "description": "위험도"
        },
        "hint": {
          "anyOf": [
            {
              "type": "string"
            },
            {
              "type": "null"
            }
          ],
          "default": null,
          "description": "예상 결과 힌트 (선택)",
          "title": "Hint"
        }
      },
      "required": [
        "id",
        "label",
        "cost"
      ],
      "title": "ActionCard",
      "type": "object"
    },
    "ActionDeck": {
      "additionalProperties": false,
      "description": "액션 덱 (Q1 결정: ui.action_deck.cards[] 구조).\n\n매 턴 AI가 제시하는 추천 행동 카드 덱입니다.\n\nAttributes:\n    cards: 액션 카드 목록 (3~6장 권장)",
      "properties": {
        "cards": {
          "default": [],
          "description": "액션 카드 목록 (3~6장 권장)",
          "items": {
            "$ref": "#/$defs/ActionCard"
          },
          "maxItems": 10,
          "minItems": 0,
          "title": "Cards",
          "type": "array"
        }
      },
      "title": "ActionDeck",
      "type": "object"
    },
    "AgentConsole": {
      "additionalProperties": false,
      "description": "에이전트 콘솔 데이터 (RULE-008).\n\n에이전트형 시스템임을 UI로 증명하기 위한 정보입니다.\n계획/실행/검증/복구의 흔적을 표시합니다.\n\nAttributes:\n    current_phase: 현재 실행 단계\n    badges: 검증 배지 목록\n    repair_count: 자동 복구 시도 횟수",
      "properties": {
        "current_phase": {
          "$ref": "#/$defs/AgentPhase",
          "default": "commit",
          "description": "현재 실행 단계"
        },
        "badges": {
          "default": [],
          "description": "검증 배지 목록",
          "items": {
            "$ref": "#/$defs/ValidationBadge"
          },
          "title": "Badges",
          "type": "array"
        },
        "repair_count": {
          "default": 0,
          "description": "자동 복구 시도 횟수",
          "minimum": 0,
          "title": "Repair Count",
          "type": "integer"
        }
      },
      "title": "AgentConsole",
      "type": "object"
    },
    "AgentPhase": {
      "description": "에이전트 실행 단계 (RULE-008).\n\n에이전트형 시스템임을 UI로 증명하기 위한 단계 표시.",
      "enum": [
        "parse",
        "validate",
        "plan",
        "resolve",
        "render",
        "verify",
        "commit"
      ],
      "title": "AgentPhase",
      "type": "string"
    },
    "Box2D": {
      "additionalProperties": false,
      "description": "2D 바운딩 박스 (RULE-009).\n\n좌표는 0~1000 정규화 좌표계이며, bbox는 [ymin, xmin, ymax, xmax] 순서입니다.\n이미지 이해 bbox 포맷과 호환됩니다.\n\nAttributes:\n    ymin: Y 최소값 (상단)\n    xmin: X 최소값 (좌측)\n    ymax: Y 최대값 (하단)\n    xmax: X 최대값 (우측)",
      "properties": {
        "ymin": {
          "description": "정규화 좌표 (0~1000)",
          "maximum": 1000,
          "minimum": 0,
          "title": "Ymin",
          "type": "integer"
        },
        "xmin": {
          "description": "정규화 좌표 (0~1000)",
          "maximum": 1000,
          "minimum": 0,
          "title": "Xmin",
          "type": "integer"
        },
        "ymax": {
          "description": "정규화 좌표 (0~1000)",
          "maximum": 1000,
          "minimum": 0,
          "title": "Ymax",
          "type": "integer"
        },
        "xmax": {
          "description": "정규화 좌표 (0~1000)",
          "maximum": 1000,
          "minimum": 0,
          "title": "Xmax",
          "type": "integer"
        }
      },
      "required": [
        "ymin",
        "xmin",
        "ymax",
        "xmax"
      ],
      "title": "Box2D",
      "type": "object"
    },
    "CurrencyAmount": {
      "additionalProperties": false,
      "description": "재화 수량.\n\nAttributes:\n    signal: 기본 재화 (텍스트 턴/이미지 생성/고급 기능에 소비)\n    memory_shard: 희귀 재화 (중요 설정 고정, 고해상도 이미지 등에 소비)",
      "properties": {
        "signal": {
          "description": "시그널 (기본 재화, 0 이상)",
          "minimum": 0,
          "title": "Signal",
          "type": "integer"
        },
        "memory_shard": {
          "description": "기억 파편 (희귀 재화, 0 이상)",
          "minimum": 0,
          "title": "Memory Shard",
          "type": "integer"
        }
      },
      "required": [
        "signal",
        "memory_shard"
      ],
      "title": "CurrencyAmount",
      "type": "object"
    },
    "EconomyOutput": {
      "additionalProperties": false,
      "description": "경제 출력 데이터 (RULE-005).\n\n이번 턴의 비용과 잔액 정보입니다.\n잔액 음수는 절대 불가 (서버 Hard gate).\n\nAttributes:\n    cost: 이번 턴에 소비된 비용\n    balance_after: 소비 후 잔액\n\nImportant:\n    - cost와 balance_after는 항상 포함되어야 합니다.\n    - balance_after의 signal과 memory_shard는 0 이상이어야 합니다.",
      "properties": {
        "cost": {
          "$ref": "#/$defs/CurrencyAmount",
          "description": "이번 턴에 소비된 비용"
        },
        "balance_after": {
          "$ref": "#/$defs/CurrencyAmount",
          "description": "소비 후 잔액"
        }
      },
      "required": [
        "cost",
        "balance_after"
      ],
      "title": "EconomyOutput",
      "type": "object"
    },
    "ImageJob": {
      "additionalProperties": false,
      "description": "이미지 생성 작업.\n\n조건부 이미지 생성/편집 요청입니다.\n이미지 생성이 느릴 경우 텍스트 우선 출력 + Lazy Loading을 사용합니다.\n\nAttributes:\n    should_generate: 이미지를 생성해야 하는지\n    prompt: 이미지 생성 프롬프트\n    model_label: 모델 선택 라벨 (FAST/QUALITY/CHEAP/REF)\n    aspect_ratio: 가로세로 비율 (예: \"16:9\", \"1:1\")\n    image_size: 이미지 크기 (예: \"1024x1024\")\n    reference_image_ids: 참조 이미지 ID 목록 (선택)",
      "properties": {
        "should_generate": {
          "description": "이미지를 생성해야 하는지",
          "title": "Should Generate",
          "type": "boolean"
        },
        "prompt": {
          "default": "",
          "description": "이미지 생성 프롬프트",
          "title": "Prompt",
          "type": "string"
        },
        "model_label": {
          "$ref": "#/$defs/ModelLabel",
          "default": "FAST",
          "description": "모델 선택 라벨"
        },
        "aspect_ratio": {
          "default": "16:9",
          "description": "가로세로 비율",
          "title": "Aspect Ratio",
          "type": "string"
        },
        "image_size": {
          "default": "1024x1024",
          "description": "이미지 크기",
          "title": "Image Size",
          "type": "string"
        },
        "reference_image_ids": {
          "default": [],
          "description": "참조 이미지 ID 목록 (선택)",
          "items": {
            "type": "string"
          },
          "title": "Reference Image Ids",
          "type": "array"
        }
      },
      "required": [
        "should_generate"
      ],
      "title": "ImageJob",
      "type": "object"
    },
    "Language": {
      "description": "지원 언어 (RULE-006).\n\nko/en 혼합 출력 금지. TurnInput.language를 SSOT로 삼아\n모든 UI/내러티브/시스템 메시지는 동일 언어로 고정합니다.",
      "enum": [
        "ko-KR",
        "en-US"
      ],
      "title": "Language",
      "type": "string"
    },
    "MemoryPin": {
      "additionalProperties": false,
      "description": "중요 설정 고정 후보.\n\n사용자가 Memory Shard를 소비해 고정할 수 있는 중요 설정입니다.\n\nAttributes:\n    id: 핀 고유 ID\n    content: 고정할 내용\n    cost: 고정에 필요한 비용",
      "properties": {
        "id": {
          "description": "핀 고유 ID",
          "title": "Id",
          "type": "string"
        },
        "content": {
          "description": "고정할 내용",
          "title": "Content",
          "type": "string"
        },
        "cost": {
          "$ref": "#/$defs/CurrencyAmount",
          "description": "고정에 필요한 비용"
        }
      },
      "required": [
        "id",
        "content",
        "cost"
      ],
      "title": "MemoryPin",
      "type": "object"
    },
    "ModelLabel": {
      "description": "모델/품질 선택 라벨 (RULE-008).\n\n프롬프트 노출 없이 \"왜 이 선택이었는지\"를 사용자 친화 라벨로 표시.",
      "enum": [
        "FAST",
        "QUALITY",
        "CHEAP",
        "REF"
      ],
      "title": "ModelLabel",
      "type": "string"
    },
    "Quest": {
      "additionalProperties": false,
      "description": "퀘스트/목표 (Quest Panel).\n\n플레이어가 달성해야 하는 현재 목표입니다.\n\nAttributes:\n    id: 퀘스트 고유 ID\n    label: 퀘스트 이름\n    is_completed: 달성 여부",
      "properties": {
        "id": {
          "description": "퀘스트 고유 ID",
          "title": "Id",
          "type": "string"
        },
        "label": {
          "description": "퀘스트 이름",
          "title": "Label",
          "type": "string"
        },
        "is_completed": {
          "default": false,
          "description": "달성 여부",
          "title": "Is Completed",
          "type": "boolean"
        }
      },
      "required": [
        "id",
        "label"
      ],
      "title": "Quest",
      "type": "object"
    },
    "RenderOutput": {
      "additionalProperties": false,
      "description": "렌더링 출력 데이터.\n\n이미지 생성/편집 관련 정보입니다.\n\nAttributes:\n    image_job: 이미지 생성 작업 (선택)",
      "properties": {
        "image_job": {
          "anyOf": [
            {
              "$ref": "#/$defs/ImageJob"
            },
            {
              "type": "null"
            }
          ],
          "default": null,
          "description": "이미지 생성 작업 (선택)"
        }
      },
      "title": "RenderOutput",
      "type": "object"
    },
    "RiskLevel": {
      "description": "행동 위험도 수준.",
      "enum": [
        "low",
        "medium",
        "high"
      ],
      "title": "RiskLevel",
      "type": "string"
    },
    "SafetyOutput": {
      "additionalProperties": false,
      "description": "안전 출력 데이터.\n\n안전 정책 관련 정보입니다.\n차단 시 명시적 메시지와 함께 안전한 대체 결과를 제공합니다.\n\nAttributes:\n    blocked: 안전 정책에 의해 차단되었는지\n    message: 차단 시 사용자에게 표시할 메시지 (선택)",
      "properties": {
        "blocked": {
          "default": false,
          "description": "안전 정책에 의해 차단되었는지",
          "title": "Blocked",
          "type": "boolean"
        },
        "message": {
          "anyOf": [
            {
              "type": "string"
            },
            {
              "type": "null"
            }
          ],
          "default": null,
          "description": "차단 시 사용자에게 표시할 메시지 (선택)",
          "title": "Message"
        }
      },
      "title": "SafetyOutput",
      "type": "object"
    },
    "SceneObject": {
      "additionalProperties": false,
      "description": "장면 오브젝트 (클릭 가능한 핫스팟).\n\n화면에서 클릭 가능한 오브젝트입니다.\n좌표는 0~1000 정규화 좌표계를 사용합니다 (RULE-009).\n\nAttributes:\n    id: 오브젝트 고유 ID\n    label: 오브젝트 라벨 (표시용)\n    box_2d: 바운딩 박스 [ymin, xmin, ymax, xmax]\n    interaction_hint: 상호작용 힌트 (선택)",
      "properties": {
        "id": {
          "description": "오브젝트 고유 ID",
          "title": "Id",
          "type": "string"
        },
        "label": {
          "description": "오브젝트 라벨 (표시용)",
          "title": "Label",
          "type": "string"
        },
        "box_2d": {
          "$ref": "#/$defs/Box2D",
          "description": "바운딩 박스"
        },
        "interaction_hint": {
          "anyOf": [
            {
              "type": "string"
            },
            {
              "type": "null"
            }
          ],
          "default": null,
          "description": "상호작용 힌트 (선택)",
          "title": "Interaction Hint"
        }
      },
      "required": [
        "id",
        "label",
        "box_2d"
      ],
      "title": "SceneObject",
      "type": "object"
    },
    "SceneOutput": {
      "additionalProperties": false,
      "description": "Scene 표시 정보 (RU-003-T1: Scene 이미지 SSOT).\n\nTurnOutput에서 Scene Canvas에 표시할 이미지 정보를 제공합니다.\nimage_url이 존재하면 SceneCanvas는 'scene' 상태로 전환됩니다.\nimage_url이 없으면 'default' 상태를 유지합니다.\n\nAttributes:\n    image_url: Scene 이미지 URL (존재 시 scene 상태로 전환)\n    alt_text: 이미지 대체 텍스트 (접근성용, 선택)",
      "properties": {
        "image_url": {
          "anyOf": [
            {
              "type": "string"
            },
            {
              "type": "null"
            }
          ],
          "default": null,
          "description": "Scene 이미지 URL (존재 시 scene 상태로 전환)",
          "title": "Image Url"
        },
        "alt_text": {
          "anyOf": [
            {
              "type": "string"
            },
            {
              "type": "null"
            }
          ],
          "default": null,
          "description": "이미지 대체 텍스트 (접근성용, 선택)",
          "title": "Alt Text"
        }
      },
      "title": "SceneOutput",
      "type": "object"
    },
    "UIOutput": {
      "additionalProperties": false,
      "description": "UI 출력 데이터.\n\nAI가 생성한 UI 요소들입니다.\n채팅 버블이 아닌 게임 UI로 표현됩니다 (RULE-002).\n\nRU-003-T1: scene 필드 추가 - Scene Canvas의 이미지 표시 정보 SSOT.\n\nAttributes:\n    action_deck: 액션 카드 덱 (Q1 결정: Option A 채택)\n    objects: 클릭 가능한 장면 오브젝트 목록\n    scene: Scene 표시 정보 (RU-003-T1)",
      "properties": {
        "action_deck": {
          "$ref": "#/$defs/ActionDeck",
          "description": "액션 카드 덱"
        },
        "objects": {
          "default": [],
          "description": "클릭 가능한 장면 오브젝트 목록",
          "items": {
            "$ref": "#/$defs/SceneObject"
          },
          "title": "Objects",
          "type": "array"
        },
        "scene": {
          "$ref": "#/$defs/SceneOutput",
          "default": {
            "image_url": null,
            "alt_text": null
          },
          "description": "Scene 표시 정보 (RU-003-T1)"
        }
      },
      "title": "UIOutput",
      "type": "object"
    },
    "ValidationBadge": {
      "description": "검증 배지 (RULE-008).\n\n턴 결과에 대한 검증 상태를 표시합니다.",
      "enum": [
        "schema_ok",
        "schema_fail",
        "economy_ok",
        "economy_fail",
        "safety_ok",
        "safety_blocked",
        "consistency_ok",
        "consistency_fail"
      ],
      "title": "ValidationBadge",
      "type": "string"
    },
    "WorldDelta": {
      "additionalProperties": false,
      "description": "세계 상태 변화 (Q2 결정: Option A - delta 중심).\n\n이번 턴에서 변경된 세계 상태를 나타냅니다.\nsnapshot은 SaveGame에만 저장하고, 매 턴은 delta만 전송합니다.\n\nAttributes:\n    rules_changed: 변경되거나 추가된 규칙 목록\n    inventory_added: 추가된 인벤토리 아이템\n    inventory_removed: 제거된 인벤토리 아이템\n    quests_updated: 업데이트된 퀘스트(목표) 목록\n    relationships_changed: 변경된 관계\n    memory_pins: 중요 설정 고정 후보",
      "properties": {
        "rules_changed": {
          "default": [],
          "description": "변경된 규칙 목록",
          "items": {
            "$ref": "#/$defs/WorldRule"
          },
          "title": "Rules Changed",
          "type": "array"
        },
        "inventory_added": {
          "default": [],
          "description": "추가된 인벤토리 아이템",
          "items": {
            "type": "string"
          },
          "title": "Inventory Added",
          "type": "array"
        },
        "inventory_removed": {
          "default": [],
          "description": "제거된 인벤토리 아이템",
          "items": {
            "type": "string"
          },
          "title": "Inventory Removed",
          "type": "array"
        },
        "quests_updated": {
          "default": [],
          "description": "업데이트된 퀘스트/목표 목록",
          "items": {
            "$ref": "#/$defs/Quest"
          },
          "title": "Quests Updated",
          "type": "array"
        },
        "relationships_changed": {
          "default": [],
          "description": "변경된 관계",
          "items": {
            "type": "string"
          },
          "title": "Relationships Changed",
          "type": "array"
        },
        "memory_pins": {
          "default": [],
          "description": "중요 설정 고정 후보",
          "items": {
            "$ref": "#/$defs/MemoryPin"
          },
          "title": "Memory Pins",
          "type": "array"
        }
      },
      "title": "WorldDelta",
      "type": "object"
    },
    "WorldRule": {
      "additionalProperties": false,
      "description": "세계 규칙 (Rule Board).\n\n현재 세계에 적용 중인 물리 법칙이나 메타 규칙입니다.\n\nAttributes:\n    id: 규칙 고유 ID\n    label: 규칙 이름\n    description: 규칙 상세 설명 (선택)",
      "properties": {
        "id": {
          "description": "규칙 고유 ID",
          "title": "Id",
          "type": "string"
        },
        "label": {
          "description": "규칙 이름",
          "title": "Label",
          "type": "string"
        },
        "description": {
          "anyOf": [
            {
              "type": "string"
            },
            {
              "type": "null"
            }
          ],
          "default": null,
          "description": "규칙 상세 설명 (선택)",
          "title": "Description"
        }
      },
      "required": [
        "id",
        "label"
      ],
      "title": "WorldRule",
      "type": "object"
    }
  },
  "additionalProperties": false,
  "description": "턴 출력 (서버 → 클라이언트).\n\n서버가 턴 처리 후 클라이언트로 반환하는 구조화된 응답입니다.\nGemini Structured Outputs(JSON Schema)로 강제됩니다.\n\nHard Gate 필드 (RULE-003/004/005):\n    - economy: cost와 balance_after 필수, 잔액 음수 금지\n    - safety: blocked 시 안전한 대체 결과 제공\n    - language: 요청 언어와 동일하게 고정 (혼합 출력 금지)\n\nAttributes:\n    language: 응답 언어 (요청과 동일)\n    narrative: 내러티브 텍스트 (표시용)\n    ui: UI 요소 (액션 덱, 오브젝트)\n    world: 세계 상태 변화 (delta 중심)\n    render: 렌더링 정보 (이미지 생성 작업)\n    economy: 경제 정보 (비용, 잔액)\n    safety: 안전 정책 정보\n    agent_console: 에이전트 실행 정보 (단계, 배지, 복구 횟수)\n\nExample:\n    >>> output = TurnOutput(\n    ...     language=Language.KO,\n    ...     narrative=\"문이 삐걱거리며 열립니다...\",\n    ...     economy=EconomyOutput(\n    ...         cost=CurrencyAmount(signal=5, memory_shard=0),\n    ...         balance_after=CurrencyAmount(signal=95, memory_shard=5),\n    ...     ),\n    ...     safety=SafetyOutput(blocked=False),\n    ... )\n    >>> schema = TurnOutput.model_json_schema()\n\nSchema Generation:\n    >>> # Gemini Structured Outputs용 JSON Schema 생성\n    >>> json_schema = TurnOutput.model_json_schema()\n    >>> # response_json_schema 파라미터에 전달\n    >>> config = {\n    ...     \"response_mime_type\": \"application/json\",\n    ...     \"response_json_schema\": json_schema,\n    ... }",
  "properties": {
    "language": {
      "$ref": "#/$defs/Language",
      "description": "응답 언어 (요청과 동일)"
    },
    "narrative": {
      "description": "내러티브 텍스트 (표시용)",
      "title": "Narrative",
      "type": "string"
    },
    "economy": {
      "$ref": "#/$defs/EconomyOutput",
      "description": "경제 정보 (비용, 잔액)"
    },
    "safety": {
      "$ref": "#/$defs/SafetyOutput",
      "description": "안전 정책 정보"
    },
    "ui": {
      "$ref": "#/$defs/UIOutput",
      "description": "UI 요소"
    },
    "world": {
      "$ref": "#/$defs/WorldDelta",
      "description": "세계 상태 변화 (delta)"
    },
    "render": {
      "$ref": "#/$defs/RenderOutput",
      "description": "렌더링 정보"
    },
    "agent_console": {
      "$ref": "#/$defs/AgentConsole",
      "description": "에이전트 실행 정보"
    }
  },
  "required": [
    "language",
    "narrative",
    "economy",
    "safety"
  ],
  "title": "TurnOutput",
  "type": "object"
}
</file>

<file path="backend/src/unknown_world/main.py">
"""Unknown World - FastAPI 애플리케이션 엔트리포인트

이 모듈은 Unknown World 백엔드의 FastAPI 앱을 정의합니다.
MVP 단계에서는 기본 헬스체크와 개발용 CORS 설정만 포함합니다.

실행 방법:
    cd backend
    uv sync
    uv run uvicorn unknown_world.main:app --reload --port 8011

참조:
    - vibe/tech-stack.md (버전 SSOT)
    - vibe/prd.md (에이전트형 게임 엔진 요구사항)
    - .cursor/rules/20-backend-orchestrator.mdc (SSE/검증/복구 규칙)
"""

# ruff: noqa: E402
# E402 무시: .env 로딩은 의도적으로 다른 import보다 먼저 실행되어야 함 (U-047)

# =============================================================================
# .env 자동 로딩 (U-047)
# =============================================================================
# 로컬 개발에서 backend/.env 파일이 있으면 자동 로딩합니다.
# - override=False: 이미 설정된 환경변수는 덮어쓰지 않음 (운영 환경 SSOT 보장)
# - 파일 미존재 시 no-op (운영/CI에서 파일 미존재를 기본으로 허용)
# - 페어링 질문 Q1 결정: Option A (import 시점에 로드)
#
# 보안 규칙:
#   - .env 파일은 레포에 커밋 금지 (.gitignore 필수)
#   - 민감 정보(키/토큰/프롬프트)는 로그/스트림/UI에 노출 금지 (RULE-007)
import os
from pathlib import Path

from dotenv import load_dotenv

# .env 파일 경로 (backend 디렉토리 기준)
_DOTENV_PATH = Path(__file__).parent.parent.parent.parent / ".env"

# .env 로딩 (override=False: 기존 환경변수 우선)
_dotenv_loaded = load_dotenv(dotenv_path=_DOTENV_PATH, override=False)

import logging
from collections.abc import AsyncGenerator
from contextlib import asynccontextmanager
from typing import Literal

from fastapi import FastAPI
from fastapi.middleware.cors import CORSMiddleware
from fastapi.staticfiles import StaticFiles
from pydantic import BaseModel, Field

from unknown_world import __version__
from unknown_world.api import image_router, turn_router
from unknown_world.services.image_generation import DEFAULT_OUTPUT_DIR
from unknown_world.services.rembg_preflight import (
    RembgPreflightResult,
    RembgReadyStatus,
    get_rembg_status,
    run_preflight_async,
)

# =============================================================================
# 로거 설정
# =============================================================================

logger = logging.getLogger(__name__)

# =============================================================================
# .env 로딩 상태 로깅 (U-047)
# =============================================================================
# 민감 정보(키/토큰/경로)는 출력하지 않음 (RULE-007/008)
# 모드/환경 정도만 로깅하여 디버깅 용이성 확보

_uw_mode = os.environ.get("UW_MODE", "mock")  # 기본값: mock (genai_client.py 정책)
_environment = os.environ.get("ENVIRONMENT", "development")

if _dotenv_loaded:
    logger.info(
        "[Config] .env 파일 로드 완료",
        extra={
            "dotenv_path": str(_DOTENV_PATH),
            "UW_MODE": _uw_mode,
            "ENVIRONMENT": _environment,
        },
    )
else:
    logger.debug(
        "[Config] .env 파일 미존재 또는 로드 실패 (기본값 사용)",
        extra={
            "UW_MODE": _uw_mode,
            "ENVIRONMENT": _environment,
        },
    )

# =============================================================================
# Lifespan (서버 시작/종료 이벤트)
# =============================================================================


@asynccontextmanager
async def lifespan(app: FastAPI) -> AsyncGenerator[None]:
    """FastAPI 앱 lifespan 관리.

    서버 시작 시:
        - rembg preflight 실행 (모델 사전 점검/다운로드)

    서버 종료 시:
        - 필요한 정리 작업 수행
    """
    # =========================================================================
    # Startup
    # =========================================================================
    logger.info("[Startup] Unknown World 백엔드 시작")

    # rembg preflight 실행 (U-045)
    # Q1: Option A - 타임아웃 짧게 + 실패 시 degraded 모드로 계속
    try:
        logger.info("[Startup] rembg preflight 시작")
        result = await run_preflight_async()

        if result.status == RembgReadyStatus.READY:
            logger.info(
                "[Startup] rembg READY",
                extra={
                    "preloaded_models": result.preloaded_models,
                    "elapsed_ms": result.preflight_time_ms,
                },
            )
        elif result.status == RembgReadyStatus.DEGRADED:
            logger.warning(
                "[Startup] rembg DEGRADED - 일부 기능이 제한될 수 있습니다",
                extra={
                    "preloaded_models": result.preloaded_models,
                    "missing_models": result.missing_models,
                    "last_error": result.last_error,
                },
            )
        else:
            logger.warning(
                "[Startup] rembg UNAVAILABLE - 배경 제거 기능이 비활성화됩니다",
                extra={"last_error": result.last_error},
            )

        # app.state에 저장
        app.state.rembg_status = result

    except Exception as e:
        # preflight 실패해도 서비스는 계속 (RULE-004)
        logger.exception("[Startup] rembg preflight 실패, degraded 모드로 시작")
        app.state.rembg_status = RembgPreflightResult(
            status=RembgReadyStatus.UNAVAILABLE,
            installed=False,
            last_error=f"preflight 예외: {type(e).__name__}",
        )

    logger.info("[Startup] Unknown World 백엔드 시작 완료")

    yield

    # =========================================================================
    # Shutdown
    # =========================================================================
    logger.info("[Shutdown] Unknown World 백엔드 종료")


# =============================================================================
# FastAPI 앱 인스턴스
# =============================================================================

app = FastAPI(
    title="Unknown World API",
    description="Gemini 기반 에이전트형 게임 엔진 오케스트레이터",
    version=__version__,
    docs_url="/docs",
    redoc_url="/redoc",
    lifespan=lifespan,
)

# =============================================================================
# 정적 파일 서빙 (U-019)
# =============================================================================
# 생성된 이미지를 /static/images 경로로 서빙합니다.
DEFAULT_OUTPUT_DIR.mkdir(parents=True, exist_ok=True)
app.mount("/static/images", StaticFiles(directory=str(DEFAULT_OUTPUT_DIR)), name="images")

# =============================================================================
# CORS 설정 (개발 환경용)
# =============================================================================
# PRD 요구: 로컬 개발에서 프론트와 통신할 수 있도록 CORS 기본 정책 준비
# RULE-011: 프론트엔드는 8001~8010 포트 사용
# 주의: 프로덕션에서는 MMP 단계에서 엄격한 정책으로 변경해야 함

ALLOWED_ORIGINS = [
    # 프론트엔드 개발 서버 포트 범위 (RULE-011: 8001~8010)
    *[f"http://localhost:{port}" for port in range(8001, 8011)],
    *[f"http://127.0.0.1:{port}" for port in range(8001, 8011)],
]

app.add_middleware(
    CORSMiddleware,
    allow_origins=ALLOWED_ORIGINS,
    allow_credentials=True,
    allow_methods=["*"],
    allow_headers=["*"],
)

# =============================================================================
# 라우터 등록
# =============================================================================

# U-007: /api/turn HTTP Streaming 엔드포인트
app.include_router(turn_router)

# U-019: /api/image 이미지 생성 엔드포인트
app.include_router(image_router)


# =============================================================================
# 응답 스키마 (Pydantic)
# =============================================================================


class RembgHealthInfo(BaseModel):
    """rembg 상태 정보 (헬스체크용).

    Attributes:
        status: rembg 준비 상태
        installed: 설치 여부
        preloaded_models: 사용 가능한 모델 목록
        missing_models: 누락된 모델 목록
        last_error: 마지막 에러 (있을 경우)
    """

    status: str = Field(description="rembg 준비 상태 (ready/degraded/unavailable/pending)")
    installed: bool = Field(description="rembg 설치 여부")
    preloaded_models: list[str] = Field(default_factory=list, description="사용 가능한 모델 목록")
    missing_models: list[str] = Field(default_factory=list, description="누락된 모델 목록")
    last_error: str | None = Field(default=None, description="마지막 에러 메시지")


class HealthResponse(BaseModel):
    """헬스체크 응답 스키마.

    Attributes:
        status: 서버 상태 ("ok" 또는 "degraded")
        version: 백엔드 버전
        service: 서비스 이름
        rembg: rembg 상태 정보 (선택)
    """

    status: Literal["ok", "degraded"]
    version: str
    service: str
    rembg: RembgHealthInfo | None = Field(default=None, description="rembg 상태 정보")


# =============================================================================
# 라우트 정의
# =============================================================================


@app.get("/health", response_model=HealthResponse, tags=["System"])
async def health_check() -> HealthResponse:
    """서버 헬스체크 엔드포인트.

    서버가 정상적으로 작동 중인지 확인합니다.
    이 엔드포인트는 로드밸런서, 모니터링 시스템, 클라이언트 연결 확인에 사용됩니다.

    rembg 상태:
        - ready: rembg 설치 + 필수 모델 캐시 완료
        - degraded: rembg 설치 + 일부 모델 누락
        - unavailable: rembg 미설치 또는 사용 불가
        - pending: preflight 아직 실행되지 않음

    Returns:
        HealthResponse: 서버 상태 정보
    """
    # rembg 상태 조회
    rembg_result = get_rembg_status()

    # 전체 서버 상태 결정
    # rembg가 unavailable이어도 서버는 ok (배경 제거만 비활성화)
    server_status: Literal["ok", "degraded"] = "ok"
    if rembg_result.status == RembgReadyStatus.UNAVAILABLE:
        # rembg 미사용 가능 시 degraded로 표시 (선택적)
        # 현재는 rembg 없어도 ok로 유지 (이미지 후처리만 스킵)
        server_status = "ok"

    # rembg 정보 구성
    rembg_info = RembgHealthInfo(
        status=rembg_result.status.value,
        installed=rembg_result.installed,
        preloaded_models=rembg_result.preloaded_models,
        missing_models=rembg_result.missing_models,
        last_error=rembg_result.last_error,
    )

    return HealthResponse(
        status=server_status,
        version=__version__,
        service="unknown-world-backend",
        rembg=rembg_info,
    )


@app.get("/", tags=["System"])
async def root() -> dict[str, str]:
    """루트 엔드포인트.

    API 정보를 간략히 안내합니다.

    Returns:
        dict: 기본 안내 메시지
    """
    return {
        "message": "Unknown World API",
        "docs": "/docs",
        "health": "/health",
    }
</file>

<file path="frontend/public/ui/manifest.json">
{
  "$schema": "./manifest.schema.json",
  "version": "1.4.0",
  "generatedAt": "2026-01-14T14:55:00Z",
  "totalBytes": 570867,
  "budgetBytes": 1572864,
  "assets": [
    {
      "id": "signal-24",
      "path": "icons/signal-24.png",
      "type": "icon",
      "size": 24,
      "fallback": "⚡",
      "usedIn": ["EconomyHUD"],
      "bytes": 1573,
      "notes": "U-038: v2 재생성, nanobanana mcp(픽셀아트), rembg(birefnet-general), ImageMagick 최적화"
    },
    {
      "id": "signal-16",
      "path": "icons/signal-16.png",
      "type": "icon",
      "size": 16,
      "fallback": "⚡",
      "usedIn": ["ActionDeck"],
      "bytes": 1012,
      "notes": "U-038: v2 재생성, nanobanana mcp(픽셀아트), rembg(birefnet-general), ImageMagick 최적화"
    },
    {
      "id": "shard-24",
      "path": "icons/shard-24.png",
      "type": "icon",
      "size": 24,
      "fallback": "💎",
      "usedIn": ["EconomyHUD"],
      "bytes": 1362,
      "notes": "U-038: v2 재생성, nanobanana mcp(픽셀아트), rembg(birefnet-general), ImageMagick 최적화"
    },
    {
      "id": "shard-16",
      "path": "icons/shard-16.png",
      "type": "icon",
      "size": 16,
      "fallback": "💎",
      "usedIn": ["ActionDeck"],
      "bytes": 1147,
      "notes": "U-038: shard-24에서 리사이즈, 16px 최적화"
    },
    {
      "id": "badge-ok-24",
      "path": "icons/badge-ok-24.png",
      "type": "icon",
      "size": 24,
      "fallback": "✓",
      "usedIn": ["AgentConsole"],
      "bytes": 1461,
      "notes": "U-038: v2 재생성, nanobanana mcp(픽셀아트), rembg(birefnet-general), ImageMagick 최적화"
    },
    {
      "id": "badge-ok-16",
      "path": "icons/badge-ok-16.png",
      "type": "icon",
      "size": 16,
      "fallback": "✓",
      "usedIn": [],
      "bytes": 1096,
      "notes": "U-038: v2 재생성, nanobanana mcp(픽셀아트), rembg(birefnet-general), ImageMagick 최적화"
    },
    {
      "id": "badge-fail-24",
      "path": "icons/badge-fail-24.png",
      "type": "icon",
      "size": 24,
      "fallback": "✗",
      "usedIn": ["AgentConsole"],
      "bytes": 2006,
      "notes": "U-038: v2 재생성, nanobanana mcp(픽셀아트), rembg(birefnet-general), ImageMagick 최적화"
    },
    {
      "id": "risk-medium-24",
      "path": "icons/risk-medium-24.png",
      "type": "icon",
      "size": 24,
      "fallback": "⚠",
      "usedIn": [],
      "bytes": 1594,
      "notes": "U-038: 24px 페어 보강, nanobanana mcp 생성"
    },
    {
      "id": "risk-medium-16",
      "path": "icons/risk-medium-16.png",
      "type": "icon",
      "size": 16,
      "fallback": "⚠",
      "usedIn": ["ActionDeck"],
      "bytes": 1256,
      "notes": "U-038: v2 재생성, nanobanana mcp(픽셀아트), rembg(birefnet-general), ImageMagick 최적화"
    },
    {
      "id": "risk-low-24",
      "path": "icons/risk-low-24.png",
      "type": "icon",
      "size": 24,
      "fallback": "✓",
      "usedIn": [],
      "bytes": 1838,
      "notes": "U-038: v2 재생성, nanobanana mcp(픽셀아트), rembg(birefnet-general), ImageMagick 최적화"
    },
    {
      "id": "risk-low-16",
      "path": "icons/risk-low-16.png",
      "type": "icon",
      "size": 16,
      "fallback": "✓",
      "usedIn": ["ActionDeck"],
      "bytes": 1331,
      "notes": "U-038: v2 재생성, nanobanana mcp(픽셀아트), rembg(birefnet-general), ImageMagick 최적화"
    },
    {
      "id": "risk-high-24",
      "path": "icons/risk-high-24.png",
      "type": "icon",
      "size": 24,
      "fallback": "⚠",
      "usedIn": [],
      "bytes": 1737,
      "notes": "U-038: v2 재생성, nanobanana mcp(픽셀아트), rembg(birefnet-general), ImageMagick 최적화"
    },
    {
      "id": "risk-high-16",
      "path": "icons/risk-high-16.png",
      "type": "icon",
      "size": 16,
      "fallback": "⚠",
      "usedIn": ["ActionDeck"],
      "bytes": 1227,
      "notes": "U-038: v2 재생성, nanobanana mcp(픽셀아트), rembg(birefnet-general), ImageMagick 최적화"
    },
    {
      "id": "status-online-16",
      "path": "icons/status-online-16.png",
      "type": "icon",
      "size": 16,
      "fallback": "●",
      "usedIn": [],
      "bytes": 1375,
      "notes": "U-038: v2 재생성, nanobanana mcp(픽셀아트), rembg(birefnet-general), ImageMagick 최적화"
    },
    {
      "id": "scene-placeholder-default",
      "path": "placeholders/scene-placeholder-default.png",
      "type": "placeholder",
      "fallback": "[SCENE]",
      "usedIn": ["SceneCanvas"],
      "bytes": 261407,
      "notes": "nanobanana mcp 생성, 레트로 터미널 스타일"
    },
    {
      "id": "scene-loading",
      "path": "placeholders/scene-loading.webp",
      "type": "placeholder",
      "fallback": "⏳",
      "usedIn": ["SceneCanvas"],
      "bytes": 47850,
      "notes": "U-031: 로딩 상태 placeholder, nanobanana mcp 생성, ImageMagick(magick) 최적화"
    },
    {
      "id": "scene-offline",
      "path": "placeholders/scene-offline.webp",
      "type": "placeholder",
      "fallback": "🔌",
      "usedIn": ["SceneCanvas"],
      "bytes": 44658,
      "notes": "U-031: 오프라인 상태 placeholder, nanobanana mcp 생성, ImageMagick(magick) 최적화"
    },
    {
      "id": "scene-blocked",
      "path": "placeholders/scene-blocked.webp",
      "type": "placeholder",
      "fallback": "🚫",
      "usedIn": ["SceneCanvas"],
      "bytes": 17318,
      "notes": "U-031: 차단 상태 placeholder, nanobanana mcp 생성, ImageMagick(magick) 최적화"
    },
    {
      "id": "scene-low-signal",
      "path": "placeholders/scene-low-signal.webp",
      "type": "placeholder",
      "fallback": "📉",
      "usedIn": ["SceneCanvas"],
      "bytes": 68454,
      "notes": "U-031: 저신호 상태 placeholder, nanobanana mcp 생성, ImageMagick(magick) 최적화"
    },
    {
      "id": "panel-corner-br",
      "path": "chrome/panel-corner-br.png",
      "type": "chrome",
      "fallback": "",
      "usedIn": ["PanelHeader"],
      "bytes": 1899,
      "notes": "U-032: 패널 코너 장식, nanobanana mcp 생성, rembg 배경 제거, ImageMagick 최적화(48x48), CSS transform으로 4방향 적용"
    },
    {
      "id": "card-frame",
      "path": "chrome/card-frame.png",
      "type": "chrome",
      "fallback": "",
      "usedIn": ["ActionCard"],
      "bytes": 9101,
      "notes": "U-032: 액션 카드 프레임, nanobanana mcp 생성, rembg 배경 제거, ImageMagick 최적화(160x80)"
    },
    {
      "id": "scanner-frame",
      "path": "chrome/scanner-frame.png",
      "type": "chrome",
      "fallback": "",
      "usedIn": ["Scanner"],
      "bytes": 100165,
      "notes": "U-032: 스캐너 슬롯 프레임, nanobanana mcp 생성, rembg(birefnet-general) 배경 제거, ImageMagick 최적화(346x200) 완료"
    }
  ]
}
</file>

<file path="frontend/package.json">
{
  "name": "unknown-world-frontend",
  "private": true,
  "version": "0.0.0",
  "type": "module",
  "packageManager": "pnpm@10.27.0",
  "scripts": {
    "dev": "vite",
    "build": "tsc -b && vite build",
    "preview": "vite preview",
    "format": "prettier . --write",
    "format:check": "prettier . --check",
    "lint": "eslint .",
    "lint:fix": "eslint . --fix",
    "typecheck": "tsc --noEmit",
    "test": "vitest run",
    "test:watch": "vitest",
    "test:coverage": "vitest run --coverage"
  },
  "dependencies": {
    "@dnd-kit/core": "6.3.1",
    "@dnd-kit/sortable": "10.0.0",
    "@dnd-kit/utilities": "^3.2.2",
    "i18next": "25.7.3",
    "react": "19.2.3",
    "react-dom": "19.2.3",
    "react-i18next": "16.5.1",
    "zod": "4.3.4",
    "zustand": "5.0.9"
  },
  "devDependencies": {
    "@eslint/js": "9.39.2",
    "@testing-library/jest-dom": "^6.9.1",
    "@testing-library/react": "^16.3.1",
    "@types/node": "25.0.3",
    "@types/react": "19.2.7",
    "@types/react-dom": "19.2.3",
    "@vitejs/plugin-react": "5.1.2",
    "@vitest/coverage-v8": "^4.0.16",
    "eslint": "9.39.2",
    "eslint-config-prettier": "10.1.8",
    "eslint-plugin-react": "7.37.5",
    "eslint-plugin-react-hooks": "7.0.1",
    "eslint-plugin-unused-imports": "4.3.0",
    "globals": "16.5.0",
    "jsdom": "^27.4.0",
    "prettier": "3.7.4",
    "typescript": "5.9.3",
    "typescript-eslint": "8.51.0",
    "vite": "7.3.0",
    "vitest": "^4.0.16"
  },
  "pnpm": {
    "onlyBuiltDependencies": [
      "esbuild"
    ]
  }
}
</file>

<file path="backend/pyproject.toml">
# backend/pyproject.toml
# SSOT: vibe/tech-stack.md (버전 기준일: 2026-01-01)

[build-system]
requires = ["hatchling"]
build-backend = "hatchling.build"

[project]
name = "unknown-world-backend"
version = "0.1.0"
description = "Unknown World Backend - Gemini 기반 에이전트형 게임 엔진"
requires-python = ">=3.14"
dependencies = [
    "fastapi==0.128.0",
    "uvicorn[standard]==0.40.0",
    "pydantic==2.12.5",
    "google-genai==1.60.0",
    "google-cloud-aiplatform==1.132.0",
    "google-cloud-storage==3.7.0",
    "python-dotenv>=1.2.1",
]

[tool.hatch.build.targets.wheel]
packages = ["src/unknown_world"]

[dependency-groups]
dev = [
    "ruff==0.14.10",
    "pyright==1.1.408",
    "pytest==9.0.2",
    "httpx==0.28.1",
    "jsonschema>=4.26.0",
    "pytest-asyncio>=1.3.0",
    "pytest-cov>=7.0.0",
]

[tool.ruff]
line-length = 100
target-version = "py314"
extend-exclude = [
    "__pycache__",
    ".ruff_cache",
    ".venv",
    "venv",
    "dist",
    "build",
]

[tool.ruff.lint]
select = [
    "E",      # pycodestyle errors
    "W",      # pycodestyle warnings
    "F",      # pyflakes
    "I",      # isort
    "UP",     # pyupgrade
    "B",      # flake8-bugbear
    "C4",     # flake8-comprehensions
    "SIM",    # flake8-simplify
]
ignore = [
    "E501",   # line too long (handled by formatter)
    "B008",   # function call in default argument (FastAPI Depends pattern)
]

[tool.ruff.format]
quote-style = "double"
indent-style = "space"

[tool.pyright]
pythonVersion = "3.14"
typeCheckingMode = "strict"
include = ["src"]
venvPath = "."
venv = ".venv"
</file>

<file path="backend/src/unknown_world/api/turn.py">
"""Unknown World - /api/turn HTTP Streaming 엔드포인트.

POST 요청을 받아 NDJSON(라인 단위 JSON) 스트리밍으로 턴 결과를 반환합니다.

설계 원칙:
    - RULE-003: 구조화 출력(JSON Schema) 우선 + Pydantic 검증
    - RULE-004: 검증 실패 시 Repair loop + 안전한 폴백
    - RULE-005: 재화 인바리언트 (잔액 음수 금지)
    - RULE-007: 프롬프트/내부 추론 노출 금지
    - RULE-008: 단계/배지 가시화, TTFB 2초 목표

스트림 이벤트 타입:
    - stage: 단계 진행 상태 (Parse→Validate→Plan→Resolve→Render→Verify→Commit)
    - badges: 검증 배지 목록
    - narrative_delta: 내러티브 텍스트 조각 (타자 효과용)
    - repair: Auto-repair 이벤트 (U-018)
    - final: 최종 TurnOutput
    - error: 에러 발생 시

리팩토링 (RU-005-Q4):
    - 기존 _stream_turn_events_mock/_real을 pipeline 기반으로 통합
    - API 레이어는 스트리밍 직렬화/전송에 집중
    - 오케스트레이션 로직은 pipeline.py로 위임

참조:
    - vibe/unit-plans/U-007[Mvp].md
    - vibe/unit-plans/U-018[Mvp].md
    - vibe/refactors/RU-005-Q4.md
    - .cursor/rules/20-backend-orchestrator.mdc
"""

from __future__ import annotations

import asyncio
import contextlib
import time
from collections.abc import AsyncGenerator
from typing import Any, cast

from fastapi import APIRouter, Request
from fastapi.responses import StreamingResponse
from pydantic import ValidationError

from unknown_world.api.turn_stream_events import (
    BadgesEvent,
    NarrativeDeltaEvent,
    RepairEvent,
    StageEvent,
    StageStatus,
    StreamEventType,
    serialize_event,
)
from unknown_world.api.turn_streaming_helpers import (
    emit_error_with_fallback,
    stream_output_with_narrative,
)
from unknown_world.models.turn import (
    CurrencyAmount,
    Language,
    TurnInput,
)
from unknown_world.orchestrator.fallback import create_safe_fallback
from unknown_world.orchestrator.pipeline import create_pipeline_context, run_pipeline
from unknown_world.orchestrator.repair_loop import MAX_REPAIR_ATTEMPTS
from unknown_world.orchestrator.stages.types import (
    PipelineEvent,
    PipelineEventType,
)

# =============================================================================
# 라우터 정의
# =============================================================================

router = APIRouter(prefix="/api", tags=["Turn"])


# =============================================================================
# Pipeline Event → Stream Event 변환
# =============================================================================


def _convert_pipeline_event(event: PipelineEvent) -> dict[str, Any] | None:
    """파이프라인 이벤트를 스트림 이벤트로 변환합니다.

    Args:
        event: 파이프라인 도메인 이벤트

    Returns:
        스트림 이벤트 dict (serialize_event에 전달) 또는 None
    """
    if event.event_type == PipelineEventType.STAGE_START:
        if event.phase is None:
            return None
        return StageEvent(
            type=StreamEventType.STAGE,
            name=event.phase.value,
            status=StageStatus.START,
        ).model_dump()

    if event.event_type == PipelineEventType.STAGE_COMPLETE:
        if event.phase is None:
            return None
        return StageEvent(
            type=StreamEventType.STAGE,
            name=event.phase.value,
            status=StageStatus.COMPLETE,
        ).model_dump()

    if event.event_type == PipelineEventType.STAGE_FAIL:
        if event.phase is None:
            return None
        return StageEvent(
            type=StreamEventType.STAGE,
            name=event.phase.value,
            status=StageStatus.FAIL,
        ).model_dump()

    if event.event_type == PipelineEventType.BADGES:
        if event.badges is None:
            return None
        return BadgesEvent(
            type=StreamEventType.BADGES,
            badges=[b.value for b in event.badges],
        ).model_dump()

    if event.event_type == PipelineEventType.REPAIR:
        return RepairEvent(
            type=StreamEventType.REPAIR,
            attempt=event.repair_attempt,
            message=event.repair_message,
        ).model_dump()

    if event.event_type == PipelineEventType.NARRATIVE_DELTA:
        if event.text is None:
            return None
        return NarrativeDeltaEvent(
            type=StreamEventType.NARRATIVE_DELTA,
            text=event.text,
        ).model_dump()

    return None


# =============================================================================
# 스트리밍 생성기
# =============================================================================


async def _stream_turn_events(
    turn_input: TurnInput, seed: int | None = None
) -> AsyncGenerator[str]:
    """턴 처리 이벤트를 NDJSON 스트림으로 생성합니다.

    Pipeline을 실행하고, 도메인 이벤트를 스트림 이벤트로 변환하여 전송합니다.

    Args:
        turn_input: 사용자 턴 입력
        seed: Mock 모드 시드 (재현성 보장)

    Yields:
        str: NDJSON 라인
    """
    # 이벤트 큐 (emit 콜백에서 이벤트를 쌓고, 메인 루프에서 소비)
    event_queue: asyncio.Queue[PipelineEvent | None] = asyncio.Queue()

    async def emit(event: PipelineEvent) -> None:
        """파이프라인 이벤트를 큐에 추가합니다."""
        await event_queue.put(event)

    # Pipeline 컨텍스트 생성
    ctx = create_pipeline_context(turn_input, seed=seed)

    # Pipeline 실행을 백그라운드 태스크로 시작
    async def run_pipeline_task() -> None:
        nonlocal ctx
        try:
            ctx = await run_pipeline(ctx, emit=emit)
        except asyncio.CancelledError:
            # RU-005-S2: 클라이언트 Abort 시 태스크도 취소됨
            # - 폴백 생성 없이 즉시 종료 (프론트 정책과 맞춤)
            raise  # finally 블록은 실행, 종료 신호만 보냄
        except Exception:
            # 예외 발생 시 폴백 (RULE-004)
            ctx.output = create_safe_fallback(
                language=turn_input.language,
                economy_snapshot=ctx.economy_snapshot,
                repair_count=ctx.repair_attempts,
            )
            ctx.is_fallback = True
        finally:
            # 종료 신호 (CancelledError 포함 모든 경우에 전송)
            await event_queue.put(None)

    pipeline_task = asyncio.create_task(run_pipeline_task())

    # 이벤트 소비 루프
    try:
        while True:
            event = await event_queue.get()
            if event is None:
                # Pipeline 종료
                break

            stream_event = _convert_pipeline_event(event)
            if stream_event is not None:
                yield serialize_event(stream_event)

        # Pipeline 완료 후 내러티브 + final 전송 (RU-005-Q3: 헬퍼 사용)
        if ctx.output is not None:
            async for line in stream_output_with_narrative(ctx.output):
                yield line

    except asyncio.CancelledError:
        # RU-005-S2: 클라이언트 Abort(연결 취소) 시 조용히 종료
        # - 추가 이벤트(error/final) 송출하지 않음
        # - 로그도 noisy하지 않게 남기지 않음 (프론트 정책과 맞춤)
        pass

    except Exception:
        # 예외 발생 시 error + final(폴백) 순서로 송출 (RULE-004, RU-005-Q3: 헬퍼 사용)
        async for line in emit_error_with_fallback(
            turn_input.language,
            economy_snapshot=ctx.economy_snapshot,
            repair_count=MAX_REPAIR_ATTEMPTS,
        ):
            yield line

    finally:
        # Pipeline 태스크 정리
        if not pipeline_task.done():
            pipeline_task.cancel()
            with contextlib.suppress(asyncio.CancelledError):
                await pipeline_task


# =============================================================================
# 입력 검증
# =============================================================================


async def _validate_and_parse_input(request: Request) -> TurnInput | dict[str, Any]:
    """요청 본문을 TurnInput으로 검증 및 파싱합니다.

    Returns:
        TurnInput 또는 에러 정보 dict (language, economy_snapshot 포함)
    """
    body: dict[str, Any] | None = None
    try:
        body = await request.json()
        return TurnInput.model_validate(body)
    except ValidationError as e:
        # RU-002-S1: 입력 검증 실패 시에도 language/economy 추출 시도
        raw_language = body.get("language") if isinstance(body, dict) else None
        raw_economy = body.get("economy_snapshot") if isinstance(body, dict) else None
        return {
            "error": True,
            "message": "Invalid input",
            "details": e.errors(),
            "language": raw_language if raw_language in ("ko-KR", "en-US") else "ko-KR",
            "economy_snapshot": raw_economy,
        }
    except Exception:
        return {
            "error": True,
            "message": "Failed to parse request body",
            "details": None,
            "language": "ko-KR",
            "economy_snapshot": None,
        }


# =============================================================================
# API 엔드포인트
# =============================================================================


@router.post(
    "/turn",
    response_class=StreamingResponse,
    summary="턴 처리 (HTTP Streaming)",
    description="""
턴 입력을 받아 NDJSON 스트리밍으로 결과를 반환합니다.

**스트림 이벤트 타입**:
- `stage`: 처리 단계 진행 상태
- `badges`: 검증 배지 목록
- `narrative_delta`: 내러티브 텍스트 조각 (타자 효과)
- `final`: 최종 TurnOutput
- `error`: 에러 발생 시

**예시 요청**:
```json
{
    "language": "ko-KR",
    "text": "문을 열어본다",
    "client": {"viewport_w": 1920, "viewport_h": 1080, "theme": "dark"},
    "economy_snapshot": {"signal": 100, "memory_shard": 5}
}
```
""",
    responses={
        200: {
            "description": "NDJSON 스트림",
            "content": {
                "application/x-ndjson": {
                    "example": '{"type":"stage","name":"parse","status":"start"}\n'
                }
            },
        },
        400: {"description": "잘못된 요청"},
    },
)
async def turn_stream(request: Request) -> StreamingResponse:
    """턴 처리 HTTP Streaming 엔드포인트.

    POST 요청으로 TurnInput을 받아 NDJSON 스트리밍으로 결과를 반환합니다.
    TTFB를 줄이기 위해 첫 stage 이벤트를 즉시 전송합니다.

    Args:
        request: FastAPI Request 객체

    Returns:
        StreamingResponse: NDJSON 스트림
    """
    # 입력 검증
    parse_result = await _validate_and_parse_input(request)

    if isinstance(parse_result, dict) and parse_result.get("error"):
        # RU-002-S1: 입력 검증 실패 시에도 error + final(폴백) 순서로 송출
        error_language = parse_result.get("language", "ko-KR")
        error_economy = parse_result.get("economy_snapshot")

        # economy_snapshot이 유효한지 확인
        economy_snapshot: CurrencyAmount | None = None
        if isinstance(error_economy, dict):
            try:
                # 명시적 타입 캐스팅으로 Pyright 경고 해소
                eco_dict = cast(dict[str, Any], error_economy)
                economy_snapshot = CurrencyAmount(
                    signal=int(eco_dict.get("signal", 100)),
                    memory_shard=int(eco_dict.get("memory_shard", 5)),
                )
            except (ValueError, TypeError):
                economy_snapshot = None

        async def error_stream() -> AsyncGenerator[str]:
            # RU-005-Q3: 헬퍼를 사용하여 error + final(폴백) 송출
            async for line in emit_error_with_fallback(
                Language.KO if error_language == "ko-KR" else Language.EN,
                error_message=parse_result.get("message", "Invalid input"),
                error_code="VALIDATION_ERROR",
                economy_snapshot=economy_snapshot,
                repair_count=0,
            ):
                yield line

        return StreamingResponse(
            error_stream(),
            media_type="application/x-ndjson",
            headers={
                "Cache-Control": "no-cache",
                "X-Accel-Buffering": "no",  # nginx 버퍼링 비활성화
            },
        )

    turn_input: TurnInput = parse_result  # type: ignore[assignment]

    # 시드 추출 (쿼리 파라미터에서, 테스트/재현용)
    seed_param = request.query_params.get("seed")
    seed = int(seed_param) if seed_param else None

    # NDJSON 스트리밍 응답
    return StreamingResponse(
        _stream_turn_events(turn_input, seed=seed),
        media_type="application/x-ndjson",
        headers={
            "Cache-Control": "no-cache",
            "X-Accel-Buffering": "no",  # nginx 버퍼링 비활성화
            "X-Request-Time": str(int(time.time() * 1000)),
        },
    )
</file>

<file path="frontend/src/locales/en-US/translation.json">
{
  "language": {
    "toggle": "Change Language",
    "toggle_tooltip": "Click to change language. A new game will start after change.",
    "ko-KR": "한국어",
    "en-US": "English"
  },
  "error": {
    "unknown_error": "An unknown error occurred.",
    "response_processing": "[System] An error occurred while processing response data.",
    "connection_failed": "[System] Failed to connect to server. Please try again."
  },
  "profile": {
    "select_title": "Select Your Profile",
    "select_hint": "Each profile has different starting conditions and objectives",
    "or": "or",
    "continue_saved": "Continue Saved Game",
    "change": "Change Profile",
    "change_tooltip": "Start a new game with a different profile",
    "narrator": {
      "name": "Narrator",
      "description": "Explore diverse stories with abundant resources",
      "welcome": "Welcome to the Ancient Library. Forgotten tales slumber within these walls...",
      "items": {
        "ancient_tome": "Ancient Tome",
        "quill_pen": "Quill Pen",
        "memory_fragment": "Memory Fragment"
      },
      "quest": {
        "discover_origin": "Discover the World's Origin",
        "collect_memories": "Collect 3 Memory Fragments"
      },
      "rule": {
        "time_flows": "Flow of Time",
        "time_flows_desc": "Time flows normally",
        "memories_persist": "Memory Persistence",
        "memories_persist_desc": "Once obtained, memories never fade"
      },
      "scene": {
        "bookshelf": "Mysterious Bookshelf",
        "bookshelf_hint": "Ancient books are glowing",
        "portal": "Glowing Portal",
        "portal_hint": "It seems to lead somewhere"
      }
    },
    "explorer": {
      "name": "Explorer",
      "description": "Explore unknown territories and uncover secrets",
      "welcome": "You wake up in a dark maze. You must find the exit and escape...",
      "items": {
        "compass": "Compass",
        "rope": "Rope",
        "lantern": "Lantern",
        "map_fragment": "Map Fragment"
      },
      "quest": {
        "find_exit": "Find the Exit",
        "explore_areas": "Explore 3 Areas",
        "gather_supplies": "Gather Supplies"
      },
      "rule": {
        "gravity": "Gravity Law",
        "gravity_desc": "Objects fall downward",
        "darkness": "Darkness Law",
        "darkness_desc": "You cannot see without light"
      },
      "scene": {
        "door": "Ancient Door",
        "door_hint": "Looks like it needs a key",
        "mechanism": "Strange Mechanism",
        "mechanism_hint": "It might be operable",
        "passage": "Hidden Passage",
        "passage_hint": "Where does it lead?"
      }
    },
    "tech": {
      "name": "Tech Expert",
      "description": "Strategize efficiently with limited resources",
      "welcome": "System boot complete. Find the optimal path with limited energy...",
      "items": {
        "data_core": "Data Core",
        "circuit_board": "Circuit Board",
        "energy_cell": "Energy Cell",
        "scanner": "Scanner Device"
      },
      "quest": {
        "analyze_system": "Complete System Analysis",
        "optimize_resources": "Optimize Resource Efficiency"
      },
      "rule": {
        "energy_conservation": "Energy Conservation",
        "energy_conservation_desc": "Energy is neither created nor destroyed",
        "data_integrity": "Data Integrity",
        "data_integrity_desc": "Corrupted data cannot be recovered",
        "system_limits": "System Limits",
        "system_limits_desc": "There are limits to concurrent processing"
      },
      "scene": {
        "terminal": "Main Terminal",
        "terminal_hint": "You can access the system",
        "conduit": "Power Conduit",
        "conduit_hint": "Energy is flowing through it"
      }
    }
  },
  "reset": {
    "button": "Reset",
    "confirm": "Click again to confirm",
    "cancel": "Cancel",
    "tooltip": "Return to the initial state of current profile"
  },
  "demo": {
    "items": {
      "keycard-alpha": {
        "name": "Keycard A"
      },
      "medkit": {
        "name": "Medkit"
      },
      "flashlight": {
        "name": "Flashlight"
      },
      "data-chip": {
        "name": "Data Chip"
      }
    },
    "scene": {
      "terminal": {
        "label": "Terminal",
        "hint": "An active terminal"
      },
      "door": {
        "label": "Door",
        "hint": "It appears to be locked"
      }
    },
    "quest": {
      "terminal": {
        "label": "Access the terminal"
      },
      "escape": {
        "label": "Find facility exit"
      },
      "collect": {
        "label": "Collect data chips"
      }
    },
    "rule": {
      "gravity": {
        "label": "Gravity Law",
        "description": "Objects fall downward"
      },
      "time": {
        "label": "Time Flow",
        "description": "Time flows at normal speed"
      }
    }
  },
  "quest": {
    "empty": "[ NO OBJECTIVES ]",
    "completed": "DONE",
    "section": {
      "active": "Active",
      "completed": "Completed"
    }
  },
  "rule_board": {
    "empty": "[ NO RULES ]",
    "active_count": "Active Rules: {{count}}"
  },
  "mutation": {
    "empty": "[ NO MUTATIONS ]",
    "timeline_title": "Mutation Timeline",
    "event_count": "{{count}} events",
    "more_events": "+{{count}} more",
    "turn_label": "T{{turn}}",
    "type": {
      "added": "Added",
      "modified": "Modified",
      "removed": "Removed"
    }
  },
  "scene": {
    "status": {
      "default": "NO SIGNAL DATA",
      "loading": "SYNCHRONIZING...",
      "offline": "CONNECTION LOST",
      "blocked": "ACCESS RESTRICTED",
      "low_signal": "LOW SIGNAL",
      "image_error": "Unable to load scene image.",
      "image_loading": "Loading scene image...",
      "image_generating": "Generating new scene...",
      "initial_sync": "Awaiting global data synchronization...",
      "syncing": "Synchronizing data...",
      "alt": "Scene Image"
    },
    "hotspot": {
      "layer_label": "Clickable Objects Area",
      "hint_prefix": "Hint",
      "click_action": "Click {{label}}",
      "drop_hint": "Drop here to use",
      "drop_action": "Use {{item}} on {{target}}",
      "drop_invalid": "You cannot use {{item}} there.",
      "demo_hint": "[DEMO TARGET]"
    }
  },
  "agent": {
    "console": {
      "queue": "Queue",
      "badges": "Badges",
      "repair": "Auto-repair",
      "status": {
        "idle": "IDLE",
        "processing": "PROCESSING"
      },
      "badges_empty": "[ Awaiting Validation ]",
      "repaired": "(Repaired)",
      "phase": {
        "parse": "Parse",
        "validate": "Validate",
        "plan": "Plan",
        "resolve": "Resolve",
        "render": "Render",
        "verify": "Verify",
        "commit": "Commit"
      },
      "badge": {
        "schema": "Schema",
        "economy": "Economy",
        "safety": "Safety",
        "consistency": "Consistency",
        "ok": "OK",
        "fail": "FAIL"
      }
    }
  },
  "ui": {
    "logo": "UNKNOWN WORLD",
    "command_placeholder": "Enter command...",
    "processing": "Processing...",
    "execute": "EXECUTE",
    "wait": "WAIT",
    "panel_placeholder": "[ Ready ]",
    "scale_decrease": "Decrease text size",
    "scale_increase": "Increase text size",
    "scale_label": "UI Scale Settings"
  },
  "economy": {
    "signal": "Signal",
    "shard": "Shard",
    "signal_cost": "Signal cost",
    "shard_cost": "Shard cost",
    "risk_level": "Risk level",
    "hud_label": "Economy Status",
    "estimated_cost": "Est. Cost",
    "confirmed_cost": "Confirmed",
    "insufficient_funds": "Insufficient funds",
    "low_balance_warning": "Low balance",
    "alternatives_title": "Alternatives",
    "alternative_text_only": "Text-only (no images)",
    "alternative_low_quality": "Low quality / Fast response",
    "ledger_title": "Recent Ledger",
    "ledger_empty": "[ NO HISTORY ]",
    "model_label": {
      "FAST": "Fast",
      "QUALITY": "Quality",
      "CHEAP": "Cheap",
      "REF": "Ref"
    }
  },
  "connection": {
    "online": "ONLINE",
    "offline": "OFFLINE"
  },
  "inventory": {
    "empty": "[ NO ITEMS ]",
    "grid_label": "Inventory Items",
    "item_label": "{{name}} (Qty: {{quantity}})",
    "drag_hint": "Drag to use"
  },
  "panel": {
    "inventory": {
      "title": "Inventory",
      "placeholder": "[ Drag & Drop Area ]"
    },
    "quest": {
      "title": "Quest",
      "placeholder": "[ Objectives / Quest List ]"
    },
    "rule_board": {
      "title": "Rule Board",
      "placeholder": "[ World Rules / Mutation Timeline ]"
    },
    "agent_console": {
      "title": "Agent Console"
    },
    "memory_pin": {
      "title": "Memory Pin",
      "placeholder": "[ Pinned Memories / Clues ]"
    },
    "scanner": {
      "title": "Scanner",
      "placeholder": "[ Image Upload Slot ]"
    }
  },
  "action": {
    "default": {
      "explore": {
        "label": "Explore",
        "description": "Look around"
      },
      "investigate": {
        "label": "Investigate",
        "description": "Examine closely"
      },
      "talk": {
        "label": "Talk",
        "description": "Start a conversation"
      }
    },
    "card_select": "Card selected: {{cardId}}",
    "deck_label": "Action Cards",
    "alternative": "ALT",
    "insufficient_balance": "Insufficient balance",
    "all_disabled_notice": "No actions available. Check alternatives.",
    "risk": {
      "low": "Low",
      "medium": "Med",
      "high": "High"
    },
    "cost_range": "{{min}}~{{max}}"
  },
  "narrative": {
    "welcome": "Welcome to the Unknown World...",
    "turn_label": "[TURN {{turn}}]",
    "streaming_label": "[STREAMING]"
  }
}
</file>

<file path="frontend/src/locales/ko-KR/translation.json">
{
  "language": {
    "toggle": "언어 변경",
    "toggle_tooltip": "클릭하여 언어를 변경합니다. 변경 후 새 게임이 시작됩니다.",
    "ko-KR": "한국어",
    "en-US": "English"
  },
  "error": {
    "unknown_error": "알 수 없는 오류가 발생했습니다.",
    "response_processing": "[시스템] 응답 데이터를 처리하는 중 문제가 발생했습니다.",
    "connection_failed": "[시스템] 서버 연결에 실패했습니다. 다시 시도해 주세요."
  },
  "profile": {
    "select_title": "프로필을 선택하세요",
    "select_hint": "프로필마다 다른 시작 조건과 목표가 있습니다",
    "or": "또는",
    "continue_saved": "저장된 게임 계속하기",
    "change": "프로필 변경",
    "change_tooltip": "다른 프로필로 새 게임 시작",
    "narrator": {
      "name": "서사꾼",
      "description": "풍부한 자원으로 다양한 이야기를 탐험하세요",
      "welcome": "고대의 도서관에 오신 것을 환영합니다. 이곳에는 잊혀진 이야기들이 잠들어 있습니다...",
      "items": {
        "ancient_tome": "고대 서책",
        "quill_pen": "깃펜",
        "memory_fragment": "기억 조각"
      },
      "quest": {
        "discover_origin": "세계의 기원을 발견하기",
        "collect_memories": "기억 조각 3개 수집하기"
      },
      "rule": {
        "time_flows": "시간의 흐름",
        "time_flows_desc": "시간은 정상적으로 흐릅니다",
        "memories_persist": "기억의 지속",
        "memories_persist_desc": "한번 얻은 기억은 사라지지 않습니다"
      },
      "scene": {
        "bookshelf": "신비한 책장",
        "bookshelf_hint": "오래된 책들이 빛나고 있다",
        "portal": "빛나는 포탈",
        "portal_hint": "어딘가로 통하는 것 같다"
      }
    },
    "explorer": {
      "name": "탐험가",
      "description": "미지의 영역을 탐험하고 비밀을 발견하세요",
      "welcome": "어두운 미로에서 눈을 떴습니다. 출구를 찾아 이곳을 탈출해야 합니다...",
      "items": {
        "compass": "나침반",
        "rope": "밧줄",
        "lantern": "랜턴",
        "map_fragment": "지도 조각"
      },
      "quest": {
        "find_exit": "탈출구 찾기",
        "explore_areas": "3개 구역 탐험하기",
        "gather_supplies": "보급품 수집"
      },
      "rule": {
        "gravity": "중력 법칙",
        "gravity_desc": "물체는 아래로 떨어집니다",
        "darkness": "어둠의 법칙",
        "darkness_desc": "빛 없이는 앞을 볼 수 없습니다"
      },
      "scene": {
        "door": "고대의 문",
        "door_hint": "열쇠가 필요해 보인다",
        "mechanism": "이상한 장치",
        "mechanism_hint": "작동시킬 수 있을 것 같다",
        "passage": "숨겨진 통로",
        "passage_hint": "어디로 이어질까?"
      }
    },
    "tech": {
      "name": "기술 전문가",
      "description": "제한된 자원으로 효율적인 전략을 세우세요",
      "welcome": "시스템 부팅 완료. 제한된 에너지로 최적의 경로를 찾아야 합니다...",
      "items": {
        "data_core": "데이터 코어",
        "circuit_board": "회로 기판",
        "energy_cell": "에너지 셀",
        "scanner": "스캐너 장치"
      },
      "quest": {
        "analyze_system": "시스템 분석 완료하기",
        "optimize_resources": "자원 효율 최적화하기"
      },
      "rule": {
        "energy_conservation": "에너지 보존",
        "energy_conservation_desc": "에너지는 생성되거나 소멸되지 않습니다",
        "data_integrity": "데이터 무결성",
        "data_integrity_desc": "손상된 데이터는 복구할 수 없습니다",
        "system_limits": "시스템 한계",
        "system_limits_desc": "동시 처리량에 제한이 있습니다"
      },
      "scene": {
        "terminal": "메인 터미널",
        "terminal_hint": "시스템에 접속할 수 있다",
        "conduit": "전력 도관",
        "conduit_hint": "에너지가 흐르고 있다"
      }
    }
  },
  "reset": {
    "button": "리셋",
    "confirm": "다시 클릭하여 확인",
    "cancel": "취소",
    "tooltip": "현재 프로필의 초기 상태로 되돌립니다"
  },
  "demo": {
    "items": {
      "keycard-alpha": {
        "name": "키카드 A"
      },
      "medkit": {
        "name": "응급 키트"
      },
      "flashlight": {
        "name": "손전등"
      },
      "data-chip": {
        "name": "데이터칩"
      }
    },
    "scene": {
      "terminal": {
        "label": "터미널",
        "hint": "활성화된 터미널이다"
      },
      "door": {
        "label": "문",
        "hint": "잠겨있는 것 같다"
      }
    },
    "quest": {
      "terminal": {
        "label": "터미널에 접속하기"
      },
      "escape": {
        "label": "시설 탈출구 찾기"
      },
      "collect": {
        "label": "데이터칩 수집"
      }
    },
    "rule": {
      "gravity": {
        "label": "중력 법칙",
        "description": "물체는 아래로 떨어진다"
      },
      "time": {
        "label": "시간 흐름",
        "description": "시간은 정상 속도로 흐른다"
      }
    }
  },
  "quest": {
    "empty": "[ 목표 없음 ]",
    "completed": "완료",
    "section": {
      "active": "진행 중",
      "completed": "완료됨"
    }
  },
  "rule_board": {
    "empty": "[ 규칙 없음 ]",
    "active_count": "활성 규칙: {{count}}개"
  },
  "mutation": {
    "empty": "[ 변형 이력 없음 ]",
    "timeline_title": "변형 타임라인",
    "event_count": "{{count}}개 이벤트",
    "more_events": "+{{count}}개 더 보기",
    "turn_label": "T{{turn}}",
    "type": {
      "added": "추가됨",
      "modified": "수정됨",
      "removed": "제거됨"
    }
  },
  "scene": {
    "status": {
      "default": "데이터 대기 중",
      "loading": "동기화 중...",
      "offline": "연결 끊김",
      "blocked": "접근 제한됨",
      "low_signal": "신호 약함",
      "image_error": "장면 이미지를 불러올 수 없습니다.",
      "image_loading": "장면 이미지 로딩 중...",
      "image_generating": "새 장면 생성 중...",
      "initial_sync": "전역 데이터 동기화 대기 중...",
      "syncing": "데이터 동기화 중...",
      "alt": "장면 이미지"
    },
    "hotspot": {
      "layer_label": "클릭 가능한 오브젝트 영역",
      "hint_prefix": "힌트",
      "click_action": "{{label}} 클릭",
      "drop_hint": "여기에 드롭하여 사용",
      "drop_action": "{{item}}을(를) {{target}}에 사용",
      "drop_invalid": "그곳에는 {{item}}을(를) 사용할 수 없습니다.",
      "demo_hint": "[데모 대상]"
    }
  },
  "agent": {
    "console": {
      "queue": "대기열",
      "badges": "검증 배지",
      "repair": "자동 복구",
      "status": {
        "idle": "대기 중",
        "processing": "처리 중"
      },
      "badges_empty": "[ 검증 대기 중 ]",
      "repaired": "(복구됨)",
      "phase": {
        "parse": "Parse",
        "validate": "Validate",
        "plan": "Plan",
        "resolve": "Resolve",
        "render": "Render",
        "verify": "Verify",
        "commit": "Commit"
      },
      "badge": {
        "schema": "Schema",
        "economy": "Economy",
        "safety": "Safety",
        "consistency": "Consistency",
        "ok": "OK",
        "fail": "FAIL"
      }
    }
  },
  "ui": {
    "logo": "UNKNOWN WORLD",
    "command_placeholder": "명령을 입력하세요...",
    "processing": "처리 중...",
    "execute": "실행",
    "wait": "대기",
    "panel_placeholder": "[ 준비 중 ]",
    "scale_decrease": "글자 크기 줄이기",
    "scale_increase": "글자 크기 늘리기",
    "scale_label": "UI 스케일 설정"
  },
  "economy": {
    "signal": "Signal",
    "shard": "Shard",
    "signal_cost": "Signal 소모",
    "shard_cost": "Shard 소모",
    "risk_level": "위험도",
    "hud_label": "재화 현황",
    "estimated_cost": "예상 비용",
    "confirmed_cost": "확정 비용",
    "insufficient_funds": "잔액 부족",
    "low_balance_warning": "잔액이 부족합니다",
    "alternatives_title": "대안 행동",
    "alternative_text_only": "텍스트만 생성 (이미지 없음)",
    "alternative_low_quality": "저품질/빠른 응답 선택",
    "ledger_title": "최근 원장 이력",
    "ledger_empty": "[ 이력 없음 ]",
    "model_label": {
      "FAST": "빠름",
      "QUALITY": "고품질",
      "CHEAP": "저비용",
      "REF": "참조"
    }
  },
  "connection": {
    "online": "온라인",
    "offline": "오프라인"
  },
  "inventory": {
    "empty": "[ 아이템 없음 ]",
    "grid_label": "인벤토리 아이템 목록",
    "item_label": "{{name}} (수량: {{quantity}})",
    "drag_hint": "드래그하여 사용"
  },
  "panel": {
    "inventory": {
      "title": "Inventory",
      "placeholder": "[ 드래그 앤 드롭 영역 ]"
    },
    "quest": {
      "title": "Quest",
      "placeholder": "[ 목표/퀘스트 목록 ]"
    },
    "rule_board": {
      "title": "Rule Board",
      "placeholder": "[ 월드 규칙/변형 타임라인 ]"
    },
    "agent_console": {
      "title": "Agent Console"
    },
    "memory_pin": {
      "title": "Memory Pin",
      "placeholder": "[ 고정된 기억/단서 ]"
    },
    "scanner": {
      "title": "Scanner",
      "placeholder": "[ 이미지 업로드 슬롯 ]"
    }
  },
  "action": {
    "default": {
      "explore": {
        "label": "탐색하기",
        "description": "주변을 살펴본다"
      },
      "investigate": {
        "label": "조사하기",
        "description": "자세히 살펴본다"
      },
      "talk": {
        "label": "대화하기",
        "description": "말을 걸어본다"
      }
    },
    "card_select": "카드 선택: {{cardId}}",
    "deck_label": "행동 선택 카드",
    "alternative": "대안",
    "insufficient_balance": "잔액 부족",
    "all_disabled_notice": "실행 가능한 행동이 없습니다. 대안을 확인하세요.",
    "risk": {
      "low": "낮음",
      "medium": "보통",
      "high": "높음"
    },
    "cost_range": "{{min}}~{{max}}"
  },
  "narrative": {
    "welcome": "미지의 세계에 오신 것을 환영합니다...",
    "turn_label": "[TURN {{turn}}]",
    "streaming_label": "[STREAMING]"
  }
}
</file>

</files>
