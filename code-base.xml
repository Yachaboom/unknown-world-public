This file is a merged representation of a subset of the codebase, containing specifically included files and files not matching ignore patterns, combined into a single document by Repomix.

<file_summary>
This section contains a summary of this file.

<purpose>
This file contains a packed representation of a subset of the repository's contents that is considered the most important context.
It is designed to be easily consumable by AI systems for analysis, code review,
or other automated processes.
</purpose>

<file_format>
The content is organized as follows:
1. This summary section
2. Repository information
3. Directory structure
4. Repository files (if enabled)
5. Multiple file entries, each consisting of:
  - File path as an attribute
  - Full contents of the file
</file_format>

<usage_guidelines>
- This file should be treated as read-only. Any changes should be made to the
  original repository files, not this packed version.
- When processing this file, use the file path to distinguish
  between different files in the repository.
- Be aware that this file may contain sensitive information. Handle it with
  the same level of security as you would the original repository.
</usage_guidelines>

<notes>
- Some files may have been excluded based on .gitignore rules and Repomix's configuration
- Binary files are not included in this packed representation. Please refer to the Repository Structure section for a complete list of file paths, including binary files
- Only files matching these patterns are included: **/*.{ts,tsx,py,toml,json,yaml,html,css}
- Files matching these patterns are excluded: .claude/**, .cursor/**, .gemini/**, .vscode/**, vibe/**, node_modules/**, backend/.venv/**, frontend/dist/**
- Files matching patterns in .gitignore are excluded
- Files matching default ignore patterns are excluded
- Files are sorted by Git change count (files with more changes are at the bottom)
</notes>

</file_summary>

<directory_structure>
backend/debug_api_call.py
backend/debug_real_mode.py
backend/debug_schema_check.py
backend/debug_server_state.py
backend/debug_uvicorn_sim.py
backend/pyproject.toml
backend/run_full_test.py
backend/src/unknown_world/__init__.py
backend/src/unknown_world/api/__init__.py
backend/src/unknown_world/api/image.py
backend/src/unknown_world/api/item_icon.py
backend/src/unknown_world/api/scanner.py
backend/src/unknown_world/api/turn_stream_events.py
backend/src/unknown_world/api/turn_streaming_helpers.py
backend/src/unknown_world/api/turn.py
backend/src/unknown_world/config/__init__.py
backend/src/unknown_world/config/economy.py
backend/src/unknown_world/config/models.py
backend/src/unknown_world/main.py
backend/src/unknown_world/models/__init__.py
backend/src/unknown_world/models/scanner.py
backend/src/unknown_world/models/turn.py
backend/src/unknown_world/orchestrator/__init__.py
backend/src/unknown_world/orchestrator/conversation_history.py
backend/src/unknown_world/orchestrator/fallback.py
backend/src/unknown_world/orchestrator/generate_turn_output.py
backend/src/unknown_world/orchestrator/mock.py
backend/src/unknown_world/orchestrator/pipeline.py
backend/src/unknown_world/orchestrator/prompt_loader.py
backend/src/unknown_world/orchestrator/repair_loop.py
backend/src/unknown_world/orchestrator/stages/__init__.py
backend/src/unknown_world/orchestrator/stages/commit.py
backend/src/unknown_world/orchestrator/stages/parse.py
backend/src/unknown_world/orchestrator/stages/plan.py
backend/src/unknown_world/orchestrator/stages/render_helpers.py
backend/src/unknown_world/orchestrator/stages/render.py
backend/src/unknown_world/orchestrator/stages/resolve.py
backend/src/unknown_world/orchestrator/stages/types.py
backend/src/unknown_world/orchestrator/stages/validate.py
backend/src/unknown_world/orchestrator/stages/verify.py
backend/src/unknown_world/services/__init__.py
backend/src/unknown_world/services/agentic_vision.py
backend/src/unknown_world/services/genai_client.py
backend/src/unknown_world/services/image_generation.py
backend/src/unknown_world/services/image_understanding.py
backend/src/unknown_world/services/item_icon_generator.py
backend/src/unknown_world/storage/__init__.py
backend/src/unknown_world/storage/local_storage.py
backend/src/unknown_world/storage/paths.py
backend/src/unknown_world/storage/seed.py
backend/src/unknown_world/storage/storage.py
backend/src/unknown_world/storage/validation.py
backend/src/unknown_world/validation/__init__.py
backend/src/unknown_world/validation/business_rules.py
backend/src/unknown_world/validation/language_gate.py
backend/start_and_test.py
backend/test_api.py
backend/test_real_vision.json
backend/tests/conftest.py
backend/tests/fixtures/image_request_fast.json
backend/tests/fixtures/image_request_quality.json
backend/tests/fixtures/turn_request.json
backend/tests/integration/test_api.py
backend/tests/integration/test_item_icon_api.py
backend/tests/integration/test_multiturn_history.py
backend/tests/integration/test_rate_limit_flow.py
backend/tests/integration/test_real_mode_gate.py
backend/tests/integration/test_resolve_vision.py
backend/tests/integration/test_scanner_api.py
backend/tests/integration/test_turn_streaming.py
backend/tests/integration/test_u085_image_api.py
backend/tests/manual_test_image.py
backend/tests/qa/test_asset_manifest.py
backend/tests/qa/test_u052_manual_verification.py
backend/tests/unit/api/test_image.py
backend/tests/unit/models/test_turn.py
backend/tests/unit/models/test_u078_objectives.py
backend/tests/unit/orchestrator/test_conversation_history.py
backend/tests/unit/orchestrator/test_generate_turn_output.py
backend/tests/unit/orchestrator/test_mock_orchestrator.py
backend/tests/unit/orchestrator/test_pipeline.py
backend/tests/unit/orchestrator/test_prompt_loader.py
backend/tests/unit/orchestrator/test_repair_loop.py
backend/tests/unit/orchestrator/test_u051_bridge.py
backend/tests/unit/orchestrator/test_u052_render_helpers.py
backend/tests/unit/orchestrator/test_u052_render_integration.py
backend/tests/unit/orchestrator/test_u053_render_async.py
backend/tests/unit/orchestrator/test_u054_image_fallback.py
backend/tests/unit/orchestrator/test_u061_image_integration.py
backend/tests/unit/orchestrator/test_u069_model_tiering.py
backend/tests/unit/orchestrator/test_u090_hotspot_restriction.py
backend/tests/unit/orchestrator/test_u131_prompt_composition.py
backend/tests/unit/services/test_agentic_vision.py
backend/tests/unit/services/test_genai_client.py
backend/tests/unit/services/test_image_extraction.py
backend/tests/unit/services/test_image_generation.py
backend/tests/unit/services/test_item_icon_generator.py
backend/tests/unit/services/test_scanner_service.py
backend/tests/unit/services/test_u075_verification.py
backend/tests/unit/services/test_u085_image_sizing.py
backend/tests/unit/services/test_u093_timeout_retry.py
backend/tests/unit/services/test_u094_scan_retry.py
backend/tests/unit/services/test_u095_scanner_randomize.py
backend/tests/unit/test_dotenv_autoload.py
backend/tests/unit/test_orchestrator_repair.py
backend/tests/unit/test_u034_verification.py
backend/tests/unit/test_u043_language_gate.py
backend/tests/unit/test_u065_schema_simplification.py
backend/tests/unit/test_u068_reference_image.py
backend/tests/unit/test_u079_economy_low_balance.py
backend/tests/unit/test_u096_consumption.py
frontend/coverage/base.css
frontend/coverage/coverage-final.json
frontend/coverage/index.html
frontend/coverage/prettify.css
frontend/coverage/turn.ts.html
frontend/index.html
frontend/package.json
frontend/public/ui/manifest.json
frontend/public/ui/manifest.schema.json
frontend/src/api/image.ts
frontend/src/api/scanner.test.ts
frontend/src/api/scanner.ts
frontend/src/api/turnStream.economy.test.ts
frontend/src/api/turnStream.test.ts
frontend/src/api/turnStream.ts
frontend/src/App.inputLock.test.tsx
frontend/src/App.test.tsx
frontend/src/App.tsx
frontend/src/components/ActionDeck.test.tsx
frontend/src/components/ActionDeck.tsx
frontend/src/components/AgentConsole.test.tsx
frontend/src/components/AgentConsole.tsx
frontend/src/components/DemoProfileSelect.tsx
frontend/src/components/DndInteraction.test.tsx
frontend/src/components/EconomyHud.i18n.test.tsx
frontend/src/components/EconomyHud.test.tsx
frontend/src/components/EconomyHud.tsx
frontend/src/components/GameHeader.tsx
frontend/src/components/Hotspot.test.tsx
frontend/src/components/Hotspot.tsx
frontend/src/components/InteractionHint.test.tsx
frontend/src/components/InteractionHint.tsx
frontend/src/components/InventoryPanel.test.tsx
frontend/src/components/InventoryPanel.tsx
frontend/src/components/MutationTimeline.test.tsx
frontend/src/components/MutationTimeline.tsx
frontend/src/components/NarrativeFeed.test.tsx
frontend/src/components/NarrativeFeed.tsx
frontend/src/components/NarrativeFeed.U-125.test.tsx
frontend/src/components/ObjectiveTracker.test.tsx
frontend/src/components/ObjectiveTracker.tsx
frontend/src/components/Panel.tsx
frontend/src/components/QuestPanel.test.tsx
frontend/src/components/QuestPanel.tsx
frontend/src/components/RateLimitPanel.test.tsx
frontend/src/components/RateLimitPanel.tsx
frontend/src/components/ResetButton.tsx
frontend/src/components/RuleBoard.test.tsx
frontend/src/components/RuleBoard.tsx
frontend/src/components/ScannerSlot.test.tsx
frontend/src/components/ScannerSlot.tsx
frontend/src/components/SceneCanvas.hotspot.test.tsx
frontend/src/components/SceneCanvas.rendering.test.tsx
frontend/src/components/SceneCanvas.test.tsx
frontend/src/components/SceneCanvas.tsx
frontend/src/components/SceneImage.test.tsx
frontend/src/components/SceneImage.tsx
frontend/src/components/UIControls.tsx
frontend/src/data/demoProfiles.ts
frontend/src/data/itemIconPresets.ts
frontend/src/demo/demoFixtures.ts
frontend/src/demo/useDemoInitializer.ts
frontend/src/dnd/types.ts
frontend/src/i18n.ts
frontend/src/locales/en-US/translation.json
frontend/src/locales/ko-KR/translation.json
frontend/src/main.tsx
frontend/src/save/constants.ts
frontend/src/save/saveGame.ts
frontend/src/save/sessionLifecycle.test.ts
frontend/src/save/sessionLifecycle.ts
frontend/src/schemas/index.ts
frontend/src/schemas/turn.economy.test.ts
frontend/src/schemas/turn.test.ts
frontend/src/schemas/turn.ts
frontend/src/schemas/verify_runbook.ts
frontend/src/setupTests.ts
frontend/src/stores/actionDeckStore.test.ts
frontend/src/stores/actionDeckStore.ts
frontend/src/stores/agentStore.test.ts
frontend/src/stores/agentStore.ts
frontend/src/stores/economyStore.test.ts
frontend/src/stores/economyStore.ts
frontend/src/stores/inventory_consumption.test.ts
frontend/src/stores/inventoryStore.test.ts
frontend/src/stores/inventoryStore.ts
frontend/src/stores/onboardingStore.test.ts
frontend/src/stores/onboardingStore.ts
frontend/src/stores/uiPrefsStore.test.ts
frontend/src/stores/uiPrefsStore.ts
frontend/src/stores/worldStore.test.ts
frontend/src/stores/worldStore.ts
frontend/src/stores/worldStore.u066.test.ts
frontend/src/style.css
frontend/src/styles/hotspot.css
frontend/src/styles/interaction-hint.css
frontend/src/turn/turnRunner.test.ts
frontend/src/turn/turnRunner.ts
frontend/src/types/scene.ts
frontend/src/types/turn_stream.ts
frontend/src/utils/box2d.test.ts
frontend/src/utils/box2d.ts
frontend/src/utils/imageSizing.test.ts
frontend/src/utils/imageSizing.ts
frontend/src/vite-env.d.ts
frontend/tsconfig.json
frontend/tsconfig.node.json
frontend/vite.config.ts
package.json
request.json
scripts/process_item_icons.py
shared/schemas/turn/turn_input.schema.json
shared/schemas/turn/turn_output.schema.json
</directory_structure>

<files>
This section contains the contents of the repository's files.

<file path="backend/src/unknown_world/__init__.py">
"""Unknown World - Backend Package

This is the main package for the Unknown World backend.
Architecture: FastAPI + Pydantic + SSE streaming

Reference:
- vibe/tech-stack.md (Python 3.14, FastAPI 0.128.0, Pydantic 2.12.5)
- vibe/prd.md (Agent-based Game Master Engine)
"""

__version__ = "0.1.0"
</file>

<file path="backend/src/unknown_world/api/turn_stream_events.py">
"""Unknown World - Turn Stream 이벤트 계약(Contract).

NDJSON 스트리밍에서 사용되는 이벤트 타입, 모델, 유틸리티를 정의합니다.
이 모듈은 Orchestrator ↔ API ↔ Frontend 간의 스트림 이벤트 계약 SSOT입니다.

설계 원칙:
    - RU-002-Q4: 이벤트 계약을 transport 계층으로 분리
    - RULE-003: 구조화 출력(JSON Schema) 우선 + Pydantic 검증
    - RULE-008: 단계/배지 가시화

참조:
    - vibe/unit-plans/U-007[Mvp].md
    - vibe/refactors/RU-002-Q4.md
"""

from __future__ import annotations

import json
from typing import Annotated, Any

from pydantic import BaseModel, Field

# =============================================================================
# 스트림 이벤트 타입 상수
# =============================================================================


class StreamEventType:
    """스트림 이벤트 타입 상수.

    NDJSON 스트리밍에서 사용되는 이벤트 타입입니다.
    PRD 예시 단계: Parse→Validate→Plan→Resolve→Render→Verify→Commit
    """

    STAGE = "stage"
    BADGES = "badges"
    NARRATIVE_DELTA = "narrative_delta"
    FINAL = "final"
    ERROR = "error"
    REPAIR = "repair"


class StageStatus:
    """단계 상태 상수."""

    START = "start"
    COMPLETE = "complete"
    FAIL = "fail"


# =============================================================================
# 스트림 이벤트 모델 (Pydantic)
# =============================================================================


class StageEvent(BaseModel):
    """단계 진행 이벤트.

    Attributes:
        type: 이벤트 타입 ("stage")
        name: 단계 이름 (Parse, Validate, Plan, Resolve, Render, Verify, Commit)
        status: 상태 (start, complete)
    """

    type: Annotated[str, Field(default=StreamEventType.STAGE)]
    name: str
    status: str


class RepairEvent(BaseModel):
    """자동 복구(Repair) 이벤트.

    Attributes:
        type: 이벤트 타입 ("repair")
        attempt: 현재 시도 횟수
        message: 복구 메시지 (선택)
    """

    type: Annotated[str, Field(default=StreamEventType.REPAIR)]
    attempt: int
    message: str | None = None


class BadgesEvent(BaseModel):
    """배지 이벤트.

    Attributes:
        type: 이벤트 타입 ("badges")
        badges: 검증 배지 목록
    """

    type: Annotated[str, Field(default=StreamEventType.BADGES)]
    badges: list[str]


class NarrativeDeltaEvent(BaseModel):
    """내러티브 델타 이벤트 (타자 효과용).

    Attributes:
        type: 이벤트 타입 ("narrative_delta")
        text: 추가된 텍스트 조각
    """

    type: Annotated[str, Field(default=StreamEventType.NARRATIVE_DELTA)]
    text: str


class FinalEvent(BaseModel):
    """최종 TurnOutput 이벤트.

    Attributes:
        type: 이벤트 타입 ("final")
        data: 완전한 TurnOutput

    Note:
        TurnOutput은 TYPE_CHECKING 블록에서 import되며,
        런타임에는 Any로 처리됩니다.
    """

    type: Annotated[str, Field(default=StreamEventType.FINAL)]
    data: Any  # TurnOutput (순환 import 방지)


class ErrorEvent(BaseModel):
    """에러 이벤트.

    Attributes:
        type: 이벤트 타입 ("error")
        message: 에러 메시지 (프롬프트/내부 추론 노출 금지)
        code: 에러 코드 (선택)
    """

    type: Annotated[str, Field(default=StreamEventType.ERROR)]
    message: str
    code: str | None = None


# =============================================================================
# 유틸리티 함수
# =============================================================================


def serialize_event(event: dict[str, Any]) -> str:
    """이벤트를 NDJSON 라인으로 직렬화합니다.

    Args:
        event: 직렬화할 이벤트 딕셔너리

    Returns:
        str: NDJSON 형식 문자열 (줄바꿈 포함)
    """
    return json.dumps(event, ensure_ascii=False) + "\n"


# =============================================================================
# 모듈 공개 API
# =============================================================================

__all__ = [
    "StreamEventType",
    "StageStatus",
    "StageEvent",
    "RepairEvent",
    "BadgesEvent",
    "NarrativeDeltaEvent",
    "FinalEvent",
    "ErrorEvent",
    "serialize_event",
]
</file>

<file path="backend/src/unknown_world/config/__init__.py">
"""Unknown World - 설정 및 상수 패키지.

이 패키지는 프로젝트 전역에서 사용하는 설정값과 상수를 관리합니다.
모델 ID, 환경 설정, 정책 등 SSOT를 유지하기 위한 중앙 저장소입니다.

참조:
    - vibe/tech-stack.md (버전/모델 SSOT)
    - .cursor/rules/00-core-critical.mdc (RULE-010: 버전/스택 고정)
"""

from unknown_world.config.models import (
    MODEL_FAST,
    MODEL_IMAGE,
    MODEL_QUALITY,
    ModelLabel,
    get_model_id,
)

__all__ = [
    "MODEL_FAST",
    "MODEL_QUALITY",
    "MODEL_IMAGE",
    "ModelLabel",
    "get_model_id",
]
</file>

<file path="backend/src/unknown_world/orchestrator/__init__.py">
"""Unknown World - Orchestrator 패키지.

이 패키지는 턴 처리 오케스트레이터를 포함합니다.
"""

from unknown_world.orchestrator.fallback import create_safe_fallback
from unknown_world.orchestrator.generate_turn_output import (
    GenerationResult,
    GenerationStatus,
    TurnOutputGenerator,
    generate_turn_output,
    get_turn_output_generator,
)
from unknown_world.orchestrator.mock import MockOrchestrator
from unknown_world.orchestrator.prompt_loader import (
    clear_prompt_cache,
    load_prompt,
    load_system_prompt,
    load_turn_instructions,
)
from unknown_world.orchestrator.repair_loop import (
    MAX_REPAIR_ATTEMPTS,
    RepairLoopResult,
    run_repair_loop,
)

__all__ = [
    # Mock Orchestrator
    "MockOrchestrator",
    # TurnOutput 생성
    "GenerationResult",
    "GenerationStatus",
    "TurnOutputGenerator",
    "generate_turn_output",
    "get_turn_output_generator",
    # Repair Loop (U-018)
    "MAX_REPAIR_ATTEMPTS",
    "RepairLoopResult",
    "run_repair_loop",
    # Fallback (U-018)
    "create_safe_fallback",
    # 프롬프트 로더
    "clear_prompt_cache",
    "load_prompt",
    "load_system_prompt",
    "load_turn_instructions",
]
</file>

<file path="backend/src/unknown_world/orchestrator/stages/__init__.py">
"""Unknown World - Pipeline Stages 패키지.

오케스트레이터 파이프라인의 각 단계(stage)를 모듈로 분리합니다.

단계 목록 (PRD 기준):
    - parse: 입력 파싱 (이미 TurnInput으로 변환됨, phase 전이만 담당)
    - validate: 비즈니스 룰 검증 + Repair loop (핵심)
    - plan: 계획 수립 (현재 pass-through)
    - resolve: 해결 (현재 pass-through)
    - render: 렌더링 (현재 pass-through)
    - verify: 검증 (현재 pass-through)
    - commit: 커밋 (최종 확정)

설계 원칙:
    - Option A (RU-005 Q1 결정): 함수 체인 방식, 클래스 도입 없음
    - 동작 보존: 기존 mock/real 경로의 결과(JSON) 의미 유지
    - 관측 가능성 SSOT: stage start/complete/fail, badges, repair를 pipeline에서 일관되게 생성

참조:
    - vibe/refactors/RU-005-Q4.md
    - vibe/refactors/RU-005-SUMMARY.md
"""

from unknown_world.orchestrator.stages.commit import commit_stage
from unknown_world.orchestrator.stages.parse import parse_stage
from unknown_world.orchestrator.stages.plan import plan_stage
from unknown_world.orchestrator.stages.render import render_stage
from unknown_world.orchestrator.stages.resolve import resolve_stage
from unknown_world.orchestrator.stages.types import (
    EmitFn,
    PipelineContext,
    PipelineEvent,
    PipelineEventType,
    StageFn,
)
from unknown_world.orchestrator.stages.validate import validate_stage
from unknown_world.orchestrator.stages.verify import verify_stage

__all__ = [
    # Types
    "PipelineContext",
    "PipelineEvent",
    "PipelineEventType",
    "EmitFn",
    "StageFn",
    # Stages
    "parse_stage",
    "validate_stage",
    "plan_stage",
    "resolve_stage",
    "render_stage",
    "verify_stage",
    "commit_stage",
]
</file>

<file path="backend/src/unknown_world/orchestrator/stages/commit.py">
"""Unknown World - Commit Stage.

커밋 단계입니다.
파이프라인의 최종 단계로, TurnOutput을 확정합니다.

설계 원칙:
    - RULE-008: 단계 이벤트 일관성
    - 동작 보존: 기존 시뮬레이션 지연 유지

참조:
    - vibe/refactors/RU-005-Q4.md
"""

from __future__ import annotations

import asyncio

from unknown_world.models.turn import AgentPhase
from unknown_world.orchestrator.stages.types import (
    EmitFn,
    PipelineContext,
    PipelineEvent,
    PipelineEventType,
)

# 모의 처리 지연 시간 (ms)
COMMIT_DELAY_MS = 20


async def commit_stage(ctx: PipelineContext, *, emit: EmitFn) -> PipelineContext:
    """Commit 단계를 실행합니다.

    파이프라인의 최종 단계로, TurnOutput을 확정합니다.

    Args:
        ctx: 파이프라인 컨텍스트
        emit: 이벤트 emit 콜백

    Returns:
        업데이트된 컨텍스트
    """
    ctx.current_phase = AgentPhase.COMMIT

    # Stage 시작 이벤트
    await emit(
        PipelineEvent(
            event_type=PipelineEventType.STAGE_START,
            phase=AgentPhase.COMMIT,
        )
    )

    # 모의 처리 지연 (기존 동작 보존)
    await asyncio.sleep(COMMIT_DELAY_MS / 1000.0)

    # Stage 완료 이벤트
    await emit(
        PipelineEvent(
            event_type=PipelineEventType.STAGE_COMPLETE,
            phase=AgentPhase.COMMIT,
        )
    )

    return ctx
</file>

<file path="backend/src/unknown_world/orchestrator/stages/parse.py">
"""Unknown World - Parse Stage.

입력 파싱 단계입니다.
TurnInput은 이미 API 레이어에서 파싱되었으므로, phase 전이만 담당합니다.

설계 원칙:
    - RULE-008: 단계 이벤트 일관성 (stage start/complete)
    - 동작 보존: 기존 동작 유지

참조:
    - vibe/refactors/RU-005-Q4.md
"""

from __future__ import annotations

from unknown_world.models.turn import AgentPhase
from unknown_world.orchestrator.stages.types import (
    EmitFn,
    PipelineContext,
    PipelineEvent,
    PipelineEventType,
)


async def parse_stage(ctx: PipelineContext, *, emit: EmitFn) -> PipelineContext:
    """Parse 단계를 실행합니다.

    입력은 이미 TurnInput으로 파싱되었으므로, phase 전이만 담당합니다.
    TTFB를 위해 가장 먼저 stage 이벤트를 전송합니다.

    Args:
        ctx: 파이프라인 컨텍스트
        emit: 이벤트 emit 콜백

    Returns:
        업데이트된 컨텍스트
    """
    ctx.current_phase = AgentPhase.PARSE

    # Stage 시작 이벤트 (TTFB를 위해 즉시 전송)
    await emit(
        PipelineEvent(
            event_type=PipelineEventType.STAGE_START,
            phase=AgentPhase.PARSE,
        )
    )

    # Parse 단계는 이미 API 레이어에서 완료됨
    # (TurnInput 검증은 FastAPI/Pydantic에서 처리)

    # Stage 완료 이벤트
    await emit(
        PipelineEvent(
            event_type=PipelineEventType.STAGE_COMPLETE,
            phase=AgentPhase.PARSE,
        )
    )

    return ctx
</file>

<file path="backend/src/unknown_world/orchestrator/stages/plan.py">
"""Unknown World - Plan Stage.

계획 수립 단계입니다.
현재 MVP에서는 실제 처리 없이 pass-through로 동작합니다.
추후 Autopilot(U-024) 등에서 로직을 추가할 자리입니다.

설계 원칙:
    - RULE-008: 단계 이벤트 일관성
    - 동작 보존: 기존 시뮬레이션 지연 유지

참조:
    - vibe/refactors/RU-005-Q4.md
"""

from __future__ import annotations

import asyncio

from unknown_world.models.turn import AgentPhase
from unknown_world.orchestrator.stages.types import (
    EmitFn,
    PipelineContext,
    PipelineEvent,
    PipelineEventType,
)

# 모의 처리 지연 시간 (ms)
PLAN_DELAY_MS = 100


async def plan_stage(ctx: PipelineContext, *, emit: EmitFn) -> PipelineContext:
    """Plan 단계를 실행합니다.

    현재는 pass-through로 동작합니다.
    추후 Autopilot 등에서 계획 수립 로직을 추가합니다.

    Args:
        ctx: 파이프라인 컨텍스트
        emit: 이벤트 emit 콜백

    Returns:
        업데이트된 컨텍스트
    """
    ctx.current_phase = AgentPhase.PLAN

    # Stage 시작 이벤트
    await emit(
        PipelineEvent(
            event_type=PipelineEventType.STAGE_START,
            phase=AgentPhase.PLAN,
        )
    )

    # 모의 처리 지연 (기존 동작 보존)
    await asyncio.sleep(PLAN_DELAY_MS / 1000.0)

    # Stage 완료 이벤트
    await emit(
        PipelineEvent(
            event_type=PipelineEventType.STAGE_COMPLETE,
            phase=AgentPhase.PLAN,
        )
    )

    return ctx
</file>

<file path="backend/src/unknown_world/validation/__init__.py">
"""Unknown World - 검증 모듈.

비즈니스 룰 검증기 및 언어 혼합 검증 게이트를 제공합니다.
"""

from unknown_world.validation.business_rules import (
    BusinessRuleError,
    BusinessRuleValidationResult,
    validate_business_rules,
)
from unknown_world.validation.language_gate import (
    MIXED_THRESHOLD_RATIO,
    LanguageGateResult,
    LanguageRatio,
    build_language_error_summary,
    is_language_mixed,
    measure_language_ratio,
    validate_language_consistency,
)

__all__ = [
    # Business Rules
    "BusinessRuleError",
    "BusinessRuleValidationResult",
    "validate_business_rules",
    # Language Gate (U-043)
    "MIXED_THRESHOLD_RATIO",
    "LanguageGateResult",
    "LanguageRatio",
    "build_language_error_summary",
    "is_language_mixed",
    "measure_language_ratio",
    "validate_language_consistency",
]
</file>

<file path="backend/tests/integration/test_api.py">
from fastapi.testclient import TestClient

from unknown_world.main import app

client = TestClient(app)


def test_health_check():
    """/health 엔드포인트가 올바른 스키마와 상태를 반환하는지 테스트합니다."""
    response = client.get("/health")
    assert response.status_code == 200
    data = response.json()
    assert data["status"] == "ok"
    assert "version" in data
    assert data["service"] == "unknown-world-backend"


def test_root_endpoint():
    """루트 엔드포인트가 정상 작동하는지 테스트합니다."""
    response = client.get("/")
    assert response.status_code == 200
    assert "message" in response.json()


def test_cors_policy():
    """RULE-011에 따른 CORS 정책이 올바르게 설정되었는지 테스트합니다."""
    # 허용된 오리진 테스트 (포트 8001)
    headers = {
        "Origin": "http://localhost:8001",
        "Access-Control-Request-Method": "GET",
    }
    response = client.options("/health", headers=headers)
    assert response.status_code == 200
    assert response.headers.get("access-control-allow-origin") == "http://localhost:8001"

    # 허용되지 않은 오리진 테스트 (포트 9000)
    headers = {
        "Origin": "http://localhost:9000",
        "Access-Control-Request-Method": "GET",
    }
    response = client.options("/health", headers=headers)
    # FastAPI/Starlette CORS 미들웨어는 허용되지 않은 경우 origin 헤더를 반환하지 않음
    assert "access-control-allow-origin" not in response.headers
</file>

<file path="backend/tests/manual_test_image.py">
"""Unknown World - 이미지 생성 API 수동 검증 스크립트."""

import json
import os

from fastapi.testclient import TestClient

from unknown_world.main import app


def run_manual_test():
    # UW_MODE를 mock으로 강제 설정하여 API 호출 없이 로직 검증
    os.environ["UW_MODE"] = "mock"
    client = TestClient(app)

    print("=== [1] 이미지 생성 요청 테스트 ===")
    payload = {
        "prompt": "A retro-future computer terminal with green text",
        "aspect_ratio": "1:1",
        "image_size": "1024x1024",
    }

    response = client.post("/api/image/generate", json=payload)
    print(f"Status Code: {response.status_code}")
    print(f"Response: {json.dumps(response.json(), indent=2, ensure_ascii=False)}")

    if response.status_code == 200:
        data = response.json()
        image_url = data["image_url"]
        image_id = data["image_id"]

        print(f"\n=== [2] 정적 파일 서빙 테스트 ({image_url}) ===")
        static_resp = client.get(image_url)
        print(f"Static Content-Type: {static_resp.headers.get('content-type')}")
        print(f"Static Success: {static_resp.status_code == 200}")

        print(f"\n=== [3] 이미지 상태 조회 테스트 ({image_id}) ===")
        status_resp = client.get(f"/api/image/status/{image_id}")
        print(f"Status Response: {json.dumps(status_resp.json(), indent=2, ensure_ascii=False)}")

        print(f"\n=== [4] 이미지 파일 직접 조회 테스트 (/api/image/file/{image_id}) ===")
        file_resp = client.get(f"/api/image/file/{image_id}")
        print(f"File Content-Type: {file_resp.headers.get('content-type')}")
        print(f"File Success: {file_resp.status_code == 200}")


if __name__ == "__main__":
    run_manual_test()
</file>

<file path="backend/tests/unit/api/test_image.py">
"""Unknown World - 이미지 생성 API 엔드포인트 단위 테스트."""

import pytest
from fastapi.testclient import TestClient

from unknown_world.main import app
from unknown_world.services.image_generation import (
    ImageGenerationStatus,
    get_image_generator,
    reset_image_generator,
)


@pytest.fixture
def client():
    """FastAPI TestClient 픽스처."""
    return TestClient(app)


@pytest.fixture(autouse=True)
def setup_mock_generator():
    """모든 테스트에서 Mock 생성기를 사용하도록 설정."""
    reset_image_generator()
    get_image_generator(force_mock=True)
    yield
    reset_image_generator()


def test_generate_image_success(client):
    """이미지 생성 성공 케이스 테스트."""
    payload = {
        "prompt": "A futuristic laboratory with glowing screens",
        "aspect_ratio": "1:1",
        "image_size": "1024x1024",
        "skip_on_failure": True,
    }

    response = client.post("/api/image/generate", json=payload)

    assert response.status_code == 200
    data = response.json()
    assert data["success"] is True
    assert data["status"] == ImageGenerationStatus.COMPLETED
    assert data["image_id"] is not None
    assert data["image_url"] is not None


def test_generate_image_validation_error(client):
    """이미지 생성 요청 검증 실패 테스트."""
    # 너무 짧은 프롬프트
    payload = {"prompt": "A", "skip_on_failure": False}

    response = client.post("/api/image/generate", json=payload)

    assert response.status_code == 400
    assert "프롬프트가 너무 짧습니다" in response.json()["detail"]


def test_generate_image_fallback_on_error(client):
    """검증 실패 시 skip_on_failure=True일 때 폴백 동작 테스트."""
    payload = {"prompt": "A", "skip_on_failure": True}

    response = client.post("/api/image/generate", json=payload)

    assert response.status_code == 200
    data = response.json()
    assert data["success"] is False
    assert data["status"] == "skipped"
    assert "프롬프트가 너무 짧습니다" in data["message"]


def test_get_image_status(client):
    """이미지 상태 조회 테스트."""
    # 먼저 생성
    gen_resp = client.post("/api/image/generate", json={"prompt": "Test status"})
    image_id = gen_resp.json()["image_id"]

    # 상태 조회
    status_resp = client.get(f"/api/image/status/{image_id}")
    assert status_resp.status_code == 200
    assert status_resp.json()["exists"] is True
    assert status_resp.json()["image_url"] is not None


def test_static_image_access(client):
    """정적 파일 경로를 통한 이미지 접근 테스트."""
    # 이미지 생성
    gen_resp = client.post("/api/image/generate", json={"prompt": "Test static access"})
    image_url = gen_resp.json()["image_url"]

    # 정적 경로로 접근
    response = client.get(image_url)
    assert response.status_code == 200
    assert response.headers["content-type"] == "image/png"


def test_get_image_file_not_found(client):
    """존재하지 않는 이미지 파일 요청 시 404 테스트."""
    response = client.get("/api/image/file/non_existent_id")
    assert response.status_code == 404
</file>

<file path="backend/tests/unit/orchestrator/test_generate_turn_output.py">
"""Unknown World - TurnOutputGenerator 단위 테스트.

U-017[Mvp] 완료 기준 검증:
    - Structured Outputs 호출 구성 (application/json, response_schema)
    - Pydantic 검증 (model_validate_json)
    - 실패 분기 처리 (SCHEMA_FAILURE)
    - language 정책 준수
"""

import json
from unittest.mock import AsyncMock, patch

import pytest

from unknown_world.models.turn import (
    ClientInfo,
    CurrencyAmount,
    EconomySnapshot,
    Language,
    Theme,
    TurnInput,
    TurnOutput,
)
from unknown_world.orchestrator.generate_turn_output import (
    GenerationStatus,
    TurnOutputGenerator,
)
from unknown_world.services.genai_client import GenerateResponse


@pytest.fixture
def turn_input() -> TurnInput:
    """기본 턴 입력 픽스처."""
    return TurnInput(
        language=Language.KO,
        text="문을 열어본다",
        client=ClientInfo(viewport_w=1920, viewport_h=1080, theme=Theme.DARK),
        economy_snapshot=EconomySnapshot(signal=100, memory_shard=5),
    )


@pytest.fixture
def valid_turn_output_json() -> str:
    """유효한 TurnOutput JSON 문자열 픽스처."""
    return json.dumps(
        {
            "language": "ko-KR",
            "narrative": "낡은 문이 열리고 먼지가 날립니다.",
            "economy": {
                "cost": {"signal": 5, "memory_shard": 0},
                "balance_after": {"signal": 95, "memory_shard": 5},
            },
            "safety": {"blocked": False, "message": None},
            "ui": {"action_deck": {"cards": []}, "objects": []},
            "world": {
                "rules_changed": [],
                "inventory_added": [],
                "inventory_removed": [],
                "quests_updated": [],
                "memory_pins": [],
            },
            "render": {"image_job": None},
            "agent_console": {
                "current_phase": "commit",
                "badges": ["schema_ok", "economy_ok", "safety_ok"],
                "repair_count": 0,
            },
        }
    )


@pytest.mark.asyncio
async def test_generate_success(turn_input, valid_turn_output_json):
    """성공적인 생성 및 Pydantic 검증 테스트."""
    generator = TurnOutputGenerator(force_mock=True)

    # Mock GenAIClient.generate
    mock_response = GenerateResponse(text=valid_turn_output_json, model_label="fast")

    with patch(
        "unknown_world.orchestrator.generate_turn_output.get_genai_client"
    ) as mock_get_client:
        mock_client = AsyncMock()
        mock_client.generate.return_value = mock_response
        mock_get_client.return_value = mock_client

        result = await generator.generate(turn_input)

        assert result.status == GenerationStatus.SUCCESS
        assert isinstance(result.output, TurnOutput)
        assert result.output.narrative == "낡은 문이 열리고 먼지가 날립니다."
        assert result.output.language == Language.KO

        # API 호출 인자 검증 (Structured Outputs 설정 확인)
        call_args = mock_client.generate.call_args[0][0]
        assert call_args.response_mime_type == "application/json"
        assert call_args.response_schema is not None
        assert "narrative" in call_args.response_schema["properties"]


@pytest.mark.asyncio
async def test_generate_schema_validation_failure(turn_input):
    """Pydantic 검증 실패(SCHEMA_FAILURE) 테스트."""
    generator = TurnOutputGenerator(force_mock=True)

    # 필수 필드(narrative)가 누락된 잘못된 JSON
    invalid_json = json.dumps(
        {
            "language": "ko-KR",
            # "narrative" 필드 누락
            "economy": {
                "cost": {"signal": 5, "memory_shard": 0},
                "balance_after": {"signal": 95, "memory_shard": 5},
            },
            "safety": {"blocked": False, "message": None},
        }
    )

    mock_response = GenerateResponse(text=invalid_json, model_label="fast")

    with patch(
        "unknown_world.orchestrator.generate_turn_output.get_genai_client"
    ) as mock_get_client:
        mock_client = AsyncMock()
        mock_client.generate.return_value = mock_response
        mock_get_client.return_value = mock_client

        result = await generator.generate(turn_input)

        assert result.status == GenerationStatus.SCHEMA_FAILURE
        assert result.output is None
        assert "validation_errors" in result.error_details


@pytest.mark.asyncio
async def test_generate_json_decode_error(turn_input):
    """JSON 파싱 실패 테스트."""
    generator = TurnOutputGenerator(force_mock=True)

    # 유효하지 않은 JSON 형식
    invalid_text = "이것은 JSON이 아닙니다 { narrative: ... "

    mock_response = GenerateResponse(text=invalid_text, model_label="fast")

    with patch(
        "unknown_world.orchestrator.generate_turn_output.get_genai_client"
    ) as mock_get_client:
        mock_client = AsyncMock()
        mock_client.generate.return_value = mock_response
        mock_get_client.return_value = mock_client

        result = await generator.generate(turn_input)

        assert result.status == GenerationStatus.SCHEMA_FAILURE
        # Pydantic model_validate_json은 JSON 파싱 실패도 ValidationError(type=json_invalid)로 보고함
        errors = result.error_details.get("validation_errors", [])
        assert any(err["type"] == "json_invalid" for err in errors)


@pytest.mark.asyncio
async def test_generate_markdown_json_extraction(turn_input, valid_turn_output_json):
    """마크다운 코드 블록 내의 JSON 추출 테스트."""
    generator = TurnOutputGenerator(force_mock=True)

    # 마크다운 코드 블록으로 감싸진 응답
    markdown_text = f"```json\n{valid_turn_output_json}\n```"

    mock_response = GenerateResponse(text=markdown_text, model_label="fast")

    with patch(
        "unknown_world.orchestrator.generate_turn_output.get_genai_client"
    ) as mock_get_client:
        mock_client = AsyncMock()
        mock_client.generate.return_value = mock_response
        mock_get_client.return_value = mock_client

        result = await generator.generate(turn_input)

        assert result.status == GenerationStatus.SUCCESS
        assert result.output.narrative == "낡은 문이 열리고 먼지가 날립니다."


@pytest.mark.asyncio
async def test_generate_api_error(turn_input):
    """API 호출 에러 처리 테스트."""
    generator = TurnOutputGenerator(force_mock=True)

    with patch(
        "unknown_world.orchestrator.generate_turn_output.get_genai_client"
    ) as mock_get_client:
        mock_client = AsyncMock()
        mock_client.generate.side_effect = RuntimeError("API connection failed")
        mock_get_client.return_value = mock_client

        result = await generator.generate(turn_input)

        assert result.status == GenerationStatus.API_ERROR
        assert "API connection failed" in result.error_details["api_error"]


def test_create_safe_fallback():
    """안전한 폴백 생성 테스트 (RULE-004)."""
    generator = TurnOutputGenerator()

    economy_snapshot = CurrencyAmount(signal=80, memory_shard=3)
    fallback = generator.create_safe_fallback(
        language=Language.KO, error_message="Test Error", economy_snapshot=economy_snapshot
    )

    assert isinstance(fallback, TurnOutput)
    assert fallback.language == Language.KO
    assert fallback.economy.cost.signal == 0
    assert fallback.economy.balance_after.signal == 80
    assert "혼란스러운" in fallback.narrative
</file>

<file path="backend/tests/unit/orchestrator/test_pipeline.py">
"""Unknown World - Pipeline 단위/통합 테스트.

RU-005[Mvp] 리팩토링 검증:
    - Stage 기반 모듈화 동작 보존
    - PipelineContext 상태 전이 확인
    - 이벤트 emit 순서 및 정합성 (RULE-008)
    - U-018 비즈니스 룰 검증 및 Repair 루프 통합 확인
"""

from unittest.mock import AsyncMock, patch

import pytest

from unknown_world.models.turn import (
    AgentPhase,
    ClientInfo,
    EconomySnapshot,
    Language,
    Theme,
    TurnInput,
    TurnOutput,
    ValidationBadge,
)
from unknown_world.orchestrator.pipeline import (
    create_pipeline_context,
    run_pipeline,
)
from unknown_world.orchestrator.stages.types import (
    PipelineEvent,
    PipelineEventType,
)


@pytest.fixture
def turn_input() -> TurnInput:
    """기본 턴 입력 픽스처."""
    return TurnInput(
        language=Language.KO,
        text="문을 열어본다",
        client=ClientInfo(viewport_w=1920, viewport_h=1080, theme=Theme.DARK),
        economy_snapshot=EconomySnapshot(signal=100, memory_shard=5),
    )


def test_create_pipeline_context(turn_input):
    """컨텍스트 초기화 검증."""
    ctx = create_pipeline_context(turn_input, seed=42, is_mock=True)

    assert ctx.turn_input == turn_input
    assert ctx.economy_snapshot.signal == 100
    assert ctx.economy_snapshot.memory_shard == 5
    assert ctx.is_mock is True
    assert ctx.seed == 42
    assert ctx.output is None
    assert ctx.badges == []


@pytest.mark.asyncio
async def test_run_pipeline_happy_path_mock(turn_input):
    """Mock 모드에서 정상적인 파이프라인 실행 확인 (Happy Path)."""
    ctx = create_pipeline_context(turn_input, seed=42, is_mock=True)
    events = []

    async def emit(event: PipelineEvent):
        events.append(event)

    ctx = await run_pipeline(ctx, emit=emit)

    # 1. 최종 결과 확인
    assert ctx.output is not None
    assert isinstance(ctx.output, TurnOutput)
    assert ctx.is_fallback is False
    assert ctx.repair_attempts == 0

    # 2. 이벤트 순서 확인 (일부 핵심 단계만)
    event_types = [e.event_type for e in events]
    phases = [e.phase for e in events if e.phase is not None]

    assert PipelineEventType.STAGE_START in event_types
    assert PipelineEventType.STAGE_COMPLETE in event_types
    assert PipelineEventType.BADGES in event_types

    # PRD 순서: Parse -> Validate -> ... -> Commit
    assert AgentPhase.PARSE in phases
    assert AgentPhase.VALIDATE in phases
    assert AgentPhase.COMMIT in phases

    # 3. 배지 확인
    badges_events = [e for e in events if e.event_type == PipelineEventType.BADGES]
    assert len(badges_events) > 0
    assert ValidationBadge.SCHEMA_OK in badges_events[0].badges


@pytest.mark.asyncio
async def test_run_pipeline_validation_failure_repair_mock(turn_input):
    """비즈니스 룰 위반 시 Repair 루프 발생 확인 (Mock)."""
    ctx = create_pipeline_context(turn_input, seed=42, is_mock=True)
    events = []

    async def emit(event: PipelineEvent):
        events.append(event)

    # validate_business_rules를 모킹하여 첫 번째 시도에서 실패하게 함
    with patch(
        "unknown_world.orchestrator.stages.validate.validate_business_rules"
    ) as mock_validate:
        from unknown_world.validation.business_rules import BusinessRuleValidationResult

        mock_validate.side_effect = [
            BusinessRuleValidationResult(
                is_valid=False, errors=[{"type": "economy_insufficient", "message": "error"}]
            ),
            BusinessRuleValidationResult(is_valid=True, errors=[]),
        ]

        ctx = await run_pipeline(ctx, emit=emit)

    # Repair 이벤트가 발생했는지 확인
    repair_events = [e for e in events if e.event_type == PipelineEventType.REPAIR]
    assert len(repair_events) == 1
    assert repair_events[0].repair_attempt == 1
    assert ctx.repair_attempts == 1
    assert ctx.is_fallback is False


@pytest.mark.asyncio
async def test_run_pipeline_exception_fallback(turn_input):
    """스테이지 실행 중 예외 발생 시 폴백 확인."""
    ctx = create_pipeline_context(turn_input, is_mock=True)

    async def emit(event: PipelineEvent):
        pass

    # 예외를 던지는 가짜 스테이지
    async def failing_stage(c, *, emit):
        raise RuntimeError("Unexpected error")

    # 가짜 스테이지를 직접 전달하여 실행
    ctx = await run_pipeline(ctx, emit=emit, stages=[failing_stage])

    assert ctx.is_fallback is True
    assert ctx.output is not None
    assert "혼란스러운 순간" in ctx.output.narrative
    # 폴백 시 비용 0 확인 (RULE-005)
    assert ctx.output.economy.cost.signal == 0
    assert ctx.output.economy.balance_after.signal == 100


@pytest.mark.asyncio
async def test_validate_stage_real_delegation(turn_input):
    """validate_stage가 Real 모드에서 run_repair_loop를 호출하는지 확인."""
    from unknown_world.models.turn import AgentConsole, TurnOutput
    from unknown_world.orchestrator.repair_loop import RepairLoopResult
    from unknown_world.orchestrator.stages.validate import validate_stage

    ctx = create_pipeline_context(turn_input, is_mock=False)
    events = []

    async def emit(event: PipelineEvent):
        events.append(event)

    # 실제 객체 생성 후 필요한 필드만 모킹
    mock_output = AsyncMock(spec=TurnOutput)
    # dataclass 필드들에 대한 attribute 에러 방지를 위해 수동 설정
    mock_output.agent_console = AgentConsole(
        badges=[ValidationBadge.SCHEMA_OK], current_phase=AgentPhase.VALIDATE
    )

    with patch("unknown_world.orchestrator.stages.validate.run_repair_loop") as mock_run:
        mock_run.return_value = RepairLoopResult(
            output=mock_output,
            repair_attempts=1,
            is_fallback=False,
            badges=[ValidationBadge.SCHEMA_OK],
            error_messages=["repair test"],
        )

        ctx = await validate_stage(ctx, emit=emit)

    assert mock_run.called
    assert ctx.repair_attempts == 1
    assert PipelineEventType.REPAIR in [e.event_type for e in events]
    assert ctx.output == mock_output


@pytest.mark.asyncio
async def test_validate_stage_mock_max_retries_fallback(turn_input):
    """Mock 모드에서 최대 재시도 횟수 초과 시 폴백 확인."""
    from unknown_world.orchestrator.repair_loop import MAX_REPAIR_ATTEMPTS
    from unknown_world.orchestrator.stages.validate import validate_stage

    ctx = create_pipeline_context(turn_input, seed=42, is_mock=True)
    events = []

    async def emit(event: PipelineEvent):
        events.append(event)

    # 항상 실패하는 비즈니스 룰 검증 결과 반환
    with patch(
        "unknown_world.orchestrator.stages.validate.validate_business_rules"
    ) as mock_validate:
        from unknown_world.validation.business_rules import BusinessRuleValidationResult

        mock_validate.return_value = BusinessRuleValidationResult(
            is_valid=False, errors=[{"type": "economy_insufficient", "message": "error"}]
        )

        ctx = await validate_stage(ctx, emit=emit)

    assert ctx.is_fallback is True
    assert ctx.repair_attempts == MAX_REPAIR_ATTEMPTS + 1  # 0회차 + 1회차 + 2회차 시도 후 실패
    assert ValidationBadge.ECONOMY_FAIL in ctx.badges
    assert ctx.output.economy.cost.signal == 0


@pytest.mark.asyncio
async def test_validate_stage_mock_unexpected_exception(turn_input):
    """Mock 검증 루프 내에서 예외 발생 시 폴백 확인."""
    from unknown_world.orchestrator.stages.validate import validate_stage

    ctx = create_pipeline_context(turn_input, seed=42, is_mock=True)
    events = []

    async def emit(event: PipelineEvent):
        events.append(event)

    # generate_turn_output 호출 시 예외 발생
    with patch(
        "unknown_world.orchestrator.mock.MockOrchestrator.generate_turn_output",
        side_effect=RuntimeError("Mock error"),
    ):
        ctx = await validate_stage(ctx, emit=emit)

    assert ctx.is_fallback is True
    # _validate_mock 내부 try-except 루프가 MAX_REPAIR_ATTEMPTS만큼 돌고 결국 폴백
    assert ctx.repair_attempts > 0
</file>

<file path="backend/tests/unit/orchestrator/test_prompt_loader.py">
"""Unit tests for prompt_loader.py.

U-036: 프롬프트 로더 핫리로드 테스트
U-046: XML 태그 파싱 + 레거시 폴백 테스트
"""

from __future__ import annotations

import os
import unittest

from unknown_world.models.turn import Language
from unknown_world.orchestrator.prompt_loader import (
    _parse_frontmatter,
    _parse_legacy_frontmatter,
    _parse_xml_meta,
    clear_prompt_cache,
    is_hot_reload_enabled,
    load_prompt,
    load_prompt_with_metadata,
)


class TestPromptLoader(unittest.TestCase):
    def setUp(self) -> None:
        # Clear cache before each test
        clear_prompt_cache()
        # Backup environment
        self._old_env = os.environ.get("ENVIRONMENT")

    def tearDown(self) -> None:
        # Restore environment
        if self._old_env is None:
            if "ENVIRONMENT" in os.environ:
                del os.environ["ENVIRONMENT"]
        else:
            os.environ["ENVIRONMENT"] = self._old_env
        # Clear cache
        clear_prompt_cache()

    def test_load_prompt_ko(self) -> None:
        """Verify loading Korean prompt."""
        # This assumes the file exists in backend/prompts/system/game_master.ko.md
        prompt = load_prompt("system", "game_master", Language.KO)
        self.assertGreater(len(prompt), 0)
        self.assertIn("#", prompt)  # Should be markdown

    def test_load_prompt_en(self) -> None:
        """Verify loading English prompt."""
        prompt = load_prompt("system", "game_master", Language.EN)
        self.assertGreater(len(prompt), 0)

    def test_load_with_metadata(self) -> None:
        """Verify frontmatter parsing."""
        data = load_prompt_with_metadata("system", "game_master", Language.KO)
        self.assertIsNotNone(data.content)
        self.assertIsInstance(data.metadata, dict)
        # Check for typical metadata fields if they exist in the file
        if "prompt_id" in data.metadata:
            self.assertGreater(len(data.metadata["prompt_id"]), 0)

    def test_hot_reload_development(self) -> None:
        """Verify hot-reload works in development mode."""
        os.environ["ENVIRONMENT"] = "development"
        self.assertTrue(is_hot_reload_enabled())

        # Use a temporary file to test hot-reload
        test_category = "system"
        test_name = "test_hot_reload"
        test_lang = Language.KO

        # Determine prompt path
        # In prompt_loader.py, _PROMPTS_ROOT is Path(__file__).parent.parent.parent.parent / "prompts"
        # Since we are in tests/unit/orchestrator/, we need to find the prompts root.
        # But let's mock _get_prompt_path or just use an existing one if possible.
        # Actually, creating a real file is better for verifying "hot-reload" of file system.

        from unknown_world.orchestrator.prompt_loader import _PROMPTS_ROOT

        test_dir = _PROMPTS_ROOT / test_category
        test_dir.mkdir(parents=True, exist_ok=True)
        test_file = test_dir / f"{test_name}.ko.md"

        try:
            # Initial content
            test_file.write_text("# Test\n\nContent 1", encoding="utf-8")

            p1 = load_prompt(test_category, test_name, test_lang)
            self.assertIn("Content 1", p1)

            # Modify file
            test_file.write_text("# Test\n\nContent 2", encoding="utf-8")

            # Load again - should be updated in dev mode
            p2 = load_prompt(test_category, test_name, test_lang)
            self.assertIn("Content 2", p2)
            self.assertNotEqual(p1, p2)

        finally:
            if test_file.exists():
                test_file.unlink()

    def test_caching_production(self) -> None:
        """Verify caching works in production mode (no hot-reload)."""
        os.environ["ENVIRONMENT"] = "production"
        self.assertFalse(is_hot_reload_enabled())

        test_category = "system"
        test_name = "test_caching"
        test_lang = Language.KO

        from unknown_world.orchestrator.prompt_loader import _PROMPTS_ROOT

        test_dir = _PROMPTS_ROOT / test_category
        test_dir.mkdir(parents=True, exist_ok=True)
        test_file = test_dir / f"{test_name}.ko.md"

        try:
            # Initial content
            test_file.write_text("# Test\n\nInitial", encoding="utf-8")

            p1 = load_prompt(test_category, test_name, test_lang)
            self.assertIn("Initial", p1)

            # Modify file
            test_file.write_text("# Test\n\nModified", encoding="utf-8")

            # Load again - should STILL be Initial because of caching
            p2 = load_prompt(test_category, test_name, test_lang)
            self.assertEqual(p1, p2)
            self.assertIn("Initial", p2)

            # After clearing cache, it should be updated
            clear_prompt_cache()
            p3 = load_prompt(test_category, test_name, test_lang)
            self.assertIn("Modified", p3)

        finally:
            if test_file.exists():
                test_file.unlink()

    def test_fallback_language(self) -> None:
        """Verify fallback to other language if requested file is missing."""
        # Create ONLY English version
        test_category = "system"
        test_name = "test_fallback"

        from unknown_world.orchestrator.prompt_loader import _PROMPTS_ROOT

        test_dir = _PROMPTS_ROOT / test_category
        test_dir.mkdir(parents=True, exist_ok=True)
        en_file = test_dir / f"{test_name}.en.md"
        ko_file = test_dir / f"{test_name}.ko.md"

        try:
            en_file.write_text("# English Content", encoding="utf-8")
            if ko_file.exists():
                ko_file.unlink()

            # Request KO, should get EN
            prompt = load_prompt(test_category, test_name, Language.KO)
            self.assertIn("English Content", prompt)

        finally:
            if en_file.exists():
                en_file.unlink()


class TestXmlParsing(unittest.TestCase):
    """U-046: XML 태그 파싱 테스트."""

    def test_parse_xml_meta_valid(self) -> None:
        """Valid XML meta tags should be parsed correctly."""
        text = """<prompt_meta>
  <prompt_id>test_prompt</prompt_id>
  <language>ko-KR</language>
  <version>0.2.0</version>
  <last_updated>2026-01-28</last_updated>
  <policy_preset>default</policy_preset>
</prompt_meta>

<prompt_body>
## 목적
테스트 프롬프트입니다.

## 내용
본문 내용이 여기에 들어갑니다.
</prompt_body>
"""
        result = _parse_xml_meta(text)
        self.assertIsNotNone(result)
        metadata, content = result  # type: ignore

        # 메타데이터 검증
        self.assertEqual(metadata["prompt_id"], "test_prompt")
        self.assertEqual(metadata["language"], "ko-KR")
        self.assertEqual(metadata["version"], "0.2.0")
        self.assertEqual(metadata["last_updated"], "2026-01-28")
        self.assertEqual(metadata["policy_preset"], "default")

        # 본문 검증 (메타 블록 제외)
        self.assertIn("## 목적", content)
        self.assertIn("테스트 프롬프트입니다.", content)
        self.assertNotIn("<prompt_meta>", content)
        self.assertNotIn("<prompt_body>", content)

    def test_parse_xml_meta_no_body_tag(self) -> None:
        """XML meta without body tag should use remaining text as content."""
        text = """<prompt_meta>
  <prompt_id>test</prompt_id>
  <version>0.1.0</version>
</prompt_meta>

## Content Section
This is the content without body tag.
"""
        result = _parse_xml_meta(text)
        self.assertIsNotNone(result)
        metadata, content = result  # type: ignore

        self.assertEqual(metadata["prompt_id"], "test")
        self.assertIn("## Content Section", content)

    def test_parse_xml_meta_returns_none_for_legacy(self) -> None:
        """Legacy format should return None from _parse_xml_meta."""
        text = """# [Prompt] Test

- prompt_id: legacy_test
- version: 0.1.0

## Content
Legacy content here.
"""
        result = _parse_xml_meta(text)
        self.assertIsNone(result)

    def test_parse_legacy_frontmatter(self) -> None:
        """Legacy frontmatter should be parsed correctly."""
        text = """# [Prompt] Test

- prompt_id: legacy_test
- language: en-US
- version: 0.1.0

## Content
Legacy content here.
"""
        metadata, content = _parse_legacy_frontmatter(text)

        self.assertEqual(metadata["prompt_id"], "legacy_test")
        self.assertEqual(metadata["language"], "en-US")
        self.assertEqual(metadata["version"], "0.1.0")
        self.assertIn("## Content", content)
        self.assertIn("Legacy content here.", content)

    def test_parse_frontmatter_prefers_xml(self) -> None:
        """_parse_frontmatter should prefer XML format when available."""
        xml_text = """<prompt_meta>
  <prompt_id>xml_test</prompt_id>
  <version>0.2.0</version>
</prompt_meta>

<prompt_body>
## XML Content
This is XML format.
</prompt_body>
"""
        metadata, content = _parse_frontmatter(xml_text)

        self.assertEqual(metadata["prompt_id"], "xml_test")
        self.assertEqual(metadata["version"], "0.2.0")
        self.assertIn("## XML Content", content)

    def test_parse_frontmatter_fallback_to_legacy(self) -> None:
        """_parse_frontmatter should fallback to legacy when XML is missing."""
        legacy_text = """# [Prompt] Test

- prompt_id: fallback_test
- version: 0.1.0

## Content
Fallback content.
"""
        metadata, content = _parse_frontmatter(legacy_text)

        self.assertEqual(metadata["prompt_id"], "fallback_test")
        self.assertIn("## Content", content)

    def test_load_prompt_with_xml_metadata(self) -> None:
        """Integration test: load_prompt_with_metadata with XML format."""
        # Load actual prompt file (migrated to XML format)
        data = load_prompt_with_metadata("system", "game_master", Language.KO)

        self.assertIsNotNone(data.content)
        self.assertIsInstance(data.metadata, dict)

        # Check metadata fields
        self.assertEqual(data.metadata.get("prompt_id"), "game_master_system")
        self.assertEqual(data.metadata.get("language"), "ko-KR")
        self.assertIn("version", data.metadata)

        # Content should not contain meta tags
        self.assertNotIn("<prompt_meta>", data.content)
        self.assertNotIn("<prompt_body>", data.content)
        self.assertIn("## 목적", data.content)

    def test_load_prompt_with_xml_metadata_en(self) -> None:
        """Integration test: English XML format."""
        data = load_prompt_with_metadata("system", "game_master", Language.EN)

        self.assertEqual(data.metadata.get("prompt_id"), "game_master_system")
        self.assertEqual(data.metadata.get("language"), "en-US")
        self.assertIn("## Purpose", data.content)


if __name__ == "__main__":
    unittest.main()
</file>

<file path="backend/tests/unit/test_u043_language_gate.py">
"""U-043: 언어 혼합 검증 및 Repair 루프 단위 테스트."""

from unittest.mock import AsyncMock, patch

import pytest

from unknown_world.models.turn import (
    ActionCard,
    ActionDeck,
    AgentConsole,
    ClientInfo,
    CurrencyAmount,
    EconomyOutput,
    EconomySnapshot,
    Language,
    RenderOutput,
    SafetyOutput,
    TurnInput,
    TurnOutput,
    UIOutput,
    ValidationBadge,
    WorldDelta,
)
from unknown_world.orchestrator.generate_turn_output import GenerationResult, GenerationStatus
from unknown_world.orchestrator.repair_loop import run_repair_loop
from unknown_world.validation.business_rules import BusinessRuleError, validate_business_rules
from unknown_world.validation.language_gate import (
    measure_language_ratio,
    validate_language_consistency,
)


@pytest.fixture
def sample_turn_input() -> TurnInput:
    return TurnInput(
        language=Language.KO,
        text="테스트 입력",
        client=ClientInfo(viewport_w=1920, viewport_h=1080),
        economy_snapshot=EconomySnapshot(signal=100, memory_shard=5),
    )


@pytest.fixture
def base_turn_output(sample_turn_input: TurnInput) -> TurnOutput:
    return TurnOutput(
        language=Language.KO,
        narrative="정상적인 한국어 내러티브입니다.",
        ui=UIOutput(
            action_deck=ActionDeck(
                cards=[
                    ActionCard(
                        id="test",
                        label="테스트 카드",
                        cost=CurrencyAmount(signal=10, memory_shard=0),
                    )
                ]
            ),
            objects=[],
        ),
        world=WorldDelta(),
        render=RenderOutput(image_job=None),
        economy=EconomyOutput(
            cost=CurrencyAmount(signal=10, memory_shard=0),
            balance_after=CurrencyAmount(signal=90, memory_shard=5),
        ),
        safety=SafetyOutput(blocked=False),
        agent_console=AgentConsole(repair_count=0),
    )


def test_measure_language_ratio_ko():
    """한국어 텍스트의 언어 비율 측정 테스트."""
    text = "안녕하세요. 이것은 테스트입니다."
    ratio = measure_language_ratio(text)
    assert ratio.hangul_ratio > 0.8
    assert ratio.latin_ratio < 0.2


def test_measure_language_ratio_en():
    """영어 텍스트의 언어 비율 측정 테스트."""
    text = "Hello. This is a test."
    ratio = measure_language_ratio(text)
    assert ratio.latin_ratio > 0.8
    assert ratio.hangul_ratio == 0.0


def test_measure_language_ratio_mixed():
    """혼합된 텍스트의 언어 비율 측정 테스트."""
    text = "안녕하세요. This is a mixed text."
    ratio = measure_language_ratio(text)
    assert ratio.hangul_count > 0
    assert ratio.latin_count > 0


def test_measure_language_ratio_whitelist():
    """화이트리스트 단어가 비율 측정에서 제외되는지 테스트."""
    # "Signal"은 화이트리스트에 있으므로 라틴 카운트에서 제외되어야 함
    text = "Signal이 감지되었습니다."
    ratio = measure_language_ratio(text)
    # "이 감지되었습니다" (한글 7자 + 공백 1자) -> 한글 7
    # "signal" 제거됨. "i" 남음?
    # re.sub(rf"(?<![a-zA-Z]){re.escape(term)}(?![a-zA-Z])", "", ...)
    # "signal" -> ""
    # "이 감지되었습니다." 만 남음
    assert ratio.latin_count == 0
    assert ratio.hangul_count > 0


def test_validate_language_consistency_mixed_ko(base_turn_output):
    """한국어 요청에 영어가 섞인 경우 검증 테스트."""
    # 1. narrative
    mixed_output = base_turn_output.model_copy(deep=True)
    mixed_output.narrative = "이것은 한국어인데 Suddenly English appeared."
    result = validate_language_consistency(mixed_output, Language.KO)
    assert result.is_valid is False
    assert any(v["field"] == "narrative" for v in result.violations)

    # 2. action_deck.cards[0].label
    mixed_output = base_turn_output.model_copy(deep=True)
    mixed_output.ui.action_deck.cards[0].label = "Mixed Label 영어"
    result = validate_language_consistency(mixed_output, Language.KO)
    assert result.is_valid is False
    assert any(v["field"] == "ui.action_deck.cards[0].label" for v in result.violations)

    # 3. safety.message
    mixed_output = base_turn_output.model_copy(deep=True)
    mixed_output.safety.message = "This is a blocked message in English."
    result = validate_language_consistency(mixed_output, Language.KO)
    assert result.is_valid is False
    assert any(v["field"] == "safety.message" for v in result.violations)


def test_validate_language_consistency_en_with_ko(base_turn_output):
    """영어 요청에 한국어가 섞인 경우 검증 테스트."""
    en_input_lang = Language.EN
    en_output = base_turn_output.model_copy(deep=True)
    en_output.language = Language.EN
    en_output.narrative = "This is English but 한국어가 섞임."

    result = validate_language_consistency(en_output, en_input_lang)
    assert result.is_valid is False
    assert any(v["field"] == "narrative" for v in result.violations)


def test_build_language_error_summary_ko(base_turn_output):
    """한국어 에러 요약 생성 테스트."""
    from unknown_world.validation.language_gate import build_language_error_summary

    mixed_output = base_turn_output.model_copy(deep=True)
    mixed_output.narrative = "Mixed English."
    result = validate_language_consistency(mixed_output, Language.KO)

    summary = build_language_error_summary(result)
    assert "언어 혼합이 감지되었습니다" in summary
    assert "narrative" in summary
    assert "한국어(ko-KR)로 다시 작성하세요" in summary


def test_validate_business_rules_language_content_mixed(sample_turn_input, base_turn_output):
    """비즈니스 룰 검증에서 언어 혼합 감지 테스트."""
    mixed_output = base_turn_output.model_copy(deep=True)
    mixed_output.narrative = "한국어와 English가 섞여 있습니다. This should fail."

    result = validate_business_rules(sample_turn_input, mixed_output)
    assert result.is_valid is False
    assert any(err["type"] == BusinessRuleError.LANGUAGE_CONTENT_MIXED for err in result.errors)


@pytest.mark.asyncio
async def test_repair_loop_fixes_language_mixing(sample_turn_input, base_turn_output):
    """언어 혼합 시 Repair 루프가 작동하여 수정되는지 테스트."""
    mixed_output = base_turn_output.model_copy(deep=True)
    mixed_output.narrative = "혼합된 언어 English Mixed."

    valid_output = base_turn_output.model_copy(deep=True)
    valid_output.narrative = "수정된 한국어 내러티브"

    with patch("unknown_world.orchestrator.repair_loop.get_turn_output_generator") as mock_get_gen:
        mock_gen = mock_get_gen.return_value
        # 첫 번째는 혼합 출력, 두 번째는 정상 출력 반환
        mock_gen.generate = AsyncMock(
            side_effect=[
                GenerationResult(status=GenerationStatus.SUCCESS, output=mixed_output),
                GenerationResult(status=GenerationStatus.SUCCESS, output=valid_output),
            ]
        )

        result = await run_repair_loop(sample_turn_input)

        assert result.repair_attempts == 1
        assert result.output.narrative == "수정된 한국어 내러티브"
        assert ValidationBadge.CONSISTENCY_OK in result.badges
        assert ValidationBadge.CONSISTENCY_FAIL not in result.badges  # 최종 배지는 OK여야 함
</file>

<file path="frontend/coverage/base.css">
body, html {
  margin:0; padding: 0;
  height: 100%;
}
body {
    font-family: Helvetica Neue, Helvetica, Arial;
    font-size: 14px;
    color:#333;
}
.small { font-size: 12px; }
*, *:after, *:before {
  -webkit-box-sizing:border-box;
     -moz-box-sizing:border-box;
          box-sizing:border-box;
  }
h1 { font-size: 20px; margin: 0;}
h2 { font-size: 14px; }
pre {
    font: 12px/1.4 Consolas, "Liberation Mono", Menlo, Courier, monospace;
    margin: 0;
    padding: 0;
    -moz-tab-size: 2;
    -o-tab-size:  2;
    tab-size: 2;
}
a { color:#0074D9; text-decoration:none; }
a:hover { text-decoration:underline; }
.strong { font-weight: bold; }
.space-top1 { padding: 10px 0 0 0; }
.pad2y { padding: 20px 0; }
.pad1y { padding: 10px 0; }
.pad2x { padding: 0 20px; }
.pad2 { padding: 20px; }
.pad1 { padding: 10px; }
.space-left2 { padding-left:55px; }
.space-right2 { padding-right:20px; }
.center { text-align:center; }
.clearfix { display:block; }
.clearfix:after {
  content:'';
  display:block;
  height:0;
  clear:both;
  visibility:hidden;
  }
.fl { float: left; }
@media only screen and (max-width:640px) {
  .col3 { width:100%; max-width:100%; }
  .hide-mobile { display:none!important; }
}

.quiet {
  color: #7f7f7f;
  color: rgba(0,0,0,0.5);
}
.quiet a { opacity: 0.7; }

.fraction {
  font-family: Consolas, 'Liberation Mono', Menlo, Courier, monospace;
  font-size: 10px;
  color: #555;
  background: #E8E8E8;
  padding: 4px 5px;
  border-radius: 3px;
  vertical-align: middle;
}

div.path a:link, div.path a:visited { color: #333; }
table.coverage {
  border-collapse: collapse;
  margin: 10px 0 0 0;
  padding: 0;
}

table.coverage td {
  margin: 0;
  padding: 0;
  vertical-align: top;
}
table.coverage td.line-count {
    text-align: right;
    padding: 0 5px 0 20px;
}
table.coverage td.line-coverage {
    text-align: right;
    padding-right: 10px;
    min-width:20px;
}

table.coverage td span.cline-any {
    display: inline-block;
    padding: 0 5px;
    width: 100%;
}
.missing-if-branch {
    display: inline-block;
    margin-right: 5px;
    border-radius: 3px;
    position: relative;
    padding: 0 4px;
    background: #333;
    color: yellow;
}

.skip-if-branch {
    display: none;
    margin-right: 10px;
    position: relative;
    padding: 0 4px;
    background: #ccc;
    color: white;
}
.missing-if-branch .typ, .skip-if-branch .typ {
    color: inherit !important;
}
.coverage-summary {
  border-collapse: collapse;
  width: 100%;
}
.coverage-summary tr { border-bottom: 1px solid #bbb; }
.keyline-all { border: 1px solid #ddd; }
.coverage-summary td, .coverage-summary th { padding: 10px; }
.coverage-summary tbody { border: 1px solid #bbb; }
.coverage-summary td { border-right: 1px solid #bbb; }
.coverage-summary td:last-child { border-right: none; }
.coverage-summary th {
  text-align: left;
  font-weight: normal;
  white-space: nowrap;
}
.coverage-summary th.file { border-right: none !important; }
.coverage-summary th.pct { }
.coverage-summary th.pic,
.coverage-summary th.abs,
.coverage-summary td.pct,
.coverage-summary td.abs { text-align: right; }
.coverage-summary td.file { white-space: nowrap;  }
.coverage-summary td.pic { min-width: 120px !important;  }
.coverage-summary tfoot td { }

.coverage-summary .sorter {
    height: 10px;
    width: 7px;
    display: inline-block;
    margin-left: 0.5em;
    background: url(sort-arrow-sprite.png) no-repeat scroll 0 0 transparent;
}
.coverage-summary .sorted .sorter {
    background-position: 0 -20px;
}
.coverage-summary .sorted-desc .sorter {
    background-position: 0 -10px;
}
.status-line {  height: 10px; }
/* yellow */
.cbranch-no { background: yellow !important; color: #111; }
/* dark red */
.red.solid, .status-line.low, .low .cover-fill { background:#C21F39 }
.low .chart { border:1px solid #C21F39 }
.highlighted,
.highlighted .cstat-no, .highlighted .fstat-no, .highlighted .cbranch-no{
  background: #C21F39 !important;
}
/* medium red */
.cstat-no, .fstat-no, .cbranch-no, .cbranch-no { background:#F6C6CE }
/* light red */
.low, .cline-no { background:#FCE1E5 }
/* light green */
.high, .cline-yes { background:rgb(230,245,208) }
/* medium green */
.cstat-yes { background:rgb(161,215,106) }
/* dark green */
.status-line.high, .high .cover-fill { background:rgb(77,146,33) }
.high .chart { border:1px solid rgb(77,146,33) }
/* dark yellow (gold) */
.status-line.medium, .medium .cover-fill { background: #f9cd0b; }
.medium .chart { border:1px solid #f9cd0b; }
/* light yellow */
.medium { background: #fff4c2; }

.cstat-skip { background: #ddd; color: #111; }
.fstat-skip { background: #ddd; color: #111 !important; }
.cbranch-skip { background: #ddd !important; color: #111; }

span.cline-neutral { background: #eaeaea; }

.coverage-summary td.empty {
    opacity: .5;
    padding-top: 4px;
    padding-bottom: 4px;
    line-height: 1;
    color: #888;
}

.cover-fill, .cover-empty {
  display:inline-block;
  height: 12px;
}
.chart {
  line-height: 0;
}
.cover-empty {
    background: white;
}
.cover-full {
    border-right: none !important;
}
pre.prettyprint {
    border: none !important;
    padding: 0 !important;
    margin: 0 !important;
}
.com { color: #999 !important; }
.ignore-none { color: #999; font-weight: normal; }

.wrapper {
  min-height: 100%;
  height: auto !important;
  height: 100%;
  margin: 0 auto -48px;
}
.footer, .push {
  height: 48px;
}
</file>

<file path="frontend/coverage/coverage-final.json">
{"D:\\Dev\\unknown-world\\frontend\\src\\schemas\\turn.ts": {"path":"D:\\Dev\\unknown-world\\frontend\\src\\schemas\\turn.ts","statementMap":{"0":{"start":{"line":30,"column":30},"end":{"line":30,"column":null}},"1":{"start":{"line":41,"column":30},"end":{"line":41,"column":null}},"2":{"start":{"line":47,"column":27},"end":{"line":47,"column":null}},"3":{"start":{"line":54,"column":32},"end":{"line":62,"column":null}},"4":{"start":{"line":69,"column":37},"end":{"line":78,"column":null}},"5":{"start":{"line":85,"column":32},"end":{"line":85,"column":null}},"6":{"start":{"line":91,"column":31},"end":{"line":91,"column":null}},"7":{"start":{"line":102,"column":32},"end":{"line":107,"column":null}},"8":{"start":{"line":115,"column":27},"end":{"line":122,"column":null}},"9":{"start":{"line":129,"column":36},"end":{"line":138,"column":null}},"10":{"start":{"line":149,"column":32},"end":{"line":156,"column":null}},"11":{"start":{"line":162,"column":32},"end":{"line":176,"column":null}},"12":{"start":{"line":183,"column":37},"end":{"line":192,"column":null}},"13":{"start":{"line":199,"column":31},"end":{"line":209,"column":null}},"14":{"start":{"line":220,"column":32},"end":{"line":229,"column":null}},"15":{"start":{"line":236,"column":33},"end":{"line":247,"column":null}},"16":{"start":{"line":254,"column":32},"end":{"line":262,"column":null}},"17":{"start":{"line":270,"column":30},"end":{"line":278,"column":null}},"18":{"start":{"line":289,"column":31},"end":{"line":295,"column":null}},"19":{"start":{"line":302,"column":31},"end":{"line":312,"column":null}},"20":{"start":{"line":319,"column":27},"end":{"line":325,"column":null}},"21":{"start":{"line":332,"column":32},"end":{"line":359,"column":null}},"22":{"start":{"line":370,"column":30},"end":{"line":382,"column":null}},"23":{"start":{"line":389,"column":34},"end":{"line":395,"column":null}},"24":{"start":{"line":407,"column":35},"end":{"line":412,"column":null}},"25":{"start":{"line":424,"column":34},"end":{"line":436,"column":null}},"26":{"start":{"line":447,"column":34},"end":{"line":453,"column":null}},"27":{"start":{"line":469,"column":32},"end":{"line":502,"column":null}},"28":{"start":{"line":523,"column":4},"end":{"line":525,"column":null}},"29":{"start":{"line":528,"column":4},"end":{"line":530,"column":null}},"30":{"start":{"line":532,"column":2},"end":{"line":563,"column":null}},"31":{"start":{"line":590,"column":17},"end":{"line":590,"column":null}},"32":{"start":{"line":592,"column":2},"end":{"line":594,"column":null}},"33":{"start":{"line":593,"column":4},"end":{"line":593,"column":null}},"34":{"start":{"line":596,"column":2},"end":{"line":600,"column":null}},"35":{"start":{"line":611,"column":2},"end":{"line":611,"column":null}},"36":{"start":{"line":625,"column":2},"end":{"line":625,"column":null}}},"fnMap":{"0":{"name":"createFallbackTurnOutput","decl":{"start":{"line":517,"column":16},"end":{"line":517,"column":null}},"loc":{"start":{"line":521,"column":14},"end":{"line":564,"column":null}},"line":521},"1":{"name":"safeParseTurnOutput","decl":{"start":{"line":585,"column":16},"end":{"line":585,"column":null}},"loc":{"start":{"line":589,"column":25},"end":{"line":601,"column":null}},"line":589},"2":{"name":"parseTurnInput","decl":{"start":{"line":610,"column":16},"end":{"line":610,"column":31}},"loc":{"start":{"line":610,"column":57},"end":{"line":612,"column":null}},"line":610},"3":{"name":"safeParseTurnInput","decl":{"start":{"line":624,"column":16},"end":{"line":624,"column":35}},"loc":{"start":{"line":624,"column":76},"end":{"line":626,"column":null}},"line":624}},"branchMap":{"0":{"loc":{"start":{"line":519,"column":2},"end":{"line":519,"column":null}},"type":"default-arg","locations":[{"start":{"line":519,"column":24},"end":{"line":519,"column":null}}],"line":519},"1":{"loc":{"start":{"line":523,"column":4},"end":{"line":525,"column":null}},"type":"cond-expr","locations":[{"start":{"line":524,"column":8},"end":{"line":524,"column":null}},{"start":{"line":525,"column":8},"end":{"line":525,"column":null}}],"line":523},"2":{"loc":{"start":{"line":528,"column":4},"end":{"line":530,"column":null}},"type":"cond-expr","locations":[{"start":{"line":529,"column":8},"end":{"line":529,"column":null}},{"start":{"line":530,"column":8},"end":{"line":530,"column":null}}],"line":528},"3":{"loc":{"start":{"line":534,"column":15},"end":{"line":534,"column":null}},"type":"binary-expr","locations":[{"start":{"line":534,"column":15},"end":{"line":534,"column":31}},{"start":{"line":534,"column":31},"end":{"line":534,"column":null}}],"line":534},"4":{"loc":{"start":{"line":587,"column":2},"end":{"line":587,"column":null}},"type":"default-arg","locations":[{"start":{"line":587,"column":23},"end":{"line":587,"column":null}}],"line":587},"5":{"loc":{"start":{"line":588,"column":2},"end":{"line":588,"column":null}},"type":"default-arg","locations":[{"start":{"line":588,"column":24},"end":{"line":588,"column":null}}],"line":588},"6":{"loc":{"start":{"line":592,"column":2},"end":{"line":594,"column":null}},"type":"if","locations":[{"start":{"line":592,"column":2},"end":{"line":594,"column":null}},{"start":{},"end":{}}],"line":592}},"s":{"0":1,"1":1,"2":1,"3":1,"4":1,"5":1,"6":1,"7":1,"8":1,"9":1,"10":1,"11":1,"12":1,"13":1,"14":1,"15":1,"16":1,"17":1,"18":1,"19":1,"20":1,"21":1,"22":1,"23":1,"24":1,"25":1,"26":1,"27":1,"28":1,"29":1,"30":1,"31":2,"32":2,"33":1,"34":1,"35":2,"36":2},"f":{"0":1,"1":2,"2":2,"3":2},"b":{"0":[1],"1":[1,0],"2":[1,0],"3":[1,1],"4":[2],"5":[2],"6":[1,1]},"meta":{"lastBranch":7,"lastFunction":4,"lastStatement":37,"seen":{"s:30:30:30:Infinity":0,"s:41:30:41:Infinity":1,"s:47:27:47:Infinity":2,"s:54:32:62:Infinity":3,"s:69:37:78:Infinity":4,"s:85:32:85:Infinity":5,"s:91:31:91:Infinity":6,"s:102:32:107:Infinity":7,"s:115:27:122:Infinity":8,"s:129:36:138:Infinity":9,"s:149:32:156:Infinity":10,"s:162:32:176:Infinity":11,"s:183:37:192:Infinity":12,"s:199:31:209:Infinity":13,"s:220:32:229:Infinity":14,"s:236:33:247:Infinity":15,"s:254:32:262:Infinity":16,"s:270:30:278:Infinity":17,"s:289:31:295:Infinity":18,"s:302:31:312:Infinity":19,"s:319:27:325:Infinity":20,"s:332:32:359:Infinity":21,"s:370:30:382:Infinity":22,"s:389:34:395:Infinity":23,"s:407:35:412:Infinity":24,"s:424:34:436:Infinity":25,"s:447:34:453:Infinity":26,"s:469:32:502:Infinity":27,"f:517:16:517:Infinity":0,"b:519:24:519:Infinity":0,"s:523:4:525:Infinity":28,"b:524:8:524:Infinity:525:8:525:Infinity":1,"s:528:4:530:Infinity":29,"b:529:8:529:Infinity:530:8:530:Infinity":2,"s:532:2:563:Infinity":30,"b:534:15:534:31:534:31:534:Infinity":3,"f:585:16:585:Infinity":1,"b:587:23:587:Infinity":4,"b:588:24:588:Infinity":5,"s:590:17:590:Infinity":31,"b:592:2:594:Infinity:undefined:undefined:undefined:undefined":6,"s:592:2:594:Infinity":32,"s:593:4:593:Infinity":33,"s:596:2:600:Infinity":34,"f:610:16:610:31":2,"s:611:2:611:Infinity":35,"f:624:16:624:35":3,"s:625:2:625:Infinity":36}}}
}
</file>

<file path="frontend/coverage/index.html">
<!doctype html>
<html lang="en">

<head>
    <title>Code coverage report for All files</title>
    <meta charset="utf-8" />
    <link rel="stylesheet" href="prettify.css" />
    <link rel="stylesheet" href="base.css" />
    <link rel="shortcut icon" type="image/x-icon" href="favicon.png" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <style type='text/css'>
        .coverage-summary .sorter {
            background-image: url(sort-arrow-sprite.png);
        }
    </style>
</head>
    
<body>
<div class='wrapper'>
    <div class='pad1'>
        <h1>All files</h1>
        <div class='clearfix'>
            
            <div class='fl pad1y space-right2'>
                <span class="strong">100% </span>
                <span class="quiet">Statements</span>
                <span class='fraction'>37/37</span>
            </div>
        
            
            <div class='fl pad1y space-right2'>
                <span class="strong">81.81% </span>
                <span class="quiet">Branches</span>
                <span class='fraction'>9/11</span>
            </div>
        
            
            <div class='fl pad1y space-right2'>
                <span class="strong">100% </span>
                <span class="quiet">Functions</span>
                <span class='fraction'>4/4</span>
            </div>
        
            
            <div class='fl pad1y space-right2'>
                <span class="strong">100% </span>
                <span class="quiet">Lines</span>
                <span class='fraction'>37/37</span>
            </div>
        
            
        </div>
        <p class="quiet">
            Press <em>n</em> or <em>j</em> to go to the next uncovered block, <em>b</em>, <em>p</em> or <em>k</em> for the previous block.
        </p>
        <template id="filterTemplate">
            <div class="quiet">
                Filter:
                <input type="search" id="fileSearch">
            </div>
        </template>
    </div>
    <div class='status-line high'></div>
    <div class="pad1">
<table class="coverage-summary">
<thead>
<tr>
   <th data-col="file" data-fmt="html" data-html="true" class="file">File</th>
   <th data-col="pic" data-type="number" data-fmt="html" data-html="true" class="pic"></th>
   <th data-col="statements" data-type="number" data-fmt="pct" class="pct">Statements</th>
   <th data-col="statements_raw" data-type="number" data-fmt="html" class="abs"></th>
   <th data-col="branches" data-type="number" data-fmt="pct" class="pct">Branches</th>
   <th data-col="branches_raw" data-type="number" data-fmt="html" class="abs"></th>
   <th data-col="functions" data-type="number" data-fmt="pct" class="pct">Functions</th>
   <th data-col="functions_raw" data-type="number" data-fmt="html" class="abs"></th>
   <th data-col="lines" data-type="number" data-fmt="pct" class="pct">Lines</th>
   <th data-col="lines_raw" data-type="number" data-fmt="html" class="abs"></th>
</tr>
</thead>
<tbody><tr>
	<td class="file high" data-value="turn.ts"><a href="turn.ts.html">turn.ts</a></td>
	<td data-value="100" class="pic high">
	<div class="chart"><div class="cover-fill cover-full" style="width: 100%"></div><div class="cover-empty" style="width: 0%"></div></div>
	</td>
	<td data-value="100" class="pct high">100%</td>
	<td data-value="37" class="abs high">37/37</td>
	<td data-value="81.81" class="pct high">81.81%</td>
	<td data-value="11" class="abs high">9/11</td>
	<td data-value="100" class="pct high">100%</td>
	<td data-value="4" class="abs high">4/4</td>
	<td data-value="100" class="pct high">100%</td>
	<td data-value="37" class="abs high">37/37</td>
	</tr>

</tbody>
</table>
</div>
                <div class='push'></div><!-- for sticky footer -->
            </div><!-- /wrapper -->
            <div class='footer quiet pad2 space-top1 center small'>
                Code coverage generated by
                <a href="https://istanbul.js.org/" target="_blank" rel="noopener noreferrer">istanbul</a>
                at 2026-01-04T13:05:55.602Z
            </div>
        <script src="prettify.js"></script>
        <script>
            window.onload = function () {
                prettyPrint();
            };
        </script>
        <script src="sorter.js"></script>
        <script src="block-navigation.js"></script>
    </body>
</html>
</file>

<file path="frontend/coverage/prettify.css">
.pln{color:#000}@media screen{.str{color:#080}.kwd{color:#008}.com{color:#800}.typ{color:#606}.lit{color:#066}.pun,.opn,.clo{color:#660}.tag{color:#008}.atn{color:#606}.atv{color:#080}.dec,.var{color:#606}.fun{color:red}}@media print,projection{.str{color:#060}.kwd{color:#006;font-weight:bold}.com{color:#600;font-style:italic}.typ{color:#404;font-weight:bold}.lit{color:#044}.pun,.opn,.clo{color:#440}.tag{color:#006;font-weight:bold}.atn{color:#404}.atv{color:#060}}pre.prettyprint{padding:2px;border:1px solid #888}ol.linenums{margin-top:0;margin-bottom:0}li.L0,li.L1,li.L2,li.L3,li.L5,li.L6,li.L7,li.L8{list-style-type:none}li.L1,li.L3,li.L5,li.L7,li.L9{background:#eee}
</file>

<file path="frontend/coverage/turn.ts.html">
<!doctype html>
<html lang="en">

<head>
    <title>Code coverage report for turn.ts</title>
    <meta charset="utf-8" />
    <link rel="stylesheet" href="prettify.css" />
    <link rel="stylesheet" href="base.css" />
    <link rel="shortcut icon" type="image/x-icon" href="favicon.png" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <style type='text/css'>
        .coverage-summary .sorter {
            background-image: url(sort-arrow-sprite.png);
        }
    </style>
</head>
    
<body>
<div class='wrapper'>
    <div class='pad1'>
        <h1><a href="index.html">All files</a> turn.ts</h1>
        <div class='clearfix'>
            
            <div class='fl pad1y space-right2'>
                <span class="strong">100% </span>
                <span class="quiet">Statements</span>
                <span class='fraction'>37/37</span>
            </div>
        
            
            <div class='fl pad1y space-right2'>
                <span class="strong">81.81% </span>
                <span class="quiet">Branches</span>
                <span class='fraction'>9/11</span>
            </div>
        
            
            <div class='fl pad1y space-right2'>
                <span class="strong">100% </span>
                <span class="quiet">Functions</span>
                <span class='fraction'>4/4</span>
            </div>
        
            
            <div class='fl pad1y space-right2'>
                <span class="strong">100% </span>
                <span class="quiet">Lines</span>
                <span class='fraction'>37/37</span>
            </div>
        
            
        </div>
        <p class="quiet">
            Press <em>n</em> or <em>j</em> to go to the next uncovered block, <em>b</em>, <em>p</em> or <em>k</em> for the previous block.
        </p>
        <template id="filterTemplate">
            <div class="quiet">
                Filter:
                <input type="search" id="fileSearch">
            </div>
        </template>
    </div>
    <div class='status-line high'></div>
    <pre><table class="coverage">
<tr><td class="line-count quiet"><a name='L1'></a><a href='#L1'>1</a>
<a name='L2'></a><a href='#L2'>2</a>
<a name='L3'></a><a href='#L3'>3</a>
<a name='L4'></a><a href='#L4'>4</a>
<a name='L5'></a><a href='#L5'>5</a>
<a name='L6'></a><a href='#L6'>6</a>
<a name='L7'></a><a href='#L7'>7</a>
<a name='L8'></a><a href='#L8'>8</a>
<a name='L9'></a><a href='#L9'>9</a>
<a name='L10'></a><a href='#L10'>10</a>
<a name='L11'></a><a href='#L11'>11</a>
<a name='L12'></a><a href='#L12'>12</a>
<a name='L13'></a><a href='#L13'>13</a>
<a name='L14'></a><a href='#L14'>14</a>
<a name='L15'></a><a href='#L15'>15</a>
<a name='L16'></a><a href='#L16'>16</a>
<a name='L17'></a><a href='#L17'>17</a>
<a name='L18'></a><a href='#L18'>18</a>
<a name='L19'></a><a href='#L19'>19</a>
<a name='L20'></a><a href='#L20'>20</a>
<a name='L21'></a><a href='#L21'>21</a>
<a name='L22'></a><a href='#L22'>22</a>
<a name='L23'></a><a href='#L23'>23</a>
<a name='L24'></a><a href='#L24'>24</a>
<a name='L25'></a><a href='#L25'>25</a>
<a name='L26'></a><a href='#L26'>26</a>
<a name='L27'></a><a href='#L27'>27</a>
<a name='L28'></a><a href='#L28'>28</a>
<a name='L29'></a><a href='#L29'>29</a>
<a name='L30'></a><a href='#L30'>30</a>
<a name='L31'></a><a href='#L31'>31</a>
<a name='L32'></a><a href='#L32'>32</a>
<a name='L33'></a><a href='#L33'>33</a>
<a name='L34'></a><a href='#L34'>34</a>
<a name='L35'></a><a href='#L35'>35</a>
<a name='L36'></a><a href='#L36'>36</a>
<a name='L37'></a><a href='#L37'>37</a>
<a name='L38'></a><a href='#L38'>38</a>
<a name='L39'></a><a href='#L39'>39</a>
<a name='L40'></a><a href='#L40'>40</a>
<a name='L41'></a><a href='#L41'>41</a>
<a name='L42'></a><a href='#L42'>42</a>
<a name='L43'></a><a href='#L43'>43</a>
<a name='L44'></a><a href='#L44'>44</a>
<a name='L45'></a><a href='#L45'>45</a>
<a name='L46'></a><a href='#L46'>46</a>
<a name='L47'></a><a href='#L47'>47</a>
<a name='L48'></a><a href='#L48'>48</a>
<a name='L49'></a><a href='#L49'>49</a>
<a name='L50'></a><a href='#L50'>50</a>
<a name='L51'></a><a href='#L51'>51</a>
<a name='L52'></a><a href='#L52'>52</a>
<a name='L53'></a><a href='#L53'>53</a>
<a name='L54'></a><a href='#L54'>54</a>
<a name='L55'></a><a href='#L55'>55</a>
<a name='L56'></a><a href='#L56'>56</a>
<a name='L57'></a><a href='#L57'>57</a>
<a name='L58'></a><a href='#L58'>58</a>
<a name='L59'></a><a href='#L59'>59</a>
<a name='L60'></a><a href='#L60'>60</a>
<a name='L61'></a><a href='#L61'>61</a>
<a name='L62'></a><a href='#L62'>62</a>
<a name='L63'></a><a href='#L63'>63</a>
<a name='L64'></a><a href='#L64'>64</a>
<a name='L65'></a><a href='#L65'>65</a>
<a name='L66'></a><a href='#L66'>66</a>
<a name='L67'></a><a href='#L67'>67</a>
<a name='L68'></a><a href='#L68'>68</a>
<a name='L69'></a><a href='#L69'>69</a>
<a name='L70'></a><a href='#L70'>70</a>
<a name='L71'></a><a href='#L71'>71</a>
<a name='L72'></a><a href='#L72'>72</a>
<a name='L73'></a><a href='#L73'>73</a>
<a name='L74'></a><a href='#L74'>74</a>
<a name='L75'></a><a href='#L75'>75</a>
<a name='L76'></a><a href='#L76'>76</a>
<a name='L77'></a><a href='#L77'>77</a>
<a name='L78'></a><a href='#L78'>78</a>
<a name='L79'></a><a href='#L79'>79</a>
<a name='L80'></a><a href='#L80'>80</a>
<a name='L81'></a><a href='#L81'>81</a>
<a name='L82'></a><a href='#L82'>82</a>
<a name='L83'></a><a href='#L83'>83</a>
<a name='L84'></a><a href='#L84'>84</a>
<a name='L85'></a><a href='#L85'>85</a>
<a name='L86'></a><a href='#L86'>86</a>
<a name='L87'></a><a href='#L87'>87</a>
<a name='L88'></a><a href='#L88'>88</a>
<a name='L89'></a><a href='#L89'>89</a>
<a name='L90'></a><a href='#L90'>90</a>
<a name='L91'></a><a href='#L91'>91</a>
<a name='L92'></a><a href='#L92'>92</a>
<a name='L93'></a><a href='#L93'>93</a>
<a name='L94'></a><a href='#L94'>94</a>
<a name='L95'></a><a href='#L95'>95</a>
<a name='L96'></a><a href='#L96'>96</a>
<a name='L97'></a><a href='#L97'>97</a>
<a name='L98'></a><a href='#L98'>98</a>
<a name='L99'></a><a href='#L99'>99</a>
<a name='L100'></a><a href='#L100'>100</a>
<a name='L101'></a><a href='#L101'>101</a>
<a name='L102'></a><a href='#L102'>102</a>
<a name='L103'></a><a href='#L103'>103</a>
<a name='L104'></a><a href='#L104'>104</a>
<a name='L105'></a><a href='#L105'>105</a>
<a name='L106'></a><a href='#L106'>106</a>
<a name='L107'></a><a href='#L107'>107</a>
<a name='L108'></a><a href='#L108'>108</a>
<a name='L109'></a><a href='#L109'>109</a>
<a name='L110'></a><a href='#L110'>110</a>
<a name='L111'></a><a href='#L111'>111</a>
<a name='L112'></a><a href='#L112'>112</a>
<a name='L113'></a><a href='#L113'>113</a>
<a name='L114'></a><a href='#L114'>114</a>
<a name='L115'></a><a href='#L115'>115</a>
<a name='L116'></a><a href='#L116'>116</a>
<a name='L117'></a><a href='#L117'>117</a>
<a name='L118'></a><a href='#L118'>118</a>
<a name='L119'></a><a href='#L119'>119</a>
<a name='L120'></a><a href='#L120'>120</a>
<a name='L121'></a><a href='#L121'>121</a>
<a name='L122'></a><a href='#L122'>122</a>
<a name='L123'></a><a href='#L123'>123</a>
<a name='L124'></a><a href='#L124'>124</a>
<a name='L125'></a><a href='#L125'>125</a>
<a name='L126'></a><a href='#L126'>126</a>
<a name='L127'></a><a href='#L127'>127</a>
<a name='L128'></a><a href='#L128'>128</a>
<a name='L129'></a><a href='#L129'>129</a>
<a name='L130'></a><a href='#L130'>130</a>
<a name='L131'></a><a href='#L131'>131</a>
<a name='L132'></a><a href='#L132'>132</a>
<a name='L133'></a><a href='#L133'>133</a>
<a name='L134'></a><a href='#L134'>134</a>
<a name='L135'></a><a href='#L135'>135</a>
<a name='L136'></a><a href='#L136'>136</a>
<a name='L137'></a><a href='#L137'>137</a>
<a name='L138'></a><a href='#L138'>138</a>
<a name='L139'></a><a href='#L139'>139</a>
<a name='L140'></a><a href='#L140'>140</a>
<a name='L141'></a><a href='#L141'>141</a>
<a name='L142'></a><a href='#L142'>142</a>
<a name='L143'></a><a href='#L143'>143</a>
<a name='L144'></a><a href='#L144'>144</a>
<a name='L145'></a><a href='#L145'>145</a>
<a name='L146'></a><a href='#L146'>146</a>
<a name='L147'></a><a href='#L147'>147</a>
<a name='L148'></a><a href='#L148'>148</a>
<a name='L149'></a><a href='#L149'>149</a>
<a name='L150'></a><a href='#L150'>150</a>
<a name='L151'></a><a href='#L151'>151</a>
<a name='L152'></a><a href='#L152'>152</a>
<a name='L153'></a><a href='#L153'>153</a>
<a name='L154'></a><a href='#L154'>154</a>
<a name='L155'></a><a href='#L155'>155</a>
<a name='L156'></a><a href='#L156'>156</a>
<a name='L157'></a><a href='#L157'>157</a>
<a name='L158'></a><a href='#L158'>158</a>
<a name='L159'></a><a href='#L159'>159</a>
<a name='L160'></a><a href='#L160'>160</a>
<a name='L161'></a><a href='#L161'>161</a>
<a name='L162'></a><a href='#L162'>162</a>
<a name='L163'></a><a href='#L163'>163</a>
<a name='L164'></a><a href='#L164'>164</a>
<a name='L165'></a><a href='#L165'>165</a>
<a name='L166'></a><a href='#L166'>166</a>
<a name='L167'></a><a href='#L167'>167</a>
<a name='L168'></a><a href='#L168'>168</a>
<a name='L169'></a><a href='#L169'>169</a>
<a name='L170'></a><a href='#L170'>170</a>
<a name='L171'></a><a href='#L171'>171</a>
<a name='L172'></a><a href='#L172'>172</a>
<a name='L173'></a><a href='#L173'>173</a>
<a name='L174'></a><a href='#L174'>174</a>
<a name='L175'></a><a href='#L175'>175</a>
<a name='L176'></a><a href='#L176'>176</a>
<a name='L177'></a><a href='#L177'>177</a>
<a name='L178'></a><a href='#L178'>178</a>
<a name='L179'></a><a href='#L179'>179</a>
<a name='L180'></a><a href='#L180'>180</a>
<a name='L181'></a><a href='#L181'>181</a>
<a name='L182'></a><a href='#L182'>182</a>
<a name='L183'></a><a href='#L183'>183</a>
<a name='L184'></a><a href='#L184'>184</a>
<a name='L185'></a><a href='#L185'>185</a>
<a name='L186'></a><a href='#L186'>186</a>
<a name='L187'></a><a href='#L187'>187</a>
<a name='L188'></a><a href='#L188'>188</a>
<a name='L189'></a><a href='#L189'>189</a>
<a name='L190'></a><a href='#L190'>190</a>
<a name='L191'></a><a href='#L191'>191</a>
<a name='L192'></a><a href='#L192'>192</a>
<a name='L193'></a><a href='#L193'>193</a>
<a name='L194'></a><a href='#L194'>194</a>
<a name='L195'></a><a href='#L195'>195</a>
<a name='L196'></a><a href='#L196'>196</a>
<a name='L197'></a><a href='#L197'>197</a>
<a name='L198'></a><a href='#L198'>198</a>
<a name='L199'></a><a href='#L199'>199</a>
<a name='L200'></a><a href='#L200'>200</a>
<a name='L201'></a><a href='#L201'>201</a>
<a name='L202'></a><a href='#L202'>202</a>
<a name='L203'></a><a href='#L203'>203</a>
<a name='L204'></a><a href='#L204'>204</a>
<a name='L205'></a><a href='#L205'>205</a>
<a name='L206'></a><a href='#L206'>206</a>
<a name='L207'></a><a href='#L207'>207</a>
<a name='L208'></a><a href='#L208'>208</a>
<a name='L209'></a><a href='#L209'>209</a>
<a name='L210'></a><a href='#L210'>210</a>
<a name='L211'></a><a href='#L211'>211</a>
<a name='L212'></a><a href='#L212'>212</a>
<a name='L213'></a><a href='#L213'>213</a>
<a name='L214'></a><a href='#L214'>214</a>
<a name='L215'></a><a href='#L215'>215</a>
<a name='L216'></a><a href='#L216'>216</a>
<a name='L217'></a><a href='#L217'>217</a>
<a name='L218'></a><a href='#L218'>218</a>
<a name='L219'></a><a href='#L219'>219</a>
<a name='L220'></a><a href='#L220'>220</a>
<a name='L221'></a><a href='#L221'>221</a>
<a name='L222'></a><a href='#L222'>222</a>
<a name='L223'></a><a href='#L223'>223</a>
<a name='L224'></a><a href='#L224'>224</a>
<a name='L225'></a><a href='#L225'>225</a>
<a name='L226'></a><a href='#L226'>226</a>
<a name='L227'></a><a href='#L227'>227</a>
<a name='L228'></a><a href='#L228'>228</a>
<a name='L229'></a><a href='#L229'>229</a>
<a name='L230'></a><a href='#L230'>230</a>
<a name='L231'></a><a href='#L231'>231</a>
<a name='L232'></a><a href='#L232'>232</a>
<a name='L233'></a><a href='#L233'>233</a>
<a name='L234'></a><a href='#L234'>234</a>
<a name='L235'></a><a href='#L235'>235</a>
<a name='L236'></a><a href='#L236'>236</a>
<a name='L237'></a><a href='#L237'>237</a>
<a name='L238'></a><a href='#L238'>238</a>
<a name='L239'></a><a href='#L239'>239</a>
<a name='L240'></a><a href='#L240'>240</a>
<a name='L241'></a><a href='#L241'>241</a>
<a name='L242'></a><a href='#L242'>242</a>
<a name='L243'></a><a href='#L243'>243</a>
<a name='L244'></a><a href='#L244'>244</a>
<a name='L245'></a><a href='#L245'>245</a>
<a name='L246'></a><a href='#L246'>246</a>
<a name='L247'></a><a href='#L247'>247</a>
<a name='L248'></a><a href='#L248'>248</a>
<a name='L249'></a><a href='#L249'>249</a>
<a name='L250'></a><a href='#L250'>250</a>
<a name='L251'></a><a href='#L251'>251</a>
<a name='L252'></a><a href='#L252'>252</a>
<a name='L253'></a><a href='#L253'>253</a>
<a name='L254'></a><a href='#L254'>254</a>
<a name='L255'></a><a href='#L255'>255</a>
<a name='L256'></a><a href='#L256'>256</a>
<a name='L257'></a><a href='#L257'>257</a>
<a name='L258'></a><a href='#L258'>258</a>
<a name='L259'></a><a href='#L259'>259</a>
<a name='L260'></a><a href='#L260'>260</a>
<a name='L261'></a><a href='#L261'>261</a>
<a name='L262'></a><a href='#L262'>262</a>
<a name='L263'></a><a href='#L263'>263</a>
<a name='L264'></a><a href='#L264'>264</a>
<a name='L265'></a><a href='#L265'>265</a>
<a name='L266'></a><a href='#L266'>266</a>
<a name='L267'></a><a href='#L267'>267</a>
<a name='L268'></a><a href='#L268'>268</a>
<a name='L269'></a><a href='#L269'>269</a>
<a name='L270'></a><a href='#L270'>270</a>
<a name='L271'></a><a href='#L271'>271</a>
<a name='L272'></a><a href='#L272'>272</a>
<a name='L273'></a><a href='#L273'>273</a>
<a name='L274'></a><a href='#L274'>274</a>
<a name='L275'></a><a href='#L275'>275</a>
<a name='L276'></a><a href='#L276'>276</a>
<a name='L277'></a><a href='#L277'>277</a>
<a name='L278'></a><a href='#L278'>278</a>
<a name='L279'></a><a href='#L279'>279</a>
<a name='L280'></a><a href='#L280'>280</a>
<a name='L281'></a><a href='#L281'>281</a>
<a name='L282'></a><a href='#L282'>282</a>
<a name='L283'></a><a href='#L283'>283</a>
<a name='L284'></a><a href='#L284'>284</a>
<a name='L285'></a><a href='#L285'>285</a>
<a name='L286'></a><a href='#L286'>286</a>
<a name='L287'></a><a href='#L287'>287</a>
<a name='L288'></a><a href='#L288'>288</a>
<a name='L289'></a><a href='#L289'>289</a>
<a name='L290'></a><a href='#L290'>290</a>
<a name='L291'></a><a href='#L291'>291</a>
<a name='L292'></a><a href='#L292'>292</a>
<a name='L293'></a><a href='#L293'>293</a>
<a name='L294'></a><a href='#L294'>294</a>
<a name='L295'></a><a href='#L295'>295</a>
<a name='L296'></a><a href='#L296'>296</a>
<a name='L297'></a><a href='#L297'>297</a>
<a name='L298'></a><a href='#L298'>298</a>
<a name='L299'></a><a href='#L299'>299</a>
<a name='L300'></a><a href='#L300'>300</a>
<a name='L301'></a><a href='#L301'>301</a>
<a name='L302'></a><a href='#L302'>302</a>
<a name='L303'></a><a href='#L303'>303</a>
<a name='L304'></a><a href='#L304'>304</a>
<a name='L305'></a><a href='#L305'>305</a>
<a name='L306'></a><a href='#L306'>306</a>
<a name='L307'></a><a href='#L307'>307</a>
<a name='L308'></a><a href='#L308'>308</a>
<a name='L309'></a><a href='#L309'>309</a>
<a name='L310'></a><a href='#L310'>310</a>
<a name='L311'></a><a href='#L311'>311</a>
<a name='L312'></a><a href='#L312'>312</a>
<a name='L313'></a><a href='#L313'>313</a>
<a name='L314'></a><a href='#L314'>314</a>
<a name='L315'></a><a href='#L315'>315</a>
<a name='L316'></a><a href='#L316'>316</a>
<a name='L317'></a><a href='#L317'>317</a>
<a name='L318'></a><a href='#L318'>318</a>
<a name='L319'></a><a href='#L319'>319</a>
<a name='L320'></a><a href='#L320'>320</a>
<a name='L321'></a><a href='#L321'>321</a>
<a name='L322'></a><a href='#L322'>322</a>
<a name='L323'></a><a href='#L323'>323</a>
<a name='L324'></a><a href='#L324'>324</a>
<a name='L325'></a><a href='#L325'>325</a>
<a name='L326'></a><a href='#L326'>326</a>
<a name='L327'></a><a href='#L327'>327</a>
<a name='L328'></a><a href='#L328'>328</a>
<a name='L329'></a><a href='#L329'>329</a>
<a name='L330'></a><a href='#L330'>330</a>
<a name='L331'></a><a href='#L331'>331</a>
<a name='L332'></a><a href='#L332'>332</a>
<a name='L333'></a><a href='#L333'>333</a>
<a name='L334'></a><a href='#L334'>334</a>
<a name='L335'></a><a href='#L335'>335</a>
<a name='L336'></a><a href='#L336'>336</a>
<a name='L337'></a><a href='#L337'>337</a>
<a name='L338'></a><a href='#L338'>338</a>
<a name='L339'></a><a href='#L339'>339</a>
<a name='L340'></a><a href='#L340'>340</a>
<a name='L341'></a><a href='#L341'>341</a>
<a name='L342'></a><a href='#L342'>342</a>
<a name='L343'></a><a href='#L343'>343</a>
<a name='L344'></a><a href='#L344'>344</a>
<a name='L345'></a><a href='#L345'>345</a>
<a name='L346'></a><a href='#L346'>346</a>
<a name='L347'></a><a href='#L347'>347</a>
<a name='L348'></a><a href='#L348'>348</a>
<a name='L349'></a><a href='#L349'>349</a>
<a name='L350'></a><a href='#L350'>350</a>
<a name='L351'></a><a href='#L351'>351</a>
<a name='L352'></a><a href='#L352'>352</a>
<a name='L353'></a><a href='#L353'>353</a>
<a name='L354'></a><a href='#L354'>354</a>
<a name='L355'></a><a href='#L355'>355</a>
<a name='L356'></a><a href='#L356'>356</a>
<a name='L357'></a><a href='#L357'>357</a>
<a name='L358'></a><a href='#L358'>358</a>
<a name='L359'></a><a href='#L359'>359</a>
<a name='L360'></a><a href='#L360'>360</a>
<a name='L361'></a><a href='#L361'>361</a>
<a name='L362'></a><a href='#L362'>362</a>
<a name='L363'></a><a href='#L363'>363</a>
<a name='L364'></a><a href='#L364'>364</a>
<a name='L365'></a><a href='#L365'>365</a>
<a name='L366'></a><a href='#L366'>366</a>
<a name='L367'></a><a href='#L367'>367</a>
<a name='L368'></a><a href='#L368'>368</a>
<a name='L369'></a><a href='#L369'>369</a>
<a name='L370'></a><a href='#L370'>370</a>
<a name='L371'></a><a href='#L371'>371</a>
<a name='L372'></a><a href='#L372'>372</a>
<a name='L373'></a><a href='#L373'>373</a>
<a name='L374'></a><a href='#L374'>374</a>
<a name='L375'></a><a href='#L375'>375</a>
<a name='L376'></a><a href='#L376'>376</a>
<a name='L377'></a><a href='#L377'>377</a>
<a name='L378'></a><a href='#L378'>378</a>
<a name='L379'></a><a href='#L379'>379</a>
<a name='L380'></a><a href='#L380'>380</a>
<a name='L381'></a><a href='#L381'>381</a>
<a name='L382'></a><a href='#L382'>382</a>
<a name='L383'></a><a href='#L383'>383</a>
<a name='L384'></a><a href='#L384'>384</a>
<a name='L385'></a><a href='#L385'>385</a>
<a name='L386'></a><a href='#L386'>386</a>
<a name='L387'></a><a href='#L387'>387</a>
<a name='L388'></a><a href='#L388'>388</a>
<a name='L389'></a><a href='#L389'>389</a>
<a name='L390'></a><a href='#L390'>390</a>
<a name='L391'></a><a href='#L391'>391</a>
<a name='L392'></a><a href='#L392'>392</a>
<a name='L393'></a><a href='#L393'>393</a>
<a name='L394'></a><a href='#L394'>394</a>
<a name='L395'></a><a href='#L395'>395</a>
<a name='L396'></a><a href='#L396'>396</a>
<a name='L397'></a><a href='#L397'>397</a>
<a name='L398'></a><a href='#L398'>398</a>
<a name='L399'></a><a href='#L399'>399</a>
<a name='L400'></a><a href='#L400'>400</a>
<a name='L401'></a><a href='#L401'>401</a>
<a name='L402'></a><a href='#L402'>402</a>
<a name='L403'></a><a href='#L403'>403</a>
<a name='L404'></a><a href='#L404'>404</a>
<a name='L405'></a><a href='#L405'>405</a>
<a name='L406'></a><a href='#L406'>406</a>
<a name='L407'></a><a href='#L407'>407</a>
<a name='L408'></a><a href='#L408'>408</a>
<a name='L409'></a><a href='#L409'>409</a>
<a name='L410'></a><a href='#L410'>410</a>
<a name='L411'></a><a href='#L411'>411</a>
<a name='L412'></a><a href='#L412'>412</a>
<a name='L413'></a><a href='#L413'>413</a>
<a name='L414'></a><a href='#L414'>414</a>
<a name='L415'></a><a href='#L415'>415</a>
<a name='L416'></a><a href='#L416'>416</a>
<a name='L417'></a><a href='#L417'>417</a>
<a name='L418'></a><a href='#L418'>418</a>
<a name='L419'></a><a href='#L419'>419</a>
<a name='L420'></a><a href='#L420'>420</a>
<a name='L421'></a><a href='#L421'>421</a>
<a name='L422'></a><a href='#L422'>422</a>
<a name='L423'></a><a href='#L423'>423</a>
<a name='L424'></a><a href='#L424'>424</a>
<a name='L425'></a><a href='#L425'>425</a>
<a name='L426'></a><a href='#L426'>426</a>
<a name='L427'></a><a href='#L427'>427</a>
<a name='L428'></a><a href='#L428'>428</a>
<a name='L429'></a><a href='#L429'>429</a>
<a name='L430'></a><a href='#L430'>430</a>
<a name='L431'></a><a href='#L431'>431</a>
<a name='L432'></a><a href='#L432'>432</a>
<a name='L433'></a><a href='#L433'>433</a>
<a name='L434'></a><a href='#L434'>434</a>
<a name='L435'></a><a href='#L435'>435</a>
<a name='L436'></a><a href='#L436'>436</a>
<a name='L437'></a><a href='#L437'>437</a>
<a name='L438'></a><a href='#L438'>438</a>
<a name='L439'></a><a href='#L439'>439</a>
<a name='L440'></a><a href='#L440'>440</a>
<a name='L441'></a><a href='#L441'>441</a>
<a name='L442'></a><a href='#L442'>442</a>
<a name='L443'></a><a href='#L443'>443</a>
<a name='L444'></a><a href='#L444'>444</a>
<a name='L445'></a><a href='#L445'>445</a>
<a name='L446'></a><a href='#L446'>446</a>
<a name='L447'></a><a href='#L447'>447</a>
<a name='L448'></a><a href='#L448'>448</a>
<a name='L449'></a><a href='#L449'>449</a>
<a name='L450'></a><a href='#L450'>450</a>
<a name='L451'></a><a href='#L451'>451</a>
<a name='L452'></a><a href='#L452'>452</a>
<a name='L453'></a><a href='#L453'>453</a>
<a name='L454'></a><a href='#L454'>454</a>
<a name='L455'></a><a href='#L455'>455</a>
<a name='L456'></a><a href='#L456'>456</a>
<a name='L457'></a><a href='#L457'>457</a>
<a name='L458'></a><a href='#L458'>458</a>
<a name='L459'></a><a href='#L459'>459</a>
<a name='L460'></a><a href='#L460'>460</a>
<a name='L461'></a><a href='#L461'>461</a>
<a name='L462'></a><a href='#L462'>462</a>
<a name='L463'></a><a href='#L463'>463</a>
<a name='L464'></a><a href='#L464'>464</a>
<a name='L465'></a><a href='#L465'>465</a>
<a name='L466'></a><a href='#L466'>466</a>
<a name='L467'></a><a href='#L467'>467</a>
<a name='L468'></a><a href='#L468'>468</a>
<a name='L469'></a><a href='#L469'>469</a>
<a name='L470'></a><a href='#L470'>470</a>
<a name='L471'></a><a href='#L471'>471</a>
<a name='L472'></a><a href='#L472'>472</a>
<a name='L473'></a><a href='#L473'>473</a>
<a name='L474'></a><a href='#L474'>474</a>
<a name='L475'></a><a href='#L475'>475</a>
<a name='L476'></a><a href='#L476'>476</a>
<a name='L477'></a><a href='#L477'>477</a>
<a name='L478'></a><a href='#L478'>478</a>
<a name='L479'></a><a href='#L479'>479</a>
<a name='L480'></a><a href='#L480'>480</a>
<a name='L481'></a><a href='#L481'>481</a>
<a name='L482'></a><a href='#L482'>482</a>
<a name='L483'></a><a href='#L483'>483</a>
<a name='L484'></a><a href='#L484'>484</a>
<a name='L485'></a><a href='#L485'>485</a>
<a name='L486'></a><a href='#L486'>486</a>
<a name='L487'></a><a href='#L487'>487</a>
<a name='L488'></a><a href='#L488'>488</a>
<a name='L489'></a><a href='#L489'>489</a>
<a name='L490'></a><a href='#L490'>490</a>
<a name='L491'></a><a href='#L491'>491</a>
<a name='L492'></a><a href='#L492'>492</a>
<a name='L493'></a><a href='#L493'>493</a>
<a name='L494'></a><a href='#L494'>494</a>
<a name='L495'></a><a href='#L495'>495</a>
<a name='L496'></a><a href='#L496'>496</a>
<a name='L497'></a><a href='#L497'>497</a>
<a name='L498'></a><a href='#L498'>498</a>
<a name='L499'></a><a href='#L499'>499</a>
<a name='L500'></a><a href='#L500'>500</a>
<a name='L501'></a><a href='#L501'>501</a>
<a name='L502'></a><a href='#L502'>502</a>
<a name='L503'></a><a href='#L503'>503</a>
<a name='L504'></a><a href='#L504'>504</a>
<a name='L505'></a><a href='#L505'>505</a>
<a name='L506'></a><a href='#L506'>506</a>
<a name='L507'></a><a href='#L507'>507</a>
<a name='L508'></a><a href='#L508'>508</a>
<a name='L509'></a><a href='#L509'>509</a>
<a name='L510'></a><a href='#L510'>510</a>
<a name='L511'></a><a href='#L511'>511</a>
<a name='L512'></a><a href='#L512'>512</a>
<a name='L513'></a><a href='#L513'>513</a>
<a name='L514'></a><a href='#L514'>514</a>
<a name='L515'></a><a href='#L515'>515</a>
<a name='L516'></a><a href='#L516'>516</a>
<a name='L517'></a><a href='#L517'>517</a>
<a name='L518'></a><a href='#L518'>518</a>
<a name='L519'></a><a href='#L519'>519</a>
<a name='L520'></a><a href='#L520'>520</a>
<a name='L521'></a><a href='#L521'>521</a>
<a name='L522'></a><a href='#L522'>522</a>
<a name='L523'></a><a href='#L523'>523</a>
<a name='L524'></a><a href='#L524'>524</a>
<a name='L525'></a><a href='#L525'>525</a>
<a name='L526'></a><a href='#L526'>526</a>
<a name='L527'></a><a href='#L527'>527</a>
<a name='L528'></a><a href='#L528'>528</a>
<a name='L529'></a><a href='#L529'>529</a>
<a name='L530'></a><a href='#L530'>530</a>
<a name='L531'></a><a href='#L531'>531</a>
<a name='L532'></a><a href='#L532'>532</a>
<a name='L533'></a><a href='#L533'>533</a>
<a name='L534'></a><a href='#L534'>534</a>
<a name='L535'></a><a href='#L535'>535</a>
<a name='L536'></a><a href='#L536'>536</a>
<a name='L537'></a><a href='#L537'>537</a>
<a name='L538'></a><a href='#L538'>538</a>
<a name='L539'></a><a href='#L539'>539</a>
<a name='L540'></a><a href='#L540'>540</a>
<a name='L541'></a><a href='#L541'>541</a>
<a name='L542'></a><a href='#L542'>542</a>
<a name='L543'></a><a href='#L543'>543</a>
<a name='L544'></a><a href='#L544'>544</a>
<a name='L545'></a><a href='#L545'>545</a>
<a name='L546'></a><a href='#L546'>546</a>
<a name='L547'></a><a href='#L547'>547</a>
<a name='L548'></a><a href='#L548'>548</a>
<a name='L549'></a><a href='#L549'>549</a>
<a name='L550'></a><a href='#L550'>550</a>
<a name='L551'></a><a href='#L551'>551</a>
<a name='L552'></a><a href='#L552'>552</a>
<a name='L553'></a><a href='#L553'>553</a>
<a name='L554'></a><a href='#L554'>554</a>
<a name='L555'></a><a href='#L555'>555</a>
<a name='L556'></a><a href='#L556'>556</a>
<a name='L557'></a><a href='#L557'>557</a>
<a name='L558'></a><a href='#L558'>558</a>
<a name='L559'></a><a href='#L559'>559</a>
<a name='L560'></a><a href='#L560'>560</a>
<a name='L561'></a><a href='#L561'>561</a>
<a name='L562'></a><a href='#L562'>562</a>
<a name='L563'></a><a href='#L563'>563</a>
<a name='L564'></a><a href='#L564'>564</a>
<a name='L565'></a><a href='#L565'>565</a>
<a name='L566'></a><a href='#L566'>566</a>
<a name='L567'></a><a href='#L567'>567</a>
<a name='L568'></a><a href='#L568'>568</a>
<a name='L569'></a><a href='#L569'>569</a>
<a name='L570'></a><a href='#L570'>570</a>
<a name='L571'></a><a href='#L571'>571</a>
<a name='L572'></a><a href='#L572'>572</a>
<a name='L573'></a><a href='#L573'>573</a>
<a name='L574'></a><a href='#L574'>574</a>
<a name='L575'></a><a href='#L575'>575</a>
<a name='L576'></a><a href='#L576'>576</a>
<a name='L577'></a><a href='#L577'>577</a>
<a name='L578'></a><a href='#L578'>578</a>
<a name='L579'></a><a href='#L579'>579</a>
<a name='L580'></a><a href='#L580'>580</a>
<a name='L581'></a><a href='#L581'>581</a>
<a name='L582'></a><a href='#L582'>582</a>
<a name='L583'></a><a href='#L583'>583</a>
<a name='L584'></a><a href='#L584'>584</a>
<a name='L585'></a><a href='#L585'>585</a>
<a name='L586'></a><a href='#L586'>586</a>
<a name='L587'></a><a href='#L587'>587</a>
<a name='L588'></a><a href='#L588'>588</a>
<a name='L589'></a><a href='#L589'>589</a>
<a name='L590'></a><a href='#L590'>590</a>
<a name='L591'></a><a href='#L591'>591</a>
<a name='L592'></a><a href='#L592'>592</a>
<a name='L593'></a><a href='#L593'>593</a>
<a name='L594'></a><a href='#L594'>594</a>
<a name='L595'></a><a href='#L595'>595</a>
<a name='L596'></a><a href='#L596'>596</a>
<a name='L597'></a><a href='#L597'>597</a>
<a name='L598'></a><a href='#L598'>598</a>
<a name='L599'></a><a href='#L599'>599</a>
<a name='L600'></a><a href='#L600'>600</a>
<a name='L601'></a><a href='#L601'>601</a>
<a name='L602'></a><a href='#L602'>602</a>
<a name='L603'></a><a href='#L603'>603</a>
<a name='L604'></a><a href='#L604'>604</a>
<a name='L605'></a><a href='#L605'>605</a>
<a name='L606'></a><a href='#L606'>606</a>
<a name='L607'></a><a href='#L607'>607</a>
<a name='L608'></a><a href='#L608'>608</a>
<a name='L609'></a><a href='#L609'>609</a>
<a name='L610'></a><a href='#L610'>610</a>
<a name='L611'></a><a href='#L611'>611</a>
<a name='L612'></a><a href='#L612'>612</a>
<a name='L613'></a><a href='#L613'>613</a>
<a name='L614'></a><a href='#L614'>614</a>
<a name='L615'></a><a href='#L615'>615</a>
<a name='L616'></a><a href='#L616'>616</a>
<a name='L617'></a><a href='#L617'>617</a>
<a name='L618'></a><a href='#L618'>618</a>
<a name='L619'></a><a href='#L619'>619</a>
<a name='L620'></a><a href='#L620'>620</a>
<a name='L621'></a><a href='#L621'>621</a>
<a name='L622'></a><a href='#L622'>622</a>
<a name='L623'></a><a href='#L623'>623</a>
<a name='L624'></a><a href='#L624'>624</a>
<a name='L625'></a><a href='#L625'>625</a>
<a name='L626'></a><a href='#L626'>626</a>
<a name='L627'></a><a href='#L627'>627</a>
<a name='L628'></a><a href='#L628'>628</a></td><td class="line-coverage quiet"><span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-yes">1x</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-yes">1x</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-yes">1x</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-yes">1x</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-yes">1x</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-yes">1x</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-yes">1x</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-yes">1x</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-yes">1x</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-yes">1x</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-yes">1x</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-yes">1x</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-yes">1x</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-yes">1x</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-yes">1x</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-yes">1x</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-yes">1x</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-yes">1x</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-yes">1x</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-yes">1x</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-yes">1x</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-yes">1x</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-yes">1x</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-yes">1x</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-yes">1x</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-yes">1x</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-yes">1x</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-yes">1x</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-yes">1x</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-yes">1x</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-yes">1x</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-yes">2x</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-yes">2x</span>
<span class="cline-any cline-yes">1x</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-yes">1x</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-yes">2x</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-yes">2x</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-neutral">&nbsp;</span></td><td class="text"><pre class="prettyprint lang-js">/**
 * Unknown World - TurnInput/TurnOutput Zod 스키마.
 *
 * 이 모듈은 백엔드 Pydantic 모델(U-005)과 1:1 대응하는 Zod 스키마를 정의합니다.
 * 클라이언트 측 검증 및 타입 안전성을 제공합니다.
 *
 * 설계 원칙:
 *   - RULE-003: 구조화 출력(JSON Schema) 우선 + 이중 검증 (서버 Pydantic + 클라 Zod)
 *   - RULE-004: 검증 실패 시 안전 폴백 제공 (UI 멈춤 방지)
 *   - RULE-005: 재화 인바리언트 (cost, balance_after 필수, 잔액 음수 금지)
 *   - RULE-006: ko/en 언어 정책 (Language enum으로 고정)
 *   - RULE-009: 좌표 규약 (0~1000, bbox [ymin,xmin,ymax,xmax])
 *
 * Q1 결정 사항:
 *   - schema_version 포함 (Option A): SaveGame/마이그레이션/검증에 유리
 *
 * @module schemas/turn
 */
&nbsp;
import { z } from "zod";
&nbsp;
// =============================================================================
// 스키마 버전 (Q1 결정: Option A - 포함)
// =============================================================================
&nbsp;
/**
 * 현재 스키마 버전.
 * SaveGame/마이그레이션/검증에 사용됩니다.
 */
export const SCHEMA_VERSION = "1.0.0" as const;
&nbsp;
// =============================================================================
// 공통 Enum 타입
// =============================================================================
&nbsp;
/**
 * 지원 언어 (RULE-006).
 * ko/en 혼합 출력 금지. TurnInput.language를 SSOT로 삼아
 * 모든 UI/내러티브/시스템 메시지는 동일 언어로 고정합니다.
 */
export const LanguageSchema = z.enum(["ko-KR", "en-US"]);
export type Language = z.infer&lt;typeof LanguageSchema&gt;;
&nbsp;
/**
 * 테마 설정.
 */
export const ThemeSchema = z.enum(["dark", "light"]);
export type Theme = z.infer&lt;typeof ThemeSchema&gt;;
&nbsp;
/**
 * 에이전트 실행 단계 (RULE-008).
 * 에이전트형 시스템임을 UI로 증명하기 위한 단계 표시.
 */
export const AgentPhaseSchema = z.enum([
  "parse",
  "validate",
  "plan",
  "resolve",
  "render",
  "verify",
  "commit",
]);
export type AgentPhase = z.infer&lt;typeof AgentPhaseSchema&gt;;
&nbsp;
/**
 * 검증 배지 (RULE-008).
 * 턴 결과에 대한 검증 상태를 표시합니다.
 */
export const ValidationBadgeSchema = z.enum([
  "schema_ok",
  "schema_fail",
  "economy_ok",
  "economy_fail",
  "safety_ok",
  "safety_blocked",
  "consistency_ok",
  "consistency_fail",
]);
export type ValidationBadge = z.infer&lt;typeof ValidationBadgeSchema&gt;;
&nbsp;
/**
 * 모델/품질 선택 라벨 (RULE-008).
 * 프롬프트 노출 없이 "왜 이 선택이었는지"를 사용자 친화 라벨로 표시.
 */
export const ModelLabelSchema = z.enum(["FAST", "QUALITY", "CHEAP", "REF"]);
export type ModelLabel = z.infer&lt;typeof ModelLabelSchema&gt;;
&nbsp;
/**
 * 행동 위험도 수준.
 */
export const RiskLevelSchema = z.enum(["low", "medium", "high"]);
export type RiskLevel = z.infer&lt;typeof RiskLevelSchema&gt;;
&nbsp;
// =============================================================================
// 공통 하위 타입
// =============================================================================
&nbsp;
/**
 * 정규화 좌표 (RULE-009).
 * 0~1000 범위의 정수입니다.
 */
export const CoordinateSchema = z
  .number()
  .int()
  .min(0)
  .max(1000)
  .describe("정규화 좌표 (0~1000)");
export type Coordinate = z.infer&lt;typeof CoordinateSchema&gt;;
&nbsp;
/**
 * 2D 바운딩 박스 (RULE-009).
 * 좌표는 0~1000 정규화 좌표계이며, bbox는 [ymin, xmin, ymax, xmax] 순서입니다.
 * 이미지 이해 bbox 포맷과 호환됩니다.
 */
export const Box2DSchema = z
  .object({
    ymin: CoordinateSchema.describe("Y 최소값 (상단)"),
    xmin: CoordinateSchema.describe("X 최소값 (좌측)"),
    ymax: CoordinateSchema.describe("Y 최대값 (하단)"),
    xmax: CoordinateSchema.describe("X 최대값 (우측)"),
  })
  .strict();
export type Box2D = z.infer&lt;typeof Box2DSchema&gt;;
&nbsp;
/**
 * 재화 수량.
 * signal과 memory_shard는 0 이상이어야 합니다 (RULE-005).
 */
export const CurrencyAmountSchema = z
  .object({
    signal: z.number().int().min(0).describe("시그널 (기본 재화, 0 이상)"),
    memory_shard: z
      .number()
      .int()
      .min(0)
      .describe("기억 파편 (희귀 재화, 0 이상)"),
  })
  .strict();
export type CurrencyAmount = z.infer&lt;typeof CurrencyAmountSchema&gt;;
&nbsp;
// =============================================================================
// TurnInput 관련 타입
// =============================================================================
&nbsp;
/**
 * 클릭 입력 정보.
 * 화면 오브젝트 클릭 시 전달되는 정보입니다.
 */
export const ClickInputSchema = z
  .object({
    object_id: z.string().describe("클릭한 오브젝트 ID"),
    box_2d: Box2DSchema.nullable()
      .default(null)
      .describe("클릭 위치 바운딩 박스 (선택)"),
  })
  .strict();
export type ClickInput = z.infer&lt;typeof ClickInputSchema&gt;;
&nbsp;
/**
 * 클라이언트 정보.
 */
export const ClientInfoSchema = z
  .object({
    viewport_w: z
      .number()
      .int()
      .positive()
      .describe("뷰포트 너비 (픽셀, 양수)"),
    viewport_h: z
      .number()
      .int()
      .positive()
      .describe("뷰포트 높이 (픽셀, 양수)"),
    theme: ThemeSchema.default("dark").describe("현재 테마"),
  })
  .strict();
export type ClientInfo = z.infer&lt;typeof ClientInfoSchema&gt;;
&nbsp;
/**
 * 재화 스냅샷 (클라이언트 → 서버).
 * 클라이언트가 보유한 현재 재화 상태입니다.
 */
export const EconomySnapshotSchema = z
  .object({
    signal: z.number().int().min(0).describe("현재 시그널 잔액 (0 이상)"),
    memory_shard: z
      .number()
      .int()
      .min(0)
      .describe("현재 기억 파편 잔액 (0 이상)"),
  })
  .strict();
export type EconomySnapshot = z.infer&lt;typeof EconomySnapshotSchema&gt;;
&nbsp;
/**
 * 턴 입력 (클라이언트 → 서버).
 * 사용자가 턴을 진행할 때 서버로 전송하는 입력 데이터입니다.
 */
export const TurnInputSchema = z
  .object({
    language: LanguageSchema.describe("요청 언어 (응답도 동일 언어로 고정)"),
    text: z.string().default("").describe("사용자 자연어 입력"),
    click: ClickInputSchema.nullable()
      .default(null)
      .describe("오브젝트 클릭 정보 (선택)"),
    client: ClientInfoSchema.describe("클라이언트 환경 정보"),
    economy_snapshot: EconomySnapshotSchema.describe("현재 재화 상태"),
  })
  .strict();
export type TurnInput = z.infer&lt;typeof TurnInputSchema&gt;;
&nbsp;
// =============================================================================
// TurnOutput 관련 타입 - UI
// =============================================================================
&nbsp;
/**
 * 액션 카드 (Action Deck).
 * 매 턴 AI가 추천하는 행동 카드입니다.
 */
export const ActionCardSchema = z
  .object({
    id: z.string().describe("카드 고유 ID"),
    label: z.string().describe("카드 라벨 (표시용)"),
    description: z.string().nullable().default(null).describe("카드 설명 (선택)"),
    cost: CurrencyAmountSchema.describe("예상 비용"),
    risk: RiskLevelSchema.default("low").describe("위험도"),
    hint: z.string().nullable().default(null).describe("예상 결과 힌트 (선택)"),
  })
  .strict();
export type ActionCard = z.infer&lt;typeof ActionCardSchema&gt;;
&nbsp;
/**
 * 장면 오브젝트 (클릭 가능한 핫스팟).
 * 좌표는 0~1000 정규화 좌표계를 사용합니다 (RULE-009).
 */
export const SceneObjectSchema = z
  .object({
    id: z.string().describe("오브젝트 고유 ID"),
    label: z.string().describe("오브젝트 라벨 (표시용)"),
    box_2d: Box2DSchema.describe("바운딩 박스"),
    interaction_hint: z
      .string()
      .nullable()
      .default(null)
      .describe("상호작용 힌트 (선택)"),
  })
  .strict();
export type SceneObject = z.infer&lt;typeof SceneObjectSchema&gt;;
&nbsp;
/**
 * 액션 덱 (Q1 결정: ui.action_deck.cards[] 구조).
 * 매 턴 AI가 제시하는 추천 행동 카드 덱입니다.
 */
export const ActionDeckSchema = z
  .object({
    cards: z
      .array(ActionCardSchema)
      .max(10)
      .default([])
      .describe("액션 카드 목록 (3~6장 권장)"),
  })
  .strict();
export type ActionDeck = z.infer&lt;typeof ActionDeckSchema&gt;;
&nbsp;
/**
 * UI 출력 데이터.
 * AI가 생성한 UI 요소들입니다.
 * 채팅 버블이 아닌 게임 UI로 표현됩니다 (RULE-002).
 */
export const UIOutputSchema = z
  .object({
    action_deck: ActionDeckSchema.default({ cards: [] }).describe("액션 카드 덱"),
    objects: z
      .array(SceneObjectSchema)
      .default([])
      .describe("클릭 가능한 장면 오브젝트 목록"),
  })
  .strict();
export type UIOutput = z.infer&lt;typeof UIOutputSchema&gt;;
&nbsp;
// =============================================================================
// TurnOutput 관련 타입 - World
// =============================================================================
&nbsp;
/**
 * 중요 설정 고정 후보.
 * 사용자가 Memory Shard를 소비해 고정할 수 있는 중요 설정입니다.
 */
export const MemoryPinSchema = z
  .object({
    id: z.string().describe("핀 고유 ID"),
    content: z.string().describe("고정할 내용"),
    cost: CurrencyAmountSchema.describe("고정에 필요한 비용"),
  })
  .strict();
export type MemoryPin = z.infer&lt;typeof MemoryPinSchema&gt;;
&nbsp;
/**
 * 세계 규칙 (Rule Board).
 * 현재 세계에 적용 중인 물리 법칙이나 메타 규칙입니다.
 */
export const WorldRuleSchema = z
  .object({
    id: z.string().describe("규칙 고유 ID"),
    label: z.string().describe("규칙 이름"),
    description: z
      .string()
      .nullable()
      .default(null)
      .describe("규칙 상세 설명 (선택)"),
  })
  .strict();
export type WorldRule = z.infer&lt;typeof WorldRuleSchema&gt;;
&nbsp;
/**
 * 퀘스트/목표 (Quest Panel).
 * 플레이어가 달성해야 하는 현재 목표입니다.
 */
export const QuestSchema = z
  .object({
    id: z.string().describe("퀘스트 고유 ID"),
    label: z.string().describe("퀘스트 이름"),
    is_completed: z.boolean().default(false).describe("달성 여부"),
  })
  .strict();
export type Quest = z.infer&lt;typeof QuestSchema&gt;;
&nbsp;
/**
 * 세계 상태 변화 (Q2 결정: Option A - delta 중심).
 * 이번 턴에서 변경된 세계 상태를 나타냅니다.
 */
export const WorldDeltaSchema = z
  .object({
    rules_changed: z
      .array(WorldRuleSchema)
      .default([])
      .describe("변경된 규칙 목록"),
    inventory_added: z
      .array(z.string())
      .default([])
      .describe("추가된 인벤토리 아이템"),
    inventory_removed: z
      .array(z.string())
      .default([])
      .describe("제거된 인벤토리 아이템"),
    quests_updated: z
      .array(QuestSchema)
      .default([])
      .describe("업데이트된 퀘스트/목표 목록"),
    relationships_changed: z
      .array(z.string())
      .default([])
      .describe("변경된 관계"),
    memory_pins: z
      .array(MemoryPinSchema)
      .default([])
      .describe("중요 설정 고정 후보"),
  })
  .strict();
export type WorldDelta = z.infer&lt;typeof WorldDeltaSchema&gt;;
&nbsp;
// =============================================================================
// TurnOutput 관련 타입 - Render
// =============================================================================
&nbsp;
/**
 * 이미지 생성 작업.
 * 조건부 이미지 생성/편집 요청입니다.
 */
export const ImageJobSchema = z
  .object({
    should_generate: z.boolean().describe("이미지를 생성해야 하는지"),
    prompt: z.string().default("").describe("이미지 생성 프롬프트"),
    model_label: ModelLabelSchema.default("FAST").describe("모델 선택 라벨"),
    aspect_ratio: z.string().default("16:9").describe("가로세로 비율"),
    image_size: z.string().default("1024x1024").describe("이미지 크기"),
    reference_image_ids: z
      .array(z.string())
      .default([])
      .describe("참조 이미지 ID 목록 (선택)"),
  })
  .strict();
export type ImageJob = z.infer&lt;typeof ImageJobSchema&gt;;
&nbsp;
/**
 * 렌더링 출력 데이터.
 * 이미지 생성/편집 관련 정보입니다.
 */
export const RenderOutputSchema = z
  .object({
    image_job: ImageJobSchema.nullable()
      .default(null)
      .describe("이미지 생성 작업 (선택)"),
  })
  .strict();
export type RenderOutput = z.infer&lt;typeof RenderOutputSchema&gt;;
&nbsp;
// =============================================================================
// TurnOutput 관련 타입 - Economy
// =============================================================================
&nbsp;
/**
 * 경제 출력 데이터 (RULE-005).
 * 이번 턴의 비용과 잔액 정보입니다.
 * 잔액 음수는 절대 불가 (서버 Hard gate).
 */
export const EconomyOutputSchema = z
  .object({
    cost: CurrencyAmountSchema.describe("이번 턴에 소비된 비용"),
    balance_after: CurrencyAmountSchema.describe("소비 후 잔액"),
  })
  .strict();
export type EconomyOutput = z.infer&lt;typeof EconomyOutputSchema&gt;;
&nbsp;
// =============================================================================
// TurnOutput 관련 타입 - Safety
// =============================================================================
&nbsp;
/**
 * 안전 출력 데이터.
 * 안전 정책 관련 정보입니다.
 * 차단 시 명시적 메시지와 함께 안전한 대체 결과를 제공합니다.
 */
export const SafetyOutputSchema = z
  .object({
    blocked: z
      .boolean()
      .default(false)
      .describe("안전 정책에 의해 차단되었는지"),
    message: z
      .string()
      .nullable()
      .default(null)
      .describe("차단 시 사용자에게 표시할 메시지 (선택)"),
  })
  .strict();
export type SafetyOutput = z.infer&lt;typeof SafetyOutputSchema&gt;;
&nbsp;
// =============================================================================
// TurnOutput 관련 타입 - Agent Console
// =============================================================================
&nbsp;
/**
 * 에이전트 콘솔 데이터 (RULE-008).
 * 에이전트형 시스템임을 UI로 증명하기 위한 정보입니다.
 */
export const AgentConsoleSchema = z
  .object({
    current_phase: AgentPhaseSchema.default("commit").describe("현재 실행 단계"),
    badges: z.array(ValidationBadgeSchema).default([]).describe("검증 배지 목록"),
    repair_count: z.number().int().min(0).default(0).describe("자동 복구 시도 횟수"),
  })
  .strict();
export type AgentConsole = z.infer&lt;typeof AgentConsoleSchema&gt;;
&nbsp;
// =============================================================================
// TurnOutput (메인 응답 스키마)
// =============================================================================
&nbsp;
/**
 * 턴 출력 (서버 → 클라이언트).
 * 서버가 턴 처리 후 클라이언트로 반환하는 구조화된 응답입니다.
 *
 * Hard Gate 필드 (RULE-003/004/005):
 *   - economy: cost와 balance_after 필수, 잔액 음수 금지
 *   - safety: blocked 시 안전한 대체 결과 제공
 *   - language: 요청 언어와 동일하게 고정 (혼합 출력 금지)
 */
export const TurnOutputSchema = z
  .object({
    // 필수 필드 (Hard Gate)
    language: LanguageSchema.describe("응답 언어 (요청과 동일)"),
    narrative: z.string().describe("내러티브 텍스트 (표시용)"),
    economy: EconomyOutputSchema.describe("경제 정보 (비용, 잔액)"),
    safety: SafetyOutputSchema.describe("안전 정책 정보"),
&nbsp;
    // UI 관련 필드
    ui: UIOutputSchema.default({ action_deck: { cards: [] }, objects: [] }).describe(
      "UI 요소",
    ),
&nbsp;
    // 세계 상태 필드
    world: WorldDeltaSchema.default({
      rules_changed: [],
      inventory_added: [],
      inventory_removed: [],
      quests_updated: [],
      relationships_changed: [],
      memory_pins: [],
    }).describe("세계 상태 변화 (delta)"),
&nbsp;
    // 렌더링 필드
    render: RenderOutputSchema.default({ image_job: null }).describe("렌더링 정보"),
&nbsp;
    // 에이전트 콘솔 필드
    agent_console: AgentConsoleSchema.default({
      current_phase: "commit",
      badges: [],
      repair_count: 0,
    }).describe("에이전트 실행 정보"),
  })
  .strict();
export type TurnOutput = z.infer&lt;typeof TurnOutputSchema&gt;;
&nbsp;
// =============================================================================
// 안전 폴백 (RULE-004)
// =============================================================================
&nbsp;
/**
 * 검증 실패 시 제공되는 안전 폴백 TurnOutput.
 * UI가 멈추지 않도록 최소한의 정보를 제공합니다.
 *
 * @param language - 요청 언어
 * @param repairCount - 복구 시도 횟수
 * @param errorMessage - 오류 메시지 (선택)
 */
export function createFallbackTurnOutput(
  language: Language,
  repairCount: number = 0,
  errorMessage?: string,
): TurnOutput {
  const fallbackNarrative =
    language === "ko-KR"
      ? "[시스템] 응답을 처리하는 중 문제가 발생했습니다. 다시 시도해 주세요."
      : <span class="branch-1 cbranch-no" title="branch not covered" >"[System] An error occurred while processing the response. Please try again.";</span>
&nbsp;
  const safetyMessage =
    language === "ko-KR"
      ? "스키마 검증 실패로 인한 폴백 응답입니다."
      : <span class="branch-1 cbranch-no" title="branch not covered" >"This is a fallback response due to schema validation failure.";</span>
&nbsp;
  return {
    language,
    narrative: errorMessage ?? fallbackNarrative,
    economy: {
      cost: { signal: 0, memory_shard: 0 },
      balance_after: { signal: 0, memory_shard: 0 },
    },
    safety: {
      blocked: false,
      message: safetyMessage,
    },
    ui: {
      action_deck: { cards: [] },
      objects: [],
    },
    world: {
      rules_changed: [],
      inventory_added: [],
      inventory_removed: [],
      quests_updated: [],
      relationships_changed: [],
      memory_pins: [],
    },
    render: {
      image_job: null,
    },
    agent_console: {
      current_phase: "commit",
      badges: ["schema_fail"],
      repair_count: repairCount,
    },
  };
}
&nbsp;
// =============================================================================
// 검증 헬퍼 함수
// =============================================================================
&nbsp;
/**
 * TurnOutput 검증 결과 타입.
 */
export type TurnOutputParseResult =
  | { success: true; data: TurnOutput }
  | { success: false; error: z.ZodError; fallback: TurnOutput };
&nbsp;
/**
 * TurnOutput을 안전하게 파싱합니다.
 * 실패 시 폴백 TurnOutput을 반환합니다 (RULE-004).
 *
 * @param data - 파싱할 데이터
 * @param language - 폴백 시 사용할 언어 (기본: ko-KR)
 * @param repairCount - 현재 복구 시도 횟수
 */
export function safeParseTurnOutput(
  data: unknown,
  language: Language = "ko-KR",
  repairCount: number = 0,
): TurnOutputParseResult {
  const result = TurnOutputSchema.safeParse(data);
&nbsp;
  if (result.success) {
    return { success: true, data: result.data };
  }
&nbsp;
  return {
    success: false,
    error: result.error,
    fallback: createFallbackTurnOutput(language, repairCount),
  };
}
&nbsp;
/**
 * TurnInput을 검증합니다.
 * 입력 데이터의 유효성을 엄격하게 검사합니다.
 *
 * @param data - 검증할 데이터
 * @throws {z.ZodError} 검증 실패 시
 */
export function parseTurnInput(data: unknown): TurnInput {
  return TurnInputSchema.parse(data);
}
&nbsp;
/**
 * TurnInput 안전 파싱 결과 타입.
 */
export type TurnInputSafeParseResult = ReturnType&lt;typeof TurnInputSchema.safeParse&gt;;
&nbsp;
/**
 * TurnInput을 안전하게 파싱합니다.
 *
 * @param data - 파싱할 데이터
 */
export function safeParseTurnInput(data: unknown): TurnInputSafeParseResult {
  return TurnInputSchema.safeParse(data);
}
&nbsp;
&nbsp;</pre></td></tr></table></pre>

                <div class='push'></div><!-- for sticky footer -->
            </div><!-- /wrapper -->
            <div class='footer quiet pad2 space-top1 center small'>
                Code coverage generated by
                <a href="https://istanbul.js.org/" target="_blank" rel="noopener noreferrer">istanbul</a>
                at 2026-01-04T13:05:55.602Z
            </div>
        <script src="prettify.js"></script>
        <script>
            window.onload = function () {
                prettyPrint();
            };
        </script>
        <script src="sorter.js"></script>
        <script src="block-navigation.js"></script>
    </body>
</html>
</file>

<file path="frontend/index.html">
<!doctype html>
<html lang="ko" data-theme="crt">
  <head>
    <meta charset="UTF-8" />
    <link rel="icon" type="image/svg+xml" href="/vite.svg" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <meta
      name="description"
      content="Unknown World - Gemini 기반 에이전트형 무한 생성 로그라이크 내러티브 게임"
    />
    <meta name="theme-color" content="#0d0d0d" />

    <!-- CRT 폰트: VT323 (영문), Share Tech Mono (마이크로 텍스트) -->
    <link rel="preconnect" href="https://fonts.googleapis.com" />
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin />
    <link
      href="https://fonts.googleapis.com/css2?family=Share+Tech+Mono&family=VT323&display=swap"
      rel="stylesheet"
    />

    <title>Unknown World</title>
  </head>
  <body>
    <div id="root"></div>
    <script type="module" src="/src/main.tsx"></script>
  </body>
</html>
</file>

<file path="frontend/package.json">
{
  "name": "unknown-world-frontend",
  "private": true,
  "version": "0.0.0",
  "type": "module",
  "packageManager": "pnpm@10.27.0",
  "scripts": {
    "dev": "vite",
    "build": "tsc -b && vite build",
    "preview": "vite preview",
    "format": "prettier . --write",
    "format:check": "prettier . --check",
    "lint": "eslint .",
    "lint:fix": "eslint . --fix",
    "typecheck": "tsc --noEmit",
    "test": "vitest run",
    "test:watch": "vitest",
    "test:coverage": "vitest run --coverage"
  },
  "dependencies": {
    "@dnd-kit/core": "6.3.1",
    "@dnd-kit/sortable": "10.0.0",
    "@dnd-kit/utilities": "^3.2.2",
    "i18next": "25.7.3",
    "react": "19.2.3",
    "react-dom": "19.2.3",
    "react-i18next": "16.5.1",
    "zod": "4.3.4",
    "zustand": "5.0.9"
  },
  "devDependencies": {
    "@eslint/js": "9.39.2",
    "@testing-library/jest-dom": "^6.9.1",
    "@testing-library/react": "^16.3.1",
    "@types/node": "25.0.3",
    "@types/react": "19.2.7",
    "@types/react-dom": "19.2.3",
    "@vitejs/plugin-react": "5.1.2",
    "@vitest/coverage-v8": "^4.0.16",
    "eslint": "9.39.2",
    "eslint-config-prettier": "10.1.8",
    "eslint-plugin-react": "7.37.5",
    "eslint-plugin-react-hooks": "7.0.1",
    "eslint-plugin-unused-imports": "4.3.0",
    "globals": "16.5.0",
    "jsdom": "^27.4.0",
    "prettier": "3.7.4",
    "typescript": "5.9.3",
    "typescript-eslint": "8.51.0",
    "vite": "7.3.0",
    "vitest": "^4.0.16"
  },
  "pnpm": {
    "onlyBuiltDependencies": [
      "esbuild"
    ]
  }
}
</file>

<file path="frontend/src/components/MutationTimeline.tsx">
/**
 * Unknown World - Mutation Timeline (U-013)
 *
 * 규칙 변형 이벤트를 시간순으로 표시하는 타임라인 컴포넌트입니다.
 * "세계가 변했다"를 UI로 체감할 수 있게 합니다.
 *
 * 설계 원칙:
 *   - RULE-002: 채팅 UI가 아닌 게임 UI로 상시 노출
 *   - RULE-006: i18n 기반 문자열 관리
 *   - PRD 6.4: Rule Mutation Timeline
 *   - Q1 결정: Option B - 별도 Timeline 컴포넌트 (가독성/확장 용이)
 *
 * @module components/MutationTimeline
 */

import { useTranslation } from 'react-i18next';
import { useWorldStore, selectMutationTimeline } from '../stores/worldStore';
import type { MutationEvent } from '../stores/worldStore';

// =============================================================================
// 상수
// =============================================================================

/** 표시할 최대 이벤트 수 (MMP에서 스크롤/요약 전략 적용 예정) */
const MAX_DISPLAY_EVENTS = 10;

// =============================================================================
// 하위 컴포넌트
// =============================================================================

interface TimelineEventProps {
  event: MutationEvent;
}

/**
 * 개별 타임라인 이벤트 렌더링
 */
function TimelineEvent({ event }: TimelineEventProps) {
  const { t } = useTranslation();

  // 이벤트 유형별 아이콘
  const typeIcon = {
    added: '➕',
    modified: '🔄',
    removed: '➖',
  }[event.type];

  // 이벤트 유형별 CSS 클래스
  const typeClass = `timeline-event-${event.type}`;

  return (
    <div className={`timeline-event ${typeClass}`} data-event-type={event.type}>
      <div className="timeline-event-marker">
        <span className="timeline-event-icon" aria-hidden="true">
          {typeIcon}
        </span>
        <span className="timeline-event-turn">
          {t('mutation.turn_label', { turn: event.turn })}
        </span>
      </div>
      <div className="timeline-event-content">
        <span className="timeline-event-label">{event.label}</span>
        <span className="timeline-event-type">{t(`mutation.type.${event.type}`)}</span>
        {event.description && <p className="timeline-event-description">{event.description}</p>}
      </div>
    </div>
  );
}

// =============================================================================
// 메인 컴포넌트
// =============================================================================

/**
 * Mutation Timeline
 *
 * 규칙 변형 이벤트를 시간순(최신 먼저)으로 표시합니다.
 * worldStore의 mutationTimeline 상태를 구독하여 실시간 업데이트됩니다.
 */
export function MutationTimeline() {
  const { t } = useTranslation();
  const mutationTimeline = useWorldStore(selectMutationTimeline);

  // 표시할 이벤트 (최대 개수 제한)
  const displayEvents = mutationTimeline.slice(0, MAX_DISPLAY_EVENTS);
  const hasMore = mutationTimeline.length > MAX_DISPLAY_EVENTS;

  // 빈 상태
  if (mutationTimeline.length === 0) {
    return (
      <div className="mutation-timeline-content timeline-empty" data-ui-importance="critical">
        <div className="timeline-empty-icon" aria-hidden="true">
          📊
        </div>
        <p className="timeline-empty-text">{t('mutation.empty')}</p>
      </div>
    );
  }

  return (
    <div className="mutation-timeline-content" data-ui-importance="critical">
      <div className="timeline-header">
        <span className="timeline-title">{t('mutation.timeline_title')}</span>
        <span className="timeline-count">
          {t('mutation.event_count', { count: mutationTimeline.length })}
        </span>
      </div>
      <div className="timeline-events" role="list" aria-label={t('mutation.timeline_title')}>
        {displayEvents.map((event, index) => (
          <TimelineEvent key={`${event.ruleId}-${event.turn}-${index}`} event={event} />
        ))}
      </div>
      {hasMore && (
        <div className="timeline-more">
          <span className="timeline-more-text">
            {t('mutation.more_events', { count: mutationTimeline.length - MAX_DISPLAY_EVENTS })}
          </span>
        </div>
      )}
    </div>
  );
}

export default MutationTimeline;
</file>

<file path="frontend/src/components/Panel.tsx">
import { useTranslation } from 'react-i18next';

interface PanelProps {
  title: string;
  children?: React.ReactNode;
  className?: string;
  /** U-032: Chrome 장식 적용 여부 */
  hasChrome?: boolean;
  /** 기본 placeholder i18n 키 (children이 없을 때 사용) */
  placeholderKey?: string;
}

export function Panel({
  title,
  children,
  className = '',
  hasChrome = false,
  placeholderKey,
}: PanelProps) {
  const { t } = useTranslation();
  const panelClass = `panel ${className} ${hasChrome ? 'has-chrome' : ''}`.trim();
  const headerClass = `panel-header ${hasChrome ? 'has-chrome' : ''}`.trim();

  return (
    <div className={panelClass}>
      <div className={headerClass}>
        <span className="panel-title">{title}</span>
      </div>
      <div className="panel-content">
        {children || (
          <p className="panel-placeholder">
            {placeholderKey ? t(placeholderKey) : t('ui.panel_placeholder')}
          </p>
        )}
      </div>
    </div>
  );
}
</file>

<file path="frontend/src/components/ResetButton.tsx">
/**
 * Unknown World - 리셋 버튼 컴포넌트 (U-015[Mvp]).
 *
 * 1회 클릭으로 현재 프로필의 초기 상태로 복구하는 버튼입니다.
 * 데모 반복 가능성을 보장합니다.
 *
 * 설계 원칙:
 *   - PRD 6.9: 즉시 리셋 1회로 데모 반복 가능
 *   - RULE-006: i18n 키 기반 다국어 지원
 *
 * @module components/ResetButton
 */

import { useCallback, useState } from 'react';
import { useTranslation } from 'react-i18next';

// =============================================================================
// 타입 정의
// =============================================================================

export interface ResetButtonProps {
  /** 리셋 클릭 시 호출되는 콜백 */
  onReset: () => void;
  /** 비활성화 여부 */
  disabled?: boolean;
  /** 확인 필요 여부 (기본: true) */
  requireConfirm?: boolean;
  /** 추가 클래스명 */
  className?: string;
  /** 컴팩트 모드 (아이콘만 표시) */
  compact?: boolean;
}

// =============================================================================
// 컴포넌트
// =============================================================================

/**
 * 게임 리셋 버튼.
 * 현재 프로필의 초기 상태로 복구합니다.
 */
export function ResetButton({
  onReset,
  disabled = false,
  requireConfirm = true,
  className = '',
  compact = false,
}: ResetButtonProps) {
  const { t } = useTranslation();
  const [isConfirming, setIsConfirming] = useState(false);

  const handleClick = useCallback(() => {
    if (requireConfirm && !isConfirming) {
      // 확인 모드로 전환
      setIsConfirming(true);
      // 3초 후 자동 취소
      setTimeout(() => setIsConfirming(false), 3000);
      return;
    }

    // 리셋 실행
    onReset();
    setIsConfirming(false);
  }, [onReset, requireConfirm, isConfirming]);

  const handleCancel = useCallback(() => {
    setIsConfirming(false);
  }, []);

  const buttonText = isConfirming ? t('reset.confirm') : compact ? '' : t('reset.button');

  const buttonAriaLabel = isConfirming ? t('reset.confirm') : t('reset.button');

  return (
    <div className={`reset-button-wrapper ${className}`.trim()}>
      <button
        type="button"
        className={`reset-button ${isConfirming ? 'confirming' : ''} ${compact ? 'compact' : ''}`}
        onClick={handleClick}
        disabled={disabled}
        aria-label={buttonAriaLabel}
        title={t('reset.tooltip')}
      >
        <span className="reset-icon" aria-hidden="true">
          🔄
        </span>
        {buttonText && <span className="reset-text">{buttonText}</span>}
      </button>

      {isConfirming && requireConfirm && (
        <button
          type="button"
          className="reset-cancel-button"
          onClick={handleCancel}
          aria-label={t('reset.cancel')}
        >
          ✕
        </button>
      )}
    </div>
  );
}

// =============================================================================
// 프로필 변경 버튼 (별도 컴포넌트)
// =============================================================================

export interface ChangeProfileButtonProps {
  /** 클릭 시 호출되는 콜백 */
  onClick: () => void;
  /** 비활성화 여부 */
  disabled?: boolean;
  /** 추가 클래스명 */
  className?: string;
}

/**
 * 프로필 변경 버튼.
 * 클릭 시 프로필 선택 화면으로 이동합니다.
 */
export function ChangeProfileButton({
  onClick,
  disabled = false,
  className = '',
}: ChangeProfileButtonProps) {
  const { t } = useTranslation();

  return (
    <button
      type="button"
      className={`change-profile-button ${className}`.trim()}
      onClick={onClick}
      disabled={disabled}
      aria-label={t('profile.change')}
      title={t('profile.change_tooltip')}
    >
      <span className="change-profile-icon" aria-hidden="true">
        👤
      </span>
      <span className="change-profile-text">{t('profile.change')}</span>
    </button>
  );
}
</file>

<file path="frontend/src/components/RuleBoard.tsx">
/**
 * Unknown World - Rule Board (U-013)
 *
 * 현재 세계에 적용 중인 규칙/물리 법칙을 "룰 카드"로 표시합니다.
 *
 * 설계 원칙:
 *   - RULE-002: 채팅 UI가 아닌 게임 UI로 상시 노출
 *   - RULE-006: i18n 기반 문자열 관리
 *   - PRD 6.4/6.7: Rule Mutation + Rule Board
 *
 * @module components/RuleBoard
 */

import { useTranslation } from 'react-i18next';
import { useWorldStore, selectActiveRules } from '../stores/worldStore';
import type { WorldRule } from '../schemas/turn';

// =============================================================================
// 하위 컴포넌트
// =============================================================================

interface RuleCardProps {
  rule: WorldRule;
}

/**
 * 개별 룰 카드 렌더링
 */
function RuleCard({ rule }: RuleCardProps) {
  return (
    <div className="rule-card" data-rule-id={rule.id}>
      <div className="rule-card-header">
        <span className="rule-card-icon" aria-hidden="true">
          ⚙
        </span>
        <span className="rule-card-label">{rule.label}</span>
      </div>
      {rule.description && <p className="rule-card-description">{rule.description}</p>}
    </div>
  );
}

// =============================================================================
// 메인 컴포넌트
// =============================================================================

/**
 * Rule Board
 *
 * 현재 세계에 적용 중인 규칙을 카드 형태로 표시합니다.
 * worldStore의 activeRules 상태를 구독하여 실시간 업데이트됩니다.
 */
export function RuleBoard() {
  const { t } = useTranslation();
  const activeRules = useWorldStore(selectActiveRules);

  // 빈 상태
  if (activeRules.length === 0) {
    return (
      <div className="rule-board-content rule-board-empty" data-ui-importance="critical">
        <div className="rule-board-empty-icon" aria-hidden="true">
          📜
        </div>
        <p className="rule-board-empty-text">{t('rule_board.empty')}</p>
      </div>
    );
  }

  return (
    <div className="rule-board-content" data-ui-importance="critical">
      <div className="rule-board-header">
        <span className="rule-board-count">
          {t('rule_board.active_count', { count: activeRules.length })}
        </span>
      </div>
      <div className="rule-card-list">
        {activeRules.map((rule) => (
          <RuleCard key={rule.id} rule={rule} />
        ))}
      </div>
    </div>
  );
}

export default RuleBoard;
</file>

<file path="frontend/src/components/SceneCanvas.test.tsx">
import { describe, it, expect } from 'vitest';
import { SCENE_PLACEHOLDERS } from './SceneImage';

describe('SCENE_PLACEHOLDERS', () => {
  it('should have all required statuses', () => {
    const statuses = ['default', 'loading', 'offline', 'blocked', 'low_signal'];
    statuses.forEach((status) => {
      expect(SCENE_PLACEHOLDERS).toHaveProperty(status);
    });
  });

  it('should have correct image paths', () => {
    expect(SCENE_PLACEHOLDERS.default.imagePath).toBe(
      '/ui/placeholders/scene-placeholder-default.png',
    );
    expect(SCENE_PLACEHOLDERS.loading.imagePath).toBe('/ui/placeholders/scene-loading.webp');
    expect(SCENE_PLACEHOLDERS.offline.imagePath).toBe('/ui/placeholders/scene-offline.webp');
    expect(SCENE_PLACEHOLDERS.blocked.imagePath).toBe('/ui/placeholders/scene-blocked.webp');
    expect(SCENE_PLACEHOLDERS.low_signal.imagePath).toBe('/ui/placeholders/scene-low-signal.webp');
  });

  it('should have correct i18n label keys', () => {
    expect(SCENE_PLACEHOLDERS.default.labelKey).toBe('scene.status.default');
    expect(SCENE_PLACEHOLDERS.loading.labelKey).toBe('scene.status.loading');
    expect(SCENE_PLACEHOLDERS.offline.labelKey).toBe('scene.status.offline');
    expect(SCENE_PLACEHOLDERS.blocked.labelKey).toBe('scene.status.blocked');
    expect(SCENE_PLACEHOLDERS.low_signal.labelKey).toBe('scene.status.low_signal');
  });
});
</file>

<file path="frontend/src/components/UIControls.tsx">
import { useTranslation } from 'react-i18next';
import { UI_SCALES, type UIScale } from '../stores/uiPrefsStore';

interface UIControlsProps {
  uiScale: UIScale;
  onIncreaseScale: () => void;
  onDecreaseScale: () => void;
}

export function UIControls({ uiScale, onIncreaseScale, onDecreaseScale }: UIControlsProps) {
  const { t } = useTranslation();
  const isMinScale = uiScale === UI_SCALES[0];
  const isMaxScale = uiScale === UI_SCALES[UI_SCALES.length - 1];

  return (
    <div className="ui-controls" role="group" aria-label={t('ui.scale_label')}>
      {/* UI 스케일 조절 */}
      <button
        type="button"
        className="ui-scale-btn"
        onClick={onDecreaseScale}
        disabled={isMinScale}
        aria-label={t('ui.scale_decrease')}
        title={`${t('ui.scale_decrease')} (A-)`}
      >
        A-
      </button>
      <span className="ui-scale-display" aria-live="polite">
        {Math.round(uiScale * 100)}%
      </span>
      <button
        type="button"
        className="ui-scale-btn"
        onClick={onIncreaseScale}
        disabled={isMaxScale}
        aria-label={t('ui.scale_increase')}
        title={`${t('ui.scale_increase')} (A+)`}
      >
        A+
      </button>
    </div>
  );
}
</file>

<file path="frontend/src/dnd/types.ts">
/**
 * Unknown World - DnD 타입 및 상수 정의 (RU-003-Q1).
 *
 * DnD 데이터 계약을 SSOT로 관리하여 타입 안전성을 확보합니다.
 * 모든 드래그/드롭 이벤트에서 동일한 상수/타입을 사용합니다.
 *
 * 설계 원칙:
 *   - SSOT: 드래그/드롭 타입 문자열은 이 모듈에서만 정의
 *   - 타입 안전성: dnd-kit의 data.current를 타입 가드로 검증
 *   - 과도한 추상화 금지: 상수/타입만 제공, 로직은 컴포넌트에 유지
 *
 * @module dnd/types
 */

import type { Box2D } from '../schemas/turn';
import type { InventoryItem } from '../stores/inventoryStore';

// =============================================================================
// DnD 타입 상수 (SSOT)
// =============================================================================

/**
 * DnD 타입 상수.
 * 드래그/드롭 데이터의 type 필드에 사용됩니다.
 */
export const DND_TYPE = {
  /** 인벤토리 아이템 드래그 */
  INVENTORY_ITEM: 'inventory-item',
  /** 핫스팟 드롭 타겟 */
  HOTSPOT: 'hotspot',
} as const;

// =============================================================================
// RU-003-S2: 인터랙션 허용 정책 (SSOT)
// =============================================================================

/**
 * 핫스팟 인터랙션이 허용되는 Scene 상태 목록.
 *
 * RU-003-S2 Step 1: Option A(데모 유지) 결정
 * - 'scene': 실제 장면 활성화 상태
 * - 'default': 데모/플레이스홀더 상태 (시각적 힌트 필요)
 *
 * @see SceneCanvas.tsx의 shouldRenderHotspots 조건
 */
export const HOTSPOT_INTERACTION_ALLOWED_STATES = ['scene', 'default'] as const;

/**
 * 인터랙션 허용 상태 타입.
 */
export type HotspotInteractionState = (typeof HOTSPOT_INTERACTION_ALLOWED_STATES)[number];

/**
 * 주어진 상태에서 핫스팟 인터랙션이 허용되는지 검사합니다.
 *
 * RU-003-S2: 인터랙션 가능 조건을 SSOT로 고정
 *
 * @param status - Scene 상태
 * @returns 인터랙션 허용 여부
 */
export function isHotspotInteractionAllowed(status: string): boolean {
  return HOTSPOT_INTERACTION_ALLOWED_STATES.includes(status as HotspotInteractionState);
}

// =============================================================================
// RU-003-S2 Step 4: 스트리밍 비활성화 정책 (SSOT)
// =============================================================================

/**
 * 스트리밍 비활성화 정책.
 *
 * RU-003-S2 Step 4: disabled 플래그의 SSOT 고정
 * - isStreaming은 agentStore에서만 제공
 * - 모든 인터랙션 컴포넌트(SceneCanvas, InventoryPanel, ActionDeck)는
 *   동일한 disabled 플래그를 공유해야 함
 * - 향후 worldStore/Turn Runner 도입 시에도 이 원칙을 유지
 *
 * @see App.tsx의 isStreaming 사용 패턴
 * @see agentStore.ts의 isStreaming 상태
 */
export const STREAMING_DISABLED_POLICY = {
  /** 스트리밍 상태 SSOT 출처 */
  source: 'agentStore.isStreaming',
  /** 비활성화 적용 대상 컴포넌트 */
  affectedComponents: ['SceneCanvas', 'InventoryPanel', 'ActionDeck', 'CommandInput'],
} as const;

/**
 * DnD 타입 유니온.
 */
export type DndType = (typeof DND_TYPE)[keyof typeof DND_TYPE];

// =============================================================================
// 드래그 데이터 타입
// =============================================================================

/**
 * 인벤토리 아이템 드래그 데이터.
 * InventoryPanel에서 드래그 시작 시 설정됩니다.
 */
export interface InventoryDragData {
  /** 드래그 타입 (항상 'inventory-item') */
  type: typeof DND_TYPE.INVENTORY_ITEM;
  /** 드래그 중인 아이템 ID */
  item_id: string;
  /** 드래그 중인 아이템 객체 */
  item: InventoryItem;
}

// =============================================================================
// 드롭 데이터 타입
// =============================================================================

/**
 * 핫스팟 드롭 타겟 데이터.
 * SceneCanvas의 핫스팟에서 설정됩니다.
 */
export interface HotspotDropData {
  /** 드롭 타겟 타입 (항상 'hotspot') */
  type: typeof DND_TYPE.HOTSPOT;
  /** 핫스팟 오브젝트 ID */
  object_id: string;
  /** 핫스팟 바운딩 박스 (0~1000 정규화) */
  box_2d: Box2D;
  /** 핫스팟 라벨 (표시용) */
  label: string;
}

// =============================================================================
// 타입 가드 함수
// =============================================================================

/**
 * 데이터가 InventoryDragData인지 검사합니다.
 *
 * @param data - dnd-kit의 active.data.current
 * @returns InventoryDragData이면 true
 */
export function isInventoryDragData(data: unknown): data is InventoryDragData {
  if (typeof data !== 'object' || data === null) {
    return false;
  }
  const obj = data as Record<string, unknown>;
  return (
    obj.type === DND_TYPE.INVENTORY_ITEM &&
    typeof obj.item_id === 'string' &&
    typeof obj.item === 'object' &&
    obj.item !== null
  );
}

/**
 * 데이터가 HotspotDropData인지 검사합니다.
 *
 * @param data - dnd-kit의 over.data.current
 * @returns HotspotDropData이면 true
 */
export function isHotspotDropData(data: unknown): data is HotspotDropData {
  if (typeof data !== 'object' || data === null) {
    return false;
  }
  const obj = data as Record<string, unknown>;
  return (
    obj.type === DND_TYPE.HOTSPOT &&
    typeof obj.object_id === 'string' &&
    typeof obj.box_2d === 'object' &&
    obj.box_2d !== null &&
    typeof obj.label === 'string'
  );
}

// =============================================================================
// RU-003-S2 Step 2: 핫스팟 우선순위 정책 (SSOT)
// =============================================================================

/**
 * 바운딩 박스의 면적을 계산합니다.
 *
 * @param box - { ymin, xmin, ymax, xmax } 형식의 바운딩 박스
 * @returns 박스 면적
 */
export function calculateBoxArea(box: Box2D): number {
  const { ymin, xmin, ymax, xmax } = box;
  return Math.abs(ymax - ymin) * Math.abs(xmax - xmin);
}

/**
 * 핫스팟 우선순위 계산을 위한 비교 함수.
 *
 * RU-003-S2 Step 2: 작은 bbox가 더 높은 우선순위를 가짐
 * - 더 작은 오브젝트가 더 구체적인 타겟이라고 가정
 * - z-index 관점에서 작은 것이 위에 렌더되어야 함
 *
 * @param a - 첫 번째 바운딩 박스
 * @param b - 두 번째 바운딩 박스
 * @returns 정렬 순서 (작은 것이 뒤로 가서 z-index가 높아짐)
 */
export function compareHotspotPriority(a: Box2D, b: Box2D): number {
  return calculateBoxArea(b) - calculateBoxArea(a);
}
</file>

<file path="frontend/src/main.tsx">
import { StrictMode } from 'react';
import { createRoot } from 'react-dom/client';
import './i18n'; // i18n 초기화
import './style.css';
import App from './App.tsx';

createRoot(document.getElementById('root')!).render(
  <StrictMode>
    <App />
  </StrictMode>,
);
</file>

<file path="frontend/src/schemas/turn.test.ts">
import { describe, it, expect } from 'vitest';
import {
  TurnInputSchema,
  TurnOutputSchema,
  safeParseTurnOutput,
  parseTurnInput,
  safeParseTurnInput,
  SCHEMA_VERSION,
} from './turn';

describe('Turn schemas', () => {
  describe('SCHEMA_VERSION', () => {
    it('should have correct version', () => {
      expect(SCHEMA_VERSION).toBe('1.0.0');
    });
  });

  describe('TurnInputSchema', () => {
    const validTurnInput = {
      language: 'ko-KR',
      text: '테스트 입력',
      client: {
        viewport_w: 1920,
        viewport_h: 1080,
        theme: 'dark',
      },
      economy_snapshot: {
        signal: 100,
        memory_shard: 5,
      },
    };

    it('should validate a valid TurnInput', () => {
      const result = TurnInputSchema.safeParse(validTurnInput);
      expect(result.success).toBe(true);
    });

    it('should fail on invalid language', () => {
      const result = TurnInputSchema.safeParse({
        ...validTurnInput,
        language: 'fr-FR',
      });
      expect(result.success).toBe(false);
    });

    it('should fail on negative economy values', () => {
      const result = TurnInputSchema.safeParse({
        ...validTurnInput,
        economy_snapshot: {
          signal: -1,
          memory_shard: 0,
        },
      });
      expect(result.success).toBe(false);
    });

    it('should fail on extra fields (strict)', () => {
      const result = TurnInputSchema.safeParse({
        ...validTurnInput,
        extra_field: 'not allowed',
      });
      expect(result.success).toBe(false);
    });

    it('should validate click input with bbox', () => {
      const result = TurnInputSchema.safeParse({
        ...validTurnInput,
        click: {
          object_id: 'door_01',
          box_2d: {
            ymin: 100,
            xmin: 100,
            ymax: 500,
            xmax: 500,
          },
        },
      });
      expect(result.success).toBe(true);
    });

    it('should fail on invalid bbox coordinates (out of range 0-1000)', () => {
      const result = TurnInputSchema.safeParse({
        ...validTurnInput,
        click: {
          object_id: 'door_01',
          box_2d: {
            ymin: -1,
            xmin: 0,
            ymax: 1001,
            xmax: 500,
          },
        },
      });
      expect(result.success).toBe(false);
    });

    it('should fail on non-positive viewport dimensions', () => {
      const result = TurnInputSchema.safeParse({
        ...validTurnInput,
        client: {
          viewport_w: 0,
          viewport_h: -100,
          theme: 'dark',
        },
      });
      expect(result.success).toBe(false);
    });

    it('should fail on non-integer coordinates', () => {
      const result = TurnInputSchema.safeParse({
        ...validTurnInput,
        click: {
          object_id: 'obj',
          box_2d: {
            ymin: 10.5,
            xmin: 20,
            ymax: 30,
            xmax: 40,
          },
        },
      });
      expect(result.success).toBe(false);
    });
  });

  describe('TurnOutputSchema', () => {
    const validTurnOutput = {
      language: 'ko-KR',
      narrative: '테스트 내러티브',
      economy: {
        cost: { signal: 5, memory_shard: 0 },
        balance_after: { signal: 95, memory_shard: 5 },
      },
      safety: {
        blocked: false,
      },
      agent_console: {
        current_phase: 'commit',
        badges: ['schema_ok', 'economy_ok'],
        repair_count: 0,
      },
    };

    it('should validate a valid TurnOutput', () => {
      const result = TurnOutputSchema.safeParse(validTurnOutput);
      expect(result.success).toBe(true);
    });

    it('should fail if required fields are missing', () => {
      const { narrative: _narrative, ...invalidOutput } = validTurnOutput;
      const result = TurnOutputSchema.safeParse(invalidOutput);
      expect(result.success).toBe(false);
    });

    it('should handle default values for optional fields', () => {
      const result = TurnOutputSchema.safeParse(validTurnOutput);
      if (result.success) {
        expect(result.data.ui).toBeDefined();
        expect(result.data.ui.action_deck.cards).toEqual([]);
        expect(result.data.world.rules_changed).toEqual([]);
      } else {
        throw new Error('Validation failed');
      }
    });

    it('should fail if there are too many action cards (max 10)', () => {
      const cards = Array.from({ length: 11 }, (_, i) => ({
        id: `card_${i}`,
        label: `Card ${i}`,
        cost: { signal: 0, memory_shard: 0 },
        risk: 'low',
      }));
      const result = TurnOutputSchema.safeParse({
        ...validTurnOutput,
        ui: {
          action_deck: { cards },
        },
      });
      expect(result.success).toBe(false);
    });

    it('should fail on negative repair_count', () => {
      const result = TurnOutputSchema.safeParse({
        ...validTurnOutput,
        agent_console: {
          current_phase: 'commit',
          badges: [],
          repair_count: -1,
        },
      });
      expect(result.success).toBe(false);
    });
  });

  describe('safeParseTurnOutput', () => {
    it('should return success for valid data', () => {
      const validTurnOutput = {
        language: 'en-US',
        narrative: 'Test narrative',
        economy: {
          cost: { signal: 0, memory_shard: 0 },
          balance_after: { signal: 100, memory_shard: 0 },
        },
        safety: { blocked: false },
      };
      const result = safeParseTurnOutput(validTurnOutput);
      expect(result.success).toBe(true);
      if (result.success) {
        expect(result.data.language).toBe('en-US');
      }
    });

    it('should return fallback for invalid data', () => {
      const invalidData = { some: 'garbage' };
      const result = safeParseTurnOutput(invalidData, 'ko-KR', 1);
      expect(result.success).toBe(false);
      if (!result.success) {
        expect(result.fallback).toBeDefined();
        expect(result.fallback.language).toBe('ko-KR');
        expect(result.fallback.agent_console.badges).toContain('schema_fail');
        expect(result.fallback.agent_console.repair_count).toBe(1);
      }
    });
  });

  describe('Input Parsing Utilities', () => {
    const validTurnInput = {
      language: 'ko-KR',
      text: '테스트 입력',
      client: {
        viewport_w: 1920,
        viewport_h: 1080,
        theme: 'dark',
      },
      economy_snapshot: {
        signal: 100,
        memory_shard: 5,
      },
    };

    describe('parseTurnInput', () => {
      it('should parse valid input', () => {
        const result = parseTurnInput(validTurnInput);
        expect(result.text).toBe('테스트 입력');
      });

      it('should throw error for invalid input', () => {
        expect(() => parseTurnInput({})).toThrow();
      });
    });

    describe('safeParseTurnInput', () => {
      it('should return success for valid input', () => {
        const result = safeParseTurnInput(validTurnInput);
        expect(result.success).toBe(true);
      });

      it('should return failure for invalid input', () => {
        const result = safeParseTurnInput({});
        expect(result.success).toBe(false);
      });
    });
  });
});
</file>

<file path="frontend/src/schemas/verify_runbook.ts">
import {
  TurnOutputSchema,
  safeParseTurnOutput,
  Box2DSchema,
  CurrencyAmountSchema,
  LanguageSchema,
  parseTurnInput,
} from './turn.js';

console.log('--- Scenario A: TurnOutput 스키마 검증 (정상 케이스) ---');
const validOutput = {
  language: 'ko-KR',
  narrative: '문이 삐걱거리며 열립니다...',
  economy: {
    cost: { signal: 5, memory_shard: 0 },
    balance_after: { signal: 95, memory_shard: 5 },
  },
  safety: { blocked: false, message: null },
};
const resultA = safeParseTurnOutput(validOutput);
console.log('Success:', resultA.success);
if (resultA.success) {
  console.log('Data (sample):', resultA.data.narrative);
}

console.log('\n--- Scenario B: TurnOutput 스키마 검증 실패 → 폴백 ---');
const invalidOutput = {
  language: 'ko-KR',
  narrative: '테스트',
};
// eslint-disable-next-line @typescript-eslint/no-explicit-any
const resultB = safeParseTurnOutput(invalidOutput as any);
console.log('Success:', resultB.success);
if (!resultB.success) {
  console.log('Error count:', resultB.error.issues.length);
  console.log('Fallback exists:', !!resultB.fallback);
  console.log(
    'Fallback badges has schema_fail:',
    resultB.fallback?.agent_console?.badges?.includes('schema_fail'),
  );
}

console.log('\n--- Scenario C: 좌표 범위 검증 (RULE-009) ---');
const validBox = { ymin: 100, xmin: 200, ymax: 300, xmax: 400 };
console.log('Valid box:', Box2DSchema.safeParse(validBox).success);
const invalidBox = { ymin: 100, xmin: 200, ymax: 1500, xmax: 400 };
console.log('Invalid box (1500):', Box2DSchema.safeParse(invalidBox).success);
const negativeBox = { ymin: -10, xmin: 200, ymax: 300, xmax: 400 };
console.log('Negative box:', Box2DSchema.safeParse(negativeBox).success);

console.log('\n--- Scenario D: 재화 인바리언트 검증 (RULE-005) ---');
const validCurrency = { signal: 100, memory_shard: 5 };
console.log('Valid currency:', CurrencyAmountSchema.safeParse(validCurrency).success);
const negativeCurrency = { signal: -10, memory_shard: 5 };
console.log('Negative signal:', CurrencyAmountSchema.safeParse(negativeCurrency).success);

console.log('\n--- Scenario E: 언어 정책 검증 (RULE-006) ---');
console.log('ko-KR:', LanguageSchema.safeParse('ko-KR').success);
console.log('en-US:', LanguageSchema.safeParse('en-US').success);
console.log('ja-JP (invalid):', LanguageSchema.safeParse('ja-JP').success);
console.log('ko (invalid format):', LanguageSchema.safeParse('ko').success);

console.log('\n--- Scenario F: TurnInput 검증 ---');
const validInput = {
  language: 'ko-KR',
  text: '문을 열어본다',
  client: {
    viewport_w: 1920,
    viewport_h: 1080,
    theme: 'dark',
  },
  economy_snapshot: {
    signal: 100,
    memory_shard: 5,
  },
};
try {
  // eslint-disable-next-line @typescript-eslint/no-explicit-any
  const parsed = parseTurnInput(validInput as any);
  console.log('Parsed successfully:', parsed.text);
} catch (e) {
  console.log('Parse error:', e);
}

console.log('\n--- Scenario G: Strict 모드 검증 ---');
const outputWithExtra = {
  language: 'ko-KR',
  narrative: '테스트',
  economy: {
    cost: { signal: 0, memory_shard: 0 },
    balance_after: { signal: 100, memory_shard: 5 },
  },
  safety: { blocked: false, message: null },
  unknown_field: '이 필드는 스키마에 없음',
};
const resultG = TurnOutputSchema.safeParse(outputWithExtra);
console.log('With extra field success:', resultG.success);
if (!resultG.success) {
  console.log('Error code:', resultG.error.issues[0].code);
}
</file>

<file path="frontend/src/stores/uiPrefsStore.test.ts">
import { describe, it, expect, beforeEach } from 'vitest';
import { useUIPrefsStore, DEFAULT_UI_SCALE, migrateUIPrefs } from './uiPrefsStore';

// Mock localStorage for non-browser environment
// Note: With jsdom environment configured in vite.config.ts, this might not be strictly necessary
// if we trust jsdom's localStorage, but keeping it explicit is fine.
// However, since we are moving to direct function testing for migration, we rely less on persist middleware internals.

describe('uiPrefsStore', () => {
  beforeEach(() => {
    useUIPrefsStore.getState().resetPrefs();
    localStorage.clear();
  });

  it('should have default initial state', () => {
    const state = useUIPrefsStore.getState();
    expect(state.uiScale).toBe(DEFAULT_UI_SCALE);
  });

  it('should increase ui scale within limit', () => {
    const { increaseUIScale } = useUIPrefsStore.getState();

    // 1.0 -> 1.1
    increaseUIScale();
    expect(useUIPrefsStore.getState().uiScale).toBe(1.1);

    // 1.1 -> 1.2
    increaseUIScale();
    expect(useUIPrefsStore.getState().uiScale).toBe(1.2);

    // 1.2 -> 1.2 (Max)
    increaseUIScale();
    expect(useUIPrefsStore.getState().uiScale).toBe(1.2);
  });

  it('should decrease ui scale within limit', () => {
    const { decreaseUIScale, setUIScale } = useUIPrefsStore.getState();

    // Start at max
    setUIScale(1.2);

    // 1.2 -> 1.1
    decreaseUIScale();
    expect(useUIPrefsStore.getState().uiScale).toBe(1.1);

    // ... -> 0.9 (Min)
    setUIScale(0.9);
    decreaseUIScale();
    expect(useUIPrefsStore.getState().uiScale).toBe(0.9);
  });

  it('should set valid ui scale', () => {
    const { setUIScale } = useUIPrefsStore.getState();

    setUIScale(1.1);
    expect(useUIPrefsStore.getState().uiScale).toBe(1.1);
  });

  it('should ignore invalid ui scale', () => {
    const { setUIScale } = useUIPrefsStore.getState();

    // @ts-expect-error Testing invalid input
    setUIScale(2.0);
    expect(useUIPrefsStore.getState().uiScale).toBe(DEFAULT_UI_SCALE);
  });

  describe('migration (U-037)', () => {
    it('should remove readableMode from legacy storage', () => {
      // Legacy state simulation
      const legacyState = {
        uiScale: 1.1,
        readableMode: true,
      };

      // Call migrate function directly
      const migratedState = migrateUIPrefs(legacyState, 0);

      // Verify
      expect(migratedState).toHaveProperty('uiScale', 1.1);
      expect(migratedState).not.toHaveProperty('readableMode');
    });

    it('should handle undefined version (very old legacy)', () => {
      const legacyState = {
        uiScale: 0.9,
        readableMode: false,
      };

      // Call migrate function directly with undefined version
      const migratedState = migrateUIPrefs(legacyState, undefined);

      expect(migratedState).toHaveProperty('uiScale', 0.9);
      expect(migratedState).not.toHaveProperty('readableMode');
    });

    it('should pass through already migrated state', () => {
      const modernState = {
        uiScale: 1.0,
      };

      const migratedState = migrateUIPrefs(modernState, 1);
      expect(migratedState).toEqual(modernState);
    });
  });
});
</file>

<file path="frontend/src/types/turn_stream.ts">
/**
 * Unknown World - Turn Stream 이벤트 계약(Contract).
 *
 * NDJSON 스트리밍에서 사용되는 이벤트 타입, 인터페이스를 정의합니다.
 * 이 모듈은 백엔드와 프론트엔드 간의 스트림 이벤트 계약 SSOT입니다.
 *
 * 설계 원칙:
 *   - RU-002-Q4: 이벤트 계약을 transport 계층으로 분리
 *   - RU-002-S2: 이벤트별 Zod 검증 + Unknown/확장 이벤트 폴백
 *   - RULE-003: 구조화 출력(JSON Schema) 우선 + 이중 검증
 *   - RULE-008: 단계/배지 가시화
 *
 * 참조:
 *   - vibe/unit-plans/U-007[Mvp].md
 *   - vibe/refactors/RU-002-Q4.md
 *   - vibe/refactors/RU-002-S2.md
 *
 * @module types/turn_stream
 */

import { z } from 'zod';
import {
  AgentPhaseSchema,
  ValidationBadgeSchema,
  type TurnOutput,
  type AgentPhase,
  type ValidationBadge,
} from '../schemas/turn';

// =============================================================================
// 스트림 이벤트 타입 상수 (서버 계약과 일치)
// =============================================================================

/** 스트림 이벤트 타입 상수 */
export const StreamEventType = {
  STAGE: 'stage',
  BADGES: 'badges',
  NARRATIVE_DELTA: 'narrative_delta',
  FINAL: 'final',
  ERROR: 'error',
  REPAIR: 'repair',
} as const;

export type StreamEventTypeName = (typeof StreamEventType)[keyof typeof StreamEventType];

/**
 * 단계 상태 상수.
 * RU-002-S2/RU-002-Q2: v1(complete) 및 v2(ok/fail) 별칭 모두 지원.
 */
export const StageStatus = {
  START: 'start',
  COMPLETE: 'complete',
  /** 단계 실패 */
  FAIL: 'fail',
} as const;

export type StageStatusName = (typeof StageStatus)[keyof typeof StageStatus];

// =============================================================================
// RU-002-S2: 이벤트별 Zod 스키마 (경량 검증 + 폴백)
// =============================================================================

/**
 * stage.status 스키마.
 * v1(complete) 및 v2(ok/fail) 별칭 모두 허용.
 */
export const StageStatusSchema = z.enum(['start', 'complete', 'ok', 'fail']);

/**
 * StageEvent Zod 스키마.
 * 단계 진행 이벤트 검증용.
 */
export const StageEventSchema = z.object({
  type: z.literal(StreamEventType.STAGE),
  name: AgentPhaseSchema,
  status: StageStatusSchema,
});

/**
 * RepairEvent Zod 스키마.
 * 자동 복구 시도 이벤트 검증용.
 */
export const RepairEventSchema = z.object({
  type: z.literal(StreamEventType.REPAIR),
  attempt: z.number(),
  message: z.string().optional(),
});

/**
 * BadgesEvent Zod 스키마 (v1: 배열).
 * v1은 badges: string[] 형식.
 */
export const BadgesEventSchemaV1 = z.object({
  type: z.literal(StreamEventType.BADGES),
  badges: z.array(ValidationBadgeSchema),
});

/**
 * BadgesEvent Zod 스키마 (v2: 객체/맵).
 * 향후 v2는 badges: { [key]: status } 형식을 지원할 수 있음.
 * 현재는 v1만 사용하므로 이 스키마는 확장성을 위해 정의.
 */
export const BadgesEventSchemaV2 = z.object({
  type: z.literal(StreamEventType.BADGES),
  badges: z.record(z.string(), z.boolean()),
});

/**
 * BadgesEvent 통합 스키마.
 * v1(배열) 또는 v2(객체) 모두 허용.
 */
export const BadgesEventSchema = z.union([BadgesEventSchemaV1, BadgesEventSchemaV2]);

/**
 * NarrativeDeltaEvent Zod 스키마.
 * 타자 효과용 내러티브 델타 이벤트 검증용.
 */
export const NarrativeDeltaEventSchema = z.object({
  type: z.literal(StreamEventType.NARRATIVE_DELTA),
  text: z.string(),
});

/**
 * FinalEvent 원시 스키마.
 * v1(data) 및 v2(turn_output) 별칭 모두 허용.
 * TurnOutput 자체 검증은 turnStream.ts에서 safeParseTurnOutput으로 수행.
 */
export const FinalEventRawSchema = z.object({
  type: z.literal(StreamEventType.FINAL),
  data: z.unknown(),
});

/**
 * ErrorEvent Zod 스키마.
 * 에러 이벤트 검증용.
 */
export const ErrorEventSchema = z.object({
  type: z.literal(StreamEventType.ERROR),
  message: z.string(),
  code: z.string().optional(),
});

/**
 * 이벤트 타입 추출용 최소 스키마.
 * Unknown 이벤트 판별에 사용.
 */
export const BaseEventSchema = z.object({
  type: z.string(),
});

// =============================================================================
// 이벤트 파싱 유틸리티 (RU-002-S2)
// =============================================================================

/** 이벤트 검증 결과 타입 */
export type EventParseResult<T> =
  | { success: true; data: T }
  | { success: false; error: z.ZodError };

/**
 * StageEvent를 안전하게 파싱합니다.
 */
export function safeParseStageEvent(
  data: unknown,
): EventParseResult<z.infer<typeof StageEventSchema>> {
  const result = StageEventSchema.safeParse(data);
  return result.success
    ? { success: true, data: result.data }
    : { success: false, error: result.error };
}

/**
 * RepairEvent를 안전하게 파싱합니다.
 */
export function safeParseRepairEvent(
  data: unknown,
): EventParseResult<z.infer<typeof RepairEventSchema>> {
  const result = RepairEventSchema.safeParse(data);
  return result.success
    ? { success: true, data: result.data }
    : { success: false, error: result.error };
}

/**
 * BadgesEvent를 안전하게 파싱합니다.
 * v1(배열) 형태로 정규화하여 반환합니다.
 */
export function safeParseBadgesEvent(data: unknown): EventParseResult<BadgesEvent> {
  const result = BadgesEventSchema.safeParse(data);
  if (!result.success) {
    return { success: false, error: result.error };
  }

  // v2(객체) 형태인 경우 v1(배열)로 정규화
  const parsed = result.data;
  if (Array.isArray(parsed.badges)) {
    // v1 형태: 그대로 반환
    return {
      success: true,
      data: { type: StreamEventType.BADGES, badges: parsed.badges as ValidationBadge[] },
    };
  } else {
    // v2 형태: true인 키만 추출하여 배열로 변환
    const badgeArray = Object.entries(parsed.badges)
      .filter(([, value]) => value)
      .map(([key]) => key as ValidationBadge);
    return {
      success: true,
      data: { type: StreamEventType.BADGES, badges: badgeArray },
    };
  }
}

/**
 * NarrativeDeltaEvent를 안전하게 파싱합니다.
 */
export function safeParseNarrativeDeltaEvent(
  data: unknown,
): EventParseResult<z.infer<typeof NarrativeDeltaEventSchema>> {
  const result = NarrativeDeltaEventSchema.safeParse(data);
  return result.success
    ? { success: true, data: result.data }
    : { success: false, error: result.error };
}

/**
 * FinalEvent 원시 형태를 안전하게 파싱합니다.
 * TurnOutput 자체 검증은 별도로 수행해야 합니다.
 */
export function safeParseFinalEventRaw(
  data: unknown,
): EventParseResult<z.infer<typeof FinalEventRawSchema>> {
  const result = FinalEventRawSchema.safeParse(data);
  return result.success
    ? { success: true, data: result.data }
    : { success: false, error: result.error };
}

/**
 * ErrorEvent를 안전하게 파싱합니다.
 */
export function safeParseErrorEvent(
  data: unknown,
): EventParseResult<z.infer<typeof ErrorEventSchema>> {
  const result = ErrorEventSchema.safeParse(data);
  return result.success
    ? { success: true, data: result.data }
    : { success: false, error: result.error };
}

/**
 * stage.status 정규화 헬퍼.
 * 'ok'를 'complete'로, 'fail'은 그대로 유지.
 */
export function normalizeStageStatus(status: string): 'start' | 'complete' | 'fail' {
  if (status === 'ok') return 'complete';
  if (status === 'fail') return 'fail';
  if (status === 'start') return 'start';
  return 'complete';
}

// =============================================================================
// 스트림 이벤트 인터페이스
// =============================================================================

/**
 * 단계 진행 이벤트.
 * RU-002-S2: status에 'fail' 추가하여 단계 실패 표현 지원.
 */
export interface StageEvent {
  type: typeof StreamEventType.STAGE;
  name: AgentPhase;
  /** 'start' | 'complete' | 'ok' | 'fail'. ok는 complete로 정규화됨. */
  status: StageStatusName;
}

/** 자동 복구(Repair) 이벤트 */
export interface RepairEvent {
  type: typeof StreamEventType.REPAIR;
  attempt: number;
  message?: string;
}

/** 배지 이벤트 */
export interface BadgesEvent {
  type: typeof StreamEventType.BADGES;
  badges: ValidationBadge[];
}

/** 내러티브 델타 이벤트 (타자 효과용) */
export interface NarrativeDeltaEvent {
  type: typeof StreamEventType.NARRATIVE_DELTA;
  text: string;
}

/** 최종 TurnOutput 이벤트
 *
 * RU-002-Q2: v1은 `data`, v2는 `turn_output` 사용.
 * 하위호환을 위해 두 필드 모두 선언하되, 정규화된 인터페이스는 `data`를 사용.
 */
export interface FinalEvent {
  type: typeof StreamEventType.FINAL;
  /** v1 현행 계약: TurnOutput 페이로드 */
  data: TurnOutput;
}

/** FinalEvent 원시 수신 형태 */
export interface FinalEventRaw {
  type: typeof StreamEventType.FINAL;
  /** TurnOutput 페이로드 */
  data: TurnOutput;
}

/** 에러 이벤트 */
export interface ErrorEvent {
  type: typeof StreamEventType.ERROR;
  message: string;
  code?: string;
}

/** 스트림 이벤트 유니온 타입 */
export type StreamEvent =
  | StageEvent
  | RepairEvent
  | BadgesEvent
  | NarrativeDeltaEvent
  | FinalEvent
  | ErrorEvent;

// =============================================================================
// 스트림 콜백 인터페이스
// =============================================================================

/** 스트림 이벤트 콜백 */
export interface StreamCallbacks {
  /** 단계 진행 이벤트 */
  onStage?: (event: StageEvent) => void;
  /** 자동 복구 이벤트 */
  onRepair?: (event: RepairEvent) => void;
  /** 배지 이벤트 */
  onBadges?: (event: BadgesEvent) => void;
  /** 내러티브 델타 이벤트 */
  onNarrativeDelta?: (event: NarrativeDeltaEvent) => void;
  /** 최종 TurnOutput 이벤트 */
  onFinal?: (event: FinalEvent) => void;
  /** 에러 이벤트 */
  onError?: (event: ErrorEvent) => void;
  /** 스트림 완료 */
  onComplete?: () => void;
}
</file>

<file path="frontend/src/utils/box2d.test.ts">
import { describe, it, expect } from 'vitest';
import {
  box2dToPixel,
  pixelToBox2d,
  isValidBox2D,
  box2dArea,
  box2dCenter,
  NORMALIZED_MAX,
} from './box2d';
import type { Box2D } from '../schemas/turn';

describe('box2d utils', () => {
  const canvas = { width: 800, height: 600 };

  describe('box2dToPixel', () => {
    it('should correctly convert normalized coordinates to pixels', () => {
      const normalized: Box2D = { ymin: 100, xmin: 200, ymax: 500, xmax: 800 };
      const pixel = box2dToPixel(normalized, canvas);

      // top = 100 * (600 / 1000) = 60
      // left = 200 * (800 / 1000) = 160
      // bottom = 500 * (600 / 1000) = 300
      // right = 800 * (800 / 1000) = 640
      // width = 640 - 160 = 480
      // height = 300 - 60 = 240

      expect(pixel).toEqual({
        top: 60,
        left: 160,
        width: 480,
        height: 240,
      });
    });

    it('should handle full canvas size', () => {
      const normalized: Box2D = { ymin: 0, xmin: 0, ymax: 1000, xmax: 1000 };
      const pixel = box2dToPixel(normalized, canvas);

      expect(pixel).toEqual({
        top: 0,
        left: 0,
        width: 800,
        height: 600,
      });
    });
  });

  describe('pixelToBox2d', () => {
    it('should correctly convert pixels back to normalized coordinates', () => {
      const pixel = { top: 60, left: 160, width: 480, height: 240 };
      const normalized = pixelToBox2d(pixel, canvas);

      expect(normalized).toEqual({
        ymin: 100,
        xmin: 200,
        ymax: 500,
        xmax: 800,
      });
    });

    it('should round and clamp values', () => {
      const pixel = { top: -10, left: -20, width: 900, height: 700 };
      const normalized = pixelToBox2d(pixel, canvas);

      expect(normalized.ymin).toBe(0);
      expect(normalized.xmin).toBe(0);
      expect(normalized.ymax).toBe(NORMALIZED_MAX);
      expect(normalized.xmax).toBe(NORMALIZED_MAX);
    });
  });

  describe('isValidBox2D', () => {
    it('should return true for valid boxes', () => {
      expect(isValidBox2D({ ymin: 100, xmin: 100, ymax: 200, xmax: 200 })).toBe(true);
      expect(isValidBox2D({ ymin: 0, xmin: 0, ymax: 1000, xmax: 1000 })).toBe(true);
    });

    it('should return false for out of range values', () => {
      expect(isValidBox2D({ ymin: -1, xmin: 0, ymax: 100, xmax: 100 })).toBe(false);
      expect(isValidBox2D({ ymin: 0, xmin: 0, ymax: 1001, xmax: 100 })).toBe(false);
    });

    it('should return false for invalid order', () => {
      expect(isValidBox2D({ ymin: 500, xmin: 100, ymax: 400, xmax: 200 })).toBe(false);
      expect(isValidBox2D({ ymin: 100, xmin: 500, ymax: 200, xmax: 400 })).toBe(false);
    });
  });

  describe('box2dArea', () => {
    it('should calculate area correctly', () => {
      const box = { ymin: 100, xmin: 100, ymax: 200, xmax: 300 };
      expect(box2dArea(box)).toBe(20000); // (200-100) * (300-100) = 100 * 200
    });
  });

  describe('box2dCenter', () => {
    it('should calculate center correctly', () => {
      const box = { ymin: 100, xmin: 100, ymax: 300, xmax: 500 };
      expect(box2dCenter(box)).toEqual({ x: 300, y: 200 });
    });
  });
});
</file>

<file path="frontend/src/utils/box2d.ts">
/**
 * Unknown World - Box2D 좌표 변환 유틸리티
 *
 * RULE-009 준수: 좌표 규약 (0~1000 정규화, bbox=[ymin,xmin,ymax,xmax])
 * - 서버/세이브에는 항상 box_2d(0~1000)를 유지
 * - 렌더에서만 viewport 크기(canvasW/H)에 맞춰 px로 변환
 *
 * @module utils/box2d
 */

import type { Box2D } from '../schemas/turn';

// =============================================================================
// 상수 정의
// =============================================================================

/**
 * 정규화 좌표계 최댓값 (0~1000).
 * RULE-009: 좌표 규약
 */
export const NORMALIZED_MAX = 1000;

// =============================================================================
// 타입 정의
// =============================================================================

/**
 * 픽셀 단위 바운딩 박스.
 * 렌더링용으로만 사용됩니다.
 */
export interface Box2DPixel {
  /** Y 최소값 (상단, 픽셀) */
  top: number;
  /** X 최소값 (좌측, 픽셀) */
  left: number;
  /** 너비 (픽셀) */
  width: number;
  /** 높이 (픽셀) */
  height: number;
}

/**
 * 캔버스 크기 정보.
 */
export interface CanvasSize {
  /** 캔버스 너비 (픽셀) */
  width: number;
  /** 캔버스 높이 (픽셀) */
  height: number;
}

// =============================================================================
// 변환 함수
// =============================================================================

/**
 * 정규화 좌표(0~1000)를 픽셀 좌표로 변환합니다.
 *
 * RULE-009: bbox 순서는 [ymin, xmin, ymax, xmax]
 *
 * @param box - 정규화 좌표 바운딩 박스
 * @param canvas - 캔버스 크기
 * @returns 픽셀 단위 바운딩 박스
 *
 * @example
 * ```ts
 * const normalized: Box2D = { ymin: 100, xmin: 200, ymax: 500, xmax: 800 };
 * const canvas = { width: 800, height: 600 };
 * const pixel = box2dToPixel(normalized, canvas);
 * // pixel = { top: 60, left: 160, width: 480, height: 240 }
 * ```
 */
export function box2dToPixel(box: Box2D, canvas: CanvasSize): Box2DPixel {
  const scaleX = canvas.width / NORMALIZED_MAX;
  const scaleY = canvas.height / NORMALIZED_MAX;

  const top = box.ymin * scaleY;
  const left = box.xmin * scaleX;
  const bottom = box.ymax * scaleY;
  const right = box.xmax * scaleX;

  return {
    top,
    left,
    width: right - left,
    height: bottom - top,
  };
}

/**
 * 픽셀 좌표를 정규화 좌표(0~1000)로 변환합니다.
 *
 * 역변환이 필요한 경우 사용합니다 (예: 클릭 위치 → 정규화 좌표).
 *
 * @param pixel - 픽셀 단위 바운딩 박스
 * @param canvas - 캔버스 크기
 * @returns 정규화 좌표 바운딩 박스
 */
export function pixelToBox2d(pixel: Box2DPixel, canvas: CanvasSize): Box2D {
  const scaleX = NORMALIZED_MAX / canvas.width;
  const scaleY = NORMALIZED_MAX / canvas.height;

  const ymin = Math.round(pixel.top * scaleY);
  const xmin = Math.round(pixel.left * scaleX);
  const ymax = Math.round((pixel.top + pixel.height) * scaleY);
  const xmax = Math.round((pixel.left + pixel.width) * scaleX);

  // RULE-009: 0~1000 범위 보장
  return {
    ymin: Math.max(0, Math.min(NORMALIZED_MAX, ymin)),
    xmin: Math.max(0, Math.min(NORMALIZED_MAX, xmin)),
    ymax: Math.max(0, Math.min(NORMALIZED_MAX, ymax)),
    xmax: Math.max(0, Math.min(NORMALIZED_MAX, xmax)),
  };
}

/**
 * Box2D가 유효한지 검증합니다.
 *
 * @param box - 검증할 바운딩 박스
 * @returns 유효 여부
 */
export function isValidBox2D(box: Box2D): boolean {
  // 0~1000 범위 체크
  if (
    box.ymin < 0 ||
    box.ymin > NORMALIZED_MAX ||
    box.xmin < 0 ||
    box.xmin > NORMALIZED_MAX ||
    box.ymax < 0 ||
    box.ymax > NORMALIZED_MAX ||
    box.xmax < 0 ||
    box.xmax > NORMALIZED_MAX
  ) {
    return false;
  }

  // ymin < ymax, xmin < xmax 체크
  if (box.ymin >= box.ymax || box.xmin >= box.xmax) {
    return false;
  }

  return true;
}

/**
 * Box2D의 면적을 계산합니다 (정규화 좌표 기준).
 *
 * @param box - 바운딩 박스
 * @returns 면적 (0~1000000)
 */
export function box2dArea(box: Box2D): number {
  return (box.ymax - box.ymin) * (box.xmax - box.xmin);
}

/**
 * Box2D의 중심점을 계산합니다 (정규화 좌표 기준).
 *
 * @param box - 바운딩 박스
 * @returns 중심점 좌표 {x, y}
 */
export function box2dCenter(box: Box2D): { x: number; y: number } {
  return {
    x: (box.xmin + box.xmax) / 2,
    y: (box.ymin + box.ymax) / 2,
  };
}
</file>

<file path="frontend/src/vite-env.d.ts">
/// <reference types="vite/client" />
</file>

<file path="frontend/tsconfig.json">
{
  "compilerOptions": {
    "target": "ES2022",
    "useDefineForClassFields": true,
    "lib": ["ES2022", "DOM", "DOM.Iterable"],
    "module": "ESNext",
    "skipLibCheck": true,

    /* Bundler mode */
    "moduleResolution": "Bundler",
    "allowImportingTsExtensions": true,
    "isolatedModules": true,
    "moduleDetection": "force",
    "noEmit": true,
    "jsx": "react-jsx",

    /* Linting (엄격 모드) */
    "strict": true,
    "noUnusedLocals": true,
    "noUnusedParameters": true,
    "noFallthroughCasesInSwitch": true,
    "noUncheckedSideEffectImports": true
  },
  "include": ["src"],
  "references": [{ "path": "./tsconfig.node.json" }]
}
</file>

<file path="frontend/tsconfig.node.json">
{
  "compilerOptions": {
    "target": "ES2022",
    "lib": ["ES2022"],
    "module": "ESNext",
    "skipLibCheck": true,

    /* Bundler mode */
    "moduleResolution": "Bundler",
    "allowImportingTsExtensions": true,
    "isolatedModules": true,
    "moduleDetection": "force",

    /* Composite for project references */
    "composite": true,
    "emitDeclarationOnly": true,
    "declaration": true,
    "declarationMap": true,

    /* Linting (엄격 모드) */
    "strict": true,
    "noUnusedLocals": true,
    "noUnusedParameters": true,
    "noFallthroughCasesInSwitch": true,
    "noUncheckedSideEffectImports": true
  },
  "include": ["vite.config.ts"]
}
</file>

<file path="backend/src/unknown_world/config/economy.py">
"""Unknown World - 경제 정책 및 상수 정의.

이 모듈은 재화(Signal, Memory Shard)와 관련된 정책 상수를 SSOT로 관리합니다.

참조:
    - vibe/prd.md 5장 (재화 시스템)
    - vibe/unit-plans/U-079[Mvp].md
"""

from typing import Final

# =============================================================================
# 재화 정책 상수
# =============================================================================

LOW_BALANCE_THRESHOLD: Final[int] = 10
"""잔액 부족 경고를 활성화하는 Signal 임계값."""

MAX_CREDIT: Final[int] = 50
"""허용되는 최대 크레딧(빚) 한도 (Signal 단위)."""

# =============================================================================
# 이미지 생성 비용 (QUALITY)
# =============================================================================

IMAGE_GENERATION_COST_SIGNAL: Final[int] = 10
"""이미지 생성 기본 Signal 비용."""

IMAGE_GENERATION_COST_MEMORY_SHARD: Final[int] = 0
"""이미지 생성 기본 Memory Shard 비용."""

# =============================================================================
# 이미지 생성 비용 (FAST 폴백)
# =============================================================================

FAST_IMAGE_COST_SIGNAL: Final[int] = 0
"""잔액 부족 시 FAST 폴백 이미지 Signal 비용 (무료)."""
</file>

<file path="backend/src/unknown_world/models/__init__.py">
"""Unknown World - 모델 패키지.

이 패키지는 TurnInput/TurnOutput 스키마 및 하위 타입을 정의합니다.
Gemini Structured Outputs(JSON Schema)용으로 설계되었습니다.

사용 예시:
    from unknown_world.models import TurnInput, TurnOutput

    # Pydantic → JSON Schema 변환 (Gemini response_json_schema용)
    schema = TurnOutput.model_json_schema()

    # 응답 검증
    output = TurnOutput.model_validate_json(response_text)

참조:
    - vibe/prd.md 8.7 (데이터 모델 설계)
    - vibe/ref/structured-outputs-guide.md
    - .cursor/rules/00-core-critical.mdc (RULE-003, RULE-005)
"""

from unknown_world.models.scanner import (
    DetectedObject,
    ItemCandidate,
    ScanRequest,
    ScanResponse,
    ScanResult,
    ScanStatus,
)
from unknown_world.models.turn import (
    ActionCard,
    ActionDeck,
    AgentConsole,
    AgentPhase,
    Box2D,
    ClickInput,
    ClientInfo,
    Coordinate,
    CurrencyAmount,
    EconomyOutput,
    EconomySnapshot,
    ImageJob,
    Language,
    MemoryPin,
    ModelLabel,
    Quest,
    RenderOutput,
    RiskLevel,
    SafetyOutput,
    SceneObject,
    Theme,
    TurnInput,
    TurnOutput,
    UIOutput,
    ValidationBadge,
    WorldDelta,
    WorldRule,
)

__all__ = [
    # Enum 타입
    "Language",
    "Theme",
    "AgentPhase",
    "ValidationBadge",
    "ModelLabel",
    "RiskLevel",
    # 공통 하위 타입
    "Coordinate",
    "Box2D",
    "CurrencyAmount",
    # TurnInput 관련
    "TurnInput",
    "ClickInput",
    "ClientInfo",
    "EconomySnapshot",
    # TurnOutput 관련
    "TurnOutput",
    "UIOutput",
    "ActionDeck",
    "ActionCard",
    "SceneObject",
    "WorldDelta",
    "WorldRule",
    "Quest",
    "MemoryPin",
    "RenderOutput",
    "ImageJob",
    "EconomyOutput",
    "SafetyOutput",
    "AgentConsole",
    # Scanner 관련 (U-021)
    "ScanStatus",
    "DetectedObject",
    "ItemCandidate",
    "ScanResult",
    "ScanRequest",
    "ScanResponse",
]
</file>

<file path="backend/src/unknown_world/orchestrator/conversation_history.py">
"""Unknown World - 멀티턴 대화 히스토리 관리 모듈 (U-127).

세션별 대화 히스토리를 관리하고, Gemini API `contents` 배열 형태로
멀티턴 컨텍스트를 제공합니다.

설계 원칙:
    - 최근 N턴(기본 5)의 대화 히스토리를 슬라이딩 윈도우로 유지
    - Gemini 3 Thought Signatures를 턴 간에 순환(circulation)
    - 토큰 예산 상한으로 비용 폭증 방지
    - 프롬프트 원문은 히스토리에 포함하지 않음 (RULE-007)
    - Option C: 사용자 텍스트 + GM 내러티브 + 핵심 상태 변화(delta)

참조:
    - vibe/unit-plans/U-127[Mvp].md
    - vibe/ref/gemini-api-guide.md (Thought Signatures)
"""

from __future__ import annotations

import logging
import os
import threading
from dataclasses import dataclass
from typing import Any, cast

logger = logging.getLogger(__name__)

# =============================================================================
# 환경변수 기반 설정
# =============================================================================

DEFAULT_MAX_TURNS = 5
"""기본 히스토리 윈도우 크기 (턴 수)."""

DEFAULT_MAX_TOKENS = 50000
"""기본 히스토리 토큰 예산 상한."""

CHARS_PER_TOKEN_ESTIMATE = 3
"""토큰 추정 계수 (한/영 혼합 기준 약 3자당 1토큰)."""


def _get_max_turns() -> int:
    """환경변수에서 최대 턴 수를 읽습니다."""
    return int(os.environ.get("UW_HISTORY_MAX_TURNS", str(DEFAULT_MAX_TURNS)))


def _get_max_tokens() -> int:
    """환경변수에서 최대 토큰 예산을 읽습니다."""
    return int(os.environ.get("UW_HISTORY_MAX_TOKENS", str(DEFAULT_MAX_TOKENS)))


# =============================================================================
# 턴 엔트리
# =============================================================================


@dataclass
class HistoryTurnEntry:
    """단일 턴의 히스토리 엔트리.

    Attributes:
        user_content: 사용자 입력 내용 (텍스트 + 액션 요약)
        model_content: GM 응답 내용 (내러티브 + 상태 변화 요약)
        thought_signature: Gemini 3 Thought Signature (모델 응답에서 추출)
        char_count: 엔트리의 총 문자 수 (토큰 추정용)
    """

    user_content: str
    model_content: str
    thought_signature: str | None = None
    char_count: int = 0

    def __post_init__(self) -> None:
        """문자 수를 자동 계산합니다."""
        self.char_count = len(self.user_content) + len(self.model_content)


# =============================================================================
# ConversationHistory
# =============================================================================


class ConversationHistory:
    """세션별 대화 히스토리 관리자.

    MVP: 서버 메모리 기반으로 세션 ID별 히스토리를 저장합니다.
    서버 재시작 시 초기화됩니다.

    Example:
        >>> history = ConversationHistory()
        >>> history.add_turn(
        ...     user_content="문을 열어본다",
        ...     model_content="문이 삐걱거리며 열립니다... [세계 변화: 열쇠 -1]",
        ...     thought_signature="<sig_abc>",
        ... )
        >>> contents = history.get_contents(max_turns=5)
    """

    def __init__(self) -> None:
        """ConversationHistory를 초기화합니다."""
        self._entries: list[HistoryTurnEntry] = []
        self._lock = threading.Lock()

    def add_turn(
        self,
        user_content: str,
        model_content: str,
        thought_signature: str | None = None,
    ) -> None:
        """턴을 히스토리에 추가합니다.

        Args:
            user_content: 사용자 입력 요약
            model_content: GM 응답 요약 (내러티브 + 핵심 상태 변화)
            thought_signature: Gemini 3 Thought Signature
        """
        entry = HistoryTurnEntry(
            user_content=user_content,
            model_content=model_content,
            thought_signature=thought_signature,
        )
        with self._lock:
            self._entries.append(entry)
            # 최대 턴 수 초과 시 오래된 턴부터 제거
            max_turns = _get_max_turns()
            if len(self._entries) > max_turns * 2:  # 여유 버퍼 2배
                self._entries = self._entries[-max_turns:]

        logger.debug(
            "[ConversationHistory] 턴 추가",
            extra={
                "total_entries": len(self._entries),
                "has_thought_signature": thought_signature is not None,
            },
        )

    def get_contents(
        self,
        max_turns: int | None = None,
    ) -> list[dict[str, Any]]:
        """Gemini API `contents` 형태로 히스토리를 반환합니다.

        최근 N턴을 user/model 교차 메시지로 변환합니다.
        Thought Signature는 model 응답의 parts에 포함됩니다.

        Args:
            max_turns: 최대 포함 턴 수 (None이면 환경변수 기본값)

        Returns:
            Gemini API contents 배열 (user/model 교차)
        """
        if max_turns is None:
            max_turns = _get_max_turns()

        with self._lock:
            entries = list(self._entries)

        # 슬라이딩 윈도우: 최근 N턴
        entries = entries[-max_turns:]

        # 토큰 예산 제한
        entries = self._trim_to_token_budget(entries)

        # contents 배열 구성
        contents: list[dict[str, Any]] = []
        for entry in entries:
            # User 메시지
            contents.append(
                {
                    "role": "user",
                    "parts": [{"text": entry.user_content}],
                }
            )

            # Model 메시지 (Thought Signature 포함)
            model_parts: list[dict[str, Any]] = [{"text": entry.model_content}]
            if entry.thought_signature:
                # base64 인코딩된 Thought Signature를 bytes로 복원하여 API에 전달
                import base64

                try:
                    sig_bytes = base64.b64decode(entry.thought_signature)
                    model_parts[0]["thoughtSignature"] = sig_bytes
                except Exception:
                    # 디코딩 실패 시 문자열 그대로 전달 (안전한 폴백)
                    model_parts[0]["thoughtSignature"] = entry.thought_signature

            contents.append(
                {
                    "role": "model",
                    "parts": model_parts,
                }
            )

        return contents

    def get_last_thought_signature(self) -> str | None:
        """마지막 턴의 Thought Signature를 반환합니다.

        Returns:
            마지막 Thought Signature 또는 None
        """
        with self._lock:
            if not self._entries:
                return None
            return self._entries[-1].thought_signature

    def clear(self) -> None:
        """히스토리를 초기화합니다."""
        with self._lock:
            self._entries.clear()
        logger.info("[ConversationHistory] 히스토리 초기화됨")

    @property
    def turn_count(self) -> int:
        """현재 저장된 턴 수."""
        with self._lock:
            return len(self._entries)

    def _trim_to_token_budget(
        self,
        entries: list[HistoryTurnEntry],
    ) -> list[HistoryTurnEntry]:
        """토큰 예산 상한을 초과하지 않도록 오래된 턴부터 제거합니다.

        Args:
            entries: 히스토리 엔트리 목록

        Returns:
            토큰 예산 내로 잘린 엔트리 목록
        """
        max_tokens = _get_max_tokens()
        max_chars = max_tokens * CHARS_PER_TOKEN_ESTIMATE

        total_chars = sum(e.char_count for e in entries)

        # 최신 턴부터 유지하며 예산 내로 자름
        while entries and total_chars > max_chars:
            removed = entries.pop(0)  # 가장 오래된 턴 제거
            total_chars -= removed.char_count
            logger.debug(
                "[ConversationHistory] 토큰 예산 초과로 턴 제거",
                extra={
                    "removed_chars": removed.char_count,
                    "remaining_chars": total_chars,
                    "remaining_entries": len(entries),
                },
            )

        return entries


# =============================================================================
# 세션 관리자 (전역 싱글톤)
# =============================================================================

_session_histories: dict[str, ConversationHistory] = {}
_session_lock = threading.Lock()

DEFAULT_SESSION_ID = "default"
"""기본 세션 ID (MVP: 단일 플레이어)."""


def get_conversation_history(session_id: str = DEFAULT_SESSION_ID) -> ConversationHistory:
    """세션 ID에 해당하는 ConversationHistory를 반환합니다.

    존재하지 않으면 새로 생성합니다.

    Args:
        session_id: 세션 식별자 (기본: "default")

    Returns:
        ConversationHistory 인스턴스
    """
    with _session_lock:
        if session_id not in _session_histories:
            _session_histories[session_id] = ConversationHistory()
            logger.info(
                "[ConversationHistory] 새 세션 히스토리 생성",
                extra={"session_id": session_id},
            )
        return _session_histories[session_id]


def reset_conversation_history(session_id: str = DEFAULT_SESSION_ID) -> None:
    """세션 히스토리를 초기화합니다.

    Args:
        session_id: 세션 식별자 (기본: "default")
    """
    with _session_lock:
        if session_id in _session_histories:
            _session_histories[session_id].clear()
            del _session_histories[session_id]
    logger.info(
        "[ConversationHistory] 세션 히스토리 리셋",
        extra={"session_id": session_id},
    )


def reset_all_histories() -> None:
    """모든 세션 히스토리를 초기화합니다."""
    with _session_lock:
        for history in _session_histories.values():
            history.clear()
        _session_histories.clear()
    logger.info("[ConversationHistory] 전체 히스토리 리셋")


def build_model_content_summary(
    narrative: str,
    world_delta: dict[str, Any] | None = None,
) -> str:
    """모델 응답을 히스토리용 요약 문자열로 변환합니다.

    Option C: GM 내러티브 + 핵심 상태 변화(delta)

    Args:
        narrative: GM 내러티브 텍스트
        world_delta: 세계 상태 변화 요약 (선택)

    Returns:
        히스토리에 저장할 모델 응답 요약
    """
    summary = narrative

    if world_delta:
        delta_parts: list[str] = []
        # 인벤토리 추가
        added_raw: list[Any] = list(world_delta.get("inventory_added") or [])
        if added_raw:
            labels: list[str] = []
            for item in added_raw:
                if isinstance(item, dict):
                    item_dict = cast(dict[str, Any], item)
                    label_val: str = str(item_dict.get("label", "?"))
                    labels.append(label_val)
            if labels:
                delta_parts.append(f"획득: {', '.join(labels)}")
        # 인벤토리 제거
        removed_raw: list[Any] = list(world_delta.get("inventory_removed") or [])
        if removed_raw:
            removed_strs: list[str] = [str(r) for r in removed_raw]
            delta_parts.append(f"소모: {', '.join(removed_strs)}")
        # 규칙 변화
        rules_raw: list[Any] = list(world_delta.get("rules_added") or [])
        if rules_raw:
            delta_parts.append(f"규칙 추가: {len(rules_raw)}개")

        if delta_parts:
            summary += f"\n[상태 변화: {'; '.join(delta_parts)}]"

    return summary
</file>

<file path="backend/src/unknown_world/orchestrator/prompt_loader.py">
"""Unknown World - 프롬프트 로더 유틸리티.

이 모듈은 언어별로 분리된 프롬프트 파일을 로드합니다.
XML 태그 기반 메타데이터 파싱 및 핫리로드를 지원합니다.

설계 원칙:
    - RULE-006: ko/en 언어 정책 준수 (혼합 출력 금지)
    - RULE-007/008: 프롬프트 원문 UI/로그 노출 금지
    - U-036: 핫리로드 (개발 모드), 프론트매터 파싱 지원
    - U-046: XML 태그 규격 통일 (메타/섹션) + 레거시 폴백

프롬프트 디렉토리 구조:
    backend/prompts/
    ├── system/
    │   ├── game_master.ko.md
    │   └── game_master.en.md
    ├── turn/
    │   ├── turn_output_instructions.ko.md
    │   └── turn_output_instructions.en.md
    └── image/
        ├── scene_prompt.ko.md
        └── scene_prompt.en.md

XML 태그 규격 (U-046):
    <prompt_meta>
      <prompt_id>game_master_system</prompt_id>
      <language>ko-KR</language>
      <version>0.1.0</version>
      <last_updated>YYYY-MM-DD</last_updated>
      <policy_preset>default</policy_preset>
    </prompt_meta>

    <prompt_body>
    ## 목적
    ...
    </prompt_body>

페어링 질문 결정:
    - U-036 Q1: Option A (개발 모드에서만 매 호출 시 리로드)
    - U-036 Q2: Option B (프론트매터 포함 마크다운)
    - U-046 Q1: Option A (메타 블록을 모델 입력에서 제거)
    - U-046 Q2: Option A (XML 파싱 실패 시 레거시 폴백)

참조:
    - vibe/prd.md 3.2 (프롬프트 파일 관리)
    - vibe/prd.md 10.4 (프롬프트 핫리로드)
    - .cursor/rules/30-prompts-i18n.mdc
"""

from __future__ import annotations

import logging
import os
import re
from dataclasses import dataclass, field
from functools import lru_cache
from pathlib import Path
from typing import Literal

from unknown_world.models.turn import Language

# =============================================================================
# 로거 설정 (프롬프트 원문 로깅 금지 - RULE-007/008)
# =============================================================================

logger = logging.getLogger(__name__)

# =============================================================================
# 경로 상수
# =============================================================================

# 프롬프트 루트 디렉토리 (backend/prompts/)
_PROMPTS_ROOT = Path(__file__).parent.parent.parent.parent / "prompts"

# 프롬프트 카테고리
PromptCategory = Literal["system", "turn", "image", "scan", "vision"]

# 언어 코드 매핑
_LANGUAGE_CODE_MAP: dict[Language, str] = {
    Language.KO: "ko",
    Language.EN: "en",
}

# =============================================================================
# 프론트매터 파싱 결과 타입
# =============================================================================


@dataclass
class PromptData:
    """프론트매터가 파싱된 프롬프트 데이터.

    Attributes:
        content: 프롬프트 본문 (프론트매터 제외)
        metadata: 프론트매터에서 추출한 메타데이터
        raw: 원본 전체 텍스트
    """

    content: str
    metadata: dict[str, str] = field(default_factory=lambda: {})
    raw: str = ""

    def to_dict(self) -> dict[str, str | dict[str, str]]:
        """JSON 직렬화 가능한 딕셔너리로 변환합니다.

        Returns:
            프롬프트 데이터 딕셔너리
        """
        return {
            "content": self.content,
            "metadata": self.metadata,
        }


# =============================================================================
# 환경 모드 확인
# =============================================================================


def _is_development_mode() -> bool:
    """개발 모드인지 확인합니다.

    ENVIRONMENT 환경변수가 'development'이면 개발 모드입니다.
    개발 모드에서는 프롬프트 핫리로드가 활성화됩니다.

    Returns:
        개발 모드 여부
    """
    return os.environ.get("ENVIRONMENT", "production").lower() == "development"


# =============================================================================
# XML 태그 및 프론트매터 파싱 (U-046)
# =============================================================================

# XML 태그 패턴 (U-046 표준)
_XML_META_PATTERN = re.compile(
    r"<prompt_meta>\s*(.*?)\s*</prompt_meta>",
    re.DOTALL,
)
_XML_BODY_PATTERN = re.compile(
    r"<prompt_body>\s*(.*?)\s*</prompt_body>",
    re.DOTALL,
)
_XML_TAG_PATTERN = re.compile(r"<(\w+)>([^<]*)</\1>")

# 레거시 프론트매터 패턴: 파일 시작 부분의 "- key: value" 형태
_FRONTMATTER_LINE_PATTERN = re.compile(r"^-\s*(\w+):\s*(.+)$")


def _parse_xml_meta(text: str) -> tuple[dict[str, str], str] | None:
    """XML 태그 기반 메타데이터와 본문을 파싱합니다.

    U-046 표준 XML 태그 규격:
        <prompt_meta>
          <prompt_id>game_master_system</prompt_id>
          <language>ko-KR</language>
          <version>0.1.0</version>
          <last_updated>YYYY-MM-DD</last_updated>
          <policy_preset>default</policy_preset>
        </prompt_meta>

        <prompt_body>
        ## 목적
        ...
        </prompt_body>

    Args:
        text: 원본 텍스트

    Returns:
        (메타데이터 딕셔너리, 본문 텍스트) 튜플
        XML 태그가 없으면 None 반환 (레거시 폴백 필요)
    """
    meta_match = _XML_META_PATTERN.search(text)
    body_match = _XML_BODY_PATTERN.search(text)

    # XML 태그가 없으면 None 반환
    if not meta_match:
        return None

    # 메타데이터 파싱
    meta_content = meta_match.group(1)
    metadata: dict[str, str] = {}
    for tag_match in _XML_TAG_PATTERN.finditer(meta_content):
        key = tag_match.group(1)
        value = tag_match.group(2).strip()
        metadata[key] = value

    # 본문 추출 (U-046 Q1: 메타 블록을 모델 입력에서 제거)
    if body_match:
        content = body_match.group(1).strip()
    else:
        # <prompt_body>가 없으면 <prompt_meta> 이후 전체를 본문으로 취급
        meta_end = meta_match.end()
        content = text[meta_end:].strip()

    return metadata, content


def _parse_legacy_frontmatter(text: str) -> tuple[dict[str, str], str]:
    """레거시 프론트매터를 파싱합니다 (U-036 호환).

    프론트매터는 첫 번째 제목(#) 이후, 두 번째 제목(##) 이전의
    "- key: value" 형태의 라인들입니다.

    예시 구조:
        # [Prompt] Title

        - prompt_id: xxx
        - version: 0.1.0

        ## 본문 섹션
        ...

    Args:
        text: 원본 마크다운 텍스트

    Returns:
        (메타데이터 딕셔너리, 본문 텍스트) 튜플
    """
    lines = text.split("\n")
    metadata: dict[str, str] = {}
    content_start_idx = 0
    found_first_heading = False

    for i, line in enumerate(lines):
        stripped = line.strip()

        # 빈 줄은 건너뜀
        if not stripped:
            continue

        # 첫 번째 제목(#) 발견
        if stripped.startswith("#") and not stripped.startswith("##"):
            found_first_heading = True
            continue

        # 두 번째 제목(##) 발견 시 프론트매터 영역 종료, 본문 시작
        if stripped.startswith("##"):
            content_start_idx = i
            break

        # 프론트매터 라인 매칭 (첫 번째 제목 이후)
        if found_first_heading:
            match = _FRONTMATTER_LINE_PATTERN.match(stripped)
            if match:
                key = match.group(1)
                value = match.group(2).strip()
                metadata[key] = value

    # 본문 추출 (두 번째 제목부터)
    content = "\n".join(lines[content_start_idx:]).strip()

    return metadata, content


def _parse_frontmatter(text: str) -> tuple[dict[str, str], str]:
    """메타데이터와 본문을 파싱합니다 (XML 우선, 레거시 폴백).

    U-046 Q2 결정: XML 태그 파싱 실패 시 레거시 폴백 후 진행

    파싱 우선순위:
        1. XML 태그 기반 (<prompt_meta>, <prompt_body>)
        2. 레거시 프론트매터 (- key: value)

    Args:
        text: 원본 텍스트

    Returns:
        (메타데이터 딕셔너리, 본문 텍스트) 튜플
    """
    # 1. XML 태그 파싱 시도
    xml_result = _parse_xml_meta(text)
    if xml_result is not None:
        metadata, content = xml_result
        logger.debug(
            "[PromptLoader] XML 태그 기반 파싱 완료",
            extra={"format": "xml", "meta_keys": list(metadata.keys())},
        )
        return metadata, content

    # 2. 레거시 폴백 (U-046 Q2: Option A)
    logger.debug(
        "[PromptLoader] 레거시 프론트매터 파싱으로 폴백",
        extra={"format": "legacy"},
    )
    return _parse_legacy_frontmatter(text)


# =============================================================================
# 프롬프트 로더 함수
# =============================================================================


def _get_prompt_path(
    category: PromptCategory,
    name: str,
    language: Language,
) -> Path:
    """프롬프트 파일 경로를 반환합니다.

    Args:
        category: 프롬프트 카테고리 (system, turn, image)
        name: 프롬프트 파일 이름 (확장자 제외)
        language: 언어 (ko-KR, en-US)

    Returns:
        프롬프트 파일 경로

    Example:
        >>> _get_prompt_path("system", "game_master", Language.KO)
        Path(".../prompts/system/game_master.ko.md")
    """
    lang_code = _LANGUAGE_CODE_MAP.get(language, "ko")
    return _PROMPTS_ROOT / category / f"{name}.{lang_code}.md"


def _load_prompt_file(
    category: PromptCategory,
    name: str,
    language: Language,
) -> str:
    """프롬프트 파일을 직접 로드합니다 (캐싱 없음).

    핫리로드 모드에서 사용됩니다.

    Args:
        category: 프롬프트 카테고리
        name: 프롬프트 이름
        language: 언어

    Returns:
        프롬프트 텍스트

    Raises:
        FileNotFoundError: 프롬프트 파일이 없는 경우
    """
    path = _get_prompt_path(category, name, language)

    if not path.exists():
        # 폴백: 반대 언어 시도
        fallback_lang = Language.EN if language == Language.KO else Language.KO
        fallback_path = _get_prompt_path(category, name, fallback_lang)

        if fallback_path.exists():
            logger.warning(
                "[PromptLoader] 폴백 언어 사용",
                extra={
                    "original_language": language.value,
                    "fallback_language": fallback_lang.value,
                },
            )
            return fallback_path.read_text(encoding="utf-8")

        raise FileNotFoundError(f"프롬프트 파일을 찾을 수 없습니다: {path}")

    return path.read_text(encoding="utf-8")


@lru_cache(maxsize=32)
def _load_prompt_cached(
    category: PromptCategory,
    name: str,
    language: Language,
) -> str:
    """프롬프트 파일을 캐싱하여 로드합니다.

    운영 모드에서 사용됩니다.

    Args:
        category: 프롬프트 카테고리
        name: 프롬프트 이름
        language: 언어

    Returns:
        프롬프트 텍스트
    """
    return _load_prompt_file(category, name, language)


def load_prompt(
    category: PromptCategory,
    name: str,
    language: Language,
) -> str:
    """프롬프트 파일을 로드합니다.

    개발 모드(ENVIRONMENT=development)에서는 매 호출 시 파일을 다시 읽습니다 (핫리로드).
    운영 모드에서는 캐싱을 통해 반복 로드를 방지합니다.
    프롬프트 원문은 로그에 기록하지 않습니다 (RULE-007/008).

    Args:
        category: 프롬프트 카테고리 (system, turn, image)
        name: 프롬프트 파일 이름 (확장자 제외)
        language: 언어 (ko-KR, en-US)

    Returns:
        프롬프트 텍스트

    Raises:
        FileNotFoundError: 프롬프트 파일이 없는 경우

    Example:
        >>> prompt = load_prompt("system", "game_master", Language.KO)
    """
    # 로그에는 경로/메타만 기록 (원문 금지)
    logger.debug(
        "[PromptLoader] 프롬프트 로드",
        extra={
            "category": category,
            "name": name,
            "language": language.value,
            "hot_reload": _is_development_mode(),
        },
    )

    # U-036 Q1 결정: 개발 모드에서만 핫리로드
    if _is_development_mode():
        return _load_prompt_file(category, name, language)
    else:
        return _load_prompt_cached(category, name, language)


def load_prompt_with_metadata(
    category: PromptCategory,
    name: str,
    language: Language,
) -> PromptData:
    """프롬프트 파일을 메타데이터와 함께 로드합니다.

    프론트매터를 파싱하여 메타데이터와 본문을 분리합니다.
    JSON 형태로 프롬프트를 전달할 때 유용합니다.

    Args:
        category: 프롬프트 카테고리 (system, turn, image)
        name: 프롬프트 파일 이름 (확장자 제외)
        language: 언어 (ko-KR, en-US)

    Returns:
        PromptData: 메타데이터와 본문이 분리된 프롬프트 데이터

    Example:
        >>> data = load_prompt_with_metadata("system", "game_master", Language.KO)
        >>> print(data.metadata.get("version"))
        >>> print(data.content[:100])
    """
    raw_text = load_prompt(category, name, language)
    metadata, content = _parse_frontmatter(raw_text)

    logger.debug(
        "[PromptLoader] 프롬프트 메타데이터 파싱 완료",
        extra={
            "category": category,
            "name": name,
            "language": language.value,
            "prompt_id": metadata.get("prompt_id", "unknown"),
            "version": metadata.get("version", "unknown"),
        },
    )

    return PromptData(
        content=content,
        metadata=metadata,
        raw=raw_text,
    )


def load_prompt_as_json(
    category: PromptCategory,
    name: str,
    language: Language,
) -> dict[str, str | dict[str, str]]:
    """프롬프트를 JSON 직렬화 가능한 딕셔너리로 로드합니다.

    API 응답이나 모델 입력으로 프롬프트를 전달할 때 유용합니다.

    Args:
        category: 프롬프트 카테고리 (system, turn, image)
        name: 프롬프트 파일 이름 (확장자 제외)
        language: 언어 (ko-KR, en-US)

    Returns:
        프롬프트 딕셔너리 (content, metadata 포함)

    Example:
        >>> prompt_json = load_prompt_as_json("image", "scene_prompt", Language.KO)
        >>> print(prompt_json["metadata"]["prompt_id"])
    """
    data = load_prompt_with_metadata(category, name, language)
    return data.to_dict()


def load_system_prompt(language: Language) -> str:
    """Game Master 시스템 프롬프트를 로드합니다.

    Args:
        language: 언어 (ko-KR, en-US)

    Returns:
        시스템 프롬프트 텍스트
    """
    return load_prompt("system", "game_master", language)


def load_turn_instructions(language: Language) -> str:
    """TurnOutput 지시 프롬프트를 로드합니다.

    Args:
        language: 언어 (ko-KR, en-US)

    Returns:
        TurnOutput 지시 텍스트
    """
    return load_prompt("turn", "turn_output_instructions", language)


def load_image_prompt(language: Language) -> str:
    """이미지 생성 프롬프트를 로드합니다.

    Args:
        language: 언어 (ko-KR, en-US)

    Returns:
        이미지 생성 프롬프트 텍스트
    """
    return load_prompt("image", "scene_prompt", language)


def load_image_prompt_with_metadata(language: Language) -> PromptData:
    """이미지 생성 프롬프트를 메타데이터와 함께 로드합니다.

    Args:
        language: 언어 (ko-KR, en-US)

    Returns:
        PromptData: 메타데이터와 본문이 분리된 이미지 프롬프트 데이터
    """
    return load_prompt_with_metadata("image", "scene_prompt", language)


def clear_prompt_cache() -> None:
    """프롬프트 캐시를 초기화합니다.

    개발 중 핫리로드 또는 테스트 시 사용합니다.
    """
    _load_prompt_cached.cache_clear()
    logger.info("[PromptLoader] 프롬프트 캐시 초기화됨")


def get_prompt_metadata(
    category: PromptCategory,
    name: str,
    language: Language,
) -> dict[str, str]:
    """프롬프트의 메타데이터만 반환합니다.

    본문 없이 버전, 언어, 업데이트 날짜 등 메타정보만 필요할 때 사용합니다.

    Args:
        category: 프롬프트 카테고리
        name: 프롬프트 이름
        language: 언어

    Returns:
        메타데이터 딕셔너리
    """
    data = load_prompt_with_metadata(category, name, language)
    return data.metadata


def is_hot_reload_enabled() -> bool:
    """핫리로드가 활성화되어 있는지 확인합니다.

    Returns:
        핫리로드 활성화 여부
    """
    return _is_development_mode()
</file>

<file path="backend/src/unknown_world/orchestrator/stages/verify.py">
"""Unknown World - Verify Stage.

검증 단계입니다.
U-090: 비정밀분석 턴 핫스팟 생성 금지 비즈니스 룰 검증이 추가되었습니다.

설계 원칙:
    - RULE-008: 단계 이벤트 일관성
    - 동작 보존: 기존 시뮬레이션 지연 유지
    - U-090: 핫스팟은 정밀분석 전용 (이중 안전장치)

참조:
    - vibe/refactors/RU-005-Q4.md
    - vibe/unit-plans/U-090[Mvp].md
"""

from __future__ import annotations

import asyncio
import logging

from unknown_world.config.models import TextModelTiering
from unknown_world.models.turn import AgentPhase
from unknown_world.orchestrator.stages.types import (
    EmitFn,
    PipelineContext,
    PipelineEvent,
    PipelineEventType,
)

logger = logging.getLogger(__name__)

# 모의 처리 지연 시간 (ms)
VERIFY_DELAY_MS = 40


async def verify_stage(ctx: PipelineContext, *, emit: EmitFn) -> PipelineContext:
    """Verify 단계를 실행합니다.

    U-090: 비정밀분석 턴에서 핫스팟이 남아있으면 강제 제거 (이중 안전장치).
    resolve stage에서 이미 필터링하지만, 만약 누락된 경우를 대비합니다.

    Args:
        ctx: 파이프라인 컨텍스트
        emit: 이벤트 emit 콜백

    Returns:
        업데이트된 컨텍스트
    """
    ctx.current_phase = AgentPhase.VERIFY

    # Stage 시작 이벤트
    await emit(
        PipelineEvent(
            event_type=PipelineEventType.STAGE_START,
            phase=AgentPhase.VERIFY,
        )
    )

    # 모의 처리 지연 (기존 동작 보존)
    await asyncio.sleep(VERIFY_DELAY_MS / 1000.0)

    # U-090: 비정밀분석 턴 핫스팟 이중 안전장치
    # resolve stage에서 이미 필터링하지만, 놓친 경우를 대비
    is_vision = TextModelTiering.is_vision_trigger(
        ctx.turn_input.action_id,
        ctx.turn_input.text,
    )
    if not is_vision and ctx.output is not None and ctx.output.ui.objects:
        leaked_count = len(ctx.output.ui.objects)
        logger.error(
            "[Verify] U-090: 비정밀분석 턴에서 핫스팟 %d개 누출 감지, 강제 제거",
            leaked_count,
        )
        new_ui = ctx.output.ui.model_copy(update={"objects": []})
        ctx.output = ctx.output.model_copy(update={"ui": new_ui})

    # Stage 완료 이벤트
    await emit(
        PipelineEvent(
            event_type=PipelineEventType.STAGE_COMPLETE,
            phase=AgentPhase.VERIFY,
        )
    )

    return ctx
</file>

<file path="backend/src/unknown_world/services/__init__.py">
"""Unknown World - 서비스 레이어 패키지.

이 패키지는 외부 서비스와의 통신을 담당하는 모듈을 관리합니다.
GenAI 클라이언트, 이미지 생성기, 스토리지 클라이언트 등이 포함됩니다.

참조:
    - vibe/tech-stack.md (google-genai 버전, Vertex AI 인증)
    - .cursor/rules/20-backend-orchestrator.mdc (Vertex 인증/비밀정보 금지)
"""

from unknown_world.services.genai_client import (
    GenAIClient,
    GenAIClientType,
    GenAIMode,
    GenerateRequest,
    GenerateResponse,
    MockGenAIClient,
    get_genai_client,
    reset_genai_client,
)
from unknown_world.services.image_generation import (
    ImageGenerationRequest,
    ImageGenerationResponse,
    ImageGenerationStatus,
    ImageGenerator,
    ImageGeneratorType,
    MockImageGenerator,
    create_fallback_response,
    get_image_generator,
    reset_image_generator,
)
from unknown_world.services.image_understanding import (
    ImageUnderstandingService,
    get_image_understanding_service,
    reset_image_understanding_service,
)

__all__ = [
    # GenAI 클라이언트
    "GenAIClient",
    "GenAIClientType",
    "GenAIMode",
    "GenerateRequest",
    "GenerateResponse",
    "MockGenAIClient",
    "get_genai_client",
    "reset_genai_client",
    # 이미지 생성 (U-019)
    "ImageGenerationRequest",
    "ImageGenerationResponse",
    "ImageGenerationStatus",
    "ImageGenerator",
    "ImageGeneratorType",
    "MockImageGenerator",
    "create_fallback_response",
    "get_image_generator",
    "reset_image_generator",
    # 이미지 이해/Scanner (U-021)
    "ImageUnderstandingService",
    "get_image_understanding_service",
    "reset_image_understanding_service",
]
</file>

<file path="backend/src/unknown_world/storage/paths.py">
"""Unknown World - 스토리지 경로 상수.

모든 저장 경로 및 URL 관련 상수를 중앙 관리합니다.
MVP: 로컬 파일 시스템 경로
MMP: GCS 버킷 경로로 확장 예정

페어링 질문 Q1 결정: Option A (backend/.data/ 전용 폴더)

참조:
    - vibe/refactors/RU-006-Q5.md
"""

from __future__ import annotations

from pathlib import Path
from typing import Final

# =============================================================================
# 기본 디렉토리 (MVP: 로컬)
# =============================================================================

# 페어링 질문 Q1: Option A - backend/.data/ 전용 폴더
# .gitignore에 backend/.data/ 추가 필수
BASE_DATA_DIR: Final[Path] = Path(".data")
"""모든 데이터 파일의 루트 디렉토리."""

# 하위 호환성을 위한 레거시 경로 (deprecated, 마이그레이션용)
LEGACY_OUTPUT_DIR: Final[Path] = Path("generated_images")
"""[Deprecated] 기존 이미지 저장 경로. .data/로 마이그레이션 권장."""

# =============================================================================
# 카테고리별 서브 경로
# =============================================================================

IMAGES_GENERATED_SUBDIR: Final[str] = "images/generated"
"""생성된 이미지 저장 서브 디렉토리."""

IMAGES_UPLOADED_SUBDIR: Final[str] = "images/uploaded"
"""업로드된 이미지 저장 서브 디렉토리."""

ARTIFACTS_SUBDIR: Final[str] = "artifacts"
"""게임 아티팩트 저장 서브 디렉토리."""

# =============================================================================
# URL 프리픽스
# =============================================================================

STATIC_URL_PREFIX: Final[str] = "/static"
"""정적 파일 서빙 URL 프리픽스."""

# 전체 경로 (자주 사용되는 조합)
STATIC_IMAGES_URL_PREFIX: Final[str] = f"{STATIC_URL_PREFIX}/images"
"""이미지 파일 URL 프리픽스 (예: /static/images/generated/xxx.png)."""

# =============================================================================
# 파일 확장자
# =============================================================================

DEFAULT_IMAGE_EXTENSION: Final[str] = "png"
"""기본 이미지 파일 확장자."""

# =============================================================================
# 경로 헬퍼 함수
# =============================================================================


def get_generated_images_dir() -> Path:
    """생성된 이미지 저장 디렉토리 경로를 반환합니다."""
    return BASE_DATA_DIR / IMAGES_GENERATED_SUBDIR


def get_uploaded_images_dir() -> Path:
    """업로드된 이미지 저장 디렉토리 경로를 반환합니다."""
    return BASE_DATA_DIR / IMAGES_UPLOADED_SUBDIR


def get_artifacts_dir() -> Path:
    """아티팩트 저장 디렉토리 경로를 반환합니다."""
    return BASE_DATA_DIR / ARTIFACTS_SUBDIR


def build_image_url(
    filename: str,
    *,
    category: str = "generated",
) -> str:
    """이미지 파일의 서빙 URL을 생성합니다.

    Args:
        filename: 파일명 (확장자 포함)
        category: 이미지 카테고리 ("generated" 또는 "uploaded")

    Returns:
        서빙 URL (예: /static/images/generated/img_abc123.png)
    """
    return f"{STATIC_URL_PREFIX}/images/{category}/{filename}"


def build_legacy_image_url(filename: str) -> str:
    """[Deprecated] 레거시 이미지 URL을 생성합니다.

    기존 코드 호환성을 위해 유지. 신규 코드에서는 build_image_url() 사용.

    Args:
        filename: 파일명 (확장자 포함)

    Returns:
        레거시 URL (예: /static/images/img_abc123.png)
    """
    return f"/static/images/{filename}"
</file>

<file path="backend/src/unknown_world/storage/seed.py">
"""U-124: 사전 생성 씬 이미지 시드.

백엔드 시작 시 프론트엔드의 사전 생성 씬 이미지(WebP)를
백엔드 output 디렉터리(PNG)로 복사합니다.

이를 통해 Gemini 참조 이미지 파이프라인(/api/image/file/{id})에서
사전 생성 이미지를 첫 턴 참조용으로 사용할 수 있습니다.

참조:
    - vibe/unit-plans/U-124[Mvp].md
    - frontend/public/ui/scenes/ (원본 WebP)
    - .data/images/generated/ (대상 PNG)
"""

from __future__ import annotations

import logging
from pathlib import Path

from unknown_world.storage.paths import get_generated_images_dir

logger = logging.getLogger(__name__)

# 백엔드 cwd 기준 프론트엔드 에셋 경로
# backend/ → ../frontend/public/ui/scenes/
_FRONTEND_SCENES_DIR = Path("../frontend/public/ui/scenes")

# 시드 대상 파일 ID 목록 (확장자 제외)
_SCENE_IMAGE_IDS: list[str] = [
    "scene-narrator-start",
    "scene-explorer-start",
    "scene-tech-start",
]


def seed_scene_images() -> None:
    """사전 생성 씬 이미지를 백엔드 output 디렉터리에 시드합니다.

    - 프론트엔드 WebP → 백엔드 PNG 변환 (Pillow 사용)
    - 이미 존재하고 원본보다 새로우면 건너뜀 (멱등)
    - 원본 미존재 또는 Pillow 오류 시 경고만 출력 (서버 시작 차단 금지)
    """
    dest_dir = get_generated_images_dir()
    dest_dir.mkdir(parents=True, exist_ok=True)

    scenes_dir = _FRONTEND_SCENES_DIR
    if not scenes_dir.exists():
        logger.warning(
            "[Seed] 프론트엔드 씬 디렉터리 없음, 시드 건너뜀",
            extra={"path": str(scenes_dir.resolve())},
        )
        return

    converted = 0
    skipped = 0

    for image_id in _SCENE_IMAGE_IDS:
        src = scenes_dir / f"{image_id}.webp"
        dest = dest_dir / f"{image_id}.png"

        if not src.exists():
            logger.warning(
                "[Seed] 소스 WebP 없음",
                extra={"image_id": image_id, "path": str(src)},
            )
            continue

        # 멱등: 대상이 이미 존재하고 원본보다 새로우면 건너뜀
        if dest.exists() and dest.stat().st_mtime >= src.stat().st_mtime:
            skipped += 1
            continue

        try:
            from PIL import Image

            with Image.open(src) as img:
                img.save(dest, format="PNG")
            converted += 1
            logger.info(
                "[Seed] 씬 이미지 변환 완료",
                extra={"image_id": image_id, "size_bytes": dest.stat().st_size},
            )
        except Exception:
            logger.exception(
                "[Seed] 씬 이미지 변환 실패",
                extra={"image_id": image_id},
            )

    logger.info(
        "[Seed] 씬 이미지 시드 완료",
        extra={"converted": converted, "skipped": skipped, "total": len(_SCENE_IMAGE_IDS)},
    )
</file>

<file path="backend/src/unknown_world/storage/storage.py">
"""Unknown World - 스토리지 추상화 인터페이스.

MVP에서는 로컬 파일 시스템, MMP에서는 GCS로 확장 가능한 구조.

설계 원칙:
    - RULE-007: 파일 내용/경로 로깅 시 메타만 기록
    - RULE-010: DB 대신 파일 기반 저장 우선

참조:
    - vibe/refactors/RU-006-Q4.md
"""

from __future__ import annotations

from abc import ABC, abstractmethod
from dataclasses import dataclass
from datetime import datetime
from enum import StrEnum


class StorageCategory(StrEnum):
    """저장 카테고리."""

    GENERATED_IMAGE = "generated_image"
    """생성된 이미지 (U-019)"""

    UPLOADED_IMAGE = "uploaded_image"
    """업로드된 이미지 (U-021, 선택적)"""

    ARTIFACT = "artifact"
    """게임 아티팩트 (엔딩 리포트, 리플레이 등)"""


@dataclass
class StorageMetadata:
    """저장된 파일 메타데이터."""

    key: str
    """스토리지 내 고유 키"""

    category: StorageCategory
    """저장 카테고리"""

    size_bytes: int
    """파일 크기"""

    content_type: str
    """MIME 타입"""

    created_at: datetime
    """생성 시각"""

    url: str
    """접근 URL"""

    session_id: str | None = None
    """세션 ID (선택)"""


@dataclass
class PutResult:
    """저장 결과."""

    success: bool
    key: str
    url: str
    metadata: StorageMetadata | None = None
    error: str | None = None


class StorageInterface(ABC):
    """스토리지 인터페이스 (추상 클래스).

    MVP: LocalStorage 구현
    MMP: GCSStorage 구현 예정
    """

    @abstractmethod
    async def put(
        self,
        data: bytes,
        *,
        category: StorageCategory,
        content_type: str = "image/png",
        file_id: str | None = None,
        session_id: str | None = None,
    ) -> PutResult:
        """파일을 저장합니다.

        Args:
            data: 파일 바이트 데이터
            category: 저장 카테고리
            content_type: MIME 타입
            file_id: 파일 ID (없으면 자동 생성)
            session_id: 세션 ID (경로 분류용)

        Returns:
            PutResult: 저장 결과
        """
        ...

    @abstractmethod
    async def get(self, key: str) -> bytes | None:
        """파일을 조회합니다.

        Args:
            key: 스토리지 키

        Returns:
            파일 바이트 데이터 (없으면 None)
        """
        ...

    @abstractmethod
    async def exists(self, key: str) -> bool:
        """파일 존재 여부를 확인합니다.

        Args:
            key: 스토리지 키

        Returns:
            존재 여부
        """
        ...

    @abstractmethod
    async def delete(self, key: str) -> bool:
        """파일을 삭제합니다.

        Args:
            key: 스토리지 키

        Returns:
            삭제 성공 여부
        """
        ...

    @abstractmethod
    def get_url(self, key: str) -> str:
        """파일 접근 URL을 반환합니다.

        Args:
            key: 스토리지 키

        Returns:
            접근 URL
        """
        ...
</file>

<file path="backend/tests/conftest.py">
import os

import pytest


@pytest.fixture(autouse=True)
def setup_test_env():
    """모든 테스트에서 UW_MODE=mock을 기본으로 사용하도록 설정합니다."""
    # 이미 설정된 경우(예: CI)는 유지하고, 로컬에서 수동 실행 시 기본값 보장
    if "UW_MODE" not in os.environ:
        os.environ["UW_MODE"] = "mock"

    # 이미지 생성 테스트를 위해 출력 디렉토리 보장
    from pathlib import Path

    output_dir = Path("test_output")
    output_dir.mkdir(parents=True, exist_ok=True)

    yield
</file>

<file path="backend/tests/fixtures/image_request_fast.json">
{
  "prompt": "A beautiful fantasy landscape with mountains and a glowing sunset",
  "aspect_ratio": "16:9",
  "model_label": "FAST"
}
</file>

<file path="backend/tests/fixtures/image_request_quality.json">
{
  "prompt": "A detailed cyberpunk city at night with neon lights",
  "aspect_ratio": "16:9",
  "model_label": "QUALITY"
}
</file>

<file path="backend/tests/fixtures/turn_request.json">
{
  "language": "ko-KR",
  "text": "새로운 세계를 탐험한다",
  "client": {
    "viewport_w": 1920,
    "viewport_h": 1080,
    "theme": "dark"
  },
  "economy_snapshot": {
    "signal": 100,
    "memory_shard": 5
  }
}
</file>

<file path="backend/tests/integration/test_item_icon_api.py">
from unittest.mock import AsyncMock, MagicMock, patch

import pytest
from httpx import ASGITransport, AsyncClient

from unknown_world.services.item_icon_generator import (
    reset_item_icon_generator,
)


@pytest.fixture(autouse=True)
def reset_generator():
    reset_item_icon_generator()
    yield
    reset_item_icon_generator()


@pytest.mark.asyncio
async def test_api_generate_icon_async():
    from unknown_world.main import app

    # ItemIconGenerator.generate_icon을 모킹하여 실제 이미지 생성 방지
    with patch("unknown_world.api.item_icon.get_item_icon_generator") as mock_get_generator:
        mock_generator = MagicMock()
        mock_get_generator.return_value = mock_generator

        from unknown_world.services.item_icon_generator import (
            IconGenerationResponse,
            IconGenerationStatus,
        )

        mock_generator.generate_icon = AsyncMock(
            return_value=IconGenerationResponse(
                status=IconGenerationStatus.PENDING,
                icon_url="/ui/icons/placeholder_item.png",
                item_id="item_123",
                is_placeholder=True,
                message="Generating...",
            )
        )

        transport = ASGITransport(app=app)
        async with AsyncClient(transport=transport, base_url="http://test") as ac:
            response = await ac.post(
                "/api/item/icon",
                json={
                    "item_id": "item_123",
                    "description": "A mysterious potion",
                    "language": "ko-KR",
                    "wait": False,
                },
            )

        assert response.status_code == 200
        data = response.json()
        assert data["status"] == "pending"
        assert data["item_id"] == "item_123"
        assert data["is_placeholder"] is True
        assert "/ui/icons/placeholder_item.png" in data["icon_url"]


@pytest.mark.asyncio
async def test_api_get_icon_status():
    from unknown_world.main import app

    with patch("unknown_world.api.item_icon.get_item_icon_generator") as mock_get_generator:
        mock_generator = MagicMock()
        mock_get_generator.return_value = mock_generator

        from unknown_world.services.item_icon_generator import IconGenerationStatus

        mock_generator.get_icon_status = AsyncMock(return_value=IconGenerationStatus.COMPLETED)

        transport = ASGITransport(app=app)
        async with AsyncClient(transport=transport, base_url="http://test") as ac:
            response = await ac.get("/api/item/icon/item_123/status")

        assert response.status_code == 200
        data = response.json()
        assert data["status"] == "completed"
        assert data["item_id"] == "item_123"
</file>

<file path="backend/tests/integration/test_rate_limit_flow.py">
"""Unknown World - RATE_LIMITED 에러 흐름 통합 테스트 (U-130).

백엔드에서 429 에러로 모든 재시도가 소진되었을 때,
스트림으로 code: "RATE_LIMITED" 에러 이벤트가 송출되는지 검증합니다.
"""

import json
import os
from unittest.mock import patch

import pytest

# 테스트 환경에서 Mock 모드 강제
os.environ["UW_MODE"] = "mock"

from fastapi.testclient import TestClient

from unknown_world.main import app
from unknown_world.models.turn import (
    ClientInfo,
    CurrencyAmount,
    EconomySnapshot,
    Language,
    TurnInput,
)
from unknown_world.orchestrator.stages.types import PipelineContext

client = TestClient(app)


@pytest.fixture
def base_turn_input() -> TurnInput:
    return TurnInput(
        language=Language.KO,
        text="테스트",
        client=ClientInfo(viewport_w=1920, viewport_h=1080),
        economy_snapshot=EconomySnapshot(signal=100, memory_shard=5),
    )


@pytest.mark.asyncio
async def test_rate_limit_error_streaming(base_turn_input):
    """429 에러 상황에서 RATE_LIMITED 에러 이벤트가 송출되는지 테스트합니다."""
    payload = base_turn_input.model_dump(mode="json")

    # Pipeline 실행 결과로 is_rate_limited=True인 컨텍스트를 반환하도록 모킹
    mock_context = PipelineContext(
        turn_input=base_turn_input,
        economy_snapshot=CurrencyAmount(signal=100, memory_shard=5),
        is_rate_limited=True,
        is_fallback=True,
        repair_attempts=2,
    )

    with patch("unknown_world.api.turn.run_pipeline", return_value=mock_context):
        response = client.post("/api/turn", json=payload)

        assert response.status_code == 200
        events = [json.loads(line) for line in response.iter_lines() if line]

        # 1. 에러 이벤트 확인
        error_events = [e for e in events if e["type"] == "error"]
        assert len(error_events) == 1
        assert error_events[0]["code"] == "RATE_LIMITED"

        # 2. RATE_LIMITED 시에는 final 이벤트가 없어야 함 (재시도 UI 유도)
        final_events = [e for e in events if e["type"] == "final"]
        assert len(final_events) == 0


@pytest.mark.asyncio
async def test_normal_error_fallback_streaming(base_turn_input):
    """일반적인 에러 상황에서는 final(폴백)이 포함되어야 함."""
    payload = base_turn_input.model_dump(mode="json")

    # Pipeline이 예외를 발생시키도록 모킹
    # run_pipeline_task 내부에서 Exception을 잡아서 create_safe_fallback을 호출함
    with patch("unknown_world.api.turn.run_pipeline", side_effect=RuntimeError("Generic Error")):
        response = client.post("/api/turn", json=payload)

        assert response.status_code == 200
        events = [json.loads(line) for line in response.iter_lines() if line]

        # 일반 에러 시에는 final(폴백) 이벤트가 포함되어야 함 (RULE-004)
        final_events = [e for e in events if e["type"] == "final"]
        assert len(final_events) == 1
        assert (
            "혼란" in final_events[0]["data"]["narrative"]
            or "confusion" in final_events[0]["data"]["narrative"].lower()
        )
</file>

<file path="backend/tests/integration/test_resolve_vision.py">
"""Unknown World - Resolve Stage 정밀분석 통합 테스트 (U-076[Mvp])."""

from unittest.mock import AsyncMock, patch

import pytest

from unknown_world.models.turn import (
    AgentPhase,
    ClientInfo,
    CurrencyAmount,
    EconomySnapshot,
    ImageJob,
    Language,
    RenderOutput,
    TurnInput,
    TurnOutput,
    UIOutput,
    WorldDelta,
)
from unknown_world.orchestrator.stages.resolve import resolve_stage
from unknown_world.orchestrator.stages.types import PipelineContext
from unknown_world.services.agentic_vision import Affordance, Box2D, VisionAnalysisResult


@pytest.fixture
def mock_emit():
    return AsyncMock()


@pytest.fixture
def base_context():
    """기본 테스트 컨텍스트."""
    economy_snap = EconomySnapshot(signal=100, memory_shard=0)
    turn_input = TurnInput(
        language=Language.KO,
        text="방을 둘러본다",
        action_id="explore",
        client=ClientInfo(viewport_w=1920, viewport_h=1080),
        economy_snapshot=economy_snap,
    )
    # 이미지가 있는 렌더 상태
    render = RenderOutput(
        image_url="/static/test_image.png",
        image_job=ImageJob(prompt="A test scene", should_generate=True),
    )
    # TurnOutput 생성
    output = TurnOutput(
        language=Language.KO,
        narrative="기본 내러티브",
        ui=UIOutput(objects=[]),
        render=render,
        world=WorldDelta(),
        economy={
            "cost": {"signal": 0, "memory_shard": 0},
            "balance_after": {"signal": 100, "memory_shard": 0},
        },
        safety={"blocked": False},
    )
    return PipelineContext(
        turn_input=turn_input,
        economy_snapshot=CurrencyAmount(
            signal=economy_snap.signal, memory_shard=economy_snap.memory_shard
        ),
        output=output,
        current_phase=AgentPhase.VALIDATE,
    )


@pytest.mark.asyncio
async def test_resolve_vision_trigger_success(base_context, mock_emit):
    """정밀분석 트리거 시 비전 서비스 호출 및 결과 반영 테스트."""
    # 트리거 액션으로 변경
    base_context.turn_input.action_id = "deep_analyze"

    # Vision 서비스 Mock
    mock_result = VisionAnalysisResult(
        affordances=[
            Affordance(label="숨겨진 상자", box_2d=Box2D(ymin=100, xmin=100, ymax=200, xmax=200))
        ],
        success=True,
    )

    with patch(
        "unknown_world.services.agentic_vision.AgenticVisionService.analyze_scene",
        new_callable=AsyncMock,
    ) as mock_analyze:
        mock_analyze.return_value = mock_result

        updated_ctx = await resolve_stage(base_context, emit=mock_emit)

        # 1. 비전 서비스 호출 확인
        mock_analyze.assert_called_once_with("/static/test_image.png", Language.KO)

        # 2. 핫스팟 추가 확인
        assert len(updated_ctx.output.ui.objects) == 1
        assert updated_ctx.output.ui.objects[0].label == "숨겨진 상자"

        # 3. 내러티브 보강 확인
        assert "장면을 자세히 살펴봅니다" in updated_ctx.output.narrative
        assert "숨겨진 상자" in updated_ctx.output.narrative

        # 4. 이미지 생성 비활성화 확인
        assert updated_ctx.output.render.image_job.should_generate is False

        # 5. 비용 배수 확인 (1.5x)
        assert updated_ctx.cost_multiplier == 1.5


@pytest.mark.asyncio
async def test_resolve_vision_no_image(base_context, mock_emit):
    """이미지가 없을 때 정밀분석 트리거 시 건너뛰기 테스트."""
    base_context.turn_input.action_id = "deep_analyze"
    base_context.output.render.image_url = None  # 이미지 없음

    with patch(
        "unknown_world.services.agentic_vision.AgenticVisionService.analyze_scene",
        new_callable=AsyncMock,
    ) as mock_analyze:
        updated_ctx = await resolve_stage(base_context, emit=mock_emit)

        # 비전 서비스가 호출되지 않아야 함
        mock_analyze.assert_not_called()
        # 핫스팟이 추가되지 않아야 함
        assert len(updated_ctx.output.ui.objects) == 0


@pytest.mark.asyncio
async def test_resolve_vision_failure_fallback(base_context, mock_emit):
    """비전 분석 실패 시 안전한 폴백 확인 (RULE-004)."""
    base_context.turn_input.action_id = "deep_analyze"

    # 실패 결과 Mock
    mock_result = VisionAnalysisResult(affordances=[], success=False, message="API Error")

    with patch(
        "unknown_world.services.agentic_vision.AgenticVisionService.analyze_scene",
        new_callable=AsyncMock,
    ) as mock_analyze:
        mock_analyze.return_value = mock_result

        updated_ctx = await resolve_stage(base_context, emit=mock_emit)

        # 핫스팟은 추가되지 않음
        assert len(updated_ctx.output.ui.objects) == 0
        # 폴백 내러티브 확인
        assert "자세히 봐도 특별한 것은 보이지 않습니다" in updated_ctx.output.narrative
        # 이미지 생성은 여전히 비활성화 (정밀분석 시도 자체로 인해)
        assert updated_ctx.output.render.image_job.should_generate is False
</file>

<file path="backend/tests/integration/test_u085_image_api.py">
"""Unknown World - U-085 이미지 API 통합 테스트."""

from fastapi.testclient import TestClient

from unknown_world.main import app
from unknown_world.services.image_generation import ImageGenerationStatus

client = TestClient(app)


def test_generate_image_endpoint_with_sdk_size():
    """/api/image/generate 엔드포인트가 SDK 크기 값을 수락하는지 테스트합니다."""
    request_data = {
        "prompt": "A futuristic city in the clouds",
        "aspect_ratio": "16:9",
        "image_size": "1K",
        "model_label": "FAST",
        "skip_on_failure": True,
    }

    response = client.post("/api/image/generate", json=request_data)

    assert response.status_code == 200
    data = response.json()
    assert data["success"] is True
    assert data["status"] == ImageGenerationStatus.COMPLETED
    assert "image_url" in data


def test_generate_image_endpoint_with_legacy_size():
    """/api/image/generate 엔드포인트가 레거시 크기 값을 수락하고 정규화하는지 테스트합니다."""
    request_data = {
        "prompt": "A futuristic city in the clouds",
        "aspect_ratio": "1:1",
        "image_size": "1024x1024",
        "model_label": "FAST",
        "skip_on_failure": True,
    }

    response = client.post("/api/image/generate", json=request_data)

    assert response.status_code == 200
    data = response.json()
    assert data["success"] is True
    # 백엔드 내부에서 1K로 정규화되어 처리됨


def test_generate_image_endpoint_invalid_size():
    """/api/image/generate 엔드포인트가 잘못된 크기 값에 대해 에러를 반환하는지 테스트합니다."""
    request_data = {
        "prompt": "A futuristic city in the clouds",
        "aspect_ratio": "16:9",
        "image_size": "unknown_size",
        "model_label": "FAST",
        "skip_on_failure": False,  # 에러 발생을 위해 False 설정
    }

    response = client.post("/api/image/generate", json=request_data)

    assert response.status_code == 400
    assert "지원하지 않는 이미지 크기" in response.json()["detail"]


def test_image_health_endpoint():
    """/api/image/health 엔드포인트 테스트."""
    response = client.get("/api/image/health")
    assert response.status_code == 200
    data = response.json()
    assert data["status"] == "ok"
    assert "mode" in data
    assert data["model"] == "gemini-3-pro-image-preview"
</file>

<file path="backend/tests/qa/test_asset_manifest.py">
import json
import os

import pytest
from jsonschema import validate

# Paths
# This file is in backend/tests/qa/
# We go up 3 levels to get to backend root: backend/tests/qa -> backend/tests -> backend -> root (wait, backend is in root)
# Actually:
# __file__ = D:\Dev\unknown-world\backend\tests\qa\test_asset_manifest.py
# os.path.dirname(__file__) = D:\Dev\unknown-world\backend\tests\qa
# ... up 1 = tests
# ... up 2 = backend
# ... up 3 = unknown-world (project root)

CURRENT_DIR = os.path.dirname(os.path.abspath(__file__))
PROJECT_ROOT = os.path.dirname(os.path.dirname(os.path.dirname(CURRENT_DIR)))

# If PROJECT_ROOT is correct, it should contain frontend/
FRONTEND_UI_DIR = os.path.join(PROJECT_ROOT, "frontend", "public", "ui")
MANIFEST_PATH = os.path.join(FRONTEND_UI_DIR, "manifest.json")
SCHEMA_PATH = os.path.join(FRONTEND_UI_DIR, "manifest.schema.json")


def test_manifest_schema_validation():
    """Validates manifest.json against manifest.schema.json"""
    if not os.path.exists(MANIFEST_PATH):
        pytest.fail(f"Manifest not found at {MANIFEST_PATH}")
    if not os.path.exists(SCHEMA_PATH):
        pytest.fail(f"Schema not found at {SCHEMA_PATH}")

    with open(MANIFEST_PATH, encoding="utf-8") as f:
        manifest = json.load(f)

    with open(SCHEMA_PATH, encoding="utf-8") as f:
        schema = json.load(f)

    # validate raises ValidationError on failure
    validate(instance=manifest, schema=schema)


def test_asset_files_existence_and_size():
    """Checks if assets listed in manifest exist and sizes match/budget"""
    with open(MANIFEST_PATH, encoding="utf-8") as f:
        manifest = json.load(f)

    assets = manifest.get("assets", [])
    total_bytes_calculated = 0

    for asset in assets:
        rel_path = asset["path"]
        abs_path = os.path.join(FRONTEND_UI_DIR, rel_path)

        # 1. Existence Check
        assert os.path.exists(abs_path), f"Asset file missing: {rel_path} (full: {abs_path})"

        # 2. Size Check
        actual_size = os.path.getsize(abs_path)
        recorded_size = asset.get("bytes")

        # Note: If size mismatches, we print a helpful message.
        # In a real QA scenario, we might want to auto-update, but for this test we fail.
        if recorded_size is not None:
            assert actual_size == recorded_size, (
                f"Size mismatch for {rel_path}: actual {actual_size} != manifest {recorded_size}"
            )

        total_bytes_calculated += actual_size

        # 3. Individual Budget Check (from QA_CHECKLIST.md)
        asset_type = asset["type"]
        if asset_type in ("icon", "item-icon"):
            # 30KB limit
            assert actual_size <= 30 * 1024, (
                f"Icon {rel_path} exceeds 30KB budget ({actual_size} bytes)"
            )
        elif asset_type == "placeholder":
            # 300KB limit
            assert actual_size <= 300 * 1024, (
                f"Placeholder {rel_path} exceeds 300KB budget ({actual_size} bytes)"
            )
        elif asset_type == "chrome":
            # 120KB limit (increased for scanner-frame)
            assert actual_size <= 120 * 1024, (
                f"Chrome asset {rel_path} exceeds 120KB budget ({actual_size} bytes)"
            )

    # 4. Total Budget Check
    recorded_total = manifest.get("totalBytes")
    if recorded_total is not None:
        assert total_bytes_calculated == recorded_total, (
            f"Total bytes mismatch: calculated {total_bytes_calculated} != manifest {recorded_total}"
        )

    budget_total = manifest.get("budgetBytes", 1572864)
    assert total_bytes_calculated <= budget_total, (
        f"Total size {total_bytes_calculated} exceeds budget {budget_total}"
    )


def test_asset_naming_convention():
    """Checks if asset IDs and paths use kebab-case"""
    with open(MANIFEST_PATH, encoding="utf-8") as f:
        manifest = json.load(f)

    for asset in manifest["assets"]:
        asset_id = asset["id"]
        # Check for lowercase and kebab-case (allow numbers)
        assert asset_id.islower(), f"Asset ID {asset_id} should be lowercase"
        assert " " not in asset_id, f"Asset ID {asset_id} should not contain spaces"
        assert "_" not in asset_id, (
            f"Asset ID {asset_id} should not contain underscores (use kebab-case)"
        )
</file>

<file path="backend/tests/qa/test_u052_manual_verification.py">
"""U-052[Mvp]: 조건부 이미지 생성 제어 로직 수동 검증 스크립트.

이 스크립트는 런북의 시나리오 A, B, C, D를 실행하고 로그 출력을 확인합니다.
특히 RULE-007(프롬프트 해시)과 RULE-005(잔액 부족 폴백)를 중점적으로 확인합니다.
"""

import logging
import sys

from unknown_world.models.turn import (
    CurrencyAmount,
    EconomyOutput,
    EconomySnapshot,
    ImageJob,
    Language,
    RenderOutput,
    SafetyOutput,
    TurnOutput,
)
from unknown_world.orchestrator.stages.render_helpers import decide_image_generation

# 로그 설정 (표준 출력으로 로그 출력)
logging.basicConfig(level=logging.DEBUG, format="%(levelname)s - %(message)s", stream=sys.stdout)
logger = logging.getLogger("U-052-Verification")


def print_separator(title):
    print("\n" + "=" * 60)
    print(f"  SCENARIO: {title}")
    print("=" * 60)


def run_verification():
    # -------------------------------------------------------------------------
    # 시나리오 A: 이미지 생성 승인 (should_generate=true, 잔액 충분)
    # -------------------------------------------------------------------------
    print_separator("A: Image Generation Approved")
    turn_output_a = TurnOutput(
        language=Language.KO,
        narrative="어두운 숲길에 들어섰다.",
        economy=EconomyOutput(
            cost=CurrencyAmount(signal=5, memory_shard=0),
            balance_after=CurrencyAmount(signal=95, memory_shard=5),
        ),
        safety=SafetyOutput(blocked=False),
        render=RenderOutput(
            image_job=ImageJob(
                should_generate=True,
                prompt="A dark forest path with moonlight filtering through the trees",
                aspect_ratio="16:9",
            )
        ),
    )
    economy_a = EconomySnapshot(signal=100, memory_shard=5)

    logger.info("Starting Scenario A...")
    decision_a = decide_image_generation(turn_output_a, economy_a, "ko-KR")

    print(f"\nResult: should_generate={decision_a.should_generate}")
    print(f"Reason: {decision_a.reason}")
    print(f"Prompt Hash: {decision_a.prompt_hash}")

    # -------------------------------------------------------------------------
    # 시나리오 B: 이미지 생성 미요청 (should_generate=false)
    # -------------------------------------------------------------------------
    print_separator("B: Image Generation Not Requested")
    turn_output_b = TurnOutput(
        language=Language.KO,
        narrative="방 안을 둘러보았다.",
        economy=EconomyOutput(
            cost=CurrencyAmount(signal=3, memory_shard=0),
            balance_after=CurrencyAmount(signal=97, memory_shard=5),
        ),
        safety=SafetyOutput(blocked=False),
        render=RenderOutput(image_job=ImageJob(should_generate=False, prompt="")),
    )
    economy_b = EconomySnapshot(signal=100, memory_shard=5)

    logger.info("Starting Scenario B...")
    decision_b = decide_image_generation(turn_output_b, economy_b, "ko-KR")

    print(f"\nResult: should_generate={decision_b.should_generate}")
    print(f"Reason: {decision_b.reason}")

    # -------------------------------------------------------------------------
    # 시나리오 C: 잔액 부족 (RULE-005)
    # -------------------------------------------------------------------------
    print_separator("C: Insufficient Balance (RULE-005)")
    turn_output_c = TurnOutput(
        language=Language.KO,
        narrative="보물 상자를 발견했다!",
        economy=EconomyOutput(
            cost=CurrencyAmount(signal=3, memory_shard=0),
            balance_after=CurrencyAmount(signal=5, memory_shard=0),
        ),
        safety=SafetyOutput(blocked=False),
        render=RenderOutput(
            image_job=ImageJob(should_generate=True, prompt="A golden treasure chest")
        ),
    )
    economy_c = EconomySnapshot(signal=5, memory_shard=0)

    logger.info(f"Starting Scenario C (Balance: {economy_c.signal} Signal)...")
    decision_c = decide_image_generation(turn_output_c, economy_c, "ko-KR")

    print(f"\nResult: should_generate={decision_c.should_generate}")
    print(f"Reason: {decision_c.reason}")
    print(f"Fallback Message: {decision_c.fallback_message}")

    # -------------------------------------------------------------------------
    # 시나리오 D: 빈 프롬프트 방어
    # -------------------------------------------------------------------------
    print_separator("D: Empty Prompt Defense")
    turn_output_d = TurnOutput(
        language=Language.EN,
        narrative="You entered the dungeon.",
        economy=EconomyOutput(
            cost=CurrencyAmount(signal=5, memory_shard=0),
            balance_after=CurrencyAmount(signal=95, memory_shard=5),
        ),
        safety=SafetyOutput(blocked=False),
        render=RenderOutput(image_job=ImageJob(should_generate=True, prompt="   ")),
    )
    economy_d = EconomySnapshot(signal=100, memory_shard=5)

    logger.info("Starting Scenario D...")
    decision_d = decide_image_generation(turn_output_d, economy_d, "en-US")

    print(f"\nResult: should_generate={decision_d.should_generate}")
    print(f"Reason: {decision_d.reason}")


if __name__ == "__main__":
    run_verification()
</file>

<file path="backend/tests/unit/models/test_turn.py">
"""TurnInput/TurnOutput 모델 단위 테스트."""

import pytest
from pydantic import ValidationError

from unknown_world.models.turn import (
    AgentConsole,
    Box2D,
    CurrencyAmount,
    EconomyOutput,
    Language,
    RenderOutput,
    TurnInput,
    TurnOutput,
    UIOutput,
    WorldDelta,
)

# =============================================================================
# Fixtures
# =============================================================================


@pytest.fixture
def valid_box_2d():
    return {"ymin": 100, "xmin": 200, "ymax": 300, "xmax": 400}


@pytest.fixture
def valid_currency_amount():
    return {"signal": 100, "memory_shard": 5}


@pytest.fixture
def valid_client_info():
    return {"viewport_w": 1920, "viewport_h": 1080, "theme": "dark"}


@pytest.fixture
def valid_turn_input_data(valid_client_info, valid_currency_amount):
    return {
        "language": "ko-KR",
        "text": "Hello",
        "client": valid_client_info,
        "economy_snapshot": valid_currency_amount,
    }


@pytest.fixture
def valid_turn_output_data(valid_currency_amount):
    return {
        "language": "ko-KR",
        "narrative": "Story continues...",
        "economy": {
            "cost": {"signal": 10, "memory_shard": 0},
            "balance_after": {"signal": 90, "memory_shard": 5},
        },
        "safety": {"blocked": False},
    }


# =============================================================================
# Coordinate & Box2D Tests
# =============================================================================


def test_box_2d_valid(valid_box_2d):
    box = Box2D(**valid_box_2d)
    assert box.ymin == 100
    assert box.xmax == 400


def test_box_2d_invalid_coordinate():
    with pytest.raises(ValidationError):
        # Out of range (ge=0, le=1000)
        Box2D(ymin=-1, xmin=0, ymax=1001, xmax=500)


def test_box_2d_extra_forbidden():
    with pytest.raises(ValidationError):
        Box2D(ymin=0, xmin=0, ymax=100, xmax=100, extra_field="not allowed")


# =============================================================================
# Currency & Economy Tests
# =============================================================================


def test_currency_amount_valid(valid_currency_amount):
    amount = CurrencyAmount(**valid_currency_amount)
    assert amount.signal == 100


def test_currency_amount_negative_fails():
    with pytest.raises(ValidationError):
        CurrencyAmount(signal=-1, memory_shard=0)


def test_economy_output_valid():
    data = {
        "cost": {"signal": 5, "memory_shard": 0},
        "balance_after": {"signal": 95, "memory_shard": 5},
    }
    economy = EconomyOutput(**data)
    assert economy.cost.signal == 5
    assert economy.balance_after.signal == 95


# =============================================================================
# TurnInput Tests
# =============================================================================


def test_turn_input_valid(valid_turn_input_data):
    turn_input = TurnInput(**valid_turn_input_data)
    assert turn_input.language == Language.KO
    assert turn_input.text == "Hello"


def test_turn_input_with_click(valid_turn_input_data, valid_box_2d):
    data = valid_turn_input_data.copy()
    data["click"] = {"object_id": "door_01", "box_2d": valid_box_2d}
    turn_input = TurnInput(**data)
    assert turn_input.click.object_id == "door_01"
    assert turn_input.click.box_2d.ymin == 100


def test_turn_input_invalid_language():
    with pytest.raises(ValidationError):
        TurnInput(
            language="fr-FR",  # Not in Language enum
            text="...",
            client={"viewport_w": 800, "viewport_h": 600},
            economy_snapshot={"signal": 0, "memory_shard": 0},
        )


# =============================================================================
# TurnOutput Tests
# =============================================================================


def test_turn_output_valid_minimal(valid_turn_output_data):
    turn_output = TurnOutput(**valid_turn_output_data)
    assert turn_output.language == Language.KO
    assert turn_output.narrative == "Story continues..."
    # Check defaults
    assert isinstance(turn_output.ui, UIOutput)
    assert isinstance(turn_output.world, WorldDelta)
    assert isinstance(turn_output.render, RenderOutput)
    assert isinstance(turn_output.agent_console, AgentConsole)


def test_turn_output_full(valid_currency_amount, valid_box_2d):
    data = {
        "language": "en-US",
        "narrative": "Narrative text",
        "ui": {
            "action_deck": {
                "cards": [
                    {
                        "id": "c1",
                        "label": "Action 1",
                        "cost": {"signal": 5, "memory_shard": 0},
                    }
                ]
            },
            "objects": [{"id": "obj1", "label": "Object 1", "box_2d": valid_box_2d}],
        },
        "world": {
            "inventory_added": [
                {
                    "id": "key",
                    "label": "열쇠",
                    "description": "낡은 철제 열쇠입니다.",
                    "quantity": 1,
                }
            ],
            "rules_changed": [{"id": "r1", "label": "Gravity", "description": "Low gravity"}],
            "quests_updated": [{"id": "q1", "label": "Find key", "is_completed": False}],
            "memory_pins": [
                {"id": "p1", "content": "Fact", "cost": {"signal": 1, "memory_shard": 0}}
            ],
        },
        "render": {
            "image_job": {
                "should_generate": True,
                "prompt": "A landscape",
                "model_label": "QUALITY",
            }
        },
        "economy": {
            "cost": {"signal": 10, "memory_shard": 0},
            "balance_after": {"signal": 90, "memory_shard": 5},
        },
        "safety": {"blocked": False},
        "agent_console": {"repair_count": 1, "badges": ["schema_ok", "economy_ok"]},
    }
    turn_output = TurnOutput(**data)
    assert turn_output.language == Language.EN
    assert len(turn_output.ui.action_deck.cards) == 1
    assert turn_output.render.image_job.should_generate is True


def test_turn_output_missing_required():
    with pytest.raises(ValidationError):
        # Missing economy and safety
        TurnOutput(language="ko-KR", narrative="...")


# =============================================================================
# JSON Schema Tests
# =============================================================================


def test_turn_output_json_schema():
    schema = TurnOutput.model_json_schema()
    assert schema["type"] == "object"
    assert "language" in schema["required"]
    assert "narrative" in schema["required"]
    assert "economy" in schema["required"]
    assert "safety" in schema["required"]

    # Check Coordinate constraints in schema
    # Pydantic 2 schema structure: properties -> language -> ...
    # Coordinate might be in $defs or inline depending on how it's used
    ui_props = schema["$defs"]["UIOutput"]["properties"]
    assert "action_deck" in ui_props

    # Verify that Coordinate (int with ge/le) is correctly represented
    # Box2D uses Coordinate
    box_props = schema["$defs"]["Box2D"]["properties"]
    assert box_props["ymin"]["maximum"] == 1000
    assert box_props["ymin"]["minimum"] == 0
</file>

<file path="backend/tests/unit/models/test_u078_objectives.py">
"""U-078 목표 시스템 강화 - Quest 모델 및 비즈니스 로직 단위 테스트."""

import pytest
from pydantic import ValidationError

from unknown_world.models.turn import Quest, TurnOutput, WorldDelta


def test_quest_model_u078_fields():
    """Quest 모델의 U-078 신규 필드 검증."""
    data = {
        "id": "main_01",
        "label": "주 목표",
        "description": "상세 설명",
        "is_main": True,
        "progress": 50,
        "reward_signal": 100,
    }
    quest = Quest(**data)
    assert quest.id == "main_01"
    assert quest.is_main is True
    assert quest.progress == 50
    assert quest.reward_signal == 100
    assert quest.is_completed is False


def test_quest_progress_range():
    """진행률(progress) 범위 검증 (0~100)."""
    # 0 OK
    Quest(id="q", label="l", progress=0)
    # 100 OK
    Quest(id="q", label="l", progress=100)

    # -1 Fail
    with pytest.raises(ValidationError):
        Quest(id="q", label="l", progress=-1)

    # 101 Fail
    with pytest.raises(ValidationError):
        Quest(id="q", label="l", progress=101)


def test_quest_reward_signal_non_negative():
    """보상(reward_signal) 0 이상 검증."""
    Quest(id="q", label="l", reward_signal=0)
    Quest(id="q", label="l", reward_signal=100)

    with pytest.raises(ValidationError):
        Quest(id="q", label="l", reward_signal=-1)


def test_world_delta_quests_updated_limit():
    """WorldDelta의 quests_updated 최대 크기 제한 검증 (max_length=3)."""
    quests = [Quest(id=f"q{i}", label=f"l{i}") for i in range(3)]
    # 3개 OK
    WorldDelta(quests_updated=quests)

    # 4개 Fail
    with pytest.raises(ValidationError):
        WorldDelta(quests_updated=quests + [Quest(id="q4", label="l4")])


def test_turn_output_with_u078_objectives():
    """TurnOutput에 포함된 U-078 목표 데이터 검증."""
    data = {
        "language": "ko-KR",
        "narrative": "목표가 업데이트되었습니다.",
        "economy": {
            "cost": {"signal": 0, "memory_shard": 0},
            "balance_after": {"signal": 100, "memory_shard": 5},
        },
        "safety": {"blocked": False},
        "world": {
            "quests_updated": [
                {
                    "id": "main",
                    "label": "주 목표",
                    "is_main": True,
                    "progress": 25,
                    "reward_signal": 50,
                },
                {"id": "sub", "label": "서브 목표", "is_completed": True, "reward_signal": 10},
            ]
        },
    }
    output = TurnOutput(**data)
    quests = output.world.quests_updated
    assert len(quests) == 2
    assert quests[0].is_main is True
    assert quests[1].is_completed is True
    assert quests[1].reward_signal == 10
</file>

<file path="backend/tests/unit/orchestrator/test_conversation_history.py">
"""Unit tests for ConversationHistory module (U-127)."""

from unittest.mock import patch

import pytest

from unknown_world.orchestrator.conversation_history import (
    ConversationHistory,
    build_model_content_summary,
    get_conversation_history,
    reset_all_histories,
    reset_conversation_history,
)


@pytest.fixture
def history():
    reset_all_histories()
    return ConversationHistory()


def test_add_turn_and_get_contents(history):
    """Test adding turns and retrieving them in Gemini contents format."""
    # Use valid base64 for thought signature to test decoding
    import base64

    sig_content = b"valid_signature"
    sig_b64 = base64.b64encode(sig_content).decode("utf-8")

    history.add_turn(
        user_content="Open the door", model_content="The door opens.", thought_signature=sig_b64
    )

    contents = history.get_contents()
    assert len(contents) == 2
    assert contents[0]["role"] == "user"
    assert contents[0]["parts"][0]["text"] == "Open the door"
    assert contents[1]["role"] == "model"
    assert contents[1]["parts"][0]["text"] == "The door opens."
    # Should be decoded back to bytes
    assert contents[1]["parts"][0]["thoughtSignature"] == sig_content


def test_sliding_window(history):
    """Test that old turns are removed when exceeding max turns."""
    # Mock environment variable or internal getter if possible,
    # but here we rely on the default (5) or set env var.
    # We'll use a loop to add more than default 5 turns.

    max_turns = 5
    for i in range(max_turns + 2):
        history.add_turn(f"User {i}", f"Model {i}")

    contents = history.get_contents()
    assert len(contents) == max_turns * 2  # user + model per turn

    # Should contain User 2 to User 6 (if 0-based index and total 7 items)
    # Actually if we added 0,1,2,3,4,5,6 (7 items). Last 5 are 2,3,4,5,6.
    assert contents[0]["parts"][0]["text"] == "User 2"
    assert contents[-2]["parts"][0]["text"] == "User 6"


def test_token_budget_trimming(history):
    """Test that turns are trimmed based on token budget."""
    # Mock token budget to be very small
    with patch("unknown_world.orchestrator.conversation_history._get_max_tokens", return_value=10):
        # "Long text..." is about 12 chars -> ~4 tokens per message.
        # Turn = User(4) + Model(4) = 8 tokens.
        # 2 turns = 16 tokens > 10. Should keep only 1 turn.

        history.add_turn("Long text A", "Long response A")
        history.add_turn("Long text B", "Long response B")

        contents = history.get_contents()
        assert len(contents) == 2  # Only 1 turn (user+model) left
        assert contents[0]["parts"][0]["text"] == "Long text B"


def test_build_model_content_summary():
    """Test summary builder with world delta."""
    narrative = "You found a sword."
    delta = {
        "inventory_added": [{"label": "Sword"}],
        "inventory_removed": ["Old Dagger"],
        "rules_added": ["New Rule"],
    }

    summary = build_model_content_summary(narrative, delta)
    assert "You found a sword." in summary
    assert "[상태 변화:" in summary
    assert "획득: Sword" in summary
    assert "소모: Old Dagger" in summary
    assert "규칙 추가: 1개" in summary


def test_session_management():
    """Test session isolation."""
    h1 = get_conversation_history("session1")
    h2 = get_conversation_history("session2")

    h1.add_turn("U1", "M1")

    assert h1.turn_count == 1
    assert h2.turn_count == 0

    reset_conversation_history("session1")
    assert h1.turn_count == 0


def test_thought_signature_handling(history):
    """Test handling of thought signatures."""
    # Base64 encoded string
    import base64

    sig_bytes = b"binary_signature"
    sig_b64 = base64.b64encode(sig_bytes).decode("utf-8")

    history.add_turn("U", "M", thought_signature=sig_b64)
    contents = history.get_contents()

    # Should be decoded back to bytes
    assert contents[1]["parts"][0]["thoughtSignature"] == sig_bytes

    # Non-base64 string (should fallback to string)
    history.clear()
    history.add_turn("U", "M", thought_signature="plain_string")
    contents = history.get_contents()
    assert contents[1]["parts"][0]["thoughtSignature"] == "plain_string"
</file>

<file path="backend/tests/unit/orchestrator/test_repair_loop.py">
from unittest.mock import AsyncMock, patch

import pytest

from unknown_world.models.turn import (
    ClientInfo,
    EconomySnapshot,
    Language,
    Theme,
    TurnInput,
    TurnOutput,
)
from unknown_world.orchestrator.generate_turn_output import (
    GenerationResult,
    GenerationStatus,
)
from unknown_world.orchestrator.repair_loop import run_repair_loop


@pytest.fixture
def turn_input() -> TurnInput:
    return TurnInput(
        language=Language.KO,
        text="문을 열어본다",
        client=ClientInfo(viewport_w=1920, viewport_h=1080, theme=Theme.DARK),
        economy_snapshot=EconomySnapshot(signal=100, memory_shard=5),
    )


@pytest.fixture
def valid_turn_output_dict() -> dict:
    return {
        "language": "ko-KR",
        "narrative": "낡은 문이 열리고 먼지가 날립니다.",
        "economy": {
            "cost": {"signal": 5, "memory_shard": 0},
            "balance_after": {"signal": 95, "memory_shard": 5},
            "credit": 0,
            "low_balance_warning": False,
        },
        "safety": {"blocked": False, "message": None},
        "ui": {"action_deck": {"cards": []}, "objects": []},
        "world": {
            "rules_changed": [],
            "inventory_added": [],
            "inventory_removed": [],
            "quests_updated": [],
            "relationships_changed": [],
            "memory_pins": [],
        },
        "render": {
            "image_job": None,
            "image_url": None,
            "image_id": None,
            "generation_time_ms": None,
        },
        "agent_console": {
            "current_phase": "commit",
            "badges": ["schema_ok", "economy_ok", "safety_ok"],
            "repair_count": 0,
            "model_label": "FAST",
        },
    }


@pytest.fixture
def valid_turn_output(valid_turn_output_dict) -> TurnOutput:
    return TurnOutput.model_validate(valid_turn_output_dict)


@pytest.mark.asyncio
async def test_repair_loop_success_first_attempt(turn_input, valid_turn_output):
    with patch("unknown_world.orchestrator.repair_loop.get_turn_output_generator") as mock_get_gen:
        mock_generator = AsyncMock()
        mock_generator.generate.return_value = GenerationResult(
            status=GenerationStatus.SUCCESS,
            output=valid_turn_output,
            model_label="QUALITY",
            cost_multiplier=2.0,
        )
        mock_get_gen.return_value = mock_generator
        result = await run_repair_loop(turn_input)
        assert result.total_attempts == 1
        assert result.is_fallback is False
        assert result.is_rate_limited is False


@pytest.mark.asyncio
async def test_repair_loop_api_error_pro_to_flash_success(turn_input, valid_turn_output):
    with (
        patch("unknown_world.orchestrator.repair_loop.get_turn_output_generator") as mock_get_gen,
        patch("unknown_world.orchestrator.repair_loop.TurnOutputGenerator") as mock_flash_gen_class,
        patch("asyncio.sleep", return_value=None),
    ):
        mock_pro_generator = AsyncMock()
        mock_pro_generator.generate.return_value = GenerationResult(
            status=GenerationStatus.API_ERROR,
            error_message="Pro API Rate Limit",
            model_label="QUALITY",
        )
        mock_get_gen.return_value = mock_pro_generator

        mock_flash_generator = AsyncMock()
        mock_flash_generator.generate.return_value = GenerationResult(
            status=GenerationStatus.SUCCESS,
            output=valid_turn_output,
            model_label="FAST",
            cost_multiplier=1.0,
        )
        mock_flash_gen_class.return_value = mock_flash_generator

        result = await run_repair_loop(turn_input)
        assert result.total_attempts == 2
        assert result.is_rate_limited is False
        assert result.model_label == "FAST"


@pytest.mark.asyncio
async def test_repair_loop_rate_limited_final_failure(turn_input):
    with (
        patch("unknown_world.orchestrator.repair_loop.get_turn_output_generator") as mock_get_gen,
        patch("unknown_world.orchestrator.repair_loop.TurnOutputGenerator") as mock_flash_gen_class,
        patch("asyncio.sleep", return_value=None),
    ):
        mock_pro_generator = AsyncMock()
        mock_pro_generator.generate.return_value = GenerationResult(
            status=GenerationStatus.API_ERROR,
            error_message="Pro 429",
            model_label="QUALITY",
        )
        mock_get_gen.return_value = mock_pro_generator

        mock_flash_generator = AsyncMock()
        mock_flash_generator.generate.return_value = GenerationResult(
            status=GenerationStatus.API_ERROR, error_message="Flash 429", model_label="FAST"
        )
        mock_flash_gen_class.return_value = mock_flash_generator

        result = await run_repair_loop(turn_input)
        assert result.total_attempts == 3
        assert result.is_fallback is True
        assert result.is_rate_limited is True


@pytest.mark.asyncio
async def test_repair_loop_schema_failure_not_rate_limited(turn_input):
    with patch("unknown_world.orchestrator.repair_loop.get_turn_output_generator") as mock_get_gen:
        mock_generator = AsyncMock()
        mock_generator.generate.return_value = GenerationResult(
            status=GenerationStatus.SCHEMA_FAILURE, error_message="Invalid JSON", model_label="FAST"
        )
        mock_get_gen.return_value = mock_generator
        result = await run_repair_loop(turn_input)
        assert result.is_fallback is True
        assert result.is_rate_limited is False
</file>

<file path="backend/tests/unit/orchestrator/test_u051_bridge.py">
"""U-051[Mvp] 렌더링 단계-이미지 생성 서비스 브릿지 구축 테스트.

검증 항목:
    - PipelineContext에 image_generator 필드 존재 및 주입 가능 여부
    - create_pipeline_context 호출 시 이미지 생성기 자동 획득 (Option A)
    - render_stage에서 주입된 이미지 생성기 접근 가능 여부
    - RULE-008: 단계 이벤트 일관성 유지
"""

from unittest.mock import MagicMock

import pytest

from unknown_world.models.turn import AgentPhase, ClientInfo, EconomySnapshot, Language, TurnInput
from unknown_world.orchestrator.pipeline import create_pipeline_context
from unknown_world.orchestrator.stages.render import render_stage
from unknown_world.orchestrator.stages.types import PipelineEvent, PipelineEventType
from unknown_world.services.image_generation import MockImageGenerator


@pytest.fixture
def turn_input() -> TurnInput:
    return TurnInput(
        language=Language.KO,
        text="테스트 입력",
        economy_snapshot=EconomySnapshot(signal=100, memory_shard=10),
        client=ClientInfo(viewport_w=1920, viewport_h=1080),
    )


def test_pipeline_context_image_generator_injection(turn_input):
    """PipelineContext에 이미지 생성기가 명시적으로 주입되는지 확인."""
    mock_gen = MagicMock(spec=MockImageGenerator)
    ctx = create_pipeline_context(turn_input, image_generator=mock_gen)

    assert ctx.image_generator == mock_gen


def test_create_pipeline_context_default_generator(turn_input):
    """image_generator를 전달하지 않았을 때 get_image_generator()를 통해 자동 획득하는지 확인.

    현재 구현은 None을 반환하므로 이 테스트는 실패해야 함 (Red 단계).
    """
    # get_image_generator를 모킹하여 호출 여부 확인
    with pytest.MonkeyPatch.context() as mp:
        mock_get_gen = MagicMock()
        mp.setattr("unknown_world.orchestrator.pipeline.get_image_generator", mock_get_gen)

        ctx = create_pipeline_context(turn_input)

        # 현재 구현에서는 mock_get_gen.called 가 False이고 ctx.image_generator가 None일 것임
        assert mock_get_gen.called, "get_image_generator()가 호출되어야 함"
        assert ctx.image_generator == mock_get_gen.return_value


@pytest.mark.asyncio
async def test_render_stage_uses_injected_generator(turn_input):
    """render_stage가 주입된 이미지 생성기를 올바르게 인식하는지 확인."""
    mock_gen = MagicMock(spec=MockImageGenerator)
    mock_gen.is_available.return_value = True

    ctx = create_pipeline_context(turn_input, image_generator=mock_gen)

    events = []

    async def emit(event: PipelineEvent):
        events.append(event)

    ctx = await render_stage(ctx, emit=emit)

    # 1. 상태 전이 및 이벤트 확인
    assert ctx.current_phase == AgentPhase.RENDER
    assert len(events) == 2
    assert events[0].event_type == PipelineEventType.STAGE_START
    assert events[1].event_type == PipelineEventType.STAGE_COMPLETE

    # 2. 이미지 생성기 호출 확인 (is_available 호출 여부로 간접 확인)
    assert mock_gen.is_available.called
</file>

<file path="backend/tests/unit/orchestrator/test_u052_render_integration.py">
"""U-052[Mvp]: 조건부 이미지 생성 제어 로직 통합 테스트.

render_stage에서 decide_image_generation이 올바르게 호출되고
판정 로직이 파이프라인 흐름에 통합되었는지 검증합니다.
"""

from unittest.mock import AsyncMock, MagicMock

import pytest

from unknown_world.models.turn import (
    ClientInfo,
    CurrencyAmount,
    EconomyOutput,
    EconomySnapshot,
    ImageJob,
    Language,
    RenderOutput,
    SafetyOutput,
    TurnInput,
    TurnOutput,
)
from unknown_world.orchestrator.stages.render import render_stage
from unknown_world.orchestrator.stages.types import PipelineContext, PipelineEventType


@pytest.fixture
def mock_emit():
    """이벤트 emit을 위한 모의 함수."""
    return AsyncMock()


@pytest.fixture
def mock_generator():
    """이미지 생성기 모의 객체."""
    generator = MagicMock()
    generator.is_available.return_value = True
    return generator


@pytest.mark.asyncio
async def test_render_stage_integration_with_image_job(mock_emit, mock_generator):
    """ImageJob이 있을 때 render_stage가 판정 로직을 수행하는지 확인."""
    # 1. 준비
    turn_input = TurnInput(
        language=Language.KO,
        text="숲으로 간다",
        economy_snapshot=EconomySnapshot(signal=100, memory_shard=5),
        client=ClientInfo(viewport_w=1920, viewport_h=1080),
    )

    turn_output = TurnOutput(
        language=Language.KO,
        narrative="어두운 숲이다.",
        economy=EconomyOutput(
            cost=CurrencyAmount(signal=5, memory_shard=0),
            balance_after=CurrencyAmount(signal=95, memory_shard=5),
        ),
        safety=SafetyOutput(blocked=False),
        render=RenderOutput(
            image_job=ImageJob(should_generate=True, prompt="A dark forest", aspect_ratio="16:9")
        ),
    )

    ctx = PipelineContext(
        turn_input=turn_input,
        economy_snapshot=CurrencyAmount(signal=100, memory_shard=5),
        output=turn_output,
        image_generator=mock_generator,
    )

    # 2. 실행
    result_ctx = await render_stage(ctx, emit=mock_emit)

    # 3. 검증
    # Stage 이벤트가 발생했는지 확인
    assert mock_emit.call_count >= 2
    event_types = [call.args[0].event_type for call in mock_emit.call_args_list]
    assert PipelineEventType.STAGE_START in event_types
    assert PipelineEventType.STAGE_COMPLETE in event_types

    # 컨텍스트가 유지되었는지 확인
    assert result_ctx.output == turn_output
    assert result_ctx.image_generator == mock_generator


@pytest.mark.asyncio
async def test_render_stage_integration_insufficient_balance(mock_emit, mock_generator):
    """잔액 부족 시 render_stage가 정상적으로 흐름을 유지하는지 확인."""
    # 1. 준비 (잔액 5, 필요 10)
    turn_input = TurnInput(
        language=Language.KO,
        text="숲으로 간다",
        economy_snapshot=EconomySnapshot(signal=5, memory_shard=0),
        client=ClientInfo(viewport_w=1920, viewport_h=1080),
    )

    turn_output = TurnOutput(
        language=Language.KO,
        narrative="어두운 숲이다.",
        economy=EconomyOutput(
            cost=CurrencyAmount(signal=0, memory_shard=0),
            balance_after=CurrencyAmount(signal=5, memory_shard=0),
        ),
        safety=SafetyOutput(blocked=False),
        render=RenderOutput(image_job=ImageJob(should_generate=True, prompt="A forest")),
    )

    ctx = PipelineContext(
        turn_input=turn_input,
        economy_snapshot=CurrencyAmount(signal=5, memory_shard=0),
        output=turn_output,
        image_generator=mock_generator,
    )

    # 2. 실행
    result_ctx = await render_stage(ctx, emit=mock_emit)

    # 3. 검증
    assert mock_emit.call_count >= 2
    # 현재 단계(U-052)에서는 pass-through이므로 output이 변하지 않아야 함
    # (폴백 메시지 반영은 U-054 예정)
    assert result_ctx.output.render.image_job.should_generate is True


@pytest.mark.asyncio
async def test_render_stage_no_generator(mock_emit):
    """이미지 생성기가 없을 때 pass-through 동작 확인."""
    # 1. 준비
    turn_input = TurnInput(
        language=Language.KO,
        text="테스트",
        economy_snapshot=EconomySnapshot(signal=100, memory_shard=5),
        client=ClientInfo(viewport_w=1920, viewport_h=1080),
    )

    ctx = PipelineContext(
        turn_input=turn_input,
        economy_snapshot=CurrencyAmount(signal=100, memory_shard=5),
        output=None,
        image_generator=None,
    )

    # 2. 실행
    result_ctx = await render_stage(ctx, emit=mock_emit)

    # 3. 검증
    assert result_ctx.image_generator is None
    event_types = [call.args[0].event_type for call in mock_emit.call_args_list]
    assert PipelineEventType.STAGE_COMPLETE in event_types
</file>

<file path="backend/tests/unit/orchestrator/test_u054_image_fallback.py">
"""U-054: 이미지 생성 폴백 및 실패 복구 체계 강화 테스트.

검증 항목:
- 시나리오 1: 이미지 생성 성공 (Happy Path)
- 시나리오 2: 안전 정책 차단 (Safety Blocked) -> safety.blocked=True, 배지 반영
- 시나리오 3: 일반 생성 실패 -> image_url=None
- 시나리오 4: 타임아웃 발생 -> 안전한 폴백
- 시나리오 5: 잔액 부족 -> 텍스트-only 폴백 메시지 반영 (U-054 핵심)
"""

from unittest.mock import AsyncMock, MagicMock

import pytest

from unknown_world.models.turn import (
    AgentConsole,
    ClientInfo,
    CurrencyAmount,
    EconomyOutput,
    EconomySnapshot,
    ImageJob,
    Language,
    RenderOutput,
    SafetyOutput,
    Theme,
    TurnInput,
    TurnOutput,
    ValidationBadge,
)
from unknown_world.orchestrator.stages.render import render_stage
from unknown_world.orchestrator.stages.types import PipelineContext
from unknown_world.services.image_generation import (
    ImageGenerationResponse,
    ImageGenerationStatus,
)


@pytest.fixture
def base_turn_output():
    """기본 TurnOutput 픽스처."""
    return TurnOutput(
        language=Language.KO,
        narrative="테스트 내러티브입니다.",
        economy=EconomyOutput(
            cost=CurrencyAmount(signal=0, memory_shard=0),
            balance_after=CurrencyAmount(signal=100, memory_shard=0),
        ),
        safety=SafetyOutput(blocked=False),
        render=RenderOutput(
            image_job=ImageJob(
                should_generate=True,
                prompt="테스트 이미지 프롬프트",
            )
        ),
        agent_console=AgentConsole(badges=[ValidationBadge.SCHEMA_OK, ValidationBadge.SAFETY_OK]),
    )


@pytest.fixture
def base_turn_input():
    """기본 TurnInput 픽스처."""
    return TurnInput(
        language=Language.KO,
        text="테스트 입력",
        client=ClientInfo(viewport_w=1920, viewport_h=1080, theme=Theme.DARK),
        economy_snapshot=EconomySnapshot(signal=100, memory_shard=0),
    )


@pytest.fixture
def mock_emit():
    """이벤트 발행 함수 모크."""
    return AsyncMock()


@pytest.fixture
def mock_image_generator():
    """이미지 생성기 서비스 모크."""
    generator = MagicMock()
    generator.is_available.return_value = True
    generator.generate = AsyncMock()
    return generator


@pytest.mark.asyncio
async def test_image_fallback_success(
    base_turn_output, base_turn_input, mock_emit, mock_image_generator
):
    """시나리오 1: 이미지 생성 성공."""
    # Given
    mock_image_generator.generate.return_value = ImageGenerationResponse(
        status=ImageGenerationStatus.COMPLETED,
        image_id="img_123",
        image_url="http://example.com/image.png",
        generation_time_ms=500,
    )

    ctx = PipelineContext(
        turn_input=base_turn_input,
        output=base_turn_output,
        image_generator=mock_image_generator,
        economy_snapshot=CurrencyAmount(signal=100, memory_shard=0),
    )

    # When
    result_ctx = await render_stage(ctx, emit=mock_emit)

    # Then
    assert result_ctx.output.render.image_url == "http://example.com/image.png"
    assert result_ctx.output.render.image_id == "img_123"
    assert ValidationBadge.SAFETY_OK in result_ctx.output.agent_console.badges


@pytest.mark.asyncio
async def test_image_fallback_safety_blocked(
    base_turn_output, base_turn_input, mock_emit, mock_image_generator
):
    """시나리오 2: 안전 정책 차단 (Safety Blocked)."""
    # Given
    mock_image_generator.generate.return_value = ImageGenerationResponse(
        status=ImageGenerationStatus.FAILED, message="Blocked by safety filters."
    )

    ctx = PipelineContext(
        turn_input=base_turn_input,
        output=base_turn_output,
        image_generator=mock_image_generator,
        economy_snapshot=CurrencyAmount(signal=100, memory_shard=0),
    )

    # When
    result_ctx = await render_stage(ctx, emit=mock_emit)

    # Then
    assert result_ctx.output.render.image_url is None
    assert result_ctx.output.safety.blocked is True
    assert ValidationBadge.SAFETY_BLOCKED in result_ctx.output.agent_console.badges
    assert ValidationBadge.SAFETY_OK not in result_ctx.output.agent_console.badges


@pytest.mark.asyncio
async def test_image_fallback_insufficient_balance(
    base_turn_output, base_turn_input, mock_emit, mock_image_generator
):
    """시나리오 5: 잔액 부족 (Insufficient Balance)."""
    # Given
    ctx = PipelineContext(
        turn_input=base_turn_input,
        output=base_turn_output,
        image_generator=mock_image_generator,
        economy_snapshot=CurrencyAmount(signal=5, memory_shard=0),
    )

    # When
    result_ctx = await render_stage(ctx, emit=mock_emit)

    # Then
    mock_image_generator.generate.assert_not_called()
    assert result_ctx.output.render.image_url is None
    assert "잔액이 부족하여" in result_ctx.output.narrative


@pytest.mark.asyncio
async def test_image_fallback_timeout(
    base_turn_output, base_turn_input, mock_emit, mock_image_generator
):
    """시나리오 4: 타임아웃 발생."""
    # Given
    mock_image_generator.generate.side_effect = TimeoutError("API Timeout")

    ctx = PipelineContext(
        turn_input=base_turn_input,
        output=base_turn_output,
        image_generator=mock_image_generator,
        economy_snapshot=CurrencyAmount(signal=100, memory_shard=0),
    )

    # When
    result_ctx = await render_stage(ctx, emit=mock_emit)

    # Then
    assert result_ctx.output.render.image_url is None
</file>

<file path="backend/tests/unit/orchestrator/test_u061_image_integration.py">
import pytest

from unknown_world.models.turn import Language, TurnInput
from unknown_world.orchestrator.generate_turn_output import TurnOutputGenerator
from unknown_world.orchestrator.prompt_loader import load_image_prompt


def test_load_image_prompt_languages():
    """언어별 이미지 프롬프트 로드 및 폴백 테스트."""
    # 한국어 로드
    ko_prompt = load_image_prompt(Language.KO)
    assert "다크 판타지" in ko_prompt
    assert "dark fantasy" in ko_prompt.lower()

    # 영어 로드
    en_prompt = load_image_prompt(Language.EN)
    assert "Dark fantasy" in en_prompt
    assert "dark fantasy" in en_prompt.lower()

    # 두 내용이 서로 다른지 확인 (번역됨)
    assert ko_prompt != en_prompt


def test_generate_turn_output_prompt_integration():
    """TurnOutputGenerator에서 이미지 가이드라인이 시스템 프롬프트에 포함되는지 테스트."""
    generator = TurnOutputGenerator(force_mock=True)

    from unknown_world.models.turn import ClientInfo, EconomySnapshot, Theme

    client_info = ClientInfo(viewport_w=1920, viewport_h=1080, theme=Theme.DARK)

    turn_input_ko = TurnInput(
        text="테스트 입력",
        language=Language.KO,
        client=client_info,
        economy_snapshot=EconomySnapshot(signal=100, memory_shard=10),
    )

    prompt_ko = generator._build_prompt(turn_input_ko)

    # 이미지 가이드라인 섹션이 포함되어 있는지 확인
    assert "## 이미지 생성 지침 (Image Generation Guidelines)" in prompt_ko
    # 한국어 지침 내용이 포함되어 있는지 확인
    assert "다크 판타지" in prompt_ko

    turn_input_en = TurnInput(
        text="Test input",
        language=Language.EN,
        client=client_info,
        economy_snapshot=EconomySnapshot(signal=100, memory_shard=10),
    )

    prompt_en = generator._build_prompt(turn_input_en)

    assert "## 이미지 생성 지침 (Image Generation Guidelines)" in prompt_en
    # 영어 지침 내용이 포함되어 있는지 확인
    assert "Dark fantasy" in prompt_en
    assert "다크 판타지" not in prompt_en  # 영어 프롬프트에는 한국어 설명이 없어야 함 (본문 기준)


@pytest.mark.asyncio
async def test_generate_turn_output_full_flow_mock(monkeypatch):
    """전체 생성 흐름에서 이미지 프롬프트가 생성되는지 확인 (Mock)."""
    # GenAIClient.generate가 유효한 TurnOutput JSON을 반환하도록 모킹
    import json

    from unknown_world.services.genai_client import GenerateResponse, MockGenAIClient

    mock_turn_output = {
        "language": "ko-KR",
        "narrative": "테스트 내러티브",
        "ui": {"action_deck": {"cards": []}, "objects": []},
        "world": {
            "rules_changed": [],
            "inventory_added": [],
            "inventory_removed": [],
            "quests_updated": [],
            "relationships_changed": [],
            "memory_pins": [],
        },
        "render": {
            "image_job": {
                "should_generate": True,
                "prompt": "A beautiful dark fantasy landscape, cinematic lighting, highly detailed",
                "model_label": "FAST",
                "aspect_ratio": "16:9",
                "image_size": "1024x1024",
            }
        },
        "economy": {
            "cost": {"signal": 5, "memory_shard": 0},
            "balance_after": {"signal": 95, "memory_shard": 10},
        },
        "safety": {"blocked": False},
        "agent_console": {"current_phase": "commit", "badges": ["schema_ok"], "repair_count": 0},
    }

    async def mock_generate(*args, **kwargs):
        return GenerateResponse(text=json.dumps(mock_turn_output), model_label="FAST")

    monkeypatch.setattr(MockGenAIClient, "generate", mock_generate)

    generator = TurnOutputGenerator(force_mock=True)

    from unknown_world.models.turn import ClientInfo, EconomySnapshot, Theme

    client_info = ClientInfo(viewport_w=1920, viewport_h=1080, theme=Theme.DARK)

    turn_input = TurnInput(
        text="어두운 숲으로 들어갑니다.",
        language=Language.KO,
        client=client_info,
        economy_snapshot=EconomySnapshot(signal=100, memory_shard=10),
    )

    result = await generator.generate(turn_input)

    assert result.status == "success"
    assert result.output is not None
    assert result.output.render.image_job.should_generate is True
    assert "dark fantasy" in result.output.render.image_job.prompt.lower()
</file>

<file path="backend/tests/unit/orchestrator/test_u090_hotspot_restriction.py">
"""Unknown World - U-090 핫스팟 생성 제한 단위 테스트."""

from unittest.mock import AsyncMock

import pytest

from unknown_world.models.turn import (
    AgentPhase,
    ClientInfo,
    CurrencyAmount,
    EconomySnapshot,
    Language,
    RenderOutput,
    SceneObject,
    TurnInput,
    TurnOutput,
    UIOutput,
    WorldDelta,
)
from unknown_world.orchestrator.stages.resolve import resolve_stage
from unknown_world.orchestrator.stages.types import PipelineContext
from unknown_world.orchestrator.stages.verify import verify_stage
from unknown_world.services.agentic_vision import Box2D


@pytest.fixture
def mock_emit():
    return AsyncMock()


@pytest.fixture
def base_context():
    """기본 테스트 컨텍스트."""
    economy_snap = EconomySnapshot(signal=100, memory_shard=0)
    turn_input = TurnInput(
        language=Language.KO,
        text="방을 둘러본다",
        action_id="explore",  # 일반 액션
        client=ClientInfo(viewport_w=1920, viewport_h=1080),
        economy_snapshot=economy_snap,
    )
    # TurnOutput 생성 (GM이 임의로 핫스팟을 생성했다고 가정)
    output = TurnOutput(
        language=Language.KO,
        narrative="방에 낡은 상자가 있습니다.",
        ui=UIOutput(
            objects=[
                SceneObject(
                    id="hallucinated_box",
                    label="환각 상자",
                    box_2d=Box2D(ymin=100, xmin=100, ymax=200, xmax=200),
                )
            ]
        ),
        render=RenderOutput(image_url="/static/test.png"),
        world=WorldDelta(),
        economy={
            "cost": {"signal": 5, "memory_shard": 0},
            "balance_after": {"signal": 95, "memory_shard": 0},
        },
        safety={"blocked": False},
    )
    return PipelineContext(
        turn_input=turn_input,
        economy_snapshot=CurrencyAmount(
            signal=economy_snap.signal, memory_shard=economy_snap.memory_shard
        ),
        output=output,
        current_phase=AgentPhase.VALIDATE,
    )


@pytest.mark.asyncio
async def test_resolve_stage_strips_hotspots_on_normal_turn(base_context, mock_emit):
    """일반 턴에서 GM이 생성한 핫스팟이 resolve_stage에서 제거되는지 확인."""
    # Given: action_id = "explore" (일반 턴), objects에 1개 존재
    assert len(base_context.output.ui.objects) == 1

    # When: resolve_stage 실행
    updated_ctx = await resolve_stage(base_context, emit=mock_emit)

    # Then: objects가 빈 배열이어야 함
    assert len(updated_ctx.output.ui.objects) == 0


@pytest.mark.asyncio
async def test_verify_stage_strips_hotspots_on_normal_turn(base_context, mock_emit):
    """일반 턴에서 핫스팟이 verify_stage에서 이중으로 제거되는지 확인."""
    # Given: action_id = "explore" (일반 턴), objects에 1개 존재
    assert len(base_context.output.ui.objects) == 1

    # When: verify_stage 실행
    updated_ctx = await verify_stage(base_context, emit=mock_emit)

    # Then: objects가 빈 배열이어야 함
    assert len(updated_ctx.output.ui.objects) == 0


@pytest.mark.asyncio
async def test_resolve_stage_keeps_objects_empty_on_normal_turn(base_context, mock_emit):
    """일반 턴에서 원래 비어있던 objects가 유지되는지 확인."""
    # Given: objects가 이미 비어있음
    base_context.output.ui.objects = []

    # When: resolve_stage 실행
    updated_ctx = await resolve_stage(base_context, emit=mock_emit)

    # Then: 여전히 비어있어야 함
    assert len(updated_ctx.output.ui.objects) == 0
</file>

<file path="backend/tests/unit/orchestrator/test_u131_prompt_composition.py">
# pyright: reportPrivateUsage=false

import pytest

from unknown_world.models.turn import ClientInfo, EconomySnapshot, Language, TurnInput
from unknown_world.orchestrator.generate_turn_output import TurnOutputGenerator


@pytest.mark.asyncio
async def test_u131_overarching_mystery_prompt_injection_ko():
    """한국어 시스템 프롬프트에 Overarching Mystery 섹션이 포함되는지 검증 (U-131)."""
    generator = TurnOutputGenerator()
    turn_input = TurnInput(
        language=Language.KO,
        text="테스트 입력",
        economy_snapshot=EconomySnapshot(signal=100, memory_shard=10),
        client=ClientInfo(viewport_w=1920, viewport_h=1080),
    )

    # 시스템 인스트럭션 빌드
    instruction = generator._build_system_instruction(turn_input, world_context="세계 상태")

    # 1. 미스터리 섹션 태그 확인
    assert "<overarching_mystery>" in instruction
    assert "</overarching_mystery>" in instruction

    # 2. 핵심 키워드 '메아리' 확인
    assert "메아리(Echo)" in instruction
    assert "모든 이야기, 모든 선택, 모든 잊힌 진실을 묶는 공명" in instruction

    # 3. 퀘스트 연결 지침 확인 (turn_output_instructions에서 로드됨)
    assert "Overarching Mystery 연결 (U-131)" in instruction
    assert '직접적으로 "메아리를 찾아라"라고 명시하지 마세요' in instruction


@pytest.mark.asyncio
async def test_u131_overarching_mystery_prompt_injection_en():
    """영어 시스템 프롬프트에 Overarching Mystery 섹션이 포함되는지 검증 (U-131)."""
    generator = TurnOutputGenerator()
    turn_input = TurnInput(
        language=Language.EN,
        text="Test Input",
        economy_snapshot=EconomySnapshot(signal=100, memory_shard=10),
        client=ClientInfo(viewport_w=1920, viewport_h=1080),
    )

    # 시스템 인스트럭션 빌드
    instruction = generator._build_system_instruction(turn_input, world_context="World Context")

    # 1. 미스터리 섹션 태그 확인
    assert "<overarching_mystery>" in instruction
    assert "</overarching_mystery>" in instruction

    # 2. 핵심 키워드 'Echo' 확인
    assert "Echo" in instruction
    assert "resonance that binds all stories, all choices, all forgotten truths" in instruction

    # 3. 퀘스트 연결 지침 확인
    assert "Overarching Mystery Connection (U-131)" in instruction
    assert 'Do NOT explicitly state "find the Echo"' in instruction
</file>

<file path="backend/tests/unit/services/test_agentic_vision.py">
"""Unknown World - Agentic Vision 서비스 단위 테스트 (U-076[Mvp])."""

from unknown_world.models.turn import Box2D, Language
from unknown_world.services.agentic_vision import (
    _normalize_bbox,
    _parse_vision_response,
    affordances_to_scene_objects,
)


def test_normalize_bbox_valid():
    """정상적인 bbox 데이터 정규화 테스트."""
    raw = {"ymin": 100, "xmin": 200, "ymax": 300, "xmax": 400}
    bbox = _normalize_bbox(raw)
    assert bbox is not None
    assert bbox.ymin == 100
    assert bbox.xmin == 200
    assert bbox.ymax == 300
    assert bbox.xmax == 400


def test_normalize_bbox_out_of_range():
    """범위를 벗어난 bbox 데이터 클램핑 테스트 (RULE-009)."""
    raw = {"ymin": -10, "xmin": 500, "ymax": 1100, "xmax": 2000}
    bbox = _normalize_bbox(raw)
    assert bbox is not None
    assert bbox.ymin == 0
    assert bbox.xmin == 500
    assert bbox.ymax == 1000
    assert bbox.xmax == 1000


def test_normalize_bbox_invalid_order():
    """ymin >= ymax 같은 잘못된 순서 자동 교정 테스트."""
    raw = {"ymin": 500, "xmin": 200, "ymax": 400, "xmax": 300}
    bbox = _normalize_bbox(raw)
    assert bbox is not None
    assert bbox.ymin == 500
    assert bbox.ymax > 500
    assert bbox.xmin == 200
    assert bbox.xmax > 200


def test_parse_vision_response_success():
    """정상적인 JSON 응답 파싱 테스트."""
    response_text = """
    ```json
    {
      "affordances": [
        {
          "label": "테스트 오브젝트",
          "box_2d": {"ymin": 10, "xmin": 20, "ymax": 100, "xmax": 200},
          "interaction_hint": "클릭하세요"
        }
      ]
    }
    ```
    """
    result = _parse_vision_response(response_text, Language.KO)
    assert result.success is True
    assert len(result.affordances) == 1
    assert result.affordances[0].label == "테스트 오브젝트"
    assert result.affordances[0].box_2d.ymin == 10
    assert result.affordances[0].interaction_hint == "클릭하세요"


def test_parse_vision_response_failure():
    """잘못된 JSON 응답 파싱 실패 및 폴백 테스트 (RULE-004)."""
    response_text = "이것은 JSON이 아닙니다."
    result = _parse_vision_response(response_text, Language.KO)
    assert result.success is False
    assert len(result.affordances) == 0


def test_affordances_to_scene_objects():
    """Affordance -> SceneObject 변환 테스트."""
    from unknown_world.services.agentic_vision import Affordance

    affs = [
        Affordance(label="Obj1", box_2d=Box2D(ymin=0, xmin=0, ymax=100, xmax=100)),
        Affordance(label="Obj2", box_2d=Box2D(ymin=200, xmin=200, ymax=300, xmax=300)),
    ]
    objs = affordances_to_scene_objects(affs, id_prefix="test")

    assert len(objs) == 2
    assert objs[0].id == "test_0"
    assert objs[0].label == "Obj1"
    assert objs[1].id == "test_1"
    assert objs[1].label == "Obj2"
</file>

<file path="backend/tests/unit/services/test_item_icon_generator.py">
import hashlib
from unittest.mock import AsyncMock, MagicMock, patch

import pytest

from unknown_world.services.item_icon_generator import (
    IconCache,
    IconGenerationRequest,
    IconGenerationStatus,
    ItemIconGenerator,
)


@pytest.fixture
def mock_image_generator():
    generator = MagicMock()
    generator.generate = AsyncMock()
    return generator


@pytest.fixture
def temp_cache_dir(tmp_path):
    return tmp_path / "icons"


@pytest.fixture
def icon_cache(temp_cache_dir):
    return IconCache(cache_dir=temp_cache_dir)


@pytest.fixture
def icon_generator(mock_image_generator, icon_cache):
    return ItemIconGenerator(image_generator=mock_image_generator, cache=icon_cache)


def test_cache_key_generation(icon_cache):
    description = "A shiny sword"
    key1 = icon_cache._make_cache_key(description)
    key2 = icon_cache._make_cache_key(description)
    assert key1 == key2
    assert key1 == hashlib.md5(description.encode()).hexdigest()


@pytest.mark.asyncio
async def test_generate_icon_cached(icon_generator, icon_cache, temp_cache_dir):
    description = "Cached item"
    cache_key = icon_cache._make_cache_key(description)
    cache_file = temp_cache_dir / f"{cache_key}.png"
    cache_file.parent.mkdir(parents=True, exist_ok=True)
    cache_file.write_bytes(b"fake_image_data")

    request = IconGenerationRequest(
        item_id="item_1", item_description=description, language="ko-KR"
    )

    response = await icon_generator.generate_icon(request, wait_for_completion=True)

    assert response.status == IconGenerationStatus.CACHED
    assert response.is_placeholder is False
    assert f"{cache_key}.png" in response.icon_url


@pytest.mark.asyncio
async def test_generate_icon_new_async(icon_generator, mock_image_generator):
    request = IconGenerationRequest(
        item_id="item_2", item_description="New item async", language="ko-KR"
    )

    response = await icon_generator.generate_icon(request, wait_for_completion=False)

    assert response.status == IconGenerationStatus.PENDING
    assert response.is_placeholder is True
    assert "placeholder" in response.icon_url

    # 백그라운드 태스크가 생성되었는지 확인 (내부 구현 의존적이지만 상태로 확인 가능)
    status = await icon_generator.get_icon_status("item_2")
    assert status in [IconGenerationStatus.GENERATING, IconGenerationStatus.COMPLETED]


@pytest.mark.asyncio
async def test_generate_icon_new_sync_success(
    icon_generator, mock_image_generator, icon_cache, temp_cache_dir
):
    from unknown_world.services.image_generation import (
        ImageGenerationResponse,
        ImageGenerationStatus,
    )

    description = "New item sync"
    cache_key = icon_cache._make_cache_key(description)

    # Mock response
    mock_image_id = "test_image_id"
    mock_image_generator.generate.return_value = ImageGenerationResponse(
        status=ImageGenerationStatus.COMPLETED,
        image_url="http://example.com/test.png",
        image_id=mock_image_id,
    )

    # 원본 파일이 생성된 것으로 시뮬레이션

    with patch(
        "unknown_world.services.item_icon_generator.get_generated_images_dir"
    ) as mock_get_dir:
        mock_get_dir.return_value = temp_cache_dir.parent  # icons의 상위 디렉토리
        gen_dir = temp_cache_dir.parent
        gen_dir.mkdir(parents=True, exist_ok=True)
        (gen_dir / f"{mock_image_id}.png").write_bytes(b"fake_image_content")

        # PIL.Image.open 모킹 (실제 이미지가 아니므로)
        with patch("PIL.Image.open") as mock_open:
            mock_img = MagicMock()
            mock_img.size = (1024, 1024)
            mock_img.resize.return_value = mock_img
            mock_open.return_value.__enter__.return_value = mock_img

            request = IconGenerationRequest(
                item_id="item_3", item_description=description, language="en-US"
            )

            response = await icon_generator.generate_icon(request, wait_for_completion=True)

            assert response.status == IconGenerationStatus.COMPLETED
            assert response.is_placeholder is False
            assert f"{cache_key}.png" in response.icon_url
            assert (temp_cache_dir / f"{cache_key}.png").exists()


@pytest.mark.asyncio
async def test_generate_icon_failure(icon_generator, mock_image_generator):
    from unknown_world.services.image_generation import (
        ImageGenerationResponse,
        ImageGenerationStatus,
    )

    mock_image_generator.generate.return_value = ImageGenerationResponse(
        status=ImageGenerationStatus.FAILED, image_url="", message="Generation failed"
    )

    request = IconGenerationRequest(
        item_id="item_4", item_description="Failing item", language="ko-KR"
    )

    response = await icon_generator.generate_icon(request, wait_for_completion=True)

    assert response.status == IconGenerationStatus.FAILED
    assert response.is_placeholder is True
    assert "placeholder" in response.icon_url
</file>

<file path="backend/tests/unit/services/test_scanner_service.py">
"""U-021 이미지 이해(Scanner) 서비스 단위 테스트."""

import pytest

from unknown_world.models.scanner import ScanStatus
from unknown_world.models.turn import Language
from unknown_world.services.image_understanding import (
    MAX_FILE_SIZE_BYTES,
    ImageUnderstandingService,
    _parse_vision_response,
    normalize_bbox,
    validate_image,
)


def test_validate_image_valid():
    """정상적인 이미지 검증 테스트."""
    content = b"a" * 1000
    assert validate_image(content, "image/png") is None
    assert validate_image(content, "image/jpeg") is None
    assert validate_image(content, "image/webp") is None


def test_validate_image_invalid_type():
    """지원하지 않는 파일 형식 검증 테스트."""
    content = b"a" * 1000
    error = validate_image(content, "text/plain")
    assert "지원하지 않는 이미지 형식" in error


def test_validate_image_too_large():
    """파일 크기 초과 검증 테스트."""
    content = b"a" * (MAX_FILE_SIZE_BYTES + 1)
    error = validate_image(content, "image/png")
    assert "파일이 너무 큽니다" in error


def test_validate_image_too_small():
    """너무 작은 파일 검증 테스트."""
    content = b"a" * 10
    error = validate_image(content, "image/png")
    assert "이미지 파일이 손상되었거나 비어있습니다" in error


def test_normalize_bbox_valid():
    """bbox 정규화 테스트 (정상 범위)."""
    bbox = {"ymin": 100, "xmin": 200, "ymax": 300, "xmax": 400}
    normalized = normalize_bbox(bbox)
    assert normalized.ymin == 100
    assert normalized.xmin == 200
    assert normalized.ymax == 300
    assert normalized.xmax == 400


def test_normalize_bbox_clamping():
    """bbox 정규화 테스트 (범위 초과 클램핑)."""
    bbox = {"ymin": -100, "xmin": 1200, "ymax": 1500, "xmax": 500}
    normalized = normalize_bbox(bbox)
    assert normalized.ymin == 0
    assert normalized.xmin == 1000  # xmin이 xmax보다 커지는 경우 normalize_bbox 로직 확인 필요
    # xmax가 500이므로 xmin이 1000으로 클램핑되면 xmin > xmax가 됨
    # normalize_bbox 구현:
    # xmin_val = max(0, min(1000, 1200)) -> 1000
    # xmax_val = max(0, min(1000, 500)) -> 500
    # if xmin_val >= xmax_val: xmax_val = min(xmin_val + 100, 1000) -> 1000
    assert normalized.xmax == 1000
    assert normalized.xmin == 1000


def test_normalize_bbox_order_correction():
    """bbox 정규화 테스트 (순서 보정)."""
    bbox = {"ymin": 500, "xmin": 500, "ymax": 200, "xmax": 200}
    normalized = normalize_bbox(bbox)
    assert normalized.ymin == 500
    assert normalized.ymax == 600  # 500 + 100
    assert normalized.xmin == 500
    assert normalized.xmax == 600  # 500 + 100


def test_parse_vision_response_valid():
    """비전 모델 응답 파싱 테스트 (정상 JSON)."""
    response_text = """
    {
      "caption": "A test image",
      "objects": [
        {
          "label": "Key",
          "box_2d": {"ymin": 100, "xmin": 100, "ymax": 200, "xmax": 200},
          "suggested_item_type": "key"
        }
      ],
      "item_candidates": [
        {
          "id": "item_1",
          "label": "Old Key",
          "description": "An old key",
          "item_type": "key",
          "source_object_index": 0
        }
      ]
    }
    """
    result = _parse_vision_response(response_text, Language.EN)
    assert result.status == ScanStatus.COMPLETED
    assert result.caption == "A test image"
    assert len(result.objects) == 1
    assert result.objects[0].label == "Key"
    assert result.objects[0].box_2d.ymin == 100
    assert len(result.item_candidates) == 1
    assert result.item_candidates[0].label == "Old Key"


def test_parse_vision_response_markdown():
    """비전 모델 응답 파싱 테스트 (마크다운 포함)."""
    response_text = """```json
    {
      "caption": "Markdown test",
      "objects": []
    }
    ```"""
    result = _parse_vision_response(response_text, Language.KO)
    assert result.status == ScanStatus.COMPLETED
    assert result.caption == "Markdown test"


def test_parse_vision_response_invalid_json():
    """비전 모델 응답 파싱 테스트 (잘못된 JSON)."""
    response_text = "This is not JSON"
    result = _parse_vision_response(response_text, Language.KO)
    assert result.status == ScanStatus.PARTIAL
    assert result.caption == "This is not JSON"
    assert "파싱할 수 없습니다" in result.message


@pytest.mark.asyncio
async def test_service_analyze_mock():
    """서비스 analyze 메서드 테스트 (Mock 모드)."""
    service = ImageUnderstandingService(force_mock=True)
    content = b"a" * 1000
    result = await service.analyze(content, "image/png", Language.KO)

    assert result.status == ScanStatus.COMPLETED
    assert "[Mock]" in result.caption
    assert len(result.objects) > 0
    assert result.analysis_time_ms >= 0
    assert result.message is None
</file>

<file path="backend/tests/unit/services/test_u093_timeout_retry.py">
from unittest.mock import AsyncMock, MagicMock, patch

import pytest

from unknown_world.services.image_generation import (
    ImageGenerationResponse,
    ImageGenerationStatus,
)
from unknown_world.services.item_icon_generator import (
    IconGenerationRequest,
    IconGenerationStatus,
    ItemIconGenerator,
)


@pytest.fixture
def mock_image_generator():
    generator = MagicMock()
    generator.generate = AsyncMock()
    return generator


@pytest.fixture
def icon_generator(mock_image_generator):
    # 캐시는 Mock으로 처리하여 파일 시스템 의존성 제거
    mock_cache = MagicMock()
    mock_cache.get.return_value = None
    return ItemIconGenerator(image_generator=mock_image_generator, cache=mock_cache)


@pytest.mark.asyncio
async def test_retry_on_timeout(icon_generator, mock_image_generator):
    """타임아웃 발생 시 최대 1회 재시도(총 2회) 후 성공하는지 검증."""
    request = IconGenerationRequest(
        item_id="item_timeout", item_description="Timeout Item", language="ko-KR"
    )

    # 첫 번째는 TimeoutError, 두 번째는 성공 응답 설정
    mock_image_generator.generate.side_effect = [
        TimeoutError(),
        ImageGenerationResponse(
            status=ImageGenerationStatus.COMPLETED,
            image_url="http://example.com/retry_success.png",
            image_id="img_retry_success",
        ),
    ]

    # asyncio.sleep 모킹 (대기 시간 제거)
    with (
        patch("asyncio.sleep", AsyncMock()) as mock_sleep,
        patch("unknown_world.services.item_icon_generator.get_generated_images_dir") as mock_dir,
        patch("pathlib.Path.exists", return_value=True),
        patch("pathlib.Path.read_bytes", return_value=b"fake_data"),
    ):
        mock_dir.return_value = MagicMock()
        # IconCache.set 모킹
        icon_generator._cache.set.return_value = "http://example.com/cached.png"

        response = await icon_generator.generate_icon(request, wait_for_completion=True)

        # 결과 검증
        assert response.status == IconGenerationStatus.COMPLETED
        assert response.icon_url == "http://example.com/cached.png"
        assert mock_image_generator.generate.call_count == 2
        assert mock_sleep.call_count == 1
        mock_sleep.assert_called_with(2.0)  # 첫 번째 백오프: 2.0s


@pytest.mark.asyncio
async def test_retry_on_retryable_error(icon_generator, mock_image_generator):
    """재시도 가능한 에러(예: 500) 발생 시 재시도하는지 검증."""
    request = IconGenerationRequest(
        item_id="item_retryable", item_description="Retryable Item", language="ko-KR"
    )

    # 첫 번째는 실패(재시도 가능), 두 번째는 성공
    mock_image_generator.generate.side_effect = [
        ImageGenerationResponse(
            status=ImageGenerationStatus.FAILED, message="Internal Server Error (500)"
        ),
        ImageGenerationResponse(
            status=ImageGenerationStatus.COMPLETED,
            image_url="http://example.com/retry_success.png",
            image_id="img_retry_success",
        ),
    ]

    with (
        patch("asyncio.sleep", AsyncMock()) as mock_sleep,
        patch("unknown_world.services.item_icon_generator.get_generated_images_dir"),
        patch("pathlib.Path.exists", return_value=True),
        patch("pathlib.Path.read_bytes", return_value=b"fake_data"),
    ):
        icon_generator._cache.set.return_value = "http://example.com/cached.png"

        response = await icon_generator.generate_icon(request, wait_for_completion=True)

        assert response.status == IconGenerationStatus.COMPLETED
        assert mock_image_generator.generate.call_count == 2
        assert mock_sleep.call_count == 1


@pytest.mark.asyncio
async def test_no_retry_on_non_retryable_error(icon_generator, mock_image_generator):
    """재시도 불가능한 에러(예: safety block) 발생 시 재시도하지 않는지 검증."""
    request = IconGenerationRequest(
        item_id="item_non_retryable", item_description="Blocked Item", language="ko-KR"
    )

    # Safety 차단 에러 (재시도 불가)
    mock_image_generator.generate.return_value = ImageGenerationResponse(
        status=ImageGenerationStatus.FAILED, message="Safety filter blocked the request"
    )

    with patch("asyncio.sleep", AsyncMock()) as mock_sleep:
        response = await icon_generator.generate_icon(request, wait_for_completion=True)

        assert response.status == IconGenerationStatus.FAILED
        assert response.is_placeholder is True
        # 재시도 없이 1회 호출 후 종료되어야 함
        assert mock_image_generator.generate.call_count == 1
        assert mock_sleep.call_count == 0


@pytest.mark.asyncio
async def test_final_failure_after_max_retries(icon_generator, mock_image_generator):
    """모든 재시도(총 2회) 실패 시 최종적으로 FAILED를 반환하는지 검증."""
    request = IconGenerationRequest(
        item_id="item_all_fail", item_description="Always Failing Item", language="ko-KR"
    )

    # 2회 모두 타임아웃 발생
    mock_image_generator.generate.side_effect = [
        TimeoutError(),
        TimeoutError(),
    ]

    with patch("asyncio.sleep", AsyncMock()) as mock_sleep:
        response = await icon_generator.generate_icon(request, wait_for_completion=True)

        assert response.status == IconGenerationStatus.FAILED
        assert response.is_placeholder is True
        assert "아이콘 생성 실패 (2/2 시도)" in response.message
        assert mock_image_generator.generate.call_count == 2
        assert mock_sleep.call_count == 1


@pytest.mark.asyncio
async def test_retry_on_retryable_exception(icon_generator, mock_image_generator):
    """재시도 가능한 예외(예: ConnectionError) 발생 시 재시도하는지 검증."""
    request = IconGenerationRequest(
        item_id="item_exc", item_description="Exception Item", language="ko-KR"
    )

    # 첫 번째는 ConnectionError, 두 번째는 성공
    mock_image_generator.generate.side_effect = [
        ConnectionError("Network disconnected"),
        ImageGenerationResponse(
            status=ImageGenerationStatus.COMPLETED,
            image_url="http://example.com/retry_success.png",
            image_id="img_retry_success",
        ),
    ]

    with (
        patch("asyncio.sleep", AsyncMock()) as mock_sleep,
        patch("unknown_world.services.item_icon_generator.get_generated_images_dir"),
        patch("pathlib.Path.exists", return_value=True),
        patch("pathlib.Path.read_bytes", return_value=b"fake_data"),
    ):
        icon_generator._cache.set.return_value = "http://example.com/cached.png"

        response = await icon_generator.generate_icon(request, wait_for_completion=True)

        assert response.status == IconGenerationStatus.COMPLETED
        assert mock_image_generator.generate.call_count == 2
        assert mock_sleep.call_count == 1
</file>

<file path="backend/tests/unit/test_dotenv_autoload.py">
"""U-047: Backend .env 자동 로딩 테스트

이 모듈은 backend/.env 파일의 자동 로딩 기능을 검증합니다.

완료 기준:
- 로컬에서 .env 존재 시 자동 로딩됨 (추가 export 불필요)
- UW_MODE/ENVIRONMENT가 .env 기준으로 반영됨
- .env 미존재 시 서버 정상 시작 (no-op)
- 민감 정보(키/토큰/프롬프트)는 로그/스트림에 노출되지 않음 (RULE-007)

테스트 시나리오:
1. .env 파일 존재 시 로딩 성공
2. .env 파일 미존재 시 기본값 사용 (정상 시작)
3. override=False 정책 검증 (기존 환경변수 우선)
4. 로깅에 민감 정보 미포함 검증
"""

import logging
import os
import tempfile
from collections.abc import Generator
from pathlib import Path

import pytest
from dotenv import load_dotenv


class TestDotenvAutoload:
    """dotenv 자동 로딩 기능 테스트 스위트."""

    # =========================================================================
    # Fixtures
    # =========================================================================

    @pytest.fixture
    def temp_env_file(self, tmp_path: Path) -> Generator[Path]:
        """임시 .env 파일을 생성하고 경로를 반환합니다."""
        env_file = tmp_path / ".env"
        env_file.write_text(
            "UW_MODE=real\nENVIRONMENT=development\nGOOGLE_APPLICATION_CREDENTIALS=./test-key.key\n"
        )
        yield env_file
        # cleanup
        if env_file.exists():
            env_file.unlink()

    @pytest.fixture
    def clean_env(self) -> Generator[None]:
        """테스트 전 관련 환경변수를 정리합니다."""
        # 저장할 원래 값들
        original_values: dict[str, str | None] = {}
        keys_to_clean = ["UW_MODE", "ENVIRONMENT", "GOOGLE_APPLICATION_CREDENTIALS"]

        for key in keys_to_clean:
            original_values[key] = os.environ.pop(key, None)

        yield

        # 복원
        for key, value in original_values.items():
            if value is not None:
                os.environ[key] = value
            elif key in os.environ:
                del os.environ[key]

    # =========================================================================
    # 1. 성공 시나리오 (Happy Path)
    # =========================================================================

    def test_dotenv_loads_when_file_exists(self, temp_env_file: Path, clean_env: None) -> None:
        """[Happy] .env 파일 존재 시 환경변수가 로드됩니다."""
        # Given: .env 파일이 존재하고 환경변수가 설정되어 있지 않음
        assert "UW_MODE" not in os.environ
        assert "ENVIRONMENT" not in os.environ

        # When: load_dotenv 호출
        result = load_dotenv(dotenv_path=temp_env_file, override=False)

        # Then: 환경변수가 로드됨
        assert result is True
        assert os.environ.get("UW_MODE") == "real"
        assert os.environ.get("ENVIRONMENT") == "development"

    def test_uw_mode_reflects_env_value(self, temp_env_file: Path, clean_env: None) -> None:
        """[Happy] UW_MODE가 .env에서 로드된 값으로 설정됩니다."""
        # Given: clean env + temp .env file
        load_dotenv(dotenv_path=temp_env_file, override=False)

        # When/Then: UW_MODE 값 확인
        assert os.environ.get("UW_MODE") == "real"

    def test_environment_reflects_env_value(self, temp_env_file: Path, clean_env: None) -> None:
        """[Happy] ENVIRONMENT가 .env에서 로드된 값으로 설정됩니다."""
        # Given: clean env + temp .env file
        load_dotenv(dotenv_path=temp_env_file, override=False)

        # When/Then: ENVIRONMENT 값 확인
        assert os.environ.get("ENVIRONMENT") == "development"

    # =========================================================================
    # 2. 실패/예외 시나리오 (Error Cases)
    # =========================================================================

    def test_server_starts_without_env_file(self, clean_env: None) -> None:
        """[Error] .env 파일 미존재 시 load_dotenv는 False를 반환하고 서버는 정상 시작합니다."""
        # Given: 존재하지 않는 경로
        non_existent_path = Path("/non/existent/path/.env")

        # When: load_dotenv 호출
        result = load_dotenv(dotenv_path=non_existent_path, override=False)

        # Then: False 반환 (에러 없이)
        assert result is False

    def test_default_values_when_env_missing(self, clean_env: None) -> None:
        """[Error] .env 미존재 시 기본값을 사용합니다."""
        # Given: .env 없이 환경변수도 없음
        # When: 기본값 조회
        uw_mode = os.environ.get("UW_MODE", "mock")
        environment = os.environ.get("ENVIRONMENT", "development")

        # Then: 기본값 사용
        assert uw_mode == "mock"  # genai_client.py의 기본값
        assert environment == "development"

    # =========================================================================
    # 3. 경계값 테스트 (Boundary Conditions)
    # =========================================================================

    def test_override_false_preserves_existing_env(
        self, temp_env_file: Path, clean_env: None
    ) -> None:
        """[Boundary] override=False: 기존 환경변수가 있으면 덮어쓰지 않습니다."""
        # Given: 환경변수가 이미 설정됨
        os.environ["UW_MODE"] = "mock"
        os.environ["ENVIRONMENT"] = "production"

        # When: load_dotenv(override=False) 호출
        load_dotenv(dotenv_path=temp_env_file, override=False)

        # Then: 기존 값 유지 (덮어쓰지 않음)
        assert os.environ.get("UW_MODE") == "mock"  # .env의 "real"로 변경되지 않음
        assert os.environ.get("ENVIRONMENT") == "production"

    def test_override_true_overwrites_existing_env(
        self, temp_env_file: Path, clean_env: None
    ) -> None:
        """[Boundary] override=True: 기존 환경변수를 덮어씁니다 (참조용, 프로덕션에서는 사용 금지)."""
        # Given: 환경변수가 이미 설정됨
        os.environ["UW_MODE"] = "mock"

        # When: load_dotenv(override=True) 호출 - 주의: 프로덕션에서는 금지
        load_dotenv(dotenv_path=temp_env_file, override=True)

        # Then: 새 값으로 덮어씀
        assert os.environ.get("UW_MODE") == "real"

    def test_empty_env_file_no_error(self, tmp_path: Path, clean_env: None) -> None:
        """[Boundary] 빈 .env 파일도 에러 없이 처리됩니다."""
        # Given: 빈 .env 파일
        empty_env = tmp_path / ".env"
        empty_env.write_text("")

        # When: load_dotenv 호출
        # Note: python-dotenv는 빈 파일에서도 에러를 발생시키지 않음
        # 반환값은 파일 존재 여부보다는 "변수가 로드되었는지"를 나타낼 수 있음
        try:
            result = load_dotenv(dotenv_path=empty_env, override=False)
            # Then: 에러 없이 완료됨 (반환값은 구현에 따라 다름)
            assert isinstance(result, bool)
        except Exception as e:
            pytest.fail(f"빈 .env 파일 처리 중 예외 발생: {e}")

    def test_env_with_comments_and_whitespace(self, tmp_path: Path, clean_env: None) -> None:
        """[Boundary] 주석과 공백이 있는 .env 파일을 올바르게 파싱합니다."""
        # Given: 주석과 공백이 있는 .env 파일
        env_file = tmp_path / ".env"
        env_file.write_text(
            "# This is a comment\n\nUW_MODE=real\n  \n# Another comment\nENVIRONMENT=staging\n"
        )

        # When: load_dotenv 호출
        load_dotenv(dotenv_path=env_file, override=False)

        # Then: 주석/공백 무시, 값만 로드
        assert os.environ.get("UW_MODE") == "real"
        assert os.environ.get("ENVIRONMENT") == "staging"

    # =========================================================================
    # 4. 보안 테스트 (Security) - RULE-007
    # =========================================================================

    def test_sensitive_info_not_in_logs(
        self, temp_env_file: Path, clean_env: None, caplog: pytest.LogCaptureFixture
    ) -> None:
        """[Security] 민감 정보(키/토큰/경로)가 로그에 노출되지 않습니다.

        이 테스트는 main.py의 로깅 정책(RULE-007)을 검증합니다:
        - 민감 정보(키/토큰/경로)는 로그에 출력하지 않음
        - 모드/환경 정보 정도만 로깅
        """
        # Given: .env에 민감 정보 포함
        load_dotenv(dotenv_path=temp_env_file, override=False)

        # When: main.py의 로깅 로직을 시뮬레이션
        with caplog.at_level(logging.INFO):
            # 로그 출력 시뮬레이션 (main.py 스타일)
            uw_mode = os.environ.get("UW_MODE", "mock")
            environment = os.environ.get("ENVIRONMENT", "development")

            logger = logging.getLogger("test_security")
            # 올바른 방식: 메시지에 안전한 정보만 포함
            logger.info(
                f"[Config] .env 파일 로드 완료 - UW_MODE={uw_mode}, ENVIRONMENT={environment}"
            )

        # Then: 민감 정보가 로그에 없음
        log_text = caplog.text

        # 키 파일 경로가 없어야 함 (RULE-007 위반 시 실패)
        assert "test-key.key" not in log_text, "민감 정보(키 파일 경로)가 로그에 노출됨"
        assert "GOOGLE_APPLICATION_CREDENTIALS" not in log_text, (
            "민감 정보(환경변수명)가 로그에 노출됨"
        )

        # 허용된 정보는 로그에 있어야 함 (올바른 로깅 확인)
        assert "UW_MODE" in log_text, "모드 정보가 로그에 있어야 함"
        assert "ENVIRONMENT" in log_text or "development" in log_text, (
            "환경 정보가 로그에 있어야 함"
        )


class TestMainModuleDotenvIntegration:
    """main.py 모듈의 dotenv 통합 테스트."""

    @pytest.fixture
    def clean_env(self) -> Generator[None]:
        """테스트 전 관련 환경변수를 정리합니다."""
        original_values: dict[str, str | None] = {}
        keys_to_clean = ["UW_MODE", "ENVIRONMENT"]

        for key in keys_to_clean:
            original_values[key] = os.environ.pop(key, None)

        yield

        for key, value in original_values.items():
            if value is not None:
                os.environ[key] = value
            elif key in os.environ:
                del os.environ[key]

    def test_main_module_dotenv_path_calculation(self) -> None:
        """[Integration] main.py의 .env 경로 계산이 올바릅니다."""
        # Given: main.py의 경로 계산 로직 재현
        # main.py 위치: backend/src/unknown_world/main.py
        # .env 위치: backend/.env
        # 따라서: main.py -> parent(unknown_world) -> parent(src) -> parent(backend) -> .env

        # 실제 main.py 경로 기준으로 계산
        main_py_path = Path(__file__).parent.parent.parent / "src" / "unknown_world" / "main.py"
        expected_dotenv_path = main_py_path.parent.parent.parent.parent / ".env"

        # When: 계산된 경로 확인
        actual_backend_dir = expected_dotenv_path.parent

        # Then: backend 디렉토리를 가리킴
        assert actual_backend_dir.name == "backend" or ".env" in str(expected_dotenv_path)

    def test_load_dotenv_returns_boolean(self) -> None:
        """[Integration] load_dotenv는 boolean을 반환하여 로딩 상태를 알 수 있습니다."""
        # Given: 임시 파일
        with tempfile.NamedTemporaryFile(mode="w", suffix=".env", delete=False) as f:
            f.write("TEST_VAR=test_value\n")
            temp_path = Path(f.name)

        try:
            # When: load_dotenv 호출
            result = load_dotenv(dotenv_path=temp_path, override=False)

            # Then: boolean 반환
            assert isinstance(result, bool)
            assert result is True
        finally:
            temp_path.unlink()


class TestDotenvPolicyCompliance:
    """dotenv 정책 준수 테스트."""

    def test_policy_local_development_autoload(self) -> None:
        """[Policy] 로컬 개발에서 .env 자동 로딩 정책이 준수됩니다.

        U-047 완료 기준:
        - 로컬에서 `cd backend && cp .env.example .env` 후
          `uv run uvicorn unknown_world.main:app ...` 실행 시
          .env가 자동 로딩된다(추가 export 불필요).
        """
        # Given: python-dotenv가 설치되어 있음 (pyproject.toml에 명시)
        # When: load_dotenv 함수가 사용 가능한지 확인
        from dotenv import load_dotenv

        # Then: 함수가 존재하고 호출 가능
        assert callable(load_dotenv)

    def test_policy_override_false_for_production_safety(self) -> None:
        """[Policy] override=False 정책으로 운영 환경 SSOT가 보장됩니다.

        U-047 정책:
        - 운영(Cloud Run 등)은 런타임 env를 SSOT로 사용(override 금지)
        """
        # Given: 운영 환경에서 환경변수가 이미 설정됨
        os.environ["POLICY_TEST_VAR"] = "production_value"

        with tempfile.NamedTemporaryFile(mode="w", suffix=".env", delete=False) as f:
            f.write("POLICY_TEST_VAR=dev_value\n")
            temp_path = Path(f.name)

        try:
            # When: override=False로 로드
            load_dotenv(dotenv_path=temp_path, override=False)

            # Then: 기존 값 유지 (운영 SSOT 보장)
            assert os.environ.get("POLICY_TEST_VAR") == "production_value"
        finally:
            temp_path.unlink()
            del os.environ["POLICY_TEST_VAR"]

    def test_policy_no_crash_without_env_file(self) -> None:
        """[Policy] .env 파일 미존재 시 서버가 정상 시작합니다.

        U-047 완료 기준:
        - .env는 존재하지 않아도 서버가 정상적으로 시작한다
          (운영/CI에서 파일 미존재를 기본으로 허용)
        """
        # Given: 존재하지 않는 .env 경로
        non_existent = Path("/definitely/not/a/real/path/.env")

        # When/Then: 에러 없이 False 반환
        try:
            result = load_dotenv(dotenv_path=non_existent, override=False)
            assert result is False  # 파일 없음
        except Exception as e:
            pytest.fail(f"load_dotenv raised an exception: {e}")
</file>

<file path="backend/tests/unit/test_orchestrator_repair.py">
"""U-018: Repair Loop 및 비즈니스 룰 검증 단위 테스트."""

from unittest.mock import AsyncMock, patch

import pytest

from unknown_world.models.turn import (
    ActionDeck,
    AgentConsole,
    AgentPhase,
    ClientInfo,
    CurrencyAmount,
    EconomyOutput,
    EconomySnapshot,
    Language,
    RenderOutput,
    SafetyOutput,
    TurnInput,
    TurnOutput,
    UIOutput,
    ValidationBadge,
    WorldDelta,
)
from unknown_world.orchestrator.generate_turn_output import GenerationResult, GenerationStatus
from unknown_world.orchestrator.repair_loop import MAX_REPAIR_ATTEMPTS, run_repair_loop
from unknown_world.validation.business_rules import validate_business_rules


@pytest.fixture
def sample_turn_input() -> TurnInput:
    return TurnInput(
        language=Language.KO,
        text="테스트 입력",
        client=ClientInfo(viewport_w=1920, viewport_h=1080),
        economy_snapshot=EconomySnapshot(signal=100, memory_shard=5),
    )


@pytest.fixture
def valid_turn_output(sample_turn_input: TurnInput) -> TurnOutput:
    return TurnOutput(
        language=Language.KO,
        narrative="성공적인 내러티브",
        ui=UIOutput(action_deck=ActionDeck(cards=[]), objects=[]),
        world=WorldDelta(),
        render=RenderOutput(image_job=None),
        economy=EconomyOutput(
            cost=CurrencyAmount(signal=10, memory_shard=1),
            balance_after=CurrencyAmount(signal=90, memory_shard=4),
        ),
        safety=SafetyOutput(blocked=False),
        agent_console=AgentConsole(
            current_phase=AgentPhase.COMMIT,
            badges=[ValidationBadge.SCHEMA_OK],
            repair_count=0,
        ),
    )


@pytest.mark.asyncio
async def test_repair_loop_success_first_time(
    sample_turn_input: TurnInput, valid_turn_output: TurnOutput
) -> None:
    """초기 시도에 바로 성공하는 케이스."""
    with patch("unknown_world.orchestrator.repair_loop.get_turn_output_generator") as mock_get_gen:
        mock_gen = mock_get_gen.return_value
        mock_gen.generate = AsyncMock(
            return_value=GenerationResult(status=GenerationStatus.SUCCESS, output=valid_turn_output)
        )

        result = await run_repair_loop(sample_turn_input)

        assert result.is_fallback is False
        assert result.repair_attempts == 0
        assert result.output.narrative == valid_turn_output.narrative
        assert ValidationBadge.SCHEMA_OK in result.badges


@pytest.mark.asyncio
async def test_repair_loop_schema_failure_then_success(
    sample_turn_input: TurnInput, valid_turn_output: TurnOutput
) -> None:
    """스키마 실패 후 두 번째 시도에 성공하는 케이스."""
    with patch("unknown_world.orchestrator.repair_loop.get_turn_output_generator") as mock_get_gen:
        mock_gen = mock_get_gen.return_value
        # 첫 번째는 실패, 두 번째는 성공
        mock_gen.generate = AsyncMock(
            side_effect=[
                GenerationResult(
                    status=GenerationStatus.SCHEMA_FAILURE, error_message="Invalid JSON"
                ),
                GenerationResult(status=GenerationStatus.SUCCESS, output=valid_turn_output),
            ]
        )

        result = await run_repair_loop(sample_turn_input)

        assert result.is_fallback is False
        assert result.repair_attempts == 1
        assert ValidationBadge.SCHEMA_FAIL not in result.badges
        assert ValidationBadge.SCHEMA_OK in result.badges


@pytest.mark.asyncio
async def test_repair_loop_business_failure_then_success(
    sample_turn_input: TurnInput, valid_turn_output: TurnOutput
) -> None:
    """비즈니스 룰(언어 불일치) 실패 후 두 번째 시도에 성공하는 케이스."""
    invalid_lang_output = valid_turn_output.model_copy(deep=True)
    invalid_lang_output.language = Language.EN  # KO 입력에 EN 출력 (위반)

    with patch("unknown_world.orchestrator.repair_loop.get_turn_output_generator") as mock_get_gen:
        mock_gen = mock_get_gen.return_value
        mock_gen.generate = AsyncMock(
            side_effect=[
                GenerationResult(status=GenerationStatus.SUCCESS, output=invalid_lang_output),
                GenerationResult(status=GenerationStatus.SUCCESS, output=valid_turn_output),
            ]
        )

        result = await run_repair_loop(sample_turn_input)

        assert result.is_fallback is False
        assert result.repair_attempts == 1
        # 첫 시도에서 SCHEMA_OK는 받았지만 비즈니스 룰에서 걸려야 함
        assert result.repair_attempts == 1


@pytest.mark.asyncio
async def test_repair_loop_max_attempts_fallback(sample_turn_input: TurnInput) -> None:
    """모든 시도가 실패하여 폴백이 반환되는 케이스."""
    with patch("unknown_world.orchestrator.repair_loop.get_turn_output_generator") as mock_get_gen:
        mock_gen = mock_get_gen.return_value
        # 계속 스키마 실패
        mock_gen.generate = AsyncMock(
            return_value=GenerationResult(
                status=GenerationStatus.SCHEMA_FAILURE, error_message="Constant failure"
            )
        )

        result = await run_repair_loop(sample_turn_input)

        assert result.is_fallback is True
        assert result.repair_attempts == MAX_REPAIR_ATTEMPTS
        assert ValidationBadge.SCHEMA_FAIL in result.badges
        # 폴백 내러티브 확인
        assert "혼란스러운 순간" in result.output.narrative


@pytest.mark.asyncio
async def test_repair_loop_safety_blocked_immediate_fallback(sample_turn_input: TurnInput) -> None:
    """안전 차단 시 즉시 폴백되는 케이스."""
    with patch("unknown_world.orchestrator.repair_loop.get_turn_output_generator") as mock_get_gen:
        mock_gen = mock_get_gen.return_value
        mock_gen.generate = AsyncMock(
            return_value=GenerationResult(
                status=GenerationStatus.SAFETY_BLOCKED, error_message="Safety block"
            )
        )

        result = await run_repair_loop(sample_turn_input)

        assert result.is_fallback is True
        assert result.repair_attempts == 0  # 즉시 중단
        assert ValidationBadge.SAFETY_BLOCKED in result.badges
        assert result.output.safety.blocked is True


@pytest.mark.asyncio
async def test_validate_economy_negative_attempt(sample_turn_input: TurnInput) -> None:
    """재화가 부족한데 비용을 청구하여 음수 잔액을 만들려고 시도하는 경우."""
    # snapshot: signal=100
    # cost: signal=120
    # balance_after: signal=-20 (위반)

    invalid_output = TurnOutput(
        language=Language.KO,
        narrative="비싼 행동",
        ui=UIOutput(action_deck=ActionDeck(cards=[]), objects=[]),
        world=WorldDelta(),
        render=RenderOutput(image_job=None),
        economy=EconomyOutput(
            cost=CurrencyAmount(signal=120, memory_shard=0),
            balance_after=CurrencyAmount(
                signal=0, memory_shard=5
            ),  # 0으로 억지 보정 또는 음수 필드 오류
        ),
        safety=SafetyOutput(blocked=False),
        agent_console=AgentConsole(repair_count=0),
    )

    result = validate_business_rules(sample_turn_input, invalid_output)

    assert result.is_valid is False
    # Signal 잔액 불일치 또는 Credit 불일치 감지
    assert any(
        "signal" in err["message"].lower() or "credit" in err["message"].lower()
        for err in result.errors
    )


@pytest.mark.asyncio
async def test_validate_economy_allow_credit(sample_turn_input: TurnInput) -> None:
    """잔액보다 높은 비용이지만 크레딧 한도 내인 경우 허용 확인 (U-079)."""
    # snapshot: signal=100
    # cost: signal=130 (빚 30 필요)
    # MAX_CREDIT = 50 이므로 통과해야 함

    valid_credit_output = TurnOutput(
        language=Language.KO,
        narrative="크레딧 사용",
        ui=UIOutput(action_deck=ActionDeck(cards=[]), objects=[]),
        world=WorldDelta(),
        render=RenderOutput(image_job=None),
        economy=EconomyOutput(
            cost=CurrencyAmount(signal=130, memory_shard=0),
            balance_after=CurrencyAmount(signal=0, memory_shard=5),
            credit=30,  # 빚 30 명시
            low_balance_warning=True,
        ),
        safety=SafetyOutput(blocked=False),
        agent_console=AgentConsole(repair_count=0),
    )

    result = validate_business_rules(sample_turn_input, valid_credit_output)

    assert result.is_valid is True
    assert not result.errors
</file>

<file path="backend/tests/unit/test_u034_verification.py">
import json
from pathlib import Path

# 프로젝트 루트 경로 설정 (backend/tests/unit/ 위치 기준)
ROOT_DIR = Path(__file__).parent.parent.parent.parent
SCHEMA_PATH = ROOT_DIR / "vibe/ref/nanobanana-asset-request.schema.json"
GUIDE_PATH = ROOT_DIR / "vibe/ref/nanobanana-mcp.md"


def test_schema_file_exists():
    """스키마 파일이 지정된 위치에 존재하는지 확인"""
    assert SCHEMA_PATH.exists(), f"Schema file not found at {SCHEMA_PATH}"


def test_schema_is_valid_json():
    """스키마 파일이 유효한 JSON 형식인지 확인"""
    with open(SCHEMA_PATH, encoding="utf-8") as f:
        schema = json.load(f)
    assert schema["title"] == "nanobanana mcp Asset Request Schema"


def test_schema_required_properties():
    """스키마의 JSON Schema required 필드가 정의되어 있는지 확인

    NOTE: JSON Schema의 `required` 배열과 "워크플로우 필수(조건부)" 필드는 구분됨.
    - Schema required: ["id", "category", "purpose", "size_px"] (SSOT)
    - Workflow required: requires_rembg, rembg_options.model 등은 조건부 필드
    """
    with open(SCHEMA_PATH, encoding="utf-8") as f:
        schema = json.load(f)

    properties = schema.get("properties", {})
    # JSON Schema의 required 필드만 검증 (스키마 SSOT 기준)
    schema_required_fields = ["id", "category", "purpose", "size_px"]
    # 워크플로우에서 자주 사용하는 선택적 필드 (properties에 정의되어 있어야 함)
    optional_workflow_fields = ["requires_rembg", "rembg_options"]

    for field in schema_required_fields:
        assert field in properties, f"Schema required field '{field}' missing in properties"

    for field in optional_workflow_fields:
        assert field in properties, f"Workflow field '{field}' missing in properties"


def test_schema_rembg_options_model():
    """rembg 모델 선택의 SSOT가 rembg_options.model인지 확인

    NOTE: 이전에 top-level rembg_model 필드가 논의되었으나,
    SSOT는 rembg_options.model로 확정됨 (U-040 페어링 결정).
    """
    with open(SCHEMA_PATH, encoding="utf-8") as f:
        schema = json.load(f)

    # rembg_options가 존재하고 model 서브필드가 있어야 함
    rembg_options = schema["properties"].get("rembg_options", {})
    assert rembg_options.get("type") == "object", "rembg_options should be an object"

    rembg_options_props = rembg_options.get("properties", {})
    assert "model" in rembg_options_props, (
        "SSOT field 'rembg_options.model' missing - "
        "rembg 모델 선택은 top-level 'rembg_model'이 아닌 'rembg_options.model'이 SSOT입니다"
    )

    # model 필드의 enum이 유효한 rembg 모델 목록을 포함하는지 확인
    model_field = rembg_options_props["model"]
    assert "enum" in model_field, "rembg_options.model should have enum constraint"
    assert "birefnet-general" in model_field["enum"], (
        "Default model 'birefnet-general' should be in enum"
    )


def test_guide_file_exists():
    """가이드 문서 파일이 존재하는지 확인"""
    assert GUIDE_PATH.exists(), f"Guide file not found at {GUIDE_PATH}"


def test_guide_content_completeness():
    """가이드 문서에 필수 섹션(아트 디렉션, 카테고리별 템플릿)이 포함되어 있는지 확인"""
    with open(GUIDE_PATH, encoding="utf-8") as f:
        content = f.read()

    # 계획서 구현 흐름 2단계, 3단계 관련 키워드 검사
    required_keywords = ["아트 디렉션", "스타일", "아이콘", "placeholder", "chrome", "템플릿"]

    missing_keywords = [kw for kw in required_keywords if kw.lower() not in content.lower()]

    # 현재 nanobanana-mcp.md에는 rembg 내용만 있으므로 실패할 가능성이 큼
    assert not missing_keywords, (
        f"Guide document is missing sections for: {', '.join(missing_keywords)}"
    )


def test_schema_rembg_rules():
    """배경 제거(rembg) 관련 강제 규칙(순백 배경)이 스키마/설명에 포함되어 있는지 확인"""
    with open(SCHEMA_PATH, encoding="utf-8") as f:
        schema = json.load(f)

    # background 필드와 requires_rembg 필드 설명 확인
    background_desc = schema["properties"]["background"].get("description", "")
    rembg_desc = schema["properties"]["requires_rembg"].get("description", "")

    assert "solid_white" in str(schema["properties"]["background"].get("enum", [])), (
        "background enum should include solid_white"
    )
    assert "rembg" in background_desc.lower(), "background description should mention rembg"
    assert "solid_white" in rembg_desc.lower(), (
        "requires_rembg description should recommend solid_white"
    )
</file>

<file path="backend/tests/unit/test_u068_reference_image.py">
"""U-068: 이전 턴 이미지를 참조이미지로 사용하는 기능 테스트."""

import pytest

from unknown_world.models.turn import ImageJob, ModelLabel
from unknown_world.services.image_generation import ImageGenerationRequest, MockImageGenerator


def test_image_job_reference_image_url_field():
    """ImageJob 모델에 reference_image_url 필드가 있는지 확인합니다."""
    job = ImageJob(
        should_generate=True,
        prompt="A mysterious forest",
        model_label=ModelLabel.QUALITY,
        reference_image_url="http://example.com/prev.png",  # 이 부분이 실패해야 함
    )
    assert job.reference_image_url == "http://example.com/prev.png"


@pytest.mark.asyncio
async def test_mock_generator_handles_reference_image_url():
    """MockImageGenerator가 reference_image_url이 포함된 요청을 처리하는지 확인합니다."""
    generator = MockImageGenerator()
    request = ImageGenerationRequest(
        prompt="A mysterious forest", reference_image_url="http://example.com/prev.png"
    )

    # MockImageGenerator.generate는 현재 reference_image_url을 무시하지만 에러는 나지 않아야 함
    response = await generator.generate(request)
    assert response.status.value == "completed"
    assert response.image_url is not None
</file>

<file path="backend/tests/unit/test_u079_economy_low_balance.py">
"""U-079[Mvp]: 재화 부족 시 이미지 생성 허용 및 필드 검증 테스트."""

import pytest

from unknown_world.models.turn import (
    AgentConsole,
    AgentPhase,
    ClientInfo,
    CurrencyAmount,
    EconomyOutput,
    EconomySnapshot,
    ImageJob,
    Language,
    RenderOutput,
    SafetyOutput,
    TurnInput,
    TurnOutput,
)
from unknown_world.orchestrator.stages.render import render_stage
from unknown_world.orchestrator.stages.types import PipelineContext
from unknown_world.services.image_generation import MockImageGenerator

# =============================================================================
# 필드 추가 검증 (Red Phase)
# =============================================================================


def test_economy_output_has_u079_fields():
    """EconomyOutput에 credit과 low_balance_warning 필드가 있는지 확인."""
    data = {
        "cost": {"signal": 10, "memory_shard": 0},
        "balance_after": {"signal": 0, "memory_shard": 5},
        "credit": 5,
        "low_balance_warning": True,
    }
    # 이 테스트는 모델 수정 전에는 실패해야 함 (extra="forbid" 때문이거나 필드 누락)
    economy = EconomyOutput(**data)
    assert economy.credit == 5
    assert economy.low_balance_warning is True


# =============================================================================
# Render Stage FAST 폴백 비용 업데이트 검증
# =============================================================================


@pytest.mark.asyncio
async def test_render_stage_updates_cost_on_low_balance():
    """잔액 부족으로 FAST 폴백 시 TurnOutput의 비용이 0으로 업데이트되는지 확인."""
    # 1. Given: 잔액 부족 상황 (Signal 5, 필요 10)
    economy_snapshot = CurrencyAmount(signal=5, memory_shard=0)

    turn_input = TurnInput(
        language=Language.KO,
        text="방을 조사한다",
        client=ClientInfo(viewport_w=1920, viewport_h=1080),
        economy_snapshot=EconomySnapshot(signal=5, memory_shard=0),
    )

    # AI가 이미지 생성을 원한다고 가정 (QUALITY 모델, 비용 10)
    original_economy = EconomyOutput(
        cost=CurrencyAmount(signal=10, memory_shard=0),
        balance_after=CurrencyAmount(signal=0, memory_shard=0),  # LLM은 대충 0으로 줄 수 있음
    )

    turn_output = TurnOutput(
        language=Language.KO,
        narrative="무언가 보입니다.",
        economy=original_economy,
        safety=SafetyOutput(blocked=False),
        render=RenderOutput(
            image_job=ImageJob(should_generate=True, prompt="A dark room", model_label="QUALITY")
        ),
        agent_console=AgentConsole(current_phase=AgentPhase.RENDER),
    )

    ctx = PipelineContext(
        turn_input=turn_input,
        economy_snapshot=economy_snapshot,
        is_mock=True,
        output=turn_output,
        image_generator=MockImageGenerator(),
    )

    # 2. When: render_stage 실행
    async def mock_emit(event):
        pass

    updated_ctx = await render_stage(ctx, emit=mock_emit)

    # 3. Then: 비용이 FAST_IMAGE_COST_SIGNAL(0)로 업데이트되었는지 확인
    # (이 로직은 아직 구현되지 않았으므로 실패해야 함)
    assert updated_ctx.output.economy.cost.signal == 0
    # balance_after도 스냅샷 유지 (5 - 0 = 5)
    assert updated_ctx.output.economy.balance_after.signal == 5
    # low_balance_warning이 설정되었는지 확인
    assert updated_ctx.output.economy.low_balance_warning is True


# =============================================================================
# 크레딧(빚) 시스템 검증
# =============================================================================


def test_economy_validation_allows_credit():
    """잔액보다 큰 비용 지불 시 크레딧이 올바르게 검증되는지 확인."""
    from unknown_world.validation.business_rules import validate_business_rules

    # 1. Given: 잔액 5, 비용 10 (크레딧 5 필요)
    turn_input = TurnInput(
        language=Language.KO,
        text="테스트",
        client=ClientInfo(viewport_w=1920, viewport_h=1080),
        economy_snapshot=EconomySnapshot(signal=5, memory_shard=0),
    )

    turn_output = TurnOutput(
        language=Language.KO,
        narrative="결과",
        economy=EconomyOutput(
            cost=CurrencyAmount(signal=10, memory_shard=0),
            balance_after=CurrencyAmount(signal=0, memory_shard=0),
            credit=5,  # 빚 5
            low_balance_warning=True,
        ),
        safety=SafetyOutput(blocked=False),
    )

    # 2. When: 비즈니스 룰 검증
    result = validate_business_rules(turn_input, turn_output)

    # 3. Then: 검증 통과
    assert result.is_valid is True
    assert not result.errors


def test_economy_validation_fails_on_excessive_credit():
    """MAX_CREDIT(50)을 초과하는 비용은 거부되어야 함."""
    from unknown_world.validation.business_rules import validate_business_rules

    # 1. Given: 잔액 5, 비용 60 (크레딧 55 필요, 한도 50 초과)
    turn_input = TurnInput(
        language=Language.KO,
        text="테스트",
        client=ClientInfo(viewport_w=1920, viewport_h=1080),
        economy_snapshot=EconomySnapshot(signal=5, memory_shard=0),
    )

    turn_output = TurnOutput(
        language=Language.KO,
        narrative="결과",
        economy=EconomyOutput(
            cost=CurrencyAmount(signal=60, memory_shard=0),
            balance_after=CurrencyAmount(signal=0, memory_shard=0),
            credit=55,
            low_balance_warning=True,
        ),
        safety=SafetyOutput(blocked=False),
    )

    # 2. When: 비즈니스 룰 검증
    result = validate_business_rules(turn_input, turn_output)

    # 3. Then: 검증 실패
    assert result.is_valid is False
    assert any("economy_negative_balance" in err["type"] for err in result.errors)
</file>

<file path="backend/tests/unit/test_u096_consumption.py">
from unknown_world.models.turn import TurnOutput, WorldDelta


def test_world_delta_inventory_removed_serialization():
    """WorldDelta의 inventory_removed 필드 직렬화/역직렬화 테스트 (U-096)."""
    delta_data = {
        "inventory_added": [],
        "inventory_removed": ["key_01", "potion_02"],
        "rules_changed": [],
        "quests_updated": [],
        "relationships_changed": [],
        "memory_pins": [],
    }
    delta = WorldDelta(**delta_data)

    assert delta.inventory_removed == ["key_01", "potion_02"]

    # JSON 직렬화 확인
    json_data = delta.model_dump()
    assert json_data["inventory_removed"] == ["key_01", "potion_02"]


def test_turn_output_with_consumption():
    """아이템 소비가 포함된 전체 TurnOutput 스키마 검증."""
    output_data = {
        "language": "ko-KR",
        "narrative": "열쇠를 사용했습니다. 열쇠가 사라졌습니다.",
        "economy": {
            "cost": {"signal": 5, "memory_shard": 0},
            "balance_after": {"signal": 95, "memory_shard": 5},
        },
        "safety": {"blocked": False, "message": None},
        "ui": {"action_deck": {"cards": []}, "objects": []},
        "world": {
            "inventory_added": [],
            "inventory_removed": ["iron_key_01"],
            "rules_changed": [],
            "quests_updated": [],
            "relationships_changed": [],
            "memory_pins": [],
        },
        "render": {"image_job": None},
        "agent_console": {
            "current_phase": "commit",
            "badges": ["schema_ok"],
            "repair_count": 0,
            "model_label": "FAST",
        },
    }

    output = TurnOutput(**output_data)
    assert "iron_key_01" in output.world.inventory_removed
    assert output.narrative == "열쇠를 사용했습니다. 열쇠가 사라졌습니다."
</file>

<file path="frontend/src/api/turnStream.test.ts">
import { describe, it, expect, vi, beforeEach } from 'vitest';
import { NDJSONParser } from './turnStream';

describe('NDJSONParser', () => {
  let parser: NDJSONParser;

  beforeEach(() => {
    parser = new NDJSONParser();
  });

  it('should parse a single complete line', () => {
    const chunk = JSON.stringify({ type: 'test', value: 1 }) + '\n';
    const results = parser.parse(chunk);
    expect(results).toHaveLength(1);
    expect(results[0]).toEqual({ type: 'test', value: 1 });
  });

  it('should parse multiple complete lines in one chunk', () => {
    const chunk = JSON.stringify({ id: 1 }) + '\n' + JSON.stringify({ id: 2 }) + '\n';
    const results = parser.parse(chunk);
    expect(results).toHaveLength(2);
    expect(results[0]).toEqual({ id: 1 });
    expect(results[1]).toEqual({ id: 2 });
  });

  it('should buffer partial lines and parse them when completed', () => {
    const chunk1 = '{"id": 1';
    const chunk2 = ', "val": "ok"}\n';

    const results1 = parser.parse(chunk1);
    expect(results1).toHaveLength(0);

    const results2 = parser.parse(chunk2);
    expect(results2).toHaveLength(1);
    expect(results2[0]).toEqual({ id: 1, val: 'ok' });
  });

  it('should ignore empty lines', () => {
    const chunk = '\n\n{"a":1}\n\n';
    const results = parser.parse(chunk);
    expect(results).toHaveLength(1);
  });

  it('should not crash on invalid JSON and continue', () => {
    const consoleSpy = vi.spyOn(console, 'warn').mockImplementation(() => {});
    const chunk = 'invalid json\n{"valid": true}\n';
    const results = parser.parse(chunk);

    expect(results).toHaveLength(1);
    expect(results[0]).toEqual({ valid: true });
    expect(consoleSpy).toHaveBeenCalled();
    consoleSpy.mockRestore();
  });

  it('should flush remaining buffer', () => {
    parser.parse('{"id": 1}'); // No newline
    const result = parser.flush();
    expect(result).toEqual({ id: 1 });
  });

  it('should return null on flush with empty buffer', () => {
    const result = parser.flush();
    expect(result).toBeNull();
  });
});

describe('executeTurnStream', () => {
  const mockInput = {
    language: 'ko-KR' as const,
    text: 'Hello',
    action_id: null,
    click: null,
    drop: null, // U-012: 드롭 입력 필드 추가
    client: { viewport_w: 100, viewport_h: 100, theme: 'dark' as const },
    economy_snapshot: { signal: 100, memory_shard: 0 },
    previous_image_url: null,
  };

  const mockCallbacks = {
    onStage: vi.fn(),
    onRepair: vi.fn(),
    onBadges: vi.fn(),
    onNarrativeDelta: vi.fn(),
    onFinal: vi.fn(),
    onError: vi.fn(),
    onComplete: vi.fn(),
  };

  beforeEach(() => {
    vi.clearAllMocks();
    global.fetch = vi.fn();
  });

  it('should process stream events correctly (including repair)', async () => {
    const encoder = new TextEncoder();
    const stream = new ReadableStream({
      start(controller) {
        controller.enqueue(
          encoder.encode(JSON.stringify({ type: 'stage', name: 'parse', status: 'start' }) + '\n'),
        );
        controller.enqueue(
          encoder.encode(
            JSON.stringify({ type: 'repair', attempt: 1, message: 'Schema fail, retrying' }) + '\n',
          ),
        );
        controller.enqueue(
          encoder.encode(JSON.stringify({ type: 'narrative_delta', text: 'Hello' }) + '\n'),
        );
        controller.enqueue(
          encoder.encode(
            JSON.stringify({
              type: 'final',
              data: {
                language: 'ko-KR',
                narrative: 'Hello',
                economy: {
                  cost: { signal: 0, memory_shard: 0 },
                  balance_after: { signal: 100, memory_shard: 0 },
                },
                safety: { blocked: false },
              },
            }) + '\n',
          ),
        );
        controller.close();
      },
    });

    (global.fetch as unknown as ReturnType<typeof vi.fn>).mockResolvedValue({
      ok: true,
      body: stream,
    });

    const { executeTurnStream } = await import('./turnStream');
    await executeTurnStream(mockInput, mockCallbacks);

    expect(mockCallbacks.onStage).toHaveBeenCalledWith(expect.objectContaining({ name: 'parse' }));
    expect(mockCallbacks.onRepair).toHaveBeenCalledWith(
      expect.objectContaining({ attempt: 1, message: 'Schema fail, retrying' }),
    );
    expect(mockCallbacks.onNarrativeDelta).toHaveBeenCalledWith(
      expect.objectContaining({ text: 'Hello' }),
    );
    expect(mockCallbacks.onFinal).toHaveBeenCalled();
    expect(mockCallbacks.onComplete).toHaveBeenCalled();
  });

  it('should handle HTTP errors', async () => {
    (global.fetch as unknown as ReturnType<typeof vi.fn>).mockResolvedValue({
      ok: false,
      status: 500,
      statusText: 'Internal Server Error',
    });

    const { executeTurnStream } = await import('./turnStream');
    await executeTurnStream(mockInput, mockCallbacks);

    expect(mockCallbacks.onError).toHaveBeenCalledWith(
      expect.objectContaining({
        code: 'STREAM_ERROR',
        message: expect.stringContaining('500'),
      }),
    );
  });

  it('should handle fetch rejection', async () => {
    (global.fetch as unknown as ReturnType<typeof vi.fn>).mockRejectedValue(
      new Error('Network failure'),
    );

    const { executeTurnStream } = await import('./turnStream');
    await executeTurnStream(mockInput, mockCallbacks);

    expect(mockCallbacks.onError).toHaveBeenCalledWith(
      expect.objectContaining({
        message: 'Network failure',
      }),
    );
  });
});
</file>

<file path="frontend/src/App.inputLock.test.tsx">
import { describe, it, expect, vi, beforeEach } from 'vitest';
import { render, screen, fireEvent, waitFor, act } from '@testing-library/react';
import App from './App';
import * as turnStream from './api/turnStream';
import { useWorldStore } from './stores/worldStore';
import { useAgentStore } from './stores/agentStore';

// i18next 모킹
vi.mock('react-i18next', () => ({
  useTranslation: () => ({
    t: (key: string) => key,
    i18n: {
      changeLanguage: () => Promise.resolve(),
      resolvedLanguage: 'ko-KR',
    },
  }),
  initReactI18next: {
    type: '3rdParty',
    init: () => {},
  },
}));

// ResizeObserver 모킹
class MockResizeObserver {
  observe = vi.fn();
  unobserve = vi.fn();
  disconnect = vi.fn();
}
global.ResizeObserver = MockResizeObserver as unknown as typeof ResizeObserver;

// api 모킹
vi.mock('./api/turnStream', () => ({
  startTurnStream: vi.fn(),
}));

describe('App - U-087 Input Locking Integration', () => {
  beforeEach(() => {
    vi.clearAllMocks();
    localStorage.clear();
    useWorldStore.getState().reset();
    useAgentStore.getState().reset();

    // getBoundingClientRect 모킹
    Element.prototype.getBoundingClientRect = vi.fn(() => ({
      width: 800,
      height: 600,
      top: 0,
      left: 0,
      bottom: 600,
      right: 800,
      x: 0,
      y: 0,
      toJSON: () => {},
    })) as unknown as () => DOMRect;
  });

  const selectProfileAndStart = async () => {
    render(<App />);
    const techProfile = screen.getByLabelText('profile.tech.name');
    fireEvent.click(techProfile);

    await waitFor(() => {
      expect(screen.getByText('panel.agent_console.title')).toBeInTheDocument();
    });
  };

  it('prevents interaction when isStreaming is true', async () => {
    await selectProfileAndStart();

    // 1. 스트리밍 상태 시작
    await act(async () => {
      useAgentStore.getState().startStream();
    });

    // 2. 입력 잠금 시각적 피드백 확인 (placeholder)
    await waitFor(
      () => {
        const input = screen.getByRole('textbox') as HTMLInputElement;
        expect(input.placeholder).toBe('ui.input_locked');
        expect(input.disabled).toBe(true);
      },
      { timeout: 2000 },
    );

    // 3. 카드 클릭 시도
    const cards = screen.getAllByRole('button', { name: /action.default/ });
    if (cards.length > 0) {
      fireEvent.click(cards[0]);
    }

    // 4. 검증: 턴 실행 및 액션 로그 생성 차단
    expect(turnStream.startTurnStream).not.toHaveBeenCalled();
    const entries = useWorldStore.getState().narrativeEntries;
    expect(entries.filter((e) => e.type === 'action_log')).toHaveLength(0);
  });

  it('prevents interaction when processingPhase is not idle', async () => {
    await selectProfileAndStart();

    // 1. 처리 단계 설정
    await act(async () => {
      useWorldStore.getState().setProcessingPhase('processing');
    });

    // 2. UI 상태 확인 (제출 버튼 텍스트)
    await waitFor(() => {
      expect(screen.getByRole('button', { name: 'ui.wait' })).toBeInTheDocument();
    });

    // 3. 커맨드 제출 시도
    const submitBtn = screen.getByRole('button', { name: 'ui.wait' });
    fireEvent.click(submitBtn);

    // 4. 검증
    expect(turnStream.startTurnStream).not.toHaveBeenCalled();
  });

  it('prevents interaction when imageLoading is true', async () => {
    await selectProfileAndStart();

    // 1. 이미지 로딩 상태 설정
    await act(async () => {
      useWorldStore.getState().setImageLoading(1);
    });

    // 2. 입력 잠금 확인 (placeholder 및 disabled)
    await waitFor(() => {
      const input = screen.getByRole('textbox') as HTMLInputElement;
      expect(input.placeholder).toBe('ui.input_locked');
      expect(input.disabled).toBe(true);

      const submitBtn = screen.getByRole('button', { name: 'ui.wait' });
      expect(submitBtn).toBeDisabled();
    });

    // 3. 검증 (액션 로그 생성 차단)
    const entries = useWorldStore.getState().narrativeEntries;
    expect(entries.filter((e) => e.type === 'action_log')).toHaveLength(0);
  });
});
</file>

<file path="frontend/src/components/EconomyHud.i18n.test.tsx">
import { describe, it, expect, beforeEach, vi } from 'vitest';
import { render, screen } from '@testing-library/react';
import { EconomyHud } from './EconomyHud';
import { useEconomyStore } from '../stores/economyStore';
import { useWorldStore } from '../stores/worldStore';

// react-i18next 모킹
vi.mock('react-i18next', () => ({
  useTranslation: () => ({
    // t 함수가 호출됨을 검증하기 위해 키를 변형하여 반환
    t: (key: string) => `translated_${key}`,
  }),
  initReactI18next: {
    type: '3rdParty',
    init: () => {},
  },
}));

describe('EconomyHud i18n 정합성 테스트 (U-099)', () => {
  beforeEach(() => {
    useEconomyStore.getState().reset();
    useWorldStore.getState().reset();
    useEconomyStore.getState().clearLedger();
  });

  it('거래 장부의 항목이 t 함수를 통해 번역되어 표시되어야 한다', () => {
    const { addLedgerEntry } = useEconomyStore.getState();

    // 1. 일반 키 추가
    addLedgerEntry({
      turnId: 1,
      reason: 'economy.ledger_reason.turn_cost',
      cost: { signal: 10, memory_shard: 0 },
      balanceAfter: { signal: 90, memory_shard: 5 },
      modelLabel: 'FAST',
    });

    // 2. 파라미터 포함 키 추가 (key|param)
    addLedgerEntry({
      turnId: 2,
      reason: 'inventory.sell_ledger_reason|Ancient Tome',
      cost: { signal: -50, memory_shard: 0 },
      balanceAfter: { signal: 140, memory_shard: 5 },
      modelLabel: 'FAST',
    });

    render(<EconomyHud />);

    // 일반 키 번역 확인
    expect(screen.getByText('translated_economy.ledger_reason.turn_cost')).toBeInTheDocument();

    // 파라미터 포함 키 번역 확인
    // "translated_inventory.sell_ledger_reason: Ancient Tome" 형식이 되어야 함
    expect(
      screen.getByText('translated_inventory.sell_ledger_reason: Ancient Tome'),
    ).toBeInTheDocument();
  });
});
</file>

<file path="frontend/src/components/GameHeader.tsx">
import type { ReactNode } from 'react';
import { useTranslation } from 'react-i18next';
import { UIControls } from './UIControls';
import { EconomyHudHeader } from './EconomyHud';
import type { UIScale } from '../stores/uiPrefsStore';
import { useEconomyStore, selectIsBalanceLow } from '../stores/economyStore';

interface GameHeaderProps {
  signal: number;
  memoryShard: number;
  credit: number;
  isConnected: boolean;
  uiScale: UIScale;
  onIncreaseScale: () => void;
  onDecreaseScale: () => void;
  /** U-015: 추가 컨트롤 (리셋/프로필 변경 버튼 등) */
  children?: ReactNode;
}

export function GameHeader({
  signal,
  memoryShard,
  credit,
  isConnected,
  uiScale,
  onIncreaseScale,
  onDecreaseScale,
  children,
}: GameHeaderProps) {
  const { t } = useTranslation();
  const isBalanceLow = useEconomyStore(selectIsBalanceLow);

  return (
    <header className="game-header has-chrome">
      <h1 className="game-title glitch" data-text={t('ui.logo')}>
        {t('ui.logo')}
      </h1>
      <div className="header-controls">
        {/* U-015: 리셋/프로필 변경 등 추가 컨트롤 */}
        {children}
        {/* UI 스케일 컨트롤 (U-028→U-037: Readable 제거) */}
        <UIControls
          uiScale={uiScale}
          onIncreaseScale={onIncreaseScale}
          onDecreaseScale={onDecreaseScale}
        />
        {/* Economy HUD (U-014: 예상 비용/확정 비용 표시 포함) */}
        <EconomyHudHeader
          signal={signal}
          memoryShard={memoryShard}
          credit={credit}
          isLow={isBalanceLow}
        />
        <div className="connection-status">
          <span className={`status-indicator ${isConnected ? '' : 'offline'}`} />
          <span>{isConnected ? t('connection.online') : t('connection.offline')}</span>
        </div>
      </div>
    </header>
  );
}
</file>

<file path="frontend/src/components/InteractionHint.test.tsx">
import { describe, it, expect } from 'vitest';
import { render, screen } from '@testing-library/react';
import { InteractionHint } from './InteractionHint';

describe('InteractionHint', () => {
  it('전달된 텍스트를 올바르게 렌더링해야 한다', () => {
    const testText = '테스트 힌트 텍스트';
    render(<InteractionHint text={testText} />);

    expect(screen.getByText(testText)).toBeInTheDocument();
  });

  it('아이콘 타입에 따라 적절한 aria-hidden SVG를 포함해야 한다', () => {
    const { container } = render(<InteractionHint text="클릭" icon="click" />);

    const svg = container.querySelector('svg');
    expect(svg).toBeInTheDocument();
    expect(svg).toHaveAttribute('aria-hidden', 'true');
    expect(container.querySelector('.interaction-hint-icon')).toBeInTheDocument();
  });

  it('위치 props에 따라 적절한 클래스를 가져야 한다', () => {
    const { container: topContainer } = render(<InteractionHint text="위" position="top" />);
    expect(topContainer.firstChild).toHaveClass('interaction-hint--top');

    const { container: bottomContainer } = render(
      <InteractionHint text="아래" position="bottom" />,
    );
    expect(bottomContainer.firstChild).toHaveClass('interaction-hint--bottom');
  });

  it('aria-label이 설정되어야 한다', () => {
    render(<InteractionHint text="조사하기" ariaLabel="커스텀 라벨" />);
    expect(screen.getByRole('tooltip')).toHaveAttribute('aria-label', '커스텀 라벨');
  });
});
</file>

<file path="frontend/src/components/InteractionHint.tsx">
/**
 * Unknown World - 인터랙션 힌트 컴포넌트
 *
 * U-074[Mvp]: 핫스팟/아이템 인터랙션 안내 UX
 * - 재사용 가능한 힌트 툴팁 컴포넌트
 * - 클릭/드래그/드롭 아이콘 + 텍스트 표시
 * - Q1 Option B: 첫 N번만 표시 후 숨김
 *
 * RULE-006 준수: i18n 키 기반 텍스트
 * RULE-002 준수: 채팅 UI가 아닌 게임 UI
 *
 * @module components/InteractionHint
 */

import { memo } from 'react';
import '../styles/interaction-hint.css';

// =============================================================================
// 타입 정의
// =============================================================================

export type HintIconType = 'click' | 'drag' | 'drop' | 'scanner';
export type HintPosition = 'top' | 'bottom' | 'left' | 'right';

interface InteractionHintProps {
  /** 힌트 텍스트 (i18n 처리된 문자열) */
  text: string;

  /** 아이콘 타입 */
  icon?: HintIconType;

  /** 힌트 위치 */
  position?: HintPosition;

  /** 추가 CSS 클래스 */
  className?: string;

  /** 접근성: aria-label 오버라이드 */
  ariaLabel?: string;
}

// =============================================================================
// 아이콘 컴포넌트
// =============================================================================

/**
 * 힌트 아이콘 SVG
 *
 * 간단한 인라인 SVG로 아이콘을 표현합니다.
 * 외부 이미지 에셋 없이 순수 CSS/SVG로 구현.
 */
function HintIcon({ type }: { type: HintIconType }) {
  switch (type) {
    case 'click':
      // 마우스 클릭 아이콘 (간단한 포인터)
      return (
        <svg
          className="interaction-hint-icon"
          viewBox="0 0 24 24"
          fill="none"
          stroke="currentColor"
          strokeWidth="2"
          strokeLinecap="round"
          strokeLinejoin="round"
          aria-hidden="true"
        >
          {/* 마우스 포인터 모양 */}
          <path d="M4 4l7.07 17 2.51-7.39L21 11.07z" />
          <line x1="13.5" y1="13.5" x2="19" y2="19" />
        </svg>
      );

    case 'drag':
      // 드래그 아이콘 (손 + 화살표)
      return (
        <svg
          className="interaction-hint-icon"
          viewBox="0 0 24 24"
          fill="none"
          stroke="currentColor"
          strokeWidth="2"
          strokeLinecap="round"
          strokeLinejoin="round"
          aria-hidden="true"
        >
          {/* 손 모양 */}
          <path d="M18 11V6a2 2 0 0 0-4 0v5" />
          <path d="M14 10V4a2 2 0 0 0-4 0v6" />
          <path d="M10 10.5V6a2 2 0 0 0-4 0v8" />
          <path d="M18 8a2 2 0 0 1 4 0v6a8 8 0 0 1-8 8h-2c-2.8 0-4.5-.86-5.99-2.34l-3.6-3.6a2 2 0 0 1 2.83-2.82L7 15" />
        </svg>
      );

    case 'drop':
      // 드롭 아이콘 (다운 화살표 + 박스)
      return (
        <svg
          className="interaction-hint-icon"
          viewBox="0 0 24 24"
          fill="none"
          stroke="currentColor"
          strokeWidth="2"
          strokeLinecap="round"
          strokeLinejoin="round"
          aria-hidden="true"
        >
          {/* 박스 */}
          <rect x="3" y="11" width="18" height="10" rx="2" />
          {/* 다운 화살표 */}
          <path d="M12 3v8" />
          <path d="M8 7l4 4 4-4" />
        </svg>
      );

    case 'scanner':
      // 스캐너 아이콘 (카메라/업로드)
      return (
        <svg
          className="interaction-hint-icon"
          viewBox="0 0 24 24"
          fill="none"
          stroke="currentColor"
          strokeWidth="2"
          strokeLinecap="round"
          strokeLinejoin="round"
          aria-hidden="true"
        >
          {/* 업로드 아이콘 */}
          <path d="M21 15v4a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2v-4" />
          <polyline points="17 8 12 3 7 8" />
          <line x1="12" y1="3" x2="12" y2="15" />
        </svg>
      );

    default:
      return null;
  }
}

// =============================================================================
// 메인 컴포넌트
// =============================================================================

/**
 * 인터랙션 힌트 컴포넌트
 *
 * 핫스팟/아이템 위에 표시되는 작은 툴팁 형태의 힌트입니다.
 * U-074[Mvp] Q1 Option B에 따라 첫 N번만 표시됩니다.
 *
 * @example
 * ```tsx
 * <InteractionHint
 *   text={t('interaction.hotspot_click')}
 *   icon="click"
 *   position="top"
 * />
 * ```
 */
function InteractionHintComponent({
  text,
  icon,
  position = 'top',
  className = '',
  ariaLabel,
}: InteractionHintProps) {
  const positionClass = `interaction-hint--${position}`;

  return (
    <div
      className={`interaction-hint ${positionClass} ${className}`.trim()}
      role="tooltip"
      aria-label={ariaLabel ?? text}
    >
      <div className="interaction-hint-content">
        {icon && <HintIcon type={icon} />}
        <span className="interaction-hint-text">{text}</span>
      </div>
    </div>
  );
}

/**
 * Memoized 인터랙션 힌트 컴포넌트
 *
 * 빈번한 호버 이벤트에서 불필요한 리렌더를 방지합니다.
 */
export const InteractionHint = memo(InteractionHintComponent);

InteractionHint.displayName = 'InteractionHint';

// Re-export types
export type { InteractionHintProps };
</file>

<file path="frontend/src/components/MutationTimeline.test.tsx">
import { describe, it, expect, beforeEach, vi } from 'vitest';
import { render, screen } from '@testing-library/react';
import { MutationTimeline } from './MutationTimeline';
import { useWorldStore } from '../stores/worldStore';

vi.mock('react-i18next', () => ({
  useTranslation: () => ({
    t: (key: string, options?: Record<string, unknown>) => {
      if (options?.turn !== undefined) return `T${options.turn}`;
      if (options?.count !== undefined) return `${key} (count: ${options.count})`;
      return key;
    },
  }),
  initReactI18next: {
    type: '3rdParty',
    init: () => {},
  },
}));

describe('MutationTimeline (U-013)', () => {
  beforeEach(() => {
    useWorldStore.getState().reset();
  });

  it('변형 이력이 없을 때 빈 상태를 표시해야 한다', () => {
    render(<MutationTimeline />);
    expect(screen.getByText('mutation.empty')).toBeInTheDocument();
  });

  it('변형 이벤트 목록을 최신순으로 표시해야 한다', () => {
    useWorldStore.setState({
      mutationTimeline: [
        {
          turn: 2,
          ruleId: 'r2',
          type: 'modified',
          label: '수정된 규칙',
          timestamp: Date.now(),
        },
        {
          turn: 1,
          ruleId: 'r1',
          type: 'added',
          label: '새 규칙',
          timestamp: Date.now() - 1000,
        },
      ],
    });

    render(<MutationTimeline />);
    expect(screen.getByText('mutation.timeline_title')).toBeInTheDocument();
    expect(screen.getAllByText('T2')).toHaveLength(1);
    expect(screen.getByText('수정된 규칙')).toBeInTheDocument();
    expect(screen.getByText('mutation.type.modified')).toBeInTheDocument();

    expect(screen.getAllByText('T1')).toHaveLength(1);
    expect(screen.getByText('새 규칙')).toBeInTheDocument();
    expect(screen.getByText('mutation.type.added')).toBeInTheDocument();
  });

  it('이벤트가 많을 때 "더 보기" 표시를 해야 한다 (최대 10개 기준)', () => {
    const manyEvents = Array.from({ length: 12 }, (_, i) => ({
      turn: i + 1,
      ruleId: `r${i}`,
      type: 'added' as const,
      label: `규칙 ${i}`,
      timestamp: Date.now(),
    })).reverse(); // 최신순

    useWorldStore.setState({ mutationTimeline: manyEvents });

    const { container } = render(<MutationTimeline />);
    // 10개만 렌더링됨
    expect(container.getElementsByClassName('timeline-event')).toHaveLength(10);
    // +2개 더 보기 표시
    expect(screen.getByText('mutation.more_events (count: 2)')).toBeInTheDocument();
  });
});
</file>

<file path="frontend/src/components/NarrativeFeed.U-125.test.tsx">
import { describe, it, expect, beforeEach, vi, afterEach } from 'vitest';
import { render, screen, act } from '@testing-library/react';
import { NarrativeFeed } from './NarrativeFeed';

// i18next 모킹
vi.mock('react-i18next', () => ({
  useTranslation: () => ({
    t: (key: string, params?: Record<string, unknown>) => {
      if (key === 'narrative.turn_label') return `Turn ${params?.turn}`;
      if (key === 'narrative.streaming_label') return 'Streaming';
      return key;
    },
  }),
}));

describe('NarrativeFeed (U-125: Visual Hierarchy)', () => {
  beforeEach(() => {
    vi.useFakeTimers();
    // prefers-reduced-motion 모킹
    Object.defineProperty(window, 'matchMedia', {
      writable: true,
      value: vi.fn().mockImplementation((query) => ({
        matches: false,
        media: query,
        onchange: null,
        addListener: vi.fn(),
        removeListener: vi.fn(),
        addEventListener: vi.fn(),
        removeEventListener: vi.fn(),
        dispatchEvent: vi.fn(),
      })),
    });
  });

  afterEach(() => {
    vi.useRealTimers();
  });

  it('유휴 상태일 때 마지막 엔트리는 narrative-active-text 클래스를 가져야 한다', () => {
    const entries = [
      { turn: 1, text: 'First turn' },
      { turn: 2, text: 'Second turn' },
    ];
    render(<NarrativeFeed entries={entries} streamingText="" />);

    // 타이핑 완료를 위해 시간 진행
    act(() => {
      vi.advanceTimersByTime(10000);
    });

    const entry1 = screen.getByText('First turn').closest('.narrative-entry');
    const entry2 = screen.getByText('Second turn').closest('.narrative-entry');

    expect(entry1?.className).toContain('past-entry');
    expect(entry1?.className).not.toContain('narrative-active-text');

    expect(entry2?.className).toContain('narrative-active-text');
    expect(entry2?.className).not.toContain('past-entry');
  });

  it('스트리밍 중일 때 모든 기존 엔트리는 past-entry 클래스를 가져야 한다', () => {
    const entries = [
      { turn: 1, text: 'First turn' },
      { turn: 2, text: 'Second turn' },
    ];
    const streamingText = 'Current streaming...';
    render(<NarrativeFeed entries={entries} streamingText={streamingText} />);

    // 타이핑 진행을 위해 시간 진행
    act(() => {
      vi.advanceTimersByTime(1000);
    });

    const entry1 = screen.getByText('First turn').closest('.narrative-entry');
    const entry2 = screen.getByText('Second turn').closest('.narrative-entry');

    // 스트리밍 중이므로 마지막 엔트리(Second turn)도 past-entry여야 함
    expect(entry1?.className).toContain('past-entry');
    expect(entry2?.className).toContain('past-entry');

    // 스트리밍 텍스트 영역 확인
    const activeArea = screen.getByText(/Current/).closest('.narrative-entry');
    expect(activeArea?.className).toContain('narrative-active-text');
  });

  it('타이핑 중일 때 마지막 엔트리는 숨겨지고 활성 영역에 표시되어야 한다', () => {
    const entries = [
      { turn: 1, text: 'First turn' },
      { turn: 2, text: 'Second turn' },
    ];
    render(<NarrativeFeed entries={entries} streamingText="" />);

    // 타이핑 진행을 위해 시간 진행
    act(() => {
      vi.advanceTimersByTime(1000);
    });

    // 타이핑 시작 직후 (Second turn이 entries에서 숨겨지고 typewriter로 표시됨)
    const entry1 = screen.getByText('First turn').closest('.narrative-entry');
    expect(entry1?.className).toContain('past-entry');

    // entries의 Second turn은 숨겨져야 함 (shouldHideLastEntry=true)
    // screen.getByText('Second turn')은 typewriter 결과물을 찾을 것임
    const activeText = screen.getByText(/Sec/);
    const activeArea = activeText.closest('.narrative-entry');
    expect(activeArea?.className).toContain('narrative-active-text');

    // entries 내부의 Second turn은 렌더링되지 않으므로, past-entry 클래스를 가진 Second turn은 없어야 함
    const allPastEntries = document.querySelectorAll('.past-entry');
    expect(allPastEntries.length).toBe(1);
    expect(allPastEntries[0].textContent).toContain('First turn');
  });
});
</file>

<file path="frontend/src/components/ObjectiveTracker.test.tsx">
import { describe, it, expect, beforeEach, vi } from 'vitest';
import { render, screen } from '@testing-library/react';
import { ObjectiveTracker } from './ObjectiveTracker';
import { useWorldStore } from '../stores/worldStore';

// i18next 모킹
vi.mock('react-i18next', () => ({
  useTranslation: () => ({
    t: (key: string) => key,
  }),
  initReactI18next: {
    type: '3rdParty',
    init: () => {},
  },
}));

describe('ObjectiveTracker (U-078)', () => {
  beforeEach(() => {
    useWorldStore.getState().reset();
  });

  it('목표가 없을 때 아무것도 렌더링하지 않아야 한다', () => {
    const { container } = render(<ObjectiveTracker />);
    expect(container.firstChild).toBeNull();
  });

  it('주 목표만 있을 때 올바르게 표시해야 한다', () => {
    useWorldStore.setState({
      quests: [
        {
          id: 'main',
          label: '주 목표',
          is_completed: false,
          description: null,
          is_main: true,
          progress: 30,
          reward_signal: 0,
        },
      ],
    });

    render(<ObjectiveTracker />);
    expect(screen.getByText('주 목표')).toBeInTheDocument();
    // 진행률 바 확인
    const progressBar = screen.getByRole('progressbar');
    expect(progressBar).toBeInTheDocument();
    const fill = progressBar.querySelector('.objective-tracker__bar-fill');
    expect(fill).toHaveStyle({ width: '30%' });
  });

  it('서브 목표 카운트를 표시해야 한다', () => {
    useWorldStore.setState({
      quests: [
        {
          id: 'main',
          label: '주 목표',
          is_completed: false,
          description: null,
          is_main: true,
          progress: 0,
          reward_signal: 0,
        },
        {
          id: 'sub1',
          label: '서브 1',
          is_completed: true,
          description: null,
          is_main: false,
          progress: 0,
          reward_signal: 0,
        },
        {
          id: 'sub2',
          label: '서브 2',
          is_completed: false,
          description: null,
          is_main: false,
          progress: 0,
          reward_signal: 0,
        },
      ],
    });

    render(<ObjectiveTracker />);
    expect(screen.getByText('(1/2)')).toBeInTheDocument();
  });

  it('완료된 목표일 때 체크 아이콘을 표시해야 한다', () => {
    useWorldStore.setState({
      quests: [
        {
          id: 'main',
          label: '완료된 주 목표',
          is_completed: true,
          description: null,
          is_main: true,
          progress: 100,
          reward_signal: 0,
        },
      ],
    });

    render(<ObjectiveTracker />);
    expect(screen.getByText('✅')).toBeInTheDocument();
    expect(screen.getByText('완료된 주 목표')).toBeInTheDocument();
  });
});
</file>

<file path="frontend/src/components/ObjectiveTracker.tsx">
/**
 * Unknown World - Objective Tracker (U-078 목표 시스템 강화)
 *
 * 화면 상단에 항상 보이는 미니 목표 트래커입니다.
 * 주 목표의 제목과 진행률을 간결하게 표시합니다.
 *
 * Q2 결정: Option B - 화면 상단에 미니 트래커 추가 (항상 보임)
 *
 * 설계 원칙:
 *   - RULE-002: 게임 HUD 요소로 상시 노출
 *   - RULE-006: i18n 기반 문자열
 *   - 최소 높이로 메인 콘텐츠를 침범하지 않음
 *
 * @module components/ObjectiveTracker
 */

import { useTranslation } from 'react-i18next';
import { useShallow } from 'zustand/react/shallow';
import { useWorldStore, selectMainObjective, selectSubObjectives } from '../stores/worldStore';

/**
 * ObjectiveTracker - 미니 목표 트래커
 *
 * game-center 영역 상단에 배치하여 항상 현재 목표를 확인할 수 있습니다.
 */
export function ObjectiveTracker() {
  const { t } = useTranslation();
  const mainObjective = useWorldStore(selectMainObjective);
  const subObjectives = useWorldStore(useShallow(selectSubObjectives));

  // 서브 목표 중 완료된 것의 수
  const completedCount = subObjectives.filter((q) => q.is_completed).length;
  const totalCount = subObjectives.length;

  // 목표가 전혀 없으면 표시하지 않음
  if (!mainObjective && totalCount === 0) {
    return null;
  }

  const progress = mainObjective?.progress ?? 0;
  const isComplete = mainObjective?.is_completed ?? false;

  return (
    <div
      className={`objective-tracker ${isComplete ? 'objective-tracker--completed' : ''}`}
      data-ui-importance="critical"
    >
      <div className="objective-tracker__icon" aria-hidden="true">
        {isComplete ? '✅' : '🎯'}
      </div>
      <div className="objective-tracker__content">
        <span className="objective-tracker__title">
          {mainObjective?.label ?? t('quest.tracker_no_objective')}
        </span>
        {totalCount > 0 && (
          <span className="objective-tracker__sub-count">
            ({completedCount}/{totalCount})
          </span>
        )}
      </div>
      <div
        className="objective-tracker__bar"
        role="progressbar"
        aria-valuenow={progress}
        aria-valuemin={0}
        aria-valuemax={100}
      >
        <div
          className="objective-tracker__bar-fill"
          style={{ width: `${Math.max(0, Math.min(100, progress))}%` }}
        />
      </div>
    </div>
  );
}

export default ObjectiveTracker;
</file>

<file path="frontend/src/components/QuestPanel.tsx">
/**
 * Unknown World - Quest Panel (U-013, U-078 목표 시스템 강화)
 *
 * 플레이어의 현재 목표를 **주 목표(Main Objective)** + **서브 목표** 형태로 표시합니다.
 *
 * U-078 변경사항:
 *   - 주 목표(is_main=true): 상단 강조 영역, 진행률 바, 보상 미리보기
 *   - 서브 목표(is_main=false): 체크리스트, 완료 시 취소선 + 보상 피드백
 *   - 목표 없을 때: "자유 탐색 중" 안내
 *   - 완료 시 체크 애니메이션 (Q4: Option B)
 *
 * 설계 원칙:
 *   - RULE-002: 채팅 UI가 아닌 게임 UI로 상시 노출
 *   - RULE-006: i18n 기반 문자열 관리
 *   - PRD 6.7: Quest/Objective Panel
 *
 * @module components/QuestPanel
 */

import { useTranslation } from 'react-i18next';
import { useShallow } from 'zustand/react/shallow';
import { useWorldStore, selectMainObjective, selectSubObjectives } from '../stores/worldStore';
import type { Quest } from '../schemas/turn';

// =============================================================================
// 진행률 바 하위 컴포넌트
// =============================================================================

interface ProgressBarProps {
  value: number; // 0-100
}

/** 주 목표 진행률 바 */
function ProgressBar({ value }: ProgressBarProps) {
  const clampedValue = Math.max(0, Math.min(100, value));
  return (
    <div
      className="objective-progress-bar"
      role="progressbar"
      aria-valuenow={clampedValue}
      aria-valuemin={0}
      aria-valuemax={100}
    >
      <div className="objective-progress-fill" style={{ width: `${clampedValue}%` }} />
      <span className="objective-progress-text">{clampedValue}%</span>
    </div>
  );
}

// =============================================================================
// 주 목표 하위 컴포넌트
// =============================================================================

interface MainObjectiveProps {
  quest: Quest;
}

/** 주 목표 영역 - 강조 표시 + 진행률 + 보상 */
function MainObjective({ quest }: MainObjectiveProps) {
  const { t } = useTranslation();

  return (
    <div
      className={`main-objective ${quest.is_completed ? 'main-objective--completed' : ''}`}
      data-ui-importance="critical"
    >
      <div className="main-objective__header">
        <span className="main-objective__icon" aria-hidden="true">
          🎯
        </span>
        <span className="main-objective__badge">{t('quest.main_objective')}</span>
      </div>
      <h4 className="main-objective__title">{quest.label}</h4>
      {quest.description && <p className="main-objective__desc">{quest.description}</p>}
      <ProgressBar value={quest.progress} />
      {quest.reward_signal > 0 && !quest.is_completed && (
        <div className="main-objective__reward">
          <span className="main-objective__reward-icon" aria-hidden="true">
            💰
          </span>
          <span>{t('quest.reward_preview', { signal: quest.reward_signal })}</span>
        </div>
      )}
      {quest.is_completed && (
        <div className="main-objective__complete-badge">
          <span aria-hidden="true">✅</span>
          <span>{t('quest.objective_complete')}</span>
        </div>
      )}
    </div>
  );
}

// =============================================================================
// 서브 목표 하위 컴포넌트
// =============================================================================

interface SubObjectiveItemProps {
  quest: Quest;
}

/** 개별 서브 목표 아이템 */
function SubObjectiveItem({ quest }: SubObjectiveItemProps) {
  const { t } = useTranslation();

  return (
    <li
      className={`sub-objective ${quest.is_completed ? 'sub-objective--completed' : 'sub-objective--active'}`}
      data-quest-id={quest.id}
    >
      <span
        className={`sub-objective__check ${quest.is_completed ? 'sub-objective__check--done' : ''}`}
        aria-hidden="true"
      >
        {quest.is_completed ? '✓' : '○'}
      </span>
      <span className="sub-objective__label">{quest.label}</span>
      {quest.reward_signal > 0 && !quest.is_completed && (
        <span
          className="sub-objective__reward"
          title={t('quest.reward_preview', { signal: quest.reward_signal })}
        >
          +{quest.reward_signal}⚡
        </span>
      )}
      {quest.is_completed && quest.reward_signal > 0 && (
        <span className="sub-objective__earned">
          {t('quest.reward_earned', { signal: quest.reward_signal })}
        </span>
      )}
    </li>
  );
}

// =============================================================================
// 메인 컴포넌트
// =============================================================================

/**
 * Quest Panel - U-078 목표 시스템 강화
 *
 * 주 목표(Main Objective) + 서브 목표(Sub-objectives)를 분리 표시합니다.
 * worldStore의 quests 상태를 구독하여 실시간 업데이트됩니다.
 */
export function QuestPanel() {
  const { t } = useTranslation();
  const mainObjective = useWorldStore(selectMainObjective);
  const subObjectives = useWorldStore(useShallow(selectSubObjectives));

  const activeSubObjectives = subObjectives.filter((q) => !q.is_completed);
  const completedSubObjectives = subObjectives.filter((q) => q.is_completed);

  // 주 목표도 없고 서브 목표도 없는 빈 상태
  if (!mainObjective && subObjectives.length === 0) {
    return (
      <div className="quest-panel-content quest-empty" data-ui-importance="critical">
        <div className="quest-empty-icon" aria-hidden="true">
          🧭
        </div>
        <p className="quest-empty-text">{t('quest.free_exploration')}</p>
        <p className="quest-empty-hint">{t('quest.free_exploration_desc')}</p>
      </div>
    );
  }

  return (
    <div className="quest-panel-content" data-ui-importance="critical">
      {/* 주 목표 영역 */}
      {mainObjective && <MainObjective quest={mainObjective} />}

      {/* 서브 목표: 진행 중 */}
      {activeSubObjectives.length > 0 && (
        <div className="quest-section quest-section-active">
          <h4 className="quest-section-title">{t('quest.sub_objectives')}</h4>
          <ul className="sub-objective-list" role="list" aria-label={t('quest.sub_objectives')}>
            {activeSubObjectives.map((quest) => (
              <SubObjectiveItem key={quest.id} quest={quest} />
            ))}
          </ul>
        </div>
      )}

      {/* 서브 목표: 완료됨 */}
      {completedSubObjectives.length > 0 && (
        <div className="quest-section quest-section-completed">
          <h4 className="quest-section-title">{t('quest.section.completed')}</h4>
          <ul
            className="sub-objective-list sub-objective-list--completed"
            role="list"
            aria-label={t('quest.section.completed')}
          >
            {completedSubObjectives.map((quest) => (
              <SubObjectiveItem key={quest.id} quest={quest} />
            ))}
          </ul>
        </div>
      )}
    </div>
  );
}

export default QuestPanel;
</file>

<file path="frontend/src/components/RateLimitPanel.test.tsx">
import { describe, it, expect, vi, beforeEach, afterEach } from 'vitest';
import { render, screen, fireEvent, act } from '@testing-library/react';
import { RateLimitPanel } from './RateLimitPanel';

// i18next 모킹
vi.mock('react-i18next', () => ({
  useTranslation: () => ({
    t: (key: string, options?: Record<string, unknown>) => {
      if (key === 'error.retry_countdown') return `Retry in ${options?.seconds}s`;
      if (key === 'error.retry_button') return 'Retry Now';
      return key;
    },
  }),
}));

describe('RateLimitPanel', () => {
  beforeEach(() => {
    vi.useFakeTimers();
  });

  afterEach(() => {
    vi.useRealTimers();
  });

  it('initially shows countdown and disabled retry button', () => {
    const onRetry = vi.fn();
    render(<RateLimitPanel onRetry={onRetry} />);

    // 초기 카운트다운 60초 확인 (여러 개 존재하므로 getAllByText 사용)
    const countdownElements = screen.getAllByText('Retry in 60s');
    expect(countdownElements.length).toBeGreaterThan(0);

    // 버튼 비활성화 확인
    const retryButton = screen.getByRole('button');
    expect(retryButton).toBeDisabled();
    expect(retryButton).toHaveTextContent('Retry in 60s');
  });

  it('decreases countdown over time', () => {
    render(<RateLimitPanel onRetry={() => {}} />);

    // 10초 경과
    act(() => {
      vi.advanceTimersByTime(10000);
    });
    expect(screen.getAllByText('Retry in 50s').length).toBeGreaterThan(0);

    // 30초 더 경과
    act(() => {
      vi.advanceTimersByTime(30000);
    });
    expect(screen.getAllByText('Retry in 20s').length).toBeGreaterThan(0);
  });

  it('enables retry button when countdown reaches zero', () => {
    const onRetry = vi.fn();
    render(<RateLimitPanel onRetry={onRetry} />);

    // 60초 경과
    act(() => {
      vi.advanceTimersByTime(60000);
    });

    // 버튼 텍스트가 'Retry Now'로 변경됨
    expect(screen.getByText('Retry Now')).toBeInTheDocument();

    // 버튼 활성화 확인
    const retryButton = screen.getByRole('button');
    expect(retryButton).not.toBeDisabled();
    expect(retryButton).toHaveTextContent('Retry Now');

    // 클릭 시 콜백 호출 확인
    fireEvent.click(retryButton);
    expect(onRetry).toHaveBeenCalled();
  });

  it('allows clicking retry button multiple times after activation', () => {
    const onRetry = vi.fn();
    render(<RateLimitPanel onRetry={onRetry} />);

    // 60초 경과
    act(() => {
      vi.advanceTimersByTime(60000);
    });

    const retryButton = screen.getByRole('button');
    fireEvent.click(retryButton);
    fireEvent.click(retryButton);

    expect(onRetry).toHaveBeenCalledTimes(2);
  });
});
</file>

<file path="frontend/src/components/RateLimitPanel.tsx">
/**
 * Unknown World - Rate Limit 재시도 안내 패널 (U-130).
 *
 * 429 Rate Limit 에러 시 표시되는 플로팅 패널입니다.
 * input-lock-overlay(z-index: 9990)보다 높은 z-index로 렌더링되어
 * 재시도 버튼이 항상 클릭 가능합니다.
 *
 * 설계 원칙:
 *   - RULE-002: 게임 UI (CRT 테마, 채팅 버블 금지)
 *   - RULE-006: ko/en i18n 정책 준수
 *   - RULE-008: 에이전트 상태 가시화
 *
 * @module components/RateLimitPanel
 */

import { useState, useEffect, useCallback } from 'react';
import { useTranslation } from 'react-i18next';

// =============================================================================
// 상수
// =============================================================================

/** 카운트다운 초기값 (초) - 페어링 결정: 60초 */
const COUNTDOWN_INITIAL = 60;

// =============================================================================
// Props
// =============================================================================

export interface RateLimitPanelProps {
  /** 재시도 버튼 클릭 시 호출 */
  onRetry: () => void;
}

// =============================================================================
// 컴포넌트
// =============================================================================

/**
 * Rate Limit 재시도 안내 패널.
 *
 * 60초 카운트다운과 함께 재시도 버튼을 표시합니다.
 * 카운트다운이 0이 되면 재시도 버튼이 활성화됩니다.
 */
export function RateLimitPanel({ onRetry }: RateLimitPanelProps) {
  const { t } = useTranslation();
  const [countdown, setCountdown] = useState(COUNTDOWN_INITIAL);
  const canRetry = countdown <= 0;

  // 카운트다운 타이머
  useEffect(() => {
    if (countdown <= 0) {
      return;
    }

    const timer = setInterval(() => {
      setCountdown((prev) => {
        const next = prev - 1;
        return next <= 0 ? 0 : next;
      });
    }, 1000);

    return () => clearInterval(timer);
  }, [countdown]);

  const handleRetry = useCallback(() => {
    if (!canRetry) return;
    onRetry();
  }, [canRetry, onRetry]);

  return (
    <div
      className="rate-limit-panel"
      role="alertdialog"
      aria-live="assertive"
      aria-label={t('error.rate_limited')}
    >
      {/* 경고 아이콘 */}
      <div className="rate-limit-icon" aria-hidden="true">
        ⚠
      </div>

      {/* 제목 */}
      <h3 className="rate-limit-title">{t('error.rate_limited')}</h3>

      {/* 상세 설명 */}
      <p className="rate-limit-detail">{t('error.rate_limited_detail')}</p>

      {/* 카운트다운 */}
      {!canRetry && (
        <div className="rate-limit-countdown" aria-live="polite">
          <div className="rate-limit-countdown-bar">
            <div
              className="rate-limit-countdown-fill"
              style={{
                width: `${((COUNTDOWN_INITIAL - countdown) / COUNTDOWN_INITIAL) * 100}%`,
              }}
            />
          </div>
          <span className="rate-limit-countdown-text">
            {t('error.retry_countdown', { seconds: countdown })}
          </span>
        </div>
      )}

      {/* 재시도 버튼 */}
      <button
        type="button"
        className="rate-limit-retry-btn"
        onClick={handleRetry}
        disabled={!canRetry}
        aria-label={t('error.retry_button')}
      >
        {canRetry ? t('error.retry_button') : t('error.retry_countdown', { seconds: countdown })}
      </button>
    </div>
  );
}
</file>

<file path="frontend/src/components/RuleBoard.test.tsx">
import { describe, it, expect, beforeEach, vi } from 'vitest';
import { render, screen } from '@testing-library/react';
import { RuleBoard } from './RuleBoard';
import { useWorldStore } from '../stores/worldStore';

vi.mock('react-i18next', () => ({
  useTranslation: () => ({
    t: (key: string, options?: Record<string, unknown>) => {
      if (options?.count !== undefined) return `${key} (count: ${options.count})`;
      return key;
    },
  }),
  initReactI18next: {
    type: '3rdParty',
    init: () => {},
  },
}));

describe('RuleBoard (U-013)', () => {
  beforeEach(() => {
    useWorldStore.getState().reset();
  });

  it('규칙이 없을 때 빈 상태를 표시해야 한다', () => {
    render(<RuleBoard />);
    expect(screen.getByText('rule_board.empty')).toBeInTheDocument();
  });

  it('활성 규칙 목록을 표시해야 한다', () => {
    useWorldStore.setState({
      activeRules: [
        { id: 'r1', label: '중력', description: '떨어진다' },
        { id: 'r2', label: '산소', description: '필요하다' },
      ],
    });

    render(<RuleBoard />);
    expect(screen.getByText('rule_board.active_count (count: 2)')).toBeInTheDocument();
    expect(screen.getByText('중력')).toBeInTheDocument();
    expect(screen.getByText('떨어진다')).toBeInTheDocument();
    expect(screen.getByText('산소')).toBeInTheDocument();
  });
});
</file>

<file path="frontend/src/components/SceneCanvas.hotspot.test.tsx">
import { describe, it, expect, vi, beforeEach } from 'vitest';
import { render, screen, fireEvent, act } from '@testing-library/react';
import { SceneCanvas } from './SceneCanvas';
import type { SceneObject } from '../schemas/turn';
import type { SceneCanvasState } from '../types/scene';
import { useWorldStore } from '../stores/worldStore';
import { useAgentStore } from '../stores/agentStore';

// i18next 모킹
vi.mock('react-i18next', () => ({
  useTranslation: () => ({
    t: (key: string) => key,
  }),
  initReactI18next: {
    type: '3rdParty',
    init: () => {},
  },
}));

// ResizeObserver 모킹
let resizeCallback: (entries: ResizeObserverEntry[]) => void;
class MockResizeObserver {
  constructor(callback: (entries: ResizeObserverEntry[]) => void) {
    resizeCallback = callback;
  }
  observe = vi.fn();
  unobserve = vi.fn();
  disconnect = vi.fn();
}

global.ResizeObserver = MockResizeObserver as unknown as typeof ResizeObserver;

/**
 * 리사이즈 이벤트를 수동으로 트리거합니다.
 */
function triggerResize(width: number, height: number) {
  if (resizeCallback) {
    act(() => {
      resizeCallback([
        {
          contentRect: { width, height } as DOMRectReadOnly,
          target: document.querySelector('.scene-canvas') as Element,
        } as ResizeObserverEntry,
      ]);
    });
  }
}

// getBoundingClientRect 모킹
Element.prototype.getBoundingClientRect = vi.fn(() => ({
  width: 800,
  height: 600,
  top: 0,
  left: 0,
  bottom: 600,
  right: 800,
  x: 0,
  y: 0,
  toJSON: () => {},
})) as unknown as () => DOMRect;

describe('SceneCanvas Hotspots', () => {
  const defaultState: SceneCanvasState = {
    status: 'scene',
    imageUrl: 'https://example.com/scene.png',
  };

  const mockObjects: SceneObject[] = [
    {
      id: 'obj-1',
      label: 'Object 1',
      box_2d: { ymin: 100, xmin: 100, ymax: 200, xmax: 200 },
      interaction_hint: 'Click me',
    },
    {
      id: 'obj-2',
      label: 'Object 2',
      box_2d: { ymin: 500, xmin: 500, ymax: 700, xmax: 700 },
      interaction_hint: null,
    },
  ];

  beforeEach(() => {
    vi.clearAllMocks();
    // 스토어 초기화
    useWorldStore.setState({
      sceneState: { status: 'default', message: '' },
      sceneObjects: [],
    });
    useAgentStore.setState({ isStreaming: false });
  });

  it('should render hotspots when objects are provided in worldStore and status is scene (sorted by area)', () => {
    useWorldStore.setState({
      sceneState: defaultState,
      sceneObjects: mockObjects,
    });

    render(<SceneCanvas />);

    // 핫스팟 레이어 확인
    const layer = screen.getByLabelText('scene.hotspot.layer_label');
    expect(layer).toBeInTheDocument();

    // 개별 핫스팟 확인 (role="button")
    // RU-003-S2: 면적 기반 정렬 - 큰 것이 먼저 렌더링되어 낮은 z-index를 가짐
    // Object 1: 100x100 = 10,000
    // Object 2: 200x200 = 40,000
    // 따라서 Object 2가 먼저 오고 Object 1이 나중에 옴
    const buttons = screen.getAllByRole('button');
    expect(buttons).toHaveLength(mockObjects.length);
    expect(buttons[0]).toHaveAttribute('aria-label', 'Object 2');
    expect(buttons[1]).toHaveAttribute('aria-label', 'Object 1');

    // z-index 확인 (RU-003-S2: HotspotOverlay 자체에 style로 적용됨)
    expect(buttons[0]).toHaveStyle({ zIndex: '1' });
    expect(buttons[1]).toHaveStyle({ zIndex: '2' });
  });

  it('should not render hotspots when status is loading', () => {
    useWorldStore.setState({
      sceneState: { status: 'loading' },
      sceneObjects: mockObjects,
    });

    render(<SceneCanvas />);

    const layer = screen.queryByLabelText('scene.hotspot.layer_label');
    expect(layer).not.toBeInTheDocument();
  });

  it('should call onHotspotClick when a hotspot is clicked', () => {
    const onHotspotClick = vi.fn();
    useWorldStore.setState({
      sceneState: defaultState,
      sceneObjects: mockObjects,
    });

    render(<SceneCanvas onHotspotClick={onHotspotClick} />);

    const firstHotspot = screen.getByLabelText('Object 1');
    fireEvent.click(firstHotspot);

    expect(onHotspotClick).toHaveBeenCalledWith({
      object_id: 'obj-1',
      box_2d: mockObjects[0].box_2d,
    });
  });

  it('should show tooltip on hover', async () => {
    useWorldStore.setState({
      sceneState: defaultState,
      sceneObjects: mockObjects,
    });

    render(<SceneCanvas />);

    const firstHotspot = screen.getByLabelText('Object 1');

    // Hover 시작
    fireEvent.mouseEnter(firstHotspot);

    // 툴팁 라벨 확인
    expect(screen.getByText('Object 1')).toBeInTheDocument();
    expect(screen.getByText(/scene.hotspot.hint_prefix/)).toBeInTheDocument();
    expect(screen.getByText(/Click me/)).toBeInTheDocument();

    // Hover 종료
    fireEvent.mouseLeave(firstHotspot);
    expect(screen.queryByText('Object 1')).not.toBeInTheDocument();
  });

  it('should be disabled when agentStore.isStreaming is true', () => {
    const onHotspotClick = vi.fn();
    useWorldStore.setState({
      sceneState: defaultState,
      sceneObjects: mockObjects,
    });
    useAgentStore.setState({ isStreaming: true });

    render(<SceneCanvas onHotspotClick={onHotspotClick} />);

    const firstHotspot = screen.getByLabelText('Object 1');
    expect(firstHotspot).toHaveAttribute('aria-disabled', 'true');
    expect(firstHotspot).toHaveAttribute('tabindex', '-1');

    fireEvent.click(firstHotspot);
    expect(onHotspotClick).not.toHaveBeenCalled();
  });

  it('should reposition hotspots when canvas size changes (reactive resize)', async () => {
    vi.useFakeTimers();
    useWorldStore.setState({
      sceneState: defaultState,
      sceneObjects: mockObjects,
    });

    render(<SceneCanvas />);

    // Object 1 찾기 (정렬에 의해 두 번째 버튼일 수 있음)
    const firstHotspot = screen.getByLabelText('Object 1');

    // 초기 크기 (800x600) 기반 위치 확인
    expect(firstHotspot).toHaveStyle({
      top: '60px',
      left: '80px',
      width: '80px',
      height: '60px',
    });

    // 크기 변경 트리거 (400x300)
    triggerResize(400, 300);

    // RU-003-S2: ResizeObserver 디바운스(100ms) 대기
    act(() => {
      vi.advanceTimersByTime(150);
    });

    // 변경된 크기 기반 위치 확인
    expect(firstHotspot).toHaveStyle({
      top: '30px',
      left: '40px',
      width: '40px',
      height: '30px',
    });

    vi.useRealTimers();
  });
});
</file>

<file path="frontend/src/components/SceneCanvas.rendering.test.tsx">
import { describe, it, expect, vi, beforeEach, afterEach } from 'vitest';
import { render, act } from '@testing-library/react';
import { SceneCanvas } from './SceneCanvas';
import { useWorldStore } from '../stores/worldStore';

// ResizeObserver 모킹
interface MockObserver {
  callback: ResizeObserverCallback;
  observe: ReturnType<typeof vi.fn>;
  unobserve: ReturnType<typeof vi.fn>;
  disconnect: ReturnType<typeof vi.fn>;
}

const observerInstances: MockObserver[] = [];
const MockResizeObserver = vi.fn().mockImplementation(function (
  this: MockObserver,
  callback: ResizeObserverCallback,
) {
  this.callback = callback;
  this.observe = vi.fn();
  this.unobserve = vi.fn();
  this.disconnect = vi.fn();
  observerInstances.push(this);
});

vi.stubGlobal('ResizeObserver', MockResizeObserver);

describe('SceneCanvas Rendering Stability (U-097)', () => {
  let consoleErrorSpy: ReturnType<typeof vi.spyOn>;

  beforeEach(() => {
    // console.error 감시 (React 렌더링 중 업데이트 경고는 console.error로 출력됨)
    consoleErrorSpy = vi.spyOn(console, 'error').mockImplementation(() => {});
    // Store 초기화
    useWorldStore.getState().reset();
    observerInstances.length = 0;
  });

  afterEach(() => {
    consoleErrorSpy.mockRestore();
    vi.clearAllMocks();
    vi.useRealTimers();
  });

  it('should not throw "Cannot update a component while rendering" warning', async () => {
    // Given: SceneCanvas 렌더링
    render(<SceneCanvas />);

    // Then: 렌더링 직후 console.error에 React 경고가 없어야 함
    const hasWarning = consoleErrorSpy.mock.calls.some(
      (call: unknown[]) =>
        typeof call[0] === 'string' && call[0].includes('Cannot update a component'),
    );

    expect(hasWarning).toBe(false);
  });

  it('should update Zustand store via useEffect, not during render', async () => {
    vi.useFakeTimers();

    // getBoundingClientRect 모킹 (초기 크기 설정용)
    const getBoundingClientRectSpy = vi
      .spyOn(HTMLElement.prototype, 'getBoundingClientRect')
      .mockReturnValue({
        width: 1024,
        height: 768,
        top: 0,
        left: 0,
        bottom: 768,
        right: 1024,
        x: 0,
        y: 0,
        toJSON: () => {},
      } as DOMRect);

    // Store의 setSceneCanvasSize를 스파이
    const setSceneCanvasSizeSpy = vi.spyOn(useWorldStore.getState(), 'setSceneCanvasSize');

    // SceneCanvas 렌더링
    render(<SceneCanvas />);

    // useEffect가 실행되도록 대기
    await act(async () => {
      vi.runAllTimers();
    });

    // setSceneCanvasSize가 호출되었는지 확인
    expect(setSceneCanvasSizeSpy).toHaveBeenCalled();

    // ResizeObserver 트리거 시뮬레이션
    const observerInstance = observerInstances[0];
    const mockEntry = {
      contentRect: { width: 800, height: 600 },
    } as unknown as ResizeObserverEntry;

    await act(async () => {
      observerInstance.callback([mockEntry], observerInstance as unknown as ResizeObserver);
    });

    // 100ms 디바운스 대기
    await act(async () => {
      vi.advanceTimersByTime(150);
    });

    // Store 업데이트 확인
    expect(useWorldStore.getState().sceneCanvasSize).toEqual({ width: 800, height: 600 });

    // 이 과정에서 렌더링 중 업데이트 경고가 발생하지 않았는지 최종 확인
    const hasWarning = consoleErrorSpy.mock.calls.some(
      (call: unknown[]) =>
        typeof call[0] === 'string' && call[0].includes('Cannot update a component'),
    );
    expect(hasWarning).toBe(false);

    getBoundingClientRectSpy.mockRestore();
  });
});
</file>

<file path="frontend/src/data/itemIconPresets.ts">
/**
 * Unknown World - 아이템 아이콘 프리셋 레지스트리 (U-092[Mvp]).
 *
 * nanobanana mcp로 사전 제작된 아이템 아이콘의 매핑 테이블입니다.
 * 초기 데모 프로필 아이템 + 자주 등장하는 공통 아이템을 포함합니다.
 *
 * 설계 원칙:
 *   - RULE-007: nanobanana mcp는 개발/에셋 제작용으로만 사용 (정적 배포)
 *   - Q2 결정: icon_url이 있으면 항상 프리셋 우선 (동적 생성 건너뛰기)
 *   - 에셋 SSOT: frontend/public/ui/items/ 경로, kebab-case, 64x64 PNG
 *
 * @module data/itemIconPresets
 */

// =============================================================================
// 프리셋 아이콘 경로 상수
// =============================================================================

/** 아이템 아이콘 에셋 기본 경로 (public 디렉토리 기준) */
const ITEMS_BASE = '/ui/items';

// =============================================================================
// 프리셋 레지스트리
// =============================================================================

/**
 * 아이템 ID → 프리셋 아이콘 URL 매핑.
 *
 * 키: 아이템 ID (kebab-case, demoProfiles 및 GM 출력에서 사용하는 ID)
 * 값: 정적 에셋 URL 경로 (/ui/items/xxx-64.png)
 *
 * 게임 도중 GM이 생성하는 아이템의 ID가 이 맵에 존재하면
 * 동적 생성을 건너뛰고 프리셋 아이콘을 즉시 사용합니다.
 */
export const ITEM_ICON_PRESETS: Readonly<Record<string, string>> = {
  // ─── 초기 아이템: Narrator 프로필 ───
  'ancient-tome': `${ITEMS_BASE}/ancient-tome-64.png`,
  'quill-pen': `${ITEMS_BASE}/quill-pen-64.png`,
  'memory-fragment': `${ITEMS_BASE}/memory-fragment-64.png`,

  // ─── 초기 아이템: Explorer 프로필 ───
  compass: `${ITEMS_BASE}/compass-64.png`,
  rope: `${ITEMS_BASE}/rope-64.png`,
  lantern: `${ITEMS_BASE}/lantern-64.png`,
  'map-fragment': `${ITEMS_BASE}/map-fragment-64.png`,

  // ─── 초기 아이템: Tech Enthusiast 프로필 ───
  'data-core': `${ITEMS_BASE}/data-core-64.png`,
  'circuit-board': `${ITEMS_BASE}/circuit-board-64.png`,
  'energy-cell': `${ITEMS_BASE}/energy-cell-64.png`,
  'scanner-device': `${ITEMS_BASE}/scanner-device-64.png`,

  // ─── 공통 아이템 (게임 중 자주 등장) ───
  sword: `${ITEMS_BASE}/sword-64.png`,
  shield: `${ITEMS_BASE}/shield-64.png`,
  potion: `${ITEMS_BASE}/potion-64.png`,
  key: `${ITEMS_BASE}/key-64.png`,
  gem: `${ITEMS_BASE}/gem-64.png`,
  scroll: `${ITEMS_BASE}/scroll-64.png`,
  torch: `${ITEMS_BASE}/torch-64.png`,
  herb: `${ITEMS_BASE}/herb-64.png`,
  coin: `${ITEMS_BASE}/coin-64.png`,
  ring: `${ITEMS_BASE}/ring-64.png`,
  amulet: `${ITEMS_BASE}/amulet-64.png`,
  dagger: `${ITEMS_BASE}/dagger-64.png`,
  flask: `${ITEMS_BASE}/flask-64.png`,
  crystal: `${ITEMS_BASE}/crystal-64.png`,
  lockpick: `${ITEMS_BASE}/lockpick-64.png`,
} as const;

// =============================================================================
// 유틸리티 함수
// =============================================================================

/**
 * 아이템 ID로 프리셋 아이콘 URL을 조회합니다.
 *
 * @param itemId - 아이템 ID (kebab-case)
 * @returns 프리셋 아이콘 URL 또는 undefined (프리셋 없음)
 */
export function getPresetIconUrl(itemId: string): string | undefined {
  // 정확한 ID 매칭
  if (itemId in ITEM_ICON_PRESETS) {
    return ITEM_ICON_PRESETS[itemId];
  }

  // 부분 매칭: 아이템 ID에 프리셋 키가 포함된 경우 (예: "rusty-sword" → "sword")
  for (const [key, url] of Object.entries(ITEM_ICON_PRESETS)) {
    if (itemId.includes(key)) {
      return url;
    }
  }

  return undefined;
}

/**
 * 아이템 ID에 프리셋 아이콘이 존재하는지 확인합니다.
 *
 * @param itemId - 아이템 ID
 * @returns 프리셋 존재 여부
 */
export function hasPresetIcon(itemId: string): boolean {
  return getPresetIconUrl(itemId) !== undefined;
}
</file>

<file path="frontend/src/demo/demoFixtures.ts">
/**
 * Unknown World - 데모용 Fixtures (RU-003-Q5)
 *
 * DEV 환경에서 사용하는 데모 초기 데이터입니다.
 * 언어 중립적인 값(ID/아이콘/수량/좌표)만 포함하며,
 * 표시 문자열(name/label/hint)은 i18n 키를 통해 렌더링합니다.
 *
 * 설계 원칙:
 *   - RULE-006: ko/en 혼합 출력 금지 (i18n 키 기반)
 *   - PRD 6.9: 데모 프로필 경계 확보
 *   - 서버 TurnOutput 대체 시 이 모듈 비활성화 가능
 *
 * @module demo/demoFixtures
 */

import type { Box2D } from '../schemas/turn';

// =============================================================================
// 타입 정의
// =============================================================================

/**
 * 데모 인벤토리 아이템 정의 (언어 중립)
 *
 * name은 i18n 키(`demo.items.{id}.name`)로 렌더링합니다.
 */
export interface DemoInventoryItemDef {
  /** 아이템 고유 ID */
  id: string;
  /** 아이템 아이콘 (이모지 또는 URL) */
  icon: string;
  /** 초기 수량 */
  quantity: number;
}

/**
 * 데모 씬 오브젝트 정의 (언어 중립)
 *
 * label/hint는 i18n 키로 렌더링합니다:
 * - labelKey: `demo.scene.{id}.label`
 * - hintKey: `demo.scene.{id}.hint`
 */
export interface DemoSceneObjectDef {
  /** 오브젝트 고유 ID */
  id: string;
  /** 바운딩 박스 (0~1000 정규화) */
  box_2d: Box2D;
  /** i18n 라벨 키 */
  labelKey: string;
  /** i18n 힌트 키 */
  hintKey: string;
}

// =============================================================================
// 데모 인벤토리 아이템
// =============================================================================

/**
 * 데모용 인벤토리 아이템 목록.
 *
 * @remarks
 * - ID/아이콘/수량만 정의 (언어 중립)
 * - 표시 이름은 `demo.items.{id}.name` 키로 i18n 처리
 */
export const DEMO_INVENTORY_ITEMS: readonly DemoInventoryItemDef[] = [
  { id: 'keycard-alpha', icon: '🔑', quantity: 1 },
  { id: 'medkit', icon: '🩹', quantity: 2 },
  { id: 'flashlight', icon: '🔦', quantity: 1 },
  { id: 'data-chip', icon: '💾', quantity: 3 },
] as const;

// =============================================================================
// 데모 씬 오브젝트
// =============================================================================

/**
 * 데모용 씬 오브젝트 목록.
 *
 * @remarks
 * - ID/좌표만 정의 (언어 중립)
 * - 표시 라벨/힌트는 i18n 키로 처리
 */
export const DEMO_SCENE_OBJECTS: readonly DemoSceneObjectDef[] = [
  {
    id: 'demo-terminal',
    box_2d: { ymin: 300, xmin: 100, ymax: 600, xmax: 400 },
    labelKey: 'demo.scene.terminal.label',
    hintKey: 'demo.scene.terminal.hint',
  },
  {
    id: 'demo-door',
    box_2d: { ymin: 200, xmin: 600, ymax: 800, xmax: 900 },
    labelKey: 'demo.scene.door.label',
    hintKey: 'demo.scene.door.hint',
  },
] as const;

// =============================================================================
// 데모 퀘스트 (U-013)
// =============================================================================

/**
 * 데모 퀘스트 정의 (언어 중립)
 *
 * label은 i18n 키(`demo.quest.{id}.label`)로 렌더링합니다.
 */
export interface DemoQuestDef {
  /** 퀘스트 고유 ID */
  id: string;
  /** i18n 라벨 키 */
  labelKey: string;
  /** 완료 여부 */
  is_completed: boolean;
  /** i18n 설명 키 (선택, U-078) */
  descriptionKey?: string;
  /** 주 목표 여부 (U-078) */
  is_main?: boolean;
  /** 진행률 0~100 (U-078) */
  progress?: number;
  /** Signal 보상량 (U-078) */
  reward_signal?: number;
}

/**
 * 데모용 퀘스트 목록 (U-078: 목표 시스템 강화).
 */
export const DEMO_QUESTS: readonly DemoQuestDef[] = [
  {
    id: 'demo-quest-terminal',
    labelKey: 'demo.quest.terminal.label',
    descriptionKey: 'demo.quest.terminal.description',
    is_completed: false,
    is_main: true,
    progress: 30,
    reward_signal: 50,
  },
  {
    id: 'demo-quest-escape',
    labelKey: 'demo.quest.escape.label',
    is_completed: false,
    is_main: false,
    progress: 0,
    reward_signal: 20,
  },
  {
    id: 'demo-quest-collect',
    labelKey: 'demo.quest.collect.label',
    is_completed: true,
    is_main: false,
    progress: 100,
    reward_signal: 10,
  },
] as const;

// =============================================================================
// 데모 규칙 (U-013)
// =============================================================================

/**
 * 데모 규칙 정의 (언어 중립)
 *
 * label/description은 i18n 키로 렌더링합니다.
 */
export interface DemoRuleDef {
  /** 규칙 고유 ID */
  id: string;
  /** i18n 라벨 키 */
  labelKey: string;
  /** i18n 설명 키 (선택) */
  descriptionKey?: string;
}

/**
 * 데모용 규칙 목록.
 */
export const DEMO_RULES: readonly DemoRuleDef[] = [
  {
    id: 'demo-rule-gravity',
    labelKey: 'demo.rule.gravity.label',
    descriptionKey: 'demo.rule.gravity.description',
  },
  {
    id: 'demo-rule-time',
    labelKey: 'demo.rule.time.label',
    descriptionKey: 'demo.rule.time.description',
  },
] as const;

// =============================================================================
// 헬퍼 함수
// =============================================================================

/**
 * 데모 인벤토리 아이템의 i18n 이름 키를 생성합니다.
 *
 * @param itemId - 아이템 ID
 * @returns i18n 키 (예: `demo.items.keycard-alpha.name`)
 */
export function getDemoItemNameKey(itemId: string): string {
  return `demo.items.${itemId}.name`;
}

/**
 * 데모 환경인지 확인합니다 (DEV 가드).
 *
 * @returns DEV 환경 여부
 */
export function isDemoEnvironment(): boolean {
  return import.meta.env.DEV;
}

/**
 * DOM에서 현재 테마를 읽습니다.
 *
 * RU-003-Q5: 'dark' 하드코딩 제거
 * - data-theme 속성을 확인하여 테마 결정
 * - 'crt', 'dark' 또는 미지정 → 'dark'
 * - 'light' → 'light'
 *
 * @returns 현재 테마 ('dark' | 'light')
 */
export function getCurrentThemeFromDOM(): 'dark' | 'light' {
  const dataTheme = document.documentElement.getAttribute('data-theme');

  // 'crt' 테마는 dark 계열로 취급
  if (dataTheme === 'light') {
    return 'light';
  }
  return 'dark';
}
</file>

<file path="frontend/src/i18n.ts">
/**
 * Unknown World - i18n 초기화 모듈
 *
 * 언어 리소스를 JSON 파일 구조로 관리합니다.
 * RULE-006 준수: ko/en 혼합 출력 금지, i18n 키 기반 SSOT
 *
 * 언어 코드: BCP-47 형식 (ko-KR, en-US)
 * - TurnInput/SaveGame의 language 필드와 동일한 축
 *
 * @see vibe/prd.md 3.1(지원 언어), 8.7(TurnInput.language)
 * @see frontend/src/locales/README.md
 */

import i18n from 'i18next';
import { initReactI18next } from 'react-i18next';

// JSON 언어 리소스 import (SSOT: locales/{lang}/translation.json)
import koKR from './locales/ko-KR/translation.json';
import enUS from './locales/en-US/translation.json';

/** 지원 언어 타입 (TurnInput.language와 동기화) */
export type SupportedLanguage = 'ko-KR' | 'en-US';

/** 기본 언어 (Devpost 제출 요건 대응을 위해 en-US 기본) */
export const DEFAULT_LANGUAGE: SupportedLanguage = 'en-US';

/** 폴백 언어 */
export const FALLBACK_LANGUAGE: SupportedLanguage = 'en-US';

/** 지원 언어 목록 */
export const SUPPORTED_LANGUAGES: SupportedLanguage[] = ['ko-KR', 'en-US'];

/**
 * 초기 언어를 결정합니다.
 * LocalStorage에 이전 설정이 있으면 우선 사용하고, 없으면 DEFAULT_LANGUAGE를 반환합니다.
 *
 * 주의: sessionLifecycle.ts의 getInitialSessionLanguage()와 동일한 로직이지만,
 * i18n 모듈 초기화 시점에 순환 참조를 방지하기 위해 인라인으로 구현합니다.
 * 키: 'unknown_world_language' (save/constants.ts의 LANGUAGE_STORAGE_KEY와 동일)
 */
function resolveInitialLanguage(): SupportedLanguage {
  try {
    const stored = localStorage.getItem('unknown_world_language');
    if (stored === 'ko-KR' || stored === 'en-US') {
      return stored;
    }
  } catch {
    // localStorage 접근 불가 환경 (SSR, 시크릿 모드 등)
  }
  return DEFAULT_LANGUAGE;
}

// i18n 리소스 정의 (BCP-47 형식 언어 코드)
const resources = {
  'ko-KR': {
    translation: koKR,
  },
  'en-US': {
    translation: enUS,
  },
};

i18n.use(initReactI18next).init({
  resources,
  lng: resolveInitialLanguage(),
  fallbackLng: FALLBACK_LANGUAGE,
  supportedLngs: SUPPORTED_LANGUAGES,
  interpolation: {
    escapeValue: false, // React에서 이미 XSS 방지
  },
  // 누락 키 처리 (개발 모드에서 경고)
  saveMissing: false,
  missingKeyHandler: (_lngs, _ns, key) => {
    if (import.meta.env.DEV) {
      console.warn(`[i18n] Missing translation key: "${key}"`);
    }
  },
});

/**
 * 현재 해결된 언어 코드를 반환합니다.
 * TurnInput.language와 동기화할 때 사용합니다.
 */
export function getResolvedLanguage(): SupportedLanguage {
  return (i18n.resolvedLanguage as SupportedLanguage) || DEFAULT_LANGUAGE;
}

/**
 * 언어를 변경합니다.
 * 향후 U-036 완료 후 사용자에게 노출할 토글에서 사용합니다.
 */
export async function changeLanguage(lang: SupportedLanguage): Promise<void> {
  await i18n.changeLanguage(lang);
}

export default i18n;
</file>

<file path="frontend/src/schemas/turn.economy.test.ts">
import { describe, it, expect } from 'vitest';
import { safeParseTurnOutput } from './turn';

describe('U-063: Economy Balance Preservation in safeParseTurnOutput', () => {
  it('should preserve economy balance in fallback when validation fails', () => {
    const invalidData = { some: 'invalid data' };
    const economySnapshot = { signal: 42, memory_shard: 7 };

    const result = safeParseTurnOutput(invalidData, 'ko-KR', 0, economySnapshot);

    expect(result.success).toBe(false);
    if (!result.success) {
      expect(result.fallback.economy.balance_after.signal).toBe(42);
      expect(result.fallback.economy.balance_after.memory_shard).toBe(7);
      expect(result.fallback.economy.cost.signal).toBe(0);
      expect(result.fallback.economy.cost.memory_shard).toBe(0);
    }
  });

  it('should use default values if economySnapshot is not provided', () => {
    const invalidData = { some: 'invalid data' };

    const result = safeParseTurnOutput(invalidData, 'ko-KR', 0);

    expect(result.success).toBe(false);
    if (!result.success) {
      // 기본값 { signal: 100, memory_shard: 5 } 확인 (turn.ts에 정의됨)
      expect(result.fallback.economy.balance_after.signal).toBe(100);
      expect(result.fallback.economy.balance_after.memory_shard).toBe(5);
    }
  });
});
</file>

<file path="frontend/src/stores/actionDeckStore.test.ts">
import { describe, it, expect, beforeEach } from 'vitest';
import { useActionDeckStore, filterAffordableCards } from './actionDeckStore';
import type { ActionCard } from '../schemas/turn';

describe('actionDeckStore', () => {
  beforeEach(() => {
    useActionDeckStore.getState().reset();
  });

  // U-065: 단순화된 ActionCard 스키마 (제거됨: description, cost_estimate, hint, reward_hint, disabled_reason)
  const mockCards: ActionCard[] = [
    {
      id: 'card-1',
      label: 'Card 1',
      cost: { signal: 10, memory_shard: 0 },
      risk: 'low',
      enabled: true,
      is_alternative: false,
    },
    {
      id: 'card-2',
      label: 'Card 2',
      cost: { signal: 50, memory_shard: 1 },
      risk: 'high',
      enabled: true,
      is_alternative: false,
    },
  ];

  it('sets cards and resets selected card', () => {
    const store = useActionDeckStore.getState();
    store.selectCard('some-id');
    expect(useActionDeckStore.getState().selectedCardId).toBe('some-id');

    store.setCards(mockCards);
    expect(useActionDeckStore.getState().cards).toEqual(mockCards);
    expect(useActionDeckStore.getState().selectedCardId).toBeNull();
  });

  it('marks a card as executed', () => {
    const store = useActionDeckStore.getState();
    store.selectCard('card-1');
    store.markExecuted('card-1');

    expect(useActionDeckStore.getState().lastExecutedCardId).toBe('card-1');
    expect(useActionDeckStore.getState().selectedCardId).toBeNull();
  });

  it('filters affordable cards correctly', () => {
    const balance = { signal: 20, memory_shard: 0 };
    const affordable = filterAffordableCards(mockCards, balance);

    expect(affordable).toHaveLength(1);
    expect(affordable[0].id).toBe('card-1');
  });

  it('respects server enabled flag in filterAffordableCards', () => {
    const disabledCards: ActionCard[] = [
      {
        ...mockCards[0],
        enabled: false,
      },
    ];
    const balance = { signal: 100, memory_shard: 100 };
    const affordable = filterAffordableCards(disabledCards, balance);

    expect(affordable).toHaveLength(0);
  });
});
</file>

<file path="frontend/src/stores/actionDeckStore.ts">
/**
 * Unknown World - Action Deck 상태 관리 (Zustand) (U-009[Mvp]).
 *
 * Action Deck의 카드 목록, 선택 상태, 잔액 기반 필터링을 관리합니다.
 *
 * 설계 원칙:
 *   - RULE-005: 잔액 부족 시 실행 불가 표시 + 대안 제공
 *   - RULE-008: 카드 클릭 → TurnInput 연결
 *
 * @module stores/actionDeckStore
 */

import { create } from 'zustand';
import type { ActionCard } from '../schemas/turn';

// =============================================================================
// 상태 타입 정의
// =============================================================================

/** Action Deck 상태 */
export interface ActionDeckState {
  /** 현재 카드 목록 (서버에서 받은 원본) */
  cards: ActionCard[];
  /** 선택된 카드 ID (클릭 후 실행 전까지) */
  selectedCardId: string | null;
  /** 마지막으로 실행된 카드 ID */
  lastExecutedCardId: string | null;
}

/** Action Deck 액션 */
export interface ActionDeckActions {
  /** 카드 목록 설정 (TurnOutput 수신 시) */
  setCards: (cards: ActionCard[]) => void;
  /** 카드 선택 */
  selectCard: (cardId: string | null) => void;
  /** 카드 실행 완료 기록 */
  markExecuted: (cardId: string) => void;
  /** 상태 초기화 */
  reset: () => void;
}

export type ActionDeckStore = ActionDeckState & ActionDeckActions;

// =============================================================================
// 초기 상태
// =============================================================================

function createInitialState(): ActionDeckState {
  return {
    cards: [],
    selectedCardId: null,
    lastExecutedCardId: null,
  };
}

// =============================================================================
// Zustand Store
// =============================================================================

/**
 * Action Deck 상태 스토어.
 *
 * @example
 * ```tsx
 * const { cards, setCards, selectCard } = useActionDeckStore();
 *
 * // TurnOutput 수신 시
 * setCards(turnOutput.ui.action_deck.cards);
 *
 * // 카드 클릭 시
 * selectCard(card.id);
 * ```
 */
export const useActionDeckStore = create<ActionDeckStore>((set) => ({
  // 초기 상태
  ...createInitialState(),

  // 액션
  setCards: (cards) => {
    set({
      cards,
      selectedCardId: null, // 새 카드 목록 수신 시 선택 초기화
    });
  },

  selectCard: (cardId) => {
    set({ selectedCardId: cardId });
  },

  markExecuted: (cardId) => {
    set({
      lastExecutedCardId: cardId,
      selectedCardId: null,
    });
  },

  reset: () => {
    set(createInitialState());
  },
}));

// =============================================================================
// 셀렉터 (성능 최적화용)
// =============================================================================

/** 카드 목록 셀렉터 */
export const selectCards = (state: ActionDeckStore) => state.cards;

/** 선택된 카드 ID 셀렉터 */
export const selectSelectedCardId = (state: ActionDeckStore) => state.selectedCardId;

/** 선택된 카드 객체 셀렉터 */
export const selectSelectedCard = (state: ActionDeckStore) =>
  state.cards.find((c) => c.id === state.selectedCardId) ?? null;

/** 마지막 실행 카드 ID 셀렉터 */
export const selectLastExecutedCardId = (state: ActionDeckStore) => state.lastExecutedCardId;

// =============================================================================
// 유틸리티 함수
// =============================================================================

/**
 * 잔액 기반으로 실행 가능한 카드만 필터링합니다.
 * (컴포넌트에서 사용하거나, 서버 응답이 enabled를 제공하지 않을 때 폴백으로 사용)
 *
 * U-065: cost_estimate 필드 제거됨, cost만 사용
 *
 * @param cards - 원본 카드 목록
 * @param balance - 현재 잔액
 * @returns 실행 가능한 카드 목록
 */
export function filterAffordableCards(
  cards: ActionCard[],
  balance: { signal: number; memory_shard: number },
): ActionCard[] {
  return cards.filter((card) => {
    // 서버에서 이미 enabled=false로 판단했으면 제외
    if (!card.enabled) return false;

    // U-065: cost_estimate 제거됨, cost만 사용
    const cost = card.cost;
    return balance.signal >= cost.signal && balance.memory_shard >= cost.memory_shard;
  });
}

/**
 * 대안 카드(is_alternative=true)만 필터링합니다.
 *
 * @param cards - 원본 카드 목록
 * @returns 대안 카드 목록
 */
export function filterAlternativeCards(cards: ActionCard[]): ActionCard[] {
  return cards.filter((card) => card.is_alternative);
}

/**
 * 일반 카드(is_alternative=false)만 필터링합니다.
 *
 * @param cards - 원본 카드 목록
 * @returns 일반 카드 목록
 */
export function filterRegularCards(cards: ActionCard[]): ActionCard[] {
  return cards.filter((card) => !card.is_alternative);
}
</file>

<file path="frontend/src/stores/economyStore.test.ts">
import { describe, it, expect, beforeEach } from 'vitest';
import {
  useEconomyStore,
  LEDGER_MAX_ENTRIES,
  canAffordCost,
  canAffordEstimate,
} from './economyStore';
import type { CurrencyAmount, CostEstimate } from '../schemas/turn';

describe('economyStore', () => {
  beforeEach(() => {
    useEconomyStore.getState().reset();
    useEconomyStore.getState().clearLedger();
  });

  it('초기 상태가 올바르게 설정되어야 한다', () => {
    const state = useEconomyStore.getState();
    expect(state.ledger).toEqual([]);
    expect(state.costEstimate).toBeNull();
    expect(state.lastCost).toBeNull();
    expect(state.isBalanceLow).toBe(false);
    expect(state.lowBalanceThreshold).toBe(10);
  });

  it('addLedgerEntry가 엔트리를 추가하고 lastCost를 업데이트해야 한다', () => {
    const entry = {
      turnId: 1,
      reason: 'explore',
      cost: { signal: 5, memory_shard: 0 },
      balanceAfter: { signal: 95, memory_shard: 10 },
      modelLabel: 'FAST' as const,
    };

    useEconomyStore.getState().addLedgerEntry(entry);

    const state = useEconomyStore.getState();
    expect(state.ledger.length).toBe(1);
    expect(state.ledger[0].turnId).toBe(1);
    expect(state.ledger[0].timestamp).toBeDefined();
    expect(state.lastCost).toEqual({
      cost: entry.cost,
      balanceAfter: entry.balanceAfter,
      turnId: entry.turnId,
      modelLabel: entry.modelLabel,
    });
  });

  it(`Ledger는 최대 ${LEDGER_MAX_ENTRIES}개까지만 보관해야 한다`, () => {
    const store = useEconomyStore.getState();

    // 25개 엔트리 추가
    for (let i = 1; i <= 25; i++) {
      store.addLedgerEntry({
        turnId: i,
        reason: `test-${i}`,
        cost: { signal: 1, memory_shard: 0 },
        balanceAfter: { signal: 100 - i, memory_shard: 0 },
      });
    }

    const state = useEconomyStore.getState();
    expect(state.ledger.length).toBe(LEDGER_MAX_ENTRIES);
    // 최신순(내림차순) 정렬 확인
    expect(state.ledger[0].turnId).toBe(25);
    expect(state.ledger[LEDGER_MAX_ENTRIES - 1].turnId).toBe(25 - LEDGER_MAX_ENTRIES + 1);
  });

  it('setCostEstimateFromCard가 예상 비용을 올바르게 설정해야 한다', () => {
    const cost: CurrencyAmount = { signal: 5, memory_shard: 0 };
    const estimate: CostEstimate = {
      min: { signal: 3, memory_shard: 0 },
      max: { signal: 7, memory_shard: 0 },
    };

    // 1. cost_estimate가 제공된 경우
    useEconomyStore.getState().setCostEstimateFromCard(cost, estimate, 'action-1', 'Test Label');
    let state = useEconomyStore.getState();
    expect(state.costEstimate).toEqual({
      min: estimate.min,
      max: estimate.max,
      actionId: 'action-1',
      label: 'Test Label',
    });

    // 2. cost_estimate가 null인 경우 (기본 cost 사용)
    useEconomyStore.getState().setCostEstimateFromCard(cost, null, 'action-2');
    state = useEconomyStore.getState();
    expect(state.costEstimate).toEqual({
      min: cost,
      max: cost,
      actionId: 'action-2',
      label: undefined,
    });
  });

  it('updateBalanceLowStatus가 임계값에 따라 상태를 업데이트해야 한다', () => {
    const store = useEconomyStore.getState();

    // 기본 임계값 10
    store.updateBalanceLowStatus({ signal: 15, memory_shard: 0 });
    expect(useEconomyStore.getState().isBalanceLow).toBe(false);

    store.updateBalanceLowStatus({ signal: 5, memory_shard: 0 });
    expect(useEconomyStore.getState().isBalanceLow).toBe(true);

    // 임계값 변경 테스트
    store.setLowBalanceThreshold(20);
    store.updateBalanceLowStatus({ signal: 15, memory_shard: 0 });
    expect(useEconomyStore.getState().isBalanceLow).toBe(true);
  });

  describe('Utility: canAffordCost & canAffordEstimate', () => {
    const balance: CurrencyAmount = { signal: 10, memory_shard: 2 };

    it('canAffordCost: 잔액이 충분할 때', () => {
      const cost: CurrencyAmount = { signal: 5, memory_shard: 1 };
      const result = canAffordCost(balance, cost);
      expect(result.affordable).toBe(true);
      expect(result.shortfall).toEqual({ signal: 0, memory_shard: 0 });
    });

    it('canAffordCost: 잔액이 부족할 때 (Signal)', () => {
      const cost: CurrencyAmount = { signal: 15, memory_shard: 1 };
      const result = canAffordCost(balance, cost);
      expect(result.affordable).toBe(false);
      expect(result.shortfall.signal).toBe(5);
    });

    it('canAffordCost: 잔액이 부족할 때 (Shard)', () => {
      const cost: CurrencyAmount = { signal: 5, memory_shard: 5 };
      const result = canAffordCost(balance, cost);
      expect(result.affordable).toBe(false);
      expect(result.shortfall.memory_shard).toBe(3);
    });

    it('canAffordEstimate: 최대 예상 비용 기준으로 체크해야 한다', () => {
      const estimate = {
        min: { signal: 5, memory_shard: 0 },
        max: { signal: 15, memory_shard: 0 },
      };
      // Signal 10 < Max 15 이므로 감당 불가
      const result = canAffordEstimate(balance, estimate);
      expect(result.affordable).toBe(false);
      expect(result.shortfall.signal).toBe(5);
    });
  });
});
</file>

<file path="frontend/src/stores/uiPrefsStore.ts">
/**
 * Unknown World - UI 설정 상태 관리 (Zustand + persist) (U-116[Mvp]).
 *
 * UI 스케일 설정을 LocalStorage에 영속화합니다.
 * U-116: SaveGame 시스템 제거에 따라 독립적인 persist 스토어로 유지됩니다.
 *
 * 설계 원칙:
 *   - PRD 9.4: 가독성(필수) - 전역 UI 스케일 조절 제공
 *   - U-037: Readable 모드 제거 → critical/ambient 중요도 기반 스타일로 대체
 *   - U-116: SaveGame 통합 로직 제거
 *
 * @module stores/uiPrefsStore
 */

import { create } from 'zustand';
import { persist, createJSONStorage } from 'zustand/middleware';

// =============================================================================
// 상수 정의
// =============================================================================

/** 지원하는 UI 스케일 값 */
export const UI_SCALES = [0.9, 1.0, 1.1, 1.2] as const;
export type UIScale = (typeof UI_SCALES)[number];

/** 기본 UI 스케일 */
export const DEFAULT_UI_SCALE: UIScale = 1.0;

/** localStorage 키 */
export const UI_PREFS_STORAGE_KEY = 'unknown-world-ui-prefs';

// =============================================================================
// 상태 타입 정의
// =============================================================================

/** UI 설정 상태 */
export interface UIPrefsState {
  /**
   * UI 스케일 (0.9 ~ 1.2)
   * - 0.9: 작은 UI (정보 밀도 높음)
   * - 1.0: 기본
   * - 1.1: 약간 확대
   * - 1.2: 큰 UI (가독성 우선)
   */
  uiScale: UIScale;
}

/** UI 설정 액션 */
export interface UIPrefsActions {
  /** UI 스케일 설정 */
  setUIScale: (scale: UIScale) => void;

  /** UI 스케일 증가 (최대 1.2) */
  increaseUIScale: () => void;

  /** UI 스케일 감소 (최소 0.9) */
  decreaseUIScale: () => void;

  /** 설정 초기화 */
  resetPrefs: () => void;
}

export type UIPrefsStore = UIPrefsState & UIPrefsActions;

// =============================================================================
// 초기 상태
// =============================================================================

/** 초기 상태 생성 */
function createInitialState(): UIPrefsState {
  return {
    uiScale: DEFAULT_UI_SCALE,
  };
}

// =============================================================================
// 유틸리티 함수
// =============================================================================

/**
 * 주어진 스케일이 유효한지 확인
 */
function isValidScale(scale: number): scale is UIScale {
  return UI_SCALES.includes(scale as UIScale);
}

/**
 * 스케일 인덱스 반환
 */
function getScaleIndex(scale: UIScale): number {
  return UI_SCALES.indexOf(scale);
}

/**
 * U-037: legacy 저장값(readableMode) 마이그레이션/무시
 * @internal exported for testing
 */
export function migrateUIPrefs(persistedState: unknown, version: number | undefined): UIPrefsState {
  // version 0 또는 undefined에서 version 1로 마이그레이션
  // readableMode 필드가 있으면 제거
  if (version === 0 || version === undefined) {
    const state = persistedState as Record<string, unknown>;
    // readableMode 필드 제거 (무시)
    if ('readableMode' in state) {
      const { readableMode: _, ...rest } = state;
      return { ...rest, uiScale: state.uiScale ?? DEFAULT_UI_SCALE } as UIPrefsState;
    }
    return { ...state, uiScale: state.uiScale ?? DEFAULT_UI_SCALE } as UIPrefsState;
  }
  return persistedState as UIPrefsState;
}

// =============================================================================
// Zustand Store with persist
// =============================================================================

/**
 * UI 설정 스토어.
 *
 * U-037: Readable 모드 제거됨. CRT 효과는 critical/ambient 중요도 기반으로 자동 적용됩니다.
 *
 * @example
 * ```tsx
 * // 컴포넌트에서 사용
 * const { uiScale, setUIScale } = useUIPrefsStore();
 *
 * // DOM 적용 (App.tsx에서)
 * useEffect(() => {
 *   document.documentElement.dataset.uiScale = uiScale.toString();
 *   document.documentElement.style.setProperty('--ui-scale-factor', uiScale.toString());
 * }, [uiScale]);
 * ```
 */
export const useUIPrefsStore = create<UIPrefsStore>()(
  persist(
    (set, get) => ({
      // 초기 상태
      ...createInitialState(),

      // 액션
      setUIScale: (scale) => {
        if (isValidScale(scale)) {
          set({ uiScale: scale });
        }
      },

      increaseUIScale: () => {
        const currentIndex = getScaleIndex(get().uiScale);
        const nextIndex = Math.min(currentIndex + 1, UI_SCALES.length - 1);
        set({ uiScale: UI_SCALES[nextIndex] });
      },

      decreaseUIScale: () => {
        const currentIndex = getScaleIndex(get().uiScale);
        const prevIndex = Math.max(currentIndex - 1, 0);
        set({ uiScale: UI_SCALES[prevIndex] });
      },

      resetPrefs: () => {
        set(createInitialState());
      },
    }),
    {
      name: UI_PREFS_STORAGE_KEY,
      storage: createJSONStorage(() => localStorage),
      // 직렬화할 필드 지정 (액션 제외)
      partialize: (state) => ({
        uiScale: state.uiScale,
      }),
      // U-037: legacy 저장값(readableMode) 마이그레이션/무시
      version: 1,
      migrate: migrateUIPrefs,
    },
  ),
);

// =============================================================================
// 셀렉터 (성능 최적화용)
// =============================================================================

/** UI 스케일 셀렉터 */
export const selectUIScale = (state: UIPrefsStore) => state.uiScale;

// =============================================================================
// DOM 적용 헬퍼
// =============================================================================

/**
 * CSS 변수로 UI 스케일 적용
 * 호출 시 html 요소에 --ui-scale-factor 변수를 설정
 */
export function applyUIScaleToDOM(scale: UIScale): void {
  document.documentElement.style.setProperty('--ui-scale-factor', scale.toString());
  document.documentElement.dataset.uiScale = scale.toString();
}

/**
 * 전체 UI 설정 DOM 적용
 * U-037: readableMode 제거됨 - 스케일만 적용
 */
export function applyUIPrefsToDOM(state: UIPrefsState): void {
  applyUIScaleToDOM(state.uiScale);
}
</file>

<file path="frontend/src/stores/worldStore.u066.test.ts">
import { describe, it, expect, beforeEach } from 'vitest';
import { useWorldStore } from './worldStore';

describe('worldStore (U-066: Late-binding Image)', () => {
  beforeEach(() => {
    useWorldStore.getState().reset();
  });

  it('setImageLoading이 올바른 상태를 설정해야 한다', () => {
    const turnId = 5;
    useWorldStore.getState().setImageLoading(turnId);

    const state = useWorldStore.getState();
    expect(state.sceneState.imageLoading).toBe(true);
    expect(state.sceneState.pendingImageTurnId).toBe(turnId);
    expect(state.sceneState.sceneRevision).toBe(turnId);
  });

  it('applyLateBindingImage가 일치하는 turnId에 대해 이미지를 적용해야 한다', () => {
    const turnId = 5;
    const imageUrl = 'https://example.com/image.png';

    // 1. 로딩 시작
    useWorldStore.getState().setImageLoading(turnId);

    // 2. 이미지 적용
    const applied = useWorldStore.getState().applyLateBindingImage(imageUrl, turnId);

    expect(applied).toBe(true);
    const state = useWorldStore.getState();
    expect(state.sceneState.status).toBe('scene');
    expect(state.sceneState.imageUrl).toBe(imageUrl);
    expect(state.sceneState.imageLoading).toBe(false);
    expect(state.sceneState.pendingImageTurnId).toBeUndefined();
  });

  it('applyLateBindingImage가 일치하지 않는 turnId에 대해 이미지를 무시해야 한다', () => {
    const oldTurnId = 5;
    const newTurnId = 6;
    const oldImageUrl = 'https://example.com/old.png';

    // 1. 이전 턴 로딩 시작
    useWorldStore.getState().setImageLoading(oldTurnId);

    // 2. 새 턴 시작 (로딩 상태 덮어씀)
    useWorldStore.getState().setImageLoading(newTurnId);

    // 3. 이전 턴의 이미지가 도착함
    const applied = useWorldStore.getState().applyLateBindingImage(oldImageUrl, oldTurnId);

    expect(applied).toBe(false);
    const state = useWorldStore.getState();
    expect(state.sceneState.pendingImageTurnId).toBe(newTurnId); // 여전히 새 턴 대기 중
    expect(state.sceneState.imageUrl).not.toBe(oldImageUrl);
  });

  it('cancelImageLoading이 로딩 상태를 해제하고 이전 이미지를 유지해야 한다', () => {
    const turnId = 5;
    const initialImageUrl = 'https://example.com/initial.png';

    // 초기 이미지 설정
    useWorldStore.setState({
      sceneState: { status: 'scene', imageUrl: initialImageUrl },
    });

    // 로딩 시작
    useWorldStore.getState().setImageLoading(turnId);
    expect(useWorldStore.getState().sceneState.imageLoading).toBe(true);
    expect(useWorldStore.getState().sceneState.previousImageUrl).toBe(initialImageUrl);

    // 로딩 취소
    useWorldStore.getState().cancelImageLoading();

    const state = useWorldStore.getState();
    expect(state.sceneState.imageLoading).toBe(false);
    expect(state.sceneState.imageUrl).toBe(initialImageUrl);
    expect(state.sceneState.previousImageUrl).toBeUndefined();
  });
});
</file>

<file path="frontend/src/styles/interaction-hint.css">
/**
 * Unknown World - 인터랙션 힌트 스타일
 *
 * U-074[Mvp]: 핫스팟/아이템 인터랙션 안내 UX
 * - 힌트 툴팁 스타일 (클릭/드래그 힌트)
 * - CRT 테마 일관성 유지
 *
 * @see vibe/ref/frontend-style-guide.md
 */

/* ============================================
   1. 인터랙션 힌트 기본 스타일
   ============================================ */

.interaction-hint {
  position: absolute;
  z-index: 30;
  pointer-events: none;
  animation: hint-fade-in 0.2s ease-out;
}

@keyframes hint-fade-in {
  from {
    opacity: 0;
    transform: translateY(4px);
  }
  to {
    opacity: 1;
    transform: translateY(0);
  }
}

/* ============================================
   2. 힌트 내용 컨테이너
   ============================================ */

.interaction-hint-content {
  display: inline-flex;
  align-items: center;
  gap: var(--spacing-xs);
  padding: var(--spacing-xs) var(--spacing-sm);
  background-color: rgba(0, 255, 128, 0.12);
  border: 1px solid var(--accent-color);
  border-radius: 3px;
  box-shadow:
    0 0 8px rgba(0, 255, 128, 0.3),
    0 2px 8px rgba(0, 0, 0, 0.6);
  white-space: nowrap;
}

/* ============================================
   3. 힌트 텍스트
   ============================================ */

.interaction-hint-text {
  font-size: var(--font-size-xs);
  font-weight: 600;
  color: var(--accent-color);
  text-transform: uppercase;
  letter-spacing: 0.5px;
  text-shadow: 0 0 4px rgba(0, 255, 128, 0.4);
}

/* ============================================
   4. 힌트 아이콘
   ============================================ */

.interaction-hint-icon {
  width: 14px;
  height: 14px;
  color: var(--accent-color);
  flex-shrink: 0;
  filter: drop-shadow(0 0 2px rgba(0, 255, 128, 0.4));
}

/* ============================================
   5. 위치 변형 (top/bottom/left/right)
   ============================================ */

/* 상단 (기본) */
.interaction-hint--top {
  bottom: calc(100% + 8px);
  left: 50%;
  transform: translateX(-50%);
}

.interaction-hint--top .interaction-hint-content::after {
  content: '';
  position: absolute;
  top: 100%;
  left: 50%;
  transform: translateX(-50%);
  border: 5px solid transparent;
  border-top-color: var(--accent-color);
}

/* 하단 */
.interaction-hint--bottom {
  top: calc(100% + 8px);
  left: 50%;
  transform: translateX(-50%);
}

.interaction-hint--bottom .interaction-hint-content::after {
  content: '';
  position: absolute;
  bottom: 100%;
  left: 50%;
  transform: translateX(-50%);
  border: 5px solid transparent;
  border-bottom-color: var(--accent-color);
}

/* 좌측 */
.interaction-hint--left {
  top: 50%;
  right: calc(100% + 8px);
  transform: translateY(-50%);
}

.interaction-hint--left .interaction-hint-content::after {
  content: '';
  position: absolute;
  left: 100%;
  top: 50%;
  transform: translateY(-50%);
  border: 5px solid transparent;
  border-left-color: var(--accent-color);
}

/* 우측 */
.interaction-hint--right {
  top: 50%;
  left: calc(100% + 8px);
  transform: translateY(-50%);
}

.interaction-hint--right .interaction-hint-content::after {
  content: '';
  position: absolute;
  right: 100%;
  top: 50%;
  transform: translateY(-50%);
  border: 5px solid transparent;
  border-right-color: var(--accent-color);
}

/* ============================================
   6. 핫스팟용 힌트 (마젠타 테마)
   ============================================ */

.interaction-hint--hotspot .interaction-hint-content {
  background-color: rgba(224, 64, 251, 0.15);
  border-color: var(--hotspot-primary);
  box-shadow:
    0 0 8px var(--hotspot-glow),
    0 2px 8px rgba(0, 0, 0, 0.6);
}

.interaction-hint--hotspot .interaction-hint-text {
  color: var(--hotspot-primary);
  text-shadow: 0 0 4px rgba(224, 64, 251, 0.4);
}

.interaction-hint--hotspot .interaction-hint-icon {
  color: var(--hotspot-primary);
  filter: drop-shadow(0 0 2px rgba(224, 64, 251, 0.4));
}

.interaction-hint--hotspot.interaction-hint--top .interaction-hint-content::after {
  border-top-color: var(--hotspot-primary);
}

.interaction-hint--hotspot.interaction-hint--bottom .interaction-hint-content::after {
  border-bottom-color: var(--hotspot-primary);
}

/* ============================================
   7. 인벤토리용 힌트 (기본 그린 테마)
   ============================================ */

.interaction-hint--inventory .interaction-hint-content {
  background-color: rgba(0, 255, 128, 0.12);
  border-color: var(--accent-color);
}

/* ============================================
   8. 반응형 조정
   ============================================ */

@media (max-width: 768px) {
  .interaction-hint-content {
    padding: 4px 8px;
  }

  .interaction-hint-text {
    font-size: 10px;
  }

  .interaction-hint-icon {
    width: 12px;
    height: 12px;
  }
}

/* ============================================
   9. 접근성: reduced-motion
   ============================================ */

@media (prefers-reduced-motion: reduce) {
  .interaction-hint {
    animation: none;
  }
}

/* ============================================
   10. 고대비 모드
   ============================================ */

@media (prefers-contrast: more) {
  .interaction-hint-content {
    border-width: 2px;
    background-color: rgba(0, 0, 0, 0.9);
  }
}
</file>

<file path="frontend/src/utils/imageSizing.test.ts">
import { describe, it, expect } from 'vitest';
import { selectImageSizing, getDefaultImageSizing } from './imageSizing';

describe('imageSizing utils', () => {
  describe('selectImageSizing', () => {
    it('should select 16:9 for landscape aspect ratio', () => {
      const result = selectImageSizing(1920, 1080);
      expect(result.aspectRatio).toBe('16:9');
      expect(result.imageSize).toBe('1K');
    });

    it('should select 1:1 for square aspect ratio', () => {
      const result = selectImageSizing(1000, 1000);
      expect(result.aspectRatio).toBe('1:1');
    });

    it('should select 9:16 for portrait aspect ratio', () => {
      const result = selectImageSizing(1080, 1920);
      expect(result.aspectRatio).toBe('9:16');
    });

    it('should select 21:9 for ultra-wide aspect ratio', () => {
      const result = selectImageSizing(2560, 1080);
      expect(result.aspectRatio).toBe('21:9');
    });

    it('should select 2:3 for vertical aspect ratio', () => {
      const result = selectImageSizing(600, 900);
      expect(result.aspectRatio).toBe('2:3');
    });

    it('should select 4:3 for traditional monitor aspect ratio', () => {
      const result = selectImageSizing(1024, 768);
      expect(result.aspectRatio).toBe('4:3');
    });

    it('should select closest ratio for slightly off dimensions', () => {
      // 800/450 = 1.777... (16:9)
      // 810/450 = 1.8
      const result = selectImageSizing(810, 450);
      expect(result.aspectRatio).toBe('16:9');
    });

    it('should fallback to default for invalid dimensions', () => {
      const defaultSizing = getDefaultImageSizing();

      expect(selectImageSizing(0, 100)).toEqual(defaultSizing);
      expect(selectImageSizing(100, 0)).toEqual(defaultSizing);
      expect(selectImageSizing(40, 40)).toEqual(defaultSizing); // MIN_VALID_DIMENSION is 50
      expect(selectImageSizing(NaN, 100)).toEqual(defaultSizing);
    });

    it('should generate correct label', () => {
      const result = selectImageSizing(1920, 1080);
      expect(result.label).toBe('IMAGE 16:9@1K');
    });
  });

  describe('getDefaultImageSizing', () => {
    it('should return 16:9 and 1K as default', () => {
      const result = getDefaultImageSizing();
      expect(result.aspectRatio).toBe('16:9');
      expect(result.imageSize).toBe('1K');
    });
  });
});
</file>

<file path="frontend/src/utils/imageSizing.ts">
/**
 * Unknown World - Scene Canvas 크기 → (aspect_ratio, image_size) 선택 유틸
 *
 * U-085[Mvp]: 이미지 크기를 현재 UI 레이아웃(Scene Canvas)에 최대한 맞춤으로 생성
 *
 * 설계 원칙:
 *   - RULE-009: 좌표 규약(0~1000) 무관 (비율만 제어)
 *   - RULE-010: 지원 비율/크기는 SDK SSOT에 고정
 *   - 페어링 Q1: UI 레이아웃 우선 (image_job.aspect_ratio보다 우선)
 *   - 페어링 Q2: image_size는 SDK 값 (1K/2K/4K) 사용
 *
 * 참조:
 *   - vibe/ref/image-generate-guide.md: "1:1","2:3","3:2","3:4","4:3","4:5","5:4","9:16","16:9","21:9"
 *   - image_size: "1K" | "2K" | "4K" (대문자 K 필수)
 *
 * @module utils/imageSizing
 */

// =============================================================================
// 타입 정의
// =============================================================================

/** SDK가 지원하는 aspect_ratio 문자열 */
export type SupportedAspectRatio =
  | '1:1'
  | '2:3'
  | '3:2'
  | '3:4'
  | '4:3'
  | '4:5'
  | '5:4'
  | '9:16'
  | '16:9'
  | '21:9';

/** SDK가 지원하는 image_size 값 */
export type SupportedImageSize = '1K' | '2K' | '4K';

/** 이미지 사이징 결과 */
export interface ImageSizingResult {
  /** 선택된 가로세로 비율 */
  aspectRatio: SupportedAspectRatio;
  /** 선택된 이미지 크기 (SDK 값) */
  imageSize: SupportedImageSize;
  /** 디버그/로그용 라벨 (예: "IMAGE 16:9@1K") */
  label: string;
}

// =============================================================================
// 상수 정의
// =============================================================================

/**
 * 지원하는 aspect_ratio 후보와 실수 비율값 매핑.
 * SDK 공식 지원 비율: "1:1","2:3","3:2","3:4","4:3","4:5","5:4","9:16","16:9","21:9"
 *
 * 게임 UI에서는 가로 레이아웃이 일반적이므로 16:9를 우선 후보로 배치.
 */
const ASPECT_RATIO_MAP: ReadonlyArray<{
  ratio: SupportedAspectRatio;
  value: number;
}> = [
  { ratio: '21:9', value: 21 / 9 }, // 2.333
  { ratio: '16:9', value: 16 / 9 }, // 1.778
  { ratio: '3:2', value: 3 / 2 }, // 1.500
  { ratio: '4:3', value: 4 / 3 }, // 1.333
  { ratio: '5:4', value: 5 / 4 }, // 1.250
  { ratio: '1:1', value: 1 / 1 }, // 1.000
  { ratio: '4:5', value: 4 / 5 }, // 0.800
  { ratio: '3:4', value: 3 / 4 }, // 0.750
  { ratio: '2:3', value: 2 / 3 }, // 0.667
  { ratio: '9:16', value: 9 / 16 }, // 0.563
];

/**
 * 기본 이미지 사이징 결과.
 * 측정 실패/비정상 값 시 안전한 폴백.
 */
const DEFAULT_SIZING: ImageSizingResult = {
  aspectRatio: '16:9',
  imageSize: '1K',
  label: 'IMAGE 16:9@1K',
};

/**
 * 유효한 Scene Canvas 크기 최소값 (px).
 * 이보다 작으면 측정 실패로 간주하고 기본값 사용.
 */
const MIN_VALID_DIMENSION = 50;

// =============================================================================
// 핵심 함수
// =============================================================================

/**
 * Scene Canvas 표시 크기(px)를 기반으로 최적의 aspect_ratio와 image_size를 선택합니다.
 *
 * - 지원 후보 중 "가장 가까운 비율"을 선택합니다.
 * - image_size는 MVP에서 '1K'로 고정합니다 (비용 효율, 데모 체감 충분).
 * - 측정 실패(0 또는 비정상 값) 시 기본값(16:9 + 1K)으로 폴백합니다.
 *
 * @param width - Scene Canvas 너비 (px)
 * @param height - Scene Canvas 높이 (px)
 * @returns 선택된 aspect_ratio, image_size, 로그 라벨
 *
 * @example
 * ```ts
 * const result = selectImageSizing(800, 450);
 * // { aspectRatio: '16:9', imageSize: '1K', label: 'IMAGE 16:9@1K' }
 *
 * const result2 = selectImageSizing(600, 800);
 * // { aspectRatio: '3:4', imageSize: '1K', label: 'IMAGE 3:4@1K' }
 * ```
 */
export function selectImageSizing(width: number, height: number): ImageSizingResult {
  // 유효성 검사: 비정상 값이면 기본값 폴백
  if (
    !Number.isFinite(width) ||
    !Number.isFinite(height) ||
    width < MIN_VALID_DIMENSION ||
    height < MIN_VALID_DIMENSION
  ) {
    return DEFAULT_SIZING;
  }

  // 목표 비율 계산
  const targetRatio = width / height;

  // 가장 가까운 비율 찾기 (절대 차이 최소화)
  let bestMatch = ASPECT_RATIO_MAP[0];
  let bestDiff = Math.abs(targetRatio - bestMatch.value);

  for (let i = 1; i < ASPECT_RATIO_MAP.length; i++) {
    const diff = Math.abs(targetRatio - ASPECT_RATIO_MAP[i].value);
    if (diff < bestDiff) {
      bestDiff = diff;
      bestMatch = ASPECT_RATIO_MAP[i];
    }
  }

  // MVP에서는 1K 고정 (비용 효율 + 데모 체감 충분)
  // MMP에서 해상도 자동 선택 도입 가능
  const imageSize: SupportedImageSize = '1K';

  return {
    aspectRatio: bestMatch.ratio,
    imageSize,
    label: `IMAGE ${bestMatch.ratio}@${imageSize}`,
  };
}

/**
 * 기본 이미지 사이징 결과를 반환합니다.
 * Scene Canvas 크기를 아직 측정하지 못한 경우 사용합니다.
 */
export function getDefaultImageSizing(): ImageSizingResult {
  return { ...DEFAULT_SIZING };
}
</file>

<file path="request.json">
{
  "language": "ko-KR",
  "text": "모험을 시작한다",
  "client": { "viewport_w": 1920, "viewport_h": 1080, "theme": "dark" },
  "economy_snapshot": { "signal": 5, "memory_shard": 0 }
}
</file>

<file path="scripts/process_item_icons.py">
"""
U-092[Mvp]: 아이템 아이콘 일괄 후처리 스크립트.
nanobanana-mcp로 생성된 원본 이미지에 rembg 배경 제거 + ImageMagick 리사이즈를 적용합니다.

Usage:
    python scripts/process_item_icons.py
"""

import subprocess
import sys
from pathlib import Path

# 소스 → 타겟 파일명 매핑
ICON_MAP = {
    # === 초기 아이템 (11개) ===
    "a_minimal_ancient_leatherbound_t.png": "ancient-tome-64.png",
    "a_minimal_feather_quill_pen_icon.png": "quill-pen-64.png",
    "a_minimal_glowing_crystal_memory.png": "memory-fragment-64.png",
    "a_minimal_compass_navigation_too.png": "compass-64.png",
    "a_minimal_coiled_rope_icon_pixel.png": "rope-64.png",
    "a_minimal_glowing_lantern_icon_p.png": "lantern-64.png",
    "a_minimal_torn_map_fragment_piec.png": "map-fragment-64.png",
    "a_minimal_glowing_data_core_sphe.png": "data-core-64.png",
    "a_minimal_green_circuit_board_ic.png": "circuit-board-64.png",
    "a_minimal_energy_cell_battery_ic.png": "energy-cell-64.png",
    "a_minimal_scanner_device_icon_pi.png": "scanner-device-64.png",
    # === 공통 아이템 (15개) ===
    "a_minimal_medieval_sword_icon_pi.png": "sword-64.png",
    "a_minimal_round_shield_icon_pixe.png": "shield-64.png",
    "a_minimal_red_healing_potion_bot.png": "potion-64.png",
    "a_minimal_ornate_golden_key_icon.png": "key-64.png",
    "a_minimal_sparkling_gemstone_ico.png": "gem-64.png",
    "a_minimal_magic_scroll_icon_pixe.png": "scroll-64.png",
    "a_minimal_burning_torch_icon_pix.png": "torch-64.png",
    "a_minimal_green_herb_bundle_icon.png": "herb-64.png",
    "a_minimal_gold_coin_icon_pixel_a.png": "coin-64.png",
    "a_minimal_magic_ring_icon_pixel_.png": "ring-64.png",
    "a_minimal_glowing_amulet_pendant.png": "amulet-64.png",
    "a_minimal_dagger_icon_pixel_art_.png": "dagger-64.png",
    "a_minimal_alchemy_flask_icon_pix.png": "flask-64.png",
    "a_minimal_glowing_crystal_icon_p.png": "crystal-64.png",
    "a_minimal_lockpick_tool_icon_pix.png": "lockpick-64.png",
}

SRC_DIR = Path.home() / "nanobanana-output"
DST_DIR = Path("d:/Dev/unknown-world/frontend/public/ui/items")
TMP_DIR = Path("d:/Dev/unknown-world/frontend/public/ui/items/_tmp")


def run(cmd: list[str], label: str) -> bool:
    """명령어를 실행하고 결과를 반환합니다."""
    print(f"  [{label}] {' '.join(cmd[:3])}...")
    result = subprocess.run(cmd, capture_output=True, text=True)
    if result.returncode != 0:
        print(f"  ❌ 실패: {result.stderr[:200]}")
        return False
    return True


def main() -> None:
    import sys
    import io
    sys.stdout = io.TextIOWrapper(sys.stdout.buffer, encoding='utf-8', errors='replace')

    DST_DIR.mkdir(parents=True, exist_ok=True)
    TMP_DIR.mkdir(parents=True, exist_ok=True)

    success = 0
    fail = 0

    for src_name, dst_name in ICON_MAP.items():
        src_path = SRC_DIR / src_name
        if not src_path.exists():
            print(f"[WARN] source not found: {src_name}")
            fail += 1
            continue

        print(f"\n[PROCESS] {src_name} -> {dst_name}")

        # Step 1: rembg background removal
        tmp_nobg = TMP_DIR / f"nobg_{dst_name}"
        ok = run(
            ["rembg", "i", "-m", "birefnet-general", str(src_path), str(tmp_nobg)],
            "rembg",
        )
        if not ok:
            print("  [WARN] rembg failed, using original")
            tmp_nobg = src_path

        # Step 2: ImageMagick trim + resize 64x64
        dst_path = DST_DIR / dst_name
        ok = run(
            [
                "magick",
                str(tmp_nobg),
                "-trim",
                "+repage",
                "-resize", "64x64",
                "-gravity", "center",
                "-background", "transparent",
                "-extent", "64x64",
                str(dst_path),
            ],
            "magick",
        )
        if ok:
            size_kb = dst_path.stat().st_size / 1024
            print(f"  [OK] {dst_name} ({size_kb:.1f}KB)")
            success += 1
        else:
            fail += 1

    # cleanup temp dir
    import shutil
    if TMP_DIR.exists():
        shutil.rmtree(TMP_DIR)

    print(f"\n{'='*50}")
    print(f"[DONE] success={success} fail={fail} total={len(ICON_MAP)}")


if __name__ == "__main__":
    main()
</file>

<file path="shared/schemas/turn/turn_input.schema.json">
{
  "$schema": "http://json-schema.org/draft-07/schema#",
  "$id": "https://unknown-world.dev/schemas/turn/turn_input.schema.json",
  "title": "TurnInput",
  "description": "Client → Server 턴 요청 스키마 (MVP). PRD 8.7절 기반.",
  "type": "object",
  "properties": {
    "language": {
      "type": "string",
      "enum": ["ko-KR", "en-US"],
      "description": "게임 언어 설정 (ko-KR 또는 en-US)"
    },
    "text": {
      "type": "string",
      "description": "사용자 입력 (자연어)"
    },
    "click": {
      "type": ["object", "null"],
      "description": "클릭된 오브젝트 정보 (선택)",
      "properties": {
        "object_id": {
          "type": "string",
          "description": "클릭된 오브젝트 ID"
        },
        "box_2d": {
          "type": ["array", "null"],
          "description": "bbox [ymin, xmin, ymax, xmax] (0~1000 정규화)",
          "items": {
            "type": "integer",
            "minimum": 0,
            "maximum": 1000
          },
          "minItems": 4,
          "maxItems": 4
        }
      },
      "required": ["object_id"]
    },
    "client": {
      "type": "object",
      "description": "클라이언트 환경 정보",
      "properties": {
        "viewport_w": {
          "type": "integer",
          "description": "뷰포트 너비 (px)"
        },
        "viewport_h": {
          "type": "integer",
          "description": "뷰포트 높이 (px)"
        },
        "theme": {
          "type": "string",
          "enum": ["dark", "light"],
          "description": "테마 설정"
        }
      },
      "required": ["viewport_w", "viewport_h", "theme"]
    },
    "economy_snapshot": {
      "type": "object",
      "description": "현재 재화 상태 스냅샷",
      "properties": {
        "signal": {
          "type": "integer",
          "minimum": 0,
          "description": "Signal 재화 잔액"
        },
        "memory_shard": {
          "type": "integer",
          "minimum": 0,
          "description": "Memory Shard 재화 잔액"
        }
      },
      "required": ["signal", "memory_shard"]
    }
  },
  "required": ["language", "text", "client", "economy_snapshot"],
  "additionalProperties": false
}
</file>

<file path="shared/schemas/turn/turn_output.schema.json">
{
  "$defs": {
    "ActionCard": {
      "additionalProperties": false,
      "description": "액션 카드 (Action Deck).\n\n매 턴 AI가 추천하는 행동 카드입니다.\n각 카드에 비용/위험/보상 힌트가 포함됩니다.\n\nAttributes:\n    id: 카드 고유 ID\n    label: 카드 라벨 (표시용)\n    description: 카드 설명 (선택)\n    cost: 예상 비용\n    risk: 위험도\n    hint: 예상 결과 힌트 (선택)",
      "properties": {
        "id": {
          "description": "카드 고유 ID",
          "title": "Id",
          "type": "string"
        },
        "label": {
          "description": "카드 라벨 (표시용)",
          "title": "Label",
          "type": "string"
        },
        "description": {
          "anyOf": [
            {
              "type": "string"
            },
            {
              "type": "null"
            }
          ],
          "default": null,
          "description": "카드 설명 (선택)",
          "title": "Description"
        },
        "cost": {
          "$ref": "#/$defs/CurrencyAmount",
          "description": "예상 비용"
        },
        "risk": {
          "$ref": "#/$defs/RiskLevel",
          "default": "low",
          "description": "위험도"
        },
        "hint": {
          "anyOf": [
            {
              "type": "string"
            },
            {
              "type": "null"
            }
          ],
          "default": null,
          "description": "예상 결과 힌트 (선택)",
          "title": "Hint"
        }
      },
      "required": ["id", "label", "cost"],
      "title": "ActionCard",
      "type": "object"
    },
    "ActionDeck": {
      "additionalProperties": false,
      "description": "액션 덱 (Q1 결정: ui.action_deck.cards[] 구조).\n\n매 턴 AI가 제시하는 추천 행동 카드 덱입니다.\n\nAttributes:\n    cards: 액션 카드 목록 (3~6장 권장)",
      "properties": {
        "cards": {
          "default": [],
          "description": "액션 카드 목록 (3~6장 권장)",
          "items": {
            "$ref": "#/$defs/ActionCard"
          },
          "maxItems": 10,
          "minItems": 0,
          "title": "Cards",
          "type": "array"
        }
      },
      "title": "ActionDeck",
      "type": "object"
    },
    "AgentConsole": {
      "additionalProperties": false,
      "description": "에이전트 콘솔 데이터 (RULE-008).\n\n에이전트형 시스템임을 UI로 증명하기 위한 정보입니다.\n계획/실행/검증/복구의 흔적을 표시합니다.\n\nAttributes:\n    current_phase: 현재 실행 단계\n    badges: 검증 배지 목록\n    repair_count: 자동 복구 시도 횟수",
      "properties": {
        "current_phase": {
          "$ref": "#/$defs/AgentPhase",
          "default": "commit",
          "description": "현재 실행 단계"
        },
        "badges": {
          "default": [],
          "description": "검증 배지 목록",
          "items": {
            "$ref": "#/$defs/ValidationBadge"
          },
          "title": "Badges",
          "type": "array"
        },
        "repair_count": {
          "default": 0,
          "description": "자동 복구 시도 횟수",
          "minimum": 0,
          "title": "Repair Count",
          "type": "integer"
        }
      },
      "title": "AgentConsole",
      "type": "object"
    },
    "AgentPhase": {
      "description": "에이전트 실행 단계 (RULE-008).\n\n에이전트형 시스템임을 UI로 증명하기 위한 단계 표시.",
      "enum": ["parse", "validate", "plan", "resolve", "render", "verify", "commit"],
      "title": "AgentPhase",
      "type": "string"
    },
    "Box2D": {
      "additionalProperties": false,
      "description": "2D 바운딩 박스 (RULE-009).\n\n좌표는 0~1000 정규화 좌표계이며, bbox는 [ymin, xmin, ymax, xmax] 순서입니다.\n이미지 이해 bbox 포맷과 호환됩니다.\n\nAttributes:\n    ymin: Y 최소값 (상단)\n    xmin: X 최소값 (좌측)\n    ymax: Y 최대값 (하단)\n    xmax: X 최대값 (우측)",
      "properties": {
        "ymin": {
          "description": "정규화 좌표 (0~1000)",
          "maximum": 1000,
          "minimum": 0,
          "title": "Ymin",
          "type": "integer"
        },
        "xmin": {
          "description": "정규화 좌표 (0~1000)",
          "maximum": 1000,
          "minimum": 0,
          "title": "Xmin",
          "type": "integer"
        },
        "ymax": {
          "description": "정규화 좌표 (0~1000)",
          "maximum": 1000,
          "minimum": 0,
          "title": "Ymax",
          "type": "integer"
        },
        "xmax": {
          "description": "정규화 좌표 (0~1000)",
          "maximum": 1000,
          "minimum": 0,
          "title": "Xmax",
          "type": "integer"
        }
      },
      "required": ["ymin", "xmin", "ymax", "xmax"],
      "title": "Box2D",
      "type": "object"
    },
    "CurrencyAmount": {
      "additionalProperties": false,
      "description": "재화 수량.\n\nAttributes:\n    signal: 기본 재화 (텍스트 턴/이미지 생성/고급 기능에 소비)\n    memory_shard: 희귀 재화 (중요 설정 고정, 고해상도 이미지 등에 소비)",
      "properties": {
        "signal": {
          "description": "시그널 (기본 재화, 0 이상)",
          "minimum": 0,
          "title": "Signal",
          "type": "integer"
        },
        "memory_shard": {
          "description": "기억 파편 (희귀 재화, 0 이상)",
          "minimum": 0,
          "title": "Memory Shard",
          "type": "integer"
        }
      },
      "required": ["signal", "memory_shard"],
      "title": "CurrencyAmount",
      "type": "object"
    },
    "EconomyOutput": {
      "additionalProperties": false,
      "description": "경제 출력 데이터 (RULE-005).\n\n이번 턴의 비용과 잔액 정보입니다.\n잔액 음수는 절대 불가 (서버 Hard gate).\n\nAttributes:\n    cost: 이번 턴에 소비된 비용\n    balance_after: 소비 후 잔액\n\nImportant:\n    - cost와 balance_after는 항상 포함되어야 합니다.\n    - balance_after의 signal과 memory_shard는 0 이상이어야 합니다.",
      "properties": {
        "cost": {
          "$ref": "#/$defs/CurrencyAmount",
          "description": "이번 턴에 소비된 비용"
        },
        "balance_after": {
          "$ref": "#/$defs/CurrencyAmount",
          "description": "소비 후 잔액"
        }
      },
      "required": ["cost", "balance_after"],
      "title": "EconomyOutput",
      "type": "object"
    },
    "ImageJob": {
      "additionalProperties": false,
      "description": "이미지 생성 작업.\n\n조건부 이미지 생성/편집 요청입니다.\n이미지 생성이 느릴 경우 텍스트 우선 출력 + Lazy Loading을 사용합니다.\n\nAttributes:\n    should_generate: 이미지를 생성해야 하는지\n    prompt: 이미지 생성 프롬프트\n    model_label: 모델 선택 라벨 (FAST/QUALITY/CHEAP/REF)\n    aspect_ratio: 가로세로 비율 (예: \"16:9\", \"1:1\")\n    image_size: 이미지 크기 (예: \"1024x1024\")\n    reference_image_ids: 참조 이미지 ID 목록 (선택)",
      "properties": {
        "should_generate": {
          "description": "이미지를 생성해야 하는지",
          "title": "Should Generate",
          "type": "boolean"
        },
        "prompt": {
          "default": "",
          "description": "이미지 생성 프롬프트",
          "title": "Prompt",
          "type": "string"
        },
        "model_label": {
          "$ref": "#/$defs/ModelLabel",
          "default": "FAST",
          "description": "모델 선택 라벨"
        },
        "aspect_ratio": {
          "default": "16:9",
          "description": "가로세로 비율",
          "title": "Aspect Ratio",
          "type": "string"
        },
        "image_size": {
          "default": "1024x1024",
          "description": "이미지 크기",
          "title": "Image Size",
          "type": "string"
        },
        "reference_image_ids": {
          "default": [],
          "description": "참조 이미지 ID 목록 (선택)",
          "items": {
            "type": "string"
          },
          "title": "Reference Image Ids",
          "type": "array"
        }
      },
      "required": ["should_generate"],
      "title": "ImageJob",
      "type": "object"
    },
    "Language": {
      "description": "지원 언어 (RULE-006).\n\nko/en 혼합 출력 금지. TurnInput.language를 SSOT로 삼아\n모든 UI/내러티브/시스템 메시지는 동일 언어로 고정합니다.",
      "enum": ["ko-KR", "en-US"],
      "title": "Language",
      "type": "string"
    },
    "MemoryPin": {
      "additionalProperties": false,
      "description": "중요 설정 고정 후보.\n\n사용자가 Memory Shard를 소비해 고정할 수 있는 중요 설정입니다.\n\nAttributes:\n    id: 핀 고유 ID\n    content: 고정할 내용\n    cost: 고정에 필요한 비용",
      "properties": {
        "id": {
          "description": "핀 고유 ID",
          "title": "Id",
          "type": "string"
        },
        "content": {
          "description": "고정할 내용",
          "title": "Content",
          "type": "string"
        },
        "cost": {
          "$ref": "#/$defs/CurrencyAmount",
          "description": "고정에 필요한 비용"
        }
      },
      "required": ["id", "content", "cost"],
      "title": "MemoryPin",
      "type": "object"
    },
    "ModelLabel": {
      "description": "모델/품질 선택 라벨 (RULE-008).\n\n프롬프트 노출 없이 \"왜 이 선택이었는지\"를 사용자 친화 라벨로 표시.",
      "enum": ["FAST", "QUALITY", "CHEAP", "REF"],
      "title": "ModelLabel",
      "type": "string"
    },
    "Quest": {
      "additionalProperties": false,
      "description": "퀘스트/목표 (Quest Panel).\n\n플레이어가 달성해야 하는 현재 목표입니다.\n\nAttributes:\n    id: 퀘스트 고유 ID\n    label: 퀘스트 이름\n    is_completed: 달성 여부",
      "properties": {
        "id": {
          "description": "퀘스트 고유 ID",
          "title": "Id",
          "type": "string"
        },
        "label": {
          "description": "퀘스트 이름",
          "title": "Label",
          "type": "string"
        },
        "is_completed": {
          "default": false,
          "description": "달성 여부",
          "title": "Is Completed",
          "type": "boolean"
        }
      },
      "required": ["id", "label"],
      "title": "Quest",
      "type": "object"
    },
    "RenderOutput": {
      "additionalProperties": false,
      "description": "렌더링 출력 데이터.\n\n이미지 생성/편집 관련 정보입니다.\n\nAttributes:\n    image_job: 이미지 생성 작업 (선택)",
      "properties": {
        "image_job": {
          "anyOf": [
            {
              "$ref": "#/$defs/ImageJob"
            },
            {
              "type": "null"
            }
          ],
          "default": null,
          "description": "이미지 생성 작업 (선택)"
        }
      },
      "title": "RenderOutput",
      "type": "object"
    },
    "RiskLevel": {
      "description": "행동 위험도 수준.",
      "enum": ["low", "medium", "high"],
      "title": "RiskLevel",
      "type": "string"
    },
    "SafetyOutput": {
      "additionalProperties": false,
      "description": "안전 출력 데이터.\n\n안전 정책 관련 정보입니다.\n차단 시 명시적 메시지와 함께 안전한 대체 결과를 제공합니다.\n\nAttributes:\n    blocked: 안전 정책에 의해 차단되었는지\n    message: 차단 시 사용자에게 표시할 메시지 (선택)",
      "properties": {
        "blocked": {
          "default": false,
          "description": "안전 정책에 의해 차단되었는지",
          "title": "Blocked",
          "type": "boolean"
        },
        "message": {
          "anyOf": [
            {
              "type": "string"
            },
            {
              "type": "null"
            }
          ],
          "default": null,
          "description": "차단 시 사용자에게 표시할 메시지 (선택)",
          "title": "Message"
        }
      },
      "title": "SafetyOutput",
      "type": "object"
    },
    "SceneObject": {
      "additionalProperties": false,
      "description": "장면 오브젝트 (클릭 가능한 핫스팟).\n\n화면에서 클릭 가능한 오브젝트입니다.\n좌표는 0~1000 정규화 좌표계를 사용합니다 (RULE-009).\n\nAttributes:\n    id: 오브젝트 고유 ID\n    label: 오브젝트 라벨 (표시용)\n    box_2d: 바운딩 박스 [ymin, xmin, ymax, xmax]\n    interaction_hint: 상호작용 힌트 (선택)",
      "properties": {
        "id": {
          "description": "오브젝트 고유 ID",
          "title": "Id",
          "type": "string"
        },
        "label": {
          "description": "오브젝트 라벨 (표시용)",
          "title": "Label",
          "type": "string"
        },
        "box_2d": {
          "$ref": "#/$defs/Box2D",
          "description": "바운딩 박스"
        },
        "interaction_hint": {
          "anyOf": [
            {
              "type": "string"
            },
            {
              "type": "null"
            }
          ],
          "default": null,
          "description": "상호작용 힌트 (선택)",
          "title": "Interaction Hint"
        }
      },
      "required": ["id", "label", "box_2d"],
      "title": "SceneObject",
      "type": "object"
    },
    "SceneOutput": {
      "additionalProperties": false,
      "description": "Scene 표시 정보 (RU-003-T1: Scene 이미지 SSOT).\n\nTurnOutput에서 Scene Canvas에 표시할 이미지 정보를 제공합니다.\nimage_url이 존재하면 SceneCanvas는 'scene' 상태로 전환됩니다.\nimage_url이 없으면 'default' 상태를 유지합니다.\n\nAttributes:\n    image_url: Scene 이미지 URL (존재 시 scene 상태로 전환)\n    alt_text: 이미지 대체 텍스트 (접근성용, 선택)",
      "properties": {
        "image_url": {
          "anyOf": [
            {
              "type": "string"
            },
            {
              "type": "null"
            }
          ],
          "default": null,
          "description": "Scene 이미지 URL (존재 시 scene 상태로 전환)",
          "title": "Image Url"
        },
        "alt_text": {
          "anyOf": [
            {
              "type": "string"
            },
            {
              "type": "null"
            }
          ],
          "default": null,
          "description": "이미지 대체 텍스트 (접근성용, 선택)",
          "title": "Alt Text"
        }
      },
      "title": "SceneOutput",
      "type": "object"
    },
    "UIOutput": {
      "additionalProperties": false,
      "description": "UI 출력 데이터.\n\nAI가 생성한 UI 요소들입니다.\n채팅 버블이 아닌 게임 UI로 표현됩니다 (RULE-002).\n\nRU-003-T1: scene 필드 추가 - Scene Canvas의 이미지 표시 정보 SSOT.\n\nAttributes:\n    action_deck: 액션 카드 덱 (Q1 결정: Option A 채택)\n    objects: 클릭 가능한 장면 오브젝트 목록\n    scene: Scene 표시 정보 (RU-003-T1)",
      "properties": {
        "action_deck": {
          "$ref": "#/$defs/ActionDeck",
          "description": "액션 카드 덱"
        },
        "objects": {
          "default": [],
          "description": "클릭 가능한 장면 오브젝트 목록",
          "items": {
            "$ref": "#/$defs/SceneObject"
          },
          "title": "Objects",
          "type": "array"
        },
        "scene": {
          "$ref": "#/$defs/SceneOutput",
          "default": {
            "image_url": null,
            "alt_text": null
          },
          "description": "Scene 표시 정보 (RU-003-T1)"
        }
      },
      "title": "UIOutput",
      "type": "object"
    },
    "ValidationBadge": {
      "description": "검증 배지 (RULE-008).\n\n턴 결과에 대한 검증 상태를 표시합니다.",
      "enum": [
        "schema_ok",
        "schema_fail",
        "economy_ok",
        "economy_fail",
        "safety_ok",
        "safety_blocked",
        "consistency_ok",
        "consistency_fail"
      ],
      "title": "ValidationBadge",
      "type": "string"
    },
    "WorldDelta": {
      "additionalProperties": false,
      "description": "세계 상태 변화 (Q2 결정: Option A - delta 중심).\n\n이번 턴에서 변경된 세계 상태를 나타냅니다.\nsnapshot은 SaveGame에만 저장하고, 매 턴은 delta만 전송합니다.\n\nAttributes:\n    rules_changed: 변경되거나 추가된 규칙 목록\n    inventory_added: 추가된 인벤토리 아이템\n    inventory_removed: 제거된 인벤토리 아이템\n    quests_updated: 업데이트된 퀘스트(목표) 목록\n    relationships_changed: 변경된 관계\n    memory_pins: 중요 설정 고정 후보",
      "properties": {
        "rules_changed": {
          "default": [],
          "description": "변경된 규칙 목록",
          "items": {
            "$ref": "#/$defs/WorldRule"
          },
          "title": "Rules Changed",
          "type": "array"
        },
        "inventory_added": {
          "default": [],
          "description": "추가된 인벤토리 아이템",
          "items": {
            "type": "string"
          },
          "title": "Inventory Added",
          "type": "array"
        },
        "inventory_removed": {
          "default": [],
          "description": "제거된 인벤토리 아이템",
          "items": {
            "type": "string"
          },
          "title": "Inventory Removed",
          "type": "array"
        },
        "quests_updated": {
          "default": [],
          "description": "업데이트된 퀘스트/목표 목록",
          "items": {
            "$ref": "#/$defs/Quest"
          },
          "title": "Quests Updated",
          "type": "array"
        },
        "relationships_changed": {
          "default": [],
          "description": "변경된 관계",
          "items": {
            "type": "string"
          },
          "title": "Relationships Changed",
          "type": "array"
        },
        "memory_pins": {
          "default": [],
          "description": "중요 설정 고정 후보",
          "items": {
            "$ref": "#/$defs/MemoryPin"
          },
          "title": "Memory Pins",
          "type": "array"
        }
      },
      "title": "WorldDelta",
      "type": "object"
    },
    "WorldRule": {
      "additionalProperties": false,
      "description": "세계 규칙 (Rule Board).\n\n현재 세계에 적용 중인 물리 법칙이나 메타 규칙입니다.\n\nAttributes:\n    id: 규칙 고유 ID\n    label: 규칙 이름\n    description: 규칙 상세 설명 (선택)",
      "properties": {
        "id": {
          "description": "규칙 고유 ID",
          "title": "Id",
          "type": "string"
        },
        "label": {
          "description": "규칙 이름",
          "title": "Label",
          "type": "string"
        },
        "description": {
          "anyOf": [
            {
              "type": "string"
            },
            {
              "type": "null"
            }
          ],
          "default": null,
          "description": "규칙 상세 설명 (선택)",
          "title": "Description"
        }
      },
      "required": ["id", "label"],
      "title": "WorldRule",
      "type": "object"
    }
  },
  "additionalProperties": false,
  "description": "턴 출력 (서버 → 클라이언트).\n\n서버가 턴 처리 후 클라이언트로 반환하는 구조화된 응답입니다.\nGemini Structured Outputs(JSON Schema)로 강제됩니다.\n\nHard Gate 필드 (RULE-003/004/005):\n    - economy: cost와 balance_after 필수, 잔액 음수 금지\n    - safety: blocked 시 안전한 대체 결과 제공\n    - language: 요청 언어와 동일하게 고정 (혼합 출력 금지)\n\nAttributes:\n    language: 응답 언어 (요청과 동일)\n    narrative: 내러티브 텍스트 (표시용)\n    ui: UI 요소 (액션 덱, 오브젝트)\n    world: 세계 상태 변화 (delta 중심)\n    render: 렌더링 정보 (이미지 생성 작업)\n    economy: 경제 정보 (비용, 잔액)\n    safety: 안전 정책 정보\n    agent_console: 에이전트 실행 정보 (단계, 배지, 복구 횟수)\n\nExample:\n    >>> output = TurnOutput(\n    ...     language=Language.KO,\n    ...     narrative=\"문이 삐걱거리며 열립니다...\",\n    ...     economy=EconomyOutput(\n    ...         cost=CurrencyAmount(signal=5, memory_shard=0),\n    ...         balance_after=CurrencyAmount(signal=95, memory_shard=5),\n    ...     ),\n    ...     safety=SafetyOutput(blocked=False),\n    ... )\n    >>> schema = TurnOutput.model_json_schema()\n\nSchema Generation:\n    >>> # Gemini Structured Outputs용 JSON Schema 생성\n    >>> json_schema = TurnOutput.model_json_schema()\n    >>> # response_json_schema 파라미터에 전달\n    >>> config = {\n    ...     \"response_mime_type\": \"application/json\",\n    ...     \"response_json_schema\": json_schema,\n    ... }",
  "properties": {
    "language": {
      "$ref": "#/$defs/Language",
      "description": "응답 언어 (요청과 동일)"
    },
    "narrative": {
      "description": "내러티브 텍스트 (표시용)",
      "title": "Narrative",
      "type": "string"
    },
    "economy": {
      "$ref": "#/$defs/EconomyOutput",
      "description": "경제 정보 (비용, 잔액)"
    },
    "safety": {
      "$ref": "#/$defs/SafetyOutput",
      "description": "안전 정책 정보"
    },
    "ui": {
      "$ref": "#/$defs/UIOutput",
      "description": "UI 요소"
    },
    "world": {
      "$ref": "#/$defs/WorldDelta",
      "description": "세계 상태 변화 (delta)"
    },
    "render": {
      "$ref": "#/$defs/RenderOutput",
      "description": "렌더링 정보"
    },
    "agent_console": {
      "$ref": "#/$defs/AgentConsole",
      "description": "에이전트 실행 정보"
    }
  },
  "required": ["language", "narrative", "economy", "safety"],
  "title": "TurnOutput",
  "type": "object"
}
</file>

<file path="backend/debug_api_call.py">
"""Debug: 서버 API 호출 테스트."""

import json

import httpx


def main():
    url = "http://localhost:8011/api/turn"
    payload = {
        "language": "ko-KR",
        "text": "문을 열어본다",
        "client": {"viewport_w": 1920, "viewport_h": 1080, "theme": "dark"},
        "economy_snapshot": {"signal": 100, "memory_shard": 5},
    }

    print(f"Sending to: {url}")
    print(f"Payload: {json.dumps(payload, ensure_ascii=False)}")
    print()

    with httpx.Client(timeout=30.0) as client:
        response = client.post(url, json=payload)
        print(f"Status: {response.status_code}")
        print()

        lines = response.text.strip().split("\n")
        for line in lines:
            data = json.loads(line)
            event_type = data.get("type")

            if event_type == "badges":
                print(f"BADGES: {data.get('badges')}")
            elif event_type == "repair":
                print(f"REPAIR attempt={data.get('attempt')}: {data.get('message')}")
            elif event_type == "final":
                final_data = data.get("data", {})
                print(f"FINAL badges: {final_data.get('agent_console', {}).get('badges')}")
                print(
                    f"FINAL repair_count: {final_data.get('agent_console', {}).get('repair_count')}"
                )
                print(f"FINAL narrative: {final_data.get('narrative', '')[:100]}")
                print(
                    f"FINAL model_label: {final_data.get('agent_console', {}).get('model_label')}"
                )
            elif event_type == "error":
                print(f"ERROR: {data.get('message')} code={data.get('code')}")
            elif event_type == "stage":
                status = data.get("status")
                if status == "fail":
                    print(f"STAGE FAIL: {data.get('name')}")


if __name__ == "__main__":
    main()
</file>

<file path="backend/debug_schema_check.py">
"""Debug: 서버에 캐시된 제너레이터와 직접 생성한 것을 비교합니다."""

import asyncio
import json
import os
from pathlib import Path

from dotenv import load_dotenv

load_dotenv(dotenv_path=Path(__file__).parent / ".env", override=False)
os.environ["UW_MODE"] = "real"

from pydantic import ValidationError

from unknown_world.models.turn import Language, TurnInput, TurnOutput
from unknown_world.orchestrator.generate_turn_output import (
    TurnOutputGenerator,
    _strip_additional_properties,
)
from unknown_world.services.genai_client import (
    reset_genai_client,
)


async def main():
    print("=== 1. Schema comparison ===")
    raw_schema = TurnOutput.model_json_schema()
    stripped = _strip_additional_properties(raw_schema)

    # Check $defs
    if "$defs" in stripped:
        print(f"Schema has $defs with {len(stripped['$defs'])} definitions")
        for name in stripped["$defs"]:
            print(f"  - {name}")
    else:
        print("Schema has NO $defs")

    print(f"Top-level keys: {list(stripped.keys())}")
    print(f"Required: {stripped.get('required', [])}")
    print()

    print("=== 2. Multiple API calls ===")
    reset_genai_client()
    generator = TurnOutputGenerator(force_mock=False)

    turn_input = TurnInput(
        language=Language.KO,
        text="문을 열어본다",
        client={"viewport_w": 1920, "viewport_h": 1080, "theme": "dark"},
        economy_snapshot={"signal": 100, "memory_shard": 5},
    )

    success_count = 0
    fail_count = 0
    for i in range(3):
        print(f"\n--- Attempt {i + 1} ---")
        result = await generator.generate(turn_input)
        print(f"Status: {result.status}")

        if result.status.value == "success":
            success_count += 1
            print("OK")
        else:
            fail_count += 1
            print(f"Error: {result.error_message}")
            print(f"Details: {json.dumps(result.error_details, indent=2, ensure_ascii=False)}")

            if result.raw_response:
                # Try to parse and identify what's wrong
                text = result.raw_response.strip()
                if text.startswith("```"):
                    lines = text.split("\n")
                    if lines[0].startswith("```"):
                        lines = lines[1:]
                    if lines and lines[-1].strip() == "```":
                        lines = lines[:-1]
                    text = "\n".join(lines)

                try:
                    data = json.loads(text)
                    print(f"JSON keys: {list(data.keys())}")

                    # Check each sub-model for extra fields
                    for key in data:
                        val = data[key]
                        if isinstance(val, dict):
                            # Check if any sub-dict has unexpected keys
                            pass

                    # Try validation manually
                    try:
                        TurnOutput.model_validate(data)
                        print("Pydantic OK (inconsistent!)")
                    except ValidationError as e:
                        print(f"Pydantic errors ({len(e.errors())}):")
                        for err in e.errors():
                            print(f"  loc={err['loc']} type={err['type']} msg={err['msg']}")
                            if "input" in err:
                                inp_str = str(err["input"])[:200]
                                print(f"  input={inp_str}")
                except json.JSONDecodeError:
                    print(f"Raw (first 500): {result.raw_response[:500]}")

    print(f"\n=== Summary: {success_count} success, {fail_count} fail ===")


if __name__ == "__main__":
    asyncio.run(main())
</file>

<file path="backend/debug_server_state.py">
"""Debug: 서버와 동일한 코드 경로로 문제를 재현합니다."""

import asyncio
import json
import os
from pathlib import Path

from dotenv import load_dotenv

# 서버와 동일하게 .env 로드
_DOTENV_PATH = Path(__file__).resolve().parent / ".env"
_dotenv_loaded = load_dotenv(dotenv_path=_DOTENV_PATH, override=False)
print(f".env path: {_DOTENV_PATH}")
print(f".env exists: {_DOTENV_PATH.exists()}")
print(f".env loaded: {_dotenv_loaded}")
print(f"UW_MODE: {os.environ.get('UW_MODE', 'NOT_SET')}")
print(f"GOOGLE_API_KEY set: {bool(os.environ.get('GOOGLE_API_KEY'))}")
print()

from pydantic import ValidationError

from unknown_world.models.turn import Language, TurnInput, TurnOutput
from unknown_world.orchestrator.generate_turn_output import (
    TurnOutputGenerator,
    _strip_additional_properties,
)


async def main():
    # 1. JSON Schema 검사 - $defs/$ref 확인
    raw_schema = TurnOutput.model_json_schema()
    stripped = _strip_additional_properties(raw_schema)

    has_refs = "$defs" in stripped
    print(f"Schema has $defs: {has_refs}")

    # $ref 참조가 있는지 확인
    schema_str = json.dumps(stripped)
    ref_count = schema_str.count('"$ref"')
    print(f"Schema $ref count: {ref_count}")

    if ref_count > 0:
        print("\n!!! WARNING: Schema has $ref references !!!")
        print("Gemini Structured Outputs may not support $ref/$defs.")
        print("This could cause intermittent failures.")
        print()

    # 2. 서버와 동일한 경로로 호출
    turn_input = TurnInput(
        language=Language.KO,
        text="문을 열어본다",
        client={"viewport_w": 1920, "viewport_h": 1080, "theme": "dark"},
        economy_snapshot={"signal": 100, "memory_shard": 5},
    )

    generator = TurnOutputGenerator(force_mock=False)

    # 3. 수동으로 Gemini API 직접 호출하여 raw 응답 확인
    from unknown_world.config.models import ModelLabel
    from unknown_world.services.genai_client import (
        GenerateRequest,
        get_genai_client,
        reset_genai_client,
    )

    reset_genai_client()
    client = get_genai_client(force_mock=False)
    print(f"Client type: {type(client).__name__}")
    print(f"Client mode: {client.mode}")
    print(f"Client available: {client.is_available()}")

    if not client.is_available():
        print("ERROR: Client not available!")
        return

    # 4. 프롬프트 빌드
    prompt = generator._build_prompt(turn_input)
    json_schema = generator._get_json_schema()

    print(f"\nPrompt length: {len(prompt)} chars")
    print(f"Schema size: {len(json.dumps(json_schema))} chars")

    # 5. Gemini 직접 호출
    request = GenerateRequest(
        prompt=prompt,
        model_label=ModelLabel.FAST,
        temperature=0.7,
        response_mime_type="application/json",
        response_schema=json_schema,
    )

    print("\nCalling Gemini API...")
    response = await client.generate(request)
    raw_text = response.text
    print(f"Response length: {len(raw_text)} chars")
    print(f"First 200 chars: {raw_text[:200]}")
    print()

    # 6. JSON 파싱
    try:
        text = raw_text.strip()
        if text.startswith("```"):
            lines = text.split("\n")
            if lines[0].startswith("```"):
                lines = lines[1:]
            if lines and lines[-1].strip() == "```":
                lines = lines[:-1]
            text = "\n".join(lines)

        data = json.loads(text)
        print(f"JSON parsed OK. Keys: {list(data.keys())}")
    except json.JSONDecodeError as e:
        print(f"JSON PARSE FAILED: {e}")
        print(f"Full response:\n{raw_text}")
        return

    # 7. Pydantic 검증
    try:
        output = TurnOutput.model_validate(data)
        print(f"Pydantic OK! Narrative: {output.narrative[:80]}...")
    except ValidationError as e:
        print(f"\n=== PYDANTIC VALIDATION FAILED ({len(e.errors())} errors) ===")
        for err in e.errors():
            print(f"  loc: {err['loc']}")
            print(f"  type: {err['type']}")
            print(f"  msg: {err['msg']}")
            if "input" in err:
                inp = str(err["input"])[:200]
                print(f"  input: {inp}")
            print()

        # 어떤 필드에 extra properties가 있는지 확인
        print("=== Checking for extra properties ===")
        _check_extra_fields(data)


def _check_extra_fields(data, path="root"):
    """모델과 비교하여 추가 필드를 찾습니다."""
    from unknown_world.models import turn as turn_models

    model_map = {
        "root": turn_models.TurnOutput,
        "economy": turn_models.EconomyOutput,
        "economy.cost": turn_models.CurrencyAmount,
        "economy.balance_after": turn_models.CurrencyAmount,
        "safety": turn_models.SafetyOutput,
        "ui": turn_models.UIOutput,
        "ui.action_deck": turn_models.ActionDeck,
        "world": turn_models.WorldDelta,
        "render": turn_models.RenderOutput,
        "agent_console": turn_models.AgentConsole,
    }

    model_cls = model_map.get(path)
    if model_cls and isinstance(data, dict):
        expected = set(model_cls.model_fields.keys())
        actual = set(data.keys())
        extra = actual - expected
        missing = expected - actual
        if extra:
            print(f"  [{path}] EXTRA fields: {extra}")
        if missing:
            # Only report missing required fields
            required = {
                name for name, field in model_cls.model_fields.items() if field.is_required()
            }
            missing_required = missing & required
            if missing_required:
                print(f"  [{path}] MISSING required: {missing_required}")

    if isinstance(data, dict):
        for key, val in data.items():
            child_path = f"{path}.{key}" if path != "root" else key
            if isinstance(val, dict):
                _check_extra_fields(val, child_path)
            elif isinstance(val, list):
                for i, item in enumerate(val):
                    if isinstance(item, dict):
                        _check_extra_fields(item, f"{child_path}[{i}]")


if __name__ == "__main__":
    asyncio.run(main())
</file>

<file path="backend/debug_uvicorn_sim.py">
"""서버와 동일한 방식으로 실행하여 문제를 재현합니다.
main.py의 .env 로딩 → pipeline context → validate_real → repair_loop 전체 경로."""

import asyncio
import os
import sys

# 1) main.py와 동일한 방식으로 .env 로드
from pathlib import Path

from dotenv import load_dotenv

_DOTENV_PATH = Path(__file__).resolve().parent / ".env"
_dotenv_loaded = load_dotenv(dotenv_path=_DOTENV_PATH, override=False)
print(f"UW_MODE={os.environ.get('UW_MODE')}", file=sys.stderr)
print(f"GOOGLE_API_KEY set={bool(os.environ.get('GOOGLE_API_KEY'))}", file=sys.stderr)

# 2) 서버와 동일한 import 경로
from unknown_world.models.turn import Language, TurnInput
from unknown_world.orchestrator.pipeline import create_pipeline_context, run_pipeline
from unknown_world.orchestrator.stages.types import PipelineEvent, PipelineEventType


async def main():
    turn_input = TurnInput(
        language=Language.KO,
        text="문을 열어본다",
        client={"viewport_w": 1920, "viewport_h": 1080, "theme": "dark"},
        economy_snapshot={"signal": 100, "memory_shard": 5},
    )

    # 3) Pipeline 컨텍스트 생성 (서버와 동일)
    ctx = create_pipeline_context(turn_input)
    print(f"is_mock={ctx.is_mock}", file=sys.stderr)

    # 4) 이벤트 수집
    events = []

    async def emit(event: PipelineEvent):
        events.append(event)
        if event.event_type == PipelineEventType.BADGES:
            badge_vals = [b.value for b in event.badges] if event.badges else []
            print(f"EVENT badges: {badge_vals}", file=sys.stderr)
        elif event.event_type == PipelineEventType.REPAIR:
            print(
                f"EVENT repair: attempt={event.repair_attempt} msg={event.repair_message}",
                file=sys.stderr,
            )

    # 5) Pipeline 실행
    ctx = await run_pipeline(ctx, emit=emit)

    # 6) 결과 출력
    print(f"\nis_fallback={ctx.is_fallback}", file=sys.stderr)
    print(f"badges={[b.value for b in ctx.badges]}", file=sys.stderr)
    print(f"repair_attempts={ctx.repair_attempts}", file=sys.stderr)

    if ctx.output:
        print(f"narrative={ctx.output.narrative[:100]}", file=sys.stderr)
        print(
            f"output_badges={[b.value for b in ctx.output.agent_console.badges]}", file=sys.stderr
        )


if __name__ == "__main__":
    asyncio.run(main())
</file>

<file path="backend/run_full_test.py">
"""정확한 재현: uvicorn CLI처럼 서버를 시작하고 테스트합니다."""

import json
import os
import subprocess
import time

import httpx


def main():
    # 서버 시작 (사용자와 동일한 명령어)
    env = os.environ.copy()
    proc = subprocess.Popen(
        [
            "uv",
            "run",
            "uvicorn",
            "src.unknown_world.main:app",
            "--host",
            "0.0.0.0",
            "--port",
            "8011",
        ],
        cwd=r"D:\Dev\unknown-world\backend",
        stdout=subprocess.PIPE,
        stderr=subprocess.PIPE,
        env=env,
    )
    print(f"Server PID: {proc.pid}")

    # 서버 시작 대기
    for i in range(15):
        time.sleep(1)
        try:
            r = httpx.get("http://localhost:8011/health", timeout=2.0)
            if r.status_code == 200:
                print(f"Server ready after {i + 1}s")
                break
        except Exception:
            pass
    else:
        print("Server failed to start!")
        proc.terminate()
        stderr = proc.stderr.read().decode("utf-8", errors="replace")
        print(f"STDERR:\n{stderr[:2000]}")
        return

    # API 테스트
    print("\n=== API Test ===")
    try:
        r = httpx.post(
            "http://localhost:8011/api/turn",
            json={
                "language": "ko-KR",
                "text": "문을 열어본다",
                "client": {"viewport_w": 1920, "viewport_h": 1080, "theme": "dark"},
                "economy_snapshot": {"signal": 100, "memory_shard": 5},
            },
            timeout=60.0,
        )

        for line in r.text.strip().split("\n"):
            d = json.loads(line)
            t = d.get("type")
            if t == "repair":
                print(f"  REPAIR: attempt={d.get('attempt')} msg={d.get('message')}")
            elif t == "badges":
                print(f"  BADGES: {d.get('badges')}")
            elif t == "final":
                fc = d.get("data", {}).get("agent_console", {})
                narr = d.get("data", {}).get("narrative", "")[:80]
                print(f"  FINAL badges={fc.get('badges')} repair={fc.get('repair_count')}")
                print(f"  NARRATIVE: {narr}")
            elif t == "error":
                print(f"  ERROR: {d.get('message')} code={d.get('code')}")
    except Exception as e:
        print(f"  EXCEPTION: {e}")

    # 서버 stderr 출력 (디버그 로그 포함)
    proc.terminate()
    try:
        proc.wait(timeout=5)
    except subprocess.TimeoutExpired:
        proc.kill()

    stderr = proc.stderr.read().decode("utf-8", errors="replace")
    print("\n=== Server STDERR (last 3000 chars) ===")
    print(stderr[-3000:])


if __name__ == "__main__":
    main()
</file>

<file path="backend/src/unknown_world/api/__init__.py">
"""Unknown World - API 패키지.

이 패키지는 FastAPI 라우터들을 포함합니다.
"""

from unknown_world.api.image import router as image_router
from unknown_world.api.item_icon import router as item_icon_router
from unknown_world.api.scanner import router as scanner_router
from unknown_world.api.turn import router as turn_router

__all__ = ["image_router", "item_icon_router", "scanner_router", "turn_router"]
</file>

<file path="backend/src/unknown_world/api/item_icon.py">
"""Unknown World - 아이템 아이콘 생성 API (U-075[Mvp]).

아이템 설명을 기반으로 동적 아이콘을 생성하는 API 엔드포인트입니다.

설계 원칙:
    - RULE-004: 실패 시 안전한 폴백 제공
    - RULE-006: ko/en 언어 정책 준수
    - RULE-007: 프롬프트 원문 노출 금지

페어링 질문 결정 (U-075[Mvp]):
    - Q1: Option B (placeholder 먼저 표시 후 백그라운드 생성)

참조:
    - vibe/unit-plans/U-075[Mvp].md
"""

from __future__ import annotations

import logging
from typing import Annotated

from fastapi import APIRouter, Query
from pydantic import BaseModel, ConfigDict, Field

from unknown_world.services.item_icon_generator import (
    IconGenerationRequest,
    get_item_icon_generator,
)

# =============================================================================
# 로거 설정
# =============================================================================

logger = logging.getLogger(__name__)

# =============================================================================
# 라우터 설정
# =============================================================================

router = APIRouter(prefix="/api/item", tags=["item"])


# =============================================================================
# API 모델
# =============================================================================


class GenerateIconRequest(BaseModel):
    """아이콘 생성 요청 (API).

    Attributes:
        item_id: 아이템 고유 ID
        description: 아이템 설명 (아이콘 생성용)
        language: 현재 세션 언어
        wait: 생성 완료까지 대기할지 여부
    """

    model_config = ConfigDict(extra="forbid")

    item_id: str = Field(description="아이템 고유 ID")
    description: str = Field(description="아이템 설명 (아이콘 생성용)")
    language: str = Field(default="en-US", description="현재 세션 언어 (ko-KR/en-US)")
    wait: bool = Field(
        default=False,
        description="생성 완료까지 대기 (false: placeholder 즉시 반환)",
    )


class IconResponse(BaseModel):
    """아이콘 응답 (API).

    Attributes:
        status: 생성 상태
        icon_url: 아이콘 URL
        item_id: 아이템 ID
        is_placeholder: placeholder 아이콘 여부
        message: 상태 메시지
    """

    model_config = ConfigDict(extra="forbid")

    status: str = Field(description="생성 상태")
    icon_url: str = Field(description="아이콘 URL")
    item_id: str = Field(description="아이템 ID")
    is_placeholder: bool = Field(default=False, description="placeholder 아이콘 여부")
    message: str | None = Field(default=None, description="상태 메시지")


class IconStatusResponse(BaseModel):
    """아이콘 상태 응답 (API).

    Attributes:
        item_id: 아이템 ID
        status: 생성 상태
    """

    model_config = ConfigDict(extra="forbid")

    item_id: str = Field(description="아이템 ID")
    status: str = Field(description="생성 상태")


# =============================================================================
# API 엔드포인트
# =============================================================================


@router.post("/icon", response_model=IconResponse)
async def generate_item_icon(request: GenerateIconRequest) -> IconResponse:
    """아이템 아이콘을 생성합니다.

    Q1 결정 (Option B): wait=false면 placeholder 즉시 반환 후 백그라운드 생성.

    Args:
        request: 아이콘 생성 요청

    Returns:
        IconResponse: 아이콘 URL 및 상태
    """
    logger.info(
        "[ItemIconAPI] 아이콘 생성 요청",
        extra={
            "item_id": request.item_id,
            "language": request.language,
            "wait": request.wait,
        },
    )

    generator = get_item_icon_generator()
    gen_request = IconGenerationRequest(
        item_id=request.item_id,
        item_description=request.description,
        language=request.language,
    )

    result = await generator.generate_icon(
        gen_request,
        wait_for_completion=request.wait,
    )

    return IconResponse(
        status=result.status.value,
        icon_url=result.icon_url,
        item_id=result.item_id,
        is_placeholder=result.is_placeholder,
        message=result.message,
    )


@router.get("/icon/{item_id}/status", response_model=IconStatusResponse)
async def get_icon_status(item_id: str) -> IconStatusResponse:
    """아이콘 생성 상태를 확인합니다.

    Args:
        item_id: 아이템 ID

    Returns:
        IconStatusResponse: 현재 상태
    """
    generator = get_item_icon_generator()
    status = await generator.get_icon_status(item_id)

    return IconStatusResponse(
        item_id=item_id,
        status=status.value,
    )


@router.get("/icon", response_model=IconResponse)
async def get_or_generate_icon(
    item_id: Annotated[str, Query(description="아이템 고유 ID")],
    description: Annotated[str, Query(description="아이템 설명")],
    language: Annotated[str, Query(description="세션 언어")] = "en-US",
) -> IconResponse:
    """아이콘을 조회하거나 생성합니다 (GET 방식).

    캐시에 있으면 즉시 반환, 없으면 백그라운드 생성 시작 후 placeholder 반환.

    Args:
        item_id: 아이템 ID
        description: 아이템 설명
        language: 세션 언어

    Returns:
        IconResponse: 아이콘 URL 및 상태
    """
    generator = get_item_icon_generator()
    gen_request = IconGenerationRequest(
        item_id=item_id,
        item_description=description,
        language=language,
    )

    result = await generator.generate_icon(
        gen_request,
        wait_for_completion=False,  # GET은 항상 비동기
    )

    return IconResponse(
        status=result.status.value,
        icon_url=result.icon_url,
        item_id=result.item_id,
        is_placeholder=result.is_placeholder,
        message=result.message,
    )
</file>

<file path="backend/src/unknown_world/api/turn.py">
"""Unknown World - /api/turn HTTP Streaming 엔드포인트.

POST 요청을 받아 NDJSON(라인 단위 JSON) 스트리밍으로 턴 결과를 반환합니다.

설계 원칙:
    - RULE-003: 구조화 출력(JSON Schema) 우선 + Pydantic 검증
    - RULE-004: 검증 실패 시 Repair loop + 안전한 폴백
    - RULE-005: 재화 인바리언트 (잔액 음수 금지)
    - RULE-007: 프롬프트/내부 추론 노출 금지
    - RULE-008: 단계/배지 가시화, TTFB 2초 목표

스트림 이벤트 타입:
    - stage: 단계 진행 상태 (Parse→Validate→Plan→Resolve→Render→Verify→Commit)
    - badges: 검증 배지 목록
    - narrative_delta: 내러티브 텍스트 조각 (타자 효과용)
    - repair: Auto-repair 이벤트 (U-018)
    - final: 최종 TurnOutput
    - error: 에러 발생 시

리팩토링 (RU-005-Q4):
    - 기존 _stream_turn_events_mock/_real을 pipeline 기반으로 통합
    - API 레이어는 스트리밍 직렬화/전송에 집중
    - 오케스트레이션 로직은 pipeline.py로 위임

참조:
    - vibe/unit-plans/U-007[Mvp].md
    - vibe/unit-plans/U-018[Mvp].md
    - vibe/refactors/RU-005-Q4.md
    - .cursor/rules/20-backend-orchestrator.mdc
"""

from __future__ import annotations

import asyncio
import contextlib
import time
from collections.abc import AsyncGenerator
from typing import Any, cast

from fastapi import APIRouter, Request
from fastapi.responses import StreamingResponse
from pydantic import ValidationError

from unknown_world.api.turn_stream_events import (
    BadgesEvent,
    NarrativeDeltaEvent,
    RepairEvent,
    StageEvent,
    StageStatus,
    StreamEventType,
    serialize_event,
)
from unknown_world.api.turn_streaming_helpers import (
    emit_error_with_fallback,
    emit_rate_limited_error,
    stream_output_with_narrative,
)
from unknown_world.models.turn import (
    CurrencyAmount,
    Language,
    TurnInput,
)
from unknown_world.orchestrator.fallback import create_safe_fallback
from unknown_world.orchestrator.pipeline import create_pipeline_context, run_pipeline
from unknown_world.orchestrator.repair_loop import MAX_REPAIR_ATTEMPTS
from unknown_world.orchestrator.stages.types import (
    PipelineEvent,
    PipelineEventType,
)

# =============================================================================
# 라우터 정의
# =============================================================================

router = APIRouter(prefix="/api", tags=["Turn"])


# =============================================================================
# Pipeline Event → Stream Event 변환
# =============================================================================


def _convert_pipeline_event(event: PipelineEvent) -> dict[str, Any] | None:
    """파이프라인 이벤트를 스트림 이벤트로 변환합니다.

    Args:
        event: 파이프라인 도메인 이벤트

    Returns:
        스트림 이벤트 dict (serialize_event에 전달) 또는 None
    """
    if event.event_type == PipelineEventType.STAGE_START:
        if event.phase is None:
            return None
        return StageEvent(
            type=StreamEventType.STAGE,
            name=event.phase.value,
            status=StageStatus.START,
        ).model_dump()

    if event.event_type == PipelineEventType.STAGE_COMPLETE:
        if event.phase is None:
            return None
        return StageEvent(
            type=StreamEventType.STAGE,
            name=event.phase.value,
            status=StageStatus.COMPLETE,
        ).model_dump()

    if event.event_type == PipelineEventType.STAGE_FAIL:
        if event.phase is None:
            return None
        return StageEvent(
            type=StreamEventType.STAGE,
            name=event.phase.value,
            status=StageStatus.FAIL,
        ).model_dump()

    if event.event_type == PipelineEventType.BADGES:
        if event.badges is None:
            return None
        return BadgesEvent(
            type=StreamEventType.BADGES,
            badges=[b.value for b in event.badges],
        ).model_dump()

    if event.event_type == PipelineEventType.REPAIR:
        return RepairEvent(
            type=StreamEventType.REPAIR,
            attempt=event.repair_attempt,
            message=event.repair_message,
        ).model_dump()

    if event.event_type == PipelineEventType.NARRATIVE_DELTA:
        if event.text is None:
            return None
        return NarrativeDeltaEvent(
            type=StreamEventType.NARRATIVE_DELTA,
            text=event.text,
        ).model_dump()

    return None


# =============================================================================
# 스트리밍 생성기
# =============================================================================


async def _stream_turn_events(
    turn_input: TurnInput, seed: int | None = None
) -> AsyncGenerator[str]:
    """턴 처리 이벤트를 NDJSON 스트림으로 생성합니다.

    Pipeline을 실행하고, 도메인 이벤트를 스트림 이벤트로 변환하여 전송합니다.

    Args:
        turn_input: 사용자 턴 입력
        seed: Mock 모드 시드 (재현성 보장)

    Yields:
        str: NDJSON 라인
    """
    # 이벤트 큐 (emit 콜백에서 이벤트를 쌓고, 메인 루프에서 소비)
    event_queue: asyncio.Queue[PipelineEvent | None] = asyncio.Queue()

    async def emit(event: PipelineEvent) -> None:
        """파이프라인 이벤트를 큐에 추가합니다."""
        await event_queue.put(event)

    # Pipeline 컨텍스트 생성
    ctx = create_pipeline_context(turn_input, seed=seed)

    # Pipeline 실행을 백그라운드 태스크로 시작
    async def run_pipeline_task() -> None:
        nonlocal ctx
        try:
            ctx = await run_pipeline(ctx, emit=emit)
        except asyncio.CancelledError:
            # RU-005-S2: 클라이언트 Abort 시 태스크도 취소됨
            # - 폴백 생성 없이 즉시 종료 (프론트 정책과 맞춤)
            raise  # finally 블록은 실행, 종료 신호만 보냄
        except Exception:
            # 예외 발생 시 폴백 (RULE-004)
            ctx.output = create_safe_fallback(
                language=turn_input.language,
                economy_snapshot=ctx.economy_snapshot,
                repair_count=ctx.repair_attempts,
            )
            ctx.is_fallback = True
        finally:
            # 종료 신호 (CancelledError 포함 모든 경우에 전송)
            await event_queue.put(None)

    pipeline_task = asyncio.create_task(run_pipeline_task())

    # 이벤트 소비 루프
    try:
        while True:
            event = await event_queue.get()
            if event is None:
                # Pipeline 종료
                break

            stream_event = _convert_pipeline_event(event)
            if stream_event is not None:
                yield serialize_event(stream_event)

        # U-130: rate limit 상태이면 error(RATE_LIMITED)만 송출, final 없음
        if ctx.is_rate_limited:
            async for line in emit_rate_limited_error(turn_input.language):
                yield line
        # Pipeline 완료 후 내러티브 + final 전송 (RU-005-Q3: 헬퍼 사용)
        elif ctx.output is not None:
            async for line in stream_output_with_narrative(ctx.output):
                yield line

    except asyncio.CancelledError:
        # RU-005-S2: 클라이언트 Abort(연결 취소) 시 조용히 종료
        # - 추가 이벤트(error/final) 송출하지 않음
        # - 로그도 noisy하지 않게 남기지 않음 (프론트 정책과 맞춤)
        pass

    except Exception:
        # 예외 발생 시 error + final(폴백) 순서로 송출 (RULE-004, RU-005-Q3: 헬퍼 사용)
        async for line in emit_error_with_fallback(
            turn_input.language,
            economy_snapshot=ctx.economy_snapshot,
            repair_count=MAX_REPAIR_ATTEMPTS,
        ):
            yield line

    finally:
        # Pipeline 태스크 정리
        if not pipeline_task.done():
            pipeline_task.cancel()
            with contextlib.suppress(asyncio.CancelledError):
                await pipeline_task


# =============================================================================
# 입력 검증
# =============================================================================


async def _validate_and_parse_input(request: Request) -> TurnInput | dict[str, Any]:
    """요청 본문을 TurnInput으로 검증 및 파싱합니다.

    Returns:
        TurnInput 또는 에러 정보 dict (language, economy_snapshot 포함)
    """
    body: dict[str, Any] | None = None
    try:
        body = await request.json()
        return TurnInput.model_validate(body)
    except ValidationError as e:
        # RU-002-S1: 입력 검증 실패 시에도 language/economy 추출 시도
        raw_language = body.get("language") if isinstance(body, dict) else None
        raw_economy = body.get("economy_snapshot") if isinstance(body, dict) else None
        return {
            "error": True,
            "message": "Invalid input",
            "details": e.errors(),
            "language": raw_language if raw_language in ("ko-KR", "en-US") else "en-US",
            "economy_snapshot": raw_economy,
        }
    except Exception:
        return {
            "error": True,
            "message": "Failed to parse request body",
            "details": None,
            "language": "en-US",
            "economy_snapshot": None,
        }


# =============================================================================
# API 엔드포인트
# =============================================================================


@router.post(
    "/turn",
    response_class=StreamingResponse,
    summary="턴 처리 (HTTP Streaming)",
    description="""
턴 입력을 받아 NDJSON 스트리밍으로 결과를 반환합니다.

**스트림 이벤트 타입**:
- `stage`: 처리 단계 진행 상태
- `badges`: 검증 배지 목록
- `narrative_delta`: 내러티브 텍스트 조각 (타자 효과)
- `final`: 최종 TurnOutput
- `error`: 에러 발생 시

**예시 요청**:
```json
{
    "language": "ko-KR",
    "text": "문을 열어본다",
    "client": {"viewport_w": 1920, "viewport_h": 1080, "theme": "dark"},
    "economy_snapshot": {"signal": 100, "memory_shard": 5}
}
```
""",
    responses={
        200: {
            "description": "NDJSON 스트림",
            "content": {
                "application/x-ndjson": {
                    "example": '{"type":"stage","name":"parse","status":"start"}\n'
                }
            },
        },
        400: {"description": "잘못된 요청"},
    },
)
async def turn_stream(request: Request) -> StreamingResponse:
    """턴 처리 HTTP Streaming 엔드포인트.

    POST 요청으로 TurnInput을 받아 NDJSON 스트리밍으로 결과를 반환합니다.
    TTFB를 줄이기 위해 첫 stage 이벤트를 즉시 전송합니다.

    Args:
        request: FastAPI Request 객체

    Returns:
        StreamingResponse: NDJSON 스트림
    """
    # 입력 검증
    parse_result = await _validate_and_parse_input(request)

    if isinstance(parse_result, dict) and parse_result.get("error"):
        # RU-002-S1: 입력 검증 실패 시에도 error + final(폴백) 순서로 송출
        error_language = parse_result.get("language", "en-US")
        error_economy = parse_result.get("economy_snapshot")

        # economy_snapshot이 유효한지 확인
        economy_snapshot: CurrencyAmount | None = None
        if isinstance(error_economy, dict):
            try:
                # 명시적 타입 캐스팅으로 Pyright 경고 해소
                eco_dict = cast(dict[str, Any], error_economy)
                economy_snapshot = CurrencyAmount(
                    signal=int(eco_dict.get("signal", 100)),
                    memory_shard=int(eco_dict.get("memory_shard", 5)),
                )
            except (ValueError, TypeError):
                economy_snapshot = None

        async def error_stream() -> AsyncGenerator[str]:
            # RU-005-Q3: 헬퍼를 사용하여 error + final(폴백) 송출
            async for line in emit_error_with_fallback(
                Language.KO if error_language == "ko-KR" else Language.EN,
                error_message=parse_result.get("message", "Invalid input"),
                error_code="VALIDATION_ERROR",
                economy_snapshot=economy_snapshot,
                repair_count=0,
            ):
                yield line

        return StreamingResponse(
            error_stream(),
            media_type="application/x-ndjson",
            headers={
                "Cache-Control": "no-cache",
                "X-Accel-Buffering": "no",  # nginx 버퍼링 비활성화
            },
        )

    turn_input: TurnInput = parse_result  # type: ignore[assignment]

    # 시드 추출 (쿼리 파라미터에서, 테스트/재현용)
    seed_param = request.query_params.get("seed")
    seed = int(seed_param) if seed_param else None

    # NDJSON 스트리밍 응답
    return StreamingResponse(
        _stream_turn_events(turn_input, seed=seed),
        media_type="application/x-ndjson",
        headers={
            "Cache-Control": "no-cache",
            "X-Accel-Buffering": "no",  # nginx 버퍼링 비활성화
            "X-Request-Time": str(int(time.time() * 1000)),
        },
    )
</file>

<file path="backend/src/unknown_world/models/scanner.py">
"""Unknown World - Scanner(이미지 이해) 스키마.

이 모듈은 이미지 업로드/분석 API의 요청/응답 스키마를 정의합니다.
사용자가 업로드한 이미지를 분석하여 "단서/아이템 후보"로 변환합니다.

설계 원칙:
    - RULE-004: 실패 시 안전한 폴백 (텍스트-only 캡션)
    - RULE-009: bbox는 0~1000 정규화 + [ymin, xmin, ymax, xmax]

페어링 질문 결정:
    - Q1: Option A (multipart 업로드로 처리, 단순)

참조:
    - vibe/unit-plans/U-021[Mvp].md
    - vibe/prd.md 8.6 (이미지 이해 요구)
    - .cursor/rules/00-core-critical.mdc (RULE-004, RULE-009)
"""

from enum import StrEnum

from pydantic import BaseModel, ConfigDict, Field

from unknown_world.models.turn import Box2D, Language


class ScanStatus(StrEnum):
    """스캔 상태.

    Attributes:
        COMPLETED: 분석 성공
        PARTIAL: 부분 성공 (일부 정보만 추출됨)
        FAILED: 분석 실패
        BLOCKED: 안전 정책에 의해 차단됨
    """

    COMPLETED = "completed"
    PARTIAL = "partial"
    FAILED = "failed"
    BLOCKED = "blocked"


class DetectedObject(BaseModel):
    """감지된 오브젝트.

    이미지에서 감지된 오브젝트 정보입니다.
    bbox는 0~1000 정규화 + [ymin, xmin, ymax, xmax] 규약을 준수합니다 (RULE-009).

    Attributes:
        label: 오브젝트 라벨 (예: "열쇠", "문", "상자")
        box_2d: 바운딩 박스 (0~1000 정규화)
        confidence: 신뢰도 (0.0~1.0, 선택)
        suggested_item_type: 추천 아이템 유형 (예: "key", "weapon", "clue")
    """

    model_config = ConfigDict(extra="forbid")

    label: str = Field(description="오브젝트 라벨")
    box_2d: Box2D = Field(description="바운딩 박스 (0~1000 정규화)")
    confidence: float | None = Field(
        default=None,
        ge=0.0,
        le=1.0,
        description="신뢰도 (0.0~1.0)",
    )
    suggested_item_type: str | None = Field(
        default=None,
        description="추천 아이템 유형 (예: key, weapon, clue)",
    )


class ItemCandidate(BaseModel):
    """아이템 후보.

    감지된 오브젝트를 기반으로 생성된 게임 아이템 후보입니다.

    Attributes:
        id: 아이템 후보 ID
        label: 아이템 이름
        description: 아이템 설명
        item_type: 아이템 유형 (예: "key", "weapon", "clue", "material")
        source_object_index: 원본 오브젝트 인덱스 (objects[] 기준)
    """

    model_config = ConfigDict(extra="forbid")

    id: str = Field(description="아이템 후보 ID")
    label: str = Field(description="아이템 이름")
    description: str = Field(default="", description="아이템 설명")
    item_type: str = Field(default="material", description="아이템 유형")
    source_object_index: int | None = Field(
        default=None,
        ge=0,
        description="원본 오브젝트 인덱스",
    )


class ScanResult(BaseModel):
    """스캔 결과.

    이미지 분석 결과 전체를 담는 모델입니다.

    Attributes:
        status: 스캔 상태
        caption: 이미지 전체 캡션
        objects: 감지된 오브젝트 목록
        item_candidates: 아이템 후보 목록
        message: 상태 메시지 (에러/경고 시)
        analysis_time_ms: 분석 소요 시간 (ms)
        original_image_key: 저장된 원본 이미지의 스토리지 키 (RU-006-S1)
        original_image_url: 저장된 원본 이미지의 접근 URL (RU-006-S1)
    """

    model_config = ConfigDict(extra="forbid")

    status: ScanStatus = Field(description="스캔 상태")
    caption: str = Field(default="", description="이미지 전체 캡션")
    objects: list[DetectedObject] = Field(
        default_factory=lambda: [],
        description="감지된 오브젝트 목록",
    )
    item_candidates: list[ItemCandidate] = Field(
        default_factory=lambda: [],
        description="아이템 후보 목록",
    )
    message: str | None = Field(default=None, description="상태 메시지")
    analysis_time_ms: int = Field(default=0, description="분석 소요 시간 (ms)")
    original_image_key: str | None = Field(
        default=None,
        description="저장된 원본 이미지의 스토리지 키 (선택적 저장 시)",
    )
    original_image_url: str | None = Field(
        default=None,
        description="저장된 원본 이미지의 접근 URL (선택적 저장 시)",
    )


class ScanRequest(BaseModel):
    """스캔 요청 (API 계층용).

    Attributes:
        language: 응답 언어 (캡션/라벨에 적용)
    """

    model_config = ConfigDict(extra="forbid")

    language: Language = Field(
        default=Language.KO,
        description="응답 언어 (캡션/라벨에 적용)",
    )


class ScanResponse(BaseModel):
    """스캔 응답 (API 계층용).

    Attributes:
        success: 성공 여부
        result: 스캔 결과
        language: 응답 언어
    """

    model_config = ConfigDict(extra="forbid")

    success: bool = Field(description="성공 여부")
    result: ScanResult = Field(description="스캔 결과")
    language: Language = Field(description="응답 언어")
</file>

<file path="backend/src/unknown_world/orchestrator/fallback.py">
"""Unknown World - 안전한 폴백 TurnOutput 생성기.

최종 복구 실패 시에도 UI가 빈 화면이 되지 않도록
스키마를 만족하는 안전한 TurnOutput을 생성합니다.

설계 원칙:
    - RULE-004: 검증 실패 시 안전한 폴백 제공
    - RULE-005: 재화 인바리언트 (비용 0, 잔액 유지)
    - RULE-006: ko/en 언어 정책 준수

참조:
    - vibe/unit-plans/U-018[Mvp].md
    - vibe/prd.md 8.7 (TurnOutput 스키마)
"""

from __future__ import annotations

from unknown_world.config.economy import LOW_BALANCE_THRESHOLD
from unknown_world.models.turn import (
    ActionCard,
    ActionDeck,
    AgentConsole,
    AgentPhase,
    CurrencyAmount,
    EconomyOutput,
    Language,
    RenderOutput,
    RiskLevel,
    SafetyOutput,
    TurnOutput,
    UIOutput,
    ValidationBadge,
    WorldDelta,
)

# =============================================================================
# 폴백 메시지 (i18n)
# =============================================================================

FALLBACK_MESSAGES = {
    Language.KO: {
        "narrative": "잠시 혼란스러운 순간이 지나갑니다. 다시 집중해봅시다.",
        "narrative_blocked": "안전 정책에 따라 이 요청을 처리할 수 없습니다. 다른 행동을 시도해보세요.",
        "alternative_label": "텍스트로 진행하기",
        "alternative_desc": "이미지 생성 없이 저비용으로 진행합니다",
    },
    Language.EN: {
        "narrative": "A moment of confusion passes. Let's focus again.",
        "narrative_blocked": "This request cannot be processed due to safety policies. Please try a different action.",
        "alternative_label": "Continue with text",
        "alternative_desc": "Proceed at low cost without image generation",
    },
}


# =============================================================================
# 폴백 생성 함수
# =============================================================================


def create_safe_fallback(
    language: Language,
    economy_snapshot: CurrencyAmount | None = None,
    repair_count: int = 0,
    is_blocked: bool = False,
) -> TurnOutput:
    """안전한 폴백 TurnOutput을 생성합니다.

    최종 복구 실패 시 사용합니다.
    스키마를 만족하고, 비용 0으로 잔액을 유지합니다.

    Args:
        language: 응답 언어
        economy_snapshot: 현재 재화 상태 (비용 0으로 유지)
        repair_count: 복구 시도 횟수
        is_blocked: 안전 정책에 의해 차단되었는지

    Returns:
        안전한 폴백 TurnOutput

    Example:
        >>> fallback = create_safe_fallback(
        ...     language=Language.KO,
        ...     economy_snapshot=CurrencyAmount(signal=50, memory_shard=3),
        ...     repair_count=2,
        ... )
        >>> print(fallback.narrative)
    """
    messages = FALLBACK_MESSAGES[language]

    # 내러티브 선택
    narrative = messages["narrative_blocked"] if is_blocked else messages["narrative"]

    # 재화 유지 (비용 0)
    balance = economy_snapshot or CurrencyAmount(signal=100, memory_shard=5)

    # 저비용 대안 카드 제공 (RULE-005)
    # U-065: description 필드 제거됨 (narrative에서 자연어로 표현)
    alternative_card = ActionCard(
        id="fallback_text_only",
        label=messages["alternative_label"],
        cost=CurrencyAmount(signal=1, memory_shard=0),
        risk=RiskLevel.LOW,
        enabled=True,
        is_alternative=True,
    )

    # 배지 결정 (RU-005-S1: 폴백에서도 모든 카테고리의 배지를 일관되게 설정)
    badges: list[ValidationBadge] = []

    # Schema: 폴백이므로 SCHEMA_FAIL (단, 안전 차단은 스키마 문제가 아님)
    if not is_blocked:
        badges.append(ValidationBadge.SCHEMA_FAIL)
    else:
        badges.append(ValidationBadge.SCHEMA_OK)

    # Economy: 폴백에서는 비용 0이므로 ECONOMY_OK
    badges.append(ValidationBadge.ECONOMY_OK)

    # Safety: is_blocked에 따라 결정
    if is_blocked:
        badges.append(ValidationBadge.SAFETY_BLOCKED)
    else:
        badges.append(ValidationBadge.SAFETY_OK)

    # Consistency: 폴백에서는 언어/좌표 문제가 없으므로 CONSISTENCY_OK
    badges.append(ValidationBadge.CONSISTENCY_OK)

    # U-079: 잔액 부족 경고 여부 결정
    is_low = balance.signal < LOW_BALANCE_THRESHOLD

    return TurnOutput(
        language=language,
        narrative=narrative,
        ui=UIOutput(
            action_deck=ActionDeck(cards=[alternative_card]),
            objects=[],
        ),
        world=WorldDelta(),
        render=RenderOutput(image_job=None),  # 이미지 생성 안 함
        economy=EconomyOutput(
            cost=CurrencyAmount(signal=0, memory_shard=0),
            balance_after=balance,
            credit=0,
            low_balance_warning=is_low,
        ),
        safety=SafetyOutput(
            blocked=is_blocked,
            message=messages["narrative_blocked"] if is_blocked else None,
        ),
        agent_console=AgentConsole(
            current_phase=AgentPhase.COMMIT,
            badges=badges,
            repair_count=repair_count,
        ),
    )
</file>

<file path="backend/src/unknown_world/orchestrator/pipeline.py">
"""Unknown World - Pipeline 실행기.

Stage 함수들을 체인으로 조합하여 실행하는 파이프라인입니다.

설계 원칙:
    - Option A (RU-005 Q1 결정): 함수 체인 방식, 클래스 도입 없음
    - 동작 보존: 기존 mock/real 경로의 결과(JSON) 의미 유지
    - 관측 가능성 SSOT: stage start/complete/fail, badges, repair를 일관되게 생성
    - 레이어링 보호: 오케스트레이터가 FastAPI에 직접 의존하지 않음
    - U-051: 이미지 생성 서비스 의존성 주입 (Option A: 매개변수 전달, 테스트 용이)

참조:
    - vibe/refactors/RU-005-Q4.md
    - vibe/refactors/RU-005-SUMMARY.md
    - vibe/unit-results/U-019[Mvp].md
"""

from __future__ import annotations

import os
from collections.abc import Sequence
from typing import TYPE_CHECKING, Any

from unknown_world.models.turn import CurrencyAmount, TurnInput
from unknown_world.orchestrator.conversation_history import (
    ConversationHistory,
    build_model_content_summary,
    get_conversation_history,
)
from unknown_world.orchestrator.fallback import create_safe_fallback
from unknown_world.orchestrator.stages.commit import commit_stage
from unknown_world.orchestrator.stages.parse import parse_stage
from unknown_world.orchestrator.stages.plan import plan_stage
from unknown_world.orchestrator.stages.render import render_stage
from unknown_world.orchestrator.stages.resolve import resolve_stage
from unknown_world.orchestrator.stages.types import (
    EmitFn,
    PipelineContext,
    StageFn,
)
from unknown_world.orchestrator.stages.validate import validate_stage
from unknown_world.orchestrator.stages.verify import verify_stage
from unknown_world.services.image_generation import get_image_generator

if TYPE_CHECKING:
    from unknown_world.services.image_generation import ImageGeneratorType

# =============================================================================
# 기본 Stage 순서 (PRD 기준)
# =============================================================================

DEFAULT_STAGES: Sequence[StageFn] = [
    parse_stage,
    validate_stage,
    plan_stage,
    resolve_stage,
    render_stage,
    verify_stage,
    commit_stage,
]
"""기본 파이프라인 단계 순서.

Parse → Validate → Plan → Resolve → Render → Verify → Commit
"""


# =============================================================================
# Pipeline 실행 함수
# =============================================================================


def _is_mock_mode() -> bool:
    """Mock 모드 여부를 확인합니다.

    UW_MODE 환경변수가 'mock'이면 Mock 모드로 동작합니다.
    기본값은 'mock'입니다 (MVP 단계).
    """
    return os.environ.get("UW_MODE", "mock").lower() == "mock"


def create_pipeline_context(
    turn_input: TurnInput,
    *,
    seed: int | None = None,
    is_mock: bool | None = None,
    image_generator: ImageGeneratorType | None = None,
    session_id: str | None = None,
) -> PipelineContext:
    """파이프라인 컨텍스트를 생성합니다.

    U-127: 세션별 대화 히스토리를 자동으로 주입합니다.

    Args:
        turn_input: 사용자 턴 입력
        seed: Mock 모드 시드 (재현성 보장)
        is_mock: Mock 모드 여부 (None이면 환경변수 기준)
        image_generator: 이미지 생성 서비스 인스턴스 (U-051)
            None이면 render_stage에서 이미지 생성을 건너뜁니다 (기존 동작 보존).
            테스트 시 MockImageGenerator를 주입하여 모킹 가능합니다.
        session_id: 세션 ID (U-127, None이면 "default" 사용)

    Returns:
        초기화된 파이프라인 컨텍스트

    Example:
        >>> # 기본 사용 (이미지 생성 없음, 기본 세션)
        >>> ctx = create_pipeline_context(turn_input)
        >>>
        >>> # 이미지 생성 서비스 주입
        >>> from unknown_world.services.image_generation import get_image_generator
        >>> generator = get_image_generator()
        >>> ctx = create_pipeline_context(turn_input, image_generator=generator)
    """
    economy_snapshot = CurrencyAmount(
        signal=turn_input.economy_snapshot.signal,
        memory_shard=turn_input.economy_snapshot.memory_shard,
    )

    is_mock = is_mock if is_mock is not None else _is_mock_mode()

    # 이미지 생성기 자동 획득 (U-051)
    if image_generator is None:
        image_generator = get_image_generator(force_mock=is_mock)

    # U-127: 대화 히스토리 자동 주입
    conversation_history: ConversationHistory | None = None
    if not is_mock:
        # Real 모드에서만 히스토리 활성화
        conversation_history = get_conversation_history(session_id or "default")

    return PipelineContext(
        turn_input=turn_input,
        economy_snapshot=economy_snapshot,
        is_mock=is_mock,
        seed=seed,
        image_generator=image_generator,
        conversation_history=conversation_history,
    )


async def run_pipeline(
    ctx: PipelineContext,
    *,
    emit: EmitFn,
    stages: Sequence[StageFn] | None = None,
) -> PipelineContext:
    """파이프라인을 실행합니다.

    Stage 함수들을 순서대로 실행하고, 각 단계에서 emit 콜백을 통해
    도메인 이벤트를 전달합니다.

    예외가 발생하면 안전한 폴백으로 종료합니다 (RULE-004).

    Args:
        ctx: 파이프라인 컨텍스트
        emit: 이벤트 emit 콜백
        stages: 실행할 stage 목록 (None이면 기본 순서)

    Returns:
        최종 파이프라인 컨텍스트

    Example:
        >>> ctx = create_pipeline_context(turn_input, seed=42)
        >>> ctx = await run_pipeline(ctx, emit=my_emit_fn)
        >>> print(ctx.output.narrative)
    """
    if stages is None:
        stages = DEFAULT_STAGES

    try:
        for stage in stages:
            ctx = await stage(ctx, emit=emit)

            # output이 None이면 validate 실패 등 → 이후 단계는 스킵
            # (단, parse 단계는 output이 없어도 정상)
            if ctx.output is None and stage != parse_stage:
                # 폴백 생성
                ctx.output = create_safe_fallback(
                    language=ctx.turn_input.language,
                    economy_snapshot=ctx.economy_snapshot,
                    repair_count=ctx.repair_attempts,
                )
                ctx.is_fallback = True
                break

    except Exception:
        # 예외 발생 시 안전한 폴백 (RULE-004)
        ctx.output = create_safe_fallback(
            language=ctx.turn_input.language,
            economy_snapshot=ctx.economy_snapshot,
            repair_count=ctx.repair_attempts,
        )
        ctx.is_fallback = True

    # U-127: 턴 완료 후 대화 히스토리에 추가
    _update_conversation_history(ctx)

    return ctx


def _update_conversation_history(ctx: PipelineContext) -> None:
    """턴 완료 후 대화 히스토리를 업데이트합니다 (U-127).

    성공/폴백에 관계없이 히스토리에 턴을 기록합니다.
    폴백 시에도 사용자의 입력은 기록하여 맥락을 유지합니다.

    Args:
        ctx: 파이프라인 컨텍스트
    """
    if ctx.conversation_history is None or ctx.output is None:
        return

    # 사용자 입력 요약
    user_content = ctx.turn_input.text
    if ctx.turn_input.action_id:
        user_content = f"[{ctx.turn_input.action_id}] {user_content}"

    # 모델 응답 요약 (Option C: 내러티브 + 핵심 상태 변화)
    # 세계 변화(delta)를 추출하여 요약
    world_delta: dict[str, Any] | None = None
    wd = ctx.output.world
    if wd:
        world_delta_dict: dict[str, Any] = {}
        if wd.inventory_added:
            world_delta_dict["inventory_added"] = [
                {"label": item.label} for item in wd.inventory_added
            ]
        if wd.inventory_removed:
            world_delta_dict["inventory_removed"] = wd.inventory_removed
        if wd.rules_changed:
            world_delta_dict["rules_added"] = [r.label for r in wd.rules_changed]
        if world_delta_dict:
            world_delta = world_delta_dict

    model_content = build_model_content_summary(
        narrative=ctx.output.narrative,
        world_delta=world_delta,
    )

    ctx.conversation_history.add_turn(
        user_content=user_content,
        model_content=model_content,
        thought_signature=ctx.thought_signature,
    )
</file>

<file path="backend/src/unknown_world/services/agentic_vision.py">
"""Unknown World - Agentic Vision 서비스 (U-076[Mvp]).

"정밀분석" 액션 실행 시 기존 Scene 이미지에서 affordances(오브젝트 후보)를
추출하는 서비스입니다.

gemini-3-flash-preview + code_execution 도구를 활용하여 이미지 내
클릭 가능한 오브젝트(핫스팟)를 구조화된 형식으로 반환합니다.

설계 원칙:
    - RULE-004: 실패 시 빈 배열 반환 (안전한 폴백)
    - RULE-007/008: 프롬프트 원문/비밀정보 노출 금지
    - RULE-009: bbox 0~1000 정규화, [ymin, xmin, ymax, xmax]
    - U-076 Q2: 비전 분석 비용 1.5x

참조:
    - vibe/unit-plans/U-076[Mvp].md
    - vibe/tech-stack.md (비전 모델: gemini-3-flash-preview)
    - vibe/ref/gemini-api-guide.md (Structured Outputs with tools)
"""

from __future__ import annotations

import json
import logging
import os
import time
from dataclasses import dataclass, field
from pathlib import Path
from typing import TYPE_CHECKING, Any, cast

from unknown_world.config.models import ModelLabel, get_model_id
from unknown_world.models.turn import Box2D, Language, SceneObject
from unknown_world.services.genai_client import ENV_UW_MODE, GenAIMode
from unknown_world.storage.validation import BBOX_MAX, BBOX_MIN

if TYPE_CHECKING:
    from google.genai import Client

# =============================================================================
# 로거 설정 (프롬프트/비밀정보 노출 금지 - RULE-007/008)
# =============================================================================

logger = logging.getLogger(__name__)

# =============================================================================
# 프롬프트 로딩
# =============================================================================

# 프롬프트 파일 디렉토리
_PROMPTS_DIR = Path(__file__).resolve().parent.parent.parent.parent / "prompts" / "vision"


def _load_prompt(language: Language) -> str:
    """비전 프롬프트를 파일에서 로드합니다.

    Args:
        language: 요청 언어

    Returns:
        프롬프트 텍스트

    Raises:
        FileNotFoundError: 프롬프트 파일이 없을 때
    """
    lang_suffix = "ko" if language == Language.KO else "en"
    prompt_path = _PROMPTS_DIR / f"scene_affordances.{lang_suffix}.md"

    if not prompt_path.exists():
        # 폴백: 한국어 프롬프트 시도
        fallback_path = _PROMPTS_DIR / "scene_affordances.ko.md"
        if fallback_path.exists():
            prompt_path = fallback_path
        else:
            raise FileNotFoundError(f"Vision prompt not found: {prompt_path}")

    return prompt_path.read_text(encoding="utf-8")


# =============================================================================
# Affordance 데이터 타입
# =============================================================================


@dataclass
class Affordance:
    """이미지에서 추출된 오브젝트 후보 (affordance).

    Attributes:
        label: 오브젝트 이름 (세션 언어에 맞게)
        box_2d: 바운딩 박스 (0~1000 정규화, [ymin, xmin, ymax, xmax])
        interaction_hint: 상호작용 힌트 (선택)
    """

    label: str
    box_2d: Box2D
    interaction_hint: str | None = None


@dataclass
class VisionAnalysisResult:
    """비전 분석 결과.

    Attributes:
        affordances: 추출된 affordances 목록
        analysis_time_ms: 분석 소요 시간 (밀리초)
        success: 분석 성공 여부
        message: 상태/에러 메시지 (내부용, UI 노출 금지)
    """

    affordances: list[Affordance] = field(default_factory=lambda: cast(list["Affordance"], []))
    analysis_time_ms: int = 0
    success: bool = True
    message: str = ""


# =============================================================================
# bbox 정규화 유틸리티
# =============================================================================


def _normalize_bbox(bbox_raw: dict[str, Any]) -> Box2D | None:
    """bbox를 0~1000 범위로 정규화합니다.

    Args:
        bbox_raw: 원본 bbox dict

    Returns:
        정규화된 Box2D 또는 None (유효하지 않은 경우)
    """
    try:
        ymin_val = int(bbox_raw.get("ymin", 0) or 0)
        xmin_val = int(bbox_raw.get("xmin", 0) or 0)
        ymax_val = int(bbox_raw.get("ymax", BBOX_MAX) or BBOX_MAX)
        xmax_val = int(bbox_raw.get("xmax", BBOX_MAX) or BBOX_MAX)

        # 범위 클램핑 (RULE-009)
        ymin_val = max(BBOX_MIN, min(BBOX_MAX, ymin_val))
        xmin_val = max(BBOX_MIN, min(BBOX_MAX, xmin_val))
        ymax_val = max(BBOX_MIN, min(BBOX_MAX, ymax_val))
        xmax_val = max(BBOX_MIN, min(BBOX_MAX, xmax_val))

        # ymin < ymax, xmin < xmax 보장
        if ymin_val >= ymax_val:
            ymax_val = min(ymin_val + 100, BBOX_MAX)
        if xmin_val >= xmax_val:
            xmax_val = min(xmin_val + 100, BBOX_MAX)

        return Box2D(ymin=ymin_val, xmin=xmin_val, ymax=ymax_val, xmax=xmax_val)
    except (ValueError, TypeError):
        return None


# =============================================================================
# Mock 서비스
# =============================================================================


def _create_mock_result(language: Language) -> VisionAnalysisResult:
    """Mock 분석 결과를 생성합니다.

    Args:
        language: 응답 언어

    Returns:
        고정된 Mock 분석 결과
    """
    if language == Language.KO:
        affordances = [
            Affordance(
                label="낡은 문",
                box_2d=Box2D(ymin=100, xmin=50, ymax=800, xmax=450),
                interaction_hint="열어볼 수 있을 것 같다",
            ),
            Affordance(
                label="벽에 걸린 횃불",
                box_2d=Box2D(ymin=50, xmin=600, ymax=400, xmax=750),
                interaction_hint="가져갈 수 있을 것 같다",
            ),
            Affordance(
                label="바닥의 금이 간 타일",
                box_2d=Box2D(ymin=700, xmin=200, ymax=900, xmax=600),
                interaction_hint="무언가 숨겨져 있을 수 있다",
            ),
        ]
    else:
        affordances = [
            Affordance(
                label="Old Door",
                box_2d=Box2D(ymin=100, xmin=50, ymax=800, xmax=450),
                interaction_hint="Looks like it can be opened",
            ),
            Affordance(
                label="Wall Torch",
                box_2d=Box2D(ymin=50, xmin=600, ymax=400, xmax=750),
                interaction_hint="Could be taken",
            ),
            Affordance(
                label="Cracked Floor Tile",
                box_2d=Box2D(ymin=700, xmin=200, ymax=900, xmax=600),
                interaction_hint="Something might be hidden underneath",
            ),
        ]

    return VisionAnalysisResult(
        affordances=affordances,
        analysis_time_ms=250,
        success=True,
        message="mock",
    )


# =============================================================================
# 응답 파싱
# =============================================================================


def _parse_vision_response(
    response_text: str,
    language: Language,
) -> VisionAnalysisResult:
    """비전 모델 응답을 파싱합니다.

    Args:
        response_text: 모델 응답 텍스트 (JSON 예상)
        language: 응답 언어

    Returns:
        파싱된 VisionAnalysisResult
    """
    try:
        # 마크다운 코드블록 제거
        text = response_text.strip()
        if text.startswith("```"):
            lines = text.split("\n")
            if lines[0].startswith("```"):
                lines = lines[1:]
            if lines and lines[-1].strip() == "```":
                lines = lines[:-1]
            text = "\n".join(lines)

        parsed = json.loads(text)

        # 이중 직렬화 처리
        if isinstance(parsed, str):
            parsed = json.loads(parsed)

        if not isinstance(parsed, dict):
            raise ValueError(f"Expected dict, got {type(parsed).__name__}")

        data = cast(dict[str, Any], parsed)

        # affordances 추출
        affordances: list[Affordance] = []
        raw_affordances: list[dict[str, Any]] = data.get("affordances") or []  # type: ignore[assignment]

        for i, aff in enumerate(raw_affordances[:5]):  # 최대 5개 (SceneObject max_length)
            if not isinstance(aff, dict):  # type: ignore[reportUnnecessaryIsInstance]
                continue

            label_val = aff.get("label")
            label: str = str(label_val) if label_val else f"Object_{i}"

            bbox_raw: dict[str, Any] = aff.get("box_2d") or {}  # type: ignore[assignment]
            bbox = _normalize_bbox(bbox_raw)
            if bbox is None:
                logger.warning(
                    "[AgenticVision] bbox 정규화 실패, 오브젝트 스킵",
                    extra={"index": i, "label": label},
                )
                continue

            hint_val = aff.get("interaction_hint")
            hint: str | None = str(hint_val) if hint_val else None

            affordances.append(
                Affordance(
                    label=label,
                    box_2d=bbox,
                    interaction_hint=hint,
                )
            )

        return VisionAnalysisResult(
            affordances=affordances,
            success=True,
            message="ok",
        )

    except (json.JSONDecodeError, ValueError) as e:
        logger.warning(
            "[AgenticVision] JSON 파싱 실패",
            extra={"error": str(e), "error_type": type(e).__name__},
        )
        return VisionAnalysisResult(
            affordances=[],
            success=False,
            message=f"parse_error: {type(e).__name__}",
        )
    except Exception as e:
        logger.error(
            "[AgenticVision] 응답 파싱 중 예외",
            extra={"error_type": type(e).__name__},
        )
        return VisionAnalysisResult(
            affordances=[],
            success=False,
            message=f"unexpected_error: {type(e).__name__}",
        )


# =============================================================================
# Affordance → SceneObject 변환
# =============================================================================


def affordances_to_scene_objects(
    affordances: list[Affordance],
    id_prefix: str = "vision",
) -> list[SceneObject]:
    """Affordances를 SceneObject 목록으로 변환합니다.

    Args:
        affordances: 추출된 affordances
        id_prefix: 오브젝트 ID 접두사

    Returns:
        SceneObject 목록
    """
    objects: list[SceneObject] = []
    for i, aff in enumerate(affordances):
        obj = SceneObject(
            id=f"{id_prefix}_{i}",
            label=aff.label,
            box_2d=aff.box_2d,
            interaction_hint=aff.interaction_hint,
        )
        objects.append(obj)
    return objects


# =============================================================================
# Agentic Vision 서비스
# =============================================================================


class AgenticVisionService:
    """Agentic Vision 서비스 (U-076[Mvp]).

    Scene 이미지에서 affordances(오브젝트 후보)를 추출하는
    gemini-3-flash-preview + code_execution 기반 서비스입니다.
    """

    def __init__(
        self,
        *,
        force_mock: bool = False,
    ) -> None:
        """AgenticVisionService를 초기화합니다.

        Args:
            force_mock: True면 Mock 모드 강제
        """
        if force_mock:
            self._is_mock = True
        else:
            mode_str = os.environ.get(ENV_UW_MODE, GenAIMode.REAL)
            self._is_mock = mode_str == GenAIMode.MOCK

        self._genai_client: Client | None = None

        if not self._is_mock:
            self._initialize_client()

        logger.info(
            "[AgenticVision] 서비스 초기화",
            extra={"mode": "mock" if self._is_mock else "real"},
        )

    def _initialize_client(self) -> None:
        """google-genai 클라이언트를 초기화합니다."""
        try:
            from google.genai import Client

            api_key = os.environ.get("GOOGLE_API_KEY")
            if not api_key:
                logger.warning(
                    "[AgenticVision] GOOGLE_API_KEY 미설정 - Mock 모드로 전환",
                )
                self._is_mock = True
                self._genai_client = None
                return

            self._genai_client = Client(api_key=api_key)
            self._is_mock = False

            logger.info(
                "[AgenticVision] API 키 클라이언트 초기화 완료",
                extra={"auth": "api_key"},
            )
        except Exception as e:
            logger.warning(
                "[AgenticVision] 클라이언트 초기화 실패 - Mock 모드로 전환",
                extra={"error_type": type(e).__name__},
            )
            self._is_mock = True
            self._genai_client = None

    @property
    def is_mock(self) -> bool:
        """Mock 모드 여부."""
        return self._is_mock

    async def analyze_scene(
        self,
        image_url: str,
        language: Language = Language.KO,
    ) -> VisionAnalysisResult:
        """Scene 이미지에서 affordances(오브젝트 후보)를 추출합니다.

        Args:
            image_url: Scene 이미지 URL (로컬 경로 또는 HTTP URL)
            language: 세션 언어

        Returns:
            VisionAnalysisResult: 분석 결과
        """
        start_time = time.time()

        logger.info(
            "[AgenticVision] 분석 시작",
            extra={
                "language": language.value,
                "has_image_url": bool(image_url),
            },
        )

        # Mock 모드
        if self._is_mock:
            logger.debug("[AgenticVision] Mock 분석 수행")
            result = _create_mock_result(language)
            result.analysis_time_ms = int((time.time() - start_time) * 1000)
            return result

        # 이미지 읽기
        image_bytes = self._load_image(image_url)
        if image_bytes is None:
            logger.warning(
                "[AgenticVision] 이미지 로드 실패, 빈 결과 반환",
                extra={"image_url_prefix": image_url[:50] if image_url else ""},
            )
            return VisionAnalysisResult(
                affordances=[],
                analysis_time_ms=int((time.time() - start_time) * 1000),
                success=False,
                message="image_load_failed",
            )

        # 실제 비전 모델 호출
        try:
            result = await self._call_vision_model(image_bytes, language)
            result.analysis_time_ms = int((time.time() - start_time) * 1000)

            logger.info(
                "[AgenticVision] 분석 완료",
                extra={
                    "affordance_count": len(result.affordances),
                    "analysis_time_ms": result.analysis_time_ms,
                    "success": result.success,
                },
            )

            return result

        except Exception as e:
            error_type = type(e).__name__
            logger.error(
                "[AgenticVision] 비전 모델 호출 실패",
                extra={"error_type": error_type},
            )
            return VisionAnalysisResult(
                affordances=[],
                analysis_time_ms=int((time.time() - start_time) * 1000),
                success=False,
                message=f"vision_error: {error_type}",
            )

    def _load_image(self, image_url: str) -> bytes | None:
        """이미지 URL에서 바이트 데이터를 로드합니다.

        로컬 경로와 HTTP URL 모두 지원합니다.

        Args:
            image_url: 이미지 경로/URL

        Returns:
            이미지 바이트 데이터 또는 None
        """
        try:
            # 로컬 파일 경로 처리
            if image_url.startswith("/static/"):
                # /static/ prefix 제거 → .data/ 내부 상대경로
                # 예: /static/images/generated/img_xxx.png → images/generated/img_xxx.png
                relative_path = image_url[len("/static/") :]

                # backend 루트 디렉토리
                base_dir = Path(__file__).resolve().parent.parent.parent.parent

                # 1) .data/ 디렉토리에서 찾기 (현재 스토리지)
                from unknown_world.storage.paths import BASE_DATA_DIR

                data_path = base_dir / str(BASE_DATA_DIR) / relative_path
                if data_path.exists():
                    return data_path.read_bytes()

                # 2) 레거시: generated_images/ 폴백
                filename = Path(image_url).name
                legacy_dir = base_dir / "generated_images"
                if legacy_dir.exists():
                    candidate = legacy_dir / filename
                    if candidate.exists():
                        return candidate.read_bytes()

                logger.warning(
                    "[AgenticVision] 로컬 이미지 파일 미존재",
                    extra={"path_prefix": str(data_path)[:80]},
                )
                return None

            elif image_url.startswith(("http://", "https://")):
                # HTTP URL의 경우 - MVP에서는 로컬 파일만 지원
                # 원격 URL은 MMP에서 구현 예정
                logger.warning(
                    "[AgenticVision] HTTP URL은 현재 미지원",
                )
                return None
            else:
                # 절대/상대 경로 시도
                path = Path(image_url)
                if path.exists():
                    return path.read_bytes()
                return None
        except Exception as e:
            logger.warning(
                "[AgenticVision] 이미지 로드 실패",
                extra={"error_type": type(e).__name__},
            )
            return None

    async def _call_vision_model(
        self,
        image_bytes: bytes,
        language: Language,
    ) -> VisionAnalysisResult:
        """비전 모델을 호출합니다.

        gemini-3-flash-preview + code_execution 활성화

        Args:
            image_bytes: 이미지 바이트 데이터
            language: 세션 언어

        Returns:
            VisionAnalysisResult
        """
        if self._genai_client is None:
            return VisionAnalysisResult(
                affordances=[],
                success=False,
                message="client_not_initialized",
            )

        # 프롬프트 로드
        try:
            prompt_text = _load_prompt(language)
        except FileNotFoundError:
            logger.warning("[AgenticVision] 프롬프트 파일 미존재, 인라인 폴백 사용")
            prompt_text = self._get_inline_prompt(language)

        # 모델 ID 조회
        model_id = get_model_id(ModelLabel.VISION)

        logger.debug(
            "[AgenticVision] 비전 모델 호출",
            extra={
                "model_id": model_id,
                "language": language.value,
                "image_size_kb": len(image_bytes) // 1024,
            },
        )

        # google-genai SDK 호출
        from google.genai.types import GenerateContentConfig, Part, Tool, ToolCodeExecution

        # 멀티모달 입력 (이미지 + 텍스트)
        contents = [
            Part.from_bytes(
                data=image_bytes,
                mime_type="image/png",
            ),
            Part.from_text(text=prompt_text),
        ]

        # Structured Outputs + code_execution (Gemini 3 지원)
        config = GenerateContentConfig(
            response_mime_type="application/json",
            max_output_tokens=4096,
            tools=[Tool(code_execution=ToolCodeExecution())],
        )

        response = await self._genai_client.aio.models.generate_content(  # type: ignore[reportUnknownMemberType]
            model=model_id,
            contents=contents,  # type: ignore[reportArgumentType]
            config=config,
        )

        # 응답 텍스트 추출
        response_text: str = ""
        if hasattr(response, "text") and response.text:
            response_text = str(response.text)
        else:
            response_text = str(response)

        if not response_text:
            return VisionAnalysisResult(
                affordances=[],
                success=False,
                message="empty_response",
            )

        return _parse_vision_response(response_text, language)

    def _get_inline_prompt(self, language: Language) -> str:
        """인라인 폴백 프롬프트를 반환합니다.

        프롬프트 파일이 없을 때 사용하는 최소 프롬프트입니다.

        Args:
            language: 세션 언어

        Returns:
            프롬프트 텍스트
        """
        if language == Language.KO:
            return (
                "이 이미지에서 클릭 가능한 오브젝트를 찾아 JSON으로 반환하세요.\n"
                '출력: {"affordances": [{"label": "이름", "box_2d": {"ymin": 0, "xmin": 0, "ymax": 1000, "xmax": 1000}, "interaction_hint": "힌트"}]}\n'
                "좌표는 0~1000 정규화, bbox=[ymin,xmin,ymax,xmax]. 최대 5개."
            )
        return (
            "Find clickable objects in this image and return as JSON.\n"
            'Output: {"affordances": [{"label": "name", "box_2d": {"ymin": 0, "xmin": 0, "ymax": 1000, "xmax": 1000}, "interaction_hint": "hint"}]}\n'
            "Coordinates: 0~1000 normalized, bbox=[ymin,xmin,ymax,xmax]. Max 5."
        )


# =============================================================================
# 팩토리 함수
# =============================================================================

_service_instance: AgenticVisionService | None = None


def get_agentic_vision_service(
    *,
    force_new: bool = False,
) -> AgenticVisionService:
    """AgenticVisionService 인스턴스를 반환합니다.

    싱글톤 패턴으로 동작합니다.

    Args:
        force_new: True면 캐시를 무시하고 새 인스턴스 생성

    Returns:
        AgenticVisionService 인스턴스
    """
    global _service_instance

    if not force_new and _service_instance is not None:
        return _service_instance

    _service_instance = AgenticVisionService()
    return _service_instance


def reset_agentic_vision_service() -> None:
    """AgenticVisionService 캐시를 초기화합니다."""
    global _service_instance
    _service_instance = None
</file>

<file path="backend/src/unknown_world/storage/local_storage.py">
"""Unknown World - 로컬 파일 시스템 스토리지 구현.

MVP 단계에서 사용하는 로컬 저장소 구현체.
페어링 질문 Q1: Option A (backend/.data/ 전용 폴더)

참조:
    - vibe/refactors/RU-006-Q4.md
    - vibe/refactors/RU-006-Q5.md
"""

from __future__ import annotations

import logging
import uuid
from datetime import UTC, datetime
from pathlib import Path

from unknown_world.storage.paths import (
    ARTIFACTS_SUBDIR,
    BASE_DATA_DIR,
    IMAGES_GENERATED_SUBDIR,
    IMAGES_UPLOADED_SUBDIR,
    STATIC_URL_PREFIX,
)
from unknown_world.storage.storage import (
    PutResult,
    StorageCategory,
    StorageInterface,
    StorageMetadata,
)

logger = logging.getLogger(__name__)

# 카테고리별 서브디렉토리 매핑 (RU-006-Q5: paths.py 상수 참조)
CATEGORY_DIRS: dict[StorageCategory, str] = {
    StorageCategory.GENERATED_IMAGE: IMAGES_GENERATED_SUBDIR,
    StorageCategory.UPLOADED_IMAGE: IMAGES_UPLOADED_SUBDIR,
    StorageCategory.ARTIFACT: ARTIFACTS_SUBDIR,
}


class LocalStorage(StorageInterface):
    """로컬 파일 시스템 스토리지.

    MVP에서 사용하는 로컬 저장소 구현체.
    """

    def __init__(self, base_dir: Path | None = None) -> None:
        """LocalStorage를 초기화합니다.

        Args:
            base_dir: 기본 저장 디렉토리 (기본값: .data)
        """
        self._base_dir = base_dir or BASE_DATA_DIR
        self._ensure_directories()

        logger.info(
            "[LocalStorage] 초기화 완료",
            extra={"base_dir": str(self._base_dir)},
        )

    def _ensure_directories(self) -> None:
        """카테고리별 디렉토리를 생성합니다."""
        for subdir in CATEGORY_DIRS.values():
            dir_path = self._base_dir / subdir
            dir_path.mkdir(parents=True, exist_ok=True)

    def _get_category_dir(self, category: StorageCategory) -> Path:
        """카테고리에 해당하는 디렉토리 경로를 반환합니다."""
        subdir = CATEGORY_DIRS.get(category, "misc")
        return self._base_dir / subdir

    def _generate_key(
        self,
        category: StorageCategory,
        file_id: str | None,
        extension: str = "png",
    ) -> str:
        """스토리지 키를 생성합니다."""
        actual_id = file_id or f"file_{uuid.uuid4().hex[:12]}"
        subdir = CATEGORY_DIRS.get(category, "misc")
        return f"{subdir}/{actual_id}.{extension}"

    async def put(
        self,
        data: bytes,
        *,
        category: StorageCategory,
        content_type: str = "image/png",
        file_id: str | None = None,
        session_id: str | None = None,
    ) -> PutResult:
        """파일을 저장합니다."""
        try:
            # 확장자 추출
            ext_map = {
                "image/png": "png",
                "image/jpeg": "jpg",
                "image/gif": "gif",
                "image/webp": "webp",
                "application/json": "json",
            }
            extension = ext_map.get(content_type, "bin")

            # 키 및 경로 생성
            key = self._generate_key(category, file_id, extension)
            file_path = self._base_dir / key
            file_path.parent.mkdir(parents=True, exist_ok=True)

            # 파일 저장
            file_path.write_bytes(data)

            # URL 생성
            url = self.get_url(key)

            # 메타데이터 생성
            metadata = StorageMetadata(
                key=key,
                category=category,
                size_bytes=len(data),
                content_type=content_type,
                created_at=datetime.now(UTC),
                url=url,
                session_id=session_id,
            )

            logger.debug(
                "[LocalStorage] 파일 저장 완료",
                extra={
                    "key": key,
                    "size_bytes": len(data),
                    "category": category.value,
                },
            )

            return PutResult(
                success=True,
                key=key,
                url=url,
                metadata=metadata,
            )

        except Exception as e:
            error_msg = f"파일 저장 실패: {type(e).__name__}"
            logger.error(
                "[LocalStorage] 저장 실패",
                extra={"error_type": type(e).__name__},
            )
            return PutResult(
                success=False,
                key="",
                url="",
                error=error_msg,
            )

    async def get(self, key: str) -> bytes | None:
        """파일을 조회합니다."""
        file_path = self._base_dir / key
        if not file_path.exists():
            return None
        return file_path.read_bytes()

    async def exists(self, key: str) -> bool:
        """파일 존재 여부를 확인합니다."""
        file_path = self._base_dir / key
        return file_path.exists()

    async def delete(self, key: str) -> bool:
        """파일을 삭제합니다."""
        file_path = self._base_dir / key
        if not file_path.exists():
            return False
        file_path.unlink()
        return True

    def get_url(self, key: str) -> str:
        """파일 접근 URL을 반환합니다."""
        # 로컬 환경에서는 /static 프리픽스로 서빙
        return f"{STATIC_URL_PREFIX}/{key}"

    @property
    def base_dir(self) -> Path:
        """기본 저장 디렉토리."""
        return self._base_dir
</file>

<file path="backend/src/unknown_world/validation/business_rules.py">
"""Unknown World - 비즈니스 룰 검증기 (Hard Gate).

스키마 검증 이후에도 남는 "의미적 실패"를 검증합니다:
- Economy: cost/balance_after 일관성, 잔액 음수 금지
- Language: TurnInput.language와 TurnOutput.language 불일치 차단
- Box2D: 0~1000 범위 + [ymin,xmin,ymax,xmax] 순서 검증
- Safety: blocked 시 안전한 대체 결과 제공 확인

설계 원칙:
    - RULE-003: 구조화 출력(JSON Schema) 우선 + 이중 검증
    - RULE-004: 검증 실패 시 Repair loop + 안전한 폴백
    - RULE-005: 재화 인바리언트 (잔액 음수 금지)
    - RULE-006: ko/en 언어 정책 준수
    - RULE-009: 좌표 규약 (0~1000, bbox [ymin,xmin,ymax,xmax])

참조:
    - vibe/unit-plans/U-018[Mvp].md
    - vibe/unit-results/U-017[Mvp].md
"""

from __future__ import annotations

import logging
from dataclasses import dataclass, field
from enum import StrEnum
from typing import TYPE_CHECKING

from unknown_world.config.economy import MAX_CREDIT
from unknown_world.models.turn import Language
from unknown_world.validation.language_gate import (
    LanguageGateResult,
    build_language_error_summary,
    validate_language_consistency,
)

if TYPE_CHECKING:
    from unknown_world.models.turn import TurnInput, TurnOutput

# =============================================================================
# 로거 설정
# =============================================================================

logger = logging.getLogger(__name__)


# =============================================================================
# i18n 에러 메시지 (RULE-006: ko/en 언어 정책 준수)
# =============================================================================

BUSINESS_RULE_MESSAGES: dict[Language, dict[str, str]] = {
    Language.KO: {
        "summary_header": "다음 비즈니스 룰을 위반했습니다:",
        "signal_insufficient": "Signal 재화가 부족합니다: 보유 {have}, 필요 {need}",
        "memory_shard_insufficient": "Memory Shard 재화가 부족합니다: 보유 {have}, 필요 {need}",
        "signal_negative": "Signal 잔액이 음수입니다: {value}",
        "memory_shard_negative": "Memory Shard 잔액이 음수입니다: {value}",
        "signal_mismatch": "Signal 잔액 불일치: 예상 {expected}, 실제 {actual}",
        "memory_shard_mismatch": "Memory Shard 잔액 불일치: 예상 {expected}, 실제 {actual}",
        "language_mismatch": "언어 불일치: 입력 {input_lang}, 출력 {output_lang}",
        "language_content_mixed": "언어 혼합 감지: {violation_count}개 필드에서 ko/en 혼합 발견",
        "box2d_out_of_range": "오브젝트 '{obj_id}'의 좌표가 범위를 벗어남: {coord}",
        "box2d_invalid_yorder": "오브젝트 '{obj_id}'의 ymin({ymin}) >= ymax({ymax})",
        "box2d_invalid_xorder": "오브젝트 '{obj_id}'의 xmin({xmin}) >= xmax({xmax})",
        "safety_blocked_no_fallback": "안전 정책에 의해 차단되었지만 대체 텍스트가 없습니다",
    },
    Language.EN: {
        "summary_header": "The following business rules were violated:",
        "signal_insufficient": "Insufficient Signal: have {have}, need {need}",
        "memory_shard_insufficient": "Insufficient Memory Shard: have {have}, need {need}",
        "signal_negative": "Signal balance is negative: {value}",
        "memory_shard_negative": "Memory Shard balance is negative: {value}",
        "signal_mismatch": "Signal balance mismatch: expected {expected}, actual {actual}",
        "memory_shard_mismatch": "Memory Shard balance mismatch: expected {expected}, actual {actual}",
        "language_mismatch": "Language mismatch: input {input_lang}, output {output_lang}",
        "language_content_mixed": "Language mixing detected: {violation_count} fields contain ko/en mixing",
        "box2d_out_of_range": "Object '{obj_id}' coordinate out of range: {coord}",
        "box2d_invalid_yorder": "Object '{obj_id}' ymin({ymin}) >= ymax({ymax})",
        "box2d_invalid_xorder": "Object '{obj_id}' xmin({xmin}) >= xmax({xmax})",
        "safety_blocked_no_fallback": "Blocked by safety policy but no fallback text provided",
    },
}


# =============================================================================
# 에러 타입
# =============================================================================


class BusinessRuleError(StrEnum):
    """비즈니스 룰 위반 타입."""

    # Economy 규칙 (RULE-005)
    ECONOMY_NEGATIVE_BALANCE = "economy_negative_balance"
    """잔액이 음수입니다 (금지)"""

    ECONOMY_COST_MISMATCH = "economy_cost_mismatch"
    """비용과 잔액 변화가 일치하지 않습니다"""

    ECONOMY_COST_MISSING = "economy_cost_missing"
    """비용 정보가 누락되었습니다"""

    # Language 규칙 (RULE-006)
    LANGUAGE_MISMATCH = "language_mismatch"
    """입력과 출력 언어가 일치하지 않습니다"""

    LANGUAGE_CONTENT_MIXED = "language_content_mixed"
    """사용자 노출 텍스트에 ko/en이 혼합되어 있습니다 (U-043)"""

    # Box2D 규칙 (RULE-009)
    BOX2D_OUT_OF_RANGE = "box2d_out_of_range"
    """좌표가 0~1000 범위를 벗어났습니다"""

    BOX2D_INVALID_ORDER = "box2d_invalid_order"
    """bbox 순서가 올바르지 않습니다 (ymin < ymax, xmin < xmax 필요)"""

    # Safety 규칙
    SAFETY_BLOCKED_NO_FALLBACK = "safety_blocked_no_fallback"
    """차단되었지만 안전한 대체 결과가 제공되지 않았습니다"""


# =============================================================================
# 검증 결과 타입
# =============================================================================


@dataclass
class BusinessRuleValidationResult:
    """비즈니스 룰 검증 결과.

    Attributes:
        is_valid: 모든 검증 통과 여부
        errors: 발견된 위반 목록
        error_summary: 에러 요약 (Repair 프롬프트용)
        language: 응답 언어 (RULE-006)
        language_gate_result: 언어 혼합 검증 결과 (U-043)
    """

    is_valid: bool = True
    errors: list[dict[str, str]] = field(default_factory=lambda: [])
    error_summary: str = ""
    language: Language = Language.EN
    language_gate_result: LanguageGateResult | None = None

    def add_error(self, error_type: BusinessRuleError, message: str) -> None:
        """에러를 추가합니다."""
        self.is_valid = False
        self.errors.append({"type": error_type.value, "message": message})

    def build_summary(self) -> str:
        """에러 요약을 생성합니다 (Repair 프롬프트용).

        언어에 따라 헤더 메시지를 분기합니다 (RULE-006).
        언어 혼합 에러가 있으면 상세 지시를 추가합니다 (U-043).
        """
        if not self.errors:
            self.error_summary = ""
            return ""

        messages = BUSINESS_RULE_MESSAGES[self.language]
        summary_lines = [messages["summary_header"]]
        for err in self.errors:
            summary_lines.append(f"- {err['message']}")

        # U-043: 언어 혼합 에러가 있으면 상세 지시 추가
        if self.language_gate_result and not self.language_gate_result.is_valid:
            summary_lines.append("")
            summary_lines.append(build_language_error_summary(self.language_gate_result))

        self.error_summary = "\n".join(summary_lines)
        return self.error_summary


# =============================================================================
# 개별 검증 함수
# =============================================================================


def _validate_economy(
    turn_input: TurnInput,
    turn_output: TurnOutput,
    result: BusinessRuleValidationResult,
) -> None:
    """Economy 규칙을 검증합니다 (RULE-005).

    검증 항목:
    - 잔액 음수 금지
    - snapshot 대비 과도한 비용 청구 금지 (U-079: 크레딧 허용)
    - cost와 balance_after 일관성
    """
    economy = turn_output.economy
    snapshot = turn_input.economy_snapshot
    messages = BUSINESS_RULE_MESSAGES[result.language]

    # 1. 과도한 비용 청구 금지 (snapshot < cost)
    # U-079: 크레딧(빚)을 허용하여 잔액보다 큰 비용 지불 가능
    # 허용 범위: snapshot.signal + MAX_CREDIT >= cost.signal
    effective_signal = snapshot.signal + MAX_CREDIT

    if effective_signal < economy.cost.signal:
        result.add_error(
            BusinessRuleError.ECONOMY_NEGATIVE_BALANCE,
            messages["signal_insufficient"].format(have=snapshot.signal, need=economy.cost.signal),
        )

    if snapshot.memory_shard < economy.cost.memory_shard:
        result.add_error(
            BusinessRuleError.ECONOMY_NEGATIVE_BALANCE,
            messages["memory_shard_insufficient"].format(
                have=snapshot.memory_shard, need=economy.cost.memory_shard
            ),
        )

    # 2. 잔액 음수 금지 (이미 필드 수준 ge=0 검증이 있지만, 비즈니스 룰에서도 명시)
    if economy.balance_after.signal < 0:
        result.add_error(
            BusinessRuleError.ECONOMY_NEGATIVE_BALANCE,
            messages["signal_negative"].format(value=economy.balance_after.signal),
        )

    if economy.balance_after.memory_shard < 0:
        result.add_error(
            BusinessRuleError.ECONOMY_NEGATIVE_BALANCE,
            messages["memory_shard_negative"].format(value=economy.balance_after.memory_shard),
        )

    # 3. cost와 balance_after 일관성 검증
    # balance_after = snapshot - cost + credit_delta 여야 함
    # (또는 credit 필드가 사용 중인 총 빚을 나타냄)
    # U-079 단순화: balance_after.signal = max(0, snapshot.signal - cost.signal)
    # credit = max(0, cost.signal - snapshot.signal)
    expected_signal = max(0, snapshot.signal - economy.cost.signal)
    expected_shard = max(0, snapshot.memory_shard - economy.cost.memory_shard)
    expected_credit = max(0, economy.cost.signal - snapshot.signal)

    if economy.balance_after.signal != expected_signal:
        result.add_error(
            BusinessRuleError.ECONOMY_COST_MISMATCH,
            messages["signal_mismatch"].format(
                expected=expected_signal, actual=economy.balance_after.signal
            ),
        )

    if economy.balance_after.memory_shard != expected_shard:
        result.add_error(
            BusinessRuleError.ECONOMY_COST_MISMATCH,
            messages["memory_shard_mismatch"].format(
                expected=expected_shard, actual=economy.balance_after.memory_shard
            ),
        )

    # credit 일관성 검증
    if economy.credit != expected_credit:
        result.add_error(
            BusinessRuleError.ECONOMY_COST_MISMATCH,
            f"Credit mismatch: expected {expected_credit}, actual {economy.credit}",
        )


def _validate_language(
    turn_input: TurnInput,
    turn_output: TurnOutput,
    result: BusinessRuleValidationResult,
) -> None:
    """Language 규칙을 검증합니다 (RULE-006).

    검증 항목:
    - TurnInput.language와 TurnOutput.language 일치
    """
    if turn_input.language != turn_output.language:
        messages = BUSINESS_RULE_MESSAGES[result.language]
        result.add_error(
            BusinessRuleError.LANGUAGE_MISMATCH,
            messages["language_mismatch"].format(
                input_lang=turn_input.language.value,
                output_lang=turn_output.language.value,
            ),
        )


def _validate_language_content(
    turn_input: TurnInput,
    turn_output: TurnOutput,
    result: BusinessRuleValidationResult,
) -> None:
    """Language 콘텐츠 혼합을 검증합니다 (RULE-006, U-043).

    검증 항목:
    - 사용자 노출 텍스트가 TurnInput.language와 동일 언어인지 확인
    - ko/en 혼합 시 LANGUAGE_CONTENT_MIXED 에러 추가
    """
    # 언어 혼합 검증 (U-043)
    lang_result = validate_language_consistency(turn_output, turn_input.language)

    if not lang_result.is_valid:
        messages = BUSINESS_RULE_MESSAGES[result.language]
        result.add_error(
            BusinessRuleError.LANGUAGE_CONTENT_MIXED,
            messages["language_content_mixed"].format(violation_count=len(lang_result.violations)),
        )
        # 상세 에러 요약 생성을 위해 결과 저장
        result.language_gate_result = lang_result


def _validate_box2d(
    turn_output: TurnOutput,
    result: BusinessRuleValidationResult,
) -> None:
    """Box2D 좌표 규칙을 검증합니다 (RULE-009).

    검증 항목:
    - 0~1000 범위
    - ymin < ymax, xmin < xmax 순서
    """
    messages = BUSINESS_RULE_MESSAGES[result.language]

    # UI 오브젝트의 box2d 검증
    for obj in turn_output.ui.objects:
        box = obj.box_2d

        # 범위 검증 (0~1000)
        coords = [box.ymin, box.xmin, box.ymax, box.xmax]
        for coord in coords:
            if coord < 0 or coord > 1000:
                result.add_error(
                    BusinessRuleError.BOX2D_OUT_OF_RANGE,
                    messages["box2d_out_of_range"].format(obj_id=obj.id, coord=coord),
                )
                break  # 한 오브젝트에 대해 한 번만 보고

        # 순서 검증 (ymin < ymax, xmin < xmax)
        if box.ymin >= box.ymax:
            result.add_error(
                BusinessRuleError.BOX2D_INVALID_ORDER,
                messages["box2d_invalid_yorder"].format(
                    obj_id=obj.id, ymin=box.ymin, ymax=box.ymax
                ),
            )

        if box.xmin >= box.xmax:
            result.add_error(
                BusinessRuleError.BOX2D_INVALID_ORDER,
                messages["box2d_invalid_xorder"].format(
                    obj_id=obj.id, xmin=box.xmin, xmax=box.xmax
                ),
            )


def _validate_safety(
    turn_output: TurnOutput,
    result: BusinessRuleValidationResult,
) -> None:
    """Safety 규칙을 검증합니다.

    검증 항목:
    - blocked 시 안전한 대체 결과(narrative) 제공 확인
    """
    safety = turn_output.safety
    messages = BUSINESS_RULE_MESSAGES[result.language]

    # 차단 시에도 narrative가 있어야 함 (안전한 대체 결과)
    if safety.blocked and (not turn_output.narrative or len(turn_output.narrative.strip()) == 0):
        result.add_error(
            BusinessRuleError.SAFETY_BLOCKED_NO_FALLBACK,
            messages["safety_blocked_no_fallback"],
        )


# =============================================================================
# 메인 검증 함수
# =============================================================================


def validate_business_rules(
    turn_input: TurnInput,
    turn_output: TurnOutput,
) -> BusinessRuleValidationResult:
    """비즈니스 룰을 검증합니다."""
    # RU-005-S2: turn_input.language에 따라 에러 메시지 i18n 분기
    result = BusinessRuleValidationResult(language=turn_input.language)

    # 1. Economy 검증 (RULE-005)
    _validate_economy(turn_input, turn_output, result)

    # 2. Language enum 검증 (RULE-006)
    _validate_language(turn_input, turn_output, result)

    # 3. Language 콘텐츠 혼합 검증 (RULE-006, U-043)
    _validate_language_content(turn_input, turn_output, result)

    # 4. Box2D 검증 (RULE-009)
    _validate_box2d(turn_output, result)

    # 5. Safety 검증
    _validate_safety(turn_output, result)

    # 에러 요약 생성
    if not result.is_valid:
        result.build_summary()
        logger.warning(
            "[BusinessRules] 검증 실패",
            extra={"error_count": len(result.errors)},
        )

    return result
</file>

<file path="backend/src/unknown_world/validation/language_gate.py">
"""Unknown World - 언어 혼합 검증 게이트 (RULE-006).

ko/en 혼합 출력을 감지하고 차단하는 Hard Gate입니다.
TurnInput.language를 SSOT로 삼아 TurnOutput의 사용자 노출 텍스트가
동일 언어로 수렴하는지 검증합니다.

설계 원칙:
    - RULE-006: ko/en 언어 정책 준수 (혼합 출력 금지)
    - RULE-004: 검증 실패 시 Repair loop로 복구
    - CP-MVP-05: 언어 혼합 금지 검증

페어링 결정:
    - Q1: Option A (보수적 - 오탐 최소, CP에서 튜닝)
    - Q2: Option A (고유명 최소치만 허용)

참조:
    - vibe/unit-plans/U-043[Mvp].md
    - vibe/ref/en-ko-issue.png (혼합 출력 사례)
    - .cursor/rules/00-core-critical.mdc
"""

from __future__ import annotations

import logging
import re
import unicodedata
from dataclasses import dataclass, field
from typing import TYPE_CHECKING

from unknown_world.models.turn import Language

if TYPE_CHECKING:
    from unknown_world.models.turn import TurnOutput

# =============================================================================
# 로거 설정
# =============================================================================

logger = logging.getLogger(__name__)

# =============================================================================
# 상수 및 설정
# =============================================================================

# 페어링 결정 Q1: Option A (보수적 - 오탐 최소)
# 혼합 판정 임계값 (이 비율 이상이면 "잘못된 언어"로 판정)
MIXED_THRESHOLD_RATIO = 0.15  # 15% 이상의 반대 언어 문자 → 혼합으로 판정

# 페어링 결정 Q2: Option A (고유명 최소치만 허용)
# 허용 화이트리스트 (영어 고유명 - 재화/모델 라벨 등)
# 주의: 복합어는 개별 단어도 함께 등록해야 합니다 (한글 붙은 경우 단어 경계 매칭 문제)
ALLOWED_ENGLISH_TERMS: set[str] = {
    # 재화 이름 (RULE-005)
    "signal",
    "shard",
    "memory",
    "memory shard",
    # 모델 라벨 (RULE-008)
    "fast",
    "quality",
    "cheap",
    "ref",
    # 시스템 상수
    "ok",
    "fail",
    "blocked",
    # 기타 허용 약어
    "ui",
    "api",
    "id",
    "json",
    "schema",
}

# 한글 유니코드 범위
HANGUL_JAMO_START = 0x1100
HANGUL_JAMO_END = 0x11FF
HANGUL_SYLLABLES_START = 0xAC00
HANGUL_SYLLABLES_END = 0xD7AF
HANGUL_COMPAT_JAMO_START = 0x3130
HANGUL_COMPAT_JAMO_END = 0x318F


# =============================================================================
# 언어 감지 휴리스틱
# =============================================================================


def _is_hangul(char: str) -> bool:
    """한글 문자인지 확인합니다."""
    code = ord(char)
    return (
        (HANGUL_SYLLABLES_START <= code <= HANGUL_SYLLABLES_END)
        or (HANGUL_JAMO_START <= code <= HANGUL_JAMO_END)
        or (HANGUL_COMPAT_JAMO_START <= code <= HANGUL_COMPAT_JAMO_END)
    )


def _is_latin(char: str) -> bool:
    """라틴 알파벳인지 확인합니다 (a-z, A-Z)."""
    return char.isalpha() and unicodedata.category(char).startswith("L") and not _is_hangul(char)


def _normalize_text_for_check(text: str) -> str:
    """검사용으로 텍스트를 정규화합니다.

    - 소문자 변환
    - 화이트리스트 단어 제거
    - 숫자/기호/공백/이모지 제거
    """
    normalized = text.lower()

    # 화이트리스트 단어 제거 (대소문자 무시)
    # 복합어를 먼저 처리 (긴 것부터)
    sorted_terms = sorted(ALLOWED_ENGLISH_TERMS, key=len, reverse=True)
    for term in sorted_terms:
        # 한글이 붙어있는 경우도 처리하기 위해 단어 경계 대신
        # 알파벳이 아닌 문자 또는 문자열 경계로 매칭
        # 예: "Signal가", "Memory Shard를" 등
        pattern = rf"(?<![a-zA-Z]){re.escape(term)}(?![a-zA-Z])"
        normalized = re.sub(pattern, "", normalized, flags=re.IGNORECASE)

    return normalized


@dataclass
class LanguageRatio:
    """언어 비율 측정 결과.

    Attributes:
        hangul_count: 한글 문자 수
        latin_count: 라틴 문자 수
        total_alpha: 총 알파벳 문자 수 (한글 + 라틴)
        hangul_ratio: 한글 비율 (0.0 ~ 1.0)
        latin_ratio: 라틴 비율 (0.0 ~ 1.0)
    """

    hangul_count: int = 0
    latin_count: int = 0
    total_alpha: int = 0
    hangul_ratio: float = 0.0
    latin_ratio: float = 0.0


def measure_language_ratio(text: str) -> LanguageRatio:
    """텍스트의 한글/라틴 비율을 측정합니다.

    화이트리스트 단어는 제거한 후 측정합니다.

    Args:
        text: 측정할 텍스트

    Returns:
        LanguageRatio: 언어 비율 측정 결과
    """
    if not text:
        return LanguageRatio()

    # 정규화 (화이트리스트 제거)
    normalized = _normalize_text_for_check(text)

    hangul_count = 0
    latin_count = 0

    for char in normalized:
        if _is_hangul(char):
            hangul_count += 1
        elif _is_latin(char):
            latin_count += 1

    total = hangul_count + latin_count

    if total == 0:
        return LanguageRatio()

    return LanguageRatio(
        hangul_count=hangul_count,
        latin_count=latin_count,
        total_alpha=total,
        hangul_ratio=hangul_count / total,
        latin_ratio=latin_count / total,
    )


def is_language_mixed(text: str, expected_language: Language) -> bool:
    """텍스트가 예상 언어와 다른 언어가 혼합되었는지 확인합니다.

    Args:
        text: 검사할 텍스트
        expected_language: 예상 언어 (TurnInput.language)

    Returns:
        bool: 혼합되었으면 True
    """
    if not text or len(text.strip()) == 0:
        return False

    ratio = measure_language_ratio(text)

    # 알파벳이 거의 없는 경우 (숫자/기호만) → 혼합 아님
    if ratio.total_alpha < 3:
        return False

    # 예상 언어에 따라 반대 언어 비율 체크
    if expected_language == Language.KO:
        # 한국어 예상인데 라틴 비율이 임계값 이상이면 혼합
        return ratio.latin_ratio >= MIXED_THRESHOLD_RATIO
    else:
        # 영어 예상인데 한글 비율이 임계값 이상이면 혼합
        return ratio.hangul_ratio >= MIXED_THRESHOLD_RATIO


# =============================================================================
# TurnOutput 텍스트 추출
# =============================================================================


@dataclass
class ExtractedText:
    """추출된 사용자 노출 텍스트.

    Attributes:
        field_path: 필드 경로 (예: "narrative", "ui.action_deck.cards[0].label")
        text: 텍스트 내용
    """

    field_path: str
    text: str


def extract_user_facing_texts(turn_output: TurnOutput) -> list[ExtractedText]:
    """TurnOutput에서 사용자 노출 텍스트를 추출합니다.

    검사 범위 (우선순위):
        - narrative
        - ui.action_deck.cards[].label, description, hint, reward_hint, disabled_reason
        - ui.objects[].label, interaction_hint
        - world.quests_updated[].label
        - world.rules_changed[].label, description
        - world.memory_pins[].content

    Args:
        turn_output: 검사할 TurnOutput

    Returns:
        list[ExtractedText]: 추출된 텍스트 목록
    """
    texts: list[ExtractedText] = []

    # 1. narrative (가장 중요)
    if turn_output.narrative:
        texts.append(ExtractedText(field_path="narrative", text=turn_output.narrative))

    # 2. ui.action_deck.cards[]
    # U-065: description, hint, reward_hint, disabled_reason 필드 제거됨
    for i, card in enumerate(turn_output.ui.action_deck.cards):
        texts.append(ExtractedText(field_path=f"ui.action_deck.cards[{i}].label", text=card.label))

    # 3. ui.objects[]
    for i, obj in enumerate(turn_output.ui.objects):
        texts.append(ExtractedText(field_path=f"ui.objects[{i}].label", text=obj.label))
        if obj.interaction_hint:
            texts.append(
                ExtractedText(
                    field_path=f"ui.objects[{i}].interaction_hint",
                    text=obj.interaction_hint,
                )
            )

    # 4. world.quests_updated[]
    for i, quest in enumerate(turn_output.world.quests_updated):
        texts.append(ExtractedText(field_path=f"world.quests_updated[{i}].label", text=quest.label))

    # 5. world.rules_changed[]
    for i, rule in enumerate(turn_output.world.rules_changed):
        texts.append(ExtractedText(field_path=f"world.rules_changed[{i}].label", text=rule.label))
        if rule.description:
            texts.append(
                ExtractedText(
                    field_path=f"world.rules_changed[{i}].description",
                    text=rule.description,
                )
            )

    # 6. world.memory_pins[]
    for i, pin in enumerate(turn_output.world.memory_pins):
        texts.append(ExtractedText(field_path=f"world.memory_pins[{i}].content", text=pin.content))

    # 7. safety.message
    if turn_output.safety.message:
        texts.append(ExtractedText(field_path="safety.message", text=turn_output.safety.message))

    return texts


# =============================================================================
# 언어 혼합 검증 결과
# =============================================================================


@dataclass
class LanguageGateResult:
    """언어 혼합 검증 결과.

    Attributes:
        is_valid: 검증 통과 여부 (혼합 없음)
        violations: 위반 사항 목록 (필드 경로 + 샘플 토큰)
        expected_language: 예상 언어
    """

    is_valid: bool = True
    violations: list[dict[str, str]] = field(default_factory=lambda: [])
    expected_language: Language = Language.EN

    def add_violation(self, field_path: str, sample_text: str) -> None:
        """위반 사항을 추가합니다."""
        self.is_valid = False
        # 로그에 전체 텍스트 노출 방지 - 앞 50자만 샘플링
        truncated = sample_text[:50] + "..." if len(sample_text) > 50 else sample_text
        self.violations.append({"field": field_path, "sample": truncated})


def validate_language_consistency(
    turn_output: TurnOutput,
    expected_language: Language,
) -> LanguageGateResult:
    """TurnOutput의 언어 일관성을 검증합니다.

    사용자 노출 텍스트가 expected_language와 일치하는지 확인합니다.
    혼합 발견 시 위반 목록을 반환합니다.

    Args:
        turn_output: 검사할 TurnOutput
        expected_language: 예상 언어 (TurnInput.language)

    Returns:
        LanguageGateResult: 검증 결과

    Example:
        >>> result = validate_language_consistency(turn_output, Language.KO)
        >>> if not result.is_valid:
        ...     print(f"혼합 발견: {len(result.violations)}건")
    """
    result = LanguageGateResult(expected_language=expected_language)

    # 사용자 노출 텍스트 추출
    texts = extract_user_facing_texts(turn_output)

    # 각 텍스트 검사
    for extracted in texts:
        if is_language_mixed(extracted.text, expected_language):
            result.add_violation(extracted.field_path, extracted.text)

    if not result.is_valid:
        logger.warning(
            "[LanguageGate] 언어 혼합 감지",
            extra={
                "expected_language": expected_language.value,
                "violation_count": len(result.violations),
            },
        )

    return result


# =============================================================================
# i18n 에러 메시지 (RULE-006)
# =============================================================================

LANGUAGE_GATE_MESSAGES: dict[Language, dict[str, str]] = {
    Language.KO: {
        "summary_header": "언어 혼합이 감지되었습니다 (RULE-006 위반):",
        "violation_item": "- 필드 '{field}': 한국어로 작성해야 합니다",
        "instruction": "모든 사용자 노출 텍스트를 한국어(ko-KR)로 다시 작성하세요.",
    },
    Language.EN: {
        "summary_header": "Language mixing detected (RULE-006 violation):",
        "violation_item": "- Field '{field}': Must be written in English",
        "instruction": "Rewrite all user-facing text in English (en-US).",
    },
}


def build_language_error_summary(result: LanguageGateResult) -> str:
    """언어 혼합 검증 실패에 대한 에러 요약을 생성합니다.

    Repair 프롬프트에 포함할 요약입니다.
    전체 텍스트는 노출하지 않고 필드 경로만 표시합니다.

    Args:
        result: 언어 검증 결과

    Returns:
        str: 에러 요약 문자열
    """
    if result.is_valid:
        return ""

    messages = LANGUAGE_GATE_MESSAGES[result.expected_language]
    lines = [messages["summary_header"]]

    # 최대 5개까지만 표시 (너무 많으면 프롬프트 비대)
    for violation in result.violations[:5]:
        lines.append(messages["violation_item"].format(field=violation["field"]))

    if len(result.violations) > 5:
        remaining = len(result.violations) - 5
        if result.expected_language == Language.KO:
            lines.append(f"- (외 {remaining}건 추가 위반)")
        else:
            lines.append(f"- (and {remaining} more violations)")

    lines.append("")
    lines.append(messages["instruction"])

    return "\n".join(lines)
</file>

<file path="backend/start_and_test.py">
"""서버를 직접 시작하고, 요청을 보내고, 종료합니다."""

import json
import time
from pathlib import Path

from dotenv import load_dotenv

load_dotenv(dotenv_path=Path(__file__).resolve().parent / ".env", override=False)

from multiprocessing import Process

import httpx
import uvicorn


def run_server():
    """서버 프로세스."""
    uvicorn.run(
        "src.unknown_world.main:app",
        host="0.0.0.0",
        port=8011,
        log_level="warning",
    )


def test_api():
    """API 테스트."""
    time.sleep(4)  # 서버 시작 대기

    print("=== Testing API ===")
    try:
        r = httpx.post(
            "http://localhost:8011/api/turn",
            json={
                "language": "ko-KR",
                "text": "문을 열어본다",
                "client": {"viewport_w": 1920, "viewport_h": 1080, "theme": "dark"},
                "economy_snapshot": {"signal": 100, "memory_shard": 5},
            },
            timeout=60.0,
        )

        for line in r.text.strip().split("\n"):
            d = json.loads(line)
            t = d.get("type")
            if t == "repair":
                print(f"  REPAIR: attempt={d.get('attempt')} msg={d.get('message')}")
            elif t == "badges":
                print(f"  BADGES: {d.get('badges')}")
            elif t == "final":
                fc = d.get("data", {}).get("agent_console", {})
                narr = d.get("data", {}).get("narrative", "")[:80]
                print(f"  FINAL: badges={fc.get('badges')} repair={fc.get('repair_count')}")
                print(f"  NARRATIVE: {narr}")
            elif t == "error":
                print(f"  ERROR: {d.get('message')} code={d.get('code')}")
    except Exception as e:
        print(f"  EXCEPTION: {e}")


if __name__ == "__main__":
    server = Process(target=run_server, daemon=True)
    server.start()
    print(f"Server PID: {server.pid}")

    try:
        test_api()
    finally:
        server.terminate()
        server.join(timeout=5)
        print("\nServer stopped.")
</file>

<file path="backend/test_api.py">
import json

import httpx

r = httpx.post(
    "http://localhost:8011/api/turn",
    json={
        "language": "ko-KR",
        "text": "문을 열어본다",
        "client": {"viewport_w": 1920, "viewport_h": 1080, "theme": "dark"},
        "economy_snapshot": {"signal": 100, "memory_shard": 5},
    },
    timeout=30.0,
)
for line in r.text.strip().split("\n"):
    d = json.loads(line)
    t = d.get("type")
    if t in ("repair", "badges", "error", "final"):
        if t == "final":
            fc = d.get("data", {}).get("agent_console", {})
            print(f"{t}: badges={fc.get('badges')} repair={fc.get('repair_count')}")
        else:
            print(f"{t}: {json.dumps(d, ensure_ascii=False)}")
</file>

<file path="backend/test_real_vision.json">
{
  "language": "ko-KR",
  "text": "",
  "action_id": "deep_analyze",
  "client": {
    "viewport_w": 1920,
    "viewport_h": 1080,
    "theme": "dark"
  },
  "economy_snapshot": {
    "signal": 100,
    "memory_shard": 5
  },
  "previous_image_url": "/static/images/test_scene.png"
}
</file>

<file path="backend/tests/integration/test_multiturn_history.py">
"""Integration tests for Multi-turn History (U-127)."""

from unittest.mock import AsyncMock, MagicMock, patch

import pytest

from unknown_world.models.turn import ClientInfo, EconomySnapshot, Language, TurnInput
from unknown_world.orchestrator.conversation_history import (
    get_conversation_history,
    reset_all_histories,
)
from unknown_world.orchestrator.generate_turn_output import GenerationStatus, generate_turn_output
from unknown_world.orchestrator.repair_loop import run_repair_loop


@pytest.fixture
def mock_genai_client():
    with patch("unknown_world.orchestrator.generate_turn_output.get_genai_client") as mock_get:
        mock_client = AsyncMock()
        mock_get.return_value = mock_client

        # Setup successful response
        mock_response = MagicMock()
        mock_response.text = '{"language": "en-US", "narrative": "Success", "ui": {}, "world": {}, "economy": {"cost": {"signal": 10, "memory_shard": 0}, "balance_after": {"signal": 90, "memory_shard": 100}}, "safety": {"blocked": false}, "agent_console": {}}'
        mock_response.thought_signature = "mock_sig"
        mock_client.generate.return_value = mock_response

        yield mock_client


@pytest.fixture
def turn_input():
    return TurnInput(
        language=Language.EN,
        text="Hello",
        action_id="test_action",
        economy_snapshot=EconomySnapshot(signal=100, memory_shard=100),
        client=ClientInfo(viewport_w=1920, viewport_h=1080),
    )


@pytest.mark.asyncio
async def test_generate_turn_output_with_history(mock_genai_client, turn_input):
    """Test generation with conversation history."""
    reset_all_histories()
    history = get_conversation_history("test_session")

    # Add a previous turn
    history.add_turn("Prev User", "Prev Model", thought_signature="prev_sig")

    # Call generate
    result = await generate_turn_output(
        turn_input,
        conversation_history=history,
        force_mock=False,  # We patched the client directly
    )

    assert result.status == GenerationStatus.SUCCESS

    # Verify request arguments
    args, kwargs = mock_genai_client.generate.call_args
    request = args[0]

    # Should use contents, not prompt
    assert request.contents is not None
    assert request.prompt == ""

    # Verify contents structure
    # 0: User (Prev)
    # 1: Model (Prev)
    # 2: User (Current)
    assert len(request.contents) == 3
    assert request.contents[0]["role"] == "user"
    assert request.contents[0]["parts"][0]["text"] == "Prev User"
    assert request.contents[1]["role"] == "model"
    assert request.contents[1]["parts"][0]["text"] == "Prev Model"
    assert request.contents[1]["parts"][0]["thoughtSignature"] == "prev_sig"
    assert request.contents[2]["role"] == "user"
    # Current input is formatted with metadata
    assert "Hello" in request.contents[2]["parts"][0]["text"]

    # Verify system instruction separation
    assert request.system_instruction is not None


@pytest.mark.asyncio
async def test_repair_loop_passes_history(mock_genai_client, turn_input):
    """Test that repair loop correctly passes history to generator."""
    reset_all_histories()
    history = get_conversation_history("test_session_repair")
    history.add_turn("History Turn", "History Resp")

    # Run repair loop
    result = await run_repair_loop(turn_input, conversation_history=history, force_mock=False)

    assert result.output is not None

    # Verify call
    args, kwargs = mock_genai_client.generate.call_args
    request = args[0]

    # Should contain history
    has_history = False
    for content in request.contents:
        if content["role"] == "user" and content["parts"][0]["text"] == "History Turn":
            has_history = True
            break
    assert has_history


@pytest.mark.asyncio
async def test_thought_signature_in_result(mock_genai_client, turn_input):
    """Test that thought signature is returned in the result."""
    reset_all_histories()

    result = await generate_turn_output(turn_input)

    assert result.thought_signature == "mock_sig"
</file>

<file path="backend/tests/integration/test_real_mode_gate.py">
"""CP-MVP-07: real 모드 로컬 실행 게이트 통합 테스트.

로컬 개발 환경에서 `.env` 기반 설정으로 **real 모드(실모델) 실행**이
안정적으로 재현되는지 검증합니다.

완료 기준:
- `.env`가 로드된 상태에서 서버가 real 모드로 실행되며, `/health`가 정상 응답한다.
- 턴 1회 실행 시 NDJSON 스트림이 정상적으로 흐르고 최종 `final`이 스키마/비즈니스 룰을 통과한다.
- 인증/환경변수 누락 케이스에서도 서버가 크래시하지 않고, 안전 폴백으로 종료한다. (RULE-004)
- mock 고정 내러티브가 real 모드에서 반복 노출되지 않는다(모드 드리프트 방지).
- 민감 정보가 로그에 노출되지 않는다 (RULE-007).

참조:
- vibe/unit-plans/CP-MVP-07.md
- vibe/unit-results/U-047[Mvp].md
- vibe/unit-results/CP-MVP-04.md
"""

from __future__ import annotations

import json
import os
from collections.abc import Generator
from pathlib import Path
from typing import Any

import pytest
from dotenv import load_dotenv
from fastapi.testclient import TestClient

from unknown_world.main import app
from unknown_world.models.turn import Language, TurnOutput
from unknown_world.services.genai_client import (
    GenAIMode,
    get_genai_client,
    reset_genai_client,
)

# =============================================================================
# Fixtures
# =============================================================================


@pytest.fixture
def client() -> TestClient:
    """FastAPI 테스트 클라이언트."""
    return TestClient(app)


@pytest.fixture
def mock_mode_env() -> Generator[None]:
    """UW_MODE=mock 환경을 설정합니다."""
    original = os.environ.get("UW_MODE")
    os.environ["UW_MODE"] = "mock"
    reset_genai_client()  # 클라이언트 캐시 초기화

    yield

    if original is not None:
        os.environ["UW_MODE"] = original
    elif "UW_MODE" in os.environ:
        del os.environ["UW_MODE"]
    reset_genai_client()


@pytest.fixture
def real_mode_env() -> Generator[None]:
    """UW_MODE=real 환경을 설정합니다 (실제 API 호출 없이 클라이언트 모드만 변경)."""
    original = os.environ.get("UW_MODE")
    os.environ["UW_MODE"] = "real"
    reset_genai_client()  # 클라이언트 캐시 초기화

    yield

    if original is not None:
        os.environ["UW_MODE"] = original
    elif "UW_MODE" in os.environ:
        del os.environ["UW_MODE"]
    reset_genai_client()


# =============================================================================
# 시나리오 A: 서버 기동 및 상태 확인 (Health Check)
# =============================================================================


class TestServerHealthWithEnv:
    """서버 기동 및 상태 확인 테스트 (시나리오 A)."""

    def test_health_endpoint_returns_ok(self, client: TestClient) -> None:
        """[Happy] /health 엔드포인트가 정상 응답합니다."""
        # When: 헬스체크 요청
        response = client.get("/health")

        # Then: 정상 응답
        assert response.status_code == 200
        data = response.json()
        assert data["status"] in ("ok", "degraded")
        assert data["service"] == "unknown-world-backend"
        assert "version" in data

    def test_health_no_rembg_field(self, client: TestClient) -> None:
        """[Happy] /health 응답에 rembg 상태가 포함되지 않습니다 (U-091 제거)."""
        # When: 헬스체크 요청
        response = client.get("/health")

        # Then: rembg 정보가 없어야 함 (U-091: 런타임 rembg 제거)
        data = response.json()
        assert "rembg" not in data

    def test_uw_mode_environment_variable_loaded(self) -> None:
        """[Happy] UW_MODE 환경변수가 올바르게 로드됩니다."""
        # Given: 현재 환경의 UW_MODE 값
        uw_mode = os.environ.get("UW_MODE", "mock")

        # Then: 유효한 값이어야 함
        assert uw_mode in ("mock", "real")


# =============================================================================
# 시나리오 B: real 모드 턴 스모크 테스트 (스트리밍)
# =============================================================================


class TestTurnStreamingInMockMode:
    """턴 스트리밍 테스트 (Mock 모드, 시나리오 B의 기본 경로)."""

    def test_stage_events_order(self, client: TestClient, mock_mode_env: None) -> None:
        """[Happy] stage 이벤트가 올바른 순서로 발생합니다."""
        # Given: 유효한 턴 입력
        payload = {
            "language": "ko-KR",
            "text": "테스트 입력",
            "client": {"viewport_w": 1920, "viewport_h": 1080, "theme": "dark"},
            "economy_snapshot": {"signal": 100, "memory_shard": 5},
        }

        # When: 턴 요청
        response = client.post("/api/turn", json=payload)

        # Then: 정상 스트리밍 응답
        assert response.status_code == 200
        assert response.headers["content-type"] == "application/x-ndjson"

        events = [json.loads(line) for line in response.iter_lines() if line]

        # stage 이벤트 순서 확인
        stages = [e["name"] for e in events if e["type"] == "stage" and e["status"] == "start"]
        expected_stages = [
            "parse",
            "validate",
            "plan",
            "resolve",
            "render",
            "verify",
            "commit",
        ]
        assert stages == expected_stages

    def test_final_event_has_valid_turn_output(
        self, client: TestClient, mock_mode_env: None
    ) -> None:
        """[Happy] final 이벤트가 유효한 TurnOutput을 포함합니다."""
        # Given: 유효한 턴 입력
        payload = {
            "language": "ko-KR",
            "text": "문을 열어본다",
            "client": {"viewport_w": 1920, "viewport_h": 1080},
            "economy_snapshot": {"signal": 100, "memory_shard": 5},
        }

        # When: 턴 요청
        response = client.post("/api/turn", json=payload)
        events = [json.loads(line) for line in response.iter_lines() if line]

        # Then: final 이벤트 확인
        final_events = [e for e in events if e["type"] == "final"]
        assert len(final_events) == 1

        # Pydantic 검증 (RULE-003)
        turn_output = TurnOutput.model_validate(final_events[0]["data"])
        assert turn_output.language == Language.KO

    def test_badges_contain_all_categories(self, client: TestClient, mock_mode_env: None) -> None:
        """[Happy] badges가 모든 카테고리(Schema/Economy/Safety/Consistency)를 포함합니다."""
        # Given: 유효한 턴 입력
        payload = {
            "language": "ko-KR",
            "text": "탐색한다",
            "client": {"viewport_w": 1920, "viewport_h": 1080},
            "economy_snapshot": {"signal": 100, "memory_shard": 5},
        }

        # When: 턴 요청
        response = client.post("/api/turn", json=payload)
        events = [json.loads(line) for line in response.iter_lines() if line]

        # Then: badges 이벤트 확인
        badges_events = [e for e in events if e["type"] == "badges"]
        assert len(badges_events) >= 1

        # 최종 badges에 모든 카테고리가 포함되어야 함
        final_badges = badges_events[-1]["badges"]
        badge_categories = {b.split("_")[0] for b in final_badges}

        # Schema, Economy, Safety, Consistency 중 최소 3개 이상
        expected_categories = {"schema", "economy", "safety", "consistency"}
        assert len(badge_categories.intersection(expected_categories)) >= 3


# =============================================================================
# 시나리오 C: Hard Gate 인바리언트 검증
# =============================================================================


class TestHardGateInvariants:
    """Hard Gate 인바리언트 검증 테스트 (시나리오 C)."""

    def test_schema_ok_in_successful_turn(self, client: TestClient, mock_mode_env: None) -> None:
        """[Happy] 성공적인 턴에서 schema_ok 배지가 포함됩니다."""
        # Given: 유효한 턴 입력
        payload = {
            "language": "ko-KR",
            "text": "정상 입력",
            "client": {"viewport_w": 1920, "viewport_h": 1080},
            "economy_snapshot": {"signal": 100, "memory_shard": 5},
        }

        # When: 턴 요청
        response = client.post("/api/turn", json=payload)
        events = [json.loads(line) for line in response.iter_lines() if line]

        # Then: final의 배지에 schema_ok 포함
        final_event = next(e for e in events if e["type"] == "final")
        badges = final_event["data"]["agent_console"]["badges"]
        assert "schema_ok" in badges

    def test_economy_ok_and_no_negative_balance(
        self, client: TestClient, mock_mode_env: None
    ) -> None:
        """[Happy] economy_ok 배지와 잔액 음수 금지 (RULE-005)."""
        # Given: 유효한 턴 입력
        payload = {
            "language": "ko-KR",
            "text": "행동",
            "client": {"viewport_w": 1920, "viewport_h": 1080},
            "economy_snapshot": {"signal": 50, "memory_shard": 2},
        }

        # When: 턴 요청
        response = client.post("/api/turn", json=payload)
        events = [json.loads(line) for line in response.iter_lines() if line]

        # Then: economy 확인
        final_event = next(e for e in events if e["type"] == "final")
        economy = final_event["data"]["economy"]

        # 잔액은 음수가 아니어야 함
        assert economy["balance_after"]["signal"] >= 0
        assert economy["balance_after"]["memory_shard"] >= 0

        # economy_ok 배지 포함
        badges = final_event["data"]["agent_console"]["badges"]
        assert "economy_ok" in badges

    def test_language_consistency(self, client: TestClient, mock_mode_env: None) -> None:
        """[Happy] 언어 일관성 유지 (RULE-006)."""
        # Given: 한국어 요청
        payload = {
            "language": "ko-KR",
            "text": "테스트",
            "client": {"viewport_w": 1920, "viewport_h": 1080},
            "economy_snapshot": {"signal": 100, "memory_shard": 5},
        }

        # When: 턴 요청
        response = client.post("/api/turn", json=payload)
        events = [json.loads(line) for line in response.iter_lines() if line]

        # Then: 응답 언어가 요청과 일치
        final_event = next(e for e in events if e["type"] == "final")
        assert final_event["data"]["language"] == "ko-KR"


# =============================================================================
# 시나리오 D: 인증 실패 케이스 (안전 폴백)
# =============================================================================


class TestSafeFallback:
    """안전 폴백 테스트 (시나리오 D)."""

    def test_invalid_input_returns_error_and_fallback(self, client: TestClient) -> None:
        """[Error] 잘못된 입력 시 error + final(폴백) 이벤트가 반환됩니다."""
        # Given: 잘못된 언어 코드
        payload = {
            "language": "invalid-lang",
            "text": "",
        }

        # When: 턴 요청
        response = client.post("/api/turn", json=payload)

        # Then: 200 응답 (스트리밍이므로)
        assert response.status_code == 200

        events = [json.loads(line) for line in response.iter_lines() if line]

        # error 이벤트 포함
        error_events = [e for e in events if e["type"] == "error"]
        assert len(error_events) >= 1
        assert error_events[0]["code"] == "VALIDATION_ERROR"

        # final(폴백) 이벤트 포함
        final_events = [e for e in events if e["type"] == "final"]
        assert len(final_events) == 1

    def test_fallback_has_zero_cost(self, client: TestClient) -> None:
        """[Error] 폴백 응답의 비용은 0입니다 (RULE-005)."""
        # Given: 잘못된 입력으로 폴백 유도
        payload = {
            "language": "invalid",
            "text": "",
        }

        # When: 턴 요청
        response = client.post("/api/turn", json=payload)
        events = [json.loads(line) for line in response.iter_lines() if line]

        # Then: 폴백 비용 0
        final_event = next(e for e in events if e["type"] == "final")
        economy = final_event["data"]["economy"]
        assert economy["cost"]["signal"] == 0
        assert economy["cost"]["memory_shard"] == 0

    def test_fallback_includes_all_badge_categories(self, client: TestClient) -> None:
        """[Error] 폴백 응답도 모든 배지 카테고리를 포함합니다 (RU-005-S1)."""
        # Given: 잘못된 입력으로 폴백 유도
        payload = {
            "language": "invalid",
            "text": "",
        }

        # When: 턴 요청
        response = client.post("/api/turn", json=payload)
        events = [json.loads(line) for line in response.iter_lines() if line]

        # Then: 폴백의 배지 확인
        final_event = next(e for e in events if e["type"] == "final")
        badges = final_event["data"]["agent_console"]["badges"]

        # 모든 카테고리 포함 확인
        badge_prefixes = {b.split("_")[0] for b in badges}
        expected_prefixes = {"schema", "economy", "safety", "consistency"}
        assert badge_prefixes == expected_prefixes


# =============================================================================
# 시나리오: Mock 템플릿 반복 방지 (모드 드리프트)
# =============================================================================


class TestModeDriftPrevention:
    """모드 드리프트 방지 테스트."""

    def test_mock_mode_client_returns_mock(self, mock_mode_env: None) -> None:
        """[Happy] UW_MODE=mock일 때 Mock 클라이언트가 반환됩니다."""
        # When: 클라이언트 조회
        client = get_genai_client()

        # Then: Mock 모드
        assert client.mode == GenAIMode.MOCK

    def test_real_mode_setting_respected(self, real_mode_env: None) -> None:
        """[Happy] UW_MODE=real일 때 real 모드가 설정됩니다.

        Note: 실제 Vertex AI 연결이 없으면 Mock으로 폴백할 수 있지만,
        환경변수 설정은 올바르게 반영되어야 합니다.
        """
        # When: 환경변수 확인
        uw_mode = os.environ.get("UW_MODE")

        # Then: real 모드 설정됨
        assert uw_mode == "real"


# =============================================================================
# 시나리오: 보안 검증 (RULE-007)
# =============================================================================


class TestSecurityCompliance:
    """보안 규칙 준수 테스트."""

    def test_sensitive_info_not_in_health_response(self, client: TestClient) -> None:
        """[Security] /health 응답에 민감 정보가 포함되지 않습니다."""
        # When: 헬스체크 요청
        response = client.get("/health")
        data = response.json()

        # Then: 민감 정보 미포함
        response_text = json.dumps(data)
        assert "GOOGLE_APPLICATION_CREDENTIALS" not in response_text
        assert "token" not in response_text.lower()
        assert "secret" not in response_text.lower()

    def test_error_response_no_internal_details(self, client: TestClient) -> None:
        """[Security] 에러 응답에 내부 구현 세부사항이 노출되지 않습니다."""
        # Given: 잘못된 입력
        payload = {"invalid": "data"}

        # When: 턴 요청
        response = client.post("/api/turn", json=payload)
        events = [json.loads(line) for line in response.iter_lines() if line]

        # Then: 에러 메시지에 스택 트레이스 없음
        error_events = [e for e in events if e["type"] == "error"]
        if error_events:
            error_message = str(error_events[0])
            assert "Traceback" not in error_message
            assert "File " not in error_message


# =============================================================================
# 시나리오: .env 로딩 정책 검증
# =============================================================================


class TestEnvLoadingPolicy:
    """환경변수 로딩 정책 테스트."""

    def test_dotenv_override_false_policy(self) -> None:
        """[Policy] override=False 정책이 적용됩니다.

        운영 환경의 환경변수가 .env 파일보다 우선합니다.
        """
        # Given: 환경변수가 이미 설정됨
        original = os.environ.get("TEST_OVERRIDE_VAR")
        os.environ["TEST_OVERRIDE_VAR"] = "production_value"

        try:
            # When: .env 파일 로드 시뮬레이션 (override=False)
            from tempfile import NamedTemporaryFile

            with NamedTemporaryFile(mode="w", suffix=".env", delete=False) as f:
                f.write("TEST_OVERRIDE_VAR=dev_value\n")
                temp_path = Path(f.name)

            load_dotenv(dotenv_path=temp_path, override=False)

            # Then: 기존 값 유지
            assert os.environ.get("TEST_OVERRIDE_VAR") == "production_value"

        finally:
            temp_path.unlink()
            if original is not None:
                os.environ["TEST_OVERRIDE_VAR"] = original
            elif "TEST_OVERRIDE_VAR" in os.environ:
                del os.environ["TEST_OVERRIDE_VAR"]

    def test_server_works_without_env_file(self, client: TestClient) -> None:
        """[Policy] .env 파일 없이도 서버가 정상 작동합니다."""
        # When: 헬스체크 요청
        response = client.get("/health")

        # Then: 정상 응답 (어떤 환경에서든)
        assert response.status_code == 200


# =============================================================================
# 시나리오: 스트리밍 무결성 검증
# =============================================================================


class TestStreamingIntegrity:
    """스트리밍 무결성 테스트."""

    def test_first_event_is_stage_parse_start(
        self, client: TestClient, mock_mode_env: None
    ) -> None:
        """[Happy] 첫 번째 이벤트는 항상 stage: parse: start입니다 (TTFB)."""
        # Given: 유효한 턴 입력
        payload = {
            "language": "ko-KR",
            "text": "테스트",
            "client": {"viewport_w": 1920, "viewport_h": 1080},
            "economy_snapshot": {"signal": 100, "memory_shard": 5},
        }

        # When: 턴 요청
        response = client.post("/api/turn", json=payload)
        events = [json.loads(line) for line in response.iter_lines() if line]

        # Then: 첫 이벤트 확인
        assert events[0]["type"] == "stage"
        assert events[0]["name"] == "parse"
        assert events[0]["status"] == "start"

    def test_final_event_is_last(self, client: TestClient, mock_mode_env: None) -> None:
        """[Happy] final 이벤트가 마지막에 옵니다."""
        # Given: 유효한 턴 입력
        payload = {
            "language": "ko-KR",
            "text": "테스트",
            "client": {"viewport_w": 1920, "viewport_h": 1080},
            "economy_snapshot": {"signal": 100, "memory_shard": 5},
        }

        # When: 턴 요청
        response = client.post("/api/turn", json=payload)
        events = [json.loads(line) for line in response.iter_lines() if line]

        # Then: 마지막 이벤트가 final
        assert events[-1]["type"] == "final"

    def test_content_type_is_ndjson(self, client: TestClient, mock_mode_env: None) -> None:
        """[Happy] Content-Type이 application/x-ndjson입니다."""
        # Given: 유효한 턴 입력
        payload = {
            "language": "ko-KR",
            "text": "테스트",
            "client": {"viewport_w": 1920, "viewport_h": 1080},
            "economy_snapshot": {"signal": 100, "memory_shard": 5},
        }

        # When: 턴 요청
        response = client.post("/api/turn", json=payload)

        # Then: 올바른 Content-Type
        assert response.headers["content-type"] == "application/x-ndjson"

    def test_deterministic_with_seed(self, client: TestClient, mock_mode_env: None) -> None:
        """[Happy] seed 사용 시 결과가 결정적입니다."""
        # Given: 동일한 입력과 시드
        payload = {
            "language": "en-US",
            "text": "Test",
            "client": {"viewport_w": 1920, "viewport_h": 1080},
            "economy_snapshot": {"signal": 100, "memory_shard": 5},
        }
        seed = 42

        # When: 동일한 시드로 두 번 요청
        def get_final(s: int) -> dict[str, Any]:
            resp = client.post(f"/api/turn?seed={s}", json=payload)
            events = [json.loads(line) for line in resp.iter_lines() if line]
            return next(e["data"] for e in events if e["type"] == "final")

        output1 = get_final(seed)
        output2 = get_final(seed)

        # Then: 동일한 결과
        assert output1 == output2
</file>

<file path="backend/tests/integration/test_turn_streaming.py">
"""Unknown World - /api/turn HTTP Streaming 통합 테스트.

NDJSON 스트리밍 이벤트의 순서, 구조, 데이터 정밀도를 검증합니다.
"""

import json
import os

# U-080 대응: 테스트 환경에서 Mock 모드 강제 (다른 임포트보다 먼저 실행)
os.environ["UW_MODE"] = "mock"

from fastapi.testclient import TestClient

from unknown_world.main import app
from unknown_world.models.turn import Language, TurnOutput

client = TestClient(app)


def test_turn_streaming_success():
    """정상적인 턴 요청 시 NDJSON 스트림이 올바른 순서로 반환되는지 테스트합니다."""
    payload = {
        "language": "ko-KR",
        "text": "테스트 입력",
        "client": {"viewport_w": 1920, "viewport_h": 1080, "theme": "dark"},
        "economy_snapshot": {"signal": 100, "memory_shard": 5},
    }

    # StreamingResponse 테스트
    response = client.post("/api/turn", json=payload)
    assert response.status_code == 200
    assert response.headers["content-type"] == "application/x-ndjson"

    events = []
    for line in response.iter_lines():
        if line:
            events.append(json.loads(line))

    # 1. 이벤트 존재 여부 확인
    assert len(events) > 0

    # 2. 첫 번째 이벤트는 항상 stage: parse: start 여야 함 (TTFB)
    assert events[0]["type"] == "stage"
    assert events[0]["name"] == "parse"
    assert events[0]["status"] == "start"

    # 3. 단계별 이벤트 순서 확인
    stages = [e["name"] for e in events if e["type"] == "stage" and e["status"] == "start"]
    expected_stages = ["parse", "validate", "plan", "resolve", "render", "verify", "commit"]
    assert stages == expected_stages

    # 4. 배지 이벤트 포함 여부 확인
    # U-060: badges 발생 여부가 중요, 정확한 수는 구현 세부사항이므로 >= 1로 완화
    badges_events = [e for e in events if e["type"] == "badges"]
    assert len(badges_events) >= 1, "최소 1개 이상의 badges 이벤트가 필요합니다"
    assert "schema_ok" in badges_events[0]["badges"]

    # 5. 최종 결과물 확인
    final_events = [e for e in events if e["type"] == "final"]
    assert len(final_events) == 1

    turn_output_data = final_events[0]["data"]
    # Pydantic 모델로 다시 검증 (RULE-003)
    turn_output = TurnOutput.model_validate(turn_output_data)
    assert turn_output.language == Language.KO
    assert len(turn_output.narrative) > 0


def test_turn_streaming_invalid_input():
    """잘못된 입력 요청 시 에러 이벤트가 스트리밍되는지 테스트합니다."""
    payload = {
        "language": "invalid-lang",  # 잘못된 언어 코드
        "text": "",
    }

    response = client.post("/api/turn", json=payload)
    # 입력 검증 실패 시에도 200 OK 스트림으로 에러를 보낼 수도 있고,
    # 400 Bad Request를 보낼 수도 있음. 현재 구현은 200 OK + type: error 임.
    assert response.status_code == 200

    events = [json.loads(line) for line in response.iter_lines() if line]
    assert any(e["type"] == "error" for e in events)
    assert any(e["code"] == "VALIDATION_ERROR" for e in events)


def test_turn_streaming_deterministic_seed():
    """seed 파라미터 사용 시 결과가 결정적인지 테스트합니다."""
    payload = {
        "language": "en-US",
        "text": "Hello",
        "client": {"viewport_w": 1920, "viewport_h": 1080},
        "economy_snapshot": {"signal": 100, "memory_shard": 5},
    }

    # 동일한 시드로 두 번 요청
    seed = 12345

    def get_final_output(s):
        resp = client.post(f"/api/turn?seed={s}", json=payload)
        events = [json.loads(line) for line in resp.iter_lines() if line]
        return next(e["data"] for e in events if e["type"] == "final")

    output1 = get_final_output(seed)
    output2 = get_final_output(seed)

    assert output1 == output2
    assert output1["language"] == "en-US"


def test_turn_streaming_generation_fallback(monkeypatch):
    """생성 중 ValidationError 발생 시 안전한 폴백이 반환되는지 테스트합니다."""
    from pydantic import ValidationError

    from unknown_world.orchestrator.mock import MockOrchestrator

    def mock_generate_failure(self, turn_input):
        # Pydantic ValidationError를 수동으로 생성하는 것은 복잡하므로
        # 간단한 필드 검증 오류를 시뮬레이션하거나 직접 raise 함
        # 여기서는 테스트를 위해 임의의 필드 누락 등으로 발생한다고 가정
        raise ValidationError.from_exception_data(title="MockError", line_errors=[])

    monkeypatch.setattr(MockOrchestrator, "generate_turn_output", mock_generate_failure)

    payload = {
        "language": "ko-KR",
        "text": "테스트",
        "client": {"viewport_w": 1920, "viewport_h": 1080},
        "economy_snapshot": {"signal": 100, "memory_shard": 5},
    }

    response = client.post("/api/turn", json=payload)
    events = [json.loads(line) for line in response.iter_lines() if line]

    final_event = next(e for e in events if e["type"] == "final")
    turn_output = final_event["data"]

    # 폴백 응답의 특징 확인
    # RU-005-Q1: SSOT fallback은 모든 카테고리의 배지를 일관되게 포함 (RU-005-S1)
    badges = turn_output["agent_console"]["badges"]
    assert "schema_fail" in badges, "폴백은 schema_fail 배지를 포함해야 함"
    assert "economy_ok" in badges, "폴백은 economy_ok 배지를 포함해야 함 (비용 0)"
    assert "safety_ok" in badges, "폴백은 safety_ok 배지를 포함해야 함"
    assert "consistency_ok" in badges, "폴백은 consistency_ok 배지를 포함해야 함"
    assert turn_output["agent_console"]["repair_count"] >= 1
    assert "혼란" in turn_output["narrative"] or "confusion" in turn_output["narrative"]


def test_turn_streaming_repair_loop(monkeypatch):
    """검증 실패 시 repair 이벤트가 스트림에 포함되는지 테스트합니다 (RU-002)."""
    from pydantic import ValidationError

    from unknown_world.orchestrator.mock import MockOrchestrator

    # 첫 번째 호출에서 실패하여 repair 트리거 시뮬레이션
    # (실제 구현에서는 N회 재시도 로직이 turn.py에 있어야 함)
    call_count = 0

    def mock_generate_with_repair(self, turn_input):
        nonlocal call_count
        call_count += 1
        if call_count == 1:
            raise ValidationError.from_exception_data(title="MockSchemaError", line_errors=[])
        return orchestrator_orig_generate(self, turn_input)

    import unknown_world.orchestrator.mock as mock_mod

    orchestrator_orig_generate = mock_mod.MockOrchestrator.generate_turn_output
    monkeypatch.setattr(MockOrchestrator, "generate_turn_output", mock_generate_with_repair)

    payload = {
        "language": "ko-KR",
        "text": "리페어 테스트",
        "client": {"viewport_w": 1920, "viewport_h": 1080},
        "economy_snapshot": {"signal": 100, "memory_shard": 5},
    }

    response = client.post("/api/turn", json=payload)
    events = [json.loads(line) for line in response.iter_lines() if line]

    # RU-002 요구사항: repair 이벤트가 명시적으로 존재해야 함
    repair_events = [e for e in events if e["type"] == "repair"]
    assert len(repair_events) >= 1
    assert "attempt" in repair_events[0]
    assert repair_events[0]["attempt"] == 1
</file>

<file path="backend/tests/unit/orchestrator/test_mock_orchestrator.py">
"""Unknown World - MockOrchestrator 단위 테스트.

U-048[Mvp] 완료 기준 검증:
    - action_id 입력 시 "말했습니다" 대신 행동 로그 프리픽스 적용
    - click 입력 시 조사/탐색 행동 로그 프리픽스 적용
    - drop 입력 시 사용/조합 행동 로그 프리픽스 적용
    - free text 입력 시 입력/명령 행동 로그 프리픽스 적용 (Q1: Option B)
    - per-turn 결정적 RNG로 다양성 확보 (다른 입력 → 다른 결과)
    - 동일 입력 → 동일 결과 (재현성 유지)

참조:
    - vibe/unit-plans/U-048[Mvp].md
    - vibe/unit-runbooks/U-048-mock-narrative-improvement-runbook.md
"""

import random

import pytest

from unknown_world.models.turn import (
    Box2D,
    ClickInput,
    ClientInfo,
    DropInput,
    EconomySnapshot,
    Language,
    Theme,
    TurnInput,
    TurnOutput,
)
from unknown_world.orchestrator.mock import (
    EN_ACTION_LOG_PREFIXES,
    KO_ACTION_LOG_PREFIXES,
    InputType,
    MockOrchestrator,
    _compute_turn_seed,
    _detect_input_type,
    _format_action_log_prefix,
)

# =============================================================================
# 픽스처
# =============================================================================


@pytest.fixture
def base_client_info() -> ClientInfo:
    """기본 클라이언트 정보 픽스처."""
    return ClientInfo(viewport_w=1920, viewport_h=1080, theme=Theme.DARK)


@pytest.fixture
def base_economy_snapshot() -> EconomySnapshot:
    """기본 경제 스냅샷 픽스처."""
    return EconomySnapshot(signal=100, memory_shard=5)


@pytest.fixture
def ko_action_input(base_client_info, base_economy_snapshot) -> TurnInput:
    """한국어 액션 카드 입력 픽스처."""
    return TurnInput(
        language=Language.KO,
        text="문을 열어본다",
        action_id="action_1",
        client=base_client_info,
        economy_snapshot=base_economy_snapshot,
    )


@pytest.fixture
def ko_click_input(base_client_info, base_economy_snapshot) -> TurnInput:
    """한국어 클릭 입력 픽스처."""
    return TurnInput(
        language=Language.KO,
        click=ClickInput(object_id="obj_door"),
        client=base_client_info,
        economy_snapshot=base_economy_snapshot,
    )


@pytest.fixture
def ko_drop_input(base_client_info, base_economy_snapshot) -> TurnInput:
    """한국어 드롭 입력 픽스처."""
    return TurnInput(
        language=Language.KO,
        drop=DropInput(
            item_id="key_001",
            target_object_id="obj_lock",
            target_box_2d=Box2D(ymin=100, xmin=200, ymax=300, xmax=400),
        ),
        client=base_client_info,
        economy_snapshot=base_economy_snapshot,
    )


@pytest.fixture
def ko_free_text_input(base_client_info, base_economy_snapshot) -> TurnInput:
    """한국어 자유 텍스트 입력 픽스처."""
    return TurnInput(
        language=Language.KO,
        text="주변을 살펴본다",
        client=base_client_info,
        economy_snapshot=base_economy_snapshot,
    )


@pytest.fixture
def en_action_input(base_client_info, base_economy_snapshot) -> TurnInput:
    """영어 액션 카드 입력 픽스처."""
    return TurnInput(
        language=Language.EN,
        text="Open the door",
        action_id="action_1",
        client=base_client_info,
        economy_snapshot=base_economy_snapshot,
    )


# =============================================================================
# _detect_input_type 테스트
# =============================================================================


class TestDetectInputType:
    """입력 타입 감지 함수 테스트."""

    def test_detect_drop_input(self, ko_drop_input):
        """drop 입력 감지 테스트 (최고 우선순위)."""
        result = _detect_input_type(ko_drop_input)
        assert result == InputType.DROP

    def test_detect_click_input(self, ko_click_input):
        """click 입력 감지 테스트."""
        result = _detect_input_type(ko_click_input)
        assert result == InputType.CLICK

    def test_detect_action_input(self, ko_action_input):
        """action_id 입력 감지 테스트."""
        result = _detect_input_type(ko_action_input)
        assert result == InputType.ACTION

    def test_detect_free_text_input(self, ko_free_text_input):
        """free text 입력 감지 테스트."""
        result = _detect_input_type(ko_free_text_input)
        assert result == InputType.FREE_TEXT

    def test_priority_drop_over_click(self, base_client_info, base_economy_snapshot):
        """drop이 click보다 우선순위가 높은지 테스트."""
        turn_input = TurnInput(
            language=Language.KO,
            drop=DropInput(
                item_id="key_001",
                target_object_id="obj_lock",
                target_box_2d=Box2D(ymin=100, xmin=200, ymax=300, xmax=400),
            ),
            click=ClickInput(object_id="obj_door"),
            client=base_client_info,
            economy_snapshot=base_economy_snapshot,
        )
        result = _detect_input_type(turn_input)
        assert result == InputType.DROP

    def test_priority_click_over_action(self, base_client_info, base_economy_snapshot):
        """click이 action_id보다 우선순위가 높은지 테스트."""
        turn_input = TurnInput(
            language=Language.KO,
            click=ClickInput(object_id="obj_door"),
            action_id="action_1",
            text="문을 열어본다",
            client=base_client_info,
            economy_snapshot=base_economy_snapshot,
        )
        result = _detect_input_type(turn_input)
        assert result == InputType.CLICK

    def test_priority_action_over_free_text(self, ko_action_input):
        """action_id가 free text보다 우선순위가 높은지 테스트."""
        # ko_action_input은 action_id와 text 둘 다 있음
        result = _detect_input_type(ko_action_input)
        assert result == InputType.ACTION


# =============================================================================
# _compute_turn_seed 테스트
# =============================================================================


class TestComputeTurnSeed:
    """per-turn 시드 계산 함수 테스트."""

    def test_same_input_same_seed(self, ko_action_input):
        """동일 입력 → 동일 시드 (재현성)."""
        base_seed = 42
        seed1 = _compute_turn_seed(base_seed, ko_action_input)
        seed2 = _compute_turn_seed(base_seed, ko_action_input)
        assert seed1 == seed2

    def test_different_text_different_seed(self, base_client_info, base_economy_snapshot):
        """다른 텍스트 → 다른 시드 (다양성)."""
        base_seed = 42
        input1 = TurnInput(
            language=Language.KO,
            text="문을 열어본다",
            client=base_client_info,
            economy_snapshot=base_economy_snapshot,
        )
        input2 = TurnInput(
            language=Language.KO,
            text="주변을 탐색한다",
            client=base_client_info,
            economy_snapshot=base_economy_snapshot,
        )
        seed1 = _compute_turn_seed(base_seed, input1)
        seed2 = _compute_turn_seed(base_seed, input2)
        assert seed1 != seed2

    def test_different_action_id_different_seed(self, base_client_info, base_economy_snapshot):
        """다른 action_id → 다른 시드."""
        base_seed = 42
        input1 = TurnInput(
            language=Language.KO,
            action_id="action_1",
            client=base_client_info,
            economy_snapshot=base_economy_snapshot,
        )
        input2 = TurnInput(
            language=Language.KO,
            action_id="action_2",
            client=base_client_info,
            economy_snapshot=base_economy_snapshot,
        )
        seed1 = _compute_turn_seed(base_seed, input1)
        seed2 = _compute_turn_seed(base_seed, input2)
        assert seed1 != seed2

    def test_different_click_object_different_seed(self, base_client_info, base_economy_snapshot):
        """다른 클릭 오브젝트 → 다른 시드."""
        base_seed = 42
        input1 = TurnInput(
            language=Language.KO,
            click=ClickInput(object_id="obj_door"),
            client=base_client_info,
            economy_snapshot=base_economy_snapshot,
        )
        input2 = TurnInput(
            language=Language.KO,
            click=ClickInput(object_id="obj_chest"),
            client=base_client_info,
            economy_snapshot=base_economy_snapshot,
        )
        seed1 = _compute_turn_seed(base_seed, input1)
        seed2 = _compute_turn_seed(base_seed, input2)
        assert seed1 != seed2

    def test_different_drop_different_seed(self, base_client_info, base_economy_snapshot):
        """다른 드롭 정보 → 다른 시드."""
        base_seed = 42
        input1 = TurnInput(
            language=Language.KO,
            drop=DropInput(
                item_id="key_001",
                target_object_id="obj_lock",
                target_box_2d=Box2D(ymin=100, xmin=200, ymax=300, xmax=400),
            ),
            client=base_client_info,
            economy_snapshot=base_economy_snapshot,
        )
        input2 = TurnInput(
            language=Language.KO,
            drop=DropInput(
                item_id="sword_001",
                target_object_id="obj_enemy",
                target_box_2d=Box2D(ymin=100, xmin=200, ymax=300, xmax=400),
            ),
            client=base_client_info,
            economy_snapshot=base_economy_snapshot,
        )
        seed1 = _compute_turn_seed(base_seed, input1)
        seed2 = _compute_turn_seed(base_seed, input2)
        assert seed1 != seed2

    def test_seed_within_valid_range(self, ko_action_input):
        """시드가 유효한 범위 내인지 테스트."""
        base_seed = 42
        seed = _compute_turn_seed(base_seed, ko_action_input)
        assert 0 <= seed < 2**32


# =============================================================================
# _format_action_log_prefix 테스트
# =============================================================================


class TestFormatActionLogPrefix:
    """행동 로그 프리픽스 포맷 함수 테스트."""

    def test_ko_action_prefix(self, ko_action_input):
        """한국어 액션 프리픽스 테스트."""
        rng = random.Random(42)
        prefix = _format_action_log_prefix(rng, InputType.ACTION, ko_action_input, is_korean=True)

        # 한국어 액션 프리픽스 중 하나여야 함
        expected_patterns = ["[행동]", "[실행]", "[시도]"]
        assert any(pattern in prefix for pattern in expected_patterns)

    def test_ko_click_prefix(self, ko_click_input):
        """한국어 클릭 프리픽스 테스트."""
        rng = random.Random(42)
        prefix = _format_action_log_prefix(rng, InputType.CLICK, ko_click_input, is_korean=True)

        expected_patterns = ["[조사]", "[탐색]", "[상호작용]"]
        assert any(pattern in prefix for pattern in expected_patterns)
        # 오브젝트 ID는 여전히 포함되어야 함 (시스템 생성 ID이므로 언어 혼합 위험 없음)
        assert "obj_door" in prefix

    def test_ko_drop_prefix(self, ko_drop_input):
        """한국어 드롭 프리픽스 테스트."""
        rng = random.Random(42)
        prefix = _format_action_log_prefix(rng, InputType.DROP, ko_drop_input, is_korean=True)

        expected_patterns = ["[사용]", "[조합]", "[적용]"]
        assert any(pattern in prefix for pattern in expected_patterns)
        # 아이템 ID와 대상 ID는 포함되어야 함
        assert "key_001" in prefix
        assert "obj_lock" in prefix

    def test_ko_free_text_prefix(self, ko_free_text_input):
        """한국어 자유 텍스트 프리픽스 테스트."""
        rng = random.Random(42)
        prefix = _format_action_log_prefix(
            rng, InputType.FREE_TEXT, ko_free_text_input, is_korean=True
        )

        # U-062: [입력] 대신 [행동], [시도], [탐색] 사용
        expected_patterns = ["[행동]", "[시도]", "[탐색]"]
        assert any(pattern in prefix for pattern in expected_patterns)

    def test_en_action_prefix(self, en_action_input):
        """영어 액션 프리픽스 테스트."""
        rng = random.Random(42)
        prefix = _format_action_log_prefix(rng, InputType.ACTION, en_action_input, is_korean=False)

        expected_patterns = ["[ACTION]", "[EXECUTE]", "[ATTEMPT]"]
        assert any(pattern in prefix for pattern in expected_patterns)

    def test_deterministic_with_same_rng_state(self, ko_action_input):
        """동일 RNG 상태에서 결정적 결과 테스트."""
        prefix1 = _format_action_log_prefix(
            random.Random(42), InputType.ACTION, ko_action_input, is_korean=True
        )
        prefix2 = _format_action_log_prefix(
            random.Random(42), InputType.ACTION, ko_action_input, is_korean=True
        )
        assert prefix1 == prefix2


# =============================================================================
# MockOrchestrator 통합 테스트
# =============================================================================


class TestMockOrchestratorNarrativePrefix:
    """MockOrchestrator 내러티브 프리픽스 통합 테스트."""

    def test_action_input_no_said_ko(self, ko_action_input):
        """한국어 액션 입력 시 '말했습니다' 없음 테스트."""
        orchestrator = MockOrchestrator(seed=42)
        output = orchestrator.generate_turn_output(ko_action_input)

        assert isinstance(output, TurnOutput)
        assert "말했습니다" not in output.narrative
        assert "라고 말했습니다" not in output.narrative

        # 행동 로그 프리픽스가 있어야 함
        expected_prefixes = ["[행동]", "[실행]", "[시도]"]
        assert any(prefix in output.narrative for prefix in expected_prefixes)

    def test_click_input_no_said_ko(self, ko_click_input):
        """한국어 클릭 입력 시 '말했습니다' 없음 테스트."""
        orchestrator = MockOrchestrator(seed=42)
        output = orchestrator.generate_turn_output(ko_click_input)

        assert "말했습니다" not in output.narrative

        expected_prefixes = ["[조사]", "[탐색]", "[상호작용]"]
        assert any(prefix in output.narrative for prefix in expected_prefixes)
        # 오브젝트 ID 포함 확인
        assert "obj_door" in output.narrative

    def test_drop_input_no_said_ko(self, ko_drop_input):
        """한국어 드롭 입력 시 '말했습니다' 없음 테스트."""
        orchestrator = MockOrchestrator(seed=42)
        output = orchestrator.generate_turn_output(ko_drop_input)

        assert "말했습니다" not in output.narrative

        expected_prefixes = ["[사용]", "[조합]", "[적용]"]
        assert any(prefix in output.narrative for prefix in expected_prefixes)
        # 아이템 및 대상 ID 포함 확인
        assert "key_001" in output.narrative
        assert "obj_lock" in output.narrative

    def test_free_text_input_no_said_ko(self, ko_free_text_input):
        """한국어 자유 텍스트 입력 시 '말했습니다' 없음 테스트."""
        orchestrator = MockOrchestrator(seed=42)
        output = orchestrator.generate_turn_output(ko_free_text_input)

        assert "말했습니다" not in output.narrative

        # U-062: [행동], [시도], [탐색] 중 하나여야 함
        expected_prefixes = ["[행동]", "[시도]", "[탐색]"]
        assert any(prefix in output.narrative for prefix in expected_prefixes)

    def test_action_input_no_said_en(self, en_action_input):
        """영어 액션 입력 시 'You said' 없음 테스트."""
        orchestrator = MockOrchestrator(seed=42)
        output = orchestrator.generate_turn_output(en_action_input)

        assert "You said" not in output.narrative
        assert "said" not in output.narrative.lower() or "[" in output.narrative[:10]

        expected_prefixes = ["[ACTION]", "[EXECUTE]", "[ATTEMPT]"]
        assert any(prefix in output.narrative for prefix in expected_prefixes)

    def test_empty_text_no_prefix(self, base_client_info, base_economy_snapshot):
        """의미 없는 입력 시 프리픽스 없음 테스트."""
        turn_input = TurnInput(
            language=Language.KO,
            text="",  # 빈 텍스트
            client=base_client_info,
            economy_snapshot=base_economy_snapshot,
        )

        orchestrator = MockOrchestrator(seed=42)
        output = orchestrator.generate_turn_output(turn_input)

        # 빈 입력이므로 프리픽스가 없어야 함
        assert not output.narrative.startswith("[")

    def test_english_input_korean_session_passes_language_gate(
        self, base_client_info, base_economy_snapshot
    ):
        """U-062: 영어 입력 시에도 한국어 세션에서 LanguageGate를 통과하는지 테스트."""
        from unknown_world.validation.language_gate import validate_language_consistency

        turn_input = TurnInput(
            language=Language.KO,
            text="English instruction for a Korean session",
            client=base_client_info,
            economy_snapshot=base_economy_snapshot,
        )

        orchestrator = MockOrchestrator(seed=42)
        output = orchestrator.generate_turn_output(turn_input)

        # 1. 내러티브에 영어 입력이 포함되지 않아야 함
        assert "English instruction" not in output.narrative

        # 2. LanguageGate 검증 통과해야 함
        result = validate_language_consistency(output, Language.KO)
        assert result.is_valid is True, f"LanguageGate failed: {result.violations}"

    def test_korean_input_english_session_passes_language_gate(
        self, base_client_info, base_economy_snapshot
    ):
        """U-062: 한국어 입력 시에도 영어 세션에서 LanguageGate를 통과하는지 테스트."""
        from unknown_world.validation.language_gate import validate_language_consistency

        turn_input = TurnInput(
            language=Language.EN,
            text="영어 세션에 들어온 한국어 명령",
            client=base_client_info,
            economy_snapshot=base_economy_snapshot,
        )

        orchestrator = MockOrchestrator(seed=42)
        output = orchestrator.generate_turn_output(turn_input)

        # 1. 내러티브에 한국어 입력이 포함되지 않아야 함
        assert "한국어 명령" not in output.narrative

        # 2. LanguageGate 검증 통과해야 함
        result = validate_language_consistency(output, Language.EN)
        assert result.is_valid is True, f"LanguageGate failed: {result.violations}"


# =============================================================================
# 결정적 다양성 테스트
# =============================================================================


class TestDeterministicDiversity:
    """결정적 다양성 테스트."""

    def test_same_input_same_output(self, ko_action_input):
        """동일 입력 → 동일 출력 (재현성)."""
        orchestrator1 = MockOrchestrator(seed=42)
        orchestrator2 = MockOrchestrator(seed=42)

        output1 = orchestrator1.generate_turn_output(ko_action_input)
        output2 = orchestrator2.generate_turn_output(ko_action_input)

        assert output1.narrative == output2.narrative
        assert len(output1.ui.action_deck.cards) == len(output2.ui.action_deck.cards)

    def test_different_input_different_output(self, base_client_info, base_economy_snapshot):
        """다른 입력 → 다른 출력 (다양성)."""
        input1 = TurnInput(
            language=Language.KO,
            text="문을 열어본다",
            client=base_client_info,
            economy_snapshot=base_economy_snapshot,
        )
        input2 = TurnInput(
            language=Language.KO,
            text="주변을 탐색한다",
            client=base_client_info,
            economy_snapshot=base_economy_snapshot,
        )

        # 같은 seed의 오케스트레이터 사용
        orchestrator = MockOrchestrator(seed=42)

        output1 = orchestrator.generate_turn_output(input1)
        output2 = orchestrator.generate_turn_output(input2)

        # per-turn RNG이므로 다른 내러티브가 나와야 함
        # (프리픽스는 같을 수 있지만 본문이 달라질 확률이 높음)
        assert output1.narrative != output2.narrative

    def test_multiple_calls_deterministic(self, ko_action_input):
        """여러 번 호출해도 같은 결과 (동일 입력에 대해)."""
        orchestrator = MockOrchestrator(seed=42)

        outputs = [orchestrator.generate_turn_output(ko_action_input) for _ in range(3)]

        # 모든 출력이 동일해야 함
        for i in range(1, len(outputs)):
            assert outputs[0].narrative == outputs[i].narrative


# =============================================================================
# 스키마/인바리언트 테스트
# =============================================================================


class TestSchemaAndInvariants:
    """스키마 및 인바리언트 테스트."""

    def test_output_is_valid_turn_output(self, ko_action_input):
        """출력이 유효한 TurnOutput인지 테스트."""
        orchestrator = MockOrchestrator(seed=42)
        output = orchestrator.generate_turn_output(ko_action_input)

        assert isinstance(output, TurnOutput)
        assert output.language == Language.KO
        assert output.narrative is not None
        assert output.economy is not None
        assert output.safety is not None

    def test_economy_invariant_no_negative_balance(self, base_client_info):
        """경제 인바리언트: 잔액 음수 금지 (RULE-005)."""
        # 잔액이 매우 적은 경우
        economy_snapshot = EconomySnapshot(signal=1, memory_shard=0)
        turn_input = TurnInput(
            language=Language.KO,
            text="비싼 행동",
            client=base_client_info,
            economy_snapshot=economy_snapshot,
        )

        orchestrator = MockOrchestrator(seed=42)
        output = orchestrator.generate_turn_output(turn_input)

        # 잔액은 0 이상이어야 함
        assert output.economy.balance_after.signal >= 0
        assert output.economy.balance_after.memory_shard >= 0

    def test_coordinate_invariant_0_to_1000(self, ko_action_input):
        """좌표 인바리언트: 0~1000 범위 (RULE-009)."""
        orchestrator = MockOrchestrator(seed=42)
        output = orchestrator.generate_turn_output(ko_action_input)

        for obj in output.ui.objects:
            assert 0 <= obj.box_2d.ymin <= 1000
            assert 0 <= obj.box_2d.xmin <= 1000
            assert 0 <= obj.box_2d.ymax <= 1000
            assert 0 <= obj.box_2d.xmax <= 1000
            # ymin < ymax, xmin < xmax
            assert obj.box_2d.ymin < obj.box_2d.ymax
            assert obj.box_2d.xmin < obj.box_2d.xmax

    def test_language_consistency(self, ko_action_input, en_action_input):
        """언어 일관성 테스트 (RULE-006)."""
        orchestrator = MockOrchestrator(seed=42)

        ko_output = orchestrator.generate_turn_output(ko_action_input)
        en_output = orchestrator.generate_turn_output(en_action_input)

        assert ko_output.language == Language.KO
        assert en_output.language == Language.EN


# =============================================================================
# 템플릿 상수 테스트
# =============================================================================


class TestTemplateConstants:
    """템플릿 상수 검증 테스트."""

    def test_ko_prefixes_have_all_input_types(self):
        """한국어 프리픽스에 모든 입력 타입이 있는지 테스트."""
        for input_type in InputType:
            assert input_type in KO_ACTION_LOG_PREFIXES
            assert len(KO_ACTION_LOG_PREFIXES[input_type]) >= 1

    def test_en_prefixes_have_all_input_types(self):
        """영어 프리픽스에 모든 입력 타입이 있는지 테스트."""
        for input_type in InputType:
            assert input_type in EN_ACTION_LOG_PREFIXES
            assert len(EN_ACTION_LOG_PREFIXES[input_type]) >= 1

    def test_ko_prefixes_no_said(self):
        """한국어 프리픽스에 '말했습니다'가 없는지 테스트."""
        for _input_type, templates in KO_ACTION_LOG_PREFIXES.items():
            for template in templates:
                assert "말했습니다" not in template

    def test_en_prefixes_no_said(self):
        """영어 프리픽스에 'said'가 없는지 테스트."""
        for _input_type, templates in EN_ACTION_LOG_PREFIXES.items():
            for template in templates:
                assert "said" not in template.lower()
</file>

<file path="backend/tests/unit/orchestrator/test_u052_render_helpers.py">
"""U-052[Mvp]: 조건부 이미지 생성 제어 로직 단위 테스트.

이 테스트는 TurnOutput 내의 image_job을 분석하여 이미지 생성 여부를 판정하는
render_helpers.py의 기능들을 검증합니다.

테스트 항목:
    - extract_image_job: TurnOutput에서 ImageJob 추출 검증
    - should_generate_image: should_generate 플래그 및 프롬프트 유효성 검사
    - get_prompt_hash: 프롬프트 해싱 검증 (RULE-007)
    - can_afford_image_generation: 잔액 기반 비용 판정 검증 (RULE-005)
    - decide_image_generation: 종합 판정 로직 및 폴백 메시지 검증
"""

import pytest

from unknown_world.models.turn import (
    CurrencyAmount,
    EconomyOutput,
    EconomySnapshot,
    ImageJob,
    Language,
    RenderOutput,
    SafetyOutput,
    TurnOutput,
)
from unknown_world.orchestrator.stages.render_helpers import (
    IMAGE_GENERATION_COST_SIGNAL,
    can_afford_image_generation,
    decide_image_generation,
    extract_image_job,
    get_prompt_hash,
    should_generate_image,
)


@pytest.fixture
def base_turn_output():
    """기본 TurnOutput 객체를 생성하는 픽스처."""
    return TurnOutput(
        language=Language.KO,
        narrative="테스트 내러티브",
        economy=EconomyOutput(
            cost=CurrencyAmount(signal=5, memory_shard=0),
            balance_after=CurrencyAmount(signal=95, memory_shard=5),
        ),
        safety=SafetyOutput(blocked=False),
    )


def test_extract_image_job_exists(base_turn_output):
    """ImageJob이 존재하는 경우 정상적으로 추출하는지 확인."""
    image_job = ImageJob(should_generate=True, prompt="A beautiful sunset")
    base_turn_output.render = RenderOutput(image_job=image_job)

    extracted = extract_image_job(base_turn_output)
    assert extracted == image_job
    assert extracted.prompt == "A beautiful sunset"


def test_extract_image_job_none(base_turn_output):
    """ImageJob이 None인 경우 None을 반환하는지 확인."""
    base_turn_output.render = RenderOutput(image_job=None)
    assert extract_image_job(base_turn_output) is None


def test_should_generate_image_true():
    """모든 조건이 만족될 때 True를 반환하는지 확인."""
    job = ImageJob(should_generate=True, prompt="Valid prompt")
    assert should_generate_image(job) is True


def test_should_generate_image_false_flag():
    """should_generate 플래그가 False면 False를 반환하는지 확인."""
    job = ImageJob(should_generate=False, prompt="Valid prompt")
    assert should_generate_image(job) is False


def test_should_generate_image_empty_prompt():
    """프롬프트가 비어있으면 False를 반환하는지 확인."""
    job1 = ImageJob(should_generate=True, prompt="")
    job2 = ImageJob(should_generate=True, prompt="   ")
    assert should_generate_image(job1) is False
    assert should_generate_image(job2) is False


def test_should_generate_image_none():
    """ImageJob이 None이면 False를 반환하는지 확인."""
    assert should_generate_image(None) is False


def test_get_prompt_hash():
    """프롬프트 해시가 8자리이며 원문과 다른지 확인."""
    prompt = "A mysterious cave in the mountains"
    h = get_prompt_hash(prompt)
    assert len(h) == 8
    assert h != prompt
    # 동일 프롬프트는 동일 해시
    assert h == get_prompt_hash(prompt)
    # 다른 프롬프트는 다른 해시
    assert h != get_prompt_hash("Something else")


def test_can_afford_image_generation():
    """잔액 기반 비용 판정 확인."""
    cost = IMAGE_GENERATION_COST_SIGNAL  # 10

    # 충분
    snapshot_ok = EconomySnapshot(signal=cost, memory_shard=0)
    assert can_afford_image_generation(snapshot_ok) is True

    # 여유
    snapshot_rich = EconomySnapshot(signal=100, memory_shard=5)
    assert can_afford_image_generation(snapshot_rich) is True

    # 부족
    snapshot_poor = EconomySnapshot(signal=cost - 1, memory_shard=0)
    assert can_afford_image_generation(snapshot_poor) is False


def test_decide_image_generation_success(base_turn_output):
    """모든 조건이 충족되어 생성이 승인되는 케이스."""
    job = ImageJob(
        should_generate=True, prompt="A dragon flying over a castle", aspect_ratio="16:9"
    )
    base_turn_output.render = RenderOutput(image_job=job)
    economy = EconomySnapshot(signal=100, memory_shard=5)

    decision = decide_image_generation(base_turn_output, economy)

    assert decision.should_generate is True
    assert decision.reason == "all_conditions_met"
    assert decision.prompt_hash == get_prompt_hash(job.prompt)
    assert decision.aspect_ratio == "16:9"
    assert decision.estimated_cost_signal == IMAGE_GENERATION_COST_SIGNAL
    assert decision.fallback_message is None


def test_decide_image_generation_insufficient_balance(base_turn_output):
    """잔액 부족 시 FAST 폴백으로 무료 생성 (U-079)."""
    job = ImageJob(should_generate=True, prompt="A treasure chest")
    base_turn_output.render = RenderOutput(image_job=job)
    # 비용 10인데 잔액 5 → U-079: FAST 폴백
    economy = EconomySnapshot(signal=5, memory_shard=0)

    decision = decide_image_generation(base_turn_output, economy, language="ko-KR")

    assert decision.should_generate is True
    assert decision.reason == "low_balance_fast_fallback"
    assert decision.model_override == "FAST"
    assert decision.is_low_balance_fallback is True
    assert decision.estimated_cost_signal == 0
    assert decision.prompt_hash == get_prompt_hash(job.prompt)


def test_decide_image_generation_no_job(base_turn_output):
    """ImageJob이 없는 케이스."""
    base_turn_output.render = RenderOutput(image_job=None)
    economy = EconomySnapshot(signal=100, memory_shard=5)

    decision = decide_image_generation(base_turn_output, economy)

    assert decision.should_generate is False
    assert decision.reason == "no_image_job"


def test_decide_image_generation_empty_prompt(base_turn_output):
    """프롬프트가 비어있는 케이스."""
    job = ImageJob(should_generate=True, prompt=" ")
    base_turn_output.render = RenderOutput(image_job=job)
    economy = EconomySnapshot(signal=100, memory_shard=5)

    decision = decide_image_generation(base_turn_output, economy)

    assert decision.should_generate is False
    assert decision.reason == "empty_prompt"


def test_decide_image_generation_language_fallback(base_turn_output):
    """잔액 부족 시 FAST 폴백으로 생성 - 언어 무관 (U-079)."""
    job = ImageJob(should_generate=True, prompt="Gold coins")
    base_turn_output.render = RenderOutput(image_job=job)
    economy = EconomySnapshot(signal=0, memory_shard=0)

    # 한국어 - U-079: FAST 폴백 (fallback_message 없음, 생성 허용)
    decision_ko = decide_image_generation(base_turn_output, economy, language="ko-KR")
    assert decision_ko.should_generate is True
    assert decision_ko.reason == "low_balance_fast_fallback"
    assert decision_ko.model_override == "FAST"
    assert decision_ko.is_low_balance_fallback is True

    # 영어 - 동일한 FAST 폴백
    decision_en = decide_image_generation(base_turn_output, economy, language="en-US")
    assert decision_en.should_generate is True
    assert decision_en.reason == "low_balance_fast_fallback"
    assert decision_en.model_override == "FAST"
</file>

<file path="backend/tests/unit/orchestrator/test_u053_render_async.py">
"""U-053[Mvp]: 비동기 이미지 생성 및 결과 데이터 동기화 테스트.

render_stage에서 실제 이미지 생성기를 호출하고
결과(URL, ID 등)가 TurnOutput에 올바르게 동기화되는지 검증합니다.
"""

from unittest.mock import AsyncMock, MagicMock

import pytest

from unknown_world.models.turn import (
    ClientInfo,
    CurrencyAmount,
    EconomyOutput,
    EconomySnapshot,
    ImageJob,
    Language,
    RenderOutput,
    SafetyOutput,
    TurnInput,
    TurnOutput,
)
from unknown_world.orchestrator.stages.render import render_stage
from unknown_world.orchestrator.stages.types import PipelineContext
from unknown_world.services.image_generation import (
    ImageGenerationResponse,
    ImageGenerationStatus,
)


@pytest.fixture
def mock_emit():
    """이벤트 emit을 위한 모의 함수."""
    return AsyncMock()


@pytest.fixture
def mock_generator():
    """이미지 생성기 모의 객체."""
    generator = MagicMock()
    generator.is_available.return_value = True
    # 기본적으로 성공 응답을 반환하도록 설정
    generator.generate = AsyncMock(
        return_value=ImageGenerationResponse(
            status=ImageGenerationStatus.COMPLETED,
            image_id="test_img_123",
            image_url="http://localhost/images/test_img_123.png",
            generation_time_ms=1200,
        )
    )
    return generator


@pytest.mark.asyncio
async def test_render_stage_sync_success(mock_emit, mock_generator):
    """이미지 생성 성공 시 TurnOutput.render에 데이터가 동기화되는지 확인."""
    # 1. 준비
    turn_input = TurnInput(
        language=Language.KO,
        text="숲으로 간다",
        economy_snapshot=EconomySnapshot(signal=100, memory_shard=5),
        client=ClientInfo(viewport_w=1920, viewport_h=1080),
    )

    # 초기 상태에서는 image_url이 None
    turn_output = TurnOutput(
        language=Language.KO,
        narrative="어두운 숲이다.",
        economy=EconomyOutput(
            cost=CurrencyAmount(signal=5, memory_shard=0),
            balance_after=CurrencyAmount(signal=95, memory_shard=5),
        ),
        safety=SafetyOutput(blocked=False),
        render=RenderOutput(
            image_job=ImageJob(should_generate=True, prompt="A dark forest", aspect_ratio="16:9")
        ),
    )

    ctx = PipelineContext(
        turn_input=turn_input,
        economy_snapshot=CurrencyAmount(signal=100, memory_shard=5),
        output=turn_output,
        image_generator=mock_generator,
    )

    # 2. 실행
    result_ctx = await render_stage(ctx, emit=mock_emit)

    # 3. 검증
    # generator.generate가 호출되었는지 확인
    mock_generator.generate.assert_called_once()

    # TurnOutput.render에 데이터가 반영되었는지 확인
    assert result_ctx.output.render.image_url == "http://localhost/images/test_img_123.png"
    assert result_ctx.output.render.image_id == "test_img_123"
    assert result_ctx.output.render.generation_time_ms == 1200


@pytest.mark.asyncio
async def test_render_stage_generator_failure(mock_emit, mock_generator):
    """이미지 생성 실패 시 TurnOutput이 변경되지 않는지 확인."""
    # 1. 준비 - 실패 응답 설정
    mock_generator.generate.return_value = ImageGenerationResponse(
        status=ImageGenerationStatus.FAILED,
        message="API Error",
    )

    turn_input = TurnInput(
        language=Language.KO,
        text="테스트",
        economy_snapshot=EconomySnapshot(signal=100, memory_shard=5),
        client=ClientInfo(viewport_w=1920, viewport_h=1080),
    )

    turn_output = TurnOutput(
        language=Language.KO,
        narrative="테스트 내러티브",
        economy=EconomyOutput(
            cost=CurrencyAmount(signal=5, memory_shard=0),
            balance_after=CurrencyAmount(signal=95, memory_shard=5),
        ),
        safety=SafetyOutput(blocked=False),
        render=RenderOutput(image_job=ImageJob(should_generate=True, prompt="Test prompt")),
    )

    ctx = PipelineContext(
        turn_input=turn_input,
        economy_snapshot=CurrencyAmount(signal=100, memory_shard=5),
        output=turn_output,
        image_generator=mock_generator,
    )

    # 2. 실행
    result_ctx = await render_stage(ctx, emit=mock_emit)

    # 3. 검증
    assert mock_generator.generate.assert_called_once
    # 실패했으므로 image_url은 여전히 None이어야 함
    assert result_ctx.output.render.image_url is None


@pytest.mark.asyncio
async def test_render_stage_exception_handling(mock_emit, mock_generator):
    """이미지 생성 중 예외 발생 시 안전하게 처리되는지 확인."""
    # 1. 준비 - 예외 발생 설정
    mock_generator.generate.side_effect = Exception("Network Timeout")

    turn_input = TurnInput(
        language=Language.KO,
        text="테스트",
        economy_snapshot=EconomySnapshot(signal=100, memory_shard=5),
        client=ClientInfo(viewport_w=1920, viewport_h=1080),
    )

    turn_output = TurnOutput(
        language=Language.KO,
        narrative="테스트 내러티브",
        economy=EconomyOutput(
            cost=CurrencyAmount(signal=5, memory_shard=0),
            balance_after=CurrencyAmount(signal=95, memory_shard=5),
        ),
        safety=SafetyOutput(blocked=False),
        render=RenderOutput(image_job=ImageJob(should_generate=True, prompt="Test prompt")),
    )

    ctx = PipelineContext(
        turn_input=turn_input,
        economy_snapshot=CurrencyAmount(signal=100, memory_shard=5),
        output=turn_output,
        image_generator=mock_generator,
    )

    # 2. 실행 & 검증 (예외가 밖으로 던져지지 않아야 함)
    result_ctx = await render_stage(ctx, emit=mock_emit)

    assert mock_generator.generate.assert_called_once
    assert result_ctx.output.render.image_url is None
</file>

<file path="backend/tests/unit/orchestrator/test_u069_model_tiering.py">
"""Unknown World - U-069 모델 티어링(FAST/QUALITY) 단위 테스트.

검증 항목:
    - 기본 모델이 FAST인지 확인
    - 특정 action_id 입력 시 QUALITY 모델로 전환되는지 확인
    - 특정 키워드 포함 시 QUALITY 모델로 전환되는지 확인
    - 모델 선택에 따른 비용 배수(cost_multiplier)가 정확히 반영되는지 확인
"""

from unittest.mock import AsyncMock, patch

import pytest

from unknown_world.config.models import ModelLabel
from unknown_world.models.turn import (
    ClientInfo,
    EconomySnapshot,
    Language,
    Theme,
    TurnInput,
)
from unknown_world.orchestrator.generate_turn_output import (
    GenerationStatus,
    TurnOutputGenerator,
)
from unknown_world.services.genai_client import GenerateResponse


@pytest.fixture
def turn_input_base() -> TurnInput:
    """기본 턴 입력 픽스처."""
    return TurnInput(
        language=Language.KO,
        text="주변을 둘러본다",
        client=ClientInfo(viewport_w=1920, viewport_h=1080, theme=Theme.DARK),
        economy_snapshot=EconomySnapshot(signal=100, memory_shard=5),
    )


def test_select_text_model_default(turn_input_base):
    """기본 입력 시 QUALITY 모델이 선택되는지 테스트 (U-127)."""
    generator = TurnOutputGenerator()
    label, multiplier = generator._select_text_model(turn_input_base)

    assert label == ModelLabel.QUALITY
    assert multiplier == 2.0


def test_select_text_model_by_action_id(turn_input_base):
    """QUALITY 트리거 action_id 입력 시 QUALITY 모델이 선택되는지 테스트."""
    generator = TurnOutputGenerator()

    # QUALITY 트리거 action_id 설정
    turn_input_base.action_id = "deep_investigate"
    label, multiplier = generator._select_text_model(turn_input_base)

    assert label == ModelLabel.QUALITY
    assert multiplier == 2.0


def test_select_text_model_by_keyword(turn_input_base):
    """QUALITY 트리거 키워드 포함 시 QUALITY 모델이 선택되는지 테스트."""
    generator = TurnOutputGenerator()

    # QUALITY 트리거 키워드 포함
    turn_input_base.text = "이 단서를 자세히 살펴본다"
    label, multiplier = generator._select_text_model(turn_input_base)

    assert label == ModelLabel.QUALITY
    assert multiplier == 2.0


def test_select_text_model_by_keyword_english(turn_input_base):
    """영문 QUALITY 트리거 키워드 포함 시 QUALITY 모델이 선택되는지 테스트."""
    generator = TurnOutputGenerator()

    # 영문 QUALITY 트리거 키워드 포함
    turn_input_base.text = "scrutinize the evidence"
    label, multiplier = generator._select_text_model(turn_input_base)

    assert label == ModelLabel.QUALITY
    assert multiplier == 2.0


@pytest.mark.asyncio
async def test_generate_reflects_model_tiering(turn_input_base):
    """generate 메서드 호출 시 모델 티어링이 결과에 반영되는지 테스트."""
    generator = TurnOutputGenerator(force_mock=True)
    turn_input_base.action_id = "정밀조사"  # QUALITY 트리거

    # Mock 응답
    mock_response_text = '{"language": "ko-KR", "narrative": "정밀 조사 결과입니다.", "economy": {"cost": {"signal": 10, "memory_shard": 0}, "balance_after": {"signal": 90, "memory_shard": 5}}, "safety": {"blocked": false}, "ui": {"action_deck": {"cards": []}, "objects": []}, "world": {"rules_changed": [], "inventory_added": [], "inventory_removed": [], "quests_updated": [], "memory_pins": []}, "agent_console": {"current_phase": "commit", "badges": [], "repair_count": 0, "model_label": "QUALITY"}}'
    mock_response = GenerateResponse(text=mock_response_text, model_label="QUALITY")

    with patch(
        "unknown_world.orchestrator.generate_turn_output.get_genai_client"
    ) as mock_get_client:
        mock_client = AsyncMock()
        mock_client.generate.return_value = mock_response
        mock_get_client.return_value = mock_client

        result = await generator.generate(turn_input_base)

        assert result.status == GenerationStatus.SUCCESS
        assert result.model_label == ModelLabel.QUALITY
        assert result.cost_multiplier == 2.0

        # QUALITY 모델 ID로 호출되었는지 확인
        call_args = mock_client.generate.call_args[0][0]
        assert call_args.model_label == ModelLabel.QUALITY
</file>

<file path="backend/tests/unit/services/test_genai_client.py">
import os
from unittest.mock import AsyncMock, MagicMock, patch

import pytest

from unknown_world.config.models import (
    MODEL_FAST,
    MODEL_IMAGE,
    MODEL_QUALITY,
    MODEL_VISION,
    ModelLabel,
    get_model_id,
)
from unknown_world.services.genai_client import (
    ENV_GOOGLE_API_KEY,
    ENV_UW_MODE,
    GenAIClient,
    GenAIMode,
    GenerateRequest,
    GenerateResponse,
    MockGenAIClient,
    get_genai_client,
    reset_genai_client,
)


def test_model_id_mapping():
    """ModelLabel이 tech-stack.md의 ID와 올바르게 매핑되는지 확인합니다."""
    assert get_model_id(ModelLabel.FAST) == MODEL_FAST
    assert get_model_id(ModelLabel.QUALITY) == MODEL_QUALITY
    assert get_model_id(ModelLabel.IMAGE) == MODEL_IMAGE
    assert get_model_id(ModelLabel.VISION) == MODEL_VISION

    assert MODEL_FAST == "gemini-3-flash-preview"
    assert MODEL_QUALITY == "gemini-3-pro-preview"
    assert MODEL_IMAGE == "gemini-3-pro-image-preview"


def test_get_genai_client_mock_mode():
    """UW_MODE=mock일 때 MockGenAIClient가 반환되는지 확인합니다."""
    reset_genai_client()
    with patch.dict(os.environ, {ENV_UW_MODE: "mock"}):
        client = get_genai_client(force_new=True)
        assert isinstance(client, MockGenAIClient)
        assert client.mode == GenAIMode.MOCK


@pytest.mark.asyncio
async def test_mock_client_generate():
    """MockGenAIClient의 generate 메서드 동작을 확인합니다."""
    client = MockGenAIClient()
    request = GenerateRequest(prompt="test prompt", model_label=ModelLabel.FAST)
    response = await client.generate(request)

    assert isinstance(response, GenerateResponse)
    assert "[Mock Response]" in response.text
    assert response.model_label == ModelLabel.FAST
    assert "total_tokens" in response.usage


@pytest.mark.asyncio
async def test_mock_client_generate_stream():
    """MockGenAIClient의 generate_stream 메서드 동작을 확인합니다."""
    client = MockGenAIClient()
    request = GenerateRequest(prompt="test prompt", model_label=ModelLabel.QUALITY)

    chunks = []
    async for chunk in client.generate_stream(request):
        chunks.append(chunk)

    assert len(chunks) > 0
    assert any(ModelLabel.QUALITY in c for c in chunks)


def test_singleton_pattern():
    """get_genai_client가 싱글톤으로 동작하는지 확인합니다."""
    reset_genai_client()
    with patch.dict(os.environ, {ENV_UW_MODE: "mock"}):
        client1 = get_genai_client()
        client2 = get_genai_client()
        assert client1 is client2


def test_genai_client_initialization():
    """GenAIClient(real)가 API 키로 SDK를 올바르게 초기화하는지 확인합니다."""
    with patch("google.genai.Client") as mock_genai_client:
        api_key = "test-api-key"
        with patch.dict(os.environ, {ENV_GOOGLE_API_KEY: api_key}):
            client = GenAIClient()

            # genai.Client가 api_key와 함께 호출되었는지 확인
            mock_genai_client.assert_called_once_with(api_key=api_key)
            assert client.is_available() is True


@pytest.mark.asyncio
async def test_genai_client_generate_real_call():
    """GenAIClient가 SDK의 generate_content를 올바르게 호출하는지 확인합니다."""
    with patch("google.genai.Client") as mock_client_class:
        mock_instance = mock_client_class.return_value
        # mock aio.models.generate_content
        mock_response = MagicMock()
        mock_response.text = "Actual response"
        mock_response.candidates = [MagicMock(finish_reason="STOP")]
        mock_response.usage_metadata = MagicMock(
            prompt_token_count=10, candidates_token_count=20, total_token_count=30
        )

        mock_instance.aio.models.generate_content = AsyncMock(return_value=mock_response)

        api_key = "test-api-key"
        with patch.dict(os.environ, {ENV_GOOGLE_API_KEY: api_key}):
            client = GenAIClient()
            request = GenerateRequest(
                prompt="hello", model_label=ModelLabel.QUALITY, max_tokens=100
            )

            response = await client.generate(request)

            # U-060: 호출 인자 확인
            mock_instance.aio.models.generate_content.assert_called_once()
            call_kwargs = mock_instance.aio.models.generate_content.call_args.kwargs
            assert call_kwargs["model"] == MODEL_QUALITY
            assert call_kwargs["contents"] == "hello"
            # config는 GenerateContentConfig 객체이므로 속성 검증
            config = call_kwargs["config"]
            assert config is not None
            assert config.max_output_tokens == 100
            assert response.text == "Actual response"
            assert response.usage["total_tokens"] == 30


def test_genai_client_initialization_failure():
    """인증 오류 등으로 SDK 초기화 실패 시 동작을 확인합니다."""
    with patch("google.genai.Client", side_effect=Exception("Auth error")):
        client = GenAIClient()
        assert client.is_available() is False
        assert client.mode == GenAIMode.REAL


def test_get_genai_client_force_new():
    """force_new=True일 때 새 인스턴스가 생성되는지 확인합니다."""
    reset_genai_client()
    with patch.dict(os.environ, {ENV_UW_MODE: "mock"}):
        client1 = get_genai_client()
        client2 = get_genai_client(force_new=True)
        assert client1 is not client2


@pytest.mark.asyncio
async def test_genai_client_generate_stream_real_call():
    """GenAIClient가 스트리밍 호출을 올바르게 수행하는지 확인합니다."""
    with patch("google.genai.Client") as mock_client_class:
        mock_instance = mock_client_class.return_value

        # mock aio.models.generate_content_stream
        async def mock_stream():
            yield MagicMock(text="chunk1")
            yield MagicMock(text="chunk2")

        mock_instance.aio.models.generate_content_stream = AsyncMock(return_value=mock_stream())

        api_key = "test-api-key"
        with patch.dict(os.environ, {ENV_GOOGLE_API_KEY: api_key}):
            client = GenAIClient()
            request = GenerateRequest(prompt="hello", model_label=ModelLabel.FAST)

            chunks = []
            async for chunk in client.generate_stream(request):
                chunks.append(chunk)

            assert chunks == ["chunk1", "chunk2"]
            mock_instance.aio.models.generate_content_stream.assert_called_once()


@pytest.mark.asyncio
async def test_genai_client_unavailable_raises_error():
    """사용 불가능한 클라이언트 호출 시 RuntimeError가 발생하는지 확인합니다."""
    with patch("google.genai.Client", side_effect=Exception("Init error")):
        client = GenAIClient()
        assert client.is_available() is False

        request = GenerateRequest(prompt="hi")
        with pytest.raises(RuntimeError, match="초기화되지 않았습니다"):
            await client.generate(request)

        with pytest.raises(RuntimeError, match="초기화되지 않았습니다"):
            async for _ in client.generate_stream(request):
                pass


@pytest.mark.asyncio
async def test_genai_client_full_config():
    """max_tokens와 temperature가 SDK 호출 시 올바르게 전달되는지 확인합니다."""
    with patch("google.genai.Client") as mock_client_class:
        mock_instance = mock_client_class.return_value
        mock_instance.aio.models.generate_content = AsyncMock(return_value=MagicMock(text="ok"))

        async def mock_stream():
            yield MagicMock(text="ok")

        mock_instance.aio.models.generate_content_stream = AsyncMock(return_value=mock_stream())

        api_key = "test-api-key"
        with patch.dict(os.environ, {ENV_GOOGLE_API_KEY: api_key}):
            client = GenAIClient()
            request = GenerateRequest(prompt="hi", max_tokens=50, temperature=0.7)

            # generate 호출 검증
            # U-060: GenerateContentConfig 객체로 전달되므로 타입 + 핵심 속성 검증
            await client.generate(request)
            mock_instance.aio.models.generate_content.assert_called_once()
            gen_call_kwargs = mock_instance.aio.models.generate_content.call_args.kwargs
            assert gen_call_kwargs["model"] == MODEL_FAST
            assert gen_call_kwargs["contents"] == "hi"
            gen_config = gen_call_kwargs["config"]
            assert gen_config is not None
            assert gen_config.max_output_tokens == 50
            assert gen_config.temperature == 0.7

            # generate_stream 호출 검증
            async for _ in client.generate_stream(request):
                pass
            mock_instance.aio.models.generate_content_stream.assert_called_once()
            stream_call_kwargs = mock_instance.aio.models.generate_content_stream.call_args.kwargs
            assert stream_call_kwargs["model"] == MODEL_FAST
            assert stream_call_kwargs["contents"] == "hi"
            stream_config = stream_call_kwargs["config"]
            assert stream_config is not None
            assert stream_config.max_output_tokens == 50
            assert stream_config.temperature == 0.7


def test_get_genai_client_real_init_failure_fallback():
    """실제 클라이언트 초기화 실패 시 Mock 클라이언트로 폴백되는지 확인합니다."""
    reset_genai_client()
    with (
        patch.dict(os.environ, {ENV_UW_MODE: "real"}),
        patch("unknown_world.services.genai_client.GenAIClient.is_available", return_value=False),
    ):
        client = get_genai_client(force_new=True)
        assert isinstance(client, MockGenAIClient)


def test_reset_genai_client():
    """reset_genai_client가 캐시를 올바르게 비우는지 확인합니다."""
    reset_genai_client()
    with patch.dict(os.environ, {ENV_UW_MODE: "mock"}):
        client1 = get_genai_client()
        reset_genai_client()
        client2 = get_genai_client()
        assert client1 is not client2


def test_mock_client_is_available():
    """MockGenAIClient가 항상 사용 가능한지 확인합니다."""
    client = MockGenAIClient()
    assert client.is_available() is True


def test_get_genai_client_invalid_mode():
    """유효하지 않은 UW_MODE일 때 기본값(REAL)으로 동작하는지 확인합니다."""
    reset_genai_client()
    with (
        patch.dict(os.environ, {ENV_UW_MODE: "invalid"}),
        patch(
            "unknown_world.services.genai_client.GenAIClient", return_value=MagicMock()
        ) as mock_real,
    ):
        get_genai_client(force_new=True)
        mock_real.assert_called_once()


def test_get_genai_client_force_mock():
    """force_mock=True일 때 환경변수와 무관하게 Mock 클라이언트를 반환하는지 확인합니다."""
    reset_genai_client()
    with patch.dict(os.environ, {ENV_UW_MODE: "real"}):
        client = get_genai_client(force_mock=True, force_new=True)
        assert isinstance(client, MockGenAIClient)
</file>

<file path="backend/tests/unit/services/test_image_extraction.py">
"""Unknown World - 이미지 추출 로직 단위 테스트."""

from unittest.mock import MagicMock

import pytest

from unknown_world.services.image_generation import ImageGenerator


@pytest.fixture
def generator():
    """ImageGenerator 인스턴스 픽스처 (클라이언트 초기화 생략)."""
    with MagicMock():
        # Client 초기화를 모킹하여 실제 Vertex AI 연결 방지
        return ImageGenerator()


def test_extract_image_success(generator):
    """정상적인 응답에서 이미지 바이트를 성공적으로 추출하는지 테스트."""
    # Gemini 응답 구조 모킹
    mock_part = MagicMock()
    mock_part.text = "A beautiful sunset"
    mock_part.inline_data.data = b"fake-image-bytes"

    mock_content = MagicMock()
    mock_content.parts = [mock_part]

    mock_candidate = MagicMock()
    mock_candidate.content = mock_content

    mock_response = MagicMock()
    mock_response.candidates = [mock_candidate]

    image_bytes = generator._extract_image_from_response(mock_response)

    assert image_bytes == b"fake-image-bytes"


def test_extract_image_text_only(generator):
    """텍스트만 포함된 응답에서 None을 반환하는지 테스트."""
    mock_part = MagicMock()
    mock_part.text = "Thinking about the image..."
    mock_part.inline_data = None  # 이미지 없음

    mock_content = MagicMock()
    mock_content.parts = [mock_part]

    mock_candidate = MagicMock()
    mock_candidate.content = mock_content

    mock_response = MagicMock()
    mock_response.candidates = [mock_candidate]

    image_bytes = generator._extract_image_from_response(mock_response)

    assert image_bytes is None


def test_extract_image_empty_response(generator):
    """비어있는 응답에서 None을 반환하는지 테스트."""
    mock_response = MagicMock()
    mock_response.candidates = []

    image_bytes = generator._extract_image_from_response(mock_response)

    assert image_bytes is None


def test_extract_image_multiple_parts(generator):
    """여러 파트 중 이미지가 있는 파트를 올바르게 찾는지 테스트."""
    mock_part_text = MagicMock()
    mock_part_text.text = "Here is your image"
    mock_part_text.inline_data = None

    mock_part_image = MagicMock()
    mock_part_image.inline_data.data = b"image-data"

    mock_content = MagicMock()
    mock_content.parts = [mock_part_text, mock_part_image]

    mock_candidate = MagicMock()
    mock_candidate.content = mock_content

    mock_response = MagicMock()
    mock_response.candidates = [mock_candidate]

    image_bytes = generator._extract_image_from_response(mock_response)

    assert image_bytes == b"image-data"


def test_extract_image_malformed_part(generator):
    """필드가 누락된 잘못된 형식의 파트를 안전하게 건너뛰는지 테스트."""
    mock_part = MagicMock(spec=[])  # 아무 속성도 없는 객체

    mock_content = MagicMock()
    mock_content.parts = [mock_part]

    mock_candidate = MagicMock()
    mock_candidate.content = mock_content

    mock_response = MagicMock()
    mock_response.candidates = [mock_candidate]

    # AttributeError 등이 발생하지 않고 None을 반환해야 함
    image_bytes = generator._extract_image_from_response(mock_response)

    assert image_bytes is None
</file>

<file path="backend/tests/unit/services/test_image_generation.py">
"""Unknown World - 이미지 생성 서비스 단위 테스트."""

from unittest.mock import MagicMock, patch

import pytest

from unknown_world.services.image_generation import (
    ImageGenerationRequest,
    ImageGenerationStatus,
    ImageGenerator,
    MockImageGenerator,
    get_image_generator,
    reset_image_generator,
)


@pytest.fixture
def temp_output_dir(tmp_path):
    """임시 출력 디렉토리 픽스처."""
    return tmp_path / "test_images"


@pytest.mark.asyncio
async def test_mock_image_generator_success(temp_output_dir):
    """Mock 이미지 생성기 성공 케이스 테스트."""
    generator = MockImageGenerator(output_dir=temp_output_dir)
    request = ImageGenerationRequest(
        prompt="A beautiful sunset over a cyberpunk city",
        aspect_ratio="1:1",
        image_size="1024x1024",
    )

    response = await generator.generate(request)

    assert response.status == ImageGenerationStatus.COMPLETED
    assert response.image_id is not None
    assert response.image_url is not None
    assert (temp_output_dir / f"{response.image_id}.png").exists()


@pytest.mark.asyncio
async def test_image_generator_initialization_failure():
    """실제 이미지 생성기 초기화 실패 시 처리 테스트."""
    with patch("google.genai.Client", side_effect=Exception("Auth error")):
        generator = ImageGenerator()
        assert generator.is_available() is False


@pytest.mark.asyncio
async def test_get_image_generator_singleton():
    """팩토리 함수를 통한 싱글톤 인스턴스 반환 테스트."""
    reset_image_generator()
    gen1 = get_image_generator(force_mock=True)
    gen2 = get_image_generator(force_mock=True)

    assert gen1 is gen2


@pytest.mark.asyncio
async def test_image_request_validation():
    """이미지 생성 요청 검증 로직 테스트."""
    from unknown_world.services.image_generation import validate_image_request

    # 성공 케이스
    valid_request = ImageGenerationRequest(prompt="Test prompt")
    assert validate_image_request(valid_request) is None

    # 실패 케이스: 지원하지 않는 크기
    invalid_size = ImageGenerationRequest(prompt="Test", image_size="invalid")
    assert validate_image_request(invalid_size) == "지원하지 않는 이미지 크기: invalid"

    # 실패 케이스: 너무 짧은 프롬프트
    short_prompt = ImageGenerationRequest(prompt="A")
    assert validate_image_request(short_prompt) == "프롬프트가 너무 짧습니다."


@pytest.mark.asyncio
async def test_image_generator_model_tiering(temp_output_dir):
    """모델 티어링(FAST/QUALITY) 라벨 처리를 테스트합니다."""
    # MockImageGenerator는 model_label을 로깅하지만 동작은 동일함
    generator = MockImageGenerator(output_dir=temp_output_dir)

    # 1. FAST 모델 요청
    fast_request = ImageGenerationRequest(
        prompt="Fast preview",
        model_label="FAST",
    )
    fast_response = await generator.generate(fast_request)
    assert fast_response.status == ImageGenerationStatus.COMPLETED

    # 2. QUALITY 모델 요청
    quality_request = ImageGenerationRequest(
        prompt="Quality image",
        model_label="QUALITY",
    )
    quality_response = await generator.generate(quality_request)
    assert quality_response.status == ImageGenerationStatus.COMPLETED


@pytest.mark.asyncio
async def test_image_generator_real_model_selection():
    """실제 ImageGenerator에서 model_label에 따른 모델 ID 선택을 테스트합니다."""
    from unittest.mock import AsyncMock

    from unknown_world.config.models import ModelLabel, get_model_id

    # Mocking google.genai.Client to avoid real API calls
    with (
        patch("google.genai.Client") as mock_client_class,
        patch.dict("os.environ", {"GOOGLE_API_KEY": "test-api-key"}),
    ):
        mock_client = mock_client_class.return_value
        # aio.models.generate_content 모킹
        # 이미지 추출 성공을 위해 텍스트 + 이미지 데이터를 포함한 mock 응답 필요
        mock_response = MagicMock()
        mock_response.candidates = [
            MagicMock(
                content=MagicMock(
                    parts=[MagicMock(inline_data=MagicMock(data=b"fake-image-bytes"))]
                )
            )
        ]
        mock_gen = AsyncMock(return_value=mock_response)
        mock_client.aio.models.generate_content = mock_gen

        generator = ImageGenerator()
        # generator._client가 mock_client를 가리키도록 설정됨

        # 1. FAST 요청
        await generator.generate(ImageGenerationRequest(prompt="test", model_label="FAST"))
        # IMAGE_FAST 모델 ID가 사용되었는지 확인
        expected_fast_id = get_model_id(ModelLabel.IMAGE_FAST)
        args, kwargs = mock_gen.call_args
        assert kwargs["model"] == expected_fast_id

        # 2. QUALITY 요청
        await generator.generate(ImageGenerationRequest(prompt="test", model_label="QUALITY"))
        # IMAGE 모델 ID가 사용되었는지 확인
        expected_quality_id = get_model_id(ModelLabel.IMAGE)
        args, kwargs = mock_gen.call_args
        assert kwargs["model"] == expected_quality_id
</file>

<file path="backend/tests/unit/services/test_u075_verification.py">
from unittest.mock import AsyncMock, MagicMock, patch

import pytest

from unknown_world.models.turn import (
    CurrencyAmount,
    EconomyOutput,
    InventoryItemData,
    Language,
    SafetyOutput,
    TurnOutput,
    WorldDelta,
)
from unknown_world.services.item_icon_generator import (
    IconGenerationRequest,
    ItemIconGenerator,
)


@pytest.fixture
def mock_image_generator():
    generator = MagicMock()
    generator.generate = AsyncMock()
    return generator


@pytest.fixture
def icon_generator(mock_image_generator):
    return ItemIconGenerator(image_generator=mock_image_generator)


@pytest.mark.asyncio
async def test_inventory_item_data_serialization():
    """Verify that TurnOutput can handle InventoryItemData in WorldDelta."""
    item = InventoryItemData(
        id="item_1",
        label="빛나는 검",
        description="태양의 빛을 머금은 전설적인 검입니다.",
        quantity=1,
    )

    delta = WorldDelta(
        inventory_added=[item]  # DESIRED: list[InventoryItemData]
    )

    output = TurnOutput(
        language=Language.KO,
        narrative="아이템을 획득했습니다.",
        economy=EconomyOutput(
            cost=CurrencyAmount(signal=0, memory_shard=0),
            balance_after=CurrencyAmount(signal=100, memory_shard=5),
        ),
        safety=SafetyOutput(blocked=False),
        world=delta,
    )

    assert isinstance(output.world.inventory_added[0], InventoryItemData)
    assert output.world.inventory_added[0].label == "빛나는 검"


@pytest.mark.asyncio
async def test_item_icon_generator_generates_icon(icon_generator, mock_image_generator):
    """Verify icon generator calls image generator without rembg (U-091)."""
    from unknown_world.services.image_generation import (
        ImageGenerationResponse,
        ImageGenerationStatus,
    )

    mock_image_generator.generate.return_value = ImageGenerationResponse(
        status=ImageGenerationStatus.COMPLETED,
        image_url="http://example.com/icon.png",
        image_id="img_1",
    )

    request = IconGenerationRequest(
        item_id="item_1", item_description="A shiny sword", language="ko-KR"
    )

    with patch.object(
        mock_image_generator, "generate", wraps=mock_image_generator.generate
    ) as mocked_gen:
        await icon_generator.generate_icon(request, wait_for_completion=True)

        called_request = mocked_gen.call_args[0][0]
        # U-091: rembg 런타임 제거 - remove_background 필드가 더 이상 없음
        assert called_request.model_label == "FAST"
</file>

<file path="backend/tests/unit/services/test_u085_image_sizing.py">
"""Unknown World - U-085 이미지 사이징 및 SDK 호환성 테스트."""

from unknown_world.services.image_generation import (
    ImageGenerationRequest,
    validate_image_request,
)
from unknown_world.storage.validation import (
    DEFAULT_ASPECT_RATIO,
    DEFAULT_IMAGE_SIZE,
    SUPPORTED_IMAGE_SIZES,
    normalize_image_size,
    validate_image_generation_request,
)


def test_normalize_image_size():
    """레거시 픽셀 값 → SDK 값 변환 및 정규화 테스트."""
    # 1. 이미 SDK 값인 경우 유지
    assert normalize_image_size("1K") == "1K"
    assert normalize_image_size("2K") == "2K"
    assert normalize_image_size("4K") == "4K"

    # 2. 레거시 픽셀 값 매핑
    assert normalize_image_size("1024x1024") == "1K"
    assert normalize_image_size("1280x768") == "1K"
    assert normalize_image_size("1536x1024") == "2K"
    assert normalize_image_size("1024x1536") == "2K"

    # 3. 알 수 없는 값 → 입력값 유지 (검증에서 걸러지도록 함)
    assert normalize_image_size("invalid") == "invalid"
    assert normalize_image_size("640x480") == "640x480"


def test_validate_image_generation_request_with_sdk_sizes():
    """SDK 크기 값을 포함한 이미지 생성 요청 검증 테스트."""
    # 1. 성공 케이스 (SDK 값)
    assert validate_image_generation_request("A test prompt", "1K") is None
    assert validate_image_generation_request("A test prompt", "2K") is None
    assert validate_image_generation_request("A test prompt", "4K") is None

    # 2. 성공 케이스 (레거시 값 - 자동 정규화 포함)
    assert validate_image_generation_request("A test prompt", "1024x1024") is None

    # 3. 실패 케이스 (지원하지 않는 크기)
    err = validate_image_generation_request("A test prompt", "8K")
    assert "Unsupported image size" in err

    # 4. 실패 케이스 (프롬프트 짧음)
    err = validate_image_generation_request("A", "1K")
    assert "Prompt is too short" in err


def test_image_generation_service_request_validation():
    """서비스 계층의 ImageGenerationRequest 검증 테스트."""
    # 1. SDK 값 사용 시 통과
    request_sdk = ImageGenerationRequest(prompt="A high quality scene", image_size="1K")
    assert validate_image_request(request_sdk) is None

    # 2. 레거시 값 사용 시 통과 (정규화 루틴 포함됨)
    request_legacy = ImageGenerationRequest(prompt="A high quality scene", image_size="1024x1024")
    assert validate_image_request(request_legacy) is None

    # 3. 잘못된 값 실패
    request_invalid = ImageGenerationRequest(prompt="A high quality scene", image_size="unknown")
    assert validate_image_request(request_invalid) is not None


def test_constants_and_defaults():
    """U-085에서 변경된 기본값 및 상수 확인."""
    assert DEFAULT_ASPECT_RATIO == "16:9"
    assert DEFAULT_IMAGE_SIZE == "1K"
    assert "1K" in SUPPORTED_IMAGE_SIZES
    assert "2K" in SUPPORTED_IMAGE_SIZES
    assert "4K" in SUPPORTED_IMAGE_SIZES
    # 소문자 'k'는 지원하지 않아야 함 (SDK 제약)
    assert "1k" not in SUPPORTED_IMAGE_SIZES
</file>

<file path="backend/tests/unit/services/test_u094_scan_retry.py">
"""U-094: ImageUnderstanding 응답 파싱 예외 시 자동 재시도 단위 테스트.

이 테스트는 ImageUnderstandingService의 재시도 로직을 검증합니다.
"""

from unittest.mock import AsyncMock, MagicMock, patch

import pytest

from unknown_world.models.scanner import ScanStatus
from unknown_world.models.turn import Language
from unknown_world.services.image_understanding import (
    SCAN_MAX_RETRIES,
    SCAN_RETRY_BACKOFF_SECONDS,
    SCAN_RETRY_REINFORCEMENT,
    ImageUnderstandingService,
)


@pytest.fixture
def service():
    """ImageUnderstandingService 인스턴스 (Real 모드 강제)."""
    with (
        patch(
            "unknown_world.services.image_understanding.ImageUnderstandingService._initialize_client"
        ),
        patch("unknown_world.services.image_understanding.load_prompt") as mock_load,
    ):
        # 기본 프롬프트 반환 설정 ({count} 포함)
        mock_load.return_value = "Analyze this image. Find {count} items."

        svc = ImageUnderstandingService(force_mock=False)
        # Real 모드 강제 (재시도 로직 활성화)
        svc._is_mock = False
        # Mock 클라이언트 주입
        svc._genai_client = MagicMock()
        svc._genai_client.aio = MagicMock()
        svc._genai_client.aio.models = MagicMock()
        svc._genai_client.aio.models.generate_content = AsyncMock()
        return svc


@pytest.mark.asyncio
async def test_retry_on_parsing_failure_success(service):
    """파싱 실패 시 재시도하여 성공하는 시나리오 테스트."""
    # 첫 번째 호출: 잘못된 JSON
    # 두 번째 호출: 정상 JSON
    mock_response_1 = MagicMock()
    mock_response_1.text = "This is not JSON"
    mock_response_1.candidates = []
    mock_response_1.prompt_feedback = None

    mock_response_2 = MagicMock()
    mock_response_2.text = (
        '{"caption": "Success after retry", "objects": [], "item_candidates": []}'
    )
    mock_response_2.candidates = []
    mock_response_2.prompt_feedback = None

    service._genai_client.aio.models.generate_content.side_effect = [
        mock_response_1,
        mock_response_2,
    ]

    with patch("asyncio.sleep", AsyncMock()) as mock_sleep:
        result = await service.analyze(b"fake_image" * 20, "image/png", Language.KO)

        assert result.status == ScanStatus.COMPLETED
        assert result.caption == "Success after retry"
        assert service._genai_client.aio.models.generate_content.call_count == 2
        assert mock_sleep.call_count == 1
        mock_sleep.assert_called_with(SCAN_RETRY_BACKOFF_SECONDS[0])


@pytest.mark.asyncio
async def test_retry_on_api_exception_success(service):
    """API 호출 예외 발생 시 재시도하여 성공하는 시나리오 테스트."""
    # 첫 번째 호출: Exception
    # 두 번째 호출: 정상 JSON
    mock_response = MagicMock()
    mock_response.text = (
        '{"caption": "Success after exception", "objects": [], "item_candidates": []}'
    )
    mock_response.candidates = []
    mock_response.prompt_feedback = None

    service._genai_client.aio.models.generate_content.side_effect = [
        Exception("Temporary API Error"),
        mock_response,
    ]

    with patch("asyncio.sleep", AsyncMock()) as mock_sleep:
        result = await service.analyze(b"fake_image" * 20, "image/png", Language.KO)

        assert result.status == ScanStatus.COMPLETED
        assert result.caption == "Success after exception"
        assert service._genai_client.aio.models.generate_content.call_count == 2
        assert mock_sleep.call_count == 1


@pytest.mark.asyncio
async def test_fail_after_max_retries(service):
    """모든 재시도 실패 시 폴백 응답을 반환하는지 테스트."""
    # 총 3회(초기 1 + 재시도 2) 모두 실패
    mock_response = MagicMock()
    mock_response.text = "Still not JSON"
    mock_response.candidates = []
    mock_response.prompt_feedback = None

    service._genai_client.aio.models.generate_content.return_value = mock_response

    with patch("asyncio.sleep", AsyncMock()) as mock_sleep:
        result = await service.analyze(b"fake_image" * 20, "image/png", Language.KO)

        # 모든 재시도 실패 시 PARTIAL(캡션만 반환) 또는 FAILED
        # 현재 _parse_vision_response는 JSONDecodeError 시 PARTIAL을 반환함
        assert result.status == ScanStatus.PARTIAL
        assert "이미지 분석에 실패했습니다" in result.message
        assert service._genai_client.aio.models.generate_content.call_count == SCAN_MAX_RETRIES + 1
        assert mock_sleep.call_count == SCAN_MAX_RETRIES


@pytest.mark.asyncio
async def test_no_retry_on_safety_block(service):
    """안전 차단 시 재시도하지 않는지 테스트."""
    mock_response = MagicMock()
    # candidates[0].finish_reason = SAFETY 시뮬레이션
    mock_candidate = MagicMock()
    mock_candidate.finish_reason = "SAFETY"
    mock_response.candidates = [mock_candidate]
    mock_response.text = ""
    # prompt_feedback도 존재하면 block_reason을 체크할 수 있으므로 명시적으로 None 설정
    mock_response.prompt_feedback = None

    service._genai_client.aio.models.generate_content.return_value = mock_response

    with patch("asyncio.sleep", AsyncMock()) as mock_sleep:
        result = await service.analyze(b"fake_image" * 20, "image/png", Language.KO)

        assert result.status == ScanStatus.BLOCKED
        assert "안전 정책" in result.message
        assert service._genai_client.aio.models.generate_content.call_count == 1
        assert mock_sleep.call_count == 0


@pytest.mark.asyncio
async def test_no_retry_on_non_retryable_api_error(service):
    """재시도 불가 API 에러 시 재시도하지 않는지 테스트."""

    # PermissionDenied 클래스 흉내
    class PermissionDenied(Exception):
        pass

    service._genai_client.aio.models.generate_content.side_effect = PermissionDenied(
        "Invalid API Key"
    )

    with patch("asyncio.sleep", AsyncMock()) as mock_sleep:
        result = await service.analyze(b"fake_image" * 20, "image/png", Language.KO)

        assert result.status == ScanStatus.FAILED
        assert "API 오류" in result.message
        assert service._genai_client.aio.models.generate_content.call_count == 1
        assert mock_sleep.call_count == 0


@pytest.mark.asyncio
async def test_prompt_reinforcement_on_retry(service):
    """재시도 시 프롬프트에 JSON 강조 지시가 추가되는지 테스트."""
    # 첫 번째 호출은 실패해야 재시도가 일어남
    mock_response_fail = MagicMock()
    mock_response_fail.text = "fail"
    mock_response_fail.candidates = []
    mock_response_fail.prompt_feedback = None

    mock_response_ok = MagicMock()
    mock_response_ok.text = '{"caption": "ok", "objects": [], "item_candidates": []}'
    mock_response_ok.candidates = []
    mock_response_ok.prompt_feedback = None

    service._genai_client.aio.models.generate_content.side_effect = [
        mock_response_fail,
        mock_response_ok,
    ]

    with patch("asyncio.sleep", AsyncMock()):
        await service.analyze(b"fake_image" * 20, "image/png", Language.KO)

        # 호출 인자 확인
        calls = service._genai_client.aio.models.generate_content.call_args_list
        assert len(calls) == 2

        # 첫 번째 호출 프롬프트 (강조 없음)
        first_call_contents = calls[0].kwargs["contents"]
        first_prompt = first_call_contents[1].text
        assert SCAN_RETRY_REINFORCEMENT[Language.KO] not in first_prompt

        # 두 번째 호출 프롬프트 (강조 포함)
        second_call_contents = calls[1].kwargs["contents"]
        second_prompt = second_call_contents[1].text
        assert SCAN_RETRY_REINFORCEMENT[Language.KO] in second_prompt
</file>

<file path="backend/tests/unit/services/test_u095_scanner_randomize.py">
"""U-095 Scanner 아이템 생성 개수 랜덤화 단위 테스트."""

from collections import Counter
from unittest.mock import MagicMock, patch

import pytest

from unknown_world.models.scanner import ItemCandidate, ScanStatus
from unknown_world.models.turn import Language
from unknown_world.services.image_understanding import (
    ImageUnderstandingService,
    ScanResult,
    _adjust_item_count,
    determine_item_count,
)


def test_determine_item_count_distribution():
    """아이템 생성 개수 분포 테스트 (가중치 랜덤 검증)."""
    iterations = 1000
    counts = [determine_item_count() for _ in range(iterations)]
    distribution = Counter(counts)

    # 가중치: 1개=60%, 2개=30%, 3개=10%
    # 1000회 실행 시 대략적인 범위 확인 (여유 있게 5% 오차 허용)
    assert 500 <= distribution[1] <= 700
    assert 200 <= distribution[2] <= 400
    assert 50 <= distribution[3] <= 150
    assert len(distribution) == 3
    assert all(c in [1, 2, 3] for c in distribution)


def test_adjust_item_count_excess():
    """아이템 수가 목표보다 많을 때 조정 테스트."""
    items = [
        ItemCandidate(id="1", label="Item 1", description="Desc 1", item_type="tool"),
        ItemCandidate(id="2", label="Item 2", description="Desc 2", item_type="tool"),
        ItemCandidate(id="3", label="Item 3", description="Desc 3", item_type="tool"),
    ]
    result = ScanResult(
        status=ScanStatus.COMPLETED,
        caption="Test",
        objects=[],
        item_candidates=items,
        analysis_time_ms=100,
    )

    adjusted = _adjust_item_count(result, target_count=2)
    assert len(adjusted.item_candidates) == 2
    assert adjusted.item_candidates[0].id == "1"
    assert adjusted.item_candidates[1].id == "2"


def test_adjust_item_count_fewer():
    """아이템 수가 목표보다 적을 때 조정 테스트 (그대로 유지)."""
    items = [
        ItemCandidate(id="1", label="Item 1", description="Desc 1", item_type="tool"),
    ]
    result = ScanResult(
        status=ScanStatus.COMPLETED,
        caption="Test",
        objects=[],
        item_candidates=items,
        analysis_time_ms=100,
    )

    adjusted = _adjust_item_count(result, target_count=3)
    assert len(adjusted.item_candidates) == 1
    assert adjusted.item_candidates[0].id == "1"


def test_adjust_item_count_duplicate_labels():
    """중복된 이름의 아이템 제거 테스트."""
    items = [
        ItemCandidate(id="1", label="Key", description="Desc 1", item_type="key"),
        ItemCandidate(id="2", label="Key", description="Desc 2", item_type="key"),
        ItemCandidate(id="3", label="Lock", description="Desc 3", item_type="tool"),
    ]
    result = ScanResult(
        status=ScanStatus.COMPLETED,
        caption="Test",
        objects=[],
        item_candidates=items,
        analysis_time_ms=100,
    )

    adjusted = _adjust_item_count(result, target_count=3)
    assert len(adjusted.item_candidates) == 2
    assert adjusted.item_candidates[0].label == "Key"
    assert adjusted.item_candidates[1].label == "Lock"


@pytest.mark.asyncio
async def test_service_analyze_uses_correct_item_count():
    """analyze 메서드가 결정된 item_count를 비전 호출에 전달하는지 테스트."""
    service = ImageUnderstandingService(force_mock=False)
    service._is_mock = False
    # Mocking genai client
    service._genai_client = MagicMock()
    service._genai_client.aio.models.generate_content = MagicMock()

    # Mock response
    mock_response = MagicMock()
    mock_response.text = '{"caption": "test", "objects": [], "item_candidates": [{"id": "i1", "label": "L1", "description": "D1", "item_type": "tool"}]}'
    service._genai_client.aio.models.generate_content.return_value = mock_response

    with (
        patch(
            "unknown_world.services.image_understanding.determine_item_count", return_value=3
        ) as mock_count,
        patch(
            "unknown_world.services.image_understanding.load_prompt",
            return_value="Test prompt {count}",
        ) as mock_load,
    ):
        await service.analyze(b"fake_image" * 100, "image/png", Language.KO)

        # determine_item_count가 호출되었는지 확인
        mock_count.assert_called_once()

        # load_prompt가 "scan", "scan_instructions"로 호출되었는지 확인
        mock_load.assert_any_call("scan", "scan_instructions", Language.KO)

        # 비전 호출 시 프롬프트에 {count}가 3으로 치환되었는지 확인
        call_args = service._genai_client.aio.models.generate_content.call_args
        prompt_part = call_args[1]["contents"][1]
        assert "Test prompt 3" in prompt_part.text
</file>

<file path="backend/tests/unit/test_u065_schema_simplification.py">
import pytest
from pydantic import ValidationError

from unknown_world.models.turn import (
    ActionCard,
    ActionDeck,
    AgentConsole,
    Language,
    TurnOutput,
    ValidationBadge,
    WorldDelta,
)


def test_turn_output_simplified_schema_validation_success():
    """단순화된 스키마를 따르는 정상적인 데이터 검증 성공 확인"""
    data = {
        "language": "ko-KR",
        "narrative": "테스트 내러티브입니다.",
        "economy": {
            "cost": {"signal": 5, "memory_shard": 0},
            "balance_after": {"signal": 95, "memory_shard": 5},
        },
        "safety": {"blocked": False},
        "ui": {
            "action_deck": {
                "cards": [
                    {
                        "id": "action_1",
                        "label": "행동 1",
                        "cost": {"signal": 1, "memory_shard": 0},
                        "risk": "low",
                        "enabled": True,
                        "is_alternative": False,
                    }
                ]
            },
            "objects": [],
        },
        "world": {
            "rules_changed": [],
            "inventory_added": [
                {
                    "id": "item_1",
                    "label": "아이템 1",
                    "description": "테스트 아이템입니다.",
                    "quantity": 1,
                }
            ],
            "quests_updated": [],
            "memory_pins": [],
        },
        "render": {"image_job": None},
        "agent_console": {"current_phase": "commit", "badges": ["schema_ok"], "repair_count": 0},
    }
    output = TurnOutput.model_validate(data)
    assert output.language == Language.KO
    assert len(output.ui.action_deck.cards) == 1
    # 제거된 필드가 데이터에 없어야 함을 확인 (ActionCard)
    assert not hasattr(output.ui.action_deck.cards[0], "description")
    assert not hasattr(output.ui.action_deck.cards[0], "cost_estimate")


def test_turn_output_extra_fields_forbidden():
    """제거된 필드가 포함되었을 때 extra='forbid' 설정에 의해 실패하는지 확인 (ActionCard)"""
    # ActionCard는 model_config = ConfigDict(extra="forbid")가 설정되어 있지 않음
    # 하지만 TurnOutput 및 주요 하위 모델들은 설정되어 있음.
    # ActionCard에 필드가 없으므로 validation 시 에러가 나거나 무시되어야 함.
    # Pydantic v2에서는 필드가 정의되지 않으면 에러가 발생함 (extra="forbid"인 경우)

    data = {
        "id": "action_1",
        "label": "행동 1",
        "description": "이 필드는 제거되었습니다.",  # 제거된 필드
        "cost": {"signal": 1, "memory_shard": 0},
    }

    with pytest.raises(ValidationError):
        ActionCard.model_validate(data)

    # extra="forbid"가 설정되어 있다면 'extra fields not permitted' 에러 발생
    # models/turn.py를 확인해보면 ActionCard에는 extra="forbid"가 없으므로 무시될 수 있음.
    # 하지만 TurnOutput 수준에서 검증할 때 문제가 될 수 있음.


def test_action_deck_max_length_violation():
    """ActionDeck.cards의 max_length=5 제약 위반 확인"""
    cards = [
        {"id": f"action_{i}", "label": f"행동 {i}", "cost": {"signal": 1, "memory_shard": 0}}
        for i in range(6)  # 6개 생성
    ]

    with pytest.raises(ValidationError) as excinfo:
        ActionDeck(cards=cards)

    assert "List should have at most 5 items" in str(excinfo.value)


def test_world_delta_max_length_violations():
    """WorldDelta의 각종 배열 max_length 제약 위반 확인"""
    # rules_changed: max_length=3
    with pytest.raises(ValidationError):
        WorldDelta(rules_changed=[{"id": "r1", "label": "L"}] * 4)

    # inventory_added: max_length=5
    with pytest.raises(ValidationError):
        WorldDelta(inventory_added=["item"] * 6)

    # memory_pins: max_length=2
    with pytest.raises(ValidationError):
        WorldDelta(
            memory_pins=[{"id": "p1", "content": "C", "cost": {"signal": 1, "memory_shard": 0}}] * 3
        )


def test_agent_console_badges_max_length():
    """AgentConsole.badges의 max_length=4 제약 위반 확인"""
    with pytest.raises(ValidationError):
        AgentConsole(badges=[ValidationBadge.SCHEMA_OK] * 5)
</file>

<file path="frontend/public/ui/manifest.json">
{
  "$schema": "./manifest.schema.json",
  "version": "1.6.0",
  "generatedAt": "2026-02-09T12:00:00Z",
  "totalBytes": 931471,
  "budgetBytes": 1572864,
  "assets": [
    {
      "id": "signal-24",
      "path": "icons/signal-24.png",
      "type": "icon",
      "size": 24,
      "fallback": "⚡",
      "usedIn": ["EconomyHUD"],
      "bytes": 1573,
      "notes": "U-038: v2 재생성, nanobanana mcp(픽셀아트), rembg(birefnet-general), ImageMagick 최적화"
    },
    {
      "id": "signal-16",
      "path": "icons/signal-16.png",
      "type": "icon",
      "size": 16,
      "fallback": "⚡",
      "usedIn": ["ActionDeck"],
      "bytes": 1012,
      "notes": "U-038: v2 재생성, nanobanana mcp(픽셀아트), rembg(birefnet-general), ImageMagick 최적화"
    },
    {
      "id": "shard-24",
      "path": "icons/shard-24.png",
      "type": "icon",
      "size": 24,
      "fallback": "💎",
      "usedIn": ["EconomyHUD"],
      "bytes": 1362,
      "notes": "U-038: v2 재생성, nanobanana mcp(픽셀아트), rembg(birefnet-general), ImageMagick 최적화"
    },
    {
      "id": "shard-16",
      "path": "icons/shard-16.png",
      "type": "icon",
      "size": 16,
      "fallback": "💎",
      "usedIn": ["ActionDeck"],
      "bytes": 1147,
      "notes": "U-038: shard-24에서 리사이즈, 16px 최적화"
    },
    {
      "id": "badge-ok-24",
      "path": "icons/badge-ok-24.png",
      "type": "icon",
      "size": 24,
      "fallback": "✓",
      "usedIn": ["AgentConsole"],
      "bytes": 1461,
      "notes": "U-038: v2 재생성, nanobanana mcp(픽셀아트), rembg(birefnet-general), ImageMagick 최적화"
    },
    {
      "id": "badge-ok-16",
      "path": "icons/badge-ok-16.png",
      "type": "icon",
      "size": 16,
      "fallback": "✓",
      "usedIn": [],
      "bytes": 1096,
      "notes": "U-038: v2 재생성, nanobanana mcp(픽셀아트), rembg(birefnet-general), ImageMagick 최적화"
    },
    {
      "id": "badge-fail-24",
      "path": "icons/badge-fail-24.png",
      "type": "icon",
      "size": 24,
      "fallback": "✗",
      "usedIn": ["AgentConsole"],
      "bytes": 2006,
      "notes": "U-038: v2 재생성, nanobanana mcp(픽셀아트), rembg(birefnet-general), ImageMagick 최적화"
    },
    {
      "id": "risk-medium-24",
      "path": "icons/risk-medium-24.png",
      "type": "icon",
      "size": 24,
      "fallback": "⚠",
      "usedIn": [],
      "bytes": 1594,
      "notes": "U-038: 24px 페어 보강, nanobanana mcp 생성"
    },
    {
      "id": "risk-medium-16",
      "path": "icons/risk-medium-16.png",
      "type": "icon",
      "size": 16,
      "fallback": "⚠",
      "usedIn": ["ActionDeck"],
      "bytes": 1256,
      "notes": "U-038: v2 재생성, nanobanana mcp(픽셀아트), rembg(birefnet-general), ImageMagick 최적화"
    },
    {
      "id": "risk-low-24",
      "path": "icons/risk-low-24.png",
      "type": "icon",
      "size": 24,
      "fallback": "✓",
      "usedIn": [],
      "bytes": 1838,
      "notes": "U-038: v2 재생성, nanobanana mcp(픽셀아트), rembg(birefnet-general), ImageMagick 최적화"
    },
    {
      "id": "risk-low-16",
      "path": "icons/risk-low-16.png",
      "type": "icon",
      "size": 16,
      "fallback": "✓",
      "usedIn": ["ActionDeck"],
      "bytes": 1331,
      "notes": "U-038: v2 재생성, nanobanana mcp(픽셀아트), rembg(birefnet-general), ImageMagick 최적화"
    },
    {
      "id": "risk-high-24",
      "path": "icons/risk-high-24.png",
      "type": "icon",
      "size": 24,
      "fallback": "⚠",
      "usedIn": [],
      "bytes": 1737,
      "notes": "U-038: v2 재생성, nanobanana mcp(픽셀아트), rembg(birefnet-general), ImageMagick 최적화"
    },
    {
      "id": "risk-high-16",
      "path": "icons/risk-high-16.png",
      "type": "icon",
      "size": 16,
      "fallback": "⚠",
      "usedIn": ["ActionDeck"],
      "bytes": 1227,
      "notes": "U-038: v2 재생성, nanobanana mcp(픽셀아트), rembg(birefnet-general), ImageMagick 최적화"
    },
    {
      "id": "status-online-16",
      "path": "icons/status-online-16.png",
      "type": "icon",
      "size": 16,
      "fallback": "●",
      "usedIn": [],
      "bytes": 1375,
      "notes": "U-038: v2 재생성, nanobanana mcp(픽셀아트), rembg(birefnet-general), ImageMagick 최적화"
    },
    {
      "id": "scene-placeholder-default",
      "path": "placeholders/scene-placeholder-default.png",
      "type": "placeholder",
      "fallback": "[SCENE]",
      "usedIn": ["SceneCanvas"],
      "bytes": 261407,
      "notes": "nanobanana mcp 생성, 레트로 터미널 스타일"
    },
    {
      "id": "scene-loading",
      "path": "placeholders/scene-loading.webp",
      "type": "placeholder",
      "fallback": "⏳",
      "usedIn": ["SceneCanvas"],
      "bytes": 47850,
      "notes": "U-031: 로딩 상태 placeholder, nanobanana mcp 생성, ImageMagick(magick) 최적화"
    },
    {
      "id": "scene-offline",
      "path": "placeholders/scene-offline.webp",
      "type": "placeholder",
      "fallback": "🔌",
      "usedIn": ["SceneCanvas"],
      "bytes": 44658,
      "notes": "U-031: 오프라인 상태 placeholder, nanobanana mcp 생성, ImageMagick(magick) 최적화"
    },
    {
      "id": "scene-blocked",
      "path": "placeholders/scene-blocked.webp",
      "type": "placeholder",
      "fallback": "🚫",
      "usedIn": ["SceneCanvas"],
      "bytes": 17318,
      "notes": "U-031: 차단 상태 placeholder, nanobanana mcp 생성, ImageMagick(magick) 최적화"
    },
    {
      "id": "scene-low-signal",
      "path": "placeholders/scene-low-signal.webp",
      "type": "placeholder",
      "fallback": "📉",
      "usedIn": ["SceneCanvas"],
      "bytes": 68454,
      "notes": "U-031: 저신호 상태 placeholder, nanobanana mcp 생성, ImageMagick(magick) 최적화"
    },
    {
      "id": "panel-corner-br",
      "path": "chrome/panel-corner-br.png",
      "type": "chrome",
      "fallback": "",
      "usedIn": ["PanelHeader"],
      "bytes": 1899,
      "notes": "U-032: 패널 코너 장식, nanobanana mcp 생성, rembg 배경 제거, ImageMagick 최적화(48x48), CSS transform으로 4방향 적용"
    },
    {
      "id": "card-frame",
      "path": "chrome/card-frame.png",
      "type": "chrome",
      "fallback": "",
      "usedIn": ["ActionCard"],
      "bytes": 9101,
      "notes": "U-032: 액션 카드 프레임, nanobanana mcp 생성, rembg 배경 제거, ImageMagick 최적화(160x80)"
    },
    {
      "id": "scanner-frame",
      "path": "chrome/scanner-frame.png",
      "type": "chrome",
      "fallback": "",
      "usedIn": ["Scanner"],
      "bytes": 100165,
      "notes": "U-032: 스캐너 슬롯 프레임, nanobanana mcp 생성, rembg(birefnet-general) 배경 제거, ImageMagick 최적화(346x200) 완료"
    },
    {
      "id": "item-ancient-tome-64",
      "path": "items/ancient-tome-64.png",
      "type": "item-icon",
      "size": 64,
      "fallback": "📕",
      "usedIn": ["InventoryPanel"],
      "bytes": 7166,
      "notes": "U-092: Narrator 초기 아이템, nanobanana mcp(pixel-art), rembg(birefnet-general), ImageMagick 64x64"
    },
    {
      "id": "item-quill-pen-64",
      "path": "items/quill-pen-64.png",
      "type": "item-icon",
      "size": 64,
      "fallback": "🖋️",
      "usedIn": ["InventoryPanel"],
      "bytes": 6474,
      "notes": "U-092: Narrator 초기 아이템, nanobanana mcp(pixel-art), rembg(birefnet-general), ImageMagick 64x64"
    },
    {
      "id": "item-memory-fragment-64",
      "path": "items/memory-fragment-64.png",
      "type": "item-icon",
      "size": 64,
      "fallback": "💠",
      "usedIn": ["InventoryPanel"],
      "bytes": 6977,
      "notes": "U-092: Narrator 초기 아이템, nanobanana mcp(pixel-art), rembg(birefnet-general), ImageMagick 64x64"
    },
    {
      "id": "item-compass-64",
      "path": "items/compass-64.png",
      "type": "item-icon",
      "size": 64,
      "fallback": "🧭",
      "usedIn": ["InventoryPanel"],
      "bytes": 9515,
      "notes": "U-092: Explorer 초기 아이템, nanobanana mcp(pixel-art), rembg(birefnet-general), ImageMagick 64x64"
    },
    {
      "id": "item-rope-64",
      "path": "items/rope-64.png",
      "type": "item-icon",
      "size": 64,
      "fallback": "🪢",
      "usedIn": ["InventoryPanel"],
      "bytes": 10713,
      "notes": "U-092: Explorer 초기 아이템, nanobanana mcp(pixel-art), rembg(birefnet-general), ImageMagick 64x64"
    },
    {
      "id": "item-lantern-64",
      "path": "items/lantern-64.png",
      "type": "item-icon",
      "size": 64,
      "fallback": "🏮",
      "usedIn": ["InventoryPanel"],
      "bytes": 8054,
      "notes": "U-092: Explorer 초기 아이템, nanobanana mcp(pixel-art), rembg(birefnet-general), ImageMagick 64x64"
    },
    {
      "id": "item-map-fragment-64",
      "path": "items/map-fragment-64.png",
      "type": "item-icon",
      "size": 64,
      "fallback": "🗺️",
      "usedIn": ["InventoryPanel"],
      "bytes": 9705,
      "notes": "U-092: Explorer 초기 아이템, nanobanana mcp(pixel-art), rembg(birefnet-general), ImageMagick 64x64"
    },
    {
      "id": "item-data-core-64",
      "path": "items/data-core-64.png",
      "type": "item-icon",
      "size": 64,
      "fallback": "💿",
      "usedIn": ["InventoryPanel"],
      "bytes": 10949,
      "notes": "U-092: Tech 초기 아이템, nanobanana mcp(pixel-art), rembg(birefnet-general), ImageMagick 64x64"
    },
    {
      "id": "item-circuit-board-64",
      "path": "items/circuit-board-64.png",
      "type": "item-icon",
      "size": 64,
      "fallback": "🔌",
      "usedIn": ["InventoryPanel"],
      "bytes": 8062,
      "notes": "U-092: Tech 초기 아이템, nanobanana mcp(pixel-art), rembg(birefnet-general), ImageMagick 64x64"
    },
    {
      "id": "item-energy-cell-64",
      "path": "items/energy-cell-64.png",
      "type": "item-icon",
      "size": 64,
      "fallback": "🔋",
      "usedIn": ["InventoryPanel"],
      "bytes": 7394,
      "notes": "U-092: Tech 초기 아이템, nanobanana mcp(pixel-art), rembg(birefnet-general), ImageMagick 64x64"
    },
    {
      "id": "item-scanner-device-64",
      "path": "items/scanner-device-64.png",
      "type": "item-icon",
      "size": 64,
      "fallback": "📡",
      "usedIn": ["InventoryPanel"],
      "bytes": 4436,
      "notes": "U-092: Tech 초기 아이템, nanobanana mcp(pixel-art), rembg(birefnet-general), ImageMagick 64x64"
    },
    {
      "id": "item-sword-64",
      "path": "items/sword-64.png",
      "type": "item-icon",
      "size": 64,
      "fallback": "⚔️",
      "usedIn": ["InventoryPanel"],
      "bytes": 5748,
      "notes": "U-092: 공통 아이템, nanobanana mcp(pixel-art), rembg(birefnet-general), ImageMagick 64x64"
    },
    {
      "id": "item-shield-64",
      "path": "items/shield-64.png",
      "type": "item-icon",
      "size": 64,
      "fallback": "🛡️",
      "usedIn": ["InventoryPanel"],
      "bytes": 10313,
      "notes": "U-092: 공통 아이템, nanobanana mcp(pixel-art), rembg(birefnet-general), ImageMagick 64x64"
    },
    {
      "id": "item-potion-64",
      "path": "items/potion-64.png",
      "type": "item-icon",
      "size": 64,
      "fallback": "🧪",
      "usedIn": ["InventoryPanel"],
      "bytes": 6083,
      "notes": "U-092: 공통 아이템, nanobanana mcp(pixel-art), rembg(birefnet-general), ImageMagick 64x64"
    },
    {
      "id": "item-key-64",
      "path": "items/key-64.png",
      "type": "item-icon",
      "size": 64,
      "fallback": "🔑",
      "usedIn": ["InventoryPanel"],
      "bytes": 8703,
      "notes": "U-092: 공통 아이템, nanobanana mcp(pixel-art), rembg(birefnet-general), ImageMagick 64x64"
    },
    {
      "id": "item-gem-64",
      "path": "items/gem-64.png",
      "type": "item-icon",
      "size": 64,
      "fallback": "💎",
      "usedIn": ["InventoryPanel"],
      "bytes": 6681,
      "notes": "U-092: 공통 아이템, nanobanana mcp(pixel-art), rembg(birefnet-general), ImageMagick 64x64"
    },
    {
      "id": "item-scroll-64",
      "path": "items/scroll-64.png",
      "type": "item-icon",
      "size": 64,
      "fallback": "📜",
      "usedIn": ["InventoryPanel"],
      "bytes": 9741,
      "notes": "U-092: 공통 아이템, nanobanana mcp(pixel-art), rembg(birefnet-general), ImageMagick 64x64"
    },
    {
      "id": "item-torch-64",
      "path": "items/torch-64.png",
      "type": "item-icon",
      "size": 64,
      "fallback": "🔥",
      "usedIn": ["InventoryPanel"],
      "bytes": 5029,
      "notes": "U-092: 공통 아이템, nanobanana mcp(pixel-art), rembg(birefnet-general), ImageMagick 64x64"
    },
    {
      "id": "item-herb-64",
      "path": "items/herb-64.png",
      "type": "item-icon",
      "size": 64,
      "fallback": "🌿",
      "usedIn": ["InventoryPanel"],
      "bytes": 7688,
      "notes": "U-092: 공통 아이템, nanobanana mcp(pixel-art), rembg(birefnet-general), ImageMagick 64x64"
    },
    {
      "id": "item-coin-64",
      "path": "items/coin-64.png",
      "type": "item-icon",
      "size": 64,
      "fallback": "🪙",
      "usedIn": ["InventoryPanel"],
      "bytes": 9757,
      "notes": "U-092: 공통 아이템, nanobanana mcp(pixel-art), rembg(birefnet-general), ImageMagick 64x64"
    },
    {
      "id": "item-ring-64",
      "path": "items/ring-64.png",
      "type": "item-icon",
      "size": 64,
      "fallback": "💍",
      "usedIn": ["InventoryPanel"],
      "bytes": 7854,
      "notes": "U-092: 공통 아이템, nanobanana mcp(pixel-art), rembg(birefnet-general), ImageMagick 64x64"
    },
    {
      "id": "item-amulet-64",
      "path": "items/amulet-64.png",
      "type": "item-icon",
      "size": 64,
      "fallback": "🔮",
      "usedIn": ["InventoryPanel"],
      "bytes": 8599,
      "notes": "U-092: 공통 아이템, nanobanana mcp(pixel-art), rembg(birefnet-general), ImageMagick 64x64"
    },
    {
      "id": "item-dagger-64",
      "path": "items/dagger-64.png",
      "type": "item-icon",
      "size": 64,
      "fallback": "🗡️",
      "usedIn": ["InventoryPanel"],
      "bytes": 6623,
      "notes": "U-092: 공통 아이템, nanobanana mcp(pixel-art), rembg(birefnet-general), ImageMagick 64x64"
    },
    {
      "id": "item-flask-64",
      "path": "items/flask-64.png",
      "type": "item-icon",
      "size": 64,
      "fallback": "⚗️",
      "usedIn": ["InventoryPanel"],
      "bytes": 7141,
      "notes": "U-092: 공통 아이템, nanobanana mcp(pixel-art), rembg(birefnet-general), ImageMagick 64x64"
    },
    {
      "id": "item-crystal-64",
      "path": "items/crystal-64.png",
      "type": "item-icon",
      "size": 64,
      "fallback": "🔷",
      "usedIn": ["InventoryPanel"],
      "bytes": 9259,
      "notes": "U-092: 공통 아이템, nanobanana mcp(pixel-art), rembg(birefnet-general), ImageMagick 64x64"
    },
    {
      "id": "item-lockpick-64",
      "path": "items/lockpick-64.png",
      "type": "item-icon",
      "size": 64,
      "fallback": "🔧",
      "usedIn": ["InventoryPanel"],
      "bytes": 6368,
      "notes": "U-092: 공통 아이템, nanobanana mcp(pixel-art), rembg(birefnet-general), ImageMagick 64x64"
    },
    {
      "id": "scene-narrator-start",
      "path": "scenes/scene-narrator-start.webp",
      "type": "scene",
      "fallback": "📖",
      "usedIn": ["SceneCanvas"],
      "bytes": 55134,
      "notes": "U-124: Narrator 프로필 첫 씬 (서재/도서관), nanobanana mcp(oil-painting), ImageMagick 1024x576 WebP Q80 (Gemini 1K 16:9 매칭)"
    },
    {
      "id": "scene-explorer-start",
      "path": "scenes/scene-explorer-start.webp",
      "type": "scene",
      "fallback": "🧭",
      "usedIn": ["SceneCanvas"],
      "bytes": 42726,
      "notes": "U-124: Explorer 프로필 첫 씬 (동굴 입구), nanobanana mcp(oil-painting), ImageMagick 1024x576 WebP Q80 (Gemini 1K 16:9 매칭)"
    },
    {
      "id": "scene-tech-start",
      "path": "scenes/scene-tech-start.webp",
      "type": "scene",
      "fallback": "⚙️",
      "usedIn": ["SceneCanvas"],
      "bytes": 57712,
      "notes": "U-124: Tech 프로필 첫 씬 (실험실), nanobanana mcp(oil-painting), ImageMagick 1024x576 WebP Q80 (Gemini 1K 16:9 매칭)"
    }
  ]
}
</file>

<file path="frontend/public/ui/manifest.schema.json">
{
  "$schema": "http://json-schema.org/draft-07/schema#",
  "$id": "https://unknown-world.dev/schemas/ui-asset-manifest.json",
  "title": "UI Asset Manifest",
  "description": "nanobanana mcp로 제작된 UI 에셋의 매니페스트 스키마",
  "type": "object",
  "required": ["version", "assets"],
  "additionalProperties": false,
  "properties": {
    "$schema": {
      "type": "string",
      "description": "JSON Schema 참조"
    },
    "version": {
      "type": "string",
      "pattern": "^\\d+\\.\\d+\\.\\d+$",
      "description": "매니페스트 버전 (SemVer)",
      "examples": ["1.0.0"]
    },
    "generatedAt": {
      "type": "string",
      "format": "date-time",
      "description": "매니페스트 생성 시각 (ISO 8601)"
    },
    "totalBytes": {
      "type": "integer",
      "minimum": 0,
      "description": "모든 에셋의 총 바이트 수"
    },
    "budgetBytes": {
      "type": "integer",
      "minimum": 0,
      "default": 1572864,
      "description": "성능 예산 상한 (기본: 1.5MB = 1572864 bytes)"
    },
    "assets": {
      "type": "array",
      "description": "에셋 목록",
      "items": {
        "$ref": "#/$defs/Asset"
      }
    }
  },
  "$defs": {
    "Asset": {
      "type": "object",
      "required": ["id", "path", "type"],
      "additionalProperties": false,
      "properties": {
        "id": {
          "type": "string",
          "pattern": "^[a-z0-9]+(-[a-z0-9]+)*$",
          "description": "에셋 고유 ID (kebab-case)",
          "examples": ["signal-24", "badge-ok-16", "scene-loading"]
        },
        "path": {
          "type": "string",
          "pattern": "^[a-z0-9-/]+\\.(png|webp|svg)$",
          "description": "ui/ 디렉토리 기준 상대 경로",
          "examples": ["icons/signal-24.png", "placeholders/scene-loading.webp"]
        },
        "type": {
          "type": "string",
          "enum": ["icon", "placeholder", "chrome", "item-icon", "scene"],
          "description": "에셋 유형"
        },
        "size": {
          "type": "integer",
          "enum": [16, 24, 32, 64, 128, 256, 512],
          "description": "픽셀 사이즈 (아이콘용)"
        },
        "width": {
          "type": "integer",
          "minimum": 1,
          "description": "가로 픽셀 (placeholder/chrome용)"
        },
        "height": {
          "type": "integer",
          "minimum": 1,
          "description": "세로 픽셀 (placeholder/chrome용)"
        },
        "fallback": {
          "type": "string",
          "maxLength": 10,
          "description": "로딩 실패 시 대체 이모지/텍스트",
          "examples": ["📡", "⚠️", "OK"]
        },
        "usedIn": {
          "type": "array",
          "items": {
            "type": "string"
          },
          "description": "사용처 컴포넌트 목록",
          "examples": [["EconomyHUD", "AgentConsole"]]
        },
        "bytes": {
          "type": "integer",
          "minimum": 0,
          "description": "파일 크기 (bytes)"
        },
        "format": {
          "type": "string",
          "enum": ["png", "webp", "svg"],
          "description": "파일 포맷"
        },
        "retina": {
          "type": "boolean",
          "default": false,
          "description": "@2x Retina 버전 존재 여부"
        },
        "description": {
          "type": "string",
          "maxLength": 200,
          "description": "에셋 설명"
        },
        "createdAt": {
          "type": "string",
          "format": "date-time",
          "description": "생성 시각 (ISO 8601)"
        },
        "promptHash": {
          "type": "string",
          "pattern": "^[a-f0-9]{8}$",
          "description": "생성 프롬프트 해시 (재현성, 8자)"
        },
        "notes": {
          "type": "string",
          "maxLength": 500,
          "description": "에셋 관련 메모 (생성 도구, 배경 제거, 최적화 등 QA 관련 기록)"
        }
      }
    }
  }
}
</file>

<file path="frontend/src/api/scanner.test.ts">
import { describe, it, expect, vi, beforeEach } from 'vitest';
import {
  scanImage,
  validateFile,
  isSupportedImageFile,
  candidateToInventoryItem,
  MAX_FILE_SIZE_BYTES,
  type ItemCandidate,
} from './scanner';

describe('Scanner API Client', () => {
  beforeEach(() => {
    vi.clearAllMocks();
    global.fetch = vi.fn();
  });

  describe('validateFile', () => {
    it('returns null for valid image files', () => {
      const file = new File([''], 'test.png', { type: 'image/png' });
      expect(validateFile(file)).toBeNull();
    });

    it('returns error for unsupported MIME types', () => {
      const file = new File([''], 'test.txt', { type: 'text/plain' });
      expect(validateFile(file)).toContain('지원하지 않는 파일 형식');
    });

    it('returns error for files exceeding max size', () => {
      const largeFile = {
        size: MAX_FILE_SIZE_BYTES + 1,
        type: 'image/png',
        name: 'large.png',
      } as File;
      expect(validateFile(largeFile)).toContain('파일이 너무 큽니다');
    });
  });

  describe('isSupportedImageFile', () => {
    it('returns true for jpg, png, webp, gif', () => {
      expect(isSupportedImageFile(new File([''], 't.jpg', { type: 'image/jpeg' }))).toBe(true);
      expect(isSupportedImageFile(new File([''], 't.png', { type: 'image/png' }))).toBe(true);
      expect(isSupportedImageFile(new File([''], 't.webp', { type: 'image/webp' }))).toBe(true);
      expect(isSupportedImageFile(new File([''], 't.gif', { type: 'image/gif' }))).toBe(true);
    });

    it('returns false for others', () => {
      expect(isSupportedImageFile(new File([''], 't.pdf', { type: 'application/pdf' }))).toBe(
        false,
      );
    });
  });

  describe('scanImage', () => {
    const mockFile = new File(['mock content'], 'test.png', { type: 'image/png' });
    const mockSuccessResponse = {
      success: true,
      status: 'completed',
      caption: 'A test scan',
      objects: [],
      item_candidates: [{ id: 'item-1', label: 'Test Item', item_type: 'tool' }],
      analysis_time_ms: 100,
      language: 'ko-KR',
    };

    it('returns success data when API call succeeds', async () => {
      (global.fetch as unknown as ReturnType<typeof vi.fn>).mockResolvedValue({
        ok: true,
        json: async () => mockSuccessResponse,
      });

      const result = await scanImage(mockFile, 'ko-KR');

      expect(result.success).toBe(true);
      if (result.success) {
        expect(result.data.caption).toBe('A test scan');
        expect(result.data.item_candidates).toHaveLength(1);
      }
    });

    it('returns error when fetch fails', async () => {
      (global.fetch as unknown as ReturnType<typeof vi.fn>).mockResolvedValue({
        ok: false,
        status: 500,
        statusText: 'Internal Server Error',
      });

      const result = await scanImage(mockFile, 'ko-KR');

      expect(result.success).toBe(false);
      if (!result.success) {
        expect(result.error).toContain('서버 오류: 500');
      }
    });

    it('returns error when response schema is invalid', async () => {
      (global.fetch as unknown as ReturnType<typeof vi.fn>).mockResolvedValue({
        ok: true,
        json: async () => ({ invalid: 'data' }),
      });

      const result = await scanImage(mockFile, 'ko-KR');

      expect(result.success).toBe(false);
      if (!result.success) {
        expect(result.error).toContain('데이터 형식이 올바르지 않습니다');
      }
    });

    it('handles network error', async () => {
      (global.fetch as unknown as ReturnType<typeof vi.fn>).mockRejectedValue(
        new Error('Network error'),
      );

      const result = await scanImage(mockFile, 'ko-KR');

      expect(result.success).toBe(false);
      if (!result.success) {
        expect(result.error).toContain('네트워크 오류');
      }
    });
  });

  describe('candidateToInventoryItem', () => {
    it('correctly maps ItemCandidate to InventoryItem with pending iconStatus (U-075)', () => {
      const candidate = {
        id: 'c-1',
        label: 'Rusty Key',
        description: 'An old key',
        item_type: 'key',
      };
      const item = candidateToInventoryItem(candidate);

      expect(item).toEqual({
        id: 'c-1',
        name: 'Rusty Key',
        description: 'An old key',
        icon: '🔑',
        quantity: 1,
        iconStatus: 'pending', // U-075: 아이콘 생성 트리거
      });
    });

    it('uses fallback icon for unknown item types', () => {
      const candidate: ItemCandidate = {
        id: 'c-2',
        label: 'Something',
        description: '',
        item_type: 'unknown',
      };
      const item = candidateToInventoryItem(candidate);
      expect(item.icon).toBe('📦');
      expect(item.iconStatus).toBe('pending'); // U-075
    });
  });
});
</file>

<file path="frontend/src/api/turnStream.economy.test.ts">
import { describe, it, expect, vi, beforeEach } from 'vitest';
import { executeTurnStream } from './turnStream';

describe('U-063: Economy Balance Preservation in executeTurnStream', () => {
  const economySnapshot = { signal: 150, memory_shard: 5 };

  const mockInput = {
    language: 'ko-KR' as const,
    text: 'Hello',
    action_id: null,
    click: null,
    drop: null,
    client: { viewport_w: 100, viewport_h: 100, theme: 'dark' as const },
    economy_snapshot: economySnapshot,
    previous_image_url: null,
  };

  const mockCallbacks = {
    onFinal: vi.fn(),
    onError: vi.fn(),
    onComplete: vi.fn(),
  };

  beforeEach(() => {
    vi.clearAllMocks();
    global.fetch = vi.fn();
  });

  it('should preserve economy balance when final event has invalid data', async () => {
    const encoder = new TextEncoder();
    const stream = new ReadableStream({
      start(controller) {
        controller.enqueue(
          encoder.encode(
            JSON.stringify({
              type: 'final',
              data: {
                // narrative 필드 누락 등 스키마 위반
                language: 'ko-KR',
                economy: {
                  cost: { signal: 0, memory_shard: 0 },
                  balance_after: { signal: 0, memory_shard: 0 },
                },
              },
            }) + '\n',
          ),
        );
        controller.close();
      },
    });

    (global.fetch as unknown as ReturnType<typeof vi.fn>).mockResolvedValue({
      ok: true,
      body: stream,
    });

    await executeTurnStream(mockInput, mockCallbacks);

    expect(mockCallbacks.onFinal).toHaveBeenCalled();
    const finalEvent = mockCallbacks.onFinal.mock.calls[0][0];
    expect(finalEvent.data.economy.balance_after.signal).toBe(150);
    expect(finalEvent.data.economy.balance_after.memory_shard).toBe(5);
    expect(finalEvent.data.agent_console.badges).toContain('schema_fail');
  });

  it('should preserve economy balance on network error (fetch rejection)', async () => {
    (global.fetch as unknown as ReturnType<typeof vi.fn>).mockRejectedValue(
      new Error('Network failure'),
    );

    await executeTurnStream(mockInput, mockCallbacks);

    expect(mockCallbacks.onError).toHaveBeenCalled();
    expect(mockCallbacks.onFinal).toHaveBeenCalled();

    const finalEvent = mockCallbacks.onFinal.mock.calls[0][0];
    expect(finalEvent.data.economy.balance_after.signal).toBe(150);
    expect(finalEvent.data.economy.balance_after.memory_shard).toBe(5);
    expect(finalEvent.data.narrative).toContain('서버 연결에 실패');
  });
});
</file>

<file path="frontend/src/components/DemoProfileSelect.tsx">
/**
 * Unknown World - 데모 프로필 선택 컴포넌트 (U-015[Mvp], U-116[Mvp]).
 *
 * 첫 화면에서 3종의 데모 프로필을 선택할 수 있는 UI를 제공합니다.
 * U-116: SaveGame 제거 후 항상 이 화면에서 시작합니다.
 *
 * 설계 원칙:
 *   - RULE-002: 채팅 UI 금지, 게임 UI로 상시 노출
 *   - RULE-006: i18n 키 기반 다국어 지원
 *   - PRD 6.9: 데모 프로필 선택만으로 즉시 시작
 *
 * @module components/DemoProfileSelect
 */

import { useCallback } from 'react';
import { useTranslation } from 'react-i18next';
import { DEMO_PROFILES, type DemoProfile } from '../data/demoProfiles';
import { SUPPORTED_LANGUAGES, type SupportedLanguage } from '../i18n';

// =============================================================================
// 타입 정의
// =============================================================================

export interface DemoProfileSelectProps {
  /** 프로필 선택 시 호출되는 콜백 */
  onSelectProfile: (profile: DemoProfile) => void;
  /** U-044: 현재 선택된 언어 */
  currentLanguage?: SupportedLanguage;
  /** U-044: 언어 변경 콜백 (profile_select에서만 허용) */
  onLanguageChange?: (language: SupportedLanguage) => void;
}

// =============================================================================
// 컴포넌트
// =============================================================================

/** U-044: 언어 표시 레이블 매핑 */
const LANGUAGE_LABELS: Record<SupportedLanguage, string> = {
  'ko-KR': '한국어',
  'en-US': 'English',
};

/**
 * 데모 프로필 선택 화면.
 * 게임 시작 전에 3종의 프로필 중 하나를 선택합니다.
 * U-044: 언어 선택 UI 포함 (profile_select에서만 변경 가능).
 * U-116: SaveGame 제거 후 Continue 버튼 제거.
 */
export function DemoProfileSelect({
  onSelectProfile,
  currentLanguage = 'en-US',
  onLanguageChange,
}: DemoProfileSelectProps) {
  const { t } = useTranslation();

  const handleSelectProfile = useCallback(
    (profile: DemoProfile) => {
      onSelectProfile(profile);
    },
    [onSelectProfile],
  );

  /** U-044: 언어 토글 핸들러 */
  const nextLanguage =
    SUPPORTED_LANGUAGES[
      (SUPPORTED_LANGUAGES.indexOf(currentLanguage) + 1) % SUPPORTED_LANGUAGES.length
    ];

  const handleLanguageToggle = useCallback(() => {
    if (!onLanguageChange) return;
    onLanguageChange(nextLanguage);
  }, [nextLanguage, onLanguageChange]);

  return (
    <div className="profile-select-container" data-ui-importance="critical">
      {/* U-044: 언어 선택 토글 (우측 상단) — 전환 대상 언어를 표시 */}
      {onLanguageChange && (
        <div className="language-toggle-container">
          <button
            type="button"
            className="language-toggle-btn"
            onClick={handleLanguageToggle}
            aria-label={t('language.toggle')}
            title={t('language.toggle_tooltip')}
          >
            <span className="language-toggle-icon" aria-hidden="true">
              🌐
            </span>
            <span className="language-toggle-label">{LANGUAGE_LABELS[nextLanguage]}</span>
          </button>
        </div>
      )}

      {/* 타이틀 */}
      <header className="profile-select-header">
        <h1 className="profile-select-title glitch" data-text={t('ui.logo')}>
          {t('ui.logo')}
        </h1>
        <p className="profile-select-subtitle">{t('profile.select_title')}</p>
      </header>

      {/* 프로필 카드 목록 */}
      <div className="profile-card-grid">
        {DEMO_PROFILES.map((profile) => (
          <button
            key={profile.id}
            type="button"
            className="profile-card"
            onClick={() => handleSelectProfile(profile)}
            style={{ '--profile-accent': profile.themeColor } as React.CSSProperties}
            aria-label={t(profile.nameKey)}
          >
            <span className="profile-card-icon" aria-hidden="true">
              {profile.icon}
            </span>
            <span className="profile-card-name">{t(profile.nameKey)}</span>
            <span className="profile-card-description">{t(profile.descriptionKey)}</span>
          </button>
        ))}
      </div>

      {/* 안내 문구 */}
      <footer className="profile-select-footer">
        <p className="profile-select-hint">{t('profile.select_hint')}</p>
      </footer>
    </div>
  );
}
</file>

<file path="frontend/src/components/Hotspot.test.tsx">
import { describe, it, expect, vi, beforeEach } from 'vitest';
import { render, screen, fireEvent } from '@testing-library/react';
import { Hotspot } from './Hotspot';
import { useOnboardingStore } from '../stores/onboardingStore';
import type { SceneObject } from '../schemas/turn';

// i18next 모킹
vi.mock('react-i18next', () => ({
  useTranslation: () => ({
    t: (key: string) => key,
  }),
}));

// dnd-kit 모킹
vi.mock('@dnd-kit/core', () => ({
  useDroppable: () => ({
    isOver: false,
    setNodeRef: vi.fn(),
  }),
}));

// box2d 유틸 모킹
vi.mock('../utils/box2d', () => ({
  box2dToPixel: vi.fn(() => ({
    top: 100,
    left: 100,
    width: 200,
    height: 200,
  })),
}));

describe('Hotspot UX - Hover Hint', () => {
  const mockObject: SceneObject = {
    id: 'test-obj',
    label: '테스트 오브젝트',
    box_2d: { ymin: 100, xmin: 100, ymax: 300, xmax: 300 },
    interaction_hint: '조사 가능',
  };

  const mockCanvasSize = { width: 1000, height: 1000 };
  const mockOnClick = vi.fn();

  beforeEach(() => {
    vi.clearAllMocks();
    useOnboardingStore.getState().resetOnboarding();
  });

  it('마우스 진입 시 onboardingStore의 카운트 증가 액션이 호출되어야 한다', () => {
    render(
      <Hotspot
        object={mockObject}
        canvasSize={mockCanvasSize}
        onClick={mockOnClick}
        disabled={false}
      />,
    );

    const hotspot = screen.getByRole('button');
    fireEvent.mouseEnter(hotspot);

    expect(useOnboardingStore.getState().hotspotHintCount).toBe(1);
  });

  it('힌트 표시 조건(첫 N번)을 만족할 때 InteractionHint가 렌더링되어야 한다', () => {
    render(
      <Hotspot
        object={mockObject}
        canvasSize={mockCanvasSize}
        onClick={mockOnClick}
        disabled={false}
      />,
    );

    const hotspot = screen.getByRole('button');
    fireEvent.mouseEnter(hotspot);

    // interaction.hotspot_click 키가 렌더링되는지 확인 (InteractionHint 컴포넌트 내의 텍스트)
    expect(screen.getByText('interaction.hotspot_click')).toBeInTheDocument();
  });

  it('힌트 임계값을 초과하면 InteractionHint가 렌더링되지 않아야 한다', () => {
    // 임계값까지 카운트 올리기
    for (let i = 0; i < 3; i++) {
      useOnboardingStore.getState().incrementHotspotHint();
    }
    expect(useOnboardingStore.getState().hotspotHintCount).toBe(3);

    render(
      <Hotspot
        object={mockObject}
        canvasSize={mockCanvasSize}
        onClick={mockOnClick}
        disabled={false}
      />,
    );

    const hotspot = screen.getByRole('button');
    fireEvent.mouseEnter(hotspot);

    // 힌트가 보이지 않아야 함
    expect(screen.queryByText('interaction.hotspot_click')).not.toBeInTheDocument();
  });

  it('비활성화 상태일 때는 카운트가 증가하지 않고 힌트도 보이지 않아야 한다', () => {
    render(
      <Hotspot
        object={mockObject}
        canvasSize={mockCanvasSize}
        onClick={mockOnClick}
        disabled={true}
      />,
    );

    const hotspot = screen.getByRole('button');
    fireEvent.mouseEnter(hotspot);

    expect(useOnboardingStore.getState().hotspotHintCount).toBe(0);
    expect(screen.queryByText('interaction.hotspot_click')).not.toBeInTheDocument();
  });
});
</file>

<file path="frontend/src/components/QuestPanel.test.tsx">
import { describe, it, expect, beforeEach, vi } from 'vitest';
import { render, screen } from '@testing-library/react';
import { QuestPanel } from './QuestPanel';
import { useWorldStore } from '../stores/worldStore';

// i18next 모킹 (t 함수가 키를 반환하도록)
vi.mock('react-i18next', () => ({
  useTranslation: () => ({
    t: (key: string) => key,
  }),
  initReactI18next: {
    type: '3rdParty',
    init: () => {},
  },
}));

describe('QuestPanel (U-013)', () => {
  beforeEach(() => {
    useWorldStore.getState().reset();
  });

  it('퀘스트가 없을 때 자유 탐색 상태를 표시해야 한다', () => {
    render(<QuestPanel />);
    // U-078: 빈 상태 → "자유 탐색" 안내로 변경
    expect(screen.getByText('quest.free_exploration')).toBeInTheDocument();
    expect(screen.getByText('quest.free_exploration_desc')).toBeInTheDocument();
  });

  it('진행 중인 퀘스트를 목록에 표시해야 한다', () => {
    useWorldStore.setState({
      quests: [
        {
          id: 'q1',
          label: '액티브 퀘스트',
          is_completed: false,
          description: null,
          is_main: false,
          progress: 0,
          reward_signal: 0,
        },
      ],
    });

    render(<QuestPanel />);
    expect(screen.getByText('액티브 퀘스트')).toBeInTheDocument();
  });

  it('완료된 퀘스트를 목록에 표시해야 한다', () => {
    useWorldStore.setState({
      quests: [
        {
          id: 'q2',
          label: '완료된 퀘스트',
          is_completed: true,
          description: null,
          is_main: false,
          progress: 100,
          reward_signal: 10,
        },
      ],
    });

    render(<QuestPanel />);
    expect(screen.getByText('완료된 퀘스트')).toBeInTheDocument();
  });

  it('주 목표와 세부 목표를 구분하여 표시해야 한다', () => {
    useWorldStore.setState({
      quests: [
        {
          id: 'q1',
          label: '주 목표',
          is_completed: false,
          description: '주 목표 설명',
          is_main: true,
          progress: 50,
          reward_signal: 100,
        },
        {
          id: 'q2',
          label: '세부 목표',
          is_completed: false,
          description: null,
          is_main: false,
          progress: 0,
          reward_signal: 20,
        },
      ],
    });

    render(<QuestPanel />);
    expect(screen.getByText('주 목표')).toBeInTheDocument();
    expect(screen.getByText('세부 목표')).toBeInTheDocument();
  });
});
</file>

<file path="frontend/src/components/SceneImage.test.tsx">
import { describe, it, expect, vi, beforeEach, afterEach } from 'vitest';
import { render, screen, act } from '@testing-library/react';
import { SceneImage } from './SceneImage';

// react-i18next 모킹
vi.mock('react-i18next', () => ({
  useTranslation: () => ({
    t: (key: string) => key,
  }),
}));

// 전역적으로 인스턴스를 추적하기 위한 배열
let imageInstances: Array<MockImage> = [];

// Image 객체 모킹
class MockImage {
  onload: (() => void) | null = null;
  onerror: (() => void) | null = null;
  _src: string = '';

  constructor() {
    imageInstances.push(this);
  }

  addEventListener(event: string, cb: () => void) {
    if (event === 'load') this.onload = cb;
    if (event === 'error') this.onerror = cb;
  }

  removeEventListener() {}

  set src(val: string) {
    this._src = val;
  }

  get src() {
    return this._src;
  }
}

describe('SceneImage Component (U-020)', () => {
  const originalImage = global.Image;

  beforeEach(() => {
    imageInstances = [];
    global.Image = MockImage as unknown as typeof Image;
  });

  afterEach(() => {
    global.Image = originalImage;
  });

  it('이미지 URL이 없을 때 placeholder를 표시해야 함', () => {
    render(<SceneImage status="default" />);
    expect(screen.getByText('scene.status.default')).toBeInTheDocument();
  });

  it('새로운 이미지 URL이 오면 로딩 인디케이터를 표시하고 이전 이미지를 유지해야 함 (Option A)', async () => {
    const { rerender } = render(<SceneImage status="scene" imageUrl="url-1.png" />);

    // 로딩 중 확인
    expect(screen.getByText('scene.status.image_loading')).toBeInTheDocument();

    // 첫 번째 이미지 로드 완료 시뮬레이션
    await act(async () => {
      if (imageInstances[0]?.onload) imageInstances[0].onload();
    });

    const img = screen.getByAltText('scene.status.alt');
    expect(img).toHaveAttribute('src', 'url-1.png');

    // 두 번째 이미지 요청
    await act(async () => {
      rerender(<SceneImage status="scene" imageUrl="url-2.png" />);
    });

    // 로딩 중 표시 확인
    expect(screen.getByText('scene.status.image_loading')).toBeInTheDocument();
    // 이전 이미지(url-1)가 여전히 보여야 함
    expect(screen.getByAltText('scene.status.alt')).toHaveAttribute('src', 'url-1.png');
  });

  it('이미지 로딩이 완료되면 새로운 이미지로 교체되어야 함', async () => {
    const { rerender } = render(<SceneImage status="scene" imageUrl="url-1.png" />);

    await act(async () => {
      if (imageInstances[0]?.onload) imageInstances[0].onload();
    });

    await act(async () => {
      rerender(<SceneImage status="scene" imageUrl="url-2.png" />);
    });

    // 두 번째 이미지 로드 완료 시뮬레이션
    await act(async () => {
      // 새로운 Image 인스턴스가 생성되었을 것임
      const secondInstance = imageInstances.find((inst) => inst.src === 'url-2.png');
      if (secondInstance?.onload) secondInstance.onload();
    });

    const img = screen.getByAltText('scene.status.alt');
    expect(img).toHaveAttribute('src', 'url-2.png');
    expect(screen.queryByText('scene.status.image_loading')).not.toBeInTheDocument();
  });

  it('이미지 로딩 실패 시 에러 배지를 표시하고 이전 이미지를 유지해야 함 (RULE-004)', async () => {
    const { rerender } = render(<SceneImage status="scene" imageUrl="url-1.png" />);

    await act(async () => {
      if (imageInstances[0]?.onload) imageInstances[0].onload();
    });

    await act(async () => {
      rerender(<SceneImage status="scene" imageUrl="url-2.png" />);
    });

    // 두 번째 이미지 로드 실패 시뮬레이션
    await act(async () => {
      const secondInstance = imageInstances.find((inst) => inst.src === 'url-2.png');
      if (secondInstance?.onerror) secondInstance.onerror();
    });

    expect(screen.getByText('scene.status.image_error')).toBeInTheDocument();
    expect(screen.getByAltText('scene.status.alt')).toHaveAttribute('src', 'url-1.png');
  });

  it('이미지가 전혀 없는 상태에서 에러 발생 시 placeholder를 표시해야 함', async () => {
    render(<SceneImage status="scene" imageUrl="invalid.png" />);

    await act(async () => {
      if (imageInstances[0]?.onerror) imageInstances[0].onerror();
    });

    expect(screen.getByText('scene.status.default')).toBeInTheDocument();
    expect(screen.getByText('⚠️')).toBeInTheDocument();
  });

  describe('Processing Overlay (U-071[Mvp])', () => {
    it('processingPhase가 processing일 때 처리 중 오버레이와 올바른 메시지를 표시해야 함', () => {
      render(<SceneImage status="scene" processingPhase="processing" />);

      expect(screen.getByText('scene.processing.processing')).toBeInTheDocument();
      // CRT 스피너 요소 존재 확인
      expect(document.querySelector('.scene-processing-spinner')).toBeInTheDocument();
    });

    it('processingPhase가 image_pending일 때 이미지 형성 중 메시지를 표시해야 함', () => {
      render(<SceneImage status="scene" processingPhase="image_pending" />);

      expect(screen.getByText('scene.processing.image_pending')).toBeInTheDocument();
    });

    it('처리 중일 때는 이전 이미지가 있더라도 숨겨야 함 (Option C)', async () => {
      const { rerender } = render(<SceneImage status="scene" imageUrl="old-url.png" />);

      // 1. 첫 번째 이미지 로드 완료
      await act(async () => {
        if (imageInstances[0]?.onload) imageInstances[0].onload();
      });

      expect(screen.getByAltText('scene.status.alt')).toHaveAttribute('src', 'old-url.png');

      // 2. 처리 중으로 전환
      rerender(<SceneImage status="scene" imageUrl="old-url.png" processingPhase="processing" />);

      // 이미지 요소가 렌더링되지 않아야 함 (Option C: 처리 중 숨김)
      expect(screen.queryByAltText('scene.status.alt')).not.toBeInTheDocument();
      // 오버레이는 표시되어야 함
      expect(screen.getByText('scene.processing.processing')).toBeInTheDocument();
    });
  });

  describe('Analyzing Overlay (U-089[Mvp])', () => {
    it('isAnalyzing이 true일 때 분석 전용 오버레이와 메시지를 표시해야 함', () => {
      render(<SceneImage status="scene" isAnalyzing={true} />);

      expect(screen.getByText('scene.analyzing.message')).toBeInTheDocument();
      expect(screen.getByText('scene.analyzing.hint')).toBeInTheDocument();
      // 스캔라인 요소 존재 확인
      expect(document.querySelector('.scene-analyzing-scanline')).toBeInTheDocument();
    });

    it('정밀분석 중에는 기존 이미지를 유지해야 함 (Option B)', async () => {
      const { rerender } = render(<SceneImage status="scene" imageUrl="old-url.png" />);

      // 1. 첫 번째 이미지 로드 완료
      await act(async () => {
        if (imageInstances[0]?.onload) imageInstances[0].onload();
      });

      expect(screen.getByAltText('scene.status.alt')).toHaveAttribute('src', 'old-url.png');

      // 2. 정밀분석 시작
      rerender(<SceneImage status="scene" imageUrl="old-url.png" isAnalyzing={true} />);

      // 이미지 요소가 여전히 존재해야 함 (기존 이미지 유지)
      expect(screen.getByAltText('scene.status.alt')).toHaveAttribute('src', 'old-url.png');
      // 분석 오버레이 표시 확인
      expect(screen.getByText('scene.analyzing.message')).toBeInTheDocument();
    });

    it('isAnalyzing이 true일 때는 processingPhase 오버레이보다 우선해야 함', () => {
      render(<SceneImage status="scene" isAnalyzing={true} processingPhase="processing" />);

      // 분석 오버레이는 표시됨
      expect(screen.getByText('scene.analyzing.message')).toBeInTheDocument();
      // 일반 처리 오버레이는 숨겨짐
      expect(screen.queryByText('scene.processing.processing')).not.toBeInTheDocument();
    });
  });
});
</file>

<file path="frontend/src/demo/useDemoInitializer.ts">
import { useEffect } from 'react';
import { useTranslation } from 'react-i18next';
import { useInventoryStore } from '../stores/inventoryStore';
import { useWorldStore } from '../stores/worldStore';
import type { Quest, WorldRule } from '../schemas/turn';
import type { MutationEvent } from '../stores/worldStore';
import {
  DEMO_INVENTORY_ITEMS,
  DEMO_SCENE_OBJECTS,
  DEMO_QUESTS,
  DEMO_RULES,
  getDemoItemNameKey,
  isDemoEnvironment,
} from '../demo/demoFixtures';

/**
 * 데모 환경에서 초기 mock 데이터를 로드하는 훅 (RU-003-Q5, U-013).
 */
export function useDemoInitializer() {
  const { t } = useTranslation();
  const { items: inventoryItems, addItems: addInventoryItems } = useInventoryStore();
  const worldStore = useWorldStore();
  const {
    sceneObjects,
    setSceneObjects,
    narrativeEntries,
    initialize: initializeWorld,
    quests,
    activeRules,
  } = worldStore;

  useEffect(() => {
    // 월드 초기화 (환영 메시지)
    if (narrativeEntries.length === 0) {
      initializeWorld(t('narrative.welcome'));
    }

    // DEV: 데모용 mock 데이터 초기화 (RU-003-Q5: DEV 가드 + i18n 키 기반)
    if (isDemoEnvironment()) {
      // 데모용 mock 인벤토리 초기화 (U-011)
      // U-075: 데모 아이템은 이모지 아이콘을 유지하므로 iconStatus: 'completed'로 설정
      if (inventoryItems.length === 0) {
        const demoInventory = DEMO_INVENTORY_ITEMS.map((item) => ({
          id: item.id,
          name: t(getDemoItemNameKey(item.id)),
          icon: item.icon,
          quantity: item.quantity,
          iconStatus: 'completed' as const, // U-075: 아이콘 생성 트리거 방지
        }));
        addInventoryItems(demoInventory);
      }

      // 데모용 mock Scene Objects 초기화 (U-010)
      if (sceneObjects.length === 0) {
        const demoSceneObjects = DEMO_SCENE_OBJECTS.map((obj) => ({
          id: obj.id,
          label: t(obj.labelKey),
          box_2d: obj.box_2d,
          interaction_hint: t(obj.hintKey),
        }));
        setSceneObjects(demoSceneObjects);
      }

      // 데모용 mock 퀘스트 초기화 (U-013, U-078)
      if (quests.length === 0) {
        const demoQuests: Quest[] = DEMO_QUESTS.map((q) => ({
          id: q.id,
          label: t(q.labelKey),
          is_completed: q.is_completed,
          description: q.descriptionKey ? t(q.descriptionKey) : null,
          is_main: q.is_main ?? false,
          progress: q.progress ?? 0,
          reward_signal: q.reward_signal ?? 0,
        }));
        useWorldStore.setState({ quests: demoQuests });
      }

      // 데모용 mock 규칙 초기화 (U-013)
      if (activeRules.length === 0) {
        const demoRules: WorldRule[] = DEMO_RULES.map((r) => ({
          id: r.id,
          label: t(r.labelKey),
          description: r.descriptionKey ? t(r.descriptionKey) : null,
        }));
        // 데모 뮤테이션 타임라인 생성 (규칙 추가 이벤트)
        const now = Date.now();
        const demoMutations: MutationEvent[] = DEMO_RULES.map((r, index) => ({
          turn: 0,
          ruleId: r.id,
          type: 'added' as const,
          label: t(r.labelKey),
          description: r.descriptionKey ? t(r.descriptionKey) : undefined,
          timestamp: now - index * 1000, // 시간 순서 구분용
        }));
        useWorldStore.setState({
          activeRules: demoRules,
          mutationTimeline: demoMutations,
        });
      }
    }
    // eslint-disable-next-line react-hooks/exhaustive-deps
  }, [t]);
}
</file>

<file path="frontend/src/schemas/index.ts">
/**
 * Unknown World - 스키마 모듈 진입점.
 *
 * TurnInput/TurnOutput Zod 스키마 및 관련 유틸리티를 재내보내기합니다.
 *
 * @module schemas
 */

// =============================================================================
// 스키마 버전
// =============================================================================

export { SCHEMA_VERSION } from './turn';

// =============================================================================
// Enum 스키마 및 타입
// =============================================================================

export {
  LanguageSchema,
  ThemeSchema,
  AgentPhaseSchema,
  ValidationBadgeSchema,
  ModelLabelSchema,
  RiskLevelSchema,
} from './turn';

export type { Language, Theme, AgentPhase, ValidationBadge, ModelLabel, RiskLevel } from './turn';

// =============================================================================
// 공통 하위 타입 스키마 및 타입
// =============================================================================

export { CoordinateSchema, Box2DSchema, CurrencyAmountSchema } from './turn';

export type { Coordinate, Box2D, CurrencyAmount } from './turn';

// =============================================================================
// TurnInput 관련 스키마 및 타입
// =============================================================================

export { ClickInputSchema, ClientInfoSchema, EconomySnapshotSchema, TurnInputSchema } from './turn';

export type { ClickInput, ClientInfo, EconomySnapshot, TurnInput } from './turn';

// =============================================================================
// TurnOutput 관련 스키마 및 타입
// =============================================================================

export {
  // UI
  ActionCardSchema,
  SceneObjectSchema,
  ActionDeckSchema,
  UIOutputSchema,
  // World
  MemoryPinSchema,
  WorldRuleSchema,
  QuestSchema,
  WorldDeltaSchema,
  // Render
  ImageJobSchema,
  RenderOutputSchema,
  // Economy
  LedgerEntrySchema,
  EconomyOutputSchema,
  // Safety
  SafetyOutputSchema, // Agent Console
  AgentConsoleSchema,
  // Main
  TurnOutputSchema,
} from './turn';

export type {
  // UI
  ActionCard,
  SceneObject,
  ActionDeck,
  UIOutput,
  // World
  MemoryPin,
  WorldRule,
  Quest,
  WorldDelta,
  // Render
  ImageJob,
  RenderOutput,
  // Economy
  LedgerEntry,
  EconomyOutput,
  // Safety
  SafetyOutput, // Agent Console
  AgentConsole,
  // Main
  TurnOutput,
} from './turn';

// =============================================================================
// 유틸리티 함수
// =============================================================================

export {
  createFallbackTurnOutput,
  safeParseTurnOutput,
  parseTurnInput,
  safeParseTurnInput,
} from './turn';

export type { TurnOutputParseResult, TurnInputSafeParseResult } from './turn';
</file>

<file path="frontend/src/setupTests.ts">
import '@testing-library/jest-dom';
import { vi } from 'vitest';

// window.matchMedia 모킹 (NarrativeFeed 등에서 사용)
Object.defineProperty(window, 'matchMedia', {
  writable: true,
  value: vi.fn().mockImplementation((query: string) => ({
    matches: false,
    media: query,
    onchange: null,
    addListener: vi.fn(), // deprecated
    removeListener: vi.fn(), // deprecated
    addEventListener: vi.fn(),
    removeEventListener: vi.fn(),
    dispatchEvent: vi.fn(),
  })),
});

// react-i18next 전역 모킹
vi.mock('react-i18next', () => ({
  useTranslation: () => ({
    t: (key: string) => key,
    i18n: {
      changeLanguage: vi.fn(),
      language: 'ko-KR',
    },
  }),
  initReactI18next: {
    type: '3rdParty',
    init: vi.fn(),
  },
  Trans: ({ children }: { children: React.ReactNode }) => children,
}));
</file>

<file path="frontend/src/stores/inventory_consumption.test.ts">
import { describe, it, expect, beforeEach, vi } from 'vitest';
import { useInventoryStore } from './inventoryStore';
import { useWorldStore } from './worldStore';
import type { TurnOutput } from '../schemas/turn';

// 하위 스토어 모킹 방지 (실제 로직 테스트를 위해)
vi.unmock('./inventoryStore');
vi.unmock('./economyStore');
vi.unmock('./actionDeckStore');

describe('Item Consumption (U-096)', () => {
  beforeEach(() => {
    useInventoryStore.getState().reset();
    useWorldStore.getState().reset();
    vi.useFakeTimers();
  });

  describe('InventoryStore Consumption Logic', () => {
    it('markConsuming: 아이템을 소비 중인 상태로 표시해야 한다', () => {
      const { markConsuming } = useInventoryStore.getState();
      markConsuming(['item1', 'item2']);

      const state = useInventoryStore.getState();
      expect(state.consumingItemIds).toContain('item1');
      expect(state.consumingItemIds).toContain('item2');
    });

    it('clearConsuming: 소비 애니메이션 완료 후 아이템을 실제로 제거해야 한다 (수량 1)', () => {
      const { addItems, markConsuming, clearConsuming } = useInventoryStore.getState();
      addItems([{ id: 'item1', name: 'Key', quantity: 1 }]);
      markConsuming(['item1']);

      clearConsuming(['item1']);

      const state = useInventoryStore.getState();
      expect(state.items).toHaveLength(0);
      expect(state.consumingItemIds).not.toContain('item1');
    });

    it('clearConsuming: 수량이 여러 개인 경우 수량만 감소시켜야 한다', () => {
      const { addItems, markConsuming, clearConsuming } = useInventoryStore.getState();
      addItems([{ id: 'potion', name: 'Potion', quantity: 3 }]);
      markConsuming(['potion']);

      clearConsuming(['potion']);

      const state = useInventoryStore.getState();
      expect(state.items).toHaveLength(1);
      expect(state.items[0].quantity).toBe(2);
      expect(state.consumingItemIds).not.toContain('potion');
    });

    it('clearConsuming: 중복 ID 제거 시 수량이 그만큼 감소해야 한다', () => {
      const { addItems, markConsuming, clearConsuming } = useInventoryStore.getState();
      addItems([{ id: 'potion', name: 'Potion', quantity: 3 }]);
      markConsuming(['potion']);

      clearConsuming(['potion', 'potion']);

      const state = useInventoryStore.getState();
      expect(state.items).toHaveLength(1);
      expect(state.items[0].quantity).toBe(1);
    });
  });

  describe('WorldStore Integration', () => {
    it('applyTurnOutput: inventory_removed가 포함되면 소비 애니메이션을 트리거해야 한다', () => {
      const { addItems } = useInventoryStore.getState();
      addItems([{ id: 'key_01', name: 'Iron Key', quantity: 1 }]);

      const mockOutput: Partial<TurnOutput> = {
        narrative: '열쇠를 사용했습니다.',
        language: 'ko-KR' as 'ko-KR' | 'en-US',
        economy: {
          cost: { signal: 0, memory_shard: 0 },
          balance_after: { signal: 100, memory_shard: 5 },
          credit: 0,
          low_balance_warning: false,
        },
        ui: {
          action_deck: { cards: [] },
          objects: [],
          scene: { image_url: '', alt_text: '' },
        },
        world: {
          inventory_added: [],
          inventory_removed: ['key_01'],
          quests_updated: [],
          rules_changed: [],
          relationships_changed: [],
          memory_pins: [],
        },
        agent_console: {
          current_phase: 'commit' as
            | 'parse'
            | 'validate'
            | 'plan'
            | 'resolve'
            | 'render'
            | 'verify'
            | 'commit',
          badges: [],
          repair_count: 0,
          model_label: 'FAST' as 'FAST' | 'QUALITY' | 'CHEAP' | 'REF',
        },
        safety: { blocked: false, message: null },
      };

      useWorldStore.getState().applyTurnOutput(mockOutput as TurnOutput);

      // 1단계: markConsuming 호출 확인
      expect(useInventoryStore.getState().consumingItemIds).toContain('key_01');
      expect(useInventoryStore.getState().items).toHaveLength(1); // 아직 제거 전

      // 2단계: 500ms 경과 후 제거 확인
      vi.advanceTimersByTime(500);
      expect(useInventoryStore.getState().items).toHaveLength(0); // 제거됨
      expect(useInventoryStore.getState().consumingItemIds).not.toContain('key_01');
    });
  });
});
</file>

<file path="frontend/src/stores/onboardingStore.test.ts">
/**
 * Unknown World - Onboarding Store Unit Tests
 *
 * U-117[Mvp]: 온보딩 가이드 팝업 제거 검증
 */

import { describe, it, expect, beforeEach } from 'vitest';
import {
  useOnboardingStore,
  selectShouldShowHotspotHint,
  selectShouldShowItemHint,
} from './onboardingStore';

describe('onboardingStore', () => {
  beforeEach(() => {
    useOnboardingStore.getState().resetOnboarding();
  });

  it('should not have popup related states (showOnboarding, onboardingStep, onboardingComplete)', () => {
    const state = useOnboardingStore.getState() as unknown as Record<string, unknown>;

    // 제거된 상태들이 존재하지 않아야 함
    expect(state.showOnboarding).toBeUndefined();
    expect(state.onboardingStep).toBeUndefined();
    expect(state.onboardingComplete).toBeUndefined();
  });

  it('should maintain hint count system for hover hints', () => {
    const state = useOnboardingStore.getState();

    expect(state.hotspotHintCount).toBe(0);
    expect(state.itemHintCount).toBe(0);

    // 힌트 표시 여부 셀렉터 작동 확인
    expect(selectShouldShowHotspotHint(state)).toBe(true);
    expect(selectShouldShowItemHint(state)).toBe(true);
  });

  it('should increment hint counts and eventually hide hints', () => {
    // 3번 증가 시도 (HINT_THRESHOLD = 3)
    useOnboardingStore.getState().incrementHotspotHint();
    useOnboardingStore.getState().incrementHotspotHint();
    useOnboardingStore.getState().incrementHotspotHint();

    const stateAfter3 = useOnboardingStore.getState();
    expect(stateAfter3.hotspotHintCount).toBe(3);
    expect(selectShouldShowHotspotHint(stateAfter3)).toBe(false); // 3회 이상이면 false

    // 더 증가하지 않아야 함 (HINT_THRESHOLD 이상이면 무시)
    useOnboardingStore.getState().incrementHotspotHint();
    expect(useOnboardingStore.getState().hotspotHintCount).toBe(3);
  });
});
</file>

<file path="frontend/src/stores/onboardingStore.ts">
/**
 * Unknown World - 인터랙션 힌트 상태 관리 스토어
 *
 * U-074[Mvp]: 핫스팟/아이템 인터랙션 안내 UX
 * - Q1 Option B: 첫 N번만 hover 힌트 표시 후 숨김 (학습 후 사라짐)
 *
 * U-117[Mvp]: 온보딩 가이드 팝업 제거
 * - showOnboarding, onboardingStep, onboardingComplete 상태 제거
 * - 관련 액션/셀렉터/initializeOnboarding 함수 제거
 * - hover 힌트 시스템(첫 N회 노출 후 숨김)만 유지
 *
 * RULE-006 준수: i18n 키 기반 텍스트
 *
 * @module stores/onboardingStore
 */

import { create } from 'zustand';
import { persist, createJSONStorage } from 'zustand/middleware';

// =============================================================================
// 상수 정의
// =============================================================================

/** 힌트를 표시할 최대 횟수 (이후 숨김) */
const HINT_THRESHOLD = 3;

/** localStorage 키 */
const STORAGE_KEY = 'unknown-world-onboarding';

// =============================================================================
// 타입 정의
// =============================================================================

interface OnboardingState {
  /** 핫스팟 hover 횟수 (첫 N번 후 힌트 숨김) */
  hotspotHintCount: number;

  /** 아이템 hover 횟수 (첫 N번 후 힌트 숨김) */
  itemHintCount: number;
}

interface OnboardingActions {
  /** 핫스팟 힌트 표시 횟수 증가 */
  incrementHotspotHint: () => void;

  /** 아이템 힌트 표시 횟수 증가 */
  incrementItemHint: () => void;

  /** 힌트 상태 초기화 (개발/테스트용) */
  resetOnboarding: () => void;
}

type OnboardingStore = OnboardingState & OnboardingActions;

// =============================================================================
// 초기 상태
// =============================================================================

const initialState: OnboardingState = {
  hotspotHintCount: 0,
  itemHintCount: 0,
};

// =============================================================================
// 셀렉터 함수 (성능 최적화)
// =============================================================================

/**
 * 핫스팟 힌트 표시 여부 (첫 N번만 true)
 */
export const selectShouldShowHotspotHint = (state: OnboardingState): boolean =>
  state.hotspotHintCount < HINT_THRESHOLD;

/**
 * 아이템 힌트 표시 여부 (첫 N번만 true)
 */
export const selectShouldShowItemHint = (state: OnboardingState): boolean =>
  state.itemHintCount < HINT_THRESHOLD;

// =============================================================================
// Zustand Store
// =============================================================================

export const useOnboardingStore = create<OnboardingStore>()(
  persist(
    (set, get) => ({
      ...initialState,

      incrementHotspotHint: () => {
        const { hotspotHintCount } = get();
        if (hotspotHintCount < HINT_THRESHOLD) {
          set({ hotspotHintCount: hotspotHintCount + 1 });
        }
      },

      incrementItemHint: () => {
        const { itemHintCount } = get();
        if (itemHintCount < HINT_THRESHOLD) {
          set({ itemHintCount: itemHintCount + 1 });
        }
      },

      resetOnboarding: () => {
        set(initialState);
      },
    }),
    {
      name: STORAGE_KEY,
      storage: createJSONStorage(() => localStorage),
      partialize: (state) => ({
        hotspotHintCount: state.hotspotHintCount,
        itemHintCount: state.itemHintCount,
      }),
    },
  ),
);

// =============================================================================
// 상수 노출 (테스트용)
// =============================================================================

/**
 * 힌트 임계값 상수 노출 (테스트용)
 */
export const ONBOARDING_HINT_THRESHOLD = HINT_THRESHOLD;
</file>

<file path="frontend/src/styles/hotspot.css">
/**
 * Unknown World - 핫스팟 전용 스타일
 *
 * U-058[Mvp]: 핫스팟 디자인 개선
 * - Q1 Option C: Magenta/Purple 계열 강조
 * - Q2 Option A: L자 브라켓 코너 마커
 *
 * RULE-009 준수: 스타일만 변경, 좌표 로직 불변
 * RULE-002 준수: 채팅 UI가 아닌 게임 UI
 *
 * @see vibe/ref/frontend-style-guide.md
 */

/* ============================================
   1. 핫스팟 레이어 (장면 이미지 위 오버레이)
   ============================================ */

.hotspot-layer {
  position: absolute;
  top: 0;
  left: 0;
  width: 100%;
  height: 100%;
  pointer-events: none;
  z-index: 10;
}

/* ============================================
   2. 핫스팟 컴포넌트 기본 스타일
   - L자 코너 마커 + 얇은 스트로크 + 반투명 배경
   ============================================ */

.hotspot {
  position: absolute;
  pointer-events: auto;
  cursor: pointer;

  /* 면: 미세한 마젠타 틴트 (콘텐츠 가시성 보호) */
  background-color: var(--hotspot-bg);

  /* 테두리: 얇은 마젠타 (기존 dashed 대신 solid) */
  border: var(--hotspot-stroke-width) solid var(--hotspot-primary);
  border-radius: 2px;

  /* 글로우: 부드러운 마젠타 외곽선 */
  box-shadow:
    0 0 6px var(--hotspot-glow),
    inset 0 0 2px rgba(224, 64, 251, 0.1);

  /* GPU 가속: 다수 핫스팟 성능 최적화 */
  will-change: transform, box-shadow;

  /* 상태 전환 애니메이션 */
  transition:
    border-color 0.2s ease-out,
    background-color 0.2s ease-out,
    box-shadow 0.2s ease-out,
    transform 0.15s ease-out;
}

/* ============================================
   2.1 L자 코너 마커 (pseudo-elements)
   - 4개 코너에 SF/터미널 느낌의 브라켓
   ============================================ */

/* 코너 마커 공통 스타일 */
.hotspot::before,
.hotspot::after,
.hotspot-corners::before,
.hotspot-corners::after {
  content: '';
  position: absolute;
  width: var(--hotspot-corner-size);
  height: var(--hotspot-corner-size);
  pointer-events: none;
  z-index: 1;
}

/* 좌상단 코너 (::before) */
.hotspot::before {
  top: -1px;
  left: -1px;
  border-top: var(--hotspot-corner-thickness) solid var(--hotspot-primary);
  border-left: var(--hotspot-corner-thickness) solid var(--hotspot-primary);
  border-radius: 2px 0 0 0;
}

/* 우상단 코너 (::after) */
.hotspot::after {
  top: -1px;
  right: -1px;
  border-top: var(--hotspot-corner-thickness) solid var(--hotspot-primary);
  border-right: var(--hotspot-corner-thickness) solid var(--hotspot-primary);
  border-radius: 0 2px 0 0;
}

/* 좌하단, 우하단 코너는 내부 요소로 구현 */
.hotspot-corners {
  position: absolute;
  inset: 0;
  pointer-events: none;
}

.hotspot-corners::before {
  bottom: -1px;
  left: -1px;
  top: auto;
  border-bottom: var(--hotspot-corner-thickness) solid var(--hotspot-primary);
  border-left: var(--hotspot-corner-thickness) solid var(--hotspot-primary);
  border-radius: 0 0 0 2px;
}

.hotspot-corners::after {
  bottom: -1px;
  right: -1px;
  top: auto;
  border-bottom: var(--hotspot-corner-thickness) solid var(--hotspot-primary);
  border-right: var(--hotspot-corner-thickness) solid var(--hotspot-primary);
  border-radius: 0 0 2px 0;
}

/* ============================================
   3. 호버 상태 (마우스 오버)
   - 색상 밝기 증가 + 코너 마커 확대 효과
   ============================================ */

.hotspot.hovered {
  background-color: rgba(240, 98, 146, 0.08);
  border-color: var(--hotspot-hover);
  box-shadow:
    0 0 10px rgba(240, 98, 146, 0.5),
    0 0 20px rgba(240, 98, 146, 0.2),
    inset 0 0 4px rgba(240, 98, 146, 0.15);
  transform: scale(1.01);
  /* 호버 시 z-index를 최상위로 올려 툴팁이 다른 핫스팟 위에 표시 */
  z-index: 100 !important;
}

/* 호버 시 코너 마커 색상 변경 */
.hotspot.hovered::before,
.hotspot.hovered::after {
  border-color: var(--hotspot-hover);
}

.hotspot.hovered .hotspot-corners::before,
.hotspot.hovered .hotspot-corners::after {
  border-color: var(--hotspot-hover);
}

/* 코너 마커 미세 펄스 애니메이션 (호버 시) */
.hotspot.hovered::before,
.hotspot.hovered::after,
.hotspot.hovered .hotspot-corners::before,
.hotspot.hovered .hotspot-corners::after {
  animation: corner-pulse 1.5s ease-in-out infinite;
}

@keyframes corner-pulse {
  0%,
  100% {
    opacity: 1;
  }
  50% {
    opacity: 0.7;
  }
}

/* ============================================
   4. 포커스 상태 (키보드 접근성)
   ============================================ */

.hotspot:focus {
  outline: none;
}

.hotspot:focus-visible {
  outline: 2px solid var(--hotspot-active);
  outline-offset: 3px;
}

/* ============================================
   5. 드롭 타겟 상태 (DnD 드래그 오버)
   - 앰버 색상 + 점멸 효과
   ============================================ */

.hotspot.drop-target-active {
  background-color: rgba(255, 171, 64, 0.1);
  border-color: var(--hotspot-drop);
  border-width: 2px;
  box-shadow:
    0 0 12px rgba(255, 171, 64, 0.5),
    0 0 24px rgba(255, 171, 64, 0.25),
    inset 0 0 6px rgba(255, 171, 64, 0.2);
  transform: scale(1.02);
  animation: drop-target-glow 0.8s ease-in-out infinite;
}

@keyframes drop-target-glow {
  0%,
  100% {
    box-shadow:
      0 0 12px rgba(255, 171, 64, 0.5),
      0 0 24px rgba(255, 171, 64, 0.25),
      inset 0 0 6px rgba(255, 171, 64, 0.2);
  }
  50% {
    box-shadow:
      0 0 16px rgba(255, 171, 64, 0.7),
      0 0 32px rgba(255, 171, 64, 0.35),
      inset 0 0 8px rgba(255, 171, 64, 0.3);
  }
}

/* 드롭 타겟 시 코너 마커 색상 변경 */
.hotspot.drop-target-active::before,
.hotspot.drop-target-active::after,
.hotspot.drop-target-active .hotspot-corners::before,
.hotspot.drop-target-active .hotspot-corners::after {
  border-color: var(--hotspot-drop);
  animation: corner-blink 0.6s ease-in-out infinite;
}

@keyframes corner-blink {
  0%,
  100% {
    opacity: 1;
  }
  50% {
    opacity: 0.5;
  }
}

/* ============================================
   6. 비활성화 상태
   - 흐릿한 색상 + 점선 테두리
   ============================================ */

.hotspot.disabled {
  cursor: not-allowed;
  background-color: rgba(156, 39, 176, 0.03);
  border-color: var(--hotspot-primary-dim);
  border-style: dashed;
  box-shadow: none;
  opacity: 0.5;
}

/* 비활성화 시 코너 마커 숨김 */
.hotspot.disabled::before,
.hotspot.disabled::after,
.hotspot.disabled .hotspot-corners::before,
.hotspot.disabled .hotspot-corners::after {
  opacity: 0.3;
  border-color: var(--hotspot-primary-dim);
}

.hotspot.disabled:hover {
  transform: none;
  border-color: var(--hotspot-primary-dim);
  background-color: rgba(156, 39, 176, 0.03);
}

/* ============================================
   7. 데모 상태 (시각적 힌트)
   ============================================ */

.hotspot.demo-target {
  animation: demo-hint 2s ease-in-out infinite;
}

@keyframes demo-hint {
  0%,
  100% {
    box-shadow:
      0 0 6px var(--hotspot-glow),
      inset 0 0 2px rgba(224, 64, 251, 0.1);
  }
  50% {
    box-shadow:
      0 0 12px var(--hotspot-glow),
      0 0 20px rgba(224, 64, 251, 0.2),
      inset 0 0 4px rgba(224, 64, 251, 0.15);
  }
}

/* ============================================
   8. 핫스팟 툴팁
   - 마젠타 테마 적용
   ============================================ */

.hotspot-tooltip {
  position: absolute;
  bottom: calc(100% + 10px);
  left: 50%;
  transform: translateX(-50%);
  min-width: 100px;
  /* 다른 핫스팟 클릭을 차단하지 않도록 이벤트 투과 */
  pointer-events: none;
  max-width: 220px;
  padding: var(--spacing-xs) var(--spacing-sm);
  background-color: rgba(20, 0, 30, 0.95);
  border: 1px solid var(--hotspot-primary);
  border-radius: 3px;
  box-shadow:
    0 0 8px var(--hotspot-glow),
    0 4px 12px rgba(0, 0, 0, 0.8);
  z-index: 20;
  white-space: nowrap;
  animation: tooltip-appear 0.15s ease-out;
}

@keyframes tooltip-appear {
  from {
    opacity: 0;
    transform: translateX(-50%) translateY(6px);
  }
  to {
    opacity: 1;
    transform: translateX(-50%) translateY(0);
  }
}

/* 툴팁 화살표 */
.hotspot-tooltip::after {
  content: '';
  position: absolute;
  top: 100%;
  left: 50%;
  transform: translateX(-50%);
  border: 7px solid transparent;
  border-top-color: var(--hotspot-primary);
}

/* 상단 여백 부족 시 툴팁을 아래쪽에 표시 */
.hotspot.tooltip-below .hotspot-tooltip {
  bottom: auto;
  top: calc(100% + 10px);
}

.hotspot.tooltip-below .hotspot-tooltip::after {
  top: auto;
  bottom: 100%;
  border-top-color: transparent;
  border-bottom-color: var(--hotspot-primary);
}

/* 드롭 타겟 + 아래쪽 툴팁 화살표 색상 */
.hotspot.tooltip-below.drop-target-active .hotspot-tooltip::after {
  border-top-color: transparent;
  border-bottom-color: var(--hotspot-drop);
}

/* 툴팁 라벨 */
.hotspot-tooltip-label {
  display: block;
  font-size: var(--font-size-sm);
  font-weight: bold;
  color: var(--hotspot-primary);
  text-transform: uppercase;
  letter-spacing: 1px;
  text-shadow: 0 0 4px rgba(224, 64, 251, 0.4);
  -webkit-font-smoothing: antialiased;
}

/* 데모 힌트 */
.hotspot-tooltip-demo {
  display: block;
  margin-top: 3px;
  font-size: var(--font-size-xs);
  color: var(--hotspot-hover);
  font-style: italic;
}

/* 상호작용 힌트 */
.hotspot-tooltip-hint {
  display: block;
  margin-top: 3px;
  font-size: var(--font-size-xs);
  color: var(--text-dim);
}

/* 드롭 힌트 */
.hotspot-tooltip-drop-hint {
  display: block;
  margin-top: 4px;
  font-size: var(--font-size-sm);
  font-weight: bold;
  color: var(--hotspot-drop);
  text-transform: uppercase;
  letter-spacing: 1px;
  animation: drop-hint-flash 0.6s ease-in-out infinite;
}

@keyframes drop-hint-flash {
  0%,
  100% {
    opacity: 1;
  }
  50% {
    opacity: 0.6;
  }
}

/* 드롭 타겟 활성 시 툴팁 테두리 색상 변경 */
.hotspot.drop-target-active .hotspot-tooltip {
  border-color: var(--hotspot-drop);
  box-shadow:
    0 0 10px rgba(255, 171, 64, 0.4),
    0 4px 12px rgba(0, 0, 0, 0.8);
}

.hotspot.drop-target-active .hotspot-tooltip::after {
  border-top-color: var(--hotspot-drop);
}

/* ============================================
   9. 모바일 조정
   ============================================ */

@media (max-width: 768px) {
  .hotspot {
    /* 터치 영역 최소 44px 보장 */
    min-width: 44px;
    min-height: 44px;
  }

  /* 모바일에서 툴팁은 아래로 표시 */
  .hotspot-tooltip {
    bottom: auto;
    top: calc(100% + 8px);
    max-width: 160px;
  }

  .hotspot-tooltip::after {
    top: auto;
    bottom: 100%;
    border-top-color: transparent;
    border-bottom-color: var(--hotspot-primary);
  }

  .hotspot.drop-target-active .hotspot-tooltip::after {
    border-top-color: transparent;
    border-bottom-color: var(--hotspot-drop);
  }

  /* 코너 마커 크기 축소 */
  .hotspot::before,
  .hotspot::after,
  .hotspot-corners::before,
  .hotspot-corners::after {
    width: 8px;
    height: 8px;
  }
}

/* ============================================
   10. 접근성: reduced-motion
   ============================================ */

@media (prefers-reduced-motion: reduce) {
  .hotspot {
    transition: none;
    will-change: auto;
  }

  .hotspot.hovered {
    transform: none;
  }

  .hotspot.drop-target-active {
    animation: none;
    transform: none;
  }

  .hotspot.demo-target {
    animation: none;
  }

  .hotspot.hovered::before,
  .hotspot.hovered::after,
  .hotspot.hovered .hotspot-corners::before,
  .hotspot.hovered .hotspot-corners::after,
  .hotspot.drop-target-active::before,
  .hotspot.drop-target-active::after,
  .hotspot.drop-target-active .hotspot-corners::before,
  .hotspot.drop-target-active .hotspot-corners::after {
    animation: none;
  }

  .hotspot-tooltip {
    animation: none;
  }

  .hotspot-tooltip-drop-hint {
    animation: none;
  }
}

/* ============================================
   11. 고대비 모드 지원
   ============================================ */

@media (prefers-contrast: more) {
  .hotspot {
    border-width: 2px;
    box-shadow:
      0 0 0 1px rgba(0, 0, 0, 0.8),
      0 0 8px var(--hotspot-glow);
  }

  .hotspot::before,
  .hotspot::after,
  .hotspot-corners::before,
  .hotspot-corners::after {
    border-width: 3px;
  }

  .hotspot-tooltip {
    border-width: 2px;
  }
}
</file>

<file path="frontend/src/turn/turnRunner.test.ts">
import { describe, it, expect, vi, beforeEach, type Mock } from 'vitest';
import { createTurnRunner } from './turnRunner';
import type { TurnInput } from '../schemas/turn';
import type { StreamCallbacks } from '../api/turnStream';

// 모킹
vi.mock('../api/turnStream', () => ({
  startTurnStream: vi.fn(() => vi.fn()),
}));

vi.mock('../api/image', () => ({
  startImageGeneration: vi.fn(),
}));

const mockWorldStore = {
  economy: { signal: 100, memory_shard: 5 },
  sceneState: { status: 'scene', imageUrl: 'old-url.png' },
  setIsAnalyzing: vi.fn(),
  setSceneState: vi.fn(),
  setProcessingPhase: vi.fn(),
  turnCount: 1,
};

vi.mock('../stores/worldStore', () => ({
  useWorldStore: {
    getState: vi.fn(() => mockWorldStore),
  },
}));

vi.mock('../stores/agentStore', () => ({
  useAgentStore: {
    getState: vi.fn(() => ({
      isStreaming: false,
      startStream: vi.fn(),
      completeStream: vi.fn(),
      handleStage: vi.fn(),
      handleBadges: vi.fn(),
      handleNarrativeDelta: vi.fn(),
      handleFinal: vi.fn(),
      handleError: vi.fn(),
    })),
  },
}));

vi.mock('react-i18next', () => ({
  useTranslation: () => ({
    t: (key: string) => key,
  }),
}));

describe('turnRunner (U-089[Mvp])', () => {
  beforeEach(() => {
    vi.clearAllMocks();
  });

  it('정밀분석 키워드 감지 시 isAnalyzing을 true로 설정해야 함', () => {
    const runner = createTurnRunner({
      t: (key: string) => key,
      theme: 'dark',
      language: 'ko-KR',
    });

    // 1. "정밀분석" 텍스트 입력
    runner.runTurn({ text: '정밀분석 해줘' });
    expect(mockWorldStore.setIsAnalyzing).toHaveBeenCalledWith(true);

    // 2. 일반 텍스트 입력 시에는 설정하지 않아야 함
    vi.clearAllMocks();
    runner.runTurn({ text: '안녕하세요' });
    expect(mockWorldStore.setIsAnalyzing).not.toHaveBeenCalled();
  });

  it('정밀분석 actionId 감지 시 isAnalyzing을 true로 설정해야 함', () => {
    const runner = createTurnRunner({
      t: (key: string) => key,
      theme: 'dark',
      language: 'ko-KR',
    });

    runner.runTurn({ text: '', actionId: 'deep_analyze' });
    expect(mockWorldStore.setIsAnalyzing).toHaveBeenCalledWith(true);
  });

  it('정밀분석 중에는 setSceneState({status: "loading"})을 호출하지 않아야 함 (기존 이미지 유지)', () => {
    const runner = createTurnRunner({
      t: (key: string) => key,
      theme: 'dark',
      language: 'ko-KR',
    });

    runner.runTurn({ text: '정밀분석' });

    // isAnalyzing은 true
    expect(mockWorldStore.setIsAnalyzing).toHaveBeenCalledWith(true);
    // status: 'loading'은 호출되지 않아야 함
    expect(mockWorldStore.setSceneState).not.toHaveBeenCalledWith(
      expect.objectContaining({ status: 'loading' }),
    );
  });

  it('턴 완료 시 최소 표시 시간 이후 isAnalyzing을 false로 설정해야 함', async () => {
    vi.useFakeTimers();
    const runner = createTurnRunner({
      t: (key: string) => key,
      theme: 'dark',
      language: 'ko-KR',
    });

    const { startTurnStream } = (await import('../api/turnStream')) as unknown as {
      startTurnStream: Mock;
    };
    let completeCallback: () => void = () => {};

    startTurnStream.mockImplementation((_input: TurnInput, callbacks: StreamCallbacks) => {
      completeCallback = callbacks.onComplete!;
      return vi.fn();
    });

    runner.runTurn({ text: '정밀분석' });
    expect(mockWorldStore.setIsAnalyzing).toHaveBeenCalledWith(true);

    // 턴 완료 호출
    completeCallback();

    // 즉시는 false가 되지 않아야 함 (최소 표시 시간 때문)
    expect(mockWorldStore.setIsAnalyzing).not.toHaveBeenLastCalledWith(false);

    // 500ms 경과 후
    vi.advanceTimersByTime(500);
    expect(mockWorldStore.setIsAnalyzing).toHaveBeenLastCalledWith(false);

    vi.useRealTimers();
  });
});

describe('turnRunner (U-124[Mvp]: toBackendReferenceUrl)', () => {
  beforeEach(() => {
    vi.clearAllMocks();
  });

  it('프론트엔드 정적 씬 이미지 URL을 백엔드 참조 URL로 변환해야 함', async () => {
    const { createTurnRunner } = await import('./turnRunner');
    const runner = createTurnRunner({
      t: (key: string) => key,
      theme: 'dark',
      language: 'ko-KR',
    });

    const { startTurnStream } = (await import('../api/turnStream')) as unknown as {
      startTurnStream: Mock;
    };

    // Narrator 프로필 초기 이미지
    mockWorldStore.sceneState.imageUrl = '/ui/scenes/scene-narrator-start.webp';
    runner.runTurn({ text: '테스트' });

    expect(startTurnStream).toHaveBeenCalledWith(
      expect.objectContaining({
        previous_image_url: '/api/image/file/scene-narrator-start',
      }),
      expect.any(Object),
    );
  });

  it('런타임 생성 이미지 URL(/api/image/file/...)은 그대로 유지해야 함', async () => {
    const { createTurnRunner } = await import('./turnRunner');
    const runner = createTurnRunner({
      t: (key: string) => key,
      theme: 'dark',
      language: 'ko-KR',
    });

    const { startTurnStream } = (await import('../api/turnStream')) as unknown as {
      startTurnStream: Mock;
    };

    // 런타임 생성 이미지
    const runtimeUrl = '/api/image/file/gen_12345.png';
    mockWorldStore.sceneState.imageUrl = runtimeUrl;
    runner.runTurn({ text: '테스트' });

    expect(startTurnStream).toHaveBeenCalledWith(
      expect.objectContaining({
        previous_image_url: runtimeUrl,
      }),
      expect.any(Object),
    );
  });

  it('외부 URL(http://...)은 그대로 유지해야 함', async () => {
    const { createTurnRunner } = await import('./turnRunner');
    const runner = createTurnRunner({
      t: (key: string) => key,
      theme: 'dark',
      language: 'ko-KR',
    });

    const { startTurnStream } = (await import('../api/turnStream')) as unknown as {
      startTurnStream: Mock;
    };

    // 외부 URL
    const externalUrl = 'https://example.com/image.png';
    mockWorldStore.sceneState.imageUrl = externalUrl;
    runner.runTurn({ text: '테스트' });

    expect(startTurnStream).toHaveBeenCalledWith(
      expect.objectContaining({
        previous_image_url: externalUrl,
      }),
      expect.any(Object),
    );
  });
});
</file>

<file path="frontend/src/types/scene.ts">
/**
 * Scene Canvas 관련 타입 정의 (U-031: Placeholder Pack, U-020: Lazy Render)
 */

/**
 * Scene 처리 단계 타입 (U-071: 로딩 인디케이터 강화)
 * - idle: 유휴 상태 (처리 없음)
 * - processing: 턴 처리 중 (텍스트 스트리밍)
 * - image_pending: 이미지 생성 대기/진행 중
 * - rendering: 결과 렌더링 중
 */
export type SceneProcessingPhase = 'idle' | 'processing' | 'image_pending' | 'rendering';

/**
 * Scene Canvas 상태 타입
 * - default: 기본 상태 (장면 이미지 없음)
 * - loading: 데이터 로딩 중
 * - offline: 오프라인/연결 끊김
 * - blocked: 안전/정책 차단
 * - low_signal: 재화/신호 부족
 * - scene: 정상 장면 표시 (이미지 URL 포함)
 */
export type SceneCanvasStatus =
  | 'default'
  | 'loading'
  | 'offline'
  | 'blocked'
  | 'low_signal'
  | 'scene';

/**
 * 이미지 로딩 상태 (U-020: Lazy Render)
 * - idle: 이미지 없음/대기
 * - loading: 이미지 로딩 중
 * - loaded: 이미지 로드 완료
 * - error: 이미지 로드 실패
 */
export type ImageLoadingState = 'idle' | 'loading' | 'loaded' | 'error';

/**
 * Scene Canvas 상태 데이터 구조
 *
 * U-020[Mvp] 확장:
 * - imageLoading: 이미지 로딩 상태 플래그 (로딩 인디케이터 표시용)
 * - previousImageUrl: 이전 이미지 URL (Option A: 이전 이미지 유지)
 *
 * U-066[Mvp] 확장:
 * - sceneRevision: late-binding 가드용 토큰 (turnCount 기반)
 * - pendingImageTurnId: 대기 중인 이미지 요청의 턴 ID
 */
export interface SceneCanvasState {
  status: SceneCanvasStatus;
  imageUrl?: string;
  message?: string;
  /** U-020: 이미지 로딩 중 여부 (로딩 인디케이터 표시용) */
  imageLoading?: boolean;
  /** U-020: 이전 이미지 URL (새 이미지 로딩 중 표시용) */
  previousImageUrl?: string;
  /** U-066: late-binding 가드용 토큰 (turnCount 기반) */
  sceneRevision?: number;
  /** U-066: 대기 중인 이미지 요청의 턴 ID */
  pendingImageTurnId?: number;
  /** U-071: 현재 처리 단계 (로딩 인디케이터 표시용) */
  processingPhase?: SceneProcessingPhase;
}

/**
 * 상태별 placeholder 정보 구조
 */
export interface PlaceholderInfo {
  imagePath: string;
  fallbackEmoji: string;
  labelKey: string;
}
</file>

<file path="frontend/vite.config.ts">
/// <reference types="vitest" />
import { defineConfig } from 'vite';
import react from '@vitejs/plugin-react';

// https://vite.dev/config/
export default defineConfig({
  plugins: [react()],
  server: {
    port: 8001, // RULE-011: 프론트엔드는 8001~8010 사용
    strictPort: true, // 포트 충돌 시 fail-fast (대역 밖 이동 방지)
    // 충돌 시: pnpm -C frontend dev --port 8002 (8002~8010 중 선택)
    proxy: {
      // 백엔드 API 프록시 (RULE-011: 백엔드는 8011~8020)
      '/api': {
        target: 'http://localhost:8011',
        changeOrigin: true,
      },
      // 정적 파일 프록시 (이미지 등)
      '/static': {
        target: 'http://localhost:8011',
        changeOrigin: true,
      },
    },
  },
  build: {
    outDir: 'dist',
    sourcemap: true,
  },
  test: {
    globals: true,
    environment: 'jsdom',
    setupFiles: './src/setupTests.ts',
  },
});
</file>

<file path="backend/debug_real_mode.py">
"""Debug script: real 모드에서 Gemini 응답을 확인합니다."""

import asyncio
import json
import os

# .env 로드
from pathlib import Path

from dotenv import load_dotenv

load_dotenv(dotenv_path=Path(__file__).parent / ".env", override=False)

# UW_MODE=real 강제
os.environ["UW_MODE"] = "real"

from pydantic import ValidationError

from unknown_world.models.turn import Language, TurnInput, TurnOutput
from unknown_world.orchestrator.generate_turn_output import TurnOutputGenerator
from unknown_world.services.genai_client import get_genai_client, reset_genai_client


async def main():
    # 클라이언트 초기화 확인
    reset_genai_client()
    client = get_genai_client()
    print(f"Client mode: {client.mode}")
    print(f"Client available: {client.is_available()}")
    print(f"GOOGLE_API_KEY set: {bool(os.environ.get('GOOGLE_API_KEY'))}")
    print()

    # TurnInput 생성
    turn_input = TurnInput(
        language=Language.KO,
        text="문을 열어본다",
        client={"viewport_w": 1920, "viewport_h": 1080, "theme": "dark"},
        economy_snapshot={"signal": 100, "memory_shard": 5},
    )

    # TurnOutputGenerator로 생성
    generator = TurnOutputGenerator(force_mock=False)
    result = await generator.generate(turn_input)

    print(f"Status: {result.status}")
    print(f"Model: {result.model_label}")
    print(f"Error: {result.error_message}")
    print(f"Error details: {json.dumps(result.error_details, indent=2, ensure_ascii=False)}")
    print()

    if result.raw_response:
        print("=== RAW RESPONSE (first 3000 chars) ===")
        print(result.raw_response[:3000])
        print()

        # 직접 파싱 시도
        try:
            text = result.raw_response.strip()
            if text.startswith("```"):
                lines = text.split("\n")
                if lines[0].startswith("```"):
                    lines = lines[1:]
                if lines and lines[-1].strip() == "```":
                    lines = lines[:-1]
                text = "\n".join(lines)

            data = json.loads(text)
            print("=== JSON PARSED OK ===")
            print(f"Top-level keys: {list(data.keys())}")
            print()

            # Pydantic 검증 시도
            try:
                TurnOutput.model_validate(data)
                print("=== PYDANTIC VALIDATION OK ===")
            except ValidationError as e:
                print("=== PYDANTIC VALIDATION ERRORS ===")
                for err in e.errors():
                    print(f"  Location: {err['loc']}")
                    print(f"  Type: {err['type']}")
                    print(f"  Message: {err['msg']}")
                    if "input" in err:
                        inp = str(err["input"])
                        print(f"  Input: {inp[:200]}")
                    print()
        except json.JSONDecodeError as e:
            print(f"=== JSON PARSE FAILED: {e} ===")

    if result.output:
        print("=== OUTPUT ===")
        print(f"Narrative: {result.output.narrative[:200]}")
        print(f"Badges: {result.output.agent_console.badges}")


if __name__ == "__main__":
    asyncio.run(main())
</file>

<file path="backend/src/unknown_world/api/turn_streaming_helpers.py">
"""Unknown World - Turn 스트리밍 공통 헬퍼.

NDJSON 스트리밍에서 반복되는 패턴을 추출한 헬퍼 함수들입니다.

설계 원칙:
    - RU-005-Q3: 중복되는 스트리밍 조각을 helper로 추출
    - RULE-004: 에러 경로에서도 final 1회 종료 인바리언트 유지
    - RULE-007/008: 프롬프트/내부 추론 노출 금지

참조:
    - vibe/refactors/RU-005-Q3.md
    - vibe/unit-plans/U-007[Mvp].md
"""

from __future__ import annotations

import asyncio
from collections.abc import AsyncGenerator

from unknown_world.api.turn_stream_events import (
    ErrorEvent,
    FinalEvent,
    NarrativeDeltaEvent,
    StreamEventType,
    serialize_event,
)
from unknown_world.models.turn import (
    CurrencyAmount,
    Language,
    TurnOutput,
)
from unknown_world.orchestrator.fallback import create_safe_fallback

# =============================================================================
# 스트리밍 헬퍼 상수
# =============================================================================

DEFAULT_CHUNK_SIZE = 20
"""내러티브 델타 청크 크기 (문자 수)."""

DEFAULT_TYPING_DELAY_SEC = 0.08
"""타자 효과 딜레이 (초). U-097: 체감 가능한 스트리밍을 위해 0.02→0.08로 조정."""

# =============================================================================
# 에러 메시지 (i18n)
# =============================================================================

ERROR_MESSAGES = {
    Language.KO: {
        "internal_error": "처리 중 오류가 발생했습니다",
        "validation_error": "입력 검증에 실패했습니다",
        "rate_limited": "API 요청 한도를 초과했습니다. 잠시 후 다시 시도해 주세요.",
    },
    Language.EN: {
        "internal_error": "An error occurred during processing",
        "validation_error": "Input validation failed",
        "rate_limited": "API request limit exceeded. Please try again shortly.",
    },
}


# =============================================================================
# 내러티브 델타 스트리밍 헬퍼
# =============================================================================


async def stream_narrative_delta(
    narrative: str,
    *,
    chunk_size: int = DEFAULT_CHUNK_SIZE,
    delay_sec: float = DEFAULT_TYPING_DELAY_SEC,
) -> AsyncGenerator[str]:
    """내러티브 텍스트를 타자 효과로 스트리밍합니다.

    Args:
        narrative: 전체 내러티브 텍스트
        chunk_size: 청크당 문자 수 (기본 20)
        delay_sec: 청크 간 딜레이 (초, 기본 0.02)

    Yields:
        str: NDJSON 라인 (narrative_delta 이벤트)

    Example:
        >>> async for line in stream_narrative_delta("안녕하세요"):
        ...     print(line)
    """
    for i in range(0, len(narrative), chunk_size):
        chunk = narrative[i : i + chunk_size]
        yield serialize_event(
            NarrativeDeltaEvent(
                type=StreamEventType.NARRATIVE_DELTA,
                text=chunk,
            ).model_dump()
        )
        await asyncio.sleep(delay_sec)


# =============================================================================
# Error + Final 폴백 헬퍼
# =============================================================================


async def emit_error_with_fallback(
    language: Language,
    *,
    error_message: str | None = None,
    error_code: str = "INTERNAL_ERROR",
    economy_snapshot: CurrencyAmount | None = None,
    repair_count: int = 0,
    is_blocked: bool = False,
) -> AsyncGenerator[str]:
    """에러 이벤트와 안전한 폴백 final을 순서대로 송출합니다.

    RULE-004: 에러 경로에서도 반드시 final 1회 종료 인바리언트를 유지합니다.

    Args:
        language: 응답 언어
        error_message: 에러 메시지 (None이면 기본 메시지 사용)
        error_code: 에러 코드 (기본 "INTERNAL_ERROR")
        economy_snapshot: 현재 재화 상태
        repair_count: 복구 시도 횟수
        is_blocked: 안전 정책에 의해 차단되었는지

    Yields:
        str: NDJSON 라인 (error 이벤트 → final 이벤트)

    Example:
        >>> async for line in emit_error_with_fallback(Language.KO):
        ...     print(line)
    """
    # 에러 메시지 결정
    messages = ERROR_MESSAGES[language]
    message = error_message or messages.get("internal_error", "Error occurred")

    # 에러 이벤트 송출
    yield serialize_event(
        ErrorEvent(
            type=StreamEventType.ERROR,
            message=message,
            code=error_code,
        ).model_dump()
    )

    # 안전한 폴백 생성 및 송출
    fallback = create_safe_fallback(
        language=language,
        economy_snapshot=economy_snapshot,
        repair_count=repair_count,
        is_blocked=is_blocked,
    )
    # U-069: TurnOutput을 먼저 직렬화하여 모든 필드 포함
    fallback_dict = fallback.model_dump(mode="json")
    yield serialize_event(
        FinalEvent(
            type=StreamEventType.FINAL,
            data=fallback_dict,
        ).model_dump(mode="json")
    )


async def emit_rate_limited_error(language: Language) -> AsyncGenerator[str]:
    """RATE_LIMITED 에러 이벤트를 송출합니다 (final 없이).

    U-130: 429 Rate Limit으로 모든 재시도가 소진된 경우 사용합니다.
    final 이벤트를 보내지 않으므로 프론트엔드에서 재시도 UI를 표시할 수 있습니다.

    Args:
        language: 응답 언어

    Yields:
        str: NDJSON 라인 (error 이벤트만, final 없음)
    """
    messages = ERROR_MESSAGES[language]
    message = messages.get("rate_limited", "API request limit exceeded.")

    yield serialize_event(
        ErrorEvent(
            type=StreamEventType.ERROR,
            message=message,
            code="RATE_LIMITED",
        ).model_dump()
    )


async def emit_final(output: TurnOutput) -> AsyncGenerator[str]:
    """최종 TurnOutput을 final 이벤트로 송출합니다.

    Args:
        output: 최종 TurnOutput

    Yields:
        str: NDJSON 라인 (final 이벤트)

    Note:
        U-069 버그 수정: TurnOutput을 먼저 model_dump()로 직렬화하여
        agent_console.model_label 등 모든 필드가 포함되도록 합니다.
        FinalEvent.data가 Any 타입이라 중첩 Pydantic 모델이
        자동 직렬화되지 않는 문제를 해결합니다.
    """
    # U-069: TurnOutput을 먼저 직렬화하여 모든 필드 포함
    output_dict = output.model_dump(mode="json")
    yield serialize_event(
        FinalEvent(
            type=StreamEventType.FINAL,
            data=output_dict,
        ).model_dump(mode="json")
    )


# =============================================================================
# 복합 헬퍼 (내러티브 + final)
# =============================================================================


async def stream_output_with_narrative(
    output: TurnOutput,
    *,
    chunk_size: int = DEFAULT_CHUNK_SIZE,
    delay_sec: float = DEFAULT_TYPING_DELAY_SEC,
) -> AsyncGenerator[str]:
    """내러티브 델타 스트리밍 후 final 이벤트를 송출합니다.

    Args:
        output: 최종 TurnOutput
        chunk_size: 청크당 문자 수
        delay_sec: 청크 간 딜레이 (초)

    Yields:
        str: NDJSON 라인 (narrative_delta 이벤트들 → final 이벤트)
    """
    # 내러티브 델타 스트리밍
    async for line in stream_narrative_delta(
        output.narrative,
        chunk_size=chunk_size,
        delay_sec=delay_sec,
    ):
        yield line

    # final 이벤트 송출
    async for line in emit_final(output):
        yield line


# =============================================================================
# 모듈 공개 API
# =============================================================================

__all__ = [
    "DEFAULT_CHUNK_SIZE",
    "DEFAULT_TYPING_DELAY_SEC",
    "ERROR_MESSAGES",
    "stream_narrative_delta",
    "emit_error_with_fallback",
    "emit_rate_limited_error",
    "emit_final",
    "stream_output_with_narrative",
]
</file>

<file path="backend/src/unknown_world/orchestrator/stages/resolve.py">
"""Unknown World - Resolve Stage.

해결 단계입니다.
U-076에서 "정밀분석" 트리거 분기가 추가되었습니다.
U-090에서 비정밀분석 턴의 핫스팟 생성을 강제 필터링합니다.

설계 원칙:
    - RULE-008: 단계 이벤트 일관성
    - RULE-009: bbox 0~1000 정규화
    - RULE-004: 실패 시 안전한 폴백 (빈 핫스팟 + 폴백 내러티브)
    - 동작 보존: 기존 시뮬레이션 지연 유지
    - U-076: "정밀분석" 트리거 시 Agentic Vision 실행 → 핫스팟 추가
    - U-090: 비정밀분석 턴에서 GM 생성 핫스팟 조용히 제거 (서버 안전장치)

참조:
    - vibe/refactors/RU-005-Q4.md
    - vibe/unit-plans/U-076[Mvp].md
    - vibe/unit-plans/U-090[Mvp].md
"""

from __future__ import annotations

import asyncio
import logging

from unknown_world.config.models import TextModelTiering
from unknown_world.models.turn import (
    AgentPhase,
    Language,
)
from unknown_world.orchestrator.stages.types import (
    EmitFn,
    PipelineContext,
    PipelineEvent,
    PipelineEventType,
)

# 모의 처리 지연 시간 (ms)
RESOLVE_DELAY_MS = 150

# 로거 (프롬프트/비밀정보 노출 금지 - RULE-007)
logger = logging.getLogger(__name__)


# =============================================================================
# 정밀분석 (Agentic Vision) 처리 (U-076)
# =============================================================================


def _is_vision_trigger(ctx: PipelineContext) -> bool:
    """정밀분석(비전 분석) 트리거 여부를 확인합니다.

    Args:
        ctx: 파이프라인 컨텍스트

    Returns:
        정밀분석 트리거 여부
    """
    action_id = ctx.turn_input.action_id
    text = ctx.turn_input.text
    return TextModelTiering.is_vision_trigger(action_id, text)


def _get_current_image_url(ctx: PipelineContext) -> str | None:
    """현재 Scene 이미지 URL을 확인합니다.

    정밀분석은 이미지가 있을 때만 실행 가능합니다.

    Args:
        ctx: 파이프라인 컨텍스트

    Returns:
        이미지 URL 또는 None
    """
    # 1. TurnInput에서 이전 이미지 URL 확인 (U-068)
    if ctx.turn_input.previous_image_url:
        return ctx.turn_input.previous_image_url

    # 2. TurnOutput.render에서 이미지 URL 확인
    if ctx.output and ctx.output.render and ctx.output.render.image_url:
        return ctx.output.render.image_url

    return None


async def _execute_vision_analysis(
    ctx: PipelineContext,
    image_url: str,
) -> PipelineContext:
    """Agentic Vision 분석을 실행하고 결과를 TurnOutput에 반영합니다.

    Args:
        ctx: 파이프라인 컨텍스트
        image_url: 분석할 Scene 이미지 URL

    Returns:
        업데이트된 컨텍스트
    """
    if ctx.output is None:
        return ctx

    language = ctx.turn_input.language

    try:
        from unknown_world.services.agentic_vision import (
            affordances_to_scene_objects,
            get_agentic_vision_service,
        )

        vision_service = get_agentic_vision_service()
        result = await vision_service.analyze_scene(image_url, language)

        if result.success and result.affordances:
            # affordances → SceneObject 변환
            new_objects = affordances_to_scene_objects(result.affordances)

            # 정밀분석: 비전 결과로 대체 (텍스트 모델은 이미지를 보지 않아 불일치)
            # 텍스트 모델이 생성한 objects는 내러티브 기반이므로
            # 실제 이미지를 분석한 비전 결과만 사용해야 정합성 유지
            merged_objects = new_objects[:5]

            # UI 업데이트
            new_ui = ctx.output.ui.model_copy(update={"objects": merged_objects})
            ctx.output = ctx.output.model_copy(update={"ui": new_ui})

            # 내러티브 보강: "장면을 자세히 살펴보니..."
            discovered_labels = [aff.label for aff in result.affordances]
            if language == Language.KO:
                vision_narrative = (
                    f"\n\n장면을 자세히 살펴봅니다... "
                    f"{', '.join(discovered_labels)}이(가) 눈에 들어옵니다."
                )
            else:
                vision_narrative = (
                    f"\n\nYou examine the scene closely... "
                    f"You notice {', '.join(discovered_labels)}."
                )

            new_narrative = ctx.output.narrative + vision_narrative
            ctx.output = ctx.output.model_copy(update={"narrative": new_narrative})

            logger.info(
                "[Resolve] 정밀분석 성공 (U-076)",
                extra={
                    "affordance_count": len(result.affordances),
                    "merged_object_count": len(merged_objects),
                    "analysis_time_ms": result.analysis_time_ms,
                },
            )

        else:
            # 분석 실패 또는 결과 없음 → 폴백 내러티브 (RULE-004)
            if language == Language.KO:
                fallback_text = "\n\n자세히 봐도 특별한 것은 보이지 않습니다."
            else:
                fallback_text = "\n\nEven looking closely, nothing special catches your eye."

            new_narrative = ctx.output.narrative + fallback_text
            ctx.output = ctx.output.model_copy(update={"narrative": new_narrative})

            logger.info(
                "[Resolve] 정밀분석 결과 없음/실패, 폴백 내러티브 적용 (U-076)",
                extra={
                    "success": result.success,
                    "message": result.message,
                },
            )

    except Exception as e:
        # 예외 발생 시 안전한 폴백 (RULE-004)
        logger.error(
            "[Resolve] 정밀분석 중 예외 발생, 폴백 적용",
            extra={"error_type": type(e).__name__},
        )
        if language == Language.KO:
            fallback_text = "\n\n자세히 봐도 특별한 것은 보이지 않습니다."
        else:
            fallback_text = "\n\nEven looking closely, nothing special catches your eye."

        new_narrative = ctx.output.narrative + fallback_text
        ctx.output = ctx.output.model_copy(update={"narrative": new_narrative})

    # 이미지 생성 강제 비활성 (정밀분석은 이미지 생성 없음)
    if ctx.output and ctx.output.render and ctx.output.render.image_job:
        no_gen_job = ctx.output.render.image_job.model_copy(update={"should_generate": False})
        new_render = ctx.output.render.model_copy(update={"image_job": no_gen_job})
        ctx.output = ctx.output.model_copy(update={"render": new_render})

    # 비용 배수 적용 (U-076 Q2: 1.5x)
    ctx.cost_multiplier = TextModelTiering.VISION_COST_MULTIPLIER

    return ctx


# =============================================================================
# Stage 함수
# =============================================================================


async def resolve_stage(ctx: PipelineContext, *, emit: EmitFn) -> PipelineContext:
    """Resolve 단계를 실행합니다.

    U-076: "정밀분석" 트리거가 감지되면 Agentic Vision 서비스를 호출하여
    이미지 내 오브젝트를 분석하고 핫스팟을 추가합니다.
    그 외에는 pass-through로 동작합니다.

    Args:
        ctx: 파이프라인 컨텍스트
        emit: 이벤트 emit 콜백

    Returns:
        업데이트된 컨텍스트
    """
    ctx.current_phase = AgentPhase.RESOLVE

    # Stage 시작 이벤트
    await emit(
        PipelineEvent(
            event_type=PipelineEventType.STAGE_START,
            phase=AgentPhase.RESOLVE,
        )
    )

    # U-076: 정밀분석 트리거 감지
    if _is_vision_trigger(ctx) and ctx.output is not None:
        image_url = _get_current_image_url(ctx)

        if image_url:
            logger.info(
                "[Resolve] 정밀분석 트리거 감지, Agentic Vision 실행 (U-076)",
                extra={
                    "action_id": ctx.turn_input.action_id,
                    "has_image": True,
                },
            )
            ctx = await _execute_vision_analysis(ctx, image_url)
        else:
            logger.info(
                "[Resolve] 정밀분석 트리거 감지, 그러나 이미지 없음 - 건너뜀",
            )
    else:
        # 기존 동작: pass-through + 모의 지연
        await asyncio.sleep(RESOLVE_DELAY_MS / 1000.0)

        # U-090: 비정밀분석 턴에서 GM이 생성한 핫스팟 조용히 제거
        # GM이 프롬프트 지시를 무시하고 objects[]에 핫스팟을 추가할 수 있으므로
        # 서버에서 강제로 빈 배열로 설정합니다 (Q2 결정: Option A - 조용히 제거)
        if ctx.output is not None and ctx.output.ui.objects:
            stripped_count = len(ctx.output.ui.objects)
            logger.warning(
                "[Resolve] U-090: 비정밀분석 턴에서 GM 생성 핫스팟 %d개 제거됨",
                stripped_count,
                extra={
                    "stripped_object_count": stripped_count,
                    "action_id": ctx.turn_input.action_id,
                },
            )
            new_ui = ctx.output.ui.model_copy(update={"objects": []})
            ctx.output = ctx.output.model_copy(update={"ui": new_ui})

    # Stage 완료 이벤트
    await emit(
        PipelineEvent(
            event_type=PipelineEventType.STAGE_COMPLETE,
            phase=AgentPhase.RESOLVE,
        )
    )

    return ctx
</file>

<file path="backend/src/unknown_world/orchestrator/stages/validate.py">
"""Unknown World - Validate Stage.

비즈니스 룰 검증 + Repair loop 단계입니다.
U-018의 run_repair_loop()를 호출해 output/badges/repair_count를 결정합니다.

설계 원칙:
    - RULE-003: 구조화 출력(JSON Schema) + 이중 검증
    - RULE-004: 검증 실패 시 Repair loop + 안전한 폴백
    - RULE-005: 재화 인바리언트 (잔액 음수 금지)
    - RULE-008: 단계/배지 가시화

참조:
    - vibe/refactors/RU-005-Q4.md
    - vibe/unit-plans/U-018[Mvp].md
"""

from __future__ import annotations

from unknown_world.models.turn import AgentPhase, Language, ValidationBadge
from unknown_world.orchestrator.fallback import create_safe_fallback
from unknown_world.orchestrator.mock import MockOrchestrator
from unknown_world.orchestrator.repair_loop import (
    MAX_REPAIR_ATTEMPTS,
    add_business_badges,
    run_repair_loop,
)
from unknown_world.orchestrator.stages.types import (
    EmitFn,
    PipelineContext,
    PipelineEvent,
    PipelineEventType,
)
from unknown_world.validation.business_rules import validate_business_rules


async def validate_stage(ctx: PipelineContext, *, emit: EmitFn) -> PipelineContext:
    """Validate 단계를 실행합니다.

    Mock 모드와 Real 모드를 구분하여 처리합니다.
    - Mock: MockOrchestrator로 생성 + 비즈니스 룰 검증
    - Real: run_repair_loop() 호출 (Gemini API + Repair loop)

    Args:
        ctx: 파이프라인 컨텍스트
        emit: 이벤트 emit 콜백

    Returns:
        업데이트된 컨텍스트 (output, badges, repair_attempts 포함)
    """
    ctx.current_phase = AgentPhase.VALIDATE

    # Stage 시작 이벤트
    await emit(
        PipelineEvent(
            event_type=PipelineEventType.STAGE_START,
            phase=AgentPhase.VALIDATE,
        )
    )

    try:
        if ctx.is_mock:
            await _validate_mock(ctx, emit)
        else:
            await _validate_real(ctx, emit)
    except Exception:
        # 예외 발생 시 폴백 (RULE-004, RU-005-S1)
        ctx.output = create_safe_fallback(
            language=ctx.turn_input.language,
            economy_snapshot=ctx.economy_snapshot,
            repair_count=ctx.repair_attempts,
        )
        ctx.is_fallback = True
        # RU-005-S1: 폴백의 배지를 스트림 이벤트와 동기화
        ctx.badges = list(ctx.output.agent_console.badges)

    # Stage 완료 이벤트
    await emit(
        PipelineEvent(
            event_type=PipelineEventType.STAGE_COMPLETE,
            phase=AgentPhase.VALIDATE,
        )
    )

    # 배지 이벤트 전송
    if ctx.badges:
        await emit(
            PipelineEvent(
                event_type=PipelineEventType.BADGES,
                badges=ctx.badges,
            )
        )

    return ctx


async def _validate_mock(ctx: PipelineContext, emit: EmitFn) -> None:
    """Mock 모드 검증을 수행합니다."""
    orchestrator = MockOrchestrator(seed=ctx.seed)
    repair_attempt = 0

    while repair_attempt <= MAX_REPAIR_ATTEMPTS:
        # 0회차는 정상 시도, 1회차부터는 repair
        if repair_attempt > 0:
            await emit(
                PipelineEvent(
                    event_type=PipelineEventType.REPAIR,
                    repair_attempt=repair_attempt,
                    repair_message=(
                        "검증 실패로 인해 다시 시도 중입니다..."
                        if ctx.turn_input.language == Language.KO
                        else "Retrying due to validation failure..."
                    ),
                )
            )
            ctx.repair_messages.append(
                "검증 실패로 인해 다시 시도 중입니다..."
                if ctx.turn_input.language == Language.KO
                else "Retrying due to validation failure..."
            )

        try:
            # Mock 생성
            turn_output = orchestrator.generate_turn_output(ctx.turn_input)

            # 비즈니스 룰 검증 (U-018)
            biz_result = validate_business_rules(ctx.turn_input, turn_output)
            if not biz_result.is_valid:
                # 비즈니스 룰 실패 → 재시도
                repair_attempt += 1
                ctx.repair_attempts = repair_attempt
                if repair_attempt > MAX_REPAIR_ATTEMPTS:
                    # 최종 실패 시 폴백 (RULE-004, RU-005-S1)
                    ctx.output = create_safe_fallback(
                        language=ctx.turn_input.language,
                        economy_snapshot=ctx.economy_snapshot,
                        repair_count=repair_attempt,
                    )
                    ctx.is_fallback = True
                    # RU-005-S1: 비즈니스 룰 실패 배지를 정확히 설정하고
                    # output과 ctx 배지를 동기화
                    failure_badges: list[ValidationBadge] = [ValidationBadge.SCHEMA_OK]
                    add_business_badges(biz_result, failure_badges)
                    ctx.output.agent_console.badges = failure_badges
                    ctx.badges = list(failure_badges)
                    return
                continue

            # 모든 검증 통과
            ctx.output = turn_output
            ctx.badges = [
                ValidationBadge.SCHEMA_OK,
                ValidationBadge.ECONOMY_OK,
                ValidationBadge.SAFETY_OK,
                ValidationBadge.CONSISTENCY_OK,
            ]
            ctx.repair_attempts = repair_attempt
            return

        except Exception:
            repair_attempt += 1
            ctx.repair_attempts = repair_attempt
            if repair_attempt > MAX_REPAIR_ATTEMPTS:
                # 최종 실패 시 폴백 (RULE-004, RU-005-S1)
                ctx.output = create_safe_fallback(
                    language=ctx.turn_input.language,
                    economy_snapshot=ctx.economy_snapshot,
                    repair_count=repair_attempt,
                )
                ctx.is_fallback = True
                # RU-005-S1: 폴백의 배지를 스트림 이벤트와 동기화
                ctx.badges = list(ctx.output.agent_console.badges)
                return
            continue

    # 루프 종료 시에도 폴백 (RU-005-S1)
    ctx.output = create_safe_fallback(
        language=ctx.turn_input.language,
        economy_snapshot=ctx.economy_snapshot,
        repair_count=repair_attempt,
    )
    ctx.is_fallback = True
    # RU-005-S1: 폴백의 배지를 스트림 이벤트와 동기화
    ctx.badges = list(ctx.output.agent_console.badges)


async def _validate_real(ctx: PipelineContext, emit: EmitFn) -> None:
    """Real 모드 검증을 수행합니다 (Gemini API + Repair loop).

    U-127: 대화 히스토리를 repair_loop에 전달하고, Thought Signature를 추적합니다.
    """
    # U-127: 대화 히스토리를 repair_loop에 전달
    result = await run_repair_loop(
        ctx.turn_input,
        conversation_history=ctx.conversation_history,
    )

    # Repair 이벤트 송출 (시도가 있었다면)
    for i in range(result.repair_attempts):
        message = result.error_messages[i] if i < len(result.error_messages) else ""
        await emit(
            PipelineEvent(
                event_type=PipelineEventType.REPAIR,
                repair_attempt=i + 1,
                repair_message=message[:100] if message else None,
            )
        )
        if message:
            ctx.repair_messages.append(message[:100])

    ctx.output = result.output
    ctx.badges = list(result.badges)
    ctx.repair_attempts = result.repair_attempts
    ctx.is_fallback = result.is_fallback
    # U-130: rate limit 상태 전파
    ctx.is_rate_limited = result.is_rate_limited

    # U-127: Thought Signature 저장 (파이프라인 종료 시 히스토리에 기록)
    ctx.thought_signature = result.thought_signature

    # U-069: 모델 티어링 정보 전달 (PipelineContext + TurnOutput)
    # config.models.ModelLabel을 models.turn.ModelLabel로 변환하여 할당 (Pyright 대응)
    from unknown_world.models.turn import ModelLabel as TurnModelLabel

    ctx.model_label = TurnModelLabel(result.model_label.value)
    ctx.cost_multiplier = result.cost_multiplier
    if ctx.output:
        ctx.output.agent_console.model_label = TurnModelLabel(result.model_label.value)
</file>

<file path="backend/src/unknown_world/storage/__init__.py">
"""Unknown World - 스토리지 모듈.

스토리지 추상화 계층을 제공합니다.
MVP: LocalStorage, MMP: GCSStorage(예정)

참조:
    - vibe/refactors/RU-006-Q4.md
    - vibe/refactors/RU-006-Q5.md
"""

from unknown_world.storage.local_storage import LocalStorage
from unknown_world.storage.paths import (
    ARTIFACTS_SUBDIR,
    BASE_DATA_DIR,
    DEFAULT_IMAGE_EXTENSION,
    IMAGES_GENERATED_SUBDIR,
    IMAGES_UPLOADED_SUBDIR,
    LEGACY_OUTPUT_DIR,
    STATIC_IMAGES_URL_PREFIX,
    STATIC_URL_PREFIX,
    build_image_url,
    build_legacy_image_url,
    get_artifacts_dir,
    get_generated_images_dir,
    get_uploaded_images_dir,
)
from unknown_world.storage.storage import (
    PutResult,
    StorageCategory,
    StorageInterface,
    StorageMetadata,
)
from unknown_world.storage.validation import (
    ALLOWED_IMAGE_MIME_TYPES,
    BBOX_MAX,
    BBOX_MIN,
    DEFAULT_ASPECT_RATIO,
    DEFAULT_IMAGE_SIZE,
    MAX_IMAGE_FILE_SIZE_BYTES,
    MAX_PROMPT_LENGTH,
    MIN_IMAGE_FILE_SIZE_BYTES,
    MIN_PROMPT_LENGTH,
    SUPPORTED_IMAGE_SIZES,
    get_max_file_size_mb,
    validate_image_generation_request,
    validate_image_upload,
)

__all__ = [
    # Storage
    "LocalStorage",
    "PutResult",
    "StorageCategory",
    "StorageInterface",
    "StorageMetadata",
    "get_storage",
    "reset_storage",
    # Paths (RU-006-Q5)
    "ARTIFACTS_SUBDIR",
    "BASE_DATA_DIR",
    "DEFAULT_IMAGE_EXTENSION",
    "IMAGES_GENERATED_SUBDIR",
    "IMAGES_UPLOADED_SUBDIR",
    "LEGACY_OUTPUT_DIR",
    "STATIC_IMAGES_URL_PREFIX",
    "STATIC_URL_PREFIX",
    "build_image_url",
    "build_legacy_image_url",
    "get_artifacts_dir",
    "get_generated_images_dir",
    "get_uploaded_images_dir",
    # Validation constants
    "ALLOWED_IMAGE_MIME_TYPES",
    "BBOX_MAX",
    "BBOX_MIN",
    "DEFAULT_ASPECT_RATIO",
    "DEFAULT_IMAGE_SIZE",
    "MAX_IMAGE_FILE_SIZE_BYTES",
    "MAX_PROMPT_LENGTH",
    "MIN_IMAGE_FILE_SIZE_BYTES",
    "MIN_PROMPT_LENGTH",
    "SUPPORTED_IMAGE_SIZES",
    # Validation functions
    "get_max_file_size_mb",
    "validate_image_generation_request",
    "validate_image_upload",
]

# 싱글톤 인스턴스 캐시
_storage_instance: StorageInterface | None = None


def get_storage(*, force_new: bool = False) -> StorageInterface:
    """스토리지 인스턴스를 반환합니다.

    환경변수에 따라 LocalStorage 또는 GCSStorage를 반환합니다.
    MVP에서는 LocalStorage만 사용합니다.

    Args:
        force_new: True면 캐시를 무시하고 새 인스턴스 생성

    Returns:
        StorageInterface 구현체
    """
    global _storage_instance

    if not force_new and _storage_instance is not None:
        return _storage_instance

    # MVP: LocalStorage만 사용
    # MMP: 환경변수로 GCS 전환 예정
    _storage_instance = LocalStorage()
    return _storage_instance


def reset_storage() -> None:
    """스토리지 캐시를 초기화합니다.

    테스트 시 스토리지를 재설정할 때 사용합니다.
    """
    global _storage_instance
    _storage_instance = None
</file>

<file path="backend/tests/integration/test_scanner_api.py">
"""U-021 이미지 이해(Scanner) API 통합 테스트."""

import os

# U-080 대응: 테스트 환경에서 Mock 모드 강제 (다른 임포트보다 먼저 실행)
os.environ["UW_MODE"] = "mock"

from fastapi.testclient import TestClient

from unknown_world.main import app
from unknown_world.models.scanner import ScanStatus

client = TestClient(app)


def test_scanner_health():
    """Scanner 헬스체크 엔드포인트 테스트."""
    response = client.get("/api/scan/health")
    assert response.status_code == 200
    data = response.json()
    assert data["status"] == "ok"
    assert "mode" in data
    assert "supported_formats" in data


def test_scan_image_mock_ko():
    """이미지 스캔 테스트 (Mock 모드, 한국어)."""
    # 테스트용 이미지 데이터 (100바이트 이상 필요)
    file_content = b"fake image content" * 10
    files = {"file": ("test.png", file_content, "image/png")}
    data = {"language": "ko-KR"}

    # UW_MODE=mock 환경에서 실행된다고 가정
    response = client.post("/api/scan", files=files, data=data)

    assert response.status_code == 200
    res_data = response.json()
    assert res_data["success"] is True
    assert res_data["status"] == ScanStatus.COMPLETED
    assert "[Mock]" in res_data["caption"]
    assert res_data["language"] == "ko-KR"
    assert len(res_data["objects"]) > 0
    assert len(res_data["item_candidates"]) > 0


def test_scan_image_mock_en():
    """이미지 스캔 테스트 (Mock 모드, 영어)."""
    file_content = b"fake image content" * 10
    files = {"file": ("test.png", file_content, "image/png")}
    data = {"language": "en-US"}

    response = client.post("/api/scan", files=files, data=data)

    assert response.status_code == 200
    res_data = response.json()
    assert res_data["success"] is True
    assert "[Mock]" in res_data["caption"]
    assert res_data["language"] == "en-US"


def test_scan_image_invalid_type():
    """지원하지 않는 파일 형식 테스트."""
    file_content = b"some text"
    files = {"file": ("test.txt", file_content, "text/plain")}

    response = client.post("/api/scan", files=files)

    assert response.status_code == 200  # 실패하더라도 200 응답 + success=False (RULE-004)
    res_data = response.json()
    assert res_data["success"] is False
    assert res_data["status"] == ScanStatus.FAILED
    assert "Unsupported image format" in res_data["message"]


def test_scan_image_too_large():
    """파일 크기 초과 테스트."""
    # 20MB + 1 byte
    large_content = b"a" * (20 * 1024 * 1024 + 1)
    files = {"file": ("large.png", large_content, "image/png")}

    response = client.post("/api/scan", files=files)

    assert response.status_code == 200
    res_data = response.json()
    assert res_data["success"] is False
    assert "File too large" in res_data["message"]
</file>

<file path="frontend/src/api/scanner.ts">
/**
 * Unknown World - Scanner(이미지 이해) API 클라이언트.
 *
 * U-022[Mvp]: Scanner 슬롯 UI에서 이미지 업로드 시 백엔드 `/api/scan` 호출.
 * U-021 의존: 백엔드 Scanner 엔드포인트와 연동.
 *
 * 설계 원칙:
 *   - RULE-004: 실패 시 안전한 폴백 (에러 메시지 반환)
 *   - RULE-007: 파일 내용/프롬프트 로깅 금지
 *   - RULE-009: bbox는 0~1000 정규화 + [ymin, xmin, ymax, xmax]
 *
 * @module api/scanner
 */

import { z } from 'zod';
import { Box2DSchema, type Language } from '../schemas/turn';

// =============================================================================
// 상수
// =============================================================================

/** Scanner API 엔드포인트 기본 URL */
const SCANNER_API_BASE = '/api/scan';

/** 지원하는 이미지 MIME 타입 */
export const ALLOWED_MIME_TYPES = ['image/jpeg', 'image/png', 'image/gif', 'image/webp'] as const;

/** 최대 파일 크기 (20MB) */
export const MAX_FILE_SIZE_BYTES = 20 * 1024 * 1024;

// =============================================================================
// Zod 스키마 정의 (백엔드 응답과 1:1 대응)
// =============================================================================

/**
 * 스캔 상태 Enum.
 */
export const ScanStatusSchema = z.enum(['completed', 'partial', 'failed', 'blocked']);
export type ScanStatus = z.infer<typeof ScanStatusSchema>;

/**
 * 감지된 오브젝트.
 * RULE-009: bbox는 0~1000 정규화.
 */
export const DetectedObjectSchema = z.object({
  label: z.string(),
  box_2d: Box2DSchema,
  confidence: z.number().min(0).max(1).nullable().optional(),
  suggested_item_type: z.string().nullable().optional(),
});
export type DetectedObject = z.infer<typeof DetectedObjectSchema>;

/**
 * 아이템 후보.
 * 스캔 결과로 생성되는 게임 아이템 후보.
 */
export const ItemCandidateSchema = z.object({
  id: z.string(),
  label: z.string(),
  description: z.string().default(''),
  item_type: z.string().default('material'),
  source_object_index: z.number().int().min(0).nullable().optional(),
});
export type ItemCandidate = z.infer<typeof ItemCandidateSchema>;

/**
 * Scanner API 응답.
 * RU-006-S1: original_image_key, original_image_url 추가
 */
export const ScannerResponseSchema = z.object({
  success: z.boolean(),
  status: ScanStatusSchema,
  caption: z.string().default(''),
  objects: z.array(DetectedObjectSchema).default([]),
  item_candidates: z.array(ItemCandidateSchema).default([]),
  message: z.string().nullable().optional(),
  analysis_time_ms: z.number().int().min(0).default(0),
  language: z.enum(['ko-KR', 'en-US']),
  original_image_key: z.string().nullable().optional(),
  original_image_url: z.string().nullable().optional(),
});
export type ScannerResponse = z.infer<typeof ScannerResponseSchema>;

// =============================================================================
// API 클라이언트 함수
// =============================================================================

/**
 * 스캔 결과 타입.
 */
export type ScanResult =
  | { success: true; data: ScannerResponse }
  | { success: false; error: string; status: ScanStatus };

/**
 * 스캔 옵션.
 * RU-006-S1: preserve_original 옵션 추가
 */
export interface ScanOptions {
  /** 원본 이미지 저장 여부 (디버깅/재분석용) */
  preserveOriginal?: boolean;
  /** 세션 ID (이미지 그룹화용) */
  sessionId?: string;
}

/**
 * 이미지를 스캔하여 오브젝트와 아이템 후보를 추출합니다.
 *
 * @param file - 분석할 이미지 파일
 * @param language - 응답 언어
 * @param options - 스캔 옵션 (RU-006-S1)
 * @returns 스캔 결과
 */
export async function scanImage(
  file: File,
  language: Language,
  options?: ScanOptions,
): Promise<ScanResult> {
  // 클라이언트 측 파일 검증
  const validationError = validateFile(file);
  if (validationError) {
    return {
      success: false,
      error: validationError,
      status: 'failed',
    };
  }

  // FormData 생성
  const formData = new FormData();
  formData.append('file', file);
  formData.append('language', language);

  // RU-006-S1: 선택적 파라미터 추가
  if (options?.preserveOriginal) {
    formData.append('preserve_original', 'true');
  }
  if (options?.sessionId) {
    formData.append('session_id', options.sessionId);
  }

  try {
    const response = await fetch(SCANNER_API_BASE, {
      method: 'POST',
      body: formData,
    });

    if (!response.ok) {
      console.error('[ScannerAPI] HTTP error', {
        status: response.status,
        statusText: response.statusText,
      });
      return {
        success: false,
        error:
          language === 'ko-KR'
            ? `서버 오류: ${response.status}`
            : `Server error: ${response.status}`,
        status: 'failed',
      };
    }

    const json = await response.json();
    const parseResult = ScannerResponseSchema.safeParse(json);

    if (!parseResult.success) {
      console.error('[ScannerAPI] Response validation failed', parseResult.error);
      return {
        success: false,
        error:
          language === 'ko-KR'
            ? '응답 데이터 형식이 올바르지 않습니다.'
            : 'Invalid response data format.',
        status: 'failed',
      };
    }

    const data = parseResult.data;

    // 성공/부분 성공 여부 확인
    if (data.status === 'completed' || data.status === 'partial') {
      return { success: true, data };
    }

    // 실패/차단 응답
    return {
      success: false,
      error: data.message ?? (language === 'ko-KR' ? '분석 실패' : 'Analysis failed'),
      status: data.status,
    };
  } catch (error) {
    console.error('[ScannerAPI] Network error', { errorType: (error as Error).name });
    return {
      success: false,
      error:
        language === 'ko-KR'
          ? '네트워크 오류가 발생했습니다. 다시 시도해 주세요.'
          : 'Network error occurred. Please try again.',
      status: 'failed',
    };
  }
}

// =============================================================================
// 유틸리티 함수
// =============================================================================

/**
 * 파일 유효성 검사.
 *
 * @param file - 검증할 파일
 * @returns 오류 메시지 (없으면 null)
 */
export function validateFile(file: File): string | null {
  // MIME 타입 검증
  if (!ALLOWED_MIME_TYPES.includes(file.type as (typeof ALLOWED_MIME_TYPES)[number])) {
    return `지원하지 않는 파일 형식입니다: ${file.type || '알 수 없음'}`;
  }

  // 파일 크기 검증
  if (file.size > MAX_FILE_SIZE_BYTES) {
    const sizeMB = (file.size / (1024 * 1024)).toFixed(1);
    return `파일이 너무 큽니다: ${sizeMB}MB (최대 20MB)`;
  }

  return null;
}

/**
 * 지원 파일 형식인지 확인.
 *
 * @param file - 확인할 파일
 * @returns 지원 여부
 */
export function isSupportedImageFile(file: File): boolean {
  return ALLOWED_MIME_TYPES.includes(file.type as (typeof ALLOWED_MIME_TYPES)[number]);
}

/**
 * ItemCandidate를 InventoryItem으로 변환합니다.
 *
 * U-075: iconStatus를 'pending'으로 설정하여 아이콘 생성 트리거
 * - icon 필드에는 임시 이모지를 설정 (생성 전 표시용)
 * - InventoryPanel에서 iconStatus가 'pending'이면 아이콘 생성 요청
 *
 * @param candidate - 아이템 후보
 * @returns InventoryItem 형태의 객체
 */
export function candidateToInventoryItem(candidate: ItemCandidate) {
  return {
    id: candidate.id,
    name: candidate.label,
    description: candidate.description,
    icon: getItemTypeEmoji(candidate.item_type),
    quantity: 1,
    iconStatus: 'pending' as const, // U-075: 아이콘 생성 트리거
  };
}

/**
 * 아이템 유형에 따른 이모지 반환.
 *
 * @param itemType - 아이템 유형
 * @returns 이모지
 */
function getItemTypeEmoji(itemType: string): string {
  const emojiMap: Record<string, string> = {
    key: '🔑',
    weapon: '⚔️',
    tool: '🔧',
    clue: '🔍',
    material: '📦',
    consumable: '💊',
    document: '📄',
    artifact: '💎',
  };
  return emojiMap[itemType] ?? '📦';
}
</file>

<file path="frontend/src/components/Hotspot.tsx">
/**
 * Unknown World - Hotspot 컴포넌트
 *
 * U-058[Mvp]: 핫스팟 디자인 개선 (코너/스트로크/색상)
 * - Q1 Option C: Magenta/Purple 계열 강조
 * - Q2 Option A: L자 브라켓 코너 마커
 *
 * U-074[Mvp]: 핫스팟 인터랙션 안내 UX
 * - Q1 Option B: 첫 N번만 hover 힌트 표시 (학습 후 사라짐)
 * - hover 시 "클릭하여 조사" 힌트 표시
 *
 * RULE-002 준수: 채팅 버블이 아닌 게임 UI
 * RULE-009 준수: 좌표 규약 (0~1000 정규화, bbox=[ymin,xmin,ymax,xmax])
 *
 * U-010[Mvp]: 핫스팟 오버레이 기본 구현
 * U-012[Mvp]: DnD 드롭 타겟 확장
 *
 * @module components/Hotspot
 */

import { useState, useCallback, memo, useEffect } from 'react';
import { useTranslation } from 'react-i18next';
import { useDroppable } from '@dnd-kit/core';
import type { SceneObject, Box2D } from '../schemas/turn';
import { box2dToPixel, type CanvasSize } from '../utils/box2d';
import { DND_TYPE, type HotspotDropData } from '../dnd/types';
import { useOnboardingStore, selectShouldShowHotspotHint } from '../stores/onboardingStore';
import { InteractionHint } from './InteractionHint';
import '../styles/hotspot.css';

// =============================================================================
// 타입 정의
// =============================================================================

/**
 * 핫스팟 클릭 이벤트 데이터
 */
export interface HotspotClickData {
  /** 클릭한 오브젝트 ID */
  object_id: string;
  /** 클릭한 오브젝트의 바운딩 박스 (0~1000 정규화) */
  box_2d: Box2D;
}

interface HotspotProps {
  /** 씬 오브젝트 데이터 */
  object: SceneObject;
  /** 캔버스 크기 (좌표 변환용) */
  canvasSize: CanvasSize;
  /** 클릭 핸들러 */
  onClick: (data: HotspotClickData) => void;
  /** 비활성화 여부 (스트리밍 중 등) */
  disabled: boolean;
  /** 데모 상태 여부 (시각적 힌트 필요) */
  isDemoState?: boolean;
  /** 우선순위 기반 z-index 스타일 */
  style?: React.CSSProperties;
}

// =============================================================================
// 메인 컴포넌트
// =============================================================================

/**
 * 핫스팟 컴포넌트
 *
 * Scene Canvas 위에 오버레이되는 클릭/드롭 가능한 영역입니다.
 * L자 코너 마커 + Magenta 테마로 시각적 품질을 향상시킵니다.
 *
 * @example
 * ```tsx
 * <Hotspot
 *   object={sceneObject}
 *   canvasSize={{ width: 800, height: 600 }}
 *   onClick={handleClick}
 *   disabled={isStreaming}
 * />
 * ```
 */
function HotspotComponent({
  object,
  canvasSize,
  onClick,
  disabled,
  isDemoState = false,
  style,
}: HotspotProps) {
  const [isHovered, setIsHovered] = useState(false);
  const { t } = useTranslation();

  // U-074: 핫스팟 힌트 상태 (첫 N번만 표시)
  const shouldShowHint = useOnboardingStore(selectShouldShowHotspotHint);
  const incrementHotspotHint = useOnboardingStore((state) => state.incrementHotspotHint);

  // U-074: hover 시작 시 힌트 카운트 증가
  useEffect(() => {
    if (isHovered && !disabled) {
      incrementHotspotHint();
    }
  }, [isHovered, disabled, incrementHotspotHint]);

  // U-012: useDroppable 훅으로 드롭 타겟 설정
  const dropData: HotspotDropData = {
    type: DND_TYPE.HOTSPOT,
    object_id: object.id,
    box_2d: object.box_2d,
    label: object.label,
  };

  const { isOver, setNodeRef } = useDroppable({
    id: `hotspot-${object.id}`,
    data: dropData,
    disabled,
  });

  // box_2d(0~1000) → px 변환 (RULE-009)
  const pixelBox = box2dToPixel(object.box_2d, canvasSize);

  // 클릭 핸들러
  const handleClick = useCallback(() => {
    if (disabled) return;
    onClick({
      object_id: object.id,
      box_2d: object.box_2d,
    });
  }, [disabled, onClick, object.id, object.box_2d]);

  // 키보드 접근성
  const handleKeyDown = useCallback(
    (e: React.KeyboardEvent) => {
      if (disabled) return;
      if (e.key === 'Enter' || e.key === ' ') {
        e.preventDefault();
        handleClick();
      }
    },
    [disabled, handleClick],
  );

  // 상태 결정
  const isHighlighted = isHovered || isOver;

  // 툴팁 방향 결정: 상단 여백이 부족하면 아래쪽으로 표시
  // 툴팁 높이(~80px) + 여유분을 기준으로 판단
  const TOOLTIP_FLIP_THRESHOLD = 80;
  const tooltipBelow = pixelBox.top < TOOLTIP_FLIP_THRESHOLD;

  // CSS 클래스 조합
  const classNames = [
    'hotspot',
    isHighlighted && !disabled ? 'hovered' : '',
    disabled ? 'disabled' : '',
    isOver ? 'drop-target-active' : '',
    isDemoState ? 'demo-target' : '',
    tooltipBelow ? 'tooltip-below' : '',
  ]
    .filter(Boolean)
    .join(' ');

  return (
    <div
      ref={setNodeRef}
      className={classNames}
      style={{
        top: `${pixelBox.top}px`,
        left: `${pixelBox.left}px`,
        width: `${pixelBox.width}px`,
        height: `${pixelBox.height}px`,
        ...style,
      }}
      onClick={handleClick}
      onMouseEnter={() => setIsHovered(true)}
      onMouseLeave={() => setIsHovered(false)}
      onKeyDown={handleKeyDown}
      role="button"
      tabIndex={disabled ? -1 : 0}
      aria-label={object.label}
      aria-disabled={disabled}
      data-drop-target={!disabled}
      data-demo-state={isDemoState}
      data-object-id={object.id}
    >
      {/* L자 코너 마커 (하단 2개) */}
      <div className="hotspot-corners" aria-hidden="true" />

      {/* 호버 또는 드래그 오버 시 툴팁 표시 */}
      {isHighlighted && !disabled && (
        <div className="hotspot-tooltip">
          <span className="hotspot-tooltip-label">{object.label}</span>

          {/* 데모 상태 표시 */}
          {isDemoState && (
            <span className="hotspot-tooltip-demo">{t('scene.hotspot.demo_hint')}</span>
          )}

          {/* 드래그 오버 시 드롭 힌트 표시 */}
          {isOver && (
            <span className="hotspot-tooltip-drop-hint">{t('scene.hotspot.drop_hint')}</span>
          )}

          {/* 일반 상호작용 힌트 */}
          {!isOver && !isDemoState && object.interaction_hint && (
            <span className="hotspot-tooltip-hint">
              {t('scene.hotspot.hint_prefix')}: {object.interaction_hint}
            </span>
          )}
        </div>
      )}

      {/* U-074: 첫 N번만 표시되는 클릭 힌트 (툴팁 외부) */}
      {isHovered && !disabled && !isOver && shouldShowHint && (
        <InteractionHint
          text={t('interaction.hotspot_click')}
          icon="click"
          position="bottom"
          className="interaction-hint--hotspot"
        />
      )}
    </div>
  );
}

/**
 * Memoized Hotspot 컴포넌트
 *
 * 다수의 핫스팟이 동시에 렌더될 때 성능 최적화를 위해 메모이제이션 적용.
 * object.id, canvasSize, disabled가 변경되지 않으면 리렌더 방지.
 */
export const Hotspot = memo(HotspotComponent, (prevProps, nextProps) => {
  // 핵심 props만 비교하여 불필요한 리렌더 방지
  return (
    prevProps.object.id === nextProps.object.id &&
    prevProps.object.label === nextProps.object.label &&
    prevProps.object.box_2d.ymin === nextProps.object.box_2d.ymin &&
    prevProps.object.box_2d.xmin === nextProps.object.box_2d.xmin &&
    prevProps.object.box_2d.ymax === nextProps.object.box_2d.ymax &&
    prevProps.object.box_2d.xmax === nextProps.object.box_2d.xmax &&
    prevProps.canvasSize.width === nextProps.canvasSize.width &&
    prevProps.canvasSize.height === nextProps.canvasSize.height &&
    prevProps.disabled === nextProps.disabled &&
    prevProps.isDemoState === nextProps.isDemoState
  );
});

Hotspot.displayName = 'Hotspot';

// Re-export for convenience
export type { HotspotProps };
</file>

<file path="frontend/src/components/SceneImage.tsx">
/**
 * Unknown World - Scene Image 컴포넌트 (U-020: Lazy Render)
 *
 * RULE-004 준수: 실패 시에도 안전한 폴백 제공
 * RULE-008 준수: 텍스트 우선 + Lazy 이미지 정책
 *
 * @module components/SceneImage
 */

import { useState, useEffect, useMemo } from 'react';
import { useTranslation } from 'react-i18next';
import type {
  SceneCanvasStatus,
  PlaceholderInfo,
  ImageLoadingState,
  SceneProcessingPhase,
} from '../types/scene';

// =============================================================================
// 상수 정의
// =============================================================================

export const SCENE_PLACEHOLDERS: Record<Exclude<SceneCanvasStatus, 'scene'>, PlaceholderInfo> = {
  default: {
    imagePath: '/ui/placeholders/scene-placeholder-default.png',
    fallbackEmoji: '📡',
    labelKey: 'scene.status.default',
  },
  loading: {
    imagePath: '/ui/placeholders/scene-loading.webp',
    fallbackEmoji: '⏳',
    labelKey: 'scene.status.loading',
  },
  offline: {
    imagePath: '/ui/placeholders/scene-offline.webp',
    fallbackEmoji: '🔌',
    labelKey: 'scene.status.offline',
  },
  blocked: {
    imagePath: '/ui/placeholders/scene-blocked.webp',
    fallbackEmoji: '🚫',
    labelKey: 'scene.status.blocked',
  },
  low_signal: {
    imagePath: '/ui/placeholders/scene-low-signal.webp',
    fallbackEmoji: '📉',
    labelKey: 'scene.status.low_signal',
  },
};

// =============================================================================
// 타입 정의
// =============================================================================

interface SceneImageProps {
  status: SceneCanvasStatus;
  imageUrl?: string;
  message?: string;
  className?: string;
  /** U-066: 이미지 생성 중 여부 (외부 상태) */
  isGenerating?: boolean;
  /** U-071: 현재 처리 단계 (로딩 인디케이터 강화) */
  processingPhase?: SceneProcessingPhase;
  /** U-089: 정밀분석(Agentic Vision) 실행 중 여부 */
  isAnalyzing?: boolean;
}

// =============================================================================
// 컴포넌트 구현
// =============================================================================

/**
 * 장면 이미지 렌더링 컴포넌트
 *
 * - Lazy loading: 새 이미지를 프리로드하고 완료 시 교체합니다.
 * - Option A: 새 이미지 로딩 중에도 이전 이미지를 유지합니다.
 * - 폴백: 로드 실패 시 에러 배지를 표시하고 이전 이미지를 유지합니다.
 * - U-066: isGenerating 상태에서 "새 장면 생성 중" 인디케이터를 표시합니다.
 */
export function SceneImage({
  status,
  imageUrl,
  message,
  className = '',
  isGenerating = false,
  processingPhase = 'idle',
  isAnalyzing = false,
}: SceneImageProps) {
  const { t } = useTranslation();

  // U-071: 처리 중 여부 (processing 또는 image_pending)
  // U-089: 정밀분석 시에는 별도 오버레이를 사용하므로 isProcessing에서 제외
  const isProcessing =
    !isAnalyzing && (processingPhase === 'processing' || processingPhase === 'image_pending');

  // 내부 상태 관리
  const [imageError, setImageError] = useState(false);
  const [displayImageUrl, setDisplayImageUrl] = useState<string | null>(null);

  // 파생 상태: 로딩 중 여부
  // - 목표 URL(imageUrl)이 존재하고, 현재 표시 중인 이미지와 다르며, 에러가 아닌 경우
  const isImageLoading = useMemo(() => {
    return !!imageUrl && imageUrl !== displayImageUrl && !imageError;
  }, [imageUrl, displayImageUrl, imageError]);

  // 이미지 URL 변경 시 로딩 프로세스 시작
  useEffect(() => {
    // 1. URL이 없거나 이미 표시 중인 경우 초기화 및 종료
    if (!imageUrl || imageUrl === displayImageUrl) {
      // eslint-disable-next-line react-hooks/set-state-in-effect
      setImageError(false);
      return;
    }

    // 2. 새 이미지 프리로드 시작

    setImageError(false);

    let isMounted = true;
    const img = new Image();
    const currentUrl = imageUrl;

    const handleLoad = () => {
      if (!isMounted) return;
      setDisplayImageUrl(currentUrl);
      setImageError(false);
    };

    const handleError = () => {
      if (!isMounted) return;
      setImageError(true);
    };

    img.addEventListener('load', handleLoad);
    img.addEventListener('error', handleError);
    img.src = imageUrl;

    return () => {
      isMounted = false;
      img.removeEventListener('load', handleLoad);
      img.removeEventListener('error', handleError);
    };
  }, [imageUrl, displayImageUrl]);

  // 이미지 로딩 상태 타입 파생 (CSS 클래스용)
  const imageLoadingState: ImageLoadingState = useMemo(() => {
    if (isImageLoading) return 'loading';
    if (imageError) return 'error';
    if (displayImageUrl) return 'loaded';
    return 'idle';
  }, [isImageLoading, imageError, displayImageUrl]);

  const hasDisplayImage = !!displayImageUrl;
  // U-071: 처리 중일 때는 scene-active 해제 (placeholder 표시를 위해)
  // U-089: 정밀분석 중에는 scene-active 유지 (기존 이미지 표시)
  const isSceneActive =
    status === 'scene' && hasDisplayImage && !imageError && !isProcessing && !isAnalyzing;

  // placeholder 정보 결정
  // U-071 Option C: 처리 중일 때도 placeholder 상태로 전환
  // U-089: 정밀분석 시에는 placeholder 미표시 (기존 이미지 유지)
  const effectiveStatus = isProcessing
    ? 'loading'
    : status === 'scene' && !hasDisplayImage
      ? 'default'
      : status;

  // U-071 Option C: 처리 중일 때 placeholder + 오버레이 표시
  // U-089: 정밀분석 시에는 기존 이미지를 유지하므로 placeholder 미표시
  const isPlaceholderVisible = (!hasDisplayImage || isProcessing) && !isAnalyzing;

  const placeholder = isPlaceholderVisible
    ? SCENE_PLACEHOLDERS[effectiveStatus as Exclude<SceneCanvasStatus, 'scene'>]
    : null;

  // U-071: 처리 단계별 메시지 키 매핑
  const processingMessageKey =
    processingPhase === 'image_pending'
      ? 'scene.processing.image_pending'
      : processingPhase === 'rendering'
        ? 'scene.processing.rendering'
        : 'scene.processing.processing';

  return (
    <div
      className={`scene-image-container ${isSceneActive || isAnalyzing ? 'scene-active' : `scene-status-${effectiveStatus}`} ${isImageLoading ? 'image-loading' : ''} ${isProcessing ? 'scene-processing' : ''} ${isAnalyzing ? 'scene-analyzing' : ''} ${className}`}
      style={placeholder ? { backgroundImage: `url('${placeholder.imagePath}')` } : {}}
    >
      {/* 장면 이미지
        - U-071 Option C: 처리 중일 때 숨김
        - U-089: 정밀분석 중에는 기존 이미지 유지 (opacity/tint는 CSS에서 처리)
      */}
      {hasDisplayImage && (!isProcessing || isAnalyzing) && (
        <img
          src={displayImageUrl}
          alt={t('scene.status.alt')}
          className={`scene-image ${imageLoadingState === 'loaded' ? 'scene-image-loaded' : ''}`}
        />
      )}

      {/* U-089: 정밀분석 전용 오버레이 (스캔라인 스윕 + 시안 글로우 라벨) */}
      {isAnalyzing && (
        <div className="scene-analyzing-overlay" aria-live="polite" role="status">
          {/* 스캔라인 스윕 효과 (위→아래 반복) */}
          <div className="scene-analyzing-scanline" aria-hidden="true" />
          {/* 시안 글로우 라벨 */}
          <span className="scene-analyzing-text">{t('scene.analyzing.message')}</span>
          {/* 서브 텍스트 (단계 힌트) */}
          <span className="scene-analyzing-subtext">{t('scene.analyzing.hint')}</span>
        </div>
      )}

      {/* U-071: 처리 중 오버레이 (CRT 테마) - 정밀분석이 아닐 때만 */}
      {isProcessing && !isAnalyzing && (
        <div className="scene-processing-overlay" aria-live="polite" role="status">
          <div className="scene-processing-spinner" aria-hidden="true">
            <div className="spinner-ring spinner-ring-outer" />
            <div className="spinner-ring spinner-ring-inner" />
            <div className="spinner-glow" />
          </div>
          <span className="scene-processing-text">{t(processingMessageKey)}</span>
          {/* CRT 스캔라인 효과 */}
          <div className="scene-processing-scanlines" aria-hidden="true" />
        </div>
      )}

      {/* 로딩 인디케이터 (이미지 URL 로딩) - 처리 중/분석 중이 아닐 때만 */}
      {isImageLoading && !isGenerating && !isProcessing && !isAnalyzing && (
        <div className="scene-loading-indicator" aria-live="polite">
          <div className="scene-loading-spinner" aria-hidden="true" />
          <span className="scene-loading-text">{t('scene.status.image_loading')}</span>
        </div>
      )}

      {/* U-066: 이미지 생성 중 인디케이터 - 처리 중/분석 중이 아닐 때만 */}
      {isGenerating && !isProcessing && !isAnalyzing && (
        <div className="scene-generating-indicator" aria-live="polite">
          <div className="scene-generating-spinner" aria-hidden="true" />
          <span className="scene-generating-text">{t('scene.status.image_generating')}</span>
        </div>
      )}

      {/* 이미지 에러 배지 - 처리 중/분석 중이 아닐 때만 */}
      {imageError && !isProcessing && !isAnalyzing && (
        <div className="scene-error-badge" role="alert">
          <span className="scene-error-icon" aria-hidden="true">
            ⚠️
          </span>
          <span className="scene-error-text">{t('scene.status.image_error')}</span>
        </div>
      )}

      {/* Placeholder 영역 - 처리 중일 때는 오버레이만 표시, 분석 중일 때는 미표시 */}
      {isPlaceholderVisible && placeholder && !isProcessing && (
        <div className="scene-placeholder">
          <p className="text-glow scene-status-label">
            <span className="scene-status-emoji" aria-hidden="true">
              {placeholder.fallbackEmoji}
            </span>{' '}
            {t(placeholder.labelKey)}
          </p>
          {message && <p className="scene-status-message">{message}</p>}
        </div>
      )}
    </div>
  );
}
</file>

<file path="frontend/src/stores/agentStore.ts">
/**
 * Unknown World - Agent Console 상태 관리 (Zustand).
 *
 * 스트리밍 중 수신되는 단계/배지/내러티브/복구 정보를 저장하고,
 * AgentConsole 컴포넌트에서 구독할 수 있도록 합니다.
 *
 * 설계 원칙:
 *   - RULE-008: 단계/배지 가시화 (프롬프트/내부 추론 노출 금지)
 *   - RULE-003/004: 검증 후 상태 반영, 실패 시 폴백
 *
 * @module stores/agentStore
 */

import { create } from 'zustand';
import type { AgentPhase, ValidationBadge, TurnOutput } from '../schemas/turn';
import type {
  StageEvent,
  BadgesEvent,
  NarrativeDeltaEvent,
  FinalEvent,
  ErrorEvent,
} from '../types/turn_stream';
import { StageStatus } from '../types/turn_stream';

// =============================================================================
// 상태 타입 정의
// =============================================================================

/** 단계 상태 */
export type PhaseStatus = 'pending' | 'in_progress' | 'completed' | 'failed';

/** 단계 정보 */
export interface PhaseInfo {
  name: AgentPhase;
  status: PhaseStatus;
}

/** 에러 정보 */
export interface AgentError {
  message: string;
  code?: string;
}

/** Agent Console 상태 */
export interface AgentState {
  /** 현재 스트리밍 중인지 */
  isStreaming: boolean;
  /** 현재 단계 */
  currentPhase: AgentPhase | null;
  /** 단계별 상태 */
  phases: PhaseInfo[];
  /** 검증 배지 목록 */
  badges: ValidationBadge[];
  /** 누적 내러티브 텍스트 (타자 효과용) */
  narrativeBuffer: string;
  /** 자동 복구 횟수 */
  repairCount: number;
  /** 최종 TurnOutput */
  finalOutput: TurnOutput | null;
  /** 에러 정보 */
  error: AgentError | null;
  /** U-130: API rate limit(429)으로 모든 재시도 소진 여부 */
  isRateLimited: boolean;
}

/** Agent Console 액션 */
export interface AgentActions {
  /** 스트림 시작 */
  startStream: () => void;
  /** 단계 이벤트 처리 */
  handleStage: (event: StageEvent) => void;
  /** 배지 이벤트 처리 */
  handleBadges: (event: BadgesEvent) => void;
  /** 내러티브 델타 이벤트 처리 */
  handleNarrativeDelta: (event: NarrativeDeltaEvent) => void;
  /** 최종 출력 이벤트 처리 */
  handleFinal: (event: FinalEvent) => void;
  /** 에러 이벤트 처리 */
  handleError: (event: ErrorEvent) => void;
  /** 스트림 완료 */
  completeStream: () => void;
  /** 상태 초기화 */
  reset: () => void;
}

export type AgentStore = AgentState & AgentActions;

// =============================================================================
// 초기 상태
// =============================================================================

/** 기본 단계 목록 (PRD 예시) */
const DEFAULT_PHASES: AgentPhase[] = [
  'parse',
  'validate',
  'plan',
  'resolve',
  'render',
  'verify',
  'commit',
];

/** 초기 상태 생성 */
function createInitialState(): AgentState {
  return {
    isStreaming: false,
    currentPhase: null,
    phases: DEFAULT_PHASES.map((name) => ({
      name,
      status: 'pending' as const,
    })),
    badges: [],
    narrativeBuffer: '',
    repairCount: 0,
    finalOutput: null,
    error: null,
    isRateLimited: false,
  };
}

// =============================================================================
// Zustand Store
// =============================================================================

/**
 * Agent Console 상태 스토어.
 *
 * @example
 * ```tsx
 * // 컴포넌트에서 사용
 * const { isStreaming, phases, badges } = useAgentStore();
 * const startStream = useAgentStore((state) => state.startStream);
 * ```
 */
export const useAgentStore = create<AgentStore>((set) => ({
  // 초기 상태
  ...createInitialState(),

  // 액션
  startStream: () => {
    set({
      ...createInitialState(),
      isStreaming: true,
    });
  },

  handleStage: (event) => {
    set((state) => {
      const phaseName = event.name;
      const eventStatus = event.status;

      // RU-002-S2: status 값에 따른 단계 상태 결정
      // 'start' → in_progress
      // 'complete' 또는 'ok' (정규화됨) → completed
      // 'fail' → failed
      let newStatus: PhaseStatus;
      if (eventStatus === StageStatus.START) {
        newStatus = 'in_progress';
      } else if (eventStatus === 'fail') {
        newStatus = 'failed';
      } else {
        // 'complete' (정규화된 'ok' 포함)
        newStatus = 'completed';
      }

      // 단계 상태 업데이트
      const phases = state.phases.map((phase) => {
        if (phase.name === phaseName) {
          return {
            ...phase,
            status: newStatus,
          };
        }
        return phase;
      });

      return {
        phases,
        currentPhase: eventStatus === StageStatus.START ? phaseName : state.currentPhase,
      };
    });
  },

  handleBadges: (event) => {
    set({
      badges: event.badges,
    });
  },

  handleNarrativeDelta: (event) => {
    set((state) => ({
      narrativeBuffer: state.narrativeBuffer + event.text,
    }));
  },

  handleFinal: (event) => {
    set({
      finalOutput: event.data,
      repairCount: event.data.agent_console?.repair_count ?? 0,
      // U-087: 텍스트가 entries에 확정되었으므로 스트리밍 버퍼 즉시 비움.
      // completeStream()이 이미지 생성 완료까지 지연되어도 텍스트 중복 표시 방지.
      narrativeBuffer: '',
    });
  },

  handleError: (event) => {
    set({
      error: {
        message: event.message,
        code: event.code,
      },
      // U-130: RATE_LIMITED 코드이면 전용 플래그 설정
      isRateLimited: event.code === 'RATE_LIMITED',
    });
  },

  completeStream: () => {
    set({
      isStreaming: false,
      narrativeBuffer: '', // 스트림 완료 시 버퍼 초기화
    });
  },

  reset: () => {
    set(createInitialState());
  },
}));

// =============================================================================
// 셀렉터 (성능 최적화용)
// =============================================================================

/** 스트리밍 상태 셀렉터 */
export const selectIsStreaming = (state: AgentStore) => state.isStreaming;

/** 현재 단계 셀렉터 */
export const selectCurrentPhase = (state: AgentStore) => state.currentPhase;

/** 단계 목록 셀렉터 */
export const selectPhases = (state: AgentStore) => state.phases;

/** 배지 목록 셀렉터 */
export const selectBadges = (state: AgentStore) => state.badges;

/** 내러티브 버퍼 셀렉터 */
export const selectNarrativeBuffer = (state: AgentStore) => state.narrativeBuffer;

/** 복구 횟수 셀렉터 */
export const selectRepairCount = (state: AgentStore) => state.repairCount;

/** 최종 출력 셀렉터 */
export const selectFinalOutput = (state: AgentStore) => state.finalOutput;

/** 에러 셀렉터 */
export const selectError = (state: AgentStore) => state.error;

/** U-130: rate limit 상태 셀렉터 */
export const selectIsRateLimited = (state: AgentStore) => state.isRateLimited;

/** 모델 라벨 셀렉터 (U-069: FAST/QUALITY 표시) */
export const selectModelLabel = (state: AgentStore) =>
  state.finalOutput?.agent_console?.model_label ?? 'FAST';
</file>

<file path="package.json">
{
  "name": "unknown-world",
  "version": "0.1.0",
  "private": true,
  "description": "Unknown World - Gemini 기반 에이전트형 게임 엔진",
  "packageManager": "pnpm@10.27.0",
  "engines": {
    "node": "24.12.0"
  },
  "scripts": {
    "kill": "pnpm kill:port && sleep 1 && pnpm kill:zombies",
    "kill:port": "npx --yes kill-port 8001 8002 8003 8004 8005 8006 8007 8008 8009 8010 8011 8012 8013 8014 8015 8016 8017 8018 8019 8020",
    "kill:zombies": "bash scripts/kill-zombies.sh",
    "kill:nuke": "bash scripts/kill-nuke.sh",
    "kill:front": "npx --yes kill-port 8001 8002 8003 8004 8005 8006 8007 8008 8009 8010",
    "kill:back": "npx --yes kill-port 8011 8012 8013 8014 8015 8016 8017 8018 8019 8020",
    "dev:back": "cd backend && uv run uvicorn unknown_world.main:app --reload --port 8011",
    "dev:front": "pnpm -C frontend dev"
  }
}
</file>

<file path="backend/src/unknown_world/api/scanner.py">
"""Unknown World - Scanner(이미지 이해) API 엔드포인트.

이 모듈은 사용자가 업로드한 이미지를 분석하여 "단서/아이템 후보"로
변환하는 API 엔드포인트를 제공합니다.

설계 원칙:
    - RULE-004: 실패 시 안전한 폴백 (텍스트-only 캡션)
    - RULE-007: 프롬프트 원문/업로드 파일 내용 로깅 금지
    - RULE-009: bbox는 0~1000 정규화 + [ymin, xmin, ymax, xmax]

페어링 질문 결정:
    - Q1: Option A (multipart 업로드로 처리)

참조:
    - vibe/unit-plans/U-021[Mvp].md
    - vibe/prd.md 6.7 (Scanner 슬롯)
    - .cursor/rules/00-core-critical.mdc
"""

from __future__ import annotations

import logging
from typing import Annotated

from fastapi import APIRouter, Depends, File, Form, UploadFile
from pydantic import BaseModel, ConfigDict, Field

from unknown_world.models.scanner import (
    DetectedObject,
    ItemCandidate,
    ScanResult,
    ScanStatus,
)
from unknown_world.models.turn import Language
from unknown_world.services.image_understanding import (
    ImageUnderstandingService,
    get_image_understanding_service,
)
from unknown_world.storage.validation import (
    ALLOWED_IMAGE_MIME_TYPES,
    MAX_IMAGE_FILE_SIZE_BYTES,
    validate_image_upload,
)

# =============================================================================
# 로거 설정
# =============================================================================

logger = logging.getLogger(__name__)

# =============================================================================
# 라우터 정의
# =============================================================================

router = APIRouter(
    prefix="/api/scan",
    tags=["Scanner"],
)


# =============================================================================
# 의존성 주입
# =============================================================================


async def get_scanner_service() -> ImageUnderstandingService:
    """Scanner 서비스 의존성."""
    return get_image_understanding_service()


# =============================================================================
# 응답 스키마 (API 계층용)
# =============================================================================


class ScannerResponse(BaseModel):
    """Scanner API 응답.

    Attributes:
        success: 성공 여부
        status: 스캔 상태
        caption: 이미지 캡션
        objects: 감지된 오브젝트 목록
        item_candidates: 아이템 후보 목록
        message: 상태/에러 메시지
        analysis_time_ms: 분석 소요 시간 (ms)
        language: 응답 언어
        original_image_key: 저장된 원본 이미지 스토리지 키 (RU-006-S1)
        original_image_url: 저장된 원본 이미지 URL (RU-006-S1)
    """

    model_config = ConfigDict(extra="forbid")

    success: bool = Field(description="성공 여부")
    status: ScanStatus = Field(description="스캔 상태")
    caption: str = Field(default="", description="이미지 캡션")
    objects: list[DetectedObject] = Field(
        default_factory=lambda: [],
        description="감지된 오브젝트 목록",
    )
    item_candidates: list[ItemCandidate] = Field(
        default_factory=lambda: [],
        description="아이템 후보 목록",
    )
    message: str | None = Field(default=None, description="상태/에러 메시지")
    analysis_time_ms: int = Field(default=0, description="분석 소요 시간 (ms)")
    language: Language = Field(description="응답 언어")
    original_image_key: str | None = Field(
        default=None,
        description="저장된 원본 이미지 스토리지 키",
    )
    original_image_url: str | None = Field(
        default=None,
        description="저장된 원본 이미지 URL",
    )


class ScannerHealthResponse(BaseModel):
    """Scanner 서비스 헬스체크 응답.

    Attributes:
        status: 서비스 상태
        mode: 동작 모드 (mock/real)
        model: 사용 중인 모델 라벨
        supported_formats: 지원하는 이미지 형식
        max_file_size_mb: 최대 파일 크기 (MB)
    """

    model_config = ConfigDict(extra="forbid")

    status: str = Field(description="서비스 상태")
    mode: str = Field(description="동작 모드")
    model: str = Field(description="사용 중인 모델")
    supported_formats: list[str] = Field(description="지원하는 이미지 형식")
    max_file_size_mb: int = Field(description="최대 파일 크기 (MB)")


# =============================================================================
# 엔드포인트 정의
# =============================================================================


@router.post(
    "",
    response_model=ScannerResponse,
    summary="이미지 스캔",
    description="이미지를 업로드하여 오브젝트와 아이템 후보를 추출합니다.",
)
async def scan_image(
    file: Annotated[UploadFile, File(description="분석할 이미지 파일")],
    language: Annotated[
        str,
        Form(description="응답 언어 (ko-KR 또는 en-US)"),
    ] = "en-US",
    preserve_original: Annotated[
        bool,
        Form(description="원본 이미지 저장 여부 (디버깅/재분석용, RU-006-S1)"),
    ] = False,
    session_id: Annotated[
        str | None,
        Form(description="세션 ID (이미지 그룹화용)"),
    ] = None,
    service: ImageUnderstandingService = Depends(get_scanner_service),
) -> ScannerResponse:
    """이미지를 스캔하여 오브젝트와 아이템 후보를 추출합니다.

    이 엔드포인트는 Scanner 슬롯 UI에서 이미지를 드롭/업로드할 때 호출됩니다.
    추출된 아이템 후보는 인벤토리에 추가하거나 세계에 배치할 수 있습니다.

    Args:
        file: 분석할 이미지 파일 (multipart/form-data)
        language: 응답 언어 (ko-KR 또는 en-US)
        preserve_original: 원본 이미지 저장 여부 (RU-006-S1)
        session_id: 세션 ID (이미지 그룹화용)
        service: Scanner 서비스 (의존성 주입)

    Returns:
        ScannerResponse: 스캔 결과

    Raises:
        HTTPException: 파일 형식이 잘못되었거나 크기 초과 시
    """
    # 언어 파싱
    try:
        lang = Language(language)
    except ValueError:
        lang = Language.KO

    # 파일 읽기
    try:
        content = await file.read()
    except Exception as e:
        logger.error(
            "[ScannerAPI] 파일 읽기 실패",
            extra={"error_type": type(e).__name__},
        )
        return ScannerResponse(
            success=False,
            status=ScanStatus.FAILED,
            message="파일을 읽을 수 없습니다",
            language=lang,
        )

    # 중앙화된 파일 검증 (RULE-004, RU-006-Q1)
    content_type = file.content_type or "application/octet-stream"
    validation_error = validate_image_upload(
        content=content,
        content_type=content_type,
        language=lang,
    )

    if validation_error:
        logger.warning(
            "[ScannerAPI] 파일 검증 실패",
            extra={"error": validation_error},
        )
        return ScannerResponse(
            success=False,
            status=ScanStatus.FAILED,
            message=validation_error,
            language=lang,
        )

    # 로그: 메타 정보만 기록 (RULE-007: 파일 내용 로깅 금지)
    logger.info(
        "[ScannerAPI] 스캔 요청",
        extra={
            "filename": file.filename,
            "content_type": content_type,
            "size_kb": len(content) // 1024,
            "language": lang.value,
        },
    )

    # 이미지 분석 수행
    try:
        result: ScanResult = await service.analyze(
            image_content=content,
            content_type=content_type,
            language=lang,
            preserve_original=preserve_original,
            session_id=session_id,
        )

        # 성공 여부 결정
        success = result.status in (ScanStatus.COMPLETED, ScanStatus.PARTIAL)

        return ScannerResponse(
            success=success,
            status=result.status,
            caption=result.caption,
            objects=result.objects,
            item_candidates=result.item_candidates,
            message=result.message,
            analysis_time_ms=result.analysis_time_ms,
            language=lang,
            original_image_key=result.original_image_key,
            original_image_url=result.original_image_url,
        )

    except Exception as e:
        error_type = type(e).__name__
        logger.error(
            "[ScannerAPI] 스캔 중 예외 발생",
            extra={"error_type": error_type},
        )

        # 안전한 폴백 응답 (RULE-004)
        return ScannerResponse(
            success=False,
            status=ScanStatus.FAILED,
            message=f"이미지 분석 중 오류가 발생했습니다: {error_type}",
            language=lang,
        )


@router.get(
    "/health",
    response_model=ScannerHealthResponse,
    summary="Scanner 서비스 헬스체크",
    description="Scanner 서비스의 상태를 확인합니다.",
)
async def scanner_health(
    service: ImageUnderstandingService = Depends(get_scanner_service),
) -> ScannerHealthResponse:
    """Scanner 서비스 헬스체크.

    Args:
        service: Scanner 서비스

    Returns:
        ScannerHealthResponse: 서비스 상태 정보
    """
    return ScannerHealthResponse(
        status="ok",
        mode="mock" if service.is_mock else "real",
        model="VISION (gemini-3-flash-preview)",
        supported_formats=list(ALLOWED_IMAGE_MIME_TYPES),
        max_file_size_mb=MAX_IMAGE_FILE_SIZE_BYTES // (1024 * 1024),
    )
</file>

<file path="backend/src/unknown_world/config/models.py">
"""Unknown World - 모델 라벨 및 ID 상수 정의.

이 모듈은 Gemini 모델 ID와 라벨을 SSOT로 관리합니다.
tech-stack.md 기준으로 버전/모델 ID가 고정되어 있으며,
임의 변경은 RULE-010 위반입니다.

모델 라인업 (tech-stack.md 기준):
    - 텍스트 FAST: gemini-3-flash-preview
    - 텍스트 QUALITY: gemini-3-pro-preview
    - 이미지(생성/편집): gemini-3-pro-image-preview (고정)

참조:
    - vibe/tech-stack.md (버전 기준일: 2026-01-01)
    - .cursor/rules/00-core-critical.mdc (RULE-007/010)
"""

from enum import StrEnum
from typing import Final


class ModelLabel(StrEnum):
    """모델 라벨 열거형.

    UI/로그에는 모델 ID 원문 대신 이 라벨을 우선 노출합니다. (RULE-008)
    """

    FAST = "FAST"
    """빠른 응답용 텍스트 모델 (gemini-3-flash-preview)"""

    QUALITY = "QUALITY"
    """고품질 텍스트 모델 (gemini-3-pro-preview)"""

    IMAGE = "IMAGE"
    """이미지 생성/편집 모델 (gemini-3-pro-image-preview, 고정)"""

    IMAGE_FAST = "IMAGE_FAST"
    """저지연 이미지 프리뷰 모델 (gemini-2.5-flash-image, U-066)"""

    VISION = "VISION"
    """비전/공간 분석 모델 (bbox/segmentation용, gemini-3-flash-preview)"""


# =============================================================================
# 모델 ID 상수 (tech-stack.md SSOT)
# =============================================================================
# 주의: 이 값들은 tech-stack.md와 1:1로 일치해야 합니다.
# 임의 변경 금지 (RULE-010)

MODEL_FAST: Final[str] = "gemini-3-flash-preview"
"""FAST 라벨 모델 ID - 빠른 텍스트 생성용"""

MODEL_QUALITY: Final[str] = "gemini-3-pro-preview"
"""QUALITY 라벨 모델 ID - 고품질 텍스트 생성용"""

MODEL_IMAGE: Final[str] = "gemini-3-pro-image-preview"
"""IMAGE 라벨 모델 ID - 이미지 생성/편집용 (고정, RULE-010)"""

MODEL_IMAGE_FAST: Final[str] = "gemini-2.5-flash-image"
"""IMAGE_FAST 라벨 모델 ID - 저지연 이미지 프리뷰용 (U-066)"""

MODEL_VISION: Final[str] = "gemini-3-flash-preview"
"""VISION 라벨 모델 ID - 비전/공간 분석용 (bbox/segmentation)"""

# =============================================================================
# U-127: 기본 텍스트 모델 / 폴백 모델 상수
# =============================================================================
# gemini-3-pro-preview를 기본 텍스트 모델로 사용.
# API 오류(429/5xx/timeout) 시 gemini-3-flash-preview로 자동 폴백.

MODEL_DEFAULT: Final[str] = MODEL_QUALITY
"""기본 텍스트 모델 ID (U-127: gemini-3-pro-preview)"""

MODEL_DEFAULT_LABEL: Final[ModelLabel] = ModelLabel.QUALITY
"""기본 텍스트 모델 라벨 (U-127: QUALITY = Pro)"""

MODEL_FALLBACK: Final[str] = MODEL_FAST
"""폴백 텍스트 모델 ID (U-127: gemini-3-flash-preview)"""

MODEL_FALLBACK_LABEL: Final[ModelLabel] = ModelLabel.FAST
"""폴백 텍스트 모델 라벨 (U-127: FAST = Flash)"""

# U-127: Gemini 3 Thinking Level 기본값 (페어링 Q2: Option A - high)
DEFAULT_THINKING_LEVEL: Final[str] = "high"
"""Gemini 3 thinking level 기본값 (U-127)"""


# =============================================================================
# 텍스트 모델 티어링 설정 (U-069)
# =============================================================================
# Q1 결정: Option B - 액션 ID + 키워드 매칭


class TextModelTiering:
    """텍스트 모델 티어링 설정.

    U-127 변경: 기본 모델이 gemini-3-pro-preview(QUALITY)로 전환됨.
    "정밀조사" 트리거 시 추가 비용 배수(2x)가 적용됨.

    페어링 질문 결정:
        - Q1: Option B - 액션 ID + 키워드 매칭
        - Q2: Option A - 2x (기본 비용의 2배)
        - Q3: Option B + C - 특정 상황 등장 + 아이템 활성화
    """

    # QUALITY 트리거 액션 ID 목록
    # "정밀조사" 및 관련 액션
    QUALITY_TRIGGER_ACTION_IDS: Final[frozenset[str]] = frozenset(
        {
            "deep_investigate",
            "정밀조사",
            "analyze",
            "examine_closely",
            "investigate_detail",
            "scrutinize",
            "thorough_search",
            # 돋보기 아이템 사용 액션 (Q3 결정: Option C)
            "use_magnifier",
            "use_magnifying_glass",
        }
    )

    # U-076: "정밀분석" 트리거 액션 ID 목록 (Agentic Vision)
    # QUALITY 트리거와 별도 관리 (다른 비용 정책: 1.5x)
    VISION_TRIGGER_ACTION_IDS: Final[frozenset[str]] = frozenset(
        {
            "deep_analyze",
            "정밀분석",
            "analyze_scene",
            "examine_scene",
            "look_closely",
        }
    )

    # U-076: 비전 분석 비용 배수 (Q2 결정: Option B - 1.5x)
    VISION_COST_MULTIPLIER: Final[float] = 1.5
    """비전 분석(정밀분석) 비용 배수"""

    # QUALITY 트리거 키워드 목록 (소문자)
    # Q1 결정: Option B - 키워드 매칭 포함
    QUALITY_TRIGGER_KEYWORDS: Final[tuple[str, ...]] = (
        "정밀조사",
        "자세히",
        "깊이",
        "꼼꼼히",
        "면밀히",
        "세밀하게",
        "thoroughly",
        "in detail",
        "closely examine",
        "scrutinize",
    )

    # U-076: 비전 분석(정밀분석) 트리거 키워드 (소문자)
    VISION_TRIGGER_KEYWORDS: Final[tuple[str, ...]] = (
        "정밀분석",
        "장면 분석",
        "이미지 분석",
        "자세히 보기",
        "analyze scene",
        "deep analyze",
        "look closely",
        "examine scene",
    )

    # 비용 배수 (Q2 결정: Option A - 2x)
    FAST_COST_MULTIPLIER: Final[float] = 1.0
    """FAST 모델 비용 배수 (기본)"""

    QUALITY_COST_MULTIPLIER: Final[float] = 2.0
    """QUALITY 모델 비용 배수 (Q2 결정: Option A - 2x)"""

    @classmethod
    def is_vision_trigger(
        cls,
        action_id: str | None,
        text: str | None,
    ) -> bool:
        """비전 분석(정밀분석) 트리거 여부를 판단합니다 (U-076).

        Args:
            action_id: 선택된 액션 ID (선택)
            text: 사용자 입력 텍스트 (선택)

        Returns:
            정밀분석(비전 분석)을 실행해야 하는지 여부
        """
        # 액션 ID 검사
        if action_id and action_id in cls.VISION_TRIGGER_ACTION_IDS:
            return True

        # 키워드 검사 (대소문자 무시)
        if text:
            text_lower = text.lower()
            for keyword in cls.VISION_TRIGGER_KEYWORDS:
                if keyword.lower() in text_lower:
                    return True

        return False

    @classmethod
    def is_quality_trigger(
        cls,
        action_id: str | None,
        text: str | None,
    ) -> bool:
        """QUALITY 모델 트리거 여부를 판단합니다.

        Args:
            action_id: 선택된 액션 ID (선택)
            text: 사용자 입력 텍스트 (선택)

        Returns:
            QUALITY 모델을 사용해야 하는지 여부
        """
        # 액션 ID 검사
        if action_id and action_id in cls.QUALITY_TRIGGER_ACTION_IDS:
            return True

        # 키워드 검사 (대소문자 무시)
        if text:
            text_lower = text.lower()
            for keyword in cls.QUALITY_TRIGGER_KEYWORDS:
                if keyword.lower() in text_lower:
                    return True

        return False

    @classmethod
    def get_cost_multiplier(cls, model_label: ModelLabel) -> float:
        """모델 라벨에 따른 비용 배수를 반환합니다.

        Args:
            model_label: 모델 라벨 (FAST, QUALITY)

        Returns:
            비용 배수
        """
        if model_label == ModelLabel.QUALITY:
            return cls.QUALITY_COST_MULTIPLIER
        return cls.FAST_COST_MULTIPLIER


# 라벨-ID 매핑 테이블
_MODEL_MAP: Final[dict[ModelLabel, str]] = {
    ModelLabel.FAST: MODEL_FAST,
    ModelLabel.QUALITY: MODEL_QUALITY,
    ModelLabel.IMAGE: MODEL_IMAGE,
    ModelLabel.IMAGE_FAST: MODEL_IMAGE_FAST,
    ModelLabel.VISION: MODEL_VISION,
}


def get_model_id(label: ModelLabel) -> str:
    """라벨로 모델 ID를 조회합니다.

    Args:
        label: 모델 라벨 (FAST, QUALITY, IMAGE, VISION)

    Returns:
        해당 라벨에 매핑된 모델 ID 문자열

    Example:
        >>> get_model_id(ModelLabel.FAST)
        'gemini-3-flash-preview'
    """
    return _MODEL_MAP[label]
</file>

<file path="backend/src/unknown_world/orchestrator/mock.py">
"""Unknown World - 모의 Orchestrator.

실모델(Gemini) 없이 프론트엔드 개발/데모를 지속할 수 있도록
결정적(seed 기반) TurnOutput을 생성하는 모의 Orchestrator입니다.

설계 원칙:
    - RULE-004: 검증 실패 시 안전한 폴백 제공
    - RULE-005: 재화 인바리언트 (잔액 음수 금지)
    - RULE-008: 단계/배지 가시화
    - RULE-009: 좌표 규약 (0~1000, bbox [ymin,xmin,ymax,xmax])

참조:
    - vibe/unit-plans/U-007[Mvp].md
    - vibe/unit-plans/U-048[Mvp].md
    - .cursor/rules/20-backend-orchestrator.mdc
"""

import hashlib
import random
from enum import Enum

from unknown_world.models.turn import (
    ActionCard,
    ActionDeck,
    AgentConsole,
    AgentPhase,
    Box2D,
    CurrencyAmount,
    EconomyOutput,
    ImageJob,
    InventoryItemData,
    Language,
    MemoryPin,
    ModelLabel,
    Quest,
    RenderOutput,
    RiskLevel,
    SafetyOutput,
    SceneObject,
    TurnInput,
    TurnOutput,
    UIOutput,
    ValidationBadge,
    WorldDelta,
    WorldRule,
)
from unknown_world.orchestrator.fallback import (
    create_safe_fallback as _create_safe_fallback,
)

# =============================================================================
# 입력 타입 분류 (U-048: 행동 로그 템플릿 분기용)
# =============================================================================


class InputType(str, Enum):
    """입력 타입 분류 (우선순위: DROP > CLICK > ACTION > FREE_TEXT)."""

    DROP = "drop"  # 아이템 드롭 (사용/조합)
    CLICK = "click"  # 핫스팟 클릭 (조사/상호작용)
    ACTION = "action"  # 액션 카드 실행
    FREE_TEXT = "free_text"  # 자유 입력


def _detect_input_type(turn_input: TurnInput) -> InputType:
    """TurnInput에서 입력 타입을 감지 (우선순위 기반).

    우선순위: drop > click > action_id > free_text

    Args:
        turn_input: 사용자 입력

    Returns:
        InputType: 감지된 입력 타입
    """
    if turn_input.drop is not None:
        return InputType.DROP
    if turn_input.click is not None:
        return InputType.CLICK
    if turn_input.action_id is not None:
        return InputType.ACTION
    return InputType.FREE_TEXT


def _compute_turn_seed(base_seed: int, turn_input: TurnInput) -> int:
    """per-turn 결정적 시드 생성 (입력 특징 해시 기반).

    base_seed와 입력의 주요 특징을 해시하여 턴마다 다른 결과를
    생성하면서도 재현성을 유지합니다.

    Args:
        base_seed: 기본 시드
        turn_input: 사용자 입력

    Returns:
        int: per-turn 시드
    """
    # 입력 특징 문자열 생성
    features: list[str] = [str(base_seed)]

    if turn_input.text:
        features.append(turn_input.text)
    if turn_input.action_id:
        features.append(turn_input.action_id)
    if turn_input.click:
        features.append(turn_input.click.object_id)
    if turn_input.drop:
        features.append(turn_input.drop.item_id)
        features.append(turn_input.drop.target_object_id)

    # 특징 문자열을 해시하여 시드 생성
    feature_str = "|".join(features)
    hash_bytes = hashlib.sha256(feature_str.encode("utf-8")).digest()
    # 해시의 처음 8바이트를 정수로 변환
    return int.from_bytes(hash_bytes[:8], byteorder="big") % (2**32)


# =============================================================================
# 행동 로그 프리픽스 템플릿 (U-048: "말했습니다" 제거)
# =============================================================================

# 한국어 행동 로그 프리픽스 (입력 타입별)
# U-062: 언어 혼합 방지를 위해 사용자 입력 텍스트를 프리픽스에 포함하지 않음
KO_ACTION_LOG_PREFIXES: dict[InputType, list[str]] = {
    InputType.DROP: [
        "[사용] {item} → {target}:",
        "[조합] {item}을(를) {target}에 사용:",
        "[적용] {item} → {target}:",
    ],
    InputType.CLICK: [
        "[조사] {object}:",
        "[탐색] {object}을(를) 살펴봄:",
        "[상호작용] {object}:",
    ],
    InputType.ACTION: [
        "[행동]",
        "[실행]",
        "[시도]",
    ],
    InputType.FREE_TEXT: [
        "[행동]",
        "[시도]",
        "[탐색]",
    ],
}

# 영어 행동 로그 프리픽스 (입력 타입별)
# U-062: 언어 혼합 방지를 위해 사용자 입력 텍스트를 프리픽스에 포함하지 않음
EN_ACTION_LOG_PREFIXES: dict[InputType, list[str]] = {
    InputType.DROP: [
        "[USE] {item} → {target}:",
        "[APPLY] {item} on {target}:",
        "[COMBINE] {item} with {target}:",
    ],
    InputType.CLICK: [
        "[EXAMINE] {object}:",
        "[INSPECT] {object}:",
        "[INTERACT] {object}:",
    ],
    InputType.ACTION: [
        "[ACTION]",
        "[EXECUTE]",
        "[ATTEMPT]",
    ],
    InputType.FREE_TEXT: [
        "[ACTION]",
        "[ATTEMPT]",
        "[EXPLORE]",
    ],
}


def _format_action_log_prefix(
    rng: random.Random,
    input_type: InputType,
    turn_input: TurnInput,
    is_korean: bool,
) -> str:
    """입력 타입에 맞는 행동 로그 프리픽스 생성.

    U-062: 언어 혼합 방지를 위해 사용자 입력 텍스트(text, action_id)는
    프리픽스에 포함하지 않습니다. 오직 DROP/CLICK의 오브젝트 ID만 포함합니다.
    (오브젝트 ID는 시스템이 생성한 것이므로 언어 혼합 위험 없음)

    Args:
        rng: 랜덤 생성기
        input_type: 입력 타입
        turn_input: 사용자 입력
        is_korean: 한국어 여부

    Returns:
        str: 포맷된 행동 로그 프리픽스
    """
    templates = KO_ACTION_LOG_PREFIXES if is_korean else EN_ACTION_LOG_PREFIXES
    template = rng.choice(templates[input_type])

    # 입력 타입별 포맷 인자 준비
    # U-062: ACTION/FREE_TEXT는 사용자 입력 텍스트를 포함하지 않음 (언어 혼합 방지)
    format_args: dict[str, str] = {}

    if input_type == InputType.DROP and turn_input.drop:
        format_args["item"] = turn_input.drop.item_id
        format_args["target"] = turn_input.drop.target_object_id
    elif input_type == InputType.CLICK and turn_input.click:
        format_args["object"] = turn_input.click.object_id
    # InputType.ACTION, InputType.FREE_TEXT는 포맷 인자 없음

    return template.format(**format_args)


# =============================================================================
# 모의 데이터 생성 헬퍼
# =============================================================================

# 한국어 내러티브 템플릿
KO_NARRATIVES = [
    "어둠 속에서 희미한 빛이 새어나옵니다. 오래된 문이 삐걱거리며 열리고, 그 너머로 알 수 없는 세계가 펼쳐집니다.",
    "발걸음 소리가 텅 빈 복도에 메아리칩니다. 벽에 걸린 초상화들의 눈이 당신을 따라 움직이는 것 같습니다.",
    "갑자기 바닥이 흔들리며, 벽에서 고대의 문자들이 빛나기 시작합니다. 무언가가 깨어나고 있습니다.",
    "안개가 걷히자, 거대한 탑이 모습을 드러냅니다. 탑 꼭대기에서 이상한 빛이 깜빡이고 있습니다.",
    "낡은 책장을 밀자, 숨겨진 통로가 나타났습니다. 통로 끝에서 기묘한 노래가 들려옵니다.",
]

# 영어 내러티브 템플릿
EN_NARRATIVES = [
    "A faint light seeps through the darkness. An ancient door creaks open, revealing an unknown world beyond.",
    "Footsteps echo through the empty corridor. The eyes of the portraits on the walls seem to follow you.",
    "Suddenly, the ground shakes and ancient runes on the walls begin to glow. Something is awakening.",
    "As the fog lifts, a massive tower reveals itself. A strange light flickers at its peak.",
    "Pushing aside the old bookshelf, you discover a hidden passage. An eerie song emanates from its depths.",
]

# 한국어 액션 카드 템플릿
KO_ACTION_CARDS = [
    {"label": "문을 열어본다", "description": "조심스럽게 문을 열어 안을 살펴본다"},
    {"label": "주변을 탐색한다", "description": "주변에 유용한 물건이 있는지 찾아본다"},
    {"label": "뒤로 물러선다", "description": "위험을 피해 안전한 곳으로 물러선다"},
    {"label": "말을 걸어본다", "description": "상대방에게 조심스럽게 말을 건다"},
    {"label": "숨어서 지켜본다", "description": "은신하여 상황을 관찰한다"},
    {"label": "공격한다", "description": "위협에 맞서 공격을 시도한다"},
]

# 영어 액션 카드 템플릿
EN_ACTION_CARDS = [
    {"label": "Open the door", "description": "Carefully open the door and look inside"},
    {"label": "Search the area", "description": "Look for useful items nearby"},
    {"label": "Step back", "description": "Retreat to a safe place to avoid danger"},
    {"label": "Speak to them", "description": "Cautiously initiate conversation"},
    {"label": "Hide and observe", "description": "Conceal yourself and watch the situation"},
    {"label": "Attack", "description": "Confront the threat with an attack"},
]

# 장면 오브젝트 템플릿
SCENE_OBJECTS_KO = [
    {"label": "낡은 문", "hint": "클릭하여 열어볼 수 있습니다"},
    {"label": "빛나는 보석", "hint": "수집할 수 있을 것 같습니다"},
    {"label": "수상한 상자", "hint": "무언가 들어있을 수 있습니다"},
    {"label": "벽의 스위치", "hint": "작동시킬 수 있습니다"},
]

SCENE_OBJECTS_EN = [
    {"label": "Old door", "hint": "Click to open"},
    {"label": "Glowing gem", "hint": "It looks collectible"},
    {"label": "Suspicious chest", "hint": "Something might be inside"},
    {"label": "Wall switch", "hint": "Can be activated"},
]


def _generate_random_box(rng: random.Random) -> Box2D:
    """랜덤 바운딩 박스 생성 (0~1000 좌표계)."""
    ymin = rng.randint(0, 700)
    xmin = rng.randint(0, 700)
    ymax = ymin + rng.randint(50, 250)
    xmax = xmin + rng.randint(50, 250)
    # 범위 보정
    ymax = min(ymax, 1000)
    xmax = min(xmax, 1000)
    return Box2D(ymin=ymin, xmin=xmin, ymax=ymax, xmax=xmax)


# =============================================================================
# MockOrchestrator 클래스
# =============================================================================


class MockOrchestrator:
    """모의 Orchestrator.

    실모델(Gemini) 없이 TurnOutput을 생성하는 모의 오케스트레이터입니다.
    seed 기반으로 결정적(재현 가능)인 결과를 생성합니다.

    Note:
        Phase 순서는 pipeline.py의 DEFAULT_STAGES가 SSOT입니다 (RU-005-Q1).

    Attributes:
        seed: 랜덤 시드 (재현성 보장)

    Example:
        >>> orchestrator = MockOrchestrator(seed=42)
        >>> turn_input = TurnInput(
        ...     language=Language.KO,
        ...     text="문을 열어본다",
        ...     client=ClientInfo(viewport_w=1920, viewport_h=1080),
        ...     economy_snapshot=EconomySnapshot(signal=100, memory_shard=5),
        ... )
        >>> output = orchestrator.generate_turn_output(turn_input)
    """

    def __init__(self, seed: int | None = None) -> None:
        """MockOrchestrator 초기화.

        Args:
            seed: 랜덤 시드. None이면 랜덤하게 생성.
        """
        self.seed = seed if seed is not None else random.randint(0, 2**32 - 1)
        self._rng = random.Random(self.seed)

    def generate_turn_output(self, turn_input: TurnInput) -> TurnOutput:
        """TurnInput을 받아 TurnOutput을 생성합니다.

        Args:
            turn_input: 사용자 입력

        Returns:
            TurnOutput: 모의 턴 결과
        """
        is_korean = turn_input.language == Language.KO

        # U-048: per-turn 결정적 RNG 생성 (입력에 따라 다른 결과)
        turn_seed = _compute_turn_seed(self.seed, turn_input)
        turn_rng = random.Random(turn_seed)

        # 내러티브 생성 (per-turn RNG 사용으로 입력별 다양성 확보)
        narratives = KO_NARRATIVES if is_korean else EN_NARRATIVES
        narrative = turn_rng.choice(narratives)

        # U-048: 입력 타입별 행동 로그 프리픽스 적용 ("말했습니다" 제거)
        input_type = _detect_input_type(turn_input)
        has_meaningful_input = (
            turn_input.drop is not None
            or turn_input.click is not None
            or turn_input.action_id is not None
            or (turn_input.text and turn_input.text.strip())
        )

        if has_meaningful_input:
            prefix = _format_action_log_prefix(turn_rng, input_type, turn_input, is_korean)
            narrative = f"{prefix} {narrative}"

        # U-048: 모든 생성에 turn_rng 사용 (입력별 결정적 다양성)
        # 액션 덱 생성 (3~6장)
        action_templates = KO_ACTION_CARDS if is_korean else EN_ACTION_CARDS
        num_cards = turn_rng.randint(3, 6)
        selected_templates = turn_rng.sample(
            action_templates, min(num_cards, len(action_templates))
        )

        action_cards: list[ActionCard] = []
        for i, template in enumerate(selected_templates):
            cost_signal = turn_rng.randint(1, 10)
            cost_shard = 1 if turn_rng.random() < 0.2 else 0  # 20% 확률로 shard 소비

            # U-065: description, hint 필드 제거됨 (narrative에서 자연어로 표현)
            action_cards.append(
                ActionCard(
                    id=f"action_{i + 1}",
                    label=template["label"],
                    cost=CurrencyAmount(signal=cost_signal, memory_shard=cost_shard),
                    risk=turn_rng.choice(list(RiskLevel)),
                )
            )

        action_deck = ActionDeck(cards=action_cards)

        # 장면 오브젝트 생성 (1~3개)
        object_templates = SCENE_OBJECTS_KO if is_korean else SCENE_OBJECTS_EN
        num_objects = turn_rng.randint(1, 3)
        selected_objects = turn_rng.sample(
            object_templates, min(num_objects, len(object_templates))
        )

        scene_objects: list[SceneObject] = []
        for i, template in enumerate(selected_objects):
            scene_objects.append(
                SceneObject(
                    id=f"obj_{i + 1}",
                    label=template["label"],
                    box_2d=_generate_random_box(turn_rng),
                    interaction_hint=template["hint"],
                )
            )

        ui_output = UIOutput(action_deck=action_deck, objects=scene_objects)

        # 세계 상태 변화 (delta) - turn_rng 전달
        world_delta = self._generate_world_delta(is_korean, turn_rng)

        # 렌더링 출력 (이미지 생성은 선택적)
        should_generate_image = turn_rng.random() < 0.3  # 30% 확률로 이미지 생성
        render_output = RenderOutput(
            image_job=ImageJob(
                should_generate=should_generate_image,
                prompt="A mysterious dungeon scene" if should_generate_image else "",
                model_label=ModelLabel.FAST,
                aspect_ratio="16:9",
                image_size="1024x576",
            )
            if should_generate_image
            else None
        )

        # 경제 출력 (비용 계산)
        turn_cost = CurrencyAmount(
            signal=turn_rng.randint(1, 5),
            memory_shard=0,
        )

        # 잔액 계산 (음수 방지 - RULE-005)
        balance_signal = max(0, turn_input.economy_snapshot.signal - turn_cost.signal)
        balance_shard = max(0, turn_input.economy_snapshot.memory_shard - turn_cost.memory_shard)

        economy_output = EconomyOutput(
            cost=turn_cost,
            balance_after=CurrencyAmount(signal=balance_signal, memory_shard=balance_shard),
        )

        # 안전 출력
        safety_output = SafetyOutput(blocked=False, message=None)

        # 에이전트 콘솔
        agent_console = AgentConsole(
            current_phase=AgentPhase.COMMIT,
            badges=[
                ValidationBadge.SCHEMA_OK,
                ValidationBadge.ECONOMY_OK,
                ValidationBadge.SAFETY_OK,
                ValidationBadge.CONSISTENCY_OK,
            ],
            repair_count=0,
        )

        return TurnOutput(
            language=turn_input.language,
            narrative=narrative,
            ui=ui_output,
            world=world_delta,
            render=render_output,
            economy=economy_output,
            safety=safety_output,
            agent_console=agent_console,
        )

    def _generate_world_delta(
        self, is_korean: bool, rng: random.Random | None = None
    ) -> WorldDelta:
        """세계 상태 변화 생성.

        Args:
            is_korean: 한국어 여부
            rng: 사용할 RNG (None이면 self._rng 사용, U-048 하위호환)

        Returns:
            WorldDelta: 생성된 세계 상태 변화
        """
        # U-048: per-turn RNG 지원 (하위호환 유지)
        use_rng = rng if rng is not None else self._rng

        # 규칙 변경 (20% 확률)
        rules_changed: list[WorldRule] = []
        if use_rng.random() < 0.2:
            rules_changed.append(
                WorldRule(
                    id="rule_gravity",
                    label="중력 반전" if is_korean else "Gravity Inversion",
                    description=(
                        "이 구역에서는 중력이 반대로 작용합니다"
                        if is_korean
                        else "Gravity works in reverse in this area"
                    ),
                )
            )

        # 인벤토리 추가 (30% 확률)
        inventory_added: list[InventoryItemData] = []
        if use_rng.random() < 0.3:
            items_ko = [
                {
                    "id": "old_key",
                    "label": "낡은 열쇠",
                    "description": "녹슬고 오래된 철제 열쇠입니다.",
                },
                {
                    "id": "mystic_orb",
                    "label": "신비로운 구슬",
                    "description": "은은한 푸른 빛을 내뿜는 투명한 구슬입니다.",
                },
                {
                    "id": "ancient_scroll",
                    "label": "고대의 두루마리",
                    "description": "알 수 없는 문자가 적힌 낡은 양피지 두루마리입니다.",
                },
            ]
            items_en = [
                {"id": "old_key", "label": "Old Key", "description": "A rusty and old iron key."},
                {
                    "id": "mystic_orb",
                    "label": "Mysterious Orb",
                    "description": "A transparent orb emitting a faint blue light.",
                },
                {
                    "id": "ancient_scroll",
                    "label": "Ancient Scroll",
                    "description": "An old parchment scroll with unknown characters.",
                },
            ]
            templates = items_ko if is_korean else items_en
            selected = use_rng.choice(templates)
            inventory_added.append(
                InventoryItemData(
                    id=selected["id"],
                    label=selected["label"],
                    description=selected["description"],
                    quantity=1,
                )
            )

        # 퀘스트 업데이트 (25% 확률)
        quests_updated: list[Quest] = []
        if use_rng.random() < 0.25:
            quests_updated.append(
                Quest(
                    id="quest_explore",
                    label="미지의 영역 탐험" if is_korean else "Explore Unknown Territory",
                    is_completed=use_rng.random() < 0.3,
                )
            )

        # 메모리 핀 (15% 확률)
        memory_pins: list[MemoryPin] = []
        if use_rng.random() < 0.15:
            memory_pins.append(
                MemoryPin(
                    id="pin_1",
                    content="이 장소의 이름은 '잊혀진 성소'"
                    if is_korean
                    else "This place is called 'Forgotten Sanctuary'",
                    cost=CurrencyAmount(signal=0, memory_shard=1),
                )
            )

        return WorldDelta(
            rules_changed=rules_changed,
            inventory_added=inventory_added,
            inventory_removed=[],
            quests_updated=quests_updated,
            relationships_changed=[],
            memory_pins=memory_pins,
        )

    def create_safe_fallback(
        self,
        language: Language,
        error_message: str | None = None,  # noqa: ARG002 - 하위 호환용 (실제로 사용하지 않음)
        economy_snapshot: CurrencyAmount | None = None,
    ) -> TurnOutput:
        """안전한 폴백 TurnOutput 생성 (RULE-004, RU-002-S1).

        스키마 검증 실패 시 반환할 안전한 기본 응답입니다.
        폴백 시 economy.balance_after는 입력 스냅샷을 그대로 유지합니다 (비용 0, 잔액 변화 없음).

        Note:
            이 메서드는 fallback.create_safe_fallback SSOT로 위임합니다 (RU-005-Q1).

        Args:
            language: 응답 언어
            error_message: 에러 메시지 (하위 호환용, 실제 미사용)
            economy_snapshot: 요청 직전 재화 스냅샷 (폴백 시 잔액 유지용)

        Returns:
            TurnOutput: 안전한 폴백 응답
        """
        # RU-005-Q1: fallback SSOT로 위임
        return _create_safe_fallback(
            language=language,
            economy_snapshot=economy_snapshot,
            repair_count=1,  # Mock에서는 기본 복구 시도 1회로 표시
            is_blocked=False,
        )
</file>

<file path="backend/src/unknown_world/orchestrator/stages/types.py">
"""Unknown World - Pipeline Stage 타입 정의.

Pipeline에서 사용하는 컨텍스트와 emit 콜백 인터페이스를 정의합니다.

설계 원칙:
    - Option A (RU-005 Q1 결정): 클래스 도입 없이 함수 체인 방식
    - 레이어링 보호: 오케스트레이터가 FastAPI에 직접 의존하지 않도록 emit 콜백 사용
    - RULE-007/008: 프롬프트/내부 추론 노출 금지, 단계/배지만 표시
    - U-051: 이미지 생성 서비스 의존성 주입 (순환 의존 방지를 위해 TYPE_CHECKING 활용)
    - U-127: 멀티턴 대화 히스토리 전달 경로

참조:
    - vibe/refactors/RU-005-Q4.md
    - vibe/unit-results/U-018[Mvp].md
    - vibe/unit-results/U-019[Mvp].md
    - vibe/unit-plans/U-127[Mvp].md
"""

from __future__ import annotations

from collections.abc import Awaitable, Callable
from dataclasses import dataclass, field
from enum import Enum
from typing import TYPE_CHECKING, Any, Protocol

from unknown_world.models.turn import (
    AgentPhase,
    CurrencyAmount,
    ModelLabel,
    TurnInput,
    TurnOutput,
    ValidationBadge,
)

if TYPE_CHECKING:
    from unknown_world.orchestrator.conversation_history import ConversationHistory
    from unknown_world.services.image_generation import ImageGeneratorType

# =============================================================================
# Emit 콜백 타입 (오케스트레이터 → API 레이어)
# =============================================================================


class PipelineEventType(str, Enum):
    """파이프라인 이벤트 타입.

    오케스트레이터가 API 레이어로 전달하는 도메인 이벤트 타입입니다.
    API 레이어는 이를 StageEvent/BadgesEvent/RepairEvent 등으로 변환합니다.
    """

    STAGE_START = "stage_start"
    STAGE_COMPLETE = "stage_complete"
    STAGE_FAIL = "stage_fail"
    BADGES = "badges"
    REPAIR = "repair"
    NARRATIVE_DELTA = "narrative_delta"


@dataclass
class PipelineEvent:
    """파이프라인 이벤트.

    오케스트레이터가 emit 콜백으로 전달하는 도메인 이벤트입니다.
    API 레이어에서 스트림 이벤트로 변환됩니다.

    Attributes:
        event_type: 이벤트 타입
        phase: 관련 단계 (stage 이벤트용)
        badges: 배지 목록 (badges 이벤트용)
        repair_attempt: 복구 시도 횟수 (repair 이벤트용)
        repair_message: 복구 메시지 (repair 이벤트용)
        text: 텍스트 (narrative_delta 이벤트용)
        extra: 추가 데이터
    """

    event_type: PipelineEventType
    phase: AgentPhase | None = None
    badges: list[ValidationBadge] | None = None
    repair_attempt: int = 0
    repair_message: str | None = None
    text: str | None = None
    extra: dict[str, Any] = field(default_factory=lambda: {})


# Emit 함수 타입: async callable로 도메인 이벤트를 전달
EmitFn = Callable[[PipelineEvent], Awaitable[None]]


# =============================================================================
# Pipeline Context
# =============================================================================


@dataclass
class PipelineContext:
    """파이프라인 컨텍스트.

    Stage 함수들이 공유하는 컨텍스트입니다.
    각 stage는 ctx를 받아 수정하고 반환합니다 (Option A: 함수 체인).

    Attributes:
        turn_input: 사용자 턴 입력
        economy_snapshot: 요청 시점 재화 스냅샷 (폴백 시 보존용)
        output: 생성된 TurnOutput (validate stage 이후)
        badges: 현재까지 수집된 배지 목록
        repair_messages: 복구 시도 시 발생한 메시지 목록
        repair_attempts: 복구 시도 횟수
        current_phase: 현재 단계
        is_fallback: 폴백으로 종료되었는지
        is_mock: Mock 모드인지
        seed: Mock 모드 시드 (재현성 보장)
        image_generator: 이미지 생성 서비스 (U-051, 선택적 주입)
            None이면 이미지 생성을 건너뛰고 pass-through로 동작합니다.
            테스트 시 MockImageGenerator를 주입하여 실제 API 호출 없이 검증 가능합니다.
        model_label: 현재 사용 중인 텍스트 모델 라벨 (U-069: FAST/QUALITY)
        cost_multiplier: 비용 배수 (U-069: FAST=1.0, QUALITY=2.0)
        conversation_history: 멀티턴 대화 히스토리 (U-127, 선택적 주입)
        thought_signature: 현재 턴의 Thought Signature (U-127, validate 후 설정)
        is_rate_limited: API rate limit(429)으로 모든 재시도 소진 여부 (U-130)
    """

    turn_input: TurnInput
    economy_snapshot: CurrencyAmount
    output: TurnOutput | None = None
    badges: list[ValidationBadge] = field(default_factory=lambda: [])
    repair_messages: list[str] = field(default_factory=lambda: [])
    repair_attempts: int = 0
    current_phase: AgentPhase = AgentPhase.PARSE
    is_fallback: bool = False
    is_rate_limited: bool = False
    is_mock: bool = False
    seed: int | None = None
    image_generator: ImageGeneratorType | None = None
    model_label: ModelLabel = ModelLabel.FAST
    cost_multiplier: float = 1.0
    conversation_history: ConversationHistory | None = None
    thought_signature: str | None = None


# =============================================================================
# Stage 함수 타입
# =============================================================================


class StageFn(Protocol):
    """Stage 함수 프로토콜.

    각 stage 함수는 이 프로토콜을 따릅니다.
    ctx를 받아 수정하고 반환하며, emit 콜백으로 이벤트를 전달합니다.
    """

    async def __call__(self, ctx: PipelineContext, *, emit: EmitFn) -> PipelineContext: ...
</file>

<file path="backend/src/unknown_world/storage/validation.py">
"""Unknown World - 파일 검증 및 제한 정책.

모든 이미지/아티팩트 관련 검증 로직과 상수를 중앙 관리합니다.
U-085: image_size를 SDK 값(1K/2K/4K)으로 마이그레이션.

설계 원칙:
    - RULE-007: 에러 메시지에 파일 내용 노출 금지
    - RULE-004: 검증 실패 시 명확한 에러 메시지 반환

참조:
    - vibe/refactors/RU-006-Q1.md
"""

from __future__ import annotations

from typing import Final

from unknown_world.models.turn import Language

# =============================================================================
# 이미지 업로드 제한 (Scanner/Vision 공통)
# =============================================================================

ALLOWED_IMAGE_MIME_TYPES: Final[frozenset[str]] = frozenset(
    {
        "image/jpeg",
        "image/jpg",
        "image/png",
        "image/gif",
        "image/webp",
    }
)
"""지원하는 이미지 MIME 타입."""

MAX_IMAGE_FILE_SIZE_BYTES: Final[int] = 20 * 1024 * 1024  # 20MB
"""최대 이미지 파일 크기 (바이트)."""

MIN_IMAGE_FILE_SIZE_BYTES: Final[int] = 100
"""최소 이미지 파일 크기 (손상 파일 감지용)."""

# =============================================================================
# 이미지 생성 제한
# =============================================================================

SUPPORTED_IMAGE_SIZES: Final[frozenset[str]] = frozenset({"1K", "2K", "4K"})
"""지원하는 이미지 생성 크기 (SDK 값, U-085: Q2 Option B 마이그레이션).

Gemini SDK image_config.image_size 값과 1:1 대응합니다.
대문자 'K' 필수 (소문자 거부됨).
참조: vibe/ref/image-generate-guide.md
"""

# U-085: 레거시 픽셀 기반 크기 → SDK 값 매핑 (하위 호환용)
LEGACY_IMAGE_SIZE_MAP: Final[dict[str, str]] = {
    "1024x1024": "1K",
    "1280x768": "1K",
    "768x1280": "1K",
    "1536x1024": "2K",
    "1024x1536": "2K",
}
"""레거시 픽셀 기반 image_size → SDK 값 매핑 (하위 호환)."""

DEFAULT_IMAGE_SIZE: Final[str] = "1K"
"""기본 이미지 생성 크기 (SDK 값, U-085 마이그레이션)."""

DEFAULT_ASPECT_RATIO: Final[str] = "16:9"
"""기본 가로세로 비율 (U-085: 게임 UI 기본 비율)."""

SUPPORTED_ASPECT_RATIOS: Final[frozenset[str]] = frozenset(
    {"1:1", "2:3", "3:2", "3:4", "4:3", "4:5", "5:4", "9:16", "16:9", "21:9"}
)
"""SDK가 지원하는 aspect_ratio 값 목록.

참조: vibe/ref/image-generate-guide.md
"""

MIN_PROMPT_LENGTH: Final[int] = 3
"""최소 프롬프트 길이."""

MAX_PROMPT_LENGTH: Final[int] = 2000
"""최대 프롬프트 길이."""

# =============================================================================
# bbox 정규화 범위 (RULE-009)
# =============================================================================

BBOX_MIN: Final[int] = 0
"""bbox 최소값."""

BBOX_MAX: Final[int] = 1000
"""bbox 최대값."""


# =============================================================================
# 검증 함수
# =============================================================================


def validate_image_upload(
    content: bytes,
    content_type: str,
    *,
    language: Language = Language.EN,
) -> str | None:
    """업로드 이미지를 검증합니다.

    Args:
        content: 이미지 바이트 데이터
        content_type: MIME 타입
        language: 에러 메시지 언어

    Returns:
        에러 메시지 (없으면 None)
    """
    is_ko = language == Language.KO

    # MIME 타입 검증
    if content_type.lower() not in ALLOWED_IMAGE_MIME_TYPES:
        return (
            f"지원하지 않는 이미지 형식입니다: {content_type}"
            if is_ko
            else f"Unsupported image format: {content_type}"
        )

    # 파일 크기 검증 (최대)
    if len(content) > MAX_IMAGE_FILE_SIZE_BYTES:
        size_mb = len(content) / (1024 * 1024)
        return (
            f"파일이 너무 큽니다: {size_mb:.1f}MB (최대 20MB)"
            if is_ko
            else f"File too large: {size_mb:.1f}MB (max 20MB)"
        )

    # 파일 크기 검증 (최소 - 손상 파일 감지)
    if len(content) < MIN_IMAGE_FILE_SIZE_BYTES:
        return (
            "이미지 파일이 손상되었거나 비어있습니다"
            if is_ko
            else "Image file is corrupted or empty"
        )

    return None


def normalize_image_size(image_size: str) -> str:
    """이미지 크기를 SDK 값으로 정규화합니다 (U-085).

    레거시 픽셀 기반 값(예: "1024x1024")이 들어오면 SDK 값(예: "1K")으로 매핑합니다.
    이미 SDK 값이면 그대로 반환합니다.

    Args:
        image_size: 요청된 이미지 크기 (SDK 값 또는 레거시 픽셀 값)

    Returns:
        정규화된 SDK 이미지 크기 값
    """
    if image_size in SUPPORTED_IMAGE_SIZES:
        return image_size
    # 레거시 값이면 매핑, 아니면 입력값 그대로 반환하여 검증에서 걸러지도록 함
    return LEGACY_IMAGE_SIZE_MAP.get(image_size, image_size)


def validate_image_generation_request(
    prompt: str,
    image_size: str,
    *,
    language: Language = Language.EN,
) -> str | None:
    """이미지 생성 요청을 검증합니다.

    U-085: image_size는 SDK 값(1K/2K/4K) 또는 레거시 픽셀 값을 허용합니다.
    레거시 값은 normalize_image_size()로 자동 변환됩니다.

    Args:
        prompt: 이미지 생성 프롬프트
        image_size: 요청된 이미지 크기 (SDK 값 또는 레거시 픽셀 값)
        language: 에러 메시지 언어

    Returns:
        에러 메시지 (없으면 None)
    """
    is_ko = language == Language.KO

    # 이미지 크기 검증 (SDK 값 또는 레거시 매핑 가능 값)
    normalized = normalize_image_size(image_size)
    if normalized not in SUPPORTED_IMAGE_SIZES:
        return (
            f"지원하지 않는 이미지 크기: {image_size}"
            if is_ko
            else f"Unsupported image size: {image_size}"
        )

    # 프롬프트 길이 검증 (너무 짧음)
    if len(prompt) < MIN_PROMPT_LENGTH:
        return "프롬프트가 너무 짧습니다." if is_ko else "Prompt is too short."

    # 프롬프트 길이 검증 (너무 김)
    if len(prompt) > MAX_PROMPT_LENGTH:
        return (
            f"프롬프트가 너무 깁니다 (최대 {MAX_PROMPT_LENGTH}자)."
            if is_ko
            else f"Prompt is too long (max {MAX_PROMPT_LENGTH} chars)."
        )

    return None


def get_max_file_size_mb() -> int:
    """최대 파일 크기를 MB 단위로 반환합니다."""
    return MAX_IMAGE_FILE_SIZE_BYTES // (1024 * 1024)
</file>

<file path="frontend/src/api/image.ts">
/**
 * Unknown World - 이미지 생성 API 클라이언트 (U-066)
 *
 * 이미지 생성을 턴과 분리하여 비동기적으로 호출합니다.
 * 텍스트 턴의 TTFB를 블로킹하지 않습니다 (RULE-008).
 *
 * 설계 원칙:
 *   - RULE-004: 실패 시 안전한 폴백 (텍스트-only 진행)
 *   - RULE-007: 프롬프트 원문 노출 금지 (로그에 해시만 기록)
 *   - RULE-008: 텍스트 우선 + Lazy 이미지 원칙
 *
 * @module api/image
 */

import type { Language } from '../schemas/turn';

// =============================================================================
// 상수 정의
// =============================================================================

/** API 베이스 URL */
const API_BASE_URL = import.meta.env.VITE_API_URL ?? 'http://localhost:8011';

/** 이미지 생성 API 엔드포인트 */
const IMAGE_GENERATE_ENDPOINT = `${API_BASE_URL}/api/image/generate`;

// =============================================================================
// 타입 정의
// =============================================================================

/** 이미지 생성 상태 */
export type ImageGenerationStatus = 'pending' | 'generating' | 'completed' | 'failed' | 'skipped';

/** 모델 티어링 라벨 (U-066) */
export type ImageModelLabel = 'FAST' | 'QUALITY';

/** 이미지 생성 요청 파라미터 */
export interface ImageGenerationRequest {
  /** 이미지 생성 프롬프트 (필수) */
  prompt: string;
  /** 언어 (에러 메시지용) */
  language?: Language;
  /** 가로세로 비율 (U-085: UI 레이아웃 기반 자동 선택, 예: "16:9") */
  aspectRatio?: string;
  /** 이미지 크기 - SDK 값 (U-085 Q2: "1K" | "2K" | "4K") */
  imageSize?: string;
  /** 참조 이미지 ID 목록 */
  referenceImageIds?: string[];
  /** 참조 이미지 URL (U-068: 이전 턴 이미지를 참조하여 연속성 유지) */
  referenceImageUrl?: string;
  /** 세션 ID */
  sessionId?: string;
  /** 실패 시 건너뛰기 (기본값: true) */
  skipOnFailure?: boolean;
  /** 모델 티어링 라벨 (U-066: FAST/QUALITY) */
  modelLabel?: ImageModelLabel;
  /** 턴 ID (late-binding 가드용, U-066) */
  turnId?: number;
}

/** 이미지 생성 응답 */
export interface ImageGenerationResponse {
  /** 성공 여부 */
  success: boolean;
  /** 생성 상태 */
  status: ImageGenerationStatus;
  /** 생성된 이미지 ID */
  imageId?: string;
  /** 생성된 이미지 URL */
  imageUrl?: string;
  /** 상태 메시지 */
  message?: string;
  /** 생성 소요 시간 (ms) */
  generationTimeMs: number;
  /** 사용된 모델 라벨 (U-066) */
  modelLabel: ImageModelLabel;
  /** 요청 턴 ID (U-066, late-binding 가드용) */
  turnId?: number;
}

/** 이미지 생성 옵션 */
export interface GenerateImageOptions {
  /** AbortSignal (요청 취소용) */
  signal?: AbortSignal;
  /** 타임아웃 (ms, 기본값: 60000) */
  timeout?: number;
}

// =============================================================================
// API 클라이언트 함수
// =============================================================================

/**
 * 이미지를 생성합니다.
 *
 * 턴과 분리된 비동기 호출로, 텍스트 스트리밍을 블로킹하지 않습니다.
 * AbortController로 요청을 취소할 수 있습니다.
 *
 * @param request - 이미지 생성 요청 파라미터
 * @param options - 생성 옵션 (signal, timeout)
 * @returns 이미지 생성 응답
 *
 * @example
 * ```ts
 * const controller = new AbortController();
 * const response = await generateImage(
 *   { prompt: 'A dark fantasy scene...', turnId: 5, modelLabel: 'FAST' },
 *   { signal: controller.signal }
 * );
 * if (response.success) {
 *   console.log('Image URL:', response.imageUrl);
 * }
 * // 취소 시: controller.abort();
 * ```
 */
export async function generateImage(
  request: ImageGenerationRequest,
  options: GenerateImageOptions = {},
): Promise<ImageGenerationResponse> {
  const { signal, timeout = 60000 } = options;

  // 타임아웃 AbortController (signal이 없을 때 사용)
  const timeoutController = new AbortController();
  const timeoutId = setTimeout(() => timeoutController.abort(), timeout);

  // 외부 signal과 타임아웃 signal 중 먼저 abort되는 것을 사용
  const combinedSignal = signal ?? timeoutController.signal;

  try {
    const response = await fetch(IMAGE_GENERATE_ENDPOINT, {
      method: 'POST',
      headers: {
        'Content-Type': 'application/json',
      },
      body: JSON.stringify({
        prompt: request.prompt,
        language: request.language ?? 'en-US',
        // U-085: aspect_ratio는 UI 레이아웃 기반 선택값 사용 (기본 16:9)
        aspect_ratio: request.aspectRatio ?? '16:9',
        // U-085 Q2: image_size는 SDK 값 (1K/2K/4K) 사용
        image_size: request.imageSize ?? '1K',
        reference_image_ids: request.referenceImageIds ?? [],
        reference_image_url: request.referenceImageUrl ?? null,
        session_id: request.sessionId ?? null,
        skip_on_failure: request.skipOnFailure ?? true,
        model_label: request.modelLabel ?? 'QUALITY',
        turn_id: request.turnId ?? null,
      }),
      signal: combinedSignal,
    });

    clearTimeout(timeoutId);

    if (!response.ok) {
      // HTTP 에러 응답 처리
      const errorText = await response.text().catch(() => 'Unknown error');
      return {
        success: false,
        status: 'failed',
        message: `HTTP ${response.status}: ${errorText}`,
        generationTimeMs: 0,
        modelLabel: request.modelLabel ?? 'QUALITY',
        turnId: request.turnId,
      };
    }

    const data = await response.json();

    // snake_case → camelCase 변환
    return {
      success: data.success,
      status: data.status,
      imageId: data.image_id,
      imageUrl: data.image_url,
      message: data.message,
      generationTimeMs: data.generation_time_ms ?? 0,
      modelLabel: data.model_label ?? request.modelLabel ?? 'QUALITY',
      turnId: data.turn_id ?? request.turnId,
    };
  } catch (error) {
    clearTimeout(timeoutId);

    // AbortError 처리 (취소됨)
    if (error instanceof Error && error.name === 'AbortError') {
      return {
        success: false,
        status: 'skipped',
        message: '이미지 생성이 취소되었습니다.',
        generationTimeMs: 0,
        modelLabel: request.modelLabel ?? 'QUALITY',
        turnId: request.turnId,
      };
    }

    // 기타 네트워크 에러
    return {
      success: false,
      status: 'failed',
      message: error instanceof Error ? error.message : '이미지 생성 중 오류가 발생했습니다.',
      generationTimeMs: 0,
      modelLabel: request.modelLabel ?? 'QUALITY',
      turnId: request.turnId,
    };
  }
}

/**
 * 이미지 생성 요청을 생성하고 AbortController를 반환합니다.
 *
 * 턴 완료 후 이미지 생성을 시작하고, 새 턴 시작 시 취소할 수 있습니다.
 *
 * @param request - 이미지 생성 요청 파라미터
 * @param onComplete - 완료 콜백
 * @param onError - 에러 콜백
 * @returns AbortController (취소용)
 *
 * @example
 * ```ts
 * const controller = startImageGeneration(
 *   { prompt: 'A dark fantasy scene...', turnId: 5 },
 *   (response) => {
 *     if (response.success) {
 *       worldStore.setSceneImage(response.imageUrl, response.turnId);
 *     }
 *   },
 *   (error) => console.error('Image generation failed:', error)
 * );
 *
 * // 새 턴 시작 시 이전 요청 취소
 * controller.abort();
 * ```
 */
export function startImageGeneration(
  request: ImageGenerationRequest,
  onComplete: (response: ImageGenerationResponse) => void,
  onError?: (error: Error) => void,
): AbortController {
  const controller = new AbortController();

  generateImage(request, { signal: controller.signal })
    .then(onComplete)
    .catch((error) => {
      if (error instanceof Error && error.name !== 'AbortError') {
        onError?.(error);
      }
    });

  return controller;
}
</file>

<file path="frontend/src/App.test.tsx">
import { describe, it, expect, vi, beforeEach } from 'vitest';
import { render, screen, fireEvent, waitFor } from '@testing-library/react';
import App from './App';
import * as turnStream from './api/turnStream';
import { useInventoryStore } from './stores/inventoryStore';
import { DemoProfile } from './data/demoProfiles';

// i18next 모킹 (RU-003-Q5: 데모 i18n 키 지원)
vi.mock('react-i18next', () => ({
  useTranslation: () => ({
    t: (key: string, options?: Record<string, unknown>) => {
      // 데모 아이템 이름
      if (key === 'profile.tech.items.data_core') return 'Data Core';
      if (key === 'profile.tech.items.circuit_board') return 'Circuit Board';
      if (key === 'profile.tech.items.energy_cell') return 'Energy Cell';
      if (key === 'profile.tech.items.scanner') return 'Scanner Device';

      // 데모 씬 오브젝트 (프로필 기반)
      if (key === 'profile.tech.scene.terminal') return 'Terminal';
      if (key === 'profile.tech.scene.terminal_hint') return 'An active terminal';

      // 액션 템플릿
      if (key === 'scene.hotspot.click_action') {
        return `Click: ${options?.label}`;
      }
      return key;
    },
    i18n: {
      changeLanguage: () => Promise.resolve(),
      resolvedLanguage: 'en-US',
    },
  }),
  initReactI18next: {
    type: '3rdParty',
    init: () => {},
  },
}));

// U-132: 데모 프로필에 핫스팟 주입 (테스트용)
vi.mock('./data/demoProfiles', async (importOriginal) => {
  const actual = (await importOriginal()) as {
    PROFILE_NARRATOR: DemoProfile;
    PROFILE_EXPLORER: DemoProfile;
    PROFILE_TECH: DemoProfile;
    DEMO_PROFILES: DemoProfile[];
  };
  const modifiedProfileTech: DemoProfile = {
    ...actual.PROFILE_TECH,
    initialState: {
      ...actual.PROFILE_TECH.initialState,
      sceneObjectDefs: [
        {
          id: 'main-terminal',
          labelKey: 'profile.tech.scene.terminal',
          hintKey: 'profile.tech.scene.terminal_hint',
          box_2d: { ymin: 200, xmin: 300, ymax: 600, xmax: 700 },
        },
      ],
    },
  };
  return {
    ...actual,
    PROFILE_TECH: modifiedProfileTech,
    get DEMO_PROFILES() {
      return [actual.PROFILE_NARRATOR, actual.PROFILE_EXPLORER, modifiedProfileTech];
    },
  };
});

// ResizeObserver 모킹
class MockResizeObserver {
  observe = vi.fn();
  unobserve = vi.fn();
  disconnect = vi.fn();
}
global.ResizeObserver = MockResizeObserver as unknown as typeof ResizeObserver;

// getBoundingClientRect 모킹
Element.prototype.getBoundingClientRect = vi.fn(() => ({
  width: 800,
  height: 600,
  top: 0,
  left: 0,
  bottom: 600,
  right: 800,
  x: 0,
  y: 0,
  toJSON: () => {},
})) as unknown as () => DOMRect;

// api 모킹
vi.mock('./api/turnStream', () => ({
  startTurnStream: vi.fn(),
}));

describe('App Integration - Hotspot Click', () => {
  beforeEach(() => {
    vi.clearAllMocks();
    localStorage.clear();
  });

  it('should trigger startTurnStream when a hotspot is clicked', async () => {
    render(<App />);

    // 1. 프로필 선택 (Playing 페이즈 진입) - 테크 프로필 선택
    const techProfile = screen.getByLabelText('profile.tech.name');
    fireEvent.click(techProfile);

    // U-060: 프로필 선택 후 상태 전환이 React 상태 업데이트이므로 waitFor 사용
    // 2. 이제 메인 게임 UI가 나타남 - 테크 프로필의 'Terminal' 핫스팟 찾기
    const terminalHotspot = await waitFor(() => {
      const hotspot = screen.getByLabelText('Terminal');
      expect(hotspot).toBeInTheDocument();
      return hotspot;
    });

    // 클릭 시뮬레이션
    fireEvent.click(terminalHotspot);

    // startTurnStream 호출 확인
    await waitFor(() => {
      expect(turnStream.startTurnStream).toHaveBeenCalled();
    });

    const [input] = vi.mocked(turnStream.startTurnStream).mock.calls[0];

    // TurnInput 검증
    expect(input.text).toBe('Click: Terminal');
    expect(input.click).toEqual({
      object_id: 'main-terminal',
      box_2d: { ymin: 200, xmin: 300, ymax: 600, xmax: 700 },
    });
  });
});

describe('App Layout - Inventory Count', () => {
  beforeEach(() => {
    vi.clearAllMocks();
    localStorage.clear();
    useInventoryStore.getState().reset();
  });

  it('updates inventory panel title based on items', async () => {
    render(<App />);

    // 1. 프로필 선택
    const techProfile = screen.getByLabelText('profile.tech.name');
    fireEvent.click(techProfile);

    // 2. 초기 제목 확인 (Tech 프로필은 기본 아이템이 있으므로 바로 inventory.count가 보임)
    await waitFor(() => {
      expect(screen.getByText(/inventory.count/)).toBeInTheDocument();
    });

    // 3. 아이템 모두 제거
    useInventoryStore.getState().reset();

    // 4. 제목이 기본값으로 돌아왔는지 확인
    await waitFor(() => {
      expect(screen.getByText('panel.inventory.title')).toBeInTheDocument();
    });

    // 5. 다시 아이템 추가
    useInventoryStore.getState().addItems([
      {
        id: 'test-item',
        name: 'Test Item',
        quantity: 1,
      },
    ]);

    // 6. 제목 업데이트 다시 확인
    await waitFor(() => {
      expect(screen.getByText(/inventory.count/)).toBeInTheDocument();
    });
  });
});
</file>

<file path="frontend/src/components/AgentConsole.test.tsx">
import { describe, it, expect, vi, beforeEach } from 'vitest';
import { render, screen } from '@testing-library/react';
import { AgentConsole } from './AgentConsole';
import type { ValidationBadge, TurnOutput } from '../schemas/turn';
import type { PhaseInfo, AgentError } from '../stores/agentStore';

// Mock i18n
vi.mock('react-i18next', () => ({
  useTranslation: () => ({
    t: (key: string, _options?: { ok?: number; total?: number; count?: number }) => {
      // Return key for assertion, or format if needed
      return key;
    },
  }),
}));

// Mock store state
interface MockState {
  phases: PhaseInfo[];
  badges: ValidationBadge[];
  repairCount: number;
  error: AgentError | null;
  isStreaming: boolean;
  finalOutput: Partial<TurnOutput> | null;
}

const mockState: MockState = {
  phases: [],
  badges: [],
  repairCount: 0,
  error: null,
  isStreaming: false,
  finalOutput: {
    agent_console: {
      model_label: 'FAST',
      repair_count: 0,
    },
  } as Partial<TurnOutput>,
};

// Mock dependencies
vi.mock('../stores/agentStore', () => ({
  useAgentStore: (selector: (state: MockState) => unknown) => selector(mockState),
  selectIsStreaming: (state: MockState) => state.isStreaming,
  selectPhases: (state: MockState) => state.phases,
  selectBadges: (state: MockState) => state.badges,
  selectRepairCount: (state: MockState) => state.repairCount,
  selectError: (state: MockState) => state.error,
  selectModelLabel: (state: MockState) => state.finalOutput?.agent_console?.model_label ?? 'FAST',
}));

describe('AgentConsole (U-123)', () => {
  beforeEach(() => {
    // Reset mock state
    mockState.phases = [];
    mockState.badges = [];
    mockState.repairCount = 0;
    mockState.error = null;
    mockState.isStreaming = false;
    mockState.finalOutput = {
      agent_console: {
        model_label: 'FAST',
        repair_count: 0,
      },
    } as Partial<TurnOutput>;
  });

  it('should always show queue, badges panel, and divider', () => {
    render(<AgentConsole />);

    // Queue should always be visible (U-123)
    expect(screen.getByText('agent.console.queue')).toBeInTheDocument();
    expect(screen.getByText('agent.console.queue_idle')).toBeInTheDocument();

    // Badges panel should always be visible (U-123)
    expect(screen.getByText('agent.console.badges')).toBeInTheDocument();
    expect(screen.getByText('agent.console.badges_empty')).toBeInTheDocument();

    // Divider should be present
    const divider = document.querySelector('.agent-console-divider');
    expect(divider).toBeInTheDocument();

    // Toggle button should NOT be present
    expect(
      screen.queryByRole('button', { name: /agent\.console\.badges_toggle/i }),
    ).not.toBeInTheDocument();
  });

  it('should show all badges details directly when badges exist', () => {
    mockState.badges = ['schema_ok', 'economy_ok'];

    render(<AgentConsole />);

    // Badges label
    expect(screen.getByText('agent.console.badges')).toBeInTheDocument();

    // Individual badge items should be visible
    expect(screen.getByText('agent.console.badge.schema')).toBeInTheDocument();
    expect(screen.getByText('agent.console.badge.economy')).toBeInTheDocument();

    // Status text (OK)
    const okStatuses = screen.getAllByText('agent.console.badge.ok');
    expect(okStatuses).toHaveLength(2);

    // Empty message should NOT be visible
    expect(screen.queryByText('agent.console.badges_empty')).not.toBeInTheDocument();
  });

  it('should show fail badge status correctly', () => {
    mockState.badges = ['schema_fail', 'economy_ok'];

    render(<AgentConsole />);

    // Schema badge should show fail
    expect(screen.getByText('agent.console.badge.schema')).toBeInTheDocument();
    expect(screen.getByText('agent.console.badge.fail')).toBeInTheDocument();

    // Economy badge should show OK
    expect(screen.getByText('agent.console.badge.economy')).toBeInTheDocument();
    expect(screen.getByText('agent.console.badge.ok')).toBeInTheDocument();
  });

  it('should show streaming queue items when streaming', () => {
    mockState.isStreaming = true;
    mockState.phases = [
      { name: 'parse', status: 'completed' },
      { name: 'validate', status: 'in_progress' },
    ];

    render(<AgentConsole />);

    // Queue idle text should NOT be visible
    expect(screen.queryByText('agent.console.queue_idle')).not.toBeInTheDocument();

    // Phase items should be visible
    expect(screen.getByText('agent.console.phase.parse')).toBeInTheDocument();
    expect(screen.getByText('agent.console.phase.validate')).toBeInTheDocument();
  });
});
</file>

<file path="frontend/src/components/DndInteraction.test.tsx">
import React from 'react';
import { describe, it, expect, vi, beforeEach, afterEach } from 'vitest';
import { render, screen, act, fireEvent, waitFor } from '@testing-library/react';
import App from '../App';
import * as turnStream from '../api/turnStream';

// dnd-kit 모킹용 타입
interface MockDndCallbacks {
  onDragEnd: (event: {
    active: { id: string; data: { current: unknown } };
    over: { id: string; data: { current: unknown } } | null;
  }) => void;
}

// dnd-kit 모킹 (콜백 가로채기용)
vi.mock('@dnd-kit/core', async () => {
  const actual = (await vi.importActual('@dnd-kit/core')) as Record<string, unknown>;
  return {
    ...actual,
    DndContext: (props: MockDndCallbacks & { children: React.ReactNode }) => {
      // 콜백 저장 (테스트에서 접근 가능하도록 global에 저장)
      (global as unknown as Record<string, unknown>).dndCallbacks = props;
      return <div data-testid="mock-dnd-context">{props.children}</div>;
    },
  };
});

// i18next 모킹 (RU-003-Q5: 데모 i18n 키 지원)
vi.mock('react-i18next', () => ({
  useTranslation: () => ({
    t: (key: string, options?: Record<string, unknown>) => {
      // 데모 아이템 이름
      if (key === 'demo.items.keycard-alpha.name') return '키카드 A';
      if (key === 'demo.items.medkit.name') return '응급 키트';
      if (key === 'demo.items.flashlight.name') return '손전등';
      if (key === 'demo.items.data-chip.name') return '데이터칩';
      // 데모 씬 오브젝트
      if (key === 'demo.scene.terminal.label') return '터미널';
      if (key === 'demo.scene.terminal.hint') return '활성화된 터미널이다';
      if (key === 'demo.scene.door.label') return '문';
      if (key === 'demo.scene.door.hint') return '잠겨있는 것 같다';
      // 액션 템플릿
      if (key === 'inventory.item_label') return `Item: ${options?.name}`;
      if (key === 'scene.hotspot.drop_action') {
        return `Drop: ${options?.item} on ${options?.target}`;
      }
      if (key === 'scene.hotspot.drop_invalid') {
        return `Invalid: ${options?.item}`;
      }
      if (key === 'action_log.use_item_on_hotspot') {
        return `Action: Use ${options?.item} on ${options?.hotspot}`;
      }
      if (key === 'connection.online') return 'ONLINE';
      return key;
    },
    i18n: {
      changeLanguage: () => Promise.resolve(),
      resolvedLanguage: 'ko-KR',
    },
  }),
  initReactI18next: {
    type: '3rdParty',
    init: () => {},
  },
}));

// ResizeObserver 모킹
class MockResizeObserver {
  observe = vi.fn();
  unobserve = vi.fn();
  disconnect = vi.fn();
}
global.ResizeObserver = MockResizeObserver as unknown as typeof ResizeObserver;
window.ResizeObserver = MockResizeObserver as unknown as typeof ResizeObserver;

// api 모킹
vi.mock('../api/turnStream', () => ({
  startTurnStream: vi.fn(),
}));

describe('DnD Interaction - Logic Test', () => {
  beforeEach(() => {
    vi.clearAllMocks();
    localStorage.clear();

    // prefers-reduced-motion 모킹 (NarrativeFeed에서 사용)
    // true로 설정하여 타이핑 효과를 생략하고 즉시 텍스트가 표시되게 함
    Object.defineProperty(window, 'matchMedia', {
      writable: true,
      value: vi.fn().mockImplementation((query) => ({
        matches: query === '(prefers-reduced-motion: reduce)',
        media: query,
        onchange: null,
        addListener: vi.fn(),
        removeListener: vi.fn(),
        addEventListener: vi.fn(),
        removeEventListener: vi.fn(),
        dispatchEvent: vi.fn(),
      })),
    });
  });

  afterEach(() => {
    //
  });

  it('should trigger turn execution when handleDragEnd is called with a hotspot target', async () => {
    render(<App />);

    // 1. 프로필 선택 (Playing 페이즈 진입)
    const narratorProfile = screen.getByLabelText('profile.narrator.name');
    fireEvent.click(narratorProfile);

    // U-060: 프로필 선택 후 DndContext 마운트를 기다림
    // DndContext가 렌더링된 후 콜백 가져오기
    const dndCallbacks = await waitFor(() => {
      const callbacks = (global as unknown as Record<string, MockDndCallbacks>).dndCallbacks;
      expect(callbacks).toBeDefined();
      expect(callbacks.onDragEnd).toBeDefined();
      return callbacks;
    });

    // RU-003-Q1: 드래그 데이터에 item 객체 포함 (타입 가드 요구사항)
    const mockItem = {
      id: 'keycard-alpha',
      name: '키카드 A',
      icon: '🔑',
      quantity: 1,
    };

    // 성공 시나리오 시뮬레이션
    act(() => {
      dndCallbacks.onDragEnd({
        active: {
          id: 'keycard-alpha',
          data: {
            current: {
              type: 'inventory-item',
              item_id: 'keycard-alpha',
              item: mockItem,
            },
          },
        },
        over: {
          id: 'hotspot-demo-terminal',
          data: {
            current: {
              type: 'hotspot',
              object_id: 'demo-terminal',
              label: '터미널',
              box_2d: { ymin: 300, xmin: 100, ymax: 600, xmax: 400 },
            },
          },
        },
      });
    });

    // startTurnStream 호출 확인
    await waitFor(() => {
      expect(turnStream.startTurnStream).toHaveBeenCalled();
    });
    const [input] = vi.mocked(turnStream.startTurnStream).mock.calls[0];

    expect(input.text).toBe('Drop: 키카드 A on 터미널');
    expect(input.drop).toEqual({
      item_id: 'keycard-alpha',
      target_object_id: 'demo-terminal',
      target_box_2d: { ymin: 300, xmin: 100, ymax: 600, xmax: 400 },
    });

    // U-070: 드롭 즉시 NarrativeFeed에 액션 로그가 표시되어야 함
    const actionLog = await screen.findByText(/Action: Use 키카드 A on 터미널/);
    expect(actionLog).toBeInTheDocument();
    expect(actionLog.closest('.narrative-entry')).toHaveClass('action-log-entry');
  });

  it('should show failure feedback when handleDragEnd is called with an invalid target', async () => {
    render(<App />);

    // 1. 프로필 선택 (Playing 페이즈 진입)
    const narratorProfile = screen.getByLabelText('profile.narrator.name');
    fireEvent.click(narratorProfile);

    // U-060: 프로필 선택 후 DndContext 마운트를 기다림
    // DndContext가 렌더링된 후 콜백 가져오기
    const dndCallbacks = await waitFor(() => {
      const callbacks = (global as unknown as Record<string, MockDndCallbacks>).dndCallbacks;
      expect(callbacks).toBeDefined();
      expect(callbacks.onDragEnd).toBeDefined();
      return callbacks;
    });

    // RU-003-Q1: 드래그 데이터에 item 객체 포함 (타입 가드 요구사항)
    const mockItem = {
      id: 'keycard-alpha',
      name: '키카드 A',
      icon: '🔑',
      quantity: 1,
    };

    // 실패 시나리오 시뮬레이션 (over가 null)
    act(() => {
      dndCallbacks.onDragEnd({
        active: {
          id: 'keycard-alpha',
          data: {
            current: {
              type: 'inventory-item',
              item_id: 'keycard-alpha',
              item: mockItem,
            },
          },
        },
        over: null,
      });
    });

    // turn 실행은 발생하지 않아야 함
    expect(turnStream.startTurnStream).not.toHaveBeenCalled();

    // 내러티브 피드에 실패 메시지가 나타나야 함
    const failureMessage = await screen.findByText(/Invalid: 키카드 A/);
    expect(failureMessage).toBeInTheDocument();
  });
});
</file>

<file path="frontend/src/components/EconomyHud.test.tsx">
import { describe, it, expect, beforeEach, vi } from 'vitest';
import { render, screen } from '@testing-library/react';
import { EconomyHud } from './EconomyHud';
import { useWorldStore } from '../stores/worldStore';
import { useEconomyStore } from '../stores/economyStore';

// react-i18next 모킹
vi.mock('react-i18next', () => ({
  useTranslation: () => ({
    t: (key: string) => key,
  }),
  initReactI18next: {
    type: '3rdParty',
    init: () => {},
  },
}));

describe('EconomyHud', () => {
  beforeEach(() => {
    useWorldStore.getState().reset();
    useEconomyStore.getState().reset();
    useEconomyStore.getState().clearLedger();
  });

  it('현재 잔액을 올바르게 표시해야 한다', () => {
    useWorldStore.getState().setEconomy({ signal: 50, memory_shard: 5, credit: 0 });

    render(<EconomyHud />);

    expect(screen.getByTestId('signal-balance')).toHaveTextContent('50');
    expect(screen.getByTestId('shard-balance')).toHaveTextContent('5');
  });

  it('예상 비용이 있을 때 표시해야 한다', () => {
    useEconomyStore.getState().setCostEstimate({
      min: { signal: 5, memory_shard: 0 },
      max: { signal: 10, memory_shard: 0 },
      label: 'Test Action',
    });

    render(<EconomyHud />);

    expect(screen.getByText('economy.estimated_cost')).toBeInTheDocument();
    expect(screen.getByText('Test Action')).toBeInTheDocument();
    expect(screen.getByText('5~10')).toBeInTheDocument();
  });

  it('감당할 수 없는 예상 비용일 때 경고를 표시해야 한다', () => {
    useWorldStore.getState().setEconomy({ signal: 5, memory_shard: 0, credit: 0 });
    useEconomyStore.getState().setCostEstimate({
      min: { signal: 10, memory_shard: 0 },
      max: { signal: 15, memory_shard: 0 },
    });

    const { container } = render(<EconomyHud />);

    expect(screen.getByText('economy.insufficient_funds')).toBeInTheDocument();
    expect(container.querySelector('.cost-unaffordable')).toBeInTheDocument();
  });

  it('예상 비용이 없을 때 마지막 확정 비용을 표시해야 한다', () => {
    useEconomyStore.getState().setLastCost({
      turnId: 1,
      cost: { signal: 8, memory_shard: 1 },
      balanceAfter: { signal: 92, memory_shard: 4 },
      modelLabel: 'QUALITY',
    });

    render(<EconomyHud />);

    expect(screen.getByText('economy.confirmed_cost')).toBeInTheDocument();
    expect(screen.getByText('8')).toBeInTheDocument();
    expect(screen.getByText('1')).toBeInTheDocument();
    expect(screen.getByText('economy.model_label.QUALITY')).toBeInTheDocument();
  });

  it('잔액 부족 시 경고 및 대안을 표시해야 한다', () => {
    // 임계값 10, 현재 잔액 5
    useWorldStore.getState().setEconomy({ signal: 5, memory_shard: 0, credit: 0 });
    useEconomyStore.getState().updateBalanceLowStatus({ signal: 5, memory_shard: 0 });

    render(<EconomyHud />);

    expect(screen.getByText('economy.low_balance_warning')).toBeInTheDocument();
    expect(screen.getByText('economy.low_balance_title')).toBeInTheDocument();
    expect(screen.getByText('economy.fast_fallback_notice')).toBeInTheDocument();
    expect(screen.getByText('economy.hint_sell_items')).toBeInTheDocument();
  });

  it('크레딧이 있을 때 표시해야 한다', () => {
    useWorldStore.getState().setEconomy({ signal: 0, memory_shard: 5, credit: 10 });

    render(<EconomyHud />);

    expect(screen.getByText(/economy.credit/)).toBeInTheDocument();
    expect(screen.getByText('-10')).toBeInTheDocument();
  });

  it('compact 모드에서는 잔액만 표시해야 한다', () => {
    useEconomyStore.getState().setCostEstimate({
      min: { signal: 5, memory_shard: 0 },
      max: { signal: 10, memory_shard: 0 },
    });

    render(<EconomyHud compact />);

    // 잔액은 표시됨
    expect(screen.getByTestId('signal-balance')).toBeInTheDocument();
    // 예상 비용은 표시되지 않음
    expect(screen.queryByText('economy.estimated_cost')).not.toBeInTheDocument();
  });

  it('거래 장부 이력이 있을 때 표시해야 한다', () => {
    useEconomyStore.getState().addLedgerEntry({
      turnId: 1,
      reason: 'test reason',
      cost: { signal: 5, memory_shard: 0 },
      balanceAfter: { signal: 95, memory_shard: 5 },
      modelLabel: 'FAST',
    });

    render(<EconomyHud />);

    expect(screen.getByText('economy.ledger_title')).toBeInTheDocument();
    expect(screen.getByText('T1')).toBeInTheDocument();
    expect(screen.getByText('test reason')).toBeInTheDocument();
    expect(screen.getByText('-5')).toBeInTheDocument();
  });
});
</file>

<file path="frontend/src/components/ScannerSlot.test.tsx">
import { describe, it, expect, vi, beforeEach } from 'vitest';
import { render, screen, fireEvent, waitFor } from '@testing-library/react';
import { ScannerSlot } from './ScannerSlot';
import * as scannerApi from '../api/scanner';
import { useInventoryStore } from '../stores/inventoryStore';
import { useAgentStore } from '../stores/agentStore';

// i18next 모킹
vi.mock('react-i18next', () => ({
  useTranslation: () => ({
    t: (key: string, params?: Record<string, unknown>) => {
      if (key === 'scanner.detected_objects') return `${params?.count} objects detected`;
      if (key === 'scanner.item_candidates') return `${params?.count} item candidates`;
      if (key === 'scanner.add_to_inventory') return `Add ${params?.count} items to inventory`;
      return key;
    },
  }),
}));

// URL.createObjectURL 모킹
global.URL.createObjectURL = vi.fn(() => 'mock-url');
global.URL.revokeObjectURL = vi.fn();

describe('ScannerSlot Component', () => {
  const mockLanguage = 'ko-KR';

  const mockScanResponse: scannerApi.ScannerResponse = {
    success: true,
    status: 'completed',
    caption: 'A mysterious artifact found in the desert.',
    objects: [
      {
        label: 'Artifact',
        box_2d: { ymin: 100, xmin: 100, ymax: 200, xmax: 200 },
        confidence: 0.9,
      },
    ],
    item_candidates: [
      {
        id: 'item-1',
        label: 'Glowing Stone',
        description: 'A stone that glows in the dark',
        item_type: 'artifact',
      },
      {
        id: 'item-2',
        label: 'Ancient Script',
        description: 'Unreadable text on a fragment',
        item_type: 'document',
      },
    ],
    analysis_time_ms: 1200,
    language: 'ko-KR',
  };

  beforeEach(() => {
    vi.clearAllMocks();
    useInventoryStore.setState({ items: [] });
    useAgentStore.setState({ isStreaming: false });
  });

  it('renders dropzone in idle state', () => {
    render(<ScannerSlot language={mockLanguage} />);
    expect(screen.getByText('scanner.dropzone_text')).toBeInTheDocument();
    expect(screen.getByText('scanner.dropzone_hint')).toBeInTheDocument();
  });

  it('handles file drop and triggers scanImage', async () => {
    const scanImageSpy = vi.spyOn(scannerApi, 'scanImage').mockResolvedValue({
      success: true,
      data: mockScanResponse,
    });

    render(<ScannerSlot language={mockLanguage} />);

    const dropzone = screen.getByRole('button', { name: /scanner.dropzone_label/i });
    const file = new File(['mock content'], 'test.png', { type: 'image/png' });

    // 드롭 이벤트 시뮬레이션
    fireEvent.drop(dropzone, {
      dataTransfer: {
        files: [file],
      },
    });

    // 업로드/분석 상태 확인
    expect(screen.getByText(/scanner.(uploading|analyzing)/i)).toBeInTheDocument();

    // 결과 렌더링 대기
    await waitFor(() => {
      expect(screen.getByText('A mysterious artifact found in the desert.')).toBeInTheDocument();
    });

    expect(scanImageSpy).toHaveBeenCalledWith(file, mockLanguage);
    expect(screen.getByText('Glowing Stone')).toBeInTheDocument();
    expect(screen.getByText('Ancient Script')).toBeInTheDocument();
  });

  it('allows toggling candidate selection', async () => {
    vi.spyOn(scannerApi, 'scanImage').mockResolvedValue({
      success: true,
      data: mockScanResponse,
    });

    render(<ScannerSlot language={mockLanguage} />);

    const dropzone = screen.getByRole('button', { name: /scanner.dropzone_label/i });
    const file = new File(['mock content'], 'test.png', { type: 'image/png' });
    fireEvent.drop(dropzone, { dataTransfer: { files: [file] } });

    await waitFor(() => {
      expect(screen.getByText('Glowing Stone')).toBeInTheDocument();
    });

    // 기본적으로 모두 선택됨 (Option B: UX는 1단계 추가를 위해 기본 선택)
    const addButton = screen.getByText('Add 2 items to inventory');
    expect(addButton).not.toBeDisabled();

    // 하나 해제
    fireEvent.click(screen.getByText('Glowing Stone'));
    expect(screen.getByText('Add 1 items to inventory')).toBeInTheDocument();

    // 모두 해제
    fireEvent.click(screen.getByText('Ancient Script'));
    expect(screen.getByText('Add 0 items to inventory')).toBeInTheDocument();
    expect(screen.getByText('Add 0 items to inventory')).toBeDisabled();
  });

  it('adds selected items to inventoryStore and resets state', async () => {
    vi.spyOn(scannerApi, 'scanImage').mockResolvedValue({
      success: true,
      data: mockScanResponse,
    });
    const addItemsSpy = vi.spyOn(useInventoryStore.getState(), 'addItems');

    render(<ScannerSlot language={mockLanguage} />);

    const dropzone = screen.getByRole('button', { name: /scanner.dropzone_label/i });
    const file = new File(['mock content'], 'test.png', { type: 'image/png' });
    fireEvent.drop(dropzone, { dataTransfer: { files: [file] } });

    await waitFor(() => {
      expect(screen.getByText('Add 2 items to inventory')).toBeInTheDocument();
    });

    fireEvent.click(screen.getByText('Add 2 items to inventory'));

    expect(addItemsSpy).toHaveBeenCalledWith([
      expect.objectContaining({ id: 'item-1', name: 'Glowing Stone' }),
      expect.objectContaining({ id: 'item-2', name: 'Ancient Script' }),
    ]);

    // 상태 리셋 확인 (idle 상태로 복귀)
    expect(screen.getByText('scanner.dropzone_text')).toBeInTheDocument();
  });

  it('displays error message on scan failure', async () => {
    vi.spyOn(scannerApi, 'scanImage').mockResolvedValue({
      success: false,
      error: 'Analysis failed due to noise',
      status: 'failed',
    });

    render(<ScannerSlot language={mockLanguage} />);

    const dropzone = screen.getByRole('button', { name: /scanner.dropzone_label/i });
    const file = new File(['mock content'], 'test.png', { type: 'image/png' });
    fireEvent.drop(dropzone, { dataTransfer: { files: [file] } });

    await waitFor(() => {
      expect(screen.getByText('Analysis failed due to noise')).toBeInTheDocument();
    });

    expect(screen.getByText('scanner.retry')).toBeInTheDocument();
  });

  it('resets state when cancel is clicked', async () => {
    vi.spyOn(scannerApi, 'scanImage').mockResolvedValue({
      success: true,
      data: mockScanResponse,
    });

    render(<ScannerSlot language={mockLanguage} />);

    const dropzone = screen.getByRole('button', { name: /scanner.dropzone_label/i });
    const file = new File(['mock content'], 'test.png', { type: 'image/png' });
    fireEvent.drop(dropzone, { dataTransfer: { files: [file] } });

    await waitFor(() => {
      expect(screen.getByText('scanner.cancel')).toBeInTheDocument();
    });

    fireEvent.click(screen.getByText('scanner.cancel'));

    // 상태 리셋 확인
    expect(screen.getByText('scanner.dropzone_text')).toBeInTheDocument();
  });

  it('displays correct discovery message based on item count (U-095)', async () => {
    render(<ScannerSlot language={mockLanguage} />);

    // 1개 발견
    const singleResponse = {
      ...mockScanResponse,
      item_candidates: [mockScanResponse.item_candidates[0]],
    };
    vi.spyOn(scannerApi, 'scanImage').mockResolvedValueOnce({
      success: true,
      data: singleResponse,
    });

    let dropzone = screen.getByRole('button', { name: /scanner.dropzone_label/i });
    fireEvent.drop(dropzone, {
      dataTransfer: { files: [new File(['content'], 'test.png', { type: 'image/png' })] },
    });
    await waitFor(() =>
      expect(screen.getByText('scanner.discovery_message.one')).toBeInTheDocument(),
    );

    // 2개 발견
    fireEvent.click(screen.getByText('scanner.cancel'));
    vi.spyOn(scannerApi, 'scanImage').mockResolvedValueOnce({
      success: true,
      data: mockScanResponse,
    });
    dropzone = screen.getByRole('button', { name: /scanner.dropzone_label/i });
    fireEvent.drop(dropzone, {
      dataTransfer: { files: [new File(['content'], 'test.png', { type: 'image/png' })] },
    });
    await waitFor(() =>
      expect(screen.getByText('scanner.discovery_message.two')).toBeInTheDocument(),
    );

    // 3개 발견
    fireEvent.click(screen.getByText('scanner.cancel'));
    const tripleResponse = {
      ...mockScanResponse,
      item_candidates: [
        ...mockScanResponse.item_candidates,
        { id: 'item-3', label: 'Extra Item', description: 'Desc', item_type: 'tool' },
      ],
    };
    vi.spyOn(scannerApi, 'scanImage').mockResolvedValueOnce({
      success: true,
      data: tripleResponse,
    });
    dropzone = screen.getByRole('button', { name: /scanner.dropzone_label/i });
    fireEvent.drop(dropzone, {
      dataTransfer: { files: [new File(['content'], 'test.png', { type: 'image/png' })] },
    });
    await waitFor(() =>
      expect(screen.getByText('scanner.discovery_message.three')).toBeInTheDocument(),
    );
  });

  it('is disabled when isStreaming is true', () => {
    useAgentStore.setState({ isStreaming: true });
    render(<ScannerSlot language={mockLanguage} />);

    const dropzone = screen.getByRole('button', { name: /scanner.dropzone_label/i });
    expect(dropzone).toHaveClass('disabled');
  });

  describe('U-072 Scanner Semantic Guidance UX', () => {
    beforeEach(() => {
      localStorage.clear();
      vi.clearAllMocks();
    });

    it('shows tooltip on mouse enter in idle state', () => {
      render(<ScannerSlot language={mockLanguage} />);

      const container = screen.getByRole('button', {
        name: /scanner.dropzone_label/i,
      }).parentElement!;

      fireEvent.mouseEnter(container);
      expect(screen.getByText('scanner.tooltip.title')).toBeInTheDocument();
      expect(screen.getByText('scanner.tooltip.description')).toBeInTheDocument();

      fireEvent.mouseLeave(container);
      expect(screen.queryByText('scanner.tooltip.title')).not.toBeInTheDocument();
    });

    it('displays drag active affordance when dragging over', () => {
      render(<ScannerSlot language={mockLanguage} />);
      const dropzone = screen.getByRole('button', { name: /scanner.dropzone_label/i });

      fireEvent.dragOver(dropzone);
      expect(dropzone).toHaveClass('drag-over');
      expect(screen.getByText('scanner.affordance.drag_active')).toBeInTheDocument();
    });

    it('displays idle affordance hint in idle state', () => {
      render(<ScannerSlot language={mockLanguage} />);
      expect(screen.getByText('scanner.affordance.idle_hint')).toBeInTheDocument();
    });
  });
});
</file>

<file path="frontend/src/components/ScannerSlot.tsx">
/**
 * Unknown World - Scanner 슬롯 컴포넌트 (U-022[Mvp], U-072[Mvp]).
 *
 * 이미지 드랍/업로드 → 백엔드 분석 → 아이템 후보 표시 → 인벤토리 추가.
 *
 * 설계 원칙:
 *   - RULE-002: 채팅 UI 금지, 게임 UI로 표시
 *   - RULE-004: 실패 시 안전한 폴백 (에러 표시)
 *   - PRD 6.7: Scanner 슬롯 멀티모달 데모 핵심
 *
 * 페어링 질문 결정 (U-022):
 *   - Q1: Option B - 사용자 확인 후 인벤토리 추가 (의도 통제)
 *
 * 페어링 질문 결정 (U-072):
 *   - Q1: Option A - 백엔드(LLM)에서 scanner_hint 플래그 생성
 *
 * @module components/ScannerSlot
 */

import { useState, useCallback, useRef, type DragEvent, type ChangeEvent } from 'react';
import { useTranslation } from 'react-i18next';
import {
  scanImage,
  isSupportedImageFile,
  candidateToInventoryItem,
  type ScannerResponse,
  type ItemCandidate,
  ALLOWED_MIME_TYPES,
  MAX_FILE_SIZE_BYTES,
} from '../api/scanner';
import { useInventoryStore } from '../stores/inventoryStore';
import { useAgentStore } from '../stores/agentStore';
import type { Language } from '../schemas/turn';

// =============================================================================
// 타입 정의
// =============================================================================

/** Scanner 슬롯 상태 */
type ScannerState = 'idle' | 'uploading' | 'analyzing' | 'result' | 'error';

/** 컴포넌트 Props */
interface ScannerSlotProps {
  /** 세션 언어 (SSOT) */
  language: Language;
  /** 비활성화 여부 (스트리밍 중 등) */
  disabled?: boolean;
}

// =============================================================================
// 컴포넌트
// =============================================================================

/**
 * Scanner 슬롯 컴포넌트.
 *
 * 이미지를 드래그/업로드하면 백엔드 Scanner API를 호출하여
 * 아이템 후보를 추출하고, 사용자가 선택하여 인벤토리에 추가합니다.
 */
export function ScannerSlot({ language, disabled = false }: ScannerSlotProps) {
  const { t } = useTranslation();
  const { addItems } = useInventoryStore();
  const { isStreaming } = useAgentStore();

  // 상태
  const [state, setState] = useState<ScannerState>('idle');
  const [isDragOver, setIsDragOver] = useState(false);
  const [errorMessage, setErrorMessage] = useState<string | null>(null);
  const [scanResult, setScanResult] = useState<ScannerResponse | null>(null);
  const [selectedCandidates, setSelectedCandidates] = useState<Set<string>>(new Set());
  const [previewUrl, setPreviewUrl] = useState<string | null>(null);

  // 파일 입력 ref
  const fileInputRef = useRef<HTMLInputElement>(null);

  // 실제 비활성화 상태
  const isDisabled = disabled || isStreaming;

  const [showTooltip, setShowTooltip] = useState(false);

  // =========================================================================
  // 핸들러
  // =========================================================================

  /**
   * 파일 처리 (업로드 및 분석).
   */
  const handleFile = useCallback(
    async (file: File) => {
      if (isDisabled) return;

      // 파일 형식 검증
      if (!isSupportedImageFile(file)) {
        setErrorMessage(t('scanner.error.unsupported_format'));
        setState('error');
        return;
      }

      // 파일 크기 검증
      if (file.size > MAX_FILE_SIZE_BYTES) {
        setErrorMessage(t('scanner.error.file_too_large'));
        setState('error');
        return;
      }

      // 프리뷰 생성
      const preview = URL.createObjectURL(file);
      setPreviewUrl(preview);

      // 상태 초기화
      setErrorMessage(null);
      setScanResult(null);
      setSelectedCandidates(new Set());
      setState('uploading');

      try {
        setState('analyzing');
        const result = await scanImage(file, language);

        if (result.success) {
          setScanResult(result.data);
          // 기본적으로 모든 후보를 선택
          const allIds = new Set(result.data.item_candidates.map((c) => c.id));
          setSelectedCandidates(allIds);
          setState('result');
        } else {
          setErrorMessage(result.error);
          setState('error');
        }
      } catch {
        setErrorMessage(t('scanner.error.unknown'));
        setState('error');
      }
    },
    [isDisabled, language, t],
  );

  /**
   * 드래그 오버 핸들러.
   */
  const handleDragOver = useCallback(
    (e: DragEvent<HTMLDivElement>) => {
      e.preventDefault();
      e.stopPropagation();
      if (!isDisabled) {
        setIsDragOver(true);
      }
    },
    [isDisabled],
  );

  /**
   * 드래그 종료 핸들러.
   */
  const handleDragLeave = useCallback((e: DragEvent<HTMLDivElement>) => {
    e.preventDefault();
    e.stopPropagation();
    setIsDragOver(false);
  }, []);

  /**
   * 드롭 핸들러.
   */
  const handleDrop = useCallback(
    (e: DragEvent<HTMLDivElement>) => {
      e.preventDefault();
      e.stopPropagation();
      setIsDragOver(false);

      if (isDisabled) return;

      const files = e.dataTransfer.files;
      if (files.length > 0) {
        void handleFile(files[0]);
      }
    },
    [isDisabled, handleFile],
  );

  /**
   * 파일 선택 핸들러.
   */
  const handleFileChange = useCallback(
    (e: ChangeEvent<HTMLInputElement>) => {
      const files = e.target.files;
      if (files && files.length > 0) {
        void handleFile(files[0]);
      }
      // 입력 초기화 (같은 파일 재선택 허용)
      if (fileInputRef.current) {
        fileInputRef.current.value = '';
      }
    },
    [handleFile],
  );

  /**
   * 파일 선택 버튼 클릭.
   */
  const handleBrowseClick = useCallback(() => {
    if (!isDisabled && fileInputRef.current) {
      fileInputRef.current.click();
    }
  }, [isDisabled]);

  /**
   * 후보 선택 토글.
   */
  const handleCandidateToggle = useCallback((candidateId: string) => {
    setSelectedCandidates((prev) => {
      const next = new Set(prev);
      if (next.has(candidateId)) {
        next.delete(candidateId);
      } else {
        next.add(candidateId);
      }
      return next;
    });
  }, []);

  /**
   * 선택한 아이템을 인벤토리에 추가.
   * Q1 Option B: 사용자 확인 후 추가.
   */
  const handleAddToInventory = useCallback(() => {
    if (!scanResult || selectedCandidates.size === 0) return;

    const selectedItems = scanResult.item_candidates
      .filter((c) => selectedCandidates.has(c.id))
      .map(candidateToInventoryItem);

    addItems(selectedItems);

    // 상태 초기화
    setState('idle');
    setScanResult(null);
    setSelectedCandidates(new Set());
    if (previewUrl) {
      URL.revokeObjectURL(previewUrl);
      setPreviewUrl(null);
    }
  }, [scanResult, selectedCandidates, addItems, previewUrl]);

  /**
   * 취소/리셋.
   */
  const handleReset = useCallback(() => {
    setState('idle');
    setScanResult(null);
    setSelectedCandidates(new Set());
    setErrorMessage(null);
    if (previewUrl) {
      URL.revokeObjectURL(previewUrl);
      setPreviewUrl(null);
    }
  }, [previewUrl]);

  // =========================================================================
  // 렌더링
  // =========================================================================

  return (
    <div
      className="scanner-slot-container"
      onMouseEnter={() => setShowTooltip(true)}
      onMouseLeave={() => setShowTooltip(false)}
    >
      {/* 툴팁 (U-072) */}
      {showTooltip && state === 'idle' && (
        <div className="scanner-tooltip" role="tooltip">
          <div className="scanner-tooltip-title">{t('scanner.tooltip.title')}</div>
          <div className="scanner-tooltip-desc">{t('scanner.tooltip.description')}</div>
        </div>
      )}

      {/* 숨겨진 파일 입력 */}
      <input
        ref={fileInputRef}
        type="file"
        accept={ALLOWED_MIME_TYPES.join(',')}
        onChange={handleFileChange}
        className="visually-hidden"
        aria-label={t('scanner.upload_label')}
      />

      {/* 상태별 렌더링 */}
      {state === 'idle' && (
        <div
          className={`scanner-dropzone ${isDragOver ? 'drag-over' : ''} ${isDisabled ? 'disabled' : ''}`}
          onDragOver={handleDragOver}
          onDragLeave={handleDragLeave}
          onDrop={handleDrop}
          onClick={handleBrowseClick}
          role="button"
          tabIndex={isDisabled ? -1 : 0}
          aria-label={t('scanner.dropzone_label')}
          onKeyDown={(e) => {
            if (e.key === 'Enter' || e.key === ' ') {
              e.preventDefault();
              handleBrowseClick();
            }
          }}
        >
          <div className="scanner-dropzone-icon">📷</div>
          <div className="scanner-dropzone-text">
            {isDragOver ? t('scanner.affordance.drag_active') : t('scanner.dropzone_text')}
          </div>
          <div className={`scanner-dropzone-hint ${isDragOver ? 'hidden' : ''}`}>
            {t('scanner.dropzone_hint')}
          </div>
          {/* 시각적 어포던스: idle 힌트 (U-072) - 항상 렌더링하여 레이아웃 시프트 방지 */}
          <div
            className={`scanner-affordance-hint ${isDragOver || isDisabled ? 'hidden' : ''}`}
            aria-hidden={isDragOver || isDisabled}
          >
            {t('scanner.affordance.idle_hint')}
          </div>
        </div>
      )}

      {(state === 'uploading' || state === 'analyzing') && (
        <div className="scanner-loading">
          {previewUrl && (
            <div className="scanner-preview">
              <img
                src={previewUrl}
                alt={t('scanner.preview_alt')}
                className="scanner-preview-img"
              />
            </div>
          )}
          <div className="scanner-loading-content">
            <div className="scanner-loading-spinner" />
            <div className="scanner-loading-text">
              {state === 'uploading' ? t('scanner.uploading') : t('scanner.analyzing')}
            </div>
          </div>
        </div>
      )}

      {state === 'error' && (
        <div className="scanner-error">
          {previewUrl && (
            <div className="scanner-preview">
              <img
                src={previewUrl}
                alt={t('scanner.preview_alt')}
                className="scanner-preview-img"
              />
            </div>
          )}
          <div className="scanner-error-content">
            <div className="scanner-error-icon">⚠️</div>
            <div className="scanner-error-message">{errorMessage}</div>
            <button type="button" className="scanner-btn scanner-btn-retry" onClick={handleReset}>
              {t('scanner.retry')}
            </button>
          </div>
        </div>
      )}

      {state === 'result' && scanResult && (
        <div className="scanner-result">
          {/* U-095: 다수 아이템 발견 피드백 메시지 */}
          <div className="scanner-discovery-message" role="status">
            {getDiscoveryMessage(scanResult.item_candidates.length, t)}
          </div>

          {/* 프리뷰 + 캡션 */}
          <div className="scanner-result-header">
            {previewUrl && (
              <div className="scanner-preview-small">
                <img
                  src={previewUrl}
                  alt={t('scanner.preview_alt')}
                  className="scanner-preview-img-small"
                />
              </div>
            )}
            <div className="scanner-result-info">
              <div className="scanner-caption">{scanResult.caption}</div>
              <div className="scanner-stats">
                {t('scanner.detected_objects', { count: scanResult.objects.length })} •{' '}
                {t('scanner.item_candidates', { count: scanResult.item_candidates.length })}
              </div>
            </div>
          </div>

          {/* 아이템 후보 목록 */}
          {scanResult.item_candidates.length > 0 ? (
            <div className="scanner-candidates">
              <div className="scanner-candidates-title">{t('scanner.select_items')}</div>
              <div className="scanner-candidates-list">
                {scanResult.item_candidates.map((candidate) => (
                  <CandidateItem
                    key={candidate.id}
                    candidate={candidate}
                    selected={selectedCandidates.has(candidate.id)}
                    onToggle={() => handleCandidateToggle(candidate.id)}
                  />
                ))}
              </div>
            </div>
          ) : (
            <div className="scanner-no-candidates">{t('scanner.no_candidates')}</div>
          )}

          {/* 액션 버튼 */}
          <div className="scanner-actions">
            <button type="button" className="scanner-btn scanner-btn-cancel" onClick={handleReset}>
              {t('scanner.cancel')}
            </button>
            <button
              type="button"
              className="scanner-btn scanner-btn-add"
              onClick={handleAddToInventory}
              disabled={selectedCandidates.size === 0}
            >
              {t('scanner.add_to_inventory', { count: selectedCandidates.size })}
            </button>
          </div>
        </div>
      )}
    </div>
  );
}

// =============================================================================
// 서브 컴포넌트
// =============================================================================

interface CandidateItemProps {
  candidate: ItemCandidate;
  selected: boolean;
  onToggle: () => void;
}

/**
 * 아이템 후보 컴포넌트.
 */
function CandidateItem({ candidate, selected, onToggle }: CandidateItemProps) {
  const { t } = useTranslation();

  // 아이템 타입에 따른 이모지
  const emoji = getItemTypeEmoji(candidate.item_type);

  return (
    <button
      type="button"
      className={`scanner-candidate ${selected ? 'selected' : ''}`}
      onClick={onToggle}
      aria-pressed={selected}
    >
      <span className="scanner-candidate-checkbox">{selected ? '☑' : '☐'}</span>
      <span className="scanner-candidate-icon">{emoji}</span>
      <span className="scanner-candidate-info">
        <span className="scanner-candidate-name">{candidate.label}</span>
        {candidate.description && (
          <span className="scanner-candidate-desc">{candidate.description}</span>
        )}
        <span className="scanner-candidate-type">
          {t(`scanner.item_type.${candidate.item_type}`, { defaultValue: candidate.item_type })}
        </span>
      </span>
    </button>
  );
}

// =============================================================================
// 유틸리티
// =============================================================================

function getItemTypeEmoji(itemType: string): string {
  const emojiMap: Record<string, string> = {
    key: '🔑',
    weapon: '⚔️',
    tool: '🔧',
    clue: '🔍',
    material: '📦',
    consumable: '💊',
    document: '📄',
    artifact: '💎',
  };
  return emojiMap[itemType] ?? '📦';
}

/**
 * 아이템 발견 개수에 따른 피드백 메시지 (U-095).
 *
 * @param count - 발견된 아이템 수
 * @param t - i18n 번역 함수
 * @returns 피드백 메시지
 */
function getDiscoveryMessage(count: number, t: (key: string) => string): string {
  if (count >= 3) return t('scanner.discovery_message.three');
  if (count === 2) return t('scanner.discovery_message.two');
  return t('scanner.discovery_message.one');
}
</file>

<file path="frontend/src/save/constants.ts">
/**
 * Unknown World - 세션/경제 관련 상수 SSOT (U-116[Mvp]).
 *
 * U-116: SaveGame 시스템 제거 후 정리.
 * - SaveGame 버전/마이그레이션 관련 상수 제거
 * - 언어 설정 영속화용 키 추가
 * - 경제/판매 정책 상수 유지
 *
 * @module save/constants
 */

// =============================================================================
// localStorage 키 (Storage Keys)
// =============================================================================

/**
 * 언어 설정 저장 키 (U-116: Q1 Option B).
 *
 * SaveGame 제거 후에도 언어 설정만은 유지합니다.
 * 프로필 선택 시 이전 언어로 시작할 수 있습니다.
 */
export const LANGUAGE_STORAGE_KEY = 'unknown_world_language' as const;

// =============================================================================
// Legacy localStorage 키 (부팅 시 정리 대상)
// =============================================================================

/**
 * 레거시 SaveGame 저장 키.
 * U-116에서 SaveGame 제거 후, 기존 사용자 브라우저에 남아있는 데이터를 정리할 때 사용합니다.
 */
export const LEGACY_SAVEGAME_STORAGE_KEY = 'unknown_world_savegame' as const;

/**
 * 레거시 프로필 ID 저장 키.
 * U-116에서 SaveGame 제거 후, 기존 사용자 브라우저에 남아있는 데이터를 정리할 때 사용합니다.
 */
export const LEGACY_PROFILE_STORAGE_KEY = 'unknown_world_current_profile' as const;

// =============================================================================
// Seed 생성 정책
// =============================================================================

/**
 * 데모 seed 접두사.
 *
 * 데모 프로필에서 생성되는 seed의 접두사입니다.
 * seed 형식: `{DEMO_SEED_PREFIX}-{profileId}-{timestamp}`
 *
 * @example 'demo-narrator-1706000000000'
 */
export const DEMO_SEED_PREFIX = 'demo' as const;

/**
 * Seed를 생성합니다.
 *
 * 현재 정책(now 기반)에 따라 seed 문자열을 생성합니다.
 *
 * @param profileId - 프로필 ID
 * @returns seed 문자열
 */
export function generateDemoSeed(profileId: string): string {
  const now = Date.now();
  return `${DEMO_SEED_PREFIX}-${profileId}-${now}`;
}

// =============================================================================
// Economy 정책 상수
// =============================================================================

/**
 * 잔액 부족 경고 임계값 (Signal 기준).
 *
 * Signal 잔액이 이 값 미만이면 isBalanceLow가 true가 됩니다.
 * HUD에서 경고 표시 및 대체 행동 제안에 사용됩니다.
 *
 * @see economyStore.ts#updateBalanceLowStatus
 */
export const LOW_BALANCE_THRESHOLD = 10 as const;

/**
 * 거래 장부(Ledger) 최대 보관 개수.
 * 최근 N개의 턴 거래 장부만 보관합니다 (메모리 최적화).
 * @see economyStore.ts#addLedgerEntry
 */
export const LEDGER_MAX_ENTRIES = 20 as const;

// =============================================================================
// U-079: 아이템 판매 정책
// =============================================================================

/**
 * 아이템 판매 기본 가격 (Signal).
 *
 * MVP에서는 모든 아이템의 판매 가격이 고정입니다.
 * 향후 아이템별 가격 차등화가 가능합니다.
 *
 * @see InventoryPanel.tsx - 판매 버튼
 */
export const ITEM_SELL_PRICE_SIGNAL = 5 as const;

// =============================================================================
// 초기값 정책 (Placeholder vs 주입)
// =============================================================================

/**
 * World/Economy 초기값 정책 (문서화용 주석).
 *
 * Store의 createInitialState()에서 정의하는 economy 등의 값은
 * **"플레이 전 placeholder"**로 취급합니다.
 *
 * 실제 게임 시작 값은 항상 startSessionFromProfile()에서 주입됩니다.
 *
 * @see worldStore.ts#createInitialState
 * @see sessionLifecycle.ts
 */
export const INITIAL_VALUE_POLICY = {
  description: 'Placeholder values for pre-play state',
  worldEconomy: {
    signal: 100,
    memory_shard: 5,
  },
} as const;

// =============================================================================
// 데모 프로필 기본 재화 범위 (참고용)
// =============================================================================

/**
 * 데모 프로필 재화 범위 참고 (문서화용).
 *
 * 각 프로필의 초기 재화는 demoProfiles.ts에서 직접 정의합니다.
 * 이 상수는 "정책 범위"를 문서화하기 위한 참고용입니다.
 *
 * - Narrator: 풍부한 재화 (다양한 선택지 탐색)
 * - Explorer: 적당한 재화 (균형 잡힌 플레이)
 * - Tech: 제한된 재화 (효율적 전략 필요)
 *
 * @see demoProfiles.ts
 */
export const DEMO_PROFILE_ECONOMY_REFERENCE = {
  narrator: { signal: 200, memory_shard: 10 },
  explorer: { signal: 150, memory_shard: 5 },
  tech: { signal: 80, memory_shard: 15 },
} as const;
</file>

<file path="frontend/src/save/sessionLifecycle.test.ts">
import { describe, it, expect, beforeEach } from 'vitest';
import { startSessionFromProfile, resetToCurrentProfile } from './sessionLifecycle';
import { useEconomyStore } from '../stores/economyStore';
import { useWorldStore } from '../stores/worldStore';
import { findProfileById } from '../data/demoProfiles';

describe('sessionLifecycle (U-099)', () => {
  beforeEach(() => {
    useEconomyStore.getState().reset();
    useWorldStore.getState().reset();
  });

  it('새 세션 시작 시 이전 거래 장부가 초기화되어야 한다', () => {
    const { addLedgerEntry } = useEconomyStore.getState();

    // 1. 이전 세션의 데이터가 있다고 가정
    addLedgerEntry({
      turnId: 10,
      reason: 'Old session entry',
      cost: { signal: 10, memory_shard: 0 },
      balanceAfter: { signal: 90, memory_shard: 5 },
    });

    expect(useEconomyStore.getState().ledger.length).toBe(1);

    // 2. 새 세션 시작 (startSessionFromProfile 호출)
    const profile = findProfileById('narrator')!;
    const t = (key: string) => key;

    startSessionFromProfile({ profile, t });

    // 3. 거래 장부가 비워졌는지 확인
    expect(useEconomyStore.getState().ledger.length).toBe(0);
  });

  it('리셋 시 이전 거래 장부가 초기화되어야 한다', () => {
    const { addLedgerEntry } = useEconomyStore.getState();

    // 1. 데이터 추가
    addLedgerEntry({
      turnId: 1,
      reason: 'Current session entry',
      cost: { signal: 10, memory_shard: 0 },
      balanceAfter: { signal: 90, memory_shard: 5 },
    });

    expect(useEconomyStore.getState().ledger.length).toBe(1);

    // 2. 리셋 실행
    const t = (key: string) => key;
    resetToCurrentProfile({ t, currentProfileId: 'narrator' });

    // 3. 거래 장부가 비워졌는지 확인
    expect(useEconomyStore.getState().ledger.length).toBe(0);
  });

  it('U-124: 세션 시작 시 프로필의 초기 이미지가 worldStore에 적용되어야 한다', () => {
    const profile = findProfileById('narrator')!;
    const t = (key: string) => key;

    // 초기 이미지가 있는지 확인
    expect(profile.initialState.initialSceneImageUrl).toBeDefined();

    startSessionFromProfile({ profile, t });

    const sceneState = useWorldStore.getState().sceneState;
    expect(sceneState.status).toBe('scene');
    expect(sceneState.imageUrl).toBe(profile.initialState.initialSceneImageUrl);
    expect(sceneState.processingPhase).toBe('idle');
  });
});
</file>

<file path="frontend/src/save/sessionLifecycle.ts">
/**
 * Unknown World - 세션 라이프사이클 관리 모듈 (U-116[Mvp]).
 *
 * U-116: SaveGame 제거 후 단순화된 세션 관리.
 * 새로고침 시 항상 프로필 선택 화면으로 복귀합니다.
 *
 * 설계 원칙:
 *   - RULE-005: Economy 인바리언트 (잔액 음수 금지)
 *   - RULE-006: ko/en i18n 정책 준수 (언어 적용 후 UI 렌더링)
 *   - U-116: SaveGame 없이 store 직접 주입
 *   - U-116-Q1 Option B: 언어 설정만 LocalStorage에 유지
 *   - U-116-Q2 Option A: SaveGame 코드 완전 삭제
 *
 * @module save/sessionLifecycle
 */

import { clearLegacySaveData } from './saveGame';
import { LANGUAGE_STORAGE_KEY } from './constants';
import { findProfileById, type DemoProfile } from '../data/demoProfiles';
import {
  getResolvedLanguage,
  changeLanguage,
  type SupportedLanguage,
  DEFAULT_LANGUAGE,
} from '../i18n';
import { useWorldStore } from '../stores/worldStore';
import { useInventoryStore } from '../stores/inventoryStore';
import { useEconomyStore } from '../stores/economyStore';
import { useActionDeckStore } from '../stores/actionDeckStore';
import { useAgentStore } from '../stores/agentStore';
// U-092: 프리셋 아이콘 레지스트리
import { getPresetIconUrl } from '../data/itemIconPresets';

// =============================================================================
// 타입 정의
// =============================================================================

/**
 * 부팅 결과 타입.
 * U-116: 항상 profile_select로 시작합니다.
 */
export type SessionBootstrap = { phase: 'profile_select' };

/**
 * 세션 시작 결과 타입.
 */
export interface SessionStartResult {
  success: true;
  profileId: string;
}

/**
 * 세션 리셋 결과 타입.
 */
export interface SessionResetResult {
  success: boolean;
  profileId: string | null;
}

// =============================================================================
// 내부 헬퍼: 모든 세션 관련 store를 초기화
// =============================================================================

/**
 * 모든 세션 관련 store를 초기화합니다.
 *
 * 세션 경계에서 항상 이 함수를 호출하여 이전 세션 잔재를 완전히 제거합니다.
 */
function resetAllSessionStores(): void {
  useWorldStore.getState().reset();
  useInventoryStore.getState().reset();
  useEconomyStore.getState().reset();
  useActionDeckStore.getState().reset();
  useAgentStore.getState().reset();
}

// =============================================================================
// 세션 라이프사이클 API
// =============================================================================

/**
 * 부팅 시 세션 상태를 확인하고 시작 phase를 결정합니다.
 *
 * U-116: 항상 profile_select로 시작합니다.
 * 기존 LocalStorage의 레거시 SaveGame 데이터를 정리합니다.
 *
 * @returns SessionBootstrap - 항상 { phase: 'profile_select' }
 */
export function bootstrapSession(): SessionBootstrap {
  // U-116: 기존 SaveGame 레거시 데이터 정리 (1회)
  clearLegacySaveData();

  return { phase: 'profile_select' };
}

/**
 * 프로필을 선택하고 새 세션을 시작합니다.
 *
 * U-116: SaveGame 없이 프로필 데이터를 store에 직접 적용합니다.
 *
 * @param args.profile - 선택한 데모 프로필
 * @param args.t - i18n 번역 함수
 * @param args.language - 세션 언어 (명시적 전달로 SSOT 유지)
 * @returns 세션 시작 결과
 */
export function startSessionFromProfile(args: {
  profile: DemoProfile;
  t: (key: string) => string;
  language?: SupportedLanguage;
}): SessionStartResult {
  const { profile, t, language: explicitLanguage } = args;

  // U-044: 명시적 언어가 있으면 사용, 없으면 i18n 현재 값 사용
  const language = explicitLanguage ?? getResolvedLanguage();

  // 모든 세션 store 초기화 (이전 세션 잔재 제거)
  resetAllSessionStores();

  // U-116: 프로필 데이터를 store에 직접 적용 (SaveGame 중간 단계 제거)
  const now = Date.now();

  useWorldStore.setState({
    economy: {
      signal: profile.initialState.economy.signal,
      memory_shard: profile.initialState.economy.memory_shard,
      credit: profile.initialState.economy.credit,
    },
    turnCount: 0,
    narrativeEntries: [
      {
        turn: 0,
        text: t(profile.initialState.welcomeMessageKey),
        type: 'narrative' as const,
      },
    ],
    // U-078: 목표 시스템 강화
    quests: profile.initialState.questDefs.map((quest) => ({
      id: quest.id,
      label: t(quest.labelKey),
      is_completed: quest.is_completed,
      description: quest.descriptionKey ? t(quest.descriptionKey) : null,
      is_main: quest.is_main ?? false,
      progress: quest.progress ?? 0,
      reward_signal: quest.reward_signal ?? 0,
    })),
    activeRules: profile.initialState.ruleDefs.map((rule) => ({
      id: rule.id,
      label: t(rule.labelKey),
      description: rule.descriptionKey ? t(rule.descriptionKey) : null,
    })),
    mutationTimeline: profile.initialState.ruleDefs.map((rule, index) => ({
      turn: 0,
      ruleId: rule.id,
      type: 'added' as const,
      label: t(rule.labelKey),
      description: rule.descriptionKey ? t(rule.descriptionKey) : undefined,
      timestamp: now - index * 1000,
    })),
    // U-116: sceneObjectDefs에서 변환 (5단계에서 빈 배열로 변경됨)
    sceneObjects: profile.initialState.sceneObjectDefs.map((obj) => ({
      id: obj.id,
      label: t(obj.labelKey),
      box_2d: obj.box_2d,
      interaction_hint: t(obj.hintKey),
    })),
    // U-124: 사전 생성 첫 씬 이미지가 있으면 Scene Canvas에 즉시 적용
    // 주의: Zustand setState는 shallow merge이므로 sceneState 전체를 교체함
    // → processingPhase/imageLoading 등 필수 필드를 반드시 포함해야 입력 잠금이 풀림
    sceneState: profile.initialState.initialSceneImageUrl
      ? {
          status: 'scene' as const,
          imageUrl: profile.initialState.initialSceneImageUrl,
          message: '',
          processingPhase: 'idle' as const,
          imageLoading: false,
          previousImageUrl: undefined,
          pendingImageTurnId: undefined,
        }
      : {
          status: 'default' as const,
          message: '',
          imageUrl: undefined,
          processingPhase: 'idle' as const,
          imageLoading: false,
          previousImageUrl: undefined,
          pendingImageTurnId: undefined,
        },
  });

  // U-092: 프리셋 아이콘이 있으면 즉시 적용
  useInventoryStore.getState().setItems(
    profile.initialState.inventoryDefs.map((item) => ({
      id: item.id,
      name: t(item.nameKey),
      icon: getPresetIconUrl(item.id) ?? item.icon,
      quantity: item.quantity,
    })),
  );

  // 언어 설정 저장 (Q1 Option B: 언어만 유지)
  try {
    localStorage.setItem(LANGUAGE_STORAGE_KEY, language);
  } catch {
    // 시크릿 모드 등에서 실패 가능 - 무시
  }

  return {
    success: true,
    profileId: profile.id,
  };
}

/**
 * 현재 프로필의 초기 상태로 리셋합니다.
 *
 * U-116: 동일 프로필로 새 세션을 시작합니다.
 *
 * @param args.t - i18n 번역 함수
 * @param args.currentProfileId - 현재 프로필 ID
 * @returns 리셋 성공 여부
 */
export function resetToCurrentProfile(args: {
  t: (key: string) => string;
  currentProfileId: string | null;
}): SessionResetResult {
  const { t, currentProfileId } = args;

  if (!currentProfileId) {
    return { success: false, profileId: null };
  }

  const profile = findProfileById(currentProfileId);
  if (!profile) {
    return { success: false, profileId: null };
  }

  // 동일 프로필로 새 세션 시작
  const result = startSessionFromProfile({ profile, t });

  return {
    success: result.success,
    profileId: result.profileId,
  };
}

/**
 * 세션을 종료하고 프로필 선택 화면으로 돌아갑니다.
 *
 * U-116: 모든 세션 store를 초기화합니다 (LocalStorage 조작 없음).
 */
export function clearSessionAndReturnToSelect(): void {
  // 모든 세션 store 초기화
  resetAllSessionStores();
}

// =============================================================================
// U-044 + U-116: 세션 언어 SSOT API
// =============================================================================

/**
 * 현재 세션 언어를 반환합니다 (SSOT).
 *
 * U-116: SaveGame 없이 i18n의 현재 언어를 직접 사용합니다.
 *
 * @returns 현재 세션 언어 (ko-KR | en-US)
 */
export function getSessionLanguage(): SupportedLanguage {
  return getResolvedLanguage();
}

/**
 * 세션 언어를 변경합니다.
 *
 * U-044: 언어 변경은 세션 경계에서만 허용 (토글=리셋 정책).
 * U-116-Q1 Option B: 언어 설정을 LocalStorage에 유지합니다.
 *
 * @param language - 변경할 언어
 */
export async function setSessionLanguage(language: SupportedLanguage): Promise<void> {
  await changeLanguage(language);
  // Q1 Option B: 언어 설정만 LocalStorage에 유지
  try {
    localStorage.setItem(LANGUAGE_STORAGE_KEY, language);
  } catch {
    // 시크릿 모드 등에서 실패 가능 - 무시
  }
}

/**
 * 초기 세션 언어를 결정합니다.
 *
 * U-116-Q1 Option B: LocalStorage에서 이전 언어 설정을 읽습니다.
 * 없으면 DEFAULT_LANGUAGE를 반환합니다.
 *
 * @returns 초기 세션 언어
 */
export function getInitialSessionLanguage(): SupportedLanguage {
  try {
    const stored = localStorage.getItem(LANGUAGE_STORAGE_KEY);
    if (stored === 'ko-KR' || stored === 'en-US') {
      return stored;
    }
  } catch {
    // localStorage 접근 불가 환경 - 무시
  }
  return DEFAULT_LANGUAGE;
}
</file>

<file path="frontend/src/stores/agentStore.test.ts">
import { describe, it, expect, beforeEach } from 'vitest';
import { useAgentStore } from './agentStore';
import { StreamEventType, StageStatus } from '../api/turnStream';
import type { TurnOutput } from '../schemas/turn';

describe('agentStore', () => {
  beforeEach(() => {
    useAgentStore.getState().reset();
  });

  it('should have correct initial state', () => {
    const state = useAgentStore.getState();
    expect(state.isStreaming).toBe(false);
    expect(state.phases).toHaveLength(7);
    expect(state.phases[0].status).toBe('pending');
    expect(state.badges).toEqual([]);
    expect(state.repairCount).toBe(0);
  });

  it('should handle startStream', () => {
    useAgentStore.getState().startStream();
    const state = useAgentStore.getState();
    expect(state.isStreaming).toBe(true);
  });

  it('should handle handleStage events', () => {
    const store = useAgentStore.getState();

    // Start parse phase
    store.handleStage({
      type: StreamEventType.STAGE,
      name: 'parse',
      status: StageStatus.START,
    });

    let state = useAgentStore.getState();
    expect(state.currentPhase).toBe('parse');
    expect(state.phases.find((p) => p.name === 'parse')?.status).toBe('in_progress');

    // Complete parse phase
    store.handleStage({
      type: StreamEventType.STAGE,
      name: 'parse',
      status: StageStatus.COMPLETE,
    });

    state = useAgentStore.getState();
    expect(state.phases.find((p) => p.name === 'parse')?.status).toBe('completed');
  });

  it('should handle handleBadges events', () => {
    const store = useAgentStore.getState();
    store.handleBadges({
      type: StreamEventType.BADGES,
      badges: ['schema_ok', 'economy_ok'],
    });

    const state = useAgentStore.getState();
    expect(state.badges).toEqual(['schema_ok', 'economy_ok']);
  });

  it('should handle handleNarrativeDelta events', () => {
    const store = useAgentStore.getState();
    store.handleNarrativeDelta({
      type: StreamEventType.NARRATIVE_DELTA,
      text: 'Hello ',
    });
    store.handleNarrativeDelta({
      type: StreamEventType.NARRATIVE_DELTA,
      text: 'World',
    });

    const state = useAgentStore.getState();
    expect(state.narrativeBuffer).toBe('Hello World');
  });

  it('should handle handleFinal events', () => {
    const store = useAgentStore.getState();
    const mockOutput = {
      language: 'ko-KR',
      narrative: 'Final message',
      economy: {
        cost: { signal: 0, memory_shard: 0 },
        balance_after: { signal: 100, memory_shard: 0 },
        credit: 0,
        low_balance_warning: false,
      },
      safety: { blocked: false, message: null },
      ui: { action_deck: { cards: [] }, objects: [], scene: { image_url: null, alt_text: null } },
      world: {
        rules_changed: [],
        inventory_added: [],
        inventory_removed: [],
        quests_updated: [],
        relationships_changed: [],
        memory_pins: [],
      },
      render: {
        image_job: null,
        image_url: null,
        image_id: null,
        generation_time_ms: null,
      },
      agent_console: {
        repair_count: 2,
        current_phase: 'commit',
        badges: [],
        model_label: 'FAST',
      },
    } as TurnOutput;

    store.handleFinal({
      type: StreamEventType.FINAL,
      data: mockOutput,
    });

    const state = useAgentStore.getState();
    expect(state.finalOutput).toEqual(mockOutput);
    expect(state.repairCount).toBe(2);
  });

  it('should handle handleError events', () => {
    const store = useAgentStore.getState();
    store.handleError({
      type: StreamEventType.ERROR,
      message: 'Network error',
      code: 'ERR_NET',
    });

    const state = useAgentStore.getState();
    expect(state.error).toEqual({
      message: 'Network error',
      code: 'ERR_NET',
    });
  });

  it('should reset state on completeStream', () => {
    const store = useAgentStore.getState();
    store.handleNarrativeDelta({ type: StreamEventType.NARRATIVE_DELTA, text: 'Some text' });
    store.startStream();

    store.completeStream();

    const state = useAgentStore.getState();
    expect(state.isStreaming).toBe(false);
    expect(state.narrativeBuffer).toBe('');
  });
});
</file>

<file path="frontend/src/stores/inventoryStore.test.ts">
import { describe, it, expect, beforeEach } from 'vitest';
import { useInventoryStore, parseInventoryAdded } from './inventoryStore';

describe('inventoryStore', () => {
  beforeEach(() => {
    useInventoryStore.getState().reset();
  });

  it('초기 상태는 비어 있어야 한다', () => {
    const state = useInventoryStore.getState();
    expect(state.items).toEqual([]);
    expect(state.draggingItemId).toBeNull();
    expect(state.selectedItemId).toBeNull();
  });

  it('addItems: 새 아이템을 추가할 수 있어야 한다', () => {
    const { addItems } = useInventoryStore.getState();
    const newItem = { id: 'item1', name: 'Item 1', quantity: 1 };

    addItems([newItem]);

    const state = useInventoryStore.getState();
    expect(state.items).toHaveLength(1);
    expect(state.items[0]).toEqual(newItem);
  });

  it('addItems: 중복된 ID의 아이템 추가 시 수량이 증가해야 한다', () => {
    const { addItems } = useInventoryStore.getState();
    const item1 = { id: 'item1', name: 'Item 1', quantity: 1 };

    addItems([item1]);
    addItems([{ id: 'item1', name: 'Item 1', quantity: 2 }]);

    const state = useInventoryStore.getState();
    expect(state.items).toHaveLength(1);
    expect(state.items[0].quantity).toBe(3);
  });

  it('removeItems: 아이템을 제거할 수 있어야 한다', () => {
    const { addItems, removeItems } = useInventoryStore.getState();
    addItems([
      { id: 'item1', name: 'Item 1', quantity: 1 },
      { id: 'item2', name: 'Item 2', quantity: 1 },
    ]);

    removeItems(['item1']);

    const state = useInventoryStore.getState();
    expect(state.items).toHaveLength(1);
    expect(state.items[0].id).toBe('item2');
  });

  it('removeItems: 제거된 아이템이 선택/드래그 중이면 초기화해야 한다', () => {
    const { addItems, removeItems, selectItem, startDrag } = useInventoryStore.getState();
    addItems([{ id: 'item1', name: 'Item 1', quantity: 1 }]);

    selectItem('item1');
    startDrag('item1');

    removeItems(['item1']);

    const state = useInventoryStore.getState();
    expect(state.selectedItemId).toBeNull();
    expect(state.draggingItemId).toBeNull();
  });

  it('startDrag/endDrag: 드래그 상태를 관리해야 한다', () => {
    const { startDrag, endDrag } = useInventoryStore.getState();

    startDrag('item1');
    expect(useInventoryStore.getState().draggingItemId).toBe('item1');

    endDrag();
    expect(useInventoryStore.getState().draggingItemId).toBeNull();
  });

  it('parseInventoryAdded: InventoryItemData 배열을 InventoryItem 배열로 변환해야 한다 (U-075)', () => {
    const added = [
      { id: 'item-a', label: '아이템 A', description: '설명 A', icon_url: null, quantity: 1 },
      {
        id: 'item-b',
        label: '아이템 B',
        description: '설명 B',
        icon_url: '/static/icon.png',
        quantity: 2,
      },
    ];
    const parsed = parseInventoryAdded(added);

    expect(parsed).toHaveLength(2);
    expect(parsed[0]).toEqual({
      id: 'item-a',
      name: '아이템 A',
      description: '설명 A',
      icon: undefined,
      quantity: 1,
      iconStatus: 'pending',
    });
    expect(parsed[1]).toEqual({
      id: 'item-b',
      name: '아이템 B',
      description: '설명 B',
      icon: '/static/icon.png',
      quantity: 2,
      iconStatus: 'completed',
    });
  });
});
</file>

<file path="backend/src/unknown_world/orchestrator/generate_turn_output.py">
"""Unknown World - TurnOutput 생성 모듈 (Structured Outputs).

이 모듈은 Gemini 텍스트 모델을 Structured Outputs(JSON Schema) 모드로 호출해
TurnOutput을 생성하고, Pydantic 검증을 통과한 결과만 반환합니다.

설계 원칙:
    - RULE-003: 구조화 출력(JSON Schema) 우선 + 이중 검증(Pydantic+Zod)
    - RULE-004: 검증 실패 시 자동 복구(Repair loop) + 안전한 폴백
    - RULE-005: 재화 인바리언트 (잔액 음수 금지)
    - RULE-006: ko/en 언어 정책 준수
    - RULE-007/008: 프롬프트/내부 추론 노출 금지

U-127 변경:
    - 기본 텍스트 모델 = QUALITY (gemini-3-pro-preview)
    - 멀티턴 contents 배열 + system_instruction 분리
    - Gemini 3 Thought Signature 순환
    - thinking_level = "high" (기본)

참조:
    - vibe/unit-plans/U-017[Mvp].md
    - vibe/unit-plans/U-127[Mvp].md
    - vibe/unit-results/U-016[Mvp].md
    - vibe/unit-results/U-005[Mvp].md
    - .cursor/rules/20-backend-orchestrator.mdc
"""

from __future__ import annotations

import json
import logging
from dataclasses import dataclass, field
from enum import StrEnum
from typing import Any, cast

from pydantic import ValidationError

from unknown_world.config.models import (
    DEFAULT_THINKING_LEVEL,
    MODEL_DEFAULT_LABEL,
    ModelLabel,
    TextModelTiering,
)
from unknown_world.models.turn import (
    CurrencyAmount,
    Language,
    TurnInput,
    TurnOutput,
)
from unknown_world.orchestrator.conversation_history import ConversationHistory
from unknown_world.orchestrator.fallback import create_safe_fallback
from unknown_world.orchestrator.prompt_loader import (
    load_image_prompt,
    load_system_prompt,
    load_turn_instructions,
)
from unknown_world.services.genai_client import (
    GenerateRequest,
    get_genai_client,
)

# =============================================================================
# 로거 설정 (프롬프트/내부 추론 노출 금지 - RULE-007/008)
# =============================================================================

logger = logging.getLogger(__name__)


# =============================================================================
# Gemini API 스키마 호환성 (U-080 핫픽스)
# =============================================================================


def _strip_additional_properties(schema: dict[str, Any]) -> dict[str, Any]:
    """JSON Schema에서 additionalProperties 필드를 재귀적으로 제거합니다.

    Gemini API는 Pydantic이 생성하는 `additionalProperties` 필드를 인식하지 못하여
    `400 INVALID_ARGUMENT: Unknown name "additional_properties"` 에러가 발생합니다.
    이 함수는 스키마에서 해당 필드를 제거하여 Gemini API와 호환되게 합니다.

    Args:
        schema: Pydantic model_json_schema()로 생성된 JSON Schema

    Returns:
        additionalProperties가 제거된 JSON Schema
    """
    # 현재 레벨에서 additionalProperties 제거
    cleaned: dict[str, Any] = {}
    for key, value in schema.items():
        if key == "additionalProperties":
            continue

        # 값 타입에 따라 재귀 처리
        cleaned_value: Any
        if isinstance(value, dict):
            # dict인 경우 재귀 호출
            nested_dict = cast(dict[str, Any], value)
            cleaned_value = _strip_additional_properties(nested_dict)
        elif isinstance(value, list):
            # list인 경우 각 요소 처리
            cleaned_list: list[Any] = []
            value_list = cast(list[Any], value)
            for item in value_list:
                if isinstance(item, dict):
                    nested_item = cast(dict[str, Any], item)
                    cleaned_list.append(_strip_additional_properties(nested_item))
                else:
                    cleaned_list.append(item)
            cleaned_value = cleaned_list
        else:
            cleaned_value = value

        cleaned[key] = cleaned_value

    return cleaned


# =============================================================================
# 생성 결과 타입
# =============================================================================


class GenerationStatus(StrEnum):
    """생성 결과 상태."""

    SUCCESS = "success"
    """Pydantic 검증 통과"""

    SCHEMA_FAILURE = "schema_failure"
    """JSON 파싱 또는 스키마 검증 실패 (복구 대상)"""

    BUSINESS_FAILURE = "business_failure"
    """비즈니스 룰 위반 (U-018에서 처리)"""

    SAFETY_BLOCKED = "safety_blocked"
    """안전 정책에 의해 차단됨"""

    API_ERROR = "api_error"
    """API 호출 실패"""


@dataclass
class GenerationResult:
    """TurnOutput 생성 결과.

    Attributes:
        status: 생성 상태
        output: 생성된 TurnOutput (성공 시)
        error_message: 에러 메시지 (실패 시, 사용자 표시용)
        error_details: 상세 에러 정보 (내부용, UI 노출 금지)
        model_label: 사용된 모델 라벨
        cost_multiplier: 비용 배수 (U-069: FAST=1.0, QUALITY=2.0)
        raw_response: 원본 응답 텍스트 (디버그용, UI 노출 금지)
        thought_signature: Gemini 3 Thought Signature (U-127). 히스토리에 저장하여 추론 맥락 유지.
    """

    status: GenerationStatus
    output: TurnOutput | None = None
    error_message: str = ""
    error_details: dict[str, Any] = field(default_factory=lambda: {})
    model_label: ModelLabel = ModelLabel.FAST
    cost_multiplier: float = 1.0
    raw_response: str = ""
    thought_signature: str | None = None


# =============================================================================
# TurnOutput 생성기
# =============================================================================


class TurnOutputGenerator:
    """Structured Outputs를 사용한 TurnOutput 생성기.

    Gemini 모델을 JSON Schema 모드로 호출하고,
    Pydantic으로 응답을 검증합니다.

    Example:
        >>> generator = TurnOutputGenerator()
        >>> result = await generator.generate(turn_input)
        >>> if result.status == GenerationStatus.SUCCESS:
        ...     print(result.output.narrative)
    """

    def __init__(
        self,
        *,
        default_model_label: ModelLabel = MODEL_DEFAULT_LABEL,
        force_mock: bool = False,
    ) -> None:
        """TurnOutputGenerator를 초기화합니다.

        Args:
            default_model_label: 기본 모델 라벨 (U-127: QUALITY = Pro)
            force_mock: Mock 클라이언트 강제 사용 여부
        """
        self._default_model_label = default_model_label
        self._force_mock = force_mock
        self._json_schema: dict[str, Any] | None = None

    def _select_text_model(self, turn_input: TurnInput) -> tuple[ModelLabel, float]:
        """액션 기반 텍스트 모델을 선택합니다 (U-069 + U-127).

        U-127: 기본 모델이 QUALITY(Pro)로 변경됨.
        "정밀조사" 트리거 시 추가 비용 배수(2x)가 적용됨.

        페어링 질문 결정:
            - Q1: Option B - 액션 ID + 키워드 매칭
            - Q2: Option A - 2x (기본 비용의 2배)

        Args:
            turn_input: 사용자 턴 입력

        Returns:
            (model_label, cost_multiplier) 튜플
        """
        action_id = turn_input.action_id
        text = turn_input.text

        # QUALITY 트리거 검사 (U-069: 비용 배수 적용)
        if TextModelTiering.is_quality_trigger(action_id, text):
            model_label = ModelLabel.QUALITY
            logger.info(
                "[TurnOutputGenerator] QUALITY 트리거 감지 (비용 2x 적용)",
                extra={
                    "action_id": action_id,
                    "has_trigger_keyword": bool(text),
                    "model_label": model_label,
                },
            )
        else:
            model_label = self._default_model_label

        cost_multiplier = TextModelTiering.get_cost_multiplier(model_label)
        return model_label, cost_multiplier

    def _get_json_schema(self) -> dict[str, Any]:
        """TurnOutput JSON Schema를 반환합니다 (캐싱).

        U-080 핫픽스: Gemini API 호환성을 위해 additionalProperties 필드를 제거합니다.
        Gemini API는 이 필드를 인식하지 못하여 400 에러가 발생합니다.
        """
        if self._json_schema is not None:
            return self._json_schema

        raw_schema = TurnOutput.model_json_schema()
        # Gemini API 호환성: additionalProperties 제거
        self._json_schema = _strip_additional_properties(raw_schema)
        return self._json_schema

    def _build_prompt(
        self,
        turn_input: TurnInput,
        world_context: str = "",
    ) -> str:
        """전체 프롬프트를 구성합니다.

        Args:
            turn_input: 사용자 턴 입력
            world_context: 현재 세계 상태 요약 (선택)

        Returns:
            조합된 프롬프트 문자열
        """
        # 언어별 프롬프트 로드
        system_prompt = load_system_prompt(turn_input.language)
        turn_instructions = load_turn_instructions(turn_input.language)

        # U-061: 이미지 생성 가이드라인 로드 및 시스템 프롬프트에 추가
        # Q1 결정: Option A (Game Master 시스템 프롬프트에 섹션 추가)
        # Q2 결정: Option A (영문 없으면 한국어로 폴백 - prompt_loader에서 처리)
        try:
            image_guidelines = load_image_prompt(turn_input.language)
            # 이미지 가이드라인을 시스템 프롬프트 끝에 섹션으로 추가
            system_prompt = f"""{system_prompt}

---

## 이미지 생성 지침 (Image Generation Guidelines)

아래 가이드라인에 따라 `image_job.prompt` 필드를 작성하세요.
LLM이 이미지 모델에 최적화된 고품질 프롬프트를 생성할 수 있도록 합니다.

{image_guidelines}"""
            logger.debug(
                "[TurnOutputGenerator] 이미지 가이드라인 로드 완료",
                extra={"language": turn_input.language.value},
            )
        except FileNotFoundError:
            # 가이드라인 없으면 기본 프롬프트만 사용 (안전한 폴백)
            logger.warning(
                "[TurnOutputGenerator] 이미지 가이드라인 파일 미존재, 기본 프롬프트 사용",
                extra={"language": turn_input.language.value},
            )

        # 입력 정보 구성 (프롬프트에 포함)
        input_summary = f"""
## 현재 턴 입력

- language: {turn_input.language.value}
- text: "{turn_input.text}"
- action_id: {turn_input.action_id or "없음"}
- economy_snapshot:
  - signal: {turn_input.economy_snapshot.signal}
  - memory_shard: {turn_input.economy_snapshot.memory_shard}
"""

        # 세계 상태 컨텍스트 (있는 경우)
        world_section = ""
        if world_context:
            world_section = f"""
## 현재 세계 상태

{world_context}
"""

        # 전체 프롬프트 조합
        full_prompt = f"""{system_prompt}

---

{turn_instructions}

---

{input_summary}
{world_section}

---

위 지시에 따라 TurnOutput JSON을 생성하세요.
"""
        return full_prompt

    def _build_system_instruction(
        self,
        turn_input: TurnInput,
        world_context: str = "",
    ) -> str:
        """시스템 인스트럭션을 구성합니다 (U-127: contents와 분리).

        멀티턴 모드에서는 시스템 프롬프트가 config.system_instruction으로 분리됩니다.

        Args:
            turn_input: 사용자 턴 입력
            world_context: 현재 세계 상태 요약 (선택)

        Returns:
            시스템 인스트럭션 문자열
        """
        # 언어별 프롬프트 로드
        system_prompt = load_system_prompt(turn_input.language)
        turn_instructions = load_turn_instructions(turn_input.language)

        # 이미지 가이드라인 로드
        try:
            image_guidelines = load_image_prompt(turn_input.language)
            system_prompt = f"""{system_prompt}

---

## 이미지 생성 지침 (Image Generation Guidelines)

아래 가이드라인에 따라 `image_job.prompt` 필드를 작성하세요.
LLM이 이미지 모델에 최적화된 고품질 프롬프트를 생성할 수 있도록 합니다.

{image_guidelines}"""
        except FileNotFoundError:
            logger.warning(
                "[TurnOutputGenerator] 이미지 가이드라인 파일 미존재, 기본 프롬프트 사용",
                extra={"language": turn_input.language.value},
            )

        # 세계 상태 컨텍스트 (시스템 인스트럭션에 포함하여 히스토리와 중복 방지)
        world_section = ""
        if world_context:
            world_section = f"""

---

## 현재 세계 상태

{world_context}
"""

        # 시스템 인스트럭션 조합
        return f"""{system_prompt}

---

{turn_instructions}
{world_section}"""

    def _build_contents(
        self,
        turn_input: TurnInput,
        conversation_history: ConversationHistory | None = None,
    ) -> list[dict[str, Any]]:
        """멀티턴 contents 배열을 구성합니다 (U-127).

        대화 히스토리 + 현재 턴 입력을 Gemini API contents 형태로 변환합니다.

        Args:
            turn_input: 사용자 턴 입력
            conversation_history: 대화 히스토리 (None이면 히스토리 없이 현재 턴만)

        Returns:
            Gemini API contents 배열
        """
        contents: list[dict[str, Any]] = []

        # 이전 턴 히스토리 추가 (있는 경우)
        if conversation_history and conversation_history.turn_count > 0:
            history_contents = conversation_history.get_contents()
            contents.extend(history_contents)

        # 현재 턴 사용자 입력
        user_text = f"""## 현재 턴 입력

- language: {turn_input.language.value}
- text: "{turn_input.text}"
- action_id: {turn_input.action_id or "없음"}
- economy_snapshot:
  - signal: {turn_input.economy_snapshot.signal}
  - memory_shard: {turn_input.economy_snapshot.memory_shard}

위 입력에 따라 TurnOutput JSON을 생성하세요."""

        contents.append(
            {
                "role": "user",
                "parts": [{"text": user_text}],
            }
        )

        return contents

    async def generate(
        self,
        turn_input: TurnInput,
        *,
        world_context: str = "",
        conversation_history: ConversationHistory | None = None,
    ) -> GenerationResult:
        """TurnOutput을 생성합니다.

        Structured Outputs(JSON Schema) 모드로 Gemini를 호출하고,
        Pydantic으로 응답을 검증합니다.

        U-127: 멀티턴 contents + system_instruction + thinking_level 지원.
        대화 히스토리가 제공되면 멀티턴 모드로, 아니면 기존 단일 프롬프트 모드로 동작.

        Args:
            turn_input: 사용자 턴 입력
            world_context: 현재 세계 상태 요약 (선택)
            conversation_history: 대화 히스토리 (U-127, 선택)

        Returns:
            GenerationResult: 생성 결과 (status, output, error 등)
        """
        # U-069: 모델 티어링 - 액션/키워드 기반 모델 선택
        label, cost_multiplier = self._select_text_model(turn_input)

        # 멀티턴 모드 여부 판단
        use_multiturn = conversation_history is not None

        # 로그에는 메타만 기록 (프롬프트 원문 금지 - RULE-007/008)
        logger.info(
            "[TurnOutputGenerator] 생성 요청",
            extra={
                "language": turn_input.language.value,
                "model_label": label,
                "cost_multiplier": cost_multiplier,
                "has_text": bool(turn_input.text),
                "has_action_id": bool(turn_input.action_id),
                "multiturn": use_multiturn,
                "history_turns": conversation_history.turn_count if conversation_history else 0,
            },
        )

        try:
            # GenAI 클라이언트 가져오기
            client = get_genai_client(force_mock=self._force_mock)

            # Structured Outputs 요청 구성 (RULE-003)
            json_schema = self._get_json_schema()

            if use_multiturn:
                # U-127: 멀티턴 모드 - contents + system_instruction 분리
                contents = self._build_contents(turn_input, conversation_history)
                system_instruction = self._build_system_instruction(turn_input, world_context)

                request = GenerateRequest(
                    model_label=label,
                    temperature=0.7,
                    response_mime_type="application/json",
                    response_schema=json_schema,
                    contents=contents,
                    system_instruction=system_instruction,
                    thinking_level=DEFAULT_THINKING_LEVEL,
                )
            else:
                # 기존 단일 프롬프트 모드 (호환성 유지)
                prompt = self._build_prompt(turn_input, world_context)
                request = GenerateRequest(
                    prompt=prompt,
                    model_label=label,
                    temperature=0.7,
                    response_mime_type="application/json",
                    response_schema=json_schema,
                )

            # API 호출
            response = await client.generate(request)
            raw_text = response.text
            # U-127: Thought Signature 추출
            thought_signature = response.thought_signature

            # Pydantic 검증 (model_validate_json 사용 - U-017 완료 기준)
            # Structured Outputs로 인해 응답이 이미 JSON이므로
            # 마크다운 코드블록 처리 후 직접 검증합니다.
            try:
                # 응답에서 JSON 부분 추출 (마크다운 코드블록 처리)
                json_text = self._extract_json(raw_text)

                # model_validate_json: JSON 문자열을 직접 파싱+검증 (U-017 완료 기준)
                turn_output = TurnOutput.model_validate_json(json_text)

                # U-069: QUALITY 모델 비용 배수 적용
                # 비즈니스 룰 검증 전에 비용과 balance_after를 조정합니다.
                if cost_multiplier > 1.0:
                    original_signal = turn_output.economy.cost.signal
                    original_shard = turn_output.economy.cost.memory_shard

                    # 추가 비용 계산
                    additional_signal = int(original_signal * (cost_multiplier - 1))
                    additional_shard = int(original_shard * (cost_multiplier - 1))

                    # 비용 증가
                    turn_output.economy.cost.signal = original_signal + additional_signal
                    turn_output.economy.cost.memory_shard = original_shard + additional_shard

                    # balance_after 감소 (추가 비용만큼)
                    turn_output.economy.balance_after.signal -= additional_signal
                    turn_output.economy.balance_after.memory_shard -= additional_shard

                    logger.info(
                        "[TurnOutputGenerator] 비용 배수 적용 (U-069)",
                        extra={
                            "original_signal": original_signal,
                            "multiplied_signal": turn_output.economy.cost.signal,
                            "additional_signal": additional_signal,
                            "cost_multiplier": cost_multiplier,
                        },
                    )

                # 성공
                logger.info(
                    "[TurnOutputGenerator] 생성 성공",
                    extra={
                        "model_label": label,
                        "cost_multiplier": cost_multiplier,
                        "has_narrative": bool(turn_output.narrative),
                        "cost_signal": turn_output.economy.cost.signal,
                        "has_thought_signature": thought_signature is not None,
                    },
                )

                return GenerationResult(
                    status=GenerationStatus.SUCCESS,
                    output=turn_output,
                    model_label=label,
                    cost_multiplier=cost_multiplier,
                    raw_response=raw_text,
                    thought_signature=thought_signature,
                )

            except ValidationError as e:
                # 스키마 검증 실패 (복구 대상 - U-018에서 처리)
                logger.warning(
                    "[TurnOutputGenerator] Pydantic 검증 실패 (복구 대상)",
                    extra={
                        "error_count": len(e.errors()),
                        "model_label": label,
                    },
                )
                return GenerationResult(
                    status=GenerationStatus.SCHEMA_FAILURE,
                    error_message="응답 형식이 올바르지 않습니다"
                    if turn_input.language == Language.KO
                    else "Invalid response format",
                    error_details={
                        "validation_errors": [
                            {"loc": err["loc"], "type": err["type"]} for err in e.errors()
                        ]
                    },
                    model_label=label,
                    cost_multiplier=cost_multiplier,
                    raw_response=raw_text,
                )
            except json.JSONDecodeError as e:
                # JSON 파싱 실패 (복구 대상)
                logger.warning(
                    "[TurnOutputGenerator] JSON 파싱 실패 (복구 대상)",
                    extra={"error_type": "JSONDecodeError"},
                )
                return GenerationResult(
                    status=GenerationStatus.SCHEMA_FAILURE,
                    error_message="응답을 파싱할 수 없습니다"
                    if turn_input.language == Language.KO
                    else "Failed to parse response",
                    error_details={"json_error": str(e)},
                    model_label=label,
                    cost_multiplier=cost_multiplier,
                    raw_response=raw_text,
                )

        except RuntimeError as e:
            # API 호출 실패
            logger.error(
                "[TurnOutputGenerator] API 호출 실패",
                extra={"error_type": type(e).__name__},
            )
            return GenerationResult(
                status=GenerationStatus.API_ERROR,
                error_message="서비스에 연결할 수 없습니다"
                if turn_input.language == Language.KO
                else "Unable to connect to service",
                error_details={"api_error": str(e)},
                model_label=label,
                cost_multiplier=cost_multiplier,
            )

        except Exception as e:
            # 예상치 못한 오류
            logger.exception(
                "[TurnOutputGenerator] 예상치 못한 오류: %s: %s",
                type(e).__name__,
                str(e)[:500],
            )
            return GenerationResult(
                status=GenerationStatus.API_ERROR,
                error_message="처리 중 오류가 발생했습니다"
                if turn_input.language == Language.KO
                else "An error occurred during processing",
                error_details={
                    "unexpected_error": type(e).__name__,
                    "error_message": str(e)[:200],
                },
                model_label=label,
                cost_multiplier=cost_multiplier,
            )

    def _extract_json(self, text: str) -> str:
        """응답 텍스트에서 JSON 부분을 추출합니다.

        마크다운 코드블록으로 감싸진 경우를 처리합니다.

        Args:
            text: 원본 응답 텍스트

        Returns:
            JSON 문자열
        """
        text = text.strip()

        # 마크다운 코드블록 처리 (```json ... ```)
        if text.startswith("```"):
            lines = text.split("\n")
            # 첫 줄(```json)과 마지막 줄(```) 제거
            if lines[0].startswith("```"):
                lines = lines[1:]
            if lines and lines[-1].strip() == "```":
                lines = lines[:-1]
            text = "\n".join(lines)

        return text.strip()

    def create_safe_fallback(
        self,
        language: Language,
        error_message: str,  # noqa: ARG002 - 하위 호환용 (실제로 사용하지 않음)
        economy_snapshot: CurrencyAmount | None = None,
    ) -> TurnOutput:
        """안전한 폴백 TurnOutput을 생성합니다.

        검증 실패 또는 에러 발생 시 사용합니다.
        (RULE-004: 안전한 폴백 제공)

        Note:
            이 메서드는 fallback.create_safe_fallback SSOT로 위임합니다 (RU-005-Q1).

        Args:
            language: 언어
            error_message: 에러 메시지 (하위 호환용, 실제 미사용)
            economy_snapshot: 현재 재화 상태 (비용 0으로 유지)

        Returns:
            안전한 폴백 TurnOutput
        """
        # RU-005-Q1: fallback SSOT로 위임
        return create_safe_fallback(
            language=language,
            economy_snapshot=economy_snapshot,
            repair_count=0,
            is_blocked=False,
        )


# =============================================================================
# 편의 함수
# =============================================================================

# 기본 생성기 인스턴스 (싱글톤)
_default_generator: TurnOutputGenerator | None = None


def get_turn_output_generator(
    *,
    force_mock: bool = False,
    force_new: bool = False,
) -> TurnOutputGenerator:
    """TurnOutputGenerator 인스턴스를 반환합니다.

    Args:
        force_mock: Mock 클라이언트 강제 사용 여부
        force_new: 새 인스턴스 생성 여부

    Returns:
        TurnOutputGenerator 인스턴스
    """
    global _default_generator

    if force_new or _default_generator is None or force_mock:
        _default_generator = TurnOutputGenerator(
            default_model_label=MODEL_DEFAULT_LABEL,  # U-127: QUALITY 기본
            force_mock=force_mock,
        )

    return _default_generator


async def generate_turn_output(
    turn_input: TurnInput,
    *,
    world_context: str = "",
    conversation_history: ConversationHistory | None = None,
    force_mock: bool = False,
) -> GenerationResult:
    """TurnOutput을 생성하는 편의 함수.

    U-127: 기본 모델 QUALITY(Pro) + 멀티턴 히스토리 지원.

    Args:
        turn_input: 사용자 턴 입력
        world_context: 현재 세계 상태 요약 (선택)
        conversation_history: 대화 히스토리 (U-127, 선택)
        force_mock: Mock 클라이언트 강제 사용 여부

    Returns:
        GenerationResult: 생성 결과

    Example:
        >>> result = await generate_turn_output(turn_input, conversation_history=history)
        >>> if result.status == GenerationStatus.SUCCESS:
        ...     print(result.output.narrative)
    """
    generator = get_turn_output_generator(force_mock=force_mock)
    return await generator.generate(
        turn_input,
        world_context=world_context,
        conversation_history=conversation_history,
    )
</file>

<file path="backend/src/unknown_world/orchestrator/repair_loop.py">
"""Unknown World - Repair Loop (제한된 재시도).

스키마/비즈니스 룰 검증 실패 시 자동으로 재시도하는 루프입니다.
max_repair_attempts 내에서 repair 재요청을 수행하고,
최종 실패 시 안전한 폴백으로 종료합니다.

U-127 변경:
    - 멀티턴 대화 히스토리 전달 지원
    - Pro→Flash 모델 폴백 (API 에러 시 자동 전환)
    - Thought Signature 추적

설계 원칙:
    - RULE-004: 검증 실패 시 Repair loop + 안전한 폴백
    - RULE-007/008: 프롬프트 원문/내부 추론 노출 금지, 결과/횟수만 표시

페어링 결정:
    - Q1: max_repair_attempts = 2 (Option A)

참조:
    - vibe/unit-plans/U-018[Mvp].md
    - vibe/unit-plans/U-127[Mvp].md
    - vibe/unit-results/U-017[Mvp].md
"""

from __future__ import annotations

import asyncio
import logging
from dataclasses import dataclass, field
from typing import TYPE_CHECKING

from unknown_world.config.models import MODEL_FALLBACK_LABEL, ModelLabel
from unknown_world.models.turn import (
    CurrencyAmount,
    Language,
    TurnInput,
    TurnOutput,
    ValidationBadge,
)
from unknown_world.orchestrator.conversation_history import ConversationHistory
from unknown_world.orchestrator.fallback import create_safe_fallback
from unknown_world.orchestrator.generate_turn_output import (
    GenerationResult,
    GenerationStatus,
    TurnOutputGenerator,
    get_turn_output_generator,
)
from unknown_world.validation.business_rules import (
    BusinessRuleValidationResult,
    validate_business_rules,
)

if TYPE_CHECKING:
    pass

# =============================================================================
# 로거 설정 (프롬프트/내부 추론 노출 금지 - RULE-007/008)
# =============================================================================

logger = logging.getLogger(__name__)


# =============================================================================
# 설정 상수
# =============================================================================

# 페어링 결정: Q1 = Option A (2회)
MAX_REPAIR_ATTEMPTS = 2
"""최대 복구 시도 횟수."""


# =============================================================================
# i18n Repair 컨텍스트 메시지 (RULE-006, RU-005-S2)
# =============================================================================

REPAIR_CONTEXT_MESSAGES: dict[Language, dict[str, str]] = {
    Language.KO: {
        "schema_header": "## 이전 시도 결과",
        "schema_error": "응답 형식이 올바르지 않았습니다.",
        "schema_instruction": "TurnOutput JSON Schema를 정확히 준수하여 다시 생성하세요.",
        "business_header": "## 이전 시도 결과",
        "business_instruction": "위 규칙을 준수하여 다시 생성하세요.",
        # U-043: 언어 교정 전용 피드백
        "language_header": "## 언어 혼합 오류",
        "language_instruction": (
            "사용자 노출 텍스트에 영어가 섞여 있습니다. "
            "모든 텍스트를 한국어(ko-KR)로만 작성하세요. "
            "스키마 구조는 유지하고 텍스트 값만 한국어로 수정합니다. "
            "예외: Signal, Shard 등 재화 이름은 영어로 유지 가능합니다."
        ),
    },
    Language.EN: {
        "schema_header": "## Previous Attempt Result",
        "schema_error": "The response format was invalid.",
        "schema_instruction": "Please regenerate following the TurnOutput JSON Schema exactly.",
        "business_header": "## Previous Attempt Result",
        "business_instruction": "Please regenerate following the rules above.",
        # U-043: 언어 교정 전용 피드백
        "language_header": "## Language Mixing Error",
        "language_instruction": (
            "User-facing text contains Korean characters. "
            "Rewrite all text in English (en-US) only. "
            "Keep the schema structure intact and only modify text values to English. "
            "Exception: Currency names like Signal, Shard may remain in English."
        ),
    },
}


# =============================================================================
# Repair Loop 결과 타입
# =============================================================================


@dataclass
class RepairLoopResult:
    """Repair Loop 결과.

    Attributes:
        output: 최종 TurnOutput (성공 또는 폴백)
        total_attempts: 총 시도 횟수 (초기 시도 포함)
        repair_attempts: 복구 시도 횟수 (초기 시도 제외)
        is_fallback: 폴백으로 종료되었는지
        badges: 검증 배지 목록
        error_messages: 각 시도의 에러 메시지 (UI 노출용)
        model_label: 사용된 텍스트 모델 라벨 (U-069: FAST/QUALITY)
        cost_multiplier: 비용 배수 (U-069: FAST=1.0, QUALITY=2.0)
        thought_signature: Gemini 3 Thought Signature (U-127). 히스토리에 저장.
    """

    output: TurnOutput
    total_attempts: int = 1
    repair_attempts: int = 0
    is_fallback: bool = False
    is_rate_limited: bool = False
    badges: list[ValidationBadge] = field(default_factory=lambda: [])
    error_messages: list[str] = field(default_factory=lambda: [])
    model_label: ModelLabel = ModelLabel.FAST
    cost_multiplier: float = 1.0
    thought_signature: str | None = None


# =============================================================================
# Repair Loop 함수
# =============================================================================


async def run_repair_loop(
    turn_input: TurnInput,
    *,
    world_context: str = "",
    conversation_history: ConversationHistory | None = None,
    force_mock: bool = False,
    max_attempts: int = MAX_REPAIR_ATTEMPTS,
) -> RepairLoopResult:
    """Repair Loop를 실행합니다.

    초기 생성을 시도하고, 실패 시 max_attempts까지 재시도합니다.
    최종 실패 시 안전한 폴백을 반환합니다.

    U-127 변경:
        - 멀티턴 대화 히스토리 전달 (conversation_history)
        - API 에러 시 Pro→Flash 모델 자동 폴백
        - Thought Signature 추적 (RepairLoopResult에 포함)

    Args:
        turn_input: 사용자 턴 입력
        world_context: 현재 세계 상태 요약 (선택)
        conversation_history: 멀티턴 대화 히스토리 (U-127, 선택)
        force_mock: Mock 클라이언트 강제 사용 여부
        max_attempts: 최대 복구 시도 횟수

    Returns:
        RepairLoopResult: 최종 결과 (성공 또는 폴백, 모델 라벨/비용 배수 포함)

    Example:
        >>> result = await run_repair_loop(turn_input, conversation_history=history)
        >>> if result.is_fallback:
        ...     print(f"폴백으로 종료 (시도: {result.repair_attempts})")
        >>> print(f"사용 모델: {result.model_label}, 비용 배수: {result.cost_multiplier}")
        >>> print(result.output.narrative)
    """
    generator = get_turn_output_generator(force_mock=force_mock)
    # U-127: Flash 폴백용 생성기 (Pro API 에러 시 사용)
    fallback_generator: TurnOutputGenerator | None = None

    economy_snapshot = CurrencyAmount(
        signal=turn_input.economy_snapshot.signal,
        memory_shard=turn_input.economy_snapshot.memory_shard,
    )

    error_messages: list[str] = []
    badges: list[ValidationBadge] = []
    repair_context = ""  # 재시도 시 추가할 컨텍스트

    # U-069: 모델 티어링 - 최초 시도에서 결정된 모델 정보 저장
    selected_model_label: ModelLabel = ModelLabel.FAST
    selected_cost_multiplier: float = 1.0
    # U-127: Thought Signature 추적
    last_thought_signature: str | None = None
    # U-127: Pro→Flash 폴백 상태
    model_fell_back = False
    # U-130: 마지막 실패가 API 에러(429 등)인지 추적
    last_failure_was_api_error = False

    last_attempt = 0
    for attempt in range(max_attempts + 1):  # 0 = 초기 시도, 1~max = 복구 시도
        badges = []  # 매 시도마다 배지 초기화 (최종 시도 상태만 유지)
        last_attempt = attempt
        is_repair = attempt > 0

        # U-127: 폴백 상태에서는 Flash 생성기 사용
        current_generator = (
            fallback_generator if model_fell_back and fallback_generator else generator
        )

        # 로그 기록 (프롬프트 노출 금지)
        logger.info(
            "[RepairLoop] 시도",
            extra={
                "attempt": attempt,
                "is_repair": is_repair,
                "language": turn_input.language.value,
                "model_fell_back": model_fell_back,
            },
        )

        # 컨텍스트 구성 (복구 시 에러 요약 추가)
        current_context = world_context
        if is_repair and repair_context:
            current_context = f"{world_context}\n\n{repair_context}"

        # 생성 시도 (U-127: 멀티턴 히스토리 전달)
        gen_result = await current_generator.generate(
            turn_input,
            world_context=current_context,
            conversation_history=conversation_history,
        )

        # U-069: 모델 티어링 - 생성 결과에서 모델 정보 저장
        selected_model_label = gen_result.model_label
        selected_cost_multiplier = gen_result.cost_multiplier

        # 1. 스키마 검증 실패 (JSON 파싱/Pydantic 실패)
        if gen_result.status == GenerationStatus.SCHEMA_FAILURE:
            badges.append(ValidationBadge.SCHEMA_FAIL)
            error_messages.append(gen_result.error_message)
            # U-130: 스키마 실패는 rate limit이 아님
            last_failure_was_api_error = False
            # RU-005-S2: language에 따라 repair 메시지 분기
            repair_context = _build_repair_context_schema(gen_result, turn_input.language)
            continue

        # 2. API 에러 (429 RESOURCE_EXHAUSTED, 5xx, timeout 등)
        if gen_result.status == GenerationStatus.API_ERROR:
            badges.append(ValidationBadge.SCHEMA_FAIL)
            error_messages.append(gen_result.error_message)
            # U-130: API 에러 추적 (최종 실패 시 RATE_LIMITED 판정용)
            last_failure_was_api_error = True

            # U-127: Pro→Flash 모델 폴백 시도
            if not model_fell_back:
                model_fell_back = True
                fallback_generator = TurnOutputGenerator(
                    default_model_label=MODEL_FALLBACK_LABEL,
                    force_mock=force_mock,
                )
                logger.warning(
                    "[RepairLoop] Pro→Flash 모델 폴백 전환 (U-127)",
                    extra={
                        "attempt": attempt,
                        "from_model": gen_result.model_label,
                        "to_model": MODEL_FALLBACK_LABEL,
                    },
                )
                # 폴백 전환 시 짧은 대기
                await asyncio.sleep(1.0)
                repair_context = ""
                continue

            # 이미 폴백 상태에서도 실패 → 지수 백오프 대기 후 재시도
            backoff_seconds = 2.0 * (2**attempt)  # 2s → 4s → 8s
            logger.warning(
                "[RepairLoop] API 에러 (Flash 폴백 후) — %.1fs 대기 후 재시도",
                backoff_seconds,
                extra={
                    "attempt": attempt,
                    "error_message": gen_result.error_message,
                    "error_details": gen_result.error_details,
                    "backoff_seconds": backoff_seconds,
                },
            )
            await asyncio.sleep(backoff_seconds)
            repair_context = ""
            continue

        # 3. 스키마 검증 성공 → 비즈니스 룰 검증
        if gen_result.status == GenerationStatus.SUCCESS and gen_result.output:
            badges.append(ValidationBadge.SCHEMA_OK)
            # U-127: Thought Signature 추적
            last_thought_signature = gen_result.thought_signature

            # 비즈니스 룰 검증
            biz_result = validate_business_rules(turn_input, gen_result.output)

            if biz_result.is_valid:
                # 모든 검증 통과
                badges.extend(
                    [
                        ValidationBadge.ECONOMY_OK,
                        ValidationBadge.SAFETY_OK,
                        ValidationBadge.CONSISTENCY_OK,
                    ]
                )

                # 서버 검증 결과로 업데이트 (RULE-003/004/008)
                gen_result.output.agent_console.badges = badges
                gen_result.output.agent_console.repair_count = attempt

                logger.info(
                    "[RepairLoop] 성공",
                    extra={
                        "total_attempts": attempt + 1,
                        "repair_attempts": attempt,
                        "model_fell_back": model_fell_back,
                        "has_thought_signature": last_thought_signature is not None,
                    },
                )

                return RepairLoopResult(
                    output=gen_result.output,
                    total_attempts=attempt + 1,
                    repair_attempts=attempt,
                    is_fallback=False,
                    badges=badges,
                    error_messages=error_messages,
                    model_label=selected_model_label,
                    cost_multiplier=selected_cost_multiplier,
                    thought_signature=last_thought_signature,
                )

            # 비즈니스 룰 실패
            add_business_badges(biz_result, badges)
            error_messages.append(biz_result.error_summary)
            # RU-005-S2: language에 따라 repair 메시지 분기
            repair_context = _build_repair_context_business(biz_result, turn_input.language)
            continue

        # 4. 안전 차단
        if gen_result.status == GenerationStatus.SAFETY_BLOCKED:
            badges.append(ValidationBadge.SAFETY_BLOCKED)
            # 안전 차단은 재시도 불가 → 즉시 폴백
            logger.warning(
                "[RepairLoop] 안전 차단으로 폴백",
                extra={"attempt": attempt},
            )
            break

    # U-130: API 에러로 모든 재시도(폴백 포함) 소진 시 rate limited 판정
    rate_limited = last_failure_was_api_error and model_fell_back

    # 최종 실패 → 안전한 폴백 반환
    logger.warning(
        "[RepairLoop] 최종 폴백 반환",
        extra={
            "max_attempts": max_attempts,
            "actual_attempts": last_attempt,
            "model_fell_back": model_fell_back,
            "is_rate_limited": rate_limited,
        },
    )

    fallback = create_safe_fallback(
        language=turn_input.language,
        economy_snapshot=economy_snapshot,
        repair_count=last_attempt,
        is_blocked=ValidationBadge.SAFETY_BLOCKED in badges,
    )

    return RepairLoopResult(
        output=fallback,
        total_attempts=last_attempt + 1,
        repair_attempts=last_attempt,
        is_fallback=True,
        is_rate_limited=rate_limited,
        badges=badges,
        error_messages=error_messages,
        model_label=selected_model_label,
        cost_multiplier=selected_cost_multiplier,
        thought_signature=last_thought_signature,
    )


# =============================================================================
# 헬퍼 함수
# =============================================================================


def _build_repair_context_schema(gen_result: GenerationResult, language: Language) -> str:
    """스키마 실패에 대한 Repair 컨텍스트를 구성합니다.

    프롬프트 원문/상세 오류는 노출하지 않고, 간단한 지시만 포함합니다.
    언어에 따라 메시지를 분기합니다 (RULE-006, RU-005-S2).

    Args:
        gen_result: 생성 결과
        language: 응답 언어
    """
    # 짧은 요약만 포함 (RULE-007/008)
    messages = REPAIR_CONTEXT_MESSAGES[language]
    return f"""
{messages["schema_header"]}

{messages["schema_error"]}
{messages["schema_instruction"]}
"""


def _build_repair_context_business(
    biz_result: BusinessRuleValidationResult, language: Language
) -> str:
    """비즈니스 룰 실패에 대한 Repair 컨텍스트를 구성합니다.

    언어에 따라 메시지를 분기합니다 (RULE-006, RU-005-S2).
    언어 혼합 에러가 있으면 특별한 지시를 추가합니다 (U-043).

    Args:
        biz_result: 비즈니스 룰 검증 결과
        language: 응답 언어
    """
    messages = REPAIR_CONTEXT_MESSAGES[language]

    # U-043: 언어 혼합 에러가 있는지 확인
    has_language_content_error = any(
        "language_content_mixed" in err["type"] for err in biz_result.errors
    )

    # 언어 혼합 에러가 있으면 특별한 지시 추가
    if has_language_content_error:
        return f"""
{messages["language_header"]}

{biz_result.error_summary}

{messages["language_instruction"]}
"""

    # 일반 비즈니스 룰 에러
    return f"""
{messages["business_header"]}

{biz_result.error_summary}

{messages["business_instruction"]}
"""


def add_business_badges(
    biz_result: BusinessRuleValidationResult,
    badges: list[ValidationBadge],
) -> None:
    """비즈니스 룰 검증 결과에 따라 배지를 추가합니다.

    에러 타입 접두어 → 배지 매핑:
        - economy_* → ECONOMY_FAIL
        - safety_* → SAFETY_BLOCKED
        - language_* (mismatch/content_mixed) 또는 box2d_* → CONSISTENCY_FAIL

    RU-005-S1: consistency 에러가 누락되지 않도록 매핑을 완전하게 구현.
    U-043: language_content_mixed도 CONSISTENCY_FAIL로 매핑.

    Args:
        biz_result: 비즈니스 룰 검증 결과
        badges: 배지 목록 (in-place 수정)
    """
    # 에러 타입별 배지 매핑 (RU-005-S1, U-043)
    has_economy_error = any("economy" in err["type"] for err in biz_result.errors)
    has_safety_error = any("safety" in err["type"] for err in biz_result.errors)
    # U-043: language_mismatch, language_content_mixed, box2d_* 모두 consistency로 매핑
    has_consistency_error = any(
        "language" in err["type"] or "box2d" in err["type"] for err in biz_result.errors
    )

    # Economy 배지
    if has_economy_error:
        badges.append(ValidationBadge.ECONOMY_FAIL)
    else:
        badges.append(ValidationBadge.ECONOMY_OK)

    # Safety 배지
    if has_safety_error:
        badges.append(ValidationBadge.SAFETY_BLOCKED)
    else:
        badges.append(ValidationBadge.SAFETY_OK)

    # Consistency 배지 (RU-005-S1: 언어/좌표 규약 위반 표시)
    if has_consistency_error:
        badges.append(ValidationBadge.CONSISTENCY_FAIL)
    else:
        badges.append(ValidationBadge.CONSISTENCY_OK)
</file>

<file path="backend/src/unknown_world/services/genai_client.py">
"""Unknown World - GenAI 클라이언트 래퍼.

이 모듈은 API 키 인증 기반의 google-genai 클라이언트를 제공합니다.
환경변수로 실제 모델과 mock 모드를 전환할 수 있습니다.

인증 방식 (U-080 핫픽스: Vertex AI 제거):
    - GOOGLE_API_KEY 환경변수로 API 키 인증 (필수)
    - https://aistudio.google.com/apikey 에서 발급

모드 전환 (페어링 질문 Q1 결정: Option A):
    - 환경변수 UW_MODE=mock → MockGenAIClient (테스트/개발용)
    - 환경변수 UW_MODE=real → 실제 Gemini API 호출 (기본값)

보안 규칙:
    - API 키는 환경변수로만 관리 (RULE-007)
    - 프롬프트 원문/비밀정보 로깅 금지 (RULE-007/008)
    - 로그에는 라벨/버전/정책 메타만 노출

참조:
    - vibe/tech-stack.md (google-genai==1.56.0)
    - vibe/unit-plans/U-080[Mvp].md (Vertex AI 제거)
    - .cursor/rules/20-backend-orchestrator.mdc
    - .cursor/rules/00-core-critical.mdc (RULE-007/010)
"""

from __future__ import annotations

import logging
import os
from collections.abc import AsyncGenerator
from dataclasses import dataclass, field
from enum import StrEnum
from typing import TYPE_CHECKING, Any

from unknown_world.config.models import ModelLabel, get_model_id

if TYPE_CHECKING:
    from google.genai import Client
    from google.genai.types import GenerateContentConfig

# =============================================================================
# 로거 설정 (프롬프트/비밀정보 노출 금지)
# =============================================================================

logger = logging.getLogger(__name__)


class GenAIMode(StrEnum):
    """GenAI 클라이언트 동작 모드.

    환경변수 UW_MODE로 제어합니다.
    """

    MOCK = "mock"
    """테스트/개발용 모의 모드 - 실제 API 호출 없음"""

    REAL = "real"
    """실제 Vertex AI 호출 모드 (기본값)"""


# =============================================================================
# 환경변수 키 상수
# =============================================================================

ENV_UW_MODE = "UW_MODE"
"""동작 모드 환경변수 (mock|real)"""

ENV_GOOGLE_API_KEY = "GOOGLE_API_KEY"
"""Gemini API 키 환경변수 (필수)"""


# =============================================================================
# 요청/응답 데이터 클래스
# =============================================================================


@dataclass
class GenerateRequest:
    """텍스트 생성 요청.

    Attributes:
        prompt: 생성 프롬프트 (주의: 로깅 금지). contents가 설정되면 무시됩니다.
        model_label: 모델 라벨 (FAST, QUALITY 등)
        max_tokens: 최대 토큰 수 (선택)
        temperature: 온도 설정 (선택, 0.0~1.0)
        response_mime_type: 응답 MIME 타입 (예: "application/json")
        response_schema: 응답 JSON 스키마 (dict 또는 Pydantic 모델 타입)
        contents: 멀티턴 contents 배열 (U-127). 설정 시 prompt 대신 사용.
        system_instruction: 시스템 인스트럭션 (U-127). contents 사용 시 분리된 시스템 프롬프트.
        thinking_level: Gemini 3 thinking level (U-127). "low" 또는 "high" (기본: "high").
    """

    prompt: str = ""
    model_label: ModelLabel = ModelLabel.FAST
    max_tokens: int | None = None
    temperature: float | None = None
    response_mime_type: str | None = None
    response_schema: Any | None = None
    contents: list[dict[str, Any]] | None = None
    system_instruction: str | None = None
    thinking_level: str | None = None


@dataclass
class GenerateResponse:
    """텍스트 생성 응답.

    Attributes:
        text: 생성된 텍스트
        model_label: 사용된 모델 라벨
        finish_reason: 종료 이유 (stop, length 등)
        usage: 토큰 사용량 정보 (선택)
        thought_signature: Gemini 3 Thought Signature (U-127). 다음 턴에 전달하여 추론 맥락 유지.
    """

    text: str
    model_label: ModelLabel
    finish_reason: str = "stop"
    usage: dict[str, int] = field(default_factory=lambda: {})
    thought_signature: str | None = None


# =============================================================================
# Mock 클라이언트 구현
# =============================================================================


class MockGenAIClient:
    """테스트/개발용 모의 GenAI 클라이언트.

    실제 API를 호출하지 않고 고정된 응답을 반환합니다.
    자격 증명 미설정 시 자동으로 이 클라이언트가 사용됩니다.
    """

    def __init__(self) -> None:
        """MockGenAIClient를 초기화합니다."""
        logger.info(
            "[GenAI] Mock 모드로 초기화됨 (실제 API 호출 없음)",
            extra={"mode": GenAIMode.MOCK},
        )

    @property
    def mode(self) -> GenAIMode:
        """현재 동작 모드."""
        return GenAIMode.MOCK

    async def generate(self, request: GenerateRequest) -> GenerateResponse:
        """모의 텍스트를 생성합니다.

        Args:
            request: 생성 요청

        Returns:
            고정된 모의 응답
        """
        # 로그에는 메타 정보만 기록 (프롬프트 원문 금지 - RULE-007/008)
        logger.debug(
            "[GenAI] Mock 생성 요청",
            extra={
                "model_label": request.model_label,
                "max_tokens": request.max_tokens,
                "has_contents": request.contents is not None,
            },
        )

        return GenerateResponse(
            text=f"[Mock Response] 이것은 {request.model_label} 모델의 모의 응답입니다.",
            model_label=request.model_label,
            finish_reason="stop",
            usage={"prompt_tokens": 10, "completion_tokens": 20, "total_tokens": 30},
            thought_signature="mock-thought-sig-placeholder",
        )

    async def generate_stream(self, request: GenerateRequest) -> AsyncGenerator[str]:
        """모의 텍스트를 스트리밍으로 생성합니다.

        Args:
            request: 생성 요청

        Yields:
            고정된 모의 텍스트 청크
        """
        logger.debug(
            "[GenAI] Mock 스트리밍 요청",
            extra={"model_label": request.model_label},
        )

        chunks = [
            "[Mock] ",
            "이것은 ",
            f"{request.model_label} ",
            "모델의 ",
            "스트리밍 ",
            "모의 응답입니다.",
        ]
        for chunk in chunks:
            yield chunk

    def is_available(self) -> bool:
        """Mock 클라이언트는 항상 사용 가능합니다."""
        return True


# =============================================================================
# 실제 GenAI 클라이언트 구현
# =============================================================================


class GenAIClient:
    """API 키 기반 실제 GenAI 클라이언트.

    google-genai SDK를 사용하여 Gemini 모델을 호출합니다.
    GOOGLE_API_KEY 환경변수로 API 키 인증을 수행합니다.

    U-080 핫픽스: Vertex AI 서비스 계정 인증 완전 제거, API 키 전용
    """

    def __init__(
        self,
        api_key: str | None = None,
    ) -> None:
        """GenAIClient를 초기화합니다.

        Args:
            api_key: Gemini API 키 (환경변수 GOOGLE_API_KEY 사용 가능)

        Raises:
            RuntimeError: API 키가 설정되지 않은 경우
        """
        self._api_key = api_key or os.environ.get(ENV_GOOGLE_API_KEY)
        self._client: Client | None = None
        self._available = False

        self._initialize_client()

    def _initialize_client(self) -> None:
        """google-genai 클라이언트를 초기화합니다."""
        try:
            if not self._api_key:
                logger.warning(
                    "[GenAI] GOOGLE_API_KEY 환경변수가 설정되지 않음 - Mock 모드로 전환 권장",
                )
                self._available = False
                return

            from google.genai import Client

            # API 키 모드로 클라이언트 초기화 (Vertex AI 제거)
            # vertexai=False (기본값)로 API 키 인증 사용
            self._client = Client(api_key=self._api_key)
            self._available = True

            # 로그에는 초기화 성공 여부만 기록 (API 키 노출 금지 - RULE-007)
            logger.info(
                "[GenAI] API 키 클라이언트 초기화 완료",
                extra={
                    "mode": GenAIMode.REAL,
                    "auth": "api_key",
                },
            )
        except Exception as e:
            # 인증 실패 시에도 앱이 멈추지 않도록 로깅만 수행
            # 오류 상세(스택트레이스)에 비밀정보가 포함될 수 있으므로 exc_info=False
            logger.warning(
                "[GenAI] API 키 클라이언트 초기화 실패 - Mock 모드로 전환 권장",
                extra={"error_type": type(e).__name__},
            )
            self._available = False

    @property
    def mode(self) -> GenAIMode:
        """현재 동작 모드."""
        return GenAIMode.REAL

    async def generate(self, request: GenerateRequest) -> GenerateResponse:
        """텍스트를 생성합니다.

        U-127: contents 배열, system_instruction, thinking_config 지원.
        contents가 설정되면 멀티턴 호출, 아니면 기존 prompt 기반 호출.

        Args:
            request: 생성 요청

        Returns:
            생성된 텍스트 응답

        Raises:
            RuntimeError: 클라이언트가 사용 불가능한 경우
        """
        if not self._available or self._client is None:
            raise RuntimeError("GenAI 클라이언트가 초기화되지 않았습니다.")

        model_id = get_model_id(request.model_label)

        # 로그에는 메타 정보만 기록 (프롬프트 원문 금지 - RULE-007/008)
        logger.debug(
            "[GenAI] 생성 요청",
            extra={
                "model_label": request.model_label,
                "model_id": model_id,
                "max_tokens": request.max_tokens,
                "has_contents": request.contents is not None,
                "has_system_instruction": request.system_instruction is not None,
                "thinking_level": request.thinking_level,
            },
        )

        # google-genai SDK 호출
        from google.genai.types import GenerateContentConfig, ThinkingConfig

        config_dict: dict[str, Any] = {}
        if request.max_tokens:
            config_dict["max_output_tokens"] = request.max_tokens
        if request.temperature is not None:
            config_dict["temperature"] = request.temperature
        if request.response_mime_type:
            config_dict["response_mime_type"] = request.response_mime_type
        if request.response_schema:
            config_dict["response_schema"] = request.response_schema
        # U-127: system_instruction 지원
        if request.system_instruction:
            config_dict["system_instruction"] = request.system_instruction
        # U-127: thinking_config 지원 (Gemini 3 Pro/Flash)
        if request.thinking_level:
            config_dict["thinking_config"] = ThinkingConfig(
                thinking_level=request.thinking_level,  # type: ignore[reportArgumentType] - SDK가 str→enum 자동 변환
            )

        config: GenerateContentConfig | None = (
            GenerateContentConfig(**config_dict) if config_dict else None
        )

        # U-127: contents가 있으면 멀티턴, 없으면 기존 prompt
        api_contents: Any = request.contents if request.contents is not None else request.prompt

        response = await self._client.aio.models.generate_content(  # type: ignore[reportUnknownMemberType]
            model=model_id,
            contents=api_contents,
            config=config,
        )

        # 응답 파싱
        text = response.text if hasattr(response, "text") and response.text else str(response)
        finish_reason = "stop"
        thought_signature: str | None = None

        if hasattr(response, "candidates") and response.candidates:
            candidate = response.candidates[0]
            if hasattr(candidate, "finish_reason"):
                finish_reason = str(candidate.finish_reason)
            # U-127: Thought Signature 추출
            # SDK는 bytes로 반환 → bytes를 그대로 유지하여 다음 턴에 전달
            if hasattr(candidate, "content") and candidate.content:
                content = candidate.content
                if hasattr(content, "parts") and content.parts:
                    for part in content.parts:
                        if hasattr(part, "thought_signature") and part.thought_signature:
                            raw_sig = part.thought_signature
                            # bytes인 경우 latin-1로 인코딩하여 문자열로 보존
                            # (API에 다시 보낼 때 bytes로 복원 가능)
                            import base64

                            thought_signature = base64.b64encode(raw_sig).decode("ascii")
                            break

        # 토큰 사용량 추출
        usage: dict[str, int] = {}
        if hasattr(response, "usage_metadata") and response.usage_metadata:
            meta = response.usage_metadata
            if hasattr(meta, "prompt_token_count") and meta.prompt_token_count is not None:
                usage["prompt_tokens"] = meta.prompt_token_count
            if hasattr(meta, "candidates_token_count") and meta.candidates_token_count is not None:
                usage["completion_tokens"] = meta.candidates_token_count
            if hasattr(meta, "total_token_count") and meta.total_token_count is not None:
                usage["total_tokens"] = meta.total_token_count

        return GenerateResponse(
            text=text,
            model_label=request.model_label,
            finish_reason=finish_reason,
            usage=usage,
            thought_signature=thought_signature,
        )

    async def generate_stream(self, request: GenerateRequest) -> AsyncGenerator[str]:
        """텍스트를 스트리밍으로 생성합니다.

        Args:
            request: 생성 요청

        Yields:
            생성된 텍스트 청크

        Raises:
            RuntimeError: 클라이언트가 사용 불가능한 경우
        """
        if not self._available or self._client is None:
            raise RuntimeError("GenAI 클라이언트가 초기화되지 않았습니다.")

        model_id = get_model_id(request.model_label)

        logger.debug(
            "[GenAI] 스트리밍 요청",
            extra={
                "model_label": request.model_label,
                "model_id": model_id,
            },
        )

        from google.genai.types import GenerateContentConfig

        config_dict: dict[str, Any] = {}
        if request.max_tokens:
            config_dict["max_output_tokens"] = request.max_tokens
        if request.temperature is not None:
            config_dict["temperature"] = request.temperature
        if request.response_mime_type:
            config_dict["response_mime_type"] = request.response_mime_type
        if request.response_schema:
            config_dict["response_schema"] = request.response_schema

        config: GenerateContentConfig | None = (
            GenerateContentConfig(**config_dict) if config_dict else None
        )

        stream = await self._client.aio.models.generate_content_stream(  # type: ignore[reportUnknownMemberType]
            model=model_id,
            contents=request.prompt,
            config=config,
        )
        async for chunk in stream:
            if hasattr(chunk, "text") and chunk.text:
                yield chunk.text

    def is_available(self) -> bool:
        """클라이언트가 사용 가능한 상태인지 확인합니다."""
        return self._available


# =============================================================================
# 팩토리 함수
# =============================================================================

# 클라이언트 타입 (Protocol 대신 Union 사용 - pyright 호환성)
GenAIClientType = MockGenAIClient | GenAIClient

# 싱글톤 클라이언트 인스턴스 캐시
_client_instance: GenAIClientType | None = None


def get_genai_client(
    *,
    force_mock: bool = False,
    force_new: bool = False,
) -> GenAIClientType:
    """GenAI 클라이언트 인스턴스를 반환합니다.

    환경변수 UW_MODE에 따라 실제 클라이언트 또는 Mock 클라이언트를 반환합니다.
    기본적으로 싱글톤 패턴으로 동작합니다.

    Args:
        force_mock: True면 환경변수와 무관하게 Mock 클라이언트 반환
        force_new: True면 캐시를 무시하고 새 인스턴스 생성

    Returns:
        GenAI 클라이언트 인스턴스

    Example:
        >>> client = get_genai_client()
        >>> response = await client.generate(GenerateRequest(prompt="Hello"))
    """
    global _client_instance

    if not force_new and _client_instance is not None:
        return _client_instance

    # 모드 결정: force_mock > 환경변수 > 기본값(real)
    if force_mock:
        mode = GenAIMode.MOCK
    else:
        mode_str = os.environ.get(ENV_UW_MODE, GenAIMode.REAL)
        mode = GenAIMode(mode_str) if mode_str in GenAIMode.__members__.values() else GenAIMode.REAL

    # 클라이언트 생성
    client_result: GenAIClientType
    if mode == GenAIMode.MOCK:
        client_result = MockGenAIClient()
    else:
        client = GenAIClient()
        # 실제 클라이언트 초기화 실패 시 Mock으로 폴백
        if not client.is_available():
            logger.warning(
                "[GenAI] 실제 클라이언트 초기화 실패, Mock 모드로 폴백",
            )
            client_result = MockGenAIClient()
        else:
            client_result = client

    _client_instance = client_result
    return client_result


def reset_genai_client() -> None:
    """GenAI 클라이언트 캐시를 초기화합니다.

    테스트 시 클라이언트를 재설정할 때 사용합니다.
    """
    global _client_instance
    _client_instance = None
</file>

<file path="frontend/src/api/turnStream.ts">
/**
 * Unknown World - HTTP Streaming 클라이언트 + NDJSON 파서.
 *
 * fetch 기반으로 POST 요청을 보내고 응답 스트림을 NDJSON으로 파싱합니다.
 * 중간 청크 파싱 실패가 전체 UI를 멈추지 않도록 설계되었습니다.
 *
 * 설계 원칙:
 *   - RULE-003: 구조화 출력(JSON Schema) 우선 + 이중 검증
 *   - RULE-004: 검증 실패 시 안전 폴백 제공
 *   - RULE-008: 단계/배지 가시화 (프롬프트/내부 추론 노출 금지)
 *   - RULE-011: 백엔드 포트 8011 사용
 *
 * @module api/turnStream
 */

import type { TurnInput, TurnOutput, Language } from '../schemas/turn';
import { safeParseTurnOutput } from '../schemas/turn';
import type { StreamCallbacks } from '../types/turn_stream';
import {
  StreamEventType,
  BaseEventSchema,
  safeParseStageEvent,
  safeParseRepairEvent,
  safeParseBadgesEvent,
  safeParseNarrativeDeltaEvent,
  safeParseFinalEventRaw,
  safeParseErrorEvent,
  normalizeStageStatus,
} from '../types/turn_stream';

// Re-export 스트림 이벤트 타입들 (하위 호환성 유지)
export type {
  StreamEventTypeName,
  StageStatusName,
  StageEvent,
  RepairEvent,
  BadgesEvent,
  NarrativeDeltaEvent,
  FinalEvent,
  ErrorEvent,
  StreamEvent,
  StreamCallbacks,
} from '../types/turn_stream';
export { StreamEventType, StageStatus } from '../types/turn_stream';

// =============================================================================
// NDJSON 파서 (Q1 결정: Option A - 직접 구현)
// =============================================================================

/**
 * NDJSON 라인 파서.
 * 부분 청크를 버퍼링하고 완전한 라인을 파싱합니다.
 */
export class NDJSONParser {
  private buffer = '';

  /**
   * 청크를 파싱하고 완전한 JSON 객체들을 반환합니다.
   *
   * @param chunk - 수신된 텍스트 청크
   * @returns 파싱된 JSON 객체 배열
   */
  parse(chunk: string): unknown[] {
    this.buffer += chunk;
    const results: unknown[] = [];

    // 줄바꿈으로 분할
    const lines = this.buffer.split('\n');

    // 마지막 라인은 불완전할 수 있으므로 버퍼에 유지
    this.buffer = lines.pop() ?? '';

    for (const line of lines) {
      const trimmed = line.trim();
      if (trimmed === '') continue;

      try {
        const parsed = JSON.parse(trimmed);
        results.push(parsed);
      } catch {
        // 파싱 실패 시 해당 라인 무시 (RULE-004: 전체 중단 방지)
        console.warn('[NDJSON] Failed to parse line:', trimmed);
      }
    }

    return results;
  }

  /**
   * 버퍼를 초기화합니다.
   */
  reset(): void {
    this.buffer = '';
  }

  /**
   * 남은 버퍼를 플러시하고 마지막 객체를 파싱합니다.
   */
  flush(): unknown | null {
    const trimmed = this.buffer.trim();
    this.buffer = '';

    if (trimmed === '') return null;

    try {
      return JSON.parse(trimmed);
    } catch {
      console.warn('[NDJSON] Failed to parse remaining buffer:', trimmed);
      return null;
    }
  }
}

// =============================================================================
// 스트림 이벤트 핸들러
// =============================================================================

/**
 * 파싱된 이벤트를 타입별로 분배합니다.
 *
 * RU-002-S2: 캐스팅 대신 Zod safeParse를 적용하여 검증 강화.
 * Unknown/확장 이벤트는 UI를 멈추지 않고 경고만 출력.
 * U-063: economySnapshot 파라미터 추가 - 폴백 시에도 재화 잔액 유지.
 *
 * @param event - 파싱된 이벤트 객체
 * @param callbacks - 콜백 함수들
 * @param language - 폴백 언어
 * @param economySnapshot - 현재 재화 스냅샷 (폴백 시 잔액 유지)
 */
function dispatchEvent(
  event: unknown,
  callbacks: StreamCallbacks,
  language: Language,
  economySnapshot: { signal: number; memory_shard: number },
): void {
  if (!event || typeof event !== 'object') return;

  // 기본 이벤트 타입 추출
  const baseResult = BaseEventSchema.safeParse(event);
  if (!baseResult.success) {
    console.warn('[TurnStream] Invalid event format (no type field):', event);
    return;
  }

  const type = baseResult.data.type;

  switch (type) {
    case StreamEventType.STAGE: {
      // RU-002-S2: stage 이벤트 검증
      const stageResult = safeParseStageEvent(event);
      if (stageResult.success) {
        // status 정규화: 'ok' → 'complete'
        const normalizedStatus = normalizeStageStatus(stageResult.data.status);
        callbacks.onStage?.({
          type: StreamEventType.STAGE,
          name: stageResult.data.name,
          status: normalizedStatus,
        });
      } else {
        console.warn('[TurnStream] Invalid stage event:', stageResult.error.message);
      }
      break;
    }

    case StreamEventType.REPAIR: {
      // RU-002-S2: repair 이벤트 검증
      const repairResult = safeParseRepairEvent(event);
      if (repairResult.success) {
        callbacks.onRepair?.(repairResult.data);
      } else {
        console.warn('[TurnStream] Invalid repair event:', repairResult.error.message);
      }
      break;
    }

    case StreamEventType.BADGES: {
      // RU-002-S2: badges 이벤트 검증 (v1/v2 정규화 포함)
      const badgesResult = safeParseBadgesEvent(event);
      if (badgesResult.success) {
        callbacks.onBadges?.(badgesResult.data);
      } else {
        console.warn('[TurnStream] Invalid badges event:', badgesResult.error.message);
      }
      break;
    }

    case StreamEventType.NARRATIVE_DELTA: {
      // RU-002-S2: narrative_delta 이벤트 검증
      const narrativeResult = safeParseNarrativeDeltaEvent(event);
      if (narrativeResult.success) {
        callbacks.onNarrativeDelta?.(narrativeResult.data);
      } else {
        console.warn('[TurnStream] Invalid narrative_delta event:', narrativeResult.error.message);
      }
      break;
    }

    case StreamEventType.FINAL: {
      // RU-002-S2: final 이벤트 구조 검증
      const finalRawResult = safeParseFinalEventRaw(event);
      if (!finalRawResult.success) {
        console.warn('[TurnStream] Invalid final event structure:', finalRawResult.error.message);
        // U-063: 구조가 잘못되어도 폴백 제공 (재화 잔액 유지)
        callbacks.onFinal?.({
          type: StreamEventType.FINAL,
          data: createFallbackTurnOutput(language, economySnapshot),
        });
        break;
      }

      // RULE-003/004: Zod strict parse + 폴백
      // U-063: economySnapshot 전달하여 폴백 시에도 재화 잔액 유지
      const turnOutputPayload = finalRawResult.data.data;
      const parseResult = safeParseTurnOutput(turnOutputPayload, language, 0, economySnapshot);

      if (parseResult.success) {
        callbacks.onFinal?.({
          type: StreamEventType.FINAL,
          data: parseResult.data,
        });
      } else {
        console.warn('[TurnStream] TurnOutput validation failed:', parseResult.error);
        callbacks.onFinal?.({
          type: StreamEventType.FINAL,
          data: parseResult.fallback,
        });
      }
      break;
    }

    case StreamEventType.ERROR: {
      // RU-002-S2: error 이벤트 검증
      const errorResult = safeParseErrorEvent(event);
      if (errorResult.success) {
        callbacks.onError?.(errorResult.data);
      } else {
        console.warn('[TurnStream] Invalid error event:', errorResult.error.message);
        // U-044: 에러 이벤트가 깨진 경우에도 기본 에러 전달 (i18n 메시지 사용)
        callbacks.onError?.({
          type: StreamEventType.ERROR,
          message: getErrorMessage('unknown_error', language),
          code: 'INVALID_ERROR_EVENT',
        });
      }
      break;
    }

    default:
      // RU-002-S2: Unknown/확장 이벤트는 UI를 멈추지 않고 경고만 출력
      // 향후 protocol, repair, telemetry 등 확장 이벤트 도입 시 여기서 처리 가능
      console.warn('[TurnStream] Unknown/ignored event type:', type, event);
  }
}

// =============================================================================
// U-044: i18n 에러/폴백 메시지 (Q2: Option B - translation.json 키 사용)
// =============================================================================

/**
 * U-044: 에러 메시지 번역 리소스.
 * 클라이언트에서 발생하는 에러 메시지를 언어별로 제공합니다.
 *
 * 주의: turnStream.ts는 React 컴포넌트가 아니므로 useTranslation 사용 불가.
 * 대신 language 매개변수로 분기 처리합니다.
 * translation.json의 키와 동기화 유지 필요 (error.* 네임스페이스).
 */
const ERROR_MESSAGES: Record<string, Record<Language, string>> = {
  // 에러 이벤트 파싱 실패
  unknown_error: {
    'ko-KR': '알 수 없는 오류가 발생했습니다.',
    'en-US': 'An unknown error occurred.',
  },
  // 응답 데이터 처리 실패 (final 이벤트 스키마 검증 실패)
  response_processing: {
    'ko-KR': '[시스템] 응답 데이터를 처리하는 중 문제가 발생했습니다.',
    'en-US': '[System] An error occurred while processing response data.',
  },
  // 서버 연결 실패 (네트워크 에러)
  connection_failed: {
    'ko-KR': '[시스템] 서버 연결에 실패했습니다. 다시 시도해 주세요.',
    'en-US': '[System] Failed to connect to server. Please try again.',
  },
};

/**
 * U-044: 에러 메시지를 언어에 맞게 반환합니다.
 */
function getErrorMessage(key: string, language: Language): string {
  return ERROR_MESSAGES[key]?.[language] ?? ERROR_MESSAGES[key]?.['en-US'] ?? key;
}

/**
 * 클라이언트 측 폴백 TurnOutput 생성 (언어 + 스냅샷 지정).
 * dispatchEvent 내부에서 사용하는 간단한 폴백.
 * U-044: 하드코딩 메시지 제거, i18n 리소스 사용.
 * U-063: economySnapshot 파라미터 추가 - 폴백에서도 재화 잔액 유지 (RULE-005).
 */
function createFallbackTurnOutput(
  language: Language,
  economySnapshot?: { signal: number; memory_shard: number },
): TurnOutput {
  const fallbackNarrative = getErrorMessage('response_processing', language);

  // U-063: 폴백에서도 재화 잔액 유지 (RULE-005)
  const balanceAfter = economySnapshot
    ? { signal: economySnapshot.signal, memory_shard: economySnapshot.memory_shard }
    : { signal: 100, memory_shard: 5 }; // 기본값 (프로필 미로드 상태의 placeholder)

  return {
    language,
    narrative: fallbackNarrative,
    economy: {
      cost: { signal: 0, memory_shard: 0 },
      balance_after: balanceAfter,
      credit: 0,
      low_balance_warning: false,
    },
    safety: {
      blocked: false,
      message: null,
    },
    ui: {
      action_deck: { cards: [] },
      objects: [],
      scene: { image_url: null, alt_text: null },
    },
    world: {
      rules_changed: [],
      inventory_added: [],
      inventory_removed: [],
      quests_updated: [],
      relationships_changed: [],
      memory_pins: [],
    },
    render: {
      image_job: null,
      image_url: null,
      image_id: null,
      generation_time_ms: null,
    },
    agent_console: {
      current_phase: 'commit',
      badges: ['schema_fail'],
      repair_count: 1,
      model_label: 'FAST',
    },
  };
}

// =============================================================================
// API 설정
// =============================================================================

/** 백엔드 API URL (RULE-011: 포트 8011) */
const API_BASE_URL = 'http://localhost:8011';

/** 턴 스트림 API 엔드포인트 */
const TURN_ENDPOINT = `${API_BASE_URL}/api/turn`;

// =============================================================================
// 스트림 클라이언트
// =============================================================================

/** 스트림 요청 옵션 */
export interface TurnStreamOptions {
  /** 요청 타임아웃 (ms) */
  timeout?: number;
  /** AbortSignal */
  signal?: AbortSignal;
}

/**
 * 턴 스트림 요청을 실행합니다.
 *
 * @param input - 턴 입력 데이터
 * @param callbacks - 이벤트 콜백
 * @param options - 요청 옵션
 * @returns 취소 함수
 */
export async function executeTurnStream(
  input: TurnInput,
  callbacks: StreamCallbacks,
  options?: TurnStreamOptions,
): Promise<void> {
  const parser = new NDJSONParser();
  const controller = new AbortController();
  const signal = options?.signal ?? controller.signal;

  // RU-002-S1: AbortError 발생 시 onComplete 호출 여부 추적
  let aborted = false;

  try {
    const response = await fetch(TURN_ENDPOINT, {
      method: 'POST',
      headers: {
        'Content-Type': 'application/json',
        Accept: 'application/x-ndjson',
      },
      body: JSON.stringify(input),
      signal,
    });

    if (!response.ok) {
      throw new Error(`HTTP ${response.status}: ${response.statusText}`);
    }

    if (!response.body) {
      throw new Error('Response body is null');
    }

    const reader = response.body.getReader();
    const decoder = new TextDecoder('utf-8');

    // 스트림 읽기 루프
    // U-063: economySnapshot을 dispatchEvent에 전달하여 폴백 시 재화 잔액 유지
    while (true) {
      const { done, value } = await reader.read();

      if (done) break;

      const chunk = decoder.decode(value, { stream: true });
      const events = parser.parse(chunk);

      for (const event of events) {
        dispatchEvent(event, callbacks, input.language, input.economy_snapshot);
      }
    }

    // 남은 버퍼 플러시
    const remaining = parser.flush();
    if (remaining) {
      dispatchEvent(remaining, callbacks, input.language, input.economy_snapshot);
    }
  } catch (error) {
    if (error instanceof DOMException && error.name === 'AbortError') {
      // RU-003-S1: Abort(취소) 정책
      // =========================================================================
      // 현재 정책(Option B): Abort 시 onComplete를 호출하지 않음
      // - 이유: 취소는 "사용자 의도"이므로 실패와 구분해야 함
      // - 주의: 이 정책에서는 Cancel 버튼 구현 시 호출자가 직접 UI 복구 필요
      //
      // 향후 Option A로 전환 가능:
      // - Abort 시에도 onComplete 호출 + 별도 플래그로 "취소 종료" 구분
      // - 장점: UI가 멈추지 않음 (복구 일관성)
      // - 단점: 취소와 실패를 구분하려면 이벤트 모델 확장 필요
      //
      // 결정 근거: RU-003-S1 Step 3
      // =========================================================================
      aborted = true;
      return;
    }

    const errorMessage = error instanceof Error ? error.message : 'Unknown error occurred';

    // RU-002-S1: 네트워크 에러 시에도 onError 호출
    callbacks.onError?.({
      type: StreamEventType.ERROR,
      message: errorMessage,
      code: 'STREAM_ERROR',
    });

    // RU-002-S1: 네트워크 에러 시 클라이언트 측 폴백 final 생성
    // 서버에서 final이 오지 못한 경우 UI가 멈추지 않도록 함
    const fallback = createClientFallbackTurnOutput(input.language, input.economy_snapshot);
    callbacks.onFinal?.({
      type: StreamEventType.FINAL,
      data: fallback,
    });
  } finally {
    // RU-002-S1: 스트림 종료 인바리언트 - 성공/실패 모두에서 onComplete 호출 보장
    if (!aborted) {
      callbacks.onComplete?.();
    }
  }
}

/**
 * 클라이언트 측 폴백 TurnOutput 생성 (RU-002-S1).
 * 서버에서 final이 오지 못한 경우 (네트워크 에러 등) 사용합니다.
 * Economy는 요청 직전 스냅샷을 그대로 유지합니다.
 * U-044: 하드코딩 메시지 제거, i18n 리소스 사용.
 */
function createClientFallbackTurnOutput(
  language: Language,
  economySnapshot: { signal: number; memory_shard: number },
): TurnOutput {
  const fallbackNarrative = getErrorMessage('connection_failed', language);

  return {
    language,
    narrative: fallbackNarrative,
    economy: {
      cost: { signal: 0, memory_shard: 0 },
      // RU-002-S1: 입력 스냅샷 그대로 유지 (비용 0, 잔액 변화 없음)
      balance_after: {
        signal: economySnapshot.signal,
        memory_shard: economySnapshot.memory_shard,
      },
      credit: 0,
      low_balance_warning: false,
    },
    safety: {
      blocked: false,
      message: null,
    },
    ui: {
      action_deck: { cards: [] },
      objects: [],
      scene: { image_url: null, alt_text: null },
    },
    world: {
      rules_changed: [],
      inventory_added: [],
      inventory_removed: [],
      quests_updated: [],
      relationships_changed: [],
      memory_pins: [],
    },
    render: {
      image_job: null,
      image_url: null,
      image_id: null,
      generation_time_ms: null,
    },
    agent_console: {
      current_phase: 'commit',
      badges: ['schema_fail'],
      repair_count: 1,
      model_label: 'FAST',
    },
  };
}

/**
 * 턴 스트림을 시작하고 취소 함수를 반환합니다.
 *
 * @param input - 턴 입력 데이터
 * @param callbacks - 이벤트 콜백
 * @returns 취소 함수
 */
export function startTurnStream(input: TurnInput, callbacks: StreamCallbacks): () => void {
  const controller = new AbortController();

  executeTurnStream(input, callbacks, { signal: controller.signal });

  return () => controller.abort();
}
</file>

<file path="frontend/src/components/ActionDeck.test.tsx">
import { describe, it, expect, vi, beforeEach } from 'vitest';
import { render, screen, fireEvent, act } from '@testing-library/react';
import { ActionDeck } from './ActionDeck';
import type { ActionCard } from '../schemas/turn';
import { useActionDeckStore } from '../stores/actionDeckStore';
import { useWorldStore } from '../stores/worldStore';
import { useAgentStore } from '../stores/agentStore';

// i18next 모킹
vi.mock('react-i18next', () => ({
  useTranslation: () => ({
    t: (key: string, params?: Record<string, unknown>) => {
      if (params?.turn !== undefined) return `Turn ${params.turn}`;
      if (key === 'action.risk.low') return 'Low';
      if (key === 'action.risk.medium') return 'Medium';
      if (key === 'action.risk.high') return 'High';
      if (key === 'action.insufficient_balance') return 'Insufficient Balance';
      if (key === 'action.alternative') return 'Alt';
      // U-128: 번역 키 모킹 추가
      if (key === 'action.vision_already_analyzed') return 'action.vision_already_analyzed';
      return key;
    },
  }),
  initReactI18next: {
    type: '3rdParty',
    init: () => {},
  },
}));

// U-065: 단순화된 ActionCard 스키마 (제거됨: description, cost_estimate, hint, reward_hint, disabled_reason)
describe('ActionDeck Component', () => {
  const mockCards: ActionCard[] = [
    {
      id: 'card-1',
      label: 'Regular Action',
      cost: { signal: 10, memory_shard: 0 },
      risk: 'low',
      enabled: true,
      is_alternative: false,
    },
    {
      id: 'card-2',
      label: 'Expensive Action',
      cost: { signal: 50, memory_shard: 1 },
      risk: 'high',
      enabled: true,
      is_alternative: false,
    },
    {
      id: 'card-alt',
      label: 'Alternative Action',
      cost: { signal: 2, memory_shard: 0 },
      risk: 'low',
      enabled: true,
      is_alternative: true,
    },
  ];

  beforeEach(() => {
    // 스토어 초기화
    act(() => {
      useActionDeckStore.setState({ cards: [] });
      useWorldStore.setState({
        economy: { signal: 100, memory_shard: 5, credit: 0 },
        sceneObjects: [], // U-128: 핫스팟 초기화 명시
      });
      useAgentStore.setState({ isStreaming: false });
    });
  });

  it('renders provided cards from store', () => {
    act(() => {
      useActionDeckStore.setState({ cards: mockCards });
    });
    render(<ActionDeck />);
    expect(screen.getByText('Regular Action')).toBeInTheDocument();
    expect(screen.getByText('Expensive Action')).toBeInTheDocument();
    expect(screen.getByText('Alternative Action')).toBeInTheDocument();
  });

  // U-065: cost_estimate 제거됨, cost만 표시
  it('displays cost values', () => {
    act(() => {
      useActionDeckStore.setState({ cards: mockCards });
    });
    render(<ActionDeck />);
    // card-1 has cost: 10
    expect(screen.getByText('10')).toBeInTheDocument();
    // card-2 has cost: 50
    expect(screen.getByText('50')).toBeInTheDocument();
  });

  // U-065: cost_estimate 제거됨, cost만 사용
  it('disables cards when balance is insufficient in worldStore', () => {
    act(() => {
      useActionDeckStore.setState({ cards: mockCards });
      useWorldStore.setState({ economy: { signal: 5, memory_shard: 0, credit: 0 } });
    });

    render(<ActionDeck />);

    // Regular Action (cost 10) -> disabled
    const card1 = screen.getByRole('button', { name: /Regular Action/i });
    expect(card1).toBeDisabled();
    expect(screen.getAllByText('Insufficient Balance').length).toBeGreaterThan(0);

    // Alternative Action (cost 2) -> enabled
    const cardAlt = screen.getByRole('button', { name: /Alternative Action/i });
    expect(cardAlt).not.toBeDisabled();
  });

  it('renders alternative badge for alternative cards', () => {
    act(() => {
      useActionDeckStore.setState({ cards: mockCards });
    });
    render(<ActionDeck />);
    expect(screen.getByText('Alt')).toBeInTheDocument();
  });

  it('calls onCardClick when an enabled card is clicked', () => {
    const onCardClick = vi.fn();
    act(() => {
      useActionDeckStore.setState({ cards: mockCards });
    });
    render(<ActionDeck onCardClick={onCardClick} />);

    fireEvent.click(screen.getByText('Regular Action'));
    expect(onCardClick).toHaveBeenCalledWith(expect.objectContaining({ id: 'card-1' }));
  });

  // U-065: disabled_reason 제거됨, 서버에서 enabled=false면 기본 메시지 표시
  it('displays default disabled message when server disables card', () => {
    const disabledCard: ActionCard[] = [
      {
        ...mockCards[0],
        enabled: false,
      },
    ];
    act(() => {
      useActionDeckStore.setState({ cards: disabledCard });
    });
    render(<ActionDeck />);
    // action.server_disabled 키가 그대로 출력됨 (모킹에서 처리 안 됨)
    const card = screen.getByRole('button', { name: /Regular Action/i });
    expect(card).toBeDisabled();
  });

  it('renders default cards when store cards are empty', () => {
    act(() => {
      useActionDeckStore.setState({ cards: [] });
    });
    render(<ActionDeck />);
    // useDefaultCards should provide some default labels
    expect(screen.getByText('action.default.explore.label')).toBeInTheDocument();
  });

  it('disables all cards when isStreaming is true in agentStore', () => {
    act(() => {
      useActionDeckStore.setState({ cards: mockCards });
      useAgentStore.setState({ isStreaming: true });
    });

    render(<ActionDeck />);

    const card1 = screen.getByRole('button', { name: /Regular Action/i });
    const cardAlt = screen.getByRole('button', { name: /Alternative Action/i });

    expect(card1).toBeDisabled();
    expect(cardAlt).toBeDisabled();
  });

  describe('Badge Layout (U-083)', () => {
    it('renders multiple badges (VISION + EARN) simultaneously', () => {
      // earn_ 접두사가 있고 VISION_TRIGGER_ACTION_IDS에 포함된 ID
      const complexCard: ActionCard[] = [
        {
          id: 'earn_정밀분석',
          label: 'Complex Action',
          cost: { signal: 5, memory_shard: 0 },
          risk: 'medium',
          enabled: true,
          is_alternative: false,
        },
      ];
      act(() => {
        useActionDeckStore.setState({ cards: complexCard });
      });
      render(<ActionDeck />);

      // VISION 뱃지 (🔍 action.vision_badge)
      expect(screen.getByText(/action\.vision_badge/)).toBeInTheDocument();
      // EARN 뱃지 (⚡ action.earn_badge)
      expect(screen.getByText(/action\.earn_badge/)).toBeInTheDocument();
    });

    it('limits visible badges to 2 and shows overflow count', () => {
      // VISION + EARN + ALT = 3개
      const threeBadgesCard: ActionCard[] = [
        {
          id: 'earn_정밀분석',
          label: 'Three Badges',
          cost: { signal: 5, memory_shard: 0 },
          risk: 'medium',
          enabled: true,
          is_alternative: true, // 수정된 로직에 의해 다른 뱃지가 있어도 추가됨
        },
      ];
      act(() => {
        useActionDeckStore.setState({ cards: threeBadgesCard });
      });
      render(<ActionDeck />);

      // VISION과 EARN은 표시되어야 함 (collectBadges 순서상)
      expect(screen.getByText(/action\.vision_badge/)).toBeInTheDocument();
      expect(screen.getByText(/action\.earn_badge/)).toBeInTheDocument();

      // ALT는 3번째이므로 숨겨지고 +1이 나타나야 함
      expect(screen.queryByText('Alt')).not.toBeInTheDocument();
      expect(screen.getByText('+1')).toBeInTheDocument();
    });

    it('shows alternative badge only when no other badges are present', () => {
      const altOnlyCard: ActionCard[] = [
        {
          id: 'simple-alt',
          label: 'Alt Only',
          cost: { signal: 1, memory_shard: 0 },
          risk: 'low',
          enabled: true,
          is_alternative: true,
        },
      ];
      act(() => {
        useActionDeckStore.setState({ cards: altOnlyCard });
      });
      render(<ActionDeck />);

      expect(screen.getByText('Alt')).toBeInTheDocument();
    });
  });

  describe('Vision Action Restriction (U-128)', () => {
    const visionCard: ActionCard[] = [
      {
        id: '정밀분석', // VISION_TRIGGER_ACTION_IDS에 포함됨
        label: 'Analyze Scene',
        cost: { signal: 5, memory_shard: 0 },
        risk: 'medium',
        enabled: true,
        is_alternative: false,
      },
    ];

    it('enables vision action when no hotspots exist', () => {
      act(() => {
        useActionDeckStore.setState({ cards: visionCard });
        useWorldStore.setState({ sceneObjects: [] });
      });

      render(<ActionDeck />);

      const card = screen.getByRole('button', { name: /Analyze Scene/i });
      expect(card).not.toBeDisabled();
    });

    it('disables vision action when hotspots exist (already analyzed)', () => {
      act(() => {
        useActionDeckStore.setState({ cards: visionCard });
        // 핫스팟이 1개 이상 존재함
        useWorldStore.setState({
          sceneObjects: [
            {
              id: 'obj-1',
              label: 'Object',
              box_2d: { ymin: 100, xmin: 100, ymax: 200, xmax: 200 },
              interaction_hint: null,
            },
          ],
        });
      });

      render(<ActionDeck />);

      const card = screen.getByRole('button', { name: /Analyze Scene/i });
      expect(card).toBeDisabled();
      // 비활성화 사유 표시 확인
      expect(screen.getByText('action.vision_already_analyzed')).toBeInTheDocument();
    });

    it('re-enables vision action when hotspots are cleared (new scene)', () => {
      act(() => {
        useActionDeckStore.setState({ cards: visionCard });
        // 1. 처음엔 핫스팟이 있어 비활성 상태
        useWorldStore.setState({
          sceneObjects: [
            {
              id: 'obj-1',
              label: 'Object',
              box_2d: { ymin: 100, xmin: 100, ymax: 200, xmax: 200 },
              interaction_hint: null,
            },
          ],
        });
      });

      const { rerender } = render(<ActionDeck />);
      expect(screen.getByRole('button', { name: /Analyze Scene/i })).toBeDisabled();

      // 2. 핫스팟이 초기화됨 (새 장면 이미지 생성 등으로 인해)
      act(() => {
        useWorldStore.setState({ sceneObjects: [] });
      });

      rerender(<ActionDeck />);
      expect(screen.getByRole('button', { name: /Analyze Scene/i })).not.toBeDisabled();
    });
  });
});
</file>

<file path="frontend/src/components/EconomyHud.tsx">
/**
 * Unknown World - Economy HUD 컴포넌트 (U-014[Mvp]).
 *
 * Signal/Memory Shard 재화 잔액, 예상 비용, 확정 비용을 표시하고,
 * 잔액 부족 시 경고 및 대안을 안내하는 게임 HUD 컴포넌트입니다.
 *
 * RULE-002 준수: 채팅 버블이 아닌 게임 HUD 형태
 * RULE-005 준수: 예상 비용 사전 표시, 잔액 음수 표시 방지
 * RULE-008 준수: 비용/모델 선택 이유는 라벨로만 표시 (프롬프트 노출 금지)
 *
 * @see vibe/prd.md 5장 - 재화 목적/UX 요구
 * @module components/EconomyHud
 */

import { useMemo, useEffect, useRef } from 'react';
import { useTranslation } from 'react-i18next';
import { useShallow } from 'zustand/react/shallow';
import { useWorldStore, type EconomyState } from '../stores/worldStore';
import {
  useEconomyStore,
  selectCostEstimate,
  selectLastCost,
  selectIsBalanceLow,
  selectRecentLedger,
  canAffordEstimate,
  type LedgerEntry,
} from '../stores/economyStore';
import type { CurrencyAmount } from '../schemas/turn';

// =============================================================================
// 타입 정의
// =============================================================================

export interface EconomyHudProps {
  /** 간소화 모드 (헤더용 - 잔액만 표시) */
  compact?: boolean;
  /** 추가 CSS 클래스 */
  className?: string;
}

// =============================================================================
// 아이콘 컴포넌트
// =============================================================================

interface CurrencyIconProps {
  type: 'signal' | 'shard';
  size?: number;
}

/** U-082: 기본 아이콘 크기를 24→28px로 확대 (가시성 향상) */
function CurrencyIcon({ type, size = 28 }: CurrencyIconProps) {
  const { t } = useTranslation();

  const iconSrc = type === 'signal' ? '/ui/icons/signal-24.png' : '/ui/icons/shard-24.png';
  const fallback = type === 'signal' ? '⚡' : '💎';
  const label = type === 'signal' ? t('economy.signal') : t('economy.shard');

  return (
    <span className="icon-wrapper" aria-label={label}>
      <img
        src={iconSrc}
        alt=""
        aria-hidden="true"
        className="icon-img"
        style={{ width: size, height: size }}
        onError={(e) => e.currentTarget.classList.add('hidden')}
      />
      <span className="icon-fallback">{fallback}</span>
    </span>
  );
}

// =============================================================================
// 잔액 표시 컴포넌트
// =============================================================================

interface BalanceDisplayProps {
  balance: EconomyState;
  isLow?: boolean;
}

function BalanceDisplay({ balance, isLow }: BalanceDisplayProps) {
  const { t } = useTranslation();

  return (
    <div className={`economy-balance ${isLow ? 'balance-low' : ''}`} data-ui-importance="critical">
      <div className="balance-item">
        <CurrencyIcon type="signal" />
        <span className="balance-value" data-testid="signal-balance">
          {balance.signal}
        </span>
        <span className="balance-label">{t('economy.signal')}</span>
      </div>
      {balance.credit > 0 && (
        <div className="balance-credit" title={t('economy.credit_desc')}>
          <span className="credit-label">{t('economy.credit')}: </span>
          <span className="credit-value">-{balance.credit}</span>
        </div>
      )}
      <div className="balance-item">
        <CurrencyIcon type="shard" />
        <span className="balance-value" data-testid="shard-balance">
          {balance.memory_shard}
        </span>
        <span className="balance-label">{t('economy.shard')}</span>
      </div>
      {isLow && (
        <div className="balance-warning" aria-live="polite">
          <span className="warning-icon">⚠</span>
          <span className="warning-text">{t('economy.low_balance_warning')}</span>
        </div>
      )}
    </div>
  );
}

// =============================================================================
// 비용 표시 컴포넌트
// =============================================================================

interface CostDisplayProps {
  /** 비용 유형 */
  type: 'estimate' | 'confirmed';
  /** 비용 범위 (예상) */
  min?: CurrencyAmount;
  max?: CurrencyAmount;
  /** 확정 비용 */
  cost?: CurrencyAmount;
  /** 감당 가능 여부 */
  affordable?: boolean;
  /** 라벨 */
  label?: string;
}

function CostDisplay({ type, min, max, cost, affordable, label }: CostDisplayProps) {
  const { t } = useTranslation();

  const isRange =
    min && max && (min.signal !== max.signal || min.memory_shard !== max.memory_shard);

  const titleKey = type === 'estimate' ? 'economy.estimated_cost' : 'economy.confirmed_cost';
  const cssClass = type === 'estimate' ? 'cost-estimate' : 'cost-confirmed';

  return (
    <div
      className={`economy-cost ${cssClass} ${affordable === false ? 'cost-unaffordable' : ''}`}
      data-ui-importance="critical"
    >
      <div className="cost-header">
        <span className="cost-title">{t(titleKey)}</span>
        {label && <span className="cost-label">{label}</span>}
      </div>
      <div className="cost-values">
        {/* Signal 비용 - U-082: 아이콘 크기 14→18px */}
        <div className="cost-item">
          <CurrencyIcon type="signal" size={18} />
          <span className="cost-value">
            {type === 'estimate' && min && max
              ? isRange
                ? `${min.signal}~${max.signal}`
                : min.signal
              : cost
                ? cost.signal
                : '-'}
          </span>
        </div>
        {/* Shard 비용 (0보다 클 때만 표시) */}
        {((type === 'estimate' && max && max.memory_shard > 0) ||
          (type === 'confirmed' && cost && cost.memory_shard > 0)) && (
          <div className="cost-item">
            <span className="cost-separator">|</span>
            <CurrencyIcon type="shard" size={18} />
            <span className="cost-value">
              {type === 'estimate' && min && max
                ? isRange
                  ? `${min.memory_shard}~${max.memory_shard}`
                  : min.memory_shard
                : cost
                  ? cost.memory_shard
                  : '-'}
            </span>
          </div>
        )}
      </div>
      {affordable === false && (
        <div className="cost-warning">
          <span className="warning-text">{t('economy.insufficient_funds')}</span>
        </div>
      )}
    </div>
  );
}

// =============================================================================
// 거래 장부(Ledger) 항목 컴포넌트
// =============================================================================

function LedgerItem({ entry }: { entry: LedgerEntry }) {
  const { t } = useTranslation();

  // U-099: i18n 언어 혼합 방지 - 키 기반 번역
  // "key|param" 형식이면 파라미터와 함께 번역, 아니면 단순 번역
  const translatedReason = useMemo(() => {
    if (entry.reason.includes('|')) {
      const [key, param] = entry.reason.split('|');
      return `${t(key)}: ${param}`;
    }
    // 키가 존재하지 않으면 t()는 입력된 문자열을 그대로 반환하므로 하드코딩된 텍스트와 호환됨
    return t(entry.reason);
  }, [entry.reason, t]);

  return (
    <div className="ledger-item">
      <div className="ledger-info">
        <span className="ledger-turn">T{entry.turnId}</span>
        <span className="ledger-reason" title={translatedReason}>
          {translatedReason}
        </span>
      </div>
      <div className="ledger-values">
        <span className="ledger-cost">
          -{entry.cost.signal}
          {entry.cost.memory_shard > 0 && ` / -${entry.cost.memory_shard}`}
        </span>
        <span
          className="ledger-model"
          title={entry.modelLabel ? t(`economy.model_label.${entry.modelLabel}`) : undefined}
        >
          {entry.modelLabel?.charAt(0)}
        </span>
      </div>
    </div>
  );
}

// =============================================================================
// 셀렉터 정의 (컴포넌트 외부에서 생성하여 참조 유지)
// =============================================================================

const selectHistory = selectRecentLedger(10);

// =============================================================================
// 메인 Economy HUD 컴포넌트
// =============================================================================

export function EconomyHud({ compact = false, className = '' }: EconomyHudProps) {
  const { t } = useTranslation();

  // Store 상태
  const economy = useWorldStore((state) => state.economy);
  const costEstimate = useEconomyStore(selectCostEstimate);
  const lastCost = useEconomyStore(selectLastCost);
  const isBalanceLow = useEconomyStore(selectIsBalanceLow);
  const recentLedger = useEconomyStore(useShallow(selectHistory));

  // U-049: 거래 장부(Ledger) 최신 항목이 보이도록 스크롤 (하단 스크롤)
  const ledgerListRef = useRef<HTMLDivElement>(null);
  useEffect(() => {
    if (ledgerListRef.current) {
      ledgerListRef.current.scrollTop = ledgerListRef.current.scrollHeight;
    }
  }, [recentLedger]);

  // 예상 비용 감당 가능 여부 계산
  const estimateAffordability = useMemo(() => {
    if (!costEstimate) return null;
    return canAffordEstimate(economy, costEstimate);
  }, [economy, costEstimate]);

  // Compact 모드 (헤더용): 잔액만 표시
  if (compact) {
    return (
      <div
        className={`economy-hud economy-hud-compact ${className}`}
        role="status"
        aria-live="polite"
      >
        <BalanceDisplay balance={economy} isLow={isBalanceLow} />
      </div>
    );
  }

  // Full 모드: 잔액 + 예상 비용 + 확정 비용 + 거래 장부 이력
  return (
    <div
      className={`economy-hud economy-hud-full ${className}`}
      role="region"
      aria-label={t('economy.hud_label')}
    >
      {/* 현재 잔액 */}
      <BalanceDisplay balance={economy} isLow={isBalanceLow} />

      {/* 예상 비용 (카드 선택/호버 시) */}
      {costEstimate && (
        <CostDisplay
          type="estimate"
          min={costEstimate.min}
          max={costEstimate.max}
          affordable={estimateAffordability?.affordable}
          label={costEstimate.label}
        />
      )}

      {/* 마지막 확정 비용 (예상 비용이 없을 때만 표시) */}
      {!costEstimate && lastCost && (
        <CostDisplay
          type="confirmed"
          cost={lastCost.cost}
          label={lastCost.modelLabel ? t(`economy.model_label.${lastCost.modelLabel}`) : undefined}
        />
      )}

      {/* U-079: 잔액 부족 시 대안 안내 + FAST 폴백 라벨 */}
      {isBalanceLow && (
        <div
          className="economy-alternatives economy-alternatives-enhanced"
          data-ui-importance="critical"
        >
          <div className="alternatives-header">
            <span className="alternatives-icon">{'\u26A1'}</span>
            <span className="alternatives-title">{t('economy.low_balance_title')}</span>
          </div>
          <div className="fast-fallback-notice">
            <span className="fast-fallback-badge">FAST</span>
            <span className="fast-fallback-text">{t('economy.fast_fallback_notice')}</span>
          </div>
          <ul className="alternatives-list">
            <li>{t('economy.hint_sell_items')}</li>
            <li>{t('economy.hint_earn_actions')}</li>
            <li>{t('economy.hint_complete_quests')}</li>
          </ul>
        </div>
      )}

      {/* 거래 장부 이력 (Ledger) */}
      <div className="economy-ledger">
        <div className="ledger-header">
          <span className="ledger-title">{t('economy.ledger_title')}</span>
        </div>
        {recentLedger.length > 0 ? (
          <div className="ledger-list" ref={ledgerListRef}>
            {recentLedger.map((entry) => (
              <LedgerItem key={`${entry.turnId}-${entry.timestamp}`} entry={entry} />
            ))}
          </div>
        ) : (
          <div className="ledger-empty">{t('economy.ledger_empty')}</div>
        )}
      </div>
    </div>
  );
}

// =============================================================================
// 헤더용 간소화 컴포넌트 (GameHeader 통합용)
// =============================================================================

export interface EconomyHudHeaderProps {
  signal: number;
  memoryShard: number;
  credit: number;
  isLow?: boolean;
}

/**
 * GameHeader에서 사용하는 간소화된 Economy HUD.
 * 기존 GameHeader의 economy-hud를 대체합니다.
 */
export function EconomyHudHeader({ signal, memoryShard, credit, isLow }: EconomyHudHeaderProps) {
  const { t } = useTranslation();
  const costEstimate = useEconomyStore(selectCostEstimate);

  // 예상 비용 감당 가능 여부
  const estimateAffordability = useMemo(() => {
    if (!costEstimate) return null;
    const balance = { signal, memory_shard: memoryShard };
    return canAffordEstimate(balance, costEstimate);
  }, [signal, memoryShard, costEstimate]);

  return (
    <div className={`economy-hud ${isLow ? 'economy-hud-low' : ''}`} data-ui-importance="critical">
      {/* 잔액 표시 */}
      <span className="icon-wrapper signal-icon" aria-label={t('economy.signal')}>
        <img
          src="/ui/icons/signal-24.png"
          alt=""
          aria-hidden="true"
          className="icon-img"
          onError={(e) => e.currentTarget.classList.add('hidden')}
        />
        <span className="icon-fallback">⚡</span>
      </span>
      <span className="currency-value" data-testid="header-signal">
        {t('economy.signal')}: {signal}
      </span>
      {credit > 0 && (
        <span className="credit-value header-credit" title={t('economy.credit_desc')}>
          -{credit}
        </span>
      )}
      <span className="icon-wrapper shard-icon" aria-label={t('economy.shard')}>
        <img
          src="/ui/icons/shard-24.png"
          alt=""
          aria-hidden="true"
          className="icon-img"
          onError={(e) => e.currentTarget.classList.add('hidden')}
        />
        <span className="icon-fallback">💎</span>
      </span>
      <span className="currency-value" data-testid="header-shard">
        {t('economy.shard')}: {memoryShard}
      </span>

      {/* 예상 비용 미니 표시 */}
      {costEstimate && (
        <span
          className={`economy-estimate-mini ${
            estimateAffordability?.affordable === false ? 'unaffordable' : ''
          }`}
          title={t('economy.estimated_cost')}
        >
          <span className="estimate-prefix">→</span>
          <span className="estimate-value">
            -{costEstimate.max.signal}
            {costEstimate.max.memory_shard > 0 && `/${costEstimate.max.memory_shard}`}
          </span>
        </span>
      )}

      {/* 잔액 부족 경고 아이콘 */}
      {isLow && (
        <span className="balance-warning-icon" title={t('economy.low_balance_warning')}>
          ⚠
        </span>
      )}
    </div>
  );
}

export default EconomyHud;
</file>

<file path="frontend/src/components/NarrativeFeed.test.tsx">
import { describe, it, expect, beforeEach, vi, afterEach } from 'vitest';
import { render, screen, act, fireEvent } from '@testing-library/react';
import { NarrativeFeed } from './NarrativeFeed';

// i18next 모킹
vi.mock('react-i18next', () => ({
  useTranslation: () => ({
    t: (key: string, params?: Record<string, unknown>) => {
      if (key === 'narrative.turn_label') return `Turn ${params?.turn}`;
      if (key === 'narrative.streaming_label') return 'Streaming';
      return key;
    },
  }),
}));

describe('NarrativeFeed (U-066: Typewriter Effect)', () => {
  beforeEach(() => {
    vi.useFakeTimers();
    // prefers-reduced-motion 모킹
    Object.defineProperty(window, 'matchMedia', {
      writable: true,
      value: vi.fn().mockImplementation((query) => ({
        matches: false,
        media: query,
        onchange: null,
        addListener: vi.fn(),
        removeListener: vi.fn(),
        addEventListener: vi.fn(),
        removeEventListener: vi.fn(),
        dispatchEvent: vi.fn(),
      })),
    });
  });

  afterEach(() => {
    vi.useRealTimers();
  });

  it('텍스트가 타이핑 효과와 함께 점진적으로 표시되어야 한다', () => {
    const entries = [{ turn: 1, text: 'Hello World' }];
    render(<NarrativeFeed entries={entries} streamingText="" />);

    // 처음에는 한 글자 또는 일부만 표시됨 (TYPING_TICK_MS 지나기 전)
    // 컴포넌트 내부에서 첫 렌더링 시 typedLen은 0임
    expect(screen.queryByText('Hello World')).toBeNull();

    // 시간 진행
    act(() => {
      vi.advanceTimersByTime(500); // 충분한 시간 진행
    });

    // 일부 텍스트가 표시됨 (정확한 글자 수는 CPS에 따라 다름)
    const textElement = screen.getByText(/Hel/);
    expect(textElement).toBeDefined();

    // 완료될 때까지 시간 진행
    act(() => {
      vi.advanceTimersByTime(10000);
    });

    expect(screen.getByText('Hello World')).toBeDefined();
  });

  it('클릭해도 fast-forward 없이 점진적으로 표시되어야 한다', () => {
    const entries = [{ turn: 1, text: 'This is a long text to test no fast forward' }];
    render(<NarrativeFeed entries={entries} streamingText="" />);

    expect(screen.queryByText(entries[0].text)).toBeNull();

    // 클릭 이벤트 발생 — fast-forward가 제거되었으므로 즉시 표시되지 않아야 함
    const feed = screen.getByRole('log');
    fireEvent.click(feed);

    // 여전히 전체 텍스트는 표시되지 않음
    expect(screen.queryByText(entries[0].text)).toBeNull();

    // 충분한 시간 경과 후 전체 표시됨
    act(() => {
      vi.advanceTimersByTime(10000);
    });
    expect(screen.getByText(entries[0].text)).toBeDefined();
  });

  it('스트리밍 중에는 스트리밍 텍스트에 타이핑 효과가 적용되어야 한다', () => {
    const entries = [{ turn: 1, text: 'Previous text' }];
    const streamingText = 'Current streaming text';
    render(<NarrativeFeed entries={entries} streamingText={streamingText} isStreaming={true} />);

    // 이전 텍스트는 보이고, 스트리밍 텍스트는 타이핑 중
    expect(screen.getByText('Previous text')).toBeDefined();
    expect(screen.queryByText('Current streaming text')).toBeNull();

    act(() => {
      vi.advanceTimersByTime(30000); // TARGET_DURATION_MS_WHILE_STREAMING
    });

    expect(screen.getByText('Current streaming text')).toBeDefined();
  });

  it('isImageLoading 상태에 따라 타이핑 완료 시점이 달라져야 한다 (U-086)', () => {
    // 약 100자 정도의 텍스트 (CPS 계산을 위해)
    const text =
      'This is a test narrative text that should take some time to type out completely for testing.'.repeat(
        2,
      );
    const entries = [{ turn: 1, text }];

    // 1. 이미지 로딩 중 (느린 모드: ~12초 목표)
    const { unmount } = render(
      <NarrativeFeed entries={entries} streamingText="" isImageLoading={true} />,
    );

    // 5초 경과 시점 - 아직 완료되지 않아야 함 (12초 목표이므로)
    act(() => {
      vi.advanceTimersByTime(5000);
    });
    expect(screen.queryByText(text)).toBeNull();

    // 13초 경과 시점 - 완료되어야 함
    act(() => {
      vi.advanceTimersByTime(8000);
    });
    expect(screen.getByText(text)).toBeDefined();
    unmount();

    // 2. 이미지 완료/없음 상태 (빠른 모드: ~2.5초 목표)
    render(<NarrativeFeed entries={entries} streamingText="" isImageLoading={false} />);

    // 1초 경과 시점 - 아직 미완료
    act(() => {
      vi.advanceTimersByTime(1000);
    });
    expect(screen.queryByText(text)).toBeNull();

    // 3초 경과 시점 - 완료되어야 함
    act(() => {
      vi.advanceTimersByTime(2000);
    });
    expect(screen.getByText(text)).toBeDefined();
  });

  it('타이핑 완료 후 이미지 로딩 중이면 상태 라벨이 표시되고, 로딩 완료 시 사라져야 한다 (U-086)', () => {
    const text = 'Short text';
    const entries = [{ turn: 1, text }];
    const { rerender } = render(
      <NarrativeFeed entries={entries} streamingText="" isImageLoading={true} />,
    );

    // 1. 타이핑 완료 전 - 라벨 없음
    expect(screen.queryByText('narrative.image_pending_label')).toBeNull();

    // 2. 타이핑 완료 - 라벨 노출
    act(() => {
      vi.advanceTimersByTime(5000);
    });
    expect(screen.getByText(text)).toBeDefined();
    expect(screen.getByText('narrative.image_pending_label')).toBeDefined();

    // 3. 이미지 로딩 완료 - 라벨 제거
    rerender(<NarrativeFeed entries={entries} streamingText="" isImageLoading={false} />);
    expect(screen.queryByText('narrative.image_pending_label')).toBeNull();
  });

  it('타이핑 중 이미지가 도착하면 속도가 빨라져야 한다 (U-086)', () => {
    const longText = 'Very long text... '.repeat(30);
    const entries = [{ turn: 1, text: longText }];
    const { rerender } = render(
      <NarrativeFeed entries={entries} streamingText="" isImageLoading={true} />,
    );

    // 2초 경과 (느린 모드)
    act(() => {
      vi.advanceTimersByTime(2000);
    });
    const lenAt2s = screen.queryByText(/Very long/)?.textContent?.length || 0;

    // 이미지가 도중에 도착함
    rerender(<NarrativeFeed entries={entries} streamingText="" isImageLoading={false} />);

    // 1초 더 경과 (이제 빠른 모드이므로 훨씬 더 많이 출력되어야 함)
    act(() => {
      vi.advanceTimersByTime(1000);
    });
    const lenAt3s = screen.queryByText(/Very long/)?.textContent?.length || 0;

    const progressAfterImage = lenAt3s - lenAt2s;
    const progressBeforeImage = lenAt2s;

    // 1초(빠른 모드) 진행분이 2초(느린 모드) 진행분보다 많아야 함 (12s vs 2.5s 비율상)
    expect(progressAfterImage).toBeGreaterThan(progressBeforeImage / 2);
  });

  it('action_log 타입의 엔트리는 ▶ 아이콘과 함께 표시되어야 한다 (U-070)', () => {
    const entries = [{ turn: 1, text: 'Action log message', type: 'action_log' as const }];
    render(<NarrativeFeed entries={entries} streamingText="" />);

    // 충분한 시간 경과하여 타이핑 완료
    act(() => {
      vi.advanceTimersByTime(10000);
    });

    expect(screen.getByText('Action log message')).toBeDefined();
    expect(screen.getByText('▶')).toBeDefined();
    // action-log-entry 클래스가 포함된 요소가 있어야 함
    const entry = screen.getByText('Action log message').closest('.narrative-entry');
    expect(entry?.className).toContain('action-log-entry');
  });
});
</file>

<file path="frontend/src/components/NarrativeFeed.tsx">
/**
 * Unknown World - NarrativeFeed 컴포넌트 (U-066 + U-086: 텍스트 우선 타이핑 출력)
 *
 * 내러티브 텍스트에 타이핑(Typewriter) 효과를 적용하여,
 * 이미지 생성 지연을 자연스럽게 흡수합니다.
 *
 * 설계 원칙 (U-086 + streaming buffering):
 *   - 스트리밍 중: useStreamingTypewriter로 서버 속도와 무관하게 ~12초에 걸쳐 점진 출력
 *   - 스트리밍 종료 후: useTypewriter로 entries 텍스트 이어서 타이핑
 *   - 이미지 생성 중(isImageLoading): 느린 타이핑 속도
 *   - 타이핑 완료 후에도 이미지 미도착 시: "이미지 형성 중…" 상태 라인 표시
 *   - fast-forward 없음: 항상 점진 출력
 *   - 접근성: prefers-reduced-motion 설정 존중
 *
 * @module components/NarrativeFeed
 */

import { useEffect, useRef, useState, useMemo } from 'react';
import { useTranslation } from 'react-i18next';
import type { NarrativeEntry } from '../stores/worldStore';

// =============================================================================
// 상수 정의 (U-066 + U-086)
// =============================================================================

/** 타이핑 인터벌 (ms) - ~30fps로 부드러운 타이핑 연출 */
const TYPING_TICK_MS = 32;

/**
 * 이미지 생성 중 느린 모드 목표 시간 (ms)
 * U-086 Q1 Option A: isImageLoading이면 무조건 느린 모드 (~12초 목표, 체감 우선)
 */
const TARGET_DURATION_MS_WHILE_STREAMING = 12000;

/**
 * 유휴 상태(이미지 완료/없음) 빠른 모드 목표 시간 (ms)
 * 이미지가 도착하면 남은 텍스트를 빠르게 출력
 */
const TARGET_DURATION_MS_IDLE = 2500;

/** 최소 CPS (characters per second) - 매우 긴 텍스트에서도 최소 속도 보장 */
const MIN_CPS = 10;

/** 최대 CPS - 짧은 텍스트도 빠르게 표시 가능 */
const MAX_CPS = 400;

// =============================================================================
// 유틸리티 함수
// =============================================================================

/** 값을 min~max 범위로 제한합니다. */
function clamp(value: number, min: number, max: number): number {
  return Math.max(min, Math.min(max, value));
}

// =============================================================================
// 타입 정의
// =============================================================================

interface NarrativeFeedProps {
  entries: NarrativeEntry[];
  streamingText: string;
  /** U-066: 스트리밍 중인지 여부 (타이핑 속도 결정에 사용) */
  isStreaming?: boolean;
  /** U-066: 이미지 로딩 중인지 여부 (타이핑 속도 결정에 사용) */
  isImageLoading?: boolean;
}

// =============================================================================
// 커스텀 훅: useStreamingTypewriter (스트리밍 텍스트 버퍼링)
// =============================================================================

/**
 * 스트리밍 중인 텍스트를 점진적으로 표시하는 훅.
 *
 * 서버에서 narrative_delta가 빠르게 도착해도 화면에는 CPS 제한에 따라
 * 천천히 표시되어 이미지 생성 시간(~10초)을 자연스럽게 흡수합니다.
 * fast-forward 기능 없음 — 항상 점진 출력.
 *
 * @param streamingText - 서버에서 누적된 스트리밍 텍스트 (빈 문자열이면 비활성)
 * @returns displayedText, displayedLen, isTyping
 */
function useStreamingTypewriter(streamingText: string) {
  const [displayedLen, setDisplayedLen] = useState(0);

  // prefers-reduced-motion 감지
  const [prefersReducedMotion, setPrefersReducedMotion] = useState(() => {
    if (typeof window === 'undefined') return false;
    return window.matchMedia('(prefers-reduced-motion: reduce)').matches;
  });

  useEffect(() => {
    if (typeof window === 'undefined') return;
    const mediaQuery = window.matchMedia('(prefers-reduced-motion: reduce)');
    const handleChange = (e: MediaQueryListEvent) => setPrefersReducedMotion(e.matches);
    mediaQuery.addEventListener('change', handleChange);
    return () => mediaQuery.removeEventListener('change', handleChange);
  }, []);

  // 새로운 스트리밍이 시작될 때만 displayedLen 리셋
  const [prevStreaming, setPrevStreaming] = useState(streamingText);
  if (streamingText && !prevStreaming) {
    setPrevStreaming(streamingText);
    setDisplayedLen(0);
  } else if (streamingText !== prevStreaming) {
    setPrevStreaming(streamingText);
  }

  // CPS 계산: 현재 버퍼 길이 기준으로 목표 시간에 맞춤
  const charsPerTick = useMemo(() => {
    if (!streamingText || streamingText.length === 0) return 1;
    const cps = clamp(
      streamingText.length / (TARGET_DURATION_MS_WHILE_STREAMING / 1000),
      MIN_CPS,
      MAX_CPS,
    );
    return Math.max(1, Math.round((cps * TYPING_TICK_MS) / 1000));
  }, [streamingText]);

  // 타이핑 루프
  useEffect(() => {
    if (!streamingText || prefersReducedMotion) return;
    if (displayedLen >= streamingText.length) return;

    const intervalId = setInterval(() => {
      setDisplayedLen((prev) => {
        const next = prev + charsPerTick;
        return next >= streamingText.length ? streamingText.length : next;
      });
    }, TYPING_TICK_MS);

    return () => clearInterval(intervalId);
  }, [streamingText, displayedLen, charsPerTick, prefersReducedMotion]);

  const displayedText = useMemo(() => {
    if (!streamingText) return '';
    if (prefersReducedMotion) return streamingText;
    return streamingText.slice(0, displayedLen);
  }, [streamingText, displayedLen, prefersReducedMotion]);

  const isTyping = !!streamingText && displayedLen < streamingText.length && !prefersReducedMotion;

  return { displayedText, displayedLen, isTyping };
}

// =============================================================================
// 커스텀 훅: useTypewriter (U-066)
// =============================================================================

/**
 * 타이핑 효과를 위한 커스텀 훅
 *
 * @param targetText - 타이핑 대상 텍스트
 * @param shouldBuyTime - 느린 타이핑 모드 사용 여부
 * @param initialLength - 이미 표시된 문자 수 (스트리밍 후 전환 시 재타이핑 방지, U-097)
 * @returns 타이핑 상태 및 제어 함수
 */
function useTypewriter(targetText: string, shouldBuyTime: boolean, initialLength: number = 0) {
  const [typedLen, setTypedLen] = useState(0);
  const [lastTargetText, setLastTargetText] = useState(targetText);

  // prefers-reduced-motion 감지
  const [prefersReducedMotion, setPrefersReducedMotion] = useState(() => {
    if (typeof window === 'undefined') return false;
    return window.matchMedia('(prefers-reduced-motion: reduce)').matches;
  });

  // CPS 계산
  const cps = useMemo(() => {
    if (!targetText || targetText.length === 0) return MIN_CPS;
    const durationMs = shouldBuyTime ? TARGET_DURATION_MS_WHILE_STREAMING : TARGET_DURATION_MS_IDLE;
    const calculatedCps = targetText.length / (durationMs / 1000);
    return clamp(calculatedCps, MIN_CPS, MAX_CPS);
  }, [targetText, shouldBuyTime]);

  // 틱당 문자 수 계산
  const charsPerTick = useMemo(() => {
    return Math.max(1, Math.round((cps * TYPING_TICK_MS) / 1000));
  }, [cps]);

  // reduced-motion 미디어 쿼리 감지
  useEffect(() => {
    if (typeof window === 'undefined') return;

    const mediaQuery = window.matchMedia('(prefers-reduced-motion: reduce)');
    const handleChange = (e: MediaQueryListEvent) => {
      setPrefersReducedMotion(e.matches);
    };

    mediaQuery.addEventListener('change', handleChange);
    return () => mediaQuery.removeEventListener('change', handleChange);
  }, []);

  // 타이핑 대상 텍스트가 변경되면 상태 초기화
  // U-097: initialLength가 있으면 이미 표시된 위치부터 시작 (스트리밍→entries 전환 시 플래시 방지)
  if (targetText !== lastTargetText) {
    setLastTargetText(targetText);
    const startPos = initialLength > 0 ? Math.min(initialLength, targetText.length) : 0;
    setTypedLen(startPos);
  }

  // 타이핑 루프
  useEffect(() => {
    // 이미 완료된 경우
    if (typedLen >= targetText.length) {
      return;
    }

    // reduced-motion이면 즉시 완료
    if (prefersReducedMotion) {
      const rafId = requestAnimationFrame(() => {
        setTypedLen(targetText.length);
      });
      return () => cancelAnimationFrame(rafId);
    }

    const intervalId = setInterval(() => {
      setTypedLen((prev) => {
        const next = prev + charsPerTick;
        return next >= targetText.length ? targetText.length : next;
      });
    }, TYPING_TICK_MS);

    return () => clearInterval(intervalId);
  }, [targetText, typedLen, charsPerTick, prefersReducedMotion]);

  // 표시할 텍스트 계산
  const visibleText = useMemo(() => {
    if (prefersReducedMotion) {
      return targetText;
    }
    return targetText.slice(0, typedLen);
  }, [targetText, typedLen, prefersReducedMotion]);

  // 타이핑 진행 중인지 여부
  const isTyping = typedLen < targetText.length && !prefersReducedMotion;

  return {
    visibleText,
    isTyping,
  };
}

// =============================================================================
// 컴포넌트 구현
// =============================================================================

export function NarrativeFeed({
  entries,
  streamingText,
  isStreaming: _isStreaming = false, // U-097: prop 유지 (향후 사용 가능, API 호환성)
  isImageLoading = false,
}: NarrativeFeedProps) {
  const { t } = useTranslation();
  const feedRef = useRef<HTMLDivElement>(null);

  // 스트리밍 텍스트 버퍼링 타이프라이터
  const {
    displayedText: streamingDisplayedText,
    displayedLen: streamingDisplayedLen,
    isTyping: isStreamTyping,
  } = useStreamingTypewriter(streamingText);

  // U-097: 스트리밍에서 실제 화면에 표시된 길이를 추적 (스트리밍→entries 전환 시 재타이핑 방지)
  const [initialLength, setInitialLength] = useState(0);

  // 스트리밍 종료 감지 및 initialLength 설정
  const [prevStreamingForInit, setPrevStreamingForInit] = useState(streamingText);
  if (streamingText !== prevStreamingForInit) {
    setPrevStreamingForInit(streamingText);
    if (!streamingText && streamingDisplayedLen > 0) {
      setInitialLength(streamingDisplayedLen);
    }
  }

  // U-097: typewriter 대상 텍스트 결정
  // 스트리밍 중: typewriter 사용하지 않음 (streamingText를 직접 표시)
  // 스트리밍 종료 후: entries의 마지막 텍스트를 typewriter 대상으로 설정
  const typewriterTarget = useMemo(() => {
    if (streamingText) return ''; // 스트리밍 중엔 typewriter 불필요
    if (entries.length > 0) return entries[entries.length - 1].text;
    return '';
  }, [streamingText, entries]);

  // U-097: initialLength가 사용된 후 리셋 (다음 턴에 영향 방지)
  useEffect(() => {
    if (initialLength > 0 && typewriterTarget) {
      // typewriter가 initialLength를 참조한 후 다음 렌더에서 리셋
      const raf = requestAnimationFrame(() => setInitialLength(0));
      return () => cancelAnimationFrame(raf);
    }
  }, [initialLength, typewriterTarget]);

  // U-066: 시간을 벌어야 하는지 여부 (느린 타이핑)
  const shouldBuyTime = isImageLoading;

  // U-066: 타이핑 효과 훅 (스트리밍 중에는 빈 문자열이므로 비활성)
  const { visibleText, isTyping } = useTypewriter(typewriterTarget, shouldBuyTime, initialLength);

  // 새 엔트리 추가 시 스크롤 (스트리밍 표시 텍스트 변경 시에도 스크롤)
  useEffect(() => {
    if (feedRef.current) {
      feedRef.current.scrollTop = feedRef.current.scrollHeight;
    }
  }, [entries, visibleText, streamingDisplayedText]);

  // U-066: 마지막 엔트리 타이핑 중 중복 표시 방지
  const shouldHideLastEntry = !streamingText && entries.length > 0 && isTyping;

  // U-097: 활성 텍스트 영역 표시 여부
  // 스트리밍 중이거나 타이핑 중일 때 활성 텍스트 영역을 표시
  const showActiveTextArea = !!streamingText || shouldHideLastEntry;

  return (
    <div className="narrative-feed" ref={feedRef} role="log" aria-live="polite">
      {entries.map((entry, index) => {
        // U-066: 마지막 엔트리 타이핑 중 숨김 처리
        const isLastEntry = index === entries.length - 1;
        if (shouldHideLastEntry && isLastEntry) {
          return null;
        }

        // U-070: 엔트리 타입에 따른 클래스 및 스타일 결정
        const entryType = entry.type ?? 'narrative';
        const isActionLog = entryType === 'action_log';
        const isSystem = entryType === 'system';
        // U-125: 이전 턴 vs 현재 턴 시각 계층 구분
        // - 유휴 상태(showActiveTextArea=false)이고 마지막 엔트리 → 현재 턴으로 밝게 유지
        // - 그 외 → 이전 턴으로 약화 (past-entry)
        const isCurrentIdleTurn = isLastEntry && !showActiveTextArea;
        const entryClassName = [
          'narrative-entry',
          isCurrentIdleTurn ? 'narrative-active-text' : 'past-entry',
          isActionLog && 'action-log-entry',
          isSystem && 'system-entry',
        ]
          .filter(Boolean)
          .join(' ');

        return (
          <div key={`${entry.turn}-${index}`} className={entryClassName}>
            {/* U-070: 액션 로그는 ▶ 아이콘 표시, 턴 라벨 숨김 */}
            {isActionLog ? (
              <span className="action-log-icon" aria-hidden="true">
                ▶
              </span>
            ) : (
              <span className="narrative-timestamp">
                {t('narrative.turn_label', { turn: entry.turn })}
              </span>
            )}
            <span className="narrative-text">{entry.text}</span>
          </div>
        );
      })}

      {/* U-097: 활성 텍스트 영역 - 스트리밍 실시간 출력 또는 타이핑 효과 */}
      {/* U-125: narrative-active-text 클래스로 현재 턴 강조 유지 */}
      {showActiveTextArea && (
        <div
          className={`narrative-entry narrative-active-text ${streamingText ? 'streaming' : 'typing'}`}
        >
          <span className="narrative-timestamp">
            {streamingText
              ? t('narrative.streaming_label')
              : t('narrative.turn_label', { turn: entries[entries.length - 1]?.turn ?? 0 })}
          </span>
          {/* 스트리밍 중 → 버퍼링된 텍스트 점진 표시, 아니면 → typewriter 결과 */}
          <span className="narrative-text">{streamingDisplayedText || visibleText}</span>
          {(isStreamTyping || isTyping) && <span className="cursor-blink">▌</span>}
        </div>
      )}

      {/* U-086: 이미지 pending 상태 라인
          타이핑이 완료된 후에도 이미지가 아직 생성 중이면 대기 이유를 명확히 표시.
          RULE-002: 게임 로그 시스템 메시지 스타일 (채팅 버블 아님)
          RULE-006: i18n 키 기반 메시지 */}
      {!isTyping && !isStreamTyping && !streamingText && isImageLoading && (
        <div
          className="narrative-entry system-entry image-pending-line"
          role="status"
          aria-live="polite"
        >
          <span className="image-pending-label">{t('narrative.image_pending_label')}</span>
          <span className="image-pending-cursor" aria-hidden="true">
            ▌
          </span>
        </div>
      )}
    </div>
  );
}
</file>

<file path="frontend/src/components/SceneCanvas.tsx">
/**
 * Unknown World - Scene Canvas 컴포넌트
 *
 * RULE-002 준수: 채팅 버블이 아닌 게임 UI
 * RULE-009 준수: 좌표 규약 (0~1000 정규화, bbox=[ymin,xmin,ymax,xmax])
 *
 * U-010[Mvp]: 핫스팟 오버레이 + 클릭 처리
 * - TurnOutput의 objects[]/hotspots[]를 기반으로 오버레이 렌더
 * - hover 시 하이라이트/툴팁 표시
 * - click 시 object_id + box_2d를 TurnInput에 포함해 전송
 *
 * U-012[Mvp]: DnD 드롭 타겟 확장
 * - 핫스팟을 droppable 영역으로 만들어 인벤토리 아이템 드롭 처리
 * - 드래그 오버 시 하이라이트 강화
 * - 드롭 성공/실패 즉시 시각화
 *
 * U-020[Mvp]: 이미지 Lazy Render (placeholder/폴백)
 * - RULE-004/008 준수: 텍스트 우선 + Lazy 이미지 정책
 * - Q1 Option A: 이전 이미지 유지 + 로딩 인디케이터 표시
 * - 이미지 실패 시에도 핫스팟/패널/로그는 계속 동작 (텍스트-only 진행)
 *
 * U-058[Mvp]: 핫스팟 디자인 개선
 * - Q1 Option C: Magenta/Purple 계열 강조
 * - Q2 Option A: L자 브라켓 코너 마커
 * - Hotspot 컴포넌트 분리로 시각적 품질 향상
 *
 * @module components/SceneCanvas
 */

import { useState, useRef, useCallback, useEffect, useMemo } from 'react';
import { useTranslation } from 'react-i18next';
import { type CanvasSize } from '../utils/box2d';
import { isHotspotInteractionAllowed, compareHotspotPriority } from '../dnd/types';
import { useWorldStore } from '../stores/worldStore';
import { useAgentStore } from '../stores/agentStore';
import { SceneImage } from './SceneImage';
import { Hotspot, type HotspotClickData } from './Hotspot';

// =============================================================================
// 타입 정의 (Re-export for backward compatibility)
// =============================================================================

export type { HotspotClickData };

interface SceneCanvasProps {
  /** 핫스팟 클릭 콜백 */
  onHotspotClick?: (data: HotspotClickData) => void;
  /** 스트리밍 중 여부 (비활성화용, 생략 시 agentStore.isStreaming 사용) */
  disabled?: boolean;
}

// =============================================================================
// 메인 컴포넌트
// =============================================================================

/**
 * Scene Canvas 컴포넌트
 *
 * U-010[Mvp]: 핫스팟 오버레이 + 클릭 처리
 * U-020[Mvp]: Lazy Render (placeholder/폴백)
 * U-031[Mvp]: Placeholder Pack
 *
 * - 상태에 따라 placeholder 이미지와 라벨을 표시합니다.
 * - 'scene' 상태에서는 실제 이미지를 렌더링하며, 로드 실패 시 폴백을 제공합니다.
 * - U-020: Q1 Option A - 이전 이미지 유지 + 로딩 인디케이터 표시
 * - objects 배열이 있으면 핫스팟 오버레이를 렌더링합니다.
 */
export function SceneCanvas({ onHotspotClick, disabled: propsDisabled }: SceneCanvasProps) {
  const { t } = useTranslation();

  // Store 상태 (RU-003: 컴포넌트 내에서 직접 구독)
  const state = useWorldStore((state) => state.sceneState);
  const objects = useWorldStore((state) => state.sceneObjects);
  const isAnalyzing = useWorldStore((state) => state.isAnalyzing);
  const isStreaming = useAgentStore((state) => state.isStreaming);

  const disabled = propsDisabled ?? isStreaming;

  // U-071: 처리 단계 및 이미지 로딩 상태 추출
  const { status, imageUrl, message, processingPhase, imageLoading } = state;

  // U-085: Store에서 setSceneCanvasSize 가져오기 (SSOT)
  const setSceneCanvasSize = useWorldStore((state) => state.setSceneCanvasSize);

  const [canvasSize, setCanvasSize] = useState<CanvasSize>({ width: 0, height: 0 });
  const canvasRef = useRef<HTMLDivElement>(null);

  // RU-003-S2 Step 3: ResizeObserver에 디바운스 적용
  // 드래그 중 핫스팟 영역이 과도하게 흔들리는 것을 방지
  // U-097: ResizeObserver 콜백에서는 로컬 상태(setCanvasSize)만 갱신한다.
  //        Zustand store 갱신(setSceneCanvasSize)은 아래 별도 useEffect로 분리.
  useEffect(() => {
    const element = canvasRef.current;
    if (!element) return;

    let resizeTimeout: ReturnType<typeof setTimeout> | null = null;
    const RESIZE_DEBOUNCE_MS = 100; // 디바운스 간격

    const resizeObserver = new ResizeObserver((entries) => {
      // 디바운스: 마지막 리사이즈 이벤트 후 일정 시간 후에만 업데이트
      if (resizeTimeout) {
        clearTimeout(resizeTimeout);
      }
      resizeTimeout = setTimeout(() => {
        for (const entry of entries) {
          const { width, height } = entry.contentRect;
          // 의미 있는 크기 변화만 적용 (5px 이상 차이)
          setCanvasSize((prev) => {
            if (Math.abs(prev.width - width) > 5 || Math.abs(prev.height - height) > 5) {
              return { width, height };
            }
            return prev;
          });
        }
      }, RESIZE_DEBOUNCE_MS);
    });

    resizeObserver.observe(element);

    // 초기 크기 설정 (로컬 상태만)
    const rect = element.getBoundingClientRect();
    setCanvasSize({ width: rect.width, height: rect.height });

    return () => {
      if (resizeTimeout) {
        clearTimeout(resizeTimeout);
      }
      resizeObserver.disconnect();
    };
  }, []);

  // U-097: canvasSize → Zustand store 동기화 (별도 렌더 사이클)
  // Q1 Option A: setSceneCanvasSize를 의존성 배열에 포함 (Zustand의 set은 안정 참조, lint 경고 방지)
  // 이로써 useState 업데이터 내부에서 외부 store를 갱신하는 React 금지 패턴을 회피한다.
  useEffect(() => {
    if (canvasSize.width > 0 && canvasSize.height > 0) {
      setSceneCanvasSize(canvasSize);
    }
  }, [canvasSize, setSceneCanvasSize]);

  // 핫스팟 클릭 핸들러
  const handleHotspotClick = useCallback(
    (data: HotspotClickData) => {
      if (onHotspotClick) {
        onHotspotClick(data);
      }
    },
    [onHotspotClick],
  );

  // RU-003-S2 Step 1: 핫스팟 렌더링 조건을 SSOT로 고정
  // - isHotspotInteractionAllowed()로 허용 상태 검사 (scene, default)
  // - objects 존재 + 캔버스 크기 확보
  // U-020: 이미지 유무와 무관하게 핫스팟은 동작 (RULE-004)
  const isInteractionAllowed = isHotspotInteractionAllowed(status);
  const shouldRenderHotspots = isInteractionAllowed && objects.length > 0 && canvasSize.width > 0;

  // RU-003-S2: 데모 상태 여부 (시각적 힌트 필요)
  const isDemoState = status === 'default';

  // RU-003-S2 Step 2: 핫스팟을 면적 기준으로 정렬 (작은 것이 뒤에 = 높은 z-index)
  const sortedObjects = useMemo(() => {
    if (objects.length <= 1) return objects;
    return [...objects].sort((a, b) => compareHotspotPriority(a.box_2d, b.box_2d));
  }, [objects]);

  return (
    <div ref={canvasRef} className="scene-canvas">
      {/* U-020: 장면 이미지 (Lazy loading + placeholder/폴백 포함) */}
      {/* U-071: 처리 단계 및 이미지 생성 상태 전달 */}
      {/* U-089: 정밀분석 상태 전달 (기존 이미지 유지 + 분석 오버레이) */}
      <SceneImage
        status={status}
        imageUrl={imageUrl}
        message={message}
        processingPhase={processingPhase}
        isGenerating={imageLoading}
        isAnalyzing={isAnalyzing}
      />

      {/* 핫스팟 오버레이 레이어 (RU-003-S2: 면적순 정렬) */}
      {/* U-020: 이미지 유무와 무관하게 핫스팟은 항상 렌더 (RULE-004) */}
      {/* U-058: Hotspot 컴포넌트 분리 (Magenta 테마 + L자 코너) */}
      {shouldRenderHotspots && (
        <div className="hotspot-layer" aria-label={t('scene.hotspot.layer_label')}>
          {sortedObjects.map((obj, index) => (
            <Hotspot
              key={obj.id}
              object={obj}
              canvasSize={canvasSize}
              onClick={handleHotspotClick}
              disabled={disabled}
              isDemoState={isDemoState}
              // RU-003-S2 Step 2: 인덱스 기반 z-index로 작은 것이 위에 표시
              style={{ zIndex: index + 1 }}
            />
          ))}
        </div>
      )}
    </div>
  );
}
</file>

<file path="frontend/src/data/demoProfiles.ts">
/**
 * Unknown World - 데모 프로필 정의 (U-015[Mvp], U-116[Mvp]).
 *
 * 로그인 없이 즉시 시작 가능한 데모 프로필 3종을 정의합니다.
 * 각 프로필은 서로 다른 초기 상태(재화/인벤토리/퀘스트/룰)를 가집니다.
 *
 * U-116: SaveGame 중간 단계 제거. 프로필 데이터는 sessionLifecycle에서
 * store에 직접 적용됩니다.
 *
 * 프로필:
 *   1. Narrator: 내러티브/스토리 중심 체험
 *   2. Explorer: 탐색/발견 중심 체험
 *   3. Tech Enthusiast: 시스템/메커닉 중심 체험
 *
 * 설계 원칙:
 *   - RULE-006: 표시 문자열은 i18n 키 기반
 *   - PRD 6.9: 데모 프로필 3종 + 즉시 리셋
 *
 * @module data/demoProfiles
 */

// =============================================================================
// 프로필 타입 정의
// =============================================================================

/**
 * 데모 프로필 정의 (언어 중립).
 * 표시용 문자열은 i18n 키로 참조합니다.
 */
export interface DemoProfileDef {
  /** 프로필 고유 ID */
  id: string;
  /** 프로필 이름 i18n 키 */
  nameKey: string;
  /** 프로필 설명 i18n 키 */
  descriptionKey: string;
  /** 프로필 아이콘 (이모지) */
  icon: string;
  /** 프로필 테마 색상 (CSS 변수명 또는 hex) */
  themeColor: string;
}

/**
 * 프로필 초기 상태.
 * sessionLifecycle에서 store에 직접 적용됩니다.
 */
export interface DemoProfileInitialState {
  /** 초기 재화 */
  economy: {
    signal: number;
    memory_shard: number;
    credit: number;
  };
  /** 초기 인벤토리 아이템 정의 (ID와 i18n 키) */
  inventoryDefs: Array<{
    id: string;
    nameKey: string;
    icon: string;
    quantity: number;
  }>;
  /** 초기 퀘스트 정의 (U-078: 목표 시스템 강화) */
  questDefs: Array<{
    id: string;
    labelKey: string;
    is_completed: boolean;
    descriptionKey?: string;
    is_main?: boolean;
    progress?: number;
    reward_signal?: number;
  }>;
  /** 초기 규칙 정의 */
  ruleDefs: Array<{
    id: string;
    labelKey: string;
    descriptionKey?: string;
  }>;
  /** 초기 Scene Objects 정의 */
  sceneObjectDefs: Array<{
    id: string;
    labelKey: string;
    hintKey: string;
    box_2d: {
      ymin: number;
      xmin: number;
      ymax: number;
      xmax: number;
    };
  }>;
  /** 환영 메시지 i18n 키 */
  welcomeMessageKey: string;
  /**
   * 사전 생성 첫 씬 이미지 경로 (U-124).
   * nanobanana mcp로 제작한 정적 에셋을 가리킵니다.
   * 프로필 시작 시 Scene Canvas에 즉시 표시됩니다.
   */
  initialSceneImageUrl?: string;
}

/**
 * 데모 프로필 전체 정의.
 */
export interface DemoProfile extends DemoProfileDef {
  initialState: DemoProfileInitialState;
}

// =============================================================================
// 데모 프로필 정의 (3종)
// =============================================================================

/**
 * Narrator 프로필: 내러티브/스토리 중심 체험.
 * 풍부한 재화로 다양한 선택지를 탐색할 수 있습니다.
 */
export const PROFILE_NARRATOR: DemoProfile = {
  id: 'narrator',
  nameKey: 'profile.narrator.name',
  descriptionKey: 'profile.narrator.description',
  icon: '📖',
  themeColor: 'var(--accent-color)',
  initialState: {
    economy: {
      signal: 200,
      memory_shard: 10,
      credit: 0,
    },
    inventoryDefs: [
      {
        id: 'ancient-tome',
        nameKey: 'profile.narrator.items.ancient_tome',
        icon: '📕',
        quantity: 1,
      },
      { id: 'quill-pen', nameKey: 'profile.narrator.items.quill_pen', icon: '🖋️', quantity: 1 },
      {
        id: 'memory-fragment',
        nameKey: 'profile.narrator.items.memory_fragment',
        icon: '💠',
        quantity: 3,
      },
    ],
    questDefs: [
      {
        id: 'quest-discover-origin',
        labelKey: 'profile.narrator.quest.discover_origin',
        descriptionKey: 'profile.narrator.quest.discover_origin_desc',
        is_completed: false,
        is_main: true,
        progress: 0,
        reward_signal: 50,
      },
      {
        id: 'quest-collect-memories',
        labelKey: 'profile.narrator.quest.collect_memories',
        is_completed: false,
        reward_signal: 15,
      },
      {
        id: 'quest-read-ancient-tome',
        labelKey: 'profile.narrator.quest.read_ancient_tome',
        is_completed: false,
        reward_signal: 10,
      },
    ],
    ruleDefs: [
      {
        id: 'rule-time-flows',
        labelKey: 'profile.narrator.rule.time_flows',
        descriptionKey: 'profile.narrator.rule.time_flows_desc',
      },
      {
        id: 'rule-memories-persist',
        labelKey: 'profile.narrator.rule.memories_persist',
        descriptionKey: 'profile.narrator.rule.memories_persist_desc',
      },
    ],
    // U-116: 초기 핫스팟 제거 (U-090 정밀분석 전용 정책 준수)
    sceneObjectDefs: [],
    welcomeMessageKey: 'profile.narrator.welcome',
    // U-124: 사전 생성 첫 씬 이미지 (nanobanana mcp, 서재/도서관)
    initialSceneImageUrl: '/ui/scenes/scene-narrator-start.webp',
  },
};

/**
 * Explorer 프로필: 탐색/발견 중심 체험.
 * 적당한 재화와 탐색 도구로 새로운 영역을 발견합니다.
 */
export const PROFILE_EXPLORER: DemoProfile = {
  id: 'explorer',
  nameKey: 'profile.explorer.name',
  descriptionKey: 'profile.explorer.description',
  icon: '🧭',
  themeColor: 'var(--text-color)',
  initialState: {
    economy: {
      signal: 150,
      memory_shard: 5,
      credit: 0,
    },
    inventoryDefs: [
      { id: 'compass', nameKey: 'profile.explorer.items.compass', icon: '🧭', quantity: 1 },
      { id: 'rope', nameKey: 'profile.explorer.items.rope', icon: '🪢', quantity: 2 },
      { id: 'lantern', nameKey: 'profile.explorer.items.lantern', icon: '🏮', quantity: 1 },
      {
        id: 'map-fragment',
        nameKey: 'profile.explorer.items.map_fragment',
        icon: '🗺️',
        quantity: 1,
      },
    ],
    questDefs: [
      {
        id: 'quest-find-exit',
        labelKey: 'profile.explorer.quest.find_exit',
        descriptionKey: 'profile.explorer.quest.find_exit_desc',
        is_completed: false,
        is_main: true,
        progress: 15,
        reward_signal: 50,
      },
      {
        id: 'quest-explore-areas',
        labelKey: 'profile.explorer.quest.explore_areas',
        is_completed: false,
        reward_signal: 20,
      },
      {
        id: 'quest-gather-supplies',
        labelKey: 'profile.explorer.quest.gather_supplies',
        is_completed: true,
        reward_signal: 10,
      },
    ],
    ruleDefs: [
      {
        id: 'rule-gravity',
        labelKey: 'profile.explorer.rule.gravity',
        descriptionKey: 'profile.explorer.rule.gravity_desc',
      },
      {
        id: 'rule-darkness',
        labelKey: 'profile.explorer.rule.darkness',
        descriptionKey: 'profile.explorer.rule.darkness_desc',
      },
    ],
    // U-116: 초기 핫스팟 제거 (U-090 정밀분석 전용 정책 준수)
    sceneObjectDefs: [],
    welcomeMessageKey: 'profile.explorer.welcome',
    // U-124: 사전 생성 첫 씬 이미지 (nanobanana mcp, 동굴 입구)
    initialSceneImageUrl: '/ui/scenes/scene-explorer-start.webp',
  },
};

/**
 * Tech Enthusiast 프로필: 시스템/메커닉 중심 체험.
 * 제한된 재화로 효율적인 전략을 세워야 합니다.
 */
export const PROFILE_TECH: DemoProfile = {
  id: 'tech',
  nameKey: 'profile.tech.name',
  descriptionKey: 'profile.tech.description',
  icon: '⚙️',
  themeColor: 'var(--warning-color)',
  initialState: {
    economy: {
      signal: 80,
      memory_shard: 15,
      credit: 0,
    },
    inventoryDefs: [
      { id: 'data-core', nameKey: 'profile.tech.items.data_core', icon: '💿', quantity: 1 },
      { id: 'circuit-board', nameKey: 'profile.tech.items.circuit_board', icon: '🔌', quantity: 2 },
      { id: 'energy-cell', nameKey: 'profile.tech.items.energy_cell', icon: '🔋', quantity: 3 },
      { id: 'scanner-device', nameKey: 'profile.tech.items.scanner', icon: '📡', quantity: 1 },
    ],
    questDefs: [
      {
        id: 'quest-analyze-system',
        labelKey: 'profile.tech.quest.analyze_system',
        descriptionKey: 'profile.tech.quest.analyze_system_desc',
        is_completed: false,
        is_main: true,
        progress: 0,
        reward_signal: 40,
      },
      {
        id: 'quest-optimize-resources',
        labelKey: 'profile.tech.quest.optimize_resources',
        is_completed: false,
        reward_signal: 15,
      },
      {
        id: 'quest-scan-terminal',
        labelKey: 'profile.tech.quest.scan_terminal',
        is_completed: false,
        reward_signal: 10,
      },
    ],
    ruleDefs: [
      {
        id: 'rule-energy-conservation',
        labelKey: 'profile.tech.rule.energy_conservation',
        descriptionKey: 'profile.tech.rule.energy_conservation_desc',
      },
      {
        id: 'rule-data-integrity',
        labelKey: 'profile.tech.rule.data_integrity',
        descriptionKey: 'profile.tech.rule.data_integrity_desc',
      },
      {
        id: 'rule-system-limits',
        labelKey: 'profile.tech.rule.system_limits',
        descriptionKey: 'profile.tech.rule.system_limits_desc',
      },
    ],
    // U-116: 초기 핫스팟 제거 (U-090 정밀분석 전용 정책 준수)
    sceneObjectDefs: [],
    welcomeMessageKey: 'profile.tech.welcome',
    // U-124: 사전 생성 첫 씬 이미지 (nanobanana mcp, 실험실)
    initialSceneImageUrl: '/ui/scenes/scene-tech-start.webp',
  },
};

/**
 * 모든 데모 프로필 목록.
 */
export const DEMO_PROFILES: readonly DemoProfile[] = [
  PROFILE_NARRATOR,
  PROFILE_EXPLORER,
  PROFILE_TECH,
] as const;

/**
 * 프로필 ID로 프로필을 찾습니다.
 */
export function findProfileById(profileId: string): DemoProfile | undefined {
  return DEMO_PROFILES.find((p) => p.id === profileId);
}

/**
 * 프로필 목록 정보만 가져옵니다 (선택 UI용).
 */
export function getProfileSummaries(): Array<DemoProfileDef> {
  return DEMO_PROFILES.map((p) => ({
    id: p.id,
    nameKey: p.nameKey,
    descriptionKey: p.descriptionKey,
    icon: p.icon,
    themeColor: p.themeColor,
  }));
}
</file>

<file path="frontend/src/stores/economyStore.ts">
/**
 * Unknown World - Economy 상태 관리 (Zustand) (U-014[Mvp]).
 *
 * Signal/Memory Shard 재화 HUD와 턴별 비용/잔액 변화를
 * **거래 장부(ledger)**로 추적하여 "비용/지연을 게임 메커닉"으로 UX에 반영합니다.
 *
 * 설계 원칙:
 *   - RULE-005: Economy 인바리언트 (잔액 음수 금지, 예상 비용 사전 표시)
 *   - RULE-008: 비용/모델 선택 이유는 라벨(FAST/QUALITY/REF)로만 설명
 *   - Q1 결정: Option A - 최근 N턴만 보관 (UI/메모리 절감)
 *   - RU-004-Q5: 상수는 save/constants.ts에서 중앙 관리
 *
 * @module stores/economyStore
 */

import { create } from 'zustand';
import type { CurrencyAmount, ModelLabel, CostEstimate } from '../schemas/turn';
// RU-004-Q5: 상수 중앙화 - constants.ts에서 import
import { LEDGER_MAX_ENTRIES, LOW_BALANCE_THRESHOLD } from '../save/constants';

// RU-004-Q5: 상수 re-export (기존 호출자 호환성 유지)
export { LEDGER_MAX_ENTRIES };

// =============================================================================
// 타입 정의
// =============================================================================

/**
 * 거래 장부(Ledger) 엔트리.
 * 각 턴에서 발생한 비용과 잔액 변화를 기록합니다.
 */
export interface LedgerEntry {
  /** 턴 ID (턴 카운트) */
  turnId: number;
  /** 액션 ID (선택된 카드 ID, 선택사항) */
  actionId?: string;
  /** 비용 사유 (예: "탐색", "이미지 생성") */
  reason: string;
  /** 소비된 비용 */
  cost: CurrencyAmount;
  /** 소비 후 잔액 */
  balanceAfter: CurrencyAmount;
  /** 모델 라벨 (FAST/QUALITY/CHEAP/REF) */
  modelLabel?: ModelLabel;
  /** 잔액 부족 경고 여부 (U-079) */
  lowBalanceWarning?: boolean;
  /** 기록 시간 */
  timestamp: number;
}

/**
 * 예상 비용 상태.
 * 현재 선택된 액션의 예상 비용을 추적합니다.
 */
export interface CostEstimateState {
  /** 최소 예상 비용 */
  min: CurrencyAmount;
  /** 최대 예상 비용 */
  max: CurrencyAmount;
  /** 예상 비용을 계산한 액션 ID */
  actionId?: string;
  /** 예상 비용 라벨/설명 */
  label?: string;
}

/**
 * 마지막 확정 비용 상태.
 * 가장 최근 턴에서 확정된 비용 정보입니다.
 */
export interface LastCostState {
  /** 확정된 비용 */
  cost: CurrencyAmount;
  /** 확정 후 잔액 */
  balanceAfter: CurrencyAmount;
  /** 턴 ID */
  turnId: number;
  /** 모델 라벨 */
  modelLabel?: ModelLabel;
}

/** Economy Store 상태 */
export interface EconomyStoreState {
  /** 거래 장부 (최근 N개 엔트리, 최신순) */
  ledger: LedgerEntry[];
  /** 현재 예상 비용 (선택한 액션 기반) */
  costEstimate: CostEstimateState | null;
  /** 마지막 확정 비용 */
  lastCost: LastCostState | null;
  /** 잔액 부족 경고 여부 */
  isBalanceLow: boolean;
  /** 잔액 부족 임계값 (Signal 기준) */
  lowBalanceThreshold: number;
}

/** Economy Store 액션 */
export interface EconomyStoreActions {
  /**
   * 턴 완료 시 거래 장부에 엔트리를 추가합니다.
   */
  addLedgerEntry: (entry: Omit<LedgerEntry, 'timestamp'>) => void;

  /**
   * 거래 장부를 외부 데이터로 주입합니다.
   *
   * - ledger는 전달된 순서(최신순)를 유지합니다.
   * - timestamp는 전달된 값을 보존합니다.
   * - lastCost는 최신 엔트리(첫 원소) 기준으로 설정합니다.
   * - isBalanceLow는 전달된 currentBalance로 재계산합니다.
   *
   * @param ledger - 거래 장부 배열 (최신순, timestamp 포함)
   * @param currentBalance - 현재 잔액 (isBalanceLow 계산용)
   */
  hydrateLedger: (ledger: LedgerEntry[], currentBalance: CurrencyAmount) => void;

  /**
   * 예상 비용을 설정합니다 (카드 선택/호버 시).
   */
  setCostEstimate: (estimate: CostEstimateState | null) => void;

  /**
   * 카드의 비용 정보로 예상 비용을 설정합니다.
   */
  setCostEstimateFromCard: (
    cost: CurrencyAmount,
    costEstimate: CostEstimate | null,
    actionId: string,
    label?: string,
  ) => void;

  /**
   * 마지막 확정 비용을 설정합니다 (TurnOutput 반영 시).
   */
  setLastCost: (lastCost: LastCostState) => void;

  /**
   * 잔액 부족 상태를 업데이트합니다.
   */
  updateBalanceLowStatus: (currentBalance: CurrencyAmount) => void;

  /**
   * 잔액 부족 임계값을 설정합니다.
   */
  setLowBalanceThreshold: (threshold: number) => void;

  /**
   * 거래 장부를 초기화합니다.
   */
  clearLedger: () => void;

  /**
   * 전체 상태를 초기화합니다.
   */
  reset: () => void;
}

export type EconomyStore = EconomyStoreState & EconomyStoreActions;

// =============================================================================
// 초기 상태
// =============================================================================

function createInitialState(): EconomyStoreState {
  // U-116: 초기 상태는 빈 거래 장부 (더미 데이터 제거)
  return {
    ledger: [],
    costEstimate: null,
    lastCost: null,
    isBalanceLow: false,
    // RU-004-Q5: 임계값 상수 SSOT (save/constants.ts)
    lowBalanceThreshold: LOW_BALANCE_THRESHOLD,
  };
}

// =============================================================================
// Zustand Store
// =============================================================================

/**
 * Economy 상태 스토어.
 *
 * 턴별 비용/잔액 변화를 거래 장부(ledger)으로 추적하고,
 * 예상 비용과 확정 비용을 UI에 제공합니다.
 *
 * @example
 * ```tsx
 * // 예상 비용 설정 (카드 호버 시)
 * const setCostEstimateFromCard = useEconomyStore(s => s.setCostEstimateFromCard);
 * setCostEstimateFromCard(card.cost, card.cost_estimate, card.id, card.label);
 *
 * // 턴 완료 시 거래 장부 기록
 * const addLedgerEntry = useEconomyStore(s => s.addLedgerEntry);
 * addLedgerEntry({
 *   turnId: turnCount,
 *   reason: 'explore',
 *   cost: turnOutput.economy.cost,
 *   balanceAfter: turnOutput.economy.balance_after,
 * });
 * ```
 */
export const useEconomyStore = create<EconomyStore>((set, get) => ({
  // 초기 상태
  ...createInitialState(),

  // 액션

  addLedgerEntry: (entry) => {
    const timestamp = Date.now();
    const newEntry: LedgerEntry = { ...entry, timestamp };

    set((state) => {
      // 최신순으로 추가하고 최대 개수 유지 (Q1: Option A)
      const updatedLedger = [newEntry, ...state.ledger].slice(0, LEDGER_MAX_ENTRIES);

      return {
        ledger: updatedLedger,
        lastCost: {
          cost: entry.cost,
          balanceAfter: entry.balanceAfter,
          turnId: entry.turnId,
          modelLabel: entry.modelLabel,
        },
        // U-079: 서버에서 전달된 경고 상태 반영
        isBalanceLow: entry.lowBalanceWarning ?? state.isBalanceLow,
        // 턴 완료 후 예상 비용 초기화
        costEstimate: null,
      };
    });
  },

  hydrateLedger: (ledger, currentBalance) => {
    const { lowBalanceThreshold } = get();

    // LEDGER_MAX_ENTRIES 정책 적용 (저장된 것이 더 많을 경우 대비)
    const hydratedLedger = ledger.slice(0, LEDGER_MAX_ENTRIES);

    // lastCost는 가장 최신 엔트리(첫 원소) 기준으로 설정
    const latestEntry = hydratedLedger[0] ?? null;
    const lastCost: LastCostState | null = latestEntry
      ? {
          cost: latestEntry.cost,
          balanceAfter: latestEntry.balanceAfter,
          turnId: latestEntry.turnId,
          modelLabel: latestEntry.modelLabel,
        }
      : null;

    // isBalanceLow는 복원된 잔액 기준으로 재계산
    const isBalanceLow = currentBalance.signal < lowBalanceThreshold;

    set({
      ledger: hydratedLedger,
      lastCost,
      isBalanceLow,
      costEstimate: null,
    });
  },

  setCostEstimate: (estimate) => {
    set({ costEstimate: estimate });
  },

  setCostEstimateFromCard: (cost, costEstimate, actionId, label) => {
    if (costEstimate) {
      set({
        costEstimate: {
          min: costEstimate.min,
          max: costEstimate.max,
          actionId,
          label,
        },
      });
    } else {
      // cost_estimate가 없으면 기본 cost를 min/max로 사용
      set({
        costEstimate: {
          min: cost,
          max: cost,
          actionId,
          label,
        },
      });
    }
  },

  setLastCost: (lastCost) => {
    set({ lastCost });
  },

  updateBalanceLowStatus: (currentBalance) => {
    const { lowBalanceThreshold } = get();
    const isLow = currentBalance.signal < lowBalanceThreshold;
    set({ isBalanceLow: isLow });
  },

  setLowBalanceThreshold: (threshold) => {
    set({ lowBalanceThreshold: threshold });
  },

  clearLedger: () => {
    set({ ledger: [], lastCost: null });
  },

  reset: () => {
    set(createInitialState());
  },
}));

// =============================================================================
// 셀렉터 (성능 최적화용)
// =============================================================================

/** 거래 장부 셀렉터 */
export const selectLedger = (state: EconomyStore) => state.ledger;

/** 예상 비용 셀렉터 */
export const selectCostEstimate = (state: EconomyStore) => state.costEstimate;

/** 마지막 확정 비용 셀렉터 */
export const selectLastCost = (state: EconomyStore) => state.lastCost;

/** 잔액 부족 상태 셀렉터 */
export const selectIsBalanceLow = (state: EconomyStore) => state.isBalanceLow;

/** 최근 N개 거래 장부 엔트리 셀렉터 */
export const selectRecentLedger =
  (count: number) =>
  (state: EconomyStore): LedgerEntry[] =>
    state.ledger.slice(0, count);

/** 총 소비 비용 계산 셀렉터 (현재 세션) */
export const selectTotalSpent = (state: EconomyStore): CurrencyAmount => {
  return state.ledger.reduce(
    (acc, entry) => ({
      signal: acc.signal + entry.cost.signal,
      memory_shard: acc.memory_shard + entry.cost.memory_shard,
    }),
    { signal: 0, memory_shard: 0 },
  );
};

// =============================================================================
// 유틸리티 함수
// =============================================================================

/**
 * 현재 잔액으로 예상 비용을 감당할 수 있는지 확인합니다.
 * RULE-005: 잔액 부족 시 실행 강행이 아니라 대체 행동을 제안.
 */
export function canAffordCost(
  balance: CurrencyAmount,
  cost: CurrencyAmount,
): { affordable: boolean; shortfall: CurrencyAmount } {
  const signalShortfall = Math.max(0, cost.signal - balance.signal);
  const shardShortfall = Math.max(0, cost.memory_shard - balance.memory_shard);

  return {
    affordable: signalShortfall === 0 && shardShortfall === 0,
    shortfall: { signal: signalShortfall, memory_shard: shardShortfall },
  };
}

/**
 * 예상 비용의 최대값으로 감당 가능 여부를 확인합니다.
 */
export function canAffordEstimate(
  balance: CurrencyAmount,
  estimate: CostEstimateState,
): { affordable: boolean; shortfall: CurrencyAmount } {
  return canAffordCost(balance, estimate.max);
}

// DEV: 디버그용 글로벌 노출
if (import.meta.env.DEV && typeof window !== 'undefined') {
  (window as unknown as Record<string, unknown>).__economyStore = useEconomyStore;
}
</file>

<file path="frontend/src/stores/inventoryStore.ts">
/**
 * Unknown World - Inventory 상태 관리 (Zustand) (U-011[Mvp]).
 *
 * Inventory의 아이템 목록, 드래그 상태, 선택 상태를 관리합니다.
 *
 * 설계 원칙:
 *   - RULE-002: Inventory는 게임 UI로 상시 노출
 *   - U-006 의존: WorldDelta.inventory_added / inventory_removed 필드 연동
 *   - U-012 연결: 드래그 데이터에 item_id를 실어 드롭 타겟(핫스팟)에 전달
 *
 * U-075[Mvp]: 아이템 아이콘 동적 생성
 *   - Q1: Option B (placeholder 먼저 표시 후 백그라운드 생성)
 *   - 아이콘 생성 상태 추적 및 URL 업데이트
 *
 * @module stores/inventoryStore
 */

import { create } from 'zustand';
// U-092: 프리셋 아이콘 레지스트리
import { getPresetIconUrl } from '../data/itemIconPresets';

// =============================================================================
// 타입 정의
// =============================================================================

/**
 * 아이콘 생성 상태.
 */
export type IconStatus = 'pending' | 'generating' | 'completed' | 'failed' | 'cached';

/**
 * 인벤토리 아이템.
 * MVP에서는 최소 필드만 정의합니다.
 *
 * U-075: icon 필드는 URL 또는 이모지, iconStatus로 생성 상태 추적
 */
export interface InventoryItem {
  /** 아이템 고유 ID */
  id: string;
  /** 아이템 이름 (표시용) */
  name: string;
  /** 아이템 설명 (선택) */
  description?: string;
  /** 아이템 아이콘 URL 또는 이모지 (선택) */
  icon?: string;
  /** 아이템 수량 (기본값: 1) */
  quantity: number;
  /** U-075: 아이콘 생성 상태 (선택) */
  iconStatus?: IconStatus;
}

/** Inventory 상태 */
export interface InventoryState {
  /** 현재 아이템 목록 */
  items: InventoryItem[];
  /** 현재 드래그 중인 아이템 ID (null이면 드래그 중 아님) */
  draggingItemId: string | null;
  /** 선택된 아이템 ID (클릭 선택, 드래그와 별개) */
  selectedItemId: string | null;
  /** U-096: 소비(삭제) 애니메이션 진행 중인 아이템 ID 집합 */
  consumingItemIds: string[];
}

/** Inventory 액션 */
export interface InventoryActions {
  /** 아이템 목록 설정 (전체 교체) */
  setItems: (items: InventoryItem[]) => void;
  /** 아이템 추가 (중복 ID면 수량 증가) */
  addItems: (items: InventoryItem[]) => void;
  /** 아이템 제거 (ID 목록) */
  removeItems: (itemIds: string[]) => void;
  /** 드래그 시작 */
  startDrag: (itemId: string) => void;
  /** 드래그 종료 */
  endDrag: () => void;
  /** 아이템 선택 */
  selectItem: (itemId: string | null) => void;
  /** 상태 초기화 */
  reset: () => void;
  /** U-075: 아이템 아이콘 업데이트 */
  updateItemIcon: (itemId: string, icon: string, status: IconStatus) => void;
  /** U-075: 아이템 아이콘 상태만 업데이트 */
  setItemIconStatus: (itemId: string, status: IconStatus) => void;
  /**
   * U-096: 아이템을 소비(삭제) 애니메이션 상태로 전환합니다.
   * fade-out 애니메이션 시작 시 호출합니다.
   */
  markConsuming: (itemIds: string[]) => void;
  /**
   * U-096: 소비 애니메이션 완료 후 아이템을 실제로 제거합니다.
   * markConsuming → (애니메이션 대기) → clearConsuming 순서로 호출합니다.
   */
  clearConsuming: (itemIds: string[]) => void;
}

export type InventoryStore = InventoryState & InventoryActions;

// =============================================================================
// 초기 상태
// =============================================================================

function createInitialState(): InventoryState {
  return {
    items: [],
    draggingItemId: null,
    selectedItemId: null,
    consumingItemIds: [],
  };
}

// =============================================================================
// Zustand Store
// =============================================================================

/**
 * Inventory 상태 스토어.
 *
 * @example
 * ```tsx
 * const { items, addItems, removeItems, startDrag, endDrag } = useInventoryStore();
 *
 * // TurnOutput.world.inventory_added 수신 시
 * addItems(inventoryAddedItems);
 *
 * // TurnOutput.world.inventory_removed 수신 시
 * removeItems(inventoryRemovedIds);
 *
 * // dnd-kit onDragStart
 * startDrag(itemId);
 *
 * // dnd-kit onDragEnd
 * endDrag();
 * ```
 */
export const useInventoryStore = create<InventoryStore>((set) => ({
  // 초기 상태
  ...createInitialState(),

  // 액션
  setItems: (items) => {
    set({
      items,
      draggingItemId: null,
      selectedItemId: null,
    });
  },

  addItems: (newItems) => {
    set((state) => {
      const itemsMap = new Map(state.items.map((item) => [item.id, item]));

      for (const newItem of newItems) {
        const existing = itemsMap.get(newItem.id);
        if (existing) {
          // 기존 아이템이면 수량 증가
          itemsMap.set(newItem.id, {
            ...existing,
            quantity: existing.quantity + newItem.quantity,
          });
        } else {
          // 새 아이템 추가
          itemsMap.set(newItem.id, newItem);
        }
      }

      return { items: Array.from(itemsMap.values()) };
    });
  },

  removeItems: (itemIds) => {
    set((state) => {
      const countsToRemove = itemIds.reduce(
        (acc, id) => {
          acc[id] = (acc[id] || 0) + 1;
          return acc;
        },
        {} as Record<string, number>,
      );

      const nextItems = state.items
        .map((item) => {
          const toRemove = countsToRemove[item.id];
          if (!toRemove) return item;

          const nextQuantity = item.quantity - toRemove;
          if (nextQuantity <= 0) return null; // 수량이 0 이하면 제거
          return { ...item, quantity: nextQuantity };
        })
        .filter((item): item is InventoryItem => item !== null);

      const removedIds = new Set(
        state.items
          .filter((item) => !nextItems.find((ni) => ni.id === item.id))
          .map((item) => item.id),
      );

      return {
        items: nextItems,
        // 완전히 제거된 아이템이 선택/드래그 중이었다면 초기화
        selectedItemId: removedIds.has(state.selectedItemId ?? '') ? null : state.selectedItemId,
        draggingItemId: removedIds.has(state.draggingItemId ?? '') ? null : state.draggingItemId,
      };
    });
  },

  startDrag: (itemId) => {
    set({ draggingItemId: itemId });
  },

  endDrag: () => {
    set({ draggingItemId: null });
  },

  selectItem: (itemId) => {
    set({ selectedItemId: itemId });
  },

  reset: () => {
    set(createInitialState());
  },

  // U-075: 아이템 아이콘 업데이트
  updateItemIcon: (itemId, icon, status) => {
    set((state) => ({
      items: state.items.map((item) =>
        item.id === itemId ? { ...item, icon, iconStatus: status } : item,
      ),
    }));
  },

  // U-075: 아이템 아이콘 상태만 업데이트
  setItemIconStatus: (itemId, status) => {
    set((state) => ({
      items: state.items.map((item) =>
        item.id === itemId ? { ...item, iconStatus: status } : item,
      ),
    }));
  },

  // U-096: 아이템 소비 애니메이션 시작
  markConsuming: (itemIds) => {
    set((state) => ({
      consumingItemIds: [...new Set([...state.consumingItemIds, ...itemIds])],
    }));
  },

  // U-096: 소비 애니메이션 완료 후 실제 제거
  clearConsuming: (itemIds) => {
    set((state) => {
      const countsToRemove = itemIds.reduce(
        (acc, id) => {
          acc[id] = (acc[id] || 0) + 1;
          return acc;
        },
        {} as Record<string, number>,
      );

      const nextItems = state.items
        .map((item) => {
          const toRemove = countsToRemove[item.id];
          if (!toRemove) return item;

          const nextQuantity = item.quantity - toRemove;
          if (nextQuantity <= 0) return null;
          return { ...item, quantity: nextQuantity };
        })
        .filter((item): item is InventoryItem => item !== null);

      const removedIds = new Set(
        state.items
          .filter((item) => !nextItems.find((ni) => ni.id === item.id))
          .map((item) => item.id),
      );

      const removeSet = new Set(itemIds);
      return {
        items: nextItems,
        consumingItemIds: state.consumingItemIds.filter((id) => !removeSet.has(id)),
        // 완전히 제거된 아이템이 선택/드래그 중이었다면 초기화
        selectedItemId: removedIds.has(state.selectedItemId ?? '') ? null : state.selectedItemId,
        draggingItemId: removedIds.has(state.draggingItemId ?? '') ? null : state.draggingItemId,
      };
    });
  },
}));

// =============================================================================
// 셀렉터 (성능 최적화용)
// =============================================================================

/** 아이템 목록 셀렉터 */
export const selectItems = (state: InventoryStore) => state.items;

/** 드래그 중인 아이템 ID 셀렉터 */
export const selectDraggingItemId = (state: InventoryStore) => state.draggingItemId;

/** 드래그 중인 아이템 객체 셀렉터 */
export const selectDraggingItem = (state: InventoryStore) =>
  state.items.find((item) => item.id === state.draggingItemId) ?? null;

/** 선택된 아이템 ID 셀렉터 */
export const selectSelectedItemId = (state: InventoryStore) => state.selectedItemId;

/** 선택된 아이템 객체 셀렉터 */
export const selectSelectedItem = (state: InventoryStore) =>
  state.items.find((item) => item.id === state.selectedItemId) ?? null;

/** 아이템 개수 셀렉터 */
export const selectItemCount = (state: InventoryStore) => state.items.length;

/** U-096: 소비 중인 아이템 ID 목록 셀렉터 */
export const selectConsumingItemIds = (state: InventoryStore) => state.consumingItemIds;

// =============================================================================
// 유틸리티 함수
// =============================================================================

/**
 * 서버 응답(inventory_added InventoryItemData 배열)을 InventoryItem 배열로 변환합니다.
 *
 * @param added - 추가된 아이템 데이터 목록 (서버 응답)
 * @returns InventoryItem 배열
 */
export function parseInventoryAdded(added: InventoryItemDataInput[]): InventoryItem[] {
  return added.map((item) => {
    // U-092: 프리셋 아이콘 우선 (Q2: icon_url이 있으면 항상 프리셋 우선, 동적 생성 건너뛰기)
    const presetUrl = getPresetIconUrl(item.id);
    const iconUrl = presetUrl ?? item.icon_url ?? undefined;
    const status: IconStatus = iconUrl ? 'completed' : 'pending';

    return {
      id: item.id,
      name: item.label,
      description: item.description || item.label,
      icon: iconUrl,
      quantity: item.quantity ?? 1,
      iconStatus: status,
    };
  });
}

/** 서버에서 오는 InventoryItemData 형태 (Zod 스키마와 동일) */
export interface InventoryItemDataInput {
  id: string;
  label: string;
  description?: string;
  icon_url?: string | null;
  quantity?: number;
}

/**
 * 아이템 ID로 아이템을 찾습니다.
 *
 * @param items - 아이템 목록
 * @param itemId - 찾을 아이템 ID
 * @returns 아이템 또는 undefined
 */
export function findItemById(items: InventoryItem[], itemId: string): InventoryItem | undefined {
  return items.find((item) => item.id === itemId);
}

// =============================================================================
// U-075: 아이콘 생성 API
// =============================================================================

/** 아이콘 생성 API 응답 */
interface IconApiResponse {
  status: string;
  icon_url: string;
  item_id: string;
  is_placeholder: boolean;
  message?: string;
}

/**
 * 아이템 아이콘 생성을 요청합니다 (U-075[Mvp]).
 *
 * Q1 결정: Option B - placeholder 먼저 반환, 백그라운드 생성
 *
 * @param itemId - 아이템 ID
 * @param description - 아이템 설명
 * @param language - 세션 언어
 * @returns 아이콘 URL 및 상태
 */
export async function requestItemIcon(
  itemId: string,
  description: string,
  language: string = 'en-US',
): Promise<{ iconUrl: string; status: IconStatus; isPlaceholder: boolean }> {
  const apiUrl = import.meta.env.VITE_API_BASE_URL || 'http://localhost:8011';

  try {
    const response = await fetch(`${apiUrl}/api/item/icon`, {
      method: 'POST',
      headers: {
        'Content-Type': 'application/json',
      },
      body: JSON.stringify({
        item_id: itemId,
        description: description,
        language: language,
        wait: false, // Q1: placeholder 즉시 반환
      }),
    });

    if (!response.ok) {
      console.warn(`[ItemIcon] API 요청 실패: ${response.status}`);
      return { iconUrl: '', status: 'failed', isPlaceholder: true };
    }

    const data: IconApiResponse = await response.json();
    return {
      iconUrl: data.icon_url,
      status: data.status as IconStatus,
      isPlaceholder: data.is_placeholder,
    };
  } catch (error) {
    console.warn('[ItemIcon] 아이콘 생성 요청 실패:', error);
    return { iconUrl: '', status: 'failed', isPlaceholder: true };
  }
}

/**
 * 아이콘 생성 상태를 폴링합니다 (U-075[Mvp]).
 *
 * @param itemId - 아이템 ID
 * @returns 현재 상태
 */
export async function pollIconStatus(itemId: string): Promise<IconStatus> {
  const apiUrl = import.meta.env.VITE_API_BASE_URL || 'http://localhost:8011';

  try {
    const response = await fetch(`${apiUrl}/api/item/icon/${itemId}/status`);

    if (!response.ok) {
      return 'failed';
    }

    const data = await response.json();
    return data.status as IconStatus;
  } catch {
    return 'failed';
  }
}
</file>

<file path="backend/pyproject.toml">
# backend/pyproject.toml
# SSOT: vibe/tech-stack.md (버전 기준일: 2026-01-01)

[build-system]
requires = ["hatchling"]
build-backend = "hatchling.build"

[project]
name = "unknown-world-backend"
version = "0.1.0"
description = "Unknown World Backend - Gemini 기반 에이전트형 게임 엔진"
requires-python = ">=3.14"
dependencies = [
    "fastapi==0.128.0",
    "uvicorn[standard]==0.40.0",
    "pydantic==2.12.5",
    "google-genai==1.60.0",
    "python-dotenv>=1.2.1",
    "python-multipart>=0.0.22",
    "pillow>=12.1.0",
]

[tool.hatch.build.targets.wheel]
packages = ["src/unknown_world"]

[dependency-groups]
dev = [
    "ruff==0.14.10",
    "pyright==1.1.408",
    "pytest==9.0.2",
    "httpx==0.28.1",
    "jsonschema>=4.26.0",
    "pytest-asyncio>=1.3.0",
    "pytest-cov>=7.0.0",
]

[tool.ruff]
line-length = 100
target-version = "py314"
extend-exclude = [
    "__pycache__",
    ".ruff_cache",
    ".venv",
    "venv",
    "dist",
    "build",
    ".claude",
    ".cursor",
    ".gemini",
    "prompts",
    "vibe",
]

[tool.ruff.lint]
select = [
    "E",      # pycodestyle errors
    "W",      # pycodestyle warnings
    "F",      # pyflakes
    "I",      # isort
    "UP",     # pyupgrade
    "B",      # flake8-bugbear
    "C4",     # flake8-comprehensions
    "SIM",    # flake8-simplify
]
ignore = [
    "E501",   # line too long (handled by formatter)
    "B008",   # function call in default argument (FastAPI Depends pattern)
]

[tool.ruff.lint.per-file-ignores]
"debug_*.py" = ["E402"]
"start_and_test.py" = ["E402"]

[tool.ruff.format]
quote-style = "double"
indent-style = "space"

[tool.pyright]
pythonVersion = "3.14"
typeCheckingMode = "strict"
include = ["src"]
venvPath = "."
venv = ".venv"
</file>

<file path="backend/src/unknown_world/api/image.py">
"""Unknown World - 이미지 생성 API 엔드포인트.

이 모듈은 장면 이미지를 조건부로 생성하는 엔드포인트를 제공합니다.
텍스트 턴의 TTFB를 블로킹하지 않도록 분리된 경로로 동작합니다.

설계 원칙:
    - RULE-004: 실패 시 안전한 폴백 (텍스트-only 진행 가능)
    - RULE-008: 텍스트 우선 + Lazy 이미지 원칙
    - RULE-010: 이미지 모델 ID 고정 (gemini-3-pro-image-preview)
    - RULE-007: 프롬프트 원문/비밀정보 노출 금지

페어링 질문 결정:
    - Q1: Option A (로컬 파일로 저장 후 image_url로 서빙)

참조:
    - vibe/unit-plans/U-019[Mvp].md
    - .cursor/rules/20-backend-orchestrator.mdc
"""

from __future__ import annotations

import logging

from fastapi import APIRouter, Depends, HTTPException
from fastapi.responses import FileResponse
from pydantic import BaseModel, ConfigDict, Field

from unknown_world.models.turn import Language
from unknown_world.services.image_generation import (
    ImageGenerationRequest,
    ImageGenerationStatus,
    ImageGeneratorType,
    MockImageGenerator,
    create_fallback_response,
    get_image_generator,
)
from unknown_world.storage.paths import (
    DEFAULT_IMAGE_EXTENSION,
    build_image_url,
    get_generated_images_dir,
)
from unknown_world.storage.validation import (
    normalize_image_size,
    validate_image_generation_request,
)

# =============================================================================
# 로거 설정
# =============================================================================

logger = logging.getLogger(__name__)

# =============================================================================
# 라우터 정의
# =============================================================================

router = APIRouter(
    prefix="/api/image",
    tags=["Image Generation"],
)


# =============================================================================
# 의존성 주입
# =============================================================================


async def get_generator():
    """이미지 생성기 의존성."""
    return get_image_generator()


# =============================================================================
# 요청/응답 스키마 (API 계층용)
# =============================================================================


class GenerateImageRequest(BaseModel):
    """이미지 생성 API 요청.

    TurnOutput.render.image_job과 정합되도록 설계합니다.

    Attributes:
        prompt: 이미지 생성 프롬프트 (필수)
        language: 언어 (에러 메시지용, RULE-006)
        aspect_ratio: 가로세로 비율
        image_size: 이미지 크기
        reference_image_ids: 참조 이미지 ID 목록 (편집용)
        reference_image_url: 참조 이미지 URL (U-068: 이전 턴 이미지 연결성)
        session_id: 세션 ID (파일 그룹화용)
        skip_on_failure: 실패 시 건너뛰기 (텍스트-only 진행)
        model_label: 모델 티어링 라벨 (U-066: FAST/QUALITY)
        turn_id: 턴 ID (late-binding 가드용, U-066)
    """

    model_config = ConfigDict(extra="forbid")

    prompt: str = Field(min_length=1, max_length=2000, description="이미지 생성 프롬프트")
    language: Language = Field(default=Language.KO, description="요청 언어")
    aspect_ratio: str = Field(
        default="16:9",
        description="가로세로 비율 (U-085: 게임 UI 기본 16:9)",
    )
    image_size: str = Field(
        default="1K",
        description="이미지 크기 - SDK 값: 1K/2K/4K (U-085: Q2 마이그레이션)",
    )
    reference_image_ids: list[str] = Field(default_factory=list, description="참조 이미지 ID 목록")
    reference_image_url: str | None = Field(
        default=None,
        description="참조 이미지 URL (U-068: 이전 턴 이미지를 참조하여 연속성 유지)",
    )
    session_id: str | None = Field(default=None, description="세션 ID")
    skip_on_failure: bool = Field(default=True, description="실패 시 건너뛰기 (텍스트-only 진행)")
    model_label: str = Field(default="QUALITY", description="모델 티어링 라벨 (FAST/QUALITY)")
    turn_id: int | None = Field(default=None, description="턴 ID (late-binding 가드용)")


class GenerateImageResponse(BaseModel):
    """이미지 생성 API 응답.

    Attributes:
        success: 성공 여부
        status: 생성 상태
        image_id: 생성된 이미지 ID
        image_url: 생성된 이미지 URL
        message: 상태 메시지
        generation_time_ms: 생성 소요 시간
        model_label: 사용된 모델 라벨 (U-066)
        turn_id: 요청 턴 ID (U-066, late-binding 가드용)
    """

    model_config = ConfigDict(extra="forbid")

    success: bool = Field(description="성공 여부")
    status: ImageGenerationStatus = Field(description="생성 상태")
    image_id: str | None = Field(default=None, description="생성된 이미지 ID")
    image_url: str | None = Field(default=None, description="생성된 이미지 URL")
    message: str | None = Field(default=None, description="상태 메시지")
    generation_time_ms: int = Field(default=0, description="생성 소요 시간 (ms)")
    model_label: str = Field(default="QUALITY", description="사용된 모델 라벨")
    turn_id: int | None = Field(default=None, description="요청 턴 ID")


class ImageStatusResponse(BaseModel):
    """이미지 상태 조회 응답.

    Attributes:
        image_id: 이미지 ID
        exists: 이미지 존재 여부
        image_url: 이미지 URL (존재하는 경우)
    """

    model_config = ConfigDict(extra="forbid")

    image_id: str = Field(description="이미지 ID")
    exists: bool = Field(description="이미지 존재 여부")
    image_url: str | None = Field(default=None, description="이미지 URL")


# =============================================================================
# 엔드포인트 정의
# =============================================================================


@router.post(
    "/generate",
    response_model=GenerateImageResponse,
    summary="이미지 생성",
    description="장면 이미지를 생성합니다. 텍스트 턴과 별개로 비동기적으로 호출됩니다.",
)
async def generate_image(
    request: GenerateImageRequest,
    generator: ImageGeneratorType = Depends(get_generator),
) -> GenerateImageResponse:
    """이미지를 생성합니다.

    이 엔드포인트는 TurnOutput의 render.image_job에서 should_generate=true인 경우
    프론트엔드에서 별도로 호출합니다.

    텍스트 턴의 TTFB를 블로킹하지 않습니다 (RULE-008).

    Args:
        request: 이미지 생성 요청
        generator: 이미지 생성기 (의존성 주입)

    Returns:
        GenerateImageResponse: 생성 결과
    """
    # U-085: image_size를 SDK 값으로 정규화 (레거시 호환)
    normalized_image_size = normalize_image_size(request.image_size)

    # 요청 검증 (정규화된 image_size로 검증)
    validation_error = validate_image_generation_request(
        prompt=request.prompt,
        image_size=normalized_image_size,
        language=request.language,
    )

    if validation_error:
        logger.warning(
            "[ImageAPI] 요청 검증 실패",
            extra={"error": validation_error},
        )

        if request.skip_on_failure:
            # 실패 시에도 텍스트-only로 진행 가능하도록 폴백 (RULE-004)
            fallback = create_fallback_response(validation_error)
            return GenerateImageResponse(
                success=False,
                status=fallback.status,
                message=fallback.message,
            )
        else:
            raise HTTPException(status_code=400, detail=validation_error)

    # 이미지 생성 실행
    try:
        result = await generator.generate(
            ImageGenerationRequest(
                prompt=request.prompt,
                aspect_ratio=request.aspect_ratio,
                image_size=normalized_image_size,
                reference_image_ids=request.reference_image_ids,
                reference_image_url=request.reference_image_url,
                session_id=request.session_id,
                model_label=request.model_label,
            )
        )

        success = result.status == ImageGenerationStatus.COMPLETED

        return GenerateImageResponse(
            success=success,
            status=result.status,
            image_id=result.image_id,
            image_url=result.image_url,
            message=result.message,
            generation_time_ms=result.generation_time_ms,
            model_label=request.model_label,
            turn_id=request.turn_id,
        )

    except Exception as e:
        error_type = type(e).__name__
        logger.error(
            "[ImageAPI] 이미지 생성 중 예외 발생",
            extra={"error_type": error_type},
        )

        if request.skip_on_failure:
            # 예외 발생 시에도 안전한 폴백 (RULE-004)
            return GenerateImageResponse(
                success=False,
                status=ImageGenerationStatus.FAILED,
                message=f"이미지 생성 중 오류가 발생했습니다: {error_type}",
            )
        else:
            raise HTTPException(
                status_code=500,
                detail=f"이미지 생성 실패: {error_type}",
            ) from e


@router.get(
    "/status/{image_id}",
    response_model=ImageStatusResponse,
    summary="이미지 상태 조회",
    description="생성된 이미지의 존재 여부와 URL을 조회합니다.",
)
async def get_image_status(
    image_id: str,
) -> ImageStatusResponse:
    """이미지 상태를 조회합니다.

    Args:
        image_id: 이미지 ID

    Returns:
        ImageStatusResponse: 이미지 상태
    """
    # 파일 존재 확인 (RU-006-Q5: 중앙화된 경로 함수 사용)
    output_dir = get_generated_images_dir()
    filename = f"{image_id}.{DEFAULT_IMAGE_EXTENSION}"
    file_path = output_dir / filename
    exists = file_path.exists()

    return ImageStatusResponse(
        image_id=image_id,
        exists=exists,
        image_url=build_image_url(filename, category="generated") if exists else None,
    )


@router.get(
    "/file/{image_id}",
    summary="이미지 파일 조회",
    description="생성된 이미지 파일을 반환합니다.",
    response_class=FileResponse,
)
async def get_image_file(
    image_id: str,
) -> FileResponse:
    """이미지 파일을 반환합니다.

    MVP에서는 로컬 파일을 직접 서빙합니다.
    MMP에서 GCS URL 리다이렉트로 변경 예정.

    Args:
        image_id: 이미지 ID

    Returns:
        FileResponse: 이미지 파일
    """
    # RU-006-Q5: 중앙화된 경로 함수 사용
    output_dir = get_generated_images_dir()
    filename = f"{image_id}.{DEFAULT_IMAGE_EXTENSION}"
    file_path = output_dir / filename

    if not file_path.exists():
        raise HTTPException(status_code=404, detail="이미지를 찾을 수 없습니다.")

    return FileResponse(
        path=str(file_path),
        media_type="image/png",
        filename=filename,
    )


@router.get(
    "/health",
    summary="이미지 서비스 헬스체크",
    description="이미지 생성 서비스의 상태를 확인합니다.",
)
async def image_health(
    generator: ImageGeneratorType = Depends(get_generator),
) -> dict[str, str | bool]:
    """이미지 서비스 헬스체크.

    Args:
        generator: 이미지 생성기

    Returns:
        헬스 상태 정보
    """
    is_available = generator.is_available()
    # MockImageGenerator 인스턴스인지 직접 확인 (싱글톤 캐시 오염 방지)
    mode = "mock" if isinstance(generator, MockImageGenerator) else "real"

    return {
        "status": "ok" if is_available else "degraded",
        "available": is_available,
        "mode": mode,
        "model": "gemini-3-pro-image-preview",
    }
</file>

<file path="backend/src/unknown_world/orchestrator/stages/render_helpers.py">
"""Unknown World - 이미지 생성 판정 헬퍼.

이 모듈은 TurnOutput의 image_job을 분석하여 이미지 생성 여부를 판정하고,
Economy 기반으로 잔액 검증을 수행하는 헬퍼 함수들을 제공합니다.

설계 원칙:
    - RULE-005: 재화 인바리언트 (잔액 음수 금지, 예상 비용 사전 표시)
    - RULE-007: 프롬프트 원문 로그 노출 금지 (해시만 사용)
    - RULE-008: 텍스트 우선 + Lazy 이미지 원칙
    - 순수 함수: 테스트 용이성을 위해 부작용 없는 순수 함수로 구현

페어링 질문 결정:
    - Q1: Option A (고정 비용 10 Signal) - MVP 단순화

참조:
    - vibe/unit-plans/U-052[Mvp].md
    - vibe/prd.md 6.7 - Economy HUD/비용 정책
    - .cursor/rules/00-core-critical.mdc - RULE-005/007/008
"""

from __future__ import annotations

import hashlib
import logging
from dataclasses import dataclass
from typing import TYPE_CHECKING

from pydantic import BaseModel, ConfigDict, Field

from unknown_world.config.economy import (
    FAST_IMAGE_COST_SIGNAL,
    IMAGE_GENERATION_COST_SIGNAL,
)

if TYPE_CHECKING:
    from unknown_world.models.turn import (
        EconomySnapshot,
        ImageJob,
        TurnOutput,
    )

# =============================================================================
# 로거 설정 (프롬프트/비밀정보 노출 금지 - RULE-007)
# =============================================================================

logger = logging.getLogger(__name__)


# =============================================================================
# 정책 및 상수 정의
# =============================================================================


class ImagePolicy(BaseModel):
    """이미지 생성 정책 (U-068).

    Attributes:
        use_reference: 참조 이미지(이전 턴 이미지) 사용 여부
        max_reference_images: 최대 참조 이미지 수 (기본 1)
    """

    model_config = ConfigDict(extra="forbid")

    use_reference: bool = Field(default=True, description="참조 이미지 사용 여부")
    max_reference_images: int = Field(default=1, description="최대 참조 이미지 수")


# 기본 정책 인스턴스
DEFAULT_IMAGE_POLICY = ImagePolicy()


# =============================================================================
# 텍스트-only 폴백 메시지 (i18n)
# =============================================================================

FALLBACK_MESSAGE_KO = "잔액이 부족하여 이미지를 생성할 수 없습니다. 텍스트로 진행합니다."
"""잔액 부족 시 폴백 메시지 (한국어)."""

FALLBACK_MESSAGE_EN = "Insufficient balance for image generation. Proceeding with text only."
"""잔액 부족 시 폴백 메시지 (영어)."""

# =============================================================================
# 이미지 생성 실패 폴백 메시지 (i18n) - U-054
# =============================================================================

IMAGE_GENERATION_FAILURE_MESSAGE_KO = "이미지 생성에 실패했습니다. 텍스트로 진행합니다."
"""이미지 생성 실패 시 폴백 메시지 (한국어)."""

IMAGE_GENERATION_FAILURE_MESSAGE_EN = "Image generation failed. Proceeding with text only."
"""이미지 생성 실패 시 폴백 메시지 (영어)."""

# =============================================================================
# 안전 정책 차단 메시지 (i18n) - U-054
# =============================================================================

SAFETY_BLOCKED_MESSAGE_KO = "안전 정책에 따라 이미지를 생성할 수 없습니다."
"""안전 정책 차단 시 메시지 (한국어)."""

SAFETY_BLOCKED_MESSAGE_EN = "Image generation blocked due to safety policies."
"""안전 정책 차단 시 메시지 (영어)."""


# =============================================================================
# 판정 결과 데이터 클래스
# =============================================================================


@dataclass(frozen=True)
class ImageGenerationDecision:
    """이미지 생성 판정 결과.

    이미지 생성 여부와 관련 정보를 담은 불변 데이터 클래스입니다.

    Attributes:
        should_generate: 이미지를 생성해야 하는지
        reason: 판정 사유 (로깅/디버깅용)
        prompt_hash: 프롬프트 해시 (원문 노출 금지, 로깅용)
        aspect_ratio: 가로세로 비율 (생성 시)
        image_size: 이미지 크기 (생성 시)
        estimated_cost_signal: 예상 Signal 비용
        fallback_message: 생성 불가 시 폴백 메시지 (선택)
        model_override: 모델 오버라이드 (U-079: 잔액 부족 시 FAST 강제)
        is_low_balance_fallback: 잔액 부족 FAST 폴백 여부 (U-079)
    """

    should_generate: bool
    reason: str
    prompt_hash: str | None = None
    aspect_ratio: str | None = None
    image_size: str | None = None
    reference_image_url: str | None = None
    estimated_cost_signal: int = IMAGE_GENERATION_COST_SIGNAL
    fallback_message: str | None = None
    model_override: str | None = None
    is_low_balance_fallback: bool = False


# =============================================================================
# ImageJob 분석 헬퍼 함수
# =============================================================================


def extract_image_job(turn_output: TurnOutput) -> ImageJob | None:
    """TurnOutput에서 ImageJob을 추출합니다.

    Args:
        turn_output: 검증할 TurnOutput

    Returns:
        유효한 ImageJob 또는 None
    """
    # TurnOutput.render는 default_factory=RenderOutput이므로 항상 존재
    # render.image_job은 선택적 (None 가능)
    return turn_output.render.image_job


def should_generate_image(image_job: ImageJob | None) -> bool:
    """이미지 생성 여부를 판정합니다.

    다음 조건을 모두 만족해야 True를 반환합니다:
    1. image_job이 None이 아님
    2. image_job.should_generate가 True
    3. image_job.prompt가 비어있지 않음 (빈 프롬프트 방어)

    Args:
        image_job: 검사할 ImageJob (None 가능)

    Returns:
        이미지를 생성해야 하면 True
    """
    if image_job is None:
        return False

    if not image_job.should_generate:
        return False

    # 빈 프롬프트 방어: 모델이 should_generate=true지만 프롬프트가 없는 경우
    return bool(image_job.prompt and image_job.prompt.strip())


def get_prompt_hash(prompt: str) -> str:
    """프롬프트의 SHA-256 해시를 생성합니다.

    RULE-007: 프롬프트 원문은 로그에 노출하지 않고 해시만 사용합니다.

    Args:
        prompt: 해시할 프롬프트

    Returns:
        8자리 해시 문자열
    """
    return hashlib.sha256(prompt.encode()).hexdigest()[:8]


# =============================================================================
# Economy 기반 판정 함수
# =============================================================================


def can_afford_image_generation(
    economy_snapshot: EconomySnapshot,
    estimated_cost_signal: int = IMAGE_GENERATION_COST_SIGNAL,
) -> bool:
    """이미지 생성 비용을 감당할 수 있는지 판정합니다.

    RULE-005: 잔액 부족 시 생성을 강행하지 않고, 대안(텍스트-only)을 제안합니다.

    Args:
        economy_snapshot: 현재 재화 스냅샷
        estimated_cost_signal: 예상 Signal 비용 (기본값: 10)

    Returns:
        비용을 감당할 수 있으면 True
    """
    return economy_snapshot.signal >= estimated_cost_signal


def get_fallback_message(language: str) -> str:
    """언어에 맞는 폴백 메시지를 반환합니다.

    RULE-006: ko/en 언어 정책 준수

    Args:
        language: 언어 코드 ("ko-KR" 또는 "en-US")

    Returns:
        해당 언어의 폴백 메시지
    """
    if language == "ko-KR":
        return FALLBACK_MESSAGE_KO
    return FALLBACK_MESSAGE_EN


# =============================================================================
# 통합 판정 함수
# =============================================================================


def decide_image_generation(
    turn_output: TurnOutput,
    economy_snapshot: EconomySnapshot,
    language: str = "en-US",
    previous_image_url: str | None = None,
) -> ImageGenerationDecision:
    """이미지 생성 여부를 종합적으로 판정합니다.

    다음 순서로 검증합니다:
    1. ImageJob 존재 여부
    2. should_generate 플래그
    3. 프롬프트 유효성
    4. 잔액 충분 여부 (RULE-005)

    Args:
        turn_output: 검증할 TurnOutput
        economy_snapshot: 현재 재화 스냅샷
        language: 폴백 메시지 언어 (기본: ko-KR)
        previous_image_url: 이전 턴 이미지 URL (U-068: 참조 이미지로 사용)

    Returns:
        ImageGenerationDecision: 판정 결과
    """
    # 1. ImageJob 추출
    image_job = extract_image_job(turn_output)

    if image_job is None:
        logger.debug("[RenderHelpers] ImageJob 없음, 이미지 생성 건너뜀")
        return ImageGenerationDecision(
            should_generate=False,
            reason="no_image_job",
        )

    # 2. should_generate 플래그 확인
    if not image_job.should_generate:
        logger.debug("[RenderHelpers] should_generate=false, 이미지 생성 건너뜀")
        return ImageGenerationDecision(
            should_generate=False,
            reason="should_generate_false",
        )

    # 3. 프롬프트 유효성 검사
    if not image_job.prompt or not image_job.prompt.strip():
        logger.warning("[RenderHelpers] 프롬프트 비어있음, 이미지 생성 건너뜀 (방어)")
        return ImageGenerationDecision(
            should_generate=False,
            reason="empty_prompt",
        )

    # 프롬프트 해시 생성 (원문 로깅 금지 - RULE-007)
    prompt_hash = get_prompt_hash(image_job.prompt)

    # U-068: 참조 이미지 URL 결정 (TurnInput 우선, image_job 폴백)
    # 클라이언트에서 제공한 이전 이미지를 우선 사용하여 연속성 유지
    effective_reference_url = previous_image_url or image_job.reference_image_url

    # 4. 잔액 확인 + U-079: FAST 폴백 정책
    # RULE-005(잔액 음수 금지) 준수하면서 게임 흐름 차단 방지
    # - 잔액 >= IMAGE_GENERATION_COST_SIGNAL: QUALITY 모델 (정상)
    # - 잔액 < IMAGE_GENERATION_COST_SIGNAL: FAST 모델 폴백 (무료)
    if not can_afford_image_generation(economy_snapshot, IMAGE_GENERATION_COST_SIGNAL):
        # U-079: 잔액 부족 → FAST 모델로 폴백 (비용 0, 무료 기본 이미지)
        logger.info(
            "[RenderHelpers] 잔액 부족, FAST 모델 폴백 (U-079)",
            extra={
                "current_signal": economy_snapshot.signal,
                "required_signal": IMAGE_GENERATION_COST_SIGNAL,
                "fallback_cost": FAST_IMAGE_COST_SIGNAL,
                "prompt_hash": prompt_hash,
            },
        )
        return ImageGenerationDecision(
            should_generate=True,
            reason="low_balance_fast_fallback",
            prompt_hash=prompt_hash,
            aspect_ratio=image_job.aspect_ratio,
            image_size=image_job.image_size,
            reference_image_url=effective_reference_url,
            estimated_cost_signal=FAST_IMAGE_COST_SIGNAL,
            model_override="FAST",
            is_low_balance_fallback=True,
        )

    # 모든 조건 통과 - QUALITY 이미지 생성 진행
    logger.info(
        "[RenderHelpers] 이미지 생성 판정 통과 (QUALITY)",
        extra={
            "prompt_hash": prompt_hash,
            "aspect_ratio": image_job.aspect_ratio,
            "image_size": image_job.image_size,
            "reference_image_url": effective_reference_url,
            "has_previous_image": bool(previous_image_url),
            "estimated_cost": IMAGE_GENERATION_COST_SIGNAL,
        },
    )

    return ImageGenerationDecision(
        should_generate=True,
        reason="all_conditions_met",
        prompt_hash=prompt_hash,
        aspect_ratio=image_job.aspect_ratio,
        image_size=image_job.image_size,
        reference_image_url=effective_reference_url,
        estimated_cost_signal=IMAGE_GENERATION_COST_SIGNAL,
    )


# =============================================================================
# 이미지 생성 실패/안전 차단 헬퍼 함수 (U-054)
# =============================================================================


def is_safety_blocked(message: str | None) -> bool:
    """응답 메시지가 안전 정책 차단을 나타내는지 확인합니다.

    RULE-004: 안전 차단 시 적절한 메시지가 TurnOutput.safety에 기록되어야 합니다.

    Args:
        message: 이미지 생성 응답 메시지 (None 가능)

    Returns:
        안전 정책 차단이면 True
    """
    if not message:
        return False

    message_lower = message.lower()
    safety_keywords = ["safety", "blocked", "policy", "violation", "prohibited"]
    return any(keyword in message_lower for keyword in safety_keywords)


def get_image_failure_message(language: str) -> str:
    """언어에 맞는 이미지 생성 실패 폴백 메시지를 반환합니다.

    RULE-006: ko/en 언어 정책 준수

    Args:
        language: 언어 코드 ("ko-KR" 또는 "en-US")

    Returns:
        해당 언어의 이미지 생성 실패 메시지
    """
    if language == "ko-KR":
        return IMAGE_GENERATION_FAILURE_MESSAGE_KO
    return IMAGE_GENERATION_FAILURE_MESSAGE_EN


def get_safety_blocked_message(language: str) -> str:
    """언어에 맞는 안전 정책 차단 메시지를 반환합니다.

    RULE-006: ko/en 언어 정책 준수

    Args:
        language: 언어 코드 ("ko-KR" 또는 "en-US")

    Returns:
        해당 언어의 안전 차단 메시지
    """
    if language == "ko-KR":
        return SAFETY_BLOCKED_MESSAGE_KO
    return SAFETY_BLOCKED_MESSAGE_EN


@dataclass(frozen=True)
class ImageFallbackResult:
    """이미지 생성 실패 시 폴백 결과.

    U-054: 이미지 생성 실패 시 안전한 폴백 정보를 담은 데이터 클래스입니다.

    Attributes:
        is_safety_blocked: 안전 정책에 의해 차단되었는지
        fallback_message: 사용자에게 표시할 폴백 메시지
        should_update_safety: TurnOutput.safety를 업데이트해야 하는지
        reason: 폴백 사유 (로깅용)
    """

    is_safety_blocked: bool
    fallback_message: str
    should_update_safety: bool
    reason: str


def create_image_fallback_result(
    status_message: str | None,
    language: str = "en-US",
) -> ImageFallbackResult:
    """이미지 생성 실패에 대한 폴백 결과를 생성합니다.

    U-054: RULE-004에 따라 이미지 생성 실패 시 안전한 폴백을 제공합니다.
    재시도 없이 즉시 폴백합니다 (Q1: Option A).

    Args:
        status_message: 이미지 생성 응답 메시지 (실패 사유)
        language: 폴백 메시지 언어 (기본: ko-KR)

    Returns:
        ImageFallbackResult: 폴백 처리에 필요한 정보
    """
    is_blocked = is_safety_blocked(status_message)

    if is_blocked:
        return ImageFallbackResult(
            is_safety_blocked=True,
            fallback_message=get_safety_blocked_message(language),
            should_update_safety=True,
            reason="safety_blocked",
        )

    return ImageFallbackResult(
        is_safety_blocked=False,
        fallback_message=get_image_failure_message(language),
        should_update_safety=False,
        reason="generation_failed",
    )
</file>

<file path="backend/src/unknown_world/services/item_icon_generator.py">
"""Unknown World - 아이템 아이콘 동적 생성 서비스 (U-075[Mvp]).

이 모듈은 인벤토리 아이템 설명을 기반으로 64x64 픽셀 아트 아이콘을 동적 생성합니다.
캐싱, 언어 정합성을 보장합니다.

U-091: 런타임 rembg 제거 - 배경 제거 없이 프롬프트로 어두운 배경 유도.
U-093: 타임아웃 90초 상향, 최대 1회 재시도(총 2회), 지수 백오프, 폴백 보강.

설계 원칙:
    - RULE-004: 실패 시 안전한 폴백 제공 (placeholder 아이콘)
    - RULE-006: ko/en 언어 정책 준수 (아이템 이름 언어 정합성)
    - RULE-007: 프롬프트 원문 노출 금지
    - RULE-010: 이미지 모델 ID 고정 (gemini-2.5-flash-image for FAST)

페어링 질문 결정 (U-075[Mvp]):
    - Q1: Option B (placeholder 먼저 표시 후 백그라운드 생성)
    - Q2: Option A (64x64 픽셀)
    - Q3: Option A (픽셀 아트 스타일 - CRT 테마)

페어링 질문 결정 (U-093[Mvp]):
    - Q1: Option B (최대 1회 재시도, 총 2회 시도)

참조:
    - vibe/unit-plans/U-075[Mvp].md
    - vibe/unit-plans/U-093[Mvp].md
    - vibe/ref/nanobanana-mcp.md (CRT 테마 아트 디렉션)
"""

from __future__ import annotations

import asyncio
import hashlib
import logging
from datetime import UTC, datetime
from enum import StrEnum
from pathlib import Path
from typing import TYPE_CHECKING

from pydantic import BaseModel, ConfigDict, Field

from unknown_world.storage.paths import build_image_url, get_generated_images_dir

if TYPE_CHECKING:
    from unknown_world.services.image_generation import ImageGeneratorType

# =============================================================================
# 로거 설정
# =============================================================================

logger = logging.getLogger(__name__)


# =============================================================================
# 상수 정의
# =============================================================================

# Q2 결정: 아이콘 사이즈 64x64
ICON_SIZE = 64
"""아이콘 크기 (픽셀)."""

ICON_IMAGE_SIZE = f"{ICON_SIZE}x{ICON_SIZE}"
"""이미지 생성용 사이즈 문자열."""

# Q3 결정: 픽셀 아트 스타일 (CRT phosphor 아트 디렉션)
# U-092: nanobanana-mcp 프롬프트 스타일 적용 (퀄리티 향상)
# 참조: vibe/ref/nanobanana-mcp.md §1 공통 아트 디렉션, §2.1 UI 아이콘 템플릿
ICON_STYLE_PROMPT = """
minimal retro CRT phosphor style icon,
high contrast pixel art aesthetic,
sharp edges, clean silhouette, no anti-aliasing,
single centered object on solid dark background (#0d0d0d),
vibrant colors from CRT phosphor palette (#33ff00 green, #ff00ff magenta, #ffaa00 amber, #ff3333 red),
no text, no decorations, no shadows, no complex gradients
"""

# 아이콘 캐시 디렉토리
ICON_CACHE_SUBDIR = "icons"

# 백그라운드 생성 타임아웃 (U-093: 30초 → 90초 상향)
ICON_GENERATION_TIMEOUT_SECONDS = 90

# U-093: 재시도 설정 (Q1: Option B - 최대 1회 재시도, 총 2회 시도)
ICON_MAX_RETRIES = 1
"""최대 재시도 횟수."""

ICON_RETRY_BASE_DELAY_SECONDS = 2.0
"""재시도 기본 대기 시간 (초). 지수 백오프 적용: delay * 2^(attempt-1)."""

# 재시도 제외 키워드 (4xx 클라이언트 에러, quota 초과, 안전 차단)
_NON_RETRYABLE_KEYWORDS = frozenset(
    {
        "quota",
        "rate_limit",
        "rate limit",
        "billing",
        "safety",
        "blocked",
        "invalid",
        "permission",
        "authentication",
        "authorization",
    }
)


class IconGenerationStatus(StrEnum):
    """아이콘 생성 상태."""

    PENDING = "pending"
    """생성 대기 중 (placeholder 반환)"""

    GENERATING = "generating"
    """생성 중"""

    COMPLETED = "completed"
    """생성 완료"""

    FAILED = "failed"
    """생성 실패 (placeholder 사용)"""

    CACHED = "cached"
    """캐시에서 반환"""


# =============================================================================
# 요청/응답 모델
# =============================================================================


class IconGenerationRequest(BaseModel):
    """아이콘 생성 요청.

    Attributes:
        item_id: 아이템 고유 ID
        item_description: 아이템 설명 (아이콘 생성용)
        language: 현재 세션 언어 (ko-KR/en-US)
    """

    model_config = ConfigDict(extra="forbid")

    item_id: str = Field(description="아이템 고유 ID")
    item_description: str = Field(description="아이템 설명 (아이콘 생성용)")
    language: str = Field(default="en-US", description="현재 세션 언어")


class IconGenerationResponse(BaseModel):
    """아이콘 생성 응답.

    Attributes:
        status: 생성 상태
        icon_url: 아이콘 URL (성공 또는 placeholder)
        item_id: 아이템 ID
        is_placeholder: placeholder 아이콘 여부
        generation_time_ms: 생성 소요 시간 (밀리초)
        message: 상태 메시지
    """

    model_config = ConfigDict(extra="forbid")

    status: IconGenerationStatus
    icon_url: str = Field(description="아이콘 URL")
    item_id: str = Field(description="아이템 ID")
    is_placeholder: bool = Field(default=False, description="placeholder 아이콘 여부")
    generation_time_ms: int = Field(default=0, description="생성 소요 시간 (ms)")
    message: str | None = Field(default=None, description="상태 메시지")


# =============================================================================
# 아이콘 캐시
# =============================================================================


class IconCache:
    """아이템 아이콘 캐시.

    메모리 캐시 + 파일 시스템 캐시를 사용하여 동일 아이템 재생성을 방지합니다.
    캐시 키는 아이템 설명의 MD5 해시입니다.
    """

    def __init__(self, cache_dir: Path | None = None) -> None:
        """IconCache를 초기화합니다.

        Args:
            cache_dir: 캐시 디렉토리 (기본: .data/images/generated/icons)
        """
        self._cache_dir = cache_dir or get_generated_images_dir() / ICON_CACHE_SUBDIR
        self._cache_dir.mkdir(parents=True, exist_ok=True)
        self._memory_cache: dict[str, str] = {}  # cache_key → icon_url

        logger.info(
            "[IconCache] 초기화 완료",
            extra={"cache_dir": str(self._cache_dir)},
        )

    def _make_cache_key(self, item_description: str) -> str:
        """캐시 키를 생성합니다 (MD5 해시).

        Args:
            item_description: 아이템 설명

        Returns:
            str: MD5 해시 (32자)
        """
        return hashlib.md5(item_description.encode()).hexdigest()

    def get(self, item_description: str) -> str | None:
        """캐시에서 아이콘 URL을 조회합니다.

        Args:
            item_description: 아이템 설명

        Returns:
            str | None: 캐시된 아이콘 URL 또는 None
        """
        cache_key = self._make_cache_key(item_description)

        # 메모리 캐시 확인
        if cache_key in self._memory_cache:
            logger.debug(
                "[IconCache] 메모리 캐시 히트",
                extra={"cache_key": cache_key[:8]},
            )
            return self._memory_cache[cache_key]

        # 파일 캐시 확인
        cache_path = self._cache_dir / f"{cache_key}.png"
        if cache_path.exists():
            icon_url = build_image_url(f"{ICON_CACHE_SUBDIR}/{cache_key}.png", category="generated")
            self._memory_cache[cache_key] = icon_url
            logger.debug(
                "[IconCache] 파일 캐시 히트",
                extra={"cache_key": cache_key[:8]},
            )
            return icon_url

        return None

    def set(self, item_description: str, image_data: bytes) -> str:
        """캐시에 아이콘을 저장합니다 (64x64 리사이징 포함).

        Args:
            item_description: 아이템 설명
            image_data: 이미지 바이트 데이터

        Returns:
            str: 저장된 아이콘의 URL
        """
        import io

        from PIL import Image

        cache_key = self._make_cache_key(item_description)
        cache_path = self._cache_dir / f"{cache_key}.png"

        # 리사이징 (U-075 핫픽스: 모델 생성본 1024x1024 -> 64x64)
        try:
            with Image.open(io.BytesIO(image_data)) as img:
                # 64x64로 리사이징 (LANCZOS 필터로 품질 유지)
                if img.size != (ICON_SIZE, ICON_SIZE):
                    img = img.resize((ICON_SIZE, ICON_SIZE), Image.Resampling.LANCZOS)  # type: ignore[reportUnknownMemberType]

                # 바이트로 다시 변환하여 저장
                output = io.BytesIO()
                img.save(output, format="PNG")
                processed_data = output.getvalue()
                cache_path.write_bytes(processed_data)

                logger.debug(
                    "[IconCache] 이미지 리사이징 완료",
                    extra={
                        "original_size": f"{img.size[0]}x{img.size[1]}",
                        "target_size": f"{ICON_SIZE}x{ICON_SIZE}",
                    },
                )
        except Exception as e:
            logger.warning(
                "[IconCache] 리사이징 실패, 원본 저장",
                extra={"error": str(e)},
            )
            cache_path.write_bytes(image_data)
            processed_data = image_data

        # URL 생성 및 메모리 캐시 저장
        icon_url = build_image_url(f"{ICON_CACHE_SUBDIR}/{cache_key}.png", category="generated")
        self._memory_cache[cache_key] = icon_url

        logger.info(
            "[IconCache] 아이콘 캐시 저장",
            extra={
                "cache_key": cache_key[:8],
                "size_bytes": len(processed_data),
            },
        )

        return icon_url

    def get_cache_path(self, item_description: str) -> Path:
        """캐시 파일 경로를 반환합니다.

        Args:
            item_description: 아이템 설명

        Returns:
            Path: 캐시 파일 경로
        """
        cache_key = self._make_cache_key(item_description)
        return self._cache_dir / f"{cache_key}.png"


# =============================================================================
# 재시도 판별 헬퍼 (U-093)
# =============================================================================


def _is_retryable_message(message: str) -> bool:
    """에러 메시지 기반으로 재시도 가능 여부를 판단합니다.

    재시도 제외: 4xx 클라이언트 에러, quota 초과, 안전 차단 등.

    Args:
        message: 에러 메시지

    Returns:
        bool: 재시도 가능 여부
    """
    message_lower = message.lower()
    return not any(keyword in message_lower for keyword in _NON_RETRYABLE_KEYWORDS)


def _is_retryable_exception(exc: Exception) -> bool:
    """예외 타입 기반으로 재시도 가능 여부를 판단합니다.

    재시도 가능: 네트워크/서버 에러 (ConnectionError, OSError 등).
    재시도 제외: 클라이언트 로직 에러 (ValueError, TypeError 등).

    Args:
        exc: 발생한 예외

    Returns:
        bool: 재시도 가능 여부
    """
    non_retryable_types = (ValueError, TypeError, AttributeError, KeyError)
    return not isinstance(exc, non_retryable_types)


# =============================================================================
# 아이콘 생성기
# =============================================================================


class ItemIconGenerator:
    """아이템 아이콘 동적 생성기.

    아이템 설명을 기반으로 64x64 픽셀 아트 아이콘을 생성합니다.
    Q1 결정: placeholder 먼저 반환 후 백그라운드에서 생성 (Option B)
    """

    def __init__(
        self,
        image_generator: ImageGeneratorType | None = None,
        cache: IconCache | None = None,
    ) -> None:
        """ItemIconGenerator를 초기화합니다.

        Args:
            image_generator: 이미지 생성기 (기본: get_image_generator())
            cache: 아이콘 캐시 (기본: 새 인스턴스)
        """
        self._image_generator = image_generator
        self._cache = cache or IconCache()
        self._pending_generations: dict[str, asyncio.Task[IconGenerationResponse]] = {}
        self._completed_urls: dict[str, str] = {}  # item_id -> icon_url (최근 완료된 항목)
        self._failed_generations: dict[str, str] = {}  # U-097: item_id -> error_message

        logger.info("[ItemIconGenerator] 초기화 완료")

    def _get_image_generator(self) -> ImageGeneratorType:
        """이미지 생성기를 lazy 로딩합니다."""
        if self._image_generator is None:
            from unknown_world.services.image_generation import get_image_generator

            self._image_generator = get_image_generator()
        return self._image_generator

    def _build_icon_prompt(self, item_description: str, language: str) -> str:
        """아이콘 생성 프롬프트를 구성합니다.

        U-092: nanobanana-mcp 프롬프트 스타일 적용.
        참조: vibe/ref/nanobanana-mcp.md §2.1 UI 아이콘 템플릿

        Args:
            item_description: 아이템 설명
            language: 세션 언어

        Returns:
            str: 이미지 생성 프롬프트
        """
        # 언어별 지시문
        lang_instruction = "한국어" if language == "ko-KR" else "English"

        # nanobanana 템플릿 기반: "A minimal [SUBJECT] icon, retro CRT phosphor style..."
        # 런타임 제약: rembg 없으므로 white 대신 dark background 사용
        return f"""\
A minimal icon of "{item_description}" ({lang_instruction}).

{ICON_STYLE_PROMPT}

Use the item's natural colors accented with CRT phosphor tones.
Background: solid dark #0d0d0d only. DO NOT use white or bright backgrounds.
{ICON_SIZE}x{ICON_SIZE} pixels, single centered object."""

    def get_placeholder_url(self, item_id: str) -> str:
        """placeholder 아이콘 URL을 반환합니다.

        Args:
            item_id: 아이템 ID

        Returns:
            str: placeholder 아이콘 URL
        """
        # 기본 placeholder (📦 이모지 사용)
        # 실제 구현에서는 정적 placeholder 이미지 경로를 반환할 수 있음
        return "/ui/icons/placeholder_item.png"

    async def generate_icon(
        self,
        request: IconGenerationRequest,
        *,
        wait_for_completion: bool = False,
    ) -> IconGenerationResponse:
        """아이템 아이콘을 생성합니다.

        Q1 결정 (Option B):
        - wait_for_completion=False: placeholder 즉시 반환, 백그라운드 생성
        - wait_for_completion=True: 생성 완료까지 대기

        Args:
            request: 아이콘 생성 요청
            wait_for_completion: 생성 완료까지 대기할지 여부

        Returns:
            IconGenerationResponse: 생성 결과
        """
        start_time = datetime.now(UTC)

        # 프롬프트 해시 (로깅용, 원문 노출 금지 - RULE-007)
        desc_hash = hashlib.md5(request.item_description.encode()).hexdigest()[:8]

        logger.debug(
            "[ItemIconGenerator] 아이콘 생성 요청",
            extra={
                "item_id": request.item_id,
                "desc_hash": desc_hash,
                "language": request.language,
                "wait": wait_for_completion,
            },
        )

        # 캐시 확인
        cached_url = self._cache.get(request.item_description)
        if cached_url:
            elapsed_ms = int((datetime.now(UTC) - start_time).total_seconds() * 1000)
            return IconGenerationResponse(
                status=IconGenerationStatus.CACHED,
                icon_url=cached_url,
                item_id=request.item_id,
                is_placeholder=False,
                generation_time_ms=elapsed_ms,
                message="캐시에서 아이콘을 반환했습니다.",
            )

        # Q1 Option B: 즉시 응답 모드 (placeholder 반환)
        if not wait_for_completion:
            # 백그라운드 생성 태스크가 없으면 시작
            if request.item_id not in self._pending_generations:
                task = asyncio.create_task(
                    self._generate_icon_internal(request),
                    name=f"icon_gen_{request.item_id}",
                )
                self._pending_generations[request.item_id] = task

                # U-097: 태스크 완료 시 결과 확인 및 상태 추적
                def _on_task_done(
                    t: asyncio.Task[IconGenerationResponse], item_id: str = request.item_id
                ) -> None:
                    self._pending_generations.pop(item_id, None)
                    try:
                        result = t.result()
                        if result.status == IconGenerationStatus.FAILED:
                            self._failed_generations[item_id] = result.message or "생성 실패"
                            logger.warning(
                                "[ItemIconGenerator] 백그라운드 아이콘 생성 실패",
                                extra={"item_id": item_id, "message": result.message},
                            )
                    except Exception as exc:
                        self._failed_generations[item_id] = str(exc)
                        logger.exception(
                            "[ItemIconGenerator] 백그라운드 태스크 예외",
                            extra={"item_id": item_id},
                        )

                task.add_done_callback(_on_task_done)

            elapsed_ms = int((datetime.now(UTC) - start_time).total_seconds() * 1000)
            return IconGenerationResponse(
                status=IconGenerationStatus.PENDING,
                icon_url=self.get_placeholder_url(request.item_id),
                item_id=request.item_id,
                is_placeholder=True,
                generation_time_ms=elapsed_ms,
                message="백그라운드에서 아이콘을 생성 중입니다.",
            )

        # 동기 생성 모드 (완료까지 대기)
        return await self._generate_icon_internal(request)

    async def _generate_icon_internal(
        self, request: IconGenerationRequest
    ) -> IconGenerationResponse:
        """내부 아이콘 생성 로직 (U-093: 재시도 지원).

        최대 ICON_MAX_RETRIES회 재시도하며, 지수 백오프를 적용합니다.
        재시도 대상: 타임아웃, 네트워크 에러, 5xx 응답.
        재시도 제외: 4xx 클라이언트 에러, quota 초과, 안전 차단.

        Args:
            request: 아이콘 생성 요청

        Returns:
            IconGenerationResponse: 생성 결과
        """
        start_time = datetime.now(UTC)
        desc_hash = hashlib.md5(request.item_description.encode()).hexdigest()[:8]
        max_attempts = ICON_MAX_RETRIES + 1  # 총 시도 횟수 (U-093 Q1: Option B → 2회)

        from unknown_world.services.image_generation import (
            ImageGenerationRequest,
            ImageGenerationStatus,
        )

        # 프롬프트 및 요청 구성 (1회만 - 재시도 시 동일 프롬프트 재사용)
        prompt = self._build_icon_prompt(request.item_description, request.language)

        # U-091: rembg 런타임 제거 - 배경 제거 없이 프롬프트로 어두운 배경 유도
        gen_request = ImageGenerationRequest(
            prompt=prompt,
            image_size="1024x1024",  # 모델 지원 표준 해상도 (U-075 핫픽스: 64x64 미지원)
            aspect_ratio="1:1",
            model_label="FAST",  # Q2: 아이콘은 저지연 모델
        )

        last_error_message: str | None = None

        for attempt in range(1, max_attempts + 1):
            try:
                generator = self._get_image_generator()
                response = await asyncio.wait_for(
                    generator.generate(gen_request),
                    timeout=ICON_GENERATION_TIMEOUT_SECONDS,
                )

                elapsed_ms = int((datetime.now(UTC) - start_time).total_seconds() * 1000)

                if response.status == ImageGenerationStatus.COMPLETED and response.image_url:
                    # 성공: 캐시에 저장
                    if response.image_id:
                        src_path = get_generated_images_dir() / f"{response.image_id}.png"
                        if src_path.exists():
                            image_data = src_path.read_bytes()
                            cached_url = self._cache.set(request.item_description, image_data)
                            self._completed_urls[request.item_id] = cached_url
                            logger.info(
                                "[ItemIconGenerator] 아이콘 생성 완료",
                                extra={
                                    "item_id": request.item_id,
                                    "desc_hash": desc_hash,
                                    "elapsed_ms": elapsed_ms,
                                    "attempt": attempt,
                                },
                            )
                            return IconGenerationResponse(
                                status=IconGenerationStatus.COMPLETED,
                                icon_url=cached_url,
                                item_id=request.item_id,
                                is_placeholder=False,
                                generation_time_ms=elapsed_ms,
                                message="아이콘이 성공적으로 생성되었습니다.",
                            )

                    # URL 직접 반환 (파일 복사 실패 시)
                    return IconGenerationResponse(
                        status=IconGenerationStatus.COMPLETED,
                        icon_url=response.image_url,
                        item_id=request.item_id,
                        is_placeholder=False,
                        generation_time_ms=elapsed_ms,
                        message="아이콘이 생성되었습니다.",
                    )

                # API 레벨 실패
                last_error_message = response.message or "아이콘 생성에 실패했습니다."

                # U-093: 재시도 가능 여부 판단 후 재시도
                if attempt < max_attempts and _is_retryable_message(last_error_message):
                    delay = ICON_RETRY_BASE_DELAY_SECONDS * (2 ** (attempt - 1))
                    logger.warning(
                        "[ItemIconGenerator] 아이콘 생성 실패, 재시도 예정",
                        extra={
                            "item_id": request.item_id,
                            "desc_hash": desc_hash,
                            "attempt": f"{attempt}/{max_attempts}",
                            "retry_delay_s": delay,
                            "error_msg": last_error_message,
                        },
                    )
                    await asyncio.sleep(delay)
                    continue

                # 재시도 불가 또는 마지막 시도
                break

            except TimeoutError:
                last_error_message = f"아이콘 생성 타임아웃 ({ICON_GENERATION_TIMEOUT_SECONDS}초)"

                # U-093: 타임아웃은 항상 재시도 대상
                if attempt < max_attempts:
                    delay = ICON_RETRY_BASE_DELAY_SECONDS * (2 ** (attempt - 1))
                    logger.warning(
                        "[ItemIconGenerator] 아이콘 생성 타임아웃, 재시도 예정",
                        extra={
                            "item_id": request.item_id,
                            "desc_hash": desc_hash,
                            "attempt": f"{attempt}/{max_attempts}",
                            "retry_delay_s": delay,
                            "timeout_seconds": ICON_GENERATION_TIMEOUT_SECONDS,
                        },
                    )
                    await asyncio.sleep(delay)
                    continue
                break

            except Exception as e:
                error_type = type(e).__name__
                last_error_message = f"아이콘 생성 중 오류: {error_type}"

                # U-093: 재시도 가능 예외인 경우만 재시도
                if attempt < max_attempts and _is_retryable_exception(e):
                    delay = ICON_RETRY_BASE_DELAY_SECONDS * (2 ** (attempt - 1))
                    logger.warning(
                        "[ItemIconGenerator] 아이콘 생성 중 오류, 재시도 예정",
                        extra={
                            "item_id": request.item_id,
                            "desc_hash": desc_hash,
                            "attempt": f"{attempt}/{max_attempts}",
                            "retry_delay_s": delay,
                            "error_type": error_type,
                        },
                    )
                    await asyncio.sleep(delay)
                    continue

                # 재시도 불가 에러 (로깅 후 종료)
                logger.exception(
                    "[ItemIconGenerator] 아이콘 생성 중 복구 불가 오류",
                    extra={
                        "item_id": request.item_id,
                        "error_type": error_type,
                    },
                )
                break

        # 모든 시도 실패 → placeholder 유지 (RULE-004: 안전한 폴백)
        elapsed_ms = int((datetime.now(UTC) - start_time).total_seconds() * 1000)
        logger.warning(
            "[ItemIconGenerator] 아이콘 생성 최종 실패",
            extra={
                "item_id": request.item_id,
                "desc_hash": desc_hash,
                "total_attempts": max_attempts,
                "elapsed_ms": elapsed_ms,
            },
        )
        return IconGenerationResponse(
            status=IconGenerationStatus.FAILED,
            icon_url=self.get_placeholder_url(request.item_id),
            item_id=request.item_id,
            is_placeholder=True,
            generation_time_ms=elapsed_ms,
            message=f"아이콘 생성 실패 ({max_attempts}/{max_attempts} 시도): {last_error_message}",
        )

    async def get_icon_status(
        self, item_id: str, request: IconGenerationRequest | None = None
    ) -> IconGenerationStatus:
        """아이콘 생성 상태를 확인합니다.

        Args:
            item_id: 아이템 ID
            request: 아이콘 생성 요청 (캐시 확인용)

        Returns:
            IconGenerationStatus: 현재 상태
        """
        # 현재 진행 중인 태스크 확인
        if item_id in self._pending_generations:
            task = self._pending_generations[item_id]
            if task.done():
                return IconGenerationStatus.COMPLETED
            return IconGenerationStatus.GENERATING

        # 최근 완료된 항목 확인
        if item_id in self._completed_urls:
            return IconGenerationStatus.COMPLETED

        # U-097: 실패한 생성 확인 (백그라운드 태스크 완료 후 실패 추적)
        if item_id in self._failed_generations:
            return IconGenerationStatus.FAILED

        # 캐시 확인 (request가 있는 경우)
        if request and self._cache.get(request.item_description):
            return IconGenerationStatus.COMPLETED

        return IconGenerationStatus.PENDING


# =============================================================================
# 싱글톤 인스턴스
# =============================================================================

_generator_instance: ItemIconGenerator | None = None


def get_item_icon_generator() -> ItemIconGenerator:
    """ItemIconGenerator 싱글톤 인스턴스를 반환합니다."""
    global _generator_instance
    if _generator_instance is None:
        _generator_instance = ItemIconGenerator()
    return _generator_instance


def reset_item_icon_generator() -> None:
    """테스트용 싱글톤 리셋."""
    global _generator_instance
    _generator_instance = None
</file>

<file path="frontend/src/components/AgentConsole.tsx">
/**
 * Unknown World - Agent Console 컴포넌트.
 *
 * 에이전트형 시스템임을 UI로 증명하기 위한 컴포넌트입니다.
 * Plan/Queue/Badges/Auto-repair 트레이스를 실시간으로 표시합니다.
 *
 * U-123: 접기 제거 + 대기열 상단 + 배지 하단 (항상 노출)
 *   - Queue(대기열): 상단 항상 노출, idle 시 "대기 중..." 표시
 *   - Badges(검증배지): 하단 항상 노출 (접기/펼치기 토글 제거)
 *   - 구분선으로 대기열/배지 영역 시각적 분리
 *
 * U-082: Agent Console 축소 기반 (레이아웃 축소 범위 유지)
 *
 * 설계 원칙:
 *   - RULE-008: 단계/배지/복구만 보여줌 (프롬프트/내부 추론 노출 금지)
 *   - RULE-002: 게임 UI로 표현 (채팅 버블 금지)
 *
 * @module components/AgentConsole
 */

import { useTranslation } from 'react-i18next';
import {
  useAgentStore,
  selectIsStreaming,
  selectPhases,
  selectBadges,
  selectRepairCount,
  selectError,
  selectModelLabel,
  type PhaseInfo,
} from '../stores/agentStore';
import type { ValidationBadge, ModelLabel } from '../schemas/turn';

// =============================================================================
// 상수 정의
// =============================================================================

/** 단계 표시 이름 i18n 키 */
const PHASE_KEYS: Record<string, string> = {
  parse: 'agent.console.phase.parse',
  validate: 'agent.console.phase.validate',
  plan: 'agent.console.phase.plan',
  resolve: 'agent.console.phase.resolve',
  render: 'agent.console.phase.render',
  verify: 'agent.console.phase.verify',
  commit: 'agent.console.phase.commit',
};

/** 배지 표시 정보 (i18n 키 기반) */
const BADGE_INFO: Record<ValidationBadge, { labelKey: string; isOk: boolean }> = {
  schema_ok: { labelKey: 'agent.console.badge.schema', isOk: true },
  schema_fail: { labelKey: 'agent.console.badge.schema', isOk: false },
  economy_ok: { labelKey: 'agent.console.badge.economy', isOk: true },
  economy_fail: { labelKey: 'agent.console.badge.economy', isOk: false },
  safety_ok: { labelKey: 'agent.console.badge.safety', isOk: true },
  safety_blocked: { labelKey: 'agent.console.badge.safety', isOk: false },
  consistency_ok: { labelKey: 'agent.console.badge.consistency', isOk: true },
  consistency_fail: { labelKey: 'agent.console.badge.consistency', isOk: false },
};

/** 모델 라벨 표시 정보 (U-069: FAST/QUALITY) */
const MODEL_LABEL_INFO: Record<ModelLabel, { labelKey: string; icon: string; colorClass: string }> =
  {
    FAST: { labelKey: 'agent.console.model.fast', icon: '\u26A1', colorClass: 'model-fast' },
    QUALITY: {
      labelKey: 'agent.console.model.quality',
      icon: '\u2605',
      colorClass: 'model-quality',
    },
    CHEAP: { labelKey: 'agent.console.model.cheap', icon: '\u{1F4B0}', colorClass: 'model-cheap' },
    REF: { labelKey: 'agent.console.model.ref', icon: '\u{1F4F7}', colorClass: 'model-ref' },
  };

// =============================================================================
// 하위 컴포넌트
// =============================================================================

/** 단계 상태 아이콘 */
function PhaseIcon({ status }: { status: PhaseInfo['status'] }) {
  switch (status) {
    case 'pending':
      return <span className="phase-icon pending">○</span>;
    case 'in_progress':
      return <span className="phase-icon in-progress">◎</span>;
    case 'completed':
      return <span className="phase-icon completed">●</span>;
    case 'failed':
      return <span className="phase-icon failed">✕</span>;
    default:
      return <span className="phase-icon">○</span>;
  }
}

/** 단계 큐 항목 */
function PhaseQueueItem({ phase }: { phase: PhaseInfo }) {
  const { t } = useTranslation();
  const key = PHASE_KEYS[phase.name];
  const label = key ? t(key) : phase.name;
  const statusClass = `phase-item ${phase.status}`;

  return (
    <div className={statusClass}>
      <PhaseIcon status={phase.status} />
      <span className="phase-label">{label}</span>
    </div>
  );
}

/**
 * 대기열(Queue): 항상 노출 - U-114
 *
 * 스트리밍 중이거나 단계가 진행된 경우 7단계 큐를 표시하고,
 * idle 상태(턴 미처리)에서는 "대기 중..." 텍스트를 표시합니다.
 * Q1: Option A - idle 시 "대기 중..." 텍스트
 */
function AlwaysVisibleQueue() {
  const { t } = useTranslation();
  const isStreaming = useAgentStore(selectIsStreaming);
  const phases = useAgentStore(selectPhases);

  return (
    <div className="agent-queue-always">
      <div className="queue-label">{t('agent.console.queue')}</div>
      {isStreaming ? (
        <div className="queue-items">
          {phases.map((phase) => (
            <PhaseQueueItem key={phase.name} phase={phase} />
          ))}
        </div>
      ) : (
        <div className="queue-idle">{t('agent.console.queue_idle')}</div>
      )}
    </div>
  );
}

/** 배지 아이템 */
function BadgeItem({ badge }: { badge: ValidationBadge }) {
  const { t } = useTranslation();
  const info = BADGE_INFO[badge];
  if (!info) return null;

  const statusClass = info.isOk ? 'badge-ok' : 'badge-fail';
  const statusText = info.isOk ? t('agent.console.badge.ok') : t('agent.console.badge.fail');
  const iconName = info.isOk ? 'badge-ok-24.png' : 'badge-fail-24.png';
  const fallbackIcon = info.isOk ? '✓' : '✗';

  return (
    <div className={`badge-item ${statusClass}`}>
      <span className="badge-label">{t(info.labelKey)}</span>
      <span className="badge-status">
        <span className="icon-wrapper">
          <img
            src={`/ui/icons/${iconName}`}
            alt=""
            aria-hidden="true"
            className="badge-icon-img"
            onError={(e) => e.currentTarget.classList.add('hidden')}
          />
          <span className="icon-fallback" style={{ fontSize: '0.625rem' }}>
            {fallbackIcon}
          </span>
        </span>
        {statusText}
      </span>
    </div>
  );
}

/** 배지 패널 */
function BadgesPanel() {
  const { t } = useTranslation();
  const badges = useAgentStore(selectBadges);

  if (badges.length === 0) {
    return (
      <div className="badges-panel">
        <div className="badges-label">{t('agent.console.badges')}</div>
        <div className="badges-empty">{t('agent.console.badges_empty')}</div>
      </div>
    );
  }

  return (
    <div className="badges-panel">
      <div className="badges-label">{t('agent.console.badges')}</div>
      <div className="badges-grid">
        {badges.map((badge, index) => (
          <BadgeItem key={`${badge}-${index}`} badge={badge} />
        ))}
      </div>
    </div>
  );
}

/** Auto-repair 트레이스 */
function RepairTrace() {
  const { t } = useTranslation();
  const repairCount = useAgentStore(selectRepairCount);
  const isStreaming = useAgentStore(selectIsStreaming);

  if (repairCount === 0 && !isStreaming) {
    return null;
  }

  return (
    <div className="repair-trace">
      <span className="repair-label">{t('agent.console.repair')}</span>
      <span className="repair-count">#{repairCount}</span>
      {repairCount > 0 && (
        <span className="repair-status text-warning"> {t('agent.console.repaired')}</span>
      )}
    </div>
  );
}

/**
 * 모델 라벨 배지 (U-069: FAST/QUALITY 표시)
 *
 * 현재 텍스트 생성에 사용된 모델을 시각적으로 표시합니다.
 * - FAST: 빠른 응답, 기본 비용 (⚡)
 * - QUALITY: 고품질 응답, 2배 비용 (★)
 */
function ModelLabelBadge() {
  const { t } = useTranslation();
  const modelLabel = useAgentStore(selectModelLabel);
  const info = MODEL_LABEL_INFO[modelLabel];

  if (!info) return null;

  // i18n 키가 없으면 폴백 텍스트 사용
  const label = t(info.labelKey, { defaultValue: modelLabel });

  return (
    <div className={`model-label-badge ${info.colorClass}`}>
      <span className="model-icon">{info.icon}</span>
      <span className="model-text">{label}</span>
    </div>
  );
}

/** 에러 표시 (U-130: RATE_LIMITED 전용 스타일 추가) */
function ErrorDisplay() {
  const { t } = useTranslation();
  const error = useAgentStore(selectError);

  if (!error) return null;

  // U-130: RATE_LIMITED 에러는 전용 경고 스타일로 표시
  if (error.code === 'RATE_LIMITED') {
    return (
      <div className="agent-error agent-error--rate-limited">
        <span className="error-icon">⏳</span>
        <span className="error-message">{t('error.rate_limited')}</span>
      </div>
    );
  }

  return (
    <div className="agent-error">
      <span className="error-icon">⚠</span>
      <span className="error-message">{error.message}</span>
      {error.code && <span className="error-code">[{error.code}]</span>}
    </div>
  );
}

/** 스트리밍 상태 표시 */
function StreamingStatus() {
  const { t } = useTranslation();
  const isStreaming = useAgentStore(selectIsStreaming);

  return (
    <div className="streaming-status">
      <span className={`status-dot ${isStreaming ? 'active' : ''}`} />
      <span className="status-text">
        {isStreaming ? t('agent.console.status.processing') : t('agent.console.status.idle')}
      </span>
    </div>
  );
}

// =============================================================================
// 메인 컴포넌트
// =============================================================================

/**
 * Agent Console 컴포넌트.
 *
 * U-123: 접기 제거 + 대기열 상단 + 배지 하단 항상 노출.
 *   - Queue: 상단 항상 표시 (idle 시 "대기 중..." 텍스트)
 *   - 구분선: CRT 테마 반투명 구분선으로 영역 분리
 *   - Badges: 하단 항상 표시 (접기/펼치기 토글 없음)
 *   - RepairTrace: 배지 아래 조건부 표시
 *
 * RULE-008에 따라 프롬프트/내부 추론은 노출하지 않습니다.
 * U-037: data-ui-importance="critical" 마킹으로 가독성 보장
 * U-069: 현재 사용 중인 모델 라벨(FAST/QUALITY) 표시 추가
 */
export function AgentConsole() {
  return (
    <div className="agent-console-content" data-ui-importance="critical">
      {/* 상단: StreamingStatus + ModelLabel + Queue(대기열) */}
      <div className="agent-console-always">
        <div className="agent-console-summary">
          <StreamingStatus />
          <ModelLabelBadge />
        </div>
        <AlwaysVisibleQueue />
      </div>

      {/* U-123: CRT 테마 구분선 (Q1: Option A - 얇은 구분선) */}
      <hr className="agent-console-divider" />

      {/* 하단: Badges(검증 배지) + RepairTrace — 항상 노출 */}
      <div className="agent-badges-section">
        <BadgesPanel />
        <RepairTrace />
      </div>

      {/* 에러는 항상 표시 */}
      <ErrorDisplay />
    </div>
  );
}

export default AgentConsole;
</file>

<file path="frontend/src/save/saveGame.ts">
/**
 * Unknown World - Legacy SaveGame 정리 모듈 (U-116[Mvp]).
 *
 * SaveGame 시스템은 U-116에서 완전 제거되었습니다.
 * 이 모듈은 기존 사용자의 LocalStorage에 남아있는 레거시 데이터를
 * 정리하는 유틸리티만 제공합니다.
 *
 * MMP에서 세션 영속성을 재설계할 때(U-113) 이 파일은 새로운 역할을 가질 수 있습니다.
 *
 * @module save/saveGame
 */

import { LEGACY_SAVEGAME_STORAGE_KEY, LEGACY_PROFILE_STORAGE_KEY } from './constants';

// =============================================================================
// Legacy 데이터 정리
// =============================================================================

/**
 * 기존 SaveGame 레거시 데이터를 LocalStorage에서 정리합니다.
 *
 * U-116: 부팅 시 1회 호출하여 이전 버전의 SaveGame 잔재를 제거합니다.
 * - `unknown_world_savegame` 키 제거
 * - `unknown_world_current_profile` 키 제거
 *
 * 언어 설정(`unknown_world_language`)은 유지합니다 (Q1 Option B).
 */
export function clearLegacySaveData(): void {
  try {
    localStorage.removeItem(LEGACY_SAVEGAME_STORAGE_KEY);
    localStorage.removeItem(LEGACY_PROFILE_STORAGE_KEY);
  } catch (error) {
    console.error('[SaveGame] 레거시 데이터 정리 실패:', error);
  }
}
</file>

<file path="backend/src/unknown_world/main.py">
"""Unknown World - FastAPI 애플리케이션 엔트리포인트

이 모듈은 Unknown World 백엔드의 FastAPI 앱을 정의합니다.
MVP 단계에서는 기본 헬스체크와 개발용 CORS 설정만 포함합니다.

실행 방법:
    cd backend
    uv sync
    uv run uvicorn unknown_world.main:app --reload --port 8011

참조:
    - vibe/tech-stack.md (버전 SSOT)
    - vibe/prd.md (에이전트형 게임 엔진 요구사항)
    - .cursor/rules/20-backend-orchestrator.mdc (SSE/검증/복구 규칙)
"""

# ruff: noqa: E402
# E402 무시: .env 로딩은 의도적으로 다른 import보다 먼저 실행되어야 함 (U-047)

# =============================================================================
# .env 자동 로딩 (U-047)
# =============================================================================
# 로컬 개발에서 backend/.env 파일이 있으면 자동 로딩합니다.
# - override=False: 이미 설정된 환경변수는 덮어쓰지 않음 (운영 환경 SSOT 보장)
# - 파일 미존재 시 no-op (운영/CI에서 파일 미존재를 기본으로 허용)
# - 페어링 질문 Q1 결정: Option A (import 시점에 로드)
#
# 보안 규칙:
#   - .env 파일은 레포에 커밋 금지 (.gitignore 필수)
#   - 민감 정보(키/토큰/프롬프트)는 로그/스트림/UI에 노출 금지 (RULE-007)
import os
from pathlib import Path

from dotenv import load_dotenv

# .env 파일 경로 (backend 디렉토리 기준)
# main.py 위치: backend/src/unknown_world/main.py
# backend/.env 위치: backend/.env (3단계 상위)
# resolve()로 절대 경로 보장
_DOTENV_PATH = Path(__file__).resolve().parent.parent.parent / ".env"

# .env 로딩 (override=False: 기존 환경변수 우선)
_dotenv_loaded = load_dotenv(dotenv_path=_DOTENV_PATH, override=False)

# 디버그: .env 로딩 상태 즉시 출력 (U-047 검증용)
import sys

print(f"[Startup] .env path: {_DOTENV_PATH}", file=sys.stderr)
print(f"[Startup] .env exists: {_DOTENV_PATH.exists()}", file=sys.stderr)
print(f"[Startup] dotenv loaded: {_dotenv_loaded}", file=sys.stderr)
import os as _os_temp

print(f"[Startup] UW_MODE: {_os_temp.environ.get('UW_MODE', 'NOT_SET')}", file=sys.stderr)

import logging
from collections.abc import AsyncGenerator
from contextlib import asynccontextmanager
from typing import Literal

from fastapi import FastAPI
from fastapi.middleware.cors import CORSMiddleware
from fastapi.staticfiles import StaticFiles
from pydantic import BaseModel

from unknown_world import __version__
from unknown_world.api import image_router, item_icon_router, scanner_router, turn_router
from unknown_world.storage.paths import BASE_DATA_DIR, STATIC_URL_PREFIX
from unknown_world.storage.seed import seed_scene_images

# =============================================================================
# 로거 설정
# =============================================================================

logger = logging.getLogger(__name__)

# =============================================================================
# .env 로딩 상태 로깅 (U-047)
# =============================================================================
# 민감 정보(키/토큰/경로)는 출력하지 않음 (RULE-007/008)
# 모드/환경 정도만 로깅하여 디버깅 용이성 확보

_uw_mode = os.environ.get("UW_MODE", "mock")  # 기본값: mock (genai_client.py 정책)
_environment = os.environ.get("ENVIRONMENT", "development")

if _dotenv_loaded:
    logger.info(
        "[Config] .env 파일 로드 완료",
        extra={
            "dotenv_path": str(_DOTENV_PATH),
            "UW_MODE": _uw_mode,
            "ENVIRONMENT": _environment,
        },
    )
else:
    logger.debug(
        "[Config] .env 파일 미존재 또는 로드 실패 (기본값 사용)",
        extra={
            "UW_MODE": _uw_mode,
            "ENVIRONMENT": _environment,
        },
    )

# =============================================================================
# Lifespan (서버 시작/종료 이벤트)
# =============================================================================


@asynccontextmanager
async def lifespan(app: FastAPI) -> AsyncGenerator[None]:
    """FastAPI 앱 lifespan 관리.

    서버 시작 시:
        - 기본 초기화 (U-091: rembg preflight 제거됨)

    서버 종료 시:
        - 필요한 정리 작업 수행
    """
    # =========================================================================
    # Startup
    # =========================================================================
    logger.info("[Startup] Unknown World 백엔드 시작")

    # U-124: 사전 생성 씬 이미지를 백엔드 output 디렉터리에 시드
    # 프론트엔드 WebP → 백엔드 PNG 변환 (Gemini 참조 이미지 파이프라인용)
    seed_scene_images()

    logger.info("[Startup] Unknown World 백엔드 시작 완료")

    yield

    # =========================================================================
    # Shutdown
    # =========================================================================
    logger.info("[Shutdown] Unknown World 백엔드 종료")


# =============================================================================
# FastAPI 앱 인스턴스
# =============================================================================

app = FastAPI(
    title="Unknown World API",
    description="Gemini 기반 에이전트형 게임 엔진 오케스트레이터",
    version=__version__,
    docs_url="/docs",
    redoc_url="/redoc",
    lifespan=lifespan,
)

# =============================================================================
# 정적 파일 서빙 (U-019, RU-006-Q5)
# =============================================================================
# 데이터 디렉토리 생성 및 정적 파일 서빙
# 전체 .data 디렉토리를 /static으로 서빙하여 카테고리별 경로 지원
# 예: /static/images/generated/img_xxx.png
BASE_DATA_DIR.mkdir(parents=True, exist_ok=True)
app.mount(STATIC_URL_PREFIX, StaticFiles(directory=str(BASE_DATA_DIR)), name="static")

# =============================================================================
# CORS 설정 (개발 환경용)
# =============================================================================
# PRD 요구: 로컬 개발에서 프론트와 통신할 수 있도록 CORS 기본 정책 준비
# RULE-011: 프론트엔드는 8001~8010 포트 사용
# 주의: 프로덕션에서는 MMP 단계에서 엄격한 정책으로 변경해야 함

ALLOWED_ORIGINS = [
    # 프론트엔드 개발 서버 포트 범위 (RULE-011: 8001~8010)
    *[f"http://localhost:{port}" for port in range(8001, 8011)],
    *[f"http://127.0.0.1:{port}" for port in range(8001, 8011)],
]

app.add_middleware(
    CORSMiddleware,
    allow_origins=ALLOWED_ORIGINS,
    allow_credentials=True,
    allow_methods=["*"],
    allow_headers=["*"],
)

# =============================================================================
# 라우터 등록
# =============================================================================

# U-007: /api/turn HTTP Streaming 엔드포인트
app.include_router(turn_router)

# U-019: /api/image 이미지 생성 엔드포인트
app.include_router(image_router)

# U-021: /api/scan 이미지 이해(Scanner) 엔드포인트
app.include_router(scanner_router)

# U-075: /api/item 아이템 아이콘 생성 엔드포인트
app.include_router(item_icon_router)


# =============================================================================
# 응답 스키마 (Pydantic)
# =============================================================================


class HealthResponse(BaseModel):
    """헬스체크 응답 스키마.

    Attributes:
        status: 서버 상태 ("ok" 또는 "degraded")
        version: 백엔드 버전
        service: 서비스 이름
    """

    status: Literal["ok", "degraded"]
    version: str
    service: str


# =============================================================================
# 라우트 정의
# =============================================================================


@app.get("/health", response_model=HealthResponse, tags=["System"])
async def health_check() -> HealthResponse:
    """서버 헬스체크 엔드포인트.

    서버가 정상적으로 작동 중인지 확인합니다.
    이 엔드포인트는 로드밸런서, 모니터링 시스템, 클라이언트 연결 확인에 사용됩니다.

    U-091: rembg 런타임 제거 - 배경 제거 상태 정보 더 이상 포함하지 않음.

    Returns:
        HealthResponse: 서버 상태 정보
    """
    return HealthResponse(
        status="ok",
        version=__version__,
        service="unknown-world-backend",
    )


@app.get("/", tags=["System"])
async def root() -> dict[str, str]:
    """루트 엔드포인트.

    API 정보를 간략히 안내합니다.

    Returns:
        dict: 기본 안내 메시지
    """
    return {
        "message": "Unknown World API",
        "docs": "/docs",
        "health": "/health",
    }
</file>

<file path="frontend/src/components/InventoryPanel.test.tsx">
import { describe, it, expect, vi, beforeEach, afterEach } from 'vitest';
import { render, screen, fireEvent, act } from '@testing-library/react';
import { InventoryPanel } from './InventoryPanel';
import { useInventoryStore } from '../stores/inventoryStore';
import { ITEM_SELL_PRICE_SIGNAL } from '../save/constants';

// i18next 모킹
vi.mock('react-i18next', () => ({
  useTranslation: () => ({
    t: (key: string, params?: Record<string, unknown>) => {
      if (key === 'inventory.sell_tooltip' || key === 'inventory.sell_aria') {
        return `${key} (price: ${params?.price})`;
      }
      return key;
    },
    i18n: {
      language: 'ko',
    },
  }),
  initReactI18next: {
    type: '3rdParty',
    init: () => {},
  },
}));

// worldStore 모킹
const mockSellItem = vi.fn();
vi.mock('../stores/worldStore', () => ({
  useWorldStore: <T,>(selector: (state: { sellItem: typeof mockSellItem }) => T) => {
    const state = {
      sellItem: mockSellItem,
    };
    return selector ? selector(state) : state;
  },
}));

// dnd-kit 모킹
vi.mock('@dnd-kit/core', async (importOriginal) => {
  const actual = await importOriginal<typeof import('@dnd-kit/core')>();
  return {
    ...actual,
    useDraggable: vi.fn(({ id }) => ({
      attributes: { role: 'button', 'aria-describedby': `DndDescribedBy-${id}` },
      listeners: { onPointerDown: vi.fn() },
      setNodeRef: vi.fn(),
      transform: null,
      isDragging: false,
    })),
    DragOverlay: ({ children }: { children: React.ReactNode }) => (
      <div data-testid="drag-overlay">{children}</div>
    ),
  };
});

describe('InventoryPanel (U-117)', () => {
  beforeEach(() => {
    useInventoryStore.getState().reset();
  });

  it('should apply drag listeners and attributes to the entire row div', () => {
    useInventoryStore.getState().addItems([
      {
        id: 'test-item-1',
        name: 'Test Item 1',
        quantity: 1,
        icon: '📦',
      },
    ]);

    render(<InventoryPanel />);

    const itemRow = screen.getByRole('listbox').children[0];
    expect(itemRow).toHaveAttribute('role', 'button');
    expect(itemRow).toHaveAttribute('aria-describedby', 'DndDescribedBy-test-item-1');
    expect(itemRow).toHaveClass('inventory-item');
  });

  it('should render only the icon in DragOverlay when dragging', () => {
    const testItem = {
      id: 'test-drag-item',
      name: 'Dragging Item',
      quantity: 1,
      icon: '🔥',
    };
    useInventoryStore.getState().addItems([testItem]);
    useInventoryStore.getState().startDrag(testItem.id);

    render(<InventoryPanel />);

    const overlay = screen.getByTestId('drag-overlay');
    const ghostIcon = overlay.querySelector('.inventory-overlay-icon');
    expect(ghostIcon).toBeInTheDocument();
    expect(ghostIcon).toHaveTextContent('🔥');
    expect(ghostIcon).not.toHaveTextContent('Dragging Item');
  });
});

describe('InventoryPanel (U-129: Sell UX)', () => {
  beforeEach(() => {
    useInventoryStore.getState().reset();
    mockSellItem.mockClear();
    vi.useFakeTimers();
  });

  afterEach(() => {
    vi.restoreAllMocks();
    vi.useRealTimers();
  });

  it('should always show sell button with correct price', () => {
    useInventoryStore.getState().addItems([
      {
        id: 'test-item',
        name: 'Sellable Item',
        quantity: 1,
        icon: '💎',
      },
    ]);

    render(<InventoryPanel />);

    const sellBtn = screen.getByRole('button', { name: /inventory.sell_aria/ });
    expect(sellBtn).toBeInTheDocument();
    expect(sellBtn).toHaveTextContent(`+${ITEM_SELL_PRICE_SIGNAL}`);
  });

  it('should transition to confirm state on first click', () => {
    useInventoryStore.getState().addItems([
      {
        id: 'test-item',
        name: 'Sellable Item',
        quantity: 1,
        icon: '💎',
      },
    ]);

    render(<InventoryPanel />);

    const sellBtn = screen.getByRole('button', { name: /inventory.sell_aria/ });
    fireEvent.click(sellBtn);

    expect(sellBtn).toHaveTextContent('inventory.sell_confirm');
    expect(sellBtn).toHaveClass('confirming');
    expect(mockSellItem).not.toHaveBeenCalled();
  });

  it('should execute sellItem on second click within 2 seconds', () => {
    useInventoryStore.getState().addItems([
      {
        id: 'test-item',
        name: 'Sellable Item',
        quantity: 1,
        icon: '💎',
      },
    ]);

    render(<InventoryPanel />);

    const sellBtn = screen.getByRole('button', { name: /inventory.sell_aria/ });
    fireEvent.click(sellBtn);
    fireEvent.click(sellBtn);

    expect(mockSellItem).toHaveBeenCalledWith('test-item', 'Sellable Item');
    expect(sellBtn).not.toHaveClass('confirming');
  });

  it('should revert to normal state after 2 seconds without second click', () => {
    useInventoryStore.getState().addItems([
      {
        id: 'test-item',
        name: 'Sellable Item',
        quantity: 1,
        icon: '💎',
      },
    ]);

    render(<InventoryPanel />);

    const sellBtn = screen.getByRole('button', { name: /inventory.sell_aria/ });
    fireEvent.click(sellBtn);
    expect(sellBtn).toHaveClass('confirming');

    act(() => {
      vi.advanceTimersByTime(2000);
    });

    expect(sellBtn).not.toHaveClass('confirming');
    expect(sellBtn).toHaveTextContent(`+${ITEM_SELL_PRICE_SIGNAL}`);
    expect(mockSellItem).not.toHaveBeenCalled();
  });
});
</file>

<file path="backend/src/unknown_world/models/turn.py">
"""Unknown World - TurnInput/TurnOutput Pydantic 스키마.

이 모듈은 Unknown World의 핵심 데이터 모델을 정의합니다.
Gemini Structured Outputs에 투입 가능한 JSON Schema(부분집합)를 생성할 수 있습니다.

설계 원칙:
    - RULE-003: 구조화 출력(JSON Schema) 우선 + 이중 검증
    - RULE-005: 재화 인바리언트 (cost, balance_after 필수, 잔액 음수 금지)
    - RULE-006: ko/en 언어 정책 (Language enum으로 고정)
    - RULE-009: 좌표 규약 (0~1000, bbox [ymin,xmin,ymax,xmax])

사용 예시:
    # Gemini Structured Outputs용 JSON Schema 생성
    schema = TurnOutput.model_json_schema()

    # 응답 검증
    output = TurnOutput.model_validate_json(gemini_response_text)

참조:
    - vibe/prd.md 8.7 (데이터 모델 설계)
    - vibe/ref/structured-outputs-guide.md
    - .cursor/rules/00-core-critical.mdc
"""

from enum import Enum
from typing import Annotated

from pydantic import BaseModel, ConfigDict, Field

# =============================================================================
# 공통 Enum 타입
# =============================================================================


class Language(str, Enum):
    """지원 언어 (RULE-006).

    ko/en 혼합 출력 금지. TurnInput.language를 SSOT로 삼아
    모든 UI/내러티브/시스템 메시지는 동일 언어로 고정합니다.
    """

    KO = "ko-KR"
    EN = "en-US"


class Theme(str, Enum):
    """테마 설정."""

    DARK = "dark"
    LIGHT = "light"


class AgentPhase(str, Enum):
    """에이전트 실행 단계 (RULE-008).

    에이전트형 시스템임을 UI로 증명하기 위한 단계 표시.
    """

    PARSE = "parse"
    VALIDATE = "validate"
    PLAN = "plan"
    RESOLVE = "resolve"
    RENDER = "render"
    VERIFY = "verify"
    COMMIT = "commit"


class ValidationBadge(str, Enum):
    """검증 배지 (RULE-008).

    턴 결과에 대한 검증 상태를 표시합니다.
    """

    SCHEMA_OK = "schema_ok"
    SCHEMA_FAIL = "schema_fail"
    ECONOMY_OK = "economy_ok"
    ECONOMY_FAIL = "economy_fail"
    SAFETY_OK = "safety_ok"
    SAFETY_BLOCKED = "safety_blocked"
    CONSISTENCY_OK = "consistency_ok"
    CONSISTENCY_FAIL = "consistency_fail"


class ModelLabel(str, Enum):
    """모델/품질 선택 라벨 (RULE-008).

    프롬프트 노출 없이 "왜 이 선택이었는지"를 사용자 친화 라벨로 표시.
    """

    FAST = "FAST"
    QUALITY = "QUALITY"
    CHEAP = "CHEAP"
    REF = "REF"


class RiskLevel(str, Enum):
    """행동 위험도 수준."""

    LOW = "low"
    MEDIUM = "medium"
    HIGH = "high"


# =============================================================================
# 공통 하위 타입
# =============================================================================

# RULE-009: 좌표는 0~1000 정규화 좌표계 (이미지 이해 bbox 포맷과 호환)
Coordinate = Annotated[int, Field(ge=0, le=1000, description="정규화 좌표 (0~1000)")]


class Box2D(BaseModel):
    """2D 바운딩 박스 (RULE-009).

    좌표는 0~1000 정규화 좌표계이며, bbox는 [ymin, xmin, ymax, xmax] 순서입니다.
    이미지 이해 bbox 포맷과 호환됩니다.

    Attributes:
        ymin: Y 최소값 (상단)
        xmin: X 최소값 (좌측)
        ymax: Y 최대값 (하단)
        xmax: X 최대값 (우측)
    """

    model_config = ConfigDict(extra="forbid")

    ymin: Coordinate
    xmin: Coordinate
    ymax: Coordinate
    xmax: Coordinate


class CurrencyAmount(BaseModel):
    """재화 수량.

    Attributes:
        signal: 기본 재화 (텍스트 턴/이미지 생성/고급 기능에 소비)
        memory_shard: 희귀 재화 (중요 설정 고정, 고해상도 이미지 등에 소비)
    """

    model_config = ConfigDict(extra="forbid")

    signal: Annotated[int, Field(ge=0, description="시그널 (기본 재화, 0 이상)")]
    memory_shard: Annotated[int, Field(ge=0, description="기억 파편 (희귀 재화, 0 이상)")]


# =============================================================================
# TurnInput 관련 타입
# =============================================================================


class ClickInput(BaseModel):
    """클릭 입력 정보.

    화면 오브젝트 클릭 시 전달되는 정보입니다.

    Attributes:
        object_id: 클릭한 오브젝트 ID
        box_2d: 클릭 위치의 바운딩 박스 (선택)
    """

    model_config = ConfigDict(extra="forbid")

    object_id: str = Field(description="클릭한 오브젝트 ID")
    box_2d: Box2D | None = Field(default=None, description="클릭 위치 바운딩 박스 (선택)")


class DropInput(BaseModel):
    """드롭 입력 정보 (U-012).

    인벤토리 아이템을 핫스팟에 드롭할 때 전달되는 정보입니다.

    Attributes:
        item_id: 드롭한 인벤토리 아이템 ID
        target_object_id: 드롭 대상 핫스팟 오브젝트 ID
        target_box_2d: 드롭 대상의 바운딩 박스 (0~1000 정규화)
    """

    model_config = ConfigDict(extra="forbid")

    item_id: str = Field(description="드롭한 인벤토리 아이템 ID")
    target_object_id: str = Field(description="드롭 대상 핫스팟 오브젝트 ID")
    target_box_2d: Box2D = Field(description="드롭 대상의 바운딩 박스 (0~1000 정규화)")


class ClientInfo(BaseModel):
    """클라이언트 정보.

    Attributes:
        viewport_w: 뷰포트 너비 (픽셀)
        viewport_h: 뷰포트 높이 (픽셀)
        theme: 현재 테마 (dark/light)
    """

    model_config = ConfigDict(extra="forbid")

    viewport_w: Annotated[int, Field(gt=0, description="뷰포트 너비 (픽셀)")]
    viewport_h: Annotated[int, Field(gt=0, description="뷰포트 높이 (픽셀)")]
    theme: Theme = Field(default=Theme.DARK, description="현재 테마")


class EconomySnapshot(BaseModel):
    """재화 스냅샷 (클라이언트 → 서버).

    클라이언트가 보유한 현재 재화 상태입니다.
    서버는 이를 검증하고 비용 계산에 사용합니다.

    Attributes:
        signal: 현재 시그널 잔액
        memory_shard: 현재 기억 파편 잔액
    """

    model_config = ConfigDict(extra="forbid")

    signal: Annotated[int, Field(ge=0, description="현재 시그널 잔액 (0 이상)")]
    memory_shard: Annotated[int, Field(ge=0, description="현재 기억 파편 잔액 (0 이상)")]


class TurnInput(BaseModel):
    """턴 입력 (클라이언트 → 서버).

    사용자가 턴을 진행할 때 서버로 전송하는 입력 데이터입니다.

    Attributes:
        language: 요청 언어 (응답도 동일 언어로 고정)
        text: 사용자 자연어 입력
        action_id: 선택한 액션 카드 ID (선택)
        click: 오브젝트 클릭 정보 (선택)
        client: 클라이언트 환경 정보
        economy_snapshot: 현재 재화 상태

    Example:
        >>> input_data = TurnInput(
        ...     language=Language.KO,
        ...     text="문을 열어본다",
        ...     economy_snapshot=EconomySnapshot(signal=100, memory_shard=5),
        ...     client=ClientInfo(viewport_w=1920, viewport_h=1080),
        ... )
    """

    model_config = ConfigDict(extra="forbid")

    language: Language = Field(description="요청 언어 (응답도 동일 언어로 고정)")
    text: str = Field(default="", description="사용자 자연어 입력")
    action_id: str | None = Field(default=None, description="선택한 액션 카드 ID (선택)")
    click: ClickInput | None = Field(default=None, description="오브젝트 클릭 정보 (선택)")
    drop: DropInput | None = Field(default=None, description="아이템 드롭 정보 (선택, U-012)")
    client: ClientInfo = Field(description="클라이언트 환경 정보")
    economy_snapshot: EconomySnapshot = Field(description="현재 재화 상태")
    previous_image_url: str | None = Field(
        default=None,
        description="이전 턴 이미지 URL (U-068: 참조 이미지로 사용하여 연속성 유지)",
    )


# =============================================================================
# TurnOutput 관련 타입 - UI
# =============================================================================


class CostEstimate(BaseModel):
    """비용 추정치 (최소/최대 범위)."""

    model_config = ConfigDict(extra="forbid")

    min: CurrencyAmount = Field(description="최소 예상 비용")
    max: CurrencyAmount = Field(description="최대 예상 비용")


class ActionCard(BaseModel):
    """액션 카드 (Action Deck) - U-065 단순화.

    매 턴 AI가 추천하는 행동 카드입니다.
    Gemini Structured Outputs 제한 대응을 위해 핵심 필드만 유지합니다.

    U-065 단순화:
        - 제거된 필드: description, cost_estimate, hint, reward_hint, disabled_reason
        - risk, is_alternative는 유지 (게임 메카닉에 필수)
        - 제거된 정보는 narrative에서 자연어로 표현

    Attributes:
        id: 카드 고유 ID
        label: 카드 라벨 (표시용)
        cost: 예상 비용 (기본)
        risk: 위험도
        enabled: 실행 가능 여부 (서버 판단)
        is_alternative: 저비용 대안 카드 여부
    """

    model_config = ConfigDict(extra="forbid")

    id: str = Field(description="카드 고유 ID")
    label: str = Field(description="카드 라벨 (표시용)")
    cost: CurrencyAmount = Field(description="예상 비용 (기본)")
    risk: RiskLevel = Field(default=RiskLevel.LOW, description="위험도")
    enabled: bool = Field(default=True, description="실행 가능 여부 (서버 판단)")
    is_alternative: bool = Field(default=False, description="저비용 대안 카드 여부")


class SceneObject(BaseModel):
    """장면 오브젝트 (클릭 가능한 핫스팟).

    화면에서 클릭 가능한 오브젝트입니다.
    좌표는 0~1000 정규화 좌표계를 사용합니다 (RULE-009).

    Attributes:
        id: 오브젝트 고유 ID
        label: 오브젝트 라벨 (표시용)
        box_2d: 바운딩 박스 [ymin, xmin, ymax, xmax]
        interaction_hint: 상호작용 힌트 (선택)
    """

    model_config = ConfigDict(extra="forbid")

    id: str = Field(description="오브젝트 고유 ID")
    label: str = Field(description="오브젝트 라벨 (표시용)")
    box_2d: Box2D = Field(description="바운딩 박스")
    interaction_hint: str | None = Field(default=None, description="상호작용 힌트 (선택)")


class ActionDeck(BaseModel):
    """액션 덱 (Q1 결정: ui.action_deck.cards[] 구조) - U-065 단순화.

    매 턴 AI가 제시하는 추천 행동 카드 덱입니다.

    U-065 단순화:
        - max_length: 10 → 5 (Gemini 스키마 제한 대응, Q2 결정)

    Attributes:
        cards: 액션 카드 목록 (3~5장 권장)
    """

    model_config = ConfigDict(extra="forbid")

    cards: list[ActionCard] = Field(
        default=[],
        min_length=0,
        max_length=5,
        description="액션 카드 목록 (3~5장 권장)",
    )


class UIOutput(BaseModel):
    """UI 출력 데이터 - U-065 단순화.

    AI가 생성한 UI 요소들입니다.
    채팅 버블이 아닌 게임 UI로 표현됩니다 (RULE-002).

    U-065 단순화:
        - objects max_length: 5로 제한 (Q2 결정)

    Attributes:
        action_deck: 액션 카드 덱 (Q1 결정: Option A 채택)
        objects: 클릭 가능한 장면 오브젝트 목록 (최대 5개)
    """

    model_config = ConfigDict(extra="forbid")

    action_deck: ActionDeck = Field(default_factory=ActionDeck, description="액션 카드 덱")
    objects: list[SceneObject] = Field(
        default=[], max_length=5, description="클릭 가능한 장면 오브젝트 목록 (최대 5개)"
    )


# =============================================================================
# TurnOutput 관련 타입 - World
# =============================================================================


class MemoryPin(BaseModel):
    """중요 설정 고정 후보.

    사용자가 Memory Shard를 소비해 고정할 수 있는 중요 설정입니다.

    Attributes:
        id: 핀 고유 ID
        content: 고정할 내용
        cost: 고정에 필요한 비용
    """

    model_config = ConfigDict(extra="forbid")

    id: str = Field(description="핀 고유 ID")
    content: str = Field(description="고정할 내용")
    cost: CurrencyAmount = Field(description="고정에 필요한 비용")


class WorldRule(BaseModel):
    """세계 규칙 (Rule Board).

    현재 세계에 적용 중인 물리 법칙이나 메타 규칙입니다.

    Attributes:
        id: 규칙 고유 ID
        label: 규칙 이름
        description: 규칙 상세 설명 (선택)
    """

    model_config = ConfigDict(extra="forbid")

    id: str = Field(description="규칙 고유 ID")
    label: str = Field(description="규칙 이름")
    description: str | None = Field(default=None, description="규칙 상세 설명 (선택)")


class Quest(BaseModel):
    """퀘스트/목표 (Quest Panel) - U-078 목표 시스템 강화.

    플레이어가 달성해야 하는 현재 목표입니다.
    is_main=true인 퀘스트가 주 목표(Main Objective)이며,
    나머지는 서브 목표(Sub-objectives)로 표시됩니다.

    Attributes:
        id: 퀘스트 고유 ID
        label: 퀘스트 이름
        is_completed: 달성 여부
        description: 목표 상세 설명 (선택)
        is_main: 주 목표 여부 (true이면 Quest 패널 상단에 강조 표시)
        progress: 진행률 (0~100, 주 목표에서 사용)
        reward_signal: 달성 시 Signal 보상량 (0이면 보상 없음)
    """

    model_config = ConfigDict(extra="forbid")

    id: str = Field(description="퀘스트 고유 ID")
    label: str = Field(description="퀘스트 이름")
    is_completed: bool = Field(default=False, description="달성 여부")
    description: str | None = Field(default=None, description="목표 상세 설명 (선택)")
    is_main: bool = Field(default=False, description="주 목표 여부")
    progress: Annotated[int, Field(ge=0, le=100, description="진행률 (0~100)")] = 0
    reward_signal: Annotated[int, Field(ge=0, description="달성 시 Signal 보상량")] = 0


class InventoryItemData(BaseModel):
    """인벤토리 아이템 데이터 (U-075[Mvp]).

    TurnOutput에서 추가되는 아이템의 상세 정보입니다.
    아이콘 URL은 별도 API로 생성됩니다 (Q1: placeholder 먼저 표시).

    Attributes:
        id: 아이템 고유 ID
        label: 아이템 표시 이름 (현재 언어에 맞게)
        description: 아이템 설명 (아이콘 생성용)
        icon_url: 아이콘 URL (선택, 캐시된 경우)
        quantity: 아이템 수량
    """

    model_config = ConfigDict(extra="forbid")

    id: str = Field(description="아이템 고유 ID")
    label: str = Field(description="아이템 표시 이름 (현재 언어에 맞게)")
    description: str = Field(default="", description="아이템 설명 (아이콘 생성용)")
    icon_url: str | None = Field(default=None, description="아이콘 URL (선택, 캐시된 경우)")
    quantity: int = Field(default=1, ge=1, description="아이템 수량")


class WorldDelta(BaseModel):
    """세계 상태 변화 (Q2 결정: Option A - delta 중심) - U-065 단순화.

    이번 턴에서 변경된 세계 상태를 나타냅니다.
    snapshot은 SaveGame에만 저장하고, 매 턴은 delta만 전송합니다.

    U-065 단순화 (Q3 결정: Option A):
        - rules_changed, quests_updated → 배열 크기 제한 (최대 3개)
        - memory_pins → 배열 크기 제한 (최대 2개)
        - 복잡한 중첩 객체의 배열 크기 축소
        - 상세 정보는 narrative에서 자연어로 표현

    Attributes:
        rules_changed: 변경되거나 추가된 규칙 목록 (최대 3개)
        inventory_added: 추가된 인벤토리 아이템 (최대 5개)
        inventory_removed: 제거된 인벤토리 아이템 (최대 5개)
        quests_updated: 업데이트된 퀘스트(목표) 목록 (최대 3개)
        relationships_changed: 변경된 관계 (최대 3개)
        memory_pins: 중요 설정 고정 후보 (최대 2개)
    """

    model_config = ConfigDict(extra="forbid")

    rules_changed: list[WorldRule] = Field(
        default=[], max_length=3, description="변경된 규칙 목록 (최대 3개)"
    )
    inventory_added: list[InventoryItemData] = Field(
        default=[], max_length=5, description="추가된 인벤토리 아이템 (최대 5개)"
    )
    inventory_removed: list[str] = Field(
        default=[], max_length=5, description="제거된 인벤토리 아이템 (최대 5개)"
    )
    quests_updated: list[Quest] = Field(
        default=[], max_length=3, description="업데이트된 퀘스트/목표 목록 (최대 3개)"
    )
    relationships_changed: list[str] = Field(
        default=[], max_length=3, description="변경된 관계 (최대 3개)"
    )
    memory_pins: list[MemoryPin] = Field(
        default=[], max_length=2, description="중요 설정 고정 후보 (최대 2개)"
    )


# =============================================================================
# TurnOutput 관련 타입 - Render
# =============================================================================


class ImageJob(BaseModel):
    """이미지 생성 작업 - U-065 단순화.

    조건부 이미지 생성/편집 요청입니다.
    이미지 생성이 느릴 경우 텍스트 우선 출력 + Lazy Loading을 사용합니다.

    U-065 단순화:
        - reference_image_ids: 배열 크기 제한 (최대 2개)
        - 기타 필드는 유지 (이미지 파이프라인 필수)

    Attributes:
        should_generate: 이미지를 생성해야 하는지
        prompt: 이미지 생성 프롬프트
        model_label: 모델 선택 라벨 (FAST/QUALITY/CHEAP/REF)
        aspect_ratio: 가로세로 비율 (예: "16:9", "1:1")
        image_size: 이미지 크기 (예: "1024x1024")
        reference_image_ids: 참조 이미지 ID 목록 (최대 2개)
    """

    model_config = ConfigDict(extra="forbid")

    should_generate: bool = Field(description="이미지를 생성해야 하는지")
    prompt: str = Field(default="", description="이미지 생성 프롬프트")
    model_label: ModelLabel = Field(default=ModelLabel.FAST, description="모델 선택 라벨")
    aspect_ratio: str = Field(default="16:9", description="가로세로 비율")
    image_size: str = Field(default="1024x1024", description="이미지 크기")
    reference_image_ids: list[str] = Field(
        default=[], max_length=2, description="참조 이미지 ID 목록 (최대 2개)"
    )
    reference_image_url: str | None = Field(
        default=None,
        description="참조 이미지 URL (U-068: 이전 턴 이미지를 참조하여 연속성 유지)",
    )


class RenderOutput(BaseModel):
    """렌더링 출력 데이터.

    이미지 생성/편집 관련 정보입니다.
    image_job은 AI 모델이 생성하고, image_url/image_id는 후처리에서 채워집니다.

    Attributes:
        image_job: 이미지 생성 작업 (선택, AI 모델 생성)
        image_url: 생성된 이미지 URL (선택, 후처리에서 채움, U-053)
        image_id: 생성된 이미지 ID (선택, 후처리에서 채움, U-053)
        generation_time_ms: 이미지 생성 소요 시간 (밀리초, 선택, U-053)
    """

    model_config = ConfigDict(extra="forbid")

    image_job: ImageJob | None = Field(default=None, description="이미지 생성 작업 (선택)")
    image_url: str | None = Field(
        default=None, description="생성된 이미지 URL (후처리에서 채움, U-053)"
    )
    image_id: str | None = Field(
        default=None, description="생성된 이미지 ID (후처리에서 채움, U-053)"
    )
    generation_time_ms: int | None = Field(
        default=None, description="이미지 생성 소요 시간 (ms, U-053)"
    )


# =============================================================================
# TurnOutput 관련 타입 - Economy
# =============================================================================


class EconomyOutput(BaseModel):
    """경제 출력 데이터 (RULE-005).

    이번 턴의 비용과 잔액 정보입니다.
    잔액 음수는 절대 불가 (서버 Hard gate).

    Attributes:
        cost: 이번 턴에 소비된 비용
        balance_after: 소비 후 잔액
        credit: 사용 중인 크레딧 (빚, Signal 단위, U-079)
        low_balance_warning: 잔액 부족 경고 여부 (U-079)

    Important:
        - cost와 balance_after는 항상 포함되어야 합니다.
        - balance_after의 signal과 memory_shard는 0 이상이어야 합니다.
    """

    model_config = ConfigDict(extra="forbid")

    cost: CurrencyAmount = Field(description="이번 턴에 소비된 비용")
    balance_after: CurrencyAmount = Field(description="소비 후 잔액")
    credit: int = Field(default=0, description="사용 중인 크레딧 (빚, Signal 단위)")
    low_balance_warning: bool = Field(default=False, description="잔액 부족 경고 여부")


# =============================================================================
# TurnOutput 관련 타입 - Safety
# =============================================================================


class SafetyOutput(BaseModel):
    """안전 출력 데이터.

    안전 정책 관련 정보입니다.
    차단 시 명시적 메시지와 함께 안전한 대체 결과를 제공합니다.

    Attributes:
        blocked: 안전 정책에 의해 차단되었는지
        message: 차단 시 사용자에게 표시할 메시지 (선택)
    """

    model_config = ConfigDict(extra="forbid")

    blocked: bool = Field(default=False, description="안전 정책에 의해 차단되었는지")
    message: str | None = Field(default=None, description="차단 시 사용자에게 표시할 메시지 (선택)")


# =============================================================================
# TurnOutput 관련 타입 - Agent Console
# =============================================================================


class AgentConsole(BaseModel):
    """에이전트 콘솔 데이터 (RULE-008) - U-065 단순화.

    에이전트형 시스템임을 UI로 증명하기 위한 정보입니다.
    계획/실행/검증/복구의 흔적을 표시합니다.

    U-065 단순화:
        - badges: 배열 크기 제한 (최대 4개)

    U-069 추가:
        - model_label: 현재 사용 중인 텍스트 모델 라벨 (FAST/QUALITY)

    Attributes:
        current_phase: 현재 실행 단계
        badges: 검증 배지 목록 (최대 4개)
        repair_count: 자동 복구 시도 횟수
        model_label: 현재 사용 중인 텍스트 모델 라벨 (U-069)
    """

    model_config = ConfigDict(extra="forbid")

    current_phase: AgentPhase = Field(default=AgentPhase.COMMIT, description="현재 실행 단계")
    badges: list[ValidationBadge] = Field(
        default=[], max_length=4, description="검증 배지 목록 (최대 4개)"
    )
    repair_count: Annotated[int, Field(ge=0, description="자동 복구 시도 횟수")] = 0
    model_label: ModelLabel = Field(
        default=ModelLabel.FAST,
        description="현재 사용 중인 텍스트 모델 라벨 (U-069: FAST/QUALITY)",
    )


# =============================================================================
# TurnOutput (메인 응답 스키마)
# =============================================================================


class TurnOutput(BaseModel):
    """턴 출력 (서버 → 클라이언트).

    서버가 턴 처리 후 클라이언트로 반환하는 구조화된 응답입니다.
    Gemini Structured Outputs(JSON Schema)로 강제됩니다.

    Hard Gate 필드 (RULE-003/004/005):
        - economy: cost와 balance_after 필수, 잔액 음수 금지
        - safety: blocked 시 안전한 대체 결과 제공
        - language: 요청 언어와 동일하게 고정 (혼합 출력 금지)

    Attributes:
        language: 응답 언어 (요청과 동일)
        narrative: 내러티브 텍스트 (표시용)
        ui: UI 요소 (액션 덱, 오브젝트)
        world: 세계 상태 변화 (delta 중심)
        render: 렌더링 정보 (이미지 생성 작업)
        economy: 경제 정보 (비용, 잔액)
        safety: 안전 정책 정보
        agent_console: 에이전트 실행 정보 (단계, 배지, 복구 횟수)

    Example:
        >>> output = TurnOutput(
        ...     language=Language.KO,
        ...     narrative="문이 삐걱거리며 열립니다...",
        ...     economy=EconomyOutput(
        ...         cost=CurrencyAmount(signal=5, memory_shard=0),
        ...         balance_after=CurrencyAmount(signal=95, memory_shard=5),
        ...     ),
        ...     safety=SafetyOutput(blocked=False),
        ... )
        >>> schema = TurnOutput.model_json_schema()

    Schema Generation:
        >>> # Gemini Structured Outputs용 JSON Schema 생성
        >>> json_schema = TurnOutput.model_json_schema()
        >>> # response_json_schema 파라미터에 전달
        >>> config = {
        ...     "response_mime_type": "application/json",
        ...     "response_json_schema": json_schema,
        ... }
    """

    model_config = ConfigDict(extra="forbid")

    # 필수 필드 (Hard Gate)
    language: Language = Field(description="응답 언어 (요청과 동일)")
    narrative: str = Field(description="내러티브 텍스트 (표시용)")
    economy: EconomyOutput = Field(description="경제 정보 (비용, 잔액)")
    safety: SafetyOutput = Field(description="안전 정책 정보")

    # UI 관련 필드
    ui: UIOutput = Field(default_factory=UIOutput, description="UI 요소")

    # 세계 상태 필드
    world: WorldDelta = Field(default_factory=WorldDelta, description="세계 상태 변화 (delta)")

    # 렌더링 필드
    render: RenderOutput = Field(default_factory=RenderOutput, description="렌더링 정보")

    # 에이전트 콘솔 필드
    agent_console: AgentConsole = Field(
        default_factory=AgentConsole, description="에이전트 실행 정보"
    )
</file>

<file path="frontend/src/components/ActionDeck.tsx">
/**
 * Unknown World - Action Deck 컴포넌트 (U-009[Mvp]).
 *
 * PRD 요구사항:
 *   - Action Deck(3~6장 카드)을 Footer 영역에 상시 노출
 *   - 각 카드에 예상 비용(최소/최대), 위험도, 보상 힌트 표기 (RULE-005)
 *   - 카드 클릭 시 TurnInput으로 선택된 행동 전송 (RULE-008)
 *   - 잔액 부족 시 실행 불가 표시 + 저비용 대안 노출 (RULE-005)
 *
 * RULE-002 준수: 채팅 버블/메시지 버튼이 아닌 "게임 카드" UI
 *
 * @see vibe/prd.md 6.7 - Action Deck 요구사항
 * @see .cursor/rules/10-frontend-game-ui.mdc
 * @module components/ActionDeck
 */

import { useMemo, useCallback, useRef, useState } from 'react';
import { useTranslation } from 'react-i18next';
import type { ActionCard } from '../schemas/turn';
import { useActionDeckStore } from '../stores/actionDeckStore';
import { useWorldStore } from '../stores/worldStore';
import { useAgentStore } from '../stores/agentStore';
import { useEconomyStore } from '../stores/economyStore';

// =============================================================================
// 드래그 스크롤 훅 (U-049: 스크롤바 숨기고 드래그로 이동)
// U-063-fix: 클릭과 드래그를 구분하여 카드 클릭이 정상 동작하도록 수정
// =============================================================================

/** 드래그로 인식할 최소 이동 거리 (픽셀) */
const DRAG_THRESHOLD = 5;

function useDragScroll() {
  const containerRef = useRef<HTMLDivElement>(null);
  const [isDragging, setIsDragging] = useState(false);

  // ref로 관리하여 불필요한 리렌더링 방지
  const isMouseDownRef = useRef(false);
  const startXRef = useRef(0);
  const scrollLeftRef = useRef(0);
  const hasDraggedRef = useRef(false);

  const handleMouseDown = useCallback((e: React.MouseEvent) => {
    if (!containerRef.current) return;
    // mouseDown 시에는 isDragging을 설정하지 않음 (클릭 허용)
    isMouseDownRef.current = true;
    hasDraggedRef.current = false;
    startXRef.current = e.pageX - containerRef.current.offsetLeft;
    scrollLeftRef.current = containerRef.current.scrollLeft;
  }, []);

  const handleMouseMove = useCallback((e: React.MouseEvent) => {
    if (!isMouseDownRef.current || !containerRef.current) return;

    const x = e.pageX - containerRef.current.offsetLeft;
    const distance = Math.abs(x - startXRef.current);

    // 임계값을 넘어야 드래그로 인식
    if (distance > DRAG_THRESHOLD) {
      if (!hasDraggedRef.current) {
        hasDraggedRef.current = true;
        setIsDragging(true);
      }
      e.preventDefault();
      const walk = (x - startXRef.current) * 1.5; // 스크롤 속도 조절
      containerRef.current.scrollLeft = scrollLeftRef.current - walk;
    }
  }, []);

  const handleMouseUp = useCallback(() => {
    isMouseDownRef.current = false;
    // 드래그가 발생했으면 약간의 지연 후 isDragging 해제 (클릭 이벤트 차단 유지)
    if (hasDraggedRef.current) {
      setTimeout(() => {
        setIsDragging(false);
        hasDraggedRef.current = false;
      }, 0);
    }
  }, []);

  const handleMouseLeave = useCallback(() => {
    isMouseDownRef.current = false;
    setIsDragging(false);
    hasDraggedRef.current = false;
  }, []);

  return {
    containerRef,
    isDragging,
    handlers: {
      onMouseDown: handleMouseDown,
      onMouseMove: handleMouseMove,
      onMouseUp: handleMouseUp,
      onMouseLeave: handleMouseLeave,
    },
  };
}

// =============================================================================
// 상수 정의 (U-069: QUALITY 트리거 액션)
// =============================================================================

/**
 * QUALITY 모델 트리거 액션 ID 목록 (U-069).
 * 백엔드 TextModelTiering.QUALITY_TRIGGER_ACTION_IDS와 동기화 필요.
 * 이 목록에 포함된 액션은 QUALITY 배지와 2x 비용이 표시됩니다.
 */
const QUALITY_TRIGGER_ACTION_IDS: ReadonlySet<string> = new Set([
  'deep_investigate',
  '정밀조사',
  'analyze',
  'examine_closely',
  'investigate_detail',
  'scrutinize',
  'thorough_search',
  'use_magnifier',
  'use_magnifying_glass',
]);

/** QUALITY 모델 비용 배수 (U-069: 2x) */
const QUALITY_COST_MULTIPLIER = 2;

/**
 * VISION(정밀분석) 트리거 액션 ID 목록 (U-076).
 * 백엔드 TextModelTiering.VISION_TRIGGER_ACTION_IDS와 동기화 필요.
 * 이 목록에 포함된 액션은 VISION 배지와 1.5x 비용이 표시됩니다.
 */
const VISION_TRIGGER_ACTION_IDS: ReadonlySet<string> = new Set([
  'deep_analyze',
  '정밀분석',
  'analyze_scene',
  'examine_scene',
  'look_closely',
]);

/** VISION 비용 배수 (U-076 Q2: 1.5x) */
const VISION_COST_MULTIPLIER = 1.5;

/**
 * U-079: 재화 획득 액션 카드 ID 접두사.
 * 이 접두사로 시작하는 카드는 재화 획득 카드로 표시합니다.
 */
const EARN_ACTION_PREFIX = 'earn_';

// =============================================================================
// 타입 정의
// =============================================================================

export interface ActionDeckProps {
  /** 카드 클릭 콜백 */
  onCardClick?: (card: ActionCard) => void;
  /** 전체 비활성화 (스트리밍 중 등, 생략 시 agentStore.isStreaming 사용) */
  disabled?: boolean;
}

interface CardDisplayInfo extends ActionCard {
  /** 클라이언트 측 실행 가능 여부 (서버 enabled가 없을 때 폴백) */
  isAffordable: boolean;
  /** 최종 비활성화 여부 */
  isDisabled: boolean;
  /** 최종 비활성화 사유 */
  finalDisabledReason: string | null;
  /** U-069: QUALITY 모델 사용 여부 */
  isQualityAction: boolean;
  /** U-076: VISION(정밀분석) 사용 여부 */
  isVisionAction: boolean;
  /** U-079: 재화 획득 액션 여부 */
  isEarnAction: boolean;
  /** U-069/U-076: 배수 적용된 표시 비용 */
  displayCost: { signal: number; memory_shard: number };
}

// =============================================================================
// 기본 카드 생성 (i18n 기반)
// =============================================================================

/**
 * 기본 카드 생성 (i18n 기반) - U-065 단순화.
 * U-065: description, cost_estimate, hint, reward_hint, disabled_reason 필드 제거됨
 */
function useDefaultCards(): ActionCard[] {
  const { t } = useTranslation();

  return useMemo(
    () => [
      {
        id: 'default-explore',
        label: t('action.default.explore.label'),
        cost: { signal: 1, memory_shard: 0 },
        risk: 'low' as const,
        enabled: true,
        is_alternative: false,
      },
      {
        id: 'default-investigate',
        label: t('action.default.investigate.label'),
        cost: { signal: 2, memory_shard: 0 },
        risk: 'medium' as const,
        enabled: true,
        is_alternative: false,
      },
      {
        id: 'default-talk',
        label: t('action.default.talk.label'),
        cost: { signal: 1, memory_shard: 0 },
        risk: 'low' as const,
        enabled: true,
        is_alternative: false,
      },
    ],
    [t],
  );
}

// =============================================================================
// 카드 비용 표시 컴포넌트
// =============================================================================

interface CardCostDisplayProps {
  card: CardDisplayInfo;
}

/**
 * 비용 표시 컴포넌트 - U-065 단순화, U-069 QUALITY 배수 지원.
 * cost_estimate 필드 제거됨, displayCost(배수 적용) 사용
 */
function CardCostDisplay({ card }: CardCostDisplayProps) {
  const { t } = useTranslation();

  // U-069: displayCost 사용 (QUALITY 액션은 2x 배수 적용됨)
  const costDisplay = `${card.displayCost.signal}`;
  const shardCost = card.displayCost.memory_shard;

  return (
    <div className="action-card-cost" data-ui-importance="critical">
      {/* Signal 비용 */}
      <span className="cost-item">
        <span className="icon-wrapper" aria-label={t('economy.signal_cost')}>
          <img
            src="/ui/icons/signal-16.png"
            alt=""
            aria-hidden="true"
            className="icon-img"
            style={{ width: 14, height: 14 }}
            onError={(e) => e.currentTarget.classList.add('hidden')}
          />
          <span className="icon-fallback">{'\u26A1'}</span>
        </span>
        <span
          className={`cost-value ${card.isQualityAction ? 'quality-cost' : ''} ${card.isVisionAction ? 'vision-cost' : ''}`}
        >
          {costDisplay}
          {card.isQualityAction && <span className="cost-multiplier">x2</span>}
          {card.isVisionAction && <span className="cost-multiplier">x1.5</span>}
        </span>
      </span>

      {/* Shard 비용 (0보다 클 때만 표시) */}
      {shardCost > 0 && (
        <span className="cost-item">
          <span className="cost-separator">|</span>
          <span className="icon-wrapper" aria-label={t('economy.shard_cost')}>
            <img
              src="/ui/icons/shard-16.png"
              alt=""
              aria-hidden="true"
              className="icon-img"
              style={{ width: 14, height: 14 }}
              onError={(e) => e.currentTarget.classList.add('hidden')}
            />
            <span className="icon-fallback">{'\u{1F48E}'}</span>
          </span>
          <span
            className={`cost-value ${card.isQualityAction ? 'quality-cost' : ''} ${card.isVisionAction ? 'vision-cost' : ''}`}
          >
            {shardCost}
            {card.isQualityAction && <span className="cost-multiplier">x2</span>}
            {card.isVisionAction && <span className="cost-multiplier">x1.5</span>}
          </span>
        </span>
      )}

      {/* 위험도 */}
      <span className="cost-item">
        <span className="cost-separator">|</span>
        <span className="icon-wrapper" aria-label={t('economy.risk_level')}>
          <img
            src={`/ui/icons/risk-${card.risk}-16.png`}
            alt=""
            aria-hidden="true"
            className={`icon-img risk-${card.risk}`}
            style={{ width: 14, height: 14 }}
            onError={(e) => e.currentTarget.classList.add('hidden')}
          />
          <span className="icon-fallback">{'\u26A0'}</span>
        </span>
        <span className={`risk-label risk-${card.risk}`}>{t(`action.risk.${card.risk}`)}</span>
      </span>
    </div>
  );
}

// =============================================================================
// 단일 카드 컴포넌트
// =============================================================================

interface ActionCardItemProps {
  card: CardDisplayInfo;
  onClick: () => void;
  onHover: (card: CardDisplayInfo | null) => void;
  disabled: boolean;
}

/**
 * U-083: 뱃지 최대 표시 개수 (Q1: Option B - 최대 2개 + "외 N개")
 */
const MAX_VISIBLE_BADGES = 2;

/**
 * 카드에 표시할 뱃지 목록을 수집한다.
 * U-083: 각 뱃지를 통합 배열로 모아 최대 2개까지만 렌더링 + 초과분 "외 N개" 표시.
 */
interface BadgeInfo {
  key: string;
  className: string;
  label: string;
  tooltip: string;
}

function collectBadges(card: CardDisplayInfo, t: (key: string) => string): BadgeInfo[] {
  const badges: BadgeInfo[] = [];

  // U-076: VISION(정밀분석) 배지 (최우선)
  if (card.isVisionAction) {
    const label = `\uD83D\uDD0D ${t('action.vision_badge')}`;
    badges.push({
      key: 'vision',
      className: 'badge-vision',
      label,
      tooltip: t('action.vision_badge'),
    });
  }

  // U-069: QUALITY 모델 배지 (VISION이 아닐 때)
  if (!card.isVisionAction && card.isQualityAction) {
    badges.push({
      key: 'quality',
      className: 'badge-quality',
      label: '\u2605 QUALITY',
      tooltip: t('economy.model_label.QUALITY'),
    });
  }

  // U-079: 재화 획득 카드 배지
  if (card.isEarnAction) {
    const label = `\u26A1 ${t('action.earn_badge')}`;
    badges.push({
      key: 'earn',
      className: 'badge-earn',
      label,
      tooltip: t('action.earn_badge'),
    });
  }

  // U-083: 대안 카드 표시 (조건 완화: 다른 뱃지가 있어도 표시될 수 있도록 함)
  // 재화 부족 등으로 '대안'이면서 'QUALITY'일 수 있는 상황 지원
  if (card.is_alternative) {
    badges.push({
      key: 'alt',
      className: 'badge-alternative',
      label: t('action.alternative'),
      tooltip: t('action.alternative'),
    });
  }

  return badges;
}

/**
 * 단일 카드 컴포넌트 - U-065 단순화, U-069 QUALITY 배지 지원.
 * U-083: 뱃지를 비용 아래 별도 행으로 이동, 최대 2개 + "외 N개", ellipsis + 툴팁
 */
function ActionCardItem({ card, onClick, onHover, disabled }: ActionCardItemProps) {
  const { t } = useTranslation();

  const cardClasses = [
    'action-card',
    'has-chrome',
    card.isDisabled ? 'card-disabled' : '',
    card.is_alternative ? 'card-alternative' : '',
    card.isQualityAction ? 'card-quality' : '',
    card.isVisionAction ? 'card-vision' : '',
    card.isEarnAction ? 'card-earn' : '',
    `risk-border-${card.risk}`,
  ]
    .filter(Boolean)
    .join(' ');

  // U-083: 뱃지 수집 및 최대 2개 제한
  const allBadges = useMemo(() => collectBadges(card, t), [card, t]);
  const visibleBadges = allBadges.slice(0, MAX_VISIBLE_BADGES);
  const overflowCount = allBadges.length - MAX_VISIBLE_BADGES;

  return (
    <button
      type="button"
      className={cardClasses}
      onClick={onClick}
      onMouseEnter={() => onHover(card)}
      onMouseLeave={() => onHover(null)}
      onFocus={() => onHover(card)}
      onBlur={() => onHover(null)}
      disabled={disabled || card.isDisabled}
      aria-disabled={disabled || card.isDisabled}
      title={card.finalDisabledReason ?? undefined}
    >
      {/* 카드 타이틀 */}
      <div className="action-card-title">{card.label}</div>

      {/* 비용/위험도 정보 */}
      <CardCostDisplay card={card} />

      {/* U-083: 뱃지 컨테이너 - 비용 아래 별도 행 (Q3: Option C) */}
      {allBadges.length > 0 && (
        <div className="action-card-badges">
          {visibleBadges.map((badge) => (
            <span
              key={badge.key}
              className={`action-card-badge ${badge.className}`}
              title={badge.tooltip}
            >
              {badge.label}
            </span>
          ))}
          {/* Q1: Option B - 초과분 "외 N개" 표시 */}
          {overflowCount > 0 && (
            <span
              className="action-card-badge badge-overflow"
              title={allBadges
                .slice(MAX_VISIBLE_BADGES)
                .map((b) => b.label)
                .join(', ')}
            >
              +{overflowCount}
            </span>
          )}
        </div>
      )}

      {/* 비활성화 오버레이 */}
      {card.isDisabled && (
        <div className="card-disabled-overlay">
          <span className="disabled-reason">
            {card.finalDisabledReason ?? t('action.insufficient_balance')}
          </span>
        </div>
      )}
    </button>
  );
}

// =============================================================================
// 메인 Action Deck 컴포넌트
// =============================================================================

export function ActionDeck({ onCardClick, disabled: propsDisabled }: ActionDeckProps) {
  const { t } = useTranslation();
  const defaultCards = useDefaultCards();

  // Store 상태 (RU-003: 컴포넌트 내에서 직접 구독)
  const cards = useActionDeckStore((state) => state.cards);
  const currentBalance = useWorldStore((state) => state.economy);
  const isStreaming = useAgentStore((state) => state.isStreaming);
  const setCostEstimateFromCard = useEconomyStore((state) => state.setCostEstimateFromCard);
  const setCostEstimate = useEconomyStore((state) => state.setCostEstimate);

  // U-128: 핫스팟 존재 여부 (정밀분석 완료 판정 SSOT)
  // sceneObjects.length > 0이면 정밀분석이 수행된 장면 (U-090 정책)
  const hasHotspots = useWorldStore((state) => state.sceneObjects.length > 0);

  // U-049: 드래그 스크롤
  const { containerRef, isDragging, handlers: dragHandlers } = useDragScroll();

  const disabled = propsDisabled ?? isStreaming;

  // 카드 호버 핸들러 (U-014: 예상 비용 표시)
  // U-065: cost_estimate 제거됨
  // U-069: displayCost (배수 적용) 사용
  const handleCardHover = useCallback(
    (card: CardDisplayInfo | null) => {
      if (card) {
        setCostEstimateFromCard(card.displayCost, null, card.id, card.label);
      } else {
        setCostEstimate(null);
      }
    },
    [setCostEstimateFromCard, setCostEstimate],
  );

  // 카드가 없으면 기본 카드 사용
  const displayCards = cards.length > 0 ? cards : defaultCards;

  // 카드별 실행 가능 여부 계산 (Q1: Option A - 서버 우선, 클라이언트 폴백)
  // U-065: cost_estimate, disabled_reason 필드 제거됨
  // U-069: QUALITY 모델 트리거 및 비용 배수 계산 추가
  const processedCards: CardDisplayInfo[] = useMemo(() => {
    return displayCards.map((card) => {
      // U-079: 재화 획득 카드 감지 (earn_ 접두사)
      const isEarnAction = card.id.startsWith(EARN_ACTION_PREFIX);

      // U-083: 접두사를 제거한 순수 ID (VISION/QUALITY 체크용)
      const baseId = isEarnAction ? card.id.slice(EARN_ACTION_PREFIX.length) : card.id;

      // U-076: VISION(정밀분석) 트리거 체크 (QUALITY보다 우선)
      const isVisionAction =
        VISION_TRIGGER_ACTION_IDS.has(card.id) || VISION_TRIGGER_ACTION_IDS.has(baseId);

      // U-069: QUALITY 모델 트리거 체크 (VISION이면 QUALITY 아님)
      const isQualityAction =
        !isVisionAction &&
        (QUALITY_TRIGGER_ACTION_IDS.has(card.id) || QUALITY_TRIGGER_ACTION_IDS.has(baseId));

      // U-069/U-076: 배수 적용된 표시 비용 계산
      const displayCost = isVisionAction
        ? {
            signal: Math.ceil(card.cost.signal * VISION_COST_MULTIPLIER),
            memory_shard: Math.ceil(card.cost.memory_shard * VISION_COST_MULTIPLIER),
          }
        : isQualityAction
          ? {
              signal: card.cost.signal * QUALITY_COST_MULTIPLIER,
              memory_shard: card.cost.memory_shard * QUALITY_COST_MULTIPLIER,
            }
          : { ...card.cost };

      // 서버에서 enabled를 명시적으로 false로 보냈으면 그대로 사용
      const serverEnabled = card.enabled;

      // 클라이언트 측 잔액 체크 (서버가 판단하지 않았을 때 폴백)
      // U-069: QUALITY 액션은 배수 적용된 비용으로 체크
      const costToCheck = displayCost;
      const isAffordable =
        currentBalance.signal >= costToCheck.signal &&
        currentBalance.memory_shard >= costToCheck.memory_shard;

      // U-128: 정밀분석 완료 시 VISION 카드 비활성화
      // sceneObjects(핫스팟)가 1개 이상 존재하면 이미 분석된 장면 (U-090 정책)
      // 새 이미지 생성 시 핫스팟이 초기화되면 자동으로 다시 활성화됨
      const isVisionDisabledByHotspots = isVisionAction && hasHotspots;

      // 최종 비활성화 여부: 서버 판단 우선, 없으면 클라이언트 판단
      const isDisabled = !serverEnabled || !isAffordable || isVisionDisabledByHotspots;

      // 비활성화 사유 결정 (U-065: disabled_reason 제거됨)
      // U-128: 정밀분석 완료 사유를 가장 높은 우선순위로 표시
      let finalDisabledReason: string | null = null;
      if (isVisionDisabledByHotspots) {
        finalDisabledReason = t('action.vision_already_analyzed');
      } else if (!serverEnabled) {
        finalDisabledReason = t('action.server_disabled');
      } else if (!isAffordable) {
        finalDisabledReason = t('action.insufficient_balance');
      }

      return {
        ...card,
        isAffordable,
        isDisabled,
        finalDisabledReason,
        isQualityAction,
        isVisionAction,
        isEarnAction,
        displayCost,
      };
    });
  }, [displayCards, currentBalance, hasHotspots, t]);

  // 일반 카드와 대안 카드 분리 (대안 카드는 뒤에 배치)
  const sortedCards = useMemo(() => {
    const regular = processedCards.filter((c) => !c.is_alternative);
    const alternatives = processedCards.filter((c) => c.is_alternative);
    return [...regular, ...alternatives];
  }, [processedCards]);

  return (
    <div
      ref={containerRef}
      className={`action-deck ${isDragging ? 'is-dragging' : ''}`}
      role="group"
      aria-label={t('action.deck_label')}
      {...dragHandlers}
    >
      {sortedCards.map((card) => (
        <ActionCardItem
          key={card.id}
          card={card}
          onClick={() => onCardClick?.(card)}
          onHover={handleCardHover}
          disabled={disabled || isDragging} /* 드래그 중 클릭 방지 */
        />
      ))}

      {/* 모든 카드가 비활성화되었을 때 안내 */}
      {sortedCards.every((c) => c.isDisabled) && !disabled && (
        <div className="deck-empty-notice">{t('action.all_disabled_notice')}</div>
      )}
    </div>
  );
}

export default ActionDeck;
</file>

<file path="frontend/src/components/InventoryPanel.tsx">
/**
 * Unknown World - Inventory Panel 컴포넌트 (U-011[Mvp], U-088[Mvp]).
 *
 * dnd-kit 기반 드래그 가능한 인벤토리 아이템 UI를 Row(행) 형태로 제공합니다.
 *
 * 설계 원칙:
 *   - RULE-002: Inventory는 게임 UI로 상시 노출 (채팅 입력 대체 금지)
 *   - tech-stack: dnd-kit 기반 draggable 구현
 *   - U-012 연결: 드래그 데이터에 item_id 포함하여 드롭 타겟에 전달
 *
 * U-088[Mvp]: Row 형태 전환
 *   - Q1: Row 48px, 아이콘 32px (컴팩트)
 *   - Q2: 구분선 + 줄무늬 조합
 *   - Q3: Hover 툴팁만 (U-056 유지)
 *   - Q4: (U-117에서 변경) Row 전체 드래그 가능, 고스트는 아이콘만
 *
 * U-117[Mvp]: 드래그 영역 Row 전체로 확장
 *   - Q1 Option A: distance 5px (마우스 이동 후 시작)
 *   - Row 전체에 listeners/attributes 적용
 *   - 고스트(DragOverlay)는 아이콘만 (U-088에서 이미 구현)
 *   - 드래그 중 Row opacity:0.4 + dashed border
 *
 * U-074[Mvp]: 아이템 인터랙션 안내 UX
 *   - Q1 Option B: 첫 N번만 hover 힌트 표시 (학습 후 사라짐)
 *   - hover 시 "드래그하여 사용" 힌트 표시
 *
 * U-075[Mvp]: 아이템 아이콘 동적 생성
 *   - Q1: Option B (placeholder 먼저 표시 후 백그라운드 생성)
 *   - Q2: Option A (64x64 픽셀)
 *   - Q3: Option A (픽셀 아트 스타일)
 *
 * @module components/InventoryPanel
 */

import { useMemo, useState, useEffect, useRef, useCallback } from 'react';
import { useDraggable, DragOverlay, type Modifier } from '@dnd-kit/core';
import { CSS } from '@dnd-kit/utilities';
import { useTranslation } from 'react-i18next';
import {
  useInventoryStore,
  type InventoryItem,
  selectItems,
  selectDraggingItem,
  selectConsumingItemIds,
  requestItemIcon,
  pollIconStatus,
} from '../stores/inventoryStore';
import { useOnboardingStore, selectShouldShowItemHint } from '../stores/onboardingStore';
import { useWorldStore } from '../stores/worldStore';

import { ITEM_SELL_PRICE_SIGNAL } from '../save/constants';
import { InteractionHint } from './InteractionHint';
import { DND_TYPE, type InventoryDragData } from '../dnd/types';

// =============================================================================
// U-117: DragOverlay 커서 스냅 modifier
// Row 전체가 드래그 영역이므로, 아이콘 고스트(40x40)의 중심이
// 항상 마우스 커서에 위치하도록 transform을 보정합니다.
// =============================================================================

/** 고스트 아이콘 크기의 절반 (40px / 2) */
const OVERLAY_HALF_SIZE = 20;

/**
 * DragOverlay의 아이콘 중심을 커서에 스냅하는 modifier.
 *
 * 기본 동작: DragOverlay는 드래그 시작 시 grab 지점 기준으로 오프셋을 유지
 * → Row 우측에서 grab하면 아이콘이 커서에서 멀리 떨어짐
 *
 * 이 modifier: grab 오프셋을 무시하고 아이콘 중심(20,20)이 커서에 오도록 보정
 */
const snapOverlayCenterToCursor: Modifier = ({ transform, activeNodeRect, activatorEvent }) => {
  if (!activeNodeRect || !activatorEvent) return transform;

  const event = activatorEvent as PointerEvent;

  // grab 시점의 커서 위치와 Row 좌상단 사이의 오프셋
  const grabOffsetX = event.clientX - activeNodeRect.left;
  const grabOffsetY = event.clientY - activeNodeRect.top;

  return {
    ...transform,
    x: transform.x + grabOffsetX - OVERLAY_HALF_SIZE,
    y: transform.y + grabOffsetY - OVERLAY_HALF_SIZE,
  };
};

// =============================================================================
// 드래그 가능한 아이템 컴포넌트
// =============================================================================

interface DraggableItemProps {
  item: InventoryItem;
  disabled?: boolean;
  /** U-096: 소비 중(fade-out 진행 중) 여부 */
  isConsuming?: boolean;
  /** U-088: 선택 여부 */
  isSelected?: boolean;
  /** U-088: 선택 핸들러 */
  onSelect?: (itemId: string) => void;
  /** U-129: 판매 버튼 항상 표시 (드래그/소비 중 제외) */
  showSellButton?: boolean;
  /** U-129: 인라인 컨펌 중인 아이템 ID */
  confirmingSellId?: string | null;
  /** U-129: 판매 버튼 클릭 핸들러 (인라인 컨펌 처리) */
  onSellClick?: (itemId: string, itemName: string) => void;
}

/**
 * 드래그 가능한 인벤토리 아이템.
 * dnd-kit의 useDraggable 훅을 사용합니다.
 * U-056: 잘린 아이템 이름에 대한 툴팁 지원
 * U-074: 첫 N번만 hover 힌트 표시
 */
function DraggableItem({
  item,
  disabled = false,
  isConsuming = false,
  isSelected = false,
  onSelect,
  showSellButton = false,
  confirmingSellId = null,
  onSellClick,
}: DraggableItemProps) {
  const { t } = useTranslation();
  const [isHovered, setIsHovered] = useState(false);

  // U-074: 아이템 힌트 상태 (첫 N번만 표시)
  const shouldShowHint = useOnboardingStore(selectShouldShowItemHint);
  const incrementItemHint = useOnboardingStore((state) => state.incrementItemHint);

  // U-074: hover 시작 시 힌트 카운트 증가
  useEffect(() => {
    if (isHovered && !disabled) {
      incrementItemHint();
    }
  }, [isHovered, disabled, incrementItemHint]);

  // dnd-kit 드래그 설정 (RU-003-Q1: 상수/타입 기반)
  const dragData: InventoryDragData = {
    type: DND_TYPE.INVENTORY_ITEM,
    item_id: item.id,
    item,
  };
  const { attributes, listeners, setNodeRef, transform, isDragging } = useDraggable({
    id: item.id,
    data: dragData,
    disabled,
  });

  // 변환 스타일 계산
  // 드래그 중일 때는 원본 아이템이 제자리에 있도록 transform 적용하지 않음
  // DragOverlay가 별도로 렌더링되므로 원본은 위치 고정
  const style = useMemo(
    () => ({
      transform: isDragging ? undefined : CSS.Translate.toString(transform),
      opacity: isDragging ? 0.3 : 1,
    }),
    [transform, isDragging],
  );

  // U-075: 아이콘 렌더링 (이모지 또는 이미지, 로딩 상태 포함)
  const renderIcon = () => {
    const isLoading = item.iconStatus === 'generating' || item.iconStatus === 'pending';

    if (item.icon) {
      // URL 형태면 이미지
      if (item.icon.startsWith('http') || item.icon.startsWith('/')) {
        return (
          <div className="inventory-item-icon-wrapper">
            <img
              src={item.icon}
              alt={item.name}
              className={`inventory-item-icon-img ${isLoading ? 'loading' : ''}`}
              onError={(e) => {
                e.currentTarget.style.display = 'none';
              }}
            />
            {isLoading && <div className="inventory-item-icon-loading" />}
          </div>
        );
      }
      // 이모지 + 로딩 상태 (U-075: 이모지여도 생성 중이면 스피너 표시)
      return (
        <div className="inventory-item-icon-wrapper">
          <span className="inventory-item-icon-emoji">{item.icon}</span>
          {isLoading && <div className="inventory-item-icon-loading" />}
        </div>
      );
    }

    // 기본 아이콘 (📦) + 로딩 상태
    return (
      <div className="inventory-item-icon-wrapper">
        <span className="inventory-item-icon-emoji">📦</span>
        {isLoading && <div className="inventory-item-icon-loading" />}
      </div>
    );
  };

  return (
    <div
      ref={setNodeRef}
      style={style}
      className={`inventory-item ${isSelected ? 'selected' : ''} ${isDragging ? 'dragging' : ''} ${disabled ? 'disabled' : ''} ${isConsuming ? 'item-consumed' : ''}`}
      onMouseEnter={() => setIsHovered(true)}
      onMouseLeave={() => setIsHovered(false)}
      onClick={() => !disabled && onSelect?.(item.id)}
      aria-label={t('inventory.item_label', { name: item.name, quantity: item.quantity })}
      aria-selected={isSelected}
      // U-056: 네이티브 툴팁 (단수는 이름만, 복수는 "이름 x 갯수")
      title={item.quantity > 1 ? `${item.name} x ${item.quantity}` : item.name}
      // U-117: Row 전체를 드래그 핸들로 확장 (Q1: Option A, distance 5px)
      {...attributes}
      {...listeners}
    >
      {/* U-117: 아이콘은 표시 전용 (드래그 핸들은 Row 전체) */}
      <div className="inventory-item-icon">{renderIcon()}</div>
      <div className="inventory-item-info">
        <span className="inventory-item-name">{item.name}</span>
        {item.quantity > 1 && <span className="inventory-item-quantity">x{item.quantity}</span>}
      </div>

      {/* U-129: 판매 버튼 (항상 노출, 인라인 컨펌) */}
      {showSellButton &&
        !disabled &&
        !isDragging &&
        !isConsuming &&
        (() => {
          const isConfirming = confirmingSellId === item.id;
          return (
            <button
              type="button"
              className={`inventory-sell-btn ${isConfirming ? 'confirming' : ''}`}
              onClick={(e) => {
                e.stopPropagation();
                onSellClick?.(item.id, item.name);
              }}
              title={
                isConfirming
                  ? t('inventory.sell_confirm')
                  : t('inventory.sell_tooltip', { price: ITEM_SELL_PRICE_SIGNAL })
              }
              aria-label={
                isConfirming
                  ? t('inventory.sell_confirm')
                  : t('inventory.sell_aria', { item: item.name, price: ITEM_SELL_PRICE_SIGNAL })
              }
            >
              {isConfirming ? (
                <span className="sell-confirm-text">{t('inventory.sell_confirm')}</span>
              ) : (
                <>
                  <span className="sell-icon">{'\u26A1'}</span>
                  <span className="sell-price">+{ITEM_SELL_PRICE_SIGNAL}</span>
                </>
              )}
            </button>
          );
        })()}

      {/* U-074: 첫 N번만 표시되는 드래그 힌트 */}
      {isHovered && !disabled && !isDragging && shouldShowHint && !showSellButton && (
        <InteractionHint
          text={t('interaction.item_drag')}
          icon="drag"
          position="top"
          className="interaction-hint--inventory"
        />
      )}
    </div>
  );
}

// =============================================================================
// 드래그 오버레이 (드래그 중 표시되는 아이템)
// =============================================================================

interface ItemOverlayProps {
  item: InventoryItem;
}

/**
 * 드래그 오버레이 — 아이콘만 표시 (U-088 Q4: Option B).
 * 드래그 중일 때 커서를 따라다니는 아이콘입니다.
 */
function ItemOverlay({ item }: ItemOverlayProps) {
  const renderIcon = () => {
    if (item.icon) {
      if (item.icon.startsWith('http') || item.icon.startsWith('/')) {
        return <img src={item.icon} alt={item.name} className="inventory-item-icon-img" />;
      }
      return <span className="inventory-item-icon-emoji">{item.icon}</span>;
    }
    return <span className="inventory-item-icon-emoji">📦</span>;
  };

  return (
    <div className="inventory-overlay-icon" title={item.name}>
      {renderIcon()}
    </div>
  );
}

// =============================================================================
// 메인 Inventory Panel 컴포넌트
// =============================================================================

interface InventoryPanelProps {
  /** 상호작용 비활성화 (스트리밍 중 등) */
  disabled?: boolean;
}

/**
 * Inventory Panel 컴포넌트.
 *
 * U-088: 인벤토리 아이템을 Row(행) 형태로 표시합니다.
 * 아이콘 영역만 드래그 핸들(Q4: Option B), DndContext는 App 최상단(Q1: Option A).
 *
 * U-075: 아이템 추가 시 아이콘 동적 생성 요청
 *
 * @example
 * ```tsx
 * <InventoryPanel disabled={isStreaming} />
 * ```
 */
export function InventoryPanel({ disabled = false }: InventoryPanelProps) {
  const { t, i18n } = useTranslation();

  // Store 상태
  const items = useInventoryStore(selectItems);
  const draggingItem = useInventoryStore(selectDraggingItem);
  const selectedItemId = useInventoryStore((state) => state.selectedItemId);
  const consumingItemIds = useInventoryStore(selectConsumingItemIds);
  const selectItem = useInventoryStore((state) => state.selectItem);
  const updateItemIcon = useInventoryStore((state) => state.updateItemIcon);
  const setItemIconStatus = useInventoryStore((state) => state.setItemIconStatus);

  // U-129: 판매 버튼 항상 표시 (isBalanceLow 조건 제거)
  const sellItem = useWorldStore((state) => state.sellItem);

  // U-129: 인라인 컨펌 상태 (2단계 클릭으로 실수 판매 방지)
  // ref + state 동기 방식: ref는 핸들러에서 즉시 최신 값을 읽고,
  // state는 UI 리렌더 트리거용
  const [confirmingSellId, setConfirmingSellId] = useState<string | null>(null);
  const confirmingSellIdRef = useRef<string | null>(null);
  const confirmTimerRef = useRef<ReturnType<typeof setTimeout> | null>(null);

  /** 동기적으로 ref + state 모두 업데이트 */
  const updateConfirmingSellId = useCallback((id: string | null) => {
    confirmingSellIdRef.current = id;
    setConfirmingSellId(id);
  }, []);

  /** U-129: 컨펌 타이머 초기화 */
  const clearConfirmTimer = useCallback(() => {
    if (confirmTimerRef.current) {
      clearTimeout(confirmTimerRef.current);
      confirmTimerRef.current = null;
    }
  }, []);

  /**
   * U-129: 판매 버튼 클릭 핸들러 (인라인 컨펌).
   * - 1차 클릭: "확인?" 상태로 전환, 2초 타이머 시작
   * - 2차 클릭 (2초 이내): 판매 실행
   * - 2초 경과: 원래 상태로 복귀
   *
   * ref를 사용하여 stale closure 문제를 방지합니다.
   */
  const handleSellClick = useCallback(
    (itemId: string, itemName: string) => {
      if (confirmingSellIdRef.current === itemId) {
        // 2차 클릭: 판매 실행
        clearConfirmTimer();
        updateConfirmingSellId(null);
        sellItem(itemId, itemName);
      } else {
        // 1차 클릭: 컨펌 상태 진입
        clearConfirmTimer();
        updateConfirmingSellId(itemId);
        confirmTimerRef.current = setTimeout(() => {
          updateConfirmingSellId(null);
        }, 2000);
      }
    },
    [sellItem, clearConfirmTimer, updateConfirmingSellId],
  );

  // 컴포넌트 언마운트 시 타이머 정리
  useEffect(() => {
    return () => clearConfirmTimer();
  }, [clearConfirmTimer]);

  // U-075: 아이콘 생성 요청 추적 (중복 요청 방지)
  const iconRequestedRef = useRef<Set<string>>(new Set());

  // U-075: 아이템 추가 시 아이콘 생성 요청
  useEffect(() => {
    const requestIconsForNewItems = async () => {
      for (const item of items) {
        // 이미 요청한 경우 스킵
        if (iconRequestedRef.current.has(item.id)) continue;

        // 이미 완료된 아이콘이 있는 경우 스킵
        if (item.iconStatus === 'completed' || item.iconStatus === 'cached') continue;

        // URL 형태의 실제 아이콘이 있으면 스킵 (이모지는 무시)
        const hasRealIcon =
          item.icon &&
          (item.icon.startsWith('http') || item.icon.startsWith('/')) &&
          !item.icon.includes('placeholder');
        if (hasRealIcon) continue;

        // iconStatus가 없거나 pending/generating/failed인 경우 아이콘 생성 시도
        // (failed인 경우도 재시도 허용)

        // 요청 추적
        iconRequestedRef.current.add(item.id);

        // 아이콘 생성 요청 (비동기)
        const description = item.description || item.name;
        const language = i18n.language === 'ko' ? 'ko-KR' : 'en-US';

        setItemIconStatus(item.id, 'generating');

        try {
          const result = await requestItemIcon(item.id, description, language);

          if (result.isPlaceholder) {
            // Placeholder 반환됨 - 폴링 시작
            setItemIconStatus(item.id, 'generating');

            // 백그라운드에서 폴링 (최대 30초)
            let attempts = 0;
            const maxAttempts = 15;
            const pollInterval = 2000; // 2초

            const poll = async () => {
              if (attempts >= maxAttempts) {
                setItemIconStatus(item.id, 'failed');
                return;
              }
              attempts++;

              const status = await pollIconStatus(item.id);
              if (status === 'completed' || status === 'cached') {
                // 완료됨 - 아이콘 URL 다시 요청
                const finalResult = await requestItemIcon(item.id, description, language);
                if (!finalResult.isPlaceholder && finalResult.iconUrl) {
                  updateItemIcon(item.id, finalResult.iconUrl, 'completed');
                }
              } else if (status === 'failed') {
                setItemIconStatus(item.id, 'failed');
              } else {
                // 계속 생성 중 - 다시 폴링
                setTimeout(poll, pollInterval);
              }
            };

            setTimeout(poll, pollInterval);
          } else if (result.iconUrl) {
            // 즉시 완료 (캐시)
            updateItemIcon(item.id, result.iconUrl, result.status);
          }
        } catch (error) {
          console.warn(`[InventoryPanel] 아이콘 생성 실패: ${item.id}`, error);
          setItemIconStatus(item.id, 'failed');
        }
      }
    };

    requestIconsForNewItems();
  }, [items, i18n.language, updateItemIcon, setItemIconStatus]);

  // 아이템 선택 핸들러 (토글 기능 포함)
  const handleSelect = (itemId: string) => {
    selectItem(itemId === selectedItemId ? null : itemId);
  };

  // 빈 인벤토리 (U-077: Q3 Option B - 아이템 획득 힌트 포함)
  if (items.length === 0) {
    return (
      <div className="inventory-panel-content">
        <div className="inventory-empty">
          <span className="inventory-empty-icon">📦</span>
          <span className="inventory-empty-text">{t('inventory.empty')}</span>
          <span className="inventory-empty-hint">{t('inventory.empty_hint')}</span>
        </div>
      </div>
    );
  }

  return (
    <div className="inventory-panel-content" data-ui-importance="critical">
      <div
        className="inventory-list"
        role="listbox"
        aria-label={t('inventory.list_label')}
        aria-multiselectable={false}
      >
        {items.map((item) => (
          <DraggableItem
            key={item.id}
            item={item}
            disabled={disabled || consumingItemIds.includes(item.id)}
            isConsuming={consumingItemIds.includes(item.id)}
            isSelected={selectedItemId === item.id}
            onSelect={handleSelect}
            showSellButton
            confirmingSellId={confirmingSellId}
            onSellClick={handleSellClick}
          />
        ))}
      </div>

      {/* U-117: 드래그 오버레이 (아이콘 중심을 커서에 스냅) */}
      <DragOverlay dropAnimation={null} modifiers={[snapOverlayCenterToCursor]}>
        {draggingItem ? <ItemOverlay item={draggingItem} /> : null}
      </DragOverlay>
    </div>
  );
}

export default InventoryPanel;
</file>

<file path="frontend/src/stores/worldStore.test.ts">
import { describe, it, expect, beforeEach, vi } from 'vitest';
import { useWorldStore, selectMainObjective, selectSubObjectives } from './worldStore';
import type { TurnOutput } from '../schemas/turn';

// i18next 모킹 (U-072)
vi.mock('../i18n', () => ({
  default: {
    t: (key: string) => key,
  },
}));

// 하위 스토어 모킹 (순환 import 방지 로직 대응)
vi.mock('./actionDeckStore', () => ({
  useActionDeckStore: {
    getState: () => ({
      setCards: vi.fn(),
    }),
  },
}));

vi.mock('./inventoryStore', () => ({
  useInventoryStore: {
    getState: () => ({
      addItems: vi.fn(),
      removeItems: vi.fn(),
    }),
  },
  parseInventoryAdded: (items: unknown) => items,
}));

describe('worldStore (U-013: Quest + Rules)', () => {
  beforeEach(() => {
    useWorldStore.getState().reset();
  });

  it('초기 상태가 올바라야 한다', () => {
    const state = useWorldStore.getState();
    expect(state.quests).toEqual([]);
    expect(state.activeRules).toEqual([]);
    expect(state.mutationTimeline).toEqual([]);
  });

  it('applyTurnOutput을 통해 새 퀘스트가 추가되어야 한다', () => {
    const mockOutput: Partial<TurnOutput> = {
      narrative: '새 퀘스트 발생',
      economy: {
        cost: { signal: 0, memory_shard: 0 },
        balance_after: { signal: 100, memory_shard: 5 },
        credit: 0,
        low_balance_warning: false,
      },
      ui: {
        scene: { image_url: '', alt_text: '' },
        action_deck: { cards: [] },
        objects: [],
      },
      world: {
        inventory_added: [],
        inventory_removed: [],
        quests_updated: [
          {
            id: 'q1',
            label: '첫 번째 임무',
            is_completed: false,
            description: null,
            is_main: false,
            progress: 0,
            reward_signal: 0,
          },
        ],
        rules_changed: [],
        relationships_changed: [],
        memory_pins: [],
      },
      agent_console: {
        current_phase: 'commit',
        badges: ['schema_ok'],
        repair_count: 0,
        model_label: 'FAST',
      },
      safety: { blocked: false, message: null },
    };

    useWorldStore.getState().applyTurnOutput(mockOutput as TurnOutput);

    const state = useWorldStore.getState();
    expect(state.quests).toHaveLength(1);
    expect(state.quests[0].id).toBe('q1');
    expect(state.quests[0].is_completed).toBe(false);
  });

  it('기존 퀘스트가 업데이트(완료)되어야 한다', () => {
    // 1. 초기 퀘스트 추가
    const initialState: Partial<TurnOutput> = {
      narrative: '초기화',
      economy: {
        cost: { signal: 0, memory_shard: 0 },
        balance_after: { signal: 100, memory_shard: 5 },
        credit: 0,
        low_balance_warning: false,
      },
      ui: {
        scene: { image_url: '', alt_text: '' },
        action_deck: { cards: [] },
        objects: [],
      },
      world: {
        inventory_added: [],
        inventory_removed: [],
        quests_updated: [
          {
            id: 'q1',
            label: '임무',
            is_completed: false,
            description: null,
            is_main: false,
            progress: 0,
            reward_signal: 0,
          },
        ],
        rules_changed: [],
        relationships_changed: [],
        memory_pins: [],
      },
      agent_console: {
        current_phase: 'commit',
        badges: ['schema_ok'],
        repair_count: 0,
        model_label: 'FAST',
      },
      safety: { blocked: false, message: null },
    };
    useWorldStore.getState().applyTurnOutput(initialState as TurnOutput);

    // 2. 퀘스트 완료 업데이트
    const updateOutput: Partial<TurnOutput> = {
      narrative: '임무 완료!',
      economy: {
        cost: { signal: 0, memory_shard: 0 },
        balance_after: { signal: 100, memory_shard: 5 },
        credit: 0,
        low_balance_warning: false,
      },
      ui: {
        scene: { image_url: '', alt_text: '' },
        action_deck: { cards: [] },
        objects: [],
      },
      world: {
        inventory_added: [],
        inventory_removed: [],
        quests_updated: [
          {
            id: 'q1',
            label: '임무',
            is_completed: true,
            description: null,
            is_main: false,
            progress: 100,
            reward_signal: 0,
          },
        ],
        rules_changed: [],
        relationships_changed: [],
        memory_pins: [],
      },
      agent_console: {
        current_phase: 'commit',
        badges: ['schema_ok'],
        repair_count: 0,
        model_label: 'FAST',
      },
      safety: { blocked: false, message: null },
    };
    useWorldStore.getState().applyTurnOutput(updateOutput as TurnOutput);

    const state = useWorldStore.getState();
    expect(state.quests).toHaveLength(1);
    expect(state.quests[0].is_completed).toBe(true);
  });

  it('새 규칙이 추가되고 타임라인에 기록되어야 한다', () => {
    const mockOutput: Partial<TurnOutput> = {
      narrative: '새 규칙 적용',
      economy: {
        cost: { signal: 0, memory_shard: 0 },
        balance_after: { signal: 100, memory_shard: 5 },
        credit: 0,
        low_balance_warning: false,
      },
      ui: {
        scene: { image_url: '', alt_text: '' },
        action_deck: { cards: [] },
        objects: [],
      },
      world: {
        inventory_added: [],
        inventory_removed: [],
        quests_updated: [],
        rules_changed: [
          {
            id: 'rule1',
            label: '중력 강화',
            description: '점프 높이가 절반으로 감소합니다.',
          },
        ],
        relationships_changed: [],
        memory_pins: [],
      },
      agent_console: {
        current_phase: 'commit',
        badges: ['schema_ok'],
        repair_count: 0,
        model_label: 'FAST',
      },
      safety: { blocked: false, message: null },
    };

    useWorldStore.getState().applyTurnOutput(mockOutput as TurnOutput);

    const state = useWorldStore.getState();
    expect(state.activeRules).toHaveLength(1);
    expect(state.activeRules[0].id).toBe('rule1');

    expect(state.mutationTimeline).toHaveLength(1);
    expect(state.mutationTimeline[0].ruleId).toBe('rule1');
    expect(state.mutationTimeline[0].type).toBe('added');
  });

  it('기존 규칙 수정 시 타임라인에 기록되어야 한다', () => {
    // 1. 초기 규칙 추가
    const initialState: Partial<TurnOutput> = {
      narrative: '초기화',
      economy: {
        cost: { signal: 0, memory_shard: 0 },
        balance_after: { signal: 100, memory_shard: 5 },
        credit: 0,
        low_balance_warning: false,
      },
      ui: {
        scene: { image_url: '', alt_text: '' },
        action_deck: { cards: [] },
        objects: [],
      },
      world: {
        inventory_added: [],
        inventory_removed: [],
        quests_updated: [],
        rules_changed: [{ id: 'rule1', label: '규칙', description: '기존' }],
        relationships_changed: [],
        memory_pins: [],
      },
      agent_console: {
        current_phase: 'commit',
        badges: ['schema_ok'],
        repair_count: 0,
        model_label: 'FAST',
      },
      safety: { blocked: false, message: null },
    };
    useWorldStore.getState().applyTurnOutput(initialState as TurnOutput);

    // 2. 규칙 수정
    const updateOutput: Partial<TurnOutput> = {
      narrative: '규칙 수정',
      economy: {
        cost: { signal: 0, memory_shard: 0 },
        balance_after: { signal: 100, memory_shard: 5 },
        credit: 0,
        low_balance_warning: false,
      },
      ui: {
        scene: { image_url: '', alt_text: '' },
        action_deck: { cards: [] },
        objects: [],
      },
      world: {
        inventory_added: [],
        inventory_removed: [],
        quests_updated: [],
        rules_changed: [{ id: 'rule1', label: '규칙', description: '수정됨' }],
        relationships_changed: [],
        memory_pins: [],
      },
      agent_console: {
        current_phase: 'commit',
        badges: ['schema_ok'],
        repair_count: 0,
        model_label: 'FAST',
      },
      safety: { blocked: false, message: null },
    };
    useWorldStore.getState().applyTurnOutput(updateOutput as TurnOutput);

    const state = useWorldStore.getState();
    expect(state.activeRules[0].description).toBe('수정됨');
    expect(state.mutationTimeline).toHaveLength(2);
    expect(state.mutationTimeline[0].type).toBe('modified');
  });

  describe('Initialization and Reset (U-015[Mvp])', () => {
    it('reset 액션은 모든 상태를 초기값으로 되돌려야 한다', () => {
      // 1. 임의의 상태 설정
      useWorldStore.setState({
        turnCount: 10,
        economy: { signal: 50, memory_shard: 0, credit: 0 },
        sceneState: {
          status: 'scene',
          imageUrl: 'test.png',
          processingPhase: 'rendering',
        },
        quests: [
          {
            id: 'q1',
            label: '퀘스트',
            is_completed: false,
            description: null,
            is_main: false,
            progress: 0,
            reward_signal: 0,
          },
        ],
      });

      // 2. 리셋 실행
      useWorldStore.getState().reset();

      // 3. 검증
      const state = useWorldStore.getState();
      expect(state.turnCount).toBe(0);
      expect(state.economy.signal).toBe(100);
      expect(state.sceneState.status).toBe('default');
      expect(state.sceneState.imageUrl).toBeUndefined();
      expect(state.sceneState.processingPhase).toBe('idle');
      expect(state.quests).toEqual([]);
      expect(state.narrativeEntries).toEqual([]);
    });

    it('initialize 액션은 웰컴 메시지와 함께 초기 상태를 설정해야 한다', () => {
      const welcomeMsg = '환영합니다!';
      useWorldStore.getState().initialize(welcomeMsg);

      const state = useWorldStore.getState();
      expect(state.turnCount).toBe(0);
      expect(state.narrativeEntries).toHaveLength(1);
      expect(state.narrativeEntries[0].text).toBe(welcomeMsg);
      expect(state.narrativeEntries[0].turn).toBe(0);
    });
  });

  describe('Action Log (U-070[Mvp])', () => {
    it('appendActionLog 액션은 action_log 타입의 엔트리를 추가해야 한다', () => {
      const logMsg = '행동 실행: 아이템 사용';
      useWorldStore.getState().appendActionLog(logMsg);

      const state = useWorldStore.getState();
      const lastEntry = state.narrativeEntries[state.narrativeEntries.length - 1];
      expect(lastEntry.text).toBe(logMsg);
      expect(lastEntry.type).toBe('action_log');
      expect(lastEntry.turn).toBe(state.turnCount);
    });
  });

  describe('Processing Phase (U-071[Mvp])', () => {
    it('setProcessingPhase 액션은 sceneState의 processingPhase를 업데이트해야 한다', () => {
      const store = useWorldStore.getState();

      // 1. 초기 상태 확인
      expect(store.sceneState.processingPhase).toBe('idle');

      // 2. 단계 변경
      store.setProcessingPhase('processing');
      expect(useWorldStore.getState().sceneState.processingPhase).toBe('processing');

      // 3. 단계 변경 (image_pending)
      store.setProcessingPhase('image_pending');
      expect(useWorldStore.getState().sceneState.processingPhase).toBe('image_pending');

      // 4. 유휴 상태로 복귀
      store.setProcessingPhase('idle');
      expect(useWorldStore.getState().sceneState.processingPhase).toBe('idle');
    });
  });

  describe('Scanner Hints (U-072[Mvp])', () => {
    it('applyTurnOutput에서 hints.scanner가 true이면 힌트 내러티브가 추가되어야 한다', () => {
      const mockOutput: Partial<TurnOutput> = {
        narrative: '일반 내러티브',
        economy: {
          cost: { signal: 0, memory_shard: 0 },
          balance_after: { signal: 100, memory_shard: 5 },
          credit: 0,
          low_balance_warning: false,
        },
        ui: {
          scene: { image_url: '', alt_text: '' },
          action_deck: { cards: [] },
          objects: [],
        },
        world: {
          inventory_added: [],
          inventory_removed: [],
          quests_updated: [],
          rules_changed: [],
          relationships_changed: [],
          memory_pins: [],
        },
        agent_console: {
          current_phase: 'commit',
          badges: ['schema_ok'],
          repair_count: 0,
          model_label: 'FAST',
        },
        safety: { blocked: false, message: null },
        hints: {
          scanner: true,
        },
      };

      useWorldStore.getState().applyTurnOutput(mockOutput as TurnOutput);

      const state = useWorldStore.getState();
      // 일반 내러티브 + 스캐너 힌트 총 2개여야 함
      expect(state.narrativeEntries).toHaveLength(2);
      expect(state.narrativeEntries[0].text).toBe('일반 내러티브');
      expect(state.narrativeEntries[1].text).toBe('scanner.hint_narrative');
      expect(state.narrativeEntries[1].type).toBe('system');
    });

    it('hints.scanner가 없으면 힌트 내러티브가 추가되지 않아야 한다', () => {
      const mockOutput: Partial<TurnOutput> = {
        narrative: '일반 내러티브',
        economy: {
          cost: { signal: 0, memory_shard: 0 },
          balance_after: { signal: 100, memory_shard: 5 },
          credit: 0,
          low_balance_warning: false,
        },
        ui: {
          scene: { image_url: '', alt_text: '' },
          action_deck: { cards: [] },
          objects: [],
        },
        world: {
          inventory_added: [],
          inventory_removed: [],
          quests_updated: [],
          rules_changed: [],
          relationships_changed: [],
          memory_pins: [],
        },
        agent_console: {
          current_phase: 'commit',
          badges: ['schema_ok'],
          repair_count: 0,
          model_label: 'FAST',
        },
        safety: { blocked: false, message: null },
      };

      useWorldStore.getState().applyTurnOutput(mockOutput as TurnOutput);

      const state = useWorldStore.getState();
      expect(state.narrativeEntries).toHaveLength(1);
      expect(state.narrativeEntries[0].text).toBe('일반 내러티브');
    });
  });

  describe('Objective System (U-078[Mvp])', () => {
    it('selectMainObjective는 is_main=true인 퀘스트를 반환해야 한다', () => {
      useWorldStore.setState({
        quests: [
          {
            id: 'q1',
            label: '서브',
            is_main: false,
            is_completed: false,
            progress: 0,
            reward_signal: 0,
            description: null,
          },
          {
            id: 'q2',
            label: '메인',
            is_main: true,
            is_completed: false,
            progress: 50,
            reward_signal: 100,
            description: null,
          },
        ],
      });

      const main = selectMainObjective(useWorldStore.getState());
      expect(main?.id).toBe('q2');
    });

    it('selectSubObjectives는 is_main=false인 퀘스트들을 반환해야 한다', () => {
      useWorldStore.setState({
        quests: [
          {
            id: 'q1',
            label: '서브1',
            is_main: false,
            is_completed: false,
            progress: 0,
            reward_signal: 0,
            description: null,
          },
          {
            id: 'q2',
            label: '메인',
            is_main: true,
            is_completed: false,
            progress: 50,
            reward_signal: 100,
            description: null,
          },
          {
            id: 'q3',
            label: '서브2',
            is_main: false,
            is_completed: false,
            progress: 0,
            reward_signal: 0,
            description: null,
          },
        ],
      });

      const subs = selectSubObjectives(useWorldStore.getState());
      expect(subs).toHaveLength(2);
      expect(subs.map((s) => s.id)).toContain('q1');
      expect(subs.map((s) => s.id)).toContain('q3');
    });

    it('퀘스트 완료 시 reward_signal이 있으면 알림 메시지가 추가되어야 한다', () => {
      // 1. 초기 상태: 미완료 퀘스트
      useWorldStore.setState({
        quests: [
          {
            id: 'q1',
            label: '임무',
            is_main: false,
            is_completed: false,
            progress: 0,
            reward_signal: 50,
            description: null,
          },
        ],
      });

      // 2. 완료 업데이트
      const output: Partial<TurnOutput> = {
        narrative: '임무 완료',
        economy: {
          cost: { signal: 0, memory_shard: 0 },
          balance_after: { signal: 150, memory_shard: 5 },
          credit: 0,
          low_balance_warning: false,
        },
        ui: {
          scene: { image_url: '', alt_text: '' },
          action_deck: { cards: [] },
          objects: [],
        },
        world: {
          inventory_added: [],
          inventory_removed: [],
          quests_updated: [
            {
              id: 'q1',
              label: '임무',
              is_main: false,
              is_completed: true,
              progress: 100,
              reward_signal: 50,
              description: null,
            },
          ],
          rules_changed: [],
          relationships_changed: [],
          memory_pins: [],
        },
        agent_console: {
          current_phase: 'commit',
          badges: ['schema_ok'],
          repair_count: 0,
          model_label: 'FAST',
        },
        safety: { blocked: false, message: null },
      };

      useWorldStore.getState().applyTurnOutput(output as TurnOutput);

      const state = useWorldStore.getState();
      // 일반 내러티브 + 보상 알림 총 2개
      expect(state.narrativeEntries).toHaveLength(2);
      expect(state.narrativeEntries[1].text).toContain('quest.objective_complete');
      expect(state.narrativeEntries[1].text).toContain('quest.reward_earned');
      expect(state.narrativeEntries[1].type).toBe('system');
    });
  });

  describe('Hotspot Policy (U-090[Mvp])', () => {
    it('새 이미지 생성 시 핫스팟이 초기화되어야 한다 (Q1: Option A)', () => {
      // 1. 기존 핫스팟 설정
      useWorldStore.setState({
        sceneObjects: [
          {
            id: 'old',
            label: '과거',
            box_2d: { ymin: 0, xmin: 0, ymax: 100, xmax: 100 },
            interaction_hint: null,
          },
        ],
      });

      // 2. 새 이미지 생성이 포함된 턴 (image_url 존재)
      const mockOutput: Partial<TurnOutput> = {
        narrative: '새 장면',
        economy: {
          cost: { signal: 0, memory_shard: 0 },
          balance_after: { signal: 100, memory_shard: 5 },
          credit: 0,
          low_balance_warning: false,
        },
        ui: {
          scene: { image_url: 'new_img.png', alt_text: '' },
          action_deck: { cards: [] },
          objects: [],
        },
        render: {
          image_url: 'new_img.png',
          image_job: null,
          image_id: 'img_1',
          generation_time_ms: 1000,
        },
        world: {
          inventory_added: [],
          inventory_removed: [],
          quests_updated: [],
          rules_changed: [],
          relationships_changed: [],
          memory_pins: [],
        },
        agent_console: {
          current_phase: 'commit',
          badges: ['schema_ok'],
          repair_count: 0,
          model_label: 'FAST',
        },
        safety: { blocked: false, message: null },
      };

      useWorldStore.getState().applyTurnOutput(mockOutput as TurnOutput);

      const state = useWorldStore.getState();
      expect(state.sceneObjects).toHaveLength(0); // 초기화됨
    });

    it('새 이미지 생성이 포함된 턴 (should_generate=true)에서도 핫스팟이 초기화되어야 한다', () => {
      // 1. 기존 핫스팟 설정
      useWorldStore.setState({
        sceneObjects: [
          {
            id: 'old',
            label: '과거',
            box_2d: { ymin: 0, xmin: 0, ymax: 100, xmax: 100 },
            interaction_hint: null,
          },
        ],
      });

      // 2. 이미지 생성 예정인 턴
      const mockOutput: Partial<TurnOutput> = {
        narrative: '장면 전환 중...',
        economy: {
          cost: { signal: 0, memory_shard: 0 },
          balance_after: { signal: 100, memory_shard: 5 },
          credit: 0,
          low_balance_warning: false,
        },
        ui: {
          scene: { image_url: '', alt_text: '' },
          action_deck: { cards: [] },
          objects: [],
        },
        render: {
          image_url: null,
          image_job: {
            should_generate: true,
            prompt: 'A new scene',
            model_label: 'FAST',
            aspect_ratio: '16:9',
            image_size: '1024x1024',
            reference_image_ids: [],
            reference_image_url: null,
          },
          image_id: null,
          generation_time_ms: null,
        },
        world: {
          inventory_added: [],
          inventory_removed: [],
          quests_updated: [],
          rules_changed: [],
          relationships_changed: [],
          memory_pins: [],
        },
        agent_console: {
          current_phase: 'commit',
          badges: ['schema_ok'],
          repair_count: 0,
          model_label: 'FAST',
        },
        safety: { blocked: false, message: null },
      };

      useWorldStore.getState().applyTurnOutput(mockOutput as TurnOutput);

      const state = useWorldStore.getState();
      expect(state.sceneObjects).toHaveLength(0); // 초기화됨
    });

    it('일반 턴(objects 비어있음)에서는 기존 핫스팟이 유지되어야 한다', () => {
      // 1. 기존 핫스팟 설정
      const oldObjects = [
        {
          id: 'obj1',
          label: '물체1',
          box_2d: { ymin: 100, xmin: 100, ymax: 200, xmax: 200 },
          interaction_hint: null,
        },
      ];
      useWorldStore.setState({
        sceneObjects: oldObjects,
      });

      // 2. 일반 턴 (objects 비어있음, 이미지 생성 없음)
      const mockOutput: Partial<TurnOutput> = {
        narrative: '아무 일도 일어나지 않습니다.',
        economy: {
          cost: { signal: 0, memory_shard: 0 },
          balance_after: { signal: 100, memory_shard: 5 },
          credit: 0,
          low_balance_warning: false,
        },
        ui: {
          scene: { image_url: '', alt_text: '' },
          action_deck: { cards: [] },
          objects: [],
        },
        world: {
          inventory_added: [],
          inventory_removed: [],
          quests_updated: [],
          rules_changed: [],
          relationships_changed: [],
          memory_pins: [],
        },
        agent_console: {
          current_phase: 'commit',
          badges: ['schema_ok'],
          repair_count: 0,
          model_label: 'FAST',
        },
        safety: { blocked: false, message: null },
      };

      useWorldStore.getState().applyTurnOutput(mockOutput as TurnOutput);

      const state = useWorldStore.getState();
      expect(state.sceneObjects).toEqual(oldObjects); // 유지됨
    });

    it('정밀분석 결과(objects 존재)는 기존 핫스팟에 병합되어야 한다', () => {
      // 1. 기존 핫스팟 설정
      const oldObjects = [
        {
          id: 'obj1',
          label: '물체1',
          box_2d: { ymin: 100, xmin: 100, ymax: 200, xmax: 200 },
          interaction_hint: null,
        },
      ];
      useWorldStore.setState({
        sceneObjects: oldObjects,
      });

      // 2. 정밀분석 결과 턴
      const newObject = {
        id: 'obj2',
        label: '물체2',
        box_2d: { ymin: 300, xmin: 300, ymax: 400, xmax: 400 },
        interaction_hint: null,
      };
      const mockOutput: Partial<TurnOutput> = {
        narrative: '자세히 보니 새로운 것이 보입니다.',
        economy: {
          cost: { signal: 0, memory_shard: 0 },
          balance_after: { signal: 100, memory_shard: 5 },
          credit: 0,
          low_balance_warning: false,
        },
        ui: {
          scene: { image_url: '', alt_text: '' },
          action_deck: { cards: [] },
          objects: [newObject],
        },
        world: {
          inventory_added: [],
          inventory_removed: [],
          quests_updated: [],
          rules_changed: [],
          relationships_changed: [],
          memory_pins: [],
        },
        agent_console: {
          current_phase: 'commit',
          badges: ['schema_ok'],
          repair_count: 0,
          model_label: 'FAST',
        },
        safety: { blocked: false, message: null },
      };

      useWorldStore.getState().applyTurnOutput(mockOutput as TurnOutput);

      const state = useWorldStore.getState();
      expect(state.sceneObjects).toHaveLength(2);
      expect(state.sceneObjects).toContainEqual(oldObjects[0]);
      expect(state.sceneObjects).toContainEqual(newObject);
    });
  });
});
</file>

<file path="backend/src/unknown_world/services/image_understanding.py">
"""Unknown World - 이미지 이해(Scanner) 서비스.

이 모듈은 사용자가 업로드한 이미지를 분석하여 캡션, 오브젝트(bbox),
아이템 후보를 추출하는 서비스를 제공합니다.

설계 원칙:
    - RULE-004: 실패 시 안전한 폴백 (텍스트-only 캡션)
    - RULE-007: 프롬프트 원문/비밀정보 노출 금지
    - RULE-009: bbox는 0~1000 정규화 + [ymin, xmin, ymax, xmax]

페어링 질문 결정:
    - Q1: Option A (multipart 업로드로 처리)

참조:
    - vibe/unit-plans/U-021[Mvp].md
    - vibe/tech-stack.md (비전 모델: gemini-3-flash-preview)
    - .cursor/rules/00-core-critical.mdc
"""

from __future__ import annotations

import asyncio
import json
import logging
import os
import random
import time
import uuid
from typing import TYPE_CHECKING, Any, cast

from unknown_world.config.models import ModelLabel, get_model_id
from unknown_world.models.scanner import (
    DetectedObject,
    ItemCandidate,
    ScanResult,
    ScanStatus,
)
from unknown_world.models.turn import Box2D, Language
from unknown_world.orchestrator.prompt_loader import load_prompt
from unknown_world.services.genai_client import ENV_UW_MODE, GenAIMode
from unknown_world.storage.validation import (
    ALLOWED_IMAGE_MIME_TYPES,
    BBOX_MAX,
    BBOX_MIN,
    MAX_IMAGE_FILE_SIZE_BYTES,
    validate_image_upload,
)

if TYPE_CHECKING:
    from google.genai import Client

# =============================================================================
# 로거 설정 (프롬프트/비밀정보 노출 금지)
# =============================================================================

logger = logging.getLogger(__name__)

# =============================================================================
# 호환성을 위한 상수 별칭 (api/scanner.py에서 import)
# =============================================================================

ALLOWED_MIME_TYPES = ALLOWED_IMAGE_MIME_TYPES
"""지원하는 이미지 MIME 타입 (호환성 별칭)."""

MAX_FILE_SIZE_BYTES = MAX_IMAGE_FILE_SIZE_BYTES
"""최대 이미지 파일 크기 (호환성 별칭)."""

# =============================================================================
# 재시도 설정 (U-094: ImageUnderstanding 응답 파싱 예외 시 자동 재시도)
# =============================================================================

SCAN_MAX_RETRIES = 2
"""최대 재시도 횟수 (총 3회 시도: 1 초기 + 2 재시도)."""

SCAN_RETRY_BACKOFF_SECONDS: list[float] = [1.0, 2.0]
"""재시도 간 백오프 시간 (초)."""

SCAN_RETRY_REINFORCEMENT: dict[Language, str] = {
    Language.KO: (
        "\n\n⚠️ 중요: 반드시 유효한 JSON 형식으로만 응답하세요. "
        "마크다운 코드 블록(```)을 사용하지 말고 순수 JSON만 반환하세요."
    ),
    Language.EN: (
        "\n\n⚠️ IMPORTANT: You MUST respond with valid JSON format only. "
        "Do NOT use markdown code blocks (```). Return pure JSON only."
    ),
}
"""재시도 시 추가되는 JSON 형식 강조 지시 (U-094 Q1: Option B)."""

# =============================================================================
# 아이템 수 랜덤화 설정 (U-095: Scanner 아이템 생성 개수 랜덤화)
# =============================================================================

SCAN_ITEM_COUNT_POPULATION: list[int] = [1, 2, 3]
"""생성 가능한 아이템 개수."""

SCAN_ITEM_COUNT_WEIGHTS: list[int] = [60, 30, 10]
"""아이템 개수별 가중치 (1개=60%, 2개=30%, 3개=10%)."""


def determine_item_count() -> int:
    """Scanner 아이템 생성 개수를 가중치 랜덤으로 결정합니다 (U-095).

    확률 분포:
        - 1개: 60%
        - 2개: 30%
        - 3개: 10%

    Returns:
        1~3 사이의 정수
    """
    return random.choices(
        population=SCAN_ITEM_COUNT_POPULATION,
        weights=SCAN_ITEM_COUNT_WEIGHTS,
        k=1,
    )[0]


_NON_RETRYABLE_ERROR_NAMES: frozenset[str] = frozenset(
    {
        "Unauthenticated",
        "PermissionDenied",
        "ResourceExhausted",
        "InvalidArgument",
        "NotFound",
    }
)
"""재시도 불가 API 에러 타입 이름 (인증/할당량/권한 등)."""


# =============================================================================
# Mock 서비스 구현
# =============================================================================


def _create_mock_scan_result(language: Language, item_count: int = 2) -> ScanResult:
    """Mock 스캔 결과를 생성합니다.

    U-095: item_count에 따라 1~3개의 아이템을 반환합니다.

    Args:
        language: 응답 언어
        item_count: 생성할 아이템 수 (1~3)

    Returns:
        Mock 스캔 결과 (item_count에 맞춘 아이템 목록)
    """
    # Mock 아이템 풀 (최대 3개) - 언어별
    _MOCK_ITEMS_KO: list[tuple[str, str, str, str]] = [
        ("녹슨 열쇠", "오래된 자물쇠를 열 수 있을 것 같은 열쇠입니다.", "key", "열쇠"),
        ("나무 상자", "무언가 들어있을 것 같은 작은 상자입니다.", "container", "상자"),
        ("깨진 수정", "희미하게 빛나는 수정 조각입니다.", "material", "수정"),
    ]
    _MOCK_ITEMS_EN: list[tuple[str, str, str, str]] = [
        ("Rusty Key", "An old key that might open an ancient lock.", "key", "Key"),
        ("Wooden Box", "A small box that might contain something.", "container", "Box"),
        ("Broken Crystal", "A faintly glowing crystal shard.", "material", "Crystal"),
    ]

    # Mock bbox 풀
    _MOCK_BBOXES: list[Box2D] = [
        Box2D(ymin=100, xmin=200, ymax=300, xmax=400),
        Box2D(ymin=400, xmin=100, ymax=700, xmax=500),
        Box2D(ymin=200, xmin=500, ymax=450, xmax=750),
    ]
    _MOCK_CONFIDENCES: list[float] = [0.95, 0.88, 0.82]

    items_pool = _MOCK_ITEMS_KO if language == Language.KO else _MOCK_ITEMS_EN
    count = max(1, min(3, item_count))  # 1~3 클램핑

    objects: list[DetectedObject] = []
    candidates: list[ItemCandidate] = []
    for i in range(count):
        label, desc, item_type, obj_label = items_pool[i]
        objects.append(
            DetectedObject(
                label=obj_label,
                box_2d=_MOCK_BBOXES[i],
                confidence=_MOCK_CONFIDENCES[i],
                suggested_item_type=item_type,
            ),
        )
        candidates.append(
            ItemCandidate(
                id=f"item_{uuid.uuid4().hex[:8]}",
                label=label,
                description=desc,
                item_type=item_type,
                source_object_index=i,
            ),
        )

    caption_ko = "[Mock] 테스트 이미지입니다. 여러 오브젝트가 감지되었습니다."
    caption_en = "[Mock] Test image. Multiple objects detected."

    return ScanResult(
        status=ScanStatus.COMPLETED,
        caption=caption_ko if language == Language.KO else caption_en,
        objects=objects,
        item_candidates=candidates,
        message=None,
        analysis_time_ms=150,
    )


# =============================================================================
# 유틸리티 함수
# =============================================================================


def validate_image(
    content: bytes,
    content_type: str,
) -> str | None:
    """이미지 파일을 검증합니다.

    NOTE: 이 함수는 호환성을 위해 유지되며, 내부적으로
    중앙화된 validate_image_upload를 호출합니다.

    Args:
        content: 이미지 바이트 데이터
        content_type: MIME 타입

    Returns:
        에러 메시지 (없으면 None)
    """
    return validate_image_upload(content, content_type, language=Language.KO)


def normalize_bbox(bbox: dict[str, Any]) -> Box2D:
    """bbox를 0~1000 범위로 정규화합니다.

    Args:
        bbox: 원본 bbox dict

    Returns:
        정규화된 Box2D
    """
    # 기본값
    ymin_val: int = int(bbox.get("ymin", 0) or 0)
    xmin_val: int = int(bbox.get("xmin", 0) or 0)
    ymax_val: int = int(bbox.get("ymax", BBOX_MAX) or BBOX_MAX)
    xmax_val: int = int(bbox.get("xmax", BBOX_MAX) or BBOX_MAX)

    # 범위 클램핑 (RULE-009)
    ymin_val = max(BBOX_MIN, min(BBOX_MAX, ymin_val))
    xmin_val = max(BBOX_MIN, min(BBOX_MAX, xmin_val))
    ymax_val = max(BBOX_MIN, min(BBOX_MAX, ymax_val))
    xmax_val = max(BBOX_MIN, min(BBOX_MAX, xmax_val))

    # ymin < ymax, xmin < xmax 보장
    if ymin_val >= ymax_val:
        ymax_val = min(ymin_val + 100, BBOX_MAX)
    if xmin_val >= xmax_val:
        xmax_val = min(xmin_val + 100, BBOX_MAX)

    return Box2D(ymin=ymin_val, xmin=xmin_val, ymax=ymax_val, xmax=xmax_val)


def _create_fallback_result(
    message: str,
    status: ScanStatus = ScanStatus.FAILED,
) -> ScanResult:
    """안전한 폴백 결과를 생성합니다 (RULE-004).

    Args:
        message: 에러/상태 메시지
        status: 스캔 상태

    Returns:
        스키마를 준수하는 폴백 ScanResult
    """
    return ScanResult(
        status=status,
        caption="",
        objects=[],
        item_candidates=[],
        message=message,
        analysis_time_ms=0,
    )


def _parse_vision_response(
    response_text: str,
    language: Language,  # noqa: ARG001
) -> ScanResult:
    """비전 모델 응답을 파싱합니다.

    Args:
        response_text: 모델 응답 텍스트 (JSON 예상)
        language: 응답 언어 (현재 사용되지 않음)

    Returns:
        파싱된 ScanResult
    """
    try:
        # JSON 파싱
        # 응답에 ```json ... ``` 마크다운이 포함된 경우 처리
        text = response_text.strip()
        if text.startswith("```"):
            # 첫 번째 줄 제거 (```json)
            lines = text.split("\n")
            if lines[0].startswith("```"):
                lines = lines[1:]
            # 마지막 줄 제거 (```)
            if lines and lines[-1].strip() == "```":
                lines = lines[:-1]
            text = "\n".join(lines)

        parsed = json.loads(text)

        # dict가 아닌 경우 처리 (이중 직렬화된 문자열 등)
        if isinstance(parsed, str):
            # 한 번 더 파싱 시도
            parsed = json.loads(parsed)

        if not isinstance(parsed, dict):
            raise ValueError(f"Expected dict, got {type(parsed).__name__}")

        data = cast(dict[str, Any], parsed)

        # caption 추출
        caption: str = str(data.get("caption", "") or "")

        # objects 추출 및 정규화
        objects: list[DetectedObject] = []
        raw_objects: list[dict[str, Any]] = data.get("objects") or []  # type: ignore[assignment]
        for i, obj in enumerate(raw_objects[:10]):  # 최대 10개
            if not isinstance(obj, dict):  # type: ignore[reportUnnecessaryIsInstance]
                continue

            label_val = obj.get("label")
            label: str = str(label_val) if label_val else f"Object_{i}"
            bbox_raw: dict[str, Any] = obj.get("box_2d") or {}  # type: ignore[assignment]
            bbox = normalize_bbox(bbox_raw)
            confidence_raw = obj.get("confidence")
            suggested_type_raw = obj.get("suggested_item_type")

            objects.append(
                DetectedObject(
                    label=label,
                    box_2d=bbox,
                    confidence=float(confidence_raw) if confidence_raw is not None else None,  # type: ignore[arg-type]
                    suggested_item_type=str(suggested_type_raw) if suggested_type_raw else None,  # type: ignore[arg-type]
                )
            )

        # item_candidates 추출
        item_candidates: list[ItemCandidate] = []
        raw_items: list[dict[str, Any]] = data.get("item_candidates") or []  # type: ignore[assignment]
        for i, item in enumerate(raw_items[:10]):  # 최대 10개
            if not isinstance(item, dict):  # type: ignore[reportUnnecessaryIsInstance]
                continue

            id_val = item.get("id")
            label_val = item.get("label")
            desc_val = item.get("description")
            type_val = item.get("item_type")
            source_idx = item.get("source_object_index")

            item_candidates.append(
                ItemCandidate(
                    id=str(id_val) if id_val else f"item_{uuid.uuid4().hex[:8]}",
                    label=str(label_val) if label_val else f"Item_{i}",
                    description=str(desc_val) if desc_val else "",
                    item_type=str(type_val) if type_val else "material",
                    source_object_index=int(source_idx) if source_idx is not None else None,  # type: ignore[arg-type]
                )
            )

        return ScanResult(
            status=ScanStatus.COMPLETED,
            caption=caption,
            objects=objects,
            item_candidates=item_candidates,
            message=None,
            analysis_time_ms=0,  # 호출자에서 설정
        )

    except (json.JSONDecodeError, ValueError) as e:
        logger.warning(
            "[ImageUnderstanding] JSON 파싱 실패",
            extra={"error": str(e), "error_type": type(e).__name__},
        )
        # 부분 결과로 캡션만 반환 (RULE-004)
        return ScanResult(
            status=ScanStatus.PARTIAL,
            caption=response_text[:500] if response_text else "",
            objects=[],
            item_candidates=[],
            message="오브젝트 감지 결과를 파싱할 수 없습니다. 캡션만 제공됩니다.",
            analysis_time_ms=0,
        )
    except Exception as e:
        logger.error(
            "[ImageUnderstanding] 응답 파싱 중 예외",
            extra={"error_type": type(e).__name__},
        )
        return _create_fallback_result(f"응답 처리 중 오류: {type(e).__name__}")


# =============================================================================
# 아이템 개수 검증/조정 (U-095)
# =============================================================================


def _adjust_item_count(result: ScanResult, target_count: int) -> ScanResult:
    """모델이 반환한 아이템 수를 target_count에 맞게 조정합니다 (U-095).

    - 아이템이 target_count보다 많으면 → 앞에서부터 target_count개만 유지
    - 아이템이 target_count보다 적으면 → 있는 만큼만 유지 (강제 생성 X)
    - 중복 이름 아이템 제거 (동일 label 금지)

    Args:
        result: 파싱된 ScanResult
        target_count: 목표 아이템 수

    Returns:
        조정된 ScanResult
    """
    if result.status not in (ScanStatus.COMPLETED, ScanStatus.PARTIAL):
        return result

    candidates = result.item_candidates

    # 중복 이름 제거 (첫 등장 유지)
    seen_labels: set[str] = set()
    unique_candidates: list[ItemCandidate] = []
    for c in candidates:
        label_lower = c.label.strip().lower()
        if label_lower not in seen_labels:
            seen_labels.add(label_lower)
            unique_candidates.append(c)

    # target_count 이하로 잘라내기
    adjusted = unique_candidates[:target_count]

    if len(adjusted) != len(candidates):
        logger.info(
            "[Scan] 아이템 수 조정: %d → %d (목표: %d)",
            len(candidates),
            len(adjusted),
            target_count,
        )

    result.item_candidates = adjusted
    return result


# =============================================================================
# 재시도 헬퍼 함수 (U-094)
# =============================================================================


def _is_non_retryable_api_error(error: Exception) -> bool:
    """재시도 불가 API 에러인지 확인합니다 (U-094).

    인증 실패(401), 권한 거부(403), 할당량 초과(429) 등은
    재시도해도 동일한 결과이므로 즉시 폴백합니다.

    Args:
        error: 발생한 예외

    Returns:
        True이면 재시도 불가
    """
    return any(cls.__name__ in _NON_RETRYABLE_ERROR_NAMES for cls in type(error).__mro__)


def _is_safety_blocked_response(response: Any) -> bool:
    """Gemini 응답이 안전 정책에 의해 차단되었는지 확인합니다 (U-094).

    안전 차단은 재시도해도 동일한 결과이므로 즉시 폴백합니다.

    Args:
        response: Gemini API 응답 객체

    Returns:
        True이면 안전 차단됨
    """
    try:
        # candidates[0].finish_reason 확인
        if hasattr(response, "candidates") and response.candidates:
            candidate = response.candidates[0]
            finish_reason = getattr(candidate, "finish_reason", None)
            if finish_reason is not None:
                reason_str = str(finish_reason).upper()
                if reason_str in ("SAFETY", "BLOCKED", "RECITATION"):
                    return True
        # prompt_feedback.block_reason 확인
        if hasattr(response, "prompt_feedback"):
            feedback = response.prompt_feedback
            if hasattr(feedback, "block_reason") and feedback.block_reason:
                return True
    except Exception:
        pass
    return False


def _get_final_failure_message(language: Language) -> str:
    """최종 실패 시 사용자에게 표시할 메시지를 반환합니다 (U-094, RULE-006).

    Args:
        language: 응답 언어

    Returns:
        i18n 폴백 메시지
    """
    if language == Language.KO:
        return "이미지 분석에 실패했습니다. 다시 시도해주세요."
    return "Image analysis failed. Please try again."


# =============================================================================
# 이미지 이해 서비스 클래스
# =============================================================================


class ImageUnderstandingService:
    """이미지 이해 서비스.

    비전 모델을 사용하여 이미지를 분석하고
    캡션, 오브젝트, 아이템 후보를 추출합니다.
    """

    def __init__(
        self,
        *,
        force_mock: bool = False,
    ) -> None:
        """ImageUnderstandingService를 초기화합니다.

        Args:
            force_mock: True면 Mock 모드 강제
        """
        # 모드 결정
        if force_mock:
            self._is_mock = True
        else:
            mode_str = os.environ.get(ENV_UW_MODE, GenAIMode.REAL)
            self._is_mock = mode_str == GenAIMode.MOCK

        self._genai_client: Client | None = None

        # Real 모드에서만 클라이언트 초기화
        if not self._is_mock:
            self._initialize_client()

        logger.info(
            "[ImageUnderstanding] 서비스 초기화",
            extra={"mode": "mock" if self._is_mock else "real"},
        )

    def _initialize_client(self) -> None:
        """google-genai 클라이언트를 초기화합니다."""
        try:
            from google.genai import Client

            # U-080 핫픽스: API 키 모드로 클라이언트 초기화 (Vertex AI 제거)
            api_key = os.environ.get("GOOGLE_API_KEY")
            if not api_key:
                logger.warning(
                    "[ImageUnderstanding] GOOGLE_API_KEY 환경변수가 설정되지 않음 - Mock 모드로 전환",
                )
                self._is_mock = True
                self._genai_client = None
                return

            self._genai_client = Client(api_key=api_key)
            self._is_mock = False

            logger.info(
                "[ImageUnderstanding] API 키 클라이언트 초기화 완료",
                extra={
                    "auth": "api_key",
                },
            )
        except Exception as e:
            logger.warning(
                "[ImageUnderstanding] 클라이언트 초기화 실패 - Mock 모드로 전환",
                extra={"error_type": type(e).__name__},
            )
            self._is_mock = True
            self._genai_client = None

    @property
    def is_mock(self) -> bool:
        """Mock 모드 여부."""
        return self._is_mock

    async def analyze(
        self,
        image_content: bytes,
        content_type: str,
        language: Language = Language.KO,
        *,
        preserve_original: bool = False,
        session_id: str | None = None,
    ) -> ScanResult:
        """이미지를 분석합니다.

        Args:
            image_content: 이미지 바이트 데이터
            content_type: MIME 타입
            language: 응답 언어
            preserve_original: 원본 이미지 저장 여부 (RU-006-S1)
            session_id: 세션 ID (저장 시 그룹화용)

        Returns:
            ScanResult: 분석 결과 (저장 시 original_image_key/url 포함)
        """
        start_time = time.time()

        # 이미지 검증
        validation_error = validate_image(image_content, content_type)
        if validation_error:
            return _create_fallback_result(validation_error)

        # 원본 이미지 저장 (선택적, RU-006-S1)
        original_image_key: str | None = None
        original_image_url: str | None = None

        if preserve_original:
            try:
                from unknown_world.storage import StorageCategory, get_storage

                storage = get_storage()
                put_result = await storage.put(
                    data=image_content,
                    category=StorageCategory.UPLOADED_IMAGE,
                    content_type=content_type,
                    session_id=session_id,
                )

                if put_result.success:
                    original_image_key = put_result.key
                    original_image_url = put_result.url
                    logger.debug(
                        "[ImageUnderstanding] 원본 이미지 저장 완료",
                        extra={
                            "key": original_image_key,
                            "size_kb": len(image_content) // 1024,
                        },
                    )
            except Exception as e:
                # 저장 실패해도 분석은 계속 (RULE-004)
                logger.warning(
                    "[ImageUnderstanding] 원본 이미지 저장 실패",
                    extra={"error_type": type(e).__name__},
                )

        # U-095: 아이템 생성 개수 랜덤 결정 (서버에서 확정적으로 결정)
        item_count = determine_item_count()
        logger.info(
            "[ImageUnderstanding] 아이템 생성 개수 결정",
            extra={"item_count": item_count},
        )

        # Mock 모드 처리
        if self._is_mock:
            logger.debug("[ImageUnderstanding] Mock 분석 수행")
            result = _create_mock_scan_result(language, item_count=item_count)
            result.analysis_time_ms = int((time.time() - start_time) * 1000)
            result.original_image_key = original_image_key
            result.original_image_url = original_image_url
            return result

        # 실제 비전 모델 호출
        try:
            result = await self._call_vision_model(
                image_content,
                content_type,
                language,
                item_count=item_count,
            )
            result.analysis_time_ms = int((time.time() - start_time) * 1000)
            result.original_image_key = original_image_key
            result.original_image_url = original_image_url
            return result

        except Exception as e:
            error_type = type(e).__name__
            logger.error(
                "[ImageUnderstanding] 비전 모델 호출 실패",
                extra={"error_type": error_type},
            )
            # 안전한 폴백 (RULE-004)
            return _create_fallback_result(f"이미지 분석 중 오류가 발생했습니다: {error_type}")

    async def _call_vision_model(
        self,
        image_content: bytes,
        content_type: str,
        language: Language,
        *,
        item_count: int = 1,
    ) -> ScanResult:
        """비전 모델을 호출합니다 (파싱 실패 시 자동 재시도 포함).

        U-094: ImageUnderstanding 응답 파싱 예외 시 자동 재시도.
        U-095: item_count에 따라 프롬프트에 아이템 수 지시 추가.

        - 최대 2회 재시도 (총 3회 시도)
        - 재시도 시 JSON 형식 강조 지시 추가 (Q1: Option B)
        - 백오프: 1초, 2초
        - 재시도 제외: 인증 실패(401), 할당량 초과(429), 안전 차단

        Args:
            image_content: 이미지 바이트 데이터
            content_type: MIME 타입
            language: 응답 언어
            item_count: 생성할 아이템 수 (1~3, U-095)

        Returns:
            ScanResult: 분석 결과 (성공 또는 폴백)
        """
        if self._genai_client is None:
            return _create_fallback_result("비전 클라이언트가 초기화되지 않았습니다")

        last_result: ScanResult | None = None

        for attempt in range(SCAN_MAX_RETRIES + 1):  # 0=초기, 1~2=재시도
            is_retry = attempt > 0

            # 재시도 시 백오프 대기
            if is_retry:
                backoff_seconds = SCAN_RETRY_BACKOFF_SECONDS[attempt - 1]
                logger.info(
                    "[Scan] 파싱 실패, 재시도 %d/%d (백오프 %.1f초)",
                    attempt,
                    SCAN_MAX_RETRIES,
                    backoff_seconds,
                )
                await asyncio.sleep(backoff_seconds)

            try:
                result = await self._execute_single_vision_call(
                    image_content,
                    content_type,
                    language,
                    is_retry=is_retry,
                    item_count=item_count,
                )

                # 완전 성공 → 아이템 수 조정 후 반환 (U-095)
                if result.status == ScanStatus.COMPLETED:
                    if is_retry:
                        logger.info(
                            "[Scan] 재시도 성공 (%d/%d 시도)",
                            attempt + 1,
                            SCAN_MAX_RETRIES + 1,
                        )
                    return _adjust_item_count(result, item_count)

                # 안전 차단 → 재시도 불가, 즉시 반환
                if result.status == ScanStatus.BLOCKED:
                    logger.warning("[Scan] 안전 차단, 재시도 건너뜀")
                    return result

                # PARTIAL/FAILED → 재시도 대상
                last_result = result
                logger.warning(
                    "[Scan] 파싱 실패 (시도 %d/%d, 상태: %s)",
                    attempt + 1,
                    SCAN_MAX_RETRIES + 1,
                    result.status.value,
                )

            except Exception as e:
                error_type = type(e).__name__

                # 재시도 불가 API 에러 (인증/할당량/권한)
                if _is_non_retryable_api_error(e):
                    logger.error(
                        "[Scan] 재시도 불가 API 오류: %s",
                        error_type,
                    )
                    return _create_fallback_result(
                        f"API 오류로 이미지 분석에 실패했습니다: {error_type}",
                    )

                # 기타 예외 → 재시도
                logger.warning(
                    "[Scan] API 호출 예외 (시도 %d/%d)",
                    attempt + 1,
                    SCAN_MAX_RETRIES + 1,
                    extra={"error_type": error_type},
                )
                last_result = _create_fallback_result(
                    f"API 호출 오류: {error_type}",
                )

        # 모든 재시도 실패 → 폴백 반환
        total_attempts = SCAN_MAX_RETRIES + 1
        logger.error(
            "[Scan] 모든 재시도 실패 (%d/%d 시도), 폴백 응답 반환",
            total_attempts,
            total_attempts,
        )

        if last_result is not None:
            last_result.message = _get_final_failure_message(language)
            return last_result

        return _create_fallback_result(_get_final_failure_message(language))

    async def _execute_single_vision_call(
        self,
        image_content: bytes,
        content_type: str,
        language: Language,
        *,
        is_retry: bool = False,
        item_count: int = 1,
    ) -> ScanResult:
        """단일 비전 모델 API 호출을 실행합니다.

        U-094: 재시도 시 JSON 형식 강조 지시를 프롬프트에 추가합니다.
        U-095: item_count에 따라 아이템 수 지시를 프롬프트에 추가합니다.

        Args:
            image_content: 이미지 바이트 데이터
            content_type: MIME 타입
            language: 응답 언어
            is_retry: 재시도 여부 (True면 JSON 강조 지시 추가)
            item_count: 생성할 아이템 수 (1~3, U-095)

        Returns:
            ScanResult: 파싱된 분석 결과

        Raises:
            Exception: API 호출 중 발생한 예외 (호출자에서 재시도/폴백 처리)
        """
        # 프롬프트 로드 (U-095: 아이템 수 지시 포함)
        prompt_text = load_prompt("scan", "scan_instructions", language).replace(
            "{count}", str(item_count)
        )

        if is_retry:
            reinforcement = SCAN_RETRY_REINFORCEMENT.get(
                language,
                SCAN_RETRY_REINFORCEMENT[Language.KO],
            )
            prompt_text = prompt_text + reinforcement

        # 모델 ID 조회
        model_id = get_model_id(ModelLabel.VISION)

        logger.debug(
            "[ImageUnderstanding] 비전 모델 호출",
            extra={
                "model_id": model_id,
                "language": language.value,
                "image_size_kb": len(image_content) // 1024,
                "is_retry": is_retry,
            },
        )

        # google-genai SDK 호출 (멀티모달 입력)
        from google.genai.types import GenerateContentConfig, Part

        # 멀티모달 입력 구성 (이미지 먼저, 텍스트 뒤에 - PRD 8.6 권장)
        contents = [
            Part.from_bytes(
                data=image_content,
                mime_type=content_type,
            ),
            Part.from_text(text=prompt_text),
        ]

        # JSON 응답 강제 + 충분한 출력 토큰 확보
        config = GenerateContentConfig(
            response_mime_type="application/json",
            max_output_tokens=32768,  # JSON 응답 잘림 방지
        )

        response = await self._genai_client.aio.models.generate_content(  # type: ignore[reportUnknownMemberType]
            model=model_id,
            contents=contents,  # type: ignore[reportArgumentType]
            config=config,
        )

        # 안전 차단 확인 (U-094: 안전 차단은 재시도 제외)
        if _is_safety_blocked_response(response):
            msg = (
                "안전 정책에 의해 이미지 분석이 차단되었습니다."
                if language == Language.KO
                else "Image analysis was blocked by safety policy."
            )
            return ScanResult(
                status=ScanStatus.BLOCKED,
                caption="",
                objects=[],
                item_candidates=[],
                message=msg,
                analysis_time_ms=0,
            )

        # 응답 텍스트 추출
        response_text: str = ""
        if hasattr(response, "text") and response.text:
            response_text = str(response.text)
        else:
            response_text = str(response)

        if not response_text:
            return _create_fallback_result("모델 응답이 비어있습니다")

        # 응답 파싱
        return _parse_vision_response(response_text, language)


# =============================================================================
# 팩토리 함수
# =============================================================================

# 싱글톤 인스턴스 캐시
_service_instance: ImageUnderstandingService | None = None


def get_image_understanding_service(
    *,
    force_new: bool = False,
) -> ImageUnderstandingService:
    """ImageUnderstandingService 인스턴스를 반환합니다.

    싱글톤 패턴으로 동작합니다.

    Args:
        force_new: True면 캐시를 무시하고 새 인스턴스 생성

    Returns:
        ImageUnderstandingService 인스턴스
    """
    global _service_instance

    if not force_new and _service_instance is not None:
        return _service_instance

    _service_instance = ImageUnderstandingService()
    return _service_instance


def reset_image_understanding_service() -> None:
    """ImageUnderstandingService 캐시를 초기화합니다.

    테스트 시 서비스를 재설정할 때 사용합니다.
    """
    global _service_instance
    _service_instance = None
</file>

<file path="backend/src/unknown_world/orchestrator/stages/render.py">
"""Unknown World - Render Stage.

렌더링 단계입니다.
U-051에서 이미지 생성 서비스 브릿지가 구축되었으며,
U-052에서 이미지 생성 여부 판정 로직이 추가되었습니다.
U-053에서 실제 이미지 생성 호출 및 결과 동기화가 구현되었습니다.

설계 원칙:
    - RULE-005: 재화 인바리언트 (잔액 부족 시 텍스트-only 폴백)
    - RULE-007: 프롬프트 원문 로그 노출 금지
    - RULE-008: 단계 이벤트 일관성, 텍스트 우선 + Lazy 이미지
    - 동작 보존: image_generator가 None이거나 should_generate가 false면 pass-through
    - U-051: 이미지 생성 서비스 의존성 주입 및 연결 가능 상태 확보
    - U-052: 조건부 이미지 생성 판정 로직
    - U-053: 비동기 이미지 생성 호출 및 TurnOutput.render 동기화

참조:
    - vibe/refactors/RU-005-Q4.md
    - vibe/unit-results/U-019[Mvp].md
    - vibe/unit-results/U-051[Mvp].md
    - vibe/unit-results/U-052[Mvp].md
    - vibe/unit-plans/U-053[Mvp].md
"""

from __future__ import annotations

import asyncio
import logging
from datetime import UTC, datetime

from unknown_world.models.turn import (
    AgentPhase,
    EconomySnapshot,
    RenderOutput,
    SafetyOutput,
    ValidationBadge,
)
from unknown_world.orchestrator.stages.render_helpers import (
    ImageFallbackResult,
    ImageGenerationDecision,
    create_image_fallback_result,
    decide_image_generation,
    extract_image_job,
)
from unknown_world.orchestrator.stages.types import (
    EmitFn,
    PipelineContext,
    PipelineEvent,
    PipelineEventType,
)
from unknown_world.services.image_generation import (
    ImageGenerationRequest,
    ImageGenerationStatus,
)

# 모의 처리 지연 시간 (ms)
RENDER_DELAY_MS = 80

# 로거 (프롬프트/비밀정보 노출 금지 - RULE-007)
logger = logging.getLogger(__name__)


# =============================================================================
# 이미지 생성 헬퍼 함수 (U-053)
# =============================================================================


async def _execute_image_generation(  # noqa: RUF100  # pyright: ignore[reportUnusedFunction]
    ctx: PipelineContext,
    image_decision: ImageGenerationDecision,
    emit: EmitFn,
) -> PipelineContext:
    """이미지 생성을 실행하고 결과를 TurnOutput에 반영합니다.

    U-097: 현재 render_stage에서는 text-first delivery를 위해 이 함수를 호출하지 않음.
    프론트엔드가 /api/image/generate로 비동기 생성을 수행함.
    향후 백엔드 사이드 이미지 생성이 필요한 경우(MMP 등) 재활용 가능.

    Args:
        ctx: 파이프라인 컨텍스트
        image_decision: 이미지 생성 판정 결과 (U-052)
        emit: 이벤트 emit 콜백

    Returns:
        업데이트된 컨텍스트 (TurnOutput.render에 image_url 반영)

    설계:
        - 페어링 질문 Q1: Option A (ctx.output 갱신) 채택
        - RULE-004: 실패 시 즉시 폴백 (재시도 0회, U-054 Q1: Option A)
        - RULE-007: 프롬프트 원문 로그 노출 금지 (해시만 사용)
        - RULE-008: 텍스트 우선 + Lazy 이미지 원칙
    """
    if ctx.image_generator is None or ctx.output is None:
        logger.debug("[Render] 이미지 생성 조건 불충족, 건너뜀")
        return ctx

    # ImageJob에서 프롬프트 추출 (판정에서 이미 유효성 검증됨)
    image_job = extract_image_job(ctx.output)
    if image_job is None or not image_job.prompt:
        logger.warning("[Render] ImageJob 또는 프롬프트 없음, 생성 건너뜀")
        return ctx

    # 언어 정보 추출 (폴백 메시지용)
    language = ctx.turn_input.language.value

    # 생성 시작 시간 기록
    start_time = datetime.now(UTC)

    logger.info(
        "[Render] 이미지 생성 시작",
        extra={
            "prompt_hash": image_decision.prompt_hash,
            "aspect_ratio": image_decision.aspect_ratio,
            "image_size": image_decision.image_size,
            "reference_image_url": image_decision.reference_image_url,
        },
    )

    # U-079: FAST 폴백 시 model_label 오버라이드
    effective_model_label = image_decision.model_override or "QUALITY"

    if image_decision.is_low_balance_fallback:
        logger.info(
            "[Render] U-079: 잔액 부족 FAST 폴백 적용",
            extra={
                "model_override": effective_model_label,
                "estimated_cost": image_decision.estimated_cost_signal,
            },
        )

    # ImageGenerationRequest 생성
    # U-091: rembg 런타임 제거 - remove_background, image_type_hint 제거
    request = ImageGenerationRequest(
        prompt=image_job.prompt,
        aspect_ratio=image_decision.aspect_ratio or image_job.aspect_ratio,
        image_size=image_decision.image_size or image_job.image_size,
        reference_image_ids=image_job.reference_image_ids,
        reference_image_url=image_decision.reference_image_url,
        session_id=None,  # 세션 ID는 필요 시 TurnInput에서 추출
        seed=ctx.seed,
        model_label=effective_model_label,
    )

    try:
        # 비동기 이미지 생성 호출
        response = await ctx.image_generator.generate(request)

        # 생성 소요 시간 계산
        elapsed_ms = int((datetime.now(UTC) - start_time).total_seconds() * 1000)

        # 결과 처리
        if response.status == ImageGenerationStatus.COMPLETED:
            logger.info(
                "[Render] 이미지 생성 성공",
                extra={
                    "image_id": response.image_id,
                    "image_url": response.image_url,
                    "generation_time_ms": response.generation_time_ms,
                    "total_elapsed_ms": elapsed_ms,
                },
            )

            # TurnOutput.render에 결과 반영 (Option A: ctx.output 갱신)
            ctx = _update_render_output(
                ctx=ctx,
                image_url=response.image_url,
                image_id=response.image_id,
                generation_time_ms=response.generation_time_ms,
            )

        else:
            # U-054: 이미지 생성 실패 - 즉시 폴백 (재시도 0회, Q1: Option A)
            logger.warning(
                "[Render] 이미지 생성 실패, 텍스트-only 폴백",
                extra={
                    "status": response.status.value,
                    "status_message": response.message,
                    "elapsed_ms": elapsed_ms,
                    "prompt_hash": image_decision.prompt_hash,
                },
            )

            # 폴백 결과 생성 및 TurnOutput 업데이트
            fallback_result = create_image_fallback_result(
                status_message=response.message,
                language=language,
            )
            ctx = _apply_image_fallback(ctx, fallback_result)

    except TimeoutError:
        # 타임아웃 예외 - 안전하게 폴백 (RULE-004)
        elapsed_ms = int((datetime.now(UTC) - start_time).total_seconds() * 1000)

        logger.warning(
            "[Render] 이미지 생성 타임아웃, 텍스트-only 폴백",
            extra={
                "elapsed_ms": elapsed_ms,
                "prompt_hash": image_decision.prompt_hash,
            },
        )

        fallback_result = create_image_fallback_result(
            status_message="timeout",
            language=language,
        )
        ctx = _apply_image_fallback(ctx, fallback_result)

    except (ValueError, TypeError) as e:
        # 잘못된 요청/검증 오류 - 안전하게 폴백 (RULE-004)
        elapsed_ms = int((datetime.now(UTC) - start_time).total_seconds() * 1000)
        error_type = type(e).__name__

        logger.warning(
            "[Render] 이미지 생성 요청 오류, 텍스트-only 폴백",
            extra={
                "error_type": error_type,
                "error_message": str(e),
                "elapsed_ms": elapsed_ms,
                "prompt_hash": image_decision.prompt_hash,
            },
        )

        fallback_result = create_image_fallback_result(
            status_message=str(e),
            language=language,
        )
        ctx = _apply_image_fallback(ctx, fallback_result)

    except Exception as e:
        # 기타 예외 발생 시 안전하게 처리 (RULE-004)
        elapsed_ms = int((datetime.now(UTC) - start_time).total_seconds() * 1000)
        error_type = type(e).__name__

        logger.error(
            "[Render] 이미지 생성 중 예외 발생, 텍스트-only 폴백",
            extra={
                "error_type": error_type,
                "error_message": str(e),
                "elapsed_ms": elapsed_ms,
                "prompt_hash": image_decision.prompt_hash,
            },
        )

        fallback_result = create_image_fallback_result(
            status_message=None,
            language=language,
        )
        ctx = _apply_image_fallback(ctx, fallback_result)

    return ctx


def _apply_image_fallback(
    ctx: PipelineContext,
    fallback_result: ImageFallbackResult,
) -> PipelineContext:
    """이미지 생성 실패 시 폴백을 적용합니다.

    U-054: RULE-004에 따라 이미지 생성 실패 시 안전한 폴백을 제공합니다.
    - 안전 차단 시 TurnOutput.safety 업데이트
    - 배지에 실패 상태 반영

    Args:
        ctx: 파이프라인 컨텍스트
        fallback_result: 폴백 처리 결과

    Returns:
        업데이트된 컨텍스트
    """
    if ctx.output is None:
        return ctx

    logger.info(
        "[Render] 이미지 폴백 적용",
        extra={
            "is_safety_blocked": fallback_result.is_safety_blocked,
            "reason": fallback_result.reason,
        },
    )

    # 안전 차단 시 TurnOutput.safety 업데이트
    if fallback_result.should_update_safety:
        new_safety = SafetyOutput(
            blocked=True,
            message=fallback_result.fallback_message,
        )
        ctx.output = ctx.output.model_copy(update={"safety": new_safety})

        # 배지에 SAFETY_BLOCKED 추가
        ctx = _add_badge(ctx, ValidationBadge.SAFETY_BLOCKED)
    else:
        # 일반 실패 시에도 기존 배지는 유지하고 로그만 기록
        # (SAFETY_OK는 이미 설정되어 있을 수 있음)
        pass

    return ctx


def _add_badge(ctx: PipelineContext, badge: ValidationBadge) -> PipelineContext:
    """TurnOutput.agent_console.badges에 배지를 추가합니다.

    U-054: 이미지 생성 상태를 배지로 반영합니다.
    중복 배지는 추가하지 않습니다.

    Args:
        ctx: 파이프라인 컨텍스트
        badge: 추가할 배지

    Returns:
        업데이트된 컨텍스트
    """
    if ctx.output is None:
        return ctx

    current_badges = list(ctx.output.agent_console.badges)

    # 관련 배지 교체 (예: SAFETY_OK -> SAFETY_BLOCKED)
    if badge == ValidationBadge.SAFETY_BLOCKED:
        current_badges = [b for b in current_badges if b != ValidationBadge.SAFETY_OK]

    # 중복 방지
    if badge not in current_badges:
        current_badges.append(badge)

    # agent_console 업데이트
    new_console = ctx.output.agent_console.model_copy(update={"badges": current_badges})
    ctx.output = ctx.output.model_copy(update={"agent_console": new_console})

    logger.debug(
        "[Render] 배지 추가됨",
        extra={"badge": badge.value, "total_badges": len(current_badges)},
    )

    return ctx


def _update_render_output(
    ctx: PipelineContext,
    *,
    image_url: str | None,
    image_id: str | None,
    generation_time_ms: int,
) -> PipelineContext:
    """TurnOutput.render에 이미지 생성 결과를 반영합니다.

    페어링 질문 Q1: Option A (ctx.output 갱신) 채택
    - Pydantic 모델은 frozen이 아니므로 직접 수정 가능
    - model_copy()를 사용하여 새 RenderOutput 생성 후 교체

    Args:
        ctx: 파이프라인 컨텍스트
        image_url: 생성된 이미지 URL
        image_id: 생성된 이미지 ID
        generation_time_ms: 생성 소요 시간 (ms)

    Returns:
        업데이트된 컨텍스트
    """
    if ctx.output is None:
        return ctx

    # 기존 RenderOutput을 복사하고 새 필드 추가
    # U-069: 백엔드에서 이미지 생성 완료 후 should_generate=False로 설정
    # 클라이언트가 중복 생성 요청을 보내지 않도록 함
    old_render = ctx.output.render
    updated_image_job = None
    if old_render.image_job is not None:
        # should_generate를 False로 변경하여 클라이언트 중복 생성 방지
        updated_image_job = old_render.image_job.model_copy(update={"should_generate": False})

    new_render = RenderOutput(
        image_job=updated_image_job,
        image_url=image_url,
        image_id=image_id,
        generation_time_ms=generation_time_ms,
    )

    # TurnOutput 전체를 model_copy로 갱신
    ctx.output = ctx.output.model_copy(update={"render": new_render})

    logger.debug(
        "[Render] TurnOutput.render 업데이트 완료",
        extra={
            "image_id": image_id,
            "image_url": image_url,
        },
    )

    return ctx


async def render_stage(ctx: PipelineContext, *, emit: EmitFn) -> PipelineContext:
    """Render 단계를 실행합니다.

    이미지 생성 서비스가 주입되었으면 이미지 생성 파이프라인을 실행합니다.
    주입되지 않았거나 이미지 생성이 필요 없는 경우 pass-through로 동작합니다.

    U-051에서 브릿지가 구축되었으며, 실제 이미지 생성 로직은 U-052/U-053에서 추가됩니다:
    - U-052: should_generate 판정 및 프롬프트/해상도 추출
    - U-053: 비동기 이미지 생성 호출 및 결과 동기화

    Args:
        ctx: 파이프라인 컨텍스트 (image_generator 포함 가능)
        emit: 이벤트 emit 콜백

    Returns:
        업데이트된 컨텍스트
    """
    ctx.current_phase = AgentPhase.RENDER

    # Stage 시작 이벤트
    await emit(
        PipelineEvent(
            event_type=PipelineEventType.STAGE_START,
            phase=AgentPhase.RENDER,
        )
    )

    # U-051/U-052: 이미지 생성 서비스 및 판정 로직
    image_decision: ImageGenerationDecision | None = None

    if ctx.image_generator is not None:
        # 이미지 생성 서비스가 주입됨 - 연결 준비 완료
        logger.debug(
            "[Render] 이미지 생성 서비스 연결됨",
            extra={
                "generator_type": type(ctx.image_generator).__name__,
                "is_available": ctx.image_generator.is_available(),
            },
        )

        # U-052: 이미지 생성 여부 판정
        if ctx.output is not None:
            # Economy 스냅샷을 EconomySnapshot으로 변환
            economy_snapshot = EconomySnapshot(
                signal=ctx.economy_snapshot.signal,
                memory_shard=ctx.economy_snapshot.memory_shard,
            )

            # 판정 수행 (U-068: 이전 이미지 URL을 참조 이미지로 전달)
            image_decision = decide_image_generation(
                turn_output=ctx.output,
                economy_snapshot=economy_snapshot,
                language=ctx.turn_input.language.value,
                previous_image_url=ctx.turn_input.previous_image_url,
            )

            # 판정 결과 로깅 (프롬프트 원문 제외 - RULE-007)
            logger.info(
                "[Render] 이미지 생성 판정 완료",
                extra={
                    "should_generate": image_decision.should_generate,
                    "reason": image_decision.reason,
                    "prompt_hash": image_decision.prompt_hash,
                    "estimated_cost": image_decision.estimated_cost_signal,
                    "is_low_balance_fallback": image_decision.is_low_balance_fallback,
                    "model_override": image_decision.model_override,
                },
            )

            # U-097: 이미지 생성은 프론트엔드에서 비동기로 실행 (text-first delivery)
            # 백엔드에서는 판정 결과(should_generate=True)만 image_job에 유지하고,
            # 실제 생성은 프론트엔드가 /api/image/generate로 별도 요청한다.
            # 이를 통해 텍스트 스트리밍이 이미지 생성 완료를 기다리지 않고 즉시 전달된다.
            if image_decision.should_generate:
                # U-079: 잔액 부족 FAST 폴백 시 model_label 오버라이드를 image_job에 반영
                if image_decision.model_override and ctx.output.render.image_job is not None:
                    updated_job = ctx.output.render.image_job.model_copy(
                        update={"model_label": image_decision.model_override}
                    )
                    new_render = ctx.output.render.model_copy(update={"image_job": updated_job})
                    ctx.output = ctx.output.model_copy(update={"render": new_render})

                # U-079: 잔액 부족 폴백 발생 시 경제 정보 사후 조정
                if image_decision.is_low_balance_fallback:
                    ctx = _adjust_economy_for_fallback(ctx, image_decision)

                logger.info(
                    "[Render] U-097: 이미지 생성을 프론트엔드에 위임 (text-first delivery)",
                    extra={
                        "should_generate": True,
                        "model_override": image_decision.model_override,
                        "is_low_balance_fallback": image_decision.is_low_balance_fallback,
                    },
                )
        else:
            logger.debug("[Render] TurnOutput 없음, 이미지 판정 건너뜀")
    else:
        # 이미지 생성 서비스 미주입 - pass-through 동작
        logger.debug("[Render] 이미지 생성 서비스 미주입, pass-through 동작")

    # 모의 처리 지연 (기존 동작 보존)
    await asyncio.sleep(RENDER_DELAY_MS / 1000.0)

    # Stage 완료 이벤트
    await emit(
        PipelineEvent(
            event_type=PipelineEventType.STAGE_COMPLETE,
            phase=AgentPhase.RENDER,
        )
    )

    return ctx


def _adjust_economy_for_fallback(
    ctx: PipelineContext,
    image_decision: ImageGenerationDecision,
) -> PipelineContext:
    """잔액 부족 폴백 발생 시 경제 정보를 조정합니다.

    U-079: FAST 모델 폴백 시 비용을 0으로 조정하고 잔액을 보존합니다.
    또한 low_balance_warning을 활성화합니다.

    Args:
        ctx: 파이프라인 컨텍스트
        image_decision: 이미지 생성 판정 결과

    Returns:
        업데이트된 컨텍스트
    """
    if ctx.output is None:
        return ctx

    logger.info(
        "[Render] U-079: 경제 정보 조정 (FAST 폴백 적용)",
        extra={
            "original_cost": ctx.output.economy.cost.signal,
            "new_cost": image_decision.estimated_cost_signal,
        },
    )

    # 1. 비용 조정 (FAST_IMAGE_COST_SIGNAL = 0)
    new_cost = ctx.output.economy.cost.model_copy(
        update={"signal": image_decision.estimated_cost_signal}
    )

    # 2. 잔액 재계산 (snapshot - new_cost)
    # RULE-005 준수를 위해 balance_after를 다시 계산
    new_signal = max(0, ctx.economy_snapshot.signal - image_decision.estimated_cost_signal)
    new_shard = max(0, ctx.economy_snapshot.memory_shard - new_cost.memory_shard)

    new_balance = ctx.output.economy.balance_after.model_copy(
        update={"signal": new_signal, "memory_shard": new_shard}
    )

    # 3. EconomyOutput 업데이트
    new_economy = ctx.output.economy.model_copy(
        update={
            "cost": new_cost,
            "balance_after": new_balance,
            "low_balance_warning": True,
        }
    )

    ctx.output = ctx.output.model_copy(update={"economy": new_economy})

    return ctx
</file>

<file path="frontend/src/turn/turnRunner.ts">
/**
 * Unknown World - Turn Runner 모듈
 *
 * RU-003-Q3: Turn 실행/스트리밍 결합을 App.tsx에서 분리하여
 * "레이아웃 + 이벤트 라우팅"과 "오케스트레이션"을 명확히 분리합니다.
 *
 * 책임:
 *   - TurnInput 생성 (언어/클릭/드롭/클라이언트 정보/재화 스냅샷)
 *   - 스트림 시작/취소/콜백 라우팅
 *   - agentStore/worldStore로 이벤트 분배
 *
 * 설계 원칙:
 *   - RULE-002: 채팅 앱이 아닌 상태 기반 게임 시스템
 *   - RULE-003/004: 구조화 출력 + 검증/복구
 *   - RULE-006: ko/en i18n 정책 준수
 *
 * @module turn/turnRunner
 */

import { useCallback, useEffect, useRef } from 'react';
import type { TurnInput, DropInput, Language } from '../schemas/turn';
import type { HotspotClickData } from '../components/SceneCanvas';
import { startTurnStream, type StreamCallbacks } from '../api/turnStream';
import { startImageGeneration, type ImageModelLabel } from '../api/image';
import { useAgentStore } from '../stores/agentStore';
import { useWorldStore } from '../stores/worldStore';
import { selectImageSizing } from '../utils/imageSizing';

// =============================================================================
// U-089: 정밀분석(Agentic Vision) 트리거 감지 상수
// 백엔드 config/models.py VISION_TRIGGER_ACTION_IDS / VISION_TRIGGER_KEYWORDS와 동기화
// =============================================================================

const VISION_TRIGGER_ACTION_IDS = new Set([
  'deep_analyze',
  '정밀분석',
  'analyze_scene',
  'examine_scene',
  'look_closely',
]);

const VISION_TRIGGER_KEYWORDS = [
  '정밀분석',
  '장면 분석',
  '이미지 분석',
  '자세히 보기',
  'analyze scene',
  'deep analyze',
  'look closely',
  'examine scene',
];

/** U-089: 정밀분석 오버레이 최소 표시 시간 (ms) - 깜빡임 방지 */
const ANALYZING_MIN_DISPLAY_MS = 500;

// =============================================================================
// U-124: 사전 생성 이미지 → 백엔드 참조 URL 변환
// =============================================================================

/**
 * 프론트엔드 정적 씬 이미지 URL을 백엔드 참조 이미지 URL로 변환합니다.
 *
 * 표시용 `/ui/scenes/scene-xxx-start.webp` URL을
 * 백엔드 이미지 서비스가 인식하는 `/api/image/file/scene-xxx-start` 형식으로 변환합니다.
 * 이를 통해 첫 턴에서 사전 생성 이미지를 Gemini 참조 이미지로 전달하여
 * 시각적 연속성을 유지합니다.
 *
 * 런타임 생성 이미지 URL(/api/image/file/... 또는 http://...)은 그대로 반환합니다.
 */
function toBackendReferenceUrl(displayUrl: string | undefined | null): string | undefined {
  if (!displayUrl) return undefined;
  // /ui/scenes/scene-narrator-start.webp → /api/image/file/scene-narrator-start
  const match = displayUrl.match(/^\/ui\/scenes\/(.+)\.\w+$/);
  if (match) {
    return `/api/image/file/${match[1]}`;
  }
  return displayUrl;
}

/**
 * U-089: 정밀분석(Agentic Vision) 트리거 여부를 판단합니다.
 * 백엔드의 ModelConfig.is_vision_trigger()와 동일한 로직입니다.
 */
function isVisionTrigger(actionId?: string, text?: string): boolean {
  if (actionId && VISION_TRIGGER_ACTION_IDS.has(actionId)) return true;
  if (text) {
    const textLower = text.toLowerCase();
    for (const keyword of VISION_TRIGGER_KEYWORDS) {
      if (textLower.includes(keyword.toLowerCase())) return true;
    }
  }
  return false;
}

// =============================================================================
// 타입 정의
// =============================================================================

/** TurnInput 생성을 위한 파라미터 */
export interface BuildTurnInputParams {
  /** 사용자 입력 텍스트 */
  text: string;
  /** 액션 카드 ID (선택) */
  actionId?: string;
  /** 핫스팟 클릭 데이터 (U-010) */
  click?: HotspotClickData;
  /** 드롭 데이터 (U-012) */
  drop?: DropInput;
  /** 재화 스냅샷 */
  economySnapshot: { signal: number; memory_shard: number };
  /** UI 테마 */
  theme: 'dark' | 'light';
  /** U-044: 세션 언어 (외부 주입, SSOT) */
  language: Language;
  /** U-068: 이전 턴 이미지 URL (참조 이미지로 사용) */
  previousImageUrl?: string | null;
}

/** Turn 실행을 위한 파라미터 (App에서 호출 시 사용) */
export interface RunTurnParams {
  /** 사용자 입력 텍스트 */
  text: string;
  /** 액션 카드 ID (선택) */
  actionId?: string;
  /** 핫스팟 클릭 데이터 (U-010) */
  click?: HotspotClickData;
  /** 드롭 데이터 (U-012) */
  drop?: DropInput;
}

/** Turn Runner 인터페이스 */
export interface TurnRunner {
  /** 턴 실행 (스트림 시작) */
  runTurn: (params: RunTurnParams) => void;
  /** 스트림 취소 */
  cancel: () => void;
}

// =============================================================================
// TurnInput 생성
// =============================================================================

/**
 * TurnInput을 생성합니다.
 *
 * U-044: 언어는 외부에서 주입받아 SSOT 유지 (getResolvedLanguage() 직접 호출 제거).
 * 클릭, 드롭, 클라이언트 정보, 재화 스냅샷을 조합하여
 * 서버로 전송할 TurnInput을 생성합니다.
 */
export function buildTurnInput(params: BuildTurnInputParams): TurnInput {
  const { text, actionId, click, drop, economySnapshot, theme, language, previousImageUrl } =
    params;

  return {
    language,
    text,
    action_id: actionId ?? null,
    // U-010: 핫스팟 클릭 데이터 포함 (Q1: Option B)
    click: click
      ? {
          object_id: click.object_id,
          box_2d: click.box_2d,
        }
      : null,
    // U-012: 아이템 드롭 데이터 포함 (Q1: Option B - target_box_2d 포함)
    drop: drop ?? null,
    client: {
      viewport_w: window.innerWidth,
      viewport_h: window.innerHeight,
      theme,
    },
    economy_snapshot: economySnapshot,
    // U-068: 이전 턴 이미지 URL (참조 이미지로 사용하여 연속성 유지)
    previous_image_url: previousImageUrl ?? null,
  };
}

// =============================================================================
// Turn Runner 생성
// =============================================================================

/**
 * Turn Runner를 생성합니다.
 *
 * RU-003-Q3: App에서 Turn Runner 인스턴스를 생성하여 사용합니다.
 * U-044: 세션 언어를 외부에서 주입받아 TurnInput 생성 시 SSOT 유지.
 * 스트림 콜백은 agentStore와 worldStore로 라우팅됩니다.
 *
 * @param deps - 의존성 (i18n 번역 함수, 테마, 세션 언어)
 * @returns Turn Runner 인터페이스
 *
 * @example
 * ```tsx
 * // App.tsx에서 사용
 * const runner = useMemo(() => createTurnRunner({
 *   t,
 *   theme: 'dark',
 *   language: sessionLanguage, // U-044: 세션 언어 SSOT
 * }), [t, sessionLanguage]);
 *
 * runner.runTurn({ text: 'hello' });
 * ```
 */
export function createTurnRunner(deps: {
  /** i18n 번역 함수 */
  t: (key: string, options?: Record<string, unknown>) => string;
  /** UI 테마 */
  theme: 'dark' | 'light';
  /** U-044: 세션 언어 (SSOT) */
  language: Language;
}): TurnRunner {
  const { t, theme, language } = deps;

  // 취소 함수 저장
  let cancelFn: (() => void) | null = null;

  // U-066: 이미지 잡 AbortController
  let imageJobController: AbortController | null = null;

  // U-080: 이미지 생성 요청 중복 방지 (StrictMode 대응)
  let imageJobPending = false;

  // U-097: onFinal에서 보관한 이미지 잡 (onComplete에서 실행)
  let pendingImageJob: { should_generate: boolean; prompt: string; model_label?: string } | null =
    null;

  // U-089: 정밀분석 오버레이 최소 표시 시간 관리
  let analyzingStartTime = 0;

  /**
   * 턴을 실행합니다.
   */
  const runTurn = (params: RunTurnParams): void => {
    // 스트리밍 중이면 무시
    const isStreaming = useAgentStore.getState().isStreaming;
    if (isStreaming) return;

    // Store 액션 가져오기 (클로저 외부에서 호출 시점에 최신 상태 참조)
    const agentStore = useAgentStore.getState();
    const worldStore = useWorldStore.getState();

    // U-089: 정밀분석 트리거 감지
    const visionAnalysis = isVisionTrigger(params.actionId, params.text);

    /**
     * U-089: 분석 상태를 해제합니다.
     * 최소 표시 시간(500ms)을 보장하여 오버레이 깜빡임을 방지합니다.
     */
    const finishAnalyzing = () => {
      const elapsed = Date.now() - analyzingStartTime;
      const remaining = ANALYZING_MIN_DISPLAY_MS - elapsed;
      if (remaining > 0) {
        setTimeout(() => {
          useWorldStore.getState().setIsAnalyzing(false);
        }, remaining);
      } else {
        useWorldStore.getState().setIsAnalyzing(false);
      }
    };

    // 재화 스냅샷 가져오기
    // U-097: credit 필드는 EconomyOutput 전용이므로 입력 스냅샷에서 제외
    // (백엔드 EconomySnapshot은 extra="forbid"로 설정됨)
    const { signal, memory_shard } = worldStore.economy;
    const economySnapshot = { signal, memory_shard };

    // U-068: 이전 이미지 URL 가져오기 (참조 이미지로 사용)
    // U-124: 사전 생성 정적 이미지 URL을 백엔드 참조 형식으로 변환
    const previousImageUrl = toBackendReferenceUrl(
      worldStore.sceneState.imageUrl ?? worldStore.sceneState.previousImageUrl,
    );

    // TurnInput 생성 (U-044: 주입된 세션 언어 사용)
    const turnInput = buildTurnInput({
      text:
        params.text ||
        (params.actionId ? t('action.card_select', { cardId: params.actionId }) : ''),
      actionId: params.actionId,
      click: params.click,
      drop: params.drop,
      economySnapshot,
      theme,
      language,
      previousImageUrl,
    });

    // Agent Store 시작
    agentStore.startStream();

    // U-089: 정밀분석 시 isAnalyzing 활성화 (기존 이미지 유지 + 분석 오버레이)
    if (visionAnalysis) {
      worldStore.setIsAnalyzing(true);
      analyzingStartTime = Date.now();
    }

    // U-071: 처리 단계를 'processing'으로 전환
    worldStore.setProcessingPhase('processing');

    // U-089: 정밀분석 시 Scene 상태를 변경하지 않음 (기존 이미지 유지)
    // 일반 턴: Scene Canvas를 로딩 상태로 전환 (U-031)
    if (!visionAnalysis) {
      worldStore.setSceneState({ status: 'loading', message: t('scene.status.syncing') });
    }

    // 스트림 콜백 설정 (RU-003-Q3: agentStore + worldStore로 라우팅)
    // RU-003-T1: sceneState 전이는 worldStore.applyTurnOutput에서 SSOT로 처리
    const callbacks: StreamCallbacks = {
      // Stage/Badges/NarrativeDelta → agentStore로만 전달
      onStage: (event) => {
        useAgentStore.getState().handleStage(event);
      },
      onBadges: (event) => {
        useAgentStore.getState().handleBadges(event);
      },
      onNarrativeDelta: (event) => {
        useAgentStore.getState().handleNarrativeDelta(event);
      },
      // Final → agentStore.handleFinal + worldStore.applyTurnOutput
      // U-097: onFinal에서는 텍스트/상태만 반영. 이미지 생성은 onComplete 이후에 시작.
      //   스트리밍 순서: narrative_delta × N → final → (스트림 종료) → onComplete
      //   onComplete에서 narrativeBuffer 초기화 후, 이미지 생성을 별도 시작.
      //   이렇게 하면 사용자가 narrative_delta를 실시간으로 본 후, final로 entries에 확정,
      //   그 다음에 이미지 생성이 시작되므로 text-first delivery가 보장됨.
      onFinal: (event) => {
        // U-097: 이미지 잡 정보를 보관 (onComplete에서 사용)
        pendingImageJob = event.data.render?.image_job ?? null;

        useAgentStore.getState().handleFinal(event);
        // U-071: 결과 렌더링 단계로 전환
        useWorldStore.getState().setProcessingPhase('rendering');
        // RU-003-Q4: TurnOutput 반영 SSOT
        useWorldStore.getState().applyTurnOutput(event.data);
        // RU-003-S1: 성공적인 final 수신 시 연결 상태 낙관적 복구
        useWorldStore.getState().setConnected(true);
      },
      // Error → agentStore.handleError + worldStore 상태 복구
      onError: (event) => {
        useAgentStore.getState().handleError(event);

        // U-130: RATE_LIMITED 에러 시 scene/연결 상태 유지 (재시도 안내 UI만 표시)
        if (event.code === 'RATE_LIMITED') {
          useWorldStore.getState().setProcessingPhase('idle');
          if (visionAnalysis) {
            finishAnalyzing();
          }
          return;
        }

        useWorldStore.getState().setConnected(false);
        // U-071: 에러 시 idle로 전환
        useWorldStore.getState().setProcessingPhase('idle');
        // U-089: 에러 시 분석 상태 해제 (최소 표시 시간 적용)
        if (visionAnalysis) {
          finishAnalyzing();
        }
        // Scene Canvas를 오프라인/에러 상태로 전환 (U-031)
        const errorCode = event.code;
        if (errorCode === 'SAFETY_BLOCKED') {
          useWorldStore.getState().setSceneState({ status: 'blocked', message: event.message });
        } else if (errorCode === 'INSUFFICIENT_BALANCE') {
          useWorldStore.getState().setSceneState({ status: 'low_signal', message: event.message });
        } else {
          useWorldStore.getState().setSceneState({ status: 'offline', message: event.message });
        }
      },
      // Complete → U-097: 이미지 생성 시작 (text-first delivery)
      // 이 시점에서 narrative_delta 스트리밍이 모두 끝나고 final이 처리된 상태.
      // narrativeBuffer가 비워지고, entries에 텍스트가 확정된 이후에 이미지 생성을 시작한다.
      // U-087: 이미지 잡이 있으면 completeStream()을 이미지 완료까지 지연하여
      //   Agent Console 대기열에서 Render 단계가 "진행 중(◎)"으로 유지되도록 한다.
      onComplete: () => {
        // U-089: 턴 완료 시 분석 상태 해제 (최소 표시 시간 적용)
        if (visionAnalysis) {
          finishAnalyzing();
        }

        // U-097: 이미지 잡이 있으면 이 시점에서 비동기 생성 시작 (text-first delivery)
        const job = pendingImageJob;
        pendingImageJob = null;

        if (job?.should_generate && job.prompt) {
          // U-080: StrictMode 대응 - 중복 요청 방지
          if (imageJobPending) {
            useAgentStore.getState().completeStream();
            useWorldStore.getState().setProcessingPhase('idle');
            return;
          }
          imageJobPending = true;

          // U-087: Render 단계를 다시 in_progress로 설정 (이미지 렌더링 진행 표시)
          useAgentStore.getState().handleStage({
            type: 'stage',
            name: 'render',
            status: 'start',
          });

          // U-071: 이미지 생성 대기 단계로 전환
          useWorldStore.getState().setProcessingPhase('image_pending');

          const worldStore = useWorldStore.getState();
          const currentTurnId = worldStore.turnCount;

          // U-068: 이전 장면 이미지 URL 가져오기 (참조 이미지로 사용)
          // U-124: 사전 생성 정적 이미지 URL을 백엔드 참조 형식으로 변환
          const previousImageUrl = toBackendReferenceUrl(
            worldStore.sceneState.imageUrl ?? worldStore.sceneState.previousImageUrl,
          );

          // 이전 이미지 잡 취소
          imageJobController?.abort();

          // 이미지 로딩 상태로 전환
          worldStore.setImageLoading(currentTurnId);

          // 모델 라벨 결정
          const modelLabel: ImageModelLabel = job.model_label === 'FAST' ? 'FAST' : 'QUALITY';

          // U-085: Scene Canvas 크기 기반 aspect_ratio/image_size 선택
          const { width: cw, height: ch } = worldStore.sceneCanvasSize;
          const sizing = selectImageSizing(cw, ch);

          // 이미지 생성 시작
          imageJobController = startImageGeneration(
            {
              prompt: job.prompt,
              language,
              aspectRatio: sizing.aspectRatio,
              imageSize: sizing.imageSize,
              modelLabel,
              turnId: currentTurnId,
              referenceImageUrl: previousImageUrl,
            },
            (response) => {
              imageJobPending = false;
              if (response.success && response.imageUrl && response.turnId !== undefined) {
                useWorldStore.getState().applyLateBindingImage(response.imageUrl, response.turnId);
              } else {
                useWorldStore.getState().cancelImageLoading();
              }
              // U-087: Render 단계 완료 후 스트림 종료
              useAgentStore.getState().handleStage({
                type: 'stage',
                name: 'render',
                status: 'complete',
              });
              useAgentStore.getState().completeStream();
              useWorldStore.getState().setProcessingPhase('idle');
            },
            () => {
              imageJobPending = false;
              useWorldStore.getState().cancelImageLoading();
              // U-087: 이미지 생성 실패 시에도 Render 단계 완료 + 스트림 종료
              useAgentStore.getState().handleStage({
                type: 'stage',
                name: 'render',
                status: 'complete',
              });
              useAgentStore.getState().completeStream();
              useWorldStore.getState().setProcessingPhase('idle');
            },
          );
        } else {
          // 이미지 잡이 없으면 바로 스트림 종료 + idle
          useAgentStore.getState().completeStream();
          useWorldStore.getState().setProcessingPhase('idle');
        }
      },
    };

    // 스트림 시작
    cancelFn = startTurnStream(turnInput, callbacks);
  };

  /**
   * 스트림을 취소합니다.
   *
   * 추후 Cancel/Pause/Autopilot UX를 위한 기본 골격입니다.
   * 현재 executeTurnStream은 Abort 시 onComplete를 호출하지 않으므로,
   * Cancel 버튼을 넣을 계획이라면 "취소 시 UI 복구 정책"을 별도로 명시해야 합니다.
   */
  const cancel = (): void => {
    cancelFn?.();
    cancelFn = null;
  };

  return {
    runTurn,
    cancel,
  };
}

// =============================================================================
// React Hook (선택적 사용)
// =============================================================================

/**
 * Turn Runner를 React 컴포넌트에서 사용하기 위한 훅.
 *
 * U-044: 세션 언어를 외부에서 주입받아 TurnInput 생성 시 SSOT 유지.
 *
 * @param deps - 의존성 (i18n 번역 함수, 테마, 세션 언어)
 * @returns Turn Runner 인터페이스 및 취소 효과
 *
 * @example
 * ```tsx
 * // 컴포넌트에서 사용
 * const { runTurn, cancel } = useTurnRunner({
 *   t,
 *   theme: 'dark',
 *   language: sessionLanguage, // U-044: 세션 언어 SSOT
 * });
 * ```
 */

export function useTurnRunner(deps: {
  t: (key: string, options?: Record<string, unknown>) => string;
  theme: 'dark' | 'light';
  /** U-044: 세션 언어 (SSOT) */
  language: Language;
}): TurnRunner {
  const { t, theme, language } = deps;

  // 취소 함수 저장 ref
  const cancelFnRef = useRef<(() => void) | null>(null);

  // U-066: 이미지 잡 AbortController ref
  const imageJobControllerRef = useRef<AbortController | null>(null);

  // U-080: 이미지 생성 요청 중복 방지 (StrictMode 대응)
  const imageJobPendingRef = useRef<boolean>(false);

  // U-097: text-first delivery - 이미지 잡을 onFinal에서 보관, onComplete에서 실행
  const pendingImageJobRef = useRef<{
    should_generate: boolean;
    prompt: string;
    model_label?: string;
  } | null>(null);

  // U-089: 정밀분석 오버레이 최소 표시 시간 관리
  const analyzingStartTimeRef = useRef<number>(0);

  // runTurn을 useCallback으로 정의
  const runTurn = useCallback(
    (params: RunTurnParams): void => {
      // 스트리밍 중이면 무시
      const isStreaming = useAgentStore.getState().isStreaming;
      if (isStreaming) return;

      // Store 액션 가져오기
      const agentStore = useAgentStore.getState();
      const worldStore = useWorldStore.getState();

      // U-089: 정밀분석 트리거 감지
      const visionAnalysis = isVisionTrigger(params.actionId, params.text);

      /**
       * U-089: 분석 상태를 해제합니다.
       * 최소 표시 시간(500ms)을 보장하여 오버레이 깜빡임을 방지합니다.
       */
      const finishAnalyzing = () => {
        const elapsed = Date.now() - analyzingStartTimeRef.current;
        const remaining = ANALYZING_MIN_DISPLAY_MS - elapsed;
        if (remaining > 0) {
          setTimeout(() => {
            useWorldStore.getState().setIsAnalyzing(false);
          }, remaining);
        } else {
          useWorldStore.getState().setIsAnalyzing(false);
        }
      };

      // 재화 스냅샷 가져오기
      // U-097: credit 필드는 EconomyOutput 전용이므로 입력 스냅샷에서 제외
      // (백엔드 EconomySnapshot은 extra="forbid"로 설정됨)
      const { signal, memory_shard } = worldStore.economy;
      const economySnapshot = { signal, memory_shard };

      // U-068: 이전 이미지 URL 가져오기 (참조 이미지로 사용)
      // U-124: 사전 생성 정적 이미지 URL을 백엔드 참조 형식으로 변환
      const previousImageUrl = toBackendReferenceUrl(
        worldStore.sceneState.imageUrl ?? worldStore.sceneState.previousImageUrl,
      );

      // TurnInput 생성 (U-044: 주입된 세션 언어 사용)
      const turnInput = buildTurnInput({
        text:
          params.text ||
          (params.actionId ? t('action.card_select', { cardId: params.actionId }) : ''),
        actionId: params.actionId,
        click: params.click,
        drop: params.drop,
        economySnapshot,
        theme,
        language,
        previousImageUrl,
      });

      // Agent Store 시작
      agentStore.startStream();

      // U-089: 정밀분석 시 isAnalyzing 활성화 (기존 이미지 유지 + 분석 오버레이)
      if (visionAnalysis) {
        worldStore.setIsAnalyzing(true);
        analyzingStartTimeRef.current = Date.now();
      }

      // U-071: 처리 단계를 'processing'으로 전환
      worldStore.setProcessingPhase('processing');

      // U-089: 정밀분석 시 Scene 상태를 변경하지 않음 (기존 이미지 유지)
      // 일반 턴: Scene Canvas를 로딩 상태로 전환 (U-031)
      if (!visionAnalysis) {
        worldStore.setSceneState({ status: 'loading', message: t('scene.status.syncing') });
      }

      // 스트림 콜백 설정 (RU-003-Q3: agentStore + worldStore로 라우팅)
      // RU-003-T1: sceneState 전이는 worldStore.applyTurnOutput에서 SSOT로 처리
      const callbacks: StreamCallbacks = {
        onStage: (event) => {
          useAgentStore.getState().handleStage(event);
        },
        onBadges: (event) => {
          useAgentStore.getState().handleBadges(event);
        },
        onNarrativeDelta: (event) => {
          useAgentStore.getState().handleNarrativeDelta(event);
        },
        // U-097: onFinal에서는 텍스트/상태만 반영. 이미지 생성은 onComplete에서 시작.
        onFinal: (event) => {
          pendingImageJobRef.current = event.data.render?.image_job ?? null;

          useAgentStore.getState().handleFinal(event);
          useWorldStore.getState().setProcessingPhase('rendering');
          useWorldStore.getState().applyTurnOutput(event.data);
          useWorldStore.getState().setConnected(true);
        },
        onError: (event) => {
          useAgentStore.getState().handleError(event);

          // U-130: RATE_LIMITED 에러 시 scene/연결 상태 유지 (재시도 안내 UI만 표시)
          if (event.code === 'RATE_LIMITED') {
            useWorldStore.getState().setProcessingPhase('idle');
            if (visionAnalysis) {
              finishAnalyzing();
            }
            return;
          }

          useWorldStore.getState().setConnected(false);
          useWorldStore.getState().setProcessingPhase('idle');
          if (visionAnalysis) {
            finishAnalyzing();
          }
          const errorCode = event.code;
          if (errorCode === 'SAFETY_BLOCKED') {
            useWorldStore.getState().setSceneState({ status: 'blocked', message: event.message });
          } else if (errorCode === 'INSUFFICIENT_BALANCE') {
            useWorldStore
              .getState()
              .setSceneState({ status: 'low_signal', message: event.message });
          } else {
            useWorldStore.getState().setSceneState({ status: 'offline', message: event.message });
          }
        },
        // U-097: onComplete에서 이미지 생성 시작 (text-first delivery)
        // 이 시점에서 narrative_delta 스트리밍 + final 처리가 모두 완료된 상태.
        // U-087: 이미지 잡이 있으면 completeStream()을 이미지 완료까지 지연하여
        //   Agent Console 대기열에서 Render 단계가 "진행 중(◎)"으로 유지되도록 한다.
        onComplete: () => {
          if (visionAnalysis) {
            finishAnalyzing();
          }

          // U-097: 이미지 잡이 있으면 이 시점에서 비동기 생성 시작
          const job = pendingImageJobRef.current;
          pendingImageJobRef.current = null;

          if (job?.should_generate && job.prompt) {
            if (imageJobPendingRef.current) {
              useAgentStore.getState().completeStream();
              useWorldStore.getState().setProcessingPhase('idle');
              return;
            }
            imageJobPendingRef.current = true;

            // U-087: Render 단계를 다시 in_progress로 설정 (이미지 렌더링 진행 표시)
            useAgentStore.getState().handleStage({
              type: 'stage',
              name: 'render',
              status: 'start',
            });

            useWorldStore.getState().setProcessingPhase('image_pending');

            const worldStore = useWorldStore.getState();
            const currentTurnId = worldStore.turnCount;
            // U-124: 사전 생성 정적 이미지 URL을 백엔드 참조 형식으로 변환
            const previousImageUrl = toBackendReferenceUrl(
              worldStore.sceneState.imageUrl ?? worldStore.sceneState.previousImageUrl,
            );

            imageJobControllerRef.current?.abort();
            worldStore.setImageLoading(currentTurnId);

            const modelLabel: ImageModelLabel = job.model_label === 'FAST' ? 'FAST' : 'QUALITY';
            const { width: cw, height: ch } = worldStore.sceneCanvasSize;
            const sizing = selectImageSizing(cw, ch);

            imageJobControllerRef.current = startImageGeneration(
              {
                prompt: job.prompt,
                language,
                aspectRatio: sizing.aspectRatio,
                imageSize: sizing.imageSize,
                modelLabel,
                turnId: currentTurnId,
                referenceImageUrl: previousImageUrl,
              },
              (response) => {
                imageJobPendingRef.current = false;
                if (response.success && response.imageUrl && response.turnId !== undefined) {
                  useWorldStore
                    .getState()
                    .applyLateBindingImage(response.imageUrl, response.turnId);
                } else {
                  useWorldStore.getState().cancelImageLoading();
                }
                // U-087: Render 단계 완료 후 스트림 종료
                useAgentStore.getState().handleStage({
                  type: 'stage',
                  name: 'render',
                  status: 'complete',
                });
                useAgentStore.getState().completeStream();
                useWorldStore.getState().setProcessingPhase('idle');
              },
              () => {
                imageJobPendingRef.current = false;
                useWorldStore.getState().cancelImageLoading();
                // U-087: 이미지 생성 실패 시에도 Render 단계 완료 + 스트림 종료
                useAgentStore.getState().handleStage({
                  type: 'stage',
                  name: 'render',
                  status: 'complete',
                });
                useAgentStore.getState().completeStream();
                useWorldStore.getState().setProcessingPhase('idle');
              },
            );
          } else {
            // 이미지 잡이 없으면 바로 스트림 종료 + idle
            useAgentStore.getState().completeStream();
            useWorldStore.getState().setProcessingPhase('idle');
          }
        },
      };

      // 스트림 시작 및 취소 함수 저장
      cancelFnRef.current = startTurnStream(turnInput, callbacks);
    },
    [t, theme, language],
  );

  // cancel 함수
  const cancel = useCallback((): void => {
    cancelFnRef.current?.();
    cancelFnRef.current = null;
  }, []);

  // 컴포넌트 언마운트 시 스트림 및 이미지 잡 취소
  useEffect(() => {
    return () => {
      cancelFnRef.current?.();
      imageJobControllerRef.current?.abort();
    };
  }, []);

  return { runTurn, cancel };
}
</file>

<file path="frontend/src/schemas/turn.ts">
/**
 * Unknown World - TurnInput/TurnOutput Zod 스키마.
 *
 * 이 모듈은 백엔드 Pydantic 모델(U-005)과 1:1 대응하는 Zod 스키마를 정의합니다.
 * 클라이언트 측 검증 및 타입 안전성을 제공합니다.
 *
 * 설계 원칙:
 *   - RULE-003: 구조화 출력(JSON Schema) 우선 + 이중 검증 (서버 Pydantic + 클라 Zod)
 *   - RULE-004: 검증 실패 시 안전 폴백 제공 (UI 멈춤 방지)
 *   - RULE-005: 재화 인바리언트 (cost, balance_after 필수, 잔액 음수 금지)
 *   - RULE-006: ko/en 언어 정책 (Language enum으로 고정)
 *   - RULE-009: 좌표 규약 (0~1000, bbox [ymin,xmin,ymax,xmax])
 *
 * Q1 결정 사항:
 *   - schema_version 포함 (Option A): SaveGame/마이그레이션/검증에 유리
 *
 * @module schemas/turn
 */

import { z } from 'zod';

// =============================================================================
// 스키마 버전 (Q1 결정: Option A - 포함)
// =============================================================================

/**
 * 현재 스키마 버전.
 * SaveGame/마이그레이션/검증에 사용됩니다.
 */
export const SCHEMA_VERSION = '1.0.0' as const;

// =============================================================================
// 공통 Enum 타입
// =============================================================================

/**
 * 지원 언어 (RULE-006).
 * ko/en 혼합 출력 금지. TurnInput.language를 SSOT로 삼아
 * 모든 UI/내러티브/시스템 메시지는 동일 언어로 고정합니다.
 */
export const LanguageSchema = z.enum(['ko-KR', 'en-US']);
export type Language = z.infer<typeof LanguageSchema>;

/**
 * 테마 설정.
 */
export const ThemeSchema = z.enum(['dark', 'light']);
export type Theme = z.infer<typeof ThemeSchema>;

/**
 * 에이전트 실행 단계 (RULE-008).
 * 에이전트형 시스템임을 UI로 증명하기 위한 단계 표시.
 */
export const AgentPhaseSchema = z.enum([
  'parse',
  'validate',
  'plan',
  'resolve',
  'render',
  'verify',
  'commit',
]);
export type AgentPhase = z.infer<typeof AgentPhaseSchema>;

/**
 * 검증 배지 (RULE-008).
 * 턴 결과에 대한 검증 상태를 표시합니다.
 */
export const ValidationBadgeSchema = z.enum([
  'schema_ok',
  'schema_fail',
  'economy_ok',
  'economy_fail',
  'safety_ok',
  'safety_blocked',
  'consistency_ok',
  'consistency_fail',
]);
export type ValidationBadge = z.infer<typeof ValidationBadgeSchema>;

/**
 * 모델/품질 선택 라벨 (RULE-008).
 * 프롬프트 노출 없이 "왜 이 선택이었는지"를 사용자 친화 라벨로 표시.
 */
export const ModelLabelSchema = z.enum(['FAST', 'QUALITY', 'CHEAP', 'REF']);
export type ModelLabel = z.infer<typeof ModelLabelSchema>;

/**
 * 행동 위험도 수준.
 */
export const RiskLevelSchema = z.enum(['low', 'medium', 'high']);
export type RiskLevel = z.infer<typeof RiskLevelSchema>;

// =============================================================================
// 공통 하위 타입
// =============================================================================

/**
 * 정규화 좌표 (RULE-009).
 * 0~1000 범위의 정수입니다.
 */
export const CoordinateSchema = z.number().int().min(0).max(1000).describe('정규화 좌표 (0~1000)');
export type Coordinate = z.infer<typeof CoordinateSchema>;

/**
 * 2D 바운딩 박스 (RULE-009).
 * 좌표는 0~1000 정규화 좌표계이며, bbox는 [ymin, xmin, ymax, xmax] 순서입니다.
 * 이미지 이해 bbox 포맷과 호환됩니다.
 */
export const Box2DSchema = z
  .object({
    ymin: CoordinateSchema.describe('Y 최소값 (상단)'),
    xmin: CoordinateSchema.describe('X 최소값 (좌측)'),
    ymax: CoordinateSchema.describe('Y 최대값 (하단)'),
    xmax: CoordinateSchema.describe('X 최대값 (우측)'),
  })
  .strict();
export type Box2D = z.infer<typeof Box2DSchema>;

/**
 * 재화 수량.
 * signal과 memory_shard는 0 이상이어야 합니다 (RULE-005).
 */
export const CurrencyAmountSchema = z
  .object({
    signal: z.number().int().min(0).describe('시그널 (기본 재화, 0 이상)'),
    memory_shard: z.number().int().min(0).describe('기억 파편 (희귀 재화, 0 이상)'),
  })
  .strict();
export type CurrencyAmount = z.infer<typeof CurrencyAmountSchema>;

// =============================================================================
// TurnInput 관련 타입
// =============================================================================

/**
 * 클릭 입력 정보.
 * 화면 오브젝트 클릭 시 전달되는 정보입니다.
 */
export const ClickInputSchema = z
  .object({
    object_id: z.string().describe('클릭한 오브젝트 ID'),
    box_2d: Box2DSchema.nullable().default(null).describe('클릭 위치 바운딩 박스 (선택)'),
  })
  .strict();
export type ClickInput = z.infer<typeof ClickInputSchema>;

/**
 * 드롭 입력 정보 (U-012).
 * 인벤토리 아이템을 핫스팟에 드롭할 때 전달되는 정보입니다.
 * Q1 결정: Option B - target_box_2d 포함하여 서버가 정확한 위치 해석 가능.
 */
export const DropInputSchema = z
  .object({
    item_id: z.string().describe('드롭한 인벤토리 아이템 ID'),
    target_object_id: z.string().describe('드롭 대상 핫스팟 오브젝트 ID'),
    target_box_2d: Box2DSchema.describe('드롭 대상의 바운딩 박스 (0~1000 정규화)'),
  })
  .strict();
export type DropInput = z.infer<typeof DropInputSchema>;

/**
 * 클라이언트 정보.
 */
export const ClientInfoSchema = z
  .object({
    viewport_w: z.number().int().positive().describe('뷰포트 너비 (픽셀, 양수)'),
    viewport_h: z.number().int().positive().describe('뷰포트 높이 (픽셀, 양수)'),
    theme: ThemeSchema.default('dark').describe('현재 테마'),
  })
  .strict();
export type ClientInfo = z.infer<typeof ClientInfoSchema>;

/**
 * 재화 스냅샷 (클라이언트 → 서버).
 * 클라이언트가 보유한 현재 재화 상태입니다.
 */
export const EconomySnapshotSchema = z
  .object({
    signal: z.number().int().min(0).describe('현재 시그널 잔액 (0 이상)'),
    memory_shard: z.number().int().min(0).describe('현재 기억 파편 잔액 (0 이상)'),
  })
  .strict();
export type EconomySnapshot = z.infer<typeof EconomySnapshotSchema>;

/**
 * 턴 입력 (클라이언트 → 서버).
 * 사용자가 턴을 진행할 때 서버로 전송하는 입력 데이터입니다.
 *
 * U-012: drop 필드 추가 - 인벤토리 아이템을 핫스팟에 드롭할 때 사용.
 */
export const TurnInputSchema = z
  .object({
    language: LanguageSchema.describe('요청 언어 (응답도 동일 언어로 고정)'),
    text: z.string().default('').describe('사용자 자연어 입력'),
    action_id: z.string().nullable().default(null).describe('선택한 액션 카드 ID (선택)'),
    click: ClickInputSchema.nullable().default(null).describe('오브젝트 클릭 정보 (선택)'),
    drop: DropInputSchema.nullable().default(null).describe('아이템 드롭 정보 (선택, U-012)'),
    client: ClientInfoSchema.describe('클라이언트 환경 정보'),
    economy_snapshot: EconomySnapshotSchema.describe('현재 재화 상태'),
    previous_image_url: z
      .string()
      .nullable()
      .default(null)
      .describe('이전 턴 이미지 URL (U-068: 참조 이미지로 사용하여 연속성 유지)'),
  })
  .strict();
export type TurnInput = z.infer<typeof TurnInputSchema>;

// =============================================================================
// TurnOutput 관련 타입 - UI
// =============================================================================

/**
 * 비용 추정치 (U-009: 최소/최대 범위).
 * 행동의 예상 비용 범위를 표시합니다.
 */
export const CostEstimateSchema = z
  .object({
    min: CurrencyAmountSchema.describe('최소 예상 비용'),
    max: CurrencyAmountSchema.describe('최대 예상 비용'),
  })
  .strict();
export type CostEstimate = z.infer<typeof CostEstimateSchema>;

/**
 * 액션 카드 (Action Deck) - U-065 단순화.
 * 매 턴 AI가 추천하는 행동 카드입니다.
 *
 * U-065 단순화:
 *   - 제거된 필드: description, cost_estimate, hint, reward_hint, disabled_reason
 *   - risk, is_alternative는 유지 (게임 메카닉에 필수)
 *   - 제거된 정보는 narrative에서 자연어로 표현
 */
export const ActionCardSchema = z
  .object({
    id: z.string().describe('카드 고유 ID'),
    label: z.string().describe('카드 라벨 (표시용)'),
    cost: CurrencyAmountSchema.describe('예상 비용 (기본)'),
    risk: RiskLevelSchema.default('low').describe('위험도'),
    enabled: z.boolean().default(true).describe('실행 가능 여부 (서버 판단)'),
    is_alternative: z.boolean().default(false).describe('저비용 대안 카드 여부'),
  })
  .strict();
export type ActionCard = z.infer<typeof ActionCardSchema>;

/**
 * 장면 오브젝트 (클릭 가능한 핫스팟).
 * 좌표는 0~1000 정규화 좌표계를 사용합니다 (RULE-009).
 */
export const SceneObjectSchema = z
  .object({
    id: z.string().describe('오브젝트 고유 ID'),
    label: z.string().describe('오브젝트 라벨 (표시용)'),
    box_2d: Box2DSchema.describe('바운딩 박스'),
    interaction_hint: z.string().nullable().default(null).describe('상호작용 힌트 (선택)'),
  })
  .strict();
export type SceneObject = z.infer<typeof SceneObjectSchema>;

/**
 * 액션 덱 (Q1 결정: ui.action_deck.cards[] 구조) - U-065 단순화.
 * 매 턴 AI가 제시하는 추천 행동 카드 덱입니다.
 *
 * U-065 단순화:
 *   - max_length: 10 → 5 (Gemini 스키마 제한 대응, Q2 결정)
 */
export const ActionDeckSchema = z
  .object({
    cards: z.array(ActionCardSchema).max(5).default([]).describe('액션 카드 목록 (3~5장 권장)'),
  })
  .strict();
export type ActionDeck = z.infer<typeof ActionDeckSchema>;

/**
 * Scene 표시 정보 (RU-003-T1: Scene 이미지 SSOT).
 *
 * TurnOutput에서 Scene Canvas에 표시할 이미지 정보를 제공합니다.
 * image_url이 존재하면 SceneCanvas는 'scene' 상태로 전환됩니다.
 * image_url이 없으면 'default' 상태를 유지합니다.
 */
export const SceneOutputSchema = z
  .object({
    image_url: z
      .string()
      .nullable()
      .default(null)
      .describe('Scene 이미지 URL (존재 시 scene 상태로 전환)'),
    alt_text: z.string().nullable().default(null).describe('이미지 대체 텍스트 (접근성용, 선택)'),
  })
  .strict();
export type SceneOutput = z.infer<typeof SceneOutputSchema>;

/**
 * Scene 기본값 (null 대응).
 */
const DEFAULT_SCENE_OUTPUT: SceneOutput = { image_url: null, alt_text: null };

/**
 * UI 출력 데이터 - U-065 단순화.
 * AI가 생성한 UI 요소들입니다.
 * 채팅 버블이 아닌 게임 UI로 표현됩니다 (RULE-002).
 *
 * RU-003-T1: scene 필드 추가 - Scene Canvas의 이미지 표시 정보 SSOT.
 * U-065 단순화: objects 배열 크기 제한 (최대 5개, Q2 결정)
 *
 * 수정: scene 필드는 백엔드에서 null로 올 수 있으므로 nullish()를 사용하여
 * null/undefined 시 기본값으로 변환합니다.
 */
export const UIOutputSchema = z
  .object({
    action_deck: ActionDeckSchema.default({ cards: [] }).describe('액션 카드 덱'),
    objects: z
      .array(SceneObjectSchema)
      .max(5)
      .default([])
      .describe('클릭 가능한 장면 오브젝트 목록 (최대 5개)'),
    scene: SceneOutputSchema.nullish()
      .transform((val) => val ?? DEFAULT_SCENE_OUTPUT)
      .describe('Scene 표시 정보 (RU-003-T1, null 허용)'),
  })
  .strict();
export type UIOutput = z.infer<typeof UIOutputSchema>;

// =============================================================================
// TurnOutput 관련 타입 - World
// =============================================================================

/**
 * 중요 설정 고정 후보.
 * 사용자가 Memory Shard를 소비해 고정할 수 있는 중요 설정입니다.
 */
export const MemoryPinSchema = z
  .object({
    id: z.string().describe('핀 고유 ID'),
    content: z.string().describe('고정할 내용'),
    cost: CurrencyAmountSchema.describe('고정에 필요한 비용'),
  })
  .strict();
export type MemoryPin = z.infer<typeof MemoryPinSchema>;

/**
 * 세계 규칙 (Rule Board).
 * 현재 세계에 적용 중인 물리 법칙이나 메타 규칙입니다.
 */
export const WorldRuleSchema = z
  .object({
    id: z.string().describe('규칙 고유 ID'),
    label: z.string().describe('규칙 이름'),
    description: z.string().nullable().default(null).describe('규칙 상세 설명 (선택)'),
  })
  .strict();
export type WorldRule = z.infer<typeof WorldRuleSchema>;

/**
 * 퀘스트/목표 (Quest Panel) - U-078 목표 시스템 강화.
 * 플레이어가 달성해야 하는 현재 목표입니다.
 * is_main=true인 퀘스트가 주 목표(Main Objective)로 Quest 패널 상단에 강조 표시됩니다.
 */
export const QuestSchema = z
  .object({
    id: z.string().describe('퀘스트 고유 ID'),
    label: z.string().describe('퀘스트 이름'),
    is_completed: z.boolean().default(false).describe('달성 여부'),
    description: z.string().nullable().default(null).describe('목표 상세 설명 (선택)'),
    is_main: z.boolean().default(false).describe('주 목표 여부'),
    progress: z.number().int().min(0).max(100).default(0).describe('진행률 (0~100)'),
    reward_signal: z.number().int().min(0).default(0).describe('달성 시 Signal 보상량'),
  })
  .strict();
export type Quest = z.infer<typeof QuestSchema>;

/**
 * 인벤토리 아이템 데이터 (U-075[Mvp]).
 * TurnOutput에서 추가되는 아이템의 상세 정보입니다.
 */
export const InventoryItemDataSchema = z
  .object({
    id: z.string().describe('아이템 고유 ID'),
    label: z.string().describe('아이템 표시 이름 (현재 언어에 맞게)'),
    description: z.string().default('').describe('아이템 설명 (아이콘 생성용)'),
    icon_url: z.string().nullable().default(null).describe('아이콘 URL (선택, 캐시된 경우)'),
    quantity: z.number().int().min(1).default(1).describe('아이템 수량'),
  })
  .strict();
export type InventoryItemData = z.infer<typeof InventoryItemDataSchema>;

/**
 * 세계 상태 변화 (Q2 결정: Option A - delta 중심) - U-065 단순화.
 * 이번 턴에서 변경된 세계 상태를 나타냅니다.
 *
 * U-065 단순화 (Q3 결정: Option A):
 *   - rules_changed, quests_updated → 배열 크기 제한 (최대 3개)
 *   - memory_pins → 배열 크기 제한 (최대 2개)
 *   - 상세 정보는 narrative에서 자연어로 표현
 */
export const WorldDeltaSchema = z
  .object({
    rules_changed: z
      .array(WorldRuleSchema)
      .max(3)
      .default([])
      .describe('변경된 규칙 목록 (최대 3개)'),
    inventory_added: z
      .array(InventoryItemDataSchema)
      .max(5)
      .default([])
      .describe('추가된 인벤토리 아이템 (최대 5개)'),
    inventory_removed: z
      .array(z.string())
      .max(5)
      .default([])
      .describe('제거된 인벤토리 아이템 (최대 5개)'),
    quests_updated: z
      .array(QuestSchema)
      .max(3)
      .default([])
      .describe('업데이트된 퀘스트/목표 목록 (최대 3개)'),
    relationships_changed: z
      .array(z.string())
      .max(3)
      .default([])
      .describe('변경된 관계 (최대 3개)'),
    memory_pins: z
      .array(MemoryPinSchema)
      .max(2)
      .default([])
      .describe('중요 설정 고정 후보 (최대 2개)'),
  })
  .strict();
export type WorldDelta = z.infer<typeof WorldDeltaSchema>;

// =============================================================================
// TurnOutput 관련 타입 - Render
// =============================================================================

/**
 * 이미지 생성 작업 - U-065 단순화.
 * 조건부 이미지 생성/편집 요청입니다.
 *
 * U-065 단순화: reference_image_ids 배열 크기 제한 (최대 2개)
 * U-091: rembg 런타임 제거 - remove_background, image_type_hint 필드 삭제
 */
export const ImageJobSchema = z
  .object({
    should_generate: z.boolean().describe('이미지를 생성해야 하는지'),
    prompt: z.string().default('').describe('이미지 생성 프롬프트'),
    model_label: ModelLabelSchema.default('FAST').describe('모델 선택 라벨'),
    aspect_ratio: z.string().default('16:9').describe('가로세로 비율'),
    image_size: z.string().default('1024x1024').describe('이미지 크기'),
    reference_image_ids: z
      .array(z.string())
      .max(2)
      .default([])
      .describe('참조 이미지 ID 목록 (최대 2개)'),
    reference_image_url: z
      .string()
      .nullable()
      .default(null)
      .describe('참조 이미지 URL (선택, AI 모델 응답 호환용)'),
  })
  .strict();
export type ImageJob = z.infer<typeof ImageJobSchema>;

/**
 * 렌더링 출력 데이터.
 * 이미지 생성/편집 관련 정보입니다.
 *
 * U-053: image_url, image_id, generation_time_ms 필드 추가 (후처리에서 채움)
 * U-091: rembg 런타임 제거 - background_removed 필드 삭제
 */
export const RenderOutputSchema = z
  .object({
    image_job: ImageJobSchema.nullable().default(null).describe('이미지 생성 작업 (선택)'),
    image_url: z
      .string()
      .nullable()
      .default(null)
      .describe('생성된 이미지 URL (후처리에서 채움, U-053)'),
    image_id: z
      .string()
      .nullable()
      .default(null)
      .describe('생성된 이미지 ID (후처리에서 채움, U-053)'),
    generation_time_ms: z
      .number()
      .int()
      .nullable()
      .default(null)
      .describe('이미지 생성 소요 시간 (ms, U-053)'),
  })
  .strict();
export type RenderOutput = z.infer<typeof RenderOutputSchema>;

// =============================================================================
// TurnOutput 관련 타입 - Economy
// =============================================================================

/**
 * 거래 장부(Ledger) 엔트리 (RULE-005).
 * 각 턴에서 발생한 비용과 잔액 변화를 기록합니다.
 */
export const LedgerEntrySchema = z
  .object({
    turnId: z.number().int().min(0).describe('턴 ID'),
    actionId: z.string().optional().describe('액션 ID (선택)'),
    reason: z.string().describe('비용 발생 사유'),
    cost: CurrencyAmountSchema.describe('소비된 비용'),
    balanceAfter: CurrencyAmountSchema.describe('소비 후 잔액'),
    modelLabel: ModelLabelSchema.optional().describe('모델 라벨 (선택)'),
    timestamp: z.number().describe('기록 시각 (timestamp)'),
  })
  .strict();
export type LedgerEntry = z.infer<typeof LedgerEntrySchema>;

/**
 * 경제 출력 데이터 (RULE-005).
 * 이번 턴의 비용과 잔액 정보입니다.
 * 잔액 음수는 절대 불가 (서버 Hard gate).
 */
export const EconomyOutputSchema = z
  .object({
    cost: CurrencyAmountSchema.describe('이번 턴에 소비된 비용'),
    balance_after: CurrencyAmountSchema.describe('소비 후 잔액'),
    credit: z.number().int().default(0).describe('사용 중인 크레딧 (빚, Signal 단위)'),
    low_balance_warning: z.boolean().default(false).describe('잔액 부족 경고 여부'),
  })
  .strict();
export type EconomyOutput = z.infer<typeof EconomyOutputSchema>;

// =============================================================================
// TurnOutput 관련 타입 - Safety
// =============================================================================

/**
 * 안전 출력 데이터.
 * 안전 정책 관련 정보입니다.
 * 차단 시 명시적 메시지와 함께 안전한 대체 결과를 제공합니다.
 */
export const SafetyOutputSchema = z
  .object({
    blocked: z.boolean().default(false).describe('안전 정책에 의해 차단되었는지'),
    message: z
      .string()
      .nullable()
      .default(null)
      .describe('차단 시 사용자에게 표시할 메시지 (선택)'),
  })
  .strict();
export type SafetyOutput = z.infer<typeof SafetyOutputSchema>;

// =============================================================================
// TurnOutput 관련 타입 - Agent Console
// =============================================================================

/**
 * 에이전트 콘솔 데이터 (RULE-008) - U-065 단순화.
 * 에이전트형 시스템임을 UI로 증명하기 위한 정보입니다.
 *
 * U-065 단순화: badges 배열 크기 제한 (최대 4개)
 * U-069: model_label 필드 추가 - 현재 사용 중인 텍스트 모델 표시
 */
export const AgentConsoleSchema = z
  .object({
    current_phase: AgentPhaseSchema.default('commit').describe('현재 실행 단계'),
    badges: z.array(ValidationBadgeSchema).max(4).default([]).describe('검증 배지 목록 (최대 4개)'),
    repair_count: z.number().int().min(0).default(0).describe('자동 복구 시도 횟수'),
    model_label: ModelLabelSchema.default('FAST').describe(
      '현재 사용 중인 텍스트 모델 라벨 (U-069)',
    ),
  })
  .strict();
export type AgentConsole = z.infer<typeof AgentConsoleSchema>;

// =============================================================================
// TurnOutput (메인 응답 스키마)
// =============================================================================

/**
 * 턴 출력 (서버 → 클라이언트).
 * 서버가 턴 처리 후 클라이언트로 반환하는 구조화된 응답입니다.
 *
 * Hard Gate 필드 (RULE-003/004/005):
 *   - economy: cost와 balance_after 필수, 잔액 음수 금지
 *   - safety: blocked 시 안전한 대체 결과 제공
 *   - language: 요청 언어와 동일하게 고정 (혼합 출력 금지)
 */
export const TurnOutputSchema = z
  .object({
    // 필수 필드 (Hard Gate)
    language: LanguageSchema.describe('응답 언어 (요청과 동일)'),
    narrative: z.string().describe('내러티브 텍스트 (표시용)'),
    economy: EconomyOutputSchema.describe('경제 정보 (비용, 잔액)'),
    safety: SafetyOutputSchema.describe('안전 정책 정보'),

    // UI 관련 필드 (RU-003-T1: scene 필드 추가)
    ui: UIOutputSchema.default({
      action_deck: { cards: [] },
      objects: [],
      scene: { image_url: null, alt_text: null },
    }).describe('UI 요소'),

    // 세계 상태 필드
    world: WorldDeltaSchema.default({
      rules_changed: [],
      inventory_added: [],
      inventory_removed: [],
      quests_updated: [],
      relationships_changed: [],
      memory_pins: [],
    }).describe('세계 상태 변화 (delta)'),

    // 렌더링 필드
    render: RenderOutputSchema.default({
      image_job: null,
      image_url: null,
      image_id: null,
      generation_time_ms: null,
    }).describe('렌더링 정보'),

    // 에이전트 콘솔 필드
    agent_console: AgentConsoleSchema.default({
      current_phase: 'commit',
      badges: [],
      repair_count: 0,
      model_label: 'FAST',
    }).describe('에이전트 실행 정보'),

    // U-072: 세션 유도를 위한 힌트 필드 (선택)
    hints: z
      .object({
        scanner: z.boolean().optional().describe('Scanner 사용 유도 힌트 여부'),
      })
      .optional()
      .describe('플레이 유도를 위한 힌트 플래그'),
  })
  .strict();
export type TurnOutput = z.infer<typeof TurnOutputSchema>;

// =============================================================================
// 안전 폴백 (RULE-004)
// =============================================================================

/**
 * 검증 실패 시 제공되는 안전 폴백 TurnOutput.
 * UI가 멈추지 않도록 최소한의 정보를 제공합니다.
 *
 * U-063: 폴백에서도 재화 잔액을 유지하도록 economySnapshot 파라미터 추가.
 * RULE-005: 재화 인바리언트 - 폴백 시에도 잔액이 0으로 초기화되지 않아야 함.
 *
 * @param language - 요청 언어
 * @param repairCount - 복구 시도 횟수
 * @param errorMessage - 오류 메시지 (선택)
 * @param economySnapshot - 현재 재화 스냅샷 (선택, 제공 시 잔액 유지)
 */
export function createFallbackTurnOutput(
  language: Language,
  repairCount: number = 0,
  errorMessage?: string,
  economySnapshot?: { signal: number; memory_shard: number },
): TurnOutput {
  const fallbackNarrative =
    language === 'ko-KR'
      ? '[시스템] 응답을 처리하는 중 문제가 발생했습니다. 다시 시도해 주세요.'
      : '[System] An error occurred while processing the response. Please try again.';

  const safetyMessage =
    language === 'ko-KR'
      ? '스키마 검증 실패로 인한 폴백 응답입니다.'
      : 'This is a fallback response due to schema validation failure.';

  // U-063: 폴백에서도 재화 잔액 유지 (RULE-005)
  // economySnapshot이 제공되면 해당 값을 사용, 없으면 기본값 사용
  const balanceAfter = economySnapshot
    ? { signal: economySnapshot.signal, memory_shard: economySnapshot.memory_shard }
    : { signal: 100, memory_shard: 5 }; // 기본값 (프로필 미로드 상태의 placeholder)

  return {
    language,
    narrative: errorMessage ?? fallbackNarrative,
    economy: {
      cost: { signal: 0, memory_shard: 0 },
      balance_after: balanceAfter,
      credit: 0,
      low_balance_warning: false,
    },
    safety: {
      blocked: false,
      message: safetyMessage,
    },
    ui: {
      action_deck: { cards: [] },
      objects: [],
      scene: { image_url: null, alt_text: null },
    },
    world: {
      rules_changed: [],
      inventory_added: [],
      inventory_removed: [],
      quests_updated: [],
      relationships_changed: [],
      memory_pins: [],
    },
    render: {
      image_job: null,
      image_url: null,
      image_id: null,
      generation_time_ms: null,
    },
    agent_console: {
      current_phase: 'commit',
      badges: ['schema_fail'],
      repair_count: repairCount,
      model_label: 'FAST',
    },
  };
}

// =============================================================================
// 검증 헬퍼 함수
// =============================================================================

/**
 * TurnOutput 검증 결과 타입.
 */
export type TurnOutputParseResult =
  | { success: true; data: TurnOutput }
  | { success: false; error: z.ZodError; fallback: TurnOutput };

/**
 * TurnOutput을 안전하게 파싱합니다.
 * 실패 시 폴백 TurnOutput을 반환합니다 (RULE-004).
 *
 * U-063: economySnapshot 파라미터 추가 - 폴백 시에도 재화 잔액 유지.
 *
 * @param data - 파싱할 데이터
 * @param language - 폴백 시 사용할 언어 (기본: ko-KR)
 * @param repairCount - 현재 복구 시도 횟수
 * @param economySnapshot - 현재 재화 스냅샷 (선택, 폴백 시 잔액 유지)
 */
export function safeParseTurnOutput(
  data: unknown,
  language: Language = 'en-US',
  repairCount: number = 0,
  economySnapshot?: { signal: number; memory_shard: number },
): TurnOutputParseResult {
  const result = TurnOutputSchema.safeParse(data);

  if (result.success) {
    return { success: true, data: result.data };
  }

  return {
    success: false,
    error: result.error,
    fallback: createFallbackTurnOutput(language, repairCount, undefined, economySnapshot),
  };
}

/**
 * TurnInput을 검증합니다.
 * 입력 데이터의 유효성을 엄격하게 검사합니다.
 *
 * @param data - 검증할 데이터
 * @throws {z.ZodError} 검증 실패 시
 */
export function parseTurnInput(data: unknown): TurnInput {
  return TurnInputSchema.parse(data);
}

/**
 * TurnInput 안전 파싱 결과 타입.
 */
export type TurnInputSafeParseResult = ReturnType<typeof TurnInputSchema.safeParse>;

/**
 * TurnInput을 안전하게 파싱합니다.
 *
 * @param data - 파싱할 데이터
 */
export function safeParseTurnInput(data: unknown): TurnInputSafeParseResult {
  return TurnInputSchema.safeParse(data);
}
</file>

<file path="frontend/src/App.tsx">
/**
 * Unknown World - 메인 게임 UI 레이아웃
 *
 * RULE-002 준수: 채팅 버블 UI 금지
 * - 내러티브는 "채팅"이 아니라 "게임 로그/내러티브 피드" 형태
 * - 고정 패널: Scene Canvas, Action Deck, Inventory, Quest,
 *   Rule Board, Economy HUD, Agent Console, Scanner Slot
 *
 * RULE-008: Agent Console에서 단계/배지/복구만 표시 (프롬프트 노출 금지)
 *
 * RU-003-Q4: App.tsx는 "레이아웃 + 이벤트 라우팅"에 집중
 * - 세션/월드 상태는 worldStore로 이동
 * - TurnOutput 반영은 worldStore.applyTurnOutput으로 단일화
 *
 * RU-004-Q4: 세션 라이프사이클 SSOT
 * - 세션 초기화/복원/리셋/변경은 sessionLifecycle 모듈로 단일화
 * - App.tsx는 세션 API 호출 + UI 전환만 담당
 *
 * U-015[Mvp]: SaveGame + Reset + Demo Profiles
 * - 프로필 선택 화면 → 게임 시작 플로우
 * - 리셋 버튼으로 프로필 초기 상태로 복구
 * - localStorage 기반 세이브/로드
 *
 * @see vibe/ref/frontend-style-guide.md
 * @see vibe/prd.md 6.7/6.8/9장
 */

import { useState, useCallback, useEffect, useMemo, useRef } from 'react';
import { useTranslation } from 'react-i18next';
import {
  DndContext,
  DragEndEvent,
  DragStartEvent,
  useSensor,
  useSensors,
  PointerSensor,
  KeyboardSensor,
} from '@dnd-kit/core';
import { Panel } from './components/Panel';
import { GameHeader } from './components/GameHeader';
import { NarrativeFeed } from './components/NarrativeFeed';
import { AgentConsole } from './components/AgentConsole';
import { EconomyHud } from './components/EconomyHud';
import { SceneCanvas, type HotspotClickData } from './components/SceneCanvas';
import { ActionDeck } from './components/ActionDeck';
import { InventoryPanel } from './components/InventoryPanel';
// U-013: Quest + Rule Board + Mutation Timeline
import { QuestPanel } from './components/QuestPanel';
// U-078: Objective Tracker (미니 트래커)
import { ObjectiveTracker } from './components/ObjectiveTracker';
import { RuleBoard } from './components/RuleBoard';
import { MutationTimeline } from './components/MutationTimeline';
// U-022: Scanner Slot
import { ScannerSlot } from './components/ScannerSlot';
// U-015: SaveGame + Demo Profiles
import { DemoProfileSelect } from './components/DemoProfileSelect';
import { ResetButton, ChangeProfileButton } from './components/ResetButton';
// U-117: OnboardingGuide 제거 (온보딩 팝업 삭제, hover 힌트는 유지)
import { useAgentStore } from './stores/agentStore';
import { useInventoryStore, selectItemCount } from './stores/inventoryStore';
import { useUIPrefsStore, applyUIPrefsToDOM } from './stores/uiPrefsStore';
import { useWorldStore } from './stores/worldStore';
import { useTurnRunner, type RunTurnParams } from './turn/turnRunner';
import type { ActionCard, DropInput } from './schemas/turn';
import { RateLimitPanel } from './components/RateLimitPanel';
import { getCurrentThemeFromDOM } from './demo/demoFixtures';
import { isInventoryDragData, isHotspotDropData } from './dnd/types';
// U-117: initializeOnboarding 제거 (온보딩 가이드 삭제)
// U-116: 세션 라이프사이클 SSOT (SaveGame 제거)
import {
  bootstrapSession,
  startSessionFromProfile,
  resetToCurrentProfile,
  clearSessionAndReturnToSelect,
  setSessionLanguage,
  getInitialSessionLanguage,
} from './save/sessionLifecycle';
import type { DemoProfile } from './data/demoProfiles';
import type { SupportedLanguage } from './i18n';

// =============================================================================
// 게임 상태 타입
// =============================================================================

type GamePhase = 'profile_select' | 'playing';

// =============================================================================
// 메인 App 컴포넌트
// =============================================================================

function App() {
  const { t } = useTranslation();

  // U-116: 항상 profile_select로 시작 (SaveGame 제거)
  const [gamePhase, setGamePhase] = useState<GamePhase>(() => {
    bootstrapSession(); // 레거시 데이터 정리
    return 'profile_select';
  });

  // 현재 선택된 프로필 ID (세션 내에서만 유지, 새로고침 시 초기화)
  const [currentProfileId, setCurrentProfileId] = useState<string | null>(null);

  // U-044: 세션 언어 SSOT
  // - SaveGame.language를 권위자로 사용하여 드리프트 방지
  // - profile_select에서만 변경 가능 (토글=리셋 정책)
  const [sessionLanguage, setSessionLanguageState] = useState<SupportedLanguage>(() => {
    return getInitialSessionLanguage();
  });

  // 로컬 UI 상태
  const [inputText, setInputText] = useState('');

  // Store 상태 (셀렉터 최적화)
  const economy = useWorldStore((state) => state.economy);
  const isConnected = useWorldStore((state) => state.isConnected);
  const sceneObjects = useWorldStore((state) => state.sceneObjects);
  const narrativeEntries = useWorldStore((state) => state.narrativeEntries);
  const appendSystemNarrative = useWorldStore((state) => state.appendSystemNarrative);
  const appendActionLog = useWorldStore((state) => state.appendActionLog);

  const { startDrag, endDrag } = useInventoryStore();
  const inventoryItemCount = useInventoryStore(selectItemCount);

  // AgentStore 셀렉터
  const isStreaming = useAgentStore((state) => state.isStreaming);
  const narrativeBuffer = useAgentStore((state) => state.narrativeBuffer);
  // U-130: rate limit 상태 셀렉터
  const isRateLimited = useAgentStore((state) => state.isRateLimited);

  // U-087: 입력 잠금 SSOT - 처리 중 모든 사용자 입력을 차단
  // U-130: rate limit 시에도 입력 잠금 유지 (재시도 버튼만 활성화)
  const processingPhase = useWorldStore((state) => state.sceneState.processingPhase);
  const imageLoading = useWorldStore((state) => state.sceneState.imageLoading);
  const isInputLocked =
    isStreaming || processingPhase !== 'idle' || imageLoading === true || isRateLimited;

  // U-130: 마지막 턴 파라미터 저장 (재시도용)
  const lastTurnParamsRef = useRef<RunTurnParams | null>(null);

  const { uiScale, increaseUIScale, decreaseUIScale } = useUIPrefsStore();

  // DOM에 UI 설정 적용 (U-028→U-037)
  useEffect(() => {
    applyUIPrefsToDOM({ uiScale });
  }, [uiScale]);

  // ==========================================================================
  // U-015 + RU-004-Q4: 프로필/세이브 관련 로직 (sessionLifecycle SSOT)
  // ==========================================================================

  /**
   * 프로필을 선택하고 게임을 시작합니다.
   * U-116: SaveGame 없이 store에 직접 적용합니다.
   */
  const handleSelectProfile = useCallback(
    (profile: DemoProfile) => {
      const result = startSessionFromProfile({ profile, t, language: sessionLanguage });
      if (result.success) {
        setCurrentProfileId(result.profileId);
        setGamePhase('playing');
      }
    },
    [t, sessionLanguage],
  );

  /**
   * U-044: profile_select에서 언어를 변경합니다.
   * 토글=리셋 정책에 따라 profile_select에서만 호출 가능합니다.
   */
  const handleLanguageChange = useCallback(async (language: SupportedLanguage) => {
    await setSessionLanguage(language);
    setSessionLanguageState(language);
  }, []);

  /**
   * 현재 프로필의 초기 상태로 리셋합니다.
   * U-116: store 전체 초기화 + 동일 프로필로 재시작합니다.
   */
  const handleReset = useCallback(() => {
    const result = resetToCurrentProfile({ t, currentProfileId });
    if (result.success && result.profileId) {
      setCurrentProfileId(result.profileId);
    }
  }, [t, currentProfileId]);

  /**
   * 프로필 선택 화면으로 돌아갑니다.
   * U-116: 모든 store 초기화 + profile_select로 전환합니다.
   */
  const handleChangeProfile = useCallback(() => {
    clearSessionAndReturnToSelect();
    setCurrentProfileId(null);
    setGamePhase('profile_select');
  }, []);

  // U-117: 온보딩 가이드 초기화 제거 (팝업 삭제, hover 힌트만 유지)

  // RU-003-Q3: Turn Runner (스트림 시작/취소/콜백 라우팅 담당)
  // U-044: 세션 언어를 SSOT로 주입하여 드리프트 방지
  const turnRunnerDeps = useMemo(
    () => ({
      t,
      theme: getCurrentThemeFromDOM(),
      language: sessionLanguage,
    }),
    [t, sessionLanguage],
  );
  const turnRunner = useTurnRunner(turnRunnerDeps);

  /**
   * 턴을 실행합니다.
   */
  const executeTurn = useCallback(
    (text: string, actionId?: string, clickData?: HotspotClickData, dropData?: DropInput) => {
      const params: RunTurnParams = {
        text,
        actionId,
        click: clickData,
        drop: dropData,
      };
      // U-130: 재시도를 위해 마지막 턴 파라미터 저장
      lastTurnParamsRef.current = params;
      turnRunner.runTurn(params);
      setInputText('');
    },
    [turnRunner],
  );

  /**
   * U-130: Rate limit 시 재시도 핸들러.
   * 마지막 실패한 턴 파라미터로 다시 실행합니다.
   */
  const handleRetry = useCallback(() => {
    const params = lastTurnParamsRef.current;
    if (!params) return;
    // agentStore.startStream() 호출 시 isRateLimited가 false로 초기화됨
    turnRunner.runTurn(params);
  }, [turnRunner]);

  /**
   * 입력 제출 핸들러
   */
  const handleSubmit = useCallback(() => {
    // U-087: 입력 잠금 시 제출 차단
    if (isInputLocked) return;
    if (inputText.trim()) {
      executeTurn(inputText.trim());
    }
  }, [inputText, executeTurn, isInputLocked]);

  /**
   * 카드 클릭 핸들러
   * U-070: Q2 Option A - 모든 플레이어 행동에 액션 로그 적용
   */
  const handleCardClick = useCallback(
    (card: ActionCard) => {
      // U-087: 입력 잠금 시 허위 액션 로그 방지 (즉시 반환)
      if (isInputLocked) return;
      // U-070: 액션 로그 추가 (TurnInput 전송 전에 즉각적 피드백)
      appendActionLog(t('action_log.click_action', { action: card.label }));
      executeTurn(card.label, card.id);
    },
    [executeTurn, appendActionLog, t, isInputLocked],
  );

  /**
   * 핫스팟 클릭 핸들러 (U-010)
   * U-070: 핫스팟 클릭에도 액션 로그 적용
   */
  const handleHotspotClick = useCallback(
    (data: HotspotClickData) => {
      // U-087: 입력 잠금 시 허위 액션 로그 방지 (즉시 반환)
      if (isInputLocked) return;
      const clickedObject = sceneObjects.find((obj) => obj.id === data.object_id);
      const clickText = clickedObject
        ? t('scene.hotspot.click_action', { label: clickedObject.label })
        : data.object_id;

      // U-070: 액션 로그 추가 (TurnInput 전송 전에 즉각적 피드백)
      const hotspotLabel = clickedObject?.label ?? data.object_id;
      appendActionLog(t('action_log.click_hotspot', { hotspot: hotspotLabel }));

      executeTurn(clickText, undefined, data);
    },
    [executeTurn, sceneObjects, t, appendActionLog, isInputLocked],
  );

  /**
   * 키보드 이벤트 핸들러
   */
  const handleKeyDown = useCallback(
    (e: React.KeyboardEvent) => {
      if (e.key === 'Enter' && !e.shiftKey) {
        e.preventDefault();
        handleSubmit();
      }
    },
    [handleSubmit],
  );

  /**
   * 드래그 시작 핸들러 (U-011)
   */
  const handleDragStart = useCallback(
    (event: DragStartEvent) => {
      // U-087: 입력 잠금 시 드래그 시작 차단
      if (isInputLocked) return;
      const { active } = event;
      if (isInventoryDragData(active.data.current)) {
        startDrag(active.data.current.item_id);
      }
    },
    [startDrag, isInputLocked],
  );

  /**
   * 드래그 종료 핸들러 (U-011 + U-012)
   * U-070: 아이템→핫스팟 드롭 시 액션 로그 추가
   */
  const handleDragEnd = useCallback(
    (event: DragEndEvent) => {
      const { active, over } = event;
      endDrag();

      // U-087: 입력 잠금 시 드롭 처리 차단 (허위 액션 로그 방지)
      if (isInputLocked) return;

      const activeData = active.data.current;
      if (!isInventoryDragData(activeData)) {
        return;
      }

      const itemId = activeData.item_id;
      const itemName = activeData.item.name;

      const overData = over?.data.current;
      if (!over || !isHotspotDropData(overData)) {
        appendSystemNarrative(
          `[${t('connection.online')}] ${t('scene.hotspot.drop_invalid', { item: itemName })}`,
        );
        return;
      }

      const { object_id: targetObjectId, box_2d: targetBox2d, label: targetLabel } = overData;

      // U-070: 액션 로그 추가 (TurnInput 전송 전에 즉각적 피드백)
      appendActionLog(
        t('action_log.use_item_on_hotspot', {
          item: itemName,
          hotspot: targetLabel,
        }),
      );

      const dropText = t('scene.hotspot.drop_action', {
        item: itemName,
        target: targetLabel,
      });

      const dropInput: DropInput = {
        item_id: itemId,
        target_object_id: targetObjectId,
        target_box_2d: targetBox2d,
      };

      executeTurn(dropText, undefined, undefined, dropInput);
    },
    [endDrag, executeTurn, appendSystemNarrative, appendActionLog, t, isInputLocked],
  );

  // dnd-kit 센서 설정 (U-117: distance 5px로 클릭/드래그 구분)
  const sensors = useSensors(
    useSensor(PointerSensor, {
      activationConstraint: {
        distance: 5,
      },
    }),
    useSensor(KeyboardSensor),
  );

  // ==========================================================================
  // 렌더링: 프로필 선택 화면
  // U-116: SaveGame 제거 → Continue 버튼 불필요, 항상 새 세션 시작
  // ==========================================================================
  if (gamePhase === 'profile_select') {
    return (
      <>
        <div className="crt-overlay" aria-hidden="true" />
        <DemoProfileSelect
          onSelectProfile={handleSelectProfile}
          currentLanguage={sessionLanguage}
          onLanguageChange={handleLanguageChange}
        />
      </>
    );
  }

  // ==========================================================================
  // 렌더링: 게임 플레이 화면
  // ==========================================================================
  return (
    <>
      <div className="crt-overlay" aria-hidden="true" />

      <DndContext sensors={sensors} onDragStart={handleDragStart} onDragEnd={handleDragEnd}>
        <div className="game-container">
          <GameHeader
            signal={economy.signal}
            memoryShard={economy.memory_shard}
            credit={economy.credit}
            isConnected={isConnected}
            uiScale={uiScale}
            onIncreaseScale={increaseUIScale}
            onDecreaseScale={decreaseUIScale}
          >
            {/* U-015: 리셋/프로필 변경 버튼 (U-087: isInputLocked로 확장) */}
            <ResetButton onReset={handleReset} disabled={isInputLocked} compact requireConfirm />
            <ChangeProfileButton onClick={handleChangeProfile} disabled={isInputLocked} />
          </GameHeader>

          {/* U-077: 좌측 사이드바 패널 영역 분배 (U-081 흡수) */}
          <aside className="sidebar-left">
            {/* U-077: Inventory - flex-1 + min-height 보장, 아이템 개수 동적 타이틀 */}
            <Panel
              title={
                inventoryItemCount > 0
                  ? t('inventory.count', { count: inventoryItemCount })
                  : t('panel.inventory.title')
              }
              className="panel-inventory flex-1"
            >
              <InventoryPanel />
            </Panel>
            {/* U-013: Quest Panel (U-077: max-height + 내부 스크롤) */}
            <Panel title={t('panel.quest.title')} className="panel-quest">
              <QuestPanel />
            </Panel>
            {/* U-013: Rule Board + Mutation Timeline (U-077: max-height + 내부 스크롤) */}
            <Panel title={t('panel.rule_board.title')} className="panel-rule-board">
              <RuleBoard />
              <MutationTimeline />
            </Panel>
          </aside>

          <main className="game-center">
            {/* U-078: 목표 미니 트래커 (항상 상단에 표시, Q2: Option B) */}
            <ObjectiveTracker />
            {/* U-087: isInputLocked로 핫스팟 클릭/드롭 비활성화 */}
            <SceneCanvas onHotspotClick={handleHotspotClick} disabled={isInputLocked} />
            {/* U-086: isStreaming/isImageLoading 전달 → 텍스트 우선 타이핑 + 이미지 pending 상태 라인 */}
            <NarrativeFeed
              entries={narrativeEntries}
              streamingText={narrativeBuffer}
              isStreaming={isStreaming}
              isImageLoading={imageLoading === true}
            />
          </main>

          {/* U-082: 우측 사이드바 - Agent Console 축소 + Economy HUD flex-1 확대
               (U-049 Q1 Option A 반전: Economy가 유연 확장, Agent Console은 콘텐츠 기반) */}
          <aside className="sidebar-right">
            <Panel title={t('panel.agent_console.title')} className="panel-agent-console" hasChrome>
              <AgentConsole />
            </Panel>
            <Panel title={t('economy.hud_label')} className="panel-economy" hasChrome>
              <EconomyHud />
            </Panel>
            <Panel title={t('panel.scanner.title')} className="panel-scanner" hasChrome>
              {/* U-087: isInputLocked로 확장 (스트리밍+이미지+처리 단계 모두 차단) */}
              <ScannerSlot language={sessionLanguage} disabled={isInputLocked} />
            </Panel>
          </aside>

          <footer className="game-footer">
            {/* U-087: isInputLocked로 ActionDeck 전체 비활성화 */}
            <ActionDeck onCardClick={handleCardClick} disabled={isInputLocked} />
            <div className="command-input-area">
              <span className="command-prompt">&gt;</span>
              <input
                type="text"
                className="command-input"
                placeholder={isInputLocked ? t('ui.input_locked') : t('ui.command_placeholder')}
                aria-label={t('ui.command_placeholder')}
                value={inputText}
                onChange={(e) => setInputText(e.target.value)}
                onKeyDown={handleKeyDown}
                disabled={isInputLocked}
              />
              <button type="button" onClick={handleSubmit} disabled={isInputLocked}>
                {isInputLocked ? t('ui.wait') : t('ui.execute')}
              </button>
            </div>
          </footer>
          {/* U-079: 재화 획득 토스트 알림 */}
          <CurrencyToastUI />
        </div>
      </DndContext>

      {/* U-087: 입력 잠금 오버레이 - 처리 중 pointer-events 차단 */}
      {isInputLocked && (
        <div className="input-lock-overlay" aria-live="polite" role="status">
          <span className="input-lock-label">{t('ui.input_locked')}</span>
        </div>
      )}

      {/* U-130: Rate Limit 재시도 안내 패널 (input-lock-overlay보다 높은 z-index) */}
      {isRateLimited && <RateLimitPanel onRetry={handleRetry} />}

      {/* U-117: 온보딩 가이드 팝업 제거 (hover 힌트는 InteractionHint로 유지) */}
    </>
  );
}

/**
 * U-079: 재화 획득 토스트 알림 컴포넌트.
 * worldStore.currencyToast 상태를 구독하여 팝업 표시.
 */
function CurrencyToastUI() {
  const toast = useWorldStore((state) => state.currencyToast);
  const dismiss = useWorldStore((state) => state.dismissCurrencyToast);

  if (!toast) return null;

  return (
    <div className="currency-toast" role="alert" aria-live="assertive">
      <span className="currency-toast-icon">
        {toast.signalDelta > 0 ? '\u26A1' : '\uD83D\uDCB8'}
      </span>
      <span className="currency-toast-amount">
        {toast.signalDelta > 0 ? '+' : ''}
        {toast.signalDelta} Signal
      </span>
      <span className="currency-toast-reason">{toast.reason}</span>
      <button type="button" className="currency-toast-close" onClick={dismiss} aria-label="Close">
        {'\u2715'}
      </button>
    </div>
  );
}

export default App;
</file>

<file path="backend/src/unknown_world/services/image_generation.py">
"""Unknown World - 이미지 생성 서비스.

이 모듈은 Gemini 이미지 생성 모델을 호출하고 결과를 로컬에 저장하는 서비스입니다.
텍스트 턴의 TTFB를 블로킹하지 않도록 분리된 경로로 동작합니다.

설계 원칙:
    - RULE-004: 실패 시 안전한 폴백 제공 (should_generate=false)
    - RULE-008: 텍스트 우선 + Lazy 이미지 원칙
    - RULE-010: 이미지 모델 ID 고정 (gemini-3-pro-image-preview)
    - RULE-007: 프롬프트 원문 노출 금지

페어링 질문 결정 (U-064[Mvp]):
    - Q1: Option A (타임아웃 60초 - 이미지 생성은 15-20초 소요 가능)
    - Q2: Option A (MVP에서는 재시도 없이 즉시 폴백)
    - Q3: Option B (텍스트 응답도 로깅 - 디버깅용)

API 호출 방식 (U-064[Mvp] 수정):
    - generate_images() 대신 generate_content() 사용
    - response_modalities=[Modality.TEXT, Modality.IMAGE] 설정
    - 응답에서 part.inline_data.data로 이미지 바이트 추출

참조:
    - vibe/tech-stack.md (모델 ID 고정)
    - vibe/unit-plans/U-019[Mvp].md
    - vibe/unit-plans/U-064[Mvp].md
    - https://ai.google.dev/gemini-api/docs/image-generation
    - .cursor/rules/20-backend-orchestrator.mdc
"""

from __future__ import annotations

import asyncio
import base64
import hashlib
import logging
import os
import random
import uuid
from dataclasses import dataclass
from datetime import UTC, datetime
from enum import StrEnum
from pathlib import Path
from typing import TYPE_CHECKING, Any

from pydantic import BaseModel, ConfigDict, Field

from unknown_world.config.models import MODEL_IMAGE, ModelLabel, get_model_id
from unknown_world.storage.paths import (
    LEGACY_OUTPUT_DIR,
    build_image_url,
    get_generated_images_dir,
)
from unknown_world.storage.validation import (
    DEFAULT_ASPECT_RATIO,
    DEFAULT_IMAGE_SIZE,
    SUPPORTED_IMAGE_SIZES,
    normalize_image_size,
)

if TYPE_CHECKING:
    from google.genai import Client

# =============================================================================
# 로거 설정 (프롬프트/비밀정보 노출 금지 - RULE-007/008)
# =============================================================================

logger = logging.getLogger(__name__)


# =============================================================================
# 상수 정의
# =============================================================================

# 하위 호환성을 위한 레거시 경로 별칭 (RU-006-Q5)
# 신규 코드에서는 get_generated_images_dir() 사용 권장
DEFAULT_OUTPUT_DIR = LEGACY_OUTPUT_DIR

# 호환성을 위한 상수 별칭
SUPPORTED_SIZES = SUPPORTED_IMAGE_SIZES
"""지원 이미지 크기 (호환성 별칭)."""

DEFAULT_SIZE = DEFAULT_IMAGE_SIZE
"""기본 이미지 크기 (호환성 별칭)."""

# U-064[Mvp] Q1 결정: 이미지 생성 타임아웃
# 이미지 생성은 15-20초 소요 가능하므로 충분한 여유를 둠
# TODO: 테스트 후 적절한 값으로 조정 (현재 5분으로 설정)
IMAGE_GENERATION_TIMEOUT_SECONDS = 300
"""이미지 생성 API 호출 타임아웃 (초)."""


class ImageGenerationStatus(StrEnum):
    """이미지 생성 상태."""

    PENDING = "pending"
    """생성 대기 중"""

    GENERATING = "generating"
    """생성 중"""

    COMPLETED = "completed"
    """생성 완료"""

    FAILED = "failed"
    """생성 실패"""

    SKIPPED = "skipped"
    """생성 건너뜀 (잔액 부족 등)"""


# =============================================================================
# 요청/응답 Pydantic 모델
# =============================================================================


class ImageGenerationRequest(BaseModel):
    """이미지 생성 요청.

    TurnOutput의 render.image_job과 정합되도록 필드를 설계합니다.

    Attributes:
        prompt: 이미지 생성 프롬프트 (필수)
        aspect_ratio: 가로세로 비율 (예: "16:9", "1:1")
        image_size: 이미지 크기 (예: "1024x1024")
        reference_image_ids: 참조 이미지 ID 목록 (선택, 편집용)
        reference_image_url: 참조 이미지 URL (U-068: 이전 턴 이미지 연결성)
        session_id: 세션 ID (파일 그룹화용)
        model_label: 모델 티어링 라벨 (U-066: FAST/QUALITY)
    """

    model_config = ConfigDict(extra="forbid")

    prompt: str = Field(min_length=1, description="이미지 생성 프롬프트")
    aspect_ratio: str = Field(default=DEFAULT_ASPECT_RATIO, description="가로세로 비율")
    image_size: str = Field(
        default=DEFAULT_SIZE,
        description="이미지 크기 - SDK 값: 1K/2K/4K (U-085 Q2 마이그레이션)",
    )
    reference_image_ids: list[str] = Field(default_factory=list, description="참조 이미지 ID 목록")
    reference_image_url: str | None = Field(
        default=None,
        description="참조 이미지 URL (U-068: 이전 턴 이미지를 참조하여 연속성 유지)",
    )
    session_id: str | None = Field(default=None, description="세션 ID")
    seed: int | None = Field(default=None, description="결정적 생성을 위한 시드 (선택)")
    model_label: str = Field(
        default="QUALITY",
        description="모델 티어링 라벨 (U-066: FAST=저지연 프리뷰, QUALITY=고품질)",
    )


class ImageGenerationResponse(BaseModel):
    """이미지 생성 응답.

    Attributes:
        status: 생성 상태
        image_id: 생성된 이미지 ID (성공 시)
        image_url: 생성된 이미지 URL (성공 시)
        message: 상태 메시지 (실패 시 오류 설명)
        generation_time_ms: 생성 소요 시간 (밀리초)
    """

    model_config = ConfigDict(extra="forbid")

    status: ImageGenerationStatus
    image_id: str | None = Field(default=None, description="생성된 이미지 ID")
    image_url: str | None = Field(default=None, description="생성된 이미지 URL")
    message: str | None = Field(default=None, description="상태 메시지")
    generation_time_ms: int = Field(default=0, description="생성 소요 시간 (ms)")


# =============================================================================
# 내부 데이터 클래스
# =============================================================================


@dataclass
class GeneratedImage:
    """생성된 이미지 정보.

    Attributes:
        id: 이미지 고유 ID
        path: 로컬 파일 경로
        url: 서빙 URL
        prompt_hash: 프롬프트 해시 (로그용, 원문 노출 금지)
        created_at: 생성 시각
        size: 파일 크기 (bytes)
        metadata: 추가 메타데이터
    """

    id: str
    path: Path
    url: str
    prompt_hash: str
    created_at: datetime
    size: int = 0

    def __post_init__(self) -> None:
        """초기화 후 메타데이터 필드 설정."""
        self._metadata: dict[str, str] = {}

    @property
    def metadata(self) -> dict[str, str]:
        """추가 메타데이터."""
        if not hasattr(self, "_metadata"):
            self._metadata = {}
        return self._metadata


# =============================================================================
# Mock 이미지 생성기
# =============================================================================


class MockImageGenerator:
    """테스트/개발용 모의 이미지 생성기.

    실제 API를 호출하지 않고 플레이스홀더 이미지를 생성합니다.
    """

    def __init__(self, output_dir: Path | None = None) -> None:
        """MockImageGenerator를 초기화합니다.

        Args:
            output_dir: 이미지 저장 디렉토리 (기본값: .data/images/generated)
        """
        self._output_dir = output_dir or get_generated_images_dir()
        self._output_dir.mkdir(parents=True, exist_ok=True)
        logger.info(
            "[ImageGen] Mock 모드로 초기화됨",
            extra={"output_dir": str(self._output_dir)},
        )

    async def generate(self, request: ImageGenerationRequest) -> ImageGenerationResponse:
        """모의 이미지를 생성합니다.

        Args:
            request: 이미지 생성 요청

        Returns:
            ImageGenerationResponse: 생성 결과
        """
        start_time = datetime.now(UTC)

        # 프롬프트 해시 생성 (원문 로깅 금지 - RULE-007)
        prompt_hash = hashlib.sha256(request.prompt.encode()).hexdigest()[:8]
        logger.debug(
            "[ImageGen] Mock 이미지 생성 요청",
            extra={
                "prompt_hash": prompt_hash,
                "size": request.image_size,
                "aspect_ratio": request.aspect_ratio,
                "model_label": request.model_label,
                "reference_image_url": request.reference_image_url,
            },
        )

        # 고유 이미지 ID 생성 (U-060: seed가 있으면 결정적 생성)
        if request.seed is not None:
            # 시드와 프롬프트 해시를 조합하여 고유성 확보
            seed_rng = random.Random(f"{request.seed}_{prompt_hash}")
            image_id = f"img_{seed_rng.getrandbits(48):012x}"
        else:
            image_id = f"img_{uuid.uuid4().hex[:12]}"

        # 플레이스홀더 이미지 생성 (1x1 투명 PNG)
        # 실제 환경에서는 Gemini API 응답으로 대체됨
        placeholder_png = self._create_placeholder_png(request.image_size)

        # 파일 저장
        file_name = f"{image_id}.png"
        file_path = self._output_dir / file_name
        file_path.write_bytes(placeholder_png)

        # U-091: rembg 런타임 제거 - 배경 제거 후처리 없이 바로 저장

        # 서빙 URL 생성 (RU-006-Q5: 중앙화된 URL 빌더 사용)
        image_url = build_image_url(file_name, category="generated")

        elapsed_ms = int((datetime.now(UTC) - start_time).total_seconds() * 1000)

        logger.info(
            "[ImageGen] Mock 이미지 생성 완료",
            extra={
                "image_id": image_id,
                "elapsed_ms": elapsed_ms,
            },
        )

        return ImageGenerationResponse(
            status=ImageGenerationStatus.COMPLETED,
            image_id=image_id,
            image_url=image_url,
            message="Mock 이미지가 생성되었습니다.",
            generation_time_ms=elapsed_ms,
        )

    def _create_placeholder_png(self, size_str: str) -> bytes:
        """플레이스홀더 PNG를 생성합니다.

        Args:
            size_str: 이미지 크기 문자열 (예: "1024x1024")

        Returns:
            PNG 바이트 데이터
        """
        # 최소한의 유효한 PNG (1x1 회색 픽셀)
        # 실제 크기는 무시하고 플레이스홀더만 반환
        # 16x16 회색 PNG (mock 식별용)
        # Base64로 인코딩된 미니멀 PNG
        minimal_png = base64.b64decode(
            "iVBORw0KGgoAAAANSUhEUgAAABAAAAAQCAYAAAAf8/9hAAAADklEQVQ4y2NgGAWjAAcA"
            "CHABAMXKQ5oAAAAASUVORK5CYII="
        )
        return minimal_png

    def is_available(self) -> bool:
        """Mock 생성기는 항상 사용 가능합니다."""
        return True


# =============================================================================
# 실제 이미지 생성기
# =============================================================================


class ImageGenerator:
    """Gemini 기반 실제 이미지 생성기.

    gemini-3-pro-image-preview 모델을 사용하여 이미지를 생성합니다.
    모델 ID는 RULE-010에 따라 고정됩니다.

    U-080 핫픽스: Vertex AI 서비스 계정 인증 완전 제거, API 키 전용
    U-068: 참조 이미지(이전 턴 이미지)를 사용한 시각적 연속성 지원
    """

    def __init__(
        self,
        output_dir: Path | None = None,
        api_key: str | None = None,
    ) -> None:
        """ImageGenerator를 초기화합니다.

        Args:
            output_dir: 이미지 저장 디렉토리 (기본값: .data/images/generated)
            api_key: Gemini API 키 (환경변수 GOOGLE_API_KEY 사용 가능)
        """
        self._output_dir = output_dir or get_generated_images_dir()
        self._output_dir.mkdir(parents=True, exist_ok=True)
        self._api_key = api_key or os.environ.get("GOOGLE_API_KEY")
        self._client: Client | None = None
        self._available = False
        # U-068: 참조 이미지 캐시 (URL → bytes)
        self._reference_image_cache: dict[str, bytes] = {}

        self._initialize_client()

    def _initialize_client(self) -> None:
        """google-genai 클라이언트를 초기화합니다."""
        try:
            if not self._api_key:
                logger.warning(
                    "[ImageGen] GOOGLE_API_KEY 환경변수가 설정되지 않음 - Mock 모드 권장",
                )
                self._available = False
                return

            from google.genai import Client

            # API 키 모드로 클라이언트 초기화 (Vertex AI 제거)
            self._client = Client(api_key=self._api_key)
            self._available = True

            # 로그에는 모델 ID만 기록 (API 키 노출 금지 - RULE-007)
            logger.info(
                "[ImageGen] API 키 이미지 생성기 초기화 완료",
                extra={
                    "model": MODEL_IMAGE,
                    "auth": "api_key",
                },
            )
        except Exception as e:
            logger.warning(
                "[ImageGen] API 키 클라이언트 초기화 실패 - Mock 모드 권장",
                extra={"error_type": type(e).__name__},
            )
            self._available = False

    async def _load_reference_image(self, url: str) -> bytes | None:
        """참조 이미지를 URL에서 로드합니다 (U-068).

        로컬 파일 또는 HTTP URL에서 이미지를 로드합니다.
        캐시를 사용하여 동일 URL의 중복 로딩을 방지합니다.

        Args:
            url: 이미지 URL (로컬 경로 또는 HTTP URL)

        Returns:
            bytes | None: 이미지 바이트 또는 실패 시 None
        """
        # 캐시 확인
        if url in self._reference_image_cache:
            logger.debug(
                "[ImageGen] 참조 이미지 캐시 히트",
                extra={"url_hash": hashlib.sha256(url.encode()).hexdigest()[:8]},
            )
            return self._reference_image_cache[url]

        try:
            # 로컬 파일 경로 처리 (API URL 형식: /api/image/file/{image_id})
            if url.startswith("/api/image/file/"):
                # URL에서 이미지 ID 추출
                image_id = url.split("/")[-1]
                file_path = self._output_dir / f"{image_id}.png"
                if file_path.exists():
                    image_bytes = file_path.read_bytes()
                    self._reference_image_cache[url] = image_bytes
                    logger.debug(
                        "[ImageGen] 로컬 참조 이미지 로드 성공",
                        extra={"image_id": image_id, "size_bytes": len(image_bytes)},
                    )
                    return image_bytes
                else:
                    logger.warning(
                        "[ImageGen] 로컬 참조 이미지 파일 없음",
                        extra={"image_id": image_id},
                    )
                    return None

            # HTTP/HTTPS URL 처리
            if url.startswith(("http://", "https://")):
                import httpx

                async with httpx.AsyncClient(timeout=30.0) as client:
                    response = await client.get(url)
                    response.raise_for_status()
                    image_bytes = response.content
                    self._reference_image_cache[url] = image_bytes
                    logger.debug(
                        "[ImageGen] HTTP 참조 이미지 로드 성공",
                        extra={
                            "url_hash": hashlib.sha256(url.encode()).hexdigest()[:8],
                            "size_bytes": len(image_bytes),
                        },
                    )
                    return image_bytes

            logger.warning(
                "[ImageGen] 지원하지 않는 참조 이미지 URL 형식",
                extra={"url_prefix": url[:20] if len(url) > 20 else url},
            )
            return None

        except Exception as e:
            logger.warning(
                "[ImageGen] 참조 이미지 로드 실패",
                extra={"error_type": type(e).__name__},
            )
            return None

    async def generate(self, request: ImageGenerationRequest) -> ImageGenerationResponse:
        """이미지를 생성합니다.

        U-064[Mvp] 수정: generate_content() API를 사용하여 이미지 생성.
        gemini-3-pro-image-preview 모델은 generate_images()가 아닌
        generate_content()를 사용해야 함.

        U-068: 참조 이미지가 있으면 멀티모달 입력으로 전달하여 시각적 연속성 유지.

        Args:
            request: 이미지 생성 요청

        Returns:
            ImageGenerationResponse: 생성 결과
        """
        if not self._available or self._client is None:
            return ImageGenerationResponse(
                status=ImageGenerationStatus.FAILED,
                message="이미지 생성 클라이언트가 초기화되지 않았습니다.",
            )

        start_time = datetime.now(UTC)

        # 프롬프트 해시 (원문 로깅 금지 - RULE-007)
        prompt_hash = hashlib.sha256(request.prompt.encode()).hexdigest()[:8]

        # U-066: model_label에 따른 모델 선택
        # FAST → gemini-2.5-flash-image (저지연 프리뷰)
        # QUALITY (기본) → gemini-3-pro-image-preview (고품질)
        selected_model_label = (
            ModelLabel.IMAGE_FAST if request.model_label == "FAST" else ModelLabel.IMAGE
        )
        selected_model_id = get_model_id(selected_model_label)

        # U-068: 참조 이미지 로드 (있는 경우)
        reference_image_bytes: bytes | None = None
        has_reference = False
        if request.reference_image_url:
            reference_image_bytes = await self._load_reference_image(request.reference_image_url)
            has_reference = reference_image_bytes is not None

        logger.debug(
            "[ImageGen] 이미지 생성 요청",
            extra={
                "prompt_hash": prompt_hash,
                "size": request.image_size,
                "aspect_ratio": request.aspect_ratio,
                "model": selected_model_id,
                "model_label": request.model_label,
                "has_reference": has_reference,
            },
        )

        try:
            from google.genai.types import (
                GenerateContentConfig,
                ImageConfig,
                Modality,
                Part,
            )

            # U-068: 참조 이미지가 있으면 멀티모달 contents 구성
            # 참조 이미지를 먼저 넣고, 프롬프트를 그 다음에 배치
            if has_reference and reference_image_bytes is not None:
                # 멀티모달 contents: [참조 이미지, 프롬프트 텍스트]
                # type: ignore[reportUnknownVariableType]
                contents = [
                    Part.from_bytes(data=reference_image_bytes, mime_type="image/png"),
                    Part.from_text(
                        text=f"이전 장면의 이미지입니다. 이 이미지의 스타일, 톤, 캐릭터/오브젝트 외형을 참조하여 다음 장면을 생성해주세요:\n\n{request.prompt}"
                    ),
                ]
            else:
                # 참조 이미지 없이 프롬프트만 전달
                contents = request.prompt

            # U-085: image_config 구성 (aspect_ratio + image_size)
            # U-097: image_size는 gemini-3-pro-image-preview (Pro) 전용 파라미터.
            # gemini-2.5-flash-image (Flash)에 전달하면 400 INVALID_ARGUMENT 발생.
            # 참조: vibe/ref/image-generate-guide.md §"Aspect ratios and image size"
            #   - Flash: aspect_ratio만 지원, 1024px 고정 해상도
            #   - Pro: aspect_ratio + image_size(1K/2K/4K) 지원
            sdk_image_size = normalize_image_size(request.image_size)
            is_pro_model = selected_model_label == ModelLabel.IMAGE

            if is_pro_model:
                image_config = ImageConfig(
                    aspect_ratio=request.aspect_ratio,
                    image_size=sdk_image_size,
                )
            else:
                # Flash 모델: aspect_ratio만 전달
                image_config = ImageConfig(
                    aspect_ratio=request.aspect_ratio,
                )

            logger.debug(
                "[ImageGen] image_config 적용",
                extra={
                    "aspect_ratio": request.aspect_ratio,
                    "image_size": sdk_image_size if is_pro_model else "(Flash: 고정 1024px)",
                    "model": selected_model_id,
                },
            )

            # U-064: generate_content() API를 사용하여 이미지 생성
            # U-085: image_config를 추가하여 비율/크기 제어
            # response_modalities에 TEXT와 IMAGE를 모두 포함
            # 참고: vibe/ref/image-generate-guide.md
            # Q1 결정: 타임아웃 60초 적용
            response = await asyncio.wait_for(
                self._client.aio.models.generate_content(  # type: ignore[reportUnknownMemberType]
                    model=selected_model_id,
                    contents=contents,  # type: ignore[reportArgumentType]
                    config=GenerateContentConfig(
                        response_modalities=[Modality.TEXT, Modality.IMAGE],
                        image_config=image_config,
                    ),
                ),
                timeout=IMAGE_GENERATION_TIMEOUT_SECONDS,
            )

            # U-064: 응답에서 이미지 추출 (메서드 분리)
            image_bytes = self._extract_image_from_response(response)

            if image_bytes is None:
                elapsed_ms = int((datetime.now(UTC) - start_time).total_seconds() * 1000)
                logger.warning(
                    "[ImageGen] 이미지 생성 응답에 이미지 데이터가 없음",
                    extra={"elapsed_ms": elapsed_ms},
                )
                return ImageGenerationResponse(
                    status=ImageGenerationStatus.FAILED,
                    message="이미지 생성 응답에 이미지 데이터가 없습니다.",
                    generation_time_ms=elapsed_ms,
                )

            # 고유 ID 및 파일 저장 (U-060: seed가 있으면 결정적 생성)
            if request.seed is not None:
                # 시드와 프롬프트 해시를 조합하여 고유성 확보
                seed_rng = random.Random(f"{request.seed}_{prompt_hash}")
                image_id = f"img_{seed_rng.getrandbits(48):012x}"
            else:
                image_id = f"img_{uuid.uuid4().hex[:12]}"

            file_name = f"{image_id}.png"
            file_path = self._output_dir / file_name
            file_path.write_bytes(image_bytes)

            # U-091: rembg 런타임 제거 - 배경 제거 후처리 없이 바로 저장

            # 서빙 URL 생성 (RU-006-Q5: 중앙화된 URL 빌더 사용)
            image_url = build_image_url(file_name, category="generated")
            elapsed_ms = int((datetime.now(UTC) - start_time).total_seconds() * 1000)

            logger.info(
                "[ImageGen] 이미지 생성 완료",
                extra={
                    "image_id": image_id,
                    "elapsed_ms": elapsed_ms,
                    "size_bytes": len(image_bytes),
                },
            )

            return ImageGenerationResponse(
                status=ImageGenerationStatus.COMPLETED,
                image_id=image_id,
                image_url=image_url,
                message="이미지가 성공적으로 생성되었습니다.",
                generation_time_ms=elapsed_ms,
            )

        except TimeoutError:
            # Q1 결정: 60초 타임아웃 초과 시 처리
            elapsed_ms = int((datetime.now(UTC) - start_time).total_seconds() * 1000)
            logger.warning(
                "[ImageGen] 이미지 생성 타임아웃",
                extra={
                    "timeout_seconds": IMAGE_GENERATION_TIMEOUT_SECONDS,
                    "elapsed_ms": elapsed_ms,
                },
            )
            return ImageGenerationResponse(
                status=ImageGenerationStatus.FAILED,
                message=f"이미지 생성 타임아웃 ({IMAGE_GENERATION_TIMEOUT_SECONDS}초 초과)",
                generation_time_ms=elapsed_ms,
            )

        except Exception as e:
            elapsed_ms = int((datetime.now(UTC) - start_time).total_seconds() * 1000)
            error_type = type(e).__name__
            # U-097: ClientError 등의 상세 원인을 캡처하여 디버깅 지원
            error_detail = str(e)[:200] if str(e) else "상세 정보 없음"

            logger.error(
                "[ImageGen] 이미지 생성 실패",
                extra={
                    "error_type": error_type,
                    "error_detail": error_detail,
                    "elapsed_ms": elapsed_ms,
                },
            )

            # 실패 시에도 안전한 응답 반환 (RULE-004)
            return ImageGenerationResponse(
                status=ImageGenerationStatus.FAILED,
                message=f"이미지 생성 중 오류가 발생했습니다: {error_type}",
                generation_time_ms=elapsed_ms,
            )

    def _extract_image_from_response(self, response: Any) -> bytes | None:
        """generate_content 응답에서 이미지 바이트 추출.

        Args:
            response: Gemini API 응답 객체

        Returns:
            bytes | None: 추출된 이미지 바이트 또는 None
        """
        try:
            if not response or not hasattr(response, "candidates") or not response.candidates:
                return None

            for candidate in response.candidates:
                if not hasattr(candidate, "content") or not candidate.content:
                    continue
                if not hasattr(candidate.content, "parts") or not candidate.content.parts:
                    continue

                for part in candidate.content.parts:
                    # Q3 결정: 텍스트 응답도 로깅 (디버깅용)
                    if hasattr(part, "text") and part.text:
                        text_preview = (
                            part.text[:100] + "..." if len(part.text) > 100 else part.text
                        )
                        logger.debug(
                            "[ImageGen] 텍스트 응답 (디버깅용)",
                            extra={"text_preview": text_preview},
                        )

                    # 이미지 데이터 추출
                    if (
                        hasattr(part, "inline_data")
                        and part.inline_data
                        and hasattr(part.inline_data, "data")
                        and part.inline_data.data
                    ):
                        logger.debug(
                            "[ImageGen] 이미지 데이터 추출 성공",
                            extra={"size_bytes": len(part.inline_data.data)},
                        )
                        return part.inline_data.data

            return None
        except Exception as e:
            logger.warning(
                "[ImageGen] 응답 파싱 중 오류 발생",
                extra={"error_type": type(e).__name__, "message": str(e)},
            )
            return None

    def is_available(self) -> bool:
        """생성기가 사용 가능한 상태인지 확인합니다."""
        return self._available


# =============================================================================
# 팩토리 함수
# =============================================================================

# 생성기 타입
ImageGeneratorType = MockImageGenerator | ImageGenerator

# 싱글톤 인스턴스 캐시
_generator_instance: ImageGeneratorType | None = None


def get_image_generator(
    *,
    force_mock: bool = False,
    force_new: bool = False,
    output_dir: Path | None = None,
) -> ImageGeneratorType:
    """이미지 생성기 인스턴스를 반환합니다.

    환경변수 UW_MODE에 따라 실제 생성기 또는 Mock 생성기를 반환합니다.

    Args:
        force_mock: True면 환경변수와 무관하게 Mock 생성기 반환
        force_new: True면 캐시를 무시하고 새 인스턴스 생성
        output_dir: 이미지 저장 디렉토리

    Returns:
        이미지 생성기 인스턴스
    """
    global _generator_instance

    if not force_new and _generator_instance is not None:
        return _generator_instance

    # 모드 결정
    mode = os.environ.get("UW_MODE", "real")

    if force_mock or mode == "mock":
        generator: ImageGeneratorType = MockImageGenerator(output_dir)
    else:
        real_gen = ImageGenerator(output_dir)
        # 실제 생성기 초기화 실패 시 Mock으로 폴백
        if not real_gen.is_available():
            logger.warning("[ImageGen] 실제 생성기 초기화 실패, Mock 모드로 폴백")
            generator = MockImageGenerator(output_dir)
        else:
            generator = real_gen

    _generator_instance = generator
    return generator


def reset_image_generator() -> None:
    """이미지 생성기 캐시를 초기화합니다.

    테스트 시 생성기를 재설정할 때 사용합니다.
    """
    global _generator_instance
    _generator_instance = None


# =============================================================================
# 헬퍼 함수
# =============================================================================


def create_fallback_response(message: str | None = None) -> ImageGenerationResponse:
    """실패 시 안전한 폴백 응답을 생성합니다.

    RULE-004: 검증 실패나 오류 시에도 안전한 응답 제공

    Args:
        message: 오류 메시지 (선택)

    Returns:
        ImageGenerationResponse: 폴백 응답
    """
    return ImageGenerationResponse(
        status=ImageGenerationStatus.SKIPPED,
        message=message or "이미지 생성을 건너뛰었습니다. 텍스트로 진행합니다.",
    )


def validate_image_request(request: ImageGenerationRequest) -> str | None:
    """이미지 생성 요청을 검증합니다.

    U-085: image_size는 SDK 값(1K/2K/4K) 또는 레거시 픽셀 값 모두 허용.

    Args:
        request: 이미지 생성 요청 객체

    Returns:
        str | None: 오류 메시지 또는 성공 시 None
    """
    if not request.prompt or len(request.prompt.strip()) < 2:
        return "프롬프트가 너무 짧습니다."

    # SDK 값 또는 레거시 값 → 정규화 후 검증
    normalized = normalize_image_size(request.image_size)
    if normalized not in SUPPORTED_IMAGE_SIZES:
        return f"지원하지 않는 이미지 크기: {request.image_size}"

    return None
</file>

<file path="frontend/src/stores/worldStore.ts">
/**
 * Unknown World - World/Session 상태 관리 (Zustand) (RU-003-Q4).
 *
 * TurnOutput 반영으로 갱신되는 세션 월드/UI 상태를 SSOT로 관리합니다.
 * App.tsx의 로컬 상태를 이 스토어로 이동하여 책임 경계를 명확히 합니다.
 *
 * 설계 원칙:
 *   - RU-003 Q1 결정: 도메인별 store 분리 (Option A)
 *   - RULE-005: Economy 인바리언트 (잔액 음수 금지)
 *   - RULE-006: ko/en i18n 정책 준수
 *
 * 확장 (U-013):
 *   - Quest/Rules/MutationEvent 상태 추가
 *   - applyTurnOutput에서 quests_updated, rules_changed 반영
 *
 * 순환 import 방지:
 *   - worldStore → (actionDeckStore/inventoryStore) 단방향만 허용
 *   - 역방향 import 금지
 *
 * @module stores/worldStore
 */

import { create } from 'zustand';
import type { TurnOutput, SceneObject, Quest, WorldRule } from '../schemas/turn';
import type { SceneCanvasState, SceneProcessingPhase } from '../types/scene';
import type { CanvasSize } from '../utils/box2d';
import { useActionDeckStore } from './actionDeckStore';
import { useInventoryStore, parseInventoryAdded } from './inventoryStore';
import { useEconomyStore } from './economyStore';
import { ITEM_SELL_PRICE_SIGNAL } from '../save/constants';
import i18n from '../i18n';

// =============================================================================
// 타입 정의
// =============================================================================

/** 재화 상태 */
export interface EconomyState {
  signal: number;
  memory_shard: number;
  /** 사용 중인 크레딧 (빚, Signal 단위, U-079) */
  credit: number;
}

/**
 * 내러티브 엔트리 타입
 *
 * U-070[Mvp]: 액션 로그 지원을 위해 type 필드 추가
 * - "narrative": 일반 게임 내러티브 (서버에서 생성)
 * - "action_log": 플레이어 행동 로그 (클라이언트에서 생성, 즉각적 피드백)
 * - "system": 시스템 메시지 (드롭 실패 등)
 */
export type NarrativeEntryType = 'narrative' | 'action_log' | 'system';

/** 내러티브 엔트리 */
export interface NarrativeEntry {
  turn: number;
  text: string;
  /** U-070: 엔트리 타입 (기본값: "narrative") */
  type?: NarrativeEntryType;
}

/**
 * 룰 변형 이벤트 (U-013: Mutation Timeline)
 * 규칙이 변경된 시점과 내용을 기록합니다.
 */
export interface MutationEvent {
  /** 변형 발생 턴 */
  turn: number;
  /** 변형된 규칙 ID */
  ruleId: string;
  /** 변형 유형: 추가/수정/제거 */
  type: 'added' | 'modified' | 'removed';
  /** 규칙 라벨 (표시용) */
  label: string;
  /** 규칙 설명 (선택) */
  description?: string;
  /** 타임스탬프 */
  timestamp: number;
}

/**
 * U-079: 재화 획득 토스트 알림 데이터.
 * 아이템 판매, 퀘스트 보상 등 재화 변동 시 팝업 표시.
 */
export interface CurrencyToast {
  /** 토스트 고유 ID (중복 방지) */
  id: string;
  /** 변동된 Signal 양 (양수: 획득, 음수: 소비) */
  signalDelta: number;
  /** 변동 사유 표시 텍스트 */
  reason: string;
  /** 생성 시간 (자동 닫힘 계산용) */
  createdAt: number;
}

/** World/Session 상태 */
export interface WorldState {
  /** 재화 상태 (RULE-005) */
  economy: EconomyState;
  /** 연결 상태 */
  isConnected: boolean;
  /** Scene Canvas 상태 (U-031) */
  sceneState: SceneCanvasState;
  /** Scene Objects (U-010: 핫스팟 오버레이) */
  sceneObjects: SceneObject[];
  /** 내러티브 히스토리 */
  narrativeEntries: NarrativeEntry[];
  /** 현재 턴 카운트 */
  turnCount: number;

  // ============ U-013: Quest + Rule Board 확장 ============

  /** 현재 퀘스트/목표 목록 */
  quests: Quest[];
  /** 현재 적용 중인 규칙 목록 */
  activeRules: WorldRule[];
  /** 룰 변형 이벤트 타임라인 (최신순) */
  mutationTimeline: MutationEvent[];

  // ============ U-085: Scene Canvas 표시 크기 (SSOT) ============

  /**
   * Scene Canvas의 실제 렌더링 크기(px) (U-085).
   * ResizeObserver로 측정된 값이 디바운스(100ms) + 5px 이상 변화 시 갱신됩니다.
   * 이미지 생성 요청 시 aspect_ratio/image_size 선택의 SSOT로 사용됩니다.
   */
  sceneCanvasSize: CanvasSize;

  // ============ U-089: 정밀분석 상태 ============

  /**
   * 정밀분석(Agentic Vision) 실행 중 여부 (U-089).
   * true일 때 SceneImage는 기존 이미지를 유지하고 분석 전용 오버레이를 표시합니다.
   */
  isAnalyzing: boolean;

  // ============ U-079: 재화 획득 토스트 알림 ============

  /**
   * 현재 표시 중인 토스트 알림 (U-079).
   * null이면 토스트 없음, 값이 있으면 일정 시간 후 자동 사라짐.
   */
  currencyToast: CurrencyToast | null;
}

/** World Store 액션 */
export interface WorldActions {
  /**
   * TurnOutput을 받아 모든 관련 상태를 업데이트합니다.
   * 이 메서드가 TurnOutput 반영의 SSOT입니다.
   */
  applyTurnOutput: (output: TurnOutput) => void;

  /**
   * 시스템 내러티브를 추가합니다 (턴 미발생 피드백용).
   * 드롭 실패 등 턴을 발생시키지 않는 피드백에 사용합니다.
   */
  appendSystemNarrative: (text: string) => void;

  /**
   * U-070[Mvp]: 액션 로그를 추가합니다.
   * 플레이어 행동에 대한 즉각적 피드백으로, TurnInput 전송 전에 호출합니다.
   * PRD 9.0: "행동 실행: ..." 형식으로 표시됩니다.
   */
  appendActionLog: (text: string) => void;

  /** Scene 상태 설정 */
  setSceneState: (state: SceneCanvasState) => void;

  /** 연결 상태 설정 */
  setConnected: (connected: boolean) => void;

  /** 경제 상태 설정 (직접 조작용, 일반적으로 applyTurnOutput 사용) */
  setEconomy: (economy: EconomyState) => void;

  /** Scene Objects 설정 (직접 조작용) */
  setSceneObjects: (objects: SceneObject[]) => void;

  /** 초기화 (초기 내러티브 메시지 포함) */
  initialize: (welcomeMessage: string) => void;

  /** 상태 완전 초기화 */
  reset: () => void;

  // ============ U-066: Late-binding 이미지 관리 ============

  /**
   * 이미지 로딩 상태를 설정합니다 (U-066).
   * 이미지 생성 시작 시 호출하여 로딩 인디케이터를 표시합니다.
   *
   * @param turnId - 이미지를 요청한 턴 ID
   */
  setImageLoading: (turnId: number) => void;

  /**
   * Late-binding 이미지를 적용합니다 (U-066).
   * 이미지 생성 완료 시 호출하여, turnId가 일치할 때만 이미지를 반영합니다.
   *
   * @param imageUrl - 생성된 이미지 URL
   * @param turnId - 이미지를 요청한 턴 ID (가드용)
   * @returns 이미지가 적용되었는지 여부
   */
  applyLateBindingImage: (imageUrl: string, turnId: number) => boolean;

  /**
   * 이미지 로딩을 취소합니다 (U-066).
   * 새 턴 시작 또는 이미지 생성 실패 시 호출합니다.
   */
  cancelImageLoading: () => void;

  // ============ U-085: Scene Canvas 크기 SSOT ============

  /**
   * Scene Canvas 표시 크기를 설정합니다 (U-085).
   * SceneCanvas 컴포넌트의 ResizeObserver에서 호출합니다.
   *
   * @param size - Scene Canvas 크기 (width, height px)
   */
  setSceneCanvasSize: (size: CanvasSize) => void;

  // ============ U-071: 처리 단계 UI 관리 ============

  /**
   * 처리 단계를 설정합니다 (U-071).
   * Scene Canvas에 현재 처리 상태를 표시하기 위해 사용합니다.
   *
   * @param phase - 현재 처리 단계 (idle, processing, image_pending, rendering)
   */
  setProcessingPhase: (phase: SceneProcessingPhase) => void;

  // ============ U-089: 정밀분석 상태 관리 ============

  /**
   * 정밀분석(Agentic Vision) 실행 상태를 설정합니다 (U-089).
   * true로 설정하면 SceneImage가 기존 이미지를 유지하면서 분석 전용 오버레이를 표시합니다.
   *
   * @param analyzing - 분석 실행 중 여부
   */
  setIsAnalyzing: (analyzing: boolean) => void;

  // ============ U-079: 아이템 판매 + 토스트 ============

  /**
   * 아이템을 판매하여 Signal을 획득합니다 (U-079).
   * 인벤토리에서 수량 1 감소, economy에 판매 가격 추가, Ledger 기록.
   *
   * @param itemId - 판매할 아이템 ID
   * @param itemName - 아이템 이름 (토스트 표시용)
   */
  sellItem: (itemId: string, itemName: string) => void;

  /**
   * 재화 획득 토스트를 표시합니다 (U-079).
   * 일정 시간 후 자동으로 사라집니다.
   */
  showCurrencyToast: (toast: Omit<CurrencyToast, 'id' | 'createdAt'>) => void;

  /**
   * 토스트를 닫습니다 (U-079).
   */
  dismissCurrencyToast: () => void;
}

export type WorldStore = WorldState & WorldActions;

// =============================================================================
// 초기 상태
// =============================================================================

/**
 * 초기 상태를 생성합니다.
 *
 * ## 중요: 이 값들은 "플레이 전 placeholder"입니다.
 *
 * 실제 게임 시작 값은 startSessionFromProfile()에서 프로필 데이터로 주입됩니다.
 * profile_select 상태에서는 HUD가 노출되지 않으므로
 * 이 placeholder 값이 화면에 표시될 일은 없습니다.
 *
 * @see save/sessionLifecycle.ts
 */
function createInitialState(): WorldState {
  return {
    // RU-004-Q5: Placeholder - 실제 값은 프로필/세이브에서 주입됨
    economy: { signal: 100, memory_shard: 5, credit: 0 },
    isConnected: true,
    sceneState: {
      status: 'default',
      message: '',
      imageUrl: undefined,
      previousImageUrl: undefined,
      processingPhase: 'idle',
      imageLoading: false,
      pendingImageTurnId: undefined,
    },
    sceneObjects: [],
    narrativeEntries: [],
    turnCount: 0,
    // U-013: Quest + Rule Board 초기 상태
    quests: [],
    activeRules: [],
    mutationTimeline: [],
    // U-085: Scene Canvas 크기 (초기값 0x0, 측정 후 갱신)
    sceneCanvasSize: { width: 0, height: 0 },
    // U-089: 정밀분석 상태
    isAnalyzing: false,
    // U-079: 재화 획득 토스트
    currencyToast: null,
  };
}

// =============================================================================
// Zustand Store
// =============================================================================

/**
 * World/Session 상태 스토어.
 *
 * TurnOutput 반영의 SSOT로, App.tsx의 로컬 상태를 대체합니다.
 *
 * @example
 * ```tsx
 * // 컴포넌트에서 상태 구독
 * const { economy, narrativeEntries } = useWorldStore();
 *
 * // TurnOutput 반영 (스트림 완료 시)
 * const applyTurnOutput = useWorldStore((state) => state.applyTurnOutput);
 * applyTurnOutput(turnOutput);
 *
 * // 시스템 피드백 추가 (드롭 실패 등)
 * const appendSystemNarrative = useWorldStore((state) => state.appendSystemNarrative);
 * appendSystemNarrative('아이템을 사용할 수 없습니다.');
 * ```
 */
export const useWorldStore = create<WorldStore>((set, get) => ({
  // 초기 상태
  ...createInitialState(),

  // 액션

  applyTurnOutput: (output) => {
    const state = get();

    // 1. 턴 카운트 증가
    const newTurnCount = state.turnCount + 1;

    // 2. 내러티브 추가 (U-070: type 명시)
    const newNarrativeEntry: NarrativeEntry = {
      turn: newTurnCount,
      text: output.narrative,
      type: 'narrative',
    };

    const newNarrativeEntries = [...state.narrativeEntries, newNarrativeEntry];

    // U-072: Scanner 힌트 유도 (Option A: 백엔드 플래그 기반)
    if (output.hints?.scanner) {
      newNarrativeEntries.push({
        turn: newTurnCount,
        text: i18n.t('scanner.hint_narrative'),
        type: 'system',
      });
    }

    // 3. 경제 상태 업데이트 (RULE-005: balance_after 반영)
    const newEconomy: EconomyState = {
      signal: output.economy.balance_after.signal,
      memory_shard: output.economy.balance_after.memory_shard,
      credit: output.economy.credit,
    };

    // 4. Scene Objects 업데이트 (U-010: 핫스팟 오버레이)
    // U-090: 핫스팟 상태 관리 정책
    //   - 새 이미지 생성(장면 전환) → 핫스팟 전체 초기화 (Q1: Option A)
    //   - 서버에서 objects 비어있음(일반 턴) → 기존 핫스팟 유지
    //   - 서버에서 objects 있음(정밀분석 턴) → 기존 핫스팟에 병합
    //
    // 장면 전환 감지:
    //   - render.image_url이 존재 → 이번 턴에서 새 이미지가 생성됨 (동기 생성 완료)
    //   - render.image_job.should_generate === true → 비동기(late-binding) 이미지 생성 예정
    //   어느 경우든 새 장면이므로 기존 핫스팟을 초기화한다.
    const isNewImageGeneration =
      !!output.render?.image_url || output.render?.image_job?.should_generate === true;

    let newSceneObjects: SceneObject[];

    if (isNewImageGeneration) {
      // Q1 Option A: 장면 전환(새 이미지 생성) → 핫스팟 전체 초기화
      // 새 장면에서는 정밀분석을 다시 해야 함
      newSceneObjects = [];
    } else if (output.ui.objects.length > 0) {
      // 정밀분석 결과 있음 → 기존 핫스팟에 병합
      // 동일 ID는 새 결과로 업데이트, 새 ID는 추가
      const mergedMap = new Map(state.sceneObjects.map((o) => [o.id, o]));
      for (const obj of output.ui.objects) {
        mergedMap.set(obj.id, obj);
      }
      newSceneObjects = Array.from(mergedMap.values());
    } else {
      // 일반 턴(objects 비어있음) → 기존 핫스팟 유지
      newSceneObjects = state.sceneObjects;
    }

    // 5. Scene 상태 전이 (RU-003-T1: Scene 이미지 SSOT)
    // - output.ui.scene.image_url이 존재하면 'scene' 상태로 전환
    // - 없으면 'default' 상태 유지
    // - safety.blocked인 경우 'blocked' 상태로 전환
    let newSceneState: SceneCanvasState;
    const currentImageUrl = state.sceneState.imageUrl ?? state.sceneState.previousImageUrl;

    if (output.safety.blocked) {
      newSceneState = {
        status: 'blocked',
        message: output.safety.message ?? undefined,
        previousImageUrl: currentImageUrl,
      };
    } else if (output.ui.scene?.image_url || output.render?.image_url) {
      // U-053: render.image_url 또는 ui.scene.image_url 중 하나라도 있으면 scene 상태로 전환
      const imageUrl = output.ui.scene?.image_url || output.render?.image_url;
      newSceneState = {
        status: 'scene',
        imageUrl: imageUrl!,
        message: output.ui.scene?.alt_text ?? undefined,
        // 새로운 이미지가 왔으므로 이전 이미지는 보존 (로딩 중이 아님)
        previousImageUrl: currentImageUrl,
      };
    } else {
      newSceneState = {
        status: 'default',
        message: '',
        previousImageUrl: currentImageUrl,
      };
    }

    // 7. 하위 스토어 업데이트 (순환 import 방지: worldStore → 하위 store 단방향)
    // Action Deck 카드 업데이트 (U-009)
    useActionDeckStore.getState().setCards(output.ui.action_deck.cards);

    // Inventory 업데이트 (U-011)
    if (output.world.inventory_added.length > 0) {
      useInventoryStore.getState().addItems(parseInventoryAdded(output.world.inventory_added));
    }
    // U-096: 아이템 소비 시 fade-out 애니메이션 후 제거
    if (output.world.inventory_removed.length > 0) {
      const removedIds = output.world.inventory_removed;
      const invStore = useInventoryStore.getState();

      // 1단계: 소비 애니메이션 시작 (fade-out CSS 클래스 적용)
      invStore.markConsuming(removedIds);

      // 2단계: 애니메이션 완료 후 실제 제거 (500ms = CSS transition 시간)
      setTimeout(() => {
        useInventoryStore.getState().clearConsuming(removedIds);
      }, 500);
    }

    // Economy Store 업데이트 (U-014: Ledger 기록)
    // U-069: 서버에서 전달된 model_label 사용 (FAST/QUALITY 티어링)
    const economyStore = useEconomyStore.getState();
    economyStore.addLedgerEntry({
      turnId: newTurnCount,
      reason: 'economy.ledger_reason.turn_cost', // U-099: i18n 키 기반 사유 (언어 혼합 방지)
      cost: output.economy.cost,
      balanceAfter: output.economy.balance_after,
      modelLabel: output.agent_console.model_label ?? 'FAST',
      lowBalanceWarning: output.economy.low_balance_warning,
    });
    // 잔액 부족 상태 업데이트
    economyStore.updateBalanceLowStatus(newEconomy);

    // 6. Quest 상태 업데이트 (U-013, U-078: 목표 시스템 강화)
    // quests_updated는 전체 퀘스트 목록이 아닌 "업데이트된" 퀘스트만 포함
    // 기존 퀘스트를 업데이트하거나 새 퀘스트를 추가
    // U-078: 서브 목표 완료 시 보상 알림 시스템 내러티브 추가
    const newQuests = [...state.quests];
    for (const updatedQuest of output.world.quests_updated) {
      const existingIndex = newQuests.findIndex((q) => q.id === updatedQuest.id);
      if (existingIndex >= 0) {
        // U-078: 미완료 → 완료 전환 감지 (보상 피드백용)
        const prevQuest = newQuests[existingIndex];
        if (
          !prevQuest.is_completed &&
          updatedQuest.is_completed &&
          updatedQuest.reward_signal > 0
        ) {
          newNarrativeEntries.push({
            turn: newTurnCount,
            text: `🎯 ${i18n.t('quest.objective_complete')} ${i18n.t('quest.reward_earned', { signal: updatedQuest.reward_signal })}`,
            type: 'system',
          });
        }
        // 기존 퀘스트 업데이트
        newQuests[existingIndex] = updatedQuest;
      } else {
        // 새 퀘스트 추가
        newQuests.push(updatedQuest);
      }
    }

    // 7. Rules 상태 업데이트 + Mutation Timeline 기록 (U-013)
    const newActiveRules = [...state.activeRules];
    const newMutationEvents: MutationEvent[] = [];
    const now = Date.now();

    for (const changedRule of output.world.rules_changed) {
      const existingIndex = newActiveRules.findIndex((r) => r.id === changedRule.id);
      if (existingIndex >= 0) {
        // 기존 규칙 수정
        newActiveRules[existingIndex] = changedRule;
        newMutationEvents.push({
          turn: newTurnCount,
          ruleId: changedRule.id,
          type: 'modified',
          label: changedRule.label,
          description: changedRule.description ?? undefined,
          timestamp: now,
        });
      } else {
        // 새 규칙 추가
        newActiveRules.push(changedRule);
        newMutationEvents.push({
          turn: newTurnCount,
          ruleId: changedRule.id,
          type: 'added',
          label: changedRule.label,
          description: changedRule.description ?? undefined,
          timestamp: now,
        });
      }
    }

    // 타임라인에 새 이벤트 추가 (최신순 정렬)
    const updatedTimeline = [...newMutationEvents, ...state.mutationTimeline];

    // 8. 상태 업데이트 (RU-003-T1: sceneState 포함, U-013: quest/rules)
    set({
      turnCount: newTurnCount,
      narrativeEntries: newNarrativeEntries,
      economy: newEconomy,
      sceneObjects: newSceneObjects,
      sceneState: newSceneState,
      // U-013 확장
      quests: newQuests,
      activeRules: newActiveRules,
      mutationTimeline: updatedTimeline,
    });

    // === 향후 확장 슬롯 (RU-003-Q4 Step 4) ===
    // TODO: output.world.memory_pins → Memory Pin 패널 업데이트
  },

  appendSystemNarrative: (text) => {
    set((state) => ({
      narrativeEntries: [
        ...state.narrativeEntries,
        {
          turn: state.turnCount, // 현재 턴으로 기록 (턴 증가 없음)
          text,
          type: 'system',
        },
      ],
    }));
  },

  // U-070[Mvp]: 액션 로그 추가
  appendActionLog: (text) => {
    set((state) => ({
      narrativeEntries: [
        ...state.narrativeEntries,
        {
          turn: state.turnCount, // 현재 턴으로 기록 (턴 증가 없음)
          text,
          type: 'action_log',
        },
      ],
    }));
  },

  setSceneState: (sceneState) => {
    // U-071 버그 수정: processingPhase를 보존하며 병합
    set((state) => ({
      sceneState: {
        ...state.sceneState,
        ...sceneState,
      },
    }));
  },

  setConnected: (isConnected) => {
    set({ isConnected });
  },

  setEconomy: (economy) => {
    set({ economy });
  },

  setSceneObjects: (sceneObjects) => {
    set({ sceneObjects });
  },

  initialize: (welcomeMessage) => {
    set({
      ...createInitialState(),
      narrativeEntries: [{ turn: 0, text: welcomeMessage, type: 'narrative' }],
    });
  },

  reset: () => {
    set(createInitialState());
  },

  // ============ U-066: Late-binding 이미지 관리 ============

  setImageLoading: (turnId) => {
    set((state) => ({
      sceneState: {
        ...state.sceneState,
        imageLoading: true,
        pendingImageTurnId: turnId,
        sceneRevision: turnId,
        // 이전 이미지 URL 보존 (Option A: 이전 이미지 유지)
        previousImageUrl: state.sceneState.imageUrl ?? state.sceneState.previousImageUrl,
      },
    }));
  },

  applyLateBindingImage: (imageUrl, turnId) => {
    const state = get();

    // late-binding 가드: pendingImageTurnId와 일치할 때만 적용
    if (state.sceneState.pendingImageTurnId !== turnId) {
      // 이미 새 턴이 시작되어 이전 요청은 무시
      return false;
    }

    set({
      sceneState: {
        status: 'scene',
        imageUrl,
        imageLoading: false,
        pendingImageTurnId: undefined,
        sceneRevision: turnId,
        // 이전 이미지 URL은 성공 시 현재 이미지로 대체
        previousImageUrl: undefined,
      },
    });

    return true;
  },

  cancelImageLoading: () => {
    set((state) => ({
      sceneState: {
        ...state.sceneState,
        imageLoading: false,
        pendingImageTurnId: undefined,
        // 이전 이미지 유지 (폴백)
        imageUrl: state.sceneState.previousImageUrl ?? state.sceneState.imageUrl,
        previousImageUrl: undefined,
      },
    }));
  },

  // ============ U-085: Scene Canvas 크기 SSOT ============

  setSceneCanvasSize: (size) => {
    set({ sceneCanvasSize: size });
  },

  // ============ U-071: 처리 단계 UI 관리 ============

  setProcessingPhase: (phase) => {
    set((state) => ({
      sceneState: {
        ...state.sceneState,
        processingPhase: phase,
      },
    }));
  },

  // ============ U-089: 정밀분석 상태 관리 ============

  setIsAnalyzing: (analyzing) => {
    set({ isAnalyzing: analyzing });
  },

  // ============ U-079: 아이템 판매 + 토스트 ============

  sellItem: (itemId, itemName) => {
    const state = get();

    // 1. 인벤토리에서 아이템 수량 감소 (1개 제거)
    const invStore = useInventoryStore.getState();
    const item = invStore.items.find((i) => i.id === itemId);
    if (!item) return; // 아이템 없으면 무시

    // fade-out 애니메이션 후 제거
    invStore.markConsuming([itemId]);
    setTimeout(() => {
      useInventoryStore.getState().clearConsuming([itemId]);
    }, 500);

    // 2. Signal 추가 (RULE-005: 잔액 음수 금지이므로 추가만)
    const sellPrice = ITEM_SELL_PRICE_SIGNAL;
    const newEconomy: EconomyState = {
      signal: state.economy.signal + sellPrice,
      memory_shard: state.economy.memory_shard,
      credit: state.economy.credit,
    };

    // 3. 내러티브에 판매 기록 추가
    const sellText = i18n.t('inventory.sell_narrative', {
      item: itemName,
      signal: sellPrice,
    });

    set({
      economy: newEconomy,
      narrativeEntries: [
        ...state.narrativeEntries,
        {
          turn: state.turnCount,
          text: sellText,
          type: 'system' as const,
        },
      ],
    });

    // 4. Economy Store에 Ledger 기록
    const economyStore = useEconomyStore.getState();
    economyStore.addLedgerEntry({
      turnId: state.turnCount,
      reason: `inventory.sell_ledger_reason|${itemName}`, // U-099: 키|파라미터 형식
      cost: { signal: -sellPrice, memory_shard: 0 }, // 음수 cost = 수입
      balanceAfter: newEconomy,
      modelLabel: 'FAST',
    });
    economyStore.updateBalanceLowStatus(newEconomy);

    // 5. 토스트 알림
    get().showCurrencyToast({
      signalDelta: sellPrice,
      reason: i18n.t('inventory.sell_toast', { item: itemName }),
    });
  },

  showCurrencyToast: (toastData) => {
    const toast: CurrencyToast = {
      ...toastData,
      id: `toast-${Date.now()}`,
      createdAt: Date.now(),
    };
    set({ currencyToast: toast });

    // 3초 후 자동 닫힘
    setTimeout(() => {
      const current = useWorldStore.getState().currencyToast;
      if (current?.id === toast.id) {
        useWorldStore.getState().dismissCurrencyToast();
      }
    }, 3000);
  },

  dismissCurrencyToast: () => {
    set({ currencyToast: null });
  },
}));

// =============================================================================
// 셀렉터 (성능 최적화용)
// =============================================================================

/** 경제 상태 셀렉터 */
export const selectEconomy = (state: WorldStore) => state.economy;

/** Signal 잔액 셀렉터 */
export const selectSignal = (state: WorldStore) => state.economy.signal;

/** Memory Shard 잔액 셀렉터 */
export const selectMemoryShard = (state: WorldStore) => state.economy.memory_shard;

/** 연결 상태 셀렉터 */
export const selectIsConnected = (state: WorldStore) => state.isConnected;

/** Scene 상태 셀렉터 */
export const selectSceneState = (state: WorldStore) => state.sceneState;

/** Scene Objects 셀렉터 */
export const selectSceneObjects = (state: WorldStore) => state.sceneObjects;

/** 내러티브 엔트리 셀렉터 */
export const selectNarrativeEntries = (state: WorldStore) => state.narrativeEntries;

/** 턴 카운트 셀렉터 */
export const selectTurnCount = (state: WorldStore) => state.turnCount;

// ============ U-013: Quest + Rule Board 셀렉터 ============

/** 퀘스트 목록 셀렉터 */
export const selectQuests = (state: WorldStore) => state.quests;

/** 활성 규칙 목록 셀렉터 */
export const selectActiveRules = (state: WorldStore) => state.activeRules;

/** 뮤테이션 타임라인 셀렉터 */
export const selectMutationTimeline = (state: WorldStore) => state.mutationTimeline;

/** 진행 중인 퀘스트 셀렉터 */
export const selectActiveQuests = (state: WorldStore) =>
  state.quests.filter((q) => !q.is_completed);

/** 완료된 퀘스트 셀렉터 */
export const selectCompletedQuests = (state: WorldStore) =>
  state.quests.filter((q) => q.is_completed);

// ============ U-078: 목표 시스템 셀렉터 ============

/** 주 목표(Main Objective) 셀렉터 - is_main=true인 첫 번째 퀘스트 */
export const selectMainObjective = (state: WorldStore) =>
  state.quests.find((q) => q.is_main) ?? null;

/** 서브 목표(Sub-objectives) 셀렉터 - is_main=false인 퀘스트 */
export const selectSubObjectives = (state: WorldStore) => state.quests.filter((q) => !q.is_main);

// ============ U-085: Scene Canvas 크기 셀렉터 ============

/** Scene Canvas 크기 셀렉터 */
export const selectSceneCanvasSize = (state: WorldStore) => state.sceneCanvasSize;

// ============ U-089: 정밀분석 셀렉터 ============

/** 정밀분석 실행 중 여부 셀렉터 */
export const selectIsAnalyzing = (state: WorldStore) => state.isAnalyzing;

/** U-079: 재화 획득 토스트 셀렉터 */
export const selectCurrencyToast = (state: WorldStore) => state.currencyToast;

// =============================================================================
// DEV: 디버그용 글로벌 노출 (프로덕션에서 제거됨)
// =============================================================================

if (import.meta.env.DEV && typeof window !== 'undefined') {
  (window as unknown as Record<string, unknown>).__worldStore = useWorldStore;
}
</file>

<file path="frontend/src/locales/en-US/translation.json">
{
  "language": {
    "toggle": "Change Language",
    "toggle_tooltip": "Click to change language. A new game will start after change.",
    "ko-KR": "한국어",
    "en-US": "English"
  },
  "error": {
    "unknown_error": "An unknown error occurred.",
    "response_processing": "[System] An error occurred while processing response data.",
    "connection_failed": "[System] Failed to connect to server. Please try again.",
    "rate_limited": "API Rate Limit Exceeded",
    "rate_limited_detail": "Too many requests. Please wait a moment and try again.",
    "retry_button": "Retry",
    "retry_countdown": "Retry available in {{seconds}}s"
  },
  "profile": {
    "select_title": "Select Your Profile",
    "select_hint": "Each profile has different starting conditions and objectives",
    "or": "or",
    "continue_saved": "Continue Saved Game",
    "change": "Change Profile",
    "change_tooltip": "Start a new game with a different profile",
    "narrator": {
      "name": "Narrator",
      "description": "Explore diverse stories with abundant resources",
      "welcome": "Welcome to the Ancient Library. Forgotten tales slumber within these walls...",
      "items": {
        "ancient_tome": "Ancient Tome",
        "quill_pen": "Quill Pen",
        "memory_fragment": "Memory Fragment"
      },
      "quest": {
        "discover_origin": "Discover the World's Origin",
        "discover_origin_desc": "Find clues and uncover how this world was created",
        "collect_memories": "Collect 3 Memory Fragments",
        "read_ancient_tome": "Decipher the Ancient Tome"
      },
      "rule": {
        "time_flows": "Flow of Time",
        "time_flows_desc": "Time flows normally",
        "memories_persist": "Memory Persistence",
        "memories_persist_desc": "Once obtained, memories never fade"
      },
      "scene": {
        "bookshelf": "Mysterious Bookshelf",
        "bookshelf_hint": "Ancient books are glowing",
        "portal": "Glowing Portal",
        "portal_hint": "It seems to lead somewhere"
      }
    },
    "explorer": {
      "name": "Explorer",
      "description": "Explore unknown territories and uncover secrets",
      "welcome": "You wake up in a dark maze. You must find the exit and escape...",
      "items": {
        "compass": "Compass",
        "rope": "Rope",
        "lantern": "Lantern",
        "map_fragment": "Map Fragment"
      },
      "quest": {
        "find_exit": "Find the Exit",
        "find_exit_desc": "Explore the maze and find the hidden exit to escape",
        "explore_areas": "Explore 3 Areas",
        "gather_supplies": "Gather Supplies"
      },
      "rule": {
        "gravity": "Gravity Law",
        "gravity_desc": "Objects fall downward",
        "darkness": "Darkness Law",
        "darkness_desc": "You cannot see without light"
      },
      "scene": {
        "door": "Ancient Door",
        "door_hint": "Looks like it needs a key",
        "mechanism": "Strange Mechanism",
        "mechanism_hint": "It might be operable",
        "passage": "Hidden Passage",
        "passage_hint": "Where does it lead?"
      }
    },
    "tech": {
      "name": "Tech Expert",
      "description": "Strategize efficiently with limited resources",
      "welcome": "System boot complete. Find the optimal path with limited energy...",
      "items": {
        "data_core": "Data Core",
        "circuit_board": "Circuit Board",
        "energy_cell": "Energy Cell",
        "scanner": "Scanner Device"
      },
      "quest": {
        "analyze_system": "Complete System Analysis",
        "analyze_system_desc": "Access the core terminal and analyze the system structure",
        "optimize_resources": "Optimize Resource Efficiency",
        "scan_terminal": "Perform Terminal Scan"
      },
      "rule": {
        "energy_conservation": "Energy Conservation",
        "energy_conservation_desc": "Energy is neither created nor destroyed",
        "data_integrity": "Data Integrity",
        "data_integrity_desc": "Corrupted data cannot be recovered",
        "system_limits": "System Limits",
        "system_limits_desc": "There are limits to concurrent processing"
      },
      "scene": {
        "terminal": "Main Terminal",
        "terminal_hint": "You can access the system",
        "conduit": "Power Conduit",
        "conduit_hint": "Energy is flowing through it"
      }
    }
  },
  "reset": {
    "button": "Reset",
    "confirm": "Click again to confirm",
    "cancel": "Cancel",
    "tooltip": "Return to the initial state of current profile"
  },
  "demo": {
    "items": {
      "keycard-alpha": {
        "name": "Keycard A"
      },
      "medkit": {
        "name": "Medkit"
      },
      "flashlight": {
        "name": "Flashlight"
      },
      "data-chip": {
        "name": "Data Chip"
      }
    },
    "scene": {
      "terminal": {
        "label": "Terminal",
        "hint": "An active terminal"
      },
      "door": {
        "label": "Door",
        "hint": "It appears to be locked"
      }
    },
    "quest": {
      "terminal": {
        "label": "Access the terminal"
      },
      "escape": {
        "label": "Find facility exit"
      },
      "collect": {
        "label": "Collect data chips"
      }
    },
    "rule": {
      "gravity": {
        "label": "Gravity Law",
        "description": "Objects fall downward"
      },
      "time": {
        "label": "Time Flow",
        "description": "Time flows at normal speed"
      }
    }
  },
  "quest": {
    "empty": "[ NO OBJECTIVES ]",
    "completed": "DONE",
    "section": {
      "active": "Active",
      "completed": "Completed"
    },
    "main_objective": "Main Objective",
    "sub_objectives": "Sub-objectives",
    "progress": "Progress {{progress}}%",
    "reward_preview": "Reward: {{signal}} Signal",
    "reward_earned": "+{{signal}} Signal earned!",
    "objective_complete": "Objective Complete!",
    "free_exploration": "Free Exploration",
    "free_exploration_desc": "Explore the world freely without a set objective",
    "no_sub_objectives": "No sub-objectives yet",
    "tracker_no_objective": "No Objective"
  },
  "rule_board": {
    "empty": "[ NO RULES ]",
    "active_count": "Active Rules: {{count}}"
  },
  "mutation": {
    "empty": "[ NO MUTATIONS ]",
    "timeline_title": "Mutation Timeline",
    "event_count": "{{count}} events",
    "more_events": "+{{count}} more",
    "turn_label": "T{{turn}}",
    "type": {
      "added": "Added",
      "modified": "Modified",
      "removed": "Removed"
    }
  },
  "scene": {
    "status": {
      "default": "NO SIGNAL DATA",
      "loading": "SYNCHRONIZING...",
      "offline": "CONNECTION LOST",
      "blocked": "ACCESS RESTRICTED",
      "low_signal": "LOW SIGNAL",
      "image_error": "Unable to load scene image.",
      "image_loading": "Loading scene image...",
      "image_generating": "Generating new scene...",
      "initial_sync": "Awaiting global data synchronization...",
      "syncing": "Synchronizing data...",
      "alt": "Scene Image"
    },
    "processing": {
      "processing": "Generating scene...",
      "image_pending": "Forming image...",
      "rendering": "Applying results..."
    },
    "analyzing": {
      "message": "ANALYZING SCENE...",
      "hint": "Scanning for objects"
    },
    "hotspot": {
      "layer_label": "Clickable Objects Area",
      "hint_prefix": "Hint",
      "click_action": "Click {{label}}",
      "drop_hint": "Drop here to use",
      "drop_action": "Use {{item}} on {{target}}",
      "drop_invalid": "You cannot use {{item}} there.",
      "demo_hint": "[DEMO TARGET]"
    }
  },
  "agent": {
    "console": {
      "queue": "Queue",
      "badges": "Badges",
      "repair": "Auto-repair",
      "status": {
        "idle": "IDLE",
        "processing": "PROCESSING"
      },
      "badges_empty": "[ Awaiting Validation ]",
      "repaired": "(Repaired)",
      "phase": {
        "parse": "Parse",
        "validate": "Validate",
        "plan": "Plan",
        "resolve": "Resolve",
        "render": "Render",
        "verify": "Verify",
        "commit": "Commit"
      },
      "badge": {
        "schema": "Schema",
        "economy": "Economy",
        "safety": "Safety",
        "consistency": "Consistency",
        "ok": "OK",
        "fail": "FAIL"
      },
      "model": {
        "fast": "Fast (FAST)",
        "quality": "Quality (QUALITY)",
        "cheap": "Cheap",
        "ref": "Reference"
      },
      "expand": "Details",
      "collapse": "Collapse",
      "queue_idle": "Waiting..."
    }
  },
  "ui": {
    "logo": "UNKNOWN WORLD",
    "command_placeholder": "Enter command...",
    "processing": "Processing...",
    "execute": "EXECUTE",
    "wait": "WAIT",
    "panel_placeholder": "[ Ready ]",
    "scale_decrease": "Decrease text size",
    "scale_increase": "Increase text size",
    "scale_label": "UI Scale Settings",
    "input_locked": "Processing…",
    "input_locked_detail": "Awaiting turn results"
  },
  "economy": {
    "signal": "Signal",
    "shard": "Shard",
    "signal_cost": "Signal cost",
    "shard_cost": "Shard cost",
    "risk_level": "Risk level",
    "hud_label": "Economy Status",
    "estimated_cost": "Est. Cost",
    "confirmed_cost": "Confirmed",
    "insufficient_funds": "Insufficient funds",
    "low_balance_warning": "Low balance",
    "low_balance_title": "Low Signal - Alternatives",
    "credit": "Credit",
    "credit_desc": "Current credit (debt) being used. Will be repaid first when earning currency.",
    "fast_fallback_notice": "Images will be generated in basic quality (FAST) for free",
    "hint_sell_items": "Sell inventory items to earn Signal",
    "hint_earn_actions": "Select currency earning cards (\u26A1)",
    "hint_complete_quests": "Complete objectives to earn rewards",
    "alternatives_title": "Alternatives",
    "alternative_text_only": "Text-only (no images)",
    "alternative_low_quality": "Low quality / Fast response",
    "ledger_title": "Resource Log",
    "ledger_empty": "[ NO HISTORY ]",
    "model_label": {
      "FAST": "Fast",
      "QUALITY": "Quality",
      "CHEAP": "Cheap",
      "REF": "Ref"
    },
    "ledger_reason": {
      "turn_cost": "Turn Cost"
    }
  },
  "connection": {
    "online": "ONLINE",
    "offline": "OFFLINE"
  },
  "inventory": {
    "empty": "[ NO ITEMS ]",
    "empty_hint": "Explore scenes to find items",
    "count": "Inventory ({{count}})",
    "grid_label": "Inventory Items",
    "list_label": "Inventory Items",
    "item_label": "{{name}} (Qty: {{quantity}})",
    "drag_hint": "Drag to use",
    "item_consumed": "{{name}} consumed",
    "sell_tooltip": "Sell (+{{price}} Signal)",
    "sell_aria": "Sell {{item}} (+{{price}} Signal)",
    "sell_narrative": "\uD83D\uDCB0 Sold {{item}} and earned {{signal}} Signal.",
    "sell_toast": "Sold {{item}}!",
    "sell_ledger_reason": "Item sold",
    "sell_confirm": "Confirm?"
  },
  "interaction": {
    "hotspot_click": "Click to investigate",
    "item_drag": "Drag to use",
    "drop_here": "Drop here",
    "_u117_removed": "Onboarding guide keys removed (U-117)"
  },
  "common": {
    "next": "Next"
  },
  "panel": {
    "inventory": {
      "title": "Inventory",
      "placeholder": "[ Drag & Drop Area ]"
    },
    "quest": {
      "title": "Quest",
      "placeholder": "[ Objectives / Quest List ]"
    },
    "rule_board": {
      "title": "Rule Board",
      "placeholder": "[ World Rules / Mutation Timeline ]"
    },
    "agent_console": {
      "title": "Agent Console"
    },
    "memory_pin": {
      "title": "Memory Pin",
      "placeholder": "[ Pinned Memories / Clues ]"
    },
    "scanner": {
      "title": "Scanner",
      "placeholder": "[ Image Upload Slot ]"
    }
  },
  "scanner": {
    "dropzone_label": "Drop image or click to upload",
    "dropzone_text": "Drop Image Here",
    "dropzone_hint": "Or click to browse files",
    "upload_label": "Upload image",
    "preview_alt": "Upload image preview",
    "uploading": "Uploading...",
    "analyzing": "Analyzing...",
    "retry": "Retry",
    "cancel": "Cancel",
    "select_items": "Select items to add to inventory",
    "add_to_inventory": "Add ({{count}})",
    "detected_objects": "Objects detected: {{count}}",
    "item_candidates": "Item candidates: {{count}}",
    "no_candidates": "No item candidates found",
    "discovery_message": {
      "one": "You found an item!",
      "two": "You found two items!",
      "three": "You found three items! What an amazing discovery!"
    },
    "error": {
      "unsupported_format": "Unsupported image format",
      "file_too_large": "File too large (max 20MB)",
      "unknown": "An unknown error occurred"
    },
    "item_type": {
      "key": "Key",
      "weapon": "Weapon",
      "tool": "Tool",
      "clue": "Clue",
      "material": "Material",
      "consumable": "Consumable",
      "document": "Document",
      "artifact": "Artifact"
    },
    "tooltip": {
      "title": "Scanner",
      "description": "Upload a real-world photo to transform it into in-game items or clues"
    },
    "affordance": {
      "idle_hint": "Image → Item",
      "drag_active": "Drop here!"
    }
  },
  "action": {
    "default": {
      "explore": {
        "label": "Explore",
        "description": "Look around"
      },
      "investigate": {
        "label": "Investigate",
        "description": "Examine closely"
      },
      "talk": {
        "label": "Talk",
        "description": "Start a conversation"
      }
    },
    "card_select": "Card selected: {{cardId}}",
    "deck_label": "Action Cards",
    "alternative": "ALT",
    "insufficient_balance": "Insufficient balance",
    "server_disabled": "Unavailable",
    "vision_badge": "VISION",
    "earn_badge": "Earn Signal",
    "vision_already_analyzed": "Scene already analyzed",
    "all_disabled_notice": "No actions available. Check alternatives.",
    "risk": {
      "low": "Low",
      "medium": "Med",
      "high": "High"
    },
    "cost_range": "{{min}}~{{max}}"
  },
  "narrative": {
    "welcome": "Welcome to the Unknown World...",
    "turn_label": "[TURN {{turn}}]",
    "streaming_label": "[STREAMING]",
    "fast_forward_title": "Click to fast-forward",
    "fast_forward_aria": "Click or press Enter/Space to display text instantly",
    "image_pending_label": "Forming image…"
  },
  "action_log": {
    "use_item_on_hotspot": "Action: Use {{item}} on {{hotspot}}",
    "click_hotspot": "Action: Examine {{hotspot}}",
    "click_action": "Action: {{action}}"
  }
}
</file>

<file path="frontend/src/locales/ko-KR/translation.json">
{
  "language": {
    "toggle": "언어 변경",
    "toggle_tooltip": "클릭하여 언어를 변경합니다. 변경 후 새 게임이 시작됩니다.",
    "ko-KR": "한국어",
    "en-US": "English"
  },
  "error": {
    "unknown_error": "알 수 없는 오류가 발생했습니다.",
    "response_processing": "[시스템] 응답 데이터를 처리하는 중 문제가 발생했습니다.",
    "connection_failed": "[시스템] 서버 연결에 실패했습니다. 다시 시도해 주세요.",
    "rate_limited": "API 요청 한도 초과",
    "rate_limited_detail": "요청이 너무 많아 일시적으로 제한되었습니다. 잠시 후 다시 시도해 주세요.",
    "retry_button": "다시 시도",
    "retry_countdown": "{{seconds}}초 후 재시도 가능"
  },
  "profile": {
    "select_title": "프로필을 선택하세요",
    "select_hint": "프로필마다 다른 시작 조건과 목표가 있습니다",
    "or": "또는",
    "continue_saved": "저장된 게임 계속하기",
    "change": "프로필 변경",
    "change_tooltip": "다른 프로필로 새 게임 시작",
    "narrator": {
      "name": "서사꾼",
      "description": "풍부한 자원으로 다양한 이야기를 탐험하세요",
      "welcome": "고대의 도서관에 오신 것을 환영합니다. 이곳에는 잊혀진 이야기들이 잠들어 있습니다...",
      "items": {
        "ancient_tome": "고대 서책",
        "quill_pen": "깃펜",
        "memory_fragment": "기억 조각"
      },
      "quest": {
        "discover_origin": "세계의 기원을 발견하기",
        "discover_origin_desc": "이 세계가 어떻게 만들어졌는지 단서를 찾아 밝혀내세요",
        "collect_memories": "기억 조각 3개 수집하기",
        "read_ancient_tome": "고대 서책을 해독하기"
      },
      "rule": {
        "time_flows": "시간의 흐름",
        "time_flows_desc": "시간은 정상적으로 흐릅니다",
        "memories_persist": "기억의 지속",
        "memories_persist_desc": "한번 얻은 기억은 사라지지 않습니다"
      },
      "scene": {
        "bookshelf": "신비한 책장",
        "bookshelf_hint": "오래된 책들이 빛나고 있다",
        "portal": "빛나는 포탈",
        "portal_hint": "어딘가로 통하는 것 같다"
      }
    },
    "explorer": {
      "name": "탐험가",
      "description": "미지의 영역을 탐험하고 비밀을 발견하세요",
      "welcome": "어두운 미로에서 눈을 떴습니다. 출구를 찾아 이곳을 탈출해야 합니다...",
      "items": {
        "compass": "나침반",
        "rope": "밧줄",
        "lantern": "랜턴",
        "map_fragment": "지도 조각"
      },
      "quest": {
        "find_exit": "탈출구 찾기",
        "find_exit_desc": "미로를 탐험하고 숨겨진 출구를 찾아 탈출하세요",
        "explore_areas": "3개 구역 탐험하기",
        "gather_supplies": "보급품 수집"
      },
      "rule": {
        "gravity": "중력 법칙",
        "gravity_desc": "물체는 아래로 떨어집니다",
        "darkness": "어둠의 법칙",
        "darkness_desc": "빛 없이는 앞을 볼 수 없습니다"
      },
      "scene": {
        "door": "고대의 문",
        "door_hint": "열쇠가 필요해 보인다",
        "mechanism": "이상한 장치",
        "mechanism_hint": "작동시킬 수 있을 것 같다",
        "passage": "숨겨진 통로",
        "passage_hint": "어디로 이어질까?"
      }
    },
    "tech": {
      "name": "기술 전문가",
      "description": "제한된 자원으로 효율적인 전략을 세우세요",
      "welcome": "시스템 부팅 완료. 제한된 에너지로 최적의 경로를 찾아야 합니다...",
      "items": {
        "data_core": "데이터 코어",
        "circuit_board": "회로 기판",
        "energy_cell": "에너지 셀",
        "scanner": "스캐너 장치"
      },
      "quest": {
        "analyze_system": "시스템 분석 완료하기",
        "analyze_system_desc": "핵심 터미널에 접근하여 시스템의 구조를 파악하세요",
        "optimize_resources": "자원 효율 최적화하기",
        "scan_terminal": "터미널 스캔 수행하기"
      },
      "rule": {
        "energy_conservation": "에너지 보존",
        "energy_conservation_desc": "에너지는 생성되거나 소멸되지 않습니다",
        "data_integrity": "데이터 무결성",
        "data_integrity_desc": "손상된 데이터는 복구할 수 없습니다",
        "system_limits": "시스템 한계",
        "system_limits_desc": "동시 처리량에 제한이 있습니다"
      },
      "scene": {
        "terminal": "메인 터미널",
        "terminal_hint": "시스템에 접속할 수 있다",
        "conduit": "전력 도관",
        "conduit_hint": "에너지가 흐르고 있다"
      }
    }
  },
  "reset": {
    "button": "리셋",
    "confirm": "다시 클릭하여 확인",
    "cancel": "취소",
    "tooltip": "현재 프로필의 초기 상태로 되돌립니다"
  },
  "demo": {
    "items": {
      "keycard-alpha": {
        "name": "키카드 A"
      },
      "medkit": {
        "name": "응급 키트"
      },
      "flashlight": {
        "name": "손전등"
      },
      "data-chip": {
        "name": "데이터칩"
      }
    },
    "scene": {
      "terminal": {
        "label": "터미널",
        "hint": "활성화된 터미널이다"
      },
      "door": {
        "label": "문",
        "hint": "잠겨있는 것 같다"
      }
    },
    "quest": {
      "terminal": {
        "label": "터미널에 접속하기"
      },
      "escape": {
        "label": "시설 탈출구 찾기"
      },
      "collect": {
        "label": "데이터칩 수집"
      }
    },
    "rule": {
      "gravity": {
        "label": "중력 법칙",
        "description": "물체는 아래로 떨어진다"
      },
      "time": {
        "label": "시간 흐름",
        "description": "시간은 정상 속도로 흐른다"
      }
    }
  },
  "quest": {
    "empty": "[ 목표 없음 ]",
    "completed": "완료",
    "section": {
      "active": "진행 중",
      "completed": "완료됨"
    },
    "main_objective": "주 목표",
    "sub_objectives": "세부 목표",
    "progress": "진행률 {{progress}}%",
    "reward_preview": "보상: {{signal}} Signal",
    "reward_earned": "+{{signal}} Signal 획득!",
    "objective_complete": "목표 달성!",
    "free_exploration": "자유 탐색 중",
    "free_exploration_desc": "정해진 목표 없이 세계를 자유롭게 탐험하세요",
    "no_sub_objectives": "세부 목표가 아직 없습니다",
    "tracker_no_objective": "목표 없음"
  },
  "rule_board": {
    "empty": "[ 규칙 없음 ]",
    "active_count": "활성 규칙: {{count}}개"
  },
  "mutation": {
    "empty": "[ 변형 이력 없음 ]",
    "timeline_title": "변형 타임라인",
    "event_count": "{{count}}개 이벤트",
    "more_events": "+{{count}}개 더 보기",
    "turn_label": "T{{turn}}",
    "type": {
      "added": "추가됨",
      "modified": "수정됨",
      "removed": "제거됨"
    }
  },
  "scene": {
    "status": {
      "default": "데이터 대기 중",
      "loading": "동기화 중...",
      "offline": "연결 끊김",
      "blocked": "접근 제한됨",
      "low_signal": "신호 약함",
      "image_error": "장면 이미지를 불러올 수 없습니다.",
      "image_loading": "장면 이미지 로딩 중...",
      "image_generating": "새 장면 생성 중...",
      "initial_sync": "전역 데이터 동기화 대기 중...",
      "syncing": "데이터 동기화 중...",
      "alt": "장면 이미지"
    },
    "processing": {
      "processing": "장면 생성 중...",
      "image_pending": "이미지 형성 중...",
      "rendering": "결과 적용 중..."
    },
    "analyzing": {
      "message": "장면 분석 중...",
      "hint": "오브젝트를 탐색하고 있습니다"
    },
    "hotspot": {
      "layer_label": "클릭 가능한 오브젝트 영역",
      "hint_prefix": "힌트",
      "click_action": "{{label}} 클릭",
      "drop_hint": "여기에 드롭하여 사용",
      "drop_action": "{{item}}을(를) {{target}}에 사용",
      "drop_invalid": "그곳에는 {{item}}을(를) 사용할 수 없습니다.",
      "demo_hint": "[데모 대상]"
    }
  },
  "agent": {
    "console": {
      "queue": "대기열",
      "badges": "검증 배지",
      "repair": "자동 복구",
      "status": {
        "idle": "대기 중",
        "processing": "처리 중"
      },
      "badges_empty": "[ 검증 대기 중 ]",
      "repaired": "(복구됨)",
      "phase": {
        "parse": "Parse",
        "validate": "Validate",
        "plan": "Plan",
        "resolve": "Resolve",
        "render": "Render",
        "verify": "Verify",
        "commit": "Commit"
      },
      "badge": {
        "schema": "Schema",
        "economy": "Economy",
        "safety": "Safety",
        "consistency": "Consistency",
        "ok": "OK",
        "fail": "FAIL"
      },
      "model": {
        "fast": "빠름 (FAST)",
        "quality": "고품질 (QUALITY)",
        "cheap": "저비용",
        "ref": "참조"
      },
      "expand": "상세 보기",
      "collapse": "접기",
      "queue_idle": "대기 중..."
    }
  },
  "ui": {
    "logo": "UNKNOWN WORLD",
    "command_placeholder": "명령을 입력하세요...",
    "processing": "처리 중...",
    "execute": "실행",
    "wait": "대기",
    "panel_placeholder": "[ 준비 중 ]",
    "scale_decrease": "글자 크기 줄이기",
    "scale_increase": "글자 크기 늘리기",
    "scale_label": "UI 스케일 설정",
    "input_locked": "처리 중…",
    "input_locked_detail": "턴 결과를 기다리는 중입니다"
  },
  "economy": {
    "signal": "Signal",
    "shard": "Shard",
    "signal_cost": "Signal 소모",
    "shard_cost": "Shard 소모",
    "risk_level": "위험도",
    "hud_label": "재화 현황",
    "estimated_cost": "예상 비용",
    "confirmed_cost": "확정 비용",
    "insufficient_funds": "잔액 부족",
    "low_balance_warning": "잔액이 부족합니다",
    "low_balance_title": "Signal 부족 - 대안 안내",
    "credit": "크레딧",
    "credit_desc": "현재 사용 중인 크레딧(부채)입니다. 재화 획득 시 우선 상환됩니다.",
    "fast_fallback_notice": "이미지는 기본 품질(FAST)로 무료 생성됩니다",
    "hint_sell_items": "인벤토리 아이템을 판매하여 Signal을 획득하세요",
    "hint_earn_actions": "재화 획득 카드(⚡)를 선택하세요",
    "hint_complete_quests": "목표를 달성하여 보상을 받으세요",
    "alternatives_title": "대안 행동",
    "alternative_text_only": "텍스트만 생성 (이미지 없음)",
    "alternative_low_quality": "저품질/빠른 응답 선택",
    "ledger_title": "거래 장부",
    "ledger_empty": "[ 이력 없음 ]",
    "model_label": {
      "FAST": "빠름",
      "QUALITY": "고품질",
      "CHEAP": "저비용",
      "REF": "참조"
    },
    "ledger_reason": {
      "turn_cost": "턴 진행 비용"
    }
  },
  "connection": {
    "online": "온라인",
    "offline": "오프라인"
  },
  "inventory": {
    "empty": "[ 아이템 없음 ]",
    "empty_hint": "장면을 탐색하여 아이템을 찾으세요",
    "count": "Inventory ({{count}})",
    "grid_label": "인벤토리 아이템 목록",
    "list_label": "인벤토리 아이템 목록",
    "item_label": "{{name}} (수량: {{quantity}})",
    "drag_hint": "드래그하여 사용",
    "item_consumed": "{{name}} 사용됨",
    "sell_tooltip": "판매 (+{{price}} Signal)",
    "sell_aria": "{{item}} 판매 (+{{price}} Signal)",
    "sell_narrative": "💰 {{item}}을(를) 판매하여 {{signal}} Signal을 획득했습니다.",
    "sell_toast": "{{item}} 판매 완료!",
    "sell_ledger_reason": "아이템 판매",
    "sell_confirm": "확인?"
  },
  "interaction": {
    "hotspot_click": "클릭하여 조사",
    "item_drag": "드래그하여 사용",
    "drop_here": "여기에 놓기",
    "_u117_removed": "온보딩 가이드 키 제거됨 (U-117)"
  },
  "common": {
    "next": "다음"
  },
  "panel": {
    "inventory": {
      "title": "Inventory",
      "placeholder": "[ 드래그 앤 드롭 영역 ]"
    },
    "quest": {
      "title": "Quest",
      "placeholder": "[ 목표/퀘스트 목록 ]"
    },
    "rule_board": {
      "title": "Rule Board",
      "placeholder": "[ 월드 규칙/변형 타임라인 ]"
    },
    "agent_console": {
      "title": "Agent Console"
    },
    "memory_pin": {
      "title": "Memory Pin",
      "placeholder": "[ 고정된 기억/단서 ]"
    },
    "scanner": {
      "title": "Scanner",
      "placeholder": "[ 이미지 업로드 슬롯 ]"
    }
  },
  "scanner": {
    "dropzone_label": "이미지를 드롭하거나 클릭하여 업로드",
    "dropzone_text": "이미지를 드롭하세요",
    "dropzone_hint": "또는 클릭하여 파일 선택",
    "upload_label": "이미지 업로드",
    "preview_alt": "업로드 이미지 미리보기",
    "uploading": "업로드 중...",
    "analyzing": "분석 중...",
    "retry": "다시 시도",
    "cancel": "취소",
    "select_items": "인벤토리에 추가할 아이템을 선택하세요",
    "add_to_inventory": "추가 ({{count}}개)",
    "detected_objects": "감지된 오브젝트: {{count}}개",
    "item_candidates": "아이템 후보: {{count}}개",
    "no_candidates": "아이템 후보를 찾지 못했습니다",
    "discovery_message": {
      "one": "아이템을 발견했습니다!",
      "two": "두 가지를 발견했습니다!",
      "three": "세 가지를 발견했습니다! 대단한 발견이네요!"
    },
    "error": {
      "unsupported_format": "지원하지 않는 이미지 형식입니다",
      "file_too_large": "파일이 너무 큽니다 (최대 20MB)",
      "unknown": "알 수 없는 오류가 발생했습니다"
    },
    "item_type": {
      "key": "열쇠",
      "weapon": "무기",
      "tool": "도구",
      "clue": "단서",
      "material": "재료",
      "consumable": "소모품",
      "document": "문서",
      "artifact": "유물"
    },
    "tooltip": {
      "title": "스캐너",
      "description": "현실의 사진을 업로드하면 게임 속 아이템이나 단서로 변환됩니다"
    },
    "affordance": {
      "idle_hint": "이미지 → 아이템",
      "drag_active": "여기에 놓으세요!"
    }
  },
  "action": {
    "default": {
      "explore": {
        "label": "탐색하기",
        "description": "주변을 살펴본다"
      },
      "investigate": {
        "label": "조사하기",
        "description": "자세히 살펴본다"
      },
      "talk": {
        "label": "대화하기",
        "description": "말을 걸어본다"
      }
    },
    "card_select": "카드 선택: {{cardId}}",
    "deck_label": "행동 선택 카드",
    "alternative": "대안",
    "insufficient_balance": "잔액 부족",
    "server_disabled": "사용 불가",
    "vision_badge": "정밀분석",
    "earn_badge": "Signal 획득",
    "vision_already_analyzed": "이미 분석된 장면입니다",
    "all_disabled_notice": "실행 가능한 행동이 없습니다. 대안을 확인하세요.",
    "risk": {
      "low": "낮음",
      "medium": "보통",
      "high": "높음"
    },
    "cost_range": "{{min}}~{{max}}"
  },
  "narrative": {
    "welcome": "미지의 세계에 오신 것을 환영합니다...",
    "turn_label": "[TURN {{turn}}]",
    "streaming_label": "[STREAMING]",
    "fast_forward_title": "클릭하여 빠르게 넘기기",
    "fast_forward_aria": "클릭하거나 Enter/Space를 눌러 텍스트를 즉시 표시합니다",
    "image_pending_label": "이미지 형성 중…"
  },
  "action_log": {
    "use_item_on_hotspot": "행동 실행: {{item}}을(를) {{hotspot}}에 사용한다",
    "click_hotspot": "행동 실행: {{hotspot}}을(를) 조사한다",
    "click_action": "행동 실행: {{action}}"
  }
}
</file>

<file path="frontend/src/style.css">
/**
 * Unknown World - CRT 테마 스타일시트 (단일 CSS SSOT)
 *
 * RULE-002 준수: 채팅 버블 UI 금지 - 게임 로그/HUD 형태만 허용
 * Frontend Style Guide 준수: CRT 터미널 레트로 미학
 *
 * @see vibe/ref/frontend-style-guide.md
 */

/* ============================================
   1. CRT 테마 토큰 (CSS Variables)
   ============================================ */
:root {
  color-scheme: dark; /* U-049: 시스템 브라우저 요소(스크롤바 등)를 다크 모드로 강제 */
  /* 기본 색상 - CRT 인광 녹색 테마 */
  --bg-color: #0d0d0d; /* 배경: 거의 순수한 검정 */
  --text-color: #33ff00; /* 주 텍스트: 인광 녹색 (CRT 그린) */
  --text-dim: #22a000; /* 보조 텍스트: 약간 더 밝게 하여 가독성 향상 (U-049) */
  --text-muted: #4a7a4a; /* U-125: 액션 로그용 저채도 색상 */
  --accent-color: #ff00ff; /* 강조색: 마젠타 */
  --border-color: #33ff00; /* 테두리: 인광 녹색 */
  --border-dim: rgba(51, 255, 0, 0.15); /* U-125: 이전 턴/현재 턴 구분선 */
  --panel-bg: rgba(0, 15, 0, 0.7); /* 패널 배경: 대비 향상을 위해 불투명도 증가 (U-049) */
  --warning-color: #ffaa00; /* 경고: 주황색 */
  --error-color: #ff3333; /* 에러: 붉은색 */

  /* CRT 효과 */
  --crt-scanline: rgba(18, 16, 16, 0.1);
  --crt-flicker: 0.03;
  --glow-intensity: 5px;
  --crt-flicker-opacity-min: 0.97;
  --crt-flicker-opacity-max: 1;

  /* 타이포그래피 */
  --font-main: 'NeoDunggeunmo', 'VT323', monospace;
  --font-micro-en:
    'Share Tech Mono', 'Consolas', monospace; /* U-037: 영문 마이크로 텍스트 가독성 */
  --font-size-base: 16px;
  --font-size-lg: 1.2rem;
  --font-size-xl: 1.5rem;
  --font-size-2xl: 2rem;
  --line-height-base: 1.5;

  /* 마이크로 텍스트 (U-049: 가독성을 위해 최소 크기 상향) */
  --font-size-xs: 0.8125rem; /* 13px at 1.0 scale - 최소 마이크로 텍스트 */
  --font-size-sm: 0.9375rem; /* 15px at 1.0 scale - 작은 텍스트 */

  /* UI 스케일 (U-028: 전역 스케일 조절) */
  --ui-scale-factor: 1;

  /* 레이아웃 - 기본 스페이싱 */
  --spacing-xs: 4px;
  --spacing-sm: 8px;
  --spacing-md: 16px;
  --spacing-lg: 24px;
  --spacing-xl: 32px;
  --border-radius: 4px;

  /* U-073: 레이아웃 확장 - 좌우 빈공간 활용
   * Q1: 1800px (와이드, 좌우 패널 충분히 넓게)
   * Q3 Option B: 장식용 패턴/텍스처 (게임 테마 강화)
   * 사이드 패널은 minmax로 유연하게 조절 */
  --layout-max-width: 1800px;
  --layout-side-panel-min: 280px;
  --layout-side-panel-max: 380px;
  --layout-center-min: 400px;
  --layout-gap: var(--spacing-sm);

  /* 그리드 레이아웃 */
  --header-height: 60px;
  --footer-height: 140px; /* U-050 v6: 컴팩트 카드에 맞춰 높이 조정 */

  /* ===========================================
     U-058: 핫스팟 디자인 토큰 (Magenta 계열)
     - Q1 Option C: Magenta/Purple 계열
     - Q2 Option A: L자 브라켓 스타일
     =========================================== */
  --hotspot-primary: #e040fb; /* 밝은 마젠타 (기본) */
  --hotspot-primary-dim: #9c27b0; /* 어두운 퍼플 (비활성) */
  --hotspot-hover: #f06292; /* 핑크 (호버) */
  --hotspot-active: #ff4081; /* 밝은 핑크 (클릭/활성) */
  --hotspot-drop: #ffab40; /* 앰버 (드롭 타겟) */
  --hotspot-glow: rgba(224, 64, 251, 0.4); /* 글로우용 투명 마젠타 */
  --hotspot-bg: rgba(224, 64, 251, 0.06); /* 배경용 미세 틴트 */

  /* 코너 마커 크기 */
  --hotspot-corner-size: 12px;
  --hotspot-corner-thickness: 2px;
  --hotspot-stroke-width: 1px;
}

/* ============================================
   1.1 라이트 테마 (Light Theme)
   - CRT 페이퍼/브라이트 모드 재현
   - Q1 Option A: 고대비 녹색-회색 조합
   ============================================ */
[data-theme='light'] {
  color-scheme: light;
  --bg-color: #f4f8f4; /* 밝은 녹색 틴트 배경 */
  --text-color: #004d00; /* 짙은 녹색 (가독성) */
  --text-dim: #668866; /* 보조 텍스트 (이전 턴용) */
  --text-muted: #809980; /* 액션 로그용 */
  --accent-color: #9c27b0; /* 보라색 강조 */
  --border-color: #004d00;
  --border-dim: rgba(0, 77, 0, 0.15);
  --panel-bg: rgba(220, 235, 220, 0.85); /* 밝은 패널 배경 */
  --warning-color: #e65100;
  --error-color: #c62828;

  /* CRT 효과 완화 */
  --crt-scanline: rgba(0, 50, 0, 0.04);
  --glow-intensity: 2px;

  /* 핫스팟 (라이트 테마 최적화) */
  --hotspot-primary: #7b1fa2;
  --hotspot-glow: rgba(123, 31, 162, 0.2);
}

/* ============================================
   2. 폰트 정의
   ============================================ */
@font-face {
  font-family: 'NeoDunggeunmo';
  src: url('https://cdn.jsdelivr.net/gh/projectnoonnu/noonfonts_2001@1.3/NeoDunggeunmo.woff')
    format('woff');
  font-weight: normal;
  font-display: swap;
}

/* ============================================
   3. Reset & Base
   ============================================ */
*,
*::before,
*::after {
  box-sizing: border-box;
  margin: 0;
  padding: 0;
}

html {
  /* U-028: UI 스케일 적용 - font-size가 스케일 팩터에 반응 */
  font-size: calc(var(--font-size-base) * var(--ui-scale-factor));
  line-height: var(--line-height-base);
}

html,
body {
  margin: 0;
  padding: 0;
  width: 100%;
  height: 100%;
  background-color: var(--bg-color);
  color: var(--text-color);
  /* U-049: 표준 스크롤바 스타일 (Firefox 등) */
  scrollbar-width: thin;
  scrollbar-color: rgba(51, 255, 0, 0.3) var(--bg-color);
}

body {
  font-family: var(--font-main);
  min-height: 100vh;
  overflow: hidden;
  /* U-057: 기본 글로우 완화 - 분위기 유지하면서 가독성 개선 */
  /* 기존: 0 0 5px (glow-intensity) → 완화: 0 0 2px */
  text-shadow:
    0 0 1px rgba(0, 0, 0, 0.8),
    0 0 2px var(--text-dim);
  -webkit-font-smoothing: antialiased;
  -moz-osx-font-smoothing: grayscale;

  /* U-073 Q3 Option B: 장식용 패턴/텍스처 (게임 테마 강화)
   * - 좌우 빈공간에 CRT 그리드 패턴 표시
   * - 게임 컨테이너 외부 영역에만 보임 */
  background-image:
    /* 수직 스캔라인 */
    repeating-linear-gradient(
      90deg,
      transparent,
      transparent 2px,
      rgba(51, 255, 0, 0.015) 2px,
      rgba(51, 255, 0, 0.015) 4px
    ),
    /* 수평 스캔라인 */
    repeating-linear-gradient(
        0deg,
        transparent,
        transparent 2px,
        rgba(51, 255, 0, 0.02) 2px,
        rgba(51, 255, 0, 0.02) 4px
      ),
    /* 미세한 그리드 도트 패턴 */
    radial-gradient(circle at center, rgba(51, 255, 0, 0.03) 1px, transparent 1px);
  background-size:
    4px 100%,
    100% 4px,
    20px 20px;
  background-position:
    0 0,
    0 0,
    10px 10px;
}

#root {
  min-height: 100vh;
  display: flex;
  flex-direction: column;
}

/* ============================================
   4. CRT 오버레이 효과
   ============================================ */

/* 스캔라인 오버레이 - U-050 v6: 스캔라인 강도 완화 */
.crt-overlay {
  position: fixed;
  top: 0;
  left: 0;
  width: 100vw;
  height: 100vh;
  /* 스캔라인: 적당히 (0.35) - 분위기와 가독성 균형 */
  background: linear-gradient(rgba(18, 16, 16, 0) 50%, rgba(0, 0, 0, 0.35) 50%);
  background-size: 100% 2px;
  pointer-events: none;
  z-index: 9999;
  /* 플리커: 느리게 (0.5s), 미세한 변화만 */
  animation: flicker 0.5s infinite;
}

/* 
 * U-037: 중요도 기반 레이어링
 * - Critical: 오버레이(9999) 위로 뚫고 올라와 선명하게 표시
 * - Ambient: 오버레이 아래에 위치하여 CRT 분위기 적용
 */

/* Critical 보호 레이어 (오버레이 위) */
[data-ui-importance='critical'],
.ui-critical,
.phase-item,
.currency-value,
.action-card-cost,
.agent-error {
  position: relative;
  z-index: 10000;
}

/* Ambient 분위기 레이어 (오버레이 아래) */
.game-title,
.panel-header,
.action-card-title {
  position: relative;
  z-index: 1; /* 9999 오버레이보다 아래 */
}

#root {
  min-height: 100vh;
}

/* 플리커(깜빡임) 애니메이션 - U-050 v5: 미세한 깜빡임 */
@keyframes flicker {
  0%,
  100% {
    opacity: 0.95;
  }
  25% {
    opacity: 1;
  }
  50% {
    opacity: 0.97;
  }
  75% {
    opacity: 0.99;
  }
}

/* 글리치 효과 (타이틀용) */
.glitch {
  position: relative;
}

.glitch::before,
.glitch::after {
  content: attr(data-text);
  position: absolute;
  top: 0;
  left: 0;
  width: 100%;
  height: 100%;
}

.glitch::before {
  left: 2px;
  text-shadow: -1px 0 #ff0000;
  clip-path: inset(0 0 0 0);
  animation: glitch-anim-1 5s infinite linear alternate-reverse;
}

.glitch::after {
  left: -2px;
  text-shadow: -1px 0 #0000ff;
  clip-path: inset(0 0 0 0);
  animation: glitch-anim-2 5s infinite linear alternate-reverse;
}

@keyframes glitch-anim-1 {
  0%,
  100% {
    clip-path: inset(0 0 95% 0);
  }
  20% {
    clip-path: inset(30% 0 50% 0);
  }
  40% {
    clip-path: inset(10% 0 70% 0);
  }
  60% {
    clip-path: inset(80% 0 5% 0);
  }
  80% {
    clip-path: inset(45% 0 35% 0);
  }
}

@keyframes glitch-anim-2 {
  0%,
  100% {
    clip-path: inset(95% 0 0 0);
  }
  20% {
    clip-path: inset(50% 0 30% 0);
  }
  40% {
    clip-path: inset(70% 0 10% 0);
  }
  60% {
    clip-path: inset(5% 0 80% 0);
  }
  80% {
    clip-path: inset(35% 0 45% 0);
  }
}

/* ============================================
   5. 게임 레이아웃 (CSS Grid)
   - RULE-002: 채팅 UI가 아닌 게임 UI 고정
   ============================================ */

.game-container {
  display: grid;
  grid-template-areas:
    'header header header'
    'sidebar-left center sidebar-right'
    'footer footer footer';
  /* U-073: minmax 기반 유연한 사이드 패널 너비
   * - 사이드 패널: 최소~최대 범위 내에서 자동 조절
   * - 중앙: 남은 공간 활용 (최소 400px 보장)
   * Q1 Option A: 1600px max-width */
  grid-template-columns:
    minmax(var(--layout-side-panel-min), var(--layout-side-panel-max))
    minmax(var(--layout-center-min), 1fr)
    minmax(var(--layout-side-panel-min), var(--layout-side-panel-max));
  grid-template-rows: var(--header-height) 1fr var(--footer-height);
  /* U-049: 스크롤 방지 - dvh 사용 및 overflow 제어 */
  height: 100dvh;
  height: 100vh; /* dvh 미지원 브라우저 폴백 */
  max-height: 100dvh;
  max-height: 100vh;
  width: 100%;
  /* U-073: 1600px max-width + 중앙 정렬 */
  max-width: var(--layout-max-width);
  margin: 0 auto;
  padding: var(--layout-gap);
  gap: var(--layout-gap);
  overflow: hidden; /* U-049: 의도치 않은 스크롤 방지 */
  /* U-073: 게임 영역 배경 - 좌우 패턴이 게임 내부에 침범하지 않도록 */
  background-color: var(--bg-color);
}

/* ============================================
   6. Header 영역
   - Title, Language Toggle, Theme Toggle,
     Connection Status, Economy HUD
   ============================================ */

.game-header {
  grid-area: header;
  display: flex;
  align-items: center;
  justify-content: space-between;
  padding: 0 var(--spacing-md);
  border: 1px solid var(--border-color);
  background-color: var(--panel-bg);
  box-shadow:
    inset 0 0 20px rgba(0, 0, 0, 0.5),
    0 0 10px var(--text-dim);
}

.game-title {
  font-size: var(--font-size-2xl);
  color: var(--text-color);
  text-transform: uppercase;
  letter-spacing: 4px;
}

.header-controls {
  display: flex;
  align-items: center;
  gap: var(--spacing-md);
}

.economy-hud {
  display: flex;
  align-items: center;
  gap: var(--spacing-sm);
  padding: var(--spacing-xs) var(--spacing-sm);
  border: 1px solid var(--text-dim);
  background-color: rgba(0, 0, 0, 0.5);
}

.economy-hud .signal-icon {
  color: var(--accent-color);
}

.connection-status {
  display: flex;
  align-items: center;
  gap: var(--spacing-xs);
  font-size: 0.875rem;
}

.status-indicator {
  width: 8px;
  height: 8px;
  border-radius: 50%;
  background-color: var(--text-color);
  box-shadow: 0 0 6px var(--text-color);
  animation: pulse 2s infinite;
}

.status-indicator.offline {
  background-color: var(--error-color);
  box-shadow: 0 0 6px var(--error-color);
  animation: none;
}

@keyframes pulse {
  0%,
  100% {
    opacity: 1;
  }
  50% {
    opacity: 0.5;
  }
}

/* ============================================
   7. Sidebar (Left) 영역
   - Inventory, Quest/Objective, Rule Board
   - U-049: 컬럼 전체 스크롤 제거, 패널 콘텐츠 단위 스크롤
   ============================================ */

.sidebar-left {
  grid-area: sidebar-left;
  display: flex;
  flex-direction: column;
  gap: var(--layout-gap); /* U-073: 레이아웃 갭 통일 */
  min-height: 0; /* U-049: flex 자식 축소 허용 */
  overflow: hidden; /* U-049: 컬럼 전체 스크롤 제거 */
}

/* ============================================
   8. Center 영역
   - Scene Canvas, Narrative Feed (로그 형태)
   ============================================ */

.game-center {
  grid-area: center;
  display: flex;
  flex-direction: column;
  gap: var(--layout-gap); /* U-073: 레이아웃 갭 통일 */
  overflow: hidden;
}

.scene-canvas {
  /* U-073: 4:3 비율 Scene Canvas - 로그창 공간 확보 */
  flex: 0 0 auto;
  aspect-ratio: 4 / 3;
  width: 100%;
  /* NarrativeFeed 충분한 공간 확보 */
  max-height: calc(100vh - var(--header-height) - var(--footer-height) - 250px);
  border: 1px solid var(--border-color);
  background-color: var(--panel-bg);
  box-shadow: inset 0 0 20px rgba(0, 0, 0, 0.8);
  display: flex;
  align-items: center;
  justify-content: center;
  position: relative;
  min-height: 200px;
  overflow: hidden; /* 내부 이미지 넘침 방지 */
}

/* U-020: Scene Image 컨테이너 스타일 */
.scene-image-container {
  position: absolute;
  inset: 0;
  width: 100%;
  height: 100%;
  display: flex;
  align-items: center;
  justify-content: center;
  background-size: cover;
  background-position: center;
  background-repeat: no-repeat;
}

.scene-placeholder {
  color: var(--text-color);
  font-size: var(--font-size-lg);
  text-align: center;
  background-color: rgba(0, 0, 0, 0.6);
  padding: var(--spacing-md);
  border: 1px solid var(--text-dim);
  /* U-057: 글로우 완화 (10px → 3px) */
  text-shadow: 0 0 3px rgba(51, 255, 0, 0.4);
  -webkit-font-smoothing: antialiased;
}

/* U-031: Scene Canvas 상태별 placeholder 스타일 */
.scene-status-label {
  display: flex;
  align-items: center;
  justify-content: center;
  gap: var(--spacing-sm);
  font-size: var(--font-size-lg);
  text-transform: uppercase;
  letter-spacing: 2px;
}

.scene-status-emoji {
  font-size: 1.5em;
}

.scene-status-message {
  margin-top: var(--spacing-xs);
  font-size: var(--font-size-sm);
}

/* 상태별 배경 이미지 적용 (container로 이동) */
.scene-image-container.scene-status-loading,
.scene-image-container.scene-status-offline,
.scene-image-container.scene-status-blocked,
.scene-image-container.scene-status-low_signal,
.scene-image-container.scene-status-default {
  background-size: cover;
  background-position: center;
  background-repeat: no-repeat;
}

/* 로딩 상태: 펄스 애니메이션 */
.scene-image-container.scene-status-loading .scene-placeholder {
  animation: loading-pulse 2s ease-in-out infinite;
}

@keyframes loading-pulse {
  0%,
  100% {
    opacity: 0.7;
  }
  50% {
    opacity: 1;
  }
}

/* 오프라인 상태: 정적 노이즈 효과 */
.scene-image-container.scene-status-offline {
  position: relative;
}

.scene-image-container.scene-status-offline::before {
  content: '';
  position: absolute;
  top: 0;
  left: 0;
  right: 0;
  bottom: 0;
  background: repeating-linear-gradient(
    0deg,
    transparent,
    transparent 2px,
    rgba(0, 0, 0, 0.1) 2px,
    rgba(0, 0, 0, 0.1) 4px
  );
  pointer-events: none;
  animation: static-noise 0.5s steps(5) infinite;
}

@keyframes static-noise {
  0%,
  100% {
    opacity: 0.3;
  }
  50% {
    opacity: 0.5;
  }
}

/* 차단 상태: 경고색 테두리 */
.scene-image-container.scene-status-blocked {
  border-color: var(--warning-color);
  box-shadow: inset 0 0 30px rgba(255, 170, 0, 0.2);
}

.scene-image-container.scene-status-blocked .scene-status-label {
  color: var(--warning-color);
}

/* 저신호 상태: 희미한 표시 */
.scene-image-container.scene-status-low_signal .scene-placeholder {
  opacity: 0.8;
}

.scene-image-container.scene-status-low_signal .scene-status-label {
  color: var(--text-dim);
}

/* 정상 장면 표시 */
.scene-image-container.scene-active {
  background-color: transparent;
}

.scene-image-container .scene-image {
  width: 100%;
  height: 100%;
  object-fit: cover;
  /* U-020: 페이드 인 효과 */
  opacity: 0;
  transition: opacity 0.3s ease-in-out;
}

/* U-020: 이미지 로드 완료 시 표시 */
.scene-image-container .scene-image.scene-image-loaded {
  opacity: 1;
}

/* ============================================
   8.0.1 이미지 로딩 인디케이터 (U-020)
   - RULE-008: 텍스트 우선 + Lazy 이미지 정책
   - Q1 Option A: 이전 이미지 유지 + 로딩 상태 표시
   ============================================ */

/* 로딩 인디케이터 컨테이너 */
.scene-loading-indicator {
  position: absolute;
  bottom: var(--spacing-md);
  right: var(--spacing-md);
  display: flex;
  align-items: center;
  gap: var(--spacing-xs);
  padding: var(--spacing-xs) var(--spacing-sm);
  background-color: rgba(0, 20, 0, 0.9);
  border: 1px solid var(--accent-color);
  border-radius: 2px;
  z-index: 15;
  animation: loading-fade-in 0.2s ease-out;
}

@keyframes loading-fade-in {
  from {
    opacity: 0;
    transform: translateY(10px);
  }
  to {
    opacity: 1;
    transform: translateY(0);
  }
}

/* 로딩 스피너 */
.scene-loading-spinner {
  width: 14px;
  height: 14px;
  border: 2px solid var(--text-dim);
  border-top-color: var(--accent-color);
  border-radius: 50%;
  animation: spin 1s linear infinite;
}

/* 로딩 텍스트 */
.scene-loading-text {
  font-size: var(--font-size-xs);
  color: var(--accent-color);
  text-transform: uppercase;
  letter-spacing: 1px;
}

/* 이미지 로딩 중 캔버스 상태 */
.scene-image-container.image-loading {
  /* 약간의 시각적 힌트 */
}

.scene-image-container.image-loading::before {
  content: '';
  position: absolute;
  bottom: 0;
  left: 0;
  width: 100%;
  height: 3px;
  background: linear-gradient(90deg, transparent 0%, var(--accent-color) 50%, transparent 100%);
  animation: loading-bar 1.5s ease-in-out infinite;
  z-index: 20;
}

@keyframes loading-bar {
  0% {
    transform: translateX(-100%);
  }
  100% {
    transform: translateX(100%);
  }
}

/* ============================================
   8.0.2 처리 중 오버레이 (U-071)
   - Scene Canvas 중앙에 CRT 테마 로딩 인디케이터
   - 처리 단계별 메시지 표시 (processing, image_pending)
   - prefers-reduced-motion 지원
   ============================================ */

/* 처리 중 컨테이너 상태 */
.scene-image-container.scene-processing {
  /* 배경을 placeholder 이미지로 대체 (Option C) */
  background-color: rgba(0, 10, 0, 0.9);
}

/* 처리 중 오버레이 (중앙 배치) */
.scene-processing-overlay {
  position: absolute;
  inset: 0;
  display: flex;
  flex-direction: column;
  align-items: center;
  justify-content: center;
  gap: var(--spacing-md);
  background: radial-gradient(
    ellipse at center,
    rgba(0, 30, 0, 0.95) 0%,
    rgba(0, 10, 0, 0.98) 100%
  );
  z-index: 25;
  animation: processing-fade-in 0.3s ease-out;
}

@keyframes processing-fade-in {
  from {
    opacity: 0;
  }
  to {
    opacity: 1;
  }
}

/* CRT 테마 스피너 */
.scene-processing-spinner {
  position: relative;
  width: 64px;
  height: 64px;
}

.scene-processing-spinner .spinner-ring {
  position: absolute;
  border-radius: 50%;
  border: 2px solid transparent;
}

.scene-processing-spinner .spinner-ring-outer {
  inset: 0;
  border-top-color: var(--text-color);
  border-right-color: var(--text-color);
  animation: spin-outer 1.5s linear infinite;
  box-shadow: 0 0 10px var(--text-color);
}

.scene-processing-spinner .spinner-ring-inner {
  inset: 8px;
  border-bottom-color: var(--accent-color);
  border-left-color: var(--accent-color);
  animation: spin-inner 1s linear infinite reverse;
  box-shadow: 0 0 8px var(--accent-color);
}

.scene-processing-spinner .spinner-glow {
  position: absolute;
  inset: 16px;
  border-radius: 50%;
  background: radial-gradient(circle, rgba(51, 255, 0, 0.15) 0%, transparent 70%);
  animation: glow-pulse 2s ease-in-out infinite;
}

@keyframes spin-outer {
  from {
    transform: rotate(0deg);
  }
  to {
    transform: rotate(360deg);
  }
}

@keyframes spin-inner {
  from {
    transform: rotate(0deg);
  }
  to {
    transform: rotate(360deg);
  }
}

@keyframes glow-pulse {
  0%,
  100% {
    opacity: 0.5;
    transform: scale(1);
  }
  50% {
    opacity: 1;
    transform: scale(1.1);
  }
}

/* 처리 단계 메시지 텍스트 */
.scene-processing-text {
  font-size: var(--font-size-lg);
  color: var(--text-color);
  text-transform: uppercase;
  letter-spacing: 3px;
  text-shadow: 0 0 10px var(--text-color);
  animation: text-flicker 3s ease-in-out infinite;
}

@keyframes text-flicker {
  0%,
  100% {
    opacity: 1;
  }
  50% {
    opacity: 0.8;
  }
  75% {
    opacity: 0.95;
  }
}

/* CRT 스캔라인 효과 (오버레이 내부) */
.scene-processing-scanlines {
  position: absolute;
  inset: 0;
  background: linear-gradient(rgba(18, 16, 16, 0) 50%, rgba(0, 0, 0, 0.25) 50%);
  background-size: 100% 4px;
  pointer-events: none;
  animation: scanline-scroll 8s linear infinite;
  opacity: 0.6;
}

@keyframes scanline-scroll {
  from {
    background-position: 0 0;
  }
  to {
    background-position: 0 100%;
  }
}

/* U-066: 이미지 생성 중 인디케이터 - processing과 동일 스타일 적용 */
.scene-generating-indicator {
  position: absolute;
  inset: 0;
  display: flex;
  flex-direction: column;
  align-items: center;
  justify-content: center;
  gap: var(--spacing-md);
  background: radial-gradient(ellipse at center, rgba(0, 30, 0, 0.9) 0%, rgba(0, 10, 0, 0.95) 100%);
  z-index: 20;
}

.scene-generating-spinner {
  width: 48px;
  height: 48px;
  border: 3px solid var(--text-dim);
  border-top-color: var(--accent-color);
  border-radius: 50%;
  animation: spin 1s linear infinite;
  box-shadow: 0 0 15px var(--accent-color);
}

.scene-generating-text {
  font-size: var(--font-size-sm);
  color: var(--accent-color);
  text-transform: uppercase;
  letter-spacing: 2px;
  text-shadow: 0 0 8px var(--accent-color);
}

/* ============================================
   U-089: 정밀분석(Agentic Vision) 전용 오버레이
   Q1: Option A - 스캔라인 스윕(위→아래) + 시안 글로우 라벨
   Q2: Option B - opacity 0.5 + 시안 틴트
   ============================================ */

/* 분석 모드 - 기존 이미지 어둡게 처리 (opacity 0.5 + cyan tint) */
.scene-image-container.scene-analyzing .scene-image {
  opacity: 0.5;
  filter: brightness(0.7) saturate(0.6);
  transition:
    opacity 0.3s ease,
    filter 0.3s ease;
}

/* 분석 완료 후 이미지 원복 */
.scene-image-container:not(.scene-analyzing) .scene-image {
  transition:
    opacity 0.3s ease,
    filter 0.3s ease;
}

/* 분석 전용 오버레이 컨테이너 */
.scene-analyzing-overlay {
  position: absolute;
  inset: 0;
  display: flex;
  flex-direction: column;
  align-items: center;
  justify-content: center;
  gap: var(--spacing-sm);
  /* 시안 틴트 배경 */
  background: rgba(0, 255, 255, 0.05);
  z-index: 15;
  pointer-events: none;
  animation: analyzing-overlay-in 0.3s ease-out;
}

@keyframes analyzing-overlay-in {
  from {
    opacity: 0;
    background: rgba(0, 255, 255, 0);
  }
  to {
    opacity: 1;
    background: rgba(0, 255, 255, 0.05);
  }
}

/* 스캔라인 스윕 효과 (위→아래 반복) */
.scene-analyzing-scanline {
  position: absolute;
  inset: 0;
  overflow: hidden;
  pointer-events: none;
}

.scene-analyzing-scanline::before {
  content: '';
  position: absolute;
  width: 100%;
  height: 4px;
  background: linear-gradient(
    transparent,
    rgba(0, 255, 255, 0.3),
    rgba(0, 255, 255, 0.7),
    rgba(0, 255, 255, 0.3),
    transparent
  );
  box-shadow:
    0 0 20px rgba(0, 255, 255, 0.4),
    0 0 60px rgba(0, 255, 255, 0.15);
  animation: analyzing-sweep 2.5s ease-in-out infinite;
}

@keyframes analyzing-sweep {
  0% {
    top: -5%;
  }
  100% {
    top: 105%;
  }
}

/* 두 번째 스캔라인 (딜레이 적용) */
.scene-analyzing-scanline::after {
  content: '';
  position: absolute;
  width: 100%;
  height: 2px;
  background: linear-gradient(
    transparent,
    rgba(0, 255, 255, 0.15),
    rgba(0, 255, 255, 0.4),
    rgba(0, 255, 255, 0.15),
    transparent
  );
  box-shadow: 0 0 12px rgba(0, 255, 255, 0.2);
  animation: analyzing-sweep 2.5s ease-in-out infinite;
  animation-delay: 1.25s;
}

/* 분석 메인 텍스트 (시안 글로우) */
.scene-analyzing-text {
  font-family: var(--font-main);
  font-size: var(--font-size-lg);
  color: rgba(0, 255, 255, 0.95);
  text-transform: uppercase;
  letter-spacing: 0.15em;
  text-shadow:
    0 0 10px rgba(0, 255, 255, 0.6),
    0 0 20px rgba(0, 255, 255, 0.3),
    0 0 40px rgba(0, 255, 255, 0.15);
  z-index: 2;
  animation: analyzing-text-pulse 2s ease-in-out infinite;
}

@keyframes analyzing-text-pulse {
  0%,
  100% {
    opacity: 1;
    text-shadow:
      0 0 10px rgba(0, 255, 255, 0.6),
      0 0 20px rgba(0, 255, 255, 0.3),
      0 0 40px rgba(0, 255, 255, 0.15);
  }
  50% {
    opacity: 0.8;
    text-shadow:
      0 0 15px rgba(0, 255, 255, 0.8),
      0 0 30px rgba(0, 255, 255, 0.4),
      0 0 50px rgba(0, 255, 255, 0.2);
  }
}

/* 분석 서브 텍스트 (힌트) */
.scene-analyzing-subtext {
  font-family: var(--font-main);
  font-size: var(--font-size-xs);
  color: rgba(0, 255, 255, 0.5);
  text-transform: uppercase;
  letter-spacing: 0.1em;
  z-index: 2;
}

/* reduced-motion: 처리 중 애니메이션 완화 (U-071) */
@media (prefers-reduced-motion: reduce) {
  .scene-processing-overlay {
    animation: none;
  }

  .scene-processing-spinner .spinner-ring-outer,
  .scene-processing-spinner .spinner-ring-inner {
    animation: none;
    border-color: var(--text-color);
  }

  .scene-processing-spinner .spinner-ring-inner {
    border-color: var(--accent-color);
  }

  .scene-processing-spinner .spinner-glow {
    animation: none;
    opacity: 0.7;
  }

  .scene-processing-text {
    animation: none;
  }

  .scene-processing-scanlines {
    animation: none;
    opacity: 0.3;
  }

  .scene-generating-spinner {
    animation: none;
    border-color: var(--accent-color);
  }

  /* U-089: 정밀분석 애니메이션 비활성화 (prefers-reduced-motion) */
  .scene-analyzing-overlay {
    animation: none;
  }

  .scene-analyzing-scanline::before,
  .scene-analyzing-scanline::after {
    animation: none;
    top: 50%;
    opacity: 0.5;
  }

  .scene-analyzing-text {
    animation: none;
    opacity: 1;
  }
}

/* ============================================
   8.0.3 이미지 에러 배지 (U-020)
   - RULE-004: 실패 시 안전한 폴백
   ============================================ */

.scene-error-badge {
  position: absolute;
  top: var(--spacing-md);
  right: var(--spacing-md);
  display: flex;
  align-items: center;
  gap: var(--spacing-xs);
  padding: var(--spacing-xs) var(--spacing-sm);
  background-color: rgba(40, 0, 0, 0.9);
  border: 1px solid var(--warning-color);
  border-radius: 2px;
  z-index: 15;
  animation: error-shake 0.3s ease-out;
}

@keyframes error-shake {
  0%,
  100% {
    transform: translateX(0);
  }
  25% {
    transform: translateX(-4px);
  }
  75% {
    transform: translateX(4px);
  }
}

.scene-error-icon {
  font-size: 0.875rem;
}

.scene-error-text {
  font-size: var(--font-size-xs);
  color: var(--warning-color);
  text-transform: uppercase;
  letter-spacing: 1px;
}

/* reduced-motion: 로딩/에러 애니메이션 완화 */
@media (prefers-reduced-motion: reduce) {
  .scene-loading-indicator {
    animation: none;
  }

  .scene-loading-spinner {
    animation: none;
    border-color: var(--accent-color);
  }

  .scene-canvas.image-loading::before {
    animation: none;
    transform: none;
  }

  .scene-error-badge {
    animation: none;
  }

  .scene-canvas .scene-image {
    transition: none;
    opacity: 1;
  }

  .scene-canvas .scene-image.scene-image-loaded {
    opacity: 1;
  }
}

/* ============================================
   8.1 핫스팟 오버레이 (U-010)
   - RULE-009: 좌표 규약 (0~1000 정규화)
   - 클릭 가능한 오브젝트 영역 표시
   ============================================ */

/* 핫스팟 레이어 (장면 이미지 위 오버레이) */
.hotspot-layer {
  position: absolute;
  top: 0;
  left: 0;
  width: 100%;
  height: 100%;
  pointer-events: none;
  z-index: 10;
}

/* 개별 핫스팟 오버레이 */
/* U-050: Option A - 면 최소화, 테두리/outline 중심 강조 */
.hotspot-overlay {
  position: absolute;
  pointer-events: auto;
  cursor: pointer;
  /* 면: 거의 투명 (콘텐츠 보호) */
  background-color: rgba(51, 255, 0, 0.02);
  /* 테두리: 대시 패턴으로 시각적 구분 + 존재감 */
  border: 1.5px dashed var(--text-color);
  border-radius: 2px;
  /* 글로우: 매우 얕고 좁게 (4px blur, 낮은 opacity) */
  box-shadow: 0 0 4px rgba(51, 255, 0, 0.15);
  transition:
    border-color 0.2s,
    border-style 0.2s,
    background-color 0.2s,
    box-shadow 0.2s;
}

/* 핫스팟 호버 효과 - U-050: 테두리 중심, 면 최소화 */
.hotspot-overlay.hovered {
  /* 면: 아주 미세한 틴트만 (덮임 방지) */
  background-color: rgba(255, 0, 255, 0.04);
  /* 테두리: solid로 전환 + 강조색 */
  border: 2px solid var(--accent-color);
  /* 글로우: 컴팩트하게 (6px blur) */
  box-shadow:
    0 0 6px rgba(255, 0, 255, 0.35),
    inset 0 0 2px rgba(255, 0, 255, 0.1);
  /* scale 제거 - 덮임 방지 */
  transform: none;
}

/* 핫스팟 포커스 효과 (접근성) */
.hotspot-overlay:focus {
  outline: 2px solid var(--accent-color);
  outline-offset: 2px;
}

/* 비활성화된 핫스팟 */
.hotspot-overlay.disabled {
  cursor: not-allowed;
  border-color: var(--text-dim);
  background-color: rgba(0, 0, 0, 0.3);
  box-shadow: none;
  opacity: 0.5;
}

.hotspot-overlay.disabled:hover {
  transform: none;
  border-color: var(--text-dim);
  background-color: rgba(0, 0, 0, 0.3);
}

/* ============================================
   8.2 핫스팟 드롭 타겟 상태 (U-012)
   - 드래그 오버 시 하이라이트 강화
   - 드롭 가능/불가 상태 시각화
   ============================================ */

/* 드롭 타겟 활성 상태 (아이템이 위에 있을 때) */
/* U-050: 면 최소화, 글로우 축소, 펄스 느리게 */
.hotspot-overlay.drop-target-active {
  /* 면: 미세한 경고 틴트 */
  background-color: rgba(255, 170, 0, 0.06);
  /* 테두리: 두껍게 + solid */
  border: 2.5px solid var(--warning-color);
  /* 글로우: 적당히 (8px blur) */
  box-shadow:
    0 0 8px rgba(255, 170, 0, 0.4),
    inset 0 0 3px rgba(255, 170, 0, 0.15);
  /* scale 축소 */
  transform: scale(1.01);
  /* 펄스: 느리게 (0.6s → 1.2s) */
  animation: drop-target-pulse 1.2s ease-in-out infinite;
}

/* 드롭 타겟 펄스 애니메이션 - U-050: 부드럽게 */
@keyframes drop-target-pulse {
  0%,
  100% {
    box-shadow:
      0 0 8px rgba(255, 170, 0, 0.4),
      inset 0 0 3px rgba(255, 170, 0, 0.15);
  }
  50% {
    box-shadow:
      0 0 12px rgba(255, 170, 0, 0.5),
      inset 0 0 4px rgba(255, 170, 0, 0.2);
  }
}

/* 드롭 힌트 스타일 (툴팁 내) */
.hotspot-tooltip-drop-hint {
  display: block;
  margin-top: 4px;
  font-size: var(--font-size-sm);
  font-weight: bold;
  color: var(--warning-color);
  text-transform: uppercase;
  letter-spacing: 1px;
  animation: drop-hint-blink 0.8s ease-in-out infinite;
}

@keyframes drop-hint-blink {
  0%,
  100% {
    opacity: 1;
  }
  50% {
    opacity: 0.6;
  }
}

/* 드롭 타겟 활성화 시 툴팁 테두리 변경 - U-050: 글로우 축소 */
.hotspot-overlay.drop-target-active .hotspot-tooltip {
  border-color: var(--warning-color);
  box-shadow:
    0 0 6px rgba(255, 170, 0, 0.3),
    0 2px 8px rgba(0, 0, 0, 0.7);
}

.hotspot-overlay.drop-target-active .hotspot-tooltip::after {
  border-top-color: var(--warning-color);
}

/* reduced-motion: 드롭 애니메이션 완화 */
@media (prefers-reduced-motion: reduce) {
  .hotspot-overlay.drop-target-active {
    animation: none;
    transform: none;
  }

  .hotspot-tooltip-drop-hint {
    animation: none;
  }
}

/* 핫스팟 툴팁 - U-050: 글로우 축소, 가독성 개선 */
.hotspot-tooltip {
  position: absolute;
  bottom: calc(100% + 8px);
  left: 50%;
  transform: translateX(-50%);
  min-width: 100px;
  max-width: 200px;
  padding: var(--spacing-xs) var(--spacing-sm);
  /* 배경: 약간 더 불투명하게 (가독성) */
  background-color: rgba(0, 15, 0, 0.92);
  border: 1px solid var(--accent-color);
  border-radius: 2px;
  /* 글로우: 축소 (10px → 5px) */
  box-shadow:
    0 0 5px rgba(255, 0, 255, 0.25),
    0 2px 8px rgba(0, 0, 0, 0.7);
  z-index: 20;
  white-space: nowrap;
  animation: tooltip-fade-in 0.15s ease-out;
  /* 다른 핫스팟 클릭을 차단하지 않도록 이벤트 투과 */
  pointer-events: none;
}

@keyframes tooltip-fade-in {
  from {
    opacity: 0;
    transform: translateX(-50%) translateY(4px);
  }
  to {
    opacity: 1;
    transform: translateX(-50%) translateY(0);
  }
}

/* 툴팁 화살표 (하단 가리키기) */
.hotspot-tooltip::after {
  content: '';
  position: absolute;
  top: 100%;
  left: 50%;
  transform: translateX(-50%);
  border: 6px solid transparent;
  border-top-color: var(--accent-color);
}

/* 툴팁 라벨 */
/* U-057: 툴팁 라벨 글로우 완화 */
.hotspot-tooltip-label {
  display: block;
  font-size: var(--font-size-sm);
  font-weight: bold;
  color: var(--text-color);
  text-transform: uppercase;
  letter-spacing: 1px;
  text-shadow: 0 0 2px rgba(51, 255, 0, 0.3);
  -webkit-font-smoothing: antialiased;
}

/* 툴팁 힌트 */
.hotspot-tooltip-hint {
  display: block;
  margin-top: 2px;
  font-size: var(--font-size-xs);
  color: var(--text-dim);
}

/* 핫스팟 있을 때 Scene Canvas 조정 */
.scene-canvas.has-hotspots {
  /* 핫스팟 레이어를 위한 position 컨텍스트 확보 */
  position: relative;
}

/* 모바일에서 핫스팟 터치 영역 확대 - U-050: 툴팁 위치 조정 */
@media (max-width: 768px) {
  .hotspot-overlay {
    /* 터치 영역 최소 44px 보장 */
    min-width: 44px;
    min-height: 44px;
  }

  .hotspot-tooltip {
    /* 화면 상단 가림 방지: 아래로 표시 */
    bottom: auto;
    top: calc(100% + 6px);
    max-width: 140px;
    font-size: 0.8rem;
  }

  .hotspot-tooltip::after {
    /* 화살표 방향 반전 */
    top: auto;
    bottom: 100%;
    border-top-color: transparent;
    border-bottom-color: var(--accent-color);
  }

  .hotspot-overlay.drop-target-active .hotspot-tooltip::after {
    border-bottom-color: var(--warning-color);
  }
}

/* 태블릿 중간 크기 - U-050 */
@media (min-width: 769px) and (max-width: 1200px) {
  .hotspot-tooltip {
    max-width: 170px;
  }
}

/* 접근성: reduced-motion에서 애니메이션 완화 */
@media (prefers-reduced-motion: reduce) {
  .hotspot-overlay {
    transition: none;
  }

  .hotspot-overlay.hovered {
    transform: none;
  }

  .hotspot-tooltip {
    animation: none;
  }
}

/* 내러티브 피드 - RULE-002: 채팅 버블 아님, 게임 로그 형태 */
.narrative-feed {
  /* U-073: Scene Canvas 1:1 비율에 맞춰 남은 공간 활용 */
  flex: 1;
  min-height: 200px; /* 최소 6~7줄 표시 가능 */
  border: 1px solid var(--border-color);
  background-color: var(--panel-bg);
  box-shadow: inset 0 0 20px rgba(0, 0, 0, 0.8);
  overflow-y: auto;
  overflow-x: hidden; /* U-049: 불필요한 가로 스크롤 방지 */
  scrollbar-width: thin; /* Firefox: 얇은 스크롤바 */
  padding: var(--spacing-sm);
}

.narrative-entry {
  padding: var(--spacing-xs) 0;
  border-bottom: 1px solid rgba(51, 255, 0, 0.2);
}

.narrative-entry:last-child {
  border-bottom: none;
}

.narrative-timestamp {
  color: var(--text-dim);
  font-size: 0.75rem;
  margin-right: var(--spacing-sm);
}

.narrative-text {
  color: var(--text-color);
}

/* ============================================
   8.0.1 U-125: 이전 턴 텍스트 주목성 제거
   - Q1 Option A: 색상 dim + 폰트 0.85em + opacity 0.75 (3중 약화)
   - Q2 Option B: hover 시 opacity: 1 + 기본 색상 복원
   - 시스템 메시지(.system-entry)는 기존 스타일 유지
   - 현재 턴(.narrative-active-text)은 밝은 스타일 유지
   ============================================ */

/* 이전 턴 내러티브 엔트리: dim + 폰트 축소 + opacity 약화 */
.narrative-entry.past-entry {
  font-size: 0.85em;
  opacity: 0.75;
  line-height: 1.4;
  transition: opacity 0.2s ease;
}

/* 일반 내러티브 텍스트만 dim 색상 적용 (액션로그/시스템은 개별 색상 유지) */
.narrative-entry.past-entry:not(.action-log-entry):not(.system-entry) .narrative-text {
  color: var(--text-dim);
}

.narrative-entry.past-entry .narrative-timestamp {
  opacity: 0.7;
}

/* 이전 턴 hover 시 복원 (Q2 Option B: opacity + 기본 색상) */
.narrative-entry.past-entry:hover {
  opacity: 1;
}

.narrative-entry.past-entry:hover .narrative-text {
  color: var(--text-color);
}

/* 액션 로그가 이전 턴일 때: 폰트 더 축소 (이미 작음) + muted 색상 유지 */
.narrative-entry.past-entry.action-log-entry {
  font-size: 0.75em;
  opacity: 0.7;
}

.narrative-entry.past-entry.action-log-entry .narrative-text {
  color: var(--text-muted);
}

/* 시스템 메시지가 이전 턴일 때: 기존 font-size 유지 (별도 스타일) */
.narrative-entry.past-entry.system-entry {
  font-size: 0.85em; /* 시스템 메시지 기본 크기 유지 */
  opacity: 0.6;
}

.narrative-entry.past-entry.system-entry .narrative-text {
  color: var(--text-dim);
}

/* 현재 턴 (streaming/typing): 밝은 스타일 강조 + 미세 구분선 */
.narrative-entry.narrative-active-text {
  font-size: 1em;
  opacity: 1;
  line-height: 1.6;
  border-top: 1px solid var(--border-dim);
  padding-top: var(--spacing-sm);
  margin-top: var(--spacing-xs);
}

.narrative-entry.narrative-active-text .narrative-text {
  color: var(--text-color);
}

/* ============================================
   8.1. U-070: Action Log Entry 스타일
   - 액션 로그는 내러티브와 시각적으로 구분됨
   - PRD 9.0: "행동 실행: ..." 형식으로 표시
   - Q1 Option A: 동일 영역에 다른 스타일(dim, 이탤릭)
   ============================================ */

.action-log-entry {
  color: var(--text-muted);
  font-style: italic;
  font-size: 0.8em;
  padding-left: 0.8em;
  border-left: 1px solid var(--text-muted);
  border-bottom: none;
  margin: 2px 0;
  opacity: 0.7;
}

.action-log-entry .narrative-text {
  color: var(--text-muted);
  font-style: italic;
}

.action-log-icon {
  color: var(--text-muted);
  margin-right: 4px;
  font-style: normal;
  font-size: 0.9em;
}

/* System entry 스타일 (드롭 실패 등) */
.system-entry {
  color: var(--text-dim);
  opacity: 0.7;
  font-size: 0.85em;
}

.system-entry .narrative-text {
  color: var(--text-dim);
}

/* ============================================
   9. Sidebar (Right) 영역
   - Agent Console, Memory Pin, Scanner Slot
   - U-049: 컬럼 전체 스크롤 제거, 패널 콘텐츠 단위 스크롤
   ============================================ */

.sidebar-right {
  grid-area: sidebar-right;
  display: flex;
  flex-direction: column;
  gap: var(--layout-gap); /* U-073: 레이아웃 갭 통일 */
  min-height: 0; /* U-049: flex 자식 축소 허용 */
  overflow: hidden; /* U-049: 컬럼 전체 스크롤 제거 */
}

/* ============================================
   10. Footer 영역
   - Action Deck, Command Input
   ============================================ */

.game-footer {
  grid-area: footer;
  display: flex;
  flex-direction: column;
  /* U-050 v5: 카드와 입력창 사이 간격 축소 */
  gap: 2px;
  padding: var(--spacing-sm);
  border: 1px solid var(--border-color);
  background-color: var(--panel-bg);
  box-shadow: inset 0 0 20px rgba(0, 0, 0, 0.5);
}

/* ============================================
   10.1 Action Deck (U-009: 게임 카드 UI)
   - RULE-002: 채팅 버튼이 아닌 게임 카드
   - RULE-005: 비용/위험/보상 표시
   ============================================ */

.action-deck {
  display: flex;
  /* U-083: 뱃지 유무와 관계없이 카드 높이를 일관되게 유지 */
  align-items: stretch;
  gap: var(--spacing-sm);
  /* U-050 v6: 카드 높이 축소에 맞춰 min-height 감소 */
  min-height: 85px;
  padding: var(--spacing-xs) 0 0;
  /* U-049: 드래그 스크롤 - 스크롤바 숨김 */
  overflow-x: auto;
  overflow-y: visible;
  scrollbar-width: none; /* Firefox */
  -ms-overflow-style: none; /* IE/Edge */
  /* 터치 디바이스 부드러운 스크롤 */
  -webkit-overflow-scrolling: touch;
  scroll-behavior: smooth;
  /* 드래그 스크롤을 위한 커서 */
  cursor: grab;
  /* 카드 스냅 */
  scroll-snap-type: x mandatory;
  scroll-padding: 0 var(--spacing-sm);
}

.action-deck::-webkit-scrollbar {
  display: none; /* Chrome/Safari */
}

.action-deck:active,
.action-deck.is-dragging {
  cursor: grabbing;
  user-select: none; /* 드래그 중 텍스트 선택 방지 */
}

/* U-049: 터치 디바이스 최적화 (Web Interface Guidelines) */
.action-deck {
  touch-action: pan-x; /* 수평 스크롤만 허용 */
  -webkit-tap-highlight-color: transparent;
}

.action-deck .action-card {
  scroll-snap-align: start;
  flex-shrink: 0; /* 카드 축소 방지 */
}

/* 카드 기본 스타일 - 게임 카드처럼 보이게 */
.action-card {
  position: relative;
  min-width: 160px;
  max-width: 200px;
  /* U-050 v6: padding 축소 - 컴팩트한 카드 */
  padding: var(--spacing-xs) var(--spacing-sm) var(--spacing-sm);
  border: 2px solid var(--border-color);
  border-radius: var(--border-radius);
  /* U-049: 배경 대비 강화 - 더 불투명한 배경 */
  background: linear-gradient(180deg, rgba(0, 20, 0, 0.98) 0%, rgba(0, 10, 0, 0.99) 100%);
  /* U-049: 내부 그림자로 깊이감 추가 */
  box-shadow:
    inset 0 0 20px rgba(0, 0, 0, 0.6),
    inset 0 1px 0 rgba(51, 255, 0, 0.1);
  cursor: pointer;
  transition:
    border-color 0.2s,
    box-shadow 0.2s,
    transform 0.15s;
  display: flex;
  flex-direction: column;
  gap: 2px;
}

/* 위험도별 테두리 색상 */
.action-card.risk-border-low {
  border-color: var(--text-color);
}

.action-card.risk-border-medium {
  border-color: var(--warning-color);
}

.action-card.risk-border-high {
  border-color: var(--error-color);
}

/* 호버 효과 - 카드가 살짝 올라오는 느낌 */
.action-card:hover:not(:disabled) {
  border-color: var(--accent-color);
  box-shadow:
    0 0 15px var(--accent-color),
    0 4px 20px rgba(0, 0, 0, 0.5);
  transform: translateY(-4px);
}

/* 카드 타이틀 - U-050 v6: 컴팩트 카드에 맞춰 크기 축소 */
/* U-057: 글로우 완화 (10px/20px → 3px) - 가독성 개선 */
.action-card-title {
  font-size: 0.85rem;
  font-weight: bold;
  color: var(--text-color);
  text-transform: uppercase;
  letter-spacing: 0.5px;
  /* U-057: 과도한 글로우 완화 - 분위기 유지 + 가독성 */
  text-shadow:
    0 0 3px rgba(51, 255, 0, 0.4),
    0 1px 2px rgba(0, 0, 0, 0.9);
  padding-bottom: 2px;
  border-bottom: 1px solid var(--text-dim);
  -webkit-font-smoothing: antialiased;
  /* U-083: 남는 공간을 타이틀이 차지 → 비용/뱃지가 항상 카드 하단 정렬 */
  flex: 1;
}

/* 카드 설명 - U-050 v6: 컴팩트 카드에 맞춰 축소 */
.action-card-description {
  font-size: 0.7rem;
  color: var(--text-dim);
  line-height: 1.2;
  min-height: 1.5em;
}

/* 비용 표시 영역 - U-050 v6: 컴팩트 너비, 가운데 정렬 */
.action-card-cost {
  display: flex;
  align-items: center;
  justify-content: center;
  flex-wrap: wrap;
  gap: 4px;
  font-size: 0.65rem;
  color: var(--warning-color);
  padding: 2px var(--spacing-xs);
  /* U-050 v6: 컨텐츠에 맞는 너비 + 카드 내 가운데 배치 */
  width: fit-content;
  margin: 0 auto;
  /* U-083: 비용 행을 카드 하단으로 밀어넣기 (타이틀 flex:1과 연동) */
  margin-top: auto;
  /* U-049: 더 강한 배경 대비 */
  background: linear-gradient(180deg, rgba(0, 0, 0, 0.7) 0%, rgba(0, 0, 0, 0.85) 100%);
  border: 1px solid rgba(51, 255, 0, 0.2);
  border-radius: 2px;
  /* U-049: 텍스트 그림자 */
  text-shadow: 0 1px 2px rgba(0, 0, 0, 0.9);
}

.action-card-cost .cost-item {
  display: inline-flex;
  align-items: center;
  gap: 2px;
}

.action-card-cost .cost-separator {
  color: var(--text-dim);
  margin: 0 2px;
}

.action-card-cost .cost-value {
  font-weight: bold;
  font-family: var(--font-micro-en);
}

/* 위험도 라벨 색상 */
.action-card-cost .risk-label {
  text-transform: uppercase;
  font-size: 0.625rem;
  font-weight: bold;
}

.action-card-cost .risk-label.risk-low {
  color: var(--text-color);
}

.action-card-cost .risk-label.risk-medium {
  color: var(--warning-color);
}

.action-card-cost .risk-label.risk-high {
  color: var(--error-color);
}

/* 힌트 영역 (위험/보상) */
.action-card-hints {
  display: flex;
  flex-direction: column;
  gap: 2px;
  font-size: 0.625rem;
  padding-top: var(--spacing-xs);
  border-top: 1px dashed var(--text-dim);
}

.action-card-hints .hint-item {
  display: flex;
  align-items: flex-start;
  gap: 4px;
}

.action-card-hints .hint-icon {
  flex-shrink: 0;
}

.action-card-hints .hint-risk {
  color: var(--warning-color);
}

.action-card-hints .hint-reward {
  color: var(--accent-color);
}

.action-card-hints .hint-text {
  color: var(--text-dim);
  line-height: 1.2;
}

/* U-083: 뱃지 컨테이너 - 비용 아래 별도 행 (Q3: Option C) */
.action-card-badges {
  display: flex;
  flex-wrap: wrap;
  justify-content: center;
  gap: 3px;
  margin-top: 3px;
}

/* U-083: 통합 뱃지 기본 스타일 (Q2: ellipsis + 툴팁) */
.action-card-badge {
  display: inline-flex;
  align-items: center;
  gap: 2px;
  padding: 1px 5px;
  font-size: 0.55rem;
  font-weight: bold;
  text-transform: uppercase;
  letter-spacing: 0.5px;
  border-radius: 2px;
  max-width: 90px;
  overflow: hidden;
  text-overflow: ellipsis;
  white-space: nowrap;
  line-height: 1.3;
}

/* U-083: 뱃지 타입별 색상 */
.action-card-badge.badge-alternative {
  background-color: var(--text-color);
  color: var(--bg-color);
}

.action-card-badge.badge-quality {
  background: linear-gradient(135deg, #ffd700, #ff8c00);
  color: #000;
}

.action-card-badge.badge-vision {
  background: linear-gradient(135deg, #00e5ff, #00b0ff);
  color: #000;
}

.action-card-badge.badge-earn {
  background: linear-gradient(135deg, rgba(255, 200, 0, 0.4), rgba(255, 165, 0, 0.35));
  border: 1px solid rgba(255, 200, 0, 0.5);
  color: #ffc800;
}

/* U-083: "외 N개" 오버플로 표시 (Q1: Option B) */
.action-card-badge.badge-overflow {
  background-color: var(--text-dim);
  color: var(--bg-color);
  font-size: 0.5rem;
  max-width: unset;
  cursor: help;
}

/* 대안 카드 스타일 */
.action-card.card-alternative {
  border-style: dashed;
  opacity: 0.85;
  min-width: 140px;
}

.action-card.card-alternative:hover:not(:disabled) {
  opacity: 1;
}

/* U-069: QUALITY 모델 카드 스타일 */
.action-card.card-quality {
  border-color: #ffd700;
}

.action-card.card-quality:hover:not(:disabled) {
  border-color: #ffd700;
  box-shadow:
    0 0 15px rgba(255, 215, 0, 0.4),
    0 0 30px rgba(255, 215, 0, 0.2);
}

/* U-083: quality-badge는 .action-card-badge.badge-quality로 통합됨 (하위 호환 제거) */

.action-card-cost .quality-cost {
  color: #ffd700;
}

.action-card-cost .cost-multiplier {
  font-size: 0.55rem;
  margin-left: 1px;
  opacity: 0.8;
}

/* U-076: VISION(정밀분석) 카드 스타일 */
.action-card.card-vision {
  border-color: #00e5ff;
}

.action-card.card-vision:hover:not(:disabled) {
  border-color: #00e5ff;
  box-shadow:
    0 0 15px rgba(0, 229, 255, 0.4),
    0 0 30px rgba(0, 229, 255, 0.2);
}

/* U-083: vision-badge는 .action-card-badge.badge-vision으로 통합됨 (하위 호환 제거) */

.action-card-cost .vision-cost {
  color: #00e5ff;
}

/* U-128: VISION 카드 정밀분석 완료 비활성화 스타일 */
/* 기존 disabled보다 더 dim 처리하여 "이미 수행됨"을 시각적으로 강조 */
.action-card.card-vision.card-disabled,
.action-card.card-vision:disabled {
  border-color: rgba(0, 229, 255, 0.25);
  opacity: 0.4;
}

/* U-128: VISION 배지도 함께 dim 처리 */
.action-card.card-vision.card-disabled .badge-vision,
.action-card.card-vision:disabled .badge-vision {
  opacity: 0.5;
}

/* 비활성화된 카드 */
.action-card.card-disabled,
.action-card:disabled {
  opacity: 0.5;
  cursor: not-allowed;
  border-color: var(--text-dim);
  transform: none;
}

.action-card.card-disabled:hover,
.action-card:disabled:hover {
  border-color: var(--text-dim);
  box-shadow: none;
  transform: none;
}

/* 비활성화 오버레이 */
.action-card .card-disabled-overlay {
  position: absolute;
  inset: 0;
  display: flex;
  align-items: center;
  justify-content: center;
  background-color: rgba(0, 0, 0, 0.7);
  border-radius: var(--border-radius);
}

.action-card .card-disabled-overlay .disabled-reason {
  padding: var(--spacing-xs) var(--spacing-sm);
  font-size: 0.625rem;
  font-weight: bold;
  text-transform: uppercase;
  letter-spacing: 1px;
  color: var(--error-color);
  background-color: rgba(0, 0, 0, 0.8);
  border: 1px solid var(--error-color);
  text-shadow: 0 0 5px var(--error-color);
}

/* 모든 카드 비활성화 안내 */
.action-deck .deck-empty-notice {
  display: flex;
  align-items: center;
  justify-content: center;
  min-width: 200px;
  padding: var(--spacing-md);
  color: var(--warning-color);
  font-size: 0.75rem;
  text-align: center;
  border: 1px dashed var(--warning-color);
  background-color: rgba(255, 170, 0, 0.1);
}

.command-input-area {
  display: flex;
  align-items: center;
  gap: var(--spacing-sm);
  padding: var(--spacing-xs);
  border: 1px solid var(--text-dim);
  background-color: rgba(0, 0, 0, 0.5);
}

.command-prompt {
  color: var(--text-color);
  font-size: var(--font-size-lg);
}

.command-input {
  flex: 1;
  background: transparent;
  border: none;
  color: var(--text-color);
  font-family: var(--font-main);
  font-size: var(--font-size-lg);
  outline: none;
  text-shadow: 0 0 5px var(--text-dim);
}

.command-input::placeholder {
  color: var(--text-dim);
}

/* ============================================
   11. 공통 패널 스타일
   - U-049: flex 스크롤 전략 정리 (min-height: 0 핵심)
   ============================================ */

.panel {
  border: 1px solid var(--border-color);
  background-color: var(--panel-bg);
  box-shadow: inset 0 0 20px rgba(0, 0, 0, 0.8);
  display: flex;
  flex-direction: column;
  min-height: 0; /* U-049: flex item 축소 허용 (필수) */
  overflow: hidden; /* U-049: 패널 자체 스크롤 방지 */
}

.panel-header {
  padding: var(--spacing-xs) var(--spacing-sm);
  border-bottom: 1px solid var(--text-dim);
  background-color: rgba(0, 0, 0, 0.3);
  display: flex;
  align-items: center;
  justify-content: space-between;
  flex-shrink: 0; /* U-049: 헤더는 축소하지 않음 */
}

.panel-title {
  font-size: 0.875rem;
  text-transform: uppercase;
  letter-spacing: 2px;
  color: var(--text-color);
}

.panel-content {
  flex: 1;
  padding: var(--spacing-sm);
  overflow-y: auto;
  overflow-x: hidden; /* U-049: 우측 패널 등 가로 스크롤 방지 */
  scrollbar-width: thin; /* Firefox: 얇은 스크롤바 */
  min-height: 0; /* U-049: flex 자식 축소 허용 (필수) */
}

.panel-placeholder {
  color: var(--text-dim);
  font-size: 0.875rem;
  text-align: center;
  padding: var(--spacing-md);
}

/* ===========================================
   11.1 사이드바 패널별 높이 전략 (U-082 반전)
   - U-049 원본: Agent Console flex-1 / Economy 고정
   - U-082 변경: Agent Console 콘텐츠 기반 / Economy flex-1
   - Agent Console: 기본 접힘(collapsed), 필요 시 확장
   - Economy HUD: 유연 확장으로 재화 현황 가시성 강화
   =========================================== */

/* Agent Console: flex 1.2 (U-099: Economy와 1.2:1.8 비율) */
.panel-agent-console {
  flex: 1.2;
  min-height: 0; /* flex 자식 축소 허용 */
}

.panel-agent-console .panel-content {
  overflow-y: auto; /* 콘텐츠가 넘칠 경우 내부 스크롤 */
}

/* Economy HUD: flex 1.8 (U-099: Agent Console 대비 1.5배 공간) */
.panel-economy {
  flex: 1.8;
  min-height: 0; /* flex 자식 축소 허용 */
}

.panel-economy .panel-content {
  display: flex;
  flex-direction: column;
  min-height: 0; /* U-049: flex 자식 축소 허용 */
}

/* Scanner Slot: 콘텐츠 기반 높이 */
.panel-scanner {
  flex-shrink: 0; /* 다른 패널에 밀려 축소되지 않음 */
  overflow: visible; /* U-072: 온보딩 말풍선이 패널 밖으로 나갈 수 있도록 */
}

.panel-scanner .panel-content {
  overflow: visible; /* U-072: 온보딩 말풍선 잘림 방지 */
}

/* ===========================================
   11.2 좌측 사이드바 패널별 높이 전략 (U-077 + U-081 흡수)
   - Inventory: flex-1 + min-height 보장 (절대 축소 금지)
   - Quest/Rule Board: max-height + 내부 스크롤
   - 모든 패널 헤더 항상 보임
   =========================================== */

/* Inventory 패널: 최소 높이 보장 + 내부 스크롤 위임 */
.panel-inventory {
  min-height: 120px; /* U-077: 최소 가시성 보장 */
}

/* U-077: 인벤토리 패널 내부 스크롤을 inventory-panel-content에 위임 */
.panel-inventory .panel-content {
  overflow: hidden;
}

/* Quest 패널: max-height 제한 + 내부 스크롤 */
.panel-quest {
  max-height: 200px; /* U-077(U-081 흡수): 과도한 확장 방지 */
  flex-shrink: 0;
}

.panel-quest .panel-content {
  overflow-y: auto;
  scrollbar-width: thin;
  scrollbar-color: var(--text-dim) transparent;
}

/* Rule Board 패널: max-height 제한 + 내부 스크롤 */
.panel-rule-board {
  max-height: 200px; /* U-077(U-081 흡수): 과도한 확장 방지 */
  flex-shrink: 0;
}

.panel-rule-board .panel-content {
  overflow-y: auto;
  scrollbar-width: thin;
  scrollbar-color: var(--text-dim) transparent;
}

/* U-077: 반응형 - 뷰포트 높이가 작을 때 조정 */
@media (max-height: 768px) {
  .panel-inventory {
    min-height: 100px;
  }

  .panel-quest {
    max-height: 150px;
  }

  .panel-rule-board {
    max-height: 150px;
  }
}

/* ============================================
   12. 버튼 스타일
   ============================================ */

button,
.btn {
  background: var(--text-color);
  color: var(--bg-color);
  border: none;
  padding: var(--spacing-xs) var(--spacing-sm);
  font-family: var(--font-main);
  font-size: var(--font-size-lg);
  cursor: pointer;
  text-transform: uppercase;
  font-weight: bold;
  transition:
    background 0.2s,
    color 0.2s;
}

/* U-050 v3: 버튼 호버 - 아이콘 식별성 + 테두리 끊김 방지 */
button:hover,
.btn:hover {
  /* 면: 약한 틴트로 변경 (아이콘 덮임 방지) */
  background: rgba(255, 0, 255, 0.15);
  color: var(--accent-color);
  /* box-shadow로 테두리 효과 (outline 끊김 방지) */
  box-shadow:
    inset 0 0 0 2px var(--accent-color),
    0 0 8px rgba(255, 0, 255, 0.4);
}

button:disabled,
.btn:disabled {
  background: var(--text-dim);
  cursor: not-allowed;
}

/* ============================================
   13. 스크롤바 커스터마이징 (U-049: 다크 테마 강제)
   ============================================ */

/* 전역 웹킷 스크롤바 (Chrome, Safari, Edge) */
::-webkit-scrollbar {
  width: 6px;
  height: 6px;
}

::-webkit-scrollbar-track {
  background: var(--bg-color);
}

::-webkit-scrollbar-thumb {
  background: rgba(51, 255, 0, 0.25); /* 튀지 않는 어두운 녹색 */
  border: 1px solid rgba(51, 255, 0, 0.4);
  border-radius: 10px;
}

::-webkit-scrollbar-thumb:hover {
  background: rgba(51, 255, 0, 0.5);
}

/* 스크롤바 화살표 제거 */
::-webkit-scrollbar-button {
  display: none;
  width: 0;
  height: 0;
}

/* 코너(가로/세로 스크롤 만나는 지점) */
::-webkit-scrollbar-corner {
  background: var(--bg-color);
}

/* ============================================
   14. 반응형 디자인
   U-073: 레이아웃 확장 - 와이드스크린 지원 추가
   ============================================ */

/* 와이드스크린 (1920px 이상): 패널 최대 너비 확장, 간격 증가
 * U-073: 1800px max-width 내에서 패널이 더 넓어짐 */
@media (min-width: 1920px) {
  :root {
    --layout-side-panel-max: 420px;
    --layout-gap: var(--spacing-md);
  }
}

/* 일반 (1366px ~ 1919px): 기본 레이아웃 유지 */
/* 기본값 사용: --layout-side-panel-min: 260px, --layout-side-panel-max: 340px */

/* 컴팩트 (1024px ~ 1365px): 패널 너비 축소 */
@media (max-width: 1365px) and (min-width: 1025px) {
  :root {
    --layout-side-panel-min: 220px;
    --layout-side-panel-max: 280px;
  }
}

/* 태블릿 (769px ~ 1024px): 좌측 사이드바 숨김 */
@media (max-width: 1024px) {
  :root {
    --layout-side-panel-min: 200px;
    --layout-side-panel-max: 260px;
  }

  .game-container {
    grid-template-areas:
      'header header'
      'center sidebar-right'
      'footer footer';
    grid-template-columns:
      minmax(var(--layout-center-min), 1fr)
      minmax(var(--layout-side-panel-min), var(--layout-side-panel-max));
  }

  .sidebar-left {
    display: none;
  }
}

/* 모바일 (768px 이하): 단일 컬럼 */
@media (max-width: 768px) {
  :root {
    font-size: 14px;
    --header-height: 50px;
    --footer-height: 100px;
    --layout-gap: var(--spacing-xs);
  }

  .game-container {
    grid-template-areas:
      'header'
      'center'
      'footer';
    grid-template-columns: 1fr;
    grid-template-rows: var(--header-height) 1fr var(--footer-height);
    padding: var(--spacing-xs);
    gap: var(--spacing-xs);
  }

  .sidebar-left,
  .sidebar-right {
    display: none;
  }

  /* U-073: 모바일에서 Scene Canvas 비율 조정 */
  .scene-canvas {
    aspect-ratio: 4 / 3; /* 모바일에서는 4:3 비율 */
    max-height: calc(100vh - var(--header-height) - var(--footer-height) - 100px);
  }

  .game-header {
    padding: 0 var(--spacing-sm);
  }

  .game-title {
    font-size: var(--font-size-lg);
    letter-spacing: 2px;
  }

  .economy-hud {
    display: none;
  }

  .action-deck {
    flex-wrap: nowrap;
    overflow-x: auto;
  }

  .action-card {
    min-width: 120px;
  }
}

/* ============================================
   15. 유틸리티 클래스
   ============================================ */

.text-dim {
  color: var(--text-dim);
}

.text-accent {
  color: var(--accent-color);
}

.text-warning {
  color: var(--warning-color);
}

.text-error {
  color: var(--error-color);
}

.text-glow {
  text-shadow: 0 0 10px var(--text-color);
}

.visually-hidden {
  position: absolute;
  width: 1px;
  height: 1px;
  padding: 0;
  margin: -1px;
  overflow: hidden;
  clip: rect(0, 0, 0, 0);
  white-space: nowrap;
  border: 0;
}

/* ============================================
   16. Agent Console 스타일 (U-008)
   - RULE-008: 단계/배지/복구 표시
   ============================================ */

.agent-console-content {
  display: flex;
  flex-direction: column;
  gap: var(--spacing-xs);
  font-size: 0.75rem;
}

/* U-114: Agent Console 항상 표시 영역 (Queue 상시 노출) */
.agent-console-always {
  display: flex;
  flex-direction: column;
  gap: var(--spacing-xs);
}

.agent-console-summary {
  display: flex;
  align-items: center;
  gap: var(--spacing-sm);
  flex-wrap: wrap;
}

/* U-114: 대기열(Queue) 상시 노출 */
.agent-queue-always {
  padding: var(--spacing-xs);
}

.agent-queue-always .queue-items {
  display: grid;
  grid-template-columns: repeat(4, 1fr);
  gap: 6px;
  width: 100%;
}

/* U-114 Q1 Option A: idle 시 "대기 중..." 텍스트 */
.queue-idle {
  color: var(--text-dim);
  font-size: 0.75rem;
  text-align: center;
  padding: var(--spacing-xs) 0;
  font-family: var(--font-micro-en);
  letter-spacing: 1px;
  text-transform: uppercase;
}

/* U-123: 대기열/배지 구분선 (CRT 테마, 반투명) */
.agent-console-divider {
  border: none;
  border-top: 1px solid var(--border-color, var(--text-dim));
  opacity: 0.3;
  margin: var(--spacing-xs) 0;
}

/* U-123: 배지 섹션 (항상 노출, 접기 없음) */
.agent-badges-section {
  display: flex;
  flex-direction: column;
  gap: var(--spacing-xs);
}

.agent-badges-section .badges-panel {
  padding: 0 var(--spacing-xs);
  border-top: none;
}

.agent-badges-section .badges-panel .badges-grid {
  gap: 2px;
}

/* 스트리밍 상태 */
.streaming-status {
  display: flex;
  align-items: center;
  gap: var(--spacing-xs);
  padding: 0; /* U-082: 인라인 표시로 변경 */
}

.streaming-status .status-dot {
  width: 6px;
  height: 6px;
  border-radius: 50%;
  background-color: var(--text-dim);
  transition: background-color 0.3s;
}

.streaming-status .status-dot.active {
  background-color: var(--accent-color);
  box-shadow: 0 0 8px var(--accent-color);
  animation: pulse 1s infinite;
}

.streaming-status .status-text {
  text-transform: uppercase;
  letter-spacing: 1px;
  color: var(--text-dim);
}

.streaming-status .status-dot.active + .status-text {
  color: var(--accent-color);
}

/* 단계 큐 */
.phase-queue {
  padding: var(--spacing-xs);
}

.phase-queue .queue-label,
.agent-queue-always .queue-label,
.badges-panel .badges-label,
.repair-trace .repair-label {
  font-size: 0.75rem; /* 12px로 상향 */
  text-transform: uppercase;
  letter-spacing: 2px;
  color: #33ff00; /* 순수 인광 녹색으로 고정 */
  opacity: 1; /* 투명도 제거하여 최대 밝기 */
  margin-bottom: var(--spacing-sm);
  font-weight: 600; /* 더 굵게 */
  /* U-057: 글로우 완화 (5px → 2px) - 라벨 가독성 개선 */
  text-shadow: 0 0 2px rgba(51, 255, 0, 0.3);
  -webkit-font-smoothing: antialiased;
}

.badges-panel .badges-grid {
  display: grid;
  grid-template-columns: repeat(2, 1fr);
  gap: 6px; /* 간격 상향 */
  width: 100%;
}

.phase-queue .queue-items,
.agent-queue-always .queue-items {
  display: grid;
  grid-template-columns: repeat(4, 1fr); /* 4열 배치 강제 */
  gap: 6px;
  width: 100%;
}

/* U-037: Phase Item 식별성 극대화 */
.phase-item {
  position: relative;
  display: flex;
  align-items: center;
  justify-content: center;
  gap: 4px;
  padding: 6px 2px;
  background-color: rgba(0, 20, 0, 0.95); /* 배경 더 어둡게 */
  border: 1px solid var(--text-dim);
  border-radius: 2px;
  font-family: var(--font-micro-en);
  font-size: 0.8125rem; /* 13px로 상향 */
  font-weight: 600; /* 더 굵게 */
  letter-spacing: 0.02em;
  box-shadow: inset 0 0 10px rgba(0, 0, 0, 0.8);
}

/* 텍스트 선명도 및 글로우 최적화 (번짐 방지) */
/* U-057: filter drop-shadow도 제거 - 완전 선명 */
.phase-item > * {
  position: relative;
  z-index: 2;
  text-shadow: none !important; /* 번짐 방지를 위해 그림자 제거 */
  filter: none !important; /* U-057: drop-shadow도 제거하여 완전 선명 */
  opacity: 1 !important;
  -webkit-font-smoothing: antialiased;
}

/* 상태별 색상 대비 상향 */
.phase-item.pending {
  color: #88ff88 !important; /* 더 밝은 녹색 */
  border-color: rgba(51, 255, 0, 0.4);
}

.phase-item.in_progress,
.phase-item.in-progress {
  color: #ff00ff !important;
  border-color: #ff00ff;
  background-color: rgba(30, 0, 30, 0.95);
  box-shadow: 0 0 8px rgba(255, 0, 255, 0.4);
  /* U-087: 깜빡임(pulse) 대신 부드러운 glow 애니메이션 */
  animation: phase-glow 2.5s ease-in-out infinite;
}

/* 씬 플레이스홀더 서브 메시지 가독성 (Critical) */
.scene-status-message {
  color: var(--text-color) !important;
  opacity: 1 !important;
  text-shadow: 0 1px 3px rgba(0, 0, 0, 1) !important;
  font-size: 0.9375rem !important; /* 15px로 상향 */
  font-weight: 500 !important;
  margin-top: var(--spacing-sm);
  z-index: 10;
  position: relative;
}

/* 씬 플레이스홀더 서브 메시지 보호 */
.scene-placeholder .status-sub {
  color: var(--text-color);
  opacity: 0.9;
  text-shadow: 0 1px 2px rgba(0, 0, 0, 1);
  font-size: var(--font-size-sm);
}

/* Scene Canvas는 여전히 강력한 CRT 분위기 유지 (Q2: Option A) */
.scene-canvas::after {
  content: '';
  position: absolute;
  inset: 0;
  background: linear-gradient(rgba(18, 16, 16, 0) 50%, rgba(0, 0, 0, 0.3) 50%);
  background-size: 100% 4px;
  pointer-events: none;
  z-index: 5;
  animation: flicker 0.15s infinite;
}

/* Economy HUD 및 기타 Critical 텍스트 보호 */
.currency-value,
.action-card-cost {
  position: relative;
  z-index: 2;
  font-family: var(--font-micro-en);
  text-shadow: 0 0 2px rgba(51, 255, 0, 0.3);
}

/* U-037: pending 상태 - 밝은 색상 + 배경 대비 */
.phase-item.pending {
  color: var(--text-color);
  background-color: rgba(0, 20, 0, 0.5);
  border-color: rgba(51, 255, 0, 0.3);
  opacity: 0.8;
}

/* U-087: 두 번째 in_progress 정의는 첫 번째와 통합됨 - animation만 유지 */
.phase-item.in_progress,
.phase-item.in-progress {
  color: var(--accent-color);
  background-color: rgba(40, 0, 40, 0.5);
  border-color: var(--accent-color);
  box-shadow: 0 0 5px var(--accent-color);
}

.phase-item.completed {
  color: var(--text-color);
  background-color: rgba(0, 30, 0, 0.5);
  border-color: var(--text-color);
}

.phase-item.failed {
  color: var(--error-color);
  background-color: rgba(40, 0, 0, 0.5);
  border-color: var(--error-color);
}

.phase-icon {
  font-size: 0.5rem;
}

.phase-icon.in-progress {
  animation: spin 2s linear infinite;
}

/* U-087: in_progress 단계 부드러운 glow (pulse 깜빡임 대체) */
@keyframes phase-glow {
  0%,
  100% {
    box-shadow: 0 0 5px rgba(255, 0, 255, 0.4);
  }
  50% {
    box-shadow: 0 0 14px rgba(255, 0, 255, 0.7);
  }
}

@keyframes spin {
  from {
    transform: rotate(0deg);
  }
  to {
    transform: rotate(360deg);
  }
}

.phase-label {
  white-space: nowrap;
}

/* 배지 패널 */
.badges-panel {
  padding: var(--spacing-xs);
  border-top: 1px solid var(--text-dim);
}

.badges-panel .badges-label {
  font-size: 0.625rem;
  text-transform: uppercase;
  letter-spacing: 1px;
  color: var(--text-dim);
  margin-bottom: var(--spacing-xs);
}

.badges-panel .badges-empty {
  color: var(--text-color);
  font-size: 0.8125rem; /* 13px로 상향 */
  font-weight: 500;
  text-align: center;
  padding: var(--spacing-sm);
  opacity: 0.9;
  text-shadow: 0 1px 2px rgba(0, 0, 0, 1);
  position: relative;
  z-index: 2;
}

/* 배지 그리드 가독성 상향 (U-037) */
.badge-item {
  display: flex;
  justify-content: space-between;
  align-items: center;
  padding: 4px 6px;
  background-color: rgba(0, 20, 0, 0.9);
  border: 1px solid var(--text-dim);
  font-family: var(--font-micro-en);
  font-size: 0.75rem;
  z-index: 2;
  position: relative;
}

.badge-label {
  color: var(--text-color);
  opacity: 0.8;
}

.badge-status {
  font-weight: bold;
  text-transform: uppercase;
}

/* Auto-repair 트레이스 */
.repair-trace {
  display: flex;
  align-items: center;
  gap: var(--spacing-xs);
  padding: var(--spacing-xs);
  border-top: 1px solid var(--text-dim);
  font-size: 0.625rem;
}

.repair-trace .repair-label {
  color: var(--text-dim);
}

.repair-trace .repair-count {
  color: var(--warning-color);
  font-weight: bold;
}

.repair-trace .repair-status {
  color: var(--warning-color);
  font-size: 0.5rem;
}

/* 에러 표시 */
.agent-error {
  display: flex;
  align-items: flex-start;
  gap: var(--spacing-xs);
  padding: var(--spacing-xs);
  background-color: rgba(255, 51, 51, 0.1);
  border: 1px solid var(--error-color);
  font-size: 0.625rem;
}

.agent-error .error-icon {
  color: var(--error-color);
}

.agent-error .error-message {
  color: var(--error-color);
  flex: 1;
  word-break: break-word;
}

.agent-error .error-code {
  color: var(--text-dim);
  font-size: 0.5rem;
}

/* ============================================
   17. 내러티브 스트리밍 효과
   ============================================ */

/* U-125: 현재 턴 streaming 상태도 밝기 유지 (이전 opacity: 0.8 → 1, 이전 턴과의 대비 강화) */
.narrative-entry.streaming {
  opacity: 1;
}

.cursor-blink {
  animation: blink 1s infinite;
  color: var(--accent-color);
}

@keyframes blink {
  0%,
  50% {
    opacity: 1;
  }
  51%,
  100% {
    opacity: 0;
  }
}

/* ============================================
   17.2 U-086: 이미지 pending 상태 라인
   - 타이핑 완료 후 이미지 생성 대기 중 표시
   - RULE-002: 게임 로그 시스템 메시지 (채팅 버블 아님)
   - 단순 DOM 1개 (성능)
   ============================================ */

.image-pending-line {
  padding: var(--spacing-xs) 0;
  border-bottom: none;
  opacity: 0.8;
}

.image-pending-label {
  color: var(--text-dim);
  font-size: 0.85rem;
  font-style: italic;
  text-shadow: 0 0 4px var(--text-dim);
}

.image-pending-cursor {
  animation: blink 1s infinite;
  color: var(--text-dim);
  font-size: 0.85rem;
  margin-left: 2px;
}

/* ============================================
   18. 액션 카드 비활성화 상태
   ============================================ */

.action-card:disabled {
  opacity: 0.5;
  cursor: not-allowed;
  border-color: var(--text-dim);
}

.action-card:disabled:hover {
  border-color: var(--text-dim);
  box-shadow: none;
}

/* ============================================
   19. Economy HUD 아이콘 (U-029: nanobanana 에셋)
   ============================================ */

.economy-hud .shard-icon {
  margin-left: var(--spacing-sm);
}

/* 에셋 아이콘 래퍼 - 폴백 패턴 (U-029/U-030) */
.icon-wrapper {
  display: inline-flex;
  align-items: center;
  justify-content: center;
  position: relative;
}

.icon-wrapper .icon-img {
  width: 20px;
  height: 20px;
  object-fit: contain;
  /* (U-029) 아이콘 표시 (U-091: rembg 런타임 제거, 프롬프트로 어두운 배경 유도) */
  display: block;
}

.icon-wrapper .icon-img.hidden {
  display: none;
}

/* 폴백 텍스트는 기본 숨김, 이미지 로드 실패 시 표시 */
.icon-wrapper .icon-fallback {
  display: none;
  font-size: 1rem;
}

/* 이미지 숨김 시 폴백 표시 */
.icon-wrapper .icon-img.hidden + .icon-fallback {
  display: inline;
}

/* Risk 등급별 아이콘 필터링 (필요 시) */
.icon-img.risk-low {
  filter: drop-shadow(0 0 2px var(--text-color));
}

.icon-img.risk-high {
  filter: drop-shadow(0 0 2px var(--error-color));
}

/* 배지 아이콘 (Agent Console) */
.badge-icon-img {
  width: 14px;
  height: 14px;
  object-fit: contain;
  vertical-align: middle;
  margin-right: 2px;
}

/* ============================================
   20. Flex 유틸리티
   ============================================ */

.flex-1 {
  flex: 1;
}

/* ============================================
   21. 가독성 보호 클래스 (U-057: 텍스트 번짐 식별성 개선)
   - 페어링 결정:
     - Q1 Option A: 본문 텍스트만 보호, 제목/라벨은 글로우 유지
     - Q2 Option B: 1px 미만의 미세 글로우 (분위기 유지 + 가독성)
     - Q3 Option A: 12px 이하 텍스트만 font-weight 상향
   ============================================ */

/* 가독성 우선 영역 - CRT 효과 완전 제거 */
.readable-text {
  text-shadow: none !important;
  filter: none !important;
  -webkit-font-smoothing: antialiased;
  -moz-osx-font-smoothing: grayscale;
}

/* 분위기 유지하면서 가독성 확보 - 미세한 글로우만 */
.readable-glow {
  text-shadow: 0 0 0.5px currentColor !important;
  filter: none !important;
  -webkit-font-smoothing: antialiased;
}

/* 중요 텍스트 강조 - 약간의 글로우 */
.readable-emphasis {
  text-shadow: 0 0 2px rgba(51, 255, 0, 0.3) !important;
  filter: none !important;
}

/* 작은 텍스트 가독성 보정 (12px 이하) - Q3 Option A */
.readable-small {
  font-weight: 500;
  letter-spacing: 0.02em;
  -webkit-font-smoothing: antialiased;
}

/* ============================================
   21.0.0 본문/설명 텍스트 가독성 (U-057)
   - Q1 Option A: 본문 텍스트만 보호, 제목/라벨은 글로우 유지
   - p, span, 설명 텍스트는 효과 제거/완화
   ============================================ */

/* 본문/설명 텍스트 - 효과 최소화 */
.narrative-text,
.action-card-description,
.quest-label,
.rule-card-description,
.timeline-event-description,
.scanner-caption,
.hotspot-tooltip-hint,
.ledger-reason {
  text-shadow: none;
  filter: none;
  -webkit-font-smoothing: antialiased;
}

/* 제목/라벨 - 미세 글로우 유지 (Q2 Option B: 1px 미만) */
.game-title,
.panel-title,
.action-card-title,
.quest-section-title,
.rule-card-label,
.timeline-title,
.scanner-candidates-title {
  text-shadow: 0 0 3px rgba(51, 255, 0, 0.4);
  filter: none;
}

/* 작은 폰트 (12px/0.75rem 이하) 가독성 강화 - Q3 Option A */
.action-card-cost,
.action-card-hints,
.action-card-hints .hint-text,
.action-card-badge,
.card-disabled-overlay .disabled-reason,
.narrative-timestamp,
.phase-queue .queue-label,
.agent-queue-always .queue-label,
.badges-panel .badges-label,
.repair-trace .repair-label,
.repair-trace .repair-status,
.agent-error .error-code,
.timeline-event-turn,
.timeline-event-type,
.ledger-model,
.scanner-stats,
.scanner-candidate-type,
.cost-label,
.timeline-more-text {
  font-weight: 500;
  letter-spacing: 0.02em;
  -webkit-font-smoothing: antialiased;
  -moz-osx-font-smoothing: grayscale;
}

/* ============================================
   21.0.1 중요도 기반 레이어링 (U-037: critical/ambient)
   - critical: 어두운 배경/패널 내부의 작은 텍스트 (마이크로 텍스트)
   - ambient: 분위기/장식, 로고/타이틀/패널 헤더 (기본 스타일)
   - Scene Canvas 중심으로 CRT 분위기 집중 (Q2: Option A)
   ============================================ */

/*
 * Critical 영역 기준 (U-037 재정의):
 * - 박스/패널 내부 콘텐츠 (어두운 배경 위 텍스트)
 * - 마이크로 텍스트 (0.75rem 이하: 배지, 비용, 타임스탬프 등)
 * - 배경색이 다양할 수 있는 영역 (에러 박스 등)
 *
 * Non-Critical (기본 스타일):
 * - 로고/타이틀 (UNKNOWN WORLD) - 충분히 크고 밝음
 * - 패널 헤더/라벨 (INVENTORY, QUEST 등) - 밝은 배경
 * - 액션 카드 제목 (탐색하기 등) - 충분히 큰 폰트
 */

/* Critical 영역: 패널 내부 작은 텍스트 가독성 보장 */
[data-ui-importance='critical'],
.ui-critical {
  /* 텍스트 대비 강화 - 어두운 배경에서 읽힘 보장 */
  color: var(--text-color);
  text-shadow:
    0 0 2px var(--text-color),
    0 1px 1px rgba(0, 0, 0, 0.9);
}

/* Critical 영역 내 보조 텍스트(dim)도 가독성 보장 */
[data-ui-importance='critical'] .text-dim,
.ui-critical .text-dim {
  color: var(--text-dim);
  text-shadow: 0 1px 1px rgba(0, 0, 0, 0.9);
}

/* Ambient 영역: CRT 분위기 허용 (기본값) */
[data-ui-importance='ambient'],
.ui-ambient {
  /* 기본 CRT 스타일 유지 - 로고/타이틀/패널 헤더 */
}

/* ============================================
   21.1 마이크로 텍스트 Critical 적용 (작은 폰트)
   - 0.75rem 이하 텍스트는 자동 Critical
   ============================================ */

/* Action Card 비용/위험 정보 (작은 텍스트, 어두운 카드 배경) */
/* U-057: 글로우 완화 - 작은 텍스트 가독성 우선 */
.action-card-cost {
  text-shadow: 0 1px 1px rgba(0, 0, 0, 0.9);
  -webkit-font-smoothing: antialiased;
}

/* 에러/차단 메시지 (배경색 다양, 중요 정보) */
/* U-057: 에러 메시지도 가독성 우선 */
.agent-error {
  text-shadow: 0 1px 1px rgba(0, 0, 0, 0.9);
  -webkit-font-smoothing: antialiased;
}

/* 배지 상태 텍스트 (작은 폰트, 패널 내부) */
/* U-057: 작은 텍스트는 글로우 제거 */
.badge-status {
  text-shadow: none;
  -webkit-font-smoothing: antialiased;
}

/* 내러티브 타임스탬프 (작은 폰트) */
/* U-057: 타임스탬프 가독성 개선 */
.narrative-timestamp {
  text-shadow: none;
  font-weight: 500;
  -webkit-font-smoothing: antialiased;
}

/* 복구 트레이스 (작은 폰트, 경고 정보) */
/* U-057: 작은 텍스트 글로우 제거 */
.repair-trace .repair-count {
  text-shadow: none;
  font-weight: 600;
  -webkit-font-smoothing: antialiased;
}

/* ============================================
   21.1 Scene Canvas 중심 CRT 분위기 (Q2: Option A)
   - 전역 오버레이 대신 Scene Canvas에 효과 집중
   ============================================ */

/* 전역 CRT 오버레이: 강도 약화 (critical 영역 보호) - U-050: 0.3 → 0.25 */
.crt-overlay {
  opacity: 0.25;
}

/* Scene Canvas: CRT 분위기 강화 (ambient 영역) */
.scene-canvas {
  position: relative;
}

/* U-050 v5: Scene Canvas CRT 효과 - 스캔라인 강조, 깜빡임 완화 */
.scene-canvas::after {
  content: '';
  position: absolute;
  top: 0;
  left: 0;
  width: 100%;
  height: 100%;
  /* 스캔라인: 적당히 */
  background: linear-gradient(rgba(18, 16, 16, 0) 50%, rgba(0, 0, 0, 0.4) 50%);
  background-size: 100% 2px;
  pointer-events: none;
  z-index: 1;
  /* 플리커: 느리게 */
  animation: flicker 0.5s infinite;
  opacity: 0.8;
}

/* Scene Canvas placeholder는 분위기 유지하면서 텍스트 읽힘 보장 */
.scene-placeholder {
  position: relative;
  z-index: 2;
}

/* ============================================
   22. 마이크로 텍스트 가독성 상향 (U-028→U-037)
   - 0.625rem → --font-size-xs (0.75rem)
   - Critical 영역은 자동 가독성 보장
   ============================================ */

/* Agent Console 기본 폰트 상향 */
.agent-console-content {
  font-size: var(--font-size-xs);
}

/* 큐 라벨 폰트 상향 */
.phase-queue .queue-label,
.agent-queue-always .queue-label {
  font-size: calc(var(--font-size-xs) * 0.85);
}

/* 단계 아이템 폰트 상향 */
.phase-item {
  font-size: calc(var(--font-size-xs) * 0.85);
}

/* 배지 패널 라벨 상향 */
.badges-panel .badges-label {
  font-size: calc(var(--font-size-xs) * 0.85);
}

.badges-panel .badges-empty {
  font-size: calc(var(--font-size-xs) * 0.85);
}

/* 배지 아이템 상향 */
.badge-item {
  font-size: calc(var(--font-size-xs) * 0.85);
}

/* 복구 트레이스 상향 */
.repair-trace {
  font-size: calc(var(--font-size-xs) * 0.85);
}

.repair-trace .repair-status {
  font-size: calc(var(--font-size-xs) * 0.7);
}

/* 에러 표시 상향 */
.agent-error {
  font-size: calc(var(--font-size-xs) * 0.85);
}

.agent-error .error-code {
  font-size: calc(var(--font-size-xs) * 0.7);
}

/* 내러티브 타임스탬프 상향 */
.narrative-timestamp {
  font-size: var(--font-size-xs);
}

/* 단계 아이콘 상향 */
.phase-icon {
  font-size: calc(var(--font-size-xs) * 0.7);
}

/* ============================================
   22.1 접근성 가드 (U-037: prefers-reduced-motion)
   - 광과민/피로 방지를 위한 자동 완화
   ============================================ */

@media (prefers-reduced-motion: reduce) {
  /* 플리커 애니메이션 비활성화 - U-050: opacity 더 낮춤 */
  .crt-overlay {
    animation: none;
    opacity: 0.12;
  }

  .scene-canvas::after {
    animation: none;
    opacity: 0.2;
  }

  /* 글리치 효과 비활성화 */
  .glitch::before,
  .glitch::after {
    animation: none;
    opacity: 0;
  }

  /* 펄스 애니메이션 비활성화 */
  .status-indicator {
    animation: none;
  }

  .streaming-status .status-dot.active {
    animation: none;
  }

  .phase-item.in_progress,
  .phase-item.in-progress {
    animation: none;
  }

  /* 로딩 펄스 비활성화 */
  .scene-canvas.scene-status-loading .scene-placeholder {
    animation: none;
  }

  /* 스태틱 노이즈 비활성화 */
  .scene-canvas.scene-status-offline::before {
    animation: none;
    opacity: 0.2;
  }

  /* 커서 깜빡임 정적 표시 */
  .cursor-blink {
    animation: none;
    opacity: 1;
  }

  /* U-086: 이미지 pending 커서 애니메이션 비활성화 */
  .image-pending-cursor {
    animation: none;
    opacity: 0.7;
  }

  /* 스핀 애니메이션 비활성화 */
  .phase-icon.in-progress {
    animation: none;
  }
}

/* ============================================
   22.2 고대비 모드 지원 (prefers-contrast)
   ============================================ */

@media (prefers-contrast: more) {
  /* Critical 텍스트 대비 추가 상향 */
  [data-ui-importance='critical'],
  .ui-critical,
  .economy-hud,
  .action-card-title,
  .action-card-cost {
    text-shadow:
      0 0 4px var(--text-color),
      0 2px 2px rgba(0, 0, 0, 1);
  }

  /* 배경 대비 강화 */
  .panel-content,
  .narrative-feed {
    background-color: rgba(0, 0, 0, 0.9);
  }

  /* 테두리 대비 강화 */
  .panel,
  .action-card {
    border-width: 2px;
  }
}

/* ============================================
   22.3 Economy HUD 스타일 (U-014)
   - RULE-005: 예상 비용/확정 비용/잔액 부족 표시
   ============================================ */

/* Economy HUD 컨테이너 */
.economy-hud {
  display: flex;
  align-items: center;
  gap: var(--spacing-sm);
  padding: var(--spacing-xs) var(--spacing-sm);
  border: 1px solid var(--text-dim);
  background-color: rgba(0, 0, 0, 0.5);
}

.economy-hud-full {
  flex: 1; /* U-099: 가용 공간을 채워 하단 여백 과다 해소 */
  display: flex;
  flex-direction: column;
  align-items: stretch;
  padding: var(--spacing-sm);
  gap: var(--spacing-sm);
  min-height: 0; /* U-049: flex 자식 축소 허용 */
}

/* 잔액 부족 시 경고 스타일 */
.economy-hud.economy-hud-low,
.economy-hud-low {
  border-color: var(--warning-color);
  background-color: rgba(255, 170, 0, 0.1);
}

/* 잔액 표시 */
.economy-balance {
  display: flex;
  align-items: center;
  gap: var(--spacing-sm);
  flex-wrap: wrap;
}

.economy-balance.balance-low {
  animation: balance-warning-pulse 1.5s ease-in-out infinite;
}

@keyframes balance-warning-pulse {
  0%,
  100% {
    opacity: 1;
  }
  50% {
    opacity: 0.7;
  }
}

.balance-item {
  display: flex;
  align-items: center;
  gap: 4px;
}

/* U-082: 잔액 폰트 사이즈 확대 (가시성 강화) */
.balance-value {
  font-family: var(--font-micro-en);
  font-weight: bold;
  font-size: 1.25rem; /* U-082: var(--font-size-sm) → 1.25rem 확대 */
}

.balance-label {
  font-size: var(--font-size-xs);
  color: var(--text-dim);
  text-transform: uppercase;
  letter-spacing: 1px;
}

/* 잔액 부족 경고 */
.balance-warning {
  display: flex;
  align-items: center;
  gap: 4px;
  margin-left: var(--spacing-xs);
  padding: 2px 6px;
  background-color: rgba(255, 170, 0, 0.2);
  border: 1px solid var(--warning-color);
  border-radius: 2px;
}

.balance-warning .warning-icon {
  color: var(--warning-color);
}

.balance-warning .warning-text {
  font-size: var(--font-size-xs);
  color: var(--warning-color);
  text-transform: uppercase;
  letter-spacing: 1px;
}

.balance-warning-icon {
  color: var(--warning-color);
  margin-left: var(--spacing-xs);
  animation: blink 1s infinite;
}

/* 비용 표시 */
.economy-cost {
  padding: var(--spacing-xs);
  background-color: rgba(0, 20, 0, 0.8);
  border: 1px solid var(--text-dim);
  border-radius: 2px;
}

.economy-cost.cost-estimate {
  border-color: var(--accent-color);
  border-style: dashed;
}

.economy-cost.cost-confirmed {
  border-color: var(--text-color);
}

.economy-cost.cost-unaffordable {
  border-color: var(--error-color);
  background-color: rgba(255, 51, 51, 0.1);
}

.cost-header {
  display: flex;
  align-items: center;
  justify-content: space-between;
  margin-bottom: var(--spacing-xs);
}

.cost-title {
  font-size: var(--font-size-xs);
  color: var(--text-dim);
  text-transform: uppercase;
  letter-spacing: 1px;
}

.cost-label {
  font-size: 0.625rem;
  color: var(--accent-color);
  padding: 1px 4px;
  background-color: rgba(255, 0, 255, 0.1);
  border: 1px solid var(--accent-color);
  border-radius: 2px;
}

.cost-values {
  display: flex;
  align-items: center;
  gap: 4px;
  flex-wrap: wrap;
}

.cost-item {
  display: inline-flex;
  align-items: center;
  gap: 2px;
}

.cost-separator {
  color: var(--text-dim);
  margin: 0 2px;
}

/* U-082: 비용 폰트 사이즈 확대 */
.cost-value {
  font-family: var(--font-micro-en);
  font-weight: bold;
  font-size: 1rem; /* U-082: 확대 */
  color: var(--warning-color);
}

.cost-warning {
  margin-top: var(--spacing-xs);
  padding: 2px 4px;
  background-color: rgba(255, 51, 51, 0.2);
  border-radius: 2px;
}

.cost-warning .warning-text {
  font-size: var(--font-size-xs);
  color: var(--error-color);
  text-transform: uppercase;
  letter-spacing: 1px;
}

/* 예상 비용 미니 표시 (헤더용) */
.economy-estimate-mini {
  display: inline-flex;
  align-items: center;
  gap: 2px;
  margin-left: var(--spacing-xs);
  padding: 1px 6px;
  background-color: rgba(255, 0, 255, 0.1);
  border: 1px dashed var(--accent-color);
  border-radius: 2px;
  font-family: var(--font-micro-en);
  font-size: var(--font-size-xs);
  color: var(--accent-color);
}

.economy-estimate-mini.unaffordable {
  border-color: var(--error-color);
  background-color: rgba(255, 51, 51, 0.1);
  color: var(--error-color);
}

.estimate-prefix {
  opacity: 0.7;
}

.estimate-value {
  font-weight: bold;
}

/* 대안 안내 */
.economy-alternatives {
  padding: var(--spacing-sm);
  background-color: rgba(51, 255, 0, 0.05);
  border: 1px dashed var(--text-color);
  border-radius: 2px;
}

.alternatives-header {
  display: flex;
  align-items: center;
  gap: var(--spacing-xs);
  margin-bottom: var(--spacing-xs);
}

.alternatives-icon {
  font-size: 1rem;
}

.alternatives-title {
  font-size: var(--font-size-xs);
  color: var(--text-color);
  text-transform: uppercase;
  letter-spacing: 1px;
}

.alternatives-list {
  list-style: none;
  padding-left: calc(1rem + var(--spacing-xs));
}

.alternatives-list li {
  font-size: var(--font-size-xs);
  color: var(--text-dim);
  line-height: 1.5;
}

.alternatives-list li::before {
  content: '• ';
  color: var(--text-color);
}

/* ===========================================
   22.4 Economy Ledger 스타일 (U-049)
   - 거래 장부 영역만 내부 스크롤
   - 잔액/비용 영역은 고정
   =========================================== */

.economy-ledger {
  display: flex;
  flex-direction: column;
  min-height: 0; /* U-049: flex 자식 축소 허용 (필수) */
  /* U-099: flex: 1 적용 → 가용 공간을 채워 하단 여백 과다 해소 */
  flex: 1;
  border-top: 1px solid var(--text-dim);
  margin-top: var(--spacing-sm);
  padding-top: var(--spacing-sm);
  overflow: hidden; /* 자식인 ledger-list의 스크롤 보장 */
}

.ledger-header {
  display: flex;
  align-items: center;
  justify-content: space-between;
  margin-bottom: var(--spacing-xs);
  flex-shrink: 0; /* U-049: 헤더는 축소하지 않음 */
}

.ledger-title {
  font-size: var(--font-size-xs);
  color: var(--text-dim);
  text-transform: uppercase;
  letter-spacing: 1px;
}

/* U-049: ledger-list만 스크롤 (핵심) */
.ledger-list {
  display: flex;
  flex-direction: column;
  gap: 4px;
  overflow-y: auto;
  overflow-x: hidden; /* U-049: 불필요한 가로 스크롤 방지 */
  scrollbar-width: thin; /* Firefox: 얇은 스크롤바 */
  min-height: 0; /* U-049: flex 자식 축소 허용 */
  /* U-099: flex: 1로 확장 허용 + max-height 제거 (부모 패널 크기에 맞춤) */
  flex: 1;
  padding-right: var(--spacing-xs); /* 스크롤바 공간 */
}

.ledger-item {
  display: flex;
  align-items: center;
  justify-content: space-between;
  padding: var(--spacing-xs);
  background-color: rgba(0, 20, 0, 0.5);
  border: 1px solid var(--text-dim);
  border-radius: 2px;
  font-size: var(--font-size-xs);
}

.ledger-info {
  display: flex;
  align-items: center;
  gap: var(--spacing-xs);
  flex: 1;
  min-width: 0;
}

.ledger-turn {
  font-family: var(--font-micro-en);
  font-weight: bold;
  color: var(--text-color);
  flex-shrink: 0;
}

.ledger-reason {
  color: var(--text-dim);
  white-space: nowrap;
  overflow: hidden;
  text-overflow: ellipsis;
}

.ledger-values {
  display: flex;
  align-items: center;
  gap: var(--spacing-xs);
  flex-shrink: 0;
}

.ledger-cost {
  font-family: var(--font-micro-en);
  color: var(--warning-color);
  font-weight: bold;
}

.ledger-model {
  font-family: var(--font-micro-en);
  font-size: 0.625rem;
  color: var(--accent-color);
  padding: 1px 3px;
  background-color: rgba(255, 0, 255, 0.1);
  border: 1px solid var(--accent-color);
  border-radius: 2px;
}

.ledger-empty {
  font-size: var(--font-size-xs);
  color: var(--text-dim);
  text-align: center;
  padding: var(--spacing-sm);
}

/* reduced-motion: 경고 애니메이션 비활성화 */
@media (prefers-reduced-motion: reduce) {
  .economy-balance.balance-low {
    animation: none;
  }

  .balance-warning-icon {
    animation: none;
    opacity: 1;
  }
}

/* ============================================
   23. UI 스케일 컨트롤 버튼 스타일 (U-028→U-037)
   ============================================ */

.ui-controls {
  display: flex;
  align-items: center;
  gap: var(--spacing-xs);
}

.ui-scale-btn {
  background: transparent;
  color: var(--text-color);
  border: 1px solid var(--text-dim);
  padding: 2px 6px;
  font-family: var(--font-main);
  font-size: var(--font-size-xs);
  cursor: pointer;
  text-transform: uppercase;
  transition:
    border-color 0.2s,
    color 0.2s,
    box-shadow 0.2s;
  min-width: 28px;
  text-align: center;
}

.ui-scale-btn:hover {
  border-color: var(--accent-color);
  color: var(--accent-color);
}

.ui-scale-btn:disabled {
  opacity: 0.4;
  cursor: not-allowed;
}

.ui-scale-btn:disabled:hover {
  border-color: var(--text-dim);
  color: var(--text-dim);
}

.ui-scale-display {
  font-size: var(--font-size-xs);
  color: var(--text-dim);
  min-width: 32px;
  text-align: center;
}

/* ============================================
   24. UI Chrome Pack (U-032)
   - 패널/카드에 적용되는 장식(코너/프레임)
   - Readable 모드에서 완화
   ============================================ */

/* Chrome 에셋 경로 변수 */
:root {
  --chrome-panel-corner: url('/ui/chrome/panel-corner-br.png');
  --chrome-card-frame: url('/ui/chrome/card-frame.png');
  --chrome-scanner-frame: url('/ui/chrome/scanner-frame.png');
  --chrome-corner-size: 32px;
  --chrome-glow-color: rgba(51, 255, 0, 0.3);
}

/* Game Header Chrome - 상단 코너 (U-032) */
.game-header.has-chrome {
  position: relative;
}

.game-header.has-chrome::before,
.game-header.has-chrome::after {
  content: '';
  position: absolute;
  width: var(--chrome-corner-size);
  height: var(--chrome-corner-size);
  background-image: var(--chrome-panel-corner);
  background-size: contain;
  background-repeat: no-repeat;
  pointer-events: none;
  opacity: 0.9;
  filter: drop-shadow(0 0 5px var(--chrome-glow-color));
  z-index: 2;
}

.game-header.has-chrome::before {
  top: -2px;
  left: -2px;
  transform: rotate(90deg);
}

.game-header.has-chrome::after {
  top: -2px;
  right: -2px;
  transform: rotate(180deg);
}

/* Panel Header Chrome - 코너 장식 (4방향 CSS transform) */
.panel-header.has-chrome {
  position: relative;
}

.panel-header.has-chrome::before,
.panel-header.has-chrome::after {
  content: '';
  position: absolute;
  width: var(--chrome-corner-size);
  height: var(--chrome-corner-size);
  background-image: var(--chrome-panel-corner);
  background-size: contain;
  background-repeat: no-repeat;
  pointer-events: none;
  opacity: 0.8;
  filter: drop-shadow(0 0 4px var(--chrome-glow-color));
}

/* 좌상단 코너 */
.panel-header.has-chrome::before {
  top: -2px;
  left: -2px;
  transform: rotate(90deg);
}

/* 우상단 코너 */
.panel-header.has-chrome::after {
  top: -2px;
  right: -2px;
  transform: rotate(180deg);
}

/* Panel Chrome - 하단 코너용 래퍼 */
.panel.has-chrome {
  position: relative;
}

.panel.has-chrome .panel-content {
  position: relative;
}

.panel.has-chrome .panel-content::before,
.panel.has-chrome .panel-content::after {
  content: '';
  position: absolute;
  width: var(--chrome-corner-size);
  height: var(--chrome-corner-size);
  background-image: var(--chrome-panel-corner);
  background-size: contain;
  background-repeat: no-repeat;
  pointer-events: none;
  opacity: 0.6;
  filter: drop-shadow(0 0 3px var(--chrome-glow-color));
}

/* 좌하단 코너 */
.panel.has-chrome .panel-content::before {
  bottom: 0;
  left: -2px;
  transform: rotate(0deg);
}

/* 우하단 코너 (원본 방향) */
.panel.has-chrome .panel-content::after {
  bottom: 0;
  right: -2px;
  transform: rotate(270deg);
}

/* Action Card Chrome - 프레임 오버레이 */
.action-card.has-chrome {
  position: relative;
  overflow: visible;
}

.action-card.has-chrome::before {
  content: '';
  position: absolute;
  top: -4px;
  left: -4px;
  right: -4px;
  bottom: -4px;
  background-image: var(--chrome-card-frame);
  background-size: 100% 100%;
  background-repeat: no-repeat;
  pointer-events: none;
  /* U-049: 배경 투명도 낮춰서 텍스트 가독성 향상 */
  opacity: 0.4;
  filter: drop-shadow(0 0 6px var(--chrome-glow-color));
  /* U-049: z-index를 낮춰서 텍스트 뒤에 위치 */
  z-index: 0;
}

/* U-049: 카드 내용은 chrome 배경 위에 표시 */
.action-card.has-chrome > * {
  position: relative;
  z-index: 1;
}

/* Scanner Slot Chrome - 장식 프레임 (U-032) */
.scanner-slot.has-chrome {
  position: relative;
  min-height: 100px;
  border: 1px dashed var(--text-dim);
  display: flex;
  align-items: center;
  justify-content: center;
  margin: var(--spacing-md) var(--spacing-sm);
  background-color: rgba(0, 0, 0, 0.4);
}

/* ============================================
   31. Scanner Slot 스타일 (U-022[Mvp])
   - PRD 6.7: 이미지 드랍/업로드 → 아이템화
   - RULE-002: 게임 UI로 상시 노출
   - Q1 Option B: 사용자 확인 후 인벤토리 추가
   ============================================ */

.scanner-slot-container {
  position: relative;
  display: flex;
  flex-direction: column;
  gap: var(--spacing-sm);
  min-height: 120px;
  padding: var(--spacing-xs);
  overflow: visible;
}

/* 드랍존 기본 스타일 */
.scanner-dropzone {
  display: flex;
  flex-direction: column;
  align-items: center;
  justify-content: center;
  gap: var(--spacing-xs);
  min-height: 100px;
  padding: var(--spacing-md);
  border: 2px dashed var(--text-dim);
  border-radius: var(--border-radius);
  background-color: rgba(0, 20, 0, 0.5);
  /* 격자 무늬 배경 추가 (기존 배경의 느낌을 계승) */
  background-image:
    linear-gradient(rgba(0, 255, 0, 0.05) 1px, transparent 1px),
    linear-gradient(90deg, rgba(0, 255, 0, 0.05) 1px, transparent 1px);
  background-size: 20px 20px;
  cursor: pointer;
  transition:
    border-color 0.2s,
    background-color 0.2s,
    box-shadow 0.2s;
  position: relative;
  overflow: hidden;
}

/* 스캔라인 애니메이션 추가 (장치 느낌) */
.scanner-dropzone::after {
  content: '';
  position: absolute;
  top: -100%;
  left: 0;
  width: 100%;
  height: 100%;
  background: linear-gradient(to bottom, transparent, rgba(0, 255, 0, 0.05) 50%, transparent);
  animation: scanning-idle 4s linear infinite;
  pointer-events: none;
}

@keyframes scanning-idle {
  0% {
    top: -100%;
  }
  100% {
    top: 100%;
  }
}

.scanner-dropzone:hover:not(.disabled) {
  border-color: var(--text-color);
  background-color: rgba(0, 30, 0, 0.6);
  background-image:
    linear-gradient(rgba(0, 255, 0, 0.08) 1px, transparent 1px),
    linear-gradient(90deg, rgba(0, 255, 0, 0.08) 1px, transparent 1px);
}

.scanner-dropzone:focus-visible {
  outline: 2px solid var(--accent-color);
  outline-offset: 2px;
}

/* 드래그 오버 상태 */
.scanner-dropzone.drag-over {
  border-color: var(--accent-color);
  background-color: rgba(40, 0, 40, 0.4);
  box-shadow:
    0 0 15px var(--accent-color),
    inset 0 0 10px rgba(255, 0, 255, 0.1);
}

/* 비활성화 상태 */
.scanner-dropzone.disabled {
  cursor: not-allowed;
  opacity: 0.5;
  border-color: var(--text-dim);
}

.scanner-dropzone.disabled:hover {
  border-color: var(--text-dim);
  background-color: rgba(0, 20, 0, 0.5);
}

.scanner-dropzone-icon {
  font-size: 2rem;
  opacity: 0.8;
}

.scanner-dropzone-text {
  font-size: var(--font-size-sm);
  color: var(--text-color);
  text-transform: uppercase;
  letter-spacing: 1px;
  text-align: center;
}

.scanner-dropzone-hint {
  font-size: var(--font-size-xs);
  color: var(--text-dim);
  text-align: center;
  min-height: 1.2em; /* U-072: 빈 상태에서도 높이 유지하여 레이아웃 시프트 방지 */
}

/* U-072: 드래그 오버 시 숨김 - visibility로 공간 유지하여 레이아웃 시프트 방지 */
.scanner-dropzone-hint.hidden {
  visibility: hidden;
}

/* 프리뷰 이미지 */
.scanner-preview {
  width: 100%;
  max-height: 80px;
  display: flex;
  align-items: center;
  justify-content: center;
  border: 1px solid var(--text-dim);
  border-radius: 2px;
  overflow: hidden;
  background-color: rgba(0, 0, 0, 0.5);
}

.scanner-preview-img {
  max-width: 100%;
  max-height: 80px;
  object-fit: contain;
}

.scanner-preview-small {
  width: 48px;
  height: 48px;
  flex-shrink: 0;
  display: flex;
  align-items: center;
  justify-content: center;
  border: 1px solid var(--text-dim);
  border-radius: 2px;
  overflow: hidden;
  background-color: rgba(0, 0, 0, 0.5);
}

.scanner-preview-img-small {
  max-width: 100%;
  max-height: 100%;
  object-fit: cover;
}

/* 로딩 상태 */
.scanner-loading {
  display: flex;
  flex-direction: column;
  align-items: center;
  gap: var(--spacing-sm);
  padding: var(--spacing-md);
}

.scanner-loading-content {
  display: flex;
  flex-direction: column;
  align-items: center;
  gap: var(--spacing-xs);
}

.scanner-loading-spinner {
  width: 24px;
  height: 24px;
  border: 3px solid var(--text-dim);
  border-top-color: var(--accent-color);
  border-radius: 50%;
  animation: spin 1s linear infinite;
}

.scanner-loading-text {
  font-size: var(--font-size-sm);
  color: var(--accent-color);
  text-transform: uppercase;
  letter-spacing: 1px;
}

/* 에러 상태 */
.scanner-error {
  display: flex;
  flex-direction: column;
  align-items: center;
  gap: var(--spacing-sm);
  padding: var(--spacing-md);
}

.scanner-error-content {
  display: flex;
  flex-direction: column;
  align-items: center;
  gap: var(--spacing-xs);
}

.scanner-error-icon {
  font-size: 1.5rem;
}

.scanner-error-message {
  font-size: var(--font-size-sm);
  color: var(--warning-color);
  text-align: center;
}

/* 결과 상태 */
.scanner-result {
  display: flex;
  flex-direction: column;
  gap: var(--spacing-sm);
  padding: var(--spacing-xs);
}

/* U-095: 다수 아이템 발견 피드백 메시지 */
.scanner-discovery-message {
  text-align: center;
  font-size: var(--font-sm);
  font-weight: 600;
  color: var(--color-accent, #00ff88);
  padding: var(--spacing-xs) var(--spacing-sm);
  border: 1px solid var(--color-accent-dim, rgba(0, 255, 136, 0.3));
  border-radius: var(--radius-sm, 4px);
  background: rgba(0, 255, 136, 0.08);
  animation: scanner-discovery-pulse 1.5s ease-in-out;
}

@keyframes scanner-discovery-pulse {
  0% {
    opacity: 0;
    transform: scale(0.95);
  }
  50% {
    opacity: 1;
    transform: scale(1.02);
  }
  100% {
    opacity: 1;
    transform: scale(1);
  }
}

.scanner-result-header {
  display: flex;
  align-items: flex-start;
  gap: var(--spacing-sm);
}

.scanner-result-info {
  flex: 1;
  display: flex;
  flex-direction: column;
  gap: 2px;
}

.scanner-caption {
  font-size: var(--font-size-sm);
  color: var(--text-color);
  line-height: 1.3;
}

.scanner-stats {
  font-size: var(--font-size-xs);
  color: var(--text-dim);
}

/* 아이템 후보 목록 */
.scanner-candidates {
  display: flex;
  flex-direction: column;
  gap: var(--spacing-xs);
}

.scanner-candidates-title {
  font-size: var(--font-size-xs);
  color: var(--text-color);
  text-transform: uppercase;
  letter-spacing: 1px;
  padding-bottom: var(--spacing-xs);
  border-bottom: 1px solid rgba(51, 255, 0, 0.2);
}

.scanner-candidates-list {
  display: flex;
  flex-direction: column;
  gap: 4px;
  max-height: 150px;
  overflow-y: auto;
  overflow-x: hidden;
  scrollbar-width: thin;
}

.scanner-candidate {
  display: flex;
  align-items: center;
  gap: var(--spacing-xs);
  padding: var(--spacing-xs);
  background-color: rgba(0, 20, 0, 0.5);
  border: 1px solid var(--text-dim);
  border-radius: 2px;
  cursor: pointer;
  transition:
    border-color 0.2s,
    background-color 0.2s;
  text-align: left;
  width: 100%;
  font-family: var(--font-main);
}

.scanner-candidate:hover {
  border-color: var(--text-color);
  background-color: rgba(0, 30, 0, 0.7);
}

.scanner-candidate.selected {
  border-color: var(--accent-color);
  background-color: rgba(40, 0, 40, 0.4);
}

.scanner-candidate-checkbox {
  font-size: 0.875rem;
  color: var(--text-color);
  flex-shrink: 0;
}

.scanner-candidate.selected .scanner-candidate-checkbox {
  color: var(--accent-color);
}

.scanner-candidate-icon {
  font-size: 1.25rem;
  flex-shrink: 0;
}

.scanner-candidate-info {
  flex: 1;
  display: flex;
  flex-direction: column;
  gap: 1px;
  min-width: 0;
}

.scanner-candidate-name {
  font-size: var(--font-size-sm);
  color: var(--text-color);
  font-weight: bold;
}

.scanner-candidate-desc {
  font-size: var(--font-size-xs);
  color: var(--text-dim);
  white-space: nowrap;
  overflow: hidden;
  text-overflow: ellipsis;
}

.scanner-candidate-type {
  font-size: 0.625rem;
  color: var(--accent-color);
  text-transform: uppercase;
  letter-spacing: 0.5px;
}

.scanner-no-candidates {
  font-size: var(--font-size-sm);
  color: var(--text-dim);
  text-align: center;
  padding: var(--spacing-md);
}

/* 액션 버튼 */
.scanner-actions {
  display: flex;
  justify-content: flex-end;
  gap: var(--spacing-xs);
  margin-top: var(--spacing-xs);
}

.scanner-btn {
  padding: var(--spacing-xs) var(--spacing-sm);
  font-family: var(--font-main);
  font-size: var(--font-size-xs);
  text-transform: uppercase;
  letter-spacing: 1px;
  cursor: pointer;
  transition:
    background-color 0.2s,
    border-color 0.2s,
    color 0.2s;
}

.scanner-btn-cancel,
.scanner-btn-retry {
  background: transparent;
  border: 1px solid var(--text-dim);
  color: var(--text-color);
}

.scanner-btn-cancel:hover,
.scanner-btn-retry:hover {
  border-color: var(--text-color);
}

.scanner-btn-add {
  background: var(--text-color);
  border: 1px solid var(--text-color);
  color: var(--bg-color);
}

.scanner-btn-add:hover:not(:disabled) {
  background: var(--accent-color);
  border-color: var(--accent-color);
  color: white;
}

.scanner-btn-add:disabled {
  opacity: 0.5;
  cursor: not-allowed;
}

/* ============================================
   U-072: Scanner 의미론적 사용 유도 UX
   ============================================ */

/* 툴팁 */
.scanner-tooltip {
  position: absolute;
  top: -60px;
  left: 50%;
  transform: translateX(-50%);
  background: rgba(0, 20, 0, 0.95);
  border: 1px solid var(--text-dim);
  border-radius: 4px;
  padding: var(--spacing-xs) var(--spacing-sm);
  z-index: 100;
  min-width: 180px;
  text-align: center;
  box-shadow: 0 2px 8px rgba(0, 0, 0, 0.5);
  pointer-events: none;
}

.scanner-tooltip::after {
  content: '';
  position: absolute;
  bottom: -6px;
  left: 50%;
  transform: translateX(-50%);
  border-left: 6px solid transparent;
  border-right: 6px solid transparent;
  border-top: 6px solid var(--text-dim);
}

.scanner-tooltip-title {
  font-size: var(--font-size-sm);
  color: var(--accent-color);
  margin-bottom: 4px;
  text-shadow: 0 0 4px var(--accent-color);
}

.scanner-tooltip-desc {
  font-size: var(--font-size-xs);
  color: var(--text-dim);
  line-height: 1.3;
}

/* 어포던스 힌트 (idle 상태) */
.scanner-affordance-hint {
  font-size: var(--font-size-xs);
  color: var(--accent-color);
  margin-top: var(--spacing-xs);
  padding: 2px 8px;
  border: 1px dashed var(--accent-color);
  border-radius: 4px;
  opacity: 0.7;
  animation: scanner-affordance-glow 3s ease-in-out infinite;
}

/* U-072: 드래그 오버/비활성화 시 숨김 - visibility로 공간 유지하여 레이아웃 시프트 방지 */
.scanner-affordance-hint.hidden {
  visibility: hidden;
  animation: none; /* 숨김 상태에서 애니메이션 중단 */
}

@keyframes scanner-affordance-glow {
  0%,
  100% {
    opacity: 0.5;
    text-shadow: none;
  }
  50% {
    opacity: 1;
    text-shadow: 0 0 6px var(--accent-color);
  }
}

/* 드래그 오버 시 어포던스 강화 */
.scanner-dropzone.drag-over .scanner-dropzone-text {
  color: var(--accent-color);
  text-shadow: 0 0 8px var(--accent-color);
  font-weight: bold;
}

/* reduced-motion */
@media (prefers-reduced-motion: reduce) {
  .scanner-loading-spinner {
    animation: none;
    border-color: var(--accent-color);
  }

  .scanner-dropzone {
    transition: none;
  }

  .scanner-candidate {
    transition: none;
  }

  /* U-072: 어포던스 애니메이션 비활성화 */
  .scanner-affordance-hint {
    animation: none;
    opacity: 0.7;
  }
}

.scanner-slot.has-chrome::before {
  content: '';
  position: absolute;
  top: -10px;
  left: -10px;
  right: -10px;
  bottom: -10px;
  background-image: var(--chrome-scanner-frame);
  background-size: 100% 100%;
  background-repeat: no-repeat;
  pointer-events: none;
  opacity: 0.8;
  filter: drop-shadow(0 0 8px var(--chrome-glow-color));
  z-index: 1;
}

/* Chrome 호버 효과 강화 */
.action-card.has-chrome:hover::before,
.scanner-slot.has-chrome:hover::before {
  opacity: 1;
  filter: drop-shadow(0 0 10px var(--accent-color));
}

/* reduced-motion: Chrome 효과 완화 */
@media (prefers-reduced-motion: reduce) {
  .game-header.has-chrome::before,
  .game-header.has-chrome::after,
  .panel-header.has-chrome::before,
  .panel-header.has-chrome::after,
  .panel.has-chrome .panel-content::before,
  .panel.has-chrome .panel-content::after {
    filter: none;
  }

  .action-card.has-chrome::before,
  .scanner-slot.has-chrome::before {
    filter: none;
  }

  .action-card.has-chrome:hover::before,
  .scanner-slot.has-chrome:hover::before {
    filter: none;
  }
}

/* Chrome 폴백: 이미지 로딩 실패 시 CSS 테두리로 대체 */
.panel-header.has-chrome.chrome-fallback::before,
.panel-header.has-chrome.chrome-fallback::after,
.panel.has-chrome.chrome-fallback .panel-content::before,
.panel.has-chrome.chrome-fallback .panel-content::after {
  background-image: none;
  background-color: var(--text-color);
  width: 8px;
  height: 8px;
  border-radius: 1px;
}

.action-card.has-chrome.chrome-fallback::before,
.scanner-slot.has-chrome.chrome-fallback::before {
  background-image: none;
  border: 1px solid var(--text-color);
  background-color: transparent;
}

/* ============================================
   25. Inventory Panel 스타일 (U-011, U-088)
   - RULE-002: 게임 UI로 상시 노출
   - U-088: Row(행) 레이아웃 전환
     Q1: Row 48px, 아이콘 32px (컴팩트)
     Q2: 구분선 + 줄무늬 조합
     Q3: Hover 툴팁만 (U-056 유지)
     Q4: 아이콘 영역만 드래그 가능
   ============================================ */

.inventory-panel-content {
  display: flex;
  flex-direction: column;
  gap: var(--spacing-sm);
  height: 100%;
  min-height: 120px;
  /* U-077: 스크롤 가능 + CRT 테마 커스텀 스크롤바 (Q2: Option B) */
  overflow-y: auto;
  overflow-x: hidden;
  scrollbar-width: thin; /* Firefox: 얇은 스크롤바 */
  scrollbar-color: rgba(51, 255, 0, 0.5) rgba(0, 20, 0, 0.8); /* Firefox: 녹색 thumb / 어두운 track */
}

/* U-077: CRT 테마 커스텀 스크롤바 - WebKit (Q2: Option B) */
.inventory-panel-content::-webkit-scrollbar {
  width: 6px;
}

.inventory-panel-content::-webkit-scrollbar-track {
  background: rgba(0, 20, 0, 0.8);
  border-left: 1px solid rgba(51, 255, 0, 0.2);
}

.inventory-panel-content::-webkit-scrollbar-thumb {
  background: rgba(51, 255, 0, 0.5);
  border-radius: 3px;
  border: 1px solid rgba(51, 255, 0, 0.3);
  box-shadow: 0 0 4px rgba(51, 255, 0, 0.3);
}

.inventory-panel-content::-webkit-scrollbar-thumb:hover {
  background: rgba(51, 255, 0, 0.7);
  box-shadow: 0 0 8px rgba(51, 255, 0, 0.5);
}

/* U-088: 인벤토리 리스트 (Row 레이아웃) */
.inventory-list {
  display: flex;
  flex-direction: column;
  padding: 0;
}

/* 빈 인벤토리 */
.inventory-empty {
  display: flex;
  flex-direction: column;
  align-items: center;
  justify-content: center;
  gap: var(--spacing-xs);
  padding: var(--spacing-lg);
  color: var(--text-dim);
  text-align: center;
}

.inventory-empty-icon {
  font-size: 2rem;
  opacity: 0.5;
}

.inventory-empty-text {
  font-size: var(--font-size-sm);
  text-transform: uppercase;
  letter-spacing: 1px;
}

/* U-077: 빈 상태 힌트 텍스트 (Q3: Option B) */
.inventory-empty-hint {
  font-size: 0.7rem;
  color: var(--text-dim);
  opacity: 0.7;
  margin-top: var(--spacing-xs);
  font-style: italic;
}

/* U-088+U-117: 인벤토리 아이템 (Row 형태, Row 전체 드래그 가능) */
.inventory-item {
  display: flex;
  flex-direction: row;
  align-items: center;
  gap: var(--spacing-sm);
  padding: 6px 12px;
  min-height: 48px; /* Q1: Row 48px */
  border-bottom: 1px solid rgba(51, 255, 0, 0.15); /* Q2: 구분선 */
  background: transparent;
  cursor: grab; /* U-117: Row 전체 드래그 가능 */
  transition:
    background-color 0.2s,
    box-shadow 0.2s,
    opacity 0.2s;
  user-select: none;
  position: relative;
}

/* Q2: Option C - 줄무늬 (zebra striping) */
.inventory-item:nth-child(even) {
  background: rgba(51, 255, 0, 0.03);
}

/* 마지막 Row는 구분선 제거 */
.inventory-item:last-child {
  border-bottom: none;
}

/* 아이템 호버 */
.inventory-item:hover:not(.disabled):not(.dragging) {
  background: rgba(51, 255, 0, 0.08);
  box-shadow: inset 0 0 8px rgba(51, 255, 0, 0.1);
  /* U-077: 힌트 팝업이 형제 아이템 위에 표시되도록 */
  z-index: 2;
}

/* U-088: 아이템 선택 상태 (Q3: Option A) */
.inventory-item.selected {
  background: rgba(255, 0, 255, 0.1);
  box-shadow: inset 3px 0 0 var(--accent-color);
}

/* U-117: 아이템 드래그 중 (Row 전체) */
.inventory-item.dragging {
  opacity: 0.4;
  border-bottom-style: dashed;
  box-shadow: none;
  cursor: grabbing;
}

/* 아이템 비활성화 */
.inventory-item.disabled {
  cursor: not-allowed;
  opacity: 0.5;
}

.inventory-item.disabled:hover {
  background: transparent;
  box-shadow: none;
}

/* U-096: 아이템 소비(삭제) fade-out 애니메이션 (Row 형태) */
.inventory-item.item-consumed {
  animation: item-consume-fadeout 0.5s ease-out forwards;
  pointer-events: none;
  cursor: default;
}

@keyframes item-consume-fadeout {
  0% {
    opacity: 1;
    transform: translateX(0);
    filter: none;
  }
  40% {
    opacity: 0.7;
    transform: translateX(-4px);
    filter: brightness(1.5) saturate(0.5);
    box-shadow: inset 3px 0 0 var(--warning-color);
  }
  100% {
    opacity: 0;
    transform: translateX(-8px);
    filter: brightness(2) saturate(0);
    box-shadow: none;
  }
}

/* U-088: 드래그 오버레이 — 아이콘만 표시 (Q4: Option B) */
.inventory-overlay-icon {
  display: flex;
  align-items: center;
  justify-content: center;
  width: 40px;
  height: 40px;
  border: 1px solid var(--accent-color);
  border-radius: 4px;
  background: rgba(0, 20, 0, 0.95);
  box-shadow:
    0 0 20px var(--accent-color),
    0 4px 16px rgba(0, 0, 0, 0.6);
  cursor: grabbing;
  z-index: 10001;
  pointer-events: none;
}

.inventory-overlay-icon .inventory-item-icon-img {
  width: 30px;
  height: 30px;
}

.inventory-overlay-icon .inventory-item-icon-emoji {
  font-size: 1.5rem;
}

/* U-088+U-117: 아이콘 (32px, 표시 전용 — 드래그 핸들은 Row 전체) */
.inventory-item-icon {
  display: flex;
  align-items: center;
  justify-content: center;
  width: 32px; /* Q1: 32px */
  height: 32px;
  flex-shrink: 0;
  border: 1px solid var(--text-dim);
  border-radius: 2px;
  background-color: rgba(0, 0, 0, 0.4);
  /* U-117: cursor는 Row(.inventory-item)에서 관리 */
  touch-action: none;
}

/* U-117: active cursor는 Row(.inventory-item.dragging)에서 관리 */

.inventory-item-icon-img {
  width: 26px;
  height: 26px;
  object-fit: contain;
  image-rendering: pixelated;
}

.inventory-item-icon-emoji {
  font-size: 1.3rem;
}

/* U-075: 아이콘 로딩 상태 */
.inventory-item-icon-wrapper {
  position: relative;
  display: flex;
  align-items: center;
  justify-content: center;
  width: 100%;
  height: 100%;
}

.inventory-item-icon-img.loading {
  opacity: 0.5;
}

.inventory-item-icon-loading {
  position: absolute;
  top: 50%;
  left: 50%;
  transform: translate(-50%, -50%);
  width: 16px;
  height: 16px;
  border: 2px solid transparent;
  border-top: 2px solid var(--primary-color);
  border-radius: 50%;
  animation: icon-loading-spin 1s linear infinite;
}

@keyframes icon-loading-spin {
  0% {
    transform: translate(-50%, -50%) rotate(0deg);
  }
  100% {
    transform: translate(-50%, -50%) rotate(360deg);
  }
}

/* U-088: 아이템 정보 (Row 가로 배치) */
.inventory-item-info {
  display: flex;
  flex-direction: row;
  align-items: center;
  gap: var(--spacing-sm);
  flex: 1;
  min-width: 0; /* text-overflow 작동을 위해 필요 */
}

.inventory-item-name {
  font-size: var(--font-size-xs);
  color: var(--text-color);
  text-align: left;
  text-transform: uppercase;
  letter-spacing: 0.5px;
  white-space: nowrap;
  overflow: hidden;
  text-overflow: ellipsis;
  flex: 1;
  min-width: 0;
}

.inventory-item-quantity {
  font-family: var(--font-micro-en); /* 수치 식별성을 위해 마이크로 폰트 적용 */
  font-size: var(--font-size-sm);
  color: var(--warning-color);
  font-weight: bold;
  text-shadow: 0 0 5px rgba(0, 0, 0, 0.9);
  flex-shrink: 0;
}

/* 포커스 상태 (접근성) */
.inventory-item:focus-visible {
  outline: 2px solid var(--accent-color);
  outline-offset: -2px;
}

.inventory-item:focus:not(:focus-visible) {
  outline: none;
}

/* 모바일 조정 (U-088) */
@media (max-width: 768px) {
  .inventory-item {
    padding: 4px 8px;
    min-height: 40px;
    gap: var(--spacing-xs);
  }

  .inventory-item-icon {
    width: 28px;
    height: 28px;
  }

  .inventory-item-icon-img {
    width: 22px;
    height: 22px;
  }

  .inventory-item-icon-emoji {
    font-size: 1.1rem;
  }

  .inventory-item-name {
    font-size: 0.625rem;
  }
}

/* reduced-motion (U-088) */
@media (prefers-reduced-motion: reduce) {
  .inventory-item {
    transition: none;
  }
}

/* ============================================
   26. Quest Panel 스타일 (U-013)
   - RULE-002: 게임 UI로 상시 노출
   - 체크리스트 형태로 목표 표시
   ============================================ */

.quest-panel-content {
  display: flex;
  flex-direction: column;
  gap: var(--spacing-sm);
  padding: var(--spacing-xs);
}

/* 빈 상태 */
.quest-empty {
  display: flex;
  flex-direction: column;
  align-items: center;
  justify-content: center;
  gap: var(--spacing-xs);
  padding: var(--spacing-md);
  min-height: 80px;
}

.quest-empty-icon {
  font-size: 1.5rem;
  opacity: 0.5;
}

.quest-empty-text {
  font-size: var(--font-size-sm);
  color: var(--text-dim);
  text-transform: uppercase;
  letter-spacing: 1px;
  text-align: center;
}

/* 섹션 */
.quest-section {
  display: flex;
  flex-direction: column;
  gap: var(--spacing-xs);
}

.quest-section-title {
  font-size: var(--font-size-xs);
  color: var(--text-dim);
  text-transform: uppercase;
  letter-spacing: 1px;
  padding-bottom: var(--spacing-xs);
  border-bottom: 1px solid rgba(51, 255, 0, 0.2);
}

/* 퀘스트 목록 */
.quest-list {
  list-style: none;
  display: flex;
  flex-direction: column;
  gap: 4px;
}

/* 개별 퀘스트 아이템 */
.quest-item {
  display: flex;
  align-items: center;
  gap: var(--spacing-xs);
  padding: var(--spacing-xs);
  background-color: rgba(0, 20, 0, 0.5);
  border: 1px solid var(--text-dim);
  border-radius: 2px;
  transition:
    border-color 0.2s,
    background-color 0.2s;
}

.quest-item.quest-active {
  border-color: var(--text-color);
}

.quest-item.quest-completed {
  border-color: var(--text-dim);
  opacity: 0.7;
}

.quest-checkbox {
  font-size: 0.875rem;
  color: var(--text-color);
  flex-shrink: 0;
}

.quest-item.quest-completed .quest-checkbox {
  color: var(--text-dim);
}

.quest-label {
  font-size: var(--font-size-sm);
  color: var(--text-color);
  flex: 1;
  line-height: 1.3;
}

.quest-item.quest-completed .quest-label {
  color: var(--text-dim);
  text-decoration: line-through;
}

.quest-status-badge {
  font-size: 0.625rem;
  color: var(--accent-color);
  text-transform: uppercase;
  letter-spacing: 1px;
  padding: 2px 4px;
  background-color: rgba(255, 0, 255, 0.1);
  border: 1px solid var(--accent-color);
  border-radius: 2px;
}

/* 완료된 퀘스트 목록 (레거시, 하위호환) */
.quest-list-completed {
  max-height: 100px;
  overflow-y: auto;
  overflow-x: hidden;
  scrollbar-width: thin;
}

/* ============================================
   26b. 목표 시스템 강화 스타일 (U-078)
   - 주 목표(Main Objective) + 서브 목표
   - 진행률 바, 보상 미리보기
   - ObjectiveTracker (미니 트래커)
   ============================================ */

/* 빈 상태 힌트 */
.quest-empty-hint {
  font-size: 0.6875rem;
  color: var(--text-dim);
  text-align: center;
  opacity: 0.7;
}

/* ---- 주 목표 (Main Objective) ---- */
.main-objective {
  background: linear-gradient(135deg, rgba(0, 40, 0, 0.6) 0%, rgba(0, 20, 0, 0.8) 100%);
  border: 1px solid var(--text-color);
  border-radius: 3px;
  padding: var(--spacing-sm);
  display: flex;
  flex-direction: column;
  gap: 6px;
  position: relative;
  overflow: hidden;
}

.main-objective::before {
  content: '';
  position: absolute;
  top: 0;
  left: 0;
  right: 0;
  height: 2px;
  background: linear-gradient(90deg, transparent, var(--accent-color), transparent);
}

.main-objective--completed {
  border-color: var(--text-dim);
  opacity: 0.8;
}

.main-objective__header {
  display: flex;
  align-items: center;
  gap: var(--spacing-xs);
}

.main-objective__icon {
  font-size: 0.875rem;
}

.main-objective__badge {
  font-size: 0.5625rem;
  color: var(--accent-color);
  text-transform: uppercase;
  letter-spacing: 1.5px;
  padding: 1px 6px;
  border: 1px solid var(--accent-color);
  border-radius: 2px;
  background-color: rgba(255, 0, 255, 0.08);
}

.main-objective__title {
  font-size: var(--font-size-sm);
  color: var(--text-color);
  font-weight: 600;
  line-height: 1.3;
  margin: 0;
}

.main-objective--completed .main-objective__title {
  text-decoration: line-through;
  color: var(--text-dim);
}

.main-objective__desc {
  font-size: 0.6875rem;
  color: var(--text-dim);
  line-height: 1.4;
  margin: 0;
}

/* 진행률 바 */
.objective-progress-bar {
  height: 14px;
  background-color: rgba(0, 20, 0, 0.8);
  border: 1px solid var(--text-dim);
  border-radius: 2px;
  position: relative;
  overflow: hidden;
}

.objective-progress-fill {
  height: 100%;
  background: linear-gradient(90deg, var(--text-color), rgba(51, 255, 0, 0.7));
  border-radius: 1px;
  transition: width 0.5s ease-out;
  box-shadow: 0 0 4px var(--text-color);
}

.objective-progress-text {
  position: absolute;
  top: 50%;
  left: 50%;
  transform: translate(-50%, -50%);
  font-size: 0.5625rem;
  color: var(--text-color);
  text-shadow: 0 0 3px rgba(0, 0, 0, 0.8);
  letter-spacing: 0.5px;
}

/* 보상 미리보기 */
.main-objective__reward {
  display: flex;
  align-items: center;
  gap: 4px;
  font-size: 0.6875rem;
  color: var(--warning-color);
}

.main-objective__reward-icon {
  font-size: 0.75rem;
}

/* 완료 뱃지 */
.main-objective__complete-badge {
  display: flex;
  align-items: center;
  gap: 4px;
  font-size: 0.6875rem;
  color: var(--accent-color);
  animation: objectiveCompleteFlash 0.6s ease-out;
}

@keyframes objectiveCompleteFlash {
  0% {
    opacity: 0;
    transform: scale(0.8);
  }
  50% {
    opacity: 1;
    transform: scale(1.1);
  }
  100% {
    opacity: 1;
    transform: scale(1);
  }
}

/* ---- 서브 목표 (Sub-objectives) ---- */
.sub-objective-list {
  list-style: none;
  display: flex;
  flex-direction: column;
  gap: 3px;
}

.sub-objective-list--completed {
  max-height: 80px;
  overflow-y: auto;
  overflow-x: hidden;
  scrollbar-width: thin;
}

.sub-objective {
  display: flex;
  align-items: center;
  gap: var(--spacing-xs);
  padding: 4px var(--spacing-xs);
  background-color: rgba(0, 20, 0, 0.4);
  border: 1px solid transparent;
  border-radius: 2px;
  transition:
    border-color 0.2s,
    background-color 0.2s,
    opacity 0.3s;
}

.sub-objective--active {
  border-color: rgba(51, 255, 0, 0.3);
}

.sub-objective--completed {
  border-color: transparent;
  opacity: 0.6;
}

.sub-objective__check {
  font-size: 0.75rem;
  color: var(--text-dim);
  flex-shrink: 0;
  width: 14px;
  text-align: center;
  transition:
    color 0.3s,
    transform 0.3s;
}

.sub-objective__check--done {
  color: var(--accent-color);
  animation: checkBounce 0.4s ease-out;
}

@keyframes checkBounce {
  0% {
    transform: scale(0.5);
  }
  50% {
    transform: scale(1.3);
  }
  100% {
    transform: scale(1);
  }
}

.sub-objective__label {
  font-size: var(--font-size-sm);
  color: var(--text-color);
  flex: 1;
  line-height: 1.3;
}

.sub-objective--completed .sub-objective__label {
  color: var(--text-dim);
  text-decoration: line-through;
}

.sub-objective__reward {
  font-size: 0.5625rem;
  color: var(--warning-color);
  flex-shrink: 0;
  white-space: nowrap;
}

.sub-objective__earned {
  font-size: 0.5625rem;
  color: var(--accent-color);
  flex-shrink: 0;
  white-space: nowrap;
  animation: objectiveCompleteFlash 0.6s ease-out;
}

/* ---- ObjectiveTracker (미니 트래커, U-078 Q2: Option B) ---- */
.objective-tracker {
  display: flex;
  align-items: center;
  gap: var(--spacing-xs);
  padding: 4px var(--spacing-sm);
  background-color: rgba(0, 20, 0, 0.7);
  border: 1px solid rgba(51, 255, 0, 0.2);
  border-radius: 2px;
  margin-bottom: var(--spacing-xs);
  min-height: 24px;
}

.objective-tracker--completed {
  border-color: var(--accent-color);
  opacity: 0.8;
}

.objective-tracker__icon {
  font-size: 0.75rem;
  flex-shrink: 0;
}

.objective-tracker__content {
  display: flex;
  align-items: center;
  gap: 4px;
  flex: 1;
  min-width: 0;
  overflow: hidden;
}

.objective-tracker__title {
  font-size: 0.6875rem;
  color: var(--text-color);
  white-space: nowrap;
  overflow: hidden;
  text-overflow: ellipsis;
}

.objective-tracker__sub-count {
  font-size: 0.5625rem;
  color: var(--text-dim);
  flex-shrink: 0;
}

.objective-tracker__bar {
  width: 48px;
  height: 6px;
  background-color: rgba(0, 20, 0, 0.8);
  border: 1px solid var(--text-dim);
  border-radius: 1px;
  overflow: hidden;
  flex-shrink: 0;
}

.objective-tracker__bar-fill {
  height: 100%;
  background-color: var(--text-color);
  transition: width 0.5s ease-out;
  box-shadow: 0 0 3px var(--text-color);
}

/* ============================================
   27. Rule Board 스타일 (U-013)
   - RULE-002: 게임 UI로 상시 노출
   - 룰 카드 형태로 규칙 표시
   ============================================ */

.rule-board-content {
  display: flex;
  flex-direction: column;
  gap: var(--spacing-sm);
  padding: var(--spacing-xs);
}

/* 빈 상태 */
.rule-board-empty {
  display: flex;
  flex-direction: column;
  align-items: center;
  justify-content: center;
  gap: var(--spacing-xs);
  padding: var(--spacing-md);
  min-height: 80px;
}

.rule-board-empty-icon {
  font-size: 1.5rem;
  opacity: 0.5;
}

.rule-board-empty-text {
  font-size: var(--font-size-sm);
  color: var(--text-dim);
  text-transform: uppercase;
  letter-spacing: 1px;
  text-align: center;
}

/* 헤더 */
.rule-board-header {
  display: flex;
  align-items: center;
  justify-content: space-between;
  padding-bottom: var(--spacing-xs);
  border-bottom: 1px solid rgba(51, 255, 0, 0.2);
}

.rule-board-count {
  font-size: var(--font-size-xs);
  color: var(--text-dim);
  text-transform: uppercase;
  letter-spacing: 1px;
}

/* 룰 카드 리스트 */
.rule-card-list {
  display: flex;
  flex-direction: column;
  gap: var(--spacing-xs);
}

/* 개별 룰 카드 */
.rule-card {
  display: flex;
  flex-direction: column;
  gap: 4px;
  padding: var(--spacing-sm);
  background: linear-gradient(180deg, rgba(0, 30, 0, 0.8) 0%, rgba(0, 15, 0, 0.9) 100%);
  border: 1px solid var(--border-color);
  border-radius: var(--border-radius);
  transition:
    border-color 0.2s,
    box-shadow 0.2s;
}

.rule-card:hover {
  border-color: var(--accent-color);
  box-shadow: 0 0 8px rgba(255, 0, 255, 0.2);
}

.rule-card-header {
  display: flex;
  align-items: center;
  gap: var(--spacing-xs);
}

.rule-card-icon {
  font-size: 0.875rem;
  color: var(--warning-color);
  flex-shrink: 0;
}

.rule-card-label {
  font-size: var(--font-size-sm);
  font-weight: bold;
  color: var(--text-color);
  text-transform: uppercase;
  letter-spacing: 0.5px;
}

.rule-card-description {
  font-size: var(--font-size-xs);
  color: var(--text-dim);
  line-height: 1.3;
  padding-left: calc(0.875rem + var(--spacing-xs));
}

/* ============================================
   28. Mutation Timeline 스타일 (U-013)
   - PRD 6.4: Rule Mutation Timeline
   - 시간순 이벤트 표시
   ============================================ */

.mutation-timeline-content {
  display: flex;
  flex-direction: column;
  gap: var(--spacing-sm);
  padding: var(--spacing-xs);
  margin-top: var(--spacing-sm);
  border-top: 1px dashed var(--text-dim);
}

/* 빈 상태 */
.timeline-empty {
  display: flex;
  flex-direction: column;
  align-items: center;
  justify-content: center;
  gap: var(--spacing-xs);
  padding: var(--spacing-md);
  min-height: 60px;
}

.timeline-empty-icon {
  font-size: 1.5rem;
  opacity: 0.5;
}

.timeline-empty-text {
  font-size: var(--font-size-sm);
  color: var(--text-dim);
  text-transform: uppercase;
  letter-spacing: 1px;
  text-align: center;
}

/* 헤더 */
.timeline-header {
  display: flex;
  align-items: center;
  justify-content: space-between;
  padding-bottom: var(--spacing-xs);
}

.timeline-title {
  font-size: var(--font-size-xs);
  color: var(--text-color);
  text-transform: uppercase;
  letter-spacing: 1px;
}

.timeline-count {
  font-size: var(--font-size-xs);
  color: var(--text-dim);
}

/* 타임라인 이벤트 리스트 */
.timeline-events {
  display: flex;
  flex-direction: column;
  gap: var(--spacing-xs);
  max-height: 150px;
  overflow-y: auto;
  overflow-x: hidden;
  scrollbar-width: thin;
}

/* 개별 타임라인 이벤트 */
.timeline-event {
  display: flex;
  align-items: flex-start;
  gap: var(--spacing-xs);
  padding: var(--spacing-xs);
  background-color: rgba(0, 20, 0, 0.5);
  border-left: 3px solid var(--text-color);
  border-radius: 0 2px 2px 0;
  transition: background-color 0.2s;
}

.timeline-event:hover {
  background-color: rgba(0, 30, 0, 0.7);
}

/* 이벤트 유형별 테두리 색상 */
.timeline-event-added {
  border-left-color: var(--text-color);
}

.timeline-event-modified {
  border-left-color: var(--warning-color);
}

.timeline-event-removed {
  border-left-color: var(--error-color);
}

/* 이벤트 마커 */
.timeline-event-marker {
  display: flex;
  flex-direction: column;
  align-items: center;
  gap: 2px;
  flex-shrink: 0;
  min-width: 40px;
}

.timeline-event-icon {
  font-size: 0.75rem;
}

.timeline-event-turn {
  font-family: var(--font-micro-en);
  font-size: 0.625rem;
  color: var(--text-dim);
  text-transform: uppercase;
}

/* 이벤트 내용 */
.timeline-event-content {
  display: flex;
  flex-direction: column;
  gap: 2px;
  flex: 1;
  min-width: 0;
}

.timeline-event-label {
  font-size: var(--font-size-xs);
  color: var(--text-color);
  font-weight: bold;
}

.timeline-event-type {
  font-size: 0.625rem;
  color: var(--text-dim);
  text-transform: uppercase;
  letter-spacing: 1px;
}

.timeline-event-description {
  font-size: var(--font-size-xs);
  color: var(--text-dim);
  line-height: 1.2;
}

/* 더보기 표시 */
.timeline-more {
  display: flex;
  justify-content: center;
  padding: var(--spacing-xs);
}

.timeline-more-text {
  font-size: 0.625rem;
  color: var(--text-dim);
  text-transform: uppercase;
  letter-spacing: 1px;
}

/* 모바일 조정 */
@media (max-width: 768px) {
  .quest-panel-content,
  .rule-board-content,
  .mutation-timeline-content {
    padding: 4px;
  }

  .quest-item,
  .rule-card,
  .timeline-event {
    padding: 4px;
  }

  .timeline-events {
    max-height: 100px;
  }
}

/* ============================================
   29. 프로필 선택 화면 스타일 (U-015[Mvp])
   - PRD 6.9: 데모 프로필 3종 + 즉시 시작
   ============================================ */

/* U-044: 언어 선택 토글 (프로필 선택 화면 우측 상단) */
.language-toggle-container {
  position: fixed;
  top: var(--spacing-lg);
  right: var(--spacing-lg);
  z-index: 100;
}

.language-toggle-btn {
  display: flex;
  align-items: center;
  gap: var(--spacing-sm);
  padding: var(--spacing-sm) var(--spacing-md);
  background: rgba(0, 30, 0, 0.9);
  border: 1px solid var(--text-dim);
  border-radius: var(--border-radius);
  color: var(--text-color);
  font-family: var(--font-main);
  font-size: var(--font-size-sm);
  cursor: pointer;
  transition:
    border-color 0.2s,
    box-shadow 0.2s;
}

.language-toggle-btn:hover {
  border-color: var(--text-color);
  box-shadow: 0 0 10px var(--text-dim);
}

.language-toggle-btn:focus-visible {
  outline: 2px solid var(--accent-color);
  outline-offset: 2px;
}

.language-toggle-icon {
  font-size: 1.2rem;
}

.language-toggle-label {
  text-transform: uppercase;
  letter-spacing: 1px;
}

.profile-select-container {
  display: flex;
  flex-direction: column;
  align-items: center;
  justify-content: center;
  min-height: 100vh;
  padding: var(--spacing-xl);
  background: radial-gradient(ellipse at center, rgba(0, 30, 0, 0.3) 0%, var(--bg-color) 70%);
}

/* 타이틀 헤더 */
.profile-select-header {
  text-align: center;
  margin-bottom: var(--spacing-xl);
}

.profile-select-title {
  font-size: 3rem;
  color: var(--text-color);
  text-transform: uppercase;
  letter-spacing: 8px;
  margin-bottom: var(--spacing-md);
  text-shadow: 0 0 20px var(--text-color);
}

.profile-select-subtitle {
  font-size: var(--font-size-lg);
  color: var(--text-dim);
  text-transform: uppercase;
  letter-spacing: 3px;
}

/* 프로필 카드 그리드 */
.profile-card-grid {
  display: grid;
  grid-template-columns: repeat(3, 1fr);
  gap: var(--spacing-lg);
  max-width: 900px;
  margin-bottom: var(--spacing-xl);
}

@media (max-width: 900px) {
  .profile-card-grid {
    grid-template-columns: repeat(2, 1fr);
  }
}

@media (max-width: 600px) {
  .profile-card-grid {
    grid-template-columns: 1fr;
  }
}

/* 프로필 카드 */
.profile-card {
  display: flex;
  flex-direction: column;
  align-items: center;
  gap: var(--spacing-md);
  padding: var(--spacing-xl);
  min-width: 220px;
  min-height: 280px;
  border: 2px solid var(--text-dim);
  border-radius: var(--border-radius);
  background: linear-gradient(180deg, rgba(0, 30, 0, 0.9) 0%, rgba(0, 10, 0, 0.95) 100%);
  cursor: pointer;
  transition:
    border-color 0.3s,
    box-shadow 0.3s,
    transform 0.2s;
  text-align: center;
}

.profile-card:hover {
  border-color: var(--profile-accent, var(--accent-color));
  box-shadow:
    0 0 30px var(--profile-accent, var(--accent-color)),
    inset 0 0 20px rgba(0, 0, 0, 0.5);
  transform: translateY(-8px) scale(1.02);
}

.profile-card:focus-visible {
  outline: 2px solid var(--accent-color);
  outline-offset: 4px;
}

.profile-card-icon {
  font-size: 4rem;
  filter: drop-shadow(0 0 10px var(--profile-accent, var(--text-color)));
}

.profile-card-name {
  font-size: var(--font-size-xl);
  font-weight: bold;
  color: var(--text-color);
  text-transform: uppercase;
  letter-spacing: 2px;
  text-shadow: 0 0 8px var(--text-dim);
}

.profile-card-description {
  font-size: var(--font-size-sm);
  color: var(--text-dim);
  line-height: 1.4;
  padding: 0 var(--spacing-sm);
}

/* 계속하기 섹션 */
.profile-continue-section {
  display: flex;
  flex-direction: column;
  align-items: center;
  gap: var(--spacing-md);
  margin-bottom: var(--spacing-lg);
}

.profile-continue-divider {
  display: flex;
  align-items: center;
  gap: var(--spacing-md);
  color: var(--text-dim);
  font-size: var(--font-size-sm);
  text-transform: uppercase;
  letter-spacing: 2px;
}

.profile-continue-divider::before,
.profile-continue-divider::after {
  content: '';
  width: 60px;
  height: 1px;
  background-color: var(--text-dim);
}

.profile-continue-btn {
  padding: var(--spacing-sm) var(--spacing-lg);
  font-size: var(--font-size-lg);
  background: transparent;
  border: 2px dashed var(--text-color);
  color: var(--text-color);
  text-transform: uppercase;
  letter-spacing: 2px;
  cursor: pointer;
  transition:
    background-color 0.2s,
    border-style 0.2s,
    box-shadow 0.2s;
}

.profile-continue-btn:hover {
  background-color: rgba(51, 255, 0, 0.1);
  border-style: solid;
  box-shadow: 0 0 15px var(--text-color);
}

/* 하단 안내 */
.profile-select-footer {
  text-align: center;
}

.profile-select-hint {
  font-size: var(--font-size-sm);
  color: var(--text-dim);
  font-style: italic;
}

/* ============================================
   30. 리셋 버튼 스타일 (U-015[Mvp])
   ============================================ */

.reset-button-wrapper {
  display: inline-flex;
  align-items: center;
  gap: var(--spacing-xs);
}

.reset-button {
  display: inline-flex;
  align-items: center;
  gap: var(--spacing-xs);
  padding: var(--spacing-xs) var(--spacing-sm);
  background: transparent;
  border: 1px solid var(--text-dim);
  color: var(--text-color);
  font-size: var(--font-size-xs);
  text-transform: uppercase;
  letter-spacing: 1px;
  cursor: pointer;
  transition:
    border-color 0.2s,
    background-color 0.2s,
    color 0.2s;
}

.reset-button:hover:not(:disabled) {
  border-color: var(--warning-color);
  color: var(--warning-color);
}

.reset-button.confirming {
  border-color: var(--error-color);
  background-color: rgba(255, 51, 51, 0.1);
  color: var(--error-color);
  animation: confirm-pulse 0.5s ease-in-out infinite;
}

@keyframes confirm-pulse {
  0%,
  100% {
    opacity: 1;
  }
  50% {
    opacity: 0.7;
  }
}

.reset-button.compact {
  padding: var(--spacing-xs);
  min-width: 28px;
  justify-content: center;
}

.reset-button:disabled {
  opacity: 0.4;
  cursor: not-allowed;
}

.reset-icon {
  font-size: 0.875rem;
}

.reset-text {
  white-space: nowrap;
}

.reset-cancel-button {
  padding: 2px 6px;
  background: transparent;
  border: 1px solid var(--text-dim);
  color: var(--text-dim);
  font-size: 0.75rem;
  cursor: pointer;
  transition:
    border-color 0.2s,
    color 0.2s;
}

.reset-cancel-button:hover {
  border-color: var(--text-color);
  color: var(--text-color);
}

/* 프로필 변경 버튼 */
.change-profile-button {
  display: inline-flex;
  align-items: center;
  gap: var(--spacing-xs);
  padding: var(--spacing-xs) var(--spacing-sm);
  background: transparent;
  border: 1px solid var(--text-dim);
  color: var(--text-color);
  font-size: var(--font-size-xs);
  text-transform: uppercase;
  letter-spacing: 1px;
  cursor: pointer;
  transition:
    border-color 0.2s,
    color 0.2s;
}

.change-profile-button:hover:not(:disabled) {
  border-color: var(--accent-color);
  color: var(--accent-color);
}

.change-profile-button:disabled {
  opacity: 0.4;
  cursor: not-allowed;
}

.change-profile-icon {
  font-size: 0.875rem;
}

.change-profile-text {
  white-space: nowrap;
}

/* reduced-motion: 프로필 선택 애니메이션 완화 */
@media (prefers-reduced-motion: reduce) {
  .profile-card:hover {
    transform: none;
  }

  .reset-button.confirming {
    animation: none;
  }
}

/* =============================================================================
 * U-079: 재화 부족 시 이미지 생성 허용 + 재화 획득 경로 다양화
 * ============================================================================= */

/* ---- 인벤토리 판매 버튼 ---- */
.inventory-sell-btn {
  display: flex;
  align-items: center;
  gap: 2px;
  padding: 2px 6px;
  border: 1px solid rgba(255, 200, 0, 0.5);
  border-radius: 4px;
  background: rgba(255, 200, 0, 0.1);
  color: #ffc800;
  font-size: var(--font-size-xs);
  font-family: var(--font-micro-en);
  cursor: pointer;
  transition: all 0.15s ease;
  white-space: nowrap;
  margin-left: auto;
  flex-shrink: 0;
}

.inventory-sell-btn:hover {
  background: rgba(255, 200, 0, 0.25);
  border-color: #ffc800;
  box-shadow: 0 0 8px rgba(255, 200, 0, 0.3);
}

.inventory-sell-btn:active {
  transform: scale(0.95);
}

.inventory-sell-btn .sell-icon {
  font-size: 0.75rem;
}

.inventory-sell-btn .sell-price {
  font-weight: 700;
}

/* U-129: 인라인 컨펌 상태 (2단계 클릭) */
.inventory-sell-btn.confirming {
  background: rgba(255, 60, 60, 0.25);
  border-color: #ff4444;
  color: #ff6666;
  animation: sell-confirm-pulse 0.6s ease-in-out infinite alternate;
}

.inventory-sell-btn.confirming:hover {
  background: rgba(255, 60, 60, 0.4);
  border-color: #ff6666;
  box-shadow: 0 0 10px rgba(255, 60, 60, 0.4);
}

.inventory-sell-btn .sell-confirm-text {
  font-weight: 700;
  font-size: var(--font-size-xs);
  letter-spacing: 0.02em;
}

@keyframes sell-confirm-pulse {
  from {
    box-shadow: 0 0 4px rgba(255, 60, 60, 0.2);
  }
  to {
    box-shadow: 0 0 10px rgba(255, 60, 60, 0.5);
  }
}

/* ---- 재화 획득 액션 카드 배지 ---- */
/* U-083: .earn-badge → .action-card-badge.badge-earn 으로 통합됨.
   아래 glow 애니메이션은 badge-earn에 적용. */
.action-card-badge.badge-earn {
  animation: earn-badge-glow 2s ease-in-out infinite;
}

@keyframes earn-badge-glow {
  0%,
  100% {
    box-shadow: 0 0 4px rgba(255, 200, 0, 0.2);
  }
  50% {
    box-shadow: 0 0 10px rgba(255, 200, 0, 0.5);
  }
}

.action-card.card-earn {
  border-color: rgba(255, 200, 0, 0.4);
}

.action-card.card-earn:hover:not(:disabled) {
  border-color: #ffc800;
  box-shadow:
    0 0 12px rgba(255, 200, 0, 0.3),
    inset 0 0 12px rgba(255, 200, 0, 0.05);
}

/* ---- EconomyHud: FAST 폴백 안내 ---- */
.economy-alternatives-enhanced .alternatives-header {
  display: flex;
  align-items: center;
  gap: 6px;
}

.fast-fallback-notice {
  display: flex;
  align-items: center;
  gap: 6px;
  padding: 4px 8px;
  margin: 4px 0;
  background: rgba(51, 255, 0, 0.08);
  border: 1px solid rgba(51, 255, 0, 0.2);
  border-radius: 4px;
  font-size: var(--font-size-xs);
}

.fast-fallback-badge {
  display: inline-block;
  padding: 1px 5px;
  border-radius: 3px;
  background: rgba(51, 255, 0, 0.2);
  border: 1px solid rgba(51, 255, 0, 0.4);
  color: var(--primary-color);
  font-family: var(--font-micro-en);
  font-size: 0.625rem;
  font-weight: 700;
  letter-spacing: 1px;
}

.fast-fallback-text {
  color: var(--text-dim);
  font-size: var(--font-size-xs);
}

/* ---- 재화 획득 토스트 알림 ---- */
.currency-toast {
  position: fixed;
  top: 60px;
  left: 50%;
  transform: translateX(-50%);
  z-index: 9999;
  display: flex;
  align-items: center;
  gap: 8px;
  padding: 10px 20px;
  border: 1px solid rgba(255, 200, 0, 0.5);
  border-radius: 8px;
  background: rgba(10, 10, 10, 0.95);
  box-shadow:
    0 4px 20px rgba(255, 200, 0, 0.2),
    0 0 30px rgba(255, 200, 0, 0.1);
  backdrop-filter: blur(8px);
  animation:
    toast-slide-in 0.3s ease-out,
    toast-fade-out 0.5s ease-in 2.5s forwards;
  pointer-events: auto;
}

.currency-toast-icon {
  font-size: 1.25rem;
}

.currency-toast-amount {
  font-family: var(--font-micro-en);
  font-size: 1.1rem;
  font-weight: 700;
  color: #ffc800;
}

.currency-toast-reason {
  font-size: var(--font-size-xs);
  color: var(--text-dim);
}

.currency-toast-close {
  padding: 2px 6px;
  border: none;
  background: transparent;
  color: var(--text-dim);
  cursor: pointer;
  font-size: 0.875rem;
  opacity: 0.6;
  transition: opacity 0.15s;
}

.currency-toast-close:hover {
  opacity: 1;
}

@keyframes toast-slide-in {
  from {
    transform: translateX(-50%) translateY(-20px);
    opacity: 0;
  }
  to {
    transform: translateX(-50%) translateY(0);
    opacity: 1;
  }
}

@keyframes toast-fade-out {
  from {
    opacity: 1;
  }
  to {
    opacity: 0;
    pointer-events: none;
  }
}

/* reduced-motion: U-079 애니메이션 완화 */
@media (prefers-reduced-motion: reduce) {
  .action-card-badge.badge-earn {
    animation: none;
  }

  .currency-toast {
    animation: none;
    opacity: 1;
  }
}

/* =============================================================================
   U-087: 입력 잠금 오버레이 (턴 처리 중 모든 사용자 입력 차단)
   - isStreaming || processingPhase !== 'idle' || imageLoading 일 때 활성화
   - pointer-events: none으로 모든 클릭/드래그를 차단
   - 시각적으로 "처리 중"임을 명확히 표시
   ============================================================================= */

.input-lock-overlay {
  position: fixed;
  inset: 0;
  z-index: 9990; /* crt-overlay(9999) 바로 아래 */
  pointer-events: auto; /* 모든 입력 이벤트를 가로챔 */
  cursor: wait;
  background: rgba(0, 0, 0, 0.15);
  display: flex;
  align-items: flex-end;
  justify-content: center;
  padding-bottom: 12px;
  animation: input-lock-fade-in 0.2s ease-out;
}

.input-lock-label {
  font-family: var(--font-family, 'Share Tech Mono', monospace);
  font-size: 0.75rem;
  color: var(--accent-color, #ff00ff);
  background: rgba(0, 0, 0, 0.7);
  padding: 4px 16px;
  border: 1px solid var(--accent-color, #ff00ff);
  border-radius: 2px;
  letter-spacing: 0.1em;
  text-transform: uppercase;
  animation: input-lock-pulse 2s ease-in-out infinite;
  box-shadow: 0 0 8px rgba(255, 0, 255, 0.3);
}

@keyframes input-lock-fade-in {
  from {
    opacity: 0;
  }
  to {
    opacity: 1;
  }
}

@keyframes input-lock-pulse {
  0%,
  100% {
    opacity: 0.8;
  }
  50% {
    opacity: 1;
  }
}

/* U-087: 잠금 중 game-container의 인터랙티브 요소 비활성화 시각 피드백 */
.input-lock-overlay ~ .currency-toast {
  pointer-events: auto; /* 토스트 알림은 닫기 버튼 유지 */
}

/* U-087: reduced-motion 대응 - 반복 애니메이션 완화 */
@media (prefers-reduced-motion: reduce) {
  .input-lock-overlay {
    animation: none;
  }

  .input-lock-label {
    animation: none;
    opacity: 1;
  }
}

/* =============================================================================
   U-130: Rate Limit 재시도 안내 패널
   - 429 Rate Limit 에러 시 표시되는 플로팅 패널
   - input-lock-overlay(z-index: 9990)보다 높은 z-index로 재시도 버튼 활성화
   - CRT 테마 + 경고 색상
   ============================================================================= */

.rate-limit-panel {
  position: fixed;
  top: 50%;
  left: 50%;
  transform: translate(-50%, -50%);
  z-index: 9995; /* input-lock-overlay(9990) < rate-limit(9995) < crt-overlay(9999) */
  pointer-events: auto;

  display: flex;
  flex-direction: column;
  align-items: center;
  gap: 12px;

  min-width: 320px;
  max-width: 420px;
  padding: 24px 32px;

  background: rgba(0, 0, 0, 0.92);
  border: 1px solid var(--warning-color, #ffaa00);
  border-radius: 4px;
  box-shadow:
    0 0 20px rgba(255, 170, 0, 0.3),
    inset 0 0 40px rgba(255, 170, 0, 0.05);

  font-family: var(--font-family, 'Share Tech Mono', monospace);
  animation: rate-limit-fade-in 0.3s ease-out;
}

.rate-limit-icon {
  font-size: 2rem;
  line-height: 1;
  color: var(--warning-color, #ffaa00);
  text-shadow: 0 0 12px rgba(255, 170, 0, 0.6);
  animation: rate-limit-icon-pulse 2s ease-in-out infinite;
}

.rate-limit-title {
  margin: 0;
  font-size: 1rem;
  font-weight: 700;
  letter-spacing: 0.08em;
  text-transform: uppercase;
  color: var(--warning-color, #ffaa00);
  text-shadow: 0 0 8px rgba(255, 170, 0, 0.4);
}

.rate-limit-detail {
  margin: 0;
  font-size: 0.8rem;
  line-height: 1.5;
  color: var(--text-color, #c8c8c8);
  text-align: center;
  opacity: 0.85;
}

/* 카운트다운 */
.rate-limit-countdown {
  width: 100%;
  display: flex;
  flex-direction: column;
  align-items: center;
  gap: 6px;
}

.rate-limit-countdown-bar {
  width: 100%;
  height: 4px;
  background: rgba(255, 170, 0, 0.15);
  border-radius: 2px;
  overflow: hidden;
}

.rate-limit-countdown-fill {
  height: 100%;
  background: var(--warning-color, #ffaa00);
  border-radius: 2px;
  transition: width 1s linear;
  box-shadow: 0 0 6px rgba(255, 170, 0, 0.5);
}

.rate-limit-countdown-text {
  font-size: 0.75rem;
  color: var(--warning-color, #ffaa00);
  opacity: 0.8;
  letter-spacing: 0.05em;
}

/* 재시도 버튼 */
.rate-limit-retry-btn {
  width: 100%;
  padding: 10px 20px;
  font-family: var(--font-family, 'Share Tech Mono', monospace);
  font-size: 0.85rem;
  font-weight: 700;
  letter-spacing: 0.1em;
  text-transform: uppercase;
  color: #000;
  background: var(--warning-color, #ffaa00);
  border: none;
  border-radius: 3px;
  cursor: pointer;
  transition:
    background 0.2s,
    box-shadow 0.2s,
    opacity 0.2s;
}

.rate-limit-retry-btn:hover:not(:disabled) {
  background: #ffcc33;
  box-shadow: 0 0 16px rgba(255, 170, 0, 0.6);
}

.rate-limit-retry-btn:active:not(:disabled) {
  transform: scale(0.98);
}

.rate-limit-retry-btn:disabled {
  background: rgba(255, 170, 0, 0.3);
  color: var(--warning-color, #ffaa00);
  cursor: not-allowed;
  opacity: 0.6;
}

/* 애니메이션 */
@keyframes rate-limit-fade-in {
  from {
    opacity: 0;
    transform: translate(-50%, -50%) scale(0.95);
  }
  to {
    opacity: 1;
    transform: translate(-50%, -50%) scale(1);
  }
}

@keyframes rate-limit-icon-pulse {
  0%,
  100% {
    opacity: 0.7;
    transform: scale(1);
  }
  50% {
    opacity: 1;
    transform: scale(1.1);
  }
}

/* Agent Console 내 RATE_LIMITED 전용 에러 스타일 */
.agent-error--rate-limited {
  border-color: var(--warning-color, #ffaa00);
  background: rgba(255, 170, 0, 0.08);
}

.agent-error--rate-limited .error-icon {
  color: var(--warning-color, #ffaa00);
}

.agent-error--rate-limited .error-message {
  color: var(--warning-color, #ffaa00);
}

/* U-130: reduced-motion 대응 */
@media (prefers-reduced-motion: reduce) {
  .rate-limit-panel {
    animation: none;
  }

  .rate-limit-icon {
    animation: none;
    opacity: 1;
  }

  .rate-limit-countdown-fill {
    transition: none;
  }
}
</file>

</files>
