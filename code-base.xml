This file is a merged representation of a subset of the codebase, containing specifically included files and files not matching ignore patterns, combined into a single document by Repomix.

<file_summary>
This section contains a summary of this file.

<purpose>
This file contains a packed representation of a subset of the repository's contents that is considered the most important context.
It is designed to be easily consumable by AI systems for analysis, code review,
or other automated processes.
</purpose>

<file_format>
The content is organized as follows:
1. This summary section
2. Repository information
3. Directory structure
4. Repository files (if enabled)
5. Multiple file entries, each consisting of:
  - File path as an attribute
  - Full contents of the file
</file_format>

<usage_guidelines>
- This file should be treated as read-only. Any changes should be made to the
  original repository files, not this packed version.
- When processing this file, use the file path to distinguish
  between different files in the repository.
- Be aware that this file may contain sensitive information. Handle it with
  the same level of security as you would the original repository.
</usage_guidelines>

<notes>
- Some files may have been excluded based on .gitignore rules and Repomix's configuration
- Binary files are not included in this packed representation. Please refer to the Repository Structure section for a complete list of file paths, including binary files
- Only files matching these patterns are included: **/*.{ts,tsx,js,jsx,json,py,toml,yaml}
- Files matching these patterns are excluded: .claude/**, .cursor/**, .gemini/**, .vscode/**, vibe/**, node_modules/**, backend/.venv/**, frontend/dist/**, frontend/coverage/**
- Files matching patterns in .gitignore are excluded
- Files matching default ignore patterns are excluded
- Files are sorted by Git change count (files with more changes are at the bottom)
</notes>

</file_summary>

<directory_structure>
backend/pyproject.toml
backend/src/unknown_world/__init__.py
backend/src/unknown_world/api/__init__.py
backend/src/unknown_world/api/turn_stream_events.py
backend/src/unknown_world/api/turn.py
backend/src/unknown_world/main.py
backend/src/unknown_world/models/__init__.py
backend/src/unknown_world/models/turn.py
backend/src/unknown_world/orchestrator/__init__.py
backend/src/unknown_world/orchestrator/mock.py
backend/tests/integration/test_api.py
backend/tests/integration/test_turn_streaming.py
backend/tests/qa/test_asset_manifest.py
backend/tests/unit/models/test_turn.py
backend/tests/unit/test_u034_verification.py
frontend/package.json
frontend/public/ui/manifest.json
frontend/public/ui/manifest.schema.json
frontend/src/api/turnStream.test.ts
frontend/src/api/turnStream.ts
frontend/src/App.test.tsx
frontend/src/App.tsx
frontend/src/components/ActionDeck.test.tsx
frontend/src/components/ActionDeck.tsx
frontend/src/components/AgentConsole.test.tsx
frontend/src/components/AgentConsole.tsx
frontend/src/components/DemoProfileSelect.tsx
frontend/src/components/DndInteraction.test.tsx
frontend/src/components/EconomyHud.test.tsx
frontend/src/components/EconomyHud.tsx
frontend/src/components/GameHeader.tsx
frontend/src/components/InventoryPanel.test.tsx
frontend/src/components/InventoryPanel.tsx
frontend/src/components/MutationTimeline.test.tsx
frontend/src/components/MutationTimeline.tsx
frontend/src/components/NarrativeFeed.tsx
frontend/src/components/Panel.tsx
frontend/src/components/QuestPanel.test.tsx
frontend/src/components/QuestPanel.tsx
frontend/src/components/ResetButton.tsx
frontend/src/components/RuleBoard.test.tsx
frontend/src/components/RuleBoard.tsx
frontend/src/components/SceneCanvas.hotspot.test.tsx
frontend/src/components/SceneCanvas.test.tsx
frontend/src/components/SceneCanvas.tsx
frontend/src/components/UIControls.tsx
frontend/src/data/demoProfiles.test.ts
frontend/src/data/demoProfiles.ts
frontend/src/demo/demoFixtures.ts
frontend/src/demo/useDemoInitializer.ts
frontend/src/dnd/types.ts
frontend/src/i18n-scenario.test.ts
frontend/src/i18n.ts
frontend/src/locales/en-US/translation.json
frontend/src/locales/ko-KR/translation.json
frontend/src/main.tsx
frontend/src/save/constants.ts
frontend/src/save/saveGame.test.ts
frontend/src/save/saveGame.ts
frontend/src/save/sessionLifecycle.test.ts
frontend/src/save/sessionLifecycle.ts
frontend/src/schemas/index.ts
frontend/src/schemas/turn.test.ts
frontend/src/schemas/turn.ts
frontend/src/schemas/verify_runbook.ts
frontend/src/setupTests.ts
frontend/src/stores/actionDeckStore.test.ts
frontend/src/stores/actionDeckStore.ts
frontend/src/stores/agentStore.test.ts
frontend/src/stores/agentStore.ts
frontend/src/stores/economyStore.test.ts
frontend/src/stores/economyStore.ts
frontend/src/stores/inventoryStore.test.ts
frontend/src/stores/inventoryStore.ts
frontend/src/stores/uiPrefsStore.test.ts
frontend/src/stores/uiPrefsStore.ts
frontend/src/stores/worldStore.test.ts
frontend/src/stores/worldStore.ts
frontend/src/turn/turnRunner.ts
frontend/src/types/scene.ts
frontend/src/types/turn_stream.ts
frontend/src/utils/box2d.test.ts
frontend/src/utils/box2d.ts
frontend/src/vite-env.d.ts
frontend/tsconfig.json
frontend/tsconfig.node.json
frontend/vite.config.ts
package.json
shared/schemas/turn/turn_input.schema.json
shared/schemas/turn/turn_output.schema.json
</directory_structure>

<files>
This section contains the contents of the repository's files.

<file path="backend/src/unknown_world/api/__init__.py">
"""Unknown World - API íŒ¨í‚¤ì§€.

ì´ íŒ¨í‚¤ì§€ëŠ” FastAPI ë¼ìš°í„°ë“¤ì„ í¬í•¨í•©ë‹ˆë‹¤.
"""

from unknown_world.api.turn import router as turn_router

__all__ = ["turn_router"]
</file>

<file path="backend/src/unknown_world/models/__init__.py">
"""Unknown World - ëª¨ë¸ íŒ¨í‚¤ì§€.

ì´ íŒ¨í‚¤ì§€ëŠ” TurnInput/TurnOutput ìŠ¤í‚¤ë§ˆ ë° í•˜ìœ„ íƒ€ì…ì„ ì •ì˜í•©ë‹ˆë‹¤.
Gemini Structured Outputs(JSON Schema)ìš©ìœ¼ë¡œ ì„¤ê³„ë˜ì—ˆìŠµë‹ˆë‹¤.

ì‚¬ìš© ì˜ˆì‹œ:
    from unknown_world.models import TurnInput, TurnOutput

    # Pydantic â†’ JSON Schema ë³€í™˜ (Gemini response_json_schemaìš©)
    schema = TurnOutput.model_json_schema()

    # ì‘ë‹µ ê²€ì¦
    output = TurnOutput.model_validate_json(response_text)

ì°¸ì¡°:
    - vibe/prd.md 8.7 (ë°ì´í„° ëª¨ë¸ ì„¤ê³„)
    - vibe/ref/structured-outputs-guide.md
    - .cursor/rules/00-core-critical.mdc (RULE-003, RULE-005)
"""

from unknown_world.models.turn import (
    ActionCard,
    ActionDeck,
    AgentConsole,
    AgentPhase,
    Box2D,
    ClickInput,
    ClientInfo,
    Coordinate,
    CurrencyAmount,
    EconomyOutput,
    EconomySnapshot,
    ImageJob,
    Language,
    MemoryPin,
    ModelLabel,
    Quest,
    RenderOutput,
    RiskLevel,
    SafetyOutput,
    SceneObject,
    Theme,
    TurnInput,
    TurnOutput,
    UIOutput,
    ValidationBadge,
    WorldDelta,
    WorldRule,
)

__all__ = [
    # Enum íƒ€ì…
    "Language",
    "Theme",
    "AgentPhase",
    "ValidationBadge",
    "ModelLabel",
    "RiskLevel",
    # ê³µí†µ í•˜ìœ„ íƒ€ì…
    "Coordinate",
    "Box2D",
    "CurrencyAmount",
    # TurnInput ê´€ë ¨
    "TurnInput",
    "ClickInput",
    "ClientInfo",
    "EconomySnapshot",
    # TurnOutput ê´€ë ¨
    "TurnOutput",
    "UIOutput",
    "ActionDeck",
    "ActionCard",
    "SceneObject",
    "WorldDelta",
    "WorldRule",
    "Quest",
    "MemoryPin",
    "RenderOutput",
    "ImageJob",
    "EconomyOutput",
    "SafetyOutput",
    "AgentConsole",
]
</file>

<file path="backend/src/unknown_world/orchestrator/__init__.py">
"""Unknown World - Orchestrator íŒ¨í‚¤ì§€.

ì´ íŒ¨í‚¤ì§€ëŠ” í„´ ì²˜ë¦¬ ì˜¤ì¼€ìŠ¤íŠ¸ë ˆì´í„°ë¥¼ í¬í•¨í•©ë‹ˆë‹¤.
"""

from unknown_world.orchestrator.mock import MockOrchestrator

__all__ = ["MockOrchestrator"]
</file>

<file path="backend/tests/integration/test_api.py">
from fastapi.testclient import TestClient

from unknown_world.main import app

client = TestClient(app)


def test_health_check():
    """/health ì—”ë“œí¬ì¸íŠ¸ê°€ ì˜¬ë°”ë¥¸ ìŠ¤í‚¤ë§ˆì™€ ìƒíƒœë¥¼ ë°˜í™˜í•˜ëŠ”ì§€ í…ŒìŠ¤íŠ¸í•©ë‹ˆë‹¤."""
    response = client.get("/health")
    assert response.status_code == 200
    data = response.json()
    assert data["status"] == "ok"
    assert "version" in data
    assert data["service"] == "unknown-world-backend"


def test_root_endpoint():
    """ë£¨íŠ¸ ì—”ë“œí¬ì¸íŠ¸ê°€ ì •ìƒ ì‘ë™í•˜ëŠ”ì§€ í…ŒìŠ¤íŠ¸í•©ë‹ˆë‹¤."""
    response = client.get("/")
    assert response.status_code == 200
    assert "message" in response.json()


def test_cors_policy():
    """RULE-011ì— ë”°ë¥¸ CORS ì •ì±…ì´ ì˜¬ë°”ë¥´ê²Œ ì„¤ì •ë˜ì—ˆëŠ”ì§€ í…ŒìŠ¤íŠ¸í•©ë‹ˆë‹¤."""
    # í—ˆìš©ëœ ì˜¤ë¦¬ì§„ í…ŒìŠ¤íŠ¸ (í¬íŠ¸ 8001)
    headers = {
        "Origin": "http://localhost:8001",
        "Access-Control-Request-Method": "GET",
    }
    response = client.options("/health", headers=headers)
    assert response.status_code == 200
    assert response.headers.get("access-control-allow-origin") == "http://localhost:8001"

    # í—ˆìš©ë˜ì§€ ì•Šì€ ì˜¤ë¦¬ì§„ í…ŒìŠ¤íŠ¸ (í¬íŠ¸ 9000)
    headers = {
        "Origin": "http://localhost:9000",
        "Access-Control-Request-Method": "GET",
    }
    response = client.options("/health", headers=headers)
    # FastAPI/Starlette CORS ë¯¸ë“¤ì›¨ì–´ëŠ” í—ˆìš©ë˜ì§€ ì•Šì€ ê²½ìš° origin í—¤ë”ë¥¼ ë°˜í™˜í•˜ì§€ ì•ŠìŒ
    assert "access-control-allow-origin" not in response.headers
</file>

<file path="backend/tests/qa/test_asset_manifest.py">
import json
import os

import pytest
from jsonschema import validate

# Paths
# This file is in backend/tests/qa/
# We go up 3 levels to get to backend root: backend/tests/qa -> backend/tests -> backend -> root (wait, backend is in root)
# Actually:
# __file__ = D:\Dev\unknown-world\backend\tests\qa\test_asset_manifest.py
# os.path.dirname(__file__) = D:\Dev\unknown-world\backend\tests\qa
# ... up 1 = tests
# ... up 2 = backend
# ... up 3 = unknown-world (project root)

CURRENT_DIR = os.path.dirname(os.path.abspath(__file__))
PROJECT_ROOT = os.path.dirname(os.path.dirname(os.path.dirname(CURRENT_DIR)))

# If PROJECT_ROOT is correct, it should contain frontend/
FRONTEND_UI_DIR = os.path.join(PROJECT_ROOT, "frontend", "public", "ui")
MANIFEST_PATH = os.path.join(FRONTEND_UI_DIR, "manifest.json")
SCHEMA_PATH = os.path.join(FRONTEND_UI_DIR, "manifest.schema.json")


def test_manifest_schema_validation():
    """Validates manifest.json against manifest.schema.json"""
    if not os.path.exists(MANIFEST_PATH):
        pytest.fail(f"Manifest not found at {MANIFEST_PATH}")
    if not os.path.exists(SCHEMA_PATH):
        pytest.fail(f"Schema not found at {SCHEMA_PATH}")

    with open(MANIFEST_PATH, encoding="utf-8") as f:
        manifest = json.load(f)

    with open(SCHEMA_PATH, encoding="utf-8") as f:
        schema = json.load(f)

    # validate raises ValidationError on failure
    validate(instance=manifest, schema=schema)


def test_asset_files_existence_and_size():
    """Checks if assets listed in manifest exist and sizes match/budget"""
    with open(MANIFEST_PATH, encoding="utf-8") as f:
        manifest = json.load(f)

    assets = manifest.get("assets", [])
    total_bytes_calculated = 0

    for asset in assets:
        rel_path = asset["path"]
        abs_path = os.path.join(FRONTEND_UI_DIR, rel_path)

        # 1. Existence Check
        assert os.path.exists(abs_path), f"Asset file missing: {rel_path} (full: {abs_path})"

        # 2. Size Check
        actual_size = os.path.getsize(abs_path)
        recorded_size = asset.get("bytes")

        # Note: If size mismatches, we print a helpful message.
        # In a real QA scenario, we might want to auto-update, but for this test we fail.
        if recorded_size is not None:
            assert actual_size == recorded_size, (
                f"Size mismatch for {rel_path}: actual {actual_size} != manifest {recorded_size}"
            )

        total_bytes_calculated += actual_size

        # 3. Individual Budget Check (from QA_CHECKLIST.md)
        asset_type = asset["type"]
        if asset_type == "icon":
            # 30KB limit
            assert actual_size <= 30 * 1024, (
                f"Icon {rel_path} exceeds 30KB budget ({actual_size} bytes)"
            )
        elif asset_type == "placeholder":
            # 300KB limit
            assert actual_size <= 300 * 1024, (
                f"Placeholder {rel_path} exceeds 300KB budget ({actual_size} bytes)"
            )
        elif asset_type == "chrome":
            # 120KB limit (increased for scanner-frame)
            assert actual_size <= 120 * 1024, (
                f"Chrome asset {rel_path} exceeds 120KB budget ({actual_size} bytes)"
            )

    # 4. Total Budget Check
    recorded_total = manifest.get("totalBytes")
    if recorded_total is not None:
        assert total_bytes_calculated == recorded_total, (
            f"Total bytes mismatch: calculated {total_bytes_calculated} != manifest {recorded_total}"
        )

    budget_total = manifest.get("budgetBytes", 1572864)
    assert total_bytes_calculated <= budget_total, (
        f"Total size {total_bytes_calculated} exceeds budget {budget_total}"
    )


def test_asset_naming_convention():
    """Checks if asset IDs and paths use kebab-case"""
    with open(MANIFEST_PATH, encoding="utf-8") as f:
        manifest = json.load(f)

    for asset in manifest["assets"]:
        asset_id = asset["id"]
        # Check for lowercase and kebab-case (allow numbers)
        assert asset_id.islower(), f"Asset ID {asset_id} should be lowercase"
        assert " " not in asset_id, f"Asset ID {asset_id} should not contain spaces"
        assert "_" not in asset_id, (
            f"Asset ID {asset_id} should not contain underscores (use kebab-case)"
        )
</file>

<file path="backend/tests/unit/models/test_turn.py">
"""TurnInput/TurnOutput ëª¨ë¸ ë‹¨ìœ„ í…ŒìŠ¤íŠ¸."""

import pytest
from pydantic import ValidationError

from unknown_world.models.turn import (
    AgentConsole,
    Box2D,
    CurrencyAmount,
    EconomyOutput,
    Language,
    RenderOutput,
    TurnInput,
    TurnOutput,
    UIOutput,
    WorldDelta,
)

# =============================================================================
# Fixtures
# =============================================================================


@pytest.fixture
def valid_box_2d():
    return {"ymin": 100, "xmin": 200, "ymax": 300, "xmax": 400}


@pytest.fixture
def valid_currency_amount():
    return {"signal": 100, "memory_shard": 5}


@pytest.fixture
def valid_client_info():
    return {"viewport_w": 1920, "viewport_h": 1080, "theme": "dark"}


@pytest.fixture
def valid_turn_input_data(valid_client_info, valid_currency_amount):
    return {
        "language": "ko-KR",
        "text": "Hello",
        "client": valid_client_info,
        "economy_snapshot": valid_currency_amount,
    }


@pytest.fixture
def valid_turn_output_data(valid_currency_amount):
    return {
        "language": "ko-KR",
        "narrative": "Story continues...",
        "economy": {
            "cost": {"signal": 10, "memory_shard": 0},
            "balance_after": {"signal": 90, "memory_shard": 5},
        },
        "safety": {"blocked": False},
    }


# =============================================================================
# Coordinate & Box2D Tests
# =============================================================================


def test_box_2d_valid(valid_box_2d):
    box = Box2D(**valid_box_2d)
    assert box.ymin == 100
    assert box.xmax == 400


def test_box_2d_invalid_coordinate():
    with pytest.raises(ValidationError):
        # Out of range (ge=0, le=1000)
        Box2D(ymin=-1, xmin=0, ymax=1001, xmax=500)


def test_box_2d_extra_forbidden():
    with pytest.raises(ValidationError):
        Box2D(ymin=0, xmin=0, ymax=100, xmax=100, extra_field="not allowed")


# =============================================================================
# Currency & Economy Tests
# =============================================================================


def test_currency_amount_valid(valid_currency_amount):
    amount = CurrencyAmount(**valid_currency_amount)
    assert amount.signal == 100


def test_currency_amount_negative_fails():
    with pytest.raises(ValidationError):
        CurrencyAmount(signal=-1, memory_shard=0)


def test_economy_output_valid():
    data = {
        "cost": {"signal": 5, "memory_shard": 0},
        "balance_after": {"signal": 95, "memory_shard": 5},
    }
    economy = EconomyOutput(**data)
    assert economy.cost.signal == 5
    assert economy.balance_after.signal == 95


# =============================================================================
# TurnInput Tests
# =============================================================================


def test_turn_input_valid(valid_turn_input_data):
    turn_input = TurnInput(**valid_turn_input_data)
    assert turn_input.language == Language.KO
    assert turn_input.text == "Hello"


def test_turn_input_with_click(valid_turn_input_data, valid_box_2d):
    data = valid_turn_input_data.copy()
    data["click"] = {"object_id": "door_01", "box_2d": valid_box_2d}
    turn_input = TurnInput(**data)
    assert turn_input.click.object_id == "door_01"
    assert turn_input.click.box_2d.ymin == 100


def test_turn_input_invalid_language():
    with pytest.raises(ValidationError):
        TurnInput(
            language="fr-FR",  # Not in Language enum
            text="...",
            client={"viewport_w": 800, "viewport_h": 600},
            economy_snapshot={"signal": 0, "memory_shard": 0},
        )


# =============================================================================
# TurnOutput Tests
# =============================================================================


def test_turn_output_valid_minimal(valid_turn_output_data):
    turn_output = TurnOutput(**valid_turn_output_data)
    assert turn_output.language == Language.KO
    assert turn_output.narrative == "Story continues..."
    # Check defaults
    assert isinstance(turn_output.ui, UIOutput)
    assert isinstance(turn_output.world, WorldDelta)
    assert isinstance(turn_output.render, RenderOutput)
    assert isinstance(turn_output.agent_console, AgentConsole)


def test_turn_output_full(valid_currency_amount, valid_box_2d):
    data = {
        "language": "en-US",
        "narrative": "Narrative text",
        "ui": {
            "action_deck": {
                "cards": [
                    {
                        "id": "c1",
                        "label": "Action 1",
                        "cost": {"signal": 5, "memory_shard": 0},
                    }
                ]
            },
            "objects": [{"id": "obj1", "label": "Object 1", "box_2d": valid_box_2d}],
        },
        "world": {
            "inventory_added": ["key"],
            "rules_changed": [{"id": "r1", "label": "Gravity", "description": "Low gravity"}],
            "quests_updated": [{"id": "q1", "label": "Find key", "is_completed": False}],
            "memory_pins": [
                {"id": "p1", "content": "Fact", "cost": {"signal": 1, "memory_shard": 0}}
            ],
        },
        "render": {
            "image_job": {
                "should_generate": True,
                "prompt": "A landscape",
                "model_label": "QUALITY",
            }
        },
        "economy": {
            "cost": {"signal": 10, "memory_shard": 0},
            "balance_after": {"signal": 90, "memory_shard": 5},
        },
        "safety": {"blocked": False},
        "agent_console": {"repair_count": 1, "badges": ["schema_ok", "economy_ok"]},
    }
    turn_output = TurnOutput(**data)
    assert turn_output.language == Language.EN
    assert len(turn_output.ui.action_deck.cards) == 1
    assert turn_output.render.image_job.should_generate is True


def test_turn_output_missing_required():
    with pytest.raises(ValidationError):
        # Missing economy and safety
        TurnOutput(language="ko-KR", narrative="...")


# =============================================================================
# JSON Schema Tests
# =============================================================================


def test_turn_output_json_schema():
    schema = TurnOutput.model_json_schema()
    assert schema["type"] == "object"
    assert "language" in schema["required"]
    assert "narrative" in schema["required"]
    assert "economy" in schema["required"]
    assert "safety" in schema["required"]

    # Check Coordinate constraints in schema
    # Pydantic 2 schema structure: properties -> language -> ...
    # Coordinate might be in $defs or inline depending on how it's used
    ui_props = schema["$defs"]["UIOutput"]["properties"]
    assert "action_deck" in ui_props

    # Verify that Coordinate (int with ge/le) is correctly represented
    # Box2D uses Coordinate
    box_props = schema["$defs"]["Box2D"]["properties"]
    assert box_props["ymin"]["maximum"] == 1000
    assert box_props["ymin"]["minimum"] == 0
</file>

<file path="frontend/src/components/DemoProfileSelect.tsx">
/**
 * Unknown World - ë°ëª¨ í”„ë¡œí•„ ì„ íƒ ì»´í¬ë„ŒíŠ¸ (U-015[Mvp]).
 *
 * ì²« í™”ë©´ì—ì„œ 3ì¢…ì˜ ë°ëª¨ í”„ë¡œí•„ì„ ì„ íƒí•  ìˆ˜ ìˆëŠ” UIë¥¼ ì œê³µí•©ë‹ˆë‹¤.
 * í”„ë¡œí•„ ì„ íƒ ì‹œ í•´ë‹¹ SaveGameì„ ì¦‰ì‹œ ë¡œë“œí•˜ê³  ê²Œì„ì„ ì‹œì‘í•©ë‹ˆë‹¤.
 *
 * ì„¤ê³„ ì›ì¹™:
 *   - RULE-002: ì±„íŒ… UI ê¸ˆì§€, ê²Œì„ UIë¡œ ìƒì‹œ ë…¸ì¶œ
 *   - RULE-006: i18n í‚¤ ê¸°ë°˜ ë‹¤êµ­ì–´ ì§€ì›
 *   - PRD 6.9: ë°ëª¨ í”„ë¡œí•„ ì„ íƒë§Œìœ¼ë¡œ ì¦‰ì‹œ ì‹œì‘
 *
 * @module components/DemoProfileSelect
 */

import { useCallback } from 'react';
import { useTranslation } from 'react-i18next';
import { DEMO_PROFILES, type DemoProfile } from '../data/demoProfiles';

// =============================================================================
// íƒ€ì… ì •ì˜
// =============================================================================

export interface DemoProfileSelectProps {
  /** í”„ë¡œí•„ ì„ íƒ ì‹œ í˜¸ì¶œë˜ëŠ” ì½œë°± */
  onSelectProfile: (profile: DemoProfile) => void;
  /** ê¸°ì¡´ ì„¸ì´ë¸Œ ë¡œë“œ ì‹œ í˜¸ì¶œë˜ëŠ” ì½œë°± (ì„¸ì´ë¸Œê°€ ìˆëŠ” ê²½ìš°) */
  onContinue?: () => void;
  /** ê¸°ì¡´ ì„¸ì´ë¸Œê°€ ìˆëŠ”ì§€ ì—¬ë¶€ */
  hasSavedGame?: boolean;
}

// =============================================================================
// ì»´í¬ë„ŒíŠ¸
// =============================================================================

/**
 * ë°ëª¨ í”„ë¡œí•„ ì„ íƒ í™”ë©´.
 * ê²Œì„ ì‹œì‘ ì „ì— 3ì¢…ì˜ í”„ë¡œí•„ ì¤‘ í•˜ë‚˜ë¥¼ ì„ íƒí•©ë‹ˆë‹¤.
 */
export function DemoProfileSelect({
  onSelectProfile,
  onContinue,
  hasSavedGame = false,
}: DemoProfileSelectProps) {
  const { t } = useTranslation();

  const handleSelectProfile = useCallback(
    (profile: DemoProfile) => {
      onSelectProfile(profile);
    },
    [onSelectProfile],
  );

  const handleContinue = useCallback(() => {
    onContinue?.();
  }, [onContinue]);

  return (
    <div className="profile-select-container" data-ui-importance="critical">
      {/* íƒ€ì´í‹€ */}
      <header className="profile-select-header">
        <h1 className="profile-select-title glitch" data-text={t('ui.logo')}>
          {t('ui.logo')}
        </h1>
        <p className="profile-select-subtitle">{t('profile.select_title')}</p>
      </header>

      {/* í”„ë¡œí•„ ì¹´ë“œ ëª©ë¡ */}
      <div className="profile-card-grid">
        {DEMO_PROFILES.map((profile) => (
          <button
            key={profile.id}
            type="button"
            className="profile-card"
            onClick={() => handleSelectProfile(profile)}
            style={{ '--profile-accent': profile.themeColor } as React.CSSProperties}
            aria-label={t(profile.nameKey)}
          >
            <span className="profile-card-icon" aria-hidden="true">
              {profile.icon}
            </span>
            <span className="profile-card-name">{t(profile.nameKey)}</span>
            <span className="profile-card-description">{t(profile.descriptionKey)}</span>
          </button>
        ))}
      </div>

      {/* ê¸°ì¡´ ì„¸ì´ë¸Œ ê³„ì†í•˜ê¸° (ìˆëŠ” ê²½ìš°) */}
      {hasSavedGame && onContinue && (
        <div className="profile-continue-section">
          <div className="profile-continue-divider">
            <span>{t('profile.or')}</span>
          </div>
          <button type="button" className="profile-continue-btn" onClick={handleContinue}>
            {t('profile.continue_saved')}
          </button>
        </div>
      )}

      {/* ì•ˆë‚´ ë¬¸êµ¬ */}
      <footer className="profile-select-footer">
        <p className="profile-select-hint">{t('profile.select_hint')}</p>
      </footer>
    </div>
  );
}
</file>

<file path="frontend/src/components/EconomyHud.test.tsx">
import { describe, it, expect, beforeEach, vi } from 'vitest';
import { render, screen } from '@testing-library/react';
import { EconomyHud } from './EconomyHud';
import { useWorldStore } from '../stores/worldStore';
import { useEconomyStore } from '../stores/economyStore';

// react-i18next ëª¨í‚¹
vi.mock('react-i18next', () => ({
  useTranslation: () => ({
    t: (key: string) => key,
  }),
}));

describe('EconomyHud', () => {
  beforeEach(() => {
    useWorldStore.getState().reset();
    useEconomyStore.getState().reset();
  });

  it('í˜„ì¬ ì”ì•¡ì„ ì˜¬ë°”ë¥´ê²Œ í‘œì‹œí•´ì•¼ í•œë‹¤', () => {
    useWorldStore.getState().setEconomy({ signal: 50, memory_shard: 5 });

    render(<EconomyHud />);

    expect(screen.getByTestId('signal-balance')).toHaveTextContent('50');
    expect(screen.getByTestId('shard-balance')).toHaveTextContent('5');
  });

  it('ì˜ˆìƒ ë¹„ìš©ì´ ìˆì„ ë•Œ í‘œì‹œí•´ì•¼ í•œë‹¤', () => {
    useEconomyStore.getState().setCostEstimate({
      min: { signal: 5, memory_shard: 0 },
      max: { signal: 10, memory_shard: 0 },
      label: 'Test Action',
    });

    render(<EconomyHud />);

    expect(screen.getByText('economy.estimated_cost')).toBeInTheDocument();
    expect(screen.getByText('Test Action')).toBeInTheDocument();
    expect(screen.getByText('5~10')).toBeInTheDocument();
  });

  it('ê°ë‹¹í•  ìˆ˜ ì—†ëŠ” ì˜ˆìƒ ë¹„ìš©ì¼ ë•Œ ê²½ê³ ë¥¼ í‘œì‹œí•´ì•¼ í•œë‹¤', () => {
    useWorldStore.getState().setEconomy({ signal: 5, memory_shard: 0 });
    useEconomyStore.getState().setCostEstimate({
      min: { signal: 10, memory_shard: 0 },
      max: { signal: 15, memory_shard: 0 },
    });

    const { container } = render(<EconomyHud />);

    expect(screen.getByText('economy.insufficient_funds')).toBeInTheDocument();
    expect(container.querySelector('.cost-unaffordable')).toBeInTheDocument();
  });

  it('ì˜ˆìƒ ë¹„ìš©ì´ ì—†ì„ ë•Œ ë§ˆì§€ë§‰ í™•ì • ë¹„ìš©ì„ í‘œì‹œí•´ì•¼ í•œë‹¤', () => {
    useEconomyStore.getState().setLastCost({
      turnId: 1,
      cost: { signal: 8, memory_shard: 1 },
      balanceAfter: { signal: 92, memory_shard: 4 },
      modelLabel: 'QUALITY',
    });

    render(<EconomyHud />);

    expect(screen.getByText('economy.confirmed_cost')).toBeInTheDocument();
    expect(screen.getByText('8')).toBeInTheDocument();
    expect(screen.getByText('1')).toBeInTheDocument();
    expect(screen.getByText('economy.model_label.QUALITY')).toBeInTheDocument();
  });

  it('ì”ì•¡ ë¶€ì¡± ì‹œ ê²½ê³  ë° ëŒ€ì•ˆì„ í‘œì‹œí•´ì•¼ í•œë‹¤', () => {
    // ì„ê³„ê°’ 10, í˜„ì¬ ì”ì•¡ 5
    useWorldStore.getState().setEconomy({ signal: 5, memory_shard: 0 });
    useEconomyStore.getState().updateBalanceLowStatus({ signal: 5, memory_shard: 0 });

    render(<EconomyHud />);

    expect(screen.getByText('economy.low_balance_warning')).toBeInTheDocument();
    expect(screen.getByText('economy.alternatives_title')).toBeInTheDocument();
    expect(screen.getByText('economy.alternative_text_only')).toBeInTheDocument();
  });

  it('compact ëª¨ë“œì—ì„œëŠ” ì”ì•¡ë§Œ í‘œì‹œí•´ì•¼ í•œë‹¤', () => {
    useEconomyStore.getState().setCostEstimate({
      min: { signal: 5, memory_shard: 0 },
      max: { signal: 10, memory_shard: 0 },
    });

    render(<EconomyHud compact />);

    // ì”ì•¡ì€ í‘œì‹œë¨
    expect(screen.getByTestId('signal-balance')).toBeInTheDocument();
    // ì˜ˆìƒ ë¹„ìš©ì€ í‘œì‹œë˜ì§€ ì•ŠìŒ
    expect(screen.queryByText('economy.estimated_cost')).not.toBeInTheDocument();
  });

  it('ì›ì¥ ì´ë ¥ì´ ìˆì„ ë•Œ í‘œì‹œí•´ì•¼ í•œë‹¤', () => {
    useEconomyStore.getState().addLedgerEntry({
      turnId: 1,
      reason: 'test reason',
      cost: { signal: 5, memory_shard: 0 },
      balanceAfter: { signal: 95, memory_shard: 5 },
      modelLabel: 'FAST',
    });

    render(<EconomyHud />);

    expect(screen.getByText('economy.ledger_title')).toBeInTheDocument();
    expect(screen.getByText('T1')).toBeInTheDocument();
    expect(screen.getByText('test reason')).toBeInTheDocument();
    expect(screen.getByText('-5')).toBeInTheDocument();
  });
});
</file>

<file path="frontend/src/components/EconomyHud.tsx">
/**
 * Unknown World - Economy HUD ì»´í¬ë„ŒíŠ¸ (U-014[Mvp]).
 *
 * Signal/Memory Shard ì¬í™” ì”ì•¡, ì˜ˆìƒ ë¹„ìš©, í™•ì • ë¹„ìš©ì„ í‘œì‹œí•˜ê³ ,
 * ì”ì•¡ ë¶€ì¡± ì‹œ ê²½ê³  ë° ëŒ€ì•ˆì„ ì•ˆë‚´í•˜ëŠ” ê²Œì„ HUD ì»´í¬ë„ŒíŠ¸ì…ë‹ˆë‹¤.
 *
 * RULE-002 ì¤€ìˆ˜: ì±„íŒ… ë²„ë¸”ì´ ì•„ë‹Œ ê²Œì„ HUD í˜•íƒœ
 * RULE-005 ì¤€ìˆ˜: ì˜ˆìƒ ë¹„ìš© ì‚¬ì „ í‘œì‹œ, ì”ì•¡ ìŒìˆ˜ í‘œì‹œ ë°©ì§€
 * RULE-008 ì¤€ìˆ˜: ë¹„ìš©/ëª¨ë¸ ì„ íƒ ì´ìœ ëŠ” ë¼ë²¨ë¡œë§Œ í‘œì‹œ (í”„ë¡¬í”„íŠ¸ ë…¸ì¶œ ê¸ˆì§€)
 *
 * @see vibe/prd.md 5ì¥ - ì¬í™” ëª©ì /UX ìš”êµ¬
 * @module components/EconomyHud
 */

import { useMemo } from 'react';
import { useTranslation } from 'react-i18next';
import { useShallow } from 'zustand/react/shallow';
import { useWorldStore } from '../stores/worldStore';
import {
  useEconomyStore,
  selectCostEstimate,
  selectLastCost,
  selectIsBalanceLow,
  selectRecentLedger,
  canAffordEstimate,
  type LedgerEntry,
} from '../stores/economyStore';
import type { CurrencyAmount } from '../schemas/turn';

// =============================================================================
// íƒ€ì… ì •ì˜
// =============================================================================

export interface EconomyHudProps {
  /** ê°„ì†Œí™” ëª¨ë“œ (í—¤ë”ìš© - ì”ì•¡ë§Œ í‘œì‹œ) */
  compact?: boolean;
  /** ì¶”ê°€ CSS í´ë˜ìŠ¤ */
  className?: string;
}

// =============================================================================
// ì•„ì´ì½˜ ì»´í¬ë„ŒíŠ¸
// =============================================================================

interface CurrencyIconProps {
  type: 'signal' | 'shard';
  size?: number;
}

function CurrencyIcon({ type, size = 20 }: CurrencyIconProps) {
  const { t } = useTranslation();

  const iconSrc = type === 'signal' ? '/ui/icons/signal-24.png' : '/ui/icons/shard-24.png';
  const fallback = type === 'signal' ? 'âš¡' : 'ğŸ’';
  const label = type === 'signal' ? t('economy.signal') : t('economy.shard');

  return (
    <span className="icon-wrapper" aria-label={label}>
      <img
        src={iconSrc}
        alt=""
        aria-hidden="true"
        className="icon-img"
        style={{ width: size, height: size }}
        onError={(e) => e.currentTarget.classList.add('hidden')}
      />
      <span className="icon-fallback">{fallback}</span>
    </span>
  );
}

// =============================================================================
// ì”ì•¡ í‘œì‹œ ì»´í¬ë„ŒíŠ¸
// =============================================================================

interface BalanceDisplayProps {
  balance: CurrencyAmount;
  isLow?: boolean;
}

function BalanceDisplay({ balance, isLow }: BalanceDisplayProps) {
  const { t } = useTranslation();

  return (
    <div className={`economy-balance ${isLow ? 'balance-low' : ''}`} data-ui-importance="critical">
      <div className="balance-item">
        <CurrencyIcon type="signal" />
        <span className="balance-value" data-testid="signal-balance">
          {balance.signal}
        </span>
        <span className="balance-label">{t('economy.signal')}</span>
      </div>
      <div className="balance-item">
        <CurrencyIcon type="shard" />
        <span className="balance-value" data-testid="shard-balance">
          {balance.memory_shard}
        </span>
        <span className="balance-label">{t('economy.shard')}</span>
      </div>
      {isLow && (
        <div className="balance-warning" aria-live="polite">
          <span className="warning-icon">âš </span>
          <span className="warning-text">{t('economy.low_balance_warning')}</span>
        </div>
      )}
    </div>
  );
}

// =============================================================================
// ë¹„ìš© í‘œì‹œ ì»´í¬ë„ŒíŠ¸
// =============================================================================

interface CostDisplayProps {
  /** ë¹„ìš© ìœ í˜• */
  type: 'estimate' | 'confirmed';
  /** ë¹„ìš© ë²”ìœ„ (ì˜ˆìƒ) */
  min?: CurrencyAmount;
  max?: CurrencyAmount;
  /** í™•ì • ë¹„ìš© */
  cost?: CurrencyAmount;
  /** ê°ë‹¹ ê°€ëŠ¥ ì—¬ë¶€ */
  affordable?: boolean;
  /** ë¼ë²¨ */
  label?: string;
}

function CostDisplay({ type, min, max, cost, affordable, label }: CostDisplayProps) {
  const { t } = useTranslation();

  const isRange =
    min && max && (min.signal !== max.signal || min.memory_shard !== max.memory_shard);

  const titleKey = type === 'estimate' ? 'economy.estimated_cost' : 'economy.confirmed_cost';
  const cssClass = type === 'estimate' ? 'cost-estimate' : 'cost-confirmed';

  return (
    <div
      className={`economy-cost ${cssClass} ${affordable === false ? 'cost-unaffordable' : ''}`}
      data-ui-importance="critical"
    >
      <div className="cost-header">
        <span className="cost-title">{t(titleKey)}</span>
        {label && <span className="cost-label">{label}</span>}
      </div>
      <div className="cost-values">
        {/* Signal ë¹„ìš© */}
        <div className="cost-item">
          <CurrencyIcon type="signal" size={14} />
          <span className="cost-value">
            {type === 'estimate' && min && max
              ? isRange
                ? `${min.signal}~${max.signal}`
                : min.signal
              : cost
                ? cost.signal
                : '-'}
          </span>
        </div>
        {/* Shard ë¹„ìš© (0ë³´ë‹¤ í´ ë•Œë§Œ í‘œì‹œ) */}
        {((type === 'estimate' && max && max.memory_shard > 0) ||
          (type === 'confirmed' && cost && cost.memory_shard > 0)) && (
          <div className="cost-item">
            <span className="cost-separator">|</span>
            <CurrencyIcon type="shard" size={14} />
            <span className="cost-value">
              {type === 'estimate' && min && max
                ? isRange
                  ? `${min.memory_shard}~${max.memory_shard}`
                  : min.memory_shard
                : cost
                  ? cost.memory_shard
                  : '-'}
            </span>
          </div>
        )}
      </div>
      {affordable === false && (
        <div className="cost-warning">
          <span className="warning-text">{t('economy.insufficient_funds')}</span>
        </div>
      )}
    </div>
  );
}

// =============================================================================
// ì›ì¥(Ledger) í•­ëª© ì»´í¬ë„ŒíŠ¸
// =============================================================================

function LedgerItem({ entry }: { entry: LedgerEntry }) {
  const { t } = useTranslation();

  return (
    <div className="ledger-item">
      <div className="ledger-info">
        <span className="ledger-turn">T{entry.turnId}</span>
        <span className="ledger-reason">{entry.reason}</span>
      </div>
      <div className="ledger-values">
        <span className="ledger-cost">
          -{entry.cost.signal}
          {entry.cost.memory_shard > 0 && ` / -${entry.cost.memory_shard}`}
        </span>
        <span
          className="ledger-model"
          title={entry.modelLabel ? t(`economy.model_label.${entry.modelLabel}`) : undefined}
        >
          {entry.modelLabel?.charAt(0)}
        </span>
      </div>
    </div>
  );
}

// =============================================================================
// ì…€ë ‰í„° ì •ì˜ (ì»´í¬ë„ŒíŠ¸ ì™¸ë¶€ì—ì„œ ìƒì„±í•˜ì—¬ ì°¸ì¡° ìœ ì§€)
// =============================================================================

const selectHistory = selectRecentLedger(5);

// =============================================================================
// ë©”ì¸ Economy HUD ì»´í¬ë„ŒíŠ¸
// =============================================================================

export function EconomyHud({ compact = false, className = '' }: EconomyHudProps) {
  const { t } = useTranslation();

  // Store ìƒíƒœ
  const economy = useWorldStore((state) => state.economy);
  const costEstimate = useEconomyStore(selectCostEstimate);
  const lastCost = useEconomyStore(selectLastCost);
  const isBalanceLow = useEconomyStore(selectIsBalanceLow);
  const recentLedger = useEconomyStore(useShallow(selectHistory));

  // ì˜ˆìƒ ë¹„ìš© ê°ë‹¹ ê°€ëŠ¥ ì—¬ë¶€ ê³„ì‚°
  const estimateAffordability = useMemo(() => {
    if (!costEstimate) return null;
    return canAffordEstimate(economy, costEstimate);
  }, [economy, costEstimate]);

  // Compact ëª¨ë“œ (í—¤ë”ìš©): ì”ì•¡ë§Œ í‘œì‹œ
  if (compact) {
    return (
      <div
        className={`economy-hud economy-hud-compact ${className}`}
        role="status"
        aria-live="polite"
      >
        <BalanceDisplay balance={economy} isLow={isBalanceLow} />
      </div>
    );
  }

  // Full ëª¨ë“œ: ì”ì•¡ + ì˜ˆìƒ ë¹„ìš© + í™•ì • ë¹„ìš© + ì›ì¥ ì´ë ¥
  return (
    <div
      className={`economy-hud economy-hud-full ${className}`}
      role="region"
      aria-label={t('economy.hud_label')}
    >
      {/* í˜„ì¬ ì”ì•¡ */}
      <BalanceDisplay balance={economy} isLow={isBalanceLow} />

      {/* ì˜ˆìƒ ë¹„ìš© (ì¹´ë“œ ì„ íƒ/í˜¸ë²„ ì‹œ) */}
      {costEstimate && (
        <CostDisplay
          type="estimate"
          min={costEstimate.min}
          max={costEstimate.max}
          affordable={estimateAffordability?.affordable}
          label={costEstimate.label}
        />
      )}

      {/* ë§ˆì§€ë§‰ í™•ì • ë¹„ìš© (ì˜ˆìƒ ë¹„ìš©ì´ ì—†ì„ ë•Œë§Œ í‘œì‹œ) */}
      {!costEstimate && lastCost && (
        <CostDisplay
          type="confirmed"
          cost={lastCost.cost}
          label={lastCost.modelLabel ? t(`economy.model_label.${lastCost.modelLabel}`) : undefined}
        />
      )}

      {/* ëŒ€ì•ˆ ì•ˆë‚´ (ì”ì•¡ ë¶€ì¡± ì‹œ) */}
      {isBalanceLow && (
        <div className="economy-alternatives" data-ui-importance="critical">
          <div className="alternatives-header">
            <span className="alternatives-icon">ğŸ’¡</span>
            <span className="alternatives-title">{t('economy.alternatives_title')}</span>
          </div>
          <ul className="alternatives-list">
            <li>{t('economy.alternative_text_only')}</li>
            <li>{t('economy.alternative_low_quality')}</li>
          </ul>
        </div>
      )}

      {/* ì›ì¥ ì´ë ¥ (Ledger) */}
      <div className="economy-ledger">
        <div className="ledger-header">
          <span className="ledger-title">{t('economy.ledger_title')}</span>
        </div>
        {recentLedger.length > 0 ? (
          <div className="ledger-list">
            {recentLedger.map((entry) => (
              <LedgerItem key={`${entry.turnId}-${entry.timestamp}`} entry={entry} />
            ))}
          </div>
        ) : (
          <div className="ledger-empty">{t('economy.ledger_empty')}</div>
        )}
      </div>
    </div>
  );
}

// =============================================================================
// í—¤ë”ìš© ê°„ì†Œí™” ì»´í¬ë„ŒíŠ¸ (GameHeader í†µí•©ìš©)
// =============================================================================

export interface EconomyHudHeaderProps {
  signal: number;
  memoryShard: number;
  isLow?: boolean;
}

/**
 * GameHeaderì—ì„œ ì‚¬ìš©í•˜ëŠ” ê°„ì†Œí™”ëœ Economy HUD.
 * ê¸°ì¡´ GameHeaderì˜ economy-hudë¥¼ ëŒ€ì²´í•©ë‹ˆë‹¤.
 */
export function EconomyHudHeader({ signal, memoryShard, isLow }: EconomyHudHeaderProps) {
  const { t } = useTranslation();
  const costEstimate = useEconomyStore(selectCostEstimate);

  // ì˜ˆìƒ ë¹„ìš© ê°ë‹¹ ê°€ëŠ¥ ì—¬ë¶€
  const estimateAffordability = useMemo(() => {
    if (!costEstimate) return null;
    const balance = { signal, memory_shard: memoryShard };
    return canAffordEstimate(balance, costEstimate);
  }, [signal, memoryShard, costEstimate]);

  return (
    <div className={`economy-hud ${isLow ? 'economy-hud-low' : ''}`} data-ui-importance="critical">
      {/* ì”ì•¡ í‘œì‹œ */}
      <span className="icon-wrapper signal-icon" aria-label={t('economy.signal')}>
        <img
          src="/ui/icons/signal-24.png"
          alt=""
          aria-hidden="true"
          className="icon-img"
          onError={(e) => e.currentTarget.classList.add('hidden')}
        />
        <span className="icon-fallback">âš¡</span>
      </span>
      <span className="currency-value" data-testid="header-signal">
        {t('economy.signal')}: {signal}
      </span>
      <span className="icon-wrapper shard-icon" aria-label={t('economy.shard')}>
        <img
          src="/ui/icons/shard-24.png"
          alt=""
          aria-hidden="true"
          className="icon-img"
          onError={(e) => e.currentTarget.classList.add('hidden')}
        />
        <span className="icon-fallback">ğŸ’</span>
      </span>
      <span className="currency-value" data-testid="header-shard">
        {t('economy.shard')}: {memoryShard}
      </span>

      {/* ì˜ˆìƒ ë¹„ìš© ë¯¸ë‹ˆ í‘œì‹œ */}
      {costEstimate && (
        <span
          className={`economy-estimate-mini ${
            estimateAffordability?.affordable === false ? 'unaffordable' : ''
          }`}
          title={t('economy.estimated_cost')}
        >
          <span className="estimate-prefix">â†’</span>
          <span className="estimate-value">
            -{costEstimate.max.signal}
            {costEstimate.max.memory_shard > 0 && `/${costEstimate.max.memory_shard}`}
          </span>
        </span>
      )}

      {/* ì”ì•¡ ë¶€ì¡± ê²½ê³  ì•„ì´ì½˜ */}
      {isLow && (
        <span className="balance-warning-icon" title={t('economy.low_balance_warning')}>
          âš 
        </span>
      )}
    </div>
  );
}

export default EconomyHud;
</file>

<file path="frontend/src/components/InventoryPanel.test.tsx">
import { describe, it, expect, vi, beforeEach } from 'vitest';
import { render, screen, fireEvent } from '@testing-library/react';
import { InventoryPanel } from './InventoryPanel';
import { useInventoryStore } from '../stores/inventoryStore';

// i18next ëª¨í‚¹
vi.mock('react-i18next', () => ({
  useTranslation: () => ({
    t: (key: string) => {
      if (key === 'inventory.empty') return 'Inventory is empty';
      if (key === 'inventory.grid_label') return 'Inventory Grid';
      return key;
    },
  }),
}));

// dnd-kit ëª¨í‚¹ (í•„ìš”ì‹œ)
// dnd-kit hooks often return attributes/listeners/setNodeRef
// For basic rendering test, we might not need to mock them if they don't crash jsdom

describe('InventoryPanel Component', () => {
  beforeEach(() => {
    useInventoryStore.getState().reset();
  });

  it('ì•„ì´í…œì´ ì—†ì„ ë•Œ ë¹ˆ ìƒíƒœ ë©”ì‹œì§€ë¥¼ í‘œì‹œí•´ì•¼ í•œë‹¤', () => {
    render(<InventoryPanel />);
    expect(screen.getByText('Inventory is empty')).toBeInTheDocument();
  });

  it('ì•„ì´í…œì´ ìˆì„ ë•Œ ëª©ë¡ì„ ë Œë”ë§í•´ì•¼ í•œë‹¤', () => {
    const { addItems } = useInventoryStore.getState();
    addItems([
      { id: 'item1', name: 'Item 1', quantity: 1, icon: 'ğŸ' },
      { id: 'item2', name: 'Item 2', quantity: 3, icon: 'ğŸ—¡ï¸' },
    ]);

    render(<InventoryPanel />);

    expect(screen.getByText('Item 1')).toBeInTheDocument();
    expect(screen.getByText('ğŸ')).toBeInTheDocument();
    expect(screen.getByText('Item 2')).toBeInTheDocument();
    expect(screen.getByText('ğŸ—¡ï¸')).toBeInTheDocument();
    expect(screen.getByText('x3')).toBeInTheDocument();
  });

  it('ì•„ì´í…œ í´ë¦­ ì‹œ ì„ íƒë˜ì–´ì•¼ í•œë‹¤', () => {
    const { addItems } = useInventoryStore.getState();
    addItems([{ id: 'item1', name: 'Item 1', quantity: 1 }]);

    render(<InventoryPanel />);

    const item = screen.getByText('Item 1').closest('.inventory-item');
    expect(item).not.toHaveClass('selected');

    fireEvent.click(screen.getByText('Item 1'));

    expect(item).toHaveClass('selected');
    expect(useInventoryStore.getState().selectedItemId).toBe('item1');
  });

  it('disabled í”„ë¡œí”„ê°€ trueì¼ ë•Œ ì•„ì´í…œ í´ë¦­ì´ ë¬´ì‹œë˜ì–´ì•¼ í•œë‹¤', () => {
    const { addItems } = useInventoryStore.getState();
    addItems([{ id: 'item1', name: 'Item 1', quantity: 1 }]);

    render(<InventoryPanel disabled={true} />);

    fireEvent.click(screen.getByText('Item 1'));

    const item = screen.getByText('Item 1').closest('.inventory-item');
    expect(item).not.toHaveClass('selected');
    expect(useInventoryStore.getState().selectedItemId).toBeNull();
  });
});
</file>

<file path="frontend/src/components/MutationTimeline.test.tsx">
import { describe, it, expect, beforeEach, vi } from 'vitest';
import { render, screen } from '@testing-library/react';
import { MutationTimeline } from './MutationTimeline';
import { useWorldStore } from '../stores/worldStore';

vi.mock('react-i18next', () => ({
  useTranslation: () => ({
    t: (key: string, options?: Record<string, unknown>) => {
      if (options?.turn !== undefined) return `T${options.turn}`;
      if (options?.count !== undefined) return `${key} (count: ${options.count})`;
      return key;
    },
  }),
}));

describe('MutationTimeline (U-013)', () => {
  beforeEach(() => {
    useWorldStore.getState().reset();
  });

  it('ë³€í˜• ì´ë ¥ì´ ì—†ì„ ë•Œ ë¹ˆ ìƒíƒœë¥¼ í‘œì‹œí•´ì•¼ í•œë‹¤', () => {
    render(<MutationTimeline />);
    expect(screen.getByText('mutation.empty')).toBeInTheDocument();
  });

  it('ë³€í˜• ì´ë²¤íŠ¸ ëª©ë¡ì„ ìµœì‹ ìˆœìœ¼ë¡œ í‘œì‹œí•´ì•¼ í•œë‹¤', () => {
    useWorldStore.setState({
      mutationTimeline: [
        {
          turn: 2,
          ruleId: 'r2',
          type: 'modified',
          label: 'ìˆ˜ì •ëœ ê·œì¹™',
          timestamp: Date.now(),
        },
        {
          turn: 1,
          ruleId: 'r1',
          type: 'added',
          label: 'ìƒˆ ê·œì¹™',
          timestamp: Date.now() - 1000,
        },
      ],
    });

    render(<MutationTimeline />);
    expect(screen.getByText('mutation.timeline_title')).toBeInTheDocument();
    expect(screen.getAllByText('T2')).toHaveLength(1);
    expect(screen.getByText('ìˆ˜ì •ëœ ê·œì¹™')).toBeInTheDocument();
    expect(screen.getByText('mutation.type.modified')).toBeInTheDocument();

    expect(screen.getAllByText('T1')).toHaveLength(1);
    expect(screen.getByText('ìƒˆ ê·œì¹™')).toBeInTheDocument();
    expect(screen.getByText('mutation.type.added')).toBeInTheDocument();
  });

  it('ì´ë²¤íŠ¸ê°€ ë§ì„ ë•Œ "ë” ë³´ê¸°" í‘œì‹œë¥¼ í•´ì•¼ í•œë‹¤ (ìµœëŒ€ 10ê°œ ê¸°ì¤€)', () => {
    const manyEvents = Array.from({ length: 12 }, (_, i) => ({
      turn: i + 1,
      ruleId: `r${i}`,
      type: 'added' as const,
      label: `ê·œì¹™ ${i}`,
      timestamp: Date.now(),
    })).reverse(); // ìµœì‹ ìˆœ

    useWorldStore.setState({ mutationTimeline: manyEvents });

    const { container } = render(<MutationTimeline />);
    // 10ê°œë§Œ ë Œë”ë§ë¨
    expect(container.getElementsByClassName('timeline-event')).toHaveLength(10);
    // +2ê°œ ë” ë³´ê¸° í‘œì‹œ
    expect(screen.getByText('mutation.more_events (count: 2)')).toBeInTheDocument();
  });
});
</file>

<file path="frontend/src/components/MutationTimeline.tsx">
/**
 * Unknown World - Mutation Timeline (U-013)
 *
 * ê·œì¹™ ë³€í˜• ì´ë²¤íŠ¸ë¥¼ ì‹œê°„ìˆœìœ¼ë¡œ í‘œì‹œí•˜ëŠ” íƒ€ì„ë¼ì¸ ì»´í¬ë„ŒíŠ¸ì…ë‹ˆë‹¤.
 * "ì„¸ê³„ê°€ ë³€í–ˆë‹¤"ë¥¼ UIë¡œ ì²´ê°í•  ìˆ˜ ìˆê²Œ í•©ë‹ˆë‹¤.
 *
 * ì„¤ê³„ ì›ì¹™:
 *   - RULE-002: ì±„íŒ… UIê°€ ì•„ë‹Œ ê²Œì„ UIë¡œ ìƒì‹œ ë…¸ì¶œ
 *   - RULE-006: i18n ê¸°ë°˜ ë¬¸ìì—´ ê´€ë¦¬
 *   - PRD 6.4: Rule Mutation Timeline
 *   - Q1 ê²°ì •: Option B - ë³„ë„ Timeline ì»´í¬ë„ŒíŠ¸ (ê°€ë…ì„±/í™•ì¥ ìš©ì´)
 *
 * @module components/MutationTimeline
 */

import { useTranslation } from 'react-i18next';
import { useWorldStore, selectMutationTimeline } from '../stores/worldStore';
import type { MutationEvent } from '../stores/worldStore';

// =============================================================================
// ìƒìˆ˜
// =============================================================================

/** í‘œì‹œí•  ìµœëŒ€ ì´ë²¤íŠ¸ ìˆ˜ (MMPì—ì„œ ìŠ¤í¬ë¡¤/ìš”ì•½ ì „ëµ ì ìš© ì˜ˆì •) */
const MAX_DISPLAY_EVENTS = 10;

// =============================================================================
// í•˜ìœ„ ì»´í¬ë„ŒíŠ¸
// =============================================================================

interface TimelineEventProps {
  event: MutationEvent;
}

/**
 * ê°œë³„ íƒ€ì„ë¼ì¸ ì´ë²¤íŠ¸ ë Œë”ë§
 */
function TimelineEvent({ event }: TimelineEventProps) {
  const { t } = useTranslation();

  // ì´ë²¤íŠ¸ ìœ í˜•ë³„ ì•„ì´ì½˜
  const typeIcon = {
    added: 'â•',
    modified: 'ğŸ”„',
    removed: 'â–',
  }[event.type];

  // ì´ë²¤íŠ¸ ìœ í˜•ë³„ CSS í´ë˜ìŠ¤
  const typeClass = `timeline-event-${event.type}`;

  return (
    <div className={`timeline-event ${typeClass}`} data-event-type={event.type}>
      <div className="timeline-event-marker">
        <span className="timeline-event-icon" aria-hidden="true">
          {typeIcon}
        </span>
        <span className="timeline-event-turn">
          {t('mutation.turn_label', { turn: event.turn })}
        </span>
      </div>
      <div className="timeline-event-content">
        <span className="timeline-event-label">{event.label}</span>
        <span className="timeline-event-type">{t(`mutation.type.${event.type}`)}</span>
        {event.description && <p className="timeline-event-description">{event.description}</p>}
      </div>
    </div>
  );
}

// =============================================================================
// ë©”ì¸ ì»´í¬ë„ŒíŠ¸
// =============================================================================

/**
 * Mutation Timeline
 *
 * ê·œì¹™ ë³€í˜• ì´ë²¤íŠ¸ë¥¼ ì‹œê°„ìˆœ(ìµœì‹  ë¨¼ì €)ìœ¼ë¡œ í‘œì‹œí•©ë‹ˆë‹¤.
 * worldStoreì˜ mutationTimeline ìƒíƒœë¥¼ êµ¬ë…í•˜ì—¬ ì‹¤ì‹œê°„ ì—…ë°ì´íŠ¸ë©ë‹ˆë‹¤.
 */
export function MutationTimeline() {
  const { t } = useTranslation();
  const mutationTimeline = useWorldStore(selectMutationTimeline);

  // í‘œì‹œí•  ì´ë²¤íŠ¸ (ìµœëŒ€ ê°œìˆ˜ ì œí•œ)
  const displayEvents = mutationTimeline.slice(0, MAX_DISPLAY_EVENTS);
  const hasMore = mutationTimeline.length > MAX_DISPLAY_EVENTS;

  // ë¹ˆ ìƒíƒœ
  if (mutationTimeline.length === 0) {
    return (
      <div className="mutation-timeline-content timeline-empty" data-ui-importance="critical">
        <div className="timeline-empty-icon" aria-hidden="true">
          ğŸ“Š
        </div>
        <p className="timeline-empty-text">{t('mutation.empty')}</p>
      </div>
    );
  }

  return (
    <div className="mutation-timeline-content" data-ui-importance="critical">
      <div className="timeline-header">
        <span className="timeline-title">{t('mutation.timeline_title')}</span>
        <span className="timeline-count">
          {t('mutation.event_count', { count: mutationTimeline.length })}
        </span>
      </div>
      <div className="timeline-events" role="list" aria-label={t('mutation.timeline_title')}>
        {displayEvents.map((event, index) => (
          <TimelineEvent key={`${event.ruleId}-${event.turn}-${index}`} event={event} />
        ))}
      </div>
      {hasMore && (
        <div className="timeline-more">
          <span className="timeline-more-text">
            {t('mutation.more_events', { count: mutationTimeline.length - MAX_DISPLAY_EVENTS })}
          </span>
        </div>
      )}
    </div>
  );
}

export default MutationTimeline;
</file>

<file path="frontend/src/components/NarrativeFeed.tsx">
import { useEffect, useRef } from 'react';
import { useTranslation } from 'react-i18next';
import type { NarrativeEntry } from '../stores/worldStore';

interface NarrativeFeedProps {
  entries: NarrativeEntry[];
  streamingText: string;
}

export function NarrativeFeed({ entries, streamingText }: NarrativeFeedProps) {
  const { t } = useTranslation();
  const feedRef = useRef<HTMLDivElement>(null);

  // ìƒˆ ì—”íŠ¸ë¦¬ ì¶”ê°€ ì‹œ ìŠ¤í¬ë¡¤
  useEffect(() => {
    if (feedRef.current) {
      feedRef.current.scrollTop = feedRef.current.scrollHeight;
    }
  }, [entries, streamingText]);

  return (
    <div className="narrative-feed" ref={feedRef}>
      {entries.map((entry, index) => (
        <div key={`${entry.turn}-${index}`} className="narrative-entry">
          <span className="narrative-timestamp">
            {t('narrative.turn_label', { turn: entry.turn })}
          </span>
          <span className="narrative-text">{entry.text}</span>
        </div>
      ))}
      {streamingText && (
        <div className="narrative-entry streaming">
          <span className="narrative-timestamp">{t('narrative.streaming_label')}</span>
          <span className="narrative-text">{streamingText}</span>
          <span className="cursor-blink">â–Œ</span>
        </div>
      )}
    </div>
  );
}
</file>

<file path="frontend/src/components/QuestPanel.test.tsx">
import { describe, it, expect, beforeEach, vi } from 'vitest';
import { render, screen } from '@testing-library/react';
import { QuestPanel } from './QuestPanel';
import { useWorldStore } from '../stores/worldStore';

// i18next ëª¨í‚¹ (t í•¨ìˆ˜ê°€ í‚¤ë¥¼ ë°˜í™˜í•˜ë„ë¡)
vi.mock('react-i18next', () => ({
  useTranslation: () => ({
    t: (key: string) => key,
  }),
}));

describe('QuestPanel (U-013)', () => {
  beforeEach(() => {
    useWorldStore.getState().reset();
  });

  it('í€˜ìŠ¤íŠ¸ê°€ ì—†ì„ ë•Œ ë¹ˆ ìƒíƒœë¥¼ í‘œì‹œí•´ì•¼ í•œë‹¤', () => {
    render(<QuestPanel />);
    expect(screen.getByText('quest.empty')).toBeInTheDocument();
  });

  it('ì§„í–‰ ì¤‘ì¸ í€˜ìŠ¤íŠ¸ë¥¼ ëª©ë¡ì— í‘œì‹œí•´ì•¼ í•œë‹¤', () => {
    useWorldStore.setState({
      quests: [{ id: 'q1', label: 'ì•¡í‹°ë¸Œ í€˜ìŠ¤íŠ¸', is_completed: false }],
    });

    render(<QuestPanel />);
    expect(screen.getByText('quest.section.active')).toBeInTheDocument();
    expect(screen.getByText('ì•¡í‹°ë¸Œ í€˜ìŠ¤íŠ¸')).toBeInTheDocument();
    expect(screen.getByText('â˜')).toBeInTheDocument();
  });

  it('ì™„ë£Œëœ í€˜ìŠ¤íŠ¸ë¥¼ ëª©ë¡ì— í‘œì‹œí•´ì•¼ í•œë‹¤', () => {
    useWorldStore.setState({
      quests: [{ id: 'q2', label: 'ì™„ë£Œëœ í€˜ìŠ¤íŠ¸', is_completed: true }],
    });

    render(<QuestPanel />);
    expect(screen.getByText('quest.section.completed')).toBeInTheDocument();
    expect(screen.getByText('ì™„ë£Œëœ í€˜ìŠ¤íŠ¸')).toBeInTheDocument();
    expect(screen.getByText('â˜‘')).toBeInTheDocument();
    expect(screen.getByText('quest.completed')).toBeInTheDocument();
  });

  it('ì§„í–‰ ì¤‘ì¸ í€˜ìŠ¤íŠ¸ì™€ ì™„ë£Œëœ í€˜ìŠ¤íŠ¸ë¥¼ ëª¨ë‘ í‘œì‹œí•´ì•¼ í•œë‹¤', () => {
    useWorldStore.setState({
      quests: [
        { id: 'q1', label: 'ì•¡í‹°ë¸Œ', is_completed: false },
        { id: 'q2', label: 'ì™„ë£Œ', is_completed: true },
      ],
    });

    render(<QuestPanel />);
    expect(screen.getByText('ì•¡í‹°ë¸Œ')).toBeInTheDocument();
    expect(screen.getByText('ì™„ë£Œ')).toBeInTheDocument();
  });
});
</file>

<file path="frontend/src/components/QuestPanel.tsx">
/**
 * Unknown World - Quest Panel (U-013)
 *
 * í”Œë ˆì´ì–´ì˜ í˜„ì¬ ëª©í‘œ/ì„œë¸Œëª©í‘œë¥¼ ì²´í¬ë¦¬ìŠ¤íŠ¸ í˜•íƒœë¡œ í‘œì‹œí•©ë‹ˆë‹¤.
 *
 * ì„¤ê³„ ì›ì¹™:
 *   - RULE-002: ì±„íŒ… UIê°€ ì•„ë‹Œ ê²Œì„ UIë¡œ ìƒì‹œ ë…¸ì¶œ
 *   - RULE-006: i18n ê¸°ë°˜ ë¬¸ìì—´ ê´€ë¦¬
 *   - PRD 6.7: Quest/Objective Panel
 *
 * @module components/QuestPanel
 */

import { useTranslation } from 'react-i18next';
import { useWorldStore, selectQuests } from '../stores/worldStore';
import type { Quest } from '../schemas/turn';

// =============================================================================
// í•˜ìœ„ ì»´í¬ë„ŒíŠ¸
// =============================================================================

interface QuestItemProps {
  quest: Quest;
}

/**
 * ê°œë³„ í€˜ìŠ¤íŠ¸ ì•„ì´í…œ ë Œë”ë§
 */
function QuestItem({ quest }: QuestItemProps) {
  const { t } = useTranslation();

  return (
    <li
      className={`quest-item ${quest.is_completed ? 'quest-completed' : 'quest-active'}`}
      data-quest-id={quest.id}
    >
      <span className="quest-checkbox" aria-hidden="true">
        {quest.is_completed ? 'â˜‘' : 'â˜'}
      </span>
      <span className="quest-label">{quest.label}</span>
      {quest.is_completed && <span className="quest-status-badge">{t('quest.completed')}</span>}
    </li>
  );
}

// =============================================================================
// ë©”ì¸ ì»´í¬ë„ŒíŠ¸
// =============================================================================

/**
 * Quest Panel
 *
 * í˜„ì¬ ëª©í‘œ/ì„œë¸Œëª©í‘œë¥¼ ì²´í¬ë¦¬ìŠ¤íŠ¸ í˜•íƒœë¡œ í‘œì‹œí•©ë‹ˆë‹¤.
 * worldStoreì˜ quests ìƒíƒœë¥¼ êµ¬ë…í•˜ì—¬ ì‹¤ì‹œê°„ ì—…ë°ì´íŠ¸ë©ë‹ˆë‹¤.
 */
export function QuestPanel() {
  const { t } = useTranslation();
  const quests = useWorldStore(selectQuests);

  // ì§„í–‰ ì¤‘ / ì™„ë£Œ ë¶„ë¦¬
  const activeQuests = quests.filter((q) => !q.is_completed);
  const completedQuests = quests.filter((q) => q.is_completed);

  // ë¹ˆ ìƒíƒœ
  if (quests.length === 0) {
    return (
      <div className="quest-panel-content quest-empty" data-ui-importance="critical">
        <div className="quest-empty-icon" aria-hidden="true">
          ğŸ“‹
        </div>
        <p className="quest-empty-text">{t('quest.empty')}</p>
      </div>
    );
  }

  return (
    <div className="quest-panel-content" data-ui-importance="critical">
      {/* ì§„í–‰ ì¤‘ì¸ í€˜ìŠ¤íŠ¸ */}
      {activeQuests.length > 0 && (
        <div className="quest-section quest-section-active">
          <h4 className="quest-section-title">{t('quest.section.active')}</h4>
          <ul className="quest-list" role="list" aria-label={t('quest.section.active')}>
            {activeQuests.map((quest) => (
              <QuestItem key={quest.id} quest={quest} />
            ))}
          </ul>
        </div>
      )}

      {/* ì™„ë£Œëœ í€˜ìŠ¤íŠ¸ */}
      {completedQuests.length > 0 && (
        <div className="quest-section quest-section-completed">
          <h4 className="quest-section-title">{t('quest.section.completed')}</h4>
          <ul
            className="quest-list quest-list-completed"
            role="list"
            aria-label={t('quest.section.completed')}
          >
            {completedQuests.map((quest) => (
              <QuestItem key={quest.id} quest={quest} />
            ))}
          </ul>
        </div>
      )}
    </div>
  );
}

export default QuestPanel;
</file>

<file path="frontend/src/components/ResetButton.tsx">
/**
 * Unknown World - ë¦¬ì…‹ ë²„íŠ¼ ì»´í¬ë„ŒíŠ¸ (U-015[Mvp]).
 *
 * 1íšŒ í´ë¦­ìœ¼ë¡œ í˜„ì¬ í”„ë¡œí•„ì˜ ì´ˆê¸° ìƒíƒœë¡œ ë³µêµ¬í•˜ëŠ” ë²„íŠ¼ì…ë‹ˆë‹¤.
 * ë°ëª¨ ë°˜ë³µ ê°€ëŠ¥ì„±ì„ ë³´ì¥í•©ë‹ˆë‹¤.
 *
 * ì„¤ê³„ ì›ì¹™:
 *   - PRD 6.9: ì¦‰ì‹œ ë¦¬ì…‹ 1íšŒë¡œ ë°ëª¨ ë°˜ë³µ ê°€ëŠ¥
 *   - RULE-006: i18n í‚¤ ê¸°ë°˜ ë‹¤êµ­ì–´ ì§€ì›
 *
 * @module components/ResetButton
 */

import { useCallback, useState } from 'react';
import { useTranslation } from 'react-i18next';

// =============================================================================
// íƒ€ì… ì •ì˜
// =============================================================================

export interface ResetButtonProps {
  /** ë¦¬ì…‹ í´ë¦­ ì‹œ í˜¸ì¶œë˜ëŠ” ì½œë°± */
  onReset: () => void;
  /** ë¹„í™œì„±í™” ì—¬ë¶€ */
  disabled?: boolean;
  /** í™•ì¸ í•„ìš” ì—¬ë¶€ (ê¸°ë³¸: true) */
  requireConfirm?: boolean;
  /** ì¶”ê°€ í´ë˜ìŠ¤ëª… */
  className?: string;
  /** ì»´íŒ©íŠ¸ ëª¨ë“œ (ì•„ì´ì½˜ë§Œ í‘œì‹œ) */
  compact?: boolean;
}

// =============================================================================
// ì»´í¬ë„ŒíŠ¸
// =============================================================================

/**
 * ê²Œì„ ë¦¬ì…‹ ë²„íŠ¼.
 * í˜„ì¬ í”„ë¡œí•„ì˜ ì´ˆê¸° ìƒíƒœë¡œ ë³µêµ¬í•©ë‹ˆë‹¤.
 */
export function ResetButton({
  onReset,
  disabled = false,
  requireConfirm = true,
  className = '',
  compact = false,
}: ResetButtonProps) {
  const { t } = useTranslation();
  const [isConfirming, setIsConfirming] = useState(false);

  const handleClick = useCallback(() => {
    if (requireConfirm && !isConfirming) {
      // í™•ì¸ ëª¨ë“œë¡œ ì „í™˜
      setIsConfirming(true);
      // 3ì´ˆ í›„ ìë™ ì·¨ì†Œ
      setTimeout(() => setIsConfirming(false), 3000);
      return;
    }

    // ë¦¬ì…‹ ì‹¤í–‰
    onReset();
    setIsConfirming(false);
  }, [onReset, requireConfirm, isConfirming]);

  const handleCancel = useCallback(() => {
    setIsConfirming(false);
  }, []);

  const buttonText = isConfirming ? t('reset.confirm') : compact ? '' : t('reset.button');

  const buttonAriaLabel = isConfirming ? t('reset.confirm') : t('reset.button');

  return (
    <div className={`reset-button-wrapper ${className}`.trim()}>
      <button
        type="button"
        className={`reset-button ${isConfirming ? 'confirming' : ''} ${compact ? 'compact' : ''}`}
        onClick={handleClick}
        disabled={disabled}
        aria-label={buttonAriaLabel}
        title={t('reset.tooltip')}
      >
        <span className="reset-icon" aria-hidden="true">
          ğŸ”„
        </span>
        {buttonText && <span className="reset-text">{buttonText}</span>}
      </button>

      {isConfirming && requireConfirm && (
        <button
          type="button"
          className="reset-cancel-button"
          onClick={handleCancel}
          aria-label={t('reset.cancel')}
        >
          âœ•
        </button>
      )}
    </div>
  );
}

// =============================================================================
// í”„ë¡œí•„ ë³€ê²½ ë²„íŠ¼ (ë³„ë„ ì»´í¬ë„ŒíŠ¸)
// =============================================================================

export interface ChangeProfileButtonProps {
  /** í´ë¦­ ì‹œ í˜¸ì¶œë˜ëŠ” ì½œë°± */
  onClick: () => void;
  /** ë¹„í™œì„±í™” ì—¬ë¶€ */
  disabled?: boolean;
  /** ì¶”ê°€ í´ë˜ìŠ¤ëª… */
  className?: string;
}

/**
 * í”„ë¡œí•„ ë³€ê²½ ë²„íŠ¼.
 * í´ë¦­ ì‹œ í”„ë¡œí•„ ì„ íƒ í™”ë©´ìœ¼ë¡œ ì´ë™í•©ë‹ˆë‹¤.
 */
export function ChangeProfileButton({
  onClick,
  disabled = false,
  className = '',
}: ChangeProfileButtonProps) {
  const { t } = useTranslation();

  return (
    <button
      type="button"
      className={`change-profile-button ${className}`.trim()}
      onClick={onClick}
      disabled={disabled}
      aria-label={t('profile.change')}
      title={t('profile.change_tooltip')}
    >
      <span className="change-profile-icon" aria-hidden="true">
        ğŸ‘¤
      </span>
      <span className="change-profile-text">{t('profile.change')}</span>
    </button>
  );
}
</file>

<file path="frontend/src/components/RuleBoard.test.tsx">
import { describe, it, expect, beforeEach, vi } from 'vitest';
import { render, screen } from '@testing-library/react';
import { RuleBoard } from './RuleBoard';
import { useWorldStore } from '../stores/worldStore';

vi.mock('react-i18next', () => ({
  useTranslation: () => ({
    t: (key: string, options?: Record<string, unknown>) => {
      if (options?.count !== undefined) return `${key} (count: ${options.count})`;
      return key;
    },
  }),
}));

describe('RuleBoard (U-013)', () => {
  beforeEach(() => {
    useWorldStore.getState().reset();
  });

  it('ê·œì¹™ì´ ì—†ì„ ë•Œ ë¹ˆ ìƒíƒœë¥¼ í‘œì‹œí•´ì•¼ í•œë‹¤', () => {
    render(<RuleBoard />);
    expect(screen.getByText('rule_board.empty')).toBeInTheDocument();
  });

  it('í™œì„± ê·œì¹™ ëª©ë¡ì„ í‘œì‹œí•´ì•¼ í•œë‹¤', () => {
    useWorldStore.setState({
      activeRules: [
        { id: 'r1', label: 'ì¤‘ë ¥', description: 'ë–¨ì–´ì§„ë‹¤' },
        { id: 'r2', label: 'ì‚°ì†Œ', description: 'í•„ìš”í•˜ë‹¤' },
      ],
    });

    render(<RuleBoard />);
    expect(screen.getByText('rule_board.active_count (count: 2)')).toBeInTheDocument();
    expect(screen.getByText('ì¤‘ë ¥')).toBeInTheDocument();
    expect(screen.getByText('ë–¨ì–´ì§„ë‹¤')).toBeInTheDocument();
    expect(screen.getByText('ì‚°ì†Œ')).toBeInTheDocument();
  });
});
</file>

<file path="frontend/src/components/RuleBoard.tsx">
/**
 * Unknown World - Rule Board (U-013)
 *
 * í˜„ì¬ ì„¸ê³„ì— ì ìš© ì¤‘ì¸ ê·œì¹™/ë¬¼ë¦¬ ë²•ì¹™ì„ "ë£° ì¹´ë“œ"ë¡œ í‘œì‹œí•©ë‹ˆë‹¤.
 *
 * ì„¤ê³„ ì›ì¹™:
 *   - RULE-002: ì±„íŒ… UIê°€ ì•„ë‹Œ ê²Œì„ UIë¡œ ìƒì‹œ ë…¸ì¶œ
 *   - RULE-006: i18n ê¸°ë°˜ ë¬¸ìì—´ ê´€ë¦¬
 *   - PRD 6.4/6.7: Rule Mutation + Rule Board
 *
 * @module components/RuleBoard
 */

import { useTranslation } from 'react-i18next';
import { useWorldStore, selectActiveRules } from '../stores/worldStore';
import type { WorldRule } from '../schemas/turn';

// =============================================================================
// í•˜ìœ„ ì»´í¬ë„ŒíŠ¸
// =============================================================================

interface RuleCardProps {
  rule: WorldRule;
}

/**
 * ê°œë³„ ë£° ì¹´ë“œ ë Œë”ë§
 */
function RuleCard({ rule }: RuleCardProps) {
  return (
    <div className="rule-card" data-rule-id={rule.id}>
      <div className="rule-card-header">
        <span className="rule-card-icon" aria-hidden="true">
          âš™
        </span>
        <span className="rule-card-label">{rule.label}</span>
      </div>
      {rule.description && <p className="rule-card-description">{rule.description}</p>}
    </div>
  );
}

// =============================================================================
// ë©”ì¸ ì»´í¬ë„ŒíŠ¸
// =============================================================================

/**
 * Rule Board
 *
 * í˜„ì¬ ì„¸ê³„ì— ì ìš© ì¤‘ì¸ ê·œì¹™ì„ ì¹´ë“œ í˜•íƒœë¡œ í‘œì‹œí•©ë‹ˆë‹¤.
 * worldStoreì˜ activeRules ìƒíƒœë¥¼ êµ¬ë…í•˜ì—¬ ì‹¤ì‹œê°„ ì—…ë°ì´íŠ¸ë©ë‹ˆë‹¤.
 */
export function RuleBoard() {
  const { t } = useTranslation();
  const activeRules = useWorldStore(selectActiveRules);

  // ë¹ˆ ìƒíƒœ
  if (activeRules.length === 0) {
    return (
      <div className="rule-board-content rule-board-empty" data-ui-importance="critical">
        <div className="rule-board-empty-icon" aria-hidden="true">
          ğŸ“œ
        </div>
        <p className="rule-board-empty-text">{t('rule_board.empty')}</p>
      </div>
    );
  }

  return (
    <div className="rule-board-content" data-ui-importance="critical">
      <div className="rule-board-header">
        <span className="rule-board-count">
          {t('rule_board.active_count', { count: activeRules.length })}
        </span>
      </div>
      <div className="rule-card-list">
        {activeRules.map((rule) => (
          <RuleCard key={rule.id} rule={rule} />
        ))}
      </div>
    </div>
  );
}

export default RuleBoard;
</file>

<file path="frontend/src/components/SceneCanvas.test.tsx">
import { describe, it, expect } from 'vitest';
import { SCENE_PLACEHOLDERS } from './SceneCanvas';

describe('SCENE_PLACEHOLDERS', () => {
  it('should have all required statuses', () => {
    const statuses = ['default', 'loading', 'offline', 'blocked', 'low_signal'];
    statuses.forEach((status) => {
      expect(SCENE_PLACEHOLDERS).toHaveProperty(status);
    });
  });

  it('should have correct image paths', () => {
    expect(SCENE_PLACEHOLDERS.default.imagePath).toBe(
      '/ui/placeholders/scene-placeholder-default.png',
    );
    expect(SCENE_PLACEHOLDERS.loading.imagePath).toBe('/ui/placeholders/scene-loading.webp');
    expect(SCENE_PLACEHOLDERS.offline.imagePath).toBe('/ui/placeholders/scene-offline.webp');
    expect(SCENE_PLACEHOLDERS.blocked.imagePath).toBe('/ui/placeholders/scene-blocked.webp');
    expect(SCENE_PLACEHOLDERS.low_signal.imagePath).toBe('/ui/placeholders/scene-low-signal.webp');
  });

  it('should have correct i18n label keys', () => {
    expect(SCENE_PLACEHOLDERS.default.labelKey).toBe('scene.status.default');
    expect(SCENE_PLACEHOLDERS.loading.labelKey).toBe('scene.status.loading');
    expect(SCENE_PLACEHOLDERS.offline.labelKey).toBe('scene.status.offline');
    expect(SCENE_PLACEHOLDERS.blocked.labelKey).toBe('scene.status.blocked');
    expect(SCENE_PLACEHOLDERS.low_signal.labelKey).toBe('scene.status.low_signal');
  });
});
</file>

<file path="frontend/src/components/UIControls.tsx">
import { useTranslation } from 'react-i18next';
import { UI_SCALES, type UIScale } from '../stores/uiPrefsStore';

interface UIControlsProps {
  uiScale: UIScale;
  onIncreaseScale: () => void;
  onDecreaseScale: () => void;
}

export function UIControls({ uiScale, onIncreaseScale, onDecreaseScale }: UIControlsProps) {
  const { t } = useTranslation();
  const isMinScale = uiScale === UI_SCALES[0];
  const isMaxScale = uiScale === UI_SCALES[UI_SCALES.length - 1];

  return (
    <div className="ui-controls" role="group" aria-label={t('ui.scale_label')}>
      {/* UI ìŠ¤ì¼€ì¼ ì¡°ì ˆ */}
      <button
        type="button"
        className="ui-scale-btn"
        onClick={onDecreaseScale}
        disabled={isMinScale}
        aria-label={t('ui.scale_decrease')}
        title={`${t('ui.scale_decrease')} (A-)`}
      >
        A-
      </button>
      <span className="ui-scale-display" aria-live="polite">
        {Math.round(uiScale * 100)}%
      </span>
      <button
        type="button"
        className="ui-scale-btn"
        onClick={onIncreaseScale}
        disabled={isMaxScale}
        aria-label={t('ui.scale_increase')}
        title={`${t('ui.scale_increase')} (A+)`}
      >
        A+
      </button>
    </div>
  );
}
</file>

<file path="frontend/src/data/demoProfiles.test.ts">
import { describe, it, expect, vi } from 'vitest';
import { PROFILE_EXPLORER, createSaveGameFromProfile, findProfileById } from './demoProfiles';
import { SAVEGAME_VERSION } from '../save/saveGame';

describe('demoProfiles (U-015[Mvp])', () => {
  const mockT = vi.fn((key: string) => `translated-${key}`);

  it('findProfileByIdëŠ” ì˜¬ë°”ë¥¸ í”„ë¡œí•„ì„ ë°˜í™˜í•´ì•¼ í•œë‹¤', () => {
    const profile = findProfileById('explorer');
    expect(profile).toBeDefined();
    expect(profile?.id).toBe('explorer');
    expect(profile?.icon).toBe('ğŸ§­');
  });

  it('ì¡´ì¬í•˜ì§€ ì•ŠëŠ” IDì— ëŒ€í•´ findProfileByIdëŠ” undefinedë¥¼ ë°˜í™˜í•´ì•¼ í•œë‹¤', () => {
    const profile = findProfileById('non-existent');
    expect(profile).toBeUndefined();
  });

  it('createSaveGameFromProfileì€ í”„ë¡œí•„ ì´ˆê¸° ìƒíƒœë¥¼ SaveGameìœ¼ë¡œ ì˜¬ë°”ë¥´ê²Œ ë³€í™˜í•´ì•¼ í•œë‹¤', () => {
    const saveGame = createSaveGameFromProfile(PROFILE_EXPLORER, 'ko-KR', mockT);

    // ê¸°ë³¸ ë©”íƒ€ë°ì´í„°
    expect(saveGame.version).toBe(SAVEGAME_VERSION);
    expect(saveGame.profileId).toBe('explorer');
    expect(saveGame.language).toBe('ko-KR');
    expect(saveGame.seed).toContain('demo-explorer-');

    // ê²½ì œ ìƒíƒœ
    expect(saveGame.economy.signal).toBe(PROFILE_EXPLORER.initialState.economy.signal);
    expect(saveGame.economy.memory_shard).toBe(PROFILE_EXPLORER.initialState.economy.memory_shard);

    // ì¸ë²¤í† ë¦¬ (ë²ˆì—­ ì ìš© í™•ì¸)
    expect(saveGame.inventory).toHaveLength(PROFILE_EXPLORER.initialState.inventoryDefs.length);
    expect(saveGame.inventory[0].name).toBe(
      `translated-${PROFILE_EXPLORER.initialState.inventoryDefs[0].nameKey}`,
    );

    // í€˜ìŠ¤íŠ¸
    expect(saveGame.quests).toHaveLength(PROFILE_EXPLORER.initialState.questDefs.length);
    expect(saveGame.quests[0].label).toBe(
      `translated-${PROFILE_EXPLORER.initialState.questDefs[0].labelKey}`,
    );

    // ê·œì¹™ ë° íƒ€ì„ë¼ì¸
    expect(saveGame.activeRules).toHaveLength(PROFILE_EXPLORER.initialState.ruleDefs.length);
    expect(saveGame.mutationTimeline).toHaveLength(PROFILE_EXPLORER.initialState.ruleDefs.length);
    expect(saveGame.mutationTimeline[0].type).toBe('added');

    // ë‚´ëŸ¬í‹°ë¸Œ (í™˜ì˜ ë©”ì‹œì§€)
    expect(saveGame.narrativeHistory).toHaveLength(1);
    expect(saveGame.narrativeHistory[0].turn).toBe(0);
    expect(saveGame.narrativeHistory[0].text).toBe(
      `translated-${PROFILE_EXPLORER.initialState.welcomeMessageKey}`,
    );

    // Scene Objects
    expect(saveGame.sceneObjects).toHaveLength(
      PROFILE_EXPLORER.initialState.sceneObjectDefs.length,
    );
    expect(saveGame.sceneObjects[0].box_2d).toEqual(
      PROFILE_EXPLORER.initialState.sceneObjectDefs[0].box_2d,
    );
  });
});
</file>

<file path="frontend/src/i18n-scenario.test.ts">
import { describe, it, expect } from 'vitest';
import i18next from './i18n';

describe('i18n Integration Scenarios (U-039)', () => {
  it('Scenario D: should have correct i18next options', () => {
    expect(i18next.options.supportedLngs).toContain('ko-KR');
    expect(i18next.options.supportedLngs).toContain('en-US');
    expect(i18next.options.lng).toBe('ko-KR');
    expect(i18next.options.fallbackLng).toContain('en-US');
  });

  it('Scenario A: should translate to Korean by default', () => {
    // Economy labels
    expect(i18next.t('economy.signal')).toBe('Signal');
    expect(i18next.t('economy.shard')).toBe('Shard');

    // Panel titles
    expect(i18next.t('panel.inventory.title')).toBe('Inventory');
    expect(i18next.t('panel.quest.title')).toBe('Quest');

    // Agent Console
    expect(i18next.t('agent.console.queue')).toBe('ëŒ€ê¸°ì—´');
    expect(i18next.t('agent.console.status.idle')).toBe('ëŒ€ê¸° ì¤‘');

    // Connection
    expect(i18next.t('connection.online')).toBe('ì˜¨ë¼ì¸');

    // UI
    expect(i18next.t('ui.command_placeholder')).toBe('ëª…ë ¹ì„ ì…ë ¥í•˜ì„¸ìš”...');
    expect(i18next.t('ui.execute')).toBe('ì‹¤í–‰');
  });

  it('Scenario B: should switch to English and back to Korean', async () => {
    // Switch to English
    await i18next.changeLanguage('en-US');
    expect(i18next.resolvedLanguage).toBe('en-US');

    // Check English translations
    expect(i18next.t('agent.console.queue')).toBe('Queue');
    expect(i18next.t('agent.console.status.idle')).toBe('IDLE');
    expect(i18next.t('connection.online')).toBe('ONLINE');
    expect(i18next.t('ui.command_placeholder')).toBe('Enter command...');
    expect(i18next.t('ui.execute')).toBe('EXECUTE');

    // Switch back to Korean
    await i18next.changeLanguage('ko-KR');
    expect(i18next.resolvedLanguage).toBe('ko-KR');
    expect(i18next.t('agent.console.queue')).toBe('ëŒ€ê¸°ì—´');
    expect(i18next.t('connection.online')).toBe('ì˜¨ë¼ì¸');
  });
});
</file>

<file path="frontend/src/save/constants.ts">
/**
 * Unknown World - SaveGame/ì„¸ì…˜ ê´€ë ¨ ìƒìˆ˜ SSOT (RU-004-Q5).
 *
 * ì •ì±…/ì´ˆê¸°ê°’ì„ í•œ ê³³ìœ¼ë¡œ ëª¨ì•„ ë³€ê²½ ì‹œ ëˆ„ë½ ìœ„í—˜ì„ ë°©ì§€í•©ë‹ˆë‹¤.
 * ëª¨ë“  SaveGame/ì„¸ì…˜ ê´€ë ¨ ìƒìˆ˜ëŠ” ì´ íŒŒì¼ì—ì„œ ê´€ë¦¬í•©ë‹ˆë‹¤.
 *
 * ì„¤ê³„ ì›ì¹™:
 *   - RU-004-Q5: í•˜ë“œì½”ë”© ì •ë¦¬ - ìƒìˆ˜ ì¤‘ì•™í™”
 *   - RULE-010: DB ë„ì… ê¸ˆì§€, SaveGame JSON ì§ë ¬í™” ê¸°ë°˜
 *   - í–¥í›„ í™•ì¥: U-026(ë¦¬í”Œë ˆì´), U-025(ì—”ë”© ë¦¬í¬íŠ¸) í˜¸í™˜
 *
 * @module save/constants
 */

// =============================================================================
// SaveGame ë²„ì „ ê´€ë¦¬
// =============================================================================

/**
 * í˜„ì¬ SaveGame ìŠ¤í‚¤ë§ˆ ë²„ì „.
 *
 * ë²„ì „ ë³€ê²½ ì‹œ `migrateSaveGame()`ì— ë§ˆì´ê·¸ë ˆì´ì…˜ ë¡œì§ì„ ì¶”ê°€í•´ì•¼ í•©ë‹ˆë‹¤.
 * ë²„ì „ í˜•ì‹: semver (major.minor.patch)
 *
 * @see saveGame.ts#migrateSaveGame
 */
export const SAVEGAME_VERSION = '1.0.0' as const;

/**
 * ì§€ì›í•˜ëŠ” SaveGame ë²„ì „ ëª©ë¡.
 *
 * ë§ˆì´ê·¸ë ˆì´ì…˜ ê°€ëŠ¥í•œ ì´ì „ ë²„ì „ë“¤ì„ í¬í•¨í•©ë‹ˆë‹¤.
 * ì´ ëª©ë¡ì— ì—†ëŠ” ë²„ì „ì€ ë§ˆì´ê·¸ë ˆì´ì…˜ ë¶ˆê°€ë¡œ ì²˜ë¦¬ë©ë‹ˆë‹¤.
 */
export const SUPPORTED_SAVEGAME_VERSIONS: readonly string[] = ['1.0.0'] as const;

// =============================================================================
// localStorage í‚¤ (Storage Keys)
// =============================================================================

/**
 * SaveGame ì €ì¥ í‚¤.
 *
 * localStorageì—ì„œ ì„¸ì´ë¸Œ ë°ì´í„°ë¥¼ ì €ì¥/ë¡œë“œí•  ë•Œ ì‚¬ìš©í•©ë‹ˆë‹¤.
 * ì´ í‚¤ë¥¼ ë³€ê²½í•˜ë©´ ê¸°ì¡´ ì„¸ì´ë¸Œ ë°ì´í„°ê°€ ë¬´íš¨í™”ë©ë‹ˆë‹¤.
 */
export const SAVEGAME_STORAGE_KEY = 'unknown_world_savegame' as const;

/**
 * í˜„ì¬ ì„ íƒëœ í”„ë¡œí•„ ID ì €ì¥ í‚¤.
 *
 * localStorageì—ì„œ í˜„ì¬ í”„ë¡œí•„ IDë¥¼ ì €ì¥/ë¡œë“œí•  ë•Œ ì‚¬ìš©í•©ë‹ˆë‹¤.
 * SaveGame.profileIdê°€ SSOTì´ë©°, ì´ í‚¤ëŠ” í´ë°±/í˜¸í™˜ì„±ìš©ì…ë‹ˆë‹¤.
 *
 * @see sessionLifecycle.ts#getInitialProfileId
 */
export const CURRENT_PROFILE_KEY = 'unknown_world_current_profile' as const;

// =============================================================================
// Seed ìƒì„± ì •ì±…
// =============================================================================

/**
 * ë°ëª¨ seed ì ‘ë‘ì‚¬.
 *
 * ë°ëª¨ í”„ë¡œí•„ì—ì„œ ìƒì„±ë˜ëŠ” seedì˜ ì ‘ë‘ì‚¬ì…ë‹ˆë‹¤.
 * seed í˜•ì‹: `{DEMO_SEED_PREFIX}-{profileId}-{timestamp}`
 *
 * @example 'demo-narrator-1706000000000'
 */
export const DEMO_SEED_PREFIX = 'demo' as const;

/**
 * Seed ìƒì„± ì •ì±… (ë¬¸ì„œí™”ìš© ì£¼ì„).
 *
 * ## í˜„ì¬ ì •ì±…: now ê¸°ë°˜ seed (ì„¸ì…˜ ë‹¤ì–‘ì„± ì¤‘ì‹œ)
 *
 * í”„ë¡œí•„ ì‹œì‘ ì‹œë§ˆë‹¤ ìƒˆë¡œìš´ seedê°€ ìƒì„±ë©ë‹ˆë‹¤.
 * - ì¥ì : ë§¤ ì„¸ì…˜ë§ˆë‹¤ ë‹¤ë¥¸ ì´ˆê¸° ìƒíƒœ/ì´ë²¤íŠ¸ ê°€ëŠ¥
 * - ë‹¨ì : ë°ëª¨ ë°˜ë³µì„±(ë™ì¼ ì‹œì‘) ë³´ì¥ ì–´ë ¤ì›€
 *
 * ## ëŒ€ì•ˆ: ê³ ì • seed (ë°ëª¨ ë°˜ë³µì„± ì¤‘ì‹œ)
 *
 * í”„ë¡œí•„ IDë§Œìœ¼ë¡œ seedë¥¼ ìƒì„±í•©ë‹ˆë‹¤.
 * - ì¥ì : ë™ì¼ í”„ë¡œí•„ì€ í•­ìƒ ë™ì¼í•œ ì‹œì‘ ìƒíƒœ
 * - ë‹¨ì : ì„¸ì…˜ ë‹¤ì–‘ì„± ë¶€ì¡±
 *
 * ## í–¥í›„ í™•ì¥ (U-026: ë¦¬í”Œë ˆì´)
 *
 * seedë¥¼ SaveGameì— ì €ì¥í•˜ì—¬ ë¦¬í”Œë ˆì´ ì‹œ ë™ì¼ ê²°ê³¼ ì¬í˜„ ê°€ëŠ¥.
 * ì—”ë”© ë¦¬í¬íŠ¸(U-025)ì—ì„œë„ seedë¥¼ ê¸°ë¡í•˜ì—¬ ê²°ê³¼ ë¶„ì„ì— í™œìš©.
 *
 * @see demoProfiles.ts#profileToSaveGameInput
 */
export const SEED_POLICY = {
  /** í˜„ì¬ ì ìš© ì¤‘ì¸ ì •ì±… */
  current: 'timestamp' as const,
  /** ê°€ëŠ¥í•œ ì •ì±… ëª©ë¡ */
  options: ['timestamp', 'fixed', 'hybrid'] as const,
} as const;

/**
 * Seedë¥¼ ìƒì„±í•©ë‹ˆë‹¤.
 *
 * í˜„ì¬ ì •ì±…(now ê¸°ë°˜)ì— ë”°ë¼ seed ë¬¸ìì—´ì„ ìƒì„±í•©ë‹ˆë‹¤.
 *
 * @param profileId - í”„ë¡œí•„ ID
 * @returns seed ë¬¸ìì—´
 */
export function generateDemoSeed(profileId: string): string {
  const now = Date.now();
  return `${DEMO_SEED_PREFIX}-${profileId}-${now}`;
}

// =============================================================================
// Economy ì •ì±… ìƒìˆ˜
// =============================================================================

/**
 * ì”ì•¡ ë¶€ì¡± ê²½ê³  ì„ê³„ê°’ (Signal ê¸°ì¤€).
 *
 * Signal ì”ì•¡ì´ ì´ ê°’ ë¯¸ë§Œì´ë©´ isBalanceLowê°€ trueê°€ ë©ë‹ˆë‹¤.
 * HUDì—ì„œ ê²½ê³  í‘œì‹œ ë° ëŒ€ì²´ í–‰ë™ ì œì•ˆì— ì‚¬ìš©ë©ë‹ˆë‹¤.
 *
 * @see economyStore.ts#updateBalanceLowStatus
 */
export const LOW_BALANCE_THRESHOLD = 10 as const;

/**
 * ì›ì¥(Ledger) ìµœëŒ€ ë³´ê´€ ê°œìˆ˜.
 *
 * ìµœê·¼ Nê°œì˜ í„´ ì›ì¥ë§Œ ë³´ê´€í•©ë‹ˆë‹¤ (ë©”ëª¨ë¦¬ ìµœì í™”).
 * ì„¸ì…˜ ë‚´ì—ì„œë§Œ ìœ ì§€ë˜ë©°, SaveGameì— í•¨ê»˜ ì €ì¥ë©ë‹ˆë‹¤.
 *
 * @see economyStore.ts#addLedgerEntry
 */
export const LEDGER_MAX_ENTRIES = 20 as const;

// =============================================================================
// ì´ˆê¸°ê°’ ì •ì±… (Placeholder vs ì£¼ì…)
// =============================================================================

/**
 * World/Economy ì´ˆê¸°ê°’ ì •ì±… (ë¬¸ì„œí™”ìš© ì£¼ì„).
 *
 * ## ì„¤ê³„ ì›ì¹™
 *
 * Storeì˜ createInitialState()ì—ì„œ ì •ì˜í•˜ëŠ” economy ë“±ì˜ ê°’ì€
 * **"í”Œë ˆì´ ì „ placeholder"**ë¡œ ì·¨ê¸‰í•©ë‹ˆë‹¤.
 *
 * ì‹¤ì œ ê²Œì„ ì‹œì‘ ê°’ì€ í•­ìƒ ë‹¤ìŒ ì¤‘ í•˜ë‚˜ì—ì„œ ì£¼ì…ë©ë‹ˆë‹¤:
 * 1. í”„ë¡œí•„ ì´ˆê¸° SaveGame (startSessionFromProfile)
 * 2. ì €ì¥ëœ SaveGame ë³µì› (continueSession)
 *
 * ## Placeholder ê°’ì˜ ì˜ë¯¸
 *
 * - worldStore.economy: { signal: 100, memory_shard: 5 }
 *   â†’ playing ì§„ì… ì „ profile_select ìƒíƒœì—ì„œëŠ” HUDê°€ ë…¸ì¶œë˜ì§€ ì•ŠìŒ
 *   â†’ ë”°ë¼ì„œ ì´ ê°’ì´ í™”ë©´ì— í‘œì‹œë  ì¼ì€ ì—†ìŒ
 *
 * ## í–¥í›„ ê°œì„  (S2 ì„ í–‰ í•„ìš”)
 *
 * S2(ì˜ëª»ëœ playing ì§„ì…)ê°€ í•´ê²°ë˜ë©´:
 * - economy: null ê°™ì€ "ë¯¸ì´ˆê¸°í™” ìƒíƒœ"ë¡œ ë³€ê²½ ê°€ëŠ¥
 * - playing ì§„ì… ì „ì— ë°˜ë“œì‹œ í”„ë¡œí•„/ì„¸ì´ë¸Œ ì£¼ì…ì„ ê°•ì œ
 * - "placeholderê°€ í™”ë©´ì— ë³´ì´ëŠ”" ë¬¸ì œë¥¼ ì›ì²œ ì°¨ë‹¨
 *
 * @see worldStore.ts#createInitialState
 * @see sessionLifecycle.ts
 */
export const INITIAL_VALUE_POLICY = {
  description: 'Placeholder values for pre-play state',
  worldEconomy: {
    signal: 100,
    memory_shard: 5,
  },
} as const;

// =============================================================================
// ë°ëª¨ í”„ë¡œí•„ ê¸°ë³¸ ì¬í™” ë²”ìœ„ (ì°¸ê³ ìš©)
// =============================================================================

/**
 * ë°ëª¨ í”„ë¡œí•„ ì¬í™” ë²”ìœ„ ì°¸ê³  (ë¬¸ì„œí™”ìš©).
 *
 * ê° í”„ë¡œí•„ì˜ ì´ˆê¸° ì¬í™”ëŠ” demoProfiles.tsì—ì„œ ì§ì ‘ ì •ì˜í•©ë‹ˆë‹¤.
 * ì´ ìƒìˆ˜ëŠ” "ì •ì±… ë²”ìœ„"ë¥¼ ë¬¸ì„œí™”í•˜ê¸° ìœ„í•œ ì°¸ê³ ìš©ì…ë‹ˆë‹¤.
 *
 * - Narrator: í’ë¶€í•œ ì¬í™” (ë‹¤ì–‘í•œ ì„ íƒì§€ íƒìƒ‰)
 * - Explorer: ì ë‹¹í•œ ì¬í™” (ê· í˜• ì¡íŒ í”Œë ˆì´)
 * - Tech: ì œí•œëœ ì¬í™” (íš¨ìœ¨ì  ì „ëµ í•„ìš”)
 *
 * @see demoProfiles.ts
 */
export const DEMO_PROFILE_ECONOMY_REFERENCE = {
  narrator: { signal: 200, memory_shard: 10 },
  explorer: { signal: 150, memory_shard: 5 },
  tech: { signal: 80, memory_shard: 15 },
} as const;
</file>

<file path="frontend/src/save/saveGame.test.ts">
import { describe, it, expect, beforeEach, vi } from 'vitest';
import {
  SaveGameSchema,
  createSaveGame,
  saveSaveGame,
  loadSaveGame,
  clearSaveGame,
  hasSaveGame,
  SAVEGAME_STORAGE_KEY,
  SAVEGAME_VERSION,
  type SaveGameInput,
} from './saveGame';

describe('saveGame utility (U-015[Mvp])', () => {
  beforeEach(() => {
    // localStorage ì´ˆê¸°í™”
    localStorage.clear();
    vi.clearAllMocks();
  });

  const mockInput: SaveGameInput = {
    language: 'ko-KR',
    profileId: 'explorer',
    seed: 'test-seed',
    economy: { signal: 100, memory_shard: 5 },
    economyLedger: [],
    turnCount: 1,
    narrativeHistory: [{ turn: 1, text: 'í…ŒìŠ¤íŠ¸ ë‚´ëŸ¬í‹°ë¸Œ' }],
    inventory: [{ id: 'item1', name: 'ì•„ì´í…œ1', quantity: 1 }],
    quests: [{ id: 'q1', label: 'í€˜ìŠ¤íŠ¸1', is_completed: false }],
    activeRules: [{ id: 'r1', label: 'ê·œì¹™1', description: 'ì„¤ëª…1' }],
    mutationTimeline: [],
    sceneObjects: [],
  };

  it('createSaveGameì€ ì˜¬ë°”ë¥¸ ìŠ¤í‚¤ë§ˆë¥¼ ê°€ì§„ ê°ì²´ë¥¼ ìƒì„±í•´ì•¼ í•œë‹¤', () => {
    const saveGame = createSaveGame(mockInput);

    expect(saveGame.version).toBe(SAVEGAME_VERSION);
    expect(saveGame.language).toBe('ko-KR');
    expect(saveGame.profileId).toBe('explorer');
    expect(saveGame.economy.signal).toBe(100);
    expect(saveGame.inventory).toHaveLength(1);
    expect(saveGame.inventory[0].name).toBe('ì•„ì´í…œ1');

    // Zod ìŠ¤í‚¤ë§ˆ ê²€ì¦
    const result = SaveGameSchema.safeParse(saveGame);
    expect(result.success).toBe(true);
  });

  it('saveSaveGameì€ ë°ì´í„°ë¥¼ localStorageì— ì €ì¥í•´ì•¼ í•œë‹¤', () => {
    const saveGame = createSaveGame(mockInput);
    const success = saveSaveGame(saveGame);

    expect(success).toBe(true);
    expect(localStorage.getItem(SAVEGAME_STORAGE_KEY)).not.toBeNull();

    const storedData = JSON.parse(localStorage.getItem(SAVEGAME_STORAGE_KEY)!);
    expect(storedData.profileId).toBe('explorer');
  });

  it('loadSaveGameì€ ì €ì¥ëœ ë°ì´í„°ë¥¼ ì˜¬ë°”ë¥´ê²Œ ë¡œë“œí•´ì•¼ í•œë‹¤', () => {
    const saveGame = createSaveGame(mockInput);
    saveSaveGame(saveGame);

    const loaded = loadSaveGame();
    expect(loaded).not.toBeNull();
    expect(loaded?.profileId).toBe('explorer');
    expect(loaded?.version).toBe(SAVEGAME_VERSION);
  });

  it('ë°ì´í„°ê°€ ì—†ì„ ë•Œ loadSaveGameì€ nullì„ ë°˜í™˜í•´ì•¼ í•œë‹¤', () => {
    const loaded = loadSaveGame();
    expect(loaded).toBeNull();
  });

  it('ìœ íš¨í•˜ì§€ ì•Šì€ ë°ì´í„°ê°€ ì €ì¥ë˜ì–´ ìˆìœ¼ë©´ loadSaveGameì€ nullì„ ë°˜í™˜í•´ì•¼ í•œë‹¤', () => {
    localStorage.setItem(SAVEGAME_STORAGE_KEY, JSON.stringify({ version: 'unknown' }));

    // safeParse ì‹¤íŒ¨ë¡œ ì¸í•´ null ë°˜í™˜ ì˜ˆìƒ
    const loaded = loadSaveGame();
    expect(loaded).toBeNull();
  });

  it('clearSaveGameì€ ì €ì¥ëœ ë°ì´í„°ë¥¼ ì‚­ì œí•´ì•¼ í•œë‹¤', () => {
    const saveGame = createSaveGame(mockInput);
    saveSaveGame(saveGame);
    expect(hasSaveGame()).toBe(true);

    clearSaveGame();
    expect(hasSaveGame()).toBe(false);
    expect(localStorage.getItem(SAVEGAME_STORAGE_KEY)).toBeNull();
  });

  it('hasSaveGameì€ ë°ì´í„° ì¡´ì¬ ì—¬ë¶€ë¥¼ ì •í™•íˆ ë°˜í™˜í•´ì•¼ í•œë‹¤', () => {
    expect(hasSaveGame()).toBe(false);

    const saveGame = createSaveGame(mockInput);
    saveSaveGame(saveGame);
    expect(hasSaveGame()).toBe(true);
  });
});
</file>

<file path="frontend/src/save/sessionLifecycle.test.ts">
import { describe, it, expect, beforeEach, vi } from 'vitest';
import {
  bootstrapSession,
  startSessionFromProfile,
  continueSession,
  resetToCurrentProfile,
  clearSessionAndReturnToSelect,
  saveCurrentSession,
  getInitialProfileId,
} from './sessionLifecycle';
import { useWorldStore } from '../stores/worldStore';
import { useInventoryStore } from '../stores/inventoryStore';
import { useEconomyStore } from '../stores/economyStore';
import { SAVEGAME_STORAGE_KEY, CURRENT_PROFILE_KEY, SAVEGAME_VERSION } from './constants';
import { PROFILE_EXPLORER } from '../data/demoProfiles';
import * as i18nModule from '../i18n';

// i18n ëª¨ë“ˆ mock
vi.mock('../i18n', async () => {
  const actual = await vi.importActual('../i18n');
  return {
    ...actual,
    changeLanguage: vi.fn().mockResolvedValue(undefined),
    getResolvedLanguage: vi.fn().mockReturnValue('ko-KR'),
  };
});

describe('sessionLifecycle (RU-004[Mvp])', () => {
  const mockT = (key: string) => `translated-${key}`;

  beforeEach(() => {
    localStorage.clear();
    vi.clearAllMocks();

    // Store ì´ˆê¸°í™”
    useWorldStore.getState().reset();
    useInventoryStore.getState().reset();
    useEconomyStore.getState().reset();
  });

  describe('bootstrapSession', () => {
    it('ì„¸ì´ë¸Œ ë°ì´í„°ê°€ ì—†ìœ¼ë©´ profile_select phaseë¥¼ ë°˜í™˜í•´ì•¼ í•œë‹¤', () => {
      const result = bootstrapSession();
      expect(result.phase).toBe('profile_select');
      if (result.phase === 'profile_select') {
        expect(result.savedGameAvailable).toBe(false);
      }
    });

    it('ìœ íš¨í•œ ì„¸ì´ë¸Œ ë°ì´í„°ê°€ ìˆìœ¼ë©´ playing phaseë¥¼ ë°˜í™˜í•´ì•¼ í•œë‹¤', () => {
      // ìœ íš¨í•œ ì„¸ì´ë¸Œ ìƒì„± ë° ì €ì¥
      const saveGame = {
        version: SAVEGAME_VERSION,
        language: 'ko-KR',
        profileId: 'explorer',
        savedAt: new Date().toISOString(),
        economy: { signal: 100, memory_shard: 5 },
        economyLedger: [],
        turnCount: 1,
        narrativeHistory: [],
        inventory: [],
        quests: [],
        activeRules: [],
        mutationTimeline: [],
        sceneObjects: [],
      };
      localStorage.setItem(SAVEGAME_STORAGE_KEY, JSON.stringify(saveGame));

      const result = bootstrapSession();
      expect(result.phase).toBe('playing');
      if (result.phase === 'playing') {
        expect(result.profileId).toBe('explorer');
      }
    });
  });

  describe('startSessionFromProfile', () => {
    it('í”„ë¡œí•„ ê¸°ë°˜ìœ¼ë¡œ ì„¸ì…˜ì„ ì‹œì‘í•˜ê³  storeì™€ localStorageë¥¼ ì—…ë°ì´íŠ¸í•´ì•¼ í•œë‹¤', () => {
      const result = startSessionFromProfile({
        profile: PROFILE_EXPLORER,
        t: mockT,
      });

      expect(result.success).toBe(true);
      expect(result.profileId).toBe(PROFILE_EXPLORER.id);

      // Store ìƒíƒœ í™•ì¸
      const worldState = useWorldStore.getState();
      expect(worldState.economy.signal).toBe(PROFILE_EXPLORER.initialState.economy.signal);
      expect(worldState.turnCount).toBe(0);
      expect(worldState.narrativeEntries).toHaveLength(1);

      const inventoryState = useInventoryStore.getState();
      expect(inventoryState.items).toHaveLength(PROFILE_EXPLORER.initialState.inventoryDefs.length);

      // localStorage í™•ì¸
      expect(localStorage.getItem(CURRENT_PROFILE_KEY)).toBe(PROFILE_EXPLORER.id);
      expect(localStorage.getItem(SAVEGAME_STORAGE_KEY)).not.toBeNull();
    });
  });

  describe('continueSession', () => {
    it('ì €ì¥ëœ ë°ì´í„°ë¥¼ ë¡œë“œí•˜ê³  storeë¥¼ ë³µì›í•´ì•¼ í•œë‹¤', async () => {
      const saveGame = {
        version: SAVEGAME_VERSION,
        language: 'en-US',
        profileId: 'explorer',
        savedAt: new Date().toISOString(),
        economy: { signal: 123, memory_shard: 45 },
        economyLedger: [],
        turnCount: 5,
        narrativeHistory: [{ turn: 1, text: 'old message' }],
        inventory: [{ id: 'item1', name: 'Item 1', quantity: 2 }],
        quests: [],
        activeRules: [],
        mutationTimeline: [],
        sceneObjects: [],
      };
      localStorage.setItem(SAVEGAME_STORAGE_KEY, JSON.stringify(saveGame));

      const result = await continueSession();

      expect(result?.success).toBe(true);
      expect(result?.profileId).toBe('explorer');

      // ì–¸ì–´ ë³€ê²½ í˜¸ì¶œ í™•ì¸
      expect(i18nModule.changeLanguage).toHaveBeenCalledWith('en-US');

      // Store ìƒíƒœ í™•ì¸
      const worldState = useWorldStore.getState();
      expect(worldState.economy.signal).toBe(123);
      expect(worldState.turnCount).toBe(5);
      expect(worldState.narrativeEntries).toHaveLength(1);

      const inventoryState = useInventoryStore.getState();
      expect(inventoryState.items).toHaveLength(1);
      expect(inventoryState.items[0].id).toBe('item1');
    });

    it('ë°ì´í„°ê°€ ì—†ìœ¼ë©´ nullì„ ë°˜í™˜í•˜ê³  í´ë¦°ì—…í•´ì•¼ í•œë‹¤', async () => {
      localStorage.setItem(CURRENT_PROFILE_KEY, 'some-profile');

      const result = await continueSession();

      expect(result).toBeNull();
      expect(localStorage.getItem(SAVEGAME_STORAGE_KEY)).toBeNull();
      expect(localStorage.getItem(CURRENT_PROFILE_KEY)).toBeNull();
    });
  });

  describe('resetToCurrentProfile', () => {
    it('í˜„ì¬ í”„ë¡œí•„ë¡œ ì„¸ì…˜ì„ ë¦¬ì…‹í•´ì•¼ í•œë‹¤', () => {
      // ë¨¼ì € ì„¸ì…˜ ì‹œì‘
      startSessionFromProfile({
        profile: PROFILE_EXPLORER,
        t: mockT,
      });

      // ìƒíƒœ ë³€ê²½ ì‹œë®¬ë ˆì´ì…˜
      useWorldStore.setState({ turnCount: 10, economy: { signal: 0, memory_shard: 0 } });

      const result = resetToCurrentProfile({
        t: mockT,
        currentProfileId: PROFILE_EXPLORER.id,
      });

      expect(result.success).toBe(true);
      expect(result.profileId).toBe(PROFILE_EXPLORER.id);

      // ì´ˆê¸° ìƒíƒœë¡œ ë³µì›ë˜ì—ˆëŠ”ì§€ í™•ì¸
      const worldState = useWorldStore.getState();
      expect(worldState.turnCount).toBe(0);
      expect(worldState.economy.signal).toBe(PROFILE_EXPLORER.initialState.economy.signal);
    });
  });

  describe('clearSessionAndReturnToSelect', () => {
    it('ëª¨ë“  ë°ì´í„°ë¥¼ ì‚­ì œí•˜ê³  storeë¥¼ ì´ˆê¸°í™”í•´ì•¼ í•œë‹¤', () => {
      // ë°ì´í„° ì±„ìš°ê¸°
      startSessionFromProfile({
        profile: PROFILE_EXPLORER,
        t: mockT,
      });

      clearSessionAndReturnToSelect();

      expect(localStorage.getItem(SAVEGAME_STORAGE_KEY)).toBeNull();
      expect(localStorage.getItem(CURRENT_PROFILE_KEY)).toBeNull();

      const worldState = useWorldStore.getState();
      expect(worldState.narrativeEntries).toHaveLength(0);
    });
  });

  describe('saveCurrentSession', () => {
    it('í˜„ì¬ ìƒíƒœë¥¼ localStorageì— ì €ì¥í•´ì•¼ í•œë‹¤', () => {
      startSessionFromProfile({
        profile: PROFILE_EXPLORER,
        t: mockT,
      });

      // ìƒíƒœ ë³€ê²½
      useWorldStore.setState({ turnCount: 1 });

      const success = saveCurrentSession(PROFILE_EXPLORER.id);
      expect(success).toBe(true);

      const saved = JSON.parse(localStorage.getItem(SAVEGAME_STORAGE_KEY)!);
      expect(saved.turnCount).toBe(1);
    });
  });

  describe('getInitialProfileId', () => {
    it('ì„¸ì´ë¸Œ ë°ì´í„°ê°€ ìˆìœ¼ë©´ ê·¸ ì•ˆì˜ profileIdë¥¼ ìš°ì„ í•´ì•¼ í•œë‹¤', () => {
      localStorage.setItem(
        SAVEGAME_STORAGE_KEY,
        JSON.stringify({
          version: SAVEGAME_VERSION,
          language: 'ko-KR',
          profileId: 'saved-profile',
          savedAt: new Date().toISOString(),
          economy: { signal: 100, memory_shard: 5 },
          economyLedger: [],
          turnCount: 1,
          narrativeHistory: [],
          inventory: [],
          quests: [],
          activeRules: [],
          mutationTimeline: [],
          sceneObjects: [],
        }),
      );
      localStorage.setItem(CURRENT_PROFILE_KEY, 'fallback-profile');

      expect(getInitialProfileId()).toBe('saved-profile');
    });

    it('ì„¸ì´ë¸Œ ë°ì´í„°ê°€ ì—†ìœ¼ë©´ CURRENT_PROFILE_KEYë¥¼ ì‚¬ìš©í•´ì•¼ í•œë‹¤', () => {
      localStorage.setItem(CURRENT_PROFILE_KEY, 'fallback-profile');
      expect(getInitialProfileId()).toBe('fallback-profile');
    });
  });
});
</file>

<file path="frontend/src/schemas/index.ts">
/**
 * Unknown World - ìŠ¤í‚¤ë§ˆ ëª¨ë“ˆ ì§„ì…ì .
 *
 * TurnInput/TurnOutput Zod ìŠ¤í‚¤ë§ˆ ë° ê´€ë ¨ ìœ í‹¸ë¦¬í‹°ë¥¼ ì¬ë‚´ë³´ë‚´ê¸°í•©ë‹ˆë‹¤.
 *
 * @module schemas
 */

// =============================================================================
// ìŠ¤í‚¤ë§ˆ ë²„ì „
// =============================================================================

export { SCHEMA_VERSION } from './turn';

// =============================================================================
// Enum ìŠ¤í‚¤ë§ˆ ë° íƒ€ì…
// =============================================================================

export {
  LanguageSchema,
  ThemeSchema,
  AgentPhaseSchema,
  ValidationBadgeSchema,
  ModelLabelSchema,
  RiskLevelSchema,
} from './turn';

export type { Language, Theme, AgentPhase, ValidationBadge, ModelLabel, RiskLevel } from './turn';

// =============================================================================
// ê³µí†µ í•˜ìœ„ íƒ€ì… ìŠ¤í‚¤ë§ˆ ë° íƒ€ì…
// =============================================================================

export { CoordinateSchema, Box2DSchema, CurrencyAmountSchema } from './turn';

export type { Coordinate, Box2D, CurrencyAmount } from './turn';

// =============================================================================
// TurnInput ê´€ë ¨ ìŠ¤í‚¤ë§ˆ ë° íƒ€ì…
// =============================================================================

export { ClickInputSchema, ClientInfoSchema, EconomySnapshotSchema, TurnInputSchema } from './turn';

export type { ClickInput, ClientInfo, EconomySnapshot, TurnInput } from './turn';

// =============================================================================
// TurnOutput ê´€ë ¨ ìŠ¤í‚¤ë§ˆ ë° íƒ€ì…
// =============================================================================

export {
  // UI
  ActionCardSchema,
  SceneObjectSchema,
  ActionDeckSchema,
  UIOutputSchema,
  // World
  MemoryPinSchema,
  WorldRuleSchema,
  QuestSchema,
  WorldDeltaSchema,
  // Render
  ImageJobSchema,
  RenderOutputSchema,
  // Economy
  EconomyOutputSchema,
  // Safety
  SafetyOutputSchema,
  // Agent Console
  AgentConsoleSchema,
  // Main
  TurnOutputSchema,
} from './turn';

export type {
  // UI
  ActionCard,
  SceneObject,
  ActionDeck,
  UIOutput,
  // World
  MemoryPin,
  WorldRule,
  Quest,
  WorldDelta,
  // Render
  ImageJob,
  RenderOutput,
  // Economy
  EconomyOutput,
  // Safety
  SafetyOutput,
  // Agent Console
  AgentConsole,
  // Main
  TurnOutput,
} from './turn';

// =============================================================================
// ìœ í‹¸ë¦¬í‹° í•¨ìˆ˜
// =============================================================================

export {
  createFallbackTurnOutput,
  safeParseTurnOutput,
  parseTurnInput,
  safeParseTurnInput,
} from './turn';

export type { TurnOutputParseResult, TurnInputSafeParseResult } from './turn';
</file>

<file path="frontend/src/schemas/turn.test.ts">
import { describe, it, expect } from 'vitest';
import {
  TurnInputSchema,
  TurnOutputSchema,
  safeParseTurnOutput,
  parseTurnInput,
  safeParseTurnInput,
  SCHEMA_VERSION,
} from './turn';

describe('Turn schemas', () => {
  describe('SCHEMA_VERSION', () => {
    it('should have correct version', () => {
      expect(SCHEMA_VERSION).toBe('1.0.0');
    });
  });

  describe('TurnInputSchema', () => {
    const validTurnInput = {
      language: 'ko-KR',
      text: 'í…ŒìŠ¤íŠ¸ ì…ë ¥',
      client: {
        viewport_w: 1920,
        viewport_h: 1080,
        theme: 'dark',
      },
      economy_snapshot: {
        signal: 100,
        memory_shard: 5,
      },
    };

    it('should validate a valid TurnInput', () => {
      const result = TurnInputSchema.safeParse(validTurnInput);
      expect(result.success).toBe(true);
    });

    it('should fail on invalid language', () => {
      const result = TurnInputSchema.safeParse({
        ...validTurnInput,
        language: 'fr-FR',
      });
      expect(result.success).toBe(false);
    });

    it('should fail on negative economy values', () => {
      const result = TurnInputSchema.safeParse({
        ...validTurnInput,
        economy_snapshot: {
          signal: -1,
          memory_shard: 0,
        },
      });
      expect(result.success).toBe(false);
    });

    it('should fail on extra fields (strict)', () => {
      const result = TurnInputSchema.safeParse({
        ...validTurnInput,
        extra_field: 'not allowed',
      });
      expect(result.success).toBe(false);
    });

    it('should validate click input with bbox', () => {
      const result = TurnInputSchema.safeParse({
        ...validTurnInput,
        click: {
          object_id: 'door_01',
          box_2d: {
            ymin: 100,
            xmin: 100,
            ymax: 500,
            xmax: 500,
          },
        },
      });
      expect(result.success).toBe(true);
    });

    it('should fail on invalid bbox coordinates (out of range 0-1000)', () => {
      const result = TurnInputSchema.safeParse({
        ...validTurnInput,
        click: {
          object_id: 'door_01',
          box_2d: {
            ymin: -1,
            xmin: 0,
            ymax: 1001,
            xmax: 500,
          },
        },
      });
      expect(result.success).toBe(false);
    });

    it('should fail on non-positive viewport dimensions', () => {
      const result = TurnInputSchema.safeParse({
        ...validTurnInput,
        client: {
          viewport_w: 0,
          viewport_h: -100,
          theme: 'dark',
        },
      });
      expect(result.success).toBe(false);
    });

    it('should fail on non-integer coordinates', () => {
      const result = TurnInputSchema.safeParse({
        ...validTurnInput,
        click: {
          object_id: 'obj',
          box_2d: {
            ymin: 10.5,
            xmin: 20,
            ymax: 30,
            xmax: 40,
          },
        },
      });
      expect(result.success).toBe(false);
    });
  });

  describe('TurnOutputSchema', () => {
    const validTurnOutput = {
      language: 'ko-KR',
      narrative: 'í…ŒìŠ¤íŠ¸ ë‚´ëŸ¬í‹°ë¸Œ',
      economy: {
        cost: { signal: 5, memory_shard: 0 },
        balance_after: { signal: 95, memory_shard: 5 },
      },
      safety: {
        blocked: false,
      },
      agent_console: {
        current_phase: 'commit',
        badges: ['schema_ok', 'economy_ok'],
        repair_count: 0,
      },
    };

    it('should validate a valid TurnOutput', () => {
      const result = TurnOutputSchema.safeParse(validTurnOutput);
      expect(result.success).toBe(true);
    });

    it('should fail if required fields are missing', () => {
      const { narrative: _narrative, ...invalidOutput } = validTurnOutput;
      const result = TurnOutputSchema.safeParse(invalidOutput);
      expect(result.success).toBe(false);
    });

    it('should handle default values for optional fields', () => {
      const result = TurnOutputSchema.safeParse(validTurnOutput);
      if (result.success) {
        expect(result.data.ui).toBeDefined();
        expect(result.data.ui.action_deck.cards).toEqual([]);
        expect(result.data.world.rules_changed).toEqual([]);
      } else {
        throw new Error('Validation failed');
      }
    });

    it('should fail if there are too many action cards (max 10)', () => {
      const cards = Array.from({ length: 11 }, (_, i) => ({
        id: `card_${i}`,
        label: `Card ${i}`,
        cost: { signal: 0, memory_shard: 0 },
        risk: 'low',
      }));
      const result = TurnOutputSchema.safeParse({
        ...validTurnOutput,
        ui: {
          action_deck: { cards },
        },
      });
      expect(result.success).toBe(false);
    });

    it('should fail on negative repair_count', () => {
      const result = TurnOutputSchema.safeParse({
        ...validTurnOutput,
        agent_console: {
          current_phase: 'commit',
          badges: [],
          repair_count: -1,
        },
      });
      expect(result.success).toBe(false);
    });
  });

  describe('safeParseTurnOutput', () => {
    it('should return success for valid data', () => {
      const validTurnOutput = {
        language: 'en-US',
        narrative: 'Test narrative',
        economy: {
          cost: { signal: 0, memory_shard: 0 },
          balance_after: { signal: 100, memory_shard: 0 },
        },
        safety: { blocked: false },
      };
      const result = safeParseTurnOutput(validTurnOutput);
      expect(result.success).toBe(true);
      if (result.success) {
        expect(result.data.language).toBe('en-US');
      }
    });

    it('should return fallback for invalid data', () => {
      const invalidData = { some: 'garbage' };
      const result = safeParseTurnOutput(invalidData, 'ko-KR', 1);
      expect(result.success).toBe(false);
      if (!result.success) {
        expect(result.fallback).toBeDefined();
        expect(result.fallback.language).toBe('ko-KR');
        expect(result.fallback.agent_console.badges).toContain('schema_fail');
        expect(result.fallback.agent_console.repair_count).toBe(1);
      }
    });
  });

  describe('Input Parsing Utilities', () => {
    const validTurnInput = {
      language: 'ko-KR',
      text: 'í…ŒìŠ¤íŠ¸ ì…ë ¥',
      client: {
        viewport_w: 1920,
        viewport_h: 1080,
        theme: 'dark',
      },
      economy_snapshot: {
        signal: 100,
        memory_shard: 5,
      },
    };

    describe('parseTurnInput', () => {
      it('should parse valid input', () => {
        const result = parseTurnInput(validTurnInput);
        expect(result.text).toBe('í…ŒìŠ¤íŠ¸ ì…ë ¥');
      });

      it('should throw error for invalid input', () => {
        expect(() => parseTurnInput({})).toThrow();
      });
    });

    describe('safeParseTurnInput', () => {
      it('should return success for valid input', () => {
        const result = safeParseTurnInput(validTurnInput);
        expect(result.success).toBe(true);
      });

      it('should return failure for invalid input', () => {
        const result = safeParseTurnInput({});
        expect(result.success).toBe(false);
      });
    });
  });
});
</file>

<file path="frontend/src/schemas/verify_runbook.ts">
import {
  TurnOutputSchema,
  safeParseTurnOutput,
  Box2DSchema,
  CurrencyAmountSchema,
  LanguageSchema,
  parseTurnInput,
} from './turn.js';

console.log('--- Scenario A: TurnOutput ìŠ¤í‚¤ë§ˆ ê²€ì¦ (ì •ìƒ ì¼€ì´ìŠ¤) ---');
const validOutput = {
  language: 'ko-KR',
  narrative: 'ë¬¸ì´ ì‚ê±±ê±°ë¦¬ë©° ì—´ë¦½ë‹ˆë‹¤...',
  economy: {
    cost: { signal: 5, memory_shard: 0 },
    balance_after: { signal: 95, memory_shard: 5 },
  },
  safety: { blocked: false, message: null },
};
const resultA = safeParseTurnOutput(validOutput);
console.log('Success:', resultA.success);
if (resultA.success) {
  console.log('Data (sample):', resultA.data.narrative);
}

console.log('\n--- Scenario B: TurnOutput ìŠ¤í‚¤ë§ˆ ê²€ì¦ ì‹¤íŒ¨ â†’ í´ë°± ---');
const invalidOutput = {
  language: 'ko-KR',
  narrative: 'í…ŒìŠ¤íŠ¸',
};
// eslint-disable-next-line @typescript-eslint/no-explicit-any
const resultB = safeParseTurnOutput(invalidOutput as any);
console.log('Success:', resultB.success);
if (!resultB.success) {
  console.log('Error count:', resultB.error.issues.length);
  console.log('Fallback exists:', !!resultB.fallback);
  console.log(
    'Fallback badges has schema_fail:',
    resultB.fallback?.agent_console?.badges?.includes('schema_fail'),
  );
}

console.log('\n--- Scenario C: ì¢Œí‘œ ë²”ìœ„ ê²€ì¦ (RULE-009) ---');
const validBox = { ymin: 100, xmin: 200, ymax: 300, xmax: 400 };
console.log('Valid box:', Box2DSchema.safeParse(validBox).success);
const invalidBox = { ymin: 100, xmin: 200, ymax: 1500, xmax: 400 };
console.log('Invalid box (1500):', Box2DSchema.safeParse(invalidBox).success);
const negativeBox = { ymin: -10, xmin: 200, ymax: 300, xmax: 400 };
console.log('Negative box:', Box2DSchema.safeParse(negativeBox).success);

console.log('\n--- Scenario D: ì¬í™” ì¸ë°”ë¦¬ì–¸íŠ¸ ê²€ì¦ (RULE-005) ---');
const validCurrency = { signal: 100, memory_shard: 5 };
console.log('Valid currency:', CurrencyAmountSchema.safeParse(validCurrency).success);
const negativeCurrency = { signal: -10, memory_shard: 5 };
console.log('Negative signal:', CurrencyAmountSchema.safeParse(negativeCurrency).success);

console.log('\n--- Scenario E: ì–¸ì–´ ì •ì±… ê²€ì¦ (RULE-006) ---');
console.log('ko-KR:', LanguageSchema.safeParse('ko-KR').success);
console.log('en-US:', LanguageSchema.safeParse('en-US').success);
console.log('ja-JP (invalid):', LanguageSchema.safeParse('ja-JP').success);
console.log('ko (invalid format):', LanguageSchema.safeParse('ko').success);

console.log('\n--- Scenario F: TurnInput ê²€ì¦ ---');
const validInput = {
  language: 'ko-KR',
  text: 'ë¬¸ì„ ì—´ì–´ë³¸ë‹¤',
  client: {
    viewport_w: 1920,
    viewport_h: 1080,
    theme: 'dark',
  },
  economy_snapshot: {
    signal: 100,
    memory_shard: 5,
  },
};
try {
  // eslint-disable-next-line @typescript-eslint/no-explicit-any
  const parsed = parseTurnInput(validInput as any);
  console.log('Parsed successfully:', parsed.text);
} catch (e) {
  console.log('Parse error:', e);
}

console.log('\n--- Scenario G: Strict ëª¨ë“œ ê²€ì¦ ---');
const outputWithExtra = {
  language: 'ko-KR',
  narrative: 'í…ŒìŠ¤íŠ¸',
  economy: {
    cost: { signal: 0, memory_shard: 0 },
    balance_after: { signal: 100, memory_shard: 5 },
  },
  safety: { blocked: false, message: null },
  unknown_field: 'ì´ í•„ë“œëŠ” ìŠ¤í‚¤ë§ˆì— ì—†ìŒ',
};
const resultG = TurnOutputSchema.safeParse(outputWithExtra);
console.log('With extra field success:', resultG.success);
if (!resultG.success) {
  console.log('Error code:', resultG.error.issues[0].code);
}
</file>

<file path="frontend/src/setupTests.ts">
import '@testing-library/jest-dom';
</file>

<file path="frontend/src/stores/actionDeckStore.test.ts">
import { describe, it, expect, beforeEach } from 'vitest';
import { useActionDeckStore, filterAffordableCards } from './actionDeckStore';
import type { ActionCard } from '../schemas/turn';

describe('actionDeckStore', () => {
  beforeEach(() => {
    useActionDeckStore.getState().reset();
  });

  const mockCards: ActionCard[] = [
    {
      id: 'card-1',
      label: 'Card 1',
      description: null,
      cost: { signal: 10, memory_shard: 0 },
      cost_estimate: null,
      risk: 'low',
      hint: null,
      reward_hint: null,
      enabled: true,
      disabled_reason: null,
      is_alternative: false,
    },
    {
      id: 'card-2',
      label: 'Card 2',
      description: null,
      cost: { signal: 50, memory_shard: 1 },
      cost_estimate: null,
      risk: 'high',
      hint: null,
      reward_hint: null,
      enabled: true,
      disabled_reason: null,
      is_alternative: false,
    },
  ];

  it('sets cards and resets selected card', () => {
    const store = useActionDeckStore.getState();
    store.selectCard('some-id');
    expect(useActionDeckStore.getState().selectedCardId).toBe('some-id');

    store.setCards(mockCards);
    expect(useActionDeckStore.getState().cards).toEqual(mockCards);
    expect(useActionDeckStore.getState().selectedCardId).toBeNull();
  });

  it('marks a card as executed', () => {
    const store = useActionDeckStore.getState();
    store.selectCard('card-1');
    store.markExecuted('card-1');

    expect(useActionDeckStore.getState().lastExecutedCardId).toBe('card-1');
    expect(useActionDeckStore.getState().selectedCardId).toBeNull();
  });

  it('filters affordable cards correctly', () => {
    const balance = { signal: 20, memory_shard: 0 };
    const affordable = filterAffordableCards(mockCards, balance);

    expect(affordable).toHaveLength(1);
    expect(affordable[0].id).toBe('card-1');
  });

  it('respects server enabled flag in filterAffordableCards', () => {
    const disabledCards: ActionCard[] = [
      {
        ...mockCards[0],
        enabled: false,
      },
    ];
    const balance = { signal: 100, memory_shard: 100 };
    const affordable = filterAffordableCards(disabledCards, balance);

    expect(affordable).toHaveLength(0);
  });
});
</file>

<file path="frontend/src/stores/actionDeckStore.ts">
/**
 * Unknown World - Action Deck ìƒíƒœ ê´€ë¦¬ (Zustand) (U-009[Mvp]).
 *
 * Action Deckì˜ ì¹´ë“œ ëª©ë¡, ì„ íƒ ìƒíƒœ, ì”ì•¡ ê¸°ë°˜ í•„í„°ë§ì„ ê´€ë¦¬í•©ë‹ˆë‹¤.
 *
 * ì„¤ê³„ ì›ì¹™:
 *   - RULE-005: ì”ì•¡ ë¶€ì¡± ì‹œ ì‹¤í–‰ ë¶ˆê°€ í‘œì‹œ + ëŒ€ì•ˆ ì œê³µ
 *   - RULE-008: ì¹´ë“œ í´ë¦­ â†’ TurnInput ì—°ê²°
 *
 * @module stores/actionDeckStore
 */

import { create } from 'zustand';
import type { ActionCard } from '../schemas/turn';

// =============================================================================
// ìƒíƒœ íƒ€ì… ì •ì˜
// =============================================================================

/** Action Deck ìƒíƒœ */
export interface ActionDeckState {
  /** í˜„ì¬ ì¹´ë“œ ëª©ë¡ (ì„œë²„ì—ì„œ ë°›ì€ ì›ë³¸) */
  cards: ActionCard[];
  /** ì„ íƒëœ ì¹´ë“œ ID (í´ë¦­ í›„ ì‹¤í–‰ ì „ê¹Œì§€) */
  selectedCardId: string | null;
  /** ë§ˆì§€ë§‰ìœ¼ë¡œ ì‹¤í–‰ëœ ì¹´ë“œ ID */
  lastExecutedCardId: string | null;
}

/** Action Deck ì•¡ì…˜ */
export interface ActionDeckActions {
  /** ì¹´ë“œ ëª©ë¡ ì„¤ì • (TurnOutput ìˆ˜ì‹  ì‹œ) */
  setCards: (cards: ActionCard[]) => void;
  /** ì¹´ë“œ ì„ íƒ */
  selectCard: (cardId: string | null) => void;
  /** ì¹´ë“œ ì‹¤í–‰ ì™„ë£Œ ê¸°ë¡ */
  markExecuted: (cardId: string) => void;
  /** ìƒíƒœ ì´ˆê¸°í™” */
  reset: () => void;
}

export type ActionDeckStore = ActionDeckState & ActionDeckActions;

// =============================================================================
// ì´ˆê¸° ìƒíƒœ
// =============================================================================

function createInitialState(): ActionDeckState {
  return {
    cards: [],
    selectedCardId: null,
    lastExecutedCardId: null,
  };
}

// =============================================================================
// Zustand Store
// =============================================================================

/**
 * Action Deck ìƒíƒœ ìŠ¤í† ì–´.
 *
 * @example
 * ```tsx
 * const { cards, setCards, selectCard } = useActionDeckStore();
 *
 * // TurnOutput ìˆ˜ì‹  ì‹œ
 * setCards(turnOutput.ui.action_deck.cards);
 *
 * // ì¹´ë“œ í´ë¦­ ì‹œ
 * selectCard(card.id);
 * ```
 */
export const useActionDeckStore = create<ActionDeckStore>((set) => ({
  // ì´ˆê¸° ìƒíƒœ
  ...createInitialState(),

  // ì•¡ì…˜
  setCards: (cards) => {
    set({
      cards,
      selectedCardId: null, // ìƒˆ ì¹´ë“œ ëª©ë¡ ìˆ˜ì‹  ì‹œ ì„ íƒ ì´ˆê¸°í™”
    });
  },

  selectCard: (cardId) => {
    set({ selectedCardId: cardId });
  },

  markExecuted: (cardId) => {
    set({
      lastExecutedCardId: cardId,
      selectedCardId: null,
    });
  },

  reset: () => {
    set(createInitialState());
  },
}));

// =============================================================================
// ì…€ë ‰í„° (ì„±ëŠ¥ ìµœì í™”ìš©)
// =============================================================================

/** ì¹´ë“œ ëª©ë¡ ì…€ë ‰í„° */
export const selectCards = (state: ActionDeckStore) => state.cards;

/** ì„ íƒëœ ì¹´ë“œ ID ì…€ë ‰í„° */
export const selectSelectedCardId = (state: ActionDeckStore) => state.selectedCardId;

/** ì„ íƒëœ ì¹´ë“œ ê°ì²´ ì…€ë ‰í„° */
export const selectSelectedCard = (state: ActionDeckStore) =>
  state.cards.find((c) => c.id === state.selectedCardId) ?? null;

/** ë§ˆì§€ë§‰ ì‹¤í–‰ ì¹´ë“œ ID ì…€ë ‰í„° */
export const selectLastExecutedCardId = (state: ActionDeckStore) => state.lastExecutedCardId;

// =============================================================================
// ìœ í‹¸ë¦¬í‹° í•¨ìˆ˜
// =============================================================================

/**
 * ì”ì•¡ ê¸°ë°˜ìœ¼ë¡œ ì‹¤í–‰ ê°€ëŠ¥í•œ ì¹´ë“œë§Œ í•„í„°ë§í•©ë‹ˆë‹¤.
 * (ì»´í¬ë„ŒíŠ¸ì—ì„œ ì‚¬ìš©í•˜ê±°ë‚˜, ì„œë²„ ì‘ë‹µì´ enabledë¥¼ ì œê³µí•˜ì§€ ì•Šì„ ë•Œ í´ë°±ìœ¼ë¡œ ì‚¬ìš©)
 *
 * @param cards - ì›ë³¸ ì¹´ë“œ ëª©ë¡
 * @param balance - í˜„ì¬ ì”ì•¡
 * @returns ì‹¤í–‰ ê°€ëŠ¥í•œ ì¹´ë“œ ëª©ë¡
 */
export function filterAffordableCards(
  cards: ActionCard[],
  balance: { signal: number; memory_shard: number },
): ActionCard[] {
  return cards.filter((card) => {
    // ì„œë²„ì—ì„œ ì´ë¯¸ enabled=falseë¡œ íŒë‹¨í–ˆìœ¼ë©´ ì œì™¸
    if (!card.enabled) return false;

    // ë¹„ìš© ì¶”ì •ì¹˜ê°€ ìˆìœ¼ë©´ ìµœëŒ€ ë¹„ìš©ìœ¼ë¡œ íŒë‹¨
    const cost = card.cost_estimate?.max ?? card.cost;
    return balance.signal >= cost.signal && balance.memory_shard >= cost.memory_shard;
  });
}

/**
 * ëŒ€ì•ˆ ì¹´ë“œ(is_alternative=true)ë§Œ í•„í„°ë§í•©ë‹ˆë‹¤.
 *
 * @param cards - ì›ë³¸ ì¹´ë“œ ëª©ë¡
 * @returns ëŒ€ì•ˆ ì¹´ë“œ ëª©ë¡
 */
export function filterAlternativeCards(cards: ActionCard[]): ActionCard[] {
  return cards.filter((card) => card.is_alternative);
}

/**
 * ì¼ë°˜ ì¹´ë“œ(is_alternative=false)ë§Œ í•„í„°ë§í•©ë‹ˆë‹¤.
 *
 * @param cards - ì›ë³¸ ì¹´ë“œ ëª©ë¡
 * @returns ì¼ë°˜ ì¹´ë“œ ëª©ë¡
 */
export function filterRegularCards(cards: ActionCard[]): ActionCard[] {
  return cards.filter((card) => !card.is_alternative);
}
</file>

<file path="frontend/src/stores/economyStore.test.ts">
import { describe, it, expect, beforeEach } from 'vitest';
import {
  useEconomyStore,
  LEDGER_MAX_ENTRIES,
  canAffordCost,
  canAffordEstimate,
} from './economyStore';
import type { CurrencyAmount, CostEstimate } from '../schemas/turn';

describe('economyStore', () => {
  beforeEach(() => {
    useEconomyStore.getState().reset();
  });

  it('ì´ˆê¸° ìƒíƒœê°€ ì˜¬ë°”ë¥´ê²Œ ì„¤ì •ë˜ì–´ì•¼ í•œë‹¤', () => {
    const state = useEconomyStore.getState();
    expect(state.ledger).toEqual([]);
    expect(state.costEstimate).toBeNull();
    expect(state.lastCost).toBeNull();
    expect(state.isBalanceLow).toBe(false);
    expect(state.lowBalanceThreshold).toBe(10);
  });

  it('addLedgerEntryê°€ ì—”íŠ¸ë¦¬ë¥¼ ì¶”ê°€í•˜ê³  lastCostë¥¼ ì—…ë°ì´íŠ¸í•´ì•¼ í•œë‹¤', () => {
    const entry = {
      turnId: 1,
      reason: 'explore',
      cost: { signal: 5, memory_shard: 0 },
      balanceAfter: { signal: 95, memory_shard: 10 },
      modelLabel: 'FAST' as const,
    };

    useEconomyStore.getState().addLedgerEntry(entry);

    const state = useEconomyStore.getState();
    expect(state.ledger.length).toBe(1);
    expect(state.ledger[0].turnId).toBe(1);
    expect(state.ledger[0].timestamp).toBeDefined();
    expect(state.lastCost).toEqual({
      cost: entry.cost,
      balanceAfter: entry.balanceAfter,
      turnId: entry.turnId,
      modelLabel: entry.modelLabel,
    });
  });

  it(`LedgerëŠ” ìµœëŒ€ ${LEDGER_MAX_ENTRIES}ê°œê¹Œì§€ë§Œ ë³´ê´€í•´ì•¼ í•œë‹¤`, () => {
    const store = useEconomyStore.getState();

    // 25ê°œ ì—”íŠ¸ë¦¬ ì¶”ê°€
    for (let i = 1; i <= 25; i++) {
      store.addLedgerEntry({
        turnId: i,
        reason: `test-${i}`,
        cost: { signal: 1, memory_shard: 0 },
        balanceAfter: { signal: 100 - i, memory_shard: 0 },
      });
    }

    const state = useEconomyStore.getState();
    expect(state.ledger.length).toBe(LEDGER_MAX_ENTRIES);
    // ìµœì‹ ìˆœ(ë‚´ë¦¼ì°¨ìˆœ) ì •ë ¬ í™•ì¸
    expect(state.ledger[0].turnId).toBe(25);
    expect(state.ledger[LEDGER_MAX_ENTRIES - 1].turnId).toBe(25 - LEDGER_MAX_ENTRIES + 1);
  });

  it('setCostEstimateFromCardê°€ ì˜ˆìƒ ë¹„ìš©ì„ ì˜¬ë°”ë¥´ê²Œ ì„¤ì •í•´ì•¼ í•œë‹¤', () => {
    const cost: CurrencyAmount = { signal: 5, memory_shard: 0 };
    const estimate: CostEstimate = {
      min: { signal: 3, memory_shard: 0 },
      max: { signal: 7, memory_shard: 0 },
    };

    // 1. cost_estimateê°€ ì œê³µëœ ê²½ìš°
    useEconomyStore.getState().setCostEstimateFromCard(cost, estimate, 'action-1', 'Test Label');
    let state = useEconomyStore.getState();
    expect(state.costEstimate).toEqual({
      min: estimate.min,
      max: estimate.max,
      actionId: 'action-1',
      label: 'Test Label',
    });

    // 2. cost_estimateê°€ nullì¸ ê²½ìš° (ê¸°ë³¸ cost ì‚¬ìš©)
    useEconomyStore.getState().setCostEstimateFromCard(cost, null, 'action-2');
    state = useEconomyStore.getState();
    expect(state.costEstimate).toEqual({
      min: cost,
      max: cost,
      actionId: 'action-2',
      label: undefined,
    });
  });

  it('updateBalanceLowStatusê°€ ì„ê³„ê°’ì— ë”°ë¼ ìƒíƒœë¥¼ ì—…ë°ì´íŠ¸í•´ì•¼ í•œë‹¤', () => {
    const store = useEconomyStore.getState();

    // ê¸°ë³¸ ì„ê³„ê°’ 10
    store.updateBalanceLowStatus({ signal: 15, memory_shard: 0 });
    expect(useEconomyStore.getState().isBalanceLow).toBe(false);

    store.updateBalanceLowStatus({ signal: 5, memory_shard: 0 });
    expect(useEconomyStore.getState().isBalanceLow).toBe(true);

    // ì„ê³„ê°’ ë³€ê²½ í…ŒìŠ¤íŠ¸
    store.setLowBalanceThreshold(20);
    store.updateBalanceLowStatus({ signal: 15, memory_shard: 0 });
    expect(useEconomyStore.getState().isBalanceLow).toBe(true);
  });

  describe('Utility: canAffordCost & canAffordEstimate', () => {
    const balance: CurrencyAmount = { signal: 10, memory_shard: 2 };

    it('canAffordCost: ì”ì•¡ì´ ì¶©ë¶„í•  ë•Œ', () => {
      const cost: CurrencyAmount = { signal: 5, memory_shard: 1 };
      const result = canAffordCost(balance, cost);
      expect(result.affordable).toBe(true);
      expect(result.shortfall).toEqual({ signal: 0, memory_shard: 0 });
    });

    it('canAffordCost: ì”ì•¡ì´ ë¶€ì¡±í•  ë•Œ (Signal)', () => {
      const cost: CurrencyAmount = { signal: 15, memory_shard: 1 };
      const result = canAffordCost(balance, cost);
      expect(result.affordable).toBe(false);
      expect(result.shortfall.signal).toBe(5);
    });

    it('canAffordCost: ì”ì•¡ì´ ë¶€ì¡±í•  ë•Œ (Shard)', () => {
      const cost: CurrencyAmount = { signal: 5, memory_shard: 5 };
      const result = canAffordCost(balance, cost);
      expect(result.affordable).toBe(false);
      expect(result.shortfall.memory_shard).toBe(3);
    });

    it('canAffordEstimate: ìµœëŒ€ ì˜ˆìƒ ë¹„ìš© ê¸°ì¤€ìœ¼ë¡œ ì²´í¬í•´ì•¼ í•œë‹¤', () => {
      const estimate = {
        min: { signal: 5, memory_shard: 0 },
        max: { signal: 15, memory_shard: 0 },
      };
      // Signal 10 < Max 15 ì´ë¯€ë¡œ ê°ë‹¹ ë¶ˆê°€
      const result = canAffordEstimate(balance, estimate);
      expect(result.affordable).toBe(false);
      expect(result.shortfall.signal).toBe(5);
    });
  });
});
</file>

<file path="frontend/src/stores/inventoryStore.test.ts">
import { describe, it, expect, beforeEach } from 'vitest';
import { useInventoryStore, parseInventoryAdded } from './inventoryStore';

describe('inventoryStore', () => {
  beforeEach(() => {
    useInventoryStore.getState().reset();
  });

  it('ì´ˆê¸° ìƒíƒœëŠ” ë¹„ì–´ ìˆì–´ì•¼ í•œë‹¤', () => {
    const state = useInventoryStore.getState();
    expect(state.items).toEqual([]);
    expect(state.draggingItemId).toBeNull();
    expect(state.selectedItemId).toBeNull();
  });

  it('addItems: ìƒˆ ì•„ì´í…œì„ ì¶”ê°€í•  ìˆ˜ ìˆì–´ì•¼ í•œë‹¤', () => {
    const { addItems } = useInventoryStore.getState();
    const newItem = { id: 'item1', name: 'Item 1', quantity: 1 };

    addItems([newItem]);

    const state = useInventoryStore.getState();
    expect(state.items).toHaveLength(1);
    expect(state.items[0]).toEqual(newItem);
  });

  it('addItems: ì¤‘ë³µëœ IDì˜ ì•„ì´í…œ ì¶”ê°€ ì‹œ ìˆ˜ëŸ‰ì´ ì¦ê°€í•´ì•¼ í•œë‹¤', () => {
    const { addItems } = useInventoryStore.getState();
    const item1 = { id: 'item1', name: 'Item 1', quantity: 1 };

    addItems([item1]);
    addItems([{ id: 'item1', name: 'Item 1', quantity: 2 }]);

    const state = useInventoryStore.getState();
    expect(state.items).toHaveLength(1);
    expect(state.items[0].quantity).toBe(3);
  });

  it('removeItems: ì•„ì´í…œì„ ì œê±°í•  ìˆ˜ ìˆì–´ì•¼ í•œë‹¤', () => {
    const { addItems, removeItems } = useInventoryStore.getState();
    addItems([
      { id: 'item1', name: 'Item 1', quantity: 1 },
      { id: 'item2', name: 'Item 2', quantity: 1 },
    ]);

    removeItems(['item1']);

    const state = useInventoryStore.getState();
    expect(state.items).toHaveLength(1);
    expect(state.items[0].id).toBe('item2');
  });

  it('removeItems: ì œê±°ëœ ì•„ì´í…œì´ ì„ íƒ/ë“œë˜ê·¸ ì¤‘ì´ë©´ ì´ˆê¸°í™”í•´ì•¼ í•œë‹¤', () => {
    const { addItems, removeItems, selectItem, startDrag } = useInventoryStore.getState();
    addItems([{ id: 'item1', name: 'Item 1', quantity: 1 }]);

    selectItem('item1');
    startDrag('item1');

    removeItems(['item1']);

    const state = useInventoryStore.getState();
    expect(state.selectedItemId).toBeNull();
    expect(state.draggingItemId).toBeNull();
  });

  it('startDrag/endDrag: ë“œë˜ê·¸ ìƒíƒœë¥¼ ê´€ë¦¬í•´ì•¼ í•œë‹¤', () => {
    const { startDrag, endDrag } = useInventoryStore.getState();

    startDrag('item1');
    expect(useInventoryStore.getState().draggingItemId).toBe('item1');

    endDrag();
    expect(useInventoryStore.getState().draggingItemId).toBeNull();
  });

  it('parseInventoryAdded: ë¬¸ìì—´ ID ëª©ë¡ì„ InventoryItem ë°°ì—´ë¡œ ë³€í™˜í•´ì•¼ í•œë‹¤', () => {
    const addedIds = ['item-a', 'item-b'];
    const parsed = parseInventoryAdded(addedIds);

    expect(parsed).toHaveLength(2);
    expect(parsed[0]).toEqual({ id: 'item-a', name: 'item-a', quantity: 1 });
    expect(parsed[1]).toEqual({ id: 'item-b', name: 'item-b', quantity: 1 });
  });
});
</file>

<file path="frontend/src/stores/inventoryStore.ts">
/**
 * Unknown World - Inventory ìƒíƒœ ê´€ë¦¬ (Zustand) (U-011[Mvp]).
 *
 * Inventoryì˜ ì•„ì´í…œ ëª©ë¡, ë“œë˜ê·¸ ìƒíƒœ, ì„ íƒ ìƒíƒœë¥¼ ê´€ë¦¬í•©ë‹ˆë‹¤.
 *
 * ì„¤ê³„ ì›ì¹™:
 *   - RULE-002: InventoryëŠ” ê²Œì„ UIë¡œ ìƒì‹œ ë…¸ì¶œ
 *   - U-006 ì˜ì¡´: WorldDelta.inventory_added / inventory_removed í•„ë“œ ì—°ë™
 *   - U-012 ì—°ê²°: ë“œë˜ê·¸ ë°ì´í„°ì— item_idë¥¼ ì‹¤ì–´ ë“œë¡­ íƒ€ê²Ÿ(í•«ìŠ¤íŒŸ)ì— ì „ë‹¬
 *
 * @module stores/inventoryStore
 */

import { create } from 'zustand';

// =============================================================================
// íƒ€ì… ì •ì˜
// =============================================================================

/**
 * ì¸ë²¤í† ë¦¬ ì•„ì´í…œ.
 * MVPì—ì„œëŠ” ìµœì†Œ í•„ë“œë§Œ ì •ì˜í•©ë‹ˆë‹¤.
 */
export interface InventoryItem {
  /** ì•„ì´í…œ ê³ ìœ  ID */
  id: string;
  /** ì•„ì´í…œ ì´ë¦„ (í‘œì‹œìš©) */
  name: string;
  /** ì•„ì´í…œ ì„¤ëª… (ì„ íƒ) */
  description?: string;
  /** ì•„ì´í…œ ì•„ì´ì½˜ URL ë˜ëŠ” ì´ëª¨ì§€ (ì„ íƒ) */
  icon?: string;
  /** ì•„ì´í…œ ìˆ˜ëŸ‰ (ê¸°ë³¸ê°’: 1) */
  quantity: number;
}

/** Inventory ìƒíƒœ */
export interface InventoryState {
  /** í˜„ì¬ ì•„ì´í…œ ëª©ë¡ */
  items: InventoryItem[];
  /** í˜„ì¬ ë“œë˜ê·¸ ì¤‘ì¸ ì•„ì´í…œ ID (nullì´ë©´ ë“œë˜ê·¸ ì¤‘ ì•„ë‹˜) */
  draggingItemId: string | null;
  /** ì„ íƒëœ ì•„ì´í…œ ID (í´ë¦­ ì„ íƒ, ë“œë˜ê·¸ì™€ ë³„ê°œ) */
  selectedItemId: string | null;
}

/** Inventory ì•¡ì…˜ */
export interface InventoryActions {
  /** ì•„ì´í…œ ëª©ë¡ ì„¤ì • (ì „ì²´ êµì²´) */
  setItems: (items: InventoryItem[]) => void;
  /** ì•„ì´í…œ ì¶”ê°€ (ì¤‘ë³µ IDë©´ ìˆ˜ëŸ‰ ì¦ê°€) */
  addItems: (items: InventoryItem[]) => void;
  /** ì•„ì´í…œ ì œê±° (ID ëª©ë¡) */
  removeItems: (itemIds: string[]) => void;
  /** ë“œë˜ê·¸ ì‹œì‘ */
  startDrag: (itemId: string) => void;
  /** ë“œë˜ê·¸ ì¢…ë£Œ */
  endDrag: () => void;
  /** ì•„ì´í…œ ì„ íƒ */
  selectItem: (itemId: string | null) => void;
  /** ìƒíƒœ ì´ˆê¸°í™” */
  reset: () => void;
}

export type InventoryStore = InventoryState & InventoryActions;

// =============================================================================
// ì´ˆê¸° ìƒíƒœ
// =============================================================================

function createInitialState(): InventoryState {
  return {
    items: [],
    draggingItemId: null,
    selectedItemId: null,
  };
}

// =============================================================================
// Zustand Store
// =============================================================================

/**
 * Inventory ìƒíƒœ ìŠ¤í† ì–´.
 *
 * @example
 * ```tsx
 * const { items, addItems, removeItems, startDrag, endDrag } = useInventoryStore();
 *
 * // TurnOutput.world.inventory_added ìˆ˜ì‹  ì‹œ
 * addItems(inventoryAddedItems);
 *
 * // TurnOutput.world.inventory_removed ìˆ˜ì‹  ì‹œ
 * removeItems(inventoryRemovedIds);
 *
 * // dnd-kit onDragStart
 * startDrag(itemId);
 *
 * // dnd-kit onDragEnd
 * endDrag();
 * ```
 */
export const useInventoryStore = create<InventoryStore>((set) => ({
  // ì´ˆê¸° ìƒíƒœ
  ...createInitialState(),

  // ì•¡ì…˜
  setItems: (items) => {
    set({
      items,
      draggingItemId: null,
      selectedItemId: null,
    });
  },

  addItems: (newItems) => {
    set((state) => {
      const itemsMap = new Map(state.items.map((item) => [item.id, item]));

      for (const newItem of newItems) {
        const existing = itemsMap.get(newItem.id);
        if (existing) {
          // ê¸°ì¡´ ì•„ì´í…œì´ë©´ ìˆ˜ëŸ‰ ì¦ê°€
          itemsMap.set(newItem.id, {
            ...existing,
            quantity: existing.quantity + newItem.quantity,
          });
        } else {
          // ìƒˆ ì•„ì´í…œ ì¶”ê°€
          itemsMap.set(newItem.id, newItem);
        }
      }

      return { items: Array.from(itemsMap.values()) };
    });
  },

  removeItems: (itemIds) => {
    set((state) => {
      const removeSet = new Set(itemIds);
      return {
        items: state.items.filter((item) => !removeSet.has(item.id)),
        // ì œê±°ëœ ì•„ì´í…œì´ ì„ íƒ/ë“œë˜ê·¸ ì¤‘ì´ì—ˆë‹¤ë©´ ì´ˆê¸°í™”
        selectedItemId: removeSet.has(state.selectedItemId ?? '') ? null : state.selectedItemId,
        draggingItemId: removeSet.has(state.draggingItemId ?? '') ? null : state.draggingItemId,
      };
    });
  },

  startDrag: (itemId) => {
    set({ draggingItemId: itemId });
  },

  endDrag: () => {
    set({ draggingItemId: null });
  },

  selectItem: (itemId) => {
    set({ selectedItemId: itemId });
  },

  reset: () => {
    set(createInitialState());
  },
}));

// =============================================================================
// ì…€ë ‰í„° (ì„±ëŠ¥ ìµœì í™”ìš©)
// =============================================================================

/** ì•„ì´í…œ ëª©ë¡ ì…€ë ‰í„° */
export const selectItems = (state: InventoryStore) => state.items;

/** ë“œë˜ê·¸ ì¤‘ì¸ ì•„ì´í…œ ID ì…€ë ‰í„° */
export const selectDraggingItemId = (state: InventoryStore) => state.draggingItemId;

/** ë“œë˜ê·¸ ì¤‘ì¸ ì•„ì´í…œ ê°ì²´ ì…€ë ‰í„° */
export const selectDraggingItem = (state: InventoryStore) =>
  state.items.find((item) => item.id === state.draggingItemId) ?? null;

/** ì„ íƒëœ ì•„ì´í…œ ID ì…€ë ‰í„° */
export const selectSelectedItemId = (state: InventoryStore) => state.selectedItemId;

/** ì„ íƒëœ ì•„ì´í…œ ê°ì²´ ì…€ë ‰í„° */
export const selectSelectedItem = (state: InventoryStore) =>
  state.items.find((item) => item.id === state.selectedItemId) ?? null;

/** ì•„ì´í…œ ê°œìˆ˜ ì…€ë ‰í„° */
export const selectItemCount = (state: InventoryStore) => state.items.length;

// =============================================================================
// ìœ í‹¸ë¦¬í‹° í•¨ìˆ˜
// =============================================================================

/**
 * ì„œë²„ ì‘ë‹µ(inventory_added ë¬¸ìì—´ ë°°ì—´)ì„ InventoryItem ë°°ì—´ë¡œ ë³€í™˜í•©ë‹ˆë‹¤.
 * MVPì—ì„œëŠ” ë¬¸ìì—´ IDë¥¼ ê¸°ë³¸ ì•„ì´í…œìœ¼ë¡œ ë³€í™˜í•©ë‹ˆë‹¤.
 *
 * @param addedIds - ì¶”ê°€ëœ ì•„ì´í…œ ID ëª©ë¡ (ì„œë²„ ì‘ë‹µ)
 * @returns InventoryItem ë°°ì—´
 */
export function parseInventoryAdded(addedIds: string[]): InventoryItem[] {
  return addedIds.map((id) => ({
    id,
    name: id, // MVP: IDë¥¼ ì´ë¦„ìœ¼ë¡œ ì‚¬ìš©
    quantity: 1,
  }));
}

/**
 * ì•„ì´í…œ IDë¡œ ì•„ì´í…œì„ ì°¾ìŠµë‹ˆë‹¤.
 *
 * @param items - ì•„ì´í…œ ëª©ë¡
 * @param itemId - ì°¾ì„ ì•„ì´í…œ ID
 * @returns ì•„ì´í…œ ë˜ëŠ” undefined
 */
export function findItemById(items: InventoryItem[], itemId: string): InventoryItem | undefined {
  return items.find((item) => item.id === itemId);
}
</file>

<file path="frontend/src/types/scene.ts">
/**
 * Scene Canvas ê´€ë ¨ íƒ€ì… ì •ì˜ (U-031: Placeholder Pack)
 */

/**
 * Scene Canvas ìƒíƒœ íƒ€ì…
 * - default: ê¸°ë³¸ ìƒíƒœ (ì¥ë©´ ì´ë¯¸ì§€ ì—†ìŒ)
 * - loading: ë°ì´í„° ë¡œë”© ì¤‘
 * - offline: ì˜¤í”„ë¼ì¸/ì—°ê²° ëŠê¹€
 * - blocked: ì•ˆì „/ì •ì±… ì°¨ë‹¨
 * - low_signal: ì¬í™”/ì‹ í˜¸ ë¶€ì¡±
 * - scene: ì •ìƒ ì¥ë©´ í‘œì‹œ (ì´ë¯¸ì§€ URL í¬í•¨)
 */
export type SceneCanvasStatus =
  | 'default'
  | 'loading'
  | 'offline'
  | 'blocked'
  | 'low_signal'
  | 'scene';

/**
 * Scene Canvas ìƒíƒœ ë°ì´í„° êµ¬ì¡°
 */
export interface SceneCanvasState {
  status: SceneCanvasStatus;
  imageUrl?: string;
  message?: string;
}

/**
 * ìƒíƒœë³„ placeholder ì •ë³´ êµ¬ì¡°
 */
export interface PlaceholderInfo {
  imagePath: string;
  fallbackEmoji: string;
  labelKey: string;
}
</file>

<file path="frontend/src/utils/box2d.test.ts">
import { describe, it, expect } from 'vitest';
import {
  box2dToPixel,
  pixelToBox2d,
  isValidBox2D,
  box2dArea,
  box2dCenter,
  NORMALIZED_MAX,
} from './box2d';
import type { Box2D } from '../schemas/turn';

describe('box2d utils', () => {
  const canvas = { width: 800, height: 600 };

  describe('box2dToPixel', () => {
    it('should correctly convert normalized coordinates to pixels', () => {
      const normalized: Box2D = { ymin: 100, xmin: 200, ymax: 500, xmax: 800 };
      const pixel = box2dToPixel(normalized, canvas);

      // top = 100 * (600 / 1000) = 60
      // left = 200 * (800 / 1000) = 160
      // bottom = 500 * (600 / 1000) = 300
      // right = 800 * (800 / 1000) = 640
      // width = 640 - 160 = 480
      // height = 300 - 60 = 240

      expect(pixel).toEqual({
        top: 60,
        left: 160,
        width: 480,
        height: 240,
      });
    });

    it('should handle full canvas size', () => {
      const normalized: Box2D = { ymin: 0, xmin: 0, ymax: 1000, xmax: 1000 };
      const pixel = box2dToPixel(normalized, canvas);

      expect(pixel).toEqual({
        top: 0,
        left: 0,
        width: 800,
        height: 600,
      });
    });
  });

  describe('pixelToBox2d', () => {
    it('should correctly convert pixels back to normalized coordinates', () => {
      const pixel = { top: 60, left: 160, width: 480, height: 240 };
      const normalized = pixelToBox2d(pixel, canvas);

      expect(normalized).toEqual({
        ymin: 100,
        xmin: 200,
        ymax: 500,
        xmax: 800,
      });
    });

    it('should round and clamp values', () => {
      const pixel = { top: -10, left: -20, width: 900, height: 700 };
      const normalized = pixelToBox2d(pixel, canvas);

      expect(normalized.ymin).toBe(0);
      expect(normalized.xmin).toBe(0);
      expect(normalized.ymax).toBe(NORMALIZED_MAX);
      expect(normalized.xmax).toBe(NORMALIZED_MAX);
    });
  });

  describe('isValidBox2D', () => {
    it('should return true for valid boxes', () => {
      expect(isValidBox2D({ ymin: 100, xmin: 100, ymax: 200, xmax: 200 })).toBe(true);
      expect(isValidBox2D({ ymin: 0, xmin: 0, ymax: 1000, xmax: 1000 })).toBe(true);
    });

    it('should return false for out of range values', () => {
      expect(isValidBox2D({ ymin: -1, xmin: 0, ymax: 100, xmax: 100 })).toBe(false);
      expect(isValidBox2D({ ymin: 0, xmin: 0, ymax: 1001, xmax: 100 })).toBe(false);
    });

    it('should return false for invalid order', () => {
      expect(isValidBox2D({ ymin: 500, xmin: 100, ymax: 400, xmax: 200 })).toBe(false);
      expect(isValidBox2D({ ymin: 100, xmin: 500, ymax: 200, xmax: 400 })).toBe(false);
    });
  });

  describe('box2dArea', () => {
    it('should calculate area correctly', () => {
      const box = { ymin: 100, xmin: 100, ymax: 200, xmax: 300 };
      expect(box2dArea(box)).toBe(20000); // (200-100) * (300-100) = 100 * 200
    });
  });

  describe('box2dCenter', () => {
    it('should calculate center correctly', () => {
      const box = { ymin: 100, xmin: 100, ymax: 300, xmax: 500 };
      expect(box2dCenter(box)).toEqual({ x: 300, y: 200 });
    });
  });
});
</file>

<file path="frontend/src/utils/box2d.ts">
/**
 * Unknown World - Box2D ì¢Œí‘œ ë³€í™˜ ìœ í‹¸ë¦¬í‹°
 *
 * RULE-009 ì¤€ìˆ˜: ì¢Œí‘œ ê·œì•½ (0~1000 ì •ê·œí™”, bbox=[ymin,xmin,ymax,xmax])
 * - ì„œë²„/ì„¸ì´ë¸Œì—ëŠ” í•­ìƒ box_2d(0~1000)ë¥¼ ìœ ì§€
 * - ë Œë”ì—ì„œë§Œ viewport í¬ê¸°(canvasW/H)ì— ë§ì¶° pxë¡œ ë³€í™˜
 *
 * @module utils/box2d
 */

import type { Box2D } from '../schemas/turn';

// =============================================================================
// ìƒìˆ˜ ì •ì˜
// =============================================================================

/**
 * ì •ê·œí™” ì¢Œí‘œê³„ ìµœëŒ“ê°’ (0~1000).
 * RULE-009: ì¢Œí‘œ ê·œì•½
 */
export const NORMALIZED_MAX = 1000;

// =============================================================================
// íƒ€ì… ì •ì˜
// =============================================================================

/**
 * í”½ì…€ ë‹¨ìœ„ ë°”ìš´ë”© ë°•ìŠ¤.
 * ë Œë”ë§ìš©ìœ¼ë¡œë§Œ ì‚¬ìš©ë©ë‹ˆë‹¤.
 */
export interface Box2DPixel {
  /** Y ìµœì†Œê°’ (ìƒë‹¨, í”½ì…€) */
  top: number;
  /** X ìµœì†Œê°’ (ì¢Œì¸¡, í”½ì…€) */
  left: number;
  /** ë„ˆë¹„ (í”½ì…€) */
  width: number;
  /** ë†’ì´ (í”½ì…€) */
  height: number;
}

/**
 * ìº”ë²„ìŠ¤ í¬ê¸° ì •ë³´.
 */
export interface CanvasSize {
  /** ìº”ë²„ìŠ¤ ë„ˆë¹„ (í”½ì…€) */
  width: number;
  /** ìº”ë²„ìŠ¤ ë†’ì´ (í”½ì…€) */
  height: number;
}

// =============================================================================
// ë³€í™˜ í•¨ìˆ˜
// =============================================================================

/**
 * ì •ê·œí™” ì¢Œí‘œ(0~1000)ë¥¼ í”½ì…€ ì¢Œí‘œë¡œ ë³€í™˜í•©ë‹ˆë‹¤.
 *
 * RULE-009: bbox ìˆœì„œëŠ” [ymin, xmin, ymax, xmax]
 *
 * @param box - ì •ê·œí™” ì¢Œí‘œ ë°”ìš´ë”© ë°•ìŠ¤
 * @param canvas - ìº”ë²„ìŠ¤ í¬ê¸°
 * @returns í”½ì…€ ë‹¨ìœ„ ë°”ìš´ë”© ë°•ìŠ¤
 *
 * @example
 * ```ts
 * const normalized: Box2D = { ymin: 100, xmin: 200, ymax: 500, xmax: 800 };
 * const canvas = { width: 800, height: 600 };
 * const pixel = box2dToPixel(normalized, canvas);
 * // pixel = { top: 60, left: 160, width: 480, height: 240 }
 * ```
 */
export function box2dToPixel(box: Box2D, canvas: CanvasSize): Box2DPixel {
  const scaleX = canvas.width / NORMALIZED_MAX;
  const scaleY = canvas.height / NORMALIZED_MAX;

  const top = box.ymin * scaleY;
  const left = box.xmin * scaleX;
  const bottom = box.ymax * scaleY;
  const right = box.xmax * scaleX;

  return {
    top,
    left,
    width: right - left,
    height: bottom - top,
  };
}

/**
 * í”½ì…€ ì¢Œí‘œë¥¼ ì •ê·œí™” ì¢Œí‘œ(0~1000)ë¡œ ë³€í™˜í•©ë‹ˆë‹¤.
 *
 * ì—­ë³€í™˜ì´ í•„ìš”í•œ ê²½ìš° ì‚¬ìš©í•©ë‹ˆë‹¤ (ì˜ˆ: í´ë¦­ ìœ„ì¹˜ â†’ ì •ê·œí™” ì¢Œí‘œ).
 *
 * @param pixel - í”½ì…€ ë‹¨ìœ„ ë°”ìš´ë”© ë°•ìŠ¤
 * @param canvas - ìº”ë²„ìŠ¤ í¬ê¸°
 * @returns ì •ê·œí™” ì¢Œí‘œ ë°”ìš´ë”© ë°•ìŠ¤
 */
export function pixelToBox2d(pixel: Box2DPixel, canvas: CanvasSize): Box2D {
  const scaleX = NORMALIZED_MAX / canvas.width;
  const scaleY = NORMALIZED_MAX / canvas.height;

  const ymin = Math.round(pixel.top * scaleY);
  const xmin = Math.round(pixel.left * scaleX);
  const ymax = Math.round((pixel.top + pixel.height) * scaleY);
  const xmax = Math.round((pixel.left + pixel.width) * scaleX);

  // RULE-009: 0~1000 ë²”ìœ„ ë³´ì¥
  return {
    ymin: Math.max(0, Math.min(NORMALIZED_MAX, ymin)),
    xmin: Math.max(0, Math.min(NORMALIZED_MAX, xmin)),
    ymax: Math.max(0, Math.min(NORMALIZED_MAX, ymax)),
    xmax: Math.max(0, Math.min(NORMALIZED_MAX, xmax)),
  };
}

/**
 * Box2Dê°€ ìœ íš¨í•œì§€ ê²€ì¦í•©ë‹ˆë‹¤.
 *
 * @param box - ê²€ì¦í•  ë°”ìš´ë”© ë°•ìŠ¤
 * @returns ìœ íš¨ ì—¬ë¶€
 */
export function isValidBox2D(box: Box2D): boolean {
  // 0~1000 ë²”ìœ„ ì²´í¬
  if (
    box.ymin < 0 ||
    box.ymin > NORMALIZED_MAX ||
    box.xmin < 0 ||
    box.xmin > NORMALIZED_MAX ||
    box.ymax < 0 ||
    box.ymax > NORMALIZED_MAX ||
    box.xmax < 0 ||
    box.xmax > NORMALIZED_MAX
  ) {
    return false;
  }

  // ymin < ymax, xmin < xmax ì²´í¬
  if (box.ymin >= box.ymax || box.xmin >= box.xmax) {
    return false;
  }

  return true;
}

/**
 * Box2Dì˜ ë©´ì ì„ ê³„ì‚°í•©ë‹ˆë‹¤ (ì •ê·œí™” ì¢Œí‘œ ê¸°ì¤€).
 *
 * @param box - ë°”ìš´ë”© ë°•ìŠ¤
 * @returns ë©´ì  (0~1000000)
 */
export function box2dArea(box: Box2D): number {
  return (box.ymax - box.ymin) * (box.xmax - box.xmin);
}

/**
 * Box2Dì˜ ì¤‘ì‹¬ì ì„ ê³„ì‚°í•©ë‹ˆë‹¤ (ì •ê·œí™” ì¢Œí‘œ ê¸°ì¤€).
 *
 * @param box - ë°”ìš´ë”© ë°•ìŠ¤
 * @returns ì¤‘ì‹¬ì  ì¢Œí‘œ {x, y}
 */
export function box2dCenter(box: Box2D): { x: number; y: number } {
  return {
    x: (box.xmin + box.xmax) / 2,
    y: (box.ymin + box.ymax) / 2,
  };
}
</file>

<file path="frontend/src/vite-env.d.ts">
/// <reference types="vite/client" />
</file>

<file path="frontend/tsconfig.node.json">
{
  "compilerOptions": {
    "target": "ES2022",
    "lib": ["ES2022"],
    "module": "ESNext",
    "skipLibCheck": true,

    /* Bundler mode */
    "moduleResolution": "Bundler",
    "allowImportingTsExtensions": true,
    "isolatedModules": true,
    "moduleDetection": "force",

    /* Composite for project references */
    "composite": true,
    "emitDeclarationOnly": true,
    "declaration": true,
    "declarationMap": true,

    /* Linting (ì—„ê²© ëª¨ë“œ) */
    "strict": true,
    "noUnusedLocals": true,
    "noUnusedParameters": true,
    "noFallthroughCasesInSwitch": true,
    "noUncheckedSideEffectImports": true
  },
  "include": ["vite.config.ts"]
}
</file>

<file path="backend/src/unknown_world/api/turn_stream_events.py">
"""Unknown World - Turn Stream ì´ë²¤íŠ¸ ê³„ì•½(Contract).

NDJSON ìŠ¤íŠ¸ë¦¬ë°ì—ì„œ ì‚¬ìš©ë˜ëŠ” ì´ë²¤íŠ¸ íƒ€ì…, ëª¨ë¸, ìœ í‹¸ë¦¬í‹°ë¥¼ ì •ì˜í•©ë‹ˆë‹¤.
ì´ ëª¨ë“ˆì€ Orchestrator â†” API â†” Frontend ê°„ì˜ ìŠ¤íŠ¸ë¦¼ ì´ë²¤íŠ¸ ê³„ì•½ SSOTì…ë‹ˆë‹¤.

ì„¤ê³„ ì›ì¹™:
    - RU-002-Q4: ì´ë²¤íŠ¸ ê³„ì•½ì„ transport ê³„ì¸µìœ¼ë¡œ ë¶„ë¦¬
    - RULE-003: êµ¬ì¡°í™” ì¶œë ¥(JSON Schema) ìš°ì„  + Pydantic ê²€ì¦
    - RULE-008: ë‹¨ê³„/ë°°ì§€ ê°€ì‹œí™”

ì°¸ì¡°:
    - vibe/unit-plans/U-007[Mvp].md
    - vibe/refactors/RU-002-Q4.md
"""

from __future__ import annotations

import json
from typing import Annotated, Any

from pydantic import BaseModel, Field

# =============================================================================
# ìŠ¤íŠ¸ë¦¼ ì´ë²¤íŠ¸ íƒ€ì… ìƒìˆ˜
# =============================================================================


class StreamEventType:
    """ìŠ¤íŠ¸ë¦¼ ì´ë²¤íŠ¸ íƒ€ì… ìƒìˆ˜.

    NDJSON ìŠ¤íŠ¸ë¦¬ë°ì—ì„œ ì‚¬ìš©ë˜ëŠ” ì´ë²¤íŠ¸ íƒ€ì…ì…ë‹ˆë‹¤.
    PRD ì˜ˆì‹œ ë‹¨ê³„: Parseâ†’Validateâ†’Planâ†’Resolveâ†’Renderâ†’Verifyâ†’Commit
    """

    STAGE = "stage"
    BADGES = "badges"
    NARRATIVE_DELTA = "narrative_delta"
    FINAL = "final"
    ERROR = "error"
    REPAIR = "repair"


class StageStatus:
    """ë‹¨ê³„ ìƒíƒœ ìƒìˆ˜."""

    START = "start"
    COMPLETE = "complete"
    FAIL = "fail"


# =============================================================================
# ìŠ¤íŠ¸ë¦¼ ì´ë²¤íŠ¸ ëª¨ë¸ (Pydantic)
# =============================================================================


class StageEvent(BaseModel):
    """ë‹¨ê³„ ì§„í–‰ ì´ë²¤íŠ¸.

    Attributes:
        type: ì´ë²¤íŠ¸ íƒ€ì… ("stage")
        name: ë‹¨ê³„ ì´ë¦„ (Parse, Validate, Plan, Resolve, Render, Verify, Commit)
        status: ìƒíƒœ (start, complete)
    """

    type: Annotated[str, Field(default=StreamEventType.STAGE)]
    name: str
    status: str


class RepairEvent(BaseModel):
    """ìë™ ë³µêµ¬(Repair) ì´ë²¤íŠ¸.

    Attributes:
        type: ì´ë²¤íŠ¸ íƒ€ì… ("repair")
        attempt: í˜„ì¬ ì‹œë„ íšŸìˆ˜
        message: ë³µêµ¬ ë©”ì‹œì§€ (ì„ íƒ)
    """

    type: Annotated[str, Field(default=StreamEventType.REPAIR)]
    attempt: int
    message: str | None = None


class BadgesEvent(BaseModel):
    """ë°°ì§€ ì´ë²¤íŠ¸.

    Attributes:
        type: ì´ë²¤íŠ¸ íƒ€ì… ("badges")
        badges: ê²€ì¦ ë°°ì§€ ëª©ë¡
    """

    type: Annotated[str, Field(default=StreamEventType.BADGES)]
    badges: list[str]


class NarrativeDeltaEvent(BaseModel):
    """ë‚´ëŸ¬í‹°ë¸Œ ë¸íƒ€ ì´ë²¤íŠ¸ (íƒ€ì íš¨ê³¼ìš©).

    Attributes:
        type: ì´ë²¤íŠ¸ íƒ€ì… ("narrative_delta")
        text: ì¶”ê°€ëœ í…ìŠ¤íŠ¸ ì¡°ê°
    """

    type: Annotated[str, Field(default=StreamEventType.NARRATIVE_DELTA)]
    text: str


class FinalEvent(BaseModel):
    """ìµœì¢… TurnOutput ì´ë²¤íŠ¸.

    Attributes:
        type: ì´ë²¤íŠ¸ íƒ€ì… ("final")
        data: ì™„ì „í•œ TurnOutput

    Note:
        TurnOutputì€ TYPE_CHECKING ë¸”ë¡ì—ì„œ importë˜ë©°,
        ëŸ°íƒ€ì„ì—ëŠ” Anyë¡œ ì²˜ë¦¬ë©ë‹ˆë‹¤.
    """

    type: Annotated[str, Field(default=StreamEventType.FINAL)]
    data: Any  # TurnOutput (ìˆœí™˜ import ë°©ì§€)


class ErrorEvent(BaseModel):
    """ì—ëŸ¬ ì´ë²¤íŠ¸.

    Attributes:
        type: ì´ë²¤íŠ¸ íƒ€ì… ("error")
        message: ì—ëŸ¬ ë©”ì‹œì§€ (í”„ë¡¬í”„íŠ¸/ë‚´ë¶€ ì¶”ë¡  ë…¸ì¶œ ê¸ˆì§€)
        code: ì—ëŸ¬ ì½”ë“œ (ì„ íƒ)
    """

    type: Annotated[str, Field(default=StreamEventType.ERROR)]
    message: str
    code: str | None = None


# =============================================================================
# ìœ í‹¸ë¦¬í‹° í•¨ìˆ˜
# =============================================================================


def serialize_event(event: dict[str, Any]) -> str:
    """ì´ë²¤íŠ¸ë¥¼ NDJSON ë¼ì¸ìœ¼ë¡œ ì§ë ¬í™”í•©ë‹ˆë‹¤.

    Args:
        event: ì§ë ¬í™”í•  ì´ë²¤íŠ¸ ë”•ì…”ë„ˆë¦¬

    Returns:
        str: NDJSON í˜•ì‹ ë¬¸ìì—´ (ì¤„ë°”ê¿ˆ í¬í•¨)
    """
    return json.dumps(event, ensure_ascii=False) + "\n"


# =============================================================================
# ëª¨ë“ˆ ê³µê°œ API
# =============================================================================

__all__ = [
    "StreamEventType",
    "StageStatus",
    "StageEvent",
    "RepairEvent",
    "BadgesEvent",
    "NarrativeDeltaEvent",
    "FinalEvent",
    "ErrorEvent",
    "serialize_event",
]
</file>

<file path="backend/src/unknown_world/models/turn.py">
"""Unknown World - TurnInput/TurnOutput Pydantic ìŠ¤í‚¤ë§ˆ.

ì´ ëª¨ë“ˆì€ Unknown Worldì˜ í•µì‹¬ ë°ì´í„° ëª¨ë¸ì„ ì •ì˜í•©ë‹ˆë‹¤.
Gemini Structured Outputsì— íˆ¬ì… ê°€ëŠ¥í•œ JSON Schema(ë¶€ë¶„ì§‘í•©)ë¥¼ ìƒì„±í•  ìˆ˜ ìˆìŠµë‹ˆë‹¤.

ì„¤ê³„ ì›ì¹™:
    - RULE-003: êµ¬ì¡°í™” ì¶œë ¥(JSON Schema) ìš°ì„  + ì´ì¤‘ ê²€ì¦
    - RULE-005: ì¬í™” ì¸ë°”ë¦¬ì–¸íŠ¸ (cost, balance_after í•„ìˆ˜, ì”ì•¡ ìŒìˆ˜ ê¸ˆì§€)
    - RULE-006: ko/en ì–¸ì–´ ì •ì±… (Language enumìœ¼ë¡œ ê³ ì •)
    - RULE-009: ì¢Œí‘œ ê·œì•½ (0~1000, bbox [ymin,xmin,ymax,xmax])

ì‚¬ìš© ì˜ˆì‹œ:
    # Gemini Structured Outputsìš© JSON Schema ìƒì„±
    schema = TurnOutput.model_json_schema()

    # ì‘ë‹µ ê²€ì¦
    output = TurnOutput.model_validate_json(gemini_response_text)

ì°¸ì¡°:
    - vibe/prd.md 8.7 (ë°ì´í„° ëª¨ë¸ ì„¤ê³„)
    - vibe/ref/structured-outputs-guide.md
    - .cursor/rules/00-core-critical.mdc
"""

from enum import Enum
from typing import Annotated

from pydantic import BaseModel, ConfigDict, Field

# =============================================================================
# ê³µí†µ Enum íƒ€ì…
# =============================================================================


class Language(str, Enum):
    """ì§€ì› ì–¸ì–´ (RULE-006).

    ko/en í˜¼í•© ì¶œë ¥ ê¸ˆì§€. TurnInput.languageë¥¼ SSOTë¡œ ì‚¼ì•„
    ëª¨ë“  UI/ë‚´ëŸ¬í‹°ë¸Œ/ì‹œìŠ¤í…œ ë©”ì‹œì§€ëŠ” ë™ì¼ ì–¸ì–´ë¡œ ê³ ì •í•©ë‹ˆë‹¤.
    """

    KO = "ko-KR"
    EN = "en-US"


class Theme(str, Enum):
    """í…Œë§ˆ ì„¤ì •."""

    DARK = "dark"
    LIGHT = "light"


class AgentPhase(str, Enum):
    """ì—ì´ì „íŠ¸ ì‹¤í–‰ ë‹¨ê³„ (RULE-008).

    ì—ì´ì „íŠ¸í˜• ì‹œìŠ¤í…œì„ì„ UIë¡œ ì¦ëª…í•˜ê¸° ìœ„í•œ ë‹¨ê³„ í‘œì‹œ.
    """

    PARSE = "parse"
    VALIDATE = "validate"
    PLAN = "plan"
    RESOLVE = "resolve"
    RENDER = "render"
    VERIFY = "verify"
    COMMIT = "commit"


class ValidationBadge(str, Enum):
    """ê²€ì¦ ë°°ì§€ (RULE-008).

    í„´ ê²°ê³¼ì— ëŒ€í•œ ê²€ì¦ ìƒíƒœë¥¼ í‘œì‹œí•©ë‹ˆë‹¤.
    """

    SCHEMA_OK = "schema_ok"
    SCHEMA_FAIL = "schema_fail"
    ECONOMY_OK = "economy_ok"
    ECONOMY_FAIL = "economy_fail"
    SAFETY_OK = "safety_ok"
    SAFETY_BLOCKED = "safety_blocked"
    CONSISTENCY_OK = "consistency_ok"
    CONSISTENCY_FAIL = "consistency_fail"


class ModelLabel(str, Enum):
    """ëª¨ë¸/í’ˆì§ˆ ì„ íƒ ë¼ë²¨ (RULE-008).

    í”„ë¡¬í”„íŠ¸ ë…¸ì¶œ ì—†ì´ "ì™œ ì´ ì„ íƒì´ì—ˆëŠ”ì§€"ë¥¼ ì‚¬ìš©ì ì¹œí™” ë¼ë²¨ë¡œ í‘œì‹œ.
    """

    FAST = "FAST"
    QUALITY = "QUALITY"
    CHEAP = "CHEAP"
    REF = "REF"


class RiskLevel(str, Enum):
    """í–‰ë™ ìœ„í—˜ë„ ìˆ˜ì¤€."""

    LOW = "low"
    MEDIUM = "medium"
    HIGH = "high"


# =============================================================================
# ê³µí†µ í•˜ìœ„ íƒ€ì…
# =============================================================================

# RULE-009: ì¢Œí‘œëŠ” 0~1000 ì •ê·œí™” ì¢Œí‘œê³„ (ì´ë¯¸ì§€ ì´í•´ bbox í¬ë§·ê³¼ í˜¸í™˜)
Coordinate = Annotated[int, Field(ge=0, le=1000, description="ì •ê·œí™” ì¢Œí‘œ (0~1000)")]


class Box2D(BaseModel):
    """2D ë°”ìš´ë”© ë°•ìŠ¤ (RULE-009).

    ì¢Œí‘œëŠ” 0~1000 ì •ê·œí™” ì¢Œí‘œê³„ì´ë©°, bboxëŠ” [ymin, xmin, ymax, xmax] ìˆœì„œì…ë‹ˆë‹¤.
    ì´ë¯¸ì§€ ì´í•´ bbox í¬ë§·ê³¼ í˜¸í™˜ë©ë‹ˆë‹¤.

    Attributes:
        ymin: Y ìµœì†Œê°’ (ìƒë‹¨)
        xmin: X ìµœì†Œê°’ (ì¢Œì¸¡)
        ymax: Y ìµœëŒ€ê°’ (í•˜ë‹¨)
        xmax: X ìµœëŒ€ê°’ (ìš°ì¸¡)
    """

    model_config = ConfigDict(extra="forbid")

    ymin: Coordinate
    xmin: Coordinate
    ymax: Coordinate
    xmax: Coordinate


class CurrencyAmount(BaseModel):
    """ì¬í™” ìˆ˜ëŸ‰.

    Attributes:
        signal: ê¸°ë³¸ ì¬í™” (í…ìŠ¤íŠ¸ í„´/ì´ë¯¸ì§€ ìƒì„±/ê³ ê¸‰ ê¸°ëŠ¥ì— ì†Œë¹„)
        memory_shard: í¬ê·€ ì¬í™” (ì¤‘ìš” ì„¤ì • ê³ ì •, ê³ í•´ìƒë„ ì´ë¯¸ì§€ ë“±ì— ì†Œë¹„)
    """

    model_config = ConfigDict(extra="forbid")

    signal: Annotated[int, Field(ge=0, description="ì‹œê·¸ë„ (ê¸°ë³¸ ì¬í™”, 0 ì´ìƒ)")]
    memory_shard: Annotated[int, Field(ge=0, description="ê¸°ì–µ íŒŒí¸ (í¬ê·€ ì¬í™”, 0 ì´ìƒ)")]


# =============================================================================
# TurnInput ê´€ë ¨ íƒ€ì…
# =============================================================================


class ClickInput(BaseModel):
    """í´ë¦­ ì…ë ¥ ì •ë³´.

    í™”ë©´ ì˜¤ë¸Œì íŠ¸ í´ë¦­ ì‹œ ì „ë‹¬ë˜ëŠ” ì •ë³´ì…ë‹ˆë‹¤.

    Attributes:
        object_id: í´ë¦­í•œ ì˜¤ë¸Œì íŠ¸ ID
        box_2d: í´ë¦­ ìœ„ì¹˜ì˜ ë°”ìš´ë”© ë°•ìŠ¤ (ì„ íƒ)
    """

    model_config = ConfigDict(extra="forbid")

    object_id: str = Field(description="í´ë¦­í•œ ì˜¤ë¸Œì íŠ¸ ID")
    box_2d: Box2D | None = Field(default=None, description="í´ë¦­ ìœ„ì¹˜ ë°”ìš´ë”© ë°•ìŠ¤ (ì„ íƒ)")


class ClientInfo(BaseModel):
    """í´ë¼ì´ì–¸íŠ¸ ì •ë³´.

    Attributes:
        viewport_w: ë·°í¬íŠ¸ ë„ˆë¹„ (í”½ì…€)
        viewport_h: ë·°í¬íŠ¸ ë†’ì´ (í”½ì…€)
        theme: í˜„ì¬ í…Œë§ˆ (dark/light)
    """

    model_config = ConfigDict(extra="forbid")

    viewport_w: Annotated[int, Field(gt=0, description="ë·°í¬íŠ¸ ë„ˆë¹„ (í”½ì…€)")]
    viewport_h: Annotated[int, Field(gt=0, description="ë·°í¬íŠ¸ ë†’ì´ (í”½ì…€)")]
    theme: Theme = Field(default=Theme.DARK, description="í˜„ì¬ í…Œë§ˆ")


class EconomySnapshot(BaseModel):
    """ì¬í™” ìŠ¤ëƒ…ìƒ· (í´ë¼ì´ì–¸íŠ¸ â†’ ì„œë²„).

    í´ë¼ì´ì–¸íŠ¸ê°€ ë³´ìœ í•œ í˜„ì¬ ì¬í™” ìƒíƒœì…ë‹ˆë‹¤.
    ì„œë²„ëŠ” ì´ë¥¼ ê²€ì¦í•˜ê³  ë¹„ìš© ê³„ì‚°ì— ì‚¬ìš©í•©ë‹ˆë‹¤.

    Attributes:
        signal: í˜„ì¬ ì‹œê·¸ë„ ì”ì•¡
        memory_shard: í˜„ì¬ ê¸°ì–µ íŒŒí¸ ì”ì•¡
    """

    model_config = ConfigDict(extra="forbid")

    signal: Annotated[int, Field(ge=0, description="í˜„ì¬ ì‹œê·¸ë„ ì”ì•¡ (0 ì´ìƒ)")]
    memory_shard: Annotated[int, Field(ge=0, description="í˜„ì¬ ê¸°ì–µ íŒŒí¸ ì”ì•¡ (0 ì´ìƒ)")]


class TurnInput(BaseModel):
    """í„´ ì…ë ¥ (í´ë¼ì´ì–¸íŠ¸ â†’ ì„œë²„).

    ì‚¬ìš©ìê°€ í„´ì„ ì§„í–‰í•  ë•Œ ì„œë²„ë¡œ ì „ì†¡í•˜ëŠ” ì…ë ¥ ë°ì´í„°ì…ë‹ˆë‹¤.

    Attributes:
        language: ìš”ì²­ ì–¸ì–´ (ì‘ë‹µë„ ë™ì¼ ì–¸ì–´ë¡œ ê³ ì •)
        text: ì‚¬ìš©ì ìì—°ì–´ ì…ë ¥
        action_id: ì„ íƒí•œ ì•¡ì…˜ ì¹´ë“œ ID (ì„ íƒ)
        click: ì˜¤ë¸Œì íŠ¸ í´ë¦­ ì •ë³´ (ì„ íƒ)
        client: í´ë¼ì´ì–¸íŠ¸ í™˜ê²½ ì •ë³´
        economy_snapshot: í˜„ì¬ ì¬í™” ìƒíƒœ

    Example:
        >>> input_data = TurnInput(
        ...     language=Language.KO,
        ...     text="ë¬¸ì„ ì—´ì–´ë³¸ë‹¤",
        ...     economy_snapshot=EconomySnapshot(signal=100, memory_shard=5),
        ...     client=ClientInfo(viewport_w=1920, viewport_h=1080),
        ... )
    """

    model_config = ConfigDict(extra="forbid")

    language: Language = Field(description="ìš”ì²­ ì–¸ì–´ (ì‘ë‹µë„ ë™ì¼ ì–¸ì–´ë¡œ ê³ ì •)")
    text: str = Field(default="", description="ì‚¬ìš©ì ìì—°ì–´ ì…ë ¥")
    action_id: str | None = Field(default=None, description="ì„ íƒí•œ ì•¡ì…˜ ì¹´ë“œ ID (ì„ íƒ)")
    click: ClickInput | None = Field(default=None, description="ì˜¤ë¸Œì íŠ¸ í´ë¦­ ì •ë³´ (ì„ íƒ)")
    client: ClientInfo = Field(description="í´ë¼ì´ì–¸íŠ¸ í™˜ê²½ ì •ë³´")
    economy_snapshot: EconomySnapshot = Field(description="í˜„ì¬ ì¬í™” ìƒíƒœ")


# =============================================================================
# TurnOutput ê´€ë ¨ íƒ€ì… - UI
# =============================================================================


class CostEstimate(BaseModel):
    """ë¹„ìš© ì¶”ì •ì¹˜ (ìµœì†Œ/ìµœëŒ€ ë²”ìœ„)."""

    model_config = ConfigDict(extra="forbid")

    min: CurrencyAmount = Field(description="ìµœì†Œ ì˜ˆìƒ ë¹„ìš©")
    max: CurrencyAmount = Field(description="ìµœëŒ€ ì˜ˆìƒ ë¹„ìš©")


class ActionCard(BaseModel):
    """ì•¡ì…˜ ì¹´ë“œ (Action Deck).

    ë§¤ í„´ AIê°€ ì¶”ì²œí•˜ëŠ” í–‰ë™ ì¹´ë“œì…ë‹ˆë‹¤.
    ê° ì¹´ë“œì— ë¹„ìš©/ìœ„í—˜/ë³´ìƒ íŒíŠ¸ê°€ í¬í•¨ë©ë‹ˆë‹¤.

    Attributes:
        id: ì¹´ë“œ ê³ ìœ  ID
        label: ì¹´ë“œ ë¼ë²¨ (í‘œì‹œìš©)
        description: ì¹´ë“œ ì„¤ëª… (ì„ íƒ)
        cost: ì˜ˆìƒ ë¹„ìš© (ê¸°ë³¸)
        cost_estimate: ë¹„ìš© ì¶”ì • ë²”ìœ„ (ì„ íƒ)
        risk: ìœ„í—˜ë„
        hint: ì˜ˆìƒ ê²°ê³¼ íŒíŠ¸ (ì„ íƒ)
        reward_hint: ë³´ìƒ íŒíŠ¸ (ì„ íƒ)
        enabled: ì‹¤í–‰ ê°€ëŠ¥ ì—¬ë¶€ (ì„œë²„ íŒë‹¨)
        disabled_reason: ë¹„í™œì„±í™” ì‚¬ìœ  (ì„ íƒ)
        is_alternative: ì €ë¹„ìš© ëŒ€ì•ˆ ì¹´ë“œ ì—¬ë¶€
    """

    model_config = ConfigDict(extra="forbid")

    id: str = Field(description="ì¹´ë“œ ê³ ìœ  ID")
    label: str = Field(description="ì¹´ë“œ ë¼ë²¨ (í‘œì‹œìš©)")
    description: str | None = Field(default=None, description="ì¹´ë“œ ì„¤ëª… (ì„ íƒ)")
    cost: CurrencyAmount = Field(description="ì˜ˆìƒ ë¹„ìš© (ê¸°ë³¸)")
    cost_estimate: CostEstimate | None = Field(default=None, description="ë¹„ìš© ì¶”ì • ë²”ìœ„ (ì„ íƒ)")
    risk: RiskLevel = Field(default=RiskLevel.LOW, description="ìœ„í—˜ë„")
    hint: str | None = Field(default=None, description="ì˜ˆìƒ ê²°ê³¼ íŒíŠ¸ (ì„ íƒ)")
    reward_hint: str | None = Field(default=None, description="ë³´ìƒ íŒíŠ¸ (ì„ íƒ)")
    enabled: bool = Field(default=True, description="ì‹¤í–‰ ê°€ëŠ¥ ì—¬ë¶€ (ì„œë²„ íŒë‹¨)")
    disabled_reason: str | None = Field(default=None, description="ë¹„í™œì„±í™” ì‚¬ìœ  (ì„ íƒ)")
    is_alternative: bool = Field(default=False, description="ì €ë¹„ìš© ëŒ€ì•ˆ ì¹´ë“œ ì—¬ë¶€")


class SceneObject(BaseModel):
    """ì¥ë©´ ì˜¤ë¸Œì íŠ¸ (í´ë¦­ ê°€ëŠ¥í•œ í•«ìŠ¤íŒŸ).

    í™”ë©´ì—ì„œ í´ë¦­ ê°€ëŠ¥í•œ ì˜¤ë¸Œì íŠ¸ì…ë‹ˆë‹¤.
    ì¢Œí‘œëŠ” 0~1000 ì •ê·œí™” ì¢Œí‘œê³„ë¥¼ ì‚¬ìš©í•©ë‹ˆë‹¤ (RULE-009).

    Attributes:
        id: ì˜¤ë¸Œì íŠ¸ ê³ ìœ  ID
        label: ì˜¤ë¸Œì íŠ¸ ë¼ë²¨ (í‘œì‹œìš©)
        box_2d: ë°”ìš´ë”© ë°•ìŠ¤ [ymin, xmin, ymax, xmax]
        interaction_hint: ìƒí˜¸ì‘ìš© íŒíŠ¸ (ì„ íƒ)
    """

    model_config = ConfigDict(extra="forbid")

    id: str = Field(description="ì˜¤ë¸Œì íŠ¸ ê³ ìœ  ID")
    label: str = Field(description="ì˜¤ë¸Œì íŠ¸ ë¼ë²¨ (í‘œì‹œìš©)")
    box_2d: Box2D = Field(description="ë°”ìš´ë”© ë°•ìŠ¤")
    interaction_hint: str | None = Field(default=None, description="ìƒí˜¸ì‘ìš© íŒíŠ¸ (ì„ íƒ)")


class ActionDeck(BaseModel):
    """ì•¡ì…˜ ë± (Q1 ê²°ì •: ui.action_deck.cards[] êµ¬ì¡°).

    ë§¤ í„´ AIê°€ ì œì‹œí•˜ëŠ” ì¶”ì²œ í–‰ë™ ì¹´ë“œ ë±ì…ë‹ˆë‹¤.

    Attributes:
        cards: ì•¡ì…˜ ì¹´ë“œ ëª©ë¡ (3~6ì¥ ê¶Œì¥)
    """

    model_config = ConfigDict(extra="forbid")

    cards: list[ActionCard] = Field(
        default=[],
        min_length=0,
        max_length=10,
        description="ì•¡ì…˜ ì¹´ë“œ ëª©ë¡ (3~6ì¥ ê¶Œì¥)",
    )


class UIOutput(BaseModel):
    """UI ì¶œë ¥ ë°ì´í„°.

    AIê°€ ìƒì„±í•œ UI ìš”ì†Œë“¤ì…ë‹ˆë‹¤.
    ì±„íŒ… ë²„ë¸”ì´ ì•„ë‹Œ ê²Œì„ UIë¡œ í‘œí˜„ë©ë‹ˆë‹¤ (RULE-002).

    Attributes:
        action_deck: ì•¡ì…˜ ì¹´ë“œ ë± (Q1 ê²°ì •: Option A ì±„íƒ)
        objects: í´ë¦­ ê°€ëŠ¥í•œ ì¥ë©´ ì˜¤ë¸Œì íŠ¸ ëª©ë¡
    """

    model_config = ConfigDict(extra="forbid")

    action_deck: ActionDeck = Field(default_factory=ActionDeck, description="ì•¡ì…˜ ì¹´ë“œ ë±")
    objects: list[SceneObject] = Field(default=[], description="í´ë¦­ ê°€ëŠ¥í•œ ì¥ë©´ ì˜¤ë¸Œì íŠ¸ ëª©ë¡")


# =============================================================================
# TurnOutput ê´€ë ¨ íƒ€ì… - World
# =============================================================================


class MemoryPin(BaseModel):
    """ì¤‘ìš” ì„¤ì • ê³ ì • í›„ë³´.

    ì‚¬ìš©ìê°€ Memory Shardë¥¼ ì†Œë¹„í•´ ê³ ì •í•  ìˆ˜ ìˆëŠ” ì¤‘ìš” ì„¤ì •ì…ë‹ˆë‹¤.

    Attributes:
        id: í•€ ê³ ìœ  ID
        content: ê³ ì •í•  ë‚´ìš©
        cost: ê³ ì •ì— í•„ìš”í•œ ë¹„ìš©
    """

    model_config = ConfigDict(extra="forbid")

    id: str = Field(description="í•€ ê³ ìœ  ID")
    content: str = Field(description="ê³ ì •í•  ë‚´ìš©")
    cost: CurrencyAmount = Field(description="ê³ ì •ì— í•„ìš”í•œ ë¹„ìš©")


class WorldRule(BaseModel):
    """ì„¸ê³„ ê·œì¹™ (Rule Board).

    í˜„ì¬ ì„¸ê³„ì— ì ìš© ì¤‘ì¸ ë¬¼ë¦¬ ë²•ì¹™ì´ë‚˜ ë©”íƒ€ ê·œì¹™ì…ë‹ˆë‹¤.

    Attributes:
        id: ê·œì¹™ ê³ ìœ  ID
        label: ê·œì¹™ ì´ë¦„
        description: ê·œì¹™ ìƒì„¸ ì„¤ëª… (ì„ íƒ)
    """

    model_config = ConfigDict(extra="forbid")

    id: str = Field(description="ê·œì¹™ ê³ ìœ  ID")
    label: str = Field(description="ê·œì¹™ ì´ë¦„")
    description: str | None = Field(default=None, description="ê·œì¹™ ìƒì„¸ ì„¤ëª… (ì„ íƒ)")


class Quest(BaseModel):
    """í€˜ìŠ¤íŠ¸/ëª©í‘œ (Quest Panel).

    í”Œë ˆì´ì–´ê°€ ë‹¬ì„±í•´ì•¼ í•˜ëŠ” í˜„ì¬ ëª©í‘œì…ë‹ˆë‹¤.

    Attributes:
        id: í€˜ìŠ¤íŠ¸ ê³ ìœ  ID
        label: í€˜ìŠ¤íŠ¸ ì´ë¦„
        is_completed: ë‹¬ì„± ì—¬ë¶€
    """

    model_config = ConfigDict(extra="forbid")

    id: str = Field(description="í€˜ìŠ¤íŠ¸ ê³ ìœ  ID")
    label: str = Field(description="í€˜ìŠ¤íŠ¸ ì´ë¦„")
    is_completed: bool = Field(default=False, description="ë‹¬ì„± ì—¬ë¶€")


class WorldDelta(BaseModel):
    """ì„¸ê³„ ìƒíƒœ ë³€í™” (Q2 ê²°ì •: Option A - delta ì¤‘ì‹¬).

    ì´ë²ˆ í„´ì—ì„œ ë³€ê²½ëœ ì„¸ê³„ ìƒíƒœë¥¼ ë‚˜íƒ€ëƒ…ë‹ˆë‹¤.
    snapshotì€ SaveGameì—ë§Œ ì €ì¥í•˜ê³ , ë§¤ í„´ì€ deltaë§Œ ì „ì†¡í•©ë‹ˆë‹¤.

    Attributes:
        rules_changed: ë³€ê²½ë˜ê±°ë‚˜ ì¶”ê°€ëœ ê·œì¹™ ëª©ë¡
        inventory_added: ì¶”ê°€ëœ ì¸ë²¤í† ë¦¬ ì•„ì´í…œ
        inventory_removed: ì œê±°ëœ ì¸ë²¤í† ë¦¬ ì•„ì´í…œ
        quests_updated: ì—…ë°ì´íŠ¸ëœ í€˜ìŠ¤íŠ¸(ëª©í‘œ) ëª©ë¡
        relationships_changed: ë³€ê²½ëœ ê´€ê³„
        memory_pins: ì¤‘ìš” ì„¤ì • ê³ ì • í›„ë³´
    """

    model_config = ConfigDict(extra="forbid")

    rules_changed: list[WorldRule] = Field(default=[], description="ë³€ê²½ëœ ê·œì¹™ ëª©ë¡")
    inventory_added: list[str] = Field(default=[], description="ì¶”ê°€ëœ ì¸ë²¤í† ë¦¬ ì•„ì´í…œ")
    inventory_removed: list[str] = Field(default=[], description="ì œê±°ëœ ì¸ë²¤í† ë¦¬ ì•„ì´í…œ")
    quests_updated: list[Quest] = Field(default=[], description="ì—…ë°ì´íŠ¸ëœ í€˜ìŠ¤íŠ¸/ëª©í‘œ ëª©ë¡")
    relationships_changed: list[str] = Field(default=[], description="ë³€ê²½ëœ ê´€ê³„")
    memory_pins: list[MemoryPin] = Field(default=[], description="ì¤‘ìš” ì„¤ì • ê³ ì • í›„ë³´")


# =============================================================================
# TurnOutput ê´€ë ¨ íƒ€ì… - Render
# =============================================================================


class ImageJob(BaseModel):
    """ì´ë¯¸ì§€ ìƒì„± ì‘ì—….

    ì¡°ê±´ë¶€ ì´ë¯¸ì§€ ìƒì„±/í¸ì§‘ ìš”ì²­ì…ë‹ˆë‹¤.
    ì´ë¯¸ì§€ ìƒì„±ì´ ëŠë¦´ ê²½ìš° í…ìŠ¤íŠ¸ ìš°ì„  ì¶œë ¥ + Lazy Loadingì„ ì‚¬ìš©í•©ë‹ˆë‹¤.

    Attributes:
        should_generate: ì´ë¯¸ì§€ë¥¼ ìƒì„±í•´ì•¼ í•˜ëŠ”ì§€
        prompt: ì´ë¯¸ì§€ ìƒì„± í”„ë¡¬í”„íŠ¸
        model_label: ëª¨ë¸ ì„ íƒ ë¼ë²¨ (FAST/QUALITY/CHEAP/REF)
        aspect_ratio: ê°€ë¡œì„¸ë¡œ ë¹„ìœ¨ (ì˜ˆ: "16:9", "1:1")
        image_size: ì´ë¯¸ì§€ í¬ê¸° (ì˜ˆ: "1024x1024")
        reference_image_ids: ì°¸ì¡° ì´ë¯¸ì§€ ID ëª©ë¡ (ì„ íƒ)
    """

    model_config = ConfigDict(extra="forbid")

    should_generate: bool = Field(description="ì´ë¯¸ì§€ë¥¼ ìƒì„±í•´ì•¼ í•˜ëŠ”ì§€")
    prompt: str = Field(default="", description="ì´ë¯¸ì§€ ìƒì„± í”„ë¡¬í”„íŠ¸")
    model_label: ModelLabel = Field(default=ModelLabel.FAST, description="ëª¨ë¸ ì„ íƒ ë¼ë²¨")
    aspect_ratio: str = Field(default="16:9", description="ê°€ë¡œì„¸ë¡œ ë¹„ìœ¨")
    image_size: str = Field(default="1024x1024", description="ì´ë¯¸ì§€ í¬ê¸°")
    reference_image_ids: list[str] = Field(default=[], description="ì°¸ì¡° ì´ë¯¸ì§€ ID ëª©ë¡ (ì„ íƒ)")


class RenderOutput(BaseModel):
    """ë Œë”ë§ ì¶œë ¥ ë°ì´í„°.

    ì´ë¯¸ì§€ ìƒì„±/í¸ì§‘ ê´€ë ¨ ì •ë³´ì…ë‹ˆë‹¤.

    Attributes:
        image_job: ì´ë¯¸ì§€ ìƒì„± ì‘ì—… (ì„ íƒ)
    """

    model_config = ConfigDict(extra="forbid")

    image_job: ImageJob | None = Field(default=None, description="ì´ë¯¸ì§€ ìƒì„± ì‘ì—… (ì„ íƒ)")


# =============================================================================
# TurnOutput ê´€ë ¨ íƒ€ì… - Economy
# =============================================================================


class EconomyOutput(BaseModel):
    """ê²½ì œ ì¶œë ¥ ë°ì´í„° (RULE-005).

    ì´ë²ˆ í„´ì˜ ë¹„ìš©ê³¼ ì”ì•¡ ì •ë³´ì…ë‹ˆë‹¤.
    ì”ì•¡ ìŒìˆ˜ëŠ” ì ˆëŒ€ ë¶ˆê°€ (ì„œë²„ Hard gate).

    Attributes:
        cost: ì´ë²ˆ í„´ì— ì†Œë¹„ëœ ë¹„ìš©
        balance_after: ì†Œë¹„ í›„ ì”ì•¡

    Important:
        - costì™€ balance_afterëŠ” í•­ìƒ í¬í•¨ë˜ì–´ì•¼ í•©ë‹ˆë‹¤.
        - balance_afterì˜ signalê³¼ memory_shardëŠ” 0 ì´ìƒì´ì–´ì•¼ í•©ë‹ˆë‹¤.
    """

    model_config = ConfigDict(extra="forbid")

    cost: CurrencyAmount = Field(description="ì´ë²ˆ í„´ì— ì†Œë¹„ëœ ë¹„ìš©")
    balance_after: CurrencyAmount = Field(description="ì†Œë¹„ í›„ ì”ì•¡")


# =============================================================================
# TurnOutput ê´€ë ¨ íƒ€ì… - Safety
# =============================================================================


class SafetyOutput(BaseModel):
    """ì•ˆì „ ì¶œë ¥ ë°ì´í„°.

    ì•ˆì „ ì •ì±… ê´€ë ¨ ì •ë³´ì…ë‹ˆë‹¤.
    ì°¨ë‹¨ ì‹œ ëª…ì‹œì  ë©”ì‹œì§€ì™€ í•¨ê»˜ ì•ˆì „í•œ ëŒ€ì²´ ê²°ê³¼ë¥¼ ì œê³µí•©ë‹ˆë‹¤.

    Attributes:
        blocked: ì•ˆì „ ì •ì±…ì— ì˜í•´ ì°¨ë‹¨ë˜ì—ˆëŠ”ì§€
        message: ì°¨ë‹¨ ì‹œ ì‚¬ìš©ìì—ê²Œ í‘œì‹œí•  ë©”ì‹œì§€ (ì„ íƒ)
    """

    model_config = ConfigDict(extra="forbid")

    blocked: bool = Field(default=False, description="ì•ˆì „ ì •ì±…ì— ì˜í•´ ì°¨ë‹¨ë˜ì—ˆëŠ”ì§€")
    message: str | None = Field(default=None, description="ì°¨ë‹¨ ì‹œ ì‚¬ìš©ìì—ê²Œ í‘œì‹œí•  ë©”ì‹œì§€ (ì„ íƒ)")


# =============================================================================
# TurnOutput ê´€ë ¨ íƒ€ì… - Agent Console
# =============================================================================


class AgentConsole(BaseModel):
    """ì—ì´ì „íŠ¸ ì½˜ì†” ë°ì´í„° (RULE-008).

    ì—ì´ì „íŠ¸í˜• ì‹œìŠ¤í…œì„ì„ UIë¡œ ì¦ëª…í•˜ê¸° ìœ„í•œ ì •ë³´ì…ë‹ˆë‹¤.
    ê³„íš/ì‹¤í–‰/ê²€ì¦/ë³µêµ¬ì˜ í”ì ì„ í‘œì‹œí•©ë‹ˆë‹¤.

    Attributes:
        current_phase: í˜„ì¬ ì‹¤í–‰ ë‹¨ê³„
        badges: ê²€ì¦ ë°°ì§€ ëª©ë¡
        repair_count: ìë™ ë³µêµ¬ ì‹œë„ íšŸìˆ˜
    """

    model_config = ConfigDict(extra="forbid")

    current_phase: AgentPhase = Field(default=AgentPhase.COMMIT, description="í˜„ì¬ ì‹¤í–‰ ë‹¨ê³„")
    badges: list[ValidationBadge] = Field(default=[], description="ê²€ì¦ ë°°ì§€ ëª©ë¡")
    repair_count: Annotated[int, Field(ge=0, description="ìë™ ë³µêµ¬ ì‹œë„ íšŸìˆ˜")] = 0


# =============================================================================
# TurnOutput (ë©”ì¸ ì‘ë‹µ ìŠ¤í‚¤ë§ˆ)
# =============================================================================


class TurnOutput(BaseModel):
    """í„´ ì¶œë ¥ (ì„œë²„ â†’ í´ë¼ì´ì–¸íŠ¸).

    ì„œë²„ê°€ í„´ ì²˜ë¦¬ í›„ í´ë¼ì´ì–¸íŠ¸ë¡œ ë°˜í™˜í•˜ëŠ” êµ¬ì¡°í™”ëœ ì‘ë‹µì…ë‹ˆë‹¤.
    Gemini Structured Outputs(JSON Schema)ë¡œ ê°•ì œë©ë‹ˆë‹¤.

    Hard Gate í•„ë“œ (RULE-003/004/005):
        - economy: costì™€ balance_after í•„ìˆ˜, ì”ì•¡ ìŒìˆ˜ ê¸ˆì§€
        - safety: blocked ì‹œ ì•ˆì „í•œ ëŒ€ì²´ ê²°ê³¼ ì œê³µ
        - language: ìš”ì²­ ì–¸ì–´ì™€ ë™ì¼í•˜ê²Œ ê³ ì • (í˜¼í•© ì¶œë ¥ ê¸ˆì§€)

    Attributes:
        language: ì‘ë‹µ ì–¸ì–´ (ìš”ì²­ê³¼ ë™ì¼)
        narrative: ë‚´ëŸ¬í‹°ë¸Œ í…ìŠ¤íŠ¸ (í‘œì‹œìš©)
        ui: UI ìš”ì†Œ (ì•¡ì…˜ ë±, ì˜¤ë¸Œì íŠ¸)
        world: ì„¸ê³„ ìƒíƒœ ë³€í™” (delta ì¤‘ì‹¬)
        render: ë Œë”ë§ ì •ë³´ (ì´ë¯¸ì§€ ìƒì„± ì‘ì—…)
        economy: ê²½ì œ ì •ë³´ (ë¹„ìš©, ì”ì•¡)
        safety: ì•ˆì „ ì •ì±… ì •ë³´
        agent_console: ì—ì´ì „íŠ¸ ì‹¤í–‰ ì •ë³´ (ë‹¨ê³„, ë°°ì§€, ë³µêµ¬ íšŸìˆ˜)

    Example:
        >>> output = TurnOutput(
        ...     language=Language.KO,
        ...     narrative="ë¬¸ì´ ì‚ê±±ê±°ë¦¬ë©° ì—´ë¦½ë‹ˆë‹¤...",
        ...     economy=EconomyOutput(
        ...         cost=CurrencyAmount(signal=5, memory_shard=0),
        ...         balance_after=CurrencyAmount(signal=95, memory_shard=5),
        ...     ),
        ...     safety=SafetyOutput(blocked=False),
        ... )
        >>> schema = TurnOutput.model_json_schema()

    Schema Generation:
        >>> # Gemini Structured Outputsìš© JSON Schema ìƒì„±
        >>> json_schema = TurnOutput.model_json_schema()
        >>> # response_json_schema íŒŒë¼ë¯¸í„°ì— ì „ë‹¬
        >>> config = {
        ...     "response_mime_type": "application/json",
        ...     "response_json_schema": json_schema,
        ... }
    """

    model_config = ConfigDict(extra="forbid")

    # í•„ìˆ˜ í•„ë“œ (Hard Gate)
    language: Language = Field(description="ì‘ë‹µ ì–¸ì–´ (ìš”ì²­ê³¼ ë™ì¼)")
    narrative: str = Field(description="ë‚´ëŸ¬í‹°ë¸Œ í…ìŠ¤íŠ¸ (í‘œì‹œìš©)")
    economy: EconomyOutput = Field(description="ê²½ì œ ì •ë³´ (ë¹„ìš©, ì”ì•¡)")
    safety: SafetyOutput = Field(description="ì•ˆì „ ì •ì±… ì •ë³´")

    # UI ê´€ë ¨ í•„ë“œ
    ui: UIOutput = Field(default_factory=UIOutput, description="UI ìš”ì†Œ")

    # ì„¸ê³„ ìƒíƒœ í•„ë“œ
    world: WorldDelta = Field(default_factory=WorldDelta, description="ì„¸ê³„ ìƒíƒœ ë³€í™” (delta)")

    # ë Œë”ë§ í•„ë“œ
    render: RenderOutput = Field(default_factory=RenderOutput, description="ë Œë”ë§ ì •ë³´")

    # ì—ì´ì „íŠ¸ ì½˜ì†” í•„ë“œ
    agent_console: AgentConsole = Field(
        default_factory=AgentConsole, description="ì—ì´ì „íŠ¸ ì‹¤í–‰ ì •ë³´"
    )
</file>

<file path="backend/tests/integration/test_turn_streaming.py">
"""Unknown World - /api/turn HTTP Streaming í†µí•© í…ŒìŠ¤íŠ¸.

NDJSON ìŠ¤íŠ¸ë¦¬ë° ì´ë²¤íŠ¸ì˜ ìˆœì„œ, êµ¬ì¡°, ë°ì´í„° ì •ë°€ë„ë¥¼ ê²€ì¦í•©ë‹ˆë‹¤.
"""

import json

from fastapi.testclient import TestClient

from unknown_world.main import app
from unknown_world.models.turn import Language, TurnOutput

client = TestClient(app)


def test_turn_streaming_success():
    """ì •ìƒì ì¸ í„´ ìš”ì²­ ì‹œ NDJSON ìŠ¤íŠ¸ë¦¼ì´ ì˜¬ë°”ë¥¸ ìˆœì„œë¡œ ë°˜í™˜ë˜ëŠ”ì§€ í…ŒìŠ¤íŠ¸í•©ë‹ˆë‹¤."""
    payload = {
        "language": "ko-KR",
        "text": "í…ŒìŠ¤íŠ¸ ì…ë ¥",
        "client": {"viewport_w": 1920, "viewport_h": 1080, "theme": "dark"},
        "economy_snapshot": {"signal": 100, "memory_shard": 5},
    }

    # StreamingResponse í…ŒìŠ¤íŠ¸
    response = client.post("/api/turn", json=payload)
    assert response.status_code == 200
    assert response.headers["content-type"] == "application/x-ndjson"

    events = []
    for line in response.iter_lines():
        if line:
            events.append(json.loads(line))

    # 1. ì´ë²¤íŠ¸ ì¡´ì¬ ì—¬ë¶€ í™•ì¸
    assert len(events) > 0

    # 2. ì²« ë²ˆì§¸ ì´ë²¤íŠ¸ëŠ” í•­ìƒ stage: parse: start ì—¬ì•¼ í•¨ (TTFB)
    assert events[0]["type"] == "stage"
    assert events[0]["name"] == "parse"
    assert events[0]["status"] == "start"

    # 3. ë‹¨ê³„ë³„ ì´ë²¤íŠ¸ ìˆœì„œ í™•ì¸
    stages = [e["name"] for e in events if e["type"] == "stage" and e["status"] == "start"]
    expected_stages = ["parse", "validate", "plan", "resolve", "render", "verify", "commit"]
    assert stages == expected_stages

    # 4. ë°°ì§€ ì´ë²¤íŠ¸ í¬í•¨ ì—¬ë¶€ í™•ì¸
    badges_events = [e for e in events if e["type"] == "badges"]
    assert len(badges_events) >= 2
    assert "schema_ok" in badges_events[0]["badges"]

    # 5. ìµœì¢… ê²°ê³¼ë¬¼ í™•ì¸
    final_events = [e for e in events if e["type"] == "final"]
    assert len(final_events) == 1

    turn_output_data = final_events[0]["data"]
    # Pydantic ëª¨ë¸ë¡œ ë‹¤ì‹œ ê²€ì¦ (RULE-003)
    turn_output = TurnOutput.model_validate(turn_output_data)
    assert turn_output.language == Language.KO
    assert len(turn_output.narrative) > 0


def test_turn_streaming_invalid_input():
    """ì˜ëª»ëœ ì…ë ¥ ìš”ì²­ ì‹œ ì—ëŸ¬ ì´ë²¤íŠ¸ê°€ ìŠ¤íŠ¸ë¦¬ë°ë˜ëŠ”ì§€ í…ŒìŠ¤íŠ¸í•©ë‹ˆë‹¤."""
    payload = {
        "language": "invalid-lang",  # ì˜ëª»ëœ ì–¸ì–´ ì½”ë“œ
        "text": "",
    }

    response = client.post("/api/turn", json=payload)
    # ì…ë ¥ ê²€ì¦ ì‹¤íŒ¨ ì‹œì—ë„ 200 OK ìŠ¤íŠ¸ë¦¼ìœ¼ë¡œ ì—ëŸ¬ë¥¼ ë³´ë‚¼ ìˆ˜ë„ ìˆê³ ,
    # 400 Bad Requestë¥¼ ë³´ë‚¼ ìˆ˜ë„ ìˆìŒ. í˜„ì¬ êµ¬í˜„ì€ 200 OK + type: error ì„.
    assert response.status_code == 200

    events = [json.loads(line) for line in response.iter_lines() if line]
    assert any(e["type"] == "error" for e in events)
    assert any(e["code"] == "VALIDATION_ERROR" for e in events)


def test_turn_streaming_deterministic_seed():
    """seed íŒŒë¼ë¯¸í„° ì‚¬ìš© ì‹œ ê²°ê³¼ê°€ ê²°ì •ì ì¸ì§€ í…ŒìŠ¤íŠ¸í•©ë‹ˆë‹¤."""
    payload = {
        "language": "en-US",
        "text": "Hello",
        "client": {"viewport_w": 1920, "viewport_h": 1080},
        "economy_snapshot": {"signal": 100, "memory_shard": 5},
    }

    # ë™ì¼í•œ ì‹œë“œë¡œ ë‘ ë²ˆ ìš”ì²­
    seed = 12345

    def get_final_output(s):
        resp = client.post(f"/api/turn?seed={s}", json=payload)
        events = [json.loads(line) for line in resp.iter_lines() if line]
        return next(e["data"] for e in events if e["type"] == "final")

    output1 = get_final_output(seed)
    output2 = get_final_output(seed)

    assert output1 == output2
    assert output1["language"] == "en-US"


def test_turn_streaming_generation_fallback(monkeypatch):
    """ìƒì„± ì¤‘ ValidationError ë°œìƒ ì‹œ ì•ˆì „í•œ í´ë°±ì´ ë°˜í™˜ë˜ëŠ”ì§€ í…ŒìŠ¤íŠ¸í•©ë‹ˆë‹¤."""
    from pydantic import ValidationError

    from unknown_world.orchestrator.mock import MockOrchestrator

    def mock_generate_failure(self, turn_input):
        # Pydantic ValidationErrorë¥¼ ìˆ˜ë™ìœ¼ë¡œ ìƒì„±í•˜ëŠ” ê²ƒì€ ë³µì¡í•˜ë¯€ë¡œ
        # ê°„ë‹¨í•œ í•„ë“œ ê²€ì¦ ì˜¤ë¥˜ë¥¼ ì‹œë®¬ë ˆì´ì…˜í•˜ê±°ë‚˜ ì§ì ‘ raise í•¨
        # ì—¬ê¸°ì„œëŠ” í…ŒìŠ¤íŠ¸ë¥¼ ìœ„í•´ ì„ì˜ì˜ í•„ë“œ ëˆ„ë½ ë“±ìœ¼ë¡œ ë°œìƒí•œë‹¤ê³  ê°€ì •
        raise ValidationError.from_exception_data(title="MockError", line_errors=[])

    monkeypatch.setattr(MockOrchestrator, "generate_turn_output", mock_generate_failure)

    payload = {
        "language": "ko-KR",
        "text": "í…ŒìŠ¤íŠ¸",
        "client": {"viewport_w": 1920, "viewport_h": 1080},
        "economy_snapshot": {"signal": 100, "memory_shard": 5},
    }

    response = client.post("/api/turn", json=payload)
    events = [json.loads(line) for line in response.iter_lines() if line]

    final_event = next(e for e in events if e["type"] == "final")
    turn_output = final_event["data"]

    # í´ë°± ì‘ë‹µì˜ íŠ¹ì§• í™•ì¸
    assert turn_output["agent_console"]["badges"] == ["schema_fail"]
    assert turn_output["agent_console"]["repair_count"] == 1
    assert "í˜¼ë€" in turn_output["narrative"] or "confusion" in turn_output["narrative"]


def test_turn_streaming_repair_loop(monkeypatch):
    """ê²€ì¦ ì‹¤íŒ¨ ì‹œ repair ì´ë²¤íŠ¸ê°€ ìŠ¤íŠ¸ë¦¼ì— í¬í•¨ë˜ëŠ”ì§€ í…ŒìŠ¤íŠ¸í•©ë‹ˆë‹¤ (RU-002)."""
    from pydantic import ValidationError

    from unknown_world.orchestrator.mock import MockOrchestrator

    # ì²« ë²ˆì§¸ í˜¸ì¶œì—ì„œ ì‹¤íŒ¨í•˜ì—¬ repair íŠ¸ë¦¬ê±° ì‹œë®¬ë ˆì´ì…˜
    # (ì‹¤ì œ êµ¬í˜„ì—ì„œëŠ” NíšŒ ì¬ì‹œë„ ë¡œì§ì´ turn.pyì— ìˆì–´ì•¼ í•¨)
    call_count = 0

    def mock_generate_with_repair(self, turn_input):
        nonlocal call_count
        call_count += 1
        if call_count == 1:
            raise ValidationError.from_exception_data(title="MockSchemaError", line_errors=[])
        return orchestrator_orig_generate(self, turn_input)

    import unknown_world.orchestrator.mock as mock_mod

    orchestrator_orig_generate = mock_mod.MockOrchestrator.generate_turn_output
    monkeypatch.setattr(MockOrchestrator, "generate_turn_output", mock_generate_with_repair)

    payload = {
        "language": "ko-KR",
        "text": "ë¦¬í˜ì–´ í…ŒìŠ¤íŠ¸",
        "client": {"viewport_w": 1920, "viewport_h": 1080},
        "economy_snapshot": {"signal": 100, "memory_shard": 5},
    }

    response = client.post("/api/turn", json=payload)
    events = [json.loads(line) for line in response.iter_lines() if line]

    # RU-002 ìš”êµ¬ì‚¬í•­: repair ì´ë²¤íŠ¸ê°€ ëª…ì‹œì ìœ¼ë¡œ ì¡´ì¬í•´ì•¼ í•¨
    repair_events = [e for e in events if e["type"] == "repair"]
    assert len(repair_events) >= 1
    assert "attempt" in repair_events[0]
    assert repair_events[0]["attempt"] == 1
</file>

<file path="backend/tests/unit/test_u034_verification.py">
import json
from pathlib import Path

# í”„ë¡œì íŠ¸ ë£¨íŠ¸ ê²½ë¡œ ì„¤ì • (backend/tests/unit/ ìœ„ì¹˜ ê¸°ì¤€)
ROOT_DIR = Path(__file__).parent.parent.parent.parent
SCHEMA_PATH = ROOT_DIR / "vibe/ref/nanobanana-asset-request.schema.json"
GUIDE_PATH = ROOT_DIR / "vibe/ref/nanobanana-mcp.md"


def test_schema_file_exists():
    """ìŠ¤í‚¤ë§ˆ íŒŒì¼ì´ ì§€ì •ëœ ìœ„ì¹˜ì— ì¡´ì¬í•˜ëŠ”ì§€ í™•ì¸"""
    assert SCHEMA_PATH.exists(), f"Schema file not found at {SCHEMA_PATH}"


def test_schema_is_valid_json():
    """ìŠ¤í‚¤ë§ˆ íŒŒì¼ì´ ìœ íš¨í•œ JSON í˜•ì‹ì¸ì§€ í™•ì¸"""
    with open(SCHEMA_PATH, encoding="utf-8") as f:
        schema = json.load(f)
    assert schema["title"] == "nanobanana mcp Asset Request Schema"


def test_schema_required_properties():
    """ê³„íšì„œì— ëª…ì‹œëœ í•„ìˆ˜ í•„ë“œê°€ ìŠ¤í‚¤ë§ˆì— ì •ì˜ë˜ì–´ ìˆëŠ”ì§€ í™•ì¸"""
    with open(SCHEMA_PATH, encoding="utf-8") as f:
        schema = json.load(f)

    properties = schema.get("properties", {})
    required_fields = ["id", "category", "purpose", "size_px", "requires_rembg", "rembg_model"]

    for field in required_fields:
        assert field in properties, f"Required field '{field}' missing in schema properties"


def test_guide_file_exists():
    """ê°€ì´ë“œ ë¬¸ì„œ íŒŒì¼ì´ ì¡´ì¬í•˜ëŠ”ì§€ í™•ì¸"""
    assert GUIDE_PATH.exists(), f"Guide file not found at {GUIDE_PATH}"


def test_guide_content_completeness():
    """ê°€ì´ë“œ ë¬¸ì„œì— í•„ìˆ˜ ì„¹ì…˜(ì•„íŠ¸ ë””ë ‰ì…˜, ì¹´í…Œê³ ë¦¬ë³„ í…œí”Œë¦¿)ì´ í¬í•¨ë˜ì–´ ìˆëŠ”ì§€ í™•ì¸"""
    with open(GUIDE_PATH, encoding="utf-8") as f:
        content = f.read()

    # ê³„íšì„œ êµ¬í˜„ íë¦„ 2ë‹¨ê³„, 3ë‹¨ê³„ ê´€ë ¨ í‚¤ì›Œë“œ ê²€ì‚¬
    required_keywords = ["ì•„íŠ¸ ë””ë ‰ì…˜", "ìŠ¤íƒ€ì¼", "ì•„ì´ì½˜", "placeholder", "chrome", "í…œí”Œë¦¿"]

    missing_keywords = [kw for kw in required_keywords if kw.lower() not in content.lower()]

    # í˜„ì¬ nanobanana-mcp.mdì—ëŠ” rembg ë‚´ìš©ë§Œ ìˆìœ¼ë¯€ë¡œ ì‹¤íŒ¨í•  ê°€ëŠ¥ì„±ì´ í¼
    assert not missing_keywords, (
        f"Guide document is missing sections for: {', '.join(missing_keywords)}"
    )


def test_schema_rembg_rules():
    """ë°°ê²½ ì œê±°(rembg) ê´€ë ¨ ê°•ì œ ê·œì¹™(ìˆœë°± ë°°ê²½)ì´ ìŠ¤í‚¤ë§ˆ/ì„¤ëª…ì— í¬í•¨ë˜ì–´ ìˆëŠ”ì§€ í™•ì¸"""
    with open(SCHEMA_PATH, encoding="utf-8") as f:
        schema = json.load(f)

    # background í•„ë“œì™€ requires_rembg í•„ë“œ ì„¤ëª… í™•ì¸
    background_desc = schema["properties"]["background"].get("description", "")
    rembg_desc = schema["properties"]["requires_rembg"].get("description", "")

    assert "solid_white" in str(schema["properties"]["background"].get("enum", [])), (
        "background enum should include solid_white"
    )
    assert "rembg" in background_desc.lower(), "background description should mention rembg"
    assert "solid_white" in rembg_desc.lower(), (
        "requires_rembg description should recommend solid_white"
    )
</file>

<file path="frontend/public/ui/manifest.schema.json">
{
  "$schema": "http://json-schema.org/draft-07/schema#",
  "$id": "https://unknown-world.dev/schemas/ui-asset-manifest.json",
  "title": "UI Asset Manifest",
  "description": "nanobanana mcpë¡œ ì œì‘ëœ UI ì—ì…‹ì˜ ë§¤ë‹ˆí˜ìŠ¤íŠ¸ ìŠ¤í‚¤ë§ˆ",
  "type": "object",
  "required": ["version", "assets"],
  "additionalProperties": false,
  "properties": {
    "$schema": {
      "type": "string",
      "description": "JSON Schema ì°¸ì¡°"
    },
    "version": {
      "type": "string",
      "pattern": "^\\d+\\.\\d+\\.\\d+$",
      "description": "ë§¤ë‹ˆí˜ìŠ¤íŠ¸ ë²„ì „ (SemVer)",
      "examples": ["1.0.0"]
    },
    "generatedAt": {
      "type": "string",
      "format": "date-time",
      "description": "ë§¤ë‹ˆí˜ìŠ¤íŠ¸ ìƒì„± ì‹œê° (ISO 8601)"
    },
    "totalBytes": {
      "type": "integer",
      "minimum": 0,
      "description": "ëª¨ë“  ì—ì…‹ì˜ ì´ ë°”ì´íŠ¸ ìˆ˜"
    },
    "budgetBytes": {
      "type": "integer",
      "minimum": 0,
      "default": 1572864,
      "description": "ì„±ëŠ¥ ì˜ˆì‚° ìƒí•œ (ê¸°ë³¸: 1.5MB = 1572864 bytes)"
    },
    "assets": {
      "type": "array",
      "description": "ì—ì…‹ ëª©ë¡",
      "items": {
        "$ref": "#/$defs/Asset"
      }
    }
  },
  "$defs": {
    "Asset": {
      "type": "object",
      "required": ["id", "path", "type"],
      "additionalProperties": false,
      "properties": {
        "id": {
          "type": "string",
          "pattern": "^[a-z0-9]+(-[a-z0-9]+)*$",
          "description": "ì—ì…‹ ê³ ìœ  ID (kebab-case)",
          "examples": ["signal-24", "badge-ok-16", "scene-loading"]
        },
        "path": {
          "type": "string",
          "pattern": "^[a-z0-9-/]+\\.(png|webp|svg)$",
          "description": "ui/ ë””ë ‰í† ë¦¬ ê¸°ì¤€ ìƒëŒ€ ê²½ë¡œ",
          "examples": ["icons/signal-24.png", "placeholders/scene-loading.webp"]
        },
        "type": {
          "type": "string",
          "enum": ["icon", "placeholder", "chrome"],
          "description": "ì—ì…‹ ìœ í˜•"
        },
        "size": {
          "type": "integer",
          "enum": [16, 24, 32, 64, 128, 256, 512],
          "description": "í”½ì…€ ì‚¬ì´ì¦ˆ (ì•„ì´ì½˜ìš©)"
        },
        "width": {
          "type": "integer",
          "minimum": 1,
          "description": "ê°€ë¡œ í”½ì…€ (placeholder/chromeìš©)"
        },
        "height": {
          "type": "integer",
          "minimum": 1,
          "description": "ì„¸ë¡œ í”½ì…€ (placeholder/chromeìš©)"
        },
        "fallback": {
          "type": "string",
          "maxLength": 10,
          "description": "ë¡œë”© ì‹¤íŒ¨ ì‹œ ëŒ€ì²´ ì´ëª¨ì§€/í…ìŠ¤íŠ¸",
          "examples": ["ğŸ“¡", "âš ï¸", "OK"]
        },
        "usedIn": {
          "type": "array",
          "items": {
            "type": "string"
          },
          "description": "ì‚¬ìš©ì²˜ ì»´í¬ë„ŒíŠ¸ ëª©ë¡",
          "examples": [["EconomyHUD", "AgentConsole"]]
        },
        "bytes": {
          "type": "integer",
          "minimum": 0,
          "description": "íŒŒì¼ í¬ê¸° (bytes)"
        },
        "format": {
          "type": "string",
          "enum": ["png", "webp", "svg"],
          "description": "íŒŒì¼ í¬ë§·"
        },
        "retina": {
          "type": "boolean",
          "default": false,
          "description": "@2x Retina ë²„ì „ ì¡´ì¬ ì—¬ë¶€"
        },
        "description": {
          "type": "string",
          "maxLength": 200,
          "description": "ì—ì…‹ ì„¤ëª…"
        },
        "createdAt": {
          "type": "string",
          "format": "date-time",
          "description": "ìƒì„± ì‹œê° (ISO 8601)"
        },
        "promptHash": {
          "type": "string",
          "pattern": "^[a-f0-9]{8}$",
          "description": "ìƒì„± í”„ë¡¬í”„íŠ¸ í•´ì‹œ (ì¬í˜„ì„±, 8ì)"
        },
        "notes": {
          "type": "string",
          "maxLength": 500,
          "description": "ì—ì…‹ ê´€ë ¨ ë©”ëª¨ (ìƒì„± ë„êµ¬, ë°°ê²½ ì œê±°, ìµœì í™” ë“± QA ê´€ë ¨ ê¸°ë¡)"
        }
      }
    }
  }
}
</file>

<file path="frontend/src/components/AgentConsole.test.tsx">
import { describe, it, expect, vi } from 'vitest';
import { render, screen } from '@testing-library/react';
import { AgentConsole } from './AgentConsole';

// Mock i18n
vi.mock('react-i18next', () => ({
  useTranslation: () => ({
    t: (key: string) => key,
  }),
}));

// Mock dependencies
type MockSelector<T> = (state: unknown) => T;

vi.mock('../stores/agentStore', () => ({
  useAgentStore: <T,>(selector: MockSelector<T>) =>
    selector({
      phases: [],
      badges: [],
      repairCount: 0,
      error: null,
      isStreaming: false,
    }),
  selectIsStreaming: (state: { isStreaming: boolean }) => state.isStreaming,
  selectPhases: (state: { phases: unknown[] }) => state.phases,
  selectBadges: (state: { badges: unknown[] }) => state.badges,
  selectRepairCount: (state: { repairCount: number }) => state.repairCount,
  selectError: (state: { error: unknown }) => state.error,
}));

describe('AgentConsole (U-037)', () => {
  it('should render with "critical" importance attribute', () => {
    const { container } = render(<AgentConsole />);

    // The root element of AgentConsole should have data-ui-importance="critical"
    const consoleElement = container.firstChild as HTMLElement;

    expect(consoleElement).toHaveAttribute('data-ui-importance', 'critical');
  });

  it('should render streaming status', () => {
    render(<AgentConsole />);
    // Verify that the correct i18n key is used
    expect(screen.getByText('agent.console.status.idle')).toBeInTheDocument();
  });
});
</file>

<file path="frontend/src/components/Panel.tsx">
import { useTranslation } from 'react-i18next';

interface PanelProps {
  title: string;
  children?: React.ReactNode;
  className?: string;
  /** U-032: Chrome ì¥ì‹ ì ìš© ì—¬ë¶€ */
  hasChrome?: boolean;
  /** ê¸°ë³¸ placeholder i18n í‚¤ (childrenì´ ì—†ì„ ë•Œ ì‚¬ìš©) */
  placeholderKey?: string;
}

export function Panel({
  title,
  children,
  className = '',
  hasChrome = false,
  placeholderKey,
}: PanelProps) {
  const { t } = useTranslation();
  const panelClass = `panel ${className} ${hasChrome ? 'has-chrome' : ''}`.trim();
  const headerClass = `panel-header ${hasChrome ? 'has-chrome' : ''}`.trim();

  return (
    <div className={panelClass}>
      <div className={headerClass}>
        <span className="panel-title">{title}</span>
      </div>
      <div className="panel-content">
        {children || (
          <p className="panel-placeholder">
            {placeholderKey ? t(placeholderKey) : t('ui.panel_placeholder')}
          </p>
        )}
      </div>
    </div>
  );
}
</file>

<file path="frontend/src/demo/demoFixtures.ts">
/**
 * Unknown World - ë°ëª¨ìš© Fixtures (RU-003-Q5)
 *
 * DEV í™˜ê²½ì—ì„œ ì‚¬ìš©í•˜ëŠ” ë°ëª¨ ì´ˆê¸° ë°ì´í„°ì…ë‹ˆë‹¤.
 * ì–¸ì–´ ì¤‘ë¦½ì ì¸ ê°’(ID/ì•„ì´ì½˜/ìˆ˜ëŸ‰/ì¢Œí‘œ)ë§Œ í¬í•¨í•˜ë©°,
 * í‘œì‹œ ë¬¸ìì—´(name/label/hint)ì€ i18n í‚¤ë¥¼ í†µí•´ ë Œë”ë§í•©ë‹ˆë‹¤.
 *
 * ì„¤ê³„ ì›ì¹™:
 *   - RULE-006: ko/en í˜¼í•© ì¶œë ¥ ê¸ˆì§€ (i18n í‚¤ ê¸°ë°˜)
 *   - PRD 6.9: ë°ëª¨ í”„ë¡œí•„ ê²½ê³„ í™•ë³´
 *   - ì„œë²„ TurnOutput ëŒ€ì²´ ì‹œ ì´ ëª¨ë“ˆ ë¹„í™œì„±í™” ê°€ëŠ¥
 *
 * @module demo/demoFixtures
 */

import type { Box2D } from '../schemas/turn';

// =============================================================================
// íƒ€ì… ì •ì˜
// =============================================================================

/**
 * ë°ëª¨ ì¸ë²¤í† ë¦¬ ì•„ì´í…œ ì •ì˜ (ì–¸ì–´ ì¤‘ë¦½)
 *
 * nameì€ i18n í‚¤(`demo.items.{id}.name`)ë¡œ ë Œë”ë§í•©ë‹ˆë‹¤.
 */
export interface DemoInventoryItemDef {
  /** ì•„ì´í…œ ê³ ìœ  ID */
  id: string;
  /** ì•„ì´í…œ ì•„ì´ì½˜ (ì´ëª¨ì§€ ë˜ëŠ” URL) */
  icon: string;
  /** ì´ˆê¸° ìˆ˜ëŸ‰ */
  quantity: number;
}

/**
 * ë°ëª¨ ì”¬ ì˜¤ë¸Œì íŠ¸ ì •ì˜ (ì–¸ì–´ ì¤‘ë¦½)
 *
 * label/hintëŠ” i18n í‚¤ë¡œ ë Œë”ë§í•©ë‹ˆë‹¤:
 * - labelKey: `demo.scene.{id}.label`
 * - hintKey: `demo.scene.{id}.hint`
 */
export interface DemoSceneObjectDef {
  /** ì˜¤ë¸Œì íŠ¸ ê³ ìœ  ID */
  id: string;
  /** ë°”ìš´ë”© ë°•ìŠ¤ (0~1000 ì •ê·œí™”) */
  box_2d: Box2D;
  /** i18n ë¼ë²¨ í‚¤ */
  labelKey: string;
  /** i18n íŒíŠ¸ í‚¤ */
  hintKey: string;
}

// =============================================================================
// ë°ëª¨ ì¸ë²¤í† ë¦¬ ì•„ì´í…œ
// =============================================================================

/**
 * ë°ëª¨ìš© ì¸ë²¤í† ë¦¬ ì•„ì´í…œ ëª©ë¡.
 *
 * @remarks
 * - ID/ì•„ì´ì½˜/ìˆ˜ëŸ‰ë§Œ ì •ì˜ (ì–¸ì–´ ì¤‘ë¦½)
 * - í‘œì‹œ ì´ë¦„ì€ `demo.items.{id}.name` í‚¤ë¡œ i18n ì²˜ë¦¬
 */
export const DEMO_INVENTORY_ITEMS: readonly DemoInventoryItemDef[] = [
  { id: 'keycard-alpha', icon: 'ğŸ”‘', quantity: 1 },
  { id: 'medkit', icon: 'ğŸ©¹', quantity: 2 },
  { id: 'flashlight', icon: 'ğŸ”¦', quantity: 1 },
  { id: 'data-chip', icon: 'ğŸ’¾', quantity: 3 },
] as const;

// =============================================================================
// ë°ëª¨ ì”¬ ì˜¤ë¸Œì íŠ¸
// =============================================================================

/**
 * ë°ëª¨ìš© ì”¬ ì˜¤ë¸Œì íŠ¸ ëª©ë¡.
 *
 * @remarks
 * - ID/ì¢Œí‘œë§Œ ì •ì˜ (ì–¸ì–´ ì¤‘ë¦½)
 * - í‘œì‹œ ë¼ë²¨/íŒíŠ¸ëŠ” i18n í‚¤ë¡œ ì²˜ë¦¬
 */
export const DEMO_SCENE_OBJECTS: readonly DemoSceneObjectDef[] = [
  {
    id: 'demo-terminal',
    box_2d: { ymin: 300, xmin: 100, ymax: 600, xmax: 400 },
    labelKey: 'demo.scene.terminal.label',
    hintKey: 'demo.scene.terminal.hint',
  },
  {
    id: 'demo-door',
    box_2d: { ymin: 200, xmin: 600, ymax: 800, xmax: 900 },
    labelKey: 'demo.scene.door.label',
    hintKey: 'demo.scene.door.hint',
  },
] as const;

// =============================================================================
// ë°ëª¨ í€˜ìŠ¤íŠ¸ (U-013)
// =============================================================================

/**
 * ë°ëª¨ í€˜ìŠ¤íŠ¸ ì •ì˜ (ì–¸ì–´ ì¤‘ë¦½)
 *
 * labelì€ i18n í‚¤(`demo.quest.{id}.label`)ë¡œ ë Œë”ë§í•©ë‹ˆë‹¤.
 */
export interface DemoQuestDef {
  /** í€˜ìŠ¤íŠ¸ ê³ ìœ  ID */
  id: string;
  /** i18n ë¼ë²¨ í‚¤ */
  labelKey: string;
  /** ì™„ë£Œ ì—¬ë¶€ */
  is_completed: boolean;
}

/**
 * ë°ëª¨ìš© í€˜ìŠ¤íŠ¸ ëª©ë¡.
 */
export const DEMO_QUESTS: readonly DemoQuestDef[] = [
  {
    id: 'demo-quest-terminal',
    labelKey: 'demo.quest.terminal.label',
    is_completed: false,
  },
  {
    id: 'demo-quest-escape',
    labelKey: 'demo.quest.escape.label',
    is_completed: false,
  },
  {
    id: 'demo-quest-collect',
    labelKey: 'demo.quest.collect.label',
    is_completed: true,
  },
] as const;

// =============================================================================
// ë°ëª¨ ê·œì¹™ (U-013)
// =============================================================================

/**
 * ë°ëª¨ ê·œì¹™ ì •ì˜ (ì–¸ì–´ ì¤‘ë¦½)
 *
 * label/descriptionì€ i18n í‚¤ë¡œ ë Œë”ë§í•©ë‹ˆë‹¤.
 */
export interface DemoRuleDef {
  /** ê·œì¹™ ê³ ìœ  ID */
  id: string;
  /** i18n ë¼ë²¨ í‚¤ */
  labelKey: string;
  /** i18n ì„¤ëª… í‚¤ (ì„ íƒ) */
  descriptionKey?: string;
}

/**
 * ë°ëª¨ìš© ê·œì¹™ ëª©ë¡.
 */
export const DEMO_RULES: readonly DemoRuleDef[] = [
  {
    id: 'demo-rule-gravity',
    labelKey: 'demo.rule.gravity.label',
    descriptionKey: 'demo.rule.gravity.description',
  },
  {
    id: 'demo-rule-time',
    labelKey: 'demo.rule.time.label',
    descriptionKey: 'demo.rule.time.description',
  },
] as const;

// =============================================================================
// í—¬í¼ í•¨ìˆ˜
// =============================================================================

/**
 * ë°ëª¨ ì¸ë²¤í† ë¦¬ ì•„ì´í…œì˜ i18n ì´ë¦„ í‚¤ë¥¼ ìƒì„±í•©ë‹ˆë‹¤.
 *
 * @param itemId - ì•„ì´í…œ ID
 * @returns i18n í‚¤ (ì˜ˆ: `demo.items.keycard-alpha.name`)
 */
export function getDemoItemNameKey(itemId: string): string {
  return `demo.items.${itemId}.name`;
}

/**
 * ë°ëª¨ í™˜ê²½ì¸ì§€ í™•ì¸í•©ë‹ˆë‹¤ (DEV ê°€ë“œ).
 *
 * @returns DEV í™˜ê²½ ì—¬ë¶€
 */
export function isDemoEnvironment(): boolean {
  return import.meta.env.DEV;
}

/**
 * DOMì—ì„œ í˜„ì¬ í…Œë§ˆë¥¼ ì½ìŠµë‹ˆë‹¤.
 *
 * RU-003-Q5: 'dark' í•˜ë“œì½”ë”© ì œê±°
 * - data-theme ì†ì„±ì„ í™•ì¸í•˜ì—¬ í…Œë§ˆ ê²°ì •
 * - 'crt', 'dark' ë˜ëŠ” ë¯¸ì§€ì • â†’ 'dark'
 * - 'light' â†’ 'light'
 *
 * @returns í˜„ì¬ í…Œë§ˆ ('dark' | 'light')
 */
export function getCurrentThemeFromDOM(): 'dark' | 'light' {
  const dataTheme = document.documentElement.getAttribute('data-theme');

  // 'crt' í…Œë§ˆëŠ” dark ê³„ì—´ë¡œ ì·¨ê¸‰
  if (dataTheme === 'light') {
    return 'light';
  }
  return 'dark';
}
</file>

<file path="frontend/src/dnd/types.ts">
/**
 * Unknown World - DnD íƒ€ì… ë° ìƒìˆ˜ ì •ì˜ (RU-003-Q1).
 *
 * DnD ë°ì´í„° ê³„ì•½ì„ SSOTë¡œ ê´€ë¦¬í•˜ì—¬ íƒ€ì… ì•ˆì „ì„±ì„ í™•ë³´í•©ë‹ˆë‹¤.
 * ëª¨ë“  ë“œë˜ê·¸/ë“œë¡­ ì´ë²¤íŠ¸ì—ì„œ ë™ì¼í•œ ìƒìˆ˜/íƒ€ì…ì„ ì‚¬ìš©í•©ë‹ˆë‹¤.
 *
 * ì„¤ê³„ ì›ì¹™:
 *   - SSOT: ë“œë˜ê·¸/ë“œë¡­ íƒ€ì… ë¬¸ìì—´ì€ ì´ ëª¨ë“ˆì—ì„œë§Œ ì •ì˜
 *   - íƒ€ì… ì•ˆì „ì„±: dnd-kitì˜ data.currentë¥¼ íƒ€ì… ê°€ë“œë¡œ ê²€ì¦
 *   - ê³¼ë„í•œ ì¶”ìƒí™” ê¸ˆì§€: ìƒìˆ˜/íƒ€ì…ë§Œ ì œê³µ, ë¡œì§ì€ ì»´í¬ë„ŒíŠ¸ì— ìœ ì§€
 *
 * @module dnd/types
 */

import type { Box2D } from '../schemas/turn';
import type { InventoryItem } from '../stores/inventoryStore';

// =============================================================================
// DnD íƒ€ì… ìƒìˆ˜ (SSOT)
// =============================================================================

/**
 * DnD íƒ€ì… ìƒìˆ˜.
 * ë“œë˜ê·¸/ë“œë¡­ ë°ì´í„°ì˜ type í•„ë“œì— ì‚¬ìš©ë©ë‹ˆë‹¤.
 */
export const DND_TYPE = {
  /** ì¸ë²¤í† ë¦¬ ì•„ì´í…œ ë“œë˜ê·¸ */
  INVENTORY_ITEM: 'inventory-item',
  /** í•«ìŠ¤íŒŸ ë“œë¡­ íƒ€ê²Ÿ */
  HOTSPOT: 'hotspot',
} as const;

// =============================================================================
// RU-003-S2: ì¸í„°ë™ì…˜ í—ˆìš© ì •ì±… (SSOT)
// =============================================================================

/**
 * í•«ìŠ¤íŒŸ ì¸í„°ë™ì…˜ì´ í—ˆìš©ë˜ëŠ” Scene ìƒíƒœ ëª©ë¡.
 *
 * RU-003-S2 Step 1: Option A(ë°ëª¨ ìœ ì§€) ê²°ì •
 * - 'scene': ì‹¤ì œ ì¥ë©´ í™œì„±í™” ìƒíƒœ
 * - 'default': ë°ëª¨/í”Œë ˆì´ìŠ¤í™€ë” ìƒíƒœ (ì‹œê°ì  íŒíŠ¸ í•„ìš”)
 *
 * @see SceneCanvas.tsxì˜ shouldRenderHotspots ì¡°ê±´
 */
export const HOTSPOT_INTERACTION_ALLOWED_STATES = ['scene', 'default'] as const;

/**
 * ì¸í„°ë™ì…˜ í—ˆìš© ìƒíƒœ íƒ€ì….
 */
export type HotspotInteractionState = (typeof HOTSPOT_INTERACTION_ALLOWED_STATES)[number];

/**
 * ì£¼ì–´ì§„ ìƒíƒœì—ì„œ í•«ìŠ¤íŒŸ ì¸í„°ë™ì…˜ì´ í—ˆìš©ë˜ëŠ”ì§€ ê²€ì‚¬í•©ë‹ˆë‹¤.
 *
 * RU-003-S2: ì¸í„°ë™ì…˜ ê°€ëŠ¥ ì¡°ê±´ì„ SSOTë¡œ ê³ ì •
 *
 * @param status - Scene ìƒíƒœ
 * @returns ì¸í„°ë™ì…˜ í—ˆìš© ì—¬ë¶€
 */
export function isHotspotInteractionAllowed(status: string): boolean {
  return HOTSPOT_INTERACTION_ALLOWED_STATES.includes(status as HotspotInteractionState);
}

// =============================================================================
// RU-003-S2 Step 4: ìŠ¤íŠ¸ë¦¬ë° ë¹„í™œì„±í™” ì •ì±… (SSOT)
// =============================================================================

/**
 * ìŠ¤íŠ¸ë¦¬ë° ë¹„í™œì„±í™” ì •ì±….
 *
 * RU-003-S2 Step 4: disabled í”Œë˜ê·¸ì˜ SSOT ê³ ì •
 * - isStreamingì€ agentStoreì—ì„œë§Œ ì œê³µ
 * - ëª¨ë“  ì¸í„°ë™ì…˜ ì»´í¬ë„ŒíŠ¸(SceneCanvas, InventoryPanel, ActionDeck)ëŠ”
 *   ë™ì¼í•œ disabled í”Œë˜ê·¸ë¥¼ ê³µìœ í•´ì•¼ í•¨
 * - í–¥í›„ worldStore/Turn Runner ë„ì… ì‹œì—ë„ ì´ ì›ì¹™ì„ ìœ ì§€
 *
 * @see App.tsxì˜ isStreaming ì‚¬ìš© íŒ¨í„´
 * @see agentStore.tsì˜ isStreaming ìƒíƒœ
 */
export const STREAMING_DISABLED_POLICY = {
  /** ìŠ¤íŠ¸ë¦¬ë° ìƒíƒœ SSOT ì¶œì²˜ */
  source: 'agentStore.isStreaming',
  /** ë¹„í™œì„±í™” ì ìš© ëŒ€ìƒ ì»´í¬ë„ŒíŠ¸ */
  affectedComponents: ['SceneCanvas', 'InventoryPanel', 'ActionDeck', 'CommandInput'],
} as const;

/**
 * DnD íƒ€ì… ìœ ë‹ˆì˜¨.
 */
export type DndType = (typeof DND_TYPE)[keyof typeof DND_TYPE];

// =============================================================================
// ë“œë˜ê·¸ ë°ì´í„° íƒ€ì…
// =============================================================================

/**
 * ì¸ë²¤í† ë¦¬ ì•„ì´í…œ ë“œë˜ê·¸ ë°ì´í„°.
 * InventoryPanelì—ì„œ ë“œë˜ê·¸ ì‹œì‘ ì‹œ ì„¤ì •ë©ë‹ˆë‹¤.
 */
export interface InventoryDragData {
  /** ë“œë˜ê·¸ íƒ€ì… (í•­ìƒ 'inventory-item') */
  type: typeof DND_TYPE.INVENTORY_ITEM;
  /** ë“œë˜ê·¸ ì¤‘ì¸ ì•„ì´í…œ ID */
  item_id: string;
  /** ë“œë˜ê·¸ ì¤‘ì¸ ì•„ì´í…œ ê°ì²´ */
  item: InventoryItem;
}

// =============================================================================
// ë“œë¡­ ë°ì´í„° íƒ€ì…
// =============================================================================

/**
 * í•«ìŠ¤íŒŸ ë“œë¡­ íƒ€ê²Ÿ ë°ì´í„°.
 * SceneCanvasì˜ í•«ìŠ¤íŒŸì—ì„œ ì„¤ì •ë©ë‹ˆë‹¤.
 */
export interface HotspotDropData {
  /** ë“œë¡­ íƒ€ê²Ÿ íƒ€ì… (í•­ìƒ 'hotspot') */
  type: typeof DND_TYPE.HOTSPOT;
  /** í•«ìŠ¤íŒŸ ì˜¤ë¸Œì íŠ¸ ID */
  object_id: string;
  /** í•«ìŠ¤íŒŸ ë°”ìš´ë”© ë°•ìŠ¤ (0~1000 ì •ê·œí™”) */
  box_2d: Box2D;
  /** í•«ìŠ¤íŒŸ ë¼ë²¨ (í‘œì‹œìš©) */
  label: string;
}

// =============================================================================
// íƒ€ì… ê°€ë“œ í•¨ìˆ˜
// =============================================================================

/**
 * ë°ì´í„°ê°€ InventoryDragDataì¸ì§€ ê²€ì‚¬í•©ë‹ˆë‹¤.
 *
 * @param data - dnd-kitì˜ active.data.current
 * @returns InventoryDragDataì´ë©´ true
 */
export function isInventoryDragData(data: unknown): data is InventoryDragData {
  if (typeof data !== 'object' || data === null) {
    return false;
  }
  const obj = data as Record<string, unknown>;
  return (
    obj.type === DND_TYPE.INVENTORY_ITEM &&
    typeof obj.item_id === 'string' &&
    typeof obj.item === 'object' &&
    obj.item !== null
  );
}

/**
 * ë°ì´í„°ê°€ HotspotDropDataì¸ì§€ ê²€ì‚¬í•©ë‹ˆë‹¤.
 *
 * @param data - dnd-kitì˜ over.data.current
 * @returns HotspotDropDataì´ë©´ true
 */
export function isHotspotDropData(data: unknown): data is HotspotDropData {
  if (typeof data !== 'object' || data === null) {
    return false;
  }
  const obj = data as Record<string, unknown>;
  return (
    obj.type === DND_TYPE.HOTSPOT &&
    typeof obj.object_id === 'string' &&
    typeof obj.box_2d === 'object' &&
    obj.box_2d !== null &&
    typeof obj.label === 'string'
  );
}

// =============================================================================
// RU-003-S2 Step 2: í•«ìŠ¤íŒŸ ìš°ì„ ìˆœìœ„ ì •ì±… (SSOT)
// =============================================================================

/**
 * ë°”ìš´ë”© ë°•ìŠ¤ì˜ ë©´ì ì„ ê³„ì‚°í•©ë‹ˆë‹¤.
 *
 * @param box - { ymin, xmin, ymax, xmax } í˜•ì‹ì˜ ë°”ìš´ë”© ë°•ìŠ¤
 * @returns ë°•ìŠ¤ ë©´ì 
 */
export function calculateBoxArea(box: Box2D): number {
  const { ymin, xmin, ymax, xmax } = box;
  return Math.abs(ymax - ymin) * Math.abs(xmax - xmin);
}

/**
 * í•«ìŠ¤íŒŸ ìš°ì„ ìˆœìœ„ ê³„ì‚°ì„ ìœ„í•œ ë¹„êµ í•¨ìˆ˜.
 *
 * RU-003-S2 Step 2: ì‘ì€ bboxê°€ ë” ë†’ì€ ìš°ì„ ìˆœìœ„ë¥¼ ê°€ì§
 * - ë” ì‘ì€ ì˜¤ë¸Œì íŠ¸ê°€ ë” êµ¬ì²´ì ì¸ íƒ€ê²Ÿì´ë¼ê³  ê°€ì •
 * - z-index ê´€ì ì—ì„œ ì‘ì€ ê²ƒì´ ìœ„ì— ë Œë”ë˜ì–´ì•¼ í•¨
 *
 * @param a - ì²« ë²ˆì§¸ ë°”ìš´ë”© ë°•ìŠ¤
 * @param b - ë‘ ë²ˆì§¸ ë°”ìš´ë”© ë°•ìŠ¤
 * @returns ì •ë ¬ ìˆœì„œ (ì‘ì€ ê²ƒì´ ë’¤ë¡œ ê°€ì„œ z-indexê°€ ë†’ì•„ì§)
 */
export function compareHotspotPriority(a: Box2D, b: Box2D): number {
  return calculateBoxArea(b) - calculateBoxArea(a);
}
</file>

<file path="frontend/src/i18n.ts">
/**
 * Unknown World - i18n ì´ˆê¸°í™” ëª¨ë“ˆ
 *
 * ì–¸ì–´ ë¦¬ì†ŒìŠ¤ë¥¼ JSON íŒŒì¼ êµ¬ì¡°ë¡œ ê´€ë¦¬í•©ë‹ˆë‹¤.
 * RULE-006 ì¤€ìˆ˜: ko/en í˜¼í•© ì¶œë ¥ ê¸ˆì§€, i18n í‚¤ ê¸°ë°˜ SSOT
 *
 * ì–¸ì–´ ì½”ë“œ: BCP-47 í˜•ì‹ (ko-KR, en-US)
 * - TurnInput/SaveGameì˜ language í•„ë“œì™€ ë™ì¼í•œ ì¶•
 *
 * @see vibe/prd.md 3.1(ì§€ì› ì–¸ì–´), 8.7(TurnInput.language)
 * @see frontend/src/locales/README.md
 */

import i18n from 'i18next';
import { initReactI18next } from 'react-i18next';

// JSON ì–¸ì–´ ë¦¬ì†ŒìŠ¤ import (SSOT: locales/{lang}/translation.json)
import koKR from './locales/ko-KR/translation.json';
import enUS from './locales/en-US/translation.json';

/** ì§€ì› ì–¸ì–´ íƒ€ì… (TurnInput.languageì™€ ë™ê¸°í™”) */
export type SupportedLanguage = 'ko-KR' | 'en-US';

/** ê¸°ë³¸ ì–¸ì–´ (ë°ëª¨ ì¼ê´€ì„±ì„ ìœ„í•´ ko-KR ê³ ì •) */
export const DEFAULT_LANGUAGE: SupportedLanguage = 'ko-KR';

/** í´ë°± ì–¸ì–´ */
export const FALLBACK_LANGUAGE: SupportedLanguage = 'en-US';

/** ì§€ì› ì–¸ì–´ ëª©ë¡ */
export const SUPPORTED_LANGUAGES: SupportedLanguage[] = ['ko-KR', 'en-US'];

// i18n ë¦¬ì†ŒìŠ¤ ì •ì˜ (BCP-47 í˜•ì‹ ì–¸ì–´ ì½”ë“œ)
const resources = {
  'ko-KR': {
    translation: koKR,
  },
  'en-US': {
    translation: enUS,
  },
};

i18n.use(initReactI18next).init({
  resources,
  lng: DEFAULT_LANGUAGE,
  fallbackLng: FALLBACK_LANGUAGE,
  supportedLngs: SUPPORTED_LANGUAGES,
  interpolation: {
    escapeValue: false, // Reactì—ì„œ ì´ë¯¸ XSS ë°©ì§€
  },
  // ëˆ„ë½ í‚¤ ì²˜ë¦¬ (ê°œë°œ ëª¨ë“œì—ì„œ ê²½ê³ )
  saveMissing: false,
  missingKeyHandler: (_lngs, _ns, key) => {
    if (import.meta.env.DEV) {
      console.warn(`[i18n] Missing translation key: "${key}"`);
    }
  },
});

/**
 * í˜„ì¬ í•´ê²°ëœ ì–¸ì–´ ì½”ë“œë¥¼ ë°˜í™˜í•©ë‹ˆë‹¤.
 * TurnInput.languageì™€ ë™ê¸°í™”í•  ë•Œ ì‚¬ìš©í•©ë‹ˆë‹¤.
 */
export function getResolvedLanguage(): SupportedLanguage {
  return (i18n.resolvedLanguage as SupportedLanguage) || DEFAULT_LANGUAGE;
}

/**
 * ì–¸ì–´ë¥¼ ë³€ê²½í•©ë‹ˆë‹¤.
 * í–¥í›„ U-036 ì™„ë£Œ í›„ ì‚¬ìš©ìì—ê²Œ ë…¸ì¶œí•  í† ê¸€ì—ì„œ ì‚¬ìš©í•©ë‹ˆë‹¤.
 */
export async function changeLanguage(lang: SupportedLanguage): Promise<void> {
  await i18n.changeLanguage(lang);
}

export default i18n;
</file>

<file path="frontend/src/main.tsx">
import { StrictMode } from 'react';
import { createRoot } from 'react-dom/client';
import './i18n'; // i18n ì´ˆê¸°í™”
import './style.css';
import App from './App.tsx';

createRoot(document.getElementById('root')!).render(
  <StrictMode>
    <App />
  </StrictMode>,
);
</file>

<file path="frontend/src/save/sessionLifecycle.ts">
/**
 * Unknown World - ì„¸ì…˜ ë¼ì´í”„ì‚¬ì´í´ ê´€ë¦¬ ëª¨ë“ˆ (RU-004-Q4).
 *
 * ì„¸ì…˜ ì´ˆê¸°í™”/ë³µì›/ë¦¬ì…‹/ë³€ê²½ì„ SSOTë¡œ ê´€ë¦¬í•©ë‹ˆë‹¤.
 * App.tsxì˜ ì„¸ì…˜ ê´€ë ¨ ë¡œì§ì„ ì´ ëª¨ë“ˆë¡œ ì´ë™í•˜ì—¬ ì±…ì„ ê²½ê³„ë¥¼ ëª…í™•íˆ í•©ë‹ˆë‹¤.
 *
 * ì„¤ê³„ ì›ì¹™:
 *   - RULE-005: Economy ì¸ë°”ë¦¬ì–¸íŠ¸ (ì”ì•¡ ìŒìˆ˜ ê¸ˆì§€)
 *   - RULE-006: ko/en i18n ì •ì±… ì¤€ìˆ˜ (ì–¸ì–´ ì ìš© í›„ UI ë Œë”ë§)
 *   - RU-004-S1: ì–¸ì–´ async ì ìš© ì™„ë£Œ í›„ store ì£¼ì…
 *   - RU-004-S2: profileId SSOT + ìœ íš¨ SaveGameë§Œ Continue
 *
 * @module save/sessionLifecycle
 */

import {
  loadSaveGame,
  saveSaveGame,
  clearSaveGame,
  getValidSaveGameOrNull,
  createSaveGame,
  loadCurrentProfileId,
  saveCurrentProfileId,
  clearCurrentProfileId,
} from './saveGame';
import { findProfileById, createSaveGameFromProfile, type DemoProfile } from '../data/demoProfiles';
import { getResolvedLanguage, changeLanguage, type SupportedLanguage } from '../i18n';
import { useWorldStore } from '../stores/worldStore';
import { useInventoryStore } from '../stores/inventoryStore';
import { useEconomyStore } from '../stores/economyStore';
import { useActionDeckStore } from '../stores/actionDeckStore';
import { useAgentStore } from '../stores/agentStore';

// =============================================================================
// íƒ€ì… ì •ì˜
// =============================================================================

/**
 * ë¶€íŒ… ê²°ê³¼ íƒ€ì….
 * ì•± ì‹œì‘ ì‹œ ì–´ë–¤ phaseë¡œ ì‹œì‘í• ì§€ ê²°ì •í•©ë‹ˆë‹¤.
 */
export type SessionBootstrap =
  | { phase: 'profile_select'; savedGameAvailable: boolean }
  | { phase: 'playing'; profileId: string | null };

/**
 * ì„¸ì…˜ ì‹œì‘ ê²°ê³¼ íƒ€ì….
 */
export interface SessionStartResult {
  success: true;
  profileId: string;
}

/**
 * ì„¸ì…˜ ë³µì› ê²°ê³¼ íƒ€ì….
 */
export interface SessionContinueResult {
  success: true;
  profileId: string;
}

/**
 * ì„¸ì…˜ ë¦¬ì…‹ ê²°ê³¼ íƒ€ì….
 */
export interface SessionResetResult {
  success: boolean;
  profileId: string | null;
}

// =============================================================================
// ë‚´ë¶€ í—¬í¼: ëª¨ë“  ì„¸ì…˜ ê´€ë ¨ storeë¥¼ ì´ˆê¸°í™”
// =============================================================================

/**
 * ëª¨ë“  ì„¸ì…˜ ê´€ë ¨ storeë¥¼ ì´ˆê¸°í™”í•©ë‹ˆë‹¤.
 *
 * RU-004-Q4 Step 2: store reset/hydrate ë²”ìœ„ í‘œì¤€í™”
 * - worldStore, inventoryStore, economyStore, actionDeckStore, agentStore
 *
 * ì„¸ì…˜ ê²½ê³„ì—ì„œ í•­ìƒ ì´ í•¨ìˆ˜ë¥¼ í˜¸ì¶œí•˜ì—¬ ì´ì „ ì„¸ì…˜ ì”ì¬ë¥¼ ì™„ì „íˆ ì œê±°í•©ë‹ˆë‹¤.
 */
function resetAllSessionStores(): void {
  useWorldStore.getState().reset();
  useInventoryStore.getState().reset();
  useEconomyStore.getState().reset();
  useActionDeckStore.getState().reset();
  useAgentStore.getState().reset();
}

// =============================================================================
// ì„¸ì…˜ ë¼ì´í”„ì‚¬ì´í´ API
// =============================================================================

/**
 * ë¶€íŒ… ì‹œ ì„¸ì…˜ ìƒíƒœë¥¼ í™•ì¸í•˜ê³  ì‹œì‘ phaseë¥¼ ê²°ì •í•©ë‹ˆë‹¤.
 *
 * RU-004-S2: hasSaveGame() ëŒ€ì‹  getValidSaveGameOrNull()ë¡œ "ìœ íš¨í•œ ì„¸ì´ë¸Œë§Œ" íŒë‹¨
 *
 * @returns SessionBootstrap - ì‹œì‘ phaseì™€ ê´€ë ¨ ì •ë³´
 */
export function bootstrapSession(): SessionBootstrap {
  const validSaveGame = getValidSaveGameOrNull();

  if (validSaveGame) {
    // ìœ íš¨í•œ ì„¸ì´ë¸Œê°€ ìˆìœ¼ë©´ playing ìƒíƒœë¡œ ì‹œì‘
    return {
      phase: 'playing',
      profileId: validSaveGame.profileId,
    };
  }

  // ìœ íš¨í•œ ì„¸ì´ë¸Œê°€ ì—†ìœ¼ë©´ profile_selectë¡œ ì‹œì‘
  // ë‹¨, localStorageì— ê¹¨ì§„ ì„¸ì´ë¸Œê°€ ìˆì„ ìˆ˜ ìˆìœ¼ë¯€ë¡œ savedGameAvailableì€ false
  return {
    phase: 'profile_select',
    savedGameAvailable: false,
  };
}

/**
 * ì €ì¥ëœ ê²Œì„ì´ ìˆëŠ”ì§€ í™•ì¸í•©ë‹ˆë‹¤ (Continue ë²„íŠ¼ í‘œì‹œìš©).
 *
 * RU-004-S2: ìœ íš¨í•œ ì„¸ì´ë¸Œë§Œ "ìˆìŒ"ìœ¼ë¡œ íŒë‹¨
 *
 * @returns ìœ íš¨í•œ ì„¸ì´ë¸Œê°€ ìˆìœ¼ë©´ true
 */
export function hasValidSaveGame(): boolean {
  return getValidSaveGameOrNull() !== null;
}

/**
 * í”„ë¡œí•„ì„ ì„ íƒí•˜ê³  ìƒˆ ì„¸ì…˜ì„ ì‹œì‘í•©ë‹ˆë‹¤.
 *
 * RU-004-Q4 Step 1: startSessionFromProfile
 * - ëª¨ë“  storeë¥¼ ì´ˆê¸°í™”
 * - í”„ë¡œí•„ ê¸°ë°˜ SaveGame ìƒì„±
 * - storeì— ì´ˆê¸° ìƒíƒœ ì£¼ì…
 * - localStorageì— ì €ì¥
 *
 * @param args.profile - ì„ íƒí•œ ë°ëª¨ í”„ë¡œí•„
 * @param args.t - i18n ë²ˆì—­ í•¨ìˆ˜
 * @returns ì„¸ì…˜ ì‹œì‘ ê²°ê³¼
 */
export function startSessionFromProfile(args: {
  profile: DemoProfile;
  t: (key: string) => string;
}): SessionStartResult {
  const { profile, t } = args;

  // í˜„ì¬ ì–¸ì–´ ì„¤ì • ìœ ì§€
  const language = getResolvedLanguage();

  // í”„ë¡œí•„ì—ì„œ SaveGame ìƒì„±
  const saveGame = createSaveGameFromProfile(profile, language, t);

  // ëª¨ë“  ì„¸ì…˜ store ì´ˆê¸°í™” (ì´ì „ ì„¸ì…˜ ì”ì¬ ì œê±°)
  resetAllSessionStores();

  // Storeì— ì´ˆê¸° ìƒíƒœ ì£¼ì…
  useWorldStore.setState({
    economy: {
      signal: saveGame.economy.signal,
      memory_shard: saveGame.economy.memory_shard,
    },
    turnCount: 0,
    narrativeEntries: saveGame.narrativeHistory,
    quests: saveGame.quests,
    activeRules: saveGame.activeRules,
    mutationTimeline: saveGame.mutationTimeline,
    sceneObjects: saveGame.sceneObjects,
  });

  useInventoryStore.getState().setItems(saveGame.inventory);

  // í”„ë¡œí•„ ID ì €ì¥ (localStorage)
  saveCurrentProfileId(profile.id);

  // SaveGame ì €ì¥ (localStorage)
  saveSaveGame(saveGame);

  return {
    success: true,
    profileId: profile.id,
  };
}

/**
 * ì €ì¥ëœ ê²Œì„ì„ ë³µì›í•˜ì—¬ ì„¸ì…˜ì„ ê³„ì†í•©ë‹ˆë‹¤.
 *
 * RU-004-Q4 Step 1: continueSession
 * RU-004-S1: asyncë¡œ ì–¸ì–´ ì ìš© ì™„ë£Œ í›„ store ì£¼ì…
 * RU-004-S2: profileId SSOT + ë¡œë“œ ì‹¤íŒ¨ ì‹œ null ë°˜í™˜
 *
 * @returns ì„¸ì…˜ ë³µì› ê²°ê³¼ ë˜ëŠ” null (ì‹¤íŒ¨ ì‹œ)
 */
export async function continueSession(): Promise<SessionContinueResult | null> {
  const saveGame = loadSaveGame();
  if (!saveGame) {
    // ë¡œë“œ ì‹¤íŒ¨ ì‹œ í´ë¦°ì—…
    clearSaveGame();
    clearCurrentProfileId();
    console.warn('[SessionLifecycle] SaveGame ë¡œë“œ ì‹¤íŒ¨, ìƒˆë¡œ ì‹œì‘ í•„ìš”');
    return null;
  }

  // RU-004-S1: ì–¸ì–´ ì„¤ì • ë¹„ë™ê¸° ì ìš© ì™„ë£Œ í›„ ì§„í–‰ (RULE-006)
  await changeLanguage(saveGame.language as SupportedLanguage);

  // ëª¨ë“  ì„¸ì…˜ store ì´ˆê¸°í™” (ì´ì „ ì„¸ì…˜ ì”ì¬ ì œê±°)
  resetAllSessionStores();

  // Storeì— ì €ì¥ëœ ìƒíƒœ ë³µì›
  useWorldStore.setState({
    economy: {
      signal: saveGame.economy.signal,
      memory_shard: saveGame.economy.memory_shard,
    },
    turnCount: saveGame.turnCount,
    narrativeEntries: saveGame.narrativeHistory,
    quests: saveGame.quests,
    activeRules: saveGame.activeRules,
    mutationTimeline: saveGame.mutationTimeline,
    sceneObjects: saveGame.sceneObjects,
  });

  // ì¸ë²¤í† ë¦¬ ë³µì›
  useInventoryStore.getState().setItems(saveGame.inventory);

  // Economy ë³µì› (RU-004-S1: hydrateLedgerë¡œ ìˆœì„œ/timestamp/lastCost/isBalanceLow ì •í•©ì„± ë³´ì¥)
  useEconomyStore.getState().hydrateLedger(saveGame.economyLedger, saveGame.economy);

  // RU-004-S2: profileId SSOT - SaveGame.profileIdë¥¼ ê¶Œìœ„ìë¡œ ì‚¬ìš©
  const profileId = saveGame.profileId;
  if (profileId) {
    saveCurrentProfileId(profileId); // localStorage ë™ê¸°í™” (ë“œë¦¬í”„íŠ¸ ë°©ì§€)
  }

  return {
    success: true,
    profileId: profileId ?? loadCurrentProfileId() ?? '',
  };
}

/**
 * í˜„ì¬ í”„ë¡œí•„ì˜ ì´ˆê¸° ìƒíƒœë¡œ ë¦¬ì…‹í•©ë‹ˆë‹¤.
 *
 * RU-004-Q4 Step 1: resetToCurrentProfile
 *
 * @param args.t - i18n ë²ˆì—­ í•¨ìˆ˜
 * @param args.currentProfileId - í˜„ì¬ í”„ë¡œí•„ ID
 * @returns ë¦¬ì…‹ ì„±ê³µ ì—¬ë¶€
 */
export function resetToCurrentProfile(args: {
  t: (key: string) => string;
  currentProfileId: string | null;
}): SessionResetResult {
  const { t, currentProfileId } = args;

  if (!currentProfileId) {
    return { success: false, profileId: null };
  }

  const profile = findProfileById(currentProfileId);
  if (!profile) {
    return { success: false, profileId: null };
  }

  // ë™ì¼ í”„ë¡œí•„ë¡œ ìƒˆ ì„¸ì…˜ ì‹œì‘
  const result = startSessionFromProfile({ profile, t });

  return {
    success: result.success,
    profileId: result.profileId,
  };
}

/**
 * ì„¸ì…˜ì„ ì¢…ë£Œí•˜ê³  í”„ë¡œí•„ ì„ íƒ í™”ë©´ìœ¼ë¡œ ëŒì•„ê°‘ë‹ˆë‹¤.
 *
 * RU-004-Q4 Step 1: clearSessionAndReturnToSelect
 * - ëª¨ë“  ì„¸ì…˜ ë°ì´í„° í´ë¦°ì—… (localStorage + store)
 */
export function clearSessionAndReturnToSelect(): void {
  // localStorage í´ë¦°ì—…
  clearSaveGame();
  clearCurrentProfileId();

  // ëª¨ë“  ì„¸ì…˜ store ì´ˆê¸°í™”
  resetAllSessionStores();
}

/**
 * í˜„ì¬ ìƒíƒœë¥¼ ì €ì¥í•©ë‹ˆë‹¤.
 *
 * í„´ ì™„ë£Œ ì‹œ ìë™ ì €ì¥ì— ì‚¬ìš©ë©ë‹ˆë‹¤.
 *
 * RU-004-Q5: seedëŠ” ì„¸ì…˜ ì‹œì‘ ì‹œ ìƒì„±ë˜ê³ , ì´í›„ ë³€ê²½ë˜ì§€ ì•Šì•„ì•¼ í•©ë‹ˆë‹¤.
 * ê¸°ì¡´ SaveGameì—ì„œ seedë¥¼ ì½ì–´ì™€ì„œ ìœ ì§€í•©ë‹ˆë‹¤.
 *
 * @param profileId - í˜„ì¬ í”„ë¡œí•„ ID
 * @returns ì €ì¥ ì„±ê³µ ì—¬ë¶€
 */
export function saveCurrentSession(profileId: string | null): boolean {
  if (!profileId) return false;

  const worldState = useWorldStore.getState();
  const economyState = useEconomyStore.getState();
  const inventoryState = useInventoryStore.getState();

  // RU-004-Q5: ê¸°ì¡´ SaveGameì—ì„œ seedë¥¼ ê°€ì ¸ì™€ ìœ ì§€ (SSOT)
  const existingSaveGame = getValidSaveGameOrNull();
  const seed = existingSaveGame?.seed ?? null;

  const saveGame = createSaveGame({
    language: getResolvedLanguage(),
    profileId,
    seed, // RU-004-Q5: seed ìœ ì§€
    economy: worldState.economy,
    economyLedger: economyState.ledger,
    turnCount: worldState.turnCount,
    narrativeHistory: worldState.narrativeEntries,
    inventory: inventoryState.items,
    quests: worldState.quests,
    activeRules: worldState.activeRules,
    mutationTimeline: worldState.mutationTimeline,
    sceneObjects: worldState.sceneObjects,
  });

  return saveSaveGame(saveGame);
}

/**
 * ì´ˆê¸° profileIdë¥¼ ê²°ì •í•©ë‹ˆë‹¤.
 *
 * RU-004-S2: SaveGame.profileIdê°€ SSOT, CURRENT_PROFILE_KEYëŠ” í´ë°±
 *
 * @returns ì´ˆê¸° profileId ë˜ëŠ” null
 */
export function getInitialProfileId(): string | null {
  // ìœ íš¨í•œ SaveGameì´ ìˆìœ¼ë©´ ê·¸ profileIdë¥¼ ì‚¬ìš©
  const validSaveGame = getValidSaveGameOrNull();
  if (validSaveGame?.profileId) {
    return validSaveGame.profileId;
  }
  // í´ë°±: CURRENT_PROFILE_KEY (í˜¸í™˜ì„±)
  return loadCurrentProfileId();
}
</file>

<file path="frontend/src/stores/agentStore.test.ts">
import { describe, it, expect, beforeEach } from 'vitest';
import { useAgentStore } from './agentStore';
import { StreamEventType, StageStatus } from '../api/turnStream';
import type { TurnOutput } from '../schemas/turn';

describe('agentStore', () => {
  beforeEach(() => {
    useAgentStore.getState().reset();
  });

  it('should have correct initial state', () => {
    const state = useAgentStore.getState();
    expect(state.isStreaming).toBe(false);
    expect(state.phases).toHaveLength(7);
    expect(state.phases[0].status).toBe('pending');
    expect(state.badges).toEqual([]);
    expect(state.repairCount).toBe(0);
  });

  it('should handle startStream', () => {
    useAgentStore.getState().startStream();
    const state = useAgentStore.getState();
    expect(state.isStreaming).toBe(true);
  });

  it('should handle handleStage events', () => {
    const store = useAgentStore.getState();

    // Start parse phase
    store.handleStage({
      type: StreamEventType.STAGE,
      name: 'parse',
      status: StageStatus.START,
    });

    let state = useAgentStore.getState();
    expect(state.currentPhase).toBe('parse');
    expect(state.phases.find((p) => p.name === 'parse')?.status).toBe('in_progress');

    // Complete parse phase
    store.handleStage({
      type: StreamEventType.STAGE,
      name: 'parse',
      status: StageStatus.COMPLETE,
    });

    state = useAgentStore.getState();
    expect(state.phases.find((p) => p.name === 'parse')?.status).toBe('completed');
  });

  it('should handle handleBadges events', () => {
    const store = useAgentStore.getState();
    store.handleBadges({
      type: StreamEventType.BADGES,
      badges: ['schema_ok', 'economy_ok'],
    });

    const state = useAgentStore.getState();
    expect(state.badges).toEqual(['schema_ok', 'economy_ok']);
  });

  it('should handle handleNarrativeDelta events', () => {
    const store = useAgentStore.getState();
    store.handleNarrativeDelta({
      type: StreamEventType.NARRATIVE_DELTA,
      text: 'Hello ',
    });
    store.handleNarrativeDelta({
      type: StreamEventType.NARRATIVE_DELTA,
      text: 'World',
    });

    const state = useAgentStore.getState();
    expect(state.narrativeBuffer).toBe('Hello World');
  });

  it('should handle handleFinal events', () => {
    const store = useAgentStore.getState();
    const mockOutput = {
      language: 'ko-KR',
      narrative: 'Final message',
      economy: {
        cost: { signal: 0, memory_shard: 0 },
        balance_after: { signal: 100, memory_shard: 0 },
      },
      safety: { blocked: false, message: null },
      ui: { action_deck: { cards: [] }, objects: [], scene: { image_url: null, alt_text: null } },
      world: {
        rules_changed: [],
        inventory_added: [],
        inventory_removed: [],
        quests_updated: [],
        relationships_changed: [],
        memory_pins: [],
      },
      render: { image_job: null },
      agent_console: {
        repair_count: 2,
        current_phase: 'commit',
        badges: [],
      },
    } as TurnOutput;

    store.handleFinal({
      type: StreamEventType.FINAL,
      data: mockOutput,
    });

    const state = useAgentStore.getState();
    expect(state.finalOutput).toEqual(mockOutput);
    expect(state.repairCount).toBe(2);
  });

  it('should handle handleError events', () => {
    const store = useAgentStore.getState();
    store.handleError({
      type: StreamEventType.ERROR,
      message: 'Network error',
      code: 'ERR_NET',
    });

    const state = useAgentStore.getState();
    expect(state.error).toEqual({
      message: 'Network error',
      code: 'ERR_NET',
    });
  });

  it('should reset state on completeStream', () => {
    const store = useAgentStore.getState();
    store.handleNarrativeDelta({ type: StreamEventType.NARRATIVE_DELTA, text: 'Some text' });
    store.startStream();

    store.completeStream();

    const state = useAgentStore.getState();
    expect(state.isStreaming).toBe(false);
    expect(state.narrativeBuffer).toBe('');
  });
});
</file>

<file path="frontend/src/stores/uiPrefsStore.test.ts">
import { describe, it, expect, beforeEach } from 'vitest';
import { useUIPrefsStore, DEFAULT_UI_SCALE, migrateUIPrefs } from './uiPrefsStore';

// Mock localStorage for non-browser environment
// Note: With jsdom environment configured in vite.config.ts, this might not be strictly necessary
// if we trust jsdom's localStorage, but keeping it explicit is fine.
// However, since we are moving to direct function testing for migration, we rely less on persist middleware internals.

describe('uiPrefsStore', () => {
  beforeEach(() => {
    useUIPrefsStore.getState().resetPrefs();
    localStorage.clear();
  });

  it('should have default initial state', () => {
    const state = useUIPrefsStore.getState();
    expect(state.uiScale).toBe(DEFAULT_UI_SCALE);
  });

  it('should increase ui scale within limit', () => {
    const { increaseUIScale } = useUIPrefsStore.getState();

    // 1.0 -> 1.1
    increaseUIScale();
    expect(useUIPrefsStore.getState().uiScale).toBe(1.1);

    // 1.1 -> 1.2
    increaseUIScale();
    expect(useUIPrefsStore.getState().uiScale).toBe(1.2);

    // 1.2 -> 1.2 (Max)
    increaseUIScale();
    expect(useUIPrefsStore.getState().uiScale).toBe(1.2);
  });

  it('should decrease ui scale within limit', () => {
    const { decreaseUIScale, setUIScale } = useUIPrefsStore.getState();

    // Start at max
    setUIScale(1.2);

    // 1.2 -> 1.1
    decreaseUIScale();
    expect(useUIPrefsStore.getState().uiScale).toBe(1.1);

    // ... -> 0.9 (Min)
    setUIScale(0.9);
    decreaseUIScale();
    expect(useUIPrefsStore.getState().uiScale).toBe(0.9);
  });

  it('should set valid ui scale', () => {
    const { setUIScale } = useUIPrefsStore.getState();

    setUIScale(1.1);
    expect(useUIPrefsStore.getState().uiScale).toBe(1.1);
  });

  it('should ignore invalid ui scale', () => {
    const { setUIScale } = useUIPrefsStore.getState();

    // @ts-expect-error Testing invalid input
    setUIScale(2.0);
    expect(useUIPrefsStore.getState().uiScale).toBe(DEFAULT_UI_SCALE);
  });

  describe('migration (U-037)', () => {
    it('should remove readableMode from legacy storage', () => {
      // Legacy state simulation
      const legacyState = {
        uiScale: 1.1,
        readableMode: true,
      };

      // Call migrate function directly
      const migratedState = migrateUIPrefs(legacyState, 0);

      // Verify
      expect(migratedState).toHaveProperty('uiScale', 1.1);
      expect(migratedState).not.toHaveProperty('readableMode');
    });

    it('should handle undefined version (very old legacy)', () => {
      const legacyState = {
        uiScale: 0.9,
        readableMode: false,
      };

      // Call migrate function directly with undefined version
      const migratedState = migrateUIPrefs(legacyState, undefined);

      expect(migratedState).toHaveProperty('uiScale', 0.9);
      expect(migratedState).not.toHaveProperty('readableMode');
    });

    it('should pass through already migrated state', () => {
      const modernState = {
        uiScale: 1.0,
      };

      const migratedState = migrateUIPrefs(modernState, 1);
      expect(migratedState).toEqual(modernState);
    });
  });
});
</file>

<file path="frontend/src/stores/uiPrefsStore.ts">
/**
 * Unknown World - UI ì„¤ì • ìƒíƒœ ê´€ë¦¬ (Zustand + persist).
 *
 * UI ìŠ¤ì¼€ì¼ ì„¤ì •ì„ ì €ì¥í•˜ê³ , SaveGame êµ¬ì¡°ì™€ í†µí•© ê°€ëŠ¥í•˜ë„ë¡ ì§ë ¬í™” ì¸í„°í˜ì´ìŠ¤ë¥¼ ì œê³µí•©ë‹ˆë‹¤.
 *
 * ì„¤ê³„ ì›ì¹™:
 *   - PRD 9.4: ê°€ë…ì„±(í•„ìˆ˜) - ì „ì—­ UI ìŠ¤ì¼€ì¼ ì¡°ì ˆ ì œê³µ
 *   - U-037: Readable ëª¨ë“œ ì œê±° â†’ critical/ambient ì¤‘ìš”ë„ ê¸°ë°˜ ìŠ¤íƒ€ì¼ë¡œ ëŒ€ì²´
 *   - Q1 ê²°ì •: Option B (SaveGameì— í¬í•¨) - persist + ì§ë ¬í™”
 *
 * @module stores/uiPrefsStore
 */

import { create } from 'zustand';
import { persist, createJSONStorage } from 'zustand/middleware';

// =============================================================================
// ìƒìˆ˜ ì •ì˜
// =============================================================================

/** ì§€ì›í•˜ëŠ” UI ìŠ¤ì¼€ì¼ ê°’ */
export const UI_SCALES = [0.9, 1.0, 1.1, 1.2] as const;
export type UIScale = (typeof UI_SCALES)[number];

/** ê¸°ë³¸ UI ìŠ¤ì¼€ì¼ */
export const DEFAULT_UI_SCALE: UIScale = 1.0;

/** localStorage í‚¤ (SaveGame í†µí•© ì‹œì—ë„ ì‚¬ìš© ê°€ëŠ¥) */
export const UI_PREFS_STORAGE_KEY = 'unknown-world-ui-prefs';

// =============================================================================
// ìƒíƒœ íƒ€ì… ì •ì˜
// =============================================================================

/** UI ì„¤ì • ìƒíƒœ (SaveGame ì§ë ¬í™” ëŒ€ìƒ) */
export interface UIPrefsState {
  /**
   * UI ìŠ¤ì¼€ì¼ (0.9 ~ 1.2)
   * - 0.9: ì‘ì€ UI (ì •ë³´ ë°€ë„ ë†’ìŒ)
   * - 1.0: ê¸°ë³¸
   * - 1.1: ì•½ê°„ í™•ëŒ€
   * - 1.2: í° UI (ê°€ë…ì„± ìš°ì„ )
   */
  uiScale: UIScale;
}

/** UI ì„¤ì • ì•¡ì…˜ */
export interface UIPrefsActions {
  /** UI ìŠ¤ì¼€ì¼ ì„¤ì • */
  setUIScale: (scale: UIScale) => void;

  /** UI ìŠ¤ì¼€ì¼ ì¦ê°€ (ìµœëŒ€ 1.2) */
  increaseUIScale: () => void;

  /** UI ìŠ¤ì¼€ì¼ ê°ì†Œ (ìµœì†Œ 0.9) */
  decreaseUIScale: () => void;

  /** ì„¤ì • ì´ˆê¸°í™” */
  resetPrefs: () => void;

  /**
   * SaveGame ì§ë ¬í™”ìš© ìƒíƒœ ì¶”ì¶œ
   * (ì¶”í›„ SaveGame í†µí•© ì‹œ ì‚¬ìš©)
   */
  getSerializableState: () => UIPrefsState;

  /**
   * SaveGame ì—­ì§ë ¬í™”ìš© ìƒíƒœ ë³µì›
   * (ì¶”í›„ SaveGame í†µí•© ì‹œ ì‚¬ìš©)
   */
  restoreState: (state: Partial<UIPrefsState>) => void;
}

export type UIPrefsStore = UIPrefsState & UIPrefsActions;

// =============================================================================
// ì´ˆê¸° ìƒíƒœ
// =============================================================================

/** ì´ˆê¸° ìƒíƒœ ìƒì„± */
function createInitialState(): UIPrefsState {
  return {
    uiScale: DEFAULT_UI_SCALE,
  };
}

// =============================================================================
// ìœ í‹¸ë¦¬í‹° í•¨ìˆ˜
// =============================================================================

/**
 * ì£¼ì–´ì§„ ìŠ¤ì¼€ì¼ì´ ìœ íš¨í•œì§€ í™•ì¸
 */
function isValidScale(scale: number): scale is UIScale {
  return UI_SCALES.includes(scale as UIScale);
}

/**
 * ìŠ¤ì¼€ì¼ ì¸ë±ìŠ¤ ë°˜í™˜
 */
function getScaleIndex(scale: UIScale): number {
  return UI_SCALES.indexOf(scale);
}

/**
 * U-037: legacy ì €ì¥ê°’(readableMode) ë§ˆì´ê·¸ë ˆì´ì…˜/ë¬´ì‹œ
 * @internal exported for testing
 */
export function migrateUIPrefs(persistedState: unknown, version: number | undefined): UIPrefsState {
  // version 0 ë˜ëŠ” undefinedì—ì„œ version 1ë¡œ ë§ˆì´ê·¸ë ˆì´ì…˜
  // readableMode í•„ë“œê°€ ìˆìœ¼ë©´ ì œê±°
  if (version === 0 || version === undefined) {
    const state = persistedState as Record<string, unknown>;
    // readableMode í•„ë“œ ì œê±° (ë¬´ì‹œ)
    if ('readableMode' in state) {
      const { readableMode: _, ...rest } = state;
      return { ...rest, uiScale: state.uiScale ?? DEFAULT_UI_SCALE } as UIPrefsState;
    }
    return { ...state, uiScale: state.uiScale ?? DEFAULT_UI_SCALE } as UIPrefsState;
  }
  return persistedState as UIPrefsState;
}

// =============================================================================
// Zustand Store with persist
// =============================================================================

/**
 * UI ì„¤ì • ìŠ¤í† ì–´.
 *
 * U-037: Readable ëª¨ë“œ ì œê±°ë¨. CRT íš¨ê³¼ëŠ” critical/ambient ì¤‘ìš”ë„ ê¸°ë°˜ìœ¼ë¡œ ìë™ ì ìš©ë©ë‹ˆë‹¤.
 *
 * @example
 * ```tsx
 * // ì»´í¬ë„ŒíŠ¸ì—ì„œ ì‚¬ìš©
 * const { uiScale, setUIScale } = useUIPrefsStore();
 *
 * // DOM ì ìš© (App.tsxì—ì„œ)
 * useEffect(() => {
 *   document.documentElement.dataset.uiScale = uiScale.toString();
 *   document.documentElement.style.setProperty('--ui-scale-factor', uiScale.toString());
 * }, [uiScale]);
 * ```
 */
export const useUIPrefsStore = create<UIPrefsStore>()(
  persist(
    (set, get) => ({
      // ì´ˆê¸° ìƒíƒœ
      ...createInitialState(),

      // ì•¡ì…˜
      setUIScale: (scale) => {
        if (isValidScale(scale)) {
          set({ uiScale: scale });
        }
      },

      increaseUIScale: () => {
        const currentIndex = getScaleIndex(get().uiScale);
        const nextIndex = Math.min(currentIndex + 1, UI_SCALES.length - 1);
        set({ uiScale: UI_SCALES[nextIndex] });
      },

      decreaseUIScale: () => {
        const currentIndex = getScaleIndex(get().uiScale);
        const prevIndex = Math.max(currentIndex - 1, 0);
        set({ uiScale: UI_SCALES[prevIndex] });
      },

      resetPrefs: () => {
        set(createInitialState());
      },

      getSerializableState: () => {
        const { uiScale } = get();
        return { uiScale };
      },

      restoreState: (state) => {
        const updates: Partial<UIPrefsState> = {};

        if (state.uiScale !== undefined && isValidScale(state.uiScale)) {
          updates.uiScale = state.uiScale;
        }

        if (Object.keys(updates).length > 0) {
          set(updates);
        }
      },
    }),
    {
      name: UI_PREFS_STORAGE_KEY,
      storage: createJSONStorage(() => localStorage),
      // ì§ë ¬í™”í•  í•„ë“œ ì§€ì • (ì•¡ì…˜ ì œì™¸)
      partialize: (state) => ({
        uiScale: state.uiScale,
      }),
      // U-037: legacy ì €ì¥ê°’(readableMode) ë§ˆì´ê·¸ë ˆì´ì…˜/ë¬´ì‹œ
      version: 1,
      migrate: migrateUIPrefs,
    },
  ),
);

// =============================================================================
// ì…€ë ‰í„° (ì„±ëŠ¥ ìµœì í™”ìš©)
// =============================================================================

/** UI ìŠ¤ì¼€ì¼ ì…€ë ‰í„° */
export const selectUIScale = (state: UIPrefsStore) => state.uiScale;

// =============================================================================
// DOM ì ìš© í—¬í¼
// =============================================================================

/**
 * CSS ë³€ìˆ˜ë¡œ UI ìŠ¤ì¼€ì¼ ì ìš©
 * í˜¸ì¶œ ì‹œ html ìš”ì†Œì— --ui-scale-factor ë³€ìˆ˜ë¥¼ ì„¤ì •
 */
export function applyUIScaleToDOM(scale: UIScale): void {
  document.documentElement.style.setProperty('--ui-scale-factor', scale.toString());
  document.documentElement.dataset.uiScale = scale.toString();
}

/**
 * ì „ì²´ UI ì„¤ì • DOM ì ìš©
 * U-037: readableMode ì œê±°ë¨ - ìŠ¤ì¼€ì¼ë§Œ ì ìš©
 */
export function applyUIPrefsToDOM(state: UIPrefsState): void {
  applyUIScaleToDOM(state.uiScale);
}
</file>

<file path="frontend/src/stores/worldStore.test.ts">
import { describe, it, expect, beforeEach, vi } from 'vitest';
import { useWorldStore } from './worldStore';
import type { TurnOutput } from '../schemas/turn';

// í•˜ìœ„ ìŠ¤í† ì–´ ëª¨í‚¹ (ìˆœí™˜ import ë°©ì§€ ë¡œì§ ëŒ€ì‘)
vi.mock('./actionDeckStore', () => ({
  useActionDeckStore: {
    getState: () => ({
      setCards: vi.fn(),
    }),
  },
}));

vi.mock('./inventoryStore', () => ({
  useInventoryStore: {
    getState: () => ({
      addItems: vi.fn(),
      removeItems: vi.fn(),
    }),
  },
  parseInventoryAdded: (items: unknown) => items,
}));

describe('worldStore (U-013: Quest + Rules)', () => {
  beforeEach(() => {
    useWorldStore.getState().reset();
  });

  it('ì´ˆê¸° ìƒíƒœê°€ ì˜¬ë°”ë¼ì•¼ í•œë‹¤', () => {
    const state = useWorldStore.getState();
    expect(state.quests).toEqual([]);
    expect(state.activeRules).toEqual([]);
    expect(state.mutationTimeline).toEqual([]);
  });

  it('applyTurnOutputì„ í†µí•´ ìƒˆ í€˜ìŠ¤íŠ¸ê°€ ì¶”ê°€ë˜ì–´ì•¼ í•œë‹¤', () => {
    const mockOutput: Partial<TurnOutput> = {
      narrative: 'ìƒˆ í€˜ìŠ¤íŠ¸ ë°œìƒ',
      economy: {
        cost: { signal: 0, memory_shard: 0 },
        balance_after: { signal: 100, memory_shard: 5 },
      },
      ui: {
        scene: { image_url: '', alt_text: '' },
        action_deck: { cards: [] },
        objects: [],
      },
      world: {
        inventory_added: [],
        inventory_removed: [],
        quests_updated: [
          {
            id: 'q1',
            label: 'ì²« ë²ˆì§¸ ì„ë¬´',
            is_completed: false,
          },
        ],
        rules_changed: [],
        relationships_changed: [],
        memory_pins: [],
      },
      agent_console: {
        current_phase: 'commit',
        badges: ['schema_ok'],
        repair_count: 0,
      },
      safety: { blocked: false, message: null },
    };

    useWorldStore.getState().applyTurnOutput(mockOutput as TurnOutput);

    const state = useWorldStore.getState();
    expect(state.quests).toHaveLength(1);
    expect(state.quests[0].id).toBe('q1');
    expect(state.quests[0].is_completed).toBe(false);
  });

  it('ê¸°ì¡´ í€˜ìŠ¤íŠ¸ê°€ ì—…ë°ì´íŠ¸(ì™„ë£Œ)ë˜ì–´ì•¼ í•œë‹¤', () => {
    // 1. ì´ˆê¸° í€˜ìŠ¤íŠ¸ ì¶”ê°€
    const initialState: Partial<TurnOutput> = {
      narrative: 'ì´ˆê¸°í™”',
      economy: {
        cost: { signal: 0, memory_shard: 0 },
        balance_after: { signal: 100, memory_shard: 5 },
      },
      ui: {
        scene: { image_url: '', alt_text: '' },
        action_deck: { cards: [] },
        objects: [],
      },
      world: {
        inventory_added: [],
        inventory_removed: [],
        quests_updated: [{ id: 'q1', label: 'ì„ë¬´', is_completed: false }],
        rules_changed: [],
        relationships_changed: [],
        memory_pins: [],
      },
      agent_console: {
        current_phase: 'commit',
        badges: ['schema_ok'],
        repair_count: 0,
      },
      safety: { blocked: false, message: null },
    };
    useWorldStore.getState().applyTurnOutput(initialState as TurnOutput);

    // 2. í€˜ìŠ¤íŠ¸ ì™„ë£Œ ì—…ë°ì´íŠ¸
    const updateOutput: Partial<TurnOutput> = {
      narrative: 'ì„ë¬´ ì™„ë£Œ!',
      economy: {
        cost: { signal: 0, memory_shard: 0 },
        balance_after: { signal: 100, memory_shard: 5 },
      },
      ui: {
        scene: { image_url: '', alt_text: '' },
        action_deck: { cards: [] },
        objects: [],
      },
      world: {
        inventory_added: [],
        inventory_removed: [],
        quests_updated: [{ id: 'q1', label: 'ì„ë¬´', is_completed: true }],
        rules_changed: [],
        relationships_changed: [],
        memory_pins: [],
      },
      agent_console: {
        current_phase: 'commit',
        badges: ['schema_ok'],
        repair_count: 0,
      },
      safety: { blocked: false, message: null },
    };
    useWorldStore.getState().applyTurnOutput(updateOutput as TurnOutput);

    const state = useWorldStore.getState();
    expect(state.quests).toHaveLength(1);
    expect(state.quests[0].is_completed).toBe(true);
  });

  it('ìƒˆ ê·œì¹™ì´ ì¶”ê°€ë˜ê³  íƒ€ì„ë¼ì¸ì— ê¸°ë¡ë˜ì–´ì•¼ í•œë‹¤', () => {
    const mockOutput: Partial<TurnOutput> = {
      narrative: 'ìƒˆ ê·œì¹™ ì ìš©',
      economy: {
        cost: { signal: 0, memory_shard: 0 },
        balance_after: { signal: 100, memory_shard: 5 },
      },
      ui: {
        scene: { image_url: '', alt_text: '' },
        action_deck: { cards: [] },
        objects: [],
      },
      world: {
        inventory_added: [],
        inventory_removed: [],
        quests_updated: [],
        rules_changed: [
          {
            id: 'rule1',
            label: 'ì¤‘ë ¥ ê°•í™”',
            description: 'ì í”„ ë†’ì´ê°€ ì ˆë°˜ìœ¼ë¡œ ê°ì†Œí•©ë‹ˆë‹¤.',
          },
        ],
        relationships_changed: [],
        memory_pins: [],
      },
      agent_console: {
        current_phase: 'commit',
        badges: ['schema_ok'],
        repair_count: 0,
      },
      safety: { blocked: false, message: null },
    };

    useWorldStore.getState().applyTurnOutput(mockOutput as TurnOutput);

    const state = useWorldStore.getState();
    expect(state.activeRules).toHaveLength(1);
    expect(state.activeRules[0].id).toBe('rule1');

    expect(state.mutationTimeline).toHaveLength(1);
    expect(state.mutationTimeline[0].ruleId).toBe('rule1');
    expect(state.mutationTimeline[0].type).toBe('added');
  });

  it('ê¸°ì¡´ ê·œì¹™ ìˆ˜ì • ì‹œ íƒ€ì„ë¼ì¸ì— ê¸°ë¡ë˜ì–´ì•¼ í•œë‹¤', () => {
    // 1. ì´ˆê¸° ê·œì¹™ ì¶”ê°€
    const initialState: Partial<TurnOutput> = {
      narrative: 'ì´ˆê¸°í™”',
      economy: {
        cost: { signal: 0, memory_shard: 0 },
        balance_after: { signal: 100, memory_shard: 5 },
      },
      ui: {
        scene: { image_url: '', alt_text: '' },
        action_deck: { cards: [] },
        objects: [],
      },
      world: {
        inventory_added: [],
        inventory_removed: [],
        quests_updated: [],
        rules_changed: [{ id: 'rule1', label: 'ê·œì¹™', description: 'ê¸°ì¡´' }],
        relationships_changed: [],
        memory_pins: [],
      },
      agent_console: {
        current_phase: 'commit',
        badges: ['schema_ok'],
        repair_count: 0,
      },
      safety: { blocked: false, message: null },
    };
    useWorldStore.getState().applyTurnOutput(initialState as TurnOutput);

    // 2. ê·œì¹™ ìˆ˜ì •
    const updateOutput: Partial<TurnOutput> = {
      narrative: 'ê·œì¹™ ìˆ˜ì •',
      economy: {
        cost: { signal: 0, memory_shard: 0 },
        balance_after: { signal: 100, memory_shard: 5 },
      },
      ui: {
        scene: { image_url: '', alt_text: '' },
        action_deck: { cards: [] },
        objects: [],
      },
      world: {
        inventory_added: [],
        inventory_removed: [],
        quests_updated: [],
        rules_changed: [{ id: 'rule1', label: 'ê·œì¹™', description: 'ìˆ˜ì •ë¨' }],
        relationships_changed: [],
        memory_pins: [],
      },
      agent_console: {
        current_phase: 'commit',
        badges: ['schema_ok'],
        repair_count: 0,
      },
      safety: { blocked: false, message: null },
    };
    useWorldStore.getState().applyTurnOutput(updateOutput as TurnOutput);

    const state = useWorldStore.getState();
    expect(state.activeRules[0].description).toBe('ìˆ˜ì •ë¨');
    expect(state.mutationTimeline).toHaveLength(2);
    expect(state.mutationTimeline[0].type).toBe('modified');
  });

  describe('Initialization and Reset (U-015[Mvp])', () => {
    it('reset ì•¡ì…˜ì€ ëª¨ë“  ìƒíƒœë¥¼ ì´ˆê¸°ê°’ìœ¼ë¡œ ë˜ëŒë ¤ì•¼ í•œë‹¤', () => {
      // 1. ì„ì˜ì˜ ìƒíƒœ ì„¤ì •
      useWorldStore.setState({
        turnCount: 10,
        economy: { signal: 50, memory_shard: 0 },
        quests: [{ id: 'q1', label: 'í€˜ìŠ¤íŠ¸', is_completed: false }],
      });

      // 2. ë¦¬ì…‹ ì‹¤í–‰
      useWorldStore.getState().reset();

      // 3. ê²€ì¦
      const state = useWorldStore.getState();
      expect(state.turnCount).toBe(0);
      expect(state.economy.signal).toBe(100);
      expect(state.quests).toEqual([]);
      expect(state.narrativeEntries).toEqual([]);
    });

    it('initialize ì•¡ì…˜ì€ ì›°ì»´ ë©”ì‹œì§€ì™€ í•¨ê»˜ ì´ˆê¸° ìƒíƒœë¥¼ ì„¤ì •í•´ì•¼ í•œë‹¤', () => {
      const welcomeMsg = 'í™˜ì˜í•©ë‹ˆë‹¤!';
      useWorldStore.getState().initialize(welcomeMsg);

      const state = useWorldStore.getState();
      expect(state.turnCount).toBe(0);
      expect(state.narrativeEntries).toHaveLength(1);
      expect(state.narrativeEntries[0].text).toBe(welcomeMsg);
      expect(state.narrativeEntries[0].turn).toBe(0);
    });
  });
});
</file>

<file path="frontend/tsconfig.json">
{
  "compilerOptions": {
    "target": "ES2022",
    "useDefineForClassFields": true,
    "lib": ["ES2022", "DOM", "DOM.Iterable"],
    "module": "ESNext",
    "skipLibCheck": true,

    /* Bundler mode */
    "moduleResolution": "Bundler",
    "allowImportingTsExtensions": true,
    "isolatedModules": true,
    "moduleDetection": "force",
    "noEmit": true,
    "jsx": "react-jsx",

    /* Linting (ì—„ê²© ëª¨ë“œ) */
    "strict": true,
    "noUnusedLocals": true,
    "noUnusedParameters": true,
    "noFallthroughCasesInSwitch": true,
    "noUncheckedSideEffectImports": true
  },
  "include": ["src"],
  "references": [{ "path": "./tsconfig.node.json" }]
}
</file>

<file path="backend/src/unknown_world/__init__.py">
"""Unknown World - Backend Package

This is the main package for the Unknown World backend.
Architecture: FastAPI + Pydantic + SSE streaming

Reference:
- vibe/tech-stack.md (Python 3.14, FastAPI 0.128.0, Pydantic 2.12.5)
- vibe/prd.md (Agent-based Game Master Engine)
"""

__version__ = "0.1.0"
</file>

<file path="backend/src/unknown_world/main.py">
"""Unknown World - FastAPI ì• í”Œë¦¬ì¼€ì´ì…˜ ì—”íŠ¸ë¦¬í¬ì¸íŠ¸

ì´ ëª¨ë“ˆì€ Unknown World ë°±ì—”ë“œì˜ FastAPI ì•±ì„ ì •ì˜í•©ë‹ˆë‹¤.
MVP ë‹¨ê³„ì—ì„œëŠ” ê¸°ë³¸ í—¬ìŠ¤ì²´í¬ì™€ ê°œë°œìš© CORS ì„¤ì •ë§Œ í¬í•¨í•©ë‹ˆë‹¤.

ì‹¤í–‰ ë°©ë²•:
    cd backend
    uv sync
    uv run uvicorn unknown_world.main:app --reload --port 8011

ì°¸ì¡°:
    - vibe/tech-stack.md (ë²„ì „ SSOT)
    - vibe/prd.md (ì—ì´ì „íŠ¸í˜• ê²Œì„ ì—”ì§„ ìš”êµ¬ì‚¬í•­)
    - .cursor/rules/20-backend-orchestrator.mdc (SSE/ê²€ì¦/ë³µêµ¬ ê·œì¹™)
"""

from typing import Literal

from fastapi import FastAPI
from fastapi.middleware.cors import CORSMiddleware
from pydantic import BaseModel

from unknown_world import __version__
from unknown_world.api import turn_router

# =============================================================================
# FastAPI ì•± ì¸ìŠ¤í„´ìŠ¤
# =============================================================================

app = FastAPI(
    title="Unknown World API",
    description="Gemini ê¸°ë°˜ ì—ì´ì „íŠ¸í˜• ê²Œì„ ì—”ì§„ ì˜¤ì¼€ìŠ¤íŠ¸ë ˆì´í„°",
    version=__version__,
    docs_url="/docs",
    redoc_url="/redoc",
)

# =============================================================================
# CORS ì„¤ì • (ê°œë°œ í™˜ê²½ìš©)
# =============================================================================
# PRD ìš”êµ¬: ë¡œì»¬ ê°œë°œì—ì„œ í”„ë¡ íŠ¸ì™€ í†µì‹ í•  ìˆ˜ ìˆë„ë¡ CORS ê¸°ë³¸ ì •ì±… ì¤€ë¹„
# RULE-011: í”„ë¡ íŠ¸ì—”ë“œëŠ” 8001~8010 í¬íŠ¸ ì‚¬ìš©
# ì£¼ì˜: í”„ë¡œë•ì…˜ì—ì„œëŠ” MMP ë‹¨ê³„ì—ì„œ ì—„ê²©í•œ ì •ì±…ìœ¼ë¡œ ë³€ê²½í•´ì•¼ í•¨

ALLOWED_ORIGINS = [
    # í”„ë¡ íŠ¸ì—”ë“œ ê°œë°œ ì„œë²„ í¬íŠ¸ ë²”ìœ„ (RULE-011: 8001~8010)
    *[f"http://localhost:{port}" for port in range(8001, 8011)],
    *[f"http://127.0.0.1:{port}" for port in range(8001, 8011)],
]

app.add_middleware(
    CORSMiddleware,
    allow_origins=ALLOWED_ORIGINS,
    allow_credentials=True,
    allow_methods=["*"],
    allow_headers=["*"],
)

# =============================================================================
# ë¼ìš°í„° ë“±ë¡
# =============================================================================

# U-007: /api/turn HTTP Streaming ì—”ë“œí¬ì¸íŠ¸
app.include_router(turn_router)


# =============================================================================
# ì‘ë‹µ ìŠ¤í‚¤ë§ˆ (Pydantic)
# =============================================================================


class HealthResponse(BaseModel):
    """í—¬ìŠ¤ì²´í¬ ì‘ë‹µ ìŠ¤í‚¤ë§ˆ.

    Attributes:
        status: ì„œë²„ ìƒíƒœ ("ok" ë˜ëŠ” "degraded")
        version: ë°±ì—”ë“œ ë²„ì „
        service: ì„œë¹„ìŠ¤ ì´ë¦„
    """

    status: Literal["ok", "degraded"]
    version: str
    service: str


# =============================================================================
# ë¼ìš°íŠ¸ ì •ì˜
# =============================================================================


@app.get("/health", response_model=HealthResponse, tags=["System"])
async def health_check() -> HealthResponse:
    """ì„œë²„ í—¬ìŠ¤ì²´í¬ ì—”ë“œí¬ì¸íŠ¸.

    ì„œë²„ê°€ ì •ìƒì ìœ¼ë¡œ ì‘ë™ ì¤‘ì¸ì§€ í™•ì¸í•©ë‹ˆë‹¤.
    ì´ ì—”ë“œí¬ì¸íŠ¸ëŠ” ë¡œë“œë°¸ëŸ°ì„œ, ëª¨ë‹ˆí„°ë§ ì‹œìŠ¤í…œ, í´ë¼ì´ì–¸íŠ¸ ì—°ê²° í™•ì¸ì— ì‚¬ìš©ë©ë‹ˆë‹¤.

    Returns:
        HealthResponse: ì„œë²„ ìƒíƒœ ì •ë³´
    """
    return HealthResponse(
        status="ok",
        version=__version__,
        service="unknown-world-backend",
    )


@app.get("/", tags=["System"])
async def root() -> dict[str, str]:
    """ë£¨íŠ¸ ì—”ë“œí¬ì¸íŠ¸.

    API ì •ë³´ë¥¼ ê°„ëµíˆ ì•ˆë‚´í•©ë‹ˆë‹¤.

    Returns:
        dict: ê¸°ë³¸ ì•ˆë‚´ ë©”ì‹œì§€
    """
    return {
        "message": "Unknown World API",
        "docs": "/docs",
        "health": "/health",
    }
</file>

<file path="backend/src/unknown_world/orchestrator/mock.py">
"""Unknown World - ëª¨ì˜ Orchestrator.

ì‹¤ëª¨ë¸(Gemini) ì—†ì´ í”„ë¡ íŠ¸ì—”ë“œ ê°œë°œ/ë°ëª¨ë¥¼ ì§€ì†í•  ìˆ˜ ìˆë„ë¡
ê²°ì •ì (seed ê¸°ë°˜) TurnOutputì„ ìƒì„±í•˜ëŠ” ëª¨ì˜ Orchestratorì…ë‹ˆë‹¤.

ì„¤ê³„ ì›ì¹™:
    - RULE-004: ê²€ì¦ ì‹¤íŒ¨ ì‹œ ì•ˆì „í•œ í´ë°± ì œê³µ
    - RULE-005: ì¬í™” ì¸ë°”ë¦¬ì–¸íŠ¸ (ì”ì•¡ ìŒìˆ˜ ê¸ˆì§€)
    - RULE-008: ë‹¨ê³„/ë°°ì§€ ê°€ì‹œí™”
    - RULE-009: ì¢Œí‘œ ê·œì•½ (0~1000, bbox [ymin,xmin,ymax,xmax])

ì°¸ì¡°:
    - vibe/unit-plans/U-007[Mvp].md
    - .cursor/rules/20-backend-orchestrator.mdc
"""

import random

from unknown_world.models.turn import (
    ActionCard,
    ActionDeck,
    AgentConsole,
    AgentPhase,
    Box2D,
    CurrencyAmount,
    EconomyOutput,
    ImageJob,
    Language,
    MemoryPin,
    ModelLabel,
    Quest,
    RenderOutput,
    RiskLevel,
    SafetyOutput,
    SceneObject,
    TurnInput,
    TurnOutput,
    UIOutput,
    ValidationBadge,
    WorldDelta,
    WorldRule,
)

# =============================================================================
# ëª¨ì˜ ë°ì´í„° ìƒì„± í—¬í¼
# =============================================================================

# í•œêµ­ì–´ ë‚´ëŸ¬í‹°ë¸Œ í…œí”Œë¦¿
KO_NARRATIVES = [
    "ì–´ë‘  ì†ì—ì„œ í¬ë¯¸í•œ ë¹›ì´ ìƒˆì–´ë‚˜ì˜µë‹ˆë‹¤. ì˜¤ë˜ëœ ë¬¸ì´ ì‚ê±±ê±°ë¦¬ë©° ì—´ë¦¬ê³ , ê·¸ ë„ˆë¨¸ë¡œ ì•Œ ìˆ˜ ì—†ëŠ” ì„¸ê³„ê°€ í¼ì³ì§‘ë‹ˆë‹¤.",
    "ë°œê±¸ìŒ ì†Œë¦¬ê°€ í…… ë¹ˆ ë³µë„ì— ë©”ì•„ë¦¬ì¹©ë‹ˆë‹¤. ë²½ì— ê±¸ë¦° ì´ˆìƒí™”ë“¤ì˜ ëˆˆì´ ë‹¹ì‹ ì„ ë”°ë¼ ì›€ì§ì´ëŠ” ê²ƒ ê°™ìŠµë‹ˆë‹¤.",
    "ê°‘ìê¸° ë°”ë‹¥ì´ í”ë“¤ë¦¬ë©°, ë²½ì—ì„œ ê³ ëŒ€ì˜ ë¬¸ìë“¤ì´ ë¹›ë‚˜ê¸° ì‹œì‘í•©ë‹ˆë‹¤. ë¬´ì–¸ê°€ê°€ ê¹¨ì–´ë‚˜ê³  ìˆìŠµë‹ˆë‹¤.",
    "ì•ˆê°œê°€ ê±·íˆì, ê±°ëŒ€í•œ íƒ‘ì´ ëª¨ìŠµì„ ë“œëŸ¬ëƒ…ë‹ˆë‹¤. íƒ‘ ê¼­ëŒ€ê¸°ì—ì„œ ì´ìƒí•œ ë¹›ì´ ê¹œë¹¡ì´ê³  ìˆìŠµë‹ˆë‹¤.",
    "ë‚¡ì€ ì±…ì¥ì„ ë°€ì, ìˆ¨ê²¨ì§„ í†µë¡œê°€ ë‚˜íƒ€ë‚¬ìŠµë‹ˆë‹¤. í†µë¡œ ëì—ì„œ ê¸°ë¬˜í•œ ë…¸ë˜ê°€ ë“¤ë ¤ì˜µë‹ˆë‹¤.",
]

# ì˜ì–´ ë‚´ëŸ¬í‹°ë¸Œ í…œí”Œë¦¿
EN_NARRATIVES = [
    "A faint light seeps through the darkness. An ancient door creaks open, revealing an unknown world beyond.",
    "Footsteps echo through the empty corridor. The eyes of the portraits on the walls seem to follow you.",
    "Suddenly, the ground shakes and ancient runes on the walls begin to glow. Something is awakening.",
    "As the fog lifts, a massive tower reveals itself. A strange light flickers at its peak.",
    "Pushing aside the old bookshelf, you discover a hidden passage. An eerie song emanates from its depths.",
]

# í•œêµ­ì–´ ì•¡ì…˜ ì¹´ë“œ í…œí”Œë¦¿
KO_ACTION_CARDS = [
    {"label": "ë¬¸ì„ ì—´ì–´ë³¸ë‹¤", "description": "ì¡°ì‹¬ìŠ¤ëŸ½ê²Œ ë¬¸ì„ ì—´ì–´ ì•ˆì„ ì‚´í´ë³¸ë‹¤"},
    {"label": "ì£¼ë³€ì„ íƒìƒ‰í•œë‹¤", "description": "ì£¼ë³€ì— ìœ ìš©í•œ ë¬¼ê±´ì´ ìˆëŠ”ì§€ ì°¾ì•„ë³¸ë‹¤"},
    {"label": "ë’¤ë¡œ ë¬¼ëŸ¬ì„ ë‹¤", "description": "ìœ„í—˜ì„ í”¼í•´ ì•ˆì „í•œ ê³³ìœ¼ë¡œ ë¬¼ëŸ¬ì„ ë‹¤"},
    {"label": "ë§ì„ ê±¸ì–´ë³¸ë‹¤", "description": "ìƒëŒ€ë°©ì—ê²Œ ì¡°ì‹¬ìŠ¤ëŸ½ê²Œ ë§ì„ ê±´ë‹¤"},
    {"label": "ìˆ¨ì–´ì„œ ì§€ì¼œë³¸ë‹¤", "description": "ì€ì‹ í•˜ì—¬ ìƒí™©ì„ ê´€ì°°í•œë‹¤"},
    {"label": "ê³µê²©í•œë‹¤", "description": "ìœ„í˜‘ì— ë§ì„œ ê³µê²©ì„ ì‹œë„í•œë‹¤"},
]

# ì˜ì–´ ì•¡ì…˜ ì¹´ë“œ í…œí”Œë¦¿
EN_ACTION_CARDS = [
    {"label": "Open the door", "description": "Carefully open the door and look inside"},
    {"label": "Search the area", "description": "Look for useful items nearby"},
    {"label": "Step back", "description": "Retreat to a safe place to avoid danger"},
    {"label": "Speak to them", "description": "Cautiously initiate conversation"},
    {"label": "Hide and observe", "description": "Conceal yourself and watch the situation"},
    {"label": "Attack", "description": "Confront the threat with an attack"},
]

# ì¥ë©´ ì˜¤ë¸Œì íŠ¸ í…œí”Œë¦¿
SCENE_OBJECTS_KO = [
    {"label": "ë‚¡ì€ ë¬¸", "hint": "í´ë¦­í•˜ì—¬ ì—´ì–´ë³¼ ìˆ˜ ìˆìŠµë‹ˆë‹¤"},
    {"label": "ë¹›ë‚˜ëŠ” ë³´ì„", "hint": "ìˆ˜ì§‘í•  ìˆ˜ ìˆì„ ê²ƒ ê°™ìŠµë‹ˆë‹¤"},
    {"label": "ìˆ˜ìƒí•œ ìƒì", "hint": "ë¬´ì–¸ê°€ ë“¤ì–´ìˆì„ ìˆ˜ ìˆìŠµë‹ˆë‹¤"},
    {"label": "ë²½ì˜ ìŠ¤ìœ„ì¹˜", "hint": "ì‘ë™ì‹œí‚¬ ìˆ˜ ìˆìŠµë‹ˆë‹¤"},
]

SCENE_OBJECTS_EN = [
    {"label": "Old door", "hint": "Click to open"},
    {"label": "Glowing gem", "hint": "It looks collectible"},
    {"label": "Suspicious chest", "hint": "Something might be inside"},
    {"label": "Wall switch", "hint": "Can be activated"},
]


def _generate_random_box(rng: random.Random) -> Box2D:
    """ëœë¤ ë°”ìš´ë”© ë°•ìŠ¤ ìƒì„± (0~1000 ì¢Œí‘œê³„)."""
    ymin = rng.randint(0, 700)
    xmin = rng.randint(0, 700)
    ymax = ymin + rng.randint(50, 250)
    xmax = xmin + rng.randint(50, 250)
    # ë²”ìœ„ ë³´ì •
    ymax = min(ymax, 1000)
    xmax = min(xmax, 1000)
    return Box2D(ymin=ymin, xmin=xmin, ymax=ymax, xmax=xmax)


# =============================================================================
# MockOrchestrator í´ë˜ìŠ¤
# =============================================================================


class MockOrchestrator:
    """ëª¨ì˜ Orchestrator.

    ì‹¤ëª¨ë¸(Gemini) ì—†ì´ TurnOutputì„ ìƒì„±í•˜ëŠ” ëª¨ì˜ ì˜¤ì¼€ìŠ¤íŠ¸ë ˆì´í„°ì…ë‹ˆë‹¤.
    seed ê¸°ë°˜ìœ¼ë¡œ ê²°ì •ì (ì¬í˜„ ê°€ëŠ¥)ì¸ ê²°ê³¼ë¥¼ ìƒì„±í•©ë‹ˆë‹¤.

    Attributes:
        seed: ëœë¤ ì‹œë“œ (ì¬í˜„ì„± ë³´ì¥)

    Example:
        >>> orchestrator = MockOrchestrator(seed=42)
        >>> turn_input = TurnInput(
        ...     language=Language.KO,
        ...     text="ë¬¸ì„ ì—´ì–´ë³¸ë‹¤",
        ...     client=ClientInfo(viewport_w=1920, viewport_h=1080),
        ...     economy_snapshot=EconomySnapshot(signal=100, memory_shard=5),
        ... )
        >>> output = orchestrator.generate_turn_output(turn_input)
    """

    # ë‹¨ê³„ ëª©ë¡ (PRD ì˜ˆì‹œ)
    PHASES = [
        AgentPhase.PARSE,
        AgentPhase.VALIDATE,
        AgentPhase.PLAN,
        AgentPhase.RESOLVE,
        AgentPhase.RENDER,
        AgentPhase.VERIFY,
        AgentPhase.COMMIT,
    ]

    def __init__(self, seed: int | None = None) -> None:
        """MockOrchestrator ì´ˆê¸°í™”.

        Args:
            seed: ëœë¤ ì‹œë“œ. Noneì´ë©´ ëœë¤í•˜ê²Œ ìƒì„±.
        """
        self.seed = seed if seed is not None else random.randint(0, 2**32 - 1)
        self._rng = random.Random(self.seed)

    def generate_turn_output(self, turn_input: TurnInput) -> TurnOutput:
        """TurnInputì„ ë°›ì•„ TurnOutputì„ ìƒì„±í•©ë‹ˆë‹¤.

        Args:
            turn_input: ì‚¬ìš©ì ì…ë ¥

        Returns:
            TurnOutput: ëª¨ì˜ í„´ ê²°ê³¼
        """
        is_korean = turn_input.language == Language.KO

        # ë‚´ëŸ¬í‹°ë¸Œ ìƒì„±
        narratives = KO_NARRATIVES if is_korean else EN_NARRATIVES
        narrative = self._rng.choice(narratives)

        # ì‚¬ìš©ì í…ìŠ¤íŠ¸ê°€ ìˆìœ¼ë©´ ë°˜ì˜
        if turn_input.text:
            prefix = (
                f'ë‹¹ì‹ ì€ "{turn_input.text}"ë¼ê³  ë§í–ˆìŠµë‹ˆë‹¤. '
                if is_korean
                else f'You said "{turn_input.text}". '
            )
            narrative = prefix + narrative

        # ì•¡ì…˜ ë± ìƒì„± (3~6ì¥)
        action_templates = KO_ACTION_CARDS if is_korean else EN_ACTION_CARDS
        num_cards = self._rng.randint(3, 6)
        selected_templates = self._rng.sample(
            action_templates, min(num_cards, len(action_templates))
        )

        action_cards: list[ActionCard] = []
        for i, template in enumerate(selected_templates):
            cost_signal = self._rng.randint(1, 10)
            cost_shard = 1 if self._rng.random() < 0.2 else 0  # 20% í™•ë¥ ë¡œ shard ì†Œë¹„

            action_cards.append(
                ActionCard(
                    id=f"action_{i + 1}",
                    label=template["label"],
                    description=template["description"],
                    cost=CurrencyAmount(signal=cost_signal, memory_shard=cost_shard),
                    risk=self._rng.choice(list(RiskLevel)),
                    hint=None,
                )
            )

        action_deck = ActionDeck(cards=action_cards)

        # ì¥ë©´ ì˜¤ë¸Œì íŠ¸ ìƒì„± (1~3ê°œ)
        object_templates = SCENE_OBJECTS_KO if is_korean else SCENE_OBJECTS_EN
        num_objects = self._rng.randint(1, 3)
        selected_objects = self._rng.sample(
            object_templates, min(num_objects, len(object_templates))
        )

        scene_objects: list[SceneObject] = []
        for i, template in enumerate(selected_objects):
            scene_objects.append(
                SceneObject(
                    id=f"obj_{i + 1}",
                    label=template["label"],
                    box_2d=_generate_random_box(self._rng),
                    interaction_hint=template["hint"],
                )
            )

        ui_output = UIOutput(action_deck=action_deck, objects=scene_objects)

        # ì„¸ê³„ ìƒíƒœ ë³€í™” (delta)
        world_delta = self._generate_world_delta(is_korean)

        # ë Œë”ë§ ì¶œë ¥ (ì´ë¯¸ì§€ ìƒì„±ì€ ì„ íƒì )
        should_generate_image = self._rng.random() < 0.3  # 30% í™•ë¥ ë¡œ ì´ë¯¸ì§€ ìƒì„±
        render_output = RenderOutput(
            image_job=ImageJob(
                should_generate=should_generate_image,
                prompt="A mysterious dungeon scene" if should_generate_image else "",
                model_label=ModelLabel.FAST,
                aspect_ratio="16:9",
                image_size="1024x576",
            )
            if should_generate_image
            else None
        )

        # ê²½ì œ ì¶œë ¥ (ë¹„ìš© ê³„ì‚°)
        turn_cost = CurrencyAmount(
            signal=self._rng.randint(1, 5),
            memory_shard=0,
        )

        # ì”ì•¡ ê³„ì‚° (ìŒìˆ˜ ë°©ì§€ - RULE-005)
        balance_signal = max(0, turn_input.economy_snapshot.signal - turn_cost.signal)
        balance_shard = max(0, turn_input.economy_snapshot.memory_shard - turn_cost.memory_shard)

        economy_output = EconomyOutput(
            cost=turn_cost,
            balance_after=CurrencyAmount(signal=balance_signal, memory_shard=balance_shard),
        )

        # ì•ˆì „ ì¶œë ¥
        safety_output = SafetyOutput(blocked=False, message=None)

        # ì—ì´ì „íŠ¸ ì½˜ì†”
        agent_console = AgentConsole(
            current_phase=AgentPhase.COMMIT,
            badges=[
                ValidationBadge.SCHEMA_OK,
                ValidationBadge.ECONOMY_OK,
                ValidationBadge.SAFETY_OK,
                ValidationBadge.CONSISTENCY_OK,
            ],
            repair_count=0,
        )

        return TurnOutput(
            language=turn_input.language,
            narrative=narrative,
            ui=ui_output,
            world=world_delta,
            render=render_output,
            economy=economy_output,
            safety=safety_output,
            agent_console=agent_console,
        )

    def _generate_world_delta(self, is_korean: bool) -> WorldDelta:
        """ì„¸ê³„ ìƒíƒœ ë³€í™” ìƒì„±."""
        # ê·œì¹™ ë³€ê²½ (20% í™•ë¥ )
        rules_changed: list[WorldRule] = []
        if self._rng.random() < 0.2:
            rules_changed.append(
                WorldRule(
                    id="rule_gravity",
                    label="ì¤‘ë ¥ ë°˜ì „" if is_korean else "Gravity Inversion",
                    description=(
                        "ì´ êµ¬ì—­ì—ì„œëŠ” ì¤‘ë ¥ì´ ë°˜ëŒ€ë¡œ ì‘ìš©í•©ë‹ˆë‹¤"
                        if is_korean
                        else "Gravity works in reverse in this area"
                    ),
                )
            )

        # ì¸ë²¤í† ë¦¬ ì¶”ê°€ (30% í™•ë¥ )
        inventory_added: list[str] = []
        if self._rng.random() < 0.3:
            items_ko = ["ë‚¡ì€ ì—´ì‡ ", "ì‹ ë¹„ë¡œìš´ êµ¬ìŠ¬", "ê³ ëŒ€ì˜ ë‘ë£¨ë§ˆë¦¬"]
            items_en = ["Old Key", "Mysterious Orb", "Ancient Scroll"]
            items = items_ko if is_korean else items_en
            inventory_added.append(self._rng.choice(items))

        # í€˜ìŠ¤íŠ¸ ì—…ë°ì´íŠ¸ (25% í™•ë¥ )
        quests_updated: list[Quest] = []
        if self._rng.random() < 0.25:
            quests_updated.append(
                Quest(
                    id="quest_explore",
                    label="ë¯¸ì§€ì˜ ì˜ì—­ íƒí—˜" if is_korean else "Explore Unknown Territory",
                    is_completed=self._rng.random() < 0.3,
                )
            )

        # ë©”ëª¨ë¦¬ í•€ (15% í™•ë¥ )
        memory_pins: list[MemoryPin] = []
        if self._rng.random() < 0.15:
            memory_pins.append(
                MemoryPin(
                    id="pin_1",
                    content="ì´ ì¥ì†Œì˜ ì´ë¦„ì€ 'ìŠí˜€ì§„ ì„±ì†Œ'"
                    if is_korean
                    else "This place is called 'Forgotten Sanctuary'",
                    cost=CurrencyAmount(signal=0, memory_shard=1),
                )
            )

        return WorldDelta(
            rules_changed=rules_changed,
            inventory_added=inventory_added,
            inventory_removed=[],
            quests_updated=quests_updated,
            relationships_changed=[],
            memory_pins=memory_pins,
        )

    def create_safe_fallback(
        self,
        language: Language,
        error_message: str | None = None,
        economy_snapshot: CurrencyAmount | None = None,
    ) -> TurnOutput:
        """ì•ˆì „í•œ í´ë°± TurnOutput ìƒì„± (RULE-004, RU-002-S1).

        ìŠ¤í‚¤ë§ˆ ê²€ì¦ ì‹¤íŒ¨ ì‹œ ë°˜í™˜í•  ì•ˆì „í•œ ê¸°ë³¸ ì‘ë‹µì…ë‹ˆë‹¤.
        í´ë°± ì‹œ economy.balance_afterëŠ” ì…ë ¥ ìŠ¤ëƒ…ìƒ·ì„ ê·¸ëŒ€ë¡œ ìœ ì§€í•©ë‹ˆë‹¤ (ë¹„ìš© 0, ì”ì•¡ ë³€í™” ì—†ìŒ).

        Args:
            language: ì‘ë‹µ ì–¸ì–´
            error_message: ì—ëŸ¬ ë©”ì‹œì§€ (ë‚´ë¶€ìš©, UIì— ë…¸ì¶œí•˜ì§€ ì•ŠìŒ)
            economy_snapshot: ìš”ì²­ ì§ì „ ì¬í™” ìŠ¤ëƒ…ìƒ· (í´ë°± ì‹œ ì”ì•¡ ìœ ì§€ìš©)

        Returns:
            TurnOutput: ì•ˆì „í•œ í´ë°± ì‘ë‹µ
        """
        is_korean = language == Language.KO

        narrative = (
            "ì ì‹œ í˜¼ë€ì´ ìˆì—ˆìŠµë‹ˆë‹¤. ë‹¤ì‹œ ì‹œë„í•´ì£¼ì„¸ìš”."
            if is_korean
            else "There was a momentary confusion. Please try again."
        )

        # RU-002-S1: í´ë°± ì‹œ ì…ë ¥ ìŠ¤ëƒ…ìƒ· ê·¸ëŒ€ë¡œ ìœ ì§€ (ë¹„ìš© 0, ì”ì•¡ ë³€í™” ì—†ìŒ)
        balance_after = (
            economy_snapshot
            if economy_snapshot is not None
            else CurrencyAmount(signal=100, memory_shard=5)  # ê¸°ë³¸ê°’ (ìŠ¤ëƒ…ìƒ· ì—†ì„ ë•Œë§Œ)
        )

        return TurnOutput(
            language=language,
            narrative=narrative,
            ui=UIOutput(action_deck=ActionDeck(cards=[]), objects=[]),
            world=WorldDelta(),
            render=RenderOutput(image_job=None),
            economy=EconomyOutput(
                cost=CurrencyAmount(signal=0, memory_shard=0),
                balance_after=balance_after,
            ),
            safety=SafetyOutput(blocked=False, message=None),
            agent_console=AgentConsole(
                current_phase=AgentPhase.COMMIT,
                badges=[ValidationBadge.SCHEMA_FAIL],  # ì‹¤íŒ¨ í‘œì‹œ
                repair_count=1,  # ë³µêµ¬ ì‹œë„ íšŸìˆ˜
            ),
        )
</file>

<file path="frontend/src/App.test.tsx">
import { describe, it, expect, vi, beforeEach } from 'vitest';
import { render, screen, fireEvent } from '@testing-library/react';
import App from './App';
import * as turnStream from './api/turnStream';

// i18next ëª¨í‚¹ (RU-003-Q5: ë°ëª¨ i18n í‚¤ ì§€ì›)
vi.mock('react-i18next', () => ({
  useTranslation: () => ({
    t: (key: string, options?: Record<string, unknown>) => {
      // ë°ëª¨ ì•„ì´í…œ ì´ë¦„
      if (key === 'demo.items.keycard-alpha.name') return 'í‚¤ì¹´ë“œ A';
      if (key === 'demo.items.medkit.name') return 'ì‘ê¸‰ í‚¤íŠ¸';
      if (key === 'demo.items.flashlight.name') return 'ì†ì „ë“±';
      if (key === 'demo.items.data-chip.name') return 'ë°ì´í„°ì¹©';
      // ë°ëª¨ ì”¬ ì˜¤ë¸Œì íŠ¸
      if (key === 'demo.scene.terminal.label') return 'í„°ë¯¸ë„';
      if (key === 'demo.scene.terminal.hint') return 'í™œì„±í™”ëœ í„°ë¯¸ë„ì´ë‹¤';
      if (key === 'demo.scene.door.label') return 'ë¬¸';
      if (key === 'demo.scene.door.hint') return 'ì ê²¨ìˆëŠ” ê²ƒ ê°™ë‹¤';
      // ì•¡ì…˜ í…œí”Œë¦¿
      if (key === 'scene.hotspot.click_action') {
        return `Click: ${options?.label}`;
      }
      return key;
    },
    i18n: {
      changeLanguage: () => Promise.resolve(),
      resolvedLanguage: 'ko-KR',
    },
  }),
  initReactI18next: {
    type: '3rdParty',
    init: () => {},
  },
}));

// ResizeObserver ëª¨í‚¹
class MockResizeObserver {
  observe = vi.fn();
  unobserve = vi.fn();
  disconnect = vi.fn();
}
global.ResizeObserver = MockResizeObserver as unknown as typeof ResizeObserver;

// getBoundingClientRect ëª¨í‚¹
Element.prototype.getBoundingClientRect = vi.fn(() => ({
  width: 800,
  height: 600,
  top: 0,
  left: 0,
  bottom: 600,
  right: 800,
  x: 0,
  y: 0,
  toJSON: () => {},
})) as unknown as () => DOMRect;

// api ëª¨í‚¹
vi.mock('./api/turnStream', () => ({
  startTurnStream: vi.fn(),
}));

describe('App Integration - Hotspot Click', () => {
  beforeEach(() => {
    vi.clearAllMocks();
  });

  it('should trigger startTurnStream when a hotspot is clicked', async () => {
    render(<App />);

    // ë°ëª¨ìš©ìœ¼ë¡œ App.tsxì— í•˜ë“œì½”ë”©ëœ 'í„°ë¯¸ë„' í•«ìŠ¤íŒŸ ì°¾ê¸°
    const terminalHotspot = screen.getByLabelText('í„°ë¯¸ë„');
    expect(terminalHotspot).toBeInTheDocument();

    // í´ë¦­ ì‹œë®¬ë ˆì´ì…˜
    fireEvent.click(terminalHotspot);

    // startTurnStream í˜¸ì¶œ í™•ì¸
    expect(turnStream.startTurnStream).toHaveBeenCalled();

    const [input] = vi.mocked(turnStream.startTurnStream).mock.calls[0];

    // TurnInput ê²€ì¦
    expect(input.text).toBe('Click: í„°ë¯¸ë„');
    expect(input.click).toEqual({
      object_id: 'demo-terminal',
      box_2d: { ymin: 300, xmin: 100, ymax: 600, xmax: 400 },
    });
  });
});
</file>

<file path="frontend/src/components/ActionDeck.test.tsx">
import { describe, it, expect, vi, beforeEach } from 'vitest';
import { render, screen, fireEvent } from '@testing-library/react';
import { ActionDeck } from './ActionDeck';
import type { ActionCard } from '../schemas/turn';
import { useActionDeckStore } from '../stores/actionDeckStore';
import { useWorldStore } from '../stores/worldStore';
import { useAgentStore } from '../stores/agentStore';

// i18next ëª¨í‚¹
vi.mock('react-i18next', () => ({
  useTranslation: () => ({
    t: (key: string, params?: Record<string, unknown>) => {
      if (params?.turn !== undefined) return `Turn ${params.turn}`;
      if (key === 'action.risk.low') return 'Low';
      if (key === 'action.risk.medium') return 'Medium';
      if (key === 'action.risk.high') return 'High';
      if (key === 'action.insufficient_balance') return 'Insufficient Balance';
      if (key === 'action.alternative') return 'Alt';
      return key;
    },
  }),
}));

describe('ActionDeck Component', () => {
  const mockCards: ActionCard[] = [
    {
      id: 'card-1',
      label: 'Regular Action',
      description: 'Test Description',
      cost: { signal: 10, memory_shard: 0 },
      cost_estimate: {
        min: { signal: 8, memory_shard: 0 },
        max: { signal: 12, memory_shard: 0 },
      },
      risk: 'low',
      hint: 'Positive hint',
      reward_hint: 'Bonus item',
      enabled: true,
      disabled_reason: null,
      is_alternative: false,
    },
    {
      id: 'card-2',
      label: 'Expensive Action',
      description: null,
      cost: { signal: 50, memory_shard: 1 },
      cost_estimate: null,
      risk: 'high',
      hint: 'Risky hint',
      reward_hint: null,
      enabled: true,
      disabled_reason: null,
      is_alternative: false,
    },
    {
      id: 'card-alt',
      label: 'Alternative Action',
      description: null,
      cost: { signal: 2, memory_shard: 0 },
      cost_estimate: null,
      risk: 'low',
      hint: null,
      reward_hint: null,
      enabled: true,
      disabled_reason: null,
      is_alternative: true,
    },
  ];

  beforeEach(() => {
    // ìŠ¤í† ì–´ ì´ˆê¸°í™”
    useActionDeckStore.setState({ cards: [] });
    useWorldStore.setState({ economy: { signal: 100, memory_shard: 5 } });
    useAgentStore.setState({ isStreaming: false });
  });

  it('renders provided cards from store', () => {
    useActionDeckStore.setState({ cards: mockCards });
    render(<ActionDeck />);
    expect(screen.getByText('Regular Action')).toBeInTheDocument();
    expect(screen.getByText('Expensive Action')).toBeInTheDocument();
    expect(screen.getByText('Alternative Action')).toBeInTheDocument();
  });

  it('displays cost estimates as ranges when available', () => {
    useActionDeckStore.setState({ cards: mockCards });
    render(<ActionDeck />);
    // card-1 has cost_estimate: 8~12
    expect(screen.getByText('8~12')).toBeInTheDocument();
    // card-2 has cost: 50
    expect(screen.getByText('50')).toBeInTheDocument();
  });

  it('disables cards when balance is insufficient in worldStore', () => {
    useActionDeckStore.setState({ cards: mockCards });
    useWorldStore.setState({ economy: { signal: 5, memory_shard: 0 } });

    render(<ActionDeck />);

    // Regular Action (cost 10/estimate max 12) -> disabled
    const card1 = screen.getByRole('button', { name: /Regular Action/i });
    expect(card1).toBeDisabled();
    expect(screen.getAllByText('Insufficient Balance').length).toBeGreaterThan(0);

    // Alternative Action (cost 2) -> enabled
    const cardAlt = screen.getByRole('button', { name: /Alternative Action/i });
    expect(cardAlt).not.toBeDisabled();
  });

  it('renders alternative badge for alternative cards', () => {
    useActionDeckStore.setState({ cards: mockCards });
    render(<ActionDeck />);
    expect(screen.getByText('Alt')).toBeInTheDocument();
  });

  it('calls onCardClick when an enabled card is clicked', () => {
    const onCardClick = vi.fn();
    useActionDeckStore.setState({ cards: mockCards });
    render(<ActionDeck onCardClick={onCardClick} />);

    fireEvent.click(screen.getByText('Regular Action'));
    expect(onCardClick).toHaveBeenCalledWith(expect.objectContaining({ id: 'card-1' }));
  });

  it('displays server-provided disabled reason', () => {
    const disabledCard: ActionCard[] = [
      {
        ...mockCards[0],
        enabled: false,
        disabled_reason: 'Locked by story',
      },
    ];
    useActionDeckStore.setState({ cards: disabledCard });
    render(<ActionDeck />);
    expect(screen.getByText('Locked by story')).toBeInTheDocument();
  });

  it('renders default cards when store cards are empty', () => {
    useActionDeckStore.setState({ cards: [] });
    render(<ActionDeck />);
    // useDefaultCards should provide some default labels
    expect(screen.getByText('action.default.explore.label')).toBeInTheDocument();
  });

  it('disables all cards when isStreaming is true in agentStore', () => {
    useActionDeckStore.setState({ cards: mockCards });
    useAgentStore.setState({ isStreaming: true });

    render(<ActionDeck />);

    const card1 = screen.getByRole('button', { name: /Regular Action/i });
    const cardAlt = screen.getByRole('button', { name: /Alternative Action/i });

    expect(card1).toBeDisabled();
    expect(cardAlt).toBeDisabled();
  });
});
</file>

<file path="frontend/src/components/DndInteraction.test.tsx">
import React from 'react';
import { describe, it, expect, vi, beforeEach } from 'vitest';
import { render, screen, act } from '@testing-library/react';
import App from '../App';
import * as turnStream from '../api/turnStream';

// dnd-kit ëª¨í‚¹ìš© íƒ€ì…
interface MockDndCallbacks {
  onDragEnd: (event: {
    active: { id: string; data: { current: unknown } };
    over: { id: string; data: { current: unknown } } | null;
  }) => void;
}

// dnd-kit ëª¨í‚¹ (ì½œë°± ê°€ë¡œì±„ê¸°ìš©)
vi.mock('@dnd-kit/core', async () => {
  const actual = (await vi.importActual('@dnd-kit/core')) as Record<string, unknown>;
  return {
    ...actual,
    DndContext: (props: MockDndCallbacks & { children: React.ReactNode }) => {
      // ì½œë°± ì €ì¥ (í…ŒìŠ¤íŠ¸ì—ì„œ ì ‘ê·¼ ê°€ëŠ¥í•˜ë„ë¡ globalì— ì €ì¥)
      (global as unknown as Record<string, unknown>).dndCallbacks = props;
      return <div data-testid="mock-dnd-context">{props.children}</div>;
    },
  };
});

// i18next ëª¨í‚¹ (RU-003-Q5: ë°ëª¨ i18n í‚¤ ì§€ì›)
vi.mock('react-i18next', () => ({
  useTranslation: () => ({
    t: (key: string, options?: Record<string, unknown>) => {
      // ë°ëª¨ ì•„ì´í…œ ì´ë¦„
      if (key === 'demo.items.keycard-alpha.name') return 'í‚¤ì¹´ë“œ A';
      if (key === 'demo.items.medkit.name') return 'ì‘ê¸‰ í‚¤íŠ¸';
      if (key === 'demo.items.flashlight.name') return 'ì†ì „ë“±';
      if (key === 'demo.items.data-chip.name') return 'ë°ì´í„°ì¹©';
      // ë°ëª¨ ì”¬ ì˜¤ë¸Œì íŠ¸
      if (key === 'demo.scene.terminal.label') return 'í„°ë¯¸ë„';
      if (key === 'demo.scene.terminal.hint') return 'í™œì„±í™”ëœ í„°ë¯¸ë„ì´ë‹¤';
      if (key === 'demo.scene.door.label') return 'ë¬¸';
      if (key === 'demo.scene.door.hint') return 'ì ê²¨ìˆëŠ” ê²ƒ ê°™ë‹¤';
      // ì•¡ì…˜ í…œí”Œë¦¿
      if (key === 'inventory.item_label') return `Item: ${options?.name}`;
      if (key === 'scene.hotspot.drop_action') {
        return `Drop: ${options?.item} on ${options?.target}`;
      }
      if (key === 'scene.hotspot.drop_invalid') {
        return `Invalid: ${options?.item}`;
      }
      if (key === 'connection.online') return 'ONLINE';
      return key;
    },
    i18n: {
      changeLanguage: () => Promise.resolve(),
      resolvedLanguage: 'ko-KR',
    },
  }),
  initReactI18next: {
    type: '3rdParty',
    init: () => {},
  },
}));

// ResizeObserver ëª¨í‚¹
class MockResizeObserver {
  observe = vi.fn();
  unobserve = vi.fn();
  disconnect = vi.fn();
}
global.ResizeObserver = MockResizeObserver as unknown as typeof ResizeObserver;
window.ResizeObserver = MockResizeObserver as unknown as typeof ResizeObserver;

// api ëª¨í‚¹
vi.mock('../api/turnStream', () => ({
  startTurnStream: vi.fn(),
}));

describe('DnD Interaction - Logic Test', () => {
  beforeEach(() => {
    vi.clearAllMocks();
  });

  it('should trigger turn execution when handleDragEnd is called with a hotspot target', async () => {
    render(<App />);
    const dndCallbacks = (global as unknown as Record<string, MockDndCallbacks>).dndCallbacks;

    // RU-003-Q1: ë“œë˜ê·¸ ë°ì´í„°ì— item ê°ì²´ í¬í•¨ (íƒ€ì… ê°€ë“œ ìš”êµ¬ì‚¬í•­)
    const mockItem = {
      id: 'keycard-alpha',
      name: 'í‚¤ì¹´ë“œ A',
      icon: 'ğŸ”‘',
      quantity: 1,
    };

    // ì„±ê³µ ì‹œë‚˜ë¦¬ì˜¤ ì‹œë®¬ë ˆì´ì…˜
    act(() => {
      dndCallbacks.onDragEnd({
        active: {
          id: 'keycard-alpha',
          data: {
            current: {
              type: 'inventory-item',
              item_id: 'keycard-alpha',
              item: mockItem,
            },
          },
        },
        over: {
          id: 'hotspot-demo-terminal',
          data: {
            current: {
              type: 'hotspot',
              object_id: 'demo-terminal',
              label: 'í„°ë¯¸ë„',
              box_2d: { ymin: 300, xmin: 100, ymax: 600, xmax: 400 },
            },
          },
        },
      });
    });

    // startTurnStream í˜¸ì¶œ í™•ì¸
    expect(turnStream.startTurnStream).toHaveBeenCalled();
    const [input] = vi.mocked(turnStream.startTurnStream).mock.calls[0];

    expect(input.text).toBe('Drop: í‚¤ì¹´ë“œ A on í„°ë¯¸ë„');
    expect(input.drop).toEqual({
      item_id: 'keycard-alpha',
      target_object_id: 'demo-terminal',
      target_box_2d: { ymin: 300, xmin: 100, ymax: 600, xmax: 400 },
    });
  });

  it('should show failure feedback when handleDragEnd is called with an invalid target', async () => {
    render(<App />);
    const dndCallbacks = (global as unknown as Record<string, MockDndCallbacks>).dndCallbacks;

    // RU-003-Q1: ë“œë˜ê·¸ ë°ì´í„°ì— item ê°ì²´ í¬í•¨ (íƒ€ì… ê°€ë“œ ìš”êµ¬ì‚¬í•­)
    const mockItem = {
      id: 'keycard-alpha',
      name: 'í‚¤ì¹´ë“œ A',
      icon: 'ğŸ”‘',
      quantity: 1,
    };

    // ì‹¤íŒ¨ ì‹œë‚˜ë¦¬ì˜¤ ì‹œë®¬ë ˆì´ì…˜ (overê°€ null)
    act(() => {
      dndCallbacks.onDragEnd({
        active: {
          id: 'keycard-alpha',
          data: {
            current: {
              type: 'inventory-item',
              item_id: 'keycard-alpha',
              item: mockItem,
            },
          },
        },
        over: null,
      });
    });

    // turn ì‹¤í–‰ì€ ë°œìƒí•˜ì§€ ì•Šì•„ì•¼ í•¨
    expect(turnStream.startTurnStream).not.toHaveBeenCalled();

    // ë‚´ëŸ¬í‹°ë¸Œ í”¼ë“œì— ì‹¤íŒ¨ ë©”ì‹œì§€ê°€ ë‚˜íƒ€ë‚˜ì•¼ í•¨
    const failureMessage = await screen.findByText(/Invalid: í‚¤ì¹´ë“œ A/);
    expect(failureMessage).toBeInTheDocument();
  });
});
</file>

<file path="frontend/src/components/GameHeader.tsx">
import type { ReactNode } from 'react';
import { useTranslation } from 'react-i18next';
import { UIControls } from './UIControls';
import { EconomyHudHeader } from './EconomyHud';
import type { UIScale } from '../stores/uiPrefsStore';
import { useEconomyStore, selectIsBalanceLow } from '../stores/economyStore';

interface GameHeaderProps {
  signal: number;
  memoryShard: number;
  isConnected: boolean;
  uiScale: UIScale;
  onIncreaseScale: () => void;
  onDecreaseScale: () => void;
  /** U-015: ì¶”ê°€ ì»¨íŠ¸ë¡¤ (ë¦¬ì…‹/í”„ë¡œí•„ ë³€ê²½ ë²„íŠ¼ ë“±) */
  children?: ReactNode;
}

export function GameHeader({
  signal,
  memoryShard,
  isConnected,
  uiScale,
  onIncreaseScale,
  onDecreaseScale,
  children,
}: GameHeaderProps) {
  const { t } = useTranslation();
  const isBalanceLow = useEconomyStore(selectIsBalanceLow);

  return (
    <header className="game-header has-chrome">
      <h1 className="game-title glitch" data-text={t('ui.logo')}>
        {t('ui.logo')}
      </h1>
      <div className="header-controls">
        {/* U-015: ë¦¬ì…‹/í”„ë¡œí•„ ë³€ê²½ ë“± ì¶”ê°€ ì»¨íŠ¸ë¡¤ */}
        {children}
        {/* UI ìŠ¤ì¼€ì¼ ì»¨íŠ¸ë¡¤ (U-028â†’U-037: Readable ì œê±°) */}
        <UIControls
          uiScale={uiScale}
          onIncreaseScale={onIncreaseScale}
          onDecreaseScale={onDecreaseScale}
        />
        {/* Economy HUD (U-014: ì˜ˆìƒ ë¹„ìš©/í™•ì • ë¹„ìš© í‘œì‹œ í¬í•¨) */}
        <EconomyHudHeader signal={signal} memoryShard={memoryShard} isLow={isBalanceLow} />
        <div className="connection-status">
          <span className={`status-indicator ${isConnected ? '' : 'offline'}`} />
          <span>{isConnected ? t('connection.online') : t('connection.offline')}</span>
        </div>
      </div>
    </header>
  );
}
</file>

<file path="frontend/src/components/InventoryPanel.tsx">
/**
 * Unknown World - Inventory Panel ì»´í¬ë„ŒíŠ¸ (U-011[Mvp]).
 *
 * dnd-kit ê¸°ë°˜ ë“œë˜ê·¸ ê°€ëŠ¥í•œ ì¸ë²¤í† ë¦¬ ì•„ì´í…œ UIë¥¼ ì œê³µí•©ë‹ˆë‹¤.
 *
 * ì„¤ê³„ ì›ì¹™:
 *   - RULE-002: InventoryëŠ” ê²Œì„ UIë¡œ ìƒì‹œ ë…¸ì¶œ (ì±„íŒ… ì…ë ¥ ëŒ€ì²´ ê¸ˆì§€)
 *   - tech-stack: dnd-kit ê¸°ë°˜ draggable êµ¬í˜„
 *   - U-012 ì—°ê²°: ë“œë˜ê·¸ ë°ì´í„°ì— item_id í¬í•¨í•˜ì—¬ ë“œë¡­ íƒ€ê²Ÿì— ì „ë‹¬
 *
 * @module components/InventoryPanel
 */

import { useCallback, useMemo } from 'react';
import { useDraggable, DragOverlay } from '@dnd-kit/core';
import { CSS } from '@dnd-kit/utilities';
import { useTranslation } from 'react-i18next';
import {
  useInventoryStore,
  type InventoryItem,
  selectItems,
  selectDraggingItem,
  selectSelectedItemId,
} from '../stores/inventoryStore';
import { DND_TYPE, type InventoryDragData } from '../dnd/types';

// =============================================================================
// ë“œë˜ê·¸ ê°€ëŠ¥í•œ ì•„ì´í…œ ì»´í¬ë„ŒíŠ¸
// =============================================================================

interface DraggableItemProps {
  item: InventoryItem;
  isSelected: boolean;
  onSelect: (itemId: string) => void;
  disabled?: boolean;
}

/**
 * ë“œë˜ê·¸ ê°€ëŠ¥í•œ ì¸ë²¤í† ë¦¬ ì•„ì´í…œ.
 * dnd-kitì˜ useDraggable í›…ì„ ì‚¬ìš©í•©ë‹ˆë‹¤.
 */
function DraggableItem({ item, isSelected, onSelect, disabled = false }: DraggableItemProps) {
  const { t } = useTranslation();

  // dnd-kit ë“œë˜ê·¸ ì„¤ì • (RU-003-Q1: ìƒìˆ˜/íƒ€ì… ê¸°ë°˜)
  const dragData: InventoryDragData = {
    type: DND_TYPE.INVENTORY_ITEM,
    item_id: item.id,
    item,
  };
  const { attributes, listeners, setNodeRef, transform, isDragging } = useDraggable({
    id: item.id,
    data: dragData,
    disabled,
  });

  // ë³€í™˜ ìŠ¤íƒ€ì¼ ê³„ì‚°
  // ë“œë˜ê·¸ ì¤‘ì¼ ë•ŒëŠ” ì›ë³¸ ì•„ì´í…œì´ ì œìë¦¬ì— ìˆë„ë¡ transform ì ìš©í•˜ì§€ ì•ŠìŒ
  // DragOverlayê°€ ë³„ë„ë¡œ ë Œë”ë§ë˜ë¯€ë¡œ ì›ë³¸ì€ ìœ„ì¹˜ ê³ ì •
  const style = useMemo(
    () => ({
      transform: isDragging ? undefined : CSS.Translate.toString(transform),
      opacity: isDragging ? 0.3 : 1,
    }),
    [transform, isDragging],
  );

  // í´ë¦­ í•¸ë“¤ëŸ¬ (ì„ íƒ)
  const handleClick = useCallback(() => {
    if (!disabled) {
      onSelect(item.id);
    }
  }, [disabled, item.id, onSelect]);

  // ì•„ì´ì½˜ ë Œë”ë§ (ì´ëª¨ì§€ ë˜ëŠ” ì´ë¯¸ì§€)
  const renderIcon = () => {
    if (item.icon) {
      // URL í˜•íƒœë©´ ì´ë¯¸ì§€, ì•„ë‹ˆë©´ ì´ëª¨ì§€
      if (item.icon.startsWith('http') || item.icon.startsWith('/')) {
        return (
          <img
            src={item.icon}
            alt={item.name}
            className="inventory-item-icon-img"
            onError={(e) => {
              e.currentTarget.style.display = 'none';
            }}
          />
        );
      }
      return <span className="inventory-item-icon-emoji">{item.icon}</span>;
    }
    // ê¸°ë³¸ ì•„ì´ì½˜ (ğŸ“¦)
    return <span className="inventory-item-icon-emoji">ğŸ“¦</span>;
  };

  return (
    <div
      ref={setNodeRef}
      style={style}
      className={`inventory-item ${isSelected ? 'selected' : ''} ${isDragging ? 'dragging' : ''} ${disabled ? 'disabled' : ''}`}
      onClick={handleClick}
      aria-label={t('inventory.item_label', { name: item.name, quantity: item.quantity })}
      aria-selected={isSelected}
      {...attributes}
      {...listeners}
    >
      <div className="inventory-item-icon">{renderIcon()}</div>
      <div className="inventory-item-info">
        <span className="inventory-item-name">{item.name}</span>
        {item.quantity > 1 && <span className="inventory-item-quantity">x{item.quantity}</span>}
      </div>
    </div>
  );
}

// =============================================================================
// ë“œë˜ê·¸ ì˜¤ë²„ë ˆì´ (ë“œë˜ê·¸ ì¤‘ í‘œì‹œë˜ëŠ” ì•„ì´í…œ)
// =============================================================================

interface ItemOverlayProps {
  item: InventoryItem;
}

/**
 * ë“œë˜ê·¸ ì˜¤ë²„ë ˆì´ ì•„ì´í…œ.
 * ë“œë˜ê·¸ ì¤‘ì¼ ë•Œ ì»¤ì„œë¥¼ ë”°ë¼ë‹¤ë‹ˆëŠ” ì•„ì´í…œ í‘œì‹œì…ë‹ˆë‹¤.
 */
function ItemOverlay({ item }: ItemOverlayProps) {
  // ì•„ì´ì½˜ ë Œë”ë§
  const renderIcon = () => {
    if (item.icon) {
      if (item.icon.startsWith('http') || item.icon.startsWith('/')) {
        return <img src={item.icon} alt={item.name} className="inventory-item-icon-img" />;
      }
      return <span className="inventory-item-icon-emoji">{item.icon}</span>;
    }
    return <span className="inventory-item-icon-emoji">ğŸ“¦</span>;
  };

  return (
    <div className="inventory-item overlay">
      <div className="inventory-item-icon">{renderIcon()}</div>
      <div className="inventory-item-info">
        <span className="inventory-item-name">{item.name}</span>
        {item.quantity > 1 && <span className="inventory-item-quantity">x{item.quantity}</span>}
      </div>
    </div>
  );
}

// =============================================================================
// ë©”ì¸ Inventory Panel ì»´í¬ë„ŒíŠ¸
// =============================================================================

interface InventoryPanelProps {
  /** ìƒí˜¸ì‘ìš© ë¹„í™œì„±í™” (ìŠ¤íŠ¸ë¦¬ë° ì¤‘ ë“±) */
  disabled?: boolean;
}

/**
 * Inventory Panel ì»´í¬ë„ŒíŠ¸.
 *
 * ì¸ë²¤í† ë¦¬ ì•„ì´í…œì„ ê·¸ë¦¬ë“œë¡œ í‘œì‹œí•˜ê³ , ë“œë˜ê·¸ ê°€ëŠ¥í•˜ê²Œ í•©ë‹ˆë‹¤.
 * DndContextëŠ” App ìµœìƒë‹¨ì— ë°°ì¹˜ë©ë‹ˆë‹¤ (Q1: Option A).
 *
 * @example
 * ```tsx
 * <InventoryPanel disabled={isStreaming} />
 * ```
 */
export function InventoryPanel({ disabled = false }: InventoryPanelProps) {
  const { t } = useTranslation();

  // Store ìƒíƒœ
  const items = useInventoryStore(selectItems);
  const draggingItem = useInventoryStore(selectDraggingItem);
  const selectedItemId = useInventoryStore(selectSelectedItemId);
  const selectItem = useInventoryStore((state) => state.selectItem);

  // ì•„ì´í…œ ì„ íƒ í•¸ë“¤ëŸ¬
  const handleSelect = useCallback(
    (itemId: string) => {
      // ì´ë¯¸ ì„ íƒëœ ì•„ì´í…œ í´ë¦­ ì‹œ ì„ íƒ í•´ì œ
      selectItem(selectedItemId === itemId ? null : itemId);
    },
    [selectedItemId, selectItem],
  );

  // ë¹ˆ ì¸ë²¤í† ë¦¬
  if (items.length === 0) {
    return (
      <div className="inventory-panel-content">
        <div className="inventory-empty">
          <span className="inventory-empty-icon">ğŸ“¦</span>
          <span className="inventory-empty-text">{t('inventory.empty')}</span>
        </div>
      </div>
    );
  }

  return (
    <div className="inventory-panel-content" data-ui-importance="critical">
      <div
        className="inventory-grid"
        role="listbox"
        aria-label={t('inventory.grid_label')}
        aria-multiselectable={false}
      >
        {items.map((item) => (
          <DraggableItem
            key={item.id}
            item={item}
            isSelected={selectedItemId === item.id}
            onSelect={handleSelect}
            disabled={disabled}
          />
        ))}
      </div>

      {/* ë“œë˜ê·¸ ì˜¤ë²„ë ˆì´ */}
      <DragOverlay dropAnimation={null}>
        {draggingItem ? <ItemOverlay item={draggingItem} /> : null}
      </DragOverlay>
    </div>
  );
}

export default InventoryPanel;
</file>

<file path="frontend/src/data/demoProfiles.ts">
/**
 * Unknown World - ë°ëª¨ í”„ë¡œí•„ ì •ì˜ (U-015[Mvp]).
 *
 * ë¡œê·¸ì¸ ì—†ì´ ì¦‰ì‹œ ì‹œì‘ ê°€ëŠ¥í•œ ë°ëª¨ í”„ë¡œí•„ 3ì¢…ì„ ì •ì˜í•©ë‹ˆë‹¤.
 * ê° í”„ë¡œí•„ì€ ì„œë¡œ ë‹¤ë¥¸ ì´ˆê¸° ìƒíƒœ(ì¬í™”/ì¸ë²¤í† ë¦¬/í€˜ìŠ¤íŠ¸/ë£°)ë¥¼ ê°€ì§‘ë‹ˆë‹¤.
 *
 * í”„ë¡œí•„:
 *   1. Narrator: ë‚´ëŸ¬í‹°ë¸Œ/ìŠ¤í† ë¦¬ ì¤‘ì‹¬ ì²´í—˜
 *   2. Explorer: íƒìƒ‰/ë°œê²¬ ì¤‘ì‹¬ ì²´í—˜
 *   3. Tech Enthusiast: ì‹œìŠ¤í…œ/ë©”ì»¤ë‹‰ ì¤‘ì‹¬ ì²´í—˜
 *
 * ì„¤ê³„ ì›ì¹™:
 *   - RULE-006: í‘œì‹œ ë¬¸ìì—´ì€ i18n í‚¤ ê¸°ë°˜
 *   - RULE-010: SaveGame JSON ì§ë ¬í™”ë¡œ ì €ì¥
 *   - PRD 6.9: ë°ëª¨ í”„ë¡œí•„ 3ì¢… + ì¦‰ì‹œ ë¦¬ì…‹
 *   - RU-004-Q5: seed ìƒì„±ì€ constants.ts SSOT ì‚¬ìš©
 *
 * @module data/demoProfiles
 */

import type { SupportedLanguage } from '../i18n';
import type { SaveGame, SaveGameInput } from '../save/saveGame';
import { createSaveGame } from '../save/saveGame';
// RU-004-Q5: seed ìƒì„± ì •ì±… SSOT
import { generateDemoSeed } from '../save/constants';

// =============================================================================
// í”„ë¡œí•„ íƒ€ì… ì •ì˜
// =============================================================================

/**
 * ë°ëª¨ í”„ë¡œí•„ ì •ì˜ (ì–¸ì–´ ì¤‘ë¦½).
 * í‘œì‹œìš© ë¬¸ìì—´ì€ i18n í‚¤ë¡œ ì°¸ì¡°í•©ë‹ˆë‹¤.
 */
export interface DemoProfileDef {
  /** í”„ë¡œí•„ ê³ ìœ  ID */
  id: string;
  /** í”„ë¡œí•„ ì´ë¦„ i18n í‚¤ */
  nameKey: string;
  /** í”„ë¡œí•„ ì„¤ëª… i18n í‚¤ */
  descriptionKey: string;
  /** í”„ë¡œí•„ ì•„ì´ì½˜ (ì´ëª¨ì§€) */
  icon: string;
  /** í”„ë¡œí•„ í…Œë§ˆ ìƒ‰ìƒ (CSS ë³€ìˆ˜ëª… ë˜ëŠ” hex) */
  themeColor: string;
}

/**
 * í”„ë¡œí•„ ì´ˆê¸° ìƒíƒœ.
 * SaveGameìœ¼ë¡œ ë³€í™˜ ê°€ëŠ¥í•œ êµ¬ì¡°ì…ë‹ˆë‹¤.
 */
export interface DemoProfileInitialState {
  /** ì´ˆê¸° ì¬í™” */
  economy: {
    signal: number;
    memory_shard: number;
  };
  /** ì´ˆê¸° ì¸ë²¤í† ë¦¬ ì•„ì´í…œ ì •ì˜ (IDì™€ i18n í‚¤) */
  inventoryDefs: Array<{
    id: string;
    nameKey: string;
    icon: string;
    quantity: number;
  }>;
  /** ì´ˆê¸° í€˜ìŠ¤íŠ¸ ì •ì˜ */
  questDefs: Array<{
    id: string;
    labelKey: string;
    is_completed: boolean;
  }>;
  /** ì´ˆê¸° ê·œì¹™ ì •ì˜ */
  ruleDefs: Array<{
    id: string;
    labelKey: string;
    descriptionKey?: string;
  }>;
  /** ì´ˆê¸° Scene Objects ì •ì˜ */
  sceneObjectDefs: Array<{
    id: string;
    labelKey: string;
    hintKey: string;
    box_2d: {
      ymin: number;
      xmin: number;
      ymax: number;
      xmax: number;
    };
  }>;
  /** í™˜ì˜ ë©”ì‹œì§€ i18n í‚¤ */
  welcomeMessageKey: string;
}

/**
 * ë°ëª¨ í”„ë¡œí•„ ì „ì²´ ì •ì˜.
 */
export interface DemoProfile extends DemoProfileDef {
  initialState: DemoProfileInitialState;
}

// =============================================================================
// ë°ëª¨ í”„ë¡œí•„ ì •ì˜ (3ì¢…)
// =============================================================================

/**
 * Narrator í”„ë¡œí•„: ë‚´ëŸ¬í‹°ë¸Œ/ìŠ¤í† ë¦¬ ì¤‘ì‹¬ ì²´í—˜.
 * í’ë¶€í•œ ì¬í™”ë¡œ ë‹¤ì–‘í•œ ì„ íƒì§€ë¥¼ íƒìƒ‰í•  ìˆ˜ ìˆìŠµë‹ˆë‹¤.
 */
export const PROFILE_NARRATOR: DemoProfile = {
  id: 'narrator',
  nameKey: 'profile.narrator.name',
  descriptionKey: 'profile.narrator.description',
  icon: 'ğŸ“–',
  themeColor: 'var(--accent-color)',
  initialState: {
    economy: {
      signal: 200,
      memory_shard: 10,
    },
    inventoryDefs: [
      {
        id: 'ancient-tome',
        nameKey: 'profile.narrator.items.ancient_tome',
        icon: 'ğŸ“•',
        quantity: 1,
      },
      { id: 'quill-pen', nameKey: 'profile.narrator.items.quill_pen', icon: 'ğŸ–‹ï¸', quantity: 1 },
      {
        id: 'memory-fragment',
        nameKey: 'profile.narrator.items.memory_fragment',
        icon: 'ğŸ’ ',
        quantity: 3,
      },
    ],
    questDefs: [
      {
        id: 'quest-discover-origin',
        labelKey: 'profile.narrator.quest.discover_origin',
        is_completed: false,
      },
      {
        id: 'quest-collect-memories',
        labelKey: 'profile.narrator.quest.collect_memories',
        is_completed: false,
      },
    ],
    ruleDefs: [
      {
        id: 'rule-time-flows',
        labelKey: 'profile.narrator.rule.time_flows',
        descriptionKey: 'profile.narrator.rule.time_flows_desc',
      },
      {
        id: 'rule-memories-persist',
        labelKey: 'profile.narrator.rule.memories_persist',
        descriptionKey: 'profile.narrator.rule.memories_persist_desc',
      },
    ],
    sceneObjectDefs: [
      {
        id: 'mysterious-bookshelf',
        labelKey: 'profile.narrator.scene.bookshelf',
        hintKey: 'profile.narrator.scene.bookshelf_hint',
        box_2d: { ymin: 200, xmin: 100, ymax: 700, xmax: 400 },
      },
      {
        id: 'glowing-portal',
        labelKey: 'profile.narrator.scene.portal',
        hintKey: 'profile.narrator.scene.portal_hint',
        box_2d: { ymin: 300, xmin: 600, ymax: 800, xmax: 900 },
      },
    ],
    welcomeMessageKey: 'profile.narrator.welcome',
  },
};

/**
 * Explorer í”„ë¡œí•„: íƒìƒ‰/ë°œê²¬ ì¤‘ì‹¬ ì²´í—˜.
 * ì ë‹¹í•œ ì¬í™”ì™€ íƒìƒ‰ ë„êµ¬ë¡œ ìƒˆë¡œìš´ ì˜ì—­ì„ ë°œê²¬í•©ë‹ˆë‹¤.
 */
export const PROFILE_EXPLORER: DemoProfile = {
  id: 'explorer',
  nameKey: 'profile.explorer.name',
  descriptionKey: 'profile.explorer.description',
  icon: 'ğŸ§­',
  themeColor: 'var(--text-color)',
  initialState: {
    economy: {
      signal: 150,
      memory_shard: 5,
    },
    inventoryDefs: [
      { id: 'compass', nameKey: 'profile.explorer.items.compass', icon: 'ğŸ§­', quantity: 1 },
      { id: 'rope', nameKey: 'profile.explorer.items.rope', icon: 'ğŸª¢', quantity: 2 },
      { id: 'lantern', nameKey: 'profile.explorer.items.lantern', icon: 'ğŸ®', quantity: 1 },
      {
        id: 'map-fragment',
        nameKey: 'profile.explorer.items.map_fragment',
        icon: 'ğŸ—ºï¸',
        quantity: 1,
      },
    ],
    questDefs: [
      { id: 'quest-find-exit', labelKey: 'profile.explorer.quest.find_exit', is_completed: false },
      {
        id: 'quest-explore-areas',
        labelKey: 'profile.explorer.quest.explore_areas',
        is_completed: false,
      },
      {
        id: 'quest-gather-supplies',
        labelKey: 'profile.explorer.quest.gather_supplies',
        is_completed: true,
      },
    ],
    ruleDefs: [
      {
        id: 'rule-gravity',
        labelKey: 'profile.explorer.rule.gravity',
        descriptionKey: 'profile.explorer.rule.gravity_desc',
      },
      {
        id: 'rule-darkness',
        labelKey: 'profile.explorer.rule.darkness',
        descriptionKey: 'profile.explorer.rule.darkness_desc',
      },
    ],
    sceneObjectDefs: [
      {
        id: 'ancient-door',
        labelKey: 'profile.explorer.scene.door',
        hintKey: 'profile.explorer.scene.door_hint',
        box_2d: { ymin: 150, xmin: 400, ymax: 850, xmax: 600 },
      },
      {
        id: 'strange-mechanism',
        labelKey: 'profile.explorer.scene.mechanism',
        hintKey: 'profile.explorer.scene.mechanism_hint',
        box_2d: { ymin: 500, xmin: 100, ymax: 700, xmax: 300 },
      },
      {
        id: 'hidden-passage',
        labelKey: 'profile.explorer.scene.passage',
        hintKey: 'profile.explorer.scene.passage_hint',
        box_2d: { ymin: 600, xmin: 700, ymax: 800, xmax: 950 },
      },
    ],
    welcomeMessageKey: 'profile.explorer.welcome',
  },
};

/**
 * Tech Enthusiast í”„ë¡œí•„: ì‹œìŠ¤í…œ/ë©”ì»¤ë‹‰ ì¤‘ì‹¬ ì²´í—˜.
 * ì œí•œëœ ì¬í™”ë¡œ íš¨ìœ¨ì ì¸ ì „ëµì„ ì„¸ì›Œì•¼ í•©ë‹ˆë‹¤.
 */
export const PROFILE_TECH: DemoProfile = {
  id: 'tech',
  nameKey: 'profile.tech.name',
  descriptionKey: 'profile.tech.description',
  icon: 'âš™ï¸',
  themeColor: 'var(--warning-color)',
  initialState: {
    economy: {
      signal: 80,
      memory_shard: 15,
    },
    inventoryDefs: [
      { id: 'data-core', nameKey: 'profile.tech.items.data_core', icon: 'ğŸ’¿', quantity: 1 },
      { id: 'circuit-board', nameKey: 'profile.tech.items.circuit_board', icon: 'ğŸ”Œ', quantity: 2 },
      { id: 'energy-cell', nameKey: 'profile.tech.items.energy_cell', icon: 'ğŸ”‹', quantity: 3 },
      { id: 'scanner-device', nameKey: 'profile.tech.items.scanner', icon: 'ğŸ“¡', quantity: 1 },
    ],
    questDefs: [
      {
        id: 'quest-analyze-system',
        labelKey: 'profile.tech.quest.analyze_system',
        is_completed: false,
      },
      {
        id: 'quest-optimize-resources',
        labelKey: 'profile.tech.quest.optimize_resources',
        is_completed: false,
      },
    ],
    ruleDefs: [
      {
        id: 'rule-energy-conservation',
        labelKey: 'profile.tech.rule.energy_conservation',
        descriptionKey: 'profile.tech.rule.energy_conservation_desc',
      },
      {
        id: 'rule-data-integrity',
        labelKey: 'profile.tech.rule.data_integrity',
        descriptionKey: 'profile.tech.rule.data_integrity_desc',
      },
      {
        id: 'rule-system-limits',
        labelKey: 'profile.tech.rule.system_limits',
        descriptionKey: 'profile.tech.rule.system_limits_desc',
      },
    ],
    sceneObjectDefs: [
      {
        id: 'main-terminal',
        labelKey: 'profile.tech.scene.terminal',
        hintKey: 'profile.tech.scene.terminal_hint',
        box_2d: { ymin: 200, xmin: 300, ymax: 600, xmax: 700 },
      },
      {
        id: 'power-conduit',
        labelKey: 'profile.tech.scene.conduit',
        hintKey: 'profile.tech.scene.conduit_hint',
        box_2d: { ymin: 100, xmin: 50, ymax: 400, xmax: 200 },
      },
    ],
    welcomeMessageKey: 'profile.tech.welcome',
  },
};

/**
 * ëª¨ë“  ë°ëª¨ í”„ë¡œí•„ ëª©ë¡.
 */
export const DEMO_PROFILES: readonly DemoProfile[] = [
  PROFILE_NARRATOR,
  PROFILE_EXPLORER,
  PROFILE_TECH,
] as const;

/**
 * í”„ë¡œí•„ IDë¡œ í”„ë¡œí•„ì„ ì°¾ìŠµë‹ˆë‹¤.
 */
export function findProfileById(profileId: string): DemoProfile | undefined {
  return DEMO_PROFILES.find((p) => p.id === profileId);
}

// =============================================================================
// í”„ë¡œí•„ â†’ SaveGameInput ë³€í™˜ (RU-004-Q1: SSOT ë‹¨ì¼í™”)
// =============================================================================

/**
 * ë°ëª¨ í”„ë¡œí•„ì„ SaveGameInputìœ¼ë¡œ ë³€í™˜í•©ë‹ˆë‹¤.
 *
 * RU-004-Q1: SaveGame ìƒì„±ì€ createSaveGame(SSOT)ë§Œ ìˆ˜í–‰í•˜ë„ë¡ ë¶„ë¦¬.
 * ì´ í•¨ìˆ˜ëŠ” "ì…ë ¥ ë³€í™˜(input adapter)" ì—­í• ë§Œ ë‹´ë‹¹í•©ë‹ˆë‹¤.
 *
 * @param profile - ë°ëª¨ í”„ë¡œí•„
 * @param language - ì–¸ì–´ ì„¤ì •
 * @param t - i18n ë²ˆì—­ í•¨ìˆ˜
 * @returns SaveGameInput ê°ì²´ (createSaveGameì— ì „ë‹¬ ê°€ëŠ¥)
 */
export function profileToSaveGameInput(
  profile: DemoProfile,
  language: SupportedLanguage,
  t: (key: string) => string,
): SaveGameInput {
  const now = Date.now();

  return {
    language,
    profileId: profile.id,
    // RU-004-Q5: seed ìƒì„± ì •ì±… SSOT (constants.ts)
    seed: generateDemoSeed(profile.id),
    economy: {
      signal: profile.initialState.economy.signal,
      memory_shard: profile.initialState.economy.memory_shard,
    },
    economyLedger: [],
    turnCount: 0,
    narrativeHistory: [
      {
        turn: 0,
        text: t(profile.initialState.welcomeMessageKey),
      },
    ],
    inventory: profile.initialState.inventoryDefs.map((item) => ({
      id: item.id,
      name: t(item.nameKey),
      icon: item.icon,
      quantity: item.quantity,
    })),
    quests: profile.initialState.questDefs.map((quest) => ({
      id: quest.id,
      label: t(quest.labelKey),
      is_completed: quest.is_completed,
    })),
    activeRules: profile.initialState.ruleDefs.map((rule) => ({
      id: rule.id,
      label: t(rule.labelKey),
      description: rule.descriptionKey ? t(rule.descriptionKey) : null,
    })),
    mutationTimeline: profile.initialState.ruleDefs.map((rule, index) => ({
      turn: 0,
      ruleId: rule.id,
      type: 'added' as const,
      label: t(rule.labelKey),
      description: rule.descriptionKey ? t(rule.descriptionKey) : undefined,
      timestamp: now - index * 1000,
    })),
    sceneObjects: profile.initialState.sceneObjectDefs.map((obj) => ({
      id: obj.id,
      label: t(obj.labelKey),
      box_2d: obj.box_2d,
      interaction_hint: t(obj.hintKey),
    })),
  };
}

/**
 * ë°ëª¨ í”„ë¡œí•„ì„ SaveGame í˜•íƒœë¡œ ë³€í™˜í•©ë‹ˆë‹¤.
 *
 * RU-004-Q1: createSaveGame(SSOT)ë¥¼ í˜¸ì¶œí•˜ëŠ” ì–‡ì€ wrapperì…ë‹ˆë‹¤.
 * ê¸°ì¡´ í˜¸ì¶œìì™€ì˜ í˜¸í™˜ì„±ì„ ìœ ì§€í•©ë‹ˆë‹¤.
 *
 * @param profile - ë°ëª¨ í”„ë¡œí•„
 * @param language - ì–¸ì–´ ì„¤ì •
 * @param t - i18n ë²ˆì—­ í•¨ìˆ˜
 * @returns SaveGame ê°ì²´
 */
export function createSaveGameFromProfile(
  profile: DemoProfile,
  language: SupportedLanguage,
  t: (key: string) => string,
): SaveGame {
  return createSaveGame(profileToSaveGameInput(profile, language, t));
}

/**
 * í”„ë¡œí•„ ëª©ë¡ ì •ë³´ë§Œ ê°€ì ¸ì˜µë‹ˆë‹¤ (ì„ íƒ UIìš©).
 */
export function getProfileSummaries(): Array<DemoProfileDef> {
  return DEMO_PROFILES.map((p) => ({
    id: p.id,
    nameKey: p.nameKey,
    descriptionKey: p.descriptionKey,
    icon: p.icon,
    themeColor: p.themeColor,
  }));
}
</file>

<file path="frontend/src/demo/useDemoInitializer.ts">
import { useEffect } from 'react';
import { useTranslation } from 'react-i18next';
import { useInventoryStore } from '../stores/inventoryStore';
import { useWorldStore } from '../stores/worldStore';
import type { Quest, WorldRule } from '../schemas/turn';
import type { MutationEvent } from '../stores/worldStore';
import {
  DEMO_INVENTORY_ITEMS,
  DEMO_SCENE_OBJECTS,
  DEMO_QUESTS,
  DEMO_RULES,
  getDemoItemNameKey,
  isDemoEnvironment,
} from '../demo/demoFixtures';

/**
 * ë°ëª¨ í™˜ê²½ì—ì„œ ì´ˆê¸° mock ë°ì´í„°ë¥¼ ë¡œë“œí•˜ëŠ” í›… (RU-003-Q5, U-013).
 */
export function useDemoInitializer() {
  const { t } = useTranslation();
  const { items: inventoryItems, addItems: addInventoryItems } = useInventoryStore();
  const worldStore = useWorldStore();
  const {
    sceneObjects,
    setSceneObjects,
    narrativeEntries,
    initialize: initializeWorld,
    quests,
    activeRules,
  } = worldStore;

  useEffect(() => {
    // ì›”ë“œ ì´ˆê¸°í™” (í™˜ì˜ ë©”ì‹œì§€)
    if (narrativeEntries.length === 0) {
      initializeWorld(t('narrative.welcome'));
    }

    // DEV: ë°ëª¨ìš© mock ë°ì´í„° ì´ˆê¸°í™” (RU-003-Q5: DEV ê°€ë“œ + i18n í‚¤ ê¸°ë°˜)
    if (isDemoEnvironment()) {
      // ë°ëª¨ìš© mock ì¸ë²¤í† ë¦¬ ì´ˆê¸°í™” (U-011)
      if (inventoryItems.length === 0) {
        const demoInventory = DEMO_INVENTORY_ITEMS.map((item) => ({
          id: item.id,
          name: t(getDemoItemNameKey(item.id)),
          icon: item.icon,
          quantity: item.quantity,
        }));
        addInventoryItems(demoInventory);
      }

      // ë°ëª¨ìš© mock Scene Objects ì´ˆê¸°í™” (U-010)
      if (sceneObjects.length === 0) {
        const demoSceneObjects = DEMO_SCENE_OBJECTS.map((obj) => ({
          id: obj.id,
          label: t(obj.labelKey),
          box_2d: obj.box_2d,
          interaction_hint: t(obj.hintKey),
        }));
        setSceneObjects(demoSceneObjects);
      }

      // ë°ëª¨ìš© mock í€˜ìŠ¤íŠ¸ ì´ˆê¸°í™” (U-013)
      if (quests.length === 0) {
        const demoQuests: Quest[] = DEMO_QUESTS.map((q) => ({
          id: q.id,
          label: t(q.labelKey),
          is_completed: q.is_completed,
        }));
        useWorldStore.setState({ quests: demoQuests });
      }

      // ë°ëª¨ìš© mock ê·œì¹™ ì´ˆê¸°í™” (U-013)
      if (activeRules.length === 0) {
        const demoRules: WorldRule[] = DEMO_RULES.map((r) => ({
          id: r.id,
          label: t(r.labelKey),
          description: r.descriptionKey ? t(r.descriptionKey) : null,
        }));
        // ë°ëª¨ ë®¤í…Œì´ì…˜ íƒ€ì„ë¼ì¸ ìƒì„± (ê·œì¹™ ì¶”ê°€ ì´ë²¤íŠ¸)
        const now = Date.now();
        const demoMutations: MutationEvent[] = DEMO_RULES.map((r, index) => ({
          turn: 0,
          ruleId: r.id,
          type: 'added' as const,
          label: t(r.labelKey),
          description: r.descriptionKey ? t(r.descriptionKey) : undefined,
          timestamp: now - index * 1000, // ì‹œê°„ ìˆœì„œ êµ¬ë¶„ìš©
        }));
        useWorldStore.setState({
          activeRules: demoRules,
          mutationTimeline: demoMutations,
        });
      }
    }
    // eslint-disable-next-line react-hooks/exhaustive-deps
  }, [t]);
}
</file>

<file path="frontend/src/stores/agentStore.ts">
/**
 * Unknown World - Agent Console ìƒíƒœ ê´€ë¦¬ (Zustand).
 *
 * ìŠ¤íŠ¸ë¦¬ë° ì¤‘ ìˆ˜ì‹ ë˜ëŠ” ë‹¨ê³„/ë°°ì§€/ë‚´ëŸ¬í‹°ë¸Œ/ë³µêµ¬ ì •ë³´ë¥¼ ì €ì¥í•˜ê³ ,
 * AgentConsole ì»´í¬ë„ŒíŠ¸ì—ì„œ êµ¬ë…í•  ìˆ˜ ìˆë„ë¡ í•©ë‹ˆë‹¤.
 *
 * ì„¤ê³„ ì›ì¹™:
 *   - RULE-008: ë‹¨ê³„/ë°°ì§€ ê°€ì‹œí™” (í”„ë¡¬í”„íŠ¸/ë‚´ë¶€ ì¶”ë¡  ë…¸ì¶œ ê¸ˆì§€)
 *   - RULE-003/004: ê²€ì¦ í›„ ìƒíƒœ ë°˜ì˜, ì‹¤íŒ¨ ì‹œ í´ë°±
 *
 * @module stores/agentStore
 */

import { create } from 'zustand';
import type { AgentPhase, ValidationBadge, TurnOutput } from '../schemas/turn';
import type {
  StageEvent,
  BadgesEvent,
  NarrativeDeltaEvent,
  FinalEvent,
  ErrorEvent,
} from '../types/turn_stream';
import { StageStatus } from '../types/turn_stream';

// =============================================================================
// ìƒíƒœ íƒ€ì… ì •ì˜
// =============================================================================

/** ë‹¨ê³„ ìƒíƒœ */
export type PhaseStatus = 'pending' | 'in_progress' | 'completed' | 'failed';

/** ë‹¨ê³„ ì •ë³´ */
export interface PhaseInfo {
  name: AgentPhase;
  status: PhaseStatus;
}

/** ì—ëŸ¬ ì •ë³´ */
export interface AgentError {
  message: string;
  code?: string;
}

/** Agent Console ìƒíƒœ */
export interface AgentState {
  /** í˜„ì¬ ìŠ¤íŠ¸ë¦¬ë° ì¤‘ì¸ì§€ */
  isStreaming: boolean;
  /** í˜„ì¬ ë‹¨ê³„ */
  currentPhase: AgentPhase | null;
  /** ë‹¨ê³„ë³„ ìƒíƒœ */
  phases: PhaseInfo[];
  /** ê²€ì¦ ë°°ì§€ ëª©ë¡ */
  badges: ValidationBadge[];
  /** ëˆ„ì  ë‚´ëŸ¬í‹°ë¸Œ í…ìŠ¤íŠ¸ (íƒ€ì íš¨ê³¼ìš©) */
  narrativeBuffer: string;
  /** ìë™ ë³µêµ¬ íšŸìˆ˜ */
  repairCount: number;
  /** ìµœì¢… TurnOutput */
  finalOutput: TurnOutput | null;
  /** ì—ëŸ¬ ì •ë³´ */
  error: AgentError | null;
}

/** Agent Console ì•¡ì…˜ */
export interface AgentActions {
  /** ìŠ¤íŠ¸ë¦¼ ì‹œì‘ */
  startStream: () => void;
  /** ë‹¨ê³„ ì´ë²¤íŠ¸ ì²˜ë¦¬ */
  handleStage: (event: StageEvent) => void;
  /** ë°°ì§€ ì´ë²¤íŠ¸ ì²˜ë¦¬ */
  handleBadges: (event: BadgesEvent) => void;
  /** ë‚´ëŸ¬í‹°ë¸Œ ë¸íƒ€ ì´ë²¤íŠ¸ ì²˜ë¦¬ */
  handleNarrativeDelta: (event: NarrativeDeltaEvent) => void;
  /** ìµœì¢… ì¶œë ¥ ì´ë²¤íŠ¸ ì²˜ë¦¬ */
  handleFinal: (event: FinalEvent) => void;
  /** ì—ëŸ¬ ì´ë²¤íŠ¸ ì²˜ë¦¬ */
  handleError: (event: ErrorEvent) => void;
  /** ìŠ¤íŠ¸ë¦¼ ì™„ë£Œ */
  completeStream: () => void;
  /** ìƒíƒœ ì´ˆê¸°í™” */
  reset: () => void;
}

export type AgentStore = AgentState & AgentActions;

// =============================================================================
// ì´ˆê¸° ìƒíƒœ
// =============================================================================

/** ê¸°ë³¸ ë‹¨ê³„ ëª©ë¡ (PRD ì˜ˆì‹œ) */
const DEFAULT_PHASES: AgentPhase[] = [
  'parse',
  'validate',
  'plan',
  'resolve',
  'render',
  'verify',
  'commit',
];

/** ì´ˆê¸° ìƒíƒœ ìƒì„± */
function createInitialState(): AgentState {
  return {
    isStreaming: false,
    currentPhase: null,
    phases: DEFAULT_PHASES.map((name) => ({
      name,
      status: 'pending' as const,
    })),
    badges: [],
    narrativeBuffer: '',
    repairCount: 0,
    finalOutput: null,
    error: null,
  };
}

// =============================================================================
// Zustand Store
// =============================================================================

/**
 * Agent Console ìƒíƒœ ìŠ¤í† ì–´.
 *
 * @example
 * ```tsx
 * // ì»´í¬ë„ŒíŠ¸ì—ì„œ ì‚¬ìš©
 * const { isStreaming, phases, badges } = useAgentStore();
 * const startStream = useAgentStore((state) => state.startStream);
 * ```
 */
export const useAgentStore = create<AgentStore>((set) => ({
  // ì´ˆê¸° ìƒíƒœ
  ...createInitialState(),

  // ì•¡ì…˜
  startStream: () => {
    set({
      ...createInitialState(),
      isStreaming: true,
    });
  },

  handleStage: (event) => {
    set((state) => {
      const phaseName = event.name;
      const eventStatus = event.status;

      // RU-002-S2: status ê°’ì— ë”°ë¥¸ ë‹¨ê³„ ìƒíƒœ ê²°ì •
      // 'start' â†’ in_progress
      // 'complete' ë˜ëŠ” 'ok' (ì •ê·œí™”ë¨) â†’ completed
      // 'fail' â†’ failed
      let newStatus: PhaseStatus;
      if (eventStatus === StageStatus.START) {
        newStatus = 'in_progress';
      } else if (eventStatus === 'fail') {
        newStatus = 'failed';
      } else {
        // 'complete' (ì •ê·œí™”ëœ 'ok' í¬í•¨)
        newStatus = 'completed';
      }

      // ë‹¨ê³„ ìƒíƒœ ì—…ë°ì´íŠ¸
      const phases = state.phases.map((phase) => {
        if (phase.name === phaseName) {
          return {
            ...phase,
            status: newStatus,
          };
        }
        return phase;
      });

      return {
        phases,
        currentPhase: eventStatus === StageStatus.START ? phaseName : state.currentPhase,
      };
    });
  },

  handleBadges: (event) => {
    set({
      badges: event.badges,
    });
  },

  handleNarrativeDelta: (event) => {
    set((state) => ({
      narrativeBuffer: state.narrativeBuffer + event.text,
    }));
  },

  handleFinal: (event) => {
    set({
      finalOutput: event.data,
      repairCount: event.data.agent_console?.repair_count ?? 0,
    });
  },

  handleError: (event) => {
    set({
      error: {
        message: event.message,
        code: event.code,
      },
    });
  },

  completeStream: () => {
    set({
      isStreaming: false,
      narrativeBuffer: '', // ìŠ¤íŠ¸ë¦¼ ì™„ë£Œ ì‹œ ë²„í¼ ì´ˆê¸°í™”
    });
  },

  reset: () => {
    set(createInitialState());
  },
}));

// =============================================================================
// ì…€ë ‰í„° (ì„±ëŠ¥ ìµœì í™”ìš©)
// =============================================================================

/** ìŠ¤íŠ¸ë¦¬ë° ìƒíƒœ ì…€ë ‰í„° */
export const selectIsStreaming = (state: AgentStore) => state.isStreaming;

/** í˜„ì¬ ë‹¨ê³„ ì…€ë ‰í„° */
export const selectCurrentPhase = (state: AgentStore) => state.currentPhase;

/** ë‹¨ê³„ ëª©ë¡ ì…€ë ‰í„° */
export const selectPhases = (state: AgentStore) => state.phases;

/** ë°°ì§€ ëª©ë¡ ì…€ë ‰í„° */
export const selectBadges = (state: AgentStore) => state.badges;

/** ë‚´ëŸ¬í‹°ë¸Œ ë²„í¼ ì…€ë ‰í„° */
export const selectNarrativeBuffer = (state: AgentStore) => state.narrativeBuffer;

/** ë³µêµ¬ íšŸìˆ˜ ì…€ë ‰í„° */
export const selectRepairCount = (state: AgentStore) => state.repairCount;

/** ìµœì¢… ì¶œë ¥ ì…€ë ‰í„° */
export const selectFinalOutput = (state: AgentStore) => state.finalOutput;

/** ì—ëŸ¬ ì…€ë ‰í„° */
export const selectError = (state: AgentStore) => state.error;
</file>

<file path="shared/schemas/turn/turn_input.schema.json">
{
  "$schema": "http://json-schema.org/draft-07/schema#",
  "$id": "https://unknown-world.dev/schemas/turn/turn_input.schema.json",
  "title": "TurnInput",
  "description": "Client â†’ Server í„´ ìš”ì²­ ìŠ¤í‚¤ë§ˆ (MVP). PRD 8.7ì ˆ ê¸°ë°˜.",
  "type": "object",
  "properties": {
    "language": {
      "type": "string",
      "enum": ["ko-KR", "en-US"],
      "description": "ê²Œì„ ì–¸ì–´ ì„¤ì • (ko-KR ë˜ëŠ” en-US)"
    },
    "text": {
      "type": "string",
      "description": "ì‚¬ìš©ì ì…ë ¥ (ìì—°ì–´)"
    },
    "click": {
      "type": ["object", "null"],
      "description": "í´ë¦­ëœ ì˜¤ë¸Œì íŠ¸ ì •ë³´ (ì„ íƒ)",
      "properties": {
        "object_id": {
          "type": "string",
          "description": "í´ë¦­ëœ ì˜¤ë¸Œì íŠ¸ ID"
        },
        "box_2d": {
          "type": ["array", "null"],
          "description": "bbox [ymin, xmin, ymax, xmax] (0~1000 ì •ê·œí™”)",
          "items": {
            "type": "integer",
            "minimum": 0,
            "maximum": 1000
          },
          "minItems": 4,
          "maxItems": 4
        }
      },
      "required": ["object_id"]
    },
    "client": {
      "type": "object",
      "description": "í´ë¼ì´ì–¸íŠ¸ í™˜ê²½ ì •ë³´",
      "properties": {
        "viewport_w": {
          "type": "integer",
          "description": "ë·°í¬íŠ¸ ë„ˆë¹„ (px)"
        },
        "viewport_h": {
          "type": "integer",
          "description": "ë·°í¬íŠ¸ ë†’ì´ (px)"
        },
        "theme": {
          "type": "string",
          "enum": ["dark", "light"],
          "description": "í…Œë§ˆ ì„¤ì •"
        }
      },
      "required": ["viewport_w", "viewport_h", "theme"]
    },
    "economy_snapshot": {
      "type": "object",
      "description": "í˜„ì¬ ì¬í™” ìƒíƒœ ìŠ¤ëƒ…ìƒ·",
      "properties": {
        "signal": {
          "type": "integer",
          "minimum": 0,
          "description": "Signal ì¬í™” ì”ì•¡"
        },
        "memory_shard": {
          "type": "integer",
          "minimum": 0,
          "description": "Memory Shard ì¬í™” ì”ì•¡"
        }
      },
      "required": ["signal", "memory_shard"]
    }
  },
  "required": ["language", "text", "client", "economy_snapshot"],
  "additionalProperties": false
}
</file>

<file path="backend/src/unknown_world/api/turn.py">
"""Unknown World - /api/turn HTTP Streaming ì—”ë“œí¬ì¸íŠ¸.

POST ìš”ì²­ì„ ë°›ì•„ NDJSON(ë¼ì¸ ë‹¨ìœ„ JSON) ìŠ¤íŠ¸ë¦¬ë°ìœ¼ë¡œ í„´ ê²°ê³¼ë¥¼ ë°˜í™˜í•©ë‹ˆë‹¤.

ì„¤ê³„ ì›ì¹™:
    - RULE-003: êµ¬ì¡°í™” ì¶œë ¥(JSON Schema) ìš°ì„  + Pydantic ê²€ì¦
    - RULE-004: ê²€ì¦ ì‹¤íŒ¨ ì‹œ Repair loop + ì•ˆì „í•œ í´ë°±
    - RULE-005: ì¬í™” ì¸ë°”ë¦¬ì–¸íŠ¸ (ì”ì•¡ ìŒìˆ˜ ê¸ˆì§€)
    - RULE-007: í”„ë¡¬í”„íŠ¸/ë‚´ë¶€ ì¶”ë¡  ë…¸ì¶œ ê¸ˆì§€
    - RULE-008: ë‹¨ê³„/ë°°ì§€ ê°€ì‹œí™”, TTFB 2ì´ˆ ëª©í‘œ

ìŠ¤íŠ¸ë¦¼ ì´ë²¤íŠ¸ íƒ€ì…:
    - stage: ë‹¨ê³„ ì§„í–‰ ìƒíƒœ (Parseâ†’Validateâ†’Planâ†’Resolveâ†’Renderâ†’Verifyâ†’Commit)
    - badges: ê²€ì¦ ë°°ì§€ ëª©ë¡
    - narrative_delta: ë‚´ëŸ¬í‹°ë¸Œ í…ìŠ¤íŠ¸ ì¡°ê° (íƒ€ì íš¨ê³¼ìš©)
    - final: ìµœì¢… TurnOutput
    - error: ì—ëŸ¬ ë°œìƒ ì‹œ

ì°¸ì¡°:
    - vibe/unit-plans/U-007[Mvp].md
    - .cursor/rules/20-backend-orchestrator.mdc
"""

import asyncio
import time
from collections.abc import AsyncGenerator
from typing import Any, cast

from fastapi import APIRouter, Request
from fastapi.responses import StreamingResponse
from pydantic import ValidationError

from unknown_world.api.turn_stream_events import (
    BadgesEvent,
    ErrorEvent,
    FinalEvent,
    NarrativeDeltaEvent,
    RepairEvent,
    StageEvent,
    StageStatus,
    StreamEventType,
    serialize_event,
)
from unknown_world.models.turn import (
    AgentPhase,
    CurrencyAmount,
    Language,
    TurnInput,
    ValidationBadge,
)
from unknown_world.orchestrator.mock import MockOrchestrator

# =============================================================================
# ë¼ìš°í„° ì •ì˜
# =============================================================================

router = APIRouter(prefix="/api", tags=["Turn"])

# ë‹¨ê³„ ëª©ë¡ (PRD ì˜ˆì‹œ)
ORCHESTRATOR_PHASES = [
    AgentPhase.PARSE,
    AgentPhase.VALIDATE,
    AgentPhase.PLAN,
    AgentPhase.RESOLVE,
    AgentPhase.RENDER,
    AgentPhase.VERIFY,
    AgentPhase.COMMIT,
]

# ëª¨ì˜ ë‹¨ê³„ ì§€ì—° ì‹œê°„ (ms) - ì‹¤ì œ ì²˜ë¦¬ ì‹œë®¬ë ˆì´ì…˜
PHASE_DELAYS_MS = {
    AgentPhase.PARSE: 50,
    AgentPhase.VALIDATE: 30,
    AgentPhase.PLAN: 100,
    AgentPhase.RESOLVE: 150,
    AgentPhase.RENDER: 80,
    AgentPhase.VERIFY: 40,
    AgentPhase.COMMIT: 20,
}


async def _stream_turn_events(
    turn_input: TurnInput, seed: int | None = None
) -> AsyncGenerator[str]:
    """í„´ ì²˜ë¦¬ ì´ë²¤íŠ¸ë¥¼ NDJSON ìŠ¤íŠ¸ë¦¼ìœ¼ë¡œ ìƒì„±í•©ë‹ˆë‹¤.

    Args:
        turn_input: ì‚¬ìš©ì í„´ ì…ë ¥
        seed: ëª¨ì˜ Orchestrator ì‹œë“œ (ì¬í˜„ì„± ë³´ì¥)

    Yields:
        str: NDJSON ë¼ì¸
    """
    orchestrator = MockOrchestrator(seed=seed)
    collected_badges: list[str] = []

    # Phase 1: Parse (TTFBë¥¼ ìœ„í•´ ì¦‰ì‹œ ì‹œì‘ ì´ë²¤íŠ¸ ì „ì†¡)
    yield serialize_event(
        StageEvent(
            type=StreamEventType.STAGE, name=AgentPhase.PARSE.value, status=StageStatus.START
        ).model_dump()
    )

    # ê° ë‹¨ê³„ë³„ ì²˜ë¦¬ ì‹œë®¬ë ˆì´ì…˜
    for phase in ORCHESTRATOR_PHASES:
        # ë‹¨ê³„ ì‹œì‘
        if phase != AgentPhase.PARSE:  # ParseëŠ” ì´ë¯¸ ì „ì†¡í•¨
            yield serialize_event(
                StageEvent(
                    type=StreamEventType.STAGE, name=phase.value, status=StageStatus.START
                ).model_dump()
            )

        # ëª¨ì˜ ì²˜ë¦¬ ì§€ì—°
        delay_ms = PHASE_DELAYS_MS.get(phase, 50)
        await asyncio.sleep(delay_ms / 1000.0)

        # ë‹¨ê³„ ì™„ë£Œ
        yield serialize_event(
            StageEvent(
                type=StreamEventType.STAGE, name=phase.value, status=StageStatus.COMPLETE
            ).model_dump()
        )

        # ë°°ì§€ ì¶”ê°€ (Validate, Verify ë‹¨ê³„ì—ì„œ)
        if phase == AgentPhase.VALIDATE:
            collected_badges.append(ValidationBadge.SCHEMA_OK.value)
            collected_badges.append(ValidationBadge.ECONOMY_OK.value)
            yield serialize_event(
                BadgesEvent(
                    type=StreamEventType.BADGES, badges=collected_badges.copy()
                ).model_dump()
            )
        elif phase == AgentPhase.VERIFY:
            collected_badges.append(ValidationBadge.SAFETY_OK.value)
            collected_badges.append(ValidationBadge.CONSISTENCY_OK.value)
            yield serialize_event(
                BadgesEvent(
                    type=StreamEventType.BADGES, badges=collected_badges.copy()
                ).model_dump()
            )

    # TurnOutput ìƒì„± (Repair ë£¨í”„ í¬í•¨ - RULE-004)
    max_repair_attempts = 3
    repair_attempt = 0
    turn_output = None

    try:
        while repair_attempt <= max_repair_attempts:
            try:
                # 0íšŒì°¨ëŠ” ì •ìƒ ì‹œë„, 1íšŒì°¨ë¶€í„°ëŠ” repair
                if repair_attempt > 0:
                    yield serialize_event(
                        RepairEvent(
                            type=StreamEventType.REPAIR,
                            attempt=repair_attempt,
                            message="ê²€ì¦ ì‹¤íŒ¨ë¡œ ì¸í•´ ë‹¤ì‹œ ì‹œë„ ì¤‘ì…ë‹ˆë‹¤..."
                            if turn_input.language == Language.KO
                            else "Retrying due to validation failure",
                        ).model_dump()
                    )

                turn_output = orchestrator.generate_turn_output(turn_input)
                break  # ì„±ê³µ ì‹œ ë£¨í”„ íƒˆì¶œ

            except ValidationError as e:
                repair_attempt += 1
                if repair_attempt > max_repair_attempts:
                    # ìµœì¢… ì‹¤íŒ¨ ì‹œ í´ë°± (RULE-004)
                    turn_output = orchestrator.create_safe_fallback(
                        language=turn_input.language,
                        error_message=str(e),
                        economy_snapshot=CurrencyAmount(
                            signal=turn_input.economy_snapshot.signal,
                            memory_shard=turn_input.economy_snapshot.memory_shard,
                        ),
                    )
                    break
                # ë£¨í”„ ê³„ì† ì§„í–‰ (ì¬ì‹œë„)
                continue

        if turn_output:
            # ë‚´ëŸ¬í‹°ë¸Œ ë¸íƒ€ ìŠ¤íŠ¸ë¦¬ë° (íƒ€ì íš¨ê³¼)
            narrative = turn_output.narrative
            chunk_size = 20  # í•œ ë²ˆì— ì „ì†¡í•  ê¸€ì ìˆ˜
            for i in range(0, len(narrative), chunk_size):
                chunk = narrative[i : i + chunk_size]
                yield serialize_event(
                    NarrativeDeltaEvent(
                        type=StreamEventType.NARRATIVE_DELTA, text=chunk
                    ).model_dump()
                )
                await asyncio.sleep(0.02)  # íƒ€ì íš¨ê³¼ ë”œë ˆì´

            # ìµœì¢… TurnOutput ì „ì†¡
            yield serialize_event(
                FinalEvent(type=StreamEventType.FINAL, data=turn_output).model_dump(mode="json")
            )

    except Exception:
        # RU-002-S1: ì˜ˆì™¸ ë°œìƒ ì‹œ error + final(í´ë°±) ìˆœì„œë¡œ ì†¡ì¶œ
        # (í”„ë¡¬í”„íŠ¸/ë‚´ë¶€ ì¶”ë¡  ë…¸ì¶œ ê¸ˆì§€ - RULE-007)
        yield serialize_event(
            ErrorEvent(
                type=StreamEventType.ERROR,
                message="ì²˜ë¦¬ ì¤‘ ì˜¤ë¥˜ê°€ ë°œìƒí–ˆìŠµë‹ˆë‹¤"
                if turn_input.language == Language.KO
                else "An error occurred during processing",
                code="INTERNAL_ERROR",
            ).model_dump()
        )
        # í•­ìƒ final(í´ë°±)ë¡œ ì¢…ë£Œ - ìŠ¤íŠ¸ë¦¼ ì¢…ë£Œ ì¸ë°”ë¦¬ì–¸íŠ¸ (RULE-004)
        fallback = orchestrator.create_safe_fallback(
            language=turn_input.language,
            error_message="Internal error",
            economy_snapshot=CurrencyAmount(
                signal=turn_input.economy_snapshot.signal,
                memory_shard=turn_input.economy_snapshot.memory_shard,
            ),
        )
        yield serialize_event(
            FinalEvent(type=StreamEventType.FINAL, data=fallback).model_dump(mode="json")
        )


async def _validate_and_parse_input(request: Request) -> TurnInput | dict[str, Any]:
    """ìš”ì²­ ë³¸ë¬¸ì„ TurnInputìœ¼ë¡œ ê²€ì¦ ë° íŒŒì‹±í•©ë‹ˆë‹¤.

    Returns:
        TurnInput ë˜ëŠ” ì—ëŸ¬ ì •ë³´ dict (language, economy_snapshot í¬í•¨)
    """
    body: dict[str, Any] | None = None
    try:
        body = await request.json()
        return TurnInput.model_validate(body)
    except ValidationError as e:
        # RU-002-S1: ì…ë ¥ ê²€ì¦ ì‹¤íŒ¨ ì‹œì—ë„ language/economy ì¶”ì¶œ ì‹œë„
        raw_language = body.get("language") if isinstance(body, dict) else None
        raw_economy = body.get("economy_snapshot") if isinstance(body, dict) else None
        return {
            "error": True,
            "message": "Invalid input",
            "details": e.errors(),
            "language": raw_language if raw_language in ("ko-KR", "en-US") else "ko-KR",
            "economy_snapshot": raw_economy,
        }
    except Exception:
        return {
            "error": True,
            "message": "Failed to parse request body",
            "details": None,
            "language": "ko-KR",
            "economy_snapshot": None,
        }


@router.post(
    "/turn",
    response_class=StreamingResponse,
    summary="í„´ ì²˜ë¦¬ (HTTP Streaming)",
    description="""
í„´ ì…ë ¥ì„ ë°›ì•„ NDJSON ìŠ¤íŠ¸ë¦¬ë°ìœ¼ë¡œ ê²°ê³¼ë¥¼ ë°˜í™˜í•©ë‹ˆë‹¤.

**ìŠ¤íŠ¸ë¦¼ ì´ë²¤íŠ¸ íƒ€ì…**:
- `stage`: ì²˜ë¦¬ ë‹¨ê³„ ì§„í–‰ ìƒíƒœ
- `badges`: ê²€ì¦ ë°°ì§€ ëª©ë¡
- `narrative_delta`: ë‚´ëŸ¬í‹°ë¸Œ í…ìŠ¤íŠ¸ ì¡°ê° (íƒ€ì íš¨ê³¼)
- `final`: ìµœì¢… TurnOutput
- `error`: ì—ëŸ¬ ë°œìƒ ì‹œ

**ì˜ˆì‹œ ìš”ì²­**:
```json
{
    "language": "ko-KR",
    "text": "ë¬¸ì„ ì—´ì–´ë³¸ë‹¤",
    "client": {"viewport_w": 1920, "viewport_h": 1080, "theme": "dark"},
    "economy_snapshot": {"signal": 100, "memory_shard": 5}
}
```
""",
    responses={
        200: {
            "description": "NDJSON ìŠ¤íŠ¸ë¦¼",
            "content": {
                "application/x-ndjson": {
                    "example": '{"type":"stage","name":"parse","status":"start"}\n'
                }
            },
        },
        400: {"description": "ì˜ëª»ëœ ìš”ì²­"},
    },
)
async def turn_stream(request: Request) -> StreamingResponse:
    """í„´ ì²˜ë¦¬ HTTP Streaming ì—”ë“œí¬ì¸íŠ¸.

    POST ìš”ì²­ìœ¼ë¡œ TurnInputì„ ë°›ì•„ NDJSON ìŠ¤íŠ¸ë¦¬ë°ìœ¼ë¡œ ê²°ê³¼ë¥¼ ë°˜í™˜í•©ë‹ˆë‹¤.
    TTFBë¥¼ ì¤„ì´ê¸° ìœ„í•´ ì²« stage ì´ë²¤íŠ¸ë¥¼ ì¦‰ì‹œ ì „ì†¡í•©ë‹ˆë‹¤.

    Args:
        request: FastAPI Request ê°ì²´

    Returns:
        StreamingResponse: NDJSON ìŠ¤íŠ¸ë¦¼
    """
    # ì…ë ¥ ê²€ì¦
    parse_result = await _validate_and_parse_input(request)

    if isinstance(parse_result, dict) and parse_result.get("error"):
        # RU-002-S1: ì…ë ¥ ê²€ì¦ ì‹¤íŒ¨ ì‹œì—ë„ error + final(í´ë°±) ìˆœì„œë¡œ ì†¡ì¶œ
        error_language = parse_result.get("language", "ko-KR")
        error_economy = parse_result.get("economy_snapshot")

        # economy_snapshotì´ ìœ íš¨í•œì§€ í™•ì¸
        economy_snapshot: CurrencyAmount | None = None
        if isinstance(error_economy, dict):
            try:
                # ëª…ì‹œì  íƒ€ì… ìºìŠ¤íŒ…ìœ¼ë¡œ Pyright ê²½ê³  í•´ì†Œ
                eco_dict = cast(dict[str, Any], error_economy)
                economy_snapshot = CurrencyAmount(
                    signal=int(eco_dict.get("signal", 100)),
                    memory_shard=int(eco_dict.get("memory_shard", 5)),
                )
            except (ValueError, TypeError):
                economy_snapshot = None

        async def error_stream() -> AsyncGenerator[str]:
            # ì—ëŸ¬ ì´ë²¤íŠ¸ ì†¡ì¶œ
            yield serialize_event(
                ErrorEvent(
                    type=StreamEventType.ERROR,
                    message=parse_result.get("message", "Invalid input"),
                    code="VALIDATION_ERROR",
                ).model_dump()
            )
            # í•­ìƒ final(í´ë°±)ë¡œ ì¢…ë£Œ - ìŠ¤íŠ¸ë¦¼ ì¢…ë£Œ ì¸ë°”ë¦¬ì–¸íŠ¸ (RULE-004)
            fallback_orchestrator = MockOrchestrator()
            fallback = fallback_orchestrator.create_safe_fallback(
                language=Language.KO if error_language == "ko-KR" else Language.EN,
                error_message="Validation error",
                economy_snapshot=economy_snapshot,
            )
            yield serialize_event(
                FinalEvent(type=StreamEventType.FINAL, data=fallback).model_dump(mode="json")
            )

        return StreamingResponse(
            error_stream(),
            media_type="application/x-ndjson",
            headers={
                "Cache-Control": "no-cache",
                "X-Accel-Buffering": "no",  # nginx ë²„í¼ë§ ë¹„í™œì„±í™”
            },
        )

    turn_input: TurnInput = parse_result  # type: ignore[assignment]

    # ì‹œë“œ ì¶”ì¶œ (ì¿¼ë¦¬ íŒŒë¼ë¯¸í„°ì—ì„œ, í…ŒìŠ¤íŠ¸/ì¬í˜„ìš©)
    seed_param = request.query_params.get("seed")
    seed = int(seed_param) if seed_param else None

    # NDJSON ìŠ¤íŠ¸ë¦¬ë° ì‘ë‹µ
    return StreamingResponse(
        _stream_turn_events(turn_input, seed=seed),
        media_type="application/x-ndjson",
        headers={
            "Cache-Control": "no-cache",
            "X-Accel-Buffering": "no",  # nginx ë²„í¼ë§ ë¹„í™œì„±í™”
            "X-Request-Time": str(int(time.time() * 1000)),
        },
    )
</file>

<file path="frontend/src/api/turnStream.test.ts">
import { describe, it, expect, vi, beforeEach } from 'vitest';
import { NDJSONParser } from './turnStream';

describe('NDJSONParser', () => {
  let parser: NDJSONParser;

  beforeEach(() => {
    parser = new NDJSONParser();
  });

  it('should parse a single complete line', () => {
    const chunk = JSON.stringify({ type: 'test', value: 1 }) + '\n';
    const results = parser.parse(chunk);
    expect(results).toHaveLength(1);
    expect(results[0]).toEqual({ type: 'test', value: 1 });
  });

  it('should parse multiple complete lines in one chunk', () => {
    const chunk = JSON.stringify({ id: 1 }) + '\n' + JSON.stringify({ id: 2 }) + '\n';
    const results = parser.parse(chunk);
    expect(results).toHaveLength(2);
    expect(results[0]).toEqual({ id: 1 });
    expect(results[1]).toEqual({ id: 2 });
  });

  it('should buffer partial lines and parse them when completed', () => {
    const chunk1 = '{"id": 1';
    const chunk2 = ', "val": "ok"}\n';

    const results1 = parser.parse(chunk1);
    expect(results1).toHaveLength(0);

    const results2 = parser.parse(chunk2);
    expect(results2).toHaveLength(1);
    expect(results2[0]).toEqual({ id: 1, val: 'ok' });
  });

  it('should ignore empty lines', () => {
    const chunk = '\n\n{"a":1}\n\n';
    const results = parser.parse(chunk);
    expect(results).toHaveLength(1);
  });

  it('should not crash on invalid JSON and continue', () => {
    const consoleSpy = vi.spyOn(console, 'warn').mockImplementation(() => {});
    const chunk = 'invalid json\n{"valid": true}\n';
    const results = parser.parse(chunk);

    expect(results).toHaveLength(1);
    expect(results[0]).toEqual({ valid: true });
    expect(consoleSpy).toHaveBeenCalled();
    consoleSpy.mockRestore();
  });

  it('should flush remaining buffer', () => {
    parser.parse('{"id": 1}'); // No newline
    const result = parser.flush();
    expect(result).toEqual({ id: 1 });
  });

  it('should return null on flush with empty buffer', () => {
    const result = parser.flush();
    expect(result).toBeNull();
  });
});

describe('executeTurnStream', () => {
  const mockInput = {
    language: 'ko-KR' as const,
    text: 'Hello',
    action_id: null,
    click: null,
    drop: null, // U-012: ë“œë¡­ ì…ë ¥ í•„ë“œ ì¶”ê°€
    client: { viewport_w: 100, viewport_h: 100, theme: 'dark' as const },
    economy_snapshot: { signal: 100, memory_shard: 0 },
  };

  const mockCallbacks = {
    onStage: vi.fn(),
    onRepair: vi.fn(),
    onBadges: vi.fn(),
    onNarrativeDelta: vi.fn(),
    onFinal: vi.fn(),
    onError: vi.fn(),
    onComplete: vi.fn(),
  };

  beforeEach(() => {
    vi.clearAllMocks();
    global.fetch = vi.fn();
  });

  it('should process stream events correctly (including repair)', async () => {
    const encoder = new TextEncoder();
    const stream = new ReadableStream({
      start(controller) {
        controller.enqueue(
          encoder.encode(JSON.stringify({ type: 'stage', name: 'parse', status: 'start' }) + '\n'),
        );
        controller.enqueue(
          encoder.encode(
            JSON.stringify({ type: 'repair', attempt: 1, message: 'Schema fail, retrying' }) + '\n',
          ),
        );
        controller.enqueue(
          encoder.encode(JSON.stringify({ type: 'narrative_delta', text: 'Hello' }) + '\n'),
        );
        controller.enqueue(
          encoder.encode(
            JSON.stringify({
              type: 'final',
              data: {
                language: 'ko-KR',
                narrative: 'Hello',
                economy: {
                  cost: { signal: 0, memory_shard: 0 },
                  balance_after: { signal: 100, memory_shard: 0 },
                },
                safety: { blocked: false },
              },
            }) + '\n',
          ),
        );
        controller.close();
      },
    });

    (global.fetch as unknown as ReturnType<typeof vi.fn>).mockResolvedValue({
      ok: true,
      body: stream,
    });

    const { executeTurnStream } = await import('./turnStream');
    await executeTurnStream(mockInput, mockCallbacks);

    expect(mockCallbacks.onStage).toHaveBeenCalledWith(expect.objectContaining({ name: 'parse' }));
    expect(mockCallbacks.onRepair).toHaveBeenCalledWith(
      expect.objectContaining({ attempt: 1, message: 'Schema fail, retrying' }),
    );
    expect(mockCallbacks.onNarrativeDelta).toHaveBeenCalledWith(
      expect.objectContaining({ text: 'Hello' }),
    );
    expect(mockCallbacks.onFinal).toHaveBeenCalled();
    expect(mockCallbacks.onComplete).toHaveBeenCalled();
  });

  it('should handle HTTP errors', async () => {
    (global.fetch as unknown as ReturnType<typeof vi.fn>).mockResolvedValue({
      ok: false,
      status: 500,
      statusText: 'Internal Server Error',
    });

    const { executeTurnStream } = await import('./turnStream');
    await executeTurnStream(mockInput, mockCallbacks);

    expect(mockCallbacks.onError).toHaveBeenCalledWith(
      expect.objectContaining({
        code: 'STREAM_ERROR',
        message: expect.stringContaining('500'),
      }),
    );
  });

  it('should handle fetch rejection', async () => {
    (global.fetch as unknown as ReturnType<typeof vi.fn>).mockRejectedValue(
      new Error('Network failure'),
    );

    const { executeTurnStream } = await import('./turnStream');
    await executeTurnStream(mockInput, mockCallbacks);

    expect(mockCallbacks.onError).toHaveBeenCalledWith(
      expect.objectContaining({
        message: 'Network failure',
      }),
    );
  });
});
</file>

<file path="frontend/src/components/ActionDeck.tsx">
/**
 * Unknown World - Action Deck ì»´í¬ë„ŒíŠ¸ (U-009[Mvp]).
 *
 * PRD ìš”êµ¬ì‚¬í•­:
 *   - Action Deck(3~6ì¥ ì¹´ë“œ)ì„ Footer ì˜ì—­ì— ìƒì‹œ ë…¸ì¶œ
 *   - ê° ì¹´ë“œì— ì˜ˆìƒ ë¹„ìš©(ìµœì†Œ/ìµœëŒ€), ìœ„í—˜ë„, ë³´ìƒ íŒíŠ¸ í‘œê¸° (RULE-005)
 *   - ì¹´ë“œ í´ë¦­ ì‹œ TurnInputìœ¼ë¡œ ì„ íƒëœ í–‰ë™ ì „ì†¡ (RULE-008)
 *   - ì”ì•¡ ë¶€ì¡± ì‹œ ì‹¤í–‰ ë¶ˆê°€ í‘œì‹œ + ì €ë¹„ìš© ëŒ€ì•ˆ ë…¸ì¶œ (RULE-005)
 *
 * RULE-002 ì¤€ìˆ˜: ì±„íŒ… ë²„ë¸”/ë©”ì‹œì§€ ë²„íŠ¼ì´ ì•„ë‹Œ "ê²Œì„ ì¹´ë“œ" UI
 *
 * @see vibe/prd.md 6.7 - Action Deck ìš”êµ¬ì‚¬í•­
 * @see .cursor/rules/10-frontend-game-ui.mdc
 * @module components/ActionDeck
 */

import { useMemo, useCallback } from 'react';
import { useTranslation } from 'react-i18next';
import type { ActionCard } from '../schemas/turn';
import { useActionDeckStore } from '../stores/actionDeckStore';
import { useWorldStore } from '../stores/worldStore';
import { useAgentStore } from '../stores/agentStore';
import { useEconomyStore } from '../stores/economyStore';

// =============================================================================
// íƒ€ì… ì •ì˜
// =============================================================================

export interface ActionDeckProps {
  /** ì¹´ë“œ í´ë¦­ ì½œë°± */
  onCardClick?: (card: ActionCard) => void;
  /** ì „ì²´ ë¹„í™œì„±í™” (ìŠ¤íŠ¸ë¦¬ë° ì¤‘ ë“±, ìƒëµ ì‹œ agentStore.isStreaming ì‚¬ìš©) */
  disabled?: boolean;
}

interface CardDisplayInfo extends ActionCard {
  /** í´ë¼ì´ì–¸íŠ¸ ì¸¡ ì‹¤í–‰ ê°€ëŠ¥ ì—¬ë¶€ (ì„œë²„ enabledê°€ ì—†ì„ ë•Œ í´ë°±) */
  isAffordable: boolean;
  /** ìµœì¢… ë¹„í™œì„±í™” ì—¬ë¶€ */
  isDisabled: boolean;
  /** ìµœì¢… ë¹„í™œì„±í™” ì‚¬ìœ  */
  finalDisabledReason: string | null;
}

// =============================================================================
// ê¸°ë³¸ ì¹´ë“œ ìƒì„± (i18n ê¸°ë°˜)
// =============================================================================

function useDefaultCards(): ActionCard[] {
  const { t } = useTranslation();

  return useMemo(
    () => [
      {
        id: 'default-explore',
        label: t('action.default.explore.label'),
        description: t('action.default.explore.description'),
        cost: { signal: 1, memory_shard: 0 },
        cost_estimate: null,
        risk: 'low' as const,
        hint: null,
        reward_hint: null,
        enabled: true,
        disabled_reason: null,
        is_alternative: false,
      },
      {
        id: 'default-investigate',
        label: t('action.default.investigate.label'),
        description: t('action.default.investigate.description'),
        cost: { signal: 2, memory_shard: 0 },
        cost_estimate: null,
        risk: 'medium' as const,
        hint: null,
        reward_hint: null,
        enabled: true,
        disabled_reason: null,
        is_alternative: false,
      },
      {
        id: 'default-talk',
        label: t('action.default.talk.label'),
        description: t('action.default.talk.description'),
        cost: { signal: 1, memory_shard: 0 },
        cost_estimate: null,
        risk: 'low' as const,
        hint: null,
        reward_hint: null,
        enabled: true,
        disabled_reason: null,
        is_alternative: false,
      },
    ],
    [t],
  );
}

// =============================================================================
// ì¹´ë“œ ë¹„ìš© í‘œì‹œ ì»´í¬ë„ŒíŠ¸
// =============================================================================

interface CardCostDisplayProps {
  card: CardDisplayInfo;
}

function CardCostDisplay({ card }: CardCostDisplayProps) {
  const { t } = useTranslation();

  // ë¹„ìš© ì¶”ì • ë²”ìœ„ê°€ ìˆìœ¼ë©´ min~max í‘œì‹œ, ì—†ìœ¼ë©´ ê¸°ë³¸ cost í‘œì‹œ
  const costDisplay = card.cost_estimate
    ? `${card.cost_estimate.min.signal}~${card.cost_estimate.max.signal}`
    : `${card.cost.signal}`;

  const shardCost = card.cost_estimate
    ? card.cost_estimate.max.memory_shard
    : card.cost.memory_shard;

  return (
    <div className="action-card-cost" data-ui-importance="critical">
      {/* Signal ë¹„ìš© */}
      <span className="cost-item">
        <span className="icon-wrapper" aria-label={t('economy.signal_cost')}>
          <img
            src="/ui/icons/signal-16.png"
            alt=""
            aria-hidden="true"
            className="icon-img"
            style={{ width: 14, height: 14 }}
            onError={(e) => e.currentTarget.classList.add('hidden')}
          />
          <span className="icon-fallback">âš¡</span>
        </span>
        <span className="cost-value">{costDisplay}</span>
      </span>

      {/* Shard ë¹„ìš© (0ë³´ë‹¤ í´ ë•Œë§Œ í‘œì‹œ) */}
      {shardCost > 0 && (
        <span className="cost-item">
          <span className="cost-separator">|</span>
          <span className="icon-wrapper" aria-label={t('economy.shard_cost')}>
            <img
              src="/ui/icons/shard-16.png"
              alt=""
              aria-hidden="true"
              className="icon-img"
              style={{ width: 14, height: 14 }}
              onError={(e) => e.currentTarget.classList.add('hidden')}
            />
            <span className="icon-fallback">ğŸ’</span>
          </span>
          <span className="cost-value">
            {card.cost_estimate
              ? `${card.cost_estimate.min.memory_shard}~${card.cost_estimate.max.memory_shard}`
              : card.cost.memory_shard}
          </span>
        </span>
      )}

      {/* ìœ„í—˜ë„ */}
      <span className="cost-item">
        <span className="cost-separator">|</span>
        <span className="icon-wrapper" aria-label={t('economy.risk_level')}>
          <img
            src={`/ui/icons/risk-${card.risk}-16.png`}
            alt=""
            aria-hidden="true"
            className={`icon-img risk-${card.risk}`}
            style={{ width: 14, height: 14 }}
            onError={(e) => e.currentTarget.classList.add('hidden')}
          />
          <span className="icon-fallback">âš </span>
        </span>
        <span className={`risk-label risk-${card.risk}`}>{t(`action.risk.${card.risk}`)}</span>
      </span>
    </div>
  );
}

// =============================================================================
// ë‹¨ì¼ ì¹´ë“œ ì»´í¬ë„ŒíŠ¸
// =============================================================================

interface ActionCardItemProps {
  card: CardDisplayInfo;
  onClick: () => void;
  onHover: (card: CardDisplayInfo | null) => void;
  disabled: boolean;
}

function ActionCardItem({ card, onClick, onHover, disabled }: ActionCardItemProps) {
  const { t } = useTranslation();

  const cardClasses = [
    'action-card',
    'has-chrome',
    card.isDisabled ? 'card-disabled' : '',
    card.is_alternative ? 'card-alternative' : '',
    `risk-border-${card.risk}`,
  ]
    .filter(Boolean)
    .join(' ');

  return (
    <button
      type="button"
      className={cardClasses}
      onClick={onClick}
      onMouseEnter={() => onHover(card)}
      onMouseLeave={() => onHover(null)}
      onFocus={() => onHover(card)}
      onBlur={() => onHover(null)}
      disabled={disabled || card.isDisabled}
      aria-disabled={disabled || card.isDisabled}
      title={card.finalDisabledReason ?? card.description ?? undefined}
    >
      {/* ëŒ€ì•ˆ ì¹´ë“œ í‘œì‹œ */}
      {card.is_alternative && <span className="alternative-badge">{t('action.alternative')}</span>}

      {/* ì¹´ë“œ íƒ€ì´í‹€ */}
      <div className="action-card-title">{card.label}</div>

      {/* ì¹´ë“œ ì„¤ëª… (ìˆì„ ë•Œë§Œ) */}
      {card.description && <div className="action-card-description">{card.description}</div>}

      {/* ë¹„ìš©/ìœ„í—˜ë„ ì •ë³´ */}
      <CardCostDisplay card={card} />

      {/* íŒíŠ¸ ì˜ì—­ */}
      {(card.hint || card.reward_hint) && (
        <div className="action-card-hints">
          {card.hint && (
            <div className="hint-item hint-risk">
              <span className="hint-icon">âš </span>
              <span className="hint-text">{card.hint}</span>
            </div>
          )}
          {card.reward_hint && (
            <div className="hint-item hint-reward">
              <span className="hint-icon">â˜…</span>
              <span className="hint-text">{card.reward_hint}</span>
            </div>
          )}
        </div>
      )}

      {/* ë¹„í™œì„±í™” ì˜¤ë²„ë ˆì´ */}
      {card.isDisabled && (
        <div className="card-disabled-overlay">
          <span className="disabled-reason">
            {card.finalDisabledReason ?? t('action.insufficient_balance')}
          </span>
        </div>
      )}
    </button>
  );
}

// =============================================================================
// ë©”ì¸ Action Deck ì»´í¬ë„ŒíŠ¸
// =============================================================================

export function ActionDeck({ onCardClick, disabled: propsDisabled }: ActionDeckProps) {
  const { t } = useTranslation();
  const defaultCards = useDefaultCards();

  // Store ìƒíƒœ (RU-003: ì»´í¬ë„ŒíŠ¸ ë‚´ì—ì„œ ì§ì ‘ êµ¬ë…)
  const cards = useActionDeckStore((state) => state.cards);
  const currentBalance = useWorldStore((state) => state.economy);
  const isStreaming = useAgentStore((state) => state.isStreaming);
  const setCostEstimateFromCard = useEconomyStore((state) => state.setCostEstimateFromCard);
  const setCostEstimate = useEconomyStore((state) => state.setCostEstimate);

  const disabled = propsDisabled ?? isStreaming;

  // ì¹´ë“œ í˜¸ë²„ í•¸ë“¤ëŸ¬ (U-014: ì˜ˆìƒ ë¹„ìš© í‘œì‹œ)
  const handleCardHover = useCallback(
    (card: CardDisplayInfo | null) => {
      if (card) {
        setCostEstimateFromCard(card.cost, card.cost_estimate, card.id, card.label);
      } else {
        setCostEstimate(null);
      }
    },
    [setCostEstimateFromCard, setCostEstimate],
  );

  // ì¹´ë“œê°€ ì—†ìœ¼ë©´ ê¸°ë³¸ ì¹´ë“œ ì‚¬ìš©
  const displayCards = cards.length > 0 ? cards : defaultCards;

  // ì¹´ë“œë³„ ì‹¤í–‰ ê°€ëŠ¥ ì—¬ë¶€ ê³„ì‚° (Q1: Option A - ì„œë²„ ìš°ì„ , í´ë¼ì´ì–¸íŠ¸ í´ë°±)
  const processedCards: CardDisplayInfo[] = useMemo(() => {
    return displayCards.map((card) => {
      // ì„œë²„ì—ì„œ enabledë¥¼ ëª…ì‹œì ìœ¼ë¡œ falseë¡œ ë³´ëƒˆìœ¼ë©´ ê·¸ëŒ€ë¡œ ì‚¬ìš©
      const serverEnabled = card.enabled;

      // í´ë¼ì´ì–¸íŠ¸ ì¸¡ ì”ì•¡ ì²´í¬ (ì„œë²„ê°€ íŒë‹¨í•˜ì§€ ì•Šì•˜ì„ ë•Œ í´ë°±)
      const costToCheck = card.cost_estimate?.max ?? card.cost;
      const isAffordable =
        currentBalance.signal >= costToCheck.signal &&
        currentBalance.memory_shard >= costToCheck.memory_shard;

      // ìµœì¢… ë¹„í™œì„±í™” ì—¬ë¶€: ì„œë²„ íŒë‹¨ ìš°ì„ , ì—†ìœ¼ë©´ í´ë¼ì´ì–¸íŠ¸ íŒë‹¨
      const isDisabled = !serverEnabled || !isAffordable;

      // ë¹„í™œì„±í™” ì‚¬ìœ  ê²°ì •
      let finalDisabledReason: string | null = null;
      if (!serverEnabled && card.disabled_reason) {
        finalDisabledReason = card.disabled_reason;
      } else if (!isAffordable) {
        finalDisabledReason = t('action.insufficient_balance');
      }

      return {
        ...card,
        isAffordable,
        isDisabled,
        finalDisabledReason,
      };
    });
  }, [displayCards, currentBalance, t]);

  // ì¼ë°˜ ì¹´ë“œì™€ ëŒ€ì•ˆ ì¹´ë“œ ë¶„ë¦¬ (ëŒ€ì•ˆ ì¹´ë“œëŠ” ë’¤ì— ë°°ì¹˜)
  const sortedCards = useMemo(() => {
    const regular = processedCards.filter((c) => !c.is_alternative);
    const alternatives = processedCards.filter((c) => c.is_alternative);
    return [...regular, ...alternatives];
  }, [processedCards]);

  return (
    <div className="action-deck" role="group" aria-label={t('action.deck_label')}>
      {sortedCards.map((card) => (
        <ActionCardItem
          key={card.id}
          card={card}
          onClick={() => onCardClick?.(card)}
          onHover={handleCardHover}
          disabled={disabled}
        />
      ))}

      {/* ëª¨ë“  ì¹´ë“œê°€ ë¹„í™œì„±í™”ë˜ì—ˆì„ ë•Œ ì•ˆë‚´ */}
      {sortedCards.every((c) => c.isDisabled) && !disabled && (
        <div className="deck-empty-notice">{t('action.all_disabled_notice')}</div>
      )}
    </div>
  );
}

export default ActionDeck;
</file>

<file path="frontend/src/components/AgentConsole.tsx">
/**
 * Unknown World - Agent Console ì»´í¬ë„ŒíŠ¸.
 *
 * ì—ì´ì „íŠ¸í˜• ì‹œìŠ¤í…œì„ì„ UIë¡œ ì¦ëª…í•˜ê¸° ìœ„í•œ ì»´í¬ë„ŒíŠ¸ì…ë‹ˆë‹¤.
 * Plan/Queue/Badges/Auto-repair íŠ¸ë ˆì´ìŠ¤ë¥¼ ì‹¤ì‹œê°„ìœ¼ë¡œ í‘œì‹œí•©ë‹ˆë‹¤.
 *
 * ì„¤ê³„ ì›ì¹™:
 *   - RULE-008: ë‹¨ê³„/ë°°ì§€/ë³µêµ¬ë§Œ ë³´ì—¬ì¤Œ (í”„ë¡¬í”„íŠ¸/ë‚´ë¶€ ì¶”ë¡  ë…¸ì¶œ ê¸ˆì§€)
 *   - RULE-002: ê²Œì„ UIë¡œ í‘œí˜„ (ì±„íŒ… ë²„ë¸” ê¸ˆì§€)
 *
 * @module components/AgentConsole
 */

import { useTranslation } from 'react-i18next';
import {
  useAgentStore,
  selectIsStreaming,
  selectPhases,
  selectBadges,
  selectRepairCount,
  selectError,
  type PhaseInfo,
} from '../stores/agentStore';
import type { ValidationBadge } from '../schemas/turn';

// =============================================================================
// ìƒìˆ˜ ì •ì˜
// =============================================================================

/** ë‹¨ê³„ í‘œì‹œ ì´ë¦„ i18n í‚¤ */
const PHASE_KEYS: Record<string, string> = {
  parse: 'agent.console.phase.parse',
  validate: 'agent.console.phase.validate',
  plan: 'agent.console.phase.plan',
  resolve: 'agent.console.phase.resolve',
  render: 'agent.console.phase.render',
  verify: 'agent.console.phase.verify',
  commit: 'agent.console.phase.commit',
};

/** ë°°ì§€ í‘œì‹œ ì •ë³´ (i18n í‚¤ ê¸°ë°˜) */
const BADGE_INFO: Record<ValidationBadge, { labelKey: string; isOk: boolean }> = {
  schema_ok: { labelKey: 'agent.console.badge.schema', isOk: true },
  schema_fail: { labelKey: 'agent.console.badge.schema', isOk: false },
  economy_ok: { labelKey: 'agent.console.badge.economy', isOk: true },
  economy_fail: { labelKey: 'agent.console.badge.economy', isOk: false },
  safety_ok: { labelKey: 'agent.console.badge.safety', isOk: true },
  safety_blocked: { labelKey: 'agent.console.badge.safety', isOk: false },
  consistency_ok: { labelKey: 'agent.console.badge.consistency', isOk: true },
  consistency_fail: { labelKey: 'agent.console.badge.consistency', isOk: false },
};

// =============================================================================
// í•˜ìœ„ ì»´í¬ë„ŒíŠ¸
// =============================================================================

/** ë‹¨ê³„ ìƒíƒœ ì•„ì´ì½˜ */
function PhaseIcon({ status }: { status: PhaseInfo['status'] }) {
  switch (status) {
    case 'pending':
      return <span className="phase-icon pending">â—‹</span>;
    case 'in_progress':
      return <span className="phase-icon in-progress">â—</span>;
    case 'completed':
      return <span className="phase-icon completed">â—</span>;
    case 'failed':
      return <span className="phase-icon failed">âœ•</span>;
    default:
      return <span className="phase-icon">â—‹</span>;
  }
}

/** ë‹¨ê³„ í í•­ëª© */
function PhaseQueueItem({ phase }: { phase: PhaseInfo }) {
  const { t } = useTranslation();
  const key = PHASE_KEYS[phase.name];
  const label = key ? t(key) : phase.name;
  const statusClass = `phase-item ${phase.status}`;

  return (
    <div className={statusClass}>
      <PhaseIcon status={phase.status} />
      <span className="phase-label">{label}</span>
    </div>
  );
}

/** ë‹¨ê³„ í */
function PhaseQueue() {
  const { t } = useTranslation();
  const phases = useAgentStore(selectPhases);

  return (
    <div className="phase-queue">
      <div className="queue-label">{t('agent.console.queue')}</div>
      <div className="queue-items">
        {phases.map((phase) => (
          <PhaseQueueItem key={phase.name} phase={phase} />
        ))}
      </div>
    </div>
  );
}

/** ë°°ì§€ ì•„ì´í…œ */
function BadgeItem({ badge }: { badge: ValidationBadge }) {
  const { t } = useTranslation();
  const info = BADGE_INFO[badge];
  if (!info) return null;

  const statusClass = info.isOk ? 'badge-ok' : 'badge-fail';
  const statusText = info.isOk ? t('agent.console.badge.ok') : t('agent.console.badge.fail');
  const iconName = info.isOk ? 'badge-ok-24.png' : 'badge-fail-24.png';
  const fallbackIcon = info.isOk ? 'âœ“' : 'âœ—';

  return (
    <div className={`badge-item ${statusClass}`}>
      <span className="badge-label">{t(info.labelKey)}</span>
      <span className="badge-status">
        <span className="icon-wrapper">
          <img
            src={`/ui/icons/${iconName}`}
            alt=""
            aria-hidden="true"
            className="badge-icon-img"
            onError={(e) => e.currentTarget.classList.add('hidden')}
          />
          <span className="icon-fallback" style={{ fontSize: '0.625rem' }}>
            {fallbackIcon}
          </span>
        </span>
        {statusText}
      </span>
    </div>
  );
}

/** ë°°ì§€ íŒ¨ë„ */
function BadgesPanel() {
  const { t } = useTranslation();
  const badges = useAgentStore(selectBadges);

  if (badges.length === 0) {
    return (
      <div className="badges-panel">
        <div className="badges-label">{t('agent.console.badges')}</div>
        <div className="badges-empty">{t('agent.console.badges_empty')}</div>
      </div>
    );
  }

  return (
    <div className="badges-panel">
      <div className="badges-label">{t('agent.console.badges')}</div>
      <div className="badges-grid">
        {badges.map((badge, index) => (
          <BadgeItem key={`${badge}-${index}`} badge={badge} />
        ))}
      </div>
    </div>
  );
}

/** Auto-repair íŠ¸ë ˆì´ìŠ¤ */
function RepairTrace() {
  const { t } = useTranslation();
  const repairCount = useAgentStore(selectRepairCount);
  const isStreaming = useAgentStore(selectIsStreaming);

  if (repairCount === 0 && !isStreaming) {
    return null;
  }

  return (
    <div className="repair-trace">
      <span className="repair-label">{t('agent.console.repair')}</span>
      <span className="repair-count">#{repairCount}</span>
      {repairCount > 0 && (
        <span className="repair-status text-warning"> {t('agent.console.repaired')}</span>
      )}
    </div>
  );
}

/** ì—ëŸ¬ í‘œì‹œ */
function ErrorDisplay() {
  const error = useAgentStore(selectError);

  if (!error) return null;

  return (
    <div className="agent-error">
      <span className="error-icon">âš </span>
      <span className="error-message">{error.message}</span>
      {error.code && <span className="error-code">[{error.code}]</span>}
    </div>
  );
}

/** ìŠ¤íŠ¸ë¦¬ë° ìƒíƒœ í‘œì‹œ */
function StreamingStatus() {
  const { t } = useTranslation();
  const isStreaming = useAgentStore(selectIsStreaming);

  return (
    <div className="streaming-status">
      <span className={`status-dot ${isStreaming ? 'active' : ''}`} />
      <span className="status-text">
        {isStreaming ? t('agent.console.status.processing') : t('agent.console.status.idle')}
      </span>
    </div>
  );
}

// =============================================================================
// ë©”ì¸ ì»´í¬ë„ŒíŠ¸
// =============================================================================

/**
 * Agent Console ì»´í¬ë„ŒíŠ¸.
 *
 * Plan/Queue/Badges/Auto-repairë¥¼ ì‹¤ì‹œê°„ìœ¼ë¡œ í‘œì‹œí•©ë‹ˆë‹¤.
 * RULE-008ì— ë”°ë¼ í”„ë¡¬í”„íŠ¸/ë‚´ë¶€ ì¶”ë¡ ì€ ë…¸ì¶œí•˜ì§€ ì•ŠìŠµë‹ˆë‹¤.
 *
 * U-037: data-ui-importance="critical" ë§ˆí‚¹ìœ¼ë¡œ ê°€ë…ì„± ë³´ì¥
 */
export function AgentConsole() {
  return (
    <div className="agent-console-content" data-ui-importance="critical">
      <StreamingStatus />
      <PhaseQueue />
      <BadgesPanel />
      <RepairTrace />
      <ErrorDisplay />
    </div>
  );
}

export default AgentConsole;
</file>

<file path="frontend/src/components/SceneCanvas.hotspot.test.tsx">
import { describe, it, expect, vi, beforeEach } from 'vitest';
import { render, screen, fireEvent, act } from '@testing-library/react';
import { SceneCanvas } from './SceneCanvas';
import type { SceneObject } from '../schemas/turn';
import type { SceneCanvasState } from '../types/scene';
import { useWorldStore } from '../stores/worldStore';
import { useAgentStore } from '../stores/agentStore';

// i18next ëª¨í‚¹
vi.mock('react-i18next', () => ({
  useTranslation: () => ({
    t: (key: string) => key,
  }),
}));

// ResizeObserver ëª¨í‚¹
let resizeCallback: (entries: ResizeObserverEntry[]) => void;
class MockResizeObserver {
  constructor(callback: (entries: ResizeObserverEntry[]) => void) {
    resizeCallback = callback;
  }
  observe = vi.fn();
  unobserve = vi.fn();
  disconnect = vi.fn();
}

global.ResizeObserver = MockResizeObserver as unknown as typeof ResizeObserver;

/**
 * ë¦¬ì‚¬ì´ì¦ˆ ì´ë²¤íŠ¸ë¥¼ ìˆ˜ë™ìœ¼ë¡œ íŠ¸ë¦¬ê±°í•©ë‹ˆë‹¤.
 */
function triggerResize(width: number, height: number) {
  if (resizeCallback) {
    act(() => {
      resizeCallback([
        {
          contentRect: { width, height } as DOMRectReadOnly,
          target: document.querySelector('.scene-canvas') as Element,
        } as ResizeObserverEntry,
      ]);
    });
  }
}

// getBoundingClientRect ëª¨í‚¹
Element.prototype.getBoundingClientRect = vi.fn(() => ({
  width: 800,
  height: 600,
  top: 0,
  left: 0,
  bottom: 600,
  right: 800,
  x: 0,
  y: 0,
  toJSON: () => {},
})) as unknown as () => DOMRect;

describe('SceneCanvas Hotspots', () => {
  const defaultState: SceneCanvasState = {
    status: 'scene',
    imageUrl: 'https://example.com/scene.png',
  };

  const mockObjects: SceneObject[] = [
    {
      id: 'obj-1',
      label: 'Object 1',
      box_2d: { ymin: 100, xmin: 100, ymax: 200, xmax: 200 },
      interaction_hint: 'Click me',
    },
    {
      id: 'obj-2',
      label: 'Object 2',
      box_2d: { ymin: 500, xmin: 500, ymax: 700, xmax: 700 },
      interaction_hint: null,
    },
  ];

  beforeEach(() => {
    vi.clearAllMocks();
    // ìŠ¤í† ì–´ ì´ˆê¸°í™”
    useWorldStore.setState({
      sceneState: { status: 'default', message: '' },
      sceneObjects: [],
    });
    useAgentStore.setState({ isStreaming: false });
  });

  it('should render hotspots when objects are provided in worldStore and status is scene (sorted by area)', () => {
    useWorldStore.setState({
      sceneState: defaultState,
      sceneObjects: mockObjects,
    });

    render(<SceneCanvas />);

    // í•«ìŠ¤íŒŸ ë ˆì´ì–´ í™•ì¸
    const layer = screen.getByLabelText('scene.hotspot.layer_label');
    expect(layer).toBeInTheDocument();

    // ê°œë³„ í•«ìŠ¤íŒŸ í™•ì¸ (role="button")
    // RU-003-S2: ë©´ì  ê¸°ë°˜ ì •ë ¬ - í° ê²ƒì´ ë¨¼ì € ë Œë”ë§ë˜ì–´ ë‚®ì€ z-indexë¥¼ ê°€ì§
    // Object 1: 100x100 = 10,000
    // Object 2: 200x200 = 40,000
    // ë”°ë¼ì„œ Object 2ê°€ ë¨¼ì € ì˜¤ê³  Object 1ì´ ë‚˜ì¤‘ì— ì˜´
    const buttons = screen.getAllByRole('button');
    expect(buttons).toHaveLength(mockObjects.length);
    expect(buttons[0]).toHaveAttribute('aria-label', 'Object 2');
    expect(buttons[1]).toHaveAttribute('aria-label', 'Object 1');

    // z-index í™•ì¸ (RU-003-S2: HotspotOverlay ìì²´ì— styleë¡œ ì ìš©ë¨)
    expect(buttons[0]).toHaveStyle({ zIndex: '1' });
    expect(buttons[1]).toHaveStyle({ zIndex: '2' });
  });

  it('should not render hotspots when status is loading', () => {
    useWorldStore.setState({
      sceneState: { status: 'loading' },
      sceneObjects: mockObjects,
    });

    render(<SceneCanvas />);

    const layer = screen.queryByLabelText('scene.hotspot.layer_label');
    expect(layer).not.toBeInTheDocument();
  });

  it('should call onHotspotClick when a hotspot is clicked', () => {
    const onHotspotClick = vi.fn();
    useWorldStore.setState({
      sceneState: defaultState,
      sceneObjects: mockObjects,
    });

    render(<SceneCanvas onHotspotClick={onHotspotClick} />);

    const firstHotspot = screen.getByLabelText('Object 1');
    fireEvent.click(firstHotspot);

    expect(onHotspotClick).toHaveBeenCalledWith({
      object_id: 'obj-1',
      box_2d: mockObjects[0].box_2d,
    });
  });

  it('should show tooltip on hover', async () => {
    useWorldStore.setState({
      sceneState: defaultState,
      sceneObjects: mockObjects,
    });

    render(<SceneCanvas />);

    const firstHotspot = screen.getByLabelText('Object 1');

    // Hover ì‹œì‘
    fireEvent.mouseEnter(firstHotspot);

    // íˆ´íŒ ë¼ë²¨ í™•ì¸
    expect(screen.getByText('Object 1')).toBeInTheDocument();
    expect(screen.getByText(/scene.hotspot.hint_prefix/)).toBeInTheDocument();
    expect(screen.getByText(/Click me/)).toBeInTheDocument();

    // Hover ì¢…ë£Œ
    fireEvent.mouseLeave(firstHotspot);
    expect(screen.queryByText('Object 1')).not.toBeInTheDocument();
  });

  it('should be disabled when agentStore.isStreaming is true', () => {
    const onHotspotClick = vi.fn();
    useWorldStore.setState({
      sceneState: defaultState,
      sceneObjects: mockObjects,
    });
    useAgentStore.setState({ isStreaming: true });

    render(<SceneCanvas onHotspotClick={onHotspotClick} />);

    const firstHotspot = screen.getByLabelText('Object 1');
    expect(firstHotspot).toHaveAttribute('aria-disabled', 'true');
    expect(firstHotspot).toHaveAttribute('tabindex', '-1');

    fireEvent.click(firstHotspot);
    expect(onHotspotClick).not.toHaveBeenCalled();
  });

  it('should reposition hotspots when canvas size changes (reactive resize)', async () => {
    vi.useFakeTimers();
    useWorldStore.setState({
      sceneState: defaultState,
      sceneObjects: mockObjects,
    });

    render(<SceneCanvas />);

    // Object 1 ì°¾ê¸° (ì •ë ¬ì— ì˜í•´ ë‘ ë²ˆì§¸ ë²„íŠ¼ì¼ ìˆ˜ ìˆìŒ)
    const firstHotspot = screen.getByLabelText('Object 1');

    // ì´ˆê¸° í¬ê¸° (800x600) ê¸°ë°˜ ìœ„ì¹˜ í™•ì¸
    expect(firstHotspot).toHaveStyle({
      top: '60px',
      left: '80px',
      width: '80px',
      height: '60px',
    });

    // í¬ê¸° ë³€ê²½ íŠ¸ë¦¬ê±° (400x300)
    triggerResize(400, 300);

    // RU-003-S2: ResizeObserver ë””ë°”ìš´ìŠ¤(100ms) ëŒ€ê¸°
    act(() => {
      vi.advanceTimersByTime(150);
    });

    // ë³€ê²½ëœ í¬ê¸° ê¸°ë°˜ ìœ„ì¹˜ í™•ì¸
    expect(firstHotspot).toHaveStyle({
      top: '30px',
      left: '40px',
      width: '40px',
      height: '30px',
    });

    vi.useRealTimers();
  });
});
</file>

<file path="frontend/src/save/saveGame.ts">
/**
 * Unknown World - SaveGame ì €ì¥/ë³µì› ëª¨ë“ˆ (U-015[Mvp]).
 *
 * ë¡œê·¸ì¸ ì—†ì´ ì¦‰ì‹œ ì‹œì‘ ê°€ëŠ¥í•œ ë°ëª¨ í”„ë¡œí•„ê³¼ ì„¸ì´ë¸Œ/ë¡œë“œ ê¸°ëŠ¥ì„ ì œê³µí•©ë‹ˆë‹¤.
 * DB ì—†ì´ SaveGame JSON ì§ë ¬í™” ê¸°ë°˜ìœ¼ë¡œ localStorageì— ì €ì¥í•©ë‹ˆë‹¤.
 *
 * ì„¤ê³„ ì›ì¹™:
 *   - RULE-010: DB/ORM ë„ì… ê¸ˆì§€ (SaveGame JSON ì§ë ¬í™” ê¸°ë°˜)
 *   - RULE-006: language í•„ë“œë¡œ ko/en í˜¼í•© ë°©ì§€
 *   - Q1 ê²°ì •: Option A - localStorage ì‚¬ìš© (ë‹¨ìˆœ/ë°ëª¨ ì í•©)
 *   - RU-004-Q5: ìƒìˆ˜ëŠ” constants.tsì—ì„œ ì¤‘ì•™ ê´€ë¦¬
 *
 * @module save/saveGame
 */

import { z } from 'zod';
import type { SupportedLanguage } from '../i18n';
import type { LedgerEntry } from '../stores/economyStore';
import type { Quest, WorldRule } from '../schemas/turn';
import type { InventoryItem } from '../stores/inventoryStore';
import type { MutationEvent, NarrativeEntry, EconomyState } from '../stores/worldStore';
import type { SceneObject } from '../schemas/turn';

// RU-004-Q5: ìƒìˆ˜ ì¤‘ì•™í™” - constants.tsì—ì„œ import
import { SAVEGAME_VERSION, SAVEGAME_STORAGE_KEY, CURRENT_PROFILE_KEY } from './constants';

// RU-004-Q5: ìƒìˆ˜ re-export (ê¸°ì¡´ í˜¸ì¶œì í˜¸í™˜ì„± ìœ ì§€)
export { SAVEGAME_VERSION, SAVEGAME_STORAGE_KEY, CURRENT_PROFILE_KEY };

// =============================================================================
// SaveGame ìŠ¤í‚¤ë§ˆ ì •ì˜
// =============================================================================

/**
 * SaveGame Zod ìŠ¤í‚¤ë§ˆ.
 * ìµœì†Œ í•„ë“œë§Œ í¬í•¨í•˜ì—¬ MVP ìš”êµ¬ì‚¬í•­ì„ ì¶©ì¡±í•©ë‹ˆë‹¤.
 */
export const SaveGameSchema = z
  .object({
    /** ìŠ¤í‚¤ë§ˆ ë²„ì „ (ë§ˆì´ê·¸ë ˆì´ì…˜ìš©) */
    version: z.string().describe('SaveGame ìŠ¤í‚¤ë§ˆ ë²„ì „'),
    /** ì„¸ì…˜ ì‹œë“œ (ë¦¬í”Œë ˆì´ ì¬í˜„ìš©, ì„ íƒ) */
    seed: z.string().nullable().default(null).describe('ì„¸ì…˜ ì‹œë“œ'),
    /** ì–¸ì–´ ì„¤ì • (RULE-006: ë³µì› ì‹œ UI i18nì—ë„ ì ìš©) */
    language: z.enum(['ko-KR', 'en-US']).describe('ì–¸ì–´ ì„¤ì •'),
    /** ì‚¬ìš©ëœ ë°ëª¨ í”„ë¡œí•„ ID */
    profileId: z.string().nullable().default(null).describe('ë°ëª¨ í”„ë¡œí•„ ID'),
    /** ì €ì¥ ì‹œê° (ISO 8601) */
    savedAt: z.string().describe('ì €ì¥ ì‹œê°'),

    /** ì¬í™” ìƒíƒœ */
    economy: z
      .object({
        signal: z.number().int().min(0),
        memory_shard: z.number().int().min(0),
      })
      .describe('ì¬í™” ìƒíƒœ'),

    /** ê²½ì œ ì›ì¥ ì´ë ¥ */
    economyLedger: z
      .array(
        z.object({
          turnId: z.number().int(),
          actionId: z.string().optional(),
          reason: z.string(),
          cost: z.object({
            signal: z.number().int().min(0),
            memory_shard: z.number().int().min(0),
          }),
          balanceAfter: z.object({
            signal: z.number().int().min(0),
            memory_shard: z.number().int().min(0),
          }),
          modelLabel: z.enum(['FAST', 'QUALITY', 'CHEAP', 'REF']).optional(),
          timestamp: z.number(),
        }),
      )
      .default([])
      .describe('ê²½ì œ ì›ì¥ ì´ë ¥'),

    /** í˜„ì¬ í„´ ì¹´ìš´íŠ¸ */
    turnCount: z.number().int().min(0).default(0).describe('í˜„ì¬ í„´ ì¹´ìš´íŠ¸'),

    /** ë‚´ëŸ¬í‹°ë¸Œ íˆìŠ¤í† ë¦¬ */
    narrativeHistory: z
      .array(
        z.object({
          turn: z.number().int(),
          text: z.string(),
        }),
      )
      .default([])
      .describe('ë‚´ëŸ¬í‹°ë¸Œ íˆìŠ¤í† ë¦¬'),

    /** ì¸ë²¤í† ë¦¬ ì•„ì´í…œ */
    inventory: z
      .array(
        z.object({
          id: z.string(),
          name: z.string(),
          description: z.string().optional(),
          icon: z.string().optional(),
          quantity: z.number().int().min(1),
        }),
      )
      .default([])
      .describe('ì¸ë²¤í† ë¦¬ ì•„ì´í…œ'),

    /** í™œì„± í€˜ìŠ¤íŠ¸ */
    quests: z
      .array(
        z.object({
          id: z.string(),
          label: z.string(),
          is_completed: z.boolean().default(false),
        }),
      )
      .default([])
      .describe('í™œì„± í€˜ìŠ¤íŠ¸'),

    /** í™œì„± ê·œì¹™ */
    activeRules: z
      .array(
        z.object({
          id: z.string(),
          label: z.string(),
          description: z.string().nullable().default(null),
        }),
      )
      .default([])
      .describe('í™œì„± ê·œì¹™'),

    /** ë£° ë³€í˜• íƒ€ì„ë¼ì¸ */
    mutationTimeline: z
      .array(
        z.object({
          turn: z.number().int(),
          ruleId: z.string(),
          type: z.enum(['added', 'modified', 'removed']),
          label: z.string(),
          description: z.string().optional(),
          timestamp: z.number(),
        }),
      )
      .default([])
      .describe('ë£° ë³€í˜• íƒ€ì„ë¼ì¸'),

    /** Scene Objects (í•«ìŠ¤íŒŸ) */
    sceneObjects: z
      .array(
        z.object({
          id: z.string(),
          label: z.string(),
          box_2d: z.object({
            ymin: z.number().int().min(0).max(1000),
            xmin: z.number().int().min(0).max(1000),
            ymax: z.number().int().min(0).max(1000),
            xmax: z.number().int().min(0).max(1000),
          }),
          interaction_hint: z.string().nullable().default(null),
        }),
      )
      .default([])
      .describe('Scene Objects'),
  })
  .strict();

export type SaveGame = z.infer<typeof SaveGameSchema>;

// =============================================================================
// ì €ì¥/ë³µì› í•¨ìˆ˜
// =============================================================================

/**
 * SaveGame ì¸í„°í˜ì´ìŠ¤ (ì €ì¥í•  ìƒíƒœ ì „ì²´ë¥¼ ìº¡ì²˜).
 */
export interface SaveGameInput {
  language: SupportedLanguage;
  profileId?: string | null;
  seed?: string | null;
  economy: EconomyState;
  economyLedger: LedgerEntry[];
  turnCount: number;
  narrativeHistory: NarrativeEntry[];
  inventory: InventoryItem[];
  quests: Quest[];
  activeRules: WorldRule[];
  mutationTimeline: MutationEvent[];
  sceneObjects: SceneObject[];
}

/**
 * í˜„ì¬ ìƒíƒœë¥¼ SaveGame ê°ì²´ë¡œ ì§ë ¬í™”í•©ë‹ˆë‹¤.
 */
export function createSaveGame(input: SaveGameInput): SaveGame {
  return {
    version: SAVEGAME_VERSION,
    seed: input.seed ?? null,
    language: input.language,
    profileId: input.profileId ?? null,
    savedAt: new Date().toISOString(),
    economy: {
      signal: input.economy.signal,
      memory_shard: input.economy.memory_shard,
    },
    economyLedger: input.economyLedger.map((entry) => ({
      turnId: entry.turnId,
      actionId: entry.actionId,
      reason: entry.reason,
      cost: {
        signal: entry.cost.signal,
        memory_shard: entry.cost.memory_shard,
      },
      balanceAfter: {
        signal: entry.balanceAfter.signal,
        memory_shard: entry.balanceAfter.memory_shard,
      },
      modelLabel: entry.modelLabel,
      timestamp: entry.timestamp,
    })),
    turnCount: input.turnCount,
    narrativeHistory: input.narrativeHistory.map((entry) => ({
      turn: entry.turn,
      text: entry.text,
    })),
    inventory: input.inventory.map((item) => ({
      id: item.id,
      name: item.name,
      description: item.description,
      icon: item.icon,
      quantity: item.quantity,
    })),
    quests: input.quests.map((quest) => ({
      id: quest.id,
      label: quest.label,
      is_completed: quest.is_completed,
    })),
    activeRules: input.activeRules.map((rule) => ({
      id: rule.id,
      label: rule.label,
      description: rule.description,
    })),
    mutationTimeline: input.mutationTimeline.map((event) => ({
      turn: event.turn,
      ruleId: event.ruleId,
      type: event.type,
      label: event.label,
      description: event.description,
      timestamp: event.timestamp,
    })),
    sceneObjects: input.sceneObjects.map((obj) => ({
      id: obj.id,
      label: obj.label,
      box_2d: {
        ymin: obj.box_2d.ymin,
        xmin: obj.box_2d.xmin,
        ymax: obj.box_2d.ymax,
        xmax: obj.box_2d.xmax,
      },
      interaction_hint: obj.interaction_hint,
    })),
  };
}

/**
 * SaveGameì„ localStorageì— ì €ì¥í•©ë‹ˆë‹¤.
 *
 * @returns ì €ì¥ ì„±ê³µ ì—¬ë¶€
 */
export function saveSaveGame(saveGame: SaveGame): boolean {
  try {
    const json = JSON.stringify(saveGame);
    localStorage.setItem(SAVEGAME_STORAGE_KEY, json);
    return true;
  } catch (error) {
    console.error('[SaveGame] ì €ì¥ ì‹¤íŒ¨:', error);
    return false;
  }
}

/**
 * localStorageì—ì„œ SaveGameì„ ë¡œë“œí•©ë‹ˆë‹¤.
 * ë§ˆì´ê·¸ë ˆì´ì…˜ì´ í•„ìš”í•œ ê²½ìš° ìë™ìœ¼ë¡œ ì ìš©í•©ë‹ˆë‹¤ (RU-004-S2).
 *
 * @returns SaveGame ê°ì²´ ë˜ëŠ” null (ì—†ê±°ë‚˜ ìœ íš¨í•˜ì§€ ì•Šì€ ê²½ìš°)
 */
export function loadSaveGame(): SaveGame | null {
  try {
    const json = localStorage.getItem(SAVEGAME_STORAGE_KEY);
    if (!json) {
      return null;
    }

    const parsed = JSON.parse(json);
    const result = SaveGameSchema.safeParse(parsed);

    if (!result.success) {
      console.warn('[SaveGame] ìŠ¤í‚¤ë§ˆ ê²€ì¦ ì‹¤íŒ¨:', result.error);
      return null;
    }

    // RU-004-S2: ë²„ì „ ë§ˆì´ê·¸ë ˆì´ì…˜ ì ìš©
    const migrated = migrateSaveGame(result.data);
    if (!migrated) {
      console.warn('[SaveGame] ë§ˆì´ê·¸ë ˆì´ì…˜ ì‹¤íŒ¨, ìƒˆë¡œ ì‹œì‘ í•„ìš”');
      return null;
    }

    return migrated;
  } catch (error) {
    console.error('[SaveGame] ë¡œë“œ ì‹¤íŒ¨:', error);
    return null;
  }
}

/**
 * ì €ì¥ëœ SaveGameì„ ì‚­ì œí•©ë‹ˆë‹¤.
 */
export function clearSaveGame(): void {
  try {
    localStorage.removeItem(SAVEGAME_STORAGE_KEY);
  } catch (error) {
    console.error('[SaveGame] ì‚­ì œ ì‹¤íŒ¨:', error);
  }
}

/**
 * SaveGameì´ ì¡´ì¬í•˜ëŠ”ì§€ í™•ì¸í•©ë‹ˆë‹¤.
 *
 * @deprecated RU-004-S2: ì´ í•¨ìˆ˜ëŠ” í‚¤ ì¡´ì¬ë§Œ í™•ì¸í•˜ë¯€ë¡œ "ìœ íš¨í•œ ì„¸ì´ë¸Œ" íŒë‹¨ì— ë¶€ì í•©í•©ë‹ˆë‹¤.
 *             ëŒ€ì‹  `getValidSaveGameOrNull()`ì„ ì‚¬ìš©í•˜ì„¸ìš”.
 */
export function hasSaveGame(): boolean {
  try {
    return localStorage.getItem(SAVEGAME_STORAGE_KEY) !== null;
  } catch {
    return false;
  }
}

/**
 * ìœ íš¨í•œ SaveGameì„ ë°˜í™˜í•©ë‹ˆë‹¤. ì—†ê±°ë‚˜ ê²€ì¦/ë§ˆì´ê·¸ë ˆì´ì…˜ ì‹¤íŒ¨ ì‹œ nullì„ ë°˜í™˜í•©ë‹ˆë‹¤ (RU-004-S2).
 *
 * `hasSaveGame()` ëŒ€ì‹  ì´ í•¨ìˆ˜ë¥¼ ì‚¬ìš©í•˜ë©´ "Continue ë²„íŠ¼ ë…¸ì¶œ" íŒë‹¨ì´ ì •í™•í•´ì§‘ë‹ˆë‹¤:
 * - localStorageì— ë°ì´í„°ê°€ ìˆì–´ë„ ìŠ¤í‚¤ë§ˆ ê²€ì¦ ì‹¤íŒ¨ ì‹œ null ë°˜í™˜
 * - ë²„ì „ ë¶ˆì¼ì¹˜ë¡œ ë§ˆì´ê·¸ë ˆì´ì…˜ ì‹¤íŒ¨ ì‹œ null ë°˜í™˜
 *
 * @returns ìœ íš¨í•œ SaveGame ë˜ëŠ” null
 */
export function getValidSaveGameOrNull(): SaveGame | null {
  return loadSaveGame();
}

// =============================================================================
// í”„ë¡œí•„ ê´€ë ¨ ìœ í‹¸ë¦¬í‹°
// =============================================================================

/**
 * í˜„ì¬ ì„ íƒëœ í”„ë¡œí•„ IDë¥¼ ì €ì¥í•©ë‹ˆë‹¤.
 */
export function saveCurrentProfileId(profileId: string): void {
  try {
    localStorage.setItem(CURRENT_PROFILE_KEY, profileId);
  } catch (error) {
    console.error('[SaveGame] í”„ë¡œí•„ ID ì €ì¥ ì‹¤íŒ¨:', error);
  }
}

/**
 * í˜„ì¬ ì„ íƒëœ í”„ë¡œí•„ IDë¥¼ ë¡œë“œí•©ë‹ˆë‹¤.
 */
export function loadCurrentProfileId(): string | null {
  try {
    return localStorage.getItem(CURRENT_PROFILE_KEY);
  } catch {
    return null;
  }
}

/**
 * í˜„ì¬ ì„ íƒëœ í”„ë¡œí•„ IDë¥¼ ì‚­ì œí•©ë‹ˆë‹¤.
 */
export function clearCurrentProfileId(): void {
  try {
    localStorage.removeItem(CURRENT_PROFILE_KEY);
  } catch (error) {
    console.error('[SaveGame] í”„ë¡œí•„ ID ì‚­ì œ ì‹¤íŒ¨:', error);
  }
}

// =============================================================================
// ë²„ì „ ë§ˆì´ê·¸ë ˆì´ì…˜ (í–¥í›„ í™•ì¥)
// =============================================================================

/**
 * SaveGame ë²„ì „ì„ í™•ì¸í•˜ê³  í•„ìš” ì‹œ ë§ˆì´ê·¸ë ˆì´ì…˜í•©ë‹ˆë‹¤.
 * í˜„ì¬ëŠ” v1.0.0ë§Œ ì§€ì›í•˜ë¯€ë¡œ íŒ¨ìŠ¤ìŠ¤ë£¨ì…ë‹ˆë‹¤.
 *
 * @param saveGame - ë¡œë“œëœ SaveGame
 * @returns ë§ˆì´ê·¸ë ˆì´ì…˜ëœ SaveGame ë˜ëŠ” null (ë§ˆì´ê·¸ë ˆì´ì…˜ ë¶ˆê°€)
 */
export function migrateSaveGame(saveGame: SaveGame): SaveGame | null {
  // í˜„ì¬ ë²„ì „ì´ë©´ ê·¸ëŒ€ë¡œ ë°˜í™˜
  if (saveGame.version === SAVEGAME_VERSION) {
    return saveGame;
  }

  // í–¥í›„ ë²„ì „ ì—…ê·¸ë ˆì´ë“œ ì‹œ ë§ˆì´ê·¸ë ˆì´ì…˜ ë¡œì§ ì¶”ê°€
  console.warn(`[SaveGame] ë²„ì „ ë¶ˆì¼ì¹˜: ${saveGame.version} -> ${SAVEGAME_VERSION}`);

  // MVPì—ì„œëŠ” ë²„ì „ ë¶ˆì¼ì¹˜ ì‹œ null ë°˜í™˜ (ìƒˆë¡œ ì‹œì‘ ìœ ë„)
  return null;
}
</file>

<file path="frontend/src/stores/economyStore.ts">
/**
 * Unknown World - Economy ìƒíƒœ ê´€ë¦¬ (Zustand) (U-014[Mvp]).
 *
 * Signal/Memory Shard ì¬í™” HUDì™€ í„´ë³„ ë¹„ìš©/ì”ì•¡ ë³€í™”ë¥¼
 * **ì›ì¥(ledger)**ìœ¼ë¡œ ì¶”ì í•˜ì—¬ "ë¹„ìš©/ì§€ì—°ì„ ê²Œì„ ë©”ì»¤ë‹‰"ìœ¼ë¡œ UXì— ë°˜ì˜í•©ë‹ˆë‹¤.
 *
 * ì„¤ê³„ ì›ì¹™:
 *   - RULE-005: Economy ì¸ë°”ë¦¬ì–¸íŠ¸ (ì”ì•¡ ìŒìˆ˜ ê¸ˆì§€, ì˜ˆìƒ ë¹„ìš© ì‚¬ì „ í‘œì‹œ)
 *   - RULE-008: ë¹„ìš©/ëª¨ë¸ ì„ íƒ ì´ìœ ëŠ” ë¼ë²¨(FAST/QUALITY/REF)ë¡œë§Œ ì„¤ëª…
 *   - Q1 ê²°ì •: Option A - ìµœê·¼ Ní„´ë§Œ ë³´ê´€ (UI/ë©”ëª¨ë¦¬ ì ˆê°)
 *   - RU-004-Q5: ìƒìˆ˜ëŠ” save/constants.tsì—ì„œ ì¤‘ì•™ ê´€ë¦¬
 *
 * @module stores/economyStore
 */

import { create } from 'zustand';
import type { CurrencyAmount, ModelLabel, CostEstimate } from '../schemas/turn';
// RU-004-Q5: ìƒìˆ˜ ì¤‘ì•™í™” - constants.tsì—ì„œ import
import { LEDGER_MAX_ENTRIES, LOW_BALANCE_THRESHOLD } from '../save/constants';

// RU-004-Q5: ìƒìˆ˜ re-export (ê¸°ì¡´ í˜¸ì¶œì í˜¸í™˜ì„± ìœ ì§€)
export { LEDGER_MAX_ENTRIES };

// =============================================================================
// íƒ€ì… ì •ì˜
// =============================================================================

/**
 * ì›ì¥(Ledger) ì—”íŠ¸ë¦¬.
 * ê° í„´ì—ì„œ ë°œìƒí•œ ë¹„ìš©ê³¼ ì”ì•¡ ë³€í™”ë¥¼ ê¸°ë¡í•©ë‹ˆë‹¤.
 */
export interface LedgerEntry {
  /** í„´ ID (í„´ ì¹´ìš´íŠ¸) */
  turnId: number;
  /** ì•¡ì…˜ ID (ì„ íƒëœ ì¹´ë“œ ID, ì„ íƒì‚¬í•­) */
  actionId?: string;
  /** ë¹„ìš© ì‚¬ìœ  (ì˜ˆ: "íƒìƒ‰", "ì´ë¯¸ì§€ ìƒì„±") */
  reason: string;
  /** ì†Œë¹„ëœ ë¹„ìš© */
  cost: CurrencyAmount;
  /** ì†Œë¹„ í›„ ì”ì•¡ */
  balanceAfter: CurrencyAmount;
  /** ëª¨ë¸ ë¼ë²¨ (FAST/QUALITY/CHEAP/REF) */
  modelLabel?: ModelLabel;
  /** ê¸°ë¡ ì‹œê°„ */
  timestamp: number;
}

/**
 * ì˜ˆìƒ ë¹„ìš© ìƒíƒœ.
 * í˜„ì¬ ì„ íƒëœ ì•¡ì…˜ì˜ ì˜ˆìƒ ë¹„ìš©ì„ ì¶”ì í•©ë‹ˆë‹¤.
 */
export interface CostEstimateState {
  /** ìµœì†Œ ì˜ˆìƒ ë¹„ìš© */
  min: CurrencyAmount;
  /** ìµœëŒ€ ì˜ˆìƒ ë¹„ìš© */
  max: CurrencyAmount;
  /** ì˜ˆìƒ ë¹„ìš©ì„ ê³„ì‚°í•œ ì•¡ì…˜ ID */
  actionId?: string;
  /** ì˜ˆìƒ ë¹„ìš© ë¼ë²¨/ì„¤ëª… */
  label?: string;
}

/**
 * ë§ˆì§€ë§‰ í™•ì • ë¹„ìš© ìƒíƒœ.
 * ê°€ì¥ ìµœê·¼ í„´ì—ì„œ í™•ì •ëœ ë¹„ìš© ì •ë³´ì…ë‹ˆë‹¤.
 */
export interface LastCostState {
  /** í™•ì •ëœ ë¹„ìš© */
  cost: CurrencyAmount;
  /** í™•ì • í›„ ì”ì•¡ */
  balanceAfter: CurrencyAmount;
  /** í„´ ID */
  turnId: number;
  /** ëª¨ë¸ ë¼ë²¨ */
  modelLabel?: ModelLabel;
}

/** Economy Store ìƒíƒœ */
export interface EconomyStoreState {
  /** ì›ì¥ (ìµœê·¼ Nê°œ ì—”íŠ¸ë¦¬, ìµœì‹ ìˆœ) */
  ledger: LedgerEntry[];
  /** í˜„ì¬ ì˜ˆìƒ ë¹„ìš© (ì„ íƒí•œ ì•¡ì…˜ ê¸°ë°˜) */
  costEstimate: CostEstimateState | null;
  /** ë§ˆì§€ë§‰ í™•ì • ë¹„ìš© */
  lastCost: LastCostState | null;
  /** ì”ì•¡ ë¶€ì¡± ê²½ê³  ì—¬ë¶€ */
  isBalanceLow: boolean;
  /** ì”ì•¡ ë¶€ì¡± ì„ê³„ê°’ (Signal ê¸°ì¤€) */
  lowBalanceThreshold: number;
}

/** Economy Store ì•¡ì…˜ */
export interface EconomyStoreActions {
  /**
   * í„´ ì™„ë£Œ ì‹œ ì›ì¥ì— ì—”íŠ¸ë¦¬ë¥¼ ì¶”ê°€í•©ë‹ˆë‹¤.
   */
  addLedgerEntry: (entry: Omit<LedgerEntry, 'timestamp'>) => void;

  /**
   * SaveGame ë³µì› ì‹œ ì›ì¥ì„ ê·¸ëŒ€ë¡œ ì£¼ì…í•©ë‹ˆë‹¤ (RU-004-S1).
   *
   * - ledgerëŠ” ì €ì¥ëœ ìˆœì„œ(ìµœì‹ ìˆœ)ë¥¼ ìœ ì§€í•©ë‹ˆë‹¤.
   * - timestampëŠ” ì €ì¥ëœ ê°’ì„ ë³´ì¡´í•©ë‹ˆë‹¤.
   * - lastCostëŠ” ìµœì‹  ì—”íŠ¸ë¦¬(ì²« ì›ì†Œ) ê¸°ì¤€ìœ¼ë¡œ ì„¤ì •í•©ë‹ˆë‹¤.
   * - isBalanceLowëŠ” ì „ë‹¬ëœ currentBalanceë¡œ ì¬ê³„ì‚°í•©ë‹ˆë‹¤.
   *
   * @param ledger - ì €ì¥ëœ ì›ì¥ ë°°ì—´ (ìµœì‹ ìˆœ, timestamp í¬í•¨)
   * @param currentBalance - ë³µì›ëœ ì”ì•¡ (isBalanceLow ê³„ì‚°ìš©)
   */
  hydrateLedger: (ledger: LedgerEntry[], currentBalance: CurrencyAmount) => void;

  /**
   * ì˜ˆìƒ ë¹„ìš©ì„ ì„¤ì •í•©ë‹ˆë‹¤ (ì¹´ë“œ ì„ íƒ/í˜¸ë²„ ì‹œ).
   */
  setCostEstimate: (estimate: CostEstimateState | null) => void;

  /**
   * ì¹´ë“œì˜ ë¹„ìš© ì •ë³´ë¡œ ì˜ˆìƒ ë¹„ìš©ì„ ì„¤ì •í•©ë‹ˆë‹¤.
   */
  setCostEstimateFromCard: (
    cost: CurrencyAmount,
    costEstimate: CostEstimate | null,
    actionId: string,
    label?: string,
  ) => void;

  /**
   * ë§ˆì§€ë§‰ í™•ì • ë¹„ìš©ì„ ì„¤ì •í•©ë‹ˆë‹¤ (TurnOutput ë°˜ì˜ ì‹œ).
   */
  setLastCost: (lastCost: LastCostState) => void;

  /**
   * ì”ì•¡ ë¶€ì¡± ìƒíƒœë¥¼ ì—…ë°ì´íŠ¸í•©ë‹ˆë‹¤.
   */
  updateBalanceLowStatus: (currentBalance: CurrencyAmount) => void;

  /**
   * ì”ì•¡ ë¶€ì¡± ì„ê³„ê°’ì„ ì„¤ì •í•©ë‹ˆë‹¤.
   */
  setLowBalanceThreshold: (threshold: number) => void;

  /**
   * ì›ì¥ì„ ì´ˆê¸°í™”í•©ë‹ˆë‹¤.
   */
  clearLedger: () => void;

  /**
   * ì „ì²´ ìƒíƒœë¥¼ ì´ˆê¸°í™”í•©ë‹ˆë‹¤.
   */
  reset: () => void;
}

export type EconomyStore = EconomyStoreState & EconomyStoreActions;

// =============================================================================
// ì´ˆê¸° ìƒíƒœ
// =============================================================================

function createInitialState(): EconomyStoreState {
  return {
    ledger: [],
    costEstimate: null,
    lastCost: null,
    isBalanceLow: false,
    // RU-004-Q5: ì„ê³„ê°’ ìƒìˆ˜ SSOT (save/constants.ts)
    lowBalanceThreshold: LOW_BALANCE_THRESHOLD,
  };
}

// =============================================================================
// Zustand Store
// =============================================================================

/**
 * Economy ìƒíƒœ ìŠ¤í† ì–´.
 *
 * í„´ë³„ ë¹„ìš©/ì”ì•¡ ë³€í™”ë¥¼ ì›ì¥(ledger)ìœ¼ë¡œ ì¶”ì í•˜ê³ ,
 * ì˜ˆìƒ ë¹„ìš©ê³¼ í™•ì • ë¹„ìš©ì„ UIì— ì œê³µí•©ë‹ˆë‹¤.
 *
 * @example
 * ```tsx
 * // ì˜ˆìƒ ë¹„ìš© ì„¤ì • (ì¹´ë“œ í˜¸ë²„ ì‹œ)
 * const setCostEstimateFromCard = useEconomyStore(s => s.setCostEstimateFromCard);
 * setCostEstimateFromCard(card.cost, card.cost_estimate, card.id, card.label);
 *
 * // í„´ ì™„ë£Œ ì‹œ ì›ì¥ ê¸°ë¡
 * const addLedgerEntry = useEconomyStore(s => s.addLedgerEntry);
 * addLedgerEntry({
 *   turnId: turnCount,
 *   reason: 'explore',
 *   cost: turnOutput.economy.cost,
 *   balanceAfter: turnOutput.economy.balance_after,
 * });
 * ```
 */
export const useEconomyStore = create<EconomyStore>((set, get) => ({
  // ì´ˆê¸° ìƒíƒœ
  ...createInitialState(),

  // ì•¡ì…˜

  addLedgerEntry: (entry) => {
    const timestamp = Date.now();
    const newEntry: LedgerEntry = { ...entry, timestamp };

    set((state) => {
      // ìµœì‹ ìˆœìœ¼ë¡œ ì¶”ê°€í•˜ê³  ìµœëŒ€ ê°œìˆ˜ ìœ ì§€ (Q1: Option A)
      const updatedLedger = [newEntry, ...state.ledger].slice(0, LEDGER_MAX_ENTRIES);

      return {
        ledger: updatedLedger,
        lastCost: {
          cost: entry.cost,
          balanceAfter: entry.balanceAfter,
          turnId: entry.turnId,
          modelLabel: entry.modelLabel,
        },
        // í„´ ì™„ë£Œ í›„ ì˜ˆìƒ ë¹„ìš© ì´ˆê¸°í™”
        costEstimate: null,
      };
    });
  },

  hydrateLedger: (ledger, currentBalance) => {
    const { lowBalanceThreshold } = get();

    // LEDGER_MAX_ENTRIES ì •ì±… ì ìš© (ì €ì¥ëœ ê²ƒì´ ë” ë§ì„ ê²½ìš° ëŒ€ë¹„)
    const hydratedLedger = ledger.slice(0, LEDGER_MAX_ENTRIES);

    // lastCostëŠ” ê°€ì¥ ìµœì‹  ì—”íŠ¸ë¦¬(ì²« ì›ì†Œ) ê¸°ì¤€ìœ¼ë¡œ ì„¤ì •
    const latestEntry = hydratedLedger[0] ?? null;
    const lastCost: LastCostState | null = latestEntry
      ? {
          cost: latestEntry.cost,
          balanceAfter: latestEntry.balanceAfter,
          turnId: latestEntry.turnId,
          modelLabel: latestEntry.modelLabel,
        }
      : null;

    // isBalanceLowëŠ” ë³µì›ëœ ì”ì•¡ ê¸°ì¤€ìœ¼ë¡œ ì¬ê³„ì‚°
    const isBalanceLow = currentBalance.signal < lowBalanceThreshold;

    set({
      ledger: hydratedLedger,
      lastCost,
      isBalanceLow,
      costEstimate: null,
    });
  },

  setCostEstimate: (estimate) => {
    set({ costEstimate: estimate });
  },

  setCostEstimateFromCard: (cost, costEstimate, actionId, label) => {
    if (costEstimate) {
      set({
        costEstimate: {
          min: costEstimate.min,
          max: costEstimate.max,
          actionId,
          label,
        },
      });
    } else {
      // cost_estimateê°€ ì—†ìœ¼ë©´ ê¸°ë³¸ costë¥¼ min/maxë¡œ ì‚¬ìš©
      set({
        costEstimate: {
          min: cost,
          max: cost,
          actionId,
          label,
        },
      });
    }
  },

  setLastCost: (lastCost) => {
    set({ lastCost });
  },

  updateBalanceLowStatus: (currentBalance) => {
    const { lowBalanceThreshold } = get();
    const isLow = currentBalance.signal < lowBalanceThreshold;
    set({ isBalanceLow: isLow });
  },

  setLowBalanceThreshold: (threshold) => {
    set({ lowBalanceThreshold: threshold });
  },

  clearLedger: () => {
    set({ ledger: [], lastCost: null });
  },

  reset: () => {
    set(createInitialState());
  },
}));

// =============================================================================
// ì…€ë ‰í„° (ì„±ëŠ¥ ìµœì í™”ìš©)
// =============================================================================

/** ì›ì¥ ì…€ë ‰í„° */
export const selectLedger = (state: EconomyStore) => state.ledger;

/** ì˜ˆìƒ ë¹„ìš© ì…€ë ‰í„° */
export const selectCostEstimate = (state: EconomyStore) => state.costEstimate;

/** ë§ˆì§€ë§‰ í™•ì • ë¹„ìš© ì…€ë ‰í„° */
export const selectLastCost = (state: EconomyStore) => state.lastCost;

/** ì”ì•¡ ë¶€ì¡± ìƒíƒœ ì…€ë ‰í„° */
export const selectIsBalanceLow = (state: EconomyStore) => state.isBalanceLow;

/** ìµœê·¼ Nê°œ ì›ì¥ ì—”íŠ¸ë¦¬ ì…€ë ‰í„° */
export const selectRecentLedger =
  (count: number) =>
  (state: EconomyStore): LedgerEntry[] =>
    state.ledger.slice(0, count);

/** ì´ ì†Œë¹„ ë¹„ìš© ê³„ì‚° ì…€ë ‰í„° (í˜„ì¬ ì„¸ì…˜) */
export const selectTotalSpent = (state: EconomyStore): CurrencyAmount => {
  return state.ledger.reduce(
    (acc, entry) => ({
      signal: acc.signal + entry.cost.signal,
      memory_shard: acc.memory_shard + entry.cost.memory_shard,
    }),
    { signal: 0, memory_shard: 0 },
  );
};

// =============================================================================
// ìœ í‹¸ë¦¬í‹° í•¨ìˆ˜
// =============================================================================

/**
 * í˜„ì¬ ì”ì•¡ìœ¼ë¡œ ì˜ˆìƒ ë¹„ìš©ì„ ê°ë‹¹í•  ìˆ˜ ìˆëŠ”ì§€ í™•ì¸í•©ë‹ˆë‹¤.
 * RULE-005: ì”ì•¡ ë¶€ì¡± ì‹œ ì‹¤í–‰ ê°•í–‰ì´ ì•„ë‹ˆë¼ ëŒ€ì²´ í–‰ë™ì„ ì œì•ˆ.
 */
export function canAffordCost(
  balance: CurrencyAmount,
  cost: CurrencyAmount,
): { affordable: boolean; shortfall: CurrencyAmount } {
  const signalShortfall = Math.max(0, cost.signal - balance.signal);
  const shardShortfall = Math.max(0, cost.memory_shard - balance.memory_shard);

  return {
    affordable: signalShortfall === 0 && shardShortfall === 0,
    shortfall: { signal: signalShortfall, memory_shard: shardShortfall },
  };
}

/**
 * ì˜ˆìƒ ë¹„ìš©ì˜ ìµœëŒ€ê°’ìœ¼ë¡œ ê°ë‹¹ ê°€ëŠ¥ ì—¬ë¶€ë¥¼ í™•ì¸í•©ë‹ˆë‹¤.
 */
export function canAffordEstimate(
  balance: CurrencyAmount,
  estimate: CostEstimateState,
): { affordable: boolean; shortfall: CurrencyAmount } {
  return canAffordCost(balance, estimate.max);
}
</file>

<file path="frontend/src/turn/turnRunner.ts">
/**
 * Unknown World - Turn Runner ëª¨ë“ˆ
 *
 * RU-003-Q3: Turn ì‹¤í–‰/ìŠ¤íŠ¸ë¦¬ë° ê²°í•©ì„ App.tsxì—ì„œ ë¶„ë¦¬í•˜ì—¬
 * "ë ˆì´ì•„ì›ƒ + ì´ë²¤íŠ¸ ë¼ìš°íŒ…"ê³¼ "ì˜¤ì¼€ìŠ¤íŠ¸ë ˆì´ì…˜"ì„ ëª…í™•íˆ ë¶„ë¦¬í•©ë‹ˆë‹¤.
 *
 * ì±…ì„:
 *   - TurnInput ìƒì„± (ì–¸ì–´/í´ë¦­/ë“œë¡­/í´ë¼ì´ì–¸íŠ¸ ì •ë³´/ì¬í™” ìŠ¤ëƒ…ìƒ·)
 *   - ìŠ¤íŠ¸ë¦¼ ì‹œì‘/ì·¨ì†Œ/ì½œë°± ë¼ìš°íŒ…
 *   - agentStore/worldStoreë¡œ ì´ë²¤íŠ¸ ë¶„ë°°
 *
 * ì„¤ê³„ ì›ì¹™:
 *   - RULE-002: ì±„íŒ… ì•±ì´ ì•„ë‹Œ ìƒíƒœ ê¸°ë°˜ ê²Œì„ ì‹œìŠ¤í…œ
 *   - RULE-003/004: êµ¬ì¡°í™” ì¶œë ¥ + ê²€ì¦/ë³µêµ¬
 *   - RULE-006: ko/en i18n ì •ì±… ì¤€ìˆ˜
 *
 * @module turn/turnRunner
 */

import type { TurnInput, DropInput } from '../schemas/turn';
import type { HotspotClickData } from '../components/SceneCanvas';
import { getResolvedLanguage } from '../i18n';
import { startTurnStream, type StreamCallbacks } from '../api/turnStream';
import { useAgentStore } from '../stores/agentStore';
import { useWorldStore } from '../stores/worldStore';

// =============================================================================
// íƒ€ì… ì •ì˜
// =============================================================================

/** TurnInput ìƒì„±ì„ ìœ„í•œ íŒŒë¼ë¯¸í„° */
export interface BuildTurnInputParams {
  /** ì‚¬ìš©ì ì…ë ¥ í…ìŠ¤íŠ¸ */
  text: string;
  /** ì•¡ì…˜ ì¹´ë“œ ID (ì„ íƒ) */
  actionId?: string;
  /** í•«ìŠ¤íŒŸ í´ë¦­ ë°ì´í„° (U-010) */
  click?: HotspotClickData;
  /** ë“œë¡­ ë°ì´í„° (U-012) */
  drop?: DropInput;
  /** ì¬í™” ìŠ¤ëƒ…ìƒ· */
  economySnapshot: { signal: number; memory_shard: number };
  /** UI í…Œë§ˆ */
  theme: 'dark' | 'light';
}

/** Turn ì‹¤í–‰ì„ ìœ„í•œ íŒŒë¼ë¯¸í„° (Appì—ì„œ í˜¸ì¶œ ì‹œ ì‚¬ìš©) */
export interface RunTurnParams {
  /** ì‚¬ìš©ì ì…ë ¥ í…ìŠ¤íŠ¸ */
  text: string;
  /** ì•¡ì…˜ ì¹´ë“œ ID (ì„ íƒ) */
  actionId?: string;
  /** í•«ìŠ¤íŒŸ í´ë¦­ ë°ì´í„° (U-010) */
  click?: HotspotClickData;
  /** ë“œë¡­ ë°ì´í„° (U-012) */
  drop?: DropInput;
}

/** Turn Runner ì¸í„°í˜ì´ìŠ¤ */
export interface TurnRunner {
  /** í„´ ì‹¤í–‰ (ìŠ¤íŠ¸ë¦¼ ì‹œì‘) */
  runTurn: (params: RunTurnParams) => void;
  /** ìŠ¤íŠ¸ë¦¼ ì·¨ì†Œ */
  cancel: () => void;
}

// =============================================================================
// TurnInput ìƒì„±
// =============================================================================

/**
 * TurnInputì„ ìƒì„±í•©ë‹ˆë‹¤.
 *
 * ì–¸ì–´, í´ë¦­, ë“œë¡­, í´ë¼ì´ì–¸íŠ¸ ì •ë³´, ì¬í™” ìŠ¤ëƒ…ìƒ·ì„ ì¡°í•©í•˜ì—¬
 * ì„œë²„ë¡œ ì „ì†¡í•  TurnInputì„ ìƒì„±í•©ë‹ˆë‹¤.
 */
export function buildTurnInput(params: BuildTurnInputParams): TurnInput {
  const { text, actionId, click, drop, economySnapshot, theme } = params;

  return {
    language: getResolvedLanguage(),
    text,
    action_id: actionId ?? null,
    // U-010: í•«ìŠ¤íŒŸ í´ë¦­ ë°ì´í„° í¬í•¨ (Q1: Option B)
    click: click
      ? {
          object_id: click.object_id,
          box_2d: click.box_2d,
        }
      : null,
    // U-012: ì•„ì´í…œ ë“œë¡­ ë°ì´í„° í¬í•¨ (Q1: Option B - target_box_2d í¬í•¨)
    drop: drop ?? null,
    client: {
      viewport_w: window.innerWidth,
      viewport_h: window.innerHeight,
      theme,
    },
    economy_snapshot: economySnapshot,
  };
}

// =============================================================================
// Turn Runner ìƒì„±
// =============================================================================

/**
 * Turn Runnerë¥¼ ìƒì„±í•©ë‹ˆë‹¤.
 *
 * RU-003-Q3: Appì—ì„œ Turn Runner ì¸ìŠ¤í„´ìŠ¤ë¥¼ ìƒì„±í•˜ì—¬ ì‚¬ìš©í•©ë‹ˆë‹¤.
 * ìŠ¤íŠ¸ë¦¼ ì½œë°±ì€ agentStoreì™€ worldStoreë¡œ ë¼ìš°íŒ…ë©ë‹ˆë‹¤.
 *
 * @param deps - ì˜ì¡´ì„± (i18n ë²ˆì—­ í•¨ìˆ˜ ë“±)
 * @returns Turn Runner ì¸í„°í˜ì´ìŠ¤
 *
 * @example
 * ```tsx
 * // App.tsxì—ì„œ ì‚¬ìš©
 * const runner = useMemo(() => createTurnRunner({
 *   t,
 *   theme: 'dark',
 * }), [t]);
 *
 * runner.runTurn({ text: 'hello' });
 * ```
 */
export function createTurnRunner(deps: {
  /** i18n ë²ˆì—­ í•¨ìˆ˜ */
  t: (key: string, options?: Record<string, unknown>) => string;
  /** UI í…Œë§ˆ */
  theme: 'dark' | 'light';
}): TurnRunner {
  const { t, theme } = deps;

  // ì·¨ì†Œ í•¨ìˆ˜ ì €ì¥
  let cancelFn: (() => void) | null = null;

  /**
   * í„´ì„ ì‹¤í–‰í•©ë‹ˆë‹¤.
   */
  const runTurn = (params: RunTurnParams): void => {
    // ìŠ¤íŠ¸ë¦¬ë° ì¤‘ì´ë©´ ë¬´ì‹œ
    const isStreaming = useAgentStore.getState().isStreaming;
    if (isStreaming) return;

    // Store ì•¡ì…˜ ê°€ì ¸ì˜¤ê¸° (í´ë¡œì € ì™¸ë¶€ì—ì„œ í˜¸ì¶œ ì‹œì ì— ìµœì‹  ìƒíƒœ ì°¸ì¡°)
    const agentStore = useAgentStore.getState();
    const worldStore = useWorldStore.getState();

    // ì¬í™” ìŠ¤ëƒ…ìƒ· ê°€ì ¸ì˜¤ê¸°
    const economySnapshot = worldStore.economy;

    // TurnInput ìƒì„±
    const turnInput = buildTurnInput({
      text:
        params.text ||
        (params.actionId ? t('action.card_select', { cardId: params.actionId }) : ''),
      actionId: params.actionId,
      click: params.click,
      drop: params.drop,
      economySnapshot,
      theme,
    });

    // Agent Store ì‹œì‘
    agentStore.startStream();

    // Scene Canvasë¥¼ ë¡œë”© ìƒíƒœë¡œ ì „í™˜ (U-031)
    worldStore.setSceneState({ status: 'loading', message: t('scene.status.syncing') });

    // ìŠ¤íŠ¸ë¦¼ ì½œë°± ì„¤ì • (RU-003-Q3: agentStore + worldStoreë¡œ ë¼ìš°íŒ…)
    // RU-003-T1: sceneState ì „ì´ëŠ” worldStore.applyTurnOutputì—ì„œ SSOTë¡œ ì²˜ë¦¬
    const callbacks: StreamCallbacks = {
      // Stage/Badges/NarrativeDelta â†’ agentStoreë¡œë§Œ ì „ë‹¬
      onStage: (event) => {
        useAgentStore.getState().handleStage(event);
      },
      onBadges: (event) => {
        useAgentStore.getState().handleBadges(event);
      },
      onNarrativeDelta: (event) => {
        useAgentStore.getState().handleNarrativeDelta(event);
      },
      // Final â†’ agentStore.handleFinal + worldStore.applyTurnOutput
      onFinal: (event) => {
        useAgentStore.getState().handleFinal(event);
        // RU-003-Q4: TurnOutput ë°˜ì˜ SSOT
        useWorldStore.getState().applyTurnOutput(event.data);
        // RU-003-S1: ì„±ê³µì ì¸ final ìˆ˜ì‹  ì‹œ ì—°ê²° ìƒíƒœ ë‚™ê´€ì  ë³µêµ¬
        useWorldStore.getState().setConnected(true);
      },
      // Error â†’ agentStore.handleError + worldStore ìƒíƒœ ë³µêµ¬
      onError: (event) => {
        useAgentStore.getState().handleError(event);
        useWorldStore.getState().setConnected(false);
        // Scene Canvasë¥¼ ì˜¤í”„ë¼ì¸/ì—ëŸ¬ ìƒíƒœë¡œ ì „í™˜ (U-031)
        const errorCode = event.code;
        if (errorCode === 'SAFETY_BLOCKED') {
          useWorldStore.getState().setSceneState({ status: 'blocked', message: event.message });
        } else if (errorCode === 'INSUFFICIENT_BALANCE') {
          useWorldStore.getState().setSceneState({ status: 'low_signal', message: event.message });
        } else {
          useWorldStore.getState().setSceneState({ status: 'offline', message: event.message });
        }
      },
      // Complete â†’ agentStore.completeStream
      // RU-003-T1: sceneState ì „ì´ëŠ” worldStore.applyTurnOutputì—ì„œ SSOTë¡œ ì²˜ë¦¬
      // - ì„±ê³µ ì‹œ: onFinal â†’ applyTurnOutputì—ì„œ ui.scene.image_url ê¸°ë°˜ìœ¼ë¡œ ì„¤ì •
      // - ì—ëŸ¬ ì‹œ: onErrorì—ì„œ ì´ë¯¸ offline/blocked/low_signalìœ¼ë¡œ ì„¤ì •ë¨
      onComplete: () => {
        useAgentStore.getState().completeStream();
        // RU-003-T1: sceneStateëŠ” applyTurnOutput(ì„±ê³µ) ë˜ëŠ” onError(ì‹¤íŒ¨)ì—ì„œ ì´ë¯¸ ì„¤ì •ë¨
        // ì—¬ê¸°ì„œ ì¶”ê°€ë¡œ ì„¤ì •í•˜ë©´ applyTurnOutputì˜ ì„¤ì •ì„ ë®ì–´ì“°ê²Œ ë˜ë¯€ë¡œ ì œê±°
      },
    };

    // ìŠ¤íŠ¸ë¦¼ ì‹œì‘
    cancelFn = startTurnStream(turnInput, callbacks);
  };

  /**
   * ìŠ¤íŠ¸ë¦¼ì„ ì·¨ì†Œí•©ë‹ˆë‹¤.
   *
   * ì¶”í›„ Cancel/Pause/Autopilot UXë¥¼ ìœ„í•œ ê¸°ë³¸ ê³¨ê²©ì…ë‹ˆë‹¤.
   * í˜„ì¬ executeTurnStreamì€ Abort ì‹œ onCompleteë¥¼ í˜¸ì¶œí•˜ì§€ ì•Šìœ¼ë¯€ë¡œ,
   * Cancel ë²„íŠ¼ì„ ë„£ì„ ê³„íšì´ë¼ë©´ "ì·¨ì†Œ ì‹œ UI ë³µêµ¬ ì •ì±…"ì„ ë³„ë„ë¡œ ëª…ì‹œí•´ì•¼ í•©ë‹ˆë‹¤.
   */
  const cancel = (): void => {
    cancelFn?.();
    cancelFn = null;
  };

  return {
    runTurn,
    cancel,
  };
}

// =============================================================================
// React Hook (ì„ íƒì  ì‚¬ìš©)
// =============================================================================

/**
 * Turn Runnerë¥¼ React ì»´í¬ë„ŒíŠ¸ì—ì„œ ì‚¬ìš©í•˜ê¸° ìœ„í•œ í›….
 *
 * @param deps - ì˜ì¡´ì„±
 * @returns Turn Runner ì¸í„°í˜ì´ìŠ¤ ë° ì·¨ì†Œ íš¨ê³¼
 *
 * @example
 * ```tsx
 * // ì»´í¬ë„ŒíŠ¸ì—ì„œ ì‚¬ìš©
 * const { runTurn, cancel } = useTurnRunner({ t, theme: 'dark' });
 * ```
 */
import { useCallback, useEffect, useRef } from 'react';

export function useTurnRunner(deps: {
  t: (key: string, options?: Record<string, unknown>) => string;
  theme: 'dark' | 'light';
}): TurnRunner {
  const { t, theme } = deps;

  // ì·¨ì†Œ í•¨ìˆ˜ ì €ì¥ ref
  const cancelFnRef = useRef<(() => void) | null>(null);

  // runTurnì„ useCallbackìœ¼ë¡œ ì •ì˜
  const runTurn = useCallback(
    (params: RunTurnParams): void => {
      // ìŠ¤íŠ¸ë¦¬ë° ì¤‘ì´ë©´ ë¬´ì‹œ
      const isStreaming = useAgentStore.getState().isStreaming;
      if (isStreaming) return;

      // Store ì•¡ì…˜ ê°€ì ¸ì˜¤ê¸°
      const agentStore = useAgentStore.getState();
      const worldStore = useWorldStore.getState();

      // ì¬í™” ìŠ¤ëƒ…ìƒ· ê°€ì ¸ì˜¤ê¸°
      const economySnapshot = worldStore.economy;

      // TurnInput ìƒì„±
      const turnInput = buildTurnInput({
        text:
          params.text ||
          (params.actionId ? t('action.card_select', { cardId: params.actionId }) : ''),
        actionId: params.actionId,
        click: params.click,
        drop: params.drop,
        economySnapshot,
        theme,
      });

      // Agent Store ì‹œì‘
      agentStore.startStream();

      // Scene Canvasë¥¼ ë¡œë”© ìƒíƒœë¡œ ì „í™˜ (U-031)
      worldStore.setSceneState({ status: 'loading', message: t('scene.status.syncing') });

      // ìŠ¤íŠ¸ë¦¼ ì½œë°± ì„¤ì • (RU-003-Q3: agentStore + worldStoreë¡œ ë¼ìš°íŒ…)
      // RU-003-T1: sceneState ì „ì´ëŠ” worldStore.applyTurnOutputì—ì„œ SSOTë¡œ ì²˜ë¦¬
      const callbacks: StreamCallbacks = {
        onStage: (event) => {
          useAgentStore.getState().handleStage(event);
        },
        onBadges: (event) => {
          useAgentStore.getState().handleBadges(event);
        },
        onNarrativeDelta: (event) => {
          useAgentStore.getState().handleNarrativeDelta(event);
        },
        onFinal: (event) => {
          useAgentStore.getState().handleFinal(event);
          useWorldStore.getState().applyTurnOutput(event.data);
          // RU-003-S1: ì„±ê³µì ì¸ final ìˆ˜ì‹  ì‹œ ì—°ê²° ìƒíƒœ ë‚™ê´€ì  ë³µêµ¬
          useWorldStore.getState().setConnected(true);
        },
        onError: (event) => {
          useAgentStore.getState().handleError(event);
          useWorldStore.getState().setConnected(false);
          // Scene Canvasë¥¼ ì˜¤í”„ë¼ì¸/ì—ëŸ¬ ìƒíƒœë¡œ ì „í™˜ (U-031)
          const errorCode = event.code;
          if (errorCode === 'SAFETY_BLOCKED') {
            useWorldStore.getState().setSceneState({ status: 'blocked', message: event.message });
          } else if (errorCode === 'INSUFFICIENT_BALANCE') {
            useWorldStore
              .getState()
              .setSceneState({ status: 'low_signal', message: event.message });
          } else {
            useWorldStore.getState().setSceneState({ status: 'offline', message: event.message });
          }
        },
        // Complete â†’ agentStore.completeStream
        // RU-003-T1: sceneState ì „ì´ëŠ” worldStore.applyTurnOutputì—ì„œ SSOTë¡œ ì²˜ë¦¬
        // - ì„±ê³µ ì‹œ: onFinal â†’ applyTurnOutputì—ì„œ ui.scene.image_url ê¸°ë°˜ìœ¼ë¡œ ì„¤ì •
        // - ì—ëŸ¬ ì‹œ: onErrorì—ì„œ ì´ë¯¸ offline/blocked/low_signalìœ¼ë¡œ ì„¤ì •ë¨
        onComplete: () => {
          useAgentStore.getState().completeStream();
          // RU-003-T1: sceneStateëŠ” applyTurnOutput(ì„±ê³µ) ë˜ëŠ” onError(ì‹¤íŒ¨)ì—ì„œ ì´ë¯¸ ì„¤ì •ë¨
          // ì—¬ê¸°ì„œ ì¶”ê°€ë¡œ ì„¤ì •í•˜ë©´ applyTurnOutputì˜ ì„¤ì •ì„ ë®ì–´ì“°ê²Œ ë˜ë¯€ë¡œ ì œê±°
        },
      };

      // ìŠ¤íŠ¸ë¦¼ ì‹œì‘ ë° ì·¨ì†Œ í•¨ìˆ˜ ì €ì¥
      cancelFnRef.current = startTurnStream(turnInput, callbacks);
    },
    [t, theme],
  );

  // cancel í•¨ìˆ˜
  const cancel = useCallback((): void => {
    cancelFnRef.current?.();
    cancelFnRef.current = null;
  }, []);

  // ì»´í¬ë„ŒíŠ¸ ì–¸ë§ˆìš´íŠ¸ ì‹œ ìŠ¤íŠ¸ë¦¼ ì·¨ì†Œ
  useEffect(() => {
    return () => {
      cancelFnRef.current?.();
    };
  }, []);

  return { runTurn, cancel };
}
</file>

<file path="frontend/src/types/turn_stream.ts">
/**
 * Unknown World - Turn Stream ì´ë²¤íŠ¸ ê³„ì•½(Contract).
 *
 * NDJSON ìŠ¤íŠ¸ë¦¬ë°ì—ì„œ ì‚¬ìš©ë˜ëŠ” ì´ë²¤íŠ¸ íƒ€ì…, ì¸í„°í˜ì´ìŠ¤ë¥¼ ì •ì˜í•©ë‹ˆë‹¤.
 * ì´ ëª¨ë“ˆì€ ë°±ì—”ë“œì™€ í”„ë¡ íŠ¸ì—”ë“œ ê°„ì˜ ìŠ¤íŠ¸ë¦¼ ì´ë²¤íŠ¸ ê³„ì•½ SSOTì…ë‹ˆë‹¤.
 *
 * ì„¤ê³„ ì›ì¹™:
 *   - RU-002-Q4: ì´ë²¤íŠ¸ ê³„ì•½ì„ transport ê³„ì¸µìœ¼ë¡œ ë¶„ë¦¬
 *   - RU-002-S2: ì´ë²¤íŠ¸ë³„ Zod ê²€ì¦ + Unknown/í™•ì¥ ì´ë²¤íŠ¸ í´ë°±
 *   - RULE-003: êµ¬ì¡°í™” ì¶œë ¥(JSON Schema) ìš°ì„  + ì´ì¤‘ ê²€ì¦
 *   - RULE-008: ë‹¨ê³„/ë°°ì§€ ê°€ì‹œí™”
 *
 * ì°¸ì¡°:
 *   - vibe/unit-plans/U-007[Mvp].md
 *   - vibe/refactors/RU-002-Q4.md
 *   - vibe/refactors/RU-002-S2.md
 *
 * @module types/turn_stream
 */

import { z } from 'zod';
import {
  AgentPhaseSchema,
  ValidationBadgeSchema,
  type TurnOutput,
  type AgentPhase,
  type ValidationBadge,
} from '../schemas/turn';

// =============================================================================
// ìŠ¤íŠ¸ë¦¼ ì´ë²¤íŠ¸ íƒ€ì… ìƒìˆ˜ (ì„œë²„ ê³„ì•½ê³¼ ì¼ì¹˜)
// =============================================================================

/** ìŠ¤íŠ¸ë¦¼ ì´ë²¤íŠ¸ íƒ€ì… ìƒìˆ˜ */
export const StreamEventType = {
  STAGE: 'stage',
  BADGES: 'badges',
  NARRATIVE_DELTA: 'narrative_delta',
  FINAL: 'final',
  ERROR: 'error',
  REPAIR: 'repair',
} as const;

export type StreamEventTypeName = (typeof StreamEventType)[keyof typeof StreamEventType];

/**
 * ë‹¨ê³„ ìƒíƒœ ìƒìˆ˜.
 * RU-002-S2/RU-002-Q2: v1(complete) ë° v2(ok/fail) ë³„ì¹­ ëª¨ë‘ ì§€ì›.
 */
export const StageStatus = {
  START: 'start',
  COMPLETE: 'complete',
  /** ë‹¨ê³„ ì‹¤íŒ¨ */
  FAIL: 'fail',
} as const;

export type StageStatusName = (typeof StageStatus)[keyof typeof StageStatus];

// =============================================================================
// RU-002-S2: ì´ë²¤íŠ¸ë³„ Zod ìŠ¤í‚¤ë§ˆ (ê²½ëŸ‰ ê²€ì¦ + í´ë°±)
// =============================================================================

/**
 * stage.status ìŠ¤í‚¤ë§ˆ.
 * v1(complete) ë° v2(ok/fail) ë³„ì¹­ ëª¨ë‘ í—ˆìš©.
 */
export const StageStatusSchema = z.enum(['start', 'complete', 'ok', 'fail']);

/**
 * StageEvent Zod ìŠ¤í‚¤ë§ˆ.
 * ë‹¨ê³„ ì§„í–‰ ì´ë²¤íŠ¸ ê²€ì¦ìš©.
 */
export const StageEventSchema = z.object({
  type: z.literal(StreamEventType.STAGE),
  name: AgentPhaseSchema,
  status: StageStatusSchema,
});

/**
 * RepairEvent Zod ìŠ¤í‚¤ë§ˆ.
 * ìë™ ë³µêµ¬ ì‹œë„ ì´ë²¤íŠ¸ ê²€ì¦ìš©.
 */
export const RepairEventSchema = z.object({
  type: z.literal(StreamEventType.REPAIR),
  attempt: z.number(),
  message: z.string().optional(),
});

/**
 * BadgesEvent Zod ìŠ¤í‚¤ë§ˆ (v1: ë°°ì—´).
 * v1ì€ badges: string[] í˜•ì‹.
 */
export const BadgesEventSchemaV1 = z.object({
  type: z.literal(StreamEventType.BADGES),
  badges: z.array(ValidationBadgeSchema),
});

/**
 * BadgesEvent Zod ìŠ¤í‚¤ë§ˆ (v2: ê°ì²´/ë§µ).
 * í–¥í›„ v2ëŠ” badges: { [key]: status } í˜•ì‹ì„ ì§€ì›í•  ìˆ˜ ìˆìŒ.
 * í˜„ì¬ëŠ” v1ë§Œ ì‚¬ìš©í•˜ë¯€ë¡œ ì´ ìŠ¤í‚¤ë§ˆëŠ” í™•ì¥ì„±ì„ ìœ„í•´ ì •ì˜.
 */
export const BadgesEventSchemaV2 = z.object({
  type: z.literal(StreamEventType.BADGES),
  badges: z.record(z.string(), z.boolean()),
});

/**
 * BadgesEvent í†µí•© ìŠ¤í‚¤ë§ˆ.
 * v1(ë°°ì—´) ë˜ëŠ” v2(ê°ì²´) ëª¨ë‘ í—ˆìš©.
 */
export const BadgesEventSchema = z.union([BadgesEventSchemaV1, BadgesEventSchemaV2]);

/**
 * NarrativeDeltaEvent Zod ìŠ¤í‚¤ë§ˆ.
 * íƒ€ì íš¨ê³¼ìš© ë‚´ëŸ¬í‹°ë¸Œ ë¸íƒ€ ì´ë²¤íŠ¸ ê²€ì¦ìš©.
 */
export const NarrativeDeltaEventSchema = z.object({
  type: z.literal(StreamEventType.NARRATIVE_DELTA),
  text: z.string(),
});

/**
 * FinalEvent ì›ì‹œ ìŠ¤í‚¤ë§ˆ.
 * v1(data) ë° v2(turn_output) ë³„ì¹­ ëª¨ë‘ í—ˆìš©.
 * TurnOutput ìì²´ ê²€ì¦ì€ turnStream.tsì—ì„œ safeParseTurnOutputìœ¼ë¡œ ìˆ˜í–‰.
 */
export const FinalEventRawSchema = z.object({
  type: z.literal(StreamEventType.FINAL),
  data: z.unknown(),
});

/**
 * ErrorEvent Zod ìŠ¤í‚¤ë§ˆ.
 * ì—ëŸ¬ ì´ë²¤íŠ¸ ê²€ì¦ìš©.
 */
export const ErrorEventSchema = z.object({
  type: z.literal(StreamEventType.ERROR),
  message: z.string(),
  code: z.string().optional(),
});

/**
 * ì´ë²¤íŠ¸ íƒ€ì… ì¶”ì¶œìš© ìµœì†Œ ìŠ¤í‚¤ë§ˆ.
 * Unknown ì´ë²¤íŠ¸ íŒë³„ì— ì‚¬ìš©.
 */
export const BaseEventSchema = z.object({
  type: z.string(),
});

// =============================================================================
// ì´ë²¤íŠ¸ íŒŒì‹± ìœ í‹¸ë¦¬í‹° (RU-002-S2)
// =============================================================================

/** ì´ë²¤íŠ¸ ê²€ì¦ ê²°ê³¼ íƒ€ì… */
export type EventParseResult<T> =
  | { success: true; data: T }
  | { success: false; error: z.ZodError };

/**
 * StageEventë¥¼ ì•ˆì „í•˜ê²Œ íŒŒì‹±í•©ë‹ˆë‹¤.
 */
export function safeParseStageEvent(
  data: unknown,
): EventParseResult<z.infer<typeof StageEventSchema>> {
  const result = StageEventSchema.safeParse(data);
  return result.success
    ? { success: true, data: result.data }
    : { success: false, error: result.error };
}

/**
 * RepairEventë¥¼ ì•ˆì „í•˜ê²Œ íŒŒì‹±í•©ë‹ˆë‹¤.
 */
export function safeParseRepairEvent(
  data: unknown,
): EventParseResult<z.infer<typeof RepairEventSchema>> {
  const result = RepairEventSchema.safeParse(data);
  return result.success
    ? { success: true, data: result.data }
    : { success: false, error: result.error };
}

/**
 * BadgesEventë¥¼ ì•ˆì „í•˜ê²Œ íŒŒì‹±í•©ë‹ˆë‹¤.
 * v1(ë°°ì—´) í˜•íƒœë¡œ ì •ê·œí™”í•˜ì—¬ ë°˜í™˜í•©ë‹ˆë‹¤.
 */
export function safeParseBadgesEvent(data: unknown): EventParseResult<BadgesEvent> {
  const result = BadgesEventSchema.safeParse(data);
  if (!result.success) {
    return { success: false, error: result.error };
  }

  // v2(ê°ì²´) í˜•íƒœì¸ ê²½ìš° v1(ë°°ì—´)ë¡œ ì •ê·œí™”
  const parsed = result.data;
  if (Array.isArray(parsed.badges)) {
    // v1 í˜•íƒœ: ê·¸ëŒ€ë¡œ ë°˜í™˜
    return {
      success: true,
      data: { type: StreamEventType.BADGES, badges: parsed.badges as ValidationBadge[] },
    };
  } else {
    // v2 í˜•íƒœ: trueì¸ í‚¤ë§Œ ì¶”ì¶œí•˜ì—¬ ë°°ì—´ë¡œ ë³€í™˜
    const badgeArray = Object.entries(parsed.badges)
      .filter(([, value]) => value)
      .map(([key]) => key as ValidationBadge);
    return {
      success: true,
      data: { type: StreamEventType.BADGES, badges: badgeArray },
    };
  }
}

/**
 * NarrativeDeltaEventë¥¼ ì•ˆì „í•˜ê²Œ íŒŒì‹±í•©ë‹ˆë‹¤.
 */
export function safeParseNarrativeDeltaEvent(
  data: unknown,
): EventParseResult<z.infer<typeof NarrativeDeltaEventSchema>> {
  const result = NarrativeDeltaEventSchema.safeParse(data);
  return result.success
    ? { success: true, data: result.data }
    : { success: false, error: result.error };
}

/**
 * FinalEvent ì›ì‹œ í˜•íƒœë¥¼ ì•ˆì „í•˜ê²Œ íŒŒì‹±í•©ë‹ˆë‹¤.
 * TurnOutput ìì²´ ê²€ì¦ì€ ë³„ë„ë¡œ ìˆ˜í–‰í•´ì•¼ í•©ë‹ˆë‹¤.
 */
export function safeParseFinalEventRaw(
  data: unknown,
): EventParseResult<z.infer<typeof FinalEventRawSchema>> {
  const result = FinalEventRawSchema.safeParse(data);
  return result.success
    ? { success: true, data: result.data }
    : { success: false, error: result.error };
}

/**
 * ErrorEventë¥¼ ì•ˆì „í•˜ê²Œ íŒŒì‹±í•©ë‹ˆë‹¤.
 */
export function safeParseErrorEvent(
  data: unknown,
): EventParseResult<z.infer<typeof ErrorEventSchema>> {
  const result = ErrorEventSchema.safeParse(data);
  return result.success
    ? { success: true, data: result.data }
    : { success: false, error: result.error };
}

/**
 * stage.status ì •ê·œí™” í—¬í¼.
 * 'ok'ë¥¼ 'complete'ë¡œ, 'fail'ì€ ê·¸ëŒ€ë¡œ ìœ ì§€.
 */
export function normalizeStageStatus(status: string): 'start' | 'complete' | 'fail' {
  if (status === 'ok') return 'complete';
  if (status === 'fail') return 'fail';
  if (status === 'start') return 'start';
  return 'complete';
}

// =============================================================================
// ìŠ¤íŠ¸ë¦¼ ì´ë²¤íŠ¸ ì¸í„°í˜ì´ìŠ¤
// =============================================================================

/**
 * ë‹¨ê³„ ì§„í–‰ ì´ë²¤íŠ¸.
 * RU-002-S2: statusì— 'fail' ì¶”ê°€í•˜ì—¬ ë‹¨ê³„ ì‹¤íŒ¨ í‘œí˜„ ì§€ì›.
 */
export interface StageEvent {
  type: typeof StreamEventType.STAGE;
  name: AgentPhase;
  /** 'start' | 'complete' | 'ok' | 'fail'. okëŠ” completeë¡œ ì •ê·œí™”ë¨. */
  status: StageStatusName;
}

/** ìë™ ë³µêµ¬(Repair) ì´ë²¤íŠ¸ */
export interface RepairEvent {
  type: typeof StreamEventType.REPAIR;
  attempt: number;
  message?: string;
}

/** ë°°ì§€ ì´ë²¤íŠ¸ */
export interface BadgesEvent {
  type: typeof StreamEventType.BADGES;
  badges: ValidationBadge[];
}

/** ë‚´ëŸ¬í‹°ë¸Œ ë¸íƒ€ ì´ë²¤íŠ¸ (íƒ€ì íš¨ê³¼ìš©) */
export interface NarrativeDeltaEvent {
  type: typeof StreamEventType.NARRATIVE_DELTA;
  text: string;
}

/** ìµœì¢… TurnOutput ì´ë²¤íŠ¸
 *
 * RU-002-Q2: v1ì€ `data`, v2ëŠ” `turn_output` ì‚¬ìš©.
 * í•˜ìœ„í˜¸í™˜ì„ ìœ„í•´ ë‘ í•„ë“œ ëª¨ë‘ ì„ ì–¸í•˜ë˜, ì •ê·œí™”ëœ ì¸í„°í˜ì´ìŠ¤ëŠ” `data`ë¥¼ ì‚¬ìš©.
 */
export interface FinalEvent {
  type: typeof StreamEventType.FINAL;
  /** v1 í˜„í–‰ ê³„ì•½: TurnOutput í˜ì´ë¡œë“œ */
  data: TurnOutput;
}

/** FinalEvent ì›ì‹œ ìˆ˜ì‹  í˜•íƒœ */
export interface FinalEventRaw {
  type: typeof StreamEventType.FINAL;
  /** TurnOutput í˜ì´ë¡œë“œ */
  data: TurnOutput;
}

/** ì—ëŸ¬ ì´ë²¤íŠ¸ */
export interface ErrorEvent {
  type: typeof StreamEventType.ERROR;
  message: string;
  code?: string;
}

/** ìŠ¤íŠ¸ë¦¼ ì´ë²¤íŠ¸ ìœ ë‹ˆì˜¨ íƒ€ì… */
export type StreamEvent =
  | StageEvent
  | RepairEvent
  | BadgesEvent
  | NarrativeDeltaEvent
  | FinalEvent
  | ErrorEvent;

// =============================================================================
// ìŠ¤íŠ¸ë¦¼ ì½œë°± ì¸í„°í˜ì´ìŠ¤
// =============================================================================

/** ìŠ¤íŠ¸ë¦¼ ì´ë²¤íŠ¸ ì½œë°± */
export interface StreamCallbacks {
  /** ë‹¨ê³„ ì§„í–‰ ì´ë²¤íŠ¸ */
  onStage?: (event: StageEvent) => void;
  /** ìë™ ë³µêµ¬ ì´ë²¤íŠ¸ */
  onRepair?: (event: RepairEvent) => void;
  /** ë°°ì§€ ì´ë²¤íŠ¸ */
  onBadges?: (event: BadgesEvent) => void;
  /** ë‚´ëŸ¬í‹°ë¸Œ ë¸íƒ€ ì´ë²¤íŠ¸ */
  onNarrativeDelta?: (event: NarrativeDeltaEvent) => void;
  /** ìµœì¢… TurnOutput ì´ë²¤íŠ¸ */
  onFinal?: (event: FinalEvent) => void;
  /** ì—ëŸ¬ ì´ë²¤íŠ¸ */
  onError?: (event: ErrorEvent) => void;
  /** ìŠ¤íŠ¸ë¦¼ ì™„ë£Œ */
  onComplete?: () => void;
}
</file>

<file path="frontend/vite.config.ts">
/// <reference types="vitest" />
import { defineConfig } from 'vite';
import react from '@vitejs/plugin-react';

// https://vite.dev/config/
export default defineConfig({
  plugins: [react()],
  server: {
    port: 8001, // RULE-011: í”„ë¡ íŠ¸ì—”ë“œëŠ” 8001~8010 ì‚¬ìš©
    strictPort: true, // í¬íŠ¸ ì¶©ëŒ ì‹œ fail-fast (ëŒ€ì—­ ë°– ì´ë™ ë°©ì§€)
    // ì¶©ëŒ ì‹œ: pnpm -C frontend dev --port 8002 (8002~8010 ì¤‘ ì„ íƒ)
  },
  build: {
    outDir: 'dist',
    sourcemap: true,
  },
  test: {
    globals: true,
    environment: 'jsdom',
    setupFiles: './src/setupTests.ts',
  },
});
</file>

<file path="backend/pyproject.toml">
# backend/pyproject.toml
# SSOT: vibe/tech-stack.md (ë²„ì „ ê¸°ì¤€ì¼: 2026-01-01)

[build-system]
requires = ["hatchling"]
build-backend = "hatchling.build"

[project]
name = "unknown-world-backend"
version = "0.1.0"
description = "Unknown World Backend - Gemini ê¸°ë°˜ ì—ì´ì „íŠ¸í˜• ê²Œì„ ì—”ì§„"
requires-python = ">=3.14"
dependencies = [
    "fastapi==0.128.0",
    "uvicorn[standard]==0.40.0",
    "pydantic==2.12.5",
    "google-genai==1.56.0",
    "google-cloud-aiplatform==1.132.0",
    "google-cloud-storage==3.7.0",
]

[tool.hatch.build.targets.wheel]
packages = ["src/unknown_world"]

[dependency-groups]
dev = [
    "ruff==0.14.10",
    "pyright==1.1.407",
    "pytest==9.0.2",
    "httpx==0.28.1",
    "jsonschema>=4.26.0",
]

[tool.ruff]
line-length = 100
target-version = "py314"
extend-exclude = [
    "__pycache__",
    ".ruff_cache",
    ".venv",
    "venv",
    "dist",
    "build",
]

[tool.ruff.lint]
select = [
    "E",      # pycodestyle errors
    "W",      # pycodestyle warnings
    "F",      # pyflakes
    "I",      # isort
    "UP",     # pyupgrade
    "B",      # flake8-bugbear
    "C4",     # flake8-comprehensions
    "SIM",    # flake8-simplify
]
ignore = [
    "E501",   # line too long (handled by formatter)
]

[tool.ruff.format]
quote-style = "double"
indent-style = "space"

[tool.pyright]
pythonVersion = "3.14"
typeCheckingMode = "strict"
include = ["src"]
</file>

<file path="frontend/src/schemas/turn.ts">
/**
 * Unknown World - TurnInput/TurnOutput Zod ìŠ¤í‚¤ë§ˆ.
 *
 * ì´ ëª¨ë“ˆì€ ë°±ì—”ë“œ Pydantic ëª¨ë¸(U-005)ê³¼ 1:1 ëŒ€ì‘í•˜ëŠ” Zod ìŠ¤í‚¤ë§ˆë¥¼ ì •ì˜í•©ë‹ˆë‹¤.
 * í´ë¼ì´ì–¸íŠ¸ ì¸¡ ê²€ì¦ ë° íƒ€ì… ì•ˆì „ì„±ì„ ì œê³µí•©ë‹ˆë‹¤.
 *
 * ì„¤ê³„ ì›ì¹™:
 *   - RULE-003: êµ¬ì¡°í™” ì¶œë ¥(JSON Schema) ìš°ì„  + ì´ì¤‘ ê²€ì¦ (ì„œë²„ Pydantic + í´ë¼ Zod)
 *   - RULE-004: ê²€ì¦ ì‹¤íŒ¨ ì‹œ ì•ˆì „ í´ë°± ì œê³µ (UI ë©ˆì¶¤ ë°©ì§€)
 *   - RULE-005: ì¬í™” ì¸ë°”ë¦¬ì–¸íŠ¸ (cost, balance_after í•„ìˆ˜, ì”ì•¡ ìŒìˆ˜ ê¸ˆì§€)
 *   - RULE-006: ko/en ì–¸ì–´ ì •ì±… (Language enumìœ¼ë¡œ ê³ ì •)
 *   - RULE-009: ì¢Œí‘œ ê·œì•½ (0~1000, bbox [ymin,xmin,ymax,xmax])
 *
 * Q1 ê²°ì • ì‚¬í•­:
 *   - schema_version í¬í•¨ (Option A): SaveGame/ë§ˆì´ê·¸ë ˆì´ì…˜/ê²€ì¦ì— ìœ ë¦¬
 *
 * @module schemas/turn
 */

import { z } from 'zod';

// =============================================================================
// ìŠ¤í‚¤ë§ˆ ë²„ì „ (Q1 ê²°ì •: Option A - í¬í•¨)
// =============================================================================

/**
 * í˜„ì¬ ìŠ¤í‚¤ë§ˆ ë²„ì „.
 * SaveGame/ë§ˆì´ê·¸ë ˆì´ì…˜/ê²€ì¦ì— ì‚¬ìš©ë©ë‹ˆë‹¤.
 */
export const SCHEMA_VERSION = '1.0.0' as const;

// =============================================================================
// ê³µí†µ Enum íƒ€ì…
// =============================================================================

/**
 * ì§€ì› ì–¸ì–´ (RULE-006).
 * ko/en í˜¼í•© ì¶œë ¥ ê¸ˆì§€. TurnInput.languageë¥¼ SSOTë¡œ ì‚¼ì•„
 * ëª¨ë“  UI/ë‚´ëŸ¬í‹°ë¸Œ/ì‹œìŠ¤í…œ ë©”ì‹œì§€ëŠ” ë™ì¼ ì–¸ì–´ë¡œ ê³ ì •í•©ë‹ˆë‹¤.
 */
export const LanguageSchema = z.enum(['ko-KR', 'en-US']);
export type Language = z.infer<typeof LanguageSchema>;

/**
 * í…Œë§ˆ ì„¤ì •.
 */
export const ThemeSchema = z.enum(['dark', 'light']);
export type Theme = z.infer<typeof ThemeSchema>;

/**
 * ì—ì´ì „íŠ¸ ì‹¤í–‰ ë‹¨ê³„ (RULE-008).
 * ì—ì´ì „íŠ¸í˜• ì‹œìŠ¤í…œì„ì„ UIë¡œ ì¦ëª…í•˜ê¸° ìœ„í•œ ë‹¨ê³„ í‘œì‹œ.
 */
export const AgentPhaseSchema = z.enum([
  'parse',
  'validate',
  'plan',
  'resolve',
  'render',
  'verify',
  'commit',
]);
export type AgentPhase = z.infer<typeof AgentPhaseSchema>;

/**
 * ê²€ì¦ ë°°ì§€ (RULE-008).
 * í„´ ê²°ê³¼ì— ëŒ€í•œ ê²€ì¦ ìƒíƒœë¥¼ í‘œì‹œí•©ë‹ˆë‹¤.
 */
export const ValidationBadgeSchema = z.enum([
  'schema_ok',
  'schema_fail',
  'economy_ok',
  'economy_fail',
  'safety_ok',
  'safety_blocked',
  'consistency_ok',
  'consistency_fail',
]);
export type ValidationBadge = z.infer<typeof ValidationBadgeSchema>;

/**
 * ëª¨ë¸/í’ˆì§ˆ ì„ íƒ ë¼ë²¨ (RULE-008).
 * í”„ë¡¬í”„íŠ¸ ë…¸ì¶œ ì—†ì´ "ì™œ ì´ ì„ íƒì´ì—ˆëŠ”ì§€"ë¥¼ ì‚¬ìš©ì ì¹œí™” ë¼ë²¨ë¡œ í‘œì‹œ.
 */
export const ModelLabelSchema = z.enum(['FAST', 'QUALITY', 'CHEAP', 'REF']);
export type ModelLabel = z.infer<typeof ModelLabelSchema>;

/**
 * í–‰ë™ ìœ„í—˜ë„ ìˆ˜ì¤€.
 */
export const RiskLevelSchema = z.enum(['low', 'medium', 'high']);
export type RiskLevel = z.infer<typeof RiskLevelSchema>;

// =============================================================================
// ê³µí†µ í•˜ìœ„ íƒ€ì…
// =============================================================================

/**
 * ì •ê·œí™” ì¢Œí‘œ (RULE-009).
 * 0~1000 ë²”ìœ„ì˜ ì •ìˆ˜ì…ë‹ˆë‹¤.
 */
export const CoordinateSchema = z.number().int().min(0).max(1000).describe('ì •ê·œí™” ì¢Œí‘œ (0~1000)');
export type Coordinate = z.infer<typeof CoordinateSchema>;

/**
 * 2D ë°”ìš´ë”© ë°•ìŠ¤ (RULE-009).
 * ì¢Œí‘œëŠ” 0~1000 ì •ê·œí™” ì¢Œí‘œê³„ì´ë©°, bboxëŠ” [ymin, xmin, ymax, xmax] ìˆœì„œì…ë‹ˆë‹¤.
 * ì´ë¯¸ì§€ ì´í•´ bbox í¬ë§·ê³¼ í˜¸í™˜ë©ë‹ˆë‹¤.
 */
export const Box2DSchema = z
  .object({
    ymin: CoordinateSchema.describe('Y ìµœì†Œê°’ (ìƒë‹¨)'),
    xmin: CoordinateSchema.describe('X ìµœì†Œê°’ (ì¢Œì¸¡)'),
    ymax: CoordinateSchema.describe('Y ìµœëŒ€ê°’ (í•˜ë‹¨)'),
    xmax: CoordinateSchema.describe('X ìµœëŒ€ê°’ (ìš°ì¸¡)'),
  })
  .strict();
export type Box2D = z.infer<typeof Box2DSchema>;

/**
 * ì¬í™” ìˆ˜ëŸ‰.
 * signalê³¼ memory_shardëŠ” 0 ì´ìƒì´ì–´ì•¼ í•©ë‹ˆë‹¤ (RULE-005).
 */
export const CurrencyAmountSchema = z
  .object({
    signal: z.number().int().min(0).describe('ì‹œê·¸ë„ (ê¸°ë³¸ ì¬í™”, 0 ì´ìƒ)'),
    memory_shard: z.number().int().min(0).describe('ê¸°ì–µ íŒŒí¸ (í¬ê·€ ì¬í™”, 0 ì´ìƒ)'),
  })
  .strict();
export type CurrencyAmount = z.infer<typeof CurrencyAmountSchema>;

// =============================================================================
// TurnInput ê´€ë ¨ íƒ€ì…
// =============================================================================

/**
 * í´ë¦­ ì…ë ¥ ì •ë³´.
 * í™”ë©´ ì˜¤ë¸Œì íŠ¸ í´ë¦­ ì‹œ ì „ë‹¬ë˜ëŠ” ì •ë³´ì…ë‹ˆë‹¤.
 */
export const ClickInputSchema = z
  .object({
    object_id: z.string().describe('í´ë¦­í•œ ì˜¤ë¸Œì íŠ¸ ID'),
    box_2d: Box2DSchema.nullable().default(null).describe('í´ë¦­ ìœ„ì¹˜ ë°”ìš´ë”© ë°•ìŠ¤ (ì„ íƒ)'),
  })
  .strict();
export type ClickInput = z.infer<typeof ClickInputSchema>;

/**
 * ë“œë¡­ ì…ë ¥ ì •ë³´ (U-012).
 * ì¸ë²¤í† ë¦¬ ì•„ì´í…œì„ í•«ìŠ¤íŒŸì— ë“œë¡­í•  ë•Œ ì „ë‹¬ë˜ëŠ” ì •ë³´ì…ë‹ˆë‹¤.
 * Q1 ê²°ì •: Option B - target_box_2d í¬í•¨í•˜ì—¬ ì„œë²„ê°€ ì •í™•í•œ ìœ„ì¹˜ í•´ì„ ê°€ëŠ¥.
 */
export const DropInputSchema = z
  .object({
    item_id: z.string().describe('ë“œë¡­í•œ ì¸ë²¤í† ë¦¬ ì•„ì´í…œ ID'),
    target_object_id: z.string().describe('ë“œë¡­ ëŒ€ìƒ í•«ìŠ¤íŒŸ ì˜¤ë¸Œì íŠ¸ ID'),
    target_box_2d: Box2DSchema.describe('ë“œë¡­ ëŒ€ìƒì˜ ë°”ìš´ë”© ë°•ìŠ¤ (0~1000 ì •ê·œí™”)'),
  })
  .strict();
export type DropInput = z.infer<typeof DropInputSchema>;

/**
 * í´ë¼ì´ì–¸íŠ¸ ì •ë³´.
 */
export const ClientInfoSchema = z
  .object({
    viewport_w: z.number().int().positive().describe('ë·°í¬íŠ¸ ë„ˆë¹„ (í”½ì…€, ì–‘ìˆ˜)'),
    viewport_h: z.number().int().positive().describe('ë·°í¬íŠ¸ ë†’ì´ (í”½ì…€, ì–‘ìˆ˜)'),
    theme: ThemeSchema.default('dark').describe('í˜„ì¬ í…Œë§ˆ'),
  })
  .strict();
export type ClientInfo = z.infer<typeof ClientInfoSchema>;

/**
 * ì¬í™” ìŠ¤ëƒ…ìƒ· (í´ë¼ì´ì–¸íŠ¸ â†’ ì„œë²„).
 * í´ë¼ì´ì–¸íŠ¸ê°€ ë³´ìœ í•œ í˜„ì¬ ì¬í™” ìƒíƒœì…ë‹ˆë‹¤.
 */
export const EconomySnapshotSchema = z
  .object({
    signal: z.number().int().min(0).describe('í˜„ì¬ ì‹œê·¸ë„ ì”ì•¡ (0 ì´ìƒ)'),
    memory_shard: z.number().int().min(0).describe('í˜„ì¬ ê¸°ì–µ íŒŒí¸ ì”ì•¡ (0 ì´ìƒ)'),
  })
  .strict();
export type EconomySnapshot = z.infer<typeof EconomySnapshotSchema>;

/**
 * í„´ ì…ë ¥ (í´ë¼ì´ì–¸íŠ¸ â†’ ì„œë²„).
 * ì‚¬ìš©ìê°€ í„´ì„ ì§„í–‰í•  ë•Œ ì„œë²„ë¡œ ì „ì†¡í•˜ëŠ” ì…ë ¥ ë°ì´í„°ì…ë‹ˆë‹¤.
 *
 * U-012: drop í•„ë“œ ì¶”ê°€ - ì¸ë²¤í† ë¦¬ ì•„ì´í…œì„ í•«ìŠ¤íŒŸì— ë“œë¡­í•  ë•Œ ì‚¬ìš©.
 */
export const TurnInputSchema = z
  .object({
    language: LanguageSchema.describe('ìš”ì²­ ì–¸ì–´ (ì‘ë‹µë„ ë™ì¼ ì–¸ì–´ë¡œ ê³ ì •)'),
    text: z.string().default('').describe('ì‚¬ìš©ì ìì—°ì–´ ì…ë ¥'),
    action_id: z.string().nullable().default(null).describe('ì„ íƒí•œ ì•¡ì…˜ ì¹´ë“œ ID (ì„ íƒ)'),
    click: ClickInputSchema.nullable().default(null).describe('ì˜¤ë¸Œì íŠ¸ í´ë¦­ ì •ë³´ (ì„ íƒ)'),
    drop: DropInputSchema.nullable().default(null).describe('ì•„ì´í…œ ë“œë¡­ ì •ë³´ (ì„ íƒ, U-012)'),
    client: ClientInfoSchema.describe('í´ë¼ì´ì–¸íŠ¸ í™˜ê²½ ì •ë³´'),
    economy_snapshot: EconomySnapshotSchema.describe('í˜„ì¬ ì¬í™” ìƒíƒœ'),
  })
  .strict();
export type TurnInput = z.infer<typeof TurnInputSchema>;

// =============================================================================
// TurnOutput ê´€ë ¨ íƒ€ì… - UI
// =============================================================================

/**
 * ë¹„ìš© ì¶”ì •ì¹˜ (U-009: ìµœì†Œ/ìµœëŒ€ ë²”ìœ„).
 * í–‰ë™ì˜ ì˜ˆìƒ ë¹„ìš© ë²”ìœ„ë¥¼ í‘œì‹œí•©ë‹ˆë‹¤.
 */
export const CostEstimateSchema = z
  .object({
    min: CurrencyAmountSchema.describe('ìµœì†Œ ì˜ˆìƒ ë¹„ìš©'),
    max: CurrencyAmountSchema.describe('ìµœëŒ€ ì˜ˆìƒ ë¹„ìš©'),
  })
  .strict();
export type CostEstimate = z.infer<typeof CostEstimateSchema>;

/**
 * ì•¡ì…˜ ì¹´ë“œ (Action Deck).
 * ë§¤ í„´ AIê°€ ì¶”ì²œí•˜ëŠ” í–‰ë™ ì¹´ë“œì…ë‹ˆë‹¤.
 *
 * U-009 í™•ì¥:
 *   - cost_estimate: ìµœì†Œ/ìµœëŒ€ ë¹„ìš© ë²”ìœ„ (RULE-005)
 *   - enabled: ì„œë²„ ì¸¡ ì‹¤í–‰ ê°€ëŠ¥ ì—¬ë¶€ íŒë‹¨ (Q1: Option A)
 *   - disabled_reason: ë¹„í™œì„±í™” ì‚¬ìœ  (ì”ì•¡ ë¶€ì¡± ë“±)
 *   - is_alternative: ì €ë¹„ìš©/í…ìŠ¤íŠ¸-only ëŒ€ì•ˆ ì¹´ë“œ ì—¬ë¶€
 */
export const ActionCardSchema = z
  .object({
    id: z.string().describe('ì¹´ë“œ ê³ ìœ  ID'),
    label: z.string().describe('ì¹´ë“œ ë¼ë²¨ (í‘œì‹œìš©)'),
    description: z.string().nullable().default(null).describe('ì¹´ë“œ ì„¤ëª… (ì„ íƒ)'),
    cost: CurrencyAmountSchema.describe('ì˜ˆìƒ ë¹„ìš© (ê¸°ë³¸)'),
    cost_estimate: CostEstimateSchema.nullable().default(null).describe('ë¹„ìš© ì¶”ì • ë²”ìœ„ (ì„ íƒ)'),
    risk: RiskLevelSchema.default('low').describe('ìœ„í—˜ë„'),
    hint: z.string().nullable().default(null).describe('ì˜ˆìƒ ê²°ê³¼ íŒíŠ¸ (ì„ íƒ)'),
    reward_hint: z.string().nullable().default(null).describe('ë³´ìƒ íŒíŠ¸ (ì„ íƒ)'),
    enabled: z.boolean().default(true).describe('ì‹¤í–‰ ê°€ëŠ¥ ì—¬ë¶€ (ì„œë²„ íŒë‹¨)'),
    disabled_reason: z.string().nullable().default(null).describe('ë¹„í™œì„±í™” ì‚¬ìœ  (ì„ íƒ)'),
    is_alternative: z.boolean().default(false).describe('ì €ë¹„ìš© ëŒ€ì•ˆ ì¹´ë“œ ì—¬ë¶€'),
  })
  .strict();
export type ActionCard = z.infer<typeof ActionCardSchema>;

/**
 * ì¥ë©´ ì˜¤ë¸Œì íŠ¸ (í´ë¦­ ê°€ëŠ¥í•œ í•«ìŠ¤íŒŸ).
 * ì¢Œí‘œëŠ” 0~1000 ì •ê·œí™” ì¢Œí‘œê³„ë¥¼ ì‚¬ìš©í•©ë‹ˆë‹¤ (RULE-009).
 */
export const SceneObjectSchema = z
  .object({
    id: z.string().describe('ì˜¤ë¸Œì íŠ¸ ê³ ìœ  ID'),
    label: z.string().describe('ì˜¤ë¸Œì íŠ¸ ë¼ë²¨ (í‘œì‹œìš©)'),
    box_2d: Box2DSchema.describe('ë°”ìš´ë”© ë°•ìŠ¤'),
    interaction_hint: z.string().nullable().default(null).describe('ìƒí˜¸ì‘ìš© íŒíŠ¸ (ì„ íƒ)'),
  })
  .strict();
export type SceneObject = z.infer<typeof SceneObjectSchema>;

/**
 * ì•¡ì…˜ ë± (Q1 ê²°ì •: ui.action_deck.cards[] êµ¬ì¡°).
 * ë§¤ í„´ AIê°€ ì œì‹œí•˜ëŠ” ì¶”ì²œ í–‰ë™ ì¹´ë“œ ë±ì…ë‹ˆë‹¤.
 */
export const ActionDeckSchema = z
  .object({
    cards: z.array(ActionCardSchema).max(10).default([]).describe('ì•¡ì…˜ ì¹´ë“œ ëª©ë¡ (3~6ì¥ ê¶Œì¥)'),
  })
  .strict();
export type ActionDeck = z.infer<typeof ActionDeckSchema>;

/**
 * Scene í‘œì‹œ ì •ë³´ (RU-003-T1: Scene ì´ë¯¸ì§€ SSOT).
 *
 * TurnOutputì—ì„œ Scene Canvasì— í‘œì‹œí•  ì´ë¯¸ì§€ ì •ë³´ë¥¼ ì œê³µí•©ë‹ˆë‹¤.
 * image_urlì´ ì¡´ì¬í•˜ë©´ SceneCanvasëŠ” 'scene' ìƒíƒœë¡œ ì „í™˜ë©ë‹ˆë‹¤.
 * image_urlì´ ì—†ìœ¼ë©´ 'default' ìƒíƒœë¥¼ ìœ ì§€í•©ë‹ˆë‹¤.
 */
export const SceneOutputSchema = z
  .object({
    image_url: z
      .string()
      .nullable()
      .default(null)
      .describe('Scene ì´ë¯¸ì§€ URL (ì¡´ì¬ ì‹œ scene ìƒíƒœë¡œ ì „í™˜)'),
    alt_text: z.string().nullable().default(null).describe('ì´ë¯¸ì§€ ëŒ€ì²´ í…ìŠ¤íŠ¸ (ì ‘ê·¼ì„±ìš©, ì„ íƒ)'),
  })
  .strict();
export type SceneOutput = z.infer<typeof SceneOutputSchema>;

/**
 * UI ì¶œë ¥ ë°ì´í„°.
 * AIê°€ ìƒì„±í•œ UI ìš”ì†Œë“¤ì…ë‹ˆë‹¤.
 * ì±„íŒ… ë²„ë¸”ì´ ì•„ë‹Œ ê²Œì„ UIë¡œ í‘œí˜„ë©ë‹ˆë‹¤ (RULE-002).
 *
 * RU-003-T1: scene í•„ë“œ ì¶”ê°€ - Scene Canvasì˜ ì´ë¯¸ì§€ í‘œì‹œ ì •ë³´ SSOT.
 */
export const UIOutputSchema = z
  .object({
    action_deck: ActionDeckSchema.default({ cards: [] }).describe('ì•¡ì…˜ ì¹´ë“œ ë±'),
    objects: z.array(SceneObjectSchema).default([]).describe('í´ë¦­ ê°€ëŠ¥í•œ ì¥ë©´ ì˜¤ë¸Œì íŠ¸ ëª©ë¡'),
    scene: SceneOutputSchema.default({ image_url: null, alt_text: null }).describe(
      'Scene í‘œì‹œ ì •ë³´ (RU-003-T1)',
    ),
  })
  .strict();
export type UIOutput = z.infer<typeof UIOutputSchema>;

// =============================================================================
// TurnOutput ê´€ë ¨ íƒ€ì… - World
// =============================================================================

/**
 * ì¤‘ìš” ì„¤ì • ê³ ì • í›„ë³´.
 * ì‚¬ìš©ìê°€ Memory Shardë¥¼ ì†Œë¹„í•´ ê³ ì •í•  ìˆ˜ ìˆëŠ” ì¤‘ìš” ì„¤ì •ì…ë‹ˆë‹¤.
 */
export const MemoryPinSchema = z
  .object({
    id: z.string().describe('í•€ ê³ ìœ  ID'),
    content: z.string().describe('ê³ ì •í•  ë‚´ìš©'),
    cost: CurrencyAmountSchema.describe('ê³ ì •ì— í•„ìš”í•œ ë¹„ìš©'),
  })
  .strict();
export type MemoryPin = z.infer<typeof MemoryPinSchema>;

/**
 * ì„¸ê³„ ê·œì¹™ (Rule Board).
 * í˜„ì¬ ì„¸ê³„ì— ì ìš© ì¤‘ì¸ ë¬¼ë¦¬ ë²•ì¹™ì´ë‚˜ ë©”íƒ€ ê·œì¹™ì…ë‹ˆë‹¤.
 */
export const WorldRuleSchema = z
  .object({
    id: z.string().describe('ê·œì¹™ ê³ ìœ  ID'),
    label: z.string().describe('ê·œì¹™ ì´ë¦„'),
    description: z.string().nullable().default(null).describe('ê·œì¹™ ìƒì„¸ ì„¤ëª… (ì„ íƒ)'),
  })
  .strict();
export type WorldRule = z.infer<typeof WorldRuleSchema>;

/**
 * í€˜ìŠ¤íŠ¸/ëª©í‘œ (Quest Panel).
 * í”Œë ˆì´ì–´ê°€ ë‹¬ì„±í•´ì•¼ í•˜ëŠ” í˜„ì¬ ëª©í‘œì…ë‹ˆë‹¤.
 */
export const QuestSchema = z
  .object({
    id: z.string().describe('í€˜ìŠ¤íŠ¸ ê³ ìœ  ID'),
    label: z.string().describe('í€˜ìŠ¤íŠ¸ ì´ë¦„'),
    is_completed: z.boolean().default(false).describe('ë‹¬ì„± ì—¬ë¶€'),
  })
  .strict();
export type Quest = z.infer<typeof QuestSchema>;

/**
 * ì„¸ê³„ ìƒíƒœ ë³€í™” (Q2 ê²°ì •: Option A - delta ì¤‘ì‹¬).
 * ì´ë²ˆ í„´ì—ì„œ ë³€ê²½ëœ ì„¸ê³„ ìƒíƒœë¥¼ ë‚˜íƒ€ëƒ…ë‹ˆë‹¤.
 */
export const WorldDeltaSchema = z
  .object({
    rules_changed: z.array(WorldRuleSchema).default([]).describe('ë³€ê²½ëœ ê·œì¹™ ëª©ë¡'),
    inventory_added: z.array(z.string()).default([]).describe('ì¶”ê°€ëœ ì¸ë²¤í† ë¦¬ ì•„ì´í…œ'),
    inventory_removed: z.array(z.string()).default([]).describe('ì œê±°ëœ ì¸ë²¤í† ë¦¬ ì•„ì´í…œ'),
    quests_updated: z.array(QuestSchema).default([]).describe('ì—…ë°ì´íŠ¸ëœ í€˜ìŠ¤íŠ¸/ëª©í‘œ ëª©ë¡'),
    relationships_changed: z.array(z.string()).default([]).describe('ë³€ê²½ëœ ê´€ê³„'),
    memory_pins: z.array(MemoryPinSchema).default([]).describe('ì¤‘ìš” ì„¤ì • ê³ ì • í›„ë³´'),
  })
  .strict();
export type WorldDelta = z.infer<typeof WorldDeltaSchema>;

// =============================================================================
// TurnOutput ê´€ë ¨ íƒ€ì… - Render
// =============================================================================

/**
 * ì´ë¯¸ì§€ ìƒì„± ì‘ì—….
 * ì¡°ê±´ë¶€ ì´ë¯¸ì§€ ìƒì„±/í¸ì§‘ ìš”ì²­ì…ë‹ˆë‹¤.
 */
export const ImageJobSchema = z
  .object({
    should_generate: z.boolean().describe('ì´ë¯¸ì§€ë¥¼ ìƒì„±í•´ì•¼ í•˜ëŠ”ì§€'),
    prompt: z.string().default('').describe('ì´ë¯¸ì§€ ìƒì„± í”„ë¡¬í”„íŠ¸'),
    model_label: ModelLabelSchema.default('FAST').describe('ëª¨ë¸ ì„ íƒ ë¼ë²¨'),
    aspect_ratio: z.string().default('16:9').describe('ê°€ë¡œì„¸ë¡œ ë¹„ìœ¨'),
    image_size: z.string().default('1024x1024').describe('ì´ë¯¸ì§€ í¬ê¸°'),
    reference_image_ids: z.array(z.string()).default([]).describe('ì°¸ì¡° ì´ë¯¸ì§€ ID ëª©ë¡ (ì„ íƒ)'),
  })
  .strict();
export type ImageJob = z.infer<typeof ImageJobSchema>;

/**
 * ë Œë”ë§ ì¶œë ¥ ë°ì´í„°.
 * ì´ë¯¸ì§€ ìƒì„±/í¸ì§‘ ê´€ë ¨ ì •ë³´ì…ë‹ˆë‹¤.
 */
export const RenderOutputSchema = z
  .object({
    image_job: ImageJobSchema.nullable().default(null).describe('ì´ë¯¸ì§€ ìƒì„± ì‘ì—… (ì„ íƒ)'),
  })
  .strict();
export type RenderOutput = z.infer<typeof RenderOutputSchema>;

// =============================================================================
// TurnOutput ê´€ë ¨ íƒ€ì… - Economy
// =============================================================================

/**
 * ê²½ì œ ì¶œë ¥ ë°ì´í„° (RULE-005).
 * ì´ë²ˆ í„´ì˜ ë¹„ìš©ê³¼ ì”ì•¡ ì •ë³´ì…ë‹ˆë‹¤.
 * ì”ì•¡ ìŒìˆ˜ëŠ” ì ˆëŒ€ ë¶ˆê°€ (ì„œë²„ Hard gate).
 */
export const EconomyOutputSchema = z
  .object({
    cost: CurrencyAmountSchema.describe('ì´ë²ˆ í„´ì— ì†Œë¹„ëœ ë¹„ìš©'),
    balance_after: CurrencyAmountSchema.describe('ì†Œë¹„ í›„ ì”ì•¡'),
  })
  .strict();
export type EconomyOutput = z.infer<typeof EconomyOutputSchema>;

// =============================================================================
// TurnOutput ê´€ë ¨ íƒ€ì… - Safety
// =============================================================================

/**
 * ì•ˆì „ ì¶œë ¥ ë°ì´í„°.
 * ì•ˆì „ ì •ì±… ê´€ë ¨ ì •ë³´ì…ë‹ˆë‹¤.
 * ì°¨ë‹¨ ì‹œ ëª…ì‹œì  ë©”ì‹œì§€ì™€ í•¨ê»˜ ì•ˆì „í•œ ëŒ€ì²´ ê²°ê³¼ë¥¼ ì œê³µí•©ë‹ˆë‹¤.
 */
export const SafetyOutputSchema = z
  .object({
    blocked: z.boolean().default(false).describe('ì•ˆì „ ì •ì±…ì— ì˜í•´ ì°¨ë‹¨ë˜ì—ˆëŠ”ì§€'),
    message: z
      .string()
      .nullable()
      .default(null)
      .describe('ì°¨ë‹¨ ì‹œ ì‚¬ìš©ìì—ê²Œ í‘œì‹œí•  ë©”ì‹œì§€ (ì„ íƒ)'),
  })
  .strict();
export type SafetyOutput = z.infer<typeof SafetyOutputSchema>;

// =============================================================================
// TurnOutput ê´€ë ¨ íƒ€ì… - Agent Console
// =============================================================================

/**
 * ì—ì´ì „íŠ¸ ì½˜ì†” ë°ì´í„° (RULE-008).
 * ì—ì´ì „íŠ¸í˜• ì‹œìŠ¤í…œì„ì„ UIë¡œ ì¦ëª…í•˜ê¸° ìœ„í•œ ì •ë³´ì…ë‹ˆë‹¤.
 */
export const AgentConsoleSchema = z
  .object({
    current_phase: AgentPhaseSchema.default('commit').describe('í˜„ì¬ ì‹¤í–‰ ë‹¨ê³„'),
    badges: z.array(ValidationBadgeSchema).default([]).describe('ê²€ì¦ ë°°ì§€ ëª©ë¡'),
    repair_count: z.number().int().min(0).default(0).describe('ìë™ ë³µêµ¬ ì‹œë„ íšŸìˆ˜'),
  })
  .strict();
export type AgentConsole = z.infer<typeof AgentConsoleSchema>;

// =============================================================================
// TurnOutput (ë©”ì¸ ì‘ë‹µ ìŠ¤í‚¤ë§ˆ)
// =============================================================================

/**
 * í„´ ì¶œë ¥ (ì„œë²„ â†’ í´ë¼ì´ì–¸íŠ¸).
 * ì„œë²„ê°€ í„´ ì²˜ë¦¬ í›„ í´ë¼ì´ì–¸íŠ¸ë¡œ ë°˜í™˜í•˜ëŠ” êµ¬ì¡°í™”ëœ ì‘ë‹µì…ë‹ˆë‹¤.
 *
 * Hard Gate í•„ë“œ (RULE-003/004/005):
 *   - economy: costì™€ balance_after í•„ìˆ˜, ì”ì•¡ ìŒìˆ˜ ê¸ˆì§€
 *   - safety: blocked ì‹œ ì•ˆì „í•œ ëŒ€ì²´ ê²°ê³¼ ì œê³µ
 *   - language: ìš”ì²­ ì–¸ì–´ì™€ ë™ì¼í•˜ê²Œ ê³ ì • (í˜¼í•© ì¶œë ¥ ê¸ˆì§€)
 */
export const TurnOutputSchema = z
  .object({
    // í•„ìˆ˜ í•„ë“œ (Hard Gate)
    language: LanguageSchema.describe('ì‘ë‹µ ì–¸ì–´ (ìš”ì²­ê³¼ ë™ì¼)'),
    narrative: z.string().describe('ë‚´ëŸ¬í‹°ë¸Œ í…ìŠ¤íŠ¸ (í‘œì‹œìš©)'),
    economy: EconomyOutputSchema.describe('ê²½ì œ ì •ë³´ (ë¹„ìš©, ì”ì•¡)'),
    safety: SafetyOutputSchema.describe('ì•ˆì „ ì •ì±… ì •ë³´'),

    // UI ê´€ë ¨ í•„ë“œ (RU-003-T1: scene í•„ë“œ ì¶”ê°€)
    ui: UIOutputSchema.default({
      action_deck: { cards: [] },
      objects: [],
      scene: { image_url: null, alt_text: null },
    }).describe('UI ìš”ì†Œ'),

    // ì„¸ê³„ ìƒíƒœ í•„ë“œ
    world: WorldDeltaSchema.default({
      rules_changed: [],
      inventory_added: [],
      inventory_removed: [],
      quests_updated: [],
      relationships_changed: [],
      memory_pins: [],
    }).describe('ì„¸ê³„ ìƒíƒœ ë³€í™” (delta)'),

    // ë Œë”ë§ í•„ë“œ
    render: RenderOutputSchema.default({ image_job: null }).describe('ë Œë”ë§ ì •ë³´'),

    // ì—ì´ì „íŠ¸ ì½˜ì†” í•„ë“œ
    agent_console: AgentConsoleSchema.default({
      current_phase: 'commit',
      badges: [],
      repair_count: 0,
    }).describe('ì—ì´ì „íŠ¸ ì‹¤í–‰ ì •ë³´'),
  })
  .strict();
export type TurnOutput = z.infer<typeof TurnOutputSchema>;

// =============================================================================
// ì•ˆì „ í´ë°± (RULE-004)
// =============================================================================

/**
 * ê²€ì¦ ì‹¤íŒ¨ ì‹œ ì œê³µë˜ëŠ” ì•ˆì „ í´ë°± TurnOutput.
 * UIê°€ ë©ˆì¶”ì§€ ì•Šë„ë¡ ìµœì†Œí•œì˜ ì •ë³´ë¥¼ ì œê³µí•©ë‹ˆë‹¤.
 *
 * @param language - ìš”ì²­ ì–¸ì–´
 * @param repairCount - ë³µêµ¬ ì‹œë„ íšŸìˆ˜
 * @param errorMessage - ì˜¤ë¥˜ ë©”ì‹œì§€ (ì„ íƒ)
 */
export function createFallbackTurnOutput(
  language: Language,
  repairCount: number = 0,
  errorMessage?: string,
): TurnOutput {
  const fallbackNarrative =
    language === 'ko-KR'
      ? '[ì‹œìŠ¤í…œ] ì‘ë‹µì„ ì²˜ë¦¬í•˜ëŠ” ì¤‘ ë¬¸ì œê°€ ë°œìƒí–ˆìŠµë‹ˆë‹¤. ë‹¤ì‹œ ì‹œë„í•´ ì£¼ì„¸ìš”.'
      : '[System] An error occurred while processing the response. Please try again.';

  const safetyMessage =
    language === 'ko-KR'
      ? 'ìŠ¤í‚¤ë§ˆ ê²€ì¦ ì‹¤íŒ¨ë¡œ ì¸í•œ í´ë°± ì‘ë‹µì…ë‹ˆë‹¤.'
      : 'This is a fallback response due to schema validation failure.';

  return {
    language,
    narrative: errorMessage ?? fallbackNarrative,
    economy: {
      cost: { signal: 0, memory_shard: 0 },
      balance_after: { signal: 0, memory_shard: 0 },
    },
    safety: {
      blocked: false,
      message: safetyMessage,
    },
    ui: {
      action_deck: { cards: [] },
      objects: [],
      scene: { image_url: null, alt_text: null },
    },
    world: {
      rules_changed: [],
      inventory_added: [],
      inventory_removed: [],
      quests_updated: [],
      relationships_changed: [],
      memory_pins: [],
    },
    render: {
      image_job: null,
    },
    agent_console: {
      current_phase: 'commit',
      badges: ['schema_fail'],
      repair_count: repairCount,
    },
  };
}

// =============================================================================
// ê²€ì¦ í—¬í¼ í•¨ìˆ˜
// =============================================================================

/**
 * TurnOutput ê²€ì¦ ê²°ê³¼ íƒ€ì….
 */
export type TurnOutputParseResult =
  | { success: true; data: TurnOutput }
  | { success: false; error: z.ZodError; fallback: TurnOutput };

/**
 * TurnOutputì„ ì•ˆì „í•˜ê²Œ íŒŒì‹±í•©ë‹ˆë‹¤.
 * ì‹¤íŒ¨ ì‹œ í´ë°± TurnOutputì„ ë°˜í™˜í•©ë‹ˆë‹¤ (RULE-004).
 *
 * @param data - íŒŒì‹±í•  ë°ì´í„°
 * @param language - í´ë°± ì‹œ ì‚¬ìš©í•  ì–¸ì–´ (ê¸°ë³¸: ko-KR)
 * @param repairCount - í˜„ì¬ ë³µêµ¬ ì‹œë„ íšŸìˆ˜
 */
export function safeParseTurnOutput(
  data: unknown,
  language: Language = 'ko-KR',
  repairCount: number = 0,
): TurnOutputParseResult {
  const result = TurnOutputSchema.safeParse(data);

  if (result.success) {
    return { success: true, data: result.data };
  }

  return {
    success: false,
    error: result.error,
    fallback: createFallbackTurnOutput(language, repairCount),
  };
}

/**
 * TurnInputì„ ê²€ì¦í•©ë‹ˆë‹¤.
 * ì…ë ¥ ë°ì´í„°ì˜ ìœ íš¨ì„±ì„ ì—„ê²©í•˜ê²Œ ê²€ì‚¬í•©ë‹ˆë‹¤.
 *
 * @param data - ê²€ì¦í•  ë°ì´í„°
 * @throws {z.ZodError} ê²€ì¦ ì‹¤íŒ¨ ì‹œ
 */
export function parseTurnInput(data: unknown): TurnInput {
  return TurnInputSchema.parse(data);
}

/**
 * TurnInput ì•ˆì „ íŒŒì‹± ê²°ê³¼ íƒ€ì….
 */
export type TurnInputSafeParseResult = ReturnType<typeof TurnInputSchema.safeParse>;

/**
 * TurnInputì„ ì•ˆì „í•˜ê²Œ íŒŒì‹±í•©ë‹ˆë‹¤.
 *
 * @param data - íŒŒì‹±í•  ë°ì´í„°
 */
export function safeParseTurnInput(data: unknown): TurnInputSafeParseResult {
  return TurnInputSchema.safeParse(data);
}
</file>

<file path="frontend/src/stores/worldStore.ts">
/**
 * Unknown World - World/Session ìƒíƒœ ê´€ë¦¬ (Zustand) (RU-003-Q4).
 *
 * TurnOutput ë°˜ì˜ìœ¼ë¡œ ê°±ì‹ ë˜ëŠ” ì„¸ì…˜ ì›”ë“œ/UI ìƒíƒœë¥¼ SSOTë¡œ ê´€ë¦¬í•©ë‹ˆë‹¤.
 * App.tsxì˜ ë¡œì»¬ ìƒíƒœë¥¼ ì´ ìŠ¤í† ì–´ë¡œ ì´ë™í•˜ì—¬ ì±…ì„ ê²½ê³„ë¥¼ ëª…í™•íˆ í•©ë‹ˆë‹¤.
 *
 * ì„¤ê³„ ì›ì¹™:
 *   - RU-003 Q1 ê²°ì •: ë„ë©”ì¸ë³„ store ë¶„ë¦¬ (Option A)
 *   - RULE-005: Economy ì¸ë°”ë¦¬ì–¸íŠ¸ (ì”ì•¡ ìŒìˆ˜ ê¸ˆì§€)
 *   - RULE-006: ko/en i18n ì •ì±… ì¤€ìˆ˜
 *
 * í™•ì¥ (U-013):
 *   - Quest/Rules/MutationEvent ìƒíƒœ ì¶”ê°€
 *   - applyTurnOutputì—ì„œ quests_updated, rules_changed ë°˜ì˜
 *
 * ìˆœí™˜ import ë°©ì§€:
 *   - worldStore â†’ (actionDeckStore/inventoryStore) ë‹¨ë°©í–¥ë§Œ í—ˆìš©
 *   - ì—­ë°©í–¥ import ê¸ˆì§€
 *
 * @module stores/worldStore
 */

import { create } from 'zustand';
import type { TurnOutput, SceneObject, Quest, WorldRule } from '../schemas/turn';
import type { SceneCanvasState } from '../types/scene';
import { useActionDeckStore } from './actionDeckStore';
import { useInventoryStore, parseInventoryAdded } from './inventoryStore';
import { useEconomyStore } from './economyStore';

// =============================================================================
// íƒ€ì… ì •ì˜
// =============================================================================

/** ì¬í™” ìƒíƒœ */
export interface EconomyState {
  signal: number;
  memory_shard: number;
}

/** ë‚´ëŸ¬í‹°ë¸Œ ì—”íŠ¸ë¦¬ */
export interface NarrativeEntry {
  turn: number;
  text: string;
}

/**
 * ë£° ë³€í˜• ì´ë²¤íŠ¸ (U-013: Mutation Timeline)
 * ê·œì¹™ì´ ë³€ê²½ëœ ì‹œì ê³¼ ë‚´ìš©ì„ ê¸°ë¡í•©ë‹ˆë‹¤.
 */
export interface MutationEvent {
  /** ë³€í˜• ë°œìƒ í„´ */
  turn: number;
  /** ë³€í˜•ëœ ê·œì¹™ ID */
  ruleId: string;
  /** ë³€í˜• ìœ í˜•: ì¶”ê°€/ìˆ˜ì •/ì œê±° */
  type: 'added' | 'modified' | 'removed';
  /** ê·œì¹™ ë¼ë²¨ (í‘œì‹œìš©) */
  label: string;
  /** ê·œì¹™ ì„¤ëª… (ì„ íƒ) */
  description?: string;
  /** íƒ€ì„ìŠ¤íƒ¬í”„ */
  timestamp: number;
}

/** World/Session ìƒíƒœ */
export interface WorldState {
  /** ì¬í™” ìƒíƒœ (RULE-005) */
  economy: EconomyState;
  /** ì—°ê²° ìƒíƒœ */
  isConnected: boolean;
  /** Scene Canvas ìƒíƒœ (U-031) */
  sceneState: SceneCanvasState;
  /** Scene Objects (U-010: í•«ìŠ¤íŒŸ ì˜¤ë²„ë ˆì´) */
  sceneObjects: SceneObject[];
  /** ë‚´ëŸ¬í‹°ë¸Œ íˆìŠ¤í† ë¦¬ */
  narrativeEntries: NarrativeEntry[];
  /** í˜„ì¬ í„´ ì¹´ìš´íŠ¸ */
  turnCount: number;

  // ============ U-013: Quest + Rule Board í™•ì¥ ============

  /** í˜„ì¬ í€˜ìŠ¤íŠ¸/ëª©í‘œ ëª©ë¡ */
  quests: Quest[];
  /** í˜„ì¬ ì ìš© ì¤‘ì¸ ê·œì¹™ ëª©ë¡ */
  activeRules: WorldRule[];
  /** ë£° ë³€í˜• ì´ë²¤íŠ¸ íƒ€ì„ë¼ì¸ (ìµœì‹ ìˆœ) */
  mutationTimeline: MutationEvent[];
}

/** World Store ì•¡ì…˜ */
export interface WorldActions {
  /**
   * TurnOutputì„ ë°›ì•„ ëª¨ë“  ê´€ë ¨ ìƒíƒœë¥¼ ì—…ë°ì´íŠ¸í•©ë‹ˆë‹¤.
   * ì´ ë©”ì„œë“œê°€ TurnOutput ë°˜ì˜ì˜ SSOTì…ë‹ˆë‹¤.
   */
  applyTurnOutput: (output: TurnOutput) => void;

  /**
   * ì‹œìŠ¤í…œ ë‚´ëŸ¬í‹°ë¸Œë¥¼ ì¶”ê°€í•©ë‹ˆë‹¤ (í„´ ë¯¸ë°œìƒ í”¼ë“œë°±ìš©).
   * ë“œë¡­ ì‹¤íŒ¨ ë“± í„´ì„ ë°œìƒì‹œí‚¤ì§€ ì•ŠëŠ” í”¼ë“œë°±ì— ì‚¬ìš©í•©ë‹ˆë‹¤.
   */
  appendSystemNarrative: (text: string) => void;

  /** Scene ìƒíƒœ ì„¤ì • */
  setSceneState: (state: SceneCanvasState) => void;

  /** ì—°ê²° ìƒíƒœ ì„¤ì • */
  setConnected: (connected: boolean) => void;

  /** ê²½ì œ ìƒíƒœ ì„¤ì • (ì§ì ‘ ì¡°ì‘ìš©, ì¼ë°˜ì ìœ¼ë¡œ applyTurnOutput ì‚¬ìš©) */
  setEconomy: (economy: EconomyState) => void;

  /** Scene Objects ì„¤ì • (ì§ì ‘ ì¡°ì‘ìš©) */
  setSceneObjects: (objects: SceneObject[]) => void;

  /** ì´ˆê¸°í™” (ì´ˆê¸° ë‚´ëŸ¬í‹°ë¸Œ ë©”ì‹œì§€ í¬í•¨) */
  initialize: (welcomeMessage: string) => void;

  /** ìƒíƒœ ì™„ì „ ì´ˆê¸°í™” */
  reset: () => void;
}

export type WorldStore = WorldState & WorldActions;

// =============================================================================
// ì´ˆê¸° ìƒíƒœ
// =============================================================================

/**
 * ì´ˆê¸° ìƒíƒœë¥¼ ìƒì„±í•©ë‹ˆë‹¤.
 *
 * RU-004-Q5: ì´ˆê¸°ê°’ ì •ì±… SSOT
 *
 * ## ì¤‘ìš”: ì´ ê°’ë“¤ì€ "í”Œë ˆì´ ì „ placeholder"ì…ë‹ˆë‹¤.
 *
 * ì‹¤ì œ ê²Œì„ ì‹œì‘ ê°’ì€ í•­ìƒ ë‹¤ìŒ ì¤‘ í•˜ë‚˜ì—ì„œ ì£¼ì…ë©ë‹ˆë‹¤:
 * 1. í”„ë¡œí•„ ì´ˆê¸° SaveGame (startSessionFromProfile)
 * 2. ì €ì¥ëœ SaveGame ë³µì› (continueSession)
 *
 * profile_select ìƒíƒœì—ì„œëŠ” HUDê°€ ë…¸ì¶œë˜ì§€ ì•Šìœ¼ë¯€ë¡œ
 * ì´ placeholder ê°’ì´ í™”ë©´ì— í‘œì‹œë  ì¼ì€ ì—†ìŠµë‹ˆë‹¤.
 *
 * @see save/constants.ts#INITIAL_VALUE_POLICY
 * @see save/sessionLifecycle.ts
 */
function createInitialState(): WorldState {
  return {
    // RU-004-Q5: Placeholder - ì‹¤ì œ ê°’ì€ í”„ë¡œí•„/ì„¸ì´ë¸Œì—ì„œ ì£¼ì…ë¨
    economy: { signal: 100, memory_shard: 5 },
    isConnected: true,
    sceneState: { status: 'default', message: '' },
    sceneObjects: [],
    narrativeEntries: [],
    turnCount: 0,
    // U-013: Quest + Rule Board ì´ˆê¸° ìƒíƒœ
    quests: [],
    activeRules: [],
    mutationTimeline: [],
  };
}

// =============================================================================
// Zustand Store
// =============================================================================

/**
 * World/Session ìƒíƒœ ìŠ¤í† ì–´.
 *
 * TurnOutput ë°˜ì˜ì˜ SSOTë¡œ, App.tsxì˜ ë¡œì»¬ ìƒíƒœë¥¼ ëŒ€ì²´í•©ë‹ˆë‹¤.
 *
 * @example
 * ```tsx
 * // ì»´í¬ë„ŒíŠ¸ì—ì„œ ìƒíƒœ êµ¬ë…
 * const { economy, narrativeEntries } = useWorldStore();
 *
 * // TurnOutput ë°˜ì˜ (ìŠ¤íŠ¸ë¦¼ ì™„ë£Œ ì‹œ)
 * const applyTurnOutput = useWorldStore((state) => state.applyTurnOutput);
 * applyTurnOutput(turnOutput);
 *
 * // ì‹œìŠ¤í…œ í”¼ë“œë°± ì¶”ê°€ (ë“œë¡­ ì‹¤íŒ¨ ë“±)
 * const appendSystemNarrative = useWorldStore((state) => state.appendSystemNarrative);
 * appendSystemNarrative('ì•„ì´í…œì„ ì‚¬ìš©í•  ìˆ˜ ì—†ìŠµë‹ˆë‹¤.');
 * ```
 */
export const useWorldStore = create<WorldStore>((set, get) => ({
  // ì´ˆê¸° ìƒíƒœ
  ...createInitialState(),

  // ì•¡ì…˜

  applyTurnOutput: (output) => {
    const state = get();

    // 1. í„´ ì¹´ìš´íŠ¸ ì¦ê°€
    const newTurnCount = state.turnCount + 1;

    // 2. ë‚´ëŸ¬í‹°ë¸Œ ì¶”ê°€
    const newNarrativeEntry: NarrativeEntry = {
      turn: newTurnCount,
      text: output.narrative,
    };

    // 3. ê²½ì œ ìƒíƒœ ì—…ë°ì´íŠ¸ (RULE-005: balance_after ë°˜ì˜)
    const newEconomy: EconomyState = {
      signal: output.economy.balance_after.signal,
      memory_shard: output.economy.balance_after.memory_shard,
    };

    // 4. Scene Objects ì—…ë°ì´íŠ¸ (U-010: í•«ìŠ¤íŒŸ ì˜¤ë²„ë ˆì´)
    const newSceneObjects = output.ui.objects;

    // 5. Scene ìƒíƒœ ì „ì´ (RU-003-T1: Scene ì´ë¯¸ì§€ SSOT)
    // - output.ui.scene.image_urlì´ ì¡´ì¬í•˜ë©´ 'scene' ìƒíƒœë¡œ ì „í™˜
    // - ì—†ìœ¼ë©´ 'default' ìƒíƒœ ìœ ì§€
    // - safety.blockedì¸ ê²½ìš° 'blocked' ìƒíƒœë¡œ ì „í™˜
    let newSceneState: SceneCanvasState;
    if (output.safety.blocked) {
      newSceneState = {
        status: 'blocked',
        message: output.safety.message ?? undefined,
      };
    } else if (output.ui.scene?.image_url) {
      newSceneState = {
        status: 'scene',
        imageUrl: output.ui.scene.image_url,
        message: output.ui.scene.alt_text ?? undefined,
      };
    } else {
      newSceneState = {
        status: 'default',
        message: '',
      };
    }

    // 7. í•˜ìœ„ ìŠ¤í† ì–´ ì—…ë°ì´íŠ¸ (ìˆœí™˜ import ë°©ì§€: worldStore â†’ í•˜ìœ„ store ë‹¨ë°©í–¥)
    // Action Deck ì¹´ë“œ ì—…ë°ì´íŠ¸ (U-009)
    useActionDeckStore.getState().setCards(output.ui.action_deck.cards);

    // Inventory ì—…ë°ì´íŠ¸ (U-011)
    if (output.world.inventory_added.length > 0) {
      useInventoryStore.getState().addItems(parseInventoryAdded(output.world.inventory_added));
    }
    if (output.world.inventory_removed.length > 0) {
      useInventoryStore.getState().removeItems(output.world.inventory_removed);
    }

    // Economy Store ì—…ë°ì´íŠ¸ (U-014: Ledger ê¸°ë¡)
    const economyStore = useEconomyStore.getState();
    economyStore.addLedgerEntry({
      turnId: newTurnCount,
      reason: output.narrative.slice(0, 50), // ë‚´ëŸ¬í‹°ë¸Œ ì• 50ìë¥¼ ì‚¬ìœ ë¡œ ì‚¬ìš©
      cost: output.economy.cost,
      balanceAfter: output.economy.balance_after,
      modelLabel: output.agent_console.badges.includes('schema_ok') ? 'QUALITY' : 'FAST',
    });
    // ì”ì•¡ ë¶€ì¡± ìƒíƒœ ì—…ë°ì´íŠ¸
    economyStore.updateBalanceLowStatus(newEconomy);

    // 6. Quest ìƒíƒœ ì—…ë°ì´íŠ¸ (U-013)
    // quests_updatedëŠ” ì „ì²´ í€˜ìŠ¤íŠ¸ ëª©ë¡ì´ ì•„ë‹Œ "ì—…ë°ì´íŠ¸ëœ" í€˜ìŠ¤íŠ¸ë§Œ í¬í•¨
    // ê¸°ì¡´ í€˜ìŠ¤íŠ¸ë¥¼ ì—…ë°ì´íŠ¸í•˜ê±°ë‚˜ ìƒˆ í€˜ìŠ¤íŠ¸ë¥¼ ì¶”ê°€
    const newQuests = [...state.quests];
    for (const updatedQuest of output.world.quests_updated) {
      const existingIndex = newQuests.findIndex((q) => q.id === updatedQuest.id);
      if (existingIndex >= 0) {
        // ê¸°ì¡´ í€˜ìŠ¤íŠ¸ ì—…ë°ì´íŠ¸
        newQuests[existingIndex] = updatedQuest;
      } else {
        // ìƒˆ í€˜ìŠ¤íŠ¸ ì¶”ê°€
        newQuests.push(updatedQuest);
      }
    }

    // 7. Rules ìƒíƒœ ì—…ë°ì´íŠ¸ + Mutation Timeline ê¸°ë¡ (U-013)
    const newActiveRules = [...state.activeRules];
    const newMutationEvents: MutationEvent[] = [];
    const now = Date.now();

    for (const changedRule of output.world.rules_changed) {
      const existingIndex = newActiveRules.findIndex((r) => r.id === changedRule.id);
      if (existingIndex >= 0) {
        // ê¸°ì¡´ ê·œì¹™ ìˆ˜ì •
        newActiveRules[existingIndex] = changedRule;
        newMutationEvents.push({
          turn: newTurnCount,
          ruleId: changedRule.id,
          type: 'modified',
          label: changedRule.label,
          description: changedRule.description ?? undefined,
          timestamp: now,
        });
      } else {
        // ìƒˆ ê·œì¹™ ì¶”ê°€
        newActiveRules.push(changedRule);
        newMutationEvents.push({
          turn: newTurnCount,
          ruleId: changedRule.id,
          type: 'added',
          label: changedRule.label,
          description: changedRule.description ?? undefined,
          timestamp: now,
        });
      }
    }

    // íƒ€ì„ë¼ì¸ì— ìƒˆ ì´ë²¤íŠ¸ ì¶”ê°€ (ìµœì‹ ìˆœ ì •ë ¬)
    const updatedTimeline = [...newMutationEvents, ...state.mutationTimeline];

    // 8. ìƒíƒœ ì—…ë°ì´íŠ¸ (RU-003-T1: sceneState í¬í•¨, U-013: quest/rules)
    set({
      turnCount: newTurnCount,
      narrativeEntries: [...state.narrativeEntries, newNarrativeEntry],
      economy: newEconomy,
      sceneObjects: newSceneObjects,
      sceneState: newSceneState,
      // U-013 í™•ì¥
      quests: newQuests,
      activeRules: newActiveRules,
      mutationTimeline: updatedTimeline,
    });

    // === í–¥í›„ í™•ì¥ ìŠ¬ë¡¯ (RU-003-Q4 Step 4) ===
    // TODO: output.world.memory_pins â†’ Memory Pin íŒ¨ë„ ì—…ë°ì´íŠ¸
  },

  appendSystemNarrative: (text) => {
    set((state) => ({
      narrativeEntries: [
        ...state.narrativeEntries,
        {
          turn: state.turnCount, // í˜„ì¬ í„´ìœ¼ë¡œ ê¸°ë¡ (í„´ ì¦ê°€ ì—†ìŒ)
          text,
        },
      ],
    }));
  },

  setSceneState: (sceneState) => {
    set({ sceneState });
  },

  setConnected: (isConnected) => {
    set({ isConnected });
  },

  setEconomy: (economy) => {
    set({ economy });
  },

  setSceneObjects: (sceneObjects) => {
    set({ sceneObjects });
  },

  initialize: (welcomeMessage) => {
    set({
      ...createInitialState(),
      narrativeEntries: [{ turn: 0, text: welcomeMessage }],
    });
  },

  reset: () => {
    set(createInitialState());
  },
}));

// =============================================================================
// ì…€ë ‰í„° (ì„±ëŠ¥ ìµœì í™”ìš©)
// =============================================================================

/** ê²½ì œ ìƒíƒœ ì…€ë ‰í„° */
export const selectEconomy = (state: WorldStore) => state.economy;

/** Signal ì”ì•¡ ì…€ë ‰í„° */
export const selectSignal = (state: WorldStore) => state.economy.signal;

/** Memory Shard ì”ì•¡ ì…€ë ‰í„° */
export const selectMemoryShard = (state: WorldStore) => state.economy.memory_shard;

/** ì—°ê²° ìƒíƒœ ì…€ë ‰í„° */
export const selectIsConnected = (state: WorldStore) => state.isConnected;

/** Scene ìƒíƒœ ì…€ë ‰í„° */
export const selectSceneState = (state: WorldStore) => state.sceneState;

/** Scene Objects ì…€ë ‰í„° */
export const selectSceneObjects = (state: WorldStore) => state.sceneObjects;

/** ë‚´ëŸ¬í‹°ë¸Œ ì—”íŠ¸ë¦¬ ì…€ë ‰í„° */
export const selectNarrativeEntries = (state: WorldStore) => state.narrativeEntries;

/** í„´ ì¹´ìš´íŠ¸ ì…€ë ‰í„° */
export const selectTurnCount = (state: WorldStore) => state.turnCount;

// ============ U-013: Quest + Rule Board ì…€ë ‰í„° ============

/** í€˜ìŠ¤íŠ¸ ëª©ë¡ ì…€ë ‰í„° */
export const selectQuests = (state: WorldStore) => state.quests;

/** í™œì„± ê·œì¹™ ëª©ë¡ ì…€ë ‰í„° */
export const selectActiveRules = (state: WorldStore) => state.activeRules;

/** ë®¤í…Œì´ì…˜ íƒ€ì„ë¼ì¸ ì…€ë ‰í„° */
export const selectMutationTimeline = (state: WorldStore) => state.mutationTimeline;

/** ì§„í–‰ ì¤‘ì¸ í€˜ìŠ¤íŠ¸ ì…€ë ‰í„° */
export const selectActiveQuests = (state: WorldStore) =>
  state.quests.filter((q) => !q.is_completed);

/** ì™„ë£Œëœ í€˜ìŠ¤íŠ¸ ì…€ë ‰í„° */
export const selectCompletedQuests = (state: WorldStore) =>
  state.quests.filter((q) => q.is_completed);
</file>

<file path="package.json">
{
  "name": "unknown-world",
  "version": "0.1.0",
  "private": true,
  "description": "Unknown World - Gemini ê¸°ë°˜ ì—ì´ì „íŠ¸í˜• ê²Œì„ ì—”ì§„",
  "packageManager": "pnpm@10.27.0",
  "engines": {
    "node": "24.12.0"
  },
  "scripts": {
    "kill": "pnpm kill:port",
    "kill:port": "npx --yes kill-port 8001 8002 8003 8004 8005 8006 8007 8008 8009 8010 8011 8012 8013 8014 8015 8016 8017 8018 8019 8020",
    "kill:front": "npx --yes kill-port 8001 8002 8003 8004 8005 8006 8007 8008 8009 8010",
    "kill:back": "npx --yes kill-port 8011 8012 8013 8014 8015 8016 8017 8018 8019 8020",
    "dev:back": "cd backend && uv run uvicorn unknown_world.main:app --reload --port 8011",
    "dev:front": "pnpm -C frontend dev"
  }
}
</file>

<file path="shared/schemas/turn/turn_output.schema.json">
{
  "$defs": {
    "ActionCard": {
      "additionalProperties": false,
      "description": "ì•¡ì…˜ ì¹´ë“œ (Action Deck).\n\në§¤ í„´ AIê°€ ì¶”ì²œí•˜ëŠ” í–‰ë™ ì¹´ë“œì…ë‹ˆë‹¤.\nê° ì¹´ë“œì— ë¹„ìš©/ìœ„í—˜/ë³´ìƒ íŒíŠ¸ê°€ í¬í•¨ë©ë‹ˆë‹¤.\n\nAttributes:\n    id: ì¹´ë“œ ê³ ìœ  ID\n    label: ì¹´ë“œ ë¼ë²¨ (í‘œì‹œìš©)\n    description: ì¹´ë“œ ì„¤ëª… (ì„ íƒ)\n    cost: ì˜ˆìƒ ë¹„ìš©\n    risk: ìœ„í—˜ë„\n    hint: ì˜ˆìƒ ê²°ê³¼ íŒíŠ¸ (ì„ íƒ)",
      "properties": {
        "id": {
          "description": "ì¹´ë“œ ê³ ìœ  ID",
          "title": "Id",
          "type": "string"
        },
        "label": {
          "description": "ì¹´ë“œ ë¼ë²¨ (í‘œì‹œìš©)",
          "title": "Label",
          "type": "string"
        },
        "description": {
          "anyOf": [
            {
              "type": "string"
            },
            {
              "type": "null"
            }
          ],
          "default": null,
          "description": "ì¹´ë“œ ì„¤ëª… (ì„ íƒ)",
          "title": "Description"
        },
        "cost": {
          "$ref": "#/$defs/CurrencyAmount",
          "description": "ì˜ˆìƒ ë¹„ìš©"
        },
        "risk": {
          "$ref": "#/$defs/RiskLevel",
          "default": "low",
          "description": "ìœ„í—˜ë„"
        },
        "hint": {
          "anyOf": [
            {
              "type": "string"
            },
            {
              "type": "null"
            }
          ],
          "default": null,
          "description": "ì˜ˆìƒ ê²°ê³¼ íŒíŠ¸ (ì„ íƒ)",
          "title": "Hint"
        }
      },
      "required": [
        "id",
        "label",
        "cost"
      ],
      "title": "ActionCard",
      "type": "object"
    },
    "ActionDeck": {
      "additionalProperties": false,
      "description": "ì•¡ì…˜ ë± (Q1 ê²°ì •: ui.action_deck.cards[] êµ¬ì¡°).\n\në§¤ í„´ AIê°€ ì œì‹œí•˜ëŠ” ì¶”ì²œ í–‰ë™ ì¹´ë“œ ë±ì…ë‹ˆë‹¤.\n\nAttributes:\n    cards: ì•¡ì…˜ ì¹´ë“œ ëª©ë¡ (3~6ì¥ ê¶Œì¥)",
      "properties": {
        "cards": {
          "default": [],
          "description": "ì•¡ì…˜ ì¹´ë“œ ëª©ë¡ (3~6ì¥ ê¶Œì¥)",
          "items": {
            "$ref": "#/$defs/ActionCard"
          },
          "maxItems": 10,
          "minItems": 0,
          "title": "Cards",
          "type": "array"
        }
      },
      "title": "ActionDeck",
      "type": "object"
    },
    "AgentConsole": {
      "additionalProperties": false,
      "description": "ì—ì´ì „íŠ¸ ì½˜ì†” ë°ì´í„° (RULE-008).\n\nì—ì´ì „íŠ¸í˜• ì‹œìŠ¤í…œì„ì„ UIë¡œ ì¦ëª…í•˜ê¸° ìœ„í•œ ì •ë³´ì…ë‹ˆë‹¤.\nê³„íš/ì‹¤í–‰/ê²€ì¦/ë³µêµ¬ì˜ í”ì ì„ í‘œì‹œí•©ë‹ˆë‹¤.\n\nAttributes:\n    current_phase: í˜„ì¬ ì‹¤í–‰ ë‹¨ê³„\n    badges: ê²€ì¦ ë°°ì§€ ëª©ë¡\n    repair_count: ìë™ ë³µêµ¬ ì‹œë„ íšŸìˆ˜",
      "properties": {
        "current_phase": {
          "$ref": "#/$defs/AgentPhase",
          "default": "commit",
          "description": "í˜„ì¬ ì‹¤í–‰ ë‹¨ê³„"
        },
        "badges": {
          "default": [],
          "description": "ê²€ì¦ ë°°ì§€ ëª©ë¡",
          "items": {
            "$ref": "#/$defs/ValidationBadge"
          },
          "title": "Badges",
          "type": "array"
        },
        "repair_count": {
          "default": 0,
          "description": "ìë™ ë³µêµ¬ ì‹œë„ íšŸìˆ˜",
          "minimum": 0,
          "title": "Repair Count",
          "type": "integer"
        }
      },
      "title": "AgentConsole",
      "type": "object"
    },
    "AgentPhase": {
      "description": "ì—ì´ì „íŠ¸ ì‹¤í–‰ ë‹¨ê³„ (RULE-008).\n\nì—ì´ì „íŠ¸í˜• ì‹œìŠ¤í…œì„ì„ UIë¡œ ì¦ëª…í•˜ê¸° ìœ„í•œ ë‹¨ê³„ í‘œì‹œ.",
      "enum": [
        "parse",
        "validate",
        "plan",
        "resolve",
        "render",
        "verify",
        "commit"
      ],
      "title": "AgentPhase",
      "type": "string"
    },
    "Box2D": {
      "additionalProperties": false,
      "description": "2D ë°”ìš´ë”© ë°•ìŠ¤ (RULE-009).\n\nì¢Œí‘œëŠ” 0~1000 ì •ê·œí™” ì¢Œí‘œê³„ì´ë©°, bboxëŠ” [ymin, xmin, ymax, xmax] ìˆœì„œì…ë‹ˆë‹¤.\nì´ë¯¸ì§€ ì´í•´ bbox í¬ë§·ê³¼ í˜¸í™˜ë©ë‹ˆë‹¤.\n\nAttributes:\n    ymin: Y ìµœì†Œê°’ (ìƒë‹¨)\n    xmin: X ìµœì†Œê°’ (ì¢Œì¸¡)\n    ymax: Y ìµœëŒ€ê°’ (í•˜ë‹¨)\n    xmax: X ìµœëŒ€ê°’ (ìš°ì¸¡)",
      "properties": {
        "ymin": {
          "description": "ì •ê·œí™” ì¢Œí‘œ (0~1000)",
          "maximum": 1000,
          "minimum": 0,
          "title": "Ymin",
          "type": "integer"
        },
        "xmin": {
          "description": "ì •ê·œí™” ì¢Œí‘œ (0~1000)",
          "maximum": 1000,
          "minimum": 0,
          "title": "Xmin",
          "type": "integer"
        },
        "ymax": {
          "description": "ì •ê·œí™” ì¢Œí‘œ (0~1000)",
          "maximum": 1000,
          "minimum": 0,
          "title": "Ymax",
          "type": "integer"
        },
        "xmax": {
          "description": "ì •ê·œí™” ì¢Œí‘œ (0~1000)",
          "maximum": 1000,
          "minimum": 0,
          "title": "Xmax",
          "type": "integer"
        }
      },
      "required": [
        "ymin",
        "xmin",
        "ymax",
        "xmax"
      ],
      "title": "Box2D",
      "type": "object"
    },
    "CurrencyAmount": {
      "additionalProperties": false,
      "description": "ì¬í™” ìˆ˜ëŸ‰.\n\nAttributes:\n    signal: ê¸°ë³¸ ì¬í™” (í…ìŠ¤íŠ¸ í„´/ì´ë¯¸ì§€ ìƒì„±/ê³ ê¸‰ ê¸°ëŠ¥ì— ì†Œë¹„)\n    memory_shard: í¬ê·€ ì¬í™” (ì¤‘ìš” ì„¤ì • ê³ ì •, ê³ í•´ìƒë„ ì´ë¯¸ì§€ ë“±ì— ì†Œë¹„)",
      "properties": {
        "signal": {
          "description": "ì‹œê·¸ë„ (ê¸°ë³¸ ì¬í™”, 0 ì´ìƒ)",
          "minimum": 0,
          "title": "Signal",
          "type": "integer"
        },
        "memory_shard": {
          "description": "ê¸°ì–µ íŒŒí¸ (í¬ê·€ ì¬í™”, 0 ì´ìƒ)",
          "minimum": 0,
          "title": "Memory Shard",
          "type": "integer"
        }
      },
      "required": [
        "signal",
        "memory_shard"
      ],
      "title": "CurrencyAmount",
      "type": "object"
    },
    "EconomyOutput": {
      "additionalProperties": false,
      "description": "ê²½ì œ ì¶œë ¥ ë°ì´í„° (RULE-005).\n\nì´ë²ˆ í„´ì˜ ë¹„ìš©ê³¼ ì”ì•¡ ì •ë³´ì…ë‹ˆë‹¤.\nì”ì•¡ ìŒìˆ˜ëŠ” ì ˆëŒ€ ë¶ˆê°€ (ì„œë²„ Hard gate).\n\nAttributes:\n    cost: ì´ë²ˆ í„´ì— ì†Œë¹„ëœ ë¹„ìš©\n    balance_after: ì†Œë¹„ í›„ ì”ì•¡\n\nImportant:\n    - costì™€ balance_afterëŠ” í•­ìƒ í¬í•¨ë˜ì–´ì•¼ í•©ë‹ˆë‹¤.\n    - balance_afterì˜ signalê³¼ memory_shardëŠ” 0 ì´ìƒì´ì–´ì•¼ í•©ë‹ˆë‹¤.",
      "properties": {
        "cost": {
          "$ref": "#/$defs/CurrencyAmount",
          "description": "ì´ë²ˆ í„´ì— ì†Œë¹„ëœ ë¹„ìš©"
        },
        "balance_after": {
          "$ref": "#/$defs/CurrencyAmount",
          "description": "ì†Œë¹„ í›„ ì”ì•¡"
        }
      },
      "required": [
        "cost",
        "balance_after"
      ],
      "title": "EconomyOutput",
      "type": "object"
    },
    "ImageJob": {
      "additionalProperties": false,
      "description": "ì´ë¯¸ì§€ ìƒì„± ì‘ì—….\n\nì¡°ê±´ë¶€ ì´ë¯¸ì§€ ìƒì„±/í¸ì§‘ ìš”ì²­ì…ë‹ˆë‹¤.\nì´ë¯¸ì§€ ìƒì„±ì´ ëŠë¦´ ê²½ìš° í…ìŠ¤íŠ¸ ìš°ì„  ì¶œë ¥ + Lazy Loadingì„ ì‚¬ìš©í•©ë‹ˆë‹¤.\n\nAttributes:\n    should_generate: ì´ë¯¸ì§€ë¥¼ ìƒì„±í•´ì•¼ í•˜ëŠ”ì§€\n    prompt: ì´ë¯¸ì§€ ìƒì„± í”„ë¡¬í”„íŠ¸\n    model_label: ëª¨ë¸ ì„ íƒ ë¼ë²¨ (FAST/QUALITY/CHEAP/REF)\n    aspect_ratio: ê°€ë¡œì„¸ë¡œ ë¹„ìœ¨ (ì˜ˆ: \"16:9\", \"1:1\")\n    image_size: ì´ë¯¸ì§€ í¬ê¸° (ì˜ˆ: \"1024x1024\")\n    reference_image_ids: ì°¸ì¡° ì´ë¯¸ì§€ ID ëª©ë¡ (ì„ íƒ)",
      "properties": {
        "should_generate": {
          "description": "ì´ë¯¸ì§€ë¥¼ ìƒì„±í•´ì•¼ í•˜ëŠ”ì§€",
          "title": "Should Generate",
          "type": "boolean"
        },
        "prompt": {
          "default": "",
          "description": "ì´ë¯¸ì§€ ìƒì„± í”„ë¡¬í”„íŠ¸",
          "title": "Prompt",
          "type": "string"
        },
        "model_label": {
          "$ref": "#/$defs/ModelLabel",
          "default": "FAST",
          "description": "ëª¨ë¸ ì„ íƒ ë¼ë²¨"
        },
        "aspect_ratio": {
          "default": "16:9",
          "description": "ê°€ë¡œì„¸ë¡œ ë¹„ìœ¨",
          "title": "Aspect Ratio",
          "type": "string"
        },
        "image_size": {
          "default": "1024x1024",
          "description": "ì´ë¯¸ì§€ í¬ê¸°",
          "title": "Image Size",
          "type": "string"
        },
        "reference_image_ids": {
          "default": [],
          "description": "ì°¸ì¡° ì´ë¯¸ì§€ ID ëª©ë¡ (ì„ íƒ)",
          "items": {
            "type": "string"
          },
          "title": "Reference Image Ids",
          "type": "array"
        }
      },
      "required": [
        "should_generate"
      ],
      "title": "ImageJob",
      "type": "object"
    },
    "Language": {
      "description": "ì§€ì› ì–¸ì–´ (RULE-006).\n\nko/en í˜¼í•© ì¶œë ¥ ê¸ˆì§€. TurnInput.languageë¥¼ SSOTë¡œ ì‚¼ì•„\nëª¨ë“  UI/ë‚´ëŸ¬í‹°ë¸Œ/ì‹œìŠ¤í…œ ë©”ì‹œì§€ëŠ” ë™ì¼ ì–¸ì–´ë¡œ ê³ ì •í•©ë‹ˆë‹¤.",
      "enum": [
        "ko-KR",
        "en-US"
      ],
      "title": "Language",
      "type": "string"
    },
    "MemoryPin": {
      "additionalProperties": false,
      "description": "ì¤‘ìš” ì„¤ì • ê³ ì • í›„ë³´.\n\nì‚¬ìš©ìê°€ Memory Shardë¥¼ ì†Œë¹„í•´ ê³ ì •í•  ìˆ˜ ìˆëŠ” ì¤‘ìš” ì„¤ì •ì…ë‹ˆë‹¤.\n\nAttributes:\n    id: í•€ ê³ ìœ  ID\n    content: ê³ ì •í•  ë‚´ìš©\n    cost: ê³ ì •ì— í•„ìš”í•œ ë¹„ìš©",
      "properties": {
        "id": {
          "description": "í•€ ê³ ìœ  ID",
          "title": "Id",
          "type": "string"
        },
        "content": {
          "description": "ê³ ì •í•  ë‚´ìš©",
          "title": "Content",
          "type": "string"
        },
        "cost": {
          "$ref": "#/$defs/CurrencyAmount",
          "description": "ê³ ì •ì— í•„ìš”í•œ ë¹„ìš©"
        }
      },
      "required": [
        "id",
        "content",
        "cost"
      ],
      "title": "MemoryPin",
      "type": "object"
    },
    "ModelLabel": {
      "description": "ëª¨ë¸/í’ˆì§ˆ ì„ íƒ ë¼ë²¨ (RULE-008).\n\ní”„ë¡¬í”„íŠ¸ ë…¸ì¶œ ì—†ì´ \"ì™œ ì´ ì„ íƒì´ì—ˆëŠ”ì§€\"ë¥¼ ì‚¬ìš©ì ì¹œí™” ë¼ë²¨ë¡œ í‘œì‹œ.",
      "enum": [
        "FAST",
        "QUALITY",
        "CHEAP",
        "REF"
      ],
      "title": "ModelLabel",
      "type": "string"
    },
    "Quest": {
      "additionalProperties": false,
      "description": "í€˜ìŠ¤íŠ¸/ëª©í‘œ (Quest Panel).\n\ní”Œë ˆì´ì–´ê°€ ë‹¬ì„±í•´ì•¼ í•˜ëŠ” í˜„ì¬ ëª©í‘œì…ë‹ˆë‹¤.\n\nAttributes:\n    id: í€˜ìŠ¤íŠ¸ ê³ ìœ  ID\n    label: í€˜ìŠ¤íŠ¸ ì´ë¦„\n    is_completed: ë‹¬ì„± ì—¬ë¶€",
      "properties": {
        "id": {
          "description": "í€˜ìŠ¤íŠ¸ ê³ ìœ  ID",
          "title": "Id",
          "type": "string"
        },
        "label": {
          "description": "í€˜ìŠ¤íŠ¸ ì´ë¦„",
          "title": "Label",
          "type": "string"
        },
        "is_completed": {
          "default": false,
          "description": "ë‹¬ì„± ì—¬ë¶€",
          "title": "Is Completed",
          "type": "boolean"
        }
      },
      "required": [
        "id",
        "label"
      ],
      "title": "Quest",
      "type": "object"
    },
    "RenderOutput": {
      "additionalProperties": false,
      "description": "ë Œë”ë§ ì¶œë ¥ ë°ì´í„°.\n\nì´ë¯¸ì§€ ìƒì„±/í¸ì§‘ ê´€ë ¨ ì •ë³´ì…ë‹ˆë‹¤.\n\nAttributes:\n    image_job: ì´ë¯¸ì§€ ìƒì„± ì‘ì—… (ì„ íƒ)",
      "properties": {
        "image_job": {
          "anyOf": [
            {
              "$ref": "#/$defs/ImageJob"
            },
            {
              "type": "null"
            }
          ],
          "default": null,
          "description": "ì´ë¯¸ì§€ ìƒì„± ì‘ì—… (ì„ íƒ)"
        }
      },
      "title": "RenderOutput",
      "type": "object"
    },
    "RiskLevel": {
      "description": "í–‰ë™ ìœ„í—˜ë„ ìˆ˜ì¤€.",
      "enum": [
        "low",
        "medium",
        "high"
      ],
      "title": "RiskLevel",
      "type": "string"
    },
    "SafetyOutput": {
      "additionalProperties": false,
      "description": "ì•ˆì „ ì¶œë ¥ ë°ì´í„°.\n\nì•ˆì „ ì •ì±… ê´€ë ¨ ì •ë³´ì…ë‹ˆë‹¤.\nì°¨ë‹¨ ì‹œ ëª…ì‹œì  ë©”ì‹œì§€ì™€ í•¨ê»˜ ì•ˆì „í•œ ëŒ€ì²´ ê²°ê³¼ë¥¼ ì œê³µí•©ë‹ˆë‹¤.\n\nAttributes:\n    blocked: ì•ˆì „ ì •ì±…ì— ì˜í•´ ì°¨ë‹¨ë˜ì—ˆëŠ”ì§€\n    message: ì°¨ë‹¨ ì‹œ ì‚¬ìš©ìì—ê²Œ í‘œì‹œí•  ë©”ì‹œì§€ (ì„ íƒ)",
      "properties": {
        "blocked": {
          "default": false,
          "description": "ì•ˆì „ ì •ì±…ì— ì˜í•´ ì°¨ë‹¨ë˜ì—ˆëŠ”ì§€",
          "title": "Blocked",
          "type": "boolean"
        },
        "message": {
          "anyOf": [
            {
              "type": "string"
            },
            {
              "type": "null"
            }
          ],
          "default": null,
          "description": "ì°¨ë‹¨ ì‹œ ì‚¬ìš©ìì—ê²Œ í‘œì‹œí•  ë©”ì‹œì§€ (ì„ íƒ)",
          "title": "Message"
        }
      },
      "title": "SafetyOutput",
      "type": "object"
    },
    "SceneObject": {
      "additionalProperties": false,
      "description": "ì¥ë©´ ì˜¤ë¸Œì íŠ¸ (í´ë¦­ ê°€ëŠ¥í•œ í•«ìŠ¤íŒŸ).\n\ní™”ë©´ì—ì„œ í´ë¦­ ê°€ëŠ¥í•œ ì˜¤ë¸Œì íŠ¸ì…ë‹ˆë‹¤.\nì¢Œí‘œëŠ” 0~1000 ì •ê·œí™” ì¢Œí‘œê³„ë¥¼ ì‚¬ìš©í•©ë‹ˆë‹¤ (RULE-009).\n\nAttributes:\n    id: ì˜¤ë¸Œì íŠ¸ ê³ ìœ  ID\n    label: ì˜¤ë¸Œì íŠ¸ ë¼ë²¨ (í‘œì‹œìš©)\n    box_2d: ë°”ìš´ë”© ë°•ìŠ¤ [ymin, xmin, ymax, xmax]\n    interaction_hint: ìƒí˜¸ì‘ìš© íŒíŠ¸ (ì„ íƒ)",
      "properties": {
        "id": {
          "description": "ì˜¤ë¸Œì íŠ¸ ê³ ìœ  ID",
          "title": "Id",
          "type": "string"
        },
        "label": {
          "description": "ì˜¤ë¸Œì íŠ¸ ë¼ë²¨ (í‘œì‹œìš©)",
          "title": "Label",
          "type": "string"
        },
        "box_2d": {
          "$ref": "#/$defs/Box2D",
          "description": "ë°”ìš´ë”© ë°•ìŠ¤"
        },
        "interaction_hint": {
          "anyOf": [
            {
              "type": "string"
            },
            {
              "type": "null"
            }
          ],
          "default": null,
          "description": "ìƒí˜¸ì‘ìš© íŒíŠ¸ (ì„ íƒ)",
          "title": "Interaction Hint"
        }
      },
      "required": [
        "id",
        "label",
        "box_2d"
      ],
      "title": "SceneObject",
      "type": "object"
    },
    "SceneOutput": {
      "additionalProperties": false,
      "description": "Scene í‘œì‹œ ì •ë³´ (RU-003-T1: Scene ì´ë¯¸ì§€ SSOT).\n\nTurnOutputì—ì„œ Scene Canvasì— í‘œì‹œí•  ì´ë¯¸ì§€ ì •ë³´ë¥¼ ì œê³µí•©ë‹ˆë‹¤.\nimage_urlì´ ì¡´ì¬í•˜ë©´ SceneCanvasëŠ” 'scene' ìƒíƒœë¡œ ì „í™˜ë©ë‹ˆë‹¤.\nimage_urlì´ ì—†ìœ¼ë©´ 'default' ìƒíƒœë¥¼ ìœ ì§€í•©ë‹ˆë‹¤.\n\nAttributes:\n    image_url: Scene ì´ë¯¸ì§€ URL (ì¡´ì¬ ì‹œ scene ìƒíƒœë¡œ ì „í™˜)\n    alt_text: ì´ë¯¸ì§€ ëŒ€ì²´ í…ìŠ¤íŠ¸ (ì ‘ê·¼ì„±ìš©, ì„ íƒ)",
      "properties": {
        "image_url": {
          "anyOf": [
            {
              "type": "string"
            },
            {
              "type": "null"
            }
          ],
          "default": null,
          "description": "Scene ì´ë¯¸ì§€ URL (ì¡´ì¬ ì‹œ scene ìƒíƒœë¡œ ì „í™˜)",
          "title": "Image Url"
        },
        "alt_text": {
          "anyOf": [
            {
              "type": "string"
            },
            {
              "type": "null"
            }
          ],
          "default": null,
          "description": "ì´ë¯¸ì§€ ëŒ€ì²´ í…ìŠ¤íŠ¸ (ì ‘ê·¼ì„±ìš©, ì„ íƒ)",
          "title": "Alt Text"
        }
      },
      "title": "SceneOutput",
      "type": "object"
    },
    "UIOutput": {
      "additionalProperties": false,
      "description": "UI ì¶œë ¥ ë°ì´í„°.\n\nAIê°€ ìƒì„±í•œ UI ìš”ì†Œë“¤ì…ë‹ˆë‹¤.\nì±„íŒ… ë²„ë¸”ì´ ì•„ë‹Œ ê²Œì„ UIë¡œ í‘œí˜„ë©ë‹ˆë‹¤ (RULE-002).\n\nRU-003-T1: scene í•„ë“œ ì¶”ê°€ - Scene Canvasì˜ ì´ë¯¸ì§€ í‘œì‹œ ì •ë³´ SSOT.\n\nAttributes:\n    action_deck: ì•¡ì…˜ ì¹´ë“œ ë± (Q1 ê²°ì •: Option A ì±„íƒ)\n    objects: í´ë¦­ ê°€ëŠ¥í•œ ì¥ë©´ ì˜¤ë¸Œì íŠ¸ ëª©ë¡\n    scene: Scene í‘œì‹œ ì •ë³´ (RU-003-T1)",
      "properties": {
        "action_deck": {
          "$ref": "#/$defs/ActionDeck",
          "description": "ì•¡ì…˜ ì¹´ë“œ ë±"
        },
        "objects": {
          "default": [],
          "description": "í´ë¦­ ê°€ëŠ¥í•œ ì¥ë©´ ì˜¤ë¸Œì íŠ¸ ëª©ë¡",
          "items": {
            "$ref": "#/$defs/SceneObject"
          },
          "title": "Objects",
          "type": "array"
        },
        "scene": {
          "$ref": "#/$defs/SceneOutput",
          "default": {
            "image_url": null,
            "alt_text": null
          },
          "description": "Scene í‘œì‹œ ì •ë³´ (RU-003-T1)"
        }
      },
      "title": "UIOutput",
      "type": "object"
    },
    "ValidationBadge": {
      "description": "ê²€ì¦ ë°°ì§€ (RULE-008).\n\ní„´ ê²°ê³¼ì— ëŒ€í•œ ê²€ì¦ ìƒíƒœë¥¼ í‘œì‹œí•©ë‹ˆë‹¤.",
      "enum": [
        "schema_ok",
        "schema_fail",
        "economy_ok",
        "economy_fail",
        "safety_ok",
        "safety_blocked",
        "consistency_ok",
        "consistency_fail"
      ],
      "title": "ValidationBadge",
      "type": "string"
    },
    "WorldDelta": {
      "additionalProperties": false,
      "description": "ì„¸ê³„ ìƒíƒœ ë³€í™” (Q2 ê²°ì •: Option A - delta ì¤‘ì‹¬).\n\nì´ë²ˆ í„´ì—ì„œ ë³€ê²½ëœ ì„¸ê³„ ìƒíƒœë¥¼ ë‚˜íƒ€ëƒ…ë‹ˆë‹¤.\nsnapshotì€ SaveGameì—ë§Œ ì €ì¥í•˜ê³ , ë§¤ í„´ì€ deltaë§Œ ì „ì†¡í•©ë‹ˆë‹¤.\n\nAttributes:\n    rules_changed: ë³€ê²½ë˜ê±°ë‚˜ ì¶”ê°€ëœ ê·œì¹™ ëª©ë¡\n    inventory_added: ì¶”ê°€ëœ ì¸ë²¤í† ë¦¬ ì•„ì´í…œ\n    inventory_removed: ì œê±°ëœ ì¸ë²¤í† ë¦¬ ì•„ì´í…œ\n    quests_updated: ì—…ë°ì´íŠ¸ëœ í€˜ìŠ¤íŠ¸(ëª©í‘œ) ëª©ë¡\n    relationships_changed: ë³€ê²½ëœ ê´€ê³„\n    memory_pins: ì¤‘ìš” ì„¤ì • ê³ ì • í›„ë³´",
      "properties": {
        "rules_changed": {
          "default": [],
          "description": "ë³€ê²½ëœ ê·œì¹™ ëª©ë¡",
          "items": {
            "$ref": "#/$defs/WorldRule"
          },
          "title": "Rules Changed",
          "type": "array"
        },
        "inventory_added": {
          "default": [],
          "description": "ì¶”ê°€ëœ ì¸ë²¤í† ë¦¬ ì•„ì´í…œ",
          "items": {
            "type": "string"
          },
          "title": "Inventory Added",
          "type": "array"
        },
        "inventory_removed": {
          "default": [],
          "description": "ì œê±°ëœ ì¸ë²¤í† ë¦¬ ì•„ì´í…œ",
          "items": {
            "type": "string"
          },
          "title": "Inventory Removed",
          "type": "array"
        },
        "quests_updated": {
          "default": [],
          "description": "ì—…ë°ì´íŠ¸ëœ í€˜ìŠ¤íŠ¸/ëª©í‘œ ëª©ë¡",
          "items": {
            "$ref": "#/$defs/Quest"
          },
          "title": "Quests Updated",
          "type": "array"
        },
        "relationships_changed": {
          "default": [],
          "description": "ë³€ê²½ëœ ê´€ê³„",
          "items": {
            "type": "string"
          },
          "title": "Relationships Changed",
          "type": "array"
        },
        "memory_pins": {
          "default": [],
          "description": "ì¤‘ìš” ì„¤ì • ê³ ì • í›„ë³´",
          "items": {
            "$ref": "#/$defs/MemoryPin"
          },
          "title": "Memory Pins",
          "type": "array"
        }
      },
      "title": "WorldDelta",
      "type": "object"
    },
    "WorldRule": {
      "additionalProperties": false,
      "description": "ì„¸ê³„ ê·œì¹™ (Rule Board).\n\ní˜„ì¬ ì„¸ê³„ì— ì ìš© ì¤‘ì¸ ë¬¼ë¦¬ ë²•ì¹™ì´ë‚˜ ë©”íƒ€ ê·œì¹™ì…ë‹ˆë‹¤.\n\nAttributes:\n    id: ê·œì¹™ ê³ ìœ  ID\n    label: ê·œì¹™ ì´ë¦„\n    description: ê·œì¹™ ìƒì„¸ ì„¤ëª… (ì„ íƒ)",
      "properties": {
        "id": {
          "description": "ê·œì¹™ ê³ ìœ  ID",
          "title": "Id",
          "type": "string"
        },
        "label": {
          "description": "ê·œì¹™ ì´ë¦„",
          "title": "Label",
          "type": "string"
        },
        "description": {
          "anyOf": [
            {
              "type": "string"
            },
            {
              "type": "null"
            }
          ],
          "default": null,
          "description": "ê·œì¹™ ìƒì„¸ ì„¤ëª… (ì„ íƒ)",
          "title": "Description"
        }
      },
      "required": [
        "id",
        "label"
      ],
      "title": "WorldRule",
      "type": "object"
    }
  },
  "additionalProperties": false,
  "description": "í„´ ì¶œë ¥ (ì„œë²„ â†’ í´ë¼ì´ì–¸íŠ¸).\n\nì„œë²„ê°€ í„´ ì²˜ë¦¬ í›„ í´ë¼ì´ì–¸íŠ¸ë¡œ ë°˜í™˜í•˜ëŠ” êµ¬ì¡°í™”ëœ ì‘ë‹µì…ë‹ˆë‹¤.\nGemini Structured Outputs(JSON Schema)ë¡œ ê°•ì œë©ë‹ˆë‹¤.\n\nHard Gate í•„ë“œ (RULE-003/004/005):\n    - economy: costì™€ balance_after í•„ìˆ˜, ì”ì•¡ ìŒìˆ˜ ê¸ˆì§€\n    - safety: blocked ì‹œ ì•ˆì „í•œ ëŒ€ì²´ ê²°ê³¼ ì œê³µ\n    - language: ìš”ì²­ ì–¸ì–´ì™€ ë™ì¼í•˜ê²Œ ê³ ì • (í˜¼í•© ì¶œë ¥ ê¸ˆì§€)\n\nAttributes:\n    language: ì‘ë‹µ ì–¸ì–´ (ìš”ì²­ê³¼ ë™ì¼)\n    narrative: ë‚´ëŸ¬í‹°ë¸Œ í…ìŠ¤íŠ¸ (í‘œì‹œìš©)\n    ui: UI ìš”ì†Œ (ì•¡ì…˜ ë±, ì˜¤ë¸Œì íŠ¸)\n    world: ì„¸ê³„ ìƒíƒœ ë³€í™” (delta ì¤‘ì‹¬)\n    render: ë Œë”ë§ ì •ë³´ (ì´ë¯¸ì§€ ìƒì„± ì‘ì—…)\n    economy: ê²½ì œ ì •ë³´ (ë¹„ìš©, ì”ì•¡)\n    safety: ì•ˆì „ ì •ì±… ì •ë³´\n    agent_console: ì—ì´ì „íŠ¸ ì‹¤í–‰ ì •ë³´ (ë‹¨ê³„, ë°°ì§€, ë³µêµ¬ íšŸìˆ˜)\n\nExample:\n    >>> output = TurnOutput(\n    ...     language=Language.KO,\n    ...     narrative=\"ë¬¸ì´ ì‚ê±±ê±°ë¦¬ë©° ì—´ë¦½ë‹ˆë‹¤...\",\n    ...     economy=EconomyOutput(\n    ...         cost=CurrencyAmount(signal=5, memory_shard=0),\n    ...         balance_after=CurrencyAmount(signal=95, memory_shard=5),\n    ...     ),\n    ...     safety=SafetyOutput(blocked=False),\n    ... )\n    >>> schema = TurnOutput.model_json_schema()\n\nSchema Generation:\n    >>> # Gemini Structured Outputsìš© JSON Schema ìƒì„±\n    >>> json_schema = TurnOutput.model_json_schema()\n    >>> # response_json_schema íŒŒë¼ë¯¸í„°ì— ì „ë‹¬\n    >>> config = {\n    ...     \"response_mime_type\": \"application/json\",\n    ...     \"response_json_schema\": json_schema,\n    ... }",
  "properties": {
    "language": {
      "$ref": "#/$defs/Language",
      "description": "ì‘ë‹µ ì–¸ì–´ (ìš”ì²­ê³¼ ë™ì¼)"
    },
    "narrative": {
      "description": "ë‚´ëŸ¬í‹°ë¸Œ í…ìŠ¤íŠ¸ (í‘œì‹œìš©)",
      "title": "Narrative",
      "type": "string"
    },
    "economy": {
      "$ref": "#/$defs/EconomyOutput",
      "description": "ê²½ì œ ì •ë³´ (ë¹„ìš©, ì”ì•¡)"
    },
    "safety": {
      "$ref": "#/$defs/SafetyOutput",
      "description": "ì•ˆì „ ì •ì±… ì •ë³´"
    },
    "ui": {
      "$ref": "#/$defs/UIOutput",
      "description": "UI ìš”ì†Œ"
    },
    "world": {
      "$ref": "#/$defs/WorldDelta",
      "description": "ì„¸ê³„ ìƒíƒœ ë³€í™” (delta)"
    },
    "render": {
      "$ref": "#/$defs/RenderOutput",
      "description": "ë Œë”ë§ ì •ë³´"
    },
    "agent_console": {
      "$ref": "#/$defs/AgentConsole",
      "description": "ì—ì´ì „íŠ¸ ì‹¤í–‰ ì •ë³´"
    }
  },
  "required": [
    "language",
    "narrative",
    "economy",
    "safety"
  ],
  "title": "TurnOutput",
  "type": "object"
}
</file>

<file path="frontend/public/ui/manifest.json">
{
  "$schema": "./manifest.schema.json",
  "version": "1.4.0",
  "generatedAt": "2026-01-14T14:55:00Z",
  "totalBytes": 570867,
  "budgetBytes": 1572864,
  "assets": [
    {
      "id": "signal-24",
      "path": "icons/signal-24.png",
      "type": "icon",
      "size": 24,
      "fallback": "âš¡",
      "usedIn": ["EconomyHUD"],
      "bytes": 1573,
      "notes": "U-038: v2 ì¬ìƒì„±, nanobanana mcp(í”½ì…€ì•„íŠ¸), rembg(birefnet-general), ImageMagick ìµœì í™”"
    },
    {
      "id": "signal-16",
      "path": "icons/signal-16.png",
      "type": "icon",
      "size": 16,
      "fallback": "âš¡",
      "usedIn": ["ActionDeck"],
      "bytes": 1012,
      "notes": "U-038: v2 ì¬ìƒì„±, nanobanana mcp(í”½ì…€ì•„íŠ¸), rembg(birefnet-general), ImageMagick ìµœì í™”"
    },
    {
      "id": "shard-24",
      "path": "icons/shard-24.png",
      "type": "icon",
      "size": 24,
      "fallback": "ğŸ’",
      "usedIn": ["EconomyHUD"],
      "bytes": 1362,
      "notes": "U-038: v2 ì¬ìƒì„±, nanobanana mcp(í”½ì…€ì•„íŠ¸), rembg(birefnet-general), ImageMagick ìµœì í™”"
    },
    {
      "id": "shard-16",
      "path": "icons/shard-16.png",
      "type": "icon",
      "size": 16,
      "fallback": "ğŸ’",
      "usedIn": ["ActionDeck"],
      "bytes": 1147,
      "notes": "U-038: shard-24ì—ì„œ ë¦¬ì‚¬ì´ì¦ˆ, 16px ìµœì í™”"
    },
    {
      "id": "badge-ok-24",
      "path": "icons/badge-ok-24.png",
      "type": "icon",
      "size": 24,
      "fallback": "âœ“",
      "usedIn": ["AgentConsole"],
      "bytes": 1461,
      "notes": "U-038: v2 ì¬ìƒì„±, nanobanana mcp(í”½ì…€ì•„íŠ¸), rembg(birefnet-general), ImageMagick ìµœì í™”"
    },
    {
      "id": "badge-ok-16",
      "path": "icons/badge-ok-16.png",
      "type": "icon",
      "size": 16,
      "fallback": "âœ“",
      "usedIn": [],
      "bytes": 1096,
      "notes": "U-038: v2 ì¬ìƒì„±, nanobanana mcp(í”½ì…€ì•„íŠ¸), rembg(birefnet-general), ImageMagick ìµœì í™”"
    },
    {
      "id": "badge-fail-24",
      "path": "icons/badge-fail-24.png",
      "type": "icon",
      "size": 24,
      "fallback": "âœ—",
      "usedIn": ["AgentConsole"],
      "bytes": 2006,
      "notes": "U-038: v2 ì¬ìƒì„±, nanobanana mcp(í”½ì…€ì•„íŠ¸), rembg(birefnet-general), ImageMagick ìµœì í™”"
    },
    {
      "id": "risk-medium-24",
      "path": "icons/risk-medium-24.png",
      "type": "icon",
      "size": 24,
      "fallback": "âš ",
      "usedIn": [],
      "bytes": 1594,
      "notes": "U-038: 24px í˜ì–´ ë³´ê°•, nanobanana mcp ìƒì„±"
    },
    {
      "id": "risk-medium-16",
      "path": "icons/risk-medium-16.png",
      "type": "icon",
      "size": 16,
      "fallback": "âš ",
      "usedIn": ["ActionDeck"],
      "bytes": 1256,
      "notes": "U-038: v2 ì¬ìƒì„±, nanobanana mcp(í”½ì…€ì•„íŠ¸), rembg(birefnet-general), ImageMagick ìµœì í™”"
    },
    {
      "id": "risk-low-24",
      "path": "icons/risk-low-24.png",
      "type": "icon",
      "size": 24,
      "fallback": "âœ“",
      "usedIn": [],
      "bytes": 1838,
      "notes": "U-038: v2 ì¬ìƒì„±, nanobanana mcp(í”½ì…€ì•„íŠ¸), rembg(birefnet-general), ImageMagick ìµœì í™”"
    },
    {
      "id": "risk-low-16",
      "path": "icons/risk-low-16.png",
      "type": "icon",
      "size": 16,
      "fallback": "âœ“",
      "usedIn": ["ActionDeck"],
      "bytes": 1331,
      "notes": "U-038: v2 ì¬ìƒì„±, nanobanana mcp(í”½ì…€ì•„íŠ¸), rembg(birefnet-general), ImageMagick ìµœì í™”"
    },
    {
      "id": "risk-high-24",
      "path": "icons/risk-high-24.png",
      "type": "icon",
      "size": 24,
      "fallback": "âš ",
      "usedIn": [],
      "bytes": 1737,
      "notes": "U-038: v2 ì¬ìƒì„±, nanobanana mcp(í”½ì…€ì•„íŠ¸), rembg(birefnet-general), ImageMagick ìµœì í™”"
    },
    {
      "id": "risk-high-16",
      "path": "icons/risk-high-16.png",
      "type": "icon",
      "size": 16,
      "fallback": "âš ",
      "usedIn": ["ActionDeck"],
      "bytes": 1227,
      "notes": "U-038: v2 ì¬ìƒì„±, nanobanana mcp(í”½ì…€ì•„íŠ¸), rembg(birefnet-general), ImageMagick ìµœì í™”"
    },
    {
      "id": "status-online-16",
      "path": "icons/status-online-16.png",
      "type": "icon",
      "size": 16,
      "fallback": "â—",
      "usedIn": [],
      "bytes": 1375,
      "notes": "U-038: v2 ì¬ìƒì„±, nanobanana mcp(í”½ì…€ì•„íŠ¸), rembg(birefnet-general), ImageMagick ìµœì í™”"
    },
    {
      "id": "scene-placeholder-default",
      "path": "placeholders/scene-placeholder-default.png",
      "type": "placeholder",
      "fallback": "[SCENE]",
      "usedIn": ["SceneCanvas"],
      "bytes": 261407,
      "notes": "nanobanana mcp ìƒì„±, ë ˆíŠ¸ë¡œ í„°ë¯¸ë„ ìŠ¤íƒ€ì¼"
    },
    {
      "id": "scene-loading",
      "path": "placeholders/scene-loading.webp",
      "type": "placeholder",
      "fallback": "â³",
      "usedIn": ["SceneCanvas"],
      "bytes": 47850,
      "notes": "U-031: ë¡œë”© ìƒíƒœ placeholder, nanobanana mcp ìƒì„±, ImageMagick(magick) ìµœì í™”"
    },
    {
      "id": "scene-offline",
      "path": "placeholders/scene-offline.webp",
      "type": "placeholder",
      "fallback": "ğŸ”Œ",
      "usedIn": ["SceneCanvas"],
      "bytes": 44658,
      "notes": "U-031: ì˜¤í”„ë¼ì¸ ìƒíƒœ placeholder, nanobanana mcp ìƒì„±, ImageMagick(magick) ìµœì í™”"
    },
    {
      "id": "scene-blocked",
      "path": "placeholders/scene-blocked.webp",
      "type": "placeholder",
      "fallback": "ğŸš«",
      "usedIn": ["SceneCanvas"],
      "bytes": 17318,
      "notes": "U-031: ì°¨ë‹¨ ìƒíƒœ placeholder, nanobanana mcp ìƒì„±, ImageMagick(magick) ìµœì í™”"
    },
    {
      "id": "scene-low-signal",
      "path": "placeholders/scene-low-signal.webp",
      "type": "placeholder",
      "fallback": "ğŸ“‰",
      "usedIn": ["SceneCanvas"],
      "bytes": 68454,
      "notes": "U-031: ì €ì‹ í˜¸ ìƒíƒœ placeholder, nanobanana mcp ìƒì„±, ImageMagick(magick) ìµœì í™”"
    },
    {
      "id": "panel-corner-br",
      "path": "chrome/panel-corner-br.png",
      "type": "chrome",
      "fallback": "",
      "usedIn": ["PanelHeader"],
      "bytes": 1899,
      "notes": "U-032: íŒ¨ë„ ì½”ë„ˆ ì¥ì‹, nanobanana mcp ìƒì„±, rembg ë°°ê²½ ì œê±°, ImageMagick ìµœì í™”(48x48), CSS transformìœ¼ë¡œ 4ë°©í–¥ ì ìš©"
    },
    {
      "id": "card-frame",
      "path": "chrome/card-frame.png",
      "type": "chrome",
      "fallback": "",
      "usedIn": ["ActionCard"],
      "bytes": 9101,
      "notes": "U-032: ì•¡ì…˜ ì¹´ë“œ í”„ë ˆì„, nanobanana mcp ìƒì„±, rembg ë°°ê²½ ì œê±°, ImageMagick ìµœì í™”(160x80)"
    },
    {
      "id": "scanner-frame",
      "path": "chrome/scanner-frame.png",
      "type": "chrome",
      "fallback": "",
      "usedIn": ["Scanner"],
      "bytes": 100165,
      "notes": "U-032: ìŠ¤ìºë„ˆ ìŠ¬ë¡¯ í”„ë ˆì„, nanobanana mcp ìƒì„±, rembg(birefnet-general) ë°°ê²½ ì œê±°, ImageMagick ìµœì í™”(346x200) ì™„ë£Œ"
    }
  ]
}
</file>

<file path="frontend/package.json">
{
  "name": "unknown-world-frontend",
  "private": true,
  "version": "0.0.0",
  "type": "module",
  "packageManager": "pnpm@10.27.0",
  "scripts": {
    "dev": "vite",
    "build": "tsc -b && vite build",
    "preview": "vite preview",
    "format": "prettier . --write",
    "format:check": "prettier . --check",
    "lint": "eslint .",
    "lint:fix": "eslint . --fix",
    "typecheck": "tsc --noEmit",
    "test": "vitest run",
    "test:watch": "vitest",
    "test:coverage": "vitest run --coverage"
  },
  "dependencies": {
    "@dnd-kit/core": "6.3.1",
    "@dnd-kit/sortable": "10.0.0",
    "@dnd-kit/utilities": "^3.2.2",
    "i18next": "25.7.3",
    "react": "19.2.3",
    "react-dom": "19.2.3",
    "react-i18next": "16.5.1",
    "zod": "4.3.4",
    "zustand": "5.0.9"
  },
  "devDependencies": {
    "@eslint/js": "9.39.2",
    "@testing-library/jest-dom": "^6.9.1",
    "@testing-library/react": "^16.3.1",
    "@types/node": "25.0.3",
    "@types/react": "19.2.7",
    "@types/react-dom": "19.2.3",
    "@vitejs/plugin-react": "5.1.2",
    "@vitest/coverage-v8": "^4.0.16",
    "eslint": "9.39.2",
    "eslint-config-prettier": "10.1.8",
    "eslint-plugin-react": "7.37.5",
    "eslint-plugin-react-hooks": "7.0.1",
    "eslint-plugin-unused-imports": "4.3.0",
    "globals": "16.5.0",
    "jsdom": "^27.4.0",
    "prettier": "3.7.4",
    "typescript": "5.9.3",
    "typescript-eslint": "8.51.0",
    "vite": "7.3.0",
    "vitest": "^4.0.16"
  },
  "pnpm": {
    "onlyBuiltDependencies": [
      "esbuild"
    ]
  }
}
</file>

<file path="frontend/src/api/turnStream.ts">
/**
 * Unknown World - HTTP Streaming í´ë¼ì´ì–¸íŠ¸ + NDJSON íŒŒì„œ.
 *
 * fetch ê¸°ë°˜ìœ¼ë¡œ POST ìš”ì²­ì„ ë³´ë‚´ê³  ì‘ë‹µ ìŠ¤íŠ¸ë¦¼ì„ NDJSONìœ¼ë¡œ íŒŒì‹±í•©ë‹ˆë‹¤.
 * ì¤‘ê°„ ì²­í¬ íŒŒì‹± ì‹¤íŒ¨ê°€ ì „ì²´ UIë¥¼ ë©ˆì¶”ì§€ ì•Šë„ë¡ ì„¤ê³„ë˜ì—ˆìŠµë‹ˆë‹¤.
 *
 * ì„¤ê³„ ì›ì¹™:
 *   - RULE-003: êµ¬ì¡°í™” ì¶œë ¥(JSON Schema) ìš°ì„  + ì´ì¤‘ ê²€ì¦
 *   - RULE-004: ê²€ì¦ ì‹¤íŒ¨ ì‹œ ì•ˆì „ í´ë°± ì œê³µ
 *   - RULE-008: ë‹¨ê³„/ë°°ì§€ ê°€ì‹œí™” (í”„ë¡¬í”„íŠ¸/ë‚´ë¶€ ì¶”ë¡  ë…¸ì¶œ ê¸ˆì§€)
 *   - RULE-011: ë°±ì—”ë“œ í¬íŠ¸ 8011 ì‚¬ìš©
 *
 * @module api/turnStream
 */

import type { TurnInput, TurnOutput, Language } from '../schemas/turn';
import { safeParseTurnOutput } from '../schemas/turn';
import type { StreamCallbacks } from '../types/turn_stream';
import {
  StreamEventType,
  BaseEventSchema,
  safeParseStageEvent,
  safeParseRepairEvent,
  safeParseBadgesEvent,
  safeParseNarrativeDeltaEvent,
  safeParseFinalEventRaw,
  safeParseErrorEvent,
  normalizeStageStatus,
} from '../types/turn_stream';

// Re-export ìŠ¤íŠ¸ë¦¼ ì´ë²¤íŠ¸ íƒ€ì…ë“¤ (í•˜ìœ„ í˜¸í™˜ì„± ìœ ì§€)
export type {
  StreamEventTypeName,
  StageStatusName,
  StageEvent,
  RepairEvent,
  BadgesEvent,
  NarrativeDeltaEvent,
  FinalEvent,
  ErrorEvent,
  StreamEvent,
  StreamCallbacks,
} from '../types/turn_stream';
export { StreamEventType, StageStatus } from '../types/turn_stream';

// =============================================================================
// NDJSON íŒŒì„œ (Q1 ê²°ì •: Option A - ì§ì ‘ êµ¬í˜„)
// =============================================================================

/**
 * NDJSON ë¼ì¸ íŒŒì„œ.
 * ë¶€ë¶„ ì²­í¬ë¥¼ ë²„í¼ë§í•˜ê³  ì™„ì „í•œ ë¼ì¸ì„ íŒŒì‹±í•©ë‹ˆë‹¤.
 */
export class NDJSONParser {
  private buffer = '';

  /**
   * ì²­í¬ë¥¼ íŒŒì‹±í•˜ê³  ì™„ì „í•œ JSON ê°ì²´ë“¤ì„ ë°˜í™˜í•©ë‹ˆë‹¤.
   *
   * @param chunk - ìˆ˜ì‹ ëœ í…ìŠ¤íŠ¸ ì²­í¬
   * @returns íŒŒì‹±ëœ JSON ê°ì²´ ë°°ì—´
   */
  parse(chunk: string): unknown[] {
    this.buffer += chunk;
    const results: unknown[] = [];

    // ì¤„ë°”ê¿ˆìœ¼ë¡œ ë¶„í• 
    const lines = this.buffer.split('\n');

    // ë§ˆì§€ë§‰ ë¼ì¸ì€ ë¶ˆì™„ì „í•  ìˆ˜ ìˆìœ¼ë¯€ë¡œ ë²„í¼ì— ìœ ì§€
    this.buffer = lines.pop() ?? '';

    for (const line of lines) {
      const trimmed = line.trim();
      if (trimmed === '') continue;

      try {
        const parsed = JSON.parse(trimmed);
        results.push(parsed);
      } catch {
        // íŒŒì‹± ì‹¤íŒ¨ ì‹œ í•´ë‹¹ ë¼ì¸ ë¬´ì‹œ (RULE-004: ì „ì²´ ì¤‘ë‹¨ ë°©ì§€)
        console.warn('[NDJSON] Failed to parse line:', trimmed);
      }
    }

    return results;
  }

  /**
   * ë²„í¼ë¥¼ ì´ˆê¸°í™”í•©ë‹ˆë‹¤.
   */
  reset(): void {
    this.buffer = '';
  }

  /**
   * ë‚¨ì€ ë²„í¼ë¥¼ í”ŒëŸ¬ì‹œí•˜ê³  ë§ˆì§€ë§‰ ê°ì²´ë¥¼ íŒŒì‹±í•©ë‹ˆë‹¤.
   */
  flush(): unknown | null {
    const trimmed = this.buffer.trim();
    this.buffer = '';

    if (trimmed === '') return null;

    try {
      return JSON.parse(trimmed);
    } catch {
      console.warn('[NDJSON] Failed to parse remaining buffer:', trimmed);
      return null;
    }
  }
}

// =============================================================================
// ìŠ¤íŠ¸ë¦¼ ì´ë²¤íŠ¸ í•¸ë“¤ëŸ¬
// =============================================================================

/**
 * íŒŒì‹±ëœ ì´ë²¤íŠ¸ë¥¼ íƒ€ì…ë³„ë¡œ ë¶„ë°°í•©ë‹ˆë‹¤.
 *
 * RU-002-S2: ìºìŠ¤íŒ… ëŒ€ì‹  Zod safeParseë¥¼ ì ìš©í•˜ì—¬ ê²€ì¦ ê°•í™”.
 * Unknown/í™•ì¥ ì´ë²¤íŠ¸ëŠ” UIë¥¼ ë©ˆì¶”ì§€ ì•Šê³  ê²½ê³ ë§Œ ì¶œë ¥.
 *
 * @param event - íŒŒì‹±ëœ ì´ë²¤íŠ¸ ê°ì²´
 * @param callbacks - ì½œë°± í•¨ìˆ˜ë“¤
 * @param language - í´ë°± ì–¸ì–´
 */
function dispatchEvent(event: unknown, callbacks: StreamCallbacks, language: Language): void {
  if (!event || typeof event !== 'object') return;

  // ê¸°ë³¸ ì´ë²¤íŠ¸ íƒ€ì… ì¶”ì¶œ
  const baseResult = BaseEventSchema.safeParse(event);
  if (!baseResult.success) {
    console.warn('[TurnStream] Invalid event format (no type field):', event);
    return;
  }

  const type = baseResult.data.type;

  switch (type) {
    case StreamEventType.STAGE: {
      // RU-002-S2: stage ì´ë²¤íŠ¸ ê²€ì¦
      const stageResult = safeParseStageEvent(event);
      if (stageResult.success) {
        // status ì •ê·œí™”: 'ok' â†’ 'complete'
        const normalizedStatus = normalizeStageStatus(stageResult.data.status);
        callbacks.onStage?.({
          type: StreamEventType.STAGE,
          name: stageResult.data.name,
          status: normalizedStatus,
        });
      } else {
        console.warn('[TurnStream] Invalid stage event:', stageResult.error.message);
      }
      break;
    }

    case StreamEventType.REPAIR: {
      // RU-002-S2: repair ì´ë²¤íŠ¸ ê²€ì¦
      const repairResult = safeParseRepairEvent(event);
      if (repairResult.success) {
        callbacks.onRepair?.(repairResult.data);
      } else {
        console.warn('[TurnStream] Invalid repair event:', repairResult.error.message);
      }
      break;
    }

    case StreamEventType.BADGES: {
      // RU-002-S2: badges ì´ë²¤íŠ¸ ê²€ì¦ (v1/v2 ì •ê·œí™” í¬í•¨)
      const badgesResult = safeParseBadgesEvent(event);
      if (badgesResult.success) {
        callbacks.onBadges?.(badgesResult.data);
      } else {
        console.warn('[TurnStream] Invalid badges event:', badgesResult.error.message);
      }
      break;
    }

    case StreamEventType.NARRATIVE_DELTA: {
      // RU-002-S2: narrative_delta ì´ë²¤íŠ¸ ê²€ì¦
      const narrativeResult = safeParseNarrativeDeltaEvent(event);
      if (narrativeResult.success) {
        callbacks.onNarrativeDelta?.(narrativeResult.data);
      } else {
        console.warn('[TurnStream] Invalid narrative_delta event:', narrativeResult.error.message);
      }
      break;
    }

    case StreamEventType.FINAL: {
      // RU-002-S2: final ì´ë²¤íŠ¸ êµ¬ì¡° ê²€ì¦
      const finalRawResult = safeParseFinalEventRaw(event);
      if (!finalRawResult.success) {
        console.warn('[TurnStream] Invalid final event structure:', finalRawResult.error.message);
        // êµ¬ì¡°ê°€ ì˜ëª»ë˜ì–´ë„ í´ë°± ì œê³µ
        callbacks.onFinal?.({
          type: StreamEventType.FINAL,
          data: createFallbackTurnOutput(language),
        });
        break;
      }

      // RULE-003/004: Zod strict parse + í´ë°±
      const turnOutputPayload = finalRawResult.data.data;
      const parseResult = safeParseTurnOutput(turnOutputPayload, language);

      if (parseResult.success) {
        callbacks.onFinal?.({
          type: StreamEventType.FINAL,
          data: parseResult.data,
        });
      } else {
        console.warn('[TurnStream] TurnOutput validation failed:', parseResult.error);
        callbacks.onFinal?.({
          type: StreamEventType.FINAL,
          data: parseResult.fallback,
        });
      }
      break;
    }

    case StreamEventType.ERROR: {
      // RU-002-S2: error ì´ë²¤íŠ¸ ê²€ì¦
      const errorResult = safeParseErrorEvent(event);
      if (errorResult.success) {
        callbacks.onError?.(errorResult.data);
      } else {
        console.warn('[TurnStream] Invalid error event:', errorResult.error.message);
        // ì—ëŸ¬ ì´ë²¤íŠ¸ê°€ ê¹¨ì§„ ê²½ìš°ì—ë„ ê¸°ë³¸ ì—ëŸ¬ ì „ë‹¬
        callbacks.onError?.({
          type: StreamEventType.ERROR,
          message: 'Unknown error (malformed error event)',
          code: 'INVALID_ERROR_EVENT',
        });
      }
      break;
    }

    default:
      // RU-002-S2: Unknown/í™•ì¥ ì´ë²¤íŠ¸ëŠ” UIë¥¼ ë©ˆì¶”ì§€ ì•Šê³  ê²½ê³ ë§Œ ì¶œë ¥
      // í–¥í›„ protocol, repair, telemetry ë“± í™•ì¥ ì´ë²¤íŠ¸ ë„ì… ì‹œ ì—¬ê¸°ì„œ ì²˜ë¦¬ ê°€ëŠ¥
      console.warn('[TurnStream] Unknown/ignored event type:', type, event);
  }
}

/**
 * í´ë¼ì´ì–¸íŠ¸ ì¸¡ í´ë°± TurnOutput ìƒì„± (ì–¸ì–´ë§Œ ì§€ì •).
 * dispatchEvent ë‚´ë¶€ì—ì„œ ì‚¬ìš©í•˜ëŠ” ê°„ë‹¨í•œ í´ë°±.
 */
function createFallbackTurnOutput(language: Language): TurnOutput {
  const fallbackNarrative =
    language === 'ko-KR'
      ? '[ì‹œìŠ¤í…œ] ì‘ë‹µ ë°ì´í„°ë¥¼ ì²˜ë¦¬í•˜ëŠ” ì¤‘ ë¬¸ì œê°€ ë°œìƒí–ˆìŠµë‹ˆë‹¤.'
      : '[System] An error occurred while processing response data.';

  return {
    language,
    narrative: fallbackNarrative,
    economy: {
      cost: { signal: 0, memory_shard: 0 },
      balance_after: { signal: 0, memory_shard: 0 },
    },
    safety: {
      blocked: false,
      message: null,
    },
    ui: {
      action_deck: { cards: [] },
      objects: [],
      scene: { image_url: null, alt_text: null },
    },
    world: {
      rules_changed: [],
      inventory_added: [],
      inventory_removed: [],
      quests_updated: [],
      relationships_changed: [],
      memory_pins: [],
    },
    render: {
      image_job: null,
    },
    agent_console: {
      current_phase: 'commit',
      badges: ['schema_fail'],
      repair_count: 1,
    },
  };
}

// =============================================================================
// API ì„¤ì •
// =============================================================================

/** ë°±ì—”ë“œ API URL (RULE-011: í¬íŠ¸ 8011) */
const API_BASE_URL = 'http://localhost:8011';

/** í„´ ìŠ¤íŠ¸ë¦¼ API ì—”ë“œí¬ì¸íŠ¸ */
const TURN_ENDPOINT = `${API_BASE_URL}/api/turn`;

// =============================================================================
// ìŠ¤íŠ¸ë¦¼ í´ë¼ì´ì–¸íŠ¸
// =============================================================================

/** ìŠ¤íŠ¸ë¦¼ ìš”ì²­ ì˜µì…˜ */
export interface TurnStreamOptions {
  /** ìš”ì²­ íƒ€ì„ì•„ì›ƒ (ms) */
  timeout?: number;
  /** AbortSignal */
  signal?: AbortSignal;
}

/**
 * í„´ ìŠ¤íŠ¸ë¦¼ ìš”ì²­ì„ ì‹¤í–‰í•©ë‹ˆë‹¤.
 *
 * @param input - í„´ ì…ë ¥ ë°ì´í„°
 * @param callbacks - ì´ë²¤íŠ¸ ì½œë°±
 * @param options - ìš”ì²­ ì˜µì…˜
 * @returns ì·¨ì†Œ í•¨ìˆ˜
 */
export async function executeTurnStream(
  input: TurnInput,
  callbacks: StreamCallbacks,
  options?: TurnStreamOptions,
): Promise<void> {
  const parser = new NDJSONParser();
  const controller = new AbortController();
  const signal = options?.signal ?? controller.signal;

  // RU-002-S1: AbortError ë°œìƒ ì‹œ onComplete í˜¸ì¶œ ì—¬ë¶€ ì¶”ì 
  let aborted = false;

  try {
    const response = await fetch(TURN_ENDPOINT, {
      method: 'POST',
      headers: {
        'Content-Type': 'application/json',
        Accept: 'application/x-ndjson',
      },
      body: JSON.stringify(input),
      signal,
    });

    if (!response.ok) {
      throw new Error(`HTTP ${response.status}: ${response.statusText}`);
    }

    if (!response.body) {
      throw new Error('Response body is null');
    }

    const reader = response.body.getReader();
    const decoder = new TextDecoder('utf-8');

    // ìŠ¤íŠ¸ë¦¼ ì½ê¸° ë£¨í”„
    while (true) {
      const { done, value } = await reader.read();

      if (done) break;

      const chunk = decoder.decode(value, { stream: true });
      const events = parser.parse(chunk);

      for (const event of events) {
        dispatchEvent(event, callbacks, input.language);
      }
    }

    // ë‚¨ì€ ë²„í¼ í”ŒëŸ¬ì‹œ
    const remaining = parser.flush();
    if (remaining) {
      dispatchEvent(remaining, callbacks, input.language);
    }
  } catch (error) {
    if (error instanceof DOMException && error.name === 'AbortError') {
      // RU-003-S1: Abort(ì·¨ì†Œ) ì •ì±…
      // =========================================================================
      // í˜„ì¬ ì •ì±…(Option B): Abort ì‹œ onCompleteë¥¼ í˜¸ì¶œí•˜ì§€ ì•ŠìŒ
      // - ì´ìœ : ì·¨ì†ŒëŠ” "ì‚¬ìš©ì ì˜ë„"ì´ë¯€ë¡œ ì‹¤íŒ¨ì™€ êµ¬ë¶„í•´ì•¼ í•¨
      // - ì£¼ì˜: ì´ ì •ì±…ì—ì„œëŠ” Cancel ë²„íŠ¼ êµ¬í˜„ ì‹œ í˜¸ì¶œìê°€ ì§ì ‘ UI ë³µêµ¬ í•„ìš”
      //
      // í–¥í›„ Option Aë¡œ ì „í™˜ ê°€ëŠ¥:
      // - Abort ì‹œì—ë„ onComplete í˜¸ì¶œ + ë³„ë„ í”Œë˜ê·¸ë¡œ "ì·¨ì†Œ ì¢…ë£Œ" êµ¬ë¶„
      // - ì¥ì : UIê°€ ë©ˆì¶”ì§€ ì•ŠìŒ (ë³µêµ¬ ì¼ê´€ì„±)
      // - ë‹¨ì : ì·¨ì†Œì™€ ì‹¤íŒ¨ë¥¼ êµ¬ë¶„í•˜ë ¤ë©´ ì´ë²¤íŠ¸ ëª¨ë¸ í™•ì¥ í•„ìš”
      //
      // ê²°ì • ê·¼ê±°: RU-003-S1 Step 3
      // =========================================================================
      aborted = true;
      return;
    }

    const errorMessage = error instanceof Error ? error.message : 'Unknown error occurred';

    // RU-002-S1: ë„¤íŠ¸ì›Œí¬ ì—ëŸ¬ ì‹œì—ë„ onError í˜¸ì¶œ
    callbacks.onError?.({
      type: StreamEventType.ERROR,
      message: errorMessage,
      code: 'STREAM_ERROR',
    });

    // RU-002-S1: ë„¤íŠ¸ì›Œí¬ ì—ëŸ¬ ì‹œ í´ë¼ì´ì–¸íŠ¸ ì¸¡ í´ë°± final ìƒì„±
    // ì„œë²„ì—ì„œ finalì´ ì˜¤ì§€ ëª»í•œ ê²½ìš° UIê°€ ë©ˆì¶”ì§€ ì•Šë„ë¡ í•¨
    const fallback = createClientFallbackTurnOutput(input.language, input.economy_snapshot);
    callbacks.onFinal?.({
      type: StreamEventType.FINAL,
      data: fallback,
    });
  } finally {
    // RU-002-S1: ìŠ¤íŠ¸ë¦¼ ì¢…ë£Œ ì¸ë°”ë¦¬ì–¸íŠ¸ - ì„±ê³µ/ì‹¤íŒ¨ ëª¨ë‘ì—ì„œ onComplete í˜¸ì¶œ ë³´ì¥
    if (!aborted) {
      callbacks.onComplete?.();
    }
  }
}

/**
 * í´ë¼ì´ì–¸íŠ¸ ì¸¡ í´ë°± TurnOutput ìƒì„± (RU-002-S1).
 * ì„œë²„ì—ì„œ finalì´ ì˜¤ì§€ ëª»í•œ ê²½ìš° (ë„¤íŠ¸ì›Œí¬ ì—ëŸ¬ ë“±) ì‚¬ìš©í•©ë‹ˆë‹¤.
 * EconomyëŠ” ìš”ì²­ ì§ì „ ìŠ¤ëƒ…ìƒ·ì„ ê·¸ëŒ€ë¡œ ìœ ì§€í•©ë‹ˆë‹¤.
 */
function createClientFallbackTurnOutput(
  language: Language,
  economySnapshot: { signal: number; memory_shard: number },
): TurnOutput {
  const fallbackNarrative =
    language === 'ko-KR'
      ? '[ì‹œìŠ¤í…œ] ì„œë²„ ì—°ê²°ì— ì‹¤íŒ¨í–ˆìŠµë‹ˆë‹¤. ë‹¤ì‹œ ì‹œë„í•´ ì£¼ì„¸ìš”.'
      : '[System] Failed to connect to server. Please try again.';

  return {
    language,
    narrative: fallbackNarrative,
    economy: {
      cost: { signal: 0, memory_shard: 0 },
      // RU-002-S1: ì…ë ¥ ìŠ¤ëƒ…ìƒ· ê·¸ëŒ€ë¡œ ìœ ì§€ (ë¹„ìš© 0, ì”ì•¡ ë³€í™” ì—†ìŒ)
      balance_after: {
        signal: economySnapshot.signal,
        memory_shard: economySnapshot.memory_shard,
      },
    },
    safety: {
      blocked: false,
      message: null,
    },
    ui: {
      action_deck: { cards: [] },
      objects: [],
      scene: { image_url: null, alt_text: null },
    },
    world: {
      rules_changed: [],
      inventory_added: [],
      inventory_removed: [],
      quests_updated: [],
      relationships_changed: [],
      memory_pins: [],
    },
    render: {
      image_job: null,
    },
    agent_console: {
      current_phase: 'commit',
      badges: ['schema_fail'],
      repair_count: 1,
    },
  };
}

/**
 * í„´ ìŠ¤íŠ¸ë¦¼ì„ ì‹œì‘í•˜ê³  ì·¨ì†Œ í•¨ìˆ˜ë¥¼ ë°˜í™˜í•©ë‹ˆë‹¤.
 *
 * @param input - í„´ ì…ë ¥ ë°ì´í„°
 * @param callbacks - ì´ë²¤íŠ¸ ì½œë°±
 * @returns ì·¨ì†Œ í•¨ìˆ˜
 */
export function startTurnStream(input: TurnInput, callbacks: StreamCallbacks): () => void {
  const controller = new AbortController();

  executeTurnStream(input, callbacks, { signal: controller.signal });

  return () => controller.abort();
}
</file>

<file path="frontend/src/components/SceneCanvas.tsx">
/**
 * Unknown World - Scene Canvas ì»´í¬ë„ŒíŠ¸
 *
 * RULE-002 ì¤€ìˆ˜: ì±„íŒ… ë²„ë¸”ì´ ì•„ë‹Œ ê²Œì„ UI
 * RULE-009 ì¤€ìˆ˜: ì¢Œí‘œ ê·œì•½ (0~1000 ì •ê·œí™”, bbox=[ymin,xmin,ymax,xmax])
 *
 * U-010[Mvp]: í•«ìŠ¤íŒŸ ì˜¤ë²„ë ˆì´ + í´ë¦­ ì²˜ë¦¬
 * - TurnOutputì˜ objects[]/hotspots[]ë¥¼ ê¸°ë°˜ìœ¼ë¡œ ì˜¤ë²„ë ˆì´ ë Œë”
 * - hover ì‹œ í•˜ì´ë¼ì´íŠ¸/íˆ´íŒ í‘œì‹œ
 * - click ì‹œ object_id + box_2dë¥¼ TurnInputì— í¬í•¨í•´ ì „ì†¡
 *
 * U-012[Mvp]: DnD ë“œë¡­ íƒ€ê²Ÿ í™•ì¥
 * - í•«ìŠ¤íŒŸì„ droppable ì˜ì—­ìœ¼ë¡œ ë§Œë“¤ì–´ ì¸ë²¤í† ë¦¬ ì•„ì´í…œ ë“œë¡­ ì²˜ë¦¬
 * - ë“œë˜ê·¸ ì˜¤ë²„ ì‹œ í•˜ì´ë¼ì´íŠ¸ ê°•í™”
 * - ë“œë¡­ ì„±ê³µ/ì‹¤íŒ¨ ì¦‰ì‹œ ì‹œê°í™”
 *
 * @module components/SceneCanvas
 */

import { useState, useRef, useCallback, useEffect, useMemo } from 'react';
import { useTranslation } from 'react-i18next';
import { useDroppable } from '@dnd-kit/core';
import type { SceneCanvasStatus, PlaceholderInfo } from '../types/scene';
import type { SceneObject, Box2D } from '../schemas/turn';
import { box2dToPixel, type CanvasSize } from '../utils/box2d';
import {
  DND_TYPE,
  type HotspotDropData,
  isHotspotInteractionAllowed,
  compareHotspotPriority,
} from '../dnd/types';
import { useWorldStore } from '../stores/worldStore';
import { useAgentStore } from '../stores/agentStore';

// =============================================================================
// ìƒìˆ˜ ì •ì˜
// =============================================================================

/**
 * ìƒíƒœë³„ placeholder ì •ë³´ (U-031: Placeholder Pack)
 * labelKeyëŠ” i18n ë²ˆì—­ í‚¤ë¡œ ì‚¬ìš©ë©ë‹ˆë‹¤.
 */
export const SCENE_PLACEHOLDERS: Record<Exclude<SceneCanvasStatus, 'scene'>, PlaceholderInfo> = {
  default: {
    imagePath: '/ui/placeholders/scene-placeholder-default.png',
    fallbackEmoji: 'ğŸ“¡',
    labelKey: 'scene.status.default',
  },
  loading: {
    imagePath: '/ui/placeholders/scene-loading.webp',
    fallbackEmoji: 'â³',
    labelKey: 'scene.status.loading',
  },
  offline: {
    imagePath: '/ui/placeholders/scene-offline.webp',
    fallbackEmoji: 'ğŸ”Œ',
    labelKey: 'scene.status.offline',
  },
  blocked: {
    imagePath: '/ui/placeholders/scene-blocked.webp',
    fallbackEmoji: 'ğŸš«',
    labelKey: 'scene.status.blocked',
  },
  low_signal: {
    imagePath: '/ui/placeholders/scene-low-signal.webp',
    fallbackEmoji: 'ğŸ“‰',
    labelKey: 'scene.status.low_signal',
  },
};

// =============================================================================
// íƒ€ì… ì •ì˜
// =============================================================================

/**
 * í•«ìŠ¤íŒŸ í´ë¦­ ì´ë²¤íŠ¸ ë°ì´í„° (Q1 ê²°ì •: Option B - object_id + box_2d)
 */
export interface HotspotClickData {
  /** í´ë¦­í•œ ì˜¤ë¸Œì íŠ¸ ID */
  object_id: string;
  /** í´ë¦­í•œ ì˜¤ë¸Œì íŠ¸ì˜ ë°”ìš´ë”© ë°•ìŠ¤ (0~1000 ì •ê·œí™”) */
  box_2d: Box2D;
}

interface SceneCanvasProps {
  /** í•«ìŠ¤íŒŸ í´ë¦­ ì½œë°± */
  onHotspotClick?: (data: HotspotClickData) => void;
  /** ìŠ¤íŠ¸ë¦¬ë° ì¤‘ ì—¬ë¶€ (ë¹„í™œì„±í™”ìš©, ìƒëµ ì‹œ agentStore.isStreaming ì‚¬ìš©) */
  disabled?: boolean;
}

// =============================================================================
// ë‚´ë¶€ ì»´í¬ë„ŒíŠ¸: í•«ìŠ¤íŒŸ ì˜¤ë²„ë ˆì´
// =============================================================================

interface HotspotOverlayProps {
  object: SceneObject;
  canvasSize: CanvasSize;
  onClick: (data: HotspotClickData) => void;
  disabled: boolean;
  /** RU-003-S2: ë°ëª¨ ìƒíƒœ ì—¬ë¶€ (ì‹œê°ì  íŒíŠ¸ í•„ìš”) */
  isDemoState?: boolean;
  /** RU-003-S2 Step 2: ìš°ì„ ìˆœìœ„ ê¸°ë°˜ z-index ìŠ¤íƒ€ì¼ */
  style?: React.CSSProperties;
}

/**
 * ê°œë³„ í•«ìŠ¤íŒŸ ì˜¤ë²„ë ˆì´ ì»´í¬ë„ŒíŠ¸ (U-010 + U-012)
 *
 * - í´ë¦­ ì‹œ object_id + box_2d ì „ì†¡ (U-010)
 * - ë“œë¡­ íƒ€ê²Ÿìœ¼ë¡œ ë™ì‘ - dnd-kit useDroppable ì‚¬ìš© (U-012)
 */
function HotspotOverlay({
  object,
  canvasSize,
  onClick,
  disabled,
  isDemoState = false,
  style,
}: HotspotOverlayProps) {
  const [isHovered, setIsHovered] = useState(false);
  const { t } = useTranslation();

  // U-012: useDroppable í›…ìœ¼ë¡œ ë“œë¡­ íƒ€ê²Ÿ ì„¤ì • (RU-003-Q1: ìƒìˆ˜/íƒ€ì… ê¸°ë°˜)
  const dropData: HotspotDropData = {
    type: DND_TYPE.HOTSPOT,
    object_id: object.id,
    box_2d: object.box_2d,
    label: object.label,
  };
  const { isOver, setNodeRef } = useDroppable({
    id: `hotspot-${object.id}`,
    data: dropData,
    disabled,
  });

  // box_2d(0~1000) â†’ px ë³€í™˜
  const pixelBox = box2dToPixel(object.box_2d, canvasSize);

  const handleClick = useCallback(() => {
    if (disabled) return;
    onClick({
      object_id: object.id,
      box_2d: object.box_2d,
    });
  }, [disabled, onClick, object.id, object.box_2d]);

  const handleKeyDown = useCallback(
    (e: React.KeyboardEvent) => {
      if (disabled) return;
      if (e.key === 'Enter' || e.key === ' ') {
        e.preventDefault();
        handleClick();
      }
    },
    [disabled, handleClick],
  );

  // ë“œë˜ê·¸ ì˜¤ë²„ ìƒíƒœ ë˜ëŠ” ë§ˆìš°ìŠ¤ í˜¸ë²„ ìƒíƒœ
  const isHighlighted = isHovered || isOver;

  // RU-003-S2: ë°ëª¨ ìƒíƒœ í´ë˜ìŠ¤ ì¶”ê°€
  const demoClass = isDemoState ? 'demo-target' : '';

  return (
    <div
      ref={setNodeRef}
      className={`hotspot-overlay ${isHighlighted ? 'hovered' : ''} ${disabled ? 'disabled' : ''} ${isOver ? 'drop-target-active' : ''} ${demoClass}`}
      style={{
        position: 'absolute',
        top: `${pixelBox.top}px`,
        left: `${pixelBox.left}px`,
        width: `${pixelBox.width}px`,
        height: `${pixelBox.height}px`,
        ...style,
      }}
      onClick={handleClick}
      onMouseEnter={() => setIsHovered(true)}
      onMouseLeave={() => setIsHovered(false)}
      onKeyDown={handleKeyDown}
      role="button"
      tabIndex={disabled ? -1 : 0}
      aria-label={object.label}
      aria-disabled={disabled}
      data-drop-target={!disabled}
      data-demo-state={isDemoState}
    >
      {/* í˜¸ë²„ ë˜ëŠ” ë“œë˜ê·¸ ì˜¤ë²„ ì‹œ íˆ´íŒ í‘œì‹œ */}
      {isHighlighted && !disabled && (
        <div className="hotspot-tooltip">
          <span className="hotspot-tooltip-label">{object.label}</span>
          {/* RU-003-S2: ë°ëª¨ ìƒíƒœ í‘œì‹œ */}
          {isDemoState && (
            <span className="hotspot-tooltip-demo">{t('scene.hotspot.demo_hint')}</span>
          )}
          {/* U-012: ë“œë˜ê·¸ ì˜¤ë²„ ì‹œ ë“œë¡­ íŒíŠ¸ í‘œì‹œ */}
          {isOver && (
            <span className="hotspot-tooltip-drop-hint">{t('scene.hotspot.drop_hint')}</span>
          )}
          {!isOver && !isDemoState && object.interaction_hint && (
            <span className="hotspot-tooltip-hint">
              {t('scene.hotspot.hint_prefix')}: {object.interaction_hint}
            </span>
          )}
        </div>
      )}
    </div>
  );
}

// =============================================================================
// ë©”ì¸ ì»´í¬ë„ŒíŠ¸
// =============================================================================

/**
 * Scene Canvas ì»´í¬ë„ŒíŠ¸
 *
 * U-010[Mvp]: í•«ìŠ¤íŒŸ ì˜¤ë²„ë ˆì´ + í´ë¦­ ì²˜ë¦¬
 * U-031[Mvp]: Placeholder Pack
 *
 * - ìƒíƒœì— ë”°ë¼ placeholder ì´ë¯¸ì§€ì™€ ë¼ë²¨ì„ í‘œì‹œí•©ë‹ˆë‹¤.
 * - 'scene' ìƒíƒœì—ì„œëŠ” ì‹¤ì œ ì´ë¯¸ì§€ë¥¼ ë Œë”ë§í•˜ë©°, ë¡œë“œ ì‹¤íŒ¨ ì‹œ í´ë°±ì„ ì œê³µí•©ë‹ˆë‹¤.
 * - objects ë°°ì—´ì´ ìˆìœ¼ë©´ í•«ìŠ¤íŒŸ ì˜¤ë²„ë ˆì´ë¥¼ ë Œë”ë§í•©ë‹ˆë‹¤.
 */
export function SceneCanvas({ onHotspotClick, disabled: propsDisabled }: SceneCanvasProps) {
  const { t } = useTranslation();

  // Store ìƒíƒœ (RU-003: ì»´í¬ë„ŒíŠ¸ ë‚´ì—ì„œ ì§ì ‘ êµ¬ë…)
  const state = useWorldStore((state) => state.sceneState);
  const objects = useWorldStore((state) => state.sceneObjects);
  const isStreaming = useAgentStore((state) => state.isStreaming);

  const disabled = propsDisabled ?? isStreaming;

  const { status, imageUrl, message } = state;
  const [imageError, setImageError] = useState(false);
  const [canvasSize, setCanvasSize] = useState<CanvasSize>({ width: 0, height: 0 });
  const canvasRef = useRef<HTMLDivElement>(null);

  // RU-003-S2 Step 3: ResizeObserverì— ë””ë°”ìš´ìŠ¤ ì ìš©
  // ë“œë˜ê·¸ ì¤‘ í•«ìŠ¤íŒŸ ì˜ì—­ì´ ê³¼ë„í•˜ê²Œ í”ë“¤ë¦¬ëŠ” ê²ƒì„ ë°©ì§€
  useEffect(() => {
    const element = canvasRef.current;
    if (!element) return;

    let resizeTimeout: ReturnType<typeof setTimeout> | null = null;
    const RESIZE_DEBOUNCE_MS = 100; // ë””ë°”ìš´ìŠ¤ ê°„ê²©

    const resizeObserver = new ResizeObserver((entries) => {
      // ë””ë°”ìš´ìŠ¤: ë§ˆì§€ë§‰ ë¦¬ì‚¬ì´ì¦ˆ ì´ë²¤íŠ¸ í›„ ì¼ì • ì‹œê°„ í›„ì—ë§Œ ì—…ë°ì´íŠ¸
      if (resizeTimeout) {
        clearTimeout(resizeTimeout);
      }
      resizeTimeout = setTimeout(() => {
        for (const entry of entries) {
          const { width, height } = entry.contentRect;
          // ì˜ë¯¸ ìˆëŠ” í¬ê¸° ë³€í™”ë§Œ ì ìš© (5px ì´ìƒ ì°¨ì´)
          setCanvasSize((prev) => {
            if (Math.abs(prev.width - width) > 5 || Math.abs(prev.height - height) > 5) {
              return { width, height };
            }
            return prev;
          });
        }
      }, RESIZE_DEBOUNCE_MS);
    });

    resizeObserver.observe(element);

    // ì´ˆê¸° í¬ê¸° ì„¤ì •
    const rect = element.getBoundingClientRect();
    setCanvasSize({ width: rect.width, height: rect.height });

    return () => {
      if (resizeTimeout) {
        clearTimeout(resizeTimeout);
      }
      resizeObserver.disconnect();
    };
  }, []);

  // í•«ìŠ¤íŒŸ í´ë¦­ í•¸ë“¤ëŸ¬
  const handleHotspotClick = useCallback(
    (data: HotspotClickData) => {
      if (onHotspotClick) {
        onHotspotClick(data);
      }
    },
    [onHotspotClick],
  );

  // ì •ìƒ ì¥ë©´ í‘œì‹œ ì¤‘ì´ê±°ë‚˜ ì´ë¯¸ì§€ ì—ëŸ¬ê°€ ë°œìƒí•œ ê²½ìš°
  const isSceneActive = status === 'scene' && imageUrl && !imageError;

  // placeholder ì •ë³´ ê²°ì • (scene ìƒíƒœì—ì„œ ì—ëŸ¬ ì‹œ defaultë¡œ í´ë°±)
  const effectiveStatus = status === 'scene' && imageError ? 'default' : status;
  const isPlaceholderVisible = effectiveStatus !== 'scene';

  const placeholder = isPlaceholderVisible
    ? SCENE_PLACEHOLDERS[effectiveStatus as Exclude<SceneCanvasStatus, 'scene'>]
    : null;

  // RU-003-S2 Step 1: í•«ìŠ¤íŒŸ ë Œë”ë§ ì¡°ê±´ì„ SSOTë¡œ ê³ ì •
  // - isHotspotInteractionAllowed()ë¡œ í—ˆìš© ìƒíƒœ ê²€ì‚¬ (scene, default)
  // - objects ì¡´ì¬ + ìº”ë²„ìŠ¤ í¬ê¸° í™•ë³´
  const isInteractionAllowed = isHotspotInteractionAllowed(status);
  const shouldRenderHotspots = isInteractionAllowed && objects.length > 0 && canvasSize.width > 0;

  // RU-003-S2: ë°ëª¨ ìƒíƒœ ì—¬ë¶€ (ì‹œê°ì  íŒíŠ¸ í•„ìš”)
  const isDemoState = status === 'default' && !isSceneActive;

  // RU-003-S2 Step 2: í•«ìŠ¤íŒŸì„ ë©´ì  ê¸°ì¤€ìœ¼ë¡œ ì •ë ¬ (ì‘ì€ ê²ƒì´ ë’¤ì— = ë†’ì€ z-index)
  const sortedObjects = useMemo(() => {
    if (objects.length <= 1) return objects;
    return [...objects].sort((a, b) => compareHotspotPriority(a.box_2d, b.box_2d));
  }, [objects]);

  return (
    <div
      ref={canvasRef}
      className={`scene-canvas ${isSceneActive ? 'scene-active' : `scene-status-${effectiveStatus}`} ${shouldRenderHotspots ? 'has-hotspots' : ''}`}
      style={placeholder ? { backgroundImage: `url('${placeholder.imagePath}')` } : {}}
    >
      {isSceneActive && (
        <img
          src={imageUrl}
          alt={t('scene.status.alt')}
          className="scene-image"
          onError={() => setImageError(true)}
        />
      )}

      {isPlaceholderVisible && placeholder && (
        <div className="scene-placeholder">
          {/* í…ìŠ¤íŠ¸ í´ë°± (ì´ë¯¸ì§€ ë¡œë“œ ì‹¤íŒ¨ ì‹œì—ë„ í‘œì‹œ) */}
          <p className="text-glow scene-status-label">
            <span className="scene-status-emoji" aria-hidden="true">
              {placeholder.fallbackEmoji}
            </span>{' '}
            {t(placeholder.labelKey)}
          </p>
          {(message || (status === 'scene' && imageError)) && (
            <p className="scene-status-message">
              {message || (imageError ? t('scene.status.image_error') : '')}
            </p>
          )}
        </div>
      )}

      {/* í•«ìŠ¤íŒŸ ì˜¤ë²„ë ˆì´ ë ˆì´ì–´ (RU-003-S2: ë©´ì ìˆœ ì •ë ¬) */}
      {shouldRenderHotspots && (
        <div className="hotspot-layer" aria-label={t('scene.hotspot.layer_label')}>
          {sortedObjects.map((obj, index) => (
            <HotspotOverlay
              key={obj.id}
              object={obj}
              canvasSize={canvasSize}
              onClick={handleHotspotClick}
              disabled={disabled}
              isDemoState={isDemoState}
              // RU-003-S2 Step 2: ì¸ë±ìŠ¤ ê¸°ë°˜ z-indexë¡œ ì‘ì€ ê²ƒì´ ìœ„ì— í‘œì‹œ
              style={{ zIndex: index + 1 }}
            />
          ))}
        </div>
      )}
    </div>
  );
}
</file>

<file path="frontend/src/locales/ko-KR/translation.json">
{
  "profile": {
    "select_title": "í”„ë¡œí•„ì„ ì„ íƒí•˜ì„¸ìš”",
    "select_hint": "í”„ë¡œí•„ë§ˆë‹¤ ë‹¤ë¥¸ ì‹œì‘ ì¡°ê±´ê³¼ ëª©í‘œê°€ ìˆìŠµë‹ˆë‹¤",
    "or": "ë˜ëŠ”",
    "continue_saved": "ì €ì¥ëœ ê²Œì„ ê³„ì†í•˜ê¸°",
    "change": "í”„ë¡œí•„ ë³€ê²½",
    "change_tooltip": "ë‹¤ë¥¸ í”„ë¡œí•„ë¡œ ìƒˆ ê²Œì„ ì‹œì‘",
    "narrator": {
      "name": "ì„œì‚¬ê¾¼",
      "description": "í’ë¶€í•œ ìì›ìœ¼ë¡œ ë‹¤ì–‘í•œ ì´ì•¼ê¸°ë¥¼ íƒí—˜í•˜ì„¸ìš”",
      "welcome": "ê³ ëŒ€ì˜ ë„ì„œê´€ì— ì˜¤ì‹  ê²ƒì„ í™˜ì˜í•©ë‹ˆë‹¤. ì´ê³³ì—ëŠ” ìŠí˜€ì§„ ì´ì•¼ê¸°ë“¤ì´ ì ë“¤ì–´ ìˆìŠµë‹ˆë‹¤...",
      "items": {
        "ancient_tome": "ê³ ëŒ€ ì„œì±…",
        "quill_pen": "ê¹ƒíœ",
        "memory_fragment": "ê¸°ì–µ ì¡°ê°"
      },
      "quest": {
        "discover_origin": "ì„¸ê³„ì˜ ê¸°ì›ì„ ë°œê²¬í•˜ê¸°",
        "collect_memories": "ê¸°ì–µ ì¡°ê° 3ê°œ ìˆ˜ì§‘í•˜ê¸°"
      },
      "rule": {
        "time_flows": "ì‹œê°„ì˜ íë¦„",
        "time_flows_desc": "ì‹œê°„ì€ ì •ìƒì ìœ¼ë¡œ íë¦…ë‹ˆë‹¤",
        "memories_persist": "ê¸°ì–µì˜ ì§€ì†",
        "memories_persist_desc": "í•œë²ˆ ì–»ì€ ê¸°ì–µì€ ì‚¬ë¼ì§€ì§€ ì•ŠìŠµë‹ˆë‹¤"
      },
      "scene": {
        "bookshelf": "ì‹ ë¹„í•œ ì±…ì¥",
        "bookshelf_hint": "ì˜¤ë˜ëœ ì±…ë“¤ì´ ë¹›ë‚˜ê³  ìˆë‹¤",
        "portal": "ë¹›ë‚˜ëŠ” í¬íƒˆ",
        "portal_hint": "ì–´ë”˜ê°€ë¡œ í†µí•˜ëŠ” ê²ƒ ê°™ë‹¤"
      }
    },
    "explorer": {
      "name": "íƒí—˜ê°€",
      "description": "ë¯¸ì§€ì˜ ì˜ì—­ì„ íƒí—˜í•˜ê³  ë¹„ë°€ì„ ë°œê²¬í•˜ì„¸ìš”",
      "welcome": "ì–´ë‘ìš´ ë¯¸ë¡œì—ì„œ ëˆˆì„ ë–´ìŠµë‹ˆë‹¤. ì¶œêµ¬ë¥¼ ì°¾ì•„ ì´ê³³ì„ íƒˆì¶œí•´ì•¼ í•©ë‹ˆë‹¤...",
      "items": {
        "compass": "ë‚˜ì¹¨ë°˜",
        "rope": "ë°§ì¤„",
        "lantern": "ëœí„´",
        "map_fragment": "ì§€ë„ ì¡°ê°"
      },
      "quest": {
        "find_exit": "íƒˆì¶œêµ¬ ì°¾ê¸°",
        "explore_areas": "3ê°œ êµ¬ì—­ íƒí—˜í•˜ê¸°",
        "gather_supplies": "ë³´ê¸‰í’ˆ ìˆ˜ì§‘"
      },
      "rule": {
        "gravity": "ì¤‘ë ¥ ë²•ì¹™",
        "gravity_desc": "ë¬¼ì²´ëŠ” ì•„ë˜ë¡œ ë–¨ì–´ì§‘ë‹ˆë‹¤",
        "darkness": "ì–´ë‘ ì˜ ë²•ì¹™",
        "darkness_desc": "ë¹› ì—†ì´ëŠ” ì•ì„ ë³¼ ìˆ˜ ì—†ìŠµë‹ˆë‹¤"
      },
      "scene": {
        "door": "ê³ ëŒ€ì˜ ë¬¸",
        "door_hint": "ì—´ì‡ ê°€ í•„ìš”í•´ ë³´ì¸ë‹¤",
        "mechanism": "ì´ìƒí•œ ì¥ì¹˜",
        "mechanism_hint": "ì‘ë™ì‹œí‚¬ ìˆ˜ ìˆì„ ê²ƒ ê°™ë‹¤",
        "passage": "ìˆ¨ê²¨ì§„ í†µë¡œ",
        "passage_hint": "ì–´ë””ë¡œ ì´ì–´ì§ˆê¹Œ?"
      }
    },
    "tech": {
      "name": "ê¸°ìˆ  ì „ë¬¸ê°€",
      "description": "ì œí•œëœ ìì›ìœ¼ë¡œ íš¨ìœ¨ì ì¸ ì „ëµì„ ì„¸ìš°ì„¸ìš”",
      "welcome": "ì‹œìŠ¤í…œ ë¶€íŒ… ì™„ë£Œ. ì œí•œëœ ì—ë„ˆì§€ë¡œ ìµœì ì˜ ê²½ë¡œë¥¼ ì°¾ì•„ì•¼ í•©ë‹ˆë‹¤...",
      "items": {
        "data_core": "ë°ì´í„° ì½”ì–´",
        "circuit_board": "íšŒë¡œ ê¸°íŒ",
        "energy_cell": "ì—ë„ˆì§€ ì…€",
        "scanner": "ìŠ¤ìºë„ˆ ì¥ì¹˜"
      },
      "quest": {
        "analyze_system": "ì‹œìŠ¤í…œ ë¶„ì„ ì™„ë£Œí•˜ê¸°",
        "optimize_resources": "ìì› íš¨ìœ¨ ìµœì í™”í•˜ê¸°"
      },
      "rule": {
        "energy_conservation": "ì—ë„ˆì§€ ë³´ì¡´",
        "energy_conservation_desc": "ì—ë„ˆì§€ëŠ” ìƒì„±ë˜ê±°ë‚˜ ì†Œë©¸ë˜ì§€ ì•ŠìŠµë‹ˆë‹¤",
        "data_integrity": "ë°ì´í„° ë¬´ê²°ì„±",
        "data_integrity_desc": "ì†ìƒëœ ë°ì´í„°ëŠ” ë³µêµ¬í•  ìˆ˜ ì—†ìŠµë‹ˆë‹¤",
        "system_limits": "ì‹œìŠ¤í…œ í•œê³„",
        "system_limits_desc": "ë™ì‹œ ì²˜ë¦¬ëŸ‰ì— ì œí•œì´ ìˆìŠµë‹ˆë‹¤"
      },
      "scene": {
        "terminal": "ë©”ì¸ í„°ë¯¸ë„",
        "terminal_hint": "ì‹œìŠ¤í…œì— ì ‘ì†í•  ìˆ˜ ìˆë‹¤",
        "conduit": "ì „ë ¥ ë„ê´€",
        "conduit_hint": "ì—ë„ˆì§€ê°€ íë¥´ê³  ìˆë‹¤"
      }
    }
  },
  "reset": {
    "button": "ë¦¬ì…‹",
    "confirm": "ë‹¤ì‹œ í´ë¦­í•˜ì—¬ í™•ì¸",
    "cancel": "ì·¨ì†Œ",
    "tooltip": "í˜„ì¬ í”„ë¡œí•„ì˜ ì´ˆê¸° ìƒíƒœë¡œ ë˜ëŒë¦½ë‹ˆë‹¤"
  },
  "demo": {
    "items": {
      "keycard-alpha": {
        "name": "í‚¤ì¹´ë“œ A"
      },
      "medkit": {
        "name": "ì‘ê¸‰ í‚¤íŠ¸"
      },
      "flashlight": {
        "name": "ì†ì „ë“±"
      },
      "data-chip": {
        "name": "ë°ì´í„°ì¹©"
      }
    },
    "scene": {
      "terminal": {
        "label": "í„°ë¯¸ë„",
        "hint": "í™œì„±í™”ëœ í„°ë¯¸ë„ì´ë‹¤"
      },
      "door": {
        "label": "ë¬¸",
        "hint": "ì ê²¨ìˆëŠ” ê²ƒ ê°™ë‹¤"
      }
    },
    "quest": {
      "terminal": {
        "label": "í„°ë¯¸ë„ì— ì ‘ì†í•˜ê¸°"
      },
      "escape": {
        "label": "ì‹œì„¤ íƒˆì¶œêµ¬ ì°¾ê¸°"
      },
      "collect": {
        "label": "ë°ì´í„°ì¹© ìˆ˜ì§‘"
      }
    },
    "rule": {
      "gravity": {
        "label": "ì¤‘ë ¥ ë²•ì¹™",
        "description": "ë¬¼ì²´ëŠ” ì•„ë˜ë¡œ ë–¨ì–´ì§„ë‹¤"
      },
      "time": {
        "label": "ì‹œê°„ íë¦„",
        "description": "ì‹œê°„ì€ ì •ìƒ ì†ë„ë¡œ íë¥¸ë‹¤"
      }
    }
  },
  "quest": {
    "empty": "[ ëª©í‘œ ì—†ìŒ ]",
    "completed": "ì™„ë£Œ",
    "section": {
      "active": "ì§„í–‰ ì¤‘",
      "completed": "ì™„ë£Œë¨"
    }
  },
  "rule_board": {
    "empty": "[ ê·œì¹™ ì—†ìŒ ]",
    "active_count": "í™œì„± ê·œì¹™: {{count}}ê°œ"
  },
  "mutation": {
    "empty": "[ ë³€í˜• ì´ë ¥ ì—†ìŒ ]",
    "timeline_title": "ë³€í˜• íƒ€ì„ë¼ì¸",
    "event_count": "{{count}}ê°œ ì´ë²¤íŠ¸",
    "more_events": "+{{count}}ê°œ ë” ë³´ê¸°",
    "turn_label": "T{{turn}}",
    "type": {
      "added": "ì¶”ê°€ë¨",
      "modified": "ìˆ˜ì •ë¨",
      "removed": "ì œê±°ë¨"
    }
  },
  "scene": {
    "status": {
      "default": "ë°ì´í„° ëŒ€ê¸° ì¤‘",
      "loading": "ë™ê¸°í™” ì¤‘...",
      "offline": "ì—°ê²° ëŠê¹€",
      "blocked": "ì ‘ê·¼ ì œí•œë¨",
      "low_signal": "ì‹ í˜¸ ì•½í•¨",
      "image_error": "ì¥ë©´ ì´ë¯¸ì§€ë¥¼ ë¶ˆëŸ¬ì˜¬ ìˆ˜ ì—†ìŠµë‹ˆë‹¤.",
      "initial_sync": "ì „ì—­ ë°ì´í„° ë™ê¸°í™” ëŒ€ê¸° ì¤‘...",
      "syncing": "ë°ì´í„° ë™ê¸°í™” ì¤‘...",
      "alt": "ì¥ë©´ ì´ë¯¸ì§€"
    },
    "hotspot": {
      "layer_label": "í´ë¦­ ê°€ëŠ¥í•œ ì˜¤ë¸Œì íŠ¸ ì˜ì—­",
      "hint_prefix": "íŒíŠ¸",
      "click_action": "{{label}} í´ë¦­",
      "drop_hint": "ì—¬ê¸°ì— ë“œë¡­í•˜ì—¬ ì‚¬ìš©",
      "drop_action": "{{item}}ì„(ë¥¼) {{target}}ì— ì‚¬ìš©",
      "drop_invalid": "ê·¸ê³³ì—ëŠ” {{item}}ì„(ë¥¼) ì‚¬ìš©í•  ìˆ˜ ì—†ìŠµë‹ˆë‹¤.",
      "demo_hint": "[ë°ëª¨ ëŒ€ìƒ]"
    }
  },
  "agent": {
    "console": {
      "queue": "ëŒ€ê¸°ì—´",
      "badges": "ê²€ì¦ ë°°ì§€",
      "repair": "ìë™ ë³µêµ¬",
      "status": {
        "idle": "ëŒ€ê¸° ì¤‘",
        "processing": "ì²˜ë¦¬ ì¤‘"
      },
      "badges_empty": "[ ê²€ì¦ ëŒ€ê¸° ì¤‘ ]",
      "repaired": "(ë³µêµ¬ë¨)",
      "phase": {
        "parse": "Parse",
        "validate": "Validate",
        "plan": "Plan",
        "resolve": "Resolve",
        "render": "Render",
        "verify": "Verify",
        "commit": "Commit"
      },
      "badge": {
        "schema": "Schema",
        "economy": "Economy",
        "safety": "Safety",
        "consistency": "Consistency",
        "ok": "OK",
        "fail": "FAIL"
      }
    }
  },
  "ui": {
    "logo": "UNKNOWN WORLD",
    "command_placeholder": "ëª…ë ¹ì„ ì…ë ¥í•˜ì„¸ìš”...",
    "processing": "ì²˜ë¦¬ ì¤‘...",
    "execute": "ì‹¤í–‰",
    "wait": "ëŒ€ê¸°",
    "panel_placeholder": "[ ì¤€ë¹„ ì¤‘ ]",
    "scale_decrease": "ê¸€ì í¬ê¸° ì¤„ì´ê¸°",
    "scale_increase": "ê¸€ì í¬ê¸° ëŠ˜ë¦¬ê¸°",
    "scale_label": "UI ìŠ¤ì¼€ì¼ ì„¤ì •"
  },
  "economy": {
    "signal": "Signal",
    "shard": "Shard",
    "signal_cost": "Signal ì†Œëª¨",
    "shard_cost": "Shard ì†Œëª¨",
    "risk_level": "ìœ„í—˜ë„",
    "hud_label": "ì¬í™” í˜„í™©",
    "estimated_cost": "ì˜ˆìƒ ë¹„ìš©",
    "confirmed_cost": "í™•ì • ë¹„ìš©",
    "insufficient_funds": "ì”ì•¡ ë¶€ì¡±",
    "low_balance_warning": "ì”ì•¡ì´ ë¶€ì¡±í•©ë‹ˆë‹¤",
    "alternatives_title": "ëŒ€ì•ˆ í–‰ë™",
    "alternative_text_only": "í…ìŠ¤íŠ¸ë§Œ ìƒì„± (ì´ë¯¸ì§€ ì—†ìŒ)",
    "alternative_low_quality": "ì €í’ˆì§ˆ/ë¹ ë¥¸ ì‘ë‹µ ì„ íƒ",
    "ledger_title": "ìµœê·¼ ì›ì¥ ì´ë ¥",
    "ledger_empty": "[ ì´ë ¥ ì—†ìŒ ]",
    "model_label": {
      "FAST": "ë¹ ë¦„",
      "QUALITY": "ê³ í’ˆì§ˆ",
      "CHEAP": "ì €ë¹„ìš©",
      "REF": "ì°¸ì¡°"
    }
  },
  "connection": {
    "online": "ì˜¨ë¼ì¸",
    "offline": "ì˜¤í”„ë¼ì¸"
  },
  "inventory": {
    "empty": "[ ì•„ì´í…œ ì—†ìŒ ]",
    "grid_label": "ì¸ë²¤í† ë¦¬ ì•„ì´í…œ ëª©ë¡",
    "item_label": "{{name}} (ìˆ˜ëŸ‰: {{quantity}})",
    "drag_hint": "ë“œë˜ê·¸í•˜ì—¬ ì‚¬ìš©"
  },
  "panel": {
    "inventory": {
      "title": "Inventory",
      "placeholder": "[ ë“œë˜ê·¸ ì•¤ ë“œë¡­ ì˜ì—­ ]"
    },
    "quest": {
      "title": "Quest",
      "placeholder": "[ ëª©í‘œ/í€˜ìŠ¤íŠ¸ ëª©ë¡ ]"
    },
    "rule_board": {
      "title": "Rule Board",
      "placeholder": "[ ì›”ë“œ ê·œì¹™/ë³€í˜• íƒ€ì„ë¼ì¸ ]"
    },
    "agent_console": {
      "title": "Agent Console"
    },
    "memory_pin": {
      "title": "Memory Pin",
      "placeholder": "[ ê³ ì •ëœ ê¸°ì–µ/ë‹¨ì„œ ]"
    },
    "scanner": {
      "title": "Scanner",
      "placeholder": "[ ì´ë¯¸ì§€ ì—…ë¡œë“œ ìŠ¬ë¡¯ ]"
    }
  },
  "action": {
    "default": {
      "explore": {
        "label": "íƒìƒ‰í•˜ê¸°",
        "description": "ì£¼ë³€ì„ ì‚´í´ë³¸ë‹¤"
      },
      "investigate": {
        "label": "ì¡°ì‚¬í•˜ê¸°",
        "description": "ìì„¸íˆ ì‚´í´ë³¸ë‹¤"
      },
      "talk": {
        "label": "ëŒ€í™”í•˜ê¸°",
        "description": "ë§ì„ ê±¸ì–´ë³¸ë‹¤"
      }
    },
    "card_select": "ì¹´ë“œ ì„ íƒ: {{cardId}}",
    "deck_label": "í–‰ë™ ì„ íƒ ì¹´ë“œ",
    "alternative": "ëŒ€ì•ˆ",
    "insufficient_balance": "ì”ì•¡ ë¶€ì¡±",
    "all_disabled_notice": "ì‹¤í–‰ ê°€ëŠ¥í•œ í–‰ë™ì´ ì—†ìŠµë‹ˆë‹¤. ëŒ€ì•ˆì„ í™•ì¸í•˜ì„¸ìš”.",
    "risk": {
      "low": "ë‚®ìŒ",
      "medium": "ë³´í†µ",
      "high": "ë†’ìŒ"
    },
    "cost_range": "{{min}}~{{max}}"
  },
  "narrative": {
    "welcome": "ë¯¸ì§€ì˜ ì„¸ê³„ì— ì˜¤ì‹  ê²ƒì„ í™˜ì˜í•©ë‹ˆë‹¤...",
    "turn_label": "[TURN {{turn}}]",
    "streaming_label": "[STREAMING]"
  }
}
</file>

<file path="frontend/src/App.tsx">
/**
 * Unknown World - ë©”ì¸ ê²Œì„ UI ë ˆì´ì•„ì›ƒ
 *
 * RULE-002 ì¤€ìˆ˜: ì±„íŒ… ë²„ë¸” UI ê¸ˆì§€
 * - ë‚´ëŸ¬í‹°ë¸ŒëŠ” "ì±„íŒ…"ì´ ì•„ë‹ˆë¼ "ê²Œì„ ë¡œê·¸/ë‚´ëŸ¬í‹°ë¸Œ í”¼ë“œ" í˜•íƒœ
 * - ê³ ì • íŒ¨ë„: Scene Canvas, Action Deck, Inventory, Quest,
 *   Rule Board, Economy HUD, Agent Console, Scanner Slot
 *
 * RULE-008: Agent Consoleì—ì„œ ë‹¨ê³„/ë°°ì§€/ë³µêµ¬ë§Œ í‘œì‹œ (í”„ë¡¬í”„íŠ¸ ë…¸ì¶œ ê¸ˆì§€)
 *
 * RU-003-Q4: App.tsxëŠ” "ë ˆì´ì•„ì›ƒ + ì´ë²¤íŠ¸ ë¼ìš°íŒ…"ì— ì§‘ì¤‘
 * - ì„¸ì…˜/ì›”ë“œ ìƒíƒœëŠ” worldStoreë¡œ ì´ë™
 * - TurnOutput ë°˜ì˜ì€ worldStore.applyTurnOutputìœ¼ë¡œ ë‹¨ì¼í™”
 *
 * RU-004-Q4: ì„¸ì…˜ ë¼ì´í”„ì‚¬ì´í´ SSOT
 * - ì„¸ì…˜ ì´ˆê¸°í™”/ë³µì›/ë¦¬ì…‹/ë³€ê²½ì€ sessionLifecycle ëª¨ë“ˆë¡œ ë‹¨ì¼í™”
 * - App.tsxëŠ” ì„¸ì…˜ API í˜¸ì¶œ + UI ì „í™˜ë§Œ ë‹´ë‹¹
 *
 * U-015[Mvp]: SaveGame + Reset + Demo Profiles
 * - í”„ë¡œí•„ ì„ íƒ í™”ë©´ â†’ ê²Œì„ ì‹œì‘ í”Œë¡œìš°
 * - ë¦¬ì…‹ ë²„íŠ¼ìœ¼ë¡œ í”„ë¡œí•„ ì´ˆê¸° ìƒíƒœë¡œ ë³µêµ¬
 * - localStorage ê¸°ë°˜ ì„¸ì´ë¸Œ/ë¡œë“œ
 *
 * @see vibe/ref/frontend-style-guide.md
 * @see vibe/prd.md 6.7/6.8/9ì¥
 */

import { useState, useCallback, useEffect, useMemo } from 'react';
import { useTranslation } from 'react-i18next';
import {
  DndContext,
  DragEndEvent,
  DragStartEvent,
  useSensor,
  useSensors,
  PointerSensor,
  KeyboardSensor,
} from '@dnd-kit/core';
import { Panel } from './components/Panel';
import { GameHeader } from './components/GameHeader';
import { NarrativeFeed } from './components/NarrativeFeed';
import { AgentConsole } from './components/AgentConsole';
import { EconomyHud } from './components/EconomyHud';
import { SceneCanvas, type HotspotClickData } from './components/SceneCanvas';
import { ActionDeck } from './components/ActionDeck';
import { InventoryPanel } from './components/InventoryPanel';
// U-013: Quest + Rule Board + Mutation Timeline
import { QuestPanel } from './components/QuestPanel';
import { RuleBoard } from './components/RuleBoard';
import { MutationTimeline } from './components/MutationTimeline';
// U-015: SaveGame + Demo Profiles
import { DemoProfileSelect } from './components/DemoProfileSelect';
import { ResetButton, ChangeProfileButton } from './components/ResetButton';
import { useAgentStore } from './stores/agentStore';
import { useInventoryStore } from './stores/inventoryStore';
import { useUIPrefsStore, applyUIPrefsToDOM } from './stores/uiPrefsStore';
import { useWorldStore } from './stores/worldStore';
import { useTurnRunner } from './turn/turnRunner';
import type { ActionCard, DropInput } from './schemas/turn';
import { getCurrentThemeFromDOM } from './demo/demoFixtures';
import { isInventoryDragData, isHotspotDropData } from './dnd/types';
// RU-004-Q4: ì„¸ì…˜ ë¼ì´í”„ì‚¬ì´í´ SSOT
import {
  bootstrapSession,
  hasValidSaveGame,
  startSessionFromProfile,
  continueSession,
  resetToCurrentProfile,
  clearSessionAndReturnToSelect,
  saveCurrentSession,
  getInitialProfileId,
} from './save/sessionLifecycle';
import type { DemoProfile } from './data/demoProfiles';

// =============================================================================
// ê²Œì„ ìƒíƒœ íƒ€ì…
// =============================================================================

type GamePhase = 'profile_select' | 'playing';

// =============================================================================
// ë©”ì¸ App ì»´í¬ë„ŒíŠ¸
// =============================================================================

function App() {
  const { t } = useTranslation();

  // U-015: ê²Œì„ ì§„í–‰ ìƒíƒœ (í”„ë¡œí•„ ì„ íƒ vs í”Œë ˆì´ ì¤‘)
  // RU-004-Q4: bootstrapSession()ìœ¼ë¡œ ì´ˆê¸° phase ê²°ì • (SSOT)
  const [gamePhase, setGamePhase] = useState<GamePhase>(() => {
    const bootstrap = bootstrapSession();
    return bootstrap.phase;
  });

  // í˜„ì¬ ì„ íƒëœ í”„ë¡œí•„ ID
  // RU-004-Q4: getInitialProfileId()ë¡œ ì´ˆê¸° profileId ê²°ì • (SSOT)
  const [currentProfileId, setCurrentProfileId] = useState<string | null>(() => {
    return getInitialProfileId();
  });

  // ë¡œì»¬ UI ìƒíƒœ
  const [inputText, setInputText] = useState('');

  // Store ìƒíƒœ
  const worldStore = useWorldStore();
  const { economy, isConnected, sceneObjects, narrativeEntries, appendSystemNarrative } =
    worldStore;

  const { startDrag, endDrag } = useInventoryStore();
  const { isStreaming, narrativeBuffer } = useAgentStore();
  const { uiScale, increaseUIScale, decreaseUIScale } = useUIPrefsStore();

  // DOMì— UI ì„¤ì • ì ìš© (U-028â†’U-037)
  useEffect(() => {
    applyUIPrefsToDOM({ uiScale });
  }, [uiScale]);

  // ==========================================================================
  // U-015 + RU-004-Q4: í”„ë¡œí•„/ì„¸ì´ë¸Œ ê´€ë ¨ ë¡œì§ (sessionLifecycle SSOT)
  // ==========================================================================

  /**
   * í”„ë¡œí•„ì„ ì„ íƒí•˜ê³  ê²Œì„ì„ ì‹œì‘í•©ë‹ˆë‹¤.
   *
   * RU-004-Q4: sessionLifecycle.startSessionFromProfile í˜¸ì¶œ
   */
  const handleSelectProfile = useCallback(
    (profile: DemoProfile) => {
      const result = startSessionFromProfile({ profile, t });
      if (result.success) {
        setCurrentProfileId(result.profileId);
        setGamePhase('playing');
      }
    },
    [t],
  );

  /**
   * ì €ì¥ëœ ê²Œì„ì„ ê³„ì†í•©ë‹ˆë‹¤.
   *
   * RU-004-Q4: sessionLifecycle.continueSession í˜¸ì¶œ
   */
  const handleContinue = useCallback(async () => {
    const result = await continueSession();
    if (result) {
      setCurrentProfileId(result.profileId);
      setGamePhase('playing');
    } else {
      // ë¡œë“œ ì‹¤íŒ¨ ì‹œ profile_selectë¡œ í´ë°±
      setCurrentProfileId(null);
      setGamePhase('profile_select');
      console.warn('[App] SaveGame ë³µì› ì‹¤íŒ¨, ìƒˆë¡œ ì‹œì‘');
    }
  }, []);

  /**
   * í˜„ì¬ í”„ë¡œí•„ì˜ ì´ˆê¸° ìƒíƒœë¡œ ë¦¬ì…‹í•©ë‹ˆë‹¤.
   *
   * RU-004-Q4: sessionLifecycle.resetToCurrentProfile í˜¸ì¶œ
   */
  const handleReset = useCallback(() => {
    const result = resetToCurrentProfile({ t, currentProfileId });
    if (result.success && result.profileId) {
      setCurrentProfileId(result.profileId);
      // ê²Œì„ ìƒíƒœëŠ” ì´ë¯¸ playingì´ë¯€ë¡œ ë³„ë„ ì„¤ì • ë¶ˆí•„ìš”
    }
  }, [t, currentProfileId]);

  /**
   * í”„ë¡œí•„ ì„ íƒ í™”ë©´ìœ¼ë¡œ ëŒì•„ê°‘ë‹ˆë‹¤.
   *
   * RU-004-Q4: sessionLifecycle.clearSessionAndReturnToSelect í˜¸ì¶œ
   */
  const handleChangeProfile = useCallback(() => {
    clearSessionAndReturnToSelect();
    setCurrentProfileId(null);
    setGamePhase('profile_select');
  }, []);

  // ê²Œì„ ì‹œì‘ ì‹œ ì €ì¥ëœ ê²Œì„ ë³µì›
  // RU-004-Q4: sessionLifecycle.continueSession í˜¸ì¶œ
  useEffect(() => {
    if (gamePhase === 'playing' && currentProfileId) {
      void continueSession().then((result) => {
        if (result) {
          setCurrentProfileId(result.profileId);
        }
      });
    }
    // eslint-disable-next-line react-hooks/exhaustive-deps
  }, []);

  // í„´ ì™„ë£Œ ì‹œ ìë™ ì €ì¥ (turnCount ë³€í™” ê°ì§€)
  // RU-004-Q4: sessionLifecycle.saveCurrentSession í˜¸ì¶œ
  useEffect(() => {
    if (gamePhase === 'playing' && narrativeEntries.length > 0) {
      saveCurrentSession(currentProfileId);
    }
  }, [gamePhase, narrativeEntries.length, currentProfileId]);

  // RU-003-Q3: Turn Runner (ìŠ¤íŠ¸ë¦¼ ì‹œì‘/ì·¨ì†Œ/ì½œë°± ë¼ìš°íŒ… ë‹´ë‹¹)
  const turnRunnerDeps = useMemo(
    () => ({
      t,
      theme: getCurrentThemeFromDOM(),
    }),
    [t],
  );
  const turnRunner = useTurnRunner(turnRunnerDeps);

  /**
   * í„´ì„ ì‹¤í–‰í•©ë‹ˆë‹¤.
   */
  const executeTurn = useCallback(
    (text: string, actionId?: string, clickData?: HotspotClickData, dropData?: DropInput) => {
      turnRunner.runTurn({
        text,
        actionId,
        click: clickData,
        drop: dropData,
      });
      setInputText('');
    },
    [turnRunner],
  );

  /**
   * ì…ë ¥ ì œì¶œ í•¸ë“¤ëŸ¬
   */
  const handleSubmit = useCallback(() => {
    if (inputText.trim()) {
      executeTurn(inputText.trim());
    }
  }, [inputText, executeTurn]);

  /**
   * ì¹´ë“œ í´ë¦­ í•¸ë“¤ëŸ¬
   */
  const handleCardClick = useCallback(
    (card: ActionCard) => {
      executeTurn(card.label, card.id);
    },
    [executeTurn],
  );

  /**
   * í•«ìŠ¤íŒŸ í´ë¦­ í•¸ë“¤ëŸ¬ (U-010)
   */
  const handleHotspotClick = useCallback(
    (data: HotspotClickData) => {
      const clickedObject = sceneObjects.find((obj) => obj.id === data.object_id);
      const clickText = clickedObject
        ? t('scene.hotspot.click_action', { label: clickedObject.label })
        : data.object_id;

      executeTurn(clickText, undefined, data);
    },
    [executeTurn, sceneObjects, t],
  );

  /**
   * í‚¤ë³´ë“œ ì´ë²¤íŠ¸ í•¸ë“¤ëŸ¬
   */
  const handleKeyDown = useCallback(
    (e: React.KeyboardEvent) => {
      if (e.key === 'Enter' && !e.shiftKey) {
        e.preventDefault();
        handleSubmit();
      }
    },
    [handleSubmit],
  );

  /**
   * ë“œë˜ê·¸ ì‹œì‘ í•¸ë“¤ëŸ¬ (U-011)
   */
  const handleDragStart = useCallback(
    (event: DragStartEvent) => {
      const { active } = event;
      if (isInventoryDragData(active.data.current)) {
        startDrag(active.data.current.item_id);
      }
    },
    [startDrag],
  );

  /**
   * ë“œë˜ê·¸ ì¢…ë£Œ í•¸ë“¤ëŸ¬ (U-011 + U-012)
   */
  const handleDragEnd = useCallback(
    (event: DragEndEvent) => {
      const { active, over } = event;
      endDrag();

      const activeData = active.data.current;
      if (!isInventoryDragData(activeData)) {
        return;
      }

      const itemId = activeData.item_id;
      const itemName = activeData.item.name;

      const overData = over?.data.current;
      if (!over || !isHotspotDropData(overData)) {
        appendSystemNarrative(
          `[${t('connection.online')}] ${t('scene.hotspot.drop_invalid', { item: itemName })}`,
        );
        return;
      }

      const { object_id: targetObjectId, box_2d: targetBox2d, label: targetLabel } = overData;

      const dropText = t('scene.hotspot.drop_action', {
        item: itemName,
        target: targetLabel,
      });

      const dropInput: DropInput = {
        item_id: itemId,
        target_object_id: targetObjectId,
        target_box_2d: targetBox2d,
      };

      executeTurn(dropText, undefined, undefined, dropInput);
    },
    [endDrag, executeTurn, appendSystemNarrative, t],
  );

  // dnd-kit ì„¼ì„œ ì„¤ì •
  const sensors = useSensors(
    useSensor(PointerSensor, {
      activationConstraint: {
        distance: 8,
      },
    }),
    useSensor(KeyboardSensor),
  );

  // ==========================================================================
  // ë Œë”ë§: í”„ë¡œí•„ ì„ íƒ í™”ë©´
  // RU-004-Q4: hasValidSaveGame()ìœ¼ë¡œ "ìœ íš¨í•œ ì„¸ì´ë¸Œë§Œ" Continue ë…¸ì¶œ
  // ==========================================================================
  if (gamePhase === 'profile_select') {
    const hasSavedGame = hasValidSaveGame();
    return (
      <>
        <div className="crt-overlay" aria-hidden="true" />
        <DemoProfileSelect
          onSelectProfile={handleSelectProfile}
          onContinue={hasSavedGame ? handleContinue : undefined}
          hasSavedGame={hasSavedGame}
        />
      </>
    );
  }

  // ==========================================================================
  // ë Œë”ë§: ê²Œì„ í”Œë ˆì´ í™”ë©´
  // ==========================================================================
  return (
    <>
      <div className="crt-overlay" aria-hidden="true" />

      <DndContext sensors={sensors} onDragStart={handleDragStart} onDragEnd={handleDragEnd}>
        <div className="game-container">
          <GameHeader
            signal={economy.signal}
            memoryShard={economy.memory_shard}
            isConnected={isConnected}
            uiScale={uiScale}
            onIncreaseScale={increaseUIScale}
            onDecreaseScale={decreaseUIScale}
          >
            {/* U-015: ë¦¬ì…‹/í”„ë¡œí•„ ë³€ê²½ ë²„íŠ¼ */}
            <ResetButton onReset={handleReset} disabled={isStreaming} compact requireConfirm />
            <ChangeProfileButton onClick={handleChangeProfile} disabled={isStreaming} />
          </GameHeader>

          <aside className="sidebar-left">
            <Panel title={t('panel.inventory.title')} className="flex-1">
              <InventoryPanel />
            </Panel>
            {/* U-013: Quest Panel */}
            <Panel title={t('panel.quest.title')}>
              <QuestPanel />
            </Panel>
            {/* U-013: Rule Board + Mutation Timeline (ë³„ë„ ì»´í¬ë„ŒíŠ¸) */}
            <Panel title={t('panel.rule_board.title')}>
              <RuleBoard />
              <MutationTimeline />
            </Panel>
          </aside>

          <main className="game-center">
            <SceneCanvas onHotspotClick={handleHotspotClick} />
            <NarrativeFeed entries={narrativeEntries} streamingText={narrativeBuffer} />
          </main>

          <aside className="sidebar-right">
            <Panel title={t('panel.agent_console.title')} className="flex-1" hasChrome>
              <AgentConsole />
            </Panel>
            <Panel title={t('economy.hud_label')} hasChrome>
              <EconomyHud />
            </Panel>
            <Panel title={t('panel.scanner.title')} hasChrome>
              <div className="scanner-slot has-chrome">
                <p className="panel-placeholder">{t('panel.scanner.placeholder')}</p>
              </div>
            </Panel>
          </aside>

          <footer className="game-footer">
            <ActionDeck onCardClick={handleCardClick} />
            <div className="command-input-area">
              <span className="command-prompt">&gt;</span>
              <input
                type="text"
                className="command-input"
                placeholder={isStreaming ? t('ui.processing') : t('ui.command_placeholder')}
                aria-label={t('ui.command_placeholder')}
                value={inputText}
                onChange={(e) => setInputText(e.target.value)}
                onKeyDown={handleKeyDown}
                disabled={isStreaming}
              />
              <button type="button" onClick={handleSubmit} disabled={isStreaming}>
                {isStreaming ? t('ui.wait') : t('ui.execute')}
              </button>
            </div>
          </footer>
        </div>
      </DndContext>
    </>
  );
}

export default App;
</file>

</files>
