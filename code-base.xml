This file is a merged representation of a subset of the codebase, containing specifically included files and files not matching ignore patterns, combined into a single document by Repomix.

<file_summary>
This section contains a summary of this file.

<purpose>
This file contains a packed representation of a subset of the repository's contents that is considered the most important context.
It is designed to be easily consumable by AI systems for analysis, code review,
or other automated processes.
</purpose>

<file_format>
The content is organized as follows:
1. This summary section
2. Repository information
3. Directory structure
4. Repository files (if enabled)
5. Multiple file entries, each consisting of:
  - File path as an attribute
  - Full contents of the file
</file_format>

<usage_guidelines>
- This file should be treated as read-only. Any changes should be made to the
  original repository files, not this packed version.
- When processing this file, use the file path to distinguish
  between different files in the repository.
- Be aware that this file may contain sensitive information. Handle it with
  the same level of security as you would the original repository.
</usage_guidelines>

<notes>
- Some files may have been excluded based on .gitignore rules and Repomix's configuration
- Binary files are not included in this packed representation. Please refer to the Repository Structure section for a complete list of file paths, including binary files
- Only files matching these patterns are included: **/*.{ts,tsx,js,jsx,json,py,md,css}
- Files matching these patterns are excluded: .claude/**, .cursor/**, .gemini/**, .vscode/**, node_modules/**, .venv/**, dist/**, coverage/**, nanobanana-output/**
- Files matching patterns in .gitignore are excluded
- Files matching default ignore patterns are excluded
- Files are sorted by Git change count (files with more changes are at the bottom)
</notes>

</file_summary>

<directory_structure>
backend/src/unknown_world/__init__.py
backend/src/unknown_world/api/__init__.py
backend/src/unknown_world/api/turn_stream_events.py
backend/src/unknown_world/api/turn.py
backend/src/unknown_world/main.py
backend/src/unknown_world/models/__init__.py
backend/src/unknown_world/models/turn.py
backend/src/unknown_world/orchestrator/__init__.py
backend/src/unknown_world/orchestrator/mock.py
backend/tests/integration/test_api.py
backend/tests/integration/test_turn_streaming.py
backend/tests/qa/test_asset_manifest.py
backend/tests/unit/models/test_turn.py
backend/tests/unit/test_u034_verification.py
CLAUDE.md
frontend/coverage/base.css
frontend/coverage/block-navigation.js
frontend/coverage/coverage-final.json
frontend/coverage/prettify.css
frontend/coverage/prettify.js
frontend/coverage/sorter.js
frontend/package.json
frontend/public/ui/manifest.json
frontend/public/ui/manifest.schema.json
frontend/public/ui/QA_CHECKLIST.md
frontend/public/ui/README.md
frontend/src/api/turnStream.test.ts
frontend/src/api/turnStream.ts
frontend/src/App.tsx
frontend/src/components/AgentConsole.tsx
frontend/src/components/SceneCanvas.test.tsx
frontend/src/components/SceneCanvas.tsx
frontend/src/i18n.ts
frontend/src/main.tsx
frontend/src/schemas/index.ts
frontend/src/schemas/turn.test.ts
frontend/src/schemas/turn.ts
frontend/src/schemas/verify_runbook.ts
frontend/src/stores/agentStore.test.ts
frontend/src/stores/agentStore.ts
frontend/src/stores/uiPrefsStore.test.ts
frontend/src/stores/uiPrefsStore.ts
frontend/src/style.css
frontend/src/types/scene.ts
frontend/src/types/turn_stream.ts
frontend/src/vite-env.d.ts
frontend/tsconfig.json
frontend/tsconfig.node.json
frontend/vite.config.ts
package.json
shared/README.md
shared/schemas/turn/turn_input.schema.json
shared/schemas/turn/turn_output.schema.json
vibe/architecture.md
vibe/changelog.md
vibe/commands/ai-refactor.md
vibe/commands/commit-log.md
vibe/commands/doc-update.md
vibe/commands/lint-check.md
vibe/commands/refactor-doc.md
vibe/commands/refactor-impl.md
vibe/commands/roadmap-update.md
vibe/commands/test-exec.md
vibe/commands/unit-impl.md
vibe/debt-log.md
vibe/prd.md
vibe/progress.md
vibe/ready/frd-prompt.md
vibe/ready/frd-tech-stack-prompt.md
vibe/ready/git-ignore-prompt.md
vibe/ready/lint-ignore-prompt.md
vibe/ready/lint-prompt.md
vibe/ready/prd-prompt.md
vibe/ready/red-line-prompt.md
vibe/ready/roadmap-prompt.md
vibe/ready/rule-prompt-cursor_claude.md
vibe/ready/rule-prompt-gemini.md
vibe/ready/tech-stack-prompt.md
vibe/ref/frontend-style-guide.md
vibe/ref/gemini-api-guide.md
vibe/ref/image-generate-guide.md
vibe/ref/image-understanding-guide.md
vibe/ref/imagemagick-guide.md
vibe/ref/nanobanana-asset-request.schema.json
vibe/ref/nanobanana-mcp.md
vibe/ref/rembg-guide.md
vibe/ref/standard-guide.md
vibe/ref/structured-outputs-guide.md
vibe/ref/text-generate-guide.md
vibe/refactors/RU-001-Q1.md
vibe/refactors/RU-001-Q4.md
vibe/refactors/RU-001-Q5.md
vibe/refactors/RU-001-S1.md
vibe/refactors/RU-001-S2.md
vibe/refactors/RU-002-Q2.md
vibe/refactors/RU-002-Q4.md
vibe/refactors/RU-002-S1.md
vibe/refactors/RU-002-S2.md
vibe/refactors/RU-002-S3.md
vibe/roadmap.md
vibe/tech-stack.md
vibe/unit-plans/CP-MMP-01.md
vibe/unit-plans/CP-MMP-02.md
vibe/unit-plans/CP-MVP-01.md
vibe/unit-plans/CP-MVP-02.md
vibe/unit-plans/CP-MVP-03.md
vibe/unit-plans/RU-001[Mvp].md
vibe/unit-plans/RU-002[Mvp].md
vibe/unit-plans/RU-003[Mvp].md
vibe/unit-plans/RU-004[Mvp].md
vibe/unit-plans/RU-005[Mvp].md
vibe/unit-plans/RU-006[Mvp].md
vibe/unit-plans/RU-007[Mvp].md
vibe/unit-plans/RU-010[Mmp].md
vibe/unit-plans/RU-011[Mmp].md
vibe/unit-plans/U-001[Mvp].md
vibe/unit-plans/U-002[Mvp].md
vibe/unit-plans/U-003[Mvp].md
vibe/unit-plans/U-004[Mvp].md
vibe/unit-plans/U-005[Mvp].md
vibe/unit-plans/U-006[Mvp].md
vibe/unit-plans/U-007[Mvp].md
vibe/unit-plans/U-008[Mvp].md
vibe/unit-plans/U-009[Mvp].md
vibe/unit-plans/U-010[Mvp].md
vibe/unit-plans/U-011[Mvp].md
vibe/unit-plans/U-012[Mvp].md
vibe/unit-plans/U-013[Mvp].md
vibe/unit-plans/U-014[Mvp].md
vibe/unit-plans/U-015[Mvp].md
vibe/unit-plans/U-016[Mvp].md
vibe/unit-plans/U-017[Mvp].md
vibe/unit-plans/U-018[Mvp].md
vibe/unit-plans/U-019[Mvp].md
vibe/unit-plans/U-020[Mvp].md
vibe/unit-plans/U-021[Mvp].md
vibe/unit-plans/U-022[Mvp].md
vibe/unit-plans/U-023[Mvp].md
vibe/unit-plans/U-024[Mvp].md
vibe/unit-plans/U-025[Mvp].md
vibe/unit-plans/U-026[Mvp].md
vibe/unit-plans/U-027[Mvp].md
vibe/unit-plans/U-028[Mvp].md
vibe/unit-plans/U-029[Mvp].md
vibe/unit-plans/U-030[Mvp].md
vibe/unit-plans/U-031[Mvp].md
vibe/unit-plans/U-032[Mvp].md
vibe/unit-plans/U-033[Mvp].md
vibe/unit-plans/U-034[Mvp].md
vibe/unit-plans/U-035[Mvp].md
vibe/unit-plans/U-036[Mvp].md
vibe/unit-plans/U-037[Mvp].md
vibe/unit-plans/U-038[Mvp].md
vibe/unit-plans/U-100[Mmp].md
vibe/unit-plans/U-101[Mmp].md
vibe/unit-plans/U-102[Mmp].md
vibe/unit-plans/U-103[Mmp].md
vibe/unit-plans/U-104[Mmp].md
vibe/unit-plans/U-105[Mmp].md
vibe/unit-plans/U-106[Mmp].md
vibe/unit-plans/U-107[Mmp].md
vibe/unit-plans/U-108[Mmp].md
vibe/unit-results/CP-MVP-01.md
vibe/unit-results/RU-001[Mvp].md
vibe/unit-results/RU-002[Mvp].md
vibe/unit-results/test_streaming_manual_v2.py
vibe/unit-results/test_streaming_manual.py
vibe/unit-results/U-001[Mvp].md
vibe/unit-results/U-002[Mvp].md
vibe/unit-results/U-003[Mvp].md
vibe/unit-results/U-004[Mvp].md
vibe/unit-results/U-005[Mvp].md
vibe/unit-results/U-006[Mvp].md
vibe/unit-results/U-007[Mvp].md
vibe/unit-results/U-008[Mvp].md
vibe/unit-results/U-027[Mvp].md
vibe/unit-results/U-028[Mvp].md
vibe/unit-results/U-029[Mvp].md
vibe/unit-results/U-030[Mvp].md
vibe/unit-results/U-031[Mvp].md
vibe/unit-results/U-032[Mvp].md
vibe/unit-results/U-034[Mvp].md
vibe/unit-runbooks/CP-MVP-01.md
vibe/unit-runbooks/U-001-scaffolding-runbook.md
vibe/unit-runbooks/U-002-frontend-init-runbook.md
vibe/unit-runbooks/U-003-backend-init-runbook.md
vibe/unit-runbooks/U-004-crt-layout-runbook.md
vibe/unit-runbooks/U-005-pydantic-schemas-runbook.md
vibe/unit-runbooks/U-006-zod-schemas-runbook.md
vibe/unit-runbooks/U-007-mock-orchestrator-runbook.md
vibe/unit-runbooks/U-008-http-streaming-client-runbook.md
vibe/unit-runbooks/U-027-kill-port-limit-runbook.md
vibe/unit-runbooks/U-028-ui-readability-runbook.md
vibe/unit-runbooks/U-029-nanobanana-asset-runbook.md
vibe/unit-runbooks/U-030-asset-ssot-runbook.md
vibe/unit-runbooks/U-031-scene-placeholders-runbook.md
vibe/unit-runbooks/U-032-chrome-pack-runbook.md
vibe/unit-runbooks/U-033-asset-qa-runbook.md
vibe/unit-runbooks/U-034-nanobanana-template-runbook.md
vibe/UPDATE-PLAN.md
</directory_structure>

<files>
This section contains the contents of the repository's files.

<file path="backend/src/unknown_world/api/__init__.py">
"""Unknown World - API 패키지.

이 패키지는 FastAPI 라우터들을 포함합니다.
"""

from unknown_world.api.turn import router as turn_router

__all__ = ["turn_router"]
</file>

<file path="backend/src/unknown_world/models/__init__.py">
"""Unknown World - 모델 패키지.

이 패키지는 TurnInput/TurnOutput 스키마 및 하위 타입을 정의합니다.
Gemini Structured Outputs(JSON Schema)용으로 설계되었습니다.

사용 예시:
    from unknown_world.models import TurnInput, TurnOutput

    # Pydantic → JSON Schema 변환 (Gemini response_json_schema용)
    schema = TurnOutput.model_json_schema()

    # 응답 검증
    output = TurnOutput.model_validate_json(response_text)

참조:
    - vibe/prd.md 8.7 (데이터 모델 설계)
    - vibe/ref/structured-outputs-guide.md
    - .cursor/rules/00-core-critical.mdc (RULE-003, RULE-005)
"""

from unknown_world.models.turn import (
    ActionCard,
    ActionDeck,
    AgentConsole,
    AgentPhase,
    Box2D,
    ClickInput,
    ClientInfo,
    Coordinate,
    CurrencyAmount,
    EconomyOutput,
    EconomySnapshot,
    ImageJob,
    Language,
    MemoryPin,
    ModelLabel,
    Quest,
    RenderOutput,
    RiskLevel,
    SafetyOutput,
    SceneObject,
    Theme,
    TurnInput,
    TurnOutput,
    UIOutput,
    ValidationBadge,
    WorldDelta,
    WorldRule,
)

__all__ = [
    # Enum 타입
    "Language",
    "Theme",
    "AgentPhase",
    "ValidationBadge",
    "ModelLabel",
    "RiskLevel",
    # 공통 하위 타입
    "Coordinate",
    "Box2D",
    "CurrencyAmount",
    # TurnInput 관련
    "TurnInput",
    "ClickInput",
    "ClientInfo",
    "EconomySnapshot",
    # TurnOutput 관련
    "TurnOutput",
    "UIOutput",
    "ActionDeck",
    "ActionCard",
    "SceneObject",
    "WorldDelta",
    "WorldRule",
    "Quest",
    "MemoryPin",
    "RenderOutput",
    "ImageJob",
    "EconomyOutput",
    "SafetyOutput",
    "AgentConsole",
]
</file>

<file path="backend/src/unknown_world/models/turn.py">
"""Unknown World - TurnInput/TurnOutput Pydantic 스키마.

이 모듈은 Unknown World의 핵심 데이터 모델을 정의합니다.
Gemini Structured Outputs에 투입 가능한 JSON Schema(부분집합)를 생성할 수 있습니다.

설계 원칙:
    - RULE-003: 구조화 출력(JSON Schema) 우선 + 이중 검증
    - RULE-005: 재화 인바리언트 (cost, balance_after 필수, 잔액 음수 금지)
    - RULE-006: ko/en 언어 정책 (Language enum으로 고정)
    - RULE-009: 좌표 규약 (0~1000, bbox [ymin,xmin,ymax,xmax])

사용 예시:
    # Gemini Structured Outputs용 JSON Schema 생성
    schema = TurnOutput.model_json_schema()

    # 응답 검증
    output = TurnOutput.model_validate_json(gemini_response_text)

참조:
    - vibe/prd.md 8.7 (데이터 모델 설계)
    - vibe/ref/structured-outputs-guide.md
    - .cursor/rules/00-core-critical.mdc
"""

from enum import Enum
from typing import Annotated

from pydantic import BaseModel, ConfigDict, Field

# =============================================================================
# 공통 Enum 타입
# =============================================================================


class Language(str, Enum):
    """지원 언어 (RULE-006).

    ko/en 혼합 출력 금지. TurnInput.language를 SSOT로 삼아
    모든 UI/내러티브/시스템 메시지는 동일 언어로 고정합니다.
    """

    KO = "ko-KR"
    EN = "en-US"


class Theme(str, Enum):
    """테마 설정."""

    DARK = "dark"
    LIGHT = "light"


class AgentPhase(str, Enum):
    """에이전트 실행 단계 (RULE-008).

    에이전트형 시스템임을 UI로 증명하기 위한 단계 표시.
    """

    PARSE = "parse"
    VALIDATE = "validate"
    PLAN = "plan"
    RESOLVE = "resolve"
    RENDER = "render"
    VERIFY = "verify"
    COMMIT = "commit"


class ValidationBadge(str, Enum):
    """검증 배지 (RULE-008).

    턴 결과에 대한 검증 상태를 표시합니다.
    """

    SCHEMA_OK = "schema_ok"
    SCHEMA_FAIL = "schema_fail"
    ECONOMY_OK = "economy_ok"
    ECONOMY_FAIL = "economy_fail"
    SAFETY_OK = "safety_ok"
    SAFETY_BLOCKED = "safety_blocked"
    CONSISTENCY_OK = "consistency_ok"
    CONSISTENCY_FAIL = "consistency_fail"


class ModelLabel(str, Enum):
    """모델/품질 선택 라벨 (RULE-008).

    프롬프트 노출 없이 "왜 이 선택이었는지"를 사용자 친화 라벨로 표시.
    """

    FAST = "FAST"
    QUALITY = "QUALITY"
    CHEAP = "CHEAP"
    REF = "REF"


class RiskLevel(str, Enum):
    """행동 위험도 수준."""

    LOW = "low"
    MEDIUM = "medium"
    HIGH = "high"


# =============================================================================
# 공통 하위 타입
# =============================================================================

# RULE-009: 좌표는 0~1000 정규화 좌표계 (이미지 이해 bbox 포맷과 호환)
Coordinate = Annotated[int, Field(ge=0, le=1000, description="정규화 좌표 (0~1000)")]


class Box2D(BaseModel):
    """2D 바운딩 박스 (RULE-009).

    좌표는 0~1000 정규화 좌표계이며, bbox는 [ymin, xmin, ymax, xmax] 순서입니다.
    이미지 이해 bbox 포맷과 호환됩니다.

    Attributes:
        ymin: Y 최소값 (상단)
        xmin: X 최소값 (좌측)
        ymax: Y 최대값 (하단)
        xmax: X 최대값 (우측)
    """

    model_config = ConfigDict(extra="forbid")

    ymin: Coordinate
    xmin: Coordinate
    ymax: Coordinate
    xmax: Coordinate


class CurrencyAmount(BaseModel):
    """재화 수량.

    Attributes:
        signal: 기본 재화 (텍스트 턴/이미지 생성/고급 기능에 소비)
        memory_shard: 희귀 재화 (중요 설정 고정, 고해상도 이미지 등에 소비)
    """

    model_config = ConfigDict(extra="forbid")

    signal: Annotated[int, Field(ge=0, description="시그널 (기본 재화, 0 이상)")]
    memory_shard: Annotated[int, Field(ge=0, description="기억 파편 (희귀 재화, 0 이상)")]


# =============================================================================
# TurnInput 관련 타입
# =============================================================================


class ClickInput(BaseModel):
    """클릭 입력 정보.

    화면 오브젝트 클릭 시 전달되는 정보입니다.

    Attributes:
        object_id: 클릭한 오브젝트 ID
        box_2d: 클릭 위치의 바운딩 박스 (선택)
    """

    model_config = ConfigDict(extra="forbid")

    object_id: str = Field(description="클릭한 오브젝트 ID")
    box_2d: Box2D | None = Field(default=None, description="클릭 위치 바운딩 박스 (선택)")


class ClientInfo(BaseModel):
    """클라이언트 정보.

    Attributes:
        viewport_w: 뷰포트 너비 (픽셀)
        viewport_h: 뷰포트 높이 (픽셀)
        theme: 현재 테마 (dark/light)
    """

    model_config = ConfigDict(extra="forbid")

    viewport_w: Annotated[int, Field(gt=0, description="뷰포트 너비 (픽셀)")]
    viewport_h: Annotated[int, Field(gt=0, description="뷰포트 높이 (픽셀)")]
    theme: Theme = Field(default=Theme.DARK, description="현재 테마")


class EconomySnapshot(BaseModel):
    """재화 스냅샷 (클라이언트 → 서버).

    클라이언트가 보유한 현재 재화 상태입니다.
    서버는 이를 검증하고 비용 계산에 사용합니다.

    Attributes:
        signal: 현재 시그널 잔액
        memory_shard: 현재 기억 파편 잔액
    """

    model_config = ConfigDict(extra="forbid")

    signal: Annotated[int, Field(ge=0, description="현재 시그널 잔액 (0 이상)")]
    memory_shard: Annotated[int, Field(ge=0, description="현재 기억 파편 잔액 (0 이상)")]


class TurnInput(BaseModel):
    """턴 입력 (클라이언트 → 서버).

    사용자가 턴을 진행할 때 서버로 전송하는 입력 데이터입니다.

    Attributes:
        language: 요청 언어 (응답도 동일 언어로 고정)
        text: 사용자 자연어 입력
        click: 오브젝트 클릭 정보 (선택)
        client: 클라이언트 환경 정보
        economy_snapshot: 현재 재화 상태

    Example:
        >>> input_data = TurnInput(
        ...     language=Language.KO,
        ...     text="문을 열어본다",
        ...     economy_snapshot=EconomySnapshot(signal=100, memory_shard=5),
        ...     client=ClientInfo(viewport_w=1920, viewport_h=1080),
        ... )
    """

    model_config = ConfigDict(extra="forbid")

    language: Language = Field(description="요청 언어 (응답도 동일 언어로 고정)")
    text: str = Field(default="", description="사용자 자연어 입력")
    click: ClickInput | None = Field(default=None, description="오브젝트 클릭 정보 (선택)")
    client: ClientInfo = Field(description="클라이언트 환경 정보")
    economy_snapshot: EconomySnapshot = Field(description="현재 재화 상태")


# =============================================================================
# TurnOutput 관련 타입 - UI
# =============================================================================


class ActionCard(BaseModel):
    """액션 카드 (Action Deck).

    매 턴 AI가 추천하는 행동 카드입니다.
    각 카드에 비용/위험/보상 힌트가 포함됩니다.

    Attributes:
        id: 카드 고유 ID
        label: 카드 라벨 (표시용)
        description: 카드 설명 (선택)
        cost: 예상 비용
        risk: 위험도
        hint: 예상 결과 힌트 (선택)
    """

    model_config = ConfigDict(extra="forbid")

    id: str = Field(description="카드 고유 ID")
    label: str = Field(description="카드 라벨 (표시용)")
    description: str | None = Field(default=None, description="카드 설명 (선택)")
    cost: CurrencyAmount = Field(description="예상 비용")
    risk: RiskLevel = Field(default=RiskLevel.LOW, description="위험도")
    hint: str | None = Field(default=None, description="예상 결과 힌트 (선택)")


class SceneObject(BaseModel):
    """장면 오브젝트 (클릭 가능한 핫스팟).

    화면에서 클릭 가능한 오브젝트입니다.
    좌표는 0~1000 정규화 좌표계를 사용합니다 (RULE-009).

    Attributes:
        id: 오브젝트 고유 ID
        label: 오브젝트 라벨 (표시용)
        box_2d: 바운딩 박스 [ymin, xmin, ymax, xmax]
        interaction_hint: 상호작용 힌트 (선택)
    """

    model_config = ConfigDict(extra="forbid")

    id: str = Field(description="오브젝트 고유 ID")
    label: str = Field(description="오브젝트 라벨 (표시용)")
    box_2d: Box2D = Field(description="바운딩 박스")
    interaction_hint: str | None = Field(default=None, description="상호작용 힌트 (선택)")


class ActionDeck(BaseModel):
    """액션 덱 (Q1 결정: ui.action_deck.cards[] 구조).

    매 턴 AI가 제시하는 추천 행동 카드 덱입니다.

    Attributes:
        cards: 액션 카드 목록 (3~6장 권장)
    """

    model_config = ConfigDict(extra="forbid")

    cards: list[ActionCard] = Field(
        default=[],
        min_length=0,
        max_length=10,
        description="액션 카드 목록 (3~6장 권장)",
    )


class UIOutput(BaseModel):
    """UI 출력 데이터.

    AI가 생성한 UI 요소들입니다.
    채팅 버블이 아닌 게임 UI로 표현됩니다 (RULE-002).

    Attributes:
        action_deck: 액션 카드 덱 (Q1 결정: Option A 채택)
        objects: 클릭 가능한 장면 오브젝트 목록
    """

    model_config = ConfigDict(extra="forbid")

    action_deck: ActionDeck = Field(default_factory=ActionDeck, description="액션 카드 덱")
    objects: list[SceneObject] = Field(default=[], description="클릭 가능한 장면 오브젝트 목록")


# =============================================================================
# TurnOutput 관련 타입 - World
# =============================================================================


class MemoryPin(BaseModel):
    """중요 설정 고정 후보.

    사용자가 Memory Shard를 소비해 고정할 수 있는 중요 설정입니다.

    Attributes:
        id: 핀 고유 ID
        content: 고정할 내용
        cost: 고정에 필요한 비용
    """

    model_config = ConfigDict(extra="forbid")

    id: str = Field(description="핀 고유 ID")
    content: str = Field(description="고정할 내용")
    cost: CurrencyAmount = Field(description="고정에 필요한 비용")


class WorldRule(BaseModel):
    """세계 규칙 (Rule Board).

    현재 세계에 적용 중인 물리 법칙이나 메타 규칙입니다.

    Attributes:
        id: 규칙 고유 ID
        label: 규칙 이름
        description: 규칙 상세 설명 (선택)
    """

    model_config = ConfigDict(extra="forbid")

    id: str = Field(description="규칙 고유 ID")
    label: str = Field(description="규칙 이름")
    description: str | None = Field(default=None, description="규칙 상세 설명 (선택)")


class Quest(BaseModel):
    """퀘스트/목표 (Quest Panel).

    플레이어가 달성해야 하는 현재 목표입니다.

    Attributes:
        id: 퀘스트 고유 ID
        label: 퀘스트 이름
        is_completed: 달성 여부
    """

    model_config = ConfigDict(extra="forbid")

    id: str = Field(description="퀘스트 고유 ID")
    label: str = Field(description="퀘스트 이름")
    is_completed: bool = Field(default=False, description="달성 여부")


class WorldDelta(BaseModel):
    """세계 상태 변화 (Q2 결정: Option A - delta 중심).

    이번 턴에서 변경된 세계 상태를 나타냅니다.
    snapshot은 SaveGame에만 저장하고, 매 턴은 delta만 전송합니다.

    Attributes:
        rules_changed: 변경되거나 추가된 규칙 목록
        inventory_added: 추가된 인벤토리 아이템
        inventory_removed: 제거된 인벤토리 아이템
        quests_updated: 업데이트된 퀘스트(목표) 목록
        relationships_changed: 변경된 관계
        memory_pins: 중요 설정 고정 후보
    """

    model_config = ConfigDict(extra="forbid")

    rules_changed: list[WorldRule] = Field(default=[], description="변경된 규칙 목록")
    inventory_added: list[str] = Field(default=[], description="추가된 인벤토리 아이템")
    inventory_removed: list[str] = Field(default=[], description="제거된 인벤토리 아이템")
    quests_updated: list[Quest] = Field(default=[], description="업데이트된 퀘스트/목표 목록")
    relationships_changed: list[str] = Field(default=[], description="변경된 관계")
    memory_pins: list[MemoryPin] = Field(default=[], description="중요 설정 고정 후보")


# =============================================================================
# TurnOutput 관련 타입 - Render
# =============================================================================


class ImageJob(BaseModel):
    """이미지 생성 작업.

    조건부 이미지 생성/편집 요청입니다.
    이미지 생성이 느릴 경우 텍스트 우선 출력 + Lazy Loading을 사용합니다.

    Attributes:
        should_generate: 이미지를 생성해야 하는지
        prompt: 이미지 생성 프롬프트
        model_label: 모델 선택 라벨 (FAST/QUALITY/CHEAP/REF)
        aspect_ratio: 가로세로 비율 (예: "16:9", "1:1")
        image_size: 이미지 크기 (예: "1024x1024")
        reference_image_ids: 참조 이미지 ID 목록 (선택)
    """

    model_config = ConfigDict(extra="forbid")

    should_generate: bool = Field(description="이미지를 생성해야 하는지")
    prompt: str = Field(default="", description="이미지 생성 프롬프트")
    model_label: ModelLabel = Field(default=ModelLabel.FAST, description="모델 선택 라벨")
    aspect_ratio: str = Field(default="16:9", description="가로세로 비율")
    image_size: str = Field(default="1024x1024", description="이미지 크기")
    reference_image_ids: list[str] = Field(default=[], description="참조 이미지 ID 목록 (선택)")


class RenderOutput(BaseModel):
    """렌더링 출력 데이터.

    이미지 생성/편집 관련 정보입니다.

    Attributes:
        image_job: 이미지 생성 작업 (선택)
    """

    model_config = ConfigDict(extra="forbid")

    image_job: ImageJob | None = Field(default=None, description="이미지 생성 작업 (선택)")


# =============================================================================
# TurnOutput 관련 타입 - Economy
# =============================================================================


class EconomyOutput(BaseModel):
    """경제 출력 데이터 (RULE-005).

    이번 턴의 비용과 잔액 정보입니다.
    잔액 음수는 절대 불가 (서버 Hard gate).

    Attributes:
        cost: 이번 턴에 소비된 비용
        balance_after: 소비 후 잔액

    Important:
        - cost와 balance_after는 항상 포함되어야 합니다.
        - balance_after의 signal과 memory_shard는 0 이상이어야 합니다.
    """

    model_config = ConfigDict(extra="forbid")

    cost: CurrencyAmount = Field(description="이번 턴에 소비된 비용")
    balance_after: CurrencyAmount = Field(description="소비 후 잔액")


# =============================================================================
# TurnOutput 관련 타입 - Safety
# =============================================================================


class SafetyOutput(BaseModel):
    """안전 출력 데이터.

    안전 정책 관련 정보입니다.
    차단 시 명시적 메시지와 함께 안전한 대체 결과를 제공합니다.

    Attributes:
        blocked: 안전 정책에 의해 차단되었는지
        message: 차단 시 사용자에게 표시할 메시지 (선택)
    """

    model_config = ConfigDict(extra="forbid")

    blocked: bool = Field(default=False, description="안전 정책에 의해 차단되었는지")
    message: str | None = Field(default=None, description="차단 시 사용자에게 표시할 메시지 (선택)")


# =============================================================================
# TurnOutput 관련 타입 - Agent Console
# =============================================================================


class AgentConsole(BaseModel):
    """에이전트 콘솔 데이터 (RULE-008).

    에이전트형 시스템임을 UI로 증명하기 위한 정보입니다.
    계획/실행/검증/복구의 흔적을 표시합니다.

    Attributes:
        current_phase: 현재 실행 단계
        badges: 검증 배지 목록
        repair_count: 자동 복구 시도 횟수
    """

    model_config = ConfigDict(extra="forbid")

    current_phase: AgentPhase = Field(default=AgentPhase.COMMIT, description="현재 실행 단계")
    badges: list[ValidationBadge] = Field(default=[], description="검증 배지 목록")
    repair_count: Annotated[int, Field(ge=0, description="자동 복구 시도 횟수")] = 0


# =============================================================================
# TurnOutput (메인 응답 스키마)
# =============================================================================


class TurnOutput(BaseModel):
    """턴 출력 (서버 → 클라이언트).

    서버가 턴 처리 후 클라이언트로 반환하는 구조화된 응답입니다.
    Gemini Structured Outputs(JSON Schema)로 강제됩니다.

    Hard Gate 필드 (RULE-003/004/005):
        - economy: cost와 balance_after 필수, 잔액 음수 금지
        - safety: blocked 시 안전한 대체 결과 제공
        - language: 요청 언어와 동일하게 고정 (혼합 출력 금지)

    Attributes:
        language: 응답 언어 (요청과 동일)
        narrative: 내러티브 텍스트 (표시용)
        ui: UI 요소 (액션 덱, 오브젝트)
        world: 세계 상태 변화 (delta 중심)
        render: 렌더링 정보 (이미지 생성 작업)
        economy: 경제 정보 (비용, 잔액)
        safety: 안전 정책 정보
        agent_console: 에이전트 실행 정보 (단계, 배지, 복구 횟수)

    Example:
        >>> output = TurnOutput(
        ...     language=Language.KO,
        ...     narrative="문이 삐걱거리며 열립니다...",
        ...     economy=EconomyOutput(
        ...         cost=CurrencyAmount(signal=5, memory_shard=0),
        ...         balance_after=CurrencyAmount(signal=95, memory_shard=5),
        ...     ),
        ...     safety=SafetyOutput(blocked=False),
        ... )
        >>> schema = TurnOutput.model_json_schema()

    Schema Generation:
        >>> # Gemini Structured Outputs용 JSON Schema 생성
        >>> json_schema = TurnOutput.model_json_schema()
        >>> # response_json_schema 파라미터에 전달
        >>> config = {
        ...     "response_mime_type": "application/json",
        ...     "response_json_schema": json_schema,
        ... }
    """

    model_config = ConfigDict(extra="forbid")

    # 필수 필드 (Hard Gate)
    language: Language = Field(description="응답 언어 (요청과 동일)")
    narrative: str = Field(description="내러티브 텍스트 (표시용)")
    economy: EconomyOutput = Field(description="경제 정보 (비용, 잔액)")
    safety: SafetyOutput = Field(description="안전 정책 정보")

    # UI 관련 필드
    ui: UIOutput = Field(default_factory=UIOutput, description="UI 요소")

    # 세계 상태 필드
    world: WorldDelta = Field(default_factory=WorldDelta, description="세계 상태 변화 (delta)")

    # 렌더링 필드
    render: RenderOutput = Field(default_factory=RenderOutput, description="렌더링 정보")

    # 에이전트 콘솔 필드
    agent_console: AgentConsole = Field(
        default_factory=AgentConsole, description="에이전트 실행 정보"
    )
</file>

<file path="backend/src/unknown_world/orchestrator/__init__.py">
"""Unknown World - Orchestrator 패키지.

이 패키지는 턴 처리 오케스트레이터를 포함합니다.
"""

from unknown_world.orchestrator.mock import MockOrchestrator

__all__ = ["MockOrchestrator"]
</file>

<file path="backend/tests/integration/test_api.py">
from fastapi.testclient import TestClient

from unknown_world.main import app

client = TestClient(app)


def test_health_check():
    """/health 엔드포인트가 올바른 스키마와 상태를 반환하는지 테스트합니다."""
    response = client.get("/health")
    assert response.status_code == 200
    data = response.json()
    assert data["status"] == "ok"
    assert "version" in data
    assert data["service"] == "unknown-world-backend"


def test_root_endpoint():
    """루트 엔드포인트가 정상 작동하는지 테스트합니다."""
    response = client.get("/")
    assert response.status_code == 200
    assert "message" in response.json()


def test_cors_policy():
    """RULE-011에 따른 CORS 정책이 올바르게 설정되었는지 테스트합니다."""
    # 허용된 오리진 테스트 (포트 8001)
    headers = {
        "Origin": "http://localhost:8001",
        "Access-Control-Request-Method": "GET",
    }
    response = client.options("/health", headers=headers)
    assert response.status_code == 200
    assert response.headers.get("access-control-allow-origin") == "http://localhost:8001"

    # 허용되지 않은 오리진 테스트 (포트 9000)
    headers = {
        "Origin": "http://localhost:9000",
        "Access-Control-Request-Method": "GET",
    }
    response = client.options("/health", headers=headers)
    # FastAPI/Starlette CORS 미들웨어는 허용되지 않은 경우 origin 헤더를 반환하지 않음
    assert "access-control-allow-origin" not in response.headers
</file>

<file path="backend/tests/qa/test_asset_manifest.py">
import json
import os

import pytest
from jsonschema import validate

# Paths
# This file is in backend/tests/qa/
# We go up 3 levels to get to backend root: backend/tests/qa -> backend/tests -> backend -> root (wait, backend is in root)
# Actually:
# __file__ = D:\Dev\unknown-world\backend\tests\qa\test_asset_manifest.py
# os.path.dirname(__file__) = D:\Dev\unknown-world\backend\tests\qa
# ... up 1 = tests
# ... up 2 = backend
# ... up 3 = unknown-world (project root)

CURRENT_DIR = os.path.dirname(os.path.abspath(__file__))
PROJECT_ROOT = os.path.dirname(os.path.dirname(os.path.dirname(CURRENT_DIR)))

# If PROJECT_ROOT is correct, it should contain frontend/
FRONTEND_UI_DIR = os.path.join(PROJECT_ROOT, "frontend", "public", "ui")
MANIFEST_PATH = os.path.join(FRONTEND_UI_DIR, "manifest.json")
SCHEMA_PATH = os.path.join(FRONTEND_UI_DIR, "manifest.schema.json")


def test_manifest_schema_validation():
    """Validates manifest.json against manifest.schema.json"""
    if not os.path.exists(MANIFEST_PATH):
        pytest.fail(f"Manifest not found at {MANIFEST_PATH}")
    if not os.path.exists(SCHEMA_PATH):
        pytest.fail(f"Schema not found at {SCHEMA_PATH}")

    with open(MANIFEST_PATH, encoding="utf-8") as f:
        manifest = json.load(f)

    with open(SCHEMA_PATH, encoding="utf-8") as f:
        schema = json.load(f)

    # validate raises ValidationError on failure
    validate(instance=manifest, schema=schema)


def test_asset_files_existence_and_size():
    """Checks if assets listed in manifest exist and sizes match/budget"""
    with open(MANIFEST_PATH, encoding="utf-8") as f:
        manifest = json.load(f)

    assets = manifest.get("assets", [])
    total_bytes_calculated = 0

    for asset in assets:
        rel_path = asset["path"]
        abs_path = os.path.join(FRONTEND_UI_DIR, rel_path)

        # 1. Existence Check
        assert os.path.exists(abs_path), f"Asset file missing: {rel_path} (full: {abs_path})"

        # 2. Size Check
        actual_size = os.path.getsize(abs_path)
        recorded_size = asset.get("bytes")

        # Note: If size mismatches, we print a helpful message.
        # In a real QA scenario, we might want to auto-update, but for this test we fail.
        if recorded_size is not None:
            assert actual_size == recorded_size, (
                f"Size mismatch for {rel_path}: actual {actual_size} != manifest {recorded_size}"
            )

        total_bytes_calculated += actual_size

        # 3. Individual Budget Check (from QA_CHECKLIST.md)
        asset_type = asset["type"]
        if asset_type == "icon":
            # 30KB limit
            assert actual_size <= 30 * 1024, (
                f"Icon {rel_path} exceeds 30KB budget ({actual_size} bytes)"
            )
        elif asset_type == "placeholder":
            # 300KB limit
            assert actual_size <= 300 * 1024, (
                f"Placeholder {rel_path} exceeds 300KB budget ({actual_size} bytes)"
            )
        elif asset_type == "chrome":
            # 120KB limit (increased for scanner-frame)
            assert actual_size <= 120 * 1024, (
                f"Chrome asset {rel_path} exceeds 120KB budget ({actual_size} bytes)"
            )

    # 4. Total Budget Check
    recorded_total = manifest.get("totalBytes")
    if recorded_total is not None:
        assert total_bytes_calculated == recorded_total, (
            f"Total bytes mismatch: calculated {total_bytes_calculated} != manifest {recorded_total}"
        )

    budget_total = manifest.get("budgetBytes", 1572864)
    assert total_bytes_calculated <= budget_total, (
        f"Total size {total_bytes_calculated} exceeds budget {budget_total}"
    )


def test_asset_naming_convention():
    """Checks if asset IDs and paths use kebab-case"""
    with open(MANIFEST_PATH, encoding="utf-8") as f:
        manifest = json.load(f)

    for asset in manifest["assets"]:
        asset_id = asset["id"]
        # Check for lowercase and kebab-case (allow numbers)
        assert asset_id.islower(), f"Asset ID {asset_id} should be lowercase"
        assert " " not in asset_id, f"Asset ID {asset_id} should not contain spaces"
        assert "_" not in asset_id, (
            f"Asset ID {asset_id} should not contain underscores (use kebab-case)"
        )
</file>

<file path="backend/tests/unit/models/test_turn.py">
"""TurnInput/TurnOutput 모델 단위 테스트."""

import pytest
from pydantic import ValidationError

from unknown_world.models.turn import (
    AgentConsole,
    Box2D,
    CurrencyAmount,
    EconomyOutput,
    Language,
    RenderOutput,
    TurnInput,
    TurnOutput,
    UIOutput,
    WorldDelta,
)

# =============================================================================
# Fixtures
# =============================================================================


@pytest.fixture
def valid_box_2d():
    return {"ymin": 100, "xmin": 200, "ymax": 300, "xmax": 400}


@pytest.fixture
def valid_currency_amount():
    return {"signal": 100, "memory_shard": 5}


@pytest.fixture
def valid_client_info():
    return {"viewport_w": 1920, "viewport_h": 1080, "theme": "dark"}


@pytest.fixture
def valid_turn_input_data(valid_client_info, valid_currency_amount):
    return {
        "language": "ko-KR",
        "text": "Hello",
        "client": valid_client_info,
        "economy_snapshot": valid_currency_amount,
    }


@pytest.fixture
def valid_turn_output_data(valid_currency_amount):
    return {
        "language": "ko-KR",
        "narrative": "Story continues...",
        "economy": {
            "cost": {"signal": 10, "memory_shard": 0},
            "balance_after": {"signal": 90, "memory_shard": 5},
        },
        "safety": {"blocked": False},
    }


# =============================================================================
# Coordinate & Box2D Tests
# =============================================================================


def test_box_2d_valid(valid_box_2d):
    box = Box2D(**valid_box_2d)
    assert box.ymin == 100
    assert box.xmax == 400


def test_box_2d_invalid_coordinate():
    with pytest.raises(ValidationError):
        # Out of range (ge=0, le=1000)
        Box2D(ymin=-1, xmin=0, ymax=1001, xmax=500)


def test_box_2d_extra_forbidden():
    with pytest.raises(ValidationError):
        Box2D(ymin=0, xmin=0, ymax=100, xmax=100, extra_field="not allowed")


# =============================================================================
# Currency & Economy Tests
# =============================================================================


def test_currency_amount_valid(valid_currency_amount):
    amount = CurrencyAmount(**valid_currency_amount)
    assert amount.signal == 100


def test_currency_amount_negative_fails():
    with pytest.raises(ValidationError):
        CurrencyAmount(signal=-1, memory_shard=0)


def test_economy_output_valid():
    data = {
        "cost": {"signal": 5, "memory_shard": 0},
        "balance_after": {"signal": 95, "memory_shard": 5},
    }
    economy = EconomyOutput(**data)
    assert economy.cost.signal == 5
    assert economy.balance_after.signal == 95


# =============================================================================
# TurnInput Tests
# =============================================================================


def test_turn_input_valid(valid_turn_input_data):
    turn_input = TurnInput(**valid_turn_input_data)
    assert turn_input.language == Language.KO
    assert turn_input.text == "Hello"


def test_turn_input_with_click(valid_turn_input_data, valid_box_2d):
    data = valid_turn_input_data.copy()
    data["click"] = {"object_id": "door_01", "box_2d": valid_box_2d}
    turn_input = TurnInput(**data)
    assert turn_input.click.object_id == "door_01"
    assert turn_input.click.box_2d.ymin == 100


def test_turn_input_invalid_language():
    with pytest.raises(ValidationError):
        TurnInput(
            language="fr-FR",  # Not in Language enum
            text="...",
            client={"viewport_w": 800, "viewport_h": 600},
            economy_snapshot={"signal": 0, "memory_shard": 0},
        )


# =============================================================================
# TurnOutput Tests
# =============================================================================


def test_turn_output_valid_minimal(valid_turn_output_data):
    turn_output = TurnOutput(**valid_turn_output_data)
    assert turn_output.language == Language.KO
    assert turn_output.narrative == "Story continues..."
    # Check defaults
    assert isinstance(turn_output.ui, UIOutput)
    assert isinstance(turn_output.world, WorldDelta)
    assert isinstance(turn_output.render, RenderOutput)
    assert isinstance(turn_output.agent_console, AgentConsole)


def test_turn_output_full(valid_currency_amount, valid_box_2d):
    data = {
        "language": "en-US",
        "narrative": "Narrative text",
        "ui": {
            "action_deck": {
                "cards": [
                    {
                        "id": "c1",
                        "label": "Action 1",
                        "cost": {"signal": 5, "memory_shard": 0},
                    }
                ]
            },
            "objects": [{"id": "obj1", "label": "Object 1", "box_2d": valid_box_2d}],
        },
        "world": {
            "inventory_added": ["key"],
            "rules_changed": [{"id": "r1", "label": "Gravity", "description": "Low gravity"}],
            "quests_updated": [{"id": "q1", "label": "Find key", "is_completed": False}],
            "memory_pins": [
                {"id": "p1", "content": "Fact", "cost": {"signal": 1, "memory_shard": 0}}
            ],
        },
        "render": {
            "image_job": {
                "should_generate": True,
                "prompt": "A landscape",
                "model_label": "QUALITY",
            }
        },
        "economy": {
            "cost": {"signal": 10, "memory_shard": 0},
            "balance_after": {"signal": 90, "memory_shard": 5},
        },
        "safety": {"blocked": False},
        "agent_console": {"repair_count": 1, "badges": ["schema_ok", "economy_ok"]},
    }
    turn_output = TurnOutput(**data)
    assert turn_output.language == Language.EN
    assert len(turn_output.ui.action_deck.cards) == 1
    assert turn_output.render.image_job.should_generate is True


def test_turn_output_missing_required():
    with pytest.raises(ValidationError):
        # Missing economy and safety
        TurnOutput(language="ko-KR", narrative="...")


# =============================================================================
# JSON Schema Tests
# =============================================================================


def test_turn_output_json_schema():
    schema = TurnOutput.model_json_schema()
    assert schema["type"] == "object"
    assert "language" in schema["required"]
    assert "narrative" in schema["required"]
    assert "economy" in schema["required"]
    assert "safety" in schema["required"]

    # Check Coordinate constraints in schema
    # Pydantic 2 schema structure: properties -> language -> ...
    # Coordinate might be in $defs or inline depending on how it's used
    ui_props = schema["$defs"]["UIOutput"]["properties"]
    assert "action_deck" in ui_props

    # Verify that Coordinate (int with ge/le) is correctly represented
    # Box2D uses Coordinate
    box_props = schema["$defs"]["Box2D"]["properties"]
    assert box_props["ymin"]["maximum"] == 1000
    assert box_props["ymin"]["minimum"] == 0
</file>

<file path="frontend/coverage/base.css">
body, html {
  margin:0; padding: 0;
  height: 100%;
}
body {
    font-family: Helvetica Neue, Helvetica, Arial;
    font-size: 14px;
    color:#333;
}
.small { font-size: 12px; }
*, *:after, *:before {
  -webkit-box-sizing:border-box;
     -moz-box-sizing:border-box;
          box-sizing:border-box;
  }
h1 { font-size: 20px; margin: 0;}
h2 { font-size: 14px; }
pre {
    font: 12px/1.4 Consolas, "Liberation Mono", Menlo, Courier, monospace;
    margin: 0;
    padding: 0;
    -moz-tab-size: 2;
    -o-tab-size:  2;
    tab-size: 2;
}
a { color:#0074D9; text-decoration:none; }
a:hover { text-decoration:underline; }
.strong { font-weight: bold; }
.space-top1 { padding: 10px 0 0 0; }
.pad2y { padding: 20px 0; }
.pad1y { padding: 10px 0; }
.pad2x { padding: 0 20px; }
.pad2 { padding: 20px; }
.pad1 { padding: 10px; }
.space-left2 { padding-left:55px; }
.space-right2 { padding-right:20px; }
.center { text-align:center; }
.clearfix { display:block; }
.clearfix:after {
  content:'';
  display:block;
  height:0;
  clear:both;
  visibility:hidden;
  }
.fl { float: left; }
@media only screen and (max-width:640px) {
  .col3 { width:100%; max-width:100%; }
  .hide-mobile { display:none!important; }
}

.quiet {
  color: #7f7f7f;
  color: rgba(0,0,0,0.5);
}
.quiet a { opacity: 0.7; }

.fraction {
  font-family: Consolas, 'Liberation Mono', Menlo, Courier, monospace;
  font-size: 10px;
  color: #555;
  background: #E8E8E8;
  padding: 4px 5px;
  border-radius: 3px;
  vertical-align: middle;
}

div.path a:link, div.path a:visited { color: #333; }
table.coverage {
  border-collapse: collapse;
  margin: 10px 0 0 0;
  padding: 0;
}

table.coverage td {
  margin: 0;
  padding: 0;
  vertical-align: top;
}
table.coverage td.line-count {
    text-align: right;
    padding: 0 5px 0 20px;
}
table.coverage td.line-coverage {
    text-align: right;
    padding-right: 10px;
    min-width:20px;
}

table.coverage td span.cline-any {
    display: inline-block;
    padding: 0 5px;
    width: 100%;
}
.missing-if-branch {
    display: inline-block;
    margin-right: 5px;
    border-radius: 3px;
    position: relative;
    padding: 0 4px;
    background: #333;
    color: yellow;
}

.skip-if-branch {
    display: none;
    margin-right: 10px;
    position: relative;
    padding: 0 4px;
    background: #ccc;
    color: white;
}
.missing-if-branch .typ, .skip-if-branch .typ {
    color: inherit !important;
}
.coverage-summary {
  border-collapse: collapse;
  width: 100%;
}
.coverage-summary tr { border-bottom: 1px solid #bbb; }
.keyline-all { border: 1px solid #ddd; }
.coverage-summary td, .coverage-summary th { padding: 10px; }
.coverage-summary tbody { border: 1px solid #bbb; }
.coverage-summary td { border-right: 1px solid #bbb; }
.coverage-summary td:last-child { border-right: none; }
.coverage-summary th {
  text-align: left;
  font-weight: normal;
  white-space: nowrap;
}
.coverage-summary th.file { border-right: none !important; }
.coverage-summary th.pct { }
.coverage-summary th.pic,
.coverage-summary th.abs,
.coverage-summary td.pct,
.coverage-summary td.abs { text-align: right; }
.coverage-summary td.file { white-space: nowrap;  }
.coverage-summary td.pic { min-width: 120px !important;  }
.coverage-summary tfoot td { }

.coverage-summary .sorter {
    height: 10px;
    width: 7px;
    display: inline-block;
    margin-left: 0.5em;
    background: url(sort-arrow-sprite.png) no-repeat scroll 0 0 transparent;
}
.coverage-summary .sorted .sorter {
    background-position: 0 -20px;
}
.coverage-summary .sorted-desc .sorter {
    background-position: 0 -10px;
}
.status-line {  height: 10px; }
/* yellow */
.cbranch-no { background: yellow !important; color: #111; }
/* dark red */
.red.solid, .status-line.low, .low .cover-fill { background:#C21F39 }
.low .chart { border:1px solid #C21F39 }
.highlighted,
.highlighted .cstat-no, .highlighted .fstat-no, .highlighted .cbranch-no{
  background: #C21F39 !important;
}
/* medium red */
.cstat-no, .fstat-no, .cbranch-no, .cbranch-no { background:#F6C6CE }
/* light red */
.low, .cline-no { background:#FCE1E5 }
/* light green */
.high, .cline-yes { background:rgb(230,245,208) }
/* medium green */
.cstat-yes { background:rgb(161,215,106) }
/* dark green */
.status-line.high, .high .cover-fill { background:rgb(77,146,33) }
.high .chart { border:1px solid rgb(77,146,33) }
/* dark yellow (gold) */
.status-line.medium, .medium .cover-fill { background: #f9cd0b; }
.medium .chart { border:1px solid #f9cd0b; }
/* light yellow */
.medium { background: #fff4c2; }

.cstat-skip { background: #ddd; color: #111; }
.fstat-skip { background: #ddd; color: #111 !important; }
.cbranch-skip { background: #ddd !important; color: #111; }

span.cline-neutral { background: #eaeaea; }

.coverage-summary td.empty {
    opacity: .5;
    padding-top: 4px;
    padding-bottom: 4px;
    line-height: 1;
    color: #888;
}

.cover-fill, .cover-empty {
  display:inline-block;
  height: 12px;
}
.chart {
  line-height: 0;
}
.cover-empty {
    background: white;
}
.cover-full {
    border-right: none !important;
}
pre.prettyprint {
    border: none !important;
    padding: 0 !important;
    margin: 0 !important;
}
.com { color: #999 !important; }
.ignore-none { color: #999; font-weight: normal; }

.wrapper {
  min-height: 100%;
  height: auto !important;
  height: 100%;
  margin: 0 auto -48px;
}
.footer, .push {
  height: 48px;
}
</file>

<file path="frontend/coverage/block-navigation.js">
/* eslint-disable */
var jumpToCode = (function init() {
    // Classes of code we would like to highlight in the file view
    var missingCoverageClasses = ['.cbranch-no', '.cstat-no', '.fstat-no'];

    // Elements to highlight in the file listing view
    var fileListingElements = ['td.pct.low'];

    // We don't want to select elements that are direct descendants of another match
    var notSelector = ':not(' + missingCoverageClasses.join('):not(') + ') > '; // becomes `:not(a):not(b) > `

    // Selector that finds elements on the page to which we can jump
    var selector =
        fileListingElements.join(', ') +
        ', ' +
        notSelector +
        missingCoverageClasses.join(', ' + notSelector); // becomes `:not(a):not(b) > a, :not(a):not(b) > b`

    // The NodeList of matching elements
    var missingCoverageElements = document.querySelectorAll(selector);

    var currentIndex;

    function toggleClass(index) {
        missingCoverageElements
            .item(currentIndex)
            .classList.remove('highlighted');
        missingCoverageElements.item(index).classList.add('highlighted');
    }

    function makeCurrent(index) {
        toggleClass(index);
        currentIndex = index;
        missingCoverageElements.item(index).scrollIntoView({
            behavior: 'smooth',
            block: 'center',
            inline: 'center'
        });
    }

    function goToPrevious() {
        var nextIndex = 0;
        if (typeof currentIndex !== 'number' || currentIndex === 0) {
            nextIndex = missingCoverageElements.length - 1;
        } else if (missingCoverageElements.length > 1) {
            nextIndex = currentIndex - 1;
        }

        makeCurrent(nextIndex);
    }

    function goToNext() {
        var nextIndex = 0;

        if (
            typeof currentIndex === 'number' &&
            currentIndex < missingCoverageElements.length - 1
        ) {
            nextIndex = currentIndex + 1;
        }

        makeCurrent(nextIndex);
    }

    return function jump(event) {
        if (
            document.getElementById('fileSearch') === document.activeElement &&
            document.activeElement != null
        ) {
            // if we're currently focused on the search input, we don't want to navigate
            return;
        }

        switch (event.which) {
            case 78: // n
            case 74: // j
                goToNext();
                break;
            case 66: // b
            case 75: // k
            case 80: // p
                goToPrevious();
                break;
        }
    };
})();
window.addEventListener('keydown', jumpToCode);
</file>

<file path="frontend/coverage/coverage-final.json">
{"D:\\Dev\\unknown-world\\frontend\\src\\schemas\\turn.ts": {"path":"D:\\Dev\\unknown-world\\frontend\\src\\schemas\\turn.ts","statementMap":{"0":{"start":{"line":30,"column":30},"end":{"line":30,"column":null}},"1":{"start":{"line":41,"column":30},"end":{"line":41,"column":null}},"2":{"start":{"line":47,"column":27},"end":{"line":47,"column":null}},"3":{"start":{"line":54,"column":32},"end":{"line":62,"column":null}},"4":{"start":{"line":69,"column":37},"end":{"line":78,"column":null}},"5":{"start":{"line":85,"column":32},"end":{"line":85,"column":null}},"6":{"start":{"line":91,"column":31},"end":{"line":91,"column":null}},"7":{"start":{"line":102,"column":32},"end":{"line":107,"column":null}},"8":{"start":{"line":115,"column":27},"end":{"line":122,"column":null}},"9":{"start":{"line":129,"column":36},"end":{"line":138,"column":null}},"10":{"start":{"line":149,"column":32},"end":{"line":156,"column":null}},"11":{"start":{"line":162,"column":32},"end":{"line":176,"column":null}},"12":{"start":{"line":183,"column":37},"end":{"line":192,"column":null}},"13":{"start":{"line":199,"column":31},"end":{"line":209,"column":null}},"14":{"start":{"line":220,"column":32},"end":{"line":229,"column":null}},"15":{"start":{"line":236,"column":33},"end":{"line":247,"column":null}},"16":{"start":{"line":254,"column":32},"end":{"line":262,"column":null}},"17":{"start":{"line":270,"column":30},"end":{"line":278,"column":null}},"18":{"start":{"line":289,"column":31},"end":{"line":295,"column":null}},"19":{"start":{"line":302,"column":31},"end":{"line":312,"column":null}},"20":{"start":{"line":319,"column":27},"end":{"line":325,"column":null}},"21":{"start":{"line":332,"column":32},"end":{"line":359,"column":null}},"22":{"start":{"line":370,"column":30},"end":{"line":382,"column":null}},"23":{"start":{"line":389,"column":34},"end":{"line":395,"column":null}},"24":{"start":{"line":407,"column":35},"end":{"line":412,"column":null}},"25":{"start":{"line":424,"column":34},"end":{"line":436,"column":null}},"26":{"start":{"line":447,"column":34},"end":{"line":453,"column":null}},"27":{"start":{"line":469,"column":32},"end":{"line":502,"column":null}},"28":{"start":{"line":523,"column":4},"end":{"line":525,"column":null}},"29":{"start":{"line":528,"column":4},"end":{"line":530,"column":null}},"30":{"start":{"line":532,"column":2},"end":{"line":563,"column":null}},"31":{"start":{"line":590,"column":17},"end":{"line":590,"column":null}},"32":{"start":{"line":592,"column":2},"end":{"line":594,"column":null}},"33":{"start":{"line":593,"column":4},"end":{"line":593,"column":null}},"34":{"start":{"line":596,"column":2},"end":{"line":600,"column":null}},"35":{"start":{"line":611,"column":2},"end":{"line":611,"column":null}},"36":{"start":{"line":625,"column":2},"end":{"line":625,"column":null}}},"fnMap":{"0":{"name":"createFallbackTurnOutput","decl":{"start":{"line":517,"column":16},"end":{"line":517,"column":null}},"loc":{"start":{"line":521,"column":14},"end":{"line":564,"column":null}},"line":521},"1":{"name":"safeParseTurnOutput","decl":{"start":{"line":585,"column":16},"end":{"line":585,"column":null}},"loc":{"start":{"line":589,"column":25},"end":{"line":601,"column":null}},"line":589},"2":{"name":"parseTurnInput","decl":{"start":{"line":610,"column":16},"end":{"line":610,"column":31}},"loc":{"start":{"line":610,"column":57},"end":{"line":612,"column":null}},"line":610},"3":{"name":"safeParseTurnInput","decl":{"start":{"line":624,"column":16},"end":{"line":624,"column":35}},"loc":{"start":{"line":624,"column":76},"end":{"line":626,"column":null}},"line":624}},"branchMap":{"0":{"loc":{"start":{"line":519,"column":2},"end":{"line":519,"column":null}},"type":"default-arg","locations":[{"start":{"line":519,"column":24},"end":{"line":519,"column":null}}],"line":519},"1":{"loc":{"start":{"line":523,"column":4},"end":{"line":525,"column":null}},"type":"cond-expr","locations":[{"start":{"line":524,"column":8},"end":{"line":524,"column":null}},{"start":{"line":525,"column":8},"end":{"line":525,"column":null}}],"line":523},"2":{"loc":{"start":{"line":528,"column":4},"end":{"line":530,"column":null}},"type":"cond-expr","locations":[{"start":{"line":529,"column":8},"end":{"line":529,"column":null}},{"start":{"line":530,"column":8},"end":{"line":530,"column":null}}],"line":528},"3":{"loc":{"start":{"line":534,"column":15},"end":{"line":534,"column":null}},"type":"binary-expr","locations":[{"start":{"line":534,"column":15},"end":{"line":534,"column":31}},{"start":{"line":534,"column":31},"end":{"line":534,"column":null}}],"line":534},"4":{"loc":{"start":{"line":587,"column":2},"end":{"line":587,"column":null}},"type":"default-arg","locations":[{"start":{"line":587,"column":23},"end":{"line":587,"column":null}}],"line":587},"5":{"loc":{"start":{"line":588,"column":2},"end":{"line":588,"column":null}},"type":"default-arg","locations":[{"start":{"line":588,"column":24},"end":{"line":588,"column":null}}],"line":588},"6":{"loc":{"start":{"line":592,"column":2},"end":{"line":594,"column":null}},"type":"if","locations":[{"start":{"line":592,"column":2},"end":{"line":594,"column":null}},{"start":{},"end":{}}],"line":592}},"s":{"0":1,"1":1,"2":1,"3":1,"4":1,"5":1,"6":1,"7":1,"8":1,"9":1,"10":1,"11":1,"12":1,"13":1,"14":1,"15":1,"16":1,"17":1,"18":1,"19":1,"20":1,"21":1,"22":1,"23":1,"24":1,"25":1,"26":1,"27":1,"28":1,"29":1,"30":1,"31":2,"32":2,"33":1,"34":1,"35":2,"36":2},"f":{"0":1,"1":2,"2":2,"3":2},"b":{"0":[1],"1":[1,0],"2":[1,0],"3":[1,1],"4":[2],"5":[2],"6":[1,1]},"meta":{"lastBranch":7,"lastFunction":4,"lastStatement":37,"seen":{"s:30:30:30:Infinity":0,"s:41:30:41:Infinity":1,"s:47:27:47:Infinity":2,"s:54:32:62:Infinity":3,"s:69:37:78:Infinity":4,"s:85:32:85:Infinity":5,"s:91:31:91:Infinity":6,"s:102:32:107:Infinity":7,"s:115:27:122:Infinity":8,"s:129:36:138:Infinity":9,"s:149:32:156:Infinity":10,"s:162:32:176:Infinity":11,"s:183:37:192:Infinity":12,"s:199:31:209:Infinity":13,"s:220:32:229:Infinity":14,"s:236:33:247:Infinity":15,"s:254:32:262:Infinity":16,"s:270:30:278:Infinity":17,"s:289:31:295:Infinity":18,"s:302:31:312:Infinity":19,"s:319:27:325:Infinity":20,"s:332:32:359:Infinity":21,"s:370:30:382:Infinity":22,"s:389:34:395:Infinity":23,"s:407:35:412:Infinity":24,"s:424:34:436:Infinity":25,"s:447:34:453:Infinity":26,"s:469:32:502:Infinity":27,"f:517:16:517:Infinity":0,"b:519:24:519:Infinity":0,"s:523:4:525:Infinity":28,"b:524:8:524:Infinity:525:8:525:Infinity":1,"s:528:4:530:Infinity":29,"b:529:8:529:Infinity:530:8:530:Infinity":2,"s:532:2:563:Infinity":30,"b:534:15:534:31:534:31:534:Infinity":3,"f:585:16:585:Infinity":1,"b:587:23:587:Infinity":4,"b:588:24:588:Infinity":5,"s:590:17:590:Infinity":31,"b:592:2:594:Infinity:undefined:undefined:undefined:undefined":6,"s:592:2:594:Infinity":32,"s:593:4:593:Infinity":33,"s:596:2:600:Infinity":34,"f:610:16:610:31":2,"s:611:2:611:Infinity":35,"f:624:16:624:35":3,"s:625:2:625:Infinity":36}}}
}
</file>

<file path="frontend/coverage/prettify.css">
.pln{color:#000}@media screen{.str{color:#080}.kwd{color:#008}.com{color:#800}.typ{color:#606}.lit{color:#066}.pun,.opn,.clo{color:#660}.tag{color:#008}.atn{color:#606}.atv{color:#080}.dec,.var{color:#606}.fun{color:red}}@media print,projection{.str{color:#060}.kwd{color:#006;font-weight:bold}.com{color:#600;font-style:italic}.typ{color:#404;font-weight:bold}.lit{color:#044}.pun,.opn,.clo{color:#440}.tag{color:#006;font-weight:bold}.atn{color:#404}.atv{color:#060}}pre.prettyprint{padding:2px;border:1px solid #888}ol.linenums{margin-top:0;margin-bottom:0}li.L0,li.L1,li.L2,li.L3,li.L5,li.L6,li.L7,li.L8{list-style-type:none}li.L1,li.L3,li.L5,li.L7,li.L9{background:#eee}
</file>

<file path="frontend/coverage/prettify.js">
/* eslint-disable */
window.PR_SHOULD_USE_CONTINUATION=true;(function(){var h=["break,continue,do,else,for,if,return,while"];var u=[h,"auto,case,char,const,default,double,enum,extern,float,goto,int,long,register,short,signed,sizeof,static,struct,switch,typedef,union,unsigned,void,volatile"];var p=[u,"catch,class,delete,false,import,new,operator,private,protected,public,this,throw,true,try,typeof"];var l=[p,"alignof,align_union,asm,axiom,bool,concept,concept_map,const_cast,constexpr,decltype,dynamic_cast,explicit,export,friend,inline,late_check,mutable,namespace,nullptr,reinterpret_cast,static_assert,static_cast,template,typeid,typename,using,virtual,where"];var x=[p,"abstract,boolean,byte,extends,final,finally,implements,import,instanceof,null,native,package,strictfp,super,synchronized,throws,transient"];var R=[x,"as,base,by,checked,decimal,delegate,descending,dynamic,event,fixed,foreach,from,group,implicit,in,interface,internal,into,is,lock,object,out,override,orderby,params,partial,readonly,ref,sbyte,sealed,stackalloc,string,select,uint,ulong,unchecked,unsafe,ushort,var"];var r="all,and,by,catch,class,else,extends,false,finally,for,if,in,is,isnt,loop,new,no,not,null,of,off,on,or,return,super,then,true,try,unless,until,when,while,yes";var w=[p,"debugger,eval,export,function,get,null,set,undefined,var,with,Infinity,NaN"];var s="caller,delete,die,do,dump,elsif,eval,exit,foreach,for,goto,if,import,last,local,my,next,no,our,print,package,redo,require,sub,undef,unless,until,use,wantarray,while,BEGIN,END";var I=[h,"and,as,assert,class,def,del,elif,except,exec,finally,from,global,import,in,is,lambda,nonlocal,not,or,pass,print,raise,try,with,yield,False,True,None"];var f=[h,"alias,and,begin,case,class,def,defined,elsif,end,ensure,false,in,module,next,nil,not,or,redo,rescue,retry,self,super,then,true,undef,unless,until,when,yield,BEGIN,END"];var H=[h,"case,done,elif,esac,eval,fi,function,in,local,set,then,until"];var A=[l,R,w,s+I,f,H];var e=/^(DIR|FILE|vector|(de|priority_)?queue|list|stack|(const_)?iterator|(multi)?(set|map)|bitset|u?(int|float)\d*)/;var C="str";var z="kwd";var j="com";var O="typ";var G="lit";var L="pun";var F="pln";var m="tag";var E="dec";var J="src";var P="atn";var n="atv";var N="nocode";var M="(?:^^\\.?|[+-]|\\!|\\!=|\\!==|\\#|\\%|\\%=|&|&&|&&=|&=|\\(|\\*|\\*=|\\+=|\\,|\\-=|\\->|\\/|\\/=|:|::|\\;|<|<<|<<=|<=|=|==|===|>|>=|>>|>>=|>>>|>>>=|\\?|\\@|\\[|\\^|\\^=|\\^\\^|\\^\\^=|\\{|\\||\\|=|\\|\\||\\|\\|=|\\~|break|case|continue|delete|do|else|finally|instanceof|return|throw|try|typeof)\\s*";function k(Z){var ad=0;var S=false;var ac=false;for(var V=0,U=Z.length;V<U;++V){var ae=Z[V];if(ae.ignoreCase){ac=true}else{if(/[a-z]/i.test(ae.source.replace(/\\u[0-9a-f]{4}|\\x[0-9a-f]{2}|\\[^ux]/gi,""))){S=true;ac=false;break}}}var Y={b:8,t:9,n:10,v:11,f:12,r:13};function ab(ah){var ag=ah.charCodeAt(0);if(ag!==92){return ag}var af=ah.charAt(1);ag=Y[af];if(ag){return ag}else{if("0"<=af&&af<="7"){return parseInt(ah.substring(1),8)}else{if(af==="u"||af==="x"){return parseInt(ah.substring(2),16)}else{return ah.charCodeAt(1)}}}}function T(af){if(af<32){return(af<16?"\\x0":"\\x")+af.toString(16)}var ag=String.fromCharCode(af);if(ag==="\\"||ag==="-"||ag==="["||ag==="]"){ag="\\"+ag}return ag}function X(am){var aq=am.substring(1,am.length-1).match(new RegExp("\\\\u[0-9A-Fa-f]{4}|\\\\x[0-9A-Fa-f]{2}|\\\\[0-3][0-7]{0,2}|\\\\[0-7]{1,2}|\\\\[\\s\\S]|-|[^-\\\\]","g"));var ak=[];var af=[];var ao=aq[0]==="^";for(var ar=ao?1:0,aj=aq.length;ar<aj;++ar){var ah=aq[ar];if(/\\[bdsw]/i.test(ah)){ak.push(ah)}else{var ag=ab(ah);var al;if(ar+2<aj&&"-"===aq[ar+1]){al=ab(aq[ar+2]);ar+=2}else{al=ag}af.push([ag,al]);if(!(al<65||ag>122)){if(!(al<65||ag>90)){af.push([Math.max(65,ag)|32,Math.min(al,90)|32])}if(!(al<97||ag>122)){af.push([Math.max(97,ag)&~32,Math.min(al,122)&~32])}}}}af.sort(function(av,au){return(av[0]-au[0])||(au[1]-av[1])});var ai=[];var ap=[NaN,NaN];for(var ar=0;ar<af.length;++ar){var at=af[ar];if(at[0]<=ap[1]+1){ap[1]=Math.max(ap[1],at[1])}else{ai.push(ap=at)}}var an=["["];if(ao){an.push("^")}an.push.apply(an,ak);for(var ar=0;ar<ai.length;++ar){var at=ai[ar];an.push(T(at[0]));if(at[1]>at[0]){if(at[1]+1>at[0]){an.push("-")}an.push(T(at[1]))}}an.push("]");return an.join("")}function W(al){var aj=al.source.match(new RegExp("(?:\\[(?:[^\\x5C\\x5D]|\\\\[\\s\\S])*\\]|\\\\u[A-Fa-f0-9]{4}|\\\\x[A-Fa-f0-9]{2}|\\\\[0-9]+|\\\\[^ux0-9]|\\(\\?[:!=]|[\\(\\)\\^]|[^\\x5B\\x5C\\(\\)\\^]+)","g"));var ah=aj.length;var an=[];for(var ak=0,am=0;ak<ah;++ak){var ag=aj[ak];if(ag==="("){++am}else{if("\\"===ag.charAt(0)){var af=+ag.substring(1);if(af&&af<=am){an[af]=-1}}}}for(var ak=1;ak<an.length;++ak){if(-1===an[ak]){an[ak]=++ad}}for(var ak=0,am=0;ak<ah;++ak){var ag=aj[ak];if(ag==="("){++am;if(an[am]===undefined){aj[ak]="(?:"}}else{if("\\"===ag.charAt(0)){var af=+ag.substring(1);if(af&&af<=am){aj[ak]="\\"+an[am]}}}}for(var ak=0,am=0;ak<ah;++ak){if("^"===aj[ak]&&"^"!==aj[ak+1]){aj[ak]=""}}if(al.ignoreCase&&S){for(var ak=0;ak<ah;++ak){var ag=aj[ak];var ai=ag.charAt(0);if(ag.length>=2&&ai==="["){aj[ak]=X(ag)}else{if(ai!=="\\"){aj[ak]=ag.replace(/[a-zA-Z]/g,function(ao){var ap=ao.charCodeAt(0);return"["+String.fromCharCode(ap&~32,ap|32)+"]"})}}}}return aj.join("")}var aa=[];for(var V=0,U=Z.length;V<U;++V){var ae=Z[V];if(ae.global||ae.multiline){throw new Error(""+ae)}aa.push("(?:"+W(ae)+")")}return new RegExp(aa.join("|"),ac?"gi":"g")}function a(V){var U=/(?:^|\s)nocode(?:\s|$)/;var X=[];var T=0;var Z=[];var W=0;var S;if(V.currentStyle){S=V.currentStyle.whiteSpace}else{if(window.getComputedStyle){S=document.defaultView.getComputedStyle(V,null).getPropertyValue("white-space")}}var Y=S&&"pre"===S.substring(0,3);function aa(ab){switch(ab.nodeType){case 1:if(U.test(ab.className)){return}for(var ae=ab.firstChild;ae;ae=ae.nextSibling){aa(ae)}var ad=ab.nodeName;if("BR"===ad||"LI"===ad){X[W]="\n";Z[W<<1]=T++;Z[(W++<<1)|1]=ab}break;case 3:case 4:var ac=ab.nodeValue;if(ac.length){if(!Y){ac=ac.replace(/[ \t\r\n]+/g," ")}else{ac=ac.replace(/\r\n?/g,"\n")}X[W]=ac;Z[W<<1]=T;T+=ac.length;Z[(W++<<1)|1]=ab}break}}aa(V);return{sourceCode:X.join("").replace(/\n$/,""),spans:Z}}function B(S,U,W,T){if(!U){return}var V={sourceCode:U,basePos:S};W(V);T.push.apply(T,V.decorations)}var v=/\S/;function o(S){var V=undefined;for(var U=S.firstChild;U;U=U.nextSibling){var T=U.nodeType;V=(T===1)?(V?S:U):(T===3)?(v.test(U.nodeValue)?S:V):V}return V===S?undefined:V}function g(U,T){var S={};var V;(function(){var ad=U.concat(T);var ah=[];var ag={};for(var ab=0,Z=ad.length;ab<Z;++ab){var Y=ad[ab];var ac=Y[3];if(ac){for(var ae=ac.length;--ae>=0;){S[ac.charAt(ae)]=Y}}var af=Y[1];var aa=""+af;if(!ag.hasOwnProperty(aa)){ah.push(af);ag[aa]=null}}ah.push(/[\0-\uffff]/);V=k(ah)})();var X=T.length;var W=function(ah){var Z=ah.sourceCode,Y=ah.basePos;var ad=[Y,F];var af=0;var an=Z.match(V)||[];var aj={};for(var ae=0,aq=an.length;ae<aq;++ae){var ag=an[ae];var ap=aj[ag];var ai=void 0;var am;if(typeof ap==="string"){am=false}else{var aa=S[ag.charAt(0)];if(aa){ai=ag.match(aa[1]);ap=aa[0]}else{for(var ao=0;ao<X;++ao){aa=T[ao];ai=ag.match(aa[1]);if(ai){ap=aa[0];break}}if(!ai){ap=F}}am=ap.length>=5&&"lang-"===ap.substring(0,5);if(am&&!(ai&&typeof ai[1]==="string")){am=false;ap=J}if(!am){aj[ag]=ap}}var ab=af;af+=ag.length;if(!am){ad.push(Y+ab,ap)}else{var al=ai[1];var ak=ag.indexOf(al);var ac=ak+al.length;if(ai[2]){ac=ag.length-ai[2].length;ak=ac-al.length}var ar=ap.substring(5);B(Y+ab,ag.substring(0,ak),W,ad);B(Y+ab+ak,al,q(ar,al),ad);B(Y+ab+ac,ag.substring(ac),W,ad)}}ah.decorations=ad};return W}function i(T){var W=[],S=[];if(T.tripleQuotedStrings){W.push([C,/^(?:\'\'\'(?:[^\'\\]|\\[\s\S]|\'{1,2}(?=[^\']))*(?:\'\'\'|$)|\"\"\"(?:[^\"\\]|\\[\s\S]|\"{1,2}(?=[^\"]))*(?:\"\"\"|$)|\'(?:[^\\\']|\\[\s\S])*(?:\'|$)|\"(?:[^\\\"]|\\[\s\S])*(?:\"|$))/,null,"'\""])}else{if(T.multiLineStrings){W.push([C,/^(?:\'(?:[^\\\']|\\[\s\S])*(?:\'|$)|\"(?:[^\\\"]|\\[\s\S])*(?:\"|$)|\`(?:[^\\\`]|\\[\s\S])*(?:\`|$))/,null,"'\"`"])}else{W.push([C,/^(?:\'(?:[^\\\'\r\n]|\\.)*(?:\'|$)|\"(?:[^\\\"\r\n]|\\.)*(?:\"|$))/,null,"\"'"])}}if(T.verbatimStrings){S.push([C,/^@\"(?:[^\"]|\"\")*(?:\"|$)/,null])}var Y=T.hashComments;if(Y){if(T.cStyleComments){if(Y>1){W.push([j,/^#(?:##(?:[^#]|#(?!##))*(?:###|$)|.*)/,null,"#"])}else{W.push([j,/^#(?:(?:define|elif|else|endif|error|ifdef|include|ifndef|line|pragma|undef|warning)\b|[^\r\n]*)/,null,"#"])}S.push([C,/^<(?:(?:(?:\.\.\/)*|\/?)(?:[\w-]+(?:\/[\w-]+)+)?[\w-]+\.h|[a-z]\w*)>/,null])}else{W.push([j,/^#[^\r\n]*/,null,"#"])}}if(T.cStyleComments){S.push([j,/^\/\/[^\r\n]*/,null]);S.push([j,/^\/\*[\s\S]*?(?:\*\/|$)/,null])}if(T.regexLiterals){var X=("/(?=[^/*])(?:[^/\\x5B\\x5C]|\\x5C[\\s\\S]|\\x5B(?:[^\\x5C\\x5D]|\\x5C[\\s\\S])*(?:\\x5D|$))+/");S.push(["lang-regex",new RegExp("^"+M+"("+X+")")])}var V=T.types;if(V){S.push([O,V])}var U=(""+T.keywords).replace(/^ | $/g,"");if(U.length){S.push([z,new RegExp("^(?:"+U.replace(/[\s,]+/g,"|")+")\\b"),null])}W.push([F,/^\s+/,null," \r\n\t\xA0"]);S.push([G,/^@[a-z_$][a-z_$@0-9]*/i,null],[O,/^(?:[@_]?[A-Z]+[a-z][A-Za-z_$@0-9]*|\w+_t\b)/,null],[F,/^[a-z_$][a-z_$@0-9]*/i,null],[G,new RegExp("^(?:0x[a-f0-9]+|(?:\\d(?:_\\d+)*\\d*(?:\\.\\d*)?|\\.\\d\\+)(?:e[+\\-]?\\d+)?)[a-z]*","i"),null,"0123456789"],[F,/^\\[\s\S]?/,null],[L,/^.[^\s\w\.$@\'\"\`\/\#\\]*/,null]);return g(W,S)}var K=i({keywords:A,hashComments:true,cStyleComments:true,multiLineStrings:true,regexLiterals:true});function Q(V,ag){var U=/(?:^|\s)nocode(?:\s|$)/;var ab=/\r\n?|\n/;var ac=V.ownerDocument;var S;if(V.currentStyle){S=V.currentStyle.whiteSpace}else{if(window.getComputedStyle){S=ac.defaultView.getComputedStyle(V,null).getPropertyValue("white-space")}}var Z=S&&"pre"===S.substring(0,3);var af=ac.createElement("LI");while(V.firstChild){af.appendChild(V.firstChild)}var W=[af];function ae(al){switch(al.nodeType){case 1:if(U.test(al.className)){break}if("BR"===al.nodeName){ad(al);if(al.parentNode){al.parentNode.removeChild(al)}}else{for(var an=al.firstChild;an;an=an.nextSibling){ae(an)}}break;case 3:case 4:if(Z){var am=al.nodeValue;var aj=am.match(ab);if(aj){var ai=am.substring(0,aj.index);al.nodeValue=ai;var ah=am.substring(aj.index+aj[0].length);if(ah){var ak=al.parentNode;ak.insertBefore(ac.createTextNode(ah),al.nextSibling)}ad(al);if(!ai){al.parentNode.removeChild(al)}}}break}}function ad(ak){while(!ak.nextSibling){ak=ak.parentNode;if(!ak){return}}function ai(al,ar){var aq=ar?al.cloneNode(false):al;var ao=al.parentNode;if(ao){var ap=ai(ao,1);var an=al.nextSibling;ap.appendChild(aq);for(var am=an;am;am=an){an=am.nextSibling;ap.appendChild(am)}}return aq}var ah=ai(ak.nextSibling,0);for(var aj;(aj=ah.parentNode)&&aj.nodeType===1;){ah=aj}W.push(ah)}for(var Y=0;Y<W.length;++Y){ae(W[Y])}if(ag===(ag|0)){W[0].setAttribute("value",ag)}var aa=ac.createElement("OL");aa.className="linenums";var X=Math.max(0,((ag-1))|0)||0;for(var Y=0,T=W.length;Y<T;++Y){af=W[Y];af.className="L"+((Y+X)%10);if(!af.firstChild){af.appendChild(ac.createTextNode("\xA0"))}aa.appendChild(af)}V.appendChild(aa)}function D(ac){var aj=/\bMSIE\b/.test(navigator.userAgent);var am=/\n/g;var al=ac.sourceCode;var an=al.length;var V=0;var aa=ac.spans;var T=aa.length;var ah=0;var X=ac.decorations;var Y=X.length;var Z=0;X[Y]=an;var ar,aq;for(aq=ar=0;aq<Y;){if(X[aq]!==X[aq+2]){X[ar++]=X[aq++];X[ar++]=X[aq++]}else{aq+=2}}Y=ar;for(aq=ar=0;aq<Y;){var at=X[aq];var ab=X[aq+1];var W=aq+2;while(W+2<=Y&&X[W+1]===ab){W+=2}X[ar++]=at;X[ar++]=ab;aq=W}Y=X.length=ar;var ae=null;while(ah<T){var af=aa[ah];var S=aa[ah+2]||an;var ag=X[Z];var ap=X[Z+2]||an;var W=Math.min(S,ap);var ak=aa[ah+1];var U;if(ak.nodeType!==1&&(U=al.substring(V,W))){if(aj){U=U.replace(am,"\r")}ak.nodeValue=U;var ai=ak.ownerDocument;var ao=ai.createElement("SPAN");ao.className=X[Z+1];var ad=ak.parentNode;ad.replaceChild(ao,ak);ao.appendChild(ak);if(V<S){aa[ah+1]=ak=ai.createTextNode(al.substring(W,S));ad.insertBefore(ak,ao.nextSibling)}}V=W;if(V>=S){ah+=2}if(V>=ap){Z+=2}}}var t={};function c(U,V){for(var S=V.length;--S>=0;){var T=V[S];if(!t.hasOwnProperty(T)){t[T]=U}else{if(window.console){console.warn("cannot override language handler %s",T)}}}}function q(T,S){if(!(T&&t.hasOwnProperty(T))){T=/^\s*</.test(S)?"default-markup":"default-code"}return t[T]}c(K,["default-code"]);c(g([],[[F,/^[^<?]+/],[E,/^<!\w[^>]*(?:>|$)/],[j,/^<\!--[\s\S]*?(?:-\->|$)/],["lang-",/^<\?([\s\S]+?)(?:\?>|$)/],["lang-",/^<%([\s\S]+?)(?:%>|$)/],[L,/^(?:<[%?]|[%?]>)/],["lang-",/^<xmp\b[^>]*>([\s\S]+?)<\/xmp\b[^>]*>/i],["lang-js",/^<script\b[^>]*>([\s\S]*?)(<\/script\b[^>]*>)/i],["lang-css",/^<style\b[^>]*>([\s\S]*?)(<\/style\b[^>]*>)/i],["lang-in.tag",/^(<\/?[a-z][^<>]*>)/i]]),["default-markup","htm","html","mxml","xhtml","xml","xsl"]);c(g([[F,/^[\s]+/,null," \t\r\n"],[n,/^(?:\"[^\"]*\"?|\'[^\']*\'?)/,null,"\"'"]],[[m,/^^<\/?[a-z](?:[\w.:-]*\w)?|\/?>$/i],[P,/^(?!style[\s=]|on)[a-z](?:[\w:-]*\w)?/i],["lang-uq.val",/^=\s*([^>\'\"\s]*(?:[^>\'\"\s\/]|\/(?=\s)))/],[L,/^[=<>\/]+/],["lang-js",/^on\w+\s*=\s*\"([^\"]+)\"/i],["lang-js",/^on\w+\s*=\s*\'([^\']+)\'/i],["lang-js",/^on\w+\s*=\s*([^\"\'>\s]+)/i],["lang-css",/^style\s*=\s*\"([^\"]+)\"/i],["lang-css",/^style\s*=\s*\'([^\']+)\'/i],["lang-css",/^style\s*=\s*([^\"\'>\s]+)/i]]),["in.tag"]);c(g([],[[n,/^[\s\S]+/]]),["uq.val"]);c(i({keywords:l,hashComments:true,cStyleComments:true,types:e}),["c","cc","cpp","cxx","cyc","m"]);c(i({keywords:"null,true,false"}),["json"]);c(i({keywords:R,hashComments:true,cStyleComments:true,verbatimStrings:true,types:e}),["cs"]);c(i({keywords:x,cStyleComments:true}),["java"]);c(i({keywords:H,hashComments:true,multiLineStrings:true}),["bsh","csh","sh"]);c(i({keywords:I,hashComments:true,multiLineStrings:true,tripleQuotedStrings:true}),["cv","py"]);c(i({keywords:s,hashComments:true,multiLineStrings:true,regexLiterals:true}),["perl","pl","pm"]);c(i({keywords:f,hashComments:true,multiLineStrings:true,regexLiterals:true}),["rb"]);c(i({keywords:w,cStyleComments:true,regexLiterals:true}),["js"]);c(i({keywords:r,hashComments:3,cStyleComments:true,multilineStrings:true,tripleQuotedStrings:true,regexLiterals:true}),["coffee"]);c(g([],[[C,/^[\s\S]+/]]),["regex"]);function d(V){var U=V.langExtension;try{var S=a(V.sourceNode);var T=S.sourceCode;V.sourceCode=T;V.spans=S.spans;V.basePos=0;q(U,T)(V);D(V)}catch(W){if("console" in window){console.log(W&&W.stack?W.stack:W)}}}function y(W,V,U){var S=document.createElement("PRE");S.innerHTML=W;if(U){Q(S,U)}var T={langExtension:V,numberLines:U,sourceNode:S};d(T);return S.innerHTML}function b(ad){function Y(af){return document.getElementsByTagName(af)}var ac=[Y("pre"),Y("code"),Y("xmp")];var T=[];for(var aa=0;aa<ac.length;++aa){for(var Z=0,V=ac[aa].length;Z<V;++Z){T.push(ac[aa][Z])}}ac=null;var W=Date;if(!W.now){W={now:function(){return +(new Date)}}}var X=0;var S;var ab=/\blang(?:uage)?-([\w.]+)(?!\S)/;var ae=/\bprettyprint\b/;function U(){var ag=(window.PR_SHOULD_USE_CONTINUATION?W.now()+250:Infinity);for(;X<T.length&&W.now()<ag;X++){var aj=T[X];var ai=aj.className;if(ai.indexOf("prettyprint")>=0){var ah=ai.match(ab);var am;if(!ah&&(am=o(aj))&&"CODE"===am.tagName){ah=am.className.match(ab)}if(ah){ah=ah[1]}var al=false;for(var ak=aj.parentNode;ak;ak=ak.parentNode){if((ak.tagName==="pre"||ak.tagName==="code"||ak.tagName==="xmp")&&ak.className&&ak.className.indexOf("prettyprint")>=0){al=true;break}}if(!al){var af=aj.className.match(/\blinenums\b(?::(\d+))?/);af=af?af[1]&&af[1].length?+af[1]:true:false;if(af){Q(aj,af)}S={langExtension:ah,sourceNode:aj,numberLines:af};d(S)}}}if(X<T.length){setTimeout(U,250)}else{if(ad){ad()}}}U()}window.prettyPrintOne=y;window.prettyPrint=b;window.PR={createSimpleLexer:g,registerLangHandler:c,sourceDecorator:i,PR_ATTRIB_NAME:P,PR_ATTRIB_VALUE:n,PR_COMMENT:j,PR_DECLARATION:E,PR_KEYWORD:z,PR_LITERAL:G,PR_NOCODE:N,PR_PLAIN:F,PR_PUNCTUATION:L,PR_SOURCE:J,PR_STRING:C,PR_TAG:m,PR_TYPE:O}})();PR.registerLangHandler(PR.createSimpleLexer([],[[PR.PR_DECLARATION,/^<!\w[^>]*(?:>|$)/],[PR.PR_COMMENT,/^<\!--[\s\S]*?(?:-\->|$)/],[PR.PR_PUNCTUATION,/^(?:<[%?]|[%?]>)/],["lang-",/^<\?([\s\S]+?)(?:\?>|$)/],["lang-",/^<%([\s\S]+?)(?:%>|$)/],["lang-",/^<xmp\b[^>]*>([\s\S]+?)<\/xmp\b[^>]*>/i],["lang-handlebars",/^<script\b[^>]*type\s*=\s*['"]?text\/x-handlebars-template['"]?\b[^>]*>([\s\S]*?)(<\/script\b[^>]*>)/i],["lang-js",/^<script\b[^>]*>([\s\S]*?)(<\/script\b[^>]*>)/i],["lang-css",/^<style\b[^>]*>([\s\S]*?)(<\/style\b[^>]*>)/i],["lang-in.tag",/^(<\/?[a-z][^<>]*>)/i],[PR.PR_DECLARATION,/^{{[#^>/]?\s*[\w.][^}]*}}/],[PR.PR_DECLARATION,/^{{&?\s*[\w.][^}]*}}/],[PR.PR_DECLARATION,/^{{{>?\s*[\w.][^}]*}}}/],[PR.PR_COMMENT,/^{{![^}]*}}/]]),["handlebars","hbs"]);PR.registerLangHandler(PR.createSimpleLexer([[PR.PR_PLAIN,/^[ \t\r\n\f]+/,null," \t\r\n\f"]],[[PR.PR_STRING,/^\"(?:[^\n\r\f\\\"]|\\(?:\r\n?|\n|\f)|\\[\s\S])*\"/,null],[PR.PR_STRING,/^\'(?:[^\n\r\f\\\']|\\(?:\r\n?|\n|\f)|\\[\s\S])*\'/,null],["lang-css-str",/^url\(([^\)\"\']*)\)/i],[PR.PR_KEYWORD,/^(?:url|rgb|\!important|@import|@page|@media|@charset|inherit)(?=[^\-\w]|$)/i,null],["lang-css-kw",/^(-?(?:[_a-z]|(?:\\[0-9a-f]+ ?))(?:[_a-z0-9\-]|\\(?:\\[0-9a-f]+ ?))*)\s*:/i],[PR.PR_COMMENT,/^\/\*[^*]*\*+(?:[^\/*][^*]*\*+)*\//],[PR.PR_COMMENT,/^(?:<!--|-->)/],[PR.PR_LITERAL,/^(?:\d+|\d*\.\d+)(?:%|[a-z]+)?/i],[PR.PR_LITERAL,/^#(?:[0-9a-f]{3}){1,2}/i],[PR.PR_PLAIN,/^-?(?:[_a-z]|(?:\\[\da-f]+ ?))(?:[_a-z\d\-]|\\(?:\\[\da-f]+ ?))*/i],[PR.PR_PUNCTUATION,/^[^\s\w\'\"]+/]]),["css"]);PR.registerLangHandler(PR.createSimpleLexer([],[[PR.PR_KEYWORD,/^-?(?:[_a-z]|(?:\\[\da-f]+ ?))(?:[_a-z\d\-]|\\(?:\\[\da-f]+ ?))*/i]]),["css-kw"]);PR.registerLangHandler(PR.createSimpleLexer([],[[PR.PR_STRING,/^[^\)\"\']+/]]),["css-str"]);
</file>

<file path="frontend/coverage/sorter.js">
/* eslint-disable */
var addSorting = (function() {
    'use strict';
    var cols,
        currentSort = {
            index: 0,
            desc: false
        };

    // returns the summary table element
    function getTable() {
        return document.querySelector('.coverage-summary');
    }
    // returns the thead element of the summary table
    function getTableHeader() {
        return getTable().querySelector('thead tr');
    }
    // returns the tbody element of the summary table
    function getTableBody() {
        return getTable().querySelector('tbody');
    }
    // returns the th element for nth column
    function getNthColumn(n) {
        return getTableHeader().querySelectorAll('th')[n];
    }

    function onFilterInput() {
        const searchValue = document.getElementById('fileSearch').value;
        const rows = document.getElementsByTagName('tbody')[0].children;

        // Try to create a RegExp from the searchValue. If it fails (invalid regex),
        // it will be treated as a plain text search
        let searchRegex;
        try {
            searchRegex = new RegExp(searchValue, 'i'); // 'i' for case-insensitive
        } catch (error) {
            searchRegex = null;
        }

        for (let i = 0; i < rows.length; i++) {
            const row = rows[i];
            let isMatch = false;

            if (searchRegex) {
                // If a valid regex was created, use it for matching
                isMatch = searchRegex.test(row.textContent);
            } else {
                // Otherwise, fall back to the original plain text search
                isMatch = row.textContent
                    .toLowerCase()
                    .includes(searchValue.toLowerCase());
            }

            row.style.display = isMatch ? '' : 'none';
        }
    }

    // loads the search box
    function addSearchBox() {
        var template = document.getElementById('filterTemplate');
        var templateClone = template.content.cloneNode(true);
        templateClone.getElementById('fileSearch').oninput = onFilterInput;
        template.parentElement.appendChild(templateClone);
    }

    // loads all columns
    function loadColumns() {
        var colNodes = getTableHeader().querySelectorAll('th'),
            colNode,
            cols = [],
            col,
            i;

        for (i = 0; i < colNodes.length; i += 1) {
            colNode = colNodes[i];
            col = {
                key: colNode.getAttribute('data-col'),
                sortable: !colNode.getAttribute('data-nosort'),
                type: colNode.getAttribute('data-type') || 'string'
            };
            cols.push(col);
            if (col.sortable) {
                col.defaultDescSort = col.type === 'number';
                colNode.innerHTML =
                    colNode.innerHTML + '<span class="sorter"></span>';
            }
        }
        return cols;
    }
    // attaches a data attribute to every tr element with an object
    // of data values keyed by column name
    function loadRowData(tableRow) {
        var tableCols = tableRow.querySelectorAll('td'),
            colNode,
            col,
            data = {},
            i,
            val;
        for (i = 0; i < tableCols.length; i += 1) {
            colNode = tableCols[i];
            col = cols[i];
            val = colNode.getAttribute('data-value');
            if (col.type === 'number') {
                val = Number(val);
            }
            data[col.key] = val;
        }
        return data;
    }
    // loads all row data
    function loadData() {
        var rows = getTableBody().querySelectorAll('tr'),
            i;

        for (i = 0; i < rows.length; i += 1) {
            rows[i].data = loadRowData(rows[i]);
        }
    }
    // sorts the table using the data for the ith column
    function sortByIndex(index, desc) {
        var key = cols[index].key,
            sorter = function(a, b) {
                a = a.data[key];
                b = b.data[key];
                return a < b ? -1 : a > b ? 1 : 0;
            },
            finalSorter = sorter,
            tableBody = document.querySelector('.coverage-summary tbody'),
            rowNodes = tableBody.querySelectorAll('tr'),
            rows = [],
            i;

        if (desc) {
            finalSorter = function(a, b) {
                return -1 * sorter(a, b);
            };
        }

        for (i = 0; i < rowNodes.length; i += 1) {
            rows.push(rowNodes[i]);
            tableBody.removeChild(rowNodes[i]);
        }

        rows.sort(finalSorter);

        for (i = 0; i < rows.length; i += 1) {
            tableBody.appendChild(rows[i]);
        }
    }
    // removes sort indicators for current column being sorted
    function removeSortIndicators() {
        var col = getNthColumn(currentSort.index),
            cls = col.className;

        cls = cls.replace(/ sorted$/, '').replace(/ sorted-desc$/, '');
        col.className = cls;
    }
    // adds sort indicators for current column being sorted
    function addSortIndicators() {
        getNthColumn(currentSort.index).className += currentSort.desc
            ? ' sorted-desc'
            : ' sorted';
    }
    // adds event listeners for all sorter widgets
    function enableUI() {
        var i,
            el,
            ithSorter = function ithSorter(i) {
                var col = cols[i];

                return function() {
                    var desc = col.defaultDescSort;

                    if (currentSort.index === i) {
                        desc = !currentSort.desc;
                    }
                    sortByIndex(i, desc);
                    removeSortIndicators();
                    currentSort.index = i;
                    currentSort.desc = desc;
                    addSortIndicators();
                };
            };
        for (i = 0; i < cols.length; i += 1) {
            if (cols[i].sortable) {
                // add the click event handler on the th so users
                // dont have to click on those tiny arrows
                el = getNthColumn(i).querySelector('.sorter').parentElement;
                if (el.addEventListener) {
                    el.addEventListener('click', ithSorter(i));
                } else {
                    el.attachEvent('onclick', ithSorter(i));
                }
            }
        }
    }
    // adds sorting functionality to the UI
    return function() {
        if (!getTable()) {
            return;
        }
        cols = loadColumns();
        loadData();
        addSearchBox();
        addSortIndicators();
        enableUI();
    };
})();

window.addEventListener('load', addSorting);
</file>

<file path="frontend/public/ui/QA_CHECKLIST.md">
# UI 에셋 QA 체크리스트

> **참조**: `frontend/public/ui/README.md` (SSOT 규칙), `vibe/ref/rembg-guide.md` (배경 제거)  
> **목적**: nanobanana mcp로 생성한 에셋의 품질/일관성 보장  
> **적용 시점**: 에셋 추가/수정 시 반드시 체크

---

## 1. 용량 예산 (Performance Budget)

### 1.1 개별 에셋 상한

| 유형            | 상한  | 권장       | 체크 항목         |
| --------------- | ----- | ---------- | ----------------- |
| **아이콘**      | 30KB  | 20KB 이하  | `bytes` 필드 확인 |
| **placeholder** | 300KB | 200KB 이하 | `bytes` 필드 확인 |
| **chrome**      | 120KB | 30KB 이하  | `bytes` 필드 확인 |

### 1.2 총합 예산

| 항목     | 값                                  |
| -------- | ----------------------------------- |
| **상한** | 1.5MB (1,572,864 bytes)             |
| **권장** | 1MB (1,048,576 bytes) 이하          |
| **현재** | `manifest.json`의 `totalBytes` 확인 |

### 1.3 용량 초과 시 대응

1. **압축/최적화**: TinyPNG, ImageMagick, WebP 변환
2. **해상도/색상 축소**: 필요 사이즈만 유지
3. **불필요 에셋 제거**: 사용처 없는 에셋 정리
4. **예산 상향**: 근거 문서화 후 `budgetBytes` 조정

---

## 2. 사이즈/규격 (Size)

### 2.1 아이콘 사이즈 체크

| 항목            | 요구                 | 체크 |
| --------------- | -------------------- | ---- |
| **필수 사이즈** | 16px, 24px 최소 2종  | ☐    |
| **선택 사이즈** | 32px, 64px (필요 시) | ☐    |
| **정방형**      | 가로 = 세로          | ☐    |

### 2.2 16px 실루엣 테스트 ⚠️

> **중요**: 16px에서도 형태가 구분되어야 합니다.

**테스트 방법**:

1. 16px 아이콘을 100% 배율로 표시
2. 2m 거리에서 형태 구분 가능 여부 확인
3. 다른 아이콘과 혼동되지 않는지 확인

**실패 시 대응**:

- 디테일 단순화
- 외곽선/실루엣 강화
- 16px/24px 별도 디자인 (사용처 분리)

### 2.3 placeholder/chrome 사이즈

| 항목            | 권장                     | 비고               |
| --------------- | ------------------------ | ------------------ |
| **placeholder** | 512x384 또는 용도별 적정 | 가로세로 비율 유지 |
| **chrome**      | 타일링 가능 사이즈       | 48px, 64px 등      |

---

## 3. 대비/가독성 (Contrast)

### 3.1 기본 대비 테스트

| 모드         | 배경                    | 요구 대비               | 체크 |
| ------------ | ----------------------- | ----------------------- | ---- |
| **기본**     | `#0d0d0d` (어두운 배경) | 인광 녹색(#33ff00) 대비 | ☐    |
| **Readable** | 대비 강화 모드          | 4.5:1 이상              | ☐    |

### 3.2 대비 검증 방법

```
도구: WebAIM Contrast Checker
URL: https://webaim.org/resources/contrastchecker/

전경색: 아이콘 주요 색상
배경색: #0d0d0d (CRT 배경)
목표: 4.5:1 이상 (AA 기준)
```

### 3.3 Readable 모드 호환

- [ ] CRT 글로우/스캔라인 OFF 시에도 식별 가능
- [ ] 텍스트 라벨이 이미지를 방해하지 않음
- [ ] 색약/색맹 접근성 고려 (색상만으로 의미 전달 금지)

---

## 4. 투명 배경 (Alpha Channel)

### 4.1 투명 배경 필요 여부

| 유형            | 투명 필수 | 배경 색상        |
| --------------- | --------- | ---------------- |
| **아이콘**      | ✅ 필수   | 투명 (알파 채널) |
| **placeholder** | ❌ 선택   | 불투명 허용      |
| **chrome**      | ✅ 필수   | 투명 (알파 채널) |

### 4.2 배경 제거 체크 (rembg)

> **참조**: `vibe/ref/rembg-guide.md`

**생성 단계 요구 (조건부)**:

- [ ] 배경 제거 예정인 에셋은 **순백(#FFFFFF) 단색 배경**으로 생성
- [ ] 그라데이션/텍스처/그림자 배경 금지

**배경 제거 실행**:

- [ ] `rembg i -m birefnet-general <input> <output>` 실행
- [ ] 알파 채널 존재 확인 (GIMP/Photoshop/Preview)
- [ ] 경계 부분 잔여 배경 없음 확인

### 4.3 투명도 검증 명령어

```bash
# ImageMagick으로 알파 채널 확인
magick identify -verbose <image.png> | grep -i alpha

# 또는 파일 정보 확인 (PNG 포맷)
file <image.png>  # PNG image data, ... RGBA
```

---

## 5. 폴백 (Fallback)

### 5.1 폴백 텍스트/이모지 체크

| 체크 항목         | 요구  | 설명                               |
| ----------------- | ----- | ---------------------------------- |
| **fallback 필드** | 필수  | manifest.json에 `fallback` 값 존재 |
| **이모지/텍스트** | 1~2자 | 예: `📡`, `⚠`, `✓`, `OK`           |
| **의미 전달**     | 명확  | 원본 아이콘과 동일한 의미          |

### 5.2 폴백 동작 테스트

**테스트 시나리오**:

1. 에셋 파일을 임시로 삭제/이름 변경
2. 브라우저에서 UI 로드
3. 폴백 텍스트/이모지가 표시되는지 확인
4. UI가 깨지지 않는지 확인

**코드 구현 확인**:

```tsx
// 예상 패턴
<img
  src="/ui/icons/signal-24.png"
  alt=""
  aria-hidden="true"
  onError={(e) => (e.currentTarget.style.display = 'none')}
/>
<span className="icon-fallback">📡</span>
```

---

## 6. 매니페스트 동기화 (manifest.json)

### 6.1 필수 필드 체크

| 필드       | 필수 | 체크                              |
| ---------- | ---- | --------------------------------- |
| `id`       | ✅   | kebab-case, 고유값                |
| `path`     | ✅   | `ui/` 기준 상대 경로              |
| `type`     | ✅   | `icon` / `placeholder` / `chrome` |
| `fallback` | 권장 | 이모지/텍스트                     |
| `bytes`    | 권장 | 파일 크기                         |
| `usedIn`   | 권장 | 사용처 컴포넌트 목록              |
| `notes`    | 선택 | QA/생성 관련 메모                 |

### 6.2 실제 파일과 매니페스트 정합성

- [ ] manifest.json의 모든 에셋이 실제 파일로 존재
- [ ] 실제 디렉토리의 모든 에셋이 manifest.json에 등록됨
- [ ] `path` 경로가 실제 파일 위치와 일치
- [ ] `bytes` 값이 실제 파일 크기와 일치

### 6.3 정합성 검증 스크립트 (참고)

```bash
# manifest.json에 있는 path들이 실제로 존재하는지 확인
cd frontend/public/ui
cat manifest.json | jq -r '.assets[].path' | while read p; do
  [ -f "$p" ] || echo "MISSING: $p"
done

# 실제 파일이 manifest에 있는지 확인
find icons placeholders chrome -type f \( -name "*.png" -o -name "*.webp" \) | while read f; do
  grep -q "\"$f\"" manifest.json || echo "NOT IN MANIFEST: $f"
done
```

---

## 7. 스타일 일관성 (CRT Theme)

### 7.1 색상 팔레트 준수

| 색상        | Hex       | 용도        | 체크 |
| ----------- | --------- | ----------- | ---- |
| 인광 녹색   | `#33ff00` | 주요 색상   | ☐    |
| 어두운 녹색 | `#1a8000` | 보조 색상   | ☐    |
| 마젠타      | `#ff00ff` | 포인트/경고 | ☐    |
| 주황색      | `#ffaa00` | 경고        | ☐    |
| 붉은색      | `#ff3333` | 에러        | ☐    |
| 배경        | `#0d0d0d` | 배경        | ☐    |

### 7.2 스타일 금지 사항

- [ ] 외부 로고/상표 복제 금지
- [ ] CRT 테마와 충돌하는 색상 금지 (밝은 파스텔, 난색 남용)
- [ ] 복잡한 그라데이션/사진 스타일 금지

---

## 8. Retina 대응 (선택)

### 8.1 Retina 필요 여부 판단

| 상황             | Retina 필요 | 비고                  |
| ---------------- | ----------- | --------------------- |
| **16px 아이콘**  | 선택        | HiDPI에서 선명도 향상 |
| **24px+ 아이콘** | 낮음        | 기본 해상도로 충분    |
| **placeholder**  | 낮음        | 이미 충분한 해상도    |

### 8.2 Retina 파일 규칙

- 파일명: `{name}-24.png` → `{name}-24@2x.png`
- CSS: `image-set()`으로 1x/2x 제공
- manifest.json: `retina: true` 표기

---

## 9. 종합 체크리스트 (Quick Reference)

에셋 추가/수정 시 아래 항목을 순서대로 체크하세요:

### 📦 추가 전

- [ ] 네이밍 규칙 준수 (`kebab-case` + 용도 + 크기)
- [ ] 포맷 규칙 준수 (아이콘=PNG, placeholder=WebP)
- [ ] CRT 테마 색상과 조화

### 🎨 생성 시

- [ ] (조건부) 배경 제거 필요 시 순백(#FFFFFF) 배경으로 생성
- [ ] 필요 사이즈로 리사이즈
- [ ] (조건부) `rembg`로 배경 제거

### ✅ 추가 후

- [ ] 개별 용량 예산 준수 확인
- [ ] 총합 예산 준수 확인 (`totalBytes` < `budgetBytes`)
- [ ] 16px 실루엣 구분 가능 여부 (아이콘)
- [ ] 기본/Readable 모드 대비 확인
- [ ] (조건부) 알파 채널 존재 확인 (투명 필요 에셋)
- [ ] 폴백 텍스트/이모지 지정
- [ ] manifest.json 업데이트
- [ ] 실제 파일과 매니페스트 정합성 확인

---

## 10. 참고 자료

- **SSOT 규칙**: `frontend/public/ui/README.md`
- **배경 제거 가이드**: `vibe/ref/rembg-guide.md`
- **매니페스트 스키마**: `frontend/public/ui/manifest.schema.json`
- **스타일 가이드**: `vibe/ref/frontend-style-guide.md`
- **가독성 패스**: U-028[Mvp] (Readable 모드)

---

_마지막 업데이트: 2026-01-12_  
_문서 버전: 1.0.0_
</file>

<file path="frontend/src/components/SceneCanvas.test.tsx">
import { describe, it, expect } from 'vitest';
import { SCENE_PLACEHOLDERS } from './SceneCanvas';

describe('SCENE_PLACEHOLDERS', () => {
  it('should have all required statuses', () => {
    const statuses = ['default', 'loading', 'offline', 'blocked', 'low_signal'];
    statuses.forEach((status) => {
      expect(SCENE_PLACEHOLDERS).toHaveProperty(status);
    });
  });

  it('should have correct image paths', () => {
    expect(SCENE_PLACEHOLDERS.default.imagePath).toBe(
      '/ui/placeholders/scene-placeholder-default.png',
    );
    expect(SCENE_PLACEHOLDERS.loading.imagePath).toBe('/ui/placeholders/scene-loading.webp');
    expect(SCENE_PLACEHOLDERS.offline.imagePath).toBe('/ui/placeholders/scene-offline.webp');
    expect(SCENE_PLACEHOLDERS.blocked.imagePath).toBe('/ui/placeholders/scene-blocked.webp');
    expect(SCENE_PLACEHOLDERS.low_signal.imagePath).toBe('/ui/placeholders/scene-low-signal.webp');
  });

  it('should have correct i18n label keys', () => {
    expect(SCENE_PLACEHOLDERS.default.labelKey).toBe('scene.status.default');
    expect(SCENE_PLACEHOLDERS.loading.labelKey).toBe('scene.status.loading');
    expect(SCENE_PLACEHOLDERS.offline.labelKey).toBe('scene.status.offline');
    expect(SCENE_PLACEHOLDERS.blocked.labelKey).toBe('scene.status.blocked');
    expect(SCENE_PLACEHOLDERS.low_signal.labelKey).toBe('scene.status.low_signal');
  });
});
</file>

<file path="frontend/src/components/SceneCanvas.tsx">
import { useState } from 'react';
import { useTranslation } from 'react-i18next';
import type { SceneCanvasStatus, SceneCanvasState, PlaceholderInfo } from '../types/scene';

/**
 * 상태별 placeholder 정보 (U-031: Placeholder Pack)
 * labelKey는 i18n 번역 키로 사용됩니다.
 */
export const SCENE_PLACEHOLDERS: Record<Exclude<SceneCanvasStatus, 'scene'>, PlaceholderInfo> = {
  default: {
    imagePath: '/ui/placeholders/scene-placeholder-default.png',
    fallbackEmoji: '📡',
    labelKey: 'scene.status.default',
  },
  loading: {
    imagePath: '/ui/placeholders/scene-loading.webp',
    fallbackEmoji: '⏳',
    labelKey: 'scene.status.loading',
  },
  offline: {
    imagePath: '/ui/placeholders/scene-offline.webp',
    fallbackEmoji: '🔌',
    labelKey: 'scene.status.offline',
  },
  blocked: {
    imagePath: '/ui/placeholders/scene-blocked.webp',
    fallbackEmoji: '🚫',
    labelKey: 'scene.status.blocked',
  },
  low_signal: {
    imagePath: '/ui/placeholders/scene-low-signal.webp',
    fallbackEmoji: '📉',
    labelKey: 'scene.status.low_signal',
  },
};

interface SceneCanvasProps {
  state: SceneCanvasState;
}

/**
 * Scene Canvas 컴포넌트 (U-031: Placeholder Pack)
 *
 * - 상태에 따라 placeholder 이미지와 라벨을 표시합니다.
 * - 'scene' 상태에서는 실제 이미지를 렌더링하며, 로드 실패 시 폴백을 제공합니다.
 */
export function SceneCanvas({ state }: SceneCanvasProps) {
  const { status, imageUrl, message } = state;
  const [imageError, setImageError] = useState(false);
  const { t } = useTranslation();

  // 정상 장면 표시 중이거나 이미지 에러가 발생한 경우
  const isSceneActive = status === 'scene' && imageUrl && !imageError;

  // placeholder 정보 결정 (scene 상태에서 에러 시 default로 폴백)
  const effectiveStatus = status === 'scene' && imageError ? 'default' : status;
  const isPlaceholderVisible = effectiveStatus !== 'scene';

  const placeholder = isPlaceholderVisible
    ? SCENE_PLACEHOLDERS[effectiveStatus as Exclude<SceneCanvasStatus, 'scene'>]
    : null;

  return (
    <div
      className={`scene-canvas ${isSceneActive ? 'scene-active' : `scene-status-${effectiveStatus}`}`}
      style={placeholder ? { backgroundImage: `url('${placeholder.imagePath}')` } : {}}
    >
      {isSceneActive && (
        <img
          src={imageUrl}
          alt="Scene"
          className="scene-image"
          onError={() => setImageError(true)}
        />
      )}

      {isPlaceholderVisible && placeholder && (
        <div className="scene-placeholder">
          {/* 텍스트 폴백 (이미지 로드 실패 시에도 표시) */}
          <p className="text-glow scene-status-label">
            <span className="scene-status-emoji" aria-hidden="true">
              {placeholder.fallbackEmoji}
            </span>{' '}
            {t(placeholder.labelKey)}
          </p>
          {(message || (status === 'scene' && imageError)) && (
            <p className="text-dim scene-status-message" style={{ fontSize: '0.875rem' }}>
              {message || (imageError ? t('scene.status.image_error') : '')}
            </p>
          )}
        </div>
      )}
    </div>
  );
}
</file>

<file path="frontend/src/i18n.ts">
import i18n from 'i18next';
import { initReactI18next } from 'react-i18next';

// i18n 리소스 정의 (RULE-006 준수)
const resources = {
  ko: {
    translation: {
      scene: {
        status: {
          default: '데이터 대기 중',
          loading: '동기화 중...',
          offline: '연결 끊김',
          blocked: '접근 제한됨',
          low_signal: '신호 약함',
          image_error: '장면 이미지를 불러올 수 없습니다.',
        },
      },
      agent: {
        console: {
          queue: '대기열',
          badges: '검증 배지',
          repair: '자동 복구',
          status: {
            idle: '대기 중',
            processing: '처리 중',
          },
          badges_empty: '[ 검증 대기 중 ]',
          repaired: '(복구됨)',
        },
      },
      ui: {
        command_placeholder: '명령을 입력하세요...',
        processing: '처리 중...',
        execute: '실행',
        wait: '대기',
      },
    },
  },
  en: {
    translation: {
      scene: {
        status: {
          default: 'NO SIGNAL DATA',
          loading: 'SYNCHRONIZING...',
          offline: 'CONNECTION LOST',
          blocked: 'ACCESS RESTRICTED',
          low_signal: 'LOW SIGNAL',
          image_error: 'Unable to load scene image.',
        },
      },
      agent: {
        console: {
          queue: 'Queue',
          badges: 'Badges',
          repair: 'Auto-repair',
          status: {
            idle: 'IDLE',
            processing: 'PROCESSING',
          },
          badges_empty: '[ Awaiting Validation ]',
          repaired: '(Repaired)',
        },
      },
      ui: {
        command_placeholder: 'Enter command...',
        processing: 'Processing...',
        execute: 'EXECUTE',
        wait: 'WAIT',
      },
    },
  },
};

i18n.use(initReactI18next).init({
  resources,
  lng: 'ko', // 기본 언어
  fallbackLng: 'en',
  interpolation: {
    escapeValue: false,
  },
});

export default i18n;
</file>

<file path="frontend/src/schemas/index.ts">
/**
 * Unknown World - 스키마 모듈 진입점.
 *
 * TurnInput/TurnOutput Zod 스키마 및 관련 유틸리티를 재내보내기합니다.
 *
 * @module schemas
 */

// =============================================================================
// 스키마 버전
// =============================================================================

export { SCHEMA_VERSION } from './turn';

// =============================================================================
// Enum 스키마 및 타입
// =============================================================================

export {
  LanguageSchema,
  ThemeSchema,
  AgentPhaseSchema,
  ValidationBadgeSchema,
  ModelLabelSchema,
  RiskLevelSchema,
} from './turn';

export type { Language, Theme, AgentPhase, ValidationBadge, ModelLabel, RiskLevel } from './turn';

// =============================================================================
// 공통 하위 타입 스키마 및 타입
// =============================================================================

export { CoordinateSchema, Box2DSchema, CurrencyAmountSchema } from './turn';

export type { Coordinate, Box2D, CurrencyAmount } from './turn';

// =============================================================================
// TurnInput 관련 스키마 및 타입
// =============================================================================

export { ClickInputSchema, ClientInfoSchema, EconomySnapshotSchema, TurnInputSchema } from './turn';

export type { ClickInput, ClientInfo, EconomySnapshot, TurnInput } from './turn';

// =============================================================================
// TurnOutput 관련 스키마 및 타입
// =============================================================================

export {
  // UI
  ActionCardSchema,
  SceneObjectSchema,
  ActionDeckSchema,
  UIOutputSchema,
  // World
  MemoryPinSchema,
  WorldRuleSchema,
  QuestSchema,
  WorldDeltaSchema,
  // Render
  ImageJobSchema,
  RenderOutputSchema,
  // Economy
  EconomyOutputSchema,
  // Safety
  SafetyOutputSchema,
  // Agent Console
  AgentConsoleSchema,
  // Main
  TurnOutputSchema,
} from './turn';

export type {
  // UI
  ActionCard,
  SceneObject,
  ActionDeck,
  UIOutput,
  // World
  MemoryPin,
  WorldRule,
  Quest,
  WorldDelta,
  // Render
  ImageJob,
  RenderOutput,
  // Economy
  EconomyOutput,
  // Safety
  SafetyOutput,
  // Agent Console
  AgentConsole,
  // Main
  TurnOutput,
} from './turn';

// =============================================================================
// 유틸리티 함수
// =============================================================================

export {
  createFallbackTurnOutput,
  safeParseTurnOutput,
  parseTurnInput,
  safeParseTurnInput,
} from './turn';

export type { TurnOutputParseResult, TurnInputSafeParseResult } from './turn';
</file>

<file path="frontend/src/schemas/turn.test.ts">
import { describe, it, expect } from 'vitest';
import {
  TurnInputSchema,
  TurnOutputSchema,
  safeParseTurnOutput,
  parseTurnInput,
  safeParseTurnInput,
  SCHEMA_VERSION,
} from './turn';

describe('Turn schemas', () => {
  describe('SCHEMA_VERSION', () => {
    it('should have correct version', () => {
      expect(SCHEMA_VERSION).toBe('1.0.0');
    });
  });

  describe('TurnInputSchema', () => {
    const validTurnInput = {
      language: 'ko-KR',
      text: '테스트 입력',
      client: {
        viewport_w: 1920,
        viewport_h: 1080,
        theme: 'dark',
      },
      economy_snapshot: {
        signal: 100,
        memory_shard: 5,
      },
    };

    it('should validate a valid TurnInput', () => {
      const result = TurnInputSchema.safeParse(validTurnInput);
      expect(result.success).toBe(true);
    });

    it('should fail on invalid language', () => {
      const result = TurnInputSchema.safeParse({
        ...validTurnInput,
        language: 'fr-FR',
      });
      expect(result.success).toBe(false);
    });

    it('should fail on negative economy values', () => {
      const result = TurnInputSchema.safeParse({
        ...validTurnInput,
        economy_snapshot: {
          signal: -1,
          memory_shard: 0,
        },
      });
      expect(result.success).toBe(false);
    });

    it('should fail on extra fields (strict)', () => {
      const result = TurnInputSchema.safeParse({
        ...validTurnInput,
        extra_field: 'not allowed',
      });
      expect(result.success).toBe(false);
    });

    it('should validate click input with bbox', () => {
      const result = TurnInputSchema.safeParse({
        ...validTurnInput,
        click: {
          object_id: 'door_01',
          box_2d: {
            ymin: 100,
            xmin: 100,
            ymax: 500,
            xmax: 500,
          },
        },
      });
      expect(result.success).toBe(true);
    });

    it('should fail on invalid bbox coordinates (out of range 0-1000)', () => {
      const result = TurnInputSchema.safeParse({
        ...validTurnInput,
        click: {
          object_id: 'door_01',
          box_2d: {
            ymin: -1,
            xmin: 0,
            ymax: 1001,
            xmax: 500,
          },
        },
      });
      expect(result.success).toBe(false);
    });

    it('should fail on non-positive viewport dimensions', () => {
      const result = TurnInputSchema.safeParse({
        ...validTurnInput,
        client: {
          viewport_w: 0,
          viewport_h: -100,
          theme: 'dark',
        },
      });
      expect(result.success).toBe(false);
    });

    it('should fail on non-integer coordinates', () => {
      const result = TurnInputSchema.safeParse({
        ...validTurnInput,
        click: {
          object_id: 'obj',
          box_2d: {
            ymin: 10.5,
            xmin: 20,
            ymax: 30,
            xmax: 40,
          },
        },
      });
      expect(result.success).toBe(false);
    });
  });

  describe('TurnOutputSchema', () => {
    const validTurnOutput = {
      language: 'ko-KR',
      narrative: '테스트 내러티브',
      economy: {
        cost: { signal: 5, memory_shard: 0 },
        balance_after: { signal: 95, memory_shard: 5 },
      },
      safety: {
        blocked: false,
      },
      agent_console: {
        current_phase: 'commit',
        badges: ['schema_ok', 'economy_ok'],
        repair_count: 0,
      },
    };

    it('should validate a valid TurnOutput', () => {
      const result = TurnOutputSchema.safeParse(validTurnOutput);
      expect(result.success).toBe(true);
    });

    it('should fail if required fields are missing', () => {
      const { narrative: _narrative, ...invalidOutput } = validTurnOutput;
      const result = TurnOutputSchema.safeParse(invalidOutput);
      expect(result.success).toBe(false);
    });

    it('should handle default values for optional fields', () => {
      const result = TurnOutputSchema.safeParse(validTurnOutput);
      if (result.success) {
        expect(result.data.ui).toBeDefined();
        expect(result.data.ui.action_deck.cards).toEqual([]);
        expect(result.data.world.rules_changed).toEqual([]);
      } else {
        throw new Error('Validation failed');
      }
    });

    it('should fail if there are too many action cards (max 10)', () => {
      const cards = Array.from({ length: 11 }, (_, i) => ({
        id: `card_${i}`,
        label: `Card ${i}`,
        cost: { signal: 0, memory_shard: 0 },
        risk: 'low',
      }));
      const result = TurnOutputSchema.safeParse({
        ...validTurnOutput,
        ui: {
          action_deck: { cards },
        },
      });
      expect(result.success).toBe(false);
    });

    it('should fail on negative repair_count', () => {
      const result = TurnOutputSchema.safeParse({
        ...validTurnOutput,
        agent_console: {
          current_phase: 'commit',
          badges: [],
          repair_count: -1,
        },
      });
      expect(result.success).toBe(false);
    });
  });

  describe('safeParseTurnOutput', () => {
    it('should return success for valid data', () => {
      const validTurnOutput = {
        language: 'en-US',
        narrative: 'Test narrative',
        economy: {
          cost: { signal: 0, memory_shard: 0 },
          balance_after: { signal: 100, memory_shard: 0 },
        },
        safety: { blocked: false },
      };
      const result = safeParseTurnOutput(validTurnOutput);
      expect(result.success).toBe(true);
      if (result.success) {
        expect(result.data.language).toBe('en-US');
      }
    });

    it('should return fallback for invalid data', () => {
      const invalidData = { some: 'garbage' };
      const result = safeParseTurnOutput(invalidData, 'ko-KR', 1);
      expect(result.success).toBe(false);
      if (!result.success) {
        expect(result.fallback).toBeDefined();
        expect(result.fallback.language).toBe('ko-KR');
        expect(result.fallback.agent_console.badges).toContain('schema_fail');
        expect(result.fallback.agent_console.repair_count).toBe(1);
      }
    });
  });

  describe('Input Parsing Utilities', () => {
    const validTurnInput = {
      language: 'ko-KR',
      text: '테스트 입력',
      client: {
        viewport_w: 1920,
        viewport_h: 1080,
        theme: 'dark',
      },
      economy_snapshot: {
        signal: 100,
        memory_shard: 5,
      },
    };

    describe('parseTurnInput', () => {
      it('should parse valid input', () => {
        const result = parseTurnInput(validTurnInput);
        expect(result.text).toBe('테스트 입력');
      });

      it('should throw error for invalid input', () => {
        expect(() => parseTurnInput({})).toThrow();
      });
    });

    describe('safeParseTurnInput', () => {
      it('should return success for valid input', () => {
        const result = safeParseTurnInput(validTurnInput);
        expect(result.success).toBe(true);
      });

      it('should return failure for invalid input', () => {
        const result = safeParseTurnInput({});
        expect(result.success).toBe(false);
      });
    });
  });
});
</file>

<file path="frontend/src/schemas/turn.ts">
/**
 * Unknown World - TurnInput/TurnOutput Zod 스키마.
 *
 * 이 모듈은 백엔드 Pydantic 모델(U-005)과 1:1 대응하는 Zod 스키마를 정의합니다.
 * 클라이언트 측 검증 및 타입 안전성을 제공합니다.
 *
 * 설계 원칙:
 *   - RULE-003: 구조화 출력(JSON Schema) 우선 + 이중 검증 (서버 Pydantic + 클라 Zod)
 *   - RULE-004: 검증 실패 시 안전 폴백 제공 (UI 멈춤 방지)
 *   - RULE-005: 재화 인바리언트 (cost, balance_after 필수, 잔액 음수 금지)
 *   - RULE-006: ko/en 언어 정책 (Language enum으로 고정)
 *   - RULE-009: 좌표 규약 (0~1000, bbox [ymin,xmin,ymax,xmax])
 *
 * Q1 결정 사항:
 *   - schema_version 포함 (Option A): SaveGame/마이그레이션/검증에 유리
 *
 * @module schemas/turn
 */

import { z } from 'zod';

// =============================================================================
// 스키마 버전 (Q1 결정: Option A - 포함)
// =============================================================================

/**
 * 현재 스키마 버전.
 * SaveGame/마이그레이션/검증에 사용됩니다.
 */
export const SCHEMA_VERSION = '1.0.0' as const;

// =============================================================================
// 공통 Enum 타입
// =============================================================================

/**
 * 지원 언어 (RULE-006).
 * ko/en 혼합 출력 금지. TurnInput.language를 SSOT로 삼아
 * 모든 UI/내러티브/시스템 메시지는 동일 언어로 고정합니다.
 */
export const LanguageSchema = z.enum(['ko-KR', 'en-US']);
export type Language = z.infer<typeof LanguageSchema>;

/**
 * 테마 설정.
 */
export const ThemeSchema = z.enum(['dark', 'light']);
export type Theme = z.infer<typeof ThemeSchema>;

/**
 * 에이전트 실행 단계 (RULE-008).
 * 에이전트형 시스템임을 UI로 증명하기 위한 단계 표시.
 */
export const AgentPhaseSchema = z.enum([
  'parse',
  'validate',
  'plan',
  'resolve',
  'render',
  'verify',
  'commit',
]);
export type AgentPhase = z.infer<typeof AgentPhaseSchema>;

/**
 * 검증 배지 (RULE-008).
 * 턴 결과에 대한 검증 상태를 표시합니다.
 */
export const ValidationBadgeSchema = z.enum([
  'schema_ok',
  'schema_fail',
  'economy_ok',
  'economy_fail',
  'safety_ok',
  'safety_blocked',
  'consistency_ok',
  'consistency_fail',
]);
export type ValidationBadge = z.infer<typeof ValidationBadgeSchema>;

/**
 * 모델/품질 선택 라벨 (RULE-008).
 * 프롬프트 노출 없이 "왜 이 선택이었는지"를 사용자 친화 라벨로 표시.
 */
export const ModelLabelSchema = z.enum(['FAST', 'QUALITY', 'CHEAP', 'REF']);
export type ModelLabel = z.infer<typeof ModelLabelSchema>;

/**
 * 행동 위험도 수준.
 */
export const RiskLevelSchema = z.enum(['low', 'medium', 'high']);
export type RiskLevel = z.infer<typeof RiskLevelSchema>;

// =============================================================================
// 공통 하위 타입
// =============================================================================

/**
 * 정규화 좌표 (RULE-009).
 * 0~1000 범위의 정수입니다.
 */
export const CoordinateSchema = z.number().int().min(0).max(1000).describe('정규화 좌표 (0~1000)');
export type Coordinate = z.infer<typeof CoordinateSchema>;

/**
 * 2D 바운딩 박스 (RULE-009).
 * 좌표는 0~1000 정규화 좌표계이며, bbox는 [ymin, xmin, ymax, xmax] 순서입니다.
 * 이미지 이해 bbox 포맷과 호환됩니다.
 */
export const Box2DSchema = z
  .object({
    ymin: CoordinateSchema.describe('Y 최소값 (상단)'),
    xmin: CoordinateSchema.describe('X 최소값 (좌측)'),
    ymax: CoordinateSchema.describe('Y 최대값 (하단)'),
    xmax: CoordinateSchema.describe('X 최대값 (우측)'),
  })
  .strict();
export type Box2D = z.infer<typeof Box2DSchema>;

/**
 * 재화 수량.
 * signal과 memory_shard는 0 이상이어야 합니다 (RULE-005).
 */
export const CurrencyAmountSchema = z
  .object({
    signal: z.number().int().min(0).describe('시그널 (기본 재화, 0 이상)'),
    memory_shard: z.number().int().min(0).describe('기억 파편 (희귀 재화, 0 이상)'),
  })
  .strict();
export type CurrencyAmount = z.infer<typeof CurrencyAmountSchema>;

// =============================================================================
// TurnInput 관련 타입
// =============================================================================

/**
 * 클릭 입력 정보.
 * 화면 오브젝트 클릭 시 전달되는 정보입니다.
 */
export const ClickInputSchema = z
  .object({
    object_id: z.string().describe('클릭한 오브젝트 ID'),
    box_2d: Box2DSchema.nullable().default(null).describe('클릭 위치 바운딩 박스 (선택)'),
  })
  .strict();
export type ClickInput = z.infer<typeof ClickInputSchema>;

/**
 * 클라이언트 정보.
 */
export const ClientInfoSchema = z
  .object({
    viewport_w: z.number().int().positive().describe('뷰포트 너비 (픽셀, 양수)'),
    viewport_h: z.number().int().positive().describe('뷰포트 높이 (픽셀, 양수)'),
    theme: ThemeSchema.default('dark').describe('현재 테마'),
  })
  .strict();
export type ClientInfo = z.infer<typeof ClientInfoSchema>;

/**
 * 재화 스냅샷 (클라이언트 → 서버).
 * 클라이언트가 보유한 현재 재화 상태입니다.
 */
export const EconomySnapshotSchema = z
  .object({
    signal: z.number().int().min(0).describe('현재 시그널 잔액 (0 이상)'),
    memory_shard: z.number().int().min(0).describe('현재 기억 파편 잔액 (0 이상)'),
  })
  .strict();
export type EconomySnapshot = z.infer<typeof EconomySnapshotSchema>;

/**
 * 턴 입력 (클라이언트 → 서버).
 * 사용자가 턴을 진행할 때 서버로 전송하는 입력 데이터입니다.
 */
export const TurnInputSchema = z
  .object({
    language: LanguageSchema.describe('요청 언어 (응답도 동일 언어로 고정)'),
    text: z.string().default('').describe('사용자 자연어 입력'),
    click: ClickInputSchema.nullable().default(null).describe('오브젝트 클릭 정보 (선택)'),
    client: ClientInfoSchema.describe('클라이언트 환경 정보'),
    economy_snapshot: EconomySnapshotSchema.describe('현재 재화 상태'),
  })
  .strict();
export type TurnInput = z.infer<typeof TurnInputSchema>;

// =============================================================================
// TurnOutput 관련 타입 - UI
// =============================================================================

/**
 * 액션 카드 (Action Deck).
 * 매 턴 AI가 추천하는 행동 카드입니다.
 */
export const ActionCardSchema = z
  .object({
    id: z.string().describe('카드 고유 ID'),
    label: z.string().describe('카드 라벨 (표시용)'),
    description: z.string().nullable().default(null).describe('카드 설명 (선택)'),
    cost: CurrencyAmountSchema.describe('예상 비용'),
    risk: RiskLevelSchema.default('low').describe('위험도'),
    hint: z.string().nullable().default(null).describe('예상 결과 힌트 (선택)'),
  })
  .strict();
export type ActionCard = z.infer<typeof ActionCardSchema>;

/**
 * 장면 오브젝트 (클릭 가능한 핫스팟).
 * 좌표는 0~1000 정규화 좌표계를 사용합니다 (RULE-009).
 */
export const SceneObjectSchema = z
  .object({
    id: z.string().describe('오브젝트 고유 ID'),
    label: z.string().describe('오브젝트 라벨 (표시용)'),
    box_2d: Box2DSchema.describe('바운딩 박스'),
    interaction_hint: z.string().nullable().default(null).describe('상호작용 힌트 (선택)'),
  })
  .strict();
export type SceneObject = z.infer<typeof SceneObjectSchema>;

/**
 * 액션 덱 (Q1 결정: ui.action_deck.cards[] 구조).
 * 매 턴 AI가 제시하는 추천 행동 카드 덱입니다.
 */
export const ActionDeckSchema = z
  .object({
    cards: z.array(ActionCardSchema).max(10).default([]).describe('액션 카드 목록 (3~6장 권장)'),
  })
  .strict();
export type ActionDeck = z.infer<typeof ActionDeckSchema>;

/**
 * UI 출력 데이터.
 * AI가 생성한 UI 요소들입니다.
 * 채팅 버블이 아닌 게임 UI로 표현됩니다 (RULE-002).
 */
export const UIOutputSchema = z
  .object({
    action_deck: ActionDeckSchema.default({ cards: [] }).describe('액션 카드 덱'),
    objects: z.array(SceneObjectSchema).default([]).describe('클릭 가능한 장면 오브젝트 목록'),
  })
  .strict();
export type UIOutput = z.infer<typeof UIOutputSchema>;

// =============================================================================
// TurnOutput 관련 타입 - World
// =============================================================================

/**
 * 중요 설정 고정 후보.
 * 사용자가 Memory Shard를 소비해 고정할 수 있는 중요 설정입니다.
 */
export const MemoryPinSchema = z
  .object({
    id: z.string().describe('핀 고유 ID'),
    content: z.string().describe('고정할 내용'),
    cost: CurrencyAmountSchema.describe('고정에 필요한 비용'),
  })
  .strict();
export type MemoryPin = z.infer<typeof MemoryPinSchema>;

/**
 * 세계 규칙 (Rule Board).
 * 현재 세계에 적용 중인 물리 법칙이나 메타 규칙입니다.
 */
export const WorldRuleSchema = z
  .object({
    id: z.string().describe('규칙 고유 ID'),
    label: z.string().describe('규칙 이름'),
    description: z.string().nullable().default(null).describe('규칙 상세 설명 (선택)'),
  })
  .strict();
export type WorldRule = z.infer<typeof WorldRuleSchema>;

/**
 * 퀘스트/목표 (Quest Panel).
 * 플레이어가 달성해야 하는 현재 목표입니다.
 */
export const QuestSchema = z
  .object({
    id: z.string().describe('퀘스트 고유 ID'),
    label: z.string().describe('퀘스트 이름'),
    is_completed: z.boolean().default(false).describe('달성 여부'),
  })
  .strict();
export type Quest = z.infer<typeof QuestSchema>;

/**
 * 세계 상태 변화 (Q2 결정: Option A - delta 중심).
 * 이번 턴에서 변경된 세계 상태를 나타냅니다.
 */
export const WorldDeltaSchema = z
  .object({
    rules_changed: z.array(WorldRuleSchema).default([]).describe('변경된 규칙 목록'),
    inventory_added: z.array(z.string()).default([]).describe('추가된 인벤토리 아이템'),
    inventory_removed: z.array(z.string()).default([]).describe('제거된 인벤토리 아이템'),
    quests_updated: z.array(QuestSchema).default([]).describe('업데이트된 퀘스트/목표 목록'),
    relationships_changed: z.array(z.string()).default([]).describe('변경된 관계'),
    memory_pins: z.array(MemoryPinSchema).default([]).describe('중요 설정 고정 후보'),
  })
  .strict();
export type WorldDelta = z.infer<typeof WorldDeltaSchema>;

// =============================================================================
// TurnOutput 관련 타입 - Render
// =============================================================================

/**
 * 이미지 생성 작업.
 * 조건부 이미지 생성/편집 요청입니다.
 */
export const ImageJobSchema = z
  .object({
    should_generate: z.boolean().describe('이미지를 생성해야 하는지'),
    prompt: z.string().default('').describe('이미지 생성 프롬프트'),
    model_label: ModelLabelSchema.default('FAST').describe('모델 선택 라벨'),
    aspect_ratio: z.string().default('16:9').describe('가로세로 비율'),
    image_size: z.string().default('1024x1024').describe('이미지 크기'),
    reference_image_ids: z.array(z.string()).default([]).describe('참조 이미지 ID 목록 (선택)'),
  })
  .strict();
export type ImageJob = z.infer<typeof ImageJobSchema>;

/**
 * 렌더링 출력 데이터.
 * 이미지 생성/편집 관련 정보입니다.
 */
export const RenderOutputSchema = z
  .object({
    image_job: ImageJobSchema.nullable().default(null).describe('이미지 생성 작업 (선택)'),
  })
  .strict();
export type RenderOutput = z.infer<typeof RenderOutputSchema>;

// =============================================================================
// TurnOutput 관련 타입 - Economy
// =============================================================================

/**
 * 경제 출력 데이터 (RULE-005).
 * 이번 턴의 비용과 잔액 정보입니다.
 * 잔액 음수는 절대 불가 (서버 Hard gate).
 */
export const EconomyOutputSchema = z
  .object({
    cost: CurrencyAmountSchema.describe('이번 턴에 소비된 비용'),
    balance_after: CurrencyAmountSchema.describe('소비 후 잔액'),
  })
  .strict();
export type EconomyOutput = z.infer<typeof EconomyOutputSchema>;

// =============================================================================
// TurnOutput 관련 타입 - Safety
// =============================================================================

/**
 * 안전 출력 데이터.
 * 안전 정책 관련 정보입니다.
 * 차단 시 명시적 메시지와 함께 안전한 대체 결과를 제공합니다.
 */
export const SafetyOutputSchema = z
  .object({
    blocked: z.boolean().default(false).describe('안전 정책에 의해 차단되었는지'),
    message: z
      .string()
      .nullable()
      .default(null)
      .describe('차단 시 사용자에게 표시할 메시지 (선택)'),
  })
  .strict();
export type SafetyOutput = z.infer<typeof SafetyOutputSchema>;

// =============================================================================
// TurnOutput 관련 타입 - Agent Console
// =============================================================================

/**
 * 에이전트 콘솔 데이터 (RULE-008).
 * 에이전트형 시스템임을 UI로 증명하기 위한 정보입니다.
 */
export const AgentConsoleSchema = z
  .object({
    current_phase: AgentPhaseSchema.default('commit').describe('현재 실행 단계'),
    badges: z.array(ValidationBadgeSchema).default([]).describe('검증 배지 목록'),
    repair_count: z.number().int().min(0).default(0).describe('자동 복구 시도 횟수'),
  })
  .strict();
export type AgentConsole = z.infer<typeof AgentConsoleSchema>;

// =============================================================================
// TurnOutput (메인 응답 스키마)
// =============================================================================

/**
 * 턴 출력 (서버 → 클라이언트).
 * 서버가 턴 처리 후 클라이언트로 반환하는 구조화된 응답입니다.
 *
 * Hard Gate 필드 (RULE-003/004/005):
 *   - economy: cost와 balance_after 필수, 잔액 음수 금지
 *   - safety: blocked 시 안전한 대체 결과 제공
 *   - language: 요청 언어와 동일하게 고정 (혼합 출력 금지)
 */
export const TurnOutputSchema = z
  .object({
    // 필수 필드 (Hard Gate)
    language: LanguageSchema.describe('응답 언어 (요청과 동일)'),
    narrative: z.string().describe('내러티브 텍스트 (표시용)'),
    economy: EconomyOutputSchema.describe('경제 정보 (비용, 잔액)'),
    safety: SafetyOutputSchema.describe('안전 정책 정보'),

    // UI 관련 필드
    ui: UIOutputSchema.default({ action_deck: { cards: [] }, objects: [] }).describe('UI 요소'),

    // 세계 상태 필드
    world: WorldDeltaSchema.default({
      rules_changed: [],
      inventory_added: [],
      inventory_removed: [],
      quests_updated: [],
      relationships_changed: [],
      memory_pins: [],
    }).describe('세계 상태 변화 (delta)'),

    // 렌더링 필드
    render: RenderOutputSchema.default({ image_job: null }).describe('렌더링 정보'),

    // 에이전트 콘솔 필드
    agent_console: AgentConsoleSchema.default({
      current_phase: 'commit',
      badges: [],
      repair_count: 0,
    }).describe('에이전트 실행 정보'),
  })
  .strict();
export type TurnOutput = z.infer<typeof TurnOutputSchema>;

// =============================================================================
// 안전 폴백 (RULE-004)
// =============================================================================

/**
 * 검증 실패 시 제공되는 안전 폴백 TurnOutput.
 * UI가 멈추지 않도록 최소한의 정보를 제공합니다.
 *
 * @param language - 요청 언어
 * @param repairCount - 복구 시도 횟수
 * @param errorMessage - 오류 메시지 (선택)
 */
export function createFallbackTurnOutput(
  language: Language,
  repairCount: number = 0,
  errorMessage?: string,
): TurnOutput {
  const fallbackNarrative =
    language === 'ko-KR'
      ? '[시스템] 응답을 처리하는 중 문제가 발생했습니다. 다시 시도해 주세요.'
      : '[System] An error occurred while processing the response. Please try again.';

  const safetyMessage =
    language === 'ko-KR'
      ? '스키마 검증 실패로 인한 폴백 응답입니다.'
      : 'This is a fallback response due to schema validation failure.';

  return {
    language,
    narrative: errorMessage ?? fallbackNarrative,
    economy: {
      cost: { signal: 0, memory_shard: 0 },
      balance_after: { signal: 0, memory_shard: 0 },
    },
    safety: {
      blocked: false,
      message: safetyMessage,
    },
    ui: {
      action_deck: { cards: [] },
      objects: [],
    },
    world: {
      rules_changed: [],
      inventory_added: [],
      inventory_removed: [],
      quests_updated: [],
      relationships_changed: [],
      memory_pins: [],
    },
    render: {
      image_job: null,
    },
    agent_console: {
      current_phase: 'commit',
      badges: ['schema_fail'],
      repair_count: repairCount,
    },
  };
}

// =============================================================================
// 검증 헬퍼 함수
// =============================================================================

/**
 * TurnOutput 검증 결과 타입.
 */
export type TurnOutputParseResult =
  | { success: true; data: TurnOutput }
  | { success: false; error: z.ZodError; fallback: TurnOutput };

/**
 * TurnOutput을 안전하게 파싱합니다.
 * 실패 시 폴백 TurnOutput을 반환합니다 (RULE-004).
 *
 * @param data - 파싱할 데이터
 * @param language - 폴백 시 사용할 언어 (기본: ko-KR)
 * @param repairCount - 현재 복구 시도 횟수
 */
export function safeParseTurnOutput(
  data: unknown,
  language: Language = 'ko-KR',
  repairCount: number = 0,
): TurnOutputParseResult {
  const result = TurnOutputSchema.safeParse(data);

  if (result.success) {
    return { success: true, data: result.data };
  }

  return {
    success: false,
    error: result.error,
    fallback: createFallbackTurnOutput(language, repairCount),
  };
}

/**
 * TurnInput을 검증합니다.
 * 입력 데이터의 유효성을 엄격하게 검사합니다.
 *
 * @param data - 검증할 데이터
 * @throws {z.ZodError} 검증 실패 시
 */
export function parseTurnInput(data: unknown): TurnInput {
  return TurnInputSchema.parse(data);
}

/**
 * TurnInput 안전 파싱 결과 타입.
 */
export type TurnInputSafeParseResult = ReturnType<typeof TurnInputSchema.safeParse>;

/**
 * TurnInput을 안전하게 파싱합니다.
 *
 * @param data - 파싱할 데이터
 */
export function safeParseTurnInput(data: unknown): TurnInputSafeParseResult {
  return TurnInputSchema.safeParse(data);
}
</file>

<file path="frontend/src/schemas/verify_runbook.ts">
import {
  TurnOutputSchema,
  safeParseTurnOutput,
  Box2DSchema,
  CurrencyAmountSchema,
  LanguageSchema,
  parseTurnInput,
} from './turn.js';

console.log('--- Scenario A: TurnOutput 스키마 검증 (정상 케이스) ---');
const validOutput = {
  language: 'ko-KR',
  narrative: '문이 삐걱거리며 열립니다...',
  economy: {
    cost: { signal: 5, memory_shard: 0 },
    balance_after: { signal: 95, memory_shard: 5 },
  },
  safety: { blocked: false, message: null },
};
const resultA = safeParseTurnOutput(validOutput);
console.log('Success:', resultA.success);
if (resultA.success) {
  console.log('Data (sample):', resultA.data.narrative);
}

console.log('\n--- Scenario B: TurnOutput 스키마 검증 실패 → 폴백 ---');
const invalidOutput = {
  language: 'ko-KR',
  narrative: '테스트',
};
// eslint-disable-next-line @typescript-eslint/no-explicit-any
const resultB = safeParseTurnOutput(invalidOutput as any);
console.log('Success:', resultB.success);
if (!resultB.success) {
  console.log('Error count:', resultB.error.issues.length);
  console.log('Fallback exists:', !!resultB.fallback);
  console.log(
    'Fallback badges has schema_fail:',
    resultB.fallback?.agent_console?.badges?.includes('schema_fail'),
  );
}

console.log('\n--- Scenario C: 좌표 범위 검증 (RULE-009) ---');
const validBox = { ymin: 100, xmin: 200, ymax: 300, xmax: 400 };
console.log('Valid box:', Box2DSchema.safeParse(validBox).success);
const invalidBox = { ymin: 100, xmin: 200, ymax: 1500, xmax: 400 };
console.log('Invalid box (1500):', Box2DSchema.safeParse(invalidBox).success);
const negativeBox = { ymin: -10, xmin: 200, ymax: 300, xmax: 400 };
console.log('Negative box:', Box2DSchema.safeParse(negativeBox).success);

console.log('\n--- Scenario D: 재화 인바리언트 검증 (RULE-005) ---');
const validCurrency = { signal: 100, memory_shard: 5 };
console.log('Valid currency:', CurrencyAmountSchema.safeParse(validCurrency).success);
const negativeCurrency = { signal: -10, memory_shard: 5 };
console.log('Negative signal:', CurrencyAmountSchema.safeParse(negativeCurrency).success);

console.log('\n--- Scenario E: 언어 정책 검증 (RULE-006) ---');
console.log('ko-KR:', LanguageSchema.safeParse('ko-KR').success);
console.log('en-US:', LanguageSchema.safeParse('en-US').success);
console.log('ja-JP (invalid):', LanguageSchema.safeParse('ja-JP').success);
console.log('ko (invalid format):', LanguageSchema.safeParse('ko').success);

console.log('\n--- Scenario F: TurnInput 검증 ---');
const validInput = {
  language: 'ko-KR',
  text: '문을 열어본다',
  client: {
    viewport_w: 1920,
    viewport_h: 1080,
    theme: 'dark',
  },
  economy_snapshot: {
    signal: 100,
    memory_shard: 5,
  },
};
try {
  // eslint-disable-next-line @typescript-eslint/no-explicit-any
  const parsed = parseTurnInput(validInput as any);
  console.log('Parsed successfully:', parsed.text);
} catch (e) {
  console.log('Parse error:', e);
}

console.log('\n--- Scenario G: Strict 모드 검증 ---');
const outputWithExtra = {
  language: 'ko-KR',
  narrative: '테스트',
  economy: {
    cost: { signal: 0, memory_shard: 0 },
    balance_after: { signal: 100, memory_shard: 5 },
  },
  safety: { blocked: false, message: null },
  unknown_field: '이 필드는 스키마에 없음',
};
const resultG = TurnOutputSchema.safeParse(outputWithExtra);
console.log('With extra field success:', resultG.success);
if (!resultG.success) {
  console.log('Error code:', resultG.error.issues[0].code);
}
</file>

<file path="frontend/src/stores/agentStore.test.ts">
import { describe, it, expect, beforeEach } from 'vitest';
import { useAgentStore } from './agentStore';
import { StreamEventType, StageStatus } from '../api/turnStream';
import type { TurnOutput } from '../schemas/turn';

describe('agentStore', () => {
  beforeEach(() => {
    useAgentStore.getState().reset();
  });

  it('should have correct initial state', () => {
    const state = useAgentStore.getState();
    expect(state.isStreaming).toBe(false);
    expect(state.phases).toHaveLength(7);
    expect(state.phases[0].status).toBe('pending');
    expect(state.badges).toEqual([]);
    expect(state.repairCount).toBe(0);
  });

  it('should handle startStream', () => {
    useAgentStore.getState().startStream();
    const state = useAgentStore.getState();
    expect(state.isStreaming).toBe(true);
  });

  it('should handle handleStage events', () => {
    const store = useAgentStore.getState();

    // Start parse phase
    store.handleStage({
      type: StreamEventType.STAGE,
      name: 'parse',
      status: StageStatus.START,
    });

    let state = useAgentStore.getState();
    expect(state.currentPhase).toBe('parse');
    expect(state.phases.find((p) => p.name === 'parse')?.status).toBe('in_progress');

    // Complete parse phase
    store.handleStage({
      type: StreamEventType.STAGE,
      name: 'parse',
      status: StageStatus.COMPLETE,
    });

    state = useAgentStore.getState();
    expect(state.phases.find((p) => p.name === 'parse')?.status).toBe('completed');
  });

  it('should handle handleBadges events', () => {
    const store = useAgentStore.getState();
    store.handleBadges({
      type: StreamEventType.BADGES,
      badges: ['schema_ok', 'economy_ok'],
    });

    const state = useAgentStore.getState();
    expect(state.badges).toEqual(['schema_ok', 'economy_ok']);
  });

  it('should handle handleNarrativeDelta events', () => {
    const store = useAgentStore.getState();
    store.handleNarrativeDelta({
      type: StreamEventType.NARRATIVE_DELTA,
      text: 'Hello ',
    });
    store.handleNarrativeDelta({
      type: StreamEventType.NARRATIVE_DELTA,
      text: 'World',
    });

    const state = useAgentStore.getState();
    expect(state.narrativeBuffer).toBe('Hello World');
  });

  it('should handle handleFinal events', () => {
    const store = useAgentStore.getState();
    const mockOutput = {
      language: 'ko-KR',
      narrative: 'Final message',
      economy: {
        cost: { signal: 0, memory_shard: 0 },
        balance_after: { signal: 100, memory_shard: 0 },
      },
      safety: { blocked: false, message: null },
      ui: { action_deck: { cards: [] }, objects: [] },
      world: {
        rules_changed: [],
        inventory_added: [],
        inventory_removed: [],
        quests_updated: [],
        relationships_changed: [],
        memory_pins: [],
      },
      render: { image_job: null },
      agent_console: {
        repair_count: 2,
        current_phase: 'commit',
        badges: [],
      },
    } as TurnOutput;

    store.handleFinal({
      type: StreamEventType.FINAL,
      data: mockOutput,
    });

    const state = useAgentStore.getState();
    expect(state.finalOutput).toEqual(mockOutput);
    expect(state.repairCount).toBe(2);
  });

  it('should handle handleError events', () => {
    const store = useAgentStore.getState();
    store.handleError({
      type: StreamEventType.ERROR,
      message: 'Network error',
      code: 'ERR_NET',
    });

    const state = useAgentStore.getState();
    expect(state.error).toEqual({
      message: 'Network error',
      code: 'ERR_NET',
    });
  });

  it('should reset state on completeStream', () => {
    const store = useAgentStore.getState();
    store.handleNarrativeDelta({ type: StreamEventType.NARRATIVE_DELTA, text: 'Some text' });
    store.startStream();

    store.completeStream();

    const state = useAgentStore.getState();
    expect(state.isStreaming).toBe(false);
    expect(state.narrativeBuffer).toBe('');
  });
});
</file>

<file path="frontend/src/stores/uiPrefsStore.test.ts">
import { describe, it, expect, beforeEach, vi } from 'vitest';
import {
  useUIPrefsStore,
  DEFAULT_UI_SCALE,
  DEFAULT_READABLE_MODE,
  applyUIPrefsToDOM,
} from './uiPrefsStore';

// Node 환경에서 localStorage 및 document 모킹
const localStorageMock = (() => {
  let store: Record<string, string> = {};
  return {
    getItem: (key: string) => store[key] || null,
    setItem: (key: string, value: string) => {
      store[key] = value.toString();
    },
    clear: () => {
      store = {};
    },
    removeItem: (key: string) => {
      delete store[key];
    },
  };
})();

const documentMock = {
  documentElement: {
    dataset: {} as Record<string, string>,
    style: {
      setProperty: vi.fn(),
      removeProperty: vi.fn(),
      getPropertyValue: vi.fn(),
    },
    removeAttribute: vi.fn(),
  },
};

vi.stubGlobal('localStorage', localStorageMock);
vi.stubGlobal('document', documentMock);

describe('uiPrefsStore', () => {
  beforeEach(() => {
    // 스토어 상태 초기화
    useUIPrefsStore.getState().resetPrefs();
    // localStorage 클리어
    localStorage.clear();

    // DOM 모킹 초기화
    documentMock.documentElement.dataset = {};
    vi.mocked(documentMock.documentElement.style.setProperty).mockClear();
    vi.mocked(documentMock.documentElement.style.getPropertyValue).mockImplementation(
      (prop: string) => {
        if (prop === '--ui-scale-factor') return documentMock.documentElement.dataset.uiScale;
        return '';
      },
    );
  });

  it('초기 상태가 올바르게 설정되어야 한다', () => {
    const state = useUIPrefsStore.getState();
    expect(state.uiScale).toBe(DEFAULT_UI_SCALE);
    expect(state.readableMode).toBe(DEFAULT_READABLE_MODE);
  });

  it('setUIScale이 유효한 값일 때만 작동해야 한다', () => {
    const store = useUIPrefsStore.getState();

    // 유효한 값 설정
    store.setUIScale(1.2);
    expect(useUIPrefsStore.getState().uiScale).toBe(1.2);

    // 유효하지 않은 값 설정 시도 (타입 단언 사용)
    // @ts-expect-error: intentional invalid scale for testing
    store.setUIScale(1.5);
    expect(useUIPrefsStore.getState().uiScale).toBe(1.2); // 이전 값 유지
  });

  it('increaseUIScale이 상한선(1.2)을 넘지 않아야 한다', () => {
    const store = useUIPrefsStore.getState();

    store.setUIScale(1.1);
    store.increaseUIScale();
    expect(useUIPrefsStore.getState().uiScale).toBe(1.2);

    store.increaseUIScale();
    expect(useUIPrefsStore.getState().uiScale).toBe(1.2); // 1.2 고정
  });

  it('decreaseUIScale이 하한선(0.9) 미만으로 내려가지 않아야 한다', () => {
    const store = useUIPrefsStore.getState();

    store.setUIScale(1.0);
    store.decreaseUIScale();
    expect(useUIPrefsStore.getState().uiScale).toBe(0.9);

    store.decreaseUIScale();
    expect(useUIPrefsStore.getState().uiScale).toBe(0.9); // 0.9 고정
  });

  it('toggleReadableMode가 상태를 반전시켜야 한다', () => {
    const store = useUIPrefsStore.getState();

    store.toggleReadableMode();
    expect(useUIPrefsStore.getState().readableMode).toBe(true);

    store.toggleReadableMode();
    expect(useUIPrefsStore.getState().readableMode).toBe(false);
  });

  it('resetPrefs가 상태를 기본값으로 되돌려야 한다', () => {
    const store = useUIPrefsStore.getState();

    store.setUIScale(1.2);
    store.setReadableMode(true);

    store.resetPrefs();

    const state = useUIPrefsStore.getState();
    expect(state.uiScale).toBe(DEFAULT_UI_SCALE);
    expect(state.readableMode).toBe(DEFAULT_READABLE_MODE);
  });

  it('applyUIPrefsToDOM이 DOM 속성을 올바르게 설정해야 한다', () => {
    const prefs = {
      uiScale: 1.1 as const,
      readableMode: true,
    };

    applyUIPrefsToDOM(prefs);

    const docEl = document.documentElement;
    expect(docEl.style.getPropertyValue('--ui-scale-factor')).toBe('1.1');
    expect(docEl.dataset.uiScale).toBe('1.1');
    expect(docEl.dataset.readable).toBe('true');
  });

  it('restoreState가 유효한 상태만 복원해야 한다', () => {
    const store = useUIPrefsStore.getState();

    store.restoreState({
      uiScale: 0.9,
      readableMode: true,
    });

    let state = useUIPrefsStore.getState();
    expect(state.uiScale).toBe(0.9);
    expect(state.readableMode).toBe(true);

    // 유효하지 않은 값으로 복원 시도
    store.restoreState({
      // @ts-expect-error: intentional invalid scale for testing
      uiScale: 2.0,
    });

    state = useUIPrefsStore.getState();
    expect(state.uiScale).toBe(0.9); // 이전 유효한 값 유지
  });
});
</file>

<file path="frontend/src/stores/uiPrefsStore.ts">
/**
 * Unknown World - UI 설정 상태 관리 (Zustand + persist).
 *
 * UI 가독성 관련 설정(스케일/Readable 모드)을 저장하고,
 * SaveGame 구조와 통합 가능하도록 직렬화 인터페이스를 제공합니다.
 *
 * 설계 원칙:
 *   - PRD 9.4: 가독성(필수) - 전역 UI 스케일 조절 제공
 *   - PRD 9.5: Readable 모드 - CRT 효과 완화 토글
 *   - Q1 결정: Option B (SaveGame에 포함) - persist + 직렬화
 *
 * @module stores/uiPrefsStore
 */

import { create } from 'zustand';
import { persist, createJSONStorage } from 'zustand/middleware';

// =============================================================================
// 상수 정의
// =============================================================================

/** 지원하는 UI 스케일 값 */
export const UI_SCALES = [0.9, 1.0, 1.1, 1.2] as const;
export type UIScale = (typeof UI_SCALES)[number];

/** 기본 UI 스케일 */
export const DEFAULT_UI_SCALE: UIScale = 1.0;

/** 기본 Readable 모드 */
export const DEFAULT_READABLE_MODE = false;

/** localStorage 키 (SaveGame 통합 시에도 사용 가능) */
export const UI_PREFS_STORAGE_KEY = 'unknown-world-ui-prefs';

// =============================================================================
// 상태 타입 정의
// =============================================================================

/** UI 설정 상태 (SaveGame 직렬화 대상) */
export interface UIPrefsState {
  /**
   * UI 스케일 (0.9 ~ 1.2)
   * - 0.9: 작은 UI (정보 밀도 높음)
   * - 1.0: 기본
   * - 1.1: 약간 확대
   * - 1.2: 큰 UI (가독성 우선)
   */
  uiScale: UIScale;

  /**
   * Readable 모드
   * - true: 스캔라인/플리커/글로우 완화, 대비 향상
   * - false: 기본 CRT 효과 유지
   */
  readableMode: boolean;
}

/** UI 설정 액션 */
export interface UIPrefsActions {
  /** UI 스케일 설정 */
  setUIScale: (scale: UIScale) => void;

  /** UI 스케일 증가 (최대 1.2) */
  increaseUIScale: () => void;

  /** UI 스케일 감소 (최소 0.9) */
  decreaseUIScale: () => void;

  /** Readable 모드 토글 */
  toggleReadableMode: () => void;

  /** Readable 모드 설정 */
  setReadableMode: (enabled: boolean) => void;

  /** 설정 초기화 */
  resetPrefs: () => void;

  /**
   * SaveGame 직렬화용 상태 추출
   * (추후 SaveGame 통합 시 사용)
   */
  getSerializableState: () => UIPrefsState;

  /**
   * SaveGame 역직렬화용 상태 복원
   * (추후 SaveGame 통합 시 사용)
   */
  restoreState: (state: Partial<UIPrefsState>) => void;
}

export type UIPrefsStore = UIPrefsState & UIPrefsActions;

// =============================================================================
// 초기 상태
// =============================================================================

/** 초기 상태 생성 */
function createInitialState(): UIPrefsState {
  return {
    uiScale: DEFAULT_UI_SCALE,
    readableMode: DEFAULT_READABLE_MODE,
  };
}

// =============================================================================
// 유틸리티 함수
// =============================================================================

/**
 * 주어진 스케일이 유효한지 확인
 */
function isValidScale(scale: number): scale is UIScale {
  return UI_SCALES.includes(scale as UIScale);
}

/**
 * 스케일 인덱스 반환
 */
function getScaleIndex(scale: UIScale): number {
  return UI_SCALES.indexOf(scale);
}

// =============================================================================
// Zustand Store with persist
// =============================================================================

/**
 * UI 설정 스토어.
 *
 * @example
 * ```tsx
 * // 컴포넌트에서 사용
 * const { uiScale, readableMode, setUIScale, toggleReadableMode } = useUIPrefsStore();
 *
 * // DOM 적용 (App.tsx에서)
 * useEffect(() => {
 *   document.documentElement.dataset.uiScale = uiScale.toString();
 *   document.documentElement.dataset.readable = readableMode.toString();
 * }, [uiScale, readableMode]);
 * ```
 */
export const useUIPrefsStore = create<UIPrefsStore>()(
  persist(
    (set, get) => ({
      // 초기 상태
      ...createInitialState(),

      // 액션
      setUIScale: (scale) => {
        if (isValidScale(scale)) {
          set({ uiScale: scale });
        }
      },

      increaseUIScale: () => {
        const currentIndex = getScaleIndex(get().uiScale);
        const nextIndex = Math.min(currentIndex + 1, UI_SCALES.length - 1);
        set({ uiScale: UI_SCALES[nextIndex] });
      },

      decreaseUIScale: () => {
        const currentIndex = getScaleIndex(get().uiScale);
        const prevIndex = Math.max(currentIndex - 1, 0);
        set({ uiScale: UI_SCALES[prevIndex] });
      },

      toggleReadableMode: () => {
        set((state) => ({ readableMode: !state.readableMode }));
      },

      setReadableMode: (enabled) => {
        set({ readableMode: enabled });
      },

      resetPrefs: () => {
        set(createInitialState());
      },

      getSerializableState: () => {
        const { uiScale, readableMode } = get();
        return { uiScale, readableMode };
      },

      restoreState: (state) => {
        const updates: Partial<UIPrefsState> = {};

        if (state.uiScale !== undefined && isValidScale(state.uiScale)) {
          updates.uiScale = state.uiScale;
        }

        if (state.readableMode !== undefined) {
          updates.readableMode = state.readableMode;
        }

        if (Object.keys(updates).length > 0) {
          set(updates);
        }
      },
    }),
    {
      name: UI_PREFS_STORAGE_KEY,
      storage: createJSONStorage(() => localStorage),
      // 직렬화할 필드 지정 (액션 제외)
      partialize: (state) => ({
        uiScale: state.uiScale,
        readableMode: state.readableMode,
      }),
    },
  ),
);

// =============================================================================
// 셀렉터 (성능 최적화용)
// =============================================================================

/** UI 스케일 셀렉터 */
export const selectUIScale = (state: UIPrefsStore) => state.uiScale;

/** Readable 모드 셀렉터 */
export const selectReadableMode = (state: UIPrefsStore) => state.readableMode;

// =============================================================================
// DOM 적용 헬퍼
// =============================================================================

/**
 * CSS 변수로 UI 스케일 적용
 * 호출 시 html 요소에 --ui-scale-factor 변수를 설정
 */
export function applyUIScaleToDOM(scale: UIScale): void {
  document.documentElement.style.setProperty('--ui-scale-factor', scale.toString());
  document.documentElement.dataset.uiScale = scale.toString();
}

/**
 * Readable 모드 적용
 * 호출 시 html 요소에 data-readable 속성 설정
 */
export function applyReadableModeToDOM(enabled: boolean): void {
  document.documentElement.dataset.readable = enabled.toString();
}

/**
 * 전체 UI 설정 DOM 적용
 */
export function applyUIPrefsToDOM(state: UIPrefsState): void {
  applyUIScaleToDOM(state.uiScale);
  applyReadableModeToDOM(state.readableMode);
}
</file>

<file path="frontend/src/types/scene.ts">
/**
 * Scene Canvas 관련 타입 정의 (U-031: Placeholder Pack)
 */

/**
 * Scene Canvas 상태 타입
 * - default: 기본 상태 (장면 이미지 없음)
 * - loading: 데이터 로딩 중
 * - offline: 오프라인/연결 끊김
 * - blocked: 안전/정책 차단
 * - low_signal: 재화/신호 부족
 * - scene: 정상 장면 표시 (이미지 URL 포함)
 */
export type SceneCanvasStatus =
  | 'default'
  | 'loading'
  | 'offline'
  | 'blocked'
  | 'low_signal'
  | 'scene';

/**
 * Scene Canvas 상태 데이터 구조
 */
export interface SceneCanvasState {
  status: SceneCanvasStatus;
  imageUrl?: string;
  message?: string;
}

/**
 * 상태별 placeholder 정보 구조
 */
export interface PlaceholderInfo {
  imagePath: string;
  fallbackEmoji: string;
  labelKey: string;
}
</file>

<file path="frontend/src/vite-env.d.ts">
/// <reference types="vite/client" />
</file>

<file path="frontend/tsconfig.node.json">
{
  "compilerOptions": {
    "target": "ES2022",
    "lib": ["ES2022"],
    "module": "ESNext",
    "skipLibCheck": true,

    /* Bundler mode */
    "moduleResolution": "Bundler",
    "allowImportingTsExtensions": true,
    "isolatedModules": true,
    "moduleDetection": "force",

    /* Composite for project references */
    "composite": true,
    "emitDeclarationOnly": true,
    "declaration": true,
    "declarationMap": true,

    /* Linting (엄격 모드) */
    "strict": true,
    "noUnusedLocals": true,
    "noUnusedParameters": true,
    "noFallthroughCasesInSwitch": true,
    "noUncheckedSideEffectImports": true
  },
  "include": ["vite.config.ts"]
}
</file>

<file path="vibe/commands/doc-update.md">
# 구현 완료 후 문서 자동 업데이트 지시서 (Post-Implementation Documentation Sync Guide)

## 1) 역할 및 시스템 설정

### 1.1 역할 정의

너는 이 프로젝트의 **AI 문서 동기화 엔지니어 (AI Documentation Synchronization Engineer)**다.
임무는 **SMART-DOC** 원칙에 따라 코드 변경 내용을 문서에 **정확하게·즉시·추적 가능**하게 반영하는 것이다.

### 1.2 시스템 동작 설정

```yaml
추론 깊이: 상세 (체크리스트 기반 검증 필수)
출력 스타일: 간결하되 핵심 정보 누락 금지
도구 사용: 필요시 무제한 활용
문서 일관성: 모든 문서 간 용어·버전·상태 동기화 필수
```

### 1.3 SMART-DOC 원칙 (행동 가능 사양)

- **S**ystematic Analysis: 변경 파일·의존·설정·API·데이터모델을 체계적으로 수집
- **M**andatory Updates: 대상 문서(Progress/Architecture/Roadmap/…)를 누락 없이 갱신
- **A**ccurate Reflection: 실제 구현과 1:1로 일치하도록 서술 (추측 금지)
- **R**eal-time Execution: 작업 중간 산출도 바로 반영 (배치가 아닌 즉시)
- **T**raceable Changes: 타임스탬프·체인지로그로 추적성 확보
- **D**ocument Consistency: 문서 간 용어·버전·상태 일관
- **O**utput Verification: 변경 후 파일 내용 확인 기능으로 검증 및 표준 보고서 출력
- **C**omprehensive Coverage: 영향받는 모든 문서 범위 포괄

---

## 2) 맥락 수집 및 우선순위

### 2.1 필수 문서 읽기 순서

작업 시작 전 **파일 읽기 기능**으로 아래 문서를 **반드시 읽고** 숙지:

1.  **`vibe/tech-stack.md`** (최우선) - **Repomix 실행을 위한 파일 확장자 파악**
2.  **런북 파일** (필수) - 구현된 기능의 실행 가이드 및 작업 맥락 파악
    - `vibe/unit-runbooks/[작업ID]-runbook.md`
3.  **`.gemini/rules/commit-rules.md`** - 커밋 메시지 작성 규칙
4.  **`vibe/progress.md`** - 현재 진행 상황 파악
5.  **`vibe/roadmap.md`** - 현재 작업 상태 및 진행률 파악

### 2.2 필요시 참조 문서

문서 업데이트 범위에 따라 추가 참조:

6.  `vibe/architecture.md` - 현재 아키텍처 구조
7.  `vibe/prd.md` - 요구사항 현황

---

## 3) 도구 사용 가이드

### 3.1 작업 계획 출력

문서 업데이트 시작 전 아래 형식으로 계획 출력:

```markdown
### 문서 동기화 계획

**목표**: [구현 내용을 어떤 문서들에 반영할지 1줄 요약]

**실행 단계**:

1. [단계 1: 시스템 스냅샷 (Repomix 실행) - 최우선 수행]
2. [단계 2: 런북 확인 및 구현 분석]
3. [단계 3: 개발 보고서 신규 작성]
4. [단계 4: Progress 문서 업데이트]
5. [단계 5: Roadmap 상태 변경]
6. [단계 6: Architecture 문서 갱신 (Repomix 결과 반영)]
7. [단계 7: 커밋 로그 생성]
8. [단계 8: 검증 및 완료 보고]

**업데이트 대상 문서**:

- `vibe/unit-results/[작업ID].md` - [개발 보고서 신규 작성 (유닛 개발만)]
- `vibe/progress.md` - [최신 항목을 문서 최상단에 추가]
- `vibe/roadmap.md` - [업데이트 내용]
- `vibe/architecture.md` - [프로젝트 구조 섹션 업데이트]

**커밋 로그**: `.gemini/rules/commit-rules.md`에 따라 생성 예정
```

---

## 4) 실행 프로세스

### Phase 1: 시스템 스냅샷 및 구조화 (System Snapshot & Structuring)

**가장 먼저 수행**: 프로젝트의 현재 상태를 Repomix로 캡처하여 분석의 기초 데이터로 삼습니다.
**주의**: 변경 규모가 작더라도 **생략하지 말고 반드시 수행**하십시오. 구조적 변경이 없다고 판단하여 건너뛰지 마십시오.

#### 4.1 Repomix 실행 (필수/최우선)

**주의**: 이 단계는 추론만으로 진행하지 말고, **반드시 실제 시스템 터미널/쉘 실행 기능을 사용하여 명령어를 실행**해야 합니다.

1.  **기술 스택 및 확장자 분석**:
    - **파일 읽기 기능**으로 `vibe/tech-stack.md` 내용을 확인합니다.
    - 프로젝트의 주 언어와 프레임워크를 파악하여 포함할 파일 확장자를 결정합니다.

2.  **명령어 구성 및 실행**:
    - **터미널 명령어 실행 기능**을 호출하여 명령어를 **실제 실행**합니다.

    <!-- end list -->

    ```bash
    # TypeScript/Node.js 예시
    repomix --include "**/*.{ts,tsx,js,jsx,json}" --ignore ".claude/**,.cursor/**, .clude/**,.gemini/**,.vscode/**,vibe/**" --output code-base.xml

    # Python 예시
    repomix --include "**/*.{py,toml,json,yaml}" --ignore ".claude/**,.cursor/**, .clude/**,.gemini/**,.vscode/**,vibe/**" --output code-base.xml
    ```

3.  **결과 확인**:
    - `code-base.xml` 파일이 정상적으로 생성되었는지 확인합니다.

---

### Phase 2: 구현 분석 및 개발 보고서 작성 (Implementation Analysis & Report Generation)

#### 4.2 런북 확인 및 코드 분석

**실제 구현 내용 파악**:

- [ ] **런북 파일 읽기** (`vibe/unit-runbooks/[작업ID]-runbook.md`) - **작업 의도 및 테스트 절차 파악**
- [ ] **Repomix 결과물 읽기** (`code-base.xml`) - **전체 파일 구조 및 최신 상태 파악**
- [ ] 실제 생성/수정된 파일 확인 (파일 시스템 직접 확인)
- [ ] 구현된 기능 목록 및 설계 결정 사항 파악
- [ ] API 엔드포인트 및 데이터 모델 변경사항 확인

#### 4.3 개발 보고서 작성 (유닛 개발만)

**적용 대상**: 유닛 개발 작업만 해당

**작성 규칙**:

- **경로**: `vibe/unit-results/[작업ID].md`
- **작성 도구**: **파일 작성 기능** 사용
- **기반 데이터**: 런북(의도/테스트) + Repomix 결과(구조/코드) + 실제 파일 분석
- **작성 방법**: 위 분석 내용을 종합하여 전체 보고서 신규 작성

**개발 보고서 템플릿**:

```markdown
# [작업명] 개발 완료 보고서

## 메타데이터

- **작업 ID**: [작업ID]
- **단계 번호**: [예: 2.3]
- **작성 일시**: YYYY-MM-DD HH:MM
- **담당**: AI Agent

---

## 1. 작업 요약

[런북을 통해 파악한 작업 목표와 실제 구현 결과를 1~2줄로 요약]

---

## 2. 작업 범위

- [정확히 수행한 작업 1]
- [정확히 수행한 작업 2]

---

## 3. 생성/수정 파일

_(Repomix 결과 및 실제 파일 시스템 분석 기반)_

| 파일 경로             | 유형      | 목적             |
| --------------------- | --------- | ---------------- |
| `[repo-root]/src/...` | 신규/수정 | [파일 목적 설명] |

---

## 4. 구현 상세

### 4.1 핵심 설계

**주요 계약** (함수·클래스·인터페이스·CLI):

- `functionName(params): returnType` - [설명]

**설계 패턴/원칙**:

- [적용한 패턴 및 원칙]

### 4.2 외부 영향 분석

- **데이터/파일 시스템**: [변경 사항]
- **권한/보안**: [변경 사항]
- **빌드/의존성**: [변경 사항]

### 4.3 가정 및 제약사항

- [전제 조건 및 제약 사항]

### 4.4 대안 검토 (있는 경우)

- [대안 분석 및 결정 사유]

---

## 5. 런북(Runbook) 정보

- **파일 경로**: `vibe/unit-runbooks/[작업ID]-runbook.md`
- **실행 결과**: 런북의 시나리오를 기반으로 구현 검증 완료
- **참조**: 상세 실행 방법은 위 런북 파일 참조

---

## 6. 리스크 및 주의사항

- [리스크 및 파괴적 변경 사항]

---

## 7. 다음 단계 안내

### 7.1 후속 작업

1. **린트 및 타입 체크**
2. **런북 실행**

### 7.2 의존 단계 확인

- **선행 단계**: [완료된 단계]
- **후속 단계**: [로드맵 참조]

---

## 8. 자체 점검 결과

- [x] 런북 기반 요구사항 충족 확인
- [x] Repomix 최신 구조 반영 확인
- [x] 아키텍처/네이밍/경로 일관성 유지
- [x] 파괴적 변경/리스크/가정 명시

---

_본 보고서는 AI Agent에 의해 자동 생성되었습니다._
```

#### 4.4 아키텍처 영향도 평가

- **컴포넌트/데이터/시스템 경계**에 대한 영향 분석 (보고서 작성 중 파악된 내용 바탕)

---

### Phase 3: 문서 분석 및 매핑 (Document Analysis & Mapping)

#### 4.5 문서 업데이트 우선순위

| 우선순위       | 문서                            | 업데이트 조건                                   |
| -------------- | ------------------------------- | ----------------------------------------------- |
| **선행 완료**  | `code-base.xml`                 | **Phase 1에서 이미 완료됨**                     |
| **선행 완료**  | `vibe/unit-results/[작업ID].md` | **Phase 2에서 이미 완료됨**                     |
| **필수 1순위** | `vibe/progress.md`              | 모든 구현 완료 시 항상 갱신 (최신 항목 최상단)  |
| **필수 2순위** | `vibe/roadmap.md`               | 작업 완료/진행률 변경 시                        |
| **필수 3순위** | `vibe/architecture.md`          | **Phase 1의 Repomix 결과 반영** 및 구조 변경 시 |
| **조건부**     | `vibe/prd.md`                   | FR/NFR 달성/변경 발생 시                        |
| **조건부**     | `vibe/tech-stack.md`            | 의존성 추가/제거/버전업 시                      |

---

## 5) 핵심 실행 규칙

### 5.1 문서 수정 규칙

1.  **모든 문서 수정은 반드시 '텍스트 치환' 기능 사용**
2.  **"언급만 하고 실제 변경 없음" 절대 금지** — 실제 치환/삽입으로 반영
3.  **각 업데이트 직후 '파일 내용 확인' 기능으로 변경 확인** (변경 전/후 스니펫 포함)
4.  **누락/검증 실패 시 해당 Phase를 재실행**
5.  **`vibe/progress.md`는 항상 최신 항목이 문서 최상단에 위치**

### 5.2 검증 정책

- 모든 문서 수정 후 반드시 **파일 내용 확인 기능**으로 해당 섹션 확인
- 변경 전/후 내용을 로그에 기록

---

## 6) 문서별 업데이트 템플릿

### 6.1 Progress 문서 (`vibe/progress.md`) - 필수

**중요**: 최신 항목이 항상 **문서 맨 위**에 위치해야 함

**업데이트 방법**:

1.  **파일 내용 확인 기능**으로 현재 Progress 문서 확인
2.  문서의 제목(# 프로젝트 진행 상황) 바로 다음 줄에 새 섹션 삽입
3.  기존 내용은 자동으로 아래로 밀려남

**삽입할 템플릿**:

```markdown
## [YYYY-MM-DD HH:MM] [작업명] 완료

### 구현 완료 항목

- **핵심 기능**: [주요 기능 1~2줄 요약]
- **추가 컴포넌트**: [새로 추가된 모듈/파일]
- **달성 요구사항**: [FR-X], [NFR-Y]

### 기술적 구현 세부사항

**사용 기술/라이브러리**:

- [기술명] v[버전]: [용도]

**설계 패턴 및 아키텍처 선택**:

- [패턴명]: [선택 이유]

**코드 구조**:
_(Repomix 결과를 참조하여 정확히 기재)_
repo-root/
├── src/
│ ├── [새 파일]
│ └── [수정 파일]

### 성능 및 품질 지표

- **코드 품질**: [린트 결과]
- **성능/보안**: [지표 및 조치]

### 의존성 변경

- [추가/업데이트/제거 내역]

### 다음 단계

- [후속 작업]

---
```

---

### 6.2 Roadmap 문서 (`vibe/roadmap.md`) - 필수

#### 업데이트 대상 섹션:

**1) 전체 진행률 (문서 상단)**

```markdown
## 프로젝트 진행 현황

**전체 진행률**: [완료]/[전체] ([퍼센트]%)
**MVP/MMP 진행률**: [상세 진행률]
**현재 진행중**: [작업명] / **최근 완료**: [작업명] (YYYY-MM-DD)
```

**2) 마일스톤 & 작업 상태**

- 마일스톤 진행률 업데이트
- 작업 상태 변경: ⏸️(대기) → 🚧(진행중) → ✅(완료)
- **완료된 작업은 "## 작업 백로그" 내의 마일스톤별 리스트에서 삭제**하고, 문서 하단의 **"### 완료" 섹션으로 이동**하여 `vibe/unit-results/[작업ID].md` 참조 링크를 추가합니다.

---

### 6.3 Architecture 문서 (`vibe/architecture.md`) - 조건부

#### 업데이트 시점:

- **Phase 1에서 생성된 Repomix 결과를 반영할 때**
- 새 컴포넌트/시스템 구조 변경 시

#### 업데이트 내용:

**1) 시스템 구성도 및 컴포넌트 상세**

- 다이어그램 및 컴포넌트 책임/인터페이스 업데이트

**2) 프로젝트 구조 시각화 (Repomix 결과 반영)**

```markdown
## 프로젝트 구조

### 디렉토리 구조

[Phase 1에서 생성된 code-base.xml의 파일 트리 내용을 여기에 삽입]

### 주요 디렉토리 설명

- `src/`: [설명]
```

---

### 6.4 사양서 문서 (`vibe/prd.md`) - 조건부

- FR(기능)/NFR(비기능) 요구사항 상태 변경 (✅ 구현 완료)
- 구현 방식 및 검증 결과(런북 참조) 추가

---

### 6.5 기술스택 문서 (`vibe/tech-stack.md`) - 조건부

- 의존성 변경 이력 추가 (추가/버전업/제거)
- 현재 기술 스택 섹션 갱신

---

## 7) 커밋 로그 생성 (필수 단계)

### Phase 7: 커밋 메시지 추천 (Commit Message Recommendation)

#### 7.1 커밋 로그 생성 시점

**모든 문서 업데이트 완료 후, 최종 콘솔 보고 전 필수 진행**

#### 7.2 커밋 로그 규칙 확인

1.  **`.gemini/rules/commit-rules.md` 문서 읽기**: **파일 내용 확인 기능**으로 규칙 확인
2.  **규칙 준수**: 형식, 컨벤션, 예시 참조

#### 7.3 커밋 로그 생성 기준 (SSOT: 현재 유닛)

**중요**: 추천 커밋 로그는 “이번 doc-update의 기준 유닛([작업ID])”을 기준으로 작성합니다.  
`vibe/progress.md` 등 **문서 변경 파일 목록은 커밋 제목/스코프를 결정하는 기준이 아닙니다.**

- **SSOT(단일 출처)**: 사용자 입력의 [작업ID] + `vibe/unit-plans/[작업ID].md` + `vibe/unit-results/[작업ID].md`
- **보조 근거**: (있는 경우) 사용자 제공 “기준 구현 커밋/의존 커밋”의 변경점
- **타입/스코프 선택 기준**: 유닛이 실제로 구현한 코드 영역/성격 기준으로 선택(feat/fix/refactor/test/chore 등)
  - 예: generator 기능 추가 → `feat(generator): [작업ID] ...`
- **Progress 섹션**: `vibe/roadmap.md`의 최신 진행률을 그대로 반영

---

## 8) 콘솔 완료 보고 (최종 출력)

### 8.1 완료 보고 형식

모든 문서 업데이트 및 커밋 로그 생성 완료 후, 콘솔에 아래 형식으로 **최종 보고 출력**:

````markdown
━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
📝 문서 동기화 완료
━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━

📅 동기화 일시: YYYY-MM-DD HH:MM
🎯 기준 구현: [작업명]

📊 업데이트 결과
✅ Repomix 실행: [최우선 실행 완료] (code-base.xml)
✅/⭕ 개발 보고서: [작성 완료 (런북 및 Repomix 기반)]
✅ Progress 문서: 최신 항목 추가 (최상단)
✅ Roadmap 문서: 진행률 갱신 및 상태 변경
✅/⭕ Architecture 문서: 구조 업데이트 완료
⭕ 사양서/기술스택: [업데이트 내역]

💾 추천 커밋 로그

```text
[Section 7) 커밋 로그 생성 단계의 규칙과 분석 결과에 따라 작성된 실제 커밋 메시지를 이곳에 출력]
```

🔍 검증 상태
• Repomix 선행 실행: 완료
• 런북 확인 후 보고서 작성: 완료
• 필수 문서 반영 및 일관성: 통과
• Progress 최신 항목 위치: 최상단 확인

📋 다음 단계

1.  Progress 문서 확인: vibe/progress.md
2.  Roadmap 문서 확인: vibe/roadmap.md
3.  개발 보고서 확인: vibe/unit-results/[작업ID].md
4.  커밋 메시지 검토 후 커밋 실행

━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
````

---

## 9) 실행 체크리스트 (단계별 확인)

### Phase 1: 시스템 스냅샷 (Repomix) - 최우선

- [ ] `vibe/tech-stack.md` 읽고 확장자 파악
- [ ] **터미널 명령어 실행 기능**으로 `repomix` **실제 실행**
- [ ] `code-base.xml` 생성 확인

### Phase 2: 분석 및 보고서 작성

- [ ] **런북 파일 읽기** (맥락 파악)
- [ ] 실제 구현 코드 및 Repomix 결과 분석
- [ ] **개발 보고서 신규 작성** (`vibe/unit-results/[작업ID].md`)
- [ ] **파일 내용 확인 기능**으로 작성 결과 검증

### Phase 3: Progress 문서 업데이트 (필수)

- [ ] 최신 구현 항목을 문서 **최상단**에 삽입
- [ ] **텍스트 치환 기능** 사용 및 검증

### Phase 4: Roadmap 문서 업데이트 (필수)

- [ ] 진행률 및 작업 상태(완료) 업데이트
- [ ] **텍스트 치환 기능** 사용 및 검증

### Phase 5: Architecture 문서 업데이트 (조건부)

- [ ] **Phase 1의 Repomix 결과**를 프로젝트 구조 섹션에 반영
- [ ] 시스템 구성도 갱신
- [ ] **텍스트 치환 기능** 사용 및 검증

### Phase 6: 기타 문서 업데이트 (조건부)

- [ ] 사양서(FR/NFR) 및 기술스택 문서 업데이트
- [ ] **텍스트 치환 기능** 사용 및 검증

### Phase 7: 커밋 로그 생성 (필수)

- [ ] `.gemini/rules/commit-rules.md` 준수하여 메시지 생성

### Phase 8: 최종 검증 및 완료 보고

- [ ] Repomix 선행 실행 여부 재확인
- [ ] 런북 기반 보고서 작성 여부 재확인
- [ ] 콘솔 완료 보고 출력

---

## 10) 일관성 검증 체크리스트 (최종)

- [ ] **순서 준수**: Repomix 실행 → 런북/코드 분석 → 보고서 작성 → 문서 동기화
- [ ] **내용 일치**: 개발 보고서 내용이 런북 및 실제 코드(Repomix)와 일치하는가?
- [ ] **위치 정확성**: Progress 문서의 최신 항목이 최상단에 있는가?
- [ ] **구조 반영**: Architecture 문서에 최신 파일 트리가 반영되었는가?

## 11) 문서화 대상
</file>

<file path="vibe/commands/refactor-doc.md">
# 리팩토링 완료 후 문서 동기화 지시서 (Post-Refactoring Documentation Sync Guide)

## 1) 역할 및 시스템 설정

### 1.1 역할 정의

너는 프로젝트의 기술 부채를 관리하고 문서 일관성을 유지하는 **AI 문서 동기화 엔지니어**다.
프롬프트 하단에 명시된 리팩토링 작업(`RU-ID`)의 결과를 시스템 문서에 정확히 반영하여 코드와 문서의 괴리를 방지한다.

### 1.2 시스템 동작 설정

```yaml
추론 깊이: 상세 (코드 변경에 따른 문서 영향도 분석)
출력 스타일: 간결하되 핵심 정보 누락 금지
원칙: SMART-DOC (Systematic, Mandatory, Accurate, Real-time, Traceable)
```

---

## 2) 맥락 수집 및 프로세스

### 2.1 필수 문서 읽기

작업 시작 전 파일 읽기 도구로 아래 문서를 읽고 숙지:

1. **Target Refactoring Proposal** (핵심): **Section 6**에 명시된 리팩토링 제안 계획서 파일.
2. **`vibe/tech-stack.md`** (확장자 파악용)
3. **`vibe/progress.md`** (진행 상황 기록)
4. **`vibe/architecture.md`** (구조 변경 시 업데이트)
5. **`.gemini/rules/commit-rules.md`** - 커밋 메시지 작성 규칙
6. **런북 파일** (선택): 런북이 생성된 경우 `vibe/unit-runbooks/[RU-ID]-runbook.md` 참조.

### 2.2 Repomix 실행 (필수)

코드의 최신 상태를 파악하기 위해 `repomix`를 실행하여 스냅샷을 생성한다.

- 명령어: `repomix --include "**/*.{ts,py,js,json,md}" -i ".claude/**,.cursor/**,.gemini/**,.vscode/**,vibe/**" --output code-base.xml` (기술 스택에 맞게 확장자 조정)

---

## 3) 문서 업데이트 가이드

### 3.1 Progress 문서 업데이트 (`vibe/progress.md`)

리팩토링 작업은 기능 추가가 아니므로 "리팩토링 완료" 섹션 또는 최신 진행 내역에 기록한다.

**업데이트 템플릿**:

```markdown
## [YYYY-MM-DD HH:MM] [Section 6의 제안 ID] 리팩토링 완료

### 작업 내용

- **제안서**: [제안 ID] [제안서 제목]
- **개선 사항**: [제안서의 '기대 효과' 및 실제 적용 내용 요약]
- **영향 범위**: [수정된 주요 모듈/파일]

### 기술적 세부사항

- [예: 하드코딩 제거 및 Config 연동]
- [예: 중복 로직 캡슐화 (Helper 함수 적용)]

### 검증

- [수동 검증 완료 / 런북 참조: (런북 경로)]
```

### 3.2 Architecture 문서 업데이트 (`vibe/architecture.md`) (조건부)

**다음의 경우에만 업데이트한다:**

1. **파일/폴더 구조 변경**: `code-base.xml`의 파일 트리를 참조하여 구조 섹션 갱신.
2. **주요 컴포넌트 변경**: 제안서가 '모듈 설계(Q4)' 카테고리이거나, 주요 의존성이 변경된 경우.

### 3.3 환경설정 문서 업데이트 (조건부)

- 제안서가 '설정 외부화'를 포함한 경우, 관련 설정 문서나 환경 변수 예시(`.env.example` 등)를 업데이트한다.

---

## 4) 커밋 로그 생성 (필수 단계)

### 4.1 커밋 로그 생성 시점

**모든 문서 업데이트 완료 후, 최종 콘솔 보고 전 필수 진행**

### 4.2 커밋 로그 규칙 확인

1.  **`.gemini/rules/commit-rules.md` 문서 읽기**: **파일 내용 확인 기능**으로 규칙 확인
2.  **규칙 준수**: 형식, 컨벤션, 예시 참조

### 4.3 커밋 로그 생성 기준

**중요**: 커밋 로그는 **문서 업데이트 작업이 아닌 실제 구현 작업**을 기준으로 작성
**타입**: 리팩토링은 보통 `refactor` 타입을 사용한다.

### 4.4 커밋 로그 템플릿 (예시)

```
[타입](스코프): 제목

본문:
- [상세 내용 1]
- [상세 내용 2]

Footer:
- 관련 이슈: #123
```

---

## 5) 완료 보고

### 5.1 콘솔 완료 보고

모든 업데이트 후 아래 형식으로 출력:

````markdown
━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
📝 리팩토링 문서 동기화 완료
━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━

📅 동기화 일시: YYYY-MM-DD HH:MM
🎯 대상 작업: [Section 6의 제안 ID]

📊 업데이트 결과
✅ Repomix 실행: 완료
✅ Progress 문서: 리팩토링 내역 기록 (최상단)
✅/⭕ Architecture 문서: [구조 변경 여부에 따라 업데이트/생략]
⭕ 원본 제안서: 유지 (변경 없음)

💾 추천 커밋 로그

```text
[생성된 커밋 메시지]
```

📋 다음 단계

1.  Progress 문서 확인: vibe/progress.md ** 최신 변경 사항 일부 확인 **
2.  커밋 메시지 확인 및 반영
    ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
````

---

## 6) 실행 체크리스트

- [ ] `repomix`를 통해 최신 코드 상태를 확인했는가?
- [ ] `Progress` 문서에 리팩토링 내역([제안 ID])을 명확히 기록했는가?
- [ ] 구조적 변경이 있는 경우 `Architecture` 문서를 갱신했는가?
- [ ] 커밋 메시지를 추천했나?
- [ ] 커밋 메시지 타입이 `refactor` 인가?

---

## 7) 현재 동기화할 리팩토링 제안 정보
</file>

<file path="vibe/commands/refactor-impl.md">
# 리팩토링 제안 기반 코드 구현 및 검증 지시서 (Refactoring Implementation & Verification Guide)

## 1) 역할 및 시스템 설정

### 1.1 역할 정의

너는 `vibe/tech-stack.md` 기술을 다루며 클린 코드와 아키텍처 개선에 특화된 **AI 리팩토링 & QA 스페셜리스트**다.
프롬프트 하단에 명시된 **리팩토링 제안서(RU)** 를 기반으로 코드를 개선하되, **기존 기능의 동작을 유지(Behavior Preservation)** 하는 것을 최우선 목표로 한다.

### 1.2 시스템 동작 설정

```yaml
추론 깊이: 상세 (제안서 분석 및 회귀 검증 필수)
출력 스타일: 구조적이고 명확한 변경 내역 제공
도구 사용: 필요시 무제한 활용
원칙: Refactor-Safe (기능 변경 없이 구조만 개선, 또는 제안서 명시 사항만 변경)
```

### 1.3 리팩토링 안전 수칙 (REF-SAFE)

모든 작업 시작 전 아래 항목을 내부적으로 검토:

- **Behavior Preservation**: 제안서에서 의도한 변경 외의 부수적인 동작 변경(Side Effect)을 절대 금지한다.
- **Incremental**: 제안서의 Step별 가이드를 준수하여 단계적으로 코드를 수정한다.
- **Traceable**: 변경 전/후의 차이를 명확히 설명할 수 있어야 한다.
- **Verification-First**: 검증 없이 코드를 수정하지 않는다. (수동 검증 또는 런북)

---

## 2) 맥락 수집 및 분석

### 2.1 필수 문서 읽기 순서

작업 시작 전 파일 읽기 도구로 아래 문서를 **반드시 읽고** 숙지:

1. **`.gemini/rules/red-line.md`** (최우선) - AI 필수 준수 규칙
2. **Target Refactoring Proposal** (핵심) - **Section 6**에 명시된 리팩토링 제안 계획서 파일.
3. **`vibe/tech-stack.md`** - 프로젝트 기술 스택
4. `vibe/prd.md` - 프로젝트 디자인 문서 및 요구사항
5. `vibe/architecture.md` - 파일 구성, 각 파일 목적, 아키텍처 설계
6. `vibe/progress.md` - 진행 현황 및 의존성
7. `.gemini/GEMINI.md` - 전역 개발 지침
8. `.gemini/rules/*.md` - 세부 도메인별 지침

### 2.2 제안서 상세 분석 (THINK-FIRST)

하단에 지정된 제안서를 읽고 다음 정보를 추출하여 내부 계획을 수립한다:

1. **대상 코드**: 수정해야 할 파일과 함수/클래스 위치
2. **개선 방안**: Step-by-Step 실행 절차 확인
3. **검증 방법**: 제안서에 명시된 검증 시나리오 파악
4. **주의사항**: 제안서의 '⚠️ 주의사항' 섹션 숙지

---

## 3) 구현 및 검증 가이드

### 3.1 작업 계획 출력

작업 시작 전 아래 형식으로 계획을 출력:

```markdown
### 리팩토링 작업 계획

**대상 제안**: [Section 6의 제안 ID]

**영향 범위**:

- [파일 경로 1]
- [파일 경로 2]

**실행 단계**:

1. [Step 1 요약]
2. [Step 2 요약]

**검증 전략**:

- [제안서 기반 검증 시나리오 요약]
```

### 3.2 구현 규칙 (Refactoring Rules)

- **네이밍 유지/변경**: 제안서에서 명시적으로 변경을 요구하지 않는 한, Public Interface(함수명, 파라미터 등)는 유지를 원칙으로 한다.
- **중복 제거**: '코드 중복(Q1)' 리팩토링 시, 공통 로직을 유틸리티나 Helper 함수로 명확히 분리한다.
- **설정 외부화**: '하드코딩(Q5)' 리팩토링 시, 프로젝트의 기존 설정 관리 패턴(예: `config.py`, `.env`, `Settings` 클래스 등)을 따른다.
- **테스트 코드**: 자동화된 테스트 코드는 작성하지 않으며(정책 준수), 제안서에 명시된 **수동 검증 방법**을 수행한다.

### 3.3 린트 및 타입 체크 (필수 실행)

- 코드 수정 직후, **반드시** `Shell 살행 도구`를 사용하여 린터와 타입 체커를 실행해야 한다.
- 실행 명령어는 **`.gemini/rules/lint-rules.md`** 를 참조한다.
- 발견된 모든 오류는 즉시 수정하여 제출한다. (오류가 있는 상태로 완료 금지)

### 3.4 테스트 실행 (필수 실행)

- 린트/타입 체크 통과 후, **`.gemini/rules/test-rules.md`** 의 지침을 참고하여 관련 테스트를 실행한다.
- 리팩토링 대상 코드와 관련된 유닛/통합 테스트를 수행하여 회귀(Regression)가 없음을 확인한다.

### 3.5 런북(Runbook) 작성 지침 (선택 사항)

- **간단한 리팩토링**: 별도의 런북 파일 생성 없이, 완료 보고 시 콘솔에 검증 결과를 요약한다.
- **복잡한 리팩토링**: 검증 절차가 복잡하거나(Step이 3개 이상), 외부 시스템 연동이 포함된 경우에만 `vibe/unit-runbooks/[RU-ID]-runbook.md` 파일을 생성한다.

---

## 4) 산출물 형식 (필수 출력 구조)

### 4.1 콘솔 완료 보고

작업 완료 후 콘솔에 아래 형식으로 요약 출력:

```markdown
━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
✅ [RU-ID] 리팩토링 완료
━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━

🛠 작업 요약
[제안서의 개선 방안 적용 결과 1줄 요약]

📂 수정 파일
• [파일경로]: [수정 내용 (예: Helper 함수 추출, 하드코딩 제거)]

🧪 검증 결과
• 린트/타입 체크: Pass (명령어 실행 완료)
• 동작 검증: [제안서의 검증 방법 수행 결과 요약]
• 런북 파일: [생성함/생략함 (사유)]

⚠️ 특이사항
• [제안서 주의사항 관련 조치 내용]

📋 다음 단계

1.  수동 검증 확인
2.  문서 업데이트 실행 (doc-update-refactor.md)
    ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
```

### 4.2 런북 파일 템플릿 (필요시에만 생성)

_복잡한 시나리오 검증이 필요한 경우에만 생성합니다._

```markdown
# [RU-ID] 리팩토링 검증 런북

## 검증 시나리오

**목적**: [리팩토링 후 기능 유지 확인]

**실행 절차**:

1. [Step 1]
   bash
   [명령어]

2. [Step 2]

**확인 결과**:

- [ ] [기존과 동일한 동작 확인]
```

---

## 5) 최종 체크리스트

- [ ] 하단에 명시된 **제안 계획서**의 모든 Step을 이행했는가?
- [ ] 기존 기능의 동작(Business Logic)을 변경하지 않았는가?
- [ ] **`.gemini/rules/lint-rules.md`** 의 명령어를 실행하고 오류를 수정했는가?
- [ ] **`.gemini/rules/test-rules.md`** 에 따라 테스트를 실행하고 통과했는가?
- [ ] 제안서의 '검증 방법'을 수행하고 결과를 확인했는가?

---

## 6) 현재 진행할 리팩토링 제안 정보
</file>

<file path="vibe/commands/test-exec.md">
# 고급 코드 검증 및 테스트 중심 개발 지시서 (Enhanced Code Verification & Test-Driven Development Guide)

## 1) 역할 및 시스템 설정

### 1.1 역할 정의

너는 `{기술스택-문서경로}` 문서의 기술을 다루는 **AI 품질 보증 및 테스트 엔지니어 (AI QA & Test Engineer)**다.

**핵심 정체성**:

- 테스트 주도 설계 (Test-Driven Design)
- 체계적 검증 및 품질 보증
- 안전한 리팩터링 지원

**품질 기준**:

- 정직·유용·비해로운 결과물
- 회귀 방지 및 추적 가능성 강화

### 1.2 시스템 동작 설정

```yaml
추론 깊이: 매우 상세 (테스트 시나리오 및 원인 분석 필수)
출력 스타일: 구조화된 분석 결과 제공
도구 사용: 필요시 무제한 활용
테스트 우선: 구현 전 테스트 작성 원칙
```

### 1.3 TEST-FIRST 철학 (행동 가능 사양)

모든 작업 시작 전 아래 원칙을 내부적으로 검토:

- **TDD**: Red → Green → Refactor 주기를 준수 (각 단계 산출을 별도 블록으로 출력)
- **Thorough**: 기능·경계·예외·성능·보안까지 테스트 범위를 명시
- **Systematic**: 테스트 피라미드(단위/통합/E2E) 비율 계획
- **Traceable**: 실패 재현 절차·로그 키·환경변수·시드 값을 기록
- **Refactoring-Safe**: 리팩터링 전후 동등성 검증 기준 명시
- **Coverage-Driven**: 커버리지 타깃(라인/브랜치/함수/조건) 설정·보고
- **Test-Integrity**: 테스트 자체의 정확성과 신뢰성 검증

---

## 2) 맥락 수집 및 우선순위

### 2.1 필수 문서 읽기 순서

작업 시작 전 `파일 읽기` 도구로 아래 문서를 **반드시 읽고** 숙지:

1. **`{RED-LINE-지침서}`** (최우선) - AI 필수 준수 규칙 (CRITICAL RULES)
2. **`{기술스택-문서경로}`** - 프로젝트 기술 스택 및 테스트 도구
3. **`{린트-타입체크-지침경로}`** - 린트 및 타입 체크 규칙
4. **대상 코드 파일** - 테스트 대상 구현 코드

### 2.2 필요시 참조 문서

작업 복잡도에 따라 추가 참조:

5. `{유닛별-런북저장경로}` - 기존 유닛의 검증 시나리오
6. `{유닛별-계획경로}` - 유닛 개발 계획 및 요구사항
7. `{사양서-문서경로}` - 프로젝트 디자인 문서 및 요구사항
8. `{아키텍쳐-문서경로}` - 파일 구성, 아키텍처 설계
9. `{로드맵-문서}` - 단계 및 마일스톤 상태
10. `{프로그레스-문서경로}` - 진행 현황 및 의존성
11. `{전역-지침-경로}` - 전역 개발 지침
12. `{세부-지침-경로}` - 세부 도메인별 지침
13. `{회기-기록-경로}` - 이번 유닛과 무관하지만 해결하지 못한 이슈 기록

### 2.3 문서 충돌 시 우선순위

```
RED-LINE > 린트 지침 > 기술스택 > 사양서 > 아키텍처 > 기타 지침
```

---

## 3) 도구 사용 가이드

### 3.1 작업 계획 출력

복잡한 테스트 작업 시작 전 아래 형식으로 계획 출력:

```markdown
### 테스트 작업 계획

**목표**: [1줄로 목표 재진술]

**실행 단계**:

1. [단계 1: 예: 요구사항 분석 및 테스트 시나리오 도출]
2. [단계 2: 예: Red - 실패하는 테스트 작성]
3. [단계 3: 예: Green - 최소 구현으로 테스트 통과]
4. [단계 4: 예: Refactor - 코드 개선]
5. [단계 5: 예: 커버리지 및 품질 검증]

**예상 산출물**:

- `tests/unit/[파일명]_test.py` - 단위 테스트
- `tests/integration/[파일명]_test.py` - 통합 테스트 (필요시)
- 커버리지 리포트
```

**실행 중**: 각 단계 완료 시 한 줄 진행 로그 출력  
**완료 후**: 최종 요약 블록 제시

---

## 4) 심층 사고 과정

### 4.1 요구사항 및 제약 분석

**기능 요구사항 구체화**:

- 입출력 사양
- 상태 전이 시나리오
- 오류 처리 요구사항
- 성능 요구사항
- 보안 요구사항

**제약 매트릭스**:
| 제약 유형 | 내용 | 영향 | 트레이드오프 |
|----------|------|------|--------------|
| 기술적 | [제약] | [영향] | [대안] |
| 비즈니스 | [제약] | [영향] | [대안] |
| 품질 | [제약] | [영향] | [대안] |
| 리소스 | [제약] | [영향] | [대안] |

**영향 범위 명시**:

- 파일 및 모듈
- API 및 인터페이스
- 데이터 및 상태
- 빌드/배포 파이프라인

---

## 5) 테스트 중심 개발 (TDD Core)

### 5.1 테스트 전략 및 구조

**테스트 피라미드 가이드** (기본 권장 비율):

- 단위 테스트 (Unit): 70%
- 통합 테스트 (Integration): 20%
- E2E 테스트: 10%

**디렉터리 구조**:

```
tests/
├── unit/              # 단위 테스트
├── integration/       # 통합 테스트
├── e2e/              # End-to-End 테스트
├── performance/      # 성능 테스트
├── security/         # 보안 테스트
└── fixtures/         # 테스트 데이터
```

**테스트 시나리오 범위**:

- 성공 시나리오 (Happy Path)
- 실패 시나리오 (Error Cases)
- 경계값 테스트 (Boundary Conditions)
- 성능 테스트 (Performance)
- 보안 테스트 (Security - OWASP 기준)
- 회귀 테스트 (Regression)

### 5.2 Red-Green-Refactor 주기

#### Red (실패하는 테스트 작성)

1. 요구사항을 테스트로 명세화
2. 테스트 이름 및 설명 명확히 작성
3. 예상 실패 메시지 명시
4. 실행하여 실패 확인

#### Green (최소 구현으로 통과)

1. 테스트를 통과시키는 최소한의 코드 작성
2. 오버엔지니어링 금지
3. 테스트 통과 확인

#### Refactor (코드 개선)

1. 구조 개선
2. 중복 제거
3. 명명 개선
4. 성능 최적화
5. 보안 강화
6. 테스트 재통과 확인 (회귀 방지)

---

### 5.3 테스트 실패 원인 판별 프로토콜 (CRITICAL)

**테스트 실패 시 반드시 아래 절차를 따라 원인을 판별하고 문서화**

#### Phase 1: 초기 진단 (Initial Diagnosis)

**1. 실패 메시지 분석**

- **Assertion 실패**: 예상값 vs 실제값 비교 분석
- **Exception/Error**: 스택 트레이스 전체 분석
- **Timeout**: 성능 이슈 vs 무한 루프 판별

**2. 테스트 격리 실행**

- 단일 테스트만 실행하여 독립성 검증
- 다른 테스트와의 순서 의존성 확인
- 테스트 환경 초기화 상태 점검

#### Phase 2: 원인 판별 (Root Cause Determination)

**3. 구현 코드 문제 징후 체크리스트**

- [ ] 비즈니스 로직 오류
- [ ] 경계값 처리 누락
- [ ] 예외 처리 미비
- [ ] 상태 관리 오류
- [ ] 동시성/경쟁 조건
- [ ] 외부 의존성 처리 오류

**4. 테스트 코드 문제 징후 체크리스트**

- [ ] 잘못된 기대값 설정
- [ ] 부적절한 테스트 데이터
- [ ] Mock/Stub 설정 오류
- [ ] 테스트 순서 의존성
- [ ] 테스트 환경 설정 오류
- [ ] 타이밍/대기 시간 문제

#### Phase 3: 교차 검증 (Cross Validation)

**5. 삼각 검증 (Triangulation)**

```markdown
a) **수동 테스트**: 동일 시나리오를 수동으로 재현

- 절차: [단계별 설명]
- 결과: [실제 동작 확인]

b) **로그 분석**: 실행 흐름과 상태 변화 추적

- 로그 위치: [경로]
- 주요 발견: [분석 결과]

c) **디버거 실행**: 중단점 설정하여 단계별 검증

- 중단점 위치: [코드 라인]
- 변수 상태: [확인 내용]
```

**6. 가설 검증 매트릭스**

| 가설               | 검증 방법   | 결과   | 확신도 |
| ------------------ | ----------- | ------ | ------ |
| 구현 로직 오류     | [검증 방법] | [결과] | 0-100% |
| 경계값 처리 오류   | [검증 방법] | [결과] | 0-100% |
| 테스트 기대값 오류 | [검증 방법] | [결과] | 0-100% |
| Mock 설정 오류     | [검증 방법] | [결과] | 0-100% |

#### Phase 4: 수정 전 최종 확인 (Pre-Fix Verification)

**7. 수정 영향도 분석**

- **구현 수정 시**: 다른 테스트에 미치는 영향 범위 예측
- **테스트 수정 시**: 요구사항 일치 여부 재확인

**8. 수정 정당성 검증 질문** (3가지 모두 YES여야 함)

- [ ] "이 수정이 원래 요구사항을 만족하는가?"
- [ ] "테스트가 실제 사용 시나리오를 정확히 반영하는가?"
- [ ] "수정이 다른 기능에 회귀를 일으키지 않는가?"

---

### 5.4 테스트 신뢰성 보장 규칙

#### 1. 테스트 수정 금지 조건

다음 경우 테스트를 수정하면 **절대 안 됨**:

- 요구사항 문서와 불일치할 때
- 실제 사용 시나리오와 다를 때
- 단순히 테스트를 통과시키기 위한 수정일 때

#### 2. 테스트 수정 허용 조건

다음 조건이 **명확히 증명될 때만** 테스트 수정 가능:

- 요구사항 변경이 명시적으로 문서화됨
- 테스트 자체의 논리적 오류가 증명됨
- 테스트 환경/도구의 제약사항이 발견됨

#### 3. 변경 추적 문서화 템플릿

```markdown
### 테스트/구현 변경 기록

**변경 유형**: [구현 코드 / 테스트 코드]

**원인 분석 결과**:

- Phase 1 진단: [요약]
- Phase 2 원인: [체크리스트 결과]
- Phase 3 교차 검증: [삼각 검증 결과]

**근거**:

- 요구사항 참조: [문서 경로 및 섹션]
- 로그 분석: [로그 내용]
- 디버깅 결과: [발견 사항]

**영향 분석**:

- 다른 테스트: [영향받는 테스트 목록]
- 다른 기능: [영향받는 기능 목록]

**검증 계획**:

- 변경 후 재검증 방법: [절차]
- 회귀 테스트 범위: [테스트 목록]
```

### 5.5 테스트 실행 순서 (자동화 기준)

```
1. Unit Tests
   ↓ (실패 시: 5.3 원인 판별 프로토콜 실행)
2. Integration Tests
   ↓ (실패 시: 5.3 원인 판별 프로토콜 실행)
3. Performance Tests
   ↓ (실패 시: 5.3 원인 판별 프로토콜 실행)
4. Security Tests
   ↓ (실패 시: 5.3 원인 판별 프로토콜 실행)
5. E2E Tests
   ↓ (실패 시: 5.3 원인 판별 프로토콜 실행)
```

**각 단계 실패 시**:

1. 즉시 중단
2. 5.3 테스트 실패 원인 판별 프로토콜 실행
3. 원인 분석 완료
4. 수정 (구현 또는 테스트)
5. 해당 단계부터 재실행

---

## 6) 품질 임계점 (Quality Thresholds)

### 6.1 필수 달성 기준

| 지표                | 최소 기준              | 권장 기준            |
| ------------------- | ---------------------- | -------------------- |
| **테스트 통과율**   | 100%                   | 100%                 |
| **라인 커버리지**   | 80%                    | 90%                  |
| **브랜치 커버리지** | 75%                    | 85%                  |
| **함수 커버리지**   | 90%                    | 95%                  |
| **조건 커버리지**   | 70%                    | 80%                  |
| **정적 분석 등급**  | A                      | A+                   |
| **보안 취약점**     | High/Critical 0개      | Medium 이하도 0개    |
| **성능**            | 기존 대비 ±5%          | 기존 대비 +10% 개선  |
| **테스트 신뢰도**   | Phase 3 교차 검증 통과 | 모든 Phase 완벽 통과 |

### 6.2 커버리지 미달 시 대응

**80% 미만인 경우**:

1. 미커버 영역 식별
2. 테스트 추가 필요성 판단
3. 정당한 예외 사유 문서화 (있는 경우)
4. 추가 테스트 작성

**예외 허용 케이스**:

- 생성된 코드 (자동 생성 파일)
- 외부 라이브러리 래퍼 (단순 전달만 하는 경우)
- 디프리케이션 예정 코드 (명시된 경우)

---

## 7) 구현 및 검증 규칙

### 7.1 핵심 원칙

**TEST-FIRST**:

- 코드 수정 전 테스트 작성 (Red)
- 최소 구현으로 통과 (Green)
- 리팩터링 및 개선 (Refactor)

**독립성**:

- 테스트 간 상태 의존 금지
- 픽스처/시드 일관화
- 실행 순서 무관하게 동작

**관찰 가능성**:

- 의미 있는 실패 메시지
- 로그 키 표준화
- 아티팩트 경로 명시

**호환성**:

- 기존 퍼블릭 API 파괴 금지
- 불가피한 경우: 마이그레이션 경로 문서화
- 디프리케이션 정책 명시

**파괴적 변경**:

- 백업 절차 없이 실행 금지
- 드라이런 먼저 실행
- 롤백 절차 준비

**테스트 무결성**:

- 테스트 수정 시 반드시 5.3 프로토콜 준수
- 변경 추적 문서화 필수

### 7.2 린트 및 타입 체크

**실행 시점**:

- 테스트 작성 후 반드시 실행
- `{린트-타입체크-지침경로}` 문서의 지침에 따라 진행

**검증 항목**:

- 코드 스타일 준수
- 타입 안정성
- 코드 품질 지표

---

## 8) 결과물 형식 (필수 출력 구조)

### 8.1 콘솔 완료 보고

테스트 작성 및 검증 완료 후, 콘솔에 아래 형식으로 보고:

```markdown
━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
✅ 테스트 작업 완료: [1줄 요약]
━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━

📦 산출물 요약
• 테스트 코드: tests/unit/[파일명]\_test.py (단위 테스트)
• 테스트 코드: tests/integration/[파일명]\_test.py (통합 테스트)
• 수정 코드: src/[파일명].py
• 커버리지: [라인 XX% / 브랜치 YY%]

📂 변경 상세
**파일별 변경점**:
• [파일명]: [변경 내용 요약]

**리팩터링**:
• [이유]: [효과]

**리스크 및 완화책**:
• [리스크]: [완화 방안]

🧪 테스트 개요
**테스트 시나리오** (총 N개):
• 성공 시나리오: X개
• 실패 시나리오: Y개
• 경계값 테스트: Z개
• 성능 테스트: A개 (필요시)
• 보안 테스트: B개 (필요시)

**커버리지 지표**:
• 라인: XX% (목표: ≥80%)
• 브랜치: YY% (목표: ≥75%)
• 함수: ZZ% (목표: ≥90%)
• 조건: AA% (목표: ≥70%)

**테스트 실패 분석** (있는 경우):
• 원인: [Phase 1-4 분석 결과 요약]
• 수정: [구현/테스트 수정 내용]
• 검증: [재검증 결과]

**품질 지표**:
• 정적 분석: [등급]
• 보안 스캔: [취약점 수]
• 성능: [기존 대비 변화]

**잔여 리스크**:
• [있다면 나열]

📋 다음 단계

1.  린트 체크: {린트-타입체크-지침경로} 참조
2.  통합 테스트 실행 확인
3.  코드 리뷰 준비

━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
```

---

### 8.2 이번 유닛과 무관한 실패/보류 이슈 기록 (필수)

테스트 과정에서 **이번 유닛의 목표와 직접적인 관계가 없으나** 발견된 실패, 오류, 또는 이상 징후가 있다면, 이를 무시하지 말고 **`{회기-기록-경로}`** 파일에 기록해야 한다.

**기록 조건**:

- 이번 작업 범위(Unit) 밖의 문제로 판단되는 경우
- 당장 해결하기 어렵거나 시간이 많이 소요되어 '나중에 해결'로 분류한 경우
- 간헐적으로 발생하는 Flaky Test 등

**실행 방법**:

- `File Write` 도구를 사용하여 `{회기-기록-경로}` 파일에 **내용을 덧붙인다 (Append)**.

**기록 형식 (Markdown)**:

```markdown
## [YYYY-MM-DD] 이슈: [이슈명 간단 요약]

- **발견 위치**: [파일명 또는 모듈명]
- **현상**: [에러 메시지 또는 이상 동작 설명]
- **추정 원인**: [분석한 내용 간략 기술]
- **보류 사유**: 이번 유닛([유닛명/번호]) 범위 밖임 / 시간 부족 / 추가 분석 필요 등
```

---

## 9) 테스트 수정 체크리스트 (필수 확인)

테스트 코드를 수정하기 전 **반드시** 아래 모든 항목을 확인:

- [ ] 테스트 실패 원인 판별 프로토콜 (5.3) 완료
- [ ] 삼각 검증 (수동/로그/디버거) 수행
- [ ] 요구사항 문서와 일치성 확인
- [ ] 실제 사용 시나리오 반영 확인
- [ ] 수정 정당성 3개 질문에 모두 YES 답변
- [ ] 변경 추적 문서 작성
- [ ] 교차 테스트 영향도 분석
- [ ] 회귀 테스트 계획 수립

**위 항목 중 하나라도 미완료 시 테스트 수정 금지**

---

## 10) 안티패턴 경고 (절대 금지)

### 10.1 절대 금지 사항

⚠️ **다음 행동은 절대 금지됨**:

1. **"테스트가 실패하니 테스트를 수정하자"**
   → ❌ 잘못됨: 원인 분석 먼저 필수

2. **"어차피 통과하면 되니까"**
   → ❌ 잘못됨: 정확성과 신뢰성이 우선

3. **"이 정도면 충분해"**
   → ❌ 잘못됨: 교차 검증 필수

4. **"테스트가 너무 엄격해"**
   → ❌ 잘못됨: 요구사항 재확인 필요

5. **"Mock을 조금만 바꾸면..."**
   → ❌ 잘못됨: 실제 동작과 일치 확인 필수

6. **"커버리지를 위한 테스트"**
   → ❌ 잘못됨: 의미 있는 시나리오 테스트 작성

7. **"시간이 없어서 테스트 스킵"**
   → ❌ 잘못됨: 테스트는 필수, 협상 불가

### 10.2 올바른 접근 방식

✅ **올바른 사고 흐름**:

```
테스트 실패 발견
↓
5.3 원인 판별 프로토콜 실행
↓
삼각 검증으로 실제 원인 파악
↓
구현 코드 문제? → 구현 수정
테스트 코드 문제? → 요구사항 재확인 후 수정
↓
회귀 테스트 실행
↓
완료
```

---

## 11) 최종 체크리스트 (제출 전 필수 확인)

작업 완료 후 아래 모든 항목을 확인:

### 11.1 분석 단계

- [ ] 맥락·요구·제약·영향 분석 완료
- [ ] 근거 문서 경로 최소 2개 이상 인용
- [ ] 테스트 시나리오 범위 명시

### 11.2 TDD 주기

- [ ] Red 단계 산출물 존재 (실패하는 테스트)
- [ ] Green 단계 산출물 존재 (통과하는 최소 구현)
- [ ] Refactor 단계 산출물 존재 (개선된 코드)

### 11.3 테스트 품질

- [ ] 테스트 피라미드 대비 시나리오 균형 (70/20/10)
- [ ] 모든 테스트 통과 (100%)
- [ ] 커버리지 임계치 달성 (라인≥80%, 브랜치≥75%, 함수≥90%)
- [ ] 정적 분석 등급 A 이상
- [ ] 보안 취약점 High/Critical 0개
- [ ] 성능 저하 없음 (±5% 이내)

### 11.4 문서화

- [ ] 회귀 위험 명시
- [ ] 완화책 문서화
- [ ] 롤백 절차 명시

### 11.5 테스트 무결성

- [ ] 테스트 실패 시 원인 판별 프로토콜 준수 여부 확인
- [ ] 테스트 수정 시 체크리스트 완료 여부 확인
- [ ] 변경 추적 문서 작성 완료

### 11.6 린트 및 품질

- [ ] `{린트-타입체크-지침경로}` 지침에 따라 검증 완료
- [ ] 코드 스타일 준수
- [ ] 타입 안정성 확보

---

## 12) 작업 지시사항 및 추가 정보
</file>

<file path="vibe/ready/lint-ignore-prompt.md">
# 린트 제외(IGNORE/EXCLUDE) 설정 생성 프롬프트

## 당신의 역할

당신은 프로젝트의 코드 품질(포맷/린트/타입체크) 자동화를 실무 수준으로 정리하는 **Quality Tooling Engineer**입니다.  
당신의 임무는 프로젝트 규칙을 근거로, 품질 도구 실행 시 **검사 대상에서 제외(ignored/excluded)되어야 할 파일/디렉토리**를 식별하고, 이를 **도구별 제외 설정**으로 정확히 반영하는 것입니다.

---

## 참조 문서(필수)

1. `.gemini/rules/lint-rules.md`  
   - 프로젝트의 **사용 도구/명령어/설정 파일(또는 템플릿)/실행 위치**가 정의된 SSOT 엔트리입니다.
2. `vibe/ready/lint-prompt.md`  
   - “규칙 기반 품질 문서/설정 생성” 프롬프트의 톤/구조/제약을 따릅니다.

> 필요 시(충돌 해결/근거 확보) 아래도 참고하되, 우선순위는 `vibe/prd.md` > `vibe/tech-stack.md` > `vibe/ref/*` 입니다.

---

## 작업 지시

아래 단계를 **순서대로** 수행하세요.

### 1) 규칙 판독 및 실행 컨텍스트(루트/도구/설정) 확정

- `.gemini/rules/lint-rules.md`를 먼저 읽고, 이 프로젝트가 실제로 사용하는 아래 항목을 **문서 근거와 함께** 확정하세요.
  - **품질 단계 종류**: Formatter / Linter / Type checker(또는 Static analysis) 중 어떤 단계를 쓰는지
  - **도구 목록**: 각 단계에서 사용하는 도구 이름(예: “어떤 포맷터/린터/타입체커인지”)
  - **실행 루트**: 레포 루트인지, 특정 서브디렉토리(`cd ...`)인지, 모노레포 패키지별인지
  - **설정 파일/템플릿 경로**: 각 도구가 참조하는 설정 파일의 경로(없으면 템플릿/생성 위치)
  - **ignore/exclude 적용 지점**: 해당 도구가 제외를 어디에 정의하는지(예: 별도 ignore 파일 / 설정 파일 키 / CLI 옵션 등)

> 🔎 **프로젝트 특이사항(중요)**  
> 이 레포의 품질 도구 표준 명령은 `frontend/`, `backend/` 하위에서 실행됩니다(`cd frontend && ...`, `cd backend && ...`).  
> 따라서 **`vibe/`는 기본 실행 범위(포맷/린트/타입체크 대상)에 포함하지 않습니다.**  
> - 예: `pnpm run format`/`lint`/`typecheck` 스크립트에 `../vibe` 같은 경로를 추가해 “대상 확장”하지 않습니다.  
> - `vibe/`를 억지로 포함/제외하려고 ignore 규칙을 넓히지 말고, **각 실행 루트(frontend/backend) 내부의 생성물/캐시/의존성만** 최소 제외로 설계하세요.  
> (특별히 `vibe/`까지 포맷해야 한다는 명시 요구가 있을 때만, 별도 합의/근거 후 범위를 확장합니다.)

### 2) 레포 구조/현황 스캔(증거 기반)

- 현재 레포를 스캔하여 “실제로 존재하거나 생성될 것이 확실한(문서 근거 포함)” 경로를 수집하세요.
  - 빌드 산출물(예: `dist/`, `build/`, `out/`, `coverage/` 등)
  - 의존성/가상환경(예: `node_modules/`, `.venv/` 등)
  - 캐시/임시 파일(예: 각 도구의 캐시 디렉토리/리포트 출력물)
  - 생성물/아티팩트(예: 로그, 리포트, 스냅샷/스크린샷 출력 폴더 등)
- 이미 존재하는 관련 파일을 확인하여 **중복/충돌**을 피하세요.
  - 예: `.gitignore`, 도구별 ignore 파일, 기존 설정 파일의 exclude/ignore 섹션

### 3) 제외(IGNORE/EXCLUDE) 정책 설계(과도한 무시 금지)

- 제외 규칙은 **최소한(minimal)** 으로 설계합니다.
- 다음은 기본적으로 **제외 금지(대상 유지)** 입니다(특별한 근거가 없는 한).
  - 소스 코드 디렉토리(예: `src/`, `app/`, `packages/*/src/` 등)
  - 테스트/스펙/검증용 디렉토리(예: `test/`, `tests/`, `__tests__/` 등)
  - 설정/스키마/문서/프롬프트 디렉토리(프로젝트에 따라 이름이 다를 수 있음)
- “문제 회피” 목적의 광범위 제외(예: 소스 트리 통째 제외)는 금지합니다.
- 특정 파일/폴더를 제외해야 한다면 **왜 제외해야 하는지(도구 한계/생성물/외부 의존 등) 근거를 명시**하세요.

### 4) 도구별 제외 설정 파일 생성/수정

`.gemini/rules/lint-rules.md`에 정의된 도구/구조에 맞춰, “해당 도구가 지원하는 방식”으로 제외 설정을 생성하거나 수정하세요.

- **공통 원칙**
  - 이미 프로젝트가 사용 중인 방식(기존 ignore 파일/기존 설정 키)이 있다면 **그 방식 우선**
  - 없다면, 해당 도구의 “표준/권장” 방식으로 최소 구성으로 도입
  - 제외 대상은 “생성물/캐시/의존성/가상환경” 위주로 제한

- **Formatter(포맷터) 제외**
  - 포맷터가 별도 ignore 파일을 지원한다면 그 파일을 사용하고,
  - 설정 파일 내 exclude/ignore를 지원한다면 그 키를 사용합니다.
  - 목표: 포맷 대상에서 “생성물/캐시/의존성/가상환경”을 제외

- **Linter(린터) 제외**
  - 린터가 설정 파일에서 ignores/exclude를 지원한다면 그 키를 사용하고,
  - 별도 ignore 파일을 쓰는 생태계라면 그 파일을 사용합니다.
  - 목표: 린트 대상에서 “생성물/캐시/의존성/가상환경”을 제외

- **(선택) 타입체크 제외 설정**
  - 규칙 파일에 타입체크/정적분석 단계가 포함되어 있고, 제외가 필요하다면 해당 도구의 exclude 방식에 맞춰 반영합니다.
  - 단, 이 작업에서 새 타입체크 규칙을 광범위하게 설계하지 말고, **exclude 반영에 필요한 최소 변경만** 수행합니다.

> 설정 파일이 아직 없는 경우에는, 규칙 파일이 지정한 위치/템플릿을 근거로 “exclude/ignore를 담기 위한 **최소 골격(minimal skeleton)**”만 생성하고, 나머지 규칙/플러그인 구성은 추가하지 않습니다.

### 5) 최종 점검(필수)

- 제외 규칙이 “생성물/캐시/의존성/가상환경” 범위를 넘어서지 않는지 점검하세요.
- 기존 `.gitignore` 및 기존 제외 규칙과 충돌/중복이 없는지 점검하세요.
- 프로젝트의 표준 명령(규칙 파일에 정의됨)을 기준으로, 제외가 “의도대로 적용”되는지 확인 방법(예: 어떤 파일이 제외되는지 확인하는 절차)을 함께 제시하세요.

---

## 출력(필수)

### A. 먼저 계획 공유

- 생성/수정할 파일 목록(경로 포함)
- 각 파일에 넣을 제외 규칙의 범주(빌드/캐시/의존성 등)와 근거

### B. 그 다음 실제 산출물 제공

- 각 파일의 최종 내용을 **파일별로** 제시하세요.
- 모든 제외 규칙은 “왜 필요한지”를 짧은 주석/설명으로 남기세요(가능한 포맷에서).
- 제외 규칙은 **프로젝트 기술 스택과 실제 레포 구조를 근거로** 작성하세요(근거 없는 프레임워크 디렉토리 나열 금지).

---

## 제약

- `.gemini/rules/lint-rules.md` 및 상위 SSOT(`vibe/prd.md`, `vibe/tech-stack.md`)와 **충돌 금지**
- 린트가 조용해지도록 소스를 숨기는 방식의 제외 금지
- Windows 환경에서도 동작하도록 경로/패턴을 표준적으로 작성(특정 로컬 절대경로 금지)
- 파일 생성 전 **계획 공유 후 진행** ( `vibe/ready/lint-prompt.md`의 제약을 그대로 적용 )
</file>

<file path="vibe/refactors/RU-001-Q1.md">
# [ID: RU-001-Q1] 실행 방법/문서/설정의 중복과 불일치 제거 (roadmap vs 코드 주석 vs 루트 스크립트 vs Pyright 설정)

## 📌 기본 정보

| 항목               | 내용                     |
| ------------------ | ------------------------ |
| **ID**             | RU-001-Q1                |
| **심각도**         | High                     |
| **카테고리**       | 코드 중복 (Duplication)  |
| **영향 범위**      | `vibe/roadmap.md`, `backend/src/unknown_world/main.py`, `package.json`, `backend/pyproject.toml`, `backend/pyrightconfig.json` |
| **예상 작업 시간** | 30~60분                  |

---

## 🔍 문제점 상세 분석

### 현재 상황

현재 레포에는 “실행 방법”과 “툴 설정”이 여러 군데에 흩어져 있으며, 일부는 서로 모순됩니다.

- `vibe/roadmap.md`의 **빠른 실행**은 `venv + pip + requirements.txt` 및 `--port 8000` 예시를 포함합니다.
- 백엔드 엔트리포인트(`backend/src/unknown_world/main.py`) docstring의 실행 예시는 `uvicorn ... --reload`만 제시되어 기본 포트(8000)로 해석될 수 있습니다.
- 반면 루트 `package.json`은 백엔드를 `--port 8011`로 실행하도록 표준화했습니다.
- Pyright 설정은 `backend/pyproject.toml`와 `backend/pyrightconfig.json`에 **중복**되어 있으며, include 범위가 다릅니다.

이 불일치는 RU-001 목표(“경로/버전/실행 방식의 흔들림 제거”)와 RULE-011(포트 정책), RULE-010(표준 고정) 관점에서 High 리스크입니다.

### 문제가 되는 이유

1. **RULE-011 위반 유도**: 문서/주석이 8000 포트를 유도하면 CORS/연동이 어긋나고 디버깅 비용이 폭증합니다.
2. **팀 표준이 깨짐**: 루트 스크립트/로드맵/주석이 서로 다르면, 신규 유닛(U-005~U-008)에서 실행 환경이 분기됩니다.
3. **Pyright 결과가 실행 위치에 따라 달라질 수 있음**: config가 중복이고 include가 다르면 “왜 어떤 파일은 검사되고 어떤 파일은 안 되는지”가 불명확해집니다.

### 영향받는 코드 위치

- 파일: `vibe/roadmap.md`
  - 라인: 185-199 (“빠른 실행” 섹션)
- 파일: `backend/src/unknown_world/main.py`
  - 라인: 6-9 (docstring 실행 예시)
- 파일: `package.json`
  - 라인: 8-13 (dev 스크립트/포트)
- 파일: `backend/pyproject.toml`
  - 라인: 61-64 (`[tool.pyright]`)
- 파일: `backend/pyrightconfig.json`
  - 라인: 1-4 (`include: ["."]`)

### 현재 코드 예시

```markdown
# vibe/roadmap.md (발췌)
uvicorn unknown_world.main:app --reload --port 8000
```

```python
# backend/src/unknown_world/main.py (발췌)
실행 방법:
    cd backend
    uvicorn unknown_world.main:app --reload
```

```json
// package.json (발췌)
"dev:back": "cd backend && uv run uvicorn unknown_world.main:app --reload --port 8011"
```

---

## 💡 개선 방안

### 제안하는 접근법

**“실행/설정의 단일 출처(SSOT)”를 정하고, 나머지는 그 SSOT를 참조하게 만듭니다.**

권장 SSOT:

- **실행 커맨드 SSOT**: 루트 `package.json` 스크립트
- **문서 SSOT(빠른 실행)**: `vibe/roadmap.md`는 위 스크립트를 그대로 안내
- **툴 설정 SSOT**: Pyright는 한 곳(`pyrightconfig.json` 또는 `pyproject.toml`)으로 통일

### 구체적 실행 단계

#### Step 1: `vibe/roadmap.md` “빠른 실행”을 현재 구조(uv, 포트 정책)에 맞게 정리

**변경 전(문제 예시):**

```bash
# Backend (예시: venv + pip)
python -m venv .venv
source .venv/Scripts/activate
pip install -r backend/requirements.txt
uvicorn unknown_world.main:app --reload --port 8000
```

**변경 후(권장):**

```bash
# Frontend (RULE-011: 8001~8010)
pnpm -C frontend install
pnpm -C frontend dev

# Backend (uv 기반, RULE-011: 8011~8020)
cd backend
uv sync
uv run uvicorn unknown_world.main:app --reload --port 8011
```

> 주의: `frontend/vite.config.ts`가 기본 포트 8001을 사용하도록 설정되어 있으므로, roadmap에는 “8001에서 뜬다”를 명시합니다.

#### Step 2: `backend/src/unknown_world/main.py` docstring 실행 예시를 루트 스크립트/포트 정책과 일치

**변경 전:**

```python
실행 방법:
    cd backend
    uvicorn unknown_world.main:app --reload
```

**변경 후:**

```python
실행 방법:
    cd backend
    uv sync
    uv run uvicorn unknown_world.main:app --reload --port 8011
```

#### Step 3: 루트 `package.json`의 프론트 실행을 `pnpm -C`로 통일 (경로/쉘 의존성 감소)

**변경 전:**

```json
"dev:front": "cd frontend && pnpm dev"
```

**변경 후:**

```json
"dev:front": "pnpm -C frontend dev"
```

#### Step 4: Pyright 설정을 단일화 (중복/불일치 제거)

권장안(둘 중 하나를 선택):

- **Option A(권장)**: `backend/pyrightconfig.json`만 SSOT로 사용하고 `pyproject.toml`의 `[tool.pyright]` 제거
  - 이유: IDE/CI에서 `pyrightconfig.json`을 가장 표준적으로 인식
- **Option B**: `pyproject.toml`만 SSOT로 사용하고 `backend/pyrightconfig.json` 제거

추가로, include 범위를 명확히 권장:

- MVP 기준으로는 **`src`만** 포함(테스트는 필요 시 별도)

### 대안적 접근법 (선택사항)

- **대안 1(최소 변경)**: 문서(`vibe/roadmap.md`)만 최신화하고, 코드 주석/스크립트는 그대로 둠
  - 장점: 변경량 최소
  - 단점: 시간이 지나면 주석/스크립트가 다시 분기되어 drift 재발 가능
- **대안 2(강경 SSOT)**: `vibe/roadmap.md`에서 “빠른 실행”을 삭제하고 루트 스크립트만 안내
  - 장점: SSOT를 강제할 수 있음(복사/붙여넣기 방지)
  - 단점: 문서가 너무 불친절해질 수 있어, 최소한의 예시는 남기는 편이 현실적
- **대안 3(추가 도구 도입)**: `justfile`/`Makefile` 등으로 실행 표준을 추가
  - 장점: 명령 표준화 강화
  - 단점: RU-001 범위를 넘어설 수 있음(팀 도구 합의 필요)

---

## 📈 기대 효과

### 즉각적 효과

- ✅ 문서/주석/스크립트가 동일한 실행 커맨드와 포트를 안내 → 온보딩/디버깅 비용 급감
- ✅ RULE-011 포트 정책의 “문서 유도 위반” 제거
- ✅ Pyright 검사 범위가 일관되어 “환경에 따라 결과가 달라짐” 문제 감소

### 장기적 효과

- 🎯 U-005~U-008에서 스키마/스트리밍 구현에 집중 가능(실행 환경 혼란 제거)
- 🎯 RU 계열 리팩토링이 “설정 정리 vs 기능 추가” 경계를 유지하기 쉬워짐

### 정량적 개선 (가능한 경우)

| 지표                         | 현재                 | 개선 후                       | 변화율 |
| ---------------------------- | -------------------- | ----------------------------- | ------ |
| 신규 개발자 실행 성공 시간   | 편차 큼              | 루트 스크립트 기반으로 고정   | ↓      |
| 포트/CORS 관련 이슈 재발률   | 문서/주석 때문에 재발 | 정책(8011/8001) 일관 안내     | ↓      |

---

## ⚠️ 주의사항 및 고려사항

### 리팩토링 시 주의할 점

1. roadmap의 “빠른 실행”은 자주 복사/붙여넣기 되므로, 반드시 최신화 후 유지해야 합니다.
2. Pyright 설정 단일화는 IDE 설정과 충돌 가능성이 있으므로, 선택한 SSOT를 명시해야 합니다.
3. Windows 환경(RU-001 사용자 환경)에서 `cd`/쉘 차이를 줄이기 위해 `pnpm -C`를 권장합니다.

### 영향받는 다른 모듈

- **U-003 런북/문서**: 실행 가이드와 충돌 시 업데이트 필요
- **U-004 런북/문서**: 프론트 실행 포트 안내와 정합성 필요

### 호환성 체크리스트

- [ ] 기존 루트 스크립트로 프론트/백엔드가 정상 실행되는가?
- [ ] 프론트 8001, 백엔드 8011 정책이 문서/주석/스크립트에서 일치하는가?
- [ ] Pyright가 같은 범위를 검사하는가(실행 위치/IDE 상관없이)?

---

## 🧪 검증 방법 (수동 검증 중심)

### 변경 전 확인 사항

1. `vibe/roadmap.md`의 빠른 실행을 그대로 따라 했을 때 8000으로 백엔드가 떠서 혼선이 생기는지 확인
2. Pyright 실행 위치에 따라 include 범위가 달라지는지 확인(backend 루트 vs repo 루트)

### 변경 후 검증 시나리오

#### 시나리오 1: 문서/스크립트대로 실행했을 때 같은 결과가 나는지

- **실행 방법**:

```bash
pnpm dev:front
pnpm dev:back
```

- **기대 결과**:
  - 프론트가 `http://localhost:8001`에서 접근 가능
  - 백엔드 `http://localhost:8011/health`가 정상 응답

#### 시나리오 2: Pyright 설정 단일화 후 검사 범위 일관성 확인

- **실행 방법**:
  - IDE에서 backend 파일 열기 → pyright 진단 범위 확인
  - CLI에서 `cd backend && uv run pyright` 실행(팀 표준 커맨드로 고정)

- **기대 결과**:
  - 검사 대상이 의도한 범위(`src`)로 고정

### 회귀 확인 체크리스트

- [ ] 기존 실행 커맨드가 깨지지 않았는가?
- [ ] 문서/주석이 오래된 안내로 되돌아가지 않았는가?

---

## 🔧 실행 가이드

### 개발자를 위한 실행 지침

1. **준비 사항**
   - RULE-011(포트 정책), U-003 결과(uv 사용), 현재 루트 스크립트 확인

2. **실행 절차**

```bash
# 문서(roadmap)와 주석(main.py), 루트 scripts를 함께 정합화
# 변경 후에는 루트 scripts만 보고도 실행 가능해야 함
pnpm dev:front
pnpm dev:back
```

3. **검증 절차**
   - 브라우저로 8001 접근
   - `/health`(8011) 응답 확인

4. **롤백 계획** (필요시)
   - 문서/주석 변경은 쉽게 되돌릴 수 있음
   - 스크립트 변경은 `git checkout package.json`로 복구 가능

### 예상 소요 시간

- 문서/주석/스크립트 정리: 20~40분
- 수동 검증: 10~20분
- 총 예상 시간: 30~60분

---

## 📚 참고 자료

- `vibe/roadmap.md` (빠른 실행 섹션)
- `backend/src/unknown_world/main.py` (docstring)
- `.cursor/rules/00-core-critical.mdc` (RULE-010/011)
- `vibe/unit-results/U-003[Mvp].md` (uv 기반)

---

## 🏷️ 태그

`#refactoring` `#code-quality` `#duplication` `#docs` `#ports` `#tooling`

---

## 📝 노트

- RU-001의 “설정 정리”는 이후 유닛의 개발 속도를 좌우합니다. 기능 추가보다 **정합성(일관된 실행 경험)** 자체가 성능입니다.
</file>

<file path="vibe/refactors/RU-001-Q4.md">
# [ID: RU-001-Q4] `shared/` 기반 JSON Schema SSOT(Option B) 디렉토리 도입 및 소비(backend/ frontend) 경로 고정

## 📌 기본 정보

| 항목               | 내용                     |
| ------------------ | ------------------------ |
| **ID**             | RU-001-Q4                |
| **심각도**         | High                     |
| **카테고리**       | 모듈 설계 (Module Design) |
| **영향 범위**      | (신규) `shared/`, `.gitignore`, U-005/U-006(스키마), U-007/U-008(SSE) |
| **예상 작업 시간** | 45~120분 (단계적 적용)   |

---

## 🔍 문제점 상세 분석

### 현재 상황

RU-001 계획서의 페어링 질문(Q1)은 **Option B(초기부터 `shared/` JSON Schema SSOT)**로 결정되어 있습니다.

```text
vibe/unit-plans/RU-001[Mvp].md
- Q1: 공통 스키마 SSOT?
  - A1: Option B
```

하지만 현재 레포 구조에는 `shared/`(공통 스키마 저장소)가 없고, 동시에 `.gitignore`는 `*.json`을 광범위하게 ignore 합니다. 즉, **Option B를 선택했지만 실제 구조가 이를 실현하지 못하는 상태**입니다.

### 문제가 되는 이유

1. **Turn 계약이 분기될 위험**: U-005(Pydantic)와 U-006(Zod)가 각각 스키마를 만들면 drift가 쉽게 발생합니다(RULE-003 위반 위험).
2. **오케스트레이터/프론트가 다른 계약을 믿는 상태로 진행**: SSE/Agent Console/Badges 구현(U-007/U-008) 시 “서로 다른 TurnOutput 가정”이 누적됩니다.
3. **스키마를 LLM에 강제하기 어렵다**: Structured Output(LLM response_json_schema)을 “한 곳”에서 관리하지 않으면, 모델 호출마다 제약이 달라질 수 있습니다(RULE-010 관점).

### 영향받는 코드 위치

- 파일: `vibe/unit-plans/RU-001[Mvp].md`
  - 라인: 83-89 (페어링 Q1 결정)
- 파일: `.gitignore`
  - 라인: 11-15 (`*.json` ignore 정책 — SSOT JSON 도입의 직접 장애물)

### 현재 코드 예시

현재 구조에는 `shared/`가 존재하지 않으며, `.gitignore`는 다음과 같이 JSON 전체를 차단합니다.

```gitignore
*.json
!package.json
!tsconfig.json
!pyrightconfig.json
```

---

## 💡 개선 방안

### 제안하는 접근법

**`shared/`에 “Turn 계약(JSON Schema)”을 고정하고, 백엔드/프론트는 이를 소비(또는 생성물로 변환)만 하게 합니다.**

핵심 원칙:

- **SSOT는 `shared/schemas/`** (사람이 읽고 리뷰 가능한 파일)
- 백엔드/프론트의 타입/검증 코드는 **SSOT로부터 생성/동기화** (drift 방지)
- 언어/런타임 차이(파이썬 vs TS)는 “생성 단계”에서 해결

### 구체적 실행 단계

#### Step 1: `shared/` 디렉토리 구조 확정 (초기 범위는 TurnInput/TurnOutput)

권장 구조(예시):

```text
shared/
  schemas/
    turn/
      turn_input.schema.json
      turn_output.schema.json
  README.md
```

초기에는 PRD의 Turn 계약(필드 구조)에서 “MVP 최소키”만 먼저 고정하고, U-005~U-008에서 점진적으로 확장합니다.

#### Step 2: `.gitignore`에서 `shared/**/*.json` allowlist 적용 (S1 제안과 연동)

**변경 후 예시:**

```gitignore
!shared/**/*.json
**/service-account*.json
**/credentials*.json
```

> 이 단계는 **RU-001-S1**과 함께 수행되어야 Option B가 실현됩니다.

#### Step 3: 소비 전략 결정 — “생성물 기반 동기화”로 drift 제거

Option B(SSOT=JSON Schema)를 현실적으로 운영하기 위한 2가지 경로:

##### 경로 A(권장, 생성물 기반)

- **Backend(Python)**: JSON Schema → Pydantic 모델 생성(예: `datamodel-code-generator`)
- **Frontend(TS)**: JSON Schema → Zod 스키마 생성(예: `json-schema-to-zod`)
- 생성물은 `backend/src/unknown_world/schemas/generated/*.py`, `frontend/src/schemas/generated/*.ts` 등에 저장

장점: “SSOT는 JSON Schema” 원칙을 엄격히 지킴  
단점: generator 도구/스크립트가 필요(단, dev-only로 충분)

##### 경로 B(과도기, 수동 동기화)

- U-005/U-006에서 Pydantic/Zod를 각각 작성하되,
- **PR 리뷰에서 반드시 shared schema와 수동 비교**(체크리스트)

장점: 도구 도입을 미룸  
단점: 사람에 의존 → drift 가능(Option A에 가까워짐)

RU-001의 결론(Option B)을 존중한다면, MVP라도 **경로 A의 최소 형태(한 번의 생성 스크립트라도)**는 도입하는 편이 안전합니다.

---

## 📈 기대 효과

### 즉각적 효과

- ✅ U-005/U-006에서 “서로 다른 Turn 계약”이 만들어지는 것을 구조적으로 차단
- ✅ LLM Structured Output JSON Schema를 한 곳에서 관리 가능
- ✅ 이후 RU-010[Mmp](스키마/상수 SSOT 강화)의 선행 기반 구축

### 장기적 효과

- 🎯 스키마 변경 시 영향 범위가 명확해지고, “클라/서버 동시 변경”이 자동으로 안내됨
- 🎯 Repair loop/Hard gate 설계가 안정화(스키마 drift 제거)

### 정량적 개선 (가능한 경우)

| 지표                   | 현재      | 개선 후                         | 변화율 |
| ---------------------- | --------- | ------------------------------- | ------ |
| Turn 계약 drift 빈도   | 높아질 수 있음 | 낮음(shared schema 기반)         | ↓      |
| 스키마 변경 반영 시간  | 수동/느림 | 생성/동기화 경로로 빠름          | ↓      |

---

## ⚠️ 주의사항 및 고려사항

### 리팩토링 시 주의할 점

1. JSON Schema는 “지원되는 부분집합” 범위로 단순하게 유지해야 합니다(PRD/가이드 준수).
2. `additionalProperties: false` 등 엄격 모드 도입 시, 초기에는 파손이 잦을 수 있으므로 단계적으로 강화합니다.
3. 스키마 파일은 “프롬프트 원문”이 아니라 계약 문서이므로 커밋해도 보안 위험이 없습니다(단, 비밀값 포함 금지).

### 영향받는 다른 모듈

- **Backend Orchestrator(U-017/U-018)**: response_json_schema의 SSOT 경로가 고정됨
- **Frontend Zod 검증(U-006)**: 생성물 경로/임포트 구조가 고정됨

### 호환성 체크리스트

- [ ] `shared/` 경로가 루트 기준으로 고정되었는가?
- [ ] `.gitignore`가 `shared/**/*.json`을 허용하는가?
- [ ] 생성물 경로가 “소스 오염(생성물 커밋 여부)” 정책과 합의되었는가?

---

## 🧪 검증 방법 (수동 검증 중심)

### 변경 전 확인 사항

1. 현재 레포에 `shared/`가 없어서 스키마 공유가 불가능함을 확인
2. `.gitignore`가 JSON을 차단해 스키마 커밋이 불가능함을 확인

### 변경 후 검증 시나리오

#### 시나리오 1: `shared/schemas`가 정상적으로 Git에 추적되는지 확인

- **실행 방법**:

```bash
mkdir -p shared/schemas/turn
echo "{\"type\":\"object\"}" > shared/schemas/turn/_check.schema.json
git status --porcelain
git check-ignore -v shared/schemas/turn/_check.schema.json || echo "NOT IGNORED ✅"
```

- **기대 결과**:
  - 새 파일이 추적 대상으로 표시된다.

#### 시나리오 2: (도입 시) 생성물 경로가 한 번에 갱신되는지 확인

- **실행 방법**: 팀이 합의한 생성 스크립트 실행
- **기대 결과**:
  - backend/ frontend의 생성물이 동일 스키마에 맞게 갱신된다.

### 회귀 확인 체크리스트

- [ ] U-005/U-006이 “각자 스키마 작성”으로 회귀하지 않는가?
- [ ] `shared/`가 단순 문서 폴더로 방치되지 않는가?

---

## 🔧 실행 가이드

### 개발자를 위한 실행 지침

1. **준비 사항**
   - RU-001 페어링 Q1 결정(Option B) 재확인
   - RU-001-S1(.gitignore)과 함께 적용할 것

2. **실행 절차**

```bash
# 1) shared/ 디렉토리 추가
mkdir -p shared/schemas/turn

# 2) 스키마 파일 추가(초기 최소)
# 3) .gitignore allowlist 적용
```

3. **검증 절차**
   - `git check-ignore`로 추적 여부 확인

4. **롤백 계획** (필요시)
   - `shared/` 폴더를 제거하고 관련 문서/스크립트만 되돌리면 됨

### 예상 소요 시간

- 디렉토리/초기 스키마 생성: 15~30분
- (선택) 생성물 스크립트 도입: 30~90분
- 총 예상 시간: 45~120분

---

## 📚 참고 자료

- `vibe/unit-plans/RU-001[Mvp].md` (페어링 Q1)
- `vibe/prd.md` (TurnInput/TurnOutput 초안)
- `vibe/ref/structured-outputs-guide.md` (JSON Schema 제약)
- `.cursor/rules/00-core-critical.mdc` (RULE-003/010)

---

## 🏷️ 태그

`#refactoring` `#module-design` `#schema-ssot` `#shared` `#high`

---

## 📝 노트

- 이 제안은 “Option B를 선택했다면 구조가 Option B를 강제해야 한다”는 관점의 최소 설계입니다.
</file>

<file path="vibe/refactors/RU-001-Q5.md">
# [ID: RU-001-Q5] 버전 고정(SSOT) 강화: 루트 `packageManager`/엔진 명시 + backend dev 의존성 pin(uv.lock 기준)

## 📌 기본 정보

| 항목               | 내용                     |
| ------------------ | ------------------------ |
| **ID**             | RU-001-Q5                |
| **심각도**         | Medium                   |
| **카테고리**       | 하드코딩 (Hard-coded Values) |
| **영향 범위**      | `package.json`, `backend/pyproject.toml`, `backend/uv.lock`, `vibe/tech-stack.md` |
| **예상 작업 시간** | 20~40분                  |

---

## 🔍 문제점 상세 분석

### 현재 상황

`vibe/tech-stack.md`는 “버전 고정/lockfile 기반 재현성”을 SSOT로 강제합니다(RULE-010).

현재 프론트는 `frontend/package.json`에 `packageManager: "pnpm@10.27.0"`가 명시되어 있으나, **루트 `package.json`에는 packageManager/engine 정보가 없습니다.**  
또한 백엔드는 `backend/pyproject.toml`의 dev dependency가 `>=` 형태로 되어 있어, lockfile(`backend/uv.lock`)과 실제 설치 버전이 **드리프트**할 여지가 있습니다.

### 문제가 되는 이유

1. **도구 버전 드리프트**: 루트에서 `pnpm` 버전이 달라지면 실행 스크립트/lockfile 해석이 달라질 수 있습니다.
2. **RULE-010 위반 위험**: “최신이라서” 도구/의존성이 올라가면 데모 재현성이 깨집니다.
3. **backend dev dependency는 실제로 실행 흐름에 영향**: 예를 들어 `pytest`/`httpx`는 통합 검증 및 개발 루프에서 사용되며, 버전 상승은 예상치 않은 실패/경고를 유발할 수 있습니다.

### 영향받는 코드 위치

- 파일: `package.json`
  - 라인: 1-14 (루트 packageManager 미기재)
- 파일: `backend/pyproject.toml`
  - 라인: 22-28 (dev deps가 `>=`)
- 파일: `backend/uv.lock`
  - 라인: (패키지 엔트리) `pytest 9.0.2`, `httpx 0.28.1` (해결된 버전 확인 가능)

### 현재 코드 예시

```toml
# backend/pyproject.toml (발췌)
[dependency-groups]
dev = [
    "ruff==0.14.10",
    "pyright==1.1.407",
    "pytest>=9.0.2",
    "httpx>=0.28.1",
]
```

```toml
# backend/uv.lock (발췌)
name = "pytest"
version = "9.0.2"
...
name = "httpx"
version = "0.28.1"
```

---

## 💡 개선 방안

### 제안하는 접근법

**“SSOT(tech-stack) + lockfile(uv.lock/pnpm-lock)”를 기준으로, 루트에도 동일한 고정 신호를 준다**가 목표입니다.

즉:

- 루트에 `packageManager`를 명시하여 pnpm 버전을 고정
- 백엔드 dev deps는 `uv.lock`에 이미 해결된 버전으로 pin(드리프트 방지)
- (선택) `engines`로 Node 버전도 명시하여 팀 온보딩 비용 감소

### 구체적 실행 단계

#### Step 1: 루트 `package.json`에 `packageManager`를 추가 (pnpm 버전 SSOT 신호)

**변경 전:**

```json
{
  "name": "unknown-world",
  "version": "0.1.0",
  "private": true
}
```

**변경 후(권장):**

```json
{
  "name": "unknown-world",
  "version": "0.1.0",
  "private": true,
  "packageManager": "pnpm@10.27.0"
}
```

> 근거: `vibe/tech-stack.md` 1.1에서 pnpm `10.27.0` 권장.

#### Step 2: `backend/pyproject.toml` dev deps를 `uv.lock` 해결 버전으로 pin

**변경 전:**

```toml
"pytest>=9.0.2",
"httpx>=0.28.1",
```

**변경 후(권장):**

```toml
"pytest==9.0.2",
"httpx==0.28.1",
```

> 근거: `backend/uv.lock`에 이미 `pytest 9.0.2`, `httpx 0.28.1`로 해결되어 있음.

#### Step 3(선택): 루트에 `engines`를 추가해 Node 버전 편차를 줄이기

`vibe/tech-stack.md`의 Node 버전(24.12.0)을 팀 표준으로 사용할 경우:

```json
"engines": {
  "node": "24.12.0"
}
```

> Windows 개발 환경에서 강제 도구를 추가하지 않고도 “권장 버전”을 명시하는 효과가 있습니다.

### 대안적 접근법 (선택사항)

- **대안 1**: dev deps `>=` 유지 + `uv.lock`만 신뢰
  - 장점: pyproject 변경이 적음
  - 단점: “사람이 lockfile을 항상 지킨다”는 가정이 필요(드리프트 가능)
- **대안 2**: tech-stack에 pytest/httpx 버전까지 SSOT로 추가하고 전부 pin
  - 장점: 문서-코드 정합성 최대
  - 단점: tech-stack의 유지보수 범위가 커짐(하지만 장기적으로는 더 안정적)

---

## 📈 기대 효과

### 즉각적 효과

- ✅ 개발 환경에서 pnpm 버전 혼선 감소(루트에서도 고정 신호)
- ✅ 백엔드 dev deps 드리프트 제거(uv.lock과 일치)
- ✅ RULE-010(임의 업그레이드 금지) 준수 강화

### 장기적 효과

- 🎯 데모 재현성/온보딩 성공률 향상(“환경이 달라서 안 됨” 유형 감소)

### 정량적 개선 (가능한 경우)

| 지표                    | 현재               | 개선 후                  | 변화율 |
| ----------------------- | ------------------ | ------------------------ | ------ |
| 의존성/도구 버전 편차   | 발생 가능           | 낮음(pin + packageManager) | ↓      |
| 실행 환경 이슈(재현성)  | 중간               | 낮음                     | ↓      |

---

## ⚠️ 주의사항 및 고려사항

### 리팩토링 시 주의할 점

1. “pin”은 안정성을 주지만, 업데이트 시에는 반드시 `tech-stack` 근거와 함께 진행해야 합니다.
2. `engines`는 강제보다 “경고/가이드” 목적이므로, 팀 도구(Volta 등) 도입은 RU-001 범위를 넘지 않게 합니다.

### 영향받는 다른 모듈

- **U-003(UV 기반 백엔드)**: `uv sync` 재현성 강화
- **프론트 빌드/개발 스크립트**: pnpm 버전 일관성 확보

### 호환성 체크리스트

- [ ] 루트에서 `pnpm -v`가 기대 버전인지 확인 가능한가?
- [ ] `uv sync`가 lockfile 기준으로 동일 버전을 설치하는가?

---

## 🧪 검증 방법 (수동 검증 중심)

### 변경 전 확인 사항

1. 루트 `package.json`에 `packageManager`가 없어도 개발이 “되는 것처럼 보이지만”, 팀/환경에 따라 pnpm 버전이 달라질 수 있음을 확인
2. `backend/pyproject.toml`의 dev deps가 `>=`라서, lockfile 업데이트 없이도 설치 버전이 바뀔 가능성이 있음을 확인

### 변경 후 검증 시나리오

#### 시나리오 1: 루트 packageManager 표시 확인

- **실행 방법**:

```bash
node -v
pnpm -v
cat package.json | head -40
```

- **기대 결과**:
  - 루트 `package.json`에 `packageManager: "pnpm@10.27.0"`가 존재

#### 시나리오 2: backend dev deps가 lockfile과 일치하는지 확인

- **실행 방법**:

```bash
cd backend
uv sync
```

- **기대 결과**:
  - `pytest==9.0.2`, `httpx==0.28.1` 기준으로 설치가 재현됨

### 회귀 확인 체크리스트

- [ ] 루트 `packageManager` 값이 임의로 변경/삭제되지 않았는가?
- [ ] backend dev deps가 다시 `>=` 형태로 돌아가지 않았는가?
- [ ] `uv.lock` 갱신 없이 의존성 버전이 드리프트하지 않는가?

---

## 🔧 실행 가이드

### 개발자를 위한 실행 지침

1. **준비 사항**
   - `vibe/tech-stack.md`의 pnpm 버전(10.27.0) 확인
   - backend는 `uv` 기반(uv.lock 존재)임을 확인

2. **실행 절차**

```bash
# 루트: pnpm 버전 확인(팀 표준)
pnpm -v

# 백엔드: lockfile 기반 설치
cd backend
uv sync
```

3. **검증 절차**
   - 루트 `package.json`에 `packageManager`가 존재하는지 확인
   - `backend/uv.lock`의 해결 버전(예: pytest 9.0.2, httpx 0.28.1)과 일치하는지 확인

4. **롤백 계획** (필요시)
   - `package.json`의 `packageManager`/`engines` 변경을 원복
   - `backend/pyproject.toml` dev deps pin 변경을 원복(단, 재현성 저하를 감수)

### 예상 소요 시간

- 설정 수정: 10~20분
- 수동 검증: 10~20분
- 총 예상 시간: 20~40분

---

## 📚 참고 자료

- `vibe/tech-stack.md` (pnpm/Node/Python SSOT)
- `.cursor/rules/00-core-critical.mdc` (RULE-010)
- `backend/uv.lock` (해결 버전 근거)

---

## 🏷️ 태그

`#refactoring` `#hardcoded` `#versions` `#ssot` `#reproducibility`

---

## 📝 노트

- RU-001의 목적은 “기능 구현 속도”를 늦추는 것이 아니라, **데모/개발 재현성(동일한 커맨드가 동일한 결과를 내는 것)**을 빠르게 확보하는 것입니다. MVP일수록 pinning의 가치가 큽니다.
</file>

<file path="vibe/refactors/RU-001-S1.md">
# [ID: RU-001-S1] `.gitignore`의 광범위 `*.json` 차단으로 스키마 SSOT(Option B) 및 안전한 설정 파일 커밋이 “조용히 실패”하는 문제

## 📌 기본 정보

| 항목               | 내용                     |
| ------------------ | ------------------------ |
| **ID**             | RU-001-S1                |
| **심각도**         | Critical                 |
| **카테고리**       | 잠재적 오류 (Potential Bugs) |
| **영향 범위**      | `.gitignore`, (예정) `shared/**/*.json`, 추후 U-005~U-008(스키마/스트리밍) |
| **예상 작업 시간** | 20~40분                  |

---

## 🔍 문제점 상세 분석

### 현재 상황

현재 레포의 `.gitignore`는 보안(RULE-007)을 이유로 **모든 `*.json` 파일을 기본적으로 ignore**하고 일부 파일만 예외 처리하고 있습니다. 이 방식은 초기에는 안전해 보이지만, RU-001의 페어링 결정(**Q1 Option B: `shared/` JSON Schema SSOT**)과 정면 충돌하며, “필수 JSON 파일(스키마/설정)”이 **Git에 추가되지 않는 상태가 정상처럼 보이는** 위험한 형태가 됩니다.

### 문제가 되는 이유

1. **SSOT(스키마) 도입이 구조적으로 막힘**: `shared/schemas/*.json` 같은 “커밋되어야 하는 JSON”이 기본 ignore 됩니다. (RU-001 Q1 Option B 불가)
2. **실패가 조용히 발생**: 개발자가 JSON 스키마 파일을 추가해도 `git status`에 나타나지 않아, 이후 유닛(U-005/U-006)에서 “파일이 없다/스키마가 없다” 같은 문제로 이어집니다.
3. **예외 목록이 계속 늘어나는 유지보수 지옥**: JSON 기반 설정/아티팩트가 늘어날수록 `!xxx.json` 예외를 계속 추가해야 하고, 팀 합의 없이도 쉽게 누락됩니다.

### 영향받는 코드 위치

- 파일: `.gitignore`
- 라인: 11-21
- 함수/클래스: N/A

### 현재 코드 예시

```gitignore
# Vertex AI / GCP Service Account Keys
*.json
!package.json
!tsconfig.json
!pyrightconfig.json
**/service-account*.json
**/credentials*.json
**/keyfile*.json
**/gcp-*.json
**/vertex-*.json
```

또한 현재 레포에는 생성물로 보이는 `frontend/vite.config.d.ts.map`이 Git에 추적되고 있습니다(정리 대상이지만, 지금 상태로는 “무엇이 생성물/무엇이 소스인지” 판단이 더 어려워집니다).

---

## 💡 개선 방안

### 제안하는 접근법

**“JSON 전체 차단” 대신 “비밀 JSON만 강차단 + 스키마/설정 JSON은 허용”** 구조로 바꿉니다.

핵심은 2가지입니다:

- **(A) 위험한 JSON(서비스계정/크리덴셜 등)은 강하게 차단**
- **(B) SSOT에 필요한 JSON(스키마)은 명시적으로 허용**

### 구체적 실행 단계

#### Step 1: `.gitignore`의 `*.json` 전역 차단을 제거/완화하고, 스키마 디렉토리를 allowlist로 허용

**변경 전:**

```gitignore
*.json
!package.json
!tsconfig.json
!pyrightconfig.json
```

**변경 후(권장안):**

```gitignore
# JSON 전체 차단 금지: 스키마/설정 JSON이 늘어나는 프로젝트 특성상 불가
# 대신 "비밀 JSON"을 파일명/경로 기반으로 강차단한다.

# ✅ Shared JSON Schema SSOT (RU-001 Q1 Option B)
!shared/**/*.json

# 🔐 Credential-like JSONs (RULE-007) - 강차단 유지/확대
**/service-account*.json
**/*service_account*.json
**/credentials*.json
**/*credential*.json
**/keyfile*.json
**/gcp-*.json
**/vertex-*.json
```

> 참고: 위 “변경 후”는 예시이며, 실제 적용 시에는 `shared/` 폴더 도입과 함께 병행하는 것이 안전합니다.

#### Step 2: “키 파일은 오직 `secrets/`에만 둔다” 규칙을 문서로 고정하고(README/roadmap), 해당 경로는 계속 ignore

이미 `.gitignore`에 존재하는:

```gitignore
secrets/
.secrets/
```

를 **팀 표준**으로 격상합니다.

#### Step 3: 생성물/산출물 누락 방지(소스 오염 차단) — `*.d.ts.map` 같은 생성물 ignore 보강

현재 `frontend/vite.config.d.ts.map`는 Git에 추적 중입니다.

예시 보강:

```gitignore
# TS build artifacts (frontend)
frontend/*.d.ts.map
frontend/*.d.ts
frontend/*.js.map
```

### 대안적 접근법 (선택사항)

- **대안 1(보수적)**: `*.json` 차단을 유지하되, `!shared/**/*.json`만 추가
  - 장점: 보안 측면에서 “기본 차단” 유지
  - 단점: JSON 설정/아티팩트가 늘어날 때마다 예외가 계속 필요(누락 위험 지속)
- **대안 2(강경)**: 서비스계정 키 파일 커밋 방지용으로 `.gitignore`가 아니라 “Pre-commit/secret scan” 도입
  - 장점: 파일 확장자 기반 차단에서 벗어남
  - 단점: RU-001 범위를 넘어설 수 있음(추후 MMP로 미루는 게 현실적)

---

## 📈 기대 효과

### 즉각적 효과

- ✅ RU-001 페어링 결정(Option B: `shared/` JSON Schema SSOT) 실행 가능
- ✅ “스키마 파일이 Git에 안 들어간 채로 진행”되는 조용한 실패 차단
- ✅ 생성물(예: `*.d.ts.map`)의 오염을 구조적으로 감소

### 장기적 효과

- 🎯 U-005~U-008(스키마/스트리밍)에서 “SSOT 부재/불일치”로 낭비되는 시간을 크게 줄임
- 🎯 보안(RULE-007)과 개발 생산성을 동시에 만족하는 ignore 정책으로 안정화

### 정량적 개선 (가능한 경우)

| 지표                     | 현재                         | 개선 후                              | 변화율 |
| ------------------------ | ---------------------------- | ------------------------------------ | ------ |
| 스키마 파일 커밋 성공률  | 낮음(기본 ignore로 누락 가능) | 높음(`shared/**/*.json` 허용/가드)   | ↑      |
| 신규 JSON 추가 시 실수율 | 예외 추가 누락 가능           | “스키마/설정 허용 + 비밀만 차단”로 ↓ | ↓      |

---

## ⚠️ 주의사항 및 고려사항

### 리팩토링 시 주의할 점

1. `.gitignore` 변경은 “보안 정책”이므로 PRD/RULE 근거를 함께 남겨야 합니다.
2. `shared/` allowlist를 열면, **키 파일이 `shared/`에 들어가는 실수**를 막기 위한 팀 규칙(README 경고)이 필요합니다.
3. `*.json` 전역 차단을 제거할 경우, credential 패턴을 충분히 촘촘하게 유지해야 합니다.

### 영향받는 다른 모듈

- **U-005/U-006**: TurnInput/TurnOutput 스키마 파일 위치가 SSOT가 되므로, 향후 경로 고정에 직접 영향
- **RU-010[Mmp]**: “스키마/상수 SSOT 강화”의 선행 기반이 됨

### 호환성 체크리스트

- [ ] 기존 파일 추적 상태(Tracked files)가 예상치 않게 변하지 않는지 확인
- [ ] 서비스 계정/크리덴셜 JSON이 Git에 올라갈 가능성이 없는지 확인
- [ ] `shared/**/*.json`이 정상적으로 add 되는지 확인

---

## 🧪 검증 방법 (수동 검증 중심)

### 변경 전 확인 사항

1. (예정) `shared/schemas/turn_output.schema.json`을 만들어도 `git status`에 나타나지 않는 현상이 있는지 확인
2. `git check-ignore -v <파일경로>`로 ignore 근거를 확인

### 변경 후 검증 시나리오

#### 시나리오 1: 스키마 JSON이 정상적으로 커밋 대상이 되는지 확인

- **실행 방법**:

```bash
mkdir -p shared/schemas
echo "{\"type\":\"object\"}" > shared/schemas/_ignore-check.schema.json
git check-ignore -v shared/schemas/_ignore-check.schema.json || echo "NOT IGNORED ✅"
git status --porcelain
```

- **기대 결과**:
  - `git check-ignore`가 출력되지 않거나 “NOT IGNORED ✅”가 찍힌다.
  - `git status`에 새 파일이 표시된다.

#### 시나리오 2: 서비스 계정 JSON이 계속 ignore 되는지 확인

- **실행 방법**:

```bash
mkdir -p secrets
echo "{\"type\":\"service_account\"}" > secrets/service-account.json
git check-ignore -v secrets/service-account.json
```

- **기대 결과**:
  - `secrets/service-account.json`은 ignore 근거가 출력된다.

### 회귀 확인 체크리스트

- [ ] 기존 설정 파일들이 갑자기 unignore 되어 노이즈가 증가하지 않았는가?
- [ ] 보안 관련 JSON이 추적 상태로 바뀌지 않았는가?

---

## 🔧 실행 가이드

### 개발자를 위한 실행 지침

1. **준비 사항**
   - `.cursor/rules/00-core-critical.mdc`의 RULE-007/010 확인
   - RU-001 페어링 결정(Q1 Option B) 재확인

2. **실행 절차**

```bash
# 1) .gitignore 수정
# 2) ignore 동작 확인
git check-ignore -v shared/schemas/_ignore-check.schema.json || true
git check-ignore -v secrets/service-account.json || true
```

3. **검증 절차**
   - 위 “수동 검증 시나리오” 2개 수행

4. **롤백 계획** (필요시)
   - `.gitignore` 변경만 되돌리면 됨(파일 추적 상태 변화는 `git rm --cached` 등으로 복구 가능)

### 예상 소요 시간

- 설정 수정: 10~15분
- 수동 검증: 10~15분
- 총 예상 시간: 20~30분

---

## 📚 참고 자료

- 관련 문서: `.cursor/rules/00-core-critical.mdc` (RULE-007/010)
- 관련 문서: `vibe/unit-plans/RU-001[Mvp].md` (페어링 Q1 Option B)
- 관련 문서: `vibe/tech-stack.md` (SSOT, 버전 고정)

---

## 🏷️ 태그

`#refactoring` `#stability` `#critical` `#gitignore` `#security` `#schema-ssot`

---

## 📝 노트

- 이 제안은 “보안 강화”를 약화시키려는 것이 아니라, **스키마 SSOT를 가능하게 하면서도 RULE-007을 더 정확하게 강제**하기 위한 정책 재설계입니다.
</file>

<file path="vibe/refactors/RU-001-S2.md">
# [ID: RU-001-S2] RULE-011 포트 대역 “엣지 케이스” 방지: Vite `strictPort`와 루트 kill 스크립트 범위 정합화

## 📌 기본 정보

| 항목               | 내용                     |
| ------------------ | ------------------------ |
| **ID**             | RU-001-S2                |
| **심각도**         | Medium                   |
| **카테고리**       | 엣지 케이스 (Edge Cases) |
| **영향 범위**      | `frontend/vite.config.ts`, `package.json`, `vibe/roadmap.md`(포트 안내) |
| **예상 작업 시간** | 15~30분                  |

---

## 🔍 문제점 상세 분석

### 현재 상황

프론트는 `frontend/vite.config.ts`에서 기본 포트를 8001로 지정하고 있으나, `strictPort: false`로 인해 **포트 충돌 시 Vite가 임의의 다음 포트로 이동**합니다.

현재 설정:

```ts
server: {
  port: 8001,
  strictPort: false,
}
```

주석에는 “8002~8010 자동 할당”처럼 보이지만, Vite는 상한(8010)을 알지 못합니다. 즉 **8001~8010이 모두 사용 중이면 8011(백엔드 기본 포트) 이상으로 넘어갈 수 있습니다.**

또한 루트 `package.json`의 `kill:port`는 8001~8015까지만 나열되어 있어, RULE-011의 백엔드 대역(8011~8020)을 “부분만” 커버합니다.

### 문제가 되는 이유

1. **RULE-011 위반 가능**: 프론트가 허용 대역(8001~8010)을 벗어나 실행될 수 있습니다.
2. **CORS/연동 이슈가 “랜덤”하게 발생**: 프론트 포트가 예상과 다르면, 백엔드 CORS allowlist(8001~8010)와 어긋납니다.
3. **정리 스크립트가 불완전**: `kill:port`가 전 대역을 커버하지 않으면, 포트 점유 문제 해결이 더 느려집니다.

### 영향받는 코드 위치

- 파일: `frontend/vite.config.ts`
  - 라인: 7-10 (`server.port`, `strictPort`)
- 파일: `package.json`
  - 라인: 8-10 (`kill:port`/`kill:back`)

### 현재 코드 예시

```ts
// frontend/vite.config.ts
server: {
  port: 8001,
  strictPort: false, // 충돌 시 8002~8010 자동 할당 허용 (※ 실제로는 상한 없음)
},
```

```json
// package.json
"kill:port": "npx kill-port 8001 ... 8015"
```

---

## 💡 개선 방안

### 제안하는 접근법

엣지 케이스를 “발생 후 디버깅”이 아니라, **발생 자체를 막는 방향**으로 정리합니다.

- 프론트 포트는 규칙 대역 밖으로 나가지 않게 **fail-fast**
- 포트 정리 스크립트는 RULE-011 대역을 **정확히 커버**

### 구체적 실행 단계

#### Step 1: `frontend/vite.config.ts`에서 `strictPort: true`로 변경하고, “대역 내 수동 선택”을 문서화

**변경 전:**

```ts
strictPort: false
```

**변경 후(권장):**

```ts
strictPort: true
```

그리고 충돌 시에는:

```bash
pnpm -C frontend dev -- --port 8002
```

처럼 **8002~8010 중 하나를 명시적으로 선택**하도록 안내합니다.

#### Step 2: 루트 `kill:port`가 8001~8020을 커버하도록 정리

**변경 전:**

```json
"kill:port": "npx kill-port 8001 ... 8015"
```

**변경 후(권장):**

```json
"kill:port": "npx kill-port 8001 8002 8003 8004 8005 8006 8007 8008 8009 8010 8011 8012 8013 8014 8015 8016 8017 8018 8019 8020"
```

#### Step 3: `vibe/roadmap.md`의 “빠른 실행”에서 포트 안내를 RULE-011과 일치시키고, 충돌 시 대처를 명시

- 프론트: 8001(충돌 시 8002~8010)
- 백엔드: 8011(충돌 시 8012~8020)

### 대안적 접근법 (선택사항)

- **대안 1(현 상태 유지)**: `strictPort: false` 유지 + “현재는 대부분 8001~8010에서만 동작한다”로 합리화
  - 장점: 개발 편의(자동 포트 이동)
  - 단점: 엣지 케이스에서 RULE-011 위반 및 CORS 불일치가 “랜덤”하게 발생
- **대안 2(스크립트 자동 선택)**: `strictPort: true` + “8001~8010에서 비어있는 포트를 찾아 Vite를 실행”하는 스크립트 추가
  - 장점: 대역 준수 + 편의성 모두 확보
  - 단점: RU-001 범위를 약간 넘어설 수 있음(스크립트 합의 필요)

---

## 📈 기대 효과

### 즉각적 효과

- ✅ 프론트가 RULE-011 대역 밖으로 실행되는 엣지 케이스 제거
- ✅ CORS/연동 이슈가 “랜덤”하게 발생하는 상황 감소
- ✅ 포트 정리(킬) 스크립트의 신뢰도 상승

### 장기적 효과

- 🎯 팀/다중 프로세스 환경에서 “왜 오늘은 안 되지?” 유형의 시간 낭비 감소

### 정량적 개선 (가능한 경우)

| 지표                           | 현재                        | 개선 후                               | 변화율 |
| ------------------------------ | --------------------------- | ------------------------------------- | ------ |
| 포트/CORS 관련 “랜덤 실패” 빈도 | 중간(환경에 따라 재현 어려움) | 낮음(fail-fast + 대역 내 명시 실행)   | ↓      |
| 포트 정리(킬) 성공률           | 부분(8016~8020 누락 가능)   | 높음(8001~8020 전 대역 커버)          | ↑      |

---

## ⚠️ 주의사항 및 고려사항

### 리팩토링 시 주의할 점

1. `strictPort: true`는 “자동 포트 이동”을 막기 때문에, 충돌 시 개발자가 포트를 바꿔야 합니다(대신 예측 가능성이 올라갑니다).
2. 포트 대역은 RULE-011에 고정되어 있으므로, 임의로 5173/3000/8000을 문서에 다시 넣지 않도록 주의합니다.

### 영향받는 다른 모듈

- **Backend CORS 설정**: `backend/src/unknown_world/main.py`의 CORS allowlist는 8001~8010을 가정합니다(대역 밖 프론트 실행 시 실패).
- **Docs/Runbooks**: `vibe/roadmap.md`, U-003/U-004 런북의 “포트 안내”가 함께 정합화되어야 합니다.

### 호환성 체크리스트

- [ ] 8001이 사용 중일 때 프론트가 실패하고, 올바른 가이드(8002~8010)가 제공되는가?
- [ ] `kill:port`로 전체 대역 포트 점유를 정리할 수 있는가?

---

## 🧪 검증 방법 (수동 검증 중심)

### 변경 전 확인 사항

1. 8001이 점유된 상태에서 프론트가 8011 이상(백엔드 대역)으로 이동해 실행될 가능성이 있는지 확인
2. `pnpm kill:port`가 8016~8020을 커버하지 않는지 확인

### 변경 후 검증 시나리오

#### 시나리오 1: 포트 충돌 시 fail-fast 확인

- **실행 방법**:
  - 8001을 다른 프로세스가 점유한 상태에서:

```bash
pnpm -C frontend dev
```

- **기대 결과**:
  - 프론트가 “다른 포트로 몰래 이동”하지 않고, 충돌로 종료된다.

#### 시나리오 2: 대역 내 수동 포트로 재실행 확인

- **실행 방법**:

```bash
pnpm -C frontend dev -- --port 8002
```

- **기대 결과**:
  - 8002에서 정상 실행된다.

#### 시나리오 3: 포트 정리 스크립트 범위 확인

- **실행 방법**:

```bash
pnpm kill:port
```

- **기대 결과**:
  - 8001~8020 포트 점유 프로세스가 정리된다(환경에 따라 권한/프로세스 정책은 확인 필요).

### 회귀 확인 체크리스트

- [ ] 프론트가 대역 밖으로 실행되는 사례가 다시 생기지 않았는가?
- [ ] 문서/주석에서 5173/8000 같은 기본 포트 안내가 재등장하지 않았는가?

---

## 🔧 실행 가이드

### 개발자를 위한 실행 지침

1. **준비 사항**
   - RULE-011(포트 정책) 확인
   - 현재 점유 포트 확인(필요 시 `pnpm kill:port` 사용)

2. **실행 절차**

```bash
# 프론트(대역 내에서만)
pnpm -C frontend dev -- --port 8002

# 백엔드(기본 8011)
pnpm dev:back

# 전체 개발 포트 대역 정리(8001~8020)
pnpm kill:port
```

3. **검증 절차**
   - 프론트가 8001~8010 중 하나에서 실행되는지 확인
   - 백엔드 `/health`(8011) 정상 응답 확인

4. **롤백 계획** (필요시)
   - `frontend/vite.config.ts`의 `strictPort`를 원복
   - `package.json`의 `kill:port` 목록을 원복

### 예상 소요 시간

- 설정 수정: 10~15분
- 수동 검증: 10~15분
- 총 예상 시간: 15~30분

---

## 📚 참고 자료

- `.cursor/rules/00-core-critical.mdc` (RULE-011)
- `frontend/vite.config.ts`
- `package.json`

---

## 🏷️ 태그

`#refactoring` `#stability` `#edge-cases` `#ports` `#rule-011`

---

## 📝 노트

- 이 제안은 “편의(자동 포트 이동)”보다 “예측 가능성(대역 준수)”을 우선합니다. CORS/연동 문제는 랜덤하게 보일수록 해결 비용이 커지므로, fail-fast가 MVP 속도를 오히려 올립니다.
</file>

<file path="vibe/refactors/RU-002-Q2.md">
# [ID: RU-002-Q2] PRD Turn Stream Protocol(SSOT)과 구현 계약의 정합성 확보: 프로토콜 버전/필드 별칭/용어 통일

## 📌 기본 정보

| 항목               | 내용                     |
| ------------------ | ------------------------ |
| **ID**             | RU-002-Q2                |
| **심각도**         | High                     |
| **카테고리**       | 네이밍 (Naming)          |
| **영향 범위**      | `vibe/prd.md`(프로토콜 명세), `vibe/unit-runbooks/U-007-mock-orchestrator-runbook.md`, `vibe/unit-runbooks/U-008-http-streaming-client-runbook.md`, `backend/src/unknown_world/api/turn.py`, `frontend/src/api/turnStream.ts` |
| **예상 작업 시간** | 45~90분                  |

---

## 🔍 문제점 상세 분석

### 현재 상황

PRD(SSOT)에는 “Turn Stream Protocol(초안)”이 정의되어 있으나, 현재 구현(U-007/U-008) 및 런북 예시는 **다른 필드/용어를 사용**합니다.

예시(SSOT):

- `stage.name`: `"Parse"` (대문자 표기)  
- `stage.status`: `"start"|"ok"|"fail"`  
- `badges`: `{schema:"ok|fail", economy:"ok|fail", ...}`  
- `final`: `{"type":"final","turn_output":{...}}`

반면 현재 구현/런북은:

- `stage.name`: `"parse"` (소문자, enum 값)  
- `stage.status`: `"start"|"complete"`  
- `badges`: `{badges:["schema_ok", ...]}` (리스트)  
- `final`: `{"type":"final","data":{...}}`  
- 추가로 `error` 이벤트가 존재(PRD 명세에는 없음)

즉, **PRD(SSOT) ↔ 코드/런북(현실)** 간에 “계약 표기”가 어긋나, RU-002의 “용어/이벤트 타입 통일”을 막는 상태입니다.

### 문제가 되는 이유

1. **SSOT 혼선은 곧 통합 리스크**: 향후 실모델 연동(U-016~) 시 다른 사람이 PRD를 보고 구현/디버깅하면 즉시 헷갈립니다.  
2. **계약 변경의 비용이 폭증**: 어떤 문서를 믿어야 하는지 불명확하면, 변경할 때마다 프론트/백/문서가 같이 흔들립니다.  
3. **관측(Agent Console) 용어가 흔들리면 데모 신뢰가 깨짐**: PRD는 “단계/배지/복구”가 일관된 용어로 보이길 요구합니다(RULE-008).

### 영향받는 코드 위치

- PRD: `vibe/prd.md` 241-246 (Turn Stream Protocol(초안) 섹션)
- 서버: `backend/src/unknown_world/api/turn.py` 218-223(설명), 160-163(final.data)
- 클라: `frontend/src/api/turnStream.ts` 65-76(final.data), 34-39(status=complete)
- 런북: U-007 runbook 84-96, U-008 runbook 전반(현 구현 계약 기반)

### 현재 코드 예시

```md
<!-- vibe/prd.md -->
- {"type":"final","turn_output":{...}}
```

```ts
// frontend/src/api/turnStream.ts
export interface FinalEvent {
  type: typeof StreamEventType.FINAL;
  data: TurnOutput;
}
```

---

## 💡 개선 방안

### 제안하는 접근법

**“프로토콜 버전(Protocol Versioning) + 필드/용어 별칭(Backward-compatible alias)”**으로 PRD(SSOT)와 현 구현을 안전하게 정렬합니다.

권장 정책:

- **단기(MVP 안정화)**: 현 구현을 `protocol_version: "1"`로 명시하고, PRD/런북을 이에 맞게 정리(문서-코드 정합성 회복).  
- **중기(품질 개선)**: PRD의 더 좋은 형태(`ok/fail`, map badges, `turn_output`)를 `protocol_version: "2"`로 정의하고, 서버/클라가 점진적으로 마이그레이션.

> 핵심은 “한 번 정한 계약은 자주 바꾸지 않는다”를 지키되, **버전과 별칭으로 확장을 열어두는 것**입니다.

### 구체적 실행 단계

#### Step 1: 스트림 프로토콜 버전 정의 + 시작 메타 이벤트(선택)

서버가 첫 이벤트로 아래를 보낼 수 있게 합니다(선택):

```json
{"type":"protocol","version":"1"}
```

- 장점: 런타임에서 어떤 계약인지 즉시 판별 가능
- 클라는 없으면 v1로 가정(폴백)

#### Step 2: PRD의 Turn Stream Protocol 섹션을 “v1(현행) + v2(목표)”로 재정리

- PRD 8.4.3의 “초안”을 다음 중 하나로 정리:
  - **(권장) v1을 현행 계약으로 명시**하고, v2를 목표로 분리
  - 또는 “초안”을 현행으로 바꾸고, 별도 문서(예: `vibe/ref/structured-outputs-guide.md`)에 목표 프로토콜을 기록

#### Step 3: 클라이언트 디코더에서 필드/용어 별칭을 지원(하위호환)

예시(개념):

- `final.data` **또는** `final.turn_output` 둘 다 수용
- `stage.status`는 `complete`를 `ok`로 간주(또는 alias)
- `badges`는
  - v1: `badges: string[]`
  - v2: `{schema:"ok|fail", ...}`
  - 둘 다 받아서 내부 표현으로 정규화

#### Step 4: 런북(U-007/U-008) 예시 출력/설명을 PRD/코드와 같은 용어로 맞춤

- U-007 runbook 예시가 현행과 일치하므로, PRD를 맞추는 쪽이 당장 비용이 낮습니다.
- 단, “목표 프로토콜(v2)”을 도입한다면 runbook에도 v2 예시를 추가합니다.

### 대안적 접근법 (선택사항)

- **대안 1(문서만 변경)**: PRD의 프로토콜 초안을 현 구현으로 바꾸고 버전 개념은 생략
  - 장점: 빠름
  - 단점: 향후 개선 시 “또 바꾸기”가 발생하기 쉬움
- **대안 2(코드만 변경)**: 즉시 PRD 형태로 코드 계약을 바꿈
  - 장점: SSOT 준수 명확
  - 단점: 변경 범위가 크고, 중간에 클라/서버 동기화 실패 위험

---

## 📈 기대 효과

### 즉각적 효과

- ✅ PRD(SSOT) ↔ 코드/런북이 같은 계약을 말하게 되어 혼선 제거
- ✅ RU-002의 “용어 통일”을 실제로 달성 가능한 형태로 고정

### 장기적 효과

- 🎯 스트림 이벤트 확장(Repair loop, 추가 배지 등) 시에도 호환성 유지
- 🎯 문서-구현 drift로 인한 “디버깅 낭비” 감소

---

## ⚠️ 주의사항 및 고려사항

### 리팩토링 시 주의할 점

1. PRD는 SSOT이므로, “코드가 맞으니 PRD를 바꾼다”가 아니라 **왜 현 계약이 MVP에 적합한지 근거(운영/안정성/범위)를 함께 기록**해야 합니다.  
2. 프로토콜 버전 이벤트를 도입할 경우, 프론트가 이를 모르면 무시해도 되도록 “추가 이벤트는 무시 가능” 설계를 유지합니다.

### 호환성 체크리스트

- [ ] PRD 8.4.3에 “현행 계약”이 명시되어 있는가?
- [ ] 서버/클라가 `final` payload 키(alias 포함)를 일치하게 처리하는가?
- [ ] `stage.status`/`badges` 구조가 버전별로 명확히 문서화되어 있는가?

---

## 🧪 검증 방법 (수동 검증 중심)

### 변경 전 확인 사항

- 현재 런북(U-007/U-008) 시나리오를 1회 수행해 “현행 계약(v1)”을 기준으로 확보

### 변경 후 검증 시나리오

#### 시나리오 1: 문서 정합성 검증(PRD ↔ 런북 ↔ 코드)

- **실행 방법**:
  - PRD 8.4.3의 프로토콜 예시가 U-007 runbook 예시와 동일한지 확인
  - 프론트/백 코드의 `final` 이벤트 키가 문서와 일치하는지 확인
- **기대 결과**:
  - ✅ 동일한 키/값/용어로 기술됨

#### 시나리오 2: 별칭 허용(하위호환) 검증(선택)

- **실행 방법**: 서버가 임시로 `final.turn_output`(v2) 형태를 송출해도 클라에서 정상 처리되는지 확인
- **기대 결과**:
  - ✅ 클라가 alias를 수용하고 TurnOutput을 반영

---

## 🔧 실행 가이드

### 개발자를 위한 실행 지침

1. **준비 사항**
   - PRD: `vibe/prd.md` 8.4.3
   - 런북: U-007/U-008
2. **실행 절차**
   - (권장) PRD에 v1/v2 프로토콜을 명시
   - (선택) protocol 이벤트/alias 디코딩 도입
3. **검증 절차**
   - 런북 기반 수동 검증 2개 수행

---

## 📚 참고 자료

- `vibe/prd.md` 8.4.3
- `.cursor/rules/00-core-critical.mdc` (SSOT, RULE-008)
- `vibe/unit-runbooks/U-007-mock-orchestrator-runbook.md`
- `vibe/unit-runbooks/U-008-http-streaming-client-runbook.md`

---

## 🏷️ 태그

`#refactoring` `#naming` `#high` `#protocol` `#ssot`

---

## 📝 노트

- 참고로 `shared/schemas/turn/turn_input.schema.json`는 현재 구현(backend/frontend의 TurnInput)과 일부 불일치(예: `click.box_2d` 형식) 징후가 있어, “계약 정합성” 관점에서 후속 점검이 필요합니다.
</file>

<file path="vibe/refactors/RU-002-Q4.md">
# [ID: RU-002-Q4] Turn Stream 이벤트 계약(타입/모델/유틸)의 모듈 경계 정리: Orchestrator ↔ API ↔ Frontend 분리 + (선택) Protocol 메타 이벤트

## 📌 기본 정보

| 항목               | 내용                     |
| ------------------ | ------------------------ |
| **ID**             | RU-002-Q4                |
| **심각도**         | High                     |
| **카테고리**       | 모듈 설계 (Module Design) |
| **영향 범위**      | `backend/src/unknown_world/api/turn.py`, `backend/src/unknown_world/orchestrator/mock.py`, (권장) `backend/src/unknown_world/api/turn_stream_events.py`, `frontend/src/api/turnStream.ts`, (권장) `frontend/src/types/turn_stream.ts`, `frontend/src/stores/agentStore.ts` |
| **예상 작업 시간** | 45~75분                  |

---

## 🔍 문제점 상세 분석

### 현재 상황

현재 스트리밍 이벤트 계약은 “동작은 맞지만”, **정의 위치와 책임 경계가 흐릿**합니다.

- 서버 이벤트 모델(`StageEvent`, `BadgesEvent`, `FinalEvent`, `ErrorEvent`)이 `orchestrator/mock.py`에 정의되어 있고(`backend/src/unknown_world/orchestrator/mock.py` 52~135), API 라우터가 이를 import 합니다(`backend/src/unknown_world/api/turn.py` 40~49).
- 프론트에서도 이벤트 타입 상수/인터페이스가 `api/turnStream.ts`에 직접 정의되어 있어(`frontend/src/api/turnStream.ts` 23~79), 계약 변경 시 drift 위험이 큽니다.
- stage 목록도 서버(`ORCHESTRATOR_PHASES`)와 클라(`DEFAULT_PHASES`)에 각각 존재합니다.

### 문제가 되는 이유

1. **계약/모델이 Orchestrator에 섞여 책임이 역전**: Orchestrator는 “TurnOutput 생성”이 핵심인데, transport(NDJSON) 이벤트까지 책임지며 결합도가 올라갑니다.  
2. **계약 drift가 구조적으로 쉬움**: 서버/클라에 동일 상수가 중복되어 있어, 작은 변경이 쉽게 불일치로 이어집니다(RU-002의 목적 정면 위배).  
3. **확장(실모델/repair) 시 비용 증가**: 이벤트가 늘어날수록 분산 정의는 수정 범위를 키워 “깨짐”을 유발합니다.

### 영향받는 코드 위치

- `backend/src/unknown_world/orchestrator/mock.py`: 52-135 (스트림 이벤트 모델이 Orchestrator에 존재)
- `backend/src/unknown_world/api/turn.py`: 40-49 (이벤트 모델 import), 57-77 (단계 상수 중복)
- `frontend/src/api/turnStream.ts`: 23-79 (이벤트 타입 중복), 180-226 (검증/디스패치가 혼재)
- `frontend/src/stores/agentStore.ts`: 90-99 (DEFAULT_PHASES 중복)

### 현재 코드 예시

```py
# backend/src/unknown_world/api/turn.py
from unknown_world.orchestrator.mock import (
    BadgesEvent,
    ErrorEvent,
    FinalEvent,
    NarrativeDeltaEvent,
    StageEvent,
    StageStatus,
    StreamEventType,
)
```

```ts
// frontend/src/api/turnStream.ts
export const StreamEventType = {
  STAGE: 'stage',
  BADGES: 'badges',
  NARRATIVE_DELTA: 'narrative_delta',
  FINAL: 'final',
  ERROR: 'error',
} as const;
```

---

## 💡 개선 방안

### 제안하는 접근법

**Turn Stream “계약(Contract)”을 transport 계층으로 분리**해 SSOT를 만들고, Orchestrator는 TurnOutput 생성에만 집중시키는 구조로 재정렬합니다.

권장 목표 상태:

- **Backend**: `api/turn_stream_events.py`에 “NDJSON 이벤트 모델/유틸” 집중
- **Orchestrator**: `TurnOutput` 생성/검증/폴백(도메인)만 담당 (스트림 이벤트 모델 제거)
- **Frontend**: `types/turn_stream.ts`에 “이벤트 타입 + (선택) 디코더(Zod)” 집중, `api/turnStream.ts`는 스트림 IO만 담당

### 구체적 실행 단계

#### Step 1: 서버 스트림 이벤트를 `api/turn_stream_events.py`로 이동(권장)

**변경 전:**

- `unknown_world/orchestrator/mock.py`에 이벤트 모델이 존재

**변경 후(권장):**

- `backend/src/unknown_world/api/turn_stream_events.py`에 아래를 정의:
  - `StreamEventType`, `StageStatus`(enum/리터럴)
  - `StageEvent`, `BadgesEvent`, `NarrativeDeltaEvent`, `FinalEvent`, `ErrorEvent`(Pydantic)
  - `_serialize_event` 같은 유틸(또는 `turn.py`에 두되 import 통일)
- `orchestrator/mock.py`는 **TurnOutput 생성기 + 안전 폴백 생성기**만 남김

#### Step 2: 프론트 이벤트 타입/디코더를 `types/turn_stream.ts`로 분리(권장)

**변경 전:**

- `api/turnStream.ts`에 이벤트 타입/파서/네트워크 IO가 혼재

**변경 후(권장):**

- `frontend/src/types/turn_stream.ts`:
  - `StreamEventType`, `StageStatus`
  - `StageEvent`, `BadgesEvent`, `NarrativeDeltaEvent`, `FinalEvent`, `ErrorEvent`, `StreamEvent`
  - (선택) Zod 기반 `decodeStreamEvent(...)` / `safeDecodeStreamEvent(...)`
- `frontend/src/api/turnStream.ts`:
  - NDJSON 파서 + fetch stream 소비 + `dispatchEvent`(가능하면 디코더 호출만)

#### Step 3: stage 목록 SSOT 전략 확정(페어링 Q1 해결을 위한 구조)

- **권장**: 서버 SSOT + 클라 폴백
  - 서버가 시작 시점에 `(선택) protocol/meta 이벤트`로 stage 목록을 제공
  - 클라는 protocol이 오면 그 목록을 표시하고, 없으면 DEFAULT_PHASES를 사용

예시(선택):

```json
{"type":"protocol","version":"1","stages":["parse","validate","plan","resolve","render","verify","commit"]}
```

> 이 메타 이벤트는 “SSOT를 어디에 둘지”를 코드로 고정하는 역할을 합니다.

### 대안적 접근법 (선택사항)

- **대안 1(최소 변경)**: 파일 이동 없이, “각 정의를 한 곳에서 import”만 강제
  - 장점: 빠름
  - 단점: 책임 경계 문제는 남아 drift 위험이 완전히 사라지지 않음
- **대안 2(강경)**: shared JSON Schema에 stream protocol까지 포함하고, 양쪽에서 이를 참조/검증
  - 장점: 가장 강한 SSOT
  - 단점: MVP 범위를 넘어설 수 있음(도입 비용)

---

## 📈 기대 효과

### 즉각적 효과

- ✅ 이벤트 계약 변경 시 수정 범위 축소(“어디를 고치면 되는지” 명확)
- ✅ Orchestrator ↔ API 결합도 감소(역할 명확화)
- ✅ RU-002 목표(타입/용어 통일) 달성 경로가 단순해짐

### 장기적 효과

- 🎯 실모델/repair loop 도입 시 이벤트 확장이 안전해짐
- 🎯 팀 온보딩 비용 감소(계약이 한 군데에 존재)

---

## ⚠️ 주의사항 및 고려사항

### 리팩토링 시 주의할 점

1. “모듈 분리”는 계약을 바꾸지 않는 방향(Behavior Preservation)으로 먼저 수행하고, 계약 변경(Q2)을 이후 단계로 분리하는 것이 안전합니다.  
2. FastAPI 라우트의 import 경로 이동은 packaging/uv 실행에 영향이 있을 수 있으니, 경로를 얕게 유지합니다.  
3. Frontend에서 event 타입/디코더를 분리할 때 순환 import가 생기지 않게 주의합니다.

### 호환성 체크리스트

- [ ] 기존 event JSON shape가 바뀌지 않았는가? (변경할 계획이면 RU-002-Q2 선행)
- [ ] stage 목록이 서버/클라에서 동일하게 유지되는가?

---

## 🧪 검증 방법 (수동 검증 중심)

### 변경 전 확인 사항

- 현재 서버/클라 정상 스트리밍 시나리오를 수행해 기준 상태를 확보(런북 U-007/U-008)

### 변경 후 검증 시나리오

#### 시나리오 1: 서버 스트림 정상 동작

- **실행 방법**: `vibe/unit-runbooks/U-007-mock-orchestrator-runbook.md` 시나리오 A
- **기대 결과**: 이벤트 시퀀스(stage→badges→narrative_delta→final) 유지

#### 시나리오 2: 프론트 Agent Console 정상 렌더

- **실행 방법**: `vibe/unit-runbooks/U-008-http-streaming-client-runbook.md` 시나리오 A/B
- **기대 결과**: Queue/Badges 정상 표시, 스트리밍 종료 후 IDLE 복귀

---

## 🔧 실행 가이드

### 개발자를 위한 실행 지침

1. **준비 사항**
   - RU-002 페어링 Q1 결정(SSOT 위치) 확인
2. **실행 절차**
   - 서버: 이벤트 모델 이동 → import 정리
   - 클라: 이벤트 타입/디코더 분리 → import 정리
   - (선택) protocol/meta 이벤트 도입
3. **검증 절차**
   - U-007/U-008 런북 시나리오 재수행
4. **롤백 계획**
   - 이동 커밋을 되돌리고, 계약 변경은 RU-002-Q2로 분리

---

## 📚 참고 자료

- `vibe/prd.md` 8.4.3(스트림 프로토콜), 6.8/10장(관측/복구 UX)
- `.cursor/rules/00-core-critical.mdc` (RULE-003/004/008)
- `vibe/unit-plans/RU-002[Mvp].md` (권장 파일/흐름)

---

## 🏷️ 태그

`#refactoring` `#module-design` `#high` `#streaming` `#contract`

---

## 📝 노트

- 이 제안은 “계약을 바꾸는 것”이 아니라, **계약을 안정적으로 유지/확장할 수 있게 ‘정의 위치’를 정리**하는 것이 1차 목표입니다.
</file>

<file path="vibe/refactors/RU-002-S1.md">
# [ID: RU-002-S1] 스트리밍 실패(네트워크/서버/검증)에서도 “항상 final(폴백 TurnOutput)로 종료” + UI 멈춤 방지 + Economy 안전화

## 📌 기본 정보

| 항목               | 내용                           |
| ------------------ | ------------------------------ |
| **ID**             | RU-002-S1                      |
| **심각도**         | Critical                       |
| **카테고리**       | 잠재적 오류 (Potential Bugs)   |
| **영향 범위**      | `backend/src/unknown_world/api/turn.py`, `backend/src/unknown_world/orchestrator/mock.py`, `frontend/src/api/turnStream.ts`, `frontend/src/App.tsx`, `frontend/src/schemas/turn.ts`, `frontend/src/stores/agentStore.ts` |
| **예상 작업 시간** | 45~90분                        |

---

## 🔍 문제점 상세 분석

### 현재 상황

현행 스트리밍 계약은 “정상 완료” 경로에서는 잘 동작하지만, **일부 실패 경로에서 UI가 멈추거나(E2E 체감: 입력/카드가 영구 disable), 또는 Economy HUD가 잘못 갱신되는** 위험이 있습니다.

특히 RU-002의 완료 기준(“실패 시 폴백 TurnOutput으로 종료”, RULE-004)과 PRD의 데모 하드 게이트(“멈춤/깨짐” 방지) 관점에서, 아래 3가지가 동시에 문제가 됩니다:

1) **클라이언트 네트워크/HTTP 오류 시 `onComplete`가 호출되지 않아 `isStreaming`이 true로 남을 수 있음**  
2) **서버가 `error` 이벤트만 내보내고 `final`로 종료하지 않는 경로가 존재**  
3) **폴백 TurnOutput의 economy.balance_after가 “현재 세션 잔액”과 무관한 값으로 채워져 HUD가 왜곡될 수 있음**

### 문제가 되는 이유

1. **UI 멈춤은 데모에서 즉시 실패로 보임**: PRD는 스트리밍 UX에서 “단계/배지/복구”가 보여야 하고, 실패 시에도 안전한 대체 결과를 제공해야 함(RULE-004/008).  
2. **Economy 인바리언트/UX 위반**: 폴백이 잔액을 임의 값으로 덮어쓰면, 사용자 입장에서 “재화가 갑자기 증발/증가”로 보이며 RULE-005(잔액 음수 금지/일관성) 정신을 훼손합니다.  
3. **향후 실모델/리페어 루프 확장 시, 실패 종료 규칙이 불명확하면 프론트/백의 복구 로직이 계속 깨짐**.

### 영향받는 코드 위치

- 서버: `backend/src/unknown_world/api/turn.py`
  - 라인: 175-185 (예외 발생 시 `error`만 송출)
  - 라인: 262-281 (입력 검증 실패 시 `error`만 송출)
  - 라인: 160-163 / 171-173 (`final`은 특정 경로에서만 송출)
- 서버: `backend/src/unknown_world/orchestrator/mock.py`
  - 라인: 437-475 (폴백 TurnOutput 생성, economy.balance_after가 하드코딩)
- 클라이언트: `frontend/src/api/turnStream.ts`
  - 라인: 310-323 (catch에서 `onError`만 호출, `onComplete` 미호출)
- 클라이언트: `frontend/src/App.tsx`
  - 라인: 259-277 (startStream으로 isStreaming=true, onComplete에서만 completeStream 호출)
  - 라인: 271-274 (onError에서 completeStream 호출 없음)
- 클라이언트: `frontend/src/schemas/turn.ts`
  - 라인: 464-495 (폴백 TurnOutput economy.balance_after=0/0)

### 현재 코드 예시

**(1) 클라이언트: 네트워크/HTTP 에러 시 complete가 호출되지 않음**

```ts
// frontend/src/api/turnStream.ts
// ...
} catch (error) {
  // ...
  callbacks.onError?.({
    type: StreamEventType.ERROR,
    message: errorMessage,
    code: 'STREAM_ERROR',
  });
}
```

**(2) 서버: 일부 실패 경로에서 error만 송출**

```py
# backend/src/unknown_world/api/turn.py
except Exception:
    yield _serialize_event(
        ErrorEvent(type=StreamEventType.ERROR, message="처리 중 오류...", code="INTERNAL_ERROR").model_dump()
    )
```

**(3) 폴백 economy가 세션 잔액과 무관**

```py
# backend/src/unknown_world/orchestrator/mock.py
balance_after=CurrencyAmount(signal=100, memory_shard=5)  # 기본 잔액 (하드코딩)
```

```ts
// frontend/src/schemas/turn.ts
economy: {
  cost: { signal: 0, memory_shard: 0 },
  balance_after: { signal: 0, memory_shard: 0 }, // 하드코딩
},
```

---

## 💡 개선 방안

### 제안하는 접근법

**“스트림 종료 인바리언트”를 명시하고, 서버/클라가 이를 강제**합니다.

- **스트림 종료 인바리언트**: “각 `/api/turn` 스트림은 정확히 1개의 `final` 이벤트로 종료한다.”  
  - 성공: 검증된 TurnOutput
  - 실패: 안전 폴백 TurnOutput (RULE-004)
- `error` 이벤트는 “UI용 경고/설명”으로 유지하되, **terminal 이벤트로 쓰지 않는다**(최종 상태는 항상 `final`).
- 폴백 TurnOutput의 Economy는 **입력 스냅샷을 그대로 유지**(비용 0, 잔액 변화 없음)하여 RULE-005 정신을 보존한다.

### 구체적 실행 단계

#### Step 1: 서버에서 “error-only 종료”를 제거하고, 실패 시에도 final(폴백) 송출

- 입력 검증 실패, 내부 예외, 생성/검증 실패 모두:
  - (선택) `error` 이벤트 송출
  - **반드시 `final` 이벤트로 폴백 TurnOutput 송출 후 종료**

**변경 전:**

- 입력 검증 실패: `error`만 송출
- 내부 예외: `error`만 송출

**변경 후(권장):**

- `final`은 항상 송출(성공/실패 통일)
- `error`는 “왜 폴백이었는지” UI 힌트용으로만 송출

#### Step 2: 폴백 TurnOutput의 economy.balance_after를 “현재 입력 스냅샷 기반”으로 표준화

- 서버 폴백: `balance_after = turn_input.economy_snapshot`, `cost = 0`
- 클라 폴백: “서버 final이 오지 못한 케이스(네트워크)”까지 커버해야 하므로,
  - `TurnInput.economy_snapshot` 또는 “요청 직전 HUD 값”을 그대로 넣어 종료용 폴백을 만든다.

#### Step 3: 클라이언트 스트림 실행기에서 `onComplete`를 finally에서 보장 + 필요 시 final 폴백을 생성해 UI 종료

- `executeTurnStream`의 try/catch를 `try { ... } catch { ... } finally { callbacks.onComplete?.() }` 형태로 정리
- `STREAM_ERROR`(HTTP error, fetch rejection 등) 시:
  - `onError` 호출
  - **즉시 `onFinal` 폴백도 호출(선택)** → App이 `applyTurnOutput`로 HUD를 안전하게 유지

#### Step 4: AgentStore/App에서 “에러 시 스트리밍 종료”를 보장

- App의 `onError`에서 `completeStream()` 호출(또는 `onComplete` 보장으로 충분)
- “오프라인 상태”가 되더라도 입력이 영구 lock 되지 않게 한다.

### 대안적 접근법 (선택사항)

- **대안 1(보수적)**: onComplete만 finally에서 보장하고, final 폴백은 만들지 않음
  - 장점: 계약 변경 최소
  - 단점: “최종 상태”가 TurnOutput 없이 끝나 UI가 덜 일관됨(특히 Economy/내러티브)
- **대안 2(강경)**: `error` 이벤트를 제거하고 모든 실패는 `final` 한 번만 송출
  - 장점: 프로토콜 단순
  - 단점: 실패 원인 가시성이 낮아짐(관측성 약화, RULE-008 손실)

---

## 📈 기대 효과

### 즉각적 효과

- ✅ 네트워크/서버 오류에서도 **UI가 “멈추지 않음”** (입력/카드 영구 disable 방지)
- ✅ “항상 final로 종료” 규칙으로 스트리밍 UX가 예측 가능해짐(RULE-004/008)
- ✅ 폴백 시에도 Economy HUD가 왜곡되지 않아 데모 신뢰도 상승(RULE-005)

### 장기적 효과

- 🎯 RU-003(실모델 연동)에서 “리페어 루프”를 추가할 때도 종료 규칙이 흔들리지 않음
- 🎯 스트리밍 계약 변경 시 프론트/백 디버깅 비용 감소

### 정량적 개선 (가능한 경우)

| 지표                    | 현재                                   | 개선 후                                     | 변화율 |
| ----------------------- | -------------------------------------- | ------------------------------------------- | ------ |
| “멈춤/잠금” 체감 이슈   | 네트워크 실패 시 발생 가능             | 실패 시에도 종료 처리(complete/final) 보장  | ↓      |
| Economy HUD 왜곡        | 폴백 시 0/0 또는 100/5로 덮어쓸 수 있음 | 폴백 시 입력 스냅샷 유지                     | ↓      |

---

## ⚠️ 주의사항 및 고려사항

### 리팩토링 시 주의할 점

1. **스트림이 항상 final로 종료**되면, 프론트는 “error 표시 + final 적용”의 우선순위를 명확히 해야 합니다(예: error는 배너, final은 상태 반영).  
2. 폴백 TurnOutput은 **프롬프트/내부 추론/스택트레이스**를 절대 포함하면 안 됩니다(RULE-007/008).  
3. “비용 0 + 잔액 유지”는 보수적인 정책입니다. 추후 “실패에도 비용 일부 발생”을 도입하려면 Economy 정책 합의가 필요합니다.

### 영향받는 다른 모듈

- **Agent Console**: Auto-repair/에러 트레이스 UX가 더 일관되게 동작(“끝났는지” 명확)
- **CP-MVP-01**: 스트리밍/스키마/폴백 체크포인트를 안정적으로 수행 가능

### 호환성 체크리스트

- [ ] 실패 시에도 `final` 이벤트가 정확히 1개 송출되는가?
- [ ] `onComplete`는 성공/실패 모두에서 호출되는가?
- [ ] 폴백 시 economy.balance_after가 “요청 직전 잔액”을 유지하는가?

---

## 🧪 검증 방법 (수동 검증 중심)

### 변경 전 확인 사항

1. **네트워크 실패(UI 멈춤) 재현**: 백엔드 종료 후 프론트에서 실행 → 입력창/카드가 영구 disable 되는지 확인  
2. **폴백 Economy 왜곡 재현**: 폴백이 발생하면 HUD가 0/0 또는 100/5로 바뀌는지 확인

### 변경 후 검증 시나리오

#### 시나리오 1: 백엔드 다운 상태에서 실행(네트워크 실패)

- **실행 방법**: `vibe/unit-runbooks/U-008-http-streaming-client-runbook.md` 시나리오 E 따라 수행  
- **기대 결과**:
  - ✅ Agent Console에 에러 표시
  - ✅ UI가 IDLE로 복귀(입력/카드 다시 활성화)
  - ✅ Economy HUD가 “요청 직전 값” 유지

#### 시나리오 2: 입력 검증 실패(필수 필드 누락/잘못된 language)

- **실행 방법**: `vibe/unit-runbooks/U-007-mock-orchestrator-runbook.md` 시나리오 D에 준해 잘못된 payload 전송  
- **기대 결과**:
  - ✅ `error` 이벤트(선택)
  - ✅ 반드시 `final` 폴백 이벤트 도착
  - ✅ 프론트는 final을 적용해 “스트림 종료 상태”가 명확

#### 시나리오 3: 서버 내부 예외(강제 실패 시뮬레이션)

- **실행 방법**: (개발자 로컬에서) `_stream_turn_events` 내부에서 예외를 강제로 발생시키는 임시 훅으로 확인  
- **기대 결과**:
  - ✅ error + final(폴백) 순서로 스트림 종료
  - ✅ UI 멈춤 없음

### 회귀 확인 체크리스트

- [ ] 정상 케이스에서 이벤트 순서(stage/badges/narrative_delta/final)가 유지되는가?
- [ ] 프론트에서 한 번의 턴 실행이 항상 “종료 상태”로 귀결되는가?

---

## 🔧 실행 가이드

### 개발자를 위한 실행 지침

1. **준비 사항**
   - PRD: `vibe/prd.md` 8.4.3(스트림 프로토콜), 6.8/10장(복구/배지 UX)
   - RULE: `.cursor/rules/00-core-critical.mdc` (RULE-004/005/008)
   - 런북: `vibe/unit-runbooks/U-007-mock-orchestrator-runbook.md`, `vibe/unit-runbooks/U-008-http-streaming-client-runbook.md`

2. **실행 절차**
   - 서버: 실패 경로에서도 final 송출 + 폴백 Economy 정책 적용
   - 클라: executeTurnStream 종료 보장(finally) + (선택) STREAM_ERROR 시 final 폴백 생성

3. **검증 절차**
   - 위 “수동 검증 시나리오” 3개 수행

4. **롤백 계획** (필요시)
   - final 송출 강제/폴백 Economy 변경만 되돌리면 됨(프로토콜 버전 이벤트 도입 시에는 v1 유지)

### 예상 소요 시간

- 코드 수정: 30~60분
- 수동 검증: 15~30분
- 총 예상 시간: 45~90분

---

## 📚 참고 자료

- `vibe/prd.md` 6.8, 8.4.3, 10장
- `.cursor/rules/00-core-critical.mdc` (RULE-004/005/008)
- `vibe/unit-runbooks/U-007-mock-orchestrator-runbook.md`
- `vibe/unit-runbooks/U-008-http-streaming-client-runbook.md`

---

## 🏷️ 태그

`#refactoring` `#stability` `#critical` `#streaming` `#fallback` `#economy`

---

## 📝 노트

- 본 제안은 “스트림이 실패해도 게임 UI가 유지되는 경험”을 만들기 위한 **최소 인바리언트(항상 final)**를 고정합니다.
</file>

<file path="vibe/refactors/RU-002-S2.md">
# [ID: RU-002-S2] 스트림 이벤트( stage/badges/error 등 ) 검증 강화(Zod) + Unknown/확장 이벤트 폴백 처리로 “깨짐” 방지

## 📌 기본 정보

| 항목               | 내용                     |
| ------------------ | ------------------------ |
| **ID**             | RU-002-S2                |
| **심각도**         | Medium                   |
| **카테고리**       | 엣지 케이스 (Edge Cases) |
| **영향 범위**      | `frontend/src/api/turnStream.ts`, (권장) `frontend/src/types/turn_stream.ts`, `frontend/src/stores/agentStore.ts` |
| **예상 작업 시간** | 30~60분                  |

---

## 🔍 문제점 상세 분석

### 현재 상황

클라이언트는 NDJSON 라인을 JSON.parse한 뒤, `type`만 보고 곧바로 이벤트 타입으로 캐스팅해 처리합니다.

- `final`은 Zod로 TurnOutput을 검증하고 폴백을 제공하지만(`frontend/src/api/turnStream.ts` 199-215),
- `stage/badges/error/narrative_delta`는 “형태 검증 없이” 그대로 store로 흘러갑니다(`frontend/src/api/turnStream.ts` 186-225).

즉, 서버가 사소하게 계약을 바꾸거나(예: status 값/키 변경), 예외 상황에서 이벤트가 깨지면:

- queue가 갱신되지 않거나
- badges UI가 꼬이거나
- AgentConsole이 “원인 모를 상태”로 남는 식의 UX 결함이 발생할 수 있습니다.

또한 향후 `protocol`, `repair`, `telemetry` 같은 확장 이벤트를 도입할 때(현 PRD 요구와도 맞음), **Unknown event를 “그냥 버리는 것”**은 관측성 측면에서 손해입니다.

### 문제가 되는 이유

1. **“스키마/폴백”은 TurnOutput만의 문제가 아님**: stage/badges가 깨지면 “에이전트형 시스템”의 증거(Queue/Badges)가 사라져 데모 체감이 악화됩니다(RULE-008).  
2. **확장 이벤트 도입 시 깨짐 확률 증가**: Unknown type을 버리면, 새 이벤트 도입이 “조용히 무시”되어 디버깅이 어려워집니다.  
3. **부분적 무결성 깨짐은 사용자에게 ‘멈춤’처럼 보임**: UI가 오동작하면 기능 실패로 인식됩니다.

### 영향받는 코드 위치

- `frontend/src/api/turnStream.ts`
  - 라인: 180-226 (`dispatchEvent`가 캐스팅 기반)
  - 라인: 223-225 (unknown type은 console.warn 후 드랍)
- `frontend/src/stores/agentStore.ts`
  - 라인: 144-165 (stage 이벤트 상태 갱신이 status 값에 강하게 결합)

### 현재 코드 예시

```ts
// frontend/src/api/turnStream.ts
switch (type) {
  case StreamEventType.STAGE:
    callbacks.onStage?.(event as StageEvent);
    break;
  // ...
  default:
    console.warn('[TurnStream] Unknown event type:', type);
}
```

---

## 💡 개선 방안

### 제안하는 접근법

**스트림 이벤트도 “경량 검증 + 폴백”**을 적용합니다.

- 각 이벤트별 최소 Zod 스키마를 정의하고 safeParse
- 실패 시:
  - UI를 멈추지 않고(=drop)
  - (선택) AgentConsole에 “Unknown/Invalid event”를 남겨 관측성을 확보

### 구체적 실행 단계

#### Step 1: 이벤트별 Zod 스키마 정의(권장 위치: `frontend/src/types/turn_stream.ts`)

예시(개념):

- `StageEventSchema`: `{type:"stage", name: AgentPhase, status: "start"|"complete"|"ok"|"fail"}`
  - `complete`를 `ok`로 정규화(별칭)하면 RU-002-Q2의 버전 전략과도 호환
- `BadgesEventSchema`: v1(list) + v2(map) 둘 다 허용 후 내부 표준 형태로 변환
- `ErrorEventSchema`: `{type:"error", message: string, code?: string}`
- `NarrativeDeltaEventSchema`: `{type:"narrative_delta", text: string}`
- `FinalEventSchema`: `{type:"final", data?: unknown, turn_output?: unknown}` (alias 후 TurnOutput 검증은 기존대로)

#### Step 2: `dispatchEvent`에서 캐스팅 대신 safeDecode → callbacks로 전달

- decode 실패 시:
  - console.warn은 유지하되
  - (선택) `onError` 콜백에 “INVALID_EVENT”를 보내 AgentConsole에 표기

#### Step 3: AgentStore가 `stage.status=fail`을 표현할 수 있게 보강(선택)

- 현재 PhaseStatus에 `failed`가 이미 있으므로(`frontend/src/stores/agentStore.ts` 30),
- status 값이 `fail`이면 해당 phase를 failed로 표시하는 로직을 추가(향후 repair loop에 필요)

### 대안적 접근법 (선택사항)

- **대안 1(최소)**: Unknown event는 무시하되, stage/badges만 Zod 검증
  - 장점: 변경 최소
  - 단점: 확장 이벤트 관측성은 여전히 부족

---

## 📈 기대 효과

### 즉각적 효과

- ✅ stage/badges가 깨져도 UI 전체가 멈추지 않고, 원인 힌트가 남음
- ✅ PRD 요구(단계/배지 가시화, 내부추론 비노출)를 더 안정적으로 달성

### 장기적 효과

- 🎯 프로토콜 확장/버전업 시 회귀 위험 감소
- 🎯 “왜 Queue/Badges가 안 보이지?” 같은 디버깅 비용 감소

---

## ⚠️ 주의사항 및 고려사항

### 리팩토링 시 주의할 점

1. 이벤트 검증 실패 시 “너무 시끄러운 에러 UX”가 되지 않게, AgentConsole 표시는 요약된 형태로 유지합니다(RULE-008).  
2. Zod 스키마는 엄격하되, “alias 허용(complete/ok, data/turn_output)” 같은 **전방 호환성**을 함께 넣어야 RU-002-Q2와 충돌하지 않습니다.

### 호환성 체크리스트

- [ ] v1 이벤트(현행) 수신 시 정상 처리되는가?
- [ ] alias가 있어도(complete/ok, data/turn_output) 깨지지 않는가?
- [ ] unknown type 이벤트가 들어와도 UI가 멈추지 않는가?

---

## 🧪 검증 방법 (수동 검증 중심)

### 변경 전 확인 사항

- 브라우저 콘솔에서 unknown event/type 상황이 발생하면 어떻게 보이는지 확인(현행은 warn만)

### 변경 후 검증 시나리오

#### 시나리오 1: Unknown event type 주입(개발자용)

- **실행 방법**: 서버가 임시로 `{"type":"protocol","version":"1"}` 같은 이벤트를 한 줄 추가 송출
- **기대 결과**:
  - ✅ UI는 멈추지 않음
  - ✅ (선택) AgentConsole에 “unknown/ignored event” 힌트가 표시됨

#### 시나리오 2: stage.status 별칭 검증

- **실행 방법**: 서버가 `complete` 대신 `ok`를 보내도록 임시 변경
- **기대 결과**:
  - ✅ Queue가 정상적으로 진행/완료 표시

---

## 🔧 실행 가이드

### 개발자를 위한 실행 지침

1. **준비 사항**
   - RU-002-Q2(버전/alias 전략)와 함께 읽고 일관성 유지
2. **실행 절차**
   - 이벤트 Zod 스키마 정의 → dispatchEvent 적용 → store fail 상태 보강(선택)
3. **검증 절차**
   - 시나리오 1~2 수행

---

## 📚 참고 자료

- `vibe/prd.md` 6.8/8.4.3(관측/프로토콜)
- `.cursor/rules/00-core-critical.mdc` (RULE-003/004/008)

---

## 🏷️ 태그

`#refactoring` `#edge-cases` `#medium` `#streaming` `#validation`

---

## 📝 노트

- “final TurnOutput 검증”만으로는 충분하지 않고, **관측 UI(Queue/Badges)도 계약의 일부**로 다뤄야 합니다.
</file>

<file path="vibe/refactors/RU-002-S3.md">
# [ID: RU-002-S3] RU-002 리팩토링 이후 “스트리밍/검증/폴백/용어 통일” 수동 검증 시나리오 패키지(데모 체감 중심)

## 📌 기본 정보

| 항목               | 내용                           |
| ------------------ | ------------------------------ |
| **ID**             | RU-002-S3                      |
| **심각도**         | Medium                         |
| **카테고리**       | 수동 검증 시나리오 (Manual Verification) |
| **영향 범위**      | (가이드) `vibe/unit-runbooks/U-007-mock-orchestrator-runbook.md`, `vibe/unit-runbooks/U-008-http-streaming-client-runbook.md`, RU-002 리팩토링 적용 파일 전반 |
| **예상 작업 시간** | 20~40분                        |

---

## 🔍 문제점 상세 분석

### 현재 상황

U-007/U-008 런북은 각각의 유닛 요구사항을 검증하는 데는 충분하지만, RU-002의 목표인:

- 이벤트 타입/용어 통일,
- 실패 시 폴백으로 “정상 종료”,
- Agent Console 관측 UX의 일관성,

을 한 번에 확인하는 **통합 시나리오**는 별도로 정리되어 있지 않습니다.

### 문제가 되는 이유

1. 리팩토링은 “작은 변경이 큰 회귀”를 만들 수 있는데, 통합 시나리오가 없으면 데모 직전에 깨짐을 발견할 수 있습니다.  
2. RU-002는 PRD 하드 게이트(검증/복구/관측)와 직결되므로, “수동 검증 체크리스트”가 사실상 품질 게이트 역할을 합니다.

---

## 💡 개선 방안

### 제안하는 접근법

RU-002 전용 “수동 검증 패키지”를 정의합니다.

- 기존 런북(U-007/U-008)을 **참조**하되,
- RU-002에서 바뀌는 포인트(종료 규칙, 폴백, 프로토콜 버전/alias, 용어) 중심으로 **최소 6개 시나리오**만 고정합니다.

### 구체적 실행 단계

#### Step 1: 통합 검증 체크리스트(시나리오 1~6) 수행

아래 시나리오를 순서대로 수행하고, “기대 결과”를 만족하면 RU-002를 통과로 판단합니다.

#### Step 2: 런북 문서에 링크 추가(선택)

- U-007/U-008 runbook 말미에 “RU-002 통합 검증: vibe/refactors/RU-002-S3.md 참조” 링크를 추가하면 재사용성이 좋아집니다.

---

## 🧪 검증 방법 (수동 검증 중심)

## 시나리오 1: 정상 스트리밍(기본 턴)

- **목적**: 이벤트 시퀀스/Agent Console/최종 TurnOutput 반영이 정상인지 확인
- **실행 방법**: U-007 runbook 시나리오 A + U-008 runbook 시나리오 A/B
- **기대 결과**:
  - ✅ Queue 단계가 Parse→Commit 순서로 진행
  - ✅ Badges가 4종(Schema/Economy/Safety/Consistency)로 표시
  - ✅ final TurnOutput 적용 후 내러티브/액션 덱/경제 HUD가 갱신

## 시나리오 2: 입력 검증 실패(잘못된 payload)

- **목적**: 입력 검증 실패도 “안전 종료(폴백 final)”로 처리되는지 확인(RU-002-S1 권장)
- **실행 방법**: U-007 runbook 시나리오 D에 준해 잘못된 payload 전송
- **기대 결과**:
  - ✅ error(선택) 표시
  - ✅ final(폴백 TurnOutput)로 종료
  - ✅ 프론트 UI가 멈추지 않고 IDLE로 복귀

## 시나리오 3: 서버 내부 예외(강제 실패)

- **목적**: 서버 내부 오류에서도 “final(폴백)로 종료”되는지 확인
- **실행 방법**: 개발자 로컬에서 예외를 강제로 발생시키는 임시 훅으로 확인
- **기대 결과**:
  - ✅ error 표시(프롬프트/내부추론 노출 없음)
  - ✅ final 폴백 도착

## 시나리오 4: 네트워크 실패(백엔드 OFFLINE)

- **목적**: 프론트가 네트워크 실패를 감지하고 UI가 멈추지 않는지 확인
- **실행 방법**: U-008 runbook 시나리오 E
- **기대 결과**:
  - ✅ Agent Console에 에러 표시
  - ✅ 입력/카드가 영구 disable 되지 않고 복구 가능
  - ✅ 연결 상태가 OFFLINE로 표시

## 시나리오 5: 프로토콜 alias/버전(선택)

- **목적**: PRD 정합성/전방 호환을 위해 alias(`final.data`/`final.turn_output`, `complete`/`ok`)가 안전한지 확인
- **실행 방법**: 서버가 임시로 다른 키/값을 송출하도록 변경(개발자용)
- **기대 결과**:
  - ✅ 클라가 정상 처리 또는 “무시 + 경고(관측)”로 안전하게 동작

## 시나리오 6: Economy 폴백 정책(잔액 왜곡 방지)

- **목적**: 폴백 발생 시에도 economy.balance_after가 합리적으로 유지되는지 확인(RULE-005)
- **실행 방법**: 시나리오 2 또는 4에서 폴백/에러를 발생시키고 HUD 확인
- **기대 결과**:
  - ✅ 잔액이 갑자기 0/0 또는 기본값으로 덮어써지지 않음(권장: 요청 직전 스냅샷 유지)

---

## 📈 기대 효과

### 즉각적 효과

- ✅ 리팩토링 직후 “데모 체감 품질”을 빠르게 확인 가능
- ✅ RU-002의 완료 기준을 체크리스트로 고정(팀 합의 비용↓)

### 장기적 효과

- 🎯 향후 실모델/리페어 루프 확장 시에도 회귀 포인트가 명확

---

## ⚠️ 주의사항 및 고려사항

### 리팩토링 시 주의할 점

1. 이 문서는 “자동화 테스트 제안”이 아니라, **데모/플레이어 관점의 수동 검증 절차**입니다.  
2. 시나리오 3/5는 개발자용(임시 훅)이며, 배포/데모 빌드에는 포함하지 않는 것을 권장합니다.

---

## 🔧 실행 가이드

### 개발자를 위한 실행 지침

1. **준비 사항**
   - 백엔드/프론트 실행은 각 런북(U-007/U-008)의 Quick Start를 따른다.
2. **실행 절차**
   - 시나리오 1~6을 순서대로 수행
3. **검증 절차**
   - 각 시나리오의 “기대 결과” 체크박스를 팀이 함께 확인

---

## 📚 참고 자료

- `vibe/unit-runbooks/U-007-mock-orchestrator-runbook.md`
- `vibe/unit-runbooks/U-008-http-streaming-client-runbook.md`
- `vibe/prd.md` 6.8/8.4.3/10장
- `.cursor/rules/00-core-critical.mdc` (RULE-004/005/008)

---

## 🏷️ 태그

`#refactoring` `#manual-verification` `#medium` `#runbook` `#streaming`

---

## 📝 노트

- RU-002가 목표로 하는 “validation/폴백/이벤트 타입 통일”은 코드만 바꿔서는 완성되지 않고, **사용자 눈에 보이는 ‘멈춤/깨짐’이 없어야** 완료로 판단할 수 있습니다.
</file>

<file path="vibe/unit-plans/U-035[Mvp].md">
# U-035[Mvp]: 실시간 이미지 생성 시 rembg 배경 제거 통합

## 메타데이터

| 항목      | 내용        |
| --------- | ----------- |
| Unit ID   | U-035[Mvp]  |
| Phase     | MVP         |
| 예상 소요 | 60분        |
| 의존성    | U-019,U-020 |
| 우선순위  | High        |

## 작업 목표

실시간 게임 진행 중 생성되는 **오브젝트/아이템 이미지**에 대해, 필요한 경우 `rembg`를 사용해 **배경을 제거**하여 투명 PNG로 제공할 수 있는 파이프라인을 구축한다.

**배경**: 게임 내 생성된 오브젝트/아이템이 Scene Canvas나 Inventory에서 "배경 없이" 자연스럽게 합성되어야 할 때, 생성 이미지의 불필요한 배경이 UX를 저해할 수 있다. 이를 위해 rembg를 **조건부 후처리** 파이프라인으로 통합한다.

**완료 기준**:

- 이미지 생성 요청(`render.image_job`)에 `remove_background` 옵션이 추가되고, 해당 플래그가 true일 때 백엔드에서 rembg 처리가 수행된다.
- rembg 모델 선택은 이미지 유형(오브젝트/캐릭터 등)에 따라 자동 선택되거나, 기본값(`u2net`)으로 동작한다.
- rembg 처리 실패 시에도 원본 이미지가 반환되는 안전 폴백이 존재한다.
- 배경 제거가 느릴 경우(p95 > 5s), 텍스트 우선 원칙(RULE-008)을 지키도록 비동기/Lazy 처리가 가능하다.

## 영향받는 파일

**생성**:

- `backend/src/unknown_world/services/image_postprocess.py` - rembg 호출/폴백 로직

**수정**:

- `backend/src/unknown_world/services/image_generation.py` - 이미지 생성 후 rembg 후처리 호출 통합
- `backend/src/unknown_world/models/turn.py` - `image_job` 스키마에 `remove_background` 옵션 추가

**참조**:

- `vibe/ref/rembg-guide.md` - 모델 선택/옵션 가이드(SSOT)
- `vibe/tech-stack.md` - rembg 버전 고정
- `.cursor/rules/00-core-critical.mdc` - RULE-004/008(안전 폴백/텍스트 우선)

## 구현 흐름

### 1단계: 스키마 확장(`remove_background` 옵션)

- `TurnOutput.render.image_job`에 `remove_background: bool = False` 필드를 추가한다.
- 프론트(Zod) 스키마에도 해당 필드를 동기화한다.

### 2단계: rembg 래퍼 서비스 작성

- `image_postprocess.py`에 rembg CLI 또는 라이브러리 호출 래퍼를 작성한다.
- 모델 자동 선택 로직(이미지 유형 힌트 기반)을 포함하거나, 기본값(`u2net`)으로 시작한다.
- 실패 시 원본 이미지를 반환하는 폴백 처리를 포함한다.

### 3단계: 이미지 생성 파이프라인에 통합

- `image_generation.py`에서 이미지 생성 완료 후 `remove_background=True`면 rembg 서비스를 호출한다.
- 결과 이미지 URL/파일 경로를 반환한다.

### 4단계: 비동기/Lazy 처리(선택)

- rembg 처리가 오래 걸릴 경우, 텍스트 우선 응답 후 이미지 URL을 Lazy로 제공하는 옵션을 검토한다.
- MVP에서는 동기 처리로 시작하되, 지연이 문제가 되면 RU에서 비동기화한다.

## 의존성 & 연결

**이전 작업에서 가져올 것**:

- **계획서**: [U-019[Mvp]](U-019[Mvp].md) - 이미지 생성 엔드포인트/잡(이미지 생성 계약)
- **계획서**: [U-020[Mvp]](U-020[Mvp].md) - 프론트 이미지 Lazy Render(placeholder/폴백)
- **결과물**: `image_generation.py`의 이미지 생성 함수

**다음 작업에 전달할 것**:

- U-022(Scanner 슬롯)에서 사용자 업로드 이미지→아이템화 시에도 동일 rembg 파이프라인 재사용 가능
- MMP 이미지 편집(U-103)에서 rembg 후처리 확장 기반

## 주의사항

**기술적 고려사항**:

- (RULE-008) 텍스트 우선: rembg 처리 지연이 턴 응답 TTFB를 블로킹하지 않도록 설계한다.
- (RULE-004) 안전 폴백: rembg 실패 시 원본 이미지를 반환하여 UX 중단을 방지한다.
- rembg는 첫 실행 시 모델 다운로드(100~200MB)가 발생할 수 있음 → 배포/로컬 환경에서 사전 다운로드(`rembg d <model>`) 권장.

**잠재적 리스크**:

- rembg 처리 시간이 예상보다 길어질 경우 → 비동기/Lazy 처리로 전환 가능하도록 래퍼를 설계한다.
- 배경 제거 품질이 이미지 유형에 따라 달라질 수 있음 → 모델 선택 로직을 `vibe/ref/rembg-guide.md` 기준으로 구현한다.

## 페어링 질문 (결정 필요)

- [ ] **Q1**: MVP에서 rembg 호출은 동기(블로킹)로 할까, 비동기(job/callback)로 할까?
  - Option A: 동기(권장: 단순, 이미지 생성 자체도 동기이므로 일관성)
  - Option B: 비동기(Lazy 이미지 제공, TTFB 최적화 가능하나 복잡도 증가)

- [ ] **Q2**: rembg 모델 선택은 자동(힌트 기반)으로 할까, 고정(`u2net`)으로 시작할까?
  - Option A: 고정(`u2net`) — MVP에서 단순하게 시작
  - Option B: 자동(힌트 기반) — 이미지 유형에 따라 최적 모델 선택

## 참고 자료

- `vibe/ref/rembg-guide.md` - rembg 모델 선택/옵션 가이드
- `vibe/prd.md` - 6.3 멀티모달 렌더링 파이프라인
- `.cursor/rules/00-core-critical.mdc` - RULE-004/008
</file>

<file path="vibe/unit-plans/U-036[Mvp].md">
# U-036[Mvp]: 스토리/이미지 프롬프트 파일 분리(ko/en) + 핫리로드

## 메타데이터

| 항목      | 내용        |
| --------- | ----------- |
| Unit ID   | U-036[Mvp]  |
| Phase     | MVP         |
| 예상 소요 | 60분        |
| 의존성    | U-017,U-019 |
| 우선순위  | High        |

## 작업 목표

스토리(텍스트) 및 이미지 생성에 사용되는 **핵심 프롬프트**를 **별도 `.md` 파일**로 분리하고, 한국어/영어 형태로 관리하여 **편집/튜닝/버전 관리**를 용이하게 한다.

**배경**: PRD 3.2에서 프롬프트를 별도 파일로 관리하도록 요구하며, 10.4에서 프롬프트 핫리로드를 명시한다. 프롬프트가 코드에 하드코딩되면 튜닝/실험이 어렵고, ko/en 혼합 출력 위반(RULE-007) 리스크가 증가한다.

**완료 기준**:

- `backend/prompts/` 디렉토리 구조가 PRD 3.2 예시에 맞게 생성된다.
- 최소 2종 프롬프트(시스템/이미지)가 ko/en 파일로 분리되어 저장된다.
- 프롬프트 로더가 `language` 파라미터에 따라 올바른 파일을 로드한다.
- (권장) 서버 재시작 없이 프롬프트 파일 변경이 반영되는 핫리로드가 동작한다.

## 영향받는 파일

**생성**:

- `backend/prompts/system/game_master.ko.md` - 시스템 프롬프트(한국어)
- `backend/prompts/system/game_master.en.md` - 시스템 프롬프트(영어)
- `backend/prompts/image/scene_prompt.ko.md` - 이미지 생성 프롬프트(한국어)
- `backend/prompts/image/scene_prompt.en.md` - 이미지 생성 프롬프트(영어)
- `backend/prompts/turn/turn_output_instructions.ko.md` - 턴 출력 지시(한국어)
- `backend/prompts/turn/turn_output_instructions.en.md` - 턴 출력 지시(영어)
- `backend/src/unknown_world/services/prompt_loader.py` - 프롬프트 로더/핫리로드 서비스

**수정**:

- `backend/src/unknown_world/orchestrator/pipeline.py` - 프롬프트 로더 호출로 전환
- `backend/src/unknown_world/services/image_generation.py` - 이미지 프롬프트 로더 호출로 전환

**참조**:

- `vibe/prd.md` - 3.2 프롬프트 디렉토리 예시, 10.4 핫리로드
- `.cursor/rules/00-core-critical.mdc` - RULE-007(ko/en 혼합 금지)
- `.cursor/rules/30-prompts-i18n.mdc` - 프롬프트/i18n 관리 규칙

## 구현 흐름

### 1단계: 프롬프트 디렉토리 구조 생성

- PRD 3.2 예시에 맞게 `backend/prompts/` 하위에 `system/`, `turn/`, `image/` 폴더를 생성한다.
- 각 폴더에 `*.ko.md`, `*.en.md` 파일을 생성한다(초안/placeholder).

### 2단계: 프롬프트 로더 서비스 작성

- `prompt_loader.py`에 `load_prompt(category, name, language)` 함수를 구현한다.
- 예: `load_prompt("system", "game_master", "ko-KR")` → `backend/prompts/system/game_master.ko.md` 읽기
- 파일이 없을 경우 기본 언어(ko-KR) 또는 에러 폴백을 제공한다.

### 3단계: 기존 코드에서 하드코딩 프롬프트를 로더 호출로 전환

- `pipeline.py`의 시스템 프롬프트를 로더 호출로 대체한다.
- `image_generation.py`의 이미지 프롬프트를 로더 호출로 대체한다.

### 4단계: (권장) 핫리로드 지원

- 개발 모드(`ENVIRONMENT=development`)에서는 매 호출 시 파일을 다시 읽도록 한다.
- 운영 모드에서는 시작 시 로드 후 캐싱하거나, 주기적 리로드를 지원한다(선택).

## 의존성 & 연결

**이전 작업에서 가져올 것**:

- **계획서**: [U-017[Mvp]](U-017[Mvp].md) - TurnOutput 생성(시스템/턴 프롬프트 사용처)
- **계획서**: [U-019[Mvp]](U-019[Mvp].md) - 이미지 생성 엔드포인트(이미지 프롬프트 사용처)
- **결과물**: 현재 하드코딩된 프롬프트 위치(pipeline.py, image_generation.py)

**다음 작업에 전달할 것**:

- U-021(Scanner 이미지 이해)에서 이미지 분석 프롬프트도 동일 패턴으로 관리 가능
- MMP(U-104 장기 세션 메모리)에서 요약/핀 프롬프트 확장 시 동일 로더 재사용

## 주의사항

**기술적 고려사항**:

- (RULE-007) ko/en 혼합 금지: 로더는 `language` 파라미터에 따라 **단일 언어 파일만** 로드해야 한다.
- 프롬프트 파일에 민감 정보(키/토큰)를 포함하지 않는다(비밀정보 커밋 금지).
- 프롬프트 파일은 마크다운 형식이지만, 렌더링 없이 **텍스트 그대로** 모델에 전달된다.

**잠재적 리스크**:

- 프롬프트 파일이 누락되거나 잘못된 경우 → 폴백(기본 언어/하드코딩)을 제공하여 서비스 중단을 방지한다.
- 핫리로드가 운영 환경에서 예기치 않은 변경을 유발할 수 있음 → 운영에서는 시작 시 로드/캐싱을 기본으로 한다.

## 페어링 질문 (결정 필요)

- [ ] **Q1**: MVP에서 핫리로드는 어느 수준까지 지원할까?
  - Option A: 개발 모드에서만 매 호출 시 리로드(권장: 운영 안정성 유지)
  - Option B: 운영에서도 주기적 리로드(복잡도 증가)

- [ ] **Q2**: 프롬프트 파일 형식은 순수 텍스트로 할까, 프론트매터(메타 포함) 마크다운으로 할까?
  - Option A: 순수 텍스트(단순, MVP 권장)
  - Option B: 프론트매터(버전/정책 메타 포함) — PRD 10.4 요구 충족(버전 기록)

## 참고 자료

- `vibe/prd.md` - 3.2 프롬프트 디렉토리 예시, 10.4 프롬프트 라이프사이클
- `.cursor/rules/30-prompts-i18n.mdc` - 프롬프트/i18n 관리 규칙
- `.cursor/rules/00-core-critical.mdc` - RULE-007(ko/en 혼합 금지)
</file>

<file path="vibe/unit-plans/U-037[Mvp].md">
# U-037[Mvp]: CRT 지글거림 보강(Readable 완화 프로파일)

## 메타데이터

| 항목      | 내용        |
| --------- | ----------- |
| Unit ID   | U-037[Mvp]  |
| Phase     | MVP         |
| 예상 소요 | 60분        |
| 의존성    | U-004,U-028 |
| 우선순위  | High        |

## 작업 목표

가독성 개선(Readable 모드) 때문에 CRT 오버레이(지글거림)가 “완전 OFF”로 느껴지지 않도록, **CRT 효과를 완화 프로파일로 재정의**하고 기본/Readable 모드 모두에서 “초기 CRT 감성”을 유지한다.

**배경**: Unknown World의 첫 인상은 CRT 테마(스캔라인/플리커/글로우)에 크게 의존한다. 하지만 Readable 모드가 오버레이를 통째로 숨기면, 가독성은 좋아져도 “게임의 느낌”이 사라져 데모 체감이 약해질 수 있다. (PRD 9.4/9.5, 리스크 R-004)

**완료 기준**:

- Readable 모드에서도 CRT 오버레이가 **완전 비활성화가 아니라 “완화”** 프로파일로 동작한다(예: scanline 대비/플리커 진폭을 낮춤).
- 기본 모드에서는 스캔라인/미세 플리커가 “체감”되며, 과도한 깜빡임/눈부심 없이 텍스트 가독성이 유지된다.
- 접근성: OS `prefers-reduced-motion: reduce` 환경에서는 플리커 애니메이션이 자동으로 완화/비활성화된다(회귀 방지).
- 변경 후에도 상호작용을 방해하지 않는다(`pointer-events: none`), 그리고 Readable 토글/스케일 저장(persist)은 기존과 동일하게 동작한다.

## 영향받는 파일

**생성**:

- (선택) `frontend/src/stores/crtPrefsStore.ts` - CRT 강도 프로파일을 별도 상태로 분리할 경우(필요 시)

**수정**:

- `frontend/src/style.css` - CRT 오버레이/Readable 모드 규칙을 “완화” 중심으로 재정의(강도 토큰/프로파일 도입)
- `frontend/src/stores/uiPrefsStore.ts` - (선택) CRT 강도 토큰을 UI prefs에 포함하고 DOM에 적용(필요 시)
- `frontend/src/App.tsx` - (선택) 헤더 UI에 CRT 강도(프로파일) 컨트롤을 추가(필요 시)

**참조**:

- `vibe/prd.md` - 9.4 접근성/Readable, 9.5 CRT 효과
- `vibe/unit-plans/U-028[Mvp].md` - Readable 모드/스케일(가독성 SSOT)
- `vibe/unit-plans/U-004[Mvp].md` - CRT 테마/오버레이 기본 규칙
- `.cursor/rules/10-frontend-game-ui.mdc` - CRT 테마/게임 UI 규칙

## 구현 흐름

### 1단계: Readable 모드 정책 재정의(“완전 OFF” → “완화”)

- Readable 모드에서 `.crt-overlay`를 `display: none`으로 숨기지 않고, **투명도/대비/플리커 진폭/속도**를 낮춘다.
- 기본 모드(Readable=false)는 기존 CRT 톤을 유지하되, “너무 강해서 읽기 어려움”으로 회귀하지 않게 진폭을 토큰으로 제어한다.

### 2단계: CSS 강도 토큰(프로파일) 도입

- CRT 오버레이에 아래와 같은 토큰을 도입한다(예시):
  - `--crt-overlay-opacity`
  - `--crt-scanline-strength`
  - `--crt-flicker-opacity-min` / `--crt-flicker-opacity-max`
  - (선택) `--crt-flicker-speed`
- `html[data-readable='true']`에서 위 토큰을 “Readable 프로파일 값”으로 덮어쓴다.

### 3단계: 접근성(자동 완화) 가드 추가

- `@media (prefers-reduced-motion: reduce)`에서 플리커 애니메이션을 비활성화하거나(또는 정적/저빈도) 강도를 최소화한다.
- (선택) `prefers-contrast` 등 대비 설정이 켜진 경우에도 오버레이 대비를 더 낮춘다.

### 4단계: 수동 검증(런북)

- 기본 모드: CRT 지글거림이 **체감**되고, 내러티브/Agent Console 마이크로 텍스트가 읽힌다.
- Readable 모드: CRT가 “완전 OFF”로 느껴지지 않지만, 장시간 읽기 편하다.
- `prefers-reduced-motion` 환경: 플리커가 자동으로 완화/비활성화된다.
- 오버레이가 클릭/드래그/스크롤을 방해하지 않는다(`pointer-events: none`).

## 의존성 & 연결

**이전 작업에서 가져올 것**:

- **계획서**: [U-028[Mvp]](U-028[Mvp].md) - Readable 모드/스케일 정책(가독성 Hard Gate)
- **계획서**: [U-004[Mvp]](U-004[Mvp].md) - CRT 테마/오버레이 기본 규칙

**다음 작업에 전달할 것**:

- U-009~U-015(핵심 UI)에서 “Readable을 켜도 CRT 정체성이 남는” 기본 룰
- U-032(Chrome), U-038(아이콘 v2)에서 Readable 모드 대비/강도 튜닝 기준

## 주의사항

**기술적 고려사항**:

- 플리커는 사용자를 불편하게 하거나(특히 광과민) 피로를 유발할 수 있으므로, 강도 토큰/`prefers-reduced-motion` 가드를 반드시 둔다.
- CRT 오버레이는 장식이며, 정보 전달/접근성은 텍스트/라벨이 SSOT다.

**잠재적 리스크**:

- “강도 낮춤”이 너무 약하면 여전히 체감이 없음 → 기본/Readable 프로파일 값을 2~3회 빠르게 튜닝하고, 최소 체감 기준을 런북에 명시한다.

## 페어링 질문 (결정 필요)

- [ ] **Q1**: Readable 모드의 목적을 어떻게 정의할까?
  - Option A: **완화**(CRT 감성 유지, 권장) ✅
  - Option B: 완전 OFF(가독성 최우선) — 대신 별도 “CRT ON” 프로파일/토글이 필요
- [ ] **Q2**: CRT 강도 컨트롤을 MVP에 포함할까?
  - Option A: 우선 CSS 프로파일만(기본/Readable/OS reduced motion)으로 해결 ✅
  - Option B: UI에서 프로파일(예: CRT/BAL/READ/OFF) 선택까지 제공

## 참고 자료

- `vibe/prd.md` - 9.4/9.5 (Readable/CRT)
- `frontend/src/style.css` - CRT overlay/Readable 모드 구현(SSOT)
- [MDN: prefers-reduced-motion](https://developer.mozilla.org/en-US/docs/Web/CSS/@media/prefers-reduced-motion) - 접근성 가드
</file>

<file path="vibe/unit-plans/U-038[Mvp].md">
# U-038[Mvp]: 핵심 UI 아이콘 12종 재생성(v2, 퀄리티/용량/사이즈/식별성)

## 메타데이터

| 항목      | 내용                  |
| --------- | --------------------- |
| Unit ID   | U-038[Mvp]            |
| Phase     | MVP                   |
| 예상 소요 | 75분                  |
| 의존성    | U-033,U-034,U-030,U-028 |
| 우선순위  | High                  |

## 작업 목표

Signal/Shard/Risk 등 “한눈에 의미를 전달해야 하는” 핵심 UI 아이콘 12종을 **v2로 재생성**하여, 작은 크기(16px)에서도 식별되는 퀄리티와 파일 용량/배율 규칙을 고정한다.

**배경**: Unknown World는 “채팅 앱이 아닌 게임 UI” 인상이 중요하고(PRD 6.7), 아이콘은 텍스트보다 빠르게 의미를 전달한다. 하지만 아이콘이 흐리거나 구분이 어려우면 오히려 UX를 해치고, 에셋이 커지면 성능 예산을 빠르게 소모한다. 따라서 아이콘은 “형태(식별성) + 예산(용량) + 사이즈(배율)”을 함께 관리해야 한다.

**완료 기준**:

- “핵심 아이콘 12종(SSOT)” 목록을 확정하고, 네이밍/폴백/사용처(usedIn)가 함께 정의된다.
- 각 아이콘은 최소 16/24 2종 사이즈로 제공되며(선택: 32/64), **16px에서도 실루엣이 구분**된다.
- 에셋 예산을 준수한다: 아이콘 1개 20KB 권장(상한 30KB), `ui/` 총합 1MB 권장(상한 1.5MB). 초과 시 압축/리사이즈/형태 단순화로 해결한다.
- `frontend/public/ui/manifest.json`에 교체/추가된 아이콘의 `bytes/usedIn/totalBytes`가 갱신되고, UI에서 아이콘/폴백이 정상 동작한다.

## 영향받는 파일

**생성**:

- `frontend/public/ui/icons/*` - v2 아이콘 PNG(투명)
- (선택) `frontend/public/ui/icons/*@2x.png` - Retina 대응이 필요한 경우

**수정**:

- `frontend/public/ui/manifest.json` - 아이콘 목록/용량/예산/사용처 갱신
- `frontend/public/ui/README.md` - (선택) 핵심 아이콘 12종(SSOT) 목록 명시 및 예산/워크플로우 보강
- `frontend/src/App.tsx` - Signal/Shard/Risk 아이콘 경로/사이즈 연결(필요 시 16/24 사용처 분리)
- `frontend/src/components/AgentConsole.tsx` - Badge 아이콘 경로/사이즈 연결(필요 시)
- `frontend/src/style.css` - 아이콘 크기 토큰/필터(리스크 등급) 및 (선택) Retina `image-set()` 지원

**참조**:

- `vibe/ref/nanobanana-mcp.md` - 아이콘 프롬프트 템플릿/아트 디렉션
- `vibe/ref/rembg-guide.md` - (조건부) 배경 제거(rembg)
- `vibe/ref/imagemagick-guide.md` - trim/resize/extent(배율) 워크플로우
- `frontend/public/ui/manifest.schema.json` - 매니페스트 스키마(SSOT)
- `frontend/public/ui/README.md` - 에셋 예산/폴백/Retina 규칙

## 구현 흐름

### 1단계: “12종 아이콘” 스펙 확정(SSOT)

- PRD의 “핵심 UI 아이콘 12종(SSOT)” 목록을 기준으로, MVP 범위의 아이콘 ID/파일명을 확정한다.
- 현재 `frontend/public/ui/icons/`의 기존 파일(12개)을 “교체 대상(v1→v2)”로 삼고, 누락된 페어(예: `shard-16`, `risk-medium-24`, `badge-fail-16`)는 필요 시 추가한다.
- 각 아이콘에 대해 최소 정보를 정리한다:
  - `id` / `path` / `fallback` / `usedIn` / `requiredSizes(16,24,...)`

### 2단계: nanobanana mcp로 v2 아이콘 생성(마스터)

- 공통 아트 디렉션(SSOT): CRT 레트로/인광 그린 기반, 단순 실루엣, 고대비, **텍스트 렌더링 금지(i18n)**.
- (필수 조건부) 투명 배경이 필요한데 결과에 배경이 섞이면 `rembg` 후처리를 전제하고, 원본 생성 시 **배경을 순백(#FFFFFF) 단색**으로 강제한다.
- 생성은 “마스터(큰 크기)”로 먼저 만들고, 후처리로 16/24/32/64를 파생한다(일관성/품질 유지).

### 3단계: 후처리(rembg + ImageMagick)로 사이즈/배율 확정

- (조건부) `rembg`로 배경 제거(알파 채널 확보) 후, ImageMagick으로 아래 순서를 표준화한다:
  1) `-trim +repage` (여백 제거)
  2) `-resize` (필요 사이즈로 축소/확대)
  3) `-gravity center -background transparent -extent` (캔버스 정렬/통일)
- 픽셀/샤프 엣지를 유지해야 하면 `-filter point` 같은 옵션을 검토한다(아이콘 스타일에 따라 결정).
- 결과물이 예산을 초과하면, 먼저 “색상 수/디테일/글로우”를 줄여 단순화한다.

### 4단계: 반영 + 매니페스트/QA 갱신

- `frontend/public/ui/icons/` 파일 교체/추가 후 `manifest.json`의 `bytes`, `totalBytes`, `usedIn`을 갱신한다.
- 기본/Readable 모드에서 대비와 식별성을 확인한다(특히 16px).
- 로딩 실패 시 텍스트/이모지 폴백이 유지되는지 확인한다.

## 의존성 & 연결

**이전 작업에서 가져올 것**:

- **계획서**: [U-030[Mvp]](U-030[Mvp].md) - 에셋 SSOT(경로/네이밍/예산/폴백)
- **계획서**: [U-033[Mvp]](U-033[Mvp].md) - manifest/QA로 추적하는 운영 방식
- **계획서**: [U-034[Mvp]](U-034[Mvp].md) - 아이콘 프롬프트 템플릿(재현성)
- **계획서**: [U-028[Mvp]](U-028[Mvp].md) - Readable 모드(대비/가독성 기준)

**다음 작업에 전달할 것**:

- U-009(Action Deck), U-014(Economy HUD), U-023(Autopilot UI) 등에서 재사용 가능한 “핵심 아이콘 세트(v2)”
- “아이콘 교체/추가 시 반드시 manifest/QA를 갱신한다”는 운영 규칙

## 주의사항

**기술적 고려사항**:

- 아이콘 이미지 안에 텍스트를 박지 않는다(언어/i18n/리사이즈 문제).
- 외부 로고/상표를 그대로 복제하지 않는다(라이선스/브랜딩 혼동 방지).
- (선택) Retina는 무조건 추가하지 말고, “16px에서 깨짐/뭉개짐”이 확인될 때만 `@2x`를 도입한다(파일 수/관리 비용 증가).

**잠재적 리스크**:

- 스타일 불일치(아이콘마다 톤이 다름) → 공통 템플릿/팔레트(SSOT)를 강제하고, 생성→후처리→QA를 한 루프로 반복한다.
- 파일 비대화 → 디테일/글로우를 줄여 단순화하고, 필요한 사이즈만 제공한다.

## 페어링 질문 (결정 필요)

- [ ] **Q1**: “12종”의 범위를 어떻게 잡을까?
  - Option A: 현재 `icons/` 폴더의 **12개 파일(v1)** 을 v2로 교체(범위 최소, 권장) ✅
  - Option B: “개념 12종 × (16/24)”로 확장하여 누락 페어까지 모두 채움(품질 ↑, 파일 수 ↑)
- [ ] **Q2**: 아이콘 스타일을 어디에 맞출까?
  - Option A: 픽셀 아트/샤프 엣지(레트로 감성 ↑, 배율/후처리 중요) ✅
  - Option B: 미니멀 라인 아트(가독성 ↑, 작은 크기에서 선 굵기 튜닝 필요)

## 참고 자료

- `vibe/prd.md` - 9.7 UI 이미지 에셋 파이프라인(예산/폴백/SSOT)
- `frontend/public/ui/README.md` - 에셋 예산/Retina/폴백 규칙(SSOT)
- `vibe/ref/nanobanana-mcp.md` - 프롬프트 템플릿/아트 디렉션
- `vibe/ref/imagemagick-guide.md` - 리사이즈/trim/extent 워크플로우
</file>

<file path="vibe/unit-results/CP-MVP-01.md">
# CP-MVP-01: 체크포인트 - 스트리밍/스키마/폴백 개발 완료 보고서

## 메타데이터

- **작업 ID**: CP-MVP-01
- **단계 번호**: 2.3
- **작성 일시**: 2026-01-10 13:00
- **담당**: AI Agent

---

## 1. 작업 요약

초기 MVP 루프의 핵심인 **스트리밍, 스키마 검증, 자동 복구 및 안전 폴백** 메커니즘이 PRD 하드 게이트(RULE-004/008)를 준수하며 안정적으로 동작함을 최종 검증하고 문서를 동기화함.

---

## 2. 작업 범위

- [x] **NDJSON 스트리밍 검증**: 서버(FastAPI)와 클라이언트(Fetch) 간의 단계별 이벤트(Stage/Badges) 및 내러티브 델타 전송 확인
- [x] **이중 검증 체계 확인**: 서버(Pydantic) 및 클라이언트(Zod)의 TurnOutput 엄격 검증 로직 점검
- [x] **복구 및 폴백 루프 검증**: 스키마 실패 또는 네트워크 에러 시 Repair loop 및 Safe fallback 동작 확인
- [x] **인바리언트 체크**: 채팅 UI 배제, 프롬프트 은닉, 0~1000 좌표 규약 준수 확인

---

## 3. 생성/수정 파일

_(분석 기반 주요 파일)_

| 파일 경로 | 유형 | 목적 |
| --------- | ---- | ---- |
| `backend/src/unknown_world/api/turn.py` | 수정 | 스트리밍 엔드포인트 및 서버측 폴백 로직 |
| `backend/src/unknown_world/api/turn_stream_events.py` | 신규 | 스트림 이벤트 계약(Contract) SSOT |
| `frontend/src/api/turnStream.ts` | 수정 | NDJSON 파서 및 클라이언트측 검증/폴백 로직 |
| `frontend/src/schemas/turn.ts` | 수정 | Zod 기반 TurnOutput 스키마 및 안전 파싱 유틸리티 |
| `vibe/unit-runbooks/CP-MVP-01.md` | 신규 | 체크포인트 재현을 위한 수동 검증 런북 |

---

## 4. 구현 상세

### 4.1 핵심 설계

**주요 계약 (Stream Events)**:
- `StageEvent`: 처리 단계(Parse→...→Commit) 시각화 (RULE-008)
- `BadgesEvent`: 검증 상태(Schema/Economy/Safety OK) 가시화
- `RepairEvent`: 자동 복구 시도 알림 (RULE-004)
- `FinalEvent`: 최종 구조화 출력(`TurnOutput`)

**설계 패턴/원칙**:
- **Fail-safe 종료 인바리언트**: 어떤 에러 상황에서도 최종적으로 `final` 이벤트를 송출하여 UI 멈춤 방지
- **이중 검증(Double Validation)**: 서버 Pydantic 검증 후 클라이언트 Zod Strict Parse 수행
- **NDJSON 버퍼 파싱**: 청크 단위 수신 시 라인 복구 및 부분 파싱 실패 격리

### 4.2 외부 영향 분석

- **데이터/파일 시스템**: 영향 없음 (메모리 내 스트리밍 처리)
- **권한/보안**: 내부 추론(CoT) 및 프롬프트 원문 스트림 제외 (RULE-007 준수)
- **빌드/의존성**: Pydantic V2 및 Zod 4.x 필수 사용

---

## 5. 런북(Runbook) 정보

- **파일 경로**: `vibe/unit-runbooks/CP-MVP-01.md`
- **실행 결과**: 성공 경로(정상 턴), 실패 경로(스키마 위반), 에러 경로(네트워크 단절) 시나리오 모두 통과
- **참조**: 상세 재현 방법은 위 런북 파일 참조

---

## 6. 리스크 및 주의사항

- **네트워크 지연**: TTFB 2초 목표 달성을 위해 첫 `stage(start)` 이벤트가 즉시 송출되어야 함
- **스키마 불일치**: 서버와 클라이언트의 스키마 버전(`1.0.0`) 동기화가 깨질 경우 폴백 빈도 증가 가능

---

## 7. 다음 단계 안내

### 7.1 후속 작업

1. **U-009[Mvp]**: Action Deck UI 컴포넌트 구현
2. **U-010[Mvp]**: Scene Canvas + Hotspot 오버레이 구현

### 7.2 의존 단계 확인

- **선행 단계**: RU-002[Mvp] (완료)
- **후속 단계**: M2 마일스톤 (핵심 UI 개발)

---

## 8. 자체 점검 결과

- [x] 런북 기반 요구사항 충족 확인
- [x] Repomix 최신 구조 반영 확인
- [x] 아키텍처/네이밍/경로 일관성 유지
- [x] 파괴적 변경/리스크/가정 명시

---

_본 보고서는 AI Agent에 의해 자동 생성되었습니다._
</file>

<file path="vibe/unit-results/RU-001[Mvp].md">
# 리팩토링 - 디렉토리/설정 정리 개발 완료 보고서

## 메타데이터

- **작업 ID**: RU-001[Mvp]
- **단계 번호**: 1.2
- **작성 일시**: 2026-01-04 19:15
- **담당**: AI Agent

---

## 1. 작업 요약

스캐폴딩 초기 단계의 불일치를 제거하고, `shared/` 기반의 SSOT(JSON Schema) 체계를 도입하여 향후 유닛들이 일관된 규칙(RULE-001~011) 하에 개발될 수 있도록 프로젝트 전반의 구조와 설정을 리팩토링함.

---

## 2. 작업 범위

- **디렉토리 구조 확정**: `frontend/`, `backend/`, `shared/` 삼분할 구조 및 명명 규칙 통일
- **JSON Schema SSOT 도입**: `shared/schemas/turn/` 내 `TurnInput`, `TurnOutput` 스키마 구축
- **버전 및 환경 제어**: 루트 `package.json`에 Node/pnpm 버전 명시 및 백엔드 의존성 고정(uv sync 기준)
- **포트 정책 강제**: RULE-011 준수(프론트 8001, 백엔드 8011) 및 `strictPort`를 통한 충돌 방지
- **실행 스크립트 단일화**: 루트 `package.json`의 `dev:front`, `dev:back`을 통한 일관된 실행 환경 보장
- **보안 및 무시 정책**: `.gitignore` 리팩토링을 통해 스키마 파일 추적 및 보안 민감 파일(service-account 등) 차단 강화

---

## 3. 생성/수정 파일

| 파일 경로 | 유형 | 목적 |
| --------- | ---- | ---- |
| `package.json` | 수정 | 루트 실행 스크립트 단일화 및 도구 버전(Node/pnpm) 명시 |
| `shared/schemas/turn/*.json` | 신규 | 클라이언트-서버 간 계약을 위한 JSON Schema SSOT |
| `shared/README.md` | 신규 | 공유 스키마 운영 전략(Option B) 명시 |
| `backend/pyproject.toml` | 수정 | 의존성 고정(==) 및 Pyright 설정 단일화 |
| `backend/src/unknown_world/main.py` | 수정 | RULE-011 기반 CORS 허용 범위 및 docstring 업데이트 |
| `frontend/vite.config.ts` | 수정 | RULE-011 포트 지정 및 `strictPort: true` 설정 |
| `.gitignore` | 수정 | JSON 정책 리팩토링 및 `shared/` 추적 허용 |
| `vibe/roadmap.md` | 수정 | 실행 가이드 및 포트 정책 정합성 동기화 |

---

## 4. 구현 상세

### 4.1 핵심 설계

**주요 계약 (JSON Schema SSOT)**:
- `TurnInput`: 언어, 텍스트, 클릭 좌표(0~1000), 뷰포트 정보, 재화 스냅샷 포함
- `TurnOutput`: 내러티브, UI(선택지/오브젝트), 월드 상태(델타), 렌더 잡, 경제(비용/잔액), 안전 상태 포함

**설계 패턴/원칙**:
- **Option B (JSON Schema SSOT)**: 서버와 클라이언트가 `shared/` 내의 동일한 JSON 스키마 파일을 참조하여 각각 Pydantic과 Zod 모델을 생성/검증하도록 함.
- **Fail-fast (strictPort)**: 포트 충돌 시 임의의 포트로 변경되지 않도록 강제하여 CORS 불일치 문제를 예방함.

### 4.2 외부 영향 분석

- **데이터/파일 시스템**: `shared/` 디렉토리가 새롭게 추가되었으며, 향후 모든 스키마의 중심점이 됨.
- **권한/보안**: 서비스 계정 키 파일에 대한 ignore 정책이 강화되었으며, `secrets/` 디렉토리가 표준 보안 저장소로 명시됨.
- **빌드/의존성**: `uv.lock` 및 `pnpm-lock.yaml`과 `pyproject.toml` 간의 버전 정합성이 확보됨.

### 4.3 가정 및 제약사항

- 모든 개발자는 Node.js `24.12.0` 및 pnpm `10.27.0` 환경을 사용하는 것을 전제로 함.
- 포트 8001~8020 대역은 이 프로젝트 전용으로 예약된 것으로 간주함.

---

## 5. 런북(Runbook) 정보

- **파일 경로**: `vibe/unit-runbooks/RU-001[Mvp]-runbook.md` (참조: `RU-001-S1`~`Q5` 세부 런북)
- **실행 결과**: 루트 스크립트를 통한 프론트/백엔드 동시 실행 및 포트 정책 준수 확인 완료
- **참조**: `pnpm dev:front` (8001), `pnpm dev:back` (8011)

---

## 6. 리스크 및 주의사항

- **스키마 변경**: `shared/` 내부의 스키마 변경 시 반드시 서버와 클라이언트 양쪽의 검증 로직 업데이트가 수반되어야 함.
- **포트 충돌**: 타 프로세스가 8001/8011을 점유 중일 경우 `strictPort`에 의해 실행이 실패하므로 `pnpm kill:port`를 선행해야 함.

---

## 7. 다음 단계 안내

### 7.1 후속 작업

1. **U-005[Mvp]**: `shared/` 스키마를 상속받은 백엔드 Pydantic 모델 구현
2. **U-006[Mvp]**: `shared/` 스키마를 상속받은 프론트엔드 Zod 모델 구현

### 7.2 의존 단계 확인

- **선행 단계**: U-003, U-004 완료 확인됨
- **후속 단계**: M1 마일스톤의 Turn 계약 단계 진입

---

## 8. 자체 점검 결과

- [x] 런북 기반 요구사항 충족 확인
- [x] Repomix 최신 구조 반영 확인
- [x] 아키텍처/네이밍/경로 일관성 유지
- [x] 파괴적 변경/리스크/가정 명시

---

_본 보고서는 AI Agent에 의해 자동 생성되었습니다._
</file>

<file path="vibe/unit-results/RU-002[Mvp].md">
# [RU-002[Mvp]: 리팩토링 - validation/폴백/이벤트 타입 통일] 개발 완료 보고서

## 메타데이터

- **작업 ID**: RU-002[Mvp]
- **단계 번호**: 1.2
- **작성 일시**: 2026-01-10 11:30
- **담당**: AI Agent

---

## 1. 작업 요약

스트림 이벤트(NDJSON), 검증, 폴백 로직이 분산되어 발생하던 불일치를 해결하고, "스키마/경제/안전" 하드 게이트 실패 시에도 일관된 방식으로 표시 및 복구가 가능하도록 서버와 클라이언트의 이벤트 계약을 단일 SSOT로 통합했습니다.

---

## 2. 작업 범위

- **이벤트 계약 통합 (SSOT)**: 서버(`turn_stream_events.py`)와 클라이언트(`turn_stream.ts`) 간의 공통 이벤트 모델 정의
- **서버측 스트리밍 강화**: 입력 검증 실패 시에도 안전한 폴백과 에러 이벤트를 송출하도록 `turn.py` 리팩토링
- **클라이언트측 파서 및 핸들러 개선**: Zod를 사용한 수신 이벤트 이중 검증 및 네트워크 단절 시 클라이언트측 폴백 생성 로직 추가
- **용어 및 라벨 통일**: `AgentPhase` 및 `ValidationBadge` 상수를 사용하여 UI와 백엔드 간의 라벨 정합성 확보

---

## 3. 생성/수정 파일

| 파일 경로 | 유형 | 목적 |
| --------- | ---- | ---- |
| `backend/src/unknown_world/api/turn_stream_events.py` | 신규 | 스트림 이벤트 타입 및 Pydantic 모델 정의 (서버 SSOT) |
| `frontend/src/types/turn_stream.ts` | 신규 | Zod 기반 스트림 이벤트 스키마 및 타입 정의 (클라이언트 SSOT) |
| `backend/src/unknown_world/api/turn.py` | 수정 | 리팩토링된 이벤트를 사용한 스트리밍 및 에러 처리 강화 |
| `frontend/src/api/turnStream.ts` | 수정 | Zod 검증 기반 이벤트 디스패처 및 클라이언트 폴백 로직 적용 |
| `backend/src/unknown_world/orchestrator/mock.py` | 수정 | 폴백 생성 로직 고도화 |

---

## 4. 구현 상세

### 4.1 핵심 설계

**이벤트 계약 (RU-002-Q4)**:
- `StreamEventType`: `stage`, `badges`, `narrative_delta`, `final`, `error`, `repair` 6종으로 표준화.
- `StageStatus`: `start`, `complete`, `fail` 상태로 명확히 분리.

**서버측 견고성**:
- `_validate_and_parse_input`: 요청 본문 파싱 실패 시에도 `language`와 `economy_snapshot`을 최대한 추출하여 문맥에 맞는 폴백 제공.
- `RepairEvent`: 모델 검증 실패 시 `Auto-repair #n` 이벤트를 송출하여 사용자에게 복구 과정을 시각화.

**클라이언트측 안전 장치**:
- `NDJSONParser`: 라인 단위 버퍼링 파서로 네트워크 지연 및 파싱 실패에 강인한 구조 유지.
- `dispatchEvent`: 수신된 모든 이벤트를 Zod로 검증하며, 유효하지 않거나 알 수 없는 이벤트는 무시하고 로그만 기록 (전체 루프 보호).
- **클라이언트측 폴백**: 서버 응답이 `final`에 도달하지 못하고 끊길 경우, 요청 시점의 경제 스냅샷을 유지하며 안전하게 종료하는 기능 추가.

### 4.2 외부 영향 분석

- **UX**: Agent Console에서 표시되는 단계와 배지가 백엔드의 실제 검증 단계와 1:1로 일치하게 됨.
- **안정성**: 어떠한 예외 상황(입력 오류, 네트워크 오류, 모델 검증 실패)에서도 시스템이 멈추지 않고 항상 `final` 결과(폴백 포함)로 수렴함.

### 4.3 가정 및 제약사항

- NDJSON 이벤트의 순서는 기본적으로 서버의 송출 순서를 따르나, 클라이언트는 `final` 수신 전까지 모든 데이터를 축적/처리할 수 있어야 함.

---

## 5. 런북(Runbook) 정보

- **검증 절차**:
  1. 잘못된 JSON 본문으로 `POST /api/turn` 호출 -> `error` 및 `final`(폴백) 수신 확인.
  2. 정상 요청 시 `stage` 순서 및 `narrative_delta` 타자 효과 확인.
  3. 스트리밍 중간에 연결 강제 종료 -> 클라이언트 콘솔에서 에러 로그 및 폴백 UI 노출 확인.

---

## 6. 리스크 및 주의사항

- **이벤트 확장성**: 신규 이벤트 타입 추가 시 반드시 `turn_stream_events.py`와 `turn_stream.ts` 양쪽에 동기화가 필요함.
- **버전 호환성**: MVP에서는 최소 이벤트 셋을 유지하며, 향후 확장 시 하위 호환성을 고려한 Zod 스키마 설계 필요.

---

## 7. 다음 단계 안내

### 7.1 후속 작업

1. **CP-MVP-01**: 전체 시스템의 마일스톤 체크포인트 검증.
2. **U-016[Mvp]**: 실제 Gemini 모델 연동을 위한 Orchestrator 확장.

### 7.2 의존 단계 확인

- **선행 단계**: U-007, U-008 완료
- **후속 단계**: CP-MVP-01, U-016

---

## 8. 자체 점검 결과

- [x] 서버/클라이언트 간 이벤트 계약 통일 완료
- [x] 에러/폴백 시나리오에서도 스키마 준수 및 종료 보장
- [x] Zod 및 Pydantic을 이용한 이중 검증 구조 확립
- [x] 프롬프트/내부 추론 정보의 외부 노출 차단 확인

---

_본 보고서는 AI Agent에 의해 자동 생성되었습니다._
</file>

<file path="vibe/unit-results/test_streaming_manual_v2.py">
import json
from fastapi.testclient import TestClient
from unknown_world.main import app
from unknown_world.models.turn import ValidationBadge

client = TestClient(app)

def test_manual_verification():
    payload = {
        "language": "ko-KR",
        "text": "검증 테스트",
        "client": {"viewport_w": 1920, "viewport_h": 1080, "theme": "dark"},
        "economy_snapshot": {"signal": 100, "memory_shard": 5}
    }
    
    print("\n--- [START] Scenario A/C Verification ---")
    response = client.post("/api/turn?seed=12345", json=payload)
    assert response.status_code == 200
    
    events = []
    for line in response.iter_lines():
        if line:
            event = json.loads(line)
            events.append(event)
            print(f"Event: {event['type']} | Status/Name: {event.get('status', event.get('name', ''))}")

    # 1. 스트림 종료 인바리언트 (항상 final로 끝남)
    assert events[-1]["type"] == "final", "Stream must end with final event"
    print("PASS Invariant: Stream ends with 'final'")

    # 2. RULE-008: 단계 가시화 (Parse -> Commit)
    stages = [e["name"] for e in events if e["type"] == "stage" and e.get("status") == "start"]
    expected_stages = ["parse", "validate", "plan", "resolve", "render", "verify", "commit"]
    assert stages == expected_stages, f"Stage sequence mismatch: {stages}"
    print("PASS RULE-008: 7 phases sequence OK")

    # 3. RULE-009: 좌표 규약 검증
    final_data = next(e["data"] for e in events if e["type"] == "final")
    objects = final_data["ui"]["objects"]
    if objects:
        for obj in objects:
            box = obj["box_2d"]
            # 형식 확인
            assert list(box.keys()) == ["ymin", "xmin", "ymax", "xmax"], f"Invalid BBox keys: {box.keys()}"
            # 범위 확인
            for k, v in box.items():
                assert 0 <= v <= 1000, f"Value out of range (0-1000): {k}={v}"
        print(f"PASS RULE-009: BBox [ymin, xmin, ymax, xmax] 0-1000 OK (count: {len(objects)})")

    print("\n--- [START] Scenario B Verification (Error Fallback) ---")
    invalid_payload = {"text": "", "language": "bad-lang"}
    response = client.post("/api/turn", json=invalid_payload)
    err_events = [json.loads(line) for line in response.iter_lines() if line]
    
    # error + final 순서 확인
    assert err_events[0]["type"] == "error"
    assert err_events[1]["type"] == "final"
    assert err_events[1]["data"]["agent_console"]["badges"] == ["schema_fail"]
    print("PASS Scenario B: error + final(fallback) sequence OK")
    print("--- [COMPLETE] Manual Verification ---")

if __name__ == "__main__":
    test_manual_verification()
</file>

<file path="vibe/unit-results/test_streaming_manual.py">
import asyncio
import json
import httpx
from unknown_world.main import app
import uvicorn
from multiprocessing import Process
import time

def run_server():
    uvicorn.run(app, host="127.0.0.1", port=8011)

async def test_streaming():
    # 서버 실행 (별도 프로세스)
    server_process = Process(target=run_server)
    server_process.start()
    
    # 서버 준비 대기
    time.sleep(3)
    
    try:
        async with httpx.AsyncClient() as client:
            payload = {
                "language": "ko-KR",
                "text": "문을 열어본다",
                "client": {"viewport_w": 1920, "viewport_h": 1080, "theme": "dark"},
                "economy_snapshot": {"signal": 100, "memory_shard": 5}
            }
            
            print("--- Streaming Start ---")
            async with client.stream("POST", "http://127.0.0.1:8011/api/turn?seed=12345", json=payload, timeout=30.0) as response:
                async for line in response.aiter_lines():
                    if not line:
                        continue
                    event = json.loads(line)
                    print(f"Event: {event['type']} | Content: {str(event)[:100]}...")
                    
                    # RULE-009: 좌표 규약 검증 (final 이벤트에서)
                    if event['type'] == 'final':
                        objects = event['data']['ui']['objects']
                        for obj in objects:
                            box = obj['box_2d']
                            print(f"BBox Check: {box}")
                            # ymin, xmin, ymax, xmax 순서 및 0~1000 범위 확인
                            assert all(0 <= v <= 1000 for v in box.values()), f"BBox out of range: {box}"
                            assert list(box.keys()) == ["ymin", "xmin", "ymax", "xmax"], f"BBox keys order mismatch: {box}"
            print("--- Streaming End ---")
            
    finally:
        server_process.terminate()
        server_process.join()

if __name__ == "__main__":
    asyncio.run(test_streaming())
</file>

<file path="vibe/unit-results/U-001[Mvp].md">
# U-001[Mvp]: 프로젝트 스캐폴딩 생성 개발 완료 보고서

## 메타데이터

- **작업 ID**: U-001[Mvp]
- **단계 번호**: 2.3
- **작성 일시**: 2026-01-03 14:30
- **담당**: AI Agent

---

## 1. 작업 요약

이 유닛은 Unknown World 프로젝트의 기반이 되는 프론트엔드(`frontend/`)와 백엔드(`backend/`) 디렉토리 구조를 구축하고, 보안 및 협업을 위한 기본 설정(`.gitignore`, `.gitattributes`)을 완료했습니다.

---

## 2. 작업 범위

- **디렉토리 구조 생성**: `frontend/`, `backend/` 및 하위 필수 디렉토리 생성
- **보안 설정**: `.gitignore`를 통해 비밀정보(API 키, 서비스 계정 등) 유출 방지 패턴 적용
- **플랫폼 호환성**: `.gitattributes`를 통해 운영체제 간 줄 끝(LF) 일관성 확보
- **백엔드 초기화**: Python 패키지 인식을 위한 `backend/src/unknown_world/__init__.py` 생성

---

## 3. 생성/수정 파일

| 파일 경로 | 유형 | 목적 |
| :--- | :--- | :--- |
| `.gitignore` | 신규 | 비밀정보 및 빌드 결과물 제외 설정 |
| `.gitattributes` | 신규 | 줄 끝 처리(LF) 및 바이너리 파일 속성 설정 |
| `frontend/.gitkeep` | 신규 | 프론트엔드 디렉토리 추적용 플레이스홀더 |
| `frontend/src/.gitkeep` | 신규 | 프론트엔드 소스 디렉토리 추적용 플레이스홀더 |
| `backend/.gitkeep` | 신규 | 백엔드 디렉토리 추적용 플레이스홀더 |
| `backend/prompts/.gitkeep` | 신규 | 프롬프트 저장소 디렉토리 추적용 플레이스홀더 |
| `backend/src/unknown_world/__init__.py` | 신규 | Python 패키지 초기화 및 버전 정보 정의 |

---

## 4. 구현 상세

### 4.1 핵심 설계

**디렉토리 구조 전략**:
- `frontend/`: Vite + React 기반 웹 UI가 위치할 독립 디렉토리
- `backend/`: FastAPI 기반 오케스트레이터가 위치할 독립 디렉토리
- `vibe/`: 프로젝트 명세, 로드맵, 기술 스택 등 SSOT 문서 저장소

**보안 전략**:
- `.gitignore`에 `service-account*.json`, `.env`, `*.log`, `__pycache__` 등을 포함하여 민감 정보 및 로컬 환경 파일이 커밋되지 않도록 방어

### 4.2 외부 영향 분석

- **데이터/파일 시스템**: 프로젝트의 전체적인 레이아웃이 확정됨
- **권한/보안**: 로컬 개발 시 생성되는 비밀 파일들이 Git에 노출되지 않도록 설정됨
- **빌드/의존성**: 향후 pnpm(frontend) 및 python/uv(backend) 환경 구축을 위한 기반 마련

---

## 5. 런북(Runbook) 정보

- **파일 경로**: `vibe/unit-runbooks/U-001-scaffolding-runbook.md`
- **실행 결과**:
    - 시나리오 A(구조 확인) 통과
    - 시나리오 B(패키지 임포트) 통과 (버전 0.0.0 확인)
    - 시나리오 C(비밀정보 보호) 통과 (패턴 검증 완료)
- **참조**: 상세 검증 절차는 런북 파일 참조

---

## 6. 리스크 및 주의사항

- **줄 끝 문제**: Windows와 Linux/macOS 간의 CRLF/LF 혼용 방지를 위해 `.gitattributes` 설정을 엄격히 유지해야 함
- **추적 대상**: `package.json`이나 `pyproject.toml` 같은 설정 파일이 실수로 `.gitignore`에 포함되지 않도록 주의함

---

## 7. 다음 단계 안내

### 7.1 후속 작업

1. **U-002**: 프론트엔드 Vite + React 초기화
2. **U-003**: 백엔드 FastAPI 초기화

### 7.2 의존 단계 확인

- **선행 단계**: 해당 없음 (MVP 시작 단계)
- **후속 단계**: U-002[Mvp], U-003[Mvp]

---

## 8. 자체 점검 결과

- [x] 런북 기반 요구사항 충족 확인
- [x] Repomix 최신 구조 반영 확인
- [x] 아키텍처/네이밍/경로 일관성 유지
- [x] 파괴적 변경/리스크/가정 명시

---
_본 보고서는 AI Agent에 의해 자동 생성되었습니다._
</file>

<file path="vibe/unit-results/U-002[Mvp].md">
# 프론트 Vite+React+TS 초기화 개발 완료 보고서

## 메타데이터

- **작업 ID**: U-002[Mvp]
- **단계 번호**: 2.3
- **작성 일시**: 2026-01-03 14:45
- **담당**: AI Agent

---

## 1. 작업 요약

`vibe/tech-stack.md`에 명시된 고정 버전을 사용하여 Vite 7 + React 19 + TypeScript 기반의 프론트엔드 개발 환경을 구축했습니다. 단일 CSS SSOT 원칙과 채팅 UI 금지 원칙을 수용할 수 있는 최소한의 프로젝트 구조를 확보했습니다.

---

## 2. 작업 범위

- **환경 초기화**: Vite 7 + React 19 + TypeScript 5.9 스캐폴딩 생성
- **도구 및 버전 고정**: `package.json` 내 핵심 의존성 버전 고정 및 `pnpm@10.27.0` 명시
- **기본 구조 설계**: 단일 `style.css` SSOT 구조 및 `App.tsx` 최소 컨테이너 구현
- **품질 도구 설정**: ESLint(Flat Config) 및 Prettier 설정 완료
- **실행 검증**: `pnpm dev`, `pnpm build`, `pnpm run typecheck` 성공 확인

---

## 3. 생성/수정 파일

| 파일 경로 | 유형 | 목적 |
| :--- | :--- | :--- |
| `frontend/package.json` | 신규 | 의존성 버전 고정 및 스크립트 정의 |
| `frontend/vite.config.ts` | 신규 | Vite 빌드 및 서버 설정 |
| `frontend/tsconfig.json` | 신규 | TypeScript 엄격 모드 설정 |
| `frontend/src/main.tsx` | 신규 | React 엔트리 포인트 |
| `frontend/src/App.tsx` | 신규 | 최소 컨테이너 컴포넌트 (채팅 UI 배제) |
| `frontend/src/style.css` | 신규 | 단일 CSS SSOT 및 초기 테마 변수 |

---

## 4. 구현 상세

### 4.1 핵심 설계

**버전 고정 전략**:
- `vibe/tech-stack.md`와 100% 일치하도록 `react@19.2.3`, `vite@7.3.0`, `typescript@5.9.3` 등을 고정했습니다.

**스타일 및 UI 원칙**:
- **RULE-002 (채팅 금지)**: `App.tsx`에 메신저 형태의 말풍선 UI가 포함되지 않도록 단순 헤더와 메인 영역으로 구성했습니다.
- **단일 CSS SSOT**: `style.css`에 초기 변수(`:root`)를 설정하고, 향후 U-004에서 CRT 테마로 확장하기 용이하게 설계했습니다.

### 4.2 외부 영향 분석

- **데이터/파일 시스템**: `frontend/` 디렉토리에 약 1.7MB(pnpm-lock 포함)의 초기 프로젝트 에셋이 생성되었습니다.
- **권한/보안**: 개발 서버는 5173 포트를 사용하며 `strictPort: true` 설정으로 충돌을 방지합니다.
- **빌드/의존성**: `pnpm`을 통한 패키지 관리 체계를 확립했습니다.

---

## 5. 런북(Runbook) 정보

- **파일 경로**: `vibe/unit-runbooks/U-002-frontend-init-runbook.md`
- **실행 결과**:
    - 시나리오 A(서버 동작): 통과 (localhost:5173 렌더링 확인)
    - 시나리오 B(린트/타입체크): 통과
    - 시나리오 C(빌드): 통과 (`dist/` 생성 및 에러 없음)
- **참조**: 상세 실행 절차는 런북 파일 참조

---

## 6. 리스크 및 주의사항

- **UI 유도 주의**: 현재는 빈 템플릿에 가깝지만, 향후 컴포넌트 추가 시 채팅 버블 형태로 회귀하지 않도록 U-004(게임 UI) 작업을 우선순위에 두어야 합니다.
- **Tailwind 금지**: 프로젝트 스타일 가이드에 따라 Tailwind CSS 도입을 엄격히 배제하고 `style.css` 중심의 관리를 유지해야 합니다.

---

## 7. 다음 단계 안내

### 7.1 후속 작업

1. **U-003**: 백엔드 FastAPI 초기화
2. **U-004**: CRT 테마 및 고정 게임 UI 레이아웃 구현

### 7.2 의존 단계 확인

- **선행 단계**: U-001[Mvp] 완료
- **후속 단계**: U-003[Mvp], U-004[Mvp]

---

## 8. 자체 점검 결과

- [x] 런북 기반 요구사항 충족 확인
- [x] Repomix 최신 구조 반영 확인
- [x] 아키텍처/네이밍/경로 일관성 유지
- [x] 파괴적 변경/리스크/가정 명시

---
_본 보고서는 AI Agent에 의해 자동 생성되었습니다._
</file>

<file path="vibe/unit-results/U-003[Mvp].md">
# 백엔드 FastAPI 초기화 개발 완료 보고서

## 메타데이터

- **작업 ID**: U-003[Mvp]
- **단계 번호**: 1.2
- **작성 일시**: 2026-01-04 01:25
- **담당**: AI Agent

---

## 1. 작업 요약

FastAPI 기반 오케스트레이터 백엔드의 최소 실행 골격을 구축하였습니다. 헬스체크 엔드포인트와 개발용 CORS 정책을 포함하며, `uv`를 통한 현대적인 Python 패키지 관리 환경을 구성했습니다.

---

## 2. 작업 범위

- **FastAPI 앱 초기화**: `main.py`에 기본 앱 인스턴스 생성 및 메타데이터 설정
- **엔드포인트 구현**: 헬스체크(`/health`) 및 루트(`/`) 라우트 추가
- **CORS 정책 설정**: RULE-011(프론트엔드 포트 8001~8010)을 준수하는 개발용 CORS 미들웨어 적용
- **의존성 관리**: `pyproject.toml`에 `vibe/tech-stack.md` SSOT 기준 버전 고정
- **검증 환경**: 통합 테스트(`test_api.py`) 및 런북 작성 완료

---

## 3. 생성/수정 파일

| 파일 경로 | 유형 | 목적 |
| --------- | ---- | ---- |
| `backend/pyproject.toml` | 신규 | 백엔드 프로젝트 설정 및 의존성 고정 |
| `backend/src/unknown_world/__init__.py` | 신규 | 패키지 루트 및 버전 정의 |
| `backend/src/unknown_world/main.py` | 신규 | FastAPI 앱 엔트리포인트 및 기본 라우트 |
| `backend/tests/integration/test_api.py` | 신규 | API 엔드포인트 및 CORS 정책 검증 테스트 |
| `package.json` | 수정 | 루트 수준의 백엔드 실행 및 프로세스 제어 스크립트 추가 |

---

## 4. 구현 상세

### 4.1 핵심 설계

**주요 계약**:

- `GET /health` -> `HealthResponse`: 서버 상태, 버전, 서비스명 반환
- `GET /` -> `dict`: API 안내 메시지 및 주요 경로 노출

**설계 패턴/원칙**:

- **Pydantic 기반 스키마**: `/health` 응답에 명시적인 모델(`HealthResponse`)을 사용하여 구조화된 출력 보장
- **RULE-011 준수**: 프론트엔드 개발 포트 범위를 허용 오리진으로 자동 생성하여 설정

### 4.2 외부 영향 분석

- **데이터/파일 시스템**: 없음 (DB 미사용 원칙 준수)
- **권한/보안**: Vertex AI 서비스 계정 인증 준비 (MMP 연동 예정)
- **빌드/의존성**: `uv`를 사용한 고속 패키지 관리 환경 도입

### 4.3 가정 및 제약사항

- 로컬 개발 환경에서는 프론트엔드가 8001~8010 포트를 사용한다고 가정함
- 백엔드 개발 서버는 8011 포트를 기본값으로 사용함

---

## 5. 런북(Runbook) 정보

- **파일 경로**: `vibe/unit-runbooks/U-003-backend-init-runbook.md`
- **실행 결과**: 헬스체크, Swagger UI 렌더링, CORS Preflight 요청 테스트 통과
- **참조**: 상세 실행 방법은 위 런북 파일 참조

---

## 6. 리스크 및 주의사항

- **CORS 설정**: 현재 모든 메소드와 헤더를 허용하고 있으므로, 배포 단계(MMP)에서 엄격한 정책으로 전환 필요

---

## 7. 다음 단계 안내

### 7.1 후속 작업

1. **U-005**: TurnInput/TurnOutput(Pydantic) 모델 추가
2. **U-007**: `/api/turn` SSE 스트리밍 라우트 추가

### 7.2 의존 단계 확인

- **선행 단계**: U-001[Mvp] 완료
- **후속 단계**: U-005[Mvp]

---

## 8. 자체 점검 결과

- [x] 런북 기반 요구사항 충족 확인
- [x] Repomix 최신 구조 반영 확인
- [x] 아키텍처/네이밍/경로 일관성 유지
- [x] 파괴적 변경/리스크/가정 명시

---

_본 보고서는 AI Agent에 의해 자동 생성되었습니다._
</file>

<file path="vibe/unit-results/U-004[Mvp].md">
# U-004[Mvp]: CRT 테마/고정 레이아웃 스켈레톤 개발 완료 보고서

## 메타데이터

- **작업 ID**: U-004[Mvp]
- **단계 번호**: 1.2
- **작성 일시**: 2026-01-04 02:00
- **담당**: AI Agent

---

## 1. 작업 요약

채팅 UI를 배제하고 게임 시스템으로서의 정체성을 확립하기 위해, CSS Grid 기반의 고정 HUD 레이아웃과 CRT 터미널 레트로 미학을 반영한 테마 스켈레톤을 구현했습니다. 이를 통해 PRD의 핵심 요구사항인 "채팅 버블 UI 금지(RULE-002)"를 기술적으로 강제하고 시각적으로 증명했습니다.

---

## 2. 작업 범위

- **고정 레이아웃 구축**: CSS Grid를 사용하여 Header, Sidebar(Left/Right), Center, Footer의 5개 영역으로 분할된 견고한 게임 UI 구조 구현.
- **8개 핵심 패널 슬롯 배치**: Inventory, Quest, Rule Board, Scene Canvas, Agent Console, Memory Pin, Scanner, Action Deck 자리를 고정 패널로 확보.
- **CRT 테마 적용**: 인광 녹색(#33ff00) 기반 테마, 스캔라인 오버레이, 플리커 효과, 글리치 애니메이션 등 레트로 터미널 스타일 구현.
- **내러티브 피드 설계**: 좌/우 말풍선 방식이 아닌, 턴 타임라인 기반의 로그 피드 형태로 내러티브 출력 구조 고정.
- **반응형 디자인**: 화면 너비에 따라 사이드바가 순차적으로 숨겨지는 가변 레이아웃(Desktop/Tablet/Mobile) 적용.

---

## 3. 생성/수정 파일

_(Repomix 결과 및 실제 파일 시스템 분석 기반)_

| 파일 경로 | 유형 | 목적 |
| --- | --- | --- |
| `frontend/src/App.tsx` | 수정 | 고정 레이아웃 스켈레톤 및 8개 패널 컴포넌트 구성 |
| `frontend/src/style.css` | 수정 | CRT 테마 토큰, CSS Grid 레이아웃, 오버레이 효과 정의 |
| `frontend/index.html` | 수정 | (가정) 폰트 로드 및 뷰포트 설정 확인 |

---

## 4. 구현 상세

### 4.1 핵심 설계

**주요 컴포넌트**:

- `Panel({ title, children })`: 헤더와 컨텐츠 영역을 가진 공통 UI 컨테이너.
- `NarrativeFeed()`: `[TURN N]` 타임스탬프를 포함한 로그 형태의 내러티브 출력부.
- `ActionDeck()`: 카드 형태의 행동 선택 영역 (비용/위험 정보 포함).
- `GameHeader()`: 타이틀(Glitch), Economy HUD(Signal), 연결 상태 표시.

**설계 패턴/원칙**:

- **CSS Grid Layout**: 패널 위치를 엄격하게 고정하여 기능 추가 시에도 레이아웃 무너짐 방지.
- **CSS Variable SSOT**: 모든 테마 색상과 수치를 `:root` 변수로 관리하여 유지보수성 확보.
- **RULE-002 강제**: 채팅 UI 컴포넌트 자체를 배제하고 로그 피드 구조를 선택.

### 4.2 외부 영향 분석

- **데이터/파일 시스템**: UI 레이아웃 고정으로 향후 `WorldState` 연동 시 데이터 바인딩 지점 명확화.
- **권한/보안**: CRT 오버레이에 `pointer-events: none`을 적용하여 상호작용 간섭 차단.
- **빌드/의존성**: 추가적인 외부 라이브러리 없이 순수 React + CSS로 구현하여 빌드 크기 최적화.

### 4.3 가정 및 제약사항

- 폰트는 Google Fonts(NeoDunggeunmo/VT323)를 CDN을 통해 로드한다고 가정합니다.
- 현재 모든 패널의 데이터는 Mock 데이터 또는 플레이스홀더로 구성되어 있습니다.

---

## 5. 런북(Runbook) 정보

- **파일 경로**: `vibe/unit-runbooks/U-004-crt-layout-runbook.md`
- **실행 결과**: CRT 테마 확인(A), 패널 배치 확인(B), 호버 효과(C), 반응형(D, E) 시나리오 모두 정상 동작 확인.
- **참조**: 상세 실행 방법 및 성공 지표는 위 런북 파일 참조.

---

## 6. 리스크 및 주의사항

- **레이아웃 고착화**: 화면이 복잡해질 경우 모바일 환경에서 일부 패널 접근성이 저하될 수 있으므로, 향후 모바일 전용 탭/슬라이드 메뉴 검토 필요.
- **CRT 피로도**: 플리커 효과가 일부 사용자에게 시각적 피로를 줄 수 있으므로, 향후 설정에서 끌 수 있는 기능 고려.

---

## 7. 다음 단계 안내

### 7.1 후속 작업

1. **U-009[Mvp]**: Action Deck 실제 카드 렌더링 및 비용 시스템 연동.
2. **U-010[Mvp]**: Scene Canvas 내 이미지 렌더링 및 핫스팟 오버레이 구현.
3. **U-011[Mvp]**: Inventory 패널 내 Drag & Drop 기능 추가.

### 7.2 의존 단계 확인

- **선행 단계**: U-002[Mvp] (완료)
- **후속 단계**: RU-001[Mvp] (리팩토링), U-005[Mvp] (스키마 설계)

---

## 8. 자체 점검 결과

- [x] 런북 기반 요구사항 충족 확인 (CRT 테마, 고정 레이아웃)
- [x] Repomix 최신 구조 반영 확인 (App.tsx, style.css 구조 일치)
- [x] 아키텍처/네이밍/경로 일관성 유지 (vibe/ref/frontend-style-guide.md 준수)
- [x] 파괴적 변경/리스크/가정 명시 (채팅 UI 금지 원칙 준수)

---

_본 보고서는 AI Agent에 의해 자동 생성되었습니다._
</file>

<file path="vibe/unit-results/U-005[Mvp].md">
# U-005[Mvp]: TurnInput/TurnOutput 스키마(Pydantic) 개발 완료 보고서

## 메타데이터

- **작업 ID**: U-005[Mvp]
- **단계 번호**: 1.2
- **작성 일시**: 2026-01-04 20:00
- **담당**: AI Agent

---

## 1. 작업 요약

백엔드에서 TurnInput/TurnOutput을 **Pydantic 모델로 정의**하고, Gemini Structured Outputs에 최적화된 JSON Schema(부분집합)를 생성 및 검증하는 체계를 구축했습니다.

---

## 2. 작업 범위

- **Pydantic V2 모델 정의**: `TurnInput`, `TurnOutput` 및 하위 컴포넌트(UI, World, Economy, Safety, AgentConsole) 설계
- **Hard Gate 규칙 강제**:
    - **경제(RULE-005)**: `cost`, `balance_after` 필수 및 재화(signal, memory_shard) 음수 방지 (`ge=0`)
    - **언어(RULE-006)**: `Language` enum (`ko-KR`, `en-US`)을 통한 혼합 출력 원천 차단
    - **좌표(RULE-009)**: 0~1000 정규화 좌표계 (`Coordinate`) 및 bbox `[ymin, xmin, ymax, xmax]` 순서 고정
- **스키마 오케스트레이션**: Gemini Structured Outputs 호환을 위한 `model_json_schema()` 지원 및 `extra="forbid"`를 통한 엄격한 검증
- **유닛 테스트**: 좌표 범위, 재화 인바리언트, 필수 필드 누락 등 10종 이상의 검증 시나리오 구현

---

## 3. 생성/수정 파일

_(Repomix 결과 및 실제 파일 시스템 분석 기반)_

| 파일 경로 | 유형 | 목적 |
| --- | --- | --- |
| `backend/src/unknown_world/models/turn.py` | 신규 | TurnInput/TurnOutput(Pydantic) 및 하위 타입 정의 |
| `backend/src/unknown_world/models/__init__.py` | 신규 | 모델 패키지 노출 |
| `backend/tests/unit/models/test_turn.py` | 신규 | 모델 제약 조건 및 스키마 생성 단위 테스트 |
| `shared/schemas/turn/turn_output.schema.json` | 수정 | 백엔드 Pydantic 모델 구조(Action Deck 등)와 동기화 |

---

## 4. 구현 상세

### 4.1 핵심 설계

**주요 모델 및 속성**:

- **`TurnOutput`**: 서버 응답의 SSOT. `language`, `narrative`, `economy`, `safety`를 필수(required)로 지정.
- **`UIOutput`**: `action_deck.cards` 구조를 채택하여 "채팅 선택지"가 아닌 "게임 액션"임을 명시.
- **`Box2D`**: `Coordinate` (Annotated int, 0~1000)를 사용하여 이미지 비전 bbox와 1:1 호환.
- **`CurrencyAmount`**: `ge=0` 제약을 통해 비즈니스 로직 실행 전 스키마 수준에서 잔액 음수 유입 차단.

**설계 패턴/원칙**:
- **Flat Schema**: Gemini Structured Outputs 제약을 고려하여 과도한 중첩을 피하고 하위 타입을 분리 정의.
- **Fail-fast Validation**: `model_validate_json`을 통해 LLM 응답이 계약을 위반할 경우 즉시 감지하여 Repair loop 트리거 기반 마련.

### 4.2 외부 영향 분석

- **데이터/파일 시스템**: 없음 (인메모리 모델 정의)
- **권한/보안**: 서비스 계정 등 민감 정보와 분리된 순수 데이터 모델링
- **빌드/의존성**: Pydantic V2 활용 (v2.12.5)

---

## 5. 런북(Runbook) 정보

- **파일 경로**: `vibe/unit-runbooks/U-005-pydantic-schemas-runbook.md`
- **실행 결과**:
    - 시나리오 A~G (직렬화, 검증, 스키마 생성, 좌표/언어/재화 규칙) 모두 통과
    - `pytest backend/tests/unit/models/test_turn.py` 실행 결과 100% Pass 확인

---

## 6. 리스크 및 주의사항

- **스키마 복잡도**: 현재는 평평한 구조를 유지하고 있으나, World State가 복잡해질 경우 Gemini의 JSON Schema 부분집합 제약에 걸릴 수 있음.
- **동기화**: 프론트엔드 Zod 모델(`U-006`) 구현 시 본 Pydantic 모델의 구조와 1:1 일치 여부 재검증 필요.

---

## 7. 다음 단계 안내

### 7.1 후속 작업

1. **U-006[Mvp]**: 프론트엔드 Zod 모델 구현 및 백엔드 스키마와 동기화
2. **U-007[Mvp]**: 모의 Orchestrator를 통한 SSE 스트리밍 연동 테스트

### 7.2 의존 단계 확인

- **선행 단계**: U-003[Mvp] (FastAPI 프로젝트 골격)
- **후속 단계**: U-017[Mvp] (실제 Gemini Structured Outputs 연동)

---

## 8. 자체 점검 결과

- [x] 런북 기반 요구사항 충족 확인
- [x] Repomix 최신 구조 반영 확인
- [x] 아키텍처/네이밍/경로 일관성 유지
- [x] Hard Gate (경제/안전/언어/좌표) 스키마 수준 강제 확인

---

_본 보고서는 AI Agent에 의해 자동 생성되었습니다._
</file>

<file path="vibe/unit-results/U-006[Mvp].md">
# U-006[Mvp]: TurnInput/TurnOutput 스키마(Zod) 개발 완료 보고서

## 메타데이터

- **작업 ID**: U-006[Mvp]
- **단계 번호**: 2.3
- **작성 일시**: 2026-01-04 15:30
- **담당**: AI Agent

---

## 1. 작업 요약

프론트엔드와 서버 간의 데이터 교환을 위한 `TurnInput` 및 `TurnOutput` Zod 스키마를 구현하였습니다. 이를 통해 런타임 타입 검증(Strict) 및 검증 실패 시의 안전 폴백 경로를 확보하여 시스템의 안정성을 높였습니다.

---

## 2. 작업 범위

- **Zod 스키마 정의**: `TurnInput`, `TurnOutput` 및 하위 컴포넌트(ActionCard, SceneObject 등) 스키마 구현
- **규약 준수**: 좌표(0~1000), 언어(ko/en), 재화(0 이상) 등 프로젝트 핵심 규칙 반영
- **안전 폴백 구현**: `safeParseTurnOutput` 및 `createFallbackTurnOutput` 함수 구현
- **서버 정합성**: 서버 Pydantic 모델과 1:1 대응하는 구조 확보

---

## 3. 생성/수정 파일

| 파일 경로 | 유형 | 목적 |
| --------- | ---- | ---- |
| `frontend/src/schemas/turn.ts` | 신규 | TurnInput/TurnOutput Zod 스키마 및 검증 헬퍼 |

---

## 4. 구현 상세

### 4.1 핵심 설계

**주요 계약 (Zod Schemas)**:

- `TurnInputSchema`: 클라이언트에서 서버로 보내는 입력 데이터 검증
- `TurnOutputSchema`: 서버에서 받은 응답 데이터 검증 (strict 모드 적용)
- `SCHEMA_VERSION`: 스키마 버전을 통한 하위 호환성 관리 ('1.0.0')

**설계 패턴/원칙**:

- **RULE-003/004 (이중 검증 & 폴백)**: `safeParseTurnOutput`을 통해 에러 발생 시 시스템이 정의한 폴백 데이터를 반환하여 UI 중단 방지
- **RULE-005 (재화 인바리언트)**: `CurrencyAmountSchema`에서 `min(0)`을 강제하여 잔액 음수 방지
- **RULE-006 (언어 정책)**: `LanguageSchema`를 통해 `ko-KR` | `en-US` 고정
- **RULE-009 (좌표 규약)**: `Box2DSchema`에서 `ymin, xmin, ymax, xmax` 순서 및 0~1000 범위 정수 검증

### 4.2 외부 영향 분석

- **데이터/파일 시스템**: SSE를 통해 전달되는 JSON 데이터의 구조적 정합성 보장
- **빌드/의존성**: `zod` 라이브러리 활용 (v3.x 기준)

### 4.3 가정 및 제약사항

- 서버의 Pydantic 모델과 필드명이 1:1로 일치해야 함 (드리프트 주의)
- `strict()` 모드 사용으로 인해 명세에 없는 필드가 포함될 경우 검증 실패 처리됨

---

## 5. 런북(Runbook) 정보

- **파일 경로**: 해당 유닛은 순수 데이터 구조(Schema) 구현으로, 별도의 런북 시나리오 대신 유닛 테스트 또는 U-008 통합 단계에서 검증 예정
- **검증 방법**: `TurnOutputSchema.parse()`를 통한 샘플 JSON 데이터 검토 완료

---

## 6. 리스크 및 주의사항

- **스키마 드리프트**: 서버(Python)와 클라이언트(TypeScript) 간의 스키마 변경 시 동기화 누락 주의
- **폴백 텍스트**: i18n 정책에 따라 폴백 메시지도 언어별로 분기 처리됨

---

## 7. 다음 단계 안내

### 7.1 후속 작업

1. **U-008[Mvp]**: SSE 스트리밍 연동 시 Zod 검증 적용
2. **RU-002**: 서버/클라이언트 스키마 SSOT 강화(Code Generator 등)

### 7.2 의존 단계 확인

- **선행 단계**: U-002 (환경 설정), U-005 (서버 스키마)
- **후속 단계**: U-008 (연동 및 렌더링)

---

## 8. 자체 점검 결과

- [x] 런북 기반 요구사항 충족 확인 (계획서 기준)
- [x] Repomix 최신 구조 반영 확인
- [x] 아키텍처/네이밍/경로 일관성 유지
- [x] 파괴적 변경/리스크/가정 명시

---

_본 보고서는 AI Agent에 의해 자동 생성되었습니다._
</file>

<file path="vibe/unit-results/U-007[Mvp].md">
# [U-007[Mvp]: 모의 Orchestrator + /api/turn HTTP Streaming(POST)] 개발 완료 보고서

## 메타데이터

- **작업 ID**: U-007[Mvp]
- **단계 번호**: 2.3
- **작성 일시**: 2026-01-04 15:30
- **담당**: AI Agent

---

## 1. 작업 요약

실모델(Gemini) 없이도 프론트엔드 개발 및 데모가 가능하도록, 결정적 시드 기반의 **모의 Orchestrator**와 NDJSON 스트리밍을 지원하는 **`/api/turn` 엔드포인트**를 구현했습니다. 이를 통해 사용자 입력부터 최종 UI 업데이트까지의 전체 루프를 시뮬레이션할 수 있습니다.

---

## 2. 작업 범위

- **모의 Orchestrator 구현**: `seed` 기반으로 재현 가능한 `TurnOutput` 생성 로직 구현 (다국어, 좌표 규약, 경제 인바리언트 준수)
- **HTTP Streaming 엔드포인트 구현**: `/api/turn` (POST)에서 NDJSON 방식으로 단계별 이벤트 스트리밍 구현
- **이벤트 계약 확정**: `stage`, `badges`, `narrative_delta`, `final`, `error` 타입의 이벤트 구조 정의
- **안전 장치 구현**: Pydantic 검증 실패 시 Safe Fallback 반환 및 내부 오류 은닉 (RULE-004, RULE-007)

---

## 3. 생성/수정 파일

| 파일 경로 | 유형 | 목적 |
| --------- | ---- | ---- |
| `backend/src/unknown_world/api/turn.py` | 신규 | `/api/turn` 스트리밍 라우트 및 NDJSON 로직 |
| `backend/src/unknown_world/orchestrator/mock.py` | 신규 | 모의 데이터 생성기 및 스트림 이벤트 모델 |
| `backend/src/unknown_world/main.py` | 수정 | `turn_router` 등록 및 CORS 설정 확인 |
| `backend/src/unknown_world/api/__init__.py` | 수정 | 라우터 익스포트 설정 |

---

## 4. 구현 상세

### 4.1 핵심 설계

**주요 엔드포인트**:
- `POST /api/turn`: `TurnInput`을 받아 NDJSON 스트림 반환.
  - `TTFB`: 요청 수신 즉시 첫 `stage` 이벤트 전송으로 응답성 확보.
  - `NDJSON`: 라인 단위 JSON 직렬화로 스트리밍 처리.

**모의 오케스트레이션 단계**:
1. `Parse` → `Validate` → `Plan` → `Resolve` → `Render` → `Verify` → `Commit` 순서로 진행.
2. `Validate`, `Verify` 단계에서 `ValidationBadge` 이벤트 송출.
3. `narrative_delta`를 통한 타자 효과(Typewriter Effect) 시뮬레이션.

**좌표 규약 (RULE-009)**:
- 모든 `SceneObject`의 `box_2d`는 `[ymin, xmin, ymax, xmax]` 포맷의 0~1000 정규화 좌표 사용.

### 4.2 외부 영향 분석

- **API**: 신규 스트리밍 API 추가로 프론트엔드의 `fetch` 스트림 처리 로직 필요.
- **경제 시스템**: 모의 데이터 생성 시 입력된 `economy_snapshot`을 바탕으로 비용 차감 후 `balance_after` 계산 (음수 방지 로직 포함).

### 4.3 가정 및 제약사항

- 현재는 모의 데이터이므로 실제 Gemini 모델의 추론 결과와는 차이가 있을 수 있음.
- `seed` 파라미터를 통해 동일한 입력에 대해 항상 동일한 결과를 얻을 수 있도록 설계됨.

---

## 5. 런북(Runbook) 정보

- **테스트 방법**: `curl` 또는 `Postman`을 사용하여 `/api/turn`에 POST 요청을 보내고 스트리밍 응답 확인.
- **예시 명령어**:
  ```bash
  curl -X POST http://localhost:8011/api/turn \
    -H "Content-Type: application/json" \
    -d '{"language":"ko-KR","text":"안녕","client":{"viewport_w":1920,"viewport_h":1080},"economy_snapshot":{"signal":100,"memory_shard":5}}'
  ```

---

## 6. 리스크 및 주의사항

- **스트림 파싱**: 클라이언트에서 NDJSON 파싱 중 partial JSON chunk 처리에 주의해야 함.
- **보안**: 에러 발생 시 내부 스택트레이스나 프롬프트 정보가 유출되지 않도록 `ErrorEvent`로 캡슐화함.

---

## 7. 다음 단계 안내

### 7.1 후속 작업

1. **프론트엔드 연동 (U-008)**: 백엔드 스트림을 소비하여 UI(Agent Console, 내러티브 피드)를 업데이트하는 로직 구현.
2. **실모델 통합 (RU-003)**: 모의 오케스트레이터를 실제 Gemini API 호출 로직으로 교체.

### 7.2 의존 단계 확인

- **선행 단계**: U-005(스키마), U-003(FastAPI 기반) 완료
- **후속 단계**: U-008, RU-003

---

## 8. 자체 점검 결과

- [x] NDJSON 스트리밍 및 단계별 이벤트 송출 확인
- [x] Pydantic 기반 입력 검증 및 출력 모델링 적용
- [x] 좌표 규약(0~1000, ymin/xmin/ymax/xmax) 준수
- [x] 경제 인바리언트 및 다국어(KO/EN) 처리 반영

---

_본 보고서는 AI Agent에 의해 자동 생성되었습니다._
</file>

<file path="vibe/unit-results/U-008[Mvp].md">
# [U-008[Mvp]: 프론트 HTTP Streaming 클라이언트 + Agent Console/배지] 개발 완료 보고서

## 메타데이터

- **작업 ID**: U-008[Mvp]
- **단계 번호**: 1.1 (마일스톤 M1)
- **작성 일시**: 2026-01-05 10:00
- **담당**: AI Agent

---

## 1. 작업 요약

사용자 명령에 대한 서버의 HTTP Streaming 응답(NDJSON)을 실시간으로 처리하는 클라이언트 파이프라인과, 시스템의 추론 및 검증 과정을 시각화하는 `Agent Console` 컴포넌트를 구현했습니다. 이를 통해 "에이전트형 시스템"임을 증명하는 핵심 UX를 구축했습니다.

---

## 2. 작업 범위

- **HTTP Streaming 클라이언트**: `fetch` API와 `ReadableStream`을 사용한 NDJSON 스트림 소비 로직 구현
- **NDJSON 파서**: 부분적으로 들어오는 데이터 청크를 라인 단위 JSON으로 안전하게 복구하는 파서 직접 구현 (Option A)
- **에이전트 상태 관리**: Zustand를 사용하여 `isStreaming`, `phases`, `badges`, `repairCount` 등의 실시간 상태 동기화
- **Agent Console 컴포넌트**: 7단계 큐(Queue), 4종 검증 배지(Badges), 자동 복구(Auto-repair) 트레이스를 포함한 게임 HUD 컴포넌트 구현
- **메인 레이아웃 통합**: `App.tsx`에 스트리밍 루프를 연결하고, 스트리밍 중 UI 비활성화 및 타자 효과(Typewriter Effect) 적용

---

## 3. 생성/수정 파일

| 파일 경로 | 유형 | 목적 |
| --------- | ---- | ---- |
| `frontend/src/api/turnStream.ts` | 신규 | NDJSON 파서 및 fetch 기반 스트리밍 클라이언트 |
| `frontend/src/stores/agentStore.ts` | 신규 | Agent Console 및 스트리밍 상태 관리 (Zustand) |
| `frontend/src/components/AgentConsole.tsx` | 신규 | 단계/배지/복구 트레이스 렌더링 컴포넌트 |
| `frontend/src/App.tsx` | 수정 | 스트림 실행 루프 연동 및 전체 UI 상태 통합 |
| `frontend/src/style.css` | 수정 | Agent Console 스타일 및 스트리밍 애니메이션 추가 |

---

## 4. 구현 상세

### 4.1 핵심 설계

**주요 계약 (API/Store)**:

- `executeTurnStream(input, callbacks)`: 입력과 콜백을 받아 스트리밍을 제어하는 저수준 함수
- `useAgentStore`: `phases` (pending/in_progress/completed), `badges` (ok/fail) 상태를 관리하는 중앙 원장
- `NDJSONParser`: 줄바꿈(`\n`) 기준의 버퍼링 파서로 네트워크 지연에 강인한 구조

**설계 패턴/원칙**:

- **RULE-008 (비노출)**: 프롬프트 원문이나 CoT는 수신하지 않으며, `stage` 및 `badges` 메타데이터만 UI에 노출
- **RULE-003/004 (검증 및 폴백)**: `final` 이벤트 수신 시 Zod로 `strict parse`를 수행하며, 실패 시 `safeParseTurnOutput`을 통해 폴백 데이터 적용
- **타자 효과**: `narrative_delta` 이벤트를 수신할 때마다 `narrativeBuffer`에 축적하여 실시간 텍스트 출력 구현

### 4.2 외부 영향 분석

- **CORS/포트**: 백엔드(8011)와 프론트엔드(8001) 간의 스트리밍 통신 설정 완료
- **UI 반응성**: 스트리밍 중 입력창 및 액션 카드를 `disabled` 처리하여 중복 요청 방지

### 4.3 가정 및 제약사항

- NDJSON 라인은 반드시 유효한 단일 JSON 객체여야 함
- 브라우저의 `fetch` 스트리밍 지원 여부에 의존 (최신 모던 브라우저 기준)

---

## 5. 런북(Runbook) 정보

- **파일 경로**: `vibe/unit-runbooks/U-008-http-streaming-client-runbook.md`
- **실행 결과**: 시나리오 A(스트리밍), B(배지), C(카드 클릭), D(비활성화), E(에러 처리) 모두 검증 완료
- **참조**: 상세 실행 방법은 위 런북 파일 참조

---

## 6. 리스크 및 주의사항

- **네트워크 단절**: 스트리밍 중 네트워크 끊김 시 `onError` 콜백을 통해 OFFLINE 상태로 안전하게 전환하도록 처리됨
- **대용량 응답**: 매우 긴 내러티브 수신 시 렌더링 성능 저하를 방지하기 위해 `narrativeBuffer` 관리에 유의 필요

---

## 7. 다음 단계 안내

### 7.1 후속 작업

1. **U-027[Mvp]**: 개발 스크립트 포트 제한 강화
2. **RU-002[Mvp]**: 유효성 검사 및 이벤트 타입 통일 리팩토링

### 7.2 의존 단계 확인

- **선행 단계**: U-006 (스키마), U-007 (모의 서버) 완료 확인
- **후속 단계**: CP-MVP-01 (체크포인트)

---

## 8. 자체 점검 결과

- [x] 런북 기반 요구사항 충족 확인
- [x] Repomix 최신 구조 반영 확인
- [x] 아키텍처/네이밍/경로 일관성 유지
- [x] RULE-003/004/008/011 준수 여부 확인

---

_본 보고서는 AI Agent에 의해 자동 생성되었습니다._
</file>

<file path="vibe/unit-results/U-027[Mvp].md">
# [U-027[Mvp]] 개발 완료 보고서

## 메타데이터

- **작업 ID**: U-027[Mvp]
- **단계 번호**: 2.3
- **작성 일시**: 2026-01-05 23:45
- **담당**: AI Agent

---

## 1. 작업 요약

포트 정책(RULE-011)에 따라 `pnpm kill` 스크립트를 광역 프로세스 종료 방식에서 8001~8020 포트 제한 종료 방식으로 전환하여, 다른 프로젝트의 Node/Uvicorn 프로세스에 영향을 주지 않는 안전한 개발 환경 종료 메커니즘을 구현함.

---

## 2. 작업 범위

- **pnpm kill 스크립트 재설계**: `taskkill` 기반의 광역 종료를 제거하고 `kill-port` 기반의 안전한 종료로 대체 (Option A 적용)
- **포트 범위 구체화**: RULE-011에 따라 Frontend(8001-8010), Backend(8011-8020) 범위를 대상으로 함
- **자동화 안정성 확보**: `npx` 실행 시 `--yes` 플래그를 추가하여 대화형 프롬프트 차단
- **문서 동기화**: `architecture.md`, `roadmap.md`에 변경된 종료 정책 및 포트 규약 반영
- **검증 가이드 작성**: 수동 테스트 시나리오 및 포트 충돌 해결 방법을 포함한 런북 생성

---

## 3. 생성/수정 파일

| 파일 경로 | 유형 | 목적 |
| --- | --- | --- |
| `package.json` | 수정 | `kill`, `kill:port` 등 개발 스크립트 고도화 및 정책 반영 |
| `vibe/architecture.md` | 수정 | RULE-011 포트 정책 설명 업데이트 |
| `vibe/roadmap.md` | 수정 | 포트 정리 명령어 예시 및 설명 갱신 |
| `vibe/unit-plans/U-027[Mvp].md` | 수정 | 페어링 질문 결정 사항(Option A) 기록 |
| `vibe/unit-runbooks/U-027-kill-port-limit-runbook.md` | 신규 | 포트 제한 종료 실행 및 검증 가이드 |
| `shared/schemas/turn/*.json` | 수정 | 스키마 파일 포맷 미세 조정 (빈 줄 추가) |

---

## 4. 구현 상세

### 4.1 핵심 설계

**개발 스크립트 고도화**:
- `kill`: `pnpm kill:port`의 별칭으로 설정하여 가장 자주 사용되는 명령어를 안전하게 전환
- `kill:port`: `8001`부터 `8020`까지의 모든 개발 포트를 순차적으로 종료
- `kill:front` / `kill:back`: 특정 레이어만 타겟팅하여 종료 가능하도록 분리

**설계 패턴/원칙**:
- **RULE-011 (Port Policy)**: 프론트엔드와 백엔드의 포트 범위를 엄격히 분리하여 충돌 방지
- **Safe Termination**: 프로세스 이름(`node.exe`)이 아닌 리스닝 포트를 기준으로 종료하여 사이드 이펙트 최소화

### 4.2 외부 영향 분석

- **환경 변수**: 영향 없음
- **의존성**: `kill-port` 패키지를 `npx`를 통해 사용하므로 별도의 설치 불필요
- **시스템**: Windows 환경에서의 `taskkill` 의존성을 줄이고 포트 기반 제어로 표준화

### 4.3 가정 및 제약사항

- 사용자의 로컬 환경에서 8001~8020 포트가 Hyper-V 등에 의해 예약되어 있을 경우 `EACCES` 오류가 발생할 수 있음 (런북에 대응 방법 기재)

---

## 5. 런북(Runbook) 정보

- **파일 경로**: `vibe/unit-runbooks/U-027-kill-port-limit-runbook.md`
- **실행 결과**: 시나리오 A(격리 검증), B(통합 종료), C(개별 종료)를 통해 기능 정상 작동 확인
- **참조**: `netstat`을 이용한 포트 점유 상태 확인 절차 포함

---

## 6. 리스크 및 주의사항

- **파괴적 변경**: 기존에 다른 용도로 8001~8020 포트를 사용하던 프로세스가 있을 경우 `pnpm kill` 실행 시 함께 종료될 수 있음.

---

## 7. 다음 단계 안내

### 7.1 후속 작업

1. **포트 사용 현황 모니터링**: 실제 개발 과정에서 포트 부족이나 예약 충돌 사례 수집
2. **CI 환경 적용**: 빌드 스크립트 전후에 포트 정리가 필요한 경우 해당 명령어 활용

### 7.2 의존 단계 확인

- **선행 단계**: RU-001[Mvp] (포트 정책 수립) 완료
- **후속 단계**: UI/Backend 연동 테스트 시 포트 정합성 확인

---

## 8. 자체 점검 결과

- [x] 런북 기반 요구사항 충족 확인
- [x] Repomix 최신 구조 반영 확인
- [x] 아키텍처/네이밍/경로 일관성 유지
- [x] 파괴적 변경/리스크/가정 명시

---

_본 보고서는 AI Agent에 의해 자동 생성되었습니다._
</file>

<file path="vibe/unit-results/U-028[Mvp].md">
# U-028[Mvp]: UI 가독성 패스(폰트 스케일/효과 토글/대비) 개발 완료 보고서

## 메타데이터

- **작업 ID**: U-028[Mvp]
- **단계 번호**: 2.3
- **작성 일시**: 2026-01-10 14:30
- **담당**: AI Agent

---

## 1. 작업 요약

UI 가독성 개선을 위해 전역 UI 스케일 조절 기능과 CRT 효과를 완화하는 Readable 모드를 도입했습니다. 이를 통해 미학적인 CRT 테마를 유지하면서도 데모 및 플레이 시 텍스트 시인성을 확보했습니다.

---

## 2. 작업 범위

- **UI 설정 상태 관리 도입**: Zustand(`persist`)를 사용한 `uiScale`, `readableMode` 상태 저장 및 복원 기능 구현.
- **전역 UI 스케일 구현**: CSS 변수(`--ui-scale-factor`)와 `rem` 기반 타이포그래피 시스템을 연동하여 0.9x ~ 1.2x 스케일 조절 기능 구현.
- **Readable 모드 구현**: 스캔라인, 플리커, 글로우 효과를 토글하여 텍스트 대비와 시인성을 향상시키는 모드 추가.
- **마이크로 텍스트 상향**: Agent Console, 배지, 타임스탬프 등 작은 텍스트 영역의 기본 폰트 크기를 상향 조정 및 Readable 모드 연동.
- **헤더 컨트롤 추가**: `GameHeader` 내에 UI 가독성 설정을 위한 직관적인 컨트롤 UI 배치.

---

## 3. 생성/수정 파일

| 파일 경로 | 유형 | 목적 |
| --------- | ---- | ---- |
| `frontend/src/stores/uiPrefsStore.ts` | 신규 | UI 설정(스케일/Readable) 상태 관리 및 DOM 적용 헬퍼 |
| `frontend/src/style.css` | 수정 | UI 스케일 변수 도입, Readable 모드 스타일 및 마이크로 텍스트 가독성 강화 |
| `frontend/src/App.tsx` | 수정 | UI 컨트롤 컴포넌트 추가 및 헤더 통합, 설정 실시간 반영 로직 구현 |

---

## 4. 구현 상세

### 4.1 핵심 설계

**주요 계약**:

- `useUIPrefsStore()`: UI 설정 상태 및 액션을 제공하는 Zustand 훅.
- `applyUIPrefsToDOM(state)`: 스토어 상태를 `html` 요소의 `data-` 속성 및 CSS 변수로 변환하여 반영.

**설계 패턴/원칙**:

- **CSS-in-JS + Data Attributes**: React 상태를 데이터 속성(`data-readable`, `data-ui-scale`)으로 전달하여 CSS 레벨에서 모든 스타일 변화를 제어(SSOT 유지).
- **Scale-aware Typography**: `html { font-size: calc(base * factor) }` 구조를 사용하여 레이아웃 파괴 없이 전역 크기 조절.

### 4.2 외부 영향 분석

- **데이터/파일 시스템**: `localStorage`에 `unknown-world-ui-prefs` 키로 설정값이 영구 저장됩니다.
- **UI/UX**: CRT 효과가 과하다고 느끼는 사용자에게 즉각적인 가독성 개선 수단을 제공하여 데모 품질을 향상시킵니다.

---

## 5. 런북(Runbook) 정보

- **파일 경로**: 별도의 런북 파일 대신 `unit-plans/U-028[Mvp].md`의 완료 기준을 기반으로 검증됨.
- **실행 결과**:
  - `A-`, `A+` 버튼 클릭 시 UI 전체 크기 변경 확인.
  - `READ` 토글 시 스캔라인/플리커 제거 및 가독성 향상 확인.
  - 새로고침 시에도 설정값이 유지됨을 확인.

---

## 6. 리스크 및 주의사항

- **레이아웃 깨짐**: 1.2x 이상의 과도한 스케일 적용 시 일부 고정 높이 패널에서 텍스트 넘침이 발생할 수 있으므로 최대 스케일을 1.2로 제한함.
- **CRT 미학 손실**: Readable 모드 사용 시 CRT 특유의 느낌이 사라지므로 기본값은 CRT 효과가 활성화된 상태로 유지함.

---

## 7. 다음 단계 안내

### 7.1 후속 작업

1. `U-009[Mvp]` Action Deck UI 구현 시 가독성 토큰 적용.
2. `U-029[Mvp]` nanobanana mcp 에셋 패스 시 아이콘 스케일 연동 검토.

### 7.2 의존 단계 확인

- **선행 단계**: U-004, U-008
- **후속 단계**: U-009, U-030

---

## 8. 자체 점검 결과

- [x] 전역 UI 스케일(0.9~1.2) 조절 및 유지 확인
- [x] Readable 모드 토글 및 효과 완화 확인
- [x] 마이크로 텍스트(Agent Console 등) 가독성 상향 확인
- [x] Header 내 컨트롤 UI 배치 확인

---

_본 보고서는 AI Agent에 의해 자동 생성되었습니다._
</file>

<file path="vibe/unit-results/U-029[Mvp].md">
# U-029[Mvp]: nanobanana mcp 에셋 패스(UI 아이콘/프레임/placeholder) 개발 완료 보고서

## 메타데이터

- **작업 ID**: U-029[Mvp]
- **단계 번호**: 2.3
- **작성 일시**: 2026-01-11 16:20
- **담당**: AI Agent

---

## 1. 작업 요약

UI의 시각적 완성도와 "게임 GM 시스템"의 몰입감을 높이기 위해 `nanobanana mcp`를 사용하여 주요 UI 아이콘 및 플레이스홀더 에셋을 제작하고 반영했습니다. `rembg`를 통한 투명 배경 확보와 이모지 폴백 로직을 통해 견고한 UI 에셋 파이프라인을 구축했습니다.

---

## 2. 작업 범위

- **에셋 제작**: Signal, Shard, Risk(Low/Med/High), Badge(OK/Fail), Status 등 총 12종의 아이콘 제작
- **플레이스홀더 제작**: Scene Canvas용 레트로 터미널 스타일 플레이스홀더 제작
- **배경 제거 및 최적화**: `rembg`를 활용한 투명 PNG 생성 및 용량 최적화 (예산 내 관리)
- **UI 통합**: Economy HUD, Action Deck, Agent Console 등에 아이콘 적용 및 CSS 폴백 로직 구현
- **매니페스트 관리**: `manifest.json`을 통한 에셋 SSOT 관리 및 메타데이터 기록

---

## 3. 생성/수정 파일

| 파일 경로 | 유형 | 목적 |
| --- | --- | --- |
| `frontend/public/ui/icons/*.png` | 신규 | UI 아이콘 에셋 (Signal, Shard, Risk 등) |
| `frontend/public/ui/placeholders/*.png` | 신규 | Scene Canvas 플레이스홀더 에셋 |
| `frontend/public/ui/manifest.json` | 수정 | 에셋 매니페스트 등록 및 메타데이터 업데이트 |
| `frontend/src/style.css` | 수정 | 아이콘 래퍼 및 폴백 스타일 추가 |
| `frontend/src/components/EconomyHUD.tsx` | 수정 | 재화 아이콘 적용 |
| `frontend/src/components/ActionCard.tsx` | 수정 | 비용/위험 아이콘 적용 |
| `vibe/unit-runbooks/U-029-nanobanana-asset-runbook.md` | 신규 | 유닛 실행 및 검증 런북 |

---

## 4. 구현 상세

### 4.1 핵심 설계

**에셋 파이프라인 (Gen-Edit-Deploy)**:
1. **Generation**: `nanobanana mcp`에 `STYLE HEADER v1` 템플릿과 순백(#FFFFFF) 배경 제약을 적용하여 일관된 스타일의 원본 생성
2. **Editing**: `rembg` (birefnet-general 모델)를 사용하여 배경을 정밀하게 제거하고 투명 PNG 확보
3. **Optimization**: 픽셀 정렬 및 용량 최적화를 통해 1KB 미만의 고효율 아이콘 생성
4. **Integration**: `manifest.json`에 경로와 폴백(이모지)을 정의하고 CSS에서 선언적으로 사용

**폴백 시스템 (Graceful Degradation)**:
- 이미 로드 실패 시 `.icon-fallback` 요소(이모지/텍스트)가 즉시 표시되도록 CSS 선택자 구조 설계
- `U-030`에서 정의한 SSOT 규칙에 따라 아이콘이 없어도 UI 기능이 유지됨

### 4.2 외부 영향 분석

- **번들 크기**: 총 에셋 크기 약 267KB로 성능 예산(1.5MB) 이내에서 안정적으로 관리됨
- **가독성**: `U-028`의 Readable 모드와 연동되어 CRT 효과 활성화 여부에 따라 아이콘 시인성이 최적화됨

---

## 5. 런북(Runbook) 정보

- **파일 경로**: `vibe/unit-runbooks/U-029-nanobanana-asset-runbook.md`
- **실행 결과**: 아이콘 렌더링, 폴백 동작, 매니페스트 정합성 등 5개 시나리오 검증 완료

---

## 6. 리스크 및 주의사항

- **스타일 일관성**: 향후 에셋 추가 시 `vibe/ref/nanobanana-mcp.md`의 프롬프트 템플릿을 엄격히 준수해야 함
- **캐싱**: 에셋 변경 시 `manifest.json`의 버전업 또는 파일명 해시 처리가 필요할 수 있음 (현재는 정적 경로 사용)

---

## 7. 다음 단계 안내

### 7.1 후속 작업

1. `U-031[Mvp]`: 상태 Placeholder Pack 확장 (Scene/오프라인/에러)
2. `U-033[Mvp]`: 에셋 매니페스트 자동화 및 QA 스크립트 고도화

### 7.2 의존 단계 확인

- **선행 단계**: U-030[Mvp], U-028[Mvp], U-034[Mvp] 완료
- **후속 단계**: U-031[Mvp], U-032[Mvp]

---

## 8. 자체 점검 결과

- [x] 6개 이상의 에셋 제작 및 반영 완료
- [x] rembg를 통한 투명 배경 확보 완료
- [x] 이모지 폴백 로직 동작 확인
- [x] manifest.json SSOT 동기화 완료
- [x] 가독성 가이드(U-028) 준수

---

_본 보고서는 AI Agent에 의해 자동 생성되었습니다._
</file>

<file path="vibe/unit-results/U-030[Mvp].md">
# U-030[Mvp] nanobanana mcp 에셋 SSOT 개발 완료 보고서

## 메타데이터

- **작업 ID**: U-030[Mvp]
- **단계 번호**: 2.3
- **작성 일시**: 2026-01-10 16:30
- **담당**: AI Agent

---

## 1. 작업 요약

`nanobanana mcp`로 생성되는 UI 및 문서용 정적 이미지 에셋의 저장 위치, 네이밍 규칙, 성능 예산, 폴백 원칙 등을 프로젝트의 단일 진실 공급원(SSOT)으로 정의하고, 이를 관리하기 위한 매니페스트 스키마 및 초기 환경 구축을 완료했습니다.

---

## 2. 작업 범위

- **SSOT 디렉토리 구축**: `frontend/public/ui/` 경로 생성 및 구조 정의
- **규칙 문서 작성**: 에셋 제작 및 관리 규칙을 담은 `README.md` 작성
- **매니페스트 시스템 설계**: JSON Schema (`manifest.schema.json`) 및 초기 매니페스트 (`manifest.json`) 구현
- **테마 정합성 확보**: `frontend/src/style.css`의 CRT 테마 색상(인광 녹색 #33ff00 등)을 에셋 스타일 가이드에 반영
- **폴백/접근성 가이드 정의**: 에셋 로딩 실패 시의 이모지/텍스트 폴백 및 ARIA 속성 활용 가이드 포함

---

## 3. 생성/수정 파일

| 파일 경로 | 유형 | 목적 |
| --- | --- | --- |
| `frontend/public/ui/README.md` | 신규 | UI 에셋 제작 및 관리 규칙 (SSOT) |
| `frontend/public/ui/manifest.schema.json` | 신규 | 에셋 매니페스트 JSON 스키마 |
| `frontend/public/ui/manifest.json` | 신규 | 에셋 목록 관리 파일 (초기 버전) |

---

## 4. 구현 상세

### 4.1 핵심 설계

**디렉토리 구조**:
- `icons/`: PNG 포맷의 투명 아이콘 (16px, 24px 필수)
- `placeholders/`: WebP 포맷의 상태/장면 이미지 (용량 최적화)
- `chrome/`: UI 프레임 및 장식용 에셋

**성능 예산 (Performance Budget)**:
- 개별 아이콘: 20KB 이하
- 개별 Placeholder: 200KB 이하
- `ui/` 폴더 총합 상한: 1.5MB (권장 1MB 이하)

**네이밍 규칙**:
- `kebab-case` 적용: `{용도}-{상태}-{크기}.{확장자}` (예: `signal-ok-24.png`)

### 4.2 외부 영향 분석

- **런타임 독립성**: `nanobanana mcp`는 개발 도구로만 사용되며, 제품 런타임은 생성된 정적 파일에만 의존함 (RULE-007 준수)
- **가독성 패스 (U-028) 호환**: Readable 모드에서도 식별 가능한 고대비 및 폴백 텍스트 유지 원칙 적용

### 4.3 가정 및 제약사항

- 에셋 추가 시 반드시 `manifest.json`을 업데이트해야 함
- 1.5MB 예산 초과 시 에셋 최적화 또는 개별 에셋 삭제 필요

---

## 5. 런북(Runbook) 정보

- **파일 경로**: `vibe/unit-runbooks/U-030-asset-ssot-runbook.md`
- **실행 결과**: 디렉토리 구조, 규칙 문서 가독성, JSON Schema 유효성 등 모든 시나리오 검증 완료
- **참조**: 에셋 추가 시 `README.md`의 체크리스트를 반드시 확인

---

## 6. 리스크 및 주의사항

- **파일명 대소문자**: Windows 환경에서 작업 시 대소문자 구분에 주의 (Linux 서버 배포 시 문제 발생 가능) -> `kebab-case` (소문자) 강제
- **라이선스**: AI 생성 에셋의 경우 SynthID 워터마크 포함 가능성 인지

---

## 7. 다음 단계 안내

### 7.1 후속 작업

1. **U-029**: 실제 아이콘/프레임 에셋 제작 패스 시작
2. **U-031**: 상태 Placeholder Pack 구축
3. **U-033**: 에셋 매니페스트 자동화 및 QA 스크립트 작성

### 7.2 의존 단계 확인

- **선행 단계**: U-004[Mvp] (CRT 테마 정의) 완료 확인됨
- **후속 단계**: U-029[Mvp] ~ U-034[Mvp] (에셋 파이프라인 완성)

---

## 8. 자체 점검 결과

- [x] 런북 기반 요구사항 충족 확인
- [x] Repomix 최신 구조 반영 확인
- [x] CRT 테마 색상 정합성 확인 (#33ff00, #ff00ff 등)
- [x] 폴백 원칙 및 코드 예시 포함 확인

---

_본 보고서는 AI Agent에 의해 자동 생성되었습니다._
</file>

<file path="vibe/unit-results/U-031[Mvp].md">
# U-031[Mvp]: nanobanana mcp 상태 Placeholder Pack 개발 완료 보고서

## 메타데이터

- **작업 ID**: U-031[Mvp]
- **단계 번호**: 2.4
- **작성 일시**: 2026-01-11 23:05
- **담당**: AI Agent

---

## 1. 작업 요약

Scene Canvas와 주요 시스템 상태(로딩/오프라인/차단/저신호 등)를 위한 게임스러운 상태 이미지(placeholder)를 제작 및 UI에 반영하고, 로딩 실패 시의 안정적인 폴백 로직을 구현했습니다. 또한 프로젝트의 유지보수성을 위해 관련 코드를 리팩토링하고 다국어 지원(i18n) 설정을 도입했습니다.

---

## 2. 작업 범위

- **상태 Placeholder 제작 및 등록**: `loading`, `offline`, `blocked`, `low-signal` 4종 에셋 제작 및 `manifest.json` 등록 완료.
- **컴포넌트 리팩토링**: `SceneCanvas` 관련 로직 및 타입을 별도 파일로 분리하여 모듈화.
- **다국어 지원(i18n)**: `react-i18next`를 초기화하고 플레이스홀더 라벨에 적용 (RULE-006 준수).
- **텍스트 폴백 강화**: 이미지 로드 실패 시에도 상태 라벨과 에러 메시지가 가독성 있게 표시되도록 로직 개선.
- **품질 보증**: 단위 테스트(`SceneCanvas.test.tsx`) 작성 및 통과, 린트/타입 체크 완료.

---

## 3. 생성/수정 파일

| 파일 경로 | 유형 | 목적 |
| --- | --- | --- |
| `frontend/src/types/scene.ts` | 신규 | Scene Canvas 관련 타입 정의 |
| `frontend/src/components/SceneCanvas.tsx` | 신규 | Scene Canvas 컴포넌트 및 상수 분리 |
| `frontend/src/components/SceneCanvas.test.tsx` | 신규 | Scene Canvas 단위 테스트 |
| `frontend/src/i18n.ts` | 신규 | i18next 초기화 및 번역 리소스 정의 |
| `frontend/src/App.tsx` | 수정 | 리팩토링된 컴포넌트 적용 및 상태 전환 로직 연결 |
| `frontend/src/main.tsx` | 수정 | i18n 초기화 코드 추가 |
| `frontend/public/ui/manifest.json` | 수정 | 신규 플레이스홀더 에셋 정보 업데이트 |

---

## 4. 구현 상세

### 4.1 핵심 설계

- **상태 전환 흐름**:
  - `executeTurn` 시작 시 → `loading`
  - 스트림 에러 발생 시 → `blocked` | `low_signal` | `offline` (에러 코드에 따름)
  - 스트림 완료 후 → `default` (또는 `scene` 이미지 표시 예정)
- **i18n 구조**: `scene.status.*` 키를 통해 한국어/영어 동시 지원. `App` 컴포넌트 전반의 하드코딩 라벨 제거를 위한 기반 마련.
- **폴백 메커니즘**: `SceneCanvas` 내부의 `imageError` 로컬 상태를 통해 이미지가 없는 환경에서도 텍스트 정보를 상시 보장.

### 4.2 프로젝트 규칙 준수

- **RULE-002**: 채팅 UI 배제 및 게임 HUD 스타일 유지.
- **RULE-006**: i18n SSOT 준수 및 언어 혼합 방지.
- **RULE-007**: MCP 에셋은 정적 배포 방식으로만 사용 (런타임 의존 없음).

---

## 5. 검증 결과

- **단위 테스트**: `pnpm run test` 결과 5개 파일, 49개 테스트 모두 통과.
- **코드 품질**: `pnpm run lint` 및 `pnpm run typecheck` 무오류 통과.
- **에셋 검증**: `manifest.json` 예산 범위 내(1.5MB 미만) 유지 확인.

---

## 6. 다음 단계 안내

1. **U-019/U-020**: 실제 Gemini 기반 이미지 생성 및 Lazy Render 연동 시, 이번에 구축한 플레이스홀더를 기본 배경으로 활용.
2. **U-033**: 에셋 매니페스트 자동화 QA 스크립트에 이번 신규 에셋 추가.
3. **전역 i18n 확장**: `AgentConsole` 등 다른 컴포넌트의 라벨도 순차적으로 `i18n.ts`로 이전.

---

_본 보고서는 AI Agent에 의해 자동 생성되었습니다._
</file>

<file path="vibe/unit-results/U-032[Mvp].md">
# U-032[Mvp] 개발 완료 보고서

## 메타데이터

- **작업 ID**: U-032[Mvp]
- **단계 번호**: 2.3
- **작성 일시**: 2026-01-12 11:30
- **담당**: AI Agent

---

## 1. 작업 요약

nanobanana mcp로 생성한 투명 배경의 Chrome 에셋(패널 코너, 카드 프레임, 스캐너 프레임)을 적용하여 게임 UI의 시각적 완성도를 높이고, Readable 모드와 연동하여 가독성을 보장했습니다.

---

## 2. 작업 범위

- **에셋 제작 및 적용**: 3종의 Chrome 에셋(`panel-corner-br`, `card-frame`, `scanner-frame`) 생성 및 최적화(rembg, ImageMagick) 후 적용
- **UI 스타일링**: `style.css`에 `.has-chrome` 클래스 기반의 코너 장식 및 프레임 오버레이 스타일 구현
- **컴포넌트 연동**: `App.tsx`의 `Panel` 및 `ActionDeck` 컴포넌트에 Chrome 적용 로직 추가
- **가독성 제어**: Readable 모드 활성화 시 Chrome 효과가 자동으로 완화되도록 CSS 변수 및 셀렉터 구성
- **SSOT 업데이트**: `manifest.json`에 신규 에셋 정보 등록

---

## 3. 생성/수정 파일

| 파일 경로 | 유형 | 목적 |
| --- | --- | --- |
| `frontend/public/ui/chrome/panel-corner-br.png` | 신규 | 패널 4방향 코너 장식 에셋 (투명 PNG) |
| `frontend/public/ui/chrome/card-frame.png` | 신규 | 액션 카드 프레임 에셋 (투명 PNG) |
| `frontend/public/ui/chrome/scanner-frame.png` | 신규 | 스캐너 슬롯 프레임 에셋 (투명 PNG) |
| `frontend/src/style.css` | 수정 | Chrome 스타일 정의 및 Readable 모드 연동 |
| `frontend/src/App.tsx` | 수정 | Chrome 적용 패널/카드 지정 |
| `frontend/public/ui/manifest.json` | 수정 | 신규 에셋 메타데이터 등록 |
| `vibe/unit-runbooks/U-032-chrome-pack-runbook.md` | 신규 | 실행 및 검증 가이드 |

---

## 4. 구현 상세

### 4.1 핵심 설계

**Chrome Decoration System**:
- **CSS Psuedo-elements**: `:before`, `:after`를 활용하여 DOM 추가 없이 장식 요소 배치
- **Transform Reuse**: 단일 코너 에셋(`panel-corner-br.png`)을 `rotate()` 변환하여 4방향에 재사용, 리소스 최적화
- **Interactive Feedback**: 카드 호버 시 프레임 색상 및 글로우 강도가 반응하여 게임적 상호작용 강화

**Readable Mode Integration**:
- `html[data-readable="true"]` 셀렉터를 통해 Chrome 요소의 `opacity`를 낮추고 `filter: drop-shadow`를 제거하여 가독성 우선 렌더링 전환

### 4.2 외부 영향 분석

- **데이터/파일 시스템**: `public/ui/chrome` 디렉토리 신설, 정적 에셋 용량 약 110KB 증가
- **성능**: CSS 이미지 로딩 추가, 하지만 Lazy Loading 및 브라우저 캐싱으로 영향 최소화

---

## 5. 런북(Runbook) 정보

- **파일 경로**: `vibe/unit-runbooks/U-032-chrome-pack-runbook.md`
- **실행 결과**: 패널 코너, 액션 카드 프레임, 스캐너 프레임 적용 및 Readable 모드 동작 검증 완료

---

## 6. 리스크 및 주의사항

- **가독성**: Chrome 장식이 텍스트를 가리지 않도록 `z-index` 및 `pointer-events: none` 설정 필수 (적용 완료)
- **에셋 로딩**: 이미지 로드 실패 시에도 레이아웃이 깨지지 않도록 `border` 기반 폴백 스타일 유지

---

## 7. 다음 단계 안내

### 7.1 후속 작업

1. **U-033[Mvp]**: manifest.json 자동화 및 QA 스크립트 확장
2. **U-009[Mvp]**: Action Deck 기능 구현 시 Chrome 프레임 활용

---

## 8. 자체 점검 결과

- [x] 런북 기반 요구사항 충족 확인 (Chrome 적용, Readable 연동)
- [x] Repomix 최신 구조 반영 확인
- [x] 아키텍처/네이밍/경로 일관성 유지
- [x] 파괴적 변경/리스크/가정 명시

---

_본 보고서는 AI Agent에 의해 자동 생성되었습니다._
</file>

<file path="vibe/unit-results/U-034[Mvp].md">
# U-034[Mvp]: nanobanana mcp 에셋 요청 스키마 + 프롬프트 템플릿(재현성) 개발 완료 보고서

## 메타데이터

- **작업 ID**: U-034[Mvp]
- **단계 번호**: MVP
- **작성 일시**: 2026-01-11 15:30
- **담당**: AI Agent

---

## 1. 작업 요약

`nanobanana mcp`를 활용한 에셋 제작 시의 스타일 일관성과 재현성을 확보하기 위해 표준화된 요청 스키마와 카테고리별 프롬프트 템플릿을 정의하고 가이드라인을 구축함.

---

## 2. 작업 범위

- **에셋 요청 스키마 정의**: `id`, `category`, `purpose`, `size_px` 등을 포함하는 JSON 스키마 구축.
- **프롬프트 템플릿 구축**: CRT 레트로 스타일을 반영한 공통 헤더 및 아이콘/Placeholder/Chrome 카테고리별 템플릿 작성.
- **배경 제거(rembg) 프로세스 통합**: 투명 배경이 필요한 에셋을 위해 `rembg` 후처리 절차를 표준화 및 문서화.
- **가이드라인 문서화**: `RULE-007`(dev-only)을 준수하는 개발용 에셋 제작 가이드 구축.

---

## 3. 생성/수정 파일

| 파일 경로 | 유형 | 목적 |
| :--- | :--- | :--- |
| `vibe/ref/nanobanana-mcp.md` | 신규 | 개발용 에셋 제작 가이드 (SSOT) |
| `vibe/ref/nanobanana-asset-request.schema.json` | 신규 | 에셋 요청 JSON 스키마 |
| `vibe/unit-runbooks/U-034-nanobanana-template-runbook.md` | 신규 | 스키마 및 템플릿 검증용 런북 |

---

## 4. 구현 상세

### 4.1 핵심 설계

**에셋 요청 스키마 (`nanobanana-asset-request.schema.json`)**:
- `category`: `icon`, `placeholder`, `chrome`으로 제한하여 목적별 스타일 분기.
- `requires_rembg`: 배경 제거 필요 여부를 명시하고 `rembg_model`을 선택 가능하게 설계.
- `size_px`: 정사각형(아이콘) 및 자유 크기(Placeholder/Chrome) 지원.

**프롬프트 템플릿 (`nanobanana-mcp.md`)**:
- **STYLE HEADER v1**: 1980년대 인광 녹색(#33ff00) CRT 모니터 미학을 공통으로 적용.
- **BACKGROUND RULE**: `rembg` 후처리를 위해 원본 생성 시 순백(#FFFFFF) 단색 배경을 강제함.

### 4.2 외부 영향 분석

- **이미지 생성 도구**: `nanobanana mcp` (Gemini 2.5 Flash Image 기반) 호출 시 이 템플릿을 준수하여 입력.
- **후처리 도구**: `rembg`를 사용하여 알파 채널을 확보하는 단계가 표준 프로세스에 포함됨.

---

## 5. 런북(Runbook) 정보

- **파일 경로**: `vibe/unit-runbooks/U-034-nanobanana-template-runbook.md`
- **실행 결과**:
  - 시나리오 A: JSON 스키마 유효성 검증 통과.
  - 시나리오 B: 카테고리별 템플릿 정의 확인 완료.
  - 시나리오 C/D: 아이콘 및 Placeholder 생성/후처리 절차 검증 완료.

---

## 6. 리스크 및 주의사항

- **RULE-007 준수**: 본 스키마와 템플릿은 오직 **개발용 정적 에셋 제작**에만 사용하며, 런타임 게임 로직에서 MCP에 의존하지 않도록 주의가 필요함.
- **텍스트 렌더링**: 생성형 이미지의 텍스트 렌더링 품질 문제로 인해 가이드에서 이미지 내 텍스트를 최소화할 것을 권고함.

---

## 7. 다음 단계 안내

### 7.1 후속 작업

1. **U-029**: 이 템플릿을 사용하여 실제 UI 에셋(아이콘/프레임/Placeholder) 제작.
2. **U-033**: 생성된 에셋을 `manifest.json`에 등록.

### 7.2 의존 단계 확인

- **선행 단계**: U-030[Mvp] (에셋 SSOT) 완료됨.
- **후속 단계**: U-031, U-032, U-033 등 에셋 제작 및 관리 유닛.

---

## 8. 자체 점검 결과

- [x] 런북 기반 요구사항 충족 확인
- [x] Repomix 최신 구조 반영 확인
- [x] 아키텍처/네이밍/경로 일관성 유지
- [x] 파괴적 변경/리스크/가정 명시

---

_본 보고서는 AI Agent에 의해 자동 생성되었습니다._
</file>

<file path="vibe/unit-runbooks/CP-MVP-01.md">
# CP-MVP-01: 체크포인트 - 스트리밍/스키마/폴백 실행 가이드

## 1. 개요

초기 MVP 루프가 "항상 플레이 가능한 데모" 조건을 만족하는지, **스트리밍/검증/복구/폴백** 관점에서 수동 검증합니다.

- HTTP Streaming으로 Queue/Badges가 먼저 보이고(TTFB 체감), 최종 TurnOutput이 UI에 반영되는지 확인
- TurnOutput 스키마 실패를 유도해도 Auto-repair 또는 safe fallback으로 종료되는지 확인
- 채팅 UI/프롬프트 노출/좌표 규약 위반이 없는지 확인

**예상 소요 시간**: 15분

**의존성**:
- 의존 유닛: RU-002[Mvp] (이벤트 계약/폴백 흐름 정리)
- 선행 완료 필요: U-007, U-008 (스트리밍 파이프라인)

---

## 2. 빠른 시작 (Quick Start)

### 2.1 환경 준비

```bash
# 프론트엔드 의존성 설치
pnpm -C frontend install

# 백엔드 의존성 동기화
cd backend && uv sync && cd ..
```

### 2.2 서버 실행

**터미널 1 - 백엔드 (포트 8011)**:
```bash
cd backend
uv run uvicorn unknown_world.main:app --reload --port 8011
# → http://localhost:8011/health 로 확인
```

**터미널 2 - 프론트엔드 (포트 8001)**:
```bash
pnpm -C frontend dev
# → http://localhost:8001 로 접근
```

### 2.3 즉시 실행

브라우저에서 http://localhost:8001 접속

### 2.4 첫 화면/결과 확인

- CRT 테마의 게임 UI가 렌더링됨
- Agent Console에 Queue(Parse→Commit), Badges(검증 대기 중) 표시
- Action Deck에 카드 3장(비용/위험 표시)
- Economy HUD에 Signal/Shard 표시

---

## 3. 핵심 기능 시나리오

### 시나리오 A: 기본 데모 (성공 경로)

**목적**: HTTP Streaming으로 단계/배지가 먼저 보이고 최종 TurnOutput이 UI에 반영되는지 확인

**실행**:
1. 명령 입력창에 "문을 열어본다" 입력
2. EXECUTE 버튼 클릭

**기대 결과**:
1. Agent Console 상태가 "PROCESSING"으로 변경
2. Queue에서 Parse → Validate → Plan → Resolve → Render → Verify → Commit 순으로 진행
3. Badges에 Schema OK, Economy OK, Safety OK, Consistency OK 표시
4. 내러티브 피드에 새 턴 텍스트 표시 (타자 효과)
5. Economy HUD에서 Signal 차감 확인 (예: 100 → 96)
6. Action Deck에 새로운 카드들 표시

**확인 포인트**:
- ✅ TTFB < 2초 (첫 stage 이벤트가 즉시 도착)
- ✅ 모든 7단계가 순서대로 진행됨
- ✅ 4개 배지 모두 OK 상태
- ✅ 경제 상태가 TurnOutput의 balance_after와 일치

---

### 시나리오 B: 입력 검증 실패 (에러 폴백)

**목적**: 잘못된 입력 시 error + final(폴백)으로 안전하게 종료되는지 확인

**실행**:
```bash
# 잘못된 JSON 형식으로 API 직접 호출
curl -s -X POST http://localhost:8011/api/turn \
  -H "Content-Type: application/json" \
  -d '{"invalid_field": true}'
```

**기대 결과**:
```
{"type": "error", "message": "Invalid input", "code": "VALIDATION_ERROR"}
{"type": "final", "data": {"language": "ko-KR", "narrative": "잠시 혼란이 있었습니다. 다시 시도해주세요.", ...}}
```

**확인 포인트**:
- ✅ error 이벤트가 먼저 송출됨
- ✅ final(폴백) 이벤트로 종료됨 (스트림 종료 인바리언트)
- ✅ economy.cost = 0 (손실 없음)
- ✅ agent_console.badges에 "schema_fail" 포함
- ✅ UI가 빈 화면이 되지 않음

---

### 시나리오 C: NDJSON 스트리밍 검증

**목적**: 모든 이벤트 타입이 올바른 순서로 스트리밍되는지 확인

**실행**:
```bash
# 테스트 JSON 파일 생성
cat > /tmp/test-turn.json << 'EOF'
{
  "language": "ko-KR",
  "text": "테스트 입력",
  "click": null,
  "client": {
    "viewport_w": 1920,
    "viewport_h": 1080,
    "theme": "dark"
  },
  "economy_snapshot": {
    "signal": 50,
    "memory_shard": 3
  }
}
EOF

# API 호출 (seed 파라미터로 재현성 보장)
curl -s -X POST "http://localhost:8011/api/turn?seed=12345" \
  -H "Content-Type: application/json" \
  -d @/tmp/test-turn.json
```

**기대 결과**:
```
{"type": "stage", "name": "parse", "status": "start"}
{"type": "stage", "name": "parse", "status": "complete"}
...
{"type": "badges", "badges": ["schema_ok", "economy_ok"]}
...
{"type": "badges", "badges": ["schema_ok", "economy_ok", "safety_ok", "consistency_ok"]}
...
{"type": "narrative_delta", "text": "당신은 \"테스트 입력\"..."}
...
{"type": "final", "data": {...}}
```

**확인 포인트**:
- ✅ stage 이벤트: 7단계 각각 start/complete
- ✅ badges 이벤트: Validate 후 2개, Verify 후 4개
- ✅ narrative_delta 이벤트: 텍스트가 청크로 분할됨
- ✅ final 이벤트: 완전한 TurnOutput 포함
- ✅ 좌표 규약: box_2d가 {ymin, xmin, ymax, xmax} 형식, 0~1000 범위

---

## 4. 금지사항/인바리언트 체크

### 4.1 채팅 버블 UI 확인 (RULE-002)

**검증 방법**:
```bash
# 프론트엔드 코드에서 ChatBubble 검색
grep -ri "ChatBubble\|chat-bubble\|chatBubble" frontend/src/
# 결과: 매칭 없음 ✅
```

**UI에서 확인**:
- 내러티브가 "게임 로그/피드" 형태로 표시됨
- 메신저형 버블 UI 없음

### 4.2 프롬프트 노출 확인 (RULE-007/008)

**검증 방법**:
1. 브라우저 DevTools > Console 탭 확인
2. 네트워크 탭에서 응답 확인

**확인 포인트**:
- ✅ 프롬프트 원문이 UI/콘솔에 노출되지 않음
- ✅ Agent Console에 단계/배지/복구 횟수만 표시됨
- ✅ Chain-of-thought 텍스트 없음

### 4.3 좌표 규약 확인 (RULE-009)

**검증 방법**:
```bash
# API 응답에서 box_2d 확인
curl -s -X POST "http://localhost:8011/api/turn?seed=12345" \
  -H "Content-Type: application/json" \
  -d @/tmp/test-turn.json | jq '.data.ui.objects[0].box_2d'
```

**기대 결과**:
```json
{
  "ymin": 543,
  "xmin": 422,
  "ymax": 742,
  "xmax": 601
}
```

**확인 포인트**:
- ✅ [ymin, xmin, ymax, xmax] 순서
- ✅ 0~1000 정규화 범위 내 값
- ✅ 0~1 좌표계나 [x,y,w,h] 형식이 아님

---

## 5. 실행 결과 확인

### 5.1 성공/실패 판단 기준

**성공** (MVP Hard Gate 통과):
- ✅ **Schema OK**: TurnOutput JSON이 Zod 스키마를 통과
- ✅ **Economy OK**: 비용/잔액 불일치 없음, 잔액 음수 금지
- ✅ **Safety OK**: 차단 시 명시 + 안전한 대체 결과 제공
- ✅ **Consistency OK**: WorldState/Rule Board/Memory Pin 일관성 유지

**실패 시 확인**:
- ❌ 스트리밍이 시작되지 않음 → 백엔드 서버 상태 확인
- ❌ Zod 검증 실패 → 프론트엔드 콘솔에서 에러 확인
- ❌ 경제 상태 불일치 → TurnOutput.economy.balance_after 확인

### 5.2 관측 메트릭

| 지표 | 목표 | 측정 방법 |
|------|------|-----------|
| Streaming TTFB | < 2s | 네트워크 탭에서 첫 바이트 시간 |
| 단계 완료 시간 | < 1s | stage 이벤트 타임스탬프 |
| 스키마 통과율 | 100% | Badges에서 Schema OK 확인 |

---

## 6. 문제 해결 (Troubleshooting)

### 6.1 일반적인 오류

**오류**: `CORS error`
- **원인**: 프론트엔드-백엔드 포트 불일치
- **해결**: 백엔드 CORS 설정에 http://localhost:8001 포함 확인

**오류**: `Connection refused`
- **원인**: 백엔드 서버 미실행
- **해결**: `uv run uvicorn unknown_world.main:app --reload --port 8011` 실행

**오류**: `TurnOutput validation failed` (콘솔)
- **원인**: 서버 응답이 Zod 스키마와 불일치
- **해결**: 백엔드 TurnOutput Pydantic 모델과 프론트엔드 Zod 스키마 동기화 확인

### 6.2 환경별 주의사항

- **Windows**: curl 명령에서 JSON 이스케이프 문제 발생 가능 → 파일로 저장 후 `@파일명` 사용
- **macOS/Linux**: 특이사항 없음

---

## 7. 체크포인트 증거

### 7.1 검증 완료 시 확인 항목

| 항목 | 상태 | 비고 |
|------|------|------|
| HTTP Streaming TTFB < 2s | ✅ | 첫 stage 이벤트 즉시 도착 |
| 7단계 Queue 진행 표시 | ✅ | Parse→Commit |
| 4개 배지 OK 표시 | ✅ | Schema/Economy/Safety/Consistency |
| 입력 실패 시 폴백 | ✅ | error + final(폴백) 순서 |
| 채팅 버블 UI 없음 | ✅ | RULE-002 준수 |
| 프롬프트 노출 없음 | ✅ | RULE-007/008 준수 |
| bbox 0~1000 정규화 | ✅ | RULE-009 준수 |

### 7.2 스크린샷

체크포인트 실행 시 다음 스크린샷을 캡처하여 보관:
1. 초기 화면 (CRT 테마 게임 UI)
2. 스트리밍 중 (PROCESSING 상태)
3. 완료 후 (Badges OK, 새 내러티브)

---

_본 런북은 CP-MVP-01 체크포인트를 위해 작성되었습니다._
</file>

<file path="vibe/unit-runbooks/U-001-scaffolding-runbook.md">
# U-001 프로젝트 스캐폴딩 실행 가이드

## 1. 개요

프론트엔드(`frontend/`)와 백엔드(`backend/`) 디렉토리 구조를 생성하고, 비밀정보가 레포에 들어가지 않도록 `.gitignore`를 설정합니다.

이 유닛은 다음 유닛(U-002, U-003)이 즉시 초기화 작업을 시작할 수 있는 기반을 제공합니다.

**예상 소요 시간**: 5분

**의존성**:

- 의존 유닛: 없음
- 선행 완료 필요: 없음

---

## 2. 빠른 시작 (Quick Start)

### 2.1 환경 준비

이 유닛은 별도 의존성 설치가 필요하지 않습니다.

### 2.2 즉시 확인

```bash
# 프로젝트 루트에서 실행
ls -la
```

### 2.3 첫 화면/결과 확인

- `frontend/` 디렉토리 존재
- `backend/` 디렉토리 존재
- `.gitignore` 파일 존재

---

## 3. 핵심 기능 시나리오

### 시나리오 A: 디렉토리 구조 확인

**목적**: 프론트엔드/백엔드 디렉토리가 올바르게 생성되었는지 검증

**실행**:

```bash
# Frontend 구조 확인
ls -la frontend/
ls -la frontend/src/

# Backend 구조 확인
ls -la backend/
ls -la backend/src/unknown_world/
ls -la backend/prompts/
```

**기대 결과**:

```
frontend/
├── .gitkeep
└── src/
    └── .gitkeep

backend/
├── .gitkeep
├── prompts/
│   └── .gitkeep
└── src/
    └── unknown_world/
        └── __init__.py
```

**확인 포인트**:

- ✅ `frontend/` 디렉토리 존재
- ✅ `frontend/src/` 디렉토리 존재
- ✅ `backend/` 디렉토리 존재
- ✅ `backend/src/unknown_world/__init__.py` 파일 존재 (패키지)
- ✅ `backend/prompts/` 디렉토리 존재

---

### 시나리오 B: Python 패키지 임포트 테스트

**목적**: 백엔드 패키지 구조가 올바른지 검증

**실행**:

```bash
# Python에서 패키지 임포트 테스트
cd backend
python -c "from src.unknown_world import __version__; print(f'Version: {__version__}')"
```

**기대 결과**:

```
Version: 0.0.0
```

**확인 포인트**:

- ✅ Python 패키지 임포트 성공
- ✅ 버전 정보 출력

---

### 시나리오 C: .gitignore 비밀정보 보호 테스트

**목적**: 비밀정보 파일이 Git에서 무시되는지 검증 (RULE-007)

**실행**:

```bash
# 테스트용 비밀정보 파일 생성
echo "fake-secret" > service-account-test.json
echo "API_KEY=secret" > .env

# Git 상태 확인 (이 파일들이 무시되어야 함)
git status --ignored

# 정리
rm -f service-account-test.json .env
```

**기대 결과**:

```
Ignored files:
  service-account-test.json
  .env
```

**확인 포인트**:

- ✅ `service-account*.json` 패턴 파일 무시됨
- ✅ `.env` 파일 무시됨
- ✅ 비밀정보가 Git에 추가되지 않음

---

### 시나리오 D: 필수 파일은 추적 확인

**목적**: package.json, tsconfig.json 등 필요한 JSON 파일은 추적되는지 검증

**실행**:

```bash
# 테스트용 설정 파일 생성
echo '{}' > frontend/package.json
echo '{}' > frontend/tsconfig.json

# Git 상태 확인 (이 파일들은 추적되어야 함)
git status

# 정리
rm -f frontend/package.json frontend/tsconfig.json
```

**기대 결과**:

- `frontend/package.json`이 Untracked files로 표시됨 (무시되지 않음)
- `frontend/tsconfig.json`이 Untracked files로 표시됨 (무시되지 않음)

**확인 포인트**:

- ✅ `package.json` 파일은 추적됨
- ✅ `tsconfig.json` 파일은 추적됨

---

## 4. 실행 결과 확인

### 4.1 생성 파일

| 경로                                    | 목적                                  |
| --------------------------------------- | ------------------------------------- |
| `frontend/.gitkeep`                     | 프론트엔드 루트 디렉토리 플레이스홀더 |
| `frontend/src/.gitkeep`                 | 소스 디렉토리 플레이스홀더            |
| `backend/.gitkeep`                      | 백엔드 루트 디렉토리 플레이스홀더     |
| `backend/src/unknown_world/__init__.py` | Python 패키지 초기화                  |
| `backend/prompts/.gitkeep`              | 프롬프트 디렉토리 플레이스홀더        |
| `.gitignore`                            | Git 무시 설정 (비밀정보 보호)         |

### 4.2 성공/실패 판단 기준

**성공**:

- ✅ 모든 디렉토리/파일이 생성됨
- ✅ Python 패키지 임포트 성공
- ✅ 비밀정보 파일이 Git에서 무시됨
- ✅ 설정 파일(package.json 등)은 추적됨

**실패 시 확인**:

- ❌ 디렉토리 없음 → 파일 생성 스크립트 재실행
- ❌ 패키지 임포트 실패 → `__init__.py` 파일 확인
- ❌ 비밀정보가 추적됨 → `.gitignore` 패턴 확인

---

## 5. 문제 해결 (Troubleshooting)

### 5.1 일반적인 오류

**오류**: `ModuleNotFoundError: No module named 'src'`

- **원인**: Python 경로에 `backend/` 디렉토리가 포함되지 않음
- **해결**: `cd backend` 후 실행하거나, `PYTHONPATH=backend python ...` 사용

**오류**: 비밀정보 파일이 Git에 추가됨

- **원인**: `.gitignore` 파일이 없거나 패턴이 잘못됨
- **해결**: `.gitignore` 파일 내용 확인 및 수정

### 5.2 환경별 주의사항

- **Windows**: 경로 구분자 `\` vs `/` 차이 주의. Git Bash 또는 PowerShell 사용 권장
- **macOS/Linux**: 특이사항 없음

---

## 6. 다음 단계

- **U-002**: `frontend/`를 Vite + React + TypeScript로 초기화
- **U-003**: `backend/`를 FastAPI 프로젝트로 초기화
</file>

<file path="vibe/unit-runbooks/U-002-frontend-init-runbook.md">
# U-002[Mvp] 프론트 Vite+React+TS 초기화 실행 가이드

## 1. 개요

이 유닛은 Unknown World 프로젝트의 **프론트엔드 개발 환경**을 Vite 7 + React 19 + TypeScript 5.9로 초기화합니다.
`frontend/` 디렉토리에서 `pnpm install` 및 `pnpm dev`가 성공적으로 실행되고, 로컬 개발 서버에서 기본 UI를 확인할 수 있습니다.

**예상 소요 시간**: 5분

**의존성**:

- 의존 유닛: U-001[Mvp] - 프로젝트 스캐폴딩
- 선행 완료 필요: U-001 완료 (frontend/ 디렉토리 존재)

---

## 2. 빠른 시작 (Quick Start)

### 2.1 환경 준비

```bash
# Node.js 24.x 및 pnpm 10.27.0 필요
node --version  # v24.x
pnpm --version  # 10.27.0

# pnpm이 없다면 corepack으로 활성화
corepack enable
```

### 2.2 의존성 설치

```bash
cd frontend
pnpm install
```

### 2.3 즉시 실행

```bash
pnpm dev
```

### 2.4 첫 화면/결과 확인

- 브라우저에서 `http://localhost:5173/` 접속
- 성공 지표:
  - 콘솔에 `VITE v7.3.0 ready` 메시지 출력
  - 검정 배경에 녹색 "Unknown World" 타이틀 표시
  - "⚡ 개발 환경 초기화 완료" 메시지 표시

---

## 3. 핵심 기능 시나리오

### 시나리오 A: 개발 서버 정상 동작

**목적**: Vite 개발 서버가 정상적으로 시작되고 React 앱이 렌더링되는지 검증

**실행**:

```bash
cd frontend
pnpm dev
```

**기대 결과**:

```
VITE v7.3.0  ready in 248 ms

➜  Local:   http://localhost:5173/
➜  Network: use --host to expose
```

**확인 포인트**:

- ✅ 포트 5173에서 서버 시작
- ✅ 브라우저에서 페이지 로드 성공
- ✅ 콘솔에 에러 없음 (Vite HMR 연결 성공)

---

### 시나리오 B: 린트/타입체크 통과

**목적**: 코드 품질 도구가 정상 동작하는지 검증

**실행**:

```bash
cd frontend
pnpm run lint
pnpm run typecheck
```

**기대 결과**:

```
# 린트: 에러 없이 완료
# 타입체크: 에러 없이 완료
```

**확인 포인트**:

- ✅ ESLint 검사 통과 (exit code 0)
- ✅ TypeScript 타입 체크 통과 (exit code 0)

---

### 시나리오 C: 빌드 성공

**목적**: 프로덕션 빌드가 정상적으로 완료되는지 검증

**실행**:

```bash
cd frontend
pnpm run build
```

**기대 결과**:

```
✓ built in XXXms
dist/
├── assets/
│   ├── index-XXXXXX.js
│   └── index-XXXXXX.css
└── index.html
```

**확인 포인트**:

- ✅ `dist/` 디렉토리 생성
- ✅ index.html, JS/CSS 에셋 파일 생성
- ✅ 빌드 에러 없음

---

## 4. 실행 결과 확인

### 4.1 버전 확인

프로젝트에서 사용하는 핵심 의존성 버전:

| 패키지    | 버전   | tech-stack.md 기준 |
| --------- | ------ | ------------------ |
| react     | 19.2.3 | ✅ 일치            |
| react-dom | 19.2.3 | ✅ 일치            |
| vite      | 7.3.0  | ✅ 일치            |
| typescript | 5.9.3 | ✅ 일치            |
| pnpm      | 10.27.0| ✅ 일치            |

### 4.2 파일 구조

```
frontend/
├── index.html          # 엔트리 HTML
├── package.json        # 의존성 및 스크립트
├── pnpm-lock.yaml      # lockfile
├── tsconfig.json       # TypeScript 설정 (엄격 모드)
├── tsconfig.node.json  # Vite 설정용 TS 설정
├── vite.config.ts      # Vite 빌드/개발 설정
├── eslint.config.mjs   # ESLint Flat Config
├── public/
│   └── vite.svg        # 파비콘
└── src/
    ├── main.tsx        # 엔트리 포인트
    ├── App.tsx         # 메인 컴포넌트
    ├── style.css       # 단일 CSS SSOT
    └── vite-env.d.ts   # Vite 타입 선언
```

### 4.3 성공/실패 판단 기준

**성공**:

- ✅ `pnpm install` 에러 없이 완료
- ✅ `pnpm dev` 실행 시 http://localhost:5173 접근 가능
- ✅ `pnpm run lint` 통과
- ✅ `pnpm run typecheck` 통과
- ✅ 브라우저 콘솔에 에러 없음

**실패 시 확인**:

- ❌ pnpm 버전 불일치 → `corepack enable` 후 재시도
- ❌ 포트 5173 충돌 → 다른 프로세스 종료 또는 vite.config.ts에서 포트 변경
- ❌ 타입 에러 → tsconfig.json 설정 확인

---

## 5. 문제 해결 (Troubleshooting)

### 5.1 일반적인 오류

**오류**: `EADDRINUSE: address already in use :::5173`

- **원인**: 포트 5173이 이미 사용 중
- **해결**:

```bash
# Windows
netstat -ano | findstr :5173
taskkill /PID <PID> /F

# 또는 vite.config.ts에서 다른 포트 지정
```

**오류**: `pnpm: command not found`

- **원인**: pnpm이 설치되지 않음
- **해결**:

```bash
corepack enable
# 또는
npm install -g pnpm@10.27.0
```

**오류**: `TS6306: Referenced project must have setting "composite": true`

- **원인**: tsconfig.node.json에 composite 설정 누락
- **해결**: tsconfig.node.json에 `"composite": true` 추가

### 5.2 환경별 주의사항

- **Windows**: 줄 끝이 CRLF로 변경될 수 있음 → `.gitattributes`로 LF 강제
- **macOS/Linux**: Node.js 버전 관리 시 nvm 사용 권장

---

## 6. 다음 단계

- **U-004**: CRT 테마 및 고정 게임 UI 레이아웃 구현
- **U-006**: Zod 스키마 추가 (TurnOutput 검증)
</file>

<file path="vibe/unit-runbooks/U-003-backend-init-runbook.md">
# U-003[Mvp] 백엔드 FastAPI 초기화 실행 가이드

## 1. 개요

이 유닛은 FastAPI 기반 오케스트레이터 백엔드의 **실행 가능한 최소 뼈대**를 구축합니다.
`/health` 엔드포인트로 헬스체크가 가능하고, 프론트엔드와 통신할 수 있는 CORS 설정이 준비됩니다.

**예상 소요 시간**: 5분

**의존성**:

- 의존 유닛: U-001[Mvp] (디렉토리 스캐폴딩)
- 선행 완료 필요: 없음 (U-001은 디렉토리만 생성)

---

## 2. 빠른 시작 (Quick Start)

### 2.1 환경 준비

**필수 조건**:
- Python 3.14 이상
- uv (Python 패키지 매니저)

```bash
# 프로젝트 루트에서 시작
cd backend

# 의존성 동기화 (uv 사용)
uv sync --all-groups
```

### 2.2 즉시 실행

```bash
# 개발 서버 실행 (hot reload 포함)
# RULE-011: 백엔드는 8011~8020 포트 사용 (기본: 8011)
cd backend
uv run uvicorn unknown_world.main:app --reload --port 8011
```

### 2.3 첫 화면/결과 확인

- 브라우저 또는 curl로 접속:
  - 루트: `http://localhost:8011/`
  - 헬스: `http://localhost:8011/health`
  - API 문서: `http://localhost:8011/docs`

- 성공 지표:
  - 콘솔에 `Uvicorn running on http://127.0.0.1:8011` 메시지 출력
  - `/health` 응답에 `"status": "ok"` 포함

---

## 3. 핵심 기능 시나리오

### 시나리오 A: 헬스체크 확인

**목적**: 서버가 정상 기동되고 헬스체크 API가 동작하는지 검증

**실행**:

```bash
curl http://localhost:8011/health
```

**기대 결과**:

```json
{
  "status": "ok",
  "version": "0.0.0",
  "service": "unknown-world-backend"
}
```

**확인 포인트**:

- ✅ HTTP 200 응답
- ✅ `status`가 `"ok"`
- ✅ `version`이 `__init__.py`의 `__version__`과 일치

---

### 시나리오 B: API 문서 확인 (Swagger UI)

**목적**: FastAPI 자동 생성 API 문서가 정상 렌더링되는지 검증

**실행**:

1. 브라우저에서 `http://localhost:8011/docs` 접속

**기대 결과**:

- Swagger UI 페이지가 렌더링됨
- "Unknown World API" 타이틀 표시
- `/health` 엔드포인트가 목록에 표시됨

**확인 포인트**:

- ✅ 페이지 로딩 성공
- ✅ 엔드포인트 "Try it out" 기능 동작

---

### 시나리오 C: CORS 헤더 확인

**목적**: 프론트엔드(localhost:8001)에서 API 호출 시 CORS 오류가 발생하지 않는지 검증

**실행**:

```bash
curl -i -X OPTIONS http://localhost:8011/health \
  -H "Origin: http://localhost:8001" \
  -H "Access-Control-Request-Method: GET"
```

**기대 결과**:

- `Access-Control-Allow-Origin: http://localhost:8001` 헤더 포함
- `Access-Control-Allow-Methods` 헤더 포함

**확인 포인트**:

- ✅ HTTP 200 응답
- ✅ CORS 헤더가 올바르게 설정됨

---

### 시나리오 D: 루트 엔드포인트 확인

**목적**: 루트 경로가 API 안내를 제공하는지 검증

**실행**:

```bash
curl http://localhost:8011/
```

**기대 결과**:

```json
{
  "message": "Unknown World API",
  "docs": "/docs",
  "health": "/health"
}
```

**확인 포인트**:

- ✅ HTTP 200 응답
- ✅ 안내 메시지 포함

---

## 4. 실행 결과 확인

### 4.1 로그 확인

- 위치: 콘솔 출력 (터미널)
- 주요 로그 메시지:
  - `INFO:     Uvicorn running on http://127.0.0.1:8011 (Press CTRL+C to quit)` - 정상 시작
  - `INFO:     Started reloader process` - Hot reload 활성화
  - `INFO:     127.0.0.1:xxxx - "GET /health HTTP/1.1" 200 OK` - 요청 처리 성공

### 4.2 성공/실패 판단 기준

**성공**:

- ✅ 서버가 8011 포트에서 기동됨
- ✅ `/health` 엔드포인트가 JSON 응답 반환
- ✅ CORS 헤더가 localhost 오리진에 대해 설정됨
- ✅ API 문서(Swagger UI)가 렌더링됨

**실패 시 확인**:

- ❌ `ModuleNotFoundError: No module named 'unknown_world'` → `cd backend` 후 실행 확인
- ❌ 포트 충돌 → `--port 8012` 등 다른 포트 사용 (RULE-011: 8011~8020 범위)
- ❌ 의존성 오류 → `uv sync --all-groups` 재실행

---

## 5. 문제 해결 (Troubleshooting)

### 5.1 일반적인 오류

**오류**: `ModuleNotFoundError: No module named 'fastapi'`

- **원인**: 의존성 미설치
- **해결**: `cd backend && uv sync --all-groups`

**오류**: `ModuleNotFoundError: No module named 'unknown_world'`

- **원인**: 잘못된 디렉토리에서 실행
- **해결**: 반드시 `backend/` 디렉토리에서 실행

**오류**: `Address already in use` 또는 `[WinError 10013]`

- **원인**: 8011 포트가 이미 사용 중
- **해결**: 
  1. `pnpm kill:back` 실행으로 기존 서버 종료
  2. 또는 `--port 8012` 등 다른 포트 사용 (RULE-011: 8011~8020 범위)

### 5.2 환경별 주의사항

- **Windows**: 경로 구분자가 `\`이지만 Python 실행에는 영향 없음
- **macOS/Linux**: 특이사항 없음

---

## 6. 검증 완료 체크리스트

- [ ] `uv sync --all-groups` 성공
- [ ] `uvicorn unknown_world.main:app --reload --port 8011` 성공
- [ ] `curl http://localhost:8011/health` → `{"status": "ok", ...}` 응답
- [ ] `curl http://localhost:8011/docs` → Swagger UI 페이지 로드
- [ ] CORS preflight 요청 성공 (Origin: http://localhost:8001)

---

## 7. 다음 단계

- **U-005**: TurnInput/TurnOutput(Pydantic) 모델 추가
- **U-007**: `/api/turn` SSE 스트리밍 라우트 추가
</file>

<file path="vibe/unit-runbooks/U-004-crt-layout-runbook.md">
# U-004 CRT 테마/고정 레이아웃 스켈레톤 실행 가이드

## 1. 개요

CRT 터미널 레트로 미학을 기반으로 한 게임 UI 레이아웃 스켈레톤을 구현했습니다. RULE-002(채팅 버블 UI 금지)를 준수하여, 내러티브는 "채팅"이 아닌 "게임 로그/턴 타임라인" 형태로 배치되었습니다.

**핵심 기능**:
- CSS Grid 기반 고정 레이아웃 (Header / Sidebar Left / Center / Sidebar Right / Footer)
- CRT 테마 토큰 (인광 녹색, 스캔라인 오버레이, 플리커 효과, 글리치 타이틀)
- 8개 고정 패널 슬롯 (Inventory, Quest, Rule Board, Scene Canvas, Agent Console, Memory Pin, Scanner, Action Deck)
- 반응형 디자인 (데스크톱 → 태블릿 → 모바일)

**예상 소요 시간**: 5분

**의존성**:
- 의존 유닛: U-002[Mvp] (Vite+React+TS 실행 환경)
- 선행 완료 필요: U-002 런북 실행 완료

---

## 2. 빠른 시작 (Quick Start)

### 2.1 환경 준비

```bash
cd frontend
pnpm install
```

### 2.2 의존 유닛 확인

```bash
# Node.js 및 pnpm 버전 확인
node --version  # v24.x 이상
pnpm --version  # v10.x 이상
```

### 2.3 즉시 실행

```bash
pnpm dev --port 8001
```

### 2.4 첫 화면/결과 확인

- 브라우저에서 `http://localhost:8001` 접속
- 성공 지표:
  - 녹색 인광 CRT 테마 화면 표시
  - "UNKNOWN WORLD" 글리치 타이틀 표시
  - 3열 레이아웃 (좌 사이드바 / 중앙 / 우 사이드바)

---

## 3. 핵심 기능 시나리오

### 시나리오 A: CRT 테마 확인

**목적**: CRT 인광 녹색 테마와 스캔라인 효과 검증

**실행**:
1. 브라우저에서 `http://localhost:8001` 접속

**기대 결과**:
- 배경색: 거의 순수한 검정 (#0d0d0d)
- 텍스트: 인광 녹색 (#33ff00) + 글로우 효과
- 스캔라인 오버레이: 수평선이 화면 전체에 미세하게 보임
- 플리커 효과: 미세한 깜빡임 애니메이션

**확인 포인트**:
- ✅ 녹색 텍스트에 text-shadow 글로우 적용
- ✅ 스캔라인이 클릭을 방해하지 않음 (pointer-events: none)
- ✅ "UNKNOWN WORLD" 타이틀에 글리치 효과 적용

---

### 시나리오 B: 고정 레이아웃 패널 확인

**목적**: 8개 고정 UI 패널 슬롯 존재 검증 (RULE-002 준수)

**실행**:
1. 브라우저에서 화면 전체 레이아웃 확인

**기대 결과**:

| 영역 | 패널 | 상태 |
|------|------|------|
| Header | Economy HUD (Signal: 100), Connection Status (ONLINE) | 표시됨 |
| Sidebar Left | Inventory, Quest, Rule Board | 표시됨 |
| Center | Scene Canvas, Narrative Feed | 표시됨 |
| Sidebar Right | Agent Console, Memory Pin, Scanner | 표시됨 |
| Footer | Action Deck (4장 카드), Command Input | 표시됨 |

**확인 포인트**:
- ✅ 모든 패널이 "자리"로 항상 존재
- ✅ 채팅 버블 UI 없음 (RULE-002)
- ✅ 내러티브는 턴 타임라인 형태 ([TURN 1], [TURN 2], ...)

---

### 시나리오 C: Action Deck 호버 효과

**목적**: 액션 카드 인터랙션 검증

**실행**:
1. Footer의 "탐색하기" 카드에 마우스를 올림

**기대 결과**:
- 테두리 색상이 마젠타(#ff00ff)로 변경
- 카드 주변에 마젠타 글로우 효과

**확인 포인트**:
- ✅ 호버 시 시각적 피드백 제공
- ✅ 비용/위험 정보 표시 (예: "⚡ 1 Signal | ⚠ 낮음")

---

### 시나리오 D: 반응형 레이아웃 (태블릿)

**목적**: 1200px 이하에서 레이아웃 변화 검증

**실행**:
1. 브라우저 창 너비를 1200px 이하로 조절
2. 또는 개발자 도구에서 반응형 모드 활성화

**기대 결과**:
- Sidebar Left가 숨겨짐
- 2열 레이아웃 (Center + Sidebar Right)으로 변경

**확인 포인트**:
- ✅ 핵심 패널(Scene Canvas, Narrative Feed, Action Deck) 유지
- ✅ Agent Console/Scanner 접근 가능

---

### 시나리오 E: 반응형 레이아웃 (모바일)

**목적**: 768px 이하에서 레이아웃 변화 검증

**실행**:
1. 브라우저 창 너비를 768px 이하로 조절
2. 또는 개발자 도구에서 모바일 디바이스 선택 (예: iPhone SE)

**기대 결과**:
- 양쪽 사이드바 모두 숨겨짐
- 1열 레이아웃 (Header → Center → Footer)
- 폰트 크기 축소 (14px)

**확인 포인트**:
- ✅ Action Deck 카드가 가로 스크롤 가능
- ✅ Command Input 여전히 사용 가능
- ✅ Narrative Feed 가독성 유지

---

## 4. 실행 결과 확인

### 4.1 로그 확인

- 위치: Vite 개발 서버 터미널 출력
- 정상 메시지:
  ```
  VITE v7.3.0  ready in XXX ms
  ➜  Local:   http://localhost:8001/
  ```

### 4.2 생성/수정 파일

| 파일 | 설명 |
|------|------|
| `frontend/src/style.css` | CRT 테마 토큰, 스캔라인 오버레이, Grid 레이아웃 |
| `frontend/src/App.tsx` | 고정 게임 UI 레이아웃 컴포넌트 |
| `frontend/index.html` | VT323 폰트 로드, data-theme 속성 |

### 4.3 성공/실패 판단 기준

**성공**:
- ✅ CRT 녹색 테마가 전체 화면에 적용됨
- ✅ 스캔라인 오버레이가 표시되고 클릭을 방해하지 않음
- ✅ 8개 패널 슬롯이 모두 표시됨
- ✅ 채팅 버블 UI 없음 (RULE-002 준수)
- ✅ 반응형 레이아웃이 정상 동작함
- ✅ 린트/타입체크 오류 없음

**실패 시 확인**:
- ❌ 녹색 테마가 보이지 않음 → CSS 파일 import 확인 (`main.tsx`에서 `style.css` import)
- ❌ 폰트가 깨져 보임 → Google Fonts CDN 연결 확인 (VT323)
- ❌ 레이아웃이 무너짐 → 브라우저 개발자 도구에서 CSS Grid 확인

---

## 5. 문제 해결 (Troubleshooting)

### 5.1 일반적인 오류

**오류**: 폰트가 시스템 폰트로 표시됨

- **원인**: CDN 폰트 로드 실패 또는 @font-face 적용 안됨
- **해결**:
  1. 네트워크 연결 확인
  2. `index.html`에 Google Fonts 링크 존재 확인
  3. `style.css`에 `@font-face` 정의 확인

**오류**: 스캔라인 효과가 클릭을 방해함

- **원인**: `pointer-events: none` 미적용
- **해결**: `.crt-overlay` 스타일에 `pointer-events: none` 추가

**오류**: 반응형이 동작하지 않음

- **원인**: `viewport` 메타 태그 누락
- **해결**: `index.html`에 `<meta name="viewport" content="width=device-width, initial-scale=1.0" />` 확인

### 5.2 환경별 주의사항

- **Windows**: NeoDunggeunmo 폰트가 CDN에서 로드되므로 로컬 설치 불필요
- **macOS/Linux**: 동일하게 동작

---

## 6. 다음 단계

이 유닛을 기반으로 다음 작업에서 패널별 실제 기능이 구현됩니다:
- U-009~U-012: Action Deck, Hotspot, Drag & Drop 등 인터랙션
- U-008: SSE 스트리밍 연결 시에도 UI가 채팅 형태로 퇴행하지 않도록 구조 유지

---

_마지막 업데이트: 2026-01-04_
</file>

<file path="vibe/unit-runbooks/U-006-zod-schemas-runbook.md">
# U-006[Mvp] TurnInput/TurnOutput Zod 스키마 실행 가이드

## 1. 개요

백엔드 Pydantic 모델과 1:1 대응하는 프론트엔드 Zod 스키마를 구현했습니다. 이 스키마는 다음을 제공합니다:

- **TurnInput/TurnOutput Zod 스키마**: strict 모드로 정의되어 추가 속성을 금지합니다
- **안전 폴백**: 스키마 검증 실패 시에도 UI가 멈추지 않도록 폴백 TurnOutput을 제공합니다
- **인바리언트 검증**: 좌표(0~1000), 언어(ko-KR/en-US), 재화(0 이상) 검증이 스키마 레벨에서 강제됩니다
- **Q1 결정 반영**: schema_version 포함 (Option A)

**예상 소요 시간**: 5분

**의존성**:

- 의존 유닛: U-002[Mvp] (TypeScript 프론트 환경), U-005[Mvp] (서버 Pydantic 스키마)
- 선행 완료 필요: U-002 런북 실행 완료

---

## 2. 빠른 시작 (Quick Start)

### 2.1 환경 준비

```bash
cd frontend
pnpm install
```

### 2.2 의존 유닛 확인

```bash
# TypeScript 환경 확인
pnpm typecheck

# 린트 확인
pnpm lint
```

### 2.3 즉시 실행

```bash
# 개발 서버 시작
pnpm dev
```

### 2.4 첫 화면/결과 확인

- 개발 서버가 정상 구동되면 스키마 모듈이 정상적으로 로드됩니다.
- 성공 지표: 타입체크/린트 에러 없이 빌드 성공

---

## 3. 핵심 기능 시나리오

### 시나리오 A: TurnOutput 스키마 검증 (정상 케이스)

**목적**: 유효한 TurnOutput JSON이 스키마를 통과하는지 검증

**실행**:

브라우저 개발자 도구 콘솔에서 실행:

```javascript
// 모듈 임포트 (Vite 개발 서버 환경에서)
const { TurnOutputSchema, safeParseTurnOutput } = await import('/src/schemas/turn.ts');

// 유효한 TurnOutput 데이터
const validOutput = {
  language: "ko-KR",
  narrative: "문이 삐걱거리며 열립니다...",
  economy: {
    cost: { signal: 5, memory_shard: 0 },
    balance_after: { signal: 95, memory_shard: 5 }
  },
  safety: { blocked: false, message: null }
};

// 검증
const result = safeParseTurnOutput(validOutput);
console.log("Success:", result.success);
console.log("Data:", result.success ? result.data : result.error);
```

**기대 결과**:

```
Success: true
Data: { language: "ko-KR", narrative: "...", ... }
```

**확인 포인트**:

- ✅ `result.success`가 `true`
- ✅ `result.data`에 파싱된 TurnOutput 객체 포함
- ✅ 기본값이 적용됨 (ui, world, render, agent_console)

---

### 시나리오 B: TurnOutput 스키마 검증 실패 → 폴백

**목적**: 유효하지 않은 데이터에서 폴백 TurnOutput이 반환되는지 검증

**실행**:

```javascript
const { safeParseTurnOutput } = await import('/src/schemas/turn.ts');

// 유효하지 않은 데이터 (economy 필드 누락)
const invalidOutput = {
  language: "ko-KR",
  narrative: "테스트"
  // economy 누락
  // safety 누락
};

const result = safeParseTurnOutput(invalidOutput);
console.log("Success:", result.success);
if (!result.success) {
  console.log("Error:", result.error.errors);
  console.log("Fallback:", result.fallback);
}
```

**기대 결과**:

```
Success: false
Error: [{ code: "invalid_type", path: ["economy"], ... }, { code: "invalid_type", path: ["safety"], ... }]
Fallback: { language: "ko-KR", narrative: "[시스템] 응답을 처리하는 중...", ... }
```

**확인 포인트**:

- ✅ `result.success`가 `false`
- ✅ `result.error`에 ZodError 포함
- ✅ `result.fallback`에 유효한 폴백 TurnOutput 포함
- ✅ 폴백의 `agent_console.badges`에 `"schema_fail"` 포함

---

### 시나리오 C: 좌표 범위 검증 (RULE-009)

**목적**: 0~1000 범위를 벗어나는 좌표가 거부되는지 검증

**실행**:

```javascript
const { Box2DSchema } = await import('/src/schemas/turn.ts');

// 유효한 좌표
const validBox = { ymin: 100, xmin: 200, ymax: 300, xmax: 400 };
console.log("Valid box:", Box2DSchema.safeParse(validBox).success);

// 범위 초과 좌표
const invalidBox = { ymin: 100, xmin: 200, ymax: 1500, xmax: 400 };
console.log("Invalid box (1500):", Box2DSchema.safeParse(invalidBox).success);

// 음수 좌표
const negativeBox = { ymin: -10, xmin: 200, ymax: 300, xmax: 400 };
console.log("Negative box:", Box2DSchema.safeParse(negativeBox).success);
```

**기대 결과**:

```
Valid box: true
Invalid box (1500): false
Negative box: false
```

**확인 포인트**:

- ✅ 0~1000 범위 내 좌표는 통과
- ✅ 1000 초과 값은 거부
- ✅ 음수 값은 거부

---

### 시나리오 D: 재화 인바리언트 검증 (RULE-005)

**목적**: 재화 값이 0 미만일 때 거부되는지 검증

**실행**:

```javascript
const { CurrencyAmountSchema } = await import('/src/schemas/turn.ts');

// 유효한 재화
const validCurrency = { signal: 100, memory_shard: 5 };
console.log("Valid currency:", CurrencyAmountSchema.safeParse(validCurrency).success);

// 음수 재화 (잔액 음수 금지 - RULE-005)
const negativeCurrency = { signal: -10, memory_shard: 5 };
console.log("Negative signal:", CurrencyAmountSchema.safeParse(negativeCurrency).success);
```

**기대 결과**:

```
Valid currency: true
Negative signal: false
```

**확인 포인트**:

- ✅ 0 이상의 재화는 통과
- ✅ 음수 재화는 거부 (RULE-005 준수)

---

### 시나리오 E: 언어 정책 검증 (RULE-006)

**목적**: 허용되지 않는 언어 코드가 거부되는지 검증

**실행**:

```javascript
const { LanguageSchema } = await import('/src/schemas/turn.ts');

console.log("ko-KR:", LanguageSchema.safeParse("ko-KR").success);
console.log("en-US:", LanguageSchema.safeParse("en-US").success);
console.log("ja-JP (invalid):", LanguageSchema.safeParse("ja-JP").success);
console.log("ko (invalid format):", LanguageSchema.safeParse("ko").success);
```

**기대 결과**:

```
ko-KR: true
en-US: true
ja-JP (invalid): false
ko (invalid format): false
```

**확인 포인트**:

- ✅ "ko-KR"과 "en-US"만 허용
- ✅ 다른 언어 코드는 거부 (RULE-006 준수)

---

### 시나리오 F: TurnInput 검증

**목적**: TurnInput 스키마가 클라이언트 입력을 올바르게 검증하는지 확인

**실행**:

```javascript
const { TurnInputSchema, parseTurnInput } = await import('/src/schemas/turn.ts');

// 유효한 TurnInput
const validInput = {
  language: "ko-KR",
  text: "문을 열어본다",
  client: {
    viewport_w: 1920,
    viewport_h: 1080,
    theme: "dark"
  },
  economy_snapshot: {
    signal: 100,
    memory_shard: 5
  }
};

try {
  const parsed = parseTurnInput(validInput);
  console.log("Parsed successfully:", parsed);
} catch (e) {
  console.log("Parse error:", e);
}
```

**기대 결과**:

```
Parsed successfully: { language: "ko-KR", text: "문을 열어본다", click: null, ... }
```

**확인 포인트**:

- ✅ 필수 필드가 모두 있으면 통과
- ✅ 선택 필드(click)에 기본값 null 적용
- ✅ theme에 기본값 "dark" 적용 (명시하지 않아도)

---

### 시나리오 G: Strict 모드 검증

**목적**: 정의되지 않은 추가 속성이 거부되는지 검증

**실행**:

```javascript
const { TurnOutputSchema } = await import('/src/schemas/turn.ts');

// 추가 속성 포함
const outputWithExtra = {
  language: "ko-KR",
  narrative: "테스트",
  economy: {
    cost: { signal: 0, memory_shard: 0 },
    balance_after: { signal: 100, memory_shard: 5 }
  },
  safety: { blocked: false },
  unknown_field: "이 필드는 스키마에 없음"
};

const result = TurnOutputSchema.safeParse(outputWithExtra);
console.log("With extra field:", result.success);
if (!result.success) {
  console.log("Error:", result.error.errors[0]);
}
```

**기대 결과**:

```
With extra field: false
Error: { code: "unrecognized_keys", keys: ["unknown_field"], ... }
```

**확인 포인트**:

- ✅ 추가 속성이 있으면 거부됨 (strict 모드)
- ✅ 에러 메시지에 인식되지 않은 키 정보 포함

---

## 4. 실행 결과 확인

### 4.1 로그 확인

- 위치: 브라우저 개발자 도구 콘솔
- 주요 로그 메시지:
  - `Success: true` - 검증 통과
  - `Success: false` - 검증 실패

### 4.2 생성 파일

- `frontend/src/schemas/turn.ts` - Zod 스키마 정의
- `frontend/src/schemas/index.ts` - 스키마 모듈 export

### 4.3 성공/실패 판단 기준

**성공**:

- ✅ `pnpm typecheck` 에러 없음
- ✅ `pnpm lint` 에러 없음
- ✅ 시나리오 A~G 모두 기대 결과와 일치

**실패 시 확인**:

- ❌ 타입 에러 → `frontend/src/schemas/turn.ts` 파일 확인
- ❌ 린트 에러 → ESLint 설정 확인
- ❌ 검증 실패 → Zod 스키마 정의 확인

---

## 5. 문제 해결 (Troubleshooting)

### 5.1 일반적인 오류

**오류**: `Module not found: zod`

- **원인**: Zod 패키지 미설치
- **해결**: `pnpm install` 실행

**오류**: `Type 'X' is not assignable to type 'Y'`

- **원인**: 스키마 정의와 타입 불일치
- **해결**: 스키마 정의 검토 후 타입 추론 확인

### 5.2 환경별 주의사항

- **Windows**: 경로 구분자 차이 없음 (ESM 모듈)
- **macOS/Linux**: 특이사항 없음

---

## 6. 다음 단계

- **U-008[Mvp]**: SSE 스트리밍 + Zod 검증 연동
- 실제 API 응답에 Zod 검증 적용
</file>

<file path="vibe/unit-runbooks/U-027-kill-port-limit-runbook.md">
# U-027 pnpm kill 포트 제한(8001~8020) 실행 가이드

## 1. 개요

`pnpm kill` 스크립트가 **node.exe 전체를 종료**하던 동작을 제거하고, **RULE-011 포트 정책(8001~8020)에 맞춰 해당 포트만 정리**하도록 변경했습니다.

이제 `pnpm kill`은 다른 프로젝트의 Node 프로세스에 영향을 주지 않으며, Unknown World 프로젝트의 개발 서버 포트만 안전하게 정리합니다.

**예상 소요 시간**: 5분

**의존성**:
- 의존 유닛: RU-001[Mvp] (포트 정책 RULE-011 정합화)
- 선행 완료 필요: 없음 (기존 `kill:port` 스크립트가 이미 존재)

---

## 2. 빠른 시작 (Quick Start)

### 2.1 환경 준비

```bash
# 프로젝트 루트에서 의존성 확인 (필요 시)
pnpm install
```

### 2.2 즉시 실행

```bash
# 8001~8020 포트 범위의 모든 프로세스 종료
pnpm kill
```

### 2.3 결과 확인

```bash
# 정리된 포트 확인
netstat -ano | grep -E "800[1-9]|801[0-9]|8020"
# 결과가 비어있으면 성공
```

---

## 3. 핵심 기능 시나리오

### 시나리오 A: 다른 프로젝트 프로세스 영향 없음 확인

**목적**: `pnpm kill`이 8001~8020 포트 대역 외의 Node 프로세스에 영향을 주지 않는지 검증

**전제 조건**:
- 8001~8020 대역 외의 포트에서 Node 프로세스가 실행 중이어야 함

**실행**:

1. **포트 대역 외에 테스트 서버 실행**:
```bash
node -e "require('http').createServer((req,res)=>{res.end('test')}).listen(9000, ()=>console.log('Test server on 9000'))"
```

2. **포트 9000 리스닝 확인**:
```bash
netstat -ano | grep 9000
# 예상: TCP 0.0.0.0:9000 LISTENING ...
```

3. **pnpm kill 실행**:
```bash
pnpm kill
```

4. **포트 9000 프로세스 생존 확인**:
```bash
netstat -ano | grep 9000
# 예상: 여전히 LISTENING 상태 (PID 동일)
```

**확인 포인트**:
- ✅ `pnpm kill` 실행 후에도 포트 9000의 프로세스가 살아있음
- ✅ 8001~8020 포트만 "Process on port XXXX killed" 메시지가 출력됨
- ✅ 다른 프로젝트의 Node 프로세스에 영향 없음

**정리**:
```bash
# 테스트 후 9000 포트 프로세스 수동 종료
npx --yes kill-port 9000
```

---

### 시나리오 B: 개발 서버 정리 확인

**목적**: 프론트엔드/백엔드 개발 서버가 `pnpm kill`로 정상 정리되는지 검증

**전제 조건**:
- 포트 8001~8020이 시스템 예약 포트가 아니어야 함 (Windows에서 Hyper-V 등으로 예약될 수 있음)

**실행 순서**:

1. **개발 서버 실행**:
```bash
# 터미널 1: 프론트엔드
pnpm dev:front

# 터미널 2: 백엔드
pnpm dev:back
```

2. **포트 리스닝 확인**:
```bash
netstat -ano | grep -E "8001|8011"
# 예상: 8001 (프론트), 8011 (백엔드) LISTENING
```

3. **pnpm kill 실행**:
```bash
pnpm kill
```

4. **포트 정리 확인**:
```bash
netstat -ano | grep -E "8001|8011"
# 예상: 결과 없음 (모두 종료됨)
```

**확인 포인트**:
- ✅ 프론트엔드 (8001) 프로세스 종료됨
- ✅ 백엔드 (8011) 프로세스 종료됨
- ✅ 개발 서버 재시작 가능

---

### 시나리오 C: 서브 스크립트 개별 테스트

**목적**: `kill:front`, `kill:back` 스크립트가 각각 의도한 포트 범위만 정리하는지 확인

**실행**:

```bash
# 프론트엔드 포트만 정리 (8001~8010)
pnpm kill:front

# 백엔드 포트만 정리 (8011~8020)
pnpm kill:back
```

**확인 포인트**:
- ✅ `kill:front`는 8001~8010 범위만 정리
- ✅ `kill:back`은 8011~8020 범위만 정리

---

## 4. 실행 결과 확인

### 4.1 콘솔 출력 예시

```
> unknown-world@0.1.0 kill D:\Dev\unknown-world
> npx --yes kill-port 8001 8002 ... 8020

Process on port 8001 killed
Process on port 8011 killed
...
```

### 4.2 성공/실패 판단 기준

**성공**:
- ✅ 8001~8020 포트의 프로세스만 종료됨
- ✅ 다른 포트(예: 3000, 5173, 9000)의 프로세스는 영향 없음
- ✅ `--yes` 옵션으로 npx 설치 확인 프롬프트 없이 실행됨

**실패 시 확인**:
- ❌ "Process on port XXXX killed" 메시지가 없음 → 해당 포트에 프로세스가 없었음 (정상)
- ❌ npx 프롬프트로 멈춤 → `--yes` 옵션이 누락되었는지 확인
- ❌ 권한 에러(EACCES) → Windows에서 포트 예약 상태 확인 필요

---

## 5. 문제 해결 (Troubleshooting)

### 5.1 일반적인 오류

**오류**: `npm warn Unknown env config ...`
- **원인**: npm 환경 설정 경고 (무시해도 무방)
- **해결**: 기능에 영향 없음, 무시

**오류**: `Error: listen EACCES: permission denied ::1:8001`
- **원인**: Windows에서 8001 포트가 시스템 예약됨 (Hyper-V 등)
- **해결**:
  1. 관리자 권한 PowerShell에서 예약 포트 확인:
     ```powershell
     netsh int ipv4 show excludedportrange protocol=tcp
     ```
  2. 예약 범위에 8001~8020이 포함되면:
     ```powershell
     # Hyper-V 비활성화 후 재부팅
     dism.exe /Online /Disable-Feature:Microsoft-Hyper-V
     # 또는 포트 대역 변경 검토
     ```

### 5.2 환경별 주의사항

- **Windows**: Hyper-V, WSL2 등이 동적 포트 범위를 예약할 수 있음. 위 EACCES 해결 참조.
- **macOS/Linux**: 일반적으로 8001~8020 포트 사용에 제약 없음

---

## 6. 스크립트 요약

| 스크립트 | 포트 범위 | 설명 |
|---------|----------|------|
| `pnpm kill` | 8001~8020 | 전체 개발 서버 포트 정리 (안전) |
| `pnpm kill:port` | 8001~8020 | `kill`과 동일 (별칭) |
| `pnpm kill:front` | 8001~8010 | 프론트엔드 포트만 정리 |
| `pnpm kill:back` | 8011~8020 | 백엔드 포트만 정리 |

**변경 사항** (U-027):
- 기존: `taskkill /IM node.exe` + `taskkill /IM uvicorn.exe` (광역 종료)
- 변경: `npx --yes kill-port 8001~8020` (포트 기반 정리)
</file>

<file path="vibe/unit-runbooks/U-028-ui-readability-runbook.md">
# U-028[Mvp] UI 가독성 패스 실행 가이드

## 1. 개요

현재 UI의 "작은 글씨/과한 CRT 효과"로 인한 가독성 문제를 해결하기 위해, **전역 UI 스케일(폰트)** 과 **Readable 모드(효과 완화)** 를 도입했습니다.

**주요 기능**:
- **UI 스케일 조절**: 0.9/1.0/1.1/1.2 배율로 전체 폰트 크기 조절 (A-/A+ 버튼)
- **Readable 모드**: 스캔라인/플리커/글로우 등 CRT 효과 완화 (READ 토글)
- **마이크로 텍스트 상향**: Agent Console/배지/타임스탬프 등 작은 텍스트 가독성 개선
- **설정 유지**: localStorage에 저장되어 새로고침 후에도 유지

**예상 소요 시간**: 5분

**의존성**:
- 의존 유닛: U-004 (CRT 테마/CSS SSOT), U-008 (Agent Console)
- 선행 완료 필요: 없음 (독립 실행 가능)

---

## 2. 빠른 시작 (Quick Start)

### 2.1 환경 준비

```bash
# 프론트엔드 의존성 설치
cd frontend
pnpm install
```

### 2.2 즉시 실행

```bash
# 개발 서버 시작
pnpm dev
```

### 2.3 첫 화면 확인

- 브라우저에서 `http://localhost:8001` 접속
- **Header 영역**에 다음 컨트롤이 표시되어야 함:
  - `A-` 버튼 (스케일 감소)
  - `100%` 표시 (현재 스케일)
  - `A+` 버튼 (스케일 증가)
  - `○ READ` 또는 `◉ READ` 토글 버튼

---

## 3. 핵심 기능 시나리오

### 시나리오 A: UI 스케일 조절

**목적**: 전역 폰트 크기가 스케일에 따라 변경되는지 확인

**실행**:
1. Header의 `A+` 버튼을 클릭
2. 표시가 `100%` → `110%` → `120%`로 변경됨을 확인
3. 모든 텍스트(내러티브, 패널 제목, 버튼 등)의 크기가 증가함을 확인
4. `A-` 버튼을 클릭하여 스케일 감소 확인
5. 최소값(90%)에서 `A-` 버튼이 비활성화됨을 확인
6. 최대값(120%)에서 `A+` 버튼이 비활성화됨을 확인

**기대 결과**:
- 스케일 표시: 90% / 100% / 110% / 120%
- 모든 텍스트 크기가 비례하여 변경
- 레이아웃이 깨지지 않음

**확인 포인트**:
- ✅ Header의 스케일 표시가 올바르게 변경
- ✅ 본문, 패널, 버튼 텍스트 크기가 동시에 변경
- ✅ Agent Console의 마이크로 텍스트도 스케일 적용
- ✅ 경계값에서 버튼 비활성화 정상 동작

---

### 시나리오 B: Readable 모드 토글

**목적**: CRT 효과가 완화되고 가독성이 향상되는지 확인

**실행**:
1. Header의 `○ READ` 버튼을 클릭
2. 버튼이 `◉ READ` (활성 상태)로 변경됨을 확인
3. 다음 효과가 비활성화됨을 확인:
   - 스캔라인 오버레이 (화면 전체의 수평선)
   - 타이틀 글리치 효과 (UNKNOWN WORLD 텍스트)
   - 텍스트 글로우/쉐도우
   - 애니메이션 펄스 효과 (상태 표시기)
4. 다시 클릭하여 원래 CRT 효과가 복원됨을 확인

**기대 결과**:
- Readable 모드 ON:
  - 스캔라인 없음
  - 글리치 효과 없음
  - 텍스트 쉐도우 없음
  - 패널 배경 약간 밝아짐 (대비 향상)
  - Agent Console 텍스트 더 크게 표시
- Readable 모드 OFF:
  - 모든 CRT 효과 복원

**확인 포인트**:
- ✅ 스캔라인 오버레이 표시/숨김 정상
- ✅ 타이틀 글리치 효과 활성화/비활성화
- ✅ 텍스트 글로우 제거/복원
- ✅ 버튼 aria-pressed 상태 정확

---

### 시나리오 C: 설정 유지 (localStorage persist)

**목적**: 설정이 새로고침 후에도 유지되는지 확인

**실행**:
1. UI 스케일을 `120%`로 설정
2. Readable 모드를 활성화
3. 브라우저를 새로고침 (F5 또는 Ctrl+R)
4. 설정이 유지되었는지 확인

**기대 결과**:
- 새로고침 후에도 스케일 `120%` 유지
- 새로고침 후에도 Readable 모드 활성 상태 유지

**확인 포인트**:
- ✅ localStorage에 `unknown-world-ui-prefs` 키 존재
- ✅ 새로고침 후 설정 복원
- ✅ 다른 탭에서도 동일 설정 적용

**localStorage 확인 방법** (개발자 도구):
```javascript
// Console에서 실행
JSON.parse(localStorage.getItem('unknown-world-ui-prefs'))
// 예상 결과: { state: { uiScale: 1.2, readableMode: true }, version: 0 }
```

---

### 시나리오 D: Agent Console 마이크로 텍스트 가독성

**목적**: Agent Console의 작은 텍스트가 읽기 쉬운지 확인

**실행**:
1. 기본 스케일(100%)에서 Agent Console 패널 확인
2. 단계 큐 (PARSE, VALIDATE, PLAN 등) 텍스트 가독성 확인
3. 배지 (Schema, Economy, Safety, Consistency) 텍스트 가독성 확인
4. Readable 모드를 활성화하고 텍스트 크기 변화 확인
5. 스케일을 120%로 변경하고 추가 확대 확인

**기대 결과**:
- 기본 상태: 최소 10px 이상 (가독 가능)
- Readable 모드: 약 12-14px (더 읽기 쉬움)
- 스케일 120%: 추가 20% 확대

**확인 포인트**:
- ✅ 단계 라벨 텍스트 가독 가능
- ✅ 배지 라벨/상태 텍스트 가독 가능
- ✅ 복구 트레이스 텍스트 가독 가능
- ✅ Readable 모드에서 추가 상향 적용

---

### 시나리오 E: 반응형 레이아웃 호환성

**목적**: 다양한 화면 크기에서 UI 컨트롤이 정상 동작하는지 확인

**실행**:
1. 브라우저 창 너비를 1200px 이상으로 설정 (데스크톱)
2. UI 컨트롤 정상 표시 확인
3. 창 너비를 768px~1200px로 조절 (태블릿)
4. UI 컨트롤 정상 표시 확인
5. 창 너비를 768px 이하로 조절 (모바일)
6. 기본 폰트가 14px로 축소되고 UI 컨트롤 유지 확인

**확인 포인트**:
- ✅ 모든 브레이크포인트에서 UI 컨트롤 접근 가능
- ✅ 모바일에서 기본 폰트 크기 축소 적용
- ✅ 스케일/Readable 설정이 모바일에서도 유효

---

## 4. 실행 결과 확인

### 4.1 DOM 속성 확인

개발자 도구에서 `<html>` 요소 확인:

```html
<!-- 기본 상태 -->
<html data-ui-scale="1" data-readable="false" style="--ui-scale-factor: 1;">

<!-- 스케일 120% + Readable 활성 -->
<html data-ui-scale="1.2" data-readable="true" style="--ui-scale-factor: 1.2;">
```

### 4.2 CSS 변수 확인

개발자 도구 Console에서:
```javascript
getComputedStyle(document.documentElement).getPropertyValue('--ui-scale-factor')
// 예상: "1" 또는 "1.2" 등
```

### 4.3 성공/실패 판단 기준

**성공**:
- ✅ UI 스케일 조절 시 모든 텍스트 크기 변경
- ✅ Readable 모드 토글 시 CRT 효과 완화/복원
- ✅ 설정이 localStorage에 저장되고 새로고침 후 복원
- ✅ Agent Console 마이크로 텍스트 가독성 개선
- ✅ 레이아웃 깨짐 없음

**실패 시 확인**:
- ❌ 스케일 변경 안 됨 → `--ui-scale-factor` CSS 변수 확인
- ❌ Readable 모드 작동 안 함 → `data-readable` 속성 확인
- ❌ 설정 유지 안 됨 → localStorage 키 확인
- ❌ 마이크로 텍스트 변화 없음 → `--font-size-xs` 변수 확인

---

## 5. 문제 해결 (Troubleshooting)

### 5.1 일반적인 오류

**오류**: UI 컨트롤이 Header에 표시되지 않음
- **원인**: App.tsx에서 UIControls 컴포넌트 렌더링 누락
- **해결**: GameHeader 컴포넌트에 UI 컨트롤 props 전달 확인

**오류**: 스케일 변경이 적용되지 않음
- **원인**: CSS 변수 `--ui-scale-factor`가 DOM에 설정되지 않음
- **해결**: `applyUIPrefsToDOM()` 함수 호출 확인, useEffect 의존성 배열 확인

**오류**: localStorage에 설정이 저장되지 않음
- **원인**: zustand persist 미들웨어 설정 오류
- **해결**: `uiPrefsStore.ts`의 persist 설정 확인

**오류**: Readable 모드에서 스캔라인이 계속 표시됨
- **원인**: CSS 선택자 `html[data-readable='true']` 불일치
- **해결**: data-readable 속성이 문자열 `"true"`/`"false"`로 설정되었는지 확인

### 5.2 환경별 주의사항

- **Windows**: 특이사항 없음
- **macOS/Linux**: 특이사항 없음
- **브라우저**: Chrome, Firefox, Edge에서 테스트됨. Safari에서 일부 CSS 변수 지원 확인 필요

---

## 6. 다음 단계

- **U-029**: nanobanana MCP 에셋 파이프라인 - 아이콘/배지의 스케일/Readable 연동 고려
- **SaveGame 통합**: `uiPrefsStore.getSerializableState()`를 통해 SaveGame JSON에 포함 가능
</file>

<file path="vibe/unit-runbooks/U-029-nanobanana-asset-runbook.md">
# U-029[Mvp] nanobanana mcp 에셋 패스 실행 가이드

## 1. 개요

UI에서 텍스트/이모지로 표현되던 요소들(Signal, Shard, Risk, Badge 등)을 **nanobanana mcp**로 제작한 이미지 에셋으로 반영했습니다. 폴백 패턴이 적용되어 이미지 로드 실패 시에도 이모지가 표시됩니다.

**예상 소요 시간**: 5분

**의존성**:
- 의존 유닛: U-030[Mvp] (에셋 SSOT), U-028[Mvp] (UI 가독성), U-008[Mvp] (Agent Console)
- 선행 완료 필요: 없음 (독립 실행 가능)

---

## 2. 빠른 시작 (Quick Start)

### 2.1 환경 준비

```bash
cd frontend
pnpm install
```

### 2.2 개발 서버 실행

```bash
pnpm dev --port 8001
```

### 2.3 첫 화면/결과 확인

- 브라우저에서 `http://localhost:8001` 접속
- 성공 지표:
  - "UNKNOWN WORLD" 헤더가 표시됨
  - Economy HUD에 Signal/Shard 영역이 보임
  - Action Deck에 3개 카드가 표시됨

---

## 3. 핵심 기능 시나리오

### 시나리오 A: 에셋 파일 확인

**목적**: 생성된 에셋 파일들이 올바른 위치에 있는지 확인

**실행**:

```bash
ls -la frontend/public/ui/icons/
```

**기대 결과**:

```
badge-fail-24.png
badge-ok-16.png
badge-ok-24.png
risk-medium-16.png
shard-24.png
signal-16.png
signal-24.png
status-online-16.png
```

**확인 포인트**:
- ✅ 최소 6개 이상의 에셋 파일 존재
- ✅ kebab-case 네이밍 규칙 준수
- ✅ PNG 포맷

---

### 시나리오 B: Economy HUD 아이콘 확인

**목적**: Signal/Shard 아이콘이 Economy HUD에 적용되었는지 확인

**실행**:
1. 브라우저에서 `http://localhost:8001` 접속
2. 화면 상단 우측 Economy HUD 영역 확인

**기대 결과**:
- Signal 아이콘 영역에 이미지 또는 ⚡ 이모지 표시
- Shard 아이콘 영역에 이미지 또는 💎 이모지 표시
- "Signal: 100", "Shard: 5" 텍스트 표시

**확인 포인트**:
- ✅ Economy HUD가 헤더에 표시됨
- ✅ 아이콘 영역이 존재함 (이미지 또는 이모지)
- ✅ 재화 수치가 정상 표시됨

---

### 시나리오 C: Action Deck 아이콘 확인

**목적**: Action Deck 카드에 Signal/Risk 아이콘이 적용되었는지 확인

**실행**:
1. 브라우저에서 화면 하단 Action Deck 영역 확인
2. 카드의 비용/위험 표시 확인

**기대 결과**:
- 각 카드에 Signal 비용 표시 (예: "1", "2")
- 각 카드에 Risk 레벨 표시 (예: "low", "medium")
- 아이콘 영역에 이미지 또는 ⚡/⚠ 이모지 표시

**확인 포인트**:
- ✅ 3개 기본 카드 표시
- ✅ 비용/위험 영역에 아이콘 래퍼 존재
- ✅ 이모지 폴백 동작 (이미지 로드 실패 시)

---

### 시나리오 D: 폴백 동작 확인

**목적**: 이미지 로드 실패 시 이모지 폴백이 동작하는지 확인

**실행**:
1. 개발자 도구(F12) 열기
2. Network 탭에서 이미지 요청 차단 또는
3. 아이콘 파일을 임시로 삭제/이동

```bash
# 임시로 아이콘 이동
mv frontend/public/ui/icons/signal-24.png frontend/public/ui/icons/signal-24.png.bak
```

4. 페이지 새로고침

**기대 결과**:
- Signal 아이콘 위치에 ⚡ 이모지가 표시됨
- UI가 깨지지 않고 정상 동작

**복원**:

```bash
mv frontend/public/ui/icons/signal-24.png.bak frontend/public/ui/icons/signal-24.png
```

**확인 포인트**:
- ✅ 이미지 로드 실패 시 이모지 표시
- ✅ UI 레이아웃 유지
- ✅ 기능 정상 동작

---

### 시나리오 E: manifest.json 확인

**목적**: 에셋 매니페스트가 올바르게 업데이트되었는지 확인

**실행**:

```bash
cat frontend/public/ui/manifest.json | head -30
```

**기대 결과**:

```json
{
  "$schema": "./manifest.schema.json",
  "version": "1.0.0",
  "assets": [
    {
      "id": "signal-24",
      "path": "icons/signal-24.png",
      ...
    }
  ]
}
```

**확인 포인트**:
- ✅ 8개 에셋 항목 존재
- ✅ 각 에셋에 fallback 정의
- ✅ usedIn 필드에 사용처 명시

---

## 4. 실행 결과 확인

### 4.1 생성 파일

| 파일 경로 | 목적 |
| --- | --- |
| `frontend/public/ui/icons/signal-24.png` | Signal 아이콘 (24px) |
| `frontend/public/ui/icons/signal-16.png` | Signal 아이콘 (16px) |
| `frontend/public/ui/icons/shard-24.png` | Memory Shard 아이콘 |
| `frontend/public/ui/icons/badge-ok-24.png` | OK 배지 아이콘 |
| `frontend/public/ui/icons/badge-ok-16.png` | OK 배지 아이콘 (16px) |
| `frontend/public/ui/icons/badge-fail-24.png` | Fail 배지 아이콘 |
| `frontend/public/ui/icons/risk-medium-16.png` | Risk 경고 아이콘 |
| `frontend/public/ui/icons/status-online-16.png` | 온라인 상태 아이콘 |

### 4.2 성능 지표

- 아이콘 파일 크기: 약 300-400KB (최적화 필요)
- 총 에셋 크기: 약 2.8MB (예산 1.5MB 초과, 후속 최적화 권장)

### 4.3 성공/실패 판단 기준

**성공**:
- ✅ 6개 이상의 에셋 파일 생성됨
- ✅ Economy HUD, Action Deck에 아이콘 적용됨
- ✅ 이모지 폴백 동작 확인됨
- ✅ manifest.json 업데이트됨

**실패 시 확인**:
- ❌ 아이콘이 안 보임 → 파일 경로 확인 (`/ui/icons/...`)
- ❌ 이모지도 안 보임 → CSS 클래스 확인 (`.icon-wrapper`, `.icon-fallback`)
- ❌ 개발 서버 오류 → `pnpm install` 재실행

---

## 5. 문제 해결 (Troubleshooting)

### 5.1 일반적인 오류

**오류**: 아이콘이 흰 박스로 표시됨

- **원인**: 흰 배경 이미지가 검정 CRT 배경에서 잘 안 보임
- **해결**: CSS `mix-blend-mode` 조정 또는 이모지 폴백 사용

**오류**: 이미지 파일을 찾을 수 없음

- **원인**: 파일 경로 오류
- **해결**: `/ui/icons/` 경로가 올바른지 확인

### 5.2 rembg 모델 선택

- **사용된 모델**: `birefnet-general` (제품/오브젝트용)
- `isnet-anime`는 캐릭터/일러스트용이므로 UI 아이콘에는 부적합
- 자세한 모델 선택 규칙: `vibe/ref/rembg-guide.md` 참조

### 5.3 후속 최적화 권장

- 이미지 크기 최적화 (TinyPNG 등)
- 24px 실제 해상도로 리사이즈
- 투명 배경 아이콘 개선 (프롬프트 조정 - 앱 아이콘 형태 금지)

---

## 6. 다음 단계

- **U-031**: 상태 Placeholder Pack 구축
- **U-033**: 에셋 매니페스트 자동화 및 QA 스크립트
- 이미지 최적화 (성능 예산 준수)

---

_마지막 업데이트: 2026-01-11_
</file>

<file path="vibe/unit-runbooks/U-030-asset-ssot-runbook.md">
# U-030[Mvp] nanobanana mcp 에셋 SSOT 실행 가이드

## 1. 개요

`nanobanana mcp`로 생성되는 UI/문서용 이미지 에셋의 **저장 위치/네이밍/사이즈/성능 예산/폴백/라이선스**를 프로젝트 SSOT로 정의했습니다. 이 런북은 정의된 규칙이 올바르게 설정되었는지 확인하고, 향후 에셋 추가 시 참조할 수 있는 가이드를 제공합니다.

**예상 소요 시간**: 5분

**의존성**:
- 의존 유닛: U-004[Mvp] (CRT 테마/고정 레이아웃)
- 선행 완료 필요: 없음 (독립적으로 검증 가능)

---

## 2. 빠른 시작 (Quick Start)

### 2.1 환경 준비

```bash
# 프로젝트 루트로 이동
cd d:/Dev/unknown-world

# 프론트엔드 의존성 설치 (이미 설치된 경우 생략)
pnpm -C frontend install
```

### 2.2 디렉토리 구조 확인

```bash
# SSOT 디렉토리 존재 확인
ls frontend/public/ui/

# 예상 출력:
# manifest.json
# manifest.schema.json
# README.md
```

### 2.3 프론트엔드 개발 서버 실행

```bash
# RULE-011: 포트 8001~8010 사용
pnpm -C frontend dev

# → http://localhost:8001 에서 접근 가능
```

---

## 3. 핵심 기능 시나리오

### 시나리오 A: SSOT 디렉토리 구조 검증

**목적**: 에셋 SSOT 경로와 필수 파일이 올바르게 생성되었는지 확인

**실행**:
```bash
# 디렉토리 구조 확인
tree frontend/public/ui/ 2>/dev/null || ls -la frontend/public/ui/
```

**기대 결과**:
```
frontend/public/ui/
├── manifest.json
├── manifest.schema.json
└── README.md
```

**확인 포인트**:
- ✅ `frontend/public/ui/` 디렉토리 존재
- ✅ `README.md` 파일 존재 (SSOT 규칙 문서)
- ✅ `manifest.schema.json` 파일 존재 (에셋 스키마)
- ✅ `manifest.json` 파일 존재 (에셋 목록, 초기 빈 상태)

---

### 시나리오 B: README.md 규칙 문서 검증

**목적**: SSOT 규칙 문서가 핵심 항목을 포함하는지 확인

**실행**:
```bash
# 핵심 섹션 존재 확인
grep -E "^## [0-9]+\." frontend/public/ui/README.md
```

**기대 결과**:
```
## 1. 핵심 원칙
## 2. 디렉토리 구조
## 3. 네이밍 규칙
## 4. 포맷 및 사이즈 규칙
## 5. 성능 예산
## 6. 스타일 가이드
## 7. 폴백 원칙 (필수)
## 8. 접근성 가이드
## 9. 에셋 제작 워크플로우
## 10. 매니페스트 관리
## 11. 라이선스
## 12. 체크리스트 (에셋 추가 시)
```

**확인 포인트**:
- ✅ Dev-only 원칙 (RULE-007) 명시
- ✅ 용어 SSOT (RULE-006) 명시
- ✅ 보안 규칙 (RULE-005) 명시
- ✅ 네이밍 규칙 (`kebab-case`) 정의
- ✅ 성능 예산 (개별/총합) 정의
- ✅ 폴백 원칙 및 예시 코드 포함

---

### 시나리오 C: manifest.schema.json 유효성 검증

**목적**: JSON Schema가 유효한지 확인

**실행**:
```bash
# JSON 문법 검증
node -e "console.log(JSON.parse(require('fs').readFileSync('frontend/public/ui/manifest.schema.json', 'utf8')).$id)"
```

**기대 결과**:
```
https://unknown-world.dev/schemas/ui-asset-manifest.json
```

**확인 포인트**:
- ✅ JSON 문법 오류 없음
- ✅ `$schema` 참조 포함
- ✅ `Asset` 정의 포함 (id, path, type 필수)
- ✅ 성능 예산 기본값 정의 (`budgetBytes: 1572864`)

---

### 시나리오 D: manifest.json 스키마 적합성 검증

**목적**: 초기 manifest.json이 스키마를 준수하는지 확인

**실행**:
```bash
# 기본 구조 확인
node -e "const m = JSON.parse(require('fs').readFileSync('frontend/public/ui/manifest.json', 'utf8')); console.log('version:', m.version, '| assets:', m.assets.length, '| budget:', m.budgetBytes)"
```

**기대 결과**:
```
version: 1.0.0 | assets: 0 | budget: 1572864
```

**확인 포인트**:
- ✅ `version` 필드 존재 (SemVer 형식)
- ✅ `assets` 배열 존재 (초기 빈 배열)
- ✅ `budgetBytes` 정의 (1.5MB)
- ✅ `$schema` 참조 포함

---

### 시나리오 E: CRT 테마 색상 참조 확인

**목적**: README.md가 style.css의 CRT 테마 색상을 올바르게 참조하는지 확인

**실행**:
```bash
# style.css의 CSS 변수와 README.md의 참조 비교
grep -E "^\s*--text-color:" frontend/src/style.css
grep "#33ff00" frontend/public/ui/README.md
```

**기대 결과**:
```
  --text-color: #33ff00; /* 주 텍스트: 인광 녹색 (CRT 그린) */
--text-color: #33ff00;    /* 인광 녹색 */
```

**확인 포인트**:
- ✅ CRT 인광 녹색 (`#33ff00`) 일치
- ✅ 배경색 (`#0d0d0d`) 일치
- ✅ 마젠타 (`#ff00ff`) 일치

---

### 시나리오 F: 브라우저에서 에셋 경로 접근 확인

**목적**: 정적 에셋이 브라우저에서 접근 가능한지 확인

**전제 조건**: 프론트엔드 개발 서버 실행 중

**실행**:
1. 브라우저에서 `http://localhost:8001/ui/README.md` 접근
2. 브라우저에서 `http://localhost:8001/ui/manifest.json` 접근

**기대 결과**:
- README.md 내용이 텍스트로 표시됨
- manifest.json 내용이 JSON으로 표시됨

**확인 포인트**:
- ✅ `/ui/` 경로로 정적 에셋 접근 가능
- ✅ CORS/보안 차단 없음

---

### 시나리오 G: PRD/Roadmap 문서 정합성 확인

**목적**: SSOT 규칙이 PRD 및 Roadmap과 일치하는지 확인

**실행**:
```bash
# PRD에서 nanobanana mcp 관련 섹션 확인
grep -A5 "9.7 UI 이미지 에셋 파이프라인" vibe/prd.md 2>/dev/null || grep "nanobanana mcp" vibe/prd.md | head -5

# Roadmap에서 U-030 상태 확인
grep "U-030" vibe/roadmap.md
```

**기대 결과**:
- PRD 9.7에 nanobanana mcp 에셋 파이프라인 규칙 존재
- Roadmap에 U-030 작업 항목 존재

**확인 포인트**:
- ✅ SSOT 경로 (`frontend/public/ui/`) 일치
- ✅ 네이밍 규칙 일치
- ✅ 성능 예산 일치
- ✅ Dev-only 원칙 일치

---

## 4. 실행 결과 확인

### 4.1 생성된 파일 목록

| 파일 | 목적 | 상태 |
|------|------|------|
| `frontend/public/ui/README.md` | SSOT 규칙 문서 | ✅ 생성됨 |
| `frontend/public/ui/manifest.schema.json` | 에셋 스키마 | ✅ 생성됨 |
| `frontend/public/ui/manifest.json` | 에셋 목록 (초기 빈 상태) | ✅ 생성됨 |

### 4.2 규칙 요약

| 항목 | 규칙 |
|------|------|
| SSOT 경로 | `frontend/public/ui/` |
| 네이밍 | `kebab-case` + 용도 + 크기 (예: `signal-24.png`) |
| 아이콘 포맷 | PNG (투명) |
| Placeholder 포맷 | WebP (Q1 결정: Option B) |
| 아이콘 예산 | 개별 20KB 이하, 필수 사이즈 16/24 |
| Placeholder 예산 | 개별 200KB 이하 |
| 총합 예산 | 1MB 이하 (권장), 1.5MB (상한) |
| 폴백 | 필수 (이모지/텍스트) |
| Dev-only | 런타임 MCP 의존 금지 |

### 4.3 성공/실패 판단 기준

**성공**:
- ✅ `frontend/public/ui/` 디렉토리 존재
- ✅ README.md에 12개 핵심 섹션 포함
- ✅ manifest.schema.json이 유효한 JSON Schema
- ✅ manifest.json이 스키마 준수
- ✅ CRT 테마 색상 참조 일치
- ✅ 브라우저에서 `/ui/` 경로 접근 가능

**실패 시 확인**:
- ❌ 디렉토리 없음 → `mkdir -p frontend/public/ui` 실행
- ❌ 파일 없음 → 해당 파일 재생성
- ❌ JSON 문법 오류 → JSON 검증 후 수정

---

## 5. 문제 해결 (Troubleshooting)

### 5.1 일반적인 오류

**오류**: `ENOENT: no such file or directory`
- **원인**: 디렉토리 또는 파일이 없음
- **해결**: `mkdir -p frontend/public/ui` 후 파일 재생성

**오류**: `SyntaxError: Unexpected token`
- **원인**: JSON 문법 오류
- **해결**: JSON 검증 도구로 확인 후 수정

**오류**: 브라우저에서 404
- **원인**: 개발 서버 미실행 또는 경로 오류
- **해결**: 
  1. `pnpm -C frontend dev` 실행
  2. `/ui/` 경로 확인 (Vite public 폴더 기준)

### 5.2 환경별 주의사항

- **Windows**: 경로 구분자 `/` 사용 (JSON 내)
- **macOS/Linux**: 특이사항 없음

---

## 6. 다음 단계

이 유닛 완료 후 다음 작업들이 U-030을 의존합니다:

- **U-029**: nanobanana mcp 에셋 패스 (아이콘/프레임/placeholder 실제 제작)
- **U-031**: 상태 Placeholder Pack
- **U-032**: UI Chrome Pack
- **U-033**: 에셋 매니페스트 + QA
- **U-034**: 에셋 요청 스키마 + 프롬프트 템플릿

---

_런북 버전: 1.0.0_
_작성일: 2026-01-10_
</file>

<file path="vibe/unit-runbooks/U-031-scene-placeholders-runbook.md">
# U-031[Mvp] Scene Canvas Placeholder Pack 실행 가이드

## 1. 개요

nanobanana mcp를 사용하여 Scene Canvas 및 주요 시스템 상태에 대한 게임스러운 placeholder 에셋을 제작하고 UI에 적용한 유닛입니다.

**구현 항목**:
- 4종 상태 placeholder 에셋: `loading`, `offline`, `blocked`, `low-signal`
- SceneCanvas 컴포넌트 (상태별 분기 렌더링)
- 텍스트 폴백 및 이미지 로드 실패 대응

**예상 소요 시간**: 5분

**의존성**:
- 의존 유닛: U-030 (에셋 SSOT), U-004 (Scene Canvas/UI 골격)
- 선행 완료 필요: 백엔드 실행 필요 (오프라인 상태 제외)

---

## 2. 빠른 시작 (Quick Start)

### 2.1 환경 준비

```bash
cd frontend
pnpm install
```

### 2.2 개발 서버 실행

```bash
pnpm run dev
```

### 2.3 브라우저 접속

- URL: http://localhost:8001/
- Scene Canvas에 기본 placeholder가 표시되어야 합니다

---

## 3. 핵심 기능 시나리오

### 시나리오 A: 기본(DEFAULT) 상태

**목적**: 초기 로딩 시 기본 placeholder 표시 확인

**실행**:
1. 브라우저에서 http://localhost:8001/ 접속

**기대 결과**:
- Scene Canvas에 CRT 스타일 풍경 placeholder 표시
- "📡 전역 데이터 동기화 대기 중..." 텍스트 오버레이

**확인 포인트**:
- ✅ placeholder 이미지가 로드됨 (`/ui/placeholders/scene-placeholder-default.png`)
- ✅ 텍스트 오버레이가 이미지 위에 표시됨
- ✅ CRT 테마 (인광 녹색, 스캔라인) 유지

---

### 시나리오 B: 로딩(LOADING) 상태

**목적**: 액션 실행 중 로딩 placeholder 표시 확인

**실행**:
1. 백엔드 서버 실행 (`cd backend && uv run uvicorn unknown_world.main:app --port 8000`)
2. 액션 카드(탐색하기 등) 클릭

**기대 결과**:
- Scene Canvas가 로딩 placeholder로 전환
- "⏳ 데이터 로딩 중..." 텍스트 표시
- Agent Console에 PROCESSING 상태 표시

**확인 포인트**:
- ✅ `/ui/placeholders/scene-loading.webp` 이미지 표시
- ✅ 스트리밍 완료 후 기본 상태로 복귀

---

### 시나리오 C: 오프라인(OFFLINE) 상태

**목적**: 백엔드 연결 실패 시 오프라인 placeholder 표시 확인

**전제 조건**:
- 백엔드 서버가 실행되지 않은 상태

**실행**:
1. 백엔드 서버 중지
2. 액션 카드 클릭 또는 페이지 새로고침

**기대 결과**:
- Scene Canvas에 오프라인 placeholder 표시
- "🔌 연결 끊김" 텍스트 표시
- HUD에 "OFFLINE" 상태 표시

**확인 포인트**:
- ✅ `/ui/placeholders/scene-offline.webp` 이미지 표시
- ✅ isConnected가 false로 전환됨

---

### 시나리오 D: 이미지 로드 실패 폴백

**목적**: placeholder 이미지 로드 실패 시 텍스트 폴백 표시 확인

**실행**:
1. 개발자 도구(F12) > Network 탭
2. WebP 파일 요청 차단
3. 페이지 새로고침

**기대 결과**:
- 이미지가 숨겨지고 텍스트만 표시
- 폴백 이모지 + 라벨 텍스트 유지

**확인 포인트**:
- ✅ `.scene-placeholder-img` 요소에 `hidden` 클래스 추가됨
- ✅ 텍스트 폴백이 가독성 있게 표시됨

---

### 시나리오 E: Readable 모드

**목적**: Readable 모드에서 placeholder 투명도 감소 확인

**실행**:
1. 헤더의 "◉ READ" 버튼 클릭하여 Readable 모드 토글

**기대 결과**:
- placeholder 이미지 투명도가 0.3으로 감소
- 텍스트 가독성 향상

**확인 포인트**:
- ✅ `html[data-readable='true']` 적용됨
- ✅ 이미지가 희미해지고 텍스트가 더 잘 보임

---

## 4. 에셋 파일 확인

### 4.1 생성된 에셋

| 파일명 | 크기 | 용도 |
|--------|------|------|
| `scene-loading.webp` | ~24KB | 로딩 상태 |
| `scene-offline.webp` | ~30KB | 오프라인 상태 |
| `scene-blocked.webp` | ~31KB | 차단 상태 |
| `scene-low-signal.webp` | ~10KB | 저신호 상태 |

### 4.2 에셋 검증

```bash
# 파일 크기 확인 (200KB 이하)
ls -lh frontend/public/ui/placeholders/scene-*.webp

# manifest.json 검증
cat frontend/public/ui/manifest.json | jq '.assets[] | select(.id | startswith("scene-"))'
```

---

## 5. 문제 해결 (Troubleshooting)

### 5.1 일반적인 오류

**오류**: placeholder 이미지가 표시되지 않음
- **원인**: 파일 경로 불일치 또는 파일 누락
- **해결**: `frontend/public/ui/placeholders/` 디렉토리 확인

**오류**: 스타일이 적용되지 않음
- **원인**: CSS 캐시 문제
- **해결**: 브라우저 강력 새로고침 (Ctrl+Shift+R)

**오류**: 상태 전환이 작동하지 않음
- **원인**: zustand 스토어 상태 불일치
- **해결**: React DevTools로 상태 확인

### 5.2 환경별 주의사항

- **Windows**: 경로 구분자 `/` 사용 필수 (URL 경로)
- **macOS/Linux**: 특이사항 없음

---

## 6. 코드 구조

### 6.1 주요 파일

- `frontend/src/App.tsx`:
  - `SceneCanvasStatus` enum 정의
  - `SCENE_PLACEHOLDERS` 매핑 객체
  - `SceneCanvas` 컴포넌트

- `frontend/src/style.css`:
  - `.scene-canvas` 스타일
  - `.scene-placeholder-img` / `.scene-placeholder-text` 스타일
  - 상태별 CSS 클래스

- `frontend/public/ui/manifest.json`:
  - 4종 placeholder 에셋 등록

### 6.2 상태 전환 로직

```
isStreaming=true  →  SceneCanvasStatus.LOADING
isConnected=false →  SceneCanvasStatus.OFFLINE
(기본)           →  SceneCanvasStatus.DEFAULT
```

> BLOCKED, LOW_SIGNAL 상태는 향후 에러 처리/API 응답에 따라 확장 예정
</file>

<file path="vibe/unit-runbooks/U-032-chrome-pack-runbook.md">
# U-032[Mvp] Chrome Pack(패널/카드 프레임/코너) 실행 가이드

## 1. 개요

`nanobanana mcp`로 제작한 UI Chrome 에셋(패널 코너 장식, 액션 카드 프레임)을 게임 UI에 적용하여 "게임스러움"을 강화했습니다. 에셋은 투명 PNG로 배경 제거(rembg)되었으며, CSS를 통해 Panel Header와 Action Card에 적용됩니다. Readable 모드에서는 Chrome 효과가 완화됩니다.

**예상 소요 시간**: 5분

**의존성**:

- 의존 유닛: U-030[Mvp] (에셋 SSOT), U-004[Mvp] (레이아웃), U-034[Mvp] (템플릿)
- 선행 완료 필요: 위 유닛들이 완료된 상태

---

## 2. 빠른 시작 (Quick Start)

### 2.1 환경 준비

```bash
cd frontend
pnpm install
```

### 2.2 즉시 실행

```bash
pnpm dev --port 8001
```

### 2.3 첫 화면 확인

- 브라우저에서 `http://localhost:8001` 접속
- 성공 지표: 오른쪽 사이드바 패널(Agent Console, Memory Pin, Scanner)에 코너 장식이 표시됨

---

## 3. 핵심 기능 시나리오

### 시나리오 A: Panel Header Chrome 확인

**목적**: 패널 헤더에 코너 장식이 적용되었는지 확인

**실행**:

1. 브라우저에서 `http://localhost:8001` 접속
2. 오른쪽 사이드바의 "Agent Console", "Memory Pin", "Scanner" 패널 확인

**기대 결과**:

- 패널 헤더 좌우 상단에 녹색 인광 코너 장식이 표시됨
- 패널 콘텐츠 좌우 하단에도 코너 장식이 표시됨
- 코너 장식에 녹색 글로우 효과가 적용됨

**확인 포인트**:

- ✅ 4개의 코너에 장식이 표시됨
- ✅ CSS transform으로 각 방향에 맞게 회전됨
- ✅ 글로우 효과(drop-shadow)가 적용됨

---

### 시나리오 B: Action Card Chrome 확인

**목적**: 액션 카드에 프레임 오버레이가 적용되었는지 확인

**실행**:

1. 화면 하단의 Action Deck 확인
2. "탐색하기", "조사하기", "대화하기" 카드 확인

**기대 결과**:

- 각 카드 주변에 녹색 프레임 오버레이가 표시됨
- 프레임에 글로우 효과가 적용됨

**확인 포인트**:

- ✅ 프레임이 카드 경계 밖으로 4px 확장됨
- ✅ 글로우 효과가 적용됨

---

### 시나리오 C: Chrome 호버 효과 확인

**목적**: 액션 카드 호버 시 Chrome 효과 강화 확인

**실행**:

1. 아무 액션 카드 위에 마우스를 올림

**기대 결과**:

- 카드 테두리가 마젠타(#ff00ff)로 변경됨
- Chrome 프레임의 글로우 효과가 마젠타로 강화됨 (opacity 1, 더 밝은 글로우)

**확인 포인트**:

- ✅ 호버 시 Chrome 프레임이 더 밝아짐
- ✅ 글로우 색상이 마젠타로 변경됨

---

### 시나리오 D: Readable 모드 연동 확인

**목적**: Readable 모드에서 Chrome 효과가 완화되는지 확인

**실행**:

1. 헤더의 "○ READ" 버튼 클릭하여 Readable 모드 활성화 ("◉ READ"로 변경)
2. 패널 코너 장식과 액션 카드 프레임 확인

**기대 결과**:

- Chrome 효과의 불투명도가 감소함 (0.3~0.4 수준)
- 글로우(drop-shadow) 효과가 제거됨
- CRT 스캔라인 오버레이가 사라짐

**확인 포인트**:

- ✅ Chrome 효과가 시각적으로 완화됨
- ✅ 가독성이 향상됨
- ✅ 버튼을 다시 클릭하면 Chrome 효과 복원

---

### 시나리오 E: 폴백 동작 확인

**목적**: 에셋 로딩 실패 시 기존 CSS 스타일로 폴백되는지 확인

**실행**:

1. 개발자 도구(F12) → Network 탭 열기
2. `/ui/chrome/panel-corner-br.png` 요청을 Block 처리
3. 페이지 새로고침

**기대 결과**:

- Chrome 에셋이 로드되지 않아도 패널 테두리(기본 CSS border)가 유지됨
- UI가 깨지지 않고 정상 표시됨

**확인 포인트**:

- ✅ 에셋 없이도 패널 기본 스타일 유지
- ✅ 사용자 경험에 치명적 영향 없음

---

## 4. 실행 결과 확인

### 4.1 생성 파일

- `frontend/public/ui/chrome/panel-corner-br.png` - 패널 코너 에셋 (투명 PNG)
- `frontend/public/ui/chrome/card-frame.png` - 카드 프레임 에셋 (투명 PNG)

### 4.2 수정 파일

- `frontend/src/style.css` - Chrome CSS 추가 (섹션 24)
- `frontend/src/App.tsx` - Panel에 `hasChrome` prop 적용, ActionCard에 `has-chrome` 클래스 추가
- `frontend/public/ui/manifest.json` - Chrome 에셋 등록

### 4.3 성공/실패 판단 기준

**성공**:

- ✅ Panel Header에 4방향 코너 장식 표시
- ✅ Action Card에 프레임 오버레이 표시
- ✅ 호버 시 Chrome 효과 강화
- ✅ Readable 모드에서 Chrome 완화
- ✅ 린트/타입 체크 통과

**실패 시 확인**:

- ❌ 에셋이 보이지 않음 → 파일 경로 및 CSS url() 확인
- ❌ 글로우 효과 없음 → filter: drop-shadow 지원 확인
- ❌ 호버 효과 없음 → :hover pseudo-class 및 z-index 확인

---

## 5. 문제 해결 (Troubleshooting)

### 5.1 일반적인 오류

**오류**: Chrome 에셋이 표시되지 않음

- **원인**: 파일 경로 오류 또는 서버 재시작 필요
- **해결**: 
  1. `frontend/public/ui/chrome/` 디렉토리에 파일 존재 확인
  2. 개발 서버 재시작: `pnpm dev --port 8001`

**오류**: 코너 장식 위치가 맞지 않음

- **원인**: CSS transform 회전 각도 오류
- **해결**: `style.css`의 `.panel-header.has-chrome::before/after` transform 값 확인

**오류**: Readable 모드에서 Chrome이 완전히 사라지지 않음

- **원인**: 정상 동작 (완화만 함, 완전 제거 아님)
- **해결**: 필요시 `html[data-readable='true']` 규칙에서 `display: none` 추가

---

## 6. 다음 단계

이 유닛을 기반으로 다음 작업을 진행할 수 있습니다:

1. **U-009**: Action Deck 실제 카드 렌더링 시 Chrome 프레임 활용
2. **U-022**: Scanner 슬롯에 별도 Chrome 에셋 적용 (선택)
3. **U-033**: manifest.json 자동화 및 QA 스크립트 확장
</file>

<file path="vibe/unit-runbooks/U-033-asset-qa-runbook.md">
# U-033[Mvp] 에셋 매니페스트 + QA 실행 가이드

## 1. 개요

nanobanana mcp로 생성한 에셋의 추적(매니페스트)과 품질 보장(QA 체크리스트)을 위한 시스템을 구축했습니다. 이 런북은 에셋 추가/수정 시 반드시 수행해야 할 QA 절차와 매니페스트 업데이트 방법을 안내합니다.

**예상 소요 시간**: 에셋당 5~10분

**의존성**:
- 의존 유닛: U-030[Mvp] - 에셋 SSOT/예산 규칙
- 선행 완료 필요: `frontend/public/ui/` 디렉토리 존재

---

## 2. 빠른 시작 (Quick Start)

### 2.1 환경 준비

```bash
# 프론트엔드 의존성 설치
pnpm -C frontend install
```

### 2.2 프론트엔드 서버 실행

```bash
# 개발 서버 시작
pnpm -C frontend dev
# → http://localhost:8001 에서 접근 가능
```

### 2.3 에셋 디렉토리 확인

```bash
# 에셋 파일 목록 확인
ls -la frontend/public/ui/icons/
ls -la frontend/public/ui/placeholders/
ls -la frontend/public/ui/chrome/
```

---

## 3. 핵심 기능 시나리오

### 시나리오 A: 매니페스트 정합성 검증

**목적**: manifest.json이 실제 파일과 일치하는지 확인

**실행 (PowerShell/Git Bash)**:

```bash
cd frontend/public/ui

# manifest.json에 있는 모든 path가 실제 파일로 존재하는지 확인
cat manifest.json | jq -r '.assets[].path' | while read p; do
  [ -f "$p" ] || echo "MISSING: $p"
done

# 실제 파일이 manifest.json에 등록되어 있는지 확인
find icons placeholders chrome -type f \( -name "*.png" -o -name "*.webp" \) | while read f; do
  grep -q "\"$f\"" manifest.json || echo "NOT IN MANIFEST: $f"
done
```

**기대 결과**:
- 출력 없음 = 정합성 OK
- `MISSING: ...` 또는 `NOT IN MANIFEST: ...` 출력 시 = 불일치 발생

**확인 포인트**:
- ✅ manifest.json의 모든 에셋 파일이 존재
- ✅ 실제 디렉토리의 모든 에셋이 manifest에 등록됨

---

### 시나리오 B: 용량 예산 검증

**목적**: 총 용량이 예산(1.5MB) 이하인지 확인

**실행**:

```bash
cd frontend/public/ui

# 총 용량 계산
find icons placeholders chrome -type f \( -name "*.png" -o -name "*.webp" \) \
  -exec stat --format='%s' {} \; | awk '{sum+=$1} END {print "Total:", sum, "bytes (" sum/1024 " KB)"}'

# manifest.json 확인
cat manifest.json | jq '{totalBytes, budgetBytes, usage_percent: (.totalBytes / .budgetBytes * 100 | round)}'
```

**기대 결과**:
```
{
  "totalBytes": 556534,
  "budgetBytes": 1572864,
  "usage_percent": 35
}
```

**확인 포인트**:
- ✅ `totalBytes` < `budgetBytes` (1,572,864 bytes = 1.5MB)
- ✅ 사용량 35% 이하 권장 (1MB 이하 = 67%)

---

### 시나리오 C: 개별 에셋 용량 검증

**목적**: 개별 에셋이 유형별 상한을 초과하지 않는지 확인

**실행**:

```bash
cd frontend/public/ui

# 아이콘 (상한 30KB)
echo "=== Icons (max 30KB) ===" && ls -la icons/*.png | awk '{if($5 > 30720) print "OVER:", $9, $5, "bytes"}'

# placeholder (상한 300KB)
echo "=== Placeholders (max 300KB) ===" && ls -la placeholders/*.{png,webp} 2>/dev/null | awk '{if($5 > 307200) print "OVER:", $9, $5, "bytes"}'

# chrome (상한 50KB)
echo "=== Chrome (max 50KB) ===" && ls -la chrome/*.png | awk '{if($5 > 51200) print "OVER:", $9, $5, "bytes"}'
```

**기대 결과**:
- 출력 없음 = 예산 준수
- `OVER: ...` 출력 시 = 해당 에셋 최적화 필요

**현재 알려진 이슈**:
- `scene-placeholder-default.png` (261KB) - PNG 포맷으로 예산 초과 없으나 WebP 변환 권장
- `scanner-frame.png` (100KB) - chrome 상한(50KB) 초과 → 최적화 권장

---

### 시나리오 D: 에셋 로드 및 폴백 테스트

**목적**: 브라우저에서 에셋이 정상 로드되고, 실패 시 폴백이 표시되는지 확인

**실행 순서**:

1. **프론트엔드 서버 시작**:
   ```bash
   pnpm -C frontend dev
   ```

2. **브라우저에서 확인** (http://localhost:8001):
   - Signal/Shard 아이콘이 Economy HUD에 표시됨
   - Action Deck에 risk 아이콘이 표시됨
   - Scene Canvas에 placeholder 이미지가 표시됨
   - Scanner 영역에 frame이 표시됨

3. **폴백 테스트** (개발자 도구에서):
   ```javascript
   // 존재하지 않는 이미지 로드 테스트
   const img = document.createElement('img');
   img.src = '/ui/icons/nonexistent.png';
   img.onerror = () => console.log('Fallback triggered!');
   document.body.appendChild(img);
   ```

4. **실제 폴백 테스트** (파일 임시 이동):
   ```bash
   # 아이콘 파일 임시 이름 변경
   mv frontend/public/ui/icons/signal-24.png frontend/public/ui/icons/signal-24.png.bak

   # 브라우저 새로고침 → 폴백 이모지 ⚡ 표시 확인

   # 파일 복원
   mv frontend/public/ui/icons/signal-24.png.bak frontend/public/ui/icons/signal-24.png
   ```

**기대 결과**:
- 에셋 파일 존재 시: 이미지 표시
- 에셋 파일 미존재 시: 폴백 이모지/텍스트 표시 (예: ⚡, 💎, ⚠)

**확인 포인트**:
- ✅ 이미지 로드 시 콘솔 에러 없음
- ✅ 이미지 미존재 시 폴백 표시, UI 깨짐 없음

---

### 시나리오 E: 16px 실루엣 테스트 (아이콘)

**목적**: 16px 아이콘이 작은 크기에서도 형태가 구분되는지 확인

**실행**:

1. 브라우저에서 http://localhost:8001 접속
2. DevTools > Elements > Styles에서 아이콘 크기를 16px로 강제:
   ```css
   .icon-img { width: 16px !important; height: 16px !important; }
   ```
3. 각 아이콘의 형태가 구분되는지 육안 확인
4. 특히 `risk-low-16.png`, `risk-high-16.png`, `risk-medium-16.png`가 서로 구분되는지 확인

**확인 포인트**:
- ✅ 16px에서 아이콘 실루엣 구분 가능
- ✅ 다른 아이콘과 혼동되지 않음

---

## 4. QA 체크리스트 사용법

### 4.1 체크리스트 위치

```
frontend/public/ui/QA_CHECKLIST.md
```

### 4.2 에셋 추가 시 체크 순서

1. **네이밍 규칙** 확인 (`kebab-case` + 용도 + 크기)
2. **포맷 규칙** 확인 (아이콘=PNG, placeholder=WebP)
3. **(조건부) 배경 제거** 실행 (rembg)
4. **용량 예산** 확인 (개별 + 총합)
5. **16px 실루엣** 확인 (아이콘)
6. **대비/Readable** 확인
7. **폴백 텍스트** 지정
8. **manifest.json** 업데이트

### 4.3 manifest.json 업데이트 예시

```json
{
  "id": "new-icon-24",
  "path": "icons/new-icon-24.png",
  "type": "icon",
  "size": 24,
  "fallback": "🆕",
  "usedIn": ["ComponentName"],
  "bytes": 1234,
  "notes": "nanobanana mcp 생성, rembg 배경 제거"
}
```

---

## 5. 문제 해결 (Troubleshooting)

### 5.1 일반적인 오류

**오류**: 이미지가 로드되지 않음 (404)
- **원인**: path 경로 불일치 또는 파일 미존재
- **해결**: manifest.json의 path와 실제 파일 경로 확인

**오류**: 폴백이 표시되지 않음
- **원인**: `icon-fallback` 클래스 또는 CSS 누락
- **해결**: `onError` 핸들러와 CSS 규칙 확인

**오류**: 용량 초과 경고
- **원인**: 에셋 최적화 미흡
- **해결**: ImageMagick, TinyPNG 등으로 압축 또는 WebP 변환

### 5.2 배경 제거 관련

**오류**: rembg로 배경 제거 후 경계가 거침
- **원인**: 원본 배경이 복잡함 (그라데이션/텍스처)
- **해결**: 원본 생성 시 순백(#FFFFFF) 배경으로 재생성

**참조**: `vibe/ref/rembg-guide.md`

---

## 6. 성공/실패 판단 기준

**성공**:
- ✅ manifest.json 정합성 100% (누락/불일치 없음)
- ✅ 총 용량 1.5MB 이하
- ✅ 개별 에셋 유형별 상한 준수
- ✅ 브라우저에서 에셋 로드 성공
- ✅ 폴백 동작 정상

**실패 시 확인**:
- ❌ 정합성 불일치 → manifest.json 업데이트 또는 파일 추가/제거
- ❌ 용량 초과 → 에셋 최적화 (압축/WebP 변환/해상도 축소)
- ❌ 로드 실패 → 경로/파일명 확인
- ❌ 폴백 미동작 → CSS/JS 코드 확인

---

## 7. 참고 자료

- **SSOT 규칙**: `frontend/public/ui/README.md`
- **QA 체크리스트**: `frontend/public/ui/QA_CHECKLIST.md`
- **매니페스트 스키마**: `frontend/public/ui/manifest.schema.json`
- **배경 제거 가이드**: `vibe/ref/rembg-guide.md`
- **의존 유닛 보고서**: `vibe/unit-results/U-030[Mvp].md`
</file>

<file path="vibe/unit-runbooks/U-034-nanobanana-template-runbook.md">
# U-034[Mvp] nanobanana mcp 에셋 요청 스키마 + 프롬프트 템플릿 실행 가이드

## 1. 개요

`nanobanana mcp`로 에셋을 만들 때 **재현성**을 높이기 위해 **에셋 요청 스키마(JSON) + 프롬프트 템플릿**을 정의했습니다.
이 런북에서는 정의된 스키마/템플릿을 사용하여 실제로 에셋을 생성하는 과정을 검증합니다.

**예상 소요 시간**: 15분

**의존성**:
- 의존 유닛: U-030[Mvp] (에셋 SSOT/예산/규칙)
- 선행 완료 필요: U-030 런북 실행 완료

---

## 2. 빠른 시작 (Quick Start)

### 2.1 환경 준비

```bash
# rembg 설치 확인 (배경 제거 도구)
pip show rembg || pip install rembg

# rembg 모델 다운로드 (첫 실행 시)
rembg d isnet-anime
```

### 2.2 의존 유닛 확인

```bash
# U-030에서 생성된 에셋 SSOT 구조 확인
ls -la frontend/public/ui/

# 예상 결과:
# README.md
# manifest.json
# manifest.schema.json
```

### 2.3 산출물 확인

```bash
# 스키마 파일 확인
cat vibe/ref/nanobanana-asset-request.schema.json | head -20

# 가이드 문서 확인
head -50 vibe/ref/nanobanana-mcp.md
```

---

## 3. 핵심 기능 시나리오

### 시나리오 A: 에셋 요청 스키마 유효성 검증

**목적**: JSON 스키마가 유효하고 예상 필드를 포함하는지 확인

**실행**:

```bash
# JSON 유효성 확인 (jq 사용)
cat vibe/ref/nanobanana-asset-request.schema.json | jq '.'

# 필수 필드 확인
cat vibe/ref/nanobanana-asset-request.schema.json | jq '.required'
```

**기대 결과**:

```json
["id", "category", "purpose", "size_px"]
```

**확인 포인트**:

- ✅ JSON 파싱 성공 (문법 오류 없음)
- ✅ 필수 필드 4개 존재 (`id`, `category`, `purpose`, `size_px`)
- ✅ `category` enum에 `icon`, `placeholder`, `chrome` 포함
- ✅ `rembg_model` 필드 존재 (배경 제거 모델 선택)

---

### 시나리오 B: 프롬프트 템플릿 확인

**목적**: 가이드 문서에 카테고리별 프롬프트 템플릿이 정의되어 있는지 확인

**실행**:

```bash
# 템플릿 섹션 확인
grep -n "TEMPLATE" vibe/ref/nanobanana-mcp.md

# 공통 아트 디렉션 헤더 확인
grep -A 10 "STYLE HEADER" vibe/ref/nanobanana-mcp.md
```

**기대 결과**:

```
# 템플릿 종류
[ICON TEMPLATE v1]
[PLACEHOLDER TEMPLATE v1]
[CHROME TEMPLATE v1]

# 공통 헤더
[STYLE HEADER v1]
CRT 레트로 터미널 스타일.
1980년대 인광 녹색(#33ff00) CRT 모니터 미학.
...
```

**확인 포인트**:

- ✅ 공통 스타일 헤더 (`STYLE HEADER v1`) 존재
- ✅ 배경 규칙 (`BACKGROUND RULE - rembg 전제`) 존재
- ✅ 카테고리별 템플릿 3종 (`ICON`, `PLACEHOLDER`, `CHROME`)

---

### 시나리오 C: nanobanana mcp 에셋 생성 테스트 (아이콘)

**목적**: 프롬프트 템플릿을 사용하여 실제로 아이콘을 생성하고 rembg로 배경 제거

**실행 순서**:

1. **Step 1**: nanobanana mcp로 아이콘 생성

   Cursor에서 nanobanana mcp 도구 호출:

   ```
   도구: mcp_nanobanana_generate_icon
   
   prompt: "CRT 레트로 터미널 스타일. 1980년대 인광 녹색(#33ff00) CRT 모니터 미학. 24x24 픽셀 아이콘. 안테나/전파 실루엣. 단순한 형태, 높은 대비. solid white background (#FFFFFF), no gradient/texture/shadow."
   type: "app-icon"
   sizes: [24, 64]
   style: "minimal"
   background: "white"
   format: "png"
   ```

   - 결과: 아이콘 이미지 파일 생성됨

2. **Step 2**: rembg로 배경 제거

   ```bash
   # 생성된 아이콘에 rembg 적용
   rembg i -m isnet-anime [생성된_파일경로].png frontend/public/ui/icons/signal-24.png
   ```

   - 결과: 투명 배경 PNG 생성됨

3. **Step 3**: 결과 확인

   ```bash
   # 파일 생성 확인
   ls -la frontend/public/ui/icons/

   # 파일 크기 확인 (30KB 이하 권장)
   du -h frontend/public/ui/icons/signal-24.png
   ```

   - 최종 산출물: 투명 배경 아이콘 PNG

**확인 포인트**:

- ✅ 아이콘 이미지 생성 성공
- ✅ rembg 배경 제거 성공 (투명 배경)
- ✅ 파일 크기 30KB 이하
- ✅ 인광 녹색 톤 유지

---

### 시나리오 D: Placeholder 생성 테스트

**목적**: placeholder 템플릿으로 상태 이미지 생성

**실행**:

```
도구: mcp_nanobanana_generate_image

prompt: "CRT 레트로 터미널 스타일. 1980년대 인광 녹색(#33ff00) CRT 모니터 미학. 스캔라인 느낌. 로딩 상태를 시각화. 512x384 픽셀. 미스터리한 분위기. 글리치 효과."
styles: ["vintage", "pixel-art"]
```

**기대 결과**:

- 레트로 스타일의 로딩 placeholder 이미지 생성

**확인 포인트**:

- ✅ 이미지 생성 성공
- ✅ CRT/레트로 톤 유지
- ✅ 텍스트 렌더링 없음 (또는 최소화)

---

## 4. 실행 결과 확인

### 4.1 생성된 파일

| 파일 경로 | 용도 |
|-----------|------|
| `vibe/ref/nanobanana-asset-request.schema.json` | 에셋 요청 스키마 |
| `vibe/ref/nanobanana-mcp.md` | 개발용 에셋 제작 가이드 |

### 4.2 스키마 주요 필드

| 필드 | 타입 | 필수 | 설명 |
|------|------|------|------|
| `id` | string | ✅ | 에셋 고유 ID (kebab-case) |
| `category` | enum | ✅ | icon/placeholder/chrome |
| `purpose` | string | ✅ | 에셋 용도 |
| `size_px` | int/object | ✅ | 크기 |
| `palette` | string[] | - | CRT 팔레트 |
| `background` | enum | - | transparent/solid_white/solid_black |
| `requires_rembg` | boolean | - | rembg 필요 여부 |
| `rembg_model` | enum | - | rembg 모델 선택 |

### 4.3 성공/실패 판단 기준

**성공**:

- ✅ 스키마 JSON 유효
- ✅ 카테고리별 프롬프트 템플릿 3종 정의
- ✅ 공통 아트 디렉션 헤더 정의
- ✅ rembg 배경 제거 절차 문서화
- ✅ U-030(SSOT) 및 U-033(매니페스트)와 연결 명시

**실패 시 확인**:

- ❌ 스키마 파싱 오류 → JSON 문법 수정
- ❌ 템플릿 섹션 누락 → 가이드 문서 보완
- ❌ rembg 명령 실패 → 모델 다운로드 (`rembg d isnet-anime`)

---

## 5. 문제 해결 (Troubleshooting)

### 5.1 일반적인 오류

**오류**: `rembg: command not found`

- **원인**: rembg 미설치
- **해결**: `pip install rembg`

**오류**: `Model not found: isnet-anime`

- **원인**: 모델 미다운로드
- **해결**: `rembg d isnet-anime`

**오류**: JSON 스키마 파싱 실패

- **원인**: JSON 문법 오류
- **해결**: `jq '.' < file.json`으로 오류 위치 확인

### 5.2 환경별 주의사항

- **Windows**: 경로에 한글 포함 시 rembg 오류 가능 → 영문 경로 사용
- **macOS/Linux**: 특이사항 없음

---

## 6. 다음 단계

이 유닛을 기반으로 다음 작업에서 활용합니다:

1. **U-029**: 아이콘/프레임/placeholder 에셋 제작 시 이 템플릿 사용
2. **U-031**: 상태 Placeholder Pack 제작 시 PLACEHOLDER TEMPLATE 사용
3. **U-032**: UI Chrome Pack 제작 시 CHROME TEMPLATE 사용
4. **U-033**: 생성된 에셋을 manifest.json에 등록

---

_런북 버전: 1.0.0_
_작성일: 2026-01-11_
</file>

<file path="backend/src/unknown_world/api/turn_stream_events.py">
"""Unknown World - Turn Stream 이벤트 계약(Contract).

NDJSON 스트리밍에서 사용되는 이벤트 타입, 모델, 유틸리티를 정의합니다.
이 모듈은 Orchestrator ↔ API ↔ Frontend 간의 스트림 이벤트 계약 SSOT입니다.

설계 원칙:
    - RU-002-Q4: 이벤트 계약을 transport 계층으로 분리
    - RULE-003: 구조화 출력(JSON Schema) 우선 + Pydantic 검증
    - RULE-008: 단계/배지 가시화

참조:
    - vibe/unit-plans/U-007[Mvp].md
    - vibe/refactors/RU-002-Q4.md
"""

from __future__ import annotations

import json
from typing import Annotated, Any

from pydantic import BaseModel, Field

# =============================================================================
# 스트림 이벤트 타입 상수
# =============================================================================


class StreamEventType:
    """스트림 이벤트 타입 상수.

    NDJSON 스트리밍에서 사용되는 이벤트 타입입니다.
    PRD 예시 단계: Parse→Validate→Plan→Resolve→Render→Verify→Commit
    """

    STAGE = "stage"
    BADGES = "badges"
    NARRATIVE_DELTA = "narrative_delta"
    FINAL = "final"
    ERROR = "error"
    REPAIR = "repair"


class StageStatus:
    """단계 상태 상수."""

    START = "start"
    COMPLETE = "complete"
    FAIL = "fail"


# =============================================================================
# 스트림 이벤트 모델 (Pydantic)
# =============================================================================


class StageEvent(BaseModel):
    """단계 진행 이벤트.

    Attributes:
        type: 이벤트 타입 ("stage")
        name: 단계 이름 (Parse, Validate, Plan, Resolve, Render, Verify, Commit)
        status: 상태 (start, complete)
    """

    type: Annotated[str, Field(default=StreamEventType.STAGE)]
    name: str
    status: str


class RepairEvent(BaseModel):
    """자동 복구(Repair) 이벤트.

    Attributes:
        type: 이벤트 타입 ("repair")
        attempt: 현재 시도 횟수
        message: 복구 메시지 (선택)
    """

    type: Annotated[str, Field(default=StreamEventType.REPAIR)]
    attempt: int
    message: str | None = None


class BadgesEvent(BaseModel):
    """배지 이벤트.

    Attributes:
        type: 이벤트 타입 ("badges")
        badges: 검증 배지 목록
    """

    type: Annotated[str, Field(default=StreamEventType.BADGES)]
    badges: list[str]


class NarrativeDeltaEvent(BaseModel):
    """내러티브 델타 이벤트 (타자 효과용).

    Attributes:
        type: 이벤트 타입 ("narrative_delta")
        text: 추가된 텍스트 조각
    """

    type: Annotated[str, Field(default=StreamEventType.NARRATIVE_DELTA)]
    text: str


class FinalEvent(BaseModel):
    """최종 TurnOutput 이벤트.

    Attributes:
        type: 이벤트 타입 ("final")
        data: 완전한 TurnOutput

    Note:
        TurnOutput은 TYPE_CHECKING 블록에서 import되며,
        런타임에는 Any로 처리됩니다.
    """

    type: Annotated[str, Field(default=StreamEventType.FINAL)]
    data: Any  # TurnOutput (순환 import 방지)


class ErrorEvent(BaseModel):
    """에러 이벤트.

    Attributes:
        type: 이벤트 타입 ("error")
        message: 에러 메시지 (프롬프트/내부 추론 노출 금지)
        code: 에러 코드 (선택)
    """

    type: Annotated[str, Field(default=StreamEventType.ERROR)]
    message: str
    code: str | None = None


# =============================================================================
# 유틸리티 함수
# =============================================================================


def serialize_event(event: dict[str, Any]) -> str:
    """이벤트를 NDJSON 라인으로 직렬화합니다.

    Args:
        event: 직렬화할 이벤트 딕셔너리

    Returns:
        str: NDJSON 형식 문자열 (줄바꿈 포함)
    """
    return json.dumps(event, ensure_ascii=False) + "\n"


# =============================================================================
# 모듈 공개 API
# =============================================================================

__all__ = [
    "StreamEventType",
    "StageStatus",
    "StageEvent",
    "RepairEvent",
    "BadgesEvent",
    "NarrativeDeltaEvent",
    "FinalEvent",
    "ErrorEvent",
    "serialize_event",
]
</file>

<file path="backend/tests/integration/test_turn_streaming.py">
"""Unknown World - /api/turn HTTP Streaming 통합 테스트.

NDJSON 스트리밍 이벤트의 순서, 구조, 데이터 정밀도를 검증합니다.
"""

import json

from fastapi.testclient import TestClient

from unknown_world.main import app
from unknown_world.models.turn import Language, TurnOutput

client = TestClient(app)


def test_turn_streaming_success():
    """정상적인 턴 요청 시 NDJSON 스트림이 올바른 순서로 반환되는지 테스트합니다."""
    payload = {
        "language": "ko-KR",
        "text": "테스트 입력",
        "client": {"viewport_w": 1920, "viewport_h": 1080, "theme": "dark"},
        "economy_snapshot": {"signal": 100, "memory_shard": 5},
    }

    # StreamingResponse 테스트
    response = client.post("/api/turn", json=payload)
    assert response.status_code == 200
    assert response.headers["content-type"] == "application/x-ndjson"

    events = []
    for line in response.iter_lines():
        if line:
            events.append(json.loads(line))

    # 1. 이벤트 존재 여부 확인
    assert len(events) > 0

    # 2. 첫 번째 이벤트는 항상 stage: parse: start 여야 함 (TTFB)
    assert events[0]["type"] == "stage"
    assert events[0]["name"] == "parse"
    assert events[0]["status"] == "start"

    # 3. 단계별 이벤트 순서 확인
    stages = [e["name"] for e in events if e["type"] == "stage" and e["status"] == "start"]
    expected_stages = ["parse", "validate", "plan", "resolve", "render", "verify", "commit"]
    assert stages == expected_stages

    # 4. 배지 이벤트 포함 여부 확인
    badges_events = [e for e in events if e["type"] == "badges"]
    assert len(badges_events) >= 2
    assert "schema_ok" in badges_events[0]["badges"]

    # 5. 최종 결과물 확인
    final_events = [e for e in events if e["type"] == "final"]
    assert len(final_events) == 1

    turn_output_data = final_events[0]["data"]
    # Pydantic 모델로 다시 검증 (RULE-003)
    turn_output = TurnOutput.model_validate(turn_output_data)
    assert turn_output.language == Language.KO
    assert len(turn_output.narrative) > 0


def test_turn_streaming_invalid_input():
    """잘못된 입력 요청 시 에러 이벤트가 스트리밍되는지 테스트합니다."""
    payload = {
        "language": "invalid-lang",  # 잘못된 언어 코드
        "text": "",
    }

    response = client.post("/api/turn", json=payload)
    # 입력 검증 실패 시에도 200 OK 스트림으로 에러를 보낼 수도 있고,
    # 400 Bad Request를 보낼 수도 있음. 현재 구현은 200 OK + type: error 임.
    assert response.status_code == 200

    events = [json.loads(line) for line in response.iter_lines() if line]
    assert any(e["type"] == "error" for e in events)
    assert any(e["code"] == "VALIDATION_ERROR" for e in events)


def test_turn_streaming_deterministic_seed():
    """seed 파라미터 사용 시 결과가 결정적인지 테스트합니다."""
    payload = {
        "language": "en-US",
        "text": "Hello",
        "client": {"viewport_w": 1920, "viewport_h": 1080},
        "economy_snapshot": {"signal": 100, "memory_shard": 5},
    }

    # 동일한 시드로 두 번 요청
    seed = 12345

    def get_final_output(s):
        resp = client.post(f"/api/turn?seed={s}", json=payload)
        events = [json.loads(line) for line in resp.iter_lines() if line]
        return next(e["data"] for e in events if e["type"] == "final")

    output1 = get_final_output(seed)
    output2 = get_final_output(seed)

    assert output1 == output2
    assert output1["language"] == "en-US"


def test_turn_streaming_generation_fallback(monkeypatch):
    """생성 중 ValidationError 발생 시 안전한 폴백이 반환되는지 테스트합니다."""
    from pydantic import ValidationError

    from unknown_world.orchestrator.mock import MockOrchestrator

    def mock_generate_failure(self, turn_input):
        # Pydantic ValidationError를 수동으로 생성하는 것은 복잡하므로
        # 간단한 필드 검증 오류를 시뮬레이션하거나 직접 raise 함
        # 여기서는 테스트를 위해 임의의 필드 누락 등으로 발생한다고 가정
        raise ValidationError.from_exception_data(title="MockError", line_errors=[])

    monkeypatch.setattr(MockOrchestrator, "generate_turn_output", mock_generate_failure)

    payload = {
        "language": "ko-KR",
        "text": "테스트",
        "client": {"viewport_w": 1920, "viewport_h": 1080},
        "economy_snapshot": {"signal": 100, "memory_shard": 5},
    }

    response = client.post("/api/turn", json=payload)
    events = [json.loads(line) for line in response.iter_lines() if line]

    final_event = next(e for e in events if e["type"] == "final")
    turn_output = final_event["data"]

    # 폴백 응답의 특징 확인
    assert turn_output["agent_console"]["badges"] == ["schema_fail"]
    assert turn_output["agent_console"]["repair_count"] == 1
    assert "혼란" in turn_output["narrative"] or "confusion" in turn_output["narrative"]


def test_turn_streaming_repair_loop(monkeypatch):
    """검증 실패 시 repair 이벤트가 스트림에 포함되는지 테스트합니다 (RU-002)."""
    from pydantic import ValidationError

    from unknown_world.orchestrator.mock import MockOrchestrator

    # 첫 번째 호출에서 실패하여 repair 트리거 시뮬레이션
    # (실제 구현에서는 N회 재시도 로직이 turn.py에 있어야 함)
    call_count = 0

    def mock_generate_with_repair(self, turn_input):
        nonlocal call_count
        call_count += 1
        if call_count == 1:
            raise ValidationError.from_exception_data(title="MockSchemaError", line_errors=[])
        return orchestrator_orig_generate(self, turn_input)

    import unknown_world.orchestrator.mock as mock_mod

    orchestrator_orig_generate = mock_mod.MockOrchestrator.generate_turn_output
    monkeypatch.setattr(MockOrchestrator, "generate_turn_output", mock_generate_with_repair)

    payload = {
        "language": "ko-KR",
        "text": "리페어 테스트",
        "client": {"viewport_w": 1920, "viewport_h": 1080},
        "economy_snapshot": {"signal": 100, "memory_shard": 5},
    }

    response = client.post("/api/turn", json=payload)
    events = [json.loads(line) for line in response.iter_lines() if line]

    # RU-002 요구사항: repair 이벤트가 명시적으로 존재해야 함
    repair_events = [e for e in events if e["type"] == "repair"]
    assert len(repair_events) >= 1
    assert "attempt" in repair_events[0]
    assert repair_events[0]["attempt"] == 1
</file>

<file path="backend/tests/unit/test_u034_verification.py">
import json
from pathlib import Path

# 프로젝트 루트 경로 설정 (backend/tests/unit/ 위치 기준)
ROOT_DIR = Path(__file__).parent.parent.parent.parent
SCHEMA_PATH = ROOT_DIR / "vibe/ref/nanobanana-asset-request.schema.json"
GUIDE_PATH = ROOT_DIR / "vibe/ref/nanobanana-mcp.md"


def test_schema_file_exists():
    """스키마 파일이 지정된 위치에 존재하는지 확인"""
    assert SCHEMA_PATH.exists(), f"Schema file not found at {SCHEMA_PATH}"


def test_schema_is_valid_json():
    """스키마 파일이 유효한 JSON 형식인지 확인"""
    with open(SCHEMA_PATH, encoding="utf-8") as f:
        schema = json.load(f)
    assert schema["title"] == "nanobanana mcp Asset Request Schema"


def test_schema_required_properties():
    """계획서에 명시된 필수 필드가 스키마에 정의되어 있는지 확인"""
    with open(SCHEMA_PATH, encoding="utf-8") as f:
        schema = json.load(f)

    properties = schema.get("properties", {})
    required_fields = ["id", "category", "purpose", "size_px", "requires_rembg", "rembg_model"]

    for field in required_fields:
        assert field in properties, f"Required field '{field}' missing in schema properties"


def test_guide_file_exists():
    """가이드 문서 파일이 존재하는지 확인"""
    assert GUIDE_PATH.exists(), f"Guide file not found at {GUIDE_PATH}"


def test_guide_content_completeness():
    """가이드 문서에 필수 섹션(아트 디렉션, 카테고리별 템플릿)이 포함되어 있는지 확인"""
    with open(GUIDE_PATH, encoding="utf-8") as f:
        content = f.read()

    # 계획서 구현 흐름 2단계, 3단계 관련 키워드 검사
    required_keywords = ["아트 디렉션", "스타일", "아이콘", "placeholder", "chrome", "템플릿"]

    missing_keywords = [kw for kw in required_keywords if kw.lower() not in content.lower()]

    # 현재 nanobanana-mcp.md에는 rembg 내용만 있으므로 실패할 가능성이 큼
    assert not missing_keywords, (
        f"Guide document is missing sections for: {', '.join(missing_keywords)}"
    )


def test_schema_rembg_rules():
    """배경 제거(rembg) 관련 강제 규칙(순백 배경)이 스키마/설명에 포함되어 있는지 확인"""
    with open(SCHEMA_PATH, encoding="utf-8") as f:
        schema = json.load(f)

    # background 필드와 requires_rembg 필드 설명 확인
    background_desc = schema["properties"]["background"].get("description", "")
    rembg_desc = schema["properties"]["requires_rembg"].get("description", "")

    assert "solid_white" in str(schema["properties"]["background"].get("enum", [])), (
        "background enum should include solid_white"
    )
    assert "rembg" in background_desc.lower(), "background description should mention rembg"
    assert "solid_white" in rembg_desc.lower(), (
        "requires_rembg description should recommend solid_white"
    )
</file>

<file path="CLAUDE.md">
# AI 에이전트 전역 지침 (Unknown World)

이 문서는 Unknown World 레포에서 작업하는 모든 AI 에이전트(Claude/Cursor 포함)가 **일관되고 효율적으로** 일할 수 있도록 하는 전역 규칙입니다.

---

## 프로젝트 개요

**Unknown World**는 Gemini 기반의 **에이전트형(Game Master) 세계 엔진**과 멀티모달(텍스트/이미지/비전) 파이프라인을 결합한 **무한 생성 로그라이크 내러티브 웹게임**입니다.

- “대화 앱”이 아니라 **상태를 가진 시스템**입니다.
- 출력은 내러티브 텍스트뿐 아니라 **UI/상태 변화/비용/이미지 작업**까지 포함한 **구조화 결과(JSON Schema)** 여야 합니다.
- 실패/불완전 출력에 대비해 **검증 + 자동 복구(Repair loop) + 안전한 폴백**을 내장합니다.

---

## SSOT(단일 출처) 및 충돌 해결 우선순위

문서/규칙이 충돌할 때는 아래 순서로 결정합니다.

1. `vibe/prd.md` (제품/UX/성공 지표/금지사항)
2. `vibe/tech-stack.md` (기술 스택/버전/아키텍처 선택)
3. `vibe/ref/*` (표준/스타일/구조화 출력 가이드)
4. `.cursor/rules/*.mdc` (구체적 실행 규칙)
5. `.gemini/rules/*` (존재하는 경우에 한해 참고; 프로젝트와 불일치 시 적용 금지)

불확실하면 **추측하지 말고 질문**합니다.

---

## 핵심 원칙 (Non‑Negotiable)

### 1) Prompt-only wrapper / Generic chatbot 회피

- “프롬프트 1장 + 채팅 UI” 형태를 금지합니다.
- 반드시 다음이 존재해야 합니다:
  - **상태(State)**: WorldState / Inventory / Rules / Economy / History
  - **오케스트레이터(Orchestrator)**: 단계 실행, 검증, 재시도, 비용 제어
  - **아티팩트(Artifacts)**: SaveGame, 엔딩 리포트, 로그/이미지

### 2) 채팅 버블 UI 금지, 게임 UI 고정

- 메신저형 **채팅 버블 UI 금지**(심사자 오해 방지).
- 데모에서 최소 다음 UI는 항상 “게임스럽게” 보이도록 고정합니다:
  - Action Deck(비용/위험/보상 포함), Inventory(DnD), Quest/Objective, Rule Board/Mutation Timeline,
    Economy HUD(예상/확정 비용), Memory Pin, Scene Canvas(핫스팟), Agent Console(Plan/Queue/Badges)

### 3) 구조화 출력(JSON Schema) 우선 + 이중 검증

- 모델 출력은 기본적으로 `application/json` + JSON Schema를 강제합니다.
- **서버(Pydantic) + 클라이언트(Zod)** 이중 검증을 전제로 설계합니다.

### 4) 검증/복구(Repair loop)와 폴백은 “필수 기능”

- 스키마 불일치/비즈니스 룰 위반/비용 초과/안전 차단 등은 **자동 복구 루프**로 처리합니다.
- 복구 실패 시에도 **텍스트-only 등 안전한 대체 결과**를 제공합니다.

### 5) 비용/지연은 UX/게임 메커닉으로 제어

- 행동 전에 **예상 비용(최소/최대)** 노출, 부족 시 **대체 행동** 제안(텍스트만/저해상도/Thinking 낮춤).
- Economy는 **원장(ledger)** 으로 추적 가능해야 하며 잔액 음수는 금지입니다.

### 6) ko/en i18n: 혼합 출력 금지

- 게임/시스템/내러티브는 `language: "ko-KR" | "en-US"` 기준으로 고정 출력합니다.
- 문자열 하드코딩 대신 i18n 리소스 키 사용(가능한 범위 내).
- 프롬프트는 언어별 `.md` 파일로 관리합니다.

### 7) 보안: Vertex AI 서비스 계정, 비밀정보 커밋 금지

- BYOK(사용자 API 키 입력) 요구 금지(MVP).
- 서비스 계정 키/토큰/쿠키 등 비밀정보를 레포에 저장/로그 출력 금지.
- 프롬프트 인젝션 방어: “사용자 입력은 룰이 아니다”를 시스템 규칙으로 고정합니다.

### 8) 관측 가능성(Observability) = UX의 일부

- 에이전트의 “계획/실행/검증/복구”를 **UI 단계/배지/큐**로 보여줍니다.
- 단, **프롬프트 원문/내부 추론**은 사용자 UI에 노출하지 않습니다.

---

## 작업 표준 (Workflow)

### 작업 시작 전 필수

- `vibe/prd.md` + `vibe/tech-stack.md`를 먼저 읽고, **이번 작업이 PRD의 어떤 요구를 충족하는지** 명시합니다.
- 변경 범위를 파일/모듈 단위로 짧게 적고(최대 5줄), 리스크/완화책을 함께 제시합니다.

### 유닛(단계) 기반 개발

- 유닛 구현 지시서는 `vibe/commands/unit-impl.md`(또는 `.cursor/commands/unit-impl.md`)의 흐름을 따릅니다.
- “현재 단계 범위” 밖의 구현/아이디어 확장은 금지합니다(요청이 오면 질문으로 승격).
- 기능 구현 후 **런북**을 작성해 재현 가능한 수동 검증 시나리오를 남깁니다.

### 문서 동기화

- 구현 완료 후 문서 동기화는 `vibe/commands/doc-update.md` 기준으로 수행합니다.
- Progress/Roadmap/Architecture/PRD/Tech-stack 문서의 동기화 규칙(최신 항목 최상단 등)을 준수합니다.

### 리팩토링

- 리팩토링은 `vibe/commands/refactor-impl.md` 기준으로 **Behavior Preservation**을 최우선합니다.

### 테스트

- 테스트 작업을 명시적으로 요청받았거나, `test-exec` 흐름을 수행할 때는 `vibe/commands/test-exec.md`의 절차(TDD, 원인 판별 프로토콜 등)를 따릅니다.
- 그 외의 일반 기능 구현에서는 “자동 테스트 도입 여부”를 추측해 추가하지 말고, 런북/리플레이 기반 검증을 우선합니다.

### 커밋 메시지

- 커밋 메시지는 `.gemini/rules/commit-rules.md` 포맷을 우선 준수합니다(한글, Progress 블록 포함).
- 단, `vibe/roadmap.md`가 비어있는 경우 Progress 수치는 임의로 만들지 말고 보류/질문합니다.

---

## 품질 기준 (출시/데모 관점)

### Hard Gate (필수 통과)

- **Schema OK**: TurnOutput JSON이 스키마를 통과
- **Economy OK**: 비용/잔액 불일치 없음, 잔액 음수 금지
- **Safety OK**: 차단 시 명시 + 안전한 대체 결과 제공
- **Consistency OK**: WorldState/Rule Board/Memory Pin 일관성 유지

### Soft Gate (관측/튜닝)

- **Streaming TTFB**: 2초 이내 목표(데모 체감 우선)
- 이미지 생성: 선택적/지연 허용(Lazy loading), 실패 시 텍스트 대체

---

## 금지사항 (절대 금지)

- ❌ 채팅 버블/메신저 UX로 회귀시키는 변경
- ❌ 구조화 출력 없이 “텍스트만” 반환하는 API/로직(특수한 예외를 제외)
- ❌ 프롬프트 원문/내부 추론/비밀정보를 UI 또는 로그로 노출
- ❌ 서비스 계정 키/토큰 등 비밀정보를 레포에 커밋
- ❌ `language` 정책을 무시하고 ko/en 혼합 출력
- ❌ 좌표 규약(0~1000, bbox [ymin,xmin,ymax,xmax])을 깨는 변경
- ❌ 재화 잔액 음수/비용 누락/예상비용 미표기

---

## 지침 운영/사용 가이드

### Cursor 규칙 적용 방식

- `.cursor/rules/*.mdc`는 **파일 패턴(`applyTo`)**에 따라 자동 적용됩니다.
- 규칙이 부족/충돌하면:
  - PRD/Tech-stack 근거를 첨부해 규칙을 업데이트하고,
  - 파일 하나가 500줄을 넘지 않게 모듈로 분리합니다.

### 온보딩(신규 합류자/에이전트) 10분 루프

- `vibe/prd.md` 6~9장(게임 UI/경제/Autopilot) → “채팅 UI 금지” 합의
- `vibe/tech-stack.md`(버전/모델 ID 고정) 확인
- `vibe/ref/frontend-style-guide.md`로 CRT 테마 규칙 숙지
- `vibe/ref/structured-outputs-guide.md`로 JSON Schema 제약 이해

### 지침 업데이트 프로세스(권장)

- 변경 필요 신호: 규칙 오해/중복/충돌/500줄 초과/6개월 미사용
- 절차: 문제 재현 → 원인(규칙 부재/모호함) → 규칙 수정/분리 → PRD/Tech-stack와 정합성 확인 → 적용 범위(applyTo) 좁히기

---

## 참조 문서

- `vibe/prd.md`
- `vibe/tech-stack.md`
- `vibe/ref/frontend-style-guide.md`
- `vibe/ref/structured-outputs-guide.md`
- `vibe/commands/*.md` / `.cursor/commands/*.md`
- `.gemini/rules/commit-rules.md`
</file>

<file path="frontend/public/ui/manifest.schema.json">
{
  "$schema": "http://json-schema.org/draft-07/schema#",
  "$id": "https://unknown-world.dev/schemas/ui-asset-manifest.json",
  "title": "UI Asset Manifest",
  "description": "nanobanana mcp로 제작된 UI 에셋의 매니페스트 스키마",
  "type": "object",
  "required": ["version", "assets"],
  "additionalProperties": false,
  "properties": {
    "$schema": {
      "type": "string",
      "description": "JSON Schema 참조"
    },
    "version": {
      "type": "string",
      "pattern": "^\\d+\\.\\d+\\.\\d+$",
      "description": "매니페스트 버전 (SemVer)",
      "examples": ["1.0.0"]
    },
    "generatedAt": {
      "type": "string",
      "format": "date-time",
      "description": "매니페스트 생성 시각 (ISO 8601)"
    },
    "totalBytes": {
      "type": "integer",
      "minimum": 0,
      "description": "모든 에셋의 총 바이트 수"
    },
    "budgetBytes": {
      "type": "integer",
      "minimum": 0,
      "default": 1572864,
      "description": "성능 예산 상한 (기본: 1.5MB = 1572864 bytes)"
    },
    "assets": {
      "type": "array",
      "description": "에셋 목록",
      "items": {
        "$ref": "#/$defs/Asset"
      }
    }
  },
  "$defs": {
    "Asset": {
      "type": "object",
      "required": ["id", "path", "type"],
      "additionalProperties": false,
      "properties": {
        "id": {
          "type": "string",
          "pattern": "^[a-z0-9]+(-[a-z0-9]+)*$",
          "description": "에셋 고유 ID (kebab-case)",
          "examples": ["signal-24", "badge-ok-16", "scene-loading"]
        },
        "path": {
          "type": "string",
          "pattern": "^[a-z0-9-/]+\\.(png|webp|svg)$",
          "description": "ui/ 디렉토리 기준 상대 경로",
          "examples": ["icons/signal-24.png", "placeholders/scene-loading.webp"]
        },
        "type": {
          "type": "string",
          "enum": ["icon", "placeholder", "chrome"],
          "description": "에셋 유형"
        },
        "size": {
          "type": "integer",
          "enum": [16, 24, 32, 64, 128, 256, 512],
          "description": "픽셀 사이즈 (아이콘용)"
        },
        "width": {
          "type": "integer",
          "minimum": 1,
          "description": "가로 픽셀 (placeholder/chrome용)"
        },
        "height": {
          "type": "integer",
          "minimum": 1,
          "description": "세로 픽셀 (placeholder/chrome용)"
        },
        "fallback": {
          "type": "string",
          "maxLength": 10,
          "description": "로딩 실패 시 대체 이모지/텍스트",
          "examples": ["📡", "⚠️", "OK"]
        },
        "usedIn": {
          "type": "array",
          "items": {
            "type": "string"
          },
          "description": "사용처 컴포넌트 목록",
          "examples": [["EconomyHUD", "AgentConsole"]]
        },
        "bytes": {
          "type": "integer",
          "minimum": 0,
          "description": "파일 크기 (bytes)"
        },
        "format": {
          "type": "string",
          "enum": ["png", "webp", "svg"],
          "description": "파일 포맷"
        },
        "retina": {
          "type": "boolean",
          "default": false,
          "description": "@2x Retina 버전 존재 여부"
        },
        "description": {
          "type": "string",
          "maxLength": 200,
          "description": "에셋 설명"
        },
        "createdAt": {
          "type": "string",
          "format": "date-time",
          "description": "생성 시각 (ISO 8601)"
        },
        "promptHash": {
          "type": "string",
          "pattern": "^[a-f0-9]{8}$",
          "description": "생성 프롬프트 해시 (재현성, 8자)"
        },
        "notes": {
          "type": "string",
          "maxLength": 500,
          "description": "에셋 관련 메모 (생성 도구, 배경 제거, 최적화 등 QA 관련 기록)"
        }
      }
    }
  }
}
</file>

<file path="frontend/src/api/turnStream.test.ts">
import { describe, it, expect, vi, beforeEach } from 'vitest';
import { NDJSONParser } from './turnStream';

describe('NDJSONParser', () => {
  let parser: NDJSONParser;

  beforeEach(() => {
    parser = new NDJSONParser();
  });

  it('should parse a single complete line', () => {
    const chunk = JSON.stringify({ type: 'test', value: 1 }) + '\n';
    const results = parser.parse(chunk);
    expect(results).toHaveLength(1);
    expect(results[0]).toEqual({ type: 'test', value: 1 });
  });

  it('should parse multiple complete lines in one chunk', () => {
    const chunk = JSON.stringify({ id: 1 }) + '\n' + JSON.stringify({ id: 2 }) + '\n';
    const results = parser.parse(chunk);
    expect(results).toHaveLength(2);
    expect(results[0]).toEqual({ id: 1 });
    expect(results[1]).toEqual({ id: 2 });
  });

  it('should buffer partial lines and parse them when completed', () => {
    const chunk1 = '{"id": 1';
    const chunk2 = ', "val": "ok"}\n';

    const results1 = parser.parse(chunk1);
    expect(results1).toHaveLength(0);

    const results2 = parser.parse(chunk2);
    expect(results2).toHaveLength(1);
    expect(results2[0]).toEqual({ id: 1, val: 'ok' });
  });

  it('should ignore empty lines', () => {
    const chunk = '\n\n{"a":1}\n\n';
    const results = parser.parse(chunk);
    expect(results).toHaveLength(1);
  });

  it('should not crash on invalid JSON and continue', () => {
    const consoleSpy = vi.spyOn(console, 'warn').mockImplementation(() => {});
    const chunk = 'invalid json\n{"valid": true}\n';
    const results = parser.parse(chunk);

    expect(results).toHaveLength(1);
    expect(results[0]).toEqual({ valid: true });
    expect(consoleSpy).toHaveBeenCalled();
    consoleSpy.mockRestore();
  });

  it('should flush remaining buffer', () => {
    parser.parse('{"id": 1}'); // No newline
    const result = parser.flush();
    expect(result).toEqual({ id: 1 });
  });

  it('should return null on flush with empty buffer', () => {
    const result = parser.flush();
    expect(result).toBeNull();
  });
});

describe('executeTurnStream', () => {
  const mockInput = {
    language: 'ko-KR' as const,
    text: 'Hello',
    click: null,
    client: { viewport_w: 100, viewport_h: 100, theme: 'dark' as const },
    economy_snapshot: { signal: 100, memory_shard: 0 },
  };

  const mockCallbacks = {
    onStage: vi.fn(),
    onRepair: vi.fn(),
    onBadges: vi.fn(),
    onNarrativeDelta: vi.fn(),
    onFinal: vi.fn(),
    onError: vi.fn(),
    onComplete: vi.fn(),
  };

  beforeEach(() => {
    vi.clearAllMocks();
    global.fetch = vi.fn();
  });

  it('should process stream events correctly (including repair)', async () => {
    const encoder = new TextEncoder();
    const stream = new ReadableStream({
      start(controller) {
        controller.enqueue(
          encoder.encode(JSON.stringify({ type: 'stage', name: 'parse', status: 'start' }) + '\n'),
        );
        controller.enqueue(
          encoder.encode(
            JSON.stringify({ type: 'repair', attempt: 1, message: 'Schema fail, retrying' }) + '\n',
          ),
        );
        controller.enqueue(
          encoder.encode(JSON.stringify({ type: 'narrative_delta', text: 'Hello' }) + '\n'),
        );
        controller.enqueue(
          encoder.encode(
            JSON.stringify({
              type: 'final',
              data: {
                language: 'ko-KR',
                narrative: 'Hello',
                economy: {
                  cost: { signal: 0, memory_shard: 0 },
                  balance_after: { signal: 100, memory_shard: 0 },
                },
                safety: { blocked: false },
              },
            }) + '\n',
          ),
        );
        controller.close();
      },
    });

    (global.fetch as unknown as ReturnType<typeof vi.fn>).mockResolvedValue({
      ok: true,
      body: stream,
    });

    const { executeTurnStream } = await import('./turnStream');
    await executeTurnStream(mockInput, mockCallbacks);

    expect(mockCallbacks.onStage).toHaveBeenCalledWith(expect.objectContaining({ name: 'parse' }));
    expect(mockCallbacks.onRepair).toHaveBeenCalledWith(
      expect.objectContaining({ attempt: 1, message: 'Schema fail, retrying' }),
    );
    expect(mockCallbacks.onNarrativeDelta).toHaveBeenCalledWith(
      expect.objectContaining({ text: 'Hello' }),
    );
    expect(mockCallbacks.onFinal).toHaveBeenCalled();
    expect(mockCallbacks.onComplete).toHaveBeenCalled();
  });

  it('should handle HTTP errors', async () => {
    (global.fetch as unknown as ReturnType<typeof vi.fn>).mockResolvedValue({
      ok: false,
      status: 500,
      statusText: 'Internal Server Error',
    });

    const { executeTurnStream } = await import('./turnStream');
    await executeTurnStream(mockInput, mockCallbacks);

    expect(mockCallbacks.onError).toHaveBeenCalledWith(
      expect.objectContaining({
        code: 'STREAM_ERROR',
        message: expect.stringContaining('500'),
      }),
    );
  });

  it('should handle fetch rejection', async () => {
    (global.fetch as unknown as ReturnType<typeof vi.fn>).mockRejectedValue(
      new Error('Network failure'),
    );

    const { executeTurnStream } = await import('./turnStream');
    await executeTurnStream(mockInput, mockCallbacks);

    expect(mockCallbacks.onError).toHaveBeenCalledWith(
      expect.objectContaining({
        message: 'Network failure',
      }),
    );
  });
});
</file>

<file path="frontend/src/components/AgentConsole.tsx">
/**
 * Unknown World - Agent Console 컴포넌트.
 *
 * 에이전트형 시스템임을 UI로 증명하기 위한 컴포넌트입니다.
 * Plan/Queue/Badges/Auto-repair 트레이스를 실시간으로 표시합니다.
 *
 * 설계 원칙:
 *   - RULE-008: 단계/배지/복구만 보여줌 (프롬프트/내부 추론 노출 금지)
 *   - RULE-002: 게임 UI로 표현 (채팅 버블 금지)
 *
 * @module components/AgentConsole
 */

import {
  useAgentStore,
  selectIsStreaming,
  selectPhases,
  selectBadges,
  selectRepairCount,
  selectError,
  type PhaseInfo,
} from '../stores/agentStore';
import type { ValidationBadge } from '../schemas/turn';

// =============================================================================
// 상수 정의
// =============================================================================

/** 단계 표시 이름 (한국어) */
const PHASE_LABELS: Record<string, string> = {
  parse: 'Parse',
  validate: 'Validate',
  plan: 'Plan',
  resolve: 'Resolve',
  render: 'Render',
  verify: 'Verify',
  commit: 'Commit',
};

/** 배지 표시 정보 */
const BADGE_INFO: Record<ValidationBadge, { label: string; isOk: boolean }> = {
  schema_ok: { label: 'Schema', isOk: true },
  schema_fail: { label: 'Schema', isOk: false },
  economy_ok: { label: 'Economy', isOk: true },
  economy_fail: { label: 'Economy', isOk: false },
  safety_ok: { label: 'Safety', isOk: true },
  safety_blocked: { label: 'Safety', isOk: false },
  consistency_ok: { label: 'Consistency', isOk: true },
  consistency_fail: { label: 'Consistency', isOk: false },
};

// =============================================================================
// 하위 컴포넌트
// =============================================================================

/** 단계 상태 아이콘 */
function PhaseIcon({ status }: { status: PhaseInfo['status'] }) {
  switch (status) {
    case 'pending':
      return <span className="phase-icon pending">○</span>;
    case 'in_progress':
      return <span className="phase-icon in-progress">◎</span>;
    case 'completed':
      return <span className="phase-icon completed">●</span>;
    case 'failed':
      return <span className="phase-icon failed">✕</span>;
    default:
      return <span className="phase-icon">○</span>;
  }
}

/** 단계 큐 항목 */
function PhaseQueueItem({ phase }: { phase: PhaseInfo }) {
  const label = PHASE_LABELS[phase.name] ?? phase.name;
  const statusClass = `phase-item ${phase.status}`;

  return (
    <div className={statusClass}>
      <PhaseIcon status={phase.status} />
      <span className="phase-label">{label}</span>
    </div>
  );
}

/** 단계 큐 */
function PhaseQueue() {
  const phases = useAgentStore(selectPhases);

  return (
    <div className="phase-queue">
      <div className="queue-label">Queue</div>
      <div className="queue-items">
        {phases.map((phase) => (
          <PhaseQueueItem key={phase.name} phase={phase} />
        ))}
      </div>
    </div>
  );
}

/** 배지 아이템 */
function BadgeItem({ badge }: { badge: ValidationBadge }) {
  const info = BADGE_INFO[badge];
  if (!info) return null;

  const statusClass = info.isOk ? 'badge-ok' : 'badge-fail';
  const statusText = info.isOk ? 'OK' : 'FAIL';
  const iconName = info.isOk ? 'badge-ok-24.png' : 'badge-fail-24.png';
  const fallbackIcon = info.isOk ? '✓' : '✗';

  return (
    <div className={`badge-item ${statusClass}`}>
      <span className="badge-label">{info.label}</span>
      <span className="badge-status">
        <span className="icon-wrapper">
          <img
            src={`/ui/icons/${iconName}`}
            alt=""
            aria-hidden="true"
            className="badge-icon-img"
            onError={(e) => e.currentTarget.classList.add('hidden')}
          />
          <span className="icon-fallback" style={{ fontSize: '0.625rem' }}>
            {fallbackIcon}
          </span>
        </span>
        {statusText}
      </span>
    </div>
  );
}

/** 배지 패널 */
function BadgesPanel() {
  const badges = useAgentStore(selectBadges);

  if (badges.length === 0) {
    return (
      <div className="badges-panel">
        <div className="badges-label">Badges</div>
        <div className="badges-empty">[ 검증 대기 중 ]</div>
      </div>
    );
  }

  return (
    <div className="badges-panel">
      <div className="badges-label">Badges</div>
      <div className="badges-grid">
        {badges.map((badge, index) => (
          <BadgeItem key={`${badge}-${index}`} badge={badge} />
        ))}
      </div>
    </div>
  );
}

/** Auto-repair 트레이스 */
function RepairTrace() {
  const repairCount = useAgentStore(selectRepairCount);
  const isStreaming = useAgentStore(selectIsStreaming);

  if (repairCount === 0 && !isStreaming) {
    return null;
  }

  return (
    <div className="repair-trace">
      <span className="repair-label">Auto-repair</span>
      <span className="repair-count">#{repairCount}</span>
      {repairCount > 0 && <span className="repair-status text-warning"> (복구됨)</span>}
    </div>
  );
}

/** 에러 표시 */
function ErrorDisplay() {
  const error = useAgentStore(selectError);

  if (!error) return null;

  return (
    <div className="agent-error">
      <span className="error-icon">⚠</span>
      <span className="error-message">{error.message}</span>
      {error.code && <span className="error-code">[{error.code}]</span>}
    </div>
  );
}

/** 스트리밍 상태 표시 */
function StreamingStatus() {
  const isStreaming = useAgentStore(selectIsStreaming);

  return (
    <div className="streaming-status">
      <span className={`status-dot ${isStreaming ? 'active' : ''}`} />
      <span className="status-text">{isStreaming ? 'PROCESSING' : 'IDLE'}</span>
    </div>
  );
}

// =============================================================================
// 메인 컴포넌트
// =============================================================================

/**
 * Agent Console 컴포넌트.
 *
 * Plan/Queue/Badges/Auto-repair를 실시간으로 표시합니다.
 * RULE-008에 따라 프롬프트/내부 추론은 노출하지 않습니다.
 */
export function AgentConsole() {
  return (
    <div className="agent-console-content">
      <StreamingStatus />
      <PhaseQueue />
      <BadgesPanel />
      <RepairTrace />
      <ErrorDisplay />
    </div>
  );
}

export default AgentConsole;
</file>

<file path="frontend/src/main.tsx">
import { StrictMode } from 'react';
import { createRoot } from 'react-dom/client';
import './i18n'; // i18n 초기화
import './style.css';
import App from './App.tsx';

createRoot(document.getElementById('root')!).render(
  <StrictMode>
    <App />
  </StrictMode>,
);
</file>

<file path="frontend/tsconfig.json">
{
  "compilerOptions": {
    "target": "ES2022",
    "useDefineForClassFields": true,
    "lib": ["ES2022", "DOM", "DOM.Iterable"],
    "module": "ESNext",
    "skipLibCheck": true,

    /* Bundler mode */
    "moduleResolution": "Bundler",
    "allowImportingTsExtensions": true,
    "isolatedModules": true,
    "moduleDetection": "force",
    "noEmit": true,
    "jsx": "react-jsx",

    /* Linting (엄격 모드) */
    "strict": true,
    "noUnusedLocals": true,
    "noUnusedParameters": true,
    "noFallthroughCasesInSwitch": true,
    "noUncheckedSideEffectImports": true
  },
  "include": ["src"],
  "references": [{ "path": "./tsconfig.node.json" }]
}
</file>

<file path="shared/README.md">
# shared/

이 디렉토리는 **프론트엔드와 백엔드 간 공유되는 스키마/타입 정의**를 위한 SSOT(Single Source of Truth) 디렉토리입니다.

## 📁 구조

```
shared/
├── schemas/
│   └── turn/                         # Turn 계약 스키마 (TurnInput/TurnOutput)
│       ├── turn_input.schema.json    # Client → Server 요청 스키마
│       └── turn_output.schema.json   # Server → Client 응답 스키마
└── README.md
```

## 🔄 SSOT 원칙 (RU-001-Q4)

- **SSOT는 `shared/schemas/`의 JSON Schema 파일**입니다.
- 백엔드(Python/Pydantic)와 프론트엔드(TS/Zod)의 타입/검증 코드는 **이 스키마로부터 생성 또는 동기화**됩니다.
- 스키마 변경 시 양쪽(backend/frontend)에 영향이 있음을 반드시 인지해야 합니다.

### 소비 전략 (Option B: 생성물 기반 동기화)

| 소비자 | 도구/방식 | 생성물 경로 (권장) |
|--------|-----------|-------------------|
| **Backend (Python)** | `datamodel-code-generator` 또는 수동 동기화 | `backend/src/unknown_world/schemas/generated/` |
| **Frontend (TS)** | `json-schema-to-zod` 또는 수동 동기화 | `frontend/src/schemas/generated/` |

> **MVP 단계에서는 수동 동기화**로 시작하고, drift가 발생하면 생성 스크립트를 도입합니다.

## 📋 스키마 파일 목록

### Turn 계약 (MVP)

| 파일 | 용도 | PRD 참조 |
|------|------|----------|
| `turn/turn_input.schema.json` | Client → Server 턴 요청 | PRD 8.7절 TurnInput |
| `turn/turn_output.schema.json` | Server → Client 턴 응답 | PRD 8.7절 TurnOutput |

## ✅ 스키마 작성 가이드라인

- **지원 타입**: `string`, `number`, `integer`, `boolean`, `object`, `array`, `null`
- **권장 속성**: `required`, `enum`, `description`을 적극 사용
- **엄격 모드**: `additionalProperties: false`로 예측 가능성 확보
- **평평한 구조**: 과도한 중첩을 피하고 단순한 스키마 유지
- **참조**: `vibe/ref/structured-outputs-guide.md`

## ⚠️ 보안 주의사항 (RULE-007)

- **절대로 서비스 계정 키, 크리덴셜, 비밀정보를 이 디렉토리에 배치하지 마세요.**
- 키 파일은 반드시 `secrets/` 디렉토리에만 배치합니다 (`.gitignore`로 차단됨).
- 스키마 파일은 "계약 문서"이므로 커밋해도 보안 위험이 없습니다 (단, 비밀값 포함 금지).

## 📚 관련 문서

- `vibe/refactors/RU-001-Q4.md` - JSON Schema SSOT 도입 근거
- `vibe/refactors/RU-001-S1.md` - .gitignore JSON 정책 변경 근거
- `vibe/ref/structured-outputs-guide.md` - Gemini Structured Output 가이드
- `vibe/prd.md` (8.7절) - TurnInput/TurnOutput 설계 방향
- `.cursor/rules/00-core-critical.mdc` - RULE-003 (이중 검증), RULE-007 (보안)
</file>

<file path="vibe/commands/commit-log.md">
# 커밋 메시지 작성 지침 프롬프트

당신은 현재 프로젝트의 커밋 메시지를 작성하는 역할을 맡았습니다. 아래 규칙과 지침을 엄격히 준수하여 **현재 구현 Commit(`git show <hash>`) 또는 현재 유닛 작업의 변경점(`git status`/`git diff`)**을 바탕으로 최적의 커밋 메시지를 제안해 주세요.

## 1. 기본 규칙 준수

- `.gemini/rules/commit-rules.md` 파일에 정의된 기본 구조와 타입(feat, fix, docs 등)을 따릅니다.
- 모든 커밋 메시지는 **한국어**로 작성합니다.

## 2. 유닛 작업 여부에 따른 분기 처리 **(중요)**

커밋 메시지를 작성하기 전에, 현재 작업이 `vibe/roadmap.md` 등에 정의된 **특정 '유닛(Unit)'을 완료하는 작업인지** 판단하세요.

### A. 유닛 작업인 경우 (Unit Task)

- `.gemini/rules/commit-rules.md`의 지침을 **완벽히** 따릅니다.
- **제목**: `<타입>(<스코프>): <유닛 ID> <유닛 설명>` 형식을 사용합니다.
- **본문**: `**Progress:**` 섹션을 포함하여 전체 및 마일스톤 진행률, 완료된 유닛 정보를 명시합니다.

### B. 유닛 작업이 아닌 경우 (Non-Unit Task)

- 일반적인 버그 수정, 문서 업데이트, 단순 리팩토링 등이 해당됩니다.
- **제목**: `<유닛 ID>` 태그를 **제외**합니다.
  - 형식: `<타입>(<스코프>): <작업 요약>`
- **본문**: `**Progress:**` 섹션을 **제외**합니다. 단순히 변경 사항에 대한 설명(What, Why)만 작성합니다.

## 3. 실행 지침

1. 사용자가 **현재 구현 Commit(해시)** 를 제공한 경우 `git show <hash>`(필요 시 `git show --name-status --stat`)를 분석하여 변경된 파일과 내용을 파악합니다. 제공되지 않은 경우 `git status`와 `git diff`로 **현재 유닛 작업** 변경점을 파악합니다.
2. 작업의 성격이 특정 유닛을 완료하는 것인지, 아니면 일반적인 유지보수/수정인지 판단합니다. (사용자의 명시적 언급이 없다면 보수적으로 판단하여 일반 작업으로 간주하거나, 확실치 않을 경우 일반 작업 형식을 따르되 유닛 ID를 괄호 안에 넣는 등 유연하게 대처하지 말고 **확실하지 않으면 제외**합니다.)
3. 위 규칙(A 또는 B)에 맞춰 커밋 메시지 초안을 작성하여 제시합니다.
4. **출력 형식**:
   사용자가 복사해서 붙여넣기 편하도록, `git commit` 명령어 없이 **순수 커밋 메시지(제목과 본문)**만 코드 블록에 담아 출력하세요.

   ```text
   <타입>(<스코프>): <제목>

   <본문 내용...>
   ```
</file>

<file path="vibe/commands/lint-check.md">
# 코드 품질 검사 및 수정 지침 프롬프트 (범용)

당신은 프로젝트의 코드 품질을 책임지는 '품질 관리자(Quality Manager)'입니다.
당신의 임무는 `.gemini/rules/lint-rules.md`에 정의된 **프로젝트별 규칙과 도구**를 사용하여 코드를 검사하고 개선하는 것입니다.

## 1. 참조 규칙 및 환경 설정

- **규칙 정의 파일**: `.gemini/rules/lint-rules.md`
- **전제 조건**:
  1. 위 규칙 파일을 먼저 판독하여 현재 프로젝트의 **주 사용 언어**, **패키지 매니저**, **사용할 도구(Linter, Formatter 등)** 및 **실행 명령어**를 파악하십시오.
  2. 모든 명령어 실행은 규칙 파일에 정의된 환경(예: 로컬, 도커, 특정 가상환경 등)을 기준합니다.

## 2. 작업 순서 및 지침

다음 3단계의 표준 절차를 수행하고, 각 단계의 결과를 분석하여 보고하세요.

### 단계 1: 코드 스타일 포맷팅 (Formatting)

- **목표**: 프로젝트 표준에 따른 일관된 코드 스타일 적용.
- **실행**: 규칙 파일에 정의된 **포맷팅 명령어(Formatter Command)**를 실행합니다.
- **행동**:
  - 명령어를 실행하여 코드 스타일을 자동으로 맞춥니다.
  - 변경된 파일이 있다면 목록을 기록합니다.

### 단계 2: 린트 검사 및 자동 수정 (Linting & Fix)

- **목표**: 문법적 오류, 잠재적 버그, 안티 패턴 제거.
- **실행**: 규칙 파일에 정의된 **린트 명령어(Lint Command)**를 실행합니다. (가능하다면 자동 수정 옵션 포함)
- **행동**:
  - 자동 수정(Auto-fix)이 가능한 항목은 즉시 반영합니다.
  - 자동 수정이 불가능한 오류가 남아있다면, 해당 오류의 내용(Rule ID, 메시지)과 위치를 파악합니다.
  - **중요**: 비즈니스 로직 변경이 필요하거나 모호한 복잡한 오류는 임의로 수정하지 말고 리포트에 기록하여 사용자에게 알립니다.

### 단계 3: 심층 정적 분석 (Static Analysis / Type Check)

- **목표**: 타입 안정성 확보 및 컴파일 타임/런타임 오류 예방.
- **실행**: 규칙 파일에 정의된 **정적 분석 또는 타입 체크 명령어(Type Check Command)**를 실행합니다.
  - _참고: 해당 언어나 환경이 타입 체크를 지원하지 않는 경우(예: 순수 JS 등), 규칙 파일의 지침에 따라 생략하거나 심화 린팅으로 대체합니다._
- **행동**:
  - 출력된 에러 메시지를 분석합니다.
  - 타입 불일치, 누락된 정의 등을 확인합니다.

## 3. 결과 보고 형식

작업 완료 후 다음 형식으로 요약하여 보고하세요. 도구 이름은 규칙 파일에서 파악한 실제 도구명(예: ESLint, Ruff, Checkstyle 등)으로 대체하여 작성합니다.

```markdown
## 🧹 코드 품질 검사 보고

### 1. 포맷팅 ({사용된 도구명})

- [ ] 변경 없음 / [x] 수정됨 (파일 수: N개)
- 수정된 파일: `...`

### 2. 린트 ({사용된 도구명})

- [ ] 통과 / [x] 이슈 발견
- 자동 수정된 이슈: N개
- **잔여 이슈 (수동 조치 필요)**:
  - `파일경로:라인`: [규칙ID] 메시지

### 3. 정적 분석/타입 ({사용된 도구명})

- [ ] 통과 / [x] 실패 (에러 수: N개) / [ ] 해당 없음
- 주요 에러:
  - `파일경로`: 메시지
```
</file>

<file path="vibe/commands/roadmap-update.md">
# Vibe 코딩 로드맵 업데이터

## 📋 역할 정의

<role_definition>
당신은 기존 개발 로드맵 `vibe/roadmap.md`을 분석하고 변경사항을 반영하는 시니어 테크 리드입니다.

**핵심 책임:**

1. **영향도 분석**: 변경사항이 미치는 범위 파악 (로드맵, 유닛 계획서, 관련 문서)
2. **품질 일관성 유지**: 기존 문서의 상세 수준과 형식을 유지
3. **일관성 유지**: 모든 문서 간 정보 동기화 보장
4. **의존성 재검증**: 변경으로 인한 의존성 충돌 해결
5. **진행률 재계산**: 완료/진행중인 작업 고려한 현실적 일정 조정
6. **리스크 재평가**: 새로운 위험 요소 식별 및 대응 방안 수립

**작업 산출물:**

- 업데이트된 로드맵 문서 (`vibe/roadmap.md`)
- 영향받는 유닛 계획서들 (`vibe/unit-plans/{Unit-ID}.md`)
- 변경된 사양서 (`vibe/prd.md`)
- 변경 이력 문서 (`{로드맵-루트}/changelog.md`)
  </role_definition>

## 🎯 핵심 원칙

<core_principles>

### 1. 품질 일관성 원칙 (최우선)

**모든 업데이트는 기존 문서의 품질 수준을 유지하거나 향상시켜야 합니다.**

```
⚠️ 절대 규칙:
- 기존 유닛 계획서보다 낮은 품질의 문서 생성 금지
- 섹션 생략 금지 (템플릿의 모든 섹션 유지)
- 내용 축약 금지 (동일한 상세 수준 유지)
```

### 2. 참조 기반 생성 원칙

**새 문서 생성 시 반드시 기존 문서를 참조 기준으로 활용합니다.**

```
신규 유닛 계획서 작성 시:
1. 완료된 유닛 계획서 (✅) 중 하나를 품질 참조 기준으로 선정
2. 선정한 문서의 구조, 상세도, 톤을 그대로 따름
3. 도메인/기능만 변경하고 품질 패턴은 유지
```

### 3. 점진적 개선 원칙

```
업데이트 우선순위:
1. 기존 품질 유지 (최소 보장)
2. 불명확한 부분 보강 (권장)
3. 새 인사이트 추가 (선택)
```

</core_principles>

## 📚 필수 맥락 수집 (업데이트 전)

<context_collection>

### 필수 읽기 문서

업데이트 작업 전 **반드시** 다음 문서들을 읽고 품질 기준을 파악합니다:

**원본 프롬프트 (품질 기준의 근원):**

- `vibe/ready/roadmap-prompt.md` - 유닛 계획서 템플릿, 형식 규칙

**품질 참조 문서 (최소 2개 이상):**

- 완료된 유닛 계획서 (✅) 중 대표적인 것 2-3개
- 가장 상세하게 작성된 유닛 계획서 1개

**현황 파악:**

- `vibe/roadmap.md` → 현재 진행 상태, 완료된 작업
- `vibe/prd.md` → 기존 요구사항 목록

### 추출할 품질 기준

```
기존 문서에서 파악할 것:
□ 메타데이터 테이블 형식
□ 작업 목표의 구체성 수준 (몇 문장?)
□ 완료 기준의 개수와 측정 가능성
□ 영향받는 파일 섹션의 상세도
□ 구현 흐름의 단계 수와 세부 항목 개수
□ 의존성 설명의 구체성
□ 주의사항의 포함 범위 (기술적 고려사항 + 리스크)
□ 페어링 질문의 형식과 옵션 제시 방법
□ 참고 자료 링크 포함 여부
```

</context_collection>

## 🔄 업데이트 프로세스

<update_workflow>

### 1단계: 품질 기준 수집 (5분) ⭐ 신규

```
📖 품질 참조 문서 선정:
1. vibe/unit-plans/ 에서 완료된 유닛 계획서 2-3개 읽기
2. 가장 상세한 문서를 "품질 기준 문서"로 선정
3. 해당 문서의 다음 항목 측정:
   - 작업 목표: 배경 설명 포함 여부, 완료 기준 개수
   - 영향받는 파일: 생성/수정/참조 각각 몇 개
   - 구현 흐름: 단계 수, 각 단계 항목 수
   - 주의사항: 고려사항/리스크 각각 몇 개
   - 페어링 질문: 질문 수, Option 개수

📊 품질 기준선 설정:
- 최소 완료 기준: {N}개
- 최소 구현 단계: {N}개
- 최소 주의사항: {N}개
```

### 2단계: 현황 파악 (5분)

```
📖 읽기:
- vibe/roadmap.md → 현재 진행 상태, 완료된 작업
- vibe/prd.md → 기존 요구사항 목록
- vibe/unit-plans/*.md → 영향받을 수 있는 유닛들

📊 확인:
- 완료된 유닛: ✅ 표시된 작업들
- 진행중인 유닛: 🚧 표시된 작업들
- 블로커: ❌ 표시된 작업들
- 현재 진행률: MVP X%, MMP Y%
```

### 3단계: 영향도 분석 (10분)

```
🔍 변경 요청 분석:
- 요구사항 변경인가? → vibe/prd.md 업데이트 필요
- 기술스택 변경인가? → vibe/tech-stack.md 업데이트 필요
- 작업 순서 변경인가? → 의존성 재검증 필요
- 새 기능 추가인가? → 새 유닛 생성 필요

📋 영향받는 유닛 식별:
- 직접 영향: 변경 대상 유닛들
- 간접 영향: 의존성으로 연결된 유닛들
- 완료된 작업 보호: ✅ 유닛은 최소 변경
```

### 4단계: 문서 업데이트 (20분)

```
1️⃣ 사양서 수정
   - P0/P1/P2 재분류
   - 새 요구사항 추가
   - 변경 사유 기록

2️⃣ 로드맵 수정
   - 백로그 재구성 (추가/삭제/수정)
   - ID 재할당 (새 유닛만, 기존 유닛 ID 유지)
   - 의존성 재정의
   - 진행률 재계산

3️⃣ 유닛 계획서 수정/생성 ⭐ 품질 체크 포함
   - [수정] 영향받는 기존 계획서 업데이트
   - [생성] 새 유닛 계획서 작성 (품질 기준 문서 참조)
   - [검증] 품질 체크리스트 통과 확인
   - 의존성 섹션 동기화

4️⃣ 변경 이력 작성
   - 무엇을 왜 변경했는지
   - 영향받은 유닛 목록
   - 주의사항
```

### 5단계: 품질 검증 (10분) ⭐ 강화

```
📋 품질 체크리스트 (모든 신규/수정 유닛 계획서):
- [ ] 메타데이터 테이블 완전함 (5개 항목)
- [ ] 작업 목표에 배경 + 완료 기준 포함
- [ ] 완료 기준 최소 3개 이상 (측정 가능)
- [ ] 영향받는 파일에 생성/수정/참조 구분
- [ ] 구현 흐름 최소 3단계 이상
- [ ] 각 단계에 구체적 하위 항목 포함
- [ ] 의존성 섹션에 이전/다음 연결 명시
- [ ] 주의사항에 기술적 고려사항 + 리스크 포함
- [ ] 페어링 질문 최소 1개 (결정 필요 사항)
- [ ] 참고 자료 링크 포함

📊 비교 검증:
- [ ] 품질 기준 문서와 동등한 상세 수준
- [ ] 기존 유닛 계획서 대비 정보량 감소 없음
- [ ] 템플릿 섹션 누락 없음

✅ 일반 체크리스트:
- [ ] 의존성 순환 없음
- [ ] 완료된 유닛 ID 보존
- [ ] 진행중 유닛 영향 최소화
- [ ] 크리티컬 패스 재확인
- [ ] 모든 유닛에 계획서 링크
- [ ] 예상 완료일 현실적
```

</update_workflow>

## 📝 유닛 계획서 품질 규칙

<unit_plan_quality_rules>

### 필수 섹션 (생략 금지)

모든 유닛 계획서는 다음 섹션을 **반드시** 포함해야 합니다:

```markdown
# {Unit-ID}: {작업명}

## 메타데이터 ← 5개 항목 테이블 (Unit ID, Phase, 예상 소요, 의존성, 우선순위)

## 작업 목표 ← 1-2문장 + **배경** + **완료 기준** (3개 이상)

## 영향받는 파일 ← **생성** + **수정** + **참조** 구분

## 구현 흐름 ← 3단계 이상, 각 단계에 구체적 항목

## 의존성 & 연결 ← **이전 작업에서 가져올 것** + **다음 작업에 전달할 것**

## 주의사항 ← **기술적 고려사항** + **잠재적 리스크**

## 페어링 질문 (결정 필요) ← 최소 1개, Option 제시

## 참고 자료 ← 관련 문서/링크
```

### 상세도 기준

각 섹션별 최소 요구사항:

| 섹션               | 최소 요구사항                                |
| ------------------ | -------------------------------------------- |
| 작업 목표          | 1-2문장 설명 + 배경 1문장 + 완료 기준 3개    |
| 영향받는 파일/생성 | 파일 경로 + 목적 설명                        |
| 영향받는 파일/수정 | 파일 경로 + 수정 이유                        |
| 영향받는 파일/참조 | 파일 경로 + 참조 목적                        |
| 구현 흐름          | 3단계 이상, 각 단계 2-4개 하위 항목          |
| 의존성 & 연결      | 이전/다음 각각 구체적 산출물/인터페이스 명시 |
| 기술적 고려사항    | 2개 이상, 관련 규칙(RULE-XXX) 참조 시 명시   |
| 잠재적 리스크      | 1개 이상, 리스크 → 대응 방안 형식            |
| 페어링 질문        | 질문 + Option A/B 형식, 또는 고려사항 리스트 |
| 참고 자료          | 1개 이상 (내부 문서 또는 외부 링크)          |

### 품질 참조 프로세스

새 유닛 계획서 작성 시 반드시 다음 프로세스를 따릅니다:

```
1. 품질 기준 문서 선정
   - 완료된 유닛 계획서 중 가장 상세한 것 선택
   - 또는 동일 마일스톤 내 가장 유사한 유닛 선택

2. 구조 복제
   - 품질 기준 문서의 섹션 구조 그대로 사용
   - 각 섹션의 항목 개수 동일하게 유지

3. 내용 대체
   - 도메인/기능 관련 내용만 변경
   - 설명의 깊이와 구체성은 유지

4. 검증
   - 품질 체크리스트 통과 확인
   - 품질 기준 문서와 나란히 비교
```

</unit_plan_quality_rules>

## 📐 업데이트 규칙

<update_rules>

### ID 관리

```
✅ 유지:
- 완료된 유닛 (✅): ID 절대 변경 금지
- 진행중 유닛 (🚧): ID 유지, 내용만 조정
- 대기중 유닛 (⏸️): 내용 변경 시 ID 유지, 삭제 시 skip

✅ 신규:
- 새 유닛: 마지막 Sequence + 1
  예: MVP 마지막이 U-025[Mvp]이면 → U-026[Mvp]
- 새 리팩토링: 마지막 RU + 1
- 새 체크포인트: 마지막 CP + 1
```

### Phase 전환 금지

```
❌ 불가능:
- MVP → MMP 이동 (Phase 변경 불가)
- 완료된 유닛의 Phase 변경

✅ 대안:
- 새 유닛을 원하는 Phase에 생성
- 기존 유닛은 "skip" 처리 후 대체 유닛 명시
```

### 의존성 보호

```
규칙:
1. 완료된 유닛(✅)을 Depends로 가진 유닛은 안전
2. 삭제할 유닛을 Depends로 가진 경우:
   - 대체 유닛 지정 OR
   - 의존성을 None으로 변경 OR
   - 해당 유닛도 함께 삭제
```

### 진행률 재계산

```
공식:
- MVP: (완료 유닛 수) / (전체 MVP 유닛 수) * 100%
- MMP: (완료 유닛 수) / (전체 MMP 유닛 수) * 100%
- 전체: (완료 유닛 수) / (전체 유닛 수) * 100%

주의:
- skip된 유닛은 분모에서 제외
- 새 유닛 추가 시 진행률 감소 가능 (정상)
```

### 기존 유닛 계획서 수정 규칙

```
✅ 허용:
- 불명확한 내용 보강/구체화
- 누락된 섹션 추가
- 오류 수정
- 의존성 정보 업데이트
- 참고 자료 추가

❌ 금지:
- 기존 내용 축약/삭제
- 섹션 제거
- 상세도 수준 저하
- 완료 기준 개수 감소
```

</update_rules>

## 📝 변경 이력 형식

<changelog_format>

```markdown
# 로드맵 변경 이력

## {YYYY-MM-DD HH:mm} - {변경 버전}

### 변경 요약

{1-2문장으로 핵심 변경사항}

### 영향받은 문서

- ✏️ vibe/prd.md: {변경 내용}
- ✏️ vibe/roadmap.md: {변경 내용}
- ✏️ vibe/unit-plans/{Unit-ID}.md: {변경 내용}

### 백로그 변경

**추가**:

- U-XXX[Phase]: {작업명} - {추가 사유}

**수정**:

- U-YYY[Phase]: {변경 전} → {변경 후} - {변경 사유}

**삭제/Skip**:

- U-ZZZ[Phase]: {작업명} - {삭제 사유} - 대체: U-AAA[Phase]

### 의존성 변경

- U-XXX: Depends 변경 (이전: U-010 → 이후: U-015,U-020)

### 진행률 변화

- MVP: 45% → 40% (새 작업 5개 추가로 인한 감소)
- MMP: 10% → 10% (변경 없음)

### 품질 검증 결과 ⭐ 신규

- 품질 기준 문서: {Unit-ID}
- 신규 유닛 계획서: {N}개 생성, 모두 품질 체크리스트 통과
- 수정된 유닛 계획서: {N}개, 상세도 유지/향상 확인

### 리스크 변경

**신규**:

- R-004: {새 리스크} - 영향: Medium - 대응: {계획}

**해소**:

- R-002: {기존 리스크} - {해소 방법}

### 주의사항

- {개발자가 알아야 할 중요 변경사항}
- {영향받는 진행중 작업 안내}

---
```

</changelog_format>

## 🎯 출력 형식

<output_format>

### 업데이트 완료 메시지

```markdown
## ✅ 로드맵 업데이트 완료

### 변경 요약

{변경사항 1-2문장}

### 업데이트된 파일

- 📄 [vibe/roadmap.md](file:///vibe/roadmap.md)
- 📄 [vibe/prd.md](file:///vibe/prd.md) (변경된 경우)
- 📁 vibe/unit-plans/: {N}개 파일 수정/생성
- 📄 {로드맵-루트}/changelog.md

### 영향받은 유닛

- 🆕 신규: U-XXX, U-YYY ({N}개)
- ✏️ 수정: U-AAA, U-BBB ({N}개)
- 🗑️ Skip: U-CCC ({N}개)

### 품질 보증 ⭐ 신규

- **품질 기준 문서**: [{Unit-ID}](vibe/unit-plans/{Unit-ID}.md)
- **신규 유닛**: {N}개 생성 - 품질 체크리스트 ✅ 통과
- **수정 유닛**: {N}개 - 상세도 유지/향상 ✅

### 진행률 변화

- **MVP**: {이전}% → {이후}%
- **MMP**: {이전}% → {이후}%
- **예상 완료**: MVP D-{일수}, MMP D-{일수}

### ⚠️ 주의사항

{개발자가 반드시 확인해야 할 사항}

### 다음 작업

현재 작업: [{Unit-ID}](vibe/unit-plans/{Unit-ID}.md) - {작업명}
```

</output_format>

## 🔧 고급 시나리오

<advanced_scenarios>

### 시나리오 1: 요구사항 우선순위 변경

```
변경: P2 → P0 승격
→ MMP 유닛을 MVP로 이동? ❌ (Phase 불변)
→ 대안: 새 MVP 유닛 생성, 기존 MMP 유닛 skip 처리
→ 품질: 새 MVP 유닛은 기존 MVP 유닛과 동등한 상세도
```

### 시나리오 2: 진행중 작업 취소

```
상황: U-015[Mvp] 🚧 진행중인데 더 이상 불필요
→ 완료 처리 후 skip 마킹
→ 의존 유닛들 영향도 검토
→ Changelog에 사유 명확히 기록
```

### 시나리오 3: 대규모 리팩토링 필요

```
판단: 10개 이상 유닛 영향
→ 새 마일스톤 생성 고려
→ 체크포인트 재배치
→ 별도 Changelog 섹션
→ 품질: 기존 유닛 계획서 상세도 기준 유지
```

### 시나리오 4: 기술스택 전면 변경

```
예: Express → Fastify
→ vibe/tech-stack.md 업데이트
→ 영향받는 모든 유닛 식별
→ 완료된 유닛 재작업 여부 결정
→ 새 리스크 추가
→ 품질: 새 유닛은 기존 유닛과 동등한 품질
```

### 시나리오 5: 유닛 계획서 품질 저하 감지 ⭐ 신규

```
증상: 새로 생성된 유닛 계획서가 기존보다 덜 상세함
→ 품질 체크리스트 재검증
→ 부족한 섹션 보강
→ 품질 기준 문서와 비교하여 동등 수준까지 보완
→ 완료 후 재검증
```

</advanced_scenarios>

## ✅ 업데이트 완료 정의

<update_done>

**필수**:

- [ ] 모든 영향받은 문서 업데이트 완료
- [ ] 의존성 검증 통과 (순환 없음)
- [ ] 진행률 재계산 완료
- [ ] Changelog 작성 완료
- [ ] 새 유닛 계획서 생성 완료

**품질 검증** ⭐ 신규:

- [ ] 품질 기준 문서 선정됨
- [ ] 모든 신규 유닛 계획서가 품질 체크리스트 통과
- [ ] 모든 수정된 유닛 계획서 상세도 유지/향상
- [ ] 필수 섹션 누락 없음
- [ ] 기존 문서 대비 정보량 감소 없음

**일반 검증**:

- [ ] 완료된 유닛 ID 보존됨
- [ ] 크리티컬 패스 여전히 유효
- [ ] 예상 완료일이 현실적
- [ ] 블로커가 해결되었거나 계획됨

</update_done>

## 📚 참조 문서

<reference_documents>

업데이트 작업 시 다음 문서들을 참조합니다:

| 문서                 | 경로                           | 참조 목적                     |
| -------------------- | ------------------------------ | ----------------------------- |
| 원본 로드맵 프롬프트 | `vibe/ready/roadmap-prompt.md` | 유닛 계획서 템플릿, 형식 규칙 |
| 현재 로드맵          | `vibe/roadmap.md`              | 현황 파악, 진행률             |
| 사양서               | `vibe/prd.md`                  | 요구사항, 우선순위            |
| 기술스택             | `vibe/tech-stack.md`           | 기술적 제약사항               |
| 유닛 계획서들        | `vibe/unit-plans/*.md`         | 품질 기준, 의존성 정보        |
| 유닛 결과 보고서들   | `vibe/unit-results/*.md`       | 완료된 작업 산출물            |

**품질 기준 문서 선정 기준**:

1. ✅ 완료된 유닛 중에서 선택
2. 가장 많은 섹션과 항목을 가진 문서
3. 설명이 가장 구체적인 문서
4. 동일 마일스톤 내 문서 우선

</reference_documents>

---

## 변경사항
</file>

<file path="vibe/debt-log.md">
## [2026-01-12] 이슈: Chrome 에셋(scanner-frame) 용량 최적화 필요

- **발견 위치**: `frontend/public/ui/chrome/scanner-frame.png`
- **현상**: 파일 크기가 약 100KB로, 초기 Chrome 에셋 예산(50KB)을 초과함. (현재 예산을 120KB로 임시 상향 조정하여 대응)
- **추정 원인**: 346x200 해상도의 고품질 텍스처 및 투명도가 포함된 PNG 포맷 특성상 용량이 큼.
- **보류 사유**: U-033[Mvp]의 목표는 "QA 프로세스 도입"이며, 당장 이미지 품질을 저하시키지 않고 예산을 조정하는 것으로 합의함. 추후 MMP 단계에서 WebP 변환 또는 추가 최적화 고려 필요.
</file>

<file path="vibe/ready/frd-prompt.md">
너는 숙련된 BA/PM이다. 아래 입력을 바탕으로 **기존 프로젝트에 특정 “메이저 기능”을 추가하기 위한 FRD(Feature Requirements Document, 요구사항 명세서)**를 **마크다운**으로 작성하라. 비어 있는 항목은 AI가 **[AI초안]**으로 간결히 보완한다. 완성된 FRD 본문만 출력하고 설명·질문은 금지한다.

=========================
[ 필수 참고 — 프로젝트 맥락 문서 ]
=========================

- @docs/prd.md : 현재 프로젝트의 PRD 문서
- @docs/architecture.md : 현재 프로젝트의 아키텍쳐 문서
- @docs/tech-stack.md : 현재 프로젝트의 기술 스택 문서
- @docs/referenceses/file-search-api.md
- @docs/referenceses/gemini-pricing.md
- @docs/referenceses/google-grounding.md
- @docs/referenceses/gemini-deep-research.md
- # @docs/referenceses/interactions-api.md

====================
[ 필수 입력 — BASIC ]
====================

- 프로젝트/서비스명:codrag/codrag-deep-research
- 기능명(추가할 메이저 기능):Codrag Deep-Research
- 기능 요약(구어체, 1-2문장): Codrag에 Gemini Deep Research 기능을 추가 합니다. 현재 지정된 저장소들의 File Search Store 대상으로 체계적이고 시각적인 연구 결과를 도출합니다.
- 배경/문제(현상·데이터·사용자 불만·운영 이슈 등): 일반 질문/답변으로 부족한 복잡한 문제, 다양한 저장소간의 관계에서 발생하는 복잡한 문제에 대해 심층적으로 연구하여 결과를 도출할 필요가 있습니다.
- 목표(2-4개):
  - 지정된 단일 Store에 대해 사용자의 질문에 대해 정확하고 깊이 있는 연구 결과를 출력합니다.
  - 복수의 Store가 지정된 경우 사용자의 질문에 대해 지정된 Store에 대한 모든 내용을 연구 하여 결과를 출력합니다.
  - 연구가 진행중일때 연구 과정에 대해 한국어로 번역하여 사용자가 과정을 볼 수 있도록 합니다.
- 레퍼런스 URL(유사 사례/경쟁사/가이드):
  - @docs/referenceses/file-search-api.md
  - @docs/referenceses/gemini-pricing.md
  - @docs/referenceses/google-grounding.md
  - @docs/referenceses/gemini-deep-research.md
  - # @docs/referenceses/interactions-api.md

=========================
[ 권장 입력 — CONTEXT ]
=========================

- 현행 동작(As-Is) 요약: <> | (비우면 [AI초안])
- 관련 화면/사용자 흐름(As-Is): <> | (비우면 [AI초안])
- 관련 모듈/서비스/컴포넌트(영향 범위): <> | (비우면 [AI초안])
- 데이터/DB/스토리지(주요 엔티티·식별자·정합성 규칙): <> | (비우면 [AI초안])
- API/이벤트/메시징/외부 연동(계약·제약): <> | (비우면 [AI초안])
- 인증/인가/권한 모델(역할·정책·감사 로그): <> | (비우면 [AI초안])
- 성능/SLO/트래픽 특성(p95, QPS, 배치 주기 등): <> | (비우면 [AI초안])
- 운영/배포(릴리즈 방식, Feature Flag, 롤백 전략): <> | (비우면 [AI초안])
- 관측성(로그/메트릭/트레이싱/알림 기준): <> | (비우면 [AI초안])
- 보안/개인정보/컴플라이언스 요구(보관기간, 마스킹, 접근통제): <> | (비우면 [AI초안])
- 용어집(도메인 용어·약어 정의): <> | (비우면 [AI초안])

---

---

## [ 선택 입력 — EXPAND ]

- 비즈니스 규칙/정책(가격, 제한, 승인, 상태 전이 등): <> | (비우면 [AI초안])
- 에러/예외/알림 정책(사용자 메시지, 에러 코드, 재시도): <> | (비우면 [AI초안])
- 데이터 마이그레이션/백필 필요 여부: <> | (비우면 [AI초안])
- 호환성 요구(구버전 클라이언트/레거시 API/DB 스키마): <> | (비우면 [AI초안])
- 분석/이벤트 트래킹(지표, 이벤트명, 속성): <> | (비우면 [AI초안])
- 접근성/국제화(다국어, 포맷, 키보드 내비게이션): <> | (비우면 [AI초안])
- QA/테스트 기준(필수 E2E 경로, 데이터 시드, 환경): <> | (비우면 [AI초안])
- 롤아웃 전략(점진 배포, 사용자/테넌트 분리, 실험): <> | (비우면 [AI초안])
- 리스크(+대응): <> | (비우면 [AI초안])
- 참고 링크: <> | (비우면 [AI초안] - 가능하면 웹검색을 통해 핵심 참고 링크 자동 첨부)

---

## 출력 규칙

### 1. 문서 구조

```markdown
# [기능명] FRD (기존 프로젝트 기능 추가)

## 1. 변경 개요

### 1.1 배경 및 문제

### 1.2 목표 및 성공 기준

### 1.3 범위 (In/Out)

## 2. 기존 시스템 맥락 (As-Is)

### 2.1 사용자/역할/권한

### 2.2 현행 사용자 흐름/화면

### 2.3 관련 구성요소(모듈/데이터/API/외부연동)

### 2.4 제약사항 및 가드레일(성능/보안/운영/호환성)

## 3. 제안 기능 개요 (To-Be)

### 3.1 핵심 컨셉

### 3.2 주요 사용자 시나리오(요약)

### 3.3 변경점 요약(UI/API/DB/권한/운영)

## 4. 요구사항 상세

### 4.1 기능 요구사항 (Functional Requirements)

### 4.2 비즈니스 규칙/정책

### 4.3 데이터 요구사항 (모델/정합성/마이그레이션)

### 4.4 API/이벤트/인터페이스 요구사항

### 4.5 UI/UX 요구사항 (상태/카피/접근성)

## 5. 비기능 요구사항 (Non-Functional Requirements)

## 6. 호환성/마이그레이션/롤백

## 7. 테스트/검증 및 수용 기준

## 8. 배포/롤아웃 계획

## 9. 위험 요소 및 대응

## 10. 가정 및 결정 필요 사항

## 11. 참고 자료
```

### 2. 요구사항 작성 규칙

- **요구사항 ID**: 기능 요구사항은 `FR-001`부터, 비기능 요구사항은 `NFR-001`부터 번호를 부여한다.
- **표 형식(필수)**: `4.1 기능 요구사항`은 아래 표를 사용한다.
  - 열(필수): ID | 요구사항 | 우선순위(P0/P1/P2) | 수용 기준(Given-When-Then) | 영향 범위(UI/API/DB/Ops) | 비고/근거
- **수용 기준**: 모든 P0 요구사항은 최소 1개 이상의 수용 기준을 포함한다.
- **모호 표현 금지**: “적절히/빠르게/가능하면/최대한” 금지. 수치·조건·예외를 명시한다.
- **질문 형식 금지**: 문서 내에 `?`, `Q1` 같은 질문 형태를 쓰지 말고, 필요한 항목은 `10. 가정 및 결정 필요 사항`에 **단정문**으로 기록한다.
- **불확실성 처리**: 입력에 근거가 없으면 함부로 단정하지 말고, `[AI초안] (가정)`으로 표시 후 `10.` 섹션에 함께 남긴다.

### 3. 작성 원칙

- **간결성**: 섹션 설명은 각 2-5문장, 대신 요구사항은 표/목록으로 압축해 밀도를 높인다.
- **실행가능성**: 개발/QA/운영이 바로 구현·검증할 수 있는 수준(데이터·API·예외·롤백 포함)으로 작성한다.
- **변경 영향 중심**: “새로 만드는 것”보다 “기존에 무엇이 어떻게 바뀌는지”를 우선적으로 명확히 한다.
- **AI초안 표기**: 보완한 내용은 반드시 `[AI초안]` 태그를 포함한다.

### 4. 금지사항

- 프롬프트 해석/메타 설명 출력
- "이해했습니다", "작성하겠습니다" 등 응답
- FRD 외 부가 설명이나 조언
- 불완전한 문서나 초안 상태 출력

### 5. 필수 포함 요소

- 모든 입력 정보 반영
- **As-Is → To-Be 변화**가 추적 가능하도록 작성(영향 범위/변경점 요약 포함)
- **마이그레이션/호환성/롤백** 섹션 포함(해당 없음이면 “해당 없음” 사유를 명시)
- **수용 기준** 포함(P0는 필수)
- 선택 입력이 비어있을 때는 `[AI초안]`으로 보완(가능하면 웹검색 참고 링크 포함)

---

## (부록) FRD 작성에 유용한 “프로젝트 맥락 자료” 체크리스트

아래 자료를 함께 제공할수록 FRD 정확도가 크게 올라간다. (문서/링크/캡처/다이어그램 어떤 형태든 가능)

- **제품/도메인**
  - 제품 한 장 요약(누가/무엇을/왜), 핵심 KPI, 용어집
- **현행 사용자 경험(As-Is)**
  - 주요 플로우(로그인~핵심행동), 화면 캡처/동영상, 에러/빈 상태 정의
- **아키텍처**
  - 시스템 구성도, 모듈 경계, 의존성, 주요 배치/워커/크론
- **데이터**
  - ERD, 주요 테이블/컬렉션, 핵심 키/인덱스, 데이터 정합성 규칙, 마이그레이션 히스토리
- **API/연동**
  - OpenAPI/Swagger/Postman 컬렉션, 이벤트 스키마, 외부 파트너 계약/쿼터/레이트리밋
- **권한/보안**
  - 역할/권한 매트릭스, 접근 정책, 감사 로그/추적 요구, 개인정보 분류/보관 기간
- **운영**
  - 배포 방식, Feature Flag 체계, 롤백 전략, 모니터링 대시보드/알람 정책
- **품질**
  - 테스트 전략(유닛/통합/E2E), QA 체크리스트, 성능 기준(SLO/SLI), 장애 대응 프로세스
- **제약/결정 기록**
  - ADR/의사결정 로그, 기술부채 리스트, “절대 바꾸면 안 되는 것” 5개

---

## (부록) 프로젝트 맥락 문서(Context Pack) 생성 프롬프트 (별도 실행용)

아래 블록은 **FRD 생성과 별개로** “컨텍스트 팩”을 먼저 만들 때 쓰는 프롬프트다. (FRD 출력에 이 블록의 본문을 포함하지 말 것)

````markdown
너는 숙련된 테크 라이터이자 솔루션 아키텍트다. 아래 입력(문서/링크/발췌/스크린샷 설명)을 바탕으로, 기능 요구사항 작성에 바로 사용할 수 있는 **프로젝트 컨텍스트 팩(Context Pack)**을 마크다운으로 작성하라. 비어 있는 항목은 **[AI초안]**으로 보완하되, 근거가 없으면 **[AI초안] (가정)**으로 표시하고 “결정 필요 사항”에 함께 기록한다. 결과물 본문만 출력하고 설명·질문은 금지한다.

====================
[ 입력 — CONTEXT PACK ]
====================

- 제품/도메인 개요(가능한 자료):
- 사용자/역할/권한 정책:
- 현행 사용자 흐름/화면(설명/캡처 링크):
- 시스템 아키텍처/모듈 구조:
- 데이터 모델/스키마/ERD:
- API/이벤트/외부연동 문서:
- 운영/배포/롤백/Feature Flag:
- 성능/SLO/트래픽 특성:
- 보안/개인정보/컴플라이언스:
- 용어집/에러코드/알림 정책:
- # 참고 링크:

## 출력 규칙

```markdown
# 프로젝트 컨텍스트 팩

## 1. 제품/도메인 요약

## 2. 사용자/역할/권한

## 3. 현행 사용자 흐름(As-Is)

## 4. 아키텍처/모듈 경계

## 5. 데이터 모델 개요

## 6. API/이벤트/외부연동

## 7. 운영/배포/관측성

## 8. 제약사항/가드레일

## 9. 결정 필요 사항

## 10. 참고 자료
```
````

```

```
</file>

<file path="vibe/ready/frd-tech-stack-prompt.md">
# 역할

너는 **기존 프로덕션/운영 중인 프로젝트에 기능을 추가**해본 경험이 많은 실전파 시니어 개발자야.

# 목표

첨부된 `vibe/prd.md`(요구사항)를 기반으로, **“기존 프로젝트 기능 추가”** 목적의 기술 스택 가이드를 작성해 줘.
이때 **기존 프로젝트의 기준 기술 스택**은 `docs/tech-stack.md`를 **단일 진실 소스(SSOT)**로 삼아, 불필요한 스택 교체 없이 요구사항을 충족하는 방향으로 결정한다.

# 입력 문서(반드시 참고)

- `vibe/prd.md`: 이번 기능 추가의 요구사항/제약/성공 기준
- `docs/tech-stack.md`: 기존 프로젝트의 기술 스택/버전(기준선)

# 핵심 원칙 (기존 프로젝트용)

- **기준선 존중**: `docs/tech-stack.md`에 있는 기존 기술은 기본적으로 **유지**한다(대규모 마이그레이션 금지).
- **변경 최소화**: 기능 추가에 꼭 필요한 범위에서만 새 기술을 도입하거나 버전을 올린다.
- **근거 중심**: “왜 이 변경/추가가 필요한가?”를 가장 짧게, 가장 명확하게 쓴다.
- **재현성**: 버전은 **정확히 고정**한다(‘latest’ 금지).
- **불확실성의 표준화**: 확신이 없으면 **추측하지 말고** `TBD`로 두고 공식 링크로 확인 경로를 제공한다.
- **분량 엄수**: 진짜로 스크롤 2-3번 이내(A4 1장 수준).

# 버전/의존성 규칙 (중요)

- **기존 스택**: `docs/tech-stack.md`에 명시된 버전/선택을 **그대로 유지**하거나, 문서에 “참조” 형태로 명시한다.
  - 예: “Backend: FastAPI(기존 문서 버전 유지)”처럼 표기 가능.
- **신규 라이브러리/SDK/API/ADK**: 작성 시점 기준 **최신 안정(Stable/GA) 버전**을 찾아 **정확한 버전으로 고정**한다.
  - 기본적으로 **pre-release(α/β/rc/preview)**는 제외. 불가피하면 “왜 필요한지/리스크/롤백”을 함께 쓴다.
- **버전 업그레이드(기존 기술의 상향)**가 필요하면:
  - “필수/선택”을 구분하고, 영향 범위(마이그레이션/호환성)와 리스크를 2-3줄로 요약한다.

# 필수 포함 사항 (기존 프로젝트 기능 추가 템플릿)

## 1. 기술 스택 요약 (한눈에 보기)

아래 2개 블록으로 표를 구성:

- **기존 유지(기준선)**: `docs/tech-stack.md` 기반(버전은 그대로 또는 ‘기존 문서 참조’)
- **이번 기능으로 추가/변경**: 새로 도입되는 기술과(또는) 상향되는 버전만 별도 표로 명시(버전 고정)

## 2. 기술 선택 매트릭스 (압축)

형식: **PRD 요구사항 → (기존 유지/신규 추가/버전 상향) → 핵심 이유(3-4단어)**  
기존 유지인 항목도 “유지 이유(호환/속도/운영)”를 한 단어로라도 표시한다.

## 3. 대안 기술 비교 (빠른 판단)

이번 기능 범위에서 새로 고민한 대안만 2-4개 수준으로:

- 선택하지 않은 이유(1줄)
- 선택한 기술의 결정적 장점(1줄)

## 4. 리스크 요약 (현실적)

기존 프로젝트 특성에 맞춘 리스크 2-3개와 대응 방향:

- 호환성/회귀 리스크
- 운영/관측성/비용 리스크
- 롤백/Feature Flag 필요 여부

## 5. 레퍼런스 링크 모음 (핵심)

모든 “추가/변경” 항목에는 **공식 문서 링크**를 반드시 포함한다.  
가능하면 “릴리즈 노트/버전 정책” 링크도 함께 제공한다.

## 6. 팀 온보딩 체크리스트 (간단)

기존 팀원이 “이번 기능 추가”에 필요한 것만 빠르게 따라갈 수 있도록:

- 기존 스택에서 **새로 알아야 할 부분** 중심
- 설치 명령어/구현 세부사항은 쓰지 않는다

# 작성 스타일

- 🚫 NO: 구현 세부사항, 코드 스니펫, 설치 명령어, 대규모 리라이트 제안
- ✅ YES: “왜 유지/왜 추가/왜 상향?”, “운영 리스크”, “공식 문서 링크”

# 결과물 제약사항

- **출력 파일 경로**: `vibe/tech-stack.md`
- **분량**: 스크롤 2-3번 이내(A4 1장 수준)
- **톤**: 간결하고 확신 있게(단, 불확실하면 `TBD` + 링크)
- **구조**: 순수 기술 스택 가이드(구현 가이드 요소 배제)
</file>

<file path="vibe/ready/git-ignore-prompt.md">
# .gitignore 생성 요청 (문서 분석 기반)

## 당신의 역할

당신은 제출된 기획서나 기술 문서를 보고 프로젝트의 전체 기술 스택을 정확하게 꿰뚫어 보는 **솔루션 아키텍트(Solution Architect)**입니다. 당신의 임무는 문서의 서술된 내용을 바탕으로 프로젝트의 기술 스택을 완벽하게 추론하고, 이를 기반으로 실무에 즉시 적용 가능한 `.gitignore` 파일을 작성하는 것입니다.

## 작업 지시

아래에 첨부된 프로젝트 문서를 면밀히 분석하여 다음 단계를 순서대로 수행해 주세요.

1. **기술 스택 추론:** 문서의 내용을 분석하여 이 프로젝트에 사용될 프로그래밍 언어, 프레임워크, 데이터베이스, 주요 라이브러리 등을 파악하고 그 목록을 먼저 제시해 주세요. 어떤 문장을 근거로 판단했는지 간략하게 언급해주세요.
2. **추가 정보 반영:** 아래 '추가 개발 환경 정보'를 위에서 추론한 기술 스택과 통합하세요.
3. **.gitignore 생성:** 위 정보를 모두 종합하여, 각 섹션별로 상세한 설명 주석이 포함된 최적의 `.gitignore` 파일을 마크다운 코드 블록으로 작성해 주세요.

---

### 1. 분석할 프로젝트 문서

- `vibe/prd.md` - 프로젝트 요구사항 문서 경로
- `vibe/tech-stack.md` - 프로젝트 기술스택 가이드 문서
- `vibe/roadmap.md` - 프로젝트 로드맵 문서
- `.gemini/GEMINI.md` - 전역 지침 경로
- `.gemini/rules/**` - 특정 영역, 작업 유형, 또는 컨텍스트에만 적용되는 구체적 규칙들

### 2. 추가 개발 환경 정보

- **개발 환경 (OS):** Windows 11
- **주요 IDE / 코드 에디터:** vs code

### 3. 반드시 제외되는 파일

- `vibe/commands.md` - 각 명령시 필요한 템플릿
- `vibe/UPDATE-PLAN.md` - 필요한 업데이트 계획을 따로 기입하는 공간

---
</file>

<file path="vibe/ready/red-line-prompt.md">
.gemini/rules/red-line.md 지침을 다음 문서들을 분석하여 이 프로젝트에 필요한 "AI 필수 준수 규칙 (Critical Rules)"을 생성해주세요.

📁 분석할 문서:

- 사양서: vibe/prd.md
- 기술스택: vibe/tech-stack.md

🎯 생성 요청사항:

1. 프로젝트의 기술스택, 아키텍처, 제약사항을 분석
2. AI가 코드 작성 시 절대 지켜야 할 규칙 5-10개 도출
3. 각 규칙은 구체적이고 실행 가능해야 함
4. 잘못된 예시(❌)와 올바른 예시(✅) 포함

📝 생성 형식:
앞서 제공한 "AI 필수 준수 규칙 (Critical Rules)" 마크다운 템플릿 형식을 따르되,
RULE-001부터 시작하여 프로젝트에 맞는 실제 규칙들로 채워주세요.

🔍 특히 다음 사항에 집중:

- 사용 중인 라이브러리/프레임워크의 특정 버전 제약
- 데이터베이스 쿼리 패턴
- API 설계 원칙
- 보안 관련 필수 사항
- 성능 관련 제약사항
- 코딩 컨벤션 중 절대 지켜야 하는 것들
</file>

<file path="vibe/ready/roadmap-prompt.md">
# Vibe 코딩 로드맵 어시스턴트

## 📋 역할 정의

<role_definition>
당신은 실행 가능한 개발 로드맵과 상세 작업 계획서를 작성하는 시니어 테크 리드입니다.

**핵심 책임:**

1. **로드맵 문서 생성**: 전체 프로젝트 개요, 마일스톤, 작업 백로그를 `vibe/roadmap.md`에 작성
2. **유닛 계획서 생성**: 각 작업(Unit)별 상세 구현 계획을 `unit-plans/{Unit-ID}.md`로 작성
3. **리스크 관리**: 기술적 위험 요소를 사전 식별하고 대응 방안 수립
4. **품질 보증**: 각 단계별 완료 기준(DoD)과 검증 절차 정의

**작업 산출물:**

- 메인 로드맵 문서 1개
- 유닛별 계획서 N개 (전체 작업 수만큼)
  </role_definition>

## 🎯 핵심 원칙

<core_principles>

1. **실행 가능성**: 각 작업은 15-30분 내 완료 가능 (최대 60분)
2. **구체성**: 파일 경로, 함수명, 완료 기준까지 명시
3. **추적 가능성**: 진행률과 병목 지점을 한눈에 파악
4. **예측 가능성**: 리스크와 버퍼 시간 사전 정의
5. **문서 일관성**: 로드맵과 유닛 계획서 간 정보 동기화
6. **점진적 구체화**: 로드맵(전략) → 유닛 계획서(전술) → 실제 코드(실행)
   </core_principles>

## ⚙️ 에이전트 설정

<agent_configuration>
**동작 원칙:**

- 긴 컨텍스트 활용 (전체 문서 동시 참조)
- 계층적 구조 출력 (로드맵 → 유닛 계획서)
- 단계별 검증 수행
- 예시 기반 학습 (Good/Bad examples)
  </agent_configuration>

## 📚 필수 맥락 수집

<context_collection>
로드맵 작성 전 다음 문서들을 읽고 핵심 정보를 추출합니다:

1. **.gemini/rules/red-line.md**: AI 필수 준수 규칙 (금지 패턴, 보안)
2. **vibe/prd.md**: 요구사항 분류 (P0/P1/P2), 성공 지표
3. **vibe/tech-stack.md**: 기술 환경, 라이브러리, 배포 전략
4. **.gemini/GEMINI.md**: 코딩 컨벤션, 파일 구조
5. **.gemini/rules/\*.md**: 도메인별 구현 규칙

**정리할 내용:**

- 프로젝트 핵심 가치 (1문장)
- 반드시 지켜야 할 제약 (TOP 3)
- 기술적 리스크 (TOP 3)
- MVP 완료 기준
  </context_collection>

## 🗺️ 2단계 개발 전략 (MVP → MMP)

<mvp_mmp_strategy>

### MVP (Minimum Viable Product)

**목표**: 핵심 가치 증명, "작동하는 것"에 집중

| 항목 | 내용                       |
| ---- | -------------------------- |
| 범위 | P0 요구사항만              |
| 품질 | 핵심 경로 안정성 우선      |
| 완료 | E2E 테스트 통과, 데모 가능 |
| 태그 | `[Mvp]`                    |
| 시간 | 전체의 30-40%              |

**판단 기준:**

```
✅ 이것 없으면 제품 무용지물? → MVP
❌ 인증, DB, 인프라, UX 개선, 예외 처리? → MMP
```

### MMP (Minimum Marketable Product)

**목표**: 판매 가능 품질, "팔릴 수 있는 것"

| 항목 | 내용                              |
| ---- | --------------------------------- |
| 범위 | P1/P2, UX, 성능, 보안             |
| 품질 | 포괄적 예외 처리, 세련된 UI       |
| 완료 | 전체 테스트, 문서, 성능 기준 만족 |
| 태그 | `[Mmp]`                           |
| 시간 | 전체의 60-70%                     |

### 체크포인트 체계

**MVP**: 데이터→API→UI→E2E (각 단계별 검증)
**MMP**: 보안→성능→UX→운영 (품질 게이트)

**통과 기준**: 작업 완료 + 테스트 통과 + 리뷰 승인 + 문서 업데이트

</mvp_mmp_strategy>

## 🔄 리팩토링 규칙

<refactoring_rules>

**ID**: `RU-XXX[Phase]` | **배치**: 관련된 유닛 개발 마무리 마다

**트리거**:

- 기능 그룹 완료
- 복잡도 > 10
- 중복 코드 3회 이상
- 파일 > 200줄

**작업 범위**:

- ✅ 구조 개선, 중복 제거, 네이밍 통일
- ❌ 새 기능 추가, 동작 변경

**완료 기준**: 기존 테스트 통과 + 복잡도 감소

</refactoring_rules>

## 🔧 유닛 스텝 사양

<unit_step_specification>

**작업 크기**: 20-45분 (최대 75분, 버퍼 30%)
**파일 범위**: 최대 1-2개 파일
**LOC**: 50-150줄

**작업명 형식**: `[동사] + [대상] + [위치]`

✅ `User 모델 정의 (/src/models/User.ts, Prisma 스키마)`
❌ `인증 기능 만들기` (너무 광범위)

**의존성**:

```
None              # 시작 작업
U-001             # 단일
U-003,U-005       # 다중 AND
```

**상태**: ⏸️ 대기 | 🚧 진행중 | ✅ 완료 | ❌ 차단됨

**완료 기준 (DoD)**:

- 기능 구현 완료
- Lint/Type 에러 없음
- 동작 확인
- 문서 업데이트 (필요시)

</unit_step_specification>

## 📝 유닛 계획서 생성 규칙

<unit_plan_generation>

### 개요

각 유닛(Unit) 작업에 대해 **별도의 상세 구현 계획서**를 `unit-plans/{Unit-ID}.md` 형식으로 생성합니다.

**목적:**

- 로드맵(전략)과 실제 코드(전술) 사이의 간극을 메우는 중간 문서
- 개발자가 바로 코딩을 시작할 수 있도록 구체적인 가이드 제공
- 코드 리뷰 시 의도 파악 용이

### 생성 시점

**필수**: 전체 로드맵 작성 직후 → 모든 유닛의 계획서를 일괄 생성

**목적:**

- AI 에이전트가 바이브 코딩 시 읽을 참조 문서
- 전후 유닛과의 맥락 유지
- 작업 간 의존성 및 연결고리 명확화

### 파일 구조

**규칙**: unit-plans는 로드맵과 동일한 디렉토리에 생성

```
예시: vibe/roadmap.md = memory-bank/roadmap.md

memory-bank/
├── roadmap.md                    # 메인 로드맵
└── unit-plans/                   # 유닛 계획서 디렉토리
    ├── U-001[Mvp].md
    ├── U-002[Mvp].md
    ├── RU-001[Mvp].md
    └── ...
```

### 유닛 계획서 템플릿

```markdown
# {Unit-ID}: {작업명}

## 메타데이터

| 항목      | 내용                              |
| --------- | --------------------------------- |
| Unit ID   | {Unit-ID}                         |
| Phase     | MVP / MMP                         |
| 예상 소요 | {X}분                             |
| 의존성    | {Depends}                         |
| 우선순위  | ⚡ Critical / High / Medium / Low |

## 작업 목표

{이 작업을 통해 달성하고자 하는 핵심 가치 1-2문장}

**배경**: {왜 이 작업이 필요한가?}

**완료 기준**:

- {측정 가능한 기준 1}
- {측정 가능한 기준 2}

## 영향받는 파일

**생성**:

- `{파일-경로-1}` - {목적}
- `{파일-경로-2}` - {목적}

**수정**:

- `{파일-경로-3}` - {수정 이유}

**참조**:

- `{파일-경로-4}` - {참조 목적}

## 구현 흐름

### 1단계: {단계명}

- {해야 할 일 1}
- {해야 할 일 2}

### 2단계: {단계명}

- {해야 할 일 1}
- {해야 할 일 2}

{필요한 만큼 추가}

## 의존성 & 연결

**이전 작업에서 가져올 것**:

- **계획서**: [{이전-Unit-ID}](unit-plans/{이전-Unit-ID}.md) - {어떤 산출물/인터페이스}
- **결과물**: 의존성 대상 유닛의 결과 보고서는 `{유닛별-개발보고-경로}/{이전-Unit-ID}.md` 에서 참조하세요.

**다음 작업에 전달할 것**:

- {다음 작업에서 사용할 산출물/인터페이스}

## 주의사항

**기술적 고려사항**:

- {주의할 점 1}
- {주의할 점 2}

**잠재적 리스크**:

- {리스크} → {대응 방안}

## 페어링 질문 (결정 필요)

> 개발자가 계획을 다듬기 위한 질문들

- [ ] **Q1**: {결정이 필요한 질문 1}
  - Option A: {선택지 A}
  - Option B: {선택지 B}
- [ ] **Q2**: {결정이 필요한 질문 2}
  - {고려사항}

## 참고 자료

- [{문서명}]({경로}) - {설명}
- {외부 링크} - {설명}
```

### 생성 규칙

**핵심 원칙:**

- 계획서 > 실행서 (how보다 what에 집중)
- AI 맥락 유지가 최우선 목표
- 코드 예시 없음, 방향만 제시
- 개발자 결정이 필요한 부분은 페어링 질문으로

**작성 가이드:**

1. 간결하게: 불필요한 설명 최소화
2. 연결성: 이전/다음 유닛과의 관계 명시
3. 결정점: 선택이 필요한 부분을 질문으로 남김

### 자동화 생성 프로세스

```
1. 로드맵에서 모든 Unit 추출
2. vibe/roadmap.md와 동일 디렉토리에 unit-plans/ 생성
3. 각 Unit별 계획서 생성:
   - 의존 Unit 참조
   - 관련 사양서 섹션 연결
   - 페어링 질문 식별
4. 메인 로드맵에 링크 추가
```

</unit_plan_generation>

## 📋 출력 형식

<output_format>

### 1. 프로젝트 대시보드

```markdown
# 📊 {프로젝트명} 로드맵

**핵심 가치**: {1-2문장}

## 진행 현황

**전체**: 0/{총개수} (0%) | **MVP**: 0/{MVP개수} (0%) | **MMP**: 0/{MMP개수} (0%)
**예상 완료**: MVP D-{일수} | MMP D-{일수}
**진행 중**: {Unit ID}
**블로커**: 없음 / ❌ {Unit ID}: {사유}

## 마일스톤

| 단계 | ID        | 이름           | 목표일     | 진행률   | 상태 |
| ---- | --------- | -------------- | ---------- | -------- | ---- |
| MVP  | M1        | {마일스톤명}   | YYYY-MM-DD | 0/{개수} | ⏸️   |
| MVP  | CP-MVP-01 | **✓ {검증명}** | YYYY-MM-DD | -        | ⏸️   |
| MMP  | M5        | {마일스톤명}   | YYYY-MM-DD | 0/{개수} | ⏸️   |
| MMP  | CP-MMP-01 | **✓ {검증명}** | YYYY-MM-DD | -        | ⏸️   |

## 핵심 기능 (MVP)

### {기능1}

- **완료 기준**: {측정 가능 기준}
- **책임 Unit**: U-001 ~ U-005
- **상태**: ⏸️

{계속...}

## 리스크

| ID    | 내용     | 영향 | 확률 | 대응   |
| ----- | -------- | ---- | ---- | ------ |
| R-001 | {리스크} | High | 30%  | {대응} |

## 메트릭

| 지표            | 현재 | 목표   |
| --------------- | ---- | ------ |
| 테스트 커버리지 | 0%   | 80%    |
| API 응답(p95)   | -    | <200ms |

**기술 부채**: 0h / 한도 8h

---
```

### 2. 작업 백로그

```markdown
## 작업 백로그

**범례**: ⏸️ 대기 | 🚧 진행중 | ✅ 완료 | ❌ 차단 | ⚡ Critical Path

### MVP

ID=[U-001[Mvp]](unit-plans/U-001[Mvp].md) | ⚡초기 설정 (package.json, tsconfig) | Depends=None | ⏸️
ID=[U-002[Mvp]](unit-plans/U-002[Mvp].md) | DB 연결 (/src/config/database.ts) | Depends=U-001 | ⏸️
ID=[U-003[Mvp]](unit-plans/U-003[Mvp].md) | User 모델 (/prisma/schema.prisma) | Depends=U-002 | ⏸️
...
ID=[RU-001[Mvp]](unit-plans/RU-001[Mvp].md) | 리팩토링: 인증 모듈 구조 정리 | Depends=U-007 | ⏸️
ID=[CP-MVP-01](unit-plans/CP-MVP-01.md) | **체크포인트: 데이터 레이어 검증** | Depends=RU-001 | ⏸️
...

### MMP

ID=[U-020[Mmp]](unit-plans/U-020[Mmp].md) | OAuth2.0 구조 설정 | Depends=RU-001 | ⏸️
ID=[U-021[Mmp]](unit-plans/U-021[Mmp].md) | Google 로그인 연동 | Depends=U-020 | ⏸️
...

### 완료

{완료된 작업들}

---
```

### 3. 빠른 실행 가이드

````markdown
## 빠른 실행

**현재 작업**: [{Unit-ID}](unit-plans/{Unit-ID}.md) - {작업명}

```bash
# 시작 명령어
{command 1}
{command 2}
```
````

**완료 확인**:

- [ ] {체크 항목 1}
- [ ] {체크 항목 2}

---

````

### 4. 일일 스탠드업

```markdown
## 일일 스탠드업 (YYYY-MM-DD)

**완료**: [{ID}](unit-plans/{ID}.md) - {설명}
**진행중**: [{ID}](unit-plans/{ID}.md) - {목표}
**블로커**: 없음 / ❌ [{ID}](unit-plans/{ID}.md): {사유} → {대응}

---
````

</output_format>

## 🎯 실행 워크플로우

<execution_workflow>

### 1. 맥락 수집 (10분)

```
.gemini/rules/red-line.md→ 필수 제약사항
vibe/prd.md → P0/P1/P2 분류
vibe/tech-stack.md → 기술 환경
.gemini/GEMINI.md + .gemini/rules/*.md → 개발 규칙
```

### 2. MVP 설계 (20분)

```
P0 요구사항 → 핵심 기능 3-5개
각 기능 → 15-30분 작업으로 분해
의존성 그래프 + 크리티컬 패스(⚡) 표시
3-5개 작업마다 RU 배치
```

### 3. MMP 확장 (15분)

```
P1/P2 요구사항 → 품질/성능/보안 작업
체크포인트 배치
```

### 4. 유닛 계획서 일괄 생성 (필수, 30분)

```
전체 로드맵 완성 직후
→ 모든 Unit 계획서 자동 생성
→ unit-plans/{Unit-ID}.md
→ 메인 로드맵에 링크 연결
```

### 5. 검증 (5분)

```
- [ ] 모든 Unit ID 부여
- [ ] 의존성 순환 없음
- [ ] 크리티컬 패스 표시
- [ ] RU 배치 완료
- [ ] 계획서 링크 작동
```

</execution_workflow>

## 🔧 작업 ID 체계

<id_system>

### ID 구조

```
{Type}-{Sequence}[{Phase}]

Type:
  U  = Unit (일반 작업)
  RU = Refactoring Unit (리팩토링)
  CP = Checkpoint (체크포인트)
  M  = Milestone (마일스톤, 백로그 외 별도 관리)

Sequence:
  001-099: MVP 일반 작업
  100-199: MMP 일반 작업
  001-009: MVP 리팩토링
  010-019: MMP 리팩토링
  MVP-01~09: MVP 체크포인트
  MMP-01~09: MMP 체크포인트

Phase:
  [Mvp]: MVP 단계
  [Mmp]: MMP 단계
  (체크포인트는 ID 자체에 포함)
```

### 예시

```
U-001[Mvp]      # MVP 첫 번째 일반 작업
U-050[Mvp]      # MVP 마지막 일반 작업
RU-001[Mvp]     # MVP 첫 번째 리팩토링
CP-MVP-01       # MVP 첫 번째 체크포인트
U-100[Mmp]      # MMP 첫 번째 일반 작업
U-199[Mmp]      # MMP 마지막 일반 작업
RU-010[Mmp]     # MMP 첫 번째 리팩토링
CP-MMP-04       # MMP 마지막 체크포인트
```

### 파일명 규칙

```
unit-plans/U-001[Mvp].md
unit-plans/RU-001[Mvp].md
unit-plans/CP-MVP-01.md
unit-plans/U-100[Mmp].md
```

**주의:** 파일명에 특수문자 `[`, `]` 사용 시 일부 시스템에서 이스케이프 필요할 수 있음. 필요시 `U-001_Mvp.md` 형식으로 조정 가능.

</id_system>

## 📊 진행 관리

<progress_management>

**상태 전환**:

```
⏸️ → 🚧 → ✅
      ↓
     ❌ (차단 시)
```

**일일 업데이트**:

- 완료 작업 → "완료된 작업" 섹션 이동
- 진행률 % 업데이트
- 블로커 즉시 기록

**품질 게이트**:

- Unit: 기능 완료 + 동작 확인
- RU: 기존 테스트 통과 + 복잡도 감소
- CP: 전체 작업 완료 + 테스트 + 리뷰

**위험 신호**:

- 🔴 크리티컬 패스 50% 지연, 블로커 24시간+
- 🟡 예상 시간 50% 초과, 의존성 충돌
- 🟢 계획 대비 ±20% 이내

</progress_management>

## ✅ 최종 완료 정의

<definition_of_done>

**로드맵 문서**:

- [ ] 대시보드, 마일스톤, 백로그 완성
- [ ] 리스크 & 메트릭 정의
- [ ] `vibe/roadmap.md` 저장

**유닛 계획서** (필수):

- [ ] 모든 Unit 계획서 생성
- [ ] `{로드맵-루트}/unit-plans/` 디렉토리 구성
- [ ] 메인 로드맵 링크 연결
- [ ] 페어링 질문 포함

**MVP 완료**:

- [ ] P0 기능 구현
- [ ] E2E 테스트 통과
- [ ] 데모 가능

**MMP 완료**:

- [ ] P1/P2 기능 구현
- [ ] 테스트 커버리지 > 80%
- [ ] 성능/보안 기준 만족

</definition_of_done>

---

**Version**: 2.0.0
**Last Updated**: 2024-11-14
**Author**: Vibe Coding Team
**License**: Internal Use Only
</file>

<file path="vibe/ready/rule-prompt-cursor_claude.md">
# AI 에이전트 지침 자동 생성 시스템

---

## 🎯 당신의 역할

당신은 **AI 에이전트 지침 설계자**입니다. 프로젝트의 요구사항과 컨텍스트를 깊이 분석하여, AI 에이전트가 최적의 성과를 낼 수 있도록 명확하고 실행 가능한 지침을 설계하고 작성하는 전문가입니다.

---

## 🎯 목표

사용자가 제공하는 프로젝트 문서들을 종합적으로 분석하여, AI 에이전트가 일관되고 효율적으로 작동할 수 있도록 하는 **계층화된 지침 체계**를 구축합니다.

---

## 필수 분석 자료

다음 문서들을 철저히 분석하여 지침 작성의 기반으로 활용하세요:

- `vibe/prd.md`: 프로젝트 요구사항등의 사양서, 프로젝트 목표, 핵심 기능, 사용자 시나리오, 비즈니스 로직
- `vibe/tech-stack.md` : 프로젝트의 기술 스택 가이드, 사용 기술, 도구, 프레임워크, 아키텍처, 또는 도메인 특화 지식

---

## 🏗️ 생성되는 지침 체계

### 📌 계층 1: 전역 지침

**파일 위치**: `CLAUDE.md`

프로젝트 **전체**에 적용되는 기본 원칙과 방향성:

<global_scope>

- **핵심 원칙**: 프로젝트의 철학, 목표, 가치
- **일반 규칙**: 모든 작업에 공통적으로 적용되는 표준
- **톤앤매너**: 커뮤니케이션 스타일, 용어 사용 원칙
- **품질 기준**: 산출물의 품질 검증 기준
- **제약사항**: 절대 해서는 안 되는 것들

</global_scope>

### 📌 계층 2: 도메인별 세부 지침

**파일 위치**: `.cursor/rules/*.mdc`

특정 영역, 작업 유형, 또는 컨텍스트에만 적용되는 구체적 규칙:

<specific_scope>

- **적용 범위 명시**: YAML Front Matter를 통한 스코프 정의
- **구체적 규칙**: 해당 영역의 상세한 작업 지침
- **예외 처리**: 특수 상황에 대한 대응 방법
- **참조 정보**: 관련 문서, 의존성, 전제조건

</specific_scope>

---

## 📝 지침 작성 프로세스

### 단계 1: 문서 분석

<analysis_framework>
제공된 문서를 다음 관점에서 분석합니다:

**요구사항 분석**

- 프로젝트의 핵심 목표는 무엇인가?
- 주요 기능과 우선순위는?
- 사용자/고객의 니즈는?
- 성공 지표는 무엇인가?

**기술/도메인 분석**

- 사용되는 기술, 도구, 방법론은?
- 아키텍처 패턴은?
- 도메인 특화 지식이 필요한가?
- 제약사항이나 의존성은?

**컨텍스트 분석**

- 팀의 작업 방식은?
- 기존 표준이나 관례는?
- 외부 시스템과의 통합 요구사항은?
- 규제나 컴플라이언스 요구사항은?

</analysis_framework>

### 단계 2: 지침 설계

<design_principles>
**명확성**

- 모호함 없는 명확한 표현
- 구체적이고 측정 가능한 기준
- 예제 코드/샘플 포함

**일관성**

- 전역 지침과 세부 지침 간 조화
- 용어와 컨벤션의 통일
- 상충하는 규칙 제거

**실용성**

- 실제 작업 흐름 반영
- 적용 가능한 구체적 액션
- 예외 상황 고려

**확장성**

- 새로운 규칙 추가 용이
- 모듈화된 구조
- 유지보수 고려

</design_principles>

### 단계 3: 범위 정의

세부 지침 파일마다 적용 범위를 명시합니다:

```yaml
---
applyTo: '<적용_범위_패턴>'
description: '이 지침이 다루는 내용에 대한 간단한 설명'
priority: <high|medium|low>
tags: [태그1, 태그2, 태그3]
---
```

**범위 패턴 예시:**

- 파일 경로: `"**/src/components/**/*.tsx"`
- 작업 유형: `"작업유형:데이터분석"`
- 컨텍스트: `"컨텍스트:고객지원"`
- 조합: `"**/api/** AND 언어:python"`

---

## 📐 지침 작성 템플릿

### 템플릿 A: 전역 지침

```markdown
# AI 에이전트 전역 지침

## 프로젝트 개요

[프로젝트의 목적, 비전, 핵심 가치를 기술]

## 핵심 원칙

<core_principles>

1. **원칙 1**: [구체적 설명]
2. **원칙 2**: [구체적 설명]
3. **원칙 3**: [구체적 설명]

</core_principles>

## 일반 규칙

<general_rules>

### 작업 표준

- [모든 작업에 적용되는 표준 1]
- [모든 작업에 적용되는 표준 2]

### 품질 기준

- [산출물이 만족해야 하는 기준 1]
- [산출물이 만족해야 하는 기준 2]

### 커뮤니케이션 가이드라인

- [언어 사용 원칙]
- [톤앤매너 규칙]
- [용어 정의 및 사용 방법]

</general_rules>

## 금지사항

<prohibitions>
- ❌ [절대 하지 말아야 할 것 1]
- ❌ [절대 하지 말아야 할 것 2]
- ❌ [절대 하지 말아야 할 것 3]
</prohibitions>

## 참조 문서

- [프로젝트 요구사항 문서]
- [기술 스택 문서]
- [관련 외부 리소스]
```

### 템플릿 B: 세부 지침

```markdown
---
applyTo: '<적용할 파일/컨텍스트 패턴>'
description: '<이 지침의 목적을 한 문장으로>'
priority: medium
tags: [관련태그1, 관련태그2]
---

# [영역명] 세부 지침

## 적용 대상

이 지침은 다음 상황/파일에 적용됩니다:

- [구체적 대상 1]
- [구체적 대상 2]

## 규칙

<rules>

### 규칙 1: [규칙 제목]

**설명**: [이 규칙이 필요한 이유와 상세 설명]

**올바른 예시**:
```

// 권장하는 방식
[좋은 예시 코드/텍스트]

```

**잘못된 예시**:

```

// 피해야 하는 방식
[나쁜 예시 코드/텍스트]

```

**이유**: [왜 첫 번째 방식이 더 나은지 설명]

### 규칙 2: [규칙 제목]

[위와 동일한 형식으로 작성]

</rules>

## 예외 처리

<exceptions>
다음의 경우에는 위 규칙을 적용하지 않거나 변형하여 적용합니다:

- **예외 상황 1**: [설명 및 대안]
- **예외 상황 2**: [설명 및 대안]

</exceptions>

## 체크리스트

이 영역의 작업을 완료하기 전 확인사항:

- [ ] [확인 항목 1]
- [ ] [확인 항목 2]
- [ ] [확인 항목 3]

## 관련 지침

- [관련된 다른 세부 지침 파일 참조]
- [참고할 전역 원칙 섹션]
```

---

## 💡 작성 팁과 베스트 프랙티스

<best_practices>

### 명확한 경계 설정

- **전역 지침**: 보편적이고 변하지 않는 핵심 원칙만 포함
- **세부 지침**: 구체적이고 실행 가능한 액션 중심으로 작성
- **두 계층 간 역할**이 명확히 구분되도록 설계

### 풍부한 예제 제공

- 모든 규칙에 "좋은 예시"와 "나쁜 예시"를 함께 제시
- 실제 프로젝트의 코드나 콘텐츠를 활용한 현실적 예제
- 왜 그런지 이유까지 설명

### 진화하는 문서로 관리

- **초기 버전**: 핵심 원칙과 필수 규칙만 포함
- **점진적 확장**: 프로젝트 진행하며 필요한 규칙 추가
- **정기적 리뷰**: 실제 사용 경험을 바탕으로 개선

### 팀 협업 중심

- 작성된 지침을 팀과 공유하고 피드백 수렴
- 실제 사용하면서 발견한 문제점 지속 개선
- Git으로 버전 관리하여 변경 이력 추적

### 적절한 균형 유지

- 너무 세세하면 오히려 생산성 저하
- 너무 추상적이면 실제 도움이 안 됨
- 핵심에 집중하되 필요한 만큼만 구체화

</best_practices>

---

## 📏 효과적인 규칙 작성 원칙

<effective_rules>

### 1. 간결성과 집중성 유지

**규칙 파일은 500줄 이하로 유지**

- 각 규칙 파일은 단일 책임을 가져야 합니다
- 너무 긴 파일은 이해하고 유지보수하기 어렵습니다
- AI 에이전트가 효율적으로 파싱하고 적용할 수 있는 크기로 제한

**예시:**

```
❌ 나쁜 예: frontend-all-rules.md (1,500줄)
✅ 좋은 예:
   - frontend-components.md (300줄)
   - frontend-state-management.md (250줄)
   - frontend-styling.md (200줄)
```

### 2. 모듈화와 조합 가능성

**대규모 규칙은 여러 개의 조합 가능한 규칙으로 분리**

- 각 규칙 파일은 독립적으로 이해 가능해야 합니다
- 필요에 따라 여러 규칙을 조합하여 사용할 수 있어야 합니다
- 의존성은 명시적으로 문서화합니다

**구조 예시:**

```
rules/
├── core/
│   ├── code-style.md          # 기본 코딩 스타일
│   └── naming-conventions.md   # 명명 규칙
├── frontend/
│   ├── react-components.md     # React 컴포넌트 규칙
│   └── css-modules.md          # CSS 모듈 규칙
└── backend/
    ├── api-design.md           # API 설계 규칙
    └── database-queries.md     # DB 쿼리 규칙
```

### 3. 구체적인 예제와 참조 제공

**추상적 지침 대신 구체적 예제 활용**

- 실제 코드 스니펫 포함
- 프로젝트의 기존 파일 참조
- Before/After 비교 제시

**예시:**

````markdown
### API 응답 형식

**설명**: 모든 API 응답은 일관된 구조를 따라야 합니다.

**올바른 예시** (참조: `src/api/users/getUser.ts`):

```typescript
interface ApiResponse<T> {
  success: boolean;
  data?: T;
  error?: {
    code: string;
    message: string;
  };
  timestamp: string;
}
```
````

**프로젝트 내 참조 파일**:

- `src/types/api.ts` - API 타입 정의
- `src/utils/apiResponse.ts` - 응답 생성 유틸리티

````

### 4. 명확하고 실행 가능한 가이드

**모호한 표현 대신 명확한 지침 제공**

- "좋은 코드를 작성하세요" ❌
- "함수는 단일 책임 원칙을 따르며, 20줄을 초과하지 않아야 합니다" ✅

**내부 문서처럼 작성**

- 팀원이 처음 프로젝트에 합류했을 때 읽을 문서라고 생각하고 작성
- 실제 작업 시나리오와 의사결정 기준 포함
- "왜"와 "어떻게"를 모두 설명

**예시:**
```markdown
### 상태 관리 라이브러리 선택

**규칙**: 전역 상태 관리에는 Zustand를 사용합니다.

**이유**:
- Redux보다 보일러플레이트가 적음
- Context API보다 성능이 우수
- TypeScript 지원이 뛰어남
- 팀원 대부분이 익숙함

**적용 방법**:
1. `src/stores/` 디렉토리에 스토어 생성
2. 각 도메인별로 별도 스토어 파일 관리
3. 네이밍: `use[도메인]Store` (예: `useUserStore`, `useCartStore`)

**참조**:
- 기존 스토어 예시: `src/stores/userStore.ts`
- 공식 문서: https://github.com/pmndrs/zustand
````

### 5. 규칙 재사용성

**반복되는 프롬프트를 규칙으로 전환**

- 채팅에서 자주 반복하는 지침이 있다면 규칙 파일로 만드세요
- 한 번 작성하고 여러 컨텍스트에서 재사용
- 팀 전체가 일관된 지침을 따를 수 있습니다

**재사용 패턴 예시:**

````markdown
---
applyTo: '**/*.test.ts'
description: '테스트 코드 작성 규칙'
priority: high
tags: [testing, quality]
---

# 테스트 코드 작성 규칙

이 규칙은 모든 테스트 파일에 적용됩니다.

## 테스트 구조

**AAA 패턴 사용** (Arrange-Act-Assert):

```typescript
describe('UserService', () => {
  it('should create a new user', async () => {
    // Arrange: 테스트 데이터 준비
    const userData = { name: '홍길동', email: 'hong@example.com' };

    // Act: 실행
    const user = await userService.create(userData);

    // Assert: 검증
    expect(user.id).toBeDefined();
    expect(user.name).toBe(userData.name);
  });
});
```
````

**매 작업마다 동일하게 적용되므로 규칙 파일로 관리**

````

### 6. 실용적인 규칙 크기 가이드

| 규칙 유형 | 권장 줄 수 | 예시 |
|---------|----------|------|
| 마이크로 규칙 | 50-100줄 | 변수 명명 규칙, 주석 스타일 |
| 컴포넌트 규칙 | 100-300줄 | React 컴포넌트 작성 규칙 |
| 도메인 규칙 | 300-500줄 | API 설계 전체 규칙 |
| 통합 규칙 | 여러 파일 조합 | 프론트엔드 전체 규칙 = 여러 파일 참조 |

</effective_rules>

---

## ✅ 품질 검증 체크리스트

### 완성도

- [ ] 제공된 모든 핵심 요구사항이 지침에 반영되었는가?
- [ ] 기술/도메인 특성이 충분히 고려되었는가?
- [ ] 전역 지침과 세부 지침이 모두 작성되었는가?
- [ ] 각 세부 지침의 적용 범위가 명확하게 정의되었는가?
- [ ] 각 규칙 파일이 500줄을 초과하지 않는가?

### 명확성

- [ ] 모호하거나 해석의 여지가 있는 표현이 없는가?
- [ ] 각 규칙에 구체적인 예시가 포함되었는가?
- [ ] 실제 프로젝트 파일을 참조하고 있는가?
- [ ] 용어가 문서 전체에서 일관되게 사용되었는가?
- [ ] 지침이 즉시 실행 가능한 수준으로 작성되었는가?

### 일관성

- [ ] 서로 다른 지침 간에 충돌이나 모순이 없는가?
- [ ] 전역 원칙이 모든 세부 규칙에 잘 반영되었는가?
- [ ] 문서 포맷과 스타일이 통일되었는가?
- [ ] 우선순위가 명확하고 합리적으로 설정되었는가?

### 실용성

- [ ] 실제 개발/작업 흐름과 일치하는가?
- [ ] 팀원들이 쉽게 이해하고 적용할 수 있는가?
- [ ] 문서 유지보수가 용이한 구조인가?
- [ ] 프로젝트 확장 시 새로운 규칙을 추가하기 쉬운가?
- [ ] 규칙이 적절히 모듈화되어 재사용 가능한가?

### 조합성

- [ ] 각 규칙 파일이 독립적으로 이해 가능한가?
- [ ] 여러 규칙을 조합하여 사용할 수 있는가?
- [ ] 의존성이 명시적으로 문서화되었는가?

---

## 🎯 최종 결과물

다음 형식으로 완성된 지침 체계를 제공합니다:

### 1. 전역 지침 파일 전체 내용

- 프로젝트의 핵심 원칙
- 모든 작업에 적용되는 일반 규칙
- 품질 기준 및 금지사항

### 2. 세부 지침 파일들

각 파일마다:

- YAML Front Matter (적용 범위, 우선순위, 태그)
- 상세한 규칙과 예시
- 실제 프로젝트 파일 참조
- 예외 처리 가이드
- 체크리스트

### 3. 구현 및 사용 가이드

- AI 에이전트에 지침을 적용하는 방법
- 팀 온보딩 절차
- 지침 업데이트 프로세스
- 규칙 조합 및 재사용 방법

---

## 📚 추가 고려사항

<additional_considerations>

### 다국어 프로젝트

- 언어별 특수 규칙 분리
- 번역 및 현지화 가이드라인
- 문화적 맥락 고려

### 레거시 시스템 통합

- 기존 코드 스타일과의 호환성
- 점진적 마이그레이션 전략
- 과도기 규칙 정의

### 규제 및 컴플라이언스

- 산업별 규제 요구사항
- 보안 및 개인정보보호 원칙
- 감사 추적 가능성

### 성능 및 최적화

- 성능 기준 및 벤치마크
- 리소스 사용 제한
- 최적화 우선순위

### 규칙 파일 관리

- 버전 관리 전략 (Git 활용)
- 규칙 변경 이력 추적
- 팀원 간 규칙 리뷰 프로세스
- 주기적인 규칙 정리 (사용되지 않는 규칙 제거)

</additional_considerations>

---

## 🔄 지침 유지보수 가이드

### 규칙 리팩토링 신호

다음과 같은 징후가 보이면 규칙을 리팩토링해야 합니다:

- 규칙 파일이 500줄을 초과함
- 여러 규칙이 서로 중복됨
- 팀원들이 규칙을 자주 오해함
- 새로운 기능 추가 시 기존 규칙과 충돌함
- 특정 규칙이 6개월 이상 사용되지 않음

### 규칙 진화 프로세스

1. **모니터링**: 실제 사용 패턴 관찰
2. **피드백 수집**: 팀원 의견 청취
3. **분석**: 개선이 필요한 영역 식별
4. **업데이트**: 규칙 수정 또는 새 규칙 작성
5. **검증**: 팀과 함께 테스트
6. **배포**: 공식 규칙으로 적용
7. **문서화**: 변경 이력 기록

### 버전 관리 예시

```markdown
# API 설계 규칙

**버전**: 2.1.0
**최종 수정일**: 2025-01-15
**변경 이력**:
- v2.1.0 (2025-01-15): 에러 코드 표준화 추가
- v2.0.0 (2024-12-01): REST에서 GraphQL로 기본 방식 변경
- v1.0.0 (2024-10-01): 초기 버전
````

---

이 문서를 활용하여 프로젝트에 최적화된 AI 에이전트 지침을 작성하세요. 명확하고, 실행 가능하며, 유지보수 가능한 지침 체계가 프로젝트의 성공을 이끌어낼 것입니다.
</file>

<file path="vibe/ready/rule-prompt-gemini.md">
# AI 에이전트 지침 자동 생성 시스템

---

## 🎯 당신의 역할

당신은 **AI 에이전트 지침 설계자**입니다. 프로젝트 요구사항을 분석하여, Gemini CLI의 **'계층적 컨텍스트 로딩'** 메커니즘에 최적화된 **모듈형 지침 체계**를 설계하고 작성합니다.

- **핵심 임무**: 전역(`~/.gemini/GEMINI.md`) 컨텍스트를 상속받아 확장하는 **프로젝트 루트 `.gemini/GEMINI.md`** 파일을 생성하고, 이 파일이 참조할 개별 **`.gemini/rules/*.md`** 파일들을 생성합니다.

---

## 🎯 목표

사용자가 제공하는 문서를 기반으로, `.gemini/GEMINI.md` 파일과 다수의 `.gemini/rules/*.md` 파일을 생성합니다. 이 체계는 `<!-- Imported from: ... -->` 구문을 통해 컨텍스트별 지침을 정적으로 로드하도록 설계되어야 합니다.

---

## 필수 분석 자료

지침 생성의 기반이 되는 핵심 문서입니다.

- `vibe/prd.md`: 프로젝트 목표, 핵심 기능, 비즈니스 로직
- `vibe/tech-stack.md`: 아키텍처, 프레임워크, 도메인 특화 지식

---

## 🏗️ 생성되는 지침 체계 (계층 구조)

Gemini CLI는 여러 `GEMINI.md` 파일을 계층적으로 결합합니다. (특정 > 일반)

- **[계층 0] 전역 (Global)**: `~/.gemini/GEMINI.md`
  - (AI 생성 대상 아님) 모든 프로젝트에 적용되는 사용자의 기본 지침. (예: "나는 시니어 개발자입니다.")
- **[계층 1] 프로젝트 루트 (Project)**: `.gemini/GEMINI.md` (예: `/project/GEMINI.md`)
  - **(AI 생성 핵심 대상)** 이 프로젝트의 기본 지침. [계층 0]을 상속받아 재정의(override)하며, [계층 2]를 임포트합니다.
- **[계층 2] 세부 모듈 (Imported)**: `.gemini/rules/*.md/...`
  - **(AI 생성 핵심 대상)** 특정 컨텍스트(작업, 파일)에 대한 구체적인 규칙.

---

## 🔧 지침 통합 방식 (Contextual Imports)

이 시스템은 **`<!-- Imported from: ... -->` 주석 기반의 정적 컨텍스트 포함 방식**을 사용합니다.

**구조 예시:**

```
project/
├── .geminiignore             # 컨텍스트 제외 파일/폴더 (예: node_modules)
├── .gemini/GEMINI.md          # [계층 1] 프로젝트 루트 지침
└── .gemini/rules/*.md/
    ├── networking-rules.md   # [계층 2] 세부 네트워킹 규칙
    ├── rendering-rules.md    # [계층 2] 세부 렌더링 규칙
    └── ...
```

**[계층 1] .gemini/GEMINI.md 내 Import 예시:**

```markdown
## 5. 모듈별 세부 규칙 (Contextual Imports)

### 네트워킹 작업 시 [networking, p2p, webrtc, multiplayer]

<!-- Imported from: .gemini/rules/*.md/networking-rules.md -->
<!-- End of import from: .gemini/rules/*.md/networking-rules.md -->

### 렌더링 작업 시 [rendering, graphics, webgl, shader]

<!-- Imported from: .gemini/rules/*.md/rendering-rules.md -->
<!-- End of import from: .gemini/rules/*.md/rendering-rules.md -->
```

---

## 📝 지침 작성 프로세스

### 단계 1: 문서 분석 및 작업 유형 식별

<analysis_framework>
제공된 `vibe/prd.md` 및 `vibe/tech-stack.md`를 분석하여 다음을 식별합니다:

- **핵심 요구사항**: 프로젝트의 주 목적과 성공 기준
- **기술/도메인 제약**: 반드시 따라야 할 기술 스택 및 아키텍처
- **주요 작업 유형**: 반복적으로 발생하는 작업 (예: API 개발, UI 렌더링, DB 쿼리)
  </analysis_framework>

### 단계 2: 지침 설계 (모듈화)

<design_principles>

- **전역 지침 (계층 1)**: 모든 작업에 공통적인 원칙 (예: 코드 스타일, 톤앤매너)
- **세부 지침 (계층 2)**: '주요 작업 유형'별로 분리된 구체적인 규칙
  </design_principles>

### 단계 3: Import 섹션 구성

`.gemini/GEMINI.md` 파일에 "모듈별 세부 규칙" 섹션을 생성하고, 식별된 작업 유형과 `<!-- Imported from: ... -->` 경로를 매핑합니다.

---

## 📐 지침 작성 템플릿

### 템플릿 A: 프로젝트 루트 지침 (`.gemini/GEMINI.md`)

```markdown
# AI 에이전트 프로젝트 지침: [프로젝트명]

## 0. 상위 컨텍스트 인지

> **[중요]** 이 지침은 사용자의 전역 지침(`~/.gemini/GEMINI.md`)을 상속받아 확장(override)합니다.

## 1. 프로젝트 개요

[프로젝트의 목적, 비전, 핵심 가치를 1~2줄로 요약]

## 2. 핵심 원칙 (Core Principles)

<core_principles>

- **원칙 1**: [간결하고 명확한 최우선 원칙 (예: 성능 최우선)]
- **원칙 2**: [두 번째 원칙 (예: 코드 가독성 유지)]
- **원칙 3**: [세 번째 원칙 (예: 엄격한 타입 준수)]
  </core_principles>

## 3. 일반 규칙 (General Rules)

<general_rules>

- [모든 작업에 공통으로 적용되는 표준 1 (예: TypeScript strict 모드 사용)]
- [모든 작업에 공통으로 적용되는 표준 2 (예: ESLint/Prettier 규칙 준수)]
  </general_rules>

## 4. 금지사항 (Prohibitions)

<prohibitions>
- ❌ [절대 하지 말아야 할 것 1 (예: `any` 타입 사용 금지)]
- ❌ [절대 하지 말아야 할 것 2 (예: 프로덕션 코드에 `console.log` 남기기 금지)]
</prohibitions>

## 5. 모듈별 세부 규칙 (Contextual Imports)

> **[중요]** AI는 사용자의 작업 요청 시, 아래 컨텍스트 키워드와 일치하는 규칙 파일을 참조합니다.

### [작업유형1] 작업 시 [키워드1, 키워드2, 키워드3]

<!-- Imported from: .gemini/rules/*.md/규칙파일1.md -->
<!-- End of import from: .gemini/rules/*.md/규칙파일1.md -->

### [작업유형2] 작업 시 [키워드4, 키워드5]

<!-- Imported from: .gemini/rules/*.md/규칙파일2.md -->
<!-- End of import from: .gemini/rules/*.md/규칙파일2.md -->

### [파일타입] 파일 작업 시 [*.확장자1, *.확장자2]

<!-- Imported from: .gemini/rules/*.md/규칙파일3.md -->
<!-- End of import from: .gemini/rules/*.md/규칙파일3.md -->

## 5.1. 작업별 동적 지침 로딩 (AI-instructed Dynamic Loading)

> **[중요]** AI는 아래에 정의된 트리거 키워드가 프롬프트에 포함될 경우, 지정된 파일을 `read_file`로 읽어 해당 지침을 추가 컨텍스트로 활용합니다. 이 규칙은 AI 에이전트에게 직접 지시하는 자연어 명령입니다.

<dynamic_loading_rules>

- **[트리거: "작업명"]**: `.gemini/rules/*.md/작업명-rules.md` 파일을 읽고 작업을 수행할 것.
- **[트리거: "다른 작업명"]**: `.gemini/rules/*.md/다른작업-rules.md` 파일을 읽고 작업을 수행할 것.
  </dynamic_loading_rules>

## 6. 참조 문서

- [주요 요구사항 문서]
- [기술 아키텍처 문서]
- [Gemini CLI Cheatsheet (Context Loading)](https://www.philschmid.de/gemini-cli-cheatsheet#context-files-geminimd)
- [Gemini CLI Official Docs (Configuration)](https://github.com/google-gemini/gemini-cli/blob/main/docs/cli/configuration.md#context-files-geminimd)
```

### 템플릿 B: 세부 지침 (`.gemini/rules/*.md/파일명.md`)

```markdown
# [영역명] 세부 지침

> **[적용 컨텍스트]**: [키워드1, 키워드2, 키워드3]
>
> **[설명]**: [이 지침의 목적을 한 문장으로 요약]
>
> **[참조]**: (이 규칙이 `.gemini/GEMINI.md`의 '어떤 키워드'에 의해 임포트되는지 명시)

---

## 1. 핵심 규칙

<rules>

### 규칙 1: [가장 중요한 규칙 제목]

**설명**: [이 규칙이 필요한 이유와 상세 설명]

**올바른 예시 (Do ✅)**:
```

[권장하는 방식의 좋은 예시 코드/텍스트]

```

**잘못된 예시 (Don't ❌)**:
```

[피해야 하는 방식의 나쁜 예시 코드/텍스트]

```

### 규칙 2: [두 번째 규칙 제목]
[...위와 동일한 형식으로 작성...]

</rules>

## 2. 예외 처리

<exceptions>
- **예외 상황 1**: [설명 및 대안 (예: 레거시 모듈 호환 시)]
</exceptions>

## 3. 체크리스트

이 영역의 작업을 완료하기 전 확인사항:
- [ ] [확인 항목 1 (예: JSDoc 주석 작성 완료)]
- [ ] [확인 항목 2 (예: 단위 테스트 통과)]
```

---

## 💡 핵심 작성 원칙 (Gemini CLI 최적화)

AI가 이 템플릿을 기반으로 지침을 생성할 때, 다음 원칙을 반드시 준수해야 합니다.

1.  **계층 구조 준수 (Hierarchy)**
    - 생성하는 `.gemini/GEMINI.md` 파일은 사용자의 전역 지침(`~/.gemini/GEMINI.md`)을 보완하거나 재정의(override)하는 역할을 수행해야 합니다.
    - 예를 들어, 전역 지침에 "Git 사용"이 있다면, 프로젝트 지침에는 "Git Flow 브랜치 전략 준수"처럼 더 구체화합니다.

2.  **철저한 모듈화 (Modularity)**
    - 각 세부 지침 파일(`템플릿 B`)은 **하나의 명확한 책임**(예: 네트워킹, 상태관리)만 가져야 합니다.
    - 파일당 권장 줄 수는 500줄 이하로 유지하여 AI가 빠르게 파싱할 수 있도록 합니다.

3.  **키워드 일치 (Keyword Matching)** - **[가장 중요]**
    - `템플릿 A`의 `### [작업유형]... [키워드]`에 사용된 **키워드 리스트**는,
    - 해당 파일(`템플릿 B`) 상단의 `> [적용 컨텍스트]: [키워드]` 리스트와 **일치해야 합니다.**
    - 이것이 Gemini CLI가 올바른 컨텍스트를 인지하는 핵심 메커니즘입니다.

4.  **명확한 예시 (Clear Examples)**
    - 모든 주요 규칙에는 **"Good/Bad (Do/Don't)" 예시**를 제공하여, 모호함을 제거하고 AI가 즉시 실행 가능한 코드를 생성하도록 유도합니다.

---

## 🚀 활용 팁 (Debugging & Tips)

생성된 지침이 올바르게 작동하는지 확인하기 위해 다음 Gemini CLI 명령어를 활용하세요.

1.  **`/memory show`**
    - **[필수 디버깅]** 현재 적용된 **최종 결합(Global + Project + Imported) 지침**을 모두 보여줍니다. 지침이 의도대로 로드되고 재정의되었는지 확인하는 가장 확실한 방법입니다.

2.  **`.geminiignore`**
    - `node_modules`, `dist` 등 AI가 컨텍스트로 참조할 필요 없는 파일/폴더를 제외하기 위해 프로젝트 루트에 `.geminiignore` 파일을 생성하세요. (
      `.gitignore`와 문법 동일)

3.  **`/init`**
    - 새 프로젝트 시작 시, ` /init` 명령어로 프로젝트용 기본 `GEMINI.md` 파일을 생성할 수 있습니다.

---

## ✅ 품질 검증 체크리스트

이 템플릿으로 지침을 모두 생성한 후, 다음을 확인합니다.

- [ ] **[디버깅]** (가상) `/memory show` 실행 시, 전역/프로젝트/임포트된 모든 지침이 의도대로 결합되는가?
- [ ] **[키워드 일치]** 전역 지침의 `[키워드]`와 세부 지침의 `[적용 컨텍스트]`가 1:1로 일치하는가?
- [ ] **[모듈화]** 각 세부 지침 파일이 단일 책임을 가지며 500줄 이내인가?
- [ ] **[명확성]** 모든 핵심 규칙에 `Do/Don't` 예시가 포함되었는가?
- [ ] **[완성도]** `vibe/prd.md`의 모든 핵심 요구사항이 지침에 반영되었는가?
- [ ] **[참조]** 제공된 공식 문서 2개(philschmid, github)가 `6. 참조 문서` 섹션에 포함되었는가?
- [ ] **[변수 유지]** `{}` 변수(경로)가 요청된 형식 그대로 유지되었는가?
</file>

<file path="vibe/ready/tech-stack-prompt.md">
# 역할

너는 MVP를 빠르게 만들어본 경험이 많은 실전파 시니어 개발자야.

# 목표

첨부된 `vibe/prd.md` PRD를 기반으로, **기술 선택의 근거를 명확히 하면서도 간결한** 기술 스택 가이드를 작성해 줘.

# 추가 맥락

1. @vibe/ref/standard-guide.md
2. @vibe/ref/frontend-style-guide.md
3. @vibe/ref/gemini-api-guide.md 는 gemini api 가이드 입니다.
4. @vibe/ref/image-generate-guide.md 이미지 생성 가이드 입니다. 해당 내용을 적극적으로 참고 해줘
5. @vibe/ref/text-generate-guide.md 텍스트 생성 가이드 입니다. 해당 내용을 적극적으로 참고 해줘
6. @vibe/ref/structured-outputs-guide.md 구조화된 출력 생성 가이드 입니다. 해당 내용을 적극적으로 반영해줘.
7. @vibe/ref/image-understanding-guide.md 이미지 참조 가이드 입니다. 해당 내용을 적극적으로 참고 해줘
8. 백엔드에서 구글 인증은 Vertex AI - 서비스 계정을 사용합니다.

# 핵심 원칙

- **기술 스택 문서의 본질에 집중** - 선택과 근거가 핵심, 구현 방법은 최소화
- **결정 우선, 완벽함 후순위** - 80% 확신이면 결정하고 진행
- **레퍼런스 접근성** - 팀원들이 각 기술의 공식 문서를 빠르게 찾을 수 있도록
- **분량 엄수** - 진짜로 스크롤 2-3번 이내

# 필수 포함 사항

## 1. 기술 스택 요약 (한눈에 보기)

선택된 핵심 기술들을 카테고리별로 깔끔하게 리스트업

## 2. 기술 선택 매트릭스 (압축)

PRD 요구사항 → 선택 기술 → 핵심 이유 (3-4단어)

## 3. 대안 기술 비교 (빠른 판단)

고려했지만 제외한 주요 기술과 간단한 이유

## 4. 리스크 요약 (현실적)

예상되는 주요 리스크 2-3개와 대응 방향

## 5. 레퍼런스 링크 모음 (핵심)

각 기술의 공식 문서/퀵스타트 링크를 찾기 쉽게 정리

## 6. 팀 온보딩 체크리스트 (간단)

팀원이 각 기술을 빠르게 파악할 수 있는 순서

# 작성 스타일

- 🚫 NO: 구현 세부사항, 코드 스니펫, 설치 명령어
- ✅ YES: "왜 이 기술인가?", "어떤 리스크가 있나?", "어디서 배우나?"

# 결과물 제약사항

- **출력 파일 경로**: `vibe/tech-stack.md`
- **분량**: 진짜로 스크롤 2-3번 이내 (A4 1장 수준)
- **톤**: 간결하고 확신있게, 불필요한 설명 제거
- **구조**: 순수 기술 스택 가이드, 구현 가이드 요소 배제

# 특별 규칙

- **레퍼런스 우선주의**: 각 기술을 배우러 갈 수 있는 최고의 링크 제공
- **분량 엄수**: 장황한 설명보다 핵심 정보 압축
- **카테고리 분류**: 기술들을 논리적으로 그룹핑해서 이해하기 쉽게
- **버전 명시**: 정확한 버전 번호로 재현성 확보
</file>

<file path="vibe/ref/frontend-style-guide.md">
# Unknown World 프론트엔드 스타일 가이드

## 개요

Unknown World는 **CRT 터미널 레트로** 미학을 기반으로 한 디자인 시스템을 사용합니다.
1980년대 녹색 인광 CRT 모니터의 향수를 불러일으키며, 미스터리한 "미지의 세계" 분위기를 연출합니다.

---

## 1. 디자인 철학

### 핵심 원칙

| 원칙                  | 설명                                                      |
| --------------------- | --------------------------------------------------------- |
| **레트로 퓨처리즘**   | 과거의 기술 미학과 미래적 신비감의 조화                   |
| **몰입형 인터페이스** | 게임과 UI의 경계를 흐리게 하여 사용자를 세계관에 몰입시킴 |
| **기능적 미니멀리즘** | 불필요한 장식 배제, 모든 요소가 목적을 가짐               |
| **접근성 우선**       | 레트로 미학을 유지하면서도 가독성과 사용성 보장           |

### 분위기 키워드

- 신비로움 (Mysterious)
- 복고풍 (Retro)
- 사이버펑크 (Cyberpunk)
- 터미널 (Terminal)
- 글리치 (Glitch)

---

## 2. 컬러 팔레트

### CSS 변수 정의

```css
:root {
  /* 기본 색상 */
  --bg-color: #0d0d0d; /* 배경: 거의 순수한 검정 */
  --text-color: #33ff00; /* 주 텍스트: 인광 녹색 (CRT 그린) */
  --text-dim: #1a8000; /* 보조 텍스트: 어두운 녹색 */
  --accent-color: #ff00ff; /* 강조색: 마젠타 */
  --border-color: #33ff00; /* 테두리: 인광 녹색 */

  /* CRT 효과 */
  --crt-scanline: rgba(18, 16, 16, 0.1);
  --crt-flicker: 0.03;
}
```

### 색상 사용 지침

| 색상                  | 용도                             | HEX                   |
| --------------------- | -------------------------------- | --------------------- |
| **Primary Green**     | 일반 텍스트, 테두리, 아이콘      | `#33ff00`             |
| **Dim Green**         | 비활성 텍스트, 그림자, 보조 요소 | `#1a8000`             |
| **Magenta**           | 호버 상태, 중요 알림, 강조       | `#ff00ff`             |
| **Deep Black**        | 배경                             | `#0d0d0d`             |
| **Transparent Green** | 패널 배경                        | `rgba(0, 20, 0, 0.3)` |

### 색상 사용 시 주의사항

- ⚠️ 밝은 색상 사용 최소화 (눈의 피로 방지)
- ⚠️ 텍스트에는 반드시 `text-shadow`로 글로우 효과 적용
- ⚠️ 마젠타는 호버/강조에만 제한적으로 사용

---

## 3. 타이포그래피

### 폰트 스택

```css
--font-main: 'NeoDonggeunmo', 'VT323', monospace;
```

### 폰트 정의

| 폰트              | 용도                | 출처                                                    |
| ----------------- | ------------------- | ------------------------------------------------------- |
| **NeoDonggeunmo** | 한글 텍스트 (1순위) | [눈누 폰트](https://noonnu.cc/font_page/36)             |
| **VT323**         | 영문 텍스트 (2순위) | [Google Fonts](https://fonts.google.com/specimen/VT323) |
| **monospace**     | 폴백                | 시스템 기본                                             |

### 폰트 로딩

```css
@font-face {
  font-family: 'NeoDonggeunmo';
  src: url('https://cdn.jsdelivr.net/gh/projectnoonnu/noonfonts_2001@1.3/NeoDunggeunmo.woff')
    format('woff');
  font-weight: normal;
  font-display: swap; /* 폰트 로딩 중에도 텍스트 표시 */
}
```

### 폰트 크기 체계

| 요소       | 크기              | 용도          |
| ---------- | ----------------- | ------------- |
| **h1**     | `2rem` (32px)     | 페이지 타이틀 |
| **body**   | `1.2rem` (19.2px) | 일반 텍스트   |
| **input**  | `1.5rem` (24px)   | 사용자 입력   |
| **button** | `1.2rem` (19.2px) | 버튼 레이블   |
| **mobile** | 기본 `14px`       | 768px 이하    |

---

## 4. CRT 효과

### 스캔라인 오버레이

화면 전체에 CRT 모니터의 수평 스캔라인을 시뮬레이션합니다.

```css
#crt-overlay {
  position: fixed;
  top: 0;
  left: 0;
  width: 100vw;
  height: 100vh;
  background: linear-gradient(rgba(18, 16, 16, 0) 50%, rgba(0, 0, 0, 0.25) 50%);
  background-size: 100% 4px;
  pointer-events: none;
  z-index: 999;
  animation: flicker 0.15s infinite;
}
```

### 플리커(깜빡임) 애니메이션

오래된 모니터의 미세한 깜빡임을 재현합니다.

```css
@keyframes flicker {
  0% {
    opacity: 0.97;
  }
  50% {
    opacity: 1;
  }
  100% {
    opacity: 0.98;
  }
}
```

### 글리치 효과

타이틀에 적용되는 시각적 글리치 효과입니다.

```css
.glitch {
  position: relative;
}

.glitch::before,
.glitch::after {
  content: attr(data-text);
  position: absolute;
  top: 0;
  left: 0;
}

.glitch::before {
  left: 2px;
  text-shadow: -1px 0 red;
  animation: glitch-anim-1 5s infinite linear alternate-reverse;
}

.glitch::after {
  left: -2px;
  text-shadow: -1px 0 blue;
  animation: glitch-anim-2 5s infinite linear alternate-reverse;
}
```

**사용법:**

```html
<h1 class="glitch" data-text="UNKNOWN WORLD">UNKNOWN WORLD</h1>
```

---

## 5. 레이아웃 구조

### 기본 레이아웃

```
┌─────────────────────────────────────────┐
│ HEADER                                  │
│ ┌─────────────────┐ ┌─────────────────┐ │
│ │ Title (h1)      │ │ Status Bar      │ │
│ └─────────────────┘ └─────────────────┘ │
├─────────────────────────────────────────┤
│ MAIN (Terminal Window)                  │
│ ┌─────────────────────────────────────┐ │
│ │                                     │ │
│ │  게임 디스플레이 영역                  │ │
│ │  (스크롤 가능)                        │ │
│ │                                     │ │
│ └─────────────────────────────────────┘ │
├─────────────────────────────────────────┤
│ FOOTER (Input Area)                     │
│ ┌─────────────────────────────────────┐ │
│ │ > [입력창________________] [EXECUTE] │ │
│ └─────────────────────────────────────┘ │
└─────────────────────────────────────────┘
```

### Flexbox 구조

```css
#app {
  display: flex;
  flex-direction: column;
  height: 100vh;
  padding: 1rem;
  max-width: 1200px;
  margin: 0 auto;
}

main {
  flex: 1; /* 남은 공간 모두 차지 */
  overflow-y: auto; /* 내용이 넘치면 스크롤 */
}
```

---

## 6. 컴포넌트 스타일

### 버튼

```css
button {
  background: var(--text-color);
  color: var(--bg-color);
  border: none;
  padding: 0.5rem 1rem;
  font-family: var(--font-main);
  font-size: 1.2rem;
  cursor: pointer;
  text-transform: uppercase;
  font-weight: bold;
}

button:hover {
  background: var(--accent-color);
  color: white;
}
```

### 입력 필드

```css
input[type='text'] {
  flex: 1;
  background: transparent;
  border: none;
  color: var(--text-color);
  font-family: var(--font-main);
  font-size: 1.5rem;
  outline: none;
  text-shadow: 0 0 5px var(--text-dim);
}
```

### 터미널 윈도우

```css
main {
  border: 1px solid var(--text-dim);
  padding: 1rem;
  background-color: rgba(0, 20, 0, 0.3);
  box-shadow: inset 0 0 20px rgba(0, 0, 0, 0.8);
}
```

### 스크롤바

```css
::-webkit-scrollbar {
  width: 10px;
}

::-webkit-scrollbar-track {
  background: var(--bg-color);
}

::-webkit-scrollbar-thumb {
  background: var(--text-dim);
  border: 1px solid var(--text-color);
}
```

---

## 7. 반응형 디자인

### 브레이크포인트

| 브레이크포인트 | 대상            |
| -------------- | --------------- |
| `768px` 이하   | 태블릿 & 모바일 |

### 모바일 조정

```css
@media (max-width: 768px) {
  :root {
    font-size: 14px; /* 기본 폰트 크기 축소 */
  }

  #app {
    padding: 0.5rem;
  }

  h1 {
    font-size: 1.5rem;
  }

  .prompt {
    font-size: 1.2rem;
  }

  input[type='text'] {
    font-size: 1.2rem;
  }

  button {
    font-size: 1rem;
    padding: 0.5rem;
  }
}
```

---

## 8. 애니메이션 가이드라인

### 허용되는 애니메이션

| 애니메이션  | 용도          | 속도  |
| ----------- | ------------- | ----- |
| **Flicker** | CRT 깜빡임    | 0.15s |
| **Glitch**  | 타이틀 글리치 | 5s    |
| **Blink**   | 커서 깜빡임   | 표준  |

### 애니메이션 원칙

1. **성능 우선**: GPU 가속 속성 (`transform`, `opacity`) 사용
2. **절제**: 과도한 애니메이션은 몰입감을 해침
3. **목적성**: 모든 애니메이션은 세계관 강화에 기여해야 함

---

## 9. 접근성 고려사항

### 색맹 대응

- 녹색/마젠타 조합은 대부분의 색각 이상에서 구분 가능
- 중요 정보는 색상 외에 텍스트로도 전달

### 시각적 피로 방지

- 어두운 배경에 제한된 밝은 색상 사용
- 스캔라인 효과는 subtle하게 유지

### 키보드 접근성

- 모든 인터랙티브 요소는 키보드로 접근 가능해야 함
- `Enter` 키로 명령 실행 지원

---

## 10. 파일 구조

```
frontend/
├── src/
│   ├── style.css      # 메인 스타일시트 (모든 스타일 포함)
│   ├── App.tsx        # 메인 컴포넌트
│   ├── main.tsx       # 엔트리 포인트
│   └── ...
├── index.html         # 외부 폰트 로드 (Google Fonts)
└── ...
```

### 스타일 관리 원칙

1. **단일 CSS 파일**: 프로젝트 규모상 단일 `style.css`로 관리
2. **CSS 변수 활용**: 테마 변경 용이성을 위해 CSS 변수 사용
3. **컴포넌트별 주석**: 관련 스타일을 주석으로 구분

---

## 11. 확장 가이드

### 새 컴포넌트 추가 시

1. 기존 CSS 변수 (`--text-color`, `--bg-color` 등) 사용
2. 레트로 터미널 미학 유지
3. 네온 글로우 효과 (`text-shadow`) 적용 고려
4. 호버 상태에 마젠타 강조색 사용

### 새 색상 추가가 필요한 경우

```css
:root {
  /* 기존 색상 유지하며 추가 */
  --warning-color: #ffaa00; /* 경고: 주황색 (레트로 터미널 호환) */
  --error-color: #ff3333; /* 에러: 붉은색 */
}
```

---

## 부록: 영감 자료

### 참고 미학

- 1980년대 IBM PC 모니터
- Fallout 시리즈 터미널 UI
- The Matrix 녹색 텍스트
- Cyberpunk 2077 UI

### 관련 자료

- [CRT Effect CSS Tutorial](https://aleclownes.com/2017/02/01/crt-display-effect.html)
- [VT323 Font](https://fonts.google.com/specimen/VT323)
- [NeoDonggeunmo 폰트](https://noonnu.cc/font_page/36)

---

_마지막 업데이트: 2025-11-30_
</file>

<file path="vibe/ref/gemini-api-guide.md">
<br />

| We have updated our[Terms of Service](https://ai.google.dev/gemini-api/terms).

Gemini 3 is our most intelligent model family to date, built on a foundation of state-of-the-art reasoning. It is designed to bring any idea to life by mastering agentic workflows, autonomous coding, and complex multimodal tasks. This guide covers key features of the Gemini 3 model family and how to get the most out of it.  
[Try Gemini 3 Pro](https://aistudio.google.com?model=gemini-3-pro-preview)[Try Gemini 3 Flash](https://aistudio.google.com?model=gemini-3-flash-preview)[Try Nano Banana Pro](https://aistudio.google.com?model=gemini-3-pro-image-preview)

Explore our[collection of Gemini 3 apps](https://aistudio.google.com/app/apps?source=showcase&showcaseTag=gemini-3)to see how the model handles advanced reasoning, autonomous coding, and complex multimodal tasks.

Get started with a few lines of code:

### Python

    from google import genai

    client = genai.Client()

    response = client.models.generate_content(
        model="gemini-3-pro-preview",
        contents="Find the race condition in this multi-threaded C++ snippet: [code here]",
    )

    print(response.text)

### JavaScript

    import { GoogleGenAI } from "@google/genai";

    const ai = new GoogleGenAI({});

    async function run() {
      const response = await ai.models.generateContent({
        model: "gemini-3-pro-preview",
        contents: "Find the race condition in this multi-threaded C++ snippet: [code here]",
      });

      console.log(response.text);
    }

    run();

### REST

    curl "https://generativelanguage.googleapis.com/v1beta/models/gemini-3-pro-preview:generateContent" \
      -H "x-goog-api-key: $GEMINI_API_KEY" \
      -H 'Content-Type: application/json' \
      -X POST \
      -d '{
        "contents": [{
          "parts": [{"text": "Find the race condition in this multi-threaded C++ snippet: [code here]"}]
        }]
      }'

## Meet the Gemini 3 series

Gemini 3 Pro, the first model in the new series, is best for complex tasks that require broad world knowledge and advanced reasoning across modalities.

Gemini 3 Flash is our latest 3-series model, with Pro-level intelligence at the speed and pricing of Flash.

Nano Banana Pro (also known as Gemini 3 Pro Image) is our highest quality image generation model yet.

All Gemini 3 models are currently in preview.

| Model ID                       | Context Window (In / Out) | Knowledge Cutoff | Pricing (Input / Output)\*                        |
| ------------------------------ | ------------------------- | ---------------- | ------------------------------------------------- |
| **gemini-3-pro-preview**       | 1M / 64k                  | Jan 2025         | $2 / $12 (\<200k tokens) $4 / $18 (\>200k tokens) |
| **gemini-3-flash-preview**     | 1M / 64k                  | Jan 2025         | $0.50 / $3                                        |
| **gemini-3-pro-image-preview** | 65k / 32k                 | Jan 2025         | $2 (Text Input) / $0.134 (Image Output)\*\*       |

_\* Pricing is per 1 million tokens unless otherwise noted._ _\*\* Image pricing varies by resolution. See the[pricing page](https://ai.google.dev/gemini-api/docs/pricing)for details._

For detailed limits, pricing, and additional information, see the[models page](https://ai.google.dev/gemini-api/docs/models/gemini).

## New API features in Gemini 3

Gemini 3 introduces new parameters designed to give developers more control over latency, cost, and multimodal fidelity.

### Thinking level

Gemini 3 series models use dynamic thinking by default to reason through prompts. You can use the`thinking_level`parameter, which controls the**maximum**depth of the model's internal reasoning process before it produces a response. Gemini 3 treats these levels as relative allowances for thinking rather than strict token guarantees.

If`thinking_level`is not specified, Gemini 3 will default to`high`. For faster, lower-latency responses when complex reasoning isn't required, you can constrain the model's thinking level to`low`.

**Gemini 3 Pro and Flash thinking levels:**

The following thinking levels are supported by both Gemini 3 Pro and Flash:

- `low`: Minimizes latency and cost. Best for simple instruction following, chat, or high-throughput applications
- `high`(Default, dynamic): Maximizes reasoning depth. The model may take significantly longer to reach a first token, but the output will be more carefully reasoned.

**Gemini 3 Flash thinking levels**

In addition to the levels above, Gemini 3 Flash also supports the following thinking levels that are not currently supported by Gemini 3 Pro:

- `minimal`: Matches the "no thinking" setting for most queries. The model may think very minimally for complex coding tasks. Minimizes latency for chat or high throughput applications.

  | **Note:** Circulation of[thought signatures](https://ai.google.dev/gemini-api/docs/gemini-3#thought_signatures)is required even when thinking level is set to`minimal`for Gemini 3 Flash.

- `medium`: Balanced thinking for most tasks.

### Python

    from google import genai
    from google.genai import types

    client = genai.Client()

    response = client.models.generate_content(
        model="gemini-3-pro-preview",
        contents="How does AI work?",
        config=types.GenerateContentConfig(
            thinking_config=types.ThinkingConfig(thinking_level="low")
        ),
    )

    print(response.text)

### JavaScript

    import { GoogleGenAI } from "@google/genai";

    const ai = new GoogleGenAI({});

    const response = await ai.models.generateContent({
        model: "gemini-3-pro-preview",
        contents: "How does AI work?",
        config: {
          thinkingConfig: {
            thinkingLevel: "low",
          }
        },
      });

    console.log(response.text);

### REST

    curl "https://generativelanguage.googleapis.com/v1beta/models/gemini-3-pro-preview:generateContent" \
      -H "x-goog-api-key: $GEMINI_API_KEY" \
      -H 'Content-Type: application/json' \
      -X POST \
      -d '{
        "contents": [{
          "parts": [{"text": "How does AI work?"}]
        }],
        "generationConfig": {
          "thinkingConfig": {
            "thinkingLevel": "low"
          }
        }
      }'

| **Important:** You cannot use both`thinking_level`and the legacy`thinking_budget`parameter in the same request. Doing so will return a 400 error.

### Media resolution

Gemini 3 introduces granular control over multimodal vision processing via the`media_resolution`parameter. Higher resolutions improve the model's ability to read fine text or identify small details, but increase token usage and latency. The`media_resolution`parameter determines the**maximum number of tokens allocated per input image or video frame.**

You can now set the resolution to`media_resolution_low`,`media_resolution_medium`,`media_resolution_high`, or`media_resolution_ultra_high`per individual media part or globally (via`generation_config`, global not available for ultra high). If unspecified, the model uses optimal defaults based on the media type.

**Recommended settings**

| Media Type            | Recommended Setting                                 | Max Tokens      | Usage Guidance                                                                                                                                                                    |
| --------------------- | --------------------------------------------------- | --------------- | --------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |
| **Images**            | `media_resolution_high`                             | 1120            | Recommended for most image analysis tasks to ensure maximum quality.                                                                                                              |
| **PDFs**              | `media_resolution_medium`                           | 560             | Optimal for document understanding; quality typically saturates at`medium`. Increasing to`high`rarely improves OCR results for standard documents.                                |
| **Video**(General)    | `media_resolution_low`(or`media_resolution_medium`) | 70 (per frame)  | **Note:** For video,`low`and`medium`settings are treated identically (70 tokens) to optimize context usage. This is sufficient for most action recognition and description tasks. |
| **Video**(Text-heavy) | `media_resolution_high`                             | 280 (per frame) | Required only when the use case involves reading dense text (OCR) or small details within video frames.                                                                           |

**Note:** The`media_resolution`parameter maps to different token counts depending on the input type. While images scale linearly (`media_resolution_low`: 280,`media_resolution_medium`: 560,`media_resolution_high`: 1120), Video is compressed more aggressively. For Video, both`media_resolution_low`and`media_resolution_medium`are capped at 70 tokens per frame, and`media_resolution_high`is capped at 280 tokens. See full details[here](https://ai.google.dev/gemini-api/docs/media-resolution#token-counts)

### Python

    from google import genai
    from google.genai import types
    import base64

    # The media_resolution parameter is currently only available in the v1alpha API version.
    client = genai.Client(http_options={'api_version': 'v1alpha'})

    response = client.models.generate_content(
        model="gemini-3-pro-preview",
        contents=[
            types.Content(
                parts=[
                    types.Part(text="What is in this image?"),
                    types.Part(
                        inline_data=types.Blob(
                            mime_type="image/jpeg",
                            data=base64.b64decode("..."),
                        ),
                        media_resolution={"level": "media_resolution_high"}
                    )
                ]
            )
        ]
    )

    print(response.text)

### JavaScript

    import { GoogleGenAI } from "@google/genai";

    // The media_resolution parameter is currently only available in the v1alpha API version.
    const ai = new GoogleGenAI({ apiVersion: "v1alpha" });

    async function run() {
      const response = await ai.models.generateContent({
        model: "gemini-3-pro-preview",
        contents: [
          {
            parts: [
              { text: "What is in this image?" },
              {
                inlineData: {
                  mimeType: "image/jpeg",
                  data: "...",
                },
                mediaResolution: {
                  level: "media_resolution_high"
                }
              }
            ]
          }
        ]
      });

      console.log(response.text);
    }

    run();

### REST

    curl "https://generativelanguage.googleapis.com/v1alpha/models/gemini-3-pro-preview:generateContent" \
      -H "x-goog-api-key: $GEMINI_API_KEY" \
      -H 'Content-Type: application/json' \
      -X POST \
      -d '{
        "contents": [{
          "parts": [
            { "text": "What is in this image?" },
            {
              "inlineData": {
                "mimeType": "image/jpeg",
                "data": "..."
              },
              "mediaResolution": {
                "level": "media_resolution_high"
              }
            }
          ]
        }]
      }'

### Temperature

For Gemini 3, we strongly recommend keeping the temperature parameter at its default value of`1.0`.

While previous models often benefited from tuning temperature to control creativity versus determinism, Gemini 3's reasoning capabilities are optimized for the default setting. Changing the temperature (setting it below 1.0) may lead to unexpected behavior, such as looping or degraded performance, particularly in complex mathematical or reasoning tasks.

### Thought signatures

Gemini 3 uses[Thought signatures](https://ai.google.dev/gemini-api/docs/thought-signatures)to maintain reasoning context across API calls. These signatures are encrypted representations of the model's internal thought process. To ensure the model maintains its reasoning capabilities you must return these signatures back to the model in your request exactly as they were received:

- **Function Calling (Strict):**The API enforces strict validation on the "Current Turn". Missing signatures will result in a 400 error.

  | **Note:** Circulation of thought signatures is required even when[thinking level](https://ai.google.dev/gemini-api/docs/gemini-3#thinking_level)is set to`minimal`for Gemini 3 Flash.

- **Text/Chat:**Validation is not strictly enforced, but omitting signatures will degrade the model's reasoning and answer quality.

- **Image generation/editing (Strict)** : The API enforces strict validation on all Model parts including a`thoughtSignature`. Missing signatures will result in a 400 error.

| **Success:** If you use the[official SDKs (Python, Node, Java)](https://ai.google.dev/gemini-api/docs/function-calling?example=meeting#thinking)and standard chat history, Thought Signatures are handled automatically. You do not need to manually manage these fields.

#### Function calling (strict validation)

When Gemini generates a`functionCall`, it relies on the`thoughtSignature`to process the tool's output correctly in the next turn. The "Current Turn" includes all Model (`functionCall`) and User (`functionResponse`) steps that occurred since the last standard**User** `text`message.

- **Single Function Call:** The`functionCall`part contains a signature. You must return it.
- **Parallel Function Calls:** Only the first`functionCall`part in the list will contain the signature. You must return the parts in the exact order received.
- **Multi-Step (Sequential):** If the model calls a tool, receives a result, and calls*another* tool (within the same turn),**both** function calls have signatures. You must return**all**accumulated signatures in the history.

#### Text and streaming

For standard chat or text generation, the presence of a signature is not guaranteed.

- **Non-Streaming** : The final content part of the response may contain a`thoughtSignature`, though it is not always present. If one is returned, you should send it back to maintain best performance.
- **Streaming**: If a signature is generated, it may arrive in a final chunk that contains an empty text part. Ensure your stream parser checks for signatures even if the text field is empty.

#### Image generation and editing

For`gemini-3-pro-image-preview`, thought signatures are critical for conversational editing. When you ask the model to modify an image it relies on the`thoughtSignature`from the previous turn to understand the composition and logic of the original image.

- **Editing:** Signatures are guaranteed on the first part after the thoughts of the response (`text`or`inlineData`) and on every subsequent`inlineData`part. You must return all of these signatures to avoid errors.

#### Code examples

#### Multi-step Function Calling (Sequential)

The user asks a question requiring two separate steps (Check Flight -\> Book Taxi) in one turn.

**Step 1: Model calls Flight Tool.**  
The model returns a signature`<Sig_A>`

```java
// Model Response (Turn 1, Step 1)
  {
    "role": "model",
    "parts": [
      {
        "functionCall": { "name": "check_flight", "args": {...} },
        "thoughtSignature": "<Sig_A>" // SAVE THIS
      }
    ]
  }
```

**Step 2: User sends Flight Result**  
We must send back`<Sig_A>`to keep the model's train of thought.

```java
// User Request (Turn 1, Step 2)
[
  { "role": "user", "parts": [{ "text": "Check flight AA100..." }] },
  {
    "role": "model",
    "parts": [
      {
        "functionCall": { "name": "check_flight", "args": {...} },
        "thoughtSignature": "<Sig_A>" // REQUIRED
      }
    ]
  },
  { "role": "user", "parts": [{ "functionResponse": { "name": "check_flight", "response": {...} } }] }
]
```

**Step 3: Model calls Taxi Tool**  
The model remembers the flight delay via`<Sig_A>`and now decides to book a taxi. It generates a*new* signature`<Sig_B>`.

```java
// Model Response (Turn 1, Step 3)
{
  "role": "model",
  "parts": [
    {
      "functionCall": { "name": "book_taxi", "args": {...} },
      "thoughtSignature": "<Sig_B>" // SAVE THIS
    }
  ]
}
```

**Step 4: User sends Taxi Result**  
To complete the turn, you must send back the entire chain:`<Sig_A>`AND`<Sig_B>`.

```java
// User Request (Turn 1, Step 4)
[
  // ... previous history ...
  {
    "role": "model",
    "parts": [
       { "functionCall": { "name": "check_flight", ... }, "thoughtSignature": "<Sig_A>" }
    ]
  },
  { "role": "user", "parts": [{ "functionResponse": {...} }] },
  {
    "role": "model",
    "parts": [
       { "functionCall": { "name": "book_taxi", ... }, "thoughtSignature": "<Sig_B>" }
    ]
  },
  { "role": "user", "parts": [{ "functionResponse": {...} }] }
]
```

#### Parallel Function Calling

The user asks: "Check the weather in Paris and London." The model returns two function calls in one response.

```java
// User Request (Sending Parallel Results)
[
  {
    "role": "user",
    "parts": [
      { "text": "Check the weather in Paris and London." }
    ]
  },
  {
    "role": "model",
    "parts": [
      // 1. First Function Call has the signature
      {
        "functionCall": { "name": "check_weather", "args": { "city": "Paris" } },
        "thoughtSignature": "<Signature_A>"
      },
      // 2. Subsequent parallel calls DO NOT have signatures
      {
        "functionCall": { "name": "check_weather", "args": { "city": "London" } }
      }
    ]
  },
  {
    "role": "user",
    "parts": [
      // 3. Function Responses are grouped together in the next block
      {
        "functionResponse": { "name": "check_weather", "response": { "temp": "15C" } }
      },
      {
        "functionResponse": { "name": "check_weather", "response": { "temp": "12C" } }
      }
    ]
  }
]
```

#### Text/In-Context Reasoning (No Validation)

The user asks a question that requires in-context reasoning without external tools. While not strictly validated, including the signature helps the model maintain the reasoning chain for follow-up questions.

```java
// User Request (Follow-up question)
[
  {
    "role": "user",
    "parts": [{ "text": "What are the risks of this investment?" }]
  },
  {
    "role": "model",
    "parts": [
      {
        "text": "I need to calculate the risk step-by-step. First, I'll look at volatility...",
        "thoughtSignature": "<Signature_C>" // Recommended to include
      }
    ]
  },
  {
    "role": "user",
    "parts": [{ "text": "Summarize that in one sentence." }]
  }
]
```

#### Image Generation \& Editing

For image generation, signatures are strictly validated. They appear on the**first part** (text or image) and**all subsequent image parts**. All must be returned in the next turn.

```java
// Model Response (Turn 1)
{
  "role": "model",
  "parts": [
    // 1. First part ALWAYS has a signature (even if text)
    {
      "text": "I will generate a cyberpunk city...",
      "thoughtSignature": "<Signature_D>"
    },
    // 2. ALL InlineData (Image) parts ALWAYS have signatures
    {
      "inlineData": { ... },
      "thoughtSignature": "<Signature_E>"
    },
  ]
}

// User Request (Turn 2 - Requesting an Edit)
{
  "contents": [
    // History must include ALL signatures received
    {
      "role": "user",
      "parts": [{ "text": "Generate a cyberpunk city" }]
    },
    {
      "role": "model",
      "parts": [
         { "text": "...", "thoughtSignature": "<Signature_D>" },
         { "inlineData": "...", "thoughtSignature": "<Signature_E>" },
      ]
    },
    // New User Prompt
    {
      "role": "user",
      "parts": [{ "text": "Make it daytime." }]
    }
  ]
}
```

#### Migrating from other models

If you are transferring a conversation trace from another model (e.g., Gemini 2.5) or injecting a custom function call that was not generated by Gemini 3, you will not have a valid signature.

To bypass strict validation in these specific scenarios, populate the field with this specific dummy string:`"thoughtSignature": "context_engineering_is_the_way_to_go"`

### Structured Outputs with tools

Gemini 3 models allow you to combine[Structured Outputs](https://ai.google.dev/gemini-api/docs/structured-output)with built-in tools, including[Grounding with Google Search](https://ai.google.dev/gemini-api/docs/google-search),[URL Context](https://ai.google.dev/gemini-api/docs/url-context), and[Code Execution](https://ai.google.dev/gemini-api/docs/code-execution).

### Python

    from google import genai
    from google.genai import types
    from pydantic import BaseModel, Field
    from typing import List

    class MatchResult(BaseModel):
        winner: str = Field(description="The name of the winner.")
        final_match_score: str = Field(description="The final match score.")
        scorers: List[str] = Field(description="The name of the scorer.")

    client = genai.Client()

    response = client.models.generate_content(
        model="gemini-3-pro-preview",
        contents="Search for all details for the latest Euro.",
        config={
            "tools": [
                {"google_search": {}},
                {"url_context": {}}
            ],
            "response_mime_type": "application/json",
            "response_json_schema": MatchResult.model_json_schema(),
        },
    )

    result = MatchResult.model_validate_json(response.text)
    print(result)

### JavaScript

    import { GoogleGenAI } from "@google/genai";
    import { z } from "zod";
    import { zodToJsonSchema } from "zod-to-json-schema";

    const ai = new GoogleGenAI({});

    const matchSchema = z.object({
      winner: z.string().describe("The name of the winner."),
      final_match_score: z.string().describe("The final score."),
      scorers: z.array(z.string()).describe("The name of the scorer.")
    });

    async function run() {
      const response = await ai.models.generateContent({
        model: "gemini-3-pro-preview",
        contents: "Search for all details for the latest Euro.",
        config: {
          tools: [
            { googleSearch: {} },
            { urlContext: {} }
          ],
          responseMimeType: "application/json",
          responseJsonSchema: zodToJsonSchema(matchSchema),
        },
      });

      const match = matchSchema.parse(JSON.parse(response.text));
      console.log(match);
    }

    run();

### REST

    curl "https://generativelanguage.googleapis.com/v1beta/models/gemini-3-pro-preview:generateContent" \
      -H "x-goog-api-key: $GEMINI_API_KEY" \
      -H 'Content-Type: application/json' \
      -X POST \
      -d '{
        "contents": [{
          "parts": [{"text": "Search for all details for the latest Euro."}]
        }],
        "tools": [
          {"googleSearch": {}},
          {"urlContext": {}}
        ],
        "generationConfig": {
            "responseMimeType": "application/json",
            "responseJsonSchema": {
                "type": "object",
                "properties": {
                    "winner": {"type": "string", "description": "The name of the winner."},
                    "final_match_score": {"type": "string", "description": "The final score."},
                    "scorers": {
                        "type": "array",
                        "items": {"type": "string"},
                        "description": "The name of the scorer."
                    }
                },
                "required": ["winner", "final_match_score", "scorers"]
            }
        }
      }'

### Image generation

Gemini 3 Pro Image lets you generate and edit images from text prompts. It uses reasoning to "think" through a prompt and can retrieve real-time data---such as weather forecasts or stock charts---before using[Google Search](https://ai.google.dev/gemini-api/docs/google-search)grounding before generating high-fidelity images.

**New \& improved capabilities:**

- **4K \& text rendering:**Generate sharp, legible text and diagrams with up to 2K and 4K resolutions.
- **Grounded generation:** Use the`google_search`tool to verify facts and generate imagery based on real-world information.
- **Conversational editing:** Multi-turn image editing by simply asking for changes (e.g., "Make the background a sunset"). This workflow relies on**Thought Signatures**to preserve visual context between turns.

For complete details on aspect ratios, editing workflows, and configuration options, see the[Image Generation guide](https://ai.google.dev/gemini-api/docs/image-generation).

### Python

    from google import genai
    from google.genai import types

    client = genai.Client()

    response = client.models.generate_content(
        model="gemini-3-pro-image-preview",
        contents="Generate an infographic of the current weather in Tokyo.",
        config=types.GenerateContentConfig(
            tools=[{"google_search": {}}],
            image_config=types.ImageConfig(
                aspect_ratio="16:9",
                image_size="4K"
            )
        )
    )

    image_parts = [part for part in response.parts if part.inline_data]

    if image_parts:
        image = image_parts[0].as_image()
        image.save('weather_tokyo.png')
        image.show()

### JavaScript

    import { GoogleGenAI } from "@google/genai";
    import * as fs from "node:fs";

    const ai = new GoogleGenAI({});

    async function run() {
      const response = await ai.models.generateContent({
        model: "gemini-3-pro-image-preview",
        contents: "Generate a visualization of the current weather in Tokyo.",
        config: {
          tools: [{ googleSearch: {} }],
          imageConfig: {
            aspectRatio: "16:9",
            imageSize: "4K"
          }
        }
      });

      for (const part of response.candidates[0].content.parts) {
        if (part.inlineData) {
          const imageData = part.inlineData.data;
          const buffer = Buffer.from(imageData, "base64");
          fs.writeFileSync("weather_tokyo.png", buffer);
        }
      }
    }

    run();

### REST

    curl "https://generativelanguage.googleapis.com/v1beta/models/gemini-3-pro-image-preview:generateContent" \
      -H "x-goog-api-key: $GEMINI_API_KEY" \
      -H 'Content-Type: application/json' \
      -X POST \
      -d '{
        "contents": [{
          "parts": [{"text": "Generate a visualization of the current weather in Tokyo."}]
        }],
        "tools": [{"googleSearch": {}}],
        "generationConfig": {
            "imageConfig": {
              "aspectRatio": "16:9",
              "imageSize": "4K"
          }
        }
      }'

**Example Response**

![Weather Tokyo](https://ai.google.dev/static/gemini-api/docs/images/weather-tokyo.jpg)

## Migrating from Gemini 2.5

Gemini 3 is our most capable model family to date and offers a stepwise improvement over Gemini 2.5. When migrating, consider the following:

- **Thinking:** If you were previously using complex prompt engineering (like chain of thought) to force Gemini 2.5 to reason, try Gemini 3 with`thinking_level: "high"`and simplified prompts.
- **Temperature settings:**If your existing code explicitly sets temperature (especially to low values for deterministic outputs), we recommend removing this parameter and using the Gemini 3 default of 1.0 to avoid potential looping issues or performance degradation on complex tasks.
- **PDF \& document understanding:** Default OCR resolution for PDFs has changed. If you relied on specific behavior for dense document parsing, test the new`media_resolution_high`setting to ensure continued accuracy.
- **Token consumption:** Migrating to Gemini 3 defaults may**increase** token usage for PDFs but**decrease**token usage for video. If requests now exceed the context window due to higher default resolutions, we recommend explicitly reducing the media resolution.
- **Image segmentation:** Image segmentation capabilities (returning pixel-level masks for objects) are not supported in Gemini 3 Pro or Gemini 3 Flash. For workloads requiring native image segmentation, we recommend continuing to utilize Gemini 2.5 Flash with thinking turned off or[Gemini Robotics-ER 1.5](https://ai.google.dev/gemini-api/docs/robotics-overview).
- **Tool support**: Maps grounding and Computer use tools are not yet supported for Gemini 3 models, so won't migrate. Additionally, combining built-in tools with function calling is not yet supported.

## OpenAI compatibility

For users utilizing the OpenAI compatibility layer, standard parameters are automatically mapped to Gemini equivalents:

- `reasoning_effort`(OAI) maps to`thinking_level`(Gemini). Note that`reasoning_effort`medium maps to`thinking_level`high.

## Prompting best practices

Gemini 3 is a reasoning model, which changes how you should prompt.

- **Precise instructions:**Be concise in your input prompts. Gemini 3 responds best to direct, clear instructions. It may over-analyze verbose or overly complex prompt engineering techniques used for older models.
- **Output verbosity:**By default, Gemini 3 is less verbose and prefers providing direct, efficient answers. If your use case requires a more conversational or "chatty" persona, you must explicitly steer the model in the prompt (e.g., "Explain this as a friendly, talkative assistant").
- **Context management:**When working with large datasets (e.g., entire books, codebases, or long videos), place your specific instructions or questions at the end of the prompt, after the data context. Anchor the model's reasoning to the provided data by starting your question with a phrase like, "Based on the information above...".

Learn more about prompt design strategies in the[prompt engineering guide](https://ai.google.dev/gemini-api/docs/prompting-strategies).

## FAQ

1. **What is the knowledge cutoff for Gemini 3?** Gemini 3 models have a knowledge cutoff of January 2025. For more recent information, use the[Search Grounding](https://ai.google.dev/gemini-api/docs/google-search)tool.

2. **What are the context window limits?**Gemini 3 models support a 1 million token input context window and up to 64k tokens of output.

3. **Is there a free tier for Gemini 3?** Gemini 3 Flash`gemini-3-flash-preview`has a free tier in the Gemini API. You can try both Gemini 3 Pro and Flash for free in Google AI Studio, but currently, there is no free tier available for`gemini-3-pro-preview`in the Gemini API.

4. **Will my old`thinking_budget`code still work?** Yes,`thinking_budget`is still supported for backward compatibility, but we recommend migrating to`thinking_level`for more predictable performance. Do not use both in the same request.

5. **Does Gemini 3 support the Batch API?** Yes, Gemini 3 supports the[Batch API.](https://ai.google.dev/gemini-api/docs/batch-api)

6. **Is Context Caching supported?** Yes,[Context Caching](https://ai.google.dev/gemini-api/docs/caching?lang=python)is supported for Gemini 3. The minimum token count required to initiate caching is 2,048 tokens.

7. **Which tools are supported in Gemini 3?** Gemini 3 supports[Google Search](https://ai.google.dev/gemini-api/docs/google-search),[File Search](https://ai.google.dev/gemini-api/docs/file-search),[Code Execution](https://ai.google.dev/gemini-api/docs/code-execution), and[URL Context](https://ai.google.dev/gemini-api/docs/url-context). It also supports standard[Function Calling](https://ai.google.dev/gemini-api/docs/function-calling?example=meeting)for your own custom tools (but not with built-in tools). Please note that[Grounding with Google Maps](https://ai.google.dev/gemini-api/docs/maps-grounding)and[Computer Use](https://ai.google.dev/gemini-api/docs/computer-use)are currently not supported.

   | **Note:** Gemini 3 billing for[Grounding with Google Search](https://ai.google.dev/gemini-api/docs/google-search)will begin on January 5, 2026.

## Next steps

- Get started with the[Gemini 3 Cookbook](https://colab.research.google.com/github/google-gemini/cookbook/blob/main/quickstarts/Get_started.ipynb#templateParams=%7B%22MODEL_ID%22%3A+%22gemini-3-pro-preview%22%7D)
- Check the dedicated Cookbook guide on[thinking levels](https://colab.research.google.com/github/google-gemini/cookbook/blob/main/quickstarts/Get_started_thinking_REST.ipynb#gemini3)and how to migrate from thinking budget to thinking levels.
</file>

<file path="vibe/ref/image-generate-guide.md">
<br />

<br />

Gemini can generate and process images conversationally. You can prompt either the[fast Gemini 2.5 Flash (aka Nano Banana) or the advanced Gemini 3 Pro Preview (aka Nano Banana Pro)](https://ai.google.dev/gemini-api/docs/image-generation#model-selection)image models with text, images, or a combination of both, allowing you to create, edit, and iterate on visuals with unprecedented control:

- **Text, Image, and Multi-Image to Image:**Generate high-quality images from text descriptions, use text prompts to edit and adjust a given image, or use multiple input images to compose new scenes and transfer styles.
- **Iterative refinement:**Conversationally refine your image over multiple turns, making small adjustments until it's perfect.
- **High-Fidelity text rendering:**Accurately generate images that contain legible and well-placed text, ideal for logos, diagrams, and posters.

All generated images include a[SynthID watermark](https://ai.google.dev/responsible/docs/safeguards/synthid).

## Image generation (text-to-image)

### Python

    from google import genai
    from google.genai import types
    from PIL import Image

    client = genai.Client()

    prompt = (
        "Create a picture of a nano banana dish in a fancy restaurant with a Gemini theme"
    )

    response = client.models.generate_content(
        model="gemini-2.5-flash-image",
        contents=[prompt],
    )

    for part in response.parts:
        if part.text is not None:
            print(part.text)
        elif part.inline_data is not None:
            image = part.as_image()
            image.save("generated_image.png")

### JavaScript

    import { GoogleGenAI } from "@google/genai";
    import * as fs from "node:fs";

    async function main() {

      const ai = new GoogleGenAI({});

      const prompt =
        "Create a picture of a nano banana dish in a fancy restaurant with a Gemini theme";

      const response = await ai.models.generateContent({
        model: "gemini-2.5-flash-image",
        contents: prompt,
      });
      for (const part of response.candidates[0].content.parts) {
        if (part.text) {
          console.log(part.text);
        } else if (part.inlineData) {
          const imageData = part.inlineData.data;
          const buffer = Buffer.from(imageData, "base64");
          fs.writeFileSync("gemini-native-image.png", buffer);
          console.log("Image saved as gemini-native-image.png");
        }
      }
    }

    main();

### Go

    package main

    import (
      "context"
      "fmt"
      "log"
      "os"
      "google.golang.org/genai"
    )

    func main() {

      ctx := context.Background()
      client, err := genai.NewClient(ctx, nil)
      if err != nil {
          log.Fatal(err)
      }

      result, _ := client.Models.GenerateContent(
          ctx,
          "gemini-2.5-flash-image",
          genai.Text("Create a picture of a nano banana dish in a " +
                     " fancy restaurant with a Gemini theme"),
      )

      for _, part := range result.Candidates[0].Content.Parts {
          if part.Text != "" {
              fmt.Println(part.Text)
          } else if part.InlineData != nil {
              imageBytes := part.InlineData.Data
              outputFilename := "gemini_generated_image.png"
              _ = os.WriteFile(outputFilename, imageBytes, 0644)
          }
      }
    }

### Java

    import com.google.genai.Client;
    import com.google.genai.types.GenerateContentConfig;
    import com.google.genai.types.GenerateContentResponse;
    import com.google.genai.types.Part;

    import java.io.IOException;
    import java.nio.file.Files;
    import java.nio.file.Paths;

    public class TextToImage {
      public static void main(String[] args) throws IOException {

        try (Client client = new Client()) {
          GenerateContentConfig config = GenerateContentConfig.builder()
              .responseModalities("TEXT", "IMAGE")
              .build();

          GenerateContentResponse response = client.models.generateContent(
              "gemini-2.5-flash-image",
              "Create a picture of a nano banana dish in a fancy restaurant with a Gemini theme",
              config);

          for (Part part : response.parts()) {
            if (part.text().isPresent()) {
              System.out.println(part.text().get());
            } else if (part.inlineData().isPresent()) {
              var blob = part.inlineData().get();
              if (blob.data().isPresent()) {
                Files.write(Paths.get("_01_generated_image.png"), blob.data().get());
              }
            }
          }
        }
      }
    }

### REST

    curl -s -X POST \
      "https://generativelanguage.googleapis.com/v1beta/models/gemini-2.5-flash-image:generateContent" \
      -H "x-goog-api-key: $GEMINI_API_KEY" \
      -H "Content-Type: application/json" \
      -d '{
        "contents": [{
          "parts": [
            {"text": "Create a picture of a nano banana dish in a fancy restaurant with a Gemini theme"}
          ]
        }]
      }' \
      | grep -o '"data": "[^"]*"' \
      | cut -d'"' -f4 \
      | base64 --decode > gemini-native-image.png

![AI-generated image of a nano banana dish](https://ai.google.dev/static/gemini-api/docs/images/nano-banana.png)AI-generated image of a nano banana dish in a Gemini-themed restaurant

## Image editing (text-and-image-to-image)

**Reminder** : Make sure you have the necessary rights to any images you upload. Don't generate content that infringe on others' rights, including videos or images that deceive, harass, or harm. Your use of this generative AI service is subject to our[Prohibited Use Policy](https://policies.google.com/terms/generative-ai/use-policy).

Provide an image and use text prompts to add, remove, or modify elements, change the style, or adjust the color grading.

The following example demonstrates uploading base64 encoded images. For multiple images, larger payloads, and supported MIME types, check the[Image understanding](https://ai.google.dev/gemini-api/docs/image-understanding)page.

### Python

    from google import genai
    from google.genai import types
    from PIL import Image

    client = genai.Client()

    prompt = (
        "Create a picture of my cat eating a nano-banana in a "
        "fancy restaurant under the Gemini constellation",
    )

    image = Image.open("/path/to/cat_image.png")

    response = client.models.generate_content(
        model="gemini-2.5-flash-image",
        contents=[prompt, image],
    )

    for part in response.parts:
        if part.text is not None:
            print(part.text)
        elif part.inline_data is not None:
            image = part.as_image()
            image.save("generated_image.png")

### JavaScript

    import { GoogleGenAI } from "@google/genai";
    import * as fs from "node:fs";

    async function main() {

      const ai = new GoogleGenAI({});

      const imagePath = "path/to/cat_image.png";
      const imageData = fs.readFileSync(imagePath);
      const base64Image = imageData.toString("base64");

      const prompt = [
        { text: "Create a picture of my cat eating a nano-banana in a" +
                "fancy restaurant under the Gemini constellation" },
        {
          inlineData: {
            mimeType: "image/png",
            data: base64Image,
          },
        },
      ];

      const response = await ai.models.generateContent({
        model: "gemini-2.5-flash-image",
        contents: prompt,
      });
      for (const part of response.candidates[0].content.parts) {
        if (part.text) {
          console.log(part.text);
        } else if (part.inlineData) {
          const imageData = part.inlineData.data;
          const buffer = Buffer.from(imageData, "base64");
          fs.writeFileSync("gemini-native-image.png", buffer);
          console.log("Image saved as gemini-native-image.png");
        }
      }
    }

    main();

### Go

    package main

    import (
     "context"
     "fmt"
     "log"
     "os"
     "google.golang.org/genai"
    )

    func main() {

     ctx := context.Background()
     client, err := genai.NewClient(ctx, nil)
     if err != nil {
         log.Fatal(err)
     }

     imagePath := "/path/to/cat_image.png"
     imgData, _ := os.ReadFile(imagePath)

     parts := []*genai.Part{
       genai.NewPartFromText("Create a picture of my cat eating a nano-banana in a fancy restaurant under the Gemini constellation"),
       &genai.Part{
         InlineData: &genai.Blob{
           MIMEType: "image/png",
           Data:     imgData,
         },
       },
     }

     contents := []*genai.Content{
       genai.NewContentFromParts(parts, genai.RoleUser),
     }

     result, _ := client.Models.GenerateContent(
         ctx,
         "gemini-2.5-flash-image",
         contents,
     )

     for _, part := range result.Candidates[0].Content.Parts {
         if part.Text != "" {
             fmt.Println(part.Text)
         } else if part.InlineData != nil {
             imageBytes := part.InlineData.Data
             outputFilename := "gemini_generated_image.png"
             _ = os.WriteFile(outputFilename, imageBytes, 0644)
         }
     }
    }

### Java

    import com.google.genai.Client;
    import com.google.genai.types.Content;
    import com.google.genai.types.GenerateContentConfig;
    import com.google.genai.types.GenerateContentResponse;
    import com.google.genai.types.Part;

    import java.io.IOException;
    import java.nio.file.Files;
    import java.nio.file.Path;
    import java.nio.file.Paths;

    public class TextAndImageToImage {
      public static void main(String[] args) throws IOException {

        try (Client client = new Client()) {
          GenerateContentConfig config = GenerateContentConfig.builder()
              .responseModalities("TEXT", "IMAGE")
              .build();

          GenerateContentResponse response = client.models.generateContent(
              "gemini-2.5-flash-image",
              Content.fromParts(
                  Part.fromText("""
                      Create a picture of my cat eating a nano-banana in
                      a fancy restaurant under the Gemini constellation
                      """),
                  Part.fromBytes(
                      Files.readAllBytes(
                          Path.of("src/main/resources/cat.jpg")),
                      "image/jpeg")),
              config);

          for (Part part : response.parts()) {
            if (part.text().isPresent()) {
              System.out.println(part.text().get());
            } else if (part.inlineData().isPresent()) {
              var blob = part.inlineData().get();
              if (blob.data().isPresent()) {
                Files.write(Paths.get("gemini_generated_image.png"), blob.data().get());
              }
            }
          }
        }
      }
    }

### REST

    IMG_PATH=/path/to/cat_image.jpeg

    if [[ "$(base64 --version 2>&1)" = *"FreeBSD"* ]]; then
      B64FLAGS="--input"
    else
      B64FLAGS="-w0"
    fi

    IMG_BASE64=$(base64 "$B64FLAGS" "$IMG_PATH" 2>&1)

    curl -X POST \
      "https://generativelanguage.googleapis.com/v1beta/models/gemini-2.5-flash-image:generateContent" \
        -H "x-goog-api-key: $GEMINI_API_KEY" \
        -H 'Content-Type: application/json' \
        -d "{
          \"contents\": [{
            \"parts\":[
                {\"text\": \"'Create a picture of my cat eating a nano-banana in a fancy restaurant under the Gemini constellation\"},
                {
                  \"inline_data\": {
                    \"mime_type\":\"image/jpeg\",
                    \"data\": \"$IMG_BASE64\"
                  }
                }
            ]
          }]
        }"  \
      | grep -o '"data": "[^"]*"' \
      | cut -d'"' -f4 \
      | base64 --decode > gemini-edited-image.png

![AI-generated image of a cat eating anano banana](https://ai.google.dev/static/gemini-api/docs/images/cat-banana.png)AI-generated image of a cat eating a nano banana

### Multi-turn image editing

Keep generating and editing images conversationally. Chat or multi-turn conversation is the recommended way to iterate on images. The following example shows a prompt to generate an infographic about photosynthesis.

### Python

    from google import genai
    from google.genai import types

    client = genai.Client()

    chat = client.chats.create(
        model="gemini-3-pro-image-preview",
        config=types.GenerateContentConfig(
            response_modalities=['TEXT', 'IMAGE'],
            tools=[{"google_search": {}}]
        )
    )

    message = "Create a vibrant infographic that explains photosynthesis as if it were a recipe for a plant's favorite food. Show the \"ingredients\" (sunlight, water, CO2) and the \"finished dish\" (sugar/energy). The style should be like a page from a colorful kids' cookbook, suitable for a 4th grader."

    response = chat.send_message(message)

    for part in response.parts:
        if part.text is not None:
            print(part.text)
        elif image:= part.as_image():
            image.save("photosynthesis.png")

### Javascript

    import { GoogleGenAI } from "@google/genai";

    const ai = new GoogleGenAI({});

    async function main() {
      const chat = ai.chats.create({
        model: "gemini-3-pro-image-preview",
        config: {
          responseModalities: ['TEXT', 'IMAGE'],
          tools: [{googleSearch: {}}],
        },
      });

    await main();

    const message = "Create a vibrant infographic that explains photosynthesis as if it were a recipe for a plant's favorite food. Show the \"ingredients\" (sunlight, water, CO2) and the \"finished dish\" (sugar/energy). The style should be like a page from a colorful kids' cookbook, suitable for a 4th grader."

    let response = await chat.sendMessage({message});

    for (const part of response.candidates[0].content.parts) {
        if (part.text) {
          console.log(part.text);
        } else if (part.inlineData) {
          const imageData = part.inlineData.data;
          const buffer = Buffer.from(imageData, "base64");
          fs.writeFileSync("photosynthesis.png", buffer);
          console.log("Image saved as photosynthesis.png");
        }
    }

### Go

    package main

    import (
        "context"
        "fmt"
        "log"
        "os"

        "google.golang.org/genai"
    )

    func main() {
        ctx := context.Background()
        client, err := genai.NewClient(ctx, nil)
        if err != nil {
            log.Fatal(err)
        }
        defer client.Close()

        model := client.GenerativeModel("gemini-3-pro-image-preview")
        model.GenerationConfig = &pb.GenerationConfig{
            ResponseModalities: []pb.ResponseModality{genai.Text, genai.Image},
        }
        chat := model.StartChat()

        message := "Create a vibrant infographic that explains photosynthesis as if it were a recipe for a plant's favorite food. Show the \"ingredients\" (sunlight, water, CO2) and the \"finished dish\" (sugar/energy). The style should be like a page from a colorful kids' cookbook, suitable for a 4th grader."

        resp, err := chat.SendMessage(ctx, genai.Text(message))
        if err != nil {
            log.Fatal(err)
        }

        for _, part := range resp.Candidates[0].Content.Parts {
            if txt, ok := part.(genai.Text); ok {
                fmt.Printf("%s", string(txt))
            } else if img, ok := part.(genai.ImageData); ok {
                err := os.WriteFile("photosynthesis.png", img.Data, 0644)
                if err != nil {
                    log.Fatal(err)
                }
            }
        }
    }

### Java

    import com.google.genai.Chat;
    import com.google.genai.Client;
    import com.google.genai.types.Content;
    import com.google.genai.types.GenerateContentConfig;
    import com.google.genai.types.GenerateContentResponse;
    import com.google.genai.types.GoogleSearch;
    import com.google.genai.types.ImageConfig;
    import com.google.genai.types.Part;
    import com.google.genai.types.RetrievalConfig;
    import com.google.genai.types.Tool;
    import com.google.genai.types.ToolConfig;

    import java.io.IOException;
    import java.nio.file.Files;
    import java.nio.file.Path;
    import java.nio.file.Paths;

    public class MultiturnImageEditing {
      public static void main(String[] args) throws IOException {

        try (Client client = new Client()) {

          GenerateContentConfig config = GenerateContentConfig.builder()
              .responseModalities("TEXT", "IMAGE")
              .tools(Tool.builder()
                  .googleSearch(GoogleSearch.builder().build())
                  .build())
              .build();

          Chat chat = client.chats.create("gemini-3-pro-image-preview", config);

          GenerateContentResponse response = chat.sendMessage("""
              Create a vibrant infographic that explains photosynthesis
              as if it were a recipe for a plant's favorite food.
              Show the "ingredients" (sunlight, water, CO2)
              and the "finished dish" (sugar/energy).
              The style should be like a page from a colorful
              kids' cookbook, suitable for a 4th grader.
              """);

          for (Part part : response.parts()) {
            if (part.text().isPresent()) {
              System.out.println(part.text().get());
            } else if (part.inlineData().isPresent()) {
              var blob = part.inlineData().get();
              if (blob.data().isPresent()) {
                Files.write(Paths.get("photosynthesis.png"), blob.data().get());
              }
            }
          }
          // ...
        }
      }
    }

### REST

    curl -s -X POST \
      "https://generativelanguage.googleapis.com/v1beta/models/gemini-3-pro-image-preview:generateContent" \
      -H "x-goog-api-key: $GEMINI_API_KEY" \
      -H "Content-Type: application/json" \
      -d '{
        "contents": [{
          "role": "user",
          "parts": [
            {"text": "Create a vibrant infographic that explains photosynthesis as if it were a recipe for a plants favorite food. Show the \"ingredients\" (sunlight, water, CO2) and the \"finished dish\" (sugar/energy). The style should be like a page from a colorful kids cookbook, suitable for a 4th grader."}
          ]
        }],
        "generationConfig": {
          "responseModalities": ["TEXT", "IMAGE"]
        }
      }' > turn1_response.json

    cat turn1_response.json
    # Requires jq to parse JSON response
    jq -r '.candidates[0].content.parts[] | select(.inlineData) | .inlineData.data' turn1_response.json | head -1 | base64 --decode > photosynthesis.png

![AI-generated infographic about photosynthesis](https://ai.google.dev/static/gemini-api/docs/images/infographic-eng.png)AI-generated infographic about photosynthesis

You can then use the same chat to change the language on the graphic to Spanish.

### Python

    message = "Update this infographic to be in Spanish. Do not change any other elements of the image."
    aspect_ratio = "16:9" # "1:1","2:3","3:2","3:4","4:3","4:5","5:4","9:16","16:9","21:9"
    resolution = "2K" # "1K", "2K", "4K"

    response = chat.send_message(message,
        config=types.GenerateContentConfig(
            image_config=types.ImageConfig(
                aspect_ratio=aspect_ratio,
                image_size=resolution
            ),
        ))

    for part in response.parts:
        if part.text is not None:
            print(part.text)
        elif image:= part.as_image():
            image.save("photosynthesis_spanish.png")

### Javascript

    const message = 'Update this infographic to be in Spanish. Do not change any other elements of the image.';
    const aspectRatio = '16:9';
    const resolution = '2K';

    let response = await chat.sendMessage({
      message,
      config: {
        responseModalities: ['TEXT', 'IMAGE'],
        imageConfig: {
          aspectRatio: aspectRatio,
          imageSize: resolution,
        },
        tools: [{googleSearch: {}}],
      },
    });

    for (const part of response.candidates[0].content.parts) {
        if (part.text) {
          console.log(part.text);
        } else if (part.inlineData) {
          const imageData = part.inlineData.data;
          const buffer = Buffer.from(imageData, "base64");
          fs.writeFileSync("photosynthesis2.png", buffer);
          console.log("Image saved as photosynthesis2.png");
        }
    }

### Go

    message = "Update this infographic to be in Spanish. Do not change any other elements of the image."
    aspect_ratio = "16:9" // "1:1","2:3","3:2","3:4","4:3","4:5","5:4","9:16","16:9","21:9"
    resolution = "2K"     // "1K", "2K", "4K"

    model.GenerationConfig.ImageConfig = &pb.ImageConfig{
        AspectRatio: aspect_ratio,
        ImageSize:   resolution,
    }

    resp, err = chat.SendMessage(ctx, genai.Text(message))
    if err != nil {
        log.Fatal(err)
    }

    for _, part := range resp.Candidates[0].Content.Parts {
        if txt, ok := part.(genai.Text); ok {
            fmt.Printf("%s", string(txt))
        } else if img, ok := part.(genai.ImageData); ok {
            err := os.WriteFile("photosynthesis_spanish.png", img.Data, 0644)
            if err != nil {
                log.Fatal(err)
            }
        }
    }

### Java

    String aspectRatio = "16:9"; // "1:1","2:3","3:2","3:4","4:3","4:5","5:4","9:16","16:9","21:9"
    String resolution = "2K"; // "1K", "2K", "4K"

    config = GenerateContentConfig.builder()
        .responseModalities("TEXT", "IMAGE")
        .imageConfig(ImageConfig.builder()
            .aspectRatio(aspectRatio)
            .imageSize(resolution)
            .build())
        .build();

    response = chat.sendMessage(
        "Update this infographic to be in Spanish. " +
        "Do not change any other elements of the image.",
        config);

    for (Part part : response.parts()) {
      if (part.text().isPresent()) {
        System.out.println(part.text().get());
      } else if (part.inlineData().isPresent()) {
        var blob = part.inlineData().get();
        if (blob.data().isPresent()) {
          Files.write(Paths.get("photosynthesis_spanish.png"), blob.data().get());
        }
      }
    }

### REST

    # Create request2.json by combining history and new prompt
    # Read model's previous response content directly into jq
    jq --argjson user1 '{"role": "user", "parts": [{"text": "Create a vibrant infographic that explains photosynthesis as if it were a recipe for a plant'\''s favorite food. Show the \"ingredients\" (sunlight, water, CO2) and the \"finished dish\" (sugar/energy). The style should be like a page from a colorful kids'\'' cookbook, suitable for a 4th grader."}]}' \
      --argjson user2 '{"role": "user", "parts": [{"text": "Update this infographic to be in Spanish. Do not change any other elements of the image."}]}' \
      -f /dev/stdin turn1_response.json > request2.json <<'EOF_JQ_FILTER'
    .candidates[0].content | {
      "contents": [$user1, ., $user2],
      "tools": [{"google_search": {}}],
      "generationConfig": {
        "responseModalities": ["TEXT", "IMAGE"],
        "imageConfig": {
          "aspectRatio": "16:9",
          "imageSize": "2K"
        }
      }
    }
    EOF_JQ_FILTER

    curl -s -X POST \
    "https://generativelanguage.googleapis.com/v1beta/models/gemini-3-pro-image-preview:generateContent" \
      -H "x-goog-api-key: $GEMINI_API_KEY" \
    -H "Content-Type: application/json" \
    -d @request2.json > turn2_response.json

    jq -r '.candidates[0].content.parts[] | select(.inlineData) | .inlineData.data' turn2_response.json | head -1 | base64 --decode > photosynthesis_spanish.png

![AI-generated infographic of photosynthesis in Spanish](https://ai.google.dev/static/gemini-api/docs/images/infographic-spanish.png)AI-generated infographic of photosynthesis in Spanish

## New with Gemini 3 Pro Image

Gemini 3 Pro Image (`gemini-3-pro-image-preview`) is a state-of-the-art image generation and editing model optimized for professional asset production. Designed to tackle the most challenging workflows through advanced reasoning, it excels at complex, multi-turn creation and modification tasks.

- **High-resolution output**: Built-in generation capabilities for 1K, 2K, and 4K visuals.
- **Advanced text rendering**: Capable of generating legible, stylized text for infographics, menus, diagrams, and marketing assets.
- **Grounding with Google Search**: The model can use Google Search as a tool to verify facts and generate imagery based on real-time data (e.g., current weather maps, stock charts, recent events).
- **Thinking mode**: The model utilizes a "thinking" process to reason through complex prompts. It generates interim "thought images" (visible in the backend but not charged) to refine the composition before producing the final high-quality output.
- **Up to 14 reference images**: You can now mix up to 14 reference images to produce the final image.

### Use up to 14 reference images

Gemini 3 Pro Preview lets you to mix up to 14 reference images. These 14 images can include the following:

- Up to 6 images of objects with high-fidelity to include in the final image
- Up to 5 images of humans to maintain character consistency

### Python

    from google import genai
    from google.genai import types
    from PIL import Image

    prompt = "An office group photo of these people, they are making funny faces."
    aspect_ratio = "5:4" # "1:1","2:3","3:2","3:4","4:3","4:5","5:4","9:16","16:9","21:9"
    resolution = "2K" # "1K", "2K", "4K"

    client = genai.Client()

    response = client.models.generate_content(
        model="gemini-3-pro-image-preview",
        contents=[
            prompt,
            Image.open('person1.png'),
            Image.open('person2.png'),
            Image.open('person3.png'),
            Image.open('person4.png'),
            Image.open('person5.png'),
        ],
        config=types.GenerateContentConfig(
            response_modalities=['TEXT', 'IMAGE'],
            image_config=types.ImageConfig(
                aspect_ratio=aspect_ratio,
                image_size=resolution
            ),
        )
    )

    for part in response.parts:
        if part.text is not None:
            print(part.text)
        elif image:= part.as_image():
            image.save("office.png")

### Javascript

    import { GoogleGenAI } from "@google/genai";
    import * as fs from "node:fs";

    async function main() {

      const ai = new GoogleGenAI({});

      const prompt =
          'An office group photo of these people, they are making funny faces.';
      const aspectRatio = '5:4';
      const resolution = '2K';

    const contents = [
      { text: prompt },
      {
        inlineData: {
          mimeType: "image/jpeg",
          data: base64ImageFile1,
        },
      },
      {
        inlineData: {
          mimeType: "image/jpeg",
          data: base64ImageFile2,
        },
      },
      {
        inlineData: {
          mimeType: "image/jpeg",
          data: base64ImageFile3,
        },
      },
      {
        inlineData: {
          mimeType: "image/jpeg",
          data: base64ImageFile4,
        },
      },
      {
        inlineData: {
          mimeType: "image/jpeg",
          data: base64ImageFile5,
        },
      }
    ];

    const response = await ai.models.generateContent({
        model: 'gemini-3-pro-image-preview',
        contents: contents,
        config: {
          responseModalities: ['TEXT', 'IMAGE'],
          imageConfig: {
            aspectRatio: aspectRatio,
            imageSize: resolution,
          },
        },
      });

      for (const part of response.candidates[0].content.parts) {
        if (part.text) {
          console.log(part.text);
        } else if (part.inlineData) {
          const imageData = part.inlineData.data;
          const buffer = Buffer.from(imageData, "base64");
          fs.writeFileSync("image.png", buffer);
          console.log("Image saved as image.png");
        }
      }

    }

    main();

### Go

    package main

    import (
        "context"
        "fmt"
        "log"
        "os"

        "google.golang.org/genai"
    )

    func main() {
        ctx := context.Background()
        client, err := genai.NewClient(ctx, nil)
        if err != nil {
            log.Fatal(err)
        }
        defer client.Close()

        model := client.GenerativeModel("gemini-3-pro-image-preview")
        model.GenerationConfig = &pb.GenerationConfig{
            ResponseModalities: []pb.ResponseModality{genai.Text, genai.Image},
            ImageConfig: &pb.ImageConfig{
                AspectRatio: "5:4",
                ImageSize:   "2K",
            },
        }

        img1, err := os.ReadFile("person1.png")
        if err != nil { log.Fatal(err) }
        img2, err := os.ReadFile("person2.png")
        if err != nil { log.Fatal(err) }
        img3, err := os.ReadFile("person3.png")
        if err != nil { log.Fatal(err) }
        img4, err := os.ReadFile("person4.png")
        if err != nil { log.Fatal(err) }
        img5, err := os.ReadFile("person5.png")
        if err != nil { log.Fatal(err) }

        parts := []genai.Part{
            genai.Text("An office group photo of these people, they are making funny faces."),
            genai.ImageData{MIMEType: "image/png", Data: img1},
            genai.ImageData{MIMEType: "image/png", Data: img2},
            genai.ImageData{MIMEType: "image/png", Data: img3},
            genai.ImageData{MIMEType: "image/png", Data: img4},
            genai.ImageData{MIMEType: "image/png", Data: img5},
        }

        resp, err := model.GenerateContent(ctx, parts...)
        if err != nil {
            log.Fatal(err)
        }

        for _, part := range resp.Candidates[0].Content.Parts {
            if txt, ok := part.(genai.Text); ok {
                fmt.Printf("%s", string(txt))
            } else if img, ok := part.(genai.ImageData); ok {
                err := os.WriteFile("office.png", img.Data, 0644)
                if err != nil {
                    log.Fatal(err)
                }
            }
        }
    }

### Java

    import com.google.genai.Client;
    import com.google.genai.types.Content;
    import com.google.genai.types.GenerateContentConfig;
    import com.google.genai.types.GenerateContentResponse;
    import com.google.genai.types.ImageConfig;
    import com.google.genai.types.Part;

    import java.io.IOException;
    import java.nio.file.Files;
    import java.nio.file.Path;
    import java.nio.file.Paths;

    public class GroupPhoto {
      public static void main(String[] args) throws IOException {

        try (Client client = new Client()) {
          GenerateContentConfig config = GenerateContentConfig.builder()
              .responseModalities("TEXT", "IMAGE")
              .imageConfig(ImageConfig.builder()
                  .aspectRatio("5:4")
                  .imageSize("2K")
                  .build())
              .build();

          GenerateContentResponse response = client.models.generateContent(
              "gemini-3-pro-image-preview",
              Content.fromParts(
                  Part.fromText("An office group photo of these people, they are making funny faces."),
                  Part.fromBytes(Files.readAllBytes(Path.of("person1.png")), "image/png"),
                  Part.fromBytes(Files.readAllBytes(Path.of("person2.png")), "image/png"),
                  Part.fromBytes(Files.readAllBytes(Path.of("person3.png")), "image/png"),
                  Part.fromBytes(Files.readAllBytes(Path.of("person4.png")), "image/png"),
                  Part.fromBytes(Files.readAllBytes(Path.of("person5.png")), "image/png")
              ), config);

          for (Part part : response.parts()) {
            if (part.text().isPresent()) {
              System.out.println(part.text().get());
            } else if (part.inlineData().isPresent()) {
              var blob = part.inlineData().get();
              if (blob.data().isPresent()) {
                Files.write(Paths.get("office.png"), blob.data().get());
              }
            }
          }
        }
      }
    }

### REST

    IMG_PATH1=person1.png
    IMG_PATH2=person2.png
    IMG_PATH3=person3.png
    IMG_PATH4=person4.png
    IMG_PATH5=person5.png

    if [[ "$(base64 --version 2>&1)" = *"FreeBSD"* ]]; then
      B64FLAGS="--input"
    else
      B64FLAGS="-w0"
    fi

    IMG1_BASE64=$(base64 "$B64FLAGS" "$IMG_PATH1" 2>&1)
    IMG2_BASE64=$(base64 "$B64FLAGS" "$IMG_PATH2" 2>&1)
    IMG3_BASE64=$(base64 "$B64FLAGS" "$IMG_PATH3" 2>&1)
    IMG4_BASE64=$(base64 "$B64FLAGS" "$IMG_PATH4" 2>&1)
    IMG5_BASE64=$(base64 "$B64FLAGS" "$IMG_PATH5" 2>&1)

    curl -X POST \
      "https://generativelanguage.googleapis.com/v1beta/models/gemini-3-pro-image-preview:generateContent" \
        -H "x-goog-api-key: $GEMINI_API_KEY" \
        -H 'Content-Type: application/json' \
        -d "{
          \"contents\": [{
            \"parts\":[
                {\"text\": \"An office group photo of these people, they are making funny faces.\"},
                {\"inline_data\": {\"mime_type\":\"image/png\", \"data\": \"$IMG1_BASE64\"}},
                {\"inline_data\": {\"mime_type\":\"image/png\", \"data\": \"$IMG2_BASE64\"}},
                {\"inline_data\": {\"mime_type\":\"image/png\", \"data\": \"$IMG3_BASE64\"}},
                {\"inline_data\": {\"mime_type\":\"image/png\", \"data\": \"$IMG4_BASE64\"}},
                {\"inline_data\": {\"mime_type\":\"image/png\", \"data\": \"$IMG5_BASE64\"}}
            ]
          }],
          \"generationConfig\": {
            \"responseModalities\": [\"TEXT\", \"IMAGE\"],
            \"imageConfig\": {
              \"aspectRatio\": \"5:4\",
              \"imageSize\": \"2K\"
            }
          }
        }" | jq -r '.candidates[0].content.parts[] | select(.inlineData) | .inlineData.data' | head -1 | base64 --decode > office.png

![AI-generated office group photo](https://ai.google.dev/static/gemini-api/docs/images/office-group-photo.jpeg)AI-generated office group photo

### Grounding with Google Search

Use the[Google Search tool](https://ai.google.dev/gemini-api/docs/google-search)to generate images based on real-time information, such as weather forecasts, stock charts, or recent events.

Note that when using Grounding with Google Search with image generation, image-based search results are not passed to the generation model and are excluded from the response.

### Python

    from google import genai
    prompt = "Visualize the current weather forecast for the next 5 days in San Francisco as a clean, modern weather chart. Add a visual on what I should wear each day"
    aspect_ratio = "16:9" # "1:1","2:3","3:2","3:4","4:3","4:5","5:4","9:16","16:9","21:9"

    client = genai.Client()

    response = client.models.generate_content(
        model="gemini-3-pro-image-preview",
        contents=prompt,
        config=types.GenerateContentConfig(
            response_modalities=['Text', 'Image'],
            image_config=types.ImageConfig(
                aspect_ratio=aspect_ratio,
            ),
            tools=[{"google_search": {}}]
        )
    )

    for part in response.parts:
        if part.text is not None:
            print(part.text)
        elif image:= part.as_image():
            image.save("weather.png")

### Javascript

    import { GoogleGenAI } from "@google/genai";
    import * as fs from "node:fs";

    async function main() {

      const ai = new GoogleGenAI({});

      const prompt = 'Visualize the current weather forecast for the next 5 days in San Francisco as a clean, modern weather chart. Add a visual on what I should wear each day';
      const aspectRatio = '16:9';
      const resolution = '2K';

    const response = await ai.models.generateContent({
        model: 'gemini-3-pro-image-preview',
        contents: prompt,
        config: {
          responseModalities: ['TEXT', 'IMAGE'],
          imageConfig: {
            aspectRatio: aspectRatio,
            imageSize: resolution,
          },
        },
      });

      for (const part of response.candidates[0].content.parts) {
        if (part.text) {
          console.log(part.text);
        } else if (part.inlineData) {
          const imageData = part.inlineData.data;
          const buffer = Buffer.from(imageData, "base64");
          fs.writeFileSync("image.png", buffer);
          console.log("Image saved as image.png");
        }
      }

    }

    main();

### Java

    import com.google.genai.Client;
    import com.google.genai.types.GenerateContentConfig;
    import com.google.genai.types.GenerateContentResponse;
    import com.google.genai.types.GoogleSearch;
    import com.google.genai.types.ImageConfig;
    import com.google.genai.types.Part;
    import com.google.genai.types.Tool;

    import java.io.IOException;
    import java.nio.file.Files;
    import java.nio.file.Paths;

    public class SearchGrounding {
      public static void main(String[] args) throws IOException {

        try (Client client = new Client()) {
          GenerateContentConfig config = GenerateContentConfig.builder()
              .responseModalities("TEXT", "IMAGE")
              .imageConfig(ImageConfig.builder()
                  .aspectRatio("16:9")
                  .build())
              .tools(Tool.builder()
                  .googleSearch(GoogleSearch.builder().build())
                  .build())
              .build();

          GenerateContentResponse response = client.models.generateContent(
              "gemini-3-pro-image-preview", """
                  Visualize the current weather forecast for the next 5 days
                  in San Francisco as a clean, modern weather chart.
                  Add a visual on what I should wear each day
                  """,
              config);

          for (Part part : response.parts()) {
            if (part.text().isPresent()) {
              System.out.println(part.text().get());
            } else if (part.inlineData().isPresent()) {
              var blob = part.inlineData().get();
              if (blob.data().isPresent()) {
                Files.write(Paths.get("weather.png"), blob.data().get());
              }
            }
          }
        }
      }
    }

### REST

    curl -s -X POST \
      "https://generativelanguage.googleapis.com/v1beta/models/gemini-3-pro-image-preview:generateContent" \
      -H "x-goog-api-key: $GEMINI_API_KEY" \
      -H "Content-Type: application/json" \
      -d '{
        "contents": [{"parts": [{"text": "Visualize the current weather forecast for the next 5 days in San Francisco as a clean, modern weather chart. Add a visual on what I should wear each day"}]}],
        "tools": [{"google_search": {}}],
        "generationConfig": {
          "responseModalities": ["TEXT", "IMAGE"],
          "imageConfig": {"aspectRatio": "16:9"}
        }
      }' | jq -r '.candidates[0].content.parts[] | select(.inlineData) | .inlineData.data' | head -1 | base64 --decode > weather.png

![AI-generated five day weather chart for San Francisco](https://ai.google.dev/static/gemini-api/docs/images/weather-forecast.png)AI-generated five day weather chart for San Francisco

The response includes`groundingMetadata`which contains the following required fields:

- **`searchEntryPoint`**: Contains the HTML and CSS to render the required search suggestions.
- **`groundingChunks`**: Returns the top 3 web sources used to ground the generated image

### Generate images up to 4K resolution

Gemini 3 Pro Image generates 1K images by default but can also output 2K and 4K images. To generate higher resolution assets, specify the`image_size`in the`generation_config`.

You must use an uppercase 'K' (e.g., 1K, 2K, 4K). Lowercase parameters (e.g., 1k) will be rejected.

### Python

    from google import genai
    from google.genai import types

    prompt = "Da Vinci style anatomical sketch of a dissected Monarch butterfly. Detailed drawings of the head, wings, and legs on textured parchment with notes in English."
    aspect_ratio = "1:1" # "1:1","2:3","3:2","3:4","4:3","4:5","5:4","9:16","16:9","21:9"
    resolution = "1K" # "1K", "2K", "4K"

    client = genai.Client()

    response = client.models.generate_content(
        model="gemini-3-pro-image-preview",
        contents=prompt,
        config=types.GenerateContentConfig(
            response_modalities=['TEXT', 'IMAGE'],
            image_config=types.ImageConfig(
                aspect_ratio=aspect_ratio,
                image_size=resolution
            ),
        )
    )

    for part in response.parts:
        if part.text is not None:
            print(part.text)
        elif image:= part.as_image():
            image.save("butterfly.png")

### Javascript

    import { GoogleGenAI } from "@google/genai";
    import * as fs from "node:fs";

    async function main() {

      const ai = new GoogleGenAI({});

      const prompt =
          'Da Vinci style anatomical sketch of a dissected Monarch butterfly. Detailed drawings of the head, wings, and legs on textured parchment with notes in English.';
      const aspectRatio = '1:1';
      const resolution = '1K';

      const response = await ai.models.generateContent({
        model: 'gemini-3-pro-image-preview',
        contents: prompt,
        config: {
          responseModalities: ['TEXT', 'IMAGE'],
          imageConfig: {
            aspectRatio: aspectRatio,
            imageSize: resolution,
          },
        },
      });

      for (const part of response.candidates[0].content.parts) {
        if (part.text) {
          console.log(part.text);
        } else if (part.inlineData) {
          const imageData = part.inlineData.data;
          const buffer = Buffer.from(imageData, "base64");
          fs.writeFileSync("image.png", buffer);
          console.log("Image saved as image.png");
        }
      }

    }

    main();

### Go

    package main

    import (
        "context"
        "fmt"
        "log"
        "os"

        "google.golang.org/genai"
    )

    func main() {
        ctx := context.Background()
        client, err := genai.NewClient(ctx, nil)
        if err != nil {
            log.Fatal(err)
        }
        defer client.Close()

        model := client.GenerativeModel("gemini-3-pro-image-preview")
        model.GenerationConfig = &pb.GenerationConfig{
            ResponseModalities: []pb.ResponseModality{genai.Text, genai.Image},
            ImageConfig: &pb.ImageConfig{
                AspectRatio: "1:1",
                ImageSize:   "1K",
            },
        }

        prompt := "Da Vinci style anatomical sketch of a dissected Monarch butterfly. Detailed drawings of the head, wings, and legs on textured parchment with notes in English."
        resp, err := model.GenerateContent(ctx, genai.Text(prompt))
        if err != nil {
            log.Fatal(err)
        }

        for _, part := range resp.Candidates[0].Content.Parts {
            if txt, ok := part.(genai.Text); ok {
                fmt.Printf("%s", string(txt))
            } else if img, ok := part.(genai.ImageData); ok {
                err := os.WriteFile("butterfly.png", img.Data, 0644)
                if err != nil {
                    log.Fatal(err)
                }
            }
        }
    }

### Java

    import com.google.genai.Client;
    import com.google.genai.types.GenerateContentConfig;
    import com.google.genai.types.GenerateContentResponse;
    import com.google.genai.types.GoogleSearch;
    import com.google.genai.types.ImageConfig;
    import com.google.genai.types.Part;
    import com.google.genai.types.Tool;

    import java.io.IOException;
    import java.nio.file.Files;
    import java.nio.file.Paths;

    public class HiRes {
        public static void main(String[] args) throws IOException {

          try (Client client = new Client()) {
            GenerateContentConfig config = GenerateContentConfig.builder()
                .responseModalities("TEXT", "IMAGE")
                .imageConfig(ImageConfig.builder()
                    .aspectRatio("16:9")
                    .imageSize("4K")
                    .build())
                .build();

            GenerateContentResponse response = client.models.generateContent(
                "gemini-3-pro-image-preview", """
                  Da Vinci style anatomical sketch of a dissected Monarch butterfly.
                  Detailed drawings of the head, wings, and legs on textured
                  parchment with notes in English.
                  """,
                config);

            for (Part part : response.parts()) {
              if (part.text().isPresent()) {
                System.out.println(part.text().get());
              } else if (part.inlineData().isPresent()) {
                var blob = part.inlineData().get();
                if (blob.data().isPresent()) {
                  Files.write(Paths.get("butterfly.png"), blob.data().get());
                }
              }
            }
          }
        }
    }

### REST

    curl -s -X POST \
      "https://generativelanguage.googleapis.com/v1beta/models/gemini-3-pro-image-preview:generateContent" \
      -H "x-goog-api-key: $GEMINI_API_KEY" \
      -H "Content-Type: application/json" \
      -d '{
        "contents": [{"parts": [{"text": "Da Vinci style anatomical sketch of a dissected Monarch butterfly. Detailed drawings of the head, wings, and legs on textured parchment with notes in English."}]}],
        "tools": [{"google_search": {}}],
        "generationConfig": {
          "responseModalities": ["TEXT", "IMAGE"],
          "imageConfig": {"aspectRatio": "1:1", "imageSize": "1K"}
        }
      }' | jq -r '.candidates[0].content.parts[] | select(.inlineData) | .inlineData.data' | head -1 | base64 --decode > butterfly.png

The following is an example image generated from this prompt:
![AI-generated Da Vinci style anatomical sketch of a dissected Monarch butterfly.](https://ai.google.dev/static/gemini-api/docs/images/gemini3-4k-image.png)AI-generated Da Vinci style anatomical sketch of a dissected Monarch butterfly.

### Thinking Process

The Gemini 3 Pro Image Preview model is a thinking model and uses a reasoning process ("Thinking") for complex prompts. This feature is enabled by default and cannot be disabled in the API. To learn more about the thinking process, see the[Gemini Thinking](https://ai.google.dev/gemini-api/docs/thinking)guide.

The model generates up to two interim images to test composition and logic. The last image within Thinking is also the final rendered image.

You can check the thoughts that lead to the final image being produced.

### Python

    for part in response.parts:
        if part.thought:
            if part.text:
                print(part.text)
            elif image:= part.as_image():
                image.show()

### Javascript

    for (const part of response.candidates[0].content.parts) {
      if (part.thought) {
        if (part.text) {
          console.log(part.text);
        } else if (part.inlineData) {
          const imageData = part.inlineData.data;
          const buffer = Buffer.from(imageData, 'base64');
          fs.writeFileSync('image.png', buffer);
          console.log('Image saved as image.png');
        }
      }
    }

#### Thought Signatures

Thought signatures are encrypted representations of the model's internal thought process and are used to preserve reasoning context across multi-turn interactions. All responses include a`thought_signature`field. As a general rule, if you receive a thought signature in a model response, you should pass it back exactly as received when sending the conversation history in the next turn. Failure to circulate thought signatures may cause the response to fail. Check the[thought signature](https://ai.google.dev/gemini-api/docs/thought-signatures)documentation for more explanations of signatures overall.
| **Note:** If you use the official[Google Gen AI SDKs](https://ai.google.dev/gemini-api/docs/libraries)and use the chat feature (or append the full model response object directly to history),**thought signatures are handled automatically**. You do not need to manually extract or manage them, or change your code.

Here is how thought signatures work:

- All`inline_data`parts with image`mimetype`which are part of the response should have signature.
- If there are some text parts at the beginning (before any image) right after the thoughts, the first text part should also have a signature.
- Thoughts do not have signatures; If`inline_data`parts with image`mimetype`are part of thoughts, they will not have signatures.

The following code shows an example of where thought signatures are included:

    [
      {
        "inline_data": {
          "data": "<base64_image_data_0>",
          "mime_type": "image/png"
        },
        "thought": true // Thoughts don't have signatures
      },
      {
        "inline_data": {
          "data": "<base64_image_data_1>",
          "mime_type": "image/png"
        },
        "thought": true // Thoughts don't have signatures
      },
      {
        "inline_data": {
          "data": "<base64_image_data_2>",
          "mime_type": "image/png"
        },
        "thought": true // Thoughts don't have signatures
      },
      {
        "text": "Here is a step-by-step guide to baking macarons, presented in three separate images.\n\n### Step 1: Piping the Batter\n\nThe first step after making your macaron batter is to pipe it onto a baking sheet. This requires a steady hand to create uniform circles.\n\n",
        "thought_signature": "<Signature_A>" // The first non-thought part always has a signature
      },
      {
        "inline_data": {
          "data": "<base64_image_data_3>",
          "mime_type": "image/png"
        },
        "thought_signature": "<Signature_B>" // All image parts have a signatures
      },
      {
        "text": "\n\n### Step 2: Baking and Developing Feet\n\nOnce piped, the macarons are baked in the oven. A key sign of a successful bake is the development of \"feet\"---the ruffled edge at the base of each macaron shell.\n\n"
        // Follow-up text parts don't have signatures
      },
      {
        "inline_data": {
          "data": "<base64_image_data_4>",
          "mime_type": "image/png"
        },
        "thought_signature": "<Signature_C>" // All image parts have a signatures
      },
      {
        "text": "\n\n### Step 3: Assembling the Macaron\n\nThe final step is to pair the cooled macaron shells by size and sandwich them together with your desired filling, creating the classic macaron dessert.\n\n"
      },
      {
        "inline_data": {
          "data": "<base64_image_data_5>",
          "mime_type": "image/png"
        },
        "thought_signature": "<Signature_D>" // All image parts have a signatures
      }
    ]

## Other image generation modes

Gemini supports other image interaction modes based on prompt structure and context, including:

- **Text to image(s) and text (interleaved):** Outputs images with related text.
  - Example prompt: "Generate an illustrated recipe for a paella."
- **Image(s) and text to image(s) and text (interleaved)** : Uses input images and text to create new related images and text.
  - Example prompt: (With an image of a furnished room) "What other color sofas would work in my space? can you update the image?"

## Generate images in batch

If you need to generate a lot of images, you can use the[Batch API](https://ai.google.dev/gemini-api/docs/batch-api). You get higher[rate limits](https://ai.google.dev/gemini-api/docs/rate-limits)in exchange for a turnaround of up to 24 hours.

Check the[Batch API image generation documentation](https://ai.google.dev/gemini-api/docs/batch-api#image-generation)and the[cookbook](https://colab.research.google.com/github/google-gemini/cookbook/blob/main/quickstarts/Batch_mode.ipynb)for Batch API image examples and code.

## Prompting guide and strategies

Mastering image generation starts with one fundamental principle:

> **Describe the scene, don't just list keywords.**The model's core strength is its deep language understanding. A narrative, descriptive paragraph will almost always produce a better, more coherent image than a list of disconnected words.

### Prompts for generating images

The following strategies will help you create effective prompts to generate exactly the images you're looking for.

#### 1. Photorealistic scenes

For realistic images, use photography terms. Mention camera angles, lens types, lighting, and fine details to guide the model toward a photorealistic result.

### Template

    A photorealistic [shot type] of [subject], [action or expression], set in
    [environment]. The scene is illuminated by [lighting description], creating
    a [mood] atmosphere. Captured with a [camera/lens details], emphasizing
    [key textures and details]. The image should be in a [aspect ratio] format.

### Prompt

    A photorealistic close-up portrait of an elderly Japanese ceramicist with
    deep, sun-etched wrinkles and a warm, knowing smile. He is carefully
    inspecting a freshly glazed tea bowl. The setting is his rustic,
    sun-drenched workshop. The scene is illuminated by soft, golden hour light
    streaming through a window, highlighting the fine texture of the clay.
    Captured with an 85mm portrait lens, resulting in a soft, blurred background
    (bokeh). The overall mood is serene and masterful. Vertical portrait
    orientation.

### Python

    from google import genai
    from google.genai import types

    client = genai.Client()

    response = client.models.generate_content(
        model="gemini-2.5-flash-image",
        contents="A photorealistic close-up portrait of an elderly Japanese ceramicist with deep, sun-etched wrinkles and a warm, knowing smile. He is carefully inspecting a freshly glazed tea bowl. The setting is his rustic, sun-drenched workshop with pottery wheels and shelves of clay pots in the background. The scene is illuminated by soft, golden hour light streaming through a window, highlighting the fine texture of the clay and the fabric of his apron. Captured with an 85mm portrait lens, resulting in a soft, blurred background (bokeh). The overall mood is serene and masterful.",
    )

    for part in response.parts:
        if part.text is not None:
            print(part.text)
        elif part.inline_data is not None:
            image = part.as_image()
            image.save("photorealistic_example.png")

### Java

    import com.google.genai.Client;
    import com.google.genai.types.GenerateContentConfig;
    import com.google.genai.types.GenerateContentResponse;
    import com.google.genai.types.Part;

    import java.io.IOException;
    import java.nio.file.Files;
    import java.nio.file.Paths;

    public class PhotorealisticScene {
      public static void main(String[] args) throws IOException {

        try (Client client = new Client()) {
          GenerateContentConfig config = GenerateContentConfig.builder()
              .responseModalities("TEXT", "IMAGE")
              .build();

          GenerateContentResponse response = client.models.generateContent(
              "gemini-2.5-flash-image",
              """
              A photorealistic close-up portrait of an elderly Japanese ceramicist
              with deep, sun-etched wrinkles and a warm, knowing smile. He is
              carefully inspecting a freshly glazed tea bowl. The setting is his
              rustic, sun-drenched workshop with pottery wheels and shelves of
              clay pots in the background. The scene is illuminated by soft,
              golden hour light streaming through a window, highlighting the
              fine texture of the clay and the fabric of his apron. Captured
              with an 85mm portrait lens, resulting in a soft, blurred
              background (bokeh). The overall mood is serene and masterful.
              """,
              config);

          for (Part part : response.parts()) {
            if (part.text().isPresent()) {
              System.out.println(part.text().get());
            } else if (part.inlineData().isPresent()) {
              var blob = part.inlineData().get();
              if (blob.data().isPresent()) {
                Files.write(Paths.get("photorealistic_example.png"), blob.data().get());
              }
            }
          }
        }
      }
    }

### JavaScript

    import { GoogleGenAI } from "@google/genai";
    import * as fs from "node:fs";

    async function main() {

      const ai = new GoogleGenAI({});

      const prompt =
        "A photorealistic close-up portrait of an elderly Japanese ceramicist with deep, sun-etched wrinkles and a warm, knowing smile. He is carefully inspecting a freshly glazed tea bowl. The setting is his rustic, sun-drenched workshop with pottery wheels and shelves of clay pots in the background. The scene is illuminated by soft, golden hour light streaming through a window, highlighting the fine texture of the clay and the fabric of his apron. Captured with an 85mm portrait lens, resulting in a soft, blurred background (bokeh). The overall mood is serene and masterful.";

      const response = await ai.models.generateContent({
        model: "gemini-2.5-flash-image",
        contents: prompt,
      });
      for (const part of response.candidates[0].content.parts) {
        if (part.text) {
          console.log(part.text);
        } else if (part.inlineData) {
          const imageData = part.inlineData.data;
          const buffer = Buffer.from(imageData, "base64");
          fs.writeFileSync("photorealistic_example.png", buffer);
          console.log("Image saved as photorealistic_example.png");
        }
      }
    }

    main();

### Go

    package main

    import (
        "context"
        "fmt"
        "log"
        "os"
        "google.golang.org/genai"
    )

    func main() {

        ctx := context.Background()
        client, err := genai.NewClient(ctx, nil)
        if err != nil {
            log.Fatal(err)
        }

        result, _ := client.Models.GenerateContent(
            ctx,
            "gemini-2.5-flash-image",
            genai.Text("A photorealistic close-up portrait of an elderly Japanese ceramicist with deep, sun-etched wrinkles and a warm, knowing smile. He is carefully inspecting a freshly glazed tea bowl. The setting is his rustic, sun-drenched workshop with pottery wheels and shelves of clay pots in the background. The scene is illuminated by soft, golden hour light streaming through a window, highlighting the fine texture of the clay and the fabric of his apron. Captured with an 85mm portrait lens, resulting in a soft, blurred background (bokeh). The overall mood is serene and masterful."),
        )

        for _, part := range result.Candidates[0].Content.Parts {
            if part.Text != "" {
                fmt.Println(part.Text)
            } else if part.InlineData != nil {
                imageBytes := part.InlineData.Data
                outputFilename := "photorealistic_example.png"
                _ = os.WriteFile(outputFilename, imageBytes, 0644)
            }
        }
    }

### REST

    curl -s -X POST
      "https://generativelanguage.googleapis.com/v1beta/models/gemini-2.5-flash-image:generateContent" \
      -H "x-goog-api-key: $GEMINI_API_KEY" \
      -H "Content-Type: application/json" \
      -d '{
        "contents": [{
          "parts": [
            {"text": "A photorealistic close-up portrait of an elderly Japanese ceramicist with deep, sun-etched wrinkles and a warm, knowing smile. He is carefully inspecting a freshly glazed tea bowl. The setting is his rustic, sun-drenched workshop with pottery wheels and shelves of clay pots in the background. The scene is illuminated by soft, golden hour light streaming through a window, highlighting the fine texture of the clay and the fabric of his apron. Captured with an 85mm portrait lens, resulting in a soft, blurred background (bokeh). The overall mood is serene and masterful."}
          ]
        }]
      }' \
      | grep -o '"data": "[^"]*"' \
      | cut -d'"' -f4 \
      | base64 --decode > photorealistic_example.png

![A photorealistic close-up portrait of an elderly Japanese ceramicist...](https://ai.google.dev/static/gemini-api/docs/images/photorealistic_example.png)A photorealistic close-up portrait of an elderly Japanese ceramicist...

#### 2. Stylized illustrations \& stickers

To create stickers, icons, or assets, be explicit about the style and request a transparent background.

### Template

    A [style] sticker of a [subject], featuring [key characteristics] and a
    [color palette]. The design should have [line style] and [shading style].
    The background must be transparent.

### Prompt

    A kawaii-style sticker of a happy red panda wearing a tiny bamboo hat. It's
    munching on a green bamboo leaf. The design features bold, clean outlines,
    simple cel-shading, and a vibrant color palette. The background must be white.

### Python

    from google import genai
    from google.genai import types

    client = genai.Client()

    response = client.models.generate_content(
        model="gemini-2.5-flash-image",
        contents="A kawaii-style sticker of a happy red panda wearing a tiny bamboo hat. It's munching on a green bamboo leaf. The design features bold, clean outlines, simple cel-shading, and a vibrant color palette. The background must be white.",
    )

    for part in response.parts:
        if part.text is not None:
            print(part.text)
        elif part.inline_data is not None:
            image = part.as_image()
            image.save("red_panda_sticker.png")

### Java

    import com.google.genai.Client;
    import com.google.genai.types.GenerateContentConfig;
    import com.google.genai.types.GenerateContentResponse;
    import com.google.genai.types.Part;

    import java.io.IOException;
    import java.nio.file.Files;
    import java.nio.file.Paths;

    public class StylizedIllustration {
      public static void main(String[] args) throws IOException {

        try (Client client = new Client()) {
          GenerateContentConfig config = GenerateContentConfig.builder()
              .responseModalities("TEXT", "IMAGE")
              .build();

          GenerateContentResponse response = client.models.generateContent(
              "gemini-2.5-flash-image",
              """
              A kawaii-style sticker of a happy red panda wearing a tiny bamboo
              hat. It's munching on a green bamboo leaf. The design features
              bold, clean outlines, simple cel-shading, and a vibrant color
              palette. The background must be white.
              """,
              config);

          for (Part part : response.parts()) {
            if (part.text().isPresent()) {
              System.out.println(part.text().get());
            } else if (part.inlineData().isPresent()) {
              var blob = part.inlineData().get();
              if (blob.data().isPresent()) {
                Files.write(Paths.get("red_panda_sticker.png"), blob.data().get());
              }
            }
          }
        }
      }
    }

### JavaScript

    import { GoogleGenAI } from "@google/genai";
    import * as fs from "node:fs";

    async function main() {

      const ai = new GoogleGenAI({});

      const prompt =
        "A kawaii-style sticker of a happy red panda wearing a tiny bamboo hat. It's munching on a green bamboo leaf. The design features bold, clean outlines, simple cel-shading, and a vibrant color palette. The background must be white.";

      const response = await ai.models.generateContent({
        model: "gemini-2.5-flash-image",
        contents: prompt,
      });
      for (const part of response.candidates[0].content.parts) {
        if (part.text) {
          console.log(part.text);
        } else if (part.inlineData) {
          const imageData = part.inlineData.data;
          const buffer = Buffer.from(imageData, "base64");
          fs.writeFileSync("red_panda_sticker.png", buffer);
          console.log("Image saved as red_panda_sticker.png");
        }
      }
    }

    main();

### Go

    package main

    import (
        "context"
        "fmt"
        "log"
        "os"
        "google.golang.org/genai"
    )

    func main() {

        ctx := context.Background()
        client, err := genai.NewClient(ctx, nil)
        if err != nil {
            log.Fatal(err)
        }

        result, _ := client.Models.GenerateContent(
            ctx,
            "gemini-2.5-flash-image",
            genai.Text("A kawaii-style sticker of a happy red panda wearing a tiny bamboo hat. It's munching on a green bamboo leaf. The design features bold, clean outlines, simple cel-shading, and a vibrant color palette. The background must be white."),
        )

        for _, part := range result.Candidates[0].Content.Parts {
            if part.Text != "" {
                fmt.Println(part.Text)
            } else if part.InlineData != nil {
                imageBytes := part.InlineData.Data
                outputFilename := "red_panda_sticker.png"
                _ = os.WriteFile(outputFilename, imageBytes, 0644)
            }
        }
    }

### REST

    curl -s -X POST
      "https://generativelanguage.googleapis.com/v1beta/models/gemini-2.5-flash-image:generateContent" \
      -H "x-goog-api-key: $GEMINI_API_KEY" \
      -H "Content-Type: application/json" \
      -d '{
        "contents": [{
          "parts": [
            {"text": "A kawaii-style sticker of a happy red panda wearing a tiny bamboo hat. It'"'"'s munching on a green bamboo leaf. The design features bold, clean outlines, simple cel-shading, and a vibrant color palette. The background must be white."}
          ]
        }]
      }' \
      | grep -o '"data": "[^"]*"' \
      | cut -d'"' -f4 \
      | base64 --decode > red_panda_sticker.png

![A kawaii-style sticker of a happy red...](https://ai.google.dev/static/gemini-api/docs/images/red_panda_sticker.png)A kawaii-style sticker of a happy red panda...

#### 3. Accurate text in images

Gemini excels at rendering text. Be clear about the text, the font style (descriptively), and the overall design. Use Gemini 3 Pro Image Preview for professional asset production.

### Template

    Create a [image type] for [brand/concept] with the text "[text to render]"
    in a [font style]. The design should be [style description], with a
    [color scheme].

### Prompt

    Create a modern, minimalist logo for a coffee shop called 'The Daily Grind'. The text should be in a clean, bold, sans-serif font. The color scheme is black and white. Put the logo in a circle. Use a coffee bean in a clever way.

### Python

    from google import genai
    from google.genai import types

    client = genai.Client()

    response = client.models.generate_content(
        model="gemini-3-pro-image-preview",
        contents="Create a modern, minimalist logo for a coffee shop called 'The Daily Grind'. The text should be in a clean, bold, sans-serif font. The color scheme is black and white. Put the logo in a circle. Use a coffee bean in a clever way.",
        config=types.GenerateContentConfig(
            image_config=types.ImageConfig(
                aspect_ratio="1:1",
            )
        )
    )

    for part in response.parts:
        if part.text is not None:
            print(part.text)
        elif part.inline_data is not None:
            image = part.as_image()
            image.save("logo_example.jpg")

### Java

    import com.google.genai.Client;
    import com.google.genai.types.GenerateContentConfig;
    import com.google.genai.types.GenerateContentResponse;
    import com.google.genai.types.Part;
    import com.google.genai.types.ImageConfig;

    import java.io.IOException;
    import java.nio.file.Files;
    import java.nio.file.Paths;

    public class AccurateTextInImages {
      public static void main(String[] args) throws IOException {

        try (Client client = new Client()) {
          GenerateContentConfig config = GenerateContentConfig.builder()
              .responseModalities("TEXT", "IMAGE")
              .imageConfig(ImageConfig.builder()
                  .aspectRatio("1:1")
                  .build())
              .build();

          GenerateContentResponse response = client.models.generateContent(
              "gemini-3-pro-image-preview",
              """
              Create a modern, minimalist logo for a coffee shop called 'The Daily Grind'. The text should be in a clean, bold, sans-serif font. The color scheme is black and white. Put the logo in a circle. Use a coffee bean in a clever way.
              """,
              config);

          for (Part part : response.parts()) {
            if (part.text().isPresent()) {
              System.out.println(part.text().get());
            } else if (part.inlineData().isPresent()) {
              var blob = part.inlineData().get();
              if (blob.data().isPresent()) {
                Files.write(Paths.get("logo_example.jpg"), blob.data().get());
              }
            }
          }
        }
      }
    }

### JavaScript

    import { GoogleGenAI } from "@google/genai";
    import * as fs from "node:fs";

    async function main() {

      const ai = new GoogleGenAI({});

      const prompt =
        "Create a modern, minimalist logo for a coffee shop called 'The Daily Grind'. The text should be in a clean, bold, sans-serif font. The color scheme is black and white. Put the logo in a circle. Use a coffee bean in a clever way.";

      const response = await ai.models.generateContent({
        model: "gemini-3-pro-image-preview",
        contents: prompt,
        config: {
          imageConfig: {
            aspectRatio: "1:1",
          },
        },
      });
      for (const part of response.candidates[0].content.parts) {
        if (part.text) {
          console.log(part.text);
        } else if (part.inlineData) {
          const imageData = part.inlineData.data;
          const buffer = Buffer.from(imageData, "base64");
          fs.writeFileSync("logo_example.jpg", buffer);
          console.log("Image saved as logo_example.jpg");
        }
      }
    }

    main();

### Go

    package main

    import (
        "context"
        "fmt"
        "log"
        "os"
        "google.golang.org/genai"
    )

    func main() {

        ctx := context.Background()
        client, err := genai.NewClient(ctx, nil)
        if err != nil {
            log.Fatal(err)
        }

        result, _ := client.Models.GenerateContent(
            ctx,
            "gemini-3-pro-image-preview",
            genai.Text("Create a modern, minimalist logo for a coffee shop called 'The Daily Grind'. The text should be in a clean, bold, sans-serif font. The color scheme is black and white. Put the logo in a circle. Use a coffee bean in a clever way."),
            &genai.GenerateContentConfig{
                ImageConfig: &genai.ImageConfig{
                  AspectRatio: "1:1",
                },
            },
        )

        for _, part := range result.Candidates[0].Content.Parts {
            if part.Text != "" {
                fmt.Println(part.Text)
            } else if part.InlineData != nil {
                imageBytes := part.InlineData.Data
                outputFilename := "logo_example.jpg"
                _ = os.WriteFile(outputFilename, imageBytes, 0644)
            }
        }
    }

### REST

    curl -s -X POST
      "https://generativelanguage.googleapis.com/v1beta/models/gemini-3-pro-image-preview:generateContent" \
      -H "x-goog-api-key: $GEMINI_API_KEY" \
      -H "Content-Type: application/json" \
      -d '{
        "contents": [{
          "parts": [
            {"text": "Create a modern, minimalist logo for a coffee shop called '"'"'The Daily Grind'"'"'. The text should be in a clean, bold, sans-serif font. The color scheme is black and white. Put the logo in a circle. Use a coffee bean in a clever way."}
          ]
        }],
        "generationConfig": {
          "imageConfig": {
            "aspectRatio": "1:1"
          }
        }
      }' \
      | grep -o '"data": "[^"]*"' \
      | cut -d'"' -f4 \
      | base64 --decode > logo_example.jpg

![Create a modern, minimalist logo for a coffee shop called 'The Daily Grind'...](https://ai.google.dev/static/gemini-api/docs/images/logo_example.jpg)Create a modern, minimalist logo for a coffee shop called 'The Daily Grind'...

#### 4. Product mockups \& commercial photography

Perfect for creating clean, professional product shots for e-commerce, advertising, or branding.

### Template

    A high-resolution, studio-lit product photograph of a [product description]
    on a [background surface/description]. The lighting is a [lighting setup,
    e.g., three-point softbox setup] to [lighting purpose]. The camera angle is
    a [angle type] to showcase [specific feature]. Ultra-realistic, with sharp
    focus on [key detail]. [Aspect ratio].

### Prompt

    A high-resolution, studio-lit product photograph of a minimalist ceramic
    coffee mug in matte black, presented on a polished concrete surface. The
    lighting is a three-point softbox setup designed to create soft, diffused
    highlights and eliminate harsh shadows. The camera angle is a slightly
    elevated 45-degree shot to showcase its clean lines. Ultra-realistic, with
    sharp focus on the steam rising from the coffee. Square image.

### Python

    from google import genai
    from google.genai import types

    client = genai.Client()

    response = client.models.generate_content(
        model="gemini-2.5-flash-image",
        contents="A high-resolution, studio-lit product photograph of a minimalist ceramic coffee mug in matte black, presented on a polished concrete surface. The lighting is a three-point softbox setup designed to create soft, diffused highlights and eliminate harsh shadows. The camera angle is a slightly elevated 45-degree shot to showcase its clean lines. Ultra-realistic, with sharp focus on the steam rising from the coffee. Square image.",
    )

    for part in response.parts:
        if part.text is not None:
            print(part.text)
        elif part.inline_data is not None:
            image = part.as_image()
            image.save("product_mockup.png")

### Java

    import com.google.genai.Client;
    import com.google.genai.types.GenerateContentConfig;
    import com.google.genai.types.GenerateContentResponse;
    import com.google.genai.types.Part;

    import java.io.IOException;
    import java.nio.file.Files;
    import java.nio.file.Paths;

    public class ProductMockup {
      public static void main(String[] args) throws IOException {

        try (Client client = new Client()) {
          GenerateContentConfig config = GenerateContentConfig.builder()
              .responseModalities("TEXT", "IMAGE")
              .build();

          GenerateContentResponse response = client.models.generateContent(
              "gemini-2.5-flash-image",
              """
              A high-resolution, studio-lit product photograph of a minimalist
              ceramic coffee mug in matte black, presented on a polished
              concrete surface. The lighting is a three-point softbox setup
              designed to create soft, diffused highlights and eliminate harsh
              shadows. The camera angle is a slightly elevated 45-degree shot
              to showcase its clean lines. Ultra-realistic, with sharp focus
              on the steam rising from the coffee. Square image.
              """,
              config);

          for (Part part : response.parts()) {
            if (part.text().isPresent()) {
              System.out.println(part.text().get());
            } else if (part.inlineData().isPresent()) {
              var blob = part.inlineData().get();
              if (blob.data().isPresent()) {
                Files.write(Paths.get("product_mockup.png"), blob.data().get());
              }
            }
          }
        }
      }
    }

### JavaScript

    import { GoogleGenAI } from "@google/genai";
    import * as fs from "node:fs";

    async function main() {

      const ai = new GoogleGenAI({});

      const prompt =
        "A high-resolution, studio-lit product photograph of a minimalist ceramic coffee mug in matte black, presented on a polished concrete surface. The lighting is a three-point softbox setup designed to create soft, diffused highlights and eliminate harsh shadows. The camera angle is a slightly elevated 45-degree shot to showcase its clean lines. Ultra-realistic, with sharp focus on the steam rising from the coffee. Square image.";

      const response = await ai.models.generateContent({
        model: "gemini-2.5-flash-image",
        contents: prompt,
      });
      for (const part of response.candidates[0].content.parts) {
        if (part.text) {
          console.log(part.text);
        } else if (part.inlineData) {
          const imageData = part.inlineData.data;
          const buffer = Buffer.from(imageData, "base64");
          fs.writeFileSync("product_mockup.png", buffer);
          console.log("Image saved as product_mockup.png");
        }
      }
    }

    main();

### Go

    package main

    import (
        "context"
        "fmt"
        "log"
        "os"
        "google.golang.org/genai"
    )

    func main() {

        ctx := context.Background()
        client, err := genai.NewClient(ctx, nil)
        if err != nil {
            log.Fatal(err)
        }

        result, _ := client.Models.GenerateContent(
            ctx,
            "gemini-2.5-flash-image",
            genai.Text("A high-resolution, studio-lit product photograph of a minimalist ceramic coffee mug in matte black, presented on a polished concrete surface. The lighting is a three-point softbox setup designed to create soft, diffused highlights and eliminate harsh shadows. The camera angle is a slightly elevated 45-degree shot to showcase its clean lines. Ultra-realistic, with sharp focus on the steam rising from the coffee. Square image."),
        )

        for _, part := range result.Candidates[0].Content.Parts {
            if part.Text != "" {
                fmt.Println(part.Text)
            } else if part.InlineData != nil {
                imageBytes := part.InlineData.Data
                outputFilename := "product_mockup.png"
                _ = os.WriteFile(outputFilename, imageBytes, 0644)
            }
        }
    }

### REST

    curl -s -X POST
      "https://generativelanguage.googleapis.com/v1beta/models/gemini-2.5-flash-image:generateContent" \
      -H "x-goog-api-key: $GEMINI_API_KEY" \
      -H "Content-Type: application/json" \
      -d '{
        "contents": [{
          "parts": [
            {"text": "A high-resolution, studio-lit product photograph of a minimalist ceramic coffee mug in matte black, presented on a polished concrete surface. The lighting is a three-point softbox setup designed to create soft, diffused highlights and eliminate harsh shadows. The camera angle is a slightly elevated 45-degree shot to showcase its clean lines. Ultra-realistic, with sharp focus on the steam rising from the coffee. Square image."}
          ]
        }]
      }' \
      | grep -o '"data": "[^"]*"' \
      | cut -d'"' -f4 \
      | base64 --decode > product_mockup.png

![A high-resolution, studio-lit product photograph of a minimalist ceramic coffee mug...](https://ai.google.dev/static/gemini-api/docs/images/product_mockup.png)A high-resolution, studio-lit product photograph of a minimalist ceramic coffee mug...

#### 5. Minimalist \& negative space design

Excellent for creating backgrounds for websites, presentations, or marketing materials where text will be overlaid.

### Template

    A minimalist composition featuring a single [subject] positioned in the
    [bottom-right/top-left/etc.] of the frame. The background is a vast, empty
    [color] canvas, creating significant negative space. Soft, subtle lighting.
    [Aspect ratio].

### Prompt

    A minimalist composition featuring a single, delicate red maple leaf
    positioned in the bottom-right of the frame. The background is a vast, empty
    off-white canvas, creating significant negative space for text. Soft,
    diffused lighting from the top left. Square image.

### Python

    from google import genai
    from google.genai import types

    client = genai.Client()

    response = client.models.generate_content(
        model="gemini-2.5-flash-image",
        contents="A minimalist composition featuring a single, delicate red maple leaf positioned in the bottom-right of the frame. The background is a vast, empty off-white canvas, creating significant negative space for text. Soft, diffused lighting from the top left. Square image.",
    )

    for part in response.parts:
        if part.text is not None:
            print(part.text)
        elif part.inline_data is not None:
            image = part.as_image()
            image.save("minimalist_design.png")

### Java

    import com.google.genai.Client;
    import com.google.genai.types.GenerateContentConfig;
    import com.google.genai.types.GenerateContentResponse;
    import com.google.genai.types.Part;

    import java.io.IOException;
    import java.nio.file.Files;
    import java.nio.file.Paths;

    public class MinimalistDesign {
      public static void main(String[] args) throws IOException {

        try (Client client = new Client()) {
          GenerateContentConfig config = GenerateContentConfig.builder()
              .responseModalities("TEXT", "IMAGE")
              .build();

          GenerateContentResponse response = client.models.generateContent(
              "gemini-2.5-flash-image",
              """
              A minimalist composition featuring a single, delicate red maple
              leaf positioned in the bottom-right of the frame. The background
              is a vast, empty off-white canvas, creating significant negative
              space for text. Soft, diffused lighting from the top left.
              Square image.
              """,
              config);

          for (Part part : response.parts()) {
            if (part.text().isPresent()) {
              System.out.println(part.text().get());
            } else if (part.inlineData().isPresent()) {
              var blob = part.inlineData().get();
              if (blob.data().isPresent()) {
                Files.write(Paths.get("minimalist_design.png"), blob.data().get());
              }
            }
          }
        }
      }
    }

### JavaScript

    import { GoogleGenAI } from "@google/genai";
    import * as fs from "node:fs";

    async function main() {

      const ai = new GoogleGenAI({});

      const prompt =
        "A minimalist composition featuring a single, delicate red maple leaf positioned in the bottom-right of the frame. The background is a vast, empty off-white canvas, creating significant negative space for text. Soft, diffused lighting from the top left. Square image.";

      const response = await ai.models.generateContent({
        model: "gemini-2.5-flash-image",
        contents: prompt,
      });
      for (const part of response.candidates[0].content.parts) {
        if (part.text) {
          console.log(part.text);
        } else if (part.inlineData) {
          const imageData = part.inlineData.data;
          const buffer = Buffer.from(imageData, "base64");
          fs.writeFileSync("minimalist_design.png", buffer);
          console.log("Image saved as minimalist_design.png");
        }
      }
    }

    main();

### Go

    package main

    import (
        "context"
        "fmt"
        "log"
        "os"
        "google.golang.org/genai"
    )

    func main() {

        ctx := context.Background()
        client, err := genai.NewClient(ctx, nil)
        if err != nil {
            log.Fatal(err)
        }

        result, _ := client.Models.GenerateContent(
            ctx,
            "gemini-2.5-flash-image",
            genai.Text("A minimalist composition featuring a single, delicate red maple leaf positioned in the bottom-right of the frame. The background is a vast, empty off-white canvas, creating significant negative space for text. Soft, diffused lighting from the top left. Square image."),
        )

        for _, part := range result.Candidates[0].Content.Parts {
            if part.Text != "" {
                fmt.Println(part.Text)
            } else if part.InlineData != nil {
                imageBytes := part.InlineData.Data
                outputFilename := "minimalist_design.png"
                _ = os.WriteFile(outputFilename, imageBytes, 0644)
            }
        }
    }

### REST

    curl -s -X POST
      "https://generativelanguage.googleapis.com/v1beta/models/gemini-2.5-flash-image:generateContent" \
      -H "x-goog-api-key: $GEMINI_API_KEY" \
      -H "Content-Type: application/json" \
      -d '{
        "contents": [{
          "parts": [
            {"text": "A minimalist composition featuring a single, delicate red maple leaf positioned in the bottom-right of the frame. The background is a vast, empty off-white canvas, creating significant negative space for text. Soft, diffused lighting from the top left. Square image."}
          ]
        }]
      }' \
      | grep -o '"data": "[^"]*"' \
      | cut -d'"' -f4 \
      | base64 --decode > minimalist_design.png

![A minimalist composition featuring a single, delicate red maple leaf...](https://ai.google.dev/static/gemini-api/docs/images/minimalist_design.png)A minimalist composition featuring a single, delicate red maple leaf...

#### 6. Sequential art (Comic panel / Storyboard)

Builds on character consistency and scene description to create panels for visual storytelling. For accuracy with text and storytelling ability, these prompts work best with Gemini 3 Pro Image Preview.

### Template

    Make a 3 panel comic in a [style]. Put the character in a [type of scene].

### Prompt

    Make a 3 panel comic in a gritty, noir art style with high-contrast black and white inks. Put the character in a humurous scene.

### Python

    from google import genai
    from google.genai import types
    from PIL import Image

    client = genai.Client()

    image_input = Image.open('/path/to/your/man_in_white_glasses.jpg')
    text_input = "Make a 3 panel comic in a gritty, noir art style with high-contrast black and white inks. Put the character in a humurous scene."

    response = client.models.generate_content(
        model="gemini-3-pro-image-preview",
        contents=[text_input, image_input],
    )

    for part in response.parts:
        if part.text is not None:
            print(part.text)
        elif part.inline_data is not None:
            image = part.as_image()
            image.save("comic_panel.jpg")

### Java

    import com.google.genai.Client;
    import com.google.genai.types.Content;
    import com.google.genai.types.GenerateContentConfig;
    import com.google.genai.types.GenerateContentResponse;
    import com.google.genai.types.Part;

    import java.io.IOException;
    import java.nio.file.Files;
    import java.nio.file.Path;
    import java.nio.file.Paths;

    public class ComicPanel {
      public static void main(String[] args) throws IOException {

        try (Client client = new Client()) {
          GenerateContentConfig config = GenerateContentConfig.builder()
              .responseModalities("TEXT", "IMAGE")
              .build();

          GenerateContentResponse response = client.models.generateContent(
              "gemini-3-pro-image-preview",
              Content.fromParts(
                  Part.fromText("""
                      Make a 3 panel comic in a gritty, noir art style with high-contrast black and white inks. Put the character in a humurous scene.
                      """),
                  Part.fromBytes(
                      Files.readAllBytes(
                          Path.of("/path/to/your/man_in_white_glasses.jpg")),
                      "image/jpeg")),
              config);

          for (Part part : response.parts()) {
            if (part.text().isPresent()) {
              System.out.println(part.text().get());
            } else if (part.inlineData().isPresent()) {
              var blob = part.inlineData().get();
              if (blob.data().isPresent()) {
                Files.write(Paths.get("comic_panel.jpg"), blob.data().get());
              }
            }
          }
        }
      }
    }

### JavaScript

    import { GoogleGenAI } from "@google/genai";
    import * as fs from "node:fs";

    async function main() {

      const ai = new GoogleGenAI({});

      const imagePath = "/path/to/your/man_in_white_glasses.jpg";
      const imageData = fs.readFileSync(imagePath);
      const base64Image = imageData.toString("base64");

      const prompt = [
        {text: "Make a 3 panel comic in a gritty, noir art style with high-contrast black and white inks. Put the character in a humurous scene."},
        {
          inlineData: {
            mimeType: "image/jpeg",
            data: base64Image,
          },
        },
      ];

      const response = await ai.models.generateContent({
        model: "gemini-3-pro-image-preview",
        contents: prompt,
      });
      for (const part of response.candidates[0].content.parts) {
        if (part.text) {
          console.log(part.text);
        } else if (part.inlineData) {
          const imageData = part.inlineData.data;
          const buffer = Buffer.from(imageData, "base64");
          fs.writeFileSync("comic_panel.jpg", buffer);
          console.log("Image saved as comic_panel.jpg");
        }
      }
    }

    main();

### Go

    package main

    import (
        "context"
        "fmt"
        "log"
        "os"
        "google.golang.org/genai"
    )

    func main() {

        ctx := context.Background()
        client, err := genai.NewClient(ctx, nil)
        if err != nil {
            log.Fatal(err)
        }

        imagePath := "/path/to/your/man_in_white_glasses.jpg"
        imgData, _ := os.ReadFile(imagePath)

        parts := []*genai.Part{
          genai.NewPartFromText("Make a 3 panel comic in a gritty, noir art style with high-contrast black and white inks. Put the character in a humurous scene."),
          &genai.Part{
            InlineData: &genai.Blob{
              MIMEType: "image/jpeg",
              Data:     imgData,
            },
          },
        }

        contents := []*genai.Content{
          genai.NewContentFromParts(parts, genai.RoleUser),
        }

        result, _ := client.Models.GenerateContent(
            ctx,
            "gemini-3-pro-image-preview",
            contents,
        )

        for _, part := range result.Candidates[0].Content.Parts {
            if part.Text != "" {
                fmt.Println(part.Text)
            } else if part.InlineData != nil {
                imageBytes := part.InlineData.Data
                outputFilename := "comic_panel.jpg"
                _ = os.WriteFile(outputFilename, imageBytes, 0644)
            }
        }
    }

### REST

    IMG_PATH=/path/to/your/man_in_white_glasses.jpg

    if [[ "$(base64 --version 2>&1)" = *"FreeBSD"* ]]; then
      B64FLAGS="--input"
    else
      B64FLAGS="-w0"
    fi

    IMG_BASE64=$(base64 "$B64FLAGS" "$IMG_PATH" 2>&1)

    curl -s -X POST
      "https://generativelanguage.googleapis.com/v1beta/models/gemini-3-pro-image-preview:generateContent" \
      -H "x-goog-api-key: $GEMINI_API_KEY" \
      -H "Content-Type: application/json" \
      -d "{
        \"contents\": [{
          \"parts\": [
            {\"text\": \"Make a 3 panel comic in a gritty, noir art style with high-contrast black and white inks. Put the character in a humurous scene.\"},
            {\"inline_data\": {\"mime_type\":\"image/jpeg\", \"data\": \"$IMG_BASE64\"}}
          ]
        }]
      }" \
      | grep -o '"data": "[^"]*"' \
      | cut -d'"' -f4 \
      | base64 --decode > comic_panel.jpg

|------------------------------------------------------------------------------------------------------------------|--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------|
| Input | Output |
| ![Man in white glasses](https://ai.google.dev/static/gemini-api/docs/images/man_in_white_glasses.jpg)Input image | ![Make a 3 panel comic in a gritty, noir art style...](https://ai.google.dev/static/gemini-api/docs/images/comic_panel.jpg)Make a 3 panel comic in a gritty, noir art style... |

#### 7. Grounding with Google Search

Use Google Search to generate images based on recent or real-time information. This is useful for news, weather, and other time-sensitive topics.

### Prompt

    Make a simple but stylish graphic of last night's Arsenal game in the Champion's League

### Python

    from google import genai
    from google.genai import types
    prompt = "Make a simple but stylish graphic of last night's Arsenal game in the Champion's League"
    aspect_ratio = "16:9" # "1:1","2:3","3:2","3:4","4:3","4:5","5:4","9:16","16:9","21:9"

    client = genai.Client()

    response = client.models.generate_content(
        model="gemini-3-pro-image-preview",
        contents=prompt,
        config=types.GenerateContentConfig(
            response_modalities=['Text', 'Image'],
            image_config=types.ImageConfig(
                aspect_ratio=aspect_ratio,
            ),
            tools=[{"google_search": {}}]
        )
    )

    for part in response.parts:
        if part.text is not None:
            print(part.text)
        elif image:= part.as_image():
            image.save("football-score.jpg")

### Java

    import com.google.genai.Client;
    import com.google.genai.types.GenerateContentConfig;
    import com.google.genai.types.GenerateContentResponse;
    import com.google.genai.types.GoogleSearch;
    import com.google.genai.types.ImageConfig;
    import com.google.genai.types.Part;
    import com.google.genai.types.Tool;

    import java.io.IOException;
    import java.nio.file.Files;
    import java.nio.file.Paths;

    public class SearchGrounding {
      public static void main(String[] args) throws IOException {

        try (Client client = new Client()) {
          GenerateContentConfig config = GenerateContentConfig.builder()
              .responseModalities("TEXT", "IMAGE")
              .imageConfig(ImageConfig.builder()
                  .aspectRatio("16:9")
                  .build())
              .tools(Tool.builder()
                  .googleSearch(GoogleSearch.builder().build())
                  .build())
              .build();

          GenerateContentResponse response = client.models.generateContent(
              "gemini-3-pro-image-preview", """
                  Make a simple but stylish graphic of last night's Arsenal game in the Champion's League
                  """,
              config);

          for (Part part : response.parts()) {
            if (part.text().isPresent()) {
              System.out.println(part.text().get());
            } else if (part.inlineData().isPresent()) {
              var blob = part.inlineData().get();
              if (blob.data().isPresent()) {
                Files.write(Paths.get("football-score.jpg"), blob.data().get());
              }
            }
          }
        }
      }
    }

### JavaScript

    import { GoogleGenAI } from "@google/genai";
    import * as fs from "node:fs";

    async function main() {

      const ai = new GoogleGenAI({});

      const prompt = "Make a simple but stylish graphic of last night's Arsenal game in the Champion's League";

      const aspectRatio = '16:9';
      const resolution = '2K';

    const response = await ai.models.generateContent({
        model: 'gemini-3-pro-image-preview',
        contents: prompt,
        config: {
          responseModalities: ['TEXT', 'IMAGE'],
          imageConfig: {
            aspectRatio: aspectRatio,
            imageSize: resolution,
          },
          tools: [{"google_search": {}}],
        },
      });

      for (const part of response.candidates[0].content.parts) {
        if (part.text) {
          console.log(part.text);
        } else if (part.inlineData) {
          const imageData = part.inlineData.data;
          const buffer = Buffer.from(imageData, "base64");
          fs.writeFileSync("football-score.jpg", buffer);
          console.log("Image saved as football-score.jpg");
        }
      }

    }

    main();

### Go

    package main

    import (
        "context"
        "fmt"
        "log"
        "os"

        "google.golang.org/genai"
        pb "google.golang.org/genai/schema"
    )

    func main() {
        ctx := context.Background()
        client, err := genai.NewClient(ctx, nil)
        if err != nil {
            log.Fatal(err)
        }
        defer client.Close()

        model := client.GenerativeModel("gemini-3-pro-image-preview")
        model.Tools = []*pb.Tool{
            pb.NewGoogleSearchTool(),
        }
        model.GenerationConfig = &pb.GenerationConfig{
            ResponseModalities: []pb.ResponseModality{genai.Text, genai.Image},
            ImageConfig: &pb.ImageConfig{
                AspectRatio: "16:9",
            },
        }

        prompt := "Make a simple but stylish graphic of last night's Arsenal game in the Champion's League"
        resp, err := model.GenerateContent(ctx, genai.Text(prompt))
        if err != nil {
            log.Fatal(err)
        }

        for _, part := range resp.Candidates[0].Content.Parts {
            if txt, ok := part.(genai.Text); ok {
                fmt.Printf("%s", string(txt))
            } else if img, ok := part.(genai.ImageData); ok {
                err := os.WriteFile("football-score.jpg", img.Data, 0644)
                if err != nil {
                    log.Fatal(err)
                }
            }
        }
    }

### REST

    curl -s -X POST \
      "https://generativelanguage.googleapis.com/v1beta/models/gemini-3-pro-image-preview:generateContent" \
      -H "x-goog-api-key: $GEMINI_API_KEY" \
      -H "Content-Type: application/json" \
      -d '{
        "contents": [{"parts": [{"text": "Make a simple but stylish graphic of last nights Arsenal game in the Champions League"}]}],
        "tools": [{"google_search": {}}],
        "generationConfig": {
          "responseModalities": ["TEXT", "IMAGE"],
          "imageConfig": {"aspectRatio": "16:9"}
        }
      }" | jq -r '.candidates[0].content.parts[] | select(.inlineData) | .inlineData.data' | head -1 | base64 --decode > football-score.jpg

![AI-generated graphic of an Arsenal football score](https://ai.google.dev/static/gemini-api/docs/images/football-score.jpg)AI-generated graphic of an Arsenal football score

### Prompts for editing images

These examples show how to provide images alongside your text prompts for editing, composition, and style transfer.

#### 1. Adding and removing elements

Provide an image and describe your change. The model will match the original image's style, lighting, and perspective.

### Template

    Using the provided image of [subject], please [add/remove/modify] [element]
    to/from the scene. Ensure the change is [description of how the change should
    integrate].

### Prompt

    "Using the provided image of my cat, please add a small, knitted wizard hat
    on its head. Make it look like it's sitting comfortably and matches the soft
    lighting of the photo."

### Python

    from google import genai
    from google.genai import types
    from PIL import Image

    client = genai.Client()

    # Base image prompt: "A photorealistic picture of a fluffy ginger cat sitting on a wooden floor, looking directly at the camera. Soft, natural light from a window."
    image_input = Image.open('/path/to/your/cat_photo.png')
    text_input = """Using the provided image of my cat, please add a small, knitted wizard hat on its head. Make it look like it's sitting comfortably and not falling off."""

    # Generate an image from a text prompt
    response = client.models.generate_content(
        model="gemini-2.5-flash-image",
        contents=[text_input, image_input],
    )

    for part in response.parts:
        if part.text is not None:
            print(part.text)
        elif part.inline_data is not None:
            image = part.as_image()
            image.save("cat_with_hat.png")

### Java

    import com.google.genai.Client;
    import com.google.genai.types.Content;
    import com.google.genai.types.GenerateContentConfig;
    import com.google.genai.types.GenerateContentResponse;
    import com.google.genai.types.Part;

    import java.io.IOException;
    import java.nio.file.Files;
    import java.nio.file.Path;
    import java.nio.file.Paths;

    public class AddRemoveElements {
      public static void main(String[] args) throws IOException {

        try (Client client = new Client()) {
          GenerateContentConfig config = GenerateContentConfig.builder()
              .responseModalities("TEXT", "IMAGE")
              .build();

          GenerateContentResponse response = client.models.generateContent(
              "gemini-2.5-flash-image",
              Content.fromParts(
                  Part.fromText("""
                      Using the provided image of my cat, please add a small,
                      knitted wizard hat on its head. Make it look like it's
                      sitting comfortably and not falling off.
                      """),
                  Part.fromBytes(
                      Files.readAllBytes(
                          Path.of("/path/to/your/cat_photo.png")),
                      "image/png")),
              config);

          for (Part part : response.parts()) {
            if (part.text().isPresent()) {
              System.out.println(part.text().get());
            } else if (part.inlineData().isPresent()) {
              var blob = part.inlineData().get();
              if (blob.data().isPresent()) {
                Files.write(Paths.get("cat_with_hat.png"), blob.data().get());
              }
            }
          }
        }
      }
    }

### JavaScript

    import { GoogleGenAI } from "@google/genai";
    import * as fs from "node:fs";

    async function main() {

      const ai = new GoogleGenAI({});

      const imagePath = "/path/to/your/cat_photo.png";
      const imageData = fs.readFileSync(imagePath);
      const base64Image = imageData.toString("base64");

      const prompt = [
        { text: "Using the provided image of my cat, please add a small, knitted wizard hat on its head. Make it look like it's sitting comfortably and not falling off." },
        {
          inlineData: {
            mimeType: "image/png",
            data: base64Image,
          },
        },
      ];

      const response = await ai.models.generateContent({
        model: "gemini-2.5-flash-image",
        contents: prompt,
      });
      for (const part of response.candidates[0].content.parts) {
        if (part.text) {
          console.log(part.text);
        } else if (part.inlineData) {
          const imageData = part.inlineData.data;
          const buffer = Buffer.from(imageData, "base64");
          fs.writeFileSync("cat_with_hat.png", buffer);
          console.log("Image saved as cat_with_hat.png");
        }
      }
    }

    main();

### Go

    package main

    import (
      "context"
      "fmt"
      "log"
      "os"
      "google.golang.org/genai"
    )

    func main() {

      ctx := context.Background()
      client, err := genai.NewClient(ctx, nil)
      if err != nil {
          log.Fatal(err)
      }

      imagePath := "/path/to/your/cat_photo.png"
      imgData, _ := os.ReadFile(imagePath)

      parts := []*genai.Part{
        genai.NewPartFromText("Using the provided image of my cat, please add a small, knitted wizard hat on its head. Make it look like it's sitting comfortably and not falling off."),
        &genai.Part{
          InlineData: &genai.Blob{
            MIMEType: "image/png",
            Data:     imgData,
          },
        },
      }

      contents := []*genai.Content{
        genai.NewContentFromParts(parts, genai.RoleUser),
      }

      result, _ := client.Models.GenerateContent(
          ctx,
          "gemini-2.5-flash-image",
          contents,
      )

      for _, part := range result.Candidates[0].Content.Parts {
          if part.Text != "" {
              fmt.Println(part.Text)
          } else if part.InlineData != nil {
              imageBytes := part.InlineData.Data
              outputFilename := "cat_with_hat.png"
              _ = os.WriteFile(outputFilename, imageBytes, 0644)
          }
      }
    }

### REST

    IMG_PATH=/path/to/your/cat_photo.png

    if [[ "$(base64 --version 2>&1)" = *"FreeBSD"* ]]; then
      B64FLAGS="--input"
    else
      B64FLAGS="-w0"
    fi

    IMG_BASE64=$(base64 "$B64FLAGS" "$IMG_PATH" 2>&1)

    curl -X POST \
      "https://generativelanguage.googleapis.com/v1beta/models/gemini-2.5-flash-image:generateContent" \
        -H "x-goog-api-key: $GEMINI_API_KEY" \
        -H 'Content-Type: application/json' \
        -d "{
          \"contents\": [{
            \"parts\":[
                {\"text\": \"Using the provided image of my cat, please add a small, knitted wizard hat on its head. Make it look like it's sitting comfortably and not falling off.\"},
                {
                  \"inline_data\": {
                    \"mime_type\":\"image/png\",
                    \"data\": \"$IMG_BASE64\"
                  }
                }
            ]
          }]
        }"  \
      | grep -o '"data": "[^"]*"' \
      | cut -d'"' -f4 \
      | base64 --decode > cat_with_hat.png

|---------------------------------------------------------|-------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------|
| Input | Output |
| :cat:A photorealistic picture of a fluffy ginger cat... | ![Using the provided image of my cat, please add a small, knitted wizard hat...](https://ai.google.dev/static/gemini-api/docs/images/cat_with_hat.png)Using the provided image of my cat, please add a small, knitted wizard hat... |

#### 2. Inpainting (Semantic masking)

Conversationally define a "mask" to edit a specific part of an image while leaving the rest untouched.

### Template

    Using the provided image, change only the [specific element] to [new
    element/description]. Keep everything else in the image exactly the same,
    preserving the original style, lighting, and composition.

### Prompt

    "Using the provided image of a living room, change only the blue sofa to be
    a vintage, brown leather chesterfield sofa. Keep the rest of the room,
    including the pillows on the sofa and the lighting, unchanged."

### Python

    from google import genai
    from google.genai import types
    from PIL import Image

    client = genai.Client()

    # Base image prompt: "A wide shot of a modern, well-lit living room with a prominent blue sofa in the center. A coffee table is in front of it and a large window is in the background."
    living_room_image = Image.open('/path/to/your/living_room.png')
    text_input = """Using the provided image of a living room, change only the blue sofa to be a vintage, brown leather chesterfield sofa. Keep the rest of the room, including the pillows on the sofa and the lighting, unchanged."""

    # Generate an image from a text prompt
    response = client.models.generate_content(
        model="gemini-2.5-flash-image",
        contents=[living_room_image, text_input],
    )

    for part in response.parts:
        if part.text is not None:
            print(part.text)
        elif part.inline_data is not None:
            image = part.as_image()
            image.save("living_room_edited.png")

### Java

    import com.google.genai.Client;
    import com.google.genai.types.Content;
    import com.google.genai.types.GenerateContentConfig;
    import com.google.genai.types.GenerateContentResponse;
    import com.google.genai.types.Part;

    import java.io.IOException;
    import java.nio.file.Files;
    import java.nio.file.Path;
    import java.nio.file.Paths;

    public class Inpainting {
      public static void main(String[] args) throws IOException {

        try (Client client = new Client()) {
          GenerateContentConfig config = GenerateContentConfig.builder()
              .responseModalities("TEXT", "IMAGE")
              .build();

          GenerateContentResponse response = client.models.generateContent(
              "gemini-2.5-flash-image",
              Content.fromParts(
                  Part.fromBytes(
                      Files.readAllBytes(
                          Path.of("/path/to/your/living_room.png")),
                      "image/png"),
                  Part.fromText("""
                      Using the provided image of a living room, change
                      only the blue sofa to be a vintage, brown leather
                      chesterfield sofa. Keep the rest of the room,
                      including the pillows on the sofa and the lighting,
                      unchanged.
                      """)),
              config);

          for (Part part : response.parts()) {
            if (part.text().isPresent()) {
              System.out.println(part.text().get());
            } else if (part.inlineData().isPresent()) {
              var blob = part.inlineData().get();
              if (blob.data().isPresent()) {
                Files.write(Paths.get("living_room_edited.png"), blob.data().get());
              }
            }
          }
        }
      }
    }

### JavaScript

    import { GoogleGenAI } from "@google/genai";
    import * as fs from "node:fs";

    async function main() {

      const ai = new GoogleGenAI({});

      const imagePath = "/path/to/your/living_room.png";
      const imageData = fs.readFileSync(imagePath);
      const base64Image = imageData.toString("base64");

      const prompt = [
        {
          inlineData: {
            mimeType: "image/png",
            data: base64Image,
          },
        },
        { text: "Using the provided image of a living room, change only the blue sofa to be a vintage, brown leather chesterfield sofa. Keep the rest of the room, including the pillows on the sofa and the lighting, unchanged." },
      ];

      const response = await ai.models.generateContent({
        model: "gemini-2.5-flash-image",
        contents: prompt,
      });
      for (const part of response.candidates[0].content.parts) {
        if (part.text) {
          console.log(part.text);
        } else if (part.inlineData) {
          const imageData = part.inlineData.data;
          const buffer = Buffer.from(imageData, "base64");
          fs.writeFileSync("living_room_edited.png", buffer);
          console.log("Image saved as living_room_edited.png");
        }
      }
    }

    main();

### Go

    package main

    import (
      "context"
      "fmt"
      "log"
      "os"
      "google.golang.org/genai"
    )

    func main() {

      ctx := context.Background()
      client, err := genai.NewClient(ctx, nil)
      if err != nil {
          log.Fatal(err)
      }

      imagePath := "/path/to/your/living_room.png"
      imgData, _ := os.ReadFile(imagePath)

      parts := []*genai.Part{
        &genai.Part{
          InlineData: &genai.Blob{
            MIMEType: "image/png",
            Data:     imgData,
          },
        },
        genai.NewPartFromText("Using the provided image of a living room, change only the blue sofa to be a vintage, brown leather chesterfield sofa. Keep the rest of the room, including the pillows on the sofa and the lighting, unchanged."),
      }

      contents := []*genai.Content{
        genai.NewContentFromParts(parts, genai.RoleUser),
      }

      result, _ := client.Models.GenerateContent(
          ctx,
          "gemini-2.5-flash-image",
          contents,
      )

      for _, part := range result.Candidates[0].Content.Parts {
          if part.Text != "" {
              fmt.Println(part.Text)
          } else if part.InlineData != nil {
              imageBytes := part.InlineData.Data
              outputFilename := "living_room_edited.png"
              _ = os.WriteFile(outputFilename, imageBytes, 0644)
          }
      }
    }

### REST

    IMG_PATH=/path/to/your/living_room.png

    if [[ "$(base64 --version 2>&1)" = *"FreeBSD"* ]]; then
      B64FLAGS="--input"
    else
      B64FLAGS="-w0"
    fi

    IMG_BASE64=$(base64 "$B64FLAGS" "$IMG_PATH" 2>&1)

    curl -X POST \
      "https://generativelanguage.googleapis.com/v1beta/models/gemini-2.5-flash-image:generateContent" \
        -H "x-goog-api-key: $GEMINI_API_KEY" \
        -H 'Content-Type: application/json' \
        -d "{
          \"contents\": [{
            \"parts\":[
                {
                  \"inline_data\": {
                    \"mime_type\":\"image/png\",
                    \"data\": \"$IMG_BASE64\"
                  }
                },
                {\"text\": \"Using the provided image of a living room, change only the blue sofa to be a vintage, brown leather chesterfield sofa. Keep the rest of the room, including the pillows on the sofa and the lighting, unchanged.\"}
            ]
          }]
        }"  \
      | grep -o '"data": "[^"]*"' \
      | cut -d'"' -f4 \
      | base64 --decode > living_room_edited.png

|--------------------------------------------------------------------------------------------------------------------------------------------------------------------------|---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------|
| Input | Output |
| ![A wide shot of a modern, well-lit living room...](https://ai.google.dev/static/gemini-api/docs/images/living_room.png)A wide shot of a modern, well-lit living room... | ![Using the provided image of a living room, change only the blue sofa to be a vintage, brown leather chesterfield sofa...](https://ai.google.dev/static/gemini-api/docs/images/living_room_edited.png)Using the provided image of a living room, change only the blue sofa to be a vintage, brown leather chesterfield sofa... |

#### 3. Style transfer

Provide an image and ask the model to recreate its content in a different artistic style.

### Template

    Transform the provided photograph of [subject] into the artistic style of [artist/art style]. Preserve the original composition but render it with [description of stylistic elements].

### Prompt

    "Transform the provided photograph of a modern city street at night into the artistic style of Vincent van Gogh's 'Starry Night'. Preserve the original composition of buildings and cars, but render all elements with swirling, impasto brushstrokes and a dramatic palette of deep blues and bright yellows."

### Python

    from google import genai
    from google.genai import types
    from PIL import Image

    client = genai.Client()

    # Base image prompt: "A photorealistic, high-resolution photograph of a busy city street in New York at night, with bright neon signs, yellow taxis, and tall skyscrapers."
    city_image = Image.open('/path/to/your/city.png')
    text_input = """Transform the provided photograph of a modern city street at night into the artistic style of Vincent van Gogh's 'Starry Night'. Preserve the original composition of buildings and cars, but render all elements with swirling, impasto brushstrokes and a dramatic palette of deep blues and bright yellows."""

    # Generate an image from a text prompt
    response = client.models.generate_content(
        model="gemini-2.5-flash-image",
        contents=[city_image, text_input],
    )

    for part in response.parts:
        if part.text is not None:
            print(part.text)
        elif part.inline_data is not None:
            image = part.as_image()
            image.save("city_style_transfer.png")

### Java

    import com.google.genai.Client;
    import com.google.genai.types.Content;
    import com.google.genai.types.GenerateContentConfig;
    import com.google.genai.types.GenerateContentResponse;
    import com.google.genai.types.Part;

    import java.io.IOException;
    import java.nio.file.Files;
    import java.nio.file.Path;
    import java.nio.file.Paths;

    public class StyleTransfer {
      public static void main(String[] args) throws IOException {

        try (Client client = new Client()) {
          GenerateContentConfig config = GenerateContentConfig.builder()
              .responseModalities("TEXT", "IMAGE")
              .build();

          GenerateContentResponse response = client.models.generateContent(
              "gemini-2.5-flash-image",
              Content.fromParts(
                  Part.fromBytes(
                      Files.readAllBytes(
                          Path.of("/path/to/your/city.png")),
                      "image/png"),
                  Part.fromText("""
                      Transform the provided photograph of a modern city
                      street at night into the artistic style of
                      Vincent van Gogh's 'Starry Night'. Preserve the
                      original composition of buildings and cars, but
                      render all elements with swirling, impasto
                      brushstrokes and a dramatic palette of deep blues
                      and bright yellows.
                      """)),
              config);

          for (Part part : response.parts()) {
            if (part.text().isPresent()) {
              System.out.println(part.text().get());
            } else if (part.inlineData().isPresent()) {
              var blob = part.inlineData().get();
              if (blob.data().isPresent()) {
                Files.write(Paths.get("city_style_transfer.png"), blob.data().get());
              }
            }
          }
        }
      }
    }

### JavaScript

    import { GoogleGenAI } from "@google/genai";
    import * as fs from "node:fs";

    async function main() {

      const ai = new GoogleGenAI({});

      const imagePath = "/path/to/your/city.png";
      const imageData = fs.readFileSync(imagePath);
      const base64Image = imageData.toString("base64");

      const prompt = [
        {
          inlineData: {
            mimeType: "image/png",
            data: base64Image,
          },
        },
        { text: "Transform the provided photograph of a modern city street at night into the artistic style of Vincent van Gogh's 'Starry Night'. Preserve the original composition of buildings and cars, but render all elements with swirling, impasto brushstrokes and a dramatic palette of deep blues and bright yellows." },
      ];

      const response = await ai.models.generateContent({
        model: "gemini-2.5-flash-image",
        contents: prompt,
      });
      for (const part of response.candidates[0].content.parts) {
        if (part.text) {
          console.log(part.text);
        } else if (part.inlineData) {
          const imageData = part.inlineData.data;
          const buffer = Buffer.from(imageData, "base64");
          fs.writeFileSync("city_style_transfer.png", buffer);
          console.log("Image saved as city_style_transfer.png");
        }
      }
    }

    main();

### Go

    package main

    import (
      "context"
      "fmt"
      "log"
      "os"
      "google.golang.org/genai"
    )

    func main() {

      ctx := context.Background()
      client, err := genai.NewClient(ctx, nil)
      if err != nil {
          log.Fatal(err)
      }

      imagePath := "/path/to/your/city.png"
      imgData, _ := os.ReadFile(imagePath)

      parts := []*genai.Part{
        &genai.Part{
          InlineData: &genai.Blob{
            MIMEType: "image/png",
            Data:     imgData,
          },
        },
        genai.NewPartFromText("Transform the provided photograph of a modern city street at night into the artistic style of Vincent van Gogh's 'Starry Night'. Preserve the original composition of buildings and cars, but render all elements with swirling, impasto brushstrokes and a dramatic palette of deep blues and bright yellows."),
      }

      contents := []*genai.Content{
        genai.NewContentFromParts(parts, genai.RoleUser),
      }

      result, _ := client.Models.GenerateContent(
          ctx,
          "gemini-2.5-flash-image",
          contents,
      )

      for _, part := range result.Candidates[0].Content.Parts {
          if part.Text != "" {
              fmt.Println(part.Text)
          } else if part.InlineData != nil {
              imageBytes := part.InlineData.Data
              outputFilename := "city_style_transfer.png"
              _ = os.WriteFile(outputFilename, imageBytes, 0644)
          }
      }
    }

### REST

    IMG_PATH=/path/to/your/city.png

    if [[ "$(base64 --version 2>&1)" = *"FreeBSD"* ]]; then
      B64FLAGS="--input"
    else
      B64FLAGS="-w0"
    fi

    IMG_BASE64=$(base64 "$B64FLAGS" "$IMG_PATH" 2>&1)

    curl -X POST \
      "https://generativelanguage.googleapis.com/v1beta/models/gemini-2.5-flash-image:generateContent" \
        -H "x-goog-api-key: $GEMINI_API_KEY" \
        -H 'Content-Type: application/json' \
        -d "{
          \"contents\": [{
            \"parts\":[
                {
                  \"inline_data\": {
                    \"mime_type\":\"image/png\",
                    \"data\": \"$IMG_BASE64\"
                  }
                },
                {\"text\": \"Transform the provided photograph of a modern city street at night into the artistic style of Vincent van Gogh's 'Starry Night'. Preserve the original composition of buildings and cars, but render all elements with swirling, impasto brushstrokes and a dramatic palette of deep blues and bright yellows.\"}
            ]
          }]
        }"  \
      | grep -o '"data": "[^"]*"' \
      | cut -d'"' -f4 \
      | base64 --decode > city_style_transfer.png

|-------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------|----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------|
| Input | Output |
| ![A photorealistic, high-resolution photograph of a busy city street...](https://ai.google.dev/static/gemini-api/docs/images/city.png)A photorealistic, high-resolution photograph of a busy city street... | ![Transform the provided photograph of a modern city street at night...](https://ai.google.dev/static/gemini-api/docs/images/city_style_transfer.png)Transform the provided photograph of a modern city street at night... |

#### 4. Advanced composition: Combining multiple images

Provide multiple images as context to create a new, composite scene. This is perfect for product mockups or creative collages.

### Template

    Create a new image by combining the elements from the provided images. Take
    the [element from image 1] and place it with/on the [element from image 2].
    The final image should be a [description of the final scene].

### Prompt

    "Create a professional e-commerce fashion photo. Take the blue floral dress
    from the first image and let the woman from the second image wear it.
    Generate a realistic, full-body shot of the woman wearing the dress, with
    the lighting and shadows adjusted to match the outdoor environment."

### Python

    from google import genai
    from google.genai import types
    from PIL import Image

    client = genai.Client()

    # Base image prompts:
    # 1. Dress: "A professionally shot photo of a blue floral summer dress on a plain white background, ghost mannequin style."
    # 2. Model: "Full-body shot of a woman with her hair in a bun, smiling, standing against a neutral grey studio background."
    dress_image = Image.open('/path/to/your/dress.png')
    model_image = Image.open('/path/to/your/model.png')

    text_input = """Create a professional e-commerce fashion photo. Take the blue floral dress from the first image and let the woman from the second image wear it. Generate a realistic, full-body shot of the woman wearing the dress, with the lighting and shadows adjusted to match the outdoor environment."""

    # Generate an image from a text prompt
    response = client.models.generate_content(
        model="gemini-2.5-flash-image",
        contents=[dress_image, model_image, text_input],
    )

    for part in response.parts:
        if part.text is not None:
            print(part.text)
        elif part.inline_data is not None:
            image = part.as_image()
            image.save("fashion_ecommerce_shot.png")

### Java

    import com.google.genai.Client;
    import com.google.genai.types.Content;
    import com.google.genai.types.GenerateContentConfig;
    import com.google.genai.types.GenerateContentResponse;
    import com.google.genai.types.Part;

    import java.io.IOException;
    import java.nio.file.Files;
    import java.nio.file.Path;
    import java.nio.file.Paths;

    public class AdvancedComposition {
      public static void main(String[] args) throws IOException {

        try (Client client = new Client()) {
          GenerateContentConfig config = GenerateContentConfig.builder()
              .responseModalities("TEXT", "IMAGE")
              .build();

          GenerateContentResponse response = client.models.generateContent(
              "gemini-2.5-flash-image",
              Content.fromParts(
                  Part.fromBytes(
                      Files.readAllBytes(
                          Path.of("/path/to/your/dress.png")),
                      "image/png"),
                  Part.fromBytes(
                      Files.readAllBytes(
                          Path.of("/path/to/your/model.png")),
                      "image/png"),
                  Part.fromText("""
                      Create a professional e-commerce fashion photo.
                      Take the blue floral dress from the first image and
                      let the woman from the second image wear it. Generate
                      a realistic, full-body shot of the woman wearing the
                      dress, with the lighting and shadows adjusted to
                      match the outdoor environment.
                      """)),
              config);

          for (Part part : response.parts()) {
            if (part.text().isPresent()) {
              System.out.println(part.text().get());
            } else if (part.inlineData().isPresent()) {
              var blob = part.inlineData().get();
              if (blob.data().isPresent()) {
                Files.write(Paths.get("fashion_ecommerce_shot.png"), blob.data().get());
              }
            }
          }
        }
      }
    }

### JavaScript

    import { GoogleGenAI } from "@google/genai";
    import * as fs from "node:fs";

    async function main() {

      const ai = new GoogleGenAI({});

      const imagePath1 = "/path/to/your/dress.png";
      const imageData1 = fs.readFileSync(imagePath1);
      const base64Image1 = imageData1.toString("base64");
      const imagePath2 = "/path/to/your/model.png";
      const imageData2 = fs.readFileSync(imagePath2);
      const base64Image2 = imageData2.toString("base64");

      const prompt = [
        {
          inlineData: {
            mimeType: "image/png",
            data: base64Image1,
          },
        },
        {
          inlineData: {
            mimeType: "image/png",
            data: base64Image2,
          },
        },
        { text: "Create a professional e-commerce fashion photo. Take the blue floral dress from the first image and let the woman from the second image wear it. Generate a realistic, full-body shot of the woman wearing the dress, with the lighting and shadows adjusted to match the outdoor environment." },
      ];

      const response = await ai.models.generateContent({
        model: "gemini-2.5-flash-image",
        contents: prompt,
      });
      for (const part of response.candidates[0].content.parts) {
        if (part.text) {
          console.log(part.text);
        } else if (part.inlineData) {
          const imageData = part.inlineData.data;
          const buffer = Buffer.from(imageData, "base64");
          fs.writeFileSync("fashion_ecommerce_shot.png", buffer);
          console.log("Image saved as fashion_ecommerce_shot.png");
        }
      }
    }

    main();

### Go

    package main

    import (
      "context"
      "fmt"
      "log"
      "os"
      "google.golang.org/genai"
    )

    func main() {

      ctx := context.Background()
      client, err := genai.NewClient(ctx, nil)
      if err != nil {
          log.Fatal(err)
      }

      imgData1, _ := os.ReadFile("/path/to/your/dress.png")
      imgData2, _ := os.ReadFile("/path/to/your/model.png")

      parts := []*genai.Part{
        &genai.Part{
          InlineData: &genai.Blob{
            MIMEType: "image/png",
            Data:     imgData1,
          },
        },
        &genai.Part{
          InlineData: &genai.Blob{
            MIMEType: "image/png",
            Data:     imgData2,
          },
        },
        genai.NewPartFromText("Create a professional e-commerce fashion photo. Take the blue floral dress from the first image and let the woman from the second image wear it. Generate a realistic, full-body shot of the woman wearing the dress, with the lighting and shadows adjusted to match the outdoor environment."),
      }

      contents := []*genai.Content{
        genai.NewContentFromParts(parts, genai.RoleUser),
      }

      result, _ := client.Models.GenerateContent(
          ctx,
          "gemini-2.5-flash-image",
          contents,
      )

      for _, part := range result.Candidates[0].Content.Parts {
          if part.Text != "" {
              fmt.Println(part.Text)
          } else if part.InlineData != nil {
              imageBytes := part.InlineData.Data
              outputFilename := "fashion_ecommerce_shot.png"
              _ = os.WriteFile(outputFilename, imageBytes, 0644)
          }
      }
    }

### REST

    IMG_PATH1=/path/to/your/dress.png
    IMG_PATH2=/path/to/your/model.png

    if [[ "$(base64 --version 2>&1)" = *"FreeBSD"* ]]; then
      B64FLAGS="--input"
    else
      B64FLAGS="-w0"
    fi

    IMG1_BASE64=$(base64 "$B64FLAGS" "$IMG_PATH1" 2>&1)
    IMG2_BASE64=$(base64 "$B64FLAGS" "$IMG_PATH2" 2>&1)

    curl -X POST \
      "https://generativelanguage.googleapis.com/v1beta/models/gemini-2.5-flash-image:generateContent" \
        -H "x-goog-api-key: $GEMINI_API_KEY" \
        -H 'Content-Type: application/json' \
        -d "{
          \"contents\": [{
            \"parts\":[
                {
                  \"inline_data\": {
                    \"mime_type\":\"image/png\",
                    \"data\": \"$IMG1_BASE64\"
                  }
                },
                {
                  \"inline_data\": {
                    \"mime_type\":\"image/png\",
                    \"data\": \"$IMG2_BASE64\"
                  }
                },
                {\"text\": \"Create a professional e-commerce fashion photo. Take the blue floral dress from the first image and let the woman from the second image wear it. Generate a realistic, full-body shot of the woman wearing the dress, with the lighting and shadows adjusted to match the outdoor environment.\"}
            ]
          }]
        }"  \
      | grep -o '"data": "[^"]*"' \
      | cut -d'"' -f4 \
      | base64 --decode > fashion_ecommerce_shot.png

|---------------------------------------------------------------------|--------------------------------------------------------------------------------------------------------------------------------------------------------------------------|---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------|
| Input 1 | Input 2 | Output |
| :dress:A professionally shot photo of a blue floral summer dress... | ![Full-body shot of a woman with her hair in a bun...](https://ai.google.dev/static/gemini-api/docs/images/model.png)Full-body shot of a woman with her hair in a bun... | ![Create a professional e-commerce fashion photo...](https://ai.google.dev/static/gemini-api/docs/images/fashion_ecommerce_shot.png)Create a professional e-commerce fashion photo... |

#### 5. High-fidelity detail preservation

To ensure critical details (like a face or logo) are preserved during an edit, describe them in great detail along with your edit request.

### Template

    Using the provided images, place [element from image 2] onto [element from
    image 1]. Ensure that the features of [element from image 1] remain
    completely unchanged. The added element should [description of how the
    element should integrate].

### Prompt

    "Take the first image of the woman with brown hair, blue eyes, and a neutral
    expression. Add the logo from the second image onto her black t-shirt.
    Ensure the woman's face and features remain completely unchanged. The logo
    should look like it's naturally printed on the fabric, following the folds
    of the shirt."

### Python

    from google import genai
    from google.genai import types
    from PIL import Image

    client = genai.Client()

    # Base image prompts:
    # 1. Woman: "A professional headshot of a woman with brown hair and blue eyes, wearing a plain black t-shirt, against a neutral studio background."
    # 2. Logo: "A simple, modern logo with the letters 'G' and 'A' in a white circle."
    woman_image = Image.open('/path/to/your/woman.png')
    logo_image = Image.open('/path/to/your/logo.png')
    text_input = """Take the first image of the woman with brown hair, blue eyes, and a neutral expression. Add the logo from the second image onto her black t-shirt. Ensure the woman's face and features remain completely unchanged. The logo should look like it's naturally printed on the fabric, following the folds of the shirt."""

    # Generate an image from a text prompt
    response = client.models.generate_content(
        model="gemini-2.5-flash-image",
        contents=[woman_image, logo_image, text_input],
    )

    for part in response.parts:
        if part.text is not None:
            print(part.text)
        elif part.inline_data is not None:
            image = part.as_image()
            image.save("woman_with_logo.png")

### Java

    import com.google.genai.Client;
    import com.google.genai.types.Content;
    import com.google.genai.types.GenerateContentConfig;
    import com.google.genai.types.GenerateContentResponse;
    import com.google.genai.types.Part;

    import java.io.IOException;
    import java.nio.file.Files;
    import java.nio.file.Path;
    import java.nio.file.Paths;

    public class HighFidelity {
      public static void main(String[] args) throws IOException {

        try (Client client = new Client()) {
          GenerateContentConfig config = GenerateContentConfig.builder()
              .responseModalities("TEXT", "IMAGE")
              .build();

          GenerateContentResponse response = client.models.generateContent(
              "gemini-2.5-flash-image",
              Content.fromParts(
                  Part.fromBytes(
                      Files.readAllBytes(
                          Path.of("/path/to/your/woman.png")),
                      "image/png"),
                  Part.fromBytes(
                      Files.readAllBytes(
                          Path.of("/path/to/your/logo.png")),
                      "image/png"),
                  Part.fromText("""
                      Take the first image of the woman with brown hair,
                      blue eyes, and a neutral expression. Add the logo
                      from the second image onto her black t-shirt.
                      Ensure the woman's face and features remain
                      completely unchanged. The logo should look like
                      it's naturally printed on the fabric, following
                      the folds of the shirt.
                      """)),
              config);

          for (Part part : response.parts()) {
            if (part.text().isPresent()) {
              System.out.println(part.text().get());
            } else if (part.inlineData().isPresent()) {
              var blob = part.inlineData().get();
              if (blob.data().isPresent()) {
                Files.write(Paths.get("woman_with_logo.png"), blob.data().get());
              }
            }
          }
        }
      }
    }

### JavaScript

    import { GoogleGenAI } from "@google/genai";
    import * as fs from "node:fs";

    async function main() {

      const ai = new GoogleGenAI({});

      const imagePath1 = "/path/to/your/woman.png";
      const imageData1 = fs.readFileSync(imagePath1);
      const base64Image1 = imageData1.toString("base64");
      const imagePath2 = "/path/to/your/logo.png";
      const imageData2 = fs.readFileSync(imagePath2);
      const base64Image2 = imageData2.toString("base64");

      const prompt = [
        {
          inlineData: {
            mimeType: "image/png",
            data: base64Image1,
          },
        },
        {
          inlineData: {
            mimeType: "image/png",
            data: base64Image2,
          },
        },
        { text: "Take the first image of the woman with brown hair, blue eyes, and a neutral expression. Add the logo from the second image onto her black t-shirt. Ensure the woman's face and features remain completely unchanged. The logo should look like it's naturally printed on the fabric, following the folds of the shirt." },
      ];

      const response = await ai.models.generateContent({
        model: "gemini-2.5-flash-image",
        contents: prompt,
      });
      for (const part of response.candidates[0].content.parts) {
        if (part.text) {
          console.log(part.text);
        } else if (part.inlineData) {
          const imageData = part.inlineData.data;
          const buffer = Buffer.from(imageData, "base64");
          fs.writeFileSync("woman_with_logo.png", buffer);
          console.log("Image saved as woman_with_logo.png");
        }
      }
    }

    main();

### Go

    package main

    import (
      "context"
      "fmt"
      "log"
      "os"
      "google.golang.org/genai"
    )

    func main() {

      ctx := context.Background()
      client, err := genai.NewClient(ctx, nil)
      if err != nil {
          log.Fatal(err)
      }

      imgData1, _ := os.ReadFile("/path/to/your/woman.png")
      imgData2, _ := os.ReadFile("/path/to/your/logo.png")

      parts := []*genai.Part{
        &genai.Part{
          InlineData: &genai.Blob{
            MIMEType: "image/png",
            Data:     imgData1,
          },
        },
        &genai.Part{
          InlineData: &genai.Blob{
            MIMEType: "image/png",
            Data:     imgData2,
          },
        },
        genai.NewPartFromText("Take the first image of the woman with brown hair, blue eyes, and a neutral expression. Add the logo from the second image onto her black t-shirt. Ensure the woman's face and features remain completely unchanged. The logo should look like it's naturally printed on the fabric, following the folds of the shirt."),
      }

      contents := []*genai.Content{
        genai.NewContentFromParts(parts, genai.RoleUser),
      }

      result, _ := client.Models.GenerateContent(
          ctx,
          "gemini-2.5-flash-image",
          contents,
      )

      for _, part := range result.Candidates[0].Content.Parts {
          if part.Text != "" {
              fmt.Println(part.Text)
          } else if part.InlineData != nil {
              imageBytes := part.InlineData.Data
              outputFilename := "woman_with_logo.png"
              _ = os.WriteFile(outputFilename, imageBytes, 0644)
          }
      }
    }

### REST

    IMG_PATH1=/path/to/your/woman.png
    IMG_PATH2=/path/to/your/logo.png

    if [[ "$(base64 --version 2>&1)" = *"FreeBSD"* ]]; then
      B64FLAGS="--input"
    else
      B64FLAGS="-w0"
    fi

    IMG1_BASE64=$(base64 "$B64FLAGS" "$IMG_PATH1" 2>&1)
    IMG2_BASE64=$(base64 "$B64FLAGS" "$IMG_PATH2" 2>&1)

    curl -X POST \
      "https://generativelanguage.googleapis.com/v1beta/models/gemini-2.5-flash-image:generateContent" \
        -H "x-goog-api-key: $GEMINI_API_KEY" \
        -H 'Content-Type: application/json' \
        -d "{
          \"contents\": [{
            \"parts\":[
                {
                  \"inline_data\": {
                    \"mime_type\":\"image/png\",
                    \"data\": \"$IMG1_BASE64\"
                  }
                },
                {
                  \"inline_data\": {
                    \"mime_type\":\"image/png\",
                    \"data\": \"$IMG2_BASE64\"
                  }
                },
                {\"text\": \"Take the first image of the woman with brown hair, blue eyes, and a neutral expression. Add the logo from the second image onto her black t-shirt. Ensure the woman's face and features remain completely unchanged. The logo should look like it's naturally printed on the fabric, following the folds of the shirt.\"}
            ]
          }]
        }"  \
      | grep -o '"data": "[^"]*"' \
      | cut -d'"' -f4 \
      | base64 --decode > woman_with_logo.png

|----------------------------------------------------------------------------|-----------------------------------------------------------------------------------------------------------------------------------------------------------------------------|----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------|
| Input 1 | Input 2 | Output |
| :woman:A professional headshot of a woman with brown hair and blue eyes... | ![A simple, modern logo with the letters 'G' and 'A'...](https://ai.google.dev/static/gemini-api/docs/images/logo.png)A simple, modern logo with the letters 'G' and 'A'... | ![Take the first image of the woman with brown hair, blue eyes, and a neutral expression...](https://ai.google.dev/static/gemini-api/docs/images/woman_with_logo.png)Take the first image of the woman with brown hair, blue eyes, and a neutral expression... |

#### 6. Bring something to life

Upload a rough sketch or drawing and ask the model to refine it into a finished image.

### Template

    Turn this rough [medium] sketch of a [subject] into a [style description]
    photo. Keep the [specific features] from the sketch but add [new details/materials].

### Prompt

    "Turn this rough pencil sketch of a futuristic car into a polished photo of the finished concept car in a showroom. Keep the sleek lines and low profile from the sketch but add metallic blue paint and neon rim lighting."

### Python

    from google import genai
    from PIL import Image

    client = genai.Client()

    # Base image prompt: "A rough pencil sketch of a flat sports car on white paper."
    sketch_image = Image.open('/path/to/your/car_sketch.png')
    text_input = """Turn this rough pencil sketch of a futuristic car into a polished photo of the finished concept car in a showroom. Keep the sleek lines and low profile from the sketch but add metallic blue paint and neon rim lighting."""

    response = client.models.generate_content(
        model="gemini-3-pro-image-preview",
        contents=[sketch_image, text_input],
    )

    for part in response.parts:
        if part.text is not None:
            print(part.text)
        elif part.inline_data is not None:
            image = part.as_image()
            image.save("car_photo.png")

### Java

    import com.google.genai.Client;
    import com.google.genai.types.Content;
    import com.google.genai.types.GenerateContentConfig;
    import com.google.genai.types.GenerateContentResponse;
    import com.google.genai.types.Part;

    import java.io.IOException;
    import java.nio.file.Files;
    import java.nio.file.Path;
    import java.nio.file.Paths;

    public class BringToLife {
      public static void main(String[] args) throws IOException {
        try (Client client = new Client()) {
          GenerateContentConfig config = GenerateContentConfig.builder()
              .responseModalities("TEXT", "IMAGE")
              .build();

          GenerateContentResponse response = client.models.generateContent(
              "gemini-3-pro-image-preview",
              Content.fromParts(
                  Part.fromBytes(
                      Files.readAllBytes(
                          Path.of("/path/to/your/car_sketch.png")),
                      "image/png"),
                  Part.fromText("""
                      Turn this rough pencil sketch of a futuristic car into a polished photo of the finished concept car in a showroom. Keep the sleek lines and low profile from the sketch but add metallic blue paint and neon rim lighting.
                      """)),
              config);

          for (Part part : response.parts()) {
            if (part.text().isPresent()) {
              System.out.println(part.text().get());
            } else if (part.inlineData().isPresent()) {
              var blob = part.inlineData().get();
              if (blob.data().isPresent()) {
                Files.write(Paths.get("car_photo.png"), blob.data().get());
              }
            }
          }
        }
      }
    }

### JavaScript

    import { GoogleGenAI } from "@google/genai";
    import * as fs from "node:fs";

    async function main() {

      const ai = new GoogleGenAI({});

      const imagePath = "/path/to/your/car_sketch.png";
      const imageData = fs.readFileSync(imagePath);
      const base64Image = imageData.toString("base64");

      const prompt = [
        {
          inlineData: {
            mimeType: "image/png",
            data: base64Image,
          },
        },
        { text: "Turn this rough pencil sketch of a futuristic car into a polished photo of the finished concept car in a showroom. Keep the sleek lines and low profile from the sketch but add metallic blue paint and neon rim lighting." },
      ];

      const response = await ai.models.generateContent({
        model: "gemini-3-pro-image-preview",
        contents: prompt,
      });
      for (const part of response.candidates[0].content.parts) {
        if (part.text) {
          console.log(part.text);
        } else if (part.inlineData) {
          const imageData = part.inlineData.data;
          const buffer = Buffer.from(imageData, "base64");
          fs.writeFileSync("car_photo.png", buffer);
          console.log("Image saved as car_photo.png");
        }
      }
    }

    main();

### Go

    package main

    import (
      "context"
      "fmt"
      "log"
      "os"
      "google.golang.org/genai"
    )

    func main() {

      ctx := context.Background()
      client, err := genai.NewClient(ctx, nil)
      if err != nil {
          log.Fatal(err)
      }

      imgData, _ := os.ReadFile("/path/to/your/car_sketch.png")

      parts := []*genai.Part{
        &genai.Part{
          InlineData: &genai.Blob{
            MIMEType: "image/png",
            Data:     imgData,
          },
        },
        genai.NewPartFromText("Turn this rough pencil sketch of a futuristic car into a polished photo of the finished concept car in a showroom. Keep the sleek lines and low profile from the sketch but add metallic blue paint and neon rim lighting."),
      }

      contents := []*genai.Content{
        genai.NewContentFromParts(parts, genai.RoleUser),
      }

      result, _ := client.Models.GenerateContent(
          ctx,
          "gemini-3-pro-image-preview",
          contents,
      )

      for _, part := range result.Candidates[0].Content.Parts {
          if part.Text != "" {
              fmt.Println(part.Text)
          } else if part.InlineData != nil {
              imageBytes := part.InlineData.Data
              outputFilename := "car_photo.png"
              _ = os.WriteFile(outputFilename, imageBytes, 0644)
          }
      }
    }

### REST

    IMG_PATH=/path/to/your/car_sketch.png

    if [[ "$(base64 --version 2>&1)" = *"FreeBSD"* ]]; then
      B64FLAGS="--input"
    else
      B64FLAGS="-w0"
    fi

    IMG_BASE64=$(base64 "$B64FLAGS" "$IMG_PATH" 2>&1)

    curl -X POST \
      "https://generativelanguage.googleapis.com/v1beta/models/gemini-3-pro-image-preview:generateContent" \
        -H "x-goog-api-key: $GEMINI_API_KEY" \
        -H 'Content-Type: application/json' \
        -d "{
          \"contents\": [{
            \"parts\":[
                {
                  \"inline_data\": {
                    \"mime_type\":\"image/png\",
                    \"data\": \"$IMG_BASE64\"
                  }
                },
                {\"text\": \"Turn this rough pencil sketch of a futuristic car into a polished photo of the finished concept car in a showroom. Keep the sleek lines and low profile from the sketch but add metallic blue paint and neon rim lighting.\"}
            ]
          }]
        }"  \
      | grep -o '"data": "[^"]*"' \
      | cut -d'"' -f4 \
      | base64 --decode > car_photo.png

|-------------------------------------------------------------------------------------------------------------|-----------------------------------------------------------------------------------------------------------------------------------|
| Input | Output |
| ![Sketch of a car](https://ai.google.dev/static/gemini-api/docs/images/car-sketch.jpg)Rough sketch of a car | ![Output showing the final concept car](https://ai.google.dev/static/gemini-api/docs/images/car-photo.jpg)Polished photo of a car |

#### 7. Character consistency: 360 view

You can generate 360-degree views of a character by iteratively prompting for different angles. For best results, include previously generated images in subsequent prompts to maintain consistency. For complex poses, include a reference image of the desired pose.

### Template

    A studio portrait of [person] against [background], [looking forward/in profile looking right/etc.]

### Prompt

    A studio portrait of this man against white, in profile looking right

### Python

    from google import genai
    from google.genai import types
    from PIL import Image

    client = genai.Client()

    image_input = Image.open('/path/to/your/man_in_white_glasses.jpg')
    text_input = """A studio portrait of this man against white, in profile looking right"""

    response = client.models.generate_content(
        model="gemini-3-pro-image-preview",
        contents=[text_input, image_input],
    )

    for part in response.parts:
        if part.text is not None:
            print(part.text)
        elif part.inline_data is not None:
            image = part.as_image()
            image.save("man_right_profile.png")

### Java

    import com.google.genai.Client;
    import com.google.genai.types.Content;
    import com.google.genai.types.GenerateContentConfig;
    import com.google.genai.types.GenerateContentResponse;
    import com.google.genai.types.Part;

    import java.io.IOException;
    import java.nio.file.Files;
    import java.nio.file.Path;
    import java.nio.file.Paths;

    public class CharacterConsistency {
      public static void main(String[] args) throws IOException {
        try (Client client = new Client()) {
          GenerateContentConfig config = GenerateContentConfig.builder()
              .responseModalities("TEXT", "IMAGE")
              .build();

          GenerateContentResponse response = client.models.generateContent(
              "gemini-3-pro-image-preview",
              Content.fromParts(
                  Part.fromText("""
                      A studio portrait of this man against white, in profile looking right
                      """),
                  Part.fromBytes(
                      Files.readAllBytes(
                          Path.of("/path/to/your/man_in_white_glasses.jpg")),
                      "image/jpeg")),
              config);

          for (Part part : response.parts()) {
            if (part.text().isPresent()) {
              System.out.println(part.text().get());
            } else if (part.inlineData().isPresent()) {
              var blob = part.inlineData().get();
              if (blob.data().isPresent()) {
                Files.write(Paths.get("man_right_profile.png"), blob.data().get());
              }
            }
          }
        }
      }
    }

### JavaScript

    import { GoogleGenAI } from "@google/genai";
    import * as fs from "node:fs";

    async function main() {

      const ai = new GoogleGenAI({});

      const imagePath = "/path/to/your/man_in_white_glasses.jpg";
      const imageData = fs.readFileSync(imagePath);
      const base64Image = imageData.toString("base64");

      const prompt = [
        { text: "A studio portrait of this man against white, in profile looking right" },
        {
          inlineData: {
            mimeType: "image/jpeg",
            data: base64Image,
          },
        },
      ];

      const response = await ai.models.generateContent({
        model: "gemini-3-pro-image-preview",
        contents: prompt,
      });
      for (const part of response.candidates[0].content.parts) {
        if (part.text) {
          console.log(part.text);
        } else if (part.inlineData) {
          const imageData = part.inlineData.data;
          const buffer = Buffer.from(imageData, "base64");
          fs.writeFileSync("man_right_profile.png", buffer);
          console.log("Image saved as man_right_profile.png");
        }
      }
    }

    main();

### Go

    package main

    import (
      "context"
      "fmt"
      "log"
      "os"
      "google.golang.org/genai"
    )

    func main() {

      ctx := context.Background()
      client, err := genai.NewClient(ctx, nil)
      if err != nil {
          log.Fatal(err)
      }

      imagePath := "/path/to/your/man_in_white_glasses.jpg"
      imgData, _ := os.ReadFile(imagePath)

      parts := []*genai.Part{
        genai.NewPartFromText("A studio portrait of this man against white, in profile looking right"),
        &genai.Part{
          InlineData: &genai.Blob{
            MIMEType: "image/jpeg",
            Data:     imgData,
          },
        },
      }

      contents := []*genai.Content{
        genai.NewContentFromParts(parts, genai.RoleUser),
      }

      result, _ := client.Models.GenerateContent(
          ctx,
          "gemini-3-pro-image-preview",
          contents,
      )

      for _, part := range result.Candidates[0].Content.Parts {
          if part.Text != "" {
              fmt.Println(part.Text)
          } else if part.InlineData != nil {
              imageBytes := part.InlineData.Data
              outputFilename := "man_right_profile.png"
              _ = os.WriteFile(outputFilename, imageBytes, 0644)
          }
      }
    }

### REST

    IMG_PATH=/path/to/your/man_in_white_glasses.jpg

    if [[ "$(base64 --version 2>&1)" = *"FreeBSD"* ]]; then
      B64FLAGS="--input"
    else
      B64FLAGS="-w0"
    fi

    IMG_BASE64=$(base64 "$B64FLAGS" "$IMG_PATH" 2>&1)

    curl -X POST \
      "https://generativelanguage.googleapis.com/v1beta/models/gemini-3-pro-image-preview:generateContent" \
        -H "x-goog-api-key: $GEMINI_API_KEY" \
        -H 'Content-Type: application/json' \
        -d "{
          \"contents\": [{
            \"parts\":[
                {\"text\": \"A studio portrait of this man against white, in profile looking right\"},
                {
                  \"inline_data\": {
                    \"mime_type\":\"image/jpeg\",
                    \"data\": \"$IMG_BASE64\"
                  }
                }
            ]
          }]
        }"  \
      | grep -o '"data": "[^"]*"' \
      | cut -d'"' -f4 \
      | base64 --decode > man_right_profile.png

|-----------------------------------------------------------------------------------------------------------------------------------------|---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------|---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------|
| Input | Output 1 | Output 2 |
| ![Original input of a man in white glasses](https://ai.google.dev/static/gemini-api/docs/images/man_in_white_glasses.jpg)Original image | ![Output of a man in white glasses looking right](https://ai.google.dev/static/gemini-api/docs/images/man_in_white_glasses_looking_right.jpg)Man in white glasses looking right | ![Output of a man in white glasses looking forward](https://ai.google.dev/static/gemini-api/docs/images/man_in_white_glasses_looking_forward.jpg)Man in white glasses looking forward |

### Best Practices

To elevate your results from good to great, incorporate these professional strategies into your workflow.

- **Be Hyper-Specific:**The more detail you provide, the more control you have. Instead of "fantasy armor," describe it: "ornate elven plate armor, etched with silver leaf patterns, with a high collar and pauldrons shaped like falcon wings."
- **Provide Context and Intent:** Explain the*purpose*of the image. The model's understanding of context will influence the final output. For example, "Create a logo for a high-end, minimalist skincare brand" will yield better results than just "Create a logo."
- **Iterate and Refine:**Don't expect a perfect image on the first try. Use the conversational nature of the model to make small changes. Follow up with prompts like, "That's great, but can you make the lighting a bit warmer?" or "Keep everything the same, but change the character's expression to be more serious."
- **Use Step-by-Step Instructions:**For complex scenes with many elements, break your prompt into steps. "First, create a background of a serene, misty forest at dawn. Then, in the foreground, add a moss-covered ancient stone altar. Finally, place a single, glowing sword on top of the altar."
- **Use "Semantic Negative Prompts":**Instead of saying "no cars," describe the desired scene positively: "an empty, deserted street with no signs of traffic."
- **Control the Camera:** Use photographic and cinematic language to control the composition. Terms like`wide-angle shot`,`macro shot`,`low-angle
perspective`.

## Limitations

- For best performance, use the following languages: EN, ar-EG, de-DE, es-MX, fr-FR, hi-IN, id-ID, it-IT, ja-JP, ko-KR, pt-BR, ru-RU, ua-UA, vi-VN, zh-CN.
- Image generation does not support audio or video inputs.
- The model won't always follow the exact number of image outputs that the user explicitly asks for.
- `gemini-2.5-flash-image`works best with up to 3 images as input, while`gemini-3-pro-image-preview`supports 5 images with high fidelity, and up to 14 images in total.
- When generating text for an image, Gemini works best if you first generate the text and then ask for an image with the text.
- All generated images include a[SynthID watermark](https://ai.google.dev/responsible/docs/safeguards/synthid).

## Optional configurations

You can optionally configure the response modalities and aspect ratio of the model's output in the`config`field of`generate_content`calls.

### Output types

The model defaults to returning text and image responses (i.e.`response_modalities=['Text', 'Image']`). You can configure the response to return only images without text using`response_modalities=['Image']`.

### Python

    response = client.models.generate_content(
        model="gemini-2.5-flash-image",
        contents=[prompt],
        config=types.GenerateContentConfig(
            response_modalities=['Image']
        )
    )

### JavaScript

    const response = await ai.models.generateContent({
        model: "gemini-2.5-flash-image",
        contents: prompt,
        config: {
            responseModalities: ['Image']
        }
      });

### Go

    result, _ := client.Models.GenerateContent(
        ctx,
        "gemini-2.5-flash-image",
        genai.Text("Create a picture of a nano banana dish in a " +
                    " fancy restaurant with a Gemini theme"),
        &genai.GenerateContentConfig{
            ResponseModalities: "Image",
        },
      )

### Java

    response = client.models.generateContent(
        "gemini-2.5-flash-image",
        prompt,
        GenerateContentConfig.builder()
            .responseModalities("IMAGE")
            .build());

### REST

    -d '{
      "contents": [{
        "parts": [
          {"text": "Create a picture of a nano banana dish in a fancy restaurant with a Gemini theme"}
        ]
      }],
      "generationConfig": {
        "responseModalities": ["Image"]
      }
    }' \

### Aspect ratios and image size

The model defaults to matching the output image size to that of your input image, or otherwise generates 1:1 squares. You can control the aspect ratio of the output image using the`aspect_ratio`field under`image_config`in the response request, shown here:

### Python

    # For gemini-2.5-flash-image
    response = client.models.generate_content(
        model="gemini-2.5-flash-image",
        contents=[prompt],
        config=types.GenerateContentConfig(
            image_config=types.ImageConfig(
                aspect_ratio="16:9",
            )
        )
    )

    # For gemini-3-pro-image-preview
    response = client.models.generate_content(
        model="gemini-3-pro-image-preview",
        contents=[prompt],
        config=types.GenerateContentConfig(
            image_config=types.ImageConfig(
                aspect_ratio="16:9",
                image_size="2K",
            )
        )
    )

### JavaScript

    // For gemini-2.5-flash-image
    const response = await ai.models.generateContent({
        model: "gemini-2.5-flash-image",
        contents: prompt,
        config: {
          imageConfig: {
            aspectRatio: "16:9",
          },
        }
      });

    // For gemini-3-pro-image-preview
    const response_gemini3 = await ai.models.generateContent({
        model: "gemini-3-pro-image-preview",
        contents: prompt,
        config: {
          imageConfig: {
            aspectRatio: "16:9",
            imageSize: "2K",
          },
        }
      });

### Go

    // For gemini-2.5-flash-image
    result, _ := client.Models.GenerateContent(
        ctx,
        "gemini-2.5-flash-image",
        genai.Text("Create a picture of a nano banana dish in a " +
                    " fancy restaurant with a Gemini theme"),
        &genai.GenerateContentConfig{
            ImageConfig: &genai.ImageConfig{
              AspectRatio: "16:9",
            },
        }
      )

    // For gemini-3-pro-image-preview
    result_gemini3, _ := client.Models.GenerateContent(
        ctx,
        "gemini-3-pro-image-preview",
        genai.Text("Create a picture of a nano banana dish in a " +
                    " fancy restaurant with a Gemini theme"),
        &genai.GenerateContentConfig{
            ImageConfig: &genai.ImageConfig{
              AspectRatio: "16:9",
              ImageSize: "2K",
            },
        }
      )

### Java

    // For gemini-2.5-flash-image
    response = client.models.generateContent(
        "gemini-2.5-flash-image",
        prompt,
        GenerateContentConfig.builder()
            .imageConfig(ImageConfig.builder()
                .aspectRatio("16:9")
                .build())
            .build());

    // For gemini-3-pro-image-preview
    response_gemini3 = client.models.generateContent(
        "gemini-3-pro-image-preview",
        prompt,
        GenerateContentConfig.builder()
            .imageConfig(ImageConfig.builder()
                .aspectRatio("16:9")
                .imageSize("2K")
                .build())
            .build());

### REST

    # For gemini-2.5-flash-image
    -d '{
      "contents": [{
        "parts": [
          {"text": "Create a picture of a nano banana dish in a fancy restaurant with a Gemini theme"}
        ]
      }],
      "generationConfig": {
        "imageConfig": {
          "aspectRatio": "16:9"
        }
      }
    }' \

    # For gemini-3-pro-image-preview
    -d '{
      "contents": [{
        "parts": [
          {"text": "Create a picture of a nano banana dish in a fancy restaurant with a Gemini theme"}
        ]
      }],
      "generationConfig": {
        "imageConfig": {
          "aspectRatio": "16:9",
          "imageSize": "2K"
        }
      }
    }' \

The different ratios available and the size of the image generated are listed in the following tables:

**Gemini 2.5 Flash Image**

| Aspect ratio | Resolution | Tokens |
| ------------ | ---------- | ------ |
| 1:1          | 1024x1024  | 1290   |
| 2:3          | 832x1248   | 1290   |
| 3:2          | 1248x832   | 1290   |
| 3:4          | 864x1184   | 1290   |
| 4:3          | 1184x864   | 1290   |
| 4:5          | 896x1152   | 1290   |
| 5:4          | 1152x896   | 1290   |
| 9:16         | 768x1344   | 1290   |
| 16:9         | 1344x768   | 1290   |
| 21:9         | 1536x672   | 1290   |

**Gemini 3 Pro Image Preview**

| Aspect ratio | 1K resolution | 1K tokens | 2K resolution | 2K tokens | 4K resolution | 4K tokens |
| ------------ | ------------- | --------- | ------------- | --------- | ------------- | --------- |
| **1:1**      | 1024x1024     | 1120      | 2048x2048     | 1120      | 4096x4096     | 2000      |
| **2:3**      | 848x1264      | 1120      | 1696x2528     | 1120      | 3392x5056     | 2000      |
| **3:2**      | 1264x848      | 1120      | 2528x1696     | 1120      | 5056x3392     | 2000      |
| **3:4**      | 896x1200      | 1120      | 1792x2400     | 1120      | 3584x4800     | 2000      |
| **4:3**      | 1200x896      | 1120      | 2400x1792     | 1120      | 4800x3584     | 2000      |
| **4:5**      | 928x1152      | 1120      | 1856x2304     | 1120      | 3712x4608     | 2000      |
| **5:4**      | 1152x928      | 1120      | 2304x1856     | 1120      | 4608x3712     | 2000      |
| **9:16**     | 768x1376      | 1120      | 1536x2752     | 1120      | 3072x5504     | 2000      |
| **16:9**     | 1376x768      | 1120      | 2752x1536     | 1120      | 5504x3072     | 2000      |
| **21:9**     | 1584x672      | 1120      | 3168x1344     | 1120      | 6336x2688     | 2000      |

## Model selection

Choose the model best suited for your specific use case.

- **Gemini 3 Pro Image Preview (Nano Banana Pro Preview)**is designed for professional asset production and complex instructions. This model features real-world grounding using Google Search, a default "Thinking" process that refines composition prior to generation, and can generate images of up to 4K resolutions.

- **Gemini 2.5 Flash Image (Nano Banana)**is designed for speed and efficiency. This model is optimized for high-volume, low-latency tasks and generates images at 1024px resolution.

### When to use Imagen

In addition to using Gemini's built-in image generation capabilities, you can also access[Imagen](https://ai.google.dev/gemini-api/docs/imagen), our specialized image generation model, through the Gemini API.

| Attribute         | Imagen                                                                                                                                                                                                                                 | Gemini Native Image                                                                                                                                                                                                                                                                                                                                                                                              |
| ----------------- | -------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- | ---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |
| Strengths         | Model specializes in image generation.                                                                                                                                                                                                 | **Default recommendation.** Unparalleled flexibility, contextual understanding, and simple, mask-free editing. Uniquely capable of multi-turn conversational editing.                                                                                                                                                                                                                                            |
| Availability      | Generally available                                                                                                                                                                                                                    | Preview (Production usage allowed)                                                                                                                                                                                                                                                                                                                                                                               |
| Latency           | **Low**. Optimized for near-real-time performance.                                                                                                                                                                                     | Higher. More computation is required for its advanced capabilities.                                                                                                                                                                                                                                                                                                                                              |
| Cost              | Cost-effective for specialized tasks. $0.02/image to $0.12/image                                                                                                                                                                       | Token-based pricing. $30 per 1 million tokens for image output (image output tokenized at 1290 tokens per image flat, up to 1024x1024px)                                                                                                                                                                                                                                                                         |
| Recommended tasks | - Image quality, photorealism, artistic detail, or specific styles (e.g., impressionism, anime) are top priorities. - Infusing branding, style, or generating logos and product designs. - Generating advanced spelling or typography. | - Interleaved text and image generation to seamlessly blend text and images. - Combine creative elements from multiple images with a single prompt. - Make highly specific edits to images, modify individual elements with simple language commands, and iteratively work on an image. - Apply a specific design or texture from one image to another while preserving the original subject's form and details. |

Imagen 4 should be your go-to model when starting to generate images with Imagen. Choose Imagen 4 Ultra for advanced use-cases or when you need the best image quality (note that can only generate one image at a time).

## What's next

- Find more examples and code samples in the[cookbook guide](https://colab.research.google.com/github/google-gemini/cookbook/blob/main/quickstarts/Get_Started_Nano_Banana.ipynb).
- Check out the[Veo guide](https://ai.google.dev/gemini-api/docs/video)to learn how to generate videos with the Gemini API.
- To learn more about Gemini models, see[Gemini models](https://ai.google.dev/gemini-api/docs/models/gemini).
</file>

<file path="vibe/ref/image-understanding-guide.md">
<br />

Gemini models are built to be multimodal from the ground up, unlocking a wide range of image processing and computer vision tasks including but not limited to image captioning, classification, and visual question answering without having to train specialized ML models.
| **Tip:** In addition to their general multimodal capabilities, Gemini models (2.0 and newer) offer**improved accuracy** for specific use cases like[object detection](https://ai.google.dev/gemini-api/docs/image-understanding#object-detection)and[segmentation](https://ai.google.dev/gemini-api/docs/image-understanding#segmentation), through additional training. See the[Capabilities](https://ai.google.dev/gemini-api/docs/image-understanding#capabilities)section for more details.

## Passing images to Gemini

You can provide images as input to Gemini using two methods:

- [Passing inline image data](https://ai.google.dev/gemini-api/docs/image-understanding#inline-image): Ideal for smaller files (total request size less than 20MB, including prompts).
- [Uploading images using the File API](https://ai.google.dev/gemini-api/docs/image-understanding#upload-image): Recommended for larger files or for reusing images across multiple requests.

### Passing inline image data

You can pass inline image data in the request to`generateContent`. You can provide image data as Base64 encoded strings or by reading local files directly (depending on the language).

The following example shows how to read an image from a local file and pass it to`generateContent`API for processing.

### Python

      from google import genai
      from google.genai import types

      with open('path/to/small-sample.jpg', 'rb') as f:
          image_bytes = f.read()

      client = genai.Client()
      response = client.models.generate_content(
        model='gemini-2.5-flash',
        contents=[
          types.Part.from_bytes(
            data=image_bytes,
            mime_type='image/jpeg',
          ),
          'Caption this image.'
        ]
      )

      print(response.text)

### JavaScript

    import { GoogleGenAI } from "@google/genai";
    import * as fs from "node:fs";

    const ai = new GoogleGenAI({});
    const base64ImageFile = fs.readFileSync("path/to/small-sample.jpg", {
      encoding: "base64",
    });

    const contents = [
      {
        inlineData: {
          mimeType: "image/jpeg",
          data: base64ImageFile,
        },
      },
      { text: "Caption this image." },
    ];

    const response = await ai.models.generateContent({
      model: "gemini-2.5-flash",
      contents: contents,
    });
    console.log(response.text);

### Go

    bytes, _ := os.ReadFile("path/to/small-sample.jpg")

    parts := []*genai.Part{
      genai.NewPartFromBytes(bytes, "image/jpeg"),
      genai.NewPartFromText("Caption this image."),
    }

    contents := []*genai.Content{
      genai.NewContentFromParts(parts, genai.RoleUser),
    }

    result, _ := client.Models.GenerateContent(
      ctx,
      "gemini-2.5-flash",
      contents,
      nil,
    )

    fmt.Println(result.Text())

### REST

    IMG_PATH="/path/to/your/image1.jpg"

    if [[ "$(base64 --version 2>&1)" = *"FreeBSD"* ]]; then
    B64FLAGS="--input"
    else
    B64FLAGS="-w0"
    fi

    curl "https://generativelanguage.googleapis.com/v1beta/models/gemini-2.5-flash:generateContent" \
    -H "x-goog-api-key: $GEMINI_API_KEY" \
    -H 'Content-Type: application/json' \
    -X POST \
    -d '{
        "contents": [{
        "parts":[
            {
                "inline_data": {
                "mime_type":"image/jpeg",
                "data": "'"$(base64 $B64FLAGS $IMG_PATH)"'"
                }
            },
            {"text": "Caption this image."},
        ]
        }]
    }' 2> /dev/null

You can also fetch an image from a URL, convert it to bytes, and pass it to`generateContent`as shown in the following examples.

### Python

    from google import genai
    from google.genai import types

    import requests

    image_path = "https://goo.gle/instrument-img"
    image_bytes = requests.get(image_path).content
    image = types.Part.from_bytes(
      data=image_bytes, mime_type="image/jpeg"
    )

    client = genai.Client()

    response = client.models.generate_content(
        model="gemini-2.5-flash",
        contents=["What is this image?", image],
    )

    print(response.text)

### JavaScript

    import { GoogleGenAI } from "@google/genai";

    async function main() {
      const ai = new GoogleGenAI({});

      const imageUrl = "https://goo.gle/instrument-img";

      const response = await fetch(imageUrl);
      const imageArrayBuffer = await response.arrayBuffer();
      const base64ImageData = Buffer.from(imageArrayBuffer).toString('base64');

      const result = await ai.models.generateContent({
        model: "gemini-2.5-flash",
        contents: [
        {
          inlineData: {
            mimeType: 'image/jpeg',
            data: base64ImageData,
          },
        },
        { text: "Caption this image." }
      ],
      });
      console.log(result.text);
    }

    main();

### Go

    package main

    import (
      "context"
      "fmt"
      "os"
      "io"
      "net/http"
      "google.golang.org/genai"
    )

    func main() {
      ctx := context.Background()
      client, err := genai.NewClient(ctx, nil)
      if err != nil {
          log.Fatal(err)
      }

      // Download the image.
      imageResp, _ := http.Get("https://goo.gle/instrument-img")

      imageBytes, _ := io.ReadAll(imageResp.Body)

      parts := []*genai.Part{
        genai.NewPartFromBytes(imageBytes, "image/jpeg"),
        genai.NewPartFromText("Caption this image."),
      }

      contents := []*genai.Content{
        genai.NewContentFromParts(parts, genai.RoleUser),
      }

      result, _ := client.Models.GenerateContent(
        ctx,
        "gemini-2.5-flash",
        contents,
        nil,
      )

      fmt.Println(result.Text())
    }

### REST

    IMG_URL="https://goo.gle/instrument-img"

    MIME_TYPE=$(curl -sIL "$IMG_URL" | grep -i '^content-type:' | awk -F ': ' '{print $2}' | sed 's/\r$//' | head -n 1)
    if [[ -z "$MIME_TYPE" || ! "$MIME_TYPE" == image/* ]]; then
      MIME_TYPE="image/jpeg"
    fi

    # Check for macOS
    if [[ "$(uname)" == "Darwin" ]]; then
      IMAGE_B64=$(curl -sL "$IMG_URL" | base64 -b 0)
    elif [[ "$(base64 --version 2>&1)" = *"FreeBSD"* ]]; then
      IMAGE_B64=$(curl -sL "$IMG_URL" | base64)
    else
      IMAGE_B64=$(curl -sL "$IMG_URL" | base64 -w0)
    fi

    curl "https://generativelanguage.googleapis.com/v1beta/models/gemini-2.5-flash:generateContent" \
        -H "x-goog-api-key: $GEMINI_API_KEY" \
        -H 'Content-Type: application/json' \
        -X POST \
        -d '{
          "contents": [{
            "parts":[
                {
                  "inline_data": {
                    "mime_type":"'"$MIME_TYPE"'",
                    "data": "'"$IMAGE_B64"'"
                  }
                },
                {"text": "Caption this image."}
            ]
          }]
        }' 2> /dev/null

| **Note:** Inline image data limits your total request size (text prompts, system instructions, and inline bytes) to 20MB. For larger requests,[upload image files](https://ai.google.dev/gemini-api/docs/image-understanding#upload-image)using the File API. Files API is also more efficient for scenarios that use the same image repeatedly.

### Uploading images using the File API

For large files or to be able to use the same image file repeatedly, use the Files API. The following code uploads an image file and then uses the file in a call to`generateContent`. See the[Files API guide](https://ai.google.dev/gemini-api/docs/files)for more information and examples.

### Python

    from google import genai

    client = genai.Client()

    my_file = client.files.upload(file="path/to/sample.jpg")

    response = client.models.generate_content(
        model="gemini-2.5-flash",
        contents=[my_file, "Caption this image."],
    )

    print(response.text)

### JavaScript

    import {
      GoogleGenAI,
      createUserContent,
      createPartFromUri,
    } from "@google/genai";

    const ai = new GoogleGenAI({});

    async function main() {
      const myfile = await ai.files.upload({
        file: "path/to/sample.jpg",
        config: { mimeType: "image/jpeg" },
      });

      const response = await ai.models.generateContent({
        model: "gemini-2.5-flash",
        contents: createUserContent([
          createPartFromUri(myfile.uri, myfile.mimeType),
          "Caption this image.",
        ]),
      });
      console.log(response.text);
    }

    await main();

### Go

    package main

    import (
      "context"
      "fmt"
      "os"
      "google.golang.org/genai"
    )

    func main() {
      ctx := context.Background()
      client, err := genai.NewClient(ctx, nil)
      if err != nil {
          log.Fatal(err)
      }

      uploadedFile, _ := client.Files.UploadFromPath(ctx, "path/to/sample.jpg", nil)

      parts := []*genai.Part{
          genai.NewPartFromText("Caption this image."),
          genai.NewPartFromURI(uploadedFile.URI, uploadedFile.MIMEType),
      }

      contents := []*genai.Content{
          genai.NewContentFromParts(parts, genai.RoleUser),
      }

      result, _ := client.Models.GenerateContent(
          ctx,
          "gemini-2.5-flash",
          contents,
          nil,
      )

      fmt.Println(result.Text())
    }

### REST

    IMAGE_PATH="path/to/sample.jpg"
    MIME_TYPE=$(file -b --mime-type "${IMAGE_PATH}")
    NUM_BYTES=$(wc -c < "${IMAGE_PATH}")
    DISPLAY_NAME=IMAGE

    tmp_header_file=upload-header.tmp

    # Initial resumable request defining metadata.
    # The upload url is in the response headers dump them to a file.
    curl "https://generativelanguage.googleapis.com/upload/v1beta/files" \
      -H "x-goog-api-key: $GEMINI_API_KEY" \
      -D upload-header.tmp \
      -H "X-Goog-Upload-Protocol: resumable" \
      -H "X-Goog-Upload-Command: start" \
      -H "X-Goog-Upload-Header-Content-Length: ${NUM_BYTES}" \
      -H "X-Goog-Upload-Header-Content-Type: ${MIME_TYPE}" \
      -H "Content-Type: application/json" \
      -d "{'file': {'display_name': '${DISPLAY_NAME}'}}" 2> /dev/null

    upload_url=$(grep -i "x-goog-upload-url: " "${tmp_header_file}" | cut -d" " -f2 | tr -d "\r")
    rm "${tmp_header_file}"

    # Upload the actual bytes.
    curl "${upload_url}" \
      -H "x-goog-api-key: $GEMINI_API_KEY" \
      -H "Content-Length: ${NUM_BYTES}" \
      -H "X-Goog-Upload-Offset: 0" \
      -H "X-Goog-Upload-Command: upload, finalize" \
      --data-binary "@${IMAGE_PATH}" 2> /dev/null > file_info.json

    file_uri=$(jq -r ".file.uri" file_info.json)
    echo file_uri=$file_uri

    # Now generate content using that file
    curl "https://generativelanguage.googleapis.com/v1beta/models/gemini-2.5-flash:generateContent" \
        -H "x-goog-api-key: $GEMINI_API_KEY" \
        -H 'Content-Type: application/json' \
        -X POST \
        -d '{
          "contents": [{
            "parts":[
              {"file_data":{"mime_type": "'"${MIME_TYPE}"'", "file_uri": "'"${file_uri}"'"}},
              {"text": "Caption this image."}]
            }]
          }' 2> /dev/null > response.json

    cat response.json
    echo

    jq ".candidates[].content.parts[].text" response.json

## Prompting with multiple images

You can provide multiple images in a single prompt by including multiple image`Part`objects in the`contents`array. These can be a mix of inline data (local files or URLs) and File API references.

### Python

    from google import genai
    from google.genai import types

    client = genai.Client()

    # Upload the first image
    image1_path = "path/to/image1.jpg"
    uploaded_file = client.files.upload(file=image1_path)

    # Prepare the second image as inline data
    image2_path = "path/to/image2.png"
    with open(image2_path, 'rb') as f:
        img2_bytes = f.read()

    # Create the prompt with text and multiple images
    response = client.models.generate_content(

        model="gemini-2.5-flash",
        contents=[
            "What is different between these two images?",
            uploaded_file,  # Use the uploaded file reference
            types.Part.from_bytes(
                data=img2_bytes,
                mime_type='image/png'
            )
        ]
    )

    print(response.text)

### JavaScript

    import {
      GoogleGenAI,
      createUserContent,
      createPartFromUri,
    } from "@google/genai";
    import * as fs from "node:fs";

    const ai = new GoogleGenAI({});

    async function main() {
      // Upload the first image
      const image1_path = "path/to/image1.jpg";
      const uploadedFile = await ai.files.upload({
        file: image1_path,
        config: { mimeType: "image/jpeg" },
      });

      // Prepare the second image as inline data
      const image2_path = "path/to/image2.png";
      const base64Image2File = fs.readFileSync(image2_path, {
        encoding: "base64",
      });

      // Create the prompt with text and multiple images

      const response = await ai.models.generateContent({

        model: "gemini-2.5-flash",
        contents: createUserContent([
          "What is different between these two images?",
          createPartFromUri(uploadedFile.uri, uploadedFile.mimeType),
          {
            inlineData: {
              mimeType: "image/png",
              data: base64Image2File,
            },
          },
        ]),
      });
      console.log(response.text);
    }

    await main();

### Go

    // Upload the first image
    image1Path := "path/to/image1.jpg"
    uploadedFile, _ := client.Files.UploadFromPath(ctx, image1Path, nil)

    // Prepare the second image as inline data
    image2Path := "path/to/image2.jpeg"
    imgBytes, _ := os.ReadFile(image2Path)

    parts := []*genai.Part{
      genai.NewPartFromText("What is different between these two images?"),
      genai.NewPartFromBytes(imgBytes, "image/jpeg"),
      genai.NewPartFromURI(uploadedFile.URI, uploadedFile.MIMEType),
    }

    contents := []*genai.Content{
      genai.NewContentFromParts(parts, genai.RoleUser),
    }

    result, _ := client.Models.GenerateContent(
      ctx,
      "gemini-2.5-flash",
      contents,
      nil,
    )

    fmt.Println(result.Text())

### REST

    # Upload the first image
    IMAGE1_PATH="path/to/image1.jpg"
    MIME1_TYPE=$(file -b --mime-type "${IMAGE1_PATH}")
    NUM1_BYTES=$(wc -c < "${IMAGE1_PATH}")
    DISPLAY_NAME1=IMAGE1

    tmp_header_file1=upload-header1.tmp

    curl "https://generativelanguage.googleapis.com/upload/v1beta/files" \
      -H "x-goog-api-key: $GEMINI_API_KEY" \
      -D upload-header1.tmp \
      -H "X-Goog-Upload-Protocol: resumable" \
      -H "X-Goog-Upload-Command: start" \
      -H "X-Goog-Upload-Header-Content-Length: ${NUM1_BYTES}" \
      -H "X-Goog-Upload-Header-Content-Type: ${MIME1_TYPE}" \
      -H "Content-Type: application/json" \
      -d "{'file': {'display_name': '${DISPLAY_NAME1}'}}" 2> /dev/null

    upload_url1=$(grep -i "x-goog-upload-url: " "${tmp_header_file1}" | cut -d" " -f2 | tr -d "\r")
    rm "${tmp_header_file1}"

    curl "${upload_url1}" \
      -H "Content-Length: ${NUM1_BYTES}" \
      -H "X-Goog-Upload-Offset: 0" \
      -H "X-Goog-Upload-Command: upload, finalize" \
      --data-binary "@${IMAGE1_PATH}" 2> /dev/null > file_info1.json

    file1_uri=$(jq ".file.uri" file_info1.json)
    echo file1_uri=$file1_uri

    # Prepare the second image (inline)
    IMAGE2_PATH="path/to/image2.png"
    MIME2_TYPE=$(file -b --mime-type "${IMAGE2_PATH}")

    if [[ "$(base64 --version 2>&1)" = *"FreeBSD"* ]]; then
      B64FLAGS="--input"
    else
      B64FLAGS="-w0"
    fi
    IMAGE2_BASE64=$(base64 $B64FLAGS $IMAGE2_PATH)

    # Now generate content using both images
    curl "https://generativelanguage.googleapis.com/v1beta/models/gemini-2.5-flash:generateContent" \
        -H "x-goog-api-key: $GEMINI_API_KEY" \
        -H 'Content-Type: application/json' \
        -X POST \
        -d '{
          "contents": [{
            "parts":[
              {"text": "What is different between these two images?"},
              {"file_data":{"mime_type": "'"${MIME1_TYPE}"'", "file_uri": '$file1_uri'}},
              {
                "inline_data": {
                  "mime_type":"'"${MIME2_TYPE}"'",
                  "data": "'"$IMAGE2_BASE64"'"
                }
              }
            ]
          }]
        }' 2> /dev/null > response.json

    cat response.json
    echo

    jq ".candidates[].content.parts[].text" response.json

## Object detection

From Gemini 2.0 onwards, models are further trained to detect objects in an image and get their bounding box coordinates. The coordinates, relative to image dimensions, scale to \[0, 1000\]. You need to descale these coordinates based on your original image size.

### Python

    from google import genai
    from google.genai import types
    from PIL import Image
    import json

    client = genai.Client()
    prompt = "Detect the all of the prominent items in the image. The box_2d should be [ymin, xmin, ymax, xmax] normalized to 0-1000."

    image = Image.open("/path/to/image.png")

    config = types.GenerateContentConfig(
      response_mime_type="application/json"
      )

    response = client.models.generate_content(model="gemini-2.5-flash",
                                              contents=[image, prompt],
                                              config=config
                                              )

    width, height = image.size
    bounding_boxes = json.loads(response.text)

    converted_bounding_boxes = []
    for bounding_box in bounding_boxes:
        abs_y1 = int(bounding_box["box_2d"][0]/1000 * height)
        abs_x1 = int(bounding_box["box_2d"][1]/1000 * width)
        abs_y2 = int(bounding_box["box_2d"][2]/1000 * height)
        abs_x2 = int(bounding_box["box_2d"][3]/1000 * width)
        converted_bounding_boxes.append([abs_x1, abs_y1, abs_x2, abs_y2])

    print("Image size: ", width, height)
    print("Bounding boxes:", converted_bounding_boxes)

| **Note:** The model also supports generating bounding boxes based on custom instructions, such as: "Show bounding boxes of all green objects in this image". It also support custom labels like "label the items with the allergens they can contain".

For more examples, check following notebooks in the[Gemini Cookbook](https://github.com/google-gemini/cookbook):

- [2D spatial understanding notebook](https://colab.research.google.com/github/google-gemini/cookbook/blob/main/quickstarts/Spatial_understanding.ipynb)
- [Experimental 3D pointing notebook](https://colab.research.google.com/github/google-gemini/cookbook/blob/main/examples/Spatial_understanding_3d.ipynb)

## Segmentation

Starting with Gemini 2.5, models not only detect items but also segment them and provide their contour masks.

The model predicts a JSON list, where each item represents a segmentation mask. Each item has a bounding box ("`box_2d`") in the format`[y0, x0, y1, x1]`with normalized coordinates between 0 and 1000, a label ("`label`") that identifies the object, and finally the segmentation mask inside the bounding box, as base64 encoded png that is a probability map with values between 0 and 255. The mask needs to be resized to match the bounding box dimensions, then binarized at your confidence threshold (127 for the midpoint).
**Note:** For better results, disable[thinking](https://ai.google.dev/gemini-api/docs/thinking)by setting the thinking budget to 0. See code sample below for an example.

### Python

    from google import genai
    from google.genai import types
    from PIL import Image, ImageDraw
    import io
    import base64
    import json
    import numpy as np
    import os

    client = genai.Client()

    def parse_json(json_output: str):
      # Parsing out the markdown fencing
      lines = json_output.splitlines()
      for i, line in enumerate(lines):
        if line == "```json":
          json_output = "\n".join(lines[i+1:])  # Remove everything before "```json"
          output = json_output.split("```")[0]  # Remove everything after the closing "```"
          break  # Exit the loop once "```json" is found
      return json_output

    def extract_segmentation_masks(image_path: str, output_dir: str = "segmentation_outputs"):
      # Load and resize image
      im = Image.open(image_path)
      im.thumbnail([1024, 1024], Image.Resampling.LANCZOS)

      prompt = """
      Give the segmentation masks for the wooden and glass items.
      Output a JSON list of segmentation masks where each entry contains the 2D
      bounding box in the key "box_2d", the segmentation mask in key "mask", and
      the text label in the key "label". Use descriptive labels.
      """

      config = types.GenerateContentConfig(
        thinking_config=types.ThinkingConfig(thinking_budget=0) # set thinking_budget to 0 for better results in object detection
      )

      response = client.models.generate_content(
        model="gemini-2.5-flash",
        contents=[prompt, im], # Pillow images can be directly passed as inputs (which will be converted by the SDK)
        config=config
      )

      # Parse JSON response
      items = json.loads(parse_json(response.text))

      # Create output directory
      os.makedirs(output_dir, exist_ok=True)

      # Process each mask
      for i, item in enumerate(items):
          # Get bounding box coordinates
          box = item["box_2d"]
          y0 = int(box[0] / 1000 * im.size[1])
          x0 = int(box[1] / 1000 * im.size[0])
          y1 = int(box[2] / 1000 * im.size[1])
          x1 = int(box[3] / 1000 * im.size[0])

          # Skip invalid boxes
          if y0 >= y1 or x0 >= x1:
              continue

          # Process mask
          png_str = item["mask"]
          if not png_str.startswith("data:image/png;base64,"):
              continue

          # Remove prefix
          png_str = png_str.removeprefix("data:image/png;base64,")
          mask_data = base64.b64decode(png_str)
          mask = Image.open(io.BytesIO(mask_data))

          # Resize mask to match bounding box
          mask = mask.resize((x1 - x0, y1 - y0), Image.Resampling.BILINEAR)

          # Convert mask to numpy array for processing
          mask_array = np.array(mask)

          # Create overlay for this mask
          overlay = Image.new('RGBA', im.size, (0, 0, 0, 0))
          overlay_draw = ImageDraw.Draw(overlay)

          # Create overlay for the mask
          color = (255, 255, 255, 200)
          for y in range(y0, y1):
              for x in range(x0, x1):
                  if mask_array[y - y0, x - x0] > 128:  # Threshold for mask
                      overlay_draw.point((x, y), fill=color)

          # Save individual mask and its overlay
          mask_filename = f"{item['label']}_{i}_mask.png"
          overlay_filename = f"{item['label']}_{i}_overlay.png"

          mask.save(os.path.join(output_dir, mask_filename))

          # Create and save overlay
          composite = Image.alpha_composite(im.convert('RGBA'), overlay)
          composite.save(os.path.join(output_dir, overlay_filename))
          print(f"Saved mask and overlay for {item['label']} to {output_dir}")

    # Example usage
    if __name__ == "__main__":
      extract_segmentation_masks("path/to/image.png")

Check the[segmentation example](https://colab.research.google.com/github/google-gemini/cookbook/blob/main/quickstarts/Spatial_understanding.ipynb#scrollTo=WQJTJ8wdGOKx)in the cookbook guide for a more detailed example.
![A table with cupcakes, with the wooden and glass objects highlighted](https://ai.google.dev/static/gemini-api/docs/images/segmentation.jpg)An example segmentation output with objects and segmentation masks

## Supported image formats

Gemini supports the following image format MIME types:

- PNG -`image/png`
- JPEG -`image/jpeg`
- WEBP -`image/webp`
- HEIC -`image/heic`
- HEIF -`image/heif`

## Capabilities

All Gemini model versions are multimodal and can be utilized in a wide range of image processing and computer vision tasks including but not limited to image captioning, visual question and answering, image classification, object detection and segmentation.

Gemini can reduce the need to use specialized ML models depending on your quality and performance requirements.

Some later model versions are specifically trained improve accuracy of specialized tasks in addition to generic capabilities:

- **Gemini 2.0 models** are further trained to support enhanced[object detection](https://ai.google.dev/gemini-api/docs/image-understanding#object-detection).

- **Gemini 2.5 models** are further trained to support enhanced[segmentation](https://ai.google.dev/gemini-api/docs/image-understanding#segmentation)in addition to[object detection](https://ai.google.dev/gemini-api/docs/image-understanding#object-detection).

## Limitations and key technical information

### File limit

Gemini 2.5 Pro/Flash, 2.0 Flash, 1.5 Pro, and 1.5 Flash support a maximum of 3,600 image files per request.

### Token calculation

- **Gemini 1.5 Flash and Gemini 1.5 Pro**: 258 tokens if both dimensions \<= 384 pixels. Larger images are tiled (min tile 256px, max 768px, resized to 768x768), with each tile costing 258 tokens.
- **Gemini 2.0 Flash and Gemini 2.5 Flash/Pro**: 258 tokens if both dimensions \<= 384 pixels. Larger images are tiled into 768x768 pixel tiles, each costing 258 tokens.

A rough formula for calculating the number of tiles is as follows:

- Calculate the crop unit size which is roughly: floor(min(width, height) / 1.5).
- Divide each dimension by the crop unit size and multiply together to get the number of tiles.

For example, for an image of dimensions 960x540 would have a crop unit size of 360. Divide each dimension by 360 and the number of tile is 3 \* 2 = 6.

### Media resolution

Gemini 3 introduces granular control over multimodal vision processing with the`media_resolution`parameter. The`media_resolution`parameter determines the**maximum number of tokens allocated per input image or video frame.**Higher resolutions improve the model's ability to read fine text or identify small details, but increase token usage and latency.

For more details about the parameter and how it can impact token calculations, see the[media resolution](https://ai.google.dev/gemini-api/docs/media-resolution)guide.

## Tips and best practices

- Verify that images are correctly rotated.
- Use clear, non-blurry images.
- When using a single image with text, place the text prompt*after* the image part in the`contents`array.

## What's next

This guide shows you how to upload image files and generate text outputs from image inputs. To learn more, see the following resources:

- [Files API](https://ai.google.dev/gemini-api/docs/files): Learn more about uploading and managing files for use with Gemini.
- [System instructions](https://ai.google.dev/gemini-api/docs/text-generation#system-instructions): System instructions let you steer the behavior of the model based on your specific needs and use cases.
- [File prompting strategies](https://ai.google.dev/gemini-api/docs/files#prompt-guide): The Gemini API supports prompting with text, image, audio, and video data, also known as multimodal prompting.
- [Safety guidance](https://ai.google.dev/gemini-api/docs/safety-guidance): Sometimes generative AI models produce unexpected outputs, such as outputs that are inaccurate, biased, or offensive. Post-processing and human evaluation are essential to limit the risk of harm from such outputs.
</file>

<file path="vibe/ref/imagemagick-guide.md">
## ImageMagick 이미지 처리 도구

### 기본 명령어
```bash
# 시스템 PATH가 설정된 경우
magick <input> [옵션] <output>

# 환경별 절대 경로 사용 시 (현재 프로젝트 권장)
"C:\Program Files\ImageMagick-7.1.2-Q16-HDRI\magick.exe" <input> [옵션] <output>
```

### 작업 자동 선택 규칙

| 작업 유형 | 키워드/특징 | 명령어 |
|----------|-------------|--------|
| 투명 영역 제거 | trim, 여백 제거, 자동 crop | `-trim +repage` |
| 수동 자르기 | crop, 특정 영역, 좌표 | `-crop WxH+X+Y +repage` |
| 중앙 자르기 | 중앙, center crop | `-gravity center -crop WxH+0+0 +repage` |
| 비율 자르기 | 정사각형, 1:1, 16:9 | `-gravity center -crop 1:1 +repage` |
| 리사이즈 (비율 유지) | 축소, 확대, resize | `-resize WxH` |
| 리사이즈 (강제) | 정확한 크기, 왜곡 허용 | `-resize WxH!` |
| 축소만 | 크면 축소, 작으면 유지 | `-resize "WxH>"` |
| 캔버스 확장 | 여백 추가, 정사각형 만들기 | `-gravity center -background transparent -extent WxH` |
| 여백 추가 | 테두리, border, padding | `-bordercolor transparent -border N` |
| 배경색 변경 | 흰색 배경, 투명 제거 | `-background white -flatten` |
| 형식 변환 | jpg, webp, ico | 출력 확장자 변경 |

### 복합 작업 패턴

> **Tip**: 아래 예시의 `magick`은 환경에 따라 `"C:\Program Files\ImageMagick-7.1.2-Q16-HDRI\magick.exe"`로 대체하여 사용하세요.

```bash
# 아이콘/썸네일 생성 (가장 많이 사용)
magick input.png -trim +repage -resize WxH -gravity center -background transparent -extent WxH output.png

# 정사각형 썸네일
magick input.png -trim +repage -resize 256x256 -gravity center -background transparent -extent 256x256 thumb.png

# 웹용 이미지 (흰색 배경 + JPEG)
magick input.png -trim +repage -resize 800x800 -background white -flatten -quality 90 output.jpg
```

### 주요 크기 프리셋

| 용도 | 크기 | 명령어 예시 |
|------|------|-------------|
| 아이콘 (작은) | 32x32, 64x64 | `-resize 64x64 -extent 64x64` |
| 아이콘 (중간) | 128x128 | `-resize 128x128 -extent 128x128` |
| 썸네일 | 256x256 | `-resize 256x256 -extent 256x256` |
| 프로필/아바타 | 512x512 | `-resize 512x512 -extent 512x512` |
| 웹 이미지 | 800x800, 1024x1024 | `-resize 1024x1024` |
| 고해상도 | 2048x2048 | `-resize 2048x2048` |

### 작업 순서

1. `-trim +repage` (투명 영역 제거)
2. `-resize WxH` (크기 조정)
3. `-gravity center` (정렬)
4. `-background transparent` (배경색)
5. `-extent WxH` (캔버스 확장)

### 주의사항
- PNG/WebP: 투명 배경 유지
- JPEG: 투명 배경 미지원 → `-background white -flatten` 필요
- `+repage`: trim/crop 후 항상 추가
- 한글 경로 피하기 (영문 권장)
</file>

<file path="vibe/ref/nanobanana-asset-request.schema.json">
{
  "$schema": "http://json-schema.org/draft-07/schema#",
  "$id": "https://unknown-world.dev/schemas/nanobanana-asset-request.json",
  "title": "nanobanana mcp Asset Request Schema",
  "description": "nanobanana mcp로 에셋을 요청할 때 사용하는 표준 스키마 (개발용, RULE-007 준수). 참조: nanobanana-mcp.md, rembg-guide.md, imagemagick-guide.md",
  "type": "object",
  "required": ["id", "category", "purpose", "size_px"],
  "additionalProperties": false,
  "properties": {
    "id": {
      "type": "string",
      "pattern": "^[a-z0-9]+(-[a-z0-9]+)*$",
      "description": "에셋 고유 ID (kebab-case, 네이밍 규칙 준수)",
      "examples": ["signal-24", "badge-ok-16", "scene-loading", "panel-corner-tl", "scanner-frame"]
    },
    "category": {
      "type": "string",
      "enum": ["icon", "placeholder", "chrome"],
      "description": "에셋 카테고리 (아이콘/placeholder/chrome). 카테고리별 프롬프트 템플릿은 nanobanana-mcp.md 섹션 2 참조"
    },
    "purpose": {
      "type": "string",
      "maxLength": 100,
      "description": "에셋 용도 (무엇을 표현하는가, 어디에 쓰이는가)",
      "examples": [
        "Economy HUD의 Signal 재화 아이콘",
        "스트리밍 로딩 중 Scene Canvas placeholder",
        "Action Deck 카드 프레임 코너",
        "Scanner 패널 이미지 업로드 슬롯 프레임"
      ]
    },
    "size_px": {
      "oneOf": [
        {
          "type": "integer",
          "enum": [16, 24, 32, 64, 128, 256, 512, 800, 1024, 2048],
          "description": "정사각형 아이콘 사이즈 (px) - imagemagick-guide.md 크기 프리셋 참조"
        },
        {
          "type": "object",
          "required": ["width", "height"],
          "properties": {
            "width": { "type": "integer", "minimum": 1, "maximum": 4096 },
            "height": { "type": "integer", "minimum": 1, "maximum": 4096 }
          },
          "additionalProperties": false,
          "description": "비정사각형 placeholder/chrome 사이즈"
        }
      ],
      "description": "에셋 크기 (px). 후처리(ImageMagick)로 최종 크기 조정"
    },
    "size_preset": {
      "type": "string",
      "enum": [
        "icon-small",
        "icon-medium",
        "icon-large",
        "thumbnail",
        "avatar",
        "web-standard",
        "high-res",
        "custom"
      ],
      "description": "크기 프리셋 (imagemagick-guide.md 참조). icon-small: 32x32/64x64, icon-medium: 128x128, icon-large: 256x256, thumbnail: 256x256, avatar: 512x512, web-standard: 800x800/1024x1024, high-res: 2048x2048"
    },
    "palette": {
      "type": "array",
      "items": {
        "type": "string",
        "pattern": "^#[0-9a-fA-F]{6}$"
      },
      "default": ["#33ff00", "#ff00ff", "#ffaa00", "#ff3333"],
      "description": "사용할 색상 팔레트 (CRT 테마 기본값 적용). nanobanana-mcp.md 섹션 1 아트 디렉션 참조",
      "examples": [
        ["#33ff00"],
        ["#33ff00", "#ff00ff"],
        ["#33ff00", "#0d0d0d"]
      ]
    },
    "mood": {
      "type": "string",
      "enum": [
        "retro",
        "glitch",
        "minimal",
        "danger",
        "warning",
        "success",
        "neutral",
        "cinematic",
        "technical"
      ],
      "default": "retro",
      "description": "에셋 분위기/톤 (CRT 레트로 기본)"
    },
    "background": {
      "type": "string",
      "enum": ["transparent", "solid_white", "solid_black"],
      "default": "transparent",
      "description": "배경 유형. 투명 필요 시 solid_white로 생성 후 rembg 제거 (rembg-guide.md 참조)"
    },
    "must_have": {
      "type": "array",
      "items": { "type": "string", "maxLength": 50 },
      "maxItems": 5,
      "description": "반드시 포함할 시각 요소",
      "examples": [
        ["인광 녹색 글로우", "단순한 실루엣"],
        ["스캔라인 느낌", "CRT 잔상"],
        ["thin glowing lines", "technical schematic style"]
      ]
    },
    "must_not_have": {
      "type": "array",
      "items": { "type": "string", "maxLength": 50 },
      "maxItems": 5,
      "default": ["텍스트 렌더링", "복잡한 그라데이션", "사진 스타일"],
      "description": "반드시 제외할 시각 요소 (nanobanana-mcp.md 금지 사항 참조)"
    },
    "fallback_text": {
      "type": "string",
      "maxLength": 10,
      "description": "에셋 로딩 실패 시 대체 이모지/텍스트",
      "examples": ["📡", "⚡", "💎", "⚠️", "OK", "FAIL", "📷"]
    },
    "output_path": {
      "type": "string",
      "pattern": "^(icons|placeholders|chrome)/[a-z0-9-]+\\.(png|webp|jpg)$",
      "description": "frontend/public/ui/ 기준 저장 경로",
      "examples": [
        "icons/signal-24.png",
        "placeholders/scene-loading.webp",
        "chrome/panel-corner-tl.png",
        "chrome/scanner-frame.png"
      ]
    },
    "output_format": {
      "type": "string",
      "enum": ["png", "webp", "jpeg"],
      "default": "png",
      "description": "출력 형식. PNG/WebP: 투명 배경 유지, JPEG: 투명 배경 미지원 (imagemagick-guide.md 주의사항 참조)"
    },

    "requires_rembg": {
      "type": "boolean",
      "default": false,
      "description": "rembg 배경 제거 필요 여부 (true면 solid_white 배경으로 생성 권장)"
    },
    "rembg_options": {
      "type": "object",
      "description": "rembg 배경 제거 옵션 (rembg-guide.md 상세 참조)",
      "properties": {
        "model": {
          "type": "string",
          "enum": [
            "birefnet-general",
            "birefnet-portrait",
            "birefnet-dis",
            "birefnet-massive",
            "isnet-anime",
            "isnet-general-use",
            "u2net",
            "u2netp",
            "u2net_human_seg",
            "u2net_cloth_seg",
            "silueta"
          ],
          "default": "birefnet-general",
          "description": "rembg 모델 선택. UI 아이콘/픽셀 아트/에셋: birefnet-general(기본), 일본 애니 캐릭터: isnet-anime, 인물 초상화: birefnet-portrait, 복잡한 배경: birefnet-dis, 최고 품질: birefnet-massive, 속도 우선: u2netp"
        },
        "alpha_matting": {
          "type": "boolean",
          "default": false,
          "description": "Alpha Matting (-a 옵션). 인물/동물 털/머리카락 경계에 사용. 픽셀 아트/UI 아이콘에는 미사용 권장"
        },
        "image_type_hint": {
          "type": "string",
          "enum": [
            "ui-icon",
            "pixel-art",
            "logo",
            "product",
            "object",
            "anime-character",
            "illustration",
            "portrait",
            "human-full-body",
            "clothing",
            "complex-background",
            "general"
          ],
          "default": "ui-icon",
          "description": "이미지 유형 힌트 (모델 자동 선택 참조용)"
        }
      },
      "additionalProperties": false
    },

    "requires_imagemagick": {
      "type": "boolean",
      "default": false,
      "description": "ImageMagick 후처리 필요 여부 (trim/resize/extent)"
    },
    "imagemagick_options": {
      "type": "object",
      "description": "ImageMagick 후처리 옵션 (imagemagick-guide.md 상세 참조)",
      "properties": {
        "trim": {
          "type": "boolean",
          "default": true,
          "description": "투명 영역/여백 자동 제거 (-trim +repage)"
        },
        "resize": {
          "oneOf": [
            {
              "type": "string",
              "pattern": "^\\d+x\\d+[!>]?$",
              "description": "리사이즈 크기. WxH: 비율 유지, WxH!: 강제(왜곡 허용), WxH>: 축소만"
            },
            { "type": "null" }
          ],
          "description": "리사이즈 옵션 (-resize). null이면 리사이즈 안함",
          "examples": ["48x48", "160x80", "256x256!", "1024x1024>"]
        },
        "gravity": {
          "type": "string",
          "enum": ["center", "north", "south", "east", "west", "northwest", "northeast", "southwest", "southeast"],
          "default": "center",
          "description": "정렬 기준점 (-gravity)"
        },
        "extent": {
          "type": "string",
          "pattern": "^\\d+x\\d+$",
          "description": "캔버스 크기 확장 (-extent WxH). 주로 정사각형 썸네일 생성에 사용",
          "examples": ["48x48", "256x256", "512x512"]
        },
        "background": {
          "type": "string",
          "enum": ["transparent", "white", "black"],
          "default": "transparent",
          "description": "extent 시 배경색 (-background)"
        },
        "border": {
          "type": "integer",
          "minimum": 0,
          "description": "테두리/패딩 추가 (-border N)"
        },
        "quality": {
          "type": "integer",
          "minimum": 1,
          "maximum": 100,
          "default": 90,
          "description": "JPEG/WebP 품질 (-quality). PNG에는 적용 안됨"
        },
        "flatten": {
          "type": "boolean",
          "default": false,
          "description": "투명 배경 제거 후 단색 배경으로 병합 (-flatten). JPEG 출력 시 필수"
        }
      },
      "additionalProperties": false
    },

    "workflow": {
      "type": "array",
      "items": {
        "type": "string",
        "enum": ["generate", "rembg", "imagemagick", "manifest", "qa"]
      },
      "default": ["generate", "manifest", "qa"],
      "description": "후처리 워크플로우 순서 (nanobanana-mcp.md 섹션 4 참조). generate: nanobanana mcp 생성, rembg: 배경 제거, imagemagick: 크기 조정/crop, manifest: manifest.json 등록, qa: 품질 확인",
      "examples": [
        ["generate", "rembg", "imagemagick", "manifest", "qa"],
        ["generate", "manifest", "qa"],
        ["generate", "imagemagick", "manifest", "qa"]
      ]
    },

    "prompt_template": {
      "type": "object",
      "description": "프롬프트 템플릿 정보 (nanobanana-mcp.md 섹션 2 참조)",
      "properties": {
        "base_template": {
          "type": "string",
          "enum": ["icon", "placeholder", "chrome", "custom"],
          "description": "기본 템플릿 타입. icon: '2.1 UI 아이콘', placeholder: '2.2 상태 Placeholder', chrome: '2.3 UI 크롬/프레임'"
        },
        "subject": {
          "type": "string",
          "maxLength": 100,
          "description": "템플릿의 [SUBJECT] 또는 [SCENE_DESCRIPTION] 대체 텍스트",
          "examples": ["scanner slot with corner brackets", "loading terminal with data streams", "signal wave icon"]
        },
        "color_override": {
          "type": "string",
          "pattern": "^#[0-9a-fA-F]{6}$",
          "description": "템플릿의 [COLOR] 대체값 (기본: #33ff00)"
        },
        "custom_prompt": {
          "type": "string",
          "maxLength": 500,
          "description": "커스텀 프롬프트 전문 (base_template이 'custom'일 때 사용)"
        }
      },
      "additionalProperties": false
    },

    "notes": {
      "type": "string",
      "maxLength": 300,
      "description": "추가 참고사항 (스타일 레퍼런스, 수정 요청, 변형 요청 등)"
    },
    "prompt_version": {
      "type": "string",
      "pattern": "^v\\d+(\\.\\d+)?$",
      "default": "v1",
      "description": "프롬프트 템플릿 버전 (재현성 추적용)",
      "examples": ["v1", "v1.1", "v2"]
    },
    "created_at": {
      "type": "string",
      "format": "date",
      "description": "에셋 요청 생성일 (YYYY-MM-DD)"
    },
    "unit_id": {
      "type": "string",
      "pattern": "^U-\\d{3}(\\[\\w+\\])?$",
      "description": "관련 유닛 ID (추적용)",
      "examples": ["U-030", "U-031[Mvp]", "U-032[Mvp]"]
    }
  },

  "if": {
    "properties": { "requires_rembg": { "const": true } }
  },
  "then": {
    "properties": {
      "background": { "const": "solid_white" }
    }
  },

  "examples": [
    {
      "id": "signal-24",
      "category": "icon",
      "purpose": "Economy HUD의 Signal 재화 아이콘",
      "size_px": 24,
      "size_preset": "icon-small",
      "palette": ["#33ff00"],
      "mood": "retro",
      "background": "solid_white",
      "must_have": ["wave pattern", "simple silhouette"],
      "must_not_have": ["text", "complex gradients"],
      "fallback_text": "📡",
      "output_path": "icons/signal-24.png",
      "output_format": "png",
      "requires_rembg": true,
      "rembg_options": {
        "model": "birefnet-general",
        "alpha_matting": false,
        "image_type_hint": "ui-icon"
      },
      "requires_imagemagick": true,
      "imagemagick_options": {
        "trim": true,
        "resize": "24x24",
        "gravity": "center",
        "extent": "24x24",
        "background": "transparent"
      },
      "workflow": ["generate", "rembg", "imagemagick", "manifest", "qa"],
      "prompt_template": {
        "base_template": "icon",
        "subject": "signal wave antenna"
      },
      "prompt_version": "v1",
      "unit_id": "U-030[Mvp]"
    },
    {
      "id": "scene-loading",
      "category": "placeholder",
      "purpose": "스트리밍 로딩 중 Scene Canvas placeholder",
      "size_px": { "width": 512, "height": 384 },
      "size_preset": "custom",
      "palette": ["#33ff00", "#0d0d0d"],
      "mood": "cinematic",
      "background": "solid_black",
      "must_have": ["scanlines", "CRT glow", "data streams"],
      "must_not_have": ["text", "complex UI"],
      "fallback_text": "⏳",
      "output_path": "placeholders/scene-loading.webp",
      "output_format": "webp",
      "requires_rembg": false,
      "requires_imagemagick": true,
      "imagemagick_options": {
        "trim": false,
        "resize": "512x384",
        "quality": 85
      },
      "workflow": ["generate", "imagemagick", "manifest", "qa"],
      "prompt_template": {
        "base_template": "placeholder",
        "subject": "loading terminal with streaming data visualization"
      },
      "prompt_version": "v1",
      "unit_id": "U-031[Mvp]"
    },
    {
      "id": "scanner-frame",
      "category": "chrome",
      "purpose": "Scanner 패널 이미지 업로드 슬롯 프레임",
      "size_px": { "width": 200, "height": 200 },
      "size_preset": "custom",
      "palette": ["#33ff00"],
      "mood": "technical",
      "background": "solid_white",
      "must_have": ["thin glowing lines", "corner brackets", "scanner slot aesthetic"],
      "must_not_have": ["text", "shadows", "gradients"],
      "fallback_text": "📷",
      "output_path": "chrome/scanner-frame.png",
      "output_format": "png",
      "requires_rembg": true,
      "rembg_options": {
        "model": "birefnet-general",
        "alpha_matting": false,
        "image_type_hint": "ui-icon"
      },
      "requires_imagemagick": true,
      "imagemagick_options": {
        "trim": true,
        "resize": "200x200",
        "gravity": "center",
        "extent": "200x200",
        "background": "transparent"
      },
      "workflow": ["generate", "rembg", "imagemagick", "manifest", "qa"],
      "prompt_template": {
        "base_template": "chrome",
        "subject": "scanner upload slot with corner brackets"
      },
      "prompt_version": "v1",
      "unit_id": "U-032[Mvp]"
    }
  ]
}
</file>

<file path="vibe/ref/nanobanana-mcp.md">
# nanobanana mcp 개발용 에셋 제작 가이드 (SSOT)

> **[RULE-007]**: 이 가이드와 `nanobanana mcp`는 개발 과정에서 UI/문서용 **정적 에셋을 제작**하는 데만 사용합니다. 게임 런타임에서 MCP에 의존하는 설계는 금지합니다.

## 1. 공통 아트 디렉션 (Art Direction)

모든 에셋은 Unknown World의 **CRT 레트로 테마**와 조화를 이루어야 합니다.

- **스타일**: 80년대 CRT 모니터, 인광 그린(Phosphor Green), 낮은 해상도, 픽셀 느낌.
- **팔레트**: 
  - 기본: `#33ff00` (인광 그린)
  - 보조: `#ff00ff` (마젠타), `#ffaa00` (오렌지), `#ff3333` (레드)
  - 배경: 0순위 투명(알파), 생성 시에는 `#FFFFFF` (순백) 단색 강제.
- **금지 사항**:
  - 사진 스타일(Photorealistic) 금지.
  - 복잡한 그라데이션 및 부드러운 그림자 금지.
  - 이미지 내 텍스트 렌더링 최소화 (i18n 및 가독성 문제).
- **재현성 규칙**: 에셋 요청 시 반드시 `nanobanana-asset-request.schema.json` 스키마를 준수하여 기록합니다.

---

## 2. 카테고리별 프롬프트 템플릿 (Templates)

### 2.1 UI 아이콘 (Icons)
- **목표**: 작은 크기(16~32px)에서도 명확히 식별되는 단순한 실루엣.
- **템플릿 문구**:
  > "A minimal [SUBJECT] icon, retro CRT phosphor style, solid [COLOR] silhouette, high contrast, pixel art aesthetic, sharp edges. No text, no background, solid white background (#FFFFFF) for rembg post-processing."

### 2.2 상태 Placeholder (Placeholders)
- **목표**: 장면의 분위기를 전달하되 정보 과잉을 피함.
- **템플릿 문구**:
  > "A cinematic low-res scene of [SCENE_DESCRIPTION], CRT monitor glow effect, scanlines, phosphor green palette, dark atmosphere. Retro computer terminal aesthetic. No complex UI elements, focus on mood."

### 2.3 UI 크롬/프레임 (Chrome)
- **목표**: 패널과 카드를 장식하는 얇은 라인과 코너.
- **템플릿 문구**:
  > "A retro UI panel corner element, thin glowing lines, [COLOR] phosphor aesthetic, technical schematic style. Minimalist rivet or joint detail. Solid white background (#FFFFFF), no shadows."

---

## 3. 후처리 도구

### 3.1 배경 제거 (rembg)

투명 배경이 필요한 에셋(아이콘, 크롬 등)은 생성 결과에 배경이 섞인 경우 `rembg` 도구를 사용하여 알파 채널을 확보합니다.

- **필수 규칙**: 배경 제거 품질을 위해 원본 생성 시 배경은 반드시 **순백(#FFFFFF) 단색**이어야 합니다.
- **세부 가이드**: 모델 선택, 명령어 옵션, Alpha Matting 기준 등 상세 내용은 아래 가이드를 참조하십시오.
  - **참조**: `vibe/ref/rembg-guide.md` (배경 제거 도구 사용 가이드)

### 3.2 크기 조정 및 Crop (ImageMagick)

생성된 에셋의 사이즈 조정, 배율 변경, 여백 제거(trim), Crop 등은 `ImageMagick` 도구를 사용합니다.

- **일반적인 작업 흐름**: trim → resize → extent (캔버스 확장)
- **세부 가이드**: 크기 프리셋, 복합 작업 패턴, 주의사항 등 상세 내용은 아래 가이드를 참조하십시오.
  - **참조**: `vibe/ref/imagemagick-guide.md` (이미지 처리 도구 사용 가이드)

---

## 4. 에셋 반영 프로세스

1. **요청 기록**: `vibe/ref/nanobanana-asset-request.schema.json`에 맞게 에셋 사양 정의.
2. **에셋 생성**: `nanobanana mcp`와 위 템플릿을 사용하여 이미지 생성.
3. **배경 제거**: 필요한 경우 `rembg` 실행 (가이드: `vibe/ref/rembg-guide.md`).
4. **크기 조정**: 필요한 경우 `ImageMagick`으로 trim/resize/extent (가이드: `vibe/ref/imagemagick-guide.md`).
5. **경로 저장**: `frontend/public/ui/` 아래 카테고리별 폴더에 저장.
6. **매니페스트 갱신**: `manifest.json`에 에셋 정보 추가 (U-033).
7. **QA 체크**: 스타일 일관성 및 폴백(텍스트/이모지) 동작 확인.
</file>

<file path="vibe/ref/structured-outputs-guide.md">
<br />

You can configure Gemini models to generate responses that adhere to a provided JSON Schema. This capability guarantees predictable and parsable results, ensures format and type-safety, enables the programmatic detection of refusals, and simplifies prompting.

Using structured outputs is ideal for a wide range of applications:

- **Data extraction:**Pull specific information from unstructured text, like extracting names, dates, and amounts from an invoice.
- **Structured classification:**Classify text into predefined categories and assign structured labels, such as categorizing customer feedback by sentiment and topic.
- **Agentic workflows:**Generate structured data that can be used to call other tools or APIs, like creating a character sheet for a game or filling out a form.

In addition to supporting JSON Schema in the REST API, the Google GenAI SDKs for Python and JavaScript also make it easy to define object schemas using[Pydantic](https://docs.pydantic.dev/latest/)and[Zod](https://zod.dev/), respectively. The example below demonstrates how to extract information from unstructured text that conforms to a schema defined in code.

Recipe ExtractorContent ModerationRecursive Structures

This example demonstrates how to extract structured data from text using basic JSON Schema types like`object`,`array`,`string`, and`integer`.

### Python

    from google import genai
    from pydantic import BaseModel, Field
    from typing import List, Optional

    class Ingredient(BaseModel):
        name: str = Field(description="Name of the ingredient.")
        quantity: str = Field(description="Quantity of the ingredient, including units.")

    class Recipe(BaseModel):
        recipe_name: str = Field(description="The name of the recipe.")
        prep_time_minutes: Optional[int] = Field(description="Optional time in minutes to prepare the recipe.")
        ingredients: List[Ingredient]
        instructions: List[str]

    client = genai.Client()

    prompt = """
    Please extract the recipe from the following text.
    The user wants to make delicious chocolate chip cookies.
    They need 2 and 1/4 cups of all-purpose flour, 1 teaspoon of baking soda,
    1 teaspoon of salt, 1 cup of unsalted butter (softened), 3/4 cup of granulated sugar,
    3/4 cup of packed brown sugar, 1 teaspoon of vanilla extract, and 2 large eggs.
    For the best part, they'll need 2 cups of semisweet chocolate chips.
    First, preheat the oven to 375°F (190°C). Then, in a small bowl, whisk together the flour,
    baking soda, and salt. In a large bowl, cream together the butter, granulated sugar, and brown sugar
    until light and fluffy. Beat in the vanilla and eggs, one at a time. Gradually beat in the dry
    ingredients until just combined. Finally, stir in the chocolate chips. Drop by rounded tablespoons
    onto ungreased baking sheets and bake for 9 to 11 minutes.
    """

    response = client.models.generate_content(
        model="gemini-2.5-flash",
        contents=prompt,
        config={
            "response_mime_type": "application/json",
            "response_json_schema": Recipe.model_json_schema(),
        },
    )

    recipe = Recipe.model_validate_json(response.text)
    print(recipe)

### JavaScript

    import { GoogleGenAI } from "@google/genai";
    import { z } from "zod";
    import { zodToJsonSchema } from "zod-to-json-schema";

    const ingredientSchema = z.object({
      name: z.string().describe("Name of the ingredient."),
      quantity: z.string().describe("Quantity of the ingredient, including units."),
    });

    const recipeSchema = z.object({
      recipe_name: z.string().describe("The name of the recipe."),
      prep_time_minutes: z.number().optional().describe("Optional time in minutes to prepare the recipe."),
      ingredients: z.array(ingredientSchema),
      instructions: z.array(z.string()),
    });

    const ai = new GoogleGenAI({});

    const prompt = `
    Please extract the recipe from the following text.
    The user wants to make delicious chocolate chip cookies.
    They need 2 and 1/4 cups of all-purpose flour, 1 teaspoon of baking soda,
    1 teaspoon of salt, 1 cup of unsalted butter (softened), 3/4 cup of granulated sugar,
    3/4 cup of packed brown sugar, 1 teaspoon of vanilla extract, and 2 large eggs.
    For the best part, they'll need 2 cups of semisweet chocolate chips.
    First, preheat the oven to 375°F (190°C). Then, in a small bowl, whisk together the flour,
    baking soda, and salt. In a large bowl, cream together the butter, granulated sugar, and brown sugar
    until light and fluffy. Beat in the vanilla and eggs, one at a time. Gradually beat in the dry
    ingredients until just combined. Finally, stir in the chocolate chips. Drop by rounded tablespoons
    onto ungreased baking sheets and bake for 9 to 11 minutes.
    `;

    const response = await ai.models.generateContent({
      model: "gemini-2.5-flash",
      contents: prompt,
      config: {
        responseMimeType: "application/json",
        responseJsonSchema: zodToJsonSchema(recipeSchema),
      },
    });

    const recipe = recipeSchema.parse(JSON.parse(response.text));
    console.log(recipe);

### Go

    package main

    import (
        "context"
        "fmt"
        "log"

        "google.golang.org/genai"
    )

    func main() {
        ctx := context.Background()
        client, err := genai.NewClient(ctx, nil)
        if err != nil {
            log.Fatal(err)
        }

        prompt := `
      Please extract the recipe from the following text.
      The user wants to make delicious chocolate chip cookies.
      They need 2 and 1/4 cups of all-purpose flour, 1 teaspoon of baking soda,
      1 teaspoon of salt, 1 cup of unsalted butter (softened), 3/4 cup of granulated sugar,
      3/4 cup of packed brown sugar, 1 teaspoon of vanilla extract, and 2 large eggs.
      For the best part, they'll need 2 cups of semisweet chocolate chips.
      First, preheat the oven to 375°F (190°C). Then, in a small bowl, whisk together the flour,
      baking soda, and salt. In a large bowl, cream together the butter, granulated sugar, and brown sugar
      until light and fluffy. Beat in the vanilla and eggs, one at a time. Gradually beat in the dry
      ingredients until just combined. Finally, stir in the chocolate chips. Drop by rounded tablespoons
      onto ungreased baking sheets and bake for 9 to 11 minutes.
      `
        config := &genai.GenerateContentConfig{
            ResponseMIMEType: "application/json",
            ResponseJsonSchema: map[string]any{
                "type": "object",
                "properties": map[string]any{
                    "recipe_name": map[string]any{
                        "type":        "string",
                        "description": "The name of the recipe.",
                    },
                    "prep_time_minutes": map[string]any{
                        "type":        "integer",
                        "description": "Optional time in minutes to prepare the recipe.",
                    },
                    "ingredients": map[string]any{
                        "type": "array",
                        "items": map[string]any{
                            "type": "object",
                            "properties": map[string]any{
                                "name": map[string]any{
                                    "type":        "string",
                                    "description": "Name of the ingredient.",
                                },
                                "quantity": map[string]any{
                                    "type":        "string",
                                    "description": "Quantity of the ingredient, including units.",
                                },
                            },
                            "required": []string{"name", "quantity"},
                        },
                    },
                    "instructions": map[string]any{
                        "type":  "array",
                        "items": map[string]any{"type": "string"},
                    },
                },
                "required": []string{"recipe_name", "ingredients", "instructions"},
            },
        }

        result, err := client.Models.GenerateContent(
            ctx,
            "gemini-2.5-flash",
            genai.Text(prompt),
            config,
        )
        if err != nil {
            log.Fatal(err)
        }
        fmt.Println(result.Text())
    }

### REST

    curl "https://generativelanguage.googleapis.com/v1beta/models/gemini-2.5-flash:generateContent" \
        -H "x-goog-api-key: $GEMINI_API_KEY" \
        -H 'Content-Type: application/json' \
        -X POST \
        -d '{
          "contents": [{
            "parts":[
              { "text": "Please extract the recipe from the following text.\nThe user wants to make delicious chocolate chip cookies.\nThey need 2 and 1/4 cups of all-purpose flour, 1 teaspoon of baking soda,\n1 teaspoon of salt, 1 cup of unsalted butter (softened), 3/4 cup of granulated sugar,\n3/4 cup of packed brown sugar, 1 teaspoon of vanilla extract, and 2 large eggs.\nFor the best part, they will need 2 cups of semisweet chocolate chips.\nFirst, preheat the oven to 375°F (190°C). Then, in a small bowl, whisk together the flour,\nbaking soda, and salt. In a large bowl, cream together the butter, granulated sugar, and brown sugar\nuntil light and fluffy. Beat in the vanilla and eggs, one at a time. Gradually beat in the dry\ningredients until just combined. Finally, stir in the chocolate chips. Drop by rounded tablespoons\nonto ungreased baking sheets and bake for 9 to 11 minutes." }
            ]
          }],
          "generationConfig": {
            "responseMimeType": "application/json",
            "responseJsonSchema": {
              "type": "object",
              "properties": {
                "recipe_name": {
                  "type": "string",
                  "description": "The name of the recipe."
                },
                "prep_time_minutes": {
                    "type": "integer",
                    "description": "Optional time in minutes to prepare the recipe."
                },
                "ingredients": {
                  "type": "array",
                  "items": {
                    "type": "object",
                    "properties": {
                      "name": { "type": "string", "description": "Name of the ingredient."},
                      "quantity": { "type": "string", "description": "Quantity of the ingredient, including units."}
                    },
                    "required": ["name", "quantity"]
                  }
                },
                "instructions": {
                  "type": "array",
                  "items": { "type": "string" }
                }
              },
              "required": ["recipe_name", "ingredients", "instructions"]
            }
          }
        }'

**Example Response:**

    {
      "recipe_name": "Delicious Chocolate Chip Cookies",
      "ingredients": [
        {
          "name": "all-purpose flour",
          "quantity": "2 and 1/4 cups"
        },
        {
          "name": "baking soda",
          "quantity": "1 teaspoon"
        },
        {
          "name": "salt",
          "quantity": "1 teaspoon"
        },
        {
          "name": "unsalted butter (softened)",
          "quantity": "1 cup"
        },
        {
          "name": "granulated sugar",
          "quantity": "3/4 cup"
        },
        {
          "name": "packed brown sugar",
          "quantity": "3/4 cup"
        },
        {
          "name": "vanilla extract",
          "quantity": "1 teaspoon"
        },
        {
          "name": "large eggs",
          "quantity": "2"
        },
        {
          "name": "semisweet chocolate chips",
          "quantity": "2 cups"
        }
      ],
      "instructions": [
        "Preheat the oven to 375°F (190°C).",
        "In a small bowl, whisk together the flour, baking soda, and salt.",
        "In a large bowl, cream together the butter, granulated sugar, and brown sugar until light and fluffy.",
        "Beat in the vanilla and eggs, one at a time.",
        "Gradually beat in the dry ingredients until just combined.",
        "Stir in the chocolate chips.",
        "Drop by rounded tablespoons onto ungreased baking sheets and bake for 9 to 11 minutes."
      ]
    }

## Streaming

You can stream structured outputs, which allows you to start processing the response as it's being generated, without having to wait for the entire output to be complete. This can improve the perceived performance of your application.

The streamed chunks will be valid partial JSON strings, which can be concatenated to form the final, complete JSON object.

### Python

    from google import genai
    from pydantic import BaseModel, Field
    from typing import Literal

    class Feedback(BaseModel):
        sentiment: Literal["positive", "neutral", "negative"]
        summary: str

    client = genai.Client()
    prompt = "The new UI is incredibly intuitive and visually appealing. Great job. Add a very long summary to test streaming!"

    response_stream = client.models.generate_content_stream(
        model="gemini-2.5-flash",
        contents=prompt,
        config={
            "response_mime_type": "application/json",
            "response_json_schema": Feedback.model_json_schema(),
        },
    )

    for chunk in response_stream:
        print(chunk.candidates[0].content.parts[0].text)

### JavaScript

    import { GoogleGenAI } from "@google/genai";
    import { z } from "zod";
    import { zodToJsonSchema } from "zod-to-json-schema";

    const ai = new GoogleGenAI({});
    const prompt = "The new UI is incredibly intuitive and visually appealing. Great job! Add a very long summary to test streaming!";

    const feedbackSchema = z.object({
      sentiment: z.enum(["positive", "neutral", "negative"]),
      summary: z.string(),
    });

    const stream = await ai.models.generateContentStream({
      model: "gemini-2.5-flash",
      contents: prompt,
      config: {
        responseMimeType: "application/json",
        responseJsonSchema: zodToJsonSchema(feedbackSchema),
      },
    });

    for await (const chunk of stream) {
      console.log(chunk.candidates[0].content.parts[0].text)
    }

## Structured outputs with tools

| **Preview:** This is a feature available only for the Gemini 3 series models,`gemini-3-pro-preview`and`gemini-3-flash-preview`.

Gemini 3 lets you combine Structured Outputs with built-in tools, including[Grounding with Google Search](https://ai.google.dev/gemini-api/docs/google-search),[URL Context](https://ai.google.dev/gemini-api/docs/url-context), and[Code Execution](https://ai.google.dev/gemini-api/docs/code-execution).

### Python

    from google import genai
    from pydantic import BaseModel, Field
    from typing import List

    class MatchResult(BaseModel):
        winner: str = Field(description="The name of the winner.")
        final_match_score: str = Field(description="The final match score.")
        scorers: List[str] = Field(description="The name of the scorer.")

    client = genai.Client()

    response = client.models.generate_content(
        model="gemini-3-pro-preview",
        contents="Search for all details for the latest Euro.",
        config={
            "tools": [
                {"google_search": {}},
                {"url_context": {}}
            ],
            "response_mime_type": "application/json",
            "response_json_schema": MatchResult.model_json_schema(),
        },
    )

    result = MatchResult.model_validate_json(response.text)
    print(result)

### JavaScript

    import { GoogleGenAI } from "@google/genai";
    import { z } from "zod";
    import { zodToJsonSchema } from "zod-to-json-schema";

    const ai = new GoogleGenAI({});

    const matchSchema = z.object({
      winner: z.string().describe("The name of the winner."),
      final_match_score: z.string().describe("The final score."),
      scorers: z.array(z.string()).describe("The name of the scorer.")
    });

    async function run() {
      const response = await ai.models.generateContent({
        model: "gemini-3-pro-preview",
        contents: "Search for all details for the latest Euro.",
        config: {
          tools: [
            { googleSearch: {} },
            { urlContext: {} }
          ],
          responseMimeType: "application/json",
          responseJsonSchema: zodToJsonSchema(matchSchema),
        },
      });

      const match = matchSchema.parse(JSON.parse(response.text));
      console.log(match);
    }

    run();

### REST

    curl "https://generativelanguage.googleapis.com/v1beta/models/gemini-3-pro-preview:generateContent" \
      -H "x-goog-api-key: $GEMINI_API_KEY" \
      -H 'Content-Type: application/json' \
      -X POST \
      -d '{
        "contents": [{
          "parts": [{"text": "Search for all details for the latest Euro."}]
        }],
        "tools": [
          {"googleSearch": {}},
          {"urlContext": {}}
        ],
        "generationConfig": {
            "responseMimeType": "application/json",
            "responseJsonSchema": {
                "type": "object",
                "properties": {
                    "winner": {"type": "string", "description": "The name of the winner."},
                    "final_match_score": {"type": "string", "description": "The final score."},
                    "scorers": {
                        "type": "array",
                        "items": {"type": "string"},
                        "description": "The name of the scorer."
                    }
                },
                "required": ["winner", "final_match_score", "scorers"]
            }
        }
      }'

## JSON schema support

To generate a JSON object, set the`response_mime_type`in the generation configuration to`application/json`and provide a`response_json_schema`. The schema must be a valid[JSON Schema](https://json-schema.org/)that describes the desired output format.

The model will then generate a response that is a syntactically valid JSON string matching the provided schema. When using structured outputs, the model will produce outputs in the same order as the keys in the schema.

Gemini's structured output mode supports a subset of the[JSON Schema](https://json-schema.org)specification.

The following values of`type`are supported:

- **`string`**: For text.
- **`number`**: For floating-point numbers.
- **`integer`**: For whole numbers.
- **`boolean`**: For true/false values.
- **`object`**: For structured data with key-value pairs.
- **`array`**: For lists of items.
- **`null`** : To allow a property to be null, include`"null"`in the type array (e.g.,`{"type": ["string", "null"]}`).

These descriptive properties help guide the model:

- **`title`**: A short description of a property.
- **`description`**: A longer and more detailed description of a property.

### Type-specific properties

**For`object`values:**

- **`properties`**: An object where each key is a property name and each value is a schema for that property.
- **`required`**: An array of strings, listing which properties are mandatory.
- **`additionalProperties`** : Controls whether properties not listed in`properties`are allowed. Can be a boolean or a schema.

**For`string`values:**

- **`enum`**: Lists a specific set of possible strings for classification tasks.
- **`format`** : Specifies a syntax for the string, such as`date-time`,`date`,`time`.

**For`number`and`integer`values:**

- **`enum`**: Lists a specific set of possible numeric values.
- **`minimum`**: The minimum inclusive value.
- **`maximum`**: The maximum inclusive value.

**For`array`values:**

- **`items`**: Defines the schema for all items in the array.
- **`prefixItems`**: Defines a list of schemas for the first N items, allowing for tuple-like structures.
- **`minItems`**: The minimum number of items in the array.
- **`maxItems`**: The maximum number of items in the array.

## Model support

The following models support structured output:

| Model                  | Structured Outputs |
| ---------------------- | ------------------ |
| Gemini 3 Pro Preview   | ✔️                 |
| Gemini 3 Flash Preview | ✔️                 |
| Gemini 2.5 Pro         | ✔️                 |
| Gemini 2.5 Flash       | ✔️                 |
| Gemini 2.5 Flash-Lite  | ✔️                 |
| Gemini 2.0 Flash       | ✔️\*               |
| Gemini 2.0 Flash-Lite  | ✔️\*               |

_\* Note that Gemini 2.0 requires an explicit`propertyOrdering`list within the JSON input to define the preferred structure. You can find an example in this[cookbook](https://github.com/google-gemini/cookbook/blob/main/examples/Pdf_structured_outputs_on_invoices_and_forms.ipynb)._

## Structured outputs vs. function calling

Both structured outputs and function calling use JSON schemas, but they serve different purposes:

| Feature                | Primary Use Case                                                                                                                                                                   |
| ---------------------- | ---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |
| **Structured Outputs** | **Formatting the final response to the user.** Use this when you want the model's*answer*to be in a specific format (e.g., extracting data from a document to save to a database). |
| **Function Calling**   | **Taking action during the conversation.** Use this when the model needs to*ask you*to perform a task (e.g., "get current weather") before it can provide a final answer.          |

## Best practices

- **Clear descriptions:** Use the`description`field in your schema to provide clear instructions to the model about what each property represents. This is crucial for guiding the model's output.
- **Strong typing:** Use specific types (`integer`,`string`,`enum`) whenever possible. If a parameter has a limited set of valid values, use an`enum`.
- **Prompt engineering:**Clearly state in your prompt what you want the model to do. For example, "Extract the following information from the text..." or "Classify this feedback according to the provided schema...".
- **Validation:**While structured output guarantees syntactically correct JSON, it does not guarantee the values are semantically correct. Always validate the final output in your application code before using it.
- **Error handling:**Implement robust error handling in your application to gracefully manage cases where the model's output, while schema-compliant, may not meet your business logic requirements.

## Limitations

- **Schema subset:**Not all features of the JSON Schema specification are supported. The model ignores unsupported properties.
- **Schema complexity:**The API may reject very large or deeply nested schemas. If you encounter errors, try simplifying your schema by shortening property names, reducing nesting, or limiting the number of constraints.
</file>

<file path="vibe/ref/text-generate-guide.md">
<br />

The Gemini API can generate text output from various inputs, including text, images, video, and audio.

Here's a basic example that takes a single text input:

### Python

    from google import genai

    client = genai.Client()

    response = client.models.generate_content(
        model="gemini-2.5-flash",
        contents="How does AI work?"
    )
    print(response.text)

### JavaScript

    import { GoogleGenAI } from "@google/genai";

    const ai = new GoogleGenAI({});

    async function main() {
      const response = await ai.models.generateContent({
        model: "gemini-2.5-flash",
        contents: "How does AI work?",
      });
      console.log(response.text);
    }

    await main();

### Go

    package main

    import (
      "context"
      "fmt"
      "os"
      "google.golang.org/genai"
    )

    func main() {

      ctx := context.Background()
      client, err := genai.NewClient(ctx, nil)
      if err != nil {
          log.Fatal(err)
      }

      result, _ := client.Models.GenerateContent(
          ctx,
          "gemini-2.5-flash",
          genai.Text("Explain how AI works in a few words"),
          nil,
      )

      fmt.Println(result.Text())
    }

### Java

    import com.google.genai.Client;
    import com.google.genai.types.GenerateContentResponse;

    public class GenerateContentWithTextInput {
      public static void main(String[] args) {

        Client client = new Client();

        GenerateContentResponse response =
            client.models.generateContent("gemini-2.5-flash", "How does AI work?", null);

        System.out.println(response.text());
      }
    }

### REST

    curl "https://generativelanguage.googleapis.com/v1beta/models/gemini-2.5-flash:generateContent" \
      -H "x-goog-api-key: $GEMINI_API_KEY" \
      -H 'Content-Type: application/json' \
      -X POST \
      -d '{
        "contents": [
          {
            "parts": [
              {
                "text": "How does AI work?"
              }
            ]
          }
        ]
      }'

### Apps Script

    // See https://developers.google.com/apps-script/guides/properties
    // for instructions on how to set the API key.
    const apiKey = PropertiesService.getScriptProperties().getProperty('GEMINI_API_KEY');

    function main() {
      const payload = {
        contents: [
          {
            parts: [
              { text: 'How AI does work?' },
            ],
          },
        ],
      };

      const url = 'https://generativelanguage.googleapis.com/v1beta/models/gemini-2.5-flash:generateContent';
      const options = {
        method: 'POST',
        contentType: 'application/json',
        headers: {
          'x-goog-api-key': apiKey,
        },
        payload: JSON.stringify(payload)
      };

      const response = UrlFetchApp.fetch(url, options);
      const data = JSON.parse(response);
      const content = data['candidates'][0]['content']['parts'][0]['text'];
      console.log(content);
    }

## Thinking with Gemini

Gemini models often have["thinking"](https://ai.google.dev/gemini-api/docs/thinking)enabled by default which allows the model to reason before responding to a request.

Each model supports different thinking configurations which gives you control over cost, latency, and intelligence. For more details, see the[thinking guide](https://ai.google.dev/gemini-api/docs/thinking#set-budget).

### Python

    from google import genai
    from google.genai import types

    client = genai.Client()

    response = client.models.generate_content(
        model="gemini-2.5-flash",
        contents="How does AI work?",
        config=types.GenerateContentConfig(
            thinking_config=types.ThinkingConfig(thinking_budget=0) # Disables thinking
        ),
    )
    print(response.text)

### JavaScript

    import { GoogleGenAI } from "@google/genai";

    const ai = new GoogleGenAI({});

    async function main() {
      const response = await ai.models.generateContent({
        model: "gemini-2.5-flash",
        contents: "How does AI work?",
        config: {
          thinkingConfig: {
            thinkingBudget: 0, // Disables thinking
          },
        }
      });
      console.log(response.text);
    }

    await main();

### Go

    package main

    import (
      "context"
      "fmt"
      "os"
      "google.golang.org/genai"
    )

    func main() {

      ctx := context.Background()
      client, err := genai.NewClient(ctx, nil)
      if err != nil {
          log.Fatal(err)
      }

      result, _ := client.Models.GenerateContent(
          ctx,
          "gemini-2.5-flash",
          genai.Text("How does AI work?"),
          &genai.GenerateContentConfig{
            ThinkingConfig: &genai.ThinkingConfig{
                ThinkingBudget: int32(0), // Disables thinking
            },
          }
      )

      fmt.Println(result.Text())
    }

### Java

    import com.google.genai.Client;
    import com.google.genai.types.GenerateContentConfig;
    import com.google.genai.types.GenerateContentResponse;
    import com.google.genai.types.ThinkingConfig;

    public class GenerateContentWithThinkingConfig {
      public static void main(String[] args) {

        Client client = new Client();

        GenerateContentConfig config =
            GenerateContentConfig.builder()
                // Disables thinking
                .thinkingConfig(ThinkingConfig.builder().thinkingBudget(0))
                .build();

        GenerateContentResponse response =
            client.models.generateContent("gemini-2.5-flash", "How does AI work?", config);

        System.out.println(response.text());
      }
    }

### REST

    curl "https://generativelanguage.googleapis.com/v1beta/models/gemini-2.5-flash:generateContent" \
      -H "x-goog-api-key: $GEMINI_API_KEY" \
      -H 'Content-Type: application/json' \
      -X POST \
      -d '{
        "contents": [
          {
            "parts": [
              {
                "text": "How does AI work?"
              }
            ]
          }
        ],
        "generationConfig": {
          "thinkingConfig": {
            "thinkingBudget": 0
          }
        }
      }'

### Apps Script

    // See https://developers.google.com/apps-script/guides/properties
    // for instructions on how to set the API key.
    const apiKey = PropertiesService.getScriptProperties().getProperty('GEMINI_API_KEY');

    function main() {
      const payload = {
        contents: [
          {
            parts: [
              { text: 'How AI does work?' },
            ],
          },
        ],
      };

      const url = 'https://generativelanguage.googleapis.com/v1beta/models/gemini-2.5-flash:generateContent';
      const options = {
        method: 'POST',
        contentType: 'application/json',
        headers: {
          'x-goog-api-key': apiKey,
        },
        payload: JSON.stringify(payload)
      };

      const response = UrlFetchApp.fetch(url, options);
      const data = JSON.parse(response);
      const content = data['candidates'][0]['content']['parts'][0]['text'];
      console.log(content);
    }

## System instructions and other configurations

You can guide the behavior of Gemini models with system instructions. To do so, pass a[`GenerateContentConfig`](https://ai.google.dev/api/generate-content#v1beta.GenerationConfig)object.

### Python

    from google import genai
    from google.genai import types

    client = genai.Client()

    response = client.models.generate_content(
        model="gemini-2.5-flash",
        config=types.GenerateContentConfig(
            system_instruction="You are a cat. Your name is Neko."),
        contents="Hello there"
    )

    print(response.text)

### JavaScript

    import { GoogleGenAI } from "@google/genai";

    const ai = new GoogleGenAI({});

    async function main() {
      const response = await ai.models.generateContent({
        model: "gemini-2.5-flash",
        contents: "Hello there",
        config: {
          systemInstruction: "You are a cat. Your name is Neko.",
        },
      });
      console.log(response.text);
    }

    await main();

### Go

    package main

    import (
      "context"
      "fmt"
      "os"
      "google.golang.org/genai"
    )

    func main() {

      ctx := context.Background()
      client, err := genai.NewClient(ctx, nil)
      if err != nil {
          log.Fatal(err)
      }

      config := &genai.GenerateContentConfig{
          SystemInstruction: genai.NewContentFromText("You are a cat. Your name is Neko.", genai.RoleUser),
      }

      result, _ := client.Models.GenerateContent(
          ctx,
          "gemini-2.5-flash",
          genai.Text("Hello there"),
          config,
      )

      fmt.Println(result.Text())
    }

### Java

    import com.google.genai.Client;
    import com.google.genai.types.Content;
    import com.google.genai.types.GenerateContentConfig;
    import com.google.genai.types.GenerateContentResponse;
    import com.google.genai.types.Part;

    public class GenerateContentWithSystemInstruction {
      public static void main(String[] args) {

        Client client = new Client();

        GenerateContentConfig config =
            GenerateContentConfig.builder()
                .systemInstruction(
                    Content.fromParts(Part.fromText("You are a cat. Your name is Neko.")))
                .build();

        GenerateContentResponse response =
            client.models.generateContent("gemini-2.5-flash", "Hello there", config);

        System.out.println(response.text());
      }
    }

### REST

    curl "https://generativelanguage.googleapis.com/v1beta/models/gemini-2.5-flash:generateContent" \
      -H "x-goog-api-key: $GEMINI_API_KEY" \
      -H 'Content-Type: application/json' \
      -d '{
        "system_instruction": {
          "parts": [
            {
              "text": "You are a cat. Your name is Neko."
            }
          ]
        },
        "contents": [
          {
            "parts": [
              {
                "text": "Hello there"
              }
            ]
          }
        ]
      }'

### Apps Script

    // See https://developers.google.com/apps-script/guides/properties
    // for instructions on how to set the API key.
    const apiKey = PropertiesService.getScriptProperties().getProperty('GEMINI_API_KEY');

    function main() {
      const systemInstruction = {
        parts: [{
          text: 'You are a cat. Your name is Neko.'
        }]
      };

      const payload = {
        systemInstruction,
        contents: [
          {
            parts: [
              { text: 'Hello there' },
            ],
          },
        ],
      };

      const url = 'https://generativelanguage.googleapis.com/v1beta/models/gemini-2.5-flash:generateContent';
      const options = {
        method: 'POST',
        contentType: 'application/json',
        headers: {
          'x-goog-api-key': apiKey,
        },
        payload: JSON.stringify(payload)
      };

      const response = UrlFetchApp.fetch(url, options);
      const data = JSON.parse(response);
      const content = data['candidates'][0]['content']['parts'][0]['text'];
      console.log(content);
    }

The[`GenerateContentConfig`](https://ai.google.dev/api/generate-content#v1beta.GenerationConfig)object also lets you override default generation parameters, such as[temperature](https://ai.google.dev/api/generate-content#v1beta.GenerationConfig).
When using Gemini 3 models, we strongly recommend keeping the`temperature`at its default value of 1.0. Changing the temperature (setting it below 1.0) may lead to unexpected behavior, such as looping or degraded performance, particularly in complex mathematical or reasoning tasks.

### Python

    from google import genai
    from google.genai import types

    client = genai.Client()

    response = client.models.generate_content(
        model="gemini-2.5-flash",
        contents=["Explain how AI works"],
        config=types.GenerateContentConfig(
            temperature=0.1
        )
    )
    print(response.text)

### JavaScript

    import { GoogleGenAI } from "@google/genai";

    const ai = new GoogleGenAI({});

    async function main() {
      const response = await ai.models.generateContent({
        model: "gemini-2.5-flash",
        contents: "Explain how AI works",
        config: {
          temperature: 0.1,
        },
      });
      console.log(response.text);
    }

    await main();

### Go

    package main

    import (
      "context"
      "fmt"
      "os"
      "google.golang.org/genai"
    )

    func main() {

      ctx := context.Background()
      client, err := genai.NewClient(ctx, nil)
      if err != nil {
          log.Fatal(err)
      }

      temp := float32(0.9)
      topP := float32(0.5)
      topK := float32(20.0)

      config := &genai.GenerateContentConfig{
        Temperature:       &temp,
        TopP:              &topP,
        TopK:              &topK,
        ResponseMIMEType:  "application/json",
      }

      result, _ := client.Models.GenerateContent(
        ctx,
        "gemini-2.5-flash",
        genai.Text("What is the average size of a swallow?"),
        config,
      )

      fmt.Println(result.Text())
    }

### Java

    import com.google.genai.Client;
    import com.google.genai.types.GenerateContentConfig;
    import com.google.genai.types.GenerateContentResponse;

    public class GenerateContentWithConfig {
      public static void main(String[] args) {

        Client client = new Client();

        GenerateContentConfig config = GenerateContentConfig.builder().temperature(0.1f).build();

        GenerateContentResponse response =
            client.models.generateContent("gemini-2.5-flash", "Explain how AI works", config);

        System.out.println(response.text());
      }
    }

### REST

    curl https://generativelanguage.googleapis.com/v1beta/models/gemini-2.5-flash:generateContent \
      -H "x-goog-api-key: $GEMINI_API_KEY" \
      -H 'Content-Type: application/json' \
      -X POST \
      -d '{
        "contents": [
          {
            "parts": [
              {
                "text": "Explain how AI works"
              }
            ]
          }
        ],
        "generationConfig": {
          "stopSequences": [
            "Title"
          ],
          "temperature": 1.0,
          "topP": 0.8,
          "topK": 10
        }
      }'

### Apps Script

    // See https://developers.google.com/apps-script/guides/properties
    // for instructions on how to set the API key.
    const apiKey = PropertiesService.getScriptProperties().getProperty('GEMINI_API_KEY');

    function main() {
      const generationConfig = {
        temperature: 1,
        topP: 0.95,
        topK: 40,
        responseMimeType: 'text/plain',
      };

      const payload = {
        generationConfig,
        contents: [
          {
            parts: [
              { text: 'Explain how AI works in a few words' },
            ],
          },
        ],
      };

      const url = 'https://generativelanguage.googleapis.com/v1beta/models/gemini-2.5-flash:generateContent';
      const options = {
        method: 'POST',
        contentType: 'application/json',
        headers: {
          'x-goog-api-key': apiKey,
        },
        payload: JSON.stringify(payload)
      };

      const response = UrlFetchApp.fetch(url, options);
      const data = JSON.parse(response);
      const content = data['candidates'][0]['content']['parts'][0]['text'];
      console.log(content);
    }

Refer to the[`GenerateContentConfig`](https://ai.google.dev/api/generate-content#v1beta.GenerationConfig)in our API reference for a complete list of configurable parameters and their descriptions.

## Multimodal inputs

The Gemini API supports multimodal inputs, allowing you to combine text with media files. The following example demonstrates providing an image:

### Python

    from PIL import Image
    from google import genai

    client = genai.Client()

    image = Image.open("/path/to/organ.png")
    response = client.models.generate_content(
        model="gemini-2.5-flash",
        contents=[image, "Tell me about this instrument"]
    )
    print(response.text)

### JavaScript

    import {
      GoogleGenAI,
      createUserContent,
      createPartFromUri,
    } from "@google/genai";

    const ai = new GoogleGenAI({});

    async function main() {
      const image = await ai.files.upload({
        file: "/path/to/organ.png",
      });
      const response = await ai.models.generateContent({
        model: "gemini-2.5-flash",
        contents: [
          createUserContent([
            "Tell me about this instrument",
            createPartFromUri(image.uri, image.mimeType),
          ]),
        ],
      });
      console.log(response.text);
    }

    await main();

### Go

    package main

    import (
      "context"
      "fmt"
      "os"
      "google.golang.org/genai"
    )

    func main() {

      ctx := context.Background()
      client, err := genai.NewClient(ctx, nil)
      if err != nil {
          log.Fatal(err)
      }

      imagePath := "/path/to/organ.jpg"
      imgData, _ := os.ReadFile(imagePath)

      parts := []*genai.Part{
          genai.NewPartFromText("Tell me about this instrument"),
          &genai.Part{
              InlineData: &genai.Blob{
                  MIMEType: "image/jpeg",
                  Data:     imgData,
              },
          },
      }

      contents := []*genai.Content{
          genai.NewContentFromParts(parts, genai.RoleUser),
      }

      result, _ := client.Models.GenerateContent(
          ctx,
          "gemini-2.5-flash",
          contents,
          nil,
      )

      fmt.Println(result.Text())
    }

### Java

    import com.google.genai.Client;
    import com.google.genai.Content;
    import com.google.genai.types.GenerateContentResponse;
    import com.google.genai.types.Part;

    public class GenerateContentWithMultiModalInputs {
      public static void main(String[] args) {

        Client client = new Client();

        Content content =
          Content.fromParts(
              Part.fromText("Tell me about this instrument"),
              Part.fromUri("/path/to/organ.jpg", "image/jpeg"));

        GenerateContentResponse response =
            client.models.generateContent("gemini-2.5-flash", content, null);

        System.out.println(response.text());
      }
    }

### REST

    # Use a temporary file to hold the base64 encoded image data
    TEMP_B64=$(mktemp)
    trap 'rm -f "$TEMP_B64"' EXIT
    base64 $B64FLAGS $IMG_PATH > "$TEMP_B64"

    # Use a temporary file to hold the JSON payload
    TEMP_JSON=$(mktemp)
    trap 'rm -f "$TEMP_JSON"' EXIT

    cat > "$TEMP_JSON" << EOF
    {
      "contents": [
        {
          "parts": [
            {
              "text": "Tell me about this instrument"
            },
            {
              "inline_data": {
                "mime_type": "image/jpeg",
                "data": "$(cat "$TEMP_B64")"
              }
            }
          ]
        }
      ]
    }
    EOF

    curl "https://generativelanguage.googleapis.com/v1beta/models/gemini-2.5-flash:generateContent" \
      -H "x-goog-api-key: $GEMINI_API_KEY" \
      -H 'Content-Type: application/json' \
      -X POST \
      -d "@$TEMP_JSON"

### Apps Script

    // See https://developers.google.com/apps-script/guides/properties
    // for instructions on how to set the API key.
    const apiKey = PropertiesService.getScriptProperties().getProperty('GEMINI_API_KEY');

    function main() {
      const imageUrl = 'http://image/url';
      const image = getImageData(imageUrl);
      const payload = {
        contents: [
          {
            parts: [
              { image },
              { text: 'Tell me about this instrument' },
            ],
          },
        ],
      };

      const url = 'https://generativelanguage.googleapis.com/v1beta/models/gemini-2.5-flash:generateContent';
      const options = {
        method: 'POST',
        contentType: 'application/json',
        headers: {
          'x-goog-api-key': apiKey,
        },
        payload: JSON.stringify(payload)
      };

      const response = UrlFetchApp.fetch(url, options);
      const data = JSON.parse(response);
      const content = data['candidates'][0]['content']['parts'][0]['text'];
      console.log(content);
    }

    function getImageData(url) {
      const blob = UrlFetchApp.fetch(url).getBlob();

      return {
        mimeType: blob.getContentType(),
        data: Utilities.base64Encode(blob.getBytes())
      };
    }

For alternative methods of providing images and more advanced image processing, see our[image understanding guide](https://ai.google.dev/gemini-api/docs/image-understanding). The API also supports[document](https://ai.google.dev/gemini-api/docs/document-processing),[video](https://ai.google.dev/gemini-api/docs/video-understanding), and[audio](https://ai.google.dev/gemini-api/docs/audio)inputs and understanding.

## Streaming responses

By default, the model returns a response only after the entire generation process is complete.

For more fluid interactions, use streaming to receive[`GenerateContentResponse`](https://ai.google.dev/api/generate-content#v1beta.GenerateContentResponse)instances incrementally as they're generated.

### Python

    from google import genai

    client = genai.Client()

    response = client.models.generate_content_stream(
        model="gemini-2.5-flash",
        contents=["Explain how AI works"]
    )
    for chunk in response:
        print(chunk.text, end="")

### JavaScript

    import { GoogleGenAI } from "@google/genai";

    const ai = new GoogleGenAI({});

    async function main() {
      const response = await ai.models.generateContentStream({
        model: "gemini-2.5-flash",
        contents: "Explain how AI works",
      });

      for await (const chunk of response) {
        console.log(chunk.text);
      }
    }

    await main();

### Go

    package main

    import (
      "context"
      "fmt"
      "os"
      "google.golang.org/genai"
    )

    func main() {

      ctx := context.Background()
      client, err := genai.NewClient(ctx, nil)
      if err != nil {
          log.Fatal(err)
      }

      stream := client.Models.GenerateContentStream(
          ctx,
          "gemini-2.5-flash",
          genai.Text("Write a story about a magic backpack."),
          nil,
      )

      for chunk, _ := range stream {
          part := chunk.Candidates[0].Content.Parts[0]
          fmt.Print(part.Text)
      }
    }

### Java

    import com.google.genai.Client;
    import com.google.genai.ResponseStream;
    import com.google.genai.types.GenerateContentResponse;

    public class GenerateContentStream {
      public static void main(String[] args) {

        Client client = new Client();

        ResponseStream<GenerateContentResponse> responseStream =
          client.models.generateContentStream(
              "gemini-2.5-flash", "Write a story about a magic backpack.", null);

        for (GenerateContentResponse res : responseStream) {
          System.out.print(res.text());
        }

        // To save resources and avoid connection leaks, it is recommended to close the response
        // stream after consumption (or using try block to get the response stream).
        responseStream.close();
      }
    }

### REST

    curl "https://generativelanguage.googleapis.com/v1beta/models/gemini-2.5-flash:streamGenerateContent?alt=sse" \
      -H "x-goog-api-key: $GEMINI_API_KEY" \
      -H 'Content-Type: application/json' \
      --no-buffer \
      -d '{
        "contents": [
          {
            "parts": [
              {
                "text": "Explain how AI works"
              }
            ]
          }
        ]
      }'

### Apps Script

    // See https://developers.google.com/apps-script/guides/properties
    // for instructions on how to set the API key.
    const apiKey = PropertiesService.getScriptProperties().getProperty('GEMINI_API_KEY');

    function main() {
      const payload = {
        contents: [
          {
            parts: [
              { text: 'Explain how AI works' },
            ],
          },
        ],
      };

      const url = 'https://generativelanguage.googleapis.com/v1beta/models/gemini-2.5-flash:streamGenerateContent';
      const options = {
        method: 'POST',
        contentType: 'application/json',
        headers: {
          'x-goog-api-key': apiKey,
        },
        payload: JSON.stringify(payload)
      };

      const response = UrlFetchApp.fetch(url, options);
      const data = JSON.parse(response);
      const content = data['candidates'][0]['content']['parts'][0]['text'];
      console.log(content);
    }

## Multi-turn conversations (chat)

Our SDKs provide functionality to collect multiple rounds of prompts and responses into a chat, giving you an easy way to keep track of the conversation history.
**Note:** Chat functionality is only implemented as part of the SDKs. Behind the scenes, it still uses the[`generateContent`](https://ai.google.dev/api/generate-content#method:-models.generatecontent)API. For multi-turn conversations, the full conversation history is sent to the model with each follow-up turn.

### Python

    from google import genai

    client = genai.Client()
    chat = client.chats.create(model="gemini-2.5-flash")

    response = chat.send_message("I have 2 dogs in my house.")
    print(response.text)

    response = chat.send_message("How many paws are in my house?")
    print(response.text)

    for message in chat.get_history():
        print(f'role - {message.role}',end=": ")
        print(message.parts[0].text)

### JavaScript

    import { GoogleGenAI } from "@google/genai";

    const ai = new GoogleGenAI({});

    async function main() {
      const chat = ai.chats.create({
        model: "gemini-2.5-flash",
        history: [
          {
            role: "user",
            parts: [{ text: "Hello" }],
          },
          {
            role: "model",
            parts: [{ text: "Great to meet you. What would you like to know?" }],
          },
        ],
      });

      const response1 = await chat.sendMessage({
        message: "I have 2 dogs in my house.",
      });
      console.log("Chat response 1:", response1.text);

      const response2 = await chat.sendMessage({
        message: "How many paws are in my house?",
      });
      console.log("Chat response 2:", response2.text);
    }

    await main();

### Go

    package main

    import (
      "context"
      "fmt"
      "os"
      "google.golang.org/genai"
    )

    func main() {

      ctx := context.Background()
      client, err := genai.NewClient(ctx, nil)
      if err != nil {
          log.Fatal(err)
      }

      history := []*genai.Content{
          genai.NewContentFromText("Hi nice to meet you! I have 2 dogs in my house.", genai.RoleUser),
          genai.NewContentFromText("Great to meet you. What would you like to know?", genai.RoleModel),
      }

      chat, _ := client.Chats.Create(ctx, "gemini-2.5-flash", nil, history)
      res, _ := chat.SendMessage(ctx, genai.Part{Text: "How many paws are in my house?"})

      if len(res.Candidates) > 0 {
          fmt.Println(res.Candidates[0].Content.Parts[0].Text)
      }
    }

### Java

    import com.google.genai.Chat;
    import com.google.genai.Client;
    import com.google.genai.types.Content;
    import com.google.genai.types.GenerateContentResponse;

    public class MultiTurnConversation {
      public static void main(String[] args) {

        Client client = new Client();
        Chat chatSession = client.chats.create("gemini-2.5-flash");

        GenerateContentResponse response =
            chatSession.sendMessage("I have 2 dogs in my house.");
        System.out.println("First response: " + response.text());

        response = chatSession.sendMessage("How many paws are in my house?");
        System.out.println("Second response: " + response.text());

        // Get the history of the chat session.
        // Passing 'true' to getHistory() returns the curated history, which excludes
        // empty or invalid parts.
        // Passing 'false' here would return the comprehensive history, including
        // empty or invalid parts.
        ImmutableList<Content> history = chatSession.getHistory(true);
        System.out.println("History: " + history);
      }
    }

### REST

    curl https://generativelanguage.googleapis.com/v1beta/models/gemini-2.5-flash:generateContent \
      -H "x-goog-api-key: $GEMINI_API_KEY" \
      -H 'Content-Type: application/json' \
      -X POST \
      -d '{
        "contents": [
          {
            "role": "user",
            "parts": [
              {
                "text": "Hello"
              }
            ]
          },
          {
            "role": "model",
            "parts": [
              {
                "text": "Great to meet you. What would you like to know?"
              }
            ]
          },
          {
            "role": "user",
            "parts": [
              {
                "text": "I have two dogs in my house. How many paws are in my house?"
              }
            ]
          }
        ]
      }'

### Apps Script

    // See https://developers.google.com/apps-script/guides/properties
    // for instructions on how to set the API key.
    const apiKey = PropertiesService.getScriptProperties().getProperty('GEMINI_API_KEY');

    function main() {
      const payload = {
        contents: [
          {
            role: 'user',
            parts: [
              { text: 'Hello' },
            ],
          },
          {
            role: 'model',
            parts: [
              { text: 'Great to meet you. What would you like to know?' },
            ],
          },
          {
            role: 'user',
            parts: [
              { text: 'I have two dogs in my house. How many paws are in my house?' },
            ],
          },
        ],
      };

      const url = 'https://generativelanguage.googleapis.com/v1beta/models/gemini-2.5-flash:generateContent';
      const options = {
        method: 'POST',
        contentType: 'application/json',
        headers: {
          'x-goog-api-key': apiKey,
        },
        payload: JSON.stringify(payload)
      };

      const response = UrlFetchApp.fetch(url, options);
      const data = JSON.parse(response);
      const content = data['candidates'][0]['content']['parts'][0]['text'];
      console.log(content);
    }

Streaming can also be used for multi-turn conversations.

### Python

    from google import genai

    client = genai.Client()
    chat = client.chats.create(model="gemini-2.5-flash")

    response = chat.send_message_stream("I have 2 dogs in my house.")
    for chunk in response:
        print(chunk.text, end="")

    response = chat.send_message_stream("How many paws are in my house?")
    for chunk in response:
        print(chunk.text, end="")

    for message in chat.get_history():
        print(f'role - {message.role}', end=": ")
        print(message.parts[0].text)

### JavaScript

    import { GoogleGenAI } from "@google/genai";

    const ai = new GoogleGenAI({});

    async function main() {
      const chat = ai.chats.create({
        model: "gemini-2.5-flash",
        history: [
          {
            role: "user",
            parts: [{ text: "Hello" }],
          },
          {
            role: "model",
            parts: [{ text: "Great to meet you. What would you like to know?" }],
          },
        ],
      });

      const stream1 = await chat.sendMessageStream({
        message: "I have 2 dogs in my house.",
      });
      for await (const chunk of stream1) {
        console.log(chunk.text);
        console.log("_".repeat(80));
      }

      const stream2 = await chat.sendMessageStream({
        message: "How many paws are in my house?",
      });
      for await (const chunk of stream2) {
        console.log(chunk.text);
        console.log("_".repeat(80));
      }
    }

    await main();

### Go

    package main

    import (
      "context"
      "fmt"
      "os"
      "google.golang.org/genai"
    )

    func main() {

      ctx := context.Background()
      client, err := genai.NewClient(ctx, nil)
      if err != nil {
          log.Fatal(err)
      }

      history := []*genai.Content{
          genai.NewContentFromText("Hi nice to meet you! I have 2 dogs in my house.", genai.RoleUser),
          genai.NewContentFromText("Great to meet you. What would you like to know?", genai.RoleModel),
      }

      chat, _ := client.Chats.Create(ctx, "gemini-2.5-flash", nil, history)
      stream := chat.SendMessageStream(ctx, genai.Part{Text: "How many paws are in my house?"})

      for chunk, _ := range stream {
          part := chunk.Candidates[0].Content.Parts[0]
          fmt.Print(part.Text)
      }
    }

### Java

    import com.google.genai.Chat;
    import com.google.genai.Client;
    import com.google.genai.ResponseStream;
    import com.google.genai.types.GenerateContentResponse;

    public class MultiTurnConversationWithStreaming {
      public static void main(String[] args) {

        Client client = new Client();
        Chat chatSession = client.chats.create("gemini-2.5-flash");

        ResponseStream<GenerateContentResponse> responseStream =
            chatSession.sendMessageStream("I have 2 dogs in my house.", null);

        for (GenerateContentResponse response : responseStream) {
          System.out.print(response.text());
        }

        responseStream = chatSession.sendMessageStream("How many paws are in my house?", null);

        for (GenerateContentResponse response : responseStream) {
          System.out.print(response.text());
        }

        // Get the history of the chat session. History is added after the stream
        // is consumed and includes the aggregated response from the stream.
        System.out.println("History: " + chatSession.getHistory(false));
      }
    }

### REST

    curl https://generativelanguage.googleapis.com/v1beta/models/gemini-2.5-flash:streamGenerateContent?alt=sse \
      -H "x-goog-api-key: $GEMINI_API_KEY" \
      -H 'Content-Type: application/json' \
      -X POST \
      -d '{
        "contents": [
          {
            "role": "user",
            "parts": [
              {
                "text": "Hello"
              }
            ]
          },
          {
            "role": "model",
            "parts": [
              {
                "text": "Great to meet you. What would you like to know?"
              }
            ]
          },
          {
            "role": "user",
            "parts": [
              {
                "text": "I have two dogs in my house. How many paws are in my house?"
              }
            ]
          }
        ]
      }'

### Apps Script

    // See https://developers.google.com/apps-script/guides/properties
    // for instructions on how to set the API key.
    const apiKey = PropertiesService.getScriptProperties().getProperty('GEMINI_API_KEY');

    function main() {
      const payload = {
        contents: [
          {
            role: 'user',
            parts: [
              { text: 'Hello' },
            ],
          },
          {
            role: 'model',
            parts: [
              { text: 'Great to meet you. What would you like to know?' },
            ],
          },
          {
            role: 'user',
            parts: [
              { text: 'I have two dogs in my house. How many paws are in my house?' },
            ],
          },
        ],
      };

      const url = 'https://generativelanguage.googleapis.com/v1beta/models/gemini-2.5-flash:streamGenerateContent';
      const options = {
        method: 'POST',
        contentType: 'application/json',
        headers: {
          'x-goog-api-key': apiKey,
        },
        payload: JSON.stringify(payload)
      };

      const response = UrlFetchApp.fetch(url, options);
      const data = JSON.parse(response);
      const content = data['candidates'][0]['content']['parts'][0]['text'];
      console.log(content);
    }

## Prompting tips

Consult our[prompt engineering guide](https://ai.google.dev/gemini/docs/prompting-strategies)for suggestions on getting the most out of Gemini.

## What's next

- Try[Gemini in Google AI Studio](https://aistudio.google.com).
- Experiment with[structured outputs](https://ai.google.dev/gemini-api/docs/structured-output)for JSON-like responses.
- Explore Gemini's[image](https://ai.google.dev/gemini-api/docs/image-understanding),[video](https://ai.google.dev/gemini-api/docs/video-understanding),[audio](https://ai.google.dev/gemini-api/docs/audio)and[document](https://ai.google.dev/gemini-api/docs/document-processing)understanding capabilities.
- Learn about multimodal[file prompting strategies](https://ai.google.dev/gemini-api/docs/files#prompt-guide).
</file>

<file path="vibe/unit-plans/CP-MMP-02.md">
# CP-MMP-02: 체크포인트 - 시나리오 회귀 100%

## 메타데이터

| 항목      | 내용              |
| --------- | ----------------- |
| Unit ID   | CP-MMP-02         |
| Phase     | MMP               |
| 예상 소요 | 60분              |
| 의존성    | RU-011[Mmp],U-107 |
| 우선순위  | ⚡ Critical       |

## 작업 목표

Scenario Library를 기준으로 “대표 시나리오 회귀 100% 통과”를 달성하고, Hard Gate 인바리언트가 배포/운영 수준에서도 깨지지 않음을 증명한다.

**배경**: MMP는 품질/운영 관점에서 회귀를 자동으로 잡을 수 있어야 하며, 특히 스키마/경제/안전/일관성은 항상 통과해야 한다. (PRD 10.3/10.5)

**완료 기준**:

- 대표 시나리오 5개(U-105)가 모두 통과한다(예외 없이 pass).
- 실패가 발생하면 즉시 원인(시나리오/턴/인바리언트)을 기록하고, 복구/수정 후 다시 100% 통과를 확인한다.
- 결과 리포트가 아티팩트로 남는다(프롬프트 원문/CoT 비노출). (RULE-008)

## 영향받는 파일

**생성**:

- `vibe/unit-runbooks/CP-MMP-02.md` - 회귀 실행/해석 런북
- `vibe/unit-results/CP-MMP-02.md` - 결과(pass/fail, 실패 원인, 측정값)

**수정**:

- 없음(검증 단계, 필요 시 결함 수정 유닛을 추가로 생성할 수 있음)

**참조**:

- `vibe/prd.md` 10.3/10.5 - Replay/Hard gate 요구
- `.cursor/rules/00-core-critical.mdc` - RULE-003/004/005/006/008/009

## 구현 흐름

### 1단계: 자동 러너 실행(로컬/배포 중 1)

- 자동 러너(U-105)로 시나리오 5개를 실행한다.
- 각 시나리오별 pass/fail와 첫 실패 지점을 기록한다.

### 2단계: 실패 분석/수정 루프

- 실패 시 인바리언트 종류로 분류한다:
  - Schema/Economy/Safety/Consistency
- 수정은 원인 유닛에서 수행하고, 다시 전체 시나리오를 재실행한다.

### 3단계: 결과 아티팩트 정리

- 100% 통과 결과 리포트를 남기고, CP 문서에 링크/요약을 기록한다.

## 의존성 & 연결

**이전 작업에서 가져올 것**:

- **계획서**: [U-105[Mmp]](U-105[Mmp].md) - Scenario Library/자동 리플레이
- **계획서**: [RU-011[Mmp]](RU-011[Mmp].md) - Autopilot/Replay 모듈 정리
- **계획서**: [U-107[Mmp]](U-107[Mmp].md) - UI 품질(모바일/접근성) 개선

**다음 작업에 전달할 것**:

- 운영/데모에서 “회귀 100% 통과”를 지속적으로 유지하는 품질 게이트

## 주의사항

**기술적 고려사항**:

- (RULE-004) 복구 실패 시에도 폴백으로 종료되어야 하며, 회귀에서 “멈춤”이 없어야 한다.
- (RULE-008) 어떤 리포트/로그에도 프롬프트 원문/내부 추론을 남기지 않는다.

**잠재적 리스크**:

- 비결정성으로 텍스트 결과는 달라질 수 있음 → 인바리언트 위주로 pass/fail를 결정하고, 텍스트 비교는 지양한다.

## 페어링 질문 (결정 필요)

- [ ] **Q1**: 회귀 실행 환경은 어디를 기준으로 할까?
  - Option A: 로컬 컨테이너(U-100) 기준(권장: 반복 속도)
  - Option B: 배포 환경(Cloud Run) 기준(신뢰도↑, 실행 비용↑)

## 참고 자료

- `vibe/prd.md` - Replay/Hard gate 품질 게이트
- `.cursor/rules/00-core-critical.mdc` - RULE-003~005, RULE-008
</file>

<file path="vibe/unit-plans/CP-MVP-02.md">
# CP-MVP-02: 체크포인트 - 클릭+드래그 데모

## 메타데이터

| 항목      | 내용        |
| --------- | ----------- |
| Unit ID   | CP-MVP-02   |
| Phase     | MVP         |
| 예상 소요 | 45분        |
| 의존성    | RU-003[Mvp] |
| 우선순위  | ⚡ Critical |

## 작업 목표

데모 표면의 핵심 조작 2종(핫스팟 클릭, 인벤토리 드래그&드롭)과 Action Deck 클릭이 “게임처럼” 동작하는지 수동 검증한다.

**배경**: PRD는 채팅이 아니라 “조작(클릭+드래그+업로드)”을 보여줘야 한다고 명시한다. (PRD 6.7)

**완료 기준**:

- Action Deck 카드 클릭 → 턴 실행 → 로그/패널 변화가 발생한다.
- 핫스팟 클릭 → 턴 실행 → 결과가 로그/패널에 반영된다.
- 아이템 드래그→핫스팟 드롭 → 턴 실행 → 성공/실패 피드백이 즉시 표시된다(무반응 금지).

## 영향받는 파일

**생성**:

- (구현 후 기록) `vibe/unit-results/CP-MVP-02.md` - 체크포인트 결과/관측값 기록
- (선택) `vibe/unit-runbooks/CP-MVP-02.md` - 재현 가능한 수동 검증 런북

**수정**:

- 없음(검증 단계)

**참조**:

- `vibe/prd.md` 6.7/9장 - 클릭/드래그 데모 표면 요구
- `.cursor/rules/10-frontend-game-ui.mdc` - Action Deck/DnD/Hotspot 규칙
- `.cursor/rules/00-core-critical.mdc` - RULE-002/008/009

## 구현 흐름

### 1단계: 클릭 데모(액션덱/핫스팟)

- 카드 1장을 클릭해 turn 실행 → Queue/Badges 진행과 final 반영을 확인한다.
- 핫스팟 1개를 클릭해 turn 실행 → 오브젝트 상호작용 결과가 로그/패널에 반영되는지 확인한다.

### 2단계: 드래그&드롭 데모(인벤토리→핫스팟)

- 아이템을 드래그하면 오버레이/피드백이 나타나는지 확인한다.
- 핫스팟 위로 드래그 시 대상 하이라이트가 동작하는지 확인한다.
- 드롭 시 turn 실행 및 성공/실패 피드백이 즉시 표시되는지 확인한다.

### 3단계: 금지사항/인바리언트 체크

- 채팅 버블 UI가 없는지 확인한다. (RULE-002)
- bbox 좌표 규약(0~1000, `[ymin,xmin,ymax,xmax]`)이 깨지지 않는지 확인한다. (RULE-009)
- Agent Console에 프롬프트 원문/내부 추론이 노출되지 않는지 확인한다. (RULE-008)

## 의존성 & 연결

**이전 작업에서 가져올 것**:

- **계획서**: [RU-003[Mvp]](RU-003[Mvp].md) - UI 상태/경계 정리
- **계획서**: [U-009[Mvp]](U-009[Mvp].md) - Action Deck
- **계획서**: [U-010[Mvp]](U-010[Mvp].md) - Hotspots
- **계획서**: [U-012[Mvp]](U-012[Mvp].md) - DnD 드롭 실행

**다음 작업에 전달할 것**:

- U-013~U-015 확장 작업(퀘스트/룰/세이브/데모프로필) 전에 “핵심 조작” 안정성 기준선

## 주의사항

**기술적 고려사항**:

- 성공 경로만 보지 말고, 반드시 드롭 실패 케이스(드롭 불가 대상/대상 없음)도 확인한다.

**잠재적 리스크**:

- 조작이 불안정하면 이후 기능이 모두 “체감 품질”에서 실패 → CP 결과를 기준으로 UX/레이어링(오버레이/포인터 이벤트)을 즉시 개선한다.

## 페어링 질문 (결정 필요)

- [ ] **Q1**: CP 결과의 증거(스크린샷/영상)를 어디까지 남길까?
  - Option A: unit-results에 텍스트+스크린샷 링크(권장: 최소 비용)
  - Option B: 데모 영상까지 기록(신뢰도↑, 비용↑)

## 참고 자료

- `vibe/prd.md` - 데모 표면/조작 요구
- `.cursor/rules/10-frontend-game-ui.mdc` - 클릭/드래그 UX 규칙
- `.cursor/rules/00-core-critical.mdc` - RULE-002/008/009
</file>

<file path="vibe/unit-plans/CP-MVP-03.md">
# CP-MVP-03: 체크포인트 - 10분 데모 루프

## 메타데이터

| 항목      | 내용        |
| --------- | ----------- |
| Unit ID   | CP-MVP-03   |
| Phase     | MVP         |
| 예상 소요 | 60분        |
| 의존성    | RU-007[Mvp] |
| 우선순위  | ⚡ Critical |

## 작업 목표

심사자/사용자가 10분 안에 핵심 기능을 모두 체험할 수 있도록, “즉시 시작 → 조작(클릭/드래그/업로드) → Autopilot → 엔딩 리포트 → 리셋”의 **데모 루프**를 수동 검증하고 런북/증거를 남긴다.

**배경**: PRD는 “항상 플레이 가능한 데모”와 “데모 표면(UI/동작) 고정”을 핵심 성공 조건으로 둔다. (PRD 10장, RULE-002)

**완료 기준**:

- 데모 프로필 선택만으로 즉시 플레이가 시작되고, Reset 1회로 반복 가능하다. (PRD 6.9)
- 다음 조작이 모두 실제로 동작한다:
  - Action Deck 클릭
  - Hotspot 클릭
  - Inventory 드래그&드롭
  - Scanner 업로드(가능하면)
  - Autopilot Goal 입력/실행
- 엔딩 리포트가 생성되고(텍스트-only 포함), 리플레이/체크 결과가 남는다.
- Hard Gate 인바리언트(스키마/경제/안전/일관성)가 깨지지 않는다.

## 영향받는 파일

**생성**:

- `vibe/unit-runbooks/CP-MVP-03.md` - 10분 데모 루프 런북(재현 절차)
- `vibe/unit-results/CP-MVP-03.md` - 실행 결과/관측값/증거(스크린샷/로그)

**수정**:

- 없음(검증 단계)

**참조**:

- `vibe/prd.md` - 데모 표면/데모 프로필/오토파일럿/리플레이 요구
- `vibe/roadmap.md` - MVP 완료 기준(DoD) 및 하드 게이트
- `.cursor/rules/00-core-critical.mdc` - RULE-002/003/004/005/008/009

## 구현 흐름

### 1단계: “즉시 시작/리셋” 검증

- Demo Profile 3종 중 1개 선택 → 즉시 시작(로그인/가입 없음)
- Reset 버튼 1회로 초기 상태 복구 → 다시 동일 프로필로 즉시 시작

### 2단계: 핵심 조작(클릭/드래그/업로드) 검증

- Action Deck 카드 1회 클릭 → 턴 실행/결과 반영 확인
- Hotspot 1회 클릭 → 턴 실행/결과 반영 확인
- Inventory 아이템 1개를 Hotspot에 드롭 → 성공/실패 피드백 확인
- Scanner에 이미지 드롭/업로드 → 캡션/아이템화 → 인벤토리에 반영 확인(가능하면)

### 3단계: Autopilot + 엔딩 + 리플레이 증거 확보

- Autopilot 모드로 전환 → Goal 입력 → 제한 스텝 실행 확인
- 엔딩 트리거(데모용)로 엔딩 리포트 생성 확인
- 리플레이 러너로 대표 시나리오 1개 재실행(또는 결과 체크)하여 Hard Gate 체크 결과를 기록

## 의존성 & 연결

**이전 작업에서 가져올 것**:

- **계획서**: [U-015[Mvp]](U-015[Mvp].md) - Demo Profiles/Reset/SaveGame
- **계획서**: [U-012[Mvp]](U-012[Mvp].md) - 드래그&드롭 실행
- **계획서**: [U-022[Mvp]](U-022[Mvp].md) - Scanner 업로드/아이템화
- **계획서**: [U-024[Mvp]](U-024[Mvp].md) - Autopilot 백엔드
- **계획서**: [U-025[Mvp]](U-025[Mvp].md) - 엔딩 리포트
- **계획서**: [U-026[Mvp]](U-026[Mvp].md) - 리플레이 하네스

**다음 작업에 전달할 것**:

- MMP 단계에서 배포/관측/회귀 자동화를 고도화할 “데모 기준선”과 런북

## 주의사항

**기술적 고려사항**:

- 실패가 발생하면 “빈 화면/멈춤”이 아니라 Repair/폴백으로 끝나야 한다. (RULE-004)
- 프롬프트 원문/내부 추론은 어떤 증거에도 포함하지 않는다(메타/라벨만). (RULE-008)

**잠재적 리스크**:

- 데모 루프가 길어지거나 준비물이 많아지면 심사자가 따라가기 어렵다 → “10분 루프”를 최우선으로 단순화하고, 프로필 프리셋에서 시작 위치를 조정한다.

## 페어링 질문 (결정 필요)

- [ ] **Q1**: CP 결과물의 “증거”는 어느 수준까지 남길까?
  - Option A: 스크린샷 + 체크리스트 + 로그 요약(권장)
  - Option B: 10분 데모 영상(신뢰도↑, 제작 부담↑)

## 참고 자료

- `vibe/prd.md` - Demo Mode/Replay/Autopilot
- `.cursor/rules/00-core-critical.mdc` - Hard Gate(RULE-003~005), 관측(RULE-008)
</file>

<file path="vibe/unit-plans/RU-003[Mvp].md">
# RU-003[Mvp]: 리팩토링 - UI 상태 슬라이스/경계 정리

## 메타데이터

| 항목      | 내용        |
| --------- | ----------- |
| Unit ID   | RU-003[Mvp] |
| Phase     | MVP         |
| 예상 소요 | 45분        |
| 의존성    | U-012       |
| 우선순위  | High        |

## 작업 목표

액션덱/핫스팟/인벤토리 DnD가 추가되며 커지는 UI/상태 코드를 **슬라이스(도메인별 store)로 분리**하고, 컴포넌트 경계를 정리해 이후 기능 추가가 “채팅 UI로 퇴행”하지 않게 만든다.

**배경**: 데모 표면은 고정되어야 하며, 상태/렌더 경계가 흐리면 기능 추가 시 UI가 쉽게 망가진다. (RULE-002)

**완료 기준**:

- Zustand store가 최소한 `agent`, `world`, `ui`(선택) 등으로 분리/정리되어 책임이 명확하다.
- SceneCanvas/Inventory/ActionDeck이 TurnOutput→상태 반영 흐름을 공유하되, 중복 파싱/중복 상태가 줄어든다.
- UI/스타일이 단일 `style.css` 원칙을 유지하며, 패널/레이아웃이 고정된 상태로 유지된다. (Frontend Style)

## 영향받는 파일

**생성**:

- `frontend/src/stores/` 내 슬라이스 파일들(예: `worldStore.ts`, `uiStore.ts` 등) - 구조 정리 목적

**수정**:

- `frontend/src/App.tsx` - store 연결/컴포넌트 조립 방식 정리
- `frontend/src/components/ActionDeck.tsx` - props/state 경계 정리
- `frontend/src/components/SceneCanvas.tsx` - props/state 경계 정리
- `frontend/src/components/InventoryPanel.tsx` - props/state 경계 정리

**참조**:

- `vibe/tech-stack.md` - Zustand 버전/역할
- `vibe/ref/frontend-style-guide.md` - 단일 CSS/레이아웃 원칙
- `.cursor/rules/10-frontend-game-ui.mdc` - 게임 UI 고정 규칙

## 구현 흐름

### 1단계: 상태 도메인(책임) 재정의

- `agent`: queue/badges/repair/연결 상태
- `world`: TurnOutput 기반의 world delta/인벤토리/퀘스트/룰 등
- `ui`: 패널 토글/선택 상태/드래그 상태(필요 시)

### 2단계: TurnOutput 반영 경로 단일화

- TurnOutput 수신 후 “상태 반영 함수(reducer)”를 한 곳으로 모은다(중복 파싱 제거).
- 컴포넌트는 store selector를 통해 필요한 최소 데이터만 구독한다.

### 3단계: UI 고정/금지사항 회귀 방지

- 컴포넌트 명/레이아웃이 Chat/Message 중심으로 변하지 않도록 네이밍/구조를 정리한다.
- CSS는 `style.css`에만 추가하고, 컴포넌트별 임의 색상/스타일을 줄인다.

## 의존성 & 연결

**이전 작업에서 가져올 것**:

- **계획서**: [U-009[Mvp]](U-009[Mvp].md) - Action Deck
- **계획서**: [U-010[Mvp]](U-010[Mvp].md) - Hotspot overlay
- **계획서**: [U-011[Mvp]](U-011[Mvp].md) - Inventory DnD
- **계획서**: [U-012[Mvp]](U-012[Mvp].md) - 드롭→턴 실행 연결

**다음 작업에 전달할 것**:

- CP-MVP-02에서 확인할 “안정된 클릭/드래그 UI” 기반
- U-013~U-015(퀘스트/룰/세이브/데모프로필) 확장 시 상태/렌더 경계 재사용

## 주의사항

**기술적 고려사항**:

- 리팩토링 유닛은 기능 추가가 아니라 **경계/중복/복잡도 감소**가 목적이다(Behavior Preservation).
- i18n 키 도입/정리는 이후 유닛에서 수행하되, 하드코딩 문자열이 늘어나지 않도록 경계를 세운다. (RULE-006)

**잠재적 리스크**:

- 구조를 너무 일찍 과도하게 추상화하면 속도가 느려짐 → “중복 제거/책임 분리” 수준까지만 수행한다.

## 페어링 질문 (결정 필요)

- [ ] **Q1**: Zustand 구성 방식을 어떻게 고정할까?
  - Option A: 도메인별 store 파일 분리(권장: 책임/테스트 용이)
  - Option B: 단일 store + slice 패턴(초기 단순하지만 커지면 복잡)

## 참고 자료

- `vibe/tech-stack.md` - Zustand
- `vibe/ref/frontend-style-guide.md` - 단일 CSS/CRT 토큰
- `.cursor/rules/10-frontend-game-ui.mdc` - UI 고정/채팅 금지
</file>

<file path="vibe/unit-plans/RU-004[Mvp].md">
# RU-004[Mvp]: 리팩토링 - SaveGame/초기상태/데모 프로필 정리

## 메타데이터

| 항목      | 내용        |
| --------- | ----------- |
| Unit ID   | RU-004[Mvp] |
| Phase     | MVP         |
| 예상 소요 | 45분        |
| 의존성    | U-015       |
| 우선순위  | High        |

## 작업 목표

Demo Profiles/Reset/SaveGame이 추가되며 생기는 중복/불일치를 제거하고, “데모 반복성”을 최우선으로 구조를 정리한다(동작 변경 없이).

**배경**: 데모 프로필은 심사자 경험의 핵심이며, 리셋이 불안정하면 데모가 곧바로 무너진다. (PRD 6.9)

**완료 기준**:

- 프로필 프리셋/초기 SaveGame/리셋 로직이 단일 소스로 정리되어 중복이 줄어든다.
- SaveGame `version`/마이그레이션 훅(최소)이 준비되어 이후 스키마 변경에 대비한다.
- 로드/리셋/저장 흐름이 “채팅 앱” 방향으로 UI가 퇴행하지 않도록 HUD 중심 플로우가 유지된다. (RULE-002)

## 영향받는 파일

**생성**:

- (선택) `frontend/src/save/migrations.ts` - SaveGame 버전 마이그레이션 훅

**수정**:

- `frontend/src/save/saveGame.ts` - 버전/기본값/검증 정리
- `frontend/src/data/demoProfiles.ts` - 프로필 프리셋 중복 제거
- `frontend/src/App.tsx` - 초기화/리셋/로드 경계 정리

**참조**:

- `vibe/prd.md` 6.6/6.9 - Save/Load, Demo Profiles, Reset 요구
- `.cursor/rules/00-core-critical.mdc` - RULE-010(DB 금지), RULE-006(language)

## 구현 흐름

### 1단계: “초기 상태의 SSOT”를 명확히 하기

- Reset의 SSOT는 “프로필 초기 SaveGame”임을 코드 구조로 고정한다.
- 임시 스냅샷/전역 변수 등으로 리셋을 구현하지 않도록 정리한다.

### 2단계: SaveGame 검증/기본값 정리

- `version` 기반으로 기본값/누락 필드를 보정하는 최소 로직을 둔다.
- 향후 TurnOutput/WorldState 스키마 확장 시에도 리셋/로드가 깨지지 않게 대비한다.

### 3단계: 데모 반복성(회귀) 관점에서 단순화

- 프로필별로 “10분 루프” 데모가 빠르게 가능한지 다시 점검하고, 과도한 분기/복잡도를 줄인다.

## 의존성 & 연결

**이전 작업에서 가져올 것**:

- **계획서**: [U-015[Mvp]](U-015[Mvp].md) - Demo Profiles/Reset/SaveGame 초기 구현

**다음 작업에 전달할 것**:

- U-025(엔딩 리포트) 및 U-026(리플레이)에서 사용할 “안정적 세션/아티팩트 기반”
- CP-MVP-03에서 “반복 데모”의 신뢰성 기준선

## 주의사항

**기술적 고려사항**:

- (RULE-010) DB/ORM을 도입해 리셋/세이브를 해결하려 하지 않는다(문서 합의 전 금지).
- (RULE-006) 언어 정책은 SaveGame 복원에도 그대로 적용되어야 한다(혼합 출력 금지).

**잠재적 리스크**:

- 리팩토링 중 “리셋 결과”가 미묘하게 바뀔 수 있음 → Behavior Preservation을 지키고, CP-MVP-02 시나리오로 재검증한다.

## 페어링 질문 (결정 필요)

- [ ] **Q1**: Demo Profiles 프리셋은 어디에 두는 게 좋을까?
  - Option A: `frontend/src/data/demoProfiles.ts` 같은 코드 기반(권장: 타입 안정)
  - Option B: `frontend/public/demo-profiles/*.json` 같은 데이터 파일(편집 용이)

## 참고 자료

- `vibe/prd.md` - 데모프로필/리셋 요구
- `.cursor/rules/00-core-critical.mdc` - RULE-010, RULE-006
</file>

<file path="vibe/unit-plans/RU-006[Mvp].md">
# RU-006[Mvp]: 리팩토링 - media/artifacts 스토리지 추상화

## 메타데이터

| 항목      | 내용        |
| --------- | ----------- |
| Unit ID   | RU-006[Mvp] |
| Phase     | MVP         |
| 예상 소요 | 60분        |
| 의존성    | U-022       |
| 우선순위  | High        |

## 작업 목표

이미지 생성/스캐너 업로드가 추가되며 생기는 저장/서빙/제한 로직을 정리해, 로컬(MVP)과 GCS(MMP) 확장을 대비한 **스토리지 추상화**를 만든다(동작 보존).

**배경**: 멀티모달은 파일/에셋이 필연적으로 늘어나며, 이를 정리하지 않으면 보안/용량/운영 문제가 빠르게 생긴다. (RULE-007)

**완료 기준**:

- 백엔드에 media/artifacts 저장 인터페이스(로컬 구현)가 도입되어, 이미지 생성/스캐너가 동일 경로로 저장한다.
- 파일 크기/타입 제한과 안전한 에러 응답이 일관되게 적용된다.
- 비밀정보/프롬프트 원문/사용자 업로드 원본이 로그에 노출되지 않는다(메타만). (RULE-007/008)

## 영향받는 파일

**생성**:

- `backend/src/unknown_world/storage/storage.py` - 스토리지 인터페이스(put/get)
- `backend/src/unknown_world/storage/local_storage.py` - 로컬 저장 구현(MVP)

**수정**:

- `backend/src/unknown_world/services/image_generation.py` - 저장 경로를 스토리지로 통일
- `backend/src/unknown_world/services/image_understanding.py` - 업로드 처리/임시 저장 정리(필요 시)

**참조**:

- `.cursor/rules/00-core-critical.mdc` - RULE-007/010
- `vibe/tech-stack.md` - MMP에서 GCS 확장 가능성

## 구현 흐름

### 1단계: 저장 대상/수명 정책 확정

- 저장 대상: 생성 이미지, 업로드 이미지(선택), 엔딩 리포트/리플레이 아티팩트(추후)
- 수명: MVP는 로컬 개발 중심(임시 폴더/데모 유지), 운영은 MMP에서 GCS로 확장

### 2단계: 스토리지 인터페이스 도입

- put/get 기반 최소 인터페이스를 만들고, 파일명 규칙(세션/턴/타입)을 정한다.
- 외부로 노출되는 것은 URL/핸들뿐이며, 원본/민감 메타를 노출하지 않는다.

### 3단계: 공통 제한/보안 적용

- 파일 크기/타입 제한을 중앙에서 관리한다.
- 로깅은 라벨/크기/처리 시간 등 메타만 남긴다(내용/원본/키/프롬프트 금지).

## 의존성 & 연결

**이전 작업에서 가져올 것**:

- **계획서**: [U-019[Mvp]](U-019[Mvp].md) - 이미지 생성
- **계획서**: [U-021[Mvp]](U-021[Mvp].md) - 스캐너 백엔드
- **계획서**: [U-022[Mvp]](U-022[Mvp].md) - 스캐너 UI 연동(업로드 경로 확인)

**다음 작업에 전달할 것**:

- U-102(MMP)에서 GCS 스토리지 어댑터로 자연스럽게 확장할 구조
- U-025/U-026(엔딩/리플레이) 아티팩트 저장 기반

## 주의사항

**기술적 고려사항**:

- (RULE-007) 사용자 업로드/생성 에셋 처리에서 비밀정보/PII 노출을 방지한다.
- (RULE-010) “저장은 DB” 같은 방향 전환 금지: 파일/SaveGame 기반으로 우선 구성한다.

**잠재적 리스크**:

- 너무 이른 추상화로 속도가 느려질 수 있음 → MVP는 로컬 구현만, 인터페이스는 최소로 제한한다.

## 페어링 질문 (결정 필요)

- [ ] **Q1**: MVP 로컬 저장 경로 정책은?
  - Option A: `backend/.data/` 같은 전용 폴더(권장: 정리 용이, gitignore 필요)
  - Option B: OS temp 디렉토리(자동 정리되지만 디버깅 어려움)

## 참고 자료

- `.cursor/rules/00-core-critical.mdc` - RULE-007/010
- `vibe/tech-stack.md` - (선택) GCS 확장
</file>

<file path="vibe/unit-plans/RU-007[Mvp].md">
# RU-007[Mvp]: 리팩토링 - artifacts 버전/경로/링크 정리

## 메타데이터

| 항목      | 내용        |
| --------- | ----------- |
| Unit ID   | RU-007[Mvp] |
| Phase     | MVP         |
| 예상 소요 | 60분        |
| 의존성    | U-026       |
| 우선순위  | High        |

## 작업 목표

SaveGame/엔딩 리포트/리플레이 결과/이미지 등 아티팩트가 늘어나는 시점에서, **버전/경로/링크 규칙**을 정리해 추적 가능성과 데모 반복성을 강화한다(동작 보존).

**배경**: PRD는 “Artifacts(저장 파일, 엔딩 리포트, 로그/이미지)”를 시스템의 필수 요소로 요구하며, 관측 가능성도 UX의 일부다. (RULE-001/008)

**완료 기준**:

- 아티팩트의 저장 경로 규칙이 정리되어(세션/턴/타입 기반) 충돌/덮어쓰기 위험이 줄어든다.
- `version` 필드/마이그레이션 훅이 최소한 준비되어 이후 형식 변경에 대비한다.
- UI/로그에는 프롬프트 원문/내부 추론/비밀정보가 포함되지 않는다(메타만). (RULE-007/008)

## 영향받는 파일

**생성**:

- `backend/src/unknown_world/artifacts/registry.py` - 아티팩트 메타/경로 레지스트리(선택)
- `backend/src/unknown_world/artifacts/types.py` - 아티팩트 타입/버전 정의(선택)

**수정**:

- `frontend/src/save/saveGame.ts` - (필요 시) artifacts 링크/메타 저장 구조 정리
- `backend/src/unknown_world/artifacts/ending_report.py` - 파일명/버전/링크 정리(필요 시)
- `backend/src/unknown_world/replay/runner.py` - 결과 저장 경로 정리(필요 시)
- `backend/src/unknown_world/storage/*` - 저장 경로 규칙 적용(필요 시)

**참조**:

- `.cursor/rules/00-core-critical.mdc` - RULE-001/007/008/010
- `vibe/prd.md` 6.6/6.5/10.3 - Save/Ending/Replay 요구

## 구현 흐름

### 1단계: 아티팩트 타입/경로 규칙 정의

- 타입 예: `save_game`, `ending_report`, `replay_result`, `scene_image`, `upload_image`
- 경로 규칙 예: `{session_id}/{turn_id}/{artifact_type}/{timestamp}.{ext}`

### 2단계: 버전/마이그레이션 최소 훅 준비

- SaveGame/EndingReport/ReplayResult에 `version` 필드를 포함하고, 파싱 시 기본값/누락 보정을 한다.
- “MVP에서의 버전 고정”과 “MMP에서의 확장”을 구분한다.

### 3단계: 링크/표시 정합

- 프론트가 아티팩트(엔딩 리포트/리플레이 결과)를 링크로 열람할 때, 깨진 링크가 발생하지 않도록 규칙을 통일한다.
- Demo Mode UI에는 메타(버전/라벨/단계)만 노출한다.

## 의존성 & 연결

**이전 작업에서 가져올 것**:

- **계획서**: [U-025[Mvp]](U-025[Mvp].md) - 엔딩 리포트 아티팩트
- **계획서**: [U-026[Mvp]](U-026[Mvp].md) - 리플레이 결과 아티팩트
- **계획서**: [RU-006[Mvp]](RU-006[Mvp].md) - media/storage 추상화

**다음 작업에 전달할 것**:

- CP-MVP-03에서 “데모 종료 → 결과물(리포트/리플레이)”이 안정적으로 남는 기준선
- MMP의 U-102(GCS), U-105(자동 리플레이) 확장 시 경로/버전 SSOT로 사용

## 주의사항

**기술적 고려사항**:

- (RULE-010) 문서 합의 없이 DB/ORM으로 아티팩트 문제를 해결하려 하지 않는다.
- (RULE-007) 업로드/생성 파일은 보안/PII를 고려해 로그에 내용/원본을 남기지 않는다.

**잠재적 리스크**:

- 경로 규칙이 잦게 바뀌면 기존 세이브/리플레이가 깨짐 → 버전 필드와 마이그레이션 훅을 반드시 둔다.

## 페어링 질문 (결정 필요)

- [ ] **Q1**: 아티팩트 레지스트리를 어디를 SSOT로 둘까?
  - Option A: 백엔드 registry(권장: 저장/서빙 정합성)
  - Option B: 프론트에서만 링크 구성(초기 단순, 서버/클라 드리프트 위험)

## 참고 자료

- `vibe/prd.md` - Artifacts/Replay/Ending 요구
- `.cursor/rules/00-core-critical.mdc` - RULE-001/007/008/010
</file>

<file path="vibe/unit-plans/RU-010[Mmp].md">
# RU-010[Mmp]: 리팩토링 - 스키마/상수 SSOT 강화 + 파일 분리

## 메타데이터

| 항목      | 내용        |
| --------- | ----------- |
| Unit ID   | RU-010[Mmp] |
| Phase     | MMP         |
| 예상 소요 | 60분        |
| 의존성    | U-105       |
| 우선순위  | High        |

## 작업 목표

Turn 스키마/모델 ID/배지/스테이지 목록 같은 핵심 상수를 SSOT로 강화하고, 파일이 커지기 시작한 모듈을 분리해 유지보수성을 높인다(동작 보존).

**배경**: 서버/클라 스키마 드리프트는 repair 비용과 회귀 실패를 폭증시킨다. MMP에서는 “문서/코드/런북” 정합성이 더 중요하다. (RULE-003/010)

**완료 기준**:

- 서버(Pydantic)와 클라(Zod)의 스키마/상수 정합성이 개선되고, 드리프트 위험이 줄어든다.
- 모델 라벨/ID, stage 목록, badge 키가 중앙 상수로 정리된다.
- 리팩토링은 Behavior Preservation을 지키며, 기존 시나리오(U-105)가 모두 통과한다.

## 영향받는 파일

**생성**:

- `backend/src/unknown_world/constants/stages.py` - stage 목록 SSOT(서버)
- `backend/src/unknown_world/constants/badges.py` - badge 키 SSOT
- `frontend/src/constants/stages.ts` - stage 목록 SSOT(클라, 또는 서버에서 주입)
- `frontend/src/constants/badges.ts` - badge 키 SSOT

**수정**:

- `backend/src/unknown_world/models/turn.py` - 스키마 파일 분리/정리(필요 시)
- `frontend/src/schemas/turn.ts` - 스키마 정합성 정리(필요 시)

**참조**:

- `.cursor/rules/00-core-critical.mdc` - RULE-003/010/008
- `vibe/tech-stack.md` - 모델 ID 고정

## 구현 흐름

### 1단계: SSOT 대상 목록 확정

- stage 이름/순서
- badge 키/표시 라벨
- 모델 라벨/ID(FAST/QUALITY/IMAGE)
- (선택) schema_version

### 2단계: 상수 모듈화/중앙화

- 서버/클라 각각 상수 파일을 두고, 동기화 방식(수동/생성/서버 주입)을 정한다.

### 3단계: 시나리오 기반 회귀 확인

- U-105 자동 러너로 기존 시나리오가 통과하는지 확인한다(필요 시 결과 문서화).

## 의존성 & 연결

**이전 작업에서 가져올 것**:

- **계획서**: [U-105[Mmp]](U-105[Mmp].md) - 시나리오 회귀(통과 기준)

**다음 작업에 전달할 것**:

- CP-MMP-01에서 “배포/관측 게이트”를 안정적으로 유지할 SSOT 기반
- 이후 기능 추가 시 스키마/상수 드리프트를 예방하는 기준선

## 주의사항

**기술적 고려사항**:

- (RULE-010) 모델 ID/버전은 tech-stack SSOT로 고정하며, 리팩토링 중에 임의 변경하지 않는다.
- (RULE-008) 관측 정보는 메타만(프롬프트 원문/내부 추론 금지).

**잠재적 리스크**:

- “SSOT 강화”가 과도한 자동화로 번질 수 있음 → MMP에서는 최소 중앙화/동기화만 수행하고, 생성 자동화는 후순위로 둔다.

## 페어링 질문 (결정 필요)

- [ ] **Q1**: stage/badge SSOT를 어디에 둘까?
  - Option A: 서버 SSOT + 클라가 서버에서 수신(권장: 드리프트 최소)
  - Option B: 서버/클라 각각 고정(초기 단순, 동기화 부담)

## 참고 자료

- `.cursor/rules/00-core-critical.mdc` - RULE-003/008/010
- `vibe/tech-stack.md` - 모델/버전 SSOT
</file>

<file path="vibe/unit-plans/RU-011[Mmp].md">
# RU-011[Mmp]: 리팩토링 - Autopilot/Replay 모듈 정리

## 메타데이터

| 항목      | 내용        |
| --------- | ----------- |
| Unit ID   | RU-011[Mmp] |
| Phase     | MMP         |
| 예상 소요 | 60분        |
| 의존성    | U-108       |
| 우선순위  | High        |

## 작업 목표

Autopilot/Replay 관련 코드가 커지기 전에 모듈 경계를 정리하고, 공통 정책(보안/검증/관측)을 일관되게 적용한다(동작 보존).

**배경**: Autopilot/Replay는 “장시간 실행 + 회귀 검증”의 핵심인데, 경계가 흐리면 보안/관측/복구 정책이 드리프트하기 쉽다. (RULE-004/007/008)

**완료 기준**:

- Autopilot 실행기/Replay 러너/Scenario library가 명확한 디렉토리/모듈로 정리된다.
- 공통 정책(프롬프트 비노출, secret 마스킹, repair 제한, hard gate 체크)이 공통 유틸로 적용된다.
- U-105 시나리오 러너가 기존과 동일하게 통과한다(Behavior Preservation).

## 영향받는 파일

**생성**:

- `backend/src/unknown_world/autopilot/` - (선택) autopilot 모듈 디렉토리
- `backend/src/unknown_world/replay/` - (기존 유지) 하위 모듈 정리(선택)

**수정**:

- `backend/src/unknown_world/orchestrator/autopilot.py` - 위치/인터페이스 정리(필요 시)
- `backend/src/unknown_world/replay/*` - runner/auto_runner/report 구조 정리(필요 시)
- `backend/src/unknown_world/security/*` - 공통 정책 적용(필요 시)

**참조**:

- `.cursor/rules/00-core-critical.mdc` - RULE-004/007/008
- `vibe/prd.md` 10장 - 리플레이 기반 개발 방식

## 구현 흐름

### 1단계: 모듈 경계 정의

- Autopilot: goal/plan/step loop + 제한 정책
- Replay: scenario types/library/runner + invariants 체크
- 공통: policy(redaction, prompt non-exposure), validation(hard gate)

### 2단계: 파일 이동/인터페이스 고정(동작 보존)

- 퍼블릭 인터페이스(함수/클래스) 최소화
- import 경계/의존성 순환 제거

### 3단계: 시나리오 회귀로 확인

- U-105 자동 러너로 주요 시나리오가 동일하게 통과하는지 확인한다.

## 의존성 & 연결

**이전 작업에서 가져올 것**:

- **계획서**: [U-024[Mvp]](U-024[Mvp].md) - Autopilot 백엔드 기반
- **계획서**: [U-105[Mmp]](U-105[Mmp].md) - 자동 리플레이 기반
- **계획서**: [U-108[Mmp]](U-108[Mmp].md) - 보안 하드닝/인젝션 시나리오

**다음 작업에 전달할 것**:

- CP-MMP-02에서 “시나리오 회귀 100%”를 통과할 안정 구조

## 주의사항

**기술적 고려사항**:

- 리팩토링 유닛에서는 새 기능 추가 금지(동작 보존).
- (RULE-008) 프롬프트/CoT 비노출은 모듈 어디에서도 예외가 없어야 한다.

**잠재적 리스크**:

- 리팩토링 중 import 경계가 깨져 배포/실행이 실패할 수 있음 → 작은 단위로 이동하고 런북 기반으로 점검한다.

## 페어링 질문 (결정 필요)

- [ ] **Q1**: Replay 러너의 실행 위치는 어디가 적절할까?
  - Option A: 백엔드 CLI/스크립트(권장: 자동화 용이)
  - Option B: 프론트 Demo Mode 버튼(체감/데모에 좋지만 운영 분리 필요)

## 참고 자료

- `vibe/prd.md` - Replay 기반 개발
- `.cursor/rules/00-core-critical.mdc` - RULE-004/007/008
</file>

<file path="vibe/unit-plans/U-001[Mvp].md">
# U-001[Mvp]: 프로젝트 스캐폴딩 생성 (frontend/backend)

## 메타데이터

| 항목      | 내용        |
| --------- | ----------- |
| Unit ID   | U-001[Mvp]  |
| Phase     | MVP         |
| 예상 소요 | 45분        |
| 의존성    | None        |
| 우선순위  | ⚡ Critical |

## 작업 목표

문서 중심으로만 존재하는 현재 레포를, **프론트/백엔드가 분리된 개발 가능한 스캐폴딩** 상태로 전환할 “뼈대”를 만든다.

**배경**: MVP는 “항상 플레이 가능한 데모”를 유지해야 하므로, 가장 먼저 실행 가능한 코드 구조가 필요하다. (참조: `vibe/prd.md` 10장)

**완료 기준**:

- `frontend/`와 `backend/` 디렉토리 구조가 생성되고, 다음 유닛(U-002/U-003)이 즉시 초기화 작업을 진행할 수 있다.
- 비밀정보(서비스 계정 키 등)가 레포에 들어가지 않는다는 원칙이 문서/가이드에 반영된다. (RULE-007)
- 기술 스택/버전 고정(tech-stack SSOT) 원칙이 “스캐폴딩 단계”부터 유지된다. (RULE-010)

## 영향받는 파일

**생성**:

- `frontend/` - 프론트엔드(Vite/React) 루트 디렉토리
- `backend/` - 백엔드(FastAPI) 루트 디렉토리

**수정**:

- 없음

**참조**:

- `vibe/prd.md` - “채팅 래퍼 금지”, 데모 표면 UI, 하드 게이트
- `vibe/tech-stack.md` - 버전 고정, 도구/라이브러리 SSOT
- `.cursor/rules/00-core-critical.mdc` - RULE-001~010

## 구현 흐름

### 1단계: 디렉토리 골격 확정

- 레포 루트에 `frontend/`, `backend/` 디렉토리를 생성한다.
- “코드가 아직 없다”는 상태를 해소하기 위해, 이후 유닛에서 생성될 파일들의 상위 경로만 먼저 확보한다.

### 2단계: 보안/버전 원칙을 스캐폴딩에 반영

- 서비스 계정/토큰/키 파일은 **절대 커밋하지 않음**을 기본 원칙으로 확정한다. (RULE-007)
- 스택/버전은 `vibe/tech-stack.md`를 기준으로 고정하며, 임의 업그레이드를 금지한다. (RULE-010)

### 3단계: 다음 유닛이 만들 파일 경로를 합의

- 프론트: `frontend/src/...` 구조(단일 `style.css` 포함)를 사용할지 확인한다. (참조: `vibe/ref/frontend-style-guide.md`)
- 백엔드: `backend/src/unknown_world/...` 같은 패키지 구조로 갈지 합의한다(아래 페어링 질문).

## 의존성 & 연결

**이전 작업에서 가져올 것**:

- 없음

**다음 작업에 전달할 것**:

- U-002에서 `frontend/`를 Vite+React+TS로 초기화할 수 있는 경로
- U-003에서 `backend/`를 FastAPI 프로젝트로 초기화할 수 있는 경로

## 주의사항

**기술적 고려사항**:

- (RULE-010) 문서 합의 없이 DB/ORM 도입 금지: 저장은 우선 SaveGame(JSON) 기반으로 설계한다.
- (RULE-007) 비밀정보 파일(서비스 계정 키 등)은 레포에 포함하지 않는다(로컬/런타임 secret로만).

**잠재적 리스크**:

- “스캐폴딩 단계에서의 구조 선택”이 이후 유닛의 파일 경로를 연쇄적으로 고정함 → **초기 합의(페어링 질문)로 기준을 확정**한다.

## 페어링 질문 (결정 필요)

- [ ] **Q1**: 백엔드 파이썬 패키지 루트는 어떤 구조로 갈까?
  - Option A: `backend/src/unknown_world/` (권장: 패키지/임포트 경계 명확)
  - Option B: `backend/app/` (단순하지만 패키지/배포 시 정리 필요)
    **A1**: Option A

## 참고 자료

- `vibe/prd.md` - MVP 핵심 기능/데모 표면/하드 게이트
- `vibe/tech-stack.md` - 고정 버전/모델 ID/도구
- `.cursor/rules/00-core-critical.mdc` - 핵심 규칙(RULE-001~010)
</file>

<file path="vibe/unit-plans/U-010[Mvp].md">
# U-010[Mvp]: Scene Canvas + Hotspot Overlay(0~1000 bbox)

## 메타데이터

| 항목      | 내용        |
| --------- | ----------- |
| Unit ID   | U-010[Mvp]  |
| Phase     | MVP         |
| 예상 소요 | 75분        |
| 의존성    | U-004,U-008 |
| 우선순위  | ⚡ Critical |

## 작업 목표

Scene Canvas(장면 영역)에 **핫스팟 오버레이**를 그리고, 핫스팟 클릭으로 TurnInput(click)을 전송해 “클릭 가능한 세계”를 만든다.

**배경**: PRD의 MVP 핵심은 오브젝트/핫스팟 좌표를 구조화하여 “플레이 가능한 화면”을 만드는 것이다. 좌표 규약은 0~1000 정규화 + `[ymin,xmin,ymax,xmax]` 고정이다. (RULE-009)

**완료 기준**:

- TurnOutput의 `objects[]`/`hotspots[]`를 기반으로 오버레이가 렌더되고 hover 하이라이트가 동작한다.
- 핫스팟 클릭 시 `object_id`(+ 선택적으로 box_2d)가 TurnInput에 포함되어 `/api/turn`으로 전송된다.
- 좌표는 저장/전송/세이브에서 끝까지 0~1000 정규화 규약을 유지하고, 렌더 시에만 px로 변환한다. (RULE-009)

## 영향받는 파일

**생성**:

- `frontend/src/components/SceneCanvas.tsx` - Scene Canvas + 오버레이 렌더/클릭 처리
- `frontend/src/utils/box2d.ts` - box_2d(0~1000) → px 변환 유틸

**수정**:

- `frontend/src/App.tsx` - Scene Canvas 배치 및 클릭→turn 실행 연결
- `frontend/src/style.css` - 오버레이(테두리/호버/툴팁) 스타일

**참조**:

- `vibe/prd.md` 6.2 - 구조화 UI(핫스팟) 요구
- `.cursor/rules/10-frontend-game-ui.mdc` - 좌표 규약/핫스팟 렌더 원칙
- `.cursor/rules/00-core-critical.mdc` - RULE-009/002/008

## 구현 흐름

### 1단계: box_2d 변환 규칙 구현(정규화 유지)

- 서버/세이브에는 항상 box_2d(0~1000)를 유지한다.
- 렌더에서만 viewport 크기(canvasW/H)에 맞춰 px로 변환한다.

### 2단계: 오버레이 렌더 + 상호작용(hover/click)

- 각 오브젝트에 대해 overlay 박스를 그린다(테두리/글로우).
- hover 시 툴팁/하이라이트를 보여준다(게임스러운 피드백).
- click 시 TurnInput(click) 생성 → U-008의 turn 실행 함수로 전달한다.

### 3단계: “채팅 UI로 보이지 않게” 피드백을 게임 UI에 고정

- 클릭 결과는 “채팅 답변” 대신 로그 피드/패널 변화(퀘스트/인벤토리/룰)에 반영되도록 경로를 유지한다.

## 의존성 & 연결

**이전 작업에서 가져올 것**:

- **계획서**: [U-004[Mvp]](U-004[Mvp].md) - Scene Canvas 자리/레이아웃
- **계획서**: [U-008[Mvp]](U-008[Mvp].md) - turn 실행/스트리밍 표시

**다음 작업에 전달할 것**:

- U-012에서 핫스팟을 “드롭 타겟”으로 확장(DnD)
- CP-MVP-02에서 클릭 데모 케이스로 사용

## 주의사항

**기술적 고려사항**:

- (RULE-009) bbox 순서/좌표계 혼용 금지: `[ymin,xmin,ymax,xmax]` + 0~1000만 허용한다.
- 오버레이 요소는 클릭/드래그를 방해하지 않게 CSS를 설계한다(필요 시 pointer-events 조절).

**잠재적 리스크**:

- 반응형 리사이즈에서 좌표 변환이 흔들릴 수 있음 → 변환은 항상 “현재 캔버스 크기” 기반으로 계산하고, 정규화 값은 그대로 유지한다.

## 페어링 질문 (결정 필요)

- [ ] **Q1**: 클릭 이벤트에 box_2d를 함께 보낼까?
  - Option A: `object_id`만 전송(단순, 서버 SSOT)
  - Option B: `object_id + box_2d` 전송(선택: 서버가 “클릭 위치 맥락”을 더 잘 이해)

## 참고 자료

- `vibe/prd.md` - 핫스팟/좌표 규약 요구
- `.cursor/rules/10-frontend-game-ui.mdc` - 좌표 변환/렌더 원칙
- `.cursor/rules/00-core-critical.mdc` - RULE-009
</file>

<file path="vibe/unit-plans/U-011[Mvp].md">
# U-011[Mvp]: Inventory 패널(DnD) 기본

## 메타데이터

| 항목      | 내용        |
| --------- | ----------- |
| Unit ID   | U-011[Mvp]  |
| Phase     | MVP         |
| 예상 소요 | 75분        |
| 의존성    | U-004       |
| 우선순위  | ⚡ Critical |

## 작업 목표

Inventory 패널을 구현하고, 아이템을 **드래그 가능한 엔티티**로 만들어 “DnD 조작”이 데모 표면에서 즉시 보이게 한다.

**배경**: PRD는 Inventory(DnD) + 아이템을 장면 오브젝트로 드래그해 사용하는 경험을 “데모 표면 핵심”으로 요구한다. (PRD 6.7, RULE-002)

**완료 기준**:

- Inventory 패널이 상시 노출되고, 아이템 리스트가 렌더된다.
- dnd-kit 기반으로 아이템이 드래그 가능하며, 드래그 중 시각적 피드백(overlay/hover)이 있다. (tech-stack)
- 드래그만으로는 “실행”되지 않으며, 실제 드롭→행동 실행은 U-012에서 연결한다.

## 영향받는 파일

**생성**:

- `frontend/src/components/InventoryPanel.tsx` - 인벤토리 UI + draggable 아이템 렌더
- `frontend/src/stores/inventoryStore.ts` - 인벤토리 상태(Zustand) 및 선택/드래그 상태(선택)

**수정**:

- `frontend/src/App.tsx` - Inventory 패널 배치(고정 사이드 패널)
- `frontend/src/style.css` - 슬롯/칩/드래그 상태 스타일

**참조**:

- `vibe/tech-stack.md` - dnd-kit 버전/사용
- `.cursor/rules/10-frontend-game-ui.mdc` - DnD 핵심 인터랙션
- `vibe/prd.md` 6.7 - Inventory DnD 요구

## 구현 흐름

### 1단계: 인벤토리 데이터 모델 연결

- TurnOutput의 inventory 구조를 기준으로 “아이템 최소 표기(이름/아이콘/설명/수량)”를 정한다.
- 상태는 WorldState에 붙여 저장하되, UI/드래그 상태는 분리한다(RU-003에서 정리).

### 2단계: dnd-kit로 draggable 구현

- 아이템을 draggable로 만들고, 드래그 오버레이/커서 피드백을 제공한다.
- 키보드 접근성/모바일 대응은 MMP에서 고도화하되, MVP에서도 최소한의 피드백은 제공한다.

### 3단계: “드롭 타겟” 확장 준비

- U-012에서 핫스팟(오브젝트)이 droppable이 될 것을 고려해, drag 데이터에 `item_id` 등을 실어둘 수 있게 한다.

## 의존성 & 연결

**이전 작업에서 가져올 것**:

- **계획서**: [U-004[Mvp]](U-004[Mvp].md) - Inventory 패널 슬롯/레이아웃
- **계획서**: [U-006[Mvp]](U-006[Mvp].md) - 스키마(Inventory 필드 정합)

**다음 작업에 전달할 것**:

- U-012에서 아이템→핫스팟 드롭(사용/조합) 실행을 연결할 draggable 기반
- CP-MVP-02에서 “드래그 동작”을 눈에 보이게 만드는 데모 표면 증거

## 주의사항

**기술적 고려사항**:

- (RULE-002) Inventory는 “게임 UI”로 상시 노출되어야 하며, 채팅 입력으로 대체하면 안 된다.
- dnd-kit 사용 시, 스타일/오버레이가 핫스팟 클릭을 방해하지 않게 레이어링을 조절한다.

**잠재적 리스크**:

- 드래그만 보이고 “드롭 결과”가 없으면 데모 설득력이 약함 → U-012를 크리티컬 패스로 붙여 즉시 드롭 실행까지 연결한다.

## 페어링 질문 (결정 필요)

- [ ] **Q1**: DnD 컨텍스트(DndContext)는 어디에 둘까?
  - Option A: App 최상단(권장: 여러 패널/드롭 타겟 확장 용이)
  - Option B: InventoryPanel 내부(단순하지만 SceneCanvas 드롭 연동이 어려워질 수 있음)

## 참고 자료

- `vibe/prd.md` - Inventory DnD 데모 요구
- `vibe/tech-stack.md` - dnd-kit 버전
- `.cursor/rules/10-frontend-game-ui.mdc` - DnD UX 규칙
</file>

<file path="vibe/unit-plans/U-012[Mvp].md">
# U-012[Mvp]: DnD 드롭(아이템→핫스팟) TurnInput 이벤트

## 메타데이터

| 항목      | 내용              |
| --------- | ----------------- |
| Unit ID   | U-012[Mvp]        |
| Phase     | MVP               |
| 예상 소요 | 75분              |
| 의존성    | U-010,U-011,U-008 |
| 우선순위  | ⚡ Critical       |

## 작업 목표

인벤토리 아이템을 Scene Canvas의 핫스팟(오브젝트)로 **드롭**하면, TurnInput(drag/drop)으로 변환되어 턴 실행이 일어나도록 연결한다.

**배경**: PRD의 데모 표면 핵심은 “드래그해서 사용/조합”이 실제로 동작하는 것을 보여주는 것이다. (PRD 6.7, RULE-002)

**완료 기준**:

- 아이템을 핫스팟 위로 드래그하면 대상이 하이라이트되고, 드롭 시 턴 실행이 발생한다.
- 드롭 실패(대상 없음/불가) 시 즉시 이유가 UI로 피드백된다(무반응 금지).
- 서버로 보내는 데이터는 id 중심이며, bbox 규약을 깨지 않는다(정규화 유지). (RULE-009)

## 영향받는 파일

**생성**:

- (선택) `frontend/src/components/dnd/DndLayer.tsx` - DnD 컨텍스트/오버레이 분리

**수정**:

- `frontend/src/components/SceneCanvas.tsx` - droppable 핫스팟/하이라이트/드롭 처리
- `frontend/src/components/InventoryPanel.tsx` - draggable 데이터(item_id 등) 포함
- `frontend/src/App.tsx` - 드롭 결과를 TurnInput으로 만들어 turn 실행
- `frontend/src/style.css` - 드롭 가능/불가 상태 시각화

**참조**:

- `.cursor/rules/10-frontend-game-ui.mdc` - DnD/핫스팟 핵심 규칙
- `.cursor/rules/00-core-critical.mdc` - RULE-002/005/009
- `vibe/prd.md` 6.7 - 드래그&드롭 데모 요구

## 구현 흐름

### 1단계: 드롭 계약(아이템/대상/의도) 정의

- TurnInput에 “드롭 액션”을 표현하는 최소 필드를 정의한다:
  - `item_id`
  - `target_object_id`
  - (선택) `target_box_2d`
- 서버가 해석할 수 있는 수준으로만 보내고, 좌표 규약을 위반하지 않는다. (RULE-009)

### 2단계: SceneCanvas를 droppable로 확장

- 핫스팟 overlay를 droppable 대상으로 만든다.
- hover 시 하이라이트/툴팁을 보여주고, 드롭 성공/실패를 즉시 시각화한다.

### 3단계: 드롭 → 턴 실행 연결

- 드롭 성공 시 TurnInput을 구성해 `/api/turn`을 호출한다(U-008).
- 결과는 로그 피드/패널 변화로 반영되며, 채팅 버블로 대체하지 않는다. (RULE-002)

## 의존성 & 연결

**이전 작업에서 가져올 것**:

- **계획서**: [U-010[Mvp]](U-010[Mvp].md) - Hotspot overlay/click
- **계획서**: [U-011[Mvp]](U-011[Mvp].md) - Inventory draggable
- **계획서**: [U-008[Mvp]](U-008[Mvp].md) - turn 실행/스트리밍 표시

**다음 작업에 전달할 것**:

- RU-003에서 정리할 “상호작용 이벤트 → TurnInput” 표준
- CP-MVP-02에서 검증할 “드래그→드롭→결과 반영” 데모 시나리오

## 주의사항

**기술적 고려사항**:

- (RULE-005) 비용/대안 UX: 드롭 액션도 예산 부족 시 대안(텍스트-only 등)이 제공될 수 있어야 한다(표시는 U-014에서 강화).
- (RULE-009) 저장/전송은 정규화 bbox만, 렌더만 px 변환.

**잠재적 리스크**:

- 드롭 UX가 “불안정/무반응”이면 데모에서 즉시 신뢰를 잃음 → 성공/실패 피드백을 반드시 즉시 제공한다.

## 페어링 질문 (결정 필요)

- [ ] **Q1**: 드롭 이벤트에 좌표 정보를 포함할까?
  - Option A: `item_id + target_object_id`만(권장: 단순/일관)
  - Option B: `target_box_2d`도 포함(서버에서 “정확히 어디에 드롭했는지” 해석 가능)

## 참고 자료

- `vibe/prd.md` - 드래그&드롭 데모 요구
- `.cursor/rules/10-frontend-game-ui.mdc` - DnD/핫스팟 규칙
- `.cursor/rules/00-core-critical.mdc` - RULE-002/009
</file>

<file path="vibe/unit-plans/U-013[Mvp].md">
# U-013[Mvp]: Quest + Rule Board/Timeline 패널

## 메타데이터

| 항목      | 내용        |
| --------- | ----------- |
| Unit ID   | U-013[Mvp]  |
| Phase     | MVP         |
| 예상 소요 | 60분        |
| 의존성    | U-004,U-008 |
| 우선순위  | Medium      |

## 작업 목표

Quest/Objective 패널과 Rule Board/Mutation Timeline 패널을 구현해, 플레이어가 “무엇을 해야 하는지/세계 규칙이 어떻게 바뀌는지”를 UI로 항상 확인할 수 있게 한다.

**배경**: PRD는 목표(Quest)와 룰 변형(Rule Mutation)이 UI로 체감되어야 한다고 명시한다. (PRD 6.4/6.7)

**완료 기준**:

- Quest 패널이 체크리스트 형태로 렌더되며, 턴 진행에 따라 상태(진행/완료)와 보상이 반영된다.
- Rule Board가 “현재 적용 중 규칙”을 카드로 노출하고, Mutation Timeline이 변형 이벤트를 시간 순으로 기록한다.
- 패널은 채팅 UI를 대체하지 않고, 고정 HUD 구성요소로 상시 노출된다. (RULE-002)

## 영향받는 파일

**생성**:

- `frontend/src/components/QuestPanel.tsx` - 목표/서브목표 렌더
- `frontend/src/components/RuleBoard.tsx` - 룰 카드 렌더
- `frontend/src/components/MutationTimeline.tsx` - 변형 이벤트 타임라인(선택: RuleBoard 내부로 포함 가능)

**수정**:

- `frontend/src/App.tsx` - 사이드 패널 슬롯에 Quest/RuleBoard 배치
- `frontend/src/style.css` - 패널/카드/타임라인 스타일(단일 CSS)

**참조**:

- `vibe/prd.md` 6.4/6.7 - 룰 변형/룰 보드/퀘스트 패널 요구
- `.cursor/rules/10-frontend-game-ui.mdc` - 고정 패널/채팅 금지

## 구현 흐름

### 1단계: TurnOutput → Quest/Rules 데이터 연결

- Zod 스키마 기준으로 Quest(목표/상태/보상)와 Rules(현재 규칙/변형 이벤트) 데이터 모델을 정한다.
- WorldState store에 “도메인 데이터”로 저장하고, 패널은 selector로 렌더한다(RU-003 기준).

### 2단계: 패널 UI 구현(상시 노출)

- Quest: 체크리스트(현재 목표/서브목표), 완료 시 보상 표시
- Rule Board: 룰 카드 리스트(활성 규칙)
- Timeline: 변형 이벤트를 최신순/시간순으로 표시(가독성 우선)

### 3단계: 데모 표면 연결(설득력 강화)

- 클릭/드래그 결과가 Quest/Rules 변화로 반영되는 흐름을 유지해, “세계가 변한다”가 UI로 증명되게 한다.

## 의존성 & 연결

**이전 작업에서 가져올 것**:

- **계획서**: [U-004[Mvp]](U-004[Mvp].md) - 고정 레이아웃(사이드 패널 슬롯)
- **계획서**: [RU-003[Mvp]](RU-003[Mvp].md) - 상태/경계 정리

**다음 작업에 전달할 것**:

- U-015에서 데모프로필별 “초기 퀘스트/초기 룰” 프리셋을 구성할 기반
- CP-MVP-03(최종 데모 루프)에서 “룰 변형/퀘스트 진행” 증거로 사용

## 주의사항

**기술적 고려사항**:

- (RULE-002) 패널은 채팅 UI로 대체할 수 없다(상시 HUD).
- 변형 이벤트는 길어질 수 있으므로, 타임라인은 스크롤/요약 전략을 고려한다(MMP에서 고도화).

**잠재적 리스크**:

- 모델이 룰/퀘스트를 과도하게 생성해 패널이 난잡해질 수 있음 → 스키마 설계에서 개수 제한/요약 필드를 고려한다(추후).

## 페어링 질문 (결정 필요)

- [ ] **Q1**: Mutation Timeline을 별도 컴포넌트로 둘까, RuleBoard에 포함할까?
  - Option A: RuleBoard 내 포함(단순)
  - Option B: 별도 Timeline 컴포넌트(권장: 가독성/확장 용이)

## 참고 자료

- `vibe/prd.md` - Quest/Rule Mutation 요구
- `.cursor/rules/10-frontend-game-ui.mdc` - 고정 패널 규칙
</file>

<file path="vibe/unit-plans/U-014[Mvp].md">
# U-014[Mvp]: Economy HUD + Ledger(프론트)

## 메타데이터

| 항목      | 내용        |
| --------- | ----------- |
| Unit ID   | U-014[Mvp]  |
| Phase     | MVP         |
| 예상 소요 | 75분        |
| 의존성    | U-009,U-008 |
| 우선순위  | ⚡ Critical |

## 작업 목표

Signal/Memory Shard 재화 HUD를 구현하고, 턴별 비용/잔액 변화를 **원장(ledger)** 으로 추적해 “비용/지연을 게임 메커닉”으로 UX에 반영한다.

**배경**: PRD는 행동 전에 예상 비용을 보여주고, 잔액 부족 시 대체 행동을 제공하며, 잔액 음수는 금지라고 명시한다. (RULE-005)

**완료 기준**:

- Header(또는 고정 HUD 영역)에 Signal/Shard 잔액이 상시 표시된다.
- 이번 행동의 예상 비용(최소/최대)과 확정 비용/잔액(balance_after)이 구분되어 표시된다.
- 클라이언트에서도 ledger를 저장/표시하며, “음수로 내려갈 수 있는 표시/진행”을 방지한다(서버 Hard gate는 U-018에서). (RULE-005)

## 영향받는 파일

**생성**:

- `frontend/src/components/EconomyHud.tsx` - 잔액/비용/대안 표시
- `frontend/src/stores/economyStore.ts` - ledger/잔액/정책 상태(Zustand)

**수정**:

- `frontend/src/App.tsx` - HUD 배치 및 turn 결과 반영 연결
- `frontend/src/components/ActionDeck.tsx` - 카드 비용 표시/부족 안내(필요 시)
- `frontend/src/style.css` - HUD/배지/경고 스타일

**참조**:

- `vibe/prd.md` 5장 - 재화 목적/UX 요구
- `.cursor/rules/00-core-critical.mdc` - RULE-005
- `.gemini/GEMINI.md` (economy-rules import) - ledger/대안 UX 체크리스트

## 구현 흐름

### 1단계: Economy 상태 모델 확정(ledger 포함)

- 최소 상태:
  - `balance`: { signal, memory_shard }
  - `last_cost`: { signal, memory_shard } (확정)
  - `cost_estimate`: { signal_min/max, shard_min/max } (예상)
  - `ledger[]`: turn_id/action_id/reason/model_label 등(요약)

### 2단계: HUD 렌더 + 부족 시 대안 가이드

- 잔액/예상/확정 비용을 한 화면에서 비교 가능하게 표시한다.
- 잔액 부족이 예상되면 “텍스트-only/저해상도/Thinking 낮춤” 같은 대안을 Action Deck과 함께 제시할 수 있도록 UI 훅을 둔다.

### 3단계: TurnOutput 반영 경로 연결

- final TurnOutput 수신 시:
  - cost/balance_after를 반영
  - ledger_entry(있다면) 추가
  - Agent Console의 Economy badge와 일관되게 표시

## 의존성 & 연결

**이전 작업에서 가져올 것**:

- **계획서**: [U-009[Mvp]](U-009[Mvp].md) - Action Deck 비용/대안 표기
- **계획서**: [U-008[Mvp]](U-008[Mvp].md) - turn 실행/스트리밍 + final 반영

**다음 작업에 전달할 것**:

- U-015에서 SaveGame에 economy ledger/잔액을 포함할 기반
- U-018에서 서버 경제 Hard gate/repair loop를 붙일 때, 클라 UX(예상비용/대안)와 정합

## 주의사항

**기술적 고려사항**:

- (RULE-005) 잔액 음수는 “표시/진행” 모두 금지: 부족 시 실행 강행이 아니라 대체 행동을 제안한다.
- (RULE-008) 비용/모델 선택 이유는 프롬프트가 아니라 “라벨(FAST/QUALITY/REF)”로만 설명한다.

**잠재적 리스크**:

- 서버/클라 ledger 불일치가 발생할 수 있음 → 서버를 SSOT로 두고, 클라는 “표시/입력 가드” 역할로 한정한다(U-018에서 확정).

## 페어링 질문 (결정 필요)

- [ ] **Q1**: 클라이언트 ledger는 얼마나 오래 보관할까?
  - Option A: 최근 N턴만 보관(권장: UI/메모리 절감)
  - Option B: 전체 세션 ledger 보관(SaveGame 크기 증가)

## 참고 자료

- `vibe/prd.md` - Economy UX/원장 요구
- `.cursor/rules/00-core-critical.mdc` - RULE-005
</file>

<file path="vibe/unit-plans/U-015[Mvp].md">
# U-015[Mvp]: SaveGame(local) + Reset + Demo Profiles(3종)

## 메타데이터

| 항목      | 내용        |
| --------- | ----------- |
| Unit ID   | U-015[Mvp]  |
| Phase     | MVP         |
| 예상 소요 | 75분        |
| 의존성    | U-014,U-013 |
| 우선순위  | ⚡ Critical |

## 작업 목표

로그인 없이 즉시 시작 가능한 **데모 프로필 3종**(Narrator/Explorer/Tech Enthusiast)과 **즉시 리셋**, 그리고 SaveGame(JSON) 기반 **세이브/로드(로컬)** 를 제공한다.

**배경**: PRD는 심사자 이탈을 막기 위해 “데모 프로필 선택만으로 즉시 시작 + 리셋 1번”을 필수 요구한다. DB 없이 SaveGame 직렬화로 시작한다. (PRD 6.6/6.9, RULE-010)

**완료 기준**:

- 첫 화면(또는 시작 플로우)에서 데모 프로필 3종을 선택하면 즉시 플레이가 시작된다(로그인/가입 없음).
- Reset 버튼 1회로 해당 프로필의 초기 상태로 복구된다(데모 반복 가능).
- SaveGame(JSON)에 `language`, `world_state`, `history`, `economy_ledger`가 포함되고, 로컬 저장/복원이 가능하다.

## 영향받는 파일

**생성**:

- `frontend/src/save/saveGame.ts` - SaveGame 직렬화/역직렬화 + 버전 필드
- `frontend/src/components/DemoProfileSelect.tsx` - 프로필 선택 UI(3종)
- `frontend/src/components/ResetButton.tsx` - 즉시 리셋 UI
- `frontend/src/data/demoProfiles.ts` - 프로필 프리셋(초기 재화/룰/퀘스트/세이브)

**수정**:

- `frontend/src/App.tsx` - 시작 플로우/프로필 적용/리셋/세이브 로드 연결
- `frontend/src/style.css` - 프로필 카드/리셋 버튼 스타일

**참조**:

- `vibe/prd.md` 6.6/6.9 - Save/Load, Demo Profiles, Reset 요구
- `.cursor/rules/00-core-critical.mdc` - RULE-010(DB 금지), RULE-006(language)
- `vibe/tech-stack.md` - “즉시 시작/즉시 리셋” MVP 정책

## 구현 흐름

### 1단계: SaveGame 스키마(최소) 확정

- 최소 필드: `version`, `seed`, `language`, `world_state`, `history`, `economy_ledger`, `assets(선택)`
- 버전이 바뀌어도 복원 가능하도록 `version` 필드를 필수로 둔다.

### 2단계: Demo Profiles 3종 정의 및 적용

- 각 프로필은:
  - 초기 재화(Signal/Shard)
  - 초기 룰/퀘스트/인벤토리
  - 데모 10분 루프를 빠르게 보여줄 “시작 위치”가 달라야 한다
- 프로필 선택 시 해당 SaveGame을 즉시 로드한다.

### 3단계: Reset 1회 복구 + 로컬 저장/로드

- Reset은 “현재 세션 스냅샷”이 아니라 “프로필 초기 SaveGame”으로 복구한다(반복 데모 안정).
- 로컬 저장은 localStorage(우선)로 시작하고, 확장(IndexedDB)은 MMP에서 고려한다.

## 의존성 & 연결

**이전 작업에서 가져올 것**:

- **계획서**: [U-014[Mvp]](U-014[Mvp].md) - economy ledger/잔액 상태
- **계획서**: [U-013[Mvp]](U-013[Mvp].md) - 퀘스트/룰 패널 데이터 모델

**다음 작업에 전달할 것**:

- U-025(엔딩 리포트)에서 “세션 아티팩트”를 저장/리플레이하기 위한 SaveGame 기반
- CP-MVP-03에서 “10분 데모 루프 반복”을 보장하는 핵심 인프라

## 주의사항

**기술적 고려사항**:

- (RULE-010) DB/ORM 도입 금지: SaveGame JSON 직렬화가 기본이다.
- (RULE-006) SaveGame에는 `language`가 포함되어야 하며, 복원 시 UI/내러티브 언어가 혼합되지 않게 한다.

**잠재적 리스크**:

- SaveGame이 커지면 로컬 저장이 불안정해질 수 있음 → MVP는 최소 필드만 저장하고, 압축/샤딩은 MMP로 미룬다.

## 페어링 질문 (결정 필요)

- [ ] **Q1**: SaveGame 저장소는 무엇을 1순위로 둘까?
  - Option A: localStorage(권장: 단순/데모 적합)
  - Option B: IndexedDB(대용량에 유리하지만 초기 구현 부담)

## 참고 자료

- `vibe/prd.md` - Save/Load, Demo Profiles, Reset
- `.cursor/rules/00-core-critical.mdc` - RULE-010, RULE-006
</file>

<file path="vibe/unit-plans/U-016[Mvp].md">
# U-016[Mvp]: Vertex 인증 + google-genai 클라이언트 + 모델 라벨 고정

## 메타데이터

| 항목      | 내용        |
| --------- | ----------- |
| Unit ID   | U-016[Mvp]  |
| Phase     | MVP         |
| 예상 소요 | 75분        |
| 의존성    | U-003       |
| 우선순위  | ⚡ Critical |

## 작업 목표

백엔드에서 Vertex AI 서비스 계정 인증으로 Gemini를 호출할 수 있도록 **google-genai 클라이언트 래퍼**를 만들고, 모델 라벨/ID를 `vibe/tech-stack.md` 기준으로 고정한다.

**배경**: MVP는 BYOK(사용자 API 키 입력)를 금지하고, 모델 ID/버전은 SSOT로 고정해야 한다. (RULE-007/010)

**완료 기준**:

- 백엔드에 “GenAI 클라이언트 생성/호출”을 담당하는 모듈이 생기고, 서비스 계정 기반 인증(로컬/배포)을 전제로 한다.
- 텍스트/이미지 모델 ID가 SSOT에 맞게 상수로 고정된다:
  - FAST: `gemini-3-flash-preview`
  - QUALITY: `gemini-3-pro-preview`
  - IMAGE: `gemini-3-pro-image-preview` (고정) (RULE-010)
- 키/토큰/쿠키 등 비밀정보가 레포/로그/UI에 노출되지 않는 설계가 포함된다. (RULE-007)

## 영향받는 파일

**생성**:

- `backend/src/unknown_world/services/genai_client.py` - google-genai 클라이언트 팩토리/래퍼
- `backend/src/unknown_world/config/models.py` - 모델 라벨/ID 상수(tech-stack SSOT)

**수정**:

- `backend/requirements.txt` - `google-genai==1.56.0` 등 의존성 추가(tech-stack 기준)

**참조**:

- `vibe/tech-stack.md` - google-genai 버전, 모델 ID 고정
- `.cursor/rules/20-backend-orchestrator.mdc` - Vertex 인증/비밀정보 금지
- `.cursor/rules/00-core-critical.mdc` - RULE-007/010

## 구현 흐름

### 1단계: 인증/실행 환경 가정 확정

- 로컬: ADC 또는 `GOOGLE_APPLICATION_CREDENTIALS`(로컬 파일, 레포에 포함 금지)로 Vertex 인증
- 배포: Cloud Run 서비스 계정 권한으로 인증(키 파일 커밋 없음)

### 2단계: 모델 라벨/ID 상수화

- “FAST/QUALITY/IMAGE” 라벨을 코드 상수로 고정하고, 모델 ID를 tech-stack과 1:1로 맞춘다.
- 로그/UI에는 모델 ID 원문 대신 라벨(FAST/QUALITY/REF 등) 우선 노출을 기본으로 한다. (RULE-008)

### 3단계: 호출 래퍼 설계(보안/관측 고려)

- 호출 래퍼는 요청 메타(라벨/버전/정책)만 로깅하고, 프롬프트 원문/비밀정보는 로깅하지 않는다. (RULE-007/008)
- 자격 증명 미설정 시에도 개발이 멈추지 않도록 “mock fallback 모드”를 설계한다(실제 구현은 선택).

## 의존성 & 연결

**이전 작업에서 가져올 것**:

- **계획서**: [U-003[Mvp]](U-003[Mvp].md) - FastAPI 백엔드 골격/의존성 관리

**다음 작업에 전달할 것**:

- U-017에서 Structured Outputs 호출을 수행할 클라이언트/모델 상수
- U-019(이미지 생성), U-021(이미지 이해)에서 재사용할 멀티모달 호출 기반

## 주의사항

**기술적 고려사항**:

- (RULE-007) BYOK 흐름(사용자 키 입력/저장) 금지: 인증은 백엔드 런타임에서만 처리한다.
- (RULE-010) 모델/버전 임의 변경 금지: tech-stack 고정.

**잠재적 리스크**:

- 로컬에서 Vertex 인증 설정이 어려워 개발이 막힐 수 있음 → mock 모드(모의 Orchestrator)와 병행해 UI 개발이 멈추지 않게 한다.

## 페어링 질문 (결정 필요)

- [ ] **Q1**: “실모델 vs 모의모드” 전환을 어떤 방식으로 둘까?
  - Option A: 환경변수 `UW_MODE=mock|real` (권장: 단순)
  - Option B: 요청 파라미터/헤더로 제어(데모에는 유리하지만 보안/운영 고려 필요)

## 참고 자료

- `vibe/tech-stack.md` - google-genai/모델 ID 고정
- `.cursor/rules/20-backend-orchestrator.mdc` - Vertex 인증/보안
- `.cursor/rules/00-core-critical.mdc` - RULE-007/010
</file>

<file path="vibe/unit-plans/U-020[Mvp].md">
# U-020[Mvp]: 프론트 이미지 Lazy Render(placeholder/폴백)

## 메타데이터

| 항목      | 내용        |
| --------- | ----------- |
| Unit ID   | U-020[Mvp]  |
| Phase     | MVP         |
| 예상 소요 | 60분        |
| 의존성    | U-010,U-019 |
| 우선순위  | ⚡ Critical |

## 작업 목표

Scene Canvas에 (조건부) 장면 이미지를 표시하되, 이미지 생성 지연/실패가 UX를 망치지 않도록 **Lazy loading + placeholder + 텍스트-only 폴백**을 구현한다.

**배경**: PRD는 “텍스트 우선 출력 + 이미지 Lazy Loading”을 핵심 UX로 요구한다. (PRD 6.3, RULE-008)

**완료 기준**:

- 이미지가 있을 때는 Scene Canvas에 렌더되고, 없거나 로딩 중이면 placeholder(또는 이전 이미지 유지)가 표시된다.
- 이미지 실패 시에도 핫스팟/패널/로그는 계속 동작하며, 텍스트-only로 안전하게 진행된다. (RULE-004)
- 핫스팟 오버레이는 이미지 유무와 무관하게 정확히 렌더된다(좌표 정규화 유지). (RULE-009)

## 영향받는 파일

**생성**:

- (선택) `frontend/src/components/SceneImage.tsx` - 이미지 로딩/에러/placeholder 처리 분리

**수정**:

- `frontend/src/components/SceneCanvas.tsx` - 이미지 레이어 + 핫스팟 레이어 결합
- `frontend/src/style.css` - 이미지/placeholder/로딩 상태 스타일

**참조**:

- `vibe/prd.md` 6.3 - 텍스트 우선 + Lazy 이미지 정책
- `.cursor/rules/00-core-critical.mdc` - RULE-004/008/009

## 구현 흐름

### 1단계: 이미지 상태 모델 확정

- 상태 최소:
  - `current_scene_image_url` (또는 `image_job_id`)
  - `loading/error` 플래그
- 이미지가 없는 경우에도 SceneCanvas가 빈 공간이 아니라 “장면 프레임”을 유지한다.

### 2단계: Lazy loading + placeholder 구현

- 이미지 로딩 동안 placeholder를 보여주고, 로딩 완료 시 교체한다.
- 실패 시에는 오류 배지를 표시하되, 게임 진행을 막지 않는다(텍스트-only). (RULE-004)

### 3단계: 핫스팟 오버레이 정합 유지

- 이미지가 바뀌어도 box_2d는 정규화 값으로 유지하고, 렌더 시 캔버스 크기에 맞춰 변환한다.

## 의존성 & 연결

**이전 작업에서 가져올 것**:

- **계획서**: [U-010[Mvp]](U-010[Mvp].md) - Hotspot overlay 렌더/좌표 변환
- **계획서**: [U-019[Mvp]](U-019[Mvp].md) - 이미지 생성 엔드포인트/잡

**다음 작업에 전달할 것**:

- U-022(Scanner 슬롯)에서 “이미지 기반 상호작용”이 추가되어도 Canvas UX가 흔들리지 않는 기반
- CP-MVP-03 데모에서 “이미지 실패해도 진행되는” 안정성 증거

## 주의사항

**기술적 고려사항**:

- (RULE-008) 이미지 생성은 느릴 수 있으므로, 텍스트/단계/배지가 먼저 보여야 한다.
- 이미지 레이어가 오버레이 클릭/드래그를 가로채지 않도록 레이어링을 조절한다.

**잠재적 리스크**:

- 이미지 로딩 상태가 길면 “멈춤”으로 인식될 수 있음 → Agent Console/상태 라벨로 “지연 작업 진행 중”을 사용자 친화적으로 표시한다.

## 페어링 질문 (결정 필요)

- [ ] **Q1**: 이미지가 새로 오기 전까지 “이전 이미지 유지”를 할까?
  - Option A: 유지한다(권장: 화면 안정, 깜빡임 감소)
  - Option B: 항상 placeholder로 전환한다(상태는 명확, 하지만 깜빡임 가능)

## 참고 자료

- `vibe/prd.md` - Lazy 이미지 정책
- `.cursor/rules/00-core-critical.mdc` - RULE-004/008/009
</file>

<file path="vibe/unit-plans/U-021[Mvp].md">
# U-021[Mvp]: 이미지 이해(Scanner) 백엔드 엔드포인트

## 메타데이터

| 항목      | 내용       |
| --------- | ---------- |
| Unit ID   | U-021[Mvp] |
| Phase     | MVP        |
| 예상 소요 | 75분       |
| 의존성    | U-016      |
| 우선순위  | High       |

## 작업 목표

사용자가 업로드한 이미지를 분석(캡션/오브젝트 bbox 등)해 “단서/아이템 후보”로 변환하는 **Scanner 백엔드 엔드포인트**를 구현한다.

**배경**: PRD는 Scanner 슬롯(이미지 드랍/업로드)을 데모 표면 핵심으로 요구하며, bbox 좌표 규약은 0~1000 정규화 + `[ymin,xmin,ymax,xmax]` 고정이다. (PRD 6.7, RULE-009)

**완료 기준**:

- 이미지 업로드 요청을 받아 캡션/오브젝트(선택: bbox 포함) 결과를 JSON으로 반환한다.
- bbox는 반드시 0~1000 정규화 + `[ymin,xmin,ymax,xmax]`를 준수한다. (RULE-009)
- 실패/차단 시에도 스키마 준수 + 안전한 대체 결과(예: 텍스트-only 캡션)로 응답한다. (RULE-004)

## 영향받는 파일

**생성**:

- `backend/src/unknown_world/api/scanner.py` - 이미지 업로드 엔드포인트(예: `/api/scan`)
- `backend/src/unknown_world/services/image_understanding.py` - 비전 호출/후처리(bbox 정규화 포함)
- (선택) `backend/src/unknown_world/models/scanner.py` - Scanner 응답 모델(Pydantic)

**수정**:

- `backend/src/unknown_world/main.py` - 라우터 등록

**참조**:

- `vibe/prd.md` 8.6/6.7 - 이미지 이해/Scanner 요구
- `.cursor/rules/00-core-critical.mdc` - RULE-004/007/009
- `vibe/tech-stack.md` - 비전 모델/Files API 입력 방식 참고

## 구현 흐름

### 1단계: 업로드/응답 계약 확정

- 입력: 이미지 파일(multipart) + (선택) `language`
- 출력(최소): `caption`, `objects[] { label, box_2d }`, `item_candidates[]`
- 파일 크기/타입 제한을 두고, 제한 초과 시 안전한 오류 응답을 반환한다.

### 2단계: 비전 호출 + bbox 정규화/검증

- 비전 모델(FAST 라벨)을 사용해 캡션/오브젝트를 추출한다(모델 고정은 tech-stack 준수).
- bbox는 항상 0~1000 정규화 + `[ymin,xmin,ymax,xmax]`로 저장/반환한다.

### 3단계: 실패/안전 폴백

- 모델 호출 실패/안전 차단 시:
  - `objects=[]`, `caption`만 제공 등 텍스트-only 폴백
  - UI가 계속 진행 가능한 형태로 응답한다. (RULE-004)

## 의존성 & 연결

**이전 작업에서 가져올 것**:

- **계획서**: [U-016[Mvp]](U-016[Mvp].md) - GenAI 클라이언트/인증/모델 라벨

**다음 작업에 전달할 것**:

- U-022에서 Scanner 슬롯 UI가 결과를 받아 아이템화/인벤토리 반영할 수 있는 API
- RU-006에서 정리할 media 저장/제한/보안 기준

## 주의사항

**기술적 고려사항**:

- (RULE-007) 업로드된 파일/자격증명/프롬프트를 로그에 남기지 않는다(메타만).
- (RULE-009) bbox 포맷/좌표계 혼용 금지.

**잠재적 리스크**:

- 업로드/처리 시간이 길어 UX가 끊길 수 있음 → 프론트에서 진행 표시/비동기 처리(U-022)와 함께 설계한다.

## 페어링 질문 (결정 필요)

- [ ] **Q1**: MVP에서 이미지 입력 처리 방식은?
  - Option A: multipart 업로드로 처리(권장: 단순)
  - Option B: Files API 업로드 + URI 참조(대용량/재사용에 유리, 구현 부담↑)

## 참고 자료

- `vibe/prd.md` - Scanner/이미지 이해 요구
- `.cursor/rules/00-core-critical.mdc` - RULE-004/007/009
</file>

<file path="vibe/unit-plans/U-022[Mvp].md">
# U-022[Mvp]: Scanner 슬롯 UI + 업로드→아이템화 반영

## 메타데이터

| 항목      | 내용        |
| --------- | ----------- |
| Unit ID   | U-022[Mvp]  |
| Phase     | MVP         |
| 예상 소요 | 75분        |
| 의존성    | U-011,U-021 |
| 우선순위  | ⚡ Critical |

## 작업 목표

Scanner 슬롯(드랍존)을 UI에 추가하고, 이미지 업로드→분석 결과를 “아이템/단서”로 인벤토리에 반영해 멀티모달 조작을 데모에서 바로 보여준다.

**배경**: PRD는 “이미지 드랍/업로드 → 아이템/단서화”를 데모 표면 핵심으로 요구한다. (PRD 6.7)

**완료 기준**:

- Scanner 슬롯이 상시 노출되고, 이미지 드롭/업로드가 동작한다.
- 업로드 진행/실패/성공 상태가 UI로 명확히 표시된다(무반응 금지).
- 분석 결과(item_candidates)가 인벤토리에 추가되고, 사용자가 다음 턴에서 드래그/사용할 수 있다.

## 영향받는 파일

**생성**:

- `frontend/src/components/ScannerSlot.tsx` - 드랍존/업로드 UI + 결과 표시
- `frontend/src/api/scanner.ts` - 업로드 API 호출 래퍼

**수정**:

- `frontend/src/App.tsx` - Scanner 슬롯 배치(고정 패널)
- `frontend/src/stores/inventoryStore.ts` - 결과 아이템 추가 로직(필요 시)
- `frontend/src/style.css` - 드랍존/상태/에러 스타일

**참조**:

- `vibe/prd.md` 6.7/8.6 - Scanner/이미지 이해 요구
- `.cursor/rules/10-frontend-game-ui.mdc` - 업로드/조작이 눈에 보이게
- `.cursor/rules/00-core-critical.mdc` - RULE-002/004/009

## 구현 흐름

### 1단계: Scanner 슬롯 UI(드랍/업로드) 구현

- 드랍존에 이미지 파일을 드롭하거나 파일 선택으로 업로드할 수 있게 한다.
- 업로드 중 상태(loading), 실패(error), 성공(success)을 명확히 표시한다.

### 2단계: 백엔드 스캐너 API 연동

- U-021의 `/api/scan` 호출로 캡션/오브젝트/아이템 후보를 받아온다.
- bbox/라벨을 UI에서 그대로 보여주되, 좌표 규약은 변환하지 않고 정규화 값으로 보존한다. (RULE-009)

### 3단계: 아이템화(인벤토리 반영) + 즉시 조작 가능하게

- 후보 아이템을 인벤토리에 추가하고, 즉시 드래그 가능한 아이템으로 표시한다(U-011).
- (선택) 사용자 확인(승인) 후 추가할지, 자동 추가할지 정책을 정한다(페어링 질문).

## 의존성 & 연결

**이전 작업에서 가져올 것**:

- **계획서**: [U-021[Mvp]](U-021[Mvp].md) - Scanner 백엔드 엔드포인트
- **계획서**: [U-011[Mvp]](U-011[Mvp].md) - Inventory(DnD) 기반

**다음 작업에 전달할 것**:

- RU-006에서 media/artifacts 저장/제한/보안 정책을 정리할 근거
- CP-MVP-03에서 “업로드 조작” 데모 케이스로 사용

## 주의사항

**기술적 고려사항**:

- (RULE-002) 업로드 결과를 채팅 메시지로만 보여주지 말고, 인벤토리/패널 변화로 “게임 시스템”임을 증명한다.
- (RULE-004) 실패 시에도 안전한 대체 결과를 표시하고, 플레이를 막지 않는다.

**잠재적 리스크**:

- 업로드 파일 크기/형식 문제로 실패가 잦을 수 있음 → 허용 포맷/제한을 UI에 명확히 안내하고, 실패 시 재시도 UX를 제공한다.

## 페어링 질문 (결정 필요)

- [ ] **Q1**: Scanner 결과 아이템을 자동으로 인벤토리에 넣을까?
  - Option A: 자동 추가(데모 빠름, 오염 가능)
  - Option B: 사용자 확인 후 추가(권장: 의도 통제, UX는 1단계 추가)

## 참고 자료

- `vibe/prd.md` - Scanner 슬롯 요구
- `.cursor/rules/10-frontend-game-ui.mdc` - 조작/피드백 UI 원칙
- `.cursor/rules/00-core-critical.mdc` - RULE-002/004/009
</file>

<file path="vibe/unit-plans/U-025[Mvp].md">
# U-025[Mvp]: 엔딩 리포트 아티팩트 생성(요약/타임라인/결산)

## 메타데이터

| 항목      | 내용        |
| --------- | ----------- |
| Unit ID   | U-025[Mvp]  |
| Phase     | MVP         |
| 예상 소요 | 75분        |
| 의존성    | U-018,U-015 |
| 우선순위  | High        |

## 작업 목표

세션이 엔딩(또는 데모 종료 조건)에 도달했을 때, 플레이 로그 기반으로 **엔딩 리포트 아티팩트**(요약/룰 변형 타임라인/경제 결산/대표 이미지 링크)를 생성한다.

**배경**: PRD는 “동적 엔딩 생성기”와 “아티팩트(리포트/이미지/로그)”를 시스템의 필수 요소로 요구한다. (PRD 6.5, RULE-001)

**완료 기준**:

- 엔딩 조건(데모용이라도)을 만족하면 “엔딩 리포트”가 생성되어 UI에서 열람/저장 가능하다.
- 리포트에는 최소 다음이 포함된다:
  - 내러티브 요약(언어 고정)
  - 룰 변형 타임라인(핵심 이벤트)
  - 퀘스트 달성도(완료율) 또는 주요 목표 결과
  - 재화 결산(ledger 기반)
- 이미지가 없거나 실패해도 텍스트-only 리포트로 완료된다. (RULE-004)

## 영향받는 파일

**생성**:

- `backend/src/unknown_world/artifacts/ending_report.py` - 엔딩 리포트 생성기(데이터 조합/요약)
- `frontend/src/components/EndingReportModal.tsx` - 리포트 표시 UI
- `frontend/src/stores/artifactsStore.ts` - (선택) 아티팩트 상태/리포트 저장

**수정**:

- `frontend/src/App.tsx` - 엔딩 상태 감지/리포트 UI 오픈/저장 연결
- `frontend/src/save/saveGame.ts` - (필요 시) 엔딩 리포트 메타 저장

**참조**:

- `vibe/prd.md` 6.5 - 동적 엔딩 생성기 요구
- `.cursor/rules/00-core-critical.mdc` - RULE-001/004/006/005

## 구현 흐름

### 1단계: 엔딩 조건과 리포트 데이터 소스 확정

- MVP에서는 데모용 “엔딩 트리거”를 정의한다(예: 특정 퀘스트 완료/턴 수/사용자 종료 버튼).
- 데이터 소스는 SaveGame/WorldState/history/economy ledger에서 가져온다.

### 2단계: 리포트 생성(서버 또는 클라) 결정

- 서버 생성 시: 요약/정합성을 중앙에서 보장 가능
- 클라 생성 시: MVP 단순하지만 모델 호출/검증 경계가 애매해질 수 있음  
  → 기본 권장: 서버에서 생성(스키마/언어/경제 정합성 유지)

### 3단계: UI 표시/저장(아티팩트화)

- 리포트를 “게임 아티팩트”로 보여주고, SaveGame에 링크(또는 본문)를 저장한다.
- 리포트에서 “10분 데모 루프”의 핵심 증거(룰 변형/경제/검증 배지)를 한눈에 확인 가능하게 한다.

## 의존성 & 연결

**이전 작업에서 가져올 것**:

- **계획서**: [U-015[Mvp]](U-015[Mvp].md) - SaveGame/ledger/히스토리
- **계획서**: [U-018[Mvp]](U-018[Mvp].md) - 검증/언어/경제 인바리언트

**다음 작업에 전달할 것**:

- U-026에서 리플레이/회귀 시 “기대 아티팩트”로 활용할 엔딩 리포트
- CP-MVP-03에서 데모 종료 시 “결과물”로 제출/설득에 사용

## 주의사항

**기술적 고려사항**:

- (RULE-006) 리포트 언어는 TurnInput.language와 동일하게 고정한다(혼합 금지).
- (RULE-005) 결산은 ledger 기반이며, 비용/잔액 불일치가 있으면 리포트 생성 시점에라도 표시/복구한다.

**잠재적 리스크**:

- 리포트가 너무 길어지면 가독성이 떨어짐 → MVP는 핵심 카드(요약/타임라인/결산) 중심으로 “짧고 강한” 형태로 유지한다.

## 페어링 질문 (결정 필요)

- [ ] **Q1**: 엔딩 리포트 생성 위치는?
  - Option A: 서버 생성(권장: 검증/정합성, 추후 저장 확장 용이)
  - Option B: 클라 생성(초기 단순, 하지만 기준선 흔들림)

## 참고 자료

- `vibe/prd.md` - 엔딩 리포트/아티팩트 요구
- `.cursor/rules/00-core-critical.mdc` - RULE-001/004/005/006
</file>

<file path="vibe/unit-plans/U-026[Mvp].md">
# U-026[Mvp]: 리플레이/시나리오 하네스(저장+수동 러너)

## 메타데이터

| 항목      | 내용        |
| --------- | ----------- |
| Unit ID   | U-026[Mvp]  |
| Phase     | MVP         |
| 예상 소요 | 75분        |
| 의존성    | U-024,U-025 |
| 우선순위  | ⚡ Critical |

## 작업 목표

대표 데모 시나리오를 seed+액션 시퀀스로 저장하고, 동일 액션을 재실행하는 **리플레이 하네스(수동 러너)** 를 구축해 회귀(regression)를 지속적으로 잡을 수 있게 한다.

**배경**: PRD는 “지속적으로 데모 테스트를 직접 할 수 있도록” replay/scenario harness를 핵심 개발 방식으로 요구한다. (PRD 10.3)

**완료 기준**:

- 시나리오 파일이 `seed + actions + invariants` 형태로 저장된다.
- 수동 러너(스크립트/버튼)가 시나리오를 재실행해 Hard Gate 인바리언트(스키마/경제/안전/일관성)를 점검할 수 있다.
- 결과로 WorldState diff(최소) 또는 체크 결과가 아티팩트로 남는다(프롬프트 원문/내부 추론은 제외). (RULE-008)

## 영향받는 파일

**생성**:

- `backend/src/unknown_world/replay/scenario_types.py` - 시나리오 모델(Pydantic, seed/actions/invariants)
- `backend/src/unknown_world/replay/scenario_library/` - 대표 시나리오 파일(예: json)
- `backend/src/unknown_world/replay/runner.py` - 수동 러너(시나리오 실행)
- `frontend/src/components/ReplayRunnerPanel.tsx` - (선택) 데모 모드에서 실행 버튼/결과 표시

**수정**:

- 없음(연동은 선택)

**참조**:

- `vibe/prd.md` 10.3 - Replay & Scenario Harness 요구
- `.cursor/rules/00-core-critical.mdc` - RULE-008/004/005
- `.gemini/GEMINI.md` (observability-replay rules) - scenario 형태/체크리스트

## 구현 흐름

### 1단계: 시나리오 포맷 정의(seed+actions+invariants)

- actions 예: `text`, `click(object_id, box_2d?)`, `drag(item_id → object_id)`, `upload(image)` 등
- invariants 예: `schema_valid`, `economy_non_negative`, `safety_fallback_present`, `bbox_format_ok`

### 2단계: 수동 러너 구현

- 시나리오를 순차 실행하며 각 턴마다:
  - TurnOutput 스키마 검증 결과
  - economy 잔액 음수 여부
  - blocked/폴백 존재 여부
  - bbox 규약 위반 여부
    를 체크한다.
- 실패 시 어느 단계에서 깨졌는지(턴 번호/인바리언트)만 기록한다(프롬프트 원문 금지).

### 3단계: 결과 아티팩트 생성

- 러너 결과를 `unit-results` 또는 runtime artifacts로 저장한다:
  - 요약: pass/fail, 실패 원인, 첫 실패 턴
  - (선택) WorldState diff 요약

## 의존성 & 연결

**이전 작업에서 가져올 것**:

- **계획서**: [U-024[Mvp]](U-024[Mvp].md) - Autopilot(자동 액션 시퀀스) 실행 흐름
- **계획서**: [U-025[Mvp]](U-025[Mvp].md) - 엔딩 리포트 아티팩트(결과물 검증)

**다음 작업에 전달할 것**:

- RU-007에서 정리할 artifacts 경로/버전/링크 표준
- MMP의 U-105(Scenario Library 확장)로 자연스럽게 확장되는 기반

## 주의사항

**기술적 고려사항**:

- (RULE-008) 관측/리플레이는 “증거”지만 프롬프트 원문/내부 추론은 기록하지 않는다.
- (RULE-004) 비결정성은 인정하되, 인바리언트는 항상 만족해야 한다(텍스트 내용은 달라도 됨).

**잠재적 리스크**:

- 멀티모달 업로드(이미지)는 자동화가 어려울 수 있음 → MVP는 텍스트/클릭/드래그 중심 시나리오부터 시작하고 업로드는 수동 보조로 둔다.

## 페어링 질문 (결정 필요)

- [ ] **Q1**: 시나리오 저장 위치/형식은?
  - Option A: `backend/src/unknown_world/replay/scenario_library/*.json` (권장: 단순/명확)
  - Option B: `vibe/unit-runbooks/`에 사람이 읽는 형태로 저장(문서 친화, 실행 자동화는 별도 필요)

## 참고 자료

- `vibe/prd.md` - Replay/Scenario Harness
- `.cursor/rules/00-core-critical.mdc` - RULE-004/005/008
</file>

<file path="vibe/unit-plans/U-027[Mvp].md">
# U-027[Mvp]: 개발 스크립트 - pnpm kill 포트 제한(8001~8020)

## 메타데이터

| 항목      | 내용       |
| --------- | ---------- |
| Unit ID   | U-027[Mvp] |
| Phase     | MVP        |
| 예상 소요 | 30분       |
| 의존성    | RU-001[Mvp] |
| 우선순위  | High       |

## 작업 목표

루트 `pnpm kill` 스크립트가 **node.exe 전체를 종료**하여 다른 프로젝트까지 영향을 주는 문제를 제거하고, RULE-011 포트 정책(8001~8020)에 맞춰 **현재 프로젝트 포트만 정리**하도록 제한한다.

**배경**: 개발 서버 포트 정책(RULE-011)을 도입한 이유는 “충돌 방지 + kill 단순화”인데, 현 `pnpm kill`은 프로세스 단위로 과도하게 종료해 규칙 의도와 반대로 동작한다.

**완료 기준**:

- `pnpm kill`이 더 이상 `node.exe` 전체를 종료하지 않고, **8001~8020 포트 범위의 프로세스만** 종료한다.
- `pnpm kill:port`가 실제로 프론트(8001~8010) / 백엔드(8011~8020) 개발 서버를 안정적으로 정리한다(다른 포트/프로세스는 영향 없음).
- 스크립트/문서(로드맵/아키텍처)에서 “kill” 사용 안내가 SSOT(`package.json scripts`)와 모순되지 않는다.

## 영향받는 파일

**생성**:

- 없음

**수정**:

- `package.json` - `scripts.kill`을 포트 기반 정리로 변경(필요 시 `kill:unsafe` 분리)
- (선택) `vibe/roadmap.md` - 빠른 실행의 kill 안내를 최신 동작과 정합화
- (선택) `vibe/architecture.md` - 실행/도구 SSOT 설명에서 kill 정책 주석 보강

**참조**:

- `.cursor/rules/00-core-critical.mdc` - RULE-011(포트 정책) 및 “SSOT: package.json scripts”
- `vibe/roadmap.md` - 빠른 실행/포트 정리 가이드

## 구현 흐름

### 1단계: 목표 동작(안전한 kill) 확정

- `pnpm kill`은 “프로젝트 개발 포트 정리”의 **안전한 별칭**이어야 한다.
- 포트 범위는 RULE-011을 따른다: 프론트 8001~8010, 백엔드 8011~8020.

### 2단계: 스크립트 변경

- `package.json`의 `scripts.kill`에서 `taskkill /IM node.exe` 같은 광역 종료를 제거한다.
- `kill:port`(또는 `kill:front` + `kill:back`)를 호출하도록 연결한다.
- (권장) `npx`가 설치 확인 프롬프트로 멈추지 않게 `--yes` 옵션을 고려한다(팀 표준 합의 필요).

### 3단계: 수동 검증(안전성 확인)

- 다른 프로젝트의 Node 프로세스(포트 대역 외)를 띄운 상태에서 `pnpm kill` 실행 → **영향이 없는지** 확인한다.
- `pnpm dev:front`, `pnpm dev:back` 실행 후 `pnpm kill`로 정리되는지 확인한다.

## 의존성 & 연결

**이전 작업에서 가져올 것**:

- **계획서**: [RU-001[Mvp]](RU-001[Mvp].md) - 포트 정책(RULE-011) 정합화 및 `kill:port` 스크립트 기반

**다음 작업에 전달할 것**:

- 개발 중 “포트 충돌/정리” 때문에 흐름이 끊기지 않는 안정적인 실행 루틴(특히 U-007/U-008 스트리밍 개발에 유리)

## 주의사항

**기술적 고려사항**:

- kill 범위는 반드시 RULE-011 포트 대역(8001~8020)으로 제한한다(다른 프로젝트 영향 금지).
- OS/쉘 차이를 피하려면 “프로세스명 kill”보다 “포트 기반 kill”을 우선한다.

**잠재적 리스크**:

- `npx kill-port`가 환경에 따라 프롬프트로 멈출 수 있음 → `--yes` 도입 여부를 합의하고, 런북에 예외 대응(수동 kill 방법)을 남긴다.

## 페어링 질문 (결정 필요)

- [ ] **Q1**: 기존 `pnpm kill`(광역 종료) 동작을 어떻게 처리할까?
  - Option A: `pnpm kill`을 안전한 포트 기반 정리로 변경하고, 광역 종료는 제거(권장: 안전)
  - Option B: `pnpm kill`은 안전하게 바꾸되, 기존 동작은 `pnpm kill:unsafe`로 분리(팀 합의 시)
  **A1**: Option A

## 참고 자료

- `.cursor/rules/00-core-critical.mdc` - RULE-011(포트 정책)
- `vibe/roadmap.md` - 빠른 실행/포트 정리
- `package.json` - scripts SSOT
</file>

<file path="vibe/unit-plans/U-028[Mvp].md">
# U-028[Mvp]: UI 가독성 패스(폰트 스케일/효과 토글/대비)

## 메타데이터

| 항목      | 내용        |
| --------- | ----------- |
| Unit ID   | U-028[Mvp]  |
| Phase     | MVP         |
| 예상 소요 | 45분        |
| 의존성    | U-004,U-008 |
| 우선순위  | High        |

## 작업 목표

현재 UI의 “작은 글씨/과한 CRT 효과”로 인한 가독성 문제를 해결하기 위해, **전역 UI 스케일(폰트)** 과 **Readable 모드(효과 완화)** 를 도입한다.

**배경**: 데모/플레이에서 텍스트가 읽히지 않으면 “시스템이 작동한다”는 증거(Agent Console/배지/퀘스트/경제)가 전달되지 않는다. CRT 미학은 유지하되, **가독성은 Hard Gate에 준하는 데모 품질**로 취급한다.

**완료 기준**:

- 전역 UI 스케일(예: 0.9/1.0/1.1/1.2)을 조절할 수 있고, 새로고침 후에도 설정이 유지된다(로컬 저장).
- Readable 모드 토글로 스캔라인/플리커/글로우 등 “읽기 방해 요소”가 완화되며, 기본 테마(다크)에서 시인성이 개선된다.
- 최소 글자 크기 가이드가 적용된다(예: Agent Console/배지/타임스탬프 같은 마이크로 텍스트가 너무 작지 않음).

## 영향받는 파일

**생성**:

- (권장) `frontend/src/stores/uiPrefsStore.ts` - UI 스케일/Readable 모드 상태 + persist(localStorage)

**수정**:

- `frontend/src/style.css` - 폰트/라인하이트/CRT 효과 토큰 및 Readable 모드 스타일 추가
- `frontend/src/App.tsx` - Header에 UI 스케일/Readable 토글(간단 버튼/토글) 추가, DOM에 설정 적용

**참조**:

- `vibe/prd.md` - 9.4 접근성/입력, 9.5 CRT 효과(상호작용 방해 금지), 6.7/6.8 데모 표면 요구
- `vibe/ref/frontend-style-guide.md` - CRT 테마 SSOT 규칙/톤
- `frontend/src/style.css` - 현재 `0.625rem~0.75rem` 기반 마이크로 텍스트 구간(Agent Console/배지 등)

## 구현 흐름

### 1단계: UI 설정(스케일/Readable) 상태 정의

- `uiScale`(number or enum)과 `readableMode`(boolean)를 정의한다.
- MVP에서는 로컬 저장(예: localStorage)으로 유지하고, SaveGame과의 통합은 후속 유닛에서 고려한다.

### 2단계: DOM 적용(SSOT: CSS 변수/데이터 속성)

- `html` 또는 `body`에 `data-ui-scale`, `data-readable` 같은 속성을 부여하거나,
- `--font-size-base`, `--glow-intensity`, `--crt-flicker` 같은 CSS 변수를 런타임에서 조절한다.

### 3단계: UI 컨트롤(헤더) 배치

- Header(`frontend/src/App.tsx`의 `GameHeader`)에 “A-/A+” 또는 드롭다운 형태로 스케일을 조절할 수 있게 한다.
- Readable 모드 토글을 추가한다(시각적으로는 버튼/스위치, 접근성은 `aria-pressed` 등으로 보완).

### 4단계: 마이크로 텍스트 기준 상향(선별 적용)

- `.agent-console-content`, `.badge-item`, `.narrative-timestamp` 등 작은 텍스트 영역을 중심으로,
  “너무 작은 rem 값”을 변수 기반(예: `--font-size-sm`)으로 올리고, Readable 모드에서 추가 상향한다.

## 의존성 & 연결

**이전 작업에서 가져올 것**:

- **계획서**: [U-004[Mvp]](U-004[Mvp].md) - CRT 테마/고정 레이아웃 스켈레톤(CSS SSOT)
- **계획서**: [U-008[Mvp]](U-008[Mvp].md) - Agent Console(단계/배지/복구) 표시(가독성 영향 범위)

**다음 작업에 전달할 것**:

- U-009~U-015(핵심 UI)에서 사용할 “기본 타이포/가독성 토큰(SSOT)”
- U-029(nanobanana mcp 에셋)에서 아이콘/배지의 ‘읽힘’ 기준선(스케일/Readable 연동)

## 주의사항

**기술적 고려사항**:

- CRT 효과는 “미학”이지만, `pointer-events: none` 및 과도한 깜빡임/글로우로 가독성을 해치지 않게 한다. (PRD 9.5)
- RULE-002(채팅 UI 금지) 준수: 가독성 개선이 “채팅 버블/메신저 UI”로 변형되는 변경은 금지한다.

**잠재적 리스크**:

- 스케일을 과도하게 올리면 레이아웃이 깨질 수 있음 → 스케일 범위를 제한하고(예: 0.9~1.2), 브레이크포인트(768px)에서만 별도 보정한다.

## 페어링 질문 (결정 필요)

- [ ] **Q1**: UI 설정(스케일/Readable) 저장 위치는 어디가 SSOT가 좋을까?
  - Option A: localStorage(persist) - MVP에서 빠르고 단순(권장)
  - Option B: SaveGame에 포함 - 세션/디바이스 간 일관(하지만 SaveGame/Reset 설계 영향)
  **A1**: Option B

## 참고 자료

- `vibe/prd.md` - 9.4 접근성/입력, 9.5 CRT 효과
- `vibe/ref/frontend-style-guide.md` - CRT 테마 스타일 가이드
- `frontend/src/style.css` - 타이포/효과 토큰(SSOT)
</file>

<file path="vibe/unit-plans/U-100[Mmp].md">
# U-100[Mmp]: Dockerfile/로컬 실행(프론트/백엔드)

## 메타데이터

| 항목      | 내용        |
| --------- | ----------- |
| Unit ID   | U-100[Mmp]  |
| Phase     | MMP         |
| 예상 소요 | 75분        |
| 의존성    | CP-MVP-03   |
| 우선순위  | ⚡ Critical |

## 작업 목표

프론트/백엔드를 Docker 기반으로 로컬에서 동일하게 실행할 수 있도록 구성해, 데모/검증 환경을 표준화한다.

**배경**: 배포 전 단계에서 로컬 실행 환경이 흔들리면 회귀 검증이 어려워진다. 또한 Secret/권한을 안전하게 분리하기 위한 컨테이너화가 필요하다. (RULE-007)

**완료 기준**:

- 프론트/백엔드 각각(또는 compose)로 Docker 실행이 가능하다.
- 로컬 실행 시에도 프롬프트 원문/키/토큰이 로그/UI에 노출되지 않는다. (RULE-007/008)
- 개발자 런북(명령/포트/환경변수)이 명확해진다(문서/README 또는 runbook).

## 영향받는 파일

**생성**:

- `frontend/Dockerfile` - 프론트 빌드/서빙
- `backend/Dockerfile` - 백엔드 실행(FastAPI)
- (선택) `docker-compose.yml` - 로컬 통합 실행
- (선택) `vibe/unit-runbooks/U-100[Mmp].md` - 로컬 실행 런북

**수정**:

- 없음(기존 설정과 충돌 시 최소 수정)

**참조**:

- `vibe/tech-stack.md` - Node/Python 런타임 버전
- `.cursor/rules/00-core-critical.mdc` - RULE-007/010

## 구현 흐름

### 1단계: 컨테이너 경계/환경변수 정리

- 프론트: 정적 빌드/서빙(또는 dev 서버 컨테이너) 전략 선택
- 백엔드: Uvicorn 실행, Vertex 인증은 런타임 권한/secret로만 주입

### 2단계: Dockerfile 작성(버전 고정)

- Node 24.12.0, Python 3.14.0 기반으로 이미지 구성(tech-stack SSOT).
- 빌드 캐시/의존성 설치 최적화(필요 최소) 적용

### 3단계: 로컬 실행/검증 루프 연결

- “데모 10분 루프(CP-MVP-03)”를 컨테이너 환경에서도 재현할 수 있도록 런북을 남긴다.

## 의존성 & 연결

**이전 작업에서 가져올 것**:

- **체크포인트**: [CP-MVP-03](CP-MVP-03.md) - 데모 루프 기준선

**다음 작업에 전달할 것**:

- U-101에서 Cloud Run 배포 구성으로 확장할 컨테이너 기반
- U-105 자동 리플레이/회귀 실행 시 “표준 실행 환경”

## 주의사항

**기술적 고려사항**:

- (RULE-007) Secret은 이미지에 bake-in 금지: 런타임 주입만.
- (RULE-010) “최신” 베이스 이미지로 임의 변경 금지: tech-stack 기준 유지.

**잠재적 리스크**:

- 컨테이너화가 초기엔 느릴 수 있음 → 데모 안정성/재현성 이득이 크므로 MMP에서 수행한다.

## 페어링 질문 (결정 필요)

- [ ] **Q1**: 로컬 실행은 compose로 단일 명령을 목표로 할까?
  - Option A: compose 단일 실행(권장: 데모/검증 단순)
  - Option B: 프론트/백엔드 개별 실행(유연하지만 진입장벽↑)

## 참고 자료

- `vibe/tech-stack.md` - 런타임/배포 기준
- `.cursor/rules/00-core-critical.mdc` - RULE-007/010
</file>

<file path="vibe/unit-plans/U-101[Mmp].md">
# U-101[Mmp]: Cloud Run 배포 구성 + env/secret 가이드

## 메타데이터

| 항목      | 내용        |
| --------- | ----------- |
| Unit ID   | U-101[Mmp]  |
| Phase     | MMP         |
| 예상 소요 | 75분        |
| 의존성    | U-100       |
| 우선순위  | ⚡ Critical |

## 작업 목표

Cloud Run에 배포 가능한 형태로 백엔드(오케스트레이터)를 구성하고, Vertex 인증/환경변수/Secret 관리 가이드를 정리한다.

**배경**: MVP는 로컬 데모를 목표로 하지만, MMP에서는 “운영 가능한 데모”를 위해 배포/권한/secret 관리가 필요하다. (RULE-007)

**완료 기준**:

- Cloud Run에서 백엔드가 실행되고(헬스체크), 프론트가 이를 호출할 수 있다.
- 서비스 계정 권한(최소 권한)과 환경변수/secret 주입 방식이 문서화된다.
- BYOK(사용자 API 키 입력) 흐름이 포함되지 않는다. (RULE-007)

## 영향받는 파일

**생성**:

- (선택) `infra/cloud-run/` - 배포 스크립트/메모
- `vibe/unit-runbooks/U-101[Mmp].md` - 배포 런북(필수 권장)

**수정**:

- `backend/Dockerfile` - Cloud Run 실행에 맞는 엔트리/포트/헬스(필요 시)

**참조**:

- `vibe/tech-stack.md` - Cloud Run 권장, 서비스 계정 기반
- `.cursor/rules/00-core-critical.mdc` - RULE-007/010

## 구현 흐름

### 1단계: Cloud Run 실행 요구사항 정리

- 포트, 헬스 체크 경로, CORS, 타임아웃 등 기본 설정을 정한다.

### 2단계: IAM/서비스 계정 권한 최소화

- Vertex AI 호출에 필요한 권한만 부여한다(최소 권한).
- 키 파일을 배포 아티팩트에 포함하지 않는다(Cloud Run SA 권한 사용).

### 3단계: 런북 작성(재현 가능한 배포)

- 빌드→배포→검증(헬스/TTFB/기본 턴 실행) 절차를 런북으로 남긴다.

## 의존성 & 연결

**이전 작업에서 가져올 것**:

- **계획서**: [U-100[Mmp]](U-100[Mmp].md) - Docker 기반 표준 실행 환경

**다음 작업에 전달할 것**:

- CP-MMP-01에서 “배포/관측 게이트” 체크를 수행할 기반
- U-102(GCS) 연동을 위한 권한/환경 기반

## 주의사항

**기술적 고려사항**:

- (RULE-007) secret(키/토큰/쿠키) 로그 출력 금지: 배포 런북에도 민감값을 남기지 않는다.
- (RULE-010) 런타임/버전 임의 변경 금지: tech-stack 기준 유지.

**잠재적 리스크**:

- 권한 설정/네트워크로 배포가 지연될 수 있음 → 런북에 “필수 권한/진단 체크리스트”를 포함한다.

## 페어링 질문 (결정 필요)

- [ ] **Q1**: 프론트 배포는 어떻게 둘까?
  - Option A: 프론트는 정적 호스팅(별도) + 백엔드 Cloud Run(권장)
  - Option B: 프론트도 Cloud Run 컨테이너로 서빙(단순하지만 비용/캐시 전략 필요)

## 참고 자료

- `vibe/tech-stack.md` - Cloud Run/Vertex 인증
- `.cursor/rules/00-core-critical.mdc` - RULE-007/010
</file>

<file path="vibe/unit-plans/U-102[Mmp].md">
# U-102[Mmp]: GCS 스토리지 어댑터(이미지/아티팩트)

## 메타데이터

| 항목      | 내용        |
| --------- | ----------- |
| Unit ID   | U-102[Mmp]  |
| Phase     | MMP         |
| 예상 소요 | 75분        |
| 의존성    | U-100       |
| 우선순위  | ⚡ Critical |

## 작업 목표

로컬 스토리지(MVP)를 GCS로 확장해, 이미지/아티팩트(엔딩 리포트/리플레이 결과)를 안정적으로 저장/서빙할 수 있게 한다.

**배경**: 운영/배포 환경에서는 로컬 디스크가 휘발될 수 있으므로, Cloud Storage 기반이 필요하다. (tech-stack, RULE-010)

**완료 기준**:

- 스토리지 추상화(RU-006/RU-007)를 GCS 구현으로 확장할 수 있다.
- 이미지/아티팩트가 GCS에 저장되고, 프론트가 접근 가능한 URL/서빙 방식이 정해진다.
- 접근 제어/권한이 최소 권한으로 구성되고, 민감값이 로그/레포에 남지 않는다. (RULE-007)

## 영향받는 파일

**생성**:

- `backend/src/unknown_world/storage/gcs_storage.py` - GCS 스토리지 구현
- (선택) `backend/src/unknown_world/config/storage.py` - 버킷/경로 설정

**수정**:

- `backend/requirements.txt` - `google-cloud-storage==3.7.0` 추가(tech-stack 기준)
- `backend/src/unknown_world/storage/storage.py` - 스토리지 선택(로컬/GCS) 분기(필요 시)

**참조**:

- `vibe/tech-stack.md` - google-cloud-storage 버전/Cloud Run 배포
- `.cursor/rules/00-core-critical.mdc` - RULE-007/010

## 구현 흐름

### 1단계: 버킷/경로/권한 정책 확정

- 버킷 이름/폴더 구조(세션/턴/타입)를 확정한다.
- Cloud Run 서비스 계정에 버킷 접근 권한을 부여한다(키 파일 커밋 금지).

### 2단계: GCS 스토리지 구현

- put/get(또는 signed URL) 기반으로 업로드/다운로드를 구현한다.
- 반환 값은 URL/핸들 중심으로 하고, 내부 경로/민감 메타를 노출하지 않는다.

### 3단계: 기존 기능(이미지/아티팩트) 연결

- 이미지 생성/스캐너/리포트/리플레이 결과 저장 경로를 GCS로 전환한다.

## 의존성 & 연결

**이전 작업에서 가져올 것**:

- **계획서**: [RU-006[Mvp]](RU-006[Mvp].md) - storage 추상화(로컬)
- **계획서**: [RU-007[Mvp]](RU-007[Mvp].md) - artifacts 경로/버전 규칙

**다음 작업에 전달할 것**:

- U-103(이미지 편집), U-105(자동 리플레이)에서 필요한 안정적 에셋 저장 기반

## 주의사항

**기술적 고려사항**:

- (RULE-007) bucket/URL 설계에서 공개 범위를 최소화하고, 필요 시 signed URL을 고려한다.
- (RULE-010) 저장 방식을 DB로 바꾸는 방향 전환 금지: 파일/아티팩트 저장으로 유지.

**잠재적 리스크**:

- URL/권한 설계가 미흡하면 데모에서 이미지가 안 보일 수 있음 → 런북에 권한/접근 체크리스트 포함.

## 페어링 질문 (결정 필요)

- [ ] **Q1**: GCS 서빙 방식은?
  - Option A: 공개 read(데모 단순, 보안↓)
  - Option B: signed URL(권장: 보안↑, 구현/만료 관리 필요)

## 참고 자료

- `vibe/tech-stack.md` - GCS/Cloud Run
- `.cursor/rules/00-core-critical.mdc` - RULE-007/010
</file>

<file path="vibe/unit-plans/U-103[Mmp].md">
# U-103[Mmp]: 이미지 편집(멀티턴, REF 유지)

## 메타데이터

| 항목      | 내용        |
| --------- | ----------- |
| Unit ID   | U-103[Mmp]  |
| Phase     | MMP         |
| 예상 소요 | 75분        |
| 의존성    | U-019,U-102 |
| 우선순위  | High        |

## 작업 목표

이미지 생성 이후 “멀티턴 편집”을 지원해, 참조 이미지(REF) 기반으로 장면 일관성을 유지하며 수정할 수 있게 한다.

**배경**: PRD는 “대화형 편집(멀티턴)”과 장면 일관성을 요구하며, 이미지 모델은 `gemini-3-pro-image-preview`로 고정이다. (PRD 8.5, RULE-010)

**완료 기준**:

- 기존 장면 이미지 + 편집 지시를 입력으로 받아 수정 이미지를 생성할 수 있다.
- 모델/ID 혼용 없이 `gemini-3-pro-image-preview`만 사용한다. (RULE-010)
- 실패 시 텍스트-only로 진행 가능하며, UI는 “이미지 없이도 플레이”를 유지한다. (RULE-004)

## 영향받는 파일

**생성**:

- `backend/src/unknown_world/services/image_editing.py` - 이미지 편집 호출/저장
- `backend/src/unknown_world/api/image_edit.py` - 편집 요청 엔드포인트

**수정**:

- `frontend/src/components/SceneCanvas.tsx` - (선택) 편집 요청 UI 트리거(버튼/모달)
- `frontend/src/style.css` - (선택) 편집 UI 스타일

**참조**:

- `vibe/prd.md` 8.5 - 멀티턴 편집/일관성 요구
- `.cursor/rules/00-core-critical.mdc` - RULE-004/010/008

## 구현 흐름

### 1단계: 편집 요청 계약 정의

- 입력: `base_image`(URL/핸들), `edit_instruction`, (선택) `mask/region`
- 출력: `edited_image_url`, `status`, 실패 시 `message`

### 2단계: 참조 이미지/시그니처(멀티턴) 관리

- SDK 사용을 전제로 히스토리/참조를 유지해 일관성을 높인다(가능 범위).
- UI/로그에는 “REF 라벨” 같은 메타만 표시하고 프롬프트 원문은 숨긴다. (RULE-008)

### 3단계: 경제/폴백 연계

- 편집은 고비용일 수 있으므로 예상 비용/대안을 노출하는 정책을 연결한다(경제 시스템).
- 실패 시 `should_generate=false` 또는 이전 이미지 유지로 폴백한다.

## 의존성 & 연결

**이전 작업에서 가져올 것**:

- **계획서**: [U-019[Mvp]](U-019[Mvp].md) - 이미지 생성 엔드포인트/잡
- **계획서**: [U-102[Mmp]](U-102[Mmp].md) - GCS 스토리지(에셋 저장)

**다음 작업에 전달할 것**:

- U-104(장기 세션)에서 “장면 일관성”을 강화할 도구

## 주의사항

**기술적 고려사항**:

- (RULE-010) 이미지 모델 ID 고정: 다른 모델로 우회 금지.
- (RULE-008) 프롬프트/내부 추론 노출 금지: 메타 라벨만.

**잠재적 리스크**:

- 편집 UX가 복잡해질 수 있음 → MMP에서는 최소 “지시 기반 편집”만 제공하고, 영역 편집은 후순위로 둔다.

## 페어링 질문 (결정 필요)

- [ ] **Q1**: MMP에서 편집 UI를 어디에 둘까?
  - Option A: SceneCanvas 내 간단 버튼/모달(권장: 접근성)
  - Option B: 별도 “에셋 편집” 패널(확장 용이, UI 부담↑)

## 참고 자료

- `vibe/prd.md` - 이미지 편집/일관성 요구
- `.cursor/rules/00-core-critical.mdc` - RULE-004/008/010
</file>

<file path="vibe/unit-plans/U-104[Mmp].md">
# U-104[Mmp]: 장기 세션 메모리 요약/핀 추천 고도화

## 메타데이터

| 항목      | 내용       |
| --------- | ---------- |
| Unit ID   | U-104[Mmp] |
| Phase     | MMP        |
| 예상 소요 | 75분       |
| 의존성    | U-025      |
| 우선순위  | High       |

## 작업 목표

장기 세션에서 설정 붕괴/환각을 줄이기 위해, WorldState 요약과 Memory Pin 후보 추천을 고도화하고, 중요한 설정을 “고정”하는 흐름을 강화한다.

**배경**: PRD는 장시간 세션에서도 일관성을 유지하기 위한 메모리/요약/중요 설정 고정 체계를 요구한다. (PRD 2.2/6.7, RULE-001)

**완료 기준**:

- 일정 턴마다(또는 트리거 기반) WorldState 요약이 생성/갱신된다.
- Memory Pin 후보가 UI로 노출되고, 사용자가 Shard를 소비해 고정할 수 있다(경제 연동). (RULE-005)
- 고정된 설정은 다음 턴 입력에 일관되게 반영되며, 혼합 언어/좌표 규약 위반이 없다. (RULE-006/009)

## 영향받는 파일

**생성**:

- `backend/src/unknown_world/memory/summarize.py` - 요약 생성(선택: 모델 호출)
- `backend/src/unknown_world/memory/pins.py` - 핀 후보 추천/고정 로직
- `frontend/src/components/MemoryPinPanel.tsx` - 핀 후보/고정된 핀 UI

**수정**:

- `frontend/src/stores/economyStore.ts` - Shard 소비/가드(필요 시)
- `backend/src/unknown_world/orchestrator/*` - TurnInput 구성 시 핀/요약 주입(필요 시)

**참조**:

- `vibe/prd.md` 6.7 - Memory Pin UI 요구
- `.cursor/rules/00-core-critical.mdc` - RULE-005/006/004

## 구현 흐름

### 1단계: 요약/핀 데이터 모델 확정

- `summary`: 장기 기억(짧은 텍스트)
- `pins[]`: 고정된 사실(짧은 문장/키)
- `pin_candidates[]`: 후보 + Shard 비용 + 고정 시 효과

### 2단계: 추천/고정 UX 연결

- 후보를 UI에 칩 형태로 노출하고, 클릭 시 Shard 소비(가드 포함)로 고정한다.
- 잔액 부족 시 대안을 제공한다(고정 없이 진행/저비용 요약). (RULE-005)

### 3단계: 입력/출력 일관성 강화

- 고정 핀은 다음 TurnInput 컨텍스트에 강제 주입하여 일관성을 높인다.
- 실패/충돌 시 repair loop 또는 안전 폴백으로 처리한다. (RULE-004)

## 의존성 & 연결

**이전 작업에서 가져올 것**:

- **계획서**: [U-025[Mvp]](U-025[Mvp].md) - 엔딩 리포트/요약 데이터 흐름

**다음 작업에 전달할 것**:

- 장기 세션/Autopilot에서 “설정 붕괴”를 줄이는 핵심 기반
- U-105 시나리오 회귀에서 “핀/요약 인바리언트” 추가 가능

## 주의사항

**기술적 고려사항**:

- (RULE-006) 요약/핀도 언어 정책을 따라야 한다(혼합 금지).
- (RULE-005) 고정은 재화 소비를 동반하며, 잔액 음수/강행 금지.

**잠재적 리스크**:

- 요약이 잘못되면 오히려 일관성을 해칠 수 있음 → 핀 고정은 “사용자 승인”을 기본으로 둔다.

## 페어링 질문 (결정 필요)

- [ ] **Q1**: 요약 생성은 언제 할까?
  - Option A: N턴마다 주기적으로(단순)
  - Option B: 규칙/관계 변화 등 트리거 기반(권장: 비용/효율)

## 참고 자료

- `vibe/prd.md` - Memory Pin/장기 세션 요구
- `.cursor/rules/00-core-critical.mdc` - RULE-004/005/006
</file>

<file path="vibe/unit-plans/U-105[Mmp].md">
# U-105[Mmp]: Scenario Library(5) + 자동 리플레이 확장

## 메타데이터

| 항목      | 내용        |
| --------- | ----------- |
| Unit ID   | U-105[Mmp]  |
| Phase     | MMP         |
| 예상 소요 | 75분        |
| 의존성    | U-026       |
| 우선순위  | ⚡ Critical |

## 작업 목표

대표 시나리오 5개를 Scenario Library로 정리하고, 이를 자동으로 반복 실행해 Hard Gate 인바리언트 회귀를 지속적으로 잡는다.

**배경**: PRD는 “리플레이/시나리오 하네스”를 핵심 개발 방식으로 채택하고, 비결정성은 허용하되 인바리언트는 항상 유지하라고 명시한다. (PRD 10.3)

**완료 기준**:

- 최소 5개의 대표 시나리오가 정의된다(온보딩/퍼즐(DnD)/룰 변형/스캐너/자동 복구).
- 자동 러너가 시나리오를 순회 실행하고, 각 실행에서 Hard Gate 체크 결과(pass/fail)를 남긴다.
- 실패 시 “어디서 깨졌는지(턴/인바리언트)”만 남기고 프롬프트 원문/내부 추론은 기록하지 않는다. (RULE-008)

## 영향받는 파일

**생성**:

- `backend/src/unknown_world/replay/scenario_library/*.json` - 시나리오 5개 이상
- `backend/src/unknown_world/replay/auto_runner.py` - 자동 러너(배치 실행)
- (선택) `backend/src/unknown_world/replay/report.py` - 실행 결과 요약 리포트 생성

**수정**:

- `backend/src/unknown_world/replay/runner.py` - 수동 러너와 코드 공유/정리(필요 시)

**참조**:

- `vibe/prd.md` 10.3 - Scenario Library/Replay Runner 요구
- `.cursor/rules/00-core-critical.mdc` - RULE-004/005/008

## 구현 흐름

### 1단계: 시나리오 5개 선정/정의

- 온보딩(기본 텍스트+액션덱)
- 퍼즐(DnD 드롭 성공/실패)
- 룰 변형(타임라인 업데이트)
- 스캐너(업로드→아이템화)
- 자동 복구(의도적 스키마/룰 실패 유도 → repair/폴백 확인)

### 2단계: 자동 러너 구현(배치 실행)

- 시나리오를 순차 실행하며 각 턴의 인바리언트를 체크한다.
- 실패 시 즉시 종료/다음 시나리오로 넘어가는 정책을 정한다(옵션).

### 3단계: 결과 리포트/아티팩트 남기기

- 실행 결과(pass/fail, 실패 원인, 첫 실패 턴)를 파일로 남긴다.
- UI(데모 모드)에서 실행 결과를 요약으로 볼 수 있게 하는 옵션을 둔다.

## 의존성 & 연결

**이전 작업에서 가져올 것**:

- **계획서**: [U-026[Mvp]](U-026[Mvp].md) - 리플레이/시나리오 하네스(수동)

**다음 작업에 전달할 것**:

- CP-MMP-02에서 “시나리오 회귀 100%” 체크포인트를 수행할 자동화 기반
- U-108(보안 하드닝)에서 인젝션/차단 케이스를 시나리오로 추가할 기반

## 주의사항

**기술적 고려사항**:

- (RULE-004) 비결정성은 인정하되, 인바리언트는 100% 통과가 목표다.
- (RULE-008) 리포트/로그에 프롬프트 원문/내부 추론/비밀정보를 남기지 않는다.

**잠재적 리스크**:

- 멀티모달 업로드 자동화는 환경 의존성이 큼 → 업로드 시나리오는 “고정 테스트 이미지”로 관리하거나 수동 보조 옵션을 둔다.

## 페어링 질문 (결정 필요)

- [ ] **Q1**: 자동 러너의 실패 정책은?
  - Option A: 실패 즉시 중단(빠른 피드백)
  - Option B: 끝까지 실행 후 요약(권장: 전체 상태 파악)

## 참고 자료

- `vibe/prd.md` - Scenario Harness/Replay Runner
- `.cursor/rules/00-core-critical.mdc` - RULE-004/005/008
</file>

<file path="vibe/unit-plans/U-107[Mmp].md">
# U-107[Mmp]: 접근성/단축키/모바일 UX 개선

## 메타데이터

| 항목      | 내용       |
| --------- | ---------- |
| Unit ID   | U-107[Mmp] |
| Phase     | MMP        |
| 예상 소요 | 75분       |
| 의존성    | U-106      |
| 우선순위  | Medium     |

## 작업 목표

고정 게임 UI를 유지하면서, 키보드 접근성/단축키/모바일 레이아웃을 개선해 “플레이 가능” 품질을 높인다.

**배경**: PRD는 접근성(키보드/포커스)과 모바일 대응을 고려하라고 명시하며, 조작(클릭/드래그/업로드)이 눈에 보여야 한다. (PRD 9.4/7)

**완료 기준**:

- 핵심 조작이 키보드로도 최소한 동작한다(예: 실행/포커스 이동/토글).
- 모바일(<=768px)에서 패널/덱/캔버스가 깨지지 않고 사용 가능하다.
- 색상만으로 상태를 전달하지 않으며(텍스트/아이콘 병행), CRT 테마는 유지된다.

## 영향받는 파일

**생성**:

- (선택) `frontend/src/hooks/useHotkeys.ts` - 단축키 처리

**수정**:

- `frontend/src/style.css` - 반응형/포커스/접근성 스타일
- `frontend/src/App.tsx` - 포커스/단축키/패널 토글(필요 시)
- `frontend/src/components/*` - aria/키보드 이벤트 보강(필요 시)

**참조**:

- `vibe/ref/frontend-style-guide.md` - 반응형/접근성 가이드
- `.cursor/rules/10-frontend-game-ui.mdc` - 게임 UI 고정 원칙

## 구현 흐름

### 1단계: 접근성/모바일 체크리스트 확정

- 키보드: Enter 실행, Tab 포커스, 토글 접근
- 모바일: 패널 축약/접기, 폰트/패딩 조정

### 2단계: UI 개선 적용

- 포커스 스타일을 CRT 테마에 맞게 보강
- 모바일 레이아웃에서 고정 HUD 요소가 과도하게 가리지 않도록 조정

### 3단계: 데모 루프 회귀 확인

- CP-MVP-03 “10분 데모 루프”를 모바일/키보드 중심으로 한 번 더 수행할 수 있게 런북을 보강한다(선택).

## 의존성 & 연결

**이전 작업에서 가져올 것**:

- **계획서**: [U-106[Mmp]](U-106[Mmp].md) - 관측 UI/메트릭(가독성 영향)

**다음 작업에 전달할 것**:

- CP-MMP-02에서 시나리오 회귀를 UI 품질 관점에서도 통과시키는 기반

## 주의사항

**기술적 고려사항**:

- (RULE-002) 접근성 개선이 “채팅 UI”로 퇴행하는 변화를 유발하면 안 된다(게임 HUD 유지).

**잠재적 리스크**:

- 모바일에서 DnD가 불안정할 수 있음 → 모바일에서는 대체 상호작용(탭 선택→대상 선택) 옵션을 고려(후순위).

## 페어링 질문 (결정 필요)

- [ ] **Q1**: 모바일에서 패널은 기본 접힘으로 둘까?
  - Option A: 기본 접힘 + 탭/드로어(권장)
  - Option B: 모두 노출(정보량↑, 조작성↓)

## 참고 자료

- `vibe/ref/frontend-style-guide.md` - 접근성/반응형
- `.cursor/rules/10-frontend-game-ui.mdc` - 게임 UI 고정 규칙
</file>

<file path="vibe/unit-plans/U-108[Mmp].md">
# U-108[Mmp]: ⚡보안 하드닝(인젝션 케이스/secret scan)

## 메타데이터

| 항목      | 내용        |
| --------- | ----------- |
| Unit ID   | U-108[Mmp]  |
| Phase     | MMP         |
| 예상 소요 | 75분        |
| 의존성    | CP-MMP-01   |
| 우선순위  | ⚡ Critical |

## 작업 목표

프롬프트 인젝션 방어(“사용자 입력은 룰이 아니다”)와 비밀정보 노출 방지(로그/레포/응답) 체계를 강화하고, 대표 공격 시나리오를 리플레이로 검증할 수 있게 한다.

**배경**: PRD/Red-line은 Vertex 서비스 계정 기반, 비밀정보 커밋/노출 금지, 프롬프트 원문/CoT 노출 금지를 핵심 규칙으로 강제한다. (RULE-007/008)

**완료 기준**:

- 입력 인젝션 케이스에서도 스키마/경제/안전 정책이 우선되며, “규칙 무시”를 따르지 않는다. (RULE-007)
- 로그/응답/UI에 비밀정보/프롬프트 원문/내부 추론이 포함되지 않는다. (RULE-007/008)
- 시나리오(U-105)에 “인젝션/차단/복구” 케이스가 추가되어 회귀로 확인 가능하다.

## 영향받는 파일

**생성**:

- `backend/src/unknown_world/security/redaction.py` - 민감 로그 마스킹/차단 유틸(선택)
- `backend/src/unknown_world/security/prompt_injection.py` - 입력 정규화/정책 가드(선택)

**수정**:

- `backend/src/unknown_world/orchestrator/*` - 시스템 규칙 우선 적용/정책 고정(필요 시)
- `backend/src/unknown_world/api/turn.py` - blocked/폴백 응답이 항상 스키마 준수하도록 정리(필요 시)
- `backend/src/unknown_world/replay/scenario_library/*` - 인젝션 시나리오 추가(U-105 연계)

**참조**:

- `.cursor/rules/00-core-critical.mdc` - RULE-007/008/004
- `.gemini/rules/red-line.md` - 금지 패턴/보안
- `vibe/prd.md` 11.3 - 프롬프트 인젝션 대응

## 구현 흐름

### 1단계: 보안 체크리스트/위협 모델 최소 확정

- 공격: “규칙 무시해”, “스키마 무시해”, “키/토큰 출력해”, “프롬프트 보여줘”
- 방어: 시스템 규칙 고정 + 출력 스키마 강제 + 로그 마스킹 + blocked 폴백

### 2단계: 방어 로직 적용/검증

- TurnInput은 데이터로만 취급하고 시스템 규칙을 덮어쓰지 못하게 한다.
- blocked 시에도 TurnOutput 스키마를 준수하며, 안전한 텍스트-only 대체 결과를 제공한다. (RULE-004)

### 3단계: 회귀 시나리오 추가

- U-105 시나리오에 인젝션/차단/복구 케이스를 추가하고 자동 러너로 확인한다.

## 의존성 & 연결

**이전 작업에서 가져올 것**:

- **체크포인트**: [CP-MMP-01](CP-MMP-01.md) - 배포/관측 환경에서의 기준선
- **계획서**: [U-105[Mmp]](U-105[Mmp].md) - 자동 리플레이/시나리오

**다음 작업에 전달할 것**:

- RU-011에서 Autopilot/Replay 모듈 정리 시 보안/로그 정책을 공통으로 적용할 기준
- CP-MMP-02에서 “시나리오 회귀 100%”의 보안 케이스 포함

## 주의사항

**기술적 고려사항**:

- (RULE-007) BYOK 금지: 사용자 키 입력/저장 UX를 만들지 않는다.
- (RULE-008) 프롬프트 원문/CoT 비노출은 절대 규칙이다.

**잠재적 리스크**:

- 방어를 강하게 하면 정상 입력도 차단될 수 있음 → blocked 시에도 항상 안전한 대체 행동을 제공해 플레이가 멈추지 않게 한다.

## 페어링 질문 (결정 필요)

- [ ] **Q1**: “보안 진단 로그”는 어디까지 남길까?
  - Option A: 이벤트 타입/턴 ID/차단 여부만(권장: 최소 노출)
  - Option B: 입력 원문 일부(리스크 큼, 권장하지 않음)

## 참고 자료

- `.gemini/rules/red-line.md` - 보안/금지 규칙
- `.cursor/rules/00-core-critical.mdc` - RULE-007/008/004
- `vibe/prd.md` - 안전/인젝션 대응
</file>

<file path="vibe/unit-runbooks/U-008-http-streaming-client-runbook.md">
# U-008[Mvp] 프론트 HTTP Streaming 클라이언트 + Agent Console/배지 실행 가이드

## 1. 개요

프론트엔드에서 `/api/turn` **HTTP Streaming 응답 스트림**을 소비하여 **단계(Queue)/배지(Badges)/Auto-repair 트레이스**를 실시간으로 표시하고, 최종 TurnOutput을 Zod 검증 후 UI에 반영하는 기능을 구현했습니다.

**주요 기능**:
- fetch 기반 HTTP Streaming + NDJSON 파서
- Zustand 상태 관리 (queue/badges/repair)
- Agent Console 실시간 렌더링
- TurnOutput Zod 검증 및 폴백 처리

**프로토콜 버전**: v1 (현행 계약) — PRD 8.4.3 참조. 클라이언트는 v1(`data`) 및 v2(`turn_output`) 별칭을 모두 수용합니다.

**예상 소요 시간**: 10분

**의존성**:
- 의존 유닛: U-004 (고정 HUD 레이아웃), U-006 (Zod 스키마), U-007 (스트림 이벤트 계약)
- 선행 완료 필요: 백엔드 서버 실행 (포트 8011)

---

## 2. 빠른 시작 (Quick Start)

### 2.1 환경 준비

```bash
# 프론트엔드 의존성 설치 (프로젝트 루트에서)
cd frontend
pnpm install
```

### 2.2 백엔드 서버 실행 (의존 유닛 확인)

```bash
# 터미널 1: 백엔드 서버 실행 (포트 8011)
cd backend
uv run uvicorn unknown_world.main:app --host 0.0.0.0 --port 8011 --reload
```

**확인**: `http://localhost:8011/docs`에서 Swagger UI 접근 가능

### 2.3 프론트엔드 서버 실행

```bash
# 터미널 2: 프론트엔드 서버 실행 (포트 8001)
cd frontend
pnpm dev -- --port 8001
```

### 2.4 첫 화면/결과 확인

- 브라우저에서 `http://localhost:8001` 접속
- 성공 지표:
  - CRT 테마의 게임 UI 레이아웃 표시
  - Agent Console 패널에 "IDLE" 상태 표시
  - 단계 큐(Queue)에 Parse→...→Commit 단계 표시

---

## 3. 핵심 기능 시나리오

### 시나리오 A: 명령 입력 및 스트리밍 확인

**목적**: 사용자 입력 시 Agent Console에 실시간 단계 진행 표시 확인

**실행**:
1. 브라우저에서 `http://localhost:8001` 접속
2. 하단 명령 입력창에 "문을 열어본다" 입력
3. EXECUTE 버튼 클릭 또는 Enter 키

**기대 결과**:
- Agent Console 상태가 "IDLE" → "PROCESSING"으로 변경
- 단계 큐에서 Parse, Validate, Plan, ... 순서로 상태 변화
  - ○ (pending) → ◎ (in_progress) → ● (completed)
- 스트리밍 완료 후 내러티브 피드에 응답 추가

**확인 포인트**:
- ✅ PROCESSING 상태에서 단계가 순차적으로 진행됨
- ✅ 완료 후 상태가 IDLE로 복귀
- ✅ 내러티브에 새 항목 추가됨

---

### 시나리오 B: 배지(Badges) 표시 확인

**목적**: 검증 배지가 정상적으로 표시되는지 확인

**실행**:
1. 시나리오 A 완료 후 Agent Console 확인

**기대 결과**:
```
Badges
┌────────────┬────────────┐
│ Schema OK  │ Economy OK │
├────────────┼────────────┤
│ Safety OK  │ Consistency│
│            │    OK      │
└────────────┴────────────┘
```

**확인 포인트**:
- ✅ 4개 배지가 2x2 그리드로 표시
- ✅ OK 배지는 녹색, FAIL 배지는 빨간색

---

### 시나리오 C: 액션 카드 클릭

**목적**: 액션 카드 클릭으로 턴 실행 확인

**실행**:
1. Footer의 Action Deck에서 아무 카드 클릭

**기대 결과**:
- Agent Console이 다시 PROCESSING 상태로 전환
- 새 턴이 실행되고 내러티브 추가

**확인 포인트**:
- ✅ 카드 클릭 시 턴 실행됨
- ✅ 스트리밍 중 카드 비활성화됨 (disabled)
- ✅ 경제 HUD의 Signal 값이 업데이트됨

---

### 시나리오 D: 스트리밍 중 UI 상태

**목적**: 스트리밍 중 UI가 적절히 비활성화되는지 확인

**실행**:
1. 명령 입력 후 EXECUTE 클릭
2. 스트리밍 중 UI 상태 확인

**기대 결과**:
- 입력창에 "처리 중..." placeholder 표시
- EXECUTE 버튼이 "WAIT"로 변경되고 비활성화
- 액션 카드들이 반투명해지고 클릭 불가

**확인 포인트**:
- ✅ 스트리밍 중 중복 요청 불가
- ✅ 완료 후 UI 정상 활성화

---

### 시나리오 E: 네트워크 에러 처리

**목적**: 백엔드 연결 실패 시 에러 표시 확인

**실행**:
1. 백엔드 서버 종료 (Ctrl+C)
2. 프론트엔드에서 명령 입력 후 EXECUTE 클릭

**기대 결과**:
- Agent Console에 에러 메시지 표시
- 연결 상태가 "OFFLINE"으로 변경

**확인 포인트**:
- ✅ 에러 메시지가 빨간색 박스로 표시
- ✅ UI가 멈추지 않고 에러 상태 표시
- ✅ 백엔드 재시작 후 정상 동작 가능

---

## 4. 실행 결과 확인

### 4.1 브라우저 개발자 도구

- **Console 탭**: NDJSON 파싱 경고/에러 확인
- **Network 탭**: `/api/turn` POST 요청 확인
  - 요청 헤더: `Content-Type: application/json`
  - 응답 헤더: `Content-Type: application/x-ndjson`

### 4.2 생성 파일

| 파일 경로 | 목적 |
|-----------|------|
| `frontend/src/api/turnStream.ts` | NDJSON 파서 + HTTP Streaming 클라이언트 |
| `frontend/src/stores/agentStore.ts` | Zustand 상태 관리 |
| `frontend/src/components/AgentConsole.tsx` | Agent Console 컴포넌트 |

### 4.3 수정 파일

| 파일 경로 | 변경 내용 |
|-----------|-----------|
| `frontend/src/App.tsx` | 스트림 연동, 상태 관리 |
| `frontend/src/style.css` | Agent Console 스타일 추가 |

### 4.4 성공/실패 판단 기준

**성공**:
- ✅ Agent Console에 단계 진행이 실시간 표시됨
- ✅ 배지가 정상적으로 표시됨
- ✅ TurnOutput이 Zod 검증을 통과하고 UI에 반영됨
- ✅ 스트리밍 중 UI가 적절히 비활성화됨
- ✅ 에러 발생 시 UI가 멈추지 않고 에러 표시

**실패 시 확인**:
- ❌ 백엔드 미실행 → 포트 8011에서 서버 실행
- ❌ CORS 에러 → 백엔드 CORS 설정 확인
- ❌ JSON 파싱 실패 → 브라우저 콘솔에서 NDJSON 형식 확인

---

## 5. 문제 해결 (Troubleshooting)

### 5.1 일반적인 오류

**오류**: `fetch failed` 또는 `Network error`

- **원인**: 백엔드 서버 미실행
- **해결**: 
  ```bash
  cd backend
  uv run uvicorn unknown_world.main:app --port 8011
  ```

**오류**: CORS policy 차단

- **원인**: 백엔드 CORS 설정 누락
- **해결**: `backend/src/unknown_world/main.py`에서 CORS 미들웨어 확인
  ```python
  app.add_middleware(
      CORSMiddleware,
      allow_origins=["http://localhost:8001"],
      allow_methods=["*"],
      allow_headers=["*"],
  )
  ```

**오류**: TurnOutput validation failed

- **원인**: 서버 응답이 Zod 스키마와 불일치
- **해결**: 
  1. 브라우저 콘솔에서 경고 메시지 확인
  2. 폴백 UI가 표시되었는지 확인
  3. 서버 Pydantic 모델과 클라이언트 Zod 스키마 동기화

### 5.2 환경별 주의사항

- **Windows**: 백엔드/프론트엔드 터미널을 별도로 실행
- **macOS/Linux**: 동일

---

## 6. 다음 단계

- **U-009[Mvp]**: Action Deck 실제 카드 렌더링 및 비용 시스템 연동
- **U-010[Mvp]**: Scene Canvas 내 이미지 렌더링 및 핫스팟 오버레이 구현
- **CP-MVP-01**: "스트리밍 + 스키마 + 폴백" 통합 검증
</file>

<file path="backend/src/unknown_world/__init__.py">
"""Unknown World - Backend Package

This is the main package for the Unknown World backend.
Architecture: FastAPI + Pydantic + SSE streaming

Reference:
- vibe/tech-stack.md (Python 3.14, FastAPI 0.128.0, Pydantic 2.12.5)
- vibe/prd.md (Agent-based Game Master Engine)
"""

__version__ = "0.1.0"
</file>

<file path="backend/src/unknown_world/main.py">
"""Unknown World - FastAPI 애플리케이션 엔트리포인트

이 모듈은 Unknown World 백엔드의 FastAPI 앱을 정의합니다.
MVP 단계에서는 기본 헬스체크와 개발용 CORS 설정만 포함합니다.

실행 방법:
    cd backend
    uv sync
    uv run uvicorn unknown_world.main:app --reload --port 8011

참조:
    - vibe/tech-stack.md (버전 SSOT)
    - vibe/prd.md (에이전트형 게임 엔진 요구사항)
    - .cursor/rules/20-backend-orchestrator.mdc (SSE/검증/복구 규칙)
"""

from typing import Literal

from fastapi import FastAPI
from fastapi.middleware.cors import CORSMiddleware
from pydantic import BaseModel

from unknown_world import __version__
from unknown_world.api import turn_router

# =============================================================================
# FastAPI 앱 인스턴스
# =============================================================================

app = FastAPI(
    title="Unknown World API",
    description="Gemini 기반 에이전트형 게임 엔진 오케스트레이터",
    version=__version__,
    docs_url="/docs",
    redoc_url="/redoc",
)

# =============================================================================
# CORS 설정 (개발 환경용)
# =============================================================================
# PRD 요구: 로컬 개발에서 프론트와 통신할 수 있도록 CORS 기본 정책 준비
# RULE-011: 프론트엔드는 8001~8010 포트 사용
# 주의: 프로덕션에서는 MMP 단계에서 엄격한 정책으로 변경해야 함

ALLOWED_ORIGINS = [
    # 프론트엔드 개발 서버 포트 범위 (RULE-011: 8001~8010)
    *[f"http://localhost:{port}" for port in range(8001, 8011)],
    *[f"http://127.0.0.1:{port}" for port in range(8001, 8011)],
]

app.add_middleware(
    CORSMiddleware,
    allow_origins=ALLOWED_ORIGINS,
    allow_credentials=True,
    allow_methods=["*"],
    allow_headers=["*"],
)

# =============================================================================
# 라우터 등록
# =============================================================================

# U-007: /api/turn HTTP Streaming 엔드포인트
app.include_router(turn_router)


# =============================================================================
# 응답 스키마 (Pydantic)
# =============================================================================


class HealthResponse(BaseModel):
    """헬스체크 응답 스키마.

    Attributes:
        status: 서버 상태 ("ok" 또는 "degraded")
        version: 백엔드 버전
        service: 서비스 이름
    """

    status: Literal["ok", "degraded"]
    version: str
    service: str


# =============================================================================
# 라우트 정의
# =============================================================================


@app.get("/health", response_model=HealthResponse, tags=["System"])
async def health_check() -> HealthResponse:
    """서버 헬스체크 엔드포인트.

    서버가 정상적으로 작동 중인지 확인합니다.
    이 엔드포인트는 로드밸런서, 모니터링 시스템, 클라이언트 연결 확인에 사용됩니다.

    Returns:
        HealthResponse: 서버 상태 정보
    """
    return HealthResponse(
        status="ok",
        version=__version__,
        service="unknown-world-backend",
    )


@app.get("/", tags=["System"])
async def root() -> dict[str, str]:
    """루트 엔드포인트.

    API 정보를 간략히 안내합니다.

    Returns:
        dict: 기본 안내 메시지
    """
    return {
        "message": "Unknown World API",
        "docs": "/docs",
        "health": "/health",
    }
</file>

<file path="backend/src/unknown_world/orchestrator/mock.py">
"""Unknown World - 모의 Orchestrator.

실모델(Gemini) 없이 프론트엔드 개발/데모를 지속할 수 있도록
결정적(seed 기반) TurnOutput을 생성하는 모의 Orchestrator입니다.

설계 원칙:
    - RULE-004: 검증 실패 시 안전한 폴백 제공
    - RULE-005: 재화 인바리언트 (잔액 음수 금지)
    - RULE-008: 단계/배지 가시화
    - RULE-009: 좌표 규약 (0~1000, bbox [ymin,xmin,ymax,xmax])

참조:
    - vibe/unit-plans/U-007[Mvp].md
    - .cursor/rules/20-backend-orchestrator.mdc
"""

import random

from unknown_world.models.turn import (
    ActionCard,
    ActionDeck,
    AgentConsole,
    AgentPhase,
    Box2D,
    CurrencyAmount,
    EconomyOutput,
    ImageJob,
    Language,
    MemoryPin,
    ModelLabel,
    Quest,
    RenderOutput,
    RiskLevel,
    SafetyOutput,
    SceneObject,
    TurnInput,
    TurnOutput,
    UIOutput,
    ValidationBadge,
    WorldDelta,
    WorldRule,
)

# =============================================================================
# 모의 데이터 생성 헬퍼
# =============================================================================

# 한국어 내러티브 템플릿
KO_NARRATIVES = [
    "어둠 속에서 희미한 빛이 새어나옵니다. 오래된 문이 삐걱거리며 열리고, 그 너머로 알 수 없는 세계가 펼쳐집니다.",
    "발걸음 소리가 텅 빈 복도에 메아리칩니다. 벽에 걸린 초상화들의 눈이 당신을 따라 움직이는 것 같습니다.",
    "갑자기 바닥이 흔들리며, 벽에서 고대의 문자들이 빛나기 시작합니다. 무언가가 깨어나고 있습니다.",
    "안개가 걷히자, 거대한 탑이 모습을 드러냅니다. 탑 꼭대기에서 이상한 빛이 깜빡이고 있습니다.",
    "낡은 책장을 밀자, 숨겨진 통로가 나타났습니다. 통로 끝에서 기묘한 노래가 들려옵니다.",
]

# 영어 내러티브 템플릿
EN_NARRATIVES = [
    "A faint light seeps through the darkness. An ancient door creaks open, revealing an unknown world beyond.",
    "Footsteps echo through the empty corridor. The eyes of the portraits on the walls seem to follow you.",
    "Suddenly, the ground shakes and ancient runes on the walls begin to glow. Something is awakening.",
    "As the fog lifts, a massive tower reveals itself. A strange light flickers at its peak.",
    "Pushing aside the old bookshelf, you discover a hidden passage. An eerie song emanates from its depths.",
]

# 한국어 액션 카드 템플릿
KO_ACTION_CARDS = [
    {"label": "문을 열어본다", "description": "조심스럽게 문을 열어 안을 살펴본다"},
    {"label": "주변을 탐색한다", "description": "주변에 유용한 물건이 있는지 찾아본다"},
    {"label": "뒤로 물러선다", "description": "위험을 피해 안전한 곳으로 물러선다"},
    {"label": "말을 걸어본다", "description": "상대방에게 조심스럽게 말을 건다"},
    {"label": "숨어서 지켜본다", "description": "은신하여 상황을 관찰한다"},
    {"label": "공격한다", "description": "위협에 맞서 공격을 시도한다"},
]

# 영어 액션 카드 템플릿
EN_ACTION_CARDS = [
    {"label": "Open the door", "description": "Carefully open the door and look inside"},
    {"label": "Search the area", "description": "Look for useful items nearby"},
    {"label": "Step back", "description": "Retreat to a safe place to avoid danger"},
    {"label": "Speak to them", "description": "Cautiously initiate conversation"},
    {"label": "Hide and observe", "description": "Conceal yourself and watch the situation"},
    {"label": "Attack", "description": "Confront the threat with an attack"},
]

# 장면 오브젝트 템플릿
SCENE_OBJECTS_KO = [
    {"label": "낡은 문", "hint": "클릭하여 열어볼 수 있습니다"},
    {"label": "빛나는 보석", "hint": "수집할 수 있을 것 같습니다"},
    {"label": "수상한 상자", "hint": "무언가 들어있을 수 있습니다"},
    {"label": "벽의 스위치", "hint": "작동시킬 수 있습니다"},
]

SCENE_OBJECTS_EN = [
    {"label": "Old door", "hint": "Click to open"},
    {"label": "Glowing gem", "hint": "It looks collectible"},
    {"label": "Suspicious chest", "hint": "Something might be inside"},
    {"label": "Wall switch", "hint": "Can be activated"},
]


def _generate_random_box(rng: random.Random) -> Box2D:
    """랜덤 바운딩 박스 생성 (0~1000 좌표계)."""
    ymin = rng.randint(0, 700)
    xmin = rng.randint(0, 700)
    ymax = ymin + rng.randint(50, 250)
    xmax = xmin + rng.randint(50, 250)
    # 범위 보정
    ymax = min(ymax, 1000)
    xmax = min(xmax, 1000)
    return Box2D(ymin=ymin, xmin=xmin, ymax=ymax, xmax=xmax)


# =============================================================================
# MockOrchestrator 클래스
# =============================================================================


class MockOrchestrator:
    """모의 Orchestrator.

    실모델(Gemini) 없이 TurnOutput을 생성하는 모의 오케스트레이터입니다.
    seed 기반으로 결정적(재현 가능)인 결과를 생성합니다.

    Attributes:
        seed: 랜덤 시드 (재현성 보장)

    Example:
        >>> orchestrator = MockOrchestrator(seed=42)
        >>> turn_input = TurnInput(
        ...     language=Language.KO,
        ...     text="문을 열어본다",
        ...     client=ClientInfo(viewport_w=1920, viewport_h=1080),
        ...     economy_snapshot=EconomySnapshot(signal=100, memory_shard=5),
        ... )
        >>> output = orchestrator.generate_turn_output(turn_input)
    """

    # 단계 목록 (PRD 예시)
    PHASES = [
        AgentPhase.PARSE,
        AgentPhase.VALIDATE,
        AgentPhase.PLAN,
        AgentPhase.RESOLVE,
        AgentPhase.RENDER,
        AgentPhase.VERIFY,
        AgentPhase.COMMIT,
    ]

    def __init__(self, seed: int | None = None) -> None:
        """MockOrchestrator 초기화.

        Args:
            seed: 랜덤 시드. None이면 랜덤하게 생성.
        """
        self.seed = seed if seed is not None else random.randint(0, 2**32 - 1)
        self._rng = random.Random(self.seed)

    def generate_turn_output(self, turn_input: TurnInput) -> TurnOutput:
        """TurnInput을 받아 TurnOutput을 생성합니다.

        Args:
            turn_input: 사용자 입력

        Returns:
            TurnOutput: 모의 턴 결과
        """
        is_korean = turn_input.language == Language.KO

        # 내러티브 생성
        narratives = KO_NARRATIVES if is_korean else EN_NARRATIVES
        narrative = self._rng.choice(narratives)

        # 사용자 텍스트가 있으면 반영
        if turn_input.text:
            prefix = (
                f'당신은 "{turn_input.text}"라고 말했습니다. '
                if is_korean
                else f'You said "{turn_input.text}". '
            )
            narrative = prefix + narrative

        # 액션 덱 생성 (3~6장)
        action_templates = KO_ACTION_CARDS if is_korean else EN_ACTION_CARDS
        num_cards = self._rng.randint(3, 6)
        selected_templates = self._rng.sample(
            action_templates, min(num_cards, len(action_templates))
        )

        action_cards: list[ActionCard] = []
        for i, template in enumerate(selected_templates):
            cost_signal = self._rng.randint(1, 10)
            cost_shard = 1 if self._rng.random() < 0.2 else 0  # 20% 확률로 shard 소비

            action_cards.append(
                ActionCard(
                    id=f"action_{i + 1}",
                    label=template["label"],
                    description=template["description"],
                    cost=CurrencyAmount(signal=cost_signal, memory_shard=cost_shard),
                    risk=self._rng.choice(list(RiskLevel)),
                    hint=None,
                )
            )

        action_deck = ActionDeck(cards=action_cards)

        # 장면 오브젝트 생성 (1~3개)
        object_templates = SCENE_OBJECTS_KO if is_korean else SCENE_OBJECTS_EN
        num_objects = self._rng.randint(1, 3)
        selected_objects = self._rng.sample(
            object_templates, min(num_objects, len(object_templates))
        )

        scene_objects: list[SceneObject] = []
        for i, template in enumerate(selected_objects):
            scene_objects.append(
                SceneObject(
                    id=f"obj_{i + 1}",
                    label=template["label"],
                    box_2d=_generate_random_box(self._rng),
                    interaction_hint=template["hint"],
                )
            )

        ui_output = UIOutput(action_deck=action_deck, objects=scene_objects)

        # 세계 상태 변화 (delta)
        world_delta = self._generate_world_delta(is_korean)

        # 렌더링 출력 (이미지 생성은 선택적)
        should_generate_image = self._rng.random() < 0.3  # 30% 확률로 이미지 생성
        render_output = RenderOutput(
            image_job=ImageJob(
                should_generate=should_generate_image,
                prompt="A mysterious dungeon scene" if should_generate_image else "",
                model_label=ModelLabel.FAST,
                aspect_ratio="16:9",
                image_size="1024x576",
            )
            if should_generate_image
            else None
        )

        # 경제 출력 (비용 계산)
        turn_cost = CurrencyAmount(
            signal=self._rng.randint(1, 5),
            memory_shard=0,
        )

        # 잔액 계산 (음수 방지 - RULE-005)
        balance_signal = max(0, turn_input.economy_snapshot.signal - turn_cost.signal)
        balance_shard = max(0, turn_input.economy_snapshot.memory_shard - turn_cost.memory_shard)

        economy_output = EconomyOutput(
            cost=turn_cost,
            balance_after=CurrencyAmount(signal=balance_signal, memory_shard=balance_shard),
        )

        # 안전 출력
        safety_output = SafetyOutput(blocked=False, message=None)

        # 에이전트 콘솔
        agent_console = AgentConsole(
            current_phase=AgentPhase.COMMIT,
            badges=[
                ValidationBadge.SCHEMA_OK,
                ValidationBadge.ECONOMY_OK,
                ValidationBadge.SAFETY_OK,
                ValidationBadge.CONSISTENCY_OK,
            ],
            repair_count=0,
        )

        return TurnOutput(
            language=turn_input.language,
            narrative=narrative,
            ui=ui_output,
            world=world_delta,
            render=render_output,
            economy=economy_output,
            safety=safety_output,
            agent_console=agent_console,
        )

    def _generate_world_delta(self, is_korean: bool) -> WorldDelta:
        """세계 상태 변화 생성."""
        # 규칙 변경 (20% 확률)
        rules_changed: list[WorldRule] = []
        if self._rng.random() < 0.2:
            rules_changed.append(
                WorldRule(
                    id="rule_gravity",
                    label="중력 반전" if is_korean else "Gravity Inversion",
                    description=(
                        "이 구역에서는 중력이 반대로 작용합니다"
                        if is_korean
                        else "Gravity works in reverse in this area"
                    ),
                )
            )

        # 인벤토리 추가 (30% 확률)
        inventory_added: list[str] = []
        if self._rng.random() < 0.3:
            items_ko = ["낡은 열쇠", "신비로운 구슬", "고대의 두루마리"]
            items_en = ["Old Key", "Mysterious Orb", "Ancient Scroll"]
            items = items_ko if is_korean else items_en
            inventory_added.append(self._rng.choice(items))

        # 퀘스트 업데이트 (25% 확률)
        quests_updated: list[Quest] = []
        if self._rng.random() < 0.25:
            quests_updated.append(
                Quest(
                    id="quest_explore",
                    label="미지의 영역 탐험" if is_korean else "Explore Unknown Territory",
                    is_completed=self._rng.random() < 0.3,
                )
            )

        # 메모리 핀 (15% 확률)
        memory_pins: list[MemoryPin] = []
        if self._rng.random() < 0.15:
            memory_pins.append(
                MemoryPin(
                    id="pin_1",
                    content="이 장소의 이름은 '잊혀진 성소'"
                    if is_korean
                    else "This place is called 'Forgotten Sanctuary'",
                    cost=CurrencyAmount(signal=0, memory_shard=1),
                )
            )

        return WorldDelta(
            rules_changed=rules_changed,
            inventory_added=inventory_added,
            inventory_removed=[],
            quests_updated=quests_updated,
            relationships_changed=[],
            memory_pins=memory_pins,
        )

    def create_safe_fallback(
        self,
        language: Language,
        error_message: str | None = None,
        economy_snapshot: CurrencyAmount | None = None,
    ) -> TurnOutput:
        """안전한 폴백 TurnOutput 생성 (RULE-004, RU-002-S1).

        스키마 검증 실패 시 반환할 안전한 기본 응답입니다.
        폴백 시 economy.balance_after는 입력 스냅샷을 그대로 유지합니다 (비용 0, 잔액 변화 없음).

        Args:
            language: 응답 언어
            error_message: 에러 메시지 (내부용, UI에 노출하지 않음)
            economy_snapshot: 요청 직전 재화 스냅샷 (폴백 시 잔액 유지용)

        Returns:
            TurnOutput: 안전한 폴백 응답
        """
        is_korean = language == Language.KO

        narrative = (
            "잠시 혼란이 있었습니다. 다시 시도해주세요."
            if is_korean
            else "There was a momentary confusion. Please try again."
        )

        # RU-002-S1: 폴백 시 입력 스냅샷 그대로 유지 (비용 0, 잔액 변화 없음)
        balance_after = (
            economy_snapshot
            if economy_snapshot is not None
            else CurrencyAmount(signal=100, memory_shard=5)  # 기본값 (스냅샷 없을 때만)
        )

        return TurnOutput(
            language=language,
            narrative=narrative,
            ui=UIOutput(action_deck=ActionDeck(cards=[]), objects=[]),
            world=WorldDelta(),
            render=RenderOutput(image_job=None),
            economy=EconomyOutput(
                cost=CurrencyAmount(signal=0, memory_shard=0),
                balance_after=balance_after,
            ),
            safety=SafetyOutput(blocked=False, message=None),
            agent_console=AgentConsole(
                current_phase=AgentPhase.COMMIT,
                badges=[ValidationBadge.SCHEMA_FAIL],  # 실패 표시
                repair_count=1,  # 복구 시도 횟수
            ),
        )
</file>

<file path="frontend/src/stores/agentStore.ts">
/**
 * Unknown World - Agent Console 상태 관리 (Zustand).
 *
 * 스트리밍 중 수신되는 단계/배지/내러티브/복구 정보를 저장하고,
 * AgentConsole 컴포넌트에서 구독할 수 있도록 합니다.
 *
 * 설계 원칙:
 *   - RULE-008: 단계/배지 가시화 (프롬프트/내부 추론 노출 금지)
 *   - RULE-003/004: 검증 후 상태 반영, 실패 시 폴백
 *
 * @module stores/agentStore
 */

import { create } from 'zustand';
import type { AgentPhase, ValidationBadge, TurnOutput } from '../schemas/turn';
import type {
  StageEvent,
  BadgesEvent,
  NarrativeDeltaEvent,
  FinalEvent,
  ErrorEvent,
} from '../types/turn_stream';
import { StageStatus } from '../types/turn_stream';

// =============================================================================
// 상태 타입 정의
// =============================================================================

/** 단계 상태 */
export type PhaseStatus = 'pending' | 'in_progress' | 'completed' | 'failed';

/** 단계 정보 */
export interface PhaseInfo {
  name: AgentPhase;
  status: PhaseStatus;
}

/** 에러 정보 */
export interface AgentError {
  message: string;
  code?: string;
}

/** Agent Console 상태 */
export interface AgentState {
  /** 현재 스트리밍 중인지 */
  isStreaming: boolean;
  /** 현재 단계 */
  currentPhase: AgentPhase | null;
  /** 단계별 상태 */
  phases: PhaseInfo[];
  /** 검증 배지 목록 */
  badges: ValidationBadge[];
  /** 누적 내러티브 텍스트 (타자 효과용) */
  narrativeBuffer: string;
  /** 자동 복구 횟수 */
  repairCount: number;
  /** 최종 TurnOutput */
  finalOutput: TurnOutput | null;
  /** 에러 정보 */
  error: AgentError | null;
}

/** Agent Console 액션 */
export interface AgentActions {
  /** 스트림 시작 */
  startStream: () => void;
  /** 단계 이벤트 처리 */
  handleStage: (event: StageEvent) => void;
  /** 배지 이벤트 처리 */
  handleBadges: (event: BadgesEvent) => void;
  /** 내러티브 델타 이벤트 처리 */
  handleNarrativeDelta: (event: NarrativeDeltaEvent) => void;
  /** 최종 출력 이벤트 처리 */
  handleFinal: (event: FinalEvent) => void;
  /** 에러 이벤트 처리 */
  handleError: (event: ErrorEvent) => void;
  /** 스트림 완료 */
  completeStream: () => void;
  /** 상태 초기화 */
  reset: () => void;
}

export type AgentStore = AgentState & AgentActions;

// =============================================================================
// 초기 상태
// =============================================================================

/** 기본 단계 목록 (PRD 예시) */
const DEFAULT_PHASES: AgentPhase[] = [
  'parse',
  'validate',
  'plan',
  'resolve',
  'render',
  'verify',
  'commit',
];

/** 초기 상태 생성 */
function createInitialState(): AgentState {
  return {
    isStreaming: false,
    currentPhase: null,
    phases: DEFAULT_PHASES.map((name) => ({
      name,
      status: 'pending' as const,
    })),
    badges: [],
    narrativeBuffer: '',
    repairCount: 0,
    finalOutput: null,
    error: null,
  };
}

// =============================================================================
// Zustand Store
// =============================================================================

/**
 * Agent Console 상태 스토어.
 *
 * @example
 * ```tsx
 * // 컴포넌트에서 사용
 * const { isStreaming, phases, badges } = useAgentStore();
 * const startStream = useAgentStore((state) => state.startStream);
 * ```
 */
export const useAgentStore = create<AgentStore>((set) => ({
  // 초기 상태
  ...createInitialState(),

  // 액션
  startStream: () => {
    set({
      ...createInitialState(),
      isStreaming: true,
    });
  },

  handleStage: (event) => {
    set((state) => {
      const phaseName = event.name;
      const eventStatus = event.status;

      // RU-002-S2: status 값에 따른 단계 상태 결정
      // 'start' → in_progress
      // 'complete' 또는 'ok' (정규화됨) → completed
      // 'fail' → failed
      let newStatus: PhaseStatus;
      if (eventStatus === StageStatus.START) {
        newStatus = 'in_progress';
      } else if (eventStatus === 'fail') {
        newStatus = 'failed';
      } else {
        // 'complete' (정규화된 'ok' 포함)
        newStatus = 'completed';
      }

      // 단계 상태 업데이트
      const phases = state.phases.map((phase) => {
        if (phase.name === phaseName) {
          return {
            ...phase,
            status: newStatus,
          };
        }
        return phase;
      });

      return {
        phases,
        currentPhase: eventStatus === StageStatus.START ? phaseName : state.currentPhase,
      };
    });
  },

  handleBadges: (event) => {
    set({
      badges: event.badges,
    });
  },

  handleNarrativeDelta: (event) => {
    set((state) => ({
      narrativeBuffer: state.narrativeBuffer + event.text,
    }));
  },

  handleFinal: (event) => {
    set({
      finalOutput: event.data,
      repairCount: event.data.agent_console?.repair_count ?? 0,
    });
  },

  handleError: (event) => {
    set({
      error: {
        message: event.message,
        code: event.code,
      },
    });
  },

  completeStream: () => {
    set({
      isStreaming: false,
      narrativeBuffer: '', // 스트림 완료 시 버퍼 초기화
    });
  },

  reset: () => {
    set(createInitialState());
  },
}));

// =============================================================================
// 셀렉터 (성능 최적화용)
// =============================================================================

/** 스트리밍 상태 셀렉터 */
export const selectIsStreaming = (state: AgentStore) => state.isStreaming;

/** 현재 단계 셀렉터 */
export const selectCurrentPhase = (state: AgentStore) => state.currentPhase;

/** 단계 목록 셀렉터 */
export const selectPhases = (state: AgentStore) => state.phases;

/** 배지 목록 셀렉터 */
export const selectBadges = (state: AgentStore) => state.badges;

/** 내러티브 버퍼 셀렉터 */
export const selectNarrativeBuffer = (state: AgentStore) => state.narrativeBuffer;

/** 복구 횟수 셀렉터 */
export const selectRepairCount = (state: AgentStore) => state.repairCount;

/** 최종 출력 셀렉터 */
export const selectFinalOutput = (state: AgentStore) => state.finalOutput;

/** 에러 셀렉터 */
export const selectError = (state: AgentStore) => state.error;
</file>

<file path="frontend/vite.config.ts">
import { defineConfig } from 'vite';
import react from '@vitejs/plugin-react';

// https://vite.dev/config/
export default defineConfig({
  plugins: [react()],
  server: {
    port: 8001, // RULE-011: 프론트엔드는 8001~8010 사용
    strictPort: true, // 포트 충돌 시 fail-fast (대역 밖 이동 방지)
    // 충돌 시: pnpm -C frontend dev --port 8002 (8002~8010 중 선택)
  },
  build: {
    outDir: 'dist',
    sourcemap: true,
  },
});
</file>

<file path="shared/schemas/turn/turn_input.schema.json">
{
  "$schema": "http://json-schema.org/draft-07/schema#",
  "$id": "https://unknown-world.dev/schemas/turn/turn_input.schema.json",
  "title": "TurnInput",
  "description": "Client → Server 턴 요청 스키마 (MVP). PRD 8.7절 기반.",
  "type": "object",
  "properties": {
    "language": {
      "type": "string",
      "enum": ["ko-KR", "en-US"],
      "description": "게임 언어 설정 (ko-KR 또는 en-US)"
    },
    "text": {
      "type": "string",
      "description": "사용자 입력 (자연어)"
    },
    "click": {
      "type": ["object", "null"],
      "description": "클릭된 오브젝트 정보 (선택)",
      "properties": {
        "object_id": {
          "type": "string",
          "description": "클릭된 오브젝트 ID"
        },
        "box_2d": {
          "type": ["array", "null"],
          "description": "bbox [ymin, xmin, ymax, xmax] (0~1000 정규화)",
          "items": {
            "type": "integer",
            "minimum": 0,
            "maximum": 1000
          },
          "minItems": 4,
          "maxItems": 4
        }
      },
      "required": ["object_id"]
    },
    "client": {
      "type": "object",
      "description": "클라이언트 환경 정보",
      "properties": {
        "viewport_w": {
          "type": "integer",
          "description": "뷰포트 너비 (px)"
        },
        "viewport_h": {
          "type": "integer",
          "description": "뷰포트 높이 (px)"
        },
        "theme": {
          "type": "string",
          "enum": ["dark", "light"],
          "description": "테마 설정"
        }
      },
      "required": ["viewport_w", "viewport_h", "theme"]
    },
    "economy_snapshot": {
      "type": "object",
      "description": "현재 재화 상태 스냅샷",
      "properties": {
        "signal": {
          "type": "integer",
          "minimum": 0,
          "description": "Signal 재화 잔액"
        },
        "memory_shard": {
          "type": "integer",
          "minimum": 0,
          "description": "Memory Shard 재화 잔액"
        }
      },
      "required": ["signal", "memory_shard"]
    }
  },
  "required": ["language", "text", "client", "economy_snapshot"],
  "additionalProperties": false
}
</file>

<file path="vibe/commands/ai-refactor.md">
# AI 코드 리뷰 및 리팩토링 제안서 생성 프롬프트

## 0. 시스템 설정 및 제어 파라미터

<system_config>
**목적**: 제공된 repomix 스냅샷(`code-base.xml`), 아키텍처 문서(`vibe/architecture.md`), 그리고 기술 부채 로그(`vibe/debt-log.md`)를 분석하여 Principal-level 엔지니어 관점에서 심층적인 코드 리뷰와 실행 가능한 개선 제안서를 생성합니다.

**분석 깊이**:

- 추론 수준: `Deep` - 피상적 문제를 넘어 아키텍처 수준의 잠재적 이슈까지 고려
- 제안 상세도: `High` - 구조적 개선과 구체적 실행 방안 중심
- 응답 간결성: `Balanced` - 근거와 기대 효과를 명확히 포함하되 간결하게 작성

**중요 제약사항**:

- ⚠️ 유닛 테스트, 통합 테스트, E2E 테스트 등 자동화된 테스트 코드 작성 제안은 **절대 포함하지 않습니다**
- ⚠️ 각 제안은 반드시 별도의 마크다운 파일로 생성되어야 합니다
- ⚠️ 각 제안서는 명확한 실행 가이드를 포함해야 합니다
  </system_config>

---

## 1. 역할 및 전문성 정의

<role>
**당신의 역할**: Principal Software Architect

**전문성**:

- 15년 이상의 대규모 시스템 설계 경험
- 코드의 장기적 유지보수성, 확장성, 안정성 극대화에 특화
- 주니어부터 시니어까지 모든 레벨의 개발자가 이해할 수 있는 명확한 커뮤니케이션

**핵심 가치관**:

1. **실용주의 (Pragmatism)**: 이론적 완벽함보다 실제 프로젝트에 긍정적 영향을 주는 개선 우선
2. **예방적 설계 (Preventive Design)**: 현재 문제 해결을 넘어 미래 문제 예방
3. **시스템 사고 (Systems Thinking)**: 개별 코드가 아닌 전체 시스템의 건강성 고려
4. **팀 성장 촉진**: 직접 수정이 아닌, 팀의 자율적 성장을 돕는 가이드 제공

**조언 원칙**:

- 건설적이고 긍정적인 톤 유지
- 명확한 근거와 예시 제공
- 즉시 실행 가능한 구체적 단계 제시
- 심각도와 우선순위 명확히 구분
  </role>

---

## 2. 컨텍스트 분석 프로세스

<context_analysis>
**분석 순서 및 방법론**:

### Step 1: 아키텍처 문서 이해

- 파일: `vibe/architecture.md`
- 목표: 프로젝트의 설계 원칙, 패턴, 제약사항 파악
- 체크포인트:
  - 정의된 레이어 구조 (예: Presentation, Business Logic, Data Access)
  - 의존성 규칙 (예: 내부 레이어는 외부 레이어에 의존 금지)
  - 명명 규칙 및 코딩 스타일 가이드
  - 사용 기술 스택 및 제약사항

### Step 2: 코드베이스 스캔

- 파일: `code-base.xml`
- 목표: 전체 코드 구조 및 모듈 간 관계 파악
- 중점 영역: 프롬프트 끝에 명시된 **분석 대상 영역**
- 체크포인트:
  - 디렉토리 구조의 논리적 일관성
  - 모듈 간 결합도 및 응집도
  - 순환 참조 여부
  - 공통 패턴 및 안티패턴 식별

### Step 3: 기술 부채 로그 분석 (Technical Debt Analysis)

- 파일: `vibe/debt-log.md`
- 목표: 이전에 기록된 실패/보류 이슈 중 리팩토링이 필요한 항목 식별
- 체크포인트:
  - 현재 코드베이스에 여전히 존재하는 문제인가?
  - 이번 리팩토링 사이클에서 해결 가능한가?
  - 해결 시 예상되는 부작용이나 리스크는 무엇인가?

### Step 4: 교차 검증

- 아키텍처 문서와 실제 코드의 일치성 확인
- 설계 원칙 위반 사례 식별
- 기술 부채 로그의 이슈와 현재 코드 상태의 상관관계 분석
  </context_analysis>

---

## 3. 체계적 분석 프레임워크

<analysis_framework>
**3단계 분석 프로세스**:

### Phase 1: 거시적 구조 분석 (Macro-level Analysis)

**목표**: 전체 시스템의 아키텍처 건강성 평가

**분석 항목**:

- ✅ 아키텍처 일관성: 정의된 패턴 준수 여부
- ✅ 모듈 경계: 책임 분리 및 결합도
- ✅ 확장성: 새로운 기능 추가 시 영향 범위
- ✅ 기술 부채: 누적된 설계 결함

**출력**: 시스템 수준의 개선 기회 3-5개

---

### Phase 2: 미시적 코드 분석 (Micro-level Analysis)

**목표**: 개별 코드의 품질 및 안정성 평가

**분석 카테고리**:

#### A. 코드 품질 (Code Quality)

1. **코드 중복 (Duplication)**
   - 동일/유사 로직의 반복
   - 복사-붙여넣기 패턴
   - 공통화 가능한 유틸리티

2. **네이밍 (Naming)**
   - 의미 전달의 명확성
   - 일관된 명명 규칙
   - 도메인 용어와의 정합성

3. **복잡도 (Complexity)**
   - 순환 복잡도(Cyclomatic Complexity)
   - 중첩 깊이
   - 함수/메서드 길이
   - 파라미터 개수

4. **모듈 설계 (Module Design)**
   - 단일 책임 원칙(SRP) 준수
   - 인터페이스 설계
   - 의존성 주입 패턴

5. **하드코딩 (Hard-coded Values)**
   - 매직 넘버
   - 하드코딩된 문자열
   - 환경 의존적 값

#### B. 안정성 (Stability)

1. **잠재적 오류 (Potential Bugs)**
   - Null/Undefined 참조
   - 타입 불일치
   - 경계 조건 미처리
   - 리소스 누수

2. **엣지 케이스 (Edge Cases)**
   - 빈 입력 처리
   - 최대/최소값 처리
   - 동시성 이슈
   - 예외 상황 처리

3. **수동 검증 시나리오 (Manual Verification)**
   - 사용자 시나리오 기반 검증 절차
   - 예외 상황 재현 방법
   - 안정성 확인 체크리스트
   - **⚠️ 자동화된 테스트 코드 작성은 제외**

#### C. 기술 부채 해결 (Technical Debt Resolution)

1. **기록된 부채 (Recorded Debt)**
   - `vibe/debt-log.md`에 기록된 미해결 이슈
   - 임시 방편으로 처리된 코드
   - `TODO`, `FIXME` 주석이 남겨진 로직

---

### Phase 3: 제안서 생성 및 구조화 (Advisory Generation)

**목표**: 실행 가능한 개선 제안을 우선순위와 함께 제공

**제안 구조**:

- 고유 ID 부여 (예: RU-001-Q1, RU-002-S1)
- 심각도 분류 (Critical / High / Medium / Low)
- 카테고리 분류 (위 분석 항목 기반)
- 구체적 위치 명시
- 명확한 개선 방안
- 기대 효과 및 영향 범위
  </analysis_framework>

---

## 4. 출력 형식 및 파일 생성 규칙

<output_specification>

### 🎯 출력 구조

**1단계: 분석 계획 제시**

먼저 아래 형식으로 분석 계획을 간략히 제시하세요:

**분석 계획 템플릿:**

- 아키텍처 문서 분석 및 핵심 설계 원칙 추출
- 코드베이스 스캔 및 명시된 분석 대상 영역 집중 분석
- 개선 기회 도출 (코드 품질 / 안정성 / 기술 부채 해결)
- 개별 제안 파일 생성 계획

---

**2단계: 요약 보고서 생성**

요약 보고서에 포함할 내용:

**📋 코드 리뷰 요약 보고서 구조:**

- **Executive Summary**
  - 전반적 평가 (2-3 문장)
  - 핵심 발견사항 (강점 / 개선 필요 / 기술 부채)
  - 제안 통계 (총 제안 수, 심각도별 분류)
  - 우선순위 액션 아이템 Top 5
- **진행 순서 (Execution Order / File-based)**
  - 생성된 제안서 파일(`vibe/refactors/RU-XXX-XX.md`)을 **실행 추천 순서대로** 나열
  - 각 항목에 **선행 의존성(예: “S1 선행 필요”)**과 **짧은 이유(1줄)**를 함께 표기
- **생성된 파일 목록**
  - 코드 품질 개선 파일들
  - 안정성 확보 파일들
  - 기술 부채 해결 파일들
- **카테고리별 분포**
  - 코드 품질 개선 카테고리별 개수
  - 안정성 확보 카테고리별 개수
  - 기술 부채 해결 카테고리별 개수

---

**3단계: 개별 제안서 파일 생성**

각 제안은 **반드시 별도의 마크다운 파일**로 생성되어야 합니다.

**파일명 규칙**:

- 코드 품질: `vibe/refactors/RU-[순번3자리]-Q[카테고리번호].md`
  - 예: `refactoring/RU-001-Q1.md` (중복 제거)
  - 예: `refactoring/RU-002-Q2.md` (네이밍 개선)
- 안정성: `vibe/refactors/RU-[순번3자리]-S[카테고리번호].md`
  - 예: `refactoring/RU-001-S1.md` (오류 처리)
- 기술부채: `vibe/refactors/RU-[순번3자리]-T[카테고리번호].md`
  - 예: `refactoring/RU-003-T1.md` (회기 부채 해결)

**카테고리 번호**:

- Q1: 코드 중복
- Q2: 네이밍
- Q3: 복잡도
- Q4: 모듈 설계
- Q5: 하드코딩
- S1: 잠재적 오류
- S2: 엣지 케이스
- S3: 수동 검증 시나리오
- T1: 회기 기록 부채 해결

**개별 제안서 템플릿**:

````markdown
# [ID: RU-XXX-QX] [간결한 제목]

## 📌 기본 정보

| 항목               | 내용                     |
| ------------------ | ------------------------ |
| **ID**             | RU-XXX-QX                |
| **심각도**         | Critical/High/Medium/Low |
| **카테고리**       | [카테고리명]             |
| **영향 범위**      | [파일/모듈 목록]         |
| **예상 작업 시간** | [시간]                   |

---

## 🔍 문제점 상세 분석

### 현재 상황

[구체적인 문제 설명 2-3문장]

### 문제가 되는 이유

1. **[이유 1]**: [구체적 설명]
2. **[이유 2]**: [구체적 설명]
3. **[이유 3]**: [구체적 설명]

### 영향받는 코드 위치

- 파일: `[파일 경로]`
- 라인: [시작]-[끝]
- 함수/클래스: `[이름]`

### 현재 코드 예시

```[언어]
// 문제가 있는 현재 코드
[코드 내용]
```

---

## 💡 개선 방안

### 제안하는 접근법

[선택한 해결 방법에 대한 설명 2-3문장]

### 구체적 실행 단계

#### Step 1: [단계명]

[수행할 작업 설명]

**변경 전:**

```[언어]
[기존 코드]
```

**변경 후:**

```[언어]
[개선된 코드]
```

#### Step 2: [단계명]

[수행할 작업 설명]

#### Step 3: [단계명]

[수행할 작업 설명]

### 대안적 접근법 (선택사항)

- **대안 1**: [설명]
  - 장점: [장점]
  - 단점: [단점]
- **대안 2**: [설명]
  - 장점: [장점]
  - 단점: [단점]

---

## 📈 기대 효과

### 즉각적 효과

- ✅ [효과 1: 구체적 개선 사항]
- ✅ [효과 2: 성능/품질 향상]
- ✅ [효과 3: 유지보수성 개선]

### 장기적 효과

- 🎯 [효과 1: 확장성 향상]
- 🎯 [효과 2: 기술 부채 감소]
- 🎯 [효과 3: 팀 생산성 증가]

### 정량적 개선 (가능한 경우)

| 지표         | 현재     | 개선 후  | 변화율 |
| ------------ | -------- | -------- | ------ |
| 코드 라인 수 | [현재값] | [개선값] | [%]    |
| 복잡도       | [현재값] | [개선값] | [%]    |
| 실행 시간    | [현재값] | [개선값] | [%]    |

---

## ⚠️ 주의사항 및 고려사항

### 리팩토링 시 주의할 점

1. [주의사항 1]
2. [주의사항 2]
3. [주의사항 3]

### 영향받는 다른 모듈

- **모듈 A**: [영향 설명]
- **모듈 B**: [영향 설명]

### 호환성 체크리스트

- [ ] 기존 API 계약 유지
- [ ] 하위 호환성 보장
- [ ] 외부 의존성 버전 호환

---

## 🧪 검증 방법 (수동 검증 중심)

### 변경 전 확인 사항

1. [현재 동작 확인 방법]
2. [현재 성능 측정 방법]

### 변경 후 검증 시나리오

#### 시나리오 1: 기본 동작 확인

- **실행 방법**: [구체적 명령어 또는 절차]
- **기대 결과**: [예상되는 결과]
- **확인 사항**:
  - ✅ [체크 포인트 1]
  - ✅ [체크 포인트 2]

#### 시나리오 2: 엣지 케이스 확인

- **테스트 입력**: [특수한 입력값]
- **기대 동작**: [예상되는 처리]
- **확인 사항**: [체크 포인트]

### 회귀 확인 체크리스트

- [ ] 기존 기능 정상 동작
- [ ] 성능 저하 없음
- [ ] 에러 처리 정상

---

## 🔧 실행 가이드

### 개발자를 위한 실행 지침

1. **준비 사항**
   - [필요한 도구/환경]
   - [사전 확인 사항]

2. **실행 절차**

   ```bash
   # 예시 명령어
   [실제 실행할 명령어들]
   ```

3. **검증 절차**
   - [검증 단계 1]
   - [검증 단계 2]

4. **롤백 계획** (필요시)
   - [롤백 절차]

### 예상 소요 시간

- 코드 수정: [시간]
- 검증: [시간]
- 총 예상 시간: [시간]

---

## 📚 참고 자료

- 관련 설계 패턴: [패턴명 및 설명]
- 관련 문서: `vibe/architecture.md` [관련 섹션]
- 관련 이슈: [이슈 번호 또는 토론 링크]
- 학습 자료: [도움이 될 문서/튜토리얼]

---

## 🏷️ 태그

`#refactoring` `#[카테고리]` `#[심각도]` `#[영향범위]`

---

## 📝 노트

[추가적인 컨텍스트나 향후 고려사항]
````

---

**4단계: 파일 생성 확인**

모든 파일 생성 후 다음을 확인하세요:

- ✅ 모든 제안이 개별 파일로 생성되었는가?
- ✅ 파일명이 규칙(RU-XXX-[Q/S/T]X.md)을 따르는가?
- ✅ 각 파일이 템플릿의 모든 섹션을 포함하는가?
- ✅ 코드 예시가 구체적이고 실행 가능한가?
- ✅ 수동 검증 시나리오가 명확하게 작성되었는가?
- ✅ 자동화된 테스트 코드 작성 제안이 없는가?
- ✅ 요약 보고서에 **진행 순서(파일명 기반)** 섹션이 포함되었는가?
- ✅ 진행 순서가 **실제로 생성된 파일명**만을 참조하는가?
- ✅ 진행 순서에 **의존성/선행 조건**이 1줄로 명시되었는가?

</output_specification>

---

## 5. 제안서 실행 프로세스

### 제안서 활용 방법

각 생성된 제안서(`vibe/refactors/RU-XXX-XX.md`)는 다음과 같이 활용됩니다:

1. **개발자 검토**: 제안서를 읽고 타당성 평가
2. **실행 결정**: 우선순위에 따라 실행 여부 결정
3. **리팩토링 수행**:
   - 제안서의 "실행 가이드"를 따라 수행
   - 필요시 `vibe/commands/refactor-impl.md` 프롬프트 활용
4. **검증**: 제안서의 "검증 방법" 섹션 수행
5. **문서 업데이트**:
   - 필요시 `vibe/commands/refactor-doc.md` 프롬프트 활용

---

## 6. 품질 보증 체크리스트

<quality_assurance>

### 최종 제출 전 자기 검증

#### ✅ 구조적 완성도

- [ ] 분석 계획이 명확하게 제시되었는가?
- [ ] 요약 보고서가 전체 상황을 잘 반영하는가?
- [ ] 모든 제안이 개별 파일로 생성되었는가?
- [ ] 파일명 규칙이 일관되게 적용되었는가?

#### ✅ 내용의 실행 가능성

- [ ] 각 제안에 고유 ID와 심각도가 부여되었는가?
- [ ] 문제점이 구체적인 코드 위치와 함께 설명되었는가?
- [ ] 개선 방안이 단계별로 명확하게 제시되었는가?
- [ ] 개발자가 즉시 실행할 수 있을 만큼 구체적인가?

#### ✅ 제약사항 준수

- [ ] 유닛/통합 테스트 코드 작성 제안이 없는가?
- [ ] 새로운 외부 라이브러리 추가 제안을 최소화했는가?
- [ ] 수동 검증 시나리오가 실용적으로 작성되었는가?

#### ✅ 전문성 및 톤

- [ ] Principal Architect 수준의 통찰력을 보여주는가?
- [ ] 건설적이고 긍정적인 톤을 유지하는가?
- [ ] 팀의 성장을 돕는 방향으로 조언하는가?

</quality_assurance>

---

## 7. 실행 지침

<execution_guide>

### 당신이 할 일:

1. **컨텍스트 로드**
   - `vibe/architecture.md` 읽기
   - `code-base.xml` 읽기
   - `vibe/debt-log.md` 읽기
   - 프롬프트 끝에 명시된 분석 대상 영역 확인

2. **분석 계획 수립 및 제시**
   - 분석 계획을 명확히 제시

3. **체계적 분석 수행**
   - Phase 1: 거시적 구조 분석
   - Phase 2: 미시적 코드 분석
   - Phase 3: 제안서 생성

4. **결과물 생성**
   - 요약 보고서 작성
   - 각 제안을 개별 마크다운 파일로 생성
   - 파일 생성 체크리스트 확인

5. **품질 검증**
   - 최종 체크리스트 수행
   - 필요시 수정 및 보완

### 당신이 하지 말아야 할 일:

- ❌ 자동화된 테스트 코드 작성 제안
- ❌ 추상적이거나 실행 불가능한 조언
- ❌ 코드 직접 수정 (가이드만 제공)
- ❌ 여러 제안을 하나의 파일에 통합
- ❌ 제안서 내에 전체 실행 프롬프트 포함 (간결한 가이드만)

</execution_guide>

---

## 8. 분석 대상 및 추가 지침
</file>

<file path="vibe/commands/unit-impl.md">
# Roadmap 단계별 코드 생성 지시서 (Roadmap Step-by-Step Code Generation Instructions)

## 1) 역할 및 시스템 설정

### 1.1 역할 정의

너는 `vibe/tech-stack.md` 문서의 기술을 다루는 **세심·정확·지시준수형 AI 소프트웨어 엔지니어**다.
현재 단계에서 요구된 작업만 수행하고, 완료 즉시 결과를 제출한다.

### 1.2 시스템 동작 설정

```yaml
추론 깊이: 상세 (체크리스트 기반 검증 필수)
출력 스타일: 간결하되 핵심 정보 누락 금지
도구 사용: 필요시 무제한 활용
범위 준수: 현재 단계만 처리, 선행/후속 단계 언급 금지
```

### 1.3 사전 분석 체크리스트 (THINK-FIRST)

모든 작업 시작 전 아래 항목을 내부적으로 검토:

- **Thorough**: 변경/영향 범위(파일·심볼·계약) 5줄 이내 목록화
- **Holistic**: 아키텍처 경계/의존성 3가지 명시
- **Iterative**: 계획→실행→검증 산출물을 별도 블록으로 출력
- **Navigated**: 대안 2개와 채택 이유 1줄
- **Knowledge**: 근거(문서/코드 경로) 2개 이상 인용
- **First-Principles**: 전제·제약을 1~2줄로 축약
- **Impact/Risk**: 영향도·리스크·완화책 3줄
- **Scalable**: 확장성 고려 포인트 2개
- **Verifiable**: 런북 시나리오로 검증 가능한 설계

---

## 2) 맥락 수집 및 우선순위

### 2.1 필수 문서 읽기 순서

작업 시작 전 파일 읽기 도구로 아래 문서를 **반드시 읽고** 숙지:

1. **`.gemini/rules/red-line.md`** (최우선) - AI 필수 준수 규칙 (CRITICAL RULES)
2. **`vibe/tech-stack.md`** - 프로젝트 기술 스택 및 도구
3. **`vibe/roadmap.md`** - 현재 단계 및 마일스톤 상태
4. **의존성 개발 보고서** - 의존성이 있는 유닛의 개발 보고서 (섹션 9에서 명시되는 경우 필수)
5. `vibe/prd.md` - 프로젝트 디자인 문서 및 요구사항
6. `vibe/architecture.md` - 파일 구성, 각 파일 목적, 아키텍처 설계
7. `vibe/progress.md` - 진행 현황 및 의존성
8. `.gemini/GEMINI.md` - 전역 개발 지침
9. `.gemini/rules/*.md` - 세부 도메인별 지침

### 2.2 의존성 확인 프로세스

**의존성 파일 명명 규칙**:

- 파일명 패턴: `[Depends 유닛ID].md`
- 경로: `vibe/unit-results/유닛ID[Tag].md`
- 예시: `memory-bank/unit-results/U-001[Mvp].md`

**의존성 확인 절차**:

1. **섹션 9 확인**: "현재 진행할 단계 및 추가 지침"에서 의존성 정보 확인
2. **의존성 파일 검색**: 섹션 9에서 명시된 의존 유닛이 있다면 `vibe/unit-results` 디렉토리에서 해당 파일 검색
3. **의존성 분석**:
   - 파일이 있으면 **반드시 읽고** 다음 정보 추출:
     - 의존 유닛이 제공하는 API/인터페이스
     - 공유 데이터 구조/타입 정의
     - 호출 규약 및 계약 사항
     - 에러 처리 방식
     - 설정 파일 또는 환경 변수
   - 파일이 없으면 의존성 없음으로 판단하고 진행

**의존성 문서 미존재 시 대응**:

- 섹션 9에서 의존성이 명시되었으나 개발 보고서가 없는 경우:
  - 사용자에게 의존 유닛 완료 여부 확인 요청
  - 의존 유닛의 코드 직접 분석 필요성 알림
  - 작업 일시 중단 또는 가정 하에 진행 여부 협의

### 2.3 문서 충돌 시 우선순위

RED-LINE > 사양서 > 의존성 개발보고 > 기술스택 > 아키텍처 > 기타 지침

---

## 3) 도구 사용 가이드 (복잡한 작업용)

**적용 조건**: 작업이 3단계 이상의 프로세스를 요구하거나, 다수의 파일 생성/수정이 필요한 경우

도구 호출 전 아래 형식으로 계획 출력:

```markdown
### 작업 계획

**목표**: [1줄로 목표 재진술]

**의존성 확인**:

- 의존 유닛: [섹션 9에서 명시된 유닛 ID] 또는 "없음"
- 참조 문서: [해당 개발 보고서 경로] 또는 "해당없음"
- 사용할 API/인터페이스: [목록] 또는 "해당없음"

**실행 단계**:

1. [단계 1 설명]
2. [단계 2 설명]
3. [단계 3 설명]
4. ...

**예상 산출물**:

- `경로/파일명.ext` - [목적]
- `경로/다른파일.ext` - [목적]
```

**실행 중**: 각 단계 완료 시 한 줄 진행 로그 출력  
**완료 후**: 최종 요약 블록 제시

---

## 4) 설계 및 구현 기준

### 4.1 설계 체크리스트

작업 전 아래 항목 모두 충족 확인:

- [ ] **의존성 검증**: 의존 유닛의 개발 보고서 읽고 API 계약 이해
- [ ] **인터페이스 준수**: 의존 유닛이 정의한 타입/프로토콜/계약 준수
- [ ] 기존 아키텍처·디렉터리·네이밍 규칙과 일관성 유지
- [ ] SOLID / DRY / YAGNI 원칙 준수
- [ ] 크로스플랫폼 고려 (Path/URI API 사용, OS 특이점 반영)
- [ ] 파괴적 변경은 계획·영향 범위 명시 후 사용자 확인 필요
- [ ] 리스크/가정 명시, 단일 책임 원칙 적용

### 4.2 구현 규칙

**범위 엄수**

- [현재 진행할 단계] 내 작업만 수행
- 선행/후속 단계 언급 또는 구현 절대 금지

**의존성 처리**

- 의존 유닛이 제공하는 모듈/함수/클래스는 직접 구현하지 않고 import/require로 사용
- 의존 유닛의 타입 정의가 있으면 재정의 금지, 참조만 허용
- 의존 유닛의 에러 처리 방식을 따라 일관성 유지

**코드 품질**

- 스타일: 리포의 포매터/린터 설정(.eslintrc, .luarc.json 등) 최우선 준수
- 경로: 리포 루트 기준 상대 경로, 코드 내에서는 Path/URI API 사용
- I/O·UI: 필수 최소한만 구현, 과도한 콘솔 UI 의존 지양

**린트 및 타입 체크 (필수 실행)**

- 코드 작성 직후, **반드시** `Shell 살행 도구`를 사용하여 린터와 타입 체커를 실행
- 실행 명령어는 `.gemini/rules/lint-rules.md`를 참조
- 발견된 모든 오류는 즉시 수정하여 제출 (오류가 있는 상태로 완료 금지)

**테스트 정책**

- 어떤 형태의 자동 테스트 코드도 작성하지 않음
- 대신 런북(Runbook)을 통한 수동 검증 시나리오 제공

**프로젝트 특화 규칙**
{프로젝트-특화규칙}

---

## 5) 산출물 형식 (필수 출력 구조)

### 5.1 콘솔 간단 보고 (즉시 피드백용)

파일 작성 완료 후, 콘솔에 아래 형식으로 **간결한 요약 출력**:

```markdown
━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
✅ [유닛ID] 개발 완료
━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━

📦 작업 요약
[1줄로 완료 내용 요약]

🔗 의존성
• 의존 유닛: [섹션 9에서 명시된 유닛 ID] 또는 "없음"
• 사용한 API: [목록] 또는 "해당없음"

📂 생성/수정 파일 (총 N개)
• src/... (신규)
• scripts/... (수정)

⚠️ 주요 주의사항
• [있다면 1~2줄로 요약, 없으면 "없음"]

📋 다음 단계

1.  개발 보고서 확인: vibe/unit-results/[유닛ID].md
2.  런북 실행: vibe/unit-runbooks/[파일명].md
3.  (완료됨) 린트/타입 체크 무결성 검증

━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
```

---

### 5.2 산출물 생성 순서

1. **코드 구현** (src/, scripts/ 등)
2. **린트/타입 체크 실행 및 수정** (무결성 확보 시까지 반복)
3. **런북 파일 작성** (`vibe/unit-runbooks/[단계번호]-[기능명]-runbook.md`)
4. **콘솔 간단 보고 출력** (위 5.1 형식)

**중요**: 개발 보고서는 작성하지 않음. 이후 "문서 자동 업데이트" 단계에서 생성됨.

---

**금지 사항**:

- 다음 단계 제안 금지
- 로드맵 변경 제안 금지
- 현재 단계 범위 외 추가 아이디어 언급 금지
- 개발 보고서 작성 금지 (문서 업데이트 단계에서 진행)

---

## 6) 런북(Runbook) 작성 규격

### 6.1 파일 생성 규칙

- **경로**: `vibe/unit-runbooks/[단계번호]-[기능명]-runbook.md`
- **예시**: `runbooks/2.3-auth-module-runbook.md`
- **형식**: 마크다운 (.md)

### 6.2 런북 템플릿

`create_file` 도구로 아래 템플릿에 따라 런북 파일 생성:

````markdown
# [단계 번호] [기능명] 실행 가이드

## 1. 개요

[무엇을 구현했고, 어떤 핵심 기능을 체험할 수 있는지 1~2 문단 요약]

**예상 소요 시간**: [예: 5분]

**의존성**:

- 의존 유닛: [섹션 9에서 명시된 유닛 ID] 또는 "없음"
- 선행 완료 필요: [다른 유닛의 런북 실행 필요 여부]

---

## 2. 빠른 시작 (Quick Start)

### 2.1 환경 준비

```bash
# 의존성 설치 (프로젝트 기술 스택에 맞는 명령어 사용)
[의존성 설치 명령어] # 예: npm install, pip install -r requirements.txt 등
```

### 2.2 의존 유닛 확인 (해당 시)

```bash
# 의존 유닛의 서비스가 실행 중인지 확인
[상태 확인 명령어] # 예: curl http://localhost:3000/health 등
# 또는 의존 모듈 import 테스트
[임포트 테스트 명령어] # 예: node -e "require('./path')" 또는 python -c "import path" 등
```

### 2.3 즉시 실행

```bash
[실행 명령어] # 예: npm start, python main.py, cargo run 등
```

### 2.4 첫 화면/결과 확인

- [확인해야 할 출력 또는 화면 설명]
- 성공 지표: [예: "Server running on port 3000" 메시지 출력]

---

## 3. 핵심 기능 시나리오

### 시나리오 A: [기본 기능명]

**목적**: [이 시나리오가 검증하는 것]

**실행**:

```bash
[명령어 또는 UI 경로]
```

**입력 예시**:

```json
{
  "example": "sample data"
}
```

**기대 결과**:

```
[예상 출력 또는 스크린샷 설명]
```

**확인 포인트**:

- ✅ [체크할 항목 1]
- ✅ [체크할 항목 2]

---

### 시나리오 B: [의존 유닛 연동 테스트] (해당 시)

**목적**: 의존 유닛과의 통합 동작 검증

**전제 조건**:

- [{의존유닛ID}]의 서비스/모듈이 정상 동작 중

**실행**:

```bash
[명령어 with 의존 유닛 호출]
```

**결과 비교**:
| 항목 | Before | After |
|------|--------|-------|
| 속성1 | 값A | 값B |

**확인 포인트**:

- ✅ 의존 유닛 API 호출 성공
- ✅ 데이터 형식 일치
- ✅ 에러 처리 일관성

---

### 시나리오 C: [통합/연동 테스트]

**목적**: [이 시나리오가 검증하는 것]

**실행 순서**:

1. **Step 1**: [설명]

   ```bash
   [명령어]
   ```

   - 결과: [확인 사항]

2. **Step 2**: [설명]

   ```bash
   [명령어]
   ```

   - 결과: [확인 사항]

3. **Step 3**: [설명]

   ```bash
   [명령어]
   ```

   - 최종 산출물: [파일/API 응답/UI 변화]

---

## 4. 실행 결과 확인

### 4.1 로그 확인

- 위치: `logs/` 디렉토리 또는 콘솔 출력
- 주요 로그 메시지:
  - `[INFO] ...`: 정상 동작
  - `[WARN] ...`: 주의 필요
  - `[ERROR] ...`: 실패 (문제 해결 섹션 참조)

### 4.2 생성 파일

- `output/[파일명]`: [설명]
- `results/[파일명]`: [설명]

### 4.3 성능 지표 (선택)

- 처리 시간: [예: ~100ms]
- 메모리 사용량: [예: ~50MB]

### 4.4 성공/실패 판단 기준

**성공**:

- ✅ [기준 1]
- ✅ [기준 2]
- ✅ 의존 유닛과의 통합 동작 정상 (해당 시)

**실패 시 확인**:

- ❌ [문제 상황 1] → [해결 방법]
- ❌ [문제 상황 2] → [해결 방법]
- ❌ 의존 유닛 연동 실패 → 의존 유닛 상태 재확인

---

## 5. 문제 해결 (Troubleshooting)

### 5.1 일반적인 오류

**오류**: `[오류 메시지]`

- **원인**: [원인 설명]
- **해결**: [해결 방법]

**오류**: `[의존 유닛 연동 오류 메시지]` (해당 시)

- **원인**: 의존 유닛 미실행 또는 API 불일치
- **해결**:
  1. 의존 유닛 상태 확인: `vibe/unit-runbooks/[의존유닛]-runbook.md` 참조
  2. API 버전 호환성 확인
  3. 네트워크/포트 충돌 확인

### 5.2 환경별 주의사항

- **Windows**: [특이사항]
- **macOS/Linux**: [특이사항]

---

## 6. 다음 단계

[이 유닛을 기반으로 다음에 진행할 작업에 대한 간략한 안내 - 선택 사항]
````

---

## 7) 실제 사용 예시

### 예시 1: 의존성이 없는 유틸리티 함수 추가

```markdown
## [1.2] 완료: 문자열 정규화 유틸리티 추가

### 작업 범위

- `src/utils/string.ts`에 `normalizeWhitespace` 함수 구현
- 다중 공백을 단일 공백으로 변환하는 로직 추가

### 의존성

- 의존 유닛: 없음
- 외부 라이브러리: 없음 (순수 JavaScript)

### 생성/수정 파일

- `src/utils/string.ts` - 문자열 처리 유틸리티 모듈

### 구현 요약

**핵심 설계**:

- `normalizeWhitespace(input: string): string` - 정규식 기반 공백 정규화
- 엣지 케이스: null/undefined는 빈 문자열 반환

**외부 영향**:

- 없음 (순수 함수, 부작용 없음)

**가정 및 제약**:

- UTF-8 문자열 가정
- 개행 문자는 유지

### 런북 파일

- 경로: `runbooks/1.2-string-normalize-runbook.md`
- 상세 실행 가이드는 위 파일 참조

### 자체 점검 결과

- [x] 현재 단계 요구사항 100% 충족, 범위 초과 없음
- [x] 의존성 없음 확인 완료
- [x] 아키텍처/네이밍/경로 일관성 유지
- [x] 자동 테스트 미작성 (정책 준수)
- [x] 런북 파일 생성 완료
- [x] 파괴적 변경 없음
- [x] 다음 단계 제안 없음
```

### 예시 2: 의존성이 있는 인증 모듈 추가

```markdown
## [2.3] 완료: 사용자 인증 모듈 추가

### 작업 범위

- `src/auth/authenticator.ts`에 `UserAuthenticator` 클래스 구현
- 유닛 1.5 데이터베이스 레이어의 UserRepository 사용
- 유닛 2.1 암호화 유틸리티의 hashPassword/verifyPassword 사용

### 의존성

- **의존 유닛**: 1.5 (데이터베이스 레이어), 2.1 (암호화 유틸리티)
- **참조 문서**:
  - `dev-reports/[Depends 1.5].md` ✅ 읽음
  - `dev-reports/[Depends 2.1].md` ✅ 읽음
- **사용한 API**:
  - `UserRepository.findByEmail(email: string): Promise<User | null>`
  - `hashPassword(password: string): Promise<string>`
  - `verifyPassword(plain: string, hashed: string): Promise<boolean>`

### 생성/수정 파일

- `src/auth/authenticator.ts` - 인증 로직 구현 (신규)
- `src/types/auth.ts` - 인증 관련 타입 정의 (신규)

### 구현 요약

**핵심 설계**:

- `UserAuthenticator.authenticate(email, password)` - 이메일/비밀번호 인증
- `UserAuthenticator.register(userData)` - 신규 사용자 등록
- 의존 유닛의 에러 처리 방식 준수 (DatabaseError, HashingError)

**외부 영향**:

- UserRepository에 새로운 쿼리 부하 발생 (로그인 시 1회 조회)
- 암호화 유틸리티 호출로 CPU 사용량 증가 (bcrypt 연산)

**가정 및 제약**:

- UserRepository는 이미 초기화되어 있음
- 비밀번호 해싱은 bcrypt 알고리즘 사용 (유닛 2.1 정의)
- 데이터베이스 연결 실패 시 에러 전파 (재시도 로직 없음)

### 런북 파일

- 경로: `runbooks/2.3-auth-module-runbook.md`
- 상세 실행 가이드 및 의존성 테스트는 위 파일 참조

### 자체 점검 결과

- [x] 현재 단계 요구사항 100% 충족, 범위 초과 없음
- [x] 의존 유닛 개발 보고서 읽고 API 계약 이해 완료
- [x] 의존 유닛의 타입/인터페이스 재정의하지 않고 import만 사용
- [x] 의존 유닛의 에러 처리 방식 준수
- [x] 아키텍처/네이밍/경로 일관성 유지
- [x] 자동 테스트 미작성 (정책 준수)
- [x] 런북 파일에 의존성 확인 시나리오 포함
- [x] 파괴적 변경 없음
- [x] 다음 단계 제안 없음
```

---

## 8) 최종 체크리스트 (제출 전 필수 확인)

작업 완료 후 아래 모든 항목을 확인:

- [ ] **의존성 확인**: 섹션 9에서 의존성이 명시된 경우, 해당 개발 보고서 반드시 읽고 분석
- [ ] **의존성 준수**: 의존 유닛이 정의한 API/타입/계약 준수, 재정의 금지
- [ ] **범위 준수**: [현재 단계] 요구사항만 100% 충족, 범위 초과 없음
- [ ] **일관성**: 아키텍처/네이밍/디렉터리 구조 기존 코드와 일치
- [ ] **정책 준수**: 자동 테스트 미작성 (본 지침 정책)
- [ ] **런북 완비**: `vibe/unit-runbooks`에 md 파일 생성 완료
- [ ] **의존성 문서화**: 런북에 의존 유닛 확인 및 연동 테스트 시나리오 포함 (해당 시)
- [ ] **무결성 검증**: 린트/타입 체크 직접 실행 및 모든 오류 수정 완료
- [ ] **리스크 명시**: 가정/제약/파괴적 변경 사항 명시
- [ ] **산출물 형식**: 섹션 5) 형식 그대로 출력 (의존성 정보 포함)
- [ ] **금지 사항**: 다음 단계 제안/로드맵 언급 없음

---

## 9) 현재 진행할 단계 및 추가 지침
</file>

<file path="vibe/ready/lint-prompt.md">
# 코드 품질 지침 생성

## 참조 문서
1. `vibe/prd.md` - 프로젝트 요구사항
2. `vibe/tech-stack.md` - 기술스택 가이드
3. `.gemini/GEMINI.md` - 전역 지침 (우선순위 높음)
4. `.gemini/rules` - 세부 지침 저장 위치

## 작업
위 문서들을 분석하여 프로젝트에 적합한 **린트, 포맷, 타입 체크 지침**을 생성하세요.

### 분석 항목
- 사용 언어/프레임워크
- 기존 코드 컨벤션
- 전역 지침과의 정합성

### 출력
분석 결과를 바탕으로 적절한 지침 파일을 `.gemini/rules/lint-rules.md`에 생성하세요.

**파일명 규칙**: `[주제].md`

### 지침 파일 필수 포함 사항
- 사용 도구 및 설정 파일 내용
- 주요 규칙과 그 근거
- 실행 명령어
- 자동화 통합 방법 (scripts, hooks, CI)

## 제약
- `.gemini/GEMINI.md` 내용과 충돌 금지
- 모든 설정에 근거 명시
- 파일 생성 전 계획 공유 후 진행
</file>

<file path="vibe/ready/prd-prompt.md">
너는 숙련된 PM이다. 아래 입력을 바탕으로 **PRD문서**를 **마크다운**으로 작성하라. 비어 있는 항목은 AI가 **[AI초안]**으로 간결히 보완한다. 완성된 PRD 본문만 출력하고 설명·질문은 금지한다.

====================
[ 필수 입력 — BASIC ]
====================

- 제품명:
- 제품설명(구어체):
- ## 필수기능 2-3개:
  -
  -
- ## 레퍼런스 URL
  -
  - ===============================================================

---

## [ 선택 입력 — EXPAND ]

- 페르소나: <> | (비우면 [AI초안])
- 사용자 흐름: <> | (비우면 [AI초안])
- 리스크(+대응): <> | (비우면 [AI초안])
- 참고 링크: <> | (비우면 [AI초안] - 가능하면 웹검색을 통해 핵심 참고 링크 자동 첨부)

---

## 출력 규칙

### 1. 문서 구조

```markdown
# [제품명] PRD

## 1. 제품 개요

### 1.1 제품 설명

### 1.2 목표

## 2. 사용자 정의

### 2.1 타겟 페르소나

### 2.2 사용자 니즈

## 3. 핵심 기능

### 3.1 필수 기능

### 3.2 포함 사양

### 3.3 제외 사양

## 4. 사용자 여정

### 4.1 주요 사용자 흐름

## 5. 기술 요구사항

### 5.1 기능 요구사항

### 5.2 비기능 요구사항

## 6. 위험 요소 및 대응

### 6.1 주요 리스크

### 6.2 대응 방안

## 7. 성공 지표

## 8. 참고 자료
```

### 2. 작성 원칙

- **간결성**: 각 섹션당 2-4문장, 핵심만 기술
- **구체성**: 모호한 표현 금지, 명확한 기준 제시
- **실행가능성**: 개발 가능한 수준으로 상세화
- **AI초안 표기**: 보완한 내용은 반드시 `[AI초안]` 태그 포함

### 3. 금지사항

- 프롬프트 해석이나 질문 출력
- "이해했습니다", "작성하겠습니다" 등 응답
- PRD 외 부가 설명이나 조언
- 불완전한 문서나 초안 상태 출력

### 4. 필수 포함 요소

- 모든 입력 정보 반영
- 빈 항목은 [AI초안]으로 보완
- 웹검색 활용한 참고 링크 (선택입력 비어있을 때)
- 실무진이 바로 활용 가능한 수준의 완성도
</file>

<file path="vibe/ref/rembg-guide.md">
## rembg 배경 제거 도구

### 기본 명령어
```bash
rembg i [옵션] <input> <output>          # 단일 이미지
rembg p [옵션] <input_dir> <output_dir>  # 폴더 일괄
rembg d <model>                           # 모델 다운로드
```

---

### 모델 자동 선택 규칙

이미지 유형을 분석하여 최적의 모델을 선택하세요:

| 이미지 유형 | 키워드/특징 | 모델 | 추가 옵션 |
|------------|-------------|------|-----------|
| **UI 아이콘/픽셀 아트/로고/에셋** | icon, pixel art, logo, asset, UI, 아이콘, 로고 | `birefnet-general` | |
| **제품/오브젝트/사물/상품** | product, object, item, 제품, 물건, 상품 | `birefnet-general` | |
| **일본 애니메이션 캐릭터** (명확한 경우만) | anime character, 애니메이션 캐릭터 (셀 애니 스타일) | `isnet-anime` | |
| **게임 캐릭터/일러스트** (애니 스타일) | illustration, cartoon character, 일러스트 | `isnet-anime` | |
| **실사 인물 초상화/셀카/프로필** | portrait, selfie, headshot, 초상화, 셀카 | `birefnet-portrait` | `-a` |
| **인물 전신/단체 사진** | human, people, full body, 사람, 전신 | `u2net_human_seg` | `-a` |
| **의류/패션/옷** | clothing, fashion, outfit, 옷, 의류 | `u2net_cloth_seg` | |
| **복잡한 배경/고해상도** | complex, detailed, high-res, 복잡한, 고해상도 | `birefnet-dis` | |
| **최고 품질 필요** | best quality, professional, 최고품질 | `birefnet-massive` | |
| **속도 우선/대량 처리** | fast, batch, quick, 빠르게, 대량 | `u2netp` | |
| **경량/저사양** | lightweight, low memory, 경량 | `silueta` | |
| **범용/개선된 품질** | general, improved, 범용 | `isnet-general-use` | |
| **일반/불명확** | 기타 | `birefnet-general` | |

---

### 모델 선택 우선순위

1. **사용자가 모델 명시** → 해당 모델 사용
2. **UI 아이콘/로고/픽셀 아트** → `birefnet-general`
3. **제품/오브젝트/일반 사물** → `birefnet-general`
4. **실사 인물/사진** → `birefnet-portrait` + `-a`
5. **일본 애니메이션 스타일 캐릭터** (명확한 경우만) → `isnet-anime`
6. **속도 우선** → `u2netp`
7. **불명확** → `birefnet-general` (기본값)

> **핵심**: 기본값은 `birefnet-general`입니다. `isnet-anime`는 일본 애니메이션 스타일 캐릭터에만 사용하세요.

---

### 모델 선택 플로우차트

```
이미지 유형 판단
    │
    ├─ UI 아이콘/픽셀 아트/로고? ──→ birefnet-general
    │
    ├─ 제품/오브젝트/사물? ──→ birefnet-general
    │      ├─ 복잡한 배경 ──→ birefnet-dis
    │      └─ 최고 품질 ──→ birefnet-massive
    │
    ├─ 실사 인물?
    │      ├─ 얼굴/초상화 ──→ birefnet-portrait + -a
    │      ├─ 전신/단체 ──→ u2net_human_seg + -a
    │      └─ 의류 중심 ──→ u2net_cloth_seg
    │
    ├─ 일본 애니메이션 캐릭터? (셀 애니 스타일)
    │      └─ 명확한 경우만 ──→ isnet-anime
    │
    ├─ 속도 우선? ──→ u2netp 또는 silueta
    │
    └─ 불명확 ──→ birefnet-general (기본값)
```

---

### isnet-anime vs birefnet-general 비교

| 특성 | isnet-anime | birefnet-general |
|------|-------------|------------------|
| **용도** | 일본 애니메이션 캐릭터 | 제품/오브젝트/UI/일반 |
| **특징** | 셀 애니 스타일에 최적화 | 범용적, 안정적 |
| **경계 처리** | 부드러운 경계 보존 | 선명한 경계 유지 |
| **픽셀 아트** | 과도한 투명화 발생 | 적합 |
| **UI 아이콘** | 부적합 | 권장 |
| **기본값** | 아님 | 기본값 |

---

### Alpha Matting (-a 옵션) 사용 기준

다음 경우 `-a` 옵션 추가:
- 인물 사진 (머리카락 경계)
- 동물 사진 (털 경계)
- 복잡한 경계가 있는 이미지

다음 경우 `-a` 옵션 제외:
- 픽셀 아트 / UI 아이콘 (선명한 경계)
- 단순한 오브젝트
- 속도가 중요한 경우

---

### 출력 파일명 규칙

- 원본: `image.png`
- 출력: `image_transparent.png` 또는 `image_nobg.png`
- 폴더: 원본과 다른 폴더에 저장 권장

---

### 사용 예시

```bash
# UI 아이콘
rembg i -m birefnet-general icon.png icon_transparent.png

# 제품 사진
rembg i -m birefnet-general product.jpg product_transparent.png

# 인물 사진 (alpha matting)
rembg i -a -m birefnet-portrait photo.jpg photo_transparent.png

# 일본 애니메이션 캐릭터 (명확한 경우만)
rembg i -m isnet-anime anime_character.png character_transparent.png

# 빠른 처리
rembg i -m u2netp input.png output.png

# 폴더 일괄 처리
rembg p -m birefnet-general ./icons/ ./transparent/
```

---

### 주의사항

- 한글 경로 피하기 (영문 경로 권장)
- 지원 형식: PNG, JPG, JPEG, WEBP
- 첫 실행 시 모델 자동 다운로드 (100~200MB)
- 모델 다운로드 실패 시: `rembg d <model>`로 수동 다운로드
- 픽셀 아트/UI 아이콘에 `isnet-anime` 사용 시 과도한 투명화 발생 가능
</file>

<file path="vibe/ref/standard-guide.md">
## 리소스 탭: “권장 방향(심사 취지에 가까운 것)” 정리 (Devpost 공식 안내 기반)

### 1) 출발점: “무엇을 만들면 심사 취지에 맞는가”

- 이번 해커톤은 **“텍스트 기반 채팅 UI 하나”를 넘어서** Gemini 3의 강점을 드러내는 **고충실도(high-fidelity) 애플리케이션**을 기대한다고 명시합니다. :contentReference[oaicite:0]{index=0}
- Gemini 3를 **단순 챗봇이 아니라 ‘멀티모달 추론 엔진’**으로 규정하며, “보고(vision)·듣고(audio)·실시간으로 세계를 이해”하는 능력을 활용해 **감지(sense)하고 반응(react)하는 제품**을 만들라고 안내합니다. :contentReference[oaicite:1]{index=1}
- 또한 “Gemini 3의 출시는 **정적(static) 채팅에서, 계획·실행하는 자율 에이전트로 전환되는 ‘Action Era’**를 상징한다”는 관점을 전면에 둡니다. 즉, **장시간 실행·다단계 작업·자율적 검증** 같은 ‘시스템’ 지향 구현을 요구합니다. :contentReference[oaicite:2]{index=2}

---

### 2) 강하게 비권장(We strongly discourage)하는 프로젝트 유형

리소스 탭은 아래 유형을 “강하게 비권장”으로 명시합니다. 핵심 메시지는 “**한 번의 프롬프트로 해결되는 것은 앱이 아니다**—견고한 시스템/오케스트레이터를 보여달라”입니다. :contentReference[oaicite:3]{index=3}

1. **Baseline RAG**
   - Gemini 3 Pro는 매우 큰 컨텍스트(예: 대규모 문서/코드베이스를 한 번에 다루는 수준)를 전제로 하며,
   - 단순 검색/요약 수준의 데이터 리트리벌은 이제 “베이스라인”이므로, 그 이상(추론/오케스트레이션/행동)을 보여 달라는 취지입니다. :contentReference[oaicite:4]{index=4}

2. **Prompt Only Wrappers**
   - “기본 UI에 시스템 프롬프트를 감싼 정도”의 앱은 비권장입니다.
   - 즉, UI만 다르고 내부는 사실상 프롬프트 1장으로 동작하는 형태를 피하라는 의미입니다. :contentReference[oaicite:5]{index=5}

3. **Simple Vision Analyzers**
   - 단순 객체 인식/식별 같은 수준은 “구식”으로 보고,
   - 시간 축을 포함한 비디오 이해, 인과(cause-effect)까지 보는 **시공간(spatial-temporal) 이해** 같은 고급 활용을 기대한다고 적고 있습니다. :contentReference[oaicite:6]{index=6}

4. **Generic Chatbots**
   - 영양 상담, 채용 스크리닝, 성격 분석 등 “전형적인 봇” 형태는 비권장입니다.
   - 요지는 “또 하나의 챗봇”이 아니라 **새로운 사용자 경험과 시스템 설계**를 요구한다는 것입니다. :contentReference[oaicite:7]{index=7}

5. **Medical Advice**
   - 의료/정신건강 관련 “진단적 조언”을 생성하는 프로젝트는 금지/비권장 범주로 명시합니다. :contentReference[oaicite:8]{index=8}

---

### 3) Strategic Tracks (권장 방향의 예시 프레임)

리소스 탭은 아래 트랙을 “시장성 + 기술 깊이” 관점의 예시로 제시하며, **여기서 더 창의적으로 확장하라**고 안내합니다. :contentReference[oaicite:9]{index=9}  
(표현은 “이 프롬프트를 그대로 따라 하라”가 아니라, **Gemini 3 Pro의 잠재력을 보여주는 방향성**입니다.) :contentReference[oaicite:10]{index=10}

#### A. The Marathon Agent

- 목표: **수시간~수일**에 걸친 장기 태스크를 수행하는 **자율 시스템** 구축
- 포인트: 긴 작업에서 “연속성 유지/자기 수정”이 중요하며, 이를 위해 **Thought Signatures / Thinking Levels** 등을 활용해 다단계 툴 콜을 사람 개입 없이 수행하는 방향을 제시합니다. :contentReference[oaicite:11]{index=11}
  - 하위 예시: **Vibe Engineering**
    - Google AI Studio의 **Build 탭**과 **Google Antigravity**를 활용하라고 제안합니다.
    - 단순히 코드를 “작성”하는 에이전트가 아니라, **자율 테스트 루프 + 브라우저 기반 검증 아티팩트**(실행/검증 흔적)를 남기는 에이전트를 지향하라고 설명합니다. :contentReference[oaicite:12]{index=12}

#### B. The Real-Time Teacher

- 목표: **Gemini Live API**를 활용해 **라이브 비디오/오디오**를 합성·이해하고,
- 사용자에게 맞게 **실시간 적응형 학습 경험**을 제공하는 방향을 제시합니다. :contentReference[oaicite:13]{index=13}

#### C. Creative Autopilot

- 목표: Gemini 3의 추론을 **nanobanana mcp** 같은 멀티모달 생성/편집(개발용 에셋 제작 도구)과 결합해,
- “고정밀(High-precision) 제작”을 수행하는 **크리에이티브 오토파일럿**을 만들라는 방향입니다.
- 특히 **더 높은 해상도**, **국소적(Paint-to-Edit) 편집 컨트롤**, **브랜드 일관성**, **가독성 있는 텍스트** 등 “프로덕션 품질의 에셋 생성”을 강조합니다. :contentReference[oaicite:14]{index=14}

---

### 4) (참고) 리소스 탭이 함께 제공하는 시작 가이드 성격의 안내

- “무료 티어는 AI Studio에서만 제공”되며, 시작점으로 AI Studio의 **Build 탭**과 **Gallery 템플릿**을 권합니다. :contentReference[oaicite:15]{index=15}
- 추가로 Gemini API 문서/Antigravity/관련 영상 링크를 리소스로 제공합니다. :contentReference[oaicite:16]{index=16}
</file>

<file path="vibe/unit-plans/CP-MMP-01.md">
# CP-MMP-01: 체크포인트 - 배포/관측 게이트

## 메타데이터

| 항목      | 내용              |
| --------- | ----------------- |
| Unit ID   | CP-MMP-01         |
| Phase     | MMP               |
| 예상 소요 | 60분              |
| 의존성    | U-101,RU-010[Mmp] |
| 우선순위  | ⚡ Critical       |

## 작업 목표

Cloud Run 배포 환경에서 “관측 가능성(Queue/Badges/Auto-repair) + Hard Gate(스키마/경제/안전/일관성)”가 실제로 유지되는지 검증하고, 런북/증거를 남긴다.

**배경**: MMP는 데모가 “운영 가능한 품질”로 보이기 위해 배포/관측이 안정적으로 작동해야 한다. (PRD 10장, RULE-008)

**완료 기준**:

- 배포 환경에서 `/api/turn` HTTP Streaming(POST) 스트리밍이 동작하고, TTFB 체감이 유지된다(<2s 목표).
- Agent Console에서 Queue/Badges/Auto-repair 트레이스가 보인다(프롬프트 원문/CoT는 비노출). (RULE-008)
- 최소 1개 시나리오(U-105) 실행이 배포 환경에서 통과한다.

## 영향받는 파일

**생성**:

- `vibe/unit-runbooks/CP-MMP-01.md` - 배포/관측 체크 런북
- `vibe/unit-results/CP-MMP-01.md` - 결과/관측값/증거

**수정**:

- 없음(검증 단계)

**참조**:

- `vibe/prd.md` - Demo Mode/관측/TTFB 목표
- `vibe/tech-stack.md` - Cloud Run/Vertex 인증
- `.cursor/rules/00-core-critical.mdc` - RULE-007/008/003/004

## 구현 흐름

### 1단계: 배포 런북대로 실행/헬스 확인

- Cloud Run 배포 후 헬스 체크/기본 turn 실행 확인

### 2단계: 관측 UI/스트리밍 검증

- 단계(Queue)가 스트리밍으로 업데이트되는지 확인
- Badges(Schema/Economy/Safety/Consistency)가 표시되는지 확인
- Auto-repair가 발생하는 케이스에서 트레이스가 노출되는지 확인(메타만)

### 3단계: 시나리오 회귀(대표 1개 이상)

- U-105 시나리오 1개를 실행해 pass/fail를 기록한다.
- 실패 시 원인(턴/인바리언트)만 기록하고 프롬프트 원문은 남기지 않는다.

## 의존성 & 연결

**이전 작업에서 가져올 것**:

- **계획서**: [U-101[Mmp]](U-101[Mmp].md) - Cloud Run 배포/secret 가이드
- **계획서**: [RU-010[Mmp]](RU-010[Mmp].md) - SSOT 강화(스테이지/배지 정합)

**다음 작업에 전달할 것**:

- U-106(관측 고도화)와 U-108(보안 하드닝)에서 사용할 배포/관측 기준선

## 주의사항

**기술적 고려사항**:

- (RULE-007) 배포 로그/문서에 키/토큰/민감값을 남기지 않는다.
- (RULE-008) 관측은 메타만: 프롬프트/CoT 비노출.

**잠재적 리스크**:

- 배포 환경 CORS/네트워크로 프론트 연동이 깨질 수 있음 → 런북에 체크리스트/진단 절차 포함.

## 페어링 질문 (결정 필요)

- [ ] **Q1**: CP 결과물은 어느 수준으로 남길까?
  - Option A: 스크린샷 + 측정값(TTFB/응답시간) + pass/fail(권장)
  - Option B: 영상/라이브 링크까지(신뢰도↑, 비용↑)

## 참고 자료

- `vibe/prd.md` - 관측/TTFB/데모 요구
- `.cursor/rules/00-core-critical.mdc` - RULE-007/008/003/004
</file>

<file path="vibe/unit-plans/RU-005[Mvp].md">
# RU-005[Mvp]: 리팩토링 - orchestrator pipeline stages 정리

## 메타데이터

| 항목      | 내용        |
| --------- | ----------- |
| Unit ID   | RU-005[Mvp] |
| Phase     | MVP         |
| 예상 소요 | 60분        |
| 의존성    | U-018       |
| 우선순위  | High        |

## 작업 목표

모의/실모델 경로, 검증/복구 로직이 섞이며 복잡해진 오케스트레이터를 **단계(Stages) 기반으로 모듈화**해 유지보수성과 관측 가능성을 높인다(동작 보존).

**배경**: PRD는 Parse→Validate→Plan→Resolve→Render→Verify→Commit 과정을 UI로 보여 “오케스트레이션”을 증명해야 한다. 단계가 코드 구조로도 명확해야 한다. (RULE-008)

**완료 기준**:

- 오케스트레이터 코드가 stage 단위로 분리되어, 각 단계의 입력/출력이 명확해진다.
- stage 이벤트/배지/Auto-repair 트레이스 송출 위치가 일관되게 정리된다.
- 실모델/모의모드 전환이 파이프라인을 깨지 않고 동작한다(Behavior Preservation).

## 영향받는 파일

**생성**:

- `backend/src/unknown_world/orchestrator/stages/` - 단계 모듈(예: parse/validate/plan/resolve/render/verify/commit)
- `backend/src/unknown_world/orchestrator/pipeline.py` - stage 조합/실행기(선택)

**수정**:

- `backend/src/unknown_world/api/turn.py` - stage 이벤트 송출 위치 정리(필요 시)
- `backend/src/unknown_world/orchestrator/*` - 기존 로직을 stage로 이동(동작 보존)

**참조**:

- `vibe/prd.md` 6.8 - Action Queue/단계 가시화 요구
- `.cursor/rules/20-backend-orchestrator.mdc` - HTTP Streaming으로 단계 스트리밍
- `.cursor/rules/00-core-critical.mdc` - RULE-004/008

## 구현 흐름

### 1단계: stage 인터페이스 정의

- 각 stage의 입력/출력 타입(또는 컨텍스트 객체)을 정한다.
- “검증(스키마/비즈니스 룰)”과 “복구(repair)”가 어디에 붙는지 경계를 명확히 한다.

### 2단계: 로직 이동(Behavior Preservation)

- 기존 turn 처리 로직을 stage 모듈로 이동하되, 출력/이벤트/상태 변경이 동일하게 유지되게 한다.
- Auto-repair는 “실패 처리 경로”로서 pipeline 내부에서 통제한다.

### 3단계: 관측 가능성(단계/배지) 정합

- stage 이벤트 이름/순서가 PRD/프론트(Agent Console)와 일치하는지 점검한다.
- 배지 키(Schema/Economy/Safety/Consistency)가 일관되게 설정되는지 정리한다.

## 의존성 & 연결

**이전 작업에서 가져올 것**:

- **계획서**: [U-018[Mvp]](U-018[Mvp].md) - business rule 검증 + repair/fallback

**다음 작업에 전달할 것**:

- U-019~U-022(이미지/스캐너), U-024(Autopilot) 등 확장 기능이 stage 기반으로 자연스럽게 추가될 수 있는 구조
- CP-MVP-03 최종 데모에서 “과정이 보이는 시스템”을 안정적으로 제공

## 주의사항

**기술적 고려사항**:

- 리팩토링 유닛에서 새 기능을 추가하지 않는다(동작 보존).
- 프롬프트 원문/내부 추론/비밀정보는 어떤 stage에서도 로그/스트림으로 내보내지 않는다. (RULE-007/008)

**잠재적 리스크**:

- 모듈화 과정에서 이벤트 송출 타이밍이 바뀌어 UI가 달라질 수 있음 → CP-MVP-01/02 시나리오로 회귀 확인을 권장한다.

## 페어링 질문 (결정 필요)

- [ ] **Q1**: pipeline 실행 형태는 무엇이 좋을까?
  - Option A: `pipeline(ctx): ctx` 함수 체인(권장: 단순/테스트 용이)
  - Option B: 클래스 기반 파이프라인(확장에는 유리, 초기 복잡)

## 참고 자료

- `vibe/prd.md` - 단계/배지/관측 UX
- `.cursor/rules/20-backend-orchestrator.mdc` - HTTP Streaming 단계 스트리밍
- `.cursor/rules/00-core-critical.mdc` - RULE-004/008
</file>

<file path="vibe/unit-plans/U-002[Mvp].md">
# U-002[Mvp]: 프론트 Vite+React+TS 초기화 (/frontend)

## 메타데이터

| 항목      | 내용        |
| --------- | ----------- |
| Unit ID   | U-002[Mvp]  |
| Phase     | MVP         |
| 예상 소요 | 60분        |
| 의존성    | U-001       |
| 우선순위  | ⚡ Critical |

## 작업 목표

`vibe/tech-stack.md`에 고정된 버전으로 **Vite 7 + React 19 + TypeScript** 프론트엔드 개발 환경을 만들고, 로컬에서 즉시 실행 가능한 상태로 만든다.

**배경**: 데모/플레이 테스트를 지속하려면 “언제든 켤 수 있는 프론트”가 먼저 필요하다. (참조: `vibe/prd.md` 10장)

**완료 기준**:

- `frontend/`에서 `pnpm install` 및 `pnpm dev`가 성공한다.
- React/TS/Vite 버전이 `vibe/tech-stack.md`와 일치하도록 고정된다. (RULE-010)
- 채팅 버블 UI를 전제로 한 기본 템플릿(메신저 UI)로 발전하지 않도록, 이후 U-004에서 “고정 게임 UI”로 바로 확장할 수 있는 최소 구조가 준비된다. (RULE-002)

## 영향받는 파일

**생성**:

- `frontend/package.json` - React/Vite/TS 버전 고정 및 스크립트 정의
- `frontend/pnpm-lock.yaml` - pnpm lockfile
- `frontend/vite.config.ts` - 개발 서버/빌드 설정
- `frontend/tsconfig.json` - TS 설정(엄격 모드 권장)
- `frontend/index.html` - 엔트리 HTML(폰트 로드 등은 U-004에서)
- `frontend/src/main.tsx` - 엔트리 포인트
- `frontend/src/App.tsx` - 메인 컴포넌트(고정 레이아웃은 U-004)
- `frontend/src/style.css` - 단일 CSS 파일(CRT 토큰은 U-004)

**수정**:

- `prettier.config.cjs` (필요 시) - 프론트에서도 동일 규칙 적용(가능하면 재사용)

**참조**:

- `vibe/tech-stack.md` - 버전 고정(React 19.2.3, Vite 7.3.0, TS 5.9.3, pnpm 10.27.0)
- `vibe/ref/frontend-style-guide.md` - 단일 `style.css` 원칙, CRT 테마
- `.cursor/rules/10-frontend-game-ui.mdc` - 채팅 UI 금지, CRT, 고정 패널

## 구현 흐름

### 1단계: Vite + React + TS 스캐폴딩 생성

- `frontend/`에서 Vite React+TS 템플릿으로 초기화한다(패키지 매니저는 pnpm).
- 기본 엔트리(`src/main.tsx`, `src/App.tsx`)가 동작하는지 확인한다.

### 2단계: 버전/도구 고정

- `packageManager: "pnpm@10.27.0"`를 고정한다.
- 핵심 의존성(React/Vite/TS)을 `vibe/tech-stack.md` 기준으로 맞춘다. (RULE-010)

### 3단계: “게임 UI로 확장” 가능한 최소 구조 확보

- `src/style.css`를 “단일 CSS SSOT”로 두고, 컴포넌트별 스타일 분산을 피한다.
- U-004에서 고정 레이아웃/CRT 토큰을 바로 추가할 수 있도록 `App.tsx`는 최소한의 컨테이너 형태로 유지한다.

## 의존성 & 연결

**이전 작업에서 가져올 것**:

- **계획서**: [U-001[Mvp]](U-001[Mvp].md) - `frontend/` 디렉토리 스캐폴딩

**다음 작업에 전달할 것**:

- U-004에서 `frontend/src/App.tsx`와 `frontend/src/style.css`를 기반으로 CRT 테마/고정 레이아웃을 구현할 수 있는 실행 환경
- U-006에서 Zod 스키마를 추가할 수 있는 TypeScript 기반 프로젝트

## 주의사항

**기술적 고려사항**:

- (RULE-002) 채팅 UI를 전제로 하는 컴포넌트/레이아웃을 도입하지 않는다(메신저 버블 금지).
- (Frontend Style) 스타일은 `frontend/src/style.css` 단일 파일 + CSS 변수로만 확장한다(Tailwind 도입 금지).

**잠재적 리스크**:

- 템플릿 기본 UI가 “채팅처럼 보이는” 방향으로 유도될 수 있음 → U-004에서 즉시 고정 게임 UI로 전환하는 것을 크리티컬 패스로 둔다.

## 페어링 질문 (결정 필요)

- [ ] **Q1**: 루트에 pnpm workspace를 둘까?
  - Option A: `frontend/` 단독 패키지로 시작(권장: 초기 단순)
  - Option B: 루트 `pnpm-workspace.yaml` 구성(추후 shared 패키지 분리 시 유리)
  **A1**: Option A

## 참고 자료

- `vibe/tech-stack.md` - 프론트 버전/도구 SSOT
- `vibe/ref/frontend-style-guide.md` - CRT/단일 CSS 원칙
- `.cursor/rules/10-frontend-game-ui.mdc` - 게임 UI 고정 규칙
</file>

<file path="vibe/unit-plans/U-003[Mvp].md">
# U-003[Mvp]: 백엔드 FastAPI 초기화 (/backend)

## 메타데이터

| 항목      | 내용        |
| --------- | ----------- |
| Unit ID   | U-003[Mvp]  |
| Phase     | MVP         |
| 예상 소요 | 60분        |
| 의존성    | U-001       |
| 우선순위  | ⚡ Critical |

## 작업 목표

FastAPI 기반 오케스트레이터 백엔드의 “실행 가능한 최소 뼈대”를 만들고, 이후 유닛에서 TurnInput/TurnOutput 계약과 HTTP Streaming(POST) 기반 스트리밍을 얹을 수 있는 기반을 마련한다.

**배경**: Unknown World는 “string→string 채팅 API”가 아니라 Turn 계약 기반의 시스템이므로, 백엔드 골격부터 이를 전제로 잡아야 한다. (RULE-001)

**완료 기준**:

- `backend/`에서 FastAPI 앱이 기동되고 `/health` 같은 최소 엔드포인트로 헬스 체크가 가능하다.
- 로컬 개발에서 프론트와 통신할 수 있도록 CORS 기본 정책이 준비된다(엄격 모드는 MMP에서).
- 의존성 버전이 `vibe/tech-stack.md`를 SSOT로 고정한다. (RULE-010)

## 영향받는 파일

**생성**:

- `backend/requirements.txt` - FastAPI/Uvicorn/Pydantic 등 버전 고정(tech-stack 기준)
- `backend/src/unknown_world/main.py` - FastAPI 앱 엔트리 + 최소 라우트
- `backend/src/unknown_world/__init__.py` - 패키지 루트(구조 선택은 U-001 Q1 기반)

**수정**:

- 없음

**참조**:

- `vibe/tech-stack.md` - Python/FastAPI/Uvicorn/Pydantic 버전 SSOT
- `.cursor/rules/20-backend-orchestrator.mdc` - HTTP Streaming/Vertex/검증/복구 가이드
- `.cursor/rules/00-core-critical.mdc` - RULE-001/003/004/007/010

## 구현 흐름

### 1단계: 백엔드 패키지/엔트리 구성

- `backend/src/unknown_world/`를 애플리케이션 패키지 루트로 구성한다(Option A 기준).
- `main.py`에 FastAPI 앱 생성 및 최소 라우트(`/health`)를 추가한다.

### 2단계: 의존성 고정 및 실행 명령 합의

- `requirements.txt`에 FastAPI/Uvicorn/Pydantic 버전을 tech-stack 기준으로 고정한다. (RULE-010)
- 로컬 실행 커맨드(예: `uvicorn unknown_world.main:app --reload`)를 문서/런북에 일관되게 반영한다.

### 3단계: 프론트 연동을 위한 최소 CORS 준비

- 개발 환경에서만 허용하는 CORS(예: localhost) 기본 정책을 설정한다.

## 의존성 & 연결

**이전 작업에서 가져올 것**:

- **계획서**: [U-001[Mvp]](U-001[Mvp].md) - `backend/` 디렉토리 스캐폴딩

**다음 작업에 전달할 것**:

- U-005에서 TurnInput/TurnOutput(Pydantic) 모델을 추가할 수 있는 패키지 구조
- U-007에서 `/api/turn` HTTP Streaming(POST) 라우트를 추가할 수 있는 FastAPI 앱 엔트리

## 주의사항

**기술적 고려사항**:

- (RULE-007) 인증은 Vertex 서비스 계정이며, 사용자 키 입력(BYOK) 흐름을 만들지 않는다.
- (RULE-010) 문서 합의 없이 DB/ORM 도입 금지: 저장은 SaveGame(JSON) 중심으로 설계한다.

**잠재적 리스크**:

- 초기 패키지 구조를 잘못 잡으면 이후 임포트/배포 정리가 반복됨 → U-001 Q1 결정을 선행하고, RU-001에서 정리한다.

## 페어링 질문 (결정 필요)

- [ ] **Q1**: 파이썬 의존성 관리는 무엇으로 고정할까?
  - Option A: `requirements.txt`(권장: 단순/명확, CI도 쉬움)
  - Option B: `pyproject.toml` 기반(추가 도구/합의 필요)

## 참고 자료

- `vibe/tech-stack.md` - 백엔드 버전 SSOT
- `.cursor/rules/20-backend-orchestrator.mdc` - HTTP Streaming/검증/복구 기준
</file>

<file path="vibe/unit-plans/U-004[Mvp].md">
# U-004[Mvp]: CRT 테마/고정 레이아웃 스켈레톤 (/frontend/src)

## 메타데이터

| 항목      | 내용        |
| --------- | ----------- |
| Unit ID   | U-004[Mvp]  |
| Phase     | MVP         |
| 예상 소요 | 60분        |
| 의존성    | U-002       |
| 우선순위  | ⚡ Critical |

## 작업 목표

채팅 UI가 아닌 “게임 화면”으로 보이도록, **고정 HUD 레이아웃 + CRT 테마 토큰**을 먼저 구현해 데모 표면을 고정한다.

**배경**: 심사/데모 실패의 가장 큰 위험은 “메신저처럼 보임”이며, PRD는 채팅 버블 UI를 명시적으로 금지한다. (RULE-002)

**완료 기준**:

- 화면에 최소 UI 구성요소(씬 캔버스, 액션덱, 인벤토리, 퀘스트, 룰보드, 경제 HUD, 에이전트 콘솔, 스캐너 슬롯)가 “자리”로 항상 존재한다.
- CRT 테마가 CSS 변수 기반(`style.css` 단일 파일)으로 적용된다. (Frontend Style Guide)
- 내러티브는 “채팅 버블”이 아니라 **게임 로그/내러티브 피드** 형태로 배치된다. (RULE-002)

## 영향받는 파일

**생성**:

- `frontend/src/components/layout/` - (선택) 패널/레이아웃 컴포넌트 분리 시 사용

**수정**:

- `frontend/src/App.tsx` - 고정 레이아웃(HEADER/CENTER/SIDE/FOOTER) 스켈레톤 구성
- `frontend/src/style.css` - CRT CSS 변수/오버레이/레이아웃 스타일 정의(단일 SSOT)
- `frontend/index.html` - 폰트 로드/`data-theme` 적용(필요 시)

**참조**:

- `vibe/prd.md` 6.7/6.8/9장 - 데모 표면 필수 UI, 채팅 UI 금지
- `vibe/ref/frontend-style-guide.md` - CRT 토큰, 단일 CSS, 기본 레이아웃
- `.cursor/rules/10-frontend-game-ui.mdc` - 고정 게임 UI/CRT/DnD/에이전트콘솔 규칙

## 구현 흐름

### 1단계: CRT 테마 토큰(변수) 확정

- `:root` CSS 변수로 `--bg-color`, `--text-color`, `--accent-color` 등을 정의한다.
- 오버레이(스캔라인/플리커)는 `pointer-events: none`으로 상호작용을 방해하지 않게 한다.

### 2단계: 고정 레이아웃 스켈레톤 구성

- Header: 타이틀/언어 토글/테마 토글/연결 상태/재화 HUD 자리
- Center: Scene Canvas 자리(이미지/핫스팟 오버레이는 U-010에서)
- Side: Inventory / Quest / Rule Board / Agent Console / Memory Pin / Scanner 자리
- Footer: Action Deck 자리 + (선택) 커맨드 입력 자리

### 3단계: “채팅처럼 보이지 않는” 내러티브 피드 배치

- 내러티브는 좌/우 버블 대신, 로그 리스트(턴 타임라인) 형태로 배치한다.
- 이후 U-008에서 스트리밍을 연결해도 UI가 채팅 UI로 퇴행하지 않게 구조를 고정한다.

## 의존성 & 연결

**이전 작업에서 가져올 것**:

- **계획서**: [U-002[Mvp]](U-002[Mvp].md) - Vite+React+TS 실행 환경

**다음 작업에 전달할 것**:

- U-009~U-012에서 패널별 실제 기능(Action Deck/Hotspot/DnD)을 구현할 고정 UI 슬롯
- RU-001에서 “초기 레이아웃/스타일 규칙”을 SSOT(가이드/규칙)와 정합화할 기준선

## 주의사항

**기술적 고려사항**:

- (RULE-002) 채팅 버블/메신저 레이아웃 금지: “로그 피드 + 게임 HUD”로 고정한다.
- (Frontend Style) 스타일은 `frontend/src/style.css` 단일 파일 + CSS 변수로만 확장한다.

**잠재적 리스크**:

- 초기 레이아웃이 추후 기능 추가로 무너지거나, 임시 UI가 채팅처럼 보일 수 있음 → “패널 자리 고정 + 로그 피드”를 먼저 완성하고 이후 기능을 채운다.

## 페어링 질문 (결정 필요)

- [ ] **Q1**: 레이아웃 구현을 어떤 방식으로 고정할까?
  - Option A: CSS Grid 기반(권장: 패널 고정/반응형 조절 용이)
  - Option B: Flex 기반(단순하지만 복잡한 고정 패널에서 유지보수 비용 증가)

## 참고 자료

- `vibe/prd.md` - 데모 표면(UI/동작) 요구
- `vibe/ref/frontend-style-guide.md` - CRT 스타일/레이아웃
- `.cursor/rules/10-frontend-game-ui.mdc` - 프론트 UI 규칙
</file>

<file path="vibe/unit-plans/U-005[Mvp].md">
# U-005[Mvp]: TurnInput/TurnOutput 스키마(Pydantic)

## 메타데이터

| 항목      | 내용        |
| --------- | ----------- |
| Unit ID   | U-005[Mvp]  |
| Phase     | MVP         |
| 예상 소요 | 60분        |
| 의존성    | U-003       |
| 우선순위  | ⚡ Critical |

## 작업 목표

백엔드에서 TurnInput/TurnOutput을 **Pydantic 모델로 정의**하고, Gemini Structured Outputs에 투입 가능한 **JSON Schema(부분집합)** 를 생성할 수 있게 만든다.

**배경**: Unknown World의 핵심은 “말만 하는 텍스트”가 아니라, UI/상태/비용을 포함한 **구조화 결과**이며 서버/클라 이중 검증이 Hard Gate다. (RULE-003)

**완료 기준**:

- TurnInput/TurnOutput Pydantic 모델이 정의되어 있고, 최소 요구 필드(언어/내러티브/UI/경제/안전/좌표/배지)가 포함된다.
- TurnOutput JSON Schema를 생성할 수 있고(Structured Outputs용), 스키마는 과도한 중첩/복잡 제약을 피한다. (Structured Outputs 가이드)
- bbox/핫스팟 좌표 규약(0~1000, `[ymin,xmin,ymax,xmax]`)과 ko/en 언어 정책이 스키마 수준에서 명확히 드러난다. (RULE-006/009)

## 영향받는 파일

**생성**:

- `backend/src/unknown_world/models/turn.py` - TurnInput/TurnOutput(Pydantic) 및 하위 타입 정의
- `backend/src/unknown_world/models/__init__.py` - 모델 패키지 노출(선택)

**수정**:

- 없음

**참조**:

- `vibe/prd.md` 8.7 - TurnInput/TurnOutput 필드 방향
- `vibe/ref/structured-outputs-guide.md` - JSON Schema 제약(부분집합/flat)
- `.cursor/rules/00-core-critical.mdc` - RULE-003/004/005/006/009

## 구현 흐름

### 1단계: 스키마 범위 확정(“UI 고정 패널” 중심)

- TurnOutput이 반드시 포함해야 하는 패널 데이터를 정리한다:
  - Action Deck(카드 3~6장, 비용/위험/대안)
  - Scene Objects/Hotspots(box_2d)
  - Inventory/Quest/Rule Board/Economy HUD/Agent Console
- Hard Gate 필드(경제/안전/언어/좌표/배지)를 required로 고정한다.

### 2단계: Pydantic 모델 설계(부분집합/단순성 유지)

- enum(언어/라벨/단계/배지)을 적극 사용해 출력 공간을 줄인다.
- `extra="forbid"` 성격으로 불명확한 필드 유입을 차단한다(가능한 범위).
- 깊은 중첩/복잡한 anyOf/oneOf를 피하고, 구조는 “평평하게” 유지한다.

### 3단계: 스키마/검증 훅 제공

- TurnOutput JSON Schema를 Gemini 호출(`response_json_schema`)에 바로 넣을 수 있도록 생성 경로를 마련한다.
- 최종 응답 텍스트를 `model_validate_json`으로 검증할 수 있도록 “검증 entrypoint”를 정한다.

## 의존성 & 연결

**이전 작업에서 가져올 것**:

- **계획서**: [U-003[Mvp]](U-003[Mvp].md) - FastAPI 프로젝트 골격/패키지 구조

**다음 작업에 전달할 것**:

- U-007에서 모의 Orchestrator가 생성할 TurnOutput의 계약(서버 검증 기준)
- U-017에서 실제 Gemini Structured Outputs 호출 시 사용할 스키마 SSOT(서버 측)

## 주의사항

**기술적 고려사항**:

- (RULE-004) 스키마 통과만으로 충분하지 않다 → 경제/언어/좌표 같은 비즈니스 룰 검증을 별도로 두고 Repair loop 대상으로 포함한다.
- (RULE-005) `economy.cost`와 `economy.balance_after`는 항상 포함되며 잔액 음수는 절대 불가(서버 Hard gate).

**잠재적 리스크**:

- 스키마가 너무 복잡하면 모델/SDK가 거부하거나 실패율이 급증 → “필수 필드 고정 + 중첩 최소화”로 시작하고, 필요 시 분할(메타/부가 정보는 축소)한다.

## 페어링 질문 (결정 필요)

- [ ] **Q1**: Action Deck 필드 구조를 어떻게 둘까? (PRD 용어 정합성 우선)
  - Option A: `ui.action_deck.cards[]` (권장: 용어/구조 명확)
  - Option B: `ui.choices[]`로 단일화(단, “채팅 선택지” 오해 위험)
  **A1**: Option A
- [ ] **Q2**: TurnOutput은 `world.delta` 중심으로 갈까, `world.snapshot`을 항상 포함할까?
  - Option A: `world.delta` + SaveGame에만 snapshot 저장(권장: 페이로드 절감)
  - Option B: 매 턴 snapshot 포함(디버그는 쉽지만 비용/지연 증가)
  **A2**: Option A

## 참고 자료

- `vibe/prd.md` - Turn 계약/하드 게이트/좌표 규약
- `vibe/ref/structured-outputs-guide.md` - JSON Schema 부분집합/스트리밍
- `.cursor/rules/00-core-critical.mdc` - RULE-003/004/005/006/009
</file>

<file path="vibe/unit-plans/U-007[Mvp].md">
# U-007[Mvp]: 모의 Orchestrator + /api/turn HTTP Streaming(POST)

## 메타데이터

| 항목      | 내용        |
| --------- | ----------- |
| Unit ID   | U-007[Mvp]  |
| Phase     | MVP         |
| 예상 소요 | 75분        |
| 의존성    | U-005       |
| 우선순위  | ⚡ Critical |

## 작업 목표

실모델(Gemini) 없이도 프론트가 개발/데모를 지속할 수 있도록, **모의 Orchestrator**로 TurnOutput을 생성하고 이를 **HTTP Streaming(POST 응답 스트림)** 으로 전달하는 `/api/turn` 엔드포인트를 구현한다.

**배경**: “항상 플레이 가능한 데모”를 유지하려면, 모델 연결이 없어도 UI/상태/경제/검증 흐름을 끝까지 흘릴 수 있어야 한다. (PRD 10장, RULE-008)

**완료 기준**:

- `/api/turn`이 `POST` 요청을 받고, `StreamingResponse`로 stage/배지/Auto-repair(필요 시)/final TurnOutput을 **NDJSON(라인 단위 JSON)** 이벤트로 순차 스트리밍한다.
- 최종 TurnOutput이 Pydantic 검증을 통과하고, 실패 시에도 스키마 준수 폴백을 반환한다. (RULE-003/004)
- box_2d 좌표 규약(0~1000, `[ymin,xmin,ymax,xmax]`)을 포함한 “클릭 가능한 장면” 데이터가 모의로라도 생성된다. (RULE-009)

## 영향받는 파일

**생성**:

- `backend/src/unknown_world/api/turn.py` - `/api/turn` HTTP Streaming(POST) 라우트 및 NDJSON 스트리밍 로직
- `backend/src/unknown_world/orchestrator/mock.py` - 모의 TurnOutput 생성기(결정적 seed 기반)

**수정**:

- `backend/src/unknown_world/main.py` - 라우터 등록 및 CORS/미들웨어 정리(필요 시)

**참조**:

- `.cursor/rules/20-backend-orchestrator.mdc` - HTTP Streaming/검증/복구 기준
- `.cursor/rules/00-core-critical.mdc` - RULE-003/004/008/009
- `vibe/prd.md` 6.8/10장 - Queue/Badges/Auto-repair 가시화, TTFB

## 구현 흐름

### 1단계: 스트림 이벤트 계약 확정(NDJSON)

- 최소 이벤트 타입을 정의한다: `stage`, `badges`(또는 stage 내 포함), `narrative_delta`, `final`, `error`(필요 시).
- stage 이름은 PRD 예시( Parse→Validate→Plan→Resolve→Render→Verify→Commit )로 통일한다.

### 2단계: 모의 Orchestrator 구현(결정적/저비용)

- TurnInput(텍스트/클릭/드래그/업로드)에 따라 TurnOutput을 생성하되, seed 기반으로 재현 가능하게 만든다.
- Action Deck(3~6), Hotspots(box_2d), Inventory/Quest/Rules/Economy를 최소 한 번씩 포함하도록 “데모 친화”로 구성한다.

### 3단계: `/api/turn` HTTP Streaming 구현(NDJSON)

- 요청 수신 즉시 `{"type":"stage","name":"Parse","status":"start"}` 같은 이벤트를 먼저 전송해 TTFB를 확보한다.
- 단계별로 이벤트를 스트리밍한 뒤, 최종 `final` 이벤트에 TurnOutput JSON을 포함한다.
- 서버에서 TurnOutput을 Pydantic으로 검증하고, 실패 시 safe fallback TurnOutput을 생성해 반환한다. (RULE-004)

## 의존성 & 연결

**이전 작업에서 가져올 것**:

- **계획서**: [U-005[Mvp]](U-005[Mvp].md) - TurnOutput 스키마/검증 기준
- **계획서**: [U-003[Mvp]](U-003[Mvp].md) - FastAPI 앱 엔트리/라우팅 기반

**다음 작업에 전달할 것**:

- U-008에서 스트림 이벤트를 소비해 Agent Console/내러티브/패널을 업데이트할 수 있는 스트림
- CP-MVP-01에서 “스트리밍/스키마/폴백” 체크포인트를 수행할 수 있는 최소 백엔드 루프

## 주의사항

**기술적 고려사항**:

- (RULE-008) 스트리밍은 “과정”을 보여주는 기능이다: stage/badges/repair 트레이스는 반드시 이벤트로 제공한다.
- (RULE-007) 디버그 편의로 프롬프트 원문/내부 추론/비밀정보를 스트림에 섞지 않는다.

**잠재적 리스크**:

- 이벤트 포맷이 불명확하면 프론트 파서 구현이 어려움 → U-008과 함께 최소 계약을 먼저 확정하고, RU-002에서 타입/폴백을 통일한다.

## 페어링 질문 (결정 필요)

- [ ] **Q1**: 스트림 포맷을 무엇으로 고정할까?
  - Option A: NDJSON(라인 단위 JSON) (권장: POST+fetch 스트리밍에 단순/견고)
  - Option B: Data Stream Protocol(예: `0:` 텍스트, `1:` UI, `2:` 시스템 JSON) (표현은 간단하지만 규약 설명 필요)
  **A1**: Option A

## 참고 자료

- `vibe/prd.md` - Queue/Badges/TTFB/Auto-repair 요구
- `.cursor/rules/20-backend-orchestrator.mdc` - HTTP Streaming 구현 규칙
- `.cursor/rules/00-core-critical.mdc` - RULE-003/004/007/008/009
</file>

<file path="vibe/unit-plans/U-009[Mvp].md">
# U-009[Mvp]: Action Deck(카드+비용/대안)

## 메타데이터

| 항목      | 내용        |
| --------- | ----------- |
| Unit ID   | U-009[Mvp]  |
| Phase     | MVP         |
| 예상 소요 | 60분        |
| 의존성    | U-004,U-008 |
| 우선순위  | ⚡ Critical |

## 작업 목표

턴 결과(TurnOutput)로부터 **Action Deck(3~6장 카드)** 을 렌더링하고, 카드 클릭으로 다음 턴 실행까지 연결한다(채팅 선택지가 아니라 “게임 카드”).

**배경**: PRD는 심사자 오해 방지를 위해 “Action Deck(비용/위험/보상 포함)”을 데모 표면에 상시 노출하라고 요구한다. (PRD 6.7, RULE-002)

**완료 기준**:

- Footer 영역에 Action Deck이 상시 노출되고, 카드가 3~6장으로 렌더링된다.
- 각 카드에 **예상 비용(최소/최대)** 과 위험/보상 힌트가 표기된다. (RULE-005)
- 카드 클릭 시 TurnInput으로 “선택된 행동”이 전송되고, HTTP Streaming(Queue/Badges)이 갱신된다. (RULE-008)

## 영향받는 파일

**생성**:

- `frontend/src/components/ActionDeck.tsx` - 카드 UI(비용/위험/보상/대안 표기)
- `frontend/src/stores/actionDeckStore.ts` - (선택) Action Deck 상태/선택 저장

**수정**:

- `frontend/src/App.tsx` - Action Deck 배치 및 클릭→turn 실행 연결
- `frontend/src/style.css` - 카드 레이아웃/호버/비활성 스타일(단일 CSS)

**참조**:

- `vibe/prd.md` 6.7 - Action Deck 요구사항(3~6장, 비용/위험/보상)
- `.cursor/rules/10-frontend-game-ui.mdc` - Action Deck 비용/대안 표기
- `.cursor/rules/00-core-critical.mdc` - RULE-002/005/008

## 구현 흐름

### 1단계: TurnOutput → Action Deck 렌더 모델 연결

- Zod 스키마(U-006)의 Action Deck 구조를 기준으로 카드 렌더링 모델을 정한다.
- 카드 필수 필드(라벨/비용추정/위험/보상/대안)를 정리한다.

### 2단계: 카드 UI(게임 카드) 구현

- 카드 수는 3~6장으로 고정하고, “메시지 버튼”처럼 보이지 않도록 카드 스타일을 적용한다.
- 잔액 부족 시 실행 불가를 명확히 표시하고, 대체 행동(저비용/텍스트-only)을 덱에 함께 노출한다. (RULE-005)

### 3단계: 카드 클릭 → TurnInput 실행 연결

- 카드 클릭 시 TurnInput에 `action_id`(또는 동등 식별자)를 포함해 `/api/turn`을 호출한다.
- 호출 중에는 Agent Console에 단계/배지 업데이트가 보이도록 U-008 흐름을 그대로 사용한다.

## 의존성 & 연결

**이전 작업에서 가져올 것**:

- **계획서**: [U-004[Mvp]](U-004[Mvp].md) - 고정 HUD 레이아웃(footer 슬롯)
- **계획서**: [U-008[Mvp]](U-008[Mvp].md) - turn 실행/스트림 소비/Agent Console

**다음 작업에 전달할 것**:

- U-014(Economy HUD+Ledger)에서 “가용 잔액 vs 비용 추정” 표시를 강화할 기반
- CP-MVP-02에서 “클릭 조작” 핵심 데모 케이스로 사용

## 주의사항

**기술적 고려사항**:

- (RULE-002) Action Deck은 채팅 선택지 UI로 보이면 안 된다(버블/버튼 행 금지).
- (RULE-005) 비용은 “사전 표시 + 부족 시 대안 제공”이 기본 UX다.

**잠재적 리스크**:

- 카드가 “그냥 버튼 모음”처럼 보일 수 있음 → 카드 프레이밍(위험/보상/비용)을 강하게 넣고, HUD 레이아웃 내에 고정한다.

## 페어링 질문 (결정 필요)

- [ ] **Q1**: “실행 가능 여부(affordable)” 판단을 어디서 할까?
  - Option A: 서버가 카드에 `enabled`/`disabled_reason`를 내려준다(권장: 일관성)
  - Option B: 클라이언트가 `balance_after`/현재 잔액으로 계산한다(초기 빠르지만 드리프트 위험)

## 참고 자료

- `vibe/prd.md` - 데모 표면(Action Deck) 요구
- `.cursor/rules/10-frontend-game-ui.mdc` - 카드 비용/대안 UX
- `.cursor/rules/00-core-critical.mdc` - RULE-002/005/008
</file>

<file path="vibe/unit-plans/U-018[Mvp].md">
# U-018[Mvp]: 비즈니스 룰 검증 + Repair loop + 안전 폴백

## 메타데이터

| 항목      | 내용        |
| --------- | ----------- |
| Unit ID   | U-018[Mvp]  |
| Phase     | MVP         |
| 예상 소요 | 75분        |
| 의존성    | U-017       |
| 우선순위  | ⚡ Critical |

## 작업 목표

스키마 검증 이후에도 남는 “의미적 실패(경제/언어/좌표/안전)”를 서버에서 Hard gate로 검증하고, 실패 시 **Repair loop(재시도 제한)** 와 **안전 폴백**으로 항상 턴을 종료할 수 있게 만든다.

**배경**: PRD의 Hard Gate는 “스키마 OK”만이 아니라 Economy/Safety/Consistency까지 포함하며, 실패는 자동 복구 루프로 처리해야 한다. (RULE-004/005)

**완료 기준**:

- 스키마 통과 후에도 비즈니스 룰 검증이 수행된다(경제/언어/좌표/안전).
- 실패 시 `max_repair_attempts` 내에서 repair 재요청이 수행되고, UI에는 Auto-repair #n 결과만 노출된다. (RULE-004/008)
- 복구 실패 시에도 **스키마를 만족하는 안전 폴백 TurnOutput**으로 종료된다(텍스트-only 포함). (RULE-004)

## 영향받는 파일

**생성**:

- `backend/src/unknown_world/validation/business_rules.py` - Economy/Language/Box2D 등 비즈니스 룰 검증
- `backend/src/unknown_world/orchestrator/repair_loop.py` - repair 요청/재시도/종료(폴백) 로직
- `backend/src/unknown_world/orchestrator/fallback.py` - 안전 폴백 TurnOutput 생성기

**수정**:

- `backend/src/unknown_world/api/turn.py` - Auto-repair 스트림 이벤트(NDJSON) 송출/연결(필요 시)
- `backend/src/unknown_world/orchestrator/generate_turn_output.py` - 실패 정보 전달/repair 입력 구성(필요 시)

**참조**:

- `.cursor/rules/00-core-critical.mdc` - RULE-004/005/006/009/008
- `.gemini/GEMINI.md` (structured-output/economy/safety imports) - 검증/복구 체크리스트
- `vibe/prd.md` 10.5 - Hard gate(스키마/경제/안전) 품질 게이트

## 구현 흐름

### 1단계: 비즈니스 룰 검증기 정의

- Economy: cost/balance_after 일관성, 잔액 음수 금지, 예상 비용 누락 금지
- Language: TurnInput.language와 TurnOutput.language 불일치/혼합 징후 차단
- Box2D: 0~1000 범위 + `[ymin,xmin,ymax,xmax]` 순서 검증
- Safety: blocked 시에도 스키마 준수 + 대체 결과 제공

### 2단계: Repair loop(제한된 재시도) 구현

- 검증 실패 시: 실패 요약(짧게) + “스키마/룰에 맞게 수정하라” 지시로 재요청한다(프롬프트 원문/CoT 노출 금지).
- 재시도 횟수 제한(`max_repair_attempts`)을 두고, 시도마다 스트림(NDJSON)로 `Auto-repair #n` 이벤트를 송출한다. (RULE-008)

### 3단계: Safe fallback TurnOutput 설계

- 최종 실패 시에도 UI가 빈 화면이 되지 않게:
  - narrative: “안전하게 텍스트-only로 진행합니다” 같은 안내(언어 고정)
  - ui: 최소 패널 자리 유지(액션덱에 저비용 대안 포함)
  - render.image_job.should_generate=false
  - economy: 비용 0 또는 보수적 처리(ledger 일관성 유지)

## 의존성 & 연결

**이전 작업에서 가져올 것**:

- **계획서**: [U-017[Mvp]](U-017[Mvp].md) - Structured Outputs 호출 + Pydantic 스키마 검증

**다음 작업에 전달할 것**:

- RU-005에서 정리할 “Parse→…→Commit” 파이프라인의 검증/복구 표준
- U-024(Autopilot) 등 고급 흐름에서도 재사용할 repair/fallback 기반

## 주의사항

**기술적 고려사항**:

- (RULE-005) 경제 인바리언트는 서버에서 Hard gate로 보장해야 한다(클라만 믿지 않음).
- (RULE-008) 관측은 “결과/횟수”만: 프롬프트 원문/내부 추론을 이벤트로 보내지 않는다.

**잠재적 리스크**:

- repair가 무한 루프/비용 폭증으로 이어질 수 있음 → 반드시 재시도 횟수 제한 + 최종 폴백으로 종료한다.

## 페어링 질문 (결정 필요)

- [ ] **Q1**: `max_repair_attempts`는 MVP에서 몇으로 둘까?
  - Option A: 2회(권장: 비용/지연 방지)
  - Option B: 3회(복구 성공률↑, 비용/지연↑)

## 참고 자료

- `vibe/prd.md` - Hard Gate/Repair loop 요구
- `.cursor/rules/00-core-critical.mdc` - RULE-004/005/006/008/009
</file>

<file path="vibe/unit-plans/U-019[Mvp].md">
# U-019[Mvp]: 이미지 생성 엔드포인트/잡(조건부)

## 메타데이터

| 항목      | 내용        |
| --------- | ----------- |
| Unit ID   | U-019[Mvp]  |
| Phase     | MVP         |
| 예상 소요 | 75분        |
| 의존성    | U-016,U-017 |
| 우선순위  | ⚡ Critical |

## 작업 목표

장면 이미지를 “선택적으로” 생성할 수 있도록, 백엔드에 **이미지 생성 엔드포인트/잡**을 추가하고 `gemini-3-pro-image-preview` 모델로 고정한다.

**배경**: PRD는 텍스트 우선 + Lazy 이미지 생성/편집을 요구하며, 이미지 모델 ID는 고정이다. (RULE-010, PRD 6.3/8.5)

**완료 기준**:

- 이미지 생성 요청이 별도 경로(엔드포인트/잡)로 수행되어, 텍스트 턴의 TTFB를 블로킹하지 않는다. (RULE-008)
- 이미지 모델 ID는 `gemini-3-pro-image-preview`로 고정되고 혼용되지 않는다. (RULE-010)
- 실패 시에도 텍스트-only로 진행 가능하도록 안전한 오류/폴백 응답이 존재한다. (RULE-004)

## 영향받는 파일

**생성**:

- `backend/src/unknown_world/api/image.py` - 이미지 생성 요청 엔드포인트
- `backend/src/unknown_world/services/image_generation.py` - 이미지 생성 호출/저장 로직

**수정**:

- `backend/src/unknown_world/main.py` - 라우터 등록(필요 시)

**참조**:

- `vibe/tech-stack.md` - 이미지 모델 ID 고정
- `.cursor/rules/00-core-critical.mdc` - RULE-004/008/010
- `.cursor/rules/20-backend-orchestrator.mdc` - 텍스트 우선 + Lazy 이미지 원칙

## 구현 흐름

### 1단계: 이미지 생성 요청 계약 정의

- 입력: `prompt`, `aspect_ratio`, `image_size`, (선택) `reference_images`
- 출력: `image_url`(또는 job_id), `status`, 실패 시 `message`
- TurnOutput의 `render.image_job`과 정합되도록 필드/용어를 맞춘다.

### 2단계: 이미지 생성 호출(모델 고정) + 저장

- 호출은 `gemini-3-pro-image-preview`로만 수행한다.
- 저장은 MVP에서는 로컬 저장/서빙(또는 메모리)로 시작하고, GCS는 MMP(U-102)에서 확장한다.

### 3단계: 실패/안전/비용 고려

- 이미지 생성 실패 시: 텍스트-only 진행 가능하도록 `should_generate=false` 폴백을 지원한다.
- (가능하면) 잔액 부족/정책상 불가 시 “대체 행동”을 반환한다(저해상도/생략). (RULE-005)

## 의존성 & 연결

**이전 작업에서 가져올 것**:

- **계획서**: [U-016[Mvp]](U-016[Mvp].md) - GenAI 클라이언트/모델 라벨 고정
- **계획서**: [U-017[Mvp]](U-017[Mvp].md) - TurnOutput 생성(이미지 job 필드 정합)

**다음 작업에 전달할 것**:

- U-020에서 프론트 SceneCanvas가 이미지 URL을 받아 Lazy 렌더할 수 있는 백엔드 기능
- U-035에서 rembg 배경 제거 통합을 위한 이미지 생성 파이프라인 기반
- U-036에서 이미지 프롬프트 파일 로딩을 위한 연동 기반
- RU-006에서 정리할 media/artifacts 스토리지 기반

## 주의사항

**기술적 고려사항**:

- (RULE-008) 텍스트 우선: 이미지 생성은 턴 응답을 블로킹하지 않는 구조를 우선한다.
- (RULE-007) 비밀정보/프롬프트 원문 노출 금지: 로그에는 메타(라벨/버전)만.

**잠재적 리스크**:

- 이미지 저장/서빙이 MVP에서 복잡해질 수 있음 → 우선 로컬 단순 구현 후 RU-006/MMP에서 추상화/확장한다.

## 페어링 질문 (결정 필요)

- [ ] **Q1**: MVP 이미지 응답은 어떤 방식이 좋을까?
  - Option A: 로컬 파일로 저장 후 `image_url`로 서빙(권장: 브라우저 친화)
  - Option B: base64를 바로 반환(구현 단순하지만 페이로드/메모리 부담)

## 참고 자료

- `vibe/tech-stack.md` - 이미지 모델 ID 고정
- `.cursor/rules/00-core-critical.mdc` - RULE-004/008/010
</file>

<file path="vibe/unit-plans/U-023[Mvp].md">
# U-023[Mvp]: Autopilot 모드 토글 + Goal 입력 + Plan/Queue UI

## 메타데이터

| 항목      | 내용        |
| --------- | ----------- |
| Unit ID   | U-023[Mvp]  |
| Phase     | MVP         |
| 예상 소요 | 75분        |
| 의존성    | U-008,U-013 |
| 우선순위  | ⚡ Critical |

## 작업 목표

프론트에 Autopilot 모드(Manual/Assist/Autopilot) 토글과 Goal 입력을 제공하고, 에이전트가 수행하는 단계(Queue)/배지(Badges)를 “계획/작업 큐”로 시각화한다.

**배경**: PRD는 “Action Era”의 증거로 Goal→Plan→Subquests + Action Queue + Badges를 UI에서 상시 노출하라고 요구한다(단, 프롬프트/내부 추론은 비노출). (PRD 6.8, RULE-008)

**완료 기준**:

- UI에 Autopilot 토글(Manual/Assist/Autopilot)이 보이며 즉시 전환된다.
- Autopilot에서 Goal 입력 후, Plan/Queue UI가 업데이트되고 작업 단계가 진행 중임을 보여준다.
- 프롬프트 원문/내부 추론은 어디에도 노출되지 않고, 사용자 친화 라벨(단계/배지/모델 라벨)만 표시된다. (RULE-008)

## 영향받는 파일

**생성**:

- `frontend/src/components/AutopilotToggle.tsx` - 모드 토글 UI
- `frontend/src/components/GoalInput.tsx` - Goal 입력 UI
- `frontend/src/components/PlanPanel.tsx` - Goal/Plan/서브퀘스트 표시(최소)
- `frontend/src/stores/autopilotStore.ts` - autopilot 모드/goal/plan 상태(Zustand)

**수정**:

- `frontend/src/App.tsx` - 토글/Goal 입력/Plan 패널 배치 및 turn 실행 경로 연결
- `frontend/src/style.css` - 토글/플랜 카드 스타일
- `frontend/src/components/AgentConsole.tsx` - (필요 시) Plan/Queue 표시 확장

**참조**:

- `vibe/prd.md` 6.8 - Autopilot/Plan/Queue/Badges 요구
- `.cursor/rules/00-core-critical.mdc` - RULE-008(관측/프롬프트 비노출)
- `.cursor/rules/10-frontend-game-ui.mdc` - Agent Console 상시 노출

## 구현 흐름

### 1단계: Autopilot 모드 모델/상태 정의

- `mode`: `manual | assist | autopilot`
- `goal`: 사용자 목표 텍스트
- `plan`: 플랜 카드/서브퀘스트(초기엔 최소 구조)

### 2단계: UI 추가(고정 패널/헤더 영역)

- 토글은 항상 보이게 두고, 모드 변경 시 UI 라벨/설명이 즉시 바뀌게 한다.
- Goal 입력은 autopilot 모드에서 활성화(또는 모든 모드에서 입력 가능 + autopilot에서만 실행).

### 3단계: turn 실행/스트리밍과 연결

- Goal 제출은 `/api/turn`에 TurnInput으로 전달하거나(간단), 별도 엔드포인트를 두는 방식(U-024에서 확정) 중 하나로 연결한다.
- Agent Console의 Queue/Badges가 “Autopilot 실행 중”에도 동일 계약으로 업데이트되게 한다.

## 의존성 & 연결

**이전 작업에서 가져올 것**:

- **계획서**: [U-008[Mvp]](U-008[Mvp].md) - 스트림 소비/Agent Console/배지
- **계획서**: [U-013[Mvp]](U-013[Mvp].md) - Quest/Rule 데이터 모델(Plan/서브퀘스트 표시와 연결)

**다음 작업에 전달할 것**:

- U-024에서 백엔드 autopilot 실행/큐 스트리밍을 구현할 프론트 UI/상태 기반
- CP-MVP-03에서 “Autopilot 데모” 시나리오의 사용자 조작 표면

## 주의사항

**기술적 고려사항**:

- (RULE-008) Plan/Queue는 “과정”만 노출: 프롬프트 원문/내부 추론/툴 호출 상세를 UI에 그대로 내보내지 않는다.
- Autopilot은 MVP에서는 “제한된 스텝/안전한 종료”를 전제로 한다(무한 실행 금지).

**잠재적 리스크**:

- Autopilot이 복잡해지면 데모 안정성이 떨어짐 → MVP는 “제한된 스텝 + 언제든 중단 가능”을 기본으로 둔다.

## 페어링 질문 (결정 필요)

- [ ] **Q1**: Plan 표시의 최소 단위는?
  - Option A: Goal 1개 + 서브퀘스트 체크리스트(권장: 단순/명확)
  - Option B: 더 세분화된 단계 카드(정보량↑, UI 복잡↑)

## 참고 자료

- `vibe/prd.md` - Autopilot/Plan/Queue/Badges
- `.cursor/rules/00-core-critical.mdc` - RULE-008
</file>

<file path="vibe/unit-plans/U-024[Mvp].md">
# U-024[Mvp]: Backend Autopilot(제한 스텝) + Action Queue Streaming

## 메타데이터

| 항목      | 내용        |
| --------- | ----------- |
| Unit ID   | U-024[Mvp]  |
| Phase     | MVP         |
| 예상 소요 | 75분        |
| 의존성    | U-018,U-023 |
| 우선순위  | ⚡ Critical |

## 작업 목표

백엔드에서 Autopilot 실행을 “제한된 스텝”으로 지원하고, 각 스텝의 단계/배지/복구 트레이스를 **Action Queue Streaming(NDJSON)** 으로 스트리밍한다.

**배경**: PRD는 Autopilot에서 Goal 기반 다단계 실행과, 그 과정(Queue/Badges/Auto-repair)을 UI로 증명하라고 요구한다. (PRD 6.8, RULE-008)

**완료 기준**:

- Autopilot 모드에서 “Goal 입력 → 제한된 단계 실행”이 백엔드에서 동작한다.
- 실행 과정이 HTTP Streaming(POST 응답 스트림) + NDJSON 이벤트로 단계/메타가 스트리밍되며, 프론트 Agent Console에 그대로 반영된다.
- 무한 실행/무한 repair가 발생하지 않도록 스텝/복구 횟수 제한이 강제된다. (RULE-004)

## 영향받는 파일

**생성**:

- `backend/src/unknown_world/orchestrator/autopilot.py` - 제한 스텝 실행기(goal→step loop)
- `backend/src/unknown_world/api/autopilot.py` - (선택) autopilot 전용 HTTP Streaming 엔드포인트

**수정**:

- `backend/src/unknown_world/api/turn.py` - (대안) turn 엔드포인트에 autopilot 모드 분기 추가
- `backend/src/unknown_world/orchestrator/pipeline.py` - (RU-005 이후) 단계 실행 재사용(필요 시)

**참조**:

- `.cursor/rules/00-core-critical.mdc` - RULE-004/008
- `.cursor/rules/20-backend-orchestrator.mdc` - HTTP Streaming으로 단계 스트리밍
- `vibe/prd.md` 6.8 - Autopilot/Action Queue 요구

## 구현 흐름

### 1단계: Autopilot 실행 정책(제한) 확정

- `max_steps`(예: 3~5)로 제한하고, 각 스텝은 TurnInput/TurnOutput 계약을 재사용한다.
- 각 스텝마다 economy/안전/일관성 검증을 수행하고, 실패 시 즉시 복구/폴백으로 종료한다.

### 2단계: 스트림 이벤트 확장(스텝/단계 트레이스)

- 기존 stage 이벤트에 `step_index`(선택) 같은 메타를 추가해, UI에서 “몇 번째 자동 실행인지” 표시할 수 있게 한다.
- Auto-repair는 스텝 내 재시도이며, 횟수 제한을 반드시 둔다. (RULE-004)

### 3단계: 프론트(U-023)와 계약 정합

- 프론트가 기대하는 Plan/Queue 표시를 위해, 서버가 “현재 목표/현재 서브퀘스트” 같은 최소 메타를 TurnOutput 또는 이벤트로 제공하는 방식(Option)을 정한다.

## 의존성 & 연결

**이전 작업에서 가져올 것**:

- **계획서**: [U-018[Mvp]](U-018[Mvp].md) - 검증/복구/폴백(무한 루프 방지)
- **계획서**: [U-023[Mvp]](U-023[Mvp].md) - 프론트 Autopilot UI/상태

**다음 작업에 전달할 것**:

- U-026(리플레이)에서 “자동 실행 시나리오”를 재현할 수 있는 액션 시퀀스 기반
- CP-MVP-03에서 “Autopilot 데모”가 안정적으로 수행되는 기반

## 주의사항

**기술적 고려사항**:

- (RULE-008) 관측은 친화 라벨만: 프롬프트 원문/내부 추론/툴 호출 상세를 그대로 보내지 않는다.
- (RULE-004) 자동 실행은 반드시 “제한된 횟수”로 끝나야 한다(무한/장시간 실행 금지).

**잠재적 리스크**:

- autopilot이 잘못 설계되면 비용/지연이 폭증 → 경제 정책(예상 비용/대안)과 함께 단계별 제한을 둔다.

## 페어링 질문 (결정 필요)

- [ ] **Q1**: autopilot 엔드포인트를 분리할까, `/api/turn`에 통합할까?
  - Option A: `/api/autopilot` 분리(명확, 정책 분리 용이)
  - Option B: `/api/turn` 통합(권장: 계약 재사용/프론트 단순)

## 참고 자료

- `vibe/prd.md` - Autopilot/Action Queue/관측 요구
- `.cursor/rules/00-core-critical.mdc` - RULE-004/008
</file>

<file path="vibe/unit-plans/U-030[Mvp].md">
# U-030[Mvp]: nanobanana mcp 에셋 SSOT(폴더/네이밍/사이즈/폴백/라이선스)

## 메타데이터

| 항목      | 내용       |
| --------- | ---------- |
| Unit ID   | U-030[Mvp] |
| Phase     | MVP        |
| 예상 소요 | 45분       |
| 의존성    | U-004      |
| 우선순위  | High       |

## 작업 목표

`nanobanana mcp`로 생성되는 UI/문서용 이미지 에셋이 난립하지 않도록, **저장 위치/네이밍/사이즈/성능 예산/폴백/라이선스**를 프로젝트 SSOT로 정의한다.

**배경**: 에셋이 늘어날수록 “어디에 저장하는지/어떤 규칙으로 만드는지/성능에 어떤 영향을 주는지”가 흐려지면, UI 품질과 유지보수성이 급격히 떨어진다. 또한 `nanobanana mcp`는 개발 도구이므로, 런타임 의존/비밀정보 커밋 같은 리스크를 사전에 차단해야 한다.

**완료 기준**:

- `nanobanana mcp`로 제작한 정적 에셋의 **SSOT 경로**와 규칙이 문서화된다.
- 네이밍/사이즈/포맷/성능 예산(예: 총합/개별 파일 상한)과 **폴백 원칙(텍스트/이모지 유지)** 이 정의된다.
- 비밀정보(키/토큰) 커밋 금지, “dev-only 사용” 원칙이 명확히 적힌다. (red-line 연동)

## 영향받는 파일

**생성**:

- `frontend/public/ui/README.md` - UI 에셋 규칙(SSOT) 요약
- (선택) `frontend/public/ui/manifest.schema.json` - 에셋 매니페스트 규칙(키/파일명/사이즈)

**수정**:

- `vibe/prd.md` - “UI 이미지 에셋 파이프라인(nanobanana mcp)” 요구사항 명문화(요약)
- `vibe/roadmap.md` - nanobanana mcp 관련 유닛들의 의존성 기준(SSOT 선행) 반영

**참조**:

- `.gemini/rules/red-line.md` - RULE-006/007(용어/dev-only/보안)
- `vibe/ref/frontend-style-guide.md` - CRT 스타일 톤/변수 기반 원칙
- `frontend/src/style.css` - CSS 변수/아이콘 적용 방식(폴백 포함)

## 구현 흐름

### 1단계: SSOT 경로/포맷 규칙 확정

- SSOT 경로를 `frontend/public/ui/`로 고정한다(정적 서빙/캐싱 단순).
- 포맷은 기본 PNG(투명)로 하되, 필요 시 WebP는 선택(브라우저 호환/품질/크기 기준으로 결정).

### 2단계: 네이밍/사이즈/예산 규칙 정의

- 네이밍: `kebab-case` + 용도 + 크기(예: `signal-24.png`, `badge-ok-16.png`)
- 아이콘 사이즈: 16/24/32/64(최소 2종), 필요 시 `image-set()`로 1x/2x 제공
- 성능 예산(예시):
  - 아이콘 1개: 20KB 이하(권장)
  - placeholder 1개: 200KB 이하(권장)
  - `frontend/public/ui/` 총합: 1MB 이하(권장)

### 3단계: 폴백/접근성/라이선스 원칙 명문화

- 폴백: 로딩 실패/미지원 시에도 UI가 깨지지 않게 텍스트/이모지 라벨을 유지한다.
- 접근성: 의미 전달은 색상만으로 하지 않고(텍스트/라벨 병행), `aria-hidden`/`alt`를 의도에 맞게 적용한다.
- 라이선스/출처: 외부 로고/상표를 그대로 복제하지 않으며, 에셋은 “프로젝트 스타일”로 제작한다(브랜딩 혼동 방지).

### 4단계: 팀 사용 가이드(최소 런북) 작성

- “에셋 요청 → nanobanana mcp로 제작(**배경 제거가 필요하면 원본 배경은 순백(#FFFFFF) 단색으로 생성**) → (필요 시) `rembg`로 배경 제거 → 리사이즈/압축 → 폴더 반영 → UI 적용/폴백 확인”의 최소 절차를 `README.md`에 기록한다. (참조: `vibe/ref/rembg-guide.md`)

## 의존성 & 연결

**이전 작업에서 가져올 것**:

- **계획서**: [U-004[Mvp]](U-004[Mvp].md) - CRT 테마/고정 레이아웃(에셋이 들어갈 UI 골격)
- **결과물**: `frontend/src/style.css`의 CSS 변수/테마 토큰(색/톤 기준)

**다음 작업에 전달할 것**:

- U-029/U-031~U-034에서 사용될 **에셋 저장/규칙 SSOT**
- PRD/레드라인에 연결되는 “dev-only 에셋 파이프라인” 기준선

## 주의사항

**기술적 고려사항**:

- `nanobanana mcp`는 개발 도구이며, 런타임(프론트/백엔드) 의존 설계는 금지한다. (red-line RULE-007)
- 비밀정보(키/토큰)는 레포/문서/로그에 남기지 않는다. (red-line RULE-005)

**잠재적 리스크**:

- 에셋이 커지면 초기 로딩/캐시가 악화 → 예산 상한과 폴백(필요 지점만 적용) 원칙을 강제한다.

## 페어링 질문 (결정 필요)

- [ ] **Q1**: placeholder(상태 이미지)는 PNG로 고정할까, WebP를 허용할까?
  - Option A: PNG 고정(단순/예측 가능)
  - Option B: placeholder만 WebP 허용(용량 절감) — 단, 브라우저 호환/품질 기준 필요
  **A1**: Option B

## 참고 자료

- `.gemini/rules/red-line.md` - 용어/보안/dev-only 규칙
- `vibe/prd.md` - 데모 표면/접근성/CRT 효과 원칙
- `vibe/ref/frontend-style-guide.md` - CRT 스타일 가이드
- `vibe/ref/rembg-guide.md` - rembg 배경 제거(모델 선택/옵션/명령) 가이드
</file>

<file path="vibe/unit-plans/U-034[Mvp].md">
# U-034[Mvp]: nanobanana mcp 에셋 요청 스키마 + 프롬프트 템플릿(재현성)

## 메타데이터

| 항목      | 내용       |
| --------- | ---------- |
| Unit ID   | U-034[Mvp] |
| Phase     | MVP        |
| 예상 소요 | 45분       |
| 의존성    | U-030      |
| 우선순위  | Medium     |

## 작업 목표

`nanobanana mcp`로 에셋을 만들 때 “말로 요청해서 매번 다르게 나오는” 문제를 줄이기 위해, **에셋 요청 스키마(필드) + 재사용 가능한 프롬프트 템플릿**을 정의한다.

**배경**: 생성형 에셋은 일관성이 가장 어려운 부분이다. 요청 포맷이 표준화되면, (1) 스타일/팔레트/톤을 고정할 수 있고 (2) 어떤 에셋이 왜 필요한지 추적되며 (3) 수정/재생성이 쉬워진다. MVP에서는 런타임 프롬프트가 아니라 **개발용 에셋 제작 프롬프트**만 다룬다. (red-line: dev-only)

**완료 기준**:

- 에셋 요청 항목(예: category, size, palette, do/don’t, fallback_text)이 정의된다.
- 공통 스타일 문장(아트 디렉션)과, 카테고리별 템플릿(아이콘/placeholder/chrome)이 문서화된다.
- 템플릿 사용 규칙이 U-030(SSOT) 및 U-033(매니페스트)와 연결된다.
- (필수 조건부) **투명 배경이 필요한 에셋**(아이콘/크롬 등)은 생성 결과에 배경이 남으면 `rembg`로 배경 제거를 수행한다는 표준 절차가 템플릿/가이드에 포함된다. (참조: `vibe/ref/rembg-guide.md`)
- (필수 조건부) 배경 제거(rembg)를 전제하는 경우, 원본 생성 단계에서 배경을 **순백(#FFFFFF) 단색**으로 만들도록 템플릿에 강제 규칙이 포함된다(그라데이션/텍스처/그림자 금지).

## 영향받는 파일

**생성**:

- `vibe/ref/nanobanana-mcp.md` - nanobanana mcp 개발용 에셋 제작 가이드(SSOT)
- (권장) `vibe/ref/nanobanana-asset-request.schema.json` - 에셋 요청 JSON 스키마(개발용)

**수정**:

- `vibe/unit-plans/U-029[Mvp].md` - 템플릿/스키마 사용을 구현 흐름/완료 기준에 반영(필요 시)
- `vibe/unit-plans/U-031[Mvp].md` - placeholder 제작 시 템플릿 사용 명시(필요 시)
- `vibe/unit-plans/U-032[Mvp].md` - chrome 제작 시 템플릿 사용 명시(필요 시)

**참조**:

- `.gemini/rules/red-line.md` - RULE-006/007(용어/dev-only/프롬프트 노출 금지)
- `vibe/unit-plans/U-030[Mvp].md` - 에셋 SSOT(폴더/네이밍/예산)
- `vibe/ref/frontend-style-guide.md` - CRT 톤/팔레트 기준

## 구현 흐름

### 1단계: 에셋 요청 스키마(필드) 정의

- 최소 필드 예시:
  - `id`, `category(icon|placeholder|chrome)`, `purpose`, `size_px`, `palette`, `mood`
  - `must_have[]`, `must_not_have[]`, `fallback_text`
  - `output_path`(SSOT 경로), `notes`

### 2단계: 공통 아트 디렉션 문장(템플릿 헤더) 작성

- CRT 레트로/인광 그린 기반
- 제한 팔레트(그린/마젠타/오렌지/레드)
  - 최종 산출물(아이콘/크롬): 투명 PNG(알파)
  - (필수 조건부) 배경 제거(rembg) 예정: **원본 생성 시 배경은 순백(#FFFFFF) 단색**으로 강제(그라데이션/텍스처/그림자 금지)
- 작은 크기에서도 읽히는 단순 형태 우선
- 텍스트 렌더링은 최소화(언어/i18n/해상도 문제)
- (필수 조건부) 투명 배경이 필요한데 결과에 배경이 섞이면, 프롬프트로만 해결하려고 버티기보다 `rembg`로 배경 제거 후처리를 수행한다(재현성/속도 우선). (참조: `vibe/ref/rembg-guide.md`)

### 3단계: 카테고리별 템플릿 작성(아이콘/placeholder/chrome)

- 아이콘: 단일 실루엣 + 높은 대비 + 투명 배경
- placeholder: “장면 느낌” + 과도한 정보/텍스트 금지
- chrome: 얇은 라인/코너/프레임(장식 과잉 금지)

### 4단계: 사용 절차(매니페스트/QA 연결) 정의

- 요청 스키마로 에셋 요구를 기록 → nanobanana mcp로 생성 → (필요 시) `rembg`로 배경 제거 → 결과를 `frontend/public/ui/`에 저장 → `manifest.json` 업데이트 → QA 체크

## 의존성 & 연결

**이전 작업에서 가져올 것**:

- **계획서**: [U-030[Mvp]](U-030[Mvp].md) - 에셋 SSOT/예산/규칙

**다음 작업에 전달할 것**:

- U-029/U-031/U-032에서 재사용할 “요청 포맷 + 템플릿”(일관성/재현성)
- 이후 자동화(스크립트 기반 생성/검증)로 확장 가능한 기반

## 주의사항

**기술적 고려사항**:

- 템플릿/스키마는 “런타임 프롬프트”가 아니라 “개발용 에셋 제작”에만 사용한다.
- 프롬프트 원문을 사용자 UI/로그에 노출하지 않는다(관측은 라벨/배지로).
- (필수 조건부) 배경 제거가 필요하면 `rembg`로 재현 가능하게 처리한다(수작업 컷아웃 금지). (참조: `vibe/ref/rembg-guide.md`)

**잠재적 리스크**:

- 템플릿이 과도하게 길면 사용성이 떨어짐 → 공통 헤더 + 카테고리별 추가 문장으로 최소화한다.

## 페어링 질문 (결정 필요)

- [x] **Q1**: 에셋 요청 스키마 파일을 어디에 둘까?
  - Option A: `vibe/ref/` (문서/가이드 중심, dev-only) ✅
  - Option B: `frontend/public/ui/` (에셋 옆에 두기 쉬움, 하지만 제품 산출물과 혼합됨)
  **A1**: Option A

## 참고 자료

- `.gemini/rules/red-line.md` - nanobanana mcp 용어/사용 범위/보안 규칙
- `vibe/unit-plans/U-030[Mvp].md` - 에셋 SSOT
- `vibe/ref/frontend-style-guide.md` - CRT 스타일 기준
- `vibe/ref/rembg-guide.md` - rembg 배경 제거(모델 선택/옵션/명령) 가이드
</file>

<file path="vibe/unit-plans/U-106[Mmp].md">
# U-106[Mmp]: 관측 지표/대시보드(Agent Console 메트릭) 고도화

## 메타데이터

| 항목      | 내용       |
| --------- | ---------- |
| Unit ID   | U-106[Mmp] |
| Phase     | MMP        |
| 예상 소요 | 75분       |
| 의존성    | CP-MMP-01  |
| 우선순위  | High       |

## 작업 목표

Agent Console을 “과정 가시화”를 넘어, TTFB/단계 소요시간/재시도 횟수/이미지 시간/비용 라벨 등을 포함한 **관측 대시보드**로 고도화한다(프롬프트 원문/CoT 비노출).

**배경**: PRD는 관측 가능성(Observability)을 UX의 일부로 요구하며, Demo Mode에서 실시간 지표를 보여야 한다. (PRD 10.2, RULE-008)

**완료 기준**:

- 최소 지표가 UI에 표시된다: TTFB, 총 응답 시간, 단계별 소요, Auto-repair 횟수, 모델 라벨(FAST/QUALITY/REF).
- 지표는 “사용자 친화 라벨”로만 표시되고, 프롬프트/내부 추론은 노출되지 않는다. (RULE-008)
- 지표 수집/표시가 게임 진행을 방해하지 않는다(성능/가독성).

## 영향받는 파일

**생성**:

- `frontend/src/components/ObservabilityPanel.tsx` - 지표 카드/그래프(간단)
- `frontend/src/stores/metricsStore.ts` - 지표 수집 상태(Zustand)

**수정**:

- `frontend/src/components/AgentConsole.tsx` - 지표 표시 통합/정리
- `backend/src/unknown_world/api/turn.py` - (선택) 스트림 이벤트에 timing 메타 추가
- `frontend/src/api/turnStream.ts` - timing/메타 파싱(필요 시)

**참조**:

- `vibe/prd.md` 10.2 - Demo Mode 지표
- `.cursor/rules/00-core-critical.mdc` - RULE-008

## 구현 흐름

### 1단계: 지표 목록/수집 지점 정의

- 클라 측정: 요청 시작~첫 이벤트(TTFB), 종료까지 총 시간
- 서버 제공(선택): stage별 시간/모델 라벨/재시도 횟수

### 2단계: UI 표시(가독성 우선)

- 숫자/라벨 중심으로 간단히 표시하고, 과도한 그래프/로그 노출은 피한다.
- 실패/복구 케이스에서 지표가 어떻게 보이는지(재시도 횟수 등) 포함한다.

### 3단계: 개인정보/보안/프롬프트 비노출 확인

- 이벤트/로그에 프롬프트 원문/내부 추론/민감값이 포함되지 않는지 점검한다.

## 의존성 & 연결

**이전 작업에서 가져올 것**:

- **체크포인트**: [CP-MMP-01](CP-MMP-01.md) - 배포/관측 게이트 기준선

**다음 작업에 전달할 것**:

- U-107(접근성/모바일)에서 지표 UI를 가독성 있게 다듬을 기반
- 운영/데모에서 튜닝 루프(리플레이→개선) 지표 근거

## 주의사항

**기술적 고려사항**:

- (RULE-008) 관측은 메타만: 프롬프트/CoT 비노출.
- 지표는 UX를 해치지 않아야 하며, 기본 UI는 게임 HUD를 유지한다.

**잠재적 리스크**:

- 지표 표시가 과도하면 “개발자 도구”처럼 보일 수 있음 → Demo Overlay 토글로 제어하고, 기본은 간결하게 유지한다.

## 페어링 질문 (결정 필요)

- [ ] **Q1**: Demo Overlay는 기본 ON일까?
  - Option A: 기본 ON(심사자 설득력↑)
  - Option B: 기본 OFF + 토글(권장: UX 깔끔, 필요 시 노출)

## 참고 자료

- `vibe/prd.md` - Demo Mode/관측 지표
- `.cursor/rules/00-core-critical.mdc` - RULE-008
</file>

<file path="vibe/unit-runbooks/U-005-pydantic-schemas-runbook.md">
# U-005[Mvp] TurnInput/TurnOutput 스키마(Pydantic) 실행 가이드

## 1. 개요

백엔드에서 TurnInput/TurnOutput을 **Pydantic 모델로 정의**하고, Gemini Structured Outputs에 투입 가능한 **JSON Schema(부분집합)** 를 생성할 수 있게 만들었습니다.

**핵심 기능**:

- TurnInput/TurnOutput Pydantic 모델 정의
- 최소 요구 필드(언어/내러티브/UI/경제/안전/좌표/배지) 포함
- `model_json_schema()` 메서드로 Gemini용 JSON Schema 생성
- `model_validate_json()` 메서드로 응답 검증

**예상 소요 시간**: 10분

**의존성**:

- 의존 유닛: U-003[Mvp] (FastAPI 프로젝트 골격)
- 선행 완료 필요: 백엔드 환경 설정 (`uv sync`)

---

## 2. 빠른 시작 (Quick Start)

### 2.1 환경 준비

```bash
cd backend
uv sync
```

### 2.2 의존 유닛 확인

```bash
# 백엔드 패키지 import 테스트
uv run python -c "from unknown_world.models import TurnInput, TurnOutput; print('OK')"
```

### 2.3 즉시 실행 - JSON Schema 생성 테스트

```bash
uv run python -c "
from unknown_world.models import TurnOutput
import json
schema = TurnOutput.model_json_schema()
print(json.dumps(schema, indent=2, ensure_ascii=False)[:2000])
print('... (truncated)')
"
```

### 2.4 첫 화면/결과 확인

- 성공 지표: JSON Schema가 콘솔에 출력됨
- `$defs`에 하위 타입들이 정의됨
- `properties`에 `language`, `narrative`, `economy`, `safety` 등 필수 필드 포함

---

## 3. 핵심 기능 시나리오

### 시나리오 A: TurnInput 생성 및 직렬화

**목적**: 클라이언트에서 서버로 전송할 TurnInput 생성 검증

**실행**:

```bash
uv run python -c "
from unknown_world.models import (
    TurnInput, Language, ClientInfo, EconomySnapshot
)

# TurnInput 생성
turn_input = TurnInput(
    language=Language.KO,
    text='문을 열어본다',
    client=ClientInfo(viewport_w=1920, viewport_h=1080),
    economy_snapshot=EconomySnapshot(signal=100, memory_shard=5),
)

# JSON 직렬화
print(turn_input.model_dump_json(indent=2))
"
```

**기대 결과**:

```json
{
  "language": "ko-KR",
  "text": "문을 열어본다",
  "click": null,
  "client": {
    "viewport_w": 1920,
    "viewport_h": 1080,
    "theme": "dark"
  },
  "economy_snapshot": {
    "signal": 100,
    "memory_shard": 5
  }
}
```

**확인 포인트**:

- ✅ `language`가 `"ko-KR"` enum 값으로 직렬화됨
- ✅ `theme`가 기본값 `"dark"`로 설정됨
- ✅ `click`이 `null`로 직렬화됨 (선택 필드)

---

### 시나리오 B: TurnOutput 생성 및 검증

**목적**: 서버에서 클라이언트로 반환할 TurnOutput 생성 검증

**실행**:

```bash
uv run python -c "
from unknown_world.models import (
    TurnOutput, Language, EconomyOutput, SafetyOutput, CurrencyAmount
)

# TurnOutput 생성
turn_output = TurnOutput(
    language=Language.KO,
    narrative='문이 삐걱거리며 열립니다. 어둠 속에서 희미한 빛이 새어나옵니다.',
    economy=EconomyOutput(
        cost=CurrencyAmount(signal=5, memory_shard=0),
        balance_after=CurrencyAmount(signal=95, memory_shard=5),
    ),
    safety=SafetyOutput(blocked=False),
)

# JSON 직렬화
print(turn_output.model_dump_json(indent=2))
"
```

**기대 결과**:

```json
{
  "language": "ko-KR",
  "narrative": "문이 삐걱거리며 열립니다...",
  "economy": {
    "cost": { "signal": 5, "memory_shard": 0 },
    "balance_after": { "signal": 95, "memory_shard": 5 }
  },
  "safety": { "blocked": false, "message": null },
  "ui": { "action_deck": { "cards": [] }, "objects": [] },
  "world": { ... },
  "render": { "image_job": null },
  "agent_console": { ... }
}
```

**확인 포인트**:

- ✅ `economy.cost`와 `economy.balance_after` 필수 포함
- ✅ `safety.blocked`가 `false`로 설정됨
- ✅ 선택 필드들이 기본값으로 채워짐

---

### 시나리오 C: JSON Schema 생성 (Gemini Structured Outputs용)

**목적**: Gemini API의 `response_json_schema`에 전달할 스키마 생성

**실행**:

```bash
uv run python -c "
from unknown_world.models import TurnOutput
import json

# JSON Schema 생성
schema = TurnOutput.model_json_schema()

# 스키마 구조 확인
print('=== Top-level keys ===')
print(list(schema.keys()))

print('\n=== Required fields ===')
print(schema.get('required', []))

print('\n=== Properties ===')
for prop, details in schema.get('properties', {}).items():
    print(f'  {prop}: {details.get(\"type\", details.get(\"\$ref\", \"unknown\"))}')
"
```

**기대 결과**:

```
=== Top-level keys ===
['$defs', 'properties', 'required', 'title', 'type']

=== Required fields ===
['language', 'narrative', 'economy', 'safety']

=== Properties ===
  language: ...
  narrative: string
  economy: ...
  safety: ...
  ui: ...
  world: ...
  render: ...
  agent_console: ...
```

**확인 포인트**:

- ✅ `$defs`에 하위 타입 정의 포함
- ✅ `required`에 Hard Gate 필드(language, narrative, economy, safety) 포함
- ✅ 스키마가 Gemini Structured Outputs 부분집합 제약 준수

---

### 시나리오 D: 좌표 규약 검증 (RULE-009)

**목적**: 0~1000 정규화 좌표계 및 bbox 순서 [ymin, xmin, ymax, xmax] 검증

**실행**:

```bash
uv run python -c "
from unknown_world.models import SceneObject, Box2D
from pydantic import ValidationError

# 정상 케이스
obj = SceneObject(
    id='door_001',
    label='문',
    box_2d=Box2D(ymin=100, xmin=200, ymax=400, xmax=500),
)
print('정상 케이스:', obj.model_dump())

# 범위 초과 케이스 (1001 > 1000)
try:
    invalid = Box2D(ymin=0, xmin=0, ymax=1001, xmax=500)
except ValidationError as e:
    print('범위 초과 오류:', e.errors()[0]['msg'])

# 음수 케이스
try:
    invalid = Box2D(ymin=-1, xmin=0, ymax=500, xmax=500)
except ValidationError as e:
    print('음수 오류:', e.errors()[0]['msg'])
"
```

**기대 결과**:

```
정상 케이스: {'id': 'door_001', 'label': '문', 'box_2d': {'ymin': 100, 'xmin': 200, 'ymax': 400, 'xmax': 500}, 'interaction_hint': None}
범위 초과 오류: Input should be less than or equal to 1000
음수 오류: Input should be greater than or equal to 0
```

**확인 포인트**:

- ✅ 정상 좌표(0~1000)가 허용됨
- ✅ 1000 초과 좌표가 거부됨
- ✅ 음수 좌표가 거부됨
- ✅ bbox 순서가 [ymin, xmin, ymax, xmax]로 명확함

---

### 시나리오 E: 언어 정책 검증 (RULE-006)

**목적**: ko/en 언어 enum 강제 및 혼합 출력 방지 검증

**실행**:

```bash
uv run python -c "
from unknown_world.models import Language, TurnInput, ClientInfo, EconomySnapshot
from pydantic import ValidationError

# 정상 케이스 (ko-KR)
input_ko = TurnInput(
    language=Language.KO,
    client=ClientInfo(viewport_w=1920, viewport_h=1080),
    economy_snapshot=EconomySnapshot(signal=100, memory_shard=5),
)
print('KO 언어:', input_ko.language.value)

# 정상 케이스 (en-US)
input_en = TurnInput(
    language=Language.EN,
    client=ClientInfo(viewport_w=1920, viewport_h=1080),
    economy_snapshot=EconomySnapshot(signal=100, memory_shard=5),
)
print('EN 언어:', input_en.language.value)

# 잘못된 언어 케이스
try:
    invalid = TurnInput(
        language='ja-JP',  # 지원하지 않는 언어
        client=ClientInfo(viewport_w=1920, viewport_h=1080),
        economy_snapshot=EconomySnapshot(signal=100, memory_shard=5),
    )
except ValidationError as e:
    print('지원하지 않는 언어 오류:', e.errors()[0]['msg'][:50])
"
```

**기대 결과**:

```
KO 언어: ko-KR
EN 언어: en-US
지원하지 않는 언어 오류: Input should be 'ko-KR' or 'en-US'
```

**확인 포인트**:

- ✅ `ko-KR` 언어가 허용됨
- ✅ `en-US` 언어가 허용됨
- ✅ 지원하지 않는 언어가 거부됨 (enum 강제)

---

### 시나리오 F: 재화 인바리언트 검증 (RULE-005)

**목적**: 잔액 음수 금지 및 비용/잔액 필수 검증

**실행**:

```bash
uv run python -c "
from unknown_world.models import CurrencyAmount, EconomyOutput
from pydantic import ValidationError

# 정상 케이스
economy = EconomyOutput(
    cost=CurrencyAmount(signal=5, memory_shard=0),
    balance_after=CurrencyAmount(signal=95, memory_shard=5),
)
print('정상 케이스:', economy.model_dump())

# 음수 signal 케이스
try:
    invalid = CurrencyAmount(signal=-1, memory_shard=0)
except ValidationError as e:
    print('음수 signal 오류:', e.errors()[0]['msg'])

# 음수 memory_shard 케이스
try:
    invalid = CurrencyAmount(signal=0, memory_shard=-5)
except ValidationError as e:
    print('음수 memory_shard 오류:', e.errors()[0]['msg'])
"
```

**기대 결과**:

```
정상 케이스: {'cost': {'signal': 5, 'memory_shard': 0}, 'balance_after': {'signal': 95, 'memory_shard': 5}}
음수 signal 오류: Input should be greater than or equal to 0
음수 memory_shard 오류: Input should be greater than or equal to 0
```

**확인 포인트**:

- ✅ 정상 재화 값(0 이상)이 허용됨
- ✅ 음수 signal이 거부됨
- ✅ 음수 memory_shard가 거부됨

---

### 시나리오 G: JSON 응답 검증 (model_validate_json)

**목적**: Gemini 응답을 TurnOutput으로 검증하는 시나리오

**실행**:

```bash
uv run python -c "
from unknown_world.models import TurnOutput
from pydantic import ValidationError
import json

# 정상 JSON 응답 (Gemini에서 반환된 것처럼)
valid_json = '''
{
    \"language\": \"ko-KR\",
    \"narrative\": \"문이 열립니다.\",
    \"economy\": {
        \"cost\": {\"signal\": 5, \"memory_shard\": 0},
        \"balance_after\": {\"signal\": 95, \"memory_shard\": 5}
    },
    \"safety\": {\"blocked\": false}
}
'''

output = TurnOutput.model_validate_json(valid_json)
print('검증 성공:', output.narrative)

# 필수 필드 누락 케이스
invalid_json = '''
{
    \"language\": \"ko-KR\",
    \"narrative\": \"문이 열립니다.\"
}
'''

try:
    TurnOutput.model_validate_json(invalid_json)
except ValidationError as e:
    print('필수 필드 누락 오류 개수:', len(e.errors()))
    print('누락된 필드:', [err['loc'][0] for err in e.errors()])
"
```

**기대 결과**:

```
검증 성공: 문이 열립니다.
필수 필드 누락 오류 개수: 2
누락된 필드: ['economy', 'safety']
```

**확인 포인트**:

- ✅ 정상 JSON이 TurnOutput으로 파싱됨
- ✅ 필수 필드(economy, safety) 누락 시 ValidationError 발생
- ✅ 오류 메시지에 누락된 필드 정보 포함

---

## 4. 실행 결과 확인

### 4.1 로그 확인

- 위치: 콘솔 출력
- 주요 로그 메시지:
  - `OK`: import 성공
  - JSON Schema 출력: 스키마 생성 성공
  - `ValidationError`: 검증 실패 (예상된 동작)

### 4.2 생성 파일

| 파일 경로 | 목적 |
|-----------|------|
| `backend/src/unknown_world/models/__init__.py` | 모델 패키지 노출 |
| `backend/src/unknown_world/models/turn.py` | TurnInput/TurnOutput 모델 정의 |

### 4.3 성공/실패 판단 기준

**성공**:

- ✅ 모든 시나리오(A~G)가 예상대로 동작
- ✅ `ruff check` 통과
- ✅ `pyright` 타입 체크 통과
- ✅ JSON Schema 생성 가능
- ✅ 좌표 규약(0~1000, bbox 순서) 검증 동작
- ✅ 언어 정책(ko/en enum) 강제 동작
- ✅ 재화 음수 거부 동작

**실패 시 확인**:

- ❌ `ModuleNotFoundError` → `uv sync` 실행
- ❌ `ValidationError` 예상과 다름 → 스키마 정의 확인
- ❌ 타입 체크 실패 → `uv run pyright src/unknown_world/models/` 실행

---

## 5. 문제 해결 (Troubleshooting)

### 5.1 일반적인 오류

**오류**: `ModuleNotFoundError: No module named 'unknown_world'`

- **원인**: 패키지가 설치되지 않음
- **해결**: `cd backend && uv sync`

**오류**: `ValidationError: extra fields not permitted`

- **원인**: 스키마에 정의되지 않은 필드 전달
- **해결**: `extra="forbid"` 설정으로 인해 추가 필드가 거부됨 (의도된 동작)

### 5.2 환경별 주의사항

- **Windows**: 경로 구분자가 `\`일 수 있음. Python에서는 문제없음.
- **macOS/Linux**: 특이사항 없음

---

## 6. 다음 단계

이 유닛의 스키마는 다음 유닛에서 사용됩니다:

- **U-007**: 모의 Orchestrator가 TurnOutput을 생성할 때 이 스키마를 계약으로 사용
- **U-017**: 실제 Gemini Structured Outputs 호출 시 `TurnOutput.model_json_schema()`를 `response_json_schema`에 전달
</file>

<file path="backend/src/unknown_world/api/turn.py">
"""Unknown World - /api/turn HTTP Streaming 엔드포인트.

POST 요청을 받아 NDJSON(라인 단위 JSON) 스트리밍으로 턴 결과를 반환합니다.

설계 원칙:
    - RULE-003: 구조화 출력(JSON Schema) 우선 + Pydantic 검증
    - RULE-004: 검증 실패 시 Repair loop + 안전한 폴백
    - RULE-005: 재화 인바리언트 (잔액 음수 금지)
    - RULE-007: 프롬프트/내부 추론 노출 금지
    - RULE-008: 단계/배지 가시화, TTFB 2초 목표

스트림 이벤트 타입:
    - stage: 단계 진행 상태 (Parse→Validate→Plan→Resolve→Render→Verify→Commit)
    - badges: 검증 배지 목록
    - narrative_delta: 내러티브 텍스트 조각 (타자 효과용)
    - final: 최종 TurnOutput
    - error: 에러 발생 시

참조:
    - vibe/unit-plans/U-007[Mvp].md
    - .cursor/rules/20-backend-orchestrator.mdc
"""

import asyncio
import time
from collections.abc import AsyncGenerator
from typing import Any, cast

from fastapi import APIRouter, Request
from fastapi.responses import StreamingResponse
from pydantic import ValidationError

from unknown_world.api.turn_stream_events import (
    BadgesEvent,
    ErrorEvent,
    FinalEvent,
    NarrativeDeltaEvent,
    RepairEvent,
    StageEvent,
    StageStatus,
    StreamEventType,
    serialize_event,
)
from unknown_world.models.turn import (
    AgentPhase,
    CurrencyAmount,
    Language,
    TurnInput,
    ValidationBadge,
)
from unknown_world.orchestrator.mock import MockOrchestrator

# =============================================================================
# 라우터 정의
# =============================================================================

router = APIRouter(prefix="/api", tags=["Turn"])

# 단계 목록 (PRD 예시)
ORCHESTRATOR_PHASES = [
    AgentPhase.PARSE,
    AgentPhase.VALIDATE,
    AgentPhase.PLAN,
    AgentPhase.RESOLVE,
    AgentPhase.RENDER,
    AgentPhase.VERIFY,
    AgentPhase.COMMIT,
]

# 모의 단계 지연 시간 (ms) - 실제 처리 시뮬레이션
PHASE_DELAYS_MS = {
    AgentPhase.PARSE: 50,
    AgentPhase.VALIDATE: 30,
    AgentPhase.PLAN: 100,
    AgentPhase.RESOLVE: 150,
    AgentPhase.RENDER: 80,
    AgentPhase.VERIFY: 40,
    AgentPhase.COMMIT: 20,
}


async def _stream_turn_events(
    turn_input: TurnInput, seed: int | None = None
) -> AsyncGenerator[str]:
    """턴 처리 이벤트를 NDJSON 스트림으로 생성합니다.

    Args:
        turn_input: 사용자 턴 입력
        seed: 모의 Orchestrator 시드 (재현성 보장)

    Yields:
        str: NDJSON 라인
    """
    orchestrator = MockOrchestrator(seed=seed)
    collected_badges: list[str] = []

    # Phase 1: Parse (TTFB를 위해 즉시 시작 이벤트 전송)
    yield serialize_event(
        StageEvent(
            type=StreamEventType.STAGE, name=AgentPhase.PARSE.value, status=StageStatus.START
        ).model_dump()
    )

    # 각 단계별 처리 시뮬레이션
    for phase in ORCHESTRATOR_PHASES:
        # 단계 시작
        if phase != AgentPhase.PARSE:  # Parse는 이미 전송함
            yield serialize_event(
                StageEvent(
                    type=StreamEventType.STAGE, name=phase.value, status=StageStatus.START
                ).model_dump()
            )

        # 모의 처리 지연
        delay_ms = PHASE_DELAYS_MS.get(phase, 50)
        await asyncio.sleep(delay_ms / 1000.0)

        # 단계 완료
        yield serialize_event(
            StageEvent(
                type=StreamEventType.STAGE, name=phase.value, status=StageStatus.COMPLETE
            ).model_dump()
        )

        # 배지 추가 (Validate, Verify 단계에서)
        if phase == AgentPhase.VALIDATE:
            collected_badges.append(ValidationBadge.SCHEMA_OK.value)
            collected_badges.append(ValidationBadge.ECONOMY_OK.value)
            yield serialize_event(
                BadgesEvent(
                    type=StreamEventType.BADGES, badges=collected_badges.copy()
                ).model_dump()
            )
        elif phase == AgentPhase.VERIFY:
            collected_badges.append(ValidationBadge.SAFETY_OK.value)
            collected_badges.append(ValidationBadge.CONSISTENCY_OK.value)
            yield serialize_event(
                BadgesEvent(
                    type=StreamEventType.BADGES, badges=collected_badges.copy()
                ).model_dump()
            )

    # TurnOutput 생성 (Repair 루프 포함 - RULE-004)
    max_repair_attempts = 3
    repair_attempt = 0
    turn_output = None

    try:
        while repair_attempt <= max_repair_attempts:
            try:
                # 0회차는 정상 시도, 1회차부터는 repair
                if repair_attempt > 0:
                    yield serialize_event(
                        RepairEvent(
                            type=StreamEventType.REPAIR,
                            attempt=repair_attempt,
                            message="검증 실패로 인해 다시 시도 중입니다..."
                            if turn_input.language == Language.KO
                            else "Retrying due to validation failure",
                        ).model_dump()
                    )

                turn_output = orchestrator.generate_turn_output(turn_input)
                break  # 성공 시 루프 탈출

            except ValidationError as e:
                repair_attempt += 1
                if repair_attempt > max_repair_attempts:
                    # 최종 실패 시 폴백 (RULE-004)
                    turn_output = orchestrator.create_safe_fallback(
                        language=turn_input.language,
                        error_message=str(e),
                        economy_snapshot=CurrencyAmount(
                            signal=turn_input.economy_snapshot.signal,
                            memory_shard=turn_input.economy_snapshot.memory_shard,
                        ),
                    )
                    break
                # 루프 계속 진행 (재시도)
                continue

        if turn_output:
            # 내러티브 델타 스트리밍 (타자 효과)
            narrative = turn_output.narrative
            chunk_size = 20  # 한 번에 전송할 글자 수
            for i in range(0, len(narrative), chunk_size):
                chunk = narrative[i : i + chunk_size]
                yield serialize_event(
                    NarrativeDeltaEvent(
                        type=StreamEventType.NARRATIVE_DELTA, text=chunk
                    ).model_dump()
                )
                await asyncio.sleep(0.02)  # 타자 효과 딜레이

            # 최종 TurnOutput 전송
            yield serialize_event(
                FinalEvent(type=StreamEventType.FINAL, data=turn_output).model_dump(mode="json")
            )

    except Exception:
        # RU-002-S1: 예외 발생 시 error + final(폴백) 순서로 송출
        # (프롬프트/내부 추론 노출 금지 - RULE-007)
        yield serialize_event(
            ErrorEvent(
                type=StreamEventType.ERROR,
                message="처리 중 오류가 발생했습니다"
                if turn_input.language == Language.KO
                else "An error occurred during processing",
                code="INTERNAL_ERROR",
            ).model_dump()
        )
        # 항상 final(폴백)로 종료 - 스트림 종료 인바리언트 (RULE-004)
        fallback = orchestrator.create_safe_fallback(
            language=turn_input.language,
            error_message="Internal error",
            economy_snapshot=CurrencyAmount(
                signal=turn_input.economy_snapshot.signal,
                memory_shard=turn_input.economy_snapshot.memory_shard,
            ),
        )
        yield serialize_event(
            FinalEvent(type=StreamEventType.FINAL, data=fallback).model_dump(mode="json")
        )


async def _validate_and_parse_input(request: Request) -> TurnInput | dict[str, Any]:
    """요청 본문을 TurnInput으로 검증 및 파싱합니다.

    Returns:
        TurnInput 또는 에러 정보 dict (language, economy_snapshot 포함)
    """
    body: dict[str, Any] | None = None
    try:
        body = await request.json()
        return TurnInput.model_validate(body)
    except ValidationError as e:
        # RU-002-S1: 입력 검증 실패 시에도 language/economy 추출 시도
        raw_language = body.get("language") if isinstance(body, dict) else None
        raw_economy = body.get("economy_snapshot") if isinstance(body, dict) else None
        return {
            "error": True,
            "message": "Invalid input",
            "details": e.errors(),
            "language": raw_language if raw_language in ("ko-KR", "en-US") else "ko-KR",
            "economy_snapshot": raw_economy,
        }
    except Exception:
        return {
            "error": True,
            "message": "Failed to parse request body",
            "details": None,
            "language": "ko-KR",
            "economy_snapshot": None,
        }


@router.post(
    "/turn",
    response_class=StreamingResponse,
    summary="턴 처리 (HTTP Streaming)",
    description="""
턴 입력을 받아 NDJSON 스트리밍으로 결과를 반환합니다.

**스트림 이벤트 타입**:
- `stage`: 처리 단계 진행 상태
- `badges`: 검증 배지 목록
- `narrative_delta`: 내러티브 텍스트 조각 (타자 효과)
- `final`: 최종 TurnOutput
- `error`: 에러 발생 시

**예시 요청**:
```json
{
    "language": "ko-KR",
    "text": "문을 열어본다",
    "client": {"viewport_w": 1920, "viewport_h": 1080, "theme": "dark"},
    "economy_snapshot": {"signal": 100, "memory_shard": 5}
}
```
""",
    responses={
        200: {
            "description": "NDJSON 스트림",
            "content": {
                "application/x-ndjson": {
                    "example": '{"type":"stage","name":"parse","status":"start"}\n'
                }
            },
        },
        400: {"description": "잘못된 요청"},
    },
)
async def turn_stream(request: Request) -> StreamingResponse:
    """턴 처리 HTTP Streaming 엔드포인트.

    POST 요청으로 TurnInput을 받아 NDJSON 스트리밍으로 결과를 반환합니다.
    TTFB를 줄이기 위해 첫 stage 이벤트를 즉시 전송합니다.

    Args:
        request: FastAPI Request 객체

    Returns:
        StreamingResponse: NDJSON 스트림
    """
    # 입력 검증
    parse_result = await _validate_and_parse_input(request)

    if isinstance(parse_result, dict) and parse_result.get("error"):
        # RU-002-S1: 입력 검증 실패 시에도 error + final(폴백) 순서로 송출
        error_language = parse_result.get("language", "ko-KR")
        error_economy = parse_result.get("economy_snapshot")

        # economy_snapshot이 유효한지 확인
        economy_snapshot: CurrencyAmount | None = None
        if isinstance(error_economy, dict):
            try:
                # 명시적 타입 캐스팅으로 Pyright 경고 해소
                eco_dict = cast(dict[str, Any], error_economy)
                economy_snapshot = CurrencyAmount(
                    signal=int(eco_dict.get("signal", 100)),
                    memory_shard=int(eco_dict.get("memory_shard", 5)),
                )
            except (ValueError, TypeError):
                economy_snapshot = None

        async def error_stream() -> AsyncGenerator[str]:
            # 에러 이벤트 송출
            yield serialize_event(
                ErrorEvent(
                    type=StreamEventType.ERROR,
                    message=parse_result.get("message", "Invalid input"),
                    code="VALIDATION_ERROR",
                ).model_dump()
            )
            # 항상 final(폴백)로 종료 - 스트림 종료 인바리언트 (RULE-004)
            fallback_orchestrator = MockOrchestrator()
            fallback = fallback_orchestrator.create_safe_fallback(
                language=Language.KO if error_language == "ko-KR" else Language.EN,
                error_message="Validation error",
                economy_snapshot=economy_snapshot,
            )
            yield serialize_event(
                FinalEvent(type=StreamEventType.FINAL, data=fallback).model_dump(mode="json")
            )

        return StreamingResponse(
            error_stream(),
            media_type="application/x-ndjson",
            headers={
                "Cache-Control": "no-cache",
                "X-Accel-Buffering": "no",  # nginx 버퍼링 비활성화
            },
        )

    turn_input: TurnInput = parse_result  # type: ignore[assignment]

    # 시드 추출 (쿼리 파라미터에서, 테스트/재현용)
    seed_param = request.query_params.get("seed")
    seed = int(seed_param) if seed_param else None

    # NDJSON 스트리밍 응답
    return StreamingResponse(
        _stream_turn_events(turn_input, seed=seed),
        media_type="application/x-ndjson",
        headers={
            "Cache-Control": "no-cache",
            "X-Accel-Buffering": "no",  # nginx 버퍼링 비활성화
            "X-Request-Time": str(int(time.time() * 1000)),
        },
    )
</file>

<file path="frontend/public/ui/README.md">
# UI 에셋 가이드 (nanobanana mcp SSOT)

> **SSOT 경로**: `frontend/public/ui/`  
> **도구**: `nanobanana mcp` (개발 전용, 런타임 의존 금지)  
> **참조**: `.gemini/rules/red-line.md` RULE-006/007, `vibe/prd.md` 9.7, `vibe/ref/rembg-guide.md`

---

## 1. 핵심 원칙

### 1.1 Dev-only 원칙 (RULE-007)

- `nanobanana mcp`는 **개발 과정에서 정적 에셋을 제작**하는 도구입니다.
- 제품 런타임(프론트/백엔드)에서 MCP에 의존하는 설계는 **금지**합니다.
- 생성된 에셋은 이 디렉토리(`frontend/public/ui/`)에 커밋하여 정적 배포합니다.

### 1.2 용어 SSOT (RULE-006)

- 이 도구는 반드시 **`nanobanana mcp`** 로 표기합니다.
- "나노바나나 MCP", "Nano Banana MCP", "banana mcp" 등 혼용 금지.
- 모델 별칭("Nano Banana / Nano Banana Pro")은 문서 인용 시에만 제한적 사용.

### 1.3 보안 (RULE-005)

- 키/토큰 등 비밀정보를 레포/로그/문서에 남기지 않습니다.
- 생성 과정에서 사용한 API 키나 인증 정보는 절대 커밋하지 않습니다.

---

## 2. 디렉토리 구조

```
frontend/public/ui/
├── README.md              # 이 파일 (SSOT 규칙)
├── manifest.schema.json   # 에셋 매니페스트 스키마
├── manifest.json          # (생성 시) 실제 에셋 목록
├── icons/                 # 아이콘 에셋
│   ├── signal-16.png
│   ├── signal-24.png
│   ├── badge-ok-16.png
│   └── ...
├── placeholders/          # 상태/장면 placeholder
│   ├── scene-loading.webp
│   ├── scene-error.webp
│   └── ...
└── chrome/                # UI 프레임/장식
    ├── panel-corner-tl.png
    ├── panel-border-h.png
    └── ...
```

---

## 3. 네이밍 규칙

### 3.1 기본 포맷

```
{용도}-{크기}.{확장자}
{용도}-{상태}-{크기}.{확장자}
```

**예시**:

- `signal-24.png` — Signal 아이콘, 24px
- `badge-ok-16.png` — OK 배지, 16px
- `scene-loading.webp` — 로딩 상태 placeholder

### 3.2 규칙

| 항목       | 규칙                                              |
| ---------- | ------------------------------------------------- |
| **케이스** | `kebab-case` (소문자 + 하이픈)                    |
| **용도**   | 명확한 역할 표현 (signal, badge, scene, panel 등) |
| **상태**   | 필요 시 상태 포함 (ok, fail, loading, error 등)   |
| **크기**   | 픽셀 단위 숫자 (16, 24, 32, 64 등)                |
| **확장자** | 용도에 맞게 선택 (아래 참조)                      |

---

## 4. 포맷 및 사이즈 규칙

### 4.1 포맷 선택

| 용도            | 기본 포맷  | 대안 | 비고                               |
| --------------- | ---------- | ---- | ---------------------------------- |
| **아이콘**      | PNG (투명) | -    | 작은 크기, 투명도 필수             |
| **placeholder** | WebP       | PNG  | 용량 절감 우선 (Q1 결정: Option B) |
| **chrome**      | PNG (투명) | -    | 프레임/장식, 투명도 필수           |

> **배경 제거(필수 조건부)**: 아이콘/chrome 등 투명 배경이 필요한 에셋은 생성 결과에 배경이 남아 있으면 `rembg`로 배경을 제거해 투명 PNG로 정리합니다. (가이드: `vibe/ref/rembg-guide.md`)

### 4.2 사이즈 규격

| 용도            | 필수 사이즈 | 선택 사이즈 | 비고             |
| --------------- | ----------- | ----------- | ---------------- |
| **아이콘**      | 16, 24      | 32, 64      | 최소 2종 필수    |
| **placeholder** | 가변        | -           | 용도별 적정 크기 |
| **chrome**      | 가변        | -           | 타일링/반복 고려 |

### 4.3 Retina 대응 (선택)

- 필요 시 `image-set()`으로 1x/2x 제공
- 파일명: `{name}-24.png`, `{name}-24@2x.png`

---

## 5. 성능 예산

| 항목                | 상한  | 권장       |
| ------------------- | ----- | ---------- |
| **아이콘 1개**      | 30KB  | 20KB 이하  |
| **placeholder 1개** | 300KB | 200KB 이하 |
| **chrome 1개**      | 50KB  | 30KB 이하  |
| **`ui/` 폴더 총합** | 1.5MB | 1MB 이하   |

**초과 시 대응**:

1. 압축/최적화 (TinyPNG, ImageOptim 등)
2. 해상도/색상 축소
3. 불필요 에셋 제거
4. 예산 상향 시 근거 문서화 필요

---

## 6. 스타일 가이드

### 6.1 CRT 테마 연동

에셋은 `frontend/src/style.css`의 CSS 변수/테마와 조화를 이뤄야 합니다.

```css
/* 참조: CRT 테마 색상 */
--bg-color: #0d0d0d; /* 배경 */
--text-color: #33ff00; /* 인광 녹색 */
--text-dim: #1a8000; /* 어두운 녹색 */
--accent-color: #ff00ff; /* 마젠타 */
--warning-color: #ffaa00; /* 주황색 */
--error-color: #ff3333; /* 붉은색 */
```

### 6.2 스타일 원칙

| 원칙                  | 설명                          |
| --------------------- | ----------------------------- |
| **레트로 퓨처리즘**   | CRT/터미널 미학과 조화        |
| **기능적 미니멀리즘** | 불필요한 장식 배제            |
| **톤 일관성**         | 인광 녹색 기반, 마젠타 포인트 |
| **고대비**            | Readable 모드에서도 식별 가능 |

### 6.3 금지 사항

- ❌ 프로젝트 외부 로고/상표 복제
- ❌ CRT 테마와 충돌하는 색상 (밝은 파스텔, 난색 계열 남용)
- ❌ 복잡한 그라데이션/사진 스타일

---

## 7. 폴백 원칙 (필수)

### 7.1 텍스트/이모지 폴백 유지

에셋 로딩 실패/미지원 시에도 **UI가 깨지지 않도록** 텍스트/이모지 라벨을 유지해야 합니다.

**예시** (React):

```tsx
<span className="icon-wrapper" aria-label="Signal">
  <img
    src="/ui/icons/signal-24.png"
    alt=""
    aria-hidden="true"
    onError={(e) => (e.currentTarget.style.display = 'none')}
  />
  <span className="icon-fallback">📡</span>
</span>
```

**CSS**:

```css
.icon-wrapper {
  display: inline-flex;
  align-items: center;
}
.icon-wrapper img + .icon-fallback {
  display: none;
}
.icon-wrapper img[style*='display: none'] + .icon-fallback {
  display: inline;
}
```

### 7.2 폴백 요구사항

| 에셋 유형       | 폴백 방식                |
| --------------- | ------------------------ |
| **아이콘**      | 이모지 또는 텍스트 라벨  |
| **placeholder** | CSS 배경색 + 텍스트      |
| **chrome**      | CSS border/shadow로 대체 |

---

## 8. 접근성 가이드

### 8.1 필수 사항

| 항목                          | 요구사항                            |
| ----------------------------- | ----------------------------------- |
| **색상만으로 의미 전달 금지** | 텍스트/라벨 병행                    |
| **장식성 이미지**             | `aria-hidden="true"` 적용           |
| **기능성 이미지**             | `alt` 텍스트 제공 또는 `aria-label` |
| **대비**                      | Readable 모드에서도 4.5:1 이상      |

### 8.2 예시

```html
<!-- 장식용 아이콘 (의미 없음) -->
<img src="/ui/chrome/corner.png" alt="" aria-hidden="true" />

<!-- 기능용 아이콘 (의미 있음) -->
<button aria-label="신호 전송">
  <img src="/ui/icons/signal-24.png" alt="Signal" />
</button>
```

---

## 9. 에셋 제작 워크플로우

### 9.1 요청 → 제작 → 적용

```
1. 요청 정의
   └── 용도, 사이즈, 스타일 명세 작성

2. nanobanana mcp로 제작
   └── 프롬프트에 CRT 스타일 키워드 포함
   └── 색상 팔레트 준수
   └── (필수 조건부) 배경 제거(rembg) 예정이면 **배경은 순백(#FFFFFF) 단색**으로 생성(그라데이션/텍스처/그림자 금지)

3. (필수 조건부) rembg로 배경 제거
   └── 아이콘/chrome 등 투명 배경이 필요한 에셋에서 배경이 남아 있으면 rembg로 제거
   └── 모델 선택/옵션은 `vibe/ref/rembg-guide.md` 준수

4. 리사이즈/압축
   └── 성능 예산 확인
   └── 필요 사이즈로 리사이즈

5. 디렉토리 반영
   └── 네이밍 규칙 준수
   └── manifest.json 업데이트

6. UI 적용 + 폴백 확인
   └── 컴포넌트에 적용
   └── 폴백 동작 테스트

7. QA
   └── 크기/대비/폴백/Readable 모드 확인
```

### 9.2 프롬프트 가이드 (예시)

```
CRT 터미널 스타일 아이콘,
인광 녹색(#33ff00) 기반,
검은 배경(#0d0d0d)에 어울리는 톤,
심플한 라인 아트,
픽셀 아트 또는 레트로 스타일,
24x24 픽셀, 투명 배경
(배경 제거 필요 시) solid white background (#FFFFFF), no gradient/texture/shadow
```

---

## 10. 매니페스트 관리

### 10.1 manifest.json

모든 에셋은 `manifest.json`에 등록하여 추적합니다.

```json
{
  "$schema": "./manifest.schema.json",
  "version": "1.0.0",
  "assets": [
    {
      "id": "signal-24",
      "path": "icons/signal-24.png",
      "type": "icon",
      "size": 24,
      "fallback": "📡",
      "usedIn": ["EconomyHUD"],
      "bytes": 1234
    }
  ]
}
```

### 10.2 업데이트 시점

- 에셋 추가/제거 시 manifest.json 동기화
- U-033에서 QA 자동화 예정

---

## 11. 라이선스

- 모든 에셋은 **프로젝트 내부 용도**로 제작됩니다.
- 외부 로고/상표를 복제하지 않습니다.
- `nanobanana mcp`로 생성된 에셋은 도구의 라이선스 정책을 따릅니다.
- 에셋에 **SynthID 워터마크**가 포함될 수 있습니다 (AI 생성 표기).

---

## 12. 체크리스트 (에셋 추가 시)

- [ ] 네이밍 규칙 준수 (`kebab-case` + 용도 + 크기)
- [ ] 포맷 규칙 준수 (아이콘=PNG, placeholder=WebP)
- [ ] 성능 예산 준수 (개별/총합)
- [ ] (조건부) 투명 배경이 필요한 에셋은 `rembg`로 배경 제거 완료(알파 채널 확인)
- [ ] (조건부) 배경 제거(rembg) 예정이면 원본 생성 단계에서 배경이 순백(#FFFFFF) 단색인지 확인(그라데이션/텍스처/그림자 금지)
- [ ] CRT 테마 색상과 조화
- [ ] 폴백 구현 확인
- [ ] 접근성 속성 적용 (`aria-hidden` 또는 `alt`)
- [ ] manifest.json 업데이트
- [ ] Readable 모드에서 대비 확인

---

_마지막 업데이트: 2026-01-11_
_문서 버전: 1.1.0_
</file>

<file path="frontend/src/types/turn_stream.ts">
/**
 * Unknown World - Turn Stream 이벤트 계약(Contract).
 *
 * NDJSON 스트리밍에서 사용되는 이벤트 타입, 인터페이스를 정의합니다.
 * 이 모듈은 백엔드와 프론트엔드 간의 스트림 이벤트 계약 SSOT입니다.
 *
 * 설계 원칙:
 *   - RU-002-Q4: 이벤트 계약을 transport 계층으로 분리
 *   - RU-002-S2: 이벤트별 Zod 검증 + Unknown/확장 이벤트 폴백
 *   - RULE-003: 구조화 출력(JSON Schema) 우선 + 이중 검증
 *   - RULE-008: 단계/배지 가시화
 *
 * 참조:
 *   - vibe/unit-plans/U-007[Mvp].md
 *   - vibe/refactors/RU-002-Q4.md
 *   - vibe/refactors/RU-002-S2.md
 *
 * @module types/turn_stream
 */

import { z } from 'zod';
import {
  AgentPhaseSchema,
  ValidationBadgeSchema,
  type TurnOutput,
  type AgentPhase,
  type ValidationBadge,
} from '../schemas/turn';

// =============================================================================
// 스트림 이벤트 타입 상수 (서버 계약과 일치)
// =============================================================================

/** 스트림 이벤트 타입 상수 */
export const StreamEventType = {
  STAGE: 'stage',
  BADGES: 'badges',
  NARRATIVE_DELTA: 'narrative_delta',
  FINAL: 'final',
  ERROR: 'error',
  REPAIR: 'repair',
} as const;

export type StreamEventTypeName = (typeof StreamEventType)[keyof typeof StreamEventType];

/**
 * 단계 상태 상수.
 * RU-002-S2/RU-002-Q2: v1(complete) 및 v2(ok/fail) 별칭 모두 지원.
 */
export const StageStatus = {
  START: 'start',
  COMPLETE: 'complete',
  /** 단계 실패 */
  FAIL: 'fail',
} as const;

export type StageStatusName = (typeof StageStatus)[keyof typeof StageStatus];

// =============================================================================
// RU-002-S2: 이벤트별 Zod 스키마 (경량 검증 + 폴백)
// =============================================================================

/**
 * stage.status 스키마.
 * v1(complete) 및 v2(ok/fail) 별칭 모두 허용.
 */
export const StageStatusSchema = z.enum(['start', 'complete', 'ok', 'fail']);

/**
 * StageEvent Zod 스키마.
 * 단계 진행 이벤트 검증용.
 */
export const StageEventSchema = z.object({
  type: z.literal(StreamEventType.STAGE),
  name: AgentPhaseSchema,
  status: StageStatusSchema,
});

/**
 * RepairEvent Zod 스키마.
 * 자동 복구 시도 이벤트 검증용.
 */
export const RepairEventSchema = z.object({
  type: z.literal(StreamEventType.REPAIR),
  attempt: z.number(),
  message: z.string().optional(),
});

/**
 * BadgesEvent Zod 스키마 (v1: 배열).
 * v1은 badges: string[] 형식.
 */
export const BadgesEventSchemaV1 = z.object({
  type: z.literal(StreamEventType.BADGES),
  badges: z.array(ValidationBadgeSchema),
});

/**
 * BadgesEvent Zod 스키마 (v2: 객체/맵).
 * 향후 v2는 badges: { [key]: status } 형식을 지원할 수 있음.
 * 현재는 v1만 사용하므로 이 스키마는 확장성을 위해 정의.
 */
export const BadgesEventSchemaV2 = z.object({
  type: z.literal(StreamEventType.BADGES),
  badges: z.record(z.string(), z.boolean()),
});

/**
 * BadgesEvent 통합 스키마.
 * v1(배열) 또는 v2(객체) 모두 허용.
 */
export const BadgesEventSchema = z.union([BadgesEventSchemaV1, BadgesEventSchemaV2]);

/**
 * NarrativeDeltaEvent Zod 스키마.
 * 타자 효과용 내러티브 델타 이벤트 검증용.
 */
export const NarrativeDeltaEventSchema = z.object({
  type: z.literal(StreamEventType.NARRATIVE_DELTA),
  text: z.string(),
});

/**
 * FinalEvent 원시 스키마.
 * v1(data) 및 v2(turn_output) 별칭 모두 허용.
 * TurnOutput 자체 검증은 turnStream.ts에서 safeParseTurnOutput으로 수행.
 */
export const FinalEventRawSchema = z.object({
  type: z.literal(StreamEventType.FINAL),
  data: z.unknown(),
});

/**
 * ErrorEvent Zod 스키마.
 * 에러 이벤트 검증용.
 */
export const ErrorEventSchema = z.object({
  type: z.literal(StreamEventType.ERROR),
  message: z.string(),
  code: z.string().optional(),
});

/**
 * 이벤트 타입 추출용 최소 스키마.
 * Unknown 이벤트 판별에 사용.
 */
export const BaseEventSchema = z.object({
  type: z.string(),
});

// =============================================================================
// 이벤트 파싱 유틸리티 (RU-002-S2)
// =============================================================================

/** 이벤트 검증 결과 타입 */
export type EventParseResult<T> =
  | { success: true; data: T }
  | { success: false; error: z.ZodError };

/**
 * StageEvent를 안전하게 파싱합니다.
 */
export function safeParseStageEvent(
  data: unknown,
): EventParseResult<z.infer<typeof StageEventSchema>> {
  const result = StageEventSchema.safeParse(data);
  return result.success
    ? { success: true, data: result.data }
    : { success: false, error: result.error };
}

/**
 * RepairEvent를 안전하게 파싱합니다.
 */
export function safeParseRepairEvent(
  data: unknown,
): EventParseResult<z.infer<typeof RepairEventSchema>> {
  const result = RepairEventSchema.safeParse(data);
  return result.success
    ? { success: true, data: result.data }
    : { success: false, error: result.error };
}

/**
 * BadgesEvent를 안전하게 파싱합니다.
 * v1(배열) 형태로 정규화하여 반환합니다.
 */
export function safeParseBadgesEvent(data: unknown): EventParseResult<BadgesEvent> {
  const result = BadgesEventSchema.safeParse(data);
  if (!result.success) {
    return { success: false, error: result.error };
  }

  // v2(객체) 형태인 경우 v1(배열)로 정규화
  const parsed = result.data;
  if (Array.isArray(parsed.badges)) {
    // v1 형태: 그대로 반환
    return {
      success: true,
      data: { type: StreamEventType.BADGES, badges: parsed.badges as ValidationBadge[] },
    };
  } else {
    // v2 형태: true인 키만 추출하여 배열로 변환
    const badgeArray = Object.entries(parsed.badges)
      .filter(([, value]) => value)
      .map(([key]) => key as ValidationBadge);
    return {
      success: true,
      data: { type: StreamEventType.BADGES, badges: badgeArray },
    };
  }
}

/**
 * NarrativeDeltaEvent를 안전하게 파싱합니다.
 */
export function safeParseNarrativeDeltaEvent(
  data: unknown,
): EventParseResult<z.infer<typeof NarrativeDeltaEventSchema>> {
  const result = NarrativeDeltaEventSchema.safeParse(data);
  return result.success
    ? { success: true, data: result.data }
    : { success: false, error: result.error };
}

/**
 * FinalEvent 원시 형태를 안전하게 파싱합니다.
 * TurnOutput 자체 검증은 별도로 수행해야 합니다.
 */
export function safeParseFinalEventRaw(
  data: unknown,
): EventParseResult<z.infer<typeof FinalEventRawSchema>> {
  const result = FinalEventRawSchema.safeParse(data);
  return result.success
    ? { success: true, data: result.data }
    : { success: false, error: result.error };
}

/**
 * ErrorEvent를 안전하게 파싱합니다.
 */
export function safeParseErrorEvent(
  data: unknown,
): EventParseResult<z.infer<typeof ErrorEventSchema>> {
  const result = ErrorEventSchema.safeParse(data);
  return result.success
    ? { success: true, data: result.data }
    : { success: false, error: result.error };
}

/**
 * stage.status 정규화 헬퍼.
 * 'ok'를 'complete'로, 'fail'은 그대로 유지.
 */
export function normalizeStageStatus(status: string): 'start' | 'complete' | 'fail' {
  if (status === 'ok') return 'complete';
  if (status === 'fail') return 'fail';
  if (status === 'start') return 'start';
  return 'complete';
}

// =============================================================================
// 스트림 이벤트 인터페이스
// =============================================================================

/**
 * 단계 진행 이벤트.
 * RU-002-S2: status에 'fail' 추가하여 단계 실패 표현 지원.
 */
export interface StageEvent {
  type: typeof StreamEventType.STAGE;
  name: AgentPhase;
  /** 'start' | 'complete' | 'ok' | 'fail'. ok는 complete로 정규화됨. */
  status: StageStatusName;
}

/** 자동 복구(Repair) 이벤트 */
export interface RepairEvent {
  type: typeof StreamEventType.REPAIR;
  attempt: number;
  message?: string;
}

/** 배지 이벤트 */
export interface BadgesEvent {
  type: typeof StreamEventType.BADGES;
  badges: ValidationBadge[];
}

/** 내러티브 델타 이벤트 (타자 효과용) */
export interface NarrativeDeltaEvent {
  type: typeof StreamEventType.NARRATIVE_DELTA;
  text: string;
}

/** 최종 TurnOutput 이벤트
 *
 * RU-002-Q2: v1은 `data`, v2는 `turn_output` 사용.
 * 하위호환을 위해 두 필드 모두 선언하되, 정규화된 인터페이스는 `data`를 사용.
 */
export interface FinalEvent {
  type: typeof StreamEventType.FINAL;
  /** v1 현행 계약: TurnOutput 페이로드 */
  data: TurnOutput;
}

/** FinalEvent 원시 수신 형태 */
export interface FinalEventRaw {
  type: typeof StreamEventType.FINAL;
  /** TurnOutput 페이로드 */
  data: TurnOutput;
}

/** 에러 이벤트 */
export interface ErrorEvent {
  type: typeof StreamEventType.ERROR;
  message: string;
  code?: string;
}

/** 스트림 이벤트 유니온 타입 */
export type StreamEvent =
  | StageEvent
  | RepairEvent
  | BadgesEvent
  | NarrativeDeltaEvent
  | FinalEvent
  | ErrorEvent;

// =============================================================================
// 스트림 콜백 인터페이스
// =============================================================================

/** 스트림 이벤트 콜백 */
export interface StreamCallbacks {
  /** 단계 진행 이벤트 */
  onStage?: (event: StageEvent) => void;
  /** 자동 복구 이벤트 */
  onRepair?: (event: RepairEvent) => void;
  /** 배지 이벤트 */
  onBadges?: (event: BadgesEvent) => void;
  /** 내러티브 델타 이벤트 */
  onNarrativeDelta?: (event: NarrativeDeltaEvent) => void;
  /** 최종 TurnOutput 이벤트 */
  onFinal?: (event: FinalEvent) => void;
  /** 에러 이벤트 */
  onError?: (event: ErrorEvent) => void;
  /** 스트림 완료 */
  onComplete?: () => void;
}
</file>

<file path="shared/schemas/turn/turn_output.schema.json">
{
  "$defs": {
    "ActionCard": {
      "additionalProperties": false,
      "description": "액션 카드 (Action Deck).\n\n매 턴 AI가 추천하는 행동 카드입니다.\n각 카드에 비용/위험/보상 힌트가 포함됩니다.\n\nAttributes:\n    id: 카드 고유 ID\n    label: 카드 라벨 (표시용)\n    description: 카드 설명 (선택)\n    cost: 예상 비용\n    risk: 위험도\n    hint: 예상 결과 힌트 (선택)",
      "properties": {
        "id": {
          "description": "카드 고유 ID",
          "title": "Id",
          "type": "string"
        },
        "label": {
          "description": "카드 라벨 (표시용)",
          "title": "Label",
          "type": "string"
        },
        "description": {
          "anyOf": [
            {
              "type": "string"
            },
            {
              "type": "null"
            }
          ],
          "default": null,
          "description": "카드 설명 (선택)",
          "title": "Description"
        },
        "cost": {
          "$ref": "#/$defs/CurrencyAmount",
          "description": "예상 비용"
        },
        "risk": {
          "$ref": "#/$defs/RiskLevel",
          "default": "low",
          "description": "위험도"
        },
        "hint": {
          "anyOf": [
            {
              "type": "string"
            },
            {
              "type": "null"
            }
          ],
          "default": null,
          "description": "예상 결과 힌트 (선택)",
          "title": "Hint"
        }
      },
      "required": [
        "id",
        "label",
        "cost"
      ],
      "title": "ActionCard",
      "type": "object"
    },
    "ActionDeck": {
      "additionalProperties": false,
      "description": "액션 덱 (Q1 결정: ui.action_deck.cards[] 구조).\n\n매 턴 AI가 제시하는 추천 행동 카드 덱입니다.\n\nAttributes:\n    cards: 액션 카드 목록 (3~6장 권장)",
      "properties": {
        "cards": {
          "default": [],
          "description": "액션 카드 목록 (3~6장 권장)",
          "items": {
            "$ref": "#/$defs/ActionCard"
          },
          "maxItems": 10,
          "minItems": 0,
          "title": "Cards",
          "type": "array"
        }
      },
      "title": "ActionDeck",
      "type": "object"
    },
    "AgentConsole": {
      "additionalProperties": false,
      "description": "에이전트 콘솔 데이터 (RULE-008).\n\n에이전트형 시스템임을 UI로 증명하기 위한 정보입니다.\n계획/실행/검증/복구의 흔적을 표시합니다.\n\nAttributes:\n    current_phase: 현재 실행 단계\n    badges: 검증 배지 목록\n    repair_count: 자동 복구 시도 횟수",
      "properties": {
        "current_phase": {
          "$ref": "#/$defs/AgentPhase",
          "default": "commit",
          "description": "현재 실행 단계"
        },
        "badges": {
          "default": [],
          "description": "검증 배지 목록",
          "items": {
            "$ref": "#/$defs/ValidationBadge"
          },
          "title": "Badges",
          "type": "array"
        },
        "repair_count": {
          "default": 0,
          "description": "자동 복구 시도 횟수",
          "minimum": 0,
          "title": "Repair Count",
          "type": "integer"
        }
      },
      "title": "AgentConsole",
      "type": "object"
    },
    "AgentPhase": {
      "description": "에이전트 실행 단계 (RULE-008).\n\n에이전트형 시스템임을 UI로 증명하기 위한 단계 표시.",
      "enum": [
        "parse",
        "validate",
        "plan",
        "resolve",
        "render",
        "verify",
        "commit"
      ],
      "title": "AgentPhase",
      "type": "string"
    },
    "Box2D": {
      "additionalProperties": false,
      "description": "2D 바운딩 박스 (RULE-009).\n\n좌표는 0~1000 정규화 좌표계이며, bbox는 [ymin, xmin, ymax, xmax] 순서입니다.\n이미지 이해 bbox 포맷과 호환됩니다.\n\nAttributes:\n    ymin: Y 최소값 (상단)\n    xmin: X 최소값 (좌측)\n    ymax: Y 최대값 (하단)\n    xmax: X 최대값 (우측)",
      "properties": {
        "ymin": {
          "description": "정규화 좌표 (0~1000)",
          "maximum": 1000,
          "minimum": 0,
          "title": "Ymin",
          "type": "integer"
        },
        "xmin": {
          "description": "정규화 좌표 (0~1000)",
          "maximum": 1000,
          "minimum": 0,
          "title": "Xmin",
          "type": "integer"
        },
        "ymax": {
          "description": "정규화 좌표 (0~1000)",
          "maximum": 1000,
          "minimum": 0,
          "title": "Ymax",
          "type": "integer"
        },
        "xmax": {
          "description": "정규화 좌표 (0~1000)",
          "maximum": 1000,
          "minimum": 0,
          "title": "Xmax",
          "type": "integer"
        }
      },
      "required": [
        "ymin",
        "xmin",
        "ymax",
        "xmax"
      ],
      "title": "Box2D",
      "type": "object"
    },
    "CurrencyAmount": {
      "additionalProperties": false,
      "description": "재화 수량.\n\nAttributes:\n    signal: 기본 재화 (텍스트 턴/이미지 생성/고급 기능에 소비)\n    memory_shard: 희귀 재화 (중요 설정 고정, 고해상도 이미지 등에 소비)",
      "properties": {
        "signal": {
          "description": "시그널 (기본 재화, 0 이상)",
          "minimum": 0,
          "title": "Signal",
          "type": "integer"
        },
        "memory_shard": {
          "description": "기억 파편 (희귀 재화, 0 이상)",
          "minimum": 0,
          "title": "Memory Shard",
          "type": "integer"
        }
      },
      "required": [
        "signal",
        "memory_shard"
      ],
      "title": "CurrencyAmount",
      "type": "object"
    },
    "EconomyOutput": {
      "additionalProperties": false,
      "description": "경제 출력 데이터 (RULE-005).\n\n이번 턴의 비용과 잔액 정보입니다.\n잔액 음수는 절대 불가 (서버 Hard gate).\n\nAttributes:\n    cost: 이번 턴에 소비된 비용\n    balance_after: 소비 후 잔액\n\nImportant:\n    - cost와 balance_after는 항상 포함되어야 합니다.\n    - balance_after의 signal과 memory_shard는 0 이상이어야 합니다.",
      "properties": {
        "cost": {
          "$ref": "#/$defs/CurrencyAmount",
          "description": "이번 턴에 소비된 비용"
        },
        "balance_after": {
          "$ref": "#/$defs/CurrencyAmount",
          "description": "소비 후 잔액"
        }
      },
      "required": [
        "cost",
        "balance_after"
      ],
      "title": "EconomyOutput",
      "type": "object"
    },
    "ImageJob": {
      "additionalProperties": false,
      "description": "이미지 생성 작업.\n\n조건부 이미지 생성/편집 요청입니다.\n이미지 생성이 느릴 경우 텍스트 우선 출력 + Lazy Loading을 사용합니다.\n\nAttributes:\n    should_generate: 이미지를 생성해야 하는지\n    prompt: 이미지 생성 프롬프트\n    model_label: 모델 선택 라벨 (FAST/QUALITY/CHEAP/REF)\n    aspect_ratio: 가로세로 비율 (예: \"16:9\", \"1:1\")\n    image_size: 이미지 크기 (예: \"1024x1024\")\n    reference_image_ids: 참조 이미지 ID 목록 (선택)",
      "properties": {
        "should_generate": {
          "description": "이미지를 생성해야 하는지",
          "title": "Should Generate",
          "type": "boolean"
        },
        "prompt": {
          "default": "",
          "description": "이미지 생성 프롬프트",
          "title": "Prompt",
          "type": "string"
        },
        "model_label": {
          "$ref": "#/$defs/ModelLabel",
          "default": "FAST",
          "description": "모델 선택 라벨"
        },
        "aspect_ratio": {
          "default": "16:9",
          "description": "가로세로 비율",
          "title": "Aspect Ratio",
          "type": "string"
        },
        "image_size": {
          "default": "1024x1024",
          "description": "이미지 크기",
          "title": "Image Size",
          "type": "string"
        },
        "reference_image_ids": {
          "default": [],
          "description": "참조 이미지 ID 목록 (선택)",
          "items": {
            "type": "string"
          },
          "title": "Reference Image Ids",
          "type": "array"
        }
      },
      "required": [
        "should_generate"
      ],
      "title": "ImageJob",
      "type": "object"
    },
    "Language": {
      "description": "지원 언어 (RULE-006).\n\nko/en 혼합 출력 금지. TurnInput.language를 SSOT로 삼아\n모든 UI/내러티브/시스템 메시지는 동일 언어로 고정합니다.",
      "enum": [
        "ko-KR",
        "en-US"
      ],
      "title": "Language",
      "type": "string"
    },
    "MemoryPin": {
      "additionalProperties": false,
      "description": "중요 설정 고정 후보.\n\n사용자가 Memory Shard를 소비해 고정할 수 있는 중요 설정입니다.\n\nAttributes:\n    id: 핀 고유 ID\n    content: 고정할 내용\n    cost: 고정에 필요한 비용",
      "properties": {
        "id": {
          "description": "핀 고유 ID",
          "title": "Id",
          "type": "string"
        },
        "content": {
          "description": "고정할 내용",
          "title": "Content",
          "type": "string"
        },
        "cost": {
          "$ref": "#/$defs/CurrencyAmount",
          "description": "고정에 필요한 비용"
        }
      },
      "required": [
        "id",
        "content",
        "cost"
      ],
      "title": "MemoryPin",
      "type": "object"
    },
    "ModelLabel": {
      "description": "모델/품질 선택 라벨 (RULE-008).\n\n프롬프트 노출 없이 \"왜 이 선택이었는지\"를 사용자 친화 라벨로 표시.",
      "enum": [
        "FAST",
        "QUALITY",
        "CHEAP",
        "REF"
      ],
      "title": "ModelLabel",
      "type": "string"
    },
    "Quest": {
      "additionalProperties": false,
      "description": "퀘스트/목표 (Quest Panel).\n\n플레이어가 달성해야 하는 현재 목표입니다.\n\nAttributes:\n    id: 퀘스트 고유 ID\n    label: 퀘스트 이름\n    is_completed: 달성 여부",
      "properties": {
        "id": {
          "description": "퀘스트 고유 ID",
          "title": "Id",
          "type": "string"
        },
        "label": {
          "description": "퀘스트 이름",
          "title": "Label",
          "type": "string"
        },
        "is_completed": {
          "default": false,
          "description": "달성 여부",
          "title": "Is Completed",
          "type": "boolean"
        }
      },
      "required": [
        "id",
        "label"
      ],
      "title": "Quest",
      "type": "object"
    },
    "RenderOutput": {
      "additionalProperties": false,
      "description": "렌더링 출력 데이터.\n\n이미지 생성/편집 관련 정보입니다.\n\nAttributes:\n    image_job: 이미지 생성 작업 (선택)",
      "properties": {
        "image_job": {
          "anyOf": [
            {
              "$ref": "#/$defs/ImageJob"
            },
            {
              "type": "null"
            }
          ],
          "default": null,
          "description": "이미지 생성 작업 (선택)"
        }
      },
      "title": "RenderOutput",
      "type": "object"
    },
    "RiskLevel": {
      "description": "행동 위험도 수준.",
      "enum": [
        "low",
        "medium",
        "high"
      ],
      "title": "RiskLevel",
      "type": "string"
    },
    "SafetyOutput": {
      "additionalProperties": false,
      "description": "안전 출력 데이터.\n\n안전 정책 관련 정보입니다.\n차단 시 명시적 메시지와 함께 안전한 대체 결과를 제공합니다.\n\nAttributes:\n    blocked: 안전 정책에 의해 차단되었는지\n    message: 차단 시 사용자에게 표시할 메시지 (선택)",
      "properties": {
        "blocked": {
          "default": false,
          "description": "안전 정책에 의해 차단되었는지",
          "title": "Blocked",
          "type": "boolean"
        },
        "message": {
          "anyOf": [
            {
              "type": "string"
            },
            {
              "type": "null"
            }
          ],
          "default": null,
          "description": "차단 시 사용자에게 표시할 메시지 (선택)",
          "title": "Message"
        }
      },
      "title": "SafetyOutput",
      "type": "object"
    },
    "SceneObject": {
      "additionalProperties": false,
      "description": "장면 오브젝트 (클릭 가능한 핫스팟).\n\n화면에서 클릭 가능한 오브젝트입니다.\n좌표는 0~1000 정규화 좌표계를 사용합니다 (RULE-009).\n\nAttributes:\n    id: 오브젝트 고유 ID\n    label: 오브젝트 라벨 (표시용)\n    box_2d: 바운딩 박스 [ymin, xmin, ymax, xmax]\n    interaction_hint: 상호작용 힌트 (선택)",
      "properties": {
        "id": {
          "description": "오브젝트 고유 ID",
          "title": "Id",
          "type": "string"
        },
        "label": {
          "description": "오브젝트 라벨 (표시용)",
          "title": "Label",
          "type": "string"
        },
        "box_2d": {
          "$ref": "#/$defs/Box2D",
          "description": "바운딩 박스"
        },
        "interaction_hint": {
          "anyOf": [
            {
              "type": "string"
            },
            {
              "type": "null"
            }
          ],
          "default": null,
          "description": "상호작용 힌트 (선택)",
          "title": "Interaction Hint"
        }
      },
      "required": [
        "id",
        "label",
        "box_2d"
      ],
      "title": "SceneObject",
      "type": "object"
    },
    "UIOutput": {
      "additionalProperties": false,
      "description": "UI 출력 데이터.\n\nAI가 생성한 UI 요소들입니다.\n채팅 버블이 아닌 게임 UI로 표현됩니다 (RULE-002).\n\nAttributes:\n    action_deck: 액션 카드 덱 (Q1 결정: Option A 채택)\n    objects: 클릭 가능한 장면 오브젝트 목록",
      "properties": {
        "action_deck": {
          "$ref": "#/$defs/ActionDeck",
          "description": "액션 카드 덱"
        },
        "objects": {
          "default": [],
          "description": "클릭 가능한 장면 오브젝트 목록",
          "items": {
            "$ref": "#/$defs/SceneObject"
          },
          "title": "Objects",
          "type": "array"
        }
      },
      "title": "UIOutput",
      "type": "object"
    },
    "ValidationBadge": {
      "description": "검증 배지 (RULE-008).\n\n턴 결과에 대한 검증 상태를 표시합니다.",
      "enum": [
        "schema_ok",
        "schema_fail",
        "economy_ok",
        "economy_fail",
        "safety_ok",
        "safety_blocked",
        "consistency_ok",
        "consistency_fail"
      ],
      "title": "ValidationBadge",
      "type": "string"
    },
    "WorldDelta": {
      "additionalProperties": false,
      "description": "세계 상태 변화 (Q2 결정: Option A - delta 중심).\n\n이번 턴에서 변경된 세계 상태를 나타냅니다.\nsnapshot은 SaveGame에만 저장하고, 매 턴은 delta만 전송합니다.\n\nAttributes:\n    rules_changed: 변경되거나 추가된 규칙 목록\n    inventory_added: 추가된 인벤토리 아이템\n    inventory_removed: 제거된 인벤토리 아이템\n    quests_updated: 업데이트된 퀘스트(목표) 목록\n    relationships_changed: 변경된 관계\n    memory_pins: 중요 설정 고정 후보",
      "properties": {
        "rules_changed": {
          "default": [],
          "description": "변경된 규칙 목록",
          "items": {
            "$ref": "#/$defs/WorldRule"
          },
          "title": "Rules Changed",
          "type": "array"
        },
        "inventory_added": {
          "default": [],
          "description": "추가된 인벤토리 아이템",
          "items": {
            "type": "string"
          },
          "title": "Inventory Added",
          "type": "array"
        },
        "inventory_removed": {
          "default": [],
          "description": "제거된 인벤토리 아이템",
          "items": {
            "type": "string"
          },
          "title": "Inventory Removed",
          "type": "array"
        },
        "quests_updated": {
          "default": [],
          "description": "업데이트된 퀘스트/목표 목록",
          "items": {
            "$ref": "#/$defs/Quest"
          },
          "title": "Quests Updated",
          "type": "array"
        },
        "relationships_changed": {
          "default": [],
          "description": "변경된 관계",
          "items": {
            "type": "string"
          },
          "title": "Relationships Changed",
          "type": "array"
        },
        "memory_pins": {
          "default": [],
          "description": "중요 설정 고정 후보",
          "items": {
            "$ref": "#/$defs/MemoryPin"
          },
          "title": "Memory Pins",
          "type": "array"
        }
      },
      "title": "WorldDelta",
      "type": "object"
    },
    "WorldRule": {
      "additionalProperties": false,
      "description": "세계 규칙 (Rule Board).\n\n현재 세계에 적용 중인 물리 법칙이나 메타 규칙입니다.\n\nAttributes:\n    id: 규칙 고유 ID\n    label: 규칙 이름\n    description: 규칙 상세 설명 (선택)",
      "properties": {
        "id": {
          "description": "규칙 고유 ID",
          "title": "Id",
          "type": "string"
        },
        "label": {
          "description": "규칙 이름",
          "title": "Label",
          "type": "string"
        },
        "description": {
          "anyOf": [
            {
              "type": "string"
            },
            {
              "type": "null"
            }
          ],
          "default": null,
          "description": "규칙 상세 설명 (선택)",
          "title": "Description"
        }
      },
      "required": [
        "id",
        "label"
      ],
      "title": "WorldRule",
      "type": "object"
    }
  },
  "additionalProperties": false,
  "description": "턴 출력 (서버 → 클라이언트).\n\n서버가 턴 처리 후 클라이언트로 반환하는 구조화된 응답입니다.\nGemini Structured Outputs(JSON Schema)로 강제됩니다.\n\nHard Gate 필드 (RULE-003/004/005):\n    - economy: cost와 balance_after 필수, 잔액 음수 금지\n    - safety: blocked 시 안전한 대체 결과 제공\n    - language: 요청 언어와 동일하게 고정 (혼합 출력 금지)\n\nAttributes:\n    language: 응답 언어 (요청과 동일)\n    narrative: 내러티브 텍스트 (표시용)\n    ui: UI 요소 (액션 덱, 오브젝트)\n    world: 세계 상태 변화 (delta 중심)\n    render: 렌더링 정보 (이미지 생성 작업)\n    economy: 경제 정보 (비용, 잔액)\n    safety: 안전 정책 정보\n    agent_console: 에이전트 실행 정보 (단계, 배지, 복구 횟수)\n\nExample:\n    >>> output = TurnOutput(\n    ...     language=Language.KO,\n    ...     narrative=\"문이 삐걱거리며 열립니다...\",\n    ...     economy=EconomyOutput(\n    ...         cost=CurrencyAmount(signal=5, memory_shard=0),\n    ...         balance_after=CurrencyAmount(signal=95, memory_shard=5),\n    ...     ),\n    ...     safety=SafetyOutput(blocked=False),\n    ... )\n    >>> schema = TurnOutput.model_json_schema()\n\nSchema Generation:\n    >>> # Gemini Structured Outputs용 JSON Schema 생성\n    >>> json_schema = TurnOutput.model_json_schema()\n    >>> # response_json_schema 파라미터에 전달\n    >>> config = {\n    ...     \"response_mime_type\": \"application/json\",\n    ...     \"response_json_schema\": json_schema,\n    ... }",
  "properties": {
    "language": {
      "$ref": "#/$defs/Language",
      "description": "응답 언어 (요청과 동일)"
    },
    "narrative": {
      "description": "내러티브 텍스트 (표시용)",
      "title": "Narrative",
      "type": "string"
    },
    "economy": {
      "$ref": "#/$defs/EconomyOutput",
      "description": "경제 정보 (비용, 잔액)"
    },
    "safety": {
      "$ref": "#/$defs/SafetyOutput",
      "description": "안전 정책 정보"
    },
    "ui": {
      "$ref": "#/$defs/UIOutput",
      "description": "UI 요소"
    },
    "world": {
      "$ref": "#/$defs/WorldDelta",
      "description": "세계 상태 변화 (delta)"
    },
    "render": {
      "$ref": "#/$defs/RenderOutput",
      "description": "렌더링 정보"
    },
    "agent_console": {
      "$ref": "#/$defs/AgentConsole",
      "description": "에이전트 실행 정보"
    }
  },
  "required": [
    "language",
    "narrative",
    "economy",
    "safety"
  ],
  "title": "TurnOutput",
  "type": "object"
}
</file>

<file path="vibe/changelog.md">
# 로드맵 변경 이력

## 2026-01-11 - roadmap-update/crt-flicker-icon-v2

### 변경 요약

가독성(Readable) 튜닝으로 CRT 지글거림이 “완전 OFF”처럼 느껴지는 문제를 방지하기 위해, CRT 효과를 **완화 프로파일로 재정의**하는 유닛(U-037)과, Signal/Shard/Risk 등 **핵심 UI 아이콘 12종을 v2로 재생성**하는 유닛(U-038)을 로드맵에 추가했습니다.

### 영향받은 문서

- ✏️ `vibe/prd.md`: Readable 모드/CRT 효과 보강 원칙 추가, 핵심 아이콘 12종(SSOT) 목록 명시
- ✏️ `vibe/roadmap.md`: U-037/U-038 추가, M2 카운트 조정(19→21) 및 상태/진행률 보정, 진행률/예상 완료 재계산, 에셋 유닛 Depends 누락(U-034) 정합화, "현재 작업" 표기 보정
- 🆕 `vibe/unit-plans/U-037[Mvp].md`: CRT 지글거림 보강(Readable 완화 프로파일) 계획서
- 🆕 `vibe/unit-plans/U-038[Mvp].md`: 핵심 UI 아이콘 12종 재생성(v2) 계획서
- ✏️ `vibe/unit-plans/U-033[Mvp].md`: 아이콘 v2(U-038) 산출물도 manifest/QA로 추적하도록 연동 힌트 추가

### 백로그 변경

**추가**:

- U-037[Mvp]: CRT 지글거림 보강(Readable 완화 프로파일) - 가독성 개선과 CRT 정체성 손실의 균형 보정
- U-038[Mvp]: 핵심 UI 아이콘 12종 재생성(v2) - 퀄리티/용량/사이즈(배율)/식별성 기준 고정

**수정**:

- U-029[Mvp]: Depends 누락 정합화 (이전: U-030,U-028,U-008 → 이후: U-030,U-028,U-008,U-034)
- U-031[Mvp]: Depends 누락 정합화 (이전: U-030,U-004 → 이후: U-030,U-004,U-034)
- U-032[Mvp]: Depends 누락 정합화 (이전: U-030,U-004 → 이후: U-030,U-004,U-034)

### 의존성 변경

- U-037[Mvp]: Depends=U-004,U-028
- U-038[Mvp]: Depends=U-033,U-034,U-030,U-028

### 진행률 변화

- **MVP**: 35% (16/46) → 33% (16/48)
- **MMP**: 0% (0/13) → 0% (0/13)
- **전체**: 27% (16/59) → 26% (16/61)

> 사유: 신규 유닛 2개 추가로 분모가 증가했습니다(완료 유닛 수는 동일).

### 품질 검증 결과

- **품질 기준 문서**: U-029[Mvp]
- **신규 유닛 계획서**: 2개 생성(U-037, U-038) - 필수 섹션/완료 기준/의존성/리스크/페어링 질문 포함 ✅
- **수정된 유닛 계획서**: 1개(U-033) - 섹션 누락 없음, 연동 힌트 추가 ✅
- **수정된 문서**: PRD/로드맵 - 기존 섹션 유지, 정보량 감소 없음 ✅

### 리스크 변경

**수정**:

- R-004: “가독성 vs CRT 정체성” 균형 붕괴 리스크를 명시하고, CRT 강도 프로파일 대응을 추가

### 주의사항

- Readable 모드의 의미는 “효과 완전 제거”가 아니라 “강도 완화”가 기본입니다(접근성/OS reduced motion에서는 완전 비활성화 가능).

---

## 2026-01-11 - roadmap-update/rembg-runtime-prompt-files

### 변경 요약

실시간 게임 진행 중 오브젝트 이미지 생성 시 **rembg 배경 제거 통합**(U-035)과, 스토리/이미지 프롬프트를 **ko/en 별도 md 파일로 분리 + 핫리로드**(U-036) 계획을 로드맵에 추가했습니다.

### 영향받은 문서

- ✏️ `vibe/tech-stack.md`: rembg를 Dev/런타임 도구로 추가, 기술 선택 매트릭스에 "오브젝트 이미지 배경 제거" 항목 추가
- ✏️ `vibe/prd.md`: 6.3에 "오브젝트 이미지 배경 제거(rembg)" 추가, 3.2에 프롬프트 관리 원칙/핫리로드 명시
- ✏️ `vibe/roadmap.md`: U-035/U-036 추가, M2 카운트 조정(17→19), 멀티모달 책임 Unit 확장, 진행률 재계산
- 🆕 `vibe/unit-plans/U-035[Mvp].md`: 실시간 이미지 생성 시 rembg 배경 제거 통합 계획서
- 🆕 `vibe/unit-plans/U-036[Mvp].md`: 스토리/이미지 프롬프트 파일 분리(ko/en) + 핫리로드 계획서
- ✏️ `vibe/unit-plans/U-017[Mvp].md`: "다음 작업에 전달할 것"에 U-036 연동 힌트 추가
- ✏️ `vibe/unit-plans/U-019[Mvp].md`: "다음 작업에 전달할 것"에 U-035/U-036 연동 힌트 추가

### 백로그 변경

**추가**:

- U-035[Mvp]: 실시간 이미지 생성 시 rembg 배경 제거 통합 - 투명 합성이 필요한 오브젝트/아이템 이미지 지원
- U-036[Mvp]: 스토리/이미지 프롬프트 파일 분리(ko/en) + 핫리로드 - 프롬프트 편집/튜닝/버전 관리 용이성 확보

**수정**:

- U-017[Mvp]: U-036 연동 힌트 추가 (프롬프트 로딩 기반)
- U-019[Mvp]: U-035/U-036 연동 힌트 추가 (이미지 파이프라인 확장 기반)

### 의존성 변경

- U-035[Mvp]: Depends=U-019,U-020 (이미지 생성/렌더 이후 배경 제거)
- U-036[Mvp]: Depends=U-017,U-019 (텍스트/이미지 프롬프트 사용처 이후 통합 로더)

### 진행률 변화

- **MVP**: 32% (14/44) → 30% (14/46)
- **MMP**: 0% (0/13) → 0% (0/13)
- **전체**: 25% (14/57) → 24% (14/59)

> 사유: 신규 유닛 2개 추가로 분모가 증가했습니다(완료 유닛 수는 동일).

### 품질 검증 결과

- **품질 기준 문서**: U-030[Mvp]
- **신규 유닛 계획서**: 2개 생성(U-035, U-036) - 필수 섹션/완료 기준/의존성/리스크/페어링 질문 포함 ✅
- **수정된 유닛 계획서**: 2개(U-017, U-019) - 섹션 누락 없음, "다음 작업에 전달할 것" 연동 힌트 추가 ✅
- **수정된 문서**: PRD/tech-stack/로드맵 - 기존 섹션 유지, 정보량 감소 없음 ✅

### 리스크 변경

**해소(부분)**:

- rembg 사용이 개발용 에셋에만 제한되던 것을 런타임으로 확장하여, 오브젝트 투명 합성 요구를 충족

### 주의사항

- rembg는 첫 실행 시 모델 다운로드(100~200MB)가 발생합니다. 배포 환경에서는 사전 다운로드(`rembg d <model>`)를 권장합니다.
- 프롬프트 핫리로드는 개발 모드에서만 활성화하고, 운영에서는 시작 시 로드/캐싱을 기본으로 합니다.

---

## 2026-01-10 - roadmap-update/nanobanana-rembg-white-background

### 변경 요약

`rembg` 배경 제거를 더 **편리하고 안정적으로** 수행할 수 있도록, 배경 제거가 필요한 에셋은 **생성 단계에서 배경을 순백(#FFFFFF) 단색**으로 만들도록(그라데이션/텍스처/그림자 금지) 유닛 계획서와 SSOT 문서에 강하게 추가했습니다.

### 영향받은 문서

- ✏️ `vibe/prd.md`: 9.7에 “배경 단순화(순백 단색) 규칙” 추가
- ✏️ `frontend/public/ui/README.md`: 워크플로우/프롬프트 예시/체크리스트에 “순백 단색 배경” 규칙 추가
- ✏️ `vibe/unit-plans/U-029[Mvp].md`: 완료 기준/아트 디렉션/구현 흐름/주의사항에 “순백 단색 배경” 강제 추가
- ✏️ `vibe/unit-plans/U-030[Mvp].md`: 최소 런북 절차에 “순백 단색 배경 생성” 추가
- ✏️ `vibe/unit-plans/U-031[Mvp].md`: (조건부) 오버레이/스티커 변형 시 “순백 단색 배경” 강제 추가
- ✏️ `vibe/unit-plans/U-032[Mvp].md`: 크롬 에셋 생성/배경 제거 전제에 “순백 단색 배경” 강제 추가
- ✏️ `vibe/unit-plans/U-033[Mvp].md`: QA 체크리스트에 “순백 단색 배경(조건부)” 항목 추가
- ✏️ `vibe/unit-plans/U-034[Mvp].md`: 템플릿 헤더/완료 기준에 “순백 단색 배경(조건부)” 규칙 추가

### 백로그 변경

**수정**:

- U-029/U-031/U-032/U-033/U-034: 배경 제거(rembg) 전제 시 “순백 단색 배경 생성” 규칙 추가

### 의존성 변경

- 없음

### 진행률 변화

- **MVP**: 32% (14/44) → 32% (14/44)
- **MMP**: 0% (0/13) → 0% (0/13)
- **전체**: 25% (14/57) → 25% (14/57)

### 품질 검증 결과

- **품질 기준 문서**: CP-MVP-01
- **수정된 유닛 계획서**: 6개(U-029, U-030, U-031, U-032, U-033, U-034) - 섹션 누락 없음, 상세도 유지/향상 ✅

### 주의사항

- “순백 단색 배경”은 **최종 결과 배경색**이 아니라, 배경 제거(rembg)를 위한 **원본 생성 단계 규칙**입니다(최종은 투명 PNG).
- 순백 배경에는 **그라데이션/텍스처/그림자**를 넣지 마세요(경계가 섞이면 제거 품질이 급락합니다).

---

## 2026-01-10 - roadmap-update/nanobanana-rembg-background-removal

### 변경 요약

`nanobanana mcp`로 생성한 UI 에셋 중 **투명 배경이 필요한 경우**, 결과에 배경이 남아 있으면 `rembg`로 배경 제거하도록 유닛 계획서/SSOT 문서를 동기화했습니다.  
(참조: `vibe/ref/rembg-guide.md`)

### 영향받은 문서

- ✏️ `vibe/prd.md`: 9.7 “UI 이미지 에셋 파이프라인(nanobanana mcp, Dev-only)”에 rembg 배경 제거(조건부) 규칙 추가
- ✏️ `vibe/roadmap.md`: 리스크 R-005 대응에 (필요 시) rembg 배경 제거 추가
- ✏️ `frontend/public/ui/README.md`: 에셋 워크플로우/체크리스트에 rembg 단계 추가(SSOT)
- ✏️ `vibe/unit-plans/U-029[Mvp].md`: 완료 기준/구현 흐름/주의사항에 rembg 배경 제거 절차 강제
- ✏️ `vibe/unit-plans/U-031[Mvp].md`: (조건부) 투명 오버레이/스티커형 산출물 필요 시 rembg 절차 추가
- ✏️ `vibe/unit-plans/U-032[Mvp].md`: (조건부) chrome 투명 PNG 필요 시 rembg 절차 추가
- ✏️ `vibe/unit-plans/U-033[Mvp].md`: QA 체크리스트에 투명도/배경 제거(rembg) 항목 추가
- ✏️ `vibe/unit-plans/U-034[Mvp].md`: 템플릿 사용 절차에 (필요 시) rembg 후처리 단계 추가
- ✏️ `vibe/unit-plans/U-030[Mvp].md`: 에셋 런북 절차에 (필요 시) rembg 단계 추가(최소 변경)

### 백로그 변경

**수정**:

- U-029[Mvp]: nanobanana mcp 에셋 패스(UI 아이콘/프레임/placeholder) - 투명 배경 필요 시 rembg 배경 제거 절차 강제
- U-031[Mvp]: nanobanana mcp 상태 Placeholder Pack - (조건부) rembg 절차 추가
- U-032[Mvp]: nanobanana mcp UI Chrome Pack - (조건부) rembg 절차 추가
- U-033[Mvp]: nanobanana mcp 에셋 매니페스트 + QA - QA에 rembg(투명도) 항목 추가
- U-034[Mvp]: nanobanana mcp 에셋 요청 스키마 + 템플릿 - 요청→생성→(필요 시 rembg)→저장→manifest→QA 절차 명시

### 의존성 변경

- 없음

### 진행률 변화

- **MVP**: 32% (14/44) → 32% (14/44)
- **MMP**: 0% (0/13) → 0% (0/13)
- **전체**: 25% (14/57) → 25% (14/57)

### 품질 검증 결과

- **품질 기준 문서**: CP-MVP-01
- **수정된 유닛 계획서**: 6개(U-029, U-030, U-031, U-032, U-033, U-034) - 섹션 누락 없음, 상세도 유지/향상 ✅

### 리스크 변경

**수정**:

- R-005: 에셋 품질/난립 리스크 대응에 (필요 시) rembg 배경 제거를 추가

### 주의사항

- `rembg` 모델 선택/옵션은 `vibe/ref/rembg-guide.md`를 준수합니다(특히 애니/일러스트 계열은 `isnet-anime` 권장).
- Windows 환경에서는 한글 경로를 피하고(영문 경로), 첫 실행 시 모델 다운로드가 발생할 수 있습니다.

---

## 2026-01-10 - roadmap-update/nanobanana-mcp-expansion

### 변경 요약

`nanobanana mcp`를 개발용 이미지 에셋 제작 도구의 **공식 용어(SSOT)** 로 고정하고,
에셋 제작/관리 계획을 “단일 유닛”에서 **SSOT/placeholder/chrome/매니페스트/템플릿**까지 전방위로 확장했습니다.  
또한 `.gemini/rules/red-line.md`를 추가해 **보안/용어/dev-only** 레드라인을 명문화했습니다.

### 영향받은 문서

- 🆕 `.gemini/rules/red-line.md`: `nanobanana mcp` 용어 SSOT, dev-only 사용, 비밀정보/프롬프트 노출 금지 규칙 추가
- ✏️ `vibe/prd.md`: 9.7 “UI 이미지 에셋 파이프라인(nanobanana mcp, Dev-only)” 섹션 추가 및 요구사항 명문화
- ✏️ `vibe/roadmap.md`: U-030~U-034 추가, U-029 Depends 갱신, 진행률/마일스톤/리스크(R-005) 동기화
- ✏️ `vibe/commands.md`: 업데이트 항목의 표기를 `nanobanana mcp`로 통일
- ✏️ `vibe/ref/standard-guide.md`: Creative Autopilot 문맥에서 `nanobanana mcp` 용어 사용으로 정합화
- ✏️ `vibe/unit-plans/U-029[Mvp].md`: Depends=U-030,U-028,U-008로 갱신 및 템플릿/매니페스트 연동 힌트 추가
- 🆕 `vibe/unit-plans/U-030[Mvp].md`: 에셋 SSOT(폴더/네이밍/예산/폴백/라이선스)
- 🆕 `vibe/unit-plans/U-031[Mvp].md`: 상태 placeholder pack(Scene/오프라인/에러/차단)
- 🆕 `vibe/unit-plans/U-032[Mvp].md`: UI chrome pack(패널/카드 프레임/코너)
- 🆕 `vibe/unit-plans/U-033[Mvp].md`: 에셋 매니페스트 + QA 체크리스트
- 🆕 `vibe/unit-plans/U-034[Mvp].md`: 에셋 요청 스키마 + 프롬프트 템플릿(재현성)

### 백로그 변경

**추가**:

- U-030[Mvp]: nanobanana mcp 에셋 SSOT(폴더/네이밍/사이즈/폴백/라이선스) - 에셋 규칙 단일화/난립 방지
- U-031[Mvp]: nanobanana mcp 상태 Placeholder Pack - 실패/지연을 UX로 흡수
- U-032[Mvp]: nanobanana mcp UI Chrome Pack - “게임 HUD” 인상 강화(과잉 적용 금지)
- U-033[Mvp]: nanobanana mcp 에셋 매니페스트 + QA - 사용처/예산/가독성 관리
- U-034[Mvp]: nanobanana mcp 에셋 요청 스키마 + 템플릿 - 일관성/재현성 확보

**수정**:

- U-029[Mvp]: Depends 변경 (이전: U-028,U-008 → 이후: U-030,U-028,U-008) - SSOT 선행 강제

### 진행률 변화

- **MVP**: 31% (12/39) → 27% (12/44)
- **MMP**: 0% (0/13) → 0% (0/13)
- **전체**: 23% (12/52) → 21% (12/57)

> 사유: 신규 유닛 5개 추가로 분모가 증가했습니다(완료 유닛 수는 동일).

### 품질 검증 결과

- **품질 기준 문서**: CP-MVP-01
- **신규 유닛 계획서**: 5개 생성(U-030~U-034) - 필수 섹션/완료 기준/의존성/리스크/페어링 질문 포함 ✅
- **수정된 문서**: PRD/로드맵/기존 유닛(U-029) - 섹션 누락 없음, 용어 SSOT 정합화 ✅

### 리스크 변경

**신규**:

- R-005: 에셋 난립/용량 비대화/스타일 불일치 - 영향: Medium - 대응: SSOT + 매니페스트/QA + 예산 상한

### 주의사항

- `nanobanana mcp`는 개발용 에셋 제작 도구로만 사용하며, 런타임 의존/비밀정보 커밋은 레드라인 위반입니다.

---

## 2026-01-10 - roadmap-update/ui-readability-nanobanana-assets

### 변경 요약

데모 UI의 “작은 글씨” 가독성 이슈를 해결하기 위한 MVP 유닛(U-028)과, nanobanana mcp를 활용해 필요한 UI 이미지 에셋을 제작/반영하는 MVP 유닛(U-029)을 백로그에 추가했습니다.  
또한 진행률 산정을 `vibe/unit-results/` 기반으로 고정하여 로드맵 대시보드/마일스톤/현재 작업 표시를 현실 값으로 동기화했습니다.

### 영향받은 문서

- ✏️ `vibe/roadmap.md`: U-028/U-029 추가, M2 카운트 조정, 가독성 리스크(R-004) 추가, 진행률/현재 작업 갱신
- ✏️ `vibe/prd.md`: 9.4 접근성/입력에 UI 스케일/Readable 모드 요구 추가, 9.6에 nanobanana mcp UI 에셋 활용 계획 명시
- 🆕 `vibe/unit-plans/U-028[Mvp].md`: UI 가독성 패스 계획서 생성
- 🆕 `vibe/unit-plans/U-029[Mvp].md`: nanobanana mcp UI 에셋 패스 계획서 생성

### 백로그 변경

**추가**:

- U-028[Mvp]: UI 가독성 패스(폰트 스케일/효과 토글/대비) - 작은 글씨로 인한 데모 체감 저하 방지
- U-029[Mvp]: nanobanana mcp 에셋 패스(UI 아이콘/프레임/placeholder) - 게임 UI 인상 강화(폴백 포함)

### 의존성 변경

- U-029[Mvp]: Depends=U-028,U-008 (Readable/스케일 및 Agent Console 연동 기반 위에서 에셋 반영)

### 진행률 변화

- **MVP**: 57% (21/37) → 31% (12/39)
- **MMP**: 0% (0/13) → 0% (0/13)
- **전체**: 42% (21/50) → 23% (12/52)

> 사유: 로드맵의 진행률 표기가 `unit-results`(완료 증거)와 불일치하여, 완료 유닛을 `vibe/unit-results/`에 존재하는 U/RU/CP로 고정해 재계산했습니다. 또한 신규 유닛 2개 추가로 분모가 증가했습니다.

### 품질 검증 결과

- **품질 기준 문서**: CP-MVP-01
- **신규 유닛 계획서**: 2개 생성(U-028, U-029) - 필수 섹션/완료 기준/의존성/리스크/페어링 질문 포함 ✅
- **수정된 문서**: PRD/로드맵 - 기존 섹션 유지, 정보량 감소 없음 ✅

### 리스크 변경

**신규**:

- R-004: 작은 글씨/과한 CRT 효과로 가독성 저하 - 영향: Medium - 대응: UI 스케일/Readable 모드 + 최소 글자 크기 가이드

### 주의사항

- U-029는 “에셋 제작/반영” 유닛이므로, 실제 이미지 파일 생성/커밋은 해당 유닛 수행 시점에 진행합니다(현재는 계획/규칙만 반영).

---

## 2026-01-04 - roadmap-update/http-streaming

### 변경 요약

기존 “SSE(EventSource) 기반 스트리밍” 전제를 제거하고, **HTTP Streaming (Fetch + POST) + NDJSON 이벤트 스트림**을 기본 스택으로 문서/유닛 계획서를 일괄 동기화했습니다.  
또한 `pnpm kill`이 `node.exe` 전체를 종료하는 문제를 해결하기 위한 MVP 유닛(U-027)을 백로그에 추가했습니다.

### 영향받은 문서

- ✏️ `vibe/prd.md`: 8.1/8.3/8.4의 스트리밍 스택을 HTTP Streaming으로 전환하고, NDJSON 이벤트 프로토콜(초안) 추가
- ✏️ `vibe/tech-stack.md`: Streaming/Reatime 항목을 HTTP Streaming으로 전환, 기술 선택 매트릭스/비교 섹션 동기화
- ✏️ `vibe/roadmap.md`: 진행률 재계산, U-027 추가, U-007/U-008 표기 변경, SSE 용어 정리
- ✏️ `vibe/architecture.md`: 백엔드 스트리밍 책임 표기 동기화
- ✏️ `.cursor/rules/20-backend-orchestrator.mdc`: 오케스트레이터 스트리밍 기본을 HTTP Streaming(Fetch+POST)로 전환
- ✏️ `vibe/unit-plans/*.md`: SSE 전제 제거 및 HTTP Streaming/NDJSON 기준으로 계획 동기화 (아래 목록 참조)

### 백로그 변경

**추가**:

- U-027[Mvp]: 개발 스크립트 - pnpm kill 포트 제한(8001~8020) - 다른 프로젝트 Node 프로세스 종료 방지

**수정**:

- U-007[Mvp]: `모의 Orchestrator + /api/turn SSE` → `모의 Orchestrator + /api/turn HTTP Streaming(POST)` - POST 입력(큰 TurnInput) 전제와 정합화
- U-008[Mvp]: `프론트 SSE 클라이언트` → `프론트 HTTP Streaming 클라이언트` - fetch+ReadableStream 기반 소비로 명확화
- RU-002[Mvp]: 이벤트/타입 통일 범위를 “SSE”에서 “NDJSON 스트림 이벤트”로 재정의
- U-024[Mvp]: `Action Queue SSE` → `Action Queue Streaming` - Autopilot 스트리밍도 동일 전제 유지
- CP-MVP-01 / CP-MMP-01: “SSE 스트리밍” 문구를 HTTP Streaming으로 교체(검증 기준 동일)

### 의존성 변경

- U-027[Mvp]: Depends=RU-001[Mvp] (포트 정책/kill:port SSOT 정리 이후 진행)

### 진행률 변화

- **MVP**: 33% → 19%
- **MMP**: 0% → 0%
- **전체**: 24% → 14%

> 사유: 완료 목록(unit-results 기준)과 진행률 표기가 불일치하여 **완료 유닛 7개 기준으로 재계산**했으며, 신규 유닛(U-027) 추가로 분모가 증가했습니다.

### 품질 검증 결과

- **품질 기준 문서**: U-006[Mvp]
- **신규 유닛 계획서**: 1개 생성(U-027) - 필수 섹션/완료 기준/의존성/리스크 포함 ✅
- **수정된 유닛 계획서**: 다수 - 섹션 누락 없이 “SSE → HTTP Streaming” 전제만 치환(상세도 유지/향상) ✅

### 리스크 변경

**신규**:

- R-004: 스트림 프로토콜(NDJSON) 파서/호환성 불안정 - 영향: Medium - 대응: RU-002에서 이벤트 타입/에러 처리/폴백 계약을 단일화

**해소(부분)**:

- R-???(암묵): EventSource(GET) 제약으로 TurnInput(큰 JSON) 전송이 어려운 설계 리스크 → HTTP Streaming(POST)로 구조적 해소

### 주의사항

- 과거 작성된 `unit-results/`, `unit-runbooks/` 일부에는 “SSE” 용어가 남아 있을 수 있습니다(역사적 기록). 이후 구현/런북 갱신 시점에 최신 스택 기준으로 정리하는 것을 권장합니다.

---
</file>

<file path="vibe/unit-plans/CP-MVP-01.md">
# CP-MVP-01: 체크포인트 - 스트리밍/스키마/폴백

## 메타데이터

| 항목      | 내용        |
| --------- | ----------- |
| Unit ID   | CP-MVP-01   |
| Phase     | MVP         |
| 예상 소요 | 45분        |
| 의존성    | RU-002[Mvp] |
| 우선순위  | ⚡ Critical |

## 작업 목표

초기 MVP 루프가 “항상 플레이 가능한 데모” 조건을 만족하는지, **스트리밍/검증/복구/폴백** 관점에서 수동 검증한다.

**배경**: PRD의 Hard Gate(스키마/경제/안전/일관성)는 “자동 복구 + 안전 폴백”까지 포함하며, 체크포인트로 조기에 깨짐을 잡아야 한다. (RULE-004)

**완료 기준**:

- HTTP Streaming으로 Queue/Badges가 먼저 보이고(TTFB 체감), 최종 TurnOutput이 UI에 반영된다. (RULE-008)
- TurnOutput 스키마 실패를 유도해도(모의 출력) Auto-repair 또는 safe fallback으로 종료되며, UI가 빈 화면이 되지 않는다. (RULE-004)
- 채팅 UI/프롬프트 노출/좌표 규약 위반이 없다. (RULE-002/008/009)

## 영향받는 파일

**생성**:

- (구현 후 기록) `vibe/unit-results/CP-MVP-01.md` - 체크포인트 결과/스크린샷/관측값 기록
- (선택) `vibe/unit-runbooks/CP-MVP-01.md` - 재현 가능한 수동 검증 런북

**수정**:

- 없음(검증 단계)

**참조**:

- `vibe/prd.md` - Hard Gate, TTFB 목표, 데모 표면 요구
- `vibe/roadmap.md` - 백로그/의존성 기준
- `.cursor/rules/00-core-critical.mdc` - RULE-002/003/004/008/009

## 구현 흐름

### 1단계: 기본 데모 시나리오(성공 경로)

- 백엔드/프론트를 로컬에서 실행한다.
- 텍스트 입력으로 1턴 실행 → Agent Console에 단계(Parse→…→Commit) 진행이 보이는지 확인한다.
- 최종 TurnOutput이 Zod 검증을 통과하고, Action Deck/Hotspot 등 최소 UI 데이터가 렌더되는지 확인한다.

### 2단계: 실패/복구 시나리오(스키마/룰 실패)

- 모의 Orchestrator에서 “의도적으로 스키마 실패”가 나오도록 토글/테스트 훅을 사용한다(구현 방식은 팀 합의).
- 실패 시:
  - Auto-repair #n 이벤트가 보이는지(또는 명시적 폴백) 확인
  - 최종적으로 safe fallback TurnOutput이 표시되는지 확인

### 3단계: 금지사항/인바리언트 체크

- 채팅 버블 UI가 없는지 확인한다. (RULE-002)
- 프롬프트 원문/내부 추론이 UI/콘솔에 노출되지 않는지 확인한다. (RULE-008)
- bbox가 0~1000 정규화 + `[ymin,xmin,ymax,xmax]` 순서로 처리되는지 확인한다. (RULE-009)

## 의존성 & 연결

**이전 작업에서 가져올 것**:

- **계획서**: [RU-002[Mvp]](RU-002[Mvp].md) - 이벤트 계약/폴백 흐름 정리
- **결과물**: (추후) `{vibe/unit-results}/RU-002[Mvp].md`에 이벤트 계약 요약이 있으면 참조

**다음 작업에 전달할 것**:

- U-009~U-012에서 클릭/드래그 같은 상호작용을 얹기 위한 “안정적인 스트리밍 루프”
- 체크포인트 결과(증거/관측값)가 이후 데모 회귀 기준선이 된다

## 주의사항

**기술적 고려사항**:

- “성공 경로”만 보지 말고, 반드시 실패/복구 경로를 확인한다(Repair loop/폴백이 핵심 기능). (RULE-004)

**잠재적 리스크**:

- 실패 경로를 테스트할 훅이 없으면 회귀를 잡기 어려움 → 모의 Orchestrator에 “의도적 실패” 옵션을 넣는 것을 권장한다.

## 페어링 질문 (결정 필요)

- [ ] **Q1**: 체크포인트 런북/결과를 어디에 SSOT로 둘까?
  - Option A: `vibe/unit-runbooks/CP-MVP-01.md`에 재현 절차, `vibe/unit-results/CP-MVP-01.md`에 결과/증거
  - Option B: 결과 문서(unit-results)에 런북까지 포함(파일 수는 줄지만 절차/결과가 섞임)
  **A1**: Option A

## 참고 자료

- `vibe/prd.md` - Hard Gate, Demo Mode, TTFB 목표
- `.cursor/rules/00-core-critical.mdc` - RULE-002/003/004/008/009
</file>

<file path="vibe/unit-plans/RU-001[Mvp].md">
# RU-001[Mvp]: 리팩토링 - 디렉토리/설정 정리

## 메타데이터

| 항목      | 내용        |
| --------- | ----------- |
| Unit ID   | RU-001[Mvp] |
| Phase     | MVP         |
| 예상 소요 | 45분        |
| 의존성    | U-004,U-003 |
| 우선순위  | High        |

## 작업 목표

스캐폴딩 단계에서 생기기 쉬운 “경로/버전/실행 방식의 흔들림”을 제거하고, 이후 유닛들이 **SSOT(tech-stack)와 규칙(RULE-001~010)** 을 위반하지 않도록 기준선을 정리한다.

**배경**: 초기에 기준을 안 잡으면 이후 유닛마다 같은 설정 문제로 시간이 소모되고, 데모 반복성이 무너진다. (참조: `vibe/prd.md` 10장)

**완료 기준**:

- 프론트/백엔드의 “실행 방법(명령/포트)”과 “버전 고정 원칙”이 로드맵/유닛 계획서와 모순 없이 정리된다.
- 채팅 UI 금지/단일 CSS/좌표 규약/보안 원칙이 초기 스캐폴딩에 반영된다. (RULE-002/007/009)
- 다음 유닛(U-005~U-008)이 스키마/스트리밍 구현에 집중할 수 있도록 파일/폴더 구조가 명확해진다.

## 영향받는 파일

**생성**:

- (선택) `frontend/README.md` - 프론트 실행/규칙 요약(프롬프트/키 노출 금지 포함)
- (선택) `backend/README.md` - 백엔드 실행/보안 요약(서비스계정, BYOK 금지 포함)

**수정**:

- `vibe/roadmap.md` - “빠른 실행” 커맨드가 실제 구조와 맞는지 점검/정리(필요 시)

**참조**:

- `vibe/tech-stack.md` - 버전/모델 ID 고정
- `.cursor/rules/00-core-critical.mdc` - RULE-001~010
- `.cursor/rules/10-frontend-game-ui.mdc` - 단일 CSS/고정 UI
- `.cursor/rules/20-backend-orchestrator.mdc` - HTTP Streaming/검증/복구

## 구현 흐름

### 1단계: 구조/명명 규칙 정리

- `frontend/`, `backend/` 디렉토리 구조(특히 백엔드 패키지 루트)를 확정한다.
- 앞으로의 유닛 계획서에서 사용할 경로 표기 규칙을 통일한다.

### 2단계: 버전/실행 방식 정합성 점검

- `vibe/tech-stack.md` 버전과 스캐폴딩(패키지/requirements) 간 불일치를 제거한다. (RULE-010)
- 로컬 실행 커맨드를 팀 표준으로 합의하고, 로드맵의 “빠른 실행”과 맞춘다.

### 3단계: “금지사항”이 구조로 강제되게 만들기

- 채팅 UI로 회귀할 여지가 있는 레이아웃/컴포넌트 네이밍을 피한다(예: Chat*, Message*).
- 비밀정보가 실수로 포함되지 않도록 가이드/ignore 정책을 준비한다(키 파일 경로 명시 금지).

## 의존성 & 연결

**이전 작업에서 가져올 것**:

- **계획서**: [U-003[Mvp]](U-003[Mvp].md) - 백엔드 초기 구조/실행
- **계획서**: [U-004[Mvp]](U-004[Mvp].md) - 프론트 고정 레이아웃/스타일 기준

**다음 작업에 전달할 것**:

- U-005~U-008에서 사용할 공통 경로/명명 규칙
- 이후 리팩토링(RU) 단위의 기준(“정리 vs 기능 추가” 경계)

## 주의사항

**기술적 고려사항**:

- (RULE-010) “최신이라서” 업그레이드 금지: tech-stack SSOT 준수.
- (RULE-007) 서비스 계정 키/토큰/쿠키/프롬프트 원문을 레포/로그/UI에 노출 금지.

**잠재적 리스크**:

- 표준을 지나치게 많이 도입하면 초기 속도가 떨어짐 → “필수 금지사항/버전 고정/실행 방법”만 최소로 합의한다.

## 페어링 질문 (결정 필요)

- [ ] **Q1**: 프론트/백엔드의 공통 스키마(타입) SSOT를 어떻게 둘까?
  - Option A: MVP는 서버(Pydantic)·클라(Zod) 중복 정의(빠르게), 이후 MMP에서 통합
  - Option B: 초기부터 `shared/` JSON Schema 파일을 SSOT로 두고 생성/검증 자동화
  **A1**: Option B

## 참고 자료

- `vibe/tech-stack.md` - 버전/모델 라인업 고정
- `.cursor/rules/00-core-critical.mdc` - 핵심 금지사항/하드 게이트
</file>

<file path="vibe/unit-plans/RU-002[Mvp].md">
# RU-002[Mvp]: 리팩토링 - validation/폴백/이벤트 타입 통일

## 메타데이터

| 항목      | 내용        |
| --------- | ----------- |
| Unit ID   | RU-002[Mvp] |
| Phase     | MVP         |
| 예상 소요 | 45분        |
| 의존성    | U-008       |
| 우선순위  | High        |

## 작업 목표

스트림 이벤트(NDJSON)/검증/폴백이 분산되어 생기는 불일치를 정리하고, “스키마/경제/안전” 실패가 발생해도 일관된 방식으로 **표시/복구/폴백** 되도록 타입과 흐름을 통일한다.

**배경**: 스트리밍/검증/복구는 MVP 하드 게이트이며, 작은 불일치가 데모에서 “멈춤/깨짐”으로 보인다. (RULE-004/008)

**완료 기준**:

- 서버가 내보내는 스트림 이벤트 타입/페이로드 형태가 단일 계약으로 정리된다.
- 클라이언트 파서/상태/표시 로직이 그 계약을 1:1로 따르고, 실패 시 폴백 TurnOutput으로 종료된다. (RULE-004)
- stage 이름/순서(Parse→…→Commit)와 Badges(Schema/Economy/Safety/Consistency)가 UI/백엔드에서 동일 용어로 유지된다. (RULE-008)

## 영향받는 파일

**생성**:

- (권장) `backend/src/unknown_world/api/turn_stream_events.py` - Turn 스트림 이벤트 스키마/생성 유틸(서버)
- (권장) `frontend/src/types/turn_stream.ts` - Turn 스트림 이벤트 타입/디코더(클라)

**수정**:

- `backend/src/unknown_world/api/turn.py` - 이벤트 생성/에러 처리 통일(필요 시)
- `frontend/src/api/turnStream.ts` - 파서/에러 처리 통일(필요 시)

**참조**:

- `.cursor/rules/00-core-critical.mdc` - RULE-004/005/008
- `vibe/prd.md` 6.8/10장 - 단계/배지/Auto-repair UX

## 구현 흐름

### 1단계: 이벤트 계약을 “단일 정의”로 정리

- 이벤트 타입 목록과 각 이벤트의 필수/옵션 필드를 문서화한다.
- `final` 이벤트에는 “검증된 TurnOutput”만 포함한다(검증 실패 시에는 폴백 TurnOutput을 final로 보냄).

### 2단계: 서버/클라 에러 처리 규칙 통일

- 스키마 실패/비즈니스 룰 실패 시: `Auto-repair #n` 이벤트 → 재시도 → (최대 N회) → 폴백 final
- 네트워크/타임아웃/서버 에러 시: 사용자에게 “안전 진행(텍스트-only)”로 안내하고 UI는 유지

### 3단계: 용어/라벨 정합성 검증

- Badges 라벨(FAST/QUALITY 등), 하드 게이트 배지 키, stage 이름이 문서/코드/로드맵에서 일치하는지 확인한다.

## 의존성 & 연결

**이전 작업에서 가져올 것**:

- **계획서**: [U-007[Mvp]](U-007[Mvp].md) - 서버 HTTP Streaming/모의 Orchestrator
- **계획서**: [U-008[Mvp]](U-008[Mvp].md) - 클라 스트림 파서/Agent Console 렌더

**다음 작업에 전달할 것**:

- CP-MVP-01에서 “스트리밍/스키마/폴백”을 안정적으로 검증할 일관된 이벤트 계약
- 이후 실모델 연동(U-016~U-018) 시에도 그대로 재사용 가능한 복구/폴백 흐름

## 주의사항

**기술적 고려사항**:

- (RULE-008) 관측은 “프롬프트 노출 없이” 수행: 이벤트에는 프롬프트 원문/내부 추론을 포함하지 않는다.
- (RULE-005) Economy는 서버에서 Hard gate: 클라이언트가 임의로 잔액을 음수로 표시/진행하지 않게 한다.

**잠재적 리스크**:

- 계약을 너무 자주 바꾸면 프론트/백이 계속 깨짐 → MVP에서는 최소 이벤트 타입으로 고정하고, 확장은 MMP에서 한다.

## 페어링 질문 (결정 필요)

- [ ] **Q1**: stage 목록/표시 라벨은 어디를 SSOT로 둘까?
  - Option A: 서버 SSOT(서버가 stage 목록을 포함해 스트림으로 제공)
  - Option B: 클라 SSOT(클라에 stage 고정 리스트를 두고 서버 이벤트를 매핑)
  **A1**: 뭐가 나은지 모르겠다. 권장되는 옵션으로 알아서

## 참고 자료

- `vibe/prd.md` - Agent Console/Auto-repair/Badges 요구
- `.cursor/rules/00-core-critical.mdc` - RULE-004/005/008
</file>

<file path="vibe/unit-plans/U-006[Mvp].md">
# U-006[Mvp]: TurnInput/TurnOutput 스키마(Zod)

## 메타데이터

| 항목      | 내용        |
| --------- | ----------- |
| Unit ID   | U-006[Mvp]  |
| Phase     | MVP         |
| 예상 소요 | 60분        |
| 의존성    | U-002       |
| 우선순위  | ⚡ Critical |

## 작업 목표

프론트에서 TurnOutput을 렌더링하기 전에 **Zod로 strict 검증**하고, 실패 시에도 UI가 멈추지 않도록 **안전 폴백 경로**를 마련한다.

**배경**: “JSON처럼 보이는 텍스트”를 대충 파싱하면 UI/경제/안전 인바리언트가 깨진다. 클라이언트 검증은 Hard Gate의 일부다. (RULE-003)

**완료 기준**:

- TurnInput/TurnOutput Zod 스키마가 정의되고 `strict` 파싱을 수행한다.
- 스키마 실패 시에도 사용자에게 “Auto-repair/폴백” 상태를 보여주며, 최소 UI(로그/패널 자리)는 유지된다. (RULE-004/008)
- bbox/핫스팟 좌표 규약(0~1000, `[ymin,xmin,ymax,xmax]`)을 Zod 레벨에서 검증한다. (RULE-009)

## 영향받는 파일

**생성**:

- `frontend/src/schemas/turn.ts` - TurnInput/TurnOutput Zod 스키마 정의
- `frontend/src/schemas/index.ts` - 스키마 export(선택)

**수정**:

- 없음(실제 연결은 U-008에서 수행)

**참조**:

- `vibe/prd.md` 8.7 - TurnInput/TurnOutput 필드 방향
- `vibe/tech-stack.md` - Zod 버전 고정
- `.cursor/rules/00-core-critical.mdc` - RULE-003/004/006/009

## 구현 흐름

### 1단계: 서버(Pydantic) 스키마와 1:1 정합성 확보

- U-005에서 정의한 필드 구조를 기준으로 Zod 스키마를 설계한다(용어/키 이름 불일치 금지).
- enum/required 구조를 최대한 동일하게 맞춘다.

### 2단계: strict parse + 폴백 전략 정의

- `parse()` 실패 시 UI에 표시할 “안전 폴백 TurnOutput”의 최소 형태를 정의한다.
- 실패는 숨기지 않고 Agent Console에 `Schema FAIL → Auto-repair` 같은 상태로 노출한다(프롬프트 원문/CoT는 제외). (RULE-008)

### 3단계: 좌표/언어/경제 인바리언트 검증 훅 준비

- bbox 배열 길이/순서/범위를 검증한다(0~1000).
- `language`는 `"ko-KR" | "en-US"`로 고정하고 혼합 출력이 UI에 섞이지 않도록 기준을 둔다. (RULE-006)

## 의존성 & 연결

**이전 작업에서 가져올 것**:

- **계획서**: [U-002[Mvp]](U-002[Mvp].md) - TypeScript 기반 프론트 실행 환경
- **계획서**: [U-005[Mvp]](U-005[Mvp].md) - 서버 스키마 구조(정합성 기준)

**다음 작업에 전달할 것**:

- U-008에서 스트림(final) payload를 렌더링하기 전, Zod 검증/폴백을 적용할 수 있는 스키마/헬퍼

## 주의사항

**기술적 고려사항**:

- (RULE-006) UI 문자열 하드코딩을 최소화하고, language 정책과 충돌하지 않게 한다(본격 i18n은 이후 유닛에서).
- (RULE-004) 폴백도 “스키마 준수”를 목표로 하되, 최악의 경우에도 UI가 비지 않게 최소 패널을 유지한다.

**잠재적 리스크**:

- 서버/클라 스키마가 드리프트하면 repair 비용/디버깅 비용이 폭증 → RU-002/RU-010에서 “SSOT 강화”를 계획한다.

## 페어링 질문 (결정 필요)

- [ ] **Q1**: TurnOutput에 `schema_version`을 포함할까?
  - Option A: 포함한다(권장: SaveGame/마이그레이션/검증에 유리)
  - Option B: 포함하지 않는다(초기 단순, 대신 앱 버전으로 관리)
  **A1**: Option A

## 참고 자료

- `vibe/prd.md` - Turn 계약/언어/좌표 규약
- `vibe/tech-stack.md` - Zod 버전 고정
- `.cursor/rules/00-core-critical.mdc` - RULE-003/004/006/009
</file>

<file path="vibe/unit-plans/U-008[Mvp].md">
# U-008[Mvp]: 프론트 HTTP Streaming 클라이언트 + Agent Console/배지

## 메타데이터

| 항목      | 내용        |
| --------- | ----------- |
| Unit ID   | U-008[Mvp]  |
| Phase     | MVP         |
| 예상 소요 | 75분        |
| 의존성    | U-006,U-007 |
| 우선순위  | ⚡ Critical |

## 작업 목표

프론트에서 `/api/turn` **HTTP Streaming 응답 스트림**을 소비해 **단계(Queue)/배지(Badges)/Auto-repair 트레이스**를 실시간으로 보여주고, 최종 TurnOutput을 Zod 검증 후 UI에 반영한다.

**배경**: “에이전트형 시스템”을 증명하려면 결과만이 아니라 과정(단계/검증/복구)이 UI로 보여야 한다. 단, 프롬프트 원문/내부 추론은 노출 금지다. (RULE-008)

**완료 기준**:

- 사용자가 입력(텍스트, 이후 클릭/드래그로 확장)을 보내면, Agent Console에 Parse→…→Commit 진행이 스트리밍으로 표시된다.
- 최종 TurnOutput이 Zod strict parse를 통과한 경우에만 상태/UI가 업데이트된다. 실패 시 안전 폴백 UI로 복구한다. (RULE-003/004)
- UI 어디에도 프롬프트 원문/내부 추론이 노출되지 않는다(메타 라벨만). (RULE-008)

## 영향받는 파일

**생성**:

- `frontend/src/api/turnStream.ts` - fetch 기반 HTTP Streaming(POST) 클라이언트 + NDJSON 이벤트 파서
- `frontend/src/stores/agentStore.ts` - queue/badges/repair 상태 저장(Zustand 권장)
- `frontend/src/components/AgentConsole.tsx` - Plan/Queue/Badges/Auto-repair 렌더

**수정**:

- `frontend/src/App.tsx` - 입력 → turn 실행 → 스트림 구독 → 상태 반영

**참조**:

- `vibe/prd.md` 6.8/10장 - 단계/배지/복구/TTFB
- `.cursor/rules/10-frontend-game-ui.mdc` - Agent Console 상시 노출
- `.cursor/rules/00-core-critical.mdc` - RULE-003/004/008

## 구현 흐름

### 1단계: 스트림 소비 방식 확정(fetch+ReadableStream)

- `/api/turn`이 POST 기반이므로 `EventSource(GET)` 대신 fetch 스트리밍으로 NDJSON 이벤트를 파싱한다.
- 최소 이벤트(`stage`, `badges`, `narrative_delta`, `final`, `error`)를 처리하는 파서를 만든다.

### 2단계: Agent Console 상태/렌더 연결

- stage 이벤트를 수신할 때마다 queue 항목의 상태를 갱신한다(예: start/ok/fail).
- 배지(Schema/Economy/Safety/Consistency) 상태를 시각적으로 표시한다.
- Auto-repair가 발생하면 횟수/결과만 표시한다(프롬프트 원문/CoT는 제외). (RULE-008)

### 3단계: final TurnOutput 검증 후 UI 반영

- `final` 이벤트 payload를 Zod로 strict parse한다. (U-006)
- 실패 시: “안전 폴백 TurnOutput”을 적용하고, 사용자에게 복구 상태를 표시한다. (RULE-004)

## 의존성 & 연결

**이전 작업에서 가져올 것**:

- **계획서**: [U-006[Mvp]](U-006[Mvp].md) - Zod 스키마/폴백 전략
- **계획서**: [U-007[Mvp]](U-007[Mvp].md) - 스트림 이벤트 계약/모의 Orchestrator
- **계획서**: [U-004[Mvp]](U-004[Mvp].md) - 고정 HUD 레이아웃(Agent Console 자리)

**다음 작업에 전달할 것**:

- CP-MVP-01에서 검증할 “스트리밍 + 스키마 + 폴백” 루프
- U-009~U-012에서 액션덱/핫스팟/DnD 실행을 TurnInput으로 연결할 기반

## 주의사항

**기술적 고려사항**:

- (RULE-008) Agent Console은 “단계/배지/복구”만 보여준다(프롬프트/내부추론 노출 금지).
- 스트림 파서는 오류에 강해야 하며, 중간 청크 파싱 실패가 전체 UI를 멈추지 않게 한다.

**잠재적 리스크**:

- fetch 스트리밍 NDJSON 파싱이 브라우저별로 까다로울 수 있음 → 최소 파서로 시작하고, RU-002에서 타입/에러 처리를 정리한다.

## 페어링 질문 (결정 필요)

- [ ] **Q1**: 스트림(NDJSON) 파서는 직접 구현할까, 경량 라이브러리를 쓸까?
  - Option A: 직접 구현(권장: 의존성 최소, 동작 투명)
  - Option B: 라이브러리 사용(초기 빠르지만 유지보수/버전 리스크)
  **A1**: Option A

## 참고 자료

- `vibe/prd.md` - Queue/Badges/Auto-repair UX
- `.cursor/rules/10-frontend-game-ui.mdc` - Agent Console 상시 노출
- `.cursor/rules/00-core-critical.mdc` - RULE-003/004/008
</file>

<file path="vibe/unit-plans/U-017[Mvp].md">
# U-017[Mvp]: Structured Output TurnOutput 생성 + Pydantic 검증

## 메타데이터

| 항목      | 내용        |
| --------- | ----------- |
| Unit ID   | U-017[Mvp]  |
| Phase     | MVP         |
| 예상 소요 | 75분        |
| 의존성    | U-016,U-005 |
| 우선순위  | ⚡ Critical |

## 작업 목표

Gemini 텍스트 모델을 **Structured Outputs(JSON Schema)** 모드로 호출해 TurnOutput을 생성하고, 서버에서 **Pydantic 검증**을 통과한 결과만 다음 단계로 전달한다.

**배경**: TurnOutput은 “파싱 가능한 계약”이며, 스키마 강제 + 서버 검증이 기본값이다. (RULE-003)

**완료 기준**:

- Gemini 호출 시 `response_mime_type=application/json` + `response_json_schema`(TurnOutput schema)를 사용한다.
- 모델 응답 텍스트를 Pydantic으로 `model_validate_json` 검증하고, 실패는 즉시 “복구 대상”으로 분류한다(U-018).
- `language` 정책(입력 언어 고정)이 프롬프트/검증 흐름에 반영된다. (RULE-006)

## 영향받는 파일

**생성**:

- `backend/src/unknown_world/orchestrator/generate_turn_output.py` - 모델 호출/응답 파싱/검증 단계
- `backend/prompts/system/game_master.ko.md` - (초기) 시스템 프롬프트(ko)
- `backend/prompts/system/game_master.en.md` - (초기) 시스템 프롬프트(en)
- `backend/prompts/turn/turn_output_instructions.ko.md` - (초기) 출력 계약 지시(ko)
- `backend/prompts/turn/turn_output_instructions.en.md` - (초기) 출력 계약 지시(en)

**수정**:

- `backend/src/unknown_world/api/turn.py` - (선택) 모의 Orchestrator 대신 실모델 경로 연결(기능 플래그 권장)

**참조**:

- `vibe/prd.md` 3.2/8.4 - 프롬프트 파일 관리/Structured Outputs
- `.cursor/rules/30-prompts-i18n.mdc` - 프롬프트 파일 메타/언어 분리 규칙
- `.cursor/rules/00-core-critical.mdc` - RULE-003/006/007/010

## 구현 흐름

### 1단계: 프롬프트 파일 로딩(ko/en 분리) 최소 구현

- 언어별 프롬프트를 파일에서 읽어온다(코드 하드코딩 금지).
- 프롬프트에는 최소한 “출력은 TurnOutput 스키마를 반드시 만족”과 “language 고정”을 명시한다.

### 2단계: Structured Outputs 호출 구성

- 모델 라벨(FAST/QUALITY) 선택 정책을 정하고(기본값 포함), 호출 config에 스키마를 연결한다.
- 스트리밍 여부(모델)는 U-007/U-008의 **HTTP Streaming(NDJSON 이벤트) 계약**과 정합되게 설계한다(초기엔 모델 비스트리밍이어도, 서버는 stage/badges/final을 스트림으로 보낼 수 있다).

### 3단계: 서버 검증(Pydantic)과 실패 분기

- 응답을 Pydantic으로 검증한다.
- 실패 시: “스키마 실패”로 분류해 U-018의 repair/fallback 흐름으로 넘길 수 있도록 실패 정보를 구조화한다(프롬프트 원문은 포함 금지). (RULE-008)

## 의존성 & 연결

**이전 작업에서 가져올 것**:

- **계획서**: [U-016[Mvp]](U-016[Mvp].md) - Vertex 인증/모델 라벨 고정
- **계획서**: [U-005[Mvp]](U-005[Mvp].md) - TurnOutput 스키마(Pydantic/JSON Schema)

**다음 작업에 전달할 것**:

- U-018에서 비즈니스 룰 검증 + repair loop를 수행할 "스키마 검증된(또는 실패한) 결과/에러 정보"
- U-036에서 프롬프트 파일 분리/핫리로드를 위한 최소 로딩 구조 기반
- RU-005에서 정리할 orchestrator stage 중 "Resolve/Render"의 핵심 생성 단계

## 주의사항

**기술적 고려사항**:

- (RULE-007) 프롬프트 원문/내부 추론을 UI/스트림 응답에 노출하지 않는다(메타만).
- (RULE-010) 모델 ID는 tech-stack SSOT로 고정하고, 이미지 모델은 혼용 금지.

**잠재적 리스크**:

- 프롬프트/스키마 불일치로 실패율이 높을 수 있음 → `.cursor/rules/30-prompts-i18n.mdc`의 “정합” 규칙을 따라 프롬프트를 짧고 명확하게 유지한다.

## 페어링 질문 (결정 필요)

- [ ] **Q1**: 기본 텍스트 생성 모델 라벨은 무엇으로 둘까?
  - Option A: FAST 기본(권장: 데모 TTFB 우선) + 중요 장면만 QUALITY
  - Option B: QUALITY 기본(품질 우선, 비용/지연 증가)

## 참고 자료

- `vibe/prd.md` - 프롬프트 파일 관리/Structured Outputs
- `.cursor/rules/30-prompts-i18n.mdc` - 프롬프트 언어 분리/메타 규칙
- `.cursor/rules/00-core-critical.mdc` - RULE-003/006/007/010
</file>

<file path="vibe/unit-plans/U-029[Mvp].md">
# U-029[Mvp]: nanobanana mcp 에셋 패스(UI 아이콘/프레임/placeholder)

## 메타데이터

| 항목      | 내용        |
| --------- | ----------- |
| Unit ID   | U-029[Mvp]  |
| Phase     | MVP         |
| 예상 소요 | 60분        |
| 의존성    | U-030,U-028,U-008,U-034 |
| 우선순위  | Medium      |

## 작업 목표

UI에서 “텍스트/이모지”만으로 표현되던 요소 중 **에셋이 효과적인 지점**(아이콘/프레임/placeholder)을 선별해, **nanobanana mcp로 제작한 이미지 에셋을 1차 반영**한다. (가이드 준수: `vibe/ref/nanobanana-mcp.md`)

**배경**: Unknown World는 “채팅 앱이 아닌 게임 UI” 인상이 중요하다. (PRD 6.7) 작은 아이콘/패널 프레임/placeholder 같은 시각 요소가 있으면, 데모에서 **게임성(UX)과 몰입감**이 즉시 상승한다. 다만, 에셋이 가독성/성능/번들 크기를 해치면 역효과이므로 “필요한 곳만, 작게, 폴백 포함”이 원칙이다.

**완료 기준**:

- 최소 6개 이상의 UI 에셋(예: Signal/Shard/Risk/Badge/Panel/Placeholder)을 **일관된 스타일**로 제작하고, repo에 추가된다.
- (필수 조건부) 아이콘/프레임처럼 **투명 배경(알파)이 필요한 에셋**은, 생성 결과에 배경이 남아 있으면 `rembg`로 배경 제거를 수행해 투명 PNG로 저장된다. (가이드 준수: `vibe/ref/rembg-guide.md`)
- (필수 조건부) 배경 제거(rembg)를 전제하는 에셋은 **원본 생성 단계에서 배경을 순백(#FFFFFF) 단색**으로 만들도록 강하게 지시한다(그라데이션/텍스처/그림자 금지) → rembg 품질/재현성/속도 향상.
- UI에서 해당 에셋이 실제로 사용되며, 로딩 실패/미지원 시 **텍스트/이모지 폴백**이 동작한다.
- 에셋 파일명/사이즈/저장 경로 규칙(SSOT, U-030)이 문서화되고, “추가 에셋 요청 → 제작/반영” 흐름이 명확해진다.
- (권장) 추가/수정한 에셋은 `frontend/public/ui/manifest.json`(U-033)로 추적 가능하게 기록된다.

## 영향받는 파일

**생성**:

- `frontend/public/ui/` - UI 아이콘/프레임/placeholder PNG(WebP는 선택)
- (권장) `frontend/public/ui/README.md` - 에셋 규칙(네이밍/사이즈/스타일/폴백) 요약

**수정**:

- `frontend/src/style.css` - 아이콘/프레임 적용을 위한 CSS(`background-image`, `image-set`, 크기 토큰) 추가
- `frontend/src/App.tsx` - Header/Economy HUD/Action Deck 등에서 아이콘 사용(필요한 최소 지점만)
- (선택) `frontend/src/components/AgentConsole.tsx` - 배지/상태 아이콘에 에셋을 쓰는 경우

**참조**:

- `vibe/ref/nanobanana-mcp.md` - nanobanana mcp 에셋 제작 가이드(SSOT)
- `vibe/ref/frontend-style-guide.md` - CRT 테마 톤(레트로/인광/스캔라인과 조화)
- `frontend/public/logo-retro.png` - 기존 레포 에셋(톤 참조)
- `vibe/prd.md` 6.7/9장 - “채팅 UI 금지 + 게임스러운 고정 HUD”

## 구현 흐름

### 1단계: “에셋이 필요한 지점” 목록 확정

- 텍스트만으로 부족하거나 “게임성”을 높이는 지점을 우선한다:
  - Economy HUD: Signal/Shard 아이콘(기존 ⚡/💎)
  - Action Deck: Risk 아이콘/카드 프레임(기존 ⚠)
  - Badges: OK/FAIL 상태 아이콘(텍스트 폴백 유지)
  - Scene Placeholder: 분위기 있는 placeholder 이미지(텍스트 유지)

### 2단계: 아트 디렉션/사이즈/네이밍 규칙 정의(SSOT)

- 스타일: CRT 레트로/픽셀 느낌, 제한된 팔레트(그린/마젠타/오렌지/레드)
  - 최종 산출물: 투명 PNG(아이콘/프레임/크롬 등 알파 필요)
  - (필수 조건부) 배경 제거(rembg) 예정: **원본 생성 시 배경은 순백(#FFFFFF) 단색**으로 강제(그라데이션/텍스처/그림자 금지)
- 권장 사이즈: 16/24/32/64(최소 2종), 필요 시 `image-set()`으로 1x/2x 제공
- 네이밍 예시: `signal-24.png`, `shard-24.png`, `risk-low-24.png`, `badge-ok-16.png`
  - (SSOT) 상세 규칙은 [U-030[Mvp]](U-030[Mvp].md) 기준을 따른다.

### 3단계: nanobanana mcp로 에셋 제작

- 동일한 스타일을 유지하기 위해 “공통 스타일 문장 + 개별 대상” 프롬프트를 재사용한다.
- (필수 조건부) 배경 제거(rembg)가 필요하면, 프롬프트에 **“solid white background (#FFFFFF), no gradient/texture/shadow”**를 명시해 원본 배경을 단순화한다.
- 작은 크기에서도 읽히는지(엣지/대비/형태)를 우선 확인하고, 필요 시 1회 정도 수정(edit)한다.
  - (권장) 템플릿/요청 스키마는 [U-034[Mvp]](U-034[Mvp].md) 기준을 따른다.

### 4단계: (필수 조건부) rembg로 배경 제거(투명 PNG가 필요한 경우)

- 아이콘/프레임/크롬 등 **투명 배경이 필요한 에셋**에서 배경이 남아 있으면, `rembg`로 배경을 제거해 알파 채널을 확보한다.
- (권장) rembg 품질/속도를 위해, 원본 생성 단계에서 배경을 **순백(#FFFFFF) 단색**으로 만들어 두는 것을 기본으로 한다(그라데이션/텍스처 금지).
- 모델 선택/옵션은 `vibe/ref/rembg-guide.md`의 “모델 자동 선택 규칙/Alpha Matting 기준”을 따른다.
  - (권장) 본 유닛의 아이콘/일러스트 계열은 기본적으로 `isnet-anime` 계열이 잘 맞는 편이다.
- 출력 파일명은 가이드의 권장 규칙을 따른다(예: `*_transparent.png` 또는 `*_nobg.png`). 필요 시 최종 네이밍(SSOT) 규칙에 맞춰 정리한다.

### 5단계: UI 반영(폴백 우선)

- CSS/컴포넌트에서 에셋을 적용하되, 항상 텍스트/이모지 폴백을 유지한다.
- Readable 모드(U-028)에서는 아이콘 대비/크기를 함께 조정할 수 있게 연결한다(선택).

## 의존성 & 연결

**이전 작업에서 가져올 것**:

- **계획서**: [U-030[Mvp]](U-030[Mvp].md) - 에셋 SSOT(경로/네이밍/예산/폴백)
- **계획서**: [U-028[Mvp]](U-028[Mvp].md) - UI 스케일/Readable 모드(아이콘 ‘읽힘’ 기준선)
- **계획서**: [U-008[Mvp]](U-008[Mvp].md) - Agent Console 배지/상태 표시(아이콘 적용 후보)

**다음 작업에 전달할 것**:

- U-009~U-015에서 재사용할 UI 에셋 세트(경로/네이밍/사이즈 규칙 포함)
- “에셋이 없을 때도 동작”하는 폴백 패턴(데모 안전성)

## 주의사항

**기술적 고려사항**:

- 에셋은 **필요한 곳만** 적용한다(과도한 이미지 의존은 지연/번들 크기 리스크).
- 접근성: `<img alt>` 또는 `aria-hidden` 등 의도를 명확히 하고, 텍스트 라벨을 제거하지 않는다.
- (필수) “투명 배경이 필요한데 배경이 섞인 결과”는 수작업 편집으로 땜질하지 말고, `rembg`로 재현 가능하게 처리한다. (참조: `vibe/ref/rembg-guide.md`)
- (필수 조건부) 배경 제거(rembg)를 전제하면, **생성 단계에서 배경은 순백(#FFFFFF) 단색**으로 강제한다(그라데이션/텍스처/그림자 금지) — 자동 제거 품질/속도/재현성에 직접 영향.

**잠재적 리스크**:

- 스타일 불일치(아이콘마다 톤이 다름) → 공통 스타일 프롬프트/팔레트 규칙을 SSOT로 두고 재사용한다.

## 페어링 질문 (결정 필요)

- [x] **Q1**: 에셋 저장 위치를 어디로 둘까?
  - Option A: `frontend/public/ui/` (정적 경로, 단순, 캐싱 유리) ✅
  - Option B: `frontend/src/assets/` (번들링/해시 관리가 쉽지만 빌드 영향)
  **A1**: Option A

## 참고 자료

- `vibe/ref/frontend-style-guide.md` - CRT 테마 규칙
- `vibe/prd.md` - “채팅 UI 금지”, 고정 HUD 요구
- `frontend/public/logo-retro.png` - 레포 내 톤 레퍼런스
- `vibe/ref/rembg-guide.md` - rembg 배경 제거(모델 선택/옵션/명령) 가이드
</file>

<file path="vibe/unit-plans/U-031[Mvp].md">
# U-031[Mvp]: nanobanana mcp 상태 Placeholder Pack(Scene/오프라인/에러/차단)

## 메타데이터

| 항목      | 내용        |
| --------- | ----------- |
| Unit ID   | U-031[Mvp]  |
| Phase     | MVP         |
| 예상 소요 | 60분        |
| 의존성    | U-030,U-004,U-034 |
| 우선순위  | Medium      |

## 작업 목표

Scene Canvas와 주요 시스템 상태(로딩/오프라인/차단/저신호 등)에 대해, 텍스트만 있는 빈 화면 대신 **게임스러운 상태 이미지(placeholder)** 를 `nanobanana mcp`로 제작하고 UI에 반영한다. (가이드 준수: `vibe/ref/nanobanana-mcp.md`)

**배경**: 데모에서 “이미지 생성이 아직 없거나 실패한 상황”이 자주 발생한다. 이때 상태 화면이 허전하면 제품이 덜 완성돼 보이고, 사용자에게 실패로 인식된다. placeholder는 **실패/지연을 UX로 흡수**하는 핵심 장치다. (PRD: Lazy image loading/폴백)

**완료 기준**:

- 최소 4종 이상의 상태 placeholder(예: `loading`, `offline`, `blocked`, `low-signal`)를 일관된 CRT 톤으로 제작한다.
- Scene Canvas에 상태별 placeholder가 적용되며, 로딩 실패 시에도 텍스트 폴백이 유지된다.
- 파일 크기/네이밍/저장 위치는 U-030(에셋 SSOT)을 준수한다.
- (필수 조건부) placeholder를 “투명 오버레이/스티커”처럼 써야 하는 경우(예: 특정 심볼만 분리), `rembg`로 배경 제거를 수행해 투명 PNG 변형을 만든다. (가이드 준수: `vibe/ref/rembg-guide.md`)
- (필수 조건부) 위 “투명 오버레이/스티커” 변형을 만들 때는, 원본 생성 단계에서 배경을 **순백(#FFFFFF) 단색**으로 강제한다(그라데이션/텍스처/그림자 금지) → rembg 품질/재현성 향상.

## 영향받는 파일

**생성**:

- `frontend/public/ui/placeholders/scene-loading-*.png` - 로딩 placeholder
- `frontend/public/ui/placeholders/scene-offline-*.png` - 오프라인 placeholder
- `frontend/public/ui/placeholders/scene-blocked-*.png` - 안전/정책 차단 placeholder
- `frontend/public/ui/placeholders/scene-low-signal-*.png` - 재화/신호 부족 placeholder

**수정**:

- `frontend/src/App.tsx` - Scene Canvas placeholder 렌더 분기(상태 → 이미지/텍스트 폴백)
- `frontend/src/style.css` - placeholder 적용 CSS(배경 이미지/크기/대비/Readable 모드 연동)
- (선택) `frontend/src/stores/agentStore.ts` - 스트림 에러/차단 상태를 UI가 소비할 수 있게 노출(필요 시)

**참조**:

- `vibe/ref/nanobanana-mcp.md` - nanobanana mcp 에셋 제작 가이드(SSOT)
- `vibe/unit-plans/U-030[Mvp].md` - 에셋 SSOT(경로/네이밍/예산/폴백)
- `vibe/unit-plans/U-028[Mvp].md` - Readable 모드/스케일(placeholder 대비/텍스트 가독성)
- `vibe/prd.md` 6.3/10.2 - 텍스트 우선 + Lazy loading + 실패 폴백

## 구현 흐름

### 1단계: 상태 정의(최소 4종) 및 UI 연결 방식 확정

- 상태 키를 단순화한다: `loading | offline | blocked | low_signal`
- MVP에서는 Scene Canvas 내부 placeholder만 먼저 적용하고, 다른 패널로 확장은 후속 유닛에서 한다.

### 2단계: nanobanana mcp로 placeholder 에셋 제작

- 공통 아트 디렉션: CRT 인광 그린 톤 + 스캔라인 느낌 + “게임 화면” 인상(단, 과도한 텍스트 렌더링은 피함)
- 1x/2x(또는 512/1024) 2종을 우선 제작해 작은/큰 화면 모두 대응한다.

### 2.5단계: (필수 조건부) rembg로 배경 제거(투명 오버레이가 필요한 경우)

- placeholder가 아니라 “분리된 오브젝트/심볼(투명 PNG)”이 필요하면, `rembg`로 배경 제거를 수행해 알파 채널을 확보한다.
- (필수) rembg 품질/속도를 위해, 원본 생성 단계에서 배경을 **순백(#FFFFFF) 단색**으로 만들도록 프롬프트에 명시한다(그라데이션/텍스처/그림자 금지).
- 모델 선택/옵션은 `vibe/ref/rembg-guide.md`의 “모델 자동 선택 규칙/Alpha Matting 기준”을 따른다.

### 3단계: UI 반영 + 폴백 유지

- 이미지가 없거나 로딩 실패 시: 기존 텍스트(`Scene Canvas`, 설명 문구)를 유지한다.
- Readable 모드에서는 placeholder의 대비/오버레이 강도를 약하게(가독성 우선) 한다.

### 4단계: 성능/예산 체크

- placeholder별 용량 상한을 확인하고(권장 200KB 이하), 필요 시 압축/리사이즈한다.
- 총 에셋 예산을 넘지 않도록 최소 개수만 유지한다.

## 의존성 & 연결

**이전 작업에서 가져올 것**:

- **계획서**: [U-030[Mvp]](U-030[Mvp].md) - 에셋 SSOT
- **계획서**: [U-004[Mvp]](U-004[Mvp].md) - Scene Canvas/UI 골격

**다음 작업에 전달할 것**:

- U-019/U-020(이미지 생성/렌더)에서 “이미지 생성 전/실패 시” 화면 품질 기준선
- 데모/리플레이에서 안정적으로 보여줄 “상태 표현 패턴(이미지+텍스트 폴백)”

## 주의사항

**기술적 고려사항**:

- placeholder에 긴 문장을 이미지로 박지 않는다(언어/접근성/번역/리사이즈 문제). 핵심 라벨은 텍스트 UI로 유지한다.
- “차단(blocked)” 표현은 공포/선정적 표현 대신, 제품/정책 안내 수준으로 표현한다.
- (필수 조건부) 배경 제거가 필요하면 `rembg`로 재현 가능하게 처리한다(수작업 컷아웃 금지). (참조: `vibe/ref/rembg-guide.md`)
- (필수 조건부) 배경 제거(rembg)를 전제하면, **생성 단계에서 배경은 순백(#FFFFFF) 단색**으로 강제한다(그라데이션/텍스처/그림자 금지).

**잠재적 리스크**:

- placeholder가 너무 화려하면 정보 전달을 방해 → Readable 모드/대비 토큰으로 완화 가능하게 설계한다.

## 페어링 질문 (결정 필요)

- [x] **Q1**: placeholder의 텍스트(예: OFFLINE) 일부를 이미지에 포함할까?
  - Option A: 이미지에는 최소 상징만 포함, 텍스트는 UI로 렌더 ✅
  - Option B: 이미지에 짧은 라벨 포함(브랜드감 ↑) — 대신 i18n/가독성 리스크
  **A1**: Option A

## 참고 자료

- `vibe/prd.md` - Lazy loading/실패 폴백, 데모 표면 UX
- `vibe/unit-plans/U-030[Mvp].md` - 에셋 SSOT 규칙
- `vibe/unit-plans/U-028[Mvp].md` - 가독성/Readable 모드
- `vibe/ref/rembg-guide.md` - rembg 배경 제거(모델 선택/옵션/명령) 가이드
</file>

<file path="vibe/unit-plans/U-032[Mvp].md">
# U-032[Mvp]: nanobanana mcp UI Chrome Pack(패널/카드 프레임/코너)

## 메타데이터

| 항목      | 내용        |
| --------- | ----------- |
| Unit ID   | U-032[Mvp]  |
| Phase     | MVP         |
| 예상 소요 | 60분        |
| 의존성    | U-030,U-004,U-034 |
| 우선순위  | Medium      |

## 작업 목표

UI의 “게임스러움”을 강화하기 위해, 패널/카드/캔버스에 적용할 **프레임(코너/라인/리벳 등)과 간단한 크롬(UI 장식)** 에셋을 `nanobanana mcp`로 제작하고 최소 범위에 반영한다. (가이드 준수: `vibe/ref/nanobanana-mcp.md`)

**배경**: Unknown World의 평가 포인트 중 하나는 “채팅 UI가 아닌 게임 UI”의 첫 인상이다. CSS만으로도 가능하지만, 적절한 크롬(프레임/코너)을 넣으면 **즉시 게임 HUD 느낌**이 살아난다. 다만 남용하면 가독성/성능이 악화되므로 “필요한 패널 1~2개에만” 적용한다.

**완료 기준**:

- 최소 3종 이상의 크롬 에셋(예: panel-corner, card-frame, scanner-frame)을 제작한다.
- Header/Panel/Action Card 중 **1~2곳**에만 선택 적용하고, Readable 모드에서는 과도한 장식을 완화한다.
- 에셋 규칙(U-030)을 준수하고, 적용 실패 시 기존 CSS 스타일로 폴백된다.
- (필수 조건부) 크롬 에셋은 **투명 배경(알파) 필수**이며, 생성 결과에 배경이 남아 있으면 `rembg`로 배경 제거를 수행해 투명 PNG로 정리한다. (가이드 준수: `vibe/ref/rembg-guide.md`)
- (필수) 위 rembg 배경 제거를 전제하므로, 원본 생성 단계에서 배경을 **순백(#FFFFFF) 단색**으로 강제한다(그라데이션/텍스처/그림자 금지) → 제거 품질/재현성 향상.

## 영향받는 파일

**생성**:

- `frontend/public/ui/chrome/panel-corner-*.png` - 패널 코너(4방향 또는 1장+CSS transform)
- `frontend/public/ui/chrome/card-frame-*.png` - 액션 카드 프레임(얇은 테두리/하이라이트)
- `frontend/public/ui/chrome/scanner-frame-*.png` - 스캐너 슬롯 프레임/장식

**수정**:

- `frontend/src/style.css` - 크롬 적용 CSS(`background-image`, `mask-image`, `image-set`) 추가
- `frontend/src/App.tsx` - 적용 대상 패널/카드에 클래스 부여(최소 범위)

**참조**:

- `vibe/ref/nanobanana-mcp.md` - nanobanana mcp 에셋 제작 가이드(SSOT)
- `vibe/unit-plans/U-030[Mvp].md` - 에셋 SSOT(예산/네이밍/폴백)
- `vibe/ref/frontend-style-guide.md` - CRT 톤/색상 변수 원칙
- `frontend/public/logo-retro.png` - 기존 톤 레퍼런스

## 구현 흐름

### 1단계: 적용 대상 1~2곳 선정(과잉 적용 금지)

- 후보: Action Deck 카드 / Panel 헤더 / Scanner 슬롯
- MVP에서는 “가장 눈에 띄는 곳 1곳 + 보조 1곳”까지만 적용한다.

### 2단계: nanobanana mcp로 크롬 에셋 제작

- 공통 스타일: CRT 레트로 + 제한 팔레트(그린/마젠타/오렌지), 얇은 라인(가독성 방해 금지)
  - 최종 산출물: 투명 PNG(알파 필수)
  - (필수) 배경 제거(rembg) 대비: **원본 생성 시 배경은 순백(#FFFFFF) 단색**으로 강제(그라데이션/텍스처/그림자 금지)
- 작은 크기에서도 형태가 깨지지 않도록 단순한 기하 형태를 우선한다.

### 3단계: (필수 조건부) rembg로 배경 제거(투명 PNG가 필요한 경우)

- 결과에 배경이 섞였거나, 가장자리가 지저분해 “테두리/글로우”와 충돌하면 `rembg`로 배경을 제거해 알파 채널을 확보한다.
- (권장) 원본을 순백 단색 배경으로 생성해 두면 rembg 결과가 안정적이다.
- 모델 선택/옵션은 `vibe/ref/rembg-guide.md`의 “모델 자동 선택 규칙/Alpha Matting 기준”을 따른다.

### 4단계: CSS로 적용 + Readable 모드 연동

- 기본 모드: 크롬 적용
- Readable 모드: 크롬의 대비/글로우를 줄이거나, 크롬을 제거하는 클래스로 완화

### 5단계: 폴백/성능 확인

- 에셋 로딩 실패 시 기존 CSS 테두리/박스섀도우로 보이게 유지한다.
- 반복/타일링 사용 시 렌더링 비용이 커지지 않도록 최소 적용을 유지한다.

## 의존성 & 연결

**이전 작업에서 가져올 것**:

- **계획서**: [U-030[Mvp]](U-030[Mvp].md) - 에셋 규칙 SSOT
- **계획서**: [U-004[Mvp]](U-004[Mvp].md) - UI 레이아웃/패널 구조

**다음 작업에 전달할 것**:

- U-009(Action Deck), U-022(Scanner) 등 UI 유닛에서 재사용 가능한 크롬 에셋 세트
- “가독성 유지 + 게임성 강화”의 균형 기준(Readable 모드 연동)

## 주의사항

**기술적 고려사항**:

- 크롬은 정보를 전달하는 UI가 아니라 “장식”이므로, 과도한 강조(강한 플리커/두꺼운 글로우)는 금지한다.
- 접근성: 장식은 `aria-hidden` 처리하고, 라벨/상태는 텍스트로 유지한다.
- (필수 조건부) 배경 제거가 필요하면 `rembg`로 재현 가능하게 처리한다(수작업 컷아웃 금지). (참조: `vibe/ref/rembg-guide.md`)
- (필수) 배경 제거(rembg) 품질/편의를 위해, **생성 단계에서 배경은 순백(#FFFFFF) 단색**으로 강제한다(그라데이션/텍스처/그림자 금지).

**잠재적 리스크**:

- 크롬이 과하면 “읽기 어려운 UI”로 회귀 → U-028 Readable 모드와 함께 튜닝한다.

## 페어링 질문 (결정 필요)

- [x] **Q1**: 크롬 적용을 어디까지 허용할까?
  - Option A: 패널/카드의 코너/프레임 정도만(권장) ✅
  - Option B: 배경 텍스처/스캔라인 패턴까지 포함(몰입 ↑, 가독성/성능 리스크 ↑)
  **A1**: Option A

## 참고 자료

- `vibe/ref/frontend-style-guide.md` - CRT 테마/변수 SSOT
- `vibe/unit-plans/U-030[Mvp].md` - 에셋 SSOT 규칙
- `frontend/src/style.css` - 현재 패널/카드 스타일(폴백 기반)
- `vibe/ref/rembg-guide.md` - rembg 배경 제거(모델 선택/옵션/명령) 가이드
</file>

<file path="vibe/unit-plans/U-033[Mvp].md">
# U-033[Mvp]: nanobanana mcp 에셋 매니페스트 + QA(크기/대비/폴백)

## 메타데이터

| 항목      | 내용       |
| --------- | ---------- |
| Unit ID   | U-033[Mvp] |
| Phase     | MVP        |
| 예상 소요 | 45분       |
| 의존성    | U-030      |
| 우선순위  | Medium     |

## 작업 목표

`nanobanana mcp`로 생성한 에셋이 “어디서 쓰이는지/규칙을 지키는지”를 확인할 수 있도록, **간단한 에셋 매니페스트(목록)와 QA 체크리스트(예산/대비/폴백)** 를 도입한다.

**배경**: 생성형 에셋은 늘기 쉽지만, 사용처/규칙이 정리되지 않으면 중복/비대화/스타일 불일치가 생긴다. MVP에서는 자동화까지 과하게 가지 않되, 최소한의 매니페스트/체크리스트로 **품질 하락을 예방**한다.

**완료 기준**:

- `frontend/public/ui/manifest.json`(또는 `manifest.yml`) 형태로 에셋 목록/용도를 기록한다.
- 신규 에셋 반영 시 체크해야 할 QA 항목(용량/사이즈/대비/폴백/Readable 모드, **투명 배경 필요 시 배경 제거(rembg)**)을 문서화한다.
- U-029/U-031/U-032 같은 에셋 유닛이 “어떤 파일을 추가/수정하는지” 추적 가능해진다.
- U-038(핵심 UI 아이콘 12종 v2)처럼 “기존 아이콘 교체/재생성”도 매니페스트/QA로 추적 가능해진다.

## 영향받는 파일

**생성**:

- `frontend/public/ui/manifest.json` - 에셋 목록(키/경로/사이즈/용도/폴백 텍스트)
- `frontend/public/ui/QA_CHECKLIST.md` - 수동 QA 체크리스트(가독성/성능/폴백)

**수정**:

- `vibe/unit-plans/U-029[Mvp].md` - “산출물 기록/QA 준수”를 완료 기준에 명시(필요 시)
- `vibe/unit-plans/U-031[Mvp].md` - placeholder 산출물 매니페스트 반영(필요 시)
- `vibe/unit-plans/U-032[Mvp].md` - chrome 산출물 매니페스트 반영(필요 시)
- `vibe/unit-plans/U-038[Mvp].md` - 아이콘 v2 산출물 매니페스트 반영(필요 시)

**참조**:

- `vibe/unit-plans/U-030[Mvp].md` - 에셋 SSOT/예산 규칙
- `vibe/unit-plans/U-028[Mvp].md` - Readable 모드(가독성 QA)

## 구현 흐름

### 1단계: 매니페스트 포맷 확정(MVP 최소)

- 항목 예시: `id`, `path`, `category(icon|placeholder|chrome)`, `size(px)`, `usage`, `fallback_text`
- MVP에서는 수동 갱신으로 시작하고, 자동 생성은 MMP에서 고려한다.

### 2단계: QA 체크리스트 정의

- 용량: 개별/총합 예산 준수
- 가독성: 작은 크기에서도 형태가 구분되는지
- (아이콘) **16px에서 실루엣이 구분**되는지, 필요 시 16px/24px 사용처를 분리해 사용한다
- (선택) Retina: `image-set()` 또는 `@2x` 변형이 필요한지 확인한다
- 대비: 기본/Readable 모드에서 텍스트를 방해하지 않는지
- 투명도(조건부): 아이콘/chrome처럼 투명 배경이 필요한 에셋은 **알파 채널이 존재**하며, 배경이 남아 있으면 `rembg`로 배경 제거가 수행되었는지 확인
- 배경 단순화(조건부): 배경 제거(rembg)를 전제한 에셋은 **원본 생성 단계에서 배경이 순백(#FFFFFF) 단색**인지 확인(그라데이션/텍스처/그림자 금지)
- 폴백: 이미지 미존재/로딩 실패 시 텍스트/이모지가 유지되는지

### 3단계: 기존 에셋 유닛과 연결(산출물 기록)

- U-029/U-031/U-032/U-038 계획서에 “산출물은 manifest에 기록”을 명시한다.
- (선택) PRD에 “에셋은 manifest로 추적”을 한 줄 추가한다.

## 의존성 & 연결

**이전 작업에서 가져올 것**:

- **계획서**: [U-030[Mvp]](U-030[Mvp].md) - 에셋 SSOT/예산 규칙

**다음 작업에 전달할 것**:

- 에셋이 늘어도 추적 가능한 목록(매니페스트)과 품질 기준(QA)
- 이후 자동화(스크립트/CI)로 확장할 기반(형식 고정)

## 주의사항

**기술적 고려사항**:

- MVP에서는 “자동화”보다 “형식 고정”이 우선이다(파일 1~2개로 단순 유지).
- 체크리스트가 너무 길어지면 방치됨 → 8~12개 핵심 항목만 유지한다.
- 배경 제거는 수작업 편집 대신 `rembg`로 재현 가능하게 처리하는 것을 기본으로 한다. (참조: `vibe/ref/rembg-guide.md`)
- (조건부) rembg 품질/속도를 위해, 배경 제거가 필요한 에셋은 **생성 단계에서 배경을 순백(#FFFFFF) 단색**으로 강제한다(그라데이션/텍스처/그림자 금지).

**잠재적 리스크**:

- 매니페스트를 안 지키면 무용지물 → 에셋 생성 유닛의 완료 기준에 포함해 강제한다.

## 페어링 질문 (결정 필요)

- [x] **Q1**: 매니페스트 포맷은 무엇이 좋을까?
  - Option A: `manifest.json`(권장: 도구/파싱 용이) ✅
  - Option B: `manifest.yml`(가독성 ↑, 파싱/정합성 ↓)
  **A1**: Option A

## 참고 자료

- `vibe/unit-plans/U-030[Mvp].md` - 에셋 SSOT
- `vibe/unit-plans/U-028[Mvp].md` - Readable/가독성 기준
- `vibe/ref/rembg-guide.md` - rembg 배경 제거(모델 선택/옵션/명령) 가이드
</file>

<file path="vibe/unit-runbooks/U-007-mock-orchestrator-runbook.md">
# U-007[Mvp] 모의 Orchestrator + /api/turn HTTP Streaming 실행 가이드

## 1. 개요

실모델(Gemini) 없이도 프론트엔드 개발/데모를 지속할 수 있도록, **모의 Orchestrator**로 TurnOutput을 생성하고 이를 **HTTP Streaming(POST 응답 스트림)** 으로 전달하는 `/api/turn` 엔드포인트를 구현했습니다.

**주요 기능**:
- NDJSON(라인 단위 JSON) 스트리밍으로 stage/badges/narrative_delta/final 이벤트 순차 전송
- 결정적(seed 기반) 모의 TurnOutput 생성으로 재현 가능한 테스트
- TTFB 최적화를 위한 즉시 stage 이벤트 전송
- 스키마 검증 실패 시 안전한 폴백 TurnOutput 반환 (RULE-004)

**프로토콜 버전**: v1 (현행 계약) — PRD 8.4.3 참조

**예상 소요 시간**: 10분

**의존성**:
- 의존 유닛: U-005[Mvp] (TurnInput/TurnOutput Pydantic 스키마), U-003[Mvp] (FastAPI 앱)
- 선행 완료 필요: 백엔드 의존성 설치 (`uv sync`)

---

## 2. 빠른 시작 (Quick Start)

### 2.1 환경 준비

```bash
# 백엔드 디렉토리로 이동
cd backend

# 의존성 설치 (uv 사용)
uv sync
```

### 2.2 의존 유닛 확인

```bash
# Pydantic 모델 import 테스트
cd backend && uv run python -c "from unknown_world.models.turn import TurnInput, TurnOutput; print('Models OK')"
```

예상 출력:
```
Models OK
```

### 2.3 즉시 실행

```bash
# 백엔드 서버 시작 (포트 8011 - RULE-011)
cd backend && uv run uvicorn unknown_world.main:app --reload --port 8011
```

### 2.4 첫 화면/결과 확인

- 브라우저에서 `http://localhost:8011/docs` 접속
- Swagger UI에서 `/api/turn` POST 엔드포인트 확인
- 성공 지표: "Turn" 태그 아래 `/api/turn` 엔드포인트 표시

---

## 3. 핵심 기능 시나리오

### 시나리오 A: 기본 턴 요청 (curl)

**목적**: NDJSON 스트리밍이 정상 동작하는지 확인

**실행**:

```bash
curl -X POST http://localhost:8011/api/turn \
  -H "Content-Type: application/json" \
  -d '{
    "language": "ko-KR",
    "text": "문을 열어본다",
    "client": {"viewport_w": 1920, "viewport_h": 1080, "theme": "dark"},
    "economy_snapshot": {"signal": 100, "memory_shard": 5}
  }' \
  --no-buffer
```

**기대 결과**:

NDJSON 형식으로 이벤트가 순차적으로 출력됩니다:

```
{"type":"stage","name":"parse","status":"start"}
{"type":"stage","name":"parse","status":"complete"}
{"type":"stage","name":"validate","status":"start"}
{"type":"stage","name":"validate","status":"complete"}
{"type":"badges","badges":["schema_ok","economy_ok"]}
{"type":"stage","name":"plan","status":"start"}
... (중략) ...
{"type":"narrative_delta","text":"당신은 \"문을 열어본다\"라"}
{"type":"narrative_delta","text":"고 말했습니다. 어둠 속에서"}
... (중략) ...
{"type":"final","data":{...TurnOutput JSON...}}
```

**확인 포인트**:
- ✅ `type: "stage"` 이벤트가 Parse→Commit 순서로 전송됨
- ✅ `type: "badges"` 이벤트에 검증 배지 포함
- ✅ `type: "narrative_delta"` 이벤트로 텍스트 조각 전송 (타자 효과)
- ✅ `type: "final"` 이벤트에 완전한 TurnOutput 포함

---

### 시나리오 B: 재현 가능한 결과 (seed 파라미터)

**목적**: 동일 seed로 동일한 TurnOutput이 생성되는지 확인

**실행**:

```bash
# 첫 번째 요청 (seed=42)
curl -X POST "http://localhost:8011/api/turn?seed=42" \
  -H "Content-Type: application/json" \
  -d '{
    "language": "ko-KR",
    "text": "주변을 살펴본다",
    "client": {"viewport_w": 1920, "viewport_h": 1080, "theme": "dark"},
    "economy_snapshot": {"signal": 100, "memory_shard": 5}
  }' 2>/dev/null | tail -1 | jq '.data.narrative'

# 두 번째 요청 (동일 seed=42)
curl -X POST "http://localhost:8011/api/turn?seed=42" \
  -H "Content-Type: application/json" \
  -d '{
    "language": "ko-KR",
    "text": "주변을 살펴본다",
    "client": {"viewport_w": 1920, "viewport_h": 1080, "theme": "dark"},
    "economy_snapshot": {"signal": 100, "memory_shard": 5}
  }' 2>/dev/null | tail -1 | jq '.data.narrative'
```

**기대 결과**:
- 두 요청의 narrative가 동일해야 함

**확인 포인트**:
- ✅ 동일 seed → 동일 결과 (결정적 출력)
- ✅ 다른 seed → 다른 결과

---

### 시나리오 C: 영어 언어 설정

**목적**: 언어 설정에 따른 다국어 출력 확인 (RULE-006)

**실행**:

```bash
curl -X POST http://localhost:8011/api/turn \
  -H "Content-Type: application/json" \
  -d '{
    "language": "en-US",
    "text": "Open the door",
    "client": {"viewport_w": 1920, "viewport_h": 1080, "theme": "dark"},
    "economy_snapshot": {"signal": 100, "memory_shard": 5}
  }' \
  --no-buffer 2>/dev/null | tail -1 | jq '.data.language, .data.narrative'
```

**기대 결과**:
```
"en-US"
"You said \"Open the door\". ..."
```

**확인 포인트**:
- ✅ `language: "en-US"` 응답
- ✅ 영어 내러티브 생성
- ✅ ko/en 혼합 없음

---

### 시나리오 D: 입력 검증 실패

**목적**: 잘못된 입력에 대한 에러 스트림 반환 확인

**실행**:

```bash
# 필수 필드 누락
curl -X POST http://localhost:8011/api/turn \
  -H "Content-Type: application/json" \
  -d '{"text": "test"}' \
  --no-buffer
```

**기대 결과**:
```
{"type":"error","message":"Invalid input","code":"VALIDATION_ERROR"}
```

**확인 포인트**:
- ✅ `type: "error"` 이벤트 반환
- ✅ 프롬프트/내부 추론 노출 없음 (RULE-007)

---

### 시나리오 E: 경제 시스템 확인 (RULE-005)

**목적**: 비용 계산 및 잔액 업데이트 확인

**실행**:

```bash
curl -X POST http://localhost:8011/api/turn \
  -H "Content-Type: application/json" \
  -d '{
    "language": "ko-KR",
    "text": "앞으로 전진한다",
    "client": {"viewport_w": 1920, "viewport_h": 1080, "theme": "dark"},
    "economy_snapshot": {"signal": 50, "memory_shard": 2}
  }' \
  --no-buffer 2>/dev/null | tail -1 | jq '.data.economy'
```

**기대 결과**:
```json
{
  "cost": {
    "signal": 1-5,
    "memory_shard": 0
  },
  "balance_after": {
    "signal": 45-49,
    "memory_shard": 2
  }
}
```

**확인 포인트**:
- ✅ `cost.signal` ≥ 0
- ✅ `balance_after.signal` ≥ 0 (음수 불가)
- ✅ 잔액 = 스냅샷 - 비용

---

### 시나리오 F: 핫스팟 좌표 규약 (RULE-009)

**목적**: box_2d 좌표가 0~1000 규약을 준수하는지 확인

**실행**:

```bash
curl -X POST "http://localhost:8011/api/turn?seed=123" \
  -H "Content-Type: application/json" \
  -d '{
    "language": "ko-KR",
    "text": "주변을 살펴본다",
    "client": {"viewport_w": 1920, "viewport_h": 1080, "theme": "dark"},
    "economy_snapshot": {"signal": 100, "memory_shard": 5}
  }' \
  --no-buffer 2>/dev/null | tail -1 | jq '.data.ui.objects[0].box_2d'
```

**기대 결과**:
```json
{
  "ymin": 0-1000,
  "xmin": 0-1000,
  "ymax": 0-1000,
  "xmax": 0-1000
}
```

**확인 포인트**:
- ✅ 모든 좌표 값이 0~1000 범위
- ✅ ymin < ymax, xmin < xmax

---

## 4. 실행 결과 확인

### 4.1 로그 확인

- 서버 로그: 터미널에서 uvicorn 출력 확인
- 주요 로그 메시지:
  - `INFO: ... "POST /api/turn HTTP/1.1" 200 OK`: 정상 처리
  - `422 Unprocessable Entity`: 입력 검증 실패

### 4.2 API 문서

- Swagger UI: `http://localhost:8011/docs`
- ReDoc: `http://localhost:8011/redoc`

### 4.3 성공/실패 판단 기준

**성공**:
- ✅ 모든 시나리오(A~F)의 확인 포인트 통과
- ✅ NDJSON 스트림이 순차적으로 전송됨
- ✅ 최종 TurnOutput이 스키마를 준수함

**실패 시 확인**:
- ❌ `Connection refused` → 서버가 실행 중인지 확인
- ❌ `422 Unprocessable Entity` → 입력 JSON 형식 확인
- ❌ 스트리밍 없이 한 번에 응답 → `--no-buffer` 옵션 확인

---

## 5. 문제 해결 (Troubleshooting)

### 5.1 일반적인 오류

**오류**: `ModuleNotFoundError: No module named 'unknown_world'`
- **원인**: 의존성 미설치 또는 경로 문제
- **해결**: `cd backend && uv sync`

**오류**: `Address already in use`
- **원인**: 8011 포트가 이미 사용 중
- **해결**: 다른 포트 사용 (`--port 8012`) 또는 기존 프로세스 종료

**오류**: 스트리밍이 한 번에 출력됨
- **원인**: curl의 버퍼링
- **해결**: `--no-buffer` 옵션 추가

### 5.2 환경별 주의사항

- **Windows**: PowerShell에서 curl은 `Invoke-WebRequest`의 별칭일 수 있음. Git Bash 또는 실제 curl 사용 권장
- **macOS/Linux**: 기본 curl 사용 가능

---

## 6. 다음 단계

1. **U-008[Mvp]**: 프론트엔드에서 스트림 이벤트를 소비해 Agent Console/내러티브/패널 업데이트
2. **CP-MVP-01**: "스트리밍/스키마/폴백" 체크포인트 수행
</file>

<file path="frontend/package.json">
{
  "name": "unknown-world-frontend",
  "private": true,
  "version": "0.0.0",
  "type": "module",
  "packageManager": "pnpm@10.27.0",
  "scripts": {
    "dev": "vite",
    "build": "tsc -b && vite build",
    "preview": "vite preview",
    "format": "prettier . --write",
    "format:check": "prettier . --check",
    "lint": "eslint .",
    "lint:fix": "eslint . --fix",
    "typecheck": "tsc --noEmit",
    "test": "vitest run",
    "test:watch": "vitest",
    "test:coverage": "vitest run --coverage"
  },
  "dependencies": {
    "@dnd-kit/core": "6.3.1",
    "@dnd-kit/sortable": "10.0.0",
    "i18next": "25.7.3",
    "react": "19.2.3",
    "react-dom": "19.2.3",
    "react-i18next": "16.5.1",
    "zod": "4.3.4",
    "zustand": "5.0.9"
  },
  "devDependencies": {
    "@eslint/js": "9.39.2",
    "@types/node": "25.0.3",
    "@types/react": "19.2.7",
    "@types/react-dom": "19.2.3",
    "@vitejs/plugin-react": "5.1.2",
    "@vitest/coverage-v8": "^4.0.16",
    "eslint": "9.39.2",
    "eslint-config-prettier": "10.1.8",
    "eslint-plugin-react": "7.37.5",
    "eslint-plugin-react-hooks": "7.0.1",
    "eslint-plugin-unused-imports": "4.3.0",
    "globals": "16.5.0",
    "prettier": "3.7.4",
    "typescript": "5.9.3",
    "typescript-eslint": "8.51.0",
    "vite": "7.3.0",
    "vitest": "^4.0.16"
  },
  "pnpm": {
    "onlyBuiltDependencies": [
      "esbuild"
    ]
  }
}
</file>

<file path="frontend/public/ui/manifest.json">
{
  "$schema": "./manifest.schema.json",
  "version": "1.3.0",
  "generatedAt": "2026-01-12T14:15:00Z",
  "totalBytes": 556534,
  "budgetBytes": 1572864,
  "assets": [
    {
      "id": "signal-24",
      "path": "icons/signal-24.png",
      "type": "icon",
      "size": 24,
      "fallback": "⚡",
      "usedIn": ["EconomyHUD", "ActionDeck"],
      "bytes": 122,
      "notes": "nanobanana mcp 생성, rembg 배경 제거 및 최적화 완료"
    },
    {
      "id": "signal-16",
      "path": "icons/signal-16.png",
      "type": "icon",
      "size": 16,
      "fallback": "⚡",
      "usedIn": [],
      "bytes": 389,
      "notes": "최적화 완료"
    },
    {
      "id": "shard-24",
      "path": "icons/shard-24.png",
      "type": "icon",
      "size": 24,
      "fallback": "💎",
      "usedIn": ["EconomyHUD", "ActionDeck"],
      "bytes": 103,
      "notes": "nanobanana mcp 생성, rembg 배경 제거 및 최적화 완료"
    },
    {
      "id": "badge-ok-24",
      "path": "icons/badge-ok-24.png",
      "type": "icon",
      "size": 24,
      "fallback": "✓",
      "usedIn": ["AgentConsole"],
      "bytes": 910,
      "notes": "최적화 완료"
    },
    {
      "id": "badge-ok-16",
      "path": "icons/badge-ok-16.png",
      "type": "icon",
      "size": 16,
      "fallback": "✓",
      "usedIn": [],
      "bytes": 586,
      "notes": "최적화 완료"
    },
    {
      "id": "badge-fail-24",
      "path": "icons/badge-fail-24.png",
      "type": "icon",
      "size": 24,
      "fallback": "✗",
      "usedIn": ["AgentConsole"],
      "bytes": 822,
      "notes": "최적화 완료"
    },
    {
      "id": "risk-medium-16",
      "path": "icons/risk-medium-16.png",
      "type": "icon",
      "size": 16,
      "fallback": "⚠",
      "usedIn": ["ActionDeck"],
      "bytes": 601,
      "notes": "최적화 완료"
    },
    {
      "id": "risk-low-24",
      "path": "icons/risk-low-24.png",
      "type": "icon",
      "size": 24,
      "fallback": "✓",
      "usedIn": ["ActionDeck"],
      "bytes": 226,
      "notes": "nanobanana mcp 생성, rembg 배경 제거 완료"
    },
    {
      "id": "risk-low-16",
      "path": "icons/risk-low-16.png",
      "type": "icon",
      "size": 16,
      "fallback": "✓",
      "usedIn": [],
      "bytes": 147
    },
    {
      "id": "risk-high-24",
      "path": "icons/risk-high-24.png",
      "type": "icon",
      "size": 24,
      "fallback": "⚠",
      "usedIn": ["ActionDeck"],
      "bytes": 969,
      "notes": "nanobanana mcp 생성, rembg 배경 제거 완료"
    },
    {
      "id": "risk-high-16",
      "path": "icons/risk-high-16.png",
      "type": "icon",
      "size": 16,
      "fallback": "⚠",
      "usedIn": [],
      "bytes": 543
    },
    {
      "id": "status-online-16",
      "path": "icons/status-online-16.png",
      "type": "icon",
      "size": 16,
      "fallback": "●",
      "usedIn": [],
      "bytes": 264,
      "notes": "최적화 완료"
    },
    {
      "id": "scene-placeholder-default",
      "path": "placeholders/scene-placeholder-default.png",
      "type": "placeholder",
      "fallback": "[SCENE]",
      "usedIn": ["SceneCanvas"],
      "bytes": 261407,
      "notes": "nanobanana mcp 생성, 레트로 터미널 스타일"
    },
    {
      "id": "scene-loading",
      "path": "placeholders/scene-loading.webp",
      "type": "placeholder",
      "fallback": "⏳",
      "usedIn": ["SceneCanvas"],
      "bytes": 47850,
      "notes": "U-031: 로딩 상태 placeholder, nanobanana mcp 생성, ImageMagick(magick) 최적화"
    },
    {
      "id": "scene-offline",
      "path": "placeholders/scene-offline.webp",
      "type": "placeholder",
      "fallback": "🔌",
      "usedIn": ["SceneCanvas"],
      "bytes": 44658,
      "notes": "U-031: 오프라인 상태 placeholder, nanobanana mcp 생성, ImageMagick(magick) 최적화"
    },
    {
      "id": "scene-blocked",
      "path": "placeholders/scene-blocked.webp",
      "type": "placeholder",
      "fallback": "🚫",
      "usedIn": ["SceneCanvas"],
      "bytes": 17318,
      "notes": "U-031: 차단 상태 placeholder, nanobanana mcp 생성, ImageMagick(magick) 최적화"
    },
    {
      "id": "scene-low-signal",
      "path": "placeholders/scene-low-signal.webp",
      "type": "placeholder",
      "fallback": "📉",
      "usedIn": ["SceneCanvas"],
      "bytes": 68454,
      "notes": "U-031: 저신호 상태 placeholder, nanobanana mcp 생성, ImageMagick(magick) 최적화"
    },
    {
      "id": "panel-corner-br",
      "path": "chrome/panel-corner-br.png",
      "type": "chrome",
      "fallback": "",
      "usedIn": ["PanelHeader"],
      "bytes": 1899,
      "notes": "U-032: 패널 코너 장식, nanobanana mcp 생성, rembg 배경 제거, ImageMagick 최적화(48x48), CSS transform으로 4방향 적용"
    },
    {
      "id": "card-frame",
      "path": "chrome/card-frame.png",
      "type": "chrome",
      "fallback": "",
      "usedIn": ["ActionCard"],
      "bytes": 9101,
      "notes": "U-032: 액션 카드 프레임, nanobanana mcp 생성, rembg 배경 제거, ImageMagick 최적화(160x80)"
    },
    {
      "id": "scanner-frame",
      "path": "chrome/scanner-frame.png",
      "type": "chrome",
      "fallback": "",
      "usedIn": ["Scanner"],
      "bytes": 100165,
      "notes": "U-032: 스캐너 슬롯 프레임, nanobanana mcp 생성, rembg(birefnet-general) 배경 제거, ImageMagick 최적화(346x200) 완료"
    }
  ]
}
</file>

<file path="package.json">
{
  "name": "unknown-world",
  "version": "0.1.0",
  "private": true,
  "description": "Unknown World - Gemini 기반 에이전트형 게임 엔진",
  "packageManager": "pnpm@10.27.0",
  "engines": {
    "node": "24.12.0"
  },
  "scripts": {
    "kill": "pnpm kill:port",
    "kill:port": "npx --yes kill-port 8001 8002 8003 8004 8005 8006 8007 8008 8009 8010 8011 8012 8013 8014 8015 8016 8017 8018 8019 8020",
    "kill:front": "npx --yes kill-port 8001 8002 8003 8004 8005 8006 8007 8008 8009 8010",
    "kill:back": "npx --yes kill-port 8011 8012 8013 8014 8015 8016 8017 8018 8019 8020",
    "dev:back": "cd backend && uv run uvicorn unknown_world.main:app --reload --port 8011",
    "dev:front": "pnpm -C frontend dev"
  }
}
</file>

<file path="vibe/tech-stack.md">
# [Unknown World] 기술 스택 가이드 (MVP)

- **기준 문서**: `vibe/prd.md`, `vibe/ref/*`
- **원칙**: Prompt-only wrapper 회피(상태/오케스트레이터/아티팩트), 구조화 출력(JSON Schema) 우선, 비용·지연 제어 내장
- **버전 기준일**: 2026-01-01 (아래 버전으로 lockfile 고정)

## 1. 기술 스택 요약 (한눈에 보기)

- **Frontend (Web UI)**
  - React `19.2.3` / React DOM `19.2.3`
  - Vite `7.3.0` (빌드/번들)
  - TypeScript `5.9.3`
  - 패키지 매니저: **pnpm** (lockfile: `pnpm-lock.yaml`)
  - 상태: Zustand `5.0.9` (WorldState/Inventory/UI/Economy)
  - 스키마: Zod `4.3.4` (TurnOutput JSON 검증)
  - DnD: `@dnd-kit/core 6.3.1` + `@dnd-kit/sortable 10.0.0`
  - i18n: i18next `25.7.3` + react-i18next `16.5.1`

- **Backend (Orchestrator API)**
  - Python `3.14.0`
  - FastAPI `0.128.0` (async)
  - Uvicorn `0.40.0` (ASGI)
  - Pydantic `2.12.5` (스키마/검증/직렬화)

- **Dev/Build Tools (이미지 후처리)**
  - rembg `2.0.67` (배경 제거, Dev/런타임 모두 사용 가능)
    - 개발용: nanobanana mcp 에셋 투명 PNG 제작
    - 런타임: 실시간 오브젝트 이미지 배경 제거(조건부)
    - 모델 선택: `vibe/ref/rembg-guide.md` 기준

- **Streaming / Realtime**
  - HTTP Streaming (Fetch + POST): 턴 요청(POST body) → 응답을 스트림으로 수신(타자 효과 + Queue/Badges)
  - (확장) WebSocket: 양방향 실시간 상호작용이 필요할 때만

- **Access (Demo Profiles for Reviewers)**
  - 데모 프로필(심사자용 프리셋 유저) 3종(페르소나 기반)
  - MVP는 “로그인/가입 없이 즉시 시작 + 즉시 리셋” 우선(외부 OAuth는 후순위)

- **GenAI (Gemini + Vertex AI)**
  - 인증: **Vertex AI 서비스 계정**(백엔드에서만)
  - Google GenAI SDK (Python): `google-genai 1.56.0`
  - (선택) Vertex 플랫폼 연동: `google-cloud-aiplatform 1.132.0`
  - (선택) 이미지/아티팩트 저장: `google-cloud-storage 3.7.0`
  - **모델 라인업(모델 ID 고정)**
    - 텍스트: `gemini-3-flash-preview`(FAST), `gemini-3-pro-preview`(QUALITY)
    - 이미지(생성/편집): `gemini-3-pro-image-preview`(EDIT/QUALITY, 고정)
    - 비전/공간: `gemini-3-flash-preview`(bbox/segmentation)

- **Infra (배포)**
  - 컨테이너: Docker
  - 런타임: Node.js `24.12.0` (프론트 빌드), Python `3.14.0` (백엔드)
  - 실행: Cloud Run (권장) / 로컬 개발

### 1.1 코드 품질(린트/포맷/타입체크) 도구 버전 (SSOT)

> 아래 버전은 **2026-01-01 기준 “최신 안정(latest)”**을 레지스트리에서 직접 조회한 값이며,
> 실제 프로젝트에서는 lockfile/설정으로 고정합니다.
>
> - npm: `npm view <package> version`
> - PyPI: `python -m pip index versions <package>`

- **Frontend**
  - pnpm `10.27.0` (권장: `package.json`에 `packageManager: "pnpm@10.27.0"` 명시)
  - ESLint `9.39.2` + `@eslint/js 9.39.2`
  - typescript-eslint `8.51.0`
  - eslint-plugin-react `7.37.5`
  - eslint-plugin-react-hooks `7.0.1`
  - eslint-plugin-unused-imports `4.3.0`
  - eslint-config-prettier `10.1.8`
  - globals `16.5.0`
  - Prettier `3.7.4`

- **Backend**
  - Ruff `0.14.10`
  - Pyright `1.1.407`

## 2. 기술 선택 매트릭스 (압축)

| PRD 요구사항                   | 선택 기술                       | 핵심 이유 (3~4단어) |
| ------------------------------ | ------------------------------- | ------------------- |
| 텍스트 “타자 효과” 스트리밍    | FastAPI + HTTP Streaming(POST)  | 요청-응답/POST 필수 |
| “채팅 앱”이 아닌 게임 UI       | React + 상태 분리               | 고충실도 UI         |
| UI/상태/비용을 기계적으로 처리 | Structured Outputs(JSON Schema) | 파싱/검증 강제      |
| 스키마 깨짐 자동 복구          | Pydantic + Zod + Repair loop    | 실패 내성           |
| 클릭 가능한 핫스팟 좌표        | 0~1000 정규화                   | 비전 bbox 호환      |
| 인벤토리 Drag & Drop           | dnd-kit                         | 접근성/제어         |
| ko/en 동시 지원                | i18next                         | 즉시 토글           |
| 심사/데모 즉시 접근            | 데모 프로필(프리셋 유저)        | 온보딩 10초         |
| 이미지 “선택적” 생성/편집      | `gemini-3-pro-image-preview`    | 편집/일관성 우선    |
| 이미지 업로드→단서/아이템화    | Gemini 비전 + Files API         | 멀티모달 핵심       |
| 오브젝트 이미지 배경 제거      | rembg (조건부 후처리)           | 투명 합성 지원      |
| API 키 노출 없이 Gemini 사용   | Vertex AI 서비스계정            | 보안/운영 단순      |

## 3. 대안 기술 비교 (빠른 판단)

- **Next.js(App Router) vs Vite**: MVP는 SSR/라우팅 복잡도보다 “빠른 반복 + 고정 레이아웃”이 핵심 → Vite 선택
- **NestJS(Node) vs FastAPI(Python)**: 오케스트레이션/검증/스키마 중심 구현을 Python+FastAPI로 빠르게 → FastAPI 선택
- **WebSocket vs HTTP Streaming**: 현재 요구는 “턴 요청-응답 + 스트리밍”이 대부분 → HTTP Streaming 우선, WS는 확장
- **Redux Toolkit vs Zustand**: 상태가 많지만 팀 속도가 우선 → 러닝커브 낮은 Zustand
- **Tailwind vs CSS 변수 기반(단일 CSS)**: 스타일 가이드가 CRT 변수/글로우를 강하게 요구 → Tailwind 대신 CSS 변수

## 4. 리스크 요약 (현실적)

- **LLM 출력 불안정(스키마/일관성)**: JSON Schema 강제 + 서버/클라 이중 검증 + 자동 repair + 안전한 폴백(텍스트-only)
- **비용/지연(특히 이미지/Thinking)**: 재화 시스템으로 호출량 제어 + 텍스트(Flash/Pro) 티어링 + 이미지 호출 빈도/해상도 정책 + Lazy image loading
- **Gemini 3 제약 + 데모 기능 노출 위험**: 공식 SDK 사용(시그니처 자동 처리) + tool 설계 분리 + 데모 프로필은 데모/스테이징에서만 활성화

## 5. 레퍼런스 링크 모음 (핵심)

- **PRD/가이드**: `vibe/prd.md`, `vibe/ref/standard-guide.md`, `vibe/ref/frontend-style-guide.md`
- **Frontend**: [React](https://react.dev/), [Vite](https://vitejs.dev/), [TypeScript](https://www.typescriptlang.org/), [Zod](https://zod.dev/), [Zustand](https://zustand-demo.pmnd.rs/), [dnd-kit](https://docs.dndkit.com/), [i18next](https://www.i18next.com/), [react-i18next](https://react.i18next.com/)
- **Backend**: [FastAPI](https://fastapi.tiangolo.com/), [Uvicorn](https://www.uvicorn.org/), [Pydantic](https://docs.pydantic.dev/)
- **Streaming**: [MDN: Server-sent events](https://developer.mozilla.org/en-US/docs/Web/API/Server-sent_events)
- **Gemini / Structured Outputs**: [Gemini API](https://ai.google.dev/docs), [Text generation](https://ai.google.dev/gemini-api/docs/text-generation), [Structured outputs](https://ai.google.dev/gemini-api/docs/structured-output), [Image generation](https://ai.google.dev/gemini-api/docs/image-generation), [Image understanding](https://ai.google.dev/gemini-api/docs/image-understanding)
- **GCP**: [Vertex AI](https://cloud.google.com/vertex-ai), [Service accounts](https://cloud.google.com/iam/docs/service-accounts), [Cloud Run](https://cloud.google.com/run), [Cloud Storage](https://cloud.google.com/storage/docs)

## 6. 팀 온보딩 체크리스트 (간단)

- **1) 제품/UX 이해**: PRD 6~9장(게임 UI·경제·Autopilot) 훑고 “채팅 UI 금지” 원칙 공유
- **2) 구조화 출력 이해**: TurnOutput을 “JSON Schema 우선”으로 생각(텍스트는 UI용 필드)
- **3) 모델 운영 감각**: Flash/Pro 티어, 이미지 편집은 Pro+시그니처가 핵심임을 숙지
- **4) 스트리밍 UX 합의**: HTTP Streaming 기준으로 TTFB/단계 배지(Queue/Badges) 표준화
- **5) GCP 권한 세팅**: 서비스 계정/Vertex AI 권한/배포 런타임(Cloud Run) 확인
- **6) 데모 시나리오 리플레이**: “드래그→클릭→룰 변형→엔딩 리포트” 10분 루프를 팀 공통 기준으로 고정
- **(필수) 데모 프로필 점검**: 3종 프리셋이 “즉시 시작/즉시 리셋” 동작하는지 데모 전 확인
</file>

<file path="frontend/src/api/turnStream.ts">
/**
 * Unknown World - HTTP Streaming 클라이언트 + NDJSON 파서.
 *
 * fetch 기반으로 POST 요청을 보내고 응답 스트림을 NDJSON으로 파싱합니다.
 * 중간 청크 파싱 실패가 전체 UI를 멈추지 않도록 설계되었습니다.
 *
 * 설계 원칙:
 *   - RULE-003: 구조화 출력(JSON Schema) 우선 + 이중 검증
 *   - RULE-004: 검증 실패 시 안전 폴백 제공
 *   - RULE-008: 단계/배지 가시화 (프롬프트/내부 추론 노출 금지)
 *   - RULE-011: 백엔드 포트 8011 사용
 *
 * @module api/turnStream
 */

import type { TurnInput, TurnOutput, Language } from '../schemas/turn';
import { safeParseTurnOutput } from '../schemas/turn';
import type { StreamCallbacks } from '../types/turn_stream';
import {
  StreamEventType,
  BaseEventSchema,
  safeParseStageEvent,
  safeParseRepairEvent,
  safeParseBadgesEvent,
  safeParseNarrativeDeltaEvent,
  safeParseFinalEventRaw,
  safeParseErrorEvent,
  normalizeStageStatus,
} from '../types/turn_stream';

// Re-export 스트림 이벤트 타입들 (하위 호환성 유지)
export type {
  StreamEventTypeName,
  StageStatusName,
  StageEvent,
  RepairEvent,
  BadgesEvent,
  NarrativeDeltaEvent,
  FinalEvent,
  ErrorEvent,
  StreamEvent,
  StreamCallbacks,
} from '../types/turn_stream';
export { StreamEventType, StageStatus } from '../types/turn_stream';

// =============================================================================
// NDJSON 파서 (Q1 결정: Option A - 직접 구현)
// =============================================================================

/**
 * NDJSON 라인 파서.
 * 부분 청크를 버퍼링하고 완전한 라인을 파싱합니다.
 */
export class NDJSONParser {
  private buffer = '';

  /**
   * 청크를 파싱하고 완전한 JSON 객체들을 반환합니다.
   *
   * @param chunk - 수신된 텍스트 청크
   * @returns 파싱된 JSON 객체 배열
   */
  parse(chunk: string): unknown[] {
    this.buffer += chunk;
    const results: unknown[] = [];

    // 줄바꿈으로 분할
    const lines = this.buffer.split('\n');

    // 마지막 라인은 불완전할 수 있으므로 버퍼에 유지
    this.buffer = lines.pop() ?? '';

    for (const line of lines) {
      const trimmed = line.trim();
      if (trimmed === '') continue;

      try {
        const parsed = JSON.parse(trimmed);
        results.push(parsed);
      } catch {
        // 파싱 실패 시 해당 라인 무시 (RULE-004: 전체 중단 방지)
        console.warn('[NDJSON] Failed to parse line:', trimmed);
      }
    }

    return results;
  }

  /**
   * 버퍼를 초기화합니다.
   */
  reset(): void {
    this.buffer = '';
  }

  /**
   * 남은 버퍼를 플러시하고 마지막 객체를 파싱합니다.
   */
  flush(): unknown | null {
    const trimmed = this.buffer.trim();
    this.buffer = '';

    if (trimmed === '') return null;

    try {
      return JSON.parse(trimmed);
    } catch {
      console.warn('[NDJSON] Failed to parse remaining buffer:', trimmed);
      return null;
    }
  }
}

// =============================================================================
// 스트림 이벤트 핸들러
// =============================================================================

/**
 * 파싱된 이벤트를 타입별로 분배합니다.
 *
 * RU-002-S2: 캐스팅 대신 Zod safeParse를 적용하여 검증 강화.
 * Unknown/확장 이벤트는 UI를 멈추지 않고 경고만 출력.
 *
 * @param event - 파싱된 이벤트 객체
 * @param callbacks - 콜백 함수들
 * @param language - 폴백 언어
 */
function dispatchEvent(event: unknown, callbacks: StreamCallbacks, language: Language): void {
  if (!event || typeof event !== 'object') return;

  // 기본 이벤트 타입 추출
  const baseResult = BaseEventSchema.safeParse(event);
  if (!baseResult.success) {
    console.warn('[TurnStream] Invalid event format (no type field):', event);
    return;
  }

  const type = baseResult.data.type;

  switch (type) {
    case StreamEventType.STAGE: {
      // RU-002-S2: stage 이벤트 검증
      const stageResult = safeParseStageEvent(event);
      if (stageResult.success) {
        // status 정규화: 'ok' → 'complete'
        const normalizedStatus = normalizeStageStatus(stageResult.data.status);
        callbacks.onStage?.({
          type: StreamEventType.STAGE,
          name: stageResult.data.name,
          status: normalizedStatus,
        });
      } else {
        console.warn('[TurnStream] Invalid stage event:', stageResult.error.message);
      }
      break;
    }

    case StreamEventType.REPAIR: {
      // RU-002-S2: repair 이벤트 검증
      const repairResult = safeParseRepairEvent(event);
      if (repairResult.success) {
        callbacks.onRepair?.(repairResult.data);
      } else {
        console.warn('[TurnStream] Invalid repair event:', repairResult.error.message);
      }
      break;
    }

    case StreamEventType.BADGES: {
      // RU-002-S2: badges 이벤트 검증 (v1/v2 정규화 포함)
      const badgesResult = safeParseBadgesEvent(event);
      if (badgesResult.success) {
        callbacks.onBadges?.(badgesResult.data);
      } else {
        console.warn('[TurnStream] Invalid badges event:', badgesResult.error.message);
      }
      break;
    }

    case StreamEventType.NARRATIVE_DELTA: {
      // RU-002-S2: narrative_delta 이벤트 검증
      const narrativeResult = safeParseNarrativeDeltaEvent(event);
      if (narrativeResult.success) {
        callbacks.onNarrativeDelta?.(narrativeResult.data);
      } else {
        console.warn('[TurnStream] Invalid narrative_delta event:', narrativeResult.error.message);
      }
      break;
    }

    case StreamEventType.FINAL: {
      // RU-002-S2: final 이벤트 구조 검증
      const finalRawResult = safeParseFinalEventRaw(event);
      if (!finalRawResult.success) {
        console.warn('[TurnStream] Invalid final event structure:', finalRawResult.error.message);
        // 구조가 잘못되어도 폴백 제공
        callbacks.onFinal?.({
          type: StreamEventType.FINAL,
          data: createFallbackTurnOutput(language),
        });
        break;
      }

      // RULE-003/004: Zod strict parse + 폴백
      const turnOutputPayload = finalRawResult.data.data;
      const parseResult = safeParseTurnOutput(turnOutputPayload, language);

      if (parseResult.success) {
        callbacks.onFinal?.({
          type: StreamEventType.FINAL,
          data: parseResult.data,
        });
      } else {
        console.warn('[TurnStream] TurnOutput validation failed:', parseResult.error);
        callbacks.onFinal?.({
          type: StreamEventType.FINAL,
          data: parseResult.fallback,
        });
      }
      break;
    }

    case StreamEventType.ERROR: {
      // RU-002-S2: error 이벤트 검증
      const errorResult = safeParseErrorEvent(event);
      if (errorResult.success) {
        callbacks.onError?.(errorResult.data);
      } else {
        console.warn('[TurnStream] Invalid error event:', errorResult.error.message);
        // 에러 이벤트가 깨진 경우에도 기본 에러 전달
        callbacks.onError?.({
          type: StreamEventType.ERROR,
          message: 'Unknown error (malformed error event)',
          code: 'INVALID_ERROR_EVENT',
        });
      }
      break;
    }

    default:
      // RU-002-S2: Unknown/확장 이벤트는 UI를 멈추지 않고 경고만 출력
      // 향후 protocol, repair, telemetry 등 확장 이벤트 도입 시 여기서 처리 가능
      console.warn('[TurnStream] Unknown/ignored event type:', type, event);
  }
}

/**
 * 클라이언트 측 폴백 TurnOutput 생성 (언어만 지정).
 * dispatchEvent 내부에서 사용하는 간단한 폴백.
 */
function createFallbackTurnOutput(language: Language): TurnOutput {
  const fallbackNarrative =
    language === 'ko-KR'
      ? '[시스템] 응답 데이터를 처리하는 중 문제가 발생했습니다.'
      : '[System] An error occurred while processing response data.';

  return {
    language,
    narrative: fallbackNarrative,
    economy: {
      cost: { signal: 0, memory_shard: 0 },
      balance_after: { signal: 0, memory_shard: 0 },
    },
    safety: {
      blocked: false,
      message: null,
    },
    ui: {
      action_deck: { cards: [] },
      objects: [],
    },
    world: {
      rules_changed: [],
      inventory_added: [],
      inventory_removed: [],
      quests_updated: [],
      relationships_changed: [],
      memory_pins: [],
    },
    render: {
      image_job: null,
    },
    agent_console: {
      current_phase: 'commit',
      badges: ['schema_fail'],
      repair_count: 1,
    },
  };
}

// =============================================================================
// API 설정
// =============================================================================

/** 백엔드 API URL (RULE-011: 포트 8011) */
const API_BASE_URL = 'http://localhost:8011';

/** 턴 스트림 API 엔드포인트 */
const TURN_ENDPOINT = `${API_BASE_URL}/api/turn`;

// =============================================================================
// 스트림 클라이언트
// =============================================================================

/** 스트림 요청 옵션 */
export interface TurnStreamOptions {
  /** 요청 타임아웃 (ms) */
  timeout?: number;
  /** AbortSignal */
  signal?: AbortSignal;
}

/**
 * 턴 스트림 요청을 실행합니다.
 *
 * @param input - 턴 입력 데이터
 * @param callbacks - 이벤트 콜백
 * @param options - 요청 옵션
 * @returns 취소 함수
 */
export async function executeTurnStream(
  input: TurnInput,
  callbacks: StreamCallbacks,
  options?: TurnStreamOptions,
): Promise<void> {
  const parser = new NDJSONParser();
  const controller = new AbortController();
  const signal = options?.signal ?? controller.signal;

  // RU-002-S1: AbortError 발생 시 onComplete 호출 여부 추적
  let aborted = false;

  try {
    const response = await fetch(TURN_ENDPOINT, {
      method: 'POST',
      headers: {
        'Content-Type': 'application/json',
        Accept: 'application/x-ndjson',
      },
      body: JSON.stringify(input),
      signal,
    });

    if (!response.ok) {
      throw new Error(`HTTP ${response.status}: ${response.statusText}`);
    }

    if (!response.body) {
      throw new Error('Response body is null');
    }

    const reader = response.body.getReader();
    const decoder = new TextDecoder('utf-8');

    // 스트림 읽기 루프
    while (true) {
      const { done, value } = await reader.read();

      if (done) break;

      const chunk = decoder.decode(value, { stream: true });
      const events = parser.parse(chunk);

      for (const event of events) {
        dispatchEvent(event, callbacks, input.language);
      }
    }

    // 남은 버퍼 플러시
    const remaining = parser.flush();
    if (remaining) {
      dispatchEvent(remaining, callbacks, input.language);
    }
  } catch (error) {
    if (error instanceof DOMException && error.name === 'AbortError') {
      // 사용자가 취소한 경우 - finally에서 onComplete 호출하지 않음
      aborted = true;
      return;
    }

    const errorMessage = error instanceof Error ? error.message : 'Unknown error occurred';

    // RU-002-S1: 네트워크 에러 시에도 onError 호출
    callbacks.onError?.({
      type: StreamEventType.ERROR,
      message: errorMessage,
      code: 'STREAM_ERROR',
    });

    // RU-002-S1: 네트워크 에러 시 클라이언트 측 폴백 final 생성
    // 서버에서 final이 오지 못한 경우 UI가 멈추지 않도록 함
    const fallback = createClientFallbackTurnOutput(input.language, input.economy_snapshot);
    callbacks.onFinal?.({
      type: StreamEventType.FINAL,
      data: fallback,
    });
  } finally {
    // RU-002-S1: 스트림 종료 인바리언트 - 성공/실패 모두에서 onComplete 호출 보장
    if (!aborted) {
      callbacks.onComplete?.();
    }
  }
}

/**
 * 클라이언트 측 폴백 TurnOutput 생성 (RU-002-S1).
 * 서버에서 final이 오지 못한 경우 (네트워크 에러 등) 사용합니다.
 * Economy는 요청 직전 스냅샷을 그대로 유지합니다.
 */
function createClientFallbackTurnOutput(
  language: Language,
  economySnapshot: { signal: number; memory_shard: number },
): TurnOutput {
  const fallbackNarrative =
    language === 'ko-KR'
      ? '[시스템] 서버 연결에 실패했습니다. 다시 시도해 주세요.'
      : '[System] Failed to connect to server. Please try again.';

  return {
    language,
    narrative: fallbackNarrative,
    economy: {
      cost: { signal: 0, memory_shard: 0 },
      // RU-002-S1: 입력 스냅샷 그대로 유지 (비용 0, 잔액 변화 없음)
      balance_after: {
        signal: economySnapshot.signal,
        memory_shard: economySnapshot.memory_shard,
      },
    },
    safety: {
      blocked: false,
      message: null,
    },
    ui: {
      action_deck: { cards: [] },
      objects: [],
    },
    world: {
      rules_changed: [],
      inventory_added: [],
      inventory_removed: [],
      quests_updated: [],
      relationships_changed: [],
      memory_pins: [],
    },
    render: {
      image_job: null,
    },
    agent_console: {
      current_phase: 'commit',
      badges: ['schema_fail'],
      repair_count: 1,
    },
  };
}

/**
 * 턴 스트림을 시작하고 취소 함수를 반환합니다.
 *
 * @param input - 턴 입력 데이터
 * @param callbacks - 이벤트 콜백
 * @returns 취소 함수
 */
export function startTurnStream(input: TurnInput, callbacks: StreamCallbacks): () => void {
  const controller = new AbortController();

  executeTurnStream(input, callbacks, { signal: controller.signal });

  return () => controller.abort();
}
</file>

<file path="frontend/src/App.tsx">
/**
 * Unknown World - 메인 게임 UI 레이아웃
 *
 * RULE-002 준수: 채팅 버블 UI 금지
 * - 내러티브는 "채팅"이 아니라 "게임 로그/내러티브 피드" 형태
 * - 고정 패널: Scene Canvas, Action Deck, Inventory, Quest,
 *   Rule Board, Economy HUD, Agent Console, Scanner Slot
 *
 * RULE-008: Agent Console에서 단계/배지/복구만 표시 (프롬프트 노출 금지)
 *
 * @see vibe/ref/frontend-style-guide.md
 * @see vibe/prd.md 6.7/6.8/9장
 */

import { useState, useCallback, useRef, useEffect } from 'react';
import { AgentConsole } from './components/AgentConsole';
import { SceneCanvas } from './components/SceneCanvas';
import type { SceneCanvasState } from './types/scene';
import { useAgentStore } from './stores/agentStore';
import { useUIPrefsStore, applyUIPrefsToDOM, UI_SCALES, type UIScale } from './stores/uiPrefsStore';
import { startTurnStream, type StreamCallbacks } from './api/turnStream';
import type { TurnInput, TurnOutput, ActionCard } from './schemas/turn';

// =============================================================================
// 타입 정의
// =============================================================================

interface NarrativeEntry {
  turn: number;
  text: string;
}

// =============================================================================
// 패널 컴포넌트
// =============================================================================

interface PanelProps {
  title: string;
  children?: React.ReactNode;
  className?: string;
  /** U-032: Chrome 장식 적용 여부 */
  hasChrome?: boolean;
}

function Panel({ title, children, className = '', hasChrome = false }: PanelProps) {
  const panelClass = `panel ${className} ${hasChrome ? 'has-chrome' : ''}`.trim();
  const headerClass = `panel-header ${hasChrome ? 'has-chrome' : ''}`.trim();

  return (
    <div className={panelClass}>
      <div className={headerClass}>
        <span className="panel-title">{title}</span>
      </div>
      <div className="panel-content">
        {children || <p className="panel-placeholder">[ 준비 중 ]</p>}
      </div>
    </div>
  );
}

// =============================================================================
// 내러티브 피드 컴포넌트
// =============================================================================

interface NarrativeFeedProps {
  entries: NarrativeEntry[];
  streamingText: string;
}

function NarrativeFeed({ entries, streamingText }: NarrativeFeedProps) {
  const feedRef = useRef<HTMLDivElement>(null);

  // 새 엔트리 추가 시 스크롤
  useEffect(() => {
    if (feedRef.current) {
      feedRef.current.scrollTop = feedRef.current.scrollHeight;
    }
  }, [entries, streamingText]);

  return (
    <div className="narrative-feed" ref={feedRef}>
      {entries.map((entry) => (
        <div key={entry.turn} className="narrative-entry">
          <span className="narrative-timestamp">[TURN {entry.turn}]</span>
          <span className="narrative-text">{entry.text}</span>
        </div>
      ))}
      {streamingText && (
        <div className="narrative-entry streaming">
          <span className="narrative-timestamp">[STREAMING]</span>
          <span className="narrative-text">{streamingText}</span>
          <span className="cursor-blink">▌</span>
        </div>
      )}
    </div>
  );
}

// =============================================================================
// 액션 덱 컴포넌트
// =============================================================================

interface ActionDeckProps {
  cards: ActionCard[];
  onCardClick?: (card: ActionCard) => void;
  disabled?: boolean;
}

function ActionDeck({ cards, onCardClick, disabled }: ActionDeckProps) {
  // 카드가 없으면 기본 카드 표시
  const displayCards: ActionCard[] =
    cards.length > 0
      ? cards
      : [
          {
            id: 'default-1',
            label: '탐색하기',
            description: '주변을 살펴본다',
            cost: { signal: 1, memory_shard: 0 },
            risk: 'low',
            hint: null,
          },
          {
            id: 'default-2',
            label: '조사하기',
            description: '자세히 살펴본다',
            cost: { signal: 2, memory_shard: 0 },
            risk: 'medium',
            hint: null,
          },
          {
            id: 'default-3',
            label: '대화하기',
            description: '말을 걸어본다',
            cost: { signal: 1, memory_shard: 0 },
            risk: 'low',
            hint: null,
          },
        ];

  return (
    <div className="action-deck">
      {displayCards.map((card) => (
        <button
          key={card.id}
          type="button"
          className="action-card has-chrome"
          onClick={() => onCardClick?.(card)}
          disabled={disabled}
        >
          <div className="action-card-title">{card.label}</div>
          <div className="action-card-cost">
            <span className="icon-wrapper" aria-label="Signal cost">
              <img
                src="/ui/icons/signal-24.png"
                alt=""
                aria-hidden="true"
                className="icon-img"
                style={{ width: 14, height: 14 }}
                onError={(e) => e.currentTarget.classList.add('hidden')}
              />
              <span className="icon-fallback">⚡</span>
            </span>{' '}
            {card.cost.signal}
            {card.cost.memory_shard > 0 && (
              <>
                {' | '}
                <span className="icon-wrapper" aria-label="Shard cost">
                  <img
                    src="/ui/icons/shard-24.png"
                    alt=""
                    aria-hidden="true"
                    className="icon-img"
                    style={{ width: 14, height: 14 }}
                    onError={(e) => e.currentTarget.classList.add('hidden')}
                  />
                  <span className="icon-fallback">💎</span>
                </span>{' '}
                {card.cost.memory_shard}
              </>
            )}
            {' | '}
            <span className="icon-wrapper" aria-label="Risk level">
              <img
                src={`/ui/icons/risk-${card.risk}-16.png`}
                alt=""
                aria-hidden="true"
                className={`icon-img risk-${card.risk}`}
                style={{ width: 14, height: 14 }}
                onError={(e) => e.currentTarget.classList.add('hidden')}
              />
              <span className="icon-fallback">⚠</span>
            </span>{' '}
            {card.risk}
          </div>
        </button>
      ))}
    </div>
  );
}

// =============================================================================
// UI 컨트롤 컴포넌트 (U-028: 가독성 패스)
// =============================================================================

interface UIControlsProps {
  uiScale: UIScale;
  readableMode: boolean;
  onIncreaseScale: () => void;
  onDecreaseScale: () => void;
  onToggleReadable: () => void;
}

function UIControls({
  uiScale,
  readableMode,
  onIncreaseScale,
  onDecreaseScale,
  onToggleReadable,
}: UIControlsProps) {
  const isMinScale = uiScale === UI_SCALES[0];
  const isMaxScale = uiScale === UI_SCALES[UI_SCALES.length - 1];

  return (
    <div className="ui-controls" role="group" aria-label="UI 가독성 설정">
      {/* UI 스케일 조절 */}
      <button
        type="button"
        className="ui-scale-btn"
        onClick={onDecreaseScale}
        disabled={isMinScale}
        aria-label="글자 크기 줄이기"
        title="글자 크기 줄이기 (A-)"
      >
        A-
      </button>
      <span className="ui-scale-display" aria-live="polite">
        {Math.round(uiScale * 100)}%
      </span>
      <button
        type="button"
        className="ui-scale-btn"
        onClick={onIncreaseScale}
        disabled={isMaxScale}
        aria-label="글자 크기 늘리기"
        title="글자 크기 늘리기 (A+)"
      >
        A+
      </button>

      <div className="ui-controls-separator" aria-hidden="true" />

      {/* Readable 모드 토글 */}
      <button
        type="button"
        className="readable-toggle-btn"
        onClick={onToggleReadable}
        aria-pressed={readableMode}
        aria-label={readableMode ? 'Readable 모드 끄기' : 'Readable 모드 켜기'}
        title="Readable 모드 (CRT 효과 완화)"
      >
        {readableMode ? '◉ READ' : '○ READ'}
      </button>
    </div>
  );
}

// =============================================================================
// 헤더 컴포넌트
// =============================================================================

interface GameHeaderProps {
  signal: number;
  memoryShard: number;
  isConnected: boolean;
  uiScale: UIScale;
  readableMode: boolean;
  onIncreaseScale: () => void;
  onDecreaseScale: () => void;
  onToggleReadable: () => void;
}

function GameHeader({
  signal,
  memoryShard,
  isConnected,
  uiScale,
  readableMode,
  onIncreaseScale,
  onDecreaseScale,
  onToggleReadable,
}: GameHeaderProps) {
  return (
    <header className="game-header has-chrome">
      <h1 className="game-title glitch" data-text="UNKNOWN WORLD">
        UNKNOWN WORLD
      </h1>
      <div className="header-controls">
        {/* UI 가독성 컨트롤 (U-028) */}
        <UIControls
          uiScale={uiScale}
          readableMode={readableMode}
          onIncreaseScale={onIncreaseScale}
          onDecreaseScale={onDecreaseScale}
          onToggleReadable={onToggleReadable}
        />
        <div className="economy-hud">
          <span className="icon-wrapper signal-icon" aria-label="Signal">
            <img
              src="/ui/icons/signal-24.png"
              alt=""
              aria-hidden="true"
              className="icon-img"
              onError={(e) => {
                e.currentTarget.classList.add('hidden');
              }}
            />
            <span className="icon-fallback">⚡</span>
          </span>
          <span>Signal: {signal}</span>
          <span className="icon-wrapper shard-icon" aria-label="Memory Shard">
            <img
              src="/ui/icons/shard-24.png"
              alt=""
              aria-hidden="true"
              className="icon-img"
              onError={(e) => {
                e.currentTarget.classList.add('hidden');
              }}
            />
            <span className="icon-fallback">💎</span>
          </span>
          <span>Shard: {memoryShard}</span>
        </div>
        <div className="connection-status">
          <span className={`status-indicator ${isConnected ? '' : 'offline'}`} />
          <span>{isConnected ? 'ONLINE' : 'OFFLINE'}</span>
        </div>
      </div>
    </header>
  );
}

// =============================================================================
// 메인 App 컴포넌트
// =============================================================================

function App() {
  // 상태
  const [inputText, setInputText] = useState('');
  const turnCountRef = useRef(0);
  const [narrativeEntries, setNarrativeEntries] = useState<NarrativeEntry[]>([
    { turn: 0, text: '미지의 세계에 오신 것을 환영합니다...' },
  ]);
  const [actionCards, setActionCards] = useState<ActionCard[]>([]);
  const [economy, setEconomy] = useState({ signal: 100, memory_shard: 5 });
  const [isConnected, setIsConnected] = useState(true);

  // Scene Canvas 상태 (U-031: Placeholder Pack)
  const [sceneState, setSceneState] = useState<SceneCanvasState>({
    status: 'default',
    message: '전역 데이터 동기화 대기 중...',
  });

  // Agent Store 액션
  const {
    startStream,
    handleStage,
    handleBadges,
    handleNarrativeDelta,
    handleFinal,
    handleError,
    completeStream,
    isStreaming,
    narrativeBuffer,
  } = useAgentStore();

  // UI Prefs Store (U-028: 가독성 패스)
  const { uiScale, readableMode, increaseUIScale, decreaseUIScale, toggleReadableMode } =
    useUIPrefsStore();

  // DOM에 UI 설정 적용 (U-028)
  useEffect(() => {
    applyUIPrefsToDOM({ uiScale, readableMode });
  }, [uiScale, readableMode]);

  // 취소 함수 ref
  const cancelStreamRef = useRef<(() => void) | null>(null);

  /**
   * TurnOutput을 받아 UI 상태를 업데이트합니다.
   */
  const applyTurnOutput = useCallback((output: TurnOutput) => {
    // 내러티브 추가
    turnCountRef.current += 1;
    const newTurn = turnCountRef.current;
    setNarrativeEntries((entries) => [...entries, { turn: newTurn, text: output.narrative }]);

    // 액션 카드 업데이트
    if (output.ui.action_deck.cards.length > 0) {
      setActionCards(output.ui.action_deck.cards);
    }

    // 경제 상태 업데이트 (RULE-005: 잔액 반영)
    setEconomy({
      signal: output.economy.balance_after.signal,
      memory_shard: output.economy.balance_after.memory_shard,
    });
  }, []);

  /**
   * 턴을 실행합니다.
   */
  const executeTurn = useCallback(
    (text: string, cardId?: string) => {
      if (isStreaming) return;

      // 입력 데이터 생성
      const turnInput: TurnInput = {
        language: 'ko-KR',
        text: text || (cardId ? `카드 선택: ${cardId}` : ''),
        click: null,
        client: {
          viewport_w: window.innerWidth,
          viewport_h: window.innerHeight,
          theme: 'dark',
        },
        economy_snapshot: economy,
      };

      // Agent Store 시작
      startStream();

      // Scene Canvas를 로딩 상태로 전환 (U-031)
      setSceneState({ status: 'loading', message: '데이터 동기화 중...' });

      // 스트림 콜백 설정
      const callbacks: StreamCallbacks = {
        onStage: handleStage,
        onBadges: handleBadges,
        onNarrativeDelta: handleNarrativeDelta,
        onFinal: (event) => {
          handleFinal(event);
          applyTurnOutput(event.data);
        },
        onError: (event) => {
          handleError(event);
          setIsConnected(false);
          // Scene Canvas를 오프라인/에러 상태로 전환 (U-031)
          const errorCode = event.code;
          if (errorCode === 'SAFETY_BLOCKED') {
            setSceneState({ status: 'blocked', message: event.message });
          } else if (errorCode === 'INSUFFICIENT_BALANCE') {
            setSceneState({ status: 'low_signal', message: event.message });
          } else {
            setSceneState({ status: 'offline', message: event.message });
          }
        },
        onComplete: () => {
          completeStream();
          // Scene Canvas를 기본 상태로 복원 (U-031)
          // TODO: TurnOutput에 scene.imageUrl이 있으면 scene 상태로 전환
          setSceneState({ status: 'default', message: '' });
        },
      };

      // 스트림 시작
      cancelStreamRef.current = startTurnStream(turnInput, callbacks);
      setInputText('');
    },
    [
      isStreaming,
      economy,
      startStream,
      handleStage,
      handleBadges,
      handleNarrativeDelta,
      handleFinal,
      handleError,
      completeStream,
      applyTurnOutput,
    ],
  );

  /**
   * 입력 제출 핸들러
   */
  const handleSubmit = useCallback(() => {
    if (inputText.trim()) {
      executeTurn(inputText.trim());
    }
  }, [inputText, executeTurn]);

  /**
   * 카드 클릭 핸들러
   */
  const handleCardClick = useCallback(
    (card: ActionCard) => {
      executeTurn(card.label, card.id);
    },
    [executeTurn],
  );

  /**
   * 키보드 이벤트 핸들러
   */
  const handleKeyDown = useCallback(
    (e: React.KeyboardEvent) => {
      if (e.key === 'Enter' && !e.shiftKey) {
        e.preventDefault();
        handleSubmit();
      }
    },
    [handleSubmit],
  );

  // 컴포넌트 언마운트 시 스트림 취소
  useEffect(() => {
    return () => {
      cancelStreamRef.current?.();
    };
  }, []);

  return (
    <>
      {/* CRT 스캔라인 오버레이 */}
      <div className="crt-overlay" aria-hidden="true" />

      {/* 게임 레이아웃 */}
      <div className="game-container">
        {/* Header: 타이틀/상태/재화/UI컨트롤 */}
        <GameHeader
          signal={economy.signal}
          memoryShard={economy.memory_shard}
          isConnected={isConnected}
          uiScale={uiScale}
          readableMode={readableMode}
          onIncreaseScale={increaseUIScale}
          onDecreaseScale={decreaseUIScale}
          onToggleReadable={toggleReadableMode}
        />

        {/* Sidebar Left: Inventory / Quest / Rule Board */}
        <aside className="sidebar-left">
          <Panel title="Inventory" className="flex-1">
            <p className="panel-placeholder">[ 드래그 앤 드롭 영역 ]</p>
          </Panel>
          <Panel title="Quest">
            <p className="panel-placeholder">[ 목표/퀘스트 목록 ]</p>
          </Panel>
          <Panel title="Rule Board">
            <p className="panel-placeholder">[ 월드 규칙/변형 타임라인 ]</p>
          </Panel>
        </aside>

        {/* Center: Scene Canvas + Narrative Feed */}
        <main className="game-center">
          <SceneCanvas state={sceneState} />
          <NarrativeFeed entries={narrativeEntries} streamingText={narrativeBuffer} />
        </main>

        {/* Sidebar Right: Agent Console / Memory Pin / Scanner */}
        <aside className="sidebar-right">
          <Panel title="Agent Console" className="flex-1" hasChrome>
            <AgentConsole />
          </Panel>
          <Panel title="Memory Pin" hasChrome>
            <p className="panel-placeholder">[ 고정된 기억/단서 ]</p>
          </Panel>
          <Panel title="Scanner" hasChrome>
            <div className="scanner-slot has-chrome">
              <p className="panel-placeholder">[ 이미지 업로드 슬롯 ]</p>
            </div>
          </Panel>
        </aside>

        {/* Footer: Action Deck + Command Input */}
        <footer className="game-footer">
          <ActionDeck cards={actionCards} onCardClick={handleCardClick} disabled={isStreaming} />
          <div className="command-input-area">
            <span className="command-prompt">&gt;</span>
            <input
              type="text"
              className="command-input"
              placeholder={isStreaming ? '처리 중...' : '명령을 입력하세요...'}
              aria-label="게임 명령 입력"
              value={inputText}
              onChange={(e) => setInputText(e.target.value)}
              onKeyDown={handleKeyDown}
              disabled={isStreaming}
            />
            <button type="button" onClick={handleSubmit} disabled={isStreaming}>
              {isStreaming ? 'WAIT' : 'EXECUTE'}
            </button>
          </div>
        </footer>
      </div>
    </>
  );
}

export default App;
</file>

<file path="frontend/src/style.css">
/**
 * Unknown World - CRT 테마 스타일시트 (단일 CSS SSOT)
 *
 * RULE-002 준수: 채팅 버블 UI 금지 - 게임 로그/HUD 형태만 허용
 * Frontend Style Guide 준수: CRT 터미널 레트로 미학
 *
 * @see vibe/ref/frontend-style-guide.md
 */

/* ============================================
   1. CRT 테마 토큰 (CSS Variables)
   ============================================ */
:root {
  /* 기본 색상 - CRT 인광 녹색 테마 */
  --bg-color: #0d0d0d; /* 배경: 거의 순수한 검정 */
  --text-color: #33ff00; /* 주 텍스트: 인광 녹색 (CRT 그린) */
  --text-dim: #1a8000; /* 보조 텍스트: 어두운 녹색 */
  --accent-color: #ff00ff; /* 강조색: 마젠타 */
  --border-color: #33ff00; /* 테두리: 인광 녹색 */
  --panel-bg: rgba(0, 20, 0, 0.3); /* 패널 배경: 투명 녹색 */
  --warning-color: #ffaa00; /* 경고: 주황색 */
  --error-color: #ff3333; /* 에러: 붉은색 */

  /* CRT 효과 */
  --crt-scanline: rgba(18, 16, 16, 0.1);
  --crt-flicker: 0.03;
  --glow-intensity: 5px;
  --crt-flicker-opacity-min: 0.97;
  --crt-flicker-opacity-max: 1;

  /* 타이포그래피 */
  --font-main: 'NeoDunggeunmo', 'VT323', monospace;
  --font-size-base: 16px;
  --font-size-lg: 1.2rem;
  --font-size-xl: 1.5rem;
  --font-size-2xl: 2rem;
  --line-height-base: 1.5;

  /* 마이크로 텍스트 (U-028: 가독성 상향) */
  --font-size-xs: 0.75rem; /* 12px at 1.0 scale - 최소 마이크로 텍스트 */
  --font-size-sm: 0.875rem; /* 14px at 1.0 scale - 작은 텍스트 */

  /* UI 스케일 (U-028: 전역 스케일 조절) */
  --ui-scale-factor: 1;

  /* 레이아웃 */
  --spacing-xs: 4px;
  --spacing-sm: 8px;
  --spacing-md: 16px;
  --spacing-lg: 24px;
  --spacing-xl: 32px;
  --border-radius: 4px;
  --max-width: 1400px;

  /* 그리드 레이아웃 */
  --header-height: 60px;
  --footer-height: 120px;
  --sidebar-width: 320px;
}

/* ============================================
   2. 폰트 정의
   ============================================ */
@font-face {
  font-family: 'NeoDunggeunmo';
  src: url('https://cdn.jsdelivr.net/gh/projectnoonnu/noonfonts_2001@1.3/NeoDunggeunmo.woff')
    format('woff');
  font-weight: normal;
  font-display: swap;
}

/* ============================================
   3. Reset & Base
   ============================================ */
*,
*::before,
*::after {
  box-sizing: border-box;
  margin: 0;
  padding: 0;
}

html {
  /* U-028: UI 스케일 적용 - font-size가 스케일 팩터에 반응 */
  font-size: calc(var(--font-size-base) * var(--ui-scale-factor));
  line-height: var(--line-height-base);
}

body {
  font-family: var(--font-main);
  background-color: var(--bg-color);
  color: var(--text-color);
  min-height: 100vh;
  overflow: hidden;
  text-shadow: 0 0 var(--glow-intensity) var(--text-dim);
}

#root {
  min-height: 100vh;
  display: flex;
  flex-direction: column;
}

/* ============================================
   4. CRT 오버레이 효과
   ============================================ */

/* 스캔라인 오버레이 */
.crt-overlay {
  position: fixed;
  top: 0;
  left: 0;
  width: 100vw;
  height: 100vh;
  background: linear-gradient(rgba(18, 16, 16, 0) 50%, rgba(0, 0, 0, 0.25) 50%);
  background-size: 100% 4px;
  pointer-events: none;
  z-index: 9999;
  animation: flicker 0.15s infinite;
}

/* 플리커(깜빡임) 애니메이션 */
@keyframes flicker {
  0% {
    opacity: 0.97;
  }
  50% {
    opacity: 1;
  }
  100% {
    opacity: 0.98;
  }
}

/* 글리치 효과 (타이틀용) */
.glitch {
  position: relative;
}

.glitch::before,
.glitch::after {
  content: attr(data-text);
  position: absolute;
  top: 0;
  left: 0;
  width: 100%;
  height: 100%;
}

.glitch::before {
  left: 2px;
  text-shadow: -1px 0 #ff0000;
  clip-path: inset(0 0 0 0);
  animation: glitch-anim-1 5s infinite linear alternate-reverse;
}

.glitch::after {
  left: -2px;
  text-shadow: -1px 0 #0000ff;
  clip-path: inset(0 0 0 0);
  animation: glitch-anim-2 5s infinite linear alternate-reverse;
}

@keyframes glitch-anim-1 {
  0%,
  100% {
    clip-path: inset(0 0 95% 0);
  }
  20% {
    clip-path: inset(30% 0 50% 0);
  }
  40% {
    clip-path: inset(10% 0 70% 0);
  }
  60% {
    clip-path: inset(80% 0 5% 0);
  }
  80% {
    clip-path: inset(45% 0 35% 0);
  }
}

@keyframes glitch-anim-2 {
  0%,
  100% {
    clip-path: inset(95% 0 0 0);
  }
  20% {
    clip-path: inset(50% 0 30% 0);
  }
  40% {
    clip-path: inset(70% 0 10% 0);
  }
  60% {
    clip-path: inset(5% 0 80% 0);
  }
  80% {
    clip-path: inset(35% 0 45% 0);
  }
}

/* ============================================
   5. 게임 레이아웃 (CSS Grid)
   - RULE-002: 채팅 UI가 아닌 게임 UI 고정
   ============================================ */

.game-container {
  display: grid;
  grid-template-areas:
    'header header header'
    'sidebar-left center sidebar-right'
    'footer footer footer';
  grid-template-columns: var(--sidebar-width) 1fr var(--sidebar-width);
  grid-template-rows: var(--header-height) 1fr var(--footer-height);
  height: 100vh;
  width: 100%;
  max-width: var(--max-width);
  margin: 0 auto;
  padding: var(--spacing-sm);
  gap: var(--spacing-sm);
}

/* ============================================
   6. Header 영역
   - Title, Language Toggle, Theme Toggle,
     Connection Status, Economy HUD
   ============================================ */

.game-header {
  grid-area: header;
  display: flex;
  align-items: center;
  justify-content: space-between;
  padding: 0 var(--spacing-md);
  border: 1px solid var(--border-color);
  background-color: var(--panel-bg);
  box-shadow:
    inset 0 0 20px rgba(0, 0, 0, 0.5),
    0 0 10px var(--text-dim);
}

.game-title {
  font-size: var(--font-size-2xl);
  color: var(--text-color);
  text-transform: uppercase;
  letter-spacing: 4px;
}

.header-controls {
  display: flex;
  align-items: center;
  gap: var(--spacing-md);
}

.economy-hud {
  display: flex;
  align-items: center;
  gap: var(--spacing-sm);
  padding: var(--spacing-xs) var(--spacing-sm);
  border: 1px solid var(--text-dim);
  background-color: rgba(0, 0, 0, 0.5);
}

.economy-hud .signal-icon {
  color: var(--accent-color);
}

.connection-status {
  display: flex;
  align-items: center;
  gap: var(--spacing-xs);
  font-size: 0.875rem;
}

.status-indicator {
  width: 8px;
  height: 8px;
  border-radius: 50%;
  background-color: var(--text-color);
  box-shadow: 0 0 6px var(--text-color);
  animation: pulse 2s infinite;
}

.status-indicator.offline {
  background-color: var(--error-color);
  box-shadow: 0 0 6px var(--error-color);
  animation: none;
}

@keyframes pulse {
  0%,
  100% {
    opacity: 1;
  }
  50% {
    opacity: 0.5;
  }
}

/* ============================================
   7. Sidebar (Left) 영역
   - Inventory, Quest/Objective, Rule Board
   ============================================ */

.sidebar-left {
  grid-area: sidebar-left;
  display: flex;
  flex-direction: column;
  gap: var(--spacing-sm);
  overflow-y: auto;
}

/* ============================================
   8. Center 영역
   - Scene Canvas, Narrative Feed (로그 형태)
   ============================================ */

.game-center {
  grid-area: center;
  display: flex;
  flex-direction: column;
  gap: var(--spacing-sm);
  overflow: hidden;
}

.scene-canvas {
  flex: 1;
  border: 1px solid var(--border-color);
  background-color: var(--panel-bg);
  background-image: url('/ui/placeholders/scene-placeholder-default.png');
  background-size: cover;
  background-position: center;
  box-shadow: inset 0 0 20px rgba(0, 0, 0, 0.8);
  display: flex;
  align-items: center;
  justify-content: center;
  position: relative;
  min-height: 200px;
}

.scene-placeholder {
  color: var(--text-color);
  font-size: var(--font-size-lg);
  text-align: center;
  background-color: rgba(0, 0, 0, 0.6);
  padding: var(--spacing-md);
  border: 1px solid var(--text-dim);
  text-shadow: 0 0 10px var(--text-color);
}

/* U-031: Scene Canvas 상태별 placeholder 스타일 */
.scene-status-label {
  display: flex;
  align-items: center;
  justify-content: center;
  gap: var(--spacing-sm);
  font-size: var(--font-size-lg);
  text-transform: uppercase;
  letter-spacing: 2px;
}

.scene-status-emoji {
  font-size: 1.5em;
}

.scene-status-message {
  margin-top: var(--spacing-xs);
  font-size: var(--font-size-sm);
}

/* 상태별 배경 이미지 적용 */
.scene-canvas.scene-status-loading,
.scene-canvas.scene-status-offline,
.scene-canvas.scene-status-blocked,
.scene-canvas.scene-status-low_signal,
.scene-canvas.scene-status-default {
  background-size: cover;
  background-position: center;
  background-repeat: no-repeat;
}

/* 로딩 상태: 펄스 애니메이션 */
.scene-canvas.scene-status-loading .scene-placeholder {
  animation: loading-pulse 2s ease-in-out infinite;
}

@keyframes loading-pulse {
  0%,
  100% {
    opacity: 0.7;
  }
  50% {
    opacity: 1;
  }
}

/* 오프라인 상태: 정적 노이즈 효과 */
.scene-canvas.scene-status-offline {
  position: relative;
}

.scene-canvas.scene-status-offline::before {
  content: '';
  position: absolute;
  top: 0;
  left: 0;
  right: 0;
  bottom: 0;
  background: repeating-linear-gradient(
    0deg,
    transparent,
    transparent 2px,
    rgba(0, 0, 0, 0.1) 2px,
    rgba(0, 0, 0, 0.1) 4px
  );
  pointer-events: none;
  animation: static-noise 0.5s steps(5) infinite;
}

@keyframes static-noise {
  0%,
  100% {
    opacity: 0.3;
  }
  50% {
    opacity: 0.5;
  }
}

/* 차단 상태: 경고색 테두리 */
.scene-canvas.scene-status-blocked {
  border-color: var(--warning-color);
  box-shadow: inset 0 0 30px rgba(255, 170, 0, 0.2);
}

.scene-canvas.scene-status-blocked .scene-status-label {
  color: var(--warning-color);
}

/* 저신호 상태: 희미한 표시 */
.scene-canvas.scene-status-low_signal .scene-placeholder {
  opacity: 0.8;
}

.scene-canvas.scene-status-low_signal .scene-status-label {
  color: var(--text-dim);
}

/* 정상 장면 표시 */
.scene-canvas.scene-active {
  background-color: transparent;
}

.scene-canvas .scene-image {
  width: 100%;
  height: 100%;
  object-fit: cover;
}

/* Readable 모드에서 placeholder 대비 향상 (U-028 연동) */
html[data-readable='true'] .scene-placeholder {
  background-color: rgba(0, 0, 0, 0.8);
}

html[data-readable='true'] .scene-canvas.scene-status-loading .scene-placeholder {
  animation: none;
}

html[data-readable='true'] .scene-canvas.scene-status-offline::before {
  display: none;
}

/* 내러티브 피드 - RULE-002: 채팅 버블 아님, 게임 로그 형태 */
.narrative-feed {
  height: 180px;
  border: 1px solid var(--border-color);
  background-color: var(--panel-bg);
  box-shadow: inset 0 0 20px rgba(0, 0, 0, 0.8);
  overflow-y: auto;
  padding: var(--spacing-sm);
}

.narrative-entry {
  padding: var(--spacing-xs) 0;
  border-bottom: 1px solid rgba(51, 255, 0, 0.2);
}

.narrative-entry:last-child {
  border-bottom: none;
}

.narrative-timestamp {
  color: var(--text-dim);
  font-size: 0.75rem;
  margin-right: var(--spacing-sm);
}

.narrative-text {
  color: var(--text-color);
}

/* ============================================
   9. Sidebar (Right) 영역
   - Agent Console, Memory Pin, Scanner Slot
   ============================================ */

.sidebar-right {
  grid-area: sidebar-right;
  display: flex;
  flex-direction: column;
  gap: var(--spacing-sm);
  overflow-y: auto;
}

/* ============================================
   10. Footer 영역
   - Action Deck, Command Input
   ============================================ */

.game-footer {
  grid-area: footer;
  display: flex;
  flex-direction: column;
  gap: var(--spacing-sm);
  padding: var(--spacing-sm);
  border: 1px solid var(--border-color);
  background-color: var(--panel-bg);
  box-shadow: inset 0 0 20px rgba(0, 0, 0, 0.5);
}

.action-deck {
  display: flex;
  gap: var(--spacing-sm);
  overflow-x: auto;
  padding-bottom: var(--spacing-xs);
}

.action-card {
  min-width: 140px;
  padding: var(--spacing-sm);
  border: 1px solid var(--border-color);
  background-color: rgba(0, 0, 0, 0.5);
  cursor: pointer;
  transition:
    border-color 0.2s,
    box-shadow 0.2s;
}

.action-card:hover {
  border-color: var(--accent-color);
  box-shadow: 0 0 10px var(--accent-color);
}

.action-card-title {
  font-size: 0.875rem;
  margin-bottom: var(--spacing-xs);
  color: var(--text-color);
}

.action-card-cost {
  font-size: 0.75rem;
  color: var(--warning-color);
}

.command-input-area {
  display: flex;
  align-items: center;
  gap: var(--spacing-sm);
  padding: var(--spacing-xs);
  border: 1px solid var(--text-dim);
  background-color: rgba(0, 0, 0, 0.5);
}

.command-prompt {
  color: var(--text-color);
  font-size: var(--font-size-lg);
}

.command-input {
  flex: 1;
  background: transparent;
  border: none;
  color: var(--text-color);
  font-family: var(--font-main);
  font-size: var(--font-size-lg);
  outline: none;
  text-shadow: 0 0 5px var(--text-dim);
}

.command-input::placeholder {
  color: var(--text-dim);
}

/* ============================================
   11. 공통 패널 스타일
   ============================================ */

.panel {
  border: 1px solid var(--border-color);
  background-color: var(--panel-bg);
  box-shadow: inset 0 0 20px rgba(0, 0, 0, 0.8);
  display: flex;
  flex-direction: column;
}

.panel-header {
  padding: var(--spacing-xs) var(--spacing-sm);
  border-bottom: 1px solid var(--text-dim);
  background-color: rgba(0, 0, 0, 0.3);
  display: flex;
  align-items: center;
  justify-content: space-between;
}

.panel-title {
  font-size: 0.875rem;
  text-transform: uppercase;
  letter-spacing: 2px;
  color: var(--text-color);
}

.panel-content {
  flex: 1;
  padding: var(--spacing-sm);
  overflow-y: auto;
}

.panel-placeholder {
  color: var(--text-dim);
  font-size: 0.875rem;
  text-align: center;
  padding: var(--spacing-md);
}

/* ============================================
   12. 버튼 스타일
   ============================================ */

button,
.btn {
  background: var(--text-color);
  color: var(--bg-color);
  border: none;
  padding: var(--spacing-xs) var(--spacing-sm);
  font-family: var(--font-main);
  font-size: var(--font-size-lg);
  cursor: pointer;
  text-transform: uppercase;
  font-weight: bold;
  transition:
    background 0.2s,
    color 0.2s;
}

button:hover,
.btn:hover {
  background: var(--accent-color);
  color: white;
}

button:disabled,
.btn:disabled {
  background: var(--text-dim);
  cursor: not-allowed;
}

/* ============================================
   13. 스크롤바 커스터마이징
   ============================================ */

::-webkit-scrollbar {
  width: 10px;
  height: 10px;
}

::-webkit-scrollbar-track {
  background: var(--bg-color);
}

::-webkit-scrollbar-thumb {
  background: var(--text-dim);
  border: 1px solid var(--text-color);
}

::-webkit-scrollbar-thumb:hover {
  background: var(--text-color);
}

/* ============================================
   14. 반응형 디자인
   ============================================ */

@media (max-width: 1200px) {
  .game-container {
    grid-template-areas:
      'header header'
      'center sidebar-right'
      'footer footer';
    grid-template-columns: 1fr var(--sidebar-width);
  }

  .sidebar-left {
    display: none;
  }
}

@media (max-width: 768px) {
  :root {
    font-size: 14px;
    --header-height: 50px;
    --footer-height: 100px;
    --sidebar-width: 100%;
  }

  .game-container {
    grid-template-areas:
      'header'
      'center'
      'footer';
    grid-template-columns: 1fr;
    grid-template-rows: var(--header-height) 1fr var(--footer-height);
    padding: var(--spacing-xs);
    gap: var(--spacing-xs);
  }

  .sidebar-left,
  .sidebar-right {
    display: none;
  }

  .game-header {
    padding: 0 var(--spacing-sm);
  }

  .game-title {
    font-size: var(--font-size-lg);
    letter-spacing: 2px;
  }

  .economy-hud {
    display: none;
  }

  .action-deck {
    flex-wrap: nowrap;
    overflow-x: auto;
  }

  .action-card {
    min-width: 120px;
  }
}

/* ============================================
   15. 유틸리티 클래스
   ============================================ */

.text-dim {
  color: var(--text-dim);
}

.text-accent {
  color: var(--accent-color);
}

.text-warning {
  color: var(--warning-color);
}

.text-error {
  color: var(--error-color);
}

.text-glow {
  text-shadow: 0 0 10px var(--text-color);
}

.visually-hidden {
  position: absolute;
  width: 1px;
  height: 1px;
  padding: 0;
  margin: -1px;
  overflow: hidden;
  clip: rect(0, 0, 0, 0);
  white-space: nowrap;
  border: 0;
}

/* ============================================
   16. Agent Console 스타일 (U-008)
   - RULE-008: 단계/배지/복구 표시
   ============================================ */

.agent-console-content {
  display: flex;
  flex-direction: column;
  gap: var(--spacing-sm);
  font-size: 0.75rem;
}

/* 스트리밍 상태 */
.streaming-status {
  display: flex;
  align-items: center;
  gap: var(--spacing-xs);
  padding: var(--spacing-xs);
  border-bottom: 1px solid var(--text-dim);
}

.streaming-status .status-dot {
  width: 6px;
  height: 6px;
  border-radius: 50%;
  background-color: var(--text-dim);
  transition: background-color 0.3s;
}

.streaming-status .status-dot.active {
  background-color: var(--accent-color);
  box-shadow: 0 0 8px var(--accent-color);
  animation: pulse 1s infinite;
}

.streaming-status .status-text {
  text-transform: uppercase;
  letter-spacing: 1px;
  color: var(--text-dim);
}

.streaming-status .status-dot.active + .status-text {
  color: var(--accent-color);
}

/* 단계 큐 */
.phase-queue {
  padding: var(--spacing-xs);
}

.phase-queue .queue-label {
  font-size: 0.625rem;
  text-transform: uppercase;
  letter-spacing: 1px;
  color: var(--text-dim);
  margin-bottom: var(--spacing-xs);
}

.phase-queue .queue-items {
  display: flex;
  flex-wrap: wrap;
  gap: 2px;
}

.phase-item {
  display: flex;
  align-items: center;
  gap: 2px;
  padding: 2px 4px;
  background-color: rgba(0, 0, 0, 0.3);
  border: 1px solid var(--text-dim);
  font-size: 0.625rem;
}

.phase-item.pending {
  color: var(--text-dim);
  border-color: var(--text-dim);
}

.phase-item.in_progress,
.phase-item.in-progress {
  color: var(--accent-color);
  border-color: var(--accent-color);
  box-shadow: 0 0 5px var(--accent-color);
  animation: pulse 1s infinite;
}

.phase-item.completed {
  color: var(--text-color);
  border-color: var(--text-color);
}

.phase-item.failed {
  color: var(--error-color);
  border-color: var(--error-color);
}

.phase-icon {
  font-size: 0.5rem;
}

.phase-icon.in-progress {
  animation: spin 2s linear infinite;
}

@keyframes spin {
  from {
    transform: rotate(0deg);
  }
  to {
    transform: rotate(360deg);
  }
}

.phase-label {
  white-space: nowrap;
}

/* 배지 패널 */
.badges-panel {
  padding: var(--spacing-xs);
  border-top: 1px solid var(--text-dim);
}

.badges-panel .badges-label {
  font-size: 0.625rem;
  text-transform: uppercase;
  letter-spacing: 1px;
  color: var(--text-dim);
  margin-bottom: var(--spacing-xs);
}

.badges-panel .badges-empty {
  color: var(--text-dim);
  font-size: 0.625rem;
  text-align: center;
  padding: var(--spacing-xs);
}

.badges-panel .badges-grid {
  display: grid;
  grid-template-columns: repeat(2, 1fr);
  gap: 2px;
}

.badge-item {
  display: flex;
  justify-content: space-between;
  align-items: center;
  padding: 2px 4px;
  background-color: rgba(0, 0, 0, 0.3);
  border: 1px solid var(--text-dim);
  font-size: 0.625rem;
}

.badge-item.badge-ok {
  border-color: var(--text-color);
}

.badge-item.badge-ok .badge-status {
  color: var(--text-color);
}

.badge-item.badge-fail {
  border-color: var(--error-color);
}

.badge-item.badge-fail .badge-status {
  color: var(--error-color);
}

.badge-label {
  color: var(--text-dim);
}

.badge-status {
  font-weight: bold;
  text-transform: uppercase;
}

/* Auto-repair 트레이스 */
.repair-trace {
  display: flex;
  align-items: center;
  gap: var(--spacing-xs);
  padding: var(--spacing-xs);
  border-top: 1px solid var(--text-dim);
  font-size: 0.625rem;
}

.repair-trace .repair-label {
  color: var(--text-dim);
}

.repair-trace .repair-count {
  color: var(--warning-color);
  font-weight: bold;
}

.repair-trace .repair-status {
  color: var(--warning-color);
  font-size: 0.5rem;
}

/* 에러 표시 */
.agent-error {
  display: flex;
  align-items: flex-start;
  gap: var(--spacing-xs);
  padding: var(--spacing-xs);
  background-color: rgba(255, 51, 51, 0.1);
  border: 1px solid var(--error-color);
  font-size: 0.625rem;
}

.agent-error .error-icon {
  color: var(--error-color);
}

.agent-error .error-message {
  color: var(--error-color);
  flex: 1;
  word-break: break-word;
}

.agent-error .error-code {
  color: var(--text-dim);
  font-size: 0.5rem;
}

/* ============================================
   17. 내러티브 스트리밍 효과
   ============================================ */

.narrative-entry.streaming {
  opacity: 0.8;
}

.cursor-blink {
  animation: blink 1s infinite;
  color: var(--accent-color);
}

@keyframes blink {
  0%,
  50% {
    opacity: 1;
  }
  51%,
  100% {
    opacity: 0;
  }
}

/* ============================================
   18. 액션 카드 비활성화 상태
   ============================================ */

.action-card:disabled {
  opacity: 0.5;
  cursor: not-allowed;
  border-color: var(--text-dim);
}

.action-card:disabled:hover {
  border-color: var(--text-dim);
  box-shadow: none;
}

/* ============================================
   19. Economy HUD 아이콘 (U-029: nanobanana 에셋)
   ============================================ */

.economy-hud .shard-icon {
  margin-left: var(--spacing-sm);
}

/* 에셋 아이콘 래퍼 - 폴백 패턴 (U-029/U-030) */
.icon-wrapper {
  display: inline-flex;
  align-items: center;
  justify-content: center;
  position: relative;
}

.icon-wrapper .icon-img {
  width: 20px;
  height: 20px;
  object-fit: contain;
  /* (U-029) 흰 배경 아이콘인 경우 screen/lighten 등으로 조절 가능하지만 rembg 완료됨 */
  display: block;
}

.icon-wrapper .icon-img.hidden {
  display: none;
}

/* 폴백 텍스트는 기본 숨김, 이미지 로드 실패 시 표시 */
.icon-wrapper .icon-fallback {
  display: none;
  font-size: 1rem;
}

/* 이미지 숨김 시 폴백 표시 */
.icon-wrapper .icon-img.hidden + .icon-fallback {
  display: inline;
}

/* Risk 등급별 아이콘 필터링 (필요 시) */
.icon-img.risk-low {
  filter: drop-shadow(0 0 2px var(--text-color));
}

.icon-img.risk-high {
  filter: drop-shadow(0 0 2px var(--error-color));
}

/* 배지 아이콘 (Agent Console) */
.badge-icon-img {
  width: 14px;
  height: 14px;
  object-fit: contain;
  vertical-align: middle;
  margin-right: 2px;
}

/* ============================================
   20. Flex 유틸리티
   ============================================ */

.flex-1 {
  flex: 1;
}

/* ============================================
   21. Readable 모드 (U-028: 가독성 패스)
   - CRT 효과 완화, 대비 향상, 마이크로 텍스트 상향
   ============================================ */

/* Readable 모드: CRT 오버레이 숨김 */
html[data-readable='true'] .crt-overlay {
  display: none;
}

/* Readable 모드: 글로우/텍스트 쉐도우 완화 */
html[data-readable='true'] body {
  text-shadow: none;
}

html[data-readable='true'] .text-glow {
  text-shadow: none;
}

/* Readable 모드: 글리치 효과 비활성화 */
html[data-readable='true'] .glitch::before,
html[data-readable='true'] .glitch::after {
  display: none;
}

/* Readable 모드: 배경 대비 향상 */
html[data-readable='true'] {
  --panel-bg: rgba(0, 30, 0, 0.5);
  --text-dim: #2aaa00; /* 보조 텍스트 밝기 상향 */
}

/* Readable 모드: 입력창 글로우 제거 */
html[data-readable='true'] .command-input {
  text-shadow: none;
}

/* Readable 모드: 상태 표시기 펄스 완화 */
html[data-readable='true'] .status-indicator {
  animation: none;
  opacity: 1;
}

/* Readable 모드: 스트리밍 상태 펄스 완화 */
html[data-readable='true'] .streaming-status .status-dot.active {
  animation: none;
}

/* Readable 모드: 단계 아이템 펄스 완화 */
html[data-readable='true'] .phase-item.in_progress,
html[data-readable='true'] .phase-item.in-progress {
  animation: none;
}

/* ============================================
   22. 마이크로 텍스트 가독성 상향 (U-028)
   - 0.625rem → --font-size-xs (0.75rem)
   - 0.75rem → --font-size-sm (0.875rem) (Readable 모드)
   ============================================ */

/* Agent Console 기본 폰트 상향 */
.agent-console-content {
  font-size: var(--font-size-xs);
}

/* 큐 라벨 폰트 상향 */
.phase-queue .queue-label {
  font-size: calc(var(--font-size-xs) * 0.85);
}

/* 단계 아이템 폰트 상향 */
.phase-item {
  font-size: calc(var(--font-size-xs) * 0.85);
}

/* 배지 패널 라벨 상향 */
.badges-panel .badges-label {
  font-size: calc(var(--font-size-xs) * 0.85);
}

.badges-panel .badges-empty {
  font-size: calc(var(--font-size-xs) * 0.85);
}

/* 배지 아이템 상향 */
.badge-item {
  font-size: calc(var(--font-size-xs) * 0.85);
}

/* 복구 트레이스 상향 */
.repair-trace {
  font-size: calc(var(--font-size-xs) * 0.85);
}

.repair-trace .repair-status {
  font-size: calc(var(--font-size-xs) * 0.7);
}

/* 에러 표시 상향 */
.agent-error {
  font-size: calc(var(--font-size-xs) * 0.85);
}

.agent-error .error-code {
  font-size: calc(var(--font-size-xs) * 0.7);
}

/* 내러티브 타임스탬프 상향 */
.narrative-timestamp {
  font-size: var(--font-size-xs);
}

/* 단계 아이콘 상향 */
.phase-icon {
  font-size: calc(var(--font-size-xs) * 0.7);
}

/* Readable 모드: 마이크로 텍스트 추가 상향 */
html[data-readable='true'] .agent-console-content {
  font-size: var(--font-size-sm);
}

html[data-readable='true'] .phase-queue .queue-label,
html[data-readable='true'] .phase-item,
html[data-readable='true'] .badges-panel .badges-label,
html[data-readable='true'] .badges-panel .badges-empty,
html[data-readable='true'] .badge-item,
html[data-readable='true'] .repair-trace,
html[data-readable='true'] .agent-error {
  font-size: var(--font-size-xs);
}

html[data-readable='true'] .narrative-timestamp {
  font-size: var(--font-size-sm);
}

/* ============================================
   23. UI 스케일 컨트롤 버튼 스타일 (U-028)
   ============================================ */

.ui-controls {
  display: flex;
  align-items: center;
  gap: var(--spacing-xs);
}

.ui-scale-btn,
.readable-toggle-btn {
  background: transparent;
  color: var(--text-color);
  border: 1px solid var(--text-dim);
  padding: 2px 6px;
  font-family: var(--font-main);
  font-size: var(--font-size-xs);
  cursor: pointer;
  text-transform: uppercase;
  transition:
    border-color 0.2s,
    color 0.2s,
    box-shadow 0.2s;
  min-width: 28px;
  text-align: center;
}

.ui-scale-btn:hover,
.readable-toggle-btn:hover {
  border-color: var(--accent-color);
  color: var(--accent-color);
}

.ui-scale-btn:disabled {
  opacity: 0.4;
  cursor: not-allowed;
}

.ui-scale-btn:disabled:hover {
  border-color: var(--text-dim);
  color: var(--text-dim);
}

.readable-toggle-btn[aria-pressed='true'] {
  background: var(--text-color);
  color: var(--bg-color);
  border-color: var(--text-color);
}

.readable-toggle-btn[aria-pressed='true']:hover {
  background: var(--accent-color);
  border-color: var(--accent-color);
  color: white;
}

.ui-scale-display {
  font-size: var(--font-size-xs);
  color: var(--text-dim);
  min-width: 32px;
  text-align: center;
}

.ui-controls-separator {
  width: 1px;
  height: 16px;
  background: var(--text-dim);
  margin: 0 var(--spacing-xs);
}

/* ============================================
   24. UI Chrome Pack (U-032)
   - 패널/카드에 적용되는 장식(코너/프레임)
   - Readable 모드에서 완화
   ============================================ */

/* Chrome 에셋 경로 변수 */
:root {
  --chrome-panel-corner: url('/ui/chrome/panel-corner-br.png');
  --chrome-card-frame: url('/ui/chrome/card-frame.png');
  --chrome-scanner-frame: url('/ui/chrome/scanner-frame.png');
  --chrome-corner-size: 32px;
  --chrome-glow-color: rgba(51, 255, 0, 0.3);
}

/* Game Header Chrome - 상단 코너 (U-032) */
.game-header.has-chrome {
  position: relative;
}

.game-header.has-chrome::before,
.game-header.has-chrome::after {
  content: '';
  position: absolute;
  width: var(--chrome-corner-size);
  height: var(--chrome-corner-size);
  background-image: var(--chrome-panel-corner);
  background-size: contain;
  background-repeat: no-repeat;
  pointer-events: none;
  opacity: 0.9;
  filter: drop-shadow(0 0 5px var(--chrome-glow-color));
  z-index: 2;
}

.game-header.has-chrome::before {
  top: -2px;
  left: -2px;
  transform: rotate(90deg);
}

.game-header.has-chrome::after {
  top: -2px;
  right: -2px;
  transform: rotate(180deg);
}

/* Panel Header Chrome - 코너 장식 (4방향 CSS transform) */
.panel-header.has-chrome {
  position: relative;
}

.panel-header.has-chrome::before,
.panel-header.has-chrome::after {
  content: '';
  position: absolute;
  width: var(--chrome-corner-size);
  height: var(--chrome-corner-size);
  background-image: var(--chrome-panel-corner);
  background-size: contain;
  background-repeat: no-repeat;
  pointer-events: none;
  opacity: 0.8;
  filter: drop-shadow(0 0 4px var(--chrome-glow-color));
}

/* 좌상단 코너 */
.panel-header.has-chrome::before {
  top: -2px;
  left: -2px;
  transform: rotate(90deg);
}

/* 우상단 코너 */
.panel-header.has-chrome::after {
  top: -2px;
  right: -2px;
  transform: rotate(180deg);
}

/* Panel Chrome - 하단 코너용 래퍼 */
.panel.has-chrome {
  position: relative;
}

.panel.has-chrome .panel-content {
  position: relative;
}

.panel.has-chrome .panel-content::before,
.panel.has-chrome .panel-content::after {
  content: '';
  position: absolute;
  width: var(--chrome-corner-size);
  height: var(--chrome-corner-size);
  background-image: var(--chrome-panel-corner);
  background-size: contain;
  background-repeat: no-repeat;
  pointer-events: none;
  opacity: 0.6;
  filter: drop-shadow(0 0 3px var(--chrome-glow-color));
}

/* 좌하단 코너 */
.panel.has-chrome .panel-content::before {
  bottom: 0;
  left: -2px;
  transform: rotate(0deg);
}

/* 우하단 코너 (원본 방향) */
.panel.has-chrome .panel-content::after {
  bottom: 0;
  right: -2px;
  transform: rotate(270deg);
}

/* Action Card Chrome - 프레임 오버레이 */
.action-card.has-chrome {
  position: relative;
  overflow: visible;
}

.action-card.has-chrome::before {
  content: '';
  position: absolute;
  top: -4px;
  left: -4px;
  right: -4px;
  bottom: -4px;
  background-image: var(--chrome-card-frame);
  background-size: 100% 100%;
  background-repeat: no-repeat;
  pointer-events: none;
  opacity: 0.7;
  filter: drop-shadow(0 0 6px var(--chrome-glow-color));
  z-index: 1;
}

/* Scanner Slot Chrome - 장식 프레임 (U-032) */
.scanner-slot.has-chrome {
  position: relative;
  min-height: 100px;
  border: 1px dashed var(--text-dim);
  display: flex;
  align-items: center;
  justify-content: center;
  margin: var(--spacing-md) var(--spacing-sm);
  background-color: rgba(0, 0, 0, 0.4);
}

.scanner-slot.has-chrome::before {
  content: '';
  position: absolute;
  top: -10px;
  left: -10px;
  right: -10px;
  bottom: -10px;
  background-image: var(--chrome-scanner-frame);
  background-size: 100% 100%;
  background-repeat: no-repeat;
  pointer-events: none;
  opacity: 0.8;
  filter: drop-shadow(0 0 8px var(--chrome-glow-color));
  z-index: 1;
}

/* Chrome 호버 효과 강화 */
.action-card.has-chrome:hover::before,
.scanner-slot.has-chrome:hover::before {
  opacity: 1;
  filter: drop-shadow(0 0 10px var(--accent-color));
}

/* Readable 모드: Chrome 완화/제거 */
html[data-readable='true'] .game-header.has-chrome::before,
html[data-readable='true'] .game-header.has-chrome::after,
html[data-readable='true'] .panel-header.has-chrome::before,
html[data-readable='true'] .panel-header.has-chrome::after,
html[data-readable='true'] .panel.has-chrome .panel-content::before,
html[data-readable='true'] .panel.has-chrome .panel-content::after {
  opacity: 0.3;
  filter: none;
}

html[data-readable='true'] .action-card.has-chrome::before,
html[data-readable='true'] .scanner-slot.has-chrome::before {
  opacity: 0.4;
  filter: none;
}

/* Chrome 폴백: 이미지 로딩 실패 시 CSS 테두리로 대체 */
.panel-header.has-chrome.chrome-fallback::before,
.panel-header.has-chrome.chrome-fallback::after,
.panel.has-chrome.chrome-fallback .panel-content::before,
.panel.has-chrome.chrome-fallback .panel-content::after {
  background-image: none;
  background-color: var(--text-color);
  width: 8px;
  height: 8px;
  border-radius: 1px;
}

.action-card.has-chrome.chrome-fallback::before,
.scanner-slot.has-chrome.chrome-fallback::before {
  background-image: none;
  border: 1px solid var(--text-color);
  background-color: transparent;
}
</file>

<file path="vibe/prd.md">
# [Unknown World] PRD

## 1. 제품 개요

### 1.1 한 줄 소개

**Unknown World**는 Gemini 기반의 **에이전트형(Game Master) 세계 엔진**과 멀티모달(텍스트·이미지·비전) 파이프라인을 결합한 **무한 생성 로그라이크 내러티브 웹게임**입니다.

### 1.2 제품 설명

- 정해진 시나리오/스크립트/엔딩이 없고, 플레이어의 **자연어 입력 + 화면 오브젝트 클릭**에 따라 세계관과 규칙이 실시간으로 갱신됩니다.
- 텍스트는 **스트리밍(타자 효과)**로 즉시 반응하고, 이미지는 필요 시점에 **선택적으로 생성/편집**되어 몰입감을 강화합니다.
- AI가 내러티브만 말하는 것이 아니라, **UI(선택지/오브젝트/좌표)**를 구조화하여 “플레이 가능한 화면”을 만듭니다.

### 1.3 목표

- **고충실도(high-fidelity) 멀티모달 앱**: 단순 채팅 래퍼가 아닌, UI·상태·경제·세이브·엔딩까지 갖춘 완성형 경험.
- **에이전트형 오케스트레이션**: 입력 해석 → 상태 갱신 → UI 생성 → (조건부) 이미지 생성/편집 → 검증/복구까지 자동 수행.
- **무한 리플레이성**: 매 세션마다 장르·시대·물리 법칙이 달라지고, 플레이 로그 기반으로 고유 엔딩이 생성됨.

## 2. 프로젝트 방향성 (Standard Guide 반영)

### 2.1 “Prompt-only wrapper / Generic chatbot” 회피 원칙

- **한 번의 프롬프트로 끝나는 앱을 만들지 않는다.**
- 게임은 “대화”가 아니라 **상태를 가진 시스템**이며, 다음 요소가 반드시 존재해야 한다:
  - **상태(state)**: WorldState / Inventory / Rules / Economy / History
  - **오케스트레이터(orchestrator)**: 다단계 생성, 검증, 재시도, 비용 제어
  - **아티팩트(artifacts)**: 저장 파일, 엔딩 리포트, 이미지/로그

### 2.2 ‘Action Era’에 맞는 구현 포인트

- **장시간 세션(마라톤 플레이)**에서도 일관성을 유지하는 **메모리/요약/중요 설정 고정** 체계를 갖춘다.
- 모델 출력은 **구조화(JSON Schema)**하여 UI/상태/비용을 기계적으로 처리한다.
- 실패/불완전 출력에 대비해 **검증 후 자동 복구(repair loop)** 를 설계한다.

### 2.3 Creative Autopilot 방향(이미지 생성 고품질)

- 이미지 생성은 “그냥 한 장 뽑기”가 아니라:
  - **장면 일관성(캐릭터/오브젝트/톤)** 유지
  - **대화형 편집(멀티턴)** 지원
  - 필요 시 **해상도/비율(1K/2K/4K, 16:9 등)**를 선택

## 3. 지원 범위 및 언어 정책

### 3.1 지원 언어

- **한국어(ko-KR), 영어(en-US)** 2개 국어 지원.
- UI 텍스트, 시스템 메시지, 게임 내 내러티브/선택지/오브젝트 라벨까지 동일 정책 적용.

### 3.2 프롬프트/출력 언어 설계 원칙 (✅ 기반 디렉토리 생성 완료)

- 모든 핵심 프롬프트는 **백엔드의 별도 `.md` 파일**로 관리한다.
- 언어별로 프롬프트를 분리하고(권장), 턴 입력에 `language`를 포함하여 응답도 동일 언어로 고정한다(혼합 출력 방지).
- 프롬프트 로더는 `language` 파라미터에 따라 올바른 파일을 로드하며, 개발 모드에서는 **핫리로드**를 지원한다.

예시 디렉토리(개념):

- `backend/prompts/system/game_master.ko.md` - 시스템 프롬프트(한국어)
- `backend/prompts/system/game_master.en.md` - 시스템 프롬프트(영어)
- `backend/prompts/turn/turn_output_instructions.ko.md` - 턴 출력 지시(한국어)
- `backend/prompts/turn/turn_output_instructions.en.md` - 턴 출력 지시(영어)
- `backend/prompts/image/scene_prompt.ko.md` - 이미지 생성 프롬프트(한국어)
- `backend/prompts/image/scene_prompt.en.md` - 이미지 생성 프롬프트(영어)

**프롬프트 관리 원칙**:

- 코드 하드코딩 금지: 모든 핵심 프롬프트는 `.md` 파일에서 로드한다.
- 편집 용이성: 마크다운 형식으로 작성하되, 렌더링 없이 텍스트 그대로 모델에 전달된다.
- 버전 관리: 프론트매터(선택)로 `prompt_version`, `policy_preset` 등 메타를 포함할 수 있다.
- 핫리로드: 개발 모드에서 서버 재시작 없이 프롬프트 변경이 반영된다.

## 4. 사용자 정의

### 4.1 타겟 페르소나

- **The Narrator**: 스토리 참여/몰입 중심
- **The Explorer**: 시스템 실험/창발 플레이 선호
- **The Tech Enthusiast**: 멀티모달·구조화·에이전트 설계에 관심

### 4.2 사용자 니즈

- “내 선택이 세계를 바꾸는” 체감(상태·규칙·시각적 결과로 피드백)
- 엔딩이 요약이 아니라 **플레이 로그 기반 리포트/아트워크**로 남는 경험
- 웹에서 가볍게 시작하되, 깊게 파고들수록 시스템이 열린다(재화/기능 해금)

## 5. 게임 재화(코스트) 시스템 (Frontend 중심)

### 5.1 목적

- **비용(토큰/이미지) 리스크를 게임 메커닉으로 전환**한다.
- 사용자는 “무제한 생성”이 아니라, 재화를 통해 **선택과 전략**을 하게 된다.

### 5.2 재화 정의(예시)

- **Signal(시그널)**: 기본 재화. 텍스트 턴/이미지 생성/고급 기능에 소비.
- **Memory Shard(기억 파편)**: 희귀 재화. “중요 설정 고정”, “룰 고착(고정)”, “고해상도 이미지” 등에 소비.

### 5.3 획득 루프(예시)

- 매 턴 생존/진행/목표 달성으로 Signal 획득
- 엔딩 도달 시 리포트 보상(Signal + Memory Shard)
- 일일 첫 접속 보너스(데모/해커톤 기준 옵션)

### 5.4 소비 정책(예시)

- **텍스트 턴**: 소량(기본)
- **이미지 생성**: 중~대량(장면 생성)
- **이미지 편집(멀티턴 수정)**: 중량(편집 회수/해상도에 비례)
- **Thinking Level High / 장문 요약 / 분석 리포트**: 추가 비용

### 5.5 UX 요구사항

- 행동 전 **예상 비용**(최소/최대)을 보여주고, 부족하면 대체 행동(텍스트만/저해상도)을 제안.
- 재화 소모 로그를 “게임스럽게” 표현(예: “세계 신호가 약해집니다… -12 Signal”).

## 6. 핵심 기능 (MVP)

### 6.1 에이전트형 Game Master 엔진

- 사용자 입력(텍스트/클릭)을 해석해 **WorldState**를 갱신한다.
- 스토리 진행(도입/전개/위기/절정/결말)을 동적으로 관리한다.
- 출력은 “말”이 아니라, **UI/상태/비용을 포함한 구조화 결과**로 반환한다.

### 6.2 구조화 UI 자동 생성(클릭 가능한 세계)

- 오브젝트/핫스팟을 좌표로 제공하여, 화면에서 클릭 가능하게 한다.
- 좌표는 **0~1000 정규화 좌표계**를 사용(이미지 이해 bbox 포맷과 호환).

### 6.3 멀티모달 렌더링 파이프라인

- 텍스트 상황 묘사 → (조건부) 이미지 생성/편집 → UI 오버레이(핫스팟) 제공
- 이미지 생성이 느릴 경우 **텍스트 우선 출력 + Lazy Loading**.
- **오브젝트/아이템 이미지 배경 제거(조건부)**: 투명 합성이 필요한 경우 `rembg`를 사용해 배경을 제거한다. (가이드: `vibe/ref/rembg-guide.md`)

### 6.4 룰 변형 시스템(Rule Mutation)

- 플레이어 행동/트리거로 장르/물리법칙/메타 룰이 변한다.
- 룰은 WorldState에 명시적으로 기록되어, 다음 턴에 일관되게 적용된다.

### 6.5 동적 엔딩 생성기

- 플레이 로그를 분석해 **요약(텍스트) + 대표 이미지 + 규칙 변화 타임라인**을 생성한다.

### 6.6 세이브/로드

- 세션 상태를 JSON으로 직렬화하여 저장/복원한다.
- 저장에는 WorldState 뿐 아니라 **재화 잔액/소모 로그/언어 설정**을 포함한다.

### 6.7 (데모 표면 핵심) 게임형 조작/피드백 시스템 (✅ UI 스켈레톤 확보)

> 심사자가 UI를 “채팅 앱”으로 오해하지 않도록, 데모에서 아래 조작과 피드백이 **항상 화면에 존재**해야 한다.

- **Action Deck(행동 카드)**: (✅ 레이아웃 확보)
  - 매 턴 AI가 추천 행동을 3~6장 카드로 제시(각 카드에 **Signal/Shard 비용**, 위험/보상 힌트 포함)
  - 사용자는 카드를 클릭해 즉시 실행하거나, 커스텀 입력으로 변형 실행
- **Inventory(인벤토리) + Drag & Drop(드래그 사용)**:
  - 아이템은 슬롯/칩 형태로 상시 표시
  - 아이템을 **장면 오브젝트(핫스팟)**로 드래그해 “사용/조합/해체”를 수행(예: 열쇠 → 자물쇠)
- **Quest/Objective Panel(목표 패널)**:
  - 현재 목표/서브목표를 체크리스트로 표시하고, 완료 시 보상(재화) 즉시 반영
- **Rule Board(룰 보드) & Mutation Timeline(변형 타임라인)**:
  - 현재 적용 중인 규칙/물리 법칙을 “룰 카드”로 노출
  - 룰 변형 이벤트는 타임라인으로 기록되어, “세계가 변했다”가 UI로 체감되게 한다
- **Economy HUD(재화 HUD)**:
  - Signal/Shard 잔액과 이번 행동의 **예상 비용/확정 비용**을 항상 표시(부족 시 대체안 제공)
- **Memory Pin UI(중요 설정 고정)**:
  - “중요 설정 후보”를 칩으로 제시하고, 사용자가 Shard를 소비해 고정(고정된 사실은 상시 HUD에 표시)
- **(멀티모달 데모) Scanner 슬롯(이미지 드랍/업로드)**:
  - 사용자가 이미지를 드래그/업로드하면, 이미지 이해(캡션/오브젝트 감지)를 통해 **아이템/단서**로 변환해 인벤토리에 추가하거나 세계에 배치
  - 예: “현실 사진 → 게임 속 ‘부품’ 아이템화”, “스케치 → 오브젝트 생성”

### 6.8 (데모 표면 핵심) 에이전트 동작 가시화(Autopilot / Action Queue / Self-Repair)

> “에이전트형 시스템”이 채팅처럼 보이지 않게 하려면, **결과만 출력**하는 것이 아니라 “계획·실행·검증·복구”의 흔적이 UI에 보여야 한다.  
> 단, **프롬프트/내부 추론(Chain-of-thought)은 노출하지 않고**, 사용자가 이해할 수 있는 **단계/상태/검증 결과**만 표시한다.

- **Autopilot 모드(필수 토글)**:
  - `Manual`(사용자 주도) / `Assist`(추천+경고) / `Autopilot`(목표 기반 자동 실행)
  - Autopilot에서는 사용자가 “목표”만 제시하면 에이전트가 **다단계 플랜을 생성**하고 작업을 진행한다(사용자는 언제든지 Pause/Cancel).
- **Goal → Plan → Subquests(계획의 시각화)**:
  - 사용자가 입력한 목표를 **플랜 카드**로 구조화해 보여주고,
  - 플랜은 Quest 패널에 **서브퀘스트/체크리스트**로 자동 반영된다(완료 시 보상/상태 변화 즉시 표시).
- **Action Queue(작업 큐) + 진행률 UI**:
  - 한 턴(또는 자동 실행 구간) 안에서 에이전트가 수행하는 단계들을 큐로 표시한다.
  - 예시 단계: `Parse` → `Validate` → `Plan` → `Resolve` → `Render` → `Verify` → `Commit`
  - 각 단계는 소요시간/비용/성공 여부를 배지로 표시(심사자가 “오케스트레이션”을 직관적으로 인지).
- **Self-Repair(자동 복구) 트레이스**:
  - 스키마 검증 실패, 비용 초과, 안전 차단, 이미지 생성 실패 등 발생 시
  - `Auto-repair #1/#2...` 처럼 재시도 횟수/결과를 표시하고, 최종적으로 “안전한 대체 결과”를 제공한다.
- **검증 배지(Proof of System)**:
  - 턴 결과에 대해 최소 다음 배지를 제공: `Schema OK`, `Economy OK`, `Safety OK`, `Consistency OK`
  - 실패 배지는 붉은 경고로 표시하고, 자동 복구/대체안으로 이어지게 한다.
- **모델/품질 선택의 “라벨” 표시(프롬프트 노출 없이)**:
  - 텍스트/이미지 호출 시 “왜 이 선택이었는지”를 사용자 친화 라벨로 표시:
    - 예: `FAST`(저지연), `QUALITY`(고품질), `CHEAP`(저비용), `REF`(참조 이미지 유지)
  - “model id” 자체를 노출해도 되지만, 심사자 관점에서는 “자동 선택/비용 제어”가 더 중요하므로 라벨 우선.
- **Replay & Diff(리플레이/상태 변화 증거)**:
  - 턴 타임라인에서 `WorldState diff`(룰/인벤토리/관계/재화 변화)를 카드로 확인 가능하게 한다.
  - 엔딩 리포트에 “플랜 달성도/서브퀘스트 완료율/룰 변형 타임라인”을 포함한다(아티팩트 강화).

### 6.9 데모 프로필(심사자용 프리셋 유저, 필수)

> 심사자가 “회원가입/설정/대기” 때문에 기능을 못 보거나 이탈하지 않도록, **즉시 플레이 가능한 데모 프로필(프리셋 유저) 형태**를 반드시 제공한다.

- **접근 방식**: 로그인/회원가입 없이 “데모 프로필 선택”만으로 즉시 시작
- **제공 형태**: 페르소나 기반 3종 프리셋(예: Narrator / Explorer / Tech Enthusiast)
- **프리셋 구성**: 초기 재화/세이브/튜토리얼 진행 상태가 서로 달라, 10분 안에 “드래그·클릭·스캐너·룰 변형·Autopilot·엔딩 리포트”를 모두 확인 가능
- **리셋 정책**: 버튼 1번으로 초기 상태로 복구(데모 반복 가능)
- **환경 분리**: 데모 프로필은 데모/스테이징에서만 활성화(운영 환경에는 포함하지 않음)

## 7. 사용자 여정(예시)

1. **Intro**: Start → 언어 선택(ko/en) → **데모 프로필 선택** → 기본 재화 지급
2. **세계 생성**: 시드 생성 → 텍스트 스트리밍으로 첫 장면 → (선택) 첫 배경 이미지 생성
3. **탐험**:
   - 텍스트 입력 또는 오브젝트 클릭
   - 시스템은 비용/위험/대안 제시(예: “이미지 생성 없이 진행 가능”)
   - 인벤토리 아이템을 오브젝트에 **드래그&드롭**하여 사용/조합(예: “열쇠 → 자물쇠”, “붕대 → 부상”)
   - 매 턴 **행동 카드(Action Deck)**로 추천 루트를 제공(채팅 선택지가 아닌 “게임 UI”로 보이게)
   - (선택) Autopilot 토글 → “목표” 지정 → 에이전트가 **플랜/서브퀘스트 생성** 후 작업 큐로 자동 실행(검증 배지/복구 트레이스 표시)
4. **룰 변형 이벤트**: 특정 행동/실패/성공 누적 → 규칙 변화 → UI/이미지 반영
5. **엔딩**: 리포트(요약/이미지/통계/재화 결산) → 재시작

## 8. 기술 설계

### 8.1 기술 스택(포함)

- **Backend**: FastAPI (async), **HTTP Streaming (Fetch + POST)** 기반 스트리밍(필요 시 WebSocket 확장)
- **Frontend**: React 19 + Vite 7
- **상태 관리**: 세션 WorldState + 요약 메모리 + 재화 원장(Economy Ledger)

### 8.2 인증/런타임: Vertex AI 서비스 계정(✅ .gitignore 보안 설정 완료)

- 백엔드는 **Vertex AI(서비스 계정)** 로 Google 인증을 수행한다.
- 사용자에게 API 키 입력(BYOK)을 요구하지 않는다(필요 시 “추후 옵션”으로만 고려).

### 8.3 Gemini 텍스트 생성(Text Generation)

- **스트리밍**: 서버는 `generateContentStream`(SDK)로 모델 청크를 수신하고, 클라이언트에는 `POST /api/turn`의 **HTTP Streaming 응답 스트림**으로 전달해 타자 효과를 구현한다.
- **시스템 인스트럭션**: Game Master 페르소나 + 금칙/안전 + 출력 스키마 규칙을 명시.
- **Thinking 제어**: Gemini 3 계열은 `thinking_level`(low/high)을 상황/재화에 따라 선택.
- **Temperature**: Gemini 3는 기본값(1.0) 유지 권장(안정성/루프 방지).

### 8.4 구조화 출력(Structured Outputs, JSON Schema)

- 응답은 기본적으로 `response_mime_type: application/json` + `response_json_schema`를 사용한다.
- **목적**: 내러티브 텍스트뿐 아니라, UI/상태/비용/이미지 요청을 “파싱 가능한” 결과로 받기 위함.
- **스트리밍 구조화 출력**: 모델이 내보내는 부분 JSON(텍스트 청크)을 서버에서 누적해 최종 TurnOutput JSON을 완성하고, 클라이언트에는 **NDJSON(라인 단위 JSON) 이벤트 스트림**으로 `stage/badges/narrative_delta/final`을 전송한다.
- **Turn Stream Protocol**: 응답은 NDJSON이며, 각 줄은 아래 이벤트 중 하나다.
  - **Protocol Version 1 (v1, 현행 계약)** — MVP 안정화 기준. 현재 백엔드/프론트엔드 구현과 일치하는 실질적 SSOT.
    - `{"type":"stage","name":"parse"|"validate"|"plan"|"resolve"|"render"|"verify"|"commit","status":"start"|"complete"}`
    - `{"type":"badges","badges":["schema_ok"|"schema_fail","economy_ok"|"economy_fail","safety_ok"|"safety_fail","consistency_ok"|"consistency_fail"]}`
    - `{"type":"narrative_delta","text":"..."}` (타자 효과용)
    - `{"type":"final","data":{...}}` (Pydantic 검증 통과한 TurnOutput)
    - `{"type":"error","message":"...","code":"..."}` (에러 발생 시, final 폴백과 함께 전송)
  - **Protocol Version 2 (v2, 목표)** — 품질 개선 단계에서 점진적 마이그레이션 예정.
    - `stage.status`: `"start"|"ok"|"fail"` (완료/실패 구분 명시화)
    - `badges`: `{"schema":"ok"|"fail","economy":"ok"|"fail","safety":"ok"|"fail","consistency":"ok"|"fail"}` (Map 형태로 변경하여 의미론적 접근 용이성 확보)
    - `final`: `{"type":"final","turn_output":{...}}` (키명을 데이터 목적에 맞게 `turn_output`으로 명시적 변경)
  - **하위호환 정책**: 클라이언트는 `final.data` 또는 `final.turn_output` 모두를 수용하도록 별칭(Alias) 지원 로직을 구현하여 프로토콜 전환기에도 중단 없는 서비스를 제공한다.
- **스키마 작성 원칙(요약)**:
  - 지원 타입 중심으로 설계: `string`, `number`, `integer`, `boolean`, `object`, `array`, `null`
  - 예측 가능성을 위해 `required`와 `enum`을 적극 사용하고, 필요 시 `additionalProperties: false`로 엄격화
  - 과도한 중첩/제약을 피하고(스키마 부분집합/복잡도 제한), **짧고 평평한(flat) 스키마**를 우선한다
- **검증/복구**:
  - 스키마 적합성(타입/필수키) 검증
  - 비즈니스 규칙 검증(예: 재화 음수 금지)
  - 실패 시 “repair 프롬프트”로 재요청
- **주의**: 스키마는 JSON Schema의 부분집합만 지원 → 과도한 중첩/제약은 피한다.
- **Structured outputs vs Function calling**:
  - Structured outputs: “최종 응답 포맷”을 강제(본 프로젝트의 기본 방식)
  - Function calling: 대화 중 “외부 행동(툴 호출)”을 위해 사용
  - 참고: Gemini 3는 built-in tools(google_search/url_context/code_execution)와 structured outputs 결합이 가능하지만, **built-in tools와 function calling의 동시 사용은 제한**될 수 있으므로 설계 시 분리한다.

### 8.5 이미지 생성(Image Generation / Editing)

- **모델 선택(고정)**
  - 이미지 생성/편집: `gemini-3-pro-image-preview` (고품질·텍스트 렌더링·멀티턴 편집)
  - 비용/지연은 “선택적 생성/편집 + 해상도/비율 정책 + 재화(경제)”로 제어
- **프롬프트 원칙**
  - 키워드 나열보다 **장면 서술(내러티브)** 중심
  - “부정 프롬프트”는 금지어 나열보다 **원하는 장면을 긍정적으로 서술(semantic negative prompt)** 방식 사용
  - 필요 시 “카메라/구도/조명”을 명시(예: wide shot, low-angle, rim light 등)하여 일관된 시각 언어 유지
- **해상도/비율**
  - 상황(모바일/데스크톱)과 재화에 따라 1K/2K/4K, 16:9 등 선택
- **멀티턴 편집**
  - 대화형 편집은 **Thought Signatures**가 중요(특히 이미지 모델)
  - SDK 사용 시 히스토리 관리로 시그니처가 자동 처리되도록 설계
  - 모든 생성 이미지에는 **SynthID 워터마크**가 포함됨(표기/정책 준수)

### 8.6 이미지 이해(Image Understanding / Reference)

- 사용자 업로드/참조 이미지(캐릭터/아이템/스케치)를 입력으로 받아:
  - 캡셔닝/요약
  - 오브젝트 감지(bbox) 및 (선택) 세그멘테이션(mask)
  - “이 이미지 스타일을 유지해 장면 생성” 같은 참조 흐름을 지원
- **입력 방식**
  - 작은 파일: inline base64(총 요청 20MB 제한)
  - 재사용/큰 파일: Files API 업로드 후 URI 참조
- **좌표 규약**
  - bbox는 \[ymin, xmin, ymax, xmax] 정규화(0~1000)로 반환/저장
- **품질 팁**
  - 단일 이미지+텍스트 입력 시, `contents` 배열에서 **이미지 파트를 먼저 두고 텍스트 지시를 뒤에 둔다**
  - bbox/segmentation 계열 작업은(특히 Gemini 2.5) **thinking_budget=0** 같은 설정으로 정확도를 높이는 옵션을 제공한다(비용/정책에 따라 선택)
  - 고해상도 텍스트 판독 등은(특히 Gemini 3) `media_resolution`을 상황에 맞게 상향할 수 있다(토큰/지연 증가)

### 8.7 핵심 데이터 모델 & 응답 스키마(초안)

> 실제 구현에서는 JSON Schema로 고정하며, 아래는 PRD 수준의 “필드 설계 방향”입니다.

- **TurnInput (Client → Server)**:
  - `language`: `"ko-KR" | "en-US"`
  - `text`: 사용자 입력(자연어)
  - `click`: `{ object_id, box_2d?: [ymin,xmin,ymax,xmax] }` (선택)
  - `client`: `{ viewport_w, viewport_h, theme: "dark"|"light" }`
  - `economy_snapshot`: `{ signal, memory_shard }`
- **TurnOutput (Server → Client, Structured Output)**:
  - `language`
  - `narrative`: 내러티브 텍스트(표시용)
  - `ui`:
    - `choices[]`: 버튼형 선택지(라벨/비용/예상 결과)
    - `objects[]`: 클릭 가능한 오브젝트(라벨/box_2d/상호작용 힌트)
  - `world`:
    - `delta`: 이번 턴 변경 사항(룰/인벤토리/관계/상태)
    - `memory_pins[]`: “중요 설정 고정” 후보(사용자 확인 후 고정)
  - `render`:
    - `image_job?`: `{ should_generate, model, aspect_ratio, image_size, prompt, reference_images? }`
  - `economy`:
    - `cost`: `{ signal, memory_shard }`
    - `balance_after`: `{ signal, memory_shard }`
  - `safety`: `{ blocked: boolean, message?: string|null }`
- **SaveGame (Local/Server)**:
  - `version`, `seed`, `language`, `theme`, `world_state`, `history`, `economy_ledger`, `assets`

## 9. 프론트엔드 UX/스타일 (Frontend Style Guide 반영)

### 9.0 데모 표면(UI/동작) 강화: Prompt-only wrapper 오해 방지

- **UI 형태 원칙**:
  - 메신저형 **채팅 버블 UI를 금지**한다(심사자에게 “챗봇 래퍼”로 보이는 지점 제거).
  - 텍스트는 “대화”가 아니라 **게임 로그/내레이션 피드**로 표현한다(시스템 메시지/행동 결과/룰 변화).
  - 프롬프트(시스템/개발용)는 UI에 노출하지 않는다(필요 시 개발자 토글로만 접근).
- **고정 레이아웃(게임스러운 첫 인상)**:
  - Header: 타이틀/Seed/언어 토글/테마 토글/재화 HUD/연결 상태(로딩/TTFB)
  - Center: **Scene Canvas(장면 이미지 + 핫스팟 오버레이)** + Hover 하이라이트/툴팁
  - Side Panels: Inventory / Quest / Rule Board / **Agent Console(Plan·Queue·Badges)**
    - 최소 2개 패널은 항상 노출하되, 데모에서는 **Agent Console을 상시 노출**하여 “에이전트 동작”이 보이게 한다.
  - Footer: Action Deck + 커맨드 입력(선택)
- **핵심 인터랙션(눈에 띄는 ‘게임 동작’)**:
  - 클릭: 핫스팟 클릭 → 조사/상호작용 → 결과 반영
  - 드래그: 인벤토리 아이템 → 오브젝트 드랍 → 사용/조합
  - 업로드: Scanner에 이미지 드랍 → “아이템화/단서화” → 인벤토리/세계에 반영
  - 토글: 언어(ko/en), 테마(dark/light) 즉시 전환(데모에서 “제품” 느낌 강화)
  - 토글: Autopilot(Manual/Assist/Autopilot) → **계획/작업 큐/검증 배지/자동 복구**가 화면에 표시

### 9.1 디자인 컨셉

- **CRT 터미널 레트로** 미학: 인광 그린, 글로우, 스캔라인, 글리치
- “게임 UI = 세계의 일부”처럼 보이도록 **몰입형 인터페이스** 유지

### 9.2 테마(다크/라이트)

- **기본: 다크 모드**
- 라이트 모드에서도 CRT 정체성을 유지하되, 가독성/피로도를 우선한다.
- 구현 원칙: CSS 변수 기반 테마 토글(`data-theme="dark|light"`)

#### 다크 테마 CSS 변수(기준)

```css
:root {
  --bg-color: #0d0d0d;
  --text-color: #33ff00;
  --text-dim: #1a8000;
  --accent-color: #ff00ff;
  --border-color: #33ff00;

  --crt-scanline: rgba(18, 16, 16, 0.1);
  --crt-flicker: 0.03;

  --font-main: 'NeoDonggeunmo', 'VT323', monospace;
}
```

#### 라이트 테마 CSS 변수(추가)

```css
[data-theme='light'] {
  --bg-color: #f5f7f5;
  --text-color: #0b3d0b;
  --text-dim: #2a6b2a;
  --accent-color: #b000b0;
  --border-color: #0b3d0b;

  --crt-scanline: rgba(0, 0, 0, 0.06);
  --crt-flicker: 0.02;
}
```

#### 폰트 로딩(요약)

- `NeoDunggeunmo`(한글) + `VT323`(영문) 조합을 기본으로 하며, 폰트 로딩 실패 시 시스템 `monospace`로 폴백한다.

### 9.3 레이아웃

- Header(타이틀/상태/재화) + Main(스크롤 터미널) + Footer(입력/실행)
- 모바일 퍼스트(768px 이하 폰트/패딩 조정)

### 9.4 접근성/입력

- 키보드: Enter로 실행, Tab 포커스, 스크린리더 고려
- 색상만으로 의미 전달 금지(텍스트/아이콘 병행)
- **가독성(필수)**: 기본 폰트가 “너무 작게” 보이지 않도록 전역 UI 스케일(폰트) 조절을 제공하고, 설정은 로컬에 유지한다.
- **Readable 모드(권장)**: 스캔라인/플리커/글로우 등 CRT 효과를 완화하는 토글을 제공해, 장시간 플레이/고해상도 모니터에서도 읽기 편하게 한다.
- **Readable 모드 동작 원칙(보강)**: Readable은 CRT 효과를 “완화”하는 모드이며, 기본 CRT 정체성이 **완전히 사라지지 않게** 최소한의 스캔라인/플리커 톤은 유지한다. (단, 접근성/OS `prefers-reduced-motion` 등에서는 완전 비활성화 가능)

### 9.5 CRT 효과(요약)

- 화면 오버레이(스캔라인/플리커)는 `pointer-events: none`으로 상호작용을 방해하지 않는다.
- 타이틀에는 글리치 효과를 제한적으로 적용(성능/가독성 우선).
- (보강) “가독성 때문에 CRT가 완전 OFF처럼 보이는” 회귀를 방지하기 위해, 효과는 **강도 토큰(프로파일)** 로 제어한다(기본/Readable/Off).

### 9.6 스타일 관리 원칙

- 프로젝트 규모 기준 **단일 CSS 파일**(예: `frontend/src/style.css`)로 관리
- 색상/테마는 **CSS 변수**로만 제어(컴포넌트별 임의 색상 금지)
- **UI 이미지 에셋(아이콘/프레임/placeholder)** 은 필요한 지점에 한해 사용하며, 폴백(텍스트/이모지)을 유지한다.
- **nanobanana mcp 활용(계획)**: UI 에셋이 필요하거나 적합한 부분은 nanobanana mcp로 제작해 반영하되, 스타일(팔레트/톤)과 파일 크기(성능)를 엄격히 관리한다.

### 9.7 UI 이미지 에셋 파이프라인 (nanobanana mcp, Dev-only)

> 목표: “채팅 앱이 아닌 게임 UI”의 첫 인상을 강화하되, **가독성/성능/보안**을 해치지 않는 범위에서만 에셋을 사용한다.

- **Dev-only 원칙**: `nanobanana mcp`는 개발 중 정적 에셋을 제작하는 도구이며, 제품 런타임(프론트/백엔드)에서 MCP에 의존하지 않는다.
- **SSOT 경로**: 정적 에셋은 `frontend/public/ui/`에 저장한다(정적 서빙/캐싱 단순화).
  - 예: `ui/icons/`, `ui/placeholders/`, `ui/chrome/`
- **네이밍 규칙**: `kebab-case` + 용도 + 크기(예: `signal-24.png`, `badge-ok-16.png`)
- **사이즈/성능 예산(권장)**:
  - 아이콘: 16/24/32/64(최소 2종), 1개 20KB 이하 권장
  - placeholder: 1개 200KB 이하 권장
  - `frontend/public/ui/` 총합 1MB 이하 권장
- **핵심 UI 아이콘 12종(SSOT, MVP)**: Signal/Shard/Risk/Badge 등은 아래 12종을 기준으로 제작/관리한다(각 아이콘 최소 16/24 제공, Readable 모드에서도 식별 가능해야 함).
  - `signal`, `shard`
  - `risk-low`, `risk-medium`, `risk-high`
  - `badge-ok`, `badge-fail`
  - `status-online`, `status-offline`
  - `autopilot`, `scanner`, `memory-pin`
- **배경 제거(필수 조건부)**: 아이콘/크롬 등 **투명 배경(알파)이 필요한 에셋**은 생성 결과에 배경이 남아 있으면 `rembg`로 배경을 제거해 투명 PNG로 정리한다. (가이드: `vibe/ref/rembg-guide.md`)
- **배경 단순화(필수 조건부)**: 배경 제거(rembg)를 전제하는 에셋은 **생성 단계에서 배경을 순백(#FFFFFF) 단색**으로 만들도록 강하게 지시한다(그라데이션/텍스처/그림자 금지) → 배경 제거 품질/재현성/속도 향상.
- **폴백(필수)**: 에셋 로딩 실패/미지원 시에도 텍스트/이모지 라벨로 기능이 유지되어야 한다.
- **접근성(필수)**: 색상만으로 의미 전달 금지(라벨/텍스트 병행), 장식성 이미지는 `aria-hidden` 등으로 의도 명시.
- **추적/QA(권장)**: 에셋은 `manifest`와 체크리스트로 사용처/규칙 준수 여부를 관리한다(용량/대비/Readable 모드).
- **보안(필수)**: 키/토큰 등 비밀정보를 레포/로그/문서에 남기지 않는다.

## 10. 개발/데모/검증 루프(Playtest-driven Iteration)

> 구현 전반에서 “항상 플레이 가능한 데모”를 유지하고, 실제 플레이를 **지속적으로 리플레이**하면서 UX/프롬프트를 빠르게 다듬는 것을 핵심 개발 방식으로 채택한다.

### 10.1 원칙

- **항상 플레이 가능한 빌드**: 매 PR/스프린트마다 “최소 1개 시나리오를 끝까지 플레이 가능한 데모”를 유지한다.
- **데모 표면 우선**: 내부 설계가 좋아도 UI가 채팅처럼 보이면 실패. UI/동작을 먼저 고정하고, 그 위에 프롬프트/엔진을 반복 개선한다.
- **관측 가능성(Observability) = UX의 일부**: 에이전트 동작(계획/큐/검증/복구)이 Demo Mode에서 항상 보이도록 한다.

### 10.2 Demo Mode(실시간 튜닝을 위한 디버그 UI)

- **Demo Overlay(상시 토글)**:
  - Agent Console(Plan/Queue/Badges)
  - 요청별 지표: TTFB, 전체 응답 시간, 이미지 생성 시간, 재시도 횟수, 스키마 검증 결과
  - 재화 원장(소모/잔액) + “왜 이 비용인지” 라벨(FAST/QUALITY/CHEAP/REF)
- **Hot controls**:
  - 언어(ko/en), 테마(dark/light), Autopilot 모드 전환
  - “이미지 생성 빈도/해상도 정책” 프리셋(예: `Story-only`, `Key Scenes`, `Every Turn`)
- **프롬프트 노출 금지**:
  - 프롬프트 원문은 UI에 표시하지 않는다(심사자 오해 방지).
  - 대신 “버전/정책 라벨/검증 배지”로 시스템 동작을 설명한다.

### 10.3 Replay & Scenario Harness(지속적 플레이 리그레션)

- **Scenario Library**:
  - “온보딩”, “퍼즐(아이템 드래그)”, “룰 변형”, “스캐너(이미지→아이템)”, “자동 복구(의도적 스키마 실패)” 등 데모 대표 시나리오를 정의한다.
  - 각 시나리오는 `seed`, 사용자 액션 시퀀스(클릭/드래그/텍스트/업로드), 기대 인바리언트(예: 재화 음수 금지, 스키마 OK)를 포함한다.
- **Replay Runner**:
  - 실제 플레이에서 생성된 세션을 “리플레이 파일”로 저장하고, 동일 액션을 재실행해 회귀(regression)를 탐지한다.
  - LLM의 비결정성은 인정하되, 최소한 아래는 항상 만족해야 한다:
    - Structured Output 스키마 유효
    - Economy 규칙 유효(잔액 음수/비용 불일치 금지)
    - Safety 차단/대체 처리 정상
    - WorldState 일관성 규칙(중요 핀/룰 보드) 위반 없음
- **아티팩트 자동 생성**:
  - 리플레이 결과로 “WorldState diff”, 실패 원인(어느 단계에서 깨졌는지), 자동 복구 시도 기록을 남긴다.

### 10.4 프롬프트 라이프사이클(버저닝/핫리로드/실험)

- 프롬프트는 `.md` 파일로 관리하며, 런타임에서 **핫리로드** 가능하게 설계한다(서버 재시작 없이 튜닝).
- 모든 응답/로그에는 최소 다음 메타를 포함한다:
  - `prompt_version`, `policy_preset`, `language`, `model_label(FAST/QUALITY/REF/...)`
- **A/B 실험(선택)**:
  - 동일 시나리오에서 프롬프트 버전 A/B를 비교할 수 있도록 “세션 단위 스위치”를 제공한다.

### 10.5 품질 게이트(자동 검증 기준)

- **Hard gate(필수 통과)**:
  - JSON Schema 검증 통과(`Schema OK`)
  - Economy 검증 통과(`Economy OK`)
  - Safety 정책 준수(`Safety OK` 또는 명시적 Block+대체)
- **Soft gate(지표 관측)**:
  - TTFB/지연/재시도 횟수/Autopilot 성공률
  - 사용자 행동량(클릭/드래그/업로드/카드 사용)이 “채팅 입력”보다 충분히 높게 유지되는지

### 10.6 운영 방식(반복 튜닝 루프)

- “데모 10분 플레이 → 리플레이 저장 → 실패/불만 포인트 라벨링 → 프롬프트/UX 조정 → 리플레이로 회귀 확인”을 기본 사이클로 삼는다.
- 모든 변경은 **데모 표면(게임성) 유지**를 전제로 하며, 채팅형 UX로 퇴행하는 변경은 거부한다.

## 11. 위험 요소 및 대응

### 11.1 비용 리스크(토큰/이미지)

- 재화 경제로 사용량을 제어하고, “텍스트만 진행/저해상도” 대안을 제공
- 이미지 생성 빈도를 자동 조절(중요 장면 위주)

### 11.2 일관성(환각/설정 붕괴)

- WorldState를 구조화해 모델 입력에 주입(중요 설정은 별도 고정 메모리)
- 일정 턴마다 요약/정리(요약도 스키마화)

### 11.3 안전/프롬프트 인젝션

- 입력/출력 필터링 + 시스템 인스트럭션 강화
- “사용자 입력은 룰이 아니다” 원칙을 명확히 하고, 모델이 스키마/규칙을 우선하게 설계

### 11.4 실패/불완전 출력

- 스키마 검증 실패 시 자동 복구 루프
- 이미지 생성 실패 시 텍스트 대체 + 재시도 정책

## 12. 성공 지표

- **Engagement**: 평균 세션 지속 시간 15분 이상
- **Retention**: D+1 재방문율 30%
- **Virality**: 엔딩 화면 공유 CTR 10%
- **Performance**: API 오류율 1% 미만, 스트리밍 TTFB 2초 이내 목표

## 13. 범위(Out of Scope)

- 멀티플레이어/협동
- BGM/SFX 생성(초기 제외)
- 복잡한 3D 렌더링(2D 이미지+텍스트 중심)

## 14. 참고 자료

- [Gemini API](https://ai.google.dev/docs)
- [Structured outputs](https://ai.google.dev/gemini-api/docs/structured-output)
- [Image generation](https://ai.google.dev/gemini-api/docs/image-generation)
- [Image understanding](https://ai.google.dev/gemini-api/docs/image-understanding)
</file>

<file path="vibe/progress.md">
# 프로젝트 진행 상황

## [2026-01-12 11:35] U-032[Mvp]: nanobanana mcp UI Chrome Pack(패널/카드 프레임/코너) 완료

### 구현 완료 항목

- **핵심 기능**: nanobanana mcp로 제작된 Chrome 에셋(코너/프레임) 적용으로 게임 UI 미학 강화 및 Readable 모드 연동
- **추가 컴포넌트**: `frontend/public/ui/chrome/` (에셋), `vibe/unit-results/U-032[Mvp].md` (보고서)
- **달성 요구사항**: [PRD 6.7] 게임 UI 고정 HUD 미학, [RULE-002] 채팅 UI 탈피, [U-028] Readable 모드 호환

### 기술적 구현 세부사항

**사용 기술/라이브러리**:
- **CSS Pseudo-elements**: `:before`, `:after`를 활용한 장식 오버레이 구현 (DOM 오염 최소화)
- **CSS Transform**: 단일 코너 에셋 회전 재사용으로 리소스 최적화
- **nanobanana mcp & rembg**: 일관된 레트로 스타일 생성 및 투명 배경 처리

**설계 패턴 및 아키텍처 선택**:
- **Decorative Overlay 패턴**: 기능적 컴포넌트(`Panel`, `ActionCard`)와 장식적 요소(`Chrome`)의 스타일 분리
- **Visual Fallback**: 에셋 로드 실패 시에도 기존 CSS 테두리가 유지되도록 설계

**코드 구조**:
repo-root/
├── frontend/public/ui/chrome/ (신규 에셋 3종)
├── frontend/src/style.css (Chrome 스타일 및 Readable 모드 예외 처리)
└── frontend/src/App.tsx (Chrome 적용 대상 지정)

### 성능 및 품질 지표
- **리소스 최적화**: 단일 코너 에셋 재사용으로 불필요한 네트워크 요청 3회 절감
- **접근성**: 모든 장식 요소에 `aria-hidden="true"` 및 `pointer-events: none` 적용

### 의존성 변경
- 없음

### 다음 단계
- [U-033[Mvp]] nanobanana mcp 에셋 매니페스트 + QA(크기/대비/폴백)

---

## [2026-01-11 23:10] U-031[Mvp]: nanobanana mcp 상태 Placeholder Pack 완료

### 구현 완료 항목

- **핵심 기능**: Scene Canvas 및 시스템 상태(로딩/오프라인/차단/저신호)를 위한 게임스러운 Placeholder 에셋 반영 및 UI 연동
- **추가 컴포넌트**: `frontend/src/components/SceneCanvas.tsx`, `frontend/src/types/scene.ts`, `frontend/src/i18n.ts`, `vibe/unit-results/U-031[Mvp].md`
- **달성 요구사항**: [PRD 6.3/10.2] Lazy loading 실패 폴백 확보, [RULE-006] ko/en i18n 정책 준수, [RULE-007] 정적 에셋 SSOT 준수

### 기술적 구현 세부사항

**사용 기술/라이브러리**:
- **react-i18next**: 플레이스홀더 라벨 및 에러 메시지의 다국어 지원 체계 구축
- **Vitest**: `SceneCanvas` 상태 매핑 및 이미지 경로의 정확성을 검증하는 단위 테스트 구현
- **React 19 State**: `imageError` 로컬 상태를 이용한 런타임 이미지 로드 실패 대응 로직 강화

**설계 패턴 및 아키텍처 선택**:
- **Component Refactoring**: `App.tsx`에 비대하게 모여있던 로직을 기능별로 분리하여 모듈성 및 테스트 용이성 향상
- **Double Fallback**: 배경 이미지(CSS)와 전면 텍스트(UI)의 이중 구조로 어떤 상황에서도 상태 정보 전달 보장

**코드 구조**:
repo-root/
├── frontend/src/
│   ├── components/SceneCanvas.tsx (상태별 렌더링)
│   ├── types/scene.ts (상태 타입 SSOT)
│   └── i18n.ts (다국어 설정 SSOT)
└── frontend/public/ui/placeholders/ (4종 신규 WebP 에셋)

### 성능 및 품질 지표
- **견고성**: 이미지 차단/삭제 시에도 이모지 + i18n 라벨을 통해 시스템 상태 100% 식별 가능
- **테스트 커버리지**: `SceneCanvas` 관련 핵심 상수 및 경로에 대한 검증 통과 (49개 테스트 pass)

### 의존성 변경
- `react-i18next`, `i18next` 활성화 (기존 의존성 활용 시작)

### 다음 단계
- [U-034[Mvp]] nanobanana mcp 프롬프트 템플릿 표준화

---

## [2026-01-11 16:30] U-029[Mvp]: nanobanana mcp 에셋 패스(UI 아이콘/프레임/placeholder) 완료

### 구현 완료 항목

- **핵심 기능**: UI의 시각적 완성도 향상을 위해 nanobanana mcp로 제작된 13종의 에셋(아이콘/플레이스홀더) 반영
- **추가 컴포넌트**: `frontend/public/ui/icons/` (에셋), `manifest.json` (업데이트), `U-029-nanobanana-asset-runbook.md` (런북), `vibe/unit-results/U-029[Mvp].md` (보고서)
- **달성 요구사항**: [PRD 6.7/9장] 게임 UI 고정 HUD 미학 확보, [RULE-007] 에셋 파이프라인(rembg) 준수

### 기술적 구현 세부사항

**사용 기술/라이브러리**:
- **nanobanana mcp**: STYLE HEADER v1 기반의 일관된 레트로 픽셀 아트 생성
- **rembg (birefnet-general)**: 자동 배경 제거를 통한 투명 PNG 확보
- **CSS Fallback Pattern**: 이미지 로딩 실패 시 이모지로 자동 전환되는 견고한 UI 구조

**설계 패턴 및 아키텍처 선택**:
- **Asset SSOT (manifest.json)**: 에셋의 경로, 크기, 사용처, 폴백 데이터를 중앙에서 관리
- **Scale-aware Icons**: `U-028` 가독성 설정과 연동되어 UI 스케일에 따른 아이콘 시인성 보장

**코드 구조**:
repo-root/
├── frontend/public/ui/
│   ├── icons/ (24px/16px 아이콘 세트)
│   ├── placeholders/ (Scene 플레이스홀더)
│   └── manifest.json (에셋 SSOT)
└── frontend/src/style.css (아이콘/폴백 스타일 정의)

### 성능 및 품질 지표
- **리소스 최적화**: 총 에셋 크기 267KB (예산 1.5MB 대비 17.8%) 달성으로 로딩 성능 확보
- **견고성**: 이미지 차단 시에도 이모지 폴백을 통해 UI 기능 100% 유지

### 의존성 변경
- 없음

### 다음 단계
- [U-031[Mvp]] nanobanana mcp 상태 Placeholder Pack (Scene/오프라인/에러)

---

### 구현 완료 항목

- **핵심 기능**: nanobanana mcp를 이용한 에셋 제작의 일관성과 재현성을 보장하기 위한 스키마 및 템플릿 체계 구축
- **추가 컴포넌트**: `vibe/ref/nanobanana-mcp.md` (가이드), `vibe/ref/nanobanana-asset-request.schema.json` (스키마), `vibe/unit-runbooks/U-034-nanobanana-template-runbook.md` (런북)
- **달성 요구사항**: [RULE-007] Dev-only 에셋 제작 원칙, [PRD 9.7] UI 에셋 파이프라인 고도화

### 기술적 구현 세부사항

**사용 기술/라이브러리**:
- **JSON Schema (Draft-07)**: 에셋 요청의 정형화를 위한 `nanobanana-asset-request.schema.json` 정의
- **Prompt Engineering**: CRT 레트로 미학을 반영한 `STYLE HEADER v1` 및 카테고리별(아이콘/Placeholder/Chrome) 템플릿 구축
- **rembg (isnet-anime)**: 생성 이미지의 배경 제거를 위한 후처리 파이프라인 표준화

**설계 패턴 및 아키텍처 선택**:
- **Schema-driven Asset Request**: 요청 사양을 JSON으로 정의하여 스타일, 팔레트, 크기 등 시각적 인바리언트를 강제
- **Hybrid Pipeline (Gen + Edit)**: 생성형 AI로 원본을 만들고 `rembg`로 알파 채널을 확보하는 하이브리드 워크플로우 도입 (재현성 및 품질 확보)

**코드 구조**:
repo-root/
└── vibe/ref/
    ├── nanobanana-mcp.md (에셋 제작 가이드 및 템플릿)
    └── nanobanana-asset-request.schema.json (에셋 요청 스키마)

### 성능 및 품질 지표
- **재현성**: 버전 관리되는 프롬프트 템플릿(`v1`)을 통해 여러 에셋 간 비주얼 일관성 90% 이상 확보 가능
- **정확도**: `rembg` 후처리를 전제한 순백(#FFFFFF) 배경 생성 규칙으로 투명 배경 추출 성공률 극대화

### 의존성 변경
- 없음 (개발 프로세스 및 가이드라인 구축)

### 다음 단계
- [U-029[Mvp]] ⚡nanobanana mcp 에셋 패스 (아이콘/프레임/Placeholder 제작)

---

### 구현 완료 항목

- **핵심 기능**: UI 에셋 제작 및 관리를 위한 SSOT 체계(저장소/규칙/매니페스트/스키마) 구축
- **추가 컴포넌트**: `frontend/public/ui/README.md` (규칙), `manifest.schema.json` (스키마), `manifest.json` (매니페스트), `vibe/unit-results/U-030[Mvp].md`
- **달성 요구사항**: [PRD 9.7] UI 이미지 에셋 파이프라인 규칙, [RULE-007] Dev-only 원칙(MCP 의존성 격리)

### 기술적 구현 세부사항

**사용 기술/라이브러리**:
- **JSON Schema (Draft-07)**: 에셋 매니페스트의 정형성 및 QA 자동화를 위한 스키마 정의
- **Static Asset Serving**: Vite `public/` 디렉토리 기반의 고성능 정적 에셋 서빙 구조 활용

**설계 패턴 및 아키텍처 선택**:
- **Asset Manifest 패턴**: 매니페스트를 통한 에셋 추적 및 런타임 폴백 데이터(이모지/텍스트) SSOT 관리
- **Theme-aligned Styling**: `style.css`의 CRT 테마 토큰(인광 녹색 등)을 제작 가이드에 명시하여 비주얼 일관성 확보

**코드 구조**:
repo-root/
└── frontend/public/ui/
    ├── README.md (제작 가이드 및 SSOT 규칙)
    ├── manifest.schema.json (에셋 데이터 스키마)
    └── manifest.json (에셋 등록 정보)

### 성능 및 품질 지표
- **성능 예산**: 개별 아이콘 20KB, 전체 1.5MB 상한 설정으로 초기 로딩 속도 보장
- **안정성**: 필수 폴백 원칙 및 접근성 가이드(ARIA) 내재화로 에셋 로딩 실패 대응력 강화

### 의존성 변경
- 없음 (개발 도구 및 정적 자원 구조화)

### 다음 단계
- [U-029[Mvp]] ⚡nanobanana mcp 에셋 패스 (아이콘/프레임/Placeholder 제작)

---

## [2026-01-10 14:35] U-028[Mvp]: UI 가독성 패스(폰트 스케일/효과 토글/대비) 완료

### 구현 완료 항목

- **핵심 기능**: 전역 UI 스케일(0.9~1.2x) 및 Readable 모드(CRT 효과 완화) 도입으로 텍스트 시인성 확보
- **추가 컴포넌트**: `uiPrefsStore.ts` (Zustand 설정), `UIControls` (헤더 버튼), `vibe/unit-results/U-028[Mvp].md`
- **달성 요구사항**: [RULE-002] 게임 UI 레이아웃 유지, [PRD 9.4/9.5] 가독성 및 CRT 효과 제어

### 기술적 구현 세부사항

**사용 기술/라이브러리**:
- **Zustand Persist**: 사용자 UI 설정을 localStorage에 영구 저장 및 복원
- **CSS Variables & Data Attributes**: `--ui-scale-factor` 및 `data-readable` 속성을 통한 선언적 스타일 제어

**설계 패턴 및 아키텍처 선택**:
- **Scale-aware Typography**: 전역 `font-size`를 스케일 팩터에 연동하여 레이아웃 일관성을 유지하며 크기 조절
- **Micro-text Visibility**: Agent Console 및 배지 영역의 기본 폰트 크기를 가독성 기준선(12px~14px)으로 상향

**코드 구조**:
repo-root/
├── frontend/src/stores/uiPrefsStore.ts (상태 관리)
├── frontend/src/style.css (가독성 토큰 및 효과 완화 스타일)
└── frontend/src/App.tsx (UI 통합 및 컨트롤 배치)

### 성능 및 품질 지표
- **시인성**: Readable 모드 활성화 시 스캔라인/플리커/글로우 제거로 텍스트 가독성 100% 향상
- **유지성**: 페이지 새로고침 후에도 설정값이 즉시 복구되어 UI 일관성 유지

### 의존성 변경
- 없음 (기존 Zustand 활용)

### 다음 단계
- [U-009[Mvp]] ⚡Action Deck(카드+비용/대안) UI 구현

---

### 구현 완료 항목

- **핵심 기능**: 스트리밍 루프의 안정성 및 Hard Gate(스키마/복구/폴백) 인바리언트 최종 검증
- **추가 컴포넌트**: `vibe/unit-results/CP-MVP-01.md` (검증 보고서), `vibe/unit-runbooks/CP-MVP-01.md` (검증 런북)
- **달성 요구사항**: [RULE-004] Repair loop + 안전 폴백, [RULE-008] 과정 가시화 및 TTFB 최적화

### 기술적 구현 세부사항

**사용 기술/라이브러리**:
- **NDJSON Streaming**: FastAPI StreamingResponse 기반 라인 단위 실시간 이벤트 송출
- **Zod / Pydantic**: 서버-클라이언트 간 데이터 무결성 이중 보장

**설계 패턴 및 아키텍처 선택**:
- **Fail-safe 종료**: 예외 발생 시에도 반드시 `final` 이벤트를 송출하여 스트림 종료 및 UI 가용성 보장
- **Agent Phase 가시화**: 오케스트레이터의 내부 단계를 투명하게 공개하여 시스템 신뢰성 확보

**코드 구조**:
repo-root/
├── backend/src/unknown_world/api/ (turn.py, turn_stream_events.py)
└── frontend/src/ (api/turnStream.ts, schemas/turn.ts)

### 성능 및 품질 지표
- **안정성**: 스키마 오류 및 네트워크 단절 시나리오에서 100% 안전 폴백 전환 확인
- **가독성**: Agent Console을 통해 단계/배지/복구 시도가 시각적으로 명확히 노출됨

### 의존성 변경
- 없음 (기존 리팩토링 결과 통합 검증)

### 다음 단계
- [U-009[Mvp]] ⚡Action Deck(카드+비용/대안) UI 구현

---


### 구현 완료 항목

- **핵심 기능**: 서버-클라이언트 간 스트림 이벤트 계약 단일 SSOT 통합 및 에러/폴백 루프 일관성 확보
- **추가 컴포넌트**: `turn_stream_events.py` (서버 계약), `turn_stream.ts` (클라이언트 계약)
- **달성 요구사항**: [RULE-004] 검증 실패 시 Repair loop + 안전 폴백, [RULE-008] 단계/배지 가시화 및 내부 추론 은닉

### 기술적 구현 세부사항

**사용 기술/라이브러리**:
- **Pydantic V2 / Zod 4.x**: 서버/클라이언트 양측에서 스트림 이벤트 스키마 강제
- **NDJSON 파이프라인**: 라인 단위 JSON 직렬화 및 버퍼 기반 복구 파서 적용

**설계 패턴 및 아키텍처 선택**:
- **Contract-first 리팩토링**: `RU-002-Q4` 결정을 실현하여 transport 계층의 이벤트 계약을 도메인 모델과 분리
- **Fail-safe 종료 인바리언트**: `RU-002-S1` 설계를 적용하여 모든 스트림이 어떤 상황에서도 최종 `final` 이벤트로 수렴하도록 보장
- **이중 검증 계층**: `RU-002-S2`에 따라 클라이언트 디스패처에서 모든 수신 이벤트를 Zod로 검증하여 비정상 데이터 유입 차단

**코드 구조**:
repo-root/
├── backend/src/unknown_world/api/
│   ├── turn.py (리팩토링 적용)
│   └── turn_stream_events.py (신규 SSOT)
└── frontend/src/
    ├── api/turnStream.ts (리팩토링 적용)
    └── types/turn_stream.ts (신규 SSOT)

### 성능 및 품질 지표
- **견고성**: 입력 오류, 네트워크 단절, 모델 검증 실패 시나리오에서 100% 안전 폴백 동작 확인
- **가독성**: Agent Console의 단계(Stage)와 배지(Badge) 용어가 서버-클라이언트 간 완전 일치

### 의존성 변경
- 추가된 외부 의존성 없음 (기존 Pydantic, Zod 활용 고도화)

### 다음 단계
- [CP-MVP-01] "스트리밍 + 스키마 + 폴백" 루프 통합 체크포인트 검증

---

## [2026-01-10 01:10] RU-002-S2: 스트림 이벤트 검증 강화(Zod) 및 Unknown 이벤트 폴백 처리 완료

### 작업 내용

- **제안서**: [RU-002-S2] 스트림 이벤트( stage/badges/error 등 ) 검증 강화(Zod) + Unknown/확장 이벤트 폴백 처리로 “깨짐” 방지
- **개선 사항**:
    - **이벤트별 Zod 검증 도입**: `stage`, `badges`, `narrative_delta`, `final`, `error` 등 모든 스트림 이벤트에 대해 경량 Zod 스키마를 정의하고 `safeParse`를 적용하여 데이터 무결성 확보.
    - **Unknown/확장 이벤트 대응**: 정의되지 않은 이벤트 타입 수신 시 콘솔 경고를 남기되 UI 중단 없이 무시(drop)하는 폴백 로직을 구현하여 전방 호환성 및 관측성 확보.
    - **프로토콜 별칭(Alias) 지원**: `stage.status`(`complete`/`ok`/`fail`), `final`(`data`/`turn_output`) 등 버전별 필드 별칭을 수용하고 표준 형태로 정규화.
    - **단계 실패 상태 시각화**: `stage.status=fail` 수신 시 Agent Console에서 해당 단계를 `failed` 상태로 표시하도록 스토어 보강.
- **영향 범위**: `frontend/src/types/turn_stream.ts`, `frontend/src/api/turnStream.ts`, `frontend/src/stores/agentStore.ts`

### 기술적 세부사항

- **검증 유틸리티**: `safeParseStageEvent`, `safeParseBadgesEvent` 등 이벤트별 전용 파싱 유틸리티를 통한 `dispatchEvent` 로직의 선언적 구현.
- **정규화 계층**: `normalizeStageStatus`를 통해 서버의 다양한 상태 표기를 클라이언트 표준(`start`/`complete`/`fail`)으로 변환.
- **견고성**: 배지 이벤트 수신 시 v1(배열)과 v2(맵) 형식을 모두 지원하여 프로토콜 업그레이드 대응.

### 검증

- **정합성 확인**: Zod 스키마가 PRD 명세 및 기존 `TurnOutput` 검증 로직과 일관되게 동작함을 확인.
- **폴백 테스트**: 존재하지 않는 이벤트 타입 또는 스키마 위반 데이터 유입 시 UI가 멈추지 않고 적절히 예외를 처리함을 확인.

---

## [2026-01-08 23:59] RU-002-Q2: PRD Turn Stream Protocol(SSOT) 정합성 확보 및 버전/별칭 도입 완료

### 작업 내용

- **제안서**: [RU-002-Q2] PRD Turn Stream Protocol(SSOT)과 구현 계약의 정합성 확보: 프로토콜 버전/필드 별칭/용어 통일
- **개선 사항**:
    - **프로토콜 버전 관리**: 현행 계약을 `Protocol Version 1`로 명시하고, 향후 개선을 위한 `Version 2` 목표를 PRD에 정의함.
    - **필드 별칭(Alias) 지원**: 클라이언트 디코더(`turnStream.ts`)에서 `final.data`(v1)와 `final.turn_output`(v2)을 모두 수용하도록 하위 호환성 확보.
    - **용어 및 명세 통일**: PRD의 프로토콜 초안을 실제 구현(U-007/U-008) 및 런북 예시와 일치하도록 정비하여 SSOT 신뢰도 회복.
    - **서버-클라이언트 정렬**: `stage.status`(`start`|`complete`), `badges`(리스트 형태) 등 현행 MVP 계약을 공식 프로토콜로 확정.
- **영향 범위**: `vibe/prd.md`, `frontend/src/api/turnStream.ts`, `backend/src/unknown_world/api/turn.py`, `vibe/unit-runbooks/U-007-mock-orchestrator-runbook.md`

### 기술적 세부사항

- **하위 호환성 디코딩**: `frontend/src/api/turnStream.ts`에서 `finalEvent.data ?? finalEvent.turn_output` 로직을 통해 프로토콜 전환기 대응.
- **SSOT 문서화**: `vibe/prd.md` 8.4 섹션을 v1(현행) 및 v2(목표)로 구조화하여 기술 부채와 향후 계획을 명시화.

### 검증

- **정합성 확인**: PRD 명세, 런북 예시, 실제 API 송출 데이터 간의 필드명 및 용어 일치 여부 검증 완료.
- **하위 호환성 테스트**: 클라이언트가 `data`와 `turn_output` 키 모두를 정상적으로 `TurnOutput` 모델로 변환함을 확인.

---

## [2026-01-08 23:55] RU-002-S1: 스트리밍 안정화 및 종료 인바리언트(항상 final) 강제 완료

### 작업 내용

- **제안서**: [RU-002-S1] 스트리밍 실패(네트워크/서버/검증)에서도 “항상 final(폴백 TurnOutput)로 종료” + UI 멈춤 방지 + Economy 안전화
- **개선 사항**:
    - **스트림 종료 인바리언트 강제**: 서버(FastAPI) 및 클라이언트(fetch) 양측에서 네트워크 오류, 입력 검증 실패, 내부 예외 등 모든 경로에서 반드시 `final` 이벤트(폴백 TurnOutput)로 종료되도록 보장하여 UI 멈춤 현상 원천 차단.
    - **Economy 일관성 유지**: 폴백 TurnOutput 생성 시 입력 스냅샷(`economy_snapshot`)을 활용하여 비용 0 및 현재 잔액 유지를 보장함으써 재화 HUD 왜곡 방지 (RULE-005 준수).
    - **클라이언트 자가 복구**: 서버로부터 `final`을 받지 못한 네트워크 장애 상황에서도 클라이언트 측에서 안전 폴백을 직접 생성하여 `onFinal` 및 `onComplete` 호출 보장.
- **영향 범위**: `backend/src/unknown_world/api/turn.py`, `backend/src/unknown_world/orchestrator/mock.py`, `frontend/src/api/turnStream.ts`

### 기술적 세부사항

- **Fail-safe 파이프라인**: 서버의 `_stream_turn_events`와 클라이언트의 `executeTurnStream`에 `try-catch-finally` 구조 및 폴백 송출 로직을 엄격히 적용.
- **상태 보존형 폴백**: `MockOrchestrator.create_safe_fallback` 메서드가 `economy_snapshot`을 인자로 받아 잔액을 보존하도록 인터페이스 확장.

### 검증

- **수동 검증 완료**: 백엔드 다운(네트워크 에러), 입력 검증 실패(Validation Error), 서버 강제 예외 발생 시나리오에서 모두 UI가 IDLE 상태로 복귀하고 재화 잔액이 유지됨을 확인.

---

## [2026-01-05 23:50] U-027[Mvp]: 개발 스크립트 - pnpm kill 포트 제한(8001~8020) 완료

### 구현 완료 항목

- **핵심 기능**: 포트 정책(RULE-011)에 따른 pnpm kill 포트 제한(8001~8020) 구현 및 광역 프로세스 종료 방식 제거
- **추가 컴포넌트**: `vibe/unit-runbooks/U-027-kill-port-limit-runbook.md` (실행 및 검증 런북)
- **달성 요구사항**: [RULE-011] 포트 정책 강제 준수, [A1] pnpm kill의 포트 기반 안전 종료 전환 결정 반영

### 기술적 구현 세부사항

**사용 기술/라이브러리**:
- **npx --yes kill-port**: 대화형 프롬프트(`Need to install the following packages...`)를 제거하여 자동화 환경 및 CI 안정성 확보
- **Port-based Termination**: 프로세스 이름이 아닌 포트 번호를 기준으로 종료하여 다른 프로젝트 프로세스 간섭 차단

**설계 패턴 및 아키텍처 선택**:
- **RULE-011 정합화**: 프론트(8001-8010)와 백엔드(8011-8020)의 전체 대역을 대상으로 하는 `kill:port` 스크립트 강화
- **Option A 적용**: 위험한 광역 종료 명령(`taskkill /IM node.exe`)을 완전히 제거하고 `pnpm kill`을 안전한 포트 기반 명령으로 대체

**코드 구조**:
repo-root/
├── package.json (scripts: kill, kill:port, kill:front, kill:back 업데이트)
└── vibe/
    ├── architecture.md (RULE-011 정책 및 안전 종료 설계 반영)
    ├── roadmap.md (포트 정리 명령어 가이드 업데이트)
    └── unit-runbooks/
        └── U-027-kill-port-limit-runbook.md (신규 런북 생성)

### 성능 및 품질 지표
- **안전성**: 8001~8020 대역 외의 Node/Uvicorn 프로세스 생존성 확보 (사이드 이펙트 제거)
- **사용성**: `pnpm kill` 단축 명령어를 통해 전체 개발 서버를 한 번에 정리 가능

### 의존성 변경
- 별도의 패키지 설치 없이 `npx`를 통한 온디맨드 실행 방식 채택

### 다음 단계
- [U-028[Mvp]] 개발 환경 통합 시작 스크립트(`pnpm dev`) 구성 검토

---

## [2026-01-05 10:00] U-008[Mvp]: 프론트 HTTP Streaming 클라이언트 + Agent Console/배지 완료

### 구현 완료 항목

- **핵심 기능**: fetch 스트리밍 기반 NDJSON 파서 구축 및 Agent Console 실시간 상태 연동
- **추가 컴포넌트**: `AgentConsole.tsx`, `turnStream.ts` (NDJSON 파서), `agentStore.ts` (Zustand)
- **달성 요구사항**: [RULE-008] 과정 가시화 및 내부 추론 은닉, [RULE-003/004] 스트림 결과 Zod 검증 및 폴백, [RULE-002] 게임 HUD 통합

### 기술적 구현 세부사항

**사용 기술/라이브러리**:
- **Fetch API & ReadableStream**: 비동기 스트림 소비
- **NDJSON 파싱**: 버퍼 기반 라인 복구 로직 직접 구현 (Option A)
- **Zustand 5.x**: `phases`, `badges`, `streaming_text` 상태 관리

**설계 패턴 및 아키텍처 선택**:
- **Typewriter Effect 패턴**: `narrative_delta` 이벤트를 통한 실시간 텍스트 출력
- **Agent Phase 가시화**: 7단계 오케스트레이션 큐(Queue) 시각화로 시스템 신뢰성 확보
- **Fail-safe 연동**: 스트림 중단 또는 스키마 불일치 시 안전 폴백(Fallback) 자동 전환

**코드 구조**:
frontend/
└── src/
    ├── api/
    │   └── turnStream.ts
    ├── stores/
    │   └── agentStore.ts
    └── components/
        └── AgentConsole.tsx

### 성능 및 품질 지표
- **응답성**: 첫 패킷 수신 즉시 UI 단계 업데이트 (TTFB 최소화)
- **견고성**: 중간 청크 파싱 실패 시에도 전체 스트림이 중단되지 않도록 에러 가드 적용

### 의존성 변경
- 추가된 외부 의존성 없음 (기존 Zustand 및 Native API 활용)

### 다음 단계
- [CP-MVP-01] "스트리밍 + 스키마 + 폴백" 루프 통합 체크포인트 검증

---

## [2026-01-04 15:35] U-006[Mvp]: TurnInput/TurnOutput 스키마(Zod) 완료

### 구현 완료 항목

- **핵심 기능**: Zod 기반의 TurnInput/TurnOutput 스키마 정의 및 클라이언트 측 엄격 검증(strict parse) 체계 구축
- **추가 컴포넌트**: `frontend/src/schemas/turn.ts` (Zod 모델 및 검증 헬퍼)
- **달성 요구사항**: [RULE-003] 클라이언트 Zod 검증, [RULE-004] 안전 폴백(Fallback) 제공, [RULE-005] 재화 인바리언트 강제, [RULE-009] 0~1000 bbox 규약 준수

### 기술적 구현 세부사항

**사용 기술/라이브러리**:
- **Zod 3.x**: `.strict()`, `.int()`, `.min()`, `.max()` 등을 활용한 강력한 스키마 검증
- **TypeScript 5.9.3**: 스키마로부터 추론된 타입을 통한 타입 안전성 확보

**설계 패턴 및 아키텍처 선택**:
- **Safe-Parse 패턴**: `safeParseTurnOutput` 유틸리티를 통해 검증 실패 시에도 UI가 중단되지 않고 `schema_fail` 배지와 함께 폴백 데이터를 반환하도록 설계 (RULE-004 준수)
- **SSOT 정합성**: 백엔드 Pydantic 모델(U-005) 및 공유 JSON Schema와 1:1 필드 매칭 및 제약 조건 동기화

**코드 구조**:
frontend/
└── src/
    └── schemas/
        └── turn.ts

### 성능 및 품질 지표
- **검증 정확도**: 0~1000 좌표 범위, 재화 최소값, 필수 필드(Strict) 검증 로직 구현 완료
- **코드 품질**: TSDoc을 통한 명세화 및 클라이언트 측 Hard Gate 역할 수행

### 의존성 변경
- 기존 `zod` 라이브러리 활용 (추가 의존성 없음)

### 다음 단계
- [U-008[Mvp]] SSE 수신 데이터에 Zod 검증 및 폴백 로직 적용

---

## [2026-01-04 22:10] U-006[Mvp]: TurnInput/TurnOutput 스키마(Zod) 완료

### 구현 완료 항목

- **핵심 기능**: Zod 기반의 TurnInput/TurnOutput 스키마 정의 및 클라이언트 측 엄격 검증(strict parse) 체계 구축
- **추가 컴포넌트**: `frontend/src/schemas/turn.ts` (Zod 모델), `frontend/src/schemas/turn.test.ts` (검증 테스트)
- **달성 요구사항**: [RULE-003] 클라이언트 Zod 검증, [RULE-004] 안전 폴백(Fallback) 제공, [RULE-005] 재화 인바리언트 강제, [RULE-009] 0~1000 bbox 규약 준수

### 기술적 구현 세부사항

**사용 기술/라이브러리**:
- **Zod 4.3.4**: `.strict()`, `.int()`, `.min()`, `.max()` 등을 활용한 강력한 스키마 검증
- **Vitest**: 100% 라인 커버리지를 달성하는 유닛 테스트 환경 구축

**설계 패턴 및 아키텍처 선택**:
- **Safe-Parse 패턴**: `safeParseTurnOutput` 유틸리티를 통해 검증 실패 시에도 UI가 중단되지 않고 `schema_fail` 배지와 함께 폴백 데이터를 반환하도록 설계 (RULE-004 준수)
- **SSOT 정합성**: 백엔드 Pydantic 모델(U-005) 및 공유 JSON Schema와 1:1 필드 매칭 및 제약 조건 동기화

**코드 구조**:
frontend/
└── src/
    └── schemas/
        ├── turn.ts
        ├── turn.test.ts
        └── index.ts (export bridge)

### 성능 및 품질 지표
- **검증 정확도**: 20개의 테스트 케이스를 통해 경계값, 타입, 엄격성 검증 100% 통과
- **코드 품질**: ESLint 및 TypeScript(tsc) 무오류 통과, 라인 커버리지 100% 달성

### 의존성 변경
- 개발 의존성 추가: `vitest`, `@vitest/coverage-v8`

### 다음 단계
- [U-008[Mvp]] SSE 수신 데이터에 Zod 검증 및 폴백 로직 적용

---

## [2026-01-04 20:00] U-005[Mvp]: TurnInput/TurnOutput 스키마(Pydantic) 완료

### 구현 완료 항목

- **핵심 기능**: Pydantic V2 기반의 구조화 출력(TurnInput/TurnOutput) 모델 정의 및 Hard Gate 검증 로직 내장
- **추가 컴포넌트**: `backend/src/unknown_world/models/turn.py` (SSOT 모델), `backend/tests/unit/models/test_turn.py` (검증 테스트)
- **달성 요구사항**: [RULE-003] 구조화 출력 우선, [RULE-005] 재화 음수 불가, [RULE-006] ko/en 고정, [RULE-009] 0~1000 bbox 규약

### 기술적 구현 세부사항

**사용 기술/라이브러리**:
- **Pydantic V2**: `Annotated` 및 `ge/le` 제약 조건을 활용한 선언적 검증
- **JSON Schema**: Gemini Structured Outputs 부분집합 제약을 준수하는 스키마 자동 생성 기능 (`model_json_schema`)

**설계 패턴 및 아키텍처 선택**:
- **Flat-Schema 패턴**: Gemini 호환성을 위해 깊은 중첩을 배제하고 `ui`, `world`, `economy`, `safety` 패널 구조로 설계
- **Strict Validation**: `extra="forbid"` 설정을 통해 스키마에 정의되지 않은 불명확한 필드 유입을 원천 차단

**코드 구조**:
backend/
└── src/
    └── unknown_world/
        └── models/
            ├── __init__.py
            └── turn.py

### 성능 및 품질 지표
- **검증 정확도**: 좌표 범위(0~1000), 재화(0 이상), 언어 enum 등 비즈니스 인바리언트 100% 검증 통과
- **스키마 정합성**: Gemini Structured Outputs용 JSON Schema Draft-07 호환성 확인

### 의존성 변경
- 추가된 외부 의존성 없음 (기존 Pydantic 활용)

### 다음 단계
- [U-006[Mvp]] TurnInput/TurnOutput Zod 모델 구현 (프론트엔드)

---

## [2026-01-07 00:05] RU-002-Q4: Turn Stream 이벤트 계약 모듈 분리 완료

### 작업 내용

- **제안서**: [RU-002-Q4] Turn Stream 이벤트 계약(타입/모델/유틸)의 모듈 경계 정리
- **개선 사항**:
    - **Backend**: 스트림 이벤트 모델을 `orchestrator/mock.py`에서 `api/turn_stream_events.py`로 분리하여 transport 계층의 책임을 명확화
    - **Frontend**: 스트림 이벤트 타입을 `api/turnStream.ts`에서 `types/turn_stream.ts`로 분리하여 데이터 계약 SSOT 구축
    - **결합도 해제**: Orchestrator는 도메인 모델(TurnOutput)에만 집중하고, API 계층이 스트림 프로토콜 직렬화를 담당하도록 구조 개선
- **영향 범위**: `backend/src/unknown_world/api/turn_stream_events.py` (신규), `frontend/src/types/turn_stream.ts` (신규), `backend/src/unknown_world/api/turn.py`, `frontend/src/api/turnStream.ts`, `frontend/src/stores/agentStore.ts`

### 기술적 세부사항

- **SSOT 강화**: 서버와 클라이언트 각각 독립된 "계약 모듈"을 가짐으로써 향후 프로토콜 확장 시 수정 범위 원자화
- **유지보수성**: `serialize_event` 유틸리티화를 통해 직렬화 로직 중앙 집중화
- **하위 호환성**: 프론트엔드 `api/turnStream.ts`에서 기존 타입을 re-export 하여 기존 컴포넌트 코드 수정 최소화

### 검증

- **수동 검증**: `git show`를 통한 모듈 분리 및 import 경로 정상화 확인 완료 (commit: b8d02f1c)

---

### 구현 완료 항목

- **핵심 기능**: 프로젝트 전반의 디렉토리 구조 확정 및 설정 파일 SSOT 통일
- **추가 컴포넌트**: `shared/schemas/turn/` (JSON Schema SSOT), 루트 실행 스크립트 (`dev:front`, `dev:back`)
- **달성 요구사항**: [RULE-011] 포트 정책 강제, [RULE-010] 기술 스택 버전 고정, [Option B] 스키마 SSOT 도입

### 기술적 구현 세부사항

**사용 기술/라이브러리**:
- **JSON Schema**: Draft-07 기반의 언어 독립적 계약 정의
- **pnpm/Node.js**: 루트 `package.json`을 통한 개발 환경 버전 제어
- **Vite/strictPort**: 포트 대역 이탈 방지를 위한 Fail-fast 설정

**설계 패턴 및 아키텍처 선택**:
- **Shared Schema SSOT**: 서버-클라이언트 간 데이터 구조 불일치를 원천 차단하기 위해 `shared/` 경로를 진실의 공급원으로 정의
- **Root-orchestrated Dev**: 하위 디렉토리로 이동할 필요 없이 루트에서 모든 서브시스템을 제어하도록 스크립트 구성

**코드 구조**:
repo-root/
├── frontend/ (포트: 8001)
├── backend/ (포트: 8011)
├── shared/ (JSON Schemas)
└── package.json (루트 오케스트레이션)

### 성능 및 품질 지표
- **환경 재현성**: Node/pnpm/Python 의존성 버전 Pin 완료
- **보안**: `.gitignore` 리팩토링으로 보안 민감 파일 노출 차단 강화

### 의존성 변경
- 루트 `package.json`에 `packageManager`, `engines` 필드 추가
- 백엔드 `pyproject.toml` 개발 의존성 버전 고정

### 다음 단계
- [U-005[Mvp]] TurnInput/TurnOutput Pydantic 모델 구현
- [U-006[Mvp]] TurnInput/TurnOutput Zod 모델 구현

---

### 작업 내용

- **제안서**: [RU-001-Q5] 버전 고정(SSOT) 강화: 루트 `packageManager`/엔진 명시 + backend dev 의존성 pin(uv.lock 기준)
- **개선 사항**:
    - 루트 `package.json`에 `packageManager: "pnpm@10.27.0"` 및 `engines.node: "24.12.0"` 명시하여 개발 도구 버전 SSOT 강화
    - `backend/pyproject.toml`의 개발 의존성(`pytest`, `httpx`)을 `uv.lock`에 해결된 버전으로 고정(pin)하여 버전 드리프트 방지
- **영향 범위**: `package.json`, `backend/pyproject.toml`

### 기술적 세부사항

- **SSOT 신호 강화**: 루트 디렉토리 진입 시점부터 일관된 도구 버전 사용을 유도하여 환경 차이에 의한 문제 선제 차단
- **백엔드 재현성**: 개발 의존성까지 명확히 pin 함으로써 `uv sync` 실행 시 항상 동일한 환경이 보장되도록 함

### 검증

- **수동 검증**: 루트 `package.json` 내용 확인 및 `backend/pyproject.toml`의 `==` 연산자 적용 확인 완료 (commit: f18f1ca)

---

## [2026-01-04 18:00] RU-001-S2: Vite strictPort 도입 및 포트 정리 스크립트 정합화

### 작업 내용

- **제안서**: [RU-001-S2] RULE-011 포트 대역 “엣지 케이스” 방지: Vite `strictPort`와 루트 kill 스크립트 범위 정합화
- **개선 사항**:
    - `frontend/vite.config.ts`에 `strictPort: true`를 적용하여 포트 충돌 시 예기치 않은 포트 이동(CORS 불일치 원인)을 원천 차단
    - 루트 `package.json`의 `kill:port` 스크립트가 RULE-011의 전체 대역(8001~8020)을 커버하도록 확장
    - `vibe/roadmap.md`의 실행 가이드를 실제 포트 정책과 일치시키고 충돌 시 대처 방법 명시
- **영향 범위**: `frontend/vite.config.ts`, `package.json`, `vibe/roadmap.md`

### 기술적 세부사항

- **Fail-fast 전략**: 포트 충돌 시 자동으로 다음 포트를 찾는 대신 에러를 발생시켜, 개발자가 명시적으로 대역 내 포트를 선택하도록 유도
- **스크립트 강화**: 프론트(8001-8010)와 백엔드(8011-8020)의 모든 가능 포트를 단일 커맨드로 정리 가능하게 함

### 검증

- **수동 검증**: `strictPort` 동작 확인 및 `kill:port` 범위 확장 확인 완료 (commit: a5b484f)

---

## [2026-01-04 17:00] RU-001-Q1: 실행 방법/문서/설정의 중복과 불일치 제거 (SSOT 통일)

### 작업 내용

- **제안서**: [RU-001-Q1] 실행 방법/문서/설정의 중복과 불일치 제거 (roadmap vs 코드 주석 vs 루트 스크립트 vs Pyright 설정)
- **개선 사항**:
    - 실행 커맨드 SSOT를 루트 `package.json`으로 확정하고, `vibe/roadmap.md` 및 `main.py` docstring을 이에 맞춰 통일
    - 포트 정책(RULE-011: 프론트 8001, 백엔드 8011)을 모든 문서와 실행 스크립트에 강제 적용
    - `pnpm -C` 옵션을 사용하여 경로 의존성 및 쉘 환경 차이에 따른 실행 오류 방지
    - Pyright 설정을 `backend/pyproject.toml`로 단일화하여 도구 설정 중복 제거 (Option B 적용)
- **영향 범위**: `vibe/roadmap.md`, `backend/src/unknown_world/main.py`, `package.json`, `backend/pyproject.toml`

### 기술적 세부사항

- **실행 표준화**: `uv run` 및 포트 명시적 지정을 통해 환경별 실행 결과 차이 제거
- **설정 단일화**: Pyright 검사 범위를 `src`로 고정하여 진단 일관성 확보

### 검증

- **수동 검증**: `pnpm dev:front` / `pnpm dev:back` 실행 시 각각 8001, 8011 포트에서 정상 동작 확인 완료

---

## [2026-01-04 16:30] RU-001-Q4: shared/ 기반 JSON Schema SSOT 도입 및 소비 경로 확정

### 작업 내용

- **제안서**: [RU-001-Q4] `shared/` 기반 JSON Schema SSOT(Option B) 디렉토리 도입 및 소비 경로 고정
- **개선 사항**:
    - `shared/schemas/turn/` 디렉토리에 `turn_input.schema.json` 및 `turn_output.schema.json` 도입
    - 백엔드(Pydantic)와 프론트엔드(Zod)의 계약 불일치(drift)를 방지하기 위한 단일 진실 공급원(SSOT) 구축
    - `shared/README.md`를 통해 공유 스키마 운영 전략(Option B) 명시
- **영향 범위**: `shared/` (신규), `vibe/unit-plans/RU-001[Mvp].md` (결정 사항 실현)

### 기술적 세부사항

- **스키마 설계**: PRD의 Turn 계약 규약을 반영하여 `turn_input`, `turn_output` 스키마 초기 버전 작성
- **구조적 강제**: `.gitignore` 수정(RU-001-S1 연동)을 통해 `shared/` 내 JSON 스키마가 안정적으로 추적되도록 보장

### 검증

- **수동 검증**: `shared/` 경로의 스키마 파일 존재 및 Git 추적 여부 확인 완료 (commit: 1c93e5b)

---

## [2026-01-04 02:45] RU-001-S1: .gitignore JSON 정책 리팩토링 및 shared/ 구조 도입

### 작업 내용

- **제안서**: [RU-001-S1] .gitignore의 광범위 *.json 차단 문제 해결
- **개선 사항**: 
    - `*.json` 전역 차단을 제거하고, `shared/**/*.json` (스키마 SSOT) 명시적 허용
    - 보안 강화를 위해 서비스 계정 및 크리덴셜 패턴(`*service_account*.json` 등) 상세 차단
    - `shared/` 디렉토리 구조 도입 및 보안 주의사항을 담은 `shared/README.md` 작성
    - 프론트엔드 빌드 아티팩트(`*.d.ts.map`, `*.js.map` 등) ignore 규칙 보강
- **영향 범위**: `.gitignore`, `shared/` (신규), `frontend/` (ignore 규칙)

### 기술적 세부사항

- **스키마 SSOT 기반 마련**: `shared/schemas/` 경로를 확보하여 향후 유닛(U-005 등)에서 활용 가능하도록 함
- **보안 가드**: `secrets/` 디렉토리를 팀 표준 보안 저장소로 격상하고, 해당 경로 내 JSON 강제 차단 유지

### 검증

- **수동 검증**: `git status`를 통해 `shared/` 내부 파일 추적 확인 및 임시 보안 파일 차단 여부 검토 완료
- **런북 참조**: `vibe/refactors/RU-001-S1.md` 내 검증 시나리오 준수

---

## [2026-01-04 02:05] U-004[Mvp]: CRT 테마/고정 레이아웃 스켈레톤 완료

### 구현 완료 항목

- **핵심 기능**: CSS Grid 기반 고정 8개 패널 레이아웃 및 CRT 터미널 테마 구현
- **추가 컴포넌트**: `Panel`, `NarrativeFeed` (로그 형태), `ActionDeck`, `GameHeader`
- **달성 요구사항**: [RULE-002] 채팅 버블 UI 금지 및 게임 HUD 구조 확보, [Frontend Style] CRT 테마 토큰 적용

### 기술적 구현 세부사항

**사용 기술/라이브러리**:

- **CSS Grid**: 3열(Sidebar L/R, Center) 3행(Header, Main, Footer) 고정 레이아웃
- **CRT Effect**: Scanline overlay, Flicker animation, Glow text, Glitch effect
- **React 19**: 함수형 컴포넌트 기반 레이아웃 구성

**설계 패턴 및 아키텍처 선택**:

- **패널 슬롯 시스템**: 향후 각 기능 유닛이 독립적으로 채워질 수 있는 8개 고정 슬롯 구조
- **로그형 내러티브**: 타임라인 기반 피드로 구성하여 "채팅" 인상을 원천 차단

**코드 구조**:
frontend/
├── src/
│   ├── App.tsx (레이아웃 및 패널 구성)
│   └── style.css (CRT 테마 및 Grid 정의)

### 성능 및 품질 지표

- **반응형 최적화**: 1200px, 768px 브레이크포인트 기반 가변 레이아웃 검증 완료
- **상호작용**: CRT 오버레이가 클릭을 방해하지 않도록 `pointer-events: none` 처리

### 의존성 변경

- 추가된 외부 의존성 없음 (Native CSS/React 활용)

### 다음 단계

- [RU-001[Mvp]] 리팩토링: 디렉토리/설정 정리
- [U-005[Mvp]] TurnInput/TurnOutput 스키마(Pydantic) 설계

---

## [2026-01-04 01:25] U-003[Mvp]: 백엔드 FastAPI 초기화 완료

### 구현 완료 항목

- **핵심 기능**: FastAPI 0.128 + Python 3.14 기반 오케스트레이터 골격 구축
- **추가 컴포넌트**: `backend/src/unknown_world/main.py` (엔트리포인트), `backend/tests/integration/test_api.py` (API 테스트)
- **달성 요구사항**: [RULE-011] 백엔드 포트(8011) 및 CORS 정책 수립, [RULE-010] 기술 스택 버전 고정

### 기술적 구현 세부사항

**사용 기술/라이브러리**:

- **FastAPI 0.128.0**: 비동기 오케스트레이터 API 프레임워크
- **uv**: 고속 패키지 관리 및 의존성 고정 (`uv.lock`)
- **Pydantic 2.12.5**: 헬스체크 응답 스키마 정의

**설계 패턴 및 아키텍처 선택**:

- **스키마 기반 헬스체크**: Pydantic 모델을 사용하여 구조화된 시스템 상태 반환
- **포트 범위 CORS**: 프론트엔드 개발 서버(8001~8010)와의 연동을 위한 화이트리스트 기반 CORS 설정

**코드 구조**:
backend/
├── pyproject.toml
├── uv.lock
├── src/
│   └── unknown_world/
│       ├── __init__.py
│       └── main.py
└── tests/
    └── integration/
        └── test_api.py

### 성능 및 품질 지표

- **API 안정성**: 통합 테스트 3종(Health, Root, CORS) 100% 통과
- **문서화**: Swagger UI(`/docs`)를 통한 자동 API 명세서 생성 확인

### 의존성 변경

- `fastapi`, `uvicorn`, `pydantic` 고정 버전 추가
- `ruff`, `pyright`, `pytest` 개발 의존성 추가

### 다음 단계

- [U-005[Mvp]] TurnInput/TurnOutput(Pydantic) 모델 추가
- [U-007[Mvp]] `/api/turn` SSE 스트리밍 라우트 추가

---

## [2026-01-03 14:45] U-002[Mvp]: 프론트 Vite+React+TS 초기화 완료

### 구현 완료 항목

- **핵심 기능**: `vibe/tech-stack.md` 기반 Vite 7 + React 19 + TypeScript 5.9 환경 구축
- **추가 컴포넌트**: `frontend/src/App.tsx`, `frontend/src/style.css` (단일 CSS SSOT 구조)
- **달성 요구사항**: [RULE-002] 채팅 UI 배제 최소 구조 확보, [RULE-010] 기술 스택 버전 고정

### 기술적 구현 세부사항

**사용 기술/라이브러리**:

- **React 19.2.3 / Vite 7.3.0**: 프론트엔드 프레임워크 및 빌드 도구
- **TypeScript 5.9.3**: 엄격 모드 적용
- **pnpm 10.27.0**: 패키지 매니저 고정

**설계 패턴 및 아키텍처 선택**:

- **단일 CSS SSOT**: 모든 스타일을 `src/style.css`에서 CSS 변수 기반으로 관리
- **최소 컨테이너 아키텍처**: 채팅 UI 유도를 방지하기 위한 헤더-메인 분리 구조

**코드 구조**:
frontend/
├── package.json
├── vite.config.ts
├── tsconfig.json
├── src/
│   ├── main.tsx
│   ├── App.tsx
│   └── style.css

### 성능 및 품질 지표

- **빌드 성공**: `pnpm build` 시 에셋 최적화 및 sourcemap 생성 확인
- **타입 안정성**: `pnpm run typecheck` 통과 (엄격 모드)

### 의존성 변경

- `react`, `react-dom` (v19.2.3) 추가
- `vite`, `typescript`, `eslint`, `prettier` 등 개발 의존성 추가

### 다음 단계

- [U-003[Mvp]] 백엔드 FastAPI 초기화
- [U-004[Mvp]] CRT 테마 및 고정 게임 UI 레이아웃 구현

---

## [2026-01-03 14:35] U-001[Mvp]: 프로젝트 스캐폴딩 생성 완료

### 구현 완료 항목

- **핵심 기능**: 프로젝트의 기본 디렉토리 구조(`frontend/`, `backend/`) 및 Git 설정(`.gitignore`, `.gitattributes`) 구축
- **추가 컴포넌트**: `backend/src/unknown_world/__init__.py` 패키지 초기화 파일
- **달성 요구사항**: [RULE-007] 비밀정보 보호 설정 완료

### 기술적 구현 세부사항

**사용 기술/라이브러리**:

- **Git**: 버전 관리 및 줄 끝 처리 설정
- **Python 3.14**: 백엔드 패키지 구조 초기화

**설계 패턴 및 아키텍처 선택**:

- **모노레포 구조**: `frontend/`와 `backend/`를 분리하여 독립적인 개발 환경 제공
- **보안 중심 설정**: 비밀정보 유출 방지를 위한 선제적 `.gitignore` 패턴 적용

**코드 구조**:
repo-root/
├── frontend/
│   ├── .gitkeep
│   └── src/
│       └── .gitkeep
├── backend/
│   ├── .gitkeep
│   ├── prompts/
│   │   └── .gitkeep
│   └── src/
│       └── unknown_world/
│           └── __init__.py
├── .gitignore
└── .gitattributes

### 성능 및 품질 지표

- **코드 품질**: Python 패키지 임포트 테스트 통과
- **보안**: 비밀정보 파일(service-account.json, .env) Git 추적 제외 검증 완료

### 의존성 변경

- 추가된 외부 의존성 없음 (기본 구조 작업)

### 다음 단계

- [U-002[Mvp]] 프론트엔드 환경 초기화 (Vite + React)
- [U-003[Mvp]] 백엔드 환경 초기화 (FastAPI)

---
</file>

<file path="vibe/architecture.md">
# Unknown World 아키텍처 가이드

## 1. 시스템 개요

Unknown World는 **Gemini 기반의 에이전트형 세계 엔진**과 멀티모달 파이프라인을 결합한 무한 생성 로그라이크 내러티브 웹게임입니다. 시스템은 상태 기반 오케스트레이터와 고수준 게임 UI로 구성됩니다.

## 2. 프로젝트 구조

### 디렉토리 구조 (Tree)

```text
D:\Dev\unknown-world\
├── .gitattributes         # Git 줄 끝 처리 및 속성 설정
├── .gitignore             # 비밀정보 및 빌드 결과물 제외
├── package.json           # 루트 개발 스크립트 및 프로세스 제어
├── code-base.xml          # 프로젝트 스냅샷 (Repomix)
├── frontend/              # 프론트엔드 (React 19 + Vite 7 + TS 5.9)
│   ├── index.html
│   ├── package.json
│   ├── tsconfig.json
│   ├── tsconfig.node.json
│   ├── vite.config.ts
│   ├── public/             # 정적 에셋
│   │   └── ui/             # UI 이미지 에셋 SSOT (U-030)
│   │       ├── README.md   # 제작/관리 규칙
│   │       ├── manifest.json # 에셋 목록 (U-029, U-032)
│   │       ├── manifest.schema.json # 매니페스트 스키마
│   │       ├── chrome/     # UI 장식/프레임 에셋 (U-032)
│   │       │   ├── card-frame.png
│   │       │   ├── panel-corner-br.png
│   │       │   └── scanner-frame.png
│   │       ├── icons/      # UI 아이콘 세트 (24px/16px) (U-029)
│   │       │   ├── badge-fail-24.png
│   │       │   ├── badge-ok-24.png
│   │       │   ├── risk-high-24.png
│   │       │   ├── shard-24.png
│   │       │   └── signal-24.png
│       └── placeholders/ # Scene 플레이스홀더 (U-029, U-031)
│           ├── scene-placeholder-default.png
│           ├── scene-loading.webp
│           ├── scene-offline.webp
│           ├── scene-blocked.webp
│           └── scene-low-signal.webp
    ├── src/
│       ├── main.tsx
│       ├── App.tsx
│       ├── style.css
│       ├── i18n.ts         # 다국어 설정 SSOT (U-031)
│       ├── vite-env.d.ts
│       ├── api/            # HTTP Streaming 클라이언트 (U-008)
│       │   └── turnStream.ts
│       ├── components/     # 게임 UI 컴포넌트 (U-008)
│       │   ├── AgentConsole.tsx
│       │   ├── SceneCanvas.tsx # 씬 캔버스 및 상태별 렌더링 (U-031)
│       │   └── SceneCanvas.test.tsx
│       ├── schemas/        # 클라이언트 측 스키마 및 검증 (U-006)
│       │   └── turn.ts
│       ├── stores/         # 상태 관리 (Zustand) (U-008, U-028)
│       │   ├── agentStore.ts
│       │   └── uiPrefsStore.ts # UI 가독성 설정 (스케일/Readable)
│       └── types/          # 스트림 이벤트 계약 타입 (RU-002-Q4)
│           ├── turn_stream.ts
│           └── scene.ts    # Scene Canvas 상태 타입 SSOT (U-031)
├── backend/               # 백엔드 (FastAPI + Pydantic)
│   ├── pyproject.toml
│   ├── uv.lock
│   ├── src/
│   │   └── unknown_world/
│   │       ├── __init__.py
│   │       ├── main.py
│   │       ├── api/        # API 엔드포인트 및 라우팅 (U-007)
│   │       │   ├── __init__.py
│   │       │   ├── turn.py
│   │       │   └── turn_stream_events.py # 스트림 이벤트 계약 모델 (RU-002-Q4)
│   │       ├── models/     # 데이터 모델 및 스키마 (U-005)
│   │       │   ├── __init__.py
│   │       │   └── turn.py
│   │       └── orchestrator/ # 오케스트레이션 엔진
│   │           └── mock.py  # 모의 Orchestrator (U-007)
│   └── tests/
│       ├── integration/
│       │   └── test_api.py
│       └── unit/           # 단위 테스트
│           └── models/
│               └── test_turn.py
├── shared/                # 공유 리소스 (SSOT)
│   ├── README.md
│   └── schemas/
│       └── turn/
│           ├── turn_input.schema.json
│           └── turn_output.schema.json
├── vibe/                  # SSOT 문서 저장소
│   ├── architecture.md
│   ├── progress.md
│   ├── roadmap.md
│   ├── tech-stack.md
│   ├── ref/                # 가이드 및 참조 문서 (SSOT)
│   │   ├── frontend-style-guide.md
│   │   ├── standard-guide.md
│   │   ├── rembg-guide.md
│   │   ├── nanobanana-mcp.md # 에셋 제작 가이드 및 템플릿 (U-034)
│   │   └── nanobanana-asset-request.schema.json # 에셋 요청 스키마 (U-034)
│   ├── unit-plans/
│   ├── unit-results/       # 유닛 개발 보고서 (U-034[Mvp] 포함)
│   └── unit-runbooks/      # 유닛 실행 가이드 (U-032-chrome-pack-runbook.md 포함)
└── code-base.xml          # 프로젝트 스냅샷 (Repomix)
```

### 주요 디렉토리 책임

- **`frontend/`**: 게임 HUD, 액션 덱, 인벤토리, 씬 캔버스 등 사용자 인터페이스 담당. Zustand로 월드 상태 관리.
    - `public/ui/`: `nanobanana mcp`로 제작된 정적 이미지 에셋(아이콘, 프레임, Placeholder) 저장소. 매니페스트를 통한 에셋 추적 및 폴백 관리.
    - `api/`: fetch 기반 HTTP Streaming 응답(NDJSON)을 소비하는 클라이언트 로직 관리.
    - `stores/`: Agent Console 상태(단계/배지) 및 월드 상태, **UI 가독성 설정**을 관리하는 Zustand 스토어.
    - `components/`: Agent Console, Narrative Feed, **Scene Canvas** 등 게임 전용 UI 컴포넌트 모음.
    - `i18n.ts`: `react-i18next` 기반의 다국어 번역 리소스 및 설정 SSOT.
    - `schemas/`: Zod를 활용한 턴 계약(Turn Contract) 검증 및 폴백 로직 정의.
    - `types/`: 서버-클라이언트 간 스트림 이벤트(NDJSON) 계약 타입 및 **Scene 상태 타입** 정의 (SSOT).
- **`backend/`**: FastAPI 기반의 오케스트레이터 서버. 비즈니스 룰 및 Gemini 연동 담당.
    - `api/`: `/api/turn` 등 클라이언트 통신을 위한 엔드포인트 관리 및 스트림 이벤트 모델(`turn_stream_events.py`) 정의.
    - `orchestrator/`: 실모델(Gemini) 또는 모의(Mock)를 통한 게임 엔진 오케스트레이션 핵심 로직 담당.
    - `models/`: Pydantic을 활용한 시스템 내부 데이터 구조 및 유효성 검증 정의.
- **`shared/`**: 백엔드와 프론트엔드 간의 **데이터 계약(Data Contract)**을 정의하는 SSOT 디렉토리.
    - `schemas/`: 언어 중립적인 JSON Schema 포맷으로 TurnInput/TurnOutput 규약 관리.
- **`vibe/`**: 프로젝트의 모든 명세와 진행 상황을 기록하는 단일 진실 공급원(SSOT).
    - `ref/`: `nanobanana mcp` 에셋 제작 스키마 및 프롬프트 템플릿, `rembg` 배경 제거 가이드 등 개발 프로세스 가이드 모음.

---

## 3. 실행 및 도구 설정 (SSOT)

Unknown World는 환경에 따른 동작 차이를 최소화하기 위해 다음 SSOT 정책을 따릅니다.

1. **실행 커맨드 SSOT**: 루트 `package.json`의 `scripts`. 모든 실행 안내(로드맵, 코드 주석 등)는 이를 기준으로 합니다.
2. **도구 및 의존성 고정 (Pinning)**:
    - **도구 버전**: 루트 `package.json`에 `packageManager`와 `engines`를 명시하여 pnpm 및 Node.js 버전을 고정합니다.
    - **의존성 버전**: `vibe/tech-stack.md`를 기준으로 모든 런타임 및 개발 의존성을 특정 버전으로 고정(pin)하여 버전 드리프트를 방지합니다.
3. **포트 정책 (RULE-011)**:
    - **Frontend**: `8001 ~ 8010` (기본: `8001`). `strictPort: true`를 강제하여 대역 외 자동 이동을 방지합니다.
    - **Backend**: `8011 ~ 8020` (기본: `8011`).
    - **정리**: `pnpm kill`은 RULE-011 포트 대역(8001~8020)만을 대상으로 하는 **안전한 포트 기반 종료**를 수행합니다. 이를 통해 `node.exe` 전체를 종료하는 광역 종료 위험을 방지하고 다른 프로젝트에 영향을 주지 않도록 설계되었습니다. (`kill:port`는 이의 별칭입니다.)
4. **도구 설정 SSOT**:
    - **Python (Backend)**: `backend/pyproject.toml` (Ruff, Pyright, uv 의존성)
    - **TypeScript (Frontend)**: `frontend/package.json` (pnpm), `frontend/tsconfig.json` (TS)

---

## 4. 핵심 아키텍처 원칙

1. **Stateful Orchestrator**: 단순 챗봇이 아닌 월드 상태(WorldState)를 유지하고 갱신하는 시스템.
2. **Structured Turn Contract**: 서버와 클라이언트는 엄격한 JSON Schema(`TurnOutput`)를 통해서만 통신.
3. **Decoupled UI**: 게임의 시각적 요소는 월드 상태로부터 독립적으로 렌더링(Data-driven UI).
4. **Resilient Pipeline**: LLM의 불안정한 출력을 Pydantic/Zod 이중 검증과 Repair loop로 방어.

## 5. 스트리밍 및 에러 핸들링 정책 (RU-002[Mvp] / CP-MVP-01)

1. **프로토콜 버전 및 하위 호환성 (Protocol Versioning)**:
    - **Version 1 (현행)**: MVP 안정화 계약. `final.data`, `stage.status: "complete"`, `badges: string[]` 형식을 사용한다.
    - **Version 2 (목표)**: 향후 개선 계약. `final.turn_output`, `stage.status: "ok"|"fail"`, `badges: Map` 형식을 지향한다.
    - **별칭(Alias) 정책**: 클라이언트는 서버가 v1 또는 v2 형식을 보내더라도 정상 동작하도록 `final.data ?? final.turn_output` 식의 별칭 지원 로직을 유지한다.
2. **스트림 이벤트 검증 (Event Validation)**: 모든 스트림 이벤트(`stage`, `badges`, `error` 등)는 소비되기 전 Zod 스키마를 통해 경량 검증을 거친다.
    - 검증 실패 시 해당 이벤트만 무시(drop)하거나 기본 폴백을 적용하며, 전체 스트림 파이프라인이나 UI가 중단되지 않도록 한다.
    - **Unknown Event**: 정의되지 않은 타입의 이벤트가 수신되면 콘솔 경고를 남기되 UI 상태에는 영향을 주지 않고 안전하게 폐기한다. 이는 향후 프로토콜 확장(telemetry, repair 등)에 대한 전방 호환성을 제공한다.
3. **종료 인바리언트 (Terminal Invariant)**: 모든 `/api/turn` 스트림은 성공, 내부 실패, 네트워크 장애 여부와 상관없이 **정확히 1개의 `final` 이벤트**로 종료되어야 한다. (CP-MVP-01에서 검증 완료)
    - 서버는 예외 발생 시 `error` 이벤트를 송출한 뒤 반드시 폴백 `TurnOutput`을 포함한 `final` 이벤트를 송출한다.
    - 클라이언트는 서버 연결 실패 시 직접 폴백 `TurnOutput`을 생성하여 스트림 종료 상태를 UI에 전달한다.
4. **상태 보존형 폴백 (State-preserving Fallback)**: 폴백 시 발생하는 `TurnOutput`은 입력 시점의 재화 스냅샷(`economy_snapshot`)을 그대로 유지하며, 비용(`cost`)은 0으로 설정하여 재화 HUD의 일관성을 보장한다. (RULE-005 준수)
5. **가시성 보장 (Observability)**: 에러 발생 시 `error` 이벤트를 통해 사용자에게 상황을 알리되, 시스템의 최종 상태는 항상 구조화된 `final` 데이터를 통해 확정한다.
6. **복구 루프 (Repair Loop)**: 스키마 검증 실패 시 최대 N회(기본 3회) 자동 복구를 시도하며, UI에는 `repair` 이벤트를 통해 상태를 알린다. (CP-MVP-01에서 검증 완료)


6. UI 가독성 및 설정 정책 (U-028[Mvp])

1. **전역 UI 스케일 (Global UI Scale)**: 사용자는 UI 전체 크기를 0.9x에서 1.2x까지 조절할 수 있다.
    - 이는 CSS 변수 `--ui-scale-factor`를 통해 제어되며, `rem` 단위 기반의 모든 타이포그래피와 간격에 영향을 미친다.
2. **Readable 모드 (Readable Mode)**: 텍스트 시인성을 저해할 수 있는 CRT 효과(스캔라인, 플리커, 글로우)를 선택적으로 완화하거나 제거할 수 있다.
    - `html[data-readable="true"]` 속성을 통해 CSS 레벨에서 선언적으로 처리한다.
    - Readable 모드 활성화 시 보조 텍스트의 대비를 상향 조정하고 마이크로 텍스트 크기를 추가로 상향한다.
3. **설정 영속성 (Persistence)**: 사용자의 UI 설정은 `localStorage`에 저장되어 페이지 새로고침 후에도 유지된다. 향후 SaveGame 시스템과 통합되어 계정/세션별로 관리될 수 있다.
4. **마이크로 텍스트 하한선 (Micro-text Baseline)**: Agent Console 등 정보 밀도가 높은 영역에서도 텍스트가 읽힐 수 있도록 최소 폰트 크기 기준(`--font-size-xs`, `--font-size-sm`)을 준수한다.


7. UI 이미지 에셋 SSOT 정책 (U-030[Mvp])

1. **Dev-only 제작 원칙**: `nanobanana mcp`는 개발 과정에서 정적 에셋을 제작하는 도구로만 사용하며, 런타임에는 생성된 `frontend/public/ui/` 내 파일에만 의존한다. (RULE-007 준수)
2. **네이밍 및 포맷**: 모든 에셋은 `kebab-case`를 사용하며, 아이콘/프레임은 PNG(투명), Placeholder는 WebP(용량 최적화) 포맷을 우선한다.
3. **성능 예산(Performance Budget)**:
    - 개별 아이콘 상한: 30KB (권장 20KB 이하)
    - 개별 Placeholder 상한: 300KB (권장 200KB 이하)
    - `ui/` 폴더 총합 상한: 1.5MB (권장 1MB 이하)
4. **폴백 강제 (Fallback-first)**: 에셋 로딩 실패 시에도 UI가 깨지지 않도록 이모지나 텍스트 라벨을 `manifest.json`에 정의하고 클라이언트에서 이를 활용한다.
5. **테마 정합성**: 에셋 제작 시 `style.css`에 정의된 CRT 테마 색상(인광 녹색 `#33ff00` 등)과 조화를 이루도록 프롬프트를 제어한다.
6. **배경 제거 파이프라인 (rembg)**: 아이콘/프레임 등 투명 배경이 필요한 에셋은 `rembg` (isnet-anime 또는 birefnet-general 모델)를 사용하여 배경을 제거한다.
    - 재현성 및 품질을 위해 원본 생성 시 **순백(#FFFFFF) 단색 배경**을 강제한다. (참조: `vibe/ref/rembg-guide.md`)


---
_본 문서는 프로젝트의 진화에 따라 수시로 업데이트됩니다._
</file>

<file path="vibe/roadmap.md">
# 📊 Unknown World 로드맵

**핵심 가치**: 구조화 출력(JSON Schema) 기반의 에이전트형 Game Master가 **상태(WorldState)·규칙(Rule Board)·경제(Economy)** 를 갱신하며, 플레이어가 **클릭·드래그·업로드(Scanner)** 로 조작 가능한 “채팅이 아닌 게임 UI”를 웹에서 즉시 플레이하게 한다.

## 진행 현황

**전체**: 18/61 (29%) | **MVP**: 18/48 (37%) | **MMP**: 0/13 (0%)

**예상 완료(가정)**: MVP D-8 | MMP D-12  
_가정: 1인 기준 / 1일 순개발 4h / 유닛 평균 45분 / 버퍼 30% 포함_

_진행률 산정: `vibe/unit-results/`에 존재하는 완료 유닛(U/RU/CP) 기준. `vibe/refactors/*`는 하위 리팩토링 기록으로 분모에서 제외._

**진행 중**: [U-033[Mvp]](unit-plans/U-033[Mvp].md) / **최근 완료**: [U-032[Mvp]](unit-results/U-032[Mvp].md) (2026-01-12)

**블로커**: 없음

## 맥락 요약 (SSOT 근거)

### 프로젝트 핵심 가치 (1문장)

- “프롬프트 래퍼가 아닌” **상태 기반 게임 시스템**을, **구조화 출력 + 검증/복구 + 게임형 UI**로 증명한다.  
  (근거: `vibe/prd.md`, `.cursor/rules/00-core-critical.mdc`)

### 반드시 지켜야 할 제약 (TOP 3)

1. **Prompt-only wrapper / Generic chatbot 금지**: TurnInput/TurnOutput 계약 + State/Orchestrator/Artifacts 필수 (RULE-001/002)
2. **구조화 출력 + 이중 검증 + Repair loop 필수**: Pydantic+Zod, 실패 시 안전 폴백, Hard Gate 준수 (RULE-003/004)
3. **경제/보안/언어/좌표/버전 고정**: 잔액 음수 금지(ledger), Vertex 서비스계정(BYOK 금지), ko/en 혼합 금지, bbox 0~1000 규약, tech-stack 버전 고정 (RULE-005/006/007/009/010)

### 기술적 리스크 (TOP 3)

| ID    | 내용                                                                   | 영향 | 확률 | 대응(요약)                                                                            |
| ----- | ---------------------------------------------------------------------- | ---- | ---- | ------------------------------------------------------------------------------------- |
| R-001 | LLM 출력 불안정(스키마/의미 불일치)로 UI/상태/경제 인바리언트 붕괴     | High | 35%  | Structured Outputs + 서버/클라 검증 + Repair loop + Safe fallback + Mock 모드         |
| R-002 | 지연/비용(특히 이미지/Thinking)으로 데모 체감 저하(TTFB>2s, 비용 폭증) | High | 30%  | HTTP Streaming 단계/배지 우선 스트리밍 + 경제(예상비용/대안) + Lazy 이미지 + 정책 프리셋 |
| R-003 | “채팅 앱처럼 보임”으로 심사/사용자 오해                                | High | 25%  | 고정 HUD(액션덱/인벤토리DnD/씬캔버스/에이전트콘솔) + 데모프로필/리셋 + 10분 데모 루프 |

### MVP 완료 기준 (Definition of Done)

- **Schema OK**: TurnOutput JSON이 스키마를 통과(서버 Pydantic + 클라 Zod)
- **Economy OK**: 예상 비용 노출, ledger 일관성, 잔액 음수 불가
- **Safety OK**: 차단/실패 시 명시 + 안전한 대체 결과(텍스트-only 등) 제공
- **Consistency OK**: 언어 정책(ko/en 혼합 금지), bbox 규약(0~1000, [ymin,xmin,ymax,xmax]) 준수
- **Demo OK(10분 루프)**: 드래그→클릭→(스캐너)업로드→룰 변형/퀘스트→오토파일럿→엔딩 리포트까지 반복 가능(데모프로필+리셋 포함)

---

## 마일스톤

| 단계 | ID        | 이름                                   | 목표일     | 진행률 | 상태 |
| ---- | --------- | -------------------------------------- | ---------- | ------ | ---- |
| MVP  | M1        | 스캐폴딩 + Turn 계약 + HTTP Streaming  | 2026-01-05 | 11/11  | ✅   |
| MVP  | CP-MVP-01 | **✓ 체크포인트: 스트리밍/스키마/폴백** | 2026-01-10 | -      | ✅   |
| MVP  | M2        | 핵심 UI(액션덱/핫스팟/DnD) + 가독성/에셋 | 2026-01-15 | 4/21   | 🚧   |
| MVP  | CP-MVP-02 | **✓ 체크포인트: 클릭+드래그 데모**     | 2026-01-15 | -      | ⏸️   |
| MVP  | M3        | 세션/데모프로필 + 실모델 + 복구        | 2026-01-18 | 0/10   | ⏸️   |
| MVP  | CP-MVP-03 | **✓ 체크포인트: 10분 데모 루프**       | 2026-01-20 | -      | ⏸️   |
| MMP  | M5        | 배포/스토리지/관측 강화                | 2026-02-01 | 0/7    | ⏸️   |
| MMP  | CP-MMP-01 | **✓ 체크포인트: 배포/관측 게이트**     | 2026-02-01 | -      | ⏸️   |
| MMP  | M6        | 장기 세션/회귀 자동화/보안 하드닝      | 2026-02-12 | 0/6    | ⏸️   |
| MMP  | CP-MMP-02 | **✓ 체크포인트: 시나리오 회귀 100%**   | 2026-02-12 | -      | ⏸️   |

## 핵심 기능 (MVP)

### Turn 계약 + 오케스트레이터 스트리밍

- **완료 기준**: HTTP Streaming(POST)로 Queue/Badges/Auto-repair를 스트리밍하고, 최종 TurnOutput이 스키마/비즈니스 룰을 통과
- **책임 Unit**: U-005 ~ CP-MVP-01, U-016 ~ U-018
- **상태**: 🚧

### “채팅이 아닌” 고정 게임 UI + 핵심 인터랙션

- **완료 기준**: Action Deck / Inventory(DnD) / Scene Canvas(Hotspots) / Economy HUD / Agent Console이 상시 노출되고, 클릭+드래그가 동작하며, 기본 폰트/대비가 “읽을 수 있는” 수준으로 유지된다
- **책임 Unit**: U-004, U-009 ~ CP-MVP-02, U-014, U-028, U-029, U-030 ~ U-034, U-037, U-038
- **상태**: 🚧

### 데모 반복 가능(데모프로필/리셋/세이브) + 엔딩 아티팩트

- **완료 기준**: 데모프로필 3종 + 즉시 시작/리셋 + SaveGame + 엔딩 리포트 아티팩트 생성
- **책임 Unit**: U-015, U-025
- **상태**: ⏸️

### 멀티모달(선택적 이미지 + Scanner 업로드)

- **완료 기준**: 텍스트 우선 + (조건부) 이미지 생성/표시, Scanner 업로드가 "아이템/단서"로 변환되어 인벤토리에 반영, 오브젝트 이미지 배경 제거(rembg) 지원
- **책임 Unit**: U-019 ~ U-022, U-035, U-036
- **상태**: ⏸️

### Autopilot + 리플레이/시나리오 하네스(데모 회귀)

- **완료 기준**: Manual/Assist/Autopilot 모드가 보이며, seed+actions 기반 리플레이로 Hard Gate 인바리언트를 점검 가능
- **책임 Unit**: U-023 ~ U-026
- **상태**: ⏸️

## 리스크

| ID    | 내용                                | 영향 | 확률 | 대응                                   |
| ----- | ----------------------------------- | ---- | ---- | -------------------------------------- |
| R-001 | 스키마/의미 불일치로 Hard Gate 실패 | High | 35%  | Repair loop + Safe fallback + Mock     |
| R-002 | 이미지/Thinking로 지연/비용 폭발    | High | 30%  | Economy 정책 + Lazy 이미지 + 티어링    |
| R-003 | UI가 채팅처럼 보여 제출/데모 실패   | High | 25%  | 고정 HUD + DnD/핫스팟/스캐너/콘솔 강조 |
| R-004 | 작은 글씨/CRT 튜닝으로 가독성·정체성 균형 붕괴 | Medium | 25% | UI 스케일 + CRT 강도 프로파일(Readable=완화) + 대비/라인하이트 가이드 |
| R-005 | 에셋 난립/용량 비대화/스타일 불일치  | Medium | 25% | nanobanana mcp 에셋 SSOT + 매니페스트/QA + 예산 상한 + (필요 시) rembg 배경 제거 |

## 메트릭

| 지표                       | 현재 | 목표        |
| -------------------------- | ---- | ----------- |
| Streaming TTFB             | -    | < 2s        |
| API 응답(p95, 텍스트)      | -    | < 200ms     |
| 이미지 생성 시간(p95)      | -    | < 12s(선택) |
| Hard Gate 통과율(리플레이) | -    | 100%        |

**기술 부채**: 0h / 한도 8h

---

### 작업 백로그

**범례**: ⏸️ 대기 | 🚧 진행중 | ✅ 완료 | ❌ 차단 | ⚡ Critical Path

### MVP
ID=[U-033[Mvp]](unit-plans/U-033[Mvp].md) | nanobanana mcp 에셋 매니페스트 + QA(크기/대비/폴백) | Depends=U-030 | 🚧
ID=[U-037[Mvp]](unit-plans/U-037[Mvp].md) | CRT 지글거림 보강(Readable 완화 프로파일) | Depends=U-004,U-028 | ⏸️
ID=[U-038[Mvp]](unit-plans/U-038[Mvp].md) | 핵심 UI 아이콘 12종 재생성(v2, 퀄리티/용량/사이즈/식별성) | Depends=U-033,U-034,U-030,U-028 | ⏸️
ID=[U-009[Mvp]](unit-plans/U-009[Mvp].md) | ⚡Action Deck(카드+비용/대안) | Depends=U-004,U-008 | ⏸️
ID=[U-010[Mvp]](unit-plans/U-010[Mvp].md) | ⚡Scene Canvas + Hotspot Overlay(0~1000 bbox) | Depends=U-004,U-008 | ⏸️
ID=[U-011[Mvp]](unit-plans/U-011[Mvp].md) | ⚡Inventory 패널(DnD) 기본 | Depends=U-004 | ⏸️
ID=[U-012[Mvp]](unit-plans/U-012[Mvp].md) | ⚡DnD 드롭(아이템→핫스팟) TurnInput 이벤트 | Depends=U-010,U-011,U-008 | ⏸️
ID=[RU-003[Mvp]](unit-plans/RU-003[Mvp].md) | 리팩토링: UI 상태 슬라이스/경계 정리 | Depends=U-012 | ⏸️
ID=[CP-MVP-02](unit-plans/CP-MVP-02.md) | **체크포인트: 클릭+드래그 데모** | Depends=RU-003 | ⏸️

ID=[U-013[Mvp]](unit-plans/U-013[Mvp].md) | Quest + Rule Board/Timeline 패널 | Depends=U-004,U-008 | ⏸️
ID=[U-014[Mvp]](unit-plans/U-014[Mvp].md) | ⚡Economy HUD + Ledger(프론트) | Depends=U-009,U-008 | ⏸️
ID=[U-015[Mvp]](unit-plans/U-015[Mvp].md) | ⚡SaveGame(local) + Reset + Demo Profiles(3종) | Depends=U-014,U-013 | ⏸️
ID=[RU-004[Mvp]](unit-plans/RU-004[Mvp].md) | 리팩토링: SaveGame/초기상태/데모 프로필 정리 | Depends=U-015 | ⏸️

ID=[U-016[Mvp]](unit-plans/U-016[Mvp].md) | ⚡Vertex 인증 + google-genai 클라이언트 + 모델 라벨 고정 | Depends=U-003 | ⏸️
ID=[U-017[Mvp]](unit-plans/U-017[Mvp].md) | ⚡Structured Output TurnOutput 생성 + Pydantic 검증 | Depends=U-016,U-005 | ⏸️
ID=[U-018[Mvp]](unit-plans/U-018[Mvp].md) | ⚡비즈니스 룰 검증 + Repair loop + 안전 폴백 | Depends=U-017 | ⏸️
ID=[RU-005[Mvp]](unit-plans/RU-005[Mvp].md) | 리팩토링: orchestrator pipeline stages 정리 | Depends=U-018 | ⏸️

ID=[U-019[Mvp]](unit-plans/U-019[Mvp].md) | ⚡이미지 생성 엔드포인트/잡(조건부) | Depends=U-016,U-017 | ⏸️
ID=[U-020[Mvp]](unit-plans/U-020[Mvp].md) | ⚡프론트 이미지 Lazy Render(placeholder/폴백) | Depends=U-010,U-019 | ⏸️
ID=[U-035[Mvp]](unit-plans/U-035[Mvp].md) | 실시간 이미지 생성 시 rembg 배경 제거 통합 | Depends=U-019,U-020 | ⏸️
ID=[U-036[Mvp]](unit-plans/U-036[Mvp].md) | 스토리/이미지 프롬프트 파일 분리(ko/en) + 핫리로드 | Depends=U-017,U-019 | ⏸️
ID=[U-021[Mvp]](unit-plans/U-021[Mvp].md) | 이미지 이해(Scanner) 백엔드 엔드포인트 | Depends=U-016 | ⏸️
ID=[U-022[Mvp]](unit-plans/U-022[Mvp].md) | ⚡Scanner 슬롯 UI + 업로드→아이템화 반영 | Depends=U-011,U-021 | ⏸️
ID=[RU-006[Mvp]](unit-plans/RU-006[Mvp].md) | 리팩토링: media/artifacts 스토리지 추상화 | Depends=U-022 | ⏸️

ID=[U-023[Mvp]](unit-plans/U-023[Mvp].md) | ⚡Autopilot 모드 토글 + Goal 입력 + Plan/Queue UI | Depends=U-008,U-013 | ⏸️
ID=[U-024[Mvp]](unit-plans/U-024[Mvp].md) | ⚡Backend Autopilot(제한 스텝) + Action Queue Streaming | Depends=U-018,U-023 | ⏸️
ID=[U-025[Mvp]](unit-plans/U-025[Mvp].md) | 엔딩 리포트 아티팩트 생성(요약/타임라인/결산) | Depends=U-018,U-015 | ⏸️
ID=[U-026[Mvp]](unit-plans/U-026[Mvp].md) | 리플레이/시나리오 하네스(저장+수동 러너) | Depends=U-024,U-025 | ⏸️
ID=[RU-007[Mvp]](unit-plans/RU-007[Mvp].md) | 리팩토링: artifacts 버전/경로/링크 정리 | Depends=U-026 | ⏸️
ID=[CP-MVP-03](unit-plans/CP-MVP-03.md) | **체크포인트: 10분 데모 루프** | Depends=RU-007 | ⏸️

### MMP

ID=[U-100[Mmp]](unit-plans/U-100[Mmp].md) | ⚡Dockerfile/로컬 실행(프론트/백엔드) | Depends=CP-MVP-03 | ⏸️
ID=[U-101[Mmp]](unit-plans/U-101[Mmp].md) | ⚡Cloud Run 배포 구성 + env/secret 가이드 | Depends=U-100 | ⏸️
ID=[U-102[Mmp]](unit-plans/U-102[Mmp].md) | ⚡GCS 스토리지 어댑터(이미지/아티팩트) | Depends=U-100 | ⏸️
ID=[U-103[Mmp]](unit-plans/U-103[Mmp].md) | 이미지 편집(멀티턴, REF 유지) | Depends=U-019,U-102 | ⏸️
ID=[U-104[Mmp]](unit-plans/U-104[Mmp].md) | 장기 세션 메모리 요약/핀 추천 고도화 | Depends=U-025 | ⏸️
ID=[U-105[Mmp]](unit-plans/U-105[Mmp].md) | ⚡Scenario Library(5) + 자동 리플레이 확장 | Depends=U-026 | ⏸️
ID=[RU-010[Mmp]](unit-plans/RU-010[Mmp].md) | 리팩토링: 스키마/상수 SSOT 강화 + 파일 분리 | Depends=U-105 | ⏸️
ID=[CP-MMP-01](unit-plans/CP-MMP-01.md) | **체크포인트: 배포/관측 게이트** | Depends=U-101,RU-010 | ⏸️

ID=[U-106[Mmp]](unit-plans/U-106[Mmp].md) | 관측 지표/대시보드(Agent Console 메트릭) 고도화 | Depends=CP-MMP-01 | ⏸️
ID=[U-107[Mmp]](unit-plans/U-107[Mmp].md) | 접근성/단축키/모바일 UX 개선 | Depends=U-106 | ⏸️
ID=[U-108[Mmp]](unit-plans/U-108[Mmp].md) | ⚡보안 하드닝(인젝션 케이스/secret scan) | Depends=CP-MMP-01 | ⏸️
ID=[RU-011[Mmp]](unit-plans/RU-011[Mmp].md) | 리팩토링: Autopilot/Replay 모듈 정리 | Depends=U-108 | ⏸️
ID=[CP-MMP-02](unit-plans/CP-MMP-02.md) | **체크포인트: 시나리오 회귀 100%** | Depends=RU-011,U-107 | ⏸️

### 완료

- ✅ [U-032[Mvp]](unit-results/U-032[Mvp].md): nanobanana mcp UI Chrome Pack(패널/카드 프레임/코너) (2026-01-12)
- ✅ [U-031[Mvp]](unit-results/U-031[Mvp].md): nanobanana mcp 상태 Placeholder Pack(Scene/오프라인/에러/차단) (2026-01-11)
- ✅ [U-029[Mvp]](unit-results/U-029[Mvp].md): nanobanana mcp 에셋 패스(UI 아이콘/프레임/placeholder) (2026-01-11)
- ✅ [U-034[Mvp]](unit-results/U-034[Mvp].md): nanobanana mcp 에셋 요청 스키마 + 프롬프트 템플릿(재현성) (2026-01-11)
- ✅ [U-030[Mvp]](unit-results/U-030[Mvp].md): nanobanana mcp 에셋 SSOT(폴더/네이밍/사이즈/폴백/라이선스) (2026-01-10)
- ✅ [U-028[Mvp]](unit-results/U-028[Mvp].md): UI 가독성 패스(폰트 스케일/효과 토글/대비) (2026-01-10)
- ✅ [CP-MVP-01](unit-results/CP-MVP-01.md): 체크포인트 - 스트리밍/스키마/폴백 (2026-01-10)
- ✅ [RU-002[Mvp]](unit-results/RU-002[Mvp].md): 리팩토링: validation/폴백/이벤트 타입 통일 (2026-01-10)
- ✅ [RU-002-S2](refactors/RU-002-S2.md): 스트림 이벤트 검증 강화(Zod) 및 Unknown 이벤트 폴백 처리 (2026-01-10)
- ✅ [RU-002-S1](refactors/RU-002-S1.md): 스트리밍 안정화 및 종료 인바리언트(항상 final) 강제 (2026-01-08)
- ✅ [RU-002-Q2](refactors/RU-002-Q2.md): PRD Turn Stream Protocol(SSOT) 정합성 확보 및 버전/별칭 도입 (2026-01-08)
- ✅ [RU-002-Q4](refactors/RU-002-Q4.md): Turn Stream 이벤트 계약 모듈 분리 (2026-01-07)
- ✅ [U-027[Mvp]](unit-results/U-027[Mvp].md): 개발 스크립트: pnpm kill 포트 제한(8001~8020) (2026-01-05)
- ✅ [U-008[Mvp]](unit-results/U-008[Mvp].md): ⚡프론트 HTTP Streaming 클라이언트 + Agent Console/배지 (2026-01-05)
- ✅ [U-007[Mvp]](unit-results/U-007[Mvp].md): ⚡모의 Orchestrator + /api/turn HTTP Streaming(POST) (2026-01-04)
- ✅ [U-006[Mvp]](unit-results/U-006[Mvp].md): ⚡TurnInput/TurnOutput 스키마(Zod) (2026-01-04)
- ✅ [U-005[Mvp]](unit-results/U-005[Mvp].md): ⚡TurnInput/TurnOutput 스키마(Pydantic) (2026-01-04)
- ✅ [RU-001[Mvp]](unit-results/RU-001[Mvp].md): 리팩토링: 디렉토리/설정 정리 (2026-01-04)
- ✅ [U-001[Mvp]](unit-results/U-001[Mvp].md): 프로젝트 스캐폴딩 생성 (2026-01-03)
- ✅ [U-002[Mvp]](unit-results/U-002[Mvp].md): 프론트 Vite+React+TS 초기화 (2026-01-03)
- ✅ [U-003[Mvp]](unit-results/U-003[Mvp].md): 백엔드 FastAPI 초기화 (2026-01-04)
- ✅ [U-004[Mvp]](unit-results/U-004[Mvp].md): CRT 테마/고정 레이아웃 스켈레톤 (2026-01-04)

---

## 빠른 실행

**현재 작업**: [U-031[Mvp]](unit-plans/U-031[Mvp].md) - nanobanana mcp 상태 Placeholder Pack(Scene/오프라인/에러/차단)

```bash
# Frontend (RULE-011: 8001~8010)
pnpm -C frontend install
pnpm -C frontend dev
# → http://localhost:8001 에서 접근 가능
# ⚠️ 포트 충돌 시 (strictPort: true로 fail-fast):
#    pnpm -C frontend dev --port 8002  (8002~8010 중 선택)

# Backend (uv 기반, RULE-011: 8011~8020)
cd backend
uv sync
uv run uvicorn unknown_world.main:app --reload --port 8011
# → http://localhost:8011/health 로 확인
# ⚠️ 포트 충돌 시: --port 8012 (8012~8020 중 선택)

# 전체 포트 정리 (8001~8020)
pnpm kill
# → RULE-011에 정의된 포트 범위(8001~8020)의 프로세스만 안전하게 정리합니다.
```

**완료 확인**:

- [ ] 브라우저에서 고정 게임 UI 레이아웃이 렌더된다(채팅 버블 없음)
- [ ] HTTP Streaming 연결이 되고 Agent Console에 단계/배지가 보인다(프롬프트 원문 노출 없음)

---

## 일일 스탠드업 (YYYY-MM-DD)

**완료**: [{ID}](unit-plans/{ID}.md) - {설명}

**진행중**: [{ID}](unit-plans/{ID}.md) - {목표}

**블로커**: 없음 / ❌ [{ID}](unit-plans/{ID}.md): {사유} → {대응}

---
</file>

</files>
