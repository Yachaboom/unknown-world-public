This file is a merged representation of a subset of the codebase, containing specifically included files and files not matching ignore patterns, combined into a single document by Repomix.

<file_summary>
This section contains a summary of this file.

<purpose>
This file contains a packed representation of a subset of the repository's contents that is considered the most important context.
It is designed to be easily consumable by AI systems for analysis, code review,
or other automated processes.
</purpose>

<file_format>
The content is organized as follows:
1. This summary section
2. Repository information
3. Directory structure
4. Repository files (if enabled)
5. Multiple file entries, each consisting of:
  - File path as an attribute
  - Full contents of the file
</file_format>

<usage_guidelines>
- This file should be treated as read-only. Any changes should be made to the
  original repository files, not this packed version.
- When processing this file, use the file path to distinguish
  between different files in the repository.
- Be aware that this file may contain sensitive information. Handle it with
  the same level of security as you would the original repository.
</usage_guidelines>

<notes>
- Some files may have been excluded based on .gitignore rules and Repomix's configuration
- Binary files are not included in this packed representation. Please refer to the Repository Structure section for a complete list of file paths, including binary files
- Only files matching these patterns are included: **/*.{ts,tsx,py,toml,json}
- Files matching these patterns are excluded: .claude/**, .cursor/**, .gemini/**, .vscode/**, backend/.venv/**, frontend/node_modules/**, vibe/**
- Files matching patterns in .gitignore are excluded
- Files matching default ignore patterns are excluded
- Files are sorted by Git change count (files with more changes are at the bottom)
</notes>

</file_summary>

<directory_structure>
backend/pyproject.toml
backend/src/unknown_world/__init__.py
backend/src/unknown_world/api/__init__.py
backend/src/unknown_world/api/turn_stream_events.py
backend/src/unknown_world/api/turn.py
backend/src/unknown_world/main.py
backend/src/unknown_world/models/__init__.py
backend/src/unknown_world/models/turn.py
backend/src/unknown_world/orchestrator/__init__.py
backend/src/unknown_world/orchestrator/mock.py
backend/tests/integration/test_api.py
backend/tests/integration/test_turn_streaming.py
backend/tests/qa/test_asset_manifest.py
backend/tests/unit/models/test_turn.py
backend/tests/unit/test_u034_verification.py
frontend/coverage/coverage-final.json
frontend/package.json
frontend/public/ui/manifest.json
frontend/public/ui/manifest.schema.json
frontend/src/api/turnStream.test.ts
frontend/src/api/turnStream.ts
frontend/src/App.test.tsx
frontend/src/App.tsx
frontend/src/components/ActionDeck.test.tsx
frontend/src/components/ActionDeck.tsx
frontend/src/components/AgentConsole.test.tsx
frontend/src/components/AgentConsole.tsx
frontend/src/components/SceneCanvas.hotspot.test.tsx
frontend/src/components/SceneCanvas.test.tsx
frontend/src/components/SceneCanvas.tsx
frontend/src/i18n-scenario.test.ts
frontend/src/i18n.ts
frontend/src/locales/en-US/translation.json
frontend/src/locales/ko-KR/translation.json
frontend/src/main.tsx
frontend/src/schemas/index.ts
frontend/src/schemas/turn.test.ts
frontend/src/schemas/turn.ts
frontend/src/schemas/verify_runbook.ts
frontend/src/setupTests.ts
frontend/src/stores/actionDeckStore.test.ts
frontend/src/stores/actionDeckStore.ts
frontend/src/stores/agentStore.test.ts
frontend/src/stores/agentStore.ts
frontend/src/stores/uiPrefsStore.test.ts
frontend/src/stores/uiPrefsStore.ts
frontend/src/types/scene.ts
frontend/src/types/turn_stream.ts
frontend/src/utils/box2d.test.ts
frontend/src/utils/box2d.ts
frontend/src/vite-env.d.ts
frontend/tsconfig.json
frontend/tsconfig.node.json
frontend/vite.config.ts
package.json
shared/schemas/turn/turn_input.schema.json
shared/schemas/turn/turn_output.schema.json
</directory_structure>

<files>
This section contains the contents of the repository's files.

<file path="backend/src/unknown_world/api/__init__.py">
"""Unknown World - API íŒ¨í‚¤ì§€.

ì´ íŒ¨í‚¤ì§€ëŠ” FastAPI ë¼ìš°í„°ë“¤ì„ í¬í•¨í•©ë‹ˆë‹¤.
"""

from unknown_world.api.turn import router as turn_router

__all__ = ["turn_router"]
</file>

<file path="backend/src/unknown_world/models/__init__.py">
"""Unknown World - ëª¨ë¸ íŒ¨í‚¤ì§€.

ì´ íŒ¨í‚¤ì§€ëŠ” TurnInput/TurnOutput ìŠ¤í‚¤ë§ˆ ë° í•˜ìœ„ íƒ€ì…ì„ ì •ì˜í•©ë‹ˆë‹¤.
Gemini Structured Outputs(JSON Schema)ìš©ìœ¼ë¡œ ì„¤ê³„ë˜ì—ˆìŠµë‹ˆë‹¤.

ì‚¬ìš© ì˜ˆì‹œ:
    from unknown_world.models import TurnInput, TurnOutput

    # Pydantic â†’ JSON Schema ë³€í™˜ (Gemini response_json_schemaìš©)
    schema = TurnOutput.model_json_schema()

    # ì‘ë‹µ ê²€ì¦
    output = TurnOutput.model_validate_json(response_text)

ì°¸ì¡°:
    - vibe/prd.md 8.7 (ë°ì´í„° ëª¨ë¸ ì„¤ê³„)
    - vibe/ref/structured-outputs-guide.md
    - .cursor/rules/00-core-critical.mdc (RULE-003, RULE-005)
"""

from unknown_world.models.turn import (
    ActionCard,
    ActionDeck,
    AgentConsole,
    AgentPhase,
    Box2D,
    ClickInput,
    ClientInfo,
    Coordinate,
    CurrencyAmount,
    EconomyOutput,
    EconomySnapshot,
    ImageJob,
    Language,
    MemoryPin,
    ModelLabel,
    Quest,
    RenderOutput,
    RiskLevel,
    SafetyOutput,
    SceneObject,
    Theme,
    TurnInput,
    TurnOutput,
    UIOutput,
    ValidationBadge,
    WorldDelta,
    WorldRule,
)

__all__ = [
    # Enum íƒ€ì…
    "Language",
    "Theme",
    "AgentPhase",
    "ValidationBadge",
    "ModelLabel",
    "RiskLevel",
    # ê³µí†µ í•˜ìœ„ íƒ€ì…
    "Coordinate",
    "Box2D",
    "CurrencyAmount",
    # TurnInput ê´€ë ¨
    "TurnInput",
    "ClickInput",
    "ClientInfo",
    "EconomySnapshot",
    # TurnOutput ê´€ë ¨
    "TurnOutput",
    "UIOutput",
    "ActionDeck",
    "ActionCard",
    "SceneObject",
    "WorldDelta",
    "WorldRule",
    "Quest",
    "MemoryPin",
    "RenderOutput",
    "ImageJob",
    "EconomyOutput",
    "SafetyOutput",
    "AgentConsole",
]
</file>

<file path="backend/src/unknown_world/orchestrator/__init__.py">
"""Unknown World - Orchestrator íŒ¨í‚¤ì§€.

ì´ íŒ¨í‚¤ì§€ëŠ” í„´ ì²˜ë¦¬ ì˜¤ì¼€ìŠ¤íŠ¸ë ˆì´í„°ë¥¼ í¬í•¨í•©ë‹ˆë‹¤.
"""

from unknown_world.orchestrator.mock import MockOrchestrator

__all__ = ["MockOrchestrator"]
</file>

<file path="backend/tests/integration/test_api.py">
from fastapi.testclient import TestClient

from unknown_world.main import app

client = TestClient(app)


def test_health_check():
    """/health ì—”ë“œí¬ì¸íŠ¸ê°€ ì˜¬ë°”ë¥¸ ìŠ¤í‚¤ë§ˆì™€ ìƒíƒœë¥¼ ë°˜í™˜í•˜ëŠ”ì§€ í…ŒìŠ¤íŠ¸í•©ë‹ˆë‹¤."""
    response = client.get("/health")
    assert response.status_code == 200
    data = response.json()
    assert data["status"] == "ok"
    assert "version" in data
    assert data["service"] == "unknown-world-backend"


def test_root_endpoint():
    """ë£¨íŠ¸ ì—”ë“œí¬ì¸íŠ¸ê°€ ì •ìƒ ì‘ë™í•˜ëŠ”ì§€ í…ŒìŠ¤íŠ¸í•©ë‹ˆë‹¤."""
    response = client.get("/")
    assert response.status_code == 200
    assert "message" in response.json()


def test_cors_policy():
    """RULE-011ì— ë”°ë¥¸ CORS ì •ì±…ì´ ì˜¬ë°”ë¥´ê²Œ ì„¤ì •ë˜ì—ˆëŠ”ì§€ í…ŒìŠ¤íŠ¸í•©ë‹ˆë‹¤."""
    # í—ˆìš©ëœ ì˜¤ë¦¬ì§„ í…ŒìŠ¤íŠ¸ (í¬íŠ¸ 8001)
    headers = {
        "Origin": "http://localhost:8001",
        "Access-Control-Request-Method": "GET",
    }
    response = client.options("/health", headers=headers)
    assert response.status_code == 200
    assert response.headers.get("access-control-allow-origin") == "http://localhost:8001"

    # í—ˆìš©ë˜ì§€ ì•Šì€ ì˜¤ë¦¬ì§„ í…ŒìŠ¤íŠ¸ (í¬íŠ¸ 9000)
    headers = {
        "Origin": "http://localhost:9000",
        "Access-Control-Request-Method": "GET",
    }
    response = client.options("/health", headers=headers)
    # FastAPI/Starlette CORS ë¯¸ë“¤ì›¨ì–´ëŠ” í—ˆìš©ë˜ì§€ ì•Šì€ ê²½ìš° origin í—¤ë”ë¥¼ ë°˜í™˜í•˜ì§€ ì•ŠìŒ
    assert "access-control-allow-origin" not in response.headers
</file>

<file path="backend/tests/qa/test_asset_manifest.py">
import json
import os

import pytest
from jsonschema import validate

# Paths
# This file is in backend/tests/qa/
# We go up 3 levels to get to backend root: backend/tests/qa -> backend/tests -> backend -> root (wait, backend is in root)
# Actually:
# __file__ = D:\Dev\unknown-world\backend\tests\qa\test_asset_manifest.py
# os.path.dirname(__file__) = D:\Dev\unknown-world\backend\tests\qa
# ... up 1 = tests
# ... up 2 = backend
# ... up 3 = unknown-world (project root)

CURRENT_DIR = os.path.dirname(os.path.abspath(__file__))
PROJECT_ROOT = os.path.dirname(os.path.dirname(os.path.dirname(CURRENT_DIR)))

# If PROJECT_ROOT is correct, it should contain frontend/
FRONTEND_UI_DIR = os.path.join(PROJECT_ROOT, "frontend", "public", "ui")
MANIFEST_PATH = os.path.join(FRONTEND_UI_DIR, "manifest.json")
SCHEMA_PATH = os.path.join(FRONTEND_UI_DIR, "manifest.schema.json")


def test_manifest_schema_validation():
    """Validates manifest.json against manifest.schema.json"""
    if not os.path.exists(MANIFEST_PATH):
        pytest.fail(f"Manifest not found at {MANIFEST_PATH}")
    if not os.path.exists(SCHEMA_PATH):
        pytest.fail(f"Schema not found at {SCHEMA_PATH}")

    with open(MANIFEST_PATH, encoding="utf-8") as f:
        manifest = json.load(f)

    with open(SCHEMA_PATH, encoding="utf-8") as f:
        schema = json.load(f)

    # validate raises ValidationError on failure
    validate(instance=manifest, schema=schema)


def test_asset_files_existence_and_size():
    """Checks if assets listed in manifest exist and sizes match/budget"""
    with open(MANIFEST_PATH, encoding="utf-8") as f:
        manifest = json.load(f)

    assets = manifest.get("assets", [])
    total_bytes_calculated = 0

    for asset in assets:
        rel_path = asset["path"]
        abs_path = os.path.join(FRONTEND_UI_DIR, rel_path)

        # 1. Existence Check
        assert os.path.exists(abs_path), f"Asset file missing: {rel_path} (full: {abs_path})"

        # 2. Size Check
        actual_size = os.path.getsize(abs_path)
        recorded_size = asset.get("bytes")

        # Note: If size mismatches, we print a helpful message.
        # In a real QA scenario, we might want to auto-update, but for this test we fail.
        if recorded_size is not None:
            assert actual_size == recorded_size, (
                f"Size mismatch for {rel_path}: actual {actual_size} != manifest {recorded_size}"
            )

        total_bytes_calculated += actual_size

        # 3. Individual Budget Check (from QA_CHECKLIST.md)
        asset_type = asset["type"]
        if asset_type == "icon":
            # 30KB limit
            assert actual_size <= 30 * 1024, (
                f"Icon {rel_path} exceeds 30KB budget ({actual_size} bytes)"
            )
        elif asset_type == "placeholder":
            # 300KB limit
            assert actual_size <= 300 * 1024, (
                f"Placeholder {rel_path} exceeds 300KB budget ({actual_size} bytes)"
            )
        elif asset_type == "chrome":
            # 120KB limit (increased for scanner-frame)
            assert actual_size <= 120 * 1024, (
                f"Chrome asset {rel_path} exceeds 120KB budget ({actual_size} bytes)"
            )

    # 4. Total Budget Check
    recorded_total = manifest.get("totalBytes")
    if recorded_total is not None:
        assert total_bytes_calculated == recorded_total, (
            f"Total bytes mismatch: calculated {total_bytes_calculated} != manifest {recorded_total}"
        )

    budget_total = manifest.get("budgetBytes", 1572864)
    assert total_bytes_calculated <= budget_total, (
        f"Total size {total_bytes_calculated} exceeds budget {budget_total}"
    )


def test_asset_naming_convention():
    """Checks if asset IDs and paths use kebab-case"""
    with open(MANIFEST_PATH, encoding="utf-8") as f:
        manifest = json.load(f)

    for asset in manifest["assets"]:
        asset_id = asset["id"]
        # Check for lowercase and kebab-case (allow numbers)
        assert asset_id.islower(), f"Asset ID {asset_id} should be lowercase"
        assert " " not in asset_id, f"Asset ID {asset_id} should not contain spaces"
        assert "_" not in asset_id, (
            f"Asset ID {asset_id} should not contain underscores (use kebab-case)"
        )
</file>

<file path="backend/tests/unit/models/test_turn.py">
"""TurnInput/TurnOutput ëª¨ë¸ ë‹¨ìœ„ í…ŒìŠ¤íŠ¸."""

import pytest
from pydantic import ValidationError

from unknown_world.models.turn import (
    AgentConsole,
    Box2D,
    CurrencyAmount,
    EconomyOutput,
    Language,
    RenderOutput,
    TurnInput,
    TurnOutput,
    UIOutput,
    WorldDelta,
)

# =============================================================================
# Fixtures
# =============================================================================


@pytest.fixture
def valid_box_2d():
    return {"ymin": 100, "xmin": 200, "ymax": 300, "xmax": 400}


@pytest.fixture
def valid_currency_amount():
    return {"signal": 100, "memory_shard": 5}


@pytest.fixture
def valid_client_info():
    return {"viewport_w": 1920, "viewport_h": 1080, "theme": "dark"}


@pytest.fixture
def valid_turn_input_data(valid_client_info, valid_currency_amount):
    return {
        "language": "ko-KR",
        "text": "Hello",
        "client": valid_client_info,
        "economy_snapshot": valid_currency_amount,
    }


@pytest.fixture
def valid_turn_output_data(valid_currency_amount):
    return {
        "language": "ko-KR",
        "narrative": "Story continues...",
        "economy": {
            "cost": {"signal": 10, "memory_shard": 0},
            "balance_after": {"signal": 90, "memory_shard": 5},
        },
        "safety": {"blocked": False},
    }


# =============================================================================
# Coordinate & Box2D Tests
# =============================================================================


def test_box_2d_valid(valid_box_2d):
    box = Box2D(**valid_box_2d)
    assert box.ymin == 100
    assert box.xmax == 400


def test_box_2d_invalid_coordinate():
    with pytest.raises(ValidationError):
        # Out of range (ge=0, le=1000)
        Box2D(ymin=-1, xmin=0, ymax=1001, xmax=500)


def test_box_2d_extra_forbidden():
    with pytest.raises(ValidationError):
        Box2D(ymin=0, xmin=0, ymax=100, xmax=100, extra_field="not allowed")


# =============================================================================
# Currency & Economy Tests
# =============================================================================


def test_currency_amount_valid(valid_currency_amount):
    amount = CurrencyAmount(**valid_currency_amount)
    assert amount.signal == 100


def test_currency_amount_negative_fails():
    with pytest.raises(ValidationError):
        CurrencyAmount(signal=-1, memory_shard=0)


def test_economy_output_valid():
    data = {
        "cost": {"signal": 5, "memory_shard": 0},
        "balance_after": {"signal": 95, "memory_shard": 5},
    }
    economy = EconomyOutput(**data)
    assert economy.cost.signal == 5
    assert economy.balance_after.signal == 95


# =============================================================================
# TurnInput Tests
# =============================================================================


def test_turn_input_valid(valid_turn_input_data):
    turn_input = TurnInput(**valid_turn_input_data)
    assert turn_input.language == Language.KO
    assert turn_input.text == "Hello"


def test_turn_input_with_click(valid_turn_input_data, valid_box_2d):
    data = valid_turn_input_data.copy()
    data["click"] = {"object_id": "door_01", "box_2d": valid_box_2d}
    turn_input = TurnInput(**data)
    assert turn_input.click.object_id == "door_01"
    assert turn_input.click.box_2d.ymin == 100


def test_turn_input_invalid_language():
    with pytest.raises(ValidationError):
        TurnInput(
            language="fr-FR",  # Not in Language enum
            text="...",
            client={"viewport_w": 800, "viewport_h": 600},
            economy_snapshot={"signal": 0, "memory_shard": 0},
        )


# =============================================================================
# TurnOutput Tests
# =============================================================================


def test_turn_output_valid_minimal(valid_turn_output_data):
    turn_output = TurnOutput(**valid_turn_output_data)
    assert turn_output.language == Language.KO
    assert turn_output.narrative == "Story continues..."
    # Check defaults
    assert isinstance(turn_output.ui, UIOutput)
    assert isinstance(turn_output.world, WorldDelta)
    assert isinstance(turn_output.render, RenderOutput)
    assert isinstance(turn_output.agent_console, AgentConsole)


def test_turn_output_full(valid_currency_amount, valid_box_2d):
    data = {
        "language": "en-US",
        "narrative": "Narrative text",
        "ui": {
            "action_deck": {
                "cards": [
                    {
                        "id": "c1",
                        "label": "Action 1",
                        "cost": {"signal": 5, "memory_shard": 0},
                    }
                ]
            },
            "objects": [{"id": "obj1", "label": "Object 1", "box_2d": valid_box_2d}],
        },
        "world": {
            "inventory_added": ["key"],
            "rules_changed": [{"id": "r1", "label": "Gravity", "description": "Low gravity"}],
            "quests_updated": [{"id": "q1", "label": "Find key", "is_completed": False}],
            "memory_pins": [
                {"id": "p1", "content": "Fact", "cost": {"signal": 1, "memory_shard": 0}}
            ],
        },
        "render": {
            "image_job": {
                "should_generate": True,
                "prompt": "A landscape",
                "model_label": "QUALITY",
            }
        },
        "economy": {
            "cost": {"signal": 10, "memory_shard": 0},
            "balance_after": {"signal": 90, "memory_shard": 5},
        },
        "safety": {"blocked": False},
        "agent_console": {"repair_count": 1, "badges": ["schema_ok", "economy_ok"]},
    }
    turn_output = TurnOutput(**data)
    assert turn_output.language == Language.EN
    assert len(turn_output.ui.action_deck.cards) == 1
    assert turn_output.render.image_job.should_generate is True


def test_turn_output_missing_required():
    with pytest.raises(ValidationError):
        # Missing economy and safety
        TurnOutput(language="ko-KR", narrative="...")


# =============================================================================
# JSON Schema Tests
# =============================================================================


def test_turn_output_json_schema():
    schema = TurnOutput.model_json_schema()
    assert schema["type"] == "object"
    assert "language" in schema["required"]
    assert "narrative" in schema["required"]
    assert "economy" in schema["required"]
    assert "safety" in schema["required"]

    # Check Coordinate constraints in schema
    # Pydantic 2 schema structure: properties -> language -> ...
    # Coordinate might be in $defs or inline depending on how it's used
    ui_props = schema["$defs"]["UIOutput"]["properties"]
    assert "action_deck" in ui_props

    # Verify that Coordinate (int with ge/le) is correctly represented
    # Box2D uses Coordinate
    box_props = schema["$defs"]["Box2D"]["properties"]
    assert box_props["ymin"]["maximum"] == 1000
    assert box_props["ymin"]["minimum"] == 0
</file>

<file path="frontend/coverage/coverage-final.json">
{"D:\\Dev\\unknown-world\\frontend\\src\\schemas\\turn.ts": {"path":"D:\\Dev\\unknown-world\\frontend\\src\\schemas\\turn.ts","statementMap":{"0":{"start":{"line":30,"column":30},"end":{"line":30,"column":null}},"1":{"start":{"line":41,"column":30},"end":{"line":41,"column":null}},"2":{"start":{"line":47,"column":27},"end":{"line":47,"column":null}},"3":{"start":{"line":54,"column":32},"end":{"line":62,"column":null}},"4":{"start":{"line":69,"column":37},"end":{"line":78,"column":null}},"5":{"start":{"line":85,"column":32},"end":{"line":85,"column":null}},"6":{"start":{"line":91,"column":31},"end":{"line":91,"column":null}},"7":{"start":{"line":102,"column":32},"end":{"line":107,"column":null}},"8":{"start":{"line":115,"column":27},"end":{"line":122,"column":null}},"9":{"start":{"line":129,"column":36},"end":{"line":138,"column":null}},"10":{"start":{"line":149,"column":32},"end":{"line":156,"column":null}},"11":{"start":{"line":162,"column":32},"end":{"line":176,"column":null}},"12":{"start":{"line":183,"column":37},"end":{"line":192,"column":null}},"13":{"start":{"line":199,"column":31},"end":{"line":209,"column":null}},"14":{"start":{"line":220,"column":32},"end":{"line":229,"column":null}},"15":{"start":{"line":236,"column":33},"end":{"line":247,"column":null}},"16":{"start":{"line":254,"column":32},"end":{"line":262,"column":null}},"17":{"start":{"line":270,"column":30},"end":{"line":278,"column":null}},"18":{"start":{"line":289,"column":31},"end":{"line":295,"column":null}},"19":{"start":{"line":302,"column":31},"end":{"line":312,"column":null}},"20":{"start":{"line":319,"column":27},"end":{"line":325,"column":null}},"21":{"start":{"line":332,"column":32},"end":{"line":359,"column":null}},"22":{"start":{"line":370,"column":30},"end":{"line":382,"column":null}},"23":{"start":{"line":389,"column":34},"end":{"line":395,"column":null}},"24":{"start":{"line":407,"column":35},"end":{"line":412,"column":null}},"25":{"start":{"line":424,"column":34},"end":{"line":436,"column":null}},"26":{"start":{"line":447,"column":34},"end":{"line":453,"column":null}},"27":{"start":{"line":469,"column":32},"end":{"line":502,"column":null}},"28":{"start":{"line":523,"column":4},"end":{"line":525,"column":null}},"29":{"start":{"line":528,"column":4},"end":{"line":530,"column":null}},"30":{"start":{"line":532,"column":2},"end":{"line":563,"column":null}},"31":{"start":{"line":590,"column":17},"end":{"line":590,"column":null}},"32":{"start":{"line":592,"column":2},"end":{"line":594,"column":null}},"33":{"start":{"line":593,"column":4},"end":{"line":593,"column":null}},"34":{"start":{"line":596,"column":2},"end":{"line":600,"column":null}},"35":{"start":{"line":611,"column":2},"end":{"line":611,"column":null}},"36":{"start":{"line":625,"column":2},"end":{"line":625,"column":null}}},"fnMap":{"0":{"name":"createFallbackTurnOutput","decl":{"start":{"line":517,"column":16},"end":{"line":517,"column":null}},"loc":{"start":{"line":521,"column":14},"end":{"line":564,"column":null}},"line":521},"1":{"name":"safeParseTurnOutput","decl":{"start":{"line":585,"column":16},"end":{"line":585,"column":null}},"loc":{"start":{"line":589,"column":25},"end":{"line":601,"column":null}},"line":589},"2":{"name":"parseTurnInput","decl":{"start":{"line":610,"column":16},"end":{"line":610,"column":31}},"loc":{"start":{"line":610,"column":57},"end":{"line":612,"column":null}},"line":610},"3":{"name":"safeParseTurnInput","decl":{"start":{"line":624,"column":16},"end":{"line":624,"column":35}},"loc":{"start":{"line":624,"column":76},"end":{"line":626,"column":null}},"line":624}},"branchMap":{"0":{"loc":{"start":{"line":519,"column":2},"end":{"line":519,"column":null}},"type":"default-arg","locations":[{"start":{"line":519,"column":24},"end":{"line":519,"column":null}}],"line":519},"1":{"loc":{"start":{"line":523,"column":4},"end":{"line":525,"column":null}},"type":"cond-expr","locations":[{"start":{"line":524,"column":8},"end":{"line":524,"column":null}},{"start":{"line":525,"column":8},"end":{"line":525,"column":null}}],"line":523},"2":{"loc":{"start":{"line":528,"column":4},"end":{"line":530,"column":null}},"type":"cond-expr","locations":[{"start":{"line":529,"column":8},"end":{"line":529,"column":null}},{"start":{"line":530,"column":8},"end":{"line":530,"column":null}}],"line":528},"3":{"loc":{"start":{"line":534,"column":15},"end":{"line":534,"column":null}},"type":"binary-expr","locations":[{"start":{"line":534,"column":15},"end":{"line":534,"column":31}},{"start":{"line":534,"column":31},"end":{"line":534,"column":null}}],"line":534},"4":{"loc":{"start":{"line":587,"column":2},"end":{"line":587,"column":null}},"type":"default-arg","locations":[{"start":{"line":587,"column":23},"end":{"line":587,"column":null}}],"line":587},"5":{"loc":{"start":{"line":588,"column":2},"end":{"line":588,"column":null}},"type":"default-arg","locations":[{"start":{"line":588,"column":24},"end":{"line":588,"column":null}}],"line":588},"6":{"loc":{"start":{"line":592,"column":2},"end":{"line":594,"column":null}},"type":"if","locations":[{"start":{"line":592,"column":2},"end":{"line":594,"column":null}},{"start":{},"end":{}}],"line":592}},"s":{"0":1,"1":1,"2":1,"3":1,"4":1,"5":1,"6":1,"7":1,"8":1,"9":1,"10":1,"11":1,"12":1,"13":1,"14":1,"15":1,"16":1,"17":1,"18":1,"19":1,"20":1,"21":1,"22":1,"23":1,"24":1,"25":1,"26":1,"27":1,"28":1,"29":1,"30":1,"31":2,"32":2,"33":1,"34":1,"35":2,"36":2},"f":{"0":1,"1":2,"2":2,"3":2},"b":{"0":[1],"1":[1,0],"2":[1,0],"3":[1,1],"4":[2],"5":[2],"6":[1,1]},"meta":{"lastBranch":7,"lastFunction":4,"lastStatement":37,"seen":{"s:30:30:30:Infinity":0,"s:41:30:41:Infinity":1,"s:47:27:47:Infinity":2,"s:54:32:62:Infinity":3,"s:69:37:78:Infinity":4,"s:85:32:85:Infinity":5,"s:91:31:91:Infinity":6,"s:102:32:107:Infinity":7,"s:115:27:122:Infinity":8,"s:129:36:138:Infinity":9,"s:149:32:156:Infinity":10,"s:162:32:176:Infinity":11,"s:183:37:192:Infinity":12,"s:199:31:209:Infinity":13,"s:220:32:229:Infinity":14,"s:236:33:247:Infinity":15,"s:254:32:262:Infinity":16,"s:270:30:278:Infinity":17,"s:289:31:295:Infinity":18,"s:302:31:312:Infinity":19,"s:319:27:325:Infinity":20,"s:332:32:359:Infinity":21,"s:370:30:382:Infinity":22,"s:389:34:395:Infinity":23,"s:407:35:412:Infinity":24,"s:424:34:436:Infinity":25,"s:447:34:453:Infinity":26,"s:469:32:502:Infinity":27,"f:517:16:517:Infinity":0,"b:519:24:519:Infinity":0,"s:523:4:525:Infinity":28,"b:524:8:524:Infinity:525:8:525:Infinity":1,"s:528:4:530:Infinity":29,"b:529:8:529:Infinity:530:8:530:Infinity":2,"s:532:2:563:Infinity":30,"b:534:15:534:31:534:31:534:Infinity":3,"f:585:16:585:Infinity":1,"b:587:23:587:Infinity":4,"b:588:24:588:Infinity":5,"s:590:17:590:Infinity":31,"b:592:2:594:Infinity:undefined:undefined:undefined:undefined":6,"s:592:2:594:Infinity":32,"s:593:4:593:Infinity":33,"s:596:2:600:Infinity":34,"f:610:16:610:31":2,"s:611:2:611:Infinity":35,"f:624:16:624:35":3,"s:625:2:625:Infinity":36}}}
}
</file>

<file path="frontend/src/App.test.tsx">
import { describe, it, expect, vi, beforeEach } from 'vitest';
import { render, screen, fireEvent } from '@testing-library/react';
import App from './App';
import * as turnStream from './api/turnStream';

// i18next ëª¨í‚¹
vi.mock('react-i18next', () => ({
  useTranslation: () => ({
    t: (key: string, options?: Record<string, unknown>) => {
      if (key === 'scene.hotspot.click_action') {
        return `Click: ${options?.label}`;
      }
      return key;
    },
    i18n: {
      changeLanguage: () => Promise.resolve(),
      resolvedLanguage: 'ko-KR',
    },
  }),
  initReactI18next: {
    type: '3rdParty',
    init: () => {},
  },
}));

// ResizeObserver ëª¨í‚¹
class MockResizeObserver {
  observe = vi.fn();
  unobserve = vi.fn();
  disconnect = vi.fn();
}
global.ResizeObserver = MockResizeObserver as unknown as typeof ResizeObserver;

// getBoundingClientRect ëª¨í‚¹
Element.prototype.getBoundingClientRect = vi.fn(() => ({
  width: 800,
  height: 600,
  top: 0,
  left: 0,
  bottom: 600,
  right: 800,
  x: 0,
  y: 0,
  toJSON: () => {},
})) as unknown as () => DOMRect;

// api ëª¨í‚¹
vi.mock('./api/turnStream', () => ({
  startTurnStream: vi.fn(),
}));

describe('App Integration - Hotspot Click', () => {
  beforeEach(() => {
    vi.clearAllMocks();
  });

  it('should trigger startTurnStream when a hotspot is clicked', async () => {
    render(<App />);
    
    // ë°ëª¨ìš©ìœ¼ë¡œ App.tsxì— í•˜ë“œì½”ë”©ëœ 'í„°ë¯¸ë„' í•«ìŠ¤íŒŸ ì°¾ê¸°
    const terminalHotspot = screen.getByLabelText('í„°ë¯¸ë„');
    expect(terminalHotspot).toBeInTheDocument();

    // í´ë¦­ ì‹œë®¬ë ˆì´ì…˜
    fireEvent.click(terminalHotspot);

    // startTurnStream í˜¸ì¶œ í™•ì¸
    expect(turnStream.startTurnStream).toHaveBeenCalled();
    
    const [input] = vi.mocked(turnStream.startTurnStream).mock.calls[0];
    
    // TurnInput ê²€ì¦
    expect(input.text).toBe('Click: í„°ë¯¸ë„');
    expect(input.click).toEqual({
      object_id: 'demo-terminal',
      box_2d: { ymin: 300, xmin: 100, ymax: 600, xmax: 400 },
    });
  });
});
</file>

<file path="frontend/src/components/ActionDeck.test.tsx">
import { describe, it, expect, vi } from 'vitest';
import { render, screen, fireEvent } from '@testing-library/react';
import { ActionDeck } from './ActionDeck';
import type { ActionCard } from '../schemas/turn';

// i18next ëª¨í‚¹
vi.mock('react-i18next', () => ({
  useTranslation: () => ({
    t: (key: string, params?: Record<string, unknown>) => {
      if (params?.turn !== undefined) return `Turn ${params.turn}`;
      if (key === 'action.risk.low') return 'Low';
      if (key === 'action.risk.medium') return 'Medium';
      if (key === 'action.risk.high') return 'High';
      if (key === 'action.insufficient_balance') return 'Insufficient Balance';
      if (key === 'action.alternative') return 'Alt';
      return key;
    },
  }),
}));

describe('ActionDeck Component', () => {
  const mockCards: ActionCard[] = [
    {
      id: 'card-1',
      label: 'Regular Action',
      description: 'Test Description',
      cost: { signal: 10, memory_shard: 0 },
      cost_estimate: {
        min: { signal: 8, memory_shard: 0 },
        max: { signal: 12, memory_shard: 0 },
      },
      risk: 'low',
      hint: 'Positive hint',
      reward_hint: 'Bonus item',
      enabled: true,
      disabled_reason: null,
      is_alternative: false,
    },
    {
      id: 'card-2',
      label: 'Expensive Action',
      description: null,
      cost: { signal: 50, memory_shard: 1 },
      cost_estimate: null,
      risk: 'high',
      hint: 'Risky hint',
      reward_hint: null,
      enabled: true,
      disabled_reason: null,
      is_alternative: false,
    },
    {
      id: 'card-alt',
      label: 'Alternative Action',
      description: null,
      cost: { signal: 2, memory_shard: 0 },
      cost_estimate: null,
      risk: 'low',
      hint: null,
      reward_hint: null,
      enabled: true,
      disabled_reason: null,
      is_alternative: true,
    },
  ];

  it('renders provided cards', () => {
    render(<ActionDeck cards={mockCards} />);
    expect(screen.getByText('Regular Action')).toBeInTheDocument();
    expect(screen.getByText('Expensive Action')).toBeInTheDocument();
    expect(screen.getByText('Alternative Action')).toBeInTheDocument();
  });

  it('displays cost estimates as ranges when available', () => {
    render(<ActionDeck cards={mockCards} />);
    // card-1 has cost_estimate: 8~12
    expect(screen.getByText('8~12')).toBeInTheDocument();
    // card-2 has cost: 50
    expect(screen.getByText('50')).toBeInTheDocument();
  });

  it('disables cards when balance is insufficient', () => {
    const lowBalance = { signal: 5, memory_shard: 0 };
    render(<ActionDeck cards={mockCards} currentBalance={lowBalance} />);

    // Regular Action (cost 10/estimate max 12) -> disabled
    const card1 = screen.getByRole('button', { name: /Regular Action/i });
    expect(card1).toBeDisabled();
    expect(screen.getAllByText('Insufficient Balance').length).toBeGreaterThan(0);

    // Alternative Action (cost 2) -> enabled
    const cardAlt = screen.getByRole('button', { name: /Alternative Action/i });
    expect(cardAlt).not.toBeDisabled();
  });

  it('renders alternative badge for alternative cards', () => {
    render(<ActionDeck cards={mockCards} />);
    expect(screen.getByText('Alt')).toBeInTheDocument();
  });

  it('calls onCardClick when an enabled card is clicked', () => {
    const onCardClick = vi.fn();
    render(<ActionDeck cards={mockCards} onCardClick={onCardClick} />);

    fireEvent.click(screen.getByText('Regular Action'));
    expect(onCardClick).toHaveBeenCalledWith(expect.objectContaining({ id: 'card-1' }));
  });

  it('displays server-provided disabled reason', () => {
    const disabledCard: ActionCard[] = [
      {
        ...mockCards[0],
        enabled: false,
        disabled_reason: 'Locked by story',
      },
    ];
    render(<ActionDeck cards={disabledCard} />);
    expect(screen.getByText('Locked by story')).toBeInTheDocument();
  });

  it('renders default cards when cards prop is empty', () => {
    render(<ActionDeck cards={[]} />);
    // useDefaultCards should provide some default labels
    expect(screen.getByText('action.default.explore.label')).toBeInTheDocument();
  });
});
</file>

<file path="frontend/src/components/ActionDeck.tsx">
/**
 * Unknown World - Action Deck ì»´í¬ë„ŒíŠ¸ (U-009[Mvp]).
 *
 * PRD ìš”êµ¬ì‚¬í•­:
 *   - Action Deck(3~6ì¥ ì¹´ë“œ)ì„ Footer ì˜ì—­ì— ìƒì‹œ ë…¸ì¶œ
 *   - ê° ì¹´ë“œì— ì˜ˆìƒ ë¹„ìš©(ìµœì†Œ/ìµœëŒ€), ìœ„í—˜ë„, ë³´ìƒ íŒíŠ¸ í‘œê¸° (RULE-005)
 *   - ì¹´ë“œ í´ë¦­ ì‹œ TurnInputìœ¼ë¡œ ì„ íƒëœ í–‰ë™ ì „ì†¡ (RULE-008)
 *   - ì”ì•¡ ë¶€ì¡± ì‹œ ì‹¤í–‰ ë¶ˆê°€ í‘œì‹œ + ì €ë¹„ìš© ëŒ€ì•ˆ ë…¸ì¶œ (RULE-005)
 *
 * RULE-002 ì¤€ìˆ˜: ì±„íŒ… ë²„ë¸”/ë©”ì‹œì§€ ë²„íŠ¼ì´ ì•„ë‹Œ "ê²Œì„ ì¹´ë“œ" UI
 *
 * @see vibe/prd.md 6.7 - Action Deck ìš”êµ¬ì‚¬í•­
 * @see .cursor/rules/10-frontend-game-ui.mdc
 * @module components/ActionDeck
 */

import { useMemo } from 'react';
import { useTranslation } from 'react-i18next';
import type { ActionCard } from '../schemas/turn';

// =============================================================================
// íƒ€ì… ì •ì˜
// =============================================================================

export interface ActionDeckProps {
  /** ì„œë²„ì—ì„œ ë°›ì€ ì•¡ì…˜ ì¹´ë“œ ëª©ë¡ */
  cards: ActionCard[];
  /** ì¹´ë“œ í´ë¦­ ì½œë°± */
  onCardClick?: (card: ActionCard) => void;
  /** ì „ì²´ ë¹„í™œì„±í™” (ìŠ¤íŠ¸ë¦¬ë° ì¤‘ ë“±) */
  disabled?: boolean;
  /** í˜„ì¬ ì”ì•¡ (í´ë¼ì´ì–¸íŠ¸ ì¸¡ ì‹¤í–‰ ê°€ëŠ¥ ì—¬ë¶€ íŒë‹¨ìš©) */
  currentBalance?: { signal: number; memory_shard: number };
}

interface CardDisplayInfo extends ActionCard {
  /** í´ë¼ì´ì–¸íŠ¸ ì¸¡ ì‹¤í–‰ ê°€ëŠ¥ ì—¬ë¶€ (ì„œë²„ enabledê°€ ì—†ì„ ë•Œ í´ë°±) */
  isAffordable: boolean;
  /** ìµœì¢… ë¹„í™œì„±í™” ì—¬ë¶€ */
  isDisabled: boolean;
  /** ìµœì¢… ë¹„í™œì„±í™” ì‚¬ìœ  */
  finalDisabledReason: string | null;
}

// =============================================================================
// ê¸°ë³¸ ì¹´ë“œ ìƒì„± (i18n ê¸°ë°˜)
// =============================================================================

function useDefaultCards(): ActionCard[] {
  const { t } = useTranslation();

  return useMemo(
    () => [
      {
        id: 'default-explore',
        label: t('action.default.explore.label'),
        description: t('action.default.explore.description'),
        cost: { signal: 1, memory_shard: 0 },
        cost_estimate: null,
        risk: 'low' as const,
        hint: null,
        reward_hint: null,
        enabled: true,
        disabled_reason: null,
        is_alternative: false,
      },
      {
        id: 'default-investigate',
        label: t('action.default.investigate.label'),
        description: t('action.default.investigate.description'),
        cost: { signal: 2, memory_shard: 0 },
        cost_estimate: null,
        risk: 'medium' as const,
        hint: null,
        reward_hint: null,
        enabled: true,
        disabled_reason: null,
        is_alternative: false,
      },
      {
        id: 'default-talk',
        label: t('action.default.talk.label'),
        description: t('action.default.talk.description'),
        cost: { signal: 1, memory_shard: 0 },
        cost_estimate: null,
        risk: 'low' as const,
        hint: null,
        reward_hint: null,
        enabled: true,
        disabled_reason: null,
        is_alternative: false,
      },
    ],
    [t],
  );
}

// =============================================================================
// ì¹´ë“œ ë¹„ìš© í‘œì‹œ ì»´í¬ë„ŒíŠ¸
// =============================================================================

interface CardCostDisplayProps {
  card: CardDisplayInfo;
}

function CardCostDisplay({ card }: CardCostDisplayProps) {
  const { t } = useTranslation();

  // ë¹„ìš© ì¶”ì • ë²”ìœ„ê°€ ìˆìœ¼ë©´ min~max í‘œì‹œ, ì—†ìœ¼ë©´ ê¸°ë³¸ cost í‘œì‹œ
  const costDisplay = card.cost_estimate
    ? `${card.cost_estimate.min.signal}~${card.cost_estimate.max.signal}`
    : `${card.cost.signal}`;

  const shardCost = card.cost_estimate
    ? card.cost_estimate.max.memory_shard
    : card.cost.memory_shard;

  return (
    <div className="action-card-cost" data-ui-importance="critical">
      {/* Signal ë¹„ìš© */}
      <span className="cost-item">
        <span className="icon-wrapper" aria-label={t('economy.signal_cost')}>
          <img
            src="/ui/icons/signal-16.png"
            alt=""
            aria-hidden="true"
            className="icon-img"
            style={{ width: 14, height: 14 }}
            onError={(e) => e.currentTarget.classList.add('hidden')}
          />
          <span className="icon-fallback">âš¡</span>
        </span>
        <span className="cost-value">{costDisplay}</span>
      </span>

      {/* Shard ë¹„ìš© (0ë³´ë‹¤ í´ ë•Œë§Œ í‘œì‹œ) */}
      {shardCost > 0 && (
        <span className="cost-item">
          <span className="cost-separator">|</span>
          <span className="icon-wrapper" aria-label={t('economy.shard_cost')}>
            <img
              src="/ui/icons/shard-16.png"
              alt=""
              aria-hidden="true"
              className="icon-img"
              style={{ width: 14, height: 14 }}
              onError={(e) => e.currentTarget.classList.add('hidden')}
            />
            <span className="icon-fallback">ğŸ’</span>
          </span>
          <span className="cost-value">
            {card.cost_estimate
              ? `${card.cost_estimate.min.memory_shard}~${card.cost_estimate.max.memory_shard}`
              : card.cost.memory_shard}
          </span>
        </span>
      )}

      {/* ìœ„í—˜ë„ */}
      <span className="cost-item">
        <span className="cost-separator">|</span>
        <span className="icon-wrapper" aria-label={t('economy.risk_level')}>
          <img
            src={`/ui/icons/risk-${card.risk}-16.png`}
            alt=""
            aria-hidden="true"
            className={`icon-img risk-${card.risk}`}
            style={{ width: 14, height: 14 }}
            onError={(e) => e.currentTarget.classList.add('hidden')}
          />
          <span className="icon-fallback">âš </span>
        </span>
        <span className={`risk-label risk-${card.risk}`}>{t(`action.risk.${card.risk}`)}</span>
      </span>
    </div>
  );
}

// =============================================================================
// ë‹¨ì¼ ì¹´ë“œ ì»´í¬ë„ŒíŠ¸
// =============================================================================

interface ActionCardItemProps {
  card: CardDisplayInfo;
  onClick: () => void;
  disabled: boolean;
}

function ActionCardItem({ card, onClick, disabled }: ActionCardItemProps) {
  const { t } = useTranslation();

  const cardClasses = [
    'action-card',
    'has-chrome',
    card.isDisabled ? 'card-disabled' : '',
    card.is_alternative ? 'card-alternative' : '',
    `risk-border-${card.risk}`,
  ]
    .filter(Boolean)
    .join(' ');

  return (
    <button
      type="button"
      className={cardClasses}
      onClick={onClick}
      disabled={disabled || card.isDisabled}
      aria-disabled={disabled || card.isDisabled}
      title={card.finalDisabledReason ?? card.description ?? undefined}
    >
      {/* ëŒ€ì•ˆ ì¹´ë“œ í‘œì‹œ */}
      {card.is_alternative && <span className="alternative-badge">{t('action.alternative')}</span>}

      {/* ì¹´ë“œ íƒ€ì´í‹€ */}
      <div className="action-card-title">{card.label}</div>

      {/* ì¹´ë“œ ì„¤ëª… (ìˆì„ ë•Œë§Œ) */}
      {card.description && <div className="action-card-description">{card.description}</div>}

      {/* ë¹„ìš©/ìœ„í—˜ë„ ì •ë³´ */}
      <CardCostDisplay card={card} />

      {/* íŒíŠ¸ ì˜ì—­ */}
      {(card.hint || card.reward_hint) && (
        <div className="action-card-hints">
          {card.hint && (
            <div className="hint-item hint-risk">
              <span className="hint-icon">âš </span>
              <span className="hint-text">{card.hint}</span>
            </div>
          )}
          {card.reward_hint && (
            <div className="hint-item hint-reward">
              <span className="hint-icon">â˜…</span>
              <span className="hint-text">{card.reward_hint}</span>
            </div>
          )}
        </div>
      )}

      {/* ë¹„í™œì„±í™” ì˜¤ë²„ë ˆì´ */}
      {card.isDisabled && (
        <div className="card-disabled-overlay">
          <span className="disabled-reason">
            {card.finalDisabledReason ?? t('action.insufficient_balance')}
          </span>
        </div>
      )}
    </button>
  );
}

// =============================================================================
// ë©”ì¸ Action Deck ì»´í¬ë„ŒíŠ¸
// =============================================================================

export function ActionDeck({
  cards,
  onCardClick,
  disabled = false,
  currentBalance = { signal: 100, memory_shard: 5 },
}: ActionDeckProps) {
  const { t } = useTranslation();
  const defaultCards = useDefaultCards();

  // ì¹´ë“œê°€ ì—†ìœ¼ë©´ ê¸°ë³¸ ì¹´ë“œ ì‚¬ìš©
  const displayCards = cards.length > 0 ? cards : defaultCards;

  // ì¹´ë“œë³„ ì‹¤í–‰ ê°€ëŠ¥ ì—¬ë¶€ ê³„ì‚° (Q1: Option A - ì„œë²„ ìš°ì„ , í´ë¼ì´ì–¸íŠ¸ í´ë°±)
  const processedCards: CardDisplayInfo[] = useMemo(() => {
    return displayCards.map((card) => {
      // ì„œë²„ì—ì„œ enabledë¥¼ ëª…ì‹œì ìœ¼ë¡œ falseë¡œ ë³´ëƒˆìœ¼ë©´ ê·¸ëŒ€ë¡œ ì‚¬ìš©
      const serverEnabled = card.enabled;

      // í´ë¼ì´ì–¸íŠ¸ ì¸¡ ì”ì•¡ ì²´í¬ (ì„œë²„ê°€ íŒë‹¨í•˜ì§€ ì•Šì•˜ì„ ë•Œ í´ë°±)
      const costToCheck = card.cost_estimate?.max ?? card.cost;
      const isAffordable =
        currentBalance.signal >= costToCheck.signal &&
        currentBalance.memory_shard >= costToCheck.memory_shard;

      // ìµœì¢… ë¹„í™œì„±í™” ì—¬ë¶€: ì„œë²„ íŒë‹¨ ìš°ì„ , ì—†ìœ¼ë©´ í´ë¼ì´ì–¸íŠ¸ íŒë‹¨
      const isDisabled = !serverEnabled || !isAffordable;

      // ë¹„í™œì„±í™” ì‚¬ìœ  ê²°ì •
      let finalDisabledReason: string | null = null;
      if (!serverEnabled && card.disabled_reason) {
        finalDisabledReason = card.disabled_reason;
      } else if (!isAffordable) {
        finalDisabledReason = t('action.insufficient_balance');
      }

      return {
        ...card,
        isAffordable,
        isDisabled,
        finalDisabledReason,
      };
    });
  }, [displayCards, currentBalance, t]);

  // ì¼ë°˜ ì¹´ë“œì™€ ëŒ€ì•ˆ ì¹´ë“œ ë¶„ë¦¬ (ëŒ€ì•ˆ ì¹´ë“œëŠ” ë’¤ì— ë°°ì¹˜)
  const sortedCards = useMemo(() => {
    const regular = processedCards.filter((c) => !c.is_alternative);
    const alternatives = processedCards.filter((c) => c.is_alternative);
    return [...regular, ...alternatives];
  }, [processedCards]);

  return (
    <div className="action-deck" role="group" aria-label={t('action.deck_label')}>
      {sortedCards.map((card) => (
        <ActionCardItem
          key={card.id}
          card={card}
          onClick={() => onCardClick?.(card)}
          disabled={disabled}
        />
      ))}

      {/* ëª¨ë“  ì¹´ë“œê°€ ë¹„í™œì„±í™”ë˜ì—ˆì„ ë•Œ ì•ˆë‚´ */}
      {sortedCards.every((c) => c.isDisabled) && !disabled && (
        <div className="deck-empty-notice">{t('action.all_disabled_notice')}</div>
      )}
    </div>
  );
}

export default ActionDeck;
</file>

<file path="frontend/src/components/SceneCanvas.hotspot.test.tsx">
import { describe, it, expect, vi, beforeEach } from 'vitest';
import { render, screen, fireEvent, act } from '@testing-library/react';
import { SceneCanvas } from './SceneCanvas';
import type { SceneObject } from '../schemas/turn';
import type { SceneCanvasState } from '../types/scene';

// i18next ëª¨í‚¹
vi.mock('react-i18next', () => ({
  useTranslation: () => ({
    t: (key: string) => key,
  }),
}));

// ResizeObserver ëª¨í‚¹
let resizeCallback: (entries: ResizeObserverEntry[]) => void;
class MockResizeObserver {
  constructor(callback: (entries: ResizeObserverEntry[]) => void) {
    resizeCallback = callback;
  }
  observe = vi.fn();
  unobserve = vi.fn();
  disconnect = vi.fn();
}

global.ResizeObserver = MockResizeObserver as unknown as typeof ResizeObserver;

/**
 * ë¦¬ì‚¬ì´ì¦ˆ ì´ë²¤íŠ¸ë¥¼ ìˆ˜ë™ìœ¼ë¡œ íŠ¸ë¦¬ê±°í•©ë‹ˆë‹¤.
 */
function triggerResize(width: number, height: number) {
  if (resizeCallback) {
    act(() => {
      resizeCallback([
        {
          contentRect: { width, height } as DOMRectReadOnly,
          target: document.querySelector('.scene-canvas') as Element,
        } as ResizeObserverEntry,
      ]);
    });
  }
}

// getBoundingClientRect ëª¨í‚¹
Element.prototype.getBoundingClientRect = vi.fn(() => ({
  width: 800,
  height: 600,
  top: 0,
  left: 0,
  bottom: 600,
  right: 800,
  x: 0,
  y: 0,
  toJSON: () => {},
})) as unknown as () => DOMRect;

describe('SceneCanvas Hotspots', () => {
  const defaultState: SceneCanvasState = {
    status: 'scene',
    imageUrl: 'https://example.com/scene.png',
  };

  const mockObjects: SceneObject[] = [
    {
      id: 'obj-1',
      label: 'Object 1',
      box_2d: { ymin: 100, xmin: 100, ymax: 200, xmax: 200 },
      interaction_hint: 'Click me',
    },
    {
      id: 'obj-2',
      label: 'Object 2',
      box_2d: { ymin: 500, xmin: 500, ymax: 700, xmax: 700 },
      interaction_hint: null,
    },
  ];

  beforeEach(() => {
    vi.clearAllMocks();
  });

  it('should render hotspots when objects are provided and status is scene', () => {
    render(<SceneCanvas state={defaultState} objects={mockObjects} />);
    
    // í•«ìŠ¤íŒŸ ë ˆì´ì–´ í™•ì¸
    const layer = screen.getByLabelText('scene.hotspot.layer_label');
    expect(layer).toBeInTheDocument();

    // ê°œë³„ í•«ìŠ¤íŒŸ í™•ì¸ (role="button")
    const buttons = screen.getAllByRole('button');
    expect(buttons).toHaveLength(mockObjects.length);
    expect(buttons[0]).toHaveAttribute('aria-label', 'Object 1');
    expect(buttons[1]).toHaveAttribute('aria-label', 'Object 2');
  });

  it('should not render hotspots when status is loading', () => {
    const loadingState: SceneCanvasState = { status: 'loading' };
    render(<SceneCanvas state={loadingState} objects={mockObjects} />);
    
    const layer = screen.queryByLabelText('scene.hotspot.layer_label');
    expect(layer).not.toBeInTheDocument();
  });

  it('should call onHotspotClick when a hotspot is clicked', () => {
    const onHotspotClick = vi.fn();
    render(<SceneCanvas state={defaultState} objects={mockObjects} onHotspotClick={onHotspotClick} />);
    
    const firstHotspot = screen.getByLabelText('Object 1');
    fireEvent.click(firstHotspot);

    expect(onHotspotClick).toHaveBeenCalledWith({
      object_id: 'obj-1',
      box_2d: mockObjects[0].box_2d,
    });
  });

  it('should show tooltip on hover', async () => {
    render(<SceneCanvas state={defaultState} objects={mockObjects} />);
    
    const firstHotspot = screen.getByLabelText('Object 1');
    
    // Hover ì‹œì‘
    fireEvent.mouseEnter(firstHotspot);
    
    // íˆ´íŒ ë¼ë²¨ í™•ì¸
    expect(screen.getByText('Object 1')).toBeInTheDocument();
    expect(screen.getByText(/scene.hotspot.hint_prefix/)).toBeInTheDocument();
    expect(screen.getByText(/Click me/)).toBeInTheDocument();

    // Hover ì¢…ë£Œ
    fireEvent.mouseLeave(firstHotspot);
    expect(screen.queryByText('Object 1')).not.toBeInTheDocument();
  });

  it('should be disabled when disabled prop is true', () => {
    const onHotspotClick = vi.fn();
    render(<SceneCanvas state={defaultState} objects={mockObjects} onHotspotClick={onHotspotClick} disabled={true} />);
    
    const firstHotspot = screen.getByLabelText('Object 1');
    expect(firstHotspot).toHaveAttribute('aria-disabled', 'true');
    expect(firstHotspot).toHaveAttribute('tabindex', '-1');

    fireEvent.click(firstHotspot);
    expect(onHotspotClick).not.toHaveBeenCalled();
  });

  it('should reposition hotspots when canvas size changes (reactive resize)', () => {
    render(<SceneCanvas state={defaultState} objects={mockObjects} />);
    
    const firstHotspot = screen.getByLabelText('Object 1');
    
    // ì´ˆê¸° í¬ê¸° (800x600) ê¸°ë°˜ ìœ„ì¹˜ í™•ì¸
    // ymin: 100, xmin: 100, ymax: 200, xmax: 200
    // top: 100 * (600/1000) = 60px
    // left: 100 * (800/1000) = 80px
    expect(firstHotspot).toHaveStyle({
      top: '60px',
      left: '80px',
      width: '80px',
      height: '60px',
    });

    // í¬ê¸° ë³€ê²½ íŠ¸ë¦¬ê±° (400x300)
    triggerResize(400, 300);
    
    // ë³€ê²½ëœ í¬ê¸° ê¸°ë°˜ ìœ„ì¹˜ í™•ì¸
    // top: 100 * (300/1000) = 30px
    // left: 100 * (400/1000) = 40px
    expect(firstHotspot).toHaveStyle({
      top: '30px',
      left: '40px',
      width: '40px',
      height: '30px',
    });
  });
});
</file>

<file path="frontend/src/components/SceneCanvas.test.tsx">
import { describe, it, expect } from 'vitest';
import { SCENE_PLACEHOLDERS } from './SceneCanvas';

describe('SCENE_PLACEHOLDERS', () => {
  it('should have all required statuses', () => {
    const statuses = ['default', 'loading', 'offline', 'blocked', 'low_signal'];
    statuses.forEach((status) => {
      expect(SCENE_PLACEHOLDERS).toHaveProperty(status);
    });
  });

  it('should have correct image paths', () => {
    expect(SCENE_PLACEHOLDERS.default.imagePath).toBe(
      '/ui/placeholders/scene-placeholder-default.png',
    );
    expect(SCENE_PLACEHOLDERS.loading.imagePath).toBe('/ui/placeholders/scene-loading.webp');
    expect(SCENE_PLACEHOLDERS.offline.imagePath).toBe('/ui/placeholders/scene-offline.webp');
    expect(SCENE_PLACEHOLDERS.blocked.imagePath).toBe('/ui/placeholders/scene-blocked.webp');
    expect(SCENE_PLACEHOLDERS.low_signal.imagePath).toBe('/ui/placeholders/scene-low-signal.webp');
  });

  it('should have correct i18n label keys', () => {
    expect(SCENE_PLACEHOLDERS.default.labelKey).toBe('scene.status.default');
    expect(SCENE_PLACEHOLDERS.loading.labelKey).toBe('scene.status.loading');
    expect(SCENE_PLACEHOLDERS.offline.labelKey).toBe('scene.status.offline');
    expect(SCENE_PLACEHOLDERS.blocked.labelKey).toBe('scene.status.blocked');
    expect(SCENE_PLACEHOLDERS.low_signal.labelKey).toBe('scene.status.low_signal');
  });
});
</file>

<file path="frontend/src/i18n-scenario.test.ts">
import { describe, it, expect } from 'vitest';
import i18next from './i18n';

describe('i18n Integration Scenarios (U-039)', () => {
  it('Scenario D: should have correct i18next options', () => {
    expect(i18next.options.supportedLngs).toContain('ko-KR');
    expect(i18next.options.supportedLngs).toContain('en-US');
    expect(i18next.options.lng).toBe('ko-KR');
    expect(i18next.options.fallbackLng).toContain('en-US');
  });

  it('Scenario A: should translate to Korean by default', () => {
    // Economy labels
    expect(i18next.t('economy.signal')).toBe('Signal');
    expect(i18next.t('economy.shard')).toBe('Shard');

    // Panel titles
    expect(i18next.t('panel.inventory.title')).toBe('Inventory');
    expect(i18next.t('panel.quest.title')).toBe('Quest');

    // Agent Console
    expect(i18next.t('agent.console.queue')).toBe('ëŒ€ê¸°ì—´');
    expect(i18next.t('agent.console.status.idle')).toBe('ëŒ€ê¸° ì¤‘');

    // Connection
    expect(i18next.t('connection.online')).toBe('ì˜¨ë¼ì¸');

    // UI
    expect(i18next.t('ui.command_placeholder')).toBe('ëª…ë ¹ì„ ì…ë ¥í•˜ì„¸ìš”...');
    expect(i18next.t('ui.execute')).toBe('ì‹¤í–‰');
  });

  it('Scenario B: should switch to English and back to Korean', async () => {
    // Switch to English
    await i18next.changeLanguage('en-US');
    expect(i18next.resolvedLanguage).toBe('en-US');

    // Check English translations
    expect(i18next.t('agent.console.queue')).toBe('Queue');
    expect(i18next.t('agent.console.status.idle')).toBe('IDLE');
    expect(i18next.t('connection.online')).toBe('ONLINE');
    expect(i18next.t('ui.command_placeholder')).toBe('Enter command...');
    expect(i18next.t('ui.execute')).toBe('EXECUTE');

    // Switch back to Korean
    await i18next.changeLanguage('ko-KR');
    expect(i18next.resolvedLanguage).toBe('ko-KR');
    expect(i18next.t('agent.console.queue')).toBe('ëŒ€ê¸°ì—´');
    expect(i18next.t('connection.online')).toBe('ì˜¨ë¼ì¸');
  });
});
</file>

<file path="frontend/src/schemas/index.ts">
/**
 * Unknown World - ìŠ¤í‚¤ë§ˆ ëª¨ë“ˆ ì§„ì…ì .
 *
 * TurnInput/TurnOutput Zod ìŠ¤í‚¤ë§ˆ ë° ê´€ë ¨ ìœ í‹¸ë¦¬í‹°ë¥¼ ì¬ë‚´ë³´ë‚´ê¸°í•©ë‹ˆë‹¤.
 *
 * @module schemas
 */

// =============================================================================
// ìŠ¤í‚¤ë§ˆ ë²„ì „
// =============================================================================

export { SCHEMA_VERSION } from './turn';

// =============================================================================
// Enum ìŠ¤í‚¤ë§ˆ ë° íƒ€ì…
// =============================================================================

export {
  LanguageSchema,
  ThemeSchema,
  AgentPhaseSchema,
  ValidationBadgeSchema,
  ModelLabelSchema,
  RiskLevelSchema,
} from './turn';

export type { Language, Theme, AgentPhase, ValidationBadge, ModelLabel, RiskLevel } from './turn';

// =============================================================================
// ê³µí†µ í•˜ìœ„ íƒ€ì… ìŠ¤í‚¤ë§ˆ ë° íƒ€ì…
// =============================================================================

export { CoordinateSchema, Box2DSchema, CurrencyAmountSchema } from './turn';

export type { Coordinate, Box2D, CurrencyAmount } from './turn';

// =============================================================================
// TurnInput ê´€ë ¨ ìŠ¤í‚¤ë§ˆ ë° íƒ€ì…
// =============================================================================

export { ClickInputSchema, ClientInfoSchema, EconomySnapshotSchema, TurnInputSchema } from './turn';

export type { ClickInput, ClientInfo, EconomySnapshot, TurnInput } from './turn';

// =============================================================================
// TurnOutput ê´€ë ¨ ìŠ¤í‚¤ë§ˆ ë° íƒ€ì…
// =============================================================================

export {
  // UI
  ActionCardSchema,
  SceneObjectSchema,
  ActionDeckSchema,
  UIOutputSchema,
  // World
  MemoryPinSchema,
  WorldRuleSchema,
  QuestSchema,
  WorldDeltaSchema,
  // Render
  ImageJobSchema,
  RenderOutputSchema,
  // Economy
  EconomyOutputSchema,
  // Safety
  SafetyOutputSchema,
  // Agent Console
  AgentConsoleSchema,
  // Main
  TurnOutputSchema,
} from './turn';

export type {
  // UI
  ActionCard,
  SceneObject,
  ActionDeck,
  UIOutput,
  // World
  MemoryPin,
  WorldRule,
  Quest,
  WorldDelta,
  // Render
  ImageJob,
  RenderOutput,
  // Economy
  EconomyOutput,
  // Safety
  SafetyOutput,
  // Agent Console
  AgentConsole,
  // Main
  TurnOutput,
} from './turn';

// =============================================================================
// ìœ í‹¸ë¦¬í‹° í•¨ìˆ˜
// =============================================================================

export {
  createFallbackTurnOutput,
  safeParseTurnOutput,
  parseTurnInput,
  safeParseTurnInput,
} from './turn';

export type { TurnOutputParseResult, TurnInputSafeParseResult } from './turn';
</file>

<file path="frontend/src/schemas/turn.test.ts">
import { describe, it, expect } from 'vitest';
import {
  TurnInputSchema,
  TurnOutputSchema,
  safeParseTurnOutput,
  parseTurnInput,
  safeParseTurnInput,
  SCHEMA_VERSION,
} from './turn';

describe('Turn schemas', () => {
  describe('SCHEMA_VERSION', () => {
    it('should have correct version', () => {
      expect(SCHEMA_VERSION).toBe('1.0.0');
    });
  });

  describe('TurnInputSchema', () => {
    const validTurnInput = {
      language: 'ko-KR',
      text: 'í…ŒìŠ¤íŠ¸ ì…ë ¥',
      client: {
        viewport_w: 1920,
        viewport_h: 1080,
        theme: 'dark',
      },
      economy_snapshot: {
        signal: 100,
        memory_shard: 5,
      },
    };

    it('should validate a valid TurnInput', () => {
      const result = TurnInputSchema.safeParse(validTurnInput);
      expect(result.success).toBe(true);
    });

    it('should fail on invalid language', () => {
      const result = TurnInputSchema.safeParse({
        ...validTurnInput,
        language: 'fr-FR',
      });
      expect(result.success).toBe(false);
    });

    it('should fail on negative economy values', () => {
      const result = TurnInputSchema.safeParse({
        ...validTurnInput,
        economy_snapshot: {
          signal: -1,
          memory_shard: 0,
        },
      });
      expect(result.success).toBe(false);
    });

    it('should fail on extra fields (strict)', () => {
      const result = TurnInputSchema.safeParse({
        ...validTurnInput,
        extra_field: 'not allowed',
      });
      expect(result.success).toBe(false);
    });

    it('should validate click input with bbox', () => {
      const result = TurnInputSchema.safeParse({
        ...validTurnInput,
        click: {
          object_id: 'door_01',
          box_2d: {
            ymin: 100,
            xmin: 100,
            ymax: 500,
            xmax: 500,
          },
        },
      });
      expect(result.success).toBe(true);
    });

    it('should fail on invalid bbox coordinates (out of range 0-1000)', () => {
      const result = TurnInputSchema.safeParse({
        ...validTurnInput,
        click: {
          object_id: 'door_01',
          box_2d: {
            ymin: -1,
            xmin: 0,
            ymax: 1001,
            xmax: 500,
          },
        },
      });
      expect(result.success).toBe(false);
    });

    it('should fail on non-positive viewport dimensions', () => {
      const result = TurnInputSchema.safeParse({
        ...validTurnInput,
        client: {
          viewport_w: 0,
          viewport_h: -100,
          theme: 'dark',
        },
      });
      expect(result.success).toBe(false);
    });

    it('should fail on non-integer coordinates', () => {
      const result = TurnInputSchema.safeParse({
        ...validTurnInput,
        click: {
          object_id: 'obj',
          box_2d: {
            ymin: 10.5,
            xmin: 20,
            ymax: 30,
            xmax: 40,
          },
        },
      });
      expect(result.success).toBe(false);
    });
  });

  describe('TurnOutputSchema', () => {
    const validTurnOutput = {
      language: 'ko-KR',
      narrative: 'í…ŒìŠ¤íŠ¸ ë‚´ëŸ¬í‹°ë¸Œ',
      economy: {
        cost: { signal: 5, memory_shard: 0 },
        balance_after: { signal: 95, memory_shard: 5 },
      },
      safety: {
        blocked: false,
      },
      agent_console: {
        current_phase: 'commit',
        badges: ['schema_ok', 'economy_ok'],
        repair_count: 0,
      },
    };

    it('should validate a valid TurnOutput', () => {
      const result = TurnOutputSchema.safeParse(validTurnOutput);
      expect(result.success).toBe(true);
    });

    it('should fail if required fields are missing', () => {
      const { narrative: _narrative, ...invalidOutput } = validTurnOutput;
      const result = TurnOutputSchema.safeParse(invalidOutput);
      expect(result.success).toBe(false);
    });

    it('should handle default values for optional fields', () => {
      const result = TurnOutputSchema.safeParse(validTurnOutput);
      if (result.success) {
        expect(result.data.ui).toBeDefined();
        expect(result.data.ui.action_deck.cards).toEqual([]);
        expect(result.data.world.rules_changed).toEqual([]);
      } else {
        throw new Error('Validation failed');
      }
    });

    it('should fail if there are too many action cards (max 10)', () => {
      const cards = Array.from({ length: 11 }, (_, i) => ({
        id: `card_${i}`,
        label: `Card ${i}`,
        cost: { signal: 0, memory_shard: 0 },
        risk: 'low',
      }));
      const result = TurnOutputSchema.safeParse({
        ...validTurnOutput,
        ui: {
          action_deck: { cards },
        },
      });
      expect(result.success).toBe(false);
    });

    it('should fail on negative repair_count', () => {
      const result = TurnOutputSchema.safeParse({
        ...validTurnOutput,
        agent_console: {
          current_phase: 'commit',
          badges: [],
          repair_count: -1,
        },
      });
      expect(result.success).toBe(false);
    });
  });

  describe('safeParseTurnOutput', () => {
    it('should return success for valid data', () => {
      const validTurnOutput = {
        language: 'en-US',
        narrative: 'Test narrative',
        economy: {
          cost: { signal: 0, memory_shard: 0 },
          balance_after: { signal: 100, memory_shard: 0 },
        },
        safety: { blocked: false },
      };
      const result = safeParseTurnOutput(validTurnOutput);
      expect(result.success).toBe(true);
      if (result.success) {
        expect(result.data.language).toBe('en-US');
      }
    });

    it('should return fallback for invalid data', () => {
      const invalidData = { some: 'garbage' };
      const result = safeParseTurnOutput(invalidData, 'ko-KR', 1);
      expect(result.success).toBe(false);
      if (!result.success) {
        expect(result.fallback).toBeDefined();
        expect(result.fallback.language).toBe('ko-KR');
        expect(result.fallback.agent_console.badges).toContain('schema_fail');
        expect(result.fallback.agent_console.repair_count).toBe(1);
      }
    });
  });

  describe('Input Parsing Utilities', () => {
    const validTurnInput = {
      language: 'ko-KR',
      text: 'í…ŒìŠ¤íŠ¸ ì…ë ¥',
      client: {
        viewport_w: 1920,
        viewport_h: 1080,
        theme: 'dark',
      },
      economy_snapshot: {
        signal: 100,
        memory_shard: 5,
      },
    };

    describe('parseTurnInput', () => {
      it('should parse valid input', () => {
        const result = parseTurnInput(validTurnInput);
        expect(result.text).toBe('í…ŒìŠ¤íŠ¸ ì…ë ¥');
      });

      it('should throw error for invalid input', () => {
        expect(() => parseTurnInput({})).toThrow();
      });
    });

    describe('safeParseTurnInput', () => {
      it('should return success for valid input', () => {
        const result = safeParseTurnInput(validTurnInput);
        expect(result.success).toBe(true);
      });

      it('should return failure for invalid input', () => {
        const result = safeParseTurnInput({});
        expect(result.success).toBe(false);
      });
    });
  });
});
</file>

<file path="frontend/src/schemas/verify_runbook.ts">
import {
  TurnOutputSchema,
  safeParseTurnOutput,
  Box2DSchema,
  CurrencyAmountSchema,
  LanguageSchema,
  parseTurnInput,
} from './turn.js';

console.log('--- Scenario A: TurnOutput ìŠ¤í‚¤ë§ˆ ê²€ì¦ (ì •ìƒ ì¼€ì´ìŠ¤) ---');
const validOutput = {
  language: 'ko-KR',
  narrative: 'ë¬¸ì´ ì‚ê±±ê±°ë¦¬ë©° ì—´ë¦½ë‹ˆë‹¤...',
  economy: {
    cost: { signal: 5, memory_shard: 0 },
    balance_after: { signal: 95, memory_shard: 5 },
  },
  safety: { blocked: false, message: null },
};
const resultA = safeParseTurnOutput(validOutput);
console.log('Success:', resultA.success);
if (resultA.success) {
  console.log('Data (sample):', resultA.data.narrative);
}

console.log('\n--- Scenario B: TurnOutput ìŠ¤í‚¤ë§ˆ ê²€ì¦ ì‹¤íŒ¨ â†’ í´ë°± ---');
const invalidOutput = {
  language: 'ko-KR',
  narrative: 'í…ŒìŠ¤íŠ¸',
};
// eslint-disable-next-line @typescript-eslint/no-explicit-any
const resultB = safeParseTurnOutput(invalidOutput as any);
console.log('Success:', resultB.success);
if (!resultB.success) {
  console.log('Error count:', resultB.error.issues.length);
  console.log('Fallback exists:', !!resultB.fallback);
  console.log(
    'Fallback badges has schema_fail:',
    resultB.fallback?.agent_console?.badges?.includes('schema_fail'),
  );
}

console.log('\n--- Scenario C: ì¢Œí‘œ ë²”ìœ„ ê²€ì¦ (RULE-009) ---');
const validBox = { ymin: 100, xmin: 200, ymax: 300, xmax: 400 };
console.log('Valid box:', Box2DSchema.safeParse(validBox).success);
const invalidBox = { ymin: 100, xmin: 200, ymax: 1500, xmax: 400 };
console.log('Invalid box (1500):', Box2DSchema.safeParse(invalidBox).success);
const negativeBox = { ymin: -10, xmin: 200, ymax: 300, xmax: 400 };
console.log('Negative box:', Box2DSchema.safeParse(negativeBox).success);

console.log('\n--- Scenario D: ì¬í™” ì¸ë°”ë¦¬ì–¸íŠ¸ ê²€ì¦ (RULE-005) ---');
const validCurrency = { signal: 100, memory_shard: 5 };
console.log('Valid currency:', CurrencyAmountSchema.safeParse(validCurrency).success);
const negativeCurrency = { signal: -10, memory_shard: 5 };
console.log('Negative signal:', CurrencyAmountSchema.safeParse(negativeCurrency).success);

console.log('\n--- Scenario E: ì–¸ì–´ ì •ì±… ê²€ì¦ (RULE-006) ---');
console.log('ko-KR:', LanguageSchema.safeParse('ko-KR').success);
console.log('en-US:', LanguageSchema.safeParse('en-US').success);
console.log('ja-JP (invalid):', LanguageSchema.safeParse('ja-JP').success);
console.log('ko (invalid format):', LanguageSchema.safeParse('ko').success);

console.log('\n--- Scenario F: TurnInput ê²€ì¦ ---');
const validInput = {
  language: 'ko-KR',
  text: 'ë¬¸ì„ ì—´ì–´ë³¸ë‹¤',
  client: {
    viewport_w: 1920,
    viewport_h: 1080,
    theme: 'dark',
  },
  economy_snapshot: {
    signal: 100,
    memory_shard: 5,
  },
};
try {
  // eslint-disable-next-line @typescript-eslint/no-explicit-any
  const parsed = parseTurnInput(validInput as any);
  console.log('Parsed successfully:', parsed.text);
} catch (e) {
  console.log('Parse error:', e);
}

console.log('\n--- Scenario G: Strict ëª¨ë“œ ê²€ì¦ ---');
const outputWithExtra = {
  language: 'ko-KR',
  narrative: 'í…ŒìŠ¤íŠ¸',
  economy: {
    cost: { signal: 0, memory_shard: 0 },
    balance_after: { signal: 100, memory_shard: 5 },
  },
  safety: { blocked: false, message: null },
  unknown_field: 'ì´ í•„ë“œëŠ” ìŠ¤í‚¤ë§ˆì— ì—†ìŒ',
};
const resultG = TurnOutputSchema.safeParse(outputWithExtra);
console.log('With extra field success:', resultG.success);
if (!resultG.success) {
  console.log('Error code:', resultG.error.issues[0].code);
}
</file>

<file path="frontend/src/setupTests.ts">
import '@testing-library/jest-dom';
</file>

<file path="frontend/src/stores/actionDeckStore.test.ts">
import { describe, it, expect, beforeEach } from 'vitest';
import { useActionDeckStore, filterAffordableCards } from './actionDeckStore';
import type { ActionCard } from '../schemas/turn';

describe('actionDeckStore', () => {
  beforeEach(() => {
    useActionDeckStore.getState().reset();
  });

  const mockCards: ActionCard[] = [
    {
      id: 'card-1',
      label: 'Card 1',
      description: null,
      cost: { signal: 10, memory_shard: 0 },
      cost_estimate: null,
      risk: 'low',
      hint: null,
      reward_hint: null,
      enabled: true,
      disabled_reason: null,
      is_alternative: false,
    },
    {
      id: 'card-2',
      label: 'Card 2',
      description: null,
      cost: { signal: 50, memory_shard: 1 },
      cost_estimate: null,
      risk: 'high',
      hint: null,
      reward_hint: null,
      enabled: true,
      disabled_reason: null,
      is_alternative: false,
    },
  ];

  it('sets cards and resets selected card', () => {
    const store = useActionDeckStore.getState();
    store.selectCard('some-id');
    expect(useActionDeckStore.getState().selectedCardId).toBe('some-id');

    store.setCards(mockCards);
    expect(useActionDeckStore.getState().cards).toEqual(mockCards);
    expect(useActionDeckStore.getState().selectedCardId).toBeNull();
  });

  it('marks a card as executed', () => {
    const store = useActionDeckStore.getState();
    store.selectCard('card-1');
    store.markExecuted('card-1');

    expect(useActionDeckStore.getState().lastExecutedCardId).toBe('card-1');
    expect(useActionDeckStore.getState().selectedCardId).toBeNull();
  });

  it('filters affordable cards correctly', () => {
    const balance = { signal: 20, memory_shard: 0 };
    const affordable = filterAffordableCards(mockCards, balance);

    expect(affordable).toHaveLength(1);
    expect(affordable[0].id).toBe('card-1');
  });

  it('respects server enabled flag in filterAffordableCards', () => {
    const disabledCards: ActionCard[] = [
      {
        ...mockCards[0],
        enabled: false,
      },
    ];
    const balance = { signal: 100, memory_shard: 100 };
    const affordable = filterAffordableCards(disabledCards, balance);

    expect(affordable).toHaveLength(0);
  });
});
</file>

<file path="frontend/src/stores/actionDeckStore.ts">
/**
 * Unknown World - Action Deck ìƒíƒœ ê´€ë¦¬ (Zustand) (U-009[Mvp]).
 *
 * Action Deckì˜ ì¹´ë“œ ëª©ë¡, ì„ íƒ ìƒíƒœ, ì”ì•¡ ê¸°ë°˜ í•„í„°ë§ì„ ê´€ë¦¬í•©ë‹ˆë‹¤.
 *
 * ì„¤ê³„ ì›ì¹™:
 *   - RULE-005: ì”ì•¡ ë¶€ì¡± ì‹œ ì‹¤í–‰ ë¶ˆê°€ í‘œì‹œ + ëŒ€ì•ˆ ì œê³µ
 *   - RULE-008: ì¹´ë“œ í´ë¦­ â†’ TurnInput ì—°ê²°
 *
 * @module stores/actionDeckStore
 */

import { create } from 'zustand';
import type { ActionCard } from '../schemas/turn';

// =============================================================================
// ìƒíƒœ íƒ€ì… ì •ì˜
// =============================================================================

/** Action Deck ìƒíƒœ */
export interface ActionDeckState {
  /** í˜„ì¬ ì¹´ë“œ ëª©ë¡ (ì„œë²„ì—ì„œ ë°›ì€ ì›ë³¸) */
  cards: ActionCard[];
  /** ì„ íƒëœ ì¹´ë“œ ID (í´ë¦­ í›„ ì‹¤í–‰ ì „ê¹Œì§€) */
  selectedCardId: string | null;
  /** ë§ˆì§€ë§‰ìœ¼ë¡œ ì‹¤í–‰ëœ ì¹´ë“œ ID */
  lastExecutedCardId: string | null;
}

/** Action Deck ì•¡ì…˜ */
export interface ActionDeckActions {
  /** ì¹´ë“œ ëª©ë¡ ì„¤ì • (TurnOutput ìˆ˜ì‹  ì‹œ) */
  setCards: (cards: ActionCard[]) => void;
  /** ì¹´ë“œ ì„ íƒ */
  selectCard: (cardId: string | null) => void;
  /** ì¹´ë“œ ì‹¤í–‰ ì™„ë£Œ ê¸°ë¡ */
  markExecuted: (cardId: string) => void;
  /** ìƒíƒœ ì´ˆê¸°í™” */
  reset: () => void;
}

export type ActionDeckStore = ActionDeckState & ActionDeckActions;

// =============================================================================
// ì´ˆê¸° ìƒíƒœ
// =============================================================================

function createInitialState(): ActionDeckState {
  return {
    cards: [],
    selectedCardId: null,
    lastExecutedCardId: null,
  };
}

// =============================================================================
// Zustand Store
// =============================================================================

/**
 * Action Deck ìƒíƒœ ìŠ¤í† ì–´.
 *
 * @example
 * ```tsx
 * const { cards, setCards, selectCard } = useActionDeckStore();
 *
 * // TurnOutput ìˆ˜ì‹  ì‹œ
 * setCards(turnOutput.ui.action_deck.cards);
 *
 * // ì¹´ë“œ í´ë¦­ ì‹œ
 * selectCard(card.id);
 * ```
 */
export const useActionDeckStore = create<ActionDeckStore>((set) => ({
  // ì´ˆê¸° ìƒíƒœ
  ...createInitialState(),

  // ì•¡ì…˜
  setCards: (cards) => {
    set({
      cards,
      selectedCardId: null, // ìƒˆ ì¹´ë“œ ëª©ë¡ ìˆ˜ì‹  ì‹œ ì„ íƒ ì´ˆê¸°í™”
    });
  },

  selectCard: (cardId) => {
    set({ selectedCardId: cardId });
  },

  markExecuted: (cardId) => {
    set({
      lastExecutedCardId: cardId,
      selectedCardId: null,
    });
  },

  reset: () => {
    set(createInitialState());
  },
}));

// =============================================================================
// ì…€ë ‰í„° (ì„±ëŠ¥ ìµœì í™”ìš©)
// =============================================================================

/** ì¹´ë“œ ëª©ë¡ ì…€ë ‰í„° */
export const selectCards = (state: ActionDeckStore) => state.cards;

/** ì„ íƒëœ ì¹´ë“œ ID ì…€ë ‰í„° */
export const selectSelectedCardId = (state: ActionDeckStore) => state.selectedCardId;

/** ì„ íƒëœ ì¹´ë“œ ê°ì²´ ì…€ë ‰í„° */
export const selectSelectedCard = (state: ActionDeckStore) =>
  state.cards.find((c) => c.id === state.selectedCardId) ?? null;

/** ë§ˆì§€ë§‰ ì‹¤í–‰ ì¹´ë“œ ID ì…€ë ‰í„° */
export const selectLastExecutedCardId = (state: ActionDeckStore) => state.lastExecutedCardId;

// =============================================================================
// ìœ í‹¸ë¦¬í‹° í•¨ìˆ˜
// =============================================================================

/**
 * ì”ì•¡ ê¸°ë°˜ìœ¼ë¡œ ì‹¤í–‰ ê°€ëŠ¥í•œ ì¹´ë“œë§Œ í•„í„°ë§í•©ë‹ˆë‹¤.
 * (ì»´í¬ë„ŒíŠ¸ì—ì„œ ì‚¬ìš©í•˜ê±°ë‚˜, ì„œë²„ ì‘ë‹µì´ enabledë¥¼ ì œê³µí•˜ì§€ ì•Šì„ ë•Œ í´ë°±ìœ¼ë¡œ ì‚¬ìš©)
 *
 * @param cards - ì›ë³¸ ì¹´ë“œ ëª©ë¡
 * @param balance - í˜„ì¬ ì”ì•¡
 * @returns ì‹¤í–‰ ê°€ëŠ¥í•œ ì¹´ë“œ ëª©ë¡
 */
export function filterAffordableCards(
  cards: ActionCard[],
  balance: { signal: number; memory_shard: number },
): ActionCard[] {
  return cards.filter((card) => {
    // ì„œë²„ì—ì„œ ì´ë¯¸ enabled=falseë¡œ íŒë‹¨í–ˆìœ¼ë©´ ì œì™¸
    if (!card.enabled) return false;

    // ë¹„ìš© ì¶”ì •ì¹˜ê°€ ìˆìœ¼ë©´ ìµœëŒ€ ë¹„ìš©ìœ¼ë¡œ íŒë‹¨
    const cost = card.cost_estimate?.max ?? card.cost;
    return balance.signal >= cost.signal && balance.memory_shard >= cost.memory_shard;
  });
}

/**
 * ëŒ€ì•ˆ ì¹´ë“œ(is_alternative=true)ë§Œ í•„í„°ë§í•©ë‹ˆë‹¤.
 *
 * @param cards - ì›ë³¸ ì¹´ë“œ ëª©ë¡
 * @returns ëŒ€ì•ˆ ì¹´ë“œ ëª©ë¡
 */
export function filterAlternativeCards(cards: ActionCard[]): ActionCard[] {
  return cards.filter((card) => card.is_alternative);
}

/**
 * ì¼ë°˜ ì¹´ë“œ(is_alternative=false)ë§Œ í•„í„°ë§í•©ë‹ˆë‹¤.
 *
 * @param cards - ì›ë³¸ ì¹´ë“œ ëª©ë¡
 * @returns ì¼ë°˜ ì¹´ë“œ ëª©ë¡
 */
export function filterRegularCards(cards: ActionCard[]): ActionCard[] {
  return cards.filter((card) => !card.is_alternative);
}
</file>

<file path="frontend/src/stores/agentStore.test.ts">
import { describe, it, expect, beforeEach } from 'vitest';
import { useAgentStore } from './agentStore';
import { StreamEventType, StageStatus } from '../api/turnStream';
import type { TurnOutput } from '../schemas/turn';

describe('agentStore', () => {
  beforeEach(() => {
    useAgentStore.getState().reset();
  });

  it('should have correct initial state', () => {
    const state = useAgentStore.getState();
    expect(state.isStreaming).toBe(false);
    expect(state.phases).toHaveLength(7);
    expect(state.phases[0].status).toBe('pending');
    expect(state.badges).toEqual([]);
    expect(state.repairCount).toBe(0);
  });

  it('should handle startStream', () => {
    useAgentStore.getState().startStream();
    const state = useAgentStore.getState();
    expect(state.isStreaming).toBe(true);
  });

  it('should handle handleStage events', () => {
    const store = useAgentStore.getState();

    // Start parse phase
    store.handleStage({
      type: StreamEventType.STAGE,
      name: 'parse',
      status: StageStatus.START,
    });

    let state = useAgentStore.getState();
    expect(state.currentPhase).toBe('parse');
    expect(state.phases.find((p) => p.name === 'parse')?.status).toBe('in_progress');

    // Complete parse phase
    store.handleStage({
      type: StreamEventType.STAGE,
      name: 'parse',
      status: StageStatus.COMPLETE,
    });

    state = useAgentStore.getState();
    expect(state.phases.find((p) => p.name === 'parse')?.status).toBe('completed');
  });

  it('should handle handleBadges events', () => {
    const store = useAgentStore.getState();
    store.handleBadges({
      type: StreamEventType.BADGES,
      badges: ['schema_ok', 'economy_ok'],
    });

    const state = useAgentStore.getState();
    expect(state.badges).toEqual(['schema_ok', 'economy_ok']);
  });

  it('should handle handleNarrativeDelta events', () => {
    const store = useAgentStore.getState();
    store.handleNarrativeDelta({
      type: StreamEventType.NARRATIVE_DELTA,
      text: 'Hello ',
    });
    store.handleNarrativeDelta({
      type: StreamEventType.NARRATIVE_DELTA,
      text: 'World',
    });

    const state = useAgentStore.getState();
    expect(state.narrativeBuffer).toBe('Hello World');
  });

  it('should handle handleFinal events', () => {
    const store = useAgentStore.getState();
    const mockOutput = {
      language: 'ko-KR',
      narrative: 'Final message',
      economy: {
        cost: { signal: 0, memory_shard: 0 },
        balance_after: { signal: 100, memory_shard: 0 },
      },
      safety: { blocked: false, message: null },
      ui: { action_deck: { cards: [] }, objects: [] },
      world: {
        rules_changed: [],
        inventory_added: [],
        inventory_removed: [],
        quests_updated: [],
        relationships_changed: [],
        memory_pins: [],
      },
      render: { image_job: null },
      agent_console: {
        repair_count: 2,
        current_phase: 'commit',
        badges: [],
      },
    } as TurnOutput;

    store.handleFinal({
      type: StreamEventType.FINAL,
      data: mockOutput,
    });

    const state = useAgentStore.getState();
    expect(state.finalOutput).toEqual(mockOutput);
    expect(state.repairCount).toBe(2);
  });

  it('should handle handleError events', () => {
    const store = useAgentStore.getState();
    store.handleError({
      type: StreamEventType.ERROR,
      message: 'Network error',
      code: 'ERR_NET',
    });

    const state = useAgentStore.getState();
    expect(state.error).toEqual({
      message: 'Network error',
      code: 'ERR_NET',
    });
  });

  it('should reset state on completeStream', () => {
    const store = useAgentStore.getState();
    store.handleNarrativeDelta({ type: StreamEventType.NARRATIVE_DELTA, text: 'Some text' });
    store.startStream();

    store.completeStream();

    const state = useAgentStore.getState();
    expect(state.isStreaming).toBe(false);
    expect(state.narrativeBuffer).toBe('');
  });
});
</file>

<file path="frontend/src/types/scene.ts">
/**
 * Scene Canvas ê´€ë ¨ íƒ€ì… ì •ì˜ (U-031: Placeholder Pack)
 */

/**
 * Scene Canvas ìƒíƒœ íƒ€ì…
 * - default: ê¸°ë³¸ ìƒíƒœ (ì¥ë©´ ì´ë¯¸ì§€ ì—†ìŒ)
 * - loading: ë°ì´í„° ë¡œë”© ì¤‘
 * - offline: ì˜¤í”„ë¼ì¸/ì—°ê²° ëŠê¹€
 * - blocked: ì•ˆì „/ì •ì±… ì°¨ë‹¨
 * - low_signal: ì¬í™”/ì‹ í˜¸ ë¶€ì¡±
 * - scene: ì •ìƒ ì¥ë©´ í‘œì‹œ (ì´ë¯¸ì§€ URL í¬í•¨)
 */
export type SceneCanvasStatus =
  | 'default'
  | 'loading'
  | 'offline'
  | 'blocked'
  | 'low_signal'
  | 'scene';

/**
 * Scene Canvas ìƒíƒœ ë°ì´í„° êµ¬ì¡°
 */
export interface SceneCanvasState {
  status: SceneCanvasStatus;
  imageUrl?: string;
  message?: string;
}

/**
 * ìƒíƒœë³„ placeholder ì •ë³´ êµ¬ì¡°
 */
export interface PlaceholderInfo {
  imagePath: string;
  fallbackEmoji: string;
  labelKey: string;
}
</file>

<file path="frontend/src/utils/box2d.test.ts">
import { describe, it, expect } from 'vitest';
import {
  box2dToPixel,
  pixelToBox2d,
  isValidBox2D,
  box2dArea,
  box2dCenter,
  NORMALIZED_MAX,
} from './box2d';
import type { Box2D } from '../schemas/turn';

describe('box2d utils', () => {
  const canvas = { width: 800, height: 600 };

  describe('box2dToPixel', () => {
    it('should correctly convert normalized coordinates to pixels', () => {
      const normalized: Box2D = { ymin: 100, xmin: 200, ymax: 500, xmax: 800 };
      const pixel = box2dToPixel(normalized, canvas);

      // top = 100 * (600 / 1000) = 60
      // left = 200 * (800 / 1000) = 160
      // bottom = 500 * (600 / 1000) = 300
      // right = 800 * (800 / 1000) = 640
      // width = 640 - 160 = 480
      // height = 300 - 60 = 240

      expect(pixel).toEqual({
        top: 60,
        left: 160,
        width: 480,
        height: 240,
      });
    });

    it('should handle full canvas size', () => {
      const normalized: Box2D = { ymin: 0, xmin: 0, ymax: 1000, xmax: 1000 };
      const pixel = box2dToPixel(normalized, canvas);

      expect(pixel).toEqual({
        top: 0,
        left: 0,
        width: 800,
        height: 600,
      });
    });
  });

  describe('pixelToBox2d', () => {
    it('should correctly convert pixels back to normalized coordinates', () => {
      const pixel = { top: 60, left: 160, width: 480, height: 240 };
      const normalized = pixelToBox2d(pixel, canvas);

      expect(normalized).toEqual({
        ymin: 100,
        xmin: 200,
        ymax: 500,
        xmax: 800,
      });
    });

    it('should round and clamp values', () => {
      const pixel = { top: -10, left: -20, width: 900, height: 700 };
      const normalized = pixelToBox2d(pixel, canvas);

      expect(normalized.ymin).toBe(0);
      expect(normalized.xmin).toBe(0);
      expect(normalized.ymax).toBe(NORMALIZED_MAX);
      expect(normalized.xmax).toBe(NORMALIZED_MAX);
    });
  });

  describe('isValidBox2D', () => {
    it('should return true for valid boxes', () => {
      expect(isValidBox2D({ ymin: 100, xmin: 100, ymax: 200, xmax: 200 })).toBe(true);
      expect(isValidBox2D({ ymin: 0, xmin: 0, ymax: 1000, xmax: 1000 })).toBe(true);
    });

    it('should return false for out of range values', () => {
      expect(isValidBox2D({ ymin: -1, xmin: 0, ymax: 100, xmax: 100 })).toBe(false);
      expect(isValidBox2D({ ymin: 0, xmin: 0, ymax: 1001, xmax: 100 })).toBe(false);
    });

    it('should return false for invalid order', () => {
      expect(isValidBox2D({ ymin: 500, xmin: 100, ymax: 400, xmax: 200 })).toBe(false);
      expect(isValidBox2D({ ymin: 100, xmin: 500, ymax: 200, xmax: 400 })).toBe(false);
    });
  });

  describe('box2dArea', () => {
    it('should calculate area correctly', () => {
      const box = { ymin: 100, xmin: 100, ymax: 200, xmax: 300 };
      expect(box2dArea(box)).toBe(20000); // (200-100) * (300-100) = 100 * 200
    });
  });

  describe('box2dCenter', () => {
    it('should calculate center correctly', () => {
      const box = { ymin: 100, xmin: 100, ymax: 300, xmax: 500 };
      expect(box2dCenter(box)).toEqual({ x: 300, y: 200 });
    });
  });
});
</file>

<file path="frontend/src/utils/box2d.ts">
/**
 * Unknown World - Box2D ì¢Œí‘œ ë³€í™˜ ìœ í‹¸ë¦¬í‹°
 *
 * RULE-009 ì¤€ìˆ˜: ì¢Œí‘œ ê·œì•½ (0~1000 ì •ê·œí™”, bbox=[ymin,xmin,ymax,xmax])
 * - ì„œë²„/ì„¸ì´ë¸Œì—ëŠ” í•­ìƒ box_2d(0~1000)ë¥¼ ìœ ì§€
 * - ë Œë”ì—ì„œë§Œ viewport í¬ê¸°(canvasW/H)ì— ë§ì¶° pxë¡œ ë³€í™˜
 *
 * @module utils/box2d
 */

import type { Box2D } from '../schemas/turn';

// =============================================================================
// ìƒìˆ˜ ì •ì˜
// =============================================================================

/**
 * ì •ê·œí™” ì¢Œí‘œê³„ ìµœëŒ“ê°’ (0~1000).
 * RULE-009: ì¢Œí‘œ ê·œì•½
 */
export const NORMALIZED_MAX = 1000;

// =============================================================================
// íƒ€ì… ì •ì˜
// =============================================================================

/**
 * í”½ì…€ ë‹¨ìœ„ ë°”ìš´ë”© ë°•ìŠ¤.
 * ë Œë”ë§ìš©ìœ¼ë¡œë§Œ ì‚¬ìš©ë©ë‹ˆë‹¤.
 */
export interface Box2DPixel {
  /** Y ìµœì†Œê°’ (ìƒë‹¨, í”½ì…€) */
  top: number;
  /** X ìµœì†Œê°’ (ì¢Œì¸¡, í”½ì…€) */
  left: number;
  /** ë„ˆë¹„ (í”½ì…€) */
  width: number;
  /** ë†’ì´ (í”½ì…€) */
  height: number;
}

/**
 * ìº”ë²„ìŠ¤ í¬ê¸° ì •ë³´.
 */
export interface CanvasSize {
  /** ìº”ë²„ìŠ¤ ë„ˆë¹„ (í”½ì…€) */
  width: number;
  /** ìº”ë²„ìŠ¤ ë†’ì´ (í”½ì…€) */
  height: number;
}

// =============================================================================
// ë³€í™˜ í•¨ìˆ˜
// =============================================================================

/**
 * ì •ê·œí™” ì¢Œí‘œ(0~1000)ë¥¼ í”½ì…€ ì¢Œí‘œë¡œ ë³€í™˜í•©ë‹ˆë‹¤.
 *
 * RULE-009: bbox ìˆœì„œëŠ” [ymin, xmin, ymax, xmax]
 *
 * @param box - ì •ê·œí™” ì¢Œí‘œ ë°”ìš´ë”© ë°•ìŠ¤
 * @param canvas - ìº”ë²„ìŠ¤ í¬ê¸°
 * @returns í”½ì…€ ë‹¨ìœ„ ë°”ìš´ë”© ë°•ìŠ¤
 *
 * @example
 * ```ts
 * const normalized: Box2D = { ymin: 100, xmin: 200, ymax: 500, xmax: 800 };
 * const canvas = { width: 800, height: 600 };
 * const pixel = box2dToPixel(normalized, canvas);
 * // pixel = { top: 60, left: 160, width: 480, height: 240 }
 * ```
 */
export function box2dToPixel(box: Box2D, canvas: CanvasSize): Box2DPixel {
  const scaleX = canvas.width / NORMALIZED_MAX;
  const scaleY = canvas.height / NORMALIZED_MAX;

  const top = box.ymin * scaleY;
  const left = box.xmin * scaleX;
  const bottom = box.ymax * scaleY;
  const right = box.xmax * scaleX;

  return {
    top,
    left,
    width: right - left,
    height: bottom - top,
  };
}

/**
 * í”½ì…€ ì¢Œí‘œë¥¼ ì •ê·œí™” ì¢Œí‘œ(0~1000)ë¡œ ë³€í™˜í•©ë‹ˆë‹¤.
 *
 * ì—­ë³€í™˜ì´ í•„ìš”í•œ ê²½ìš° ì‚¬ìš©í•©ë‹ˆë‹¤ (ì˜ˆ: í´ë¦­ ìœ„ì¹˜ â†’ ì •ê·œí™” ì¢Œí‘œ).
 *
 * @param pixel - í”½ì…€ ë‹¨ìœ„ ë°”ìš´ë”© ë°•ìŠ¤
 * @param canvas - ìº”ë²„ìŠ¤ í¬ê¸°
 * @returns ì •ê·œí™” ì¢Œí‘œ ë°”ìš´ë”© ë°•ìŠ¤
 */
export function pixelToBox2d(pixel: Box2DPixel, canvas: CanvasSize): Box2D {
  const scaleX = NORMALIZED_MAX / canvas.width;
  const scaleY = NORMALIZED_MAX / canvas.height;

  const ymin = Math.round(pixel.top * scaleY);
  const xmin = Math.round(pixel.left * scaleX);
  const ymax = Math.round((pixel.top + pixel.height) * scaleY);
  const xmax = Math.round((pixel.left + pixel.width) * scaleX);

  // RULE-009: 0~1000 ë²”ìœ„ ë³´ì¥
  return {
    ymin: Math.max(0, Math.min(NORMALIZED_MAX, ymin)),
    xmin: Math.max(0, Math.min(NORMALIZED_MAX, xmin)),
    ymax: Math.max(0, Math.min(NORMALIZED_MAX, ymax)),
    xmax: Math.max(0, Math.min(NORMALIZED_MAX, xmax)),
  };
}

/**
 * Box2Dê°€ ìœ íš¨í•œì§€ ê²€ì¦í•©ë‹ˆë‹¤.
 *
 * @param box - ê²€ì¦í•  ë°”ìš´ë”© ë°•ìŠ¤
 * @returns ìœ íš¨ ì—¬ë¶€
 */
export function isValidBox2D(box: Box2D): boolean {
  // 0~1000 ë²”ìœ„ ì²´í¬
  if (
    box.ymin < 0 ||
    box.ymin > NORMALIZED_MAX ||
    box.xmin < 0 ||
    box.xmin > NORMALIZED_MAX ||
    box.ymax < 0 ||
    box.ymax > NORMALIZED_MAX ||
    box.xmax < 0 ||
    box.xmax > NORMALIZED_MAX
  ) {
    return false;
  }

  // ymin < ymax, xmin < xmax ì²´í¬
  if (box.ymin >= box.ymax || box.xmin >= box.xmax) {
    return false;
  }

  return true;
}

/**
 * Box2Dì˜ ë©´ì ì„ ê³„ì‚°í•©ë‹ˆë‹¤ (ì •ê·œí™” ì¢Œí‘œ ê¸°ì¤€).
 *
 * @param box - ë°”ìš´ë”© ë°•ìŠ¤
 * @returns ë©´ì  (0~1000000)
 */
export function box2dArea(box: Box2D): number {
  return (box.ymax - box.ymin) * (box.xmax - box.xmin);
}

/**
 * Box2Dì˜ ì¤‘ì‹¬ì ì„ ê³„ì‚°í•©ë‹ˆë‹¤ (ì •ê·œí™” ì¢Œí‘œ ê¸°ì¤€).
 *
 * @param box - ë°”ìš´ë”© ë°•ìŠ¤
 * @returns ì¤‘ì‹¬ì  ì¢Œí‘œ {x, y}
 */
export function box2dCenter(box: Box2D): { x: number; y: number } {
  return {
    x: (box.xmin + box.xmax) / 2,
    y: (box.ymin + box.ymax) / 2,
  };
}
</file>

<file path="frontend/src/vite-env.d.ts">
/// <reference types="vite/client" />
</file>

<file path="frontend/tsconfig.node.json">
{
  "compilerOptions": {
    "target": "ES2022",
    "lib": ["ES2022"],
    "module": "ESNext",
    "skipLibCheck": true,

    /* Bundler mode */
    "moduleResolution": "Bundler",
    "allowImportingTsExtensions": true,
    "isolatedModules": true,
    "moduleDetection": "force",

    /* Composite for project references */
    "composite": true,
    "emitDeclarationOnly": true,
    "declaration": true,
    "declarationMap": true,

    /* Linting (ì—„ê²© ëª¨ë“œ) */
    "strict": true,
    "noUnusedLocals": true,
    "noUnusedParameters": true,
    "noFallthroughCasesInSwitch": true,
    "noUncheckedSideEffectImports": true
  },
  "include": ["vite.config.ts"]
}
</file>

<file path="backend/src/unknown_world/api/turn_stream_events.py">
"""Unknown World - Turn Stream ì´ë²¤íŠ¸ ê³„ì•½(Contract).

NDJSON ìŠ¤íŠ¸ë¦¬ë°ì—ì„œ ì‚¬ìš©ë˜ëŠ” ì´ë²¤íŠ¸ íƒ€ì…, ëª¨ë¸, ìœ í‹¸ë¦¬í‹°ë¥¼ ì •ì˜í•©ë‹ˆë‹¤.
ì´ ëª¨ë“ˆì€ Orchestrator â†” API â†” Frontend ê°„ì˜ ìŠ¤íŠ¸ë¦¼ ì´ë²¤íŠ¸ ê³„ì•½ SSOTì…ë‹ˆë‹¤.

ì„¤ê³„ ì›ì¹™:
    - RU-002-Q4: ì´ë²¤íŠ¸ ê³„ì•½ì„ transport ê³„ì¸µìœ¼ë¡œ ë¶„ë¦¬
    - RULE-003: êµ¬ì¡°í™” ì¶œë ¥(JSON Schema) ìš°ì„  + Pydantic ê²€ì¦
    - RULE-008: ë‹¨ê³„/ë°°ì§€ ê°€ì‹œí™”

ì°¸ì¡°:
    - vibe/unit-plans/U-007[Mvp].md
    - vibe/refactors/RU-002-Q4.md
"""

from __future__ import annotations

import json
from typing import Annotated, Any

from pydantic import BaseModel, Field

# =============================================================================
# ìŠ¤íŠ¸ë¦¼ ì´ë²¤íŠ¸ íƒ€ì… ìƒìˆ˜
# =============================================================================


class StreamEventType:
    """ìŠ¤íŠ¸ë¦¼ ì´ë²¤íŠ¸ íƒ€ì… ìƒìˆ˜.

    NDJSON ìŠ¤íŠ¸ë¦¬ë°ì—ì„œ ì‚¬ìš©ë˜ëŠ” ì´ë²¤íŠ¸ íƒ€ì…ì…ë‹ˆë‹¤.
    PRD ì˜ˆì‹œ ë‹¨ê³„: Parseâ†’Validateâ†’Planâ†’Resolveâ†’Renderâ†’Verifyâ†’Commit
    """

    STAGE = "stage"
    BADGES = "badges"
    NARRATIVE_DELTA = "narrative_delta"
    FINAL = "final"
    ERROR = "error"
    REPAIR = "repair"


class StageStatus:
    """ë‹¨ê³„ ìƒíƒœ ìƒìˆ˜."""

    START = "start"
    COMPLETE = "complete"
    FAIL = "fail"


# =============================================================================
# ìŠ¤íŠ¸ë¦¼ ì´ë²¤íŠ¸ ëª¨ë¸ (Pydantic)
# =============================================================================


class StageEvent(BaseModel):
    """ë‹¨ê³„ ì§„í–‰ ì´ë²¤íŠ¸.

    Attributes:
        type: ì´ë²¤íŠ¸ íƒ€ì… ("stage")
        name: ë‹¨ê³„ ì´ë¦„ (Parse, Validate, Plan, Resolve, Render, Verify, Commit)
        status: ìƒíƒœ (start, complete)
    """

    type: Annotated[str, Field(default=StreamEventType.STAGE)]
    name: str
    status: str


class RepairEvent(BaseModel):
    """ìë™ ë³µêµ¬(Repair) ì´ë²¤íŠ¸.

    Attributes:
        type: ì´ë²¤íŠ¸ íƒ€ì… ("repair")
        attempt: í˜„ì¬ ì‹œë„ íšŸìˆ˜
        message: ë³µêµ¬ ë©”ì‹œì§€ (ì„ íƒ)
    """

    type: Annotated[str, Field(default=StreamEventType.REPAIR)]
    attempt: int
    message: str | None = None


class BadgesEvent(BaseModel):
    """ë°°ì§€ ì´ë²¤íŠ¸.

    Attributes:
        type: ì´ë²¤íŠ¸ íƒ€ì… ("badges")
        badges: ê²€ì¦ ë°°ì§€ ëª©ë¡
    """

    type: Annotated[str, Field(default=StreamEventType.BADGES)]
    badges: list[str]


class NarrativeDeltaEvent(BaseModel):
    """ë‚´ëŸ¬í‹°ë¸Œ ë¸íƒ€ ì´ë²¤íŠ¸ (íƒ€ì íš¨ê³¼ìš©).

    Attributes:
        type: ì´ë²¤íŠ¸ íƒ€ì… ("narrative_delta")
        text: ì¶”ê°€ëœ í…ìŠ¤íŠ¸ ì¡°ê°
    """

    type: Annotated[str, Field(default=StreamEventType.NARRATIVE_DELTA)]
    text: str


class FinalEvent(BaseModel):
    """ìµœì¢… TurnOutput ì´ë²¤íŠ¸.

    Attributes:
        type: ì´ë²¤íŠ¸ íƒ€ì… ("final")
        data: ì™„ì „í•œ TurnOutput

    Note:
        TurnOutputì€ TYPE_CHECKING ë¸”ë¡ì—ì„œ importë˜ë©°,
        ëŸ°íƒ€ì„ì—ëŠ” Anyë¡œ ì²˜ë¦¬ë©ë‹ˆë‹¤.
    """

    type: Annotated[str, Field(default=StreamEventType.FINAL)]
    data: Any  # TurnOutput (ìˆœí™˜ import ë°©ì§€)


class ErrorEvent(BaseModel):
    """ì—ëŸ¬ ì´ë²¤íŠ¸.

    Attributes:
        type: ì´ë²¤íŠ¸ íƒ€ì… ("error")
        message: ì—ëŸ¬ ë©”ì‹œì§€ (í”„ë¡¬í”„íŠ¸/ë‚´ë¶€ ì¶”ë¡  ë…¸ì¶œ ê¸ˆì§€)
        code: ì—ëŸ¬ ì½”ë“œ (ì„ íƒ)
    """

    type: Annotated[str, Field(default=StreamEventType.ERROR)]
    message: str
    code: str | None = None


# =============================================================================
# ìœ í‹¸ë¦¬í‹° í•¨ìˆ˜
# =============================================================================


def serialize_event(event: dict[str, Any]) -> str:
    """ì´ë²¤íŠ¸ë¥¼ NDJSON ë¼ì¸ìœ¼ë¡œ ì§ë ¬í™”í•©ë‹ˆë‹¤.

    Args:
        event: ì§ë ¬í™”í•  ì´ë²¤íŠ¸ ë”•ì…”ë„ˆë¦¬

    Returns:
        str: NDJSON í˜•ì‹ ë¬¸ìì—´ (ì¤„ë°”ê¿ˆ í¬í•¨)
    """
    return json.dumps(event, ensure_ascii=False) + "\n"


# =============================================================================
# ëª¨ë“ˆ ê³µê°œ API
# =============================================================================

__all__ = [
    "StreamEventType",
    "StageStatus",
    "StageEvent",
    "RepairEvent",
    "BadgesEvent",
    "NarrativeDeltaEvent",
    "FinalEvent",
    "ErrorEvent",
    "serialize_event",
]
</file>

<file path="backend/src/unknown_world/models/turn.py">
"""Unknown World - TurnInput/TurnOutput Pydantic ìŠ¤í‚¤ë§ˆ.

ì´ ëª¨ë“ˆì€ Unknown Worldì˜ í•µì‹¬ ë°ì´í„° ëª¨ë¸ì„ ì •ì˜í•©ë‹ˆë‹¤.
Gemini Structured Outputsì— íˆ¬ì… ê°€ëŠ¥í•œ JSON Schema(ë¶€ë¶„ì§‘í•©)ë¥¼ ìƒì„±í•  ìˆ˜ ìˆìŠµë‹ˆë‹¤.

ì„¤ê³„ ì›ì¹™:
    - RULE-003: êµ¬ì¡°í™” ì¶œë ¥(JSON Schema) ìš°ì„  + ì´ì¤‘ ê²€ì¦
    - RULE-005: ì¬í™” ì¸ë°”ë¦¬ì–¸íŠ¸ (cost, balance_after í•„ìˆ˜, ì”ì•¡ ìŒìˆ˜ ê¸ˆì§€)
    - RULE-006: ko/en ì–¸ì–´ ì •ì±… (Language enumìœ¼ë¡œ ê³ ì •)
    - RULE-009: ì¢Œí‘œ ê·œì•½ (0~1000, bbox [ymin,xmin,ymax,xmax])

ì‚¬ìš© ì˜ˆì‹œ:
    # Gemini Structured Outputsìš© JSON Schema ìƒì„±
    schema = TurnOutput.model_json_schema()

    # ì‘ë‹µ ê²€ì¦
    output = TurnOutput.model_validate_json(gemini_response_text)

ì°¸ì¡°:
    - vibe/prd.md 8.7 (ë°ì´í„° ëª¨ë¸ ì„¤ê³„)
    - vibe/ref/structured-outputs-guide.md
    - .cursor/rules/00-core-critical.mdc
"""

from enum import Enum
from typing import Annotated

from pydantic import BaseModel, ConfigDict, Field

# =============================================================================
# ê³µí†µ Enum íƒ€ì…
# =============================================================================


class Language(str, Enum):
    """ì§€ì› ì–¸ì–´ (RULE-006).

    ko/en í˜¼í•© ì¶œë ¥ ê¸ˆì§€. TurnInput.languageë¥¼ SSOTë¡œ ì‚¼ì•„
    ëª¨ë“  UI/ë‚´ëŸ¬í‹°ë¸Œ/ì‹œìŠ¤í…œ ë©”ì‹œì§€ëŠ” ë™ì¼ ì–¸ì–´ë¡œ ê³ ì •í•©ë‹ˆë‹¤.
    """

    KO = "ko-KR"
    EN = "en-US"


class Theme(str, Enum):
    """í…Œë§ˆ ì„¤ì •."""

    DARK = "dark"
    LIGHT = "light"


class AgentPhase(str, Enum):
    """ì—ì´ì „íŠ¸ ì‹¤í–‰ ë‹¨ê³„ (RULE-008).

    ì—ì´ì „íŠ¸í˜• ì‹œìŠ¤í…œì„ì„ UIë¡œ ì¦ëª…í•˜ê¸° ìœ„í•œ ë‹¨ê³„ í‘œì‹œ.
    """

    PARSE = "parse"
    VALIDATE = "validate"
    PLAN = "plan"
    RESOLVE = "resolve"
    RENDER = "render"
    VERIFY = "verify"
    COMMIT = "commit"


class ValidationBadge(str, Enum):
    """ê²€ì¦ ë°°ì§€ (RULE-008).

    í„´ ê²°ê³¼ì— ëŒ€í•œ ê²€ì¦ ìƒíƒœë¥¼ í‘œì‹œí•©ë‹ˆë‹¤.
    """

    SCHEMA_OK = "schema_ok"
    SCHEMA_FAIL = "schema_fail"
    ECONOMY_OK = "economy_ok"
    ECONOMY_FAIL = "economy_fail"
    SAFETY_OK = "safety_ok"
    SAFETY_BLOCKED = "safety_blocked"
    CONSISTENCY_OK = "consistency_ok"
    CONSISTENCY_FAIL = "consistency_fail"


class ModelLabel(str, Enum):
    """ëª¨ë¸/í’ˆì§ˆ ì„ íƒ ë¼ë²¨ (RULE-008).

    í”„ë¡¬í”„íŠ¸ ë…¸ì¶œ ì—†ì´ "ì™œ ì´ ì„ íƒì´ì—ˆëŠ”ì§€"ë¥¼ ì‚¬ìš©ì ì¹œí™” ë¼ë²¨ë¡œ í‘œì‹œ.
    """

    FAST = "FAST"
    QUALITY = "QUALITY"
    CHEAP = "CHEAP"
    REF = "REF"


class RiskLevel(str, Enum):
    """í–‰ë™ ìœ„í—˜ë„ ìˆ˜ì¤€."""

    LOW = "low"
    MEDIUM = "medium"
    HIGH = "high"


# =============================================================================
# ê³µí†µ í•˜ìœ„ íƒ€ì…
# =============================================================================

# RULE-009: ì¢Œí‘œëŠ” 0~1000 ì •ê·œí™” ì¢Œí‘œê³„ (ì´ë¯¸ì§€ ì´í•´ bbox í¬ë§·ê³¼ í˜¸í™˜)
Coordinate = Annotated[int, Field(ge=0, le=1000, description="ì •ê·œí™” ì¢Œí‘œ (0~1000)")]


class Box2D(BaseModel):
    """2D ë°”ìš´ë”© ë°•ìŠ¤ (RULE-009).

    ì¢Œí‘œëŠ” 0~1000 ì •ê·œí™” ì¢Œí‘œê³„ì´ë©°, bboxëŠ” [ymin, xmin, ymax, xmax] ìˆœì„œì…ë‹ˆë‹¤.
    ì´ë¯¸ì§€ ì´í•´ bbox í¬ë§·ê³¼ í˜¸í™˜ë©ë‹ˆë‹¤.

    Attributes:
        ymin: Y ìµœì†Œê°’ (ìƒë‹¨)
        xmin: X ìµœì†Œê°’ (ì¢Œì¸¡)
        ymax: Y ìµœëŒ€ê°’ (í•˜ë‹¨)
        xmax: X ìµœëŒ€ê°’ (ìš°ì¸¡)
    """

    model_config = ConfigDict(extra="forbid")

    ymin: Coordinate
    xmin: Coordinate
    ymax: Coordinate
    xmax: Coordinate


class CurrencyAmount(BaseModel):
    """ì¬í™” ìˆ˜ëŸ‰.

    Attributes:
        signal: ê¸°ë³¸ ì¬í™” (í…ìŠ¤íŠ¸ í„´/ì´ë¯¸ì§€ ìƒì„±/ê³ ê¸‰ ê¸°ëŠ¥ì— ì†Œë¹„)
        memory_shard: í¬ê·€ ì¬í™” (ì¤‘ìš” ì„¤ì • ê³ ì •, ê³ í•´ìƒë„ ì´ë¯¸ì§€ ë“±ì— ì†Œë¹„)
    """

    model_config = ConfigDict(extra="forbid")

    signal: Annotated[int, Field(ge=0, description="ì‹œê·¸ë„ (ê¸°ë³¸ ì¬í™”, 0 ì´ìƒ)")]
    memory_shard: Annotated[int, Field(ge=0, description="ê¸°ì–µ íŒŒí¸ (í¬ê·€ ì¬í™”, 0 ì´ìƒ)")]


# =============================================================================
# TurnInput ê´€ë ¨ íƒ€ì…
# =============================================================================


class ClickInput(BaseModel):
    """í´ë¦­ ì…ë ¥ ì •ë³´.

    í™”ë©´ ì˜¤ë¸Œì íŠ¸ í´ë¦­ ì‹œ ì „ë‹¬ë˜ëŠ” ì •ë³´ì…ë‹ˆë‹¤.

    Attributes:
        object_id: í´ë¦­í•œ ì˜¤ë¸Œì íŠ¸ ID
        box_2d: í´ë¦­ ìœ„ì¹˜ì˜ ë°”ìš´ë”© ë°•ìŠ¤ (ì„ íƒ)
    """

    model_config = ConfigDict(extra="forbid")

    object_id: str = Field(description="í´ë¦­í•œ ì˜¤ë¸Œì íŠ¸ ID")
    box_2d: Box2D | None = Field(default=None, description="í´ë¦­ ìœ„ì¹˜ ë°”ìš´ë”© ë°•ìŠ¤ (ì„ íƒ)")


class ClientInfo(BaseModel):
    """í´ë¼ì´ì–¸íŠ¸ ì •ë³´.

    Attributes:
        viewport_w: ë·°í¬íŠ¸ ë„ˆë¹„ (í”½ì…€)
        viewport_h: ë·°í¬íŠ¸ ë†’ì´ (í”½ì…€)
        theme: í˜„ì¬ í…Œë§ˆ (dark/light)
    """

    model_config = ConfigDict(extra="forbid")

    viewport_w: Annotated[int, Field(gt=0, description="ë·°í¬íŠ¸ ë„ˆë¹„ (í”½ì…€)")]
    viewport_h: Annotated[int, Field(gt=0, description="ë·°í¬íŠ¸ ë†’ì´ (í”½ì…€)")]
    theme: Theme = Field(default=Theme.DARK, description="í˜„ì¬ í…Œë§ˆ")


class EconomySnapshot(BaseModel):
    """ì¬í™” ìŠ¤ëƒ…ìƒ· (í´ë¼ì´ì–¸íŠ¸ â†’ ì„œë²„).

    í´ë¼ì´ì–¸íŠ¸ê°€ ë³´ìœ í•œ í˜„ì¬ ì¬í™” ìƒíƒœì…ë‹ˆë‹¤.
    ì„œë²„ëŠ” ì´ë¥¼ ê²€ì¦í•˜ê³  ë¹„ìš© ê³„ì‚°ì— ì‚¬ìš©í•©ë‹ˆë‹¤.

    Attributes:
        signal: í˜„ì¬ ì‹œê·¸ë„ ì”ì•¡
        memory_shard: í˜„ì¬ ê¸°ì–µ íŒŒí¸ ì”ì•¡
    """

    model_config = ConfigDict(extra="forbid")

    signal: Annotated[int, Field(ge=0, description="í˜„ì¬ ì‹œê·¸ë„ ì”ì•¡ (0 ì´ìƒ)")]
    memory_shard: Annotated[int, Field(ge=0, description="í˜„ì¬ ê¸°ì–µ íŒŒí¸ ì”ì•¡ (0 ì´ìƒ)")]


class TurnInput(BaseModel):
    """í„´ ì…ë ¥ (í´ë¼ì´ì–¸íŠ¸ â†’ ì„œë²„).

    ì‚¬ìš©ìê°€ í„´ì„ ì§„í–‰í•  ë•Œ ì„œë²„ë¡œ ì „ì†¡í•˜ëŠ” ì…ë ¥ ë°ì´í„°ì…ë‹ˆë‹¤.

    Attributes:
        language: ìš”ì²­ ì–¸ì–´ (ì‘ë‹µë„ ë™ì¼ ì–¸ì–´ë¡œ ê³ ì •)
        text: ì‚¬ìš©ì ìì—°ì–´ ì…ë ¥
        action_id: ì„ íƒí•œ ì•¡ì…˜ ì¹´ë“œ ID (ì„ íƒ)
        click: ì˜¤ë¸Œì íŠ¸ í´ë¦­ ì •ë³´ (ì„ íƒ)
        client: í´ë¼ì´ì–¸íŠ¸ í™˜ê²½ ì •ë³´
        economy_snapshot: í˜„ì¬ ì¬í™” ìƒíƒœ

    Example:
        >>> input_data = TurnInput(
        ...     language=Language.KO,
        ...     text="ë¬¸ì„ ì—´ì–´ë³¸ë‹¤",
        ...     economy_snapshot=EconomySnapshot(signal=100, memory_shard=5),
        ...     client=ClientInfo(viewport_w=1920, viewport_h=1080),
        ... )
    """

    model_config = ConfigDict(extra="forbid")

    language: Language = Field(description="ìš”ì²­ ì–¸ì–´ (ì‘ë‹µë„ ë™ì¼ ì–¸ì–´ë¡œ ê³ ì •)")
    text: str = Field(default="", description="ì‚¬ìš©ì ìì—°ì–´ ì…ë ¥")
    action_id: str | None = Field(default=None, description="ì„ íƒí•œ ì•¡ì…˜ ì¹´ë“œ ID (ì„ íƒ)")
    click: ClickInput | None = Field(default=None, description="ì˜¤ë¸Œì íŠ¸ í´ë¦­ ì •ë³´ (ì„ íƒ)")
    client: ClientInfo = Field(description="í´ë¼ì´ì–¸íŠ¸ í™˜ê²½ ì •ë³´")
    economy_snapshot: EconomySnapshot = Field(description="í˜„ì¬ ì¬í™” ìƒíƒœ")


# =============================================================================
# TurnOutput ê´€ë ¨ íƒ€ì… - UI
# =============================================================================


class CostEstimate(BaseModel):
    """ë¹„ìš© ì¶”ì •ì¹˜ (ìµœì†Œ/ìµœëŒ€ ë²”ìœ„)."""

    model_config = ConfigDict(extra="forbid")

    min: CurrencyAmount = Field(description="ìµœì†Œ ì˜ˆìƒ ë¹„ìš©")
    max: CurrencyAmount = Field(description="ìµœëŒ€ ì˜ˆìƒ ë¹„ìš©")


class ActionCard(BaseModel):
    """ì•¡ì…˜ ì¹´ë“œ (Action Deck).

    ë§¤ í„´ AIê°€ ì¶”ì²œí•˜ëŠ” í–‰ë™ ì¹´ë“œì…ë‹ˆë‹¤.
    ê° ì¹´ë“œì— ë¹„ìš©/ìœ„í—˜/ë³´ìƒ íŒíŠ¸ê°€ í¬í•¨ë©ë‹ˆë‹¤.

    Attributes:
        id: ì¹´ë“œ ê³ ìœ  ID
        label: ì¹´ë“œ ë¼ë²¨ (í‘œì‹œìš©)
        description: ì¹´ë“œ ì„¤ëª… (ì„ íƒ)
        cost: ì˜ˆìƒ ë¹„ìš© (ê¸°ë³¸)
        cost_estimate: ë¹„ìš© ì¶”ì • ë²”ìœ„ (ì„ íƒ)
        risk: ìœ„í—˜ë„
        hint: ì˜ˆìƒ ê²°ê³¼ íŒíŠ¸ (ì„ íƒ)
        reward_hint: ë³´ìƒ íŒíŠ¸ (ì„ íƒ)
        enabled: ì‹¤í–‰ ê°€ëŠ¥ ì—¬ë¶€ (ì„œë²„ íŒë‹¨)
        disabled_reason: ë¹„í™œì„±í™” ì‚¬ìœ  (ì„ íƒ)
        is_alternative: ì €ë¹„ìš© ëŒ€ì•ˆ ì¹´ë“œ ì—¬ë¶€
    """

    model_config = ConfigDict(extra="forbid")

    id: str = Field(description="ì¹´ë“œ ê³ ìœ  ID")
    label: str = Field(description="ì¹´ë“œ ë¼ë²¨ (í‘œì‹œìš©)")
    description: str | None = Field(default=None, description="ì¹´ë“œ ì„¤ëª… (ì„ íƒ)")
    cost: CurrencyAmount = Field(description="ì˜ˆìƒ ë¹„ìš© (ê¸°ë³¸)")
    cost_estimate: CostEstimate | None = Field(default=None, description="ë¹„ìš© ì¶”ì • ë²”ìœ„ (ì„ íƒ)")
    risk: RiskLevel = Field(default=RiskLevel.LOW, description="ìœ„í—˜ë„")
    hint: str | None = Field(default=None, description="ì˜ˆìƒ ê²°ê³¼ íŒíŠ¸ (ì„ íƒ)")
    reward_hint: str | None = Field(default=None, description="ë³´ìƒ íŒíŠ¸ (ì„ íƒ)")
    enabled: bool = Field(default=True, description="ì‹¤í–‰ ê°€ëŠ¥ ì—¬ë¶€ (ì„œë²„ íŒë‹¨)")
    disabled_reason: str | None = Field(default=None, description="ë¹„í™œì„±í™” ì‚¬ìœ  (ì„ íƒ)")
    is_alternative: bool = Field(default=False, description="ì €ë¹„ìš© ëŒ€ì•ˆ ì¹´ë“œ ì—¬ë¶€")


class SceneObject(BaseModel):
    """ì¥ë©´ ì˜¤ë¸Œì íŠ¸ (í´ë¦­ ê°€ëŠ¥í•œ í•«ìŠ¤íŒŸ).

    í™”ë©´ì—ì„œ í´ë¦­ ê°€ëŠ¥í•œ ì˜¤ë¸Œì íŠ¸ì…ë‹ˆë‹¤.
    ì¢Œí‘œëŠ” 0~1000 ì •ê·œí™” ì¢Œí‘œê³„ë¥¼ ì‚¬ìš©í•©ë‹ˆë‹¤ (RULE-009).

    Attributes:
        id: ì˜¤ë¸Œì íŠ¸ ê³ ìœ  ID
        label: ì˜¤ë¸Œì íŠ¸ ë¼ë²¨ (í‘œì‹œìš©)
        box_2d: ë°”ìš´ë”© ë°•ìŠ¤ [ymin, xmin, ymax, xmax]
        interaction_hint: ìƒí˜¸ì‘ìš© íŒíŠ¸ (ì„ íƒ)
    """

    model_config = ConfigDict(extra="forbid")

    id: str = Field(description="ì˜¤ë¸Œì íŠ¸ ê³ ìœ  ID")
    label: str = Field(description="ì˜¤ë¸Œì íŠ¸ ë¼ë²¨ (í‘œì‹œìš©)")
    box_2d: Box2D = Field(description="ë°”ìš´ë”© ë°•ìŠ¤")
    interaction_hint: str | None = Field(default=None, description="ìƒí˜¸ì‘ìš© íŒíŠ¸ (ì„ íƒ)")


class ActionDeck(BaseModel):
    """ì•¡ì…˜ ë± (Q1 ê²°ì •: ui.action_deck.cards[] êµ¬ì¡°).

    ë§¤ í„´ AIê°€ ì œì‹œí•˜ëŠ” ì¶”ì²œ í–‰ë™ ì¹´ë“œ ë±ì…ë‹ˆë‹¤.

    Attributes:
        cards: ì•¡ì…˜ ì¹´ë“œ ëª©ë¡ (3~6ì¥ ê¶Œì¥)
    """

    model_config = ConfigDict(extra="forbid")

    cards: list[ActionCard] = Field(
        default=[],
        min_length=0,
        max_length=10,
        description="ì•¡ì…˜ ì¹´ë“œ ëª©ë¡ (3~6ì¥ ê¶Œì¥)",
    )


class UIOutput(BaseModel):
    """UI ì¶œë ¥ ë°ì´í„°.

    AIê°€ ìƒì„±í•œ UI ìš”ì†Œë“¤ì…ë‹ˆë‹¤.
    ì±„íŒ… ë²„ë¸”ì´ ì•„ë‹Œ ê²Œì„ UIë¡œ í‘œí˜„ë©ë‹ˆë‹¤ (RULE-002).

    Attributes:
        action_deck: ì•¡ì…˜ ì¹´ë“œ ë± (Q1 ê²°ì •: Option A ì±„íƒ)
        objects: í´ë¦­ ê°€ëŠ¥í•œ ì¥ë©´ ì˜¤ë¸Œì íŠ¸ ëª©ë¡
    """

    model_config = ConfigDict(extra="forbid")

    action_deck: ActionDeck = Field(default_factory=ActionDeck, description="ì•¡ì…˜ ì¹´ë“œ ë±")
    objects: list[SceneObject] = Field(default=[], description="í´ë¦­ ê°€ëŠ¥í•œ ì¥ë©´ ì˜¤ë¸Œì íŠ¸ ëª©ë¡")


# =============================================================================
# TurnOutput ê´€ë ¨ íƒ€ì… - World
# =============================================================================


class MemoryPin(BaseModel):
    """ì¤‘ìš” ì„¤ì • ê³ ì • í›„ë³´.

    ì‚¬ìš©ìê°€ Memory Shardë¥¼ ì†Œë¹„í•´ ê³ ì •í•  ìˆ˜ ìˆëŠ” ì¤‘ìš” ì„¤ì •ì…ë‹ˆë‹¤.

    Attributes:
        id: í•€ ê³ ìœ  ID
        content: ê³ ì •í•  ë‚´ìš©
        cost: ê³ ì •ì— í•„ìš”í•œ ë¹„ìš©
    """

    model_config = ConfigDict(extra="forbid")

    id: str = Field(description="í•€ ê³ ìœ  ID")
    content: str = Field(description="ê³ ì •í•  ë‚´ìš©")
    cost: CurrencyAmount = Field(description="ê³ ì •ì— í•„ìš”í•œ ë¹„ìš©")


class WorldRule(BaseModel):
    """ì„¸ê³„ ê·œì¹™ (Rule Board).

    í˜„ì¬ ì„¸ê³„ì— ì ìš© ì¤‘ì¸ ë¬¼ë¦¬ ë²•ì¹™ì´ë‚˜ ë©”íƒ€ ê·œì¹™ì…ë‹ˆë‹¤.

    Attributes:
        id: ê·œì¹™ ê³ ìœ  ID
        label: ê·œì¹™ ì´ë¦„
        description: ê·œì¹™ ìƒì„¸ ì„¤ëª… (ì„ íƒ)
    """

    model_config = ConfigDict(extra="forbid")

    id: str = Field(description="ê·œì¹™ ê³ ìœ  ID")
    label: str = Field(description="ê·œì¹™ ì´ë¦„")
    description: str | None = Field(default=None, description="ê·œì¹™ ìƒì„¸ ì„¤ëª… (ì„ íƒ)")


class Quest(BaseModel):
    """í€˜ìŠ¤íŠ¸/ëª©í‘œ (Quest Panel).

    í”Œë ˆì´ì–´ê°€ ë‹¬ì„±í•´ì•¼ í•˜ëŠ” í˜„ì¬ ëª©í‘œì…ë‹ˆë‹¤.

    Attributes:
        id: í€˜ìŠ¤íŠ¸ ê³ ìœ  ID
        label: í€˜ìŠ¤íŠ¸ ì´ë¦„
        is_completed: ë‹¬ì„± ì—¬ë¶€
    """

    model_config = ConfigDict(extra="forbid")

    id: str = Field(description="í€˜ìŠ¤íŠ¸ ê³ ìœ  ID")
    label: str = Field(description="í€˜ìŠ¤íŠ¸ ì´ë¦„")
    is_completed: bool = Field(default=False, description="ë‹¬ì„± ì—¬ë¶€")


class WorldDelta(BaseModel):
    """ì„¸ê³„ ìƒíƒœ ë³€í™” (Q2 ê²°ì •: Option A - delta ì¤‘ì‹¬).

    ì´ë²ˆ í„´ì—ì„œ ë³€ê²½ëœ ì„¸ê³„ ìƒíƒœë¥¼ ë‚˜íƒ€ëƒ…ë‹ˆë‹¤.
    snapshotì€ SaveGameì—ë§Œ ì €ì¥í•˜ê³ , ë§¤ í„´ì€ deltaë§Œ ì „ì†¡í•©ë‹ˆë‹¤.

    Attributes:
        rules_changed: ë³€ê²½ë˜ê±°ë‚˜ ì¶”ê°€ëœ ê·œì¹™ ëª©ë¡
        inventory_added: ì¶”ê°€ëœ ì¸ë²¤í† ë¦¬ ì•„ì´í…œ
        inventory_removed: ì œê±°ëœ ì¸ë²¤í† ë¦¬ ì•„ì´í…œ
        quests_updated: ì—…ë°ì´íŠ¸ëœ í€˜ìŠ¤íŠ¸(ëª©í‘œ) ëª©ë¡
        relationships_changed: ë³€ê²½ëœ ê´€ê³„
        memory_pins: ì¤‘ìš” ì„¤ì • ê³ ì • í›„ë³´
    """

    model_config = ConfigDict(extra="forbid")

    rules_changed: list[WorldRule] = Field(default=[], description="ë³€ê²½ëœ ê·œì¹™ ëª©ë¡")
    inventory_added: list[str] = Field(default=[], description="ì¶”ê°€ëœ ì¸ë²¤í† ë¦¬ ì•„ì´í…œ")
    inventory_removed: list[str] = Field(default=[], description="ì œê±°ëœ ì¸ë²¤í† ë¦¬ ì•„ì´í…œ")
    quests_updated: list[Quest] = Field(default=[], description="ì—…ë°ì´íŠ¸ëœ í€˜ìŠ¤íŠ¸/ëª©í‘œ ëª©ë¡")
    relationships_changed: list[str] = Field(default=[], description="ë³€ê²½ëœ ê´€ê³„")
    memory_pins: list[MemoryPin] = Field(default=[], description="ì¤‘ìš” ì„¤ì • ê³ ì • í›„ë³´")


# =============================================================================
# TurnOutput ê´€ë ¨ íƒ€ì… - Render
# =============================================================================


class ImageJob(BaseModel):
    """ì´ë¯¸ì§€ ìƒì„± ì‘ì—….

    ì¡°ê±´ë¶€ ì´ë¯¸ì§€ ìƒì„±/í¸ì§‘ ìš”ì²­ì…ë‹ˆë‹¤.
    ì´ë¯¸ì§€ ìƒì„±ì´ ëŠë¦´ ê²½ìš° í…ìŠ¤íŠ¸ ìš°ì„  ì¶œë ¥ + Lazy Loadingì„ ì‚¬ìš©í•©ë‹ˆë‹¤.

    Attributes:
        should_generate: ì´ë¯¸ì§€ë¥¼ ìƒì„±í•´ì•¼ í•˜ëŠ”ì§€
        prompt: ì´ë¯¸ì§€ ìƒì„± í”„ë¡¬í”„íŠ¸
        model_label: ëª¨ë¸ ì„ íƒ ë¼ë²¨ (FAST/QUALITY/CHEAP/REF)
        aspect_ratio: ê°€ë¡œì„¸ë¡œ ë¹„ìœ¨ (ì˜ˆ: "16:9", "1:1")
        image_size: ì´ë¯¸ì§€ í¬ê¸° (ì˜ˆ: "1024x1024")
        reference_image_ids: ì°¸ì¡° ì´ë¯¸ì§€ ID ëª©ë¡ (ì„ íƒ)
    """

    model_config = ConfigDict(extra="forbid")

    should_generate: bool = Field(description="ì´ë¯¸ì§€ë¥¼ ìƒì„±í•´ì•¼ í•˜ëŠ”ì§€")
    prompt: str = Field(default="", description="ì´ë¯¸ì§€ ìƒì„± í”„ë¡¬í”„íŠ¸")
    model_label: ModelLabel = Field(default=ModelLabel.FAST, description="ëª¨ë¸ ì„ íƒ ë¼ë²¨")
    aspect_ratio: str = Field(default="16:9", description="ê°€ë¡œì„¸ë¡œ ë¹„ìœ¨")
    image_size: str = Field(default="1024x1024", description="ì´ë¯¸ì§€ í¬ê¸°")
    reference_image_ids: list[str] = Field(default=[], description="ì°¸ì¡° ì´ë¯¸ì§€ ID ëª©ë¡ (ì„ íƒ)")


class RenderOutput(BaseModel):
    """ë Œë”ë§ ì¶œë ¥ ë°ì´í„°.

    ì´ë¯¸ì§€ ìƒì„±/í¸ì§‘ ê´€ë ¨ ì •ë³´ì…ë‹ˆë‹¤.

    Attributes:
        image_job: ì´ë¯¸ì§€ ìƒì„± ì‘ì—… (ì„ íƒ)
    """

    model_config = ConfigDict(extra="forbid")

    image_job: ImageJob | None = Field(default=None, description="ì´ë¯¸ì§€ ìƒì„± ì‘ì—… (ì„ íƒ)")


# =============================================================================
# TurnOutput ê´€ë ¨ íƒ€ì… - Economy
# =============================================================================


class EconomyOutput(BaseModel):
    """ê²½ì œ ì¶œë ¥ ë°ì´í„° (RULE-005).

    ì´ë²ˆ í„´ì˜ ë¹„ìš©ê³¼ ì”ì•¡ ì •ë³´ì…ë‹ˆë‹¤.
    ì”ì•¡ ìŒìˆ˜ëŠ” ì ˆëŒ€ ë¶ˆê°€ (ì„œë²„ Hard gate).

    Attributes:
        cost: ì´ë²ˆ í„´ì— ì†Œë¹„ëœ ë¹„ìš©
        balance_after: ì†Œë¹„ í›„ ì”ì•¡

    Important:
        - costì™€ balance_afterëŠ” í•­ìƒ í¬í•¨ë˜ì–´ì•¼ í•©ë‹ˆë‹¤.
        - balance_afterì˜ signalê³¼ memory_shardëŠ” 0 ì´ìƒì´ì–´ì•¼ í•©ë‹ˆë‹¤.
    """

    model_config = ConfigDict(extra="forbid")

    cost: CurrencyAmount = Field(description="ì´ë²ˆ í„´ì— ì†Œë¹„ëœ ë¹„ìš©")
    balance_after: CurrencyAmount = Field(description="ì†Œë¹„ í›„ ì”ì•¡")


# =============================================================================
# TurnOutput ê´€ë ¨ íƒ€ì… - Safety
# =============================================================================


class SafetyOutput(BaseModel):
    """ì•ˆì „ ì¶œë ¥ ë°ì´í„°.

    ì•ˆì „ ì •ì±… ê´€ë ¨ ì •ë³´ì…ë‹ˆë‹¤.
    ì°¨ë‹¨ ì‹œ ëª…ì‹œì  ë©”ì‹œì§€ì™€ í•¨ê»˜ ì•ˆì „í•œ ëŒ€ì²´ ê²°ê³¼ë¥¼ ì œê³µí•©ë‹ˆë‹¤.

    Attributes:
        blocked: ì•ˆì „ ì •ì±…ì— ì˜í•´ ì°¨ë‹¨ë˜ì—ˆëŠ”ì§€
        message: ì°¨ë‹¨ ì‹œ ì‚¬ìš©ìì—ê²Œ í‘œì‹œí•  ë©”ì‹œì§€ (ì„ íƒ)
    """

    model_config = ConfigDict(extra="forbid")

    blocked: bool = Field(default=False, description="ì•ˆì „ ì •ì±…ì— ì˜í•´ ì°¨ë‹¨ë˜ì—ˆëŠ”ì§€")
    message: str | None = Field(default=None, description="ì°¨ë‹¨ ì‹œ ì‚¬ìš©ìì—ê²Œ í‘œì‹œí•  ë©”ì‹œì§€ (ì„ íƒ)")


# =============================================================================
# TurnOutput ê´€ë ¨ íƒ€ì… - Agent Console
# =============================================================================


class AgentConsole(BaseModel):
    """ì—ì´ì „íŠ¸ ì½˜ì†” ë°ì´í„° (RULE-008).

    ì—ì´ì „íŠ¸í˜• ì‹œìŠ¤í…œì„ì„ UIë¡œ ì¦ëª…í•˜ê¸° ìœ„í•œ ì •ë³´ì…ë‹ˆë‹¤.
    ê³„íš/ì‹¤í–‰/ê²€ì¦/ë³µêµ¬ì˜ í”ì ì„ í‘œì‹œí•©ë‹ˆë‹¤.

    Attributes:
        current_phase: í˜„ì¬ ì‹¤í–‰ ë‹¨ê³„
        badges: ê²€ì¦ ë°°ì§€ ëª©ë¡
        repair_count: ìë™ ë³µêµ¬ ì‹œë„ íšŸìˆ˜
    """

    model_config = ConfigDict(extra="forbid")

    current_phase: AgentPhase = Field(default=AgentPhase.COMMIT, description="í˜„ì¬ ì‹¤í–‰ ë‹¨ê³„")
    badges: list[ValidationBadge] = Field(default=[], description="ê²€ì¦ ë°°ì§€ ëª©ë¡")
    repair_count: Annotated[int, Field(ge=0, description="ìë™ ë³µêµ¬ ì‹œë„ íšŸìˆ˜")] = 0


# =============================================================================
# TurnOutput (ë©”ì¸ ì‘ë‹µ ìŠ¤í‚¤ë§ˆ)
# =============================================================================


class TurnOutput(BaseModel):
    """í„´ ì¶œë ¥ (ì„œë²„ â†’ í´ë¼ì´ì–¸íŠ¸).

    ì„œë²„ê°€ í„´ ì²˜ë¦¬ í›„ í´ë¼ì´ì–¸íŠ¸ë¡œ ë°˜í™˜í•˜ëŠ” êµ¬ì¡°í™”ëœ ì‘ë‹µì…ë‹ˆë‹¤.
    Gemini Structured Outputs(JSON Schema)ë¡œ ê°•ì œë©ë‹ˆë‹¤.

    Hard Gate í•„ë“œ (RULE-003/004/005):
        - economy: costì™€ balance_after í•„ìˆ˜, ì”ì•¡ ìŒìˆ˜ ê¸ˆì§€
        - safety: blocked ì‹œ ì•ˆì „í•œ ëŒ€ì²´ ê²°ê³¼ ì œê³µ
        - language: ìš”ì²­ ì–¸ì–´ì™€ ë™ì¼í•˜ê²Œ ê³ ì • (í˜¼í•© ì¶œë ¥ ê¸ˆì§€)

    Attributes:
        language: ì‘ë‹µ ì–¸ì–´ (ìš”ì²­ê³¼ ë™ì¼)
        narrative: ë‚´ëŸ¬í‹°ë¸Œ í…ìŠ¤íŠ¸ (í‘œì‹œìš©)
        ui: UI ìš”ì†Œ (ì•¡ì…˜ ë±, ì˜¤ë¸Œì íŠ¸)
        world: ì„¸ê³„ ìƒíƒœ ë³€í™” (delta ì¤‘ì‹¬)
        render: ë Œë”ë§ ì •ë³´ (ì´ë¯¸ì§€ ìƒì„± ì‘ì—…)
        economy: ê²½ì œ ì •ë³´ (ë¹„ìš©, ì”ì•¡)
        safety: ì•ˆì „ ì •ì±… ì •ë³´
        agent_console: ì—ì´ì „íŠ¸ ì‹¤í–‰ ì •ë³´ (ë‹¨ê³„, ë°°ì§€, ë³µêµ¬ íšŸìˆ˜)

    Example:
        >>> output = TurnOutput(
        ...     language=Language.KO,
        ...     narrative="ë¬¸ì´ ì‚ê±±ê±°ë¦¬ë©° ì—´ë¦½ë‹ˆë‹¤...",
        ...     economy=EconomyOutput(
        ...         cost=CurrencyAmount(signal=5, memory_shard=0),
        ...         balance_after=CurrencyAmount(signal=95, memory_shard=5),
        ...     ),
        ...     safety=SafetyOutput(blocked=False),
        ... )
        >>> schema = TurnOutput.model_json_schema()

    Schema Generation:
        >>> # Gemini Structured Outputsìš© JSON Schema ìƒì„±
        >>> json_schema = TurnOutput.model_json_schema()
        >>> # response_json_schema íŒŒë¼ë¯¸í„°ì— ì „ë‹¬
        >>> config = {
        ...     "response_mime_type": "application/json",
        ...     "response_json_schema": json_schema,
        ... }
    """

    model_config = ConfigDict(extra="forbid")

    # í•„ìˆ˜ í•„ë“œ (Hard Gate)
    language: Language = Field(description="ì‘ë‹µ ì–¸ì–´ (ìš”ì²­ê³¼ ë™ì¼)")
    narrative: str = Field(description="ë‚´ëŸ¬í‹°ë¸Œ í…ìŠ¤íŠ¸ (í‘œì‹œìš©)")
    economy: EconomyOutput = Field(description="ê²½ì œ ì •ë³´ (ë¹„ìš©, ì”ì•¡)")
    safety: SafetyOutput = Field(description="ì•ˆì „ ì •ì±… ì •ë³´")

    # UI ê´€ë ¨ í•„ë“œ
    ui: UIOutput = Field(default_factory=UIOutput, description="UI ìš”ì†Œ")

    # ì„¸ê³„ ìƒíƒœ í•„ë“œ
    world: WorldDelta = Field(default_factory=WorldDelta, description="ì„¸ê³„ ìƒíƒœ ë³€í™” (delta)")

    # ë Œë”ë§ í•„ë“œ
    render: RenderOutput = Field(default_factory=RenderOutput, description="ë Œë”ë§ ì •ë³´")

    # ì—ì´ì „íŠ¸ ì½˜ì†” í•„ë“œ
    agent_console: AgentConsole = Field(
        default_factory=AgentConsole, description="ì—ì´ì „íŠ¸ ì‹¤í–‰ ì •ë³´"
    )
</file>

<file path="backend/tests/integration/test_turn_streaming.py">
"""Unknown World - /api/turn HTTP Streaming í†µí•© í…ŒìŠ¤íŠ¸.

NDJSON ìŠ¤íŠ¸ë¦¬ë° ì´ë²¤íŠ¸ì˜ ìˆœì„œ, êµ¬ì¡°, ë°ì´í„° ì •ë°€ë„ë¥¼ ê²€ì¦í•©ë‹ˆë‹¤.
"""

import json

from fastapi.testclient import TestClient

from unknown_world.main import app
from unknown_world.models.turn import Language, TurnOutput

client = TestClient(app)


def test_turn_streaming_success():
    """ì •ìƒì ì¸ í„´ ìš”ì²­ ì‹œ NDJSON ìŠ¤íŠ¸ë¦¼ì´ ì˜¬ë°”ë¥¸ ìˆœì„œë¡œ ë°˜í™˜ë˜ëŠ”ì§€ í…ŒìŠ¤íŠ¸í•©ë‹ˆë‹¤."""
    payload = {
        "language": "ko-KR",
        "text": "í…ŒìŠ¤íŠ¸ ì…ë ¥",
        "client": {"viewport_w": 1920, "viewport_h": 1080, "theme": "dark"},
        "economy_snapshot": {"signal": 100, "memory_shard": 5},
    }

    # StreamingResponse í…ŒìŠ¤íŠ¸
    response = client.post("/api/turn", json=payload)
    assert response.status_code == 200
    assert response.headers["content-type"] == "application/x-ndjson"

    events = []
    for line in response.iter_lines():
        if line:
            events.append(json.loads(line))

    # 1. ì´ë²¤íŠ¸ ì¡´ì¬ ì—¬ë¶€ í™•ì¸
    assert len(events) > 0

    # 2. ì²« ë²ˆì§¸ ì´ë²¤íŠ¸ëŠ” í•­ìƒ stage: parse: start ì—¬ì•¼ í•¨ (TTFB)
    assert events[0]["type"] == "stage"
    assert events[0]["name"] == "parse"
    assert events[0]["status"] == "start"

    # 3. ë‹¨ê³„ë³„ ì´ë²¤íŠ¸ ìˆœì„œ í™•ì¸
    stages = [e["name"] for e in events if e["type"] == "stage" and e["status"] == "start"]
    expected_stages = ["parse", "validate", "plan", "resolve", "render", "verify", "commit"]
    assert stages == expected_stages

    # 4. ë°°ì§€ ì´ë²¤íŠ¸ í¬í•¨ ì—¬ë¶€ í™•ì¸
    badges_events = [e for e in events if e["type"] == "badges"]
    assert len(badges_events) >= 2
    assert "schema_ok" in badges_events[0]["badges"]

    # 5. ìµœì¢… ê²°ê³¼ë¬¼ í™•ì¸
    final_events = [e for e in events if e["type"] == "final"]
    assert len(final_events) == 1

    turn_output_data = final_events[0]["data"]
    # Pydantic ëª¨ë¸ë¡œ ë‹¤ì‹œ ê²€ì¦ (RULE-003)
    turn_output = TurnOutput.model_validate(turn_output_data)
    assert turn_output.language == Language.KO
    assert len(turn_output.narrative) > 0


def test_turn_streaming_invalid_input():
    """ì˜ëª»ëœ ì…ë ¥ ìš”ì²­ ì‹œ ì—ëŸ¬ ì´ë²¤íŠ¸ê°€ ìŠ¤íŠ¸ë¦¬ë°ë˜ëŠ”ì§€ í…ŒìŠ¤íŠ¸í•©ë‹ˆë‹¤."""
    payload = {
        "language": "invalid-lang",  # ì˜ëª»ëœ ì–¸ì–´ ì½”ë“œ
        "text": "",
    }

    response = client.post("/api/turn", json=payload)
    # ì…ë ¥ ê²€ì¦ ì‹¤íŒ¨ ì‹œì—ë„ 200 OK ìŠ¤íŠ¸ë¦¼ìœ¼ë¡œ ì—ëŸ¬ë¥¼ ë³´ë‚¼ ìˆ˜ë„ ìˆê³ ,
    # 400 Bad Requestë¥¼ ë³´ë‚¼ ìˆ˜ë„ ìˆìŒ. í˜„ì¬ êµ¬í˜„ì€ 200 OK + type: error ì„.
    assert response.status_code == 200

    events = [json.loads(line) for line in response.iter_lines() if line]
    assert any(e["type"] == "error" for e in events)
    assert any(e["code"] == "VALIDATION_ERROR" for e in events)


def test_turn_streaming_deterministic_seed():
    """seed íŒŒë¼ë¯¸í„° ì‚¬ìš© ì‹œ ê²°ê³¼ê°€ ê²°ì •ì ì¸ì§€ í…ŒìŠ¤íŠ¸í•©ë‹ˆë‹¤."""
    payload = {
        "language": "en-US",
        "text": "Hello",
        "client": {"viewport_w": 1920, "viewport_h": 1080},
        "economy_snapshot": {"signal": 100, "memory_shard": 5},
    }

    # ë™ì¼í•œ ì‹œë“œë¡œ ë‘ ë²ˆ ìš”ì²­
    seed = 12345

    def get_final_output(s):
        resp = client.post(f"/api/turn?seed={s}", json=payload)
        events = [json.loads(line) for line in resp.iter_lines() if line]
        return next(e["data"] for e in events if e["type"] == "final")

    output1 = get_final_output(seed)
    output2 = get_final_output(seed)

    assert output1 == output2
    assert output1["language"] == "en-US"


def test_turn_streaming_generation_fallback(monkeypatch):
    """ìƒì„± ì¤‘ ValidationError ë°œìƒ ì‹œ ì•ˆì „í•œ í´ë°±ì´ ë°˜í™˜ë˜ëŠ”ì§€ í…ŒìŠ¤íŠ¸í•©ë‹ˆë‹¤."""
    from pydantic import ValidationError

    from unknown_world.orchestrator.mock import MockOrchestrator

    def mock_generate_failure(self, turn_input):
        # Pydantic ValidationErrorë¥¼ ìˆ˜ë™ìœ¼ë¡œ ìƒì„±í•˜ëŠ” ê²ƒì€ ë³µì¡í•˜ë¯€ë¡œ
        # ê°„ë‹¨í•œ í•„ë“œ ê²€ì¦ ì˜¤ë¥˜ë¥¼ ì‹œë®¬ë ˆì´ì…˜í•˜ê±°ë‚˜ ì§ì ‘ raise í•¨
        # ì—¬ê¸°ì„œëŠ” í…ŒìŠ¤íŠ¸ë¥¼ ìœ„í•´ ì„ì˜ì˜ í•„ë“œ ëˆ„ë½ ë“±ìœ¼ë¡œ ë°œìƒí•œë‹¤ê³  ê°€ì •
        raise ValidationError.from_exception_data(title="MockError", line_errors=[])

    monkeypatch.setattr(MockOrchestrator, "generate_turn_output", mock_generate_failure)

    payload = {
        "language": "ko-KR",
        "text": "í…ŒìŠ¤íŠ¸",
        "client": {"viewport_w": 1920, "viewport_h": 1080},
        "economy_snapshot": {"signal": 100, "memory_shard": 5},
    }

    response = client.post("/api/turn", json=payload)
    events = [json.loads(line) for line in response.iter_lines() if line]

    final_event = next(e for e in events if e["type"] == "final")
    turn_output = final_event["data"]

    # í´ë°± ì‘ë‹µì˜ íŠ¹ì§• í™•ì¸
    assert turn_output["agent_console"]["badges"] == ["schema_fail"]
    assert turn_output["agent_console"]["repair_count"] == 1
    assert "í˜¼ë€" in turn_output["narrative"] or "confusion" in turn_output["narrative"]


def test_turn_streaming_repair_loop(monkeypatch):
    """ê²€ì¦ ì‹¤íŒ¨ ì‹œ repair ì´ë²¤íŠ¸ê°€ ìŠ¤íŠ¸ë¦¼ì— í¬í•¨ë˜ëŠ”ì§€ í…ŒìŠ¤íŠ¸í•©ë‹ˆë‹¤ (RU-002)."""
    from pydantic import ValidationError

    from unknown_world.orchestrator.mock import MockOrchestrator

    # ì²« ë²ˆì§¸ í˜¸ì¶œì—ì„œ ì‹¤íŒ¨í•˜ì—¬ repair íŠ¸ë¦¬ê±° ì‹œë®¬ë ˆì´ì…˜
    # (ì‹¤ì œ êµ¬í˜„ì—ì„œëŠ” NíšŒ ì¬ì‹œë„ ë¡œì§ì´ turn.pyì— ìˆì–´ì•¼ í•¨)
    call_count = 0

    def mock_generate_with_repair(self, turn_input):
        nonlocal call_count
        call_count += 1
        if call_count == 1:
            raise ValidationError.from_exception_data(title="MockSchemaError", line_errors=[])
        return orchestrator_orig_generate(self, turn_input)

    import unknown_world.orchestrator.mock as mock_mod

    orchestrator_orig_generate = mock_mod.MockOrchestrator.generate_turn_output
    monkeypatch.setattr(MockOrchestrator, "generate_turn_output", mock_generate_with_repair)

    payload = {
        "language": "ko-KR",
        "text": "ë¦¬í˜ì–´ í…ŒìŠ¤íŠ¸",
        "client": {"viewport_w": 1920, "viewport_h": 1080},
        "economy_snapshot": {"signal": 100, "memory_shard": 5},
    }

    response = client.post("/api/turn", json=payload)
    events = [json.loads(line) for line in response.iter_lines() if line]

    # RU-002 ìš”êµ¬ì‚¬í•­: repair ì´ë²¤íŠ¸ê°€ ëª…ì‹œì ìœ¼ë¡œ ì¡´ì¬í•´ì•¼ í•¨
    repair_events = [e for e in events if e["type"] == "repair"]
    assert len(repair_events) >= 1
    assert "attempt" in repair_events[0]
    assert repair_events[0]["attempt"] == 1
</file>

<file path="backend/tests/unit/test_u034_verification.py">
import json
from pathlib import Path

# í”„ë¡œì íŠ¸ ë£¨íŠ¸ ê²½ë¡œ ì„¤ì • (backend/tests/unit/ ìœ„ì¹˜ ê¸°ì¤€)
ROOT_DIR = Path(__file__).parent.parent.parent.parent
SCHEMA_PATH = ROOT_DIR / "vibe/ref/nanobanana-asset-request.schema.json"
GUIDE_PATH = ROOT_DIR / "vibe/ref/nanobanana-mcp.md"


def test_schema_file_exists():
    """ìŠ¤í‚¤ë§ˆ íŒŒì¼ì´ ì§€ì •ëœ ìœ„ì¹˜ì— ì¡´ì¬í•˜ëŠ”ì§€ í™•ì¸"""
    assert SCHEMA_PATH.exists(), f"Schema file not found at {SCHEMA_PATH}"


def test_schema_is_valid_json():
    """ìŠ¤í‚¤ë§ˆ íŒŒì¼ì´ ìœ íš¨í•œ JSON í˜•ì‹ì¸ì§€ í™•ì¸"""
    with open(SCHEMA_PATH, encoding="utf-8") as f:
        schema = json.load(f)
    assert schema["title"] == "nanobanana mcp Asset Request Schema"


def test_schema_required_properties():
    """ê³„íšì„œì— ëª…ì‹œëœ í•„ìˆ˜ í•„ë“œê°€ ìŠ¤í‚¤ë§ˆì— ì •ì˜ë˜ì–´ ìˆëŠ”ì§€ í™•ì¸"""
    with open(SCHEMA_PATH, encoding="utf-8") as f:
        schema = json.load(f)

    properties = schema.get("properties", {})
    required_fields = ["id", "category", "purpose", "size_px", "requires_rembg", "rembg_model"]

    for field in required_fields:
        assert field in properties, f"Required field '{field}' missing in schema properties"


def test_guide_file_exists():
    """ê°€ì´ë“œ ë¬¸ì„œ íŒŒì¼ì´ ì¡´ì¬í•˜ëŠ”ì§€ í™•ì¸"""
    assert GUIDE_PATH.exists(), f"Guide file not found at {GUIDE_PATH}"


def test_guide_content_completeness():
    """ê°€ì´ë“œ ë¬¸ì„œì— í•„ìˆ˜ ì„¹ì…˜(ì•„íŠ¸ ë””ë ‰ì…˜, ì¹´í…Œê³ ë¦¬ë³„ í…œí”Œë¦¿)ì´ í¬í•¨ë˜ì–´ ìˆëŠ”ì§€ í™•ì¸"""
    with open(GUIDE_PATH, encoding="utf-8") as f:
        content = f.read()

    # ê³„íšì„œ êµ¬í˜„ íë¦„ 2ë‹¨ê³„, 3ë‹¨ê³„ ê´€ë ¨ í‚¤ì›Œë“œ ê²€ì‚¬
    required_keywords = ["ì•„íŠ¸ ë””ë ‰ì…˜", "ìŠ¤íƒ€ì¼", "ì•„ì´ì½˜", "placeholder", "chrome", "í…œí”Œë¦¿"]

    missing_keywords = [kw for kw in required_keywords if kw.lower() not in content.lower()]

    # í˜„ì¬ nanobanana-mcp.mdì—ëŠ” rembg ë‚´ìš©ë§Œ ìˆìœ¼ë¯€ë¡œ ì‹¤íŒ¨í•  ê°€ëŠ¥ì„±ì´ í¼
    assert not missing_keywords, (
        f"Guide document is missing sections for: {', '.join(missing_keywords)}"
    )


def test_schema_rembg_rules():
    """ë°°ê²½ ì œê±°(rembg) ê´€ë ¨ ê°•ì œ ê·œì¹™(ìˆœë°± ë°°ê²½)ì´ ìŠ¤í‚¤ë§ˆ/ì„¤ëª…ì— í¬í•¨ë˜ì–´ ìˆëŠ”ì§€ í™•ì¸"""
    with open(SCHEMA_PATH, encoding="utf-8") as f:
        schema = json.load(f)

    # background í•„ë“œì™€ requires_rembg í•„ë“œ ì„¤ëª… í™•ì¸
    background_desc = schema["properties"]["background"].get("description", "")
    rembg_desc = schema["properties"]["requires_rembg"].get("description", "")

    assert "solid_white" in str(schema["properties"]["background"].get("enum", [])), (
        "background enum should include solid_white"
    )
    assert "rembg" in background_desc.lower(), "background description should mention rembg"
    assert "solid_white" in rembg_desc.lower(), (
        "requires_rembg description should recommend solid_white"
    )
</file>

<file path="frontend/public/ui/manifest.schema.json">
{
  "$schema": "http://json-schema.org/draft-07/schema#",
  "$id": "https://unknown-world.dev/schemas/ui-asset-manifest.json",
  "title": "UI Asset Manifest",
  "description": "nanobanana mcpë¡œ ì œì‘ëœ UI ì—ì…‹ì˜ ë§¤ë‹ˆí˜ìŠ¤íŠ¸ ìŠ¤í‚¤ë§ˆ",
  "type": "object",
  "required": ["version", "assets"],
  "additionalProperties": false,
  "properties": {
    "$schema": {
      "type": "string",
      "description": "JSON Schema ì°¸ì¡°"
    },
    "version": {
      "type": "string",
      "pattern": "^\\d+\\.\\d+\\.\\d+$",
      "description": "ë§¤ë‹ˆí˜ìŠ¤íŠ¸ ë²„ì „ (SemVer)",
      "examples": ["1.0.0"]
    },
    "generatedAt": {
      "type": "string",
      "format": "date-time",
      "description": "ë§¤ë‹ˆí˜ìŠ¤íŠ¸ ìƒì„± ì‹œê° (ISO 8601)"
    },
    "totalBytes": {
      "type": "integer",
      "minimum": 0,
      "description": "ëª¨ë“  ì—ì…‹ì˜ ì´ ë°”ì´íŠ¸ ìˆ˜"
    },
    "budgetBytes": {
      "type": "integer",
      "minimum": 0,
      "default": 1572864,
      "description": "ì„±ëŠ¥ ì˜ˆì‚° ìƒí•œ (ê¸°ë³¸: 1.5MB = 1572864 bytes)"
    },
    "assets": {
      "type": "array",
      "description": "ì—ì…‹ ëª©ë¡",
      "items": {
        "$ref": "#/$defs/Asset"
      }
    }
  },
  "$defs": {
    "Asset": {
      "type": "object",
      "required": ["id", "path", "type"],
      "additionalProperties": false,
      "properties": {
        "id": {
          "type": "string",
          "pattern": "^[a-z0-9]+(-[a-z0-9]+)*$",
          "description": "ì—ì…‹ ê³ ìœ  ID (kebab-case)",
          "examples": ["signal-24", "badge-ok-16", "scene-loading"]
        },
        "path": {
          "type": "string",
          "pattern": "^[a-z0-9-/]+\\.(png|webp|svg)$",
          "description": "ui/ ë””ë ‰í† ë¦¬ ê¸°ì¤€ ìƒëŒ€ ê²½ë¡œ",
          "examples": ["icons/signal-24.png", "placeholders/scene-loading.webp"]
        },
        "type": {
          "type": "string",
          "enum": ["icon", "placeholder", "chrome"],
          "description": "ì—ì…‹ ìœ í˜•"
        },
        "size": {
          "type": "integer",
          "enum": [16, 24, 32, 64, 128, 256, 512],
          "description": "í”½ì…€ ì‚¬ì´ì¦ˆ (ì•„ì´ì½˜ìš©)"
        },
        "width": {
          "type": "integer",
          "minimum": 1,
          "description": "ê°€ë¡œ í”½ì…€ (placeholder/chromeìš©)"
        },
        "height": {
          "type": "integer",
          "minimum": 1,
          "description": "ì„¸ë¡œ í”½ì…€ (placeholder/chromeìš©)"
        },
        "fallback": {
          "type": "string",
          "maxLength": 10,
          "description": "ë¡œë”© ì‹¤íŒ¨ ì‹œ ëŒ€ì²´ ì´ëª¨ì§€/í…ìŠ¤íŠ¸",
          "examples": ["ğŸ“¡", "âš ï¸", "OK"]
        },
        "usedIn": {
          "type": "array",
          "items": {
            "type": "string"
          },
          "description": "ì‚¬ìš©ì²˜ ì»´í¬ë„ŒíŠ¸ ëª©ë¡",
          "examples": [["EconomyHUD", "AgentConsole"]]
        },
        "bytes": {
          "type": "integer",
          "minimum": 0,
          "description": "íŒŒì¼ í¬ê¸° (bytes)"
        },
        "format": {
          "type": "string",
          "enum": ["png", "webp", "svg"],
          "description": "íŒŒì¼ í¬ë§·"
        },
        "retina": {
          "type": "boolean",
          "default": false,
          "description": "@2x Retina ë²„ì „ ì¡´ì¬ ì—¬ë¶€"
        },
        "description": {
          "type": "string",
          "maxLength": 200,
          "description": "ì—ì…‹ ì„¤ëª…"
        },
        "createdAt": {
          "type": "string",
          "format": "date-time",
          "description": "ìƒì„± ì‹œê° (ISO 8601)"
        },
        "promptHash": {
          "type": "string",
          "pattern": "^[a-f0-9]{8}$",
          "description": "ìƒì„± í”„ë¡¬í”„íŠ¸ í•´ì‹œ (ì¬í˜„ì„±, 8ì)"
        },
        "notes": {
          "type": "string",
          "maxLength": 500,
          "description": "ì—ì…‹ ê´€ë ¨ ë©”ëª¨ (ìƒì„± ë„êµ¬, ë°°ê²½ ì œê±°, ìµœì í™” ë“± QA ê´€ë ¨ ê¸°ë¡)"
        }
      }
    }
  }
}
</file>

<file path="frontend/src/components/AgentConsole.test.tsx">
import { describe, it, expect, vi } from 'vitest';
import { render, screen } from '@testing-library/react';
import { AgentConsole } from './AgentConsole';

// Mock i18n
vi.mock('react-i18next', () => ({
  useTranslation: () => ({
    t: (key: string) => key,
  }),
}));

// Mock dependencies
type MockSelector<T> = (state: unknown) => T;

vi.mock('../stores/agentStore', () => ({
  useAgentStore: <T,>(selector: MockSelector<T>) =>
    selector({
      phases: [],
      badges: [],
      repairCount: 0,
      error: null,
      isStreaming: false,
    }),
  selectIsStreaming: (state: { isStreaming: boolean }) => state.isStreaming,
  selectPhases: (state: { phases: unknown[] }) => state.phases,
  selectBadges: (state: { badges: unknown[] }) => state.badges,
  selectRepairCount: (state: { repairCount: number }) => state.repairCount,
  selectError: (state: { error: unknown }) => state.error,
}));

describe('AgentConsole (U-037)', () => {
  it('should render with "critical" importance attribute', () => {
    const { container } = render(<AgentConsole />);

    // The root element of AgentConsole should have data-ui-importance="critical"
    const consoleElement = container.firstChild as HTMLElement;

    expect(consoleElement).toHaveAttribute('data-ui-importance', 'critical');
  });

  it('should render streaming status', () => {
    render(<AgentConsole />);
    // Verify that the correct i18n key is used
    expect(screen.getByText('agent.console.status.idle')).toBeInTheDocument();
  });
});
</file>

<file path="frontend/src/i18n.ts">
/**
 * Unknown World - i18n ì´ˆê¸°í™” ëª¨ë“ˆ
 *
 * ì–¸ì–´ ë¦¬ì†ŒìŠ¤ë¥¼ JSON íŒŒì¼ êµ¬ì¡°ë¡œ ê´€ë¦¬í•©ë‹ˆë‹¤.
 * RULE-006 ì¤€ìˆ˜: ko/en í˜¼í•© ì¶œë ¥ ê¸ˆì§€, i18n í‚¤ ê¸°ë°˜ SSOT
 *
 * ì–¸ì–´ ì½”ë“œ: BCP-47 í˜•ì‹ (ko-KR, en-US)
 * - TurnInput/SaveGameì˜ language í•„ë“œì™€ ë™ì¼í•œ ì¶•
 *
 * @see vibe/prd.md 3.1(ì§€ì› ì–¸ì–´), 8.7(TurnInput.language)
 * @see frontend/src/locales/README.md
 */

import i18n from 'i18next';
import { initReactI18next } from 'react-i18next';

// JSON ì–¸ì–´ ë¦¬ì†ŒìŠ¤ import (SSOT: locales/{lang}/translation.json)
import koKR from './locales/ko-KR/translation.json';
import enUS from './locales/en-US/translation.json';

/** ì§€ì› ì–¸ì–´ íƒ€ì… (TurnInput.languageì™€ ë™ê¸°í™”) */
export type SupportedLanguage = 'ko-KR' | 'en-US';

/** ê¸°ë³¸ ì–¸ì–´ (ë°ëª¨ ì¼ê´€ì„±ì„ ìœ„í•´ ko-KR ê³ ì •) */
export const DEFAULT_LANGUAGE: SupportedLanguage = 'ko-KR';

/** í´ë°± ì–¸ì–´ */
export const FALLBACK_LANGUAGE: SupportedLanguage = 'en-US';

/** ì§€ì› ì–¸ì–´ ëª©ë¡ */
export const SUPPORTED_LANGUAGES: SupportedLanguage[] = ['ko-KR', 'en-US'];

// i18n ë¦¬ì†ŒìŠ¤ ì •ì˜ (BCP-47 í˜•ì‹ ì–¸ì–´ ì½”ë“œ)
const resources = {
  'ko-KR': {
    translation: koKR,
  },
  'en-US': {
    translation: enUS,
  },
};

i18n.use(initReactI18next).init({
  resources,
  lng: DEFAULT_LANGUAGE,
  fallbackLng: FALLBACK_LANGUAGE,
  supportedLngs: SUPPORTED_LANGUAGES,
  interpolation: {
    escapeValue: false, // Reactì—ì„œ ì´ë¯¸ XSS ë°©ì§€
  },
  // ëˆ„ë½ í‚¤ ì²˜ë¦¬ (ê°œë°œ ëª¨ë“œì—ì„œ ê²½ê³ )
  saveMissing: false,
  missingKeyHandler: (_lngs, _ns, key) => {
    if (import.meta.env.DEV) {
      console.warn(`[i18n] Missing translation key: "${key}"`);
    }
  },
});

/**
 * í˜„ì¬ í•´ê²°ëœ ì–¸ì–´ ì½”ë“œë¥¼ ë°˜í™˜í•©ë‹ˆë‹¤.
 * TurnInput.languageì™€ ë™ê¸°í™”í•  ë•Œ ì‚¬ìš©í•©ë‹ˆë‹¤.
 */
export function getResolvedLanguage(): SupportedLanguage {
  return (i18n.resolvedLanguage as SupportedLanguage) || DEFAULT_LANGUAGE;
}

/**
 * ì–¸ì–´ë¥¼ ë³€ê²½í•©ë‹ˆë‹¤.
 * í–¥í›„ U-036 ì™„ë£Œ í›„ ì‚¬ìš©ìì—ê²Œ ë…¸ì¶œí•  í† ê¸€ì—ì„œ ì‚¬ìš©í•©ë‹ˆë‹¤.
 */
export async function changeLanguage(lang: SupportedLanguage): Promise<void> {
  await i18n.changeLanguage(lang);
}

export default i18n;
</file>

<file path="frontend/src/main.tsx">
import { StrictMode } from 'react';
import { createRoot } from 'react-dom/client';
import './i18n'; // i18n ì´ˆê¸°í™”
import './style.css';
import App from './App.tsx';

createRoot(document.getElementById('root')!).render(
  <StrictMode>
    <App />
  </StrictMode>,
);
</file>

<file path="frontend/src/schemas/turn.ts">
/**
 * Unknown World - TurnInput/TurnOutput Zod ìŠ¤í‚¤ë§ˆ.
 *
 * ì´ ëª¨ë“ˆì€ ë°±ì—”ë“œ Pydantic ëª¨ë¸(U-005)ê³¼ 1:1 ëŒ€ì‘í•˜ëŠ” Zod ìŠ¤í‚¤ë§ˆë¥¼ ì •ì˜í•©ë‹ˆë‹¤.
 * í´ë¼ì´ì–¸íŠ¸ ì¸¡ ê²€ì¦ ë° íƒ€ì… ì•ˆì „ì„±ì„ ì œê³µí•©ë‹ˆë‹¤.
 *
 * ì„¤ê³„ ì›ì¹™:
 *   - RULE-003: êµ¬ì¡°í™” ì¶œë ¥(JSON Schema) ìš°ì„  + ì´ì¤‘ ê²€ì¦ (ì„œë²„ Pydantic + í´ë¼ Zod)
 *   - RULE-004: ê²€ì¦ ì‹¤íŒ¨ ì‹œ ì•ˆì „ í´ë°± ì œê³µ (UI ë©ˆì¶¤ ë°©ì§€)
 *   - RULE-005: ì¬í™” ì¸ë°”ë¦¬ì–¸íŠ¸ (cost, balance_after í•„ìˆ˜, ì”ì•¡ ìŒìˆ˜ ê¸ˆì§€)
 *   - RULE-006: ko/en ì–¸ì–´ ì •ì±… (Language enumìœ¼ë¡œ ê³ ì •)
 *   - RULE-009: ì¢Œí‘œ ê·œì•½ (0~1000, bbox [ymin,xmin,ymax,xmax])
 *
 * Q1 ê²°ì • ì‚¬í•­:
 *   - schema_version í¬í•¨ (Option A): SaveGame/ë§ˆì´ê·¸ë ˆì´ì…˜/ê²€ì¦ì— ìœ ë¦¬
 *
 * @module schemas/turn
 */

import { z } from 'zod';

// =============================================================================
// ìŠ¤í‚¤ë§ˆ ë²„ì „ (Q1 ê²°ì •: Option A - í¬í•¨)
// =============================================================================

/**
 * í˜„ì¬ ìŠ¤í‚¤ë§ˆ ë²„ì „.
 * SaveGame/ë§ˆì´ê·¸ë ˆì´ì…˜/ê²€ì¦ì— ì‚¬ìš©ë©ë‹ˆë‹¤.
 */
export const SCHEMA_VERSION = '1.0.0' as const;

// =============================================================================
// ê³µí†µ Enum íƒ€ì…
// =============================================================================

/**
 * ì§€ì› ì–¸ì–´ (RULE-006).
 * ko/en í˜¼í•© ì¶œë ¥ ê¸ˆì§€. TurnInput.languageë¥¼ SSOTë¡œ ì‚¼ì•„
 * ëª¨ë“  UI/ë‚´ëŸ¬í‹°ë¸Œ/ì‹œìŠ¤í…œ ë©”ì‹œì§€ëŠ” ë™ì¼ ì–¸ì–´ë¡œ ê³ ì •í•©ë‹ˆë‹¤.
 */
export const LanguageSchema = z.enum(['ko-KR', 'en-US']);
export type Language = z.infer<typeof LanguageSchema>;

/**
 * í…Œë§ˆ ì„¤ì •.
 */
export const ThemeSchema = z.enum(['dark', 'light']);
export type Theme = z.infer<typeof ThemeSchema>;

/**
 * ì—ì´ì „íŠ¸ ì‹¤í–‰ ë‹¨ê³„ (RULE-008).
 * ì—ì´ì „íŠ¸í˜• ì‹œìŠ¤í…œì„ì„ UIë¡œ ì¦ëª…í•˜ê¸° ìœ„í•œ ë‹¨ê³„ í‘œì‹œ.
 */
export const AgentPhaseSchema = z.enum([
  'parse',
  'validate',
  'plan',
  'resolve',
  'render',
  'verify',
  'commit',
]);
export type AgentPhase = z.infer<typeof AgentPhaseSchema>;

/**
 * ê²€ì¦ ë°°ì§€ (RULE-008).
 * í„´ ê²°ê³¼ì— ëŒ€í•œ ê²€ì¦ ìƒíƒœë¥¼ í‘œì‹œí•©ë‹ˆë‹¤.
 */
export const ValidationBadgeSchema = z.enum([
  'schema_ok',
  'schema_fail',
  'economy_ok',
  'economy_fail',
  'safety_ok',
  'safety_blocked',
  'consistency_ok',
  'consistency_fail',
]);
export type ValidationBadge = z.infer<typeof ValidationBadgeSchema>;

/**
 * ëª¨ë¸/í’ˆì§ˆ ì„ íƒ ë¼ë²¨ (RULE-008).
 * í”„ë¡¬í”„íŠ¸ ë…¸ì¶œ ì—†ì´ "ì™œ ì´ ì„ íƒì´ì—ˆëŠ”ì§€"ë¥¼ ì‚¬ìš©ì ì¹œí™” ë¼ë²¨ë¡œ í‘œì‹œ.
 */
export const ModelLabelSchema = z.enum(['FAST', 'QUALITY', 'CHEAP', 'REF']);
export type ModelLabel = z.infer<typeof ModelLabelSchema>;

/**
 * í–‰ë™ ìœ„í—˜ë„ ìˆ˜ì¤€.
 */
export const RiskLevelSchema = z.enum(['low', 'medium', 'high']);
export type RiskLevel = z.infer<typeof RiskLevelSchema>;

// =============================================================================
// ê³µí†µ í•˜ìœ„ íƒ€ì…
// =============================================================================

/**
 * ì •ê·œí™” ì¢Œí‘œ (RULE-009).
 * 0~1000 ë²”ìœ„ì˜ ì •ìˆ˜ì…ë‹ˆë‹¤.
 */
export const CoordinateSchema = z.number().int().min(0).max(1000).describe('ì •ê·œí™” ì¢Œí‘œ (0~1000)');
export type Coordinate = z.infer<typeof CoordinateSchema>;

/**
 * 2D ë°”ìš´ë”© ë°•ìŠ¤ (RULE-009).
 * ì¢Œí‘œëŠ” 0~1000 ì •ê·œí™” ì¢Œí‘œê³„ì´ë©°, bboxëŠ” [ymin, xmin, ymax, xmax] ìˆœì„œì…ë‹ˆë‹¤.
 * ì´ë¯¸ì§€ ì´í•´ bbox í¬ë§·ê³¼ í˜¸í™˜ë©ë‹ˆë‹¤.
 */
export const Box2DSchema = z
  .object({
    ymin: CoordinateSchema.describe('Y ìµœì†Œê°’ (ìƒë‹¨)'),
    xmin: CoordinateSchema.describe('X ìµœì†Œê°’ (ì¢Œì¸¡)'),
    ymax: CoordinateSchema.describe('Y ìµœëŒ€ê°’ (í•˜ë‹¨)'),
    xmax: CoordinateSchema.describe('X ìµœëŒ€ê°’ (ìš°ì¸¡)'),
  })
  .strict();
export type Box2D = z.infer<typeof Box2DSchema>;

/**
 * ì¬í™” ìˆ˜ëŸ‰.
 * signalê³¼ memory_shardëŠ” 0 ì´ìƒì´ì–´ì•¼ í•©ë‹ˆë‹¤ (RULE-005).
 */
export const CurrencyAmountSchema = z
  .object({
    signal: z.number().int().min(0).describe('ì‹œê·¸ë„ (ê¸°ë³¸ ì¬í™”, 0 ì´ìƒ)'),
    memory_shard: z.number().int().min(0).describe('ê¸°ì–µ íŒŒí¸ (í¬ê·€ ì¬í™”, 0 ì´ìƒ)'),
  })
  .strict();
export type CurrencyAmount = z.infer<typeof CurrencyAmountSchema>;

// =============================================================================
// TurnInput ê´€ë ¨ íƒ€ì…
// =============================================================================

/**
 * í´ë¦­ ì…ë ¥ ì •ë³´.
 * í™”ë©´ ì˜¤ë¸Œì íŠ¸ í´ë¦­ ì‹œ ì „ë‹¬ë˜ëŠ” ì •ë³´ì…ë‹ˆë‹¤.
 */
export const ClickInputSchema = z
  .object({
    object_id: z.string().describe('í´ë¦­í•œ ì˜¤ë¸Œì íŠ¸ ID'),
    box_2d: Box2DSchema.nullable().default(null).describe('í´ë¦­ ìœ„ì¹˜ ë°”ìš´ë”© ë°•ìŠ¤ (ì„ íƒ)'),
  })
  .strict();
export type ClickInput = z.infer<typeof ClickInputSchema>;

/**
 * í´ë¼ì´ì–¸íŠ¸ ì •ë³´.
 */
export const ClientInfoSchema = z
  .object({
    viewport_w: z.number().int().positive().describe('ë·°í¬íŠ¸ ë„ˆë¹„ (í”½ì…€, ì–‘ìˆ˜)'),
    viewport_h: z.number().int().positive().describe('ë·°í¬íŠ¸ ë†’ì´ (í”½ì…€, ì–‘ìˆ˜)'),
    theme: ThemeSchema.default('dark').describe('í˜„ì¬ í…Œë§ˆ'),
  })
  .strict();
export type ClientInfo = z.infer<typeof ClientInfoSchema>;

/**
 * ì¬í™” ìŠ¤ëƒ…ìƒ· (í´ë¼ì´ì–¸íŠ¸ â†’ ì„œë²„).
 * í´ë¼ì´ì–¸íŠ¸ê°€ ë³´ìœ í•œ í˜„ì¬ ì¬í™” ìƒíƒœì…ë‹ˆë‹¤.
 */
export const EconomySnapshotSchema = z
  .object({
    signal: z.number().int().min(0).describe('í˜„ì¬ ì‹œê·¸ë„ ì”ì•¡ (0 ì´ìƒ)'),
    memory_shard: z.number().int().min(0).describe('í˜„ì¬ ê¸°ì–µ íŒŒí¸ ì”ì•¡ (0 ì´ìƒ)'),
  })
  .strict();
export type EconomySnapshot = z.infer<typeof EconomySnapshotSchema>;

/**
 * í„´ ì…ë ¥ (í´ë¼ì´ì–¸íŠ¸ â†’ ì„œë²„).
 * ì‚¬ìš©ìê°€ í„´ì„ ì§„í–‰í•  ë•Œ ì„œë²„ë¡œ ì „ì†¡í•˜ëŠ” ì…ë ¥ ë°ì´í„°ì…ë‹ˆë‹¤.
 */
export const TurnInputSchema = z
  .object({
    language: LanguageSchema.describe('ìš”ì²­ ì–¸ì–´ (ì‘ë‹µë„ ë™ì¼ ì–¸ì–´ë¡œ ê³ ì •)'),
    text: z.string().default('').describe('ì‚¬ìš©ì ìì—°ì–´ ì…ë ¥'),
    action_id: z.string().nullable().default(null).describe('ì„ íƒí•œ ì•¡ì…˜ ì¹´ë“œ ID (ì„ íƒ)'),
    click: ClickInputSchema.nullable().default(null).describe('ì˜¤ë¸Œì íŠ¸ í´ë¦­ ì •ë³´ (ì„ íƒ)'),
    client: ClientInfoSchema.describe('í´ë¼ì´ì–¸íŠ¸ í™˜ê²½ ì •ë³´'),
    economy_snapshot: EconomySnapshotSchema.describe('í˜„ì¬ ì¬í™” ìƒíƒœ'),
  })
  .strict();
export type TurnInput = z.infer<typeof TurnInputSchema>;

// =============================================================================
// TurnOutput ê´€ë ¨ íƒ€ì… - UI
// =============================================================================

/**
 * ë¹„ìš© ì¶”ì •ì¹˜ (U-009: ìµœì†Œ/ìµœëŒ€ ë²”ìœ„).
 * í–‰ë™ì˜ ì˜ˆìƒ ë¹„ìš© ë²”ìœ„ë¥¼ í‘œì‹œí•©ë‹ˆë‹¤.
 */
export const CostEstimateSchema = z
  .object({
    min: CurrencyAmountSchema.describe('ìµœì†Œ ì˜ˆìƒ ë¹„ìš©'),
    max: CurrencyAmountSchema.describe('ìµœëŒ€ ì˜ˆìƒ ë¹„ìš©'),
  })
  .strict();
export type CostEstimate = z.infer<typeof CostEstimateSchema>;

/**
 * ì•¡ì…˜ ì¹´ë“œ (Action Deck).
 * ë§¤ í„´ AIê°€ ì¶”ì²œí•˜ëŠ” í–‰ë™ ì¹´ë“œì…ë‹ˆë‹¤.
 *
 * U-009 í™•ì¥:
 *   - cost_estimate: ìµœì†Œ/ìµœëŒ€ ë¹„ìš© ë²”ìœ„ (RULE-005)
 *   - enabled: ì„œë²„ ì¸¡ ì‹¤í–‰ ê°€ëŠ¥ ì—¬ë¶€ íŒë‹¨ (Q1: Option A)
 *   - disabled_reason: ë¹„í™œì„±í™” ì‚¬ìœ  (ì”ì•¡ ë¶€ì¡± ë“±)
 *   - is_alternative: ì €ë¹„ìš©/í…ìŠ¤íŠ¸-only ëŒ€ì•ˆ ì¹´ë“œ ì—¬ë¶€
 */
export const ActionCardSchema = z
  .object({
    id: z.string().describe('ì¹´ë“œ ê³ ìœ  ID'),
    label: z.string().describe('ì¹´ë“œ ë¼ë²¨ (í‘œì‹œìš©)'),
    description: z.string().nullable().default(null).describe('ì¹´ë“œ ì„¤ëª… (ì„ íƒ)'),
    cost: CurrencyAmountSchema.describe('ì˜ˆìƒ ë¹„ìš© (ê¸°ë³¸)'),
    cost_estimate: CostEstimateSchema.nullable().default(null).describe('ë¹„ìš© ì¶”ì • ë²”ìœ„ (ì„ íƒ)'),
    risk: RiskLevelSchema.default('low').describe('ìœ„í—˜ë„'),
    hint: z.string().nullable().default(null).describe('ì˜ˆìƒ ê²°ê³¼ íŒíŠ¸ (ì„ íƒ)'),
    reward_hint: z.string().nullable().default(null).describe('ë³´ìƒ íŒíŠ¸ (ì„ íƒ)'),
    enabled: z.boolean().default(true).describe('ì‹¤í–‰ ê°€ëŠ¥ ì—¬ë¶€ (ì„œë²„ íŒë‹¨)'),
    disabled_reason: z.string().nullable().default(null).describe('ë¹„í™œì„±í™” ì‚¬ìœ  (ì„ íƒ)'),
    is_alternative: z.boolean().default(false).describe('ì €ë¹„ìš© ëŒ€ì•ˆ ì¹´ë“œ ì—¬ë¶€'),
  })
  .strict();
export type ActionCard = z.infer<typeof ActionCardSchema>;

/**
 * ì¥ë©´ ì˜¤ë¸Œì íŠ¸ (í´ë¦­ ê°€ëŠ¥í•œ í•«ìŠ¤íŒŸ).
 * ì¢Œí‘œëŠ” 0~1000 ì •ê·œí™” ì¢Œí‘œê³„ë¥¼ ì‚¬ìš©í•©ë‹ˆë‹¤ (RULE-009).
 */
export const SceneObjectSchema = z
  .object({
    id: z.string().describe('ì˜¤ë¸Œì íŠ¸ ê³ ìœ  ID'),
    label: z.string().describe('ì˜¤ë¸Œì íŠ¸ ë¼ë²¨ (í‘œì‹œìš©)'),
    box_2d: Box2DSchema.describe('ë°”ìš´ë”© ë°•ìŠ¤'),
    interaction_hint: z.string().nullable().default(null).describe('ìƒí˜¸ì‘ìš© íŒíŠ¸ (ì„ íƒ)'),
  })
  .strict();
export type SceneObject = z.infer<typeof SceneObjectSchema>;

/**
 * ì•¡ì…˜ ë± (Q1 ê²°ì •: ui.action_deck.cards[] êµ¬ì¡°).
 * ë§¤ í„´ AIê°€ ì œì‹œí•˜ëŠ” ì¶”ì²œ í–‰ë™ ì¹´ë“œ ë±ì…ë‹ˆë‹¤.
 */
export const ActionDeckSchema = z
  .object({
    cards: z.array(ActionCardSchema).max(10).default([]).describe('ì•¡ì…˜ ì¹´ë“œ ëª©ë¡ (3~6ì¥ ê¶Œì¥)'),
  })
  .strict();
export type ActionDeck = z.infer<typeof ActionDeckSchema>;

/**
 * UI ì¶œë ¥ ë°ì´í„°.
 * AIê°€ ìƒì„±í•œ UI ìš”ì†Œë“¤ì…ë‹ˆë‹¤.
 * ì±„íŒ… ë²„ë¸”ì´ ì•„ë‹Œ ê²Œì„ UIë¡œ í‘œí˜„ë©ë‹ˆë‹¤ (RULE-002).
 */
export const UIOutputSchema = z
  .object({
    action_deck: ActionDeckSchema.default({ cards: [] }).describe('ì•¡ì…˜ ì¹´ë“œ ë±'),
    objects: z.array(SceneObjectSchema).default([]).describe('í´ë¦­ ê°€ëŠ¥í•œ ì¥ë©´ ì˜¤ë¸Œì íŠ¸ ëª©ë¡'),
  })
  .strict();
export type UIOutput = z.infer<typeof UIOutputSchema>;

// =============================================================================
// TurnOutput ê´€ë ¨ íƒ€ì… - World
// =============================================================================

/**
 * ì¤‘ìš” ì„¤ì • ê³ ì • í›„ë³´.
 * ì‚¬ìš©ìê°€ Memory Shardë¥¼ ì†Œë¹„í•´ ê³ ì •í•  ìˆ˜ ìˆëŠ” ì¤‘ìš” ì„¤ì •ì…ë‹ˆë‹¤.
 */
export const MemoryPinSchema = z
  .object({
    id: z.string().describe('í•€ ê³ ìœ  ID'),
    content: z.string().describe('ê³ ì •í•  ë‚´ìš©'),
    cost: CurrencyAmountSchema.describe('ê³ ì •ì— í•„ìš”í•œ ë¹„ìš©'),
  })
  .strict();
export type MemoryPin = z.infer<typeof MemoryPinSchema>;

/**
 * ì„¸ê³„ ê·œì¹™ (Rule Board).
 * í˜„ì¬ ì„¸ê³„ì— ì ìš© ì¤‘ì¸ ë¬¼ë¦¬ ë²•ì¹™ì´ë‚˜ ë©”íƒ€ ê·œì¹™ì…ë‹ˆë‹¤.
 */
export const WorldRuleSchema = z
  .object({
    id: z.string().describe('ê·œì¹™ ê³ ìœ  ID'),
    label: z.string().describe('ê·œì¹™ ì´ë¦„'),
    description: z.string().nullable().default(null).describe('ê·œì¹™ ìƒì„¸ ì„¤ëª… (ì„ íƒ)'),
  })
  .strict();
export type WorldRule = z.infer<typeof WorldRuleSchema>;

/**
 * í€˜ìŠ¤íŠ¸/ëª©í‘œ (Quest Panel).
 * í”Œë ˆì´ì–´ê°€ ë‹¬ì„±í•´ì•¼ í•˜ëŠ” í˜„ì¬ ëª©í‘œì…ë‹ˆë‹¤.
 */
export const QuestSchema = z
  .object({
    id: z.string().describe('í€˜ìŠ¤íŠ¸ ê³ ìœ  ID'),
    label: z.string().describe('í€˜ìŠ¤íŠ¸ ì´ë¦„'),
    is_completed: z.boolean().default(false).describe('ë‹¬ì„± ì—¬ë¶€'),
  })
  .strict();
export type Quest = z.infer<typeof QuestSchema>;

/**
 * ì„¸ê³„ ìƒíƒœ ë³€í™” (Q2 ê²°ì •: Option A - delta ì¤‘ì‹¬).
 * ì´ë²ˆ í„´ì—ì„œ ë³€ê²½ëœ ì„¸ê³„ ìƒíƒœë¥¼ ë‚˜íƒ€ëƒ…ë‹ˆë‹¤.
 */
export const WorldDeltaSchema = z
  .object({
    rules_changed: z.array(WorldRuleSchema).default([]).describe('ë³€ê²½ëœ ê·œì¹™ ëª©ë¡'),
    inventory_added: z.array(z.string()).default([]).describe('ì¶”ê°€ëœ ì¸ë²¤í† ë¦¬ ì•„ì´í…œ'),
    inventory_removed: z.array(z.string()).default([]).describe('ì œê±°ëœ ì¸ë²¤í† ë¦¬ ì•„ì´í…œ'),
    quests_updated: z.array(QuestSchema).default([]).describe('ì—…ë°ì´íŠ¸ëœ í€˜ìŠ¤íŠ¸/ëª©í‘œ ëª©ë¡'),
    relationships_changed: z.array(z.string()).default([]).describe('ë³€ê²½ëœ ê´€ê³„'),
    memory_pins: z.array(MemoryPinSchema).default([]).describe('ì¤‘ìš” ì„¤ì • ê³ ì • í›„ë³´'),
  })
  .strict();
export type WorldDelta = z.infer<typeof WorldDeltaSchema>;

// =============================================================================
// TurnOutput ê´€ë ¨ íƒ€ì… - Render
// =============================================================================

/**
 * ì´ë¯¸ì§€ ìƒì„± ì‘ì—….
 * ì¡°ê±´ë¶€ ì´ë¯¸ì§€ ìƒì„±/í¸ì§‘ ìš”ì²­ì…ë‹ˆë‹¤.
 */
export const ImageJobSchema = z
  .object({
    should_generate: z.boolean().describe('ì´ë¯¸ì§€ë¥¼ ìƒì„±í•´ì•¼ í•˜ëŠ”ì§€'),
    prompt: z.string().default('').describe('ì´ë¯¸ì§€ ìƒì„± í”„ë¡¬í”„íŠ¸'),
    model_label: ModelLabelSchema.default('FAST').describe('ëª¨ë¸ ì„ íƒ ë¼ë²¨'),
    aspect_ratio: z.string().default('16:9').describe('ê°€ë¡œì„¸ë¡œ ë¹„ìœ¨'),
    image_size: z.string().default('1024x1024').describe('ì´ë¯¸ì§€ í¬ê¸°'),
    reference_image_ids: z.array(z.string()).default([]).describe('ì°¸ì¡° ì´ë¯¸ì§€ ID ëª©ë¡ (ì„ íƒ)'),
  })
  .strict();
export type ImageJob = z.infer<typeof ImageJobSchema>;

/**
 * ë Œë”ë§ ì¶œë ¥ ë°ì´í„°.
 * ì´ë¯¸ì§€ ìƒì„±/í¸ì§‘ ê´€ë ¨ ì •ë³´ì…ë‹ˆë‹¤.
 */
export const RenderOutputSchema = z
  .object({
    image_job: ImageJobSchema.nullable().default(null).describe('ì´ë¯¸ì§€ ìƒì„± ì‘ì—… (ì„ íƒ)'),
  })
  .strict();
export type RenderOutput = z.infer<typeof RenderOutputSchema>;

// =============================================================================
// TurnOutput ê´€ë ¨ íƒ€ì… - Economy
// =============================================================================

/**
 * ê²½ì œ ì¶œë ¥ ë°ì´í„° (RULE-005).
 * ì´ë²ˆ í„´ì˜ ë¹„ìš©ê³¼ ì”ì•¡ ì •ë³´ì…ë‹ˆë‹¤.
 * ì”ì•¡ ìŒìˆ˜ëŠ” ì ˆëŒ€ ë¶ˆê°€ (ì„œë²„ Hard gate).
 */
export const EconomyOutputSchema = z
  .object({
    cost: CurrencyAmountSchema.describe('ì´ë²ˆ í„´ì— ì†Œë¹„ëœ ë¹„ìš©'),
    balance_after: CurrencyAmountSchema.describe('ì†Œë¹„ í›„ ì”ì•¡'),
  })
  .strict();
export type EconomyOutput = z.infer<typeof EconomyOutputSchema>;

// =============================================================================
// TurnOutput ê´€ë ¨ íƒ€ì… - Safety
// =============================================================================

/**
 * ì•ˆì „ ì¶œë ¥ ë°ì´í„°.
 * ì•ˆì „ ì •ì±… ê´€ë ¨ ì •ë³´ì…ë‹ˆë‹¤.
 * ì°¨ë‹¨ ì‹œ ëª…ì‹œì  ë©”ì‹œì§€ì™€ í•¨ê»˜ ì•ˆì „í•œ ëŒ€ì²´ ê²°ê³¼ë¥¼ ì œê³µí•©ë‹ˆë‹¤.
 */
export const SafetyOutputSchema = z
  .object({
    blocked: z.boolean().default(false).describe('ì•ˆì „ ì •ì±…ì— ì˜í•´ ì°¨ë‹¨ë˜ì—ˆëŠ”ì§€'),
    message: z
      .string()
      .nullable()
      .default(null)
      .describe('ì°¨ë‹¨ ì‹œ ì‚¬ìš©ìì—ê²Œ í‘œì‹œí•  ë©”ì‹œì§€ (ì„ íƒ)'),
  })
  .strict();
export type SafetyOutput = z.infer<typeof SafetyOutputSchema>;

// =============================================================================
// TurnOutput ê´€ë ¨ íƒ€ì… - Agent Console
// =============================================================================

/**
 * ì—ì´ì „íŠ¸ ì½˜ì†” ë°ì´í„° (RULE-008).
 * ì—ì´ì „íŠ¸í˜• ì‹œìŠ¤í…œì„ì„ UIë¡œ ì¦ëª…í•˜ê¸° ìœ„í•œ ì •ë³´ì…ë‹ˆë‹¤.
 */
export const AgentConsoleSchema = z
  .object({
    current_phase: AgentPhaseSchema.default('commit').describe('í˜„ì¬ ì‹¤í–‰ ë‹¨ê³„'),
    badges: z.array(ValidationBadgeSchema).default([]).describe('ê²€ì¦ ë°°ì§€ ëª©ë¡'),
    repair_count: z.number().int().min(0).default(0).describe('ìë™ ë³µêµ¬ ì‹œë„ íšŸìˆ˜'),
  })
  .strict();
export type AgentConsole = z.infer<typeof AgentConsoleSchema>;

// =============================================================================
// TurnOutput (ë©”ì¸ ì‘ë‹µ ìŠ¤í‚¤ë§ˆ)
// =============================================================================

/**
 * í„´ ì¶œë ¥ (ì„œë²„ â†’ í´ë¼ì´ì–¸íŠ¸).
 * ì„œë²„ê°€ í„´ ì²˜ë¦¬ í›„ í´ë¼ì´ì–¸íŠ¸ë¡œ ë°˜í™˜í•˜ëŠ” êµ¬ì¡°í™”ëœ ì‘ë‹µì…ë‹ˆë‹¤.
 *
 * Hard Gate í•„ë“œ (RULE-003/004/005):
 *   - economy: costì™€ balance_after í•„ìˆ˜, ì”ì•¡ ìŒìˆ˜ ê¸ˆì§€
 *   - safety: blocked ì‹œ ì•ˆì „í•œ ëŒ€ì²´ ê²°ê³¼ ì œê³µ
 *   - language: ìš”ì²­ ì–¸ì–´ì™€ ë™ì¼í•˜ê²Œ ê³ ì • (í˜¼í•© ì¶œë ¥ ê¸ˆì§€)
 */
export const TurnOutputSchema = z
  .object({
    // í•„ìˆ˜ í•„ë“œ (Hard Gate)
    language: LanguageSchema.describe('ì‘ë‹µ ì–¸ì–´ (ìš”ì²­ê³¼ ë™ì¼)'),
    narrative: z.string().describe('ë‚´ëŸ¬í‹°ë¸Œ í…ìŠ¤íŠ¸ (í‘œì‹œìš©)'),
    economy: EconomyOutputSchema.describe('ê²½ì œ ì •ë³´ (ë¹„ìš©, ì”ì•¡)'),
    safety: SafetyOutputSchema.describe('ì•ˆì „ ì •ì±… ì •ë³´'),

    // UI ê´€ë ¨ í•„ë“œ
    ui: UIOutputSchema.default({ action_deck: { cards: [] }, objects: [] }).describe('UI ìš”ì†Œ'),

    // ì„¸ê³„ ìƒíƒœ í•„ë“œ
    world: WorldDeltaSchema.default({
      rules_changed: [],
      inventory_added: [],
      inventory_removed: [],
      quests_updated: [],
      relationships_changed: [],
      memory_pins: [],
    }).describe('ì„¸ê³„ ìƒíƒœ ë³€í™” (delta)'),

    // ë Œë”ë§ í•„ë“œ
    render: RenderOutputSchema.default({ image_job: null }).describe('ë Œë”ë§ ì •ë³´'),

    // ì—ì´ì „íŠ¸ ì½˜ì†” í•„ë“œ
    agent_console: AgentConsoleSchema.default({
      current_phase: 'commit',
      badges: [],
      repair_count: 0,
    }).describe('ì—ì´ì „íŠ¸ ì‹¤í–‰ ì •ë³´'),
  })
  .strict();
export type TurnOutput = z.infer<typeof TurnOutputSchema>;

// =============================================================================
// ì•ˆì „ í´ë°± (RULE-004)
// =============================================================================

/**
 * ê²€ì¦ ì‹¤íŒ¨ ì‹œ ì œê³µë˜ëŠ” ì•ˆì „ í´ë°± TurnOutput.
 * UIê°€ ë©ˆì¶”ì§€ ì•Šë„ë¡ ìµœì†Œí•œì˜ ì •ë³´ë¥¼ ì œê³µí•©ë‹ˆë‹¤.
 *
 * @param language - ìš”ì²­ ì–¸ì–´
 * @param repairCount - ë³µêµ¬ ì‹œë„ íšŸìˆ˜
 * @param errorMessage - ì˜¤ë¥˜ ë©”ì‹œì§€ (ì„ íƒ)
 */
export function createFallbackTurnOutput(
  language: Language,
  repairCount: number = 0,
  errorMessage?: string,
): TurnOutput {
  const fallbackNarrative =
    language === 'ko-KR'
      ? '[ì‹œìŠ¤í…œ] ì‘ë‹µì„ ì²˜ë¦¬í•˜ëŠ” ì¤‘ ë¬¸ì œê°€ ë°œìƒí–ˆìŠµë‹ˆë‹¤. ë‹¤ì‹œ ì‹œë„í•´ ì£¼ì„¸ìš”.'
      : '[System] An error occurred while processing the response. Please try again.';

  const safetyMessage =
    language === 'ko-KR'
      ? 'ìŠ¤í‚¤ë§ˆ ê²€ì¦ ì‹¤íŒ¨ë¡œ ì¸í•œ í´ë°± ì‘ë‹µì…ë‹ˆë‹¤.'
      : 'This is a fallback response due to schema validation failure.';

  return {
    language,
    narrative: errorMessage ?? fallbackNarrative,
    economy: {
      cost: { signal: 0, memory_shard: 0 },
      balance_after: { signal: 0, memory_shard: 0 },
    },
    safety: {
      blocked: false,
      message: safetyMessage,
    },
    ui: {
      action_deck: { cards: [] },
      objects: [],
    },
    world: {
      rules_changed: [],
      inventory_added: [],
      inventory_removed: [],
      quests_updated: [],
      relationships_changed: [],
      memory_pins: [],
    },
    render: {
      image_job: null,
    },
    agent_console: {
      current_phase: 'commit',
      badges: ['schema_fail'],
      repair_count: repairCount,
    },
  };
}

// =============================================================================
// ê²€ì¦ í—¬í¼ í•¨ìˆ˜
// =============================================================================

/**
 * TurnOutput ê²€ì¦ ê²°ê³¼ íƒ€ì….
 */
export type TurnOutputParseResult =
  | { success: true; data: TurnOutput }
  | { success: false; error: z.ZodError; fallback: TurnOutput };

/**
 * TurnOutputì„ ì•ˆì „í•˜ê²Œ íŒŒì‹±í•©ë‹ˆë‹¤.
 * ì‹¤íŒ¨ ì‹œ í´ë°± TurnOutputì„ ë°˜í™˜í•©ë‹ˆë‹¤ (RULE-004).
 *
 * @param data - íŒŒì‹±í•  ë°ì´í„°
 * @param language - í´ë°± ì‹œ ì‚¬ìš©í•  ì–¸ì–´ (ê¸°ë³¸: ko-KR)
 * @param repairCount - í˜„ì¬ ë³µêµ¬ ì‹œë„ íšŸìˆ˜
 */
export function safeParseTurnOutput(
  data: unknown,
  language: Language = 'ko-KR',
  repairCount: number = 0,
): TurnOutputParseResult {
  const result = TurnOutputSchema.safeParse(data);

  if (result.success) {
    return { success: true, data: result.data };
  }

  return {
    success: false,
    error: result.error,
    fallback: createFallbackTurnOutput(language, repairCount),
  };
}

/**
 * TurnInputì„ ê²€ì¦í•©ë‹ˆë‹¤.
 * ì…ë ¥ ë°ì´í„°ì˜ ìœ íš¨ì„±ì„ ì—„ê²©í•˜ê²Œ ê²€ì‚¬í•©ë‹ˆë‹¤.
 *
 * @param data - ê²€ì¦í•  ë°ì´í„°
 * @throws {z.ZodError} ê²€ì¦ ì‹¤íŒ¨ ì‹œ
 */
export function parseTurnInput(data: unknown): TurnInput {
  return TurnInputSchema.parse(data);
}

/**
 * TurnInput ì•ˆì „ íŒŒì‹± ê²°ê³¼ íƒ€ì….
 */
export type TurnInputSafeParseResult = ReturnType<typeof TurnInputSchema.safeParse>;

/**
 * TurnInputì„ ì•ˆì „í•˜ê²Œ íŒŒì‹±í•©ë‹ˆë‹¤.
 *
 * @param data - íŒŒì‹±í•  ë°ì´í„°
 */
export function safeParseTurnInput(data: unknown): TurnInputSafeParseResult {
  return TurnInputSchema.safeParse(data);
}
</file>

<file path="frontend/src/stores/uiPrefsStore.test.ts">
import { describe, it, expect, beforeEach } from 'vitest';
import { useUIPrefsStore, DEFAULT_UI_SCALE, migrateUIPrefs } from './uiPrefsStore';

// Mock localStorage for non-browser environment
// Note: With jsdom environment configured in vite.config.ts, this might not be strictly necessary
// if we trust jsdom's localStorage, but keeping it explicit is fine.
// However, since we are moving to direct function testing for migration, we rely less on persist middleware internals.

describe('uiPrefsStore', () => {
  beforeEach(() => {
    useUIPrefsStore.getState().resetPrefs();
    localStorage.clear();
  });

  it('should have default initial state', () => {
    const state = useUIPrefsStore.getState();
    expect(state.uiScale).toBe(DEFAULT_UI_SCALE);
  });

  it('should increase ui scale within limit', () => {
    const { increaseUIScale } = useUIPrefsStore.getState();

    // 1.0 -> 1.1
    increaseUIScale();
    expect(useUIPrefsStore.getState().uiScale).toBe(1.1);

    // 1.1 -> 1.2
    increaseUIScale();
    expect(useUIPrefsStore.getState().uiScale).toBe(1.2);

    // 1.2 -> 1.2 (Max)
    increaseUIScale();
    expect(useUIPrefsStore.getState().uiScale).toBe(1.2);
  });

  it('should decrease ui scale within limit', () => {
    const { decreaseUIScale, setUIScale } = useUIPrefsStore.getState();

    // Start at max
    setUIScale(1.2);

    // 1.2 -> 1.1
    decreaseUIScale();
    expect(useUIPrefsStore.getState().uiScale).toBe(1.1);

    // ... -> 0.9 (Min)
    setUIScale(0.9);
    decreaseUIScale();
    expect(useUIPrefsStore.getState().uiScale).toBe(0.9);
  });

  it('should set valid ui scale', () => {
    const { setUIScale } = useUIPrefsStore.getState();

    setUIScale(1.1);
    expect(useUIPrefsStore.getState().uiScale).toBe(1.1);
  });

  it('should ignore invalid ui scale', () => {
    const { setUIScale } = useUIPrefsStore.getState();

    // @ts-expect-error Testing invalid input
    setUIScale(2.0);
    expect(useUIPrefsStore.getState().uiScale).toBe(DEFAULT_UI_SCALE);
  });

  describe('migration (U-037)', () => {
    it('should remove readableMode from legacy storage', () => {
      // Legacy state simulation
      const legacyState = {
        uiScale: 1.1,
        readableMode: true,
      };

      // Call migrate function directly
      const migratedState = migrateUIPrefs(legacyState, 0);

      // Verify
      expect(migratedState).toHaveProperty('uiScale', 1.1);
      expect(migratedState).not.toHaveProperty('readableMode');
    });

    it('should handle undefined version (very old legacy)', () => {
      const legacyState = {
        uiScale: 0.9,
        readableMode: false,
      };

      // Call migrate function directly with undefined version
      const migratedState = migrateUIPrefs(legacyState, undefined);

      expect(migratedState).toHaveProperty('uiScale', 0.9);
      expect(migratedState).not.toHaveProperty('readableMode');
    });

    it('should pass through already migrated state', () => {
      const modernState = {
        uiScale: 1.0,
      };

      const migratedState = migrateUIPrefs(modernState, 1);
      expect(migratedState).toEqual(modernState);
    });
  });
});
</file>

<file path="frontend/src/stores/uiPrefsStore.ts">
/**
 * Unknown World - UI ì„¤ì • ìƒíƒœ ê´€ë¦¬ (Zustand + persist).
 *
 * UI ìŠ¤ì¼€ì¼ ì„¤ì •ì„ ì €ì¥í•˜ê³ , SaveGame êµ¬ì¡°ì™€ í†µí•© ê°€ëŠ¥í•˜ë„ë¡ ì§ë ¬í™” ì¸í„°í˜ì´ìŠ¤ë¥¼ ì œê³µí•©ë‹ˆë‹¤.
 *
 * ì„¤ê³„ ì›ì¹™:
 *   - PRD 9.4: ê°€ë…ì„±(í•„ìˆ˜) - ì „ì—­ UI ìŠ¤ì¼€ì¼ ì¡°ì ˆ ì œê³µ
 *   - U-037: Readable ëª¨ë“œ ì œê±° â†’ critical/ambient ì¤‘ìš”ë„ ê¸°ë°˜ ìŠ¤íƒ€ì¼ë¡œ ëŒ€ì²´
 *   - Q1 ê²°ì •: Option B (SaveGameì— í¬í•¨) - persist + ì§ë ¬í™”
 *
 * @module stores/uiPrefsStore
 */

import { create } from 'zustand';
import { persist, createJSONStorage } from 'zustand/middleware';

// =============================================================================
// ìƒìˆ˜ ì •ì˜
// =============================================================================

/** ì§€ì›í•˜ëŠ” UI ìŠ¤ì¼€ì¼ ê°’ */
export const UI_SCALES = [0.9, 1.0, 1.1, 1.2] as const;
export type UIScale = (typeof UI_SCALES)[number];

/** ê¸°ë³¸ UI ìŠ¤ì¼€ì¼ */
export const DEFAULT_UI_SCALE: UIScale = 1.0;

/** localStorage í‚¤ (SaveGame í†µí•© ì‹œì—ë„ ì‚¬ìš© ê°€ëŠ¥) */
export const UI_PREFS_STORAGE_KEY = 'unknown-world-ui-prefs';

// =============================================================================
// ìƒíƒœ íƒ€ì… ì •ì˜
// =============================================================================

/** UI ì„¤ì • ìƒíƒœ (SaveGame ì§ë ¬í™” ëŒ€ìƒ) */
export interface UIPrefsState {
  /**
   * UI ìŠ¤ì¼€ì¼ (0.9 ~ 1.2)
   * - 0.9: ì‘ì€ UI (ì •ë³´ ë°€ë„ ë†’ìŒ)
   * - 1.0: ê¸°ë³¸
   * - 1.1: ì•½ê°„ í™•ëŒ€
   * - 1.2: í° UI (ê°€ë…ì„± ìš°ì„ )
   */
  uiScale: UIScale;
}

/** UI ì„¤ì • ì•¡ì…˜ */
export interface UIPrefsActions {
  /** UI ìŠ¤ì¼€ì¼ ì„¤ì • */
  setUIScale: (scale: UIScale) => void;

  /** UI ìŠ¤ì¼€ì¼ ì¦ê°€ (ìµœëŒ€ 1.2) */
  increaseUIScale: () => void;

  /** UI ìŠ¤ì¼€ì¼ ê°ì†Œ (ìµœì†Œ 0.9) */
  decreaseUIScale: () => void;

  /** ì„¤ì • ì´ˆê¸°í™” */
  resetPrefs: () => void;

  /**
   * SaveGame ì§ë ¬í™”ìš© ìƒíƒœ ì¶”ì¶œ
   * (ì¶”í›„ SaveGame í†µí•© ì‹œ ì‚¬ìš©)
   */
  getSerializableState: () => UIPrefsState;

  /**
   * SaveGame ì—­ì§ë ¬í™”ìš© ìƒíƒœ ë³µì›
   * (ì¶”í›„ SaveGame í†µí•© ì‹œ ì‚¬ìš©)
   */
  restoreState: (state: Partial<UIPrefsState>) => void;
}

export type UIPrefsStore = UIPrefsState & UIPrefsActions;

// =============================================================================
// ì´ˆê¸° ìƒíƒœ
// =============================================================================

/** ì´ˆê¸° ìƒíƒœ ìƒì„± */
function createInitialState(): UIPrefsState {
  return {
    uiScale: DEFAULT_UI_SCALE,
  };
}

// =============================================================================
// ìœ í‹¸ë¦¬í‹° í•¨ìˆ˜
// =============================================================================

/**
 * ì£¼ì–´ì§„ ìŠ¤ì¼€ì¼ì´ ìœ íš¨í•œì§€ í™•ì¸
 */
function isValidScale(scale: number): scale is UIScale {
  return UI_SCALES.includes(scale as UIScale);
}

/**
 * ìŠ¤ì¼€ì¼ ì¸ë±ìŠ¤ ë°˜í™˜
 */
function getScaleIndex(scale: UIScale): number {
  return UI_SCALES.indexOf(scale);
}

/**
 * U-037: legacy ì €ì¥ê°’(readableMode) ë§ˆì´ê·¸ë ˆì´ì…˜/ë¬´ì‹œ
 * @internal exported for testing
 */
export function migrateUIPrefs(persistedState: unknown, version: number | undefined): UIPrefsState {
  // version 0 ë˜ëŠ” undefinedì—ì„œ version 1ë¡œ ë§ˆì´ê·¸ë ˆì´ì…˜
  // readableMode í•„ë“œê°€ ìˆìœ¼ë©´ ì œê±°
  if (version === 0 || version === undefined) {
    const state = persistedState as Record<string, unknown>;
    // readableMode í•„ë“œ ì œê±° (ë¬´ì‹œ)
    if ('readableMode' in state) {
      const { readableMode: _, ...rest } = state;
      return { ...rest, uiScale: state.uiScale ?? DEFAULT_UI_SCALE } as UIPrefsState;
    }
    return { ...state, uiScale: state.uiScale ?? DEFAULT_UI_SCALE } as UIPrefsState;
  }
  return persistedState as UIPrefsState;
}

// =============================================================================
// Zustand Store with persist
// =============================================================================

/**
 * UI ì„¤ì • ìŠ¤í† ì–´.
 *
 * U-037: Readable ëª¨ë“œ ì œê±°ë¨. CRT íš¨ê³¼ëŠ” critical/ambient ì¤‘ìš”ë„ ê¸°ë°˜ìœ¼ë¡œ ìë™ ì ìš©ë©ë‹ˆë‹¤.
 *
 * @example
 * ```tsx
 * // ì»´í¬ë„ŒíŠ¸ì—ì„œ ì‚¬ìš©
 * const { uiScale, setUIScale } = useUIPrefsStore();
 *
 * // DOM ì ìš© (App.tsxì—ì„œ)
 * useEffect(() => {
 *   document.documentElement.dataset.uiScale = uiScale.toString();
 *   document.documentElement.style.setProperty('--ui-scale-factor', uiScale.toString());
 * }, [uiScale]);
 * ```
 */
export const useUIPrefsStore = create<UIPrefsStore>()(
  persist(
    (set, get) => ({
      // ì´ˆê¸° ìƒíƒœ
      ...createInitialState(),

      // ì•¡ì…˜
      setUIScale: (scale) => {
        if (isValidScale(scale)) {
          set({ uiScale: scale });
        }
      },

      increaseUIScale: () => {
        const currentIndex = getScaleIndex(get().uiScale);
        const nextIndex = Math.min(currentIndex + 1, UI_SCALES.length - 1);
        set({ uiScale: UI_SCALES[nextIndex] });
      },

      decreaseUIScale: () => {
        const currentIndex = getScaleIndex(get().uiScale);
        const prevIndex = Math.max(currentIndex - 1, 0);
        set({ uiScale: UI_SCALES[prevIndex] });
      },

      resetPrefs: () => {
        set(createInitialState());
      },

      getSerializableState: () => {
        const { uiScale } = get();
        return { uiScale };
      },

      restoreState: (state) => {
        const updates: Partial<UIPrefsState> = {};

        if (state.uiScale !== undefined && isValidScale(state.uiScale)) {
          updates.uiScale = state.uiScale;
        }

        if (Object.keys(updates).length > 0) {
          set(updates);
        }
      },
    }),
    {
      name: UI_PREFS_STORAGE_KEY,
      storage: createJSONStorage(() => localStorage),
      // ì§ë ¬í™”í•  í•„ë“œ ì§€ì • (ì•¡ì…˜ ì œì™¸)
      partialize: (state) => ({
        uiScale: state.uiScale,
      }),
      // U-037: legacy ì €ì¥ê°’(readableMode) ë§ˆì´ê·¸ë ˆì´ì…˜/ë¬´ì‹œ
      version: 1,
      migrate: migrateUIPrefs,
    },
  ),
);

// =============================================================================
// ì…€ë ‰í„° (ì„±ëŠ¥ ìµœì í™”ìš©)
// =============================================================================

/** UI ìŠ¤ì¼€ì¼ ì…€ë ‰í„° */
export const selectUIScale = (state: UIPrefsStore) => state.uiScale;

// =============================================================================
// DOM ì ìš© í—¬í¼
// =============================================================================

/**
 * CSS ë³€ìˆ˜ë¡œ UI ìŠ¤ì¼€ì¼ ì ìš©
 * í˜¸ì¶œ ì‹œ html ìš”ì†Œì— --ui-scale-factor ë³€ìˆ˜ë¥¼ ì„¤ì •
 */
export function applyUIScaleToDOM(scale: UIScale): void {
  document.documentElement.style.setProperty('--ui-scale-factor', scale.toString());
  document.documentElement.dataset.uiScale = scale.toString();
}

/**
 * ì „ì²´ UI ì„¤ì • DOM ì ìš©
 * U-037: readableMode ì œê±°ë¨ - ìŠ¤ì¼€ì¼ë§Œ ì ìš©
 */
export function applyUIPrefsToDOM(state: UIPrefsState): void {
  applyUIScaleToDOM(state.uiScale);
}
</file>

<file path="frontend/tsconfig.json">
{
  "compilerOptions": {
    "target": "ES2022",
    "useDefineForClassFields": true,
    "lib": ["ES2022", "DOM", "DOM.Iterable"],
    "module": "ESNext",
    "skipLibCheck": true,

    /* Bundler mode */
    "moduleResolution": "Bundler",
    "allowImportingTsExtensions": true,
    "isolatedModules": true,
    "moduleDetection": "force",
    "noEmit": true,
    "jsx": "react-jsx",

    /* Linting (ì—„ê²© ëª¨ë“œ) */
    "strict": true,
    "noUnusedLocals": true,
    "noUnusedParameters": true,
    "noFallthroughCasesInSwitch": true,
    "noUncheckedSideEffectImports": true
  },
  "include": ["src"],
  "references": [{ "path": "./tsconfig.node.json" }]
}
</file>

<file path="backend/src/unknown_world/__init__.py">
"""Unknown World - Backend Package

This is the main package for the Unknown World backend.
Architecture: FastAPI + Pydantic + SSE streaming

Reference:
- vibe/tech-stack.md (Python 3.14, FastAPI 0.128.0, Pydantic 2.12.5)
- vibe/prd.md (Agent-based Game Master Engine)
"""

__version__ = "0.1.0"
</file>

<file path="backend/src/unknown_world/main.py">
"""Unknown World - FastAPI ì• í”Œë¦¬ì¼€ì´ì…˜ ì—”íŠ¸ë¦¬í¬ì¸íŠ¸

ì´ ëª¨ë“ˆì€ Unknown World ë°±ì—”ë“œì˜ FastAPI ì•±ì„ ì •ì˜í•©ë‹ˆë‹¤.
MVP ë‹¨ê³„ì—ì„œëŠ” ê¸°ë³¸ í—¬ìŠ¤ì²´í¬ì™€ ê°œë°œìš© CORS ì„¤ì •ë§Œ í¬í•¨í•©ë‹ˆë‹¤.

ì‹¤í–‰ ë°©ë²•:
    cd backend
    uv sync
    uv run uvicorn unknown_world.main:app --reload --port 8011

ì°¸ì¡°:
    - vibe/tech-stack.md (ë²„ì „ SSOT)
    - vibe/prd.md (ì—ì´ì „íŠ¸í˜• ê²Œì„ ì—”ì§„ ìš”êµ¬ì‚¬í•­)
    - .cursor/rules/20-backend-orchestrator.mdc (SSE/ê²€ì¦/ë³µêµ¬ ê·œì¹™)
"""

from typing import Literal

from fastapi import FastAPI
from fastapi.middleware.cors import CORSMiddleware
from pydantic import BaseModel

from unknown_world import __version__
from unknown_world.api import turn_router

# =============================================================================
# FastAPI ì•± ì¸ìŠ¤í„´ìŠ¤
# =============================================================================

app = FastAPI(
    title="Unknown World API",
    description="Gemini ê¸°ë°˜ ì—ì´ì „íŠ¸í˜• ê²Œì„ ì—”ì§„ ì˜¤ì¼€ìŠ¤íŠ¸ë ˆì´í„°",
    version=__version__,
    docs_url="/docs",
    redoc_url="/redoc",
)

# =============================================================================
# CORS ì„¤ì • (ê°œë°œ í™˜ê²½ìš©)
# =============================================================================
# PRD ìš”êµ¬: ë¡œì»¬ ê°œë°œì—ì„œ í”„ë¡ íŠ¸ì™€ í†µì‹ í•  ìˆ˜ ìˆë„ë¡ CORS ê¸°ë³¸ ì •ì±… ì¤€ë¹„
# RULE-011: í”„ë¡ íŠ¸ì—”ë“œëŠ” 8001~8010 í¬íŠ¸ ì‚¬ìš©
# ì£¼ì˜: í”„ë¡œë•ì…˜ì—ì„œëŠ” MMP ë‹¨ê³„ì—ì„œ ì—„ê²©í•œ ì •ì±…ìœ¼ë¡œ ë³€ê²½í•´ì•¼ í•¨

ALLOWED_ORIGINS = [
    # í”„ë¡ íŠ¸ì—”ë“œ ê°œë°œ ì„œë²„ í¬íŠ¸ ë²”ìœ„ (RULE-011: 8001~8010)
    *[f"http://localhost:{port}" for port in range(8001, 8011)],
    *[f"http://127.0.0.1:{port}" for port in range(8001, 8011)],
]

app.add_middleware(
    CORSMiddleware,
    allow_origins=ALLOWED_ORIGINS,
    allow_credentials=True,
    allow_methods=["*"],
    allow_headers=["*"],
)

# =============================================================================
# ë¼ìš°í„° ë“±ë¡
# =============================================================================

# U-007: /api/turn HTTP Streaming ì—”ë“œí¬ì¸íŠ¸
app.include_router(turn_router)


# =============================================================================
# ì‘ë‹µ ìŠ¤í‚¤ë§ˆ (Pydantic)
# =============================================================================


class HealthResponse(BaseModel):
    """í—¬ìŠ¤ì²´í¬ ì‘ë‹µ ìŠ¤í‚¤ë§ˆ.

    Attributes:
        status: ì„œë²„ ìƒíƒœ ("ok" ë˜ëŠ” "degraded")
        version: ë°±ì—”ë“œ ë²„ì „
        service: ì„œë¹„ìŠ¤ ì´ë¦„
    """

    status: Literal["ok", "degraded"]
    version: str
    service: str


# =============================================================================
# ë¼ìš°íŠ¸ ì •ì˜
# =============================================================================


@app.get("/health", response_model=HealthResponse, tags=["System"])
async def health_check() -> HealthResponse:
    """ì„œë²„ í—¬ìŠ¤ì²´í¬ ì—”ë“œí¬ì¸íŠ¸.

    ì„œë²„ê°€ ì •ìƒì ìœ¼ë¡œ ì‘ë™ ì¤‘ì¸ì§€ í™•ì¸í•©ë‹ˆë‹¤.
    ì´ ì—”ë“œí¬ì¸íŠ¸ëŠ” ë¡œë“œë°¸ëŸ°ì„œ, ëª¨ë‹ˆí„°ë§ ì‹œìŠ¤í…œ, í´ë¼ì´ì–¸íŠ¸ ì—°ê²° í™•ì¸ì— ì‚¬ìš©ë©ë‹ˆë‹¤.

    Returns:
        HealthResponse: ì„œë²„ ìƒíƒœ ì •ë³´
    """
    return HealthResponse(
        status="ok",
        version=__version__,
        service="unknown-world-backend",
    )


@app.get("/", tags=["System"])
async def root() -> dict[str, str]:
    """ë£¨íŠ¸ ì—”ë“œí¬ì¸íŠ¸.

    API ì •ë³´ë¥¼ ê°„ëµíˆ ì•ˆë‚´í•©ë‹ˆë‹¤.

    Returns:
        dict: ê¸°ë³¸ ì•ˆë‚´ ë©”ì‹œì§€
    """
    return {
        "message": "Unknown World API",
        "docs": "/docs",
        "health": "/health",
    }
</file>

<file path="backend/src/unknown_world/orchestrator/mock.py">
"""Unknown World - ëª¨ì˜ Orchestrator.

ì‹¤ëª¨ë¸(Gemini) ì—†ì´ í”„ë¡ íŠ¸ì—”ë“œ ê°œë°œ/ë°ëª¨ë¥¼ ì§€ì†í•  ìˆ˜ ìˆë„ë¡
ê²°ì •ì (seed ê¸°ë°˜) TurnOutputì„ ìƒì„±í•˜ëŠ” ëª¨ì˜ Orchestratorì…ë‹ˆë‹¤.

ì„¤ê³„ ì›ì¹™:
    - RULE-004: ê²€ì¦ ì‹¤íŒ¨ ì‹œ ì•ˆì „í•œ í´ë°± ì œê³µ
    - RULE-005: ì¬í™” ì¸ë°”ë¦¬ì–¸íŠ¸ (ì”ì•¡ ìŒìˆ˜ ê¸ˆì§€)
    - RULE-008: ë‹¨ê³„/ë°°ì§€ ê°€ì‹œí™”
    - RULE-009: ì¢Œí‘œ ê·œì•½ (0~1000, bbox [ymin,xmin,ymax,xmax])

ì°¸ì¡°:
    - vibe/unit-plans/U-007[Mvp].md
    - .cursor/rules/20-backend-orchestrator.mdc
"""

import random

from unknown_world.models.turn import (
    ActionCard,
    ActionDeck,
    AgentConsole,
    AgentPhase,
    Box2D,
    CurrencyAmount,
    EconomyOutput,
    ImageJob,
    Language,
    MemoryPin,
    ModelLabel,
    Quest,
    RenderOutput,
    RiskLevel,
    SafetyOutput,
    SceneObject,
    TurnInput,
    TurnOutput,
    UIOutput,
    ValidationBadge,
    WorldDelta,
    WorldRule,
)

# =============================================================================
# ëª¨ì˜ ë°ì´í„° ìƒì„± í—¬í¼
# =============================================================================

# í•œêµ­ì–´ ë‚´ëŸ¬í‹°ë¸Œ í…œí”Œë¦¿
KO_NARRATIVES = [
    "ì–´ë‘  ì†ì—ì„œ í¬ë¯¸í•œ ë¹›ì´ ìƒˆì–´ë‚˜ì˜µë‹ˆë‹¤. ì˜¤ë˜ëœ ë¬¸ì´ ì‚ê±±ê±°ë¦¬ë©° ì—´ë¦¬ê³ , ê·¸ ë„ˆë¨¸ë¡œ ì•Œ ìˆ˜ ì—†ëŠ” ì„¸ê³„ê°€ í¼ì³ì§‘ë‹ˆë‹¤.",
    "ë°œê±¸ìŒ ì†Œë¦¬ê°€ í…… ë¹ˆ ë³µë„ì— ë©”ì•„ë¦¬ì¹©ë‹ˆë‹¤. ë²½ì— ê±¸ë¦° ì´ˆìƒí™”ë“¤ì˜ ëˆˆì´ ë‹¹ì‹ ì„ ë”°ë¼ ì›€ì§ì´ëŠ” ê²ƒ ê°™ìŠµë‹ˆë‹¤.",
    "ê°‘ìê¸° ë°”ë‹¥ì´ í”ë“¤ë¦¬ë©°, ë²½ì—ì„œ ê³ ëŒ€ì˜ ë¬¸ìë“¤ì´ ë¹›ë‚˜ê¸° ì‹œì‘í•©ë‹ˆë‹¤. ë¬´ì–¸ê°€ê°€ ê¹¨ì–´ë‚˜ê³  ìˆìŠµë‹ˆë‹¤.",
    "ì•ˆê°œê°€ ê±·íˆì, ê±°ëŒ€í•œ íƒ‘ì´ ëª¨ìŠµì„ ë“œëŸ¬ëƒ…ë‹ˆë‹¤. íƒ‘ ê¼­ëŒ€ê¸°ì—ì„œ ì´ìƒí•œ ë¹›ì´ ê¹œë¹¡ì´ê³  ìˆìŠµë‹ˆë‹¤.",
    "ë‚¡ì€ ì±…ì¥ì„ ë°€ì, ìˆ¨ê²¨ì§„ í†µë¡œê°€ ë‚˜íƒ€ë‚¬ìŠµë‹ˆë‹¤. í†µë¡œ ëì—ì„œ ê¸°ë¬˜í•œ ë…¸ë˜ê°€ ë“¤ë ¤ì˜µë‹ˆë‹¤.",
]

# ì˜ì–´ ë‚´ëŸ¬í‹°ë¸Œ í…œí”Œë¦¿
EN_NARRATIVES = [
    "A faint light seeps through the darkness. An ancient door creaks open, revealing an unknown world beyond.",
    "Footsteps echo through the empty corridor. The eyes of the portraits on the walls seem to follow you.",
    "Suddenly, the ground shakes and ancient runes on the walls begin to glow. Something is awakening.",
    "As the fog lifts, a massive tower reveals itself. A strange light flickers at its peak.",
    "Pushing aside the old bookshelf, you discover a hidden passage. An eerie song emanates from its depths.",
]

# í•œêµ­ì–´ ì•¡ì…˜ ì¹´ë“œ í…œí”Œë¦¿
KO_ACTION_CARDS = [
    {"label": "ë¬¸ì„ ì—´ì–´ë³¸ë‹¤", "description": "ì¡°ì‹¬ìŠ¤ëŸ½ê²Œ ë¬¸ì„ ì—´ì–´ ì•ˆì„ ì‚´í´ë³¸ë‹¤"},
    {"label": "ì£¼ë³€ì„ íƒìƒ‰í•œë‹¤", "description": "ì£¼ë³€ì— ìœ ìš©í•œ ë¬¼ê±´ì´ ìˆëŠ”ì§€ ì°¾ì•„ë³¸ë‹¤"},
    {"label": "ë’¤ë¡œ ë¬¼ëŸ¬ì„ ë‹¤", "description": "ìœ„í—˜ì„ í”¼í•´ ì•ˆì „í•œ ê³³ìœ¼ë¡œ ë¬¼ëŸ¬ì„ ë‹¤"},
    {"label": "ë§ì„ ê±¸ì–´ë³¸ë‹¤", "description": "ìƒëŒ€ë°©ì—ê²Œ ì¡°ì‹¬ìŠ¤ëŸ½ê²Œ ë§ì„ ê±´ë‹¤"},
    {"label": "ìˆ¨ì–´ì„œ ì§€ì¼œë³¸ë‹¤", "description": "ì€ì‹ í•˜ì—¬ ìƒí™©ì„ ê´€ì°°í•œë‹¤"},
    {"label": "ê³µê²©í•œë‹¤", "description": "ìœ„í˜‘ì— ë§ì„œ ê³µê²©ì„ ì‹œë„í•œë‹¤"},
]

# ì˜ì–´ ì•¡ì…˜ ì¹´ë“œ í…œí”Œë¦¿
EN_ACTION_CARDS = [
    {"label": "Open the door", "description": "Carefully open the door and look inside"},
    {"label": "Search the area", "description": "Look for useful items nearby"},
    {"label": "Step back", "description": "Retreat to a safe place to avoid danger"},
    {"label": "Speak to them", "description": "Cautiously initiate conversation"},
    {"label": "Hide and observe", "description": "Conceal yourself and watch the situation"},
    {"label": "Attack", "description": "Confront the threat with an attack"},
]

# ì¥ë©´ ì˜¤ë¸Œì íŠ¸ í…œí”Œë¦¿
SCENE_OBJECTS_KO = [
    {"label": "ë‚¡ì€ ë¬¸", "hint": "í´ë¦­í•˜ì—¬ ì—´ì–´ë³¼ ìˆ˜ ìˆìŠµë‹ˆë‹¤"},
    {"label": "ë¹›ë‚˜ëŠ” ë³´ì„", "hint": "ìˆ˜ì§‘í•  ìˆ˜ ìˆì„ ê²ƒ ê°™ìŠµë‹ˆë‹¤"},
    {"label": "ìˆ˜ìƒí•œ ìƒì", "hint": "ë¬´ì–¸ê°€ ë“¤ì–´ìˆì„ ìˆ˜ ìˆìŠµë‹ˆë‹¤"},
    {"label": "ë²½ì˜ ìŠ¤ìœ„ì¹˜", "hint": "ì‘ë™ì‹œí‚¬ ìˆ˜ ìˆìŠµë‹ˆë‹¤"},
]

SCENE_OBJECTS_EN = [
    {"label": "Old door", "hint": "Click to open"},
    {"label": "Glowing gem", "hint": "It looks collectible"},
    {"label": "Suspicious chest", "hint": "Something might be inside"},
    {"label": "Wall switch", "hint": "Can be activated"},
]


def _generate_random_box(rng: random.Random) -> Box2D:
    """ëœë¤ ë°”ìš´ë”© ë°•ìŠ¤ ìƒì„± (0~1000 ì¢Œí‘œê³„)."""
    ymin = rng.randint(0, 700)
    xmin = rng.randint(0, 700)
    ymax = ymin + rng.randint(50, 250)
    xmax = xmin + rng.randint(50, 250)
    # ë²”ìœ„ ë³´ì •
    ymax = min(ymax, 1000)
    xmax = min(xmax, 1000)
    return Box2D(ymin=ymin, xmin=xmin, ymax=ymax, xmax=xmax)


# =============================================================================
# MockOrchestrator í´ë˜ìŠ¤
# =============================================================================


class MockOrchestrator:
    """ëª¨ì˜ Orchestrator.

    ì‹¤ëª¨ë¸(Gemini) ì—†ì´ TurnOutputì„ ìƒì„±í•˜ëŠ” ëª¨ì˜ ì˜¤ì¼€ìŠ¤íŠ¸ë ˆì´í„°ì…ë‹ˆë‹¤.
    seed ê¸°ë°˜ìœ¼ë¡œ ê²°ì •ì (ì¬í˜„ ê°€ëŠ¥)ì¸ ê²°ê³¼ë¥¼ ìƒì„±í•©ë‹ˆë‹¤.

    Attributes:
        seed: ëœë¤ ì‹œë“œ (ì¬í˜„ì„± ë³´ì¥)

    Example:
        >>> orchestrator = MockOrchestrator(seed=42)
        >>> turn_input = TurnInput(
        ...     language=Language.KO,
        ...     text="ë¬¸ì„ ì—´ì–´ë³¸ë‹¤",
        ...     client=ClientInfo(viewport_w=1920, viewport_h=1080),
        ...     economy_snapshot=EconomySnapshot(signal=100, memory_shard=5),
        ... )
        >>> output = orchestrator.generate_turn_output(turn_input)
    """

    # ë‹¨ê³„ ëª©ë¡ (PRD ì˜ˆì‹œ)
    PHASES = [
        AgentPhase.PARSE,
        AgentPhase.VALIDATE,
        AgentPhase.PLAN,
        AgentPhase.RESOLVE,
        AgentPhase.RENDER,
        AgentPhase.VERIFY,
        AgentPhase.COMMIT,
    ]

    def __init__(self, seed: int | None = None) -> None:
        """MockOrchestrator ì´ˆê¸°í™”.

        Args:
            seed: ëœë¤ ì‹œë“œ. Noneì´ë©´ ëœë¤í•˜ê²Œ ìƒì„±.
        """
        self.seed = seed if seed is not None else random.randint(0, 2**32 - 1)
        self._rng = random.Random(self.seed)

    def generate_turn_output(self, turn_input: TurnInput) -> TurnOutput:
        """TurnInputì„ ë°›ì•„ TurnOutputì„ ìƒì„±í•©ë‹ˆë‹¤.

        Args:
            turn_input: ì‚¬ìš©ì ì…ë ¥

        Returns:
            TurnOutput: ëª¨ì˜ í„´ ê²°ê³¼
        """
        is_korean = turn_input.language == Language.KO

        # ë‚´ëŸ¬í‹°ë¸Œ ìƒì„±
        narratives = KO_NARRATIVES if is_korean else EN_NARRATIVES
        narrative = self._rng.choice(narratives)

        # ì‚¬ìš©ì í…ìŠ¤íŠ¸ê°€ ìˆìœ¼ë©´ ë°˜ì˜
        if turn_input.text:
            prefix = (
                f'ë‹¹ì‹ ì€ "{turn_input.text}"ë¼ê³  ë§í–ˆìŠµë‹ˆë‹¤. '
                if is_korean
                else f'You said "{turn_input.text}". '
            )
            narrative = prefix + narrative

        # ì•¡ì…˜ ë± ìƒì„± (3~6ì¥)
        action_templates = KO_ACTION_CARDS if is_korean else EN_ACTION_CARDS
        num_cards = self._rng.randint(3, 6)
        selected_templates = self._rng.sample(
            action_templates, min(num_cards, len(action_templates))
        )

        action_cards: list[ActionCard] = []
        for i, template in enumerate(selected_templates):
            cost_signal = self._rng.randint(1, 10)
            cost_shard = 1 if self._rng.random() < 0.2 else 0  # 20% í™•ë¥ ë¡œ shard ì†Œë¹„

            action_cards.append(
                ActionCard(
                    id=f"action_{i + 1}",
                    label=template["label"],
                    description=template["description"],
                    cost=CurrencyAmount(signal=cost_signal, memory_shard=cost_shard),
                    risk=self._rng.choice(list(RiskLevel)),
                    hint=None,
                )
            )

        action_deck = ActionDeck(cards=action_cards)

        # ì¥ë©´ ì˜¤ë¸Œì íŠ¸ ìƒì„± (1~3ê°œ)
        object_templates = SCENE_OBJECTS_KO if is_korean else SCENE_OBJECTS_EN
        num_objects = self._rng.randint(1, 3)
        selected_objects = self._rng.sample(
            object_templates, min(num_objects, len(object_templates))
        )

        scene_objects: list[SceneObject] = []
        for i, template in enumerate(selected_objects):
            scene_objects.append(
                SceneObject(
                    id=f"obj_{i + 1}",
                    label=template["label"],
                    box_2d=_generate_random_box(self._rng),
                    interaction_hint=template["hint"],
                )
            )

        ui_output = UIOutput(action_deck=action_deck, objects=scene_objects)

        # ì„¸ê³„ ìƒíƒœ ë³€í™” (delta)
        world_delta = self._generate_world_delta(is_korean)

        # ë Œë”ë§ ì¶œë ¥ (ì´ë¯¸ì§€ ìƒì„±ì€ ì„ íƒì )
        should_generate_image = self._rng.random() < 0.3  # 30% í™•ë¥ ë¡œ ì´ë¯¸ì§€ ìƒì„±
        render_output = RenderOutput(
            image_job=ImageJob(
                should_generate=should_generate_image,
                prompt="A mysterious dungeon scene" if should_generate_image else "",
                model_label=ModelLabel.FAST,
                aspect_ratio="16:9",
                image_size="1024x576",
            )
            if should_generate_image
            else None
        )

        # ê²½ì œ ì¶œë ¥ (ë¹„ìš© ê³„ì‚°)
        turn_cost = CurrencyAmount(
            signal=self._rng.randint(1, 5),
            memory_shard=0,
        )

        # ì”ì•¡ ê³„ì‚° (ìŒìˆ˜ ë°©ì§€ - RULE-005)
        balance_signal = max(0, turn_input.economy_snapshot.signal - turn_cost.signal)
        balance_shard = max(0, turn_input.economy_snapshot.memory_shard - turn_cost.memory_shard)

        economy_output = EconomyOutput(
            cost=turn_cost,
            balance_after=CurrencyAmount(signal=balance_signal, memory_shard=balance_shard),
        )

        # ì•ˆì „ ì¶œë ¥
        safety_output = SafetyOutput(blocked=False, message=None)

        # ì—ì´ì „íŠ¸ ì½˜ì†”
        agent_console = AgentConsole(
            current_phase=AgentPhase.COMMIT,
            badges=[
                ValidationBadge.SCHEMA_OK,
                ValidationBadge.ECONOMY_OK,
                ValidationBadge.SAFETY_OK,
                ValidationBadge.CONSISTENCY_OK,
            ],
            repair_count=0,
        )

        return TurnOutput(
            language=turn_input.language,
            narrative=narrative,
            ui=ui_output,
            world=world_delta,
            render=render_output,
            economy=economy_output,
            safety=safety_output,
            agent_console=agent_console,
        )

    def _generate_world_delta(self, is_korean: bool) -> WorldDelta:
        """ì„¸ê³„ ìƒíƒœ ë³€í™” ìƒì„±."""
        # ê·œì¹™ ë³€ê²½ (20% í™•ë¥ )
        rules_changed: list[WorldRule] = []
        if self._rng.random() < 0.2:
            rules_changed.append(
                WorldRule(
                    id="rule_gravity",
                    label="ì¤‘ë ¥ ë°˜ì „" if is_korean else "Gravity Inversion",
                    description=(
                        "ì´ êµ¬ì—­ì—ì„œëŠ” ì¤‘ë ¥ì´ ë°˜ëŒ€ë¡œ ì‘ìš©í•©ë‹ˆë‹¤"
                        if is_korean
                        else "Gravity works in reverse in this area"
                    ),
                )
            )

        # ì¸ë²¤í† ë¦¬ ì¶”ê°€ (30% í™•ë¥ )
        inventory_added: list[str] = []
        if self._rng.random() < 0.3:
            items_ko = ["ë‚¡ì€ ì—´ì‡ ", "ì‹ ë¹„ë¡œìš´ êµ¬ìŠ¬", "ê³ ëŒ€ì˜ ë‘ë£¨ë§ˆë¦¬"]
            items_en = ["Old Key", "Mysterious Orb", "Ancient Scroll"]
            items = items_ko if is_korean else items_en
            inventory_added.append(self._rng.choice(items))

        # í€˜ìŠ¤íŠ¸ ì—…ë°ì´íŠ¸ (25% í™•ë¥ )
        quests_updated: list[Quest] = []
        if self._rng.random() < 0.25:
            quests_updated.append(
                Quest(
                    id="quest_explore",
                    label="ë¯¸ì§€ì˜ ì˜ì—­ íƒí—˜" if is_korean else "Explore Unknown Territory",
                    is_completed=self._rng.random() < 0.3,
                )
            )

        # ë©”ëª¨ë¦¬ í•€ (15% í™•ë¥ )
        memory_pins: list[MemoryPin] = []
        if self._rng.random() < 0.15:
            memory_pins.append(
                MemoryPin(
                    id="pin_1",
                    content="ì´ ì¥ì†Œì˜ ì´ë¦„ì€ 'ìŠí˜€ì§„ ì„±ì†Œ'"
                    if is_korean
                    else "This place is called 'Forgotten Sanctuary'",
                    cost=CurrencyAmount(signal=0, memory_shard=1),
                )
            )

        return WorldDelta(
            rules_changed=rules_changed,
            inventory_added=inventory_added,
            inventory_removed=[],
            quests_updated=quests_updated,
            relationships_changed=[],
            memory_pins=memory_pins,
        )

    def create_safe_fallback(
        self,
        language: Language,
        error_message: str | None = None,
        economy_snapshot: CurrencyAmount | None = None,
    ) -> TurnOutput:
        """ì•ˆì „í•œ í´ë°± TurnOutput ìƒì„± (RULE-004, RU-002-S1).

        ìŠ¤í‚¤ë§ˆ ê²€ì¦ ì‹¤íŒ¨ ì‹œ ë°˜í™˜í•  ì•ˆì „í•œ ê¸°ë³¸ ì‘ë‹µì…ë‹ˆë‹¤.
        í´ë°± ì‹œ economy.balance_afterëŠ” ì…ë ¥ ìŠ¤ëƒ…ìƒ·ì„ ê·¸ëŒ€ë¡œ ìœ ì§€í•©ë‹ˆë‹¤ (ë¹„ìš© 0, ì”ì•¡ ë³€í™” ì—†ìŒ).

        Args:
            language: ì‘ë‹µ ì–¸ì–´
            error_message: ì—ëŸ¬ ë©”ì‹œì§€ (ë‚´ë¶€ìš©, UIì— ë…¸ì¶œí•˜ì§€ ì•ŠìŒ)
            economy_snapshot: ìš”ì²­ ì§ì „ ì¬í™” ìŠ¤ëƒ…ìƒ· (í´ë°± ì‹œ ì”ì•¡ ìœ ì§€ìš©)

        Returns:
            TurnOutput: ì•ˆì „í•œ í´ë°± ì‘ë‹µ
        """
        is_korean = language == Language.KO

        narrative = (
            "ì ì‹œ í˜¼ë€ì´ ìˆì—ˆìŠµë‹ˆë‹¤. ë‹¤ì‹œ ì‹œë„í•´ì£¼ì„¸ìš”."
            if is_korean
            else "There was a momentary confusion. Please try again."
        )

        # RU-002-S1: í´ë°± ì‹œ ì…ë ¥ ìŠ¤ëƒ…ìƒ· ê·¸ëŒ€ë¡œ ìœ ì§€ (ë¹„ìš© 0, ì”ì•¡ ë³€í™” ì—†ìŒ)
        balance_after = (
            economy_snapshot
            if economy_snapshot is not None
            else CurrencyAmount(signal=100, memory_shard=5)  # ê¸°ë³¸ê°’ (ìŠ¤ëƒ…ìƒ· ì—†ì„ ë•Œë§Œ)
        )

        return TurnOutput(
            language=language,
            narrative=narrative,
            ui=UIOutput(action_deck=ActionDeck(cards=[]), objects=[]),
            world=WorldDelta(),
            render=RenderOutput(image_job=None),
            economy=EconomyOutput(
                cost=CurrencyAmount(signal=0, memory_shard=0),
                balance_after=balance_after,
            ),
            safety=SafetyOutput(blocked=False, message=None),
            agent_console=AgentConsole(
                current_phase=AgentPhase.COMMIT,
                badges=[ValidationBadge.SCHEMA_FAIL],  # ì‹¤íŒ¨ í‘œì‹œ
                repair_count=1,  # ë³µêµ¬ ì‹œë„ íšŸìˆ˜
            ),
        )
</file>

<file path="frontend/src/api/turnStream.test.ts">
import { describe, it, expect, vi, beforeEach } from 'vitest';
import { NDJSONParser } from './turnStream';

describe('NDJSONParser', () => {
  let parser: NDJSONParser;

  beforeEach(() => {
    parser = new NDJSONParser();
  });

  it('should parse a single complete line', () => {
    const chunk = JSON.stringify({ type: 'test', value: 1 }) + '\n';
    const results = parser.parse(chunk);
    expect(results).toHaveLength(1);
    expect(results[0]).toEqual({ type: 'test', value: 1 });
  });

  it('should parse multiple complete lines in one chunk', () => {
    const chunk = JSON.stringify({ id: 1 }) + '\n' + JSON.stringify({ id: 2 }) + '\n';
    const results = parser.parse(chunk);
    expect(results).toHaveLength(2);
    expect(results[0]).toEqual({ id: 1 });
    expect(results[1]).toEqual({ id: 2 });
  });

  it('should buffer partial lines and parse them when completed', () => {
    const chunk1 = '{"id": 1';
    const chunk2 = ', "val": "ok"}\n';

    const results1 = parser.parse(chunk1);
    expect(results1).toHaveLength(0);

    const results2 = parser.parse(chunk2);
    expect(results2).toHaveLength(1);
    expect(results2[0]).toEqual({ id: 1, val: 'ok' });
  });

  it('should ignore empty lines', () => {
    const chunk = '\n\n{"a":1}\n\n';
    const results = parser.parse(chunk);
    expect(results).toHaveLength(1);
  });

  it('should not crash on invalid JSON and continue', () => {
    const consoleSpy = vi.spyOn(console, 'warn').mockImplementation(() => {});
    const chunk = 'invalid json\n{"valid": true}\n';
    const results = parser.parse(chunk);

    expect(results).toHaveLength(1);
    expect(results[0]).toEqual({ valid: true });
    expect(consoleSpy).toHaveBeenCalled();
    consoleSpy.mockRestore();
  });

  it('should flush remaining buffer', () => {
    parser.parse('{"id": 1}'); // No newline
    const result = parser.flush();
    expect(result).toEqual({ id: 1 });
  });

  it('should return null on flush with empty buffer', () => {
    const result = parser.flush();
    expect(result).toBeNull();
  });
});

describe('executeTurnStream', () => {
  const mockInput = {
    language: 'ko-KR' as const,
    text: 'Hello',
    action_id: null,
    click: null,
    client: { viewport_w: 100, viewport_h: 100, theme: 'dark' as const },
    economy_snapshot: { signal: 100, memory_shard: 0 },
  };

  const mockCallbacks = {
    onStage: vi.fn(),
    onRepair: vi.fn(),
    onBadges: vi.fn(),
    onNarrativeDelta: vi.fn(),
    onFinal: vi.fn(),
    onError: vi.fn(),
    onComplete: vi.fn(),
  };

  beforeEach(() => {
    vi.clearAllMocks();
    global.fetch = vi.fn();
  });

  it('should process stream events correctly (including repair)', async () => {
    const encoder = new TextEncoder();
    const stream = new ReadableStream({
      start(controller) {
        controller.enqueue(
          encoder.encode(JSON.stringify({ type: 'stage', name: 'parse', status: 'start' }) + '\n'),
        );
        controller.enqueue(
          encoder.encode(
            JSON.stringify({ type: 'repair', attempt: 1, message: 'Schema fail, retrying' }) + '\n',
          ),
        );
        controller.enqueue(
          encoder.encode(JSON.stringify({ type: 'narrative_delta', text: 'Hello' }) + '\n'),
        );
        controller.enqueue(
          encoder.encode(
            JSON.stringify({
              type: 'final',
              data: {
                language: 'ko-KR',
                narrative: 'Hello',
                economy: {
                  cost: { signal: 0, memory_shard: 0 },
                  balance_after: { signal: 100, memory_shard: 0 },
                },
                safety: { blocked: false },
              },
            }) + '\n',
          ),
        );
        controller.close();
      },
    });

    (global.fetch as unknown as ReturnType<typeof vi.fn>).mockResolvedValue({
      ok: true,
      body: stream,
    });

    const { executeTurnStream } = await import('./turnStream');
    await executeTurnStream(mockInput, mockCallbacks);

    expect(mockCallbacks.onStage).toHaveBeenCalledWith(expect.objectContaining({ name: 'parse' }));
    expect(mockCallbacks.onRepair).toHaveBeenCalledWith(
      expect.objectContaining({ attempt: 1, message: 'Schema fail, retrying' }),
    );
    expect(mockCallbacks.onNarrativeDelta).toHaveBeenCalledWith(
      expect.objectContaining({ text: 'Hello' }),
    );
    expect(mockCallbacks.onFinal).toHaveBeenCalled();
    expect(mockCallbacks.onComplete).toHaveBeenCalled();
  });

  it('should handle HTTP errors', async () => {
    (global.fetch as unknown as ReturnType<typeof vi.fn>).mockResolvedValue({
      ok: false,
      status: 500,
      statusText: 'Internal Server Error',
    });

    const { executeTurnStream } = await import('./turnStream');
    await executeTurnStream(mockInput, mockCallbacks);

    expect(mockCallbacks.onError).toHaveBeenCalledWith(
      expect.objectContaining({
        code: 'STREAM_ERROR',
        message: expect.stringContaining('500'),
      }),
    );
  });

  it('should handle fetch rejection', async () => {
    (global.fetch as unknown as ReturnType<typeof vi.fn>).mockRejectedValue(
      new Error('Network failure'),
    );

    const { executeTurnStream } = await import('./turnStream');
    await executeTurnStream(mockInput, mockCallbacks);

    expect(mockCallbacks.onError).toHaveBeenCalledWith(
      expect.objectContaining({
        message: 'Network failure',
      }),
    );
  });
});
</file>

<file path="frontend/src/locales/ko-KR/translation.json">
{
  "scene": {
    "status": {
      "default": "ë°ì´í„° ëŒ€ê¸° ì¤‘",
      "loading": "ë™ê¸°í™” ì¤‘...",
      "offline": "ì—°ê²° ëŠê¹€",
      "blocked": "ì ‘ê·¼ ì œí•œë¨",
      "low_signal": "ì‹ í˜¸ ì•½í•¨",
      "image_error": "ì¥ë©´ ì´ë¯¸ì§€ë¥¼ ë¶ˆëŸ¬ì˜¬ ìˆ˜ ì—†ìŠµë‹ˆë‹¤.",
      "initial_sync": "ì „ì—­ ë°ì´í„° ë™ê¸°í™” ëŒ€ê¸° ì¤‘...",
      "syncing": "ë°ì´í„° ë™ê¸°í™” ì¤‘...",
      "alt": "ì¥ë©´ ì´ë¯¸ì§€"
    },
    "hotspot": {
      "layer_label": "í´ë¦­ ê°€ëŠ¥í•œ ì˜¤ë¸Œì íŠ¸ ì˜ì—­",
      "hint_prefix": "íŒíŠ¸",
      "click_action": "{{label}} í´ë¦­"
    }
  },
  "agent": {
    "console": {
      "queue": "ëŒ€ê¸°ì—´",
      "badges": "ê²€ì¦ ë°°ì§€",
      "repair": "ìë™ ë³µêµ¬",
      "status": {
        "idle": "ëŒ€ê¸° ì¤‘",
        "processing": "ì²˜ë¦¬ ì¤‘"
      },
      "badges_empty": "[ ê²€ì¦ ëŒ€ê¸° ì¤‘ ]",
      "repaired": "(ë³µêµ¬ë¨)",
      "phase": {
        "parse": "Parse",
        "validate": "Validate",
        "plan": "Plan",
        "resolve": "Resolve",
        "render": "Render",
        "verify": "Verify",
        "commit": "Commit"
      },
      "badge": {
        "schema": "Schema",
        "economy": "Economy",
        "safety": "Safety",
        "consistency": "Consistency",
        "ok": "OK",
        "fail": "FAIL"
      }
    }
  },
  "ui": {
    "logo": "UNKNOWN WORLD",
    "command_placeholder": "ëª…ë ¹ì„ ì…ë ¥í•˜ì„¸ìš”...",
    "processing": "ì²˜ë¦¬ ì¤‘...",
    "execute": "ì‹¤í–‰",
    "wait": "ëŒ€ê¸°",
    "panel_placeholder": "[ ì¤€ë¹„ ì¤‘ ]",
    "scale_decrease": "ê¸€ì í¬ê¸° ì¤„ì´ê¸°",
    "scale_increase": "ê¸€ì í¬ê¸° ëŠ˜ë¦¬ê¸°",
    "scale_label": "UI ìŠ¤ì¼€ì¼ ì„¤ì •"
  },
  "economy": {
    "signal": "Signal",
    "shard": "Shard",
    "signal_cost": "Signal ì†Œëª¨",
    "shard_cost": "Shard ì†Œëª¨",
    "risk_level": "ìœ„í—˜ë„"
  },
  "connection": {
    "online": "ì˜¨ë¼ì¸",
    "offline": "ì˜¤í”„ë¼ì¸"
  },
  "panel": {
    "inventory": {
      "title": "Inventory",
      "placeholder": "[ ë“œë˜ê·¸ ì•¤ ë“œë¡­ ì˜ì—­ ]"
    },
    "quest": {
      "title": "Quest",
      "placeholder": "[ ëª©í‘œ/í€˜ìŠ¤íŠ¸ ëª©ë¡ ]"
    },
    "rule_board": {
      "title": "Rule Board",
      "placeholder": "[ ì›”ë“œ ê·œì¹™/ë³€í˜• íƒ€ì„ë¼ì¸ ]"
    },
    "agent_console": {
      "title": "Agent Console"
    },
    "memory_pin": {
      "title": "Memory Pin",
      "placeholder": "[ ê³ ì •ëœ ê¸°ì–µ/ë‹¨ì„œ ]"
    },
    "scanner": {
      "title": "Scanner",
      "placeholder": "[ ì´ë¯¸ì§€ ì—…ë¡œë“œ ìŠ¬ë¡¯ ]"
    }
  },
  "action": {
    "default": {
      "explore": {
        "label": "íƒìƒ‰í•˜ê¸°",
        "description": "ì£¼ë³€ì„ ì‚´í´ë³¸ë‹¤"
      },
      "investigate": {
        "label": "ì¡°ì‚¬í•˜ê¸°",
        "description": "ìì„¸íˆ ì‚´í´ë³¸ë‹¤"
      },
      "talk": {
        "label": "ëŒ€í™”í•˜ê¸°",
        "description": "ë§ì„ ê±¸ì–´ë³¸ë‹¤"
      }
    },
    "card_select": "ì¹´ë“œ ì„ íƒ: {{cardId}}",
    "deck_label": "í–‰ë™ ì„ íƒ ì¹´ë“œ",
    "alternative": "ëŒ€ì•ˆ",
    "insufficient_balance": "ì”ì•¡ ë¶€ì¡±",
    "all_disabled_notice": "ì‹¤í–‰ ê°€ëŠ¥í•œ í–‰ë™ì´ ì—†ìŠµë‹ˆë‹¤. ëŒ€ì•ˆì„ í™•ì¸í•˜ì„¸ìš”.",
    "risk": {
      "low": "ë‚®ìŒ",
      "medium": "ë³´í†µ",
      "high": "ë†’ìŒ"
    },
    "cost_range": "{{min}}~{{max}}"
  },
  "narrative": {
    "welcome": "ë¯¸ì§€ì˜ ì„¸ê³„ì— ì˜¤ì‹  ê²ƒì„ í™˜ì˜í•©ë‹ˆë‹¤...",
    "turn_label": "[TURN {{turn}}]",
    "streaming_label": "[STREAMING]"
  }
}
</file>

<file path="frontend/src/stores/agentStore.ts">
/**
 * Unknown World - Agent Console ìƒíƒœ ê´€ë¦¬ (Zustand).
 *
 * ìŠ¤íŠ¸ë¦¬ë° ì¤‘ ìˆ˜ì‹ ë˜ëŠ” ë‹¨ê³„/ë°°ì§€/ë‚´ëŸ¬í‹°ë¸Œ/ë³µêµ¬ ì •ë³´ë¥¼ ì €ì¥í•˜ê³ ,
 * AgentConsole ì»´í¬ë„ŒíŠ¸ì—ì„œ êµ¬ë…í•  ìˆ˜ ìˆë„ë¡ í•©ë‹ˆë‹¤.
 *
 * ì„¤ê³„ ì›ì¹™:
 *   - RULE-008: ë‹¨ê³„/ë°°ì§€ ê°€ì‹œí™” (í”„ë¡¬í”„íŠ¸/ë‚´ë¶€ ì¶”ë¡  ë…¸ì¶œ ê¸ˆì§€)
 *   - RULE-003/004: ê²€ì¦ í›„ ìƒíƒœ ë°˜ì˜, ì‹¤íŒ¨ ì‹œ í´ë°±
 *
 * @module stores/agentStore
 */

import { create } from 'zustand';
import type { AgentPhase, ValidationBadge, TurnOutput } from '../schemas/turn';
import type {
  StageEvent,
  BadgesEvent,
  NarrativeDeltaEvent,
  FinalEvent,
  ErrorEvent,
} from '../types/turn_stream';
import { StageStatus } from '../types/turn_stream';

// =============================================================================
// ìƒíƒœ íƒ€ì… ì •ì˜
// =============================================================================

/** ë‹¨ê³„ ìƒíƒœ */
export type PhaseStatus = 'pending' | 'in_progress' | 'completed' | 'failed';

/** ë‹¨ê³„ ì •ë³´ */
export interface PhaseInfo {
  name: AgentPhase;
  status: PhaseStatus;
}

/** ì—ëŸ¬ ì •ë³´ */
export interface AgentError {
  message: string;
  code?: string;
}

/** Agent Console ìƒíƒœ */
export interface AgentState {
  /** í˜„ì¬ ìŠ¤íŠ¸ë¦¬ë° ì¤‘ì¸ì§€ */
  isStreaming: boolean;
  /** í˜„ì¬ ë‹¨ê³„ */
  currentPhase: AgentPhase | null;
  /** ë‹¨ê³„ë³„ ìƒíƒœ */
  phases: PhaseInfo[];
  /** ê²€ì¦ ë°°ì§€ ëª©ë¡ */
  badges: ValidationBadge[];
  /** ëˆ„ì  ë‚´ëŸ¬í‹°ë¸Œ í…ìŠ¤íŠ¸ (íƒ€ì íš¨ê³¼ìš©) */
  narrativeBuffer: string;
  /** ìë™ ë³µêµ¬ íšŸìˆ˜ */
  repairCount: number;
  /** ìµœì¢… TurnOutput */
  finalOutput: TurnOutput | null;
  /** ì—ëŸ¬ ì •ë³´ */
  error: AgentError | null;
}

/** Agent Console ì•¡ì…˜ */
export interface AgentActions {
  /** ìŠ¤íŠ¸ë¦¼ ì‹œì‘ */
  startStream: () => void;
  /** ë‹¨ê³„ ì´ë²¤íŠ¸ ì²˜ë¦¬ */
  handleStage: (event: StageEvent) => void;
  /** ë°°ì§€ ì´ë²¤íŠ¸ ì²˜ë¦¬ */
  handleBadges: (event: BadgesEvent) => void;
  /** ë‚´ëŸ¬í‹°ë¸Œ ë¸íƒ€ ì´ë²¤íŠ¸ ì²˜ë¦¬ */
  handleNarrativeDelta: (event: NarrativeDeltaEvent) => void;
  /** ìµœì¢… ì¶œë ¥ ì´ë²¤íŠ¸ ì²˜ë¦¬ */
  handleFinal: (event: FinalEvent) => void;
  /** ì—ëŸ¬ ì´ë²¤íŠ¸ ì²˜ë¦¬ */
  handleError: (event: ErrorEvent) => void;
  /** ìŠ¤íŠ¸ë¦¼ ì™„ë£Œ */
  completeStream: () => void;
  /** ìƒíƒœ ì´ˆê¸°í™” */
  reset: () => void;
}

export type AgentStore = AgentState & AgentActions;

// =============================================================================
// ì´ˆê¸° ìƒíƒœ
// =============================================================================

/** ê¸°ë³¸ ë‹¨ê³„ ëª©ë¡ (PRD ì˜ˆì‹œ) */
const DEFAULT_PHASES: AgentPhase[] = [
  'parse',
  'validate',
  'plan',
  'resolve',
  'render',
  'verify',
  'commit',
];

/** ì´ˆê¸° ìƒíƒœ ìƒì„± */
function createInitialState(): AgentState {
  return {
    isStreaming: false,
    currentPhase: null,
    phases: DEFAULT_PHASES.map((name) => ({
      name,
      status: 'pending' as const,
    })),
    badges: [],
    narrativeBuffer: '',
    repairCount: 0,
    finalOutput: null,
    error: null,
  };
}

// =============================================================================
// Zustand Store
// =============================================================================

/**
 * Agent Console ìƒíƒœ ìŠ¤í† ì–´.
 *
 * @example
 * ```tsx
 * // ì»´í¬ë„ŒíŠ¸ì—ì„œ ì‚¬ìš©
 * const { isStreaming, phases, badges } = useAgentStore();
 * const startStream = useAgentStore((state) => state.startStream);
 * ```
 */
export const useAgentStore = create<AgentStore>((set) => ({
  // ì´ˆê¸° ìƒíƒœ
  ...createInitialState(),

  // ì•¡ì…˜
  startStream: () => {
    set({
      ...createInitialState(),
      isStreaming: true,
    });
  },

  handleStage: (event) => {
    set((state) => {
      const phaseName = event.name;
      const eventStatus = event.status;

      // RU-002-S2: status ê°’ì— ë”°ë¥¸ ë‹¨ê³„ ìƒíƒœ ê²°ì •
      // 'start' â†’ in_progress
      // 'complete' ë˜ëŠ” 'ok' (ì •ê·œí™”ë¨) â†’ completed
      // 'fail' â†’ failed
      let newStatus: PhaseStatus;
      if (eventStatus === StageStatus.START) {
        newStatus = 'in_progress';
      } else if (eventStatus === 'fail') {
        newStatus = 'failed';
      } else {
        // 'complete' (ì •ê·œí™”ëœ 'ok' í¬í•¨)
        newStatus = 'completed';
      }

      // ë‹¨ê³„ ìƒíƒœ ì—…ë°ì´íŠ¸
      const phases = state.phases.map((phase) => {
        if (phase.name === phaseName) {
          return {
            ...phase,
            status: newStatus,
          };
        }
        return phase;
      });

      return {
        phases,
        currentPhase: eventStatus === StageStatus.START ? phaseName : state.currentPhase,
      };
    });
  },

  handleBadges: (event) => {
    set({
      badges: event.badges,
    });
  },

  handleNarrativeDelta: (event) => {
    set((state) => ({
      narrativeBuffer: state.narrativeBuffer + event.text,
    }));
  },

  handleFinal: (event) => {
    set({
      finalOutput: event.data,
      repairCount: event.data.agent_console?.repair_count ?? 0,
    });
  },

  handleError: (event) => {
    set({
      error: {
        message: event.message,
        code: event.code,
      },
    });
  },

  completeStream: () => {
    set({
      isStreaming: false,
      narrativeBuffer: '', // ìŠ¤íŠ¸ë¦¼ ì™„ë£Œ ì‹œ ë²„í¼ ì´ˆê¸°í™”
    });
  },

  reset: () => {
    set(createInitialState());
  },
}));

// =============================================================================
// ì…€ë ‰í„° (ì„±ëŠ¥ ìµœì í™”ìš©)
// =============================================================================

/** ìŠ¤íŠ¸ë¦¬ë° ìƒíƒœ ì…€ë ‰í„° */
export const selectIsStreaming = (state: AgentStore) => state.isStreaming;

/** í˜„ì¬ ë‹¨ê³„ ì…€ë ‰í„° */
export const selectCurrentPhase = (state: AgentStore) => state.currentPhase;

/** ë‹¨ê³„ ëª©ë¡ ì…€ë ‰í„° */
export const selectPhases = (state: AgentStore) => state.phases;

/** ë°°ì§€ ëª©ë¡ ì…€ë ‰í„° */
export const selectBadges = (state: AgentStore) => state.badges;

/** ë‚´ëŸ¬í‹°ë¸Œ ë²„í¼ ì…€ë ‰í„° */
export const selectNarrativeBuffer = (state: AgentStore) => state.narrativeBuffer;

/** ë³µêµ¬ íšŸìˆ˜ ì…€ë ‰í„° */
export const selectRepairCount = (state: AgentStore) => state.repairCount;

/** ìµœì¢… ì¶œë ¥ ì…€ë ‰í„° */
export const selectFinalOutput = (state: AgentStore) => state.finalOutput;

/** ì—ëŸ¬ ì…€ë ‰í„° */
export const selectError = (state: AgentStore) => state.error;
</file>

<file path="shared/schemas/turn/turn_input.schema.json">
{
  "$schema": "http://json-schema.org/draft-07/schema#",
  "$id": "https://unknown-world.dev/schemas/turn/turn_input.schema.json",
  "title": "TurnInput",
  "description": "Client â†’ Server í„´ ìš”ì²­ ìŠ¤í‚¤ë§ˆ (MVP). PRD 8.7ì ˆ ê¸°ë°˜.",
  "type": "object",
  "properties": {
    "language": {
      "type": "string",
      "enum": ["ko-KR", "en-US"],
      "description": "ê²Œì„ ì–¸ì–´ ì„¤ì • (ko-KR ë˜ëŠ” en-US)"
    },
    "text": {
      "type": "string",
      "description": "ì‚¬ìš©ì ì…ë ¥ (ìì—°ì–´)"
    },
    "click": {
      "type": ["object", "null"],
      "description": "í´ë¦­ëœ ì˜¤ë¸Œì íŠ¸ ì •ë³´ (ì„ íƒ)",
      "properties": {
        "object_id": {
          "type": "string",
          "description": "í´ë¦­ëœ ì˜¤ë¸Œì íŠ¸ ID"
        },
        "box_2d": {
          "type": ["array", "null"],
          "description": "bbox [ymin, xmin, ymax, xmax] (0~1000 ì •ê·œí™”)",
          "items": {
            "type": "integer",
            "minimum": 0,
            "maximum": 1000
          },
          "minItems": 4,
          "maxItems": 4
        }
      },
      "required": ["object_id"]
    },
    "client": {
      "type": "object",
      "description": "í´ë¼ì´ì–¸íŠ¸ í™˜ê²½ ì •ë³´",
      "properties": {
        "viewport_w": {
          "type": "integer",
          "description": "ë·°í¬íŠ¸ ë„ˆë¹„ (px)"
        },
        "viewport_h": {
          "type": "integer",
          "description": "ë·°í¬íŠ¸ ë†’ì´ (px)"
        },
        "theme": {
          "type": "string",
          "enum": ["dark", "light"],
          "description": "í…Œë§ˆ ì„¤ì •"
        }
      },
      "required": ["viewport_w", "viewport_h", "theme"]
    },
    "economy_snapshot": {
      "type": "object",
      "description": "í˜„ì¬ ì¬í™” ìƒíƒœ ìŠ¤ëƒ…ìƒ·",
      "properties": {
        "signal": {
          "type": "integer",
          "minimum": 0,
          "description": "Signal ì¬í™” ì”ì•¡"
        },
        "memory_shard": {
          "type": "integer",
          "minimum": 0,
          "description": "Memory Shard ì¬í™” ì”ì•¡"
        }
      },
      "required": ["signal", "memory_shard"]
    }
  },
  "required": ["language", "text", "client", "economy_snapshot"],
  "additionalProperties": false
}
</file>

<file path="backend/src/unknown_world/api/turn.py">
"""Unknown World - /api/turn HTTP Streaming ì—”ë“œí¬ì¸íŠ¸.

POST ìš”ì²­ì„ ë°›ì•„ NDJSON(ë¼ì¸ ë‹¨ìœ„ JSON) ìŠ¤íŠ¸ë¦¬ë°ìœ¼ë¡œ í„´ ê²°ê³¼ë¥¼ ë°˜í™˜í•©ë‹ˆë‹¤.

ì„¤ê³„ ì›ì¹™:
    - RULE-003: êµ¬ì¡°í™” ì¶œë ¥(JSON Schema) ìš°ì„  + Pydantic ê²€ì¦
    - RULE-004: ê²€ì¦ ì‹¤íŒ¨ ì‹œ Repair loop + ì•ˆì „í•œ í´ë°±
    - RULE-005: ì¬í™” ì¸ë°”ë¦¬ì–¸íŠ¸ (ì”ì•¡ ìŒìˆ˜ ê¸ˆì§€)
    - RULE-007: í”„ë¡¬í”„íŠ¸/ë‚´ë¶€ ì¶”ë¡  ë…¸ì¶œ ê¸ˆì§€
    - RULE-008: ë‹¨ê³„/ë°°ì§€ ê°€ì‹œí™”, TTFB 2ì´ˆ ëª©í‘œ

ìŠ¤íŠ¸ë¦¼ ì´ë²¤íŠ¸ íƒ€ì…:
    - stage: ë‹¨ê³„ ì§„í–‰ ìƒíƒœ (Parseâ†’Validateâ†’Planâ†’Resolveâ†’Renderâ†’Verifyâ†’Commit)
    - badges: ê²€ì¦ ë°°ì§€ ëª©ë¡
    - narrative_delta: ë‚´ëŸ¬í‹°ë¸Œ í…ìŠ¤íŠ¸ ì¡°ê° (íƒ€ì íš¨ê³¼ìš©)
    - final: ìµœì¢… TurnOutput
    - error: ì—ëŸ¬ ë°œìƒ ì‹œ

ì°¸ì¡°:
    - vibe/unit-plans/U-007[Mvp].md
    - .cursor/rules/20-backend-orchestrator.mdc
"""

import asyncio
import time
from collections.abc import AsyncGenerator
from typing import Any, cast

from fastapi import APIRouter, Request
from fastapi.responses import StreamingResponse
from pydantic import ValidationError

from unknown_world.api.turn_stream_events import (
    BadgesEvent,
    ErrorEvent,
    FinalEvent,
    NarrativeDeltaEvent,
    RepairEvent,
    StageEvent,
    StageStatus,
    StreamEventType,
    serialize_event,
)
from unknown_world.models.turn import (
    AgentPhase,
    CurrencyAmount,
    Language,
    TurnInput,
    ValidationBadge,
)
from unknown_world.orchestrator.mock import MockOrchestrator

# =============================================================================
# ë¼ìš°í„° ì •ì˜
# =============================================================================

router = APIRouter(prefix="/api", tags=["Turn"])

# ë‹¨ê³„ ëª©ë¡ (PRD ì˜ˆì‹œ)
ORCHESTRATOR_PHASES = [
    AgentPhase.PARSE,
    AgentPhase.VALIDATE,
    AgentPhase.PLAN,
    AgentPhase.RESOLVE,
    AgentPhase.RENDER,
    AgentPhase.VERIFY,
    AgentPhase.COMMIT,
]

# ëª¨ì˜ ë‹¨ê³„ ì§€ì—° ì‹œê°„ (ms) - ì‹¤ì œ ì²˜ë¦¬ ì‹œë®¬ë ˆì´ì…˜
PHASE_DELAYS_MS = {
    AgentPhase.PARSE: 50,
    AgentPhase.VALIDATE: 30,
    AgentPhase.PLAN: 100,
    AgentPhase.RESOLVE: 150,
    AgentPhase.RENDER: 80,
    AgentPhase.VERIFY: 40,
    AgentPhase.COMMIT: 20,
}


async def _stream_turn_events(
    turn_input: TurnInput, seed: int | None = None
) -> AsyncGenerator[str]:
    """í„´ ì²˜ë¦¬ ì´ë²¤íŠ¸ë¥¼ NDJSON ìŠ¤íŠ¸ë¦¼ìœ¼ë¡œ ìƒì„±í•©ë‹ˆë‹¤.

    Args:
        turn_input: ì‚¬ìš©ì í„´ ì…ë ¥
        seed: ëª¨ì˜ Orchestrator ì‹œë“œ (ì¬í˜„ì„± ë³´ì¥)

    Yields:
        str: NDJSON ë¼ì¸
    """
    orchestrator = MockOrchestrator(seed=seed)
    collected_badges: list[str] = []

    # Phase 1: Parse (TTFBë¥¼ ìœ„í•´ ì¦‰ì‹œ ì‹œì‘ ì´ë²¤íŠ¸ ì „ì†¡)
    yield serialize_event(
        StageEvent(
            type=StreamEventType.STAGE, name=AgentPhase.PARSE.value, status=StageStatus.START
        ).model_dump()
    )

    # ê° ë‹¨ê³„ë³„ ì²˜ë¦¬ ì‹œë®¬ë ˆì´ì…˜
    for phase in ORCHESTRATOR_PHASES:
        # ë‹¨ê³„ ì‹œì‘
        if phase != AgentPhase.PARSE:  # ParseëŠ” ì´ë¯¸ ì „ì†¡í•¨
            yield serialize_event(
                StageEvent(
                    type=StreamEventType.STAGE, name=phase.value, status=StageStatus.START
                ).model_dump()
            )

        # ëª¨ì˜ ì²˜ë¦¬ ì§€ì—°
        delay_ms = PHASE_DELAYS_MS.get(phase, 50)
        await asyncio.sleep(delay_ms / 1000.0)

        # ë‹¨ê³„ ì™„ë£Œ
        yield serialize_event(
            StageEvent(
                type=StreamEventType.STAGE, name=phase.value, status=StageStatus.COMPLETE
            ).model_dump()
        )

        # ë°°ì§€ ì¶”ê°€ (Validate, Verify ë‹¨ê³„ì—ì„œ)
        if phase == AgentPhase.VALIDATE:
            collected_badges.append(ValidationBadge.SCHEMA_OK.value)
            collected_badges.append(ValidationBadge.ECONOMY_OK.value)
            yield serialize_event(
                BadgesEvent(
                    type=StreamEventType.BADGES, badges=collected_badges.copy()
                ).model_dump()
            )
        elif phase == AgentPhase.VERIFY:
            collected_badges.append(ValidationBadge.SAFETY_OK.value)
            collected_badges.append(ValidationBadge.CONSISTENCY_OK.value)
            yield serialize_event(
                BadgesEvent(
                    type=StreamEventType.BADGES, badges=collected_badges.copy()
                ).model_dump()
            )

    # TurnOutput ìƒì„± (Repair ë£¨í”„ í¬í•¨ - RULE-004)
    max_repair_attempts = 3
    repair_attempt = 0
    turn_output = None

    try:
        while repair_attempt <= max_repair_attempts:
            try:
                # 0íšŒì°¨ëŠ” ì •ìƒ ì‹œë„, 1íšŒì°¨ë¶€í„°ëŠ” repair
                if repair_attempt > 0:
                    yield serialize_event(
                        RepairEvent(
                            type=StreamEventType.REPAIR,
                            attempt=repair_attempt,
                            message="ê²€ì¦ ì‹¤íŒ¨ë¡œ ì¸í•´ ë‹¤ì‹œ ì‹œë„ ì¤‘ì…ë‹ˆë‹¤..."
                            if turn_input.language == Language.KO
                            else "Retrying due to validation failure",
                        ).model_dump()
                    )

                turn_output = orchestrator.generate_turn_output(turn_input)
                break  # ì„±ê³µ ì‹œ ë£¨í”„ íƒˆì¶œ

            except ValidationError as e:
                repair_attempt += 1
                if repair_attempt > max_repair_attempts:
                    # ìµœì¢… ì‹¤íŒ¨ ì‹œ í´ë°± (RULE-004)
                    turn_output = orchestrator.create_safe_fallback(
                        language=turn_input.language,
                        error_message=str(e),
                        economy_snapshot=CurrencyAmount(
                            signal=turn_input.economy_snapshot.signal,
                            memory_shard=turn_input.economy_snapshot.memory_shard,
                        ),
                    )
                    break
                # ë£¨í”„ ê³„ì† ì§„í–‰ (ì¬ì‹œë„)
                continue

        if turn_output:
            # ë‚´ëŸ¬í‹°ë¸Œ ë¸íƒ€ ìŠ¤íŠ¸ë¦¬ë° (íƒ€ì íš¨ê³¼)
            narrative = turn_output.narrative
            chunk_size = 20  # í•œ ë²ˆì— ì „ì†¡í•  ê¸€ì ìˆ˜
            for i in range(0, len(narrative), chunk_size):
                chunk = narrative[i : i + chunk_size]
                yield serialize_event(
                    NarrativeDeltaEvent(
                        type=StreamEventType.NARRATIVE_DELTA, text=chunk
                    ).model_dump()
                )
                await asyncio.sleep(0.02)  # íƒ€ì íš¨ê³¼ ë”œë ˆì´

            # ìµœì¢… TurnOutput ì „ì†¡
            yield serialize_event(
                FinalEvent(type=StreamEventType.FINAL, data=turn_output).model_dump(mode="json")
            )

    except Exception:
        # RU-002-S1: ì˜ˆì™¸ ë°œìƒ ì‹œ error + final(í´ë°±) ìˆœì„œë¡œ ì†¡ì¶œ
        # (í”„ë¡¬í”„íŠ¸/ë‚´ë¶€ ì¶”ë¡  ë…¸ì¶œ ê¸ˆì§€ - RULE-007)
        yield serialize_event(
            ErrorEvent(
                type=StreamEventType.ERROR,
                message="ì²˜ë¦¬ ì¤‘ ì˜¤ë¥˜ê°€ ë°œìƒí–ˆìŠµë‹ˆë‹¤"
                if turn_input.language == Language.KO
                else "An error occurred during processing",
                code="INTERNAL_ERROR",
            ).model_dump()
        )
        # í•­ìƒ final(í´ë°±)ë¡œ ì¢…ë£Œ - ìŠ¤íŠ¸ë¦¼ ì¢…ë£Œ ì¸ë°”ë¦¬ì–¸íŠ¸ (RULE-004)
        fallback = orchestrator.create_safe_fallback(
            language=turn_input.language,
            error_message="Internal error",
            economy_snapshot=CurrencyAmount(
                signal=turn_input.economy_snapshot.signal,
                memory_shard=turn_input.economy_snapshot.memory_shard,
            ),
        )
        yield serialize_event(
            FinalEvent(type=StreamEventType.FINAL, data=fallback).model_dump(mode="json")
        )


async def _validate_and_parse_input(request: Request) -> TurnInput | dict[str, Any]:
    """ìš”ì²­ ë³¸ë¬¸ì„ TurnInputìœ¼ë¡œ ê²€ì¦ ë° íŒŒì‹±í•©ë‹ˆë‹¤.

    Returns:
        TurnInput ë˜ëŠ” ì—ëŸ¬ ì •ë³´ dict (language, economy_snapshot í¬í•¨)
    """
    body: dict[str, Any] | None = None
    try:
        body = await request.json()
        return TurnInput.model_validate(body)
    except ValidationError as e:
        # RU-002-S1: ì…ë ¥ ê²€ì¦ ì‹¤íŒ¨ ì‹œì—ë„ language/economy ì¶”ì¶œ ì‹œë„
        raw_language = body.get("language") if isinstance(body, dict) else None
        raw_economy = body.get("economy_snapshot") if isinstance(body, dict) else None
        return {
            "error": True,
            "message": "Invalid input",
            "details": e.errors(),
            "language": raw_language if raw_language in ("ko-KR", "en-US") else "ko-KR",
            "economy_snapshot": raw_economy,
        }
    except Exception:
        return {
            "error": True,
            "message": "Failed to parse request body",
            "details": None,
            "language": "ko-KR",
            "economy_snapshot": None,
        }


@router.post(
    "/turn",
    response_class=StreamingResponse,
    summary="í„´ ì²˜ë¦¬ (HTTP Streaming)",
    description="""
í„´ ì…ë ¥ì„ ë°›ì•„ NDJSON ìŠ¤íŠ¸ë¦¬ë°ìœ¼ë¡œ ê²°ê³¼ë¥¼ ë°˜í™˜í•©ë‹ˆë‹¤.

**ìŠ¤íŠ¸ë¦¼ ì´ë²¤íŠ¸ íƒ€ì…**:
- `stage`: ì²˜ë¦¬ ë‹¨ê³„ ì§„í–‰ ìƒíƒœ
- `badges`: ê²€ì¦ ë°°ì§€ ëª©ë¡
- `narrative_delta`: ë‚´ëŸ¬í‹°ë¸Œ í…ìŠ¤íŠ¸ ì¡°ê° (íƒ€ì íš¨ê³¼)
- `final`: ìµœì¢… TurnOutput
- `error`: ì—ëŸ¬ ë°œìƒ ì‹œ

**ì˜ˆì‹œ ìš”ì²­**:
```json
{
    "language": "ko-KR",
    "text": "ë¬¸ì„ ì—´ì–´ë³¸ë‹¤",
    "client": {"viewport_w": 1920, "viewport_h": 1080, "theme": "dark"},
    "economy_snapshot": {"signal": 100, "memory_shard": 5}
}
```
""",
    responses={
        200: {
            "description": "NDJSON ìŠ¤íŠ¸ë¦¼",
            "content": {
                "application/x-ndjson": {
                    "example": '{"type":"stage","name":"parse","status":"start"}\n'
                }
            },
        },
        400: {"description": "ì˜ëª»ëœ ìš”ì²­"},
    },
)
async def turn_stream(request: Request) -> StreamingResponse:
    """í„´ ì²˜ë¦¬ HTTP Streaming ì—”ë“œí¬ì¸íŠ¸.

    POST ìš”ì²­ìœ¼ë¡œ TurnInputì„ ë°›ì•„ NDJSON ìŠ¤íŠ¸ë¦¬ë°ìœ¼ë¡œ ê²°ê³¼ë¥¼ ë°˜í™˜í•©ë‹ˆë‹¤.
    TTFBë¥¼ ì¤„ì´ê¸° ìœ„í•´ ì²« stage ì´ë²¤íŠ¸ë¥¼ ì¦‰ì‹œ ì „ì†¡í•©ë‹ˆë‹¤.

    Args:
        request: FastAPI Request ê°ì²´

    Returns:
        StreamingResponse: NDJSON ìŠ¤íŠ¸ë¦¼
    """
    # ì…ë ¥ ê²€ì¦
    parse_result = await _validate_and_parse_input(request)

    if isinstance(parse_result, dict) and parse_result.get("error"):
        # RU-002-S1: ì…ë ¥ ê²€ì¦ ì‹¤íŒ¨ ì‹œì—ë„ error + final(í´ë°±) ìˆœì„œë¡œ ì†¡ì¶œ
        error_language = parse_result.get("language", "ko-KR")
        error_economy = parse_result.get("economy_snapshot")

        # economy_snapshotì´ ìœ íš¨í•œì§€ í™•ì¸
        economy_snapshot: CurrencyAmount | None = None
        if isinstance(error_economy, dict):
            try:
                # ëª…ì‹œì  íƒ€ì… ìºìŠ¤íŒ…ìœ¼ë¡œ Pyright ê²½ê³  í•´ì†Œ
                eco_dict = cast(dict[str, Any], error_economy)
                economy_snapshot = CurrencyAmount(
                    signal=int(eco_dict.get("signal", 100)),
                    memory_shard=int(eco_dict.get("memory_shard", 5)),
                )
            except (ValueError, TypeError):
                economy_snapshot = None

        async def error_stream() -> AsyncGenerator[str]:
            # ì—ëŸ¬ ì´ë²¤íŠ¸ ì†¡ì¶œ
            yield serialize_event(
                ErrorEvent(
                    type=StreamEventType.ERROR,
                    message=parse_result.get("message", "Invalid input"),
                    code="VALIDATION_ERROR",
                ).model_dump()
            )
            # í•­ìƒ final(í´ë°±)ë¡œ ì¢…ë£Œ - ìŠ¤íŠ¸ë¦¼ ì¢…ë£Œ ì¸ë°”ë¦¬ì–¸íŠ¸ (RULE-004)
            fallback_orchestrator = MockOrchestrator()
            fallback = fallback_orchestrator.create_safe_fallback(
                language=Language.KO if error_language == "ko-KR" else Language.EN,
                error_message="Validation error",
                economy_snapshot=economy_snapshot,
            )
            yield serialize_event(
                FinalEvent(type=StreamEventType.FINAL, data=fallback).model_dump(mode="json")
            )

        return StreamingResponse(
            error_stream(),
            media_type="application/x-ndjson",
            headers={
                "Cache-Control": "no-cache",
                "X-Accel-Buffering": "no",  # nginx ë²„í¼ë§ ë¹„í™œì„±í™”
            },
        )

    turn_input: TurnInput = parse_result  # type: ignore[assignment]

    # ì‹œë“œ ì¶”ì¶œ (ì¿¼ë¦¬ íŒŒë¼ë¯¸í„°ì—ì„œ, í…ŒìŠ¤íŠ¸/ì¬í˜„ìš©)
    seed_param = request.query_params.get("seed")
    seed = int(seed_param) if seed_param else None

    # NDJSON ìŠ¤íŠ¸ë¦¬ë° ì‘ë‹µ
    return StreamingResponse(
        _stream_turn_events(turn_input, seed=seed),
        media_type="application/x-ndjson",
        headers={
            "Cache-Control": "no-cache",
            "X-Accel-Buffering": "no",  # nginx ë²„í¼ë§ ë¹„í™œì„±í™”
            "X-Request-Time": str(int(time.time() * 1000)),
        },
    )
</file>

<file path="frontend/src/components/AgentConsole.tsx">
/**
 * Unknown World - Agent Console ì»´í¬ë„ŒíŠ¸.
 *
 * ì—ì´ì „íŠ¸í˜• ì‹œìŠ¤í…œì„ì„ UIë¡œ ì¦ëª…í•˜ê¸° ìœ„í•œ ì»´í¬ë„ŒíŠ¸ì…ë‹ˆë‹¤.
 * Plan/Queue/Badges/Auto-repair íŠ¸ë ˆì´ìŠ¤ë¥¼ ì‹¤ì‹œê°„ìœ¼ë¡œ í‘œì‹œí•©ë‹ˆë‹¤.
 *
 * ì„¤ê³„ ì›ì¹™:
 *   - RULE-008: ë‹¨ê³„/ë°°ì§€/ë³µêµ¬ë§Œ ë³´ì—¬ì¤Œ (í”„ë¡¬í”„íŠ¸/ë‚´ë¶€ ì¶”ë¡  ë…¸ì¶œ ê¸ˆì§€)
 *   - RULE-002: ê²Œì„ UIë¡œ í‘œí˜„ (ì±„íŒ… ë²„ë¸” ê¸ˆì§€)
 *
 * @module components/AgentConsole
 */

import { useTranslation } from 'react-i18next';
import {
  useAgentStore,
  selectIsStreaming,
  selectPhases,
  selectBadges,
  selectRepairCount,
  selectError,
  type PhaseInfo,
} from '../stores/agentStore';
import type { ValidationBadge } from '../schemas/turn';

// =============================================================================
// ìƒìˆ˜ ì •ì˜
// =============================================================================

/** ë‹¨ê³„ í‘œì‹œ ì´ë¦„ i18n í‚¤ */
const PHASE_KEYS: Record<string, string> = {
  parse: 'agent.console.phase.parse',
  validate: 'agent.console.phase.validate',
  plan: 'agent.console.phase.plan',
  resolve: 'agent.console.phase.resolve',
  render: 'agent.console.phase.render',
  verify: 'agent.console.phase.verify',
  commit: 'agent.console.phase.commit',
};

/** ë°°ì§€ í‘œì‹œ ì •ë³´ (i18n í‚¤ ê¸°ë°˜) */
const BADGE_INFO: Record<ValidationBadge, { labelKey: string; isOk: boolean }> = {
  schema_ok: { labelKey: 'agent.console.badge.schema', isOk: true },
  schema_fail: { labelKey: 'agent.console.badge.schema', isOk: false },
  economy_ok: { labelKey: 'agent.console.badge.economy', isOk: true },
  economy_fail: { labelKey: 'agent.console.badge.economy', isOk: false },
  safety_ok: { labelKey: 'agent.console.badge.safety', isOk: true },
  safety_blocked: { labelKey: 'agent.console.badge.safety', isOk: false },
  consistency_ok: { labelKey: 'agent.console.badge.consistency', isOk: true },
  consistency_fail: { labelKey: 'agent.console.badge.consistency', isOk: false },
};

// =============================================================================
// í•˜ìœ„ ì»´í¬ë„ŒíŠ¸
// =============================================================================

/** ë‹¨ê³„ ìƒíƒœ ì•„ì´ì½˜ */
function PhaseIcon({ status }: { status: PhaseInfo['status'] }) {
  switch (status) {
    case 'pending':
      return <span className="phase-icon pending">â—‹</span>;
    case 'in_progress':
      return <span className="phase-icon in-progress">â—</span>;
    case 'completed':
      return <span className="phase-icon completed">â—</span>;
    case 'failed':
      return <span className="phase-icon failed">âœ•</span>;
    default:
      return <span className="phase-icon">â—‹</span>;
  }
}

/** ë‹¨ê³„ í í•­ëª© */
function PhaseQueueItem({ phase }: { phase: PhaseInfo }) {
  const { t } = useTranslation();
  const key = PHASE_KEYS[phase.name];
  const label = key ? t(key) : phase.name;
  const statusClass = `phase-item ${phase.status}`;

  return (
    <div className={statusClass}>
      <PhaseIcon status={phase.status} />
      <span className="phase-label">{label}</span>
    </div>
  );
}

/** ë‹¨ê³„ í */
function PhaseQueue() {
  const { t } = useTranslation();
  const phases = useAgentStore(selectPhases);

  return (
    <div className="phase-queue">
      <div className="queue-label">{t('agent.console.queue')}</div>
      <div className="queue-items">
        {phases.map((phase) => (
          <PhaseQueueItem key={phase.name} phase={phase} />
        ))}
      </div>
    </div>
  );
}

/** ë°°ì§€ ì•„ì´í…œ */
function BadgeItem({ badge }: { badge: ValidationBadge }) {
  const { t } = useTranslation();
  const info = BADGE_INFO[badge];
  if (!info) return null;

  const statusClass = info.isOk ? 'badge-ok' : 'badge-fail';
  const statusText = info.isOk ? t('agent.console.badge.ok') : t('agent.console.badge.fail');
  const iconName = info.isOk ? 'badge-ok-24.png' : 'badge-fail-24.png';
  const fallbackIcon = info.isOk ? 'âœ“' : 'âœ—';

  return (
    <div className={`badge-item ${statusClass}`}>
      <span className="badge-label">{t(info.labelKey)}</span>
      <span className="badge-status">
        <span className="icon-wrapper">
          <img
            src={`/ui/icons/${iconName}`}
            alt=""
            aria-hidden="true"
            className="badge-icon-img"
            onError={(e) => e.currentTarget.classList.add('hidden')}
          />
          <span className="icon-fallback" style={{ fontSize: '0.625rem' }}>
            {fallbackIcon}
          </span>
        </span>
        {statusText}
      </span>
    </div>
  );
}

/** ë°°ì§€ íŒ¨ë„ */
function BadgesPanel() {
  const { t } = useTranslation();
  const badges = useAgentStore(selectBadges);

  if (badges.length === 0) {
    return (
      <div className="badges-panel">
        <div className="badges-label">{t('agent.console.badges')}</div>
        <div className="badges-empty">{t('agent.console.badges_empty')}</div>
      </div>
    );
  }

  return (
    <div className="badges-panel">
      <div className="badges-label">{t('agent.console.badges')}</div>
      <div className="badges-grid">
        {badges.map((badge, index) => (
          <BadgeItem key={`${badge}-${index}`} badge={badge} />
        ))}
      </div>
    </div>
  );
}

/** Auto-repair íŠ¸ë ˆì´ìŠ¤ */
function RepairTrace() {
  const { t } = useTranslation();
  const repairCount = useAgentStore(selectRepairCount);
  const isStreaming = useAgentStore(selectIsStreaming);

  if (repairCount === 0 && !isStreaming) {
    return null;
  }

  return (
    <div className="repair-trace">
      <span className="repair-label">{t('agent.console.repair')}</span>
      <span className="repair-count">#{repairCount}</span>
      {repairCount > 0 && (
        <span className="repair-status text-warning"> {t('agent.console.repaired')}</span>
      )}
    </div>
  );
}

/** ì—ëŸ¬ í‘œì‹œ */
function ErrorDisplay() {
  const error = useAgentStore(selectError);

  if (!error) return null;

  return (
    <div className="agent-error">
      <span className="error-icon">âš </span>
      <span className="error-message">{error.message}</span>
      {error.code && <span className="error-code">[{error.code}]</span>}
    </div>
  );
}

/** ìŠ¤íŠ¸ë¦¬ë° ìƒíƒœ í‘œì‹œ */
function StreamingStatus() {
  const { t } = useTranslation();
  const isStreaming = useAgentStore(selectIsStreaming);

  return (
    <div className="streaming-status">
      <span className={`status-dot ${isStreaming ? 'active' : ''}`} />
      <span className="status-text">
        {isStreaming ? t('agent.console.status.processing') : t('agent.console.status.idle')}
      </span>
    </div>
  );
}

// =============================================================================
// ë©”ì¸ ì»´í¬ë„ŒíŠ¸
// =============================================================================

/**
 * Agent Console ì»´í¬ë„ŒíŠ¸.
 *
 * Plan/Queue/Badges/Auto-repairë¥¼ ì‹¤ì‹œê°„ìœ¼ë¡œ í‘œì‹œí•©ë‹ˆë‹¤.
 * RULE-008ì— ë”°ë¼ í”„ë¡¬í”„íŠ¸/ë‚´ë¶€ ì¶”ë¡ ì€ ë…¸ì¶œí•˜ì§€ ì•ŠìŠµë‹ˆë‹¤.
 *
 * U-037: data-ui-importance="critical" ë§ˆí‚¹ìœ¼ë¡œ ê°€ë…ì„± ë³´ì¥
 */
export function AgentConsole() {
  return (
    <div className="agent-console-content" data-ui-importance="critical">
      <StreamingStatus />
      <PhaseQueue />
      <BadgesPanel />
      <RepairTrace />
      <ErrorDisplay />
    </div>
  );
}

export default AgentConsole;
</file>

<file path="frontend/src/components/SceneCanvas.tsx">
/**
 * Unknown World - Scene Canvas ì»´í¬ë„ŒíŠ¸
 *
 * RULE-002 ì¤€ìˆ˜: ì±„íŒ… ë²„ë¸”ì´ ì•„ë‹Œ ê²Œì„ UI
 * RULE-009 ì¤€ìˆ˜: ì¢Œí‘œ ê·œì•½ (0~1000 ì •ê·œí™”, bbox=[ymin,xmin,ymax,xmax])
 *
 * U-010[Mvp]: í•«ìŠ¤íŒŸ ì˜¤ë²„ë ˆì´ + í´ë¦­ ì²˜ë¦¬
 * - TurnOutputì˜ objects[]/hotspots[]ë¥¼ ê¸°ë°˜ìœ¼ë¡œ ì˜¤ë²„ë ˆì´ ë Œë”
 * - hover ì‹œ í•˜ì´ë¼ì´íŠ¸/íˆ´íŒ í‘œì‹œ
 * - click ì‹œ object_id + box_2dë¥¼ TurnInputì— í¬í•¨í•´ ì „ì†¡
 *
 * @module components/SceneCanvas
 */

import { useState, useRef, useCallback, useEffect } from 'react';
import { useTranslation } from 'react-i18next';
import type { SceneCanvasStatus, SceneCanvasState, PlaceholderInfo } from '../types/scene';
import type { SceneObject, Box2D } from '../schemas/turn';
import { box2dToPixel, type CanvasSize } from '../utils/box2d';

// =============================================================================
// ìƒìˆ˜ ì •ì˜
// =============================================================================

/**
 * ìƒíƒœë³„ placeholder ì •ë³´ (U-031: Placeholder Pack)
 * labelKeyëŠ” i18n ë²ˆì—­ í‚¤ë¡œ ì‚¬ìš©ë©ë‹ˆë‹¤.
 */
export const SCENE_PLACEHOLDERS: Record<Exclude<SceneCanvasStatus, 'scene'>, PlaceholderInfo> = {
  default: {
    imagePath: '/ui/placeholders/scene-placeholder-default.png',
    fallbackEmoji: 'ğŸ“¡',
    labelKey: 'scene.status.default',
  },
  loading: {
    imagePath: '/ui/placeholders/scene-loading.webp',
    fallbackEmoji: 'â³',
    labelKey: 'scene.status.loading',
  },
  offline: {
    imagePath: '/ui/placeholders/scene-offline.webp',
    fallbackEmoji: 'ğŸ”Œ',
    labelKey: 'scene.status.offline',
  },
  blocked: {
    imagePath: '/ui/placeholders/scene-blocked.webp',
    fallbackEmoji: 'ğŸš«',
    labelKey: 'scene.status.blocked',
  },
  low_signal: {
    imagePath: '/ui/placeholders/scene-low-signal.webp',
    fallbackEmoji: 'ğŸ“‰',
    labelKey: 'scene.status.low_signal',
  },
};

// =============================================================================
// íƒ€ì… ì •ì˜
// =============================================================================

/**
 * í•«ìŠ¤íŒŸ í´ë¦­ ì´ë²¤íŠ¸ ë°ì´í„° (Q1 ê²°ì •: Option B - object_id + box_2d)
 */
export interface HotspotClickData {
  /** í´ë¦­í•œ ì˜¤ë¸Œì íŠ¸ ID */
  object_id: string;
  /** í´ë¦­í•œ ì˜¤ë¸Œì íŠ¸ì˜ ë°”ìš´ë”© ë°•ìŠ¤ (0~1000 ì •ê·œí™”) */
  box_2d: Box2D;
}

interface SceneCanvasProps {
  state: SceneCanvasState;
  /** í´ë¦­ ê°€ëŠ¥í•œ ì˜¤ë¸Œì íŠ¸ ëª©ë¡ */
  objects?: SceneObject[];
  /** í•«ìŠ¤íŒŸ í´ë¦­ ì½œë°± */
  onHotspotClick?: (data: HotspotClickData) => void;
  /** ìŠ¤íŠ¸ë¦¬ë° ì¤‘ ì—¬ë¶€ (ë¹„í™œì„±í™”ìš©) */
  disabled?: boolean;
}

// =============================================================================
// ë‚´ë¶€ ì»´í¬ë„ŒíŠ¸: í•«ìŠ¤íŒŸ ì˜¤ë²„ë ˆì´
// =============================================================================

interface HotspotOverlayProps {
  object: SceneObject;
  canvasSize: CanvasSize;
  onClick: (data: HotspotClickData) => void;
  disabled: boolean;
}

/**
 * ê°œë³„ í•«ìŠ¤íŒŸ ì˜¤ë²„ë ˆì´ ì»´í¬ë„ŒíŠ¸
 */
function HotspotOverlay({ object, canvasSize, onClick, disabled }: HotspotOverlayProps) {
  const [isHovered, setIsHovered] = useState(false);
  const { t } = useTranslation();

  // box_2d(0~1000) â†’ px ë³€í™˜
  const pixelBox = box2dToPixel(object.box_2d, canvasSize);

  const handleClick = useCallback(() => {
    if (disabled) return;
    onClick({
      object_id: object.id,
      box_2d: object.box_2d,
    });
  }, [disabled, onClick, object.id, object.box_2d]);

  const handleKeyDown = useCallback(
    (e: React.KeyboardEvent) => {
      if (disabled) return;
      if (e.key === 'Enter' || e.key === ' ') {
        e.preventDefault();
        handleClick();
      }
    },
    [disabled, handleClick],
  );

  return (
    <div
      className={`hotspot-overlay ${isHovered ? 'hovered' : ''} ${disabled ? 'disabled' : ''}`}
      style={{
        position: 'absolute',
        top: `${pixelBox.top}px`,
        left: `${pixelBox.left}px`,
        width: `${pixelBox.width}px`,
        height: `${pixelBox.height}px`,
      }}
      onClick={handleClick}
      onMouseEnter={() => setIsHovered(true)}
      onMouseLeave={() => setIsHovered(false)}
      onKeyDown={handleKeyDown}
      role="button"
      tabIndex={disabled ? -1 : 0}
      aria-label={object.label}
      aria-disabled={disabled}
    >
      {/* í˜¸ë²„ ì‹œ íˆ´íŒ í‘œì‹œ */}
      {isHovered && !disabled && (
        <div className="hotspot-tooltip">
          <span className="hotspot-tooltip-label">{object.label}</span>
          {object.interaction_hint && (
            <span className="hotspot-tooltip-hint">
              {t('scene.hotspot.hint_prefix')}: {object.interaction_hint}
            </span>
          )}
        </div>
      )}
    </div>
  );
}

// =============================================================================
// ë©”ì¸ ì»´í¬ë„ŒíŠ¸
// =============================================================================

/**
 * Scene Canvas ì»´í¬ë„ŒíŠ¸
 *
 * U-010[Mvp]: í•«ìŠ¤íŒŸ ì˜¤ë²„ë ˆì´ + í´ë¦­ ì²˜ë¦¬
 * U-031[Mvp]: Placeholder Pack
 *
 * - ìƒíƒœì— ë”°ë¼ placeholder ì´ë¯¸ì§€ì™€ ë¼ë²¨ì„ í‘œì‹œí•©ë‹ˆë‹¤.
 * - 'scene' ìƒíƒœì—ì„œëŠ” ì‹¤ì œ ì´ë¯¸ì§€ë¥¼ ë Œë”ë§í•˜ë©°, ë¡œë“œ ì‹¤íŒ¨ ì‹œ í´ë°±ì„ ì œê³µí•©ë‹ˆë‹¤.
 * - objects ë°°ì—´ì´ ìˆìœ¼ë©´ í•«ìŠ¤íŒŸ ì˜¤ë²„ë ˆì´ë¥¼ ë Œë”ë§í•©ë‹ˆë‹¤.
 */
export function SceneCanvas({
  state,
  objects = [],
  onHotspotClick,
  disabled = false,
}: SceneCanvasProps) {
  const { status, imageUrl, message } = state;
  const [imageError, setImageError] = useState(false);
  const [canvasSize, setCanvasSize] = useState<CanvasSize>({ width: 0, height: 0 });
  const canvasRef = useRef<HTMLDivElement>(null);
  const { t } = useTranslation();

  // ResizeObserverë¡œ ìº”ë²„ìŠ¤ í¬ê¸° ì¶”ì  (ë°˜ì‘í˜• ì¢Œí‘œ ë³€í™˜ìš©)
  useEffect(() => {
    const element = canvasRef.current;
    if (!element) return;

    const resizeObserver = new ResizeObserver((entries) => {
      for (const entry of entries) {
        const { width, height } = entry.contentRect;
        setCanvasSize({ width, height });
      }
    });

    resizeObserver.observe(element);

    // ì´ˆê¸° í¬ê¸° ì„¤ì •
    const rect = element.getBoundingClientRect();
    setCanvasSize({ width: rect.width, height: rect.height });

    return () => {
      resizeObserver.disconnect();
    };
  }, []);

  // í•«ìŠ¤íŒŸ í´ë¦­ í•¸ë“¤ëŸ¬
  const handleHotspotClick = useCallback(
    (data: HotspotClickData) => {
      if (onHotspotClick) {
        onHotspotClick(data);
      }
    },
    [onHotspotClick],
  );

  // ì •ìƒ ì¥ë©´ í‘œì‹œ ì¤‘ì´ê±°ë‚˜ ì´ë¯¸ì§€ ì—ëŸ¬ê°€ ë°œìƒí•œ ê²½ìš°
  const isSceneActive = status === 'scene' && imageUrl && !imageError;

  // placeholder ì •ë³´ ê²°ì • (scene ìƒíƒœì—ì„œ ì—ëŸ¬ ì‹œ defaultë¡œ í´ë°±)
  const effectiveStatus = status === 'scene' && imageError ? 'default' : status;
  const isPlaceholderVisible = effectiveStatus !== 'scene';

  const placeholder = isPlaceholderVisible
    ? SCENE_PLACEHOLDERS[effectiveStatus as Exclude<SceneCanvasStatus, 'scene'>]
    : null;

  // í•«ìŠ¤íŒŸ ë Œë”ë§ ì¡°ê±´: scene í™œì„±í™” ìƒíƒœ + objects ì¡´ì¬ + ìº”ë²„ìŠ¤ í¬ê¸° í™•ë³´
  const shouldRenderHotspots =
    (isSceneActive || status === 'default') && objects.length > 0 && canvasSize.width > 0;

  return (
    <div
      ref={canvasRef}
      className={`scene-canvas ${isSceneActive ? 'scene-active' : `scene-status-${effectiveStatus}`} ${shouldRenderHotspots ? 'has-hotspots' : ''}`}
      style={placeholder ? { backgroundImage: `url('${placeholder.imagePath}')` } : {}}
    >
      {isSceneActive && (
        <img
          src={imageUrl}
          alt={t('scene.status.alt')}
          className="scene-image"
          onError={() => setImageError(true)}
        />
      )}

      {isPlaceholderVisible && placeholder && (
        <div className="scene-placeholder">
          {/* í…ìŠ¤íŠ¸ í´ë°± (ì´ë¯¸ì§€ ë¡œë“œ ì‹¤íŒ¨ ì‹œì—ë„ í‘œì‹œ) */}
          <p className="text-glow scene-status-label">
            <span className="scene-status-emoji" aria-hidden="true">
              {placeholder.fallbackEmoji}
            </span>{' '}
            {t(placeholder.labelKey)}
          </p>
          {(message || (status === 'scene' && imageError)) && (
            <p className="scene-status-message">
              {message || (imageError ? t('scene.status.image_error') : '')}
            </p>
          )}
        </div>
      )}

      {/* í•«ìŠ¤íŒŸ ì˜¤ë²„ë ˆì´ ë ˆì´ì–´ */}
      {shouldRenderHotspots && (
        <div className="hotspot-layer" aria-label={t('scene.hotspot.layer_label')}>
          {objects.map((obj) => (
            <HotspotOverlay
              key={obj.id}
              object={obj}
              canvasSize={canvasSize}
              onClick={handleHotspotClick}
              disabled={disabled}
            />
          ))}
        </div>
      )}
    </div>
  );
}
</file>

<file path="frontend/src/types/turn_stream.ts">
/**
 * Unknown World - Turn Stream ì´ë²¤íŠ¸ ê³„ì•½(Contract).
 *
 * NDJSON ìŠ¤íŠ¸ë¦¬ë°ì—ì„œ ì‚¬ìš©ë˜ëŠ” ì´ë²¤íŠ¸ íƒ€ì…, ì¸í„°í˜ì´ìŠ¤ë¥¼ ì •ì˜í•©ë‹ˆë‹¤.
 * ì´ ëª¨ë“ˆì€ ë°±ì—”ë“œì™€ í”„ë¡ íŠ¸ì—”ë“œ ê°„ì˜ ìŠ¤íŠ¸ë¦¼ ì´ë²¤íŠ¸ ê³„ì•½ SSOTì…ë‹ˆë‹¤.
 *
 * ì„¤ê³„ ì›ì¹™:
 *   - RU-002-Q4: ì´ë²¤íŠ¸ ê³„ì•½ì„ transport ê³„ì¸µìœ¼ë¡œ ë¶„ë¦¬
 *   - RU-002-S2: ì´ë²¤íŠ¸ë³„ Zod ê²€ì¦ + Unknown/í™•ì¥ ì´ë²¤íŠ¸ í´ë°±
 *   - RULE-003: êµ¬ì¡°í™” ì¶œë ¥(JSON Schema) ìš°ì„  + ì´ì¤‘ ê²€ì¦
 *   - RULE-008: ë‹¨ê³„/ë°°ì§€ ê°€ì‹œí™”
 *
 * ì°¸ì¡°:
 *   - vibe/unit-plans/U-007[Mvp].md
 *   - vibe/refactors/RU-002-Q4.md
 *   - vibe/refactors/RU-002-S2.md
 *
 * @module types/turn_stream
 */

import { z } from 'zod';
import {
  AgentPhaseSchema,
  ValidationBadgeSchema,
  type TurnOutput,
  type AgentPhase,
  type ValidationBadge,
} from '../schemas/turn';

// =============================================================================
// ìŠ¤íŠ¸ë¦¼ ì´ë²¤íŠ¸ íƒ€ì… ìƒìˆ˜ (ì„œë²„ ê³„ì•½ê³¼ ì¼ì¹˜)
// =============================================================================

/** ìŠ¤íŠ¸ë¦¼ ì´ë²¤íŠ¸ íƒ€ì… ìƒìˆ˜ */
export const StreamEventType = {
  STAGE: 'stage',
  BADGES: 'badges',
  NARRATIVE_DELTA: 'narrative_delta',
  FINAL: 'final',
  ERROR: 'error',
  REPAIR: 'repair',
} as const;

export type StreamEventTypeName = (typeof StreamEventType)[keyof typeof StreamEventType];

/**
 * ë‹¨ê³„ ìƒíƒœ ìƒìˆ˜.
 * RU-002-S2/RU-002-Q2: v1(complete) ë° v2(ok/fail) ë³„ì¹­ ëª¨ë‘ ì§€ì›.
 */
export const StageStatus = {
  START: 'start',
  COMPLETE: 'complete',
  /** ë‹¨ê³„ ì‹¤íŒ¨ */
  FAIL: 'fail',
} as const;

export type StageStatusName = (typeof StageStatus)[keyof typeof StageStatus];

// =============================================================================
// RU-002-S2: ì´ë²¤íŠ¸ë³„ Zod ìŠ¤í‚¤ë§ˆ (ê²½ëŸ‰ ê²€ì¦ + í´ë°±)
// =============================================================================

/**
 * stage.status ìŠ¤í‚¤ë§ˆ.
 * v1(complete) ë° v2(ok/fail) ë³„ì¹­ ëª¨ë‘ í—ˆìš©.
 */
export const StageStatusSchema = z.enum(['start', 'complete', 'ok', 'fail']);

/**
 * StageEvent Zod ìŠ¤í‚¤ë§ˆ.
 * ë‹¨ê³„ ì§„í–‰ ì´ë²¤íŠ¸ ê²€ì¦ìš©.
 */
export const StageEventSchema = z.object({
  type: z.literal(StreamEventType.STAGE),
  name: AgentPhaseSchema,
  status: StageStatusSchema,
});

/**
 * RepairEvent Zod ìŠ¤í‚¤ë§ˆ.
 * ìë™ ë³µêµ¬ ì‹œë„ ì´ë²¤íŠ¸ ê²€ì¦ìš©.
 */
export const RepairEventSchema = z.object({
  type: z.literal(StreamEventType.REPAIR),
  attempt: z.number(),
  message: z.string().optional(),
});

/**
 * BadgesEvent Zod ìŠ¤í‚¤ë§ˆ (v1: ë°°ì—´).
 * v1ì€ badges: string[] í˜•ì‹.
 */
export const BadgesEventSchemaV1 = z.object({
  type: z.literal(StreamEventType.BADGES),
  badges: z.array(ValidationBadgeSchema),
});

/**
 * BadgesEvent Zod ìŠ¤í‚¤ë§ˆ (v2: ê°ì²´/ë§µ).
 * í–¥í›„ v2ëŠ” badges: { [key]: status } í˜•ì‹ì„ ì§€ì›í•  ìˆ˜ ìˆìŒ.
 * í˜„ì¬ëŠ” v1ë§Œ ì‚¬ìš©í•˜ë¯€ë¡œ ì´ ìŠ¤í‚¤ë§ˆëŠ” í™•ì¥ì„±ì„ ìœ„í•´ ì •ì˜.
 */
export const BadgesEventSchemaV2 = z.object({
  type: z.literal(StreamEventType.BADGES),
  badges: z.record(z.string(), z.boolean()),
});

/**
 * BadgesEvent í†µí•© ìŠ¤í‚¤ë§ˆ.
 * v1(ë°°ì—´) ë˜ëŠ” v2(ê°ì²´) ëª¨ë‘ í—ˆìš©.
 */
export const BadgesEventSchema = z.union([BadgesEventSchemaV1, BadgesEventSchemaV2]);

/**
 * NarrativeDeltaEvent Zod ìŠ¤í‚¤ë§ˆ.
 * íƒ€ì íš¨ê³¼ìš© ë‚´ëŸ¬í‹°ë¸Œ ë¸íƒ€ ì´ë²¤íŠ¸ ê²€ì¦ìš©.
 */
export const NarrativeDeltaEventSchema = z.object({
  type: z.literal(StreamEventType.NARRATIVE_DELTA),
  text: z.string(),
});

/**
 * FinalEvent ì›ì‹œ ìŠ¤í‚¤ë§ˆ.
 * v1(data) ë° v2(turn_output) ë³„ì¹­ ëª¨ë‘ í—ˆìš©.
 * TurnOutput ìì²´ ê²€ì¦ì€ turnStream.tsì—ì„œ safeParseTurnOutputìœ¼ë¡œ ìˆ˜í–‰.
 */
export const FinalEventRawSchema = z.object({
  type: z.literal(StreamEventType.FINAL),
  data: z.unknown(),
});

/**
 * ErrorEvent Zod ìŠ¤í‚¤ë§ˆ.
 * ì—ëŸ¬ ì´ë²¤íŠ¸ ê²€ì¦ìš©.
 */
export const ErrorEventSchema = z.object({
  type: z.literal(StreamEventType.ERROR),
  message: z.string(),
  code: z.string().optional(),
});

/**
 * ì´ë²¤íŠ¸ íƒ€ì… ì¶”ì¶œìš© ìµœì†Œ ìŠ¤í‚¤ë§ˆ.
 * Unknown ì´ë²¤íŠ¸ íŒë³„ì— ì‚¬ìš©.
 */
export const BaseEventSchema = z.object({
  type: z.string(),
});

// =============================================================================
// ì´ë²¤íŠ¸ íŒŒì‹± ìœ í‹¸ë¦¬í‹° (RU-002-S2)
// =============================================================================

/** ì´ë²¤íŠ¸ ê²€ì¦ ê²°ê³¼ íƒ€ì… */
export type EventParseResult<T> =
  | { success: true; data: T }
  | { success: false; error: z.ZodError };

/**
 * StageEventë¥¼ ì•ˆì „í•˜ê²Œ íŒŒì‹±í•©ë‹ˆë‹¤.
 */
export function safeParseStageEvent(
  data: unknown,
): EventParseResult<z.infer<typeof StageEventSchema>> {
  const result = StageEventSchema.safeParse(data);
  return result.success
    ? { success: true, data: result.data }
    : { success: false, error: result.error };
}

/**
 * RepairEventë¥¼ ì•ˆì „í•˜ê²Œ íŒŒì‹±í•©ë‹ˆë‹¤.
 */
export function safeParseRepairEvent(
  data: unknown,
): EventParseResult<z.infer<typeof RepairEventSchema>> {
  const result = RepairEventSchema.safeParse(data);
  return result.success
    ? { success: true, data: result.data }
    : { success: false, error: result.error };
}

/**
 * BadgesEventë¥¼ ì•ˆì „í•˜ê²Œ íŒŒì‹±í•©ë‹ˆë‹¤.
 * v1(ë°°ì—´) í˜•íƒœë¡œ ì •ê·œí™”í•˜ì—¬ ë°˜í™˜í•©ë‹ˆë‹¤.
 */
export function safeParseBadgesEvent(data: unknown): EventParseResult<BadgesEvent> {
  const result = BadgesEventSchema.safeParse(data);
  if (!result.success) {
    return { success: false, error: result.error };
  }

  // v2(ê°ì²´) í˜•íƒœì¸ ê²½ìš° v1(ë°°ì—´)ë¡œ ì •ê·œí™”
  const parsed = result.data;
  if (Array.isArray(parsed.badges)) {
    // v1 í˜•íƒœ: ê·¸ëŒ€ë¡œ ë°˜í™˜
    return {
      success: true,
      data: { type: StreamEventType.BADGES, badges: parsed.badges as ValidationBadge[] },
    };
  } else {
    // v2 í˜•íƒœ: trueì¸ í‚¤ë§Œ ì¶”ì¶œí•˜ì—¬ ë°°ì—´ë¡œ ë³€í™˜
    const badgeArray = Object.entries(parsed.badges)
      .filter(([, value]) => value)
      .map(([key]) => key as ValidationBadge);
    return {
      success: true,
      data: { type: StreamEventType.BADGES, badges: badgeArray },
    };
  }
}

/**
 * NarrativeDeltaEventë¥¼ ì•ˆì „í•˜ê²Œ íŒŒì‹±í•©ë‹ˆë‹¤.
 */
export function safeParseNarrativeDeltaEvent(
  data: unknown,
): EventParseResult<z.infer<typeof NarrativeDeltaEventSchema>> {
  const result = NarrativeDeltaEventSchema.safeParse(data);
  return result.success
    ? { success: true, data: result.data }
    : { success: false, error: result.error };
}

/**
 * FinalEvent ì›ì‹œ í˜•íƒœë¥¼ ì•ˆì „í•˜ê²Œ íŒŒì‹±í•©ë‹ˆë‹¤.
 * TurnOutput ìì²´ ê²€ì¦ì€ ë³„ë„ë¡œ ìˆ˜í–‰í•´ì•¼ í•©ë‹ˆë‹¤.
 */
export function safeParseFinalEventRaw(
  data: unknown,
): EventParseResult<z.infer<typeof FinalEventRawSchema>> {
  const result = FinalEventRawSchema.safeParse(data);
  return result.success
    ? { success: true, data: result.data }
    : { success: false, error: result.error };
}

/**
 * ErrorEventë¥¼ ì•ˆì „í•˜ê²Œ íŒŒì‹±í•©ë‹ˆë‹¤.
 */
export function safeParseErrorEvent(
  data: unknown,
): EventParseResult<z.infer<typeof ErrorEventSchema>> {
  const result = ErrorEventSchema.safeParse(data);
  return result.success
    ? { success: true, data: result.data }
    : { success: false, error: result.error };
}

/**
 * stage.status ì •ê·œí™” í—¬í¼.
 * 'ok'ë¥¼ 'complete'ë¡œ, 'fail'ì€ ê·¸ëŒ€ë¡œ ìœ ì§€.
 */
export function normalizeStageStatus(status: string): 'start' | 'complete' | 'fail' {
  if (status === 'ok') return 'complete';
  if (status === 'fail') return 'fail';
  if (status === 'start') return 'start';
  return 'complete';
}

// =============================================================================
// ìŠ¤íŠ¸ë¦¼ ì´ë²¤íŠ¸ ì¸í„°í˜ì´ìŠ¤
// =============================================================================

/**
 * ë‹¨ê³„ ì§„í–‰ ì´ë²¤íŠ¸.
 * RU-002-S2: statusì— 'fail' ì¶”ê°€í•˜ì—¬ ë‹¨ê³„ ì‹¤íŒ¨ í‘œí˜„ ì§€ì›.
 */
export interface StageEvent {
  type: typeof StreamEventType.STAGE;
  name: AgentPhase;
  /** 'start' | 'complete' | 'ok' | 'fail'. okëŠ” completeë¡œ ì •ê·œí™”ë¨. */
  status: StageStatusName;
}

/** ìë™ ë³µêµ¬(Repair) ì´ë²¤íŠ¸ */
export interface RepairEvent {
  type: typeof StreamEventType.REPAIR;
  attempt: number;
  message?: string;
}

/** ë°°ì§€ ì´ë²¤íŠ¸ */
export interface BadgesEvent {
  type: typeof StreamEventType.BADGES;
  badges: ValidationBadge[];
}

/** ë‚´ëŸ¬í‹°ë¸Œ ë¸íƒ€ ì´ë²¤íŠ¸ (íƒ€ì íš¨ê³¼ìš©) */
export interface NarrativeDeltaEvent {
  type: typeof StreamEventType.NARRATIVE_DELTA;
  text: string;
}

/** ìµœì¢… TurnOutput ì´ë²¤íŠ¸
 *
 * RU-002-Q2: v1ì€ `data`, v2ëŠ” `turn_output` ì‚¬ìš©.
 * í•˜ìœ„í˜¸í™˜ì„ ìœ„í•´ ë‘ í•„ë“œ ëª¨ë‘ ì„ ì–¸í•˜ë˜, ì •ê·œí™”ëœ ì¸í„°í˜ì´ìŠ¤ëŠ” `data`ë¥¼ ì‚¬ìš©.
 */
export interface FinalEvent {
  type: typeof StreamEventType.FINAL;
  /** v1 í˜„í–‰ ê³„ì•½: TurnOutput í˜ì´ë¡œë“œ */
  data: TurnOutput;
}

/** FinalEvent ì›ì‹œ ìˆ˜ì‹  í˜•íƒœ */
export interface FinalEventRaw {
  type: typeof StreamEventType.FINAL;
  /** TurnOutput í˜ì´ë¡œë“œ */
  data: TurnOutput;
}

/** ì—ëŸ¬ ì´ë²¤íŠ¸ */
export interface ErrorEvent {
  type: typeof StreamEventType.ERROR;
  message: string;
  code?: string;
}

/** ìŠ¤íŠ¸ë¦¼ ì´ë²¤íŠ¸ ìœ ë‹ˆì˜¨ íƒ€ì… */
export type StreamEvent =
  | StageEvent
  | RepairEvent
  | BadgesEvent
  | NarrativeDeltaEvent
  | FinalEvent
  | ErrorEvent;

// =============================================================================
// ìŠ¤íŠ¸ë¦¼ ì½œë°± ì¸í„°í˜ì´ìŠ¤
// =============================================================================

/** ìŠ¤íŠ¸ë¦¼ ì´ë²¤íŠ¸ ì½œë°± */
export interface StreamCallbacks {
  /** ë‹¨ê³„ ì§„í–‰ ì´ë²¤íŠ¸ */
  onStage?: (event: StageEvent) => void;
  /** ìë™ ë³µêµ¬ ì´ë²¤íŠ¸ */
  onRepair?: (event: RepairEvent) => void;
  /** ë°°ì§€ ì´ë²¤íŠ¸ */
  onBadges?: (event: BadgesEvent) => void;
  /** ë‚´ëŸ¬í‹°ë¸Œ ë¸íƒ€ ì´ë²¤íŠ¸ */
  onNarrativeDelta?: (event: NarrativeDeltaEvent) => void;
  /** ìµœì¢… TurnOutput ì´ë²¤íŠ¸ */
  onFinal?: (event: FinalEvent) => void;
  /** ì—ëŸ¬ ì´ë²¤íŠ¸ */
  onError?: (event: ErrorEvent) => void;
  /** ìŠ¤íŠ¸ë¦¼ ì™„ë£Œ */
  onComplete?: () => void;
}
</file>

<file path="frontend/vite.config.ts">
/// <reference types="vitest" />
import { defineConfig } from 'vite';
import react from '@vitejs/plugin-react';

// https://vite.dev/config/
export default defineConfig({
  plugins: [react()],
  server: {
    port: 8001, // RULE-011: í”„ë¡ íŠ¸ì—”ë“œëŠ” 8001~8010 ì‚¬ìš©
    strictPort: true, // í¬íŠ¸ ì¶©ëŒ ì‹œ fail-fast (ëŒ€ì—­ ë°– ì´ë™ ë°©ì§€)
    // ì¶©ëŒ ì‹œ: pnpm -C frontend dev --port 8002 (8002~8010 ì¤‘ ì„ íƒ)
  },
  build: {
    outDir: 'dist',
    sourcemap: true,
  },
  test: {
    globals: true,
    environment: 'jsdom',
    setupFiles: './src/setupTests.ts',
  },
});
</file>

<file path="shared/schemas/turn/turn_output.schema.json">
{
  "$defs": {
    "ActionCard": {
      "additionalProperties": false,
      "description": "ì•¡ì…˜ ì¹´ë“œ (Action Deck).\n\në§¤ í„´ AIê°€ ì¶”ì²œí•˜ëŠ” í–‰ë™ ì¹´ë“œì…ë‹ˆë‹¤.\nê° ì¹´ë“œì— ë¹„ìš©/ìœ„í—˜/ë³´ìƒ íŒíŠ¸ê°€ í¬í•¨ë©ë‹ˆë‹¤.\n\nAttributes:\n    id: ì¹´ë“œ ê³ ìœ  ID\n    label: ì¹´ë“œ ë¼ë²¨ (í‘œì‹œìš©)\n    description: ì¹´ë“œ ì„¤ëª… (ì„ íƒ)\n    cost: ì˜ˆìƒ ë¹„ìš©\n    risk: ìœ„í—˜ë„\n    hint: ì˜ˆìƒ ê²°ê³¼ íŒíŠ¸ (ì„ íƒ)",
      "properties": {
        "id": {
          "description": "ì¹´ë“œ ê³ ìœ  ID",
          "title": "Id",
          "type": "string"
        },
        "label": {
          "description": "ì¹´ë“œ ë¼ë²¨ (í‘œì‹œìš©)",
          "title": "Label",
          "type": "string"
        },
        "description": {
          "anyOf": [
            {
              "type": "string"
            },
            {
              "type": "null"
            }
          ],
          "default": null,
          "description": "ì¹´ë“œ ì„¤ëª… (ì„ íƒ)",
          "title": "Description"
        },
        "cost": {
          "$ref": "#/$defs/CurrencyAmount",
          "description": "ì˜ˆìƒ ë¹„ìš©"
        },
        "risk": {
          "$ref": "#/$defs/RiskLevel",
          "default": "low",
          "description": "ìœ„í—˜ë„"
        },
        "hint": {
          "anyOf": [
            {
              "type": "string"
            },
            {
              "type": "null"
            }
          ],
          "default": null,
          "description": "ì˜ˆìƒ ê²°ê³¼ íŒíŠ¸ (ì„ íƒ)",
          "title": "Hint"
        }
      },
      "required": [
        "id",
        "label",
        "cost"
      ],
      "title": "ActionCard",
      "type": "object"
    },
    "ActionDeck": {
      "additionalProperties": false,
      "description": "ì•¡ì…˜ ë± (Q1 ê²°ì •: ui.action_deck.cards[] êµ¬ì¡°).\n\në§¤ í„´ AIê°€ ì œì‹œí•˜ëŠ” ì¶”ì²œ í–‰ë™ ì¹´ë“œ ë±ì…ë‹ˆë‹¤.\n\nAttributes:\n    cards: ì•¡ì…˜ ì¹´ë“œ ëª©ë¡ (3~6ì¥ ê¶Œì¥)",
      "properties": {
        "cards": {
          "default": [],
          "description": "ì•¡ì…˜ ì¹´ë“œ ëª©ë¡ (3~6ì¥ ê¶Œì¥)",
          "items": {
            "$ref": "#/$defs/ActionCard"
          },
          "maxItems": 10,
          "minItems": 0,
          "title": "Cards",
          "type": "array"
        }
      },
      "title": "ActionDeck",
      "type": "object"
    },
    "AgentConsole": {
      "additionalProperties": false,
      "description": "ì—ì´ì „íŠ¸ ì½˜ì†” ë°ì´í„° (RULE-008).\n\nì—ì´ì „íŠ¸í˜• ì‹œìŠ¤í…œì„ì„ UIë¡œ ì¦ëª…í•˜ê¸° ìœ„í•œ ì •ë³´ì…ë‹ˆë‹¤.\nê³„íš/ì‹¤í–‰/ê²€ì¦/ë³µêµ¬ì˜ í”ì ì„ í‘œì‹œí•©ë‹ˆë‹¤.\n\nAttributes:\n    current_phase: í˜„ì¬ ì‹¤í–‰ ë‹¨ê³„\n    badges: ê²€ì¦ ë°°ì§€ ëª©ë¡\n    repair_count: ìë™ ë³µêµ¬ ì‹œë„ íšŸìˆ˜",
      "properties": {
        "current_phase": {
          "$ref": "#/$defs/AgentPhase",
          "default": "commit",
          "description": "í˜„ì¬ ì‹¤í–‰ ë‹¨ê³„"
        },
        "badges": {
          "default": [],
          "description": "ê²€ì¦ ë°°ì§€ ëª©ë¡",
          "items": {
            "$ref": "#/$defs/ValidationBadge"
          },
          "title": "Badges",
          "type": "array"
        },
        "repair_count": {
          "default": 0,
          "description": "ìë™ ë³µêµ¬ ì‹œë„ íšŸìˆ˜",
          "minimum": 0,
          "title": "Repair Count",
          "type": "integer"
        }
      },
      "title": "AgentConsole",
      "type": "object"
    },
    "AgentPhase": {
      "description": "ì—ì´ì „íŠ¸ ì‹¤í–‰ ë‹¨ê³„ (RULE-008).\n\nì—ì´ì „íŠ¸í˜• ì‹œìŠ¤í…œì„ì„ UIë¡œ ì¦ëª…í•˜ê¸° ìœ„í•œ ë‹¨ê³„ í‘œì‹œ.",
      "enum": [
        "parse",
        "validate",
        "plan",
        "resolve",
        "render",
        "verify",
        "commit"
      ],
      "title": "AgentPhase",
      "type": "string"
    },
    "Box2D": {
      "additionalProperties": false,
      "description": "2D ë°”ìš´ë”© ë°•ìŠ¤ (RULE-009).\n\nì¢Œí‘œëŠ” 0~1000 ì •ê·œí™” ì¢Œí‘œê³„ì´ë©°, bboxëŠ” [ymin, xmin, ymax, xmax] ìˆœì„œì…ë‹ˆë‹¤.\nì´ë¯¸ì§€ ì´í•´ bbox í¬ë§·ê³¼ í˜¸í™˜ë©ë‹ˆë‹¤.\n\nAttributes:\n    ymin: Y ìµœì†Œê°’ (ìƒë‹¨)\n    xmin: X ìµœì†Œê°’ (ì¢Œì¸¡)\n    ymax: Y ìµœëŒ€ê°’ (í•˜ë‹¨)\n    xmax: X ìµœëŒ€ê°’ (ìš°ì¸¡)",
      "properties": {
        "ymin": {
          "description": "ì •ê·œí™” ì¢Œí‘œ (0~1000)",
          "maximum": 1000,
          "minimum": 0,
          "title": "Ymin",
          "type": "integer"
        },
        "xmin": {
          "description": "ì •ê·œí™” ì¢Œí‘œ (0~1000)",
          "maximum": 1000,
          "minimum": 0,
          "title": "Xmin",
          "type": "integer"
        },
        "ymax": {
          "description": "ì •ê·œí™” ì¢Œí‘œ (0~1000)",
          "maximum": 1000,
          "minimum": 0,
          "title": "Ymax",
          "type": "integer"
        },
        "xmax": {
          "description": "ì •ê·œí™” ì¢Œí‘œ (0~1000)",
          "maximum": 1000,
          "minimum": 0,
          "title": "Xmax",
          "type": "integer"
        }
      },
      "required": [
        "ymin",
        "xmin",
        "ymax",
        "xmax"
      ],
      "title": "Box2D",
      "type": "object"
    },
    "CurrencyAmount": {
      "additionalProperties": false,
      "description": "ì¬í™” ìˆ˜ëŸ‰.\n\nAttributes:\n    signal: ê¸°ë³¸ ì¬í™” (í…ìŠ¤íŠ¸ í„´/ì´ë¯¸ì§€ ìƒì„±/ê³ ê¸‰ ê¸°ëŠ¥ì— ì†Œë¹„)\n    memory_shard: í¬ê·€ ì¬í™” (ì¤‘ìš” ì„¤ì • ê³ ì •, ê³ í•´ìƒë„ ì´ë¯¸ì§€ ë“±ì— ì†Œë¹„)",
      "properties": {
        "signal": {
          "description": "ì‹œê·¸ë„ (ê¸°ë³¸ ì¬í™”, 0 ì´ìƒ)",
          "minimum": 0,
          "title": "Signal",
          "type": "integer"
        },
        "memory_shard": {
          "description": "ê¸°ì–µ íŒŒí¸ (í¬ê·€ ì¬í™”, 0 ì´ìƒ)",
          "minimum": 0,
          "title": "Memory Shard",
          "type": "integer"
        }
      },
      "required": [
        "signal",
        "memory_shard"
      ],
      "title": "CurrencyAmount",
      "type": "object"
    },
    "EconomyOutput": {
      "additionalProperties": false,
      "description": "ê²½ì œ ì¶œë ¥ ë°ì´í„° (RULE-005).\n\nì´ë²ˆ í„´ì˜ ë¹„ìš©ê³¼ ì”ì•¡ ì •ë³´ì…ë‹ˆë‹¤.\nì”ì•¡ ìŒìˆ˜ëŠ” ì ˆëŒ€ ë¶ˆê°€ (ì„œë²„ Hard gate).\n\nAttributes:\n    cost: ì´ë²ˆ í„´ì— ì†Œë¹„ëœ ë¹„ìš©\n    balance_after: ì†Œë¹„ í›„ ì”ì•¡\n\nImportant:\n    - costì™€ balance_afterëŠ” í•­ìƒ í¬í•¨ë˜ì–´ì•¼ í•©ë‹ˆë‹¤.\n    - balance_afterì˜ signalê³¼ memory_shardëŠ” 0 ì´ìƒì´ì–´ì•¼ í•©ë‹ˆë‹¤.",
      "properties": {
        "cost": {
          "$ref": "#/$defs/CurrencyAmount",
          "description": "ì´ë²ˆ í„´ì— ì†Œë¹„ëœ ë¹„ìš©"
        },
        "balance_after": {
          "$ref": "#/$defs/CurrencyAmount",
          "description": "ì†Œë¹„ í›„ ì”ì•¡"
        }
      },
      "required": [
        "cost",
        "balance_after"
      ],
      "title": "EconomyOutput",
      "type": "object"
    },
    "ImageJob": {
      "additionalProperties": false,
      "description": "ì´ë¯¸ì§€ ìƒì„± ì‘ì—….\n\nì¡°ê±´ë¶€ ì´ë¯¸ì§€ ìƒì„±/í¸ì§‘ ìš”ì²­ì…ë‹ˆë‹¤.\nì´ë¯¸ì§€ ìƒì„±ì´ ëŠë¦´ ê²½ìš° í…ìŠ¤íŠ¸ ìš°ì„  ì¶œë ¥ + Lazy Loadingì„ ì‚¬ìš©í•©ë‹ˆë‹¤.\n\nAttributes:\n    should_generate: ì´ë¯¸ì§€ë¥¼ ìƒì„±í•´ì•¼ í•˜ëŠ”ì§€\n    prompt: ì´ë¯¸ì§€ ìƒì„± í”„ë¡¬í”„íŠ¸\n    model_label: ëª¨ë¸ ì„ íƒ ë¼ë²¨ (FAST/QUALITY/CHEAP/REF)\n    aspect_ratio: ê°€ë¡œì„¸ë¡œ ë¹„ìœ¨ (ì˜ˆ: \"16:9\", \"1:1\")\n    image_size: ì´ë¯¸ì§€ í¬ê¸° (ì˜ˆ: \"1024x1024\")\n    reference_image_ids: ì°¸ì¡° ì´ë¯¸ì§€ ID ëª©ë¡ (ì„ íƒ)",
      "properties": {
        "should_generate": {
          "description": "ì´ë¯¸ì§€ë¥¼ ìƒì„±í•´ì•¼ í•˜ëŠ”ì§€",
          "title": "Should Generate",
          "type": "boolean"
        },
        "prompt": {
          "default": "",
          "description": "ì´ë¯¸ì§€ ìƒì„± í”„ë¡¬í”„íŠ¸",
          "title": "Prompt",
          "type": "string"
        },
        "model_label": {
          "$ref": "#/$defs/ModelLabel",
          "default": "FAST",
          "description": "ëª¨ë¸ ì„ íƒ ë¼ë²¨"
        },
        "aspect_ratio": {
          "default": "16:9",
          "description": "ê°€ë¡œì„¸ë¡œ ë¹„ìœ¨",
          "title": "Aspect Ratio",
          "type": "string"
        },
        "image_size": {
          "default": "1024x1024",
          "description": "ì´ë¯¸ì§€ í¬ê¸°",
          "title": "Image Size",
          "type": "string"
        },
        "reference_image_ids": {
          "default": [],
          "description": "ì°¸ì¡° ì´ë¯¸ì§€ ID ëª©ë¡ (ì„ íƒ)",
          "items": {
            "type": "string"
          },
          "title": "Reference Image Ids",
          "type": "array"
        }
      },
      "required": [
        "should_generate"
      ],
      "title": "ImageJob",
      "type": "object"
    },
    "Language": {
      "description": "ì§€ì› ì–¸ì–´ (RULE-006).\n\nko/en í˜¼í•© ì¶œë ¥ ê¸ˆì§€. TurnInput.languageë¥¼ SSOTë¡œ ì‚¼ì•„\nëª¨ë“  UI/ë‚´ëŸ¬í‹°ë¸Œ/ì‹œìŠ¤í…œ ë©”ì‹œì§€ëŠ” ë™ì¼ ì–¸ì–´ë¡œ ê³ ì •í•©ë‹ˆë‹¤.",
      "enum": [
        "ko-KR",
        "en-US"
      ],
      "title": "Language",
      "type": "string"
    },
    "MemoryPin": {
      "additionalProperties": false,
      "description": "ì¤‘ìš” ì„¤ì • ê³ ì • í›„ë³´.\n\nì‚¬ìš©ìê°€ Memory Shardë¥¼ ì†Œë¹„í•´ ê³ ì •í•  ìˆ˜ ìˆëŠ” ì¤‘ìš” ì„¤ì •ì…ë‹ˆë‹¤.\n\nAttributes:\n    id: í•€ ê³ ìœ  ID\n    content: ê³ ì •í•  ë‚´ìš©\n    cost: ê³ ì •ì— í•„ìš”í•œ ë¹„ìš©",
      "properties": {
        "id": {
          "description": "í•€ ê³ ìœ  ID",
          "title": "Id",
          "type": "string"
        },
        "content": {
          "description": "ê³ ì •í•  ë‚´ìš©",
          "title": "Content",
          "type": "string"
        },
        "cost": {
          "$ref": "#/$defs/CurrencyAmount",
          "description": "ê³ ì •ì— í•„ìš”í•œ ë¹„ìš©"
        }
      },
      "required": [
        "id",
        "content",
        "cost"
      ],
      "title": "MemoryPin",
      "type": "object"
    },
    "ModelLabel": {
      "description": "ëª¨ë¸/í’ˆì§ˆ ì„ íƒ ë¼ë²¨ (RULE-008).\n\ní”„ë¡¬í”„íŠ¸ ë…¸ì¶œ ì—†ì´ \"ì™œ ì´ ì„ íƒì´ì—ˆëŠ”ì§€\"ë¥¼ ì‚¬ìš©ì ì¹œí™” ë¼ë²¨ë¡œ í‘œì‹œ.",
      "enum": [
        "FAST",
        "QUALITY",
        "CHEAP",
        "REF"
      ],
      "title": "ModelLabel",
      "type": "string"
    },
    "Quest": {
      "additionalProperties": false,
      "description": "í€˜ìŠ¤íŠ¸/ëª©í‘œ (Quest Panel).\n\ní”Œë ˆì´ì–´ê°€ ë‹¬ì„±í•´ì•¼ í•˜ëŠ” í˜„ì¬ ëª©í‘œì…ë‹ˆë‹¤.\n\nAttributes:\n    id: í€˜ìŠ¤íŠ¸ ê³ ìœ  ID\n    label: í€˜ìŠ¤íŠ¸ ì´ë¦„\n    is_completed: ë‹¬ì„± ì—¬ë¶€",
      "properties": {
        "id": {
          "description": "í€˜ìŠ¤íŠ¸ ê³ ìœ  ID",
          "title": "Id",
          "type": "string"
        },
        "label": {
          "description": "í€˜ìŠ¤íŠ¸ ì´ë¦„",
          "title": "Label",
          "type": "string"
        },
        "is_completed": {
          "default": false,
          "description": "ë‹¬ì„± ì—¬ë¶€",
          "title": "Is Completed",
          "type": "boolean"
        }
      },
      "required": [
        "id",
        "label"
      ],
      "title": "Quest",
      "type": "object"
    },
    "RenderOutput": {
      "additionalProperties": false,
      "description": "ë Œë”ë§ ì¶œë ¥ ë°ì´í„°.\n\nì´ë¯¸ì§€ ìƒì„±/í¸ì§‘ ê´€ë ¨ ì •ë³´ì…ë‹ˆë‹¤.\n\nAttributes:\n    image_job: ì´ë¯¸ì§€ ìƒì„± ì‘ì—… (ì„ íƒ)",
      "properties": {
        "image_job": {
          "anyOf": [
            {
              "$ref": "#/$defs/ImageJob"
            },
            {
              "type": "null"
            }
          ],
          "default": null,
          "description": "ì´ë¯¸ì§€ ìƒì„± ì‘ì—… (ì„ íƒ)"
        }
      },
      "title": "RenderOutput",
      "type": "object"
    },
    "RiskLevel": {
      "description": "í–‰ë™ ìœ„í—˜ë„ ìˆ˜ì¤€.",
      "enum": [
        "low",
        "medium",
        "high"
      ],
      "title": "RiskLevel",
      "type": "string"
    },
    "SafetyOutput": {
      "additionalProperties": false,
      "description": "ì•ˆì „ ì¶œë ¥ ë°ì´í„°.\n\nì•ˆì „ ì •ì±… ê´€ë ¨ ì •ë³´ì…ë‹ˆë‹¤.\nì°¨ë‹¨ ì‹œ ëª…ì‹œì  ë©”ì‹œì§€ì™€ í•¨ê»˜ ì•ˆì „í•œ ëŒ€ì²´ ê²°ê³¼ë¥¼ ì œê³µí•©ë‹ˆë‹¤.\n\nAttributes:\n    blocked: ì•ˆì „ ì •ì±…ì— ì˜í•´ ì°¨ë‹¨ë˜ì—ˆëŠ”ì§€\n    message: ì°¨ë‹¨ ì‹œ ì‚¬ìš©ìì—ê²Œ í‘œì‹œí•  ë©”ì‹œì§€ (ì„ íƒ)",
      "properties": {
        "blocked": {
          "default": false,
          "description": "ì•ˆì „ ì •ì±…ì— ì˜í•´ ì°¨ë‹¨ë˜ì—ˆëŠ”ì§€",
          "title": "Blocked",
          "type": "boolean"
        },
        "message": {
          "anyOf": [
            {
              "type": "string"
            },
            {
              "type": "null"
            }
          ],
          "default": null,
          "description": "ì°¨ë‹¨ ì‹œ ì‚¬ìš©ìì—ê²Œ í‘œì‹œí•  ë©”ì‹œì§€ (ì„ íƒ)",
          "title": "Message"
        }
      },
      "title": "SafetyOutput",
      "type": "object"
    },
    "SceneObject": {
      "additionalProperties": false,
      "description": "ì¥ë©´ ì˜¤ë¸Œì íŠ¸ (í´ë¦­ ê°€ëŠ¥í•œ í•«ìŠ¤íŒŸ).\n\ní™”ë©´ì—ì„œ í´ë¦­ ê°€ëŠ¥í•œ ì˜¤ë¸Œì íŠ¸ì…ë‹ˆë‹¤.\nì¢Œí‘œëŠ” 0~1000 ì •ê·œí™” ì¢Œí‘œê³„ë¥¼ ì‚¬ìš©í•©ë‹ˆë‹¤ (RULE-009).\n\nAttributes:\n    id: ì˜¤ë¸Œì íŠ¸ ê³ ìœ  ID\n    label: ì˜¤ë¸Œì íŠ¸ ë¼ë²¨ (í‘œì‹œìš©)\n    box_2d: ë°”ìš´ë”© ë°•ìŠ¤ [ymin, xmin, ymax, xmax]\n    interaction_hint: ìƒí˜¸ì‘ìš© íŒíŠ¸ (ì„ íƒ)",
      "properties": {
        "id": {
          "description": "ì˜¤ë¸Œì íŠ¸ ê³ ìœ  ID",
          "title": "Id",
          "type": "string"
        },
        "label": {
          "description": "ì˜¤ë¸Œì íŠ¸ ë¼ë²¨ (í‘œì‹œìš©)",
          "title": "Label",
          "type": "string"
        },
        "box_2d": {
          "$ref": "#/$defs/Box2D",
          "description": "ë°”ìš´ë”© ë°•ìŠ¤"
        },
        "interaction_hint": {
          "anyOf": [
            {
              "type": "string"
            },
            {
              "type": "null"
            }
          ],
          "default": null,
          "description": "ìƒí˜¸ì‘ìš© íŒíŠ¸ (ì„ íƒ)",
          "title": "Interaction Hint"
        }
      },
      "required": [
        "id",
        "label",
        "box_2d"
      ],
      "title": "SceneObject",
      "type": "object"
    },
    "UIOutput": {
      "additionalProperties": false,
      "description": "UI ì¶œë ¥ ë°ì´í„°.\n\nAIê°€ ìƒì„±í•œ UI ìš”ì†Œë“¤ì…ë‹ˆë‹¤.\nì±„íŒ… ë²„ë¸”ì´ ì•„ë‹Œ ê²Œì„ UIë¡œ í‘œí˜„ë©ë‹ˆë‹¤ (RULE-002).\n\nAttributes:\n    action_deck: ì•¡ì…˜ ì¹´ë“œ ë± (Q1 ê²°ì •: Option A ì±„íƒ)\n    objects: í´ë¦­ ê°€ëŠ¥í•œ ì¥ë©´ ì˜¤ë¸Œì íŠ¸ ëª©ë¡",
      "properties": {
        "action_deck": {
          "$ref": "#/$defs/ActionDeck",
          "description": "ì•¡ì…˜ ì¹´ë“œ ë±"
        },
        "objects": {
          "default": [],
          "description": "í´ë¦­ ê°€ëŠ¥í•œ ì¥ë©´ ì˜¤ë¸Œì íŠ¸ ëª©ë¡",
          "items": {
            "$ref": "#/$defs/SceneObject"
          },
          "title": "Objects",
          "type": "array"
        }
      },
      "title": "UIOutput",
      "type": "object"
    },
    "ValidationBadge": {
      "description": "ê²€ì¦ ë°°ì§€ (RULE-008).\n\ní„´ ê²°ê³¼ì— ëŒ€í•œ ê²€ì¦ ìƒíƒœë¥¼ í‘œì‹œí•©ë‹ˆë‹¤.",
      "enum": [
        "schema_ok",
        "schema_fail",
        "economy_ok",
        "economy_fail",
        "safety_ok",
        "safety_blocked",
        "consistency_ok",
        "consistency_fail"
      ],
      "title": "ValidationBadge",
      "type": "string"
    },
    "WorldDelta": {
      "additionalProperties": false,
      "description": "ì„¸ê³„ ìƒíƒœ ë³€í™” (Q2 ê²°ì •: Option A - delta ì¤‘ì‹¬).\n\nì´ë²ˆ í„´ì—ì„œ ë³€ê²½ëœ ì„¸ê³„ ìƒíƒœë¥¼ ë‚˜íƒ€ëƒ…ë‹ˆë‹¤.\nsnapshotì€ SaveGameì—ë§Œ ì €ì¥í•˜ê³ , ë§¤ í„´ì€ deltaë§Œ ì „ì†¡í•©ë‹ˆë‹¤.\n\nAttributes:\n    rules_changed: ë³€ê²½ë˜ê±°ë‚˜ ì¶”ê°€ëœ ê·œì¹™ ëª©ë¡\n    inventory_added: ì¶”ê°€ëœ ì¸ë²¤í† ë¦¬ ì•„ì´í…œ\n    inventory_removed: ì œê±°ëœ ì¸ë²¤í† ë¦¬ ì•„ì´í…œ\n    quests_updated: ì—…ë°ì´íŠ¸ëœ í€˜ìŠ¤íŠ¸(ëª©í‘œ) ëª©ë¡\n    relationships_changed: ë³€ê²½ëœ ê´€ê³„\n    memory_pins: ì¤‘ìš” ì„¤ì • ê³ ì • í›„ë³´",
      "properties": {
        "rules_changed": {
          "default": [],
          "description": "ë³€ê²½ëœ ê·œì¹™ ëª©ë¡",
          "items": {
            "$ref": "#/$defs/WorldRule"
          },
          "title": "Rules Changed",
          "type": "array"
        },
        "inventory_added": {
          "default": [],
          "description": "ì¶”ê°€ëœ ì¸ë²¤í† ë¦¬ ì•„ì´í…œ",
          "items": {
            "type": "string"
          },
          "title": "Inventory Added",
          "type": "array"
        },
        "inventory_removed": {
          "default": [],
          "description": "ì œê±°ëœ ì¸ë²¤í† ë¦¬ ì•„ì´í…œ",
          "items": {
            "type": "string"
          },
          "title": "Inventory Removed",
          "type": "array"
        },
        "quests_updated": {
          "default": [],
          "description": "ì—…ë°ì´íŠ¸ëœ í€˜ìŠ¤íŠ¸/ëª©í‘œ ëª©ë¡",
          "items": {
            "$ref": "#/$defs/Quest"
          },
          "title": "Quests Updated",
          "type": "array"
        },
        "relationships_changed": {
          "default": [],
          "description": "ë³€ê²½ëœ ê´€ê³„",
          "items": {
            "type": "string"
          },
          "title": "Relationships Changed",
          "type": "array"
        },
        "memory_pins": {
          "default": [],
          "description": "ì¤‘ìš” ì„¤ì • ê³ ì • í›„ë³´",
          "items": {
            "$ref": "#/$defs/MemoryPin"
          },
          "title": "Memory Pins",
          "type": "array"
        }
      },
      "title": "WorldDelta",
      "type": "object"
    },
    "WorldRule": {
      "additionalProperties": false,
      "description": "ì„¸ê³„ ê·œì¹™ (Rule Board).\n\ní˜„ì¬ ì„¸ê³„ì— ì ìš© ì¤‘ì¸ ë¬¼ë¦¬ ë²•ì¹™ì´ë‚˜ ë©”íƒ€ ê·œì¹™ì…ë‹ˆë‹¤.\n\nAttributes:\n    id: ê·œì¹™ ê³ ìœ  ID\n    label: ê·œì¹™ ì´ë¦„\n    description: ê·œì¹™ ìƒì„¸ ì„¤ëª… (ì„ íƒ)",
      "properties": {
        "id": {
          "description": "ê·œì¹™ ê³ ìœ  ID",
          "title": "Id",
          "type": "string"
        },
        "label": {
          "description": "ê·œì¹™ ì´ë¦„",
          "title": "Label",
          "type": "string"
        },
        "description": {
          "anyOf": [
            {
              "type": "string"
            },
            {
              "type": "null"
            }
          ],
          "default": null,
          "description": "ê·œì¹™ ìƒì„¸ ì„¤ëª… (ì„ íƒ)",
          "title": "Description"
        }
      },
      "required": [
        "id",
        "label"
      ],
      "title": "WorldRule",
      "type": "object"
    }
  },
  "additionalProperties": false,
  "description": "í„´ ì¶œë ¥ (ì„œë²„ â†’ í´ë¼ì´ì–¸íŠ¸).\n\nì„œë²„ê°€ í„´ ì²˜ë¦¬ í›„ í´ë¼ì´ì–¸íŠ¸ë¡œ ë°˜í™˜í•˜ëŠ” êµ¬ì¡°í™”ëœ ì‘ë‹µì…ë‹ˆë‹¤.\nGemini Structured Outputs(JSON Schema)ë¡œ ê°•ì œë©ë‹ˆë‹¤.\n\nHard Gate í•„ë“œ (RULE-003/004/005):\n    - economy: costì™€ balance_after í•„ìˆ˜, ì”ì•¡ ìŒìˆ˜ ê¸ˆì§€\n    - safety: blocked ì‹œ ì•ˆì „í•œ ëŒ€ì²´ ê²°ê³¼ ì œê³µ\n    - language: ìš”ì²­ ì–¸ì–´ì™€ ë™ì¼í•˜ê²Œ ê³ ì • (í˜¼í•© ì¶œë ¥ ê¸ˆì§€)\n\nAttributes:\n    language: ì‘ë‹µ ì–¸ì–´ (ìš”ì²­ê³¼ ë™ì¼)\n    narrative: ë‚´ëŸ¬í‹°ë¸Œ í…ìŠ¤íŠ¸ (í‘œì‹œìš©)\n    ui: UI ìš”ì†Œ (ì•¡ì…˜ ë±, ì˜¤ë¸Œì íŠ¸)\n    world: ì„¸ê³„ ìƒíƒœ ë³€í™” (delta ì¤‘ì‹¬)\n    render: ë Œë”ë§ ì •ë³´ (ì´ë¯¸ì§€ ìƒì„± ì‘ì—…)\n    economy: ê²½ì œ ì •ë³´ (ë¹„ìš©, ì”ì•¡)\n    safety: ì•ˆì „ ì •ì±… ì •ë³´\n    agent_console: ì—ì´ì „íŠ¸ ì‹¤í–‰ ì •ë³´ (ë‹¨ê³„, ë°°ì§€, ë³µêµ¬ íšŸìˆ˜)\n\nExample:\n    >>> output = TurnOutput(\n    ...     language=Language.KO,\n    ...     narrative=\"ë¬¸ì´ ì‚ê±±ê±°ë¦¬ë©° ì—´ë¦½ë‹ˆë‹¤...\",\n    ...     economy=EconomyOutput(\n    ...         cost=CurrencyAmount(signal=5, memory_shard=0),\n    ...         balance_after=CurrencyAmount(signal=95, memory_shard=5),\n    ...     ),\n    ...     safety=SafetyOutput(blocked=False),\n    ... )\n    >>> schema = TurnOutput.model_json_schema()\n\nSchema Generation:\n    >>> # Gemini Structured Outputsìš© JSON Schema ìƒì„±\n    >>> json_schema = TurnOutput.model_json_schema()\n    >>> # response_json_schema íŒŒë¼ë¯¸í„°ì— ì „ë‹¬\n    >>> config = {\n    ...     \"response_mime_type\": \"application/json\",\n    ...     \"response_json_schema\": json_schema,\n    ... }",
  "properties": {
    "language": {
      "$ref": "#/$defs/Language",
      "description": "ì‘ë‹µ ì–¸ì–´ (ìš”ì²­ê³¼ ë™ì¼)"
    },
    "narrative": {
      "description": "ë‚´ëŸ¬í‹°ë¸Œ í…ìŠ¤íŠ¸ (í‘œì‹œìš©)",
      "title": "Narrative",
      "type": "string"
    },
    "economy": {
      "$ref": "#/$defs/EconomyOutput",
      "description": "ê²½ì œ ì •ë³´ (ë¹„ìš©, ì”ì•¡)"
    },
    "safety": {
      "$ref": "#/$defs/SafetyOutput",
      "description": "ì•ˆì „ ì •ì±… ì •ë³´"
    },
    "ui": {
      "$ref": "#/$defs/UIOutput",
      "description": "UI ìš”ì†Œ"
    },
    "world": {
      "$ref": "#/$defs/WorldDelta",
      "description": "ì„¸ê³„ ìƒíƒœ ë³€í™” (delta)"
    },
    "render": {
      "$ref": "#/$defs/RenderOutput",
      "description": "ë Œë”ë§ ì •ë³´"
    },
    "agent_console": {
      "$ref": "#/$defs/AgentConsole",
      "description": "ì—ì´ì „íŠ¸ ì‹¤í–‰ ì •ë³´"
    }
  },
  "required": [
    "language",
    "narrative",
    "economy",
    "safety"
  ],
  "title": "TurnOutput",
  "type": "object"
}
</file>

<file path="backend/pyproject.toml">
# backend/pyproject.toml
# SSOT: vibe/tech-stack.md (ë²„ì „ ê¸°ì¤€ì¼: 2026-01-01)

[build-system]
requires = ["hatchling"]
build-backend = "hatchling.build"

[project]
name = "unknown-world-backend"
version = "0.1.0"
description = "Unknown World Backend - Gemini ê¸°ë°˜ ì—ì´ì „íŠ¸í˜• ê²Œì„ ì—”ì§„"
requires-python = ">=3.14"
dependencies = [
    "fastapi==0.128.0",
    "uvicorn[standard]==0.40.0",
    "pydantic==2.12.5",
    "google-genai==1.56.0",
    "google-cloud-aiplatform==1.132.0",
    "google-cloud-storage==3.7.0",
]

[tool.hatch.build.targets.wheel]
packages = ["src/unknown_world"]

[dependency-groups]
dev = [
    "ruff==0.14.10",
    "pyright==1.1.407",
    "pytest==9.0.2",
    "httpx==0.28.1",
    "jsonschema>=4.26.0",
]

[tool.ruff]
line-length = 100
target-version = "py314"
extend-exclude = [
    "__pycache__",
    ".ruff_cache",
    ".venv",
    "venv",
    "dist",
    "build",
]

[tool.ruff.lint]
select = [
    "E",      # pycodestyle errors
    "W",      # pycodestyle warnings
    "F",      # pyflakes
    "I",      # isort
    "UP",     # pyupgrade
    "B",      # flake8-bugbear
    "C4",     # flake8-comprehensions
    "SIM",    # flake8-simplify
]
ignore = [
    "E501",   # line too long (handled by formatter)
]

[tool.ruff.format]
quote-style = "double"
indent-style = "space"

[tool.pyright]
pythonVersion = "3.14"
typeCheckingMode = "strict"
include = ["src"]
</file>

<file path="package.json">
{
  "name": "unknown-world",
  "version": "0.1.0",
  "private": true,
  "description": "Unknown World - Gemini ê¸°ë°˜ ì—ì´ì „íŠ¸í˜• ê²Œì„ ì—”ì§„",
  "packageManager": "pnpm@10.27.0",
  "engines": {
    "node": "24.12.0"
  },
  "scripts": {
    "kill": "pnpm kill:port",
    "kill:port": "npx --yes kill-port 8001 8002 8003 8004 8005 8006 8007 8008 8009 8010 8011 8012 8013 8014 8015 8016 8017 8018 8019 8020",
    "kill:front": "npx --yes kill-port 8001 8002 8003 8004 8005 8006 8007 8008 8009 8010",
    "kill:back": "npx --yes kill-port 8011 8012 8013 8014 8015 8016 8017 8018 8019 8020",
    "dev:back": "cd backend && uv run uvicorn unknown_world.main:app --reload --port 8011",
    "dev:front": "pnpm -C frontend dev"
  }
}
</file>

<file path="frontend/package.json">
{
  "name": "unknown-world-frontend",
  "private": true,
  "version": "0.0.0",
  "type": "module",
  "packageManager": "pnpm@10.27.0",
  "scripts": {
    "dev": "vite",
    "build": "tsc -b && vite build",
    "preview": "vite preview",
    "format": "prettier . --write",
    "format:check": "prettier . --check",
    "lint": "eslint .",
    "lint:fix": "eslint . --fix",
    "typecheck": "tsc --noEmit",
    "test": "vitest run",
    "test:watch": "vitest",
    "test:coverage": "vitest run --coverage"
  },
  "dependencies": {
    "@dnd-kit/core": "6.3.1",
    "@dnd-kit/sortable": "10.0.0",
    "i18next": "25.7.3",
    "react": "19.2.3",
    "react-dom": "19.2.3",
    "react-i18next": "16.5.1",
    "zod": "4.3.4",
    "zustand": "5.0.9"
  },
  "devDependencies": {
    "@eslint/js": "9.39.2",
    "@testing-library/jest-dom": "^6.9.1",
    "@testing-library/react": "^16.3.1",
    "@types/node": "25.0.3",
    "@types/react": "19.2.7",
    "@types/react-dom": "19.2.3",
    "@vitejs/plugin-react": "5.1.2",
    "@vitest/coverage-v8": "^4.0.16",
    "eslint": "9.39.2",
    "eslint-config-prettier": "10.1.8",
    "eslint-plugin-react": "7.37.5",
    "eslint-plugin-react-hooks": "7.0.1",
    "eslint-plugin-unused-imports": "4.3.0",
    "globals": "16.5.0",
    "jsdom": "^27.4.0",
    "prettier": "3.7.4",
    "typescript": "5.9.3",
    "typescript-eslint": "8.51.0",
    "vite": "7.3.0",
    "vitest": "^4.0.16"
  },
  "pnpm": {
    "onlyBuiltDependencies": [
      "esbuild"
    ]
  }
}
</file>

<file path="frontend/public/ui/manifest.json">
{
  "$schema": "./manifest.schema.json",
  "version": "1.4.0",
  "generatedAt": "2026-01-14T14:55:00Z",
  "totalBytes": 570867,
  "budgetBytes": 1572864,
  "assets": [
    {
      "id": "signal-24",
      "path": "icons/signal-24.png",
      "type": "icon",
      "size": 24,
      "fallback": "âš¡",
      "usedIn": ["EconomyHUD"],
      "bytes": 1573,
      "notes": "U-038: v2 ì¬ìƒì„±, nanobanana mcp(í”½ì…€ì•„íŠ¸), rembg(birefnet-general), ImageMagick ìµœì í™”"
    },
    {
      "id": "signal-16",
      "path": "icons/signal-16.png",
      "type": "icon",
      "size": 16,
      "fallback": "âš¡",
      "usedIn": ["ActionDeck"],
      "bytes": 1012,
      "notes": "U-038: v2 ì¬ìƒì„±, nanobanana mcp(í”½ì…€ì•„íŠ¸), rembg(birefnet-general), ImageMagick ìµœì í™”"
    },
    {
      "id": "shard-24",
      "path": "icons/shard-24.png",
      "type": "icon",
      "size": 24,
      "fallback": "ğŸ’",
      "usedIn": ["EconomyHUD"],
      "bytes": 1362,
      "notes": "U-038: v2 ì¬ìƒì„±, nanobanana mcp(í”½ì…€ì•„íŠ¸), rembg(birefnet-general), ImageMagick ìµœì í™”"
    },
    {
      "id": "shard-16",
      "path": "icons/shard-16.png",
      "type": "icon",
      "size": 16,
      "fallback": "ğŸ’",
      "usedIn": ["ActionDeck"],
      "bytes": 1147,
      "notes": "U-038: shard-24ì—ì„œ ë¦¬ì‚¬ì´ì¦ˆ, 16px ìµœì í™”"
    },
    {
      "id": "badge-ok-24",
      "path": "icons/badge-ok-24.png",
      "type": "icon",
      "size": 24,
      "fallback": "âœ“",
      "usedIn": ["AgentConsole"],
      "bytes": 1461,
      "notes": "U-038: v2 ì¬ìƒì„±, nanobanana mcp(í”½ì…€ì•„íŠ¸), rembg(birefnet-general), ImageMagick ìµœì í™”"
    },
    {
      "id": "badge-ok-16",
      "path": "icons/badge-ok-16.png",
      "type": "icon",
      "size": 16,
      "fallback": "âœ“",
      "usedIn": [],
      "bytes": 1096,
      "notes": "U-038: v2 ì¬ìƒì„±, nanobanana mcp(í”½ì…€ì•„íŠ¸), rembg(birefnet-general), ImageMagick ìµœì í™”"
    },
    {
      "id": "badge-fail-24",
      "path": "icons/badge-fail-24.png",
      "type": "icon",
      "size": 24,
      "fallback": "âœ—",
      "usedIn": ["AgentConsole"],
      "bytes": 2006,
      "notes": "U-038: v2 ì¬ìƒì„±, nanobanana mcp(í”½ì…€ì•„íŠ¸), rembg(birefnet-general), ImageMagick ìµœì í™”"
    },
    {
      "id": "risk-medium-24",
      "path": "icons/risk-medium-24.png",
      "type": "icon",
      "size": 24,
      "fallback": "âš ",
      "usedIn": [],
      "bytes": 1594,
      "notes": "U-038: 24px í˜ì–´ ë³´ê°•, nanobanana mcp ìƒì„±"
    },
    {
      "id": "risk-medium-16",
      "path": "icons/risk-medium-16.png",
      "type": "icon",
      "size": 16,
      "fallback": "âš ",
      "usedIn": ["ActionDeck"],
      "bytes": 1256,
      "notes": "U-038: v2 ì¬ìƒì„±, nanobanana mcp(í”½ì…€ì•„íŠ¸), rembg(birefnet-general), ImageMagick ìµœì í™”"
    },
    {
      "id": "risk-low-24",
      "path": "icons/risk-low-24.png",
      "type": "icon",
      "size": 24,
      "fallback": "âœ“",
      "usedIn": [],
      "bytes": 1838,
      "notes": "U-038: v2 ì¬ìƒì„±, nanobanana mcp(í”½ì…€ì•„íŠ¸), rembg(birefnet-general), ImageMagick ìµœì í™”"
    },
    {
      "id": "risk-low-16",
      "path": "icons/risk-low-16.png",
      "type": "icon",
      "size": 16,
      "fallback": "âœ“",
      "usedIn": ["ActionDeck"],
      "bytes": 1331,
      "notes": "U-038: v2 ì¬ìƒì„±, nanobanana mcp(í”½ì…€ì•„íŠ¸), rembg(birefnet-general), ImageMagick ìµœì í™”"
    },
    {
      "id": "risk-high-24",
      "path": "icons/risk-high-24.png",
      "type": "icon",
      "size": 24,
      "fallback": "âš ",
      "usedIn": [],
      "bytes": 1737,
      "notes": "U-038: v2 ì¬ìƒì„±, nanobanana mcp(í”½ì…€ì•„íŠ¸), rembg(birefnet-general), ImageMagick ìµœì í™”"
    },
    {
      "id": "risk-high-16",
      "path": "icons/risk-high-16.png",
      "type": "icon",
      "size": 16,
      "fallback": "âš ",
      "usedIn": ["ActionDeck"],
      "bytes": 1227,
      "notes": "U-038: v2 ì¬ìƒì„±, nanobanana mcp(í”½ì…€ì•„íŠ¸), rembg(birefnet-general), ImageMagick ìµœì í™”"
    },
    {
      "id": "status-online-16",
      "path": "icons/status-online-16.png",
      "type": "icon",
      "size": 16,
      "fallback": "â—",
      "usedIn": [],
      "bytes": 1375,
      "notes": "U-038: v2 ì¬ìƒì„±, nanobanana mcp(í”½ì…€ì•„íŠ¸), rembg(birefnet-general), ImageMagick ìµœì í™”"
    },
    {
      "id": "scene-placeholder-default",
      "path": "placeholders/scene-placeholder-default.png",
      "type": "placeholder",
      "fallback": "[SCENE]",
      "usedIn": ["SceneCanvas"],
      "bytes": 261407,
      "notes": "nanobanana mcp ìƒì„±, ë ˆíŠ¸ë¡œ í„°ë¯¸ë„ ìŠ¤íƒ€ì¼"
    },
    {
      "id": "scene-loading",
      "path": "placeholders/scene-loading.webp",
      "type": "placeholder",
      "fallback": "â³",
      "usedIn": ["SceneCanvas"],
      "bytes": 47850,
      "notes": "U-031: ë¡œë”© ìƒíƒœ placeholder, nanobanana mcp ìƒì„±, ImageMagick(magick) ìµœì í™”"
    },
    {
      "id": "scene-offline",
      "path": "placeholders/scene-offline.webp",
      "type": "placeholder",
      "fallback": "ğŸ”Œ",
      "usedIn": ["SceneCanvas"],
      "bytes": 44658,
      "notes": "U-031: ì˜¤í”„ë¼ì¸ ìƒíƒœ placeholder, nanobanana mcp ìƒì„±, ImageMagick(magick) ìµœì í™”"
    },
    {
      "id": "scene-blocked",
      "path": "placeholders/scene-blocked.webp",
      "type": "placeholder",
      "fallback": "ğŸš«",
      "usedIn": ["SceneCanvas"],
      "bytes": 17318,
      "notes": "U-031: ì°¨ë‹¨ ìƒíƒœ placeholder, nanobanana mcp ìƒì„±, ImageMagick(magick) ìµœì í™”"
    },
    {
      "id": "scene-low-signal",
      "path": "placeholders/scene-low-signal.webp",
      "type": "placeholder",
      "fallback": "ğŸ“‰",
      "usedIn": ["SceneCanvas"],
      "bytes": 68454,
      "notes": "U-031: ì €ì‹ í˜¸ ìƒíƒœ placeholder, nanobanana mcp ìƒì„±, ImageMagick(magick) ìµœì í™”"
    },
    {
      "id": "panel-corner-br",
      "path": "chrome/panel-corner-br.png",
      "type": "chrome",
      "fallback": "",
      "usedIn": ["PanelHeader"],
      "bytes": 1899,
      "notes": "U-032: íŒ¨ë„ ì½”ë„ˆ ì¥ì‹, nanobanana mcp ìƒì„±, rembg ë°°ê²½ ì œê±°, ImageMagick ìµœì í™”(48x48), CSS transformìœ¼ë¡œ 4ë°©í–¥ ì ìš©"
    },
    {
      "id": "card-frame",
      "path": "chrome/card-frame.png",
      "type": "chrome",
      "fallback": "",
      "usedIn": ["ActionCard"],
      "bytes": 9101,
      "notes": "U-032: ì•¡ì…˜ ì¹´ë“œ í”„ë ˆì„, nanobanana mcp ìƒì„±, rembg ë°°ê²½ ì œê±°, ImageMagick ìµœì í™”(160x80)"
    },
    {
      "id": "scanner-frame",
      "path": "chrome/scanner-frame.png",
      "type": "chrome",
      "fallback": "",
      "usedIn": ["Scanner"],
      "bytes": 100165,
      "notes": "U-032: ìŠ¤ìºë„ˆ ìŠ¬ë¡¯ í”„ë ˆì„, nanobanana mcp ìƒì„±, rembg(birefnet-general) ë°°ê²½ ì œê±°, ImageMagick ìµœì í™”(346x200) ì™„ë£Œ"
    }
  ]
}
</file>

<file path="frontend/src/api/turnStream.ts">
/**
 * Unknown World - HTTP Streaming í´ë¼ì´ì–¸íŠ¸ + NDJSON íŒŒì„œ.
 *
 * fetch ê¸°ë°˜ìœ¼ë¡œ POST ìš”ì²­ì„ ë³´ë‚´ê³  ì‘ë‹µ ìŠ¤íŠ¸ë¦¼ì„ NDJSONìœ¼ë¡œ íŒŒì‹±í•©ë‹ˆë‹¤.
 * ì¤‘ê°„ ì²­í¬ íŒŒì‹± ì‹¤íŒ¨ê°€ ì „ì²´ UIë¥¼ ë©ˆì¶”ì§€ ì•Šë„ë¡ ì„¤ê³„ë˜ì—ˆìŠµë‹ˆë‹¤.
 *
 * ì„¤ê³„ ì›ì¹™:
 *   - RULE-003: êµ¬ì¡°í™” ì¶œë ¥(JSON Schema) ìš°ì„  + ì´ì¤‘ ê²€ì¦
 *   - RULE-004: ê²€ì¦ ì‹¤íŒ¨ ì‹œ ì•ˆì „ í´ë°± ì œê³µ
 *   - RULE-008: ë‹¨ê³„/ë°°ì§€ ê°€ì‹œí™” (í”„ë¡¬í”„íŠ¸/ë‚´ë¶€ ì¶”ë¡  ë…¸ì¶œ ê¸ˆì§€)
 *   - RULE-011: ë°±ì—”ë“œ í¬íŠ¸ 8011 ì‚¬ìš©
 *
 * @module api/turnStream
 */

import type { TurnInput, TurnOutput, Language } from '../schemas/turn';
import { safeParseTurnOutput } from '../schemas/turn';
import type { StreamCallbacks } from '../types/turn_stream';
import {
  StreamEventType,
  BaseEventSchema,
  safeParseStageEvent,
  safeParseRepairEvent,
  safeParseBadgesEvent,
  safeParseNarrativeDeltaEvent,
  safeParseFinalEventRaw,
  safeParseErrorEvent,
  normalizeStageStatus,
} from '../types/turn_stream';

// Re-export ìŠ¤íŠ¸ë¦¼ ì´ë²¤íŠ¸ íƒ€ì…ë“¤ (í•˜ìœ„ í˜¸í™˜ì„± ìœ ì§€)
export type {
  StreamEventTypeName,
  StageStatusName,
  StageEvent,
  RepairEvent,
  BadgesEvent,
  NarrativeDeltaEvent,
  FinalEvent,
  ErrorEvent,
  StreamEvent,
  StreamCallbacks,
} from '../types/turn_stream';
export { StreamEventType, StageStatus } from '../types/turn_stream';

// =============================================================================
// NDJSON íŒŒì„œ (Q1 ê²°ì •: Option A - ì§ì ‘ êµ¬í˜„)
// =============================================================================

/**
 * NDJSON ë¼ì¸ íŒŒì„œ.
 * ë¶€ë¶„ ì²­í¬ë¥¼ ë²„í¼ë§í•˜ê³  ì™„ì „í•œ ë¼ì¸ì„ íŒŒì‹±í•©ë‹ˆë‹¤.
 */
export class NDJSONParser {
  private buffer = '';

  /**
   * ì²­í¬ë¥¼ íŒŒì‹±í•˜ê³  ì™„ì „í•œ JSON ê°ì²´ë“¤ì„ ë°˜í™˜í•©ë‹ˆë‹¤.
   *
   * @param chunk - ìˆ˜ì‹ ëœ í…ìŠ¤íŠ¸ ì²­í¬
   * @returns íŒŒì‹±ëœ JSON ê°ì²´ ë°°ì—´
   */
  parse(chunk: string): unknown[] {
    this.buffer += chunk;
    const results: unknown[] = [];

    // ì¤„ë°”ê¿ˆìœ¼ë¡œ ë¶„í• 
    const lines = this.buffer.split('\n');

    // ë§ˆì§€ë§‰ ë¼ì¸ì€ ë¶ˆì™„ì „í•  ìˆ˜ ìˆìœ¼ë¯€ë¡œ ë²„í¼ì— ìœ ì§€
    this.buffer = lines.pop() ?? '';

    for (const line of lines) {
      const trimmed = line.trim();
      if (trimmed === '') continue;

      try {
        const parsed = JSON.parse(trimmed);
        results.push(parsed);
      } catch {
        // íŒŒì‹± ì‹¤íŒ¨ ì‹œ í•´ë‹¹ ë¼ì¸ ë¬´ì‹œ (RULE-004: ì „ì²´ ì¤‘ë‹¨ ë°©ì§€)
        console.warn('[NDJSON] Failed to parse line:', trimmed);
      }
    }

    return results;
  }

  /**
   * ë²„í¼ë¥¼ ì´ˆê¸°í™”í•©ë‹ˆë‹¤.
   */
  reset(): void {
    this.buffer = '';
  }

  /**
   * ë‚¨ì€ ë²„í¼ë¥¼ í”ŒëŸ¬ì‹œí•˜ê³  ë§ˆì§€ë§‰ ê°ì²´ë¥¼ íŒŒì‹±í•©ë‹ˆë‹¤.
   */
  flush(): unknown | null {
    const trimmed = this.buffer.trim();
    this.buffer = '';

    if (trimmed === '') return null;

    try {
      return JSON.parse(trimmed);
    } catch {
      console.warn('[NDJSON] Failed to parse remaining buffer:', trimmed);
      return null;
    }
  }
}

// =============================================================================
// ìŠ¤íŠ¸ë¦¼ ì´ë²¤íŠ¸ í•¸ë“¤ëŸ¬
// =============================================================================

/**
 * íŒŒì‹±ëœ ì´ë²¤íŠ¸ë¥¼ íƒ€ì…ë³„ë¡œ ë¶„ë°°í•©ë‹ˆë‹¤.
 *
 * RU-002-S2: ìºìŠ¤íŒ… ëŒ€ì‹  Zod safeParseë¥¼ ì ìš©í•˜ì—¬ ê²€ì¦ ê°•í™”.
 * Unknown/í™•ì¥ ì´ë²¤íŠ¸ëŠ” UIë¥¼ ë©ˆì¶”ì§€ ì•Šê³  ê²½ê³ ë§Œ ì¶œë ¥.
 *
 * @param event - íŒŒì‹±ëœ ì´ë²¤íŠ¸ ê°ì²´
 * @param callbacks - ì½œë°± í•¨ìˆ˜ë“¤
 * @param language - í´ë°± ì–¸ì–´
 */
function dispatchEvent(event: unknown, callbacks: StreamCallbacks, language: Language): void {
  if (!event || typeof event !== 'object') return;

  // ê¸°ë³¸ ì´ë²¤íŠ¸ íƒ€ì… ì¶”ì¶œ
  const baseResult = BaseEventSchema.safeParse(event);
  if (!baseResult.success) {
    console.warn('[TurnStream] Invalid event format (no type field):', event);
    return;
  }

  const type = baseResult.data.type;

  switch (type) {
    case StreamEventType.STAGE: {
      // RU-002-S2: stage ì´ë²¤íŠ¸ ê²€ì¦
      const stageResult = safeParseStageEvent(event);
      if (stageResult.success) {
        // status ì •ê·œí™”: 'ok' â†’ 'complete'
        const normalizedStatus = normalizeStageStatus(stageResult.data.status);
        callbacks.onStage?.({
          type: StreamEventType.STAGE,
          name: stageResult.data.name,
          status: normalizedStatus,
        });
      } else {
        console.warn('[TurnStream] Invalid stage event:', stageResult.error.message);
      }
      break;
    }

    case StreamEventType.REPAIR: {
      // RU-002-S2: repair ì´ë²¤íŠ¸ ê²€ì¦
      const repairResult = safeParseRepairEvent(event);
      if (repairResult.success) {
        callbacks.onRepair?.(repairResult.data);
      } else {
        console.warn('[TurnStream] Invalid repair event:', repairResult.error.message);
      }
      break;
    }

    case StreamEventType.BADGES: {
      // RU-002-S2: badges ì´ë²¤íŠ¸ ê²€ì¦ (v1/v2 ì •ê·œí™” í¬í•¨)
      const badgesResult = safeParseBadgesEvent(event);
      if (badgesResult.success) {
        callbacks.onBadges?.(badgesResult.data);
      } else {
        console.warn('[TurnStream] Invalid badges event:', badgesResult.error.message);
      }
      break;
    }

    case StreamEventType.NARRATIVE_DELTA: {
      // RU-002-S2: narrative_delta ì´ë²¤íŠ¸ ê²€ì¦
      const narrativeResult = safeParseNarrativeDeltaEvent(event);
      if (narrativeResult.success) {
        callbacks.onNarrativeDelta?.(narrativeResult.data);
      } else {
        console.warn('[TurnStream] Invalid narrative_delta event:', narrativeResult.error.message);
      }
      break;
    }

    case StreamEventType.FINAL: {
      // RU-002-S2: final ì´ë²¤íŠ¸ êµ¬ì¡° ê²€ì¦
      const finalRawResult = safeParseFinalEventRaw(event);
      if (!finalRawResult.success) {
        console.warn('[TurnStream] Invalid final event structure:', finalRawResult.error.message);
        // êµ¬ì¡°ê°€ ì˜ëª»ë˜ì–´ë„ í´ë°± ì œê³µ
        callbacks.onFinal?.({
          type: StreamEventType.FINAL,
          data: createFallbackTurnOutput(language),
        });
        break;
      }

      // RULE-003/004: Zod strict parse + í´ë°±
      const turnOutputPayload = finalRawResult.data.data;
      const parseResult = safeParseTurnOutput(turnOutputPayload, language);

      if (parseResult.success) {
        callbacks.onFinal?.({
          type: StreamEventType.FINAL,
          data: parseResult.data,
        });
      } else {
        console.warn('[TurnStream] TurnOutput validation failed:', parseResult.error);
        callbacks.onFinal?.({
          type: StreamEventType.FINAL,
          data: parseResult.fallback,
        });
      }
      break;
    }

    case StreamEventType.ERROR: {
      // RU-002-S2: error ì´ë²¤íŠ¸ ê²€ì¦
      const errorResult = safeParseErrorEvent(event);
      if (errorResult.success) {
        callbacks.onError?.(errorResult.data);
      } else {
        console.warn('[TurnStream] Invalid error event:', errorResult.error.message);
        // ì—ëŸ¬ ì´ë²¤íŠ¸ê°€ ê¹¨ì§„ ê²½ìš°ì—ë„ ê¸°ë³¸ ì—ëŸ¬ ì „ë‹¬
        callbacks.onError?.({
          type: StreamEventType.ERROR,
          message: 'Unknown error (malformed error event)',
          code: 'INVALID_ERROR_EVENT',
        });
      }
      break;
    }

    default:
      // RU-002-S2: Unknown/í™•ì¥ ì´ë²¤íŠ¸ëŠ” UIë¥¼ ë©ˆì¶”ì§€ ì•Šê³  ê²½ê³ ë§Œ ì¶œë ¥
      // í–¥í›„ protocol, repair, telemetry ë“± í™•ì¥ ì´ë²¤íŠ¸ ë„ì… ì‹œ ì—¬ê¸°ì„œ ì²˜ë¦¬ ê°€ëŠ¥
      console.warn('[TurnStream] Unknown/ignored event type:', type, event);
  }
}

/**
 * í´ë¼ì´ì–¸íŠ¸ ì¸¡ í´ë°± TurnOutput ìƒì„± (ì–¸ì–´ë§Œ ì§€ì •).
 * dispatchEvent ë‚´ë¶€ì—ì„œ ì‚¬ìš©í•˜ëŠ” ê°„ë‹¨í•œ í´ë°±.
 */
function createFallbackTurnOutput(language: Language): TurnOutput {
  const fallbackNarrative =
    language === 'ko-KR'
      ? '[ì‹œìŠ¤í…œ] ì‘ë‹µ ë°ì´í„°ë¥¼ ì²˜ë¦¬í•˜ëŠ” ì¤‘ ë¬¸ì œê°€ ë°œìƒí–ˆìŠµë‹ˆë‹¤.'
      : '[System] An error occurred while processing response data.';

  return {
    language,
    narrative: fallbackNarrative,
    economy: {
      cost: { signal: 0, memory_shard: 0 },
      balance_after: { signal: 0, memory_shard: 0 },
    },
    safety: {
      blocked: false,
      message: null,
    },
    ui: {
      action_deck: { cards: [] },
      objects: [],
    },
    world: {
      rules_changed: [],
      inventory_added: [],
      inventory_removed: [],
      quests_updated: [],
      relationships_changed: [],
      memory_pins: [],
    },
    render: {
      image_job: null,
    },
    agent_console: {
      current_phase: 'commit',
      badges: ['schema_fail'],
      repair_count: 1,
    },
  };
}

// =============================================================================
// API ì„¤ì •
// =============================================================================

/** ë°±ì—”ë“œ API URL (RULE-011: í¬íŠ¸ 8011) */
const API_BASE_URL = 'http://localhost:8011';

/** í„´ ìŠ¤íŠ¸ë¦¼ API ì—”ë“œí¬ì¸íŠ¸ */
const TURN_ENDPOINT = `${API_BASE_URL}/api/turn`;

// =============================================================================
// ìŠ¤íŠ¸ë¦¼ í´ë¼ì´ì–¸íŠ¸
// =============================================================================

/** ìŠ¤íŠ¸ë¦¼ ìš”ì²­ ì˜µì…˜ */
export interface TurnStreamOptions {
  /** ìš”ì²­ íƒ€ì„ì•„ì›ƒ (ms) */
  timeout?: number;
  /** AbortSignal */
  signal?: AbortSignal;
}

/**
 * í„´ ìŠ¤íŠ¸ë¦¼ ìš”ì²­ì„ ì‹¤í–‰í•©ë‹ˆë‹¤.
 *
 * @param input - í„´ ì…ë ¥ ë°ì´í„°
 * @param callbacks - ì´ë²¤íŠ¸ ì½œë°±
 * @param options - ìš”ì²­ ì˜µì…˜
 * @returns ì·¨ì†Œ í•¨ìˆ˜
 */
export async function executeTurnStream(
  input: TurnInput,
  callbacks: StreamCallbacks,
  options?: TurnStreamOptions,
): Promise<void> {
  const parser = new NDJSONParser();
  const controller = new AbortController();
  const signal = options?.signal ?? controller.signal;

  // RU-002-S1: AbortError ë°œìƒ ì‹œ onComplete í˜¸ì¶œ ì—¬ë¶€ ì¶”ì 
  let aborted = false;

  try {
    const response = await fetch(TURN_ENDPOINT, {
      method: 'POST',
      headers: {
        'Content-Type': 'application/json',
        Accept: 'application/x-ndjson',
      },
      body: JSON.stringify(input),
      signal,
    });

    if (!response.ok) {
      throw new Error(`HTTP ${response.status}: ${response.statusText}`);
    }

    if (!response.body) {
      throw new Error('Response body is null');
    }

    const reader = response.body.getReader();
    const decoder = new TextDecoder('utf-8');

    // ìŠ¤íŠ¸ë¦¼ ì½ê¸° ë£¨í”„
    while (true) {
      const { done, value } = await reader.read();

      if (done) break;

      const chunk = decoder.decode(value, { stream: true });
      const events = parser.parse(chunk);

      for (const event of events) {
        dispatchEvent(event, callbacks, input.language);
      }
    }

    // ë‚¨ì€ ë²„í¼ í”ŒëŸ¬ì‹œ
    const remaining = parser.flush();
    if (remaining) {
      dispatchEvent(remaining, callbacks, input.language);
    }
  } catch (error) {
    if (error instanceof DOMException && error.name === 'AbortError') {
      // ì‚¬ìš©ìê°€ ì·¨ì†Œí•œ ê²½ìš° - finallyì—ì„œ onComplete í˜¸ì¶œí•˜ì§€ ì•ŠìŒ
      aborted = true;
      return;
    }

    const errorMessage = error instanceof Error ? error.message : 'Unknown error occurred';

    // RU-002-S1: ë„¤íŠ¸ì›Œí¬ ì—ëŸ¬ ì‹œì—ë„ onError í˜¸ì¶œ
    callbacks.onError?.({
      type: StreamEventType.ERROR,
      message: errorMessage,
      code: 'STREAM_ERROR',
    });

    // RU-002-S1: ë„¤íŠ¸ì›Œí¬ ì—ëŸ¬ ì‹œ í´ë¼ì´ì–¸íŠ¸ ì¸¡ í´ë°± final ìƒì„±
    // ì„œë²„ì—ì„œ finalì´ ì˜¤ì§€ ëª»í•œ ê²½ìš° UIê°€ ë©ˆì¶”ì§€ ì•Šë„ë¡ í•¨
    const fallback = createClientFallbackTurnOutput(input.language, input.economy_snapshot);
    callbacks.onFinal?.({
      type: StreamEventType.FINAL,
      data: fallback,
    });
  } finally {
    // RU-002-S1: ìŠ¤íŠ¸ë¦¼ ì¢…ë£Œ ì¸ë°”ë¦¬ì–¸íŠ¸ - ì„±ê³µ/ì‹¤íŒ¨ ëª¨ë‘ì—ì„œ onComplete í˜¸ì¶œ ë³´ì¥
    if (!aborted) {
      callbacks.onComplete?.();
    }
  }
}

/**
 * í´ë¼ì´ì–¸íŠ¸ ì¸¡ í´ë°± TurnOutput ìƒì„± (RU-002-S1).
 * ì„œë²„ì—ì„œ finalì´ ì˜¤ì§€ ëª»í•œ ê²½ìš° (ë„¤íŠ¸ì›Œí¬ ì—ëŸ¬ ë“±) ì‚¬ìš©í•©ë‹ˆë‹¤.
 * EconomyëŠ” ìš”ì²­ ì§ì „ ìŠ¤ëƒ…ìƒ·ì„ ê·¸ëŒ€ë¡œ ìœ ì§€í•©ë‹ˆë‹¤.
 */
function createClientFallbackTurnOutput(
  language: Language,
  economySnapshot: { signal: number; memory_shard: number },
): TurnOutput {
  const fallbackNarrative =
    language === 'ko-KR'
      ? '[ì‹œìŠ¤í…œ] ì„œë²„ ì—°ê²°ì— ì‹¤íŒ¨í–ˆìŠµë‹ˆë‹¤. ë‹¤ì‹œ ì‹œë„í•´ ì£¼ì„¸ìš”.'
      : '[System] Failed to connect to server. Please try again.';

  return {
    language,
    narrative: fallbackNarrative,
    economy: {
      cost: { signal: 0, memory_shard: 0 },
      // RU-002-S1: ì…ë ¥ ìŠ¤ëƒ…ìƒ· ê·¸ëŒ€ë¡œ ìœ ì§€ (ë¹„ìš© 0, ì”ì•¡ ë³€í™” ì—†ìŒ)
      balance_after: {
        signal: economySnapshot.signal,
        memory_shard: economySnapshot.memory_shard,
      },
    },
    safety: {
      blocked: false,
      message: null,
    },
    ui: {
      action_deck: { cards: [] },
      objects: [],
    },
    world: {
      rules_changed: [],
      inventory_added: [],
      inventory_removed: [],
      quests_updated: [],
      relationships_changed: [],
      memory_pins: [],
    },
    render: {
      image_job: null,
    },
    agent_console: {
      current_phase: 'commit',
      badges: ['schema_fail'],
      repair_count: 1,
    },
  };
}

/**
 * í„´ ìŠ¤íŠ¸ë¦¼ì„ ì‹œì‘í•˜ê³  ì·¨ì†Œ í•¨ìˆ˜ë¥¼ ë°˜í™˜í•©ë‹ˆë‹¤.
 *
 * @param input - í„´ ì…ë ¥ ë°ì´í„°
 * @param callbacks - ì´ë²¤íŠ¸ ì½œë°±
 * @returns ì·¨ì†Œ í•¨ìˆ˜
 */
export function startTurnStream(input: TurnInput, callbacks: StreamCallbacks): () => void {
  const controller = new AbortController();

  executeTurnStream(input, callbacks, { signal: controller.signal });

  return () => controller.abort();
}
</file>

<file path="frontend/src/App.tsx">
/**
 * Unknown World - ë©”ì¸ ê²Œì„ UI ë ˆì´ì•„ì›ƒ
 *
 * RULE-002 ì¤€ìˆ˜: ì±„íŒ… ë²„ë¸” UI ê¸ˆì§€
 * - ë‚´ëŸ¬í‹°ë¸ŒëŠ” "ì±„íŒ…"ì´ ì•„ë‹ˆë¼ "ê²Œì„ ë¡œê·¸/ë‚´ëŸ¬í‹°ë¸Œ í”¼ë“œ" í˜•íƒœ
 * - ê³ ì • íŒ¨ë„: Scene Canvas, Action Deck, Inventory, Quest,
 *   Rule Board, Economy HUD, Agent Console, Scanner Slot
 *
 * RULE-008: Agent Consoleì—ì„œ ë‹¨ê³„/ë°°ì§€/ë³µêµ¬ë§Œ í‘œì‹œ (í”„ë¡¬í”„íŠ¸ ë…¸ì¶œ ê¸ˆì§€)
 *
 * @see vibe/ref/frontend-style-guide.md
 * @see vibe/prd.md 6.7/6.8/9ì¥
 */

import { useState, useCallback, useRef, useEffect } from 'react';
import { useTranslation } from 'react-i18next';
import { AgentConsole } from './components/AgentConsole';
import { SceneCanvas, type HotspotClickData } from './components/SceneCanvas';
import { ActionDeck } from './components/ActionDeck';
import type { SceneCanvasState } from './types/scene';
import type { SceneObject } from './schemas/turn';
import { useAgentStore } from './stores/agentStore';
import { useActionDeckStore } from './stores/actionDeckStore';
import { useUIPrefsStore, applyUIPrefsToDOM, UI_SCALES, type UIScale } from './stores/uiPrefsStore';
import { startTurnStream, type StreamCallbacks } from './api/turnStream';
import type { TurnInput, TurnOutput, ActionCard } from './schemas/turn';
import { getResolvedLanguage } from './i18n';

// =============================================================================
// íƒ€ì… ì •ì˜
// =============================================================================

interface NarrativeEntry {
  turn: number;
  text: string;
}

// =============================================================================
// íŒ¨ë„ ì»´í¬ë„ŒíŠ¸
// =============================================================================

interface PanelProps {
  title: string;
  children?: React.ReactNode;
  className?: string;
  /** U-032: Chrome ì¥ì‹ ì ìš© ì—¬ë¶€ */
  hasChrome?: boolean;
  /** ê¸°ë³¸ placeholder i18n í‚¤ (childrenì´ ì—†ì„ ë•Œ ì‚¬ìš©) */
  placeholderKey?: string;
}

function Panel({ title, children, className = '', hasChrome = false, placeholderKey }: PanelProps) {
  const { t } = useTranslation();
  const panelClass = `panel ${className} ${hasChrome ? 'has-chrome' : ''}`.trim();
  const headerClass = `panel-header ${hasChrome ? 'has-chrome' : ''}`.trim();

  return (
    <div className={panelClass}>
      <div className={headerClass}>
        <span className="panel-title">{title}</span>
      </div>
      <div className="panel-content">
        {children || (
          <p className="panel-placeholder">
            {placeholderKey ? t(placeholderKey) : t('ui.panel_placeholder')}
          </p>
        )}
      </div>
    </div>
  );
}

// =============================================================================
// ë‚´ëŸ¬í‹°ë¸Œ í”¼ë“œ ì»´í¬ë„ŒíŠ¸
// =============================================================================

interface NarrativeFeedProps {
  entries: NarrativeEntry[];
  streamingText: string;
}

function NarrativeFeed({ entries, streamingText }: NarrativeFeedProps) {
  const { t } = useTranslation();
  const feedRef = useRef<HTMLDivElement>(null);

  // ìƒˆ ì—”íŠ¸ë¦¬ ì¶”ê°€ ì‹œ ìŠ¤í¬ë¡¤
  useEffect(() => {
    if (feedRef.current) {
      feedRef.current.scrollTop = feedRef.current.scrollHeight;
    }
  }, [entries, streamingText]);

  return (
    <div className="narrative-feed" ref={feedRef}>
      {entries.map((entry) => (
        <div key={entry.turn} className="narrative-entry">
          <span className="narrative-timestamp">
            {t('narrative.turn_label', { turn: entry.turn })}
          </span>
          <span className="narrative-text">{entry.text}</span>
        </div>
      ))}
      {streamingText && (
        <div className="narrative-entry streaming">
          <span className="narrative-timestamp">{t('narrative.streaming_label')}</span>
          <span className="narrative-text">{streamingText}</span>
          <span className="cursor-blink">â–Œ</span>
        </div>
      )}
    </div>
  );
}

// =============================================================================
// UI ì»¨íŠ¸ë¡¤ ì»´í¬ë„ŒíŠ¸ (U-028â†’U-037: Readable ëª¨ë“œ ì œê±°, ìŠ¤ì¼€ì¼ë§Œ ìœ ì§€)
// =============================================================================

interface UIControlsProps {
  uiScale: UIScale;
  onIncreaseScale: () => void;
  onDecreaseScale: () => void;
}

function UIControls({ uiScale, onIncreaseScale, onDecreaseScale }: UIControlsProps) {
  const { t } = useTranslation();
  const isMinScale = uiScale === UI_SCALES[0];
  const isMaxScale = uiScale === UI_SCALES[UI_SCALES.length - 1];

  return (
    <div className="ui-controls" role="group" aria-label={t('ui.scale_label')}>
      {/* UI ìŠ¤ì¼€ì¼ ì¡°ì ˆ */}
      <button
        type="button"
        className="ui-scale-btn"
        onClick={onDecreaseScale}
        disabled={isMinScale}
        aria-label={t('ui.scale_decrease')}
        title={`${t('ui.scale_decrease')} (A-)`}
      >
        A-
      </button>
      <span className="ui-scale-display" aria-live="polite">
        {Math.round(uiScale * 100)}%
      </span>
      <button
        type="button"
        className="ui-scale-btn"
        onClick={onIncreaseScale}
        disabled={isMaxScale}
        aria-label={t('ui.scale_increase')}
        title={`${t('ui.scale_increase')} (A+)`}
      >
        A+
      </button>
    </div>
  );
}

// =============================================================================
// í—¤ë” ì»´í¬ë„ŒíŠ¸
// =============================================================================

interface GameHeaderProps {
  signal: number;
  memoryShard: number;
  isConnected: boolean;
  uiScale: UIScale;
  onIncreaseScale: () => void;
  onDecreaseScale: () => void;
}

function GameHeader({
  signal,
  memoryShard,
  isConnected,
  uiScale,
  onIncreaseScale,
  onDecreaseScale,
}: GameHeaderProps) {
  const { t } = useTranslation();

  return (
    <header className="game-header has-chrome">
      <h1 className="game-title glitch" data-text={t('ui.logo')}>
        {t('ui.logo')}
      </h1>
      <div className="header-controls">
        {/* UI ìŠ¤ì¼€ì¼ ì»¨íŠ¸ë¡¤ (U-028â†’U-037: Readable ì œê±°) */}
        <UIControls
          uiScale={uiScale}
          onIncreaseScale={onIncreaseScale}
          onDecreaseScale={onDecreaseScale}
        />
        <div className="economy-hud">
          <span className="icon-wrapper signal-icon" aria-label={t('economy.signal')}>
            <img
              src="/ui/icons/signal-24.png"
              alt=""
              aria-hidden="true"
              className="icon-img"
              onError={(e) => {
                e.currentTarget.classList.add('hidden');
              }}
            />
            <span className="icon-fallback">âš¡</span>
          </span>
          <span className="currency-value">
            {t('economy.signal')}: {signal}
          </span>
          <span className="icon-wrapper shard-icon" aria-label={t('economy.shard')}>
            <img
              src="/ui/icons/shard-24.png"
              alt=""
              aria-hidden="true"
              className="icon-img"
              onError={(e) => {
                e.currentTarget.classList.add('hidden');
              }}
            />
            <span className="icon-fallback">ğŸ’</span>
          </span>
          <span className="currency-value">
            {t('economy.shard')}: {memoryShard}
          </span>
        </div>
        <div className="connection-status">
          <span className={`status-indicator ${isConnected ? '' : 'offline'}`} />
          <span>{isConnected ? t('connection.online') : t('connection.offline')}</span>
        </div>
      </div>
    </header>
  );
}

// =============================================================================
// ë©”ì¸ App ì»´í¬ë„ŒíŠ¸
// =============================================================================

function App() {
  const { t } = useTranslation();

  // ìƒíƒœ
  const [inputText, setInputText] = useState('');
  const turnCountRef = useRef(0);
  const [narrativeEntries, setNarrativeEntries] = useState<NarrativeEntry[]>(() => [
    { turn: 0, text: t('narrative.welcome') },
  ]);
  const [economy, setEconomy] = useState({ signal: 100, memory_shard: 5 });
  const [isConnected, setIsConnected] = useState(true);

  // Action Deck Store (U-009)
  const { cards: actionCards, setCards: setActionCards } = useActionDeckStore();

  // Scene Canvas ìƒíƒœ (U-031: Placeholder Pack)
  const [sceneState, setSceneState] = useState<SceneCanvasState>({
    status: 'default',
    message: t('scene.status.initial_sync'),
  });

  // Scene Objects ìƒíƒœ (U-010: í•«ìŠ¤íŒŸ ì˜¤ë²„ë ˆì´)
  // DEV: ë°ëª¨ìš© mock ì˜¤ë¸Œì íŠ¸ - ì‹¤ì œ ì„œë²„ ì—°ë™ ì‹œ ë¹ˆ ë°°ì—´ë¡œ ì‹œì‘
  const [sceneObjects, setSceneObjects] = useState<SceneObject[]>([
    {
      id: 'demo-terminal',
      label: 'í„°ë¯¸ë„',
      box_2d: { ymin: 300, xmin: 100, ymax: 600, xmax: 400 },
      interaction_hint: 'í™œì„±í™”ëœ í„°ë¯¸ë„ì´ë‹¤',
    },
    {
      id: 'demo-door',
      label: 'ë¬¸',
      box_2d: { ymin: 200, xmin: 600, ymax: 800, xmax: 900 },
      interaction_hint: 'ì ê²¨ìˆëŠ” ê²ƒ ê°™ë‹¤',
    },
  ]);

  // Agent Store ì•¡ì…˜
  const {
    startStream,
    handleStage,
    handleBadges,
    handleNarrativeDelta,
    handleFinal,
    handleError,
    completeStream,
    isStreaming,
    narrativeBuffer,
  } = useAgentStore();

  // UI Prefs Store (U-028â†’U-037: Readable ëª¨ë“œ ì œê±°)
  const { uiScale, increaseUIScale, decreaseUIScale } = useUIPrefsStore();

  // DOMì— UI ì„¤ì • ì ìš© (U-028â†’U-037)
  useEffect(() => {
    applyUIPrefsToDOM({ uiScale });
  }, [uiScale]);

  // ì·¨ì†Œ í•¨ìˆ˜ ref
  const cancelStreamRef = useRef<(() => void) | null>(null);

  /**
   * TurnOutputì„ ë°›ì•„ UI ìƒíƒœë¥¼ ì—…ë°ì´íŠ¸í•©ë‹ˆë‹¤.
   */
  const applyTurnOutput = useCallback(
    (output: TurnOutput) => {
      // ë‚´ëŸ¬í‹°ë¸Œ ì¶”ê°€
      turnCountRef.current += 1;
      const newTurn = turnCountRef.current;
      setNarrativeEntries((entries) => [...entries, { turn: newTurn, text: output.narrative }]);

      // ì•¡ì…˜ ì¹´ë“œ ì—…ë°ì´íŠ¸ (U-009: Action Deck Store ì‚¬ìš©)
      setActionCards(output.ui.action_deck.cards);

      // ê²½ì œ ìƒíƒœ ì—…ë°ì´íŠ¸ (RULE-005: ì”ì•¡ ë°˜ì˜)
      setEconomy({
        signal: output.economy.balance_after.signal,
        memory_shard: output.economy.balance_after.memory_shard,
      });

      // Scene Objects ì—…ë°ì´íŠ¸ (U-010: í•«ìŠ¤íŒŸ ì˜¤ë²„ë ˆì´)
      setSceneObjects(output.ui.objects);
    },
    [setActionCards],
  );

  /**
   * í„´ì„ ì‹¤í–‰í•©ë‹ˆë‹¤.
   *
   * U-010: click íŒŒë¼ë¯¸í„° ì¶”ê°€ (Q1 ê²°ì •: Option B - object_id + box_2d ì „ì†¡)
   */
  const executeTurn = useCallback(
    (text: string, actionId?: string, clickData?: HotspotClickData) => {
      if (isStreaming) return;

      // ì…ë ¥ ë°ì´í„° ìƒì„± (ì–¸ì–´ëŠ” i18n resolvedLanguageì™€ ë™ê¸°í™”)
      const turnInput: TurnInput = {
        language: getResolvedLanguage(),
        text: text || (actionId ? t('action.card_select', { cardId: actionId }) : ''),
        action_id: actionId ?? null,
        // U-010: í•«ìŠ¤íŒŸ í´ë¦­ ë°ì´í„° í¬í•¨ (Q1: Option B)
        click: clickData
          ? {
              object_id: clickData.object_id,
              box_2d: clickData.box_2d,
            }
          : null,
        client: {
          viewport_w: window.innerWidth,
          viewport_h: window.innerHeight,
          theme: 'dark',
        },
        economy_snapshot: economy,
      };

      // Agent Store ì‹œì‘
      startStream();

      // Scene Canvasë¥¼ ë¡œë”© ìƒíƒœë¡œ ì „í™˜ (U-031)
      setSceneState({ status: 'loading', message: t('scene.status.syncing') });

      // ìŠ¤íŠ¸ë¦¼ ì½œë°± ì„¤ì •
      const callbacks: StreamCallbacks = {
        onStage: handleStage,
        onBadges: handleBadges,
        onNarrativeDelta: handleNarrativeDelta,
        onFinal: (event) => {
          handleFinal(event);
          applyTurnOutput(event.data);
        },
        onError: (event) => {
          handleError(event);
          setIsConnected(false);
          // Scene Canvasë¥¼ ì˜¤í”„ë¼ì¸/ì—ëŸ¬ ìƒíƒœë¡œ ì „í™˜ (U-031)
          const errorCode = event.code;
          if (errorCode === 'SAFETY_BLOCKED') {
            setSceneState({ status: 'blocked', message: event.message });
          } else if (errorCode === 'INSUFFICIENT_BALANCE') {
            setSceneState({ status: 'low_signal', message: event.message });
          } else {
            setSceneState({ status: 'offline', message: event.message });
          }
        },
        onComplete: () => {
          completeStream();
          // Scene Canvasë¥¼ ê¸°ë³¸ ìƒíƒœë¡œ ë³µì› (U-031)
          // TODO: TurnOutputì— scene.imageUrlì´ ìˆìœ¼ë©´ scene ìƒíƒœë¡œ ì „í™˜
          setSceneState({ status: 'default', message: '' });
        },
      };

      // ìŠ¤íŠ¸ë¦¼ ì‹œì‘
      cancelStreamRef.current = startTurnStream(turnInput, callbacks);
      setInputText('');
    },
    [
      isStreaming,
      economy,
      startStream,
      handleStage,
      handleBadges,
      handleNarrativeDelta,
      handleFinal,
      handleError,
      completeStream,
      applyTurnOutput,
      t,
    ],
  );

  /**
   * ì…ë ¥ ì œì¶œ í•¸ë“¤ëŸ¬
   */
  const handleSubmit = useCallback(() => {
    if (inputText.trim()) {
      executeTurn(inputText.trim());
    }
  }, [inputText, executeTurn]);

  /**
   * ì¹´ë“œ í´ë¦­ í•¸ë“¤ëŸ¬
   */
  const handleCardClick = useCallback(
    (card: ActionCard) => {
      executeTurn(card.label, card.id);
    },
    [executeTurn],
  );

  /**
   * í•«ìŠ¤íŒŸ í´ë¦­ í•¸ë“¤ëŸ¬ (U-010)
   * í´ë¦­í•œ ì˜¤ë¸Œì íŠ¸ ì •ë³´ë¥¼ TurnInputì— í¬í•¨í•˜ì—¬ ì„œë²„ë¡œ ì „ì†¡í•©ë‹ˆë‹¤.
   */
  const handleHotspotClick = useCallback(
    (data: HotspotClickData) => {
      // í´ë¦­í•œ ì˜¤ë¸Œì íŠ¸ì˜ ë¼ë²¨ì„ ì°¾ì•„ í…ìŠ¤íŠ¸ë¡œ ì‚¬ìš©
      const clickedObject = sceneObjects.find((obj) => obj.id === data.object_id);
      const clickText = clickedObject
        ? t('scene.hotspot.click_action', { label: clickedObject.label })
        : data.object_id;

      executeTurn(clickText, undefined, data);
    },
    [executeTurn, sceneObjects, t],
  );

  /**
   * í‚¤ë³´ë“œ ì´ë²¤íŠ¸ í•¸ë“¤ëŸ¬
   */
  const handleKeyDown = useCallback(
    (e: React.KeyboardEvent) => {
      if (e.key === 'Enter' && !e.shiftKey) {
        e.preventDefault();
        handleSubmit();
      }
    },
    [handleSubmit],
  );

  // ì»´í¬ë„ŒíŠ¸ ì–¸ë§ˆìš´íŠ¸ ì‹œ ìŠ¤íŠ¸ë¦¼ ì·¨ì†Œ
  useEffect(() => {
    return () => {
      cancelStreamRef.current?.();
    };
  }, []);

  return (
    <>
      {/* CRT ìŠ¤ìº”ë¼ì¸ ì˜¤ë²„ë ˆì´ */}
      <div className="crt-overlay" aria-hidden="true" />

      {/* ê²Œì„ ë ˆì´ì•„ì›ƒ */}
      <div className="game-container">
        {/* Header: íƒ€ì´í‹€/ìƒíƒœ/ì¬í™”/UIì»¨íŠ¸ë¡¤ */}
        <GameHeader
          signal={economy.signal}
          memoryShard={economy.memory_shard}
          isConnected={isConnected}
          uiScale={uiScale}
          onIncreaseScale={increaseUIScale}
          onDecreaseScale={decreaseUIScale}
        />

        {/* Sidebar Left: Inventory / Quest / Rule Board */}
        <aside className="sidebar-left">
          <Panel
            title={t('panel.inventory.title')}
            className="flex-1"
            placeholderKey="panel.inventory.placeholder"
          />
          <Panel title={t('panel.quest.title')} placeholderKey="panel.quest.placeholder" />
          <Panel
            title={t('panel.rule_board.title')}
            placeholderKey="panel.rule_board.placeholder"
          />
        </aside>

        {/* Center: Scene Canvas + Narrative Feed */}
        <main className="game-center">
          <SceneCanvas
            state={sceneState}
            objects={sceneObjects}
            onHotspotClick={handleHotspotClick}
            disabled={isStreaming}
          />
          <NarrativeFeed entries={narrativeEntries} streamingText={narrativeBuffer} />
        </main>

        {/* Sidebar Right: Agent Console / Memory Pin / Scanner */}
        <aside className="sidebar-right">
          <Panel title={t('panel.agent_console.title')} className="flex-1" hasChrome>
            <AgentConsole />
          </Panel>
          <Panel
            title={t('panel.memory_pin.title')}
            hasChrome
            placeholderKey="panel.memory_pin.placeholder"
          />
          <Panel title={t('panel.scanner.title')} hasChrome>
            <div className="scanner-slot has-chrome">
              <p className="panel-placeholder">{t('panel.scanner.placeholder')}</p>
            </div>
          </Panel>
        </aside>

        {/* Footer: Action Deck + Command Input (U-009) */}
        <footer className="game-footer">
          <ActionDeck
            cards={actionCards}
            onCardClick={handleCardClick}
            disabled={isStreaming}
            currentBalance={economy}
          />
          <div className="command-input-area">
            <span className="command-prompt">&gt;</span>
            <input
              type="text"
              className="command-input"
              placeholder={isStreaming ? t('ui.processing') : t('ui.command_placeholder')}
              aria-label={t('ui.command_placeholder')}
              value={inputText}
              onChange={(e) => setInputText(e.target.value)}
              onKeyDown={handleKeyDown}
              disabled={isStreaming}
            />
            <button type="button" onClick={handleSubmit} disabled={isStreaming}>
              {isStreaming ? t('ui.wait') : t('ui.execute')}
            </button>
          </div>
        </footer>
      </div>
    </>
  );
}

export default App;
</file>

</files>
