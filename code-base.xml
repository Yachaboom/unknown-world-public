This file is a merged representation of a subset of the codebase, containing specifically included files and files not matching ignore patterns, combined into a single document by Repomix.

<file_summary>
This section contains a summary of this file.

<purpose>
This file contains a packed representation of a subset of the repository's contents that is considered the most important context.
It is designed to be easily consumable by AI systems for analysis, code review,
or other automated processes.
</purpose>

<file_format>
The content is organized as follows:
1. This summary section
2. Repository information
3. Directory structure
4. Repository files (if enabled)
5. Multiple file entries, each consisting of:
  - File path as an attribute
  - Full contents of the file
</file_format>

<usage_guidelines>
- This file should be treated as read-only. Any changes should be made to the
  original repository files, not this packed version.
- When processing this file, use the file path to distinguish
  between different files in the repository.
- Be aware that this file may contain sensitive information. Handle it with
  the same level of security as you would the original repository.
</usage_guidelines>

<notes>
- Some files may have been excluded based on .gitignore rules and Repomix's configuration
- Binary files are not included in this packed representation. Please refer to the Repository Structure section for a complete list of file paths, including binary files
- Only files matching these patterns are included: **/*.{ts,tsx,js,jsx,json,py,toml,yaml}
- Files matching these patterns are excluded: .claude/**, .cursor/**, .gemini/**, .vscode/**, vibe/**, node_modules/**, backend/.venv/**, frontend/dist/**
- Files matching patterns in .gitignore are excluded
- Files matching default ignore patterns are excluded
- Files are sorted by Git change count (files with more changes are at the bottom)
</notes>

</file_summary>

<directory_structure>
backend/pyproject.toml
backend/src/unknown_world/__init__.py
backend/src/unknown_world/api/__init__.py
backend/src/unknown_world/api/turn_stream_events.py
backend/src/unknown_world/api/turn.py
backend/src/unknown_world/main.py
backend/src/unknown_world/models/__init__.py
backend/src/unknown_world/models/turn.py
backend/src/unknown_world/orchestrator/__init__.py
backend/src/unknown_world/orchestrator/mock.py
backend/tests/integration/test_api.py
backend/tests/integration/test_turn_streaming.py
backend/tests/qa/test_asset_manifest.py
backend/tests/unit/models/test_turn.py
backend/tests/unit/test_u034_verification.py
frontend/coverage/block-navigation.js
frontend/coverage/coverage-final.json
frontend/coverage/prettify.js
frontend/coverage/sorter.js
frontend/package.json
frontend/public/ui/manifest.json
frontend/public/ui/manifest.schema.json
frontend/src/api/turnStream.test.ts
frontend/src/api/turnStream.ts
frontend/src/App.test.tsx
frontend/src/App.tsx
frontend/src/components/ActionDeck.test.tsx
frontend/src/components/ActionDeck.tsx
frontend/src/components/AgentConsole.test.tsx
frontend/src/components/AgentConsole.tsx
frontend/src/components/DndInteraction.test.tsx
frontend/src/components/EconomyHud.test.tsx
frontend/src/components/EconomyHud.tsx
frontend/src/components/GameHeader.tsx
frontend/src/components/InventoryPanel.test.tsx
frontend/src/components/InventoryPanel.tsx
frontend/src/components/MutationTimeline.test.tsx
frontend/src/components/MutationTimeline.tsx
frontend/src/components/NarrativeFeed.tsx
frontend/src/components/Panel.tsx
frontend/src/components/QuestPanel.test.tsx
frontend/src/components/QuestPanel.tsx
frontend/src/components/RuleBoard.test.tsx
frontend/src/components/RuleBoard.tsx
frontend/src/components/SceneCanvas.hotspot.test.tsx
frontend/src/components/SceneCanvas.test.tsx
frontend/src/components/SceneCanvas.tsx
frontend/src/components/UIControls.tsx
frontend/src/demo/demoFixtures.ts
frontend/src/demo/useDemoInitializer.ts
frontend/src/dnd/types.ts
frontend/src/i18n-scenario.test.ts
frontend/src/i18n.ts
frontend/src/locales/en-US/translation.json
frontend/src/locales/ko-KR/translation.json
frontend/src/main.tsx
frontend/src/schemas/index.ts
frontend/src/schemas/turn.test.ts
frontend/src/schemas/turn.ts
frontend/src/schemas/verify_runbook.ts
frontend/src/setupTests.ts
frontend/src/stores/actionDeckStore.test.ts
frontend/src/stores/actionDeckStore.ts
frontend/src/stores/agentStore.test.ts
frontend/src/stores/agentStore.ts
frontend/src/stores/economyStore.test.ts
frontend/src/stores/economyStore.ts
frontend/src/stores/inventoryStore.test.ts
frontend/src/stores/inventoryStore.ts
frontend/src/stores/uiPrefsStore.test.ts
frontend/src/stores/uiPrefsStore.ts
frontend/src/stores/worldStore.test.ts
frontend/src/stores/worldStore.ts
frontend/src/turn/turnRunner.ts
frontend/src/types/scene.ts
frontend/src/types/turn_stream.ts
frontend/src/utils/box2d.test.ts
frontend/src/utils/box2d.ts
frontend/src/vite-env.d.ts
frontend/tsconfig.json
frontend/tsconfig.node.json
frontend/vite.config.ts
package.json
shared/schemas/turn/turn_input.schema.json
shared/schemas/turn/turn_output.schema.json
</directory_structure>

<files>
This section contains the contents of the repository's files.

<file path="backend/src/unknown_world/api/__init__.py">
"""Unknown World - API 패키지.

이 패키지는 FastAPI 라우터들을 포함합니다.
"""

from unknown_world.api.turn import router as turn_router

__all__ = ["turn_router"]
</file>

<file path="backend/src/unknown_world/models/__init__.py">
"""Unknown World - 모델 패키지.

이 패키지는 TurnInput/TurnOutput 스키마 및 하위 타입을 정의합니다.
Gemini Structured Outputs(JSON Schema)용으로 설계되었습니다.

사용 예시:
    from unknown_world.models import TurnInput, TurnOutput

    # Pydantic → JSON Schema 변환 (Gemini response_json_schema용)
    schema = TurnOutput.model_json_schema()

    # 응답 검증
    output = TurnOutput.model_validate_json(response_text)

참조:
    - vibe/prd.md 8.7 (데이터 모델 설계)
    - vibe/ref/structured-outputs-guide.md
    - .cursor/rules/00-core-critical.mdc (RULE-003, RULE-005)
"""

from unknown_world.models.turn import (
    ActionCard,
    ActionDeck,
    AgentConsole,
    AgentPhase,
    Box2D,
    ClickInput,
    ClientInfo,
    Coordinate,
    CurrencyAmount,
    EconomyOutput,
    EconomySnapshot,
    ImageJob,
    Language,
    MemoryPin,
    ModelLabel,
    Quest,
    RenderOutput,
    RiskLevel,
    SafetyOutput,
    SceneObject,
    Theme,
    TurnInput,
    TurnOutput,
    UIOutput,
    ValidationBadge,
    WorldDelta,
    WorldRule,
)

__all__ = [
    # Enum 타입
    "Language",
    "Theme",
    "AgentPhase",
    "ValidationBadge",
    "ModelLabel",
    "RiskLevel",
    # 공통 하위 타입
    "Coordinate",
    "Box2D",
    "CurrencyAmount",
    # TurnInput 관련
    "TurnInput",
    "ClickInput",
    "ClientInfo",
    "EconomySnapshot",
    # TurnOutput 관련
    "TurnOutput",
    "UIOutput",
    "ActionDeck",
    "ActionCard",
    "SceneObject",
    "WorldDelta",
    "WorldRule",
    "Quest",
    "MemoryPin",
    "RenderOutput",
    "ImageJob",
    "EconomyOutput",
    "SafetyOutput",
    "AgentConsole",
]
</file>

<file path="backend/src/unknown_world/orchestrator/__init__.py">
"""Unknown World - Orchestrator 패키지.

이 패키지는 턴 처리 오케스트레이터를 포함합니다.
"""

from unknown_world.orchestrator.mock import MockOrchestrator

__all__ = ["MockOrchestrator"]
</file>

<file path="backend/tests/integration/test_api.py">
from fastapi.testclient import TestClient

from unknown_world.main import app

client = TestClient(app)


def test_health_check():
    """/health 엔드포인트가 올바른 스키마와 상태를 반환하는지 테스트합니다."""
    response = client.get("/health")
    assert response.status_code == 200
    data = response.json()
    assert data["status"] == "ok"
    assert "version" in data
    assert data["service"] == "unknown-world-backend"


def test_root_endpoint():
    """루트 엔드포인트가 정상 작동하는지 테스트합니다."""
    response = client.get("/")
    assert response.status_code == 200
    assert "message" in response.json()


def test_cors_policy():
    """RULE-011에 따른 CORS 정책이 올바르게 설정되었는지 테스트합니다."""
    # 허용된 오리진 테스트 (포트 8001)
    headers = {
        "Origin": "http://localhost:8001",
        "Access-Control-Request-Method": "GET",
    }
    response = client.options("/health", headers=headers)
    assert response.status_code == 200
    assert response.headers.get("access-control-allow-origin") == "http://localhost:8001"

    # 허용되지 않은 오리진 테스트 (포트 9000)
    headers = {
        "Origin": "http://localhost:9000",
        "Access-Control-Request-Method": "GET",
    }
    response = client.options("/health", headers=headers)
    # FastAPI/Starlette CORS 미들웨어는 허용되지 않은 경우 origin 헤더를 반환하지 않음
    assert "access-control-allow-origin" not in response.headers
</file>

<file path="backend/tests/qa/test_asset_manifest.py">
import json
import os

import pytest
from jsonschema import validate

# Paths
# This file is in backend/tests/qa/
# We go up 3 levels to get to backend root: backend/tests/qa -> backend/tests -> backend -> root (wait, backend is in root)
# Actually:
# __file__ = D:\Dev\unknown-world\backend\tests\qa\test_asset_manifest.py
# os.path.dirname(__file__) = D:\Dev\unknown-world\backend\tests\qa
# ... up 1 = tests
# ... up 2 = backend
# ... up 3 = unknown-world (project root)

CURRENT_DIR = os.path.dirname(os.path.abspath(__file__))
PROJECT_ROOT = os.path.dirname(os.path.dirname(os.path.dirname(CURRENT_DIR)))

# If PROJECT_ROOT is correct, it should contain frontend/
FRONTEND_UI_DIR = os.path.join(PROJECT_ROOT, "frontend", "public", "ui")
MANIFEST_PATH = os.path.join(FRONTEND_UI_DIR, "manifest.json")
SCHEMA_PATH = os.path.join(FRONTEND_UI_DIR, "manifest.schema.json")


def test_manifest_schema_validation():
    """Validates manifest.json against manifest.schema.json"""
    if not os.path.exists(MANIFEST_PATH):
        pytest.fail(f"Manifest not found at {MANIFEST_PATH}")
    if not os.path.exists(SCHEMA_PATH):
        pytest.fail(f"Schema not found at {SCHEMA_PATH}")

    with open(MANIFEST_PATH, encoding="utf-8") as f:
        manifest = json.load(f)

    with open(SCHEMA_PATH, encoding="utf-8") as f:
        schema = json.load(f)

    # validate raises ValidationError on failure
    validate(instance=manifest, schema=schema)


def test_asset_files_existence_and_size():
    """Checks if assets listed in manifest exist and sizes match/budget"""
    with open(MANIFEST_PATH, encoding="utf-8") as f:
        manifest = json.load(f)

    assets = manifest.get("assets", [])
    total_bytes_calculated = 0

    for asset in assets:
        rel_path = asset["path"]
        abs_path = os.path.join(FRONTEND_UI_DIR, rel_path)

        # 1. Existence Check
        assert os.path.exists(abs_path), f"Asset file missing: {rel_path} (full: {abs_path})"

        # 2. Size Check
        actual_size = os.path.getsize(abs_path)
        recorded_size = asset.get("bytes")

        # Note: If size mismatches, we print a helpful message.
        # In a real QA scenario, we might want to auto-update, but for this test we fail.
        if recorded_size is not None:
            assert actual_size == recorded_size, (
                f"Size mismatch for {rel_path}: actual {actual_size} != manifest {recorded_size}"
            )

        total_bytes_calculated += actual_size

        # 3. Individual Budget Check (from QA_CHECKLIST.md)
        asset_type = asset["type"]
        if asset_type == "icon":
            # 30KB limit
            assert actual_size <= 30 * 1024, (
                f"Icon {rel_path} exceeds 30KB budget ({actual_size} bytes)"
            )
        elif asset_type == "placeholder":
            # 300KB limit
            assert actual_size <= 300 * 1024, (
                f"Placeholder {rel_path} exceeds 300KB budget ({actual_size} bytes)"
            )
        elif asset_type == "chrome":
            # 120KB limit (increased for scanner-frame)
            assert actual_size <= 120 * 1024, (
                f"Chrome asset {rel_path} exceeds 120KB budget ({actual_size} bytes)"
            )

    # 4. Total Budget Check
    recorded_total = manifest.get("totalBytes")
    if recorded_total is not None:
        assert total_bytes_calculated == recorded_total, (
            f"Total bytes mismatch: calculated {total_bytes_calculated} != manifest {recorded_total}"
        )

    budget_total = manifest.get("budgetBytes", 1572864)
    assert total_bytes_calculated <= budget_total, (
        f"Total size {total_bytes_calculated} exceeds budget {budget_total}"
    )


def test_asset_naming_convention():
    """Checks if asset IDs and paths use kebab-case"""
    with open(MANIFEST_PATH, encoding="utf-8") as f:
        manifest = json.load(f)

    for asset in manifest["assets"]:
        asset_id = asset["id"]
        # Check for lowercase and kebab-case (allow numbers)
        assert asset_id.islower(), f"Asset ID {asset_id} should be lowercase"
        assert " " not in asset_id, f"Asset ID {asset_id} should not contain spaces"
        assert "_" not in asset_id, (
            f"Asset ID {asset_id} should not contain underscores (use kebab-case)"
        )
</file>

<file path="backend/tests/unit/models/test_turn.py">
"""TurnInput/TurnOutput 모델 단위 테스트."""

import pytest
from pydantic import ValidationError

from unknown_world.models.turn import (
    AgentConsole,
    Box2D,
    CurrencyAmount,
    EconomyOutput,
    Language,
    RenderOutput,
    TurnInput,
    TurnOutput,
    UIOutput,
    WorldDelta,
)

# =============================================================================
# Fixtures
# =============================================================================


@pytest.fixture
def valid_box_2d():
    return {"ymin": 100, "xmin": 200, "ymax": 300, "xmax": 400}


@pytest.fixture
def valid_currency_amount():
    return {"signal": 100, "memory_shard": 5}


@pytest.fixture
def valid_client_info():
    return {"viewport_w": 1920, "viewport_h": 1080, "theme": "dark"}


@pytest.fixture
def valid_turn_input_data(valid_client_info, valid_currency_amount):
    return {
        "language": "ko-KR",
        "text": "Hello",
        "client": valid_client_info,
        "economy_snapshot": valid_currency_amount,
    }


@pytest.fixture
def valid_turn_output_data(valid_currency_amount):
    return {
        "language": "ko-KR",
        "narrative": "Story continues...",
        "economy": {
            "cost": {"signal": 10, "memory_shard": 0},
            "balance_after": {"signal": 90, "memory_shard": 5},
        },
        "safety": {"blocked": False},
    }


# =============================================================================
# Coordinate & Box2D Tests
# =============================================================================


def test_box_2d_valid(valid_box_2d):
    box = Box2D(**valid_box_2d)
    assert box.ymin == 100
    assert box.xmax == 400


def test_box_2d_invalid_coordinate():
    with pytest.raises(ValidationError):
        # Out of range (ge=0, le=1000)
        Box2D(ymin=-1, xmin=0, ymax=1001, xmax=500)


def test_box_2d_extra_forbidden():
    with pytest.raises(ValidationError):
        Box2D(ymin=0, xmin=0, ymax=100, xmax=100, extra_field="not allowed")


# =============================================================================
# Currency & Economy Tests
# =============================================================================


def test_currency_amount_valid(valid_currency_amount):
    amount = CurrencyAmount(**valid_currency_amount)
    assert amount.signal == 100


def test_currency_amount_negative_fails():
    with pytest.raises(ValidationError):
        CurrencyAmount(signal=-1, memory_shard=0)


def test_economy_output_valid():
    data = {
        "cost": {"signal": 5, "memory_shard": 0},
        "balance_after": {"signal": 95, "memory_shard": 5},
    }
    economy = EconomyOutput(**data)
    assert economy.cost.signal == 5
    assert economy.balance_after.signal == 95


# =============================================================================
# TurnInput Tests
# =============================================================================


def test_turn_input_valid(valid_turn_input_data):
    turn_input = TurnInput(**valid_turn_input_data)
    assert turn_input.language == Language.KO
    assert turn_input.text == "Hello"


def test_turn_input_with_click(valid_turn_input_data, valid_box_2d):
    data = valid_turn_input_data.copy()
    data["click"] = {"object_id": "door_01", "box_2d": valid_box_2d}
    turn_input = TurnInput(**data)
    assert turn_input.click.object_id == "door_01"
    assert turn_input.click.box_2d.ymin == 100


def test_turn_input_invalid_language():
    with pytest.raises(ValidationError):
        TurnInput(
            language="fr-FR",  # Not in Language enum
            text="...",
            client={"viewport_w": 800, "viewport_h": 600},
            economy_snapshot={"signal": 0, "memory_shard": 0},
        )


# =============================================================================
# TurnOutput Tests
# =============================================================================


def test_turn_output_valid_minimal(valid_turn_output_data):
    turn_output = TurnOutput(**valid_turn_output_data)
    assert turn_output.language == Language.KO
    assert turn_output.narrative == "Story continues..."
    # Check defaults
    assert isinstance(turn_output.ui, UIOutput)
    assert isinstance(turn_output.world, WorldDelta)
    assert isinstance(turn_output.render, RenderOutput)
    assert isinstance(turn_output.agent_console, AgentConsole)


def test_turn_output_full(valid_currency_amount, valid_box_2d):
    data = {
        "language": "en-US",
        "narrative": "Narrative text",
        "ui": {
            "action_deck": {
                "cards": [
                    {
                        "id": "c1",
                        "label": "Action 1",
                        "cost": {"signal": 5, "memory_shard": 0},
                    }
                ]
            },
            "objects": [{"id": "obj1", "label": "Object 1", "box_2d": valid_box_2d}],
        },
        "world": {
            "inventory_added": ["key"],
            "rules_changed": [{"id": "r1", "label": "Gravity", "description": "Low gravity"}],
            "quests_updated": [{"id": "q1", "label": "Find key", "is_completed": False}],
            "memory_pins": [
                {"id": "p1", "content": "Fact", "cost": {"signal": 1, "memory_shard": 0}}
            ],
        },
        "render": {
            "image_job": {
                "should_generate": True,
                "prompt": "A landscape",
                "model_label": "QUALITY",
            }
        },
        "economy": {
            "cost": {"signal": 10, "memory_shard": 0},
            "balance_after": {"signal": 90, "memory_shard": 5},
        },
        "safety": {"blocked": False},
        "agent_console": {"repair_count": 1, "badges": ["schema_ok", "economy_ok"]},
    }
    turn_output = TurnOutput(**data)
    assert turn_output.language == Language.EN
    assert len(turn_output.ui.action_deck.cards) == 1
    assert turn_output.render.image_job.should_generate is True


def test_turn_output_missing_required():
    with pytest.raises(ValidationError):
        # Missing economy and safety
        TurnOutput(language="ko-KR", narrative="...")


# =============================================================================
# JSON Schema Tests
# =============================================================================


def test_turn_output_json_schema():
    schema = TurnOutput.model_json_schema()
    assert schema["type"] == "object"
    assert "language" in schema["required"]
    assert "narrative" in schema["required"]
    assert "economy" in schema["required"]
    assert "safety" in schema["required"]

    # Check Coordinate constraints in schema
    # Pydantic 2 schema structure: properties -> language -> ...
    # Coordinate might be in $defs or inline depending on how it's used
    ui_props = schema["$defs"]["UIOutput"]["properties"]
    assert "action_deck" in ui_props

    # Verify that Coordinate (int with ge/le) is correctly represented
    # Box2D uses Coordinate
    box_props = schema["$defs"]["Box2D"]["properties"]
    assert box_props["ymin"]["maximum"] == 1000
    assert box_props["ymin"]["minimum"] == 0
</file>

<file path="frontend/coverage/block-navigation.js">
/* eslint-disable */
var jumpToCode = (function init() {
    // Classes of code we would like to highlight in the file view
    var missingCoverageClasses = ['.cbranch-no', '.cstat-no', '.fstat-no'];

    // Elements to highlight in the file listing view
    var fileListingElements = ['td.pct.low'];

    // We don't want to select elements that are direct descendants of another match
    var notSelector = ':not(' + missingCoverageClasses.join('):not(') + ') > '; // becomes `:not(a):not(b) > `

    // Selector that finds elements on the page to which we can jump
    var selector =
        fileListingElements.join(', ') +
        ', ' +
        notSelector +
        missingCoverageClasses.join(', ' + notSelector); // becomes `:not(a):not(b) > a, :not(a):not(b) > b`

    // The NodeList of matching elements
    var missingCoverageElements = document.querySelectorAll(selector);

    var currentIndex;

    function toggleClass(index) {
        missingCoverageElements
            .item(currentIndex)
            .classList.remove('highlighted');
        missingCoverageElements.item(index).classList.add('highlighted');
    }

    function makeCurrent(index) {
        toggleClass(index);
        currentIndex = index;
        missingCoverageElements.item(index).scrollIntoView({
            behavior: 'smooth',
            block: 'center',
            inline: 'center'
        });
    }

    function goToPrevious() {
        var nextIndex = 0;
        if (typeof currentIndex !== 'number' || currentIndex === 0) {
            nextIndex = missingCoverageElements.length - 1;
        } else if (missingCoverageElements.length > 1) {
            nextIndex = currentIndex - 1;
        }

        makeCurrent(nextIndex);
    }

    function goToNext() {
        var nextIndex = 0;

        if (
            typeof currentIndex === 'number' &&
            currentIndex < missingCoverageElements.length - 1
        ) {
            nextIndex = currentIndex + 1;
        }

        makeCurrent(nextIndex);
    }

    return function jump(event) {
        if (
            document.getElementById('fileSearch') === document.activeElement &&
            document.activeElement != null
        ) {
            // if we're currently focused on the search input, we don't want to navigate
            return;
        }

        switch (event.which) {
            case 78: // n
            case 74: // j
                goToNext();
                break;
            case 66: // b
            case 75: // k
            case 80: // p
                goToPrevious();
                break;
        }
    };
})();
window.addEventListener('keydown', jumpToCode);
</file>

<file path="frontend/coverage/coverage-final.json">
{"D:\\Dev\\unknown-world\\frontend\\src\\schemas\\turn.ts": {"path":"D:\\Dev\\unknown-world\\frontend\\src\\schemas\\turn.ts","statementMap":{"0":{"start":{"line":30,"column":30},"end":{"line":30,"column":null}},"1":{"start":{"line":41,"column":30},"end":{"line":41,"column":null}},"2":{"start":{"line":47,"column":27},"end":{"line":47,"column":null}},"3":{"start":{"line":54,"column":32},"end":{"line":62,"column":null}},"4":{"start":{"line":69,"column":37},"end":{"line":78,"column":null}},"5":{"start":{"line":85,"column":32},"end":{"line":85,"column":null}},"6":{"start":{"line":91,"column":31},"end":{"line":91,"column":null}},"7":{"start":{"line":102,"column":32},"end":{"line":107,"column":null}},"8":{"start":{"line":115,"column":27},"end":{"line":122,"column":null}},"9":{"start":{"line":129,"column":36},"end":{"line":138,"column":null}},"10":{"start":{"line":149,"column":32},"end":{"line":156,"column":null}},"11":{"start":{"line":162,"column":32},"end":{"line":176,"column":null}},"12":{"start":{"line":183,"column":37},"end":{"line":192,"column":null}},"13":{"start":{"line":199,"column":31},"end":{"line":209,"column":null}},"14":{"start":{"line":220,"column":32},"end":{"line":229,"column":null}},"15":{"start":{"line":236,"column":33},"end":{"line":247,"column":null}},"16":{"start":{"line":254,"column":32},"end":{"line":262,"column":null}},"17":{"start":{"line":270,"column":30},"end":{"line":278,"column":null}},"18":{"start":{"line":289,"column":31},"end":{"line":295,"column":null}},"19":{"start":{"line":302,"column":31},"end":{"line":312,"column":null}},"20":{"start":{"line":319,"column":27},"end":{"line":325,"column":null}},"21":{"start":{"line":332,"column":32},"end":{"line":359,"column":null}},"22":{"start":{"line":370,"column":30},"end":{"line":382,"column":null}},"23":{"start":{"line":389,"column":34},"end":{"line":395,"column":null}},"24":{"start":{"line":407,"column":35},"end":{"line":412,"column":null}},"25":{"start":{"line":424,"column":34},"end":{"line":436,"column":null}},"26":{"start":{"line":447,"column":34},"end":{"line":453,"column":null}},"27":{"start":{"line":469,"column":32},"end":{"line":502,"column":null}},"28":{"start":{"line":523,"column":4},"end":{"line":525,"column":null}},"29":{"start":{"line":528,"column":4},"end":{"line":530,"column":null}},"30":{"start":{"line":532,"column":2},"end":{"line":563,"column":null}},"31":{"start":{"line":590,"column":17},"end":{"line":590,"column":null}},"32":{"start":{"line":592,"column":2},"end":{"line":594,"column":null}},"33":{"start":{"line":593,"column":4},"end":{"line":593,"column":null}},"34":{"start":{"line":596,"column":2},"end":{"line":600,"column":null}},"35":{"start":{"line":611,"column":2},"end":{"line":611,"column":null}},"36":{"start":{"line":625,"column":2},"end":{"line":625,"column":null}}},"fnMap":{"0":{"name":"createFallbackTurnOutput","decl":{"start":{"line":517,"column":16},"end":{"line":517,"column":null}},"loc":{"start":{"line":521,"column":14},"end":{"line":564,"column":null}},"line":521},"1":{"name":"safeParseTurnOutput","decl":{"start":{"line":585,"column":16},"end":{"line":585,"column":null}},"loc":{"start":{"line":589,"column":25},"end":{"line":601,"column":null}},"line":589},"2":{"name":"parseTurnInput","decl":{"start":{"line":610,"column":16},"end":{"line":610,"column":31}},"loc":{"start":{"line":610,"column":57},"end":{"line":612,"column":null}},"line":610},"3":{"name":"safeParseTurnInput","decl":{"start":{"line":624,"column":16},"end":{"line":624,"column":35}},"loc":{"start":{"line":624,"column":76},"end":{"line":626,"column":null}},"line":624}},"branchMap":{"0":{"loc":{"start":{"line":519,"column":2},"end":{"line":519,"column":null}},"type":"default-arg","locations":[{"start":{"line":519,"column":24},"end":{"line":519,"column":null}}],"line":519},"1":{"loc":{"start":{"line":523,"column":4},"end":{"line":525,"column":null}},"type":"cond-expr","locations":[{"start":{"line":524,"column":8},"end":{"line":524,"column":null}},{"start":{"line":525,"column":8},"end":{"line":525,"column":null}}],"line":523},"2":{"loc":{"start":{"line":528,"column":4},"end":{"line":530,"column":null}},"type":"cond-expr","locations":[{"start":{"line":529,"column":8},"end":{"line":529,"column":null}},{"start":{"line":530,"column":8},"end":{"line":530,"column":null}}],"line":528},"3":{"loc":{"start":{"line":534,"column":15},"end":{"line":534,"column":null}},"type":"binary-expr","locations":[{"start":{"line":534,"column":15},"end":{"line":534,"column":31}},{"start":{"line":534,"column":31},"end":{"line":534,"column":null}}],"line":534},"4":{"loc":{"start":{"line":587,"column":2},"end":{"line":587,"column":null}},"type":"default-arg","locations":[{"start":{"line":587,"column":23},"end":{"line":587,"column":null}}],"line":587},"5":{"loc":{"start":{"line":588,"column":2},"end":{"line":588,"column":null}},"type":"default-arg","locations":[{"start":{"line":588,"column":24},"end":{"line":588,"column":null}}],"line":588},"6":{"loc":{"start":{"line":592,"column":2},"end":{"line":594,"column":null}},"type":"if","locations":[{"start":{"line":592,"column":2},"end":{"line":594,"column":null}},{"start":{},"end":{}}],"line":592}},"s":{"0":1,"1":1,"2":1,"3":1,"4":1,"5":1,"6":1,"7":1,"8":1,"9":1,"10":1,"11":1,"12":1,"13":1,"14":1,"15":1,"16":1,"17":1,"18":1,"19":1,"20":1,"21":1,"22":1,"23":1,"24":1,"25":1,"26":1,"27":1,"28":1,"29":1,"30":1,"31":2,"32":2,"33":1,"34":1,"35":2,"36":2},"f":{"0":1,"1":2,"2":2,"3":2},"b":{"0":[1],"1":[1,0],"2":[1,0],"3":[1,1],"4":[2],"5":[2],"6":[1,1]},"meta":{"lastBranch":7,"lastFunction":4,"lastStatement":37,"seen":{"s:30:30:30:Infinity":0,"s:41:30:41:Infinity":1,"s:47:27:47:Infinity":2,"s:54:32:62:Infinity":3,"s:69:37:78:Infinity":4,"s:85:32:85:Infinity":5,"s:91:31:91:Infinity":6,"s:102:32:107:Infinity":7,"s:115:27:122:Infinity":8,"s:129:36:138:Infinity":9,"s:149:32:156:Infinity":10,"s:162:32:176:Infinity":11,"s:183:37:192:Infinity":12,"s:199:31:209:Infinity":13,"s:220:32:229:Infinity":14,"s:236:33:247:Infinity":15,"s:254:32:262:Infinity":16,"s:270:30:278:Infinity":17,"s:289:31:295:Infinity":18,"s:302:31:312:Infinity":19,"s:319:27:325:Infinity":20,"s:332:32:359:Infinity":21,"s:370:30:382:Infinity":22,"s:389:34:395:Infinity":23,"s:407:35:412:Infinity":24,"s:424:34:436:Infinity":25,"s:447:34:453:Infinity":26,"s:469:32:502:Infinity":27,"f:517:16:517:Infinity":0,"b:519:24:519:Infinity":0,"s:523:4:525:Infinity":28,"b:524:8:524:Infinity:525:8:525:Infinity":1,"s:528:4:530:Infinity":29,"b:529:8:529:Infinity:530:8:530:Infinity":2,"s:532:2:563:Infinity":30,"b:534:15:534:31:534:31:534:Infinity":3,"f:585:16:585:Infinity":1,"b:587:23:587:Infinity":4,"b:588:24:588:Infinity":5,"s:590:17:590:Infinity":31,"b:592:2:594:Infinity:undefined:undefined:undefined:undefined":6,"s:592:2:594:Infinity":32,"s:593:4:593:Infinity":33,"s:596:2:600:Infinity":34,"f:610:16:610:31":2,"s:611:2:611:Infinity":35,"f:624:16:624:35":3,"s:625:2:625:Infinity":36}}}
}
</file>

<file path="frontend/coverage/prettify.js">
/* eslint-disable */
window.PR_SHOULD_USE_CONTINUATION=true;(function(){var h=["break,continue,do,else,for,if,return,while"];var u=[h,"auto,case,char,const,default,double,enum,extern,float,goto,int,long,register,short,signed,sizeof,static,struct,switch,typedef,union,unsigned,void,volatile"];var p=[u,"catch,class,delete,false,import,new,operator,private,protected,public,this,throw,true,try,typeof"];var l=[p,"alignof,align_union,asm,axiom,bool,concept,concept_map,const_cast,constexpr,decltype,dynamic_cast,explicit,export,friend,inline,late_check,mutable,namespace,nullptr,reinterpret_cast,static_assert,static_cast,template,typeid,typename,using,virtual,where"];var x=[p,"abstract,boolean,byte,extends,final,finally,implements,import,instanceof,null,native,package,strictfp,super,synchronized,throws,transient"];var R=[x,"as,base,by,checked,decimal,delegate,descending,dynamic,event,fixed,foreach,from,group,implicit,in,interface,internal,into,is,lock,object,out,override,orderby,params,partial,readonly,ref,sbyte,sealed,stackalloc,string,select,uint,ulong,unchecked,unsafe,ushort,var"];var r="all,and,by,catch,class,else,extends,false,finally,for,if,in,is,isnt,loop,new,no,not,null,of,off,on,or,return,super,then,true,try,unless,until,when,while,yes";var w=[p,"debugger,eval,export,function,get,null,set,undefined,var,with,Infinity,NaN"];var s="caller,delete,die,do,dump,elsif,eval,exit,foreach,for,goto,if,import,last,local,my,next,no,our,print,package,redo,require,sub,undef,unless,until,use,wantarray,while,BEGIN,END";var I=[h,"and,as,assert,class,def,del,elif,except,exec,finally,from,global,import,in,is,lambda,nonlocal,not,or,pass,print,raise,try,with,yield,False,True,None"];var f=[h,"alias,and,begin,case,class,def,defined,elsif,end,ensure,false,in,module,next,nil,not,or,redo,rescue,retry,self,super,then,true,undef,unless,until,when,yield,BEGIN,END"];var H=[h,"case,done,elif,esac,eval,fi,function,in,local,set,then,until"];var A=[l,R,w,s+I,f,H];var e=/^(DIR|FILE|vector|(de|priority_)?queue|list|stack|(const_)?iterator|(multi)?(set|map)|bitset|u?(int|float)\d*)/;var C="str";var z="kwd";var j="com";var O="typ";var G="lit";var L="pun";var F="pln";var m="tag";var E="dec";var J="src";var P="atn";var n="atv";var N="nocode";var M="(?:^^\\.?|[+-]|\\!|\\!=|\\!==|\\#|\\%|\\%=|&|&&|&&=|&=|\\(|\\*|\\*=|\\+=|\\,|\\-=|\\->|\\/|\\/=|:|::|\\;|<|<<|<<=|<=|=|==|===|>|>=|>>|>>=|>>>|>>>=|\\?|\\@|\\[|\\^|\\^=|\\^\\^|\\^\\^=|\\{|\\||\\|=|\\|\\||\\|\\|=|\\~|break|case|continue|delete|do|else|finally|instanceof|return|throw|try|typeof)\\s*";function k(Z){var ad=0;var S=false;var ac=false;for(var V=0,U=Z.length;V<U;++V){var ae=Z[V];if(ae.ignoreCase){ac=true}else{if(/[a-z]/i.test(ae.source.replace(/\\u[0-9a-f]{4}|\\x[0-9a-f]{2}|\\[^ux]/gi,""))){S=true;ac=false;break}}}var Y={b:8,t:9,n:10,v:11,f:12,r:13};function ab(ah){var ag=ah.charCodeAt(0);if(ag!==92){return ag}var af=ah.charAt(1);ag=Y[af];if(ag){return ag}else{if("0"<=af&&af<="7"){return parseInt(ah.substring(1),8)}else{if(af==="u"||af==="x"){return parseInt(ah.substring(2),16)}else{return ah.charCodeAt(1)}}}}function T(af){if(af<32){return(af<16?"\\x0":"\\x")+af.toString(16)}var ag=String.fromCharCode(af);if(ag==="\\"||ag==="-"||ag==="["||ag==="]"){ag="\\"+ag}return ag}function X(am){var aq=am.substring(1,am.length-1).match(new RegExp("\\\\u[0-9A-Fa-f]{4}|\\\\x[0-9A-Fa-f]{2}|\\\\[0-3][0-7]{0,2}|\\\\[0-7]{1,2}|\\\\[\\s\\S]|-|[^-\\\\]","g"));var ak=[];var af=[];var ao=aq[0]==="^";for(var ar=ao?1:0,aj=aq.length;ar<aj;++ar){var ah=aq[ar];if(/\\[bdsw]/i.test(ah)){ak.push(ah)}else{var ag=ab(ah);var al;if(ar+2<aj&&"-"===aq[ar+1]){al=ab(aq[ar+2]);ar+=2}else{al=ag}af.push([ag,al]);if(!(al<65||ag>122)){if(!(al<65||ag>90)){af.push([Math.max(65,ag)|32,Math.min(al,90)|32])}if(!(al<97||ag>122)){af.push([Math.max(97,ag)&~32,Math.min(al,122)&~32])}}}}af.sort(function(av,au){return(av[0]-au[0])||(au[1]-av[1])});var ai=[];var ap=[NaN,NaN];for(var ar=0;ar<af.length;++ar){var at=af[ar];if(at[0]<=ap[1]+1){ap[1]=Math.max(ap[1],at[1])}else{ai.push(ap=at)}}var an=["["];if(ao){an.push("^")}an.push.apply(an,ak);for(var ar=0;ar<ai.length;++ar){var at=ai[ar];an.push(T(at[0]));if(at[1]>at[0]){if(at[1]+1>at[0]){an.push("-")}an.push(T(at[1]))}}an.push("]");return an.join("")}function W(al){var aj=al.source.match(new RegExp("(?:\\[(?:[^\\x5C\\x5D]|\\\\[\\s\\S])*\\]|\\\\u[A-Fa-f0-9]{4}|\\\\x[A-Fa-f0-9]{2}|\\\\[0-9]+|\\\\[^ux0-9]|\\(\\?[:!=]|[\\(\\)\\^]|[^\\x5B\\x5C\\(\\)\\^]+)","g"));var ah=aj.length;var an=[];for(var ak=0,am=0;ak<ah;++ak){var ag=aj[ak];if(ag==="("){++am}else{if("\\"===ag.charAt(0)){var af=+ag.substring(1);if(af&&af<=am){an[af]=-1}}}}for(var ak=1;ak<an.length;++ak){if(-1===an[ak]){an[ak]=++ad}}for(var ak=0,am=0;ak<ah;++ak){var ag=aj[ak];if(ag==="("){++am;if(an[am]===undefined){aj[ak]="(?:"}}else{if("\\"===ag.charAt(0)){var af=+ag.substring(1);if(af&&af<=am){aj[ak]="\\"+an[am]}}}}for(var ak=0,am=0;ak<ah;++ak){if("^"===aj[ak]&&"^"!==aj[ak+1]){aj[ak]=""}}if(al.ignoreCase&&S){for(var ak=0;ak<ah;++ak){var ag=aj[ak];var ai=ag.charAt(0);if(ag.length>=2&&ai==="["){aj[ak]=X(ag)}else{if(ai!=="\\"){aj[ak]=ag.replace(/[a-zA-Z]/g,function(ao){var ap=ao.charCodeAt(0);return"["+String.fromCharCode(ap&~32,ap|32)+"]"})}}}}return aj.join("")}var aa=[];for(var V=0,U=Z.length;V<U;++V){var ae=Z[V];if(ae.global||ae.multiline){throw new Error(""+ae)}aa.push("(?:"+W(ae)+")")}return new RegExp(aa.join("|"),ac?"gi":"g")}function a(V){var U=/(?:^|\s)nocode(?:\s|$)/;var X=[];var T=0;var Z=[];var W=0;var S;if(V.currentStyle){S=V.currentStyle.whiteSpace}else{if(window.getComputedStyle){S=document.defaultView.getComputedStyle(V,null).getPropertyValue("white-space")}}var Y=S&&"pre"===S.substring(0,3);function aa(ab){switch(ab.nodeType){case 1:if(U.test(ab.className)){return}for(var ae=ab.firstChild;ae;ae=ae.nextSibling){aa(ae)}var ad=ab.nodeName;if("BR"===ad||"LI"===ad){X[W]="\n";Z[W<<1]=T++;Z[(W++<<1)|1]=ab}break;case 3:case 4:var ac=ab.nodeValue;if(ac.length){if(!Y){ac=ac.replace(/[ \t\r\n]+/g," ")}else{ac=ac.replace(/\r\n?/g,"\n")}X[W]=ac;Z[W<<1]=T;T+=ac.length;Z[(W++<<1)|1]=ab}break}}aa(V);return{sourceCode:X.join("").replace(/\n$/,""),spans:Z}}function B(S,U,W,T){if(!U){return}var V={sourceCode:U,basePos:S};W(V);T.push.apply(T,V.decorations)}var v=/\S/;function o(S){var V=undefined;for(var U=S.firstChild;U;U=U.nextSibling){var T=U.nodeType;V=(T===1)?(V?S:U):(T===3)?(v.test(U.nodeValue)?S:V):V}return V===S?undefined:V}function g(U,T){var S={};var V;(function(){var ad=U.concat(T);var ah=[];var ag={};for(var ab=0,Z=ad.length;ab<Z;++ab){var Y=ad[ab];var ac=Y[3];if(ac){for(var ae=ac.length;--ae>=0;){S[ac.charAt(ae)]=Y}}var af=Y[1];var aa=""+af;if(!ag.hasOwnProperty(aa)){ah.push(af);ag[aa]=null}}ah.push(/[\0-\uffff]/);V=k(ah)})();var X=T.length;var W=function(ah){var Z=ah.sourceCode,Y=ah.basePos;var ad=[Y,F];var af=0;var an=Z.match(V)||[];var aj={};for(var ae=0,aq=an.length;ae<aq;++ae){var ag=an[ae];var ap=aj[ag];var ai=void 0;var am;if(typeof ap==="string"){am=false}else{var aa=S[ag.charAt(0)];if(aa){ai=ag.match(aa[1]);ap=aa[0]}else{for(var ao=0;ao<X;++ao){aa=T[ao];ai=ag.match(aa[1]);if(ai){ap=aa[0];break}}if(!ai){ap=F}}am=ap.length>=5&&"lang-"===ap.substring(0,5);if(am&&!(ai&&typeof ai[1]==="string")){am=false;ap=J}if(!am){aj[ag]=ap}}var ab=af;af+=ag.length;if(!am){ad.push(Y+ab,ap)}else{var al=ai[1];var ak=ag.indexOf(al);var ac=ak+al.length;if(ai[2]){ac=ag.length-ai[2].length;ak=ac-al.length}var ar=ap.substring(5);B(Y+ab,ag.substring(0,ak),W,ad);B(Y+ab+ak,al,q(ar,al),ad);B(Y+ab+ac,ag.substring(ac),W,ad)}}ah.decorations=ad};return W}function i(T){var W=[],S=[];if(T.tripleQuotedStrings){W.push([C,/^(?:\'\'\'(?:[^\'\\]|\\[\s\S]|\'{1,2}(?=[^\']))*(?:\'\'\'|$)|\"\"\"(?:[^\"\\]|\\[\s\S]|\"{1,2}(?=[^\"]))*(?:\"\"\"|$)|\'(?:[^\\\']|\\[\s\S])*(?:\'|$)|\"(?:[^\\\"]|\\[\s\S])*(?:\"|$))/,null,"'\""])}else{if(T.multiLineStrings){W.push([C,/^(?:\'(?:[^\\\']|\\[\s\S])*(?:\'|$)|\"(?:[^\\\"]|\\[\s\S])*(?:\"|$)|\`(?:[^\\\`]|\\[\s\S])*(?:\`|$))/,null,"'\"`"])}else{W.push([C,/^(?:\'(?:[^\\\'\r\n]|\\.)*(?:\'|$)|\"(?:[^\\\"\r\n]|\\.)*(?:\"|$))/,null,"\"'"])}}if(T.verbatimStrings){S.push([C,/^@\"(?:[^\"]|\"\")*(?:\"|$)/,null])}var Y=T.hashComments;if(Y){if(T.cStyleComments){if(Y>1){W.push([j,/^#(?:##(?:[^#]|#(?!##))*(?:###|$)|.*)/,null,"#"])}else{W.push([j,/^#(?:(?:define|elif|else|endif|error|ifdef|include|ifndef|line|pragma|undef|warning)\b|[^\r\n]*)/,null,"#"])}S.push([C,/^<(?:(?:(?:\.\.\/)*|\/?)(?:[\w-]+(?:\/[\w-]+)+)?[\w-]+\.h|[a-z]\w*)>/,null])}else{W.push([j,/^#[^\r\n]*/,null,"#"])}}if(T.cStyleComments){S.push([j,/^\/\/[^\r\n]*/,null]);S.push([j,/^\/\*[\s\S]*?(?:\*\/|$)/,null])}if(T.regexLiterals){var X=("/(?=[^/*])(?:[^/\\x5B\\x5C]|\\x5C[\\s\\S]|\\x5B(?:[^\\x5C\\x5D]|\\x5C[\\s\\S])*(?:\\x5D|$))+/");S.push(["lang-regex",new RegExp("^"+M+"("+X+")")])}var V=T.types;if(V){S.push([O,V])}var U=(""+T.keywords).replace(/^ | $/g,"");if(U.length){S.push([z,new RegExp("^(?:"+U.replace(/[\s,]+/g,"|")+")\\b"),null])}W.push([F,/^\s+/,null," \r\n\t\xA0"]);S.push([G,/^@[a-z_$][a-z_$@0-9]*/i,null],[O,/^(?:[@_]?[A-Z]+[a-z][A-Za-z_$@0-9]*|\w+_t\b)/,null],[F,/^[a-z_$][a-z_$@0-9]*/i,null],[G,new RegExp("^(?:0x[a-f0-9]+|(?:\\d(?:_\\d+)*\\d*(?:\\.\\d*)?|\\.\\d\\+)(?:e[+\\-]?\\d+)?)[a-z]*","i"),null,"0123456789"],[F,/^\\[\s\S]?/,null],[L,/^.[^\s\w\.$@\'\"\`\/\#\\]*/,null]);return g(W,S)}var K=i({keywords:A,hashComments:true,cStyleComments:true,multiLineStrings:true,regexLiterals:true});function Q(V,ag){var U=/(?:^|\s)nocode(?:\s|$)/;var ab=/\r\n?|\n/;var ac=V.ownerDocument;var S;if(V.currentStyle){S=V.currentStyle.whiteSpace}else{if(window.getComputedStyle){S=ac.defaultView.getComputedStyle(V,null).getPropertyValue("white-space")}}var Z=S&&"pre"===S.substring(0,3);var af=ac.createElement("LI");while(V.firstChild){af.appendChild(V.firstChild)}var W=[af];function ae(al){switch(al.nodeType){case 1:if(U.test(al.className)){break}if("BR"===al.nodeName){ad(al);if(al.parentNode){al.parentNode.removeChild(al)}}else{for(var an=al.firstChild;an;an=an.nextSibling){ae(an)}}break;case 3:case 4:if(Z){var am=al.nodeValue;var aj=am.match(ab);if(aj){var ai=am.substring(0,aj.index);al.nodeValue=ai;var ah=am.substring(aj.index+aj[0].length);if(ah){var ak=al.parentNode;ak.insertBefore(ac.createTextNode(ah),al.nextSibling)}ad(al);if(!ai){al.parentNode.removeChild(al)}}}break}}function ad(ak){while(!ak.nextSibling){ak=ak.parentNode;if(!ak){return}}function ai(al,ar){var aq=ar?al.cloneNode(false):al;var ao=al.parentNode;if(ao){var ap=ai(ao,1);var an=al.nextSibling;ap.appendChild(aq);for(var am=an;am;am=an){an=am.nextSibling;ap.appendChild(am)}}return aq}var ah=ai(ak.nextSibling,0);for(var aj;(aj=ah.parentNode)&&aj.nodeType===1;){ah=aj}W.push(ah)}for(var Y=0;Y<W.length;++Y){ae(W[Y])}if(ag===(ag|0)){W[0].setAttribute("value",ag)}var aa=ac.createElement("OL");aa.className="linenums";var X=Math.max(0,((ag-1))|0)||0;for(var Y=0,T=W.length;Y<T;++Y){af=W[Y];af.className="L"+((Y+X)%10);if(!af.firstChild){af.appendChild(ac.createTextNode("\xA0"))}aa.appendChild(af)}V.appendChild(aa)}function D(ac){var aj=/\bMSIE\b/.test(navigator.userAgent);var am=/\n/g;var al=ac.sourceCode;var an=al.length;var V=0;var aa=ac.spans;var T=aa.length;var ah=0;var X=ac.decorations;var Y=X.length;var Z=0;X[Y]=an;var ar,aq;for(aq=ar=0;aq<Y;){if(X[aq]!==X[aq+2]){X[ar++]=X[aq++];X[ar++]=X[aq++]}else{aq+=2}}Y=ar;for(aq=ar=0;aq<Y;){var at=X[aq];var ab=X[aq+1];var W=aq+2;while(W+2<=Y&&X[W+1]===ab){W+=2}X[ar++]=at;X[ar++]=ab;aq=W}Y=X.length=ar;var ae=null;while(ah<T){var af=aa[ah];var S=aa[ah+2]||an;var ag=X[Z];var ap=X[Z+2]||an;var W=Math.min(S,ap);var ak=aa[ah+1];var U;if(ak.nodeType!==1&&(U=al.substring(V,W))){if(aj){U=U.replace(am,"\r")}ak.nodeValue=U;var ai=ak.ownerDocument;var ao=ai.createElement("SPAN");ao.className=X[Z+1];var ad=ak.parentNode;ad.replaceChild(ao,ak);ao.appendChild(ak);if(V<S){aa[ah+1]=ak=ai.createTextNode(al.substring(W,S));ad.insertBefore(ak,ao.nextSibling)}}V=W;if(V>=S){ah+=2}if(V>=ap){Z+=2}}}var t={};function c(U,V){for(var S=V.length;--S>=0;){var T=V[S];if(!t.hasOwnProperty(T)){t[T]=U}else{if(window.console){console.warn("cannot override language handler %s",T)}}}}function q(T,S){if(!(T&&t.hasOwnProperty(T))){T=/^\s*</.test(S)?"default-markup":"default-code"}return t[T]}c(K,["default-code"]);c(g([],[[F,/^[^<?]+/],[E,/^<!\w[^>]*(?:>|$)/],[j,/^<\!--[\s\S]*?(?:-\->|$)/],["lang-",/^<\?([\s\S]+?)(?:\?>|$)/],["lang-",/^<%([\s\S]+?)(?:%>|$)/],[L,/^(?:<[%?]|[%?]>)/],["lang-",/^<xmp\b[^>]*>([\s\S]+?)<\/xmp\b[^>]*>/i],["lang-js",/^<script\b[^>]*>([\s\S]*?)(<\/script\b[^>]*>)/i],["lang-css",/^<style\b[^>]*>([\s\S]*?)(<\/style\b[^>]*>)/i],["lang-in.tag",/^(<\/?[a-z][^<>]*>)/i]]),["default-markup","htm","html","mxml","xhtml","xml","xsl"]);c(g([[F,/^[\s]+/,null," \t\r\n"],[n,/^(?:\"[^\"]*\"?|\'[^\']*\'?)/,null,"\"'"]],[[m,/^^<\/?[a-z](?:[\w.:-]*\w)?|\/?>$/i],[P,/^(?!style[\s=]|on)[a-z](?:[\w:-]*\w)?/i],["lang-uq.val",/^=\s*([^>\'\"\s]*(?:[^>\'\"\s\/]|\/(?=\s)))/],[L,/^[=<>\/]+/],["lang-js",/^on\w+\s*=\s*\"([^\"]+)\"/i],["lang-js",/^on\w+\s*=\s*\'([^\']+)\'/i],["lang-js",/^on\w+\s*=\s*([^\"\'>\s]+)/i],["lang-css",/^style\s*=\s*\"([^\"]+)\"/i],["lang-css",/^style\s*=\s*\'([^\']+)\'/i],["lang-css",/^style\s*=\s*([^\"\'>\s]+)/i]]),["in.tag"]);c(g([],[[n,/^[\s\S]+/]]),["uq.val"]);c(i({keywords:l,hashComments:true,cStyleComments:true,types:e}),["c","cc","cpp","cxx","cyc","m"]);c(i({keywords:"null,true,false"}),["json"]);c(i({keywords:R,hashComments:true,cStyleComments:true,verbatimStrings:true,types:e}),["cs"]);c(i({keywords:x,cStyleComments:true}),["java"]);c(i({keywords:H,hashComments:true,multiLineStrings:true}),["bsh","csh","sh"]);c(i({keywords:I,hashComments:true,multiLineStrings:true,tripleQuotedStrings:true}),["cv","py"]);c(i({keywords:s,hashComments:true,multiLineStrings:true,regexLiterals:true}),["perl","pl","pm"]);c(i({keywords:f,hashComments:true,multiLineStrings:true,regexLiterals:true}),["rb"]);c(i({keywords:w,cStyleComments:true,regexLiterals:true}),["js"]);c(i({keywords:r,hashComments:3,cStyleComments:true,multilineStrings:true,tripleQuotedStrings:true,regexLiterals:true}),["coffee"]);c(g([],[[C,/^[\s\S]+/]]),["regex"]);function d(V){var U=V.langExtension;try{var S=a(V.sourceNode);var T=S.sourceCode;V.sourceCode=T;V.spans=S.spans;V.basePos=0;q(U,T)(V);D(V)}catch(W){if("console" in window){console.log(W&&W.stack?W.stack:W)}}}function y(W,V,U){var S=document.createElement("PRE");S.innerHTML=W;if(U){Q(S,U)}var T={langExtension:V,numberLines:U,sourceNode:S};d(T);return S.innerHTML}function b(ad){function Y(af){return document.getElementsByTagName(af)}var ac=[Y("pre"),Y("code"),Y("xmp")];var T=[];for(var aa=0;aa<ac.length;++aa){for(var Z=0,V=ac[aa].length;Z<V;++Z){T.push(ac[aa][Z])}}ac=null;var W=Date;if(!W.now){W={now:function(){return +(new Date)}}}var X=0;var S;var ab=/\blang(?:uage)?-([\w.]+)(?!\S)/;var ae=/\bprettyprint\b/;function U(){var ag=(window.PR_SHOULD_USE_CONTINUATION?W.now()+250:Infinity);for(;X<T.length&&W.now()<ag;X++){var aj=T[X];var ai=aj.className;if(ai.indexOf("prettyprint")>=0){var ah=ai.match(ab);var am;if(!ah&&(am=o(aj))&&"CODE"===am.tagName){ah=am.className.match(ab)}if(ah){ah=ah[1]}var al=false;for(var ak=aj.parentNode;ak;ak=ak.parentNode){if((ak.tagName==="pre"||ak.tagName==="code"||ak.tagName==="xmp")&&ak.className&&ak.className.indexOf("prettyprint")>=0){al=true;break}}if(!al){var af=aj.className.match(/\blinenums\b(?::(\d+))?/);af=af?af[1]&&af[1].length?+af[1]:true:false;if(af){Q(aj,af)}S={langExtension:ah,sourceNode:aj,numberLines:af};d(S)}}}if(X<T.length){setTimeout(U,250)}else{if(ad){ad()}}}U()}window.prettyPrintOne=y;window.prettyPrint=b;window.PR={createSimpleLexer:g,registerLangHandler:c,sourceDecorator:i,PR_ATTRIB_NAME:P,PR_ATTRIB_VALUE:n,PR_COMMENT:j,PR_DECLARATION:E,PR_KEYWORD:z,PR_LITERAL:G,PR_NOCODE:N,PR_PLAIN:F,PR_PUNCTUATION:L,PR_SOURCE:J,PR_STRING:C,PR_TAG:m,PR_TYPE:O}})();PR.registerLangHandler(PR.createSimpleLexer([],[[PR.PR_DECLARATION,/^<!\w[^>]*(?:>|$)/],[PR.PR_COMMENT,/^<\!--[\s\S]*?(?:-\->|$)/],[PR.PR_PUNCTUATION,/^(?:<[%?]|[%?]>)/],["lang-",/^<\?([\s\S]+?)(?:\?>|$)/],["lang-",/^<%([\s\S]+?)(?:%>|$)/],["lang-",/^<xmp\b[^>]*>([\s\S]+?)<\/xmp\b[^>]*>/i],["lang-handlebars",/^<script\b[^>]*type\s*=\s*['"]?text\/x-handlebars-template['"]?\b[^>]*>([\s\S]*?)(<\/script\b[^>]*>)/i],["lang-js",/^<script\b[^>]*>([\s\S]*?)(<\/script\b[^>]*>)/i],["lang-css",/^<style\b[^>]*>([\s\S]*?)(<\/style\b[^>]*>)/i],["lang-in.tag",/^(<\/?[a-z][^<>]*>)/i],[PR.PR_DECLARATION,/^{{[#^>/]?\s*[\w.][^}]*}}/],[PR.PR_DECLARATION,/^{{&?\s*[\w.][^}]*}}/],[PR.PR_DECLARATION,/^{{{>?\s*[\w.][^}]*}}}/],[PR.PR_COMMENT,/^{{![^}]*}}/]]),["handlebars","hbs"]);PR.registerLangHandler(PR.createSimpleLexer([[PR.PR_PLAIN,/^[ \t\r\n\f]+/,null," \t\r\n\f"]],[[PR.PR_STRING,/^\"(?:[^\n\r\f\\\"]|\\(?:\r\n?|\n|\f)|\\[\s\S])*\"/,null],[PR.PR_STRING,/^\'(?:[^\n\r\f\\\']|\\(?:\r\n?|\n|\f)|\\[\s\S])*\'/,null],["lang-css-str",/^url\(([^\)\"\']*)\)/i],[PR.PR_KEYWORD,/^(?:url|rgb|\!important|@import|@page|@media|@charset|inherit)(?=[^\-\w]|$)/i,null],["lang-css-kw",/^(-?(?:[_a-z]|(?:\\[0-9a-f]+ ?))(?:[_a-z0-9\-]|\\(?:\\[0-9a-f]+ ?))*)\s*:/i],[PR.PR_COMMENT,/^\/\*[^*]*\*+(?:[^\/*][^*]*\*+)*\//],[PR.PR_COMMENT,/^(?:<!--|-->)/],[PR.PR_LITERAL,/^(?:\d+|\d*\.\d+)(?:%|[a-z]+)?/i],[PR.PR_LITERAL,/^#(?:[0-9a-f]{3}){1,2}/i],[PR.PR_PLAIN,/^-?(?:[_a-z]|(?:\\[\da-f]+ ?))(?:[_a-z\d\-]|\\(?:\\[\da-f]+ ?))*/i],[PR.PR_PUNCTUATION,/^[^\s\w\'\"]+/]]),["css"]);PR.registerLangHandler(PR.createSimpleLexer([],[[PR.PR_KEYWORD,/^-?(?:[_a-z]|(?:\\[\da-f]+ ?))(?:[_a-z\d\-]|\\(?:\\[\da-f]+ ?))*/i]]),["css-kw"]);PR.registerLangHandler(PR.createSimpleLexer([],[[PR.PR_STRING,/^[^\)\"\']+/]]),["css-str"]);
</file>

<file path="frontend/coverage/sorter.js">
/* eslint-disable */
var addSorting = (function() {
    'use strict';
    var cols,
        currentSort = {
            index: 0,
            desc: false
        };

    // returns the summary table element
    function getTable() {
        return document.querySelector('.coverage-summary');
    }
    // returns the thead element of the summary table
    function getTableHeader() {
        return getTable().querySelector('thead tr');
    }
    // returns the tbody element of the summary table
    function getTableBody() {
        return getTable().querySelector('tbody');
    }
    // returns the th element for nth column
    function getNthColumn(n) {
        return getTableHeader().querySelectorAll('th')[n];
    }

    function onFilterInput() {
        const searchValue = document.getElementById('fileSearch').value;
        const rows = document.getElementsByTagName('tbody')[0].children;

        // Try to create a RegExp from the searchValue. If it fails (invalid regex),
        // it will be treated as a plain text search
        let searchRegex;
        try {
            searchRegex = new RegExp(searchValue, 'i'); // 'i' for case-insensitive
        } catch (error) {
            searchRegex = null;
        }

        for (let i = 0; i < rows.length; i++) {
            const row = rows[i];
            let isMatch = false;

            if (searchRegex) {
                // If a valid regex was created, use it for matching
                isMatch = searchRegex.test(row.textContent);
            } else {
                // Otherwise, fall back to the original plain text search
                isMatch = row.textContent
                    .toLowerCase()
                    .includes(searchValue.toLowerCase());
            }

            row.style.display = isMatch ? '' : 'none';
        }
    }

    // loads the search box
    function addSearchBox() {
        var template = document.getElementById('filterTemplate');
        var templateClone = template.content.cloneNode(true);
        templateClone.getElementById('fileSearch').oninput = onFilterInput;
        template.parentElement.appendChild(templateClone);
    }

    // loads all columns
    function loadColumns() {
        var colNodes = getTableHeader().querySelectorAll('th'),
            colNode,
            cols = [],
            col,
            i;

        for (i = 0; i < colNodes.length; i += 1) {
            colNode = colNodes[i];
            col = {
                key: colNode.getAttribute('data-col'),
                sortable: !colNode.getAttribute('data-nosort'),
                type: colNode.getAttribute('data-type') || 'string'
            };
            cols.push(col);
            if (col.sortable) {
                col.defaultDescSort = col.type === 'number';
                colNode.innerHTML =
                    colNode.innerHTML + '<span class="sorter"></span>';
            }
        }
        return cols;
    }
    // attaches a data attribute to every tr element with an object
    // of data values keyed by column name
    function loadRowData(tableRow) {
        var tableCols = tableRow.querySelectorAll('td'),
            colNode,
            col,
            data = {},
            i,
            val;
        for (i = 0; i < tableCols.length; i += 1) {
            colNode = tableCols[i];
            col = cols[i];
            val = colNode.getAttribute('data-value');
            if (col.type === 'number') {
                val = Number(val);
            }
            data[col.key] = val;
        }
        return data;
    }
    // loads all row data
    function loadData() {
        var rows = getTableBody().querySelectorAll('tr'),
            i;

        for (i = 0; i < rows.length; i += 1) {
            rows[i].data = loadRowData(rows[i]);
        }
    }
    // sorts the table using the data for the ith column
    function sortByIndex(index, desc) {
        var key = cols[index].key,
            sorter = function(a, b) {
                a = a.data[key];
                b = b.data[key];
                return a < b ? -1 : a > b ? 1 : 0;
            },
            finalSorter = sorter,
            tableBody = document.querySelector('.coverage-summary tbody'),
            rowNodes = tableBody.querySelectorAll('tr'),
            rows = [],
            i;

        if (desc) {
            finalSorter = function(a, b) {
                return -1 * sorter(a, b);
            };
        }

        for (i = 0; i < rowNodes.length; i += 1) {
            rows.push(rowNodes[i]);
            tableBody.removeChild(rowNodes[i]);
        }

        rows.sort(finalSorter);

        for (i = 0; i < rows.length; i += 1) {
            tableBody.appendChild(rows[i]);
        }
    }
    // removes sort indicators for current column being sorted
    function removeSortIndicators() {
        var col = getNthColumn(currentSort.index),
            cls = col.className;

        cls = cls.replace(/ sorted$/, '').replace(/ sorted-desc$/, '');
        col.className = cls;
    }
    // adds sort indicators for current column being sorted
    function addSortIndicators() {
        getNthColumn(currentSort.index).className += currentSort.desc
            ? ' sorted-desc'
            : ' sorted';
    }
    // adds event listeners for all sorter widgets
    function enableUI() {
        var i,
            el,
            ithSorter = function ithSorter(i) {
                var col = cols[i];

                return function() {
                    var desc = col.defaultDescSort;

                    if (currentSort.index === i) {
                        desc = !currentSort.desc;
                    }
                    sortByIndex(i, desc);
                    removeSortIndicators();
                    currentSort.index = i;
                    currentSort.desc = desc;
                    addSortIndicators();
                };
            };
        for (i = 0; i < cols.length; i += 1) {
            if (cols[i].sortable) {
                // add the click event handler on the th so users
                // dont have to click on those tiny arrows
                el = getNthColumn(i).querySelector('.sorter').parentElement;
                if (el.addEventListener) {
                    el.addEventListener('click', ithSorter(i));
                } else {
                    el.attachEvent('onclick', ithSorter(i));
                }
            }
        }
    }
    // adds sorting functionality to the UI
    return function() {
        if (!getTable()) {
            return;
        }
        cols = loadColumns();
        loadData();
        addSearchBox();
        addSortIndicators();
        enableUI();
    };
})();

window.addEventListener('load', addSorting);
</file>

<file path="frontend/src/components/EconomyHud.test.tsx">
import { describe, it, expect, beforeEach, vi } from 'vitest';
import { render, screen } from '@testing-library/react';
import { EconomyHud } from './EconomyHud';
import { useWorldStore } from '../stores/worldStore';
import { useEconomyStore } from '../stores/economyStore';

// react-i18next 모킹
vi.mock('react-i18next', () => ({
  useTranslation: () => ({
    t: (key: string) => key,
  }),
}));

describe('EconomyHud', () => {
  beforeEach(() => {
    useWorldStore.getState().reset();
    useEconomyStore.getState().reset();
  });

  it('현재 잔액을 올바르게 표시해야 한다', () => {
    useWorldStore.getState().setEconomy({ signal: 50, memory_shard: 5 });

    render(<EconomyHud />);

    expect(screen.getByTestId('signal-balance')).toHaveTextContent('50');
    expect(screen.getByTestId('shard-balance')).toHaveTextContent('5');
  });

  it('예상 비용이 있을 때 표시해야 한다', () => {
    useEconomyStore.getState().setCostEstimate({
      min: { signal: 5, memory_shard: 0 },
      max: { signal: 10, memory_shard: 0 },
      label: 'Test Action',
    });

    render(<EconomyHud />);

    expect(screen.getByText('economy.estimated_cost')).toBeInTheDocument();
    expect(screen.getByText('Test Action')).toBeInTheDocument();
    expect(screen.getByText('5~10')).toBeInTheDocument();
  });

  it('감당할 수 없는 예상 비용일 때 경고를 표시해야 한다', () => {
    useWorldStore.getState().setEconomy({ signal: 5, memory_shard: 0 });
    useEconomyStore.getState().setCostEstimate({
      min: { signal: 10, memory_shard: 0 },
      max: { signal: 15, memory_shard: 0 },
    });

    const { container } = render(<EconomyHud />);

    expect(screen.getByText('economy.insufficient_funds')).toBeInTheDocument();
    expect(container.querySelector('.cost-unaffordable')).toBeInTheDocument();
  });

  it('예상 비용이 없을 때 마지막 확정 비용을 표시해야 한다', () => {
    useEconomyStore.getState().setLastCost({
      turnId: 1,
      cost: { signal: 8, memory_shard: 1 },
      balanceAfter: { signal: 92, memory_shard: 4 },
      modelLabel: 'QUALITY',
    });

    render(<EconomyHud />);

    expect(screen.getByText('economy.confirmed_cost')).toBeInTheDocument();
    expect(screen.getByText('8')).toBeInTheDocument();
    expect(screen.getByText('1')).toBeInTheDocument();
    expect(screen.getByText('economy.model_label.QUALITY')).toBeInTheDocument();
  });

  it('잔액 부족 시 경고 및 대안을 표시해야 한다', () => {
    // 임계값 10, 현재 잔액 5
    useWorldStore.getState().setEconomy({ signal: 5, memory_shard: 0 });
    useEconomyStore.getState().updateBalanceLowStatus({ signal: 5, memory_shard: 0 });

    render(<EconomyHud />);

    expect(screen.getByText('economy.low_balance_warning')).toBeInTheDocument();
    expect(screen.getByText('economy.alternatives_title')).toBeInTheDocument();
    expect(screen.getByText('economy.alternative_text_only')).toBeInTheDocument();
  });

  it('compact 모드에서는 잔액만 표시해야 한다', () => {
    useEconomyStore.getState().setCostEstimate({
      min: { signal: 5, memory_shard: 0 },
      max: { signal: 10, memory_shard: 0 },
    });

    render(<EconomyHud compact />);

    // 잔액은 표시됨
    expect(screen.getByTestId('signal-balance')).toBeInTheDocument();
    // 예상 비용은 표시되지 않음
    expect(screen.queryByText('economy.estimated_cost')).not.toBeInTheDocument();
  });

  it('원장 이력이 있을 때 표시해야 한다', () => {
    useEconomyStore.getState().addLedgerEntry({
      turnId: 1,
      reason: 'test reason',
      cost: { signal: 5, memory_shard: 0 },
      balanceAfter: { signal: 95, memory_shard: 5 },
      modelLabel: 'FAST',
    });

    render(<EconomyHud />);

    expect(screen.getByText('economy.ledger_title')).toBeInTheDocument();
    expect(screen.getByText('T1')).toBeInTheDocument();
    expect(screen.getByText('test reason')).toBeInTheDocument();
    expect(screen.getByText('-5')).toBeInTheDocument();
  });
});
</file>

<file path="frontend/src/components/EconomyHud.tsx">
/**
 * Unknown World - Economy HUD 컴포넌트 (U-014[Mvp]).
 *
 * Signal/Memory Shard 재화 잔액, 예상 비용, 확정 비용을 표시하고,
 * 잔액 부족 시 경고 및 대안을 안내하는 게임 HUD 컴포넌트입니다.
 *
 * RULE-002 준수: 채팅 버블이 아닌 게임 HUD 형태
 * RULE-005 준수: 예상 비용 사전 표시, 잔액 음수 표시 방지
 * RULE-008 준수: 비용/모델 선택 이유는 라벨로만 표시 (프롬프트 노출 금지)
 *
 * @see vibe/prd.md 5장 - 재화 목적/UX 요구
 * @module components/EconomyHud
 */

import { useMemo } from 'react';
import { useTranslation } from 'react-i18next';
import { useShallow } from 'zustand/react/shallow';
import { useWorldStore } from '../stores/worldStore';
import {
  useEconomyStore,
  selectCostEstimate,
  selectLastCost,
  selectIsBalanceLow,
  selectRecentLedger,
  canAffordEstimate,
  type LedgerEntry,
} from '../stores/economyStore';
import type { CurrencyAmount } from '../schemas/turn';

// =============================================================================
// 타입 정의
// =============================================================================

export interface EconomyHudProps {
  /** 간소화 모드 (헤더용 - 잔액만 표시) */
  compact?: boolean;
  /** 추가 CSS 클래스 */
  className?: string;
}

// =============================================================================
// 아이콘 컴포넌트
// =============================================================================

interface CurrencyIconProps {
  type: 'signal' | 'shard';
  size?: number;
}

function CurrencyIcon({ type, size = 20 }: CurrencyIconProps) {
  const { t } = useTranslation();

  const iconSrc = type === 'signal' ? '/ui/icons/signal-24.png' : '/ui/icons/shard-24.png';
  const fallback = type === 'signal' ? '⚡' : '💎';
  const label = type === 'signal' ? t('economy.signal') : t('economy.shard');

  return (
    <span className="icon-wrapper" aria-label={label}>
      <img
        src={iconSrc}
        alt=""
        aria-hidden="true"
        className="icon-img"
        style={{ width: size, height: size }}
        onError={(e) => e.currentTarget.classList.add('hidden')}
      />
      <span className="icon-fallback">{fallback}</span>
    </span>
  );
}

// =============================================================================
// 잔액 표시 컴포넌트
// =============================================================================

interface BalanceDisplayProps {
  balance: CurrencyAmount;
  isLow?: boolean;
}

function BalanceDisplay({ balance, isLow }: BalanceDisplayProps) {
  const { t } = useTranslation();

  return (
    <div className={`economy-balance ${isLow ? 'balance-low' : ''}`} data-ui-importance="critical">
      <div className="balance-item">
        <CurrencyIcon type="signal" />
        <span className="balance-value" data-testid="signal-balance">
          {balance.signal}
        </span>
        <span className="balance-label">{t('economy.signal')}</span>
      </div>
      <div className="balance-item">
        <CurrencyIcon type="shard" />
        <span className="balance-value" data-testid="shard-balance">
          {balance.memory_shard}
        </span>
        <span className="balance-label">{t('economy.shard')}</span>
      </div>
      {isLow && (
        <div className="balance-warning" aria-live="polite">
          <span className="warning-icon">⚠</span>
          <span className="warning-text">{t('economy.low_balance_warning')}</span>
        </div>
      )}
    </div>
  );
}

// =============================================================================
// 비용 표시 컴포넌트
// =============================================================================

interface CostDisplayProps {
  /** 비용 유형 */
  type: 'estimate' | 'confirmed';
  /** 비용 범위 (예상) */
  min?: CurrencyAmount;
  max?: CurrencyAmount;
  /** 확정 비용 */
  cost?: CurrencyAmount;
  /** 감당 가능 여부 */
  affordable?: boolean;
  /** 라벨 */
  label?: string;
}

function CostDisplay({ type, min, max, cost, affordable, label }: CostDisplayProps) {
  const { t } = useTranslation();

  const isRange =
    min && max && (min.signal !== max.signal || min.memory_shard !== max.memory_shard);

  const titleKey = type === 'estimate' ? 'economy.estimated_cost' : 'economy.confirmed_cost';
  const cssClass = type === 'estimate' ? 'cost-estimate' : 'cost-confirmed';

  return (
    <div
      className={`economy-cost ${cssClass} ${affordable === false ? 'cost-unaffordable' : ''}`}
      data-ui-importance="critical"
    >
      <div className="cost-header">
        <span className="cost-title">{t(titleKey)}</span>
        {label && <span className="cost-label">{label}</span>}
      </div>
      <div className="cost-values">
        {/* Signal 비용 */}
        <div className="cost-item">
          <CurrencyIcon type="signal" size={14} />
          <span className="cost-value">
            {type === 'estimate' && min && max
              ? isRange
                ? `${min.signal}~${max.signal}`
                : min.signal
              : cost
                ? cost.signal
                : '-'}
          </span>
        </div>
        {/* Shard 비용 (0보다 클 때만 표시) */}
        {((type === 'estimate' && max && max.memory_shard > 0) ||
          (type === 'confirmed' && cost && cost.memory_shard > 0)) && (
          <div className="cost-item">
            <span className="cost-separator">|</span>
            <CurrencyIcon type="shard" size={14} />
            <span className="cost-value">
              {type === 'estimate' && min && max
                ? isRange
                  ? `${min.memory_shard}~${max.memory_shard}`
                  : min.memory_shard
                : cost
                  ? cost.memory_shard
                  : '-'}
            </span>
          </div>
        )}
      </div>
      {affordable === false && (
        <div className="cost-warning">
          <span className="warning-text">{t('economy.insufficient_funds')}</span>
        </div>
      )}
    </div>
  );
}

// =============================================================================
// 원장(Ledger) 항목 컴포넌트
// =============================================================================

function LedgerItem({ entry }: { entry: LedgerEntry }) {
  const { t } = useTranslation();

  return (
    <div className="ledger-item">
      <div className="ledger-info">
        <span className="ledger-turn">T{entry.turnId}</span>
        <span className="ledger-reason">{entry.reason}</span>
      </div>
      <div className="ledger-values">
        <span className="ledger-cost">
          -{entry.cost.signal}
          {entry.cost.memory_shard > 0 && ` / -${entry.cost.memory_shard}`}
        </span>
        <span
          className="ledger-model"
          title={entry.modelLabel ? t(`economy.model_label.${entry.modelLabel}`) : undefined}
        >
          {entry.modelLabel?.charAt(0)}
        </span>
      </div>
    </div>
  );
}

// =============================================================================
// 셀렉터 정의 (컴포넌트 외부에서 생성하여 참조 유지)
// =============================================================================

const selectHistory = selectRecentLedger(5);

// =============================================================================
// 메인 Economy HUD 컴포넌트
// =============================================================================

export function EconomyHud({ compact = false, className = '' }: EconomyHudProps) {
  const { t } = useTranslation();

  // Store 상태
  const economy = useWorldStore((state) => state.economy);
  const costEstimate = useEconomyStore(selectCostEstimate);
  const lastCost = useEconomyStore(selectLastCost);
  const isBalanceLow = useEconomyStore(selectIsBalanceLow);
  const recentLedger = useEconomyStore(useShallow(selectHistory));

  // 예상 비용 감당 가능 여부 계산
  const estimateAffordability = useMemo(() => {
    if (!costEstimate) return null;
    return canAffordEstimate(economy, costEstimate);
  }, [economy, costEstimate]);

  // Compact 모드 (헤더용): 잔액만 표시
  if (compact) {
    return (
      <div
        className={`economy-hud economy-hud-compact ${className}`}
        role="status"
        aria-live="polite"
      >
        <BalanceDisplay balance={economy} isLow={isBalanceLow} />
      </div>
    );
  }

  // Full 모드: 잔액 + 예상 비용 + 확정 비용 + 원장 이력
  return (
    <div
      className={`economy-hud economy-hud-full ${className}`}
      role="region"
      aria-label={t('economy.hud_label')}
    >
      {/* 현재 잔액 */}
      <BalanceDisplay balance={economy} isLow={isBalanceLow} />

      {/* 예상 비용 (카드 선택/호버 시) */}
      {costEstimate && (
        <CostDisplay
          type="estimate"
          min={costEstimate.min}
          max={costEstimate.max}
          affordable={estimateAffordability?.affordable}
          label={costEstimate.label}
        />
      )}

      {/* 마지막 확정 비용 (예상 비용이 없을 때만 표시) */}
      {!costEstimate && lastCost && (
        <CostDisplay
          type="confirmed"
          cost={lastCost.cost}
          label={lastCost.modelLabel ? t(`economy.model_label.${lastCost.modelLabel}`) : undefined}
        />
      )}

      {/* 대안 안내 (잔액 부족 시) */}
      {isBalanceLow && (
        <div className="economy-alternatives" data-ui-importance="critical">
          <div className="alternatives-header">
            <span className="alternatives-icon">💡</span>
            <span className="alternatives-title">{t('economy.alternatives_title')}</span>
          </div>
          <ul className="alternatives-list">
            <li>{t('economy.alternative_text_only')}</li>
            <li>{t('economy.alternative_low_quality')}</li>
          </ul>
        </div>
      )}

      {/* 원장 이력 (Ledger) */}
      <div className="economy-ledger">
        <div className="ledger-header">
          <span className="ledger-title">{t('economy.ledger_title')}</span>
        </div>
        {recentLedger.length > 0 ? (
          <div className="ledger-list">
            {recentLedger.map((entry) => (
              <LedgerItem key={`${entry.turnId}-${entry.timestamp}`} entry={entry} />
            ))}
          </div>
        ) : (
          <div className="ledger-empty">{t('economy.ledger_empty')}</div>
        )}
      </div>
    </div>
  );
}

// =============================================================================
// 헤더용 간소화 컴포넌트 (GameHeader 통합용)
// =============================================================================

export interface EconomyHudHeaderProps {
  signal: number;
  memoryShard: number;
  isLow?: boolean;
}

/**
 * GameHeader에서 사용하는 간소화된 Economy HUD.
 * 기존 GameHeader의 economy-hud를 대체합니다.
 */
export function EconomyHudHeader({ signal, memoryShard, isLow }: EconomyHudHeaderProps) {
  const { t } = useTranslation();
  const costEstimate = useEconomyStore(selectCostEstimate);

  // 예상 비용 감당 가능 여부
  const estimateAffordability = useMemo(() => {
    if (!costEstimate) return null;
    const balance = { signal, memory_shard: memoryShard };
    return canAffordEstimate(balance, costEstimate);
  }, [signal, memoryShard, costEstimate]);

  return (
    <div className={`economy-hud ${isLow ? 'economy-hud-low' : ''}`} data-ui-importance="critical">
      {/* 잔액 표시 */}
      <span className="icon-wrapper signal-icon" aria-label={t('economy.signal')}>
        <img
          src="/ui/icons/signal-24.png"
          alt=""
          aria-hidden="true"
          className="icon-img"
          onError={(e) => e.currentTarget.classList.add('hidden')}
        />
        <span className="icon-fallback">⚡</span>
      </span>
      <span className="currency-value" data-testid="header-signal">
        {t('economy.signal')}: {signal}
      </span>
      <span className="icon-wrapper shard-icon" aria-label={t('economy.shard')}>
        <img
          src="/ui/icons/shard-24.png"
          alt=""
          aria-hidden="true"
          className="icon-img"
          onError={(e) => e.currentTarget.classList.add('hidden')}
        />
        <span className="icon-fallback">💎</span>
      </span>
      <span className="currency-value" data-testid="header-shard">
        {t('economy.shard')}: {memoryShard}
      </span>

      {/* 예상 비용 미니 표시 */}
      {costEstimate && (
        <span
          className={`economy-estimate-mini ${
            estimateAffordability?.affordable === false ? 'unaffordable' : ''
          }`}
          title={t('economy.estimated_cost')}
        >
          <span className="estimate-prefix">→</span>
          <span className="estimate-value">
            -{costEstimate.max.signal}
            {costEstimate.max.memory_shard > 0 && `/${costEstimate.max.memory_shard}`}
          </span>
        </span>
      )}

      {/* 잔액 부족 경고 아이콘 */}
      {isLow && (
        <span className="balance-warning-icon" title={t('economy.low_balance_warning')}>
          ⚠
        </span>
      )}
    </div>
  );
}

export default EconomyHud;
</file>

<file path="frontend/src/components/InventoryPanel.test.tsx">
import { describe, it, expect, vi, beforeEach } from 'vitest';
import { render, screen, fireEvent } from '@testing-library/react';
import { InventoryPanel } from './InventoryPanel';
import { useInventoryStore } from '../stores/inventoryStore';

// i18next 모킹
vi.mock('react-i18next', () => ({
  useTranslation: () => ({
    t: (key: string) => {
      if (key === 'inventory.empty') return 'Inventory is empty';
      if (key === 'inventory.grid_label') return 'Inventory Grid';
      return key;
    },
  }),
}));

// dnd-kit 모킹 (필요시)
// dnd-kit hooks often return attributes/listeners/setNodeRef
// For basic rendering test, we might not need to mock them if they don't crash jsdom

describe('InventoryPanel Component', () => {
  beforeEach(() => {
    useInventoryStore.getState().reset();
  });

  it('아이템이 없을 때 빈 상태 메시지를 표시해야 한다', () => {
    render(<InventoryPanel />);
    expect(screen.getByText('Inventory is empty')).toBeInTheDocument();
  });

  it('아이템이 있을 때 목록을 렌더링해야 한다', () => {
    const { addItems } = useInventoryStore.getState();
    addItems([
      { id: 'item1', name: 'Item 1', quantity: 1, icon: '🍎' },
      { id: 'item2', name: 'Item 2', quantity: 3, icon: '🗡️' },
    ]);

    render(<InventoryPanel />);

    expect(screen.getByText('Item 1')).toBeInTheDocument();
    expect(screen.getByText('🍎')).toBeInTheDocument();
    expect(screen.getByText('Item 2')).toBeInTheDocument();
    expect(screen.getByText('🗡️')).toBeInTheDocument();
    expect(screen.getByText('x3')).toBeInTheDocument();
  });

  it('아이템 클릭 시 선택되어야 한다', () => {
    const { addItems } = useInventoryStore.getState();
    addItems([{ id: 'item1', name: 'Item 1', quantity: 1 }]);

    render(<InventoryPanel />);

    const item = screen.getByText('Item 1').closest('.inventory-item');
    expect(item).not.toHaveClass('selected');

    fireEvent.click(screen.getByText('Item 1'));

    expect(item).toHaveClass('selected');
    expect(useInventoryStore.getState().selectedItemId).toBe('item1');
  });

  it('disabled 프로프가 true일 때 아이템 클릭이 무시되어야 한다', () => {
    const { addItems } = useInventoryStore.getState();
    addItems([{ id: 'item1', name: 'Item 1', quantity: 1 }]);

    render(<InventoryPanel disabled={true} />);

    fireEvent.click(screen.getByText('Item 1'));

    const item = screen.getByText('Item 1').closest('.inventory-item');
    expect(item).not.toHaveClass('selected');
    expect(useInventoryStore.getState().selectedItemId).toBeNull();
  });
});
</file>

<file path="frontend/src/components/MutationTimeline.test.tsx">
import { describe, it, expect, beforeEach, vi } from 'vitest';
import { render, screen } from '@testing-library/react';
import { MutationTimeline } from './MutationTimeline';
import { useWorldStore } from '../stores/worldStore';

vi.mock('react-i18next', () => ({
  useTranslation: () => ({
    t: (key: string, options?: Record<string, unknown>) => {
      if (options?.turn !== undefined) return `T${options.turn}`;
      if (options?.count !== undefined) return `${key} (count: ${options.count})`;
      return key;
    },
  }),
}));

describe('MutationTimeline (U-013)', () => {
  beforeEach(() => {
    useWorldStore.getState().reset();
  });

  it('변형 이력이 없을 때 빈 상태를 표시해야 한다', () => {
    render(<MutationTimeline />);
    expect(screen.getByText('mutation.empty')).toBeInTheDocument();
  });

  it('변형 이벤트 목록을 최신순으로 표시해야 한다', () => {
    useWorldStore.setState({
      mutationTimeline: [
        {
          turn: 2,
          ruleId: 'r2',
          type: 'modified',
          label: '수정된 규칙',
          timestamp: Date.now(),
        },
        {
          turn: 1,
          ruleId: 'r1',
          type: 'added',
          label: '새 규칙',
          timestamp: Date.now() - 1000,
        },
      ],
    });

    render(<MutationTimeline />);
    expect(screen.getByText('mutation.timeline_title')).toBeInTheDocument();
    expect(screen.getAllByText('T2')).toHaveLength(1);
    expect(screen.getByText('수정된 규칙')).toBeInTheDocument();
    expect(screen.getByText('mutation.type.modified')).toBeInTheDocument();

    expect(screen.getAllByText('T1')).toHaveLength(1);
    expect(screen.getByText('새 규칙')).toBeInTheDocument();
    expect(screen.getByText('mutation.type.added')).toBeInTheDocument();
  });

  it('이벤트가 많을 때 "더 보기" 표시를 해야 한다 (최대 10개 기준)', () => {
    const manyEvents = Array.from({ length: 12 }, (_, i) => ({
      turn: i + 1,
      ruleId: `r${i}`,
      type: 'added' as const,
      label: `규칙 ${i}`,
      timestamp: Date.now(),
    })).reverse(); // 최신순

    useWorldStore.setState({ mutationTimeline: manyEvents });

    const { container } = render(<MutationTimeline />);
    // 10개만 렌더링됨
    expect(container.getElementsByClassName('timeline-event')).toHaveLength(10);
    // +2개 더 보기 표시
    expect(screen.getByText('mutation.more_events (count: 2)')).toBeInTheDocument();
  });
});
</file>

<file path="frontend/src/components/MutationTimeline.tsx">
/**
 * Unknown World - Mutation Timeline (U-013)
 *
 * 규칙 변형 이벤트를 시간순으로 표시하는 타임라인 컴포넌트입니다.
 * "세계가 변했다"를 UI로 체감할 수 있게 합니다.
 *
 * 설계 원칙:
 *   - RULE-002: 채팅 UI가 아닌 게임 UI로 상시 노출
 *   - RULE-006: i18n 기반 문자열 관리
 *   - PRD 6.4: Rule Mutation Timeline
 *   - Q1 결정: Option B - 별도 Timeline 컴포넌트 (가독성/확장 용이)
 *
 * @module components/MutationTimeline
 */

import { useTranslation } from 'react-i18next';
import { useWorldStore, selectMutationTimeline } from '../stores/worldStore';
import type { MutationEvent } from '../stores/worldStore';

// =============================================================================
// 상수
// =============================================================================

/** 표시할 최대 이벤트 수 (MMP에서 스크롤/요약 전략 적용 예정) */
const MAX_DISPLAY_EVENTS = 10;

// =============================================================================
// 하위 컴포넌트
// =============================================================================

interface TimelineEventProps {
  event: MutationEvent;
}

/**
 * 개별 타임라인 이벤트 렌더링
 */
function TimelineEvent({ event }: TimelineEventProps) {
  const { t } = useTranslation();

  // 이벤트 유형별 아이콘
  const typeIcon = {
    added: '➕',
    modified: '🔄',
    removed: '➖',
  }[event.type];

  // 이벤트 유형별 CSS 클래스
  const typeClass = `timeline-event-${event.type}`;

  return (
    <div className={`timeline-event ${typeClass}`} data-event-type={event.type}>
      <div className="timeline-event-marker">
        <span className="timeline-event-icon" aria-hidden="true">
          {typeIcon}
        </span>
        <span className="timeline-event-turn">
          {t('mutation.turn_label', { turn: event.turn })}
        </span>
      </div>
      <div className="timeline-event-content">
        <span className="timeline-event-label">{event.label}</span>
        <span className="timeline-event-type">{t(`mutation.type.${event.type}`)}</span>
        {event.description && <p className="timeline-event-description">{event.description}</p>}
      </div>
    </div>
  );
}

// =============================================================================
// 메인 컴포넌트
// =============================================================================

/**
 * Mutation Timeline
 *
 * 규칙 변형 이벤트를 시간순(최신 먼저)으로 표시합니다.
 * worldStore의 mutationTimeline 상태를 구독하여 실시간 업데이트됩니다.
 */
export function MutationTimeline() {
  const { t } = useTranslation();
  const mutationTimeline = useWorldStore(selectMutationTimeline);

  // 표시할 이벤트 (최대 개수 제한)
  const displayEvents = mutationTimeline.slice(0, MAX_DISPLAY_EVENTS);
  const hasMore = mutationTimeline.length > MAX_DISPLAY_EVENTS;

  // 빈 상태
  if (mutationTimeline.length === 0) {
    return (
      <div className="mutation-timeline-content timeline-empty" data-ui-importance="critical">
        <div className="timeline-empty-icon" aria-hidden="true">
          📊
        </div>
        <p className="timeline-empty-text">{t('mutation.empty')}</p>
      </div>
    );
  }

  return (
    <div className="mutation-timeline-content" data-ui-importance="critical">
      <div className="timeline-header">
        <span className="timeline-title">{t('mutation.timeline_title')}</span>
        <span className="timeline-count">
          {t('mutation.event_count', { count: mutationTimeline.length })}
        </span>
      </div>
      <div className="timeline-events" role="list" aria-label={t('mutation.timeline_title')}>
        {displayEvents.map((event, index) => (
          <TimelineEvent key={`${event.ruleId}-${event.turn}-${index}`} event={event} />
        ))}
      </div>
      {hasMore && (
        <div className="timeline-more">
          <span className="timeline-more-text">
            {t('mutation.more_events', { count: mutationTimeline.length - MAX_DISPLAY_EVENTS })}
          </span>
        </div>
      )}
    </div>
  );
}

export default MutationTimeline;
</file>

<file path="frontend/src/components/NarrativeFeed.tsx">
import { useEffect, useRef } from 'react';
import { useTranslation } from 'react-i18next';
import type { NarrativeEntry } from '../stores/worldStore';

interface NarrativeFeedProps {
  entries: NarrativeEntry[];
  streamingText: string;
}

export function NarrativeFeed({ entries, streamingText }: NarrativeFeedProps) {
  const { t } = useTranslation();
  const feedRef = useRef<HTMLDivElement>(null);

  // 새 엔트리 추가 시 스크롤
  useEffect(() => {
    if (feedRef.current) {
      feedRef.current.scrollTop = feedRef.current.scrollHeight;
    }
  }, [entries, streamingText]);

  return (
    <div className="narrative-feed" ref={feedRef}>
      {entries.map((entry, index) => (
        <div key={`${entry.turn}-${index}`} className="narrative-entry">
          <span className="narrative-timestamp">
            {t('narrative.turn_label', { turn: entry.turn })}
          </span>
          <span className="narrative-text">{entry.text}</span>
        </div>
      ))}
      {streamingText && (
        <div className="narrative-entry streaming">
          <span className="narrative-timestamp">{t('narrative.streaming_label')}</span>
          <span className="narrative-text">{streamingText}</span>
          <span className="cursor-blink">▌</span>
        </div>
      )}
    </div>
  );
}
</file>

<file path="frontend/src/components/QuestPanel.test.tsx">
import { describe, it, expect, beforeEach, vi } from 'vitest';
import { render, screen } from '@testing-library/react';
import { QuestPanel } from './QuestPanel';
import { useWorldStore } from '../stores/worldStore';

// i18next 모킹 (t 함수가 키를 반환하도록)
vi.mock('react-i18next', () => ({
  useTranslation: () => ({
    t: (key: string) => key,
  }),
}));

describe('QuestPanel (U-013)', () => {
  beforeEach(() => {
    useWorldStore.getState().reset();
  });

  it('퀘스트가 없을 때 빈 상태를 표시해야 한다', () => {
    render(<QuestPanel />);
    expect(screen.getByText('quest.empty')).toBeInTheDocument();
  });

  it('진행 중인 퀘스트를 목록에 표시해야 한다', () => {
    useWorldStore.setState({
      quests: [{ id: 'q1', label: '액티브 퀘스트', is_completed: false }],
    });

    render(<QuestPanel />);
    expect(screen.getByText('quest.section.active')).toBeInTheDocument();
    expect(screen.getByText('액티브 퀘스트')).toBeInTheDocument();
    expect(screen.getByText('☐')).toBeInTheDocument();
  });

  it('완료된 퀘스트를 목록에 표시해야 한다', () => {
    useWorldStore.setState({
      quests: [{ id: 'q2', label: '완료된 퀘스트', is_completed: true }],
    });

    render(<QuestPanel />);
    expect(screen.getByText('quest.section.completed')).toBeInTheDocument();
    expect(screen.getByText('완료된 퀘스트')).toBeInTheDocument();
    expect(screen.getByText('☑')).toBeInTheDocument();
    expect(screen.getByText('quest.completed')).toBeInTheDocument();
  });

  it('진행 중인 퀘스트와 완료된 퀘스트를 모두 표시해야 한다', () => {
    useWorldStore.setState({
      quests: [
        { id: 'q1', label: '액티브', is_completed: false },
        { id: 'q2', label: '완료', is_completed: true },
      ],
    });

    render(<QuestPanel />);
    expect(screen.getByText('액티브')).toBeInTheDocument();
    expect(screen.getByText('완료')).toBeInTheDocument();
  });
});
</file>

<file path="frontend/src/components/QuestPanel.tsx">
/**
 * Unknown World - Quest Panel (U-013)
 *
 * 플레이어의 현재 목표/서브목표를 체크리스트 형태로 표시합니다.
 *
 * 설계 원칙:
 *   - RULE-002: 채팅 UI가 아닌 게임 UI로 상시 노출
 *   - RULE-006: i18n 기반 문자열 관리
 *   - PRD 6.7: Quest/Objective Panel
 *
 * @module components/QuestPanel
 */

import { useTranslation } from 'react-i18next';
import { useWorldStore, selectQuests } from '../stores/worldStore';
import type { Quest } from '../schemas/turn';

// =============================================================================
// 하위 컴포넌트
// =============================================================================

interface QuestItemProps {
  quest: Quest;
}

/**
 * 개별 퀘스트 아이템 렌더링
 */
function QuestItem({ quest }: QuestItemProps) {
  const { t } = useTranslation();

  return (
    <li
      className={`quest-item ${quest.is_completed ? 'quest-completed' : 'quest-active'}`}
      data-quest-id={quest.id}
    >
      <span className="quest-checkbox" aria-hidden="true">
        {quest.is_completed ? '☑' : '☐'}
      </span>
      <span className="quest-label">{quest.label}</span>
      {quest.is_completed && <span className="quest-status-badge">{t('quest.completed')}</span>}
    </li>
  );
}

// =============================================================================
// 메인 컴포넌트
// =============================================================================

/**
 * Quest Panel
 *
 * 현재 목표/서브목표를 체크리스트 형태로 표시합니다.
 * worldStore의 quests 상태를 구독하여 실시간 업데이트됩니다.
 */
export function QuestPanel() {
  const { t } = useTranslation();
  const quests = useWorldStore(selectQuests);

  // 진행 중 / 완료 분리
  const activeQuests = quests.filter((q) => !q.is_completed);
  const completedQuests = quests.filter((q) => q.is_completed);

  // 빈 상태
  if (quests.length === 0) {
    return (
      <div className="quest-panel-content quest-empty" data-ui-importance="critical">
        <div className="quest-empty-icon" aria-hidden="true">
          📋
        </div>
        <p className="quest-empty-text">{t('quest.empty')}</p>
      </div>
    );
  }

  return (
    <div className="quest-panel-content" data-ui-importance="critical">
      {/* 진행 중인 퀘스트 */}
      {activeQuests.length > 0 && (
        <div className="quest-section quest-section-active">
          <h4 className="quest-section-title">{t('quest.section.active')}</h4>
          <ul className="quest-list" role="list" aria-label={t('quest.section.active')}>
            {activeQuests.map((quest) => (
              <QuestItem key={quest.id} quest={quest} />
            ))}
          </ul>
        </div>
      )}

      {/* 완료된 퀘스트 */}
      {completedQuests.length > 0 && (
        <div className="quest-section quest-section-completed">
          <h4 className="quest-section-title">{t('quest.section.completed')}</h4>
          <ul
            className="quest-list quest-list-completed"
            role="list"
            aria-label={t('quest.section.completed')}
          >
            {completedQuests.map((quest) => (
              <QuestItem key={quest.id} quest={quest} />
            ))}
          </ul>
        </div>
      )}
    </div>
  );
}

export default QuestPanel;
</file>

<file path="frontend/src/components/RuleBoard.test.tsx">
import { describe, it, expect, beforeEach, vi } from 'vitest';
import { render, screen } from '@testing-library/react';
import { RuleBoard } from './RuleBoard';
import { useWorldStore } from '../stores/worldStore';

vi.mock('react-i18next', () => ({
  useTranslation: () => ({
    t: (key: string, options?: Record<string, unknown>) => {
      if (options?.count !== undefined) return `${key} (count: ${options.count})`;
      return key;
    },
  }),
}));

describe('RuleBoard (U-013)', () => {
  beforeEach(() => {
    useWorldStore.getState().reset();
  });

  it('규칙이 없을 때 빈 상태를 표시해야 한다', () => {
    render(<RuleBoard />);
    expect(screen.getByText('rule_board.empty')).toBeInTheDocument();
  });

  it('활성 규칙 목록을 표시해야 한다', () => {
    useWorldStore.setState({
      activeRules: [
        { id: 'r1', label: '중력', description: '떨어진다' },
        { id: 'r2', label: '산소', description: '필요하다' },
      ],
    });

    render(<RuleBoard />);
    expect(screen.getByText('rule_board.active_count (count: 2)')).toBeInTheDocument();
    expect(screen.getByText('중력')).toBeInTheDocument();
    expect(screen.getByText('떨어진다')).toBeInTheDocument();
    expect(screen.getByText('산소')).toBeInTheDocument();
  });
});
</file>

<file path="frontend/src/components/RuleBoard.tsx">
/**
 * Unknown World - Rule Board (U-013)
 *
 * 현재 세계에 적용 중인 규칙/물리 법칙을 "룰 카드"로 표시합니다.
 *
 * 설계 원칙:
 *   - RULE-002: 채팅 UI가 아닌 게임 UI로 상시 노출
 *   - RULE-006: i18n 기반 문자열 관리
 *   - PRD 6.4/6.7: Rule Mutation + Rule Board
 *
 * @module components/RuleBoard
 */

import { useTranslation } from 'react-i18next';
import { useWorldStore, selectActiveRules } from '../stores/worldStore';
import type { WorldRule } from '../schemas/turn';

// =============================================================================
// 하위 컴포넌트
// =============================================================================

interface RuleCardProps {
  rule: WorldRule;
}

/**
 * 개별 룰 카드 렌더링
 */
function RuleCard({ rule }: RuleCardProps) {
  return (
    <div className="rule-card" data-rule-id={rule.id}>
      <div className="rule-card-header">
        <span className="rule-card-icon" aria-hidden="true">
          ⚙
        </span>
        <span className="rule-card-label">{rule.label}</span>
      </div>
      {rule.description && <p className="rule-card-description">{rule.description}</p>}
    </div>
  );
}

// =============================================================================
// 메인 컴포넌트
// =============================================================================

/**
 * Rule Board
 *
 * 현재 세계에 적용 중인 규칙을 카드 형태로 표시합니다.
 * worldStore의 activeRules 상태를 구독하여 실시간 업데이트됩니다.
 */
export function RuleBoard() {
  const { t } = useTranslation();
  const activeRules = useWorldStore(selectActiveRules);

  // 빈 상태
  if (activeRules.length === 0) {
    return (
      <div className="rule-board-content rule-board-empty" data-ui-importance="critical">
        <div className="rule-board-empty-icon" aria-hidden="true">
          📜
        </div>
        <p className="rule-board-empty-text">{t('rule_board.empty')}</p>
      </div>
    );
  }

  return (
    <div className="rule-board-content" data-ui-importance="critical">
      <div className="rule-board-header">
        <span className="rule-board-count">
          {t('rule_board.active_count', { count: activeRules.length })}
        </span>
      </div>
      <div className="rule-card-list">
        {activeRules.map((rule) => (
          <RuleCard key={rule.id} rule={rule} />
        ))}
      </div>
    </div>
  );
}

export default RuleBoard;
</file>

<file path="frontend/src/components/SceneCanvas.test.tsx">
import { describe, it, expect } from 'vitest';
import { SCENE_PLACEHOLDERS } from './SceneCanvas';

describe('SCENE_PLACEHOLDERS', () => {
  it('should have all required statuses', () => {
    const statuses = ['default', 'loading', 'offline', 'blocked', 'low_signal'];
    statuses.forEach((status) => {
      expect(SCENE_PLACEHOLDERS).toHaveProperty(status);
    });
  });

  it('should have correct image paths', () => {
    expect(SCENE_PLACEHOLDERS.default.imagePath).toBe(
      '/ui/placeholders/scene-placeholder-default.png',
    );
    expect(SCENE_PLACEHOLDERS.loading.imagePath).toBe('/ui/placeholders/scene-loading.webp');
    expect(SCENE_PLACEHOLDERS.offline.imagePath).toBe('/ui/placeholders/scene-offline.webp');
    expect(SCENE_PLACEHOLDERS.blocked.imagePath).toBe('/ui/placeholders/scene-blocked.webp');
    expect(SCENE_PLACEHOLDERS.low_signal.imagePath).toBe('/ui/placeholders/scene-low-signal.webp');
  });

  it('should have correct i18n label keys', () => {
    expect(SCENE_PLACEHOLDERS.default.labelKey).toBe('scene.status.default');
    expect(SCENE_PLACEHOLDERS.loading.labelKey).toBe('scene.status.loading');
    expect(SCENE_PLACEHOLDERS.offline.labelKey).toBe('scene.status.offline');
    expect(SCENE_PLACEHOLDERS.blocked.labelKey).toBe('scene.status.blocked');
    expect(SCENE_PLACEHOLDERS.low_signal.labelKey).toBe('scene.status.low_signal');
  });
});
</file>

<file path="frontend/src/components/UIControls.tsx">
import { useTranslation } from 'react-i18next';
import { UI_SCALES, type UIScale } from '../stores/uiPrefsStore';

interface UIControlsProps {
  uiScale: UIScale;
  onIncreaseScale: () => void;
  onDecreaseScale: () => void;
}

export function UIControls({ uiScale, onIncreaseScale, onDecreaseScale }: UIControlsProps) {
  const { t } = useTranslation();
  const isMinScale = uiScale === UI_SCALES[0];
  const isMaxScale = uiScale === UI_SCALES[UI_SCALES.length - 1];

  return (
    <div className="ui-controls" role="group" aria-label={t('ui.scale_label')}>
      {/* UI 스케일 조절 */}
      <button
        type="button"
        className="ui-scale-btn"
        onClick={onDecreaseScale}
        disabled={isMinScale}
        aria-label={t('ui.scale_decrease')}
        title={`${t('ui.scale_decrease')} (A-)`}
      >
        A-
      </button>
      <span className="ui-scale-display" aria-live="polite">
        {Math.round(uiScale * 100)}%
      </span>
      <button
        type="button"
        className="ui-scale-btn"
        onClick={onIncreaseScale}
        disabled={isMaxScale}
        aria-label={t('ui.scale_increase')}
        title={`${t('ui.scale_increase')} (A+)`}
      >
        A+
      </button>
    </div>
  );
}
</file>

<file path="frontend/src/i18n-scenario.test.ts">
import { describe, it, expect } from 'vitest';
import i18next from './i18n';

describe('i18n Integration Scenarios (U-039)', () => {
  it('Scenario D: should have correct i18next options', () => {
    expect(i18next.options.supportedLngs).toContain('ko-KR');
    expect(i18next.options.supportedLngs).toContain('en-US');
    expect(i18next.options.lng).toBe('ko-KR');
    expect(i18next.options.fallbackLng).toContain('en-US');
  });

  it('Scenario A: should translate to Korean by default', () => {
    // Economy labels
    expect(i18next.t('economy.signal')).toBe('Signal');
    expect(i18next.t('economy.shard')).toBe('Shard');

    // Panel titles
    expect(i18next.t('panel.inventory.title')).toBe('Inventory');
    expect(i18next.t('panel.quest.title')).toBe('Quest');

    // Agent Console
    expect(i18next.t('agent.console.queue')).toBe('대기열');
    expect(i18next.t('agent.console.status.idle')).toBe('대기 중');

    // Connection
    expect(i18next.t('connection.online')).toBe('온라인');

    // UI
    expect(i18next.t('ui.command_placeholder')).toBe('명령을 입력하세요...');
    expect(i18next.t('ui.execute')).toBe('실행');
  });

  it('Scenario B: should switch to English and back to Korean', async () => {
    // Switch to English
    await i18next.changeLanguage('en-US');
    expect(i18next.resolvedLanguage).toBe('en-US');

    // Check English translations
    expect(i18next.t('agent.console.queue')).toBe('Queue');
    expect(i18next.t('agent.console.status.idle')).toBe('IDLE');
    expect(i18next.t('connection.online')).toBe('ONLINE');
    expect(i18next.t('ui.command_placeholder')).toBe('Enter command...');
    expect(i18next.t('ui.execute')).toBe('EXECUTE');

    // Switch back to Korean
    await i18next.changeLanguage('ko-KR');
    expect(i18next.resolvedLanguage).toBe('ko-KR');
    expect(i18next.t('agent.console.queue')).toBe('대기열');
    expect(i18next.t('connection.online')).toBe('온라인');
  });
});
</file>

<file path="frontend/src/schemas/index.ts">
/**
 * Unknown World - 스키마 모듈 진입점.
 *
 * TurnInput/TurnOutput Zod 스키마 및 관련 유틸리티를 재내보내기합니다.
 *
 * @module schemas
 */

// =============================================================================
// 스키마 버전
// =============================================================================

export { SCHEMA_VERSION } from './turn';

// =============================================================================
// Enum 스키마 및 타입
// =============================================================================

export {
  LanguageSchema,
  ThemeSchema,
  AgentPhaseSchema,
  ValidationBadgeSchema,
  ModelLabelSchema,
  RiskLevelSchema,
} from './turn';

export type { Language, Theme, AgentPhase, ValidationBadge, ModelLabel, RiskLevel } from './turn';

// =============================================================================
// 공통 하위 타입 스키마 및 타입
// =============================================================================

export { CoordinateSchema, Box2DSchema, CurrencyAmountSchema } from './turn';

export type { Coordinate, Box2D, CurrencyAmount } from './turn';

// =============================================================================
// TurnInput 관련 스키마 및 타입
// =============================================================================

export { ClickInputSchema, ClientInfoSchema, EconomySnapshotSchema, TurnInputSchema } from './turn';

export type { ClickInput, ClientInfo, EconomySnapshot, TurnInput } from './turn';

// =============================================================================
// TurnOutput 관련 스키마 및 타입
// =============================================================================

export {
  // UI
  ActionCardSchema,
  SceneObjectSchema,
  ActionDeckSchema,
  UIOutputSchema,
  // World
  MemoryPinSchema,
  WorldRuleSchema,
  QuestSchema,
  WorldDeltaSchema,
  // Render
  ImageJobSchema,
  RenderOutputSchema,
  // Economy
  EconomyOutputSchema,
  // Safety
  SafetyOutputSchema,
  // Agent Console
  AgentConsoleSchema,
  // Main
  TurnOutputSchema,
} from './turn';

export type {
  // UI
  ActionCard,
  SceneObject,
  ActionDeck,
  UIOutput,
  // World
  MemoryPin,
  WorldRule,
  Quest,
  WorldDelta,
  // Render
  ImageJob,
  RenderOutput,
  // Economy
  EconomyOutput,
  // Safety
  SafetyOutput,
  // Agent Console
  AgentConsole,
  // Main
  TurnOutput,
} from './turn';

// =============================================================================
// 유틸리티 함수
// =============================================================================

export {
  createFallbackTurnOutput,
  safeParseTurnOutput,
  parseTurnInput,
  safeParseTurnInput,
} from './turn';

export type { TurnOutputParseResult, TurnInputSafeParseResult } from './turn';
</file>

<file path="frontend/src/schemas/turn.test.ts">
import { describe, it, expect } from 'vitest';
import {
  TurnInputSchema,
  TurnOutputSchema,
  safeParseTurnOutput,
  parseTurnInput,
  safeParseTurnInput,
  SCHEMA_VERSION,
} from './turn';

describe('Turn schemas', () => {
  describe('SCHEMA_VERSION', () => {
    it('should have correct version', () => {
      expect(SCHEMA_VERSION).toBe('1.0.0');
    });
  });

  describe('TurnInputSchema', () => {
    const validTurnInput = {
      language: 'ko-KR',
      text: '테스트 입력',
      client: {
        viewport_w: 1920,
        viewport_h: 1080,
        theme: 'dark',
      },
      economy_snapshot: {
        signal: 100,
        memory_shard: 5,
      },
    };

    it('should validate a valid TurnInput', () => {
      const result = TurnInputSchema.safeParse(validTurnInput);
      expect(result.success).toBe(true);
    });

    it('should fail on invalid language', () => {
      const result = TurnInputSchema.safeParse({
        ...validTurnInput,
        language: 'fr-FR',
      });
      expect(result.success).toBe(false);
    });

    it('should fail on negative economy values', () => {
      const result = TurnInputSchema.safeParse({
        ...validTurnInput,
        economy_snapshot: {
          signal: -1,
          memory_shard: 0,
        },
      });
      expect(result.success).toBe(false);
    });

    it('should fail on extra fields (strict)', () => {
      const result = TurnInputSchema.safeParse({
        ...validTurnInput,
        extra_field: 'not allowed',
      });
      expect(result.success).toBe(false);
    });

    it('should validate click input with bbox', () => {
      const result = TurnInputSchema.safeParse({
        ...validTurnInput,
        click: {
          object_id: 'door_01',
          box_2d: {
            ymin: 100,
            xmin: 100,
            ymax: 500,
            xmax: 500,
          },
        },
      });
      expect(result.success).toBe(true);
    });

    it('should fail on invalid bbox coordinates (out of range 0-1000)', () => {
      const result = TurnInputSchema.safeParse({
        ...validTurnInput,
        click: {
          object_id: 'door_01',
          box_2d: {
            ymin: -1,
            xmin: 0,
            ymax: 1001,
            xmax: 500,
          },
        },
      });
      expect(result.success).toBe(false);
    });

    it('should fail on non-positive viewport dimensions', () => {
      const result = TurnInputSchema.safeParse({
        ...validTurnInput,
        client: {
          viewport_w: 0,
          viewport_h: -100,
          theme: 'dark',
        },
      });
      expect(result.success).toBe(false);
    });

    it('should fail on non-integer coordinates', () => {
      const result = TurnInputSchema.safeParse({
        ...validTurnInput,
        click: {
          object_id: 'obj',
          box_2d: {
            ymin: 10.5,
            xmin: 20,
            ymax: 30,
            xmax: 40,
          },
        },
      });
      expect(result.success).toBe(false);
    });
  });

  describe('TurnOutputSchema', () => {
    const validTurnOutput = {
      language: 'ko-KR',
      narrative: '테스트 내러티브',
      economy: {
        cost: { signal: 5, memory_shard: 0 },
        balance_after: { signal: 95, memory_shard: 5 },
      },
      safety: {
        blocked: false,
      },
      agent_console: {
        current_phase: 'commit',
        badges: ['schema_ok', 'economy_ok'],
        repair_count: 0,
      },
    };

    it('should validate a valid TurnOutput', () => {
      const result = TurnOutputSchema.safeParse(validTurnOutput);
      expect(result.success).toBe(true);
    });

    it('should fail if required fields are missing', () => {
      const { narrative: _narrative, ...invalidOutput } = validTurnOutput;
      const result = TurnOutputSchema.safeParse(invalidOutput);
      expect(result.success).toBe(false);
    });

    it('should handle default values for optional fields', () => {
      const result = TurnOutputSchema.safeParse(validTurnOutput);
      if (result.success) {
        expect(result.data.ui).toBeDefined();
        expect(result.data.ui.action_deck.cards).toEqual([]);
        expect(result.data.world.rules_changed).toEqual([]);
      } else {
        throw new Error('Validation failed');
      }
    });

    it('should fail if there are too many action cards (max 10)', () => {
      const cards = Array.from({ length: 11 }, (_, i) => ({
        id: `card_${i}`,
        label: `Card ${i}`,
        cost: { signal: 0, memory_shard: 0 },
        risk: 'low',
      }));
      const result = TurnOutputSchema.safeParse({
        ...validTurnOutput,
        ui: {
          action_deck: { cards },
        },
      });
      expect(result.success).toBe(false);
    });

    it('should fail on negative repair_count', () => {
      const result = TurnOutputSchema.safeParse({
        ...validTurnOutput,
        agent_console: {
          current_phase: 'commit',
          badges: [],
          repair_count: -1,
        },
      });
      expect(result.success).toBe(false);
    });
  });

  describe('safeParseTurnOutput', () => {
    it('should return success for valid data', () => {
      const validTurnOutput = {
        language: 'en-US',
        narrative: 'Test narrative',
        economy: {
          cost: { signal: 0, memory_shard: 0 },
          balance_after: { signal: 100, memory_shard: 0 },
        },
        safety: { blocked: false },
      };
      const result = safeParseTurnOutput(validTurnOutput);
      expect(result.success).toBe(true);
      if (result.success) {
        expect(result.data.language).toBe('en-US');
      }
    });

    it('should return fallback for invalid data', () => {
      const invalidData = { some: 'garbage' };
      const result = safeParseTurnOutput(invalidData, 'ko-KR', 1);
      expect(result.success).toBe(false);
      if (!result.success) {
        expect(result.fallback).toBeDefined();
        expect(result.fallback.language).toBe('ko-KR');
        expect(result.fallback.agent_console.badges).toContain('schema_fail');
        expect(result.fallback.agent_console.repair_count).toBe(1);
      }
    });
  });

  describe('Input Parsing Utilities', () => {
    const validTurnInput = {
      language: 'ko-KR',
      text: '테스트 입력',
      client: {
        viewport_w: 1920,
        viewport_h: 1080,
        theme: 'dark',
      },
      economy_snapshot: {
        signal: 100,
        memory_shard: 5,
      },
    };

    describe('parseTurnInput', () => {
      it('should parse valid input', () => {
        const result = parseTurnInput(validTurnInput);
        expect(result.text).toBe('테스트 입력');
      });

      it('should throw error for invalid input', () => {
        expect(() => parseTurnInput({})).toThrow();
      });
    });

    describe('safeParseTurnInput', () => {
      it('should return success for valid input', () => {
        const result = safeParseTurnInput(validTurnInput);
        expect(result.success).toBe(true);
      });

      it('should return failure for invalid input', () => {
        const result = safeParseTurnInput({});
        expect(result.success).toBe(false);
      });
    });
  });
});
</file>

<file path="frontend/src/schemas/verify_runbook.ts">
import {
  TurnOutputSchema,
  safeParseTurnOutput,
  Box2DSchema,
  CurrencyAmountSchema,
  LanguageSchema,
  parseTurnInput,
} from './turn.js';

console.log('--- Scenario A: TurnOutput 스키마 검증 (정상 케이스) ---');
const validOutput = {
  language: 'ko-KR',
  narrative: '문이 삐걱거리며 열립니다...',
  economy: {
    cost: { signal: 5, memory_shard: 0 },
    balance_after: { signal: 95, memory_shard: 5 },
  },
  safety: { blocked: false, message: null },
};
const resultA = safeParseTurnOutput(validOutput);
console.log('Success:', resultA.success);
if (resultA.success) {
  console.log('Data (sample):', resultA.data.narrative);
}

console.log('\n--- Scenario B: TurnOutput 스키마 검증 실패 → 폴백 ---');
const invalidOutput = {
  language: 'ko-KR',
  narrative: '테스트',
};
// eslint-disable-next-line @typescript-eslint/no-explicit-any
const resultB = safeParseTurnOutput(invalidOutput as any);
console.log('Success:', resultB.success);
if (!resultB.success) {
  console.log('Error count:', resultB.error.issues.length);
  console.log('Fallback exists:', !!resultB.fallback);
  console.log(
    'Fallback badges has schema_fail:',
    resultB.fallback?.agent_console?.badges?.includes('schema_fail'),
  );
}

console.log('\n--- Scenario C: 좌표 범위 검증 (RULE-009) ---');
const validBox = { ymin: 100, xmin: 200, ymax: 300, xmax: 400 };
console.log('Valid box:', Box2DSchema.safeParse(validBox).success);
const invalidBox = { ymin: 100, xmin: 200, ymax: 1500, xmax: 400 };
console.log('Invalid box (1500):', Box2DSchema.safeParse(invalidBox).success);
const negativeBox = { ymin: -10, xmin: 200, ymax: 300, xmax: 400 };
console.log('Negative box:', Box2DSchema.safeParse(negativeBox).success);

console.log('\n--- Scenario D: 재화 인바리언트 검증 (RULE-005) ---');
const validCurrency = { signal: 100, memory_shard: 5 };
console.log('Valid currency:', CurrencyAmountSchema.safeParse(validCurrency).success);
const negativeCurrency = { signal: -10, memory_shard: 5 };
console.log('Negative signal:', CurrencyAmountSchema.safeParse(negativeCurrency).success);

console.log('\n--- Scenario E: 언어 정책 검증 (RULE-006) ---');
console.log('ko-KR:', LanguageSchema.safeParse('ko-KR').success);
console.log('en-US:', LanguageSchema.safeParse('en-US').success);
console.log('ja-JP (invalid):', LanguageSchema.safeParse('ja-JP').success);
console.log('ko (invalid format):', LanguageSchema.safeParse('ko').success);

console.log('\n--- Scenario F: TurnInput 검증 ---');
const validInput = {
  language: 'ko-KR',
  text: '문을 열어본다',
  client: {
    viewport_w: 1920,
    viewport_h: 1080,
    theme: 'dark',
  },
  economy_snapshot: {
    signal: 100,
    memory_shard: 5,
  },
};
try {
  // eslint-disable-next-line @typescript-eslint/no-explicit-any
  const parsed = parseTurnInput(validInput as any);
  console.log('Parsed successfully:', parsed.text);
} catch (e) {
  console.log('Parse error:', e);
}

console.log('\n--- Scenario G: Strict 모드 검증 ---');
const outputWithExtra = {
  language: 'ko-KR',
  narrative: '테스트',
  economy: {
    cost: { signal: 0, memory_shard: 0 },
    balance_after: { signal: 100, memory_shard: 5 },
  },
  safety: { blocked: false, message: null },
  unknown_field: '이 필드는 스키마에 없음',
};
const resultG = TurnOutputSchema.safeParse(outputWithExtra);
console.log('With extra field success:', resultG.success);
if (!resultG.success) {
  console.log('Error code:', resultG.error.issues[0].code);
}
</file>

<file path="frontend/src/setupTests.ts">
import '@testing-library/jest-dom';
</file>

<file path="frontend/src/stores/actionDeckStore.test.ts">
import { describe, it, expect, beforeEach } from 'vitest';
import { useActionDeckStore, filterAffordableCards } from './actionDeckStore';
import type { ActionCard } from '../schemas/turn';

describe('actionDeckStore', () => {
  beforeEach(() => {
    useActionDeckStore.getState().reset();
  });

  const mockCards: ActionCard[] = [
    {
      id: 'card-1',
      label: 'Card 1',
      description: null,
      cost: { signal: 10, memory_shard: 0 },
      cost_estimate: null,
      risk: 'low',
      hint: null,
      reward_hint: null,
      enabled: true,
      disabled_reason: null,
      is_alternative: false,
    },
    {
      id: 'card-2',
      label: 'Card 2',
      description: null,
      cost: { signal: 50, memory_shard: 1 },
      cost_estimate: null,
      risk: 'high',
      hint: null,
      reward_hint: null,
      enabled: true,
      disabled_reason: null,
      is_alternative: false,
    },
  ];

  it('sets cards and resets selected card', () => {
    const store = useActionDeckStore.getState();
    store.selectCard('some-id');
    expect(useActionDeckStore.getState().selectedCardId).toBe('some-id');

    store.setCards(mockCards);
    expect(useActionDeckStore.getState().cards).toEqual(mockCards);
    expect(useActionDeckStore.getState().selectedCardId).toBeNull();
  });

  it('marks a card as executed', () => {
    const store = useActionDeckStore.getState();
    store.selectCard('card-1');
    store.markExecuted('card-1');

    expect(useActionDeckStore.getState().lastExecutedCardId).toBe('card-1');
    expect(useActionDeckStore.getState().selectedCardId).toBeNull();
  });

  it('filters affordable cards correctly', () => {
    const balance = { signal: 20, memory_shard: 0 };
    const affordable = filterAffordableCards(mockCards, balance);

    expect(affordable).toHaveLength(1);
    expect(affordable[0].id).toBe('card-1');
  });

  it('respects server enabled flag in filterAffordableCards', () => {
    const disabledCards: ActionCard[] = [
      {
        ...mockCards[0],
        enabled: false,
      },
    ];
    const balance = { signal: 100, memory_shard: 100 };
    const affordable = filterAffordableCards(disabledCards, balance);

    expect(affordable).toHaveLength(0);
  });
});
</file>

<file path="frontend/src/stores/actionDeckStore.ts">
/**
 * Unknown World - Action Deck 상태 관리 (Zustand) (U-009[Mvp]).
 *
 * Action Deck의 카드 목록, 선택 상태, 잔액 기반 필터링을 관리합니다.
 *
 * 설계 원칙:
 *   - RULE-005: 잔액 부족 시 실행 불가 표시 + 대안 제공
 *   - RULE-008: 카드 클릭 → TurnInput 연결
 *
 * @module stores/actionDeckStore
 */

import { create } from 'zustand';
import type { ActionCard } from '../schemas/turn';

// =============================================================================
// 상태 타입 정의
// =============================================================================

/** Action Deck 상태 */
export interface ActionDeckState {
  /** 현재 카드 목록 (서버에서 받은 원본) */
  cards: ActionCard[];
  /** 선택된 카드 ID (클릭 후 실행 전까지) */
  selectedCardId: string | null;
  /** 마지막으로 실행된 카드 ID */
  lastExecutedCardId: string | null;
}

/** Action Deck 액션 */
export interface ActionDeckActions {
  /** 카드 목록 설정 (TurnOutput 수신 시) */
  setCards: (cards: ActionCard[]) => void;
  /** 카드 선택 */
  selectCard: (cardId: string | null) => void;
  /** 카드 실행 완료 기록 */
  markExecuted: (cardId: string) => void;
  /** 상태 초기화 */
  reset: () => void;
}

export type ActionDeckStore = ActionDeckState & ActionDeckActions;

// =============================================================================
// 초기 상태
// =============================================================================

function createInitialState(): ActionDeckState {
  return {
    cards: [],
    selectedCardId: null,
    lastExecutedCardId: null,
  };
}

// =============================================================================
// Zustand Store
// =============================================================================

/**
 * Action Deck 상태 스토어.
 *
 * @example
 * ```tsx
 * const { cards, setCards, selectCard } = useActionDeckStore();
 *
 * // TurnOutput 수신 시
 * setCards(turnOutput.ui.action_deck.cards);
 *
 * // 카드 클릭 시
 * selectCard(card.id);
 * ```
 */
export const useActionDeckStore = create<ActionDeckStore>((set) => ({
  // 초기 상태
  ...createInitialState(),

  // 액션
  setCards: (cards) => {
    set({
      cards,
      selectedCardId: null, // 새 카드 목록 수신 시 선택 초기화
    });
  },

  selectCard: (cardId) => {
    set({ selectedCardId: cardId });
  },

  markExecuted: (cardId) => {
    set({
      lastExecutedCardId: cardId,
      selectedCardId: null,
    });
  },

  reset: () => {
    set(createInitialState());
  },
}));

// =============================================================================
// 셀렉터 (성능 최적화용)
// =============================================================================

/** 카드 목록 셀렉터 */
export const selectCards = (state: ActionDeckStore) => state.cards;

/** 선택된 카드 ID 셀렉터 */
export const selectSelectedCardId = (state: ActionDeckStore) => state.selectedCardId;

/** 선택된 카드 객체 셀렉터 */
export const selectSelectedCard = (state: ActionDeckStore) =>
  state.cards.find((c) => c.id === state.selectedCardId) ?? null;

/** 마지막 실행 카드 ID 셀렉터 */
export const selectLastExecutedCardId = (state: ActionDeckStore) => state.lastExecutedCardId;

// =============================================================================
// 유틸리티 함수
// =============================================================================

/**
 * 잔액 기반으로 실행 가능한 카드만 필터링합니다.
 * (컴포넌트에서 사용하거나, 서버 응답이 enabled를 제공하지 않을 때 폴백으로 사용)
 *
 * @param cards - 원본 카드 목록
 * @param balance - 현재 잔액
 * @returns 실행 가능한 카드 목록
 */
export function filterAffordableCards(
  cards: ActionCard[],
  balance: { signal: number; memory_shard: number },
): ActionCard[] {
  return cards.filter((card) => {
    // 서버에서 이미 enabled=false로 판단했으면 제외
    if (!card.enabled) return false;

    // 비용 추정치가 있으면 최대 비용으로 판단
    const cost = card.cost_estimate?.max ?? card.cost;
    return balance.signal >= cost.signal && balance.memory_shard >= cost.memory_shard;
  });
}

/**
 * 대안 카드(is_alternative=true)만 필터링합니다.
 *
 * @param cards - 원본 카드 목록
 * @returns 대안 카드 목록
 */
export function filterAlternativeCards(cards: ActionCard[]): ActionCard[] {
  return cards.filter((card) => card.is_alternative);
}

/**
 * 일반 카드(is_alternative=false)만 필터링합니다.
 *
 * @param cards - 원본 카드 목록
 * @returns 일반 카드 목록
 */
export function filterRegularCards(cards: ActionCard[]): ActionCard[] {
  return cards.filter((card) => !card.is_alternative);
}
</file>

<file path="frontend/src/stores/economyStore.test.ts">
import { describe, it, expect, beforeEach } from 'vitest';
import {
  useEconomyStore,
  LEDGER_MAX_ENTRIES,
  canAffordCost,
  canAffordEstimate,
} from './economyStore';
import type { CurrencyAmount, CostEstimate } from '../schemas/turn';

describe('economyStore', () => {
  beforeEach(() => {
    useEconomyStore.getState().reset();
  });

  it('초기 상태가 올바르게 설정되어야 한다', () => {
    const state = useEconomyStore.getState();
    expect(state.ledger).toEqual([]);
    expect(state.costEstimate).toBeNull();
    expect(state.lastCost).toBeNull();
    expect(state.isBalanceLow).toBe(false);
    expect(state.lowBalanceThreshold).toBe(10);
  });

  it('addLedgerEntry가 엔트리를 추가하고 lastCost를 업데이트해야 한다', () => {
    const entry = {
      turnId: 1,
      reason: 'explore',
      cost: { signal: 5, memory_shard: 0 },
      balanceAfter: { signal: 95, memory_shard: 10 },
      modelLabel: 'FAST' as const,
    };

    useEconomyStore.getState().addLedgerEntry(entry);

    const state = useEconomyStore.getState();
    expect(state.ledger.length).toBe(1);
    expect(state.ledger[0].turnId).toBe(1);
    expect(state.ledger[0].timestamp).toBeDefined();
    expect(state.lastCost).toEqual({
      cost: entry.cost,
      balanceAfter: entry.balanceAfter,
      turnId: entry.turnId,
      modelLabel: entry.modelLabel,
    });
  });

  it(`Ledger는 최대 ${LEDGER_MAX_ENTRIES}개까지만 보관해야 한다`, () => {
    const store = useEconomyStore.getState();

    // 25개 엔트리 추가
    for (let i = 1; i <= 25; i++) {
      store.addLedgerEntry({
        turnId: i,
        reason: `test-${i}`,
        cost: { signal: 1, memory_shard: 0 },
        balanceAfter: { signal: 100 - i, memory_shard: 0 },
      });
    }

    const state = useEconomyStore.getState();
    expect(state.ledger.length).toBe(LEDGER_MAX_ENTRIES);
    // 최신순(내림차순) 정렬 확인
    expect(state.ledger[0].turnId).toBe(25);
    expect(state.ledger[LEDGER_MAX_ENTRIES - 1].turnId).toBe(25 - LEDGER_MAX_ENTRIES + 1);
  });

  it('setCostEstimateFromCard가 예상 비용을 올바르게 설정해야 한다', () => {
    const cost: CurrencyAmount = { signal: 5, memory_shard: 0 };
    const estimate: CostEstimate = {
      min: { signal: 3, memory_shard: 0 },
      max: { signal: 7, memory_shard: 0 },
    };

    // 1. cost_estimate가 제공된 경우
    useEconomyStore.getState().setCostEstimateFromCard(cost, estimate, 'action-1', 'Test Label');
    let state = useEconomyStore.getState();
    expect(state.costEstimate).toEqual({
      min: estimate.min,
      max: estimate.max,
      actionId: 'action-1',
      label: 'Test Label',
    });

    // 2. cost_estimate가 null인 경우 (기본 cost 사용)
    useEconomyStore.getState().setCostEstimateFromCard(cost, null, 'action-2');
    state = useEconomyStore.getState();
    expect(state.costEstimate).toEqual({
      min: cost,
      max: cost,
      actionId: 'action-2',
      label: undefined,
    });
  });

  it('updateBalanceLowStatus가 임계값에 따라 상태를 업데이트해야 한다', () => {
    const store = useEconomyStore.getState();

    // 기본 임계값 10
    store.updateBalanceLowStatus({ signal: 15, memory_shard: 0 });
    expect(useEconomyStore.getState().isBalanceLow).toBe(false);

    store.updateBalanceLowStatus({ signal: 5, memory_shard: 0 });
    expect(useEconomyStore.getState().isBalanceLow).toBe(true);

    // 임계값 변경 테스트
    store.setLowBalanceThreshold(20);
    store.updateBalanceLowStatus({ signal: 15, memory_shard: 0 });
    expect(useEconomyStore.getState().isBalanceLow).toBe(true);
  });

  describe('Utility: canAffordCost & canAffordEstimate', () => {
    const balance: CurrencyAmount = { signal: 10, memory_shard: 2 };

    it('canAffordCost: 잔액이 충분할 때', () => {
      const cost: CurrencyAmount = { signal: 5, memory_shard: 1 };
      const result = canAffordCost(balance, cost);
      expect(result.affordable).toBe(true);
      expect(result.shortfall).toEqual({ signal: 0, memory_shard: 0 });
    });

    it('canAffordCost: 잔액이 부족할 때 (Signal)', () => {
      const cost: CurrencyAmount = { signal: 15, memory_shard: 1 };
      const result = canAffordCost(balance, cost);
      expect(result.affordable).toBe(false);
      expect(result.shortfall.signal).toBe(5);
    });

    it('canAffordCost: 잔액이 부족할 때 (Shard)', () => {
      const cost: CurrencyAmount = { signal: 5, memory_shard: 5 };
      const result = canAffordCost(balance, cost);
      expect(result.affordable).toBe(false);
      expect(result.shortfall.memory_shard).toBe(3);
    });

    it('canAffordEstimate: 최대 예상 비용 기준으로 체크해야 한다', () => {
      const estimate = {
        min: { signal: 5, memory_shard: 0 },
        max: { signal: 15, memory_shard: 0 },
      };
      // Signal 10 < Max 15 이므로 감당 불가
      const result = canAffordEstimate(balance, estimate);
      expect(result.affordable).toBe(false);
      expect(result.shortfall.signal).toBe(5);
    });
  });
});
</file>

<file path="frontend/src/stores/economyStore.ts">
/**
 * Unknown World - Economy 상태 관리 (Zustand) (U-014[Mvp]).
 *
 * Signal/Memory Shard 재화 HUD와 턴별 비용/잔액 변화를
 * **원장(ledger)**으로 추적하여 "비용/지연을 게임 메커닉"으로 UX에 반영합니다.
 *
 * 설계 원칙:
 *   - RULE-005: Economy 인바리언트 (잔액 음수 금지, 예상 비용 사전 표시)
 *   - RULE-008: 비용/모델 선택 이유는 라벨(FAST/QUALITY/REF)로만 설명
 *   - Q1 결정: Option A - 최근 N턴만 보관 (UI/메모리 절감)
 *
 * @module stores/economyStore
 */

import { create } from 'zustand';
import type { CurrencyAmount, ModelLabel, CostEstimate } from '../schemas/turn';

// =============================================================================
// 상수 정의
// =============================================================================

/** 최근 N턴의 ledger만 보관 (Q1: Option A) */
export const LEDGER_MAX_ENTRIES = 20;

// =============================================================================
// 타입 정의
// =============================================================================

/**
 * 원장(Ledger) 엔트리.
 * 각 턴에서 발생한 비용과 잔액 변화를 기록합니다.
 */
export interface LedgerEntry {
  /** 턴 ID (턴 카운트) */
  turnId: number;
  /** 액션 ID (선택된 카드 ID, 선택사항) */
  actionId?: string;
  /** 비용 사유 (예: "탐색", "이미지 생성") */
  reason: string;
  /** 소비된 비용 */
  cost: CurrencyAmount;
  /** 소비 후 잔액 */
  balanceAfter: CurrencyAmount;
  /** 모델 라벨 (FAST/QUALITY/CHEAP/REF) */
  modelLabel?: ModelLabel;
  /** 기록 시간 */
  timestamp: number;
}

/**
 * 예상 비용 상태.
 * 현재 선택된 액션의 예상 비용을 추적합니다.
 */
export interface CostEstimateState {
  /** 최소 예상 비용 */
  min: CurrencyAmount;
  /** 최대 예상 비용 */
  max: CurrencyAmount;
  /** 예상 비용을 계산한 액션 ID */
  actionId?: string;
  /** 예상 비용 라벨/설명 */
  label?: string;
}

/**
 * 마지막 확정 비용 상태.
 * 가장 최근 턴에서 확정된 비용 정보입니다.
 */
export interface LastCostState {
  /** 확정된 비용 */
  cost: CurrencyAmount;
  /** 확정 후 잔액 */
  balanceAfter: CurrencyAmount;
  /** 턴 ID */
  turnId: number;
  /** 모델 라벨 */
  modelLabel?: ModelLabel;
}

/** Economy Store 상태 */
export interface EconomyStoreState {
  /** 원장 (최근 N개 엔트리, 최신순) */
  ledger: LedgerEntry[];
  /** 현재 예상 비용 (선택한 액션 기반) */
  costEstimate: CostEstimateState | null;
  /** 마지막 확정 비용 */
  lastCost: LastCostState | null;
  /** 잔액 부족 경고 여부 */
  isBalanceLow: boolean;
  /** 잔액 부족 임계값 (Signal 기준) */
  lowBalanceThreshold: number;
}

/** Economy Store 액션 */
export interface EconomyStoreActions {
  /**
   * 턴 완료 시 원장에 엔트리를 추가합니다.
   */
  addLedgerEntry: (entry: Omit<LedgerEntry, 'timestamp'>) => void;

  /**
   * 예상 비용을 설정합니다 (카드 선택/호버 시).
   */
  setCostEstimate: (estimate: CostEstimateState | null) => void;

  /**
   * 카드의 비용 정보로 예상 비용을 설정합니다.
   */
  setCostEstimateFromCard: (
    cost: CurrencyAmount,
    costEstimate: CostEstimate | null,
    actionId: string,
    label?: string,
  ) => void;

  /**
   * 마지막 확정 비용을 설정합니다 (TurnOutput 반영 시).
   */
  setLastCost: (lastCost: LastCostState) => void;

  /**
   * 잔액 부족 상태를 업데이트합니다.
   */
  updateBalanceLowStatus: (currentBalance: CurrencyAmount) => void;

  /**
   * 잔액 부족 임계값을 설정합니다.
   */
  setLowBalanceThreshold: (threshold: number) => void;

  /**
   * 원장을 초기화합니다.
   */
  clearLedger: () => void;

  /**
   * 전체 상태를 초기화합니다.
   */
  reset: () => void;
}

export type EconomyStore = EconomyStoreState & EconomyStoreActions;

// =============================================================================
// 초기 상태
// =============================================================================

function createInitialState(): EconomyStoreState {
  return {
    ledger: [],
    costEstimate: null,
    lastCost: null,
    isBalanceLow: false,
    lowBalanceThreshold: 10, // Signal 10 미만이면 경고
  };
}

// =============================================================================
// Zustand Store
// =============================================================================

/**
 * Economy 상태 스토어.
 *
 * 턴별 비용/잔액 변화를 원장(ledger)으로 추적하고,
 * 예상 비용과 확정 비용을 UI에 제공합니다.
 *
 * @example
 * ```tsx
 * // 예상 비용 설정 (카드 호버 시)
 * const setCostEstimateFromCard = useEconomyStore(s => s.setCostEstimateFromCard);
 * setCostEstimateFromCard(card.cost, card.cost_estimate, card.id, card.label);
 *
 * // 턴 완료 시 원장 기록
 * const addLedgerEntry = useEconomyStore(s => s.addLedgerEntry);
 * addLedgerEntry({
 *   turnId: turnCount,
 *   reason: 'explore',
 *   cost: turnOutput.economy.cost,
 *   balanceAfter: turnOutput.economy.balance_after,
 * });
 * ```
 */
export const useEconomyStore = create<EconomyStore>((set, get) => ({
  // 초기 상태
  ...createInitialState(),

  // 액션

  addLedgerEntry: (entry) => {
    const timestamp = Date.now();
    const newEntry: LedgerEntry = { ...entry, timestamp };

    set((state) => {
      // 최신순으로 추가하고 최대 개수 유지 (Q1: Option A)
      const updatedLedger = [newEntry, ...state.ledger].slice(0, LEDGER_MAX_ENTRIES);

      return {
        ledger: updatedLedger,
        lastCost: {
          cost: entry.cost,
          balanceAfter: entry.balanceAfter,
          turnId: entry.turnId,
          modelLabel: entry.modelLabel,
        },
        // 턴 완료 후 예상 비용 초기화
        costEstimate: null,
      };
    });
  },

  setCostEstimate: (estimate) => {
    set({ costEstimate: estimate });
  },

  setCostEstimateFromCard: (cost, costEstimate, actionId, label) => {
    if (costEstimate) {
      set({
        costEstimate: {
          min: costEstimate.min,
          max: costEstimate.max,
          actionId,
          label,
        },
      });
    } else {
      // cost_estimate가 없으면 기본 cost를 min/max로 사용
      set({
        costEstimate: {
          min: cost,
          max: cost,
          actionId,
          label,
        },
      });
    }
  },

  setLastCost: (lastCost) => {
    set({ lastCost });
  },

  updateBalanceLowStatus: (currentBalance) => {
    const { lowBalanceThreshold } = get();
    const isLow = currentBalance.signal < lowBalanceThreshold;
    set({ isBalanceLow: isLow });
  },

  setLowBalanceThreshold: (threshold) => {
    set({ lowBalanceThreshold: threshold });
  },

  clearLedger: () => {
    set({ ledger: [], lastCost: null });
  },

  reset: () => {
    set(createInitialState());
  },
}));

// =============================================================================
// 셀렉터 (성능 최적화용)
// =============================================================================

/** 원장 셀렉터 */
export const selectLedger = (state: EconomyStore) => state.ledger;

/** 예상 비용 셀렉터 */
export const selectCostEstimate = (state: EconomyStore) => state.costEstimate;

/** 마지막 확정 비용 셀렉터 */
export const selectLastCost = (state: EconomyStore) => state.lastCost;

/** 잔액 부족 상태 셀렉터 */
export const selectIsBalanceLow = (state: EconomyStore) => state.isBalanceLow;

/** 최근 N개 원장 엔트리 셀렉터 */
export const selectRecentLedger =
  (count: number) =>
  (state: EconomyStore): LedgerEntry[] =>
    state.ledger.slice(0, count);

/** 총 소비 비용 계산 셀렉터 (현재 세션) */
export const selectTotalSpent = (state: EconomyStore): CurrencyAmount => {
  return state.ledger.reduce(
    (acc, entry) => ({
      signal: acc.signal + entry.cost.signal,
      memory_shard: acc.memory_shard + entry.cost.memory_shard,
    }),
    { signal: 0, memory_shard: 0 },
  );
};

// =============================================================================
// 유틸리티 함수
// =============================================================================

/**
 * 현재 잔액으로 예상 비용을 감당할 수 있는지 확인합니다.
 * RULE-005: 잔액 부족 시 실행 강행이 아니라 대체 행동을 제안.
 */
export function canAffordCost(
  balance: CurrencyAmount,
  cost: CurrencyAmount,
): { affordable: boolean; shortfall: CurrencyAmount } {
  const signalShortfall = Math.max(0, cost.signal - balance.signal);
  const shardShortfall = Math.max(0, cost.memory_shard - balance.memory_shard);

  return {
    affordable: signalShortfall === 0 && shardShortfall === 0,
    shortfall: { signal: signalShortfall, memory_shard: shardShortfall },
  };
}

/**
 * 예상 비용의 최대값으로 감당 가능 여부를 확인합니다.
 */
export function canAffordEstimate(
  balance: CurrencyAmount,
  estimate: CostEstimateState,
): { affordable: boolean; shortfall: CurrencyAmount } {
  return canAffordCost(balance, estimate.max);
}
</file>

<file path="frontend/src/stores/inventoryStore.test.ts">
import { describe, it, expect, beforeEach } from 'vitest';
import { useInventoryStore, parseInventoryAdded } from './inventoryStore';

describe('inventoryStore', () => {
  beforeEach(() => {
    useInventoryStore.getState().reset();
  });

  it('초기 상태는 비어 있어야 한다', () => {
    const state = useInventoryStore.getState();
    expect(state.items).toEqual([]);
    expect(state.draggingItemId).toBeNull();
    expect(state.selectedItemId).toBeNull();
  });

  it('addItems: 새 아이템을 추가할 수 있어야 한다', () => {
    const { addItems } = useInventoryStore.getState();
    const newItem = { id: 'item1', name: 'Item 1', quantity: 1 };

    addItems([newItem]);

    const state = useInventoryStore.getState();
    expect(state.items).toHaveLength(1);
    expect(state.items[0]).toEqual(newItem);
  });

  it('addItems: 중복된 ID의 아이템 추가 시 수량이 증가해야 한다', () => {
    const { addItems } = useInventoryStore.getState();
    const item1 = { id: 'item1', name: 'Item 1', quantity: 1 };

    addItems([item1]);
    addItems([{ id: 'item1', name: 'Item 1', quantity: 2 }]);

    const state = useInventoryStore.getState();
    expect(state.items).toHaveLength(1);
    expect(state.items[0].quantity).toBe(3);
  });

  it('removeItems: 아이템을 제거할 수 있어야 한다', () => {
    const { addItems, removeItems } = useInventoryStore.getState();
    addItems([
      { id: 'item1', name: 'Item 1', quantity: 1 },
      { id: 'item2', name: 'Item 2', quantity: 1 },
    ]);

    removeItems(['item1']);

    const state = useInventoryStore.getState();
    expect(state.items).toHaveLength(1);
    expect(state.items[0].id).toBe('item2');
  });

  it('removeItems: 제거된 아이템이 선택/드래그 중이면 초기화해야 한다', () => {
    const { addItems, removeItems, selectItem, startDrag } = useInventoryStore.getState();
    addItems([{ id: 'item1', name: 'Item 1', quantity: 1 }]);

    selectItem('item1');
    startDrag('item1');

    removeItems(['item1']);

    const state = useInventoryStore.getState();
    expect(state.selectedItemId).toBeNull();
    expect(state.draggingItemId).toBeNull();
  });

  it('startDrag/endDrag: 드래그 상태를 관리해야 한다', () => {
    const { startDrag, endDrag } = useInventoryStore.getState();

    startDrag('item1');
    expect(useInventoryStore.getState().draggingItemId).toBe('item1');

    endDrag();
    expect(useInventoryStore.getState().draggingItemId).toBeNull();
  });

  it('parseInventoryAdded: 문자열 ID 목록을 InventoryItem 배열로 변환해야 한다', () => {
    const addedIds = ['item-a', 'item-b'];
    const parsed = parseInventoryAdded(addedIds);

    expect(parsed).toHaveLength(2);
    expect(parsed[0]).toEqual({ id: 'item-a', name: 'item-a', quantity: 1 });
    expect(parsed[1]).toEqual({ id: 'item-b', name: 'item-b', quantity: 1 });
  });
});
</file>

<file path="frontend/src/stores/inventoryStore.ts">
/**
 * Unknown World - Inventory 상태 관리 (Zustand) (U-011[Mvp]).
 *
 * Inventory의 아이템 목록, 드래그 상태, 선택 상태를 관리합니다.
 *
 * 설계 원칙:
 *   - RULE-002: Inventory는 게임 UI로 상시 노출
 *   - U-006 의존: WorldDelta.inventory_added / inventory_removed 필드 연동
 *   - U-012 연결: 드래그 데이터에 item_id를 실어 드롭 타겟(핫스팟)에 전달
 *
 * @module stores/inventoryStore
 */

import { create } from 'zustand';

// =============================================================================
// 타입 정의
// =============================================================================

/**
 * 인벤토리 아이템.
 * MVP에서는 최소 필드만 정의합니다.
 */
export interface InventoryItem {
  /** 아이템 고유 ID */
  id: string;
  /** 아이템 이름 (표시용) */
  name: string;
  /** 아이템 설명 (선택) */
  description?: string;
  /** 아이템 아이콘 URL 또는 이모지 (선택) */
  icon?: string;
  /** 아이템 수량 (기본값: 1) */
  quantity: number;
}

/** Inventory 상태 */
export interface InventoryState {
  /** 현재 아이템 목록 */
  items: InventoryItem[];
  /** 현재 드래그 중인 아이템 ID (null이면 드래그 중 아님) */
  draggingItemId: string | null;
  /** 선택된 아이템 ID (클릭 선택, 드래그와 별개) */
  selectedItemId: string | null;
}

/** Inventory 액션 */
export interface InventoryActions {
  /** 아이템 목록 설정 (전체 교체) */
  setItems: (items: InventoryItem[]) => void;
  /** 아이템 추가 (중복 ID면 수량 증가) */
  addItems: (items: InventoryItem[]) => void;
  /** 아이템 제거 (ID 목록) */
  removeItems: (itemIds: string[]) => void;
  /** 드래그 시작 */
  startDrag: (itemId: string) => void;
  /** 드래그 종료 */
  endDrag: () => void;
  /** 아이템 선택 */
  selectItem: (itemId: string | null) => void;
  /** 상태 초기화 */
  reset: () => void;
}

export type InventoryStore = InventoryState & InventoryActions;

// =============================================================================
// 초기 상태
// =============================================================================

function createInitialState(): InventoryState {
  return {
    items: [],
    draggingItemId: null,
    selectedItemId: null,
  };
}

// =============================================================================
// Zustand Store
// =============================================================================

/**
 * Inventory 상태 스토어.
 *
 * @example
 * ```tsx
 * const { items, addItems, removeItems, startDrag, endDrag } = useInventoryStore();
 *
 * // TurnOutput.world.inventory_added 수신 시
 * addItems(inventoryAddedItems);
 *
 * // TurnOutput.world.inventory_removed 수신 시
 * removeItems(inventoryRemovedIds);
 *
 * // dnd-kit onDragStart
 * startDrag(itemId);
 *
 * // dnd-kit onDragEnd
 * endDrag();
 * ```
 */
export const useInventoryStore = create<InventoryStore>((set) => ({
  // 초기 상태
  ...createInitialState(),

  // 액션
  setItems: (items) => {
    set({
      items,
      draggingItemId: null,
      selectedItemId: null,
    });
  },

  addItems: (newItems) => {
    set((state) => {
      const itemsMap = new Map(state.items.map((item) => [item.id, item]));

      for (const newItem of newItems) {
        const existing = itemsMap.get(newItem.id);
        if (existing) {
          // 기존 아이템이면 수량 증가
          itemsMap.set(newItem.id, {
            ...existing,
            quantity: existing.quantity + newItem.quantity,
          });
        } else {
          // 새 아이템 추가
          itemsMap.set(newItem.id, newItem);
        }
      }

      return { items: Array.from(itemsMap.values()) };
    });
  },

  removeItems: (itemIds) => {
    set((state) => {
      const removeSet = new Set(itemIds);
      return {
        items: state.items.filter((item) => !removeSet.has(item.id)),
        // 제거된 아이템이 선택/드래그 중이었다면 초기화
        selectedItemId: removeSet.has(state.selectedItemId ?? '') ? null : state.selectedItemId,
        draggingItemId: removeSet.has(state.draggingItemId ?? '') ? null : state.draggingItemId,
      };
    });
  },

  startDrag: (itemId) => {
    set({ draggingItemId: itemId });
  },

  endDrag: () => {
    set({ draggingItemId: null });
  },

  selectItem: (itemId) => {
    set({ selectedItemId: itemId });
  },

  reset: () => {
    set(createInitialState());
  },
}));

// =============================================================================
// 셀렉터 (성능 최적화용)
// =============================================================================

/** 아이템 목록 셀렉터 */
export const selectItems = (state: InventoryStore) => state.items;

/** 드래그 중인 아이템 ID 셀렉터 */
export const selectDraggingItemId = (state: InventoryStore) => state.draggingItemId;

/** 드래그 중인 아이템 객체 셀렉터 */
export const selectDraggingItem = (state: InventoryStore) =>
  state.items.find((item) => item.id === state.draggingItemId) ?? null;

/** 선택된 아이템 ID 셀렉터 */
export const selectSelectedItemId = (state: InventoryStore) => state.selectedItemId;

/** 선택된 아이템 객체 셀렉터 */
export const selectSelectedItem = (state: InventoryStore) =>
  state.items.find((item) => item.id === state.selectedItemId) ?? null;

/** 아이템 개수 셀렉터 */
export const selectItemCount = (state: InventoryStore) => state.items.length;

// =============================================================================
// 유틸리티 함수
// =============================================================================

/**
 * 서버 응답(inventory_added 문자열 배열)을 InventoryItem 배열로 변환합니다.
 * MVP에서는 문자열 ID를 기본 아이템으로 변환합니다.
 *
 * @param addedIds - 추가된 아이템 ID 목록 (서버 응답)
 * @returns InventoryItem 배열
 */
export function parseInventoryAdded(addedIds: string[]): InventoryItem[] {
  return addedIds.map((id) => ({
    id,
    name: id, // MVP: ID를 이름으로 사용
    quantity: 1,
  }));
}

/**
 * 아이템 ID로 아이템을 찾습니다.
 *
 * @param items - 아이템 목록
 * @param itemId - 찾을 아이템 ID
 * @returns 아이템 또는 undefined
 */
export function findItemById(items: InventoryItem[], itemId: string): InventoryItem | undefined {
  return items.find((item) => item.id === itemId);
}
</file>

<file path="frontend/src/stores/worldStore.test.ts">
import { describe, it, expect, beforeEach, vi } from 'vitest';
import { useWorldStore } from './worldStore';
import type { TurnOutput } from '../schemas/turn';

// 하위 스토어 모킹 (순환 import 방지 로직 대응)
vi.mock('./actionDeckStore', () => ({
  useActionDeckStore: {
    getState: () => ({
      setCards: vi.fn(),
    }),
  },
}));

vi.mock('./inventoryStore', () => ({
  useInventoryStore: {
    getState: () => ({
      addItems: vi.fn(),
      removeItems: vi.fn(),
    }),
  },
  parseInventoryAdded: (items: unknown) => items,
}));

describe('worldStore (U-013: Quest + Rules)', () => {
  beforeEach(() => {
    useWorldStore.getState().reset();
  });

  it('초기 상태가 올바라야 한다', () => {
    const state = useWorldStore.getState();
    expect(state.quests).toEqual([]);
    expect(state.activeRules).toEqual([]);
    expect(state.mutationTimeline).toEqual([]);
  });

  it('applyTurnOutput을 통해 새 퀘스트가 추가되어야 한다', () => {
    const mockOutput: Partial<TurnOutput> = {
      narrative: '새 퀘스트 발생',
      economy: {
        cost: { signal: 0, memory_shard: 0 },
        balance_after: { signal: 100, memory_shard: 5 },
      },
      ui: {
        scene: { image_url: '', alt_text: '' },
        action_deck: { cards: [] },
        objects: [],
      },
      world: {
        inventory_added: [],
        inventory_removed: [],
        quests_updated: [
          {
            id: 'q1',
            label: '첫 번째 임무',
            is_completed: false,
          },
        ],
        rules_changed: [],
        relationships_changed: [],
        memory_pins: [],
      },
      safety: { blocked: false, message: null },
    };

    useWorldStore.getState().applyTurnOutput(mockOutput as TurnOutput);

    const state = useWorldStore.getState();
    expect(state.quests).toHaveLength(1);
    expect(state.quests[0].id).toBe('q1');
    expect(state.quests[0].is_completed).toBe(false);
  });

  it('기존 퀘스트가 업데이트(완료)되어야 한다', () => {
    // 1. 초기 퀘스트 추가
    const initialState: Partial<TurnOutput> = {
      narrative: '초기화',
      economy: {
        cost: { signal: 0, memory_shard: 0 },
        balance_after: { signal: 100, memory_shard: 5 },
      },
      ui: {
        scene: { image_url: '', alt_text: '' },
        action_deck: { cards: [] },
        objects: [],
      },
      world: {
        inventory_added: [],
        inventory_removed: [],
        quests_updated: [{ id: 'q1', label: '임무', is_completed: false }],
        rules_changed: [],
        relationships_changed: [],
        memory_pins: [],
      },
      safety: { blocked: false, message: null },
    };
    useWorldStore.getState().applyTurnOutput(initialState as TurnOutput);

    // 2. 퀘스트 완료 업데이트
    const updateOutput: Partial<TurnOutput> = {
      narrative: '임무 완료!',
      economy: {
        cost: { signal: 0, memory_shard: 0 },
        balance_after: { signal: 100, memory_shard: 5 },
      },
      ui: {
        scene: { image_url: '', alt_text: '' },
        action_deck: { cards: [] },
        objects: [],
      },
      world: {
        inventory_added: [],
        inventory_removed: [],
        quests_updated: [{ id: 'q1', label: '임무', is_completed: true }],
        rules_changed: [],
        relationships_changed: [],
        memory_pins: [],
      },
      safety: { blocked: false, message: null },
    };
    useWorldStore.getState().applyTurnOutput(updateOutput as TurnOutput);

    const state = useWorldStore.getState();
    expect(state.quests).toHaveLength(1);
    expect(state.quests[0].is_completed).toBe(true);
  });

  it('새 규칙이 추가되고 타임라인에 기록되어야 한다', () => {
    const mockOutput: Partial<TurnOutput> = {
      narrative: '새 규칙 적용',
      economy: {
        cost: { signal: 0, memory_shard: 0 },
        balance_after: { signal: 100, memory_shard: 5 },
      },
      ui: {
        scene: { image_url: '', alt_text: '' },
        action_deck: { cards: [] },
        objects: [],
      },
      world: {
        inventory_added: [],
        inventory_removed: [],
        quests_updated: [],
        rules_changed: [
          {
            id: 'rule1',
            label: '중력 강화',
            description: '점프 높이가 절반으로 감소합니다.',
          },
        ],
        relationships_changed: [],
        memory_pins: [],
      },
      safety: { blocked: false, message: null },
    };

    useWorldStore.getState().applyTurnOutput(mockOutput as TurnOutput);

    const state = useWorldStore.getState();
    expect(state.activeRules).toHaveLength(1);
    expect(state.activeRules[0].id).toBe('rule1');

    expect(state.mutationTimeline).toHaveLength(1);
    expect(state.mutationTimeline[0].ruleId).toBe('rule1');
    expect(state.mutationTimeline[0].type).toBe('added');
  });

  it('기존 규칙 수정 시 타임라인에 기록되어야 한다', () => {
    // 1. 초기 규칙 추가
    const initialState: Partial<TurnOutput> = {
      narrative: '초기화',
      economy: {
        cost: { signal: 0, memory_shard: 0 },
        balance_after: { signal: 100, memory_shard: 5 },
      },
      ui: {
        scene: { image_url: '', alt_text: '' },
        action_deck: { cards: [] },
        objects: [],
      },
      world: {
        inventory_added: [],
        inventory_removed: [],
        quests_updated: [],
        rules_changed: [{ id: 'rule1', label: '규칙', description: '기존' }],
        relationships_changed: [],
        memory_pins: [],
      },
      safety: { blocked: false, message: null },
    };
    useWorldStore.getState().applyTurnOutput(initialState as TurnOutput);

    // 2. 규칙 수정
    const updateOutput: Partial<TurnOutput> = {
      narrative: '규칙 수정',
      economy: {
        cost: { signal: 0, memory_shard: 0 },
        balance_after: { signal: 100, memory_shard: 5 },
      },
      ui: {
        scene: { image_url: '', alt_text: '' },
        action_deck: { cards: [] },
        objects: [],
      },
      world: {
        inventory_added: [],
        inventory_removed: [],
        quests_updated: [],
        rules_changed: [{ id: 'rule1', label: '규칙', description: '수정됨' }],
        relationships_changed: [],
        memory_pins: [],
      },
      safety: { blocked: false, message: null },
    };
    useWorldStore.getState().applyTurnOutput(updateOutput as TurnOutput);

    const state = useWorldStore.getState();
    expect(state.activeRules[0].description).toBe('수정됨');
    expect(state.mutationTimeline).toHaveLength(2);
    expect(state.mutationTimeline[0].type).toBe('modified');
  });
});
</file>

<file path="frontend/src/types/scene.ts">
/**
 * Scene Canvas 관련 타입 정의 (U-031: Placeholder Pack)
 */

/**
 * Scene Canvas 상태 타입
 * - default: 기본 상태 (장면 이미지 없음)
 * - loading: 데이터 로딩 중
 * - offline: 오프라인/연결 끊김
 * - blocked: 안전/정책 차단
 * - low_signal: 재화/신호 부족
 * - scene: 정상 장면 표시 (이미지 URL 포함)
 */
export type SceneCanvasStatus =
  | 'default'
  | 'loading'
  | 'offline'
  | 'blocked'
  | 'low_signal'
  | 'scene';

/**
 * Scene Canvas 상태 데이터 구조
 */
export interface SceneCanvasState {
  status: SceneCanvasStatus;
  imageUrl?: string;
  message?: string;
}

/**
 * 상태별 placeholder 정보 구조
 */
export interface PlaceholderInfo {
  imagePath: string;
  fallbackEmoji: string;
  labelKey: string;
}
</file>

<file path="frontend/src/utils/box2d.test.ts">
import { describe, it, expect } from 'vitest';
import {
  box2dToPixel,
  pixelToBox2d,
  isValidBox2D,
  box2dArea,
  box2dCenter,
  NORMALIZED_MAX,
} from './box2d';
import type { Box2D } from '../schemas/turn';

describe('box2d utils', () => {
  const canvas = { width: 800, height: 600 };

  describe('box2dToPixel', () => {
    it('should correctly convert normalized coordinates to pixels', () => {
      const normalized: Box2D = { ymin: 100, xmin: 200, ymax: 500, xmax: 800 };
      const pixel = box2dToPixel(normalized, canvas);

      // top = 100 * (600 / 1000) = 60
      // left = 200 * (800 / 1000) = 160
      // bottom = 500 * (600 / 1000) = 300
      // right = 800 * (800 / 1000) = 640
      // width = 640 - 160 = 480
      // height = 300 - 60 = 240

      expect(pixel).toEqual({
        top: 60,
        left: 160,
        width: 480,
        height: 240,
      });
    });

    it('should handle full canvas size', () => {
      const normalized: Box2D = { ymin: 0, xmin: 0, ymax: 1000, xmax: 1000 };
      const pixel = box2dToPixel(normalized, canvas);

      expect(pixel).toEqual({
        top: 0,
        left: 0,
        width: 800,
        height: 600,
      });
    });
  });

  describe('pixelToBox2d', () => {
    it('should correctly convert pixels back to normalized coordinates', () => {
      const pixel = { top: 60, left: 160, width: 480, height: 240 };
      const normalized = pixelToBox2d(pixel, canvas);

      expect(normalized).toEqual({
        ymin: 100,
        xmin: 200,
        ymax: 500,
        xmax: 800,
      });
    });

    it('should round and clamp values', () => {
      const pixel = { top: -10, left: -20, width: 900, height: 700 };
      const normalized = pixelToBox2d(pixel, canvas);

      expect(normalized.ymin).toBe(0);
      expect(normalized.xmin).toBe(0);
      expect(normalized.ymax).toBe(NORMALIZED_MAX);
      expect(normalized.xmax).toBe(NORMALIZED_MAX);
    });
  });

  describe('isValidBox2D', () => {
    it('should return true for valid boxes', () => {
      expect(isValidBox2D({ ymin: 100, xmin: 100, ymax: 200, xmax: 200 })).toBe(true);
      expect(isValidBox2D({ ymin: 0, xmin: 0, ymax: 1000, xmax: 1000 })).toBe(true);
    });

    it('should return false for out of range values', () => {
      expect(isValidBox2D({ ymin: -1, xmin: 0, ymax: 100, xmax: 100 })).toBe(false);
      expect(isValidBox2D({ ymin: 0, xmin: 0, ymax: 1001, xmax: 100 })).toBe(false);
    });

    it('should return false for invalid order', () => {
      expect(isValidBox2D({ ymin: 500, xmin: 100, ymax: 400, xmax: 200 })).toBe(false);
      expect(isValidBox2D({ ymin: 100, xmin: 500, ymax: 200, xmax: 400 })).toBe(false);
    });
  });

  describe('box2dArea', () => {
    it('should calculate area correctly', () => {
      const box = { ymin: 100, xmin: 100, ymax: 200, xmax: 300 };
      expect(box2dArea(box)).toBe(20000); // (200-100) * (300-100) = 100 * 200
    });
  });

  describe('box2dCenter', () => {
    it('should calculate center correctly', () => {
      const box = { ymin: 100, xmin: 100, ymax: 300, xmax: 500 };
      expect(box2dCenter(box)).toEqual({ x: 300, y: 200 });
    });
  });
});
</file>

<file path="frontend/src/utils/box2d.ts">
/**
 * Unknown World - Box2D 좌표 변환 유틸리티
 *
 * RULE-009 준수: 좌표 규약 (0~1000 정규화, bbox=[ymin,xmin,ymax,xmax])
 * - 서버/세이브에는 항상 box_2d(0~1000)를 유지
 * - 렌더에서만 viewport 크기(canvasW/H)에 맞춰 px로 변환
 *
 * @module utils/box2d
 */

import type { Box2D } from '../schemas/turn';

// =============================================================================
// 상수 정의
// =============================================================================

/**
 * 정규화 좌표계 최댓값 (0~1000).
 * RULE-009: 좌표 규약
 */
export const NORMALIZED_MAX = 1000;

// =============================================================================
// 타입 정의
// =============================================================================

/**
 * 픽셀 단위 바운딩 박스.
 * 렌더링용으로만 사용됩니다.
 */
export interface Box2DPixel {
  /** Y 최소값 (상단, 픽셀) */
  top: number;
  /** X 최소값 (좌측, 픽셀) */
  left: number;
  /** 너비 (픽셀) */
  width: number;
  /** 높이 (픽셀) */
  height: number;
}

/**
 * 캔버스 크기 정보.
 */
export interface CanvasSize {
  /** 캔버스 너비 (픽셀) */
  width: number;
  /** 캔버스 높이 (픽셀) */
  height: number;
}

// =============================================================================
// 변환 함수
// =============================================================================

/**
 * 정규화 좌표(0~1000)를 픽셀 좌표로 변환합니다.
 *
 * RULE-009: bbox 순서는 [ymin, xmin, ymax, xmax]
 *
 * @param box - 정규화 좌표 바운딩 박스
 * @param canvas - 캔버스 크기
 * @returns 픽셀 단위 바운딩 박스
 *
 * @example
 * ```ts
 * const normalized: Box2D = { ymin: 100, xmin: 200, ymax: 500, xmax: 800 };
 * const canvas = { width: 800, height: 600 };
 * const pixel = box2dToPixel(normalized, canvas);
 * // pixel = { top: 60, left: 160, width: 480, height: 240 }
 * ```
 */
export function box2dToPixel(box: Box2D, canvas: CanvasSize): Box2DPixel {
  const scaleX = canvas.width / NORMALIZED_MAX;
  const scaleY = canvas.height / NORMALIZED_MAX;

  const top = box.ymin * scaleY;
  const left = box.xmin * scaleX;
  const bottom = box.ymax * scaleY;
  const right = box.xmax * scaleX;

  return {
    top,
    left,
    width: right - left,
    height: bottom - top,
  };
}

/**
 * 픽셀 좌표를 정규화 좌표(0~1000)로 변환합니다.
 *
 * 역변환이 필요한 경우 사용합니다 (예: 클릭 위치 → 정규화 좌표).
 *
 * @param pixel - 픽셀 단위 바운딩 박스
 * @param canvas - 캔버스 크기
 * @returns 정규화 좌표 바운딩 박스
 */
export function pixelToBox2d(pixel: Box2DPixel, canvas: CanvasSize): Box2D {
  const scaleX = NORMALIZED_MAX / canvas.width;
  const scaleY = NORMALIZED_MAX / canvas.height;

  const ymin = Math.round(pixel.top * scaleY);
  const xmin = Math.round(pixel.left * scaleX);
  const ymax = Math.round((pixel.top + pixel.height) * scaleY);
  const xmax = Math.round((pixel.left + pixel.width) * scaleX);

  // RULE-009: 0~1000 범위 보장
  return {
    ymin: Math.max(0, Math.min(NORMALIZED_MAX, ymin)),
    xmin: Math.max(0, Math.min(NORMALIZED_MAX, xmin)),
    ymax: Math.max(0, Math.min(NORMALIZED_MAX, ymax)),
    xmax: Math.max(0, Math.min(NORMALIZED_MAX, xmax)),
  };
}

/**
 * Box2D가 유효한지 검증합니다.
 *
 * @param box - 검증할 바운딩 박스
 * @returns 유효 여부
 */
export function isValidBox2D(box: Box2D): boolean {
  // 0~1000 범위 체크
  if (
    box.ymin < 0 ||
    box.ymin > NORMALIZED_MAX ||
    box.xmin < 0 ||
    box.xmin > NORMALIZED_MAX ||
    box.ymax < 0 ||
    box.ymax > NORMALIZED_MAX ||
    box.xmax < 0 ||
    box.xmax > NORMALIZED_MAX
  ) {
    return false;
  }

  // ymin < ymax, xmin < xmax 체크
  if (box.ymin >= box.ymax || box.xmin >= box.xmax) {
    return false;
  }

  return true;
}

/**
 * Box2D의 면적을 계산합니다 (정규화 좌표 기준).
 *
 * @param box - 바운딩 박스
 * @returns 면적 (0~1000000)
 */
export function box2dArea(box: Box2D): number {
  return (box.ymax - box.ymin) * (box.xmax - box.xmin);
}

/**
 * Box2D의 중심점을 계산합니다 (정규화 좌표 기준).
 *
 * @param box - 바운딩 박스
 * @returns 중심점 좌표 {x, y}
 */
export function box2dCenter(box: Box2D): { x: number; y: number } {
  return {
    x: (box.xmin + box.xmax) / 2,
    y: (box.ymin + box.ymax) / 2,
  };
}
</file>

<file path="frontend/src/vite-env.d.ts">
/// <reference types="vite/client" />
</file>

<file path="frontend/tsconfig.node.json">
{
  "compilerOptions": {
    "target": "ES2022",
    "lib": ["ES2022"],
    "module": "ESNext",
    "skipLibCheck": true,

    /* Bundler mode */
    "moduleResolution": "Bundler",
    "allowImportingTsExtensions": true,
    "isolatedModules": true,
    "moduleDetection": "force",

    /* Composite for project references */
    "composite": true,
    "emitDeclarationOnly": true,
    "declaration": true,
    "declarationMap": true,

    /* Linting (엄격 모드) */
    "strict": true,
    "noUnusedLocals": true,
    "noUnusedParameters": true,
    "noFallthroughCasesInSwitch": true,
    "noUncheckedSideEffectImports": true
  },
  "include": ["vite.config.ts"]
}
</file>

<file path="backend/src/unknown_world/api/turn_stream_events.py">
"""Unknown World - Turn Stream 이벤트 계약(Contract).

NDJSON 스트리밍에서 사용되는 이벤트 타입, 모델, 유틸리티를 정의합니다.
이 모듈은 Orchestrator ↔ API ↔ Frontend 간의 스트림 이벤트 계약 SSOT입니다.

설계 원칙:
    - RU-002-Q4: 이벤트 계약을 transport 계층으로 분리
    - RULE-003: 구조화 출력(JSON Schema) 우선 + Pydantic 검증
    - RULE-008: 단계/배지 가시화

참조:
    - vibe/unit-plans/U-007[Mvp].md
    - vibe/refactors/RU-002-Q4.md
"""

from __future__ import annotations

import json
from typing import Annotated, Any

from pydantic import BaseModel, Field

# =============================================================================
# 스트림 이벤트 타입 상수
# =============================================================================


class StreamEventType:
    """스트림 이벤트 타입 상수.

    NDJSON 스트리밍에서 사용되는 이벤트 타입입니다.
    PRD 예시 단계: Parse→Validate→Plan→Resolve→Render→Verify→Commit
    """

    STAGE = "stage"
    BADGES = "badges"
    NARRATIVE_DELTA = "narrative_delta"
    FINAL = "final"
    ERROR = "error"
    REPAIR = "repair"


class StageStatus:
    """단계 상태 상수."""

    START = "start"
    COMPLETE = "complete"
    FAIL = "fail"


# =============================================================================
# 스트림 이벤트 모델 (Pydantic)
# =============================================================================


class StageEvent(BaseModel):
    """단계 진행 이벤트.

    Attributes:
        type: 이벤트 타입 ("stage")
        name: 단계 이름 (Parse, Validate, Plan, Resolve, Render, Verify, Commit)
        status: 상태 (start, complete)
    """

    type: Annotated[str, Field(default=StreamEventType.STAGE)]
    name: str
    status: str


class RepairEvent(BaseModel):
    """자동 복구(Repair) 이벤트.

    Attributes:
        type: 이벤트 타입 ("repair")
        attempt: 현재 시도 횟수
        message: 복구 메시지 (선택)
    """

    type: Annotated[str, Field(default=StreamEventType.REPAIR)]
    attempt: int
    message: str | None = None


class BadgesEvent(BaseModel):
    """배지 이벤트.

    Attributes:
        type: 이벤트 타입 ("badges")
        badges: 검증 배지 목록
    """

    type: Annotated[str, Field(default=StreamEventType.BADGES)]
    badges: list[str]


class NarrativeDeltaEvent(BaseModel):
    """내러티브 델타 이벤트 (타자 효과용).

    Attributes:
        type: 이벤트 타입 ("narrative_delta")
        text: 추가된 텍스트 조각
    """

    type: Annotated[str, Field(default=StreamEventType.NARRATIVE_DELTA)]
    text: str


class FinalEvent(BaseModel):
    """최종 TurnOutput 이벤트.

    Attributes:
        type: 이벤트 타입 ("final")
        data: 완전한 TurnOutput

    Note:
        TurnOutput은 TYPE_CHECKING 블록에서 import되며,
        런타임에는 Any로 처리됩니다.
    """

    type: Annotated[str, Field(default=StreamEventType.FINAL)]
    data: Any  # TurnOutput (순환 import 방지)


class ErrorEvent(BaseModel):
    """에러 이벤트.

    Attributes:
        type: 이벤트 타입 ("error")
        message: 에러 메시지 (프롬프트/내부 추론 노출 금지)
        code: 에러 코드 (선택)
    """

    type: Annotated[str, Field(default=StreamEventType.ERROR)]
    message: str
    code: str | None = None


# =============================================================================
# 유틸리티 함수
# =============================================================================


def serialize_event(event: dict[str, Any]) -> str:
    """이벤트를 NDJSON 라인으로 직렬화합니다.

    Args:
        event: 직렬화할 이벤트 딕셔너리

    Returns:
        str: NDJSON 형식 문자열 (줄바꿈 포함)
    """
    return json.dumps(event, ensure_ascii=False) + "\n"


# =============================================================================
# 모듈 공개 API
# =============================================================================

__all__ = [
    "StreamEventType",
    "StageStatus",
    "StageEvent",
    "RepairEvent",
    "BadgesEvent",
    "NarrativeDeltaEvent",
    "FinalEvent",
    "ErrorEvent",
    "serialize_event",
]
</file>

<file path="backend/src/unknown_world/models/turn.py">
"""Unknown World - TurnInput/TurnOutput Pydantic 스키마.

이 모듈은 Unknown World의 핵심 데이터 모델을 정의합니다.
Gemini Structured Outputs에 투입 가능한 JSON Schema(부분집합)를 생성할 수 있습니다.

설계 원칙:
    - RULE-003: 구조화 출력(JSON Schema) 우선 + 이중 검증
    - RULE-005: 재화 인바리언트 (cost, balance_after 필수, 잔액 음수 금지)
    - RULE-006: ko/en 언어 정책 (Language enum으로 고정)
    - RULE-009: 좌표 규약 (0~1000, bbox [ymin,xmin,ymax,xmax])

사용 예시:
    # Gemini Structured Outputs용 JSON Schema 생성
    schema = TurnOutput.model_json_schema()

    # 응답 검증
    output = TurnOutput.model_validate_json(gemini_response_text)

참조:
    - vibe/prd.md 8.7 (데이터 모델 설계)
    - vibe/ref/structured-outputs-guide.md
    - .cursor/rules/00-core-critical.mdc
"""

from enum import Enum
from typing import Annotated

from pydantic import BaseModel, ConfigDict, Field

# =============================================================================
# 공통 Enum 타입
# =============================================================================


class Language(str, Enum):
    """지원 언어 (RULE-006).

    ko/en 혼합 출력 금지. TurnInput.language를 SSOT로 삼아
    모든 UI/내러티브/시스템 메시지는 동일 언어로 고정합니다.
    """

    KO = "ko-KR"
    EN = "en-US"


class Theme(str, Enum):
    """테마 설정."""

    DARK = "dark"
    LIGHT = "light"


class AgentPhase(str, Enum):
    """에이전트 실행 단계 (RULE-008).

    에이전트형 시스템임을 UI로 증명하기 위한 단계 표시.
    """

    PARSE = "parse"
    VALIDATE = "validate"
    PLAN = "plan"
    RESOLVE = "resolve"
    RENDER = "render"
    VERIFY = "verify"
    COMMIT = "commit"


class ValidationBadge(str, Enum):
    """검증 배지 (RULE-008).

    턴 결과에 대한 검증 상태를 표시합니다.
    """

    SCHEMA_OK = "schema_ok"
    SCHEMA_FAIL = "schema_fail"
    ECONOMY_OK = "economy_ok"
    ECONOMY_FAIL = "economy_fail"
    SAFETY_OK = "safety_ok"
    SAFETY_BLOCKED = "safety_blocked"
    CONSISTENCY_OK = "consistency_ok"
    CONSISTENCY_FAIL = "consistency_fail"


class ModelLabel(str, Enum):
    """모델/품질 선택 라벨 (RULE-008).

    프롬프트 노출 없이 "왜 이 선택이었는지"를 사용자 친화 라벨로 표시.
    """

    FAST = "FAST"
    QUALITY = "QUALITY"
    CHEAP = "CHEAP"
    REF = "REF"


class RiskLevel(str, Enum):
    """행동 위험도 수준."""

    LOW = "low"
    MEDIUM = "medium"
    HIGH = "high"


# =============================================================================
# 공통 하위 타입
# =============================================================================

# RULE-009: 좌표는 0~1000 정규화 좌표계 (이미지 이해 bbox 포맷과 호환)
Coordinate = Annotated[int, Field(ge=0, le=1000, description="정규화 좌표 (0~1000)")]


class Box2D(BaseModel):
    """2D 바운딩 박스 (RULE-009).

    좌표는 0~1000 정규화 좌표계이며, bbox는 [ymin, xmin, ymax, xmax] 순서입니다.
    이미지 이해 bbox 포맷과 호환됩니다.

    Attributes:
        ymin: Y 최소값 (상단)
        xmin: X 최소값 (좌측)
        ymax: Y 최대값 (하단)
        xmax: X 최대값 (우측)
    """

    model_config = ConfigDict(extra="forbid")

    ymin: Coordinate
    xmin: Coordinate
    ymax: Coordinate
    xmax: Coordinate


class CurrencyAmount(BaseModel):
    """재화 수량.

    Attributes:
        signal: 기본 재화 (텍스트 턴/이미지 생성/고급 기능에 소비)
        memory_shard: 희귀 재화 (중요 설정 고정, 고해상도 이미지 등에 소비)
    """

    model_config = ConfigDict(extra="forbid")

    signal: Annotated[int, Field(ge=0, description="시그널 (기본 재화, 0 이상)")]
    memory_shard: Annotated[int, Field(ge=0, description="기억 파편 (희귀 재화, 0 이상)")]


# =============================================================================
# TurnInput 관련 타입
# =============================================================================


class ClickInput(BaseModel):
    """클릭 입력 정보.

    화면 오브젝트 클릭 시 전달되는 정보입니다.

    Attributes:
        object_id: 클릭한 오브젝트 ID
        box_2d: 클릭 위치의 바운딩 박스 (선택)
    """

    model_config = ConfigDict(extra="forbid")

    object_id: str = Field(description="클릭한 오브젝트 ID")
    box_2d: Box2D | None = Field(default=None, description="클릭 위치 바운딩 박스 (선택)")


class ClientInfo(BaseModel):
    """클라이언트 정보.

    Attributes:
        viewport_w: 뷰포트 너비 (픽셀)
        viewport_h: 뷰포트 높이 (픽셀)
        theme: 현재 테마 (dark/light)
    """

    model_config = ConfigDict(extra="forbid")

    viewport_w: Annotated[int, Field(gt=0, description="뷰포트 너비 (픽셀)")]
    viewport_h: Annotated[int, Field(gt=0, description="뷰포트 높이 (픽셀)")]
    theme: Theme = Field(default=Theme.DARK, description="현재 테마")


class EconomySnapshot(BaseModel):
    """재화 스냅샷 (클라이언트 → 서버).

    클라이언트가 보유한 현재 재화 상태입니다.
    서버는 이를 검증하고 비용 계산에 사용합니다.

    Attributes:
        signal: 현재 시그널 잔액
        memory_shard: 현재 기억 파편 잔액
    """

    model_config = ConfigDict(extra="forbid")

    signal: Annotated[int, Field(ge=0, description="현재 시그널 잔액 (0 이상)")]
    memory_shard: Annotated[int, Field(ge=0, description="현재 기억 파편 잔액 (0 이상)")]


class TurnInput(BaseModel):
    """턴 입력 (클라이언트 → 서버).

    사용자가 턴을 진행할 때 서버로 전송하는 입력 데이터입니다.

    Attributes:
        language: 요청 언어 (응답도 동일 언어로 고정)
        text: 사용자 자연어 입력
        action_id: 선택한 액션 카드 ID (선택)
        click: 오브젝트 클릭 정보 (선택)
        client: 클라이언트 환경 정보
        economy_snapshot: 현재 재화 상태

    Example:
        >>> input_data = TurnInput(
        ...     language=Language.KO,
        ...     text="문을 열어본다",
        ...     economy_snapshot=EconomySnapshot(signal=100, memory_shard=5),
        ...     client=ClientInfo(viewport_w=1920, viewport_h=1080),
        ... )
    """

    model_config = ConfigDict(extra="forbid")

    language: Language = Field(description="요청 언어 (응답도 동일 언어로 고정)")
    text: str = Field(default="", description="사용자 자연어 입력")
    action_id: str | None = Field(default=None, description="선택한 액션 카드 ID (선택)")
    click: ClickInput | None = Field(default=None, description="오브젝트 클릭 정보 (선택)")
    client: ClientInfo = Field(description="클라이언트 환경 정보")
    economy_snapshot: EconomySnapshot = Field(description="현재 재화 상태")


# =============================================================================
# TurnOutput 관련 타입 - UI
# =============================================================================


class CostEstimate(BaseModel):
    """비용 추정치 (최소/최대 범위)."""

    model_config = ConfigDict(extra="forbid")

    min: CurrencyAmount = Field(description="최소 예상 비용")
    max: CurrencyAmount = Field(description="최대 예상 비용")


class ActionCard(BaseModel):
    """액션 카드 (Action Deck).

    매 턴 AI가 추천하는 행동 카드입니다.
    각 카드에 비용/위험/보상 힌트가 포함됩니다.

    Attributes:
        id: 카드 고유 ID
        label: 카드 라벨 (표시용)
        description: 카드 설명 (선택)
        cost: 예상 비용 (기본)
        cost_estimate: 비용 추정 범위 (선택)
        risk: 위험도
        hint: 예상 결과 힌트 (선택)
        reward_hint: 보상 힌트 (선택)
        enabled: 실행 가능 여부 (서버 판단)
        disabled_reason: 비활성화 사유 (선택)
        is_alternative: 저비용 대안 카드 여부
    """

    model_config = ConfigDict(extra="forbid")

    id: str = Field(description="카드 고유 ID")
    label: str = Field(description="카드 라벨 (표시용)")
    description: str | None = Field(default=None, description="카드 설명 (선택)")
    cost: CurrencyAmount = Field(description="예상 비용 (기본)")
    cost_estimate: CostEstimate | None = Field(default=None, description="비용 추정 범위 (선택)")
    risk: RiskLevel = Field(default=RiskLevel.LOW, description="위험도")
    hint: str | None = Field(default=None, description="예상 결과 힌트 (선택)")
    reward_hint: str | None = Field(default=None, description="보상 힌트 (선택)")
    enabled: bool = Field(default=True, description="실행 가능 여부 (서버 판단)")
    disabled_reason: str | None = Field(default=None, description="비활성화 사유 (선택)")
    is_alternative: bool = Field(default=False, description="저비용 대안 카드 여부")


class SceneObject(BaseModel):
    """장면 오브젝트 (클릭 가능한 핫스팟).

    화면에서 클릭 가능한 오브젝트입니다.
    좌표는 0~1000 정규화 좌표계를 사용합니다 (RULE-009).

    Attributes:
        id: 오브젝트 고유 ID
        label: 오브젝트 라벨 (표시용)
        box_2d: 바운딩 박스 [ymin, xmin, ymax, xmax]
        interaction_hint: 상호작용 힌트 (선택)
    """

    model_config = ConfigDict(extra="forbid")

    id: str = Field(description="오브젝트 고유 ID")
    label: str = Field(description="오브젝트 라벨 (표시용)")
    box_2d: Box2D = Field(description="바운딩 박스")
    interaction_hint: str | None = Field(default=None, description="상호작용 힌트 (선택)")


class ActionDeck(BaseModel):
    """액션 덱 (Q1 결정: ui.action_deck.cards[] 구조).

    매 턴 AI가 제시하는 추천 행동 카드 덱입니다.

    Attributes:
        cards: 액션 카드 목록 (3~6장 권장)
    """

    model_config = ConfigDict(extra="forbid")

    cards: list[ActionCard] = Field(
        default=[],
        min_length=0,
        max_length=10,
        description="액션 카드 목록 (3~6장 권장)",
    )


class UIOutput(BaseModel):
    """UI 출력 데이터.

    AI가 생성한 UI 요소들입니다.
    채팅 버블이 아닌 게임 UI로 표현됩니다 (RULE-002).

    Attributes:
        action_deck: 액션 카드 덱 (Q1 결정: Option A 채택)
        objects: 클릭 가능한 장면 오브젝트 목록
    """

    model_config = ConfigDict(extra="forbid")

    action_deck: ActionDeck = Field(default_factory=ActionDeck, description="액션 카드 덱")
    objects: list[SceneObject] = Field(default=[], description="클릭 가능한 장면 오브젝트 목록")


# =============================================================================
# TurnOutput 관련 타입 - World
# =============================================================================


class MemoryPin(BaseModel):
    """중요 설정 고정 후보.

    사용자가 Memory Shard를 소비해 고정할 수 있는 중요 설정입니다.

    Attributes:
        id: 핀 고유 ID
        content: 고정할 내용
        cost: 고정에 필요한 비용
    """

    model_config = ConfigDict(extra="forbid")

    id: str = Field(description="핀 고유 ID")
    content: str = Field(description="고정할 내용")
    cost: CurrencyAmount = Field(description="고정에 필요한 비용")


class WorldRule(BaseModel):
    """세계 규칙 (Rule Board).

    현재 세계에 적용 중인 물리 법칙이나 메타 규칙입니다.

    Attributes:
        id: 규칙 고유 ID
        label: 규칙 이름
        description: 규칙 상세 설명 (선택)
    """

    model_config = ConfigDict(extra="forbid")

    id: str = Field(description="규칙 고유 ID")
    label: str = Field(description="규칙 이름")
    description: str | None = Field(default=None, description="규칙 상세 설명 (선택)")


class Quest(BaseModel):
    """퀘스트/목표 (Quest Panel).

    플레이어가 달성해야 하는 현재 목표입니다.

    Attributes:
        id: 퀘스트 고유 ID
        label: 퀘스트 이름
        is_completed: 달성 여부
    """

    model_config = ConfigDict(extra="forbid")

    id: str = Field(description="퀘스트 고유 ID")
    label: str = Field(description="퀘스트 이름")
    is_completed: bool = Field(default=False, description="달성 여부")


class WorldDelta(BaseModel):
    """세계 상태 변화 (Q2 결정: Option A - delta 중심).

    이번 턴에서 변경된 세계 상태를 나타냅니다.
    snapshot은 SaveGame에만 저장하고, 매 턴은 delta만 전송합니다.

    Attributes:
        rules_changed: 변경되거나 추가된 규칙 목록
        inventory_added: 추가된 인벤토리 아이템
        inventory_removed: 제거된 인벤토리 아이템
        quests_updated: 업데이트된 퀘스트(목표) 목록
        relationships_changed: 변경된 관계
        memory_pins: 중요 설정 고정 후보
    """

    model_config = ConfigDict(extra="forbid")

    rules_changed: list[WorldRule] = Field(default=[], description="변경된 규칙 목록")
    inventory_added: list[str] = Field(default=[], description="추가된 인벤토리 아이템")
    inventory_removed: list[str] = Field(default=[], description="제거된 인벤토리 아이템")
    quests_updated: list[Quest] = Field(default=[], description="업데이트된 퀘스트/목표 목록")
    relationships_changed: list[str] = Field(default=[], description="변경된 관계")
    memory_pins: list[MemoryPin] = Field(default=[], description="중요 설정 고정 후보")


# =============================================================================
# TurnOutput 관련 타입 - Render
# =============================================================================


class ImageJob(BaseModel):
    """이미지 생성 작업.

    조건부 이미지 생성/편집 요청입니다.
    이미지 생성이 느릴 경우 텍스트 우선 출력 + Lazy Loading을 사용합니다.

    Attributes:
        should_generate: 이미지를 생성해야 하는지
        prompt: 이미지 생성 프롬프트
        model_label: 모델 선택 라벨 (FAST/QUALITY/CHEAP/REF)
        aspect_ratio: 가로세로 비율 (예: "16:9", "1:1")
        image_size: 이미지 크기 (예: "1024x1024")
        reference_image_ids: 참조 이미지 ID 목록 (선택)
    """

    model_config = ConfigDict(extra="forbid")

    should_generate: bool = Field(description="이미지를 생성해야 하는지")
    prompt: str = Field(default="", description="이미지 생성 프롬프트")
    model_label: ModelLabel = Field(default=ModelLabel.FAST, description="모델 선택 라벨")
    aspect_ratio: str = Field(default="16:9", description="가로세로 비율")
    image_size: str = Field(default="1024x1024", description="이미지 크기")
    reference_image_ids: list[str] = Field(default=[], description="참조 이미지 ID 목록 (선택)")


class RenderOutput(BaseModel):
    """렌더링 출력 데이터.

    이미지 생성/편집 관련 정보입니다.

    Attributes:
        image_job: 이미지 생성 작업 (선택)
    """

    model_config = ConfigDict(extra="forbid")

    image_job: ImageJob | None = Field(default=None, description="이미지 생성 작업 (선택)")


# =============================================================================
# TurnOutput 관련 타입 - Economy
# =============================================================================


class EconomyOutput(BaseModel):
    """경제 출력 데이터 (RULE-005).

    이번 턴의 비용과 잔액 정보입니다.
    잔액 음수는 절대 불가 (서버 Hard gate).

    Attributes:
        cost: 이번 턴에 소비된 비용
        balance_after: 소비 후 잔액

    Important:
        - cost와 balance_after는 항상 포함되어야 합니다.
        - balance_after의 signal과 memory_shard는 0 이상이어야 합니다.
    """

    model_config = ConfigDict(extra="forbid")

    cost: CurrencyAmount = Field(description="이번 턴에 소비된 비용")
    balance_after: CurrencyAmount = Field(description="소비 후 잔액")


# =============================================================================
# TurnOutput 관련 타입 - Safety
# =============================================================================


class SafetyOutput(BaseModel):
    """안전 출력 데이터.

    안전 정책 관련 정보입니다.
    차단 시 명시적 메시지와 함께 안전한 대체 결과를 제공합니다.

    Attributes:
        blocked: 안전 정책에 의해 차단되었는지
        message: 차단 시 사용자에게 표시할 메시지 (선택)
    """

    model_config = ConfigDict(extra="forbid")

    blocked: bool = Field(default=False, description="안전 정책에 의해 차단되었는지")
    message: str | None = Field(default=None, description="차단 시 사용자에게 표시할 메시지 (선택)")


# =============================================================================
# TurnOutput 관련 타입 - Agent Console
# =============================================================================


class AgentConsole(BaseModel):
    """에이전트 콘솔 데이터 (RULE-008).

    에이전트형 시스템임을 UI로 증명하기 위한 정보입니다.
    계획/실행/검증/복구의 흔적을 표시합니다.

    Attributes:
        current_phase: 현재 실행 단계
        badges: 검증 배지 목록
        repair_count: 자동 복구 시도 횟수
    """

    model_config = ConfigDict(extra="forbid")

    current_phase: AgentPhase = Field(default=AgentPhase.COMMIT, description="현재 실행 단계")
    badges: list[ValidationBadge] = Field(default=[], description="검증 배지 목록")
    repair_count: Annotated[int, Field(ge=0, description="자동 복구 시도 횟수")] = 0


# =============================================================================
# TurnOutput (메인 응답 스키마)
# =============================================================================


class TurnOutput(BaseModel):
    """턴 출력 (서버 → 클라이언트).

    서버가 턴 처리 후 클라이언트로 반환하는 구조화된 응답입니다.
    Gemini Structured Outputs(JSON Schema)로 강제됩니다.

    Hard Gate 필드 (RULE-003/004/005):
        - economy: cost와 balance_after 필수, 잔액 음수 금지
        - safety: blocked 시 안전한 대체 결과 제공
        - language: 요청 언어와 동일하게 고정 (혼합 출력 금지)

    Attributes:
        language: 응답 언어 (요청과 동일)
        narrative: 내러티브 텍스트 (표시용)
        ui: UI 요소 (액션 덱, 오브젝트)
        world: 세계 상태 변화 (delta 중심)
        render: 렌더링 정보 (이미지 생성 작업)
        economy: 경제 정보 (비용, 잔액)
        safety: 안전 정책 정보
        agent_console: 에이전트 실행 정보 (단계, 배지, 복구 횟수)

    Example:
        >>> output = TurnOutput(
        ...     language=Language.KO,
        ...     narrative="문이 삐걱거리며 열립니다...",
        ...     economy=EconomyOutput(
        ...         cost=CurrencyAmount(signal=5, memory_shard=0),
        ...         balance_after=CurrencyAmount(signal=95, memory_shard=5),
        ...     ),
        ...     safety=SafetyOutput(blocked=False),
        ... )
        >>> schema = TurnOutput.model_json_schema()

    Schema Generation:
        >>> # Gemini Structured Outputs용 JSON Schema 생성
        >>> json_schema = TurnOutput.model_json_schema()
        >>> # response_json_schema 파라미터에 전달
        >>> config = {
        ...     "response_mime_type": "application/json",
        ...     "response_json_schema": json_schema,
        ... }
    """

    model_config = ConfigDict(extra="forbid")

    # 필수 필드 (Hard Gate)
    language: Language = Field(description="응답 언어 (요청과 동일)")
    narrative: str = Field(description="내러티브 텍스트 (표시용)")
    economy: EconomyOutput = Field(description="경제 정보 (비용, 잔액)")
    safety: SafetyOutput = Field(description="안전 정책 정보")

    # UI 관련 필드
    ui: UIOutput = Field(default_factory=UIOutput, description="UI 요소")

    # 세계 상태 필드
    world: WorldDelta = Field(default_factory=WorldDelta, description="세계 상태 변화 (delta)")

    # 렌더링 필드
    render: RenderOutput = Field(default_factory=RenderOutput, description="렌더링 정보")

    # 에이전트 콘솔 필드
    agent_console: AgentConsole = Field(
        default_factory=AgentConsole, description="에이전트 실행 정보"
    )
</file>

<file path="backend/tests/integration/test_turn_streaming.py">
"""Unknown World - /api/turn HTTP Streaming 통합 테스트.

NDJSON 스트리밍 이벤트의 순서, 구조, 데이터 정밀도를 검증합니다.
"""

import json

from fastapi.testclient import TestClient

from unknown_world.main import app
from unknown_world.models.turn import Language, TurnOutput

client = TestClient(app)


def test_turn_streaming_success():
    """정상적인 턴 요청 시 NDJSON 스트림이 올바른 순서로 반환되는지 테스트합니다."""
    payload = {
        "language": "ko-KR",
        "text": "테스트 입력",
        "client": {"viewport_w": 1920, "viewport_h": 1080, "theme": "dark"},
        "economy_snapshot": {"signal": 100, "memory_shard": 5},
    }

    # StreamingResponse 테스트
    response = client.post("/api/turn", json=payload)
    assert response.status_code == 200
    assert response.headers["content-type"] == "application/x-ndjson"

    events = []
    for line in response.iter_lines():
        if line:
            events.append(json.loads(line))

    # 1. 이벤트 존재 여부 확인
    assert len(events) > 0

    # 2. 첫 번째 이벤트는 항상 stage: parse: start 여야 함 (TTFB)
    assert events[0]["type"] == "stage"
    assert events[0]["name"] == "parse"
    assert events[0]["status"] == "start"

    # 3. 단계별 이벤트 순서 확인
    stages = [e["name"] for e in events if e["type"] == "stage" and e["status"] == "start"]
    expected_stages = ["parse", "validate", "plan", "resolve", "render", "verify", "commit"]
    assert stages == expected_stages

    # 4. 배지 이벤트 포함 여부 확인
    badges_events = [e for e in events if e["type"] == "badges"]
    assert len(badges_events) >= 2
    assert "schema_ok" in badges_events[0]["badges"]

    # 5. 최종 결과물 확인
    final_events = [e for e in events if e["type"] == "final"]
    assert len(final_events) == 1

    turn_output_data = final_events[0]["data"]
    # Pydantic 모델로 다시 검증 (RULE-003)
    turn_output = TurnOutput.model_validate(turn_output_data)
    assert turn_output.language == Language.KO
    assert len(turn_output.narrative) > 0


def test_turn_streaming_invalid_input():
    """잘못된 입력 요청 시 에러 이벤트가 스트리밍되는지 테스트합니다."""
    payload = {
        "language": "invalid-lang",  # 잘못된 언어 코드
        "text": "",
    }

    response = client.post("/api/turn", json=payload)
    # 입력 검증 실패 시에도 200 OK 스트림으로 에러를 보낼 수도 있고,
    # 400 Bad Request를 보낼 수도 있음. 현재 구현은 200 OK + type: error 임.
    assert response.status_code == 200

    events = [json.loads(line) for line in response.iter_lines() if line]
    assert any(e["type"] == "error" for e in events)
    assert any(e["code"] == "VALIDATION_ERROR" for e in events)


def test_turn_streaming_deterministic_seed():
    """seed 파라미터 사용 시 결과가 결정적인지 테스트합니다."""
    payload = {
        "language": "en-US",
        "text": "Hello",
        "client": {"viewport_w": 1920, "viewport_h": 1080},
        "economy_snapshot": {"signal": 100, "memory_shard": 5},
    }

    # 동일한 시드로 두 번 요청
    seed = 12345

    def get_final_output(s):
        resp = client.post(f"/api/turn?seed={s}", json=payload)
        events = [json.loads(line) for line in resp.iter_lines() if line]
        return next(e["data"] for e in events if e["type"] == "final")

    output1 = get_final_output(seed)
    output2 = get_final_output(seed)

    assert output1 == output2
    assert output1["language"] == "en-US"


def test_turn_streaming_generation_fallback(monkeypatch):
    """생성 중 ValidationError 발생 시 안전한 폴백이 반환되는지 테스트합니다."""
    from pydantic import ValidationError

    from unknown_world.orchestrator.mock import MockOrchestrator

    def mock_generate_failure(self, turn_input):
        # Pydantic ValidationError를 수동으로 생성하는 것은 복잡하므로
        # 간단한 필드 검증 오류를 시뮬레이션하거나 직접 raise 함
        # 여기서는 테스트를 위해 임의의 필드 누락 등으로 발생한다고 가정
        raise ValidationError.from_exception_data(title="MockError", line_errors=[])

    monkeypatch.setattr(MockOrchestrator, "generate_turn_output", mock_generate_failure)

    payload = {
        "language": "ko-KR",
        "text": "테스트",
        "client": {"viewport_w": 1920, "viewport_h": 1080},
        "economy_snapshot": {"signal": 100, "memory_shard": 5},
    }

    response = client.post("/api/turn", json=payload)
    events = [json.loads(line) for line in response.iter_lines() if line]

    final_event = next(e for e in events if e["type"] == "final")
    turn_output = final_event["data"]

    # 폴백 응답의 특징 확인
    assert turn_output["agent_console"]["badges"] == ["schema_fail"]
    assert turn_output["agent_console"]["repair_count"] == 1
    assert "혼란" in turn_output["narrative"] or "confusion" in turn_output["narrative"]


def test_turn_streaming_repair_loop(monkeypatch):
    """검증 실패 시 repair 이벤트가 스트림에 포함되는지 테스트합니다 (RU-002)."""
    from pydantic import ValidationError

    from unknown_world.orchestrator.mock import MockOrchestrator

    # 첫 번째 호출에서 실패하여 repair 트리거 시뮬레이션
    # (실제 구현에서는 N회 재시도 로직이 turn.py에 있어야 함)
    call_count = 0

    def mock_generate_with_repair(self, turn_input):
        nonlocal call_count
        call_count += 1
        if call_count == 1:
            raise ValidationError.from_exception_data(title="MockSchemaError", line_errors=[])
        return orchestrator_orig_generate(self, turn_input)

    import unknown_world.orchestrator.mock as mock_mod

    orchestrator_orig_generate = mock_mod.MockOrchestrator.generate_turn_output
    monkeypatch.setattr(MockOrchestrator, "generate_turn_output", mock_generate_with_repair)

    payload = {
        "language": "ko-KR",
        "text": "리페어 테스트",
        "client": {"viewport_w": 1920, "viewport_h": 1080},
        "economy_snapshot": {"signal": 100, "memory_shard": 5},
    }

    response = client.post("/api/turn", json=payload)
    events = [json.loads(line) for line in response.iter_lines() if line]

    # RU-002 요구사항: repair 이벤트가 명시적으로 존재해야 함
    repair_events = [e for e in events if e["type"] == "repair"]
    assert len(repair_events) >= 1
    assert "attempt" in repair_events[0]
    assert repair_events[0]["attempt"] == 1
</file>

<file path="backend/tests/unit/test_u034_verification.py">
import json
from pathlib import Path

# 프로젝트 루트 경로 설정 (backend/tests/unit/ 위치 기준)
ROOT_DIR = Path(__file__).parent.parent.parent.parent
SCHEMA_PATH = ROOT_DIR / "vibe/ref/nanobanana-asset-request.schema.json"
GUIDE_PATH = ROOT_DIR / "vibe/ref/nanobanana-mcp.md"


def test_schema_file_exists():
    """스키마 파일이 지정된 위치에 존재하는지 확인"""
    assert SCHEMA_PATH.exists(), f"Schema file not found at {SCHEMA_PATH}"


def test_schema_is_valid_json():
    """스키마 파일이 유효한 JSON 형식인지 확인"""
    with open(SCHEMA_PATH, encoding="utf-8") as f:
        schema = json.load(f)
    assert schema["title"] == "nanobanana mcp Asset Request Schema"


def test_schema_required_properties():
    """계획서에 명시된 필수 필드가 스키마에 정의되어 있는지 확인"""
    with open(SCHEMA_PATH, encoding="utf-8") as f:
        schema = json.load(f)

    properties = schema.get("properties", {})
    required_fields = ["id", "category", "purpose", "size_px", "requires_rembg", "rembg_model"]

    for field in required_fields:
        assert field in properties, f"Required field '{field}' missing in schema properties"


def test_guide_file_exists():
    """가이드 문서 파일이 존재하는지 확인"""
    assert GUIDE_PATH.exists(), f"Guide file not found at {GUIDE_PATH}"


def test_guide_content_completeness():
    """가이드 문서에 필수 섹션(아트 디렉션, 카테고리별 템플릿)이 포함되어 있는지 확인"""
    with open(GUIDE_PATH, encoding="utf-8") as f:
        content = f.read()

    # 계획서 구현 흐름 2단계, 3단계 관련 키워드 검사
    required_keywords = ["아트 디렉션", "스타일", "아이콘", "placeholder", "chrome", "템플릿"]

    missing_keywords = [kw for kw in required_keywords if kw.lower() not in content.lower()]

    # 현재 nanobanana-mcp.md에는 rembg 내용만 있으므로 실패할 가능성이 큼
    assert not missing_keywords, (
        f"Guide document is missing sections for: {', '.join(missing_keywords)}"
    )


def test_schema_rembg_rules():
    """배경 제거(rembg) 관련 강제 규칙(순백 배경)이 스키마/설명에 포함되어 있는지 확인"""
    with open(SCHEMA_PATH, encoding="utf-8") as f:
        schema = json.load(f)

    # background 필드와 requires_rembg 필드 설명 확인
    background_desc = schema["properties"]["background"].get("description", "")
    rembg_desc = schema["properties"]["requires_rembg"].get("description", "")

    assert "solid_white" in str(schema["properties"]["background"].get("enum", [])), (
        "background enum should include solid_white"
    )
    assert "rembg" in background_desc.lower(), "background description should mention rembg"
    assert "solid_white" in rembg_desc.lower(), (
        "requires_rembg description should recommend solid_white"
    )
</file>

<file path="frontend/public/ui/manifest.schema.json">
{
  "$schema": "http://json-schema.org/draft-07/schema#",
  "$id": "https://unknown-world.dev/schemas/ui-asset-manifest.json",
  "title": "UI Asset Manifest",
  "description": "nanobanana mcp로 제작된 UI 에셋의 매니페스트 스키마",
  "type": "object",
  "required": ["version", "assets"],
  "additionalProperties": false,
  "properties": {
    "$schema": {
      "type": "string",
      "description": "JSON Schema 참조"
    },
    "version": {
      "type": "string",
      "pattern": "^\\d+\\.\\d+\\.\\d+$",
      "description": "매니페스트 버전 (SemVer)",
      "examples": ["1.0.0"]
    },
    "generatedAt": {
      "type": "string",
      "format": "date-time",
      "description": "매니페스트 생성 시각 (ISO 8601)"
    },
    "totalBytes": {
      "type": "integer",
      "minimum": 0,
      "description": "모든 에셋의 총 바이트 수"
    },
    "budgetBytes": {
      "type": "integer",
      "minimum": 0,
      "default": 1572864,
      "description": "성능 예산 상한 (기본: 1.5MB = 1572864 bytes)"
    },
    "assets": {
      "type": "array",
      "description": "에셋 목록",
      "items": {
        "$ref": "#/$defs/Asset"
      }
    }
  },
  "$defs": {
    "Asset": {
      "type": "object",
      "required": ["id", "path", "type"],
      "additionalProperties": false,
      "properties": {
        "id": {
          "type": "string",
          "pattern": "^[a-z0-9]+(-[a-z0-9]+)*$",
          "description": "에셋 고유 ID (kebab-case)",
          "examples": ["signal-24", "badge-ok-16", "scene-loading"]
        },
        "path": {
          "type": "string",
          "pattern": "^[a-z0-9-/]+\\.(png|webp|svg)$",
          "description": "ui/ 디렉토리 기준 상대 경로",
          "examples": ["icons/signal-24.png", "placeholders/scene-loading.webp"]
        },
        "type": {
          "type": "string",
          "enum": ["icon", "placeholder", "chrome"],
          "description": "에셋 유형"
        },
        "size": {
          "type": "integer",
          "enum": [16, 24, 32, 64, 128, 256, 512],
          "description": "픽셀 사이즈 (아이콘용)"
        },
        "width": {
          "type": "integer",
          "minimum": 1,
          "description": "가로 픽셀 (placeholder/chrome용)"
        },
        "height": {
          "type": "integer",
          "minimum": 1,
          "description": "세로 픽셀 (placeholder/chrome용)"
        },
        "fallback": {
          "type": "string",
          "maxLength": 10,
          "description": "로딩 실패 시 대체 이모지/텍스트",
          "examples": ["📡", "⚠️", "OK"]
        },
        "usedIn": {
          "type": "array",
          "items": {
            "type": "string"
          },
          "description": "사용처 컴포넌트 목록",
          "examples": [["EconomyHUD", "AgentConsole"]]
        },
        "bytes": {
          "type": "integer",
          "minimum": 0,
          "description": "파일 크기 (bytes)"
        },
        "format": {
          "type": "string",
          "enum": ["png", "webp", "svg"],
          "description": "파일 포맷"
        },
        "retina": {
          "type": "boolean",
          "default": false,
          "description": "@2x Retina 버전 존재 여부"
        },
        "description": {
          "type": "string",
          "maxLength": 200,
          "description": "에셋 설명"
        },
        "createdAt": {
          "type": "string",
          "format": "date-time",
          "description": "생성 시각 (ISO 8601)"
        },
        "promptHash": {
          "type": "string",
          "pattern": "^[a-f0-9]{8}$",
          "description": "생성 프롬프트 해시 (재현성, 8자)"
        },
        "notes": {
          "type": "string",
          "maxLength": 500,
          "description": "에셋 관련 메모 (생성 도구, 배경 제거, 최적화 등 QA 관련 기록)"
        }
      }
    }
  }
}
</file>

<file path="frontend/src/components/AgentConsole.test.tsx">
import { describe, it, expect, vi } from 'vitest';
import { render, screen } from '@testing-library/react';
import { AgentConsole } from './AgentConsole';

// Mock i18n
vi.mock('react-i18next', () => ({
  useTranslation: () => ({
    t: (key: string) => key,
  }),
}));

// Mock dependencies
type MockSelector<T> = (state: unknown) => T;

vi.mock('../stores/agentStore', () => ({
  useAgentStore: <T,>(selector: MockSelector<T>) =>
    selector({
      phases: [],
      badges: [],
      repairCount: 0,
      error: null,
      isStreaming: false,
    }),
  selectIsStreaming: (state: { isStreaming: boolean }) => state.isStreaming,
  selectPhases: (state: { phases: unknown[] }) => state.phases,
  selectBadges: (state: { badges: unknown[] }) => state.badges,
  selectRepairCount: (state: { repairCount: number }) => state.repairCount,
  selectError: (state: { error: unknown }) => state.error,
}));

describe('AgentConsole (U-037)', () => {
  it('should render with "critical" importance attribute', () => {
    const { container } = render(<AgentConsole />);

    // The root element of AgentConsole should have data-ui-importance="critical"
    const consoleElement = container.firstChild as HTMLElement;

    expect(consoleElement).toHaveAttribute('data-ui-importance', 'critical');
  });

  it('should render streaming status', () => {
    render(<AgentConsole />);
    // Verify that the correct i18n key is used
    expect(screen.getByText('agent.console.status.idle')).toBeInTheDocument();
  });
});
</file>

<file path="frontend/src/components/GameHeader.tsx">
import { useTranslation } from 'react-i18next';
import { UIControls } from './UIControls';
import { EconomyHudHeader } from './EconomyHud';
import type { UIScale } from '../stores/uiPrefsStore';
import { useEconomyStore, selectIsBalanceLow } from '../stores/economyStore';

interface GameHeaderProps {
  signal: number;
  memoryShard: number;
  isConnected: boolean;
  uiScale: UIScale;
  onIncreaseScale: () => void;
  onDecreaseScale: () => void;
}

export function GameHeader({
  signal,
  memoryShard,
  isConnected,
  uiScale,
  onIncreaseScale,
  onDecreaseScale,
}: GameHeaderProps) {
  const { t } = useTranslation();
  const isBalanceLow = useEconomyStore(selectIsBalanceLow);

  return (
    <header className="game-header has-chrome">
      <h1 className="game-title glitch" data-text={t('ui.logo')}>
        {t('ui.logo')}
      </h1>
      <div className="header-controls">
        {/* UI 스케일 컨트롤 (U-028→U-037: Readable 제거) */}
        <UIControls
          uiScale={uiScale}
          onIncreaseScale={onIncreaseScale}
          onDecreaseScale={onDecreaseScale}
        />
        {/* Economy HUD (U-014: 예상 비용/확정 비용 표시 포함) */}
        <EconomyHudHeader signal={signal} memoryShard={memoryShard} isLow={isBalanceLow} />
        <div className="connection-status">
          <span className={`status-indicator ${isConnected ? '' : 'offline'}`} />
          <span>{isConnected ? t('connection.online') : t('connection.offline')}</span>
        </div>
      </div>
    </header>
  );
}
</file>

<file path="frontend/src/components/Panel.tsx">
import { useTranslation } from 'react-i18next';

interface PanelProps {
  title: string;
  children?: React.ReactNode;
  className?: string;
  /** U-032: Chrome 장식 적용 여부 */
  hasChrome?: boolean;
  /** 기본 placeholder i18n 키 (children이 없을 때 사용) */
  placeholderKey?: string;
}

export function Panel({
  title,
  children,
  className = '',
  hasChrome = false,
  placeholderKey,
}: PanelProps) {
  const { t } = useTranslation();
  const panelClass = `panel ${className} ${hasChrome ? 'has-chrome' : ''}`.trim();
  const headerClass = `panel-header ${hasChrome ? 'has-chrome' : ''}`.trim();

  return (
    <div className={panelClass}>
      <div className={headerClass}>
        <span className="panel-title">{title}</span>
      </div>
      <div className="panel-content">
        {children || (
          <p className="panel-placeholder">
            {placeholderKey ? t(placeholderKey) : t('ui.panel_placeholder')}
          </p>
        )}
      </div>
    </div>
  );
}
</file>

<file path="frontend/src/demo/demoFixtures.ts">
/**
 * Unknown World - 데모용 Fixtures (RU-003-Q5)
 *
 * DEV 환경에서 사용하는 데모 초기 데이터입니다.
 * 언어 중립적인 값(ID/아이콘/수량/좌표)만 포함하며,
 * 표시 문자열(name/label/hint)은 i18n 키를 통해 렌더링합니다.
 *
 * 설계 원칙:
 *   - RULE-006: ko/en 혼합 출력 금지 (i18n 키 기반)
 *   - PRD 6.9: 데모 프로필 경계 확보
 *   - 서버 TurnOutput 대체 시 이 모듈 비활성화 가능
 *
 * @module demo/demoFixtures
 */

import type { Box2D } from '../schemas/turn';

// =============================================================================
// 타입 정의
// =============================================================================

/**
 * 데모 인벤토리 아이템 정의 (언어 중립)
 *
 * name은 i18n 키(`demo.items.{id}.name`)로 렌더링합니다.
 */
export interface DemoInventoryItemDef {
  /** 아이템 고유 ID */
  id: string;
  /** 아이템 아이콘 (이모지 또는 URL) */
  icon: string;
  /** 초기 수량 */
  quantity: number;
}

/**
 * 데모 씬 오브젝트 정의 (언어 중립)
 *
 * label/hint는 i18n 키로 렌더링합니다:
 * - labelKey: `demo.scene.{id}.label`
 * - hintKey: `demo.scene.{id}.hint`
 */
export interface DemoSceneObjectDef {
  /** 오브젝트 고유 ID */
  id: string;
  /** 바운딩 박스 (0~1000 정규화) */
  box_2d: Box2D;
  /** i18n 라벨 키 */
  labelKey: string;
  /** i18n 힌트 키 */
  hintKey: string;
}

// =============================================================================
// 데모 인벤토리 아이템
// =============================================================================

/**
 * 데모용 인벤토리 아이템 목록.
 *
 * @remarks
 * - ID/아이콘/수량만 정의 (언어 중립)
 * - 표시 이름은 `demo.items.{id}.name` 키로 i18n 처리
 */
export const DEMO_INVENTORY_ITEMS: readonly DemoInventoryItemDef[] = [
  { id: 'keycard-alpha', icon: '🔑', quantity: 1 },
  { id: 'medkit', icon: '🩹', quantity: 2 },
  { id: 'flashlight', icon: '🔦', quantity: 1 },
  { id: 'data-chip', icon: '💾', quantity: 3 },
] as const;

// =============================================================================
// 데모 씬 오브젝트
// =============================================================================

/**
 * 데모용 씬 오브젝트 목록.
 *
 * @remarks
 * - ID/좌표만 정의 (언어 중립)
 * - 표시 라벨/힌트는 i18n 키로 처리
 */
export const DEMO_SCENE_OBJECTS: readonly DemoSceneObjectDef[] = [
  {
    id: 'demo-terminal',
    box_2d: { ymin: 300, xmin: 100, ymax: 600, xmax: 400 },
    labelKey: 'demo.scene.terminal.label',
    hintKey: 'demo.scene.terminal.hint',
  },
  {
    id: 'demo-door',
    box_2d: { ymin: 200, xmin: 600, ymax: 800, xmax: 900 },
    labelKey: 'demo.scene.door.label',
    hintKey: 'demo.scene.door.hint',
  },
] as const;

// =============================================================================
// 데모 퀘스트 (U-013)
// =============================================================================

/**
 * 데모 퀘스트 정의 (언어 중립)
 *
 * label은 i18n 키(`demo.quest.{id}.label`)로 렌더링합니다.
 */
export interface DemoQuestDef {
  /** 퀘스트 고유 ID */
  id: string;
  /** i18n 라벨 키 */
  labelKey: string;
  /** 완료 여부 */
  is_completed: boolean;
}

/**
 * 데모용 퀘스트 목록.
 */
export const DEMO_QUESTS: readonly DemoQuestDef[] = [
  {
    id: 'demo-quest-terminal',
    labelKey: 'demo.quest.terminal.label',
    is_completed: false,
  },
  {
    id: 'demo-quest-escape',
    labelKey: 'demo.quest.escape.label',
    is_completed: false,
  },
  {
    id: 'demo-quest-collect',
    labelKey: 'demo.quest.collect.label',
    is_completed: true,
  },
] as const;

// =============================================================================
// 데모 규칙 (U-013)
// =============================================================================

/**
 * 데모 규칙 정의 (언어 중립)
 *
 * label/description은 i18n 키로 렌더링합니다.
 */
export interface DemoRuleDef {
  /** 규칙 고유 ID */
  id: string;
  /** i18n 라벨 키 */
  labelKey: string;
  /** i18n 설명 키 (선택) */
  descriptionKey?: string;
}

/**
 * 데모용 규칙 목록.
 */
export const DEMO_RULES: readonly DemoRuleDef[] = [
  {
    id: 'demo-rule-gravity',
    labelKey: 'demo.rule.gravity.label',
    descriptionKey: 'demo.rule.gravity.description',
  },
  {
    id: 'demo-rule-time',
    labelKey: 'demo.rule.time.label',
    descriptionKey: 'demo.rule.time.description',
  },
] as const;

// =============================================================================
// 헬퍼 함수
// =============================================================================

/**
 * 데모 인벤토리 아이템의 i18n 이름 키를 생성합니다.
 *
 * @param itemId - 아이템 ID
 * @returns i18n 키 (예: `demo.items.keycard-alpha.name`)
 */
export function getDemoItemNameKey(itemId: string): string {
  return `demo.items.${itemId}.name`;
}

/**
 * 데모 환경인지 확인합니다 (DEV 가드).
 *
 * @returns DEV 환경 여부
 */
export function isDemoEnvironment(): boolean {
  return import.meta.env.DEV;
}

/**
 * DOM에서 현재 테마를 읽습니다.
 *
 * RU-003-Q5: 'dark' 하드코딩 제거
 * - data-theme 속성을 확인하여 테마 결정
 * - 'crt', 'dark' 또는 미지정 → 'dark'
 * - 'light' → 'light'
 *
 * @returns 현재 테마 ('dark' | 'light')
 */
export function getCurrentThemeFromDOM(): 'dark' | 'light' {
  const dataTheme = document.documentElement.getAttribute('data-theme');

  // 'crt' 테마는 dark 계열로 취급
  if (dataTheme === 'light') {
    return 'light';
  }
  return 'dark';
}
</file>

<file path="frontend/src/dnd/types.ts">
/**
 * Unknown World - DnD 타입 및 상수 정의 (RU-003-Q1).
 *
 * DnD 데이터 계약을 SSOT로 관리하여 타입 안전성을 확보합니다.
 * 모든 드래그/드롭 이벤트에서 동일한 상수/타입을 사용합니다.
 *
 * 설계 원칙:
 *   - SSOT: 드래그/드롭 타입 문자열은 이 모듈에서만 정의
 *   - 타입 안전성: dnd-kit의 data.current를 타입 가드로 검증
 *   - 과도한 추상화 금지: 상수/타입만 제공, 로직은 컴포넌트에 유지
 *
 * @module dnd/types
 */

import type { Box2D } from '../schemas/turn';
import type { InventoryItem } from '../stores/inventoryStore';

// =============================================================================
// DnD 타입 상수 (SSOT)
// =============================================================================

/**
 * DnD 타입 상수.
 * 드래그/드롭 데이터의 type 필드에 사용됩니다.
 */
export const DND_TYPE = {
  /** 인벤토리 아이템 드래그 */
  INVENTORY_ITEM: 'inventory-item',
  /** 핫스팟 드롭 타겟 */
  HOTSPOT: 'hotspot',
} as const;

// =============================================================================
// RU-003-S2: 인터랙션 허용 정책 (SSOT)
// =============================================================================

/**
 * 핫스팟 인터랙션이 허용되는 Scene 상태 목록.
 *
 * RU-003-S2 Step 1: Option A(데모 유지) 결정
 * - 'scene': 실제 장면 활성화 상태
 * - 'default': 데모/플레이스홀더 상태 (시각적 힌트 필요)
 *
 * @see SceneCanvas.tsx의 shouldRenderHotspots 조건
 */
export const HOTSPOT_INTERACTION_ALLOWED_STATES = ['scene', 'default'] as const;

/**
 * 인터랙션 허용 상태 타입.
 */
export type HotspotInteractionState = (typeof HOTSPOT_INTERACTION_ALLOWED_STATES)[number];

/**
 * 주어진 상태에서 핫스팟 인터랙션이 허용되는지 검사합니다.
 *
 * RU-003-S2: 인터랙션 가능 조건을 SSOT로 고정
 *
 * @param status - Scene 상태
 * @returns 인터랙션 허용 여부
 */
export function isHotspotInteractionAllowed(status: string): boolean {
  return HOTSPOT_INTERACTION_ALLOWED_STATES.includes(status as HotspotInteractionState);
}

// =============================================================================
// RU-003-S2 Step 4: 스트리밍 비활성화 정책 (SSOT)
// =============================================================================

/**
 * 스트리밍 비활성화 정책.
 *
 * RU-003-S2 Step 4: disabled 플래그의 SSOT 고정
 * - isStreaming은 agentStore에서만 제공
 * - 모든 인터랙션 컴포넌트(SceneCanvas, InventoryPanel, ActionDeck)는
 *   동일한 disabled 플래그를 공유해야 함
 * - 향후 worldStore/Turn Runner 도입 시에도 이 원칙을 유지
 *
 * @see App.tsx의 isStreaming 사용 패턴
 * @see agentStore.ts의 isStreaming 상태
 */
export const STREAMING_DISABLED_POLICY = {
  /** 스트리밍 상태 SSOT 출처 */
  source: 'agentStore.isStreaming',
  /** 비활성화 적용 대상 컴포넌트 */
  affectedComponents: ['SceneCanvas', 'InventoryPanel', 'ActionDeck', 'CommandInput'],
} as const;

/**
 * DnD 타입 유니온.
 */
export type DndType = (typeof DND_TYPE)[keyof typeof DND_TYPE];

// =============================================================================
// 드래그 데이터 타입
// =============================================================================

/**
 * 인벤토리 아이템 드래그 데이터.
 * InventoryPanel에서 드래그 시작 시 설정됩니다.
 */
export interface InventoryDragData {
  /** 드래그 타입 (항상 'inventory-item') */
  type: typeof DND_TYPE.INVENTORY_ITEM;
  /** 드래그 중인 아이템 ID */
  item_id: string;
  /** 드래그 중인 아이템 객체 */
  item: InventoryItem;
}

// =============================================================================
// 드롭 데이터 타입
// =============================================================================

/**
 * 핫스팟 드롭 타겟 데이터.
 * SceneCanvas의 핫스팟에서 설정됩니다.
 */
export interface HotspotDropData {
  /** 드롭 타겟 타입 (항상 'hotspot') */
  type: typeof DND_TYPE.HOTSPOT;
  /** 핫스팟 오브젝트 ID */
  object_id: string;
  /** 핫스팟 바운딩 박스 (0~1000 정규화) */
  box_2d: Box2D;
  /** 핫스팟 라벨 (표시용) */
  label: string;
}

// =============================================================================
// 타입 가드 함수
// =============================================================================

/**
 * 데이터가 InventoryDragData인지 검사합니다.
 *
 * @param data - dnd-kit의 active.data.current
 * @returns InventoryDragData이면 true
 */
export function isInventoryDragData(data: unknown): data is InventoryDragData {
  if (typeof data !== 'object' || data === null) {
    return false;
  }
  const obj = data as Record<string, unknown>;
  return (
    obj.type === DND_TYPE.INVENTORY_ITEM &&
    typeof obj.item_id === 'string' &&
    typeof obj.item === 'object' &&
    obj.item !== null
  );
}

/**
 * 데이터가 HotspotDropData인지 검사합니다.
 *
 * @param data - dnd-kit의 over.data.current
 * @returns HotspotDropData이면 true
 */
export function isHotspotDropData(data: unknown): data is HotspotDropData {
  if (typeof data !== 'object' || data === null) {
    return false;
  }
  const obj = data as Record<string, unknown>;
  return (
    obj.type === DND_TYPE.HOTSPOT &&
    typeof obj.object_id === 'string' &&
    typeof obj.box_2d === 'object' &&
    obj.box_2d !== null &&
    typeof obj.label === 'string'
  );
}

// =============================================================================
// RU-003-S2 Step 2: 핫스팟 우선순위 정책 (SSOT)
// =============================================================================

/**
 * 바운딩 박스의 면적을 계산합니다.
 *
 * @param box - { ymin, xmin, ymax, xmax } 형식의 바운딩 박스
 * @returns 박스 면적
 */
export function calculateBoxArea(box: Box2D): number {
  const { ymin, xmin, ymax, xmax } = box;
  return Math.abs(ymax - ymin) * Math.abs(xmax - xmin);
}

/**
 * 핫스팟 우선순위 계산을 위한 비교 함수.
 *
 * RU-003-S2 Step 2: 작은 bbox가 더 높은 우선순위를 가짐
 * - 더 작은 오브젝트가 더 구체적인 타겟이라고 가정
 * - z-index 관점에서 작은 것이 위에 렌더되어야 함
 *
 * @param a - 첫 번째 바운딩 박스
 * @param b - 두 번째 바운딩 박스
 * @returns 정렬 순서 (작은 것이 뒤로 가서 z-index가 높아짐)
 */
export function compareHotspotPriority(a: Box2D, b: Box2D): number {
  return calculateBoxArea(b) - calculateBoxArea(a);
}
</file>

<file path="frontend/src/i18n.ts">
/**
 * Unknown World - i18n 초기화 모듈
 *
 * 언어 리소스를 JSON 파일 구조로 관리합니다.
 * RULE-006 준수: ko/en 혼합 출력 금지, i18n 키 기반 SSOT
 *
 * 언어 코드: BCP-47 형식 (ko-KR, en-US)
 * - TurnInput/SaveGame의 language 필드와 동일한 축
 *
 * @see vibe/prd.md 3.1(지원 언어), 8.7(TurnInput.language)
 * @see frontend/src/locales/README.md
 */

import i18n from 'i18next';
import { initReactI18next } from 'react-i18next';

// JSON 언어 리소스 import (SSOT: locales/{lang}/translation.json)
import koKR from './locales/ko-KR/translation.json';
import enUS from './locales/en-US/translation.json';

/** 지원 언어 타입 (TurnInput.language와 동기화) */
export type SupportedLanguage = 'ko-KR' | 'en-US';

/** 기본 언어 (데모 일관성을 위해 ko-KR 고정) */
export const DEFAULT_LANGUAGE: SupportedLanguage = 'ko-KR';

/** 폴백 언어 */
export const FALLBACK_LANGUAGE: SupportedLanguage = 'en-US';

/** 지원 언어 목록 */
export const SUPPORTED_LANGUAGES: SupportedLanguage[] = ['ko-KR', 'en-US'];

// i18n 리소스 정의 (BCP-47 형식 언어 코드)
const resources = {
  'ko-KR': {
    translation: koKR,
  },
  'en-US': {
    translation: enUS,
  },
};

i18n.use(initReactI18next).init({
  resources,
  lng: DEFAULT_LANGUAGE,
  fallbackLng: FALLBACK_LANGUAGE,
  supportedLngs: SUPPORTED_LANGUAGES,
  interpolation: {
    escapeValue: false, // React에서 이미 XSS 방지
  },
  // 누락 키 처리 (개발 모드에서 경고)
  saveMissing: false,
  missingKeyHandler: (_lngs, _ns, key) => {
    if (import.meta.env.DEV) {
      console.warn(`[i18n] Missing translation key: "${key}"`);
    }
  },
});

/**
 * 현재 해결된 언어 코드를 반환합니다.
 * TurnInput.language와 동기화할 때 사용합니다.
 */
export function getResolvedLanguage(): SupportedLanguage {
  return (i18n.resolvedLanguage as SupportedLanguage) || DEFAULT_LANGUAGE;
}

/**
 * 언어를 변경합니다.
 * 향후 U-036 완료 후 사용자에게 노출할 토글에서 사용합니다.
 */
export async function changeLanguage(lang: SupportedLanguage): Promise<void> {
  await i18n.changeLanguage(lang);
}

export default i18n;
</file>

<file path="frontend/src/main.tsx">
import { StrictMode } from 'react';
import { createRoot } from 'react-dom/client';
import './i18n'; // i18n 초기화
import './style.css';
import App from './App.tsx';

createRoot(document.getElementById('root')!).render(
  <StrictMode>
    <App />
  </StrictMode>,
);
</file>

<file path="frontend/src/stores/agentStore.test.ts">
import { describe, it, expect, beforeEach } from 'vitest';
import { useAgentStore } from './agentStore';
import { StreamEventType, StageStatus } from '../api/turnStream';
import type { TurnOutput } from '../schemas/turn';

describe('agentStore', () => {
  beforeEach(() => {
    useAgentStore.getState().reset();
  });

  it('should have correct initial state', () => {
    const state = useAgentStore.getState();
    expect(state.isStreaming).toBe(false);
    expect(state.phases).toHaveLength(7);
    expect(state.phases[0].status).toBe('pending');
    expect(state.badges).toEqual([]);
    expect(state.repairCount).toBe(0);
  });

  it('should handle startStream', () => {
    useAgentStore.getState().startStream();
    const state = useAgentStore.getState();
    expect(state.isStreaming).toBe(true);
  });

  it('should handle handleStage events', () => {
    const store = useAgentStore.getState();

    // Start parse phase
    store.handleStage({
      type: StreamEventType.STAGE,
      name: 'parse',
      status: StageStatus.START,
    });

    let state = useAgentStore.getState();
    expect(state.currentPhase).toBe('parse');
    expect(state.phases.find((p) => p.name === 'parse')?.status).toBe('in_progress');

    // Complete parse phase
    store.handleStage({
      type: StreamEventType.STAGE,
      name: 'parse',
      status: StageStatus.COMPLETE,
    });

    state = useAgentStore.getState();
    expect(state.phases.find((p) => p.name === 'parse')?.status).toBe('completed');
  });

  it('should handle handleBadges events', () => {
    const store = useAgentStore.getState();
    store.handleBadges({
      type: StreamEventType.BADGES,
      badges: ['schema_ok', 'economy_ok'],
    });

    const state = useAgentStore.getState();
    expect(state.badges).toEqual(['schema_ok', 'economy_ok']);
  });

  it('should handle handleNarrativeDelta events', () => {
    const store = useAgentStore.getState();
    store.handleNarrativeDelta({
      type: StreamEventType.NARRATIVE_DELTA,
      text: 'Hello ',
    });
    store.handleNarrativeDelta({
      type: StreamEventType.NARRATIVE_DELTA,
      text: 'World',
    });

    const state = useAgentStore.getState();
    expect(state.narrativeBuffer).toBe('Hello World');
  });

  it('should handle handleFinal events', () => {
    const store = useAgentStore.getState();
    const mockOutput = {
      language: 'ko-KR',
      narrative: 'Final message',
      economy: {
        cost: { signal: 0, memory_shard: 0 },
        balance_after: { signal: 100, memory_shard: 0 },
      },
      safety: { blocked: false, message: null },
      ui: { action_deck: { cards: [] }, objects: [], scene: { image_url: null, alt_text: null } },
      world: {
        rules_changed: [],
        inventory_added: [],
        inventory_removed: [],
        quests_updated: [],
        relationships_changed: [],
        memory_pins: [],
      },
      render: { image_job: null },
      agent_console: {
        repair_count: 2,
        current_phase: 'commit',
        badges: [],
      },
    } as TurnOutput;

    store.handleFinal({
      type: StreamEventType.FINAL,
      data: mockOutput,
    });

    const state = useAgentStore.getState();
    expect(state.finalOutput).toEqual(mockOutput);
    expect(state.repairCount).toBe(2);
  });

  it('should handle handleError events', () => {
    const store = useAgentStore.getState();
    store.handleError({
      type: StreamEventType.ERROR,
      message: 'Network error',
      code: 'ERR_NET',
    });

    const state = useAgentStore.getState();
    expect(state.error).toEqual({
      message: 'Network error',
      code: 'ERR_NET',
    });
  });

  it('should reset state on completeStream', () => {
    const store = useAgentStore.getState();
    store.handleNarrativeDelta({ type: StreamEventType.NARRATIVE_DELTA, text: 'Some text' });
    store.startStream();

    store.completeStream();

    const state = useAgentStore.getState();
    expect(state.isStreaming).toBe(false);
    expect(state.narrativeBuffer).toBe('');
  });
});
</file>

<file path="frontend/src/stores/uiPrefsStore.test.ts">
import { describe, it, expect, beforeEach } from 'vitest';
import { useUIPrefsStore, DEFAULT_UI_SCALE, migrateUIPrefs } from './uiPrefsStore';

// Mock localStorage for non-browser environment
// Note: With jsdom environment configured in vite.config.ts, this might not be strictly necessary
// if we trust jsdom's localStorage, but keeping it explicit is fine.
// However, since we are moving to direct function testing for migration, we rely less on persist middleware internals.

describe('uiPrefsStore', () => {
  beforeEach(() => {
    useUIPrefsStore.getState().resetPrefs();
    localStorage.clear();
  });

  it('should have default initial state', () => {
    const state = useUIPrefsStore.getState();
    expect(state.uiScale).toBe(DEFAULT_UI_SCALE);
  });

  it('should increase ui scale within limit', () => {
    const { increaseUIScale } = useUIPrefsStore.getState();

    // 1.0 -> 1.1
    increaseUIScale();
    expect(useUIPrefsStore.getState().uiScale).toBe(1.1);

    // 1.1 -> 1.2
    increaseUIScale();
    expect(useUIPrefsStore.getState().uiScale).toBe(1.2);

    // 1.2 -> 1.2 (Max)
    increaseUIScale();
    expect(useUIPrefsStore.getState().uiScale).toBe(1.2);
  });

  it('should decrease ui scale within limit', () => {
    const { decreaseUIScale, setUIScale } = useUIPrefsStore.getState();

    // Start at max
    setUIScale(1.2);

    // 1.2 -> 1.1
    decreaseUIScale();
    expect(useUIPrefsStore.getState().uiScale).toBe(1.1);

    // ... -> 0.9 (Min)
    setUIScale(0.9);
    decreaseUIScale();
    expect(useUIPrefsStore.getState().uiScale).toBe(0.9);
  });

  it('should set valid ui scale', () => {
    const { setUIScale } = useUIPrefsStore.getState();

    setUIScale(1.1);
    expect(useUIPrefsStore.getState().uiScale).toBe(1.1);
  });

  it('should ignore invalid ui scale', () => {
    const { setUIScale } = useUIPrefsStore.getState();

    // @ts-expect-error Testing invalid input
    setUIScale(2.0);
    expect(useUIPrefsStore.getState().uiScale).toBe(DEFAULT_UI_SCALE);
  });

  describe('migration (U-037)', () => {
    it('should remove readableMode from legacy storage', () => {
      // Legacy state simulation
      const legacyState = {
        uiScale: 1.1,
        readableMode: true,
      };

      // Call migrate function directly
      const migratedState = migrateUIPrefs(legacyState, 0);

      // Verify
      expect(migratedState).toHaveProperty('uiScale', 1.1);
      expect(migratedState).not.toHaveProperty('readableMode');
    });

    it('should handle undefined version (very old legacy)', () => {
      const legacyState = {
        uiScale: 0.9,
        readableMode: false,
      };

      // Call migrate function directly with undefined version
      const migratedState = migrateUIPrefs(legacyState, undefined);

      expect(migratedState).toHaveProperty('uiScale', 0.9);
      expect(migratedState).not.toHaveProperty('readableMode');
    });

    it('should pass through already migrated state', () => {
      const modernState = {
        uiScale: 1.0,
      };

      const migratedState = migrateUIPrefs(modernState, 1);
      expect(migratedState).toEqual(modernState);
    });
  });
});
</file>

<file path="frontend/src/stores/uiPrefsStore.ts">
/**
 * Unknown World - UI 설정 상태 관리 (Zustand + persist).
 *
 * UI 스케일 설정을 저장하고, SaveGame 구조와 통합 가능하도록 직렬화 인터페이스를 제공합니다.
 *
 * 설계 원칙:
 *   - PRD 9.4: 가독성(필수) - 전역 UI 스케일 조절 제공
 *   - U-037: Readable 모드 제거 → critical/ambient 중요도 기반 스타일로 대체
 *   - Q1 결정: Option B (SaveGame에 포함) - persist + 직렬화
 *
 * @module stores/uiPrefsStore
 */

import { create } from 'zustand';
import { persist, createJSONStorage } from 'zustand/middleware';

// =============================================================================
// 상수 정의
// =============================================================================

/** 지원하는 UI 스케일 값 */
export const UI_SCALES = [0.9, 1.0, 1.1, 1.2] as const;
export type UIScale = (typeof UI_SCALES)[number];

/** 기본 UI 스케일 */
export const DEFAULT_UI_SCALE: UIScale = 1.0;

/** localStorage 키 (SaveGame 통합 시에도 사용 가능) */
export const UI_PREFS_STORAGE_KEY = 'unknown-world-ui-prefs';

// =============================================================================
// 상태 타입 정의
// =============================================================================

/** UI 설정 상태 (SaveGame 직렬화 대상) */
export interface UIPrefsState {
  /**
   * UI 스케일 (0.9 ~ 1.2)
   * - 0.9: 작은 UI (정보 밀도 높음)
   * - 1.0: 기본
   * - 1.1: 약간 확대
   * - 1.2: 큰 UI (가독성 우선)
   */
  uiScale: UIScale;
}

/** UI 설정 액션 */
export interface UIPrefsActions {
  /** UI 스케일 설정 */
  setUIScale: (scale: UIScale) => void;

  /** UI 스케일 증가 (최대 1.2) */
  increaseUIScale: () => void;

  /** UI 스케일 감소 (최소 0.9) */
  decreaseUIScale: () => void;

  /** 설정 초기화 */
  resetPrefs: () => void;

  /**
   * SaveGame 직렬화용 상태 추출
   * (추후 SaveGame 통합 시 사용)
   */
  getSerializableState: () => UIPrefsState;

  /**
   * SaveGame 역직렬화용 상태 복원
   * (추후 SaveGame 통합 시 사용)
   */
  restoreState: (state: Partial<UIPrefsState>) => void;
}

export type UIPrefsStore = UIPrefsState & UIPrefsActions;

// =============================================================================
// 초기 상태
// =============================================================================

/** 초기 상태 생성 */
function createInitialState(): UIPrefsState {
  return {
    uiScale: DEFAULT_UI_SCALE,
  };
}

// =============================================================================
// 유틸리티 함수
// =============================================================================

/**
 * 주어진 스케일이 유효한지 확인
 */
function isValidScale(scale: number): scale is UIScale {
  return UI_SCALES.includes(scale as UIScale);
}

/**
 * 스케일 인덱스 반환
 */
function getScaleIndex(scale: UIScale): number {
  return UI_SCALES.indexOf(scale);
}

/**
 * U-037: legacy 저장값(readableMode) 마이그레이션/무시
 * @internal exported for testing
 */
export function migrateUIPrefs(persistedState: unknown, version: number | undefined): UIPrefsState {
  // version 0 또는 undefined에서 version 1로 마이그레이션
  // readableMode 필드가 있으면 제거
  if (version === 0 || version === undefined) {
    const state = persistedState as Record<string, unknown>;
    // readableMode 필드 제거 (무시)
    if ('readableMode' in state) {
      const { readableMode: _, ...rest } = state;
      return { ...rest, uiScale: state.uiScale ?? DEFAULT_UI_SCALE } as UIPrefsState;
    }
    return { ...state, uiScale: state.uiScale ?? DEFAULT_UI_SCALE } as UIPrefsState;
  }
  return persistedState as UIPrefsState;
}

// =============================================================================
// Zustand Store with persist
// =============================================================================

/**
 * UI 설정 스토어.
 *
 * U-037: Readable 모드 제거됨. CRT 효과는 critical/ambient 중요도 기반으로 자동 적용됩니다.
 *
 * @example
 * ```tsx
 * // 컴포넌트에서 사용
 * const { uiScale, setUIScale } = useUIPrefsStore();
 *
 * // DOM 적용 (App.tsx에서)
 * useEffect(() => {
 *   document.documentElement.dataset.uiScale = uiScale.toString();
 *   document.documentElement.style.setProperty('--ui-scale-factor', uiScale.toString());
 * }, [uiScale]);
 * ```
 */
export const useUIPrefsStore = create<UIPrefsStore>()(
  persist(
    (set, get) => ({
      // 초기 상태
      ...createInitialState(),

      // 액션
      setUIScale: (scale) => {
        if (isValidScale(scale)) {
          set({ uiScale: scale });
        }
      },

      increaseUIScale: () => {
        const currentIndex = getScaleIndex(get().uiScale);
        const nextIndex = Math.min(currentIndex + 1, UI_SCALES.length - 1);
        set({ uiScale: UI_SCALES[nextIndex] });
      },

      decreaseUIScale: () => {
        const currentIndex = getScaleIndex(get().uiScale);
        const prevIndex = Math.max(currentIndex - 1, 0);
        set({ uiScale: UI_SCALES[prevIndex] });
      },

      resetPrefs: () => {
        set(createInitialState());
      },

      getSerializableState: () => {
        const { uiScale } = get();
        return { uiScale };
      },

      restoreState: (state) => {
        const updates: Partial<UIPrefsState> = {};

        if (state.uiScale !== undefined && isValidScale(state.uiScale)) {
          updates.uiScale = state.uiScale;
        }

        if (Object.keys(updates).length > 0) {
          set(updates);
        }
      },
    }),
    {
      name: UI_PREFS_STORAGE_KEY,
      storage: createJSONStorage(() => localStorage),
      // 직렬화할 필드 지정 (액션 제외)
      partialize: (state) => ({
        uiScale: state.uiScale,
      }),
      // U-037: legacy 저장값(readableMode) 마이그레이션/무시
      version: 1,
      migrate: migrateUIPrefs,
    },
  ),
);

// =============================================================================
// 셀렉터 (성능 최적화용)
// =============================================================================

/** UI 스케일 셀렉터 */
export const selectUIScale = (state: UIPrefsStore) => state.uiScale;

// =============================================================================
// DOM 적용 헬퍼
// =============================================================================

/**
 * CSS 변수로 UI 스케일 적용
 * 호출 시 html 요소에 --ui-scale-factor 변수를 설정
 */
export function applyUIScaleToDOM(scale: UIScale): void {
  document.documentElement.style.setProperty('--ui-scale-factor', scale.toString());
  document.documentElement.dataset.uiScale = scale.toString();
}

/**
 * 전체 UI 설정 DOM 적용
 * U-037: readableMode 제거됨 - 스케일만 적용
 */
export function applyUIPrefsToDOM(state: UIPrefsState): void {
  applyUIScaleToDOM(state.uiScale);
}
</file>

<file path="frontend/tsconfig.json">
{
  "compilerOptions": {
    "target": "ES2022",
    "useDefineForClassFields": true,
    "lib": ["ES2022", "DOM", "DOM.Iterable"],
    "module": "ESNext",
    "skipLibCheck": true,

    /* Bundler mode */
    "moduleResolution": "Bundler",
    "allowImportingTsExtensions": true,
    "isolatedModules": true,
    "moduleDetection": "force",
    "noEmit": true,
    "jsx": "react-jsx",

    /* Linting (엄격 모드) */
    "strict": true,
    "noUnusedLocals": true,
    "noUnusedParameters": true,
    "noFallthroughCasesInSwitch": true,
    "noUncheckedSideEffectImports": true
  },
  "include": ["src"],
  "references": [{ "path": "./tsconfig.node.json" }]
}
</file>

<file path="backend/src/unknown_world/__init__.py">
"""Unknown World - Backend Package

This is the main package for the Unknown World backend.
Architecture: FastAPI + Pydantic + SSE streaming

Reference:
- vibe/tech-stack.md (Python 3.14, FastAPI 0.128.0, Pydantic 2.12.5)
- vibe/prd.md (Agent-based Game Master Engine)
"""

__version__ = "0.1.0"
</file>

<file path="backend/src/unknown_world/main.py">
"""Unknown World - FastAPI 애플리케이션 엔트리포인트

이 모듈은 Unknown World 백엔드의 FastAPI 앱을 정의합니다.
MVP 단계에서는 기본 헬스체크와 개발용 CORS 설정만 포함합니다.

실행 방법:
    cd backend
    uv sync
    uv run uvicorn unknown_world.main:app --reload --port 8011

참조:
    - vibe/tech-stack.md (버전 SSOT)
    - vibe/prd.md (에이전트형 게임 엔진 요구사항)
    - .cursor/rules/20-backend-orchestrator.mdc (SSE/검증/복구 규칙)
"""

from typing import Literal

from fastapi import FastAPI
from fastapi.middleware.cors import CORSMiddleware
from pydantic import BaseModel

from unknown_world import __version__
from unknown_world.api import turn_router

# =============================================================================
# FastAPI 앱 인스턴스
# =============================================================================

app = FastAPI(
    title="Unknown World API",
    description="Gemini 기반 에이전트형 게임 엔진 오케스트레이터",
    version=__version__,
    docs_url="/docs",
    redoc_url="/redoc",
)

# =============================================================================
# CORS 설정 (개발 환경용)
# =============================================================================
# PRD 요구: 로컬 개발에서 프론트와 통신할 수 있도록 CORS 기본 정책 준비
# RULE-011: 프론트엔드는 8001~8010 포트 사용
# 주의: 프로덕션에서는 MMP 단계에서 엄격한 정책으로 변경해야 함

ALLOWED_ORIGINS = [
    # 프론트엔드 개발 서버 포트 범위 (RULE-011: 8001~8010)
    *[f"http://localhost:{port}" for port in range(8001, 8011)],
    *[f"http://127.0.0.1:{port}" for port in range(8001, 8011)],
]

app.add_middleware(
    CORSMiddleware,
    allow_origins=ALLOWED_ORIGINS,
    allow_credentials=True,
    allow_methods=["*"],
    allow_headers=["*"],
)

# =============================================================================
# 라우터 등록
# =============================================================================

# U-007: /api/turn HTTP Streaming 엔드포인트
app.include_router(turn_router)


# =============================================================================
# 응답 스키마 (Pydantic)
# =============================================================================


class HealthResponse(BaseModel):
    """헬스체크 응답 스키마.

    Attributes:
        status: 서버 상태 ("ok" 또는 "degraded")
        version: 백엔드 버전
        service: 서비스 이름
    """

    status: Literal["ok", "degraded"]
    version: str
    service: str


# =============================================================================
# 라우트 정의
# =============================================================================


@app.get("/health", response_model=HealthResponse, tags=["System"])
async def health_check() -> HealthResponse:
    """서버 헬스체크 엔드포인트.

    서버가 정상적으로 작동 중인지 확인합니다.
    이 엔드포인트는 로드밸런서, 모니터링 시스템, 클라이언트 연결 확인에 사용됩니다.

    Returns:
        HealthResponse: 서버 상태 정보
    """
    return HealthResponse(
        status="ok",
        version=__version__,
        service="unknown-world-backend",
    )


@app.get("/", tags=["System"])
async def root() -> dict[str, str]:
    """루트 엔드포인트.

    API 정보를 간략히 안내합니다.

    Returns:
        dict: 기본 안내 메시지
    """
    return {
        "message": "Unknown World API",
        "docs": "/docs",
        "health": "/health",
    }
</file>

<file path="backend/src/unknown_world/orchestrator/mock.py">
"""Unknown World - 모의 Orchestrator.

실모델(Gemini) 없이 프론트엔드 개발/데모를 지속할 수 있도록
결정적(seed 기반) TurnOutput을 생성하는 모의 Orchestrator입니다.

설계 원칙:
    - RULE-004: 검증 실패 시 안전한 폴백 제공
    - RULE-005: 재화 인바리언트 (잔액 음수 금지)
    - RULE-008: 단계/배지 가시화
    - RULE-009: 좌표 규약 (0~1000, bbox [ymin,xmin,ymax,xmax])

참조:
    - vibe/unit-plans/U-007[Mvp].md
    - .cursor/rules/20-backend-orchestrator.mdc
"""

import random

from unknown_world.models.turn import (
    ActionCard,
    ActionDeck,
    AgentConsole,
    AgentPhase,
    Box2D,
    CurrencyAmount,
    EconomyOutput,
    ImageJob,
    Language,
    MemoryPin,
    ModelLabel,
    Quest,
    RenderOutput,
    RiskLevel,
    SafetyOutput,
    SceneObject,
    TurnInput,
    TurnOutput,
    UIOutput,
    ValidationBadge,
    WorldDelta,
    WorldRule,
)

# =============================================================================
# 모의 데이터 생성 헬퍼
# =============================================================================

# 한국어 내러티브 템플릿
KO_NARRATIVES = [
    "어둠 속에서 희미한 빛이 새어나옵니다. 오래된 문이 삐걱거리며 열리고, 그 너머로 알 수 없는 세계가 펼쳐집니다.",
    "발걸음 소리가 텅 빈 복도에 메아리칩니다. 벽에 걸린 초상화들의 눈이 당신을 따라 움직이는 것 같습니다.",
    "갑자기 바닥이 흔들리며, 벽에서 고대의 문자들이 빛나기 시작합니다. 무언가가 깨어나고 있습니다.",
    "안개가 걷히자, 거대한 탑이 모습을 드러냅니다. 탑 꼭대기에서 이상한 빛이 깜빡이고 있습니다.",
    "낡은 책장을 밀자, 숨겨진 통로가 나타났습니다. 통로 끝에서 기묘한 노래가 들려옵니다.",
]

# 영어 내러티브 템플릿
EN_NARRATIVES = [
    "A faint light seeps through the darkness. An ancient door creaks open, revealing an unknown world beyond.",
    "Footsteps echo through the empty corridor. The eyes of the portraits on the walls seem to follow you.",
    "Suddenly, the ground shakes and ancient runes on the walls begin to glow. Something is awakening.",
    "As the fog lifts, a massive tower reveals itself. A strange light flickers at its peak.",
    "Pushing aside the old bookshelf, you discover a hidden passage. An eerie song emanates from its depths.",
]

# 한국어 액션 카드 템플릿
KO_ACTION_CARDS = [
    {"label": "문을 열어본다", "description": "조심스럽게 문을 열어 안을 살펴본다"},
    {"label": "주변을 탐색한다", "description": "주변에 유용한 물건이 있는지 찾아본다"},
    {"label": "뒤로 물러선다", "description": "위험을 피해 안전한 곳으로 물러선다"},
    {"label": "말을 걸어본다", "description": "상대방에게 조심스럽게 말을 건다"},
    {"label": "숨어서 지켜본다", "description": "은신하여 상황을 관찰한다"},
    {"label": "공격한다", "description": "위협에 맞서 공격을 시도한다"},
]

# 영어 액션 카드 템플릿
EN_ACTION_CARDS = [
    {"label": "Open the door", "description": "Carefully open the door and look inside"},
    {"label": "Search the area", "description": "Look for useful items nearby"},
    {"label": "Step back", "description": "Retreat to a safe place to avoid danger"},
    {"label": "Speak to them", "description": "Cautiously initiate conversation"},
    {"label": "Hide and observe", "description": "Conceal yourself and watch the situation"},
    {"label": "Attack", "description": "Confront the threat with an attack"},
]

# 장면 오브젝트 템플릿
SCENE_OBJECTS_KO = [
    {"label": "낡은 문", "hint": "클릭하여 열어볼 수 있습니다"},
    {"label": "빛나는 보석", "hint": "수집할 수 있을 것 같습니다"},
    {"label": "수상한 상자", "hint": "무언가 들어있을 수 있습니다"},
    {"label": "벽의 스위치", "hint": "작동시킬 수 있습니다"},
]

SCENE_OBJECTS_EN = [
    {"label": "Old door", "hint": "Click to open"},
    {"label": "Glowing gem", "hint": "It looks collectible"},
    {"label": "Suspicious chest", "hint": "Something might be inside"},
    {"label": "Wall switch", "hint": "Can be activated"},
]


def _generate_random_box(rng: random.Random) -> Box2D:
    """랜덤 바운딩 박스 생성 (0~1000 좌표계)."""
    ymin = rng.randint(0, 700)
    xmin = rng.randint(0, 700)
    ymax = ymin + rng.randint(50, 250)
    xmax = xmin + rng.randint(50, 250)
    # 범위 보정
    ymax = min(ymax, 1000)
    xmax = min(xmax, 1000)
    return Box2D(ymin=ymin, xmin=xmin, ymax=ymax, xmax=xmax)


# =============================================================================
# MockOrchestrator 클래스
# =============================================================================


class MockOrchestrator:
    """모의 Orchestrator.

    실모델(Gemini) 없이 TurnOutput을 생성하는 모의 오케스트레이터입니다.
    seed 기반으로 결정적(재현 가능)인 결과를 생성합니다.

    Attributes:
        seed: 랜덤 시드 (재현성 보장)

    Example:
        >>> orchestrator = MockOrchestrator(seed=42)
        >>> turn_input = TurnInput(
        ...     language=Language.KO,
        ...     text="문을 열어본다",
        ...     client=ClientInfo(viewport_w=1920, viewport_h=1080),
        ...     economy_snapshot=EconomySnapshot(signal=100, memory_shard=5),
        ... )
        >>> output = orchestrator.generate_turn_output(turn_input)
    """

    # 단계 목록 (PRD 예시)
    PHASES = [
        AgentPhase.PARSE,
        AgentPhase.VALIDATE,
        AgentPhase.PLAN,
        AgentPhase.RESOLVE,
        AgentPhase.RENDER,
        AgentPhase.VERIFY,
        AgentPhase.COMMIT,
    ]

    def __init__(self, seed: int | None = None) -> None:
        """MockOrchestrator 초기화.

        Args:
            seed: 랜덤 시드. None이면 랜덤하게 생성.
        """
        self.seed = seed if seed is not None else random.randint(0, 2**32 - 1)
        self._rng = random.Random(self.seed)

    def generate_turn_output(self, turn_input: TurnInput) -> TurnOutput:
        """TurnInput을 받아 TurnOutput을 생성합니다.

        Args:
            turn_input: 사용자 입력

        Returns:
            TurnOutput: 모의 턴 결과
        """
        is_korean = turn_input.language == Language.KO

        # 내러티브 생성
        narratives = KO_NARRATIVES if is_korean else EN_NARRATIVES
        narrative = self._rng.choice(narratives)

        # 사용자 텍스트가 있으면 반영
        if turn_input.text:
            prefix = (
                f'당신은 "{turn_input.text}"라고 말했습니다. '
                if is_korean
                else f'You said "{turn_input.text}". '
            )
            narrative = prefix + narrative

        # 액션 덱 생성 (3~6장)
        action_templates = KO_ACTION_CARDS if is_korean else EN_ACTION_CARDS
        num_cards = self._rng.randint(3, 6)
        selected_templates = self._rng.sample(
            action_templates, min(num_cards, len(action_templates))
        )

        action_cards: list[ActionCard] = []
        for i, template in enumerate(selected_templates):
            cost_signal = self._rng.randint(1, 10)
            cost_shard = 1 if self._rng.random() < 0.2 else 0  # 20% 확률로 shard 소비

            action_cards.append(
                ActionCard(
                    id=f"action_{i + 1}",
                    label=template["label"],
                    description=template["description"],
                    cost=CurrencyAmount(signal=cost_signal, memory_shard=cost_shard),
                    risk=self._rng.choice(list(RiskLevel)),
                    hint=None,
                )
            )

        action_deck = ActionDeck(cards=action_cards)

        # 장면 오브젝트 생성 (1~3개)
        object_templates = SCENE_OBJECTS_KO if is_korean else SCENE_OBJECTS_EN
        num_objects = self._rng.randint(1, 3)
        selected_objects = self._rng.sample(
            object_templates, min(num_objects, len(object_templates))
        )

        scene_objects: list[SceneObject] = []
        for i, template in enumerate(selected_objects):
            scene_objects.append(
                SceneObject(
                    id=f"obj_{i + 1}",
                    label=template["label"],
                    box_2d=_generate_random_box(self._rng),
                    interaction_hint=template["hint"],
                )
            )

        ui_output = UIOutput(action_deck=action_deck, objects=scene_objects)

        # 세계 상태 변화 (delta)
        world_delta = self._generate_world_delta(is_korean)

        # 렌더링 출력 (이미지 생성은 선택적)
        should_generate_image = self._rng.random() < 0.3  # 30% 확률로 이미지 생성
        render_output = RenderOutput(
            image_job=ImageJob(
                should_generate=should_generate_image,
                prompt="A mysterious dungeon scene" if should_generate_image else "",
                model_label=ModelLabel.FAST,
                aspect_ratio="16:9",
                image_size="1024x576",
            )
            if should_generate_image
            else None
        )

        # 경제 출력 (비용 계산)
        turn_cost = CurrencyAmount(
            signal=self._rng.randint(1, 5),
            memory_shard=0,
        )

        # 잔액 계산 (음수 방지 - RULE-005)
        balance_signal = max(0, turn_input.economy_snapshot.signal - turn_cost.signal)
        balance_shard = max(0, turn_input.economy_snapshot.memory_shard - turn_cost.memory_shard)

        economy_output = EconomyOutput(
            cost=turn_cost,
            balance_after=CurrencyAmount(signal=balance_signal, memory_shard=balance_shard),
        )

        # 안전 출력
        safety_output = SafetyOutput(blocked=False, message=None)

        # 에이전트 콘솔
        agent_console = AgentConsole(
            current_phase=AgentPhase.COMMIT,
            badges=[
                ValidationBadge.SCHEMA_OK,
                ValidationBadge.ECONOMY_OK,
                ValidationBadge.SAFETY_OK,
                ValidationBadge.CONSISTENCY_OK,
            ],
            repair_count=0,
        )

        return TurnOutput(
            language=turn_input.language,
            narrative=narrative,
            ui=ui_output,
            world=world_delta,
            render=render_output,
            economy=economy_output,
            safety=safety_output,
            agent_console=agent_console,
        )

    def _generate_world_delta(self, is_korean: bool) -> WorldDelta:
        """세계 상태 변화 생성."""
        # 규칙 변경 (20% 확률)
        rules_changed: list[WorldRule] = []
        if self._rng.random() < 0.2:
            rules_changed.append(
                WorldRule(
                    id="rule_gravity",
                    label="중력 반전" if is_korean else "Gravity Inversion",
                    description=(
                        "이 구역에서는 중력이 반대로 작용합니다"
                        if is_korean
                        else "Gravity works in reverse in this area"
                    ),
                )
            )

        # 인벤토리 추가 (30% 확률)
        inventory_added: list[str] = []
        if self._rng.random() < 0.3:
            items_ko = ["낡은 열쇠", "신비로운 구슬", "고대의 두루마리"]
            items_en = ["Old Key", "Mysterious Orb", "Ancient Scroll"]
            items = items_ko if is_korean else items_en
            inventory_added.append(self._rng.choice(items))

        # 퀘스트 업데이트 (25% 확률)
        quests_updated: list[Quest] = []
        if self._rng.random() < 0.25:
            quests_updated.append(
                Quest(
                    id="quest_explore",
                    label="미지의 영역 탐험" if is_korean else "Explore Unknown Territory",
                    is_completed=self._rng.random() < 0.3,
                )
            )

        # 메모리 핀 (15% 확률)
        memory_pins: list[MemoryPin] = []
        if self._rng.random() < 0.15:
            memory_pins.append(
                MemoryPin(
                    id="pin_1",
                    content="이 장소의 이름은 '잊혀진 성소'"
                    if is_korean
                    else "This place is called 'Forgotten Sanctuary'",
                    cost=CurrencyAmount(signal=0, memory_shard=1),
                )
            )

        return WorldDelta(
            rules_changed=rules_changed,
            inventory_added=inventory_added,
            inventory_removed=[],
            quests_updated=quests_updated,
            relationships_changed=[],
            memory_pins=memory_pins,
        )

    def create_safe_fallback(
        self,
        language: Language,
        error_message: str | None = None,
        economy_snapshot: CurrencyAmount | None = None,
    ) -> TurnOutput:
        """안전한 폴백 TurnOutput 생성 (RULE-004, RU-002-S1).

        스키마 검증 실패 시 반환할 안전한 기본 응답입니다.
        폴백 시 economy.balance_after는 입력 스냅샷을 그대로 유지합니다 (비용 0, 잔액 변화 없음).

        Args:
            language: 응답 언어
            error_message: 에러 메시지 (내부용, UI에 노출하지 않음)
            economy_snapshot: 요청 직전 재화 스냅샷 (폴백 시 잔액 유지용)

        Returns:
            TurnOutput: 안전한 폴백 응답
        """
        is_korean = language == Language.KO

        narrative = (
            "잠시 혼란이 있었습니다. 다시 시도해주세요."
            if is_korean
            else "There was a momentary confusion. Please try again."
        )

        # RU-002-S1: 폴백 시 입력 스냅샷 그대로 유지 (비용 0, 잔액 변화 없음)
        balance_after = (
            economy_snapshot
            if economy_snapshot is not None
            else CurrencyAmount(signal=100, memory_shard=5)  # 기본값 (스냅샷 없을 때만)
        )

        return TurnOutput(
            language=language,
            narrative=narrative,
            ui=UIOutput(action_deck=ActionDeck(cards=[]), objects=[]),
            world=WorldDelta(),
            render=RenderOutput(image_job=None),
            economy=EconomyOutput(
                cost=CurrencyAmount(signal=0, memory_shard=0),
                balance_after=balance_after,
            ),
            safety=SafetyOutput(blocked=False, message=None),
            agent_console=AgentConsole(
                current_phase=AgentPhase.COMMIT,
                badges=[ValidationBadge.SCHEMA_FAIL],  # 실패 표시
                repair_count=1,  # 복구 시도 횟수
            ),
        )
</file>

<file path="frontend/src/App.test.tsx">
import { describe, it, expect, vi, beforeEach } from 'vitest';
import { render, screen, fireEvent } from '@testing-library/react';
import App from './App';
import * as turnStream from './api/turnStream';

// i18next 모킹 (RU-003-Q5: 데모 i18n 키 지원)
vi.mock('react-i18next', () => ({
  useTranslation: () => ({
    t: (key: string, options?: Record<string, unknown>) => {
      // 데모 아이템 이름
      if (key === 'demo.items.keycard-alpha.name') return '키카드 A';
      if (key === 'demo.items.medkit.name') return '응급 키트';
      if (key === 'demo.items.flashlight.name') return '손전등';
      if (key === 'demo.items.data-chip.name') return '데이터칩';
      // 데모 씬 오브젝트
      if (key === 'demo.scene.terminal.label') return '터미널';
      if (key === 'demo.scene.terminal.hint') return '활성화된 터미널이다';
      if (key === 'demo.scene.door.label') return '문';
      if (key === 'demo.scene.door.hint') return '잠겨있는 것 같다';
      // 액션 템플릿
      if (key === 'scene.hotspot.click_action') {
        return `Click: ${options?.label}`;
      }
      return key;
    },
    i18n: {
      changeLanguage: () => Promise.resolve(),
      resolvedLanguage: 'ko-KR',
    },
  }),
  initReactI18next: {
    type: '3rdParty',
    init: () => {},
  },
}));

// ResizeObserver 모킹
class MockResizeObserver {
  observe = vi.fn();
  unobserve = vi.fn();
  disconnect = vi.fn();
}
global.ResizeObserver = MockResizeObserver as unknown as typeof ResizeObserver;

// getBoundingClientRect 모킹
Element.prototype.getBoundingClientRect = vi.fn(() => ({
  width: 800,
  height: 600,
  top: 0,
  left: 0,
  bottom: 600,
  right: 800,
  x: 0,
  y: 0,
  toJSON: () => {},
})) as unknown as () => DOMRect;

// api 모킹
vi.mock('./api/turnStream', () => ({
  startTurnStream: vi.fn(),
}));

describe('App Integration - Hotspot Click', () => {
  beforeEach(() => {
    vi.clearAllMocks();
  });

  it('should trigger startTurnStream when a hotspot is clicked', async () => {
    render(<App />);

    // 데모용으로 App.tsx에 하드코딩된 '터미널' 핫스팟 찾기
    const terminalHotspot = screen.getByLabelText('터미널');
    expect(terminalHotspot).toBeInTheDocument();

    // 클릭 시뮬레이션
    fireEvent.click(terminalHotspot);

    // startTurnStream 호출 확인
    expect(turnStream.startTurnStream).toHaveBeenCalled();

    const [input] = vi.mocked(turnStream.startTurnStream).mock.calls[0];

    // TurnInput 검증
    expect(input.text).toBe('Click: 터미널');
    expect(input.click).toEqual({
      object_id: 'demo-terminal',
      box_2d: { ymin: 300, xmin: 100, ymax: 600, xmax: 400 },
    });
  });
});
</file>

<file path="frontend/src/components/ActionDeck.test.tsx">
import { describe, it, expect, vi, beforeEach } from 'vitest';
import { render, screen, fireEvent } from '@testing-library/react';
import { ActionDeck } from './ActionDeck';
import type { ActionCard } from '../schemas/turn';
import { useActionDeckStore } from '../stores/actionDeckStore';
import { useWorldStore } from '../stores/worldStore';
import { useAgentStore } from '../stores/agentStore';

// i18next 모킹
vi.mock('react-i18next', () => ({
  useTranslation: () => ({
    t: (key: string, params?: Record<string, unknown>) => {
      if (params?.turn !== undefined) return `Turn ${params.turn}`;
      if (key === 'action.risk.low') return 'Low';
      if (key === 'action.risk.medium') return 'Medium';
      if (key === 'action.risk.high') return 'High';
      if (key === 'action.insufficient_balance') return 'Insufficient Balance';
      if (key === 'action.alternative') return 'Alt';
      return key;
    },
  }),
}));

describe('ActionDeck Component', () => {
  const mockCards: ActionCard[] = [
    {
      id: 'card-1',
      label: 'Regular Action',
      description: 'Test Description',
      cost: { signal: 10, memory_shard: 0 },
      cost_estimate: {
        min: { signal: 8, memory_shard: 0 },
        max: { signal: 12, memory_shard: 0 },
      },
      risk: 'low',
      hint: 'Positive hint',
      reward_hint: 'Bonus item',
      enabled: true,
      disabled_reason: null,
      is_alternative: false,
    },
    {
      id: 'card-2',
      label: 'Expensive Action',
      description: null,
      cost: { signal: 50, memory_shard: 1 },
      cost_estimate: null,
      risk: 'high',
      hint: 'Risky hint',
      reward_hint: null,
      enabled: true,
      disabled_reason: null,
      is_alternative: false,
    },
    {
      id: 'card-alt',
      label: 'Alternative Action',
      description: null,
      cost: { signal: 2, memory_shard: 0 },
      cost_estimate: null,
      risk: 'low',
      hint: null,
      reward_hint: null,
      enabled: true,
      disabled_reason: null,
      is_alternative: true,
    },
  ];

  beforeEach(() => {
    // 스토어 초기화
    useActionDeckStore.setState({ cards: [] });
    useWorldStore.setState({ economy: { signal: 100, memory_shard: 5 } });
    useAgentStore.setState({ isStreaming: false });
  });

  it('renders provided cards from store', () => {
    useActionDeckStore.setState({ cards: mockCards });
    render(<ActionDeck />);
    expect(screen.getByText('Regular Action')).toBeInTheDocument();
    expect(screen.getByText('Expensive Action')).toBeInTheDocument();
    expect(screen.getByText('Alternative Action')).toBeInTheDocument();
  });

  it('displays cost estimates as ranges when available', () => {
    useActionDeckStore.setState({ cards: mockCards });
    render(<ActionDeck />);
    // card-1 has cost_estimate: 8~12
    expect(screen.getByText('8~12')).toBeInTheDocument();
    // card-2 has cost: 50
    expect(screen.getByText('50')).toBeInTheDocument();
  });

  it('disables cards when balance is insufficient in worldStore', () => {
    useActionDeckStore.setState({ cards: mockCards });
    useWorldStore.setState({ economy: { signal: 5, memory_shard: 0 } });

    render(<ActionDeck />);

    // Regular Action (cost 10/estimate max 12) -> disabled
    const card1 = screen.getByRole('button', { name: /Regular Action/i });
    expect(card1).toBeDisabled();
    expect(screen.getAllByText('Insufficient Balance').length).toBeGreaterThan(0);

    // Alternative Action (cost 2) -> enabled
    const cardAlt = screen.getByRole('button', { name: /Alternative Action/i });
    expect(cardAlt).not.toBeDisabled();
  });

  it('renders alternative badge for alternative cards', () => {
    useActionDeckStore.setState({ cards: mockCards });
    render(<ActionDeck />);
    expect(screen.getByText('Alt')).toBeInTheDocument();
  });

  it('calls onCardClick when an enabled card is clicked', () => {
    const onCardClick = vi.fn();
    useActionDeckStore.setState({ cards: mockCards });
    render(<ActionDeck onCardClick={onCardClick} />);

    fireEvent.click(screen.getByText('Regular Action'));
    expect(onCardClick).toHaveBeenCalledWith(expect.objectContaining({ id: 'card-1' }));
  });

  it('displays server-provided disabled reason', () => {
    const disabledCard: ActionCard[] = [
      {
        ...mockCards[0],
        enabled: false,
        disabled_reason: 'Locked by story',
      },
    ];
    useActionDeckStore.setState({ cards: disabledCard });
    render(<ActionDeck />);
    expect(screen.getByText('Locked by story')).toBeInTheDocument();
  });

  it('renders default cards when store cards are empty', () => {
    useActionDeckStore.setState({ cards: [] });
    render(<ActionDeck />);
    // useDefaultCards should provide some default labels
    expect(screen.getByText('action.default.explore.label')).toBeInTheDocument();
  });

  it('disables all cards when isStreaming is true in agentStore', () => {
    useActionDeckStore.setState({ cards: mockCards });
    useAgentStore.setState({ isStreaming: true });

    render(<ActionDeck />);

    const card1 = screen.getByRole('button', { name: /Regular Action/i });
    const cardAlt = screen.getByRole('button', { name: /Alternative Action/i });

    expect(card1).toBeDisabled();
    expect(cardAlt).toBeDisabled();
  });
});
</file>

<file path="frontend/src/components/DndInteraction.test.tsx">
import React from 'react';
import { describe, it, expect, vi, beforeEach } from 'vitest';
import { render, screen, act } from '@testing-library/react';
import App from '../App';
import * as turnStream from '../api/turnStream';

// dnd-kit 모킹용 타입
interface MockDndCallbacks {
  onDragEnd: (event: {
    active: { id: string; data: { current: unknown } };
    over: { id: string; data: { current: unknown } } | null;
  }) => void;
}

// dnd-kit 모킹 (콜백 가로채기용)
vi.mock('@dnd-kit/core', async () => {
  const actual = (await vi.importActual('@dnd-kit/core')) as Record<string, unknown>;
  return {
    ...actual,
    DndContext: (props: MockDndCallbacks & { children: React.ReactNode }) => {
      // 콜백 저장 (테스트에서 접근 가능하도록 global에 저장)
      (global as unknown as Record<string, unknown>).dndCallbacks = props;
      return <div data-testid="mock-dnd-context">{props.children}</div>;
    },
  };
});

// i18next 모킹 (RU-003-Q5: 데모 i18n 키 지원)
vi.mock('react-i18next', () => ({
  useTranslation: () => ({
    t: (key: string, options?: Record<string, unknown>) => {
      // 데모 아이템 이름
      if (key === 'demo.items.keycard-alpha.name') return '키카드 A';
      if (key === 'demo.items.medkit.name') return '응급 키트';
      if (key === 'demo.items.flashlight.name') return '손전등';
      if (key === 'demo.items.data-chip.name') return '데이터칩';
      // 데모 씬 오브젝트
      if (key === 'demo.scene.terminal.label') return '터미널';
      if (key === 'demo.scene.terminal.hint') return '활성화된 터미널이다';
      if (key === 'demo.scene.door.label') return '문';
      if (key === 'demo.scene.door.hint') return '잠겨있는 것 같다';
      // 액션 템플릿
      if (key === 'inventory.item_label') return `Item: ${options?.name}`;
      if (key === 'scene.hotspot.drop_action') {
        return `Drop: ${options?.item} on ${options?.target}`;
      }
      if (key === 'scene.hotspot.drop_invalid') {
        return `Invalid: ${options?.item}`;
      }
      if (key === 'connection.online') return 'ONLINE';
      return key;
    },
    i18n: {
      changeLanguage: () => Promise.resolve(),
      resolvedLanguage: 'ko-KR',
    },
  }),
  initReactI18next: {
    type: '3rdParty',
    init: () => {},
  },
}));

// ResizeObserver 모킹
class MockResizeObserver {
  observe = vi.fn();
  unobserve = vi.fn();
  disconnect = vi.fn();
}
global.ResizeObserver = MockResizeObserver as unknown as typeof ResizeObserver;
window.ResizeObserver = MockResizeObserver as unknown as typeof ResizeObserver;

// api 모킹
vi.mock('../api/turnStream', () => ({
  startTurnStream: vi.fn(),
}));

describe('DnD Interaction - Logic Test', () => {
  beforeEach(() => {
    vi.clearAllMocks();
  });

  it('should trigger turn execution when handleDragEnd is called with a hotspot target', async () => {
    render(<App />);
    const dndCallbacks = (global as unknown as Record<string, MockDndCallbacks>).dndCallbacks;

    // RU-003-Q1: 드래그 데이터에 item 객체 포함 (타입 가드 요구사항)
    const mockItem = {
      id: 'keycard-alpha',
      name: '키카드 A',
      icon: '🔑',
      quantity: 1,
    };

    // 성공 시나리오 시뮬레이션
    act(() => {
      dndCallbacks.onDragEnd({
        active: {
          id: 'keycard-alpha',
          data: {
            current: {
              type: 'inventory-item',
              item_id: 'keycard-alpha',
              item: mockItem,
            },
          },
        },
        over: {
          id: 'hotspot-demo-terminal',
          data: {
            current: {
              type: 'hotspot',
              object_id: 'demo-terminal',
              label: '터미널',
              box_2d: { ymin: 300, xmin: 100, ymax: 600, xmax: 400 },
            },
          },
        },
      });
    });

    // startTurnStream 호출 확인
    expect(turnStream.startTurnStream).toHaveBeenCalled();
    const [input] = vi.mocked(turnStream.startTurnStream).mock.calls[0];

    expect(input.text).toBe('Drop: 키카드 A on 터미널');
    expect(input.drop).toEqual({
      item_id: 'keycard-alpha',
      target_object_id: 'demo-terminal',
      target_box_2d: { ymin: 300, xmin: 100, ymax: 600, xmax: 400 },
    });
  });

  it('should show failure feedback when handleDragEnd is called with an invalid target', async () => {
    render(<App />);
    const dndCallbacks = (global as unknown as Record<string, MockDndCallbacks>).dndCallbacks;

    // RU-003-Q1: 드래그 데이터에 item 객체 포함 (타입 가드 요구사항)
    const mockItem = {
      id: 'keycard-alpha',
      name: '키카드 A',
      icon: '🔑',
      quantity: 1,
    };

    // 실패 시나리오 시뮬레이션 (over가 null)
    act(() => {
      dndCallbacks.onDragEnd({
        active: {
          id: 'keycard-alpha',
          data: {
            current: {
              type: 'inventory-item',
              item_id: 'keycard-alpha',
              item: mockItem,
            },
          },
        },
        over: null,
      });
    });

    // turn 실행은 발생하지 않아야 함
    expect(turnStream.startTurnStream).not.toHaveBeenCalled();

    // 내러티브 피드에 실패 메시지가 나타나야 함
    const failureMessage = await screen.findByText(/Invalid: 키카드 A/);
    expect(failureMessage).toBeInTheDocument();
  });
});
</file>

<file path="frontend/src/components/InventoryPanel.tsx">
/**
 * Unknown World - Inventory Panel 컴포넌트 (U-011[Mvp]).
 *
 * dnd-kit 기반 드래그 가능한 인벤토리 아이템 UI를 제공합니다.
 *
 * 설계 원칙:
 *   - RULE-002: Inventory는 게임 UI로 상시 노출 (채팅 입력 대체 금지)
 *   - tech-stack: dnd-kit 기반 draggable 구현
 *   - U-012 연결: 드래그 데이터에 item_id 포함하여 드롭 타겟에 전달
 *
 * @module components/InventoryPanel
 */

import { useCallback, useMemo } from 'react';
import { useDraggable, DragOverlay } from '@dnd-kit/core';
import { CSS } from '@dnd-kit/utilities';
import { useTranslation } from 'react-i18next';
import {
  useInventoryStore,
  type InventoryItem,
  selectItems,
  selectDraggingItem,
  selectSelectedItemId,
} from '../stores/inventoryStore';
import { DND_TYPE, type InventoryDragData } from '../dnd/types';

// =============================================================================
// 드래그 가능한 아이템 컴포넌트
// =============================================================================

interface DraggableItemProps {
  item: InventoryItem;
  isSelected: boolean;
  onSelect: (itemId: string) => void;
  disabled?: boolean;
}

/**
 * 드래그 가능한 인벤토리 아이템.
 * dnd-kit의 useDraggable 훅을 사용합니다.
 */
function DraggableItem({ item, isSelected, onSelect, disabled = false }: DraggableItemProps) {
  const { t } = useTranslation();

  // dnd-kit 드래그 설정 (RU-003-Q1: 상수/타입 기반)
  const dragData: InventoryDragData = {
    type: DND_TYPE.INVENTORY_ITEM,
    item_id: item.id,
    item,
  };
  const { attributes, listeners, setNodeRef, transform, isDragging } = useDraggable({
    id: item.id,
    data: dragData,
    disabled,
  });

  // 변환 스타일 계산
  // 드래그 중일 때는 원본 아이템이 제자리에 있도록 transform 적용하지 않음
  // DragOverlay가 별도로 렌더링되므로 원본은 위치 고정
  const style = useMemo(
    () => ({
      transform: isDragging ? undefined : CSS.Translate.toString(transform),
      opacity: isDragging ? 0.3 : 1,
    }),
    [transform, isDragging],
  );

  // 클릭 핸들러 (선택)
  const handleClick = useCallback(() => {
    if (!disabled) {
      onSelect(item.id);
    }
  }, [disabled, item.id, onSelect]);

  // 아이콘 렌더링 (이모지 또는 이미지)
  const renderIcon = () => {
    if (item.icon) {
      // URL 형태면 이미지, 아니면 이모지
      if (item.icon.startsWith('http') || item.icon.startsWith('/')) {
        return (
          <img
            src={item.icon}
            alt={item.name}
            className="inventory-item-icon-img"
            onError={(e) => {
              e.currentTarget.style.display = 'none';
            }}
          />
        );
      }
      return <span className="inventory-item-icon-emoji">{item.icon}</span>;
    }
    // 기본 아이콘 (📦)
    return <span className="inventory-item-icon-emoji">📦</span>;
  };

  return (
    <div
      ref={setNodeRef}
      style={style}
      className={`inventory-item ${isSelected ? 'selected' : ''} ${isDragging ? 'dragging' : ''} ${disabled ? 'disabled' : ''}`}
      onClick={handleClick}
      aria-label={t('inventory.item_label', { name: item.name, quantity: item.quantity })}
      aria-selected={isSelected}
      {...attributes}
      {...listeners}
    >
      <div className="inventory-item-icon">{renderIcon()}</div>
      <div className="inventory-item-info">
        <span className="inventory-item-name">{item.name}</span>
        {item.quantity > 1 && <span className="inventory-item-quantity">x{item.quantity}</span>}
      </div>
    </div>
  );
}

// =============================================================================
// 드래그 오버레이 (드래그 중 표시되는 아이템)
// =============================================================================

interface ItemOverlayProps {
  item: InventoryItem;
}

/**
 * 드래그 오버레이 아이템.
 * 드래그 중일 때 커서를 따라다니는 아이템 표시입니다.
 */
function ItemOverlay({ item }: ItemOverlayProps) {
  // 아이콘 렌더링
  const renderIcon = () => {
    if (item.icon) {
      if (item.icon.startsWith('http') || item.icon.startsWith('/')) {
        return <img src={item.icon} alt={item.name} className="inventory-item-icon-img" />;
      }
      return <span className="inventory-item-icon-emoji">{item.icon}</span>;
    }
    return <span className="inventory-item-icon-emoji">📦</span>;
  };

  return (
    <div className="inventory-item overlay">
      <div className="inventory-item-icon">{renderIcon()}</div>
      <div className="inventory-item-info">
        <span className="inventory-item-name">{item.name}</span>
        {item.quantity > 1 && <span className="inventory-item-quantity">x{item.quantity}</span>}
      </div>
    </div>
  );
}

// =============================================================================
// 메인 Inventory Panel 컴포넌트
// =============================================================================

interface InventoryPanelProps {
  /** 상호작용 비활성화 (스트리밍 중 등) */
  disabled?: boolean;
}

/**
 * Inventory Panel 컴포넌트.
 *
 * 인벤토리 아이템을 그리드로 표시하고, 드래그 가능하게 합니다.
 * DndContext는 App 최상단에 배치됩니다 (Q1: Option A).
 *
 * @example
 * ```tsx
 * <InventoryPanel disabled={isStreaming} />
 * ```
 */
export function InventoryPanel({ disabled = false }: InventoryPanelProps) {
  const { t } = useTranslation();

  // Store 상태
  const items = useInventoryStore(selectItems);
  const draggingItem = useInventoryStore(selectDraggingItem);
  const selectedItemId = useInventoryStore(selectSelectedItemId);
  const selectItem = useInventoryStore((state) => state.selectItem);

  // 아이템 선택 핸들러
  const handleSelect = useCallback(
    (itemId: string) => {
      // 이미 선택된 아이템 클릭 시 선택 해제
      selectItem(selectedItemId === itemId ? null : itemId);
    },
    [selectedItemId, selectItem],
  );

  // 빈 인벤토리
  if (items.length === 0) {
    return (
      <div className="inventory-panel-content">
        <div className="inventory-empty">
          <span className="inventory-empty-icon">📦</span>
          <span className="inventory-empty-text">{t('inventory.empty')}</span>
        </div>
      </div>
    );
  }

  return (
    <div className="inventory-panel-content" data-ui-importance="critical">
      <div
        className="inventory-grid"
        role="listbox"
        aria-label={t('inventory.grid_label')}
        aria-multiselectable={false}
      >
        {items.map((item) => (
          <DraggableItem
            key={item.id}
            item={item}
            isSelected={selectedItemId === item.id}
            onSelect={handleSelect}
            disabled={disabled}
          />
        ))}
      </div>

      {/* 드래그 오버레이 */}
      <DragOverlay dropAnimation={null}>
        {draggingItem ? <ItemOverlay item={draggingItem} /> : null}
      </DragOverlay>
    </div>
  );
}

export default InventoryPanel;
</file>

<file path="frontend/src/demo/useDemoInitializer.ts">
import { useEffect } from 'react';
import { useTranslation } from 'react-i18next';
import { useInventoryStore } from '../stores/inventoryStore';
import { useWorldStore } from '../stores/worldStore';
import type { Quest, WorldRule } from '../schemas/turn';
import type { MutationEvent } from '../stores/worldStore';
import {
  DEMO_INVENTORY_ITEMS,
  DEMO_SCENE_OBJECTS,
  DEMO_QUESTS,
  DEMO_RULES,
  getDemoItemNameKey,
  isDemoEnvironment,
} from '../demo/demoFixtures';

/**
 * 데모 환경에서 초기 mock 데이터를 로드하는 훅 (RU-003-Q5, U-013).
 */
export function useDemoInitializer() {
  const { t } = useTranslation();
  const { items: inventoryItems, addItems: addInventoryItems } = useInventoryStore();
  const worldStore = useWorldStore();
  const {
    sceneObjects,
    setSceneObjects,
    narrativeEntries,
    initialize: initializeWorld,
    quests,
    activeRules,
  } = worldStore;

  useEffect(() => {
    // 월드 초기화 (환영 메시지)
    if (narrativeEntries.length === 0) {
      initializeWorld(t('narrative.welcome'));
    }

    // DEV: 데모용 mock 데이터 초기화 (RU-003-Q5: DEV 가드 + i18n 키 기반)
    if (isDemoEnvironment()) {
      // 데모용 mock 인벤토리 초기화 (U-011)
      if (inventoryItems.length === 0) {
        const demoInventory = DEMO_INVENTORY_ITEMS.map((item) => ({
          id: item.id,
          name: t(getDemoItemNameKey(item.id)),
          icon: item.icon,
          quantity: item.quantity,
        }));
        addInventoryItems(demoInventory);
      }

      // 데모용 mock Scene Objects 초기화 (U-010)
      if (sceneObjects.length === 0) {
        const demoSceneObjects = DEMO_SCENE_OBJECTS.map((obj) => ({
          id: obj.id,
          label: t(obj.labelKey),
          box_2d: obj.box_2d,
          interaction_hint: t(obj.hintKey),
        }));
        setSceneObjects(demoSceneObjects);
      }

      // 데모용 mock 퀘스트 초기화 (U-013)
      if (quests.length === 0) {
        const demoQuests: Quest[] = DEMO_QUESTS.map((q) => ({
          id: q.id,
          label: t(q.labelKey),
          is_completed: q.is_completed,
        }));
        useWorldStore.setState({ quests: demoQuests });
      }

      // 데모용 mock 규칙 초기화 (U-013)
      if (activeRules.length === 0) {
        const demoRules: WorldRule[] = DEMO_RULES.map((r) => ({
          id: r.id,
          label: t(r.labelKey),
          description: r.descriptionKey ? t(r.descriptionKey) : null,
        }));
        // 데모 뮤테이션 타임라인 생성 (규칙 추가 이벤트)
        const now = Date.now();
        const demoMutations: MutationEvent[] = DEMO_RULES.map((r, index) => ({
          turn: 0,
          ruleId: r.id,
          type: 'added' as const,
          label: t(r.labelKey),
          description: r.descriptionKey ? t(r.descriptionKey) : undefined,
          timestamp: now - index * 1000, // 시간 순서 구분용
        }));
        useWorldStore.setState({
          activeRules: demoRules,
          mutationTimeline: demoMutations,
        });
      }
    }
    // eslint-disable-next-line react-hooks/exhaustive-deps
  }, [t]);
}
</file>

<file path="frontend/src/stores/agentStore.ts">
/**
 * Unknown World - Agent Console 상태 관리 (Zustand).
 *
 * 스트리밍 중 수신되는 단계/배지/내러티브/복구 정보를 저장하고,
 * AgentConsole 컴포넌트에서 구독할 수 있도록 합니다.
 *
 * 설계 원칙:
 *   - RULE-008: 단계/배지 가시화 (프롬프트/내부 추론 노출 금지)
 *   - RULE-003/004: 검증 후 상태 반영, 실패 시 폴백
 *
 * @module stores/agentStore
 */

import { create } from 'zustand';
import type { AgentPhase, ValidationBadge, TurnOutput } from '../schemas/turn';
import type {
  StageEvent,
  BadgesEvent,
  NarrativeDeltaEvent,
  FinalEvent,
  ErrorEvent,
} from '../types/turn_stream';
import { StageStatus } from '../types/turn_stream';

// =============================================================================
// 상태 타입 정의
// =============================================================================

/** 단계 상태 */
export type PhaseStatus = 'pending' | 'in_progress' | 'completed' | 'failed';

/** 단계 정보 */
export interface PhaseInfo {
  name: AgentPhase;
  status: PhaseStatus;
}

/** 에러 정보 */
export interface AgentError {
  message: string;
  code?: string;
}

/** Agent Console 상태 */
export interface AgentState {
  /** 현재 스트리밍 중인지 */
  isStreaming: boolean;
  /** 현재 단계 */
  currentPhase: AgentPhase | null;
  /** 단계별 상태 */
  phases: PhaseInfo[];
  /** 검증 배지 목록 */
  badges: ValidationBadge[];
  /** 누적 내러티브 텍스트 (타자 효과용) */
  narrativeBuffer: string;
  /** 자동 복구 횟수 */
  repairCount: number;
  /** 최종 TurnOutput */
  finalOutput: TurnOutput | null;
  /** 에러 정보 */
  error: AgentError | null;
}

/** Agent Console 액션 */
export interface AgentActions {
  /** 스트림 시작 */
  startStream: () => void;
  /** 단계 이벤트 처리 */
  handleStage: (event: StageEvent) => void;
  /** 배지 이벤트 처리 */
  handleBadges: (event: BadgesEvent) => void;
  /** 내러티브 델타 이벤트 처리 */
  handleNarrativeDelta: (event: NarrativeDeltaEvent) => void;
  /** 최종 출력 이벤트 처리 */
  handleFinal: (event: FinalEvent) => void;
  /** 에러 이벤트 처리 */
  handleError: (event: ErrorEvent) => void;
  /** 스트림 완료 */
  completeStream: () => void;
  /** 상태 초기화 */
  reset: () => void;
}

export type AgentStore = AgentState & AgentActions;

// =============================================================================
// 초기 상태
// =============================================================================

/** 기본 단계 목록 (PRD 예시) */
const DEFAULT_PHASES: AgentPhase[] = [
  'parse',
  'validate',
  'plan',
  'resolve',
  'render',
  'verify',
  'commit',
];

/** 초기 상태 생성 */
function createInitialState(): AgentState {
  return {
    isStreaming: false,
    currentPhase: null,
    phases: DEFAULT_PHASES.map((name) => ({
      name,
      status: 'pending' as const,
    })),
    badges: [],
    narrativeBuffer: '',
    repairCount: 0,
    finalOutput: null,
    error: null,
  };
}

// =============================================================================
// Zustand Store
// =============================================================================

/**
 * Agent Console 상태 스토어.
 *
 * @example
 * ```tsx
 * // 컴포넌트에서 사용
 * const { isStreaming, phases, badges } = useAgentStore();
 * const startStream = useAgentStore((state) => state.startStream);
 * ```
 */
export const useAgentStore = create<AgentStore>((set) => ({
  // 초기 상태
  ...createInitialState(),

  // 액션
  startStream: () => {
    set({
      ...createInitialState(),
      isStreaming: true,
    });
  },

  handleStage: (event) => {
    set((state) => {
      const phaseName = event.name;
      const eventStatus = event.status;

      // RU-002-S2: status 값에 따른 단계 상태 결정
      // 'start' → in_progress
      // 'complete' 또는 'ok' (정규화됨) → completed
      // 'fail' → failed
      let newStatus: PhaseStatus;
      if (eventStatus === StageStatus.START) {
        newStatus = 'in_progress';
      } else if (eventStatus === 'fail') {
        newStatus = 'failed';
      } else {
        // 'complete' (정규화된 'ok' 포함)
        newStatus = 'completed';
      }

      // 단계 상태 업데이트
      const phases = state.phases.map((phase) => {
        if (phase.name === phaseName) {
          return {
            ...phase,
            status: newStatus,
          };
        }
        return phase;
      });

      return {
        phases,
        currentPhase: eventStatus === StageStatus.START ? phaseName : state.currentPhase,
      };
    });
  },

  handleBadges: (event) => {
    set({
      badges: event.badges,
    });
  },

  handleNarrativeDelta: (event) => {
    set((state) => ({
      narrativeBuffer: state.narrativeBuffer + event.text,
    }));
  },

  handleFinal: (event) => {
    set({
      finalOutput: event.data,
      repairCount: event.data.agent_console?.repair_count ?? 0,
    });
  },

  handleError: (event) => {
    set({
      error: {
        message: event.message,
        code: event.code,
      },
    });
  },

  completeStream: () => {
    set({
      isStreaming: false,
      narrativeBuffer: '', // 스트림 완료 시 버퍼 초기화
    });
  },

  reset: () => {
    set(createInitialState());
  },
}));

// =============================================================================
// 셀렉터 (성능 최적화용)
// =============================================================================

/** 스트리밍 상태 셀렉터 */
export const selectIsStreaming = (state: AgentStore) => state.isStreaming;

/** 현재 단계 셀렉터 */
export const selectCurrentPhase = (state: AgentStore) => state.currentPhase;

/** 단계 목록 셀렉터 */
export const selectPhases = (state: AgentStore) => state.phases;

/** 배지 목록 셀렉터 */
export const selectBadges = (state: AgentStore) => state.badges;

/** 내러티브 버퍼 셀렉터 */
export const selectNarrativeBuffer = (state: AgentStore) => state.narrativeBuffer;

/** 복구 횟수 셀렉터 */
export const selectRepairCount = (state: AgentStore) => state.repairCount;

/** 최종 출력 셀렉터 */
export const selectFinalOutput = (state: AgentStore) => state.finalOutput;

/** 에러 셀렉터 */
export const selectError = (state: AgentStore) => state.error;
</file>

<file path="shared/schemas/turn/turn_input.schema.json">
{
  "$schema": "http://json-schema.org/draft-07/schema#",
  "$id": "https://unknown-world.dev/schemas/turn/turn_input.schema.json",
  "title": "TurnInput",
  "description": "Client → Server 턴 요청 스키마 (MVP). PRD 8.7절 기반.",
  "type": "object",
  "properties": {
    "language": {
      "type": "string",
      "enum": ["ko-KR", "en-US"],
      "description": "게임 언어 설정 (ko-KR 또는 en-US)"
    },
    "text": {
      "type": "string",
      "description": "사용자 입력 (자연어)"
    },
    "click": {
      "type": ["object", "null"],
      "description": "클릭된 오브젝트 정보 (선택)",
      "properties": {
        "object_id": {
          "type": "string",
          "description": "클릭된 오브젝트 ID"
        },
        "box_2d": {
          "type": ["array", "null"],
          "description": "bbox [ymin, xmin, ymax, xmax] (0~1000 정규화)",
          "items": {
            "type": "integer",
            "minimum": 0,
            "maximum": 1000
          },
          "minItems": 4,
          "maxItems": 4
        }
      },
      "required": ["object_id"]
    },
    "client": {
      "type": "object",
      "description": "클라이언트 환경 정보",
      "properties": {
        "viewport_w": {
          "type": "integer",
          "description": "뷰포트 너비 (px)"
        },
        "viewport_h": {
          "type": "integer",
          "description": "뷰포트 높이 (px)"
        },
        "theme": {
          "type": "string",
          "enum": ["dark", "light"],
          "description": "테마 설정"
        }
      },
      "required": ["viewport_w", "viewport_h", "theme"]
    },
    "economy_snapshot": {
      "type": "object",
      "description": "현재 재화 상태 스냅샷",
      "properties": {
        "signal": {
          "type": "integer",
          "minimum": 0,
          "description": "Signal 재화 잔액"
        },
        "memory_shard": {
          "type": "integer",
          "minimum": 0,
          "description": "Memory Shard 재화 잔액"
        }
      },
      "required": ["signal", "memory_shard"]
    }
  },
  "required": ["language", "text", "client", "economy_snapshot"],
  "additionalProperties": false
}
</file>

<file path="backend/src/unknown_world/api/turn.py">
"""Unknown World - /api/turn HTTP Streaming 엔드포인트.

POST 요청을 받아 NDJSON(라인 단위 JSON) 스트리밍으로 턴 결과를 반환합니다.

설계 원칙:
    - RULE-003: 구조화 출력(JSON Schema) 우선 + Pydantic 검증
    - RULE-004: 검증 실패 시 Repair loop + 안전한 폴백
    - RULE-005: 재화 인바리언트 (잔액 음수 금지)
    - RULE-007: 프롬프트/내부 추론 노출 금지
    - RULE-008: 단계/배지 가시화, TTFB 2초 목표

스트림 이벤트 타입:
    - stage: 단계 진행 상태 (Parse→Validate→Plan→Resolve→Render→Verify→Commit)
    - badges: 검증 배지 목록
    - narrative_delta: 내러티브 텍스트 조각 (타자 효과용)
    - final: 최종 TurnOutput
    - error: 에러 발생 시

참조:
    - vibe/unit-plans/U-007[Mvp].md
    - .cursor/rules/20-backend-orchestrator.mdc
"""

import asyncio
import time
from collections.abc import AsyncGenerator
from typing import Any, cast

from fastapi import APIRouter, Request
from fastapi.responses import StreamingResponse
from pydantic import ValidationError

from unknown_world.api.turn_stream_events import (
    BadgesEvent,
    ErrorEvent,
    FinalEvent,
    NarrativeDeltaEvent,
    RepairEvent,
    StageEvent,
    StageStatus,
    StreamEventType,
    serialize_event,
)
from unknown_world.models.turn import (
    AgentPhase,
    CurrencyAmount,
    Language,
    TurnInput,
    ValidationBadge,
)
from unknown_world.orchestrator.mock import MockOrchestrator

# =============================================================================
# 라우터 정의
# =============================================================================

router = APIRouter(prefix="/api", tags=["Turn"])

# 단계 목록 (PRD 예시)
ORCHESTRATOR_PHASES = [
    AgentPhase.PARSE,
    AgentPhase.VALIDATE,
    AgentPhase.PLAN,
    AgentPhase.RESOLVE,
    AgentPhase.RENDER,
    AgentPhase.VERIFY,
    AgentPhase.COMMIT,
]

# 모의 단계 지연 시간 (ms) - 실제 처리 시뮬레이션
PHASE_DELAYS_MS = {
    AgentPhase.PARSE: 50,
    AgentPhase.VALIDATE: 30,
    AgentPhase.PLAN: 100,
    AgentPhase.RESOLVE: 150,
    AgentPhase.RENDER: 80,
    AgentPhase.VERIFY: 40,
    AgentPhase.COMMIT: 20,
}


async def _stream_turn_events(
    turn_input: TurnInput, seed: int | None = None
) -> AsyncGenerator[str]:
    """턴 처리 이벤트를 NDJSON 스트림으로 생성합니다.

    Args:
        turn_input: 사용자 턴 입력
        seed: 모의 Orchestrator 시드 (재현성 보장)

    Yields:
        str: NDJSON 라인
    """
    orchestrator = MockOrchestrator(seed=seed)
    collected_badges: list[str] = []

    # Phase 1: Parse (TTFB를 위해 즉시 시작 이벤트 전송)
    yield serialize_event(
        StageEvent(
            type=StreamEventType.STAGE, name=AgentPhase.PARSE.value, status=StageStatus.START
        ).model_dump()
    )

    # 각 단계별 처리 시뮬레이션
    for phase in ORCHESTRATOR_PHASES:
        # 단계 시작
        if phase != AgentPhase.PARSE:  # Parse는 이미 전송함
            yield serialize_event(
                StageEvent(
                    type=StreamEventType.STAGE, name=phase.value, status=StageStatus.START
                ).model_dump()
            )

        # 모의 처리 지연
        delay_ms = PHASE_DELAYS_MS.get(phase, 50)
        await asyncio.sleep(delay_ms / 1000.0)

        # 단계 완료
        yield serialize_event(
            StageEvent(
                type=StreamEventType.STAGE, name=phase.value, status=StageStatus.COMPLETE
            ).model_dump()
        )

        # 배지 추가 (Validate, Verify 단계에서)
        if phase == AgentPhase.VALIDATE:
            collected_badges.append(ValidationBadge.SCHEMA_OK.value)
            collected_badges.append(ValidationBadge.ECONOMY_OK.value)
            yield serialize_event(
                BadgesEvent(
                    type=StreamEventType.BADGES, badges=collected_badges.copy()
                ).model_dump()
            )
        elif phase == AgentPhase.VERIFY:
            collected_badges.append(ValidationBadge.SAFETY_OK.value)
            collected_badges.append(ValidationBadge.CONSISTENCY_OK.value)
            yield serialize_event(
                BadgesEvent(
                    type=StreamEventType.BADGES, badges=collected_badges.copy()
                ).model_dump()
            )

    # TurnOutput 생성 (Repair 루프 포함 - RULE-004)
    max_repair_attempts = 3
    repair_attempt = 0
    turn_output = None

    try:
        while repair_attempt <= max_repair_attempts:
            try:
                # 0회차는 정상 시도, 1회차부터는 repair
                if repair_attempt > 0:
                    yield serialize_event(
                        RepairEvent(
                            type=StreamEventType.REPAIR,
                            attempt=repair_attempt,
                            message="검증 실패로 인해 다시 시도 중입니다..."
                            if turn_input.language == Language.KO
                            else "Retrying due to validation failure",
                        ).model_dump()
                    )

                turn_output = orchestrator.generate_turn_output(turn_input)
                break  # 성공 시 루프 탈출

            except ValidationError as e:
                repair_attempt += 1
                if repair_attempt > max_repair_attempts:
                    # 최종 실패 시 폴백 (RULE-004)
                    turn_output = orchestrator.create_safe_fallback(
                        language=turn_input.language,
                        error_message=str(e),
                        economy_snapshot=CurrencyAmount(
                            signal=turn_input.economy_snapshot.signal,
                            memory_shard=turn_input.economy_snapshot.memory_shard,
                        ),
                    )
                    break
                # 루프 계속 진행 (재시도)
                continue

        if turn_output:
            # 내러티브 델타 스트리밍 (타자 효과)
            narrative = turn_output.narrative
            chunk_size = 20  # 한 번에 전송할 글자 수
            for i in range(0, len(narrative), chunk_size):
                chunk = narrative[i : i + chunk_size]
                yield serialize_event(
                    NarrativeDeltaEvent(
                        type=StreamEventType.NARRATIVE_DELTA, text=chunk
                    ).model_dump()
                )
                await asyncio.sleep(0.02)  # 타자 효과 딜레이

            # 최종 TurnOutput 전송
            yield serialize_event(
                FinalEvent(type=StreamEventType.FINAL, data=turn_output).model_dump(mode="json")
            )

    except Exception:
        # RU-002-S1: 예외 발생 시 error + final(폴백) 순서로 송출
        # (프롬프트/내부 추론 노출 금지 - RULE-007)
        yield serialize_event(
            ErrorEvent(
                type=StreamEventType.ERROR,
                message="처리 중 오류가 발생했습니다"
                if turn_input.language == Language.KO
                else "An error occurred during processing",
                code="INTERNAL_ERROR",
            ).model_dump()
        )
        # 항상 final(폴백)로 종료 - 스트림 종료 인바리언트 (RULE-004)
        fallback = orchestrator.create_safe_fallback(
            language=turn_input.language,
            error_message="Internal error",
            economy_snapshot=CurrencyAmount(
                signal=turn_input.economy_snapshot.signal,
                memory_shard=turn_input.economy_snapshot.memory_shard,
            ),
        )
        yield serialize_event(
            FinalEvent(type=StreamEventType.FINAL, data=fallback).model_dump(mode="json")
        )


async def _validate_and_parse_input(request: Request) -> TurnInput | dict[str, Any]:
    """요청 본문을 TurnInput으로 검증 및 파싱합니다.

    Returns:
        TurnInput 또는 에러 정보 dict (language, economy_snapshot 포함)
    """
    body: dict[str, Any] | None = None
    try:
        body = await request.json()
        return TurnInput.model_validate(body)
    except ValidationError as e:
        # RU-002-S1: 입력 검증 실패 시에도 language/economy 추출 시도
        raw_language = body.get("language") if isinstance(body, dict) else None
        raw_economy = body.get("economy_snapshot") if isinstance(body, dict) else None
        return {
            "error": True,
            "message": "Invalid input",
            "details": e.errors(),
            "language": raw_language if raw_language in ("ko-KR", "en-US") else "ko-KR",
            "economy_snapshot": raw_economy,
        }
    except Exception:
        return {
            "error": True,
            "message": "Failed to parse request body",
            "details": None,
            "language": "ko-KR",
            "economy_snapshot": None,
        }


@router.post(
    "/turn",
    response_class=StreamingResponse,
    summary="턴 처리 (HTTP Streaming)",
    description="""
턴 입력을 받아 NDJSON 스트리밍으로 결과를 반환합니다.

**스트림 이벤트 타입**:
- `stage`: 처리 단계 진행 상태
- `badges`: 검증 배지 목록
- `narrative_delta`: 내러티브 텍스트 조각 (타자 효과)
- `final`: 최종 TurnOutput
- `error`: 에러 발생 시

**예시 요청**:
```json
{
    "language": "ko-KR",
    "text": "문을 열어본다",
    "client": {"viewport_w": 1920, "viewport_h": 1080, "theme": "dark"},
    "economy_snapshot": {"signal": 100, "memory_shard": 5}
}
```
""",
    responses={
        200: {
            "description": "NDJSON 스트림",
            "content": {
                "application/x-ndjson": {
                    "example": '{"type":"stage","name":"parse","status":"start"}\n'
                }
            },
        },
        400: {"description": "잘못된 요청"},
    },
)
async def turn_stream(request: Request) -> StreamingResponse:
    """턴 처리 HTTP Streaming 엔드포인트.

    POST 요청으로 TurnInput을 받아 NDJSON 스트리밍으로 결과를 반환합니다.
    TTFB를 줄이기 위해 첫 stage 이벤트를 즉시 전송합니다.

    Args:
        request: FastAPI Request 객체

    Returns:
        StreamingResponse: NDJSON 스트림
    """
    # 입력 검증
    parse_result = await _validate_and_parse_input(request)

    if isinstance(parse_result, dict) and parse_result.get("error"):
        # RU-002-S1: 입력 검증 실패 시에도 error + final(폴백) 순서로 송출
        error_language = parse_result.get("language", "ko-KR")
        error_economy = parse_result.get("economy_snapshot")

        # economy_snapshot이 유효한지 확인
        economy_snapshot: CurrencyAmount | None = None
        if isinstance(error_economy, dict):
            try:
                # 명시적 타입 캐스팅으로 Pyright 경고 해소
                eco_dict = cast(dict[str, Any], error_economy)
                economy_snapshot = CurrencyAmount(
                    signal=int(eco_dict.get("signal", 100)),
                    memory_shard=int(eco_dict.get("memory_shard", 5)),
                )
            except (ValueError, TypeError):
                economy_snapshot = None

        async def error_stream() -> AsyncGenerator[str]:
            # 에러 이벤트 송출
            yield serialize_event(
                ErrorEvent(
                    type=StreamEventType.ERROR,
                    message=parse_result.get("message", "Invalid input"),
                    code="VALIDATION_ERROR",
                ).model_dump()
            )
            # 항상 final(폴백)로 종료 - 스트림 종료 인바리언트 (RULE-004)
            fallback_orchestrator = MockOrchestrator()
            fallback = fallback_orchestrator.create_safe_fallback(
                language=Language.KO if error_language == "ko-KR" else Language.EN,
                error_message="Validation error",
                economy_snapshot=economy_snapshot,
            )
            yield serialize_event(
                FinalEvent(type=StreamEventType.FINAL, data=fallback).model_dump(mode="json")
            )

        return StreamingResponse(
            error_stream(),
            media_type="application/x-ndjson",
            headers={
                "Cache-Control": "no-cache",
                "X-Accel-Buffering": "no",  # nginx 버퍼링 비활성화
            },
        )

    turn_input: TurnInput = parse_result  # type: ignore[assignment]

    # 시드 추출 (쿼리 파라미터에서, 테스트/재현용)
    seed_param = request.query_params.get("seed")
    seed = int(seed_param) if seed_param else None

    # NDJSON 스트리밍 응답
    return StreamingResponse(
        _stream_turn_events(turn_input, seed=seed),
        media_type="application/x-ndjson",
        headers={
            "Cache-Control": "no-cache",
            "X-Accel-Buffering": "no",  # nginx 버퍼링 비활성화
            "X-Request-Time": str(int(time.time() * 1000)),
        },
    )
</file>

<file path="frontend/src/api/turnStream.test.ts">
import { describe, it, expect, vi, beforeEach } from 'vitest';
import { NDJSONParser } from './turnStream';

describe('NDJSONParser', () => {
  let parser: NDJSONParser;

  beforeEach(() => {
    parser = new NDJSONParser();
  });

  it('should parse a single complete line', () => {
    const chunk = JSON.stringify({ type: 'test', value: 1 }) + '\n';
    const results = parser.parse(chunk);
    expect(results).toHaveLength(1);
    expect(results[0]).toEqual({ type: 'test', value: 1 });
  });

  it('should parse multiple complete lines in one chunk', () => {
    const chunk = JSON.stringify({ id: 1 }) + '\n' + JSON.stringify({ id: 2 }) + '\n';
    const results = parser.parse(chunk);
    expect(results).toHaveLength(2);
    expect(results[0]).toEqual({ id: 1 });
    expect(results[1]).toEqual({ id: 2 });
  });

  it('should buffer partial lines and parse them when completed', () => {
    const chunk1 = '{"id": 1';
    const chunk2 = ', "val": "ok"}\n';

    const results1 = parser.parse(chunk1);
    expect(results1).toHaveLength(0);

    const results2 = parser.parse(chunk2);
    expect(results2).toHaveLength(1);
    expect(results2[0]).toEqual({ id: 1, val: 'ok' });
  });

  it('should ignore empty lines', () => {
    const chunk = '\n\n{"a":1}\n\n';
    const results = parser.parse(chunk);
    expect(results).toHaveLength(1);
  });

  it('should not crash on invalid JSON and continue', () => {
    const consoleSpy = vi.spyOn(console, 'warn').mockImplementation(() => {});
    const chunk = 'invalid json\n{"valid": true}\n';
    const results = parser.parse(chunk);

    expect(results).toHaveLength(1);
    expect(results[0]).toEqual({ valid: true });
    expect(consoleSpy).toHaveBeenCalled();
    consoleSpy.mockRestore();
  });

  it('should flush remaining buffer', () => {
    parser.parse('{"id": 1}'); // No newline
    const result = parser.flush();
    expect(result).toEqual({ id: 1 });
  });

  it('should return null on flush with empty buffer', () => {
    const result = parser.flush();
    expect(result).toBeNull();
  });
});

describe('executeTurnStream', () => {
  const mockInput = {
    language: 'ko-KR' as const,
    text: 'Hello',
    action_id: null,
    click: null,
    drop: null, // U-012: 드롭 입력 필드 추가
    client: { viewport_w: 100, viewport_h: 100, theme: 'dark' as const },
    economy_snapshot: { signal: 100, memory_shard: 0 },
  };

  const mockCallbacks = {
    onStage: vi.fn(),
    onRepair: vi.fn(),
    onBadges: vi.fn(),
    onNarrativeDelta: vi.fn(),
    onFinal: vi.fn(),
    onError: vi.fn(),
    onComplete: vi.fn(),
  };

  beforeEach(() => {
    vi.clearAllMocks();
    global.fetch = vi.fn();
  });

  it('should process stream events correctly (including repair)', async () => {
    const encoder = new TextEncoder();
    const stream = new ReadableStream({
      start(controller) {
        controller.enqueue(
          encoder.encode(JSON.stringify({ type: 'stage', name: 'parse', status: 'start' }) + '\n'),
        );
        controller.enqueue(
          encoder.encode(
            JSON.stringify({ type: 'repair', attempt: 1, message: 'Schema fail, retrying' }) + '\n',
          ),
        );
        controller.enqueue(
          encoder.encode(JSON.stringify({ type: 'narrative_delta', text: 'Hello' }) + '\n'),
        );
        controller.enqueue(
          encoder.encode(
            JSON.stringify({
              type: 'final',
              data: {
                language: 'ko-KR',
                narrative: 'Hello',
                economy: {
                  cost: { signal: 0, memory_shard: 0 },
                  balance_after: { signal: 100, memory_shard: 0 },
                },
                safety: { blocked: false },
              },
            }) + '\n',
          ),
        );
        controller.close();
      },
    });

    (global.fetch as unknown as ReturnType<typeof vi.fn>).mockResolvedValue({
      ok: true,
      body: stream,
    });

    const { executeTurnStream } = await import('./turnStream');
    await executeTurnStream(mockInput, mockCallbacks);

    expect(mockCallbacks.onStage).toHaveBeenCalledWith(expect.objectContaining({ name: 'parse' }));
    expect(mockCallbacks.onRepair).toHaveBeenCalledWith(
      expect.objectContaining({ attempt: 1, message: 'Schema fail, retrying' }),
    );
    expect(mockCallbacks.onNarrativeDelta).toHaveBeenCalledWith(
      expect.objectContaining({ text: 'Hello' }),
    );
    expect(mockCallbacks.onFinal).toHaveBeenCalled();
    expect(mockCallbacks.onComplete).toHaveBeenCalled();
  });

  it('should handle HTTP errors', async () => {
    (global.fetch as unknown as ReturnType<typeof vi.fn>).mockResolvedValue({
      ok: false,
      status: 500,
      statusText: 'Internal Server Error',
    });

    const { executeTurnStream } = await import('./turnStream');
    await executeTurnStream(mockInput, mockCallbacks);

    expect(mockCallbacks.onError).toHaveBeenCalledWith(
      expect.objectContaining({
        code: 'STREAM_ERROR',
        message: expect.stringContaining('500'),
      }),
    );
  });

  it('should handle fetch rejection', async () => {
    (global.fetch as unknown as ReturnType<typeof vi.fn>).mockRejectedValue(
      new Error('Network failure'),
    );

    const { executeTurnStream } = await import('./turnStream');
    await executeTurnStream(mockInput, mockCallbacks);

    expect(mockCallbacks.onError).toHaveBeenCalledWith(
      expect.objectContaining({
        message: 'Network failure',
      }),
    );
  });
});
</file>

<file path="frontend/src/components/ActionDeck.tsx">
/**
 * Unknown World - Action Deck 컴포넌트 (U-009[Mvp]).
 *
 * PRD 요구사항:
 *   - Action Deck(3~6장 카드)을 Footer 영역에 상시 노출
 *   - 각 카드에 예상 비용(최소/최대), 위험도, 보상 힌트 표기 (RULE-005)
 *   - 카드 클릭 시 TurnInput으로 선택된 행동 전송 (RULE-008)
 *   - 잔액 부족 시 실행 불가 표시 + 저비용 대안 노출 (RULE-005)
 *
 * RULE-002 준수: 채팅 버블/메시지 버튼이 아닌 "게임 카드" UI
 *
 * @see vibe/prd.md 6.7 - Action Deck 요구사항
 * @see .cursor/rules/10-frontend-game-ui.mdc
 * @module components/ActionDeck
 */

import { useMemo, useCallback } from 'react';
import { useTranslation } from 'react-i18next';
import type { ActionCard } from '../schemas/turn';
import { useActionDeckStore } from '../stores/actionDeckStore';
import { useWorldStore } from '../stores/worldStore';
import { useAgentStore } from '../stores/agentStore';
import { useEconomyStore } from '../stores/economyStore';

// =============================================================================
// 타입 정의
// =============================================================================

export interface ActionDeckProps {
  /** 카드 클릭 콜백 */
  onCardClick?: (card: ActionCard) => void;
  /** 전체 비활성화 (스트리밍 중 등, 생략 시 agentStore.isStreaming 사용) */
  disabled?: boolean;
}

interface CardDisplayInfo extends ActionCard {
  /** 클라이언트 측 실행 가능 여부 (서버 enabled가 없을 때 폴백) */
  isAffordable: boolean;
  /** 최종 비활성화 여부 */
  isDisabled: boolean;
  /** 최종 비활성화 사유 */
  finalDisabledReason: string | null;
}

// =============================================================================
// 기본 카드 생성 (i18n 기반)
// =============================================================================

function useDefaultCards(): ActionCard[] {
  const { t } = useTranslation();

  return useMemo(
    () => [
      {
        id: 'default-explore',
        label: t('action.default.explore.label'),
        description: t('action.default.explore.description'),
        cost: { signal: 1, memory_shard: 0 },
        cost_estimate: null,
        risk: 'low' as const,
        hint: null,
        reward_hint: null,
        enabled: true,
        disabled_reason: null,
        is_alternative: false,
      },
      {
        id: 'default-investigate',
        label: t('action.default.investigate.label'),
        description: t('action.default.investigate.description'),
        cost: { signal: 2, memory_shard: 0 },
        cost_estimate: null,
        risk: 'medium' as const,
        hint: null,
        reward_hint: null,
        enabled: true,
        disabled_reason: null,
        is_alternative: false,
      },
      {
        id: 'default-talk',
        label: t('action.default.talk.label'),
        description: t('action.default.talk.description'),
        cost: { signal: 1, memory_shard: 0 },
        cost_estimate: null,
        risk: 'low' as const,
        hint: null,
        reward_hint: null,
        enabled: true,
        disabled_reason: null,
        is_alternative: false,
      },
    ],
    [t],
  );
}

// =============================================================================
// 카드 비용 표시 컴포넌트
// =============================================================================

interface CardCostDisplayProps {
  card: CardDisplayInfo;
}

function CardCostDisplay({ card }: CardCostDisplayProps) {
  const { t } = useTranslation();

  // 비용 추정 범위가 있으면 min~max 표시, 없으면 기본 cost 표시
  const costDisplay = card.cost_estimate
    ? `${card.cost_estimate.min.signal}~${card.cost_estimate.max.signal}`
    : `${card.cost.signal}`;

  const shardCost = card.cost_estimate
    ? card.cost_estimate.max.memory_shard
    : card.cost.memory_shard;

  return (
    <div className="action-card-cost" data-ui-importance="critical">
      {/* Signal 비용 */}
      <span className="cost-item">
        <span className="icon-wrapper" aria-label={t('economy.signal_cost')}>
          <img
            src="/ui/icons/signal-16.png"
            alt=""
            aria-hidden="true"
            className="icon-img"
            style={{ width: 14, height: 14 }}
            onError={(e) => e.currentTarget.classList.add('hidden')}
          />
          <span className="icon-fallback">⚡</span>
        </span>
        <span className="cost-value">{costDisplay}</span>
      </span>

      {/* Shard 비용 (0보다 클 때만 표시) */}
      {shardCost > 0 && (
        <span className="cost-item">
          <span className="cost-separator">|</span>
          <span className="icon-wrapper" aria-label={t('economy.shard_cost')}>
            <img
              src="/ui/icons/shard-16.png"
              alt=""
              aria-hidden="true"
              className="icon-img"
              style={{ width: 14, height: 14 }}
              onError={(e) => e.currentTarget.classList.add('hidden')}
            />
            <span className="icon-fallback">💎</span>
          </span>
          <span className="cost-value">
            {card.cost_estimate
              ? `${card.cost_estimate.min.memory_shard}~${card.cost_estimate.max.memory_shard}`
              : card.cost.memory_shard}
          </span>
        </span>
      )}

      {/* 위험도 */}
      <span className="cost-item">
        <span className="cost-separator">|</span>
        <span className="icon-wrapper" aria-label={t('economy.risk_level')}>
          <img
            src={`/ui/icons/risk-${card.risk}-16.png`}
            alt=""
            aria-hidden="true"
            className={`icon-img risk-${card.risk}`}
            style={{ width: 14, height: 14 }}
            onError={(e) => e.currentTarget.classList.add('hidden')}
          />
          <span className="icon-fallback">⚠</span>
        </span>
        <span className={`risk-label risk-${card.risk}`}>{t(`action.risk.${card.risk}`)}</span>
      </span>
    </div>
  );
}

// =============================================================================
// 단일 카드 컴포넌트
// =============================================================================

interface ActionCardItemProps {
  card: CardDisplayInfo;
  onClick: () => void;
  onHover: (card: CardDisplayInfo | null) => void;
  disabled: boolean;
}

function ActionCardItem({ card, onClick, onHover, disabled }: ActionCardItemProps) {
  const { t } = useTranslation();

  const cardClasses = [
    'action-card',
    'has-chrome',
    card.isDisabled ? 'card-disabled' : '',
    card.is_alternative ? 'card-alternative' : '',
    `risk-border-${card.risk}`,
  ]
    .filter(Boolean)
    .join(' ');

  return (
    <button
      type="button"
      className={cardClasses}
      onClick={onClick}
      onMouseEnter={() => onHover(card)}
      onMouseLeave={() => onHover(null)}
      onFocus={() => onHover(card)}
      onBlur={() => onHover(null)}
      disabled={disabled || card.isDisabled}
      aria-disabled={disabled || card.isDisabled}
      title={card.finalDisabledReason ?? card.description ?? undefined}
    >
      {/* 대안 카드 표시 */}
      {card.is_alternative && <span className="alternative-badge">{t('action.alternative')}</span>}

      {/* 카드 타이틀 */}
      <div className="action-card-title">{card.label}</div>

      {/* 카드 설명 (있을 때만) */}
      {card.description && <div className="action-card-description">{card.description}</div>}

      {/* 비용/위험도 정보 */}
      <CardCostDisplay card={card} />

      {/* 힌트 영역 */}
      {(card.hint || card.reward_hint) && (
        <div className="action-card-hints">
          {card.hint && (
            <div className="hint-item hint-risk">
              <span className="hint-icon">⚠</span>
              <span className="hint-text">{card.hint}</span>
            </div>
          )}
          {card.reward_hint && (
            <div className="hint-item hint-reward">
              <span className="hint-icon">★</span>
              <span className="hint-text">{card.reward_hint}</span>
            </div>
          )}
        </div>
      )}

      {/* 비활성화 오버레이 */}
      {card.isDisabled && (
        <div className="card-disabled-overlay">
          <span className="disabled-reason">
            {card.finalDisabledReason ?? t('action.insufficient_balance')}
          </span>
        </div>
      )}
    </button>
  );
}

// =============================================================================
// 메인 Action Deck 컴포넌트
// =============================================================================

export function ActionDeck({ onCardClick, disabled: propsDisabled }: ActionDeckProps) {
  const { t } = useTranslation();
  const defaultCards = useDefaultCards();

  // Store 상태 (RU-003: 컴포넌트 내에서 직접 구독)
  const cards = useActionDeckStore((state) => state.cards);
  const currentBalance = useWorldStore((state) => state.economy);
  const isStreaming = useAgentStore((state) => state.isStreaming);
  const setCostEstimateFromCard = useEconomyStore((state) => state.setCostEstimateFromCard);
  const setCostEstimate = useEconomyStore((state) => state.setCostEstimate);

  const disabled = propsDisabled ?? isStreaming;

  // 카드 호버 핸들러 (U-014: 예상 비용 표시)
  const handleCardHover = useCallback(
    (card: CardDisplayInfo | null) => {
      if (card) {
        setCostEstimateFromCard(card.cost, card.cost_estimate, card.id, card.label);
      } else {
        setCostEstimate(null);
      }
    },
    [setCostEstimateFromCard, setCostEstimate],
  );

  // 카드가 없으면 기본 카드 사용
  const displayCards = cards.length > 0 ? cards : defaultCards;

  // 카드별 실행 가능 여부 계산 (Q1: Option A - 서버 우선, 클라이언트 폴백)
  const processedCards: CardDisplayInfo[] = useMemo(() => {
    return displayCards.map((card) => {
      // 서버에서 enabled를 명시적으로 false로 보냈으면 그대로 사용
      const serverEnabled = card.enabled;

      // 클라이언트 측 잔액 체크 (서버가 판단하지 않았을 때 폴백)
      const costToCheck = card.cost_estimate?.max ?? card.cost;
      const isAffordable =
        currentBalance.signal >= costToCheck.signal &&
        currentBalance.memory_shard >= costToCheck.memory_shard;

      // 최종 비활성화 여부: 서버 판단 우선, 없으면 클라이언트 판단
      const isDisabled = !serverEnabled || !isAffordable;

      // 비활성화 사유 결정
      let finalDisabledReason: string | null = null;
      if (!serverEnabled && card.disabled_reason) {
        finalDisabledReason = card.disabled_reason;
      } else if (!isAffordable) {
        finalDisabledReason = t('action.insufficient_balance');
      }

      return {
        ...card,
        isAffordable,
        isDisabled,
        finalDisabledReason,
      };
    });
  }, [displayCards, currentBalance, t]);

  // 일반 카드와 대안 카드 분리 (대안 카드는 뒤에 배치)
  const sortedCards = useMemo(() => {
    const regular = processedCards.filter((c) => !c.is_alternative);
    const alternatives = processedCards.filter((c) => c.is_alternative);
    return [...regular, ...alternatives];
  }, [processedCards]);

  return (
    <div className="action-deck" role="group" aria-label={t('action.deck_label')}>
      {sortedCards.map((card) => (
        <ActionCardItem
          key={card.id}
          card={card}
          onClick={() => onCardClick?.(card)}
          onHover={handleCardHover}
          disabled={disabled}
        />
      ))}

      {/* 모든 카드가 비활성화되었을 때 안내 */}
      {sortedCards.every((c) => c.isDisabled) && !disabled && (
        <div className="deck-empty-notice">{t('action.all_disabled_notice')}</div>
      )}
    </div>
  );
}

export default ActionDeck;
</file>

<file path="frontend/src/components/AgentConsole.tsx">
/**
 * Unknown World - Agent Console 컴포넌트.
 *
 * 에이전트형 시스템임을 UI로 증명하기 위한 컴포넌트입니다.
 * Plan/Queue/Badges/Auto-repair 트레이스를 실시간으로 표시합니다.
 *
 * 설계 원칙:
 *   - RULE-008: 단계/배지/복구만 보여줌 (프롬프트/내부 추론 노출 금지)
 *   - RULE-002: 게임 UI로 표현 (채팅 버블 금지)
 *
 * @module components/AgentConsole
 */

import { useTranslation } from 'react-i18next';
import {
  useAgentStore,
  selectIsStreaming,
  selectPhases,
  selectBadges,
  selectRepairCount,
  selectError,
  type PhaseInfo,
} from '../stores/agentStore';
import type { ValidationBadge } from '../schemas/turn';

// =============================================================================
// 상수 정의
// =============================================================================

/** 단계 표시 이름 i18n 키 */
const PHASE_KEYS: Record<string, string> = {
  parse: 'agent.console.phase.parse',
  validate: 'agent.console.phase.validate',
  plan: 'agent.console.phase.plan',
  resolve: 'agent.console.phase.resolve',
  render: 'agent.console.phase.render',
  verify: 'agent.console.phase.verify',
  commit: 'agent.console.phase.commit',
};

/** 배지 표시 정보 (i18n 키 기반) */
const BADGE_INFO: Record<ValidationBadge, { labelKey: string; isOk: boolean }> = {
  schema_ok: { labelKey: 'agent.console.badge.schema', isOk: true },
  schema_fail: { labelKey: 'agent.console.badge.schema', isOk: false },
  economy_ok: { labelKey: 'agent.console.badge.economy', isOk: true },
  economy_fail: { labelKey: 'agent.console.badge.economy', isOk: false },
  safety_ok: { labelKey: 'agent.console.badge.safety', isOk: true },
  safety_blocked: { labelKey: 'agent.console.badge.safety', isOk: false },
  consistency_ok: { labelKey: 'agent.console.badge.consistency', isOk: true },
  consistency_fail: { labelKey: 'agent.console.badge.consistency', isOk: false },
};

// =============================================================================
// 하위 컴포넌트
// =============================================================================

/** 단계 상태 아이콘 */
function PhaseIcon({ status }: { status: PhaseInfo['status'] }) {
  switch (status) {
    case 'pending':
      return <span className="phase-icon pending">○</span>;
    case 'in_progress':
      return <span className="phase-icon in-progress">◎</span>;
    case 'completed':
      return <span className="phase-icon completed">●</span>;
    case 'failed':
      return <span className="phase-icon failed">✕</span>;
    default:
      return <span className="phase-icon">○</span>;
  }
}

/** 단계 큐 항목 */
function PhaseQueueItem({ phase }: { phase: PhaseInfo }) {
  const { t } = useTranslation();
  const key = PHASE_KEYS[phase.name];
  const label = key ? t(key) : phase.name;
  const statusClass = `phase-item ${phase.status}`;

  return (
    <div className={statusClass}>
      <PhaseIcon status={phase.status} />
      <span className="phase-label">{label}</span>
    </div>
  );
}

/** 단계 큐 */
function PhaseQueue() {
  const { t } = useTranslation();
  const phases = useAgentStore(selectPhases);

  return (
    <div className="phase-queue">
      <div className="queue-label">{t('agent.console.queue')}</div>
      <div className="queue-items">
        {phases.map((phase) => (
          <PhaseQueueItem key={phase.name} phase={phase} />
        ))}
      </div>
    </div>
  );
}

/** 배지 아이템 */
function BadgeItem({ badge }: { badge: ValidationBadge }) {
  const { t } = useTranslation();
  const info = BADGE_INFO[badge];
  if (!info) return null;

  const statusClass = info.isOk ? 'badge-ok' : 'badge-fail';
  const statusText = info.isOk ? t('agent.console.badge.ok') : t('agent.console.badge.fail');
  const iconName = info.isOk ? 'badge-ok-24.png' : 'badge-fail-24.png';
  const fallbackIcon = info.isOk ? '✓' : '✗';

  return (
    <div className={`badge-item ${statusClass}`}>
      <span className="badge-label">{t(info.labelKey)}</span>
      <span className="badge-status">
        <span className="icon-wrapper">
          <img
            src={`/ui/icons/${iconName}`}
            alt=""
            aria-hidden="true"
            className="badge-icon-img"
            onError={(e) => e.currentTarget.classList.add('hidden')}
          />
          <span className="icon-fallback" style={{ fontSize: '0.625rem' }}>
            {fallbackIcon}
          </span>
        </span>
        {statusText}
      </span>
    </div>
  );
}

/** 배지 패널 */
function BadgesPanel() {
  const { t } = useTranslation();
  const badges = useAgentStore(selectBadges);

  if (badges.length === 0) {
    return (
      <div className="badges-panel">
        <div className="badges-label">{t('agent.console.badges')}</div>
        <div className="badges-empty">{t('agent.console.badges_empty')}</div>
      </div>
    );
  }

  return (
    <div className="badges-panel">
      <div className="badges-label">{t('agent.console.badges')}</div>
      <div className="badges-grid">
        {badges.map((badge, index) => (
          <BadgeItem key={`${badge}-${index}`} badge={badge} />
        ))}
      </div>
    </div>
  );
}

/** Auto-repair 트레이스 */
function RepairTrace() {
  const { t } = useTranslation();
  const repairCount = useAgentStore(selectRepairCount);
  const isStreaming = useAgentStore(selectIsStreaming);

  if (repairCount === 0 && !isStreaming) {
    return null;
  }

  return (
    <div className="repair-trace">
      <span className="repair-label">{t('agent.console.repair')}</span>
      <span className="repair-count">#{repairCount}</span>
      {repairCount > 0 && (
        <span className="repair-status text-warning"> {t('agent.console.repaired')}</span>
      )}
    </div>
  );
}

/** 에러 표시 */
function ErrorDisplay() {
  const error = useAgentStore(selectError);

  if (!error) return null;

  return (
    <div className="agent-error">
      <span className="error-icon">⚠</span>
      <span className="error-message">{error.message}</span>
      {error.code && <span className="error-code">[{error.code}]</span>}
    </div>
  );
}

/** 스트리밍 상태 표시 */
function StreamingStatus() {
  const { t } = useTranslation();
  const isStreaming = useAgentStore(selectIsStreaming);

  return (
    <div className="streaming-status">
      <span className={`status-dot ${isStreaming ? 'active' : ''}`} />
      <span className="status-text">
        {isStreaming ? t('agent.console.status.processing') : t('agent.console.status.idle')}
      </span>
    </div>
  );
}

// =============================================================================
// 메인 컴포넌트
// =============================================================================

/**
 * Agent Console 컴포넌트.
 *
 * Plan/Queue/Badges/Auto-repair를 실시간으로 표시합니다.
 * RULE-008에 따라 프롬프트/내부 추론은 노출하지 않습니다.
 *
 * U-037: data-ui-importance="critical" 마킹으로 가독성 보장
 */
export function AgentConsole() {
  return (
    <div className="agent-console-content" data-ui-importance="critical">
      <StreamingStatus />
      <PhaseQueue />
      <BadgesPanel />
      <RepairTrace />
      <ErrorDisplay />
    </div>
  );
}

export default AgentConsole;
</file>

<file path="frontend/src/components/SceneCanvas.hotspot.test.tsx">
import { describe, it, expect, vi, beforeEach } from 'vitest';
import { render, screen, fireEvent, act } from '@testing-library/react';
import { SceneCanvas } from './SceneCanvas';
import type { SceneObject } from '../schemas/turn';
import type { SceneCanvasState } from '../types/scene';
import { useWorldStore } from '../stores/worldStore';
import { useAgentStore } from '../stores/agentStore';

// i18next 모킹
vi.mock('react-i18next', () => ({
  useTranslation: () => ({
    t: (key: string) => key,
  }),
}));

// ResizeObserver 모킹
let resizeCallback: (entries: ResizeObserverEntry[]) => void;
class MockResizeObserver {
  constructor(callback: (entries: ResizeObserverEntry[]) => void) {
    resizeCallback = callback;
  }
  observe = vi.fn();
  unobserve = vi.fn();
  disconnect = vi.fn();
}

global.ResizeObserver = MockResizeObserver as unknown as typeof ResizeObserver;

/**
 * 리사이즈 이벤트를 수동으로 트리거합니다.
 */
function triggerResize(width: number, height: number) {
  if (resizeCallback) {
    act(() => {
      resizeCallback([
        {
          contentRect: { width, height } as DOMRectReadOnly,
          target: document.querySelector('.scene-canvas') as Element,
        } as ResizeObserverEntry,
      ]);
    });
  }
}

// getBoundingClientRect 모킹
Element.prototype.getBoundingClientRect = vi.fn(() => ({
  width: 800,
  height: 600,
  top: 0,
  left: 0,
  bottom: 600,
  right: 800,
  x: 0,
  y: 0,
  toJSON: () => {},
})) as unknown as () => DOMRect;

describe('SceneCanvas Hotspots', () => {
  const defaultState: SceneCanvasState = {
    status: 'scene',
    imageUrl: 'https://example.com/scene.png',
  };

  const mockObjects: SceneObject[] = [
    {
      id: 'obj-1',
      label: 'Object 1',
      box_2d: { ymin: 100, xmin: 100, ymax: 200, xmax: 200 },
      interaction_hint: 'Click me',
    },
    {
      id: 'obj-2',
      label: 'Object 2',
      box_2d: { ymin: 500, xmin: 500, ymax: 700, xmax: 700 },
      interaction_hint: null,
    },
  ];

  beforeEach(() => {
    vi.clearAllMocks();
    // 스토어 초기화
    useWorldStore.setState({
      sceneState: { status: 'default', message: '' },
      sceneObjects: [],
    });
    useAgentStore.setState({ isStreaming: false });
  });

  it('should render hotspots when objects are provided in worldStore and status is scene (sorted by area)', () => {
    useWorldStore.setState({
      sceneState: defaultState,
      sceneObjects: mockObjects,
    });

    render(<SceneCanvas />);

    // 핫스팟 레이어 확인
    const layer = screen.getByLabelText('scene.hotspot.layer_label');
    expect(layer).toBeInTheDocument();

    // 개별 핫스팟 확인 (role="button")
    // RU-003-S2: 면적 기반 정렬 - 큰 것이 먼저 렌더링되어 낮은 z-index를 가짐
    // Object 1: 100x100 = 10,000
    // Object 2: 200x200 = 40,000
    // 따라서 Object 2가 먼저 오고 Object 1이 나중에 옴
    const buttons = screen.getAllByRole('button');
    expect(buttons).toHaveLength(mockObjects.length);
    expect(buttons[0]).toHaveAttribute('aria-label', 'Object 2');
    expect(buttons[1]).toHaveAttribute('aria-label', 'Object 1');

    // z-index 확인 (RU-003-S2: HotspotOverlay 자체에 style로 적용됨)
    expect(buttons[0]).toHaveStyle({ zIndex: '1' });
    expect(buttons[1]).toHaveStyle({ zIndex: '2' });
  });

  it('should not render hotspots when status is loading', () => {
    useWorldStore.setState({
      sceneState: { status: 'loading' },
      sceneObjects: mockObjects,
    });

    render(<SceneCanvas />);

    const layer = screen.queryByLabelText('scene.hotspot.layer_label');
    expect(layer).not.toBeInTheDocument();
  });

  it('should call onHotspotClick when a hotspot is clicked', () => {
    const onHotspotClick = vi.fn();
    useWorldStore.setState({
      sceneState: defaultState,
      sceneObjects: mockObjects,
    });

    render(<SceneCanvas onHotspotClick={onHotspotClick} />);

    const firstHotspot = screen.getByLabelText('Object 1');
    fireEvent.click(firstHotspot);

    expect(onHotspotClick).toHaveBeenCalledWith({
      object_id: 'obj-1',
      box_2d: mockObjects[0].box_2d,
    });
  });

  it('should show tooltip on hover', async () => {
    useWorldStore.setState({
      sceneState: defaultState,
      sceneObjects: mockObjects,
    });

    render(<SceneCanvas />);

    const firstHotspot = screen.getByLabelText('Object 1');

    // Hover 시작
    fireEvent.mouseEnter(firstHotspot);

    // 툴팁 라벨 확인
    expect(screen.getByText('Object 1')).toBeInTheDocument();
    expect(screen.getByText(/scene.hotspot.hint_prefix/)).toBeInTheDocument();
    expect(screen.getByText(/Click me/)).toBeInTheDocument();

    // Hover 종료
    fireEvent.mouseLeave(firstHotspot);
    expect(screen.queryByText('Object 1')).not.toBeInTheDocument();
  });

  it('should be disabled when agentStore.isStreaming is true', () => {
    const onHotspotClick = vi.fn();
    useWorldStore.setState({
      sceneState: defaultState,
      sceneObjects: mockObjects,
    });
    useAgentStore.setState({ isStreaming: true });

    render(<SceneCanvas onHotspotClick={onHotspotClick} />);

    const firstHotspot = screen.getByLabelText('Object 1');
    expect(firstHotspot).toHaveAttribute('aria-disabled', 'true');
    expect(firstHotspot).toHaveAttribute('tabindex', '-1');

    fireEvent.click(firstHotspot);
    expect(onHotspotClick).not.toHaveBeenCalled();
  });

  it('should reposition hotspots when canvas size changes (reactive resize)', async () => {
    vi.useFakeTimers();
    useWorldStore.setState({
      sceneState: defaultState,
      sceneObjects: mockObjects,
    });

    render(<SceneCanvas />);

    // Object 1 찾기 (정렬에 의해 두 번째 버튼일 수 있음)
    const firstHotspot = screen.getByLabelText('Object 1');

    // 초기 크기 (800x600) 기반 위치 확인
    expect(firstHotspot).toHaveStyle({
      top: '60px',
      left: '80px',
      width: '80px',
      height: '60px',
    });

    // 크기 변경 트리거 (400x300)
    triggerResize(400, 300);

    // RU-003-S2: ResizeObserver 디바운스(100ms) 대기
    act(() => {
      vi.advanceTimersByTime(150);
    });

    // 변경된 크기 기반 위치 확인
    expect(firstHotspot).toHaveStyle({
      top: '30px',
      left: '40px',
      width: '40px',
      height: '30px',
    });

    vi.useRealTimers();
  });
});
</file>

<file path="frontend/src/stores/worldStore.ts">
/**
 * Unknown World - World/Session 상태 관리 (Zustand) (RU-003-Q4).
 *
 * TurnOutput 반영으로 갱신되는 세션 월드/UI 상태를 SSOT로 관리합니다.
 * App.tsx의 로컬 상태를 이 스토어로 이동하여 책임 경계를 명확히 합니다.
 *
 * 설계 원칙:
 *   - RU-003 Q1 결정: 도메인별 store 분리 (Option A)
 *   - RULE-005: Economy 인바리언트 (잔액 음수 금지)
 *   - RULE-006: ko/en i18n 정책 준수
 *
 * 확장 (U-013):
 *   - Quest/Rules/MutationEvent 상태 추가
 *   - applyTurnOutput에서 quests_updated, rules_changed 반영
 *
 * 순환 import 방지:
 *   - worldStore → (actionDeckStore/inventoryStore) 단방향만 허용
 *   - 역방향 import 금지
 *
 * @module stores/worldStore
 */

import { create } from 'zustand';
import type { TurnOutput, SceneObject, Quest, WorldRule } from '../schemas/turn';
import type { SceneCanvasState } from '../types/scene';
import { useActionDeckStore } from './actionDeckStore';
import { useInventoryStore, parseInventoryAdded } from './inventoryStore';
import { useEconomyStore } from './economyStore';

// =============================================================================
// 타입 정의
// =============================================================================

/** 재화 상태 */
export interface EconomyState {
  signal: number;
  memory_shard: number;
}

/** 내러티브 엔트리 */
export interface NarrativeEntry {
  turn: number;
  text: string;
}

/**
 * 룰 변형 이벤트 (U-013: Mutation Timeline)
 * 규칙이 변경된 시점과 내용을 기록합니다.
 */
export interface MutationEvent {
  /** 변형 발생 턴 */
  turn: number;
  /** 변형된 규칙 ID */
  ruleId: string;
  /** 변형 유형: 추가/수정/제거 */
  type: 'added' | 'modified' | 'removed';
  /** 규칙 라벨 (표시용) */
  label: string;
  /** 규칙 설명 (선택) */
  description?: string;
  /** 타임스탬프 */
  timestamp: number;
}

/** World/Session 상태 */
export interface WorldState {
  /** 재화 상태 (RULE-005) */
  economy: EconomyState;
  /** 연결 상태 */
  isConnected: boolean;
  /** Scene Canvas 상태 (U-031) */
  sceneState: SceneCanvasState;
  /** Scene Objects (U-010: 핫스팟 오버레이) */
  sceneObjects: SceneObject[];
  /** 내러티브 히스토리 */
  narrativeEntries: NarrativeEntry[];
  /** 현재 턴 카운트 */
  turnCount: number;

  // ============ U-013: Quest + Rule Board 확장 ============

  /** 현재 퀘스트/목표 목록 */
  quests: Quest[];
  /** 현재 적용 중인 규칙 목록 */
  activeRules: WorldRule[];
  /** 룰 변형 이벤트 타임라인 (최신순) */
  mutationTimeline: MutationEvent[];
}

/** World Store 액션 */
export interface WorldActions {
  /**
   * TurnOutput을 받아 모든 관련 상태를 업데이트합니다.
   * 이 메서드가 TurnOutput 반영의 SSOT입니다.
   */
  applyTurnOutput: (output: TurnOutput) => void;

  /**
   * 시스템 내러티브를 추가합니다 (턴 미발생 피드백용).
   * 드롭 실패 등 턴을 발생시키지 않는 피드백에 사용합니다.
   */
  appendSystemNarrative: (text: string) => void;

  /** Scene 상태 설정 */
  setSceneState: (state: SceneCanvasState) => void;

  /** 연결 상태 설정 */
  setConnected: (connected: boolean) => void;

  /** 경제 상태 설정 (직접 조작용, 일반적으로 applyTurnOutput 사용) */
  setEconomy: (economy: EconomyState) => void;

  /** Scene Objects 설정 (직접 조작용) */
  setSceneObjects: (objects: SceneObject[]) => void;

  /** 초기화 (초기 내러티브 메시지 포함) */
  initialize: (welcomeMessage: string) => void;

  /** 상태 완전 초기화 */
  reset: () => void;
}

export type WorldStore = WorldState & WorldActions;

// =============================================================================
// 초기 상태
// =============================================================================

function createInitialState(): WorldState {
  return {
    economy: { signal: 100, memory_shard: 5 },
    isConnected: true,
    sceneState: { status: 'default', message: '' },
    sceneObjects: [],
    narrativeEntries: [],
    turnCount: 0,
    // U-013: Quest + Rule Board 초기 상태
    quests: [],
    activeRules: [],
    mutationTimeline: [],
  };
}

// =============================================================================
// Zustand Store
// =============================================================================

/**
 * World/Session 상태 스토어.
 *
 * TurnOutput 반영의 SSOT로, App.tsx의 로컬 상태를 대체합니다.
 *
 * @example
 * ```tsx
 * // 컴포넌트에서 상태 구독
 * const { economy, narrativeEntries } = useWorldStore();
 *
 * // TurnOutput 반영 (스트림 완료 시)
 * const applyTurnOutput = useWorldStore((state) => state.applyTurnOutput);
 * applyTurnOutput(turnOutput);
 *
 * // 시스템 피드백 추가 (드롭 실패 등)
 * const appendSystemNarrative = useWorldStore((state) => state.appendSystemNarrative);
 * appendSystemNarrative('아이템을 사용할 수 없습니다.');
 * ```
 */
export const useWorldStore = create<WorldStore>((set, get) => ({
  // 초기 상태
  ...createInitialState(),

  // 액션

  applyTurnOutput: (output) => {
    const state = get();

    // 1. 턴 카운트 증가
    const newTurnCount = state.turnCount + 1;

    // 2. 내러티브 추가
    const newNarrativeEntry: NarrativeEntry = {
      turn: newTurnCount,
      text: output.narrative,
    };

    // 3. 경제 상태 업데이트 (RULE-005: balance_after 반영)
    const newEconomy: EconomyState = {
      signal: output.economy.balance_after.signal,
      memory_shard: output.economy.balance_after.memory_shard,
    };

    // 4. Scene Objects 업데이트 (U-010: 핫스팟 오버레이)
    const newSceneObjects = output.ui.objects;

    // 5. Scene 상태 전이 (RU-003-T1: Scene 이미지 SSOT)
    // - output.ui.scene.image_url이 존재하면 'scene' 상태로 전환
    // - 없으면 'default' 상태 유지
    // - safety.blocked인 경우 'blocked' 상태로 전환
    let newSceneState: SceneCanvasState;
    if (output.safety.blocked) {
      newSceneState = {
        status: 'blocked',
        message: output.safety.message ?? undefined,
      };
    } else if (output.ui.scene?.image_url) {
      newSceneState = {
        status: 'scene',
        imageUrl: output.ui.scene.image_url,
        message: output.ui.scene.alt_text ?? undefined,
      };
    } else {
      newSceneState = {
        status: 'default',
        message: '',
      };
    }

    // 7. 하위 스토어 업데이트 (순환 import 방지: worldStore → 하위 store 단방향)
    // Action Deck 카드 업데이트 (U-009)
    useActionDeckStore.getState().setCards(output.ui.action_deck.cards);

    // Inventory 업데이트 (U-011)
    if (output.world.inventory_added.length > 0) {
      useInventoryStore.getState().addItems(parseInventoryAdded(output.world.inventory_added));
    }
    if (output.world.inventory_removed.length > 0) {
      useInventoryStore.getState().removeItems(output.world.inventory_removed);
    }

    // Economy Store 업데이트 (U-014: Ledger 기록)
    const economyStore = useEconomyStore.getState();
    economyStore.addLedgerEntry({
      turnId: newTurnCount,
      reason: output.narrative.slice(0, 50), // 내러티브 앞 50자를 사유로 사용
      cost: output.economy.cost,
      balanceAfter: output.economy.balance_after,
      modelLabel: output.agent_console.badges.includes('schema_ok') ? 'QUALITY' : 'FAST',
    });
    // 잔액 부족 상태 업데이트
    economyStore.updateBalanceLowStatus(newEconomy);

    // 6. Quest 상태 업데이트 (U-013)
    // quests_updated는 전체 퀘스트 목록이 아닌 "업데이트된" 퀘스트만 포함
    // 기존 퀘스트를 업데이트하거나 새 퀘스트를 추가
    const newQuests = [...state.quests];
    for (const updatedQuest of output.world.quests_updated) {
      const existingIndex = newQuests.findIndex((q) => q.id === updatedQuest.id);
      if (existingIndex >= 0) {
        // 기존 퀘스트 업데이트
        newQuests[existingIndex] = updatedQuest;
      } else {
        // 새 퀘스트 추가
        newQuests.push(updatedQuest);
      }
    }

    // 7. Rules 상태 업데이트 + Mutation Timeline 기록 (U-013)
    const newActiveRules = [...state.activeRules];
    const newMutationEvents: MutationEvent[] = [];
    const now = Date.now();

    for (const changedRule of output.world.rules_changed) {
      const existingIndex = newActiveRules.findIndex((r) => r.id === changedRule.id);
      if (existingIndex >= 0) {
        // 기존 규칙 수정
        newActiveRules[existingIndex] = changedRule;
        newMutationEvents.push({
          turn: newTurnCount,
          ruleId: changedRule.id,
          type: 'modified',
          label: changedRule.label,
          description: changedRule.description ?? undefined,
          timestamp: now,
        });
      } else {
        // 새 규칙 추가
        newActiveRules.push(changedRule);
        newMutationEvents.push({
          turn: newTurnCount,
          ruleId: changedRule.id,
          type: 'added',
          label: changedRule.label,
          description: changedRule.description ?? undefined,
          timestamp: now,
        });
      }
    }

    // 타임라인에 새 이벤트 추가 (최신순 정렬)
    const updatedTimeline = [...newMutationEvents, ...state.mutationTimeline];

    // 8. 상태 업데이트 (RU-003-T1: sceneState 포함, U-013: quest/rules)
    set({
      turnCount: newTurnCount,
      narrativeEntries: [...state.narrativeEntries, newNarrativeEntry],
      economy: newEconomy,
      sceneObjects: newSceneObjects,
      sceneState: newSceneState,
      // U-013 확장
      quests: newQuests,
      activeRules: newActiveRules,
      mutationTimeline: updatedTimeline,
    });

    // === 향후 확장 슬롯 (RU-003-Q4 Step 4) ===
    // TODO: output.world.memory_pins → Memory Pin 패널 업데이트
  },

  appendSystemNarrative: (text) => {
    set((state) => ({
      narrativeEntries: [
        ...state.narrativeEntries,
        {
          turn: state.turnCount, // 현재 턴으로 기록 (턴 증가 없음)
          text,
        },
      ],
    }));
  },

  setSceneState: (sceneState) => {
    set({ sceneState });
  },

  setConnected: (isConnected) => {
    set({ isConnected });
  },

  setEconomy: (economy) => {
    set({ economy });
  },

  setSceneObjects: (sceneObjects) => {
    set({ sceneObjects });
  },

  initialize: (welcomeMessage) => {
    set({
      ...createInitialState(),
      narrativeEntries: [{ turn: 0, text: welcomeMessage }],
    });
  },

  reset: () => {
    set(createInitialState());
  },
}));

// =============================================================================
// 셀렉터 (성능 최적화용)
// =============================================================================

/** 경제 상태 셀렉터 */
export const selectEconomy = (state: WorldStore) => state.economy;

/** Signal 잔액 셀렉터 */
export const selectSignal = (state: WorldStore) => state.economy.signal;

/** Memory Shard 잔액 셀렉터 */
export const selectMemoryShard = (state: WorldStore) => state.economy.memory_shard;

/** 연결 상태 셀렉터 */
export const selectIsConnected = (state: WorldStore) => state.isConnected;

/** Scene 상태 셀렉터 */
export const selectSceneState = (state: WorldStore) => state.sceneState;

/** Scene Objects 셀렉터 */
export const selectSceneObjects = (state: WorldStore) => state.sceneObjects;

/** 내러티브 엔트리 셀렉터 */
export const selectNarrativeEntries = (state: WorldStore) => state.narrativeEntries;

/** 턴 카운트 셀렉터 */
export const selectTurnCount = (state: WorldStore) => state.turnCount;

// ============ U-013: Quest + Rule Board 셀렉터 ============

/** 퀘스트 목록 셀렉터 */
export const selectQuests = (state: WorldStore) => state.quests;

/** 활성 규칙 목록 셀렉터 */
export const selectActiveRules = (state: WorldStore) => state.activeRules;

/** 뮤테이션 타임라인 셀렉터 */
export const selectMutationTimeline = (state: WorldStore) => state.mutationTimeline;

/** 진행 중인 퀘스트 셀렉터 */
export const selectActiveQuests = (state: WorldStore) =>
  state.quests.filter((q) => !q.is_completed);

/** 완료된 퀘스트 셀렉터 */
export const selectCompletedQuests = (state: WorldStore) =>
  state.quests.filter((q) => q.is_completed);
</file>

<file path="frontend/src/turn/turnRunner.ts">
/**
 * Unknown World - Turn Runner 모듈
 *
 * RU-003-Q3: Turn 실행/스트리밍 결합을 App.tsx에서 분리하여
 * "레이아웃 + 이벤트 라우팅"과 "오케스트레이션"을 명확히 분리합니다.
 *
 * 책임:
 *   - TurnInput 생성 (언어/클릭/드롭/클라이언트 정보/재화 스냅샷)
 *   - 스트림 시작/취소/콜백 라우팅
 *   - agentStore/worldStore로 이벤트 분배
 *
 * 설계 원칙:
 *   - RULE-002: 채팅 앱이 아닌 상태 기반 게임 시스템
 *   - RULE-003/004: 구조화 출력 + 검증/복구
 *   - RULE-006: ko/en i18n 정책 준수
 *
 * @module turn/turnRunner
 */

import type { TurnInput, DropInput } from '../schemas/turn';
import type { HotspotClickData } from '../components/SceneCanvas';
import { getResolvedLanguage } from '../i18n';
import { startTurnStream, type StreamCallbacks } from '../api/turnStream';
import { useAgentStore } from '../stores/agentStore';
import { useWorldStore } from '../stores/worldStore';

// =============================================================================
// 타입 정의
// =============================================================================

/** TurnInput 생성을 위한 파라미터 */
export interface BuildTurnInputParams {
  /** 사용자 입력 텍스트 */
  text: string;
  /** 액션 카드 ID (선택) */
  actionId?: string;
  /** 핫스팟 클릭 데이터 (U-010) */
  click?: HotspotClickData;
  /** 드롭 데이터 (U-012) */
  drop?: DropInput;
  /** 재화 스냅샷 */
  economySnapshot: { signal: number; memory_shard: number };
  /** UI 테마 */
  theme: 'dark' | 'light';
}

/** Turn 실행을 위한 파라미터 (App에서 호출 시 사용) */
export interface RunTurnParams {
  /** 사용자 입력 텍스트 */
  text: string;
  /** 액션 카드 ID (선택) */
  actionId?: string;
  /** 핫스팟 클릭 데이터 (U-010) */
  click?: HotspotClickData;
  /** 드롭 데이터 (U-012) */
  drop?: DropInput;
}

/** Turn Runner 인터페이스 */
export interface TurnRunner {
  /** 턴 실행 (스트림 시작) */
  runTurn: (params: RunTurnParams) => void;
  /** 스트림 취소 */
  cancel: () => void;
}

// =============================================================================
// TurnInput 생성
// =============================================================================

/**
 * TurnInput을 생성합니다.
 *
 * 언어, 클릭, 드롭, 클라이언트 정보, 재화 스냅샷을 조합하여
 * 서버로 전송할 TurnInput을 생성합니다.
 */
export function buildTurnInput(params: BuildTurnInputParams): TurnInput {
  const { text, actionId, click, drop, economySnapshot, theme } = params;

  return {
    language: getResolvedLanguage(),
    text,
    action_id: actionId ?? null,
    // U-010: 핫스팟 클릭 데이터 포함 (Q1: Option B)
    click: click
      ? {
          object_id: click.object_id,
          box_2d: click.box_2d,
        }
      : null,
    // U-012: 아이템 드롭 데이터 포함 (Q1: Option B - target_box_2d 포함)
    drop: drop ?? null,
    client: {
      viewport_w: window.innerWidth,
      viewport_h: window.innerHeight,
      theme,
    },
    economy_snapshot: economySnapshot,
  };
}

// =============================================================================
// Turn Runner 생성
// =============================================================================

/**
 * Turn Runner를 생성합니다.
 *
 * RU-003-Q3: App에서 Turn Runner 인스턴스를 생성하여 사용합니다.
 * 스트림 콜백은 agentStore와 worldStore로 라우팅됩니다.
 *
 * @param deps - 의존성 (i18n 번역 함수 등)
 * @returns Turn Runner 인터페이스
 *
 * @example
 * ```tsx
 * // App.tsx에서 사용
 * const runner = useMemo(() => createTurnRunner({
 *   t,
 *   theme: 'dark',
 * }), [t]);
 *
 * runner.runTurn({ text: 'hello' });
 * ```
 */
export function createTurnRunner(deps: {
  /** i18n 번역 함수 */
  t: (key: string, options?: Record<string, unknown>) => string;
  /** UI 테마 */
  theme: 'dark' | 'light';
}): TurnRunner {
  const { t, theme } = deps;

  // 취소 함수 저장
  let cancelFn: (() => void) | null = null;

  /**
   * 턴을 실행합니다.
   */
  const runTurn = (params: RunTurnParams): void => {
    // 스트리밍 중이면 무시
    const isStreaming = useAgentStore.getState().isStreaming;
    if (isStreaming) return;

    // Store 액션 가져오기 (클로저 외부에서 호출 시점에 최신 상태 참조)
    const agentStore = useAgentStore.getState();
    const worldStore = useWorldStore.getState();

    // 재화 스냅샷 가져오기
    const economySnapshot = worldStore.economy;

    // TurnInput 생성
    const turnInput = buildTurnInput({
      text:
        params.text ||
        (params.actionId ? t('action.card_select', { cardId: params.actionId }) : ''),
      actionId: params.actionId,
      click: params.click,
      drop: params.drop,
      economySnapshot,
      theme,
    });

    // Agent Store 시작
    agentStore.startStream();

    // Scene Canvas를 로딩 상태로 전환 (U-031)
    worldStore.setSceneState({ status: 'loading', message: t('scene.status.syncing') });

    // 스트림 콜백 설정 (RU-003-Q3: agentStore + worldStore로 라우팅)
    // RU-003-T1: sceneState 전이는 worldStore.applyTurnOutput에서 SSOT로 처리
    const callbacks: StreamCallbacks = {
      // Stage/Badges/NarrativeDelta → agentStore로만 전달
      onStage: (event) => {
        useAgentStore.getState().handleStage(event);
      },
      onBadges: (event) => {
        useAgentStore.getState().handleBadges(event);
      },
      onNarrativeDelta: (event) => {
        useAgentStore.getState().handleNarrativeDelta(event);
      },
      // Final → agentStore.handleFinal + worldStore.applyTurnOutput
      onFinal: (event) => {
        useAgentStore.getState().handleFinal(event);
        // RU-003-Q4: TurnOutput 반영 SSOT
        useWorldStore.getState().applyTurnOutput(event.data);
        // RU-003-S1: 성공적인 final 수신 시 연결 상태 낙관적 복구
        useWorldStore.getState().setConnected(true);
      },
      // Error → agentStore.handleError + worldStore 상태 복구
      onError: (event) => {
        useAgentStore.getState().handleError(event);
        useWorldStore.getState().setConnected(false);
        // Scene Canvas를 오프라인/에러 상태로 전환 (U-031)
        const errorCode = event.code;
        if (errorCode === 'SAFETY_BLOCKED') {
          useWorldStore.getState().setSceneState({ status: 'blocked', message: event.message });
        } else if (errorCode === 'INSUFFICIENT_BALANCE') {
          useWorldStore.getState().setSceneState({ status: 'low_signal', message: event.message });
        } else {
          useWorldStore.getState().setSceneState({ status: 'offline', message: event.message });
        }
      },
      // Complete → agentStore.completeStream
      // RU-003-T1: sceneState 전이는 worldStore.applyTurnOutput에서 SSOT로 처리
      // - 성공 시: onFinal → applyTurnOutput에서 ui.scene.image_url 기반으로 설정
      // - 에러 시: onError에서 이미 offline/blocked/low_signal으로 설정됨
      onComplete: () => {
        useAgentStore.getState().completeStream();
        // RU-003-T1: sceneState는 applyTurnOutput(성공) 또는 onError(실패)에서 이미 설정됨
        // 여기서 추가로 설정하면 applyTurnOutput의 설정을 덮어쓰게 되므로 제거
      },
    };

    // 스트림 시작
    cancelFn = startTurnStream(turnInput, callbacks);
  };

  /**
   * 스트림을 취소합니다.
   *
   * 추후 Cancel/Pause/Autopilot UX를 위한 기본 골격입니다.
   * 현재 executeTurnStream은 Abort 시 onComplete를 호출하지 않으므로,
   * Cancel 버튼을 넣을 계획이라면 "취소 시 UI 복구 정책"을 별도로 명시해야 합니다.
   */
  const cancel = (): void => {
    cancelFn?.();
    cancelFn = null;
  };

  return {
    runTurn,
    cancel,
  };
}

// =============================================================================
// React Hook (선택적 사용)
// =============================================================================

/**
 * Turn Runner를 React 컴포넌트에서 사용하기 위한 훅.
 *
 * @param deps - 의존성
 * @returns Turn Runner 인터페이스 및 취소 효과
 *
 * @example
 * ```tsx
 * // 컴포넌트에서 사용
 * const { runTurn, cancel } = useTurnRunner({ t, theme: 'dark' });
 * ```
 */
import { useCallback, useEffect, useRef } from 'react';

export function useTurnRunner(deps: {
  t: (key: string, options?: Record<string, unknown>) => string;
  theme: 'dark' | 'light';
}): TurnRunner {
  const { t, theme } = deps;

  // 취소 함수 저장 ref
  const cancelFnRef = useRef<(() => void) | null>(null);

  // runTurn을 useCallback으로 정의
  const runTurn = useCallback(
    (params: RunTurnParams): void => {
      // 스트리밍 중이면 무시
      const isStreaming = useAgentStore.getState().isStreaming;
      if (isStreaming) return;

      // Store 액션 가져오기
      const agentStore = useAgentStore.getState();
      const worldStore = useWorldStore.getState();

      // 재화 스냅샷 가져오기
      const economySnapshot = worldStore.economy;

      // TurnInput 생성
      const turnInput = buildTurnInput({
        text:
          params.text ||
          (params.actionId ? t('action.card_select', { cardId: params.actionId }) : ''),
        actionId: params.actionId,
        click: params.click,
        drop: params.drop,
        economySnapshot,
        theme,
      });

      // Agent Store 시작
      agentStore.startStream();

      // Scene Canvas를 로딩 상태로 전환 (U-031)
      worldStore.setSceneState({ status: 'loading', message: t('scene.status.syncing') });

      // 스트림 콜백 설정 (RU-003-Q3: agentStore + worldStore로 라우팅)
      // RU-003-T1: sceneState 전이는 worldStore.applyTurnOutput에서 SSOT로 처리
      const callbacks: StreamCallbacks = {
        onStage: (event) => {
          useAgentStore.getState().handleStage(event);
        },
        onBadges: (event) => {
          useAgentStore.getState().handleBadges(event);
        },
        onNarrativeDelta: (event) => {
          useAgentStore.getState().handleNarrativeDelta(event);
        },
        onFinal: (event) => {
          useAgentStore.getState().handleFinal(event);
          useWorldStore.getState().applyTurnOutput(event.data);
          // RU-003-S1: 성공적인 final 수신 시 연결 상태 낙관적 복구
          useWorldStore.getState().setConnected(true);
        },
        onError: (event) => {
          useAgentStore.getState().handleError(event);
          useWorldStore.getState().setConnected(false);
          // Scene Canvas를 오프라인/에러 상태로 전환 (U-031)
          const errorCode = event.code;
          if (errorCode === 'SAFETY_BLOCKED') {
            useWorldStore.getState().setSceneState({ status: 'blocked', message: event.message });
          } else if (errorCode === 'INSUFFICIENT_BALANCE') {
            useWorldStore
              .getState()
              .setSceneState({ status: 'low_signal', message: event.message });
          } else {
            useWorldStore.getState().setSceneState({ status: 'offline', message: event.message });
          }
        },
        // Complete → agentStore.completeStream
        // RU-003-T1: sceneState 전이는 worldStore.applyTurnOutput에서 SSOT로 처리
        // - 성공 시: onFinal → applyTurnOutput에서 ui.scene.image_url 기반으로 설정
        // - 에러 시: onError에서 이미 offline/blocked/low_signal으로 설정됨
        onComplete: () => {
          useAgentStore.getState().completeStream();
          // RU-003-T1: sceneState는 applyTurnOutput(성공) 또는 onError(실패)에서 이미 설정됨
          // 여기서 추가로 설정하면 applyTurnOutput의 설정을 덮어쓰게 되므로 제거
        },
      };

      // 스트림 시작 및 취소 함수 저장
      cancelFnRef.current = startTurnStream(turnInput, callbacks);
    },
    [t, theme],
  );

  // cancel 함수
  const cancel = useCallback((): void => {
    cancelFnRef.current?.();
    cancelFnRef.current = null;
  }, []);

  // 컴포넌트 언마운트 시 스트림 취소
  useEffect(() => {
    return () => {
      cancelFnRef.current?.();
    };
  }, []);

  return { runTurn, cancel };
}
</file>

<file path="frontend/src/types/turn_stream.ts">
/**
 * Unknown World - Turn Stream 이벤트 계약(Contract).
 *
 * NDJSON 스트리밍에서 사용되는 이벤트 타입, 인터페이스를 정의합니다.
 * 이 모듈은 백엔드와 프론트엔드 간의 스트림 이벤트 계약 SSOT입니다.
 *
 * 설계 원칙:
 *   - RU-002-Q4: 이벤트 계약을 transport 계층으로 분리
 *   - RU-002-S2: 이벤트별 Zod 검증 + Unknown/확장 이벤트 폴백
 *   - RULE-003: 구조화 출력(JSON Schema) 우선 + 이중 검증
 *   - RULE-008: 단계/배지 가시화
 *
 * 참조:
 *   - vibe/unit-plans/U-007[Mvp].md
 *   - vibe/refactors/RU-002-Q4.md
 *   - vibe/refactors/RU-002-S2.md
 *
 * @module types/turn_stream
 */

import { z } from 'zod';
import {
  AgentPhaseSchema,
  ValidationBadgeSchema,
  type TurnOutput,
  type AgentPhase,
  type ValidationBadge,
} from '../schemas/turn';

// =============================================================================
// 스트림 이벤트 타입 상수 (서버 계약과 일치)
// =============================================================================

/** 스트림 이벤트 타입 상수 */
export const StreamEventType = {
  STAGE: 'stage',
  BADGES: 'badges',
  NARRATIVE_DELTA: 'narrative_delta',
  FINAL: 'final',
  ERROR: 'error',
  REPAIR: 'repair',
} as const;

export type StreamEventTypeName = (typeof StreamEventType)[keyof typeof StreamEventType];

/**
 * 단계 상태 상수.
 * RU-002-S2/RU-002-Q2: v1(complete) 및 v2(ok/fail) 별칭 모두 지원.
 */
export const StageStatus = {
  START: 'start',
  COMPLETE: 'complete',
  /** 단계 실패 */
  FAIL: 'fail',
} as const;

export type StageStatusName = (typeof StageStatus)[keyof typeof StageStatus];

// =============================================================================
// RU-002-S2: 이벤트별 Zod 스키마 (경량 검증 + 폴백)
// =============================================================================

/**
 * stage.status 스키마.
 * v1(complete) 및 v2(ok/fail) 별칭 모두 허용.
 */
export const StageStatusSchema = z.enum(['start', 'complete', 'ok', 'fail']);

/**
 * StageEvent Zod 스키마.
 * 단계 진행 이벤트 검증용.
 */
export const StageEventSchema = z.object({
  type: z.literal(StreamEventType.STAGE),
  name: AgentPhaseSchema,
  status: StageStatusSchema,
});

/**
 * RepairEvent Zod 스키마.
 * 자동 복구 시도 이벤트 검증용.
 */
export const RepairEventSchema = z.object({
  type: z.literal(StreamEventType.REPAIR),
  attempt: z.number(),
  message: z.string().optional(),
});

/**
 * BadgesEvent Zod 스키마 (v1: 배열).
 * v1은 badges: string[] 형식.
 */
export const BadgesEventSchemaV1 = z.object({
  type: z.literal(StreamEventType.BADGES),
  badges: z.array(ValidationBadgeSchema),
});

/**
 * BadgesEvent Zod 스키마 (v2: 객체/맵).
 * 향후 v2는 badges: { [key]: status } 형식을 지원할 수 있음.
 * 현재는 v1만 사용하므로 이 스키마는 확장성을 위해 정의.
 */
export const BadgesEventSchemaV2 = z.object({
  type: z.literal(StreamEventType.BADGES),
  badges: z.record(z.string(), z.boolean()),
});

/**
 * BadgesEvent 통합 스키마.
 * v1(배열) 또는 v2(객체) 모두 허용.
 */
export const BadgesEventSchema = z.union([BadgesEventSchemaV1, BadgesEventSchemaV2]);

/**
 * NarrativeDeltaEvent Zod 스키마.
 * 타자 효과용 내러티브 델타 이벤트 검증용.
 */
export const NarrativeDeltaEventSchema = z.object({
  type: z.literal(StreamEventType.NARRATIVE_DELTA),
  text: z.string(),
});

/**
 * FinalEvent 원시 스키마.
 * v1(data) 및 v2(turn_output) 별칭 모두 허용.
 * TurnOutput 자체 검증은 turnStream.ts에서 safeParseTurnOutput으로 수행.
 */
export const FinalEventRawSchema = z.object({
  type: z.literal(StreamEventType.FINAL),
  data: z.unknown(),
});

/**
 * ErrorEvent Zod 스키마.
 * 에러 이벤트 검증용.
 */
export const ErrorEventSchema = z.object({
  type: z.literal(StreamEventType.ERROR),
  message: z.string(),
  code: z.string().optional(),
});

/**
 * 이벤트 타입 추출용 최소 스키마.
 * Unknown 이벤트 판별에 사용.
 */
export const BaseEventSchema = z.object({
  type: z.string(),
});

// =============================================================================
// 이벤트 파싱 유틸리티 (RU-002-S2)
// =============================================================================

/** 이벤트 검증 결과 타입 */
export type EventParseResult<T> =
  | { success: true; data: T }
  | { success: false; error: z.ZodError };

/**
 * StageEvent를 안전하게 파싱합니다.
 */
export function safeParseStageEvent(
  data: unknown,
): EventParseResult<z.infer<typeof StageEventSchema>> {
  const result = StageEventSchema.safeParse(data);
  return result.success
    ? { success: true, data: result.data }
    : { success: false, error: result.error };
}

/**
 * RepairEvent를 안전하게 파싱합니다.
 */
export function safeParseRepairEvent(
  data: unknown,
): EventParseResult<z.infer<typeof RepairEventSchema>> {
  const result = RepairEventSchema.safeParse(data);
  return result.success
    ? { success: true, data: result.data }
    : { success: false, error: result.error };
}

/**
 * BadgesEvent를 안전하게 파싱합니다.
 * v1(배열) 형태로 정규화하여 반환합니다.
 */
export function safeParseBadgesEvent(data: unknown): EventParseResult<BadgesEvent> {
  const result = BadgesEventSchema.safeParse(data);
  if (!result.success) {
    return { success: false, error: result.error };
  }

  // v2(객체) 형태인 경우 v1(배열)로 정규화
  const parsed = result.data;
  if (Array.isArray(parsed.badges)) {
    // v1 형태: 그대로 반환
    return {
      success: true,
      data: { type: StreamEventType.BADGES, badges: parsed.badges as ValidationBadge[] },
    };
  } else {
    // v2 형태: true인 키만 추출하여 배열로 변환
    const badgeArray = Object.entries(parsed.badges)
      .filter(([, value]) => value)
      .map(([key]) => key as ValidationBadge);
    return {
      success: true,
      data: { type: StreamEventType.BADGES, badges: badgeArray },
    };
  }
}

/**
 * NarrativeDeltaEvent를 안전하게 파싱합니다.
 */
export function safeParseNarrativeDeltaEvent(
  data: unknown,
): EventParseResult<z.infer<typeof NarrativeDeltaEventSchema>> {
  const result = NarrativeDeltaEventSchema.safeParse(data);
  return result.success
    ? { success: true, data: result.data }
    : { success: false, error: result.error };
}

/**
 * FinalEvent 원시 형태를 안전하게 파싱합니다.
 * TurnOutput 자체 검증은 별도로 수행해야 합니다.
 */
export function safeParseFinalEventRaw(
  data: unknown,
): EventParseResult<z.infer<typeof FinalEventRawSchema>> {
  const result = FinalEventRawSchema.safeParse(data);
  return result.success
    ? { success: true, data: result.data }
    : { success: false, error: result.error };
}

/**
 * ErrorEvent를 안전하게 파싱합니다.
 */
export function safeParseErrorEvent(
  data: unknown,
): EventParseResult<z.infer<typeof ErrorEventSchema>> {
  const result = ErrorEventSchema.safeParse(data);
  return result.success
    ? { success: true, data: result.data }
    : { success: false, error: result.error };
}

/**
 * stage.status 정규화 헬퍼.
 * 'ok'를 'complete'로, 'fail'은 그대로 유지.
 */
export function normalizeStageStatus(status: string): 'start' | 'complete' | 'fail' {
  if (status === 'ok') return 'complete';
  if (status === 'fail') return 'fail';
  if (status === 'start') return 'start';
  return 'complete';
}

// =============================================================================
// 스트림 이벤트 인터페이스
// =============================================================================

/**
 * 단계 진행 이벤트.
 * RU-002-S2: status에 'fail' 추가하여 단계 실패 표현 지원.
 */
export interface StageEvent {
  type: typeof StreamEventType.STAGE;
  name: AgentPhase;
  /** 'start' | 'complete' | 'ok' | 'fail'. ok는 complete로 정규화됨. */
  status: StageStatusName;
}

/** 자동 복구(Repair) 이벤트 */
export interface RepairEvent {
  type: typeof StreamEventType.REPAIR;
  attempt: number;
  message?: string;
}

/** 배지 이벤트 */
export interface BadgesEvent {
  type: typeof StreamEventType.BADGES;
  badges: ValidationBadge[];
}

/** 내러티브 델타 이벤트 (타자 효과용) */
export interface NarrativeDeltaEvent {
  type: typeof StreamEventType.NARRATIVE_DELTA;
  text: string;
}

/** 최종 TurnOutput 이벤트
 *
 * RU-002-Q2: v1은 `data`, v2는 `turn_output` 사용.
 * 하위호환을 위해 두 필드 모두 선언하되, 정규화된 인터페이스는 `data`를 사용.
 */
export interface FinalEvent {
  type: typeof StreamEventType.FINAL;
  /** v1 현행 계약: TurnOutput 페이로드 */
  data: TurnOutput;
}

/** FinalEvent 원시 수신 형태 */
export interface FinalEventRaw {
  type: typeof StreamEventType.FINAL;
  /** TurnOutput 페이로드 */
  data: TurnOutput;
}

/** 에러 이벤트 */
export interface ErrorEvent {
  type: typeof StreamEventType.ERROR;
  message: string;
  code?: string;
}

/** 스트림 이벤트 유니온 타입 */
export type StreamEvent =
  | StageEvent
  | RepairEvent
  | BadgesEvent
  | NarrativeDeltaEvent
  | FinalEvent
  | ErrorEvent;

// =============================================================================
// 스트림 콜백 인터페이스
// =============================================================================

/** 스트림 이벤트 콜백 */
export interface StreamCallbacks {
  /** 단계 진행 이벤트 */
  onStage?: (event: StageEvent) => void;
  /** 자동 복구 이벤트 */
  onRepair?: (event: RepairEvent) => void;
  /** 배지 이벤트 */
  onBadges?: (event: BadgesEvent) => void;
  /** 내러티브 델타 이벤트 */
  onNarrativeDelta?: (event: NarrativeDeltaEvent) => void;
  /** 최종 TurnOutput 이벤트 */
  onFinal?: (event: FinalEvent) => void;
  /** 에러 이벤트 */
  onError?: (event: ErrorEvent) => void;
  /** 스트림 완료 */
  onComplete?: () => void;
}
</file>

<file path="frontend/vite.config.ts">
/// <reference types="vitest" />
import { defineConfig } from 'vite';
import react from '@vitejs/plugin-react';

// https://vite.dev/config/
export default defineConfig({
  plugins: [react()],
  server: {
    port: 8001, // RULE-011: 프론트엔드는 8001~8010 사용
    strictPort: true, // 포트 충돌 시 fail-fast (대역 밖 이동 방지)
    // 충돌 시: pnpm -C frontend dev --port 8002 (8002~8010 중 선택)
  },
  build: {
    outDir: 'dist',
    sourcemap: true,
  },
  test: {
    globals: true,
    environment: 'jsdom',
    setupFiles: './src/setupTests.ts',
  },
});
</file>

<file path="backend/pyproject.toml">
# backend/pyproject.toml
# SSOT: vibe/tech-stack.md (버전 기준일: 2026-01-01)

[build-system]
requires = ["hatchling"]
build-backend = "hatchling.build"

[project]
name = "unknown-world-backend"
version = "0.1.0"
description = "Unknown World Backend - Gemini 기반 에이전트형 게임 엔진"
requires-python = ">=3.14"
dependencies = [
    "fastapi==0.128.0",
    "uvicorn[standard]==0.40.0",
    "pydantic==2.12.5",
    "google-genai==1.56.0",
    "google-cloud-aiplatform==1.132.0",
    "google-cloud-storage==3.7.0",
]

[tool.hatch.build.targets.wheel]
packages = ["src/unknown_world"]

[dependency-groups]
dev = [
    "ruff==0.14.10",
    "pyright==1.1.407",
    "pytest==9.0.2",
    "httpx==0.28.1",
    "jsonschema>=4.26.0",
]

[tool.ruff]
line-length = 100
target-version = "py314"
extend-exclude = [
    "__pycache__",
    ".ruff_cache",
    ".venv",
    "venv",
    "dist",
    "build",
]

[tool.ruff.lint]
select = [
    "E",      # pycodestyle errors
    "W",      # pycodestyle warnings
    "F",      # pyflakes
    "I",      # isort
    "UP",     # pyupgrade
    "B",      # flake8-bugbear
    "C4",     # flake8-comprehensions
    "SIM",    # flake8-simplify
]
ignore = [
    "E501",   # line too long (handled by formatter)
]

[tool.ruff.format]
quote-style = "double"
indent-style = "space"

[tool.pyright]
pythonVersion = "3.14"
typeCheckingMode = "strict"
include = ["src"]
</file>

<file path="frontend/src/schemas/turn.ts">
/**
 * Unknown World - TurnInput/TurnOutput Zod 스키마.
 *
 * 이 모듈은 백엔드 Pydantic 모델(U-005)과 1:1 대응하는 Zod 스키마를 정의합니다.
 * 클라이언트 측 검증 및 타입 안전성을 제공합니다.
 *
 * 설계 원칙:
 *   - RULE-003: 구조화 출력(JSON Schema) 우선 + 이중 검증 (서버 Pydantic + 클라 Zod)
 *   - RULE-004: 검증 실패 시 안전 폴백 제공 (UI 멈춤 방지)
 *   - RULE-005: 재화 인바리언트 (cost, balance_after 필수, 잔액 음수 금지)
 *   - RULE-006: ko/en 언어 정책 (Language enum으로 고정)
 *   - RULE-009: 좌표 규약 (0~1000, bbox [ymin,xmin,ymax,xmax])
 *
 * Q1 결정 사항:
 *   - schema_version 포함 (Option A): SaveGame/마이그레이션/검증에 유리
 *
 * @module schemas/turn
 */

import { z } from 'zod';

// =============================================================================
// 스키마 버전 (Q1 결정: Option A - 포함)
// =============================================================================

/**
 * 현재 스키마 버전.
 * SaveGame/마이그레이션/검증에 사용됩니다.
 */
export const SCHEMA_VERSION = '1.0.0' as const;

// =============================================================================
// 공통 Enum 타입
// =============================================================================

/**
 * 지원 언어 (RULE-006).
 * ko/en 혼합 출력 금지. TurnInput.language를 SSOT로 삼아
 * 모든 UI/내러티브/시스템 메시지는 동일 언어로 고정합니다.
 */
export const LanguageSchema = z.enum(['ko-KR', 'en-US']);
export type Language = z.infer<typeof LanguageSchema>;

/**
 * 테마 설정.
 */
export const ThemeSchema = z.enum(['dark', 'light']);
export type Theme = z.infer<typeof ThemeSchema>;

/**
 * 에이전트 실행 단계 (RULE-008).
 * 에이전트형 시스템임을 UI로 증명하기 위한 단계 표시.
 */
export const AgentPhaseSchema = z.enum([
  'parse',
  'validate',
  'plan',
  'resolve',
  'render',
  'verify',
  'commit',
]);
export type AgentPhase = z.infer<typeof AgentPhaseSchema>;

/**
 * 검증 배지 (RULE-008).
 * 턴 결과에 대한 검증 상태를 표시합니다.
 */
export const ValidationBadgeSchema = z.enum([
  'schema_ok',
  'schema_fail',
  'economy_ok',
  'economy_fail',
  'safety_ok',
  'safety_blocked',
  'consistency_ok',
  'consistency_fail',
]);
export type ValidationBadge = z.infer<typeof ValidationBadgeSchema>;

/**
 * 모델/품질 선택 라벨 (RULE-008).
 * 프롬프트 노출 없이 "왜 이 선택이었는지"를 사용자 친화 라벨로 표시.
 */
export const ModelLabelSchema = z.enum(['FAST', 'QUALITY', 'CHEAP', 'REF']);
export type ModelLabel = z.infer<typeof ModelLabelSchema>;

/**
 * 행동 위험도 수준.
 */
export const RiskLevelSchema = z.enum(['low', 'medium', 'high']);
export type RiskLevel = z.infer<typeof RiskLevelSchema>;

// =============================================================================
// 공통 하위 타입
// =============================================================================

/**
 * 정규화 좌표 (RULE-009).
 * 0~1000 범위의 정수입니다.
 */
export const CoordinateSchema = z.number().int().min(0).max(1000).describe('정규화 좌표 (0~1000)');
export type Coordinate = z.infer<typeof CoordinateSchema>;

/**
 * 2D 바운딩 박스 (RULE-009).
 * 좌표는 0~1000 정규화 좌표계이며, bbox는 [ymin, xmin, ymax, xmax] 순서입니다.
 * 이미지 이해 bbox 포맷과 호환됩니다.
 */
export const Box2DSchema = z
  .object({
    ymin: CoordinateSchema.describe('Y 최소값 (상단)'),
    xmin: CoordinateSchema.describe('X 최소값 (좌측)'),
    ymax: CoordinateSchema.describe('Y 최대값 (하단)'),
    xmax: CoordinateSchema.describe('X 최대값 (우측)'),
  })
  .strict();
export type Box2D = z.infer<typeof Box2DSchema>;

/**
 * 재화 수량.
 * signal과 memory_shard는 0 이상이어야 합니다 (RULE-005).
 */
export const CurrencyAmountSchema = z
  .object({
    signal: z.number().int().min(0).describe('시그널 (기본 재화, 0 이상)'),
    memory_shard: z.number().int().min(0).describe('기억 파편 (희귀 재화, 0 이상)'),
  })
  .strict();
export type CurrencyAmount = z.infer<typeof CurrencyAmountSchema>;

// =============================================================================
// TurnInput 관련 타입
// =============================================================================

/**
 * 클릭 입력 정보.
 * 화면 오브젝트 클릭 시 전달되는 정보입니다.
 */
export const ClickInputSchema = z
  .object({
    object_id: z.string().describe('클릭한 오브젝트 ID'),
    box_2d: Box2DSchema.nullable().default(null).describe('클릭 위치 바운딩 박스 (선택)'),
  })
  .strict();
export type ClickInput = z.infer<typeof ClickInputSchema>;

/**
 * 드롭 입력 정보 (U-012).
 * 인벤토리 아이템을 핫스팟에 드롭할 때 전달되는 정보입니다.
 * Q1 결정: Option B - target_box_2d 포함하여 서버가 정확한 위치 해석 가능.
 */
export const DropInputSchema = z
  .object({
    item_id: z.string().describe('드롭한 인벤토리 아이템 ID'),
    target_object_id: z.string().describe('드롭 대상 핫스팟 오브젝트 ID'),
    target_box_2d: Box2DSchema.describe('드롭 대상의 바운딩 박스 (0~1000 정규화)'),
  })
  .strict();
export type DropInput = z.infer<typeof DropInputSchema>;

/**
 * 클라이언트 정보.
 */
export const ClientInfoSchema = z
  .object({
    viewport_w: z.number().int().positive().describe('뷰포트 너비 (픽셀, 양수)'),
    viewport_h: z.number().int().positive().describe('뷰포트 높이 (픽셀, 양수)'),
    theme: ThemeSchema.default('dark').describe('현재 테마'),
  })
  .strict();
export type ClientInfo = z.infer<typeof ClientInfoSchema>;

/**
 * 재화 스냅샷 (클라이언트 → 서버).
 * 클라이언트가 보유한 현재 재화 상태입니다.
 */
export const EconomySnapshotSchema = z
  .object({
    signal: z.number().int().min(0).describe('현재 시그널 잔액 (0 이상)'),
    memory_shard: z.number().int().min(0).describe('현재 기억 파편 잔액 (0 이상)'),
  })
  .strict();
export type EconomySnapshot = z.infer<typeof EconomySnapshotSchema>;

/**
 * 턴 입력 (클라이언트 → 서버).
 * 사용자가 턴을 진행할 때 서버로 전송하는 입력 데이터입니다.
 *
 * U-012: drop 필드 추가 - 인벤토리 아이템을 핫스팟에 드롭할 때 사용.
 */
export const TurnInputSchema = z
  .object({
    language: LanguageSchema.describe('요청 언어 (응답도 동일 언어로 고정)'),
    text: z.string().default('').describe('사용자 자연어 입력'),
    action_id: z.string().nullable().default(null).describe('선택한 액션 카드 ID (선택)'),
    click: ClickInputSchema.nullable().default(null).describe('오브젝트 클릭 정보 (선택)'),
    drop: DropInputSchema.nullable().default(null).describe('아이템 드롭 정보 (선택, U-012)'),
    client: ClientInfoSchema.describe('클라이언트 환경 정보'),
    economy_snapshot: EconomySnapshotSchema.describe('현재 재화 상태'),
  })
  .strict();
export type TurnInput = z.infer<typeof TurnInputSchema>;

// =============================================================================
// TurnOutput 관련 타입 - UI
// =============================================================================

/**
 * 비용 추정치 (U-009: 최소/최대 범위).
 * 행동의 예상 비용 범위를 표시합니다.
 */
export const CostEstimateSchema = z
  .object({
    min: CurrencyAmountSchema.describe('최소 예상 비용'),
    max: CurrencyAmountSchema.describe('최대 예상 비용'),
  })
  .strict();
export type CostEstimate = z.infer<typeof CostEstimateSchema>;

/**
 * 액션 카드 (Action Deck).
 * 매 턴 AI가 추천하는 행동 카드입니다.
 *
 * U-009 확장:
 *   - cost_estimate: 최소/최대 비용 범위 (RULE-005)
 *   - enabled: 서버 측 실행 가능 여부 판단 (Q1: Option A)
 *   - disabled_reason: 비활성화 사유 (잔액 부족 등)
 *   - is_alternative: 저비용/텍스트-only 대안 카드 여부
 */
export const ActionCardSchema = z
  .object({
    id: z.string().describe('카드 고유 ID'),
    label: z.string().describe('카드 라벨 (표시용)'),
    description: z.string().nullable().default(null).describe('카드 설명 (선택)'),
    cost: CurrencyAmountSchema.describe('예상 비용 (기본)'),
    cost_estimate: CostEstimateSchema.nullable().default(null).describe('비용 추정 범위 (선택)'),
    risk: RiskLevelSchema.default('low').describe('위험도'),
    hint: z.string().nullable().default(null).describe('예상 결과 힌트 (선택)'),
    reward_hint: z.string().nullable().default(null).describe('보상 힌트 (선택)'),
    enabled: z.boolean().default(true).describe('실행 가능 여부 (서버 판단)'),
    disabled_reason: z.string().nullable().default(null).describe('비활성화 사유 (선택)'),
    is_alternative: z.boolean().default(false).describe('저비용 대안 카드 여부'),
  })
  .strict();
export type ActionCard = z.infer<typeof ActionCardSchema>;

/**
 * 장면 오브젝트 (클릭 가능한 핫스팟).
 * 좌표는 0~1000 정규화 좌표계를 사용합니다 (RULE-009).
 */
export const SceneObjectSchema = z
  .object({
    id: z.string().describe('오브젝트 고유 ID'),
    label: z.string().describe('오브젝트 라벨 (표시용)'),
    box_2d: Box2DSchema.describe('바운딩 박스'),
    interaction_hint: z.string().nullable().default(null).describe('상호작용 힌트 (선택)'),
  })
  .strict();
export type SceneObject = z.infer<typeof SceneObjectSchema>;

/**
 * 액션 덱 (Q1 결정: ui.action_deck.cards[] 구조).
 * 매 턴 AI가 제시하는 추천 행동 카드 덱입니다.
 */
export const ActionDeckSchema = z
  .object({
    cards: z.array(ActionCardSchema).max(10).default([]).describe('액션 카드 목록 (3~6장 권장)'),
  })
  .strict();
export type ActionDeck = z.infer<typeof ActionDeckSchema>;

/**
 * Scene 표시 정보 (RU-003-T1: Scene 이미지 SSOT).
 *
 * TurnOutput에서 Scene Canvas에 표시할 이미지 정보를 제공합니다.
 * image_url이 존재하면 SceneCanvas는 'scene' 상태로 전환됩니다.
 * image_url이 없으면 'default' 상태를 유지합니다.
 */
export const SceneOutputSchema = z
  .object({
    image_url: z
      .string()
      .nullable()
      .default(null)
      .describe('Scene 이미지 URL (존재 시 scene 상태로 전환)'),
    alt_text: z.string().nullable().default(null).describe('이미지 대체 텍스트 (접근성용, 선택)'),
  })
  .strict();
export type SceneOutput = z.infer<typeof SceneOutputSchema>;

/**
 * UI 출력 데이터.
 * AI가 생성한 UI 요소들입니다.
 * 채팅 버블이 아닌 게임 UI로 표현됩니다 (RULE-002).
 *
 * RU-003-T1: scene 필드 추가 - Scene Canvas의 이미지 표시 정보 SSOT.
 */
export const UIOutputSchema = z
  .object({
    action_deck: ActionDeckSchema.default({ cards: [] }).describe('액션 카드 덱'),
    objects: z.array(SceneObjectSchema).default([]).describe('클릭 가능한 장면 오브젝트 목록'),
    scene: SceneOutputSchema.default({ image_url: null, alt_text: null }).describe(
      'Scene 표시 정보 (RU-003-T1)',
    ),
  })
  .strict();
export type UIOutput = z.infer<typeof UIOutputSchema>;

// =============================================================================
// TurnOutput 관련 타입 - World
// =============================================================================

/**
 * 중요 설정 고정 후보.
 * 사용자가 Memory Shard를 소비해 고정할 수 있는 중요 설정입니다.
 */
export const MemoryPinSchema = z
  .object({
    id: z.string().describe('핀 고유 ID'),
    content: z.string().describe('고정할 내용'),
    cost: CurrencyAmountSchema.describe('고정에 필요한 비용'),
  })
  .strict();
export type MemoryPin = z.infer<typeof MemoryPinSchema>;

/**
 * 세계 규칙 (Rule Board).
 * 현재 세계에 적용 중인 물리 법칙이나 메타 규칙입니다.
 */
export const WorldRuleSchema = z
  .object({
    id: z.string().describe('규칙 고유 ID'),
    label: z.string().describe('규칙 이름'),
    description: z.string().nullable().default(null).describe('규칙 상세 설명 (선택)'),
  })
  .strict();
export type WorldRule = z.infer<typeof WorldRuleSchema>;

/**
 * 퀘스트/목표 (Quest Panel).
 * 플레이어가 달성해야 하는 현재 목표입니다.
 */
export const QuestSchema = z
  .object({
    id: z.string().describe('퀘스트 고유 ID'),
    label: z.string().describe('퀘스트 이름'),
    is_completed: z.boolean().default(false).describe('달성 여부'),
  })
  .strict();
export type Quest = z.infer<typeof QuestSchema>;

/**
 * 세계 상태 변화 (Q2 결정: Option A - delta 중심).
 * 이번 턴에서 변경된 세계 상태를 나타냅니다.
 */
export const WorldDeltaSchema = z
  .object({
    rules_changed: z.array(WorldRuleSchema).default([]).describe('변경된 규칙 목록'),
    inventory_added: z.array(z.string()).default([]).describe('추가된 인벤토리 아이템'),
    inventory_removed: z.array(z.string()).default([]).describe('제거된 인벤토리 아이템'),
    quests_updated: z.array(QuestSchema).default([]).describe('업데이트된 퀘스트/목표 목록'),
    relationships_changed: z.array(z.string()).default([]).describe('변경된 관계'),
    memory_pins: z.array(MemoryPinSchema).default([]).describe('중요 설정 고정 후보'),
  })
  .strict();
export type WorldDelta = z.infer<typeof WorldDeltaSchema>;

// =============================================================================
// TurnOutput 관련 타입 - Render
// =============================================================================

/**
 * 이미지 생성 작업.
 * 조건부 이미지 생성/편집 요청입니다.
 */
export const ImageJobSchema = z
  .object({
    should_generate: z.boolean().describe('이미지를 생성해야 하는지'),
    prompt: z.string().default('').describe('이미지 생성 프롬프트'),
    model_label: ModelLabelSchema.default('FAST').describe('모델 선택 라벨'),
    aspect_ratio: z.string().default('16:9').describe('가로세로 비율'),
    image_size: z.string().default('1024x1024').describe('이미지 크기'),
    reference_image_ids: z.array(z.string()).default([]).describe('참조 이미지 ID 목록 (선택)'),
  })
  .strict();
export type ImageJob = z.infer<typeof ImageJobSchema>;

/**
 * 렌더링 출력 데이터.
 * 이미지 생성/편집 관련 정보입니다.
 */
export const RenderOutputSchema = z
  .object({
    image_job: ImageJobSchema.nullable().default(null).describe('이미지 생성 작업 (선택)'),
  })
  .strict();
export type RenderOutput = z.infer<typeof RenderOutputSchema>;

// =============================================================================
// TurnOutput 관련 타입 - Economy
// =============================================================================

/**
 * 경제 출력 데이터 (RULE-005).
 * 이번 턴의 비용과 잔액 정보입니다.
 * 잔액 음수는 절대 불가 (서버 Hard gate).
 */
export const EconomyOutputSchema = z
  .object({
    cost: CurrencyAmountSchema.describe('이번 턴에 소비된 비용'),
    balance_after: CurrencyAmountSchema.describe('소비 후 잔액'),
  })
  .strict();
export type EconomyOutput = z.infer<typeof EconomyOutputSchema>;

// =============================================================================
// TurnOutput 관련 타입 - Safety
// =============================================================================

/**
 * 안전 출력 데이터.
 * 안전 정책 관련 정보입니다.
 * 차단 시 명시적 메시지와 함께 안전한 대체 결과를 제공합니다.
 */
export const SafetyOutputSchema = z
  .object({
    blocked: z.boolean().default(false).describe('안전 정책에 의해 차단되었는지'),
    message: z
      .string()
      .nullable()
      .default(null)
      .describe('차단 시 사용자에게 표시할 메시지 (선택)'),
  })
  .strict();
export type SafetyOutput = z.infer<typeof SafetyOutputSchema>;

// =============================================================================
// TurnOutput 관련 타입 - Agent Console
// =============================================================================

/**
 * 에이전트 콘솔 데이터 (RULE-008).
 * 에이전트형 시스템임을 UI로 증명하기 위한 정보입니다.
 */
export const AgentConsoleSchema = z
  .object({
    current_phase: AgentPhaseSchema.default('commit').describe('현재 실행 단계'),
    badges: z.array(ValidationBadgeSchema).default([]).describe('검증 배지 목록'),
    repair_count: z.number().int().min(0).default(0).describe('자동 복구 시도 횟수'),
  })
  .strict();
export type AgentConsole = z.infer<typeof AgentConsoleSchema>;

// =============================================================================
// TurnOutput (메인 응답 스키마)
// =============================================================================

/**
 * 턴 출력 (서버 → 클라이언트).
 * 서버가 턴 처리 후 클라이언트로 반환하는 구조화된 응답입니다.
 *
 * Hard Gate 필드 (RULE-003/004/005):
 *   - economy: cost와 balance_after 필수, 잔액 음수 금지
 *   - safety: blocked 시 안전한 대체 결과 제공
 *   - language: 요청 언어와 동일하게 고정 (혼합 출력 금지)
 */
export const TurnOutputSchema = z
  .object({
    // 필수 필드 (Hard Gate)
    language: LanguageSchema.describe('응답 언어 (요청과 동일)'),
    narrative: z.string().describe('내러티브 텍스트 (표시용)'),
    economy: EconomyOutputSchema.describe('경제 정보 (비용, 잔액)'),
    safety: SafetyOutputSchema.describe('안전 정책 정보'),

    // UI 관련 필드 (RU-003-T1: scene 필드 추가)
    ui: UIOutputSchema.default({
      action_deck: { cards: [] },
      objects: [],
      scene: { image_url: null, alt_text: null },
    }).describe('UI 요소'),

    // 세계 상태 필드
    world: WorldDeltaSchema.default({
      rules_changed: [],
      inventory_added: [],
      inventory_removed: [],
      quests_updated: [],
      relationships_changed: [],
      memory_pins: [],
    }).describe('세계 상태 변화 (delta)'),

    // 렌더링 필드
    render: RenderOutputSchema.default({ image_job: null }).describe('렌더링 정보'),

    // 에이전트 콘솔 필드
    agent_console: AgentConsoleSchema.default({
      current_phase: 'commit',
      badges: [],
      repair_count: 0,
    }).describe('에이전트 실행 정보'),
  })
  .strict();
export type TurnOutput = z.infer<typeof TurnOutputSchema>;

// =============================================================================
// 안전 폴백 (RULE-004)
// =============================================================================

/**
 * 검증 실패 시 제공되는 안전 폴백 TurnOutput.
 * UI가 멈추지 않도록 최소한의 정보를 제공합니다.
 *
 * @param language - 요청 언어
 * @param repairCount - 복구 시도 횟수
 * @param errorMessage - 오류 메시지 (선택)
 */
export function createFallbackTurnOutput(
  language: Language,
  repairCount: number = 0,
  errorMessage?: string,
): TurnOutput {
  const fallbackNarrative =
    language === 'ko-KR'
      ? '[시스템] 응답을 처리하는 중 문제가 발생했습니다. 다시 시도해 주세요.'
      : '[System] An error occurred while processing the response. Please try again.';

  const safetyMessage =
    language === 'ko-KR'
      ? '스키마 검증 실패로 인한 폴백 응답입니다.'
      : 'This is a fallback response due to schema validation failure.';

  return {
    language,
    narrative: errorMessage ?? fallbackNarrative,
    economy: {
      cost: { signal: 0, memory_shard: 0 },
      balance_after: { signal: 0, memory_shard: 0 },
    },
    safety: {
      blocked: false,
      message: safetyMessage,
    },
    ui: {
      action_deck: { cards: [] },
      objects: [],
      scene: { image_url: null, alt_text: null },
    },
    world: {
      rules_changed: [],
      inventory_added: [],
      inventory_removed: [],
      quests_updated: [],
      relationships_changed: [],
      memory_pins: [],
    },
    render: {
      image_job: null,
    },
    agent_console: {
      current_phase: 'commit',
      badges: ['schema_fail'],
      repair_count: repairCount,
    },
  };
}

// =============================================================================
// 검증 헬퍼 함수
// =============================================================================

/**
 * TurnOutput 검증 결과 타입.
 */
export type TurnOutputParseResult =
  | { success: true; data: TurnOutput }
  | { success: false; error: z.ZodError; fallback: TurnOutput };

/**
 * TurnOutput을 안전하게 파싱합니다.
 * 실패 시 폴백 TurnOutput을 반환합니다 (RULE-004).
 *
 * @param data - 파싱할 데이터
 * @param language - 폴백 시 사용할 언어 (기본: ko-KR)
 * @param repairCount - 현재 복구 시도 횟수
 */
export function safeParseTurnOutput(
  data: unknown,
  language: Language = 'ko-KR',
  repairCount: number = 0,
): TurnOutputParseResult {
  const result = TurnOutputSchema.safeParse(data);

  if (result.success) {
    return { success: true, data: result.data };
  }

  return {
    success: false,
    error: result.error,
    fallback: createFallbackTurnOutput(language, repairCount),
  };
}

/**
 * TurnInput을 검증합니다.
 * 입력 데이터의 유효성을 엄격하게 검사합니다.
 *
 * @param data - 검증할 데이터
 * @throws {z.ZodError} 검증 실패 시
 */
export function parseTurnInput(data: unknown): TurnInput {
  return TurnInputSchema.parse(data);
}

/**
 * TurnInput 안전 파싱 결과 타입.
 */
export type TurnInputSafeParseResult = ReturnType<typeof TurnInputSchema.safeParse>;

/**
 * TurnInput을 안전하게 파싱합니다.
 *
 * @param data - 파싱할 데이터
 */
export function safeParseTurnInput(data: unknown): TurnInputSafeParseResult {
  return TurnInputSchema.safeParse(data);
}
</file>

<file path="package.json">
{
  "name": "unknown-world",
  "version": "0.1.0",
  "private": true,
  "description": "Unknown World - Gemini 기반 에이전트형 게임 엔진",
  "packageManager": "pnpm@10.27.0",
  "engines": {
    "node": "24.12.0"
  },
  "scripts": {
    "kill": "pnpm kill:port",
    "kill:port": "npx --yes kill-port 8001 8002 8003 8004 8005 8006 8007 8008 8009 8010 8011 8012 8013 8014 8015 8016 8017 8018 8019 8020",
    "kill:front": "npx --yes kill-port 8001 8002 8003 8004 8005 8006 8007 8008 8009 8010",
    "kill:back": "npx --yes kill-port 8011 8012 8013 8014 8015 8016 8017 8018 8019 8020",
    "dev:back": "cd backend && uv run uvicorn unknown_world.main:app --reload --port 8011",
    "dev:front": "pnpm -C frontend dev"
  }
}
</file>

<file path="shared/schemas/turn/turn_output.schema.json">
{
  "$defs": {
    "ActionCard": {
      "additionalProperties": false,
      "description": "액션 카드 (Action Deck).\n\n매 턴 AI가 추천하는 행동 카드입니다.\n각 카드에 비용/위험/보상 힌트가 포함됩니다.\n\nAttributes:\n    id: 카드 고유 ID\n    label: 카드 라벨 (표시용)\n    description: 카드 설명 (선택)\n    cost: 예상 비용\n    risk: 위험도\n    hint: 예상 결과 힌트 (선택)",
      "properties": {
        "id": {
          "description": "카드 고유 ID",
          "title": "Id",
          "type": "string"
        },
        "label": {
          "description": "카드 라벨 (표시용)",
          "title": "Label",
          "type": "string"
        },
        "description": {
          "anyOf": [
            {
              "type": "string"
            },
            {
              "type": "null"
            }
          ],
          "default": null,
          "description": "카드 설명 (선택)",
          "title": "Description"
        },
        "cost": {
          "$ref": "#/$defs/CurrencyAmount",
          "description": "예상 비용"
        },
        "risk": {
          "$ref": "#/$defs/RiskLevel",
          "default": "low",
          "description": "위험도"
        },
        "hint": {
          "anyOf": [
            {
              "type": "string"
            },
            {
              "type": "null"
            }
          ],
          "default": null,
          "description": "예상 결과 힌트 (선택)",
          "title": "Hint"
        }
      },
      "required": [
        "id",
        "label",
        "cost"
      ],
      "title": "ActionCard",
      "type": "object"
    },
    "ActionDeck": {
      "additionalProperties": false,
      "description": "액션 덱 (Q1 결정: ui.action_deck.cards[] 구조).\n\n매 턴 AI가 제시하는 추천 행동 카드 덱입니다.\n\nAttributes:\n    cards: 액션 카드 목록 (3~6장 권장)",
      "properties": {
        "cards": {
          "default": [],
          "description": "액션 카드 목록 (3~6장 권장)",
          "items": {
            "$ref": "#/$defs/ActionCard"
          },
          "maxItems": 10,
          "minItems": 0,
          "title": "Cards",
          "type": "array"
        }
      },
      "title": "ActionDeck",
      "type": "object"
    },
    "AgentConsole": {
      "additionalProperties": false,
      "description": "에이전트 콘솔 데이터 (RULE-008).\n\n에이전트형 시스템임을 UI로 증명하기 위한 정보입니다.\n계획/실행/검증/복구의 흔적을 표시합니다.\n\nAttributes:\n    current_phase: 현재 실행 단계\n    badges: 검증 배지 목록\n    repair_count: 자동 복구 시도 횟수",
      "properties": {
        "current_phase": {
          "$ref": "#/$defs/AgentPhase",
          "default": "commit",
          "description": "현재 실행 단계"
        },
        "badges": {
          "default": [],
          "description": "검증 배지 목록",
          "items": {
            "$ref": "#/$defs/ValidationBadge"
          },
          "title": "Badges",
          "type": "array"
        },
        "repair_count": {
          "default": 0,
          "description": "자동 복구 시도 횟수",
          "minimum": 0,
          "title": "Repair Count",
          "type": "integer"
        }
      },
      "title": "AgentConsole",
      "type": "object"
    },
    "AgentPhase": {
      "description": "에이전트 실행 단계 (RULE-008).\n\n에이전트형 시스템임을 UI로 증명하기 위한 단계 표시.",
      "enum": [
        "parse",
        "validate",
        "plan",
        "resolve",
        "render",
        "verify",
        "commit"
      ],
      "title": "AgentPhase",
      "type": "string"
    },
    "Box2D": {
      "additionalProperties": false,
      "description": "2D 바운딩 박스 (RULE-009).\n\n좌표는 0~1000 정규화 좌표계이며, bbox는 [ymin, xmin, ymax, xmax] 순서입니다.\n이미지 이해 bbox 포맷과 호환됩니다.\n\nAttributes:\n    ymin: Y 최소값 (상단)\n    xmin: X 최소값 (좌측)\n    ymax: Y 최대값 (하단)\n    xmax: X 최대값 (우측)",
      "properties": {
        "ymin": {
          "description": "정규화 좌표 (0~1000)",
          "maximum": 1000,
          "minimum": 0,
          "title": "Ymin",
          "type": "integer"
        },
        "xmin": {
          "description": "정규화 좌표 (0~1000)",
          "maximum": 1000,
          "minimum": 0,
          "title": "Xmin",
          "type": "integer"
        },
        "ymax": {
          "description": "정규화 좌표 (0~1000)",
          "maximum": 1000,
          "minimum": 0,
          "title": "Ymax",
          "type": "integer"
        },
        "xmax": {
          "description": "정규화 좌표 (0~1000)",
          "maximum": 1000,
          "minimum": 0,
          "title": "Xmax",
          "type": "integer"
        }
      },
      "required": [
        "ymin",
        "xmin",
        "ymax",
        "xmax"
      ],
      "title": "Box2D",
      "type": "object"
    },
    "CurrencyAmount": {
      "additionalProperties": false,
      "description": "재화 수량.\n\nAttributes:\n    signal: 기본 재화 (텍스트 턴/이미지 생성/고급 기능에 소비)\n    memory_shard: 희귀 재화 (중요 설정 고정, 고해상도 이미지 등에 소비)",
      "properties": {
        "signal": {
          "description": "시그널 (기본 재화, 0 이상)",
          "minimum": 0,
          "title": "Signal",
          "type": "integer"
        },
        "memory_shard": {
          "description": "기억 파편 (희귀 재화, 0 이상)",
          "minimum": 0,
          "title": "Memory Shard",
          "type": "integer"
        }
      },
      "required": [
        "signal",
        "memory_shard"
      ],
      "title": "CurrencyAmount",
      "type": "object"
    },
    "EconomyOutput": {
      "additionalProperties": false,
      "description": "경제 출력 데이터 (RULE-005).\n\n이번 턴의 비용과 잔액 정보입니다.\n잔액 음수는 절대 불가 (서버 Hard gate).\n\nAttributes:\n    cost: 이번 턴에 소비된 비용\n    balance_after: 소비 후 잔액\n\nImportant:\n    - cost와 balance_after는 항상 포함되어야 합니다.\n    - balance_after의 signal과 memory_shard는 0 이상이어야 합니다.",
      "properties": {
        "cost": {
          "$ref": "#/$defs/CurrencyAmount",
          "description": "이번 턴에 소비된 비용"
        },
        "balance_after": {
          "$ref": "#/$defs/CurrencyAmount",
          "description": "소비 후 잔액"
        }
      },
      "required": [
        "cost",
        "balance_after"
      ],
      "title": "EconomyOutput",
      "type": "object"
    },
    "ImageJob": {
      "additionalProperties": false,
      "description": "이미지 생성 작업.\n\n조건부 이미지 생성/편집 요청입니다.\n이미지 생성이 느릴 경우 텍스트 우선 출력 + Lazy Loading을 사용합니다.\n\nAttributes:\n    should_generate: 이미지를 생성해야 하는지\n    prompt: 이미지 생성 프롬프트\n    model_label: 모델 선택 라벨 (FAST/QUALITY/CHEAP/REF)\n    aspect_ratio: 가로세로 비율 (예: \"16:9\", \"1:1\")\n    image_size: 이미지 크기 (예: \"1024x1024\")\n    reference_image_ids: 참조 이미지 ID 목록 (선택)",
      "properties": {
        "should_generate": {
          "description": "이미지를 생성해야 하는지",
          "title": "Should Generate",
          "type": "boolean"
        },
        "prompt": {
          "default": "",
          "description": "이미지 생성 프롬프트",
          "title": "Prompt",
          "type": "string"
        },
        "model_label": {
          "$ref": "#/$defs/ModelLabel",
          "default": "FAST",
          "description": "모델 선택 라벨"
        },
        "aspect_ratio": {
          "default": "16:9",
          "description": "가로세로 비율",
          "title": "Aspect Ratio",
          "type": "string"
        },
        "image_size": {
          "default": "1024x1024",
          "description": "이미지 크기",
          "title": "Image Size",
          "type": "string"
        },
        "reference_image_ids": {
          "default": [],
          "description": "참조 이미지 ID 목록 (선택)",
          "items": {
            "type": "string"
          },
          "title": "Reference Image Ids",
          "type": "array"
        }
      },
      "required": [
        "should_generate"
      ],
      "title": "ImageJob",
      "type": "object"
    },
    "Language": {
      "description": "지원 언어 (RULE-006).\n\nko/en 혼합 출력 금지. TurnInput.language를 SSOT로 삼아\n모든 UI/내러티브/시스템 메시지는 동일 언어로 고정합니다.",
      "enum": [
        "ko-KR",
        "en-US"
      ],
      "title": "Language",
      "type": "string"
    },
    "MemoryPin": {
      "additionalProperties": false,
      "description": "중요 설정 고정 후보.\n\n사용자가 Memory Shard를 소비해 고정할 수 있는 중요 설정입니다.\n\nAttributes:\n    id: 핀 고유 ID\n    content: 고정할 내용\n    cost: 고정에 필요한 비용",
      "properties": {
        "id": {
          "description": "핀 고유 ID",
          "title": "Id",
          "type": "string"
        },
        "content": {
          "description": "고정할 내용",
          "title": "Content",
          "type": "string"
        },
        "cost": {
          "$ref": "#/$defs/CurrencyAmount",
          "description": "고정에 필요한 비용"
        }
      },
      "required": [
        "id",
        "content",
        "cost"
      ],
      "title": "MemoryPin",
      "type": "object"
    },
    "ModelLabel": {
      "description": "모델/품질 선택 라벨 (RULE-008).\n\n프롬프트 노출 없이 \"왜 이 선택이었는지\"를 사용자 친화 라벨로 표시.",
      "enum": [
        "FAST",
        "QUALITY",
        "CHEAP",
        "REF"
      ],
      "title": "ModelLabel",
      "type": "string"
    },
    "Quest": {
      "additionalProperties": false,
      "description": "퀘스트/목표 (Quest Panel).\n\n플레이어가 달성해야 하는 현재 목표입니다.\n\nAttributes:\n    id: 퀘스트 고유 ID\n    label: 퀘스트 이름\n    is_completed: 달성 여부",
      "properties": {
        "id": {
          "description": "퀘스트 고유 ID",
          "title": "Id",
          "type": "string"
        },
        "label": {
          "description": "퀘스트 이름",
          "title": "Label",
          "type": "string"
        },
        "is_completed": {
          "default": false,
          "description": "달성 여부",
          "title": "Is Completed",
          "type": "boolean"
        }
      },
      "required": [
        "id",
        "label"
      ],
      "title": "Quest",
      "type": "object"
    },
    "RenderOutput": {
      "additionalProperties": false,
      "description": "렌더링 출력 데이터.\n\n이미지 생성/편집 관련 정보입니다.\n\nAttributes:\n    image_job: 이미지 생성 작업 (선택)",
      "properties": {
        "image_job": {
          "anyOf": [
            {
              "$ref": "#/$defs/ImageJob"
            },
            {
              "type": "null"
            }
          ],
          "default": null,
          "description": "이미지 생성 작업 (선택)"
        }
      },
      "title": "RenderOutput",
      "type": "object"
    },
    "RiskLevel": {
      "description": "행동 위험도 수준.",
      "enum": [
        "low",
        "medium",
        "high"
      ],
      "title": "RiskLevel",
      "type": "string"
    },
    "SafetyOutput": {
      "additionalProperties": false,
      "description": "안전 출력 데이터.\n\n안전 정책 관련 정보입니다.\n차단 시 명시적 메시지와 함께 안전한 대체 결과를 제공합니다.\n\nAttributes:\n    blocked: 안전 정책에 의해 차단되었는지\n    message: 차단 시 사용자에게 표시할 메시지 (선택)",
      "properties": {
        "blocked": {
          "default": false,
          "description": "안전 정책에 의해 차단되었는지",
          "title": "Blocked",
          "type": "boolean"
        },
        "message": {
          "anyOf": [
            {
              "type": "string"
            },
            {
              "type": "null"
            }
          ],
          "default": null,
          "description": "차단 시 사용자에게 표시할 메시지 (선택)",
          "title": "Message"
        }
      },
      "title": "SafetyOutput",
      "type": "object"
    },
    "SceneObject": {
      "additionalProperties": false,
      "description": "장면 오브젝트 (클릭 가능한 핫스팟).\n\n화면에서 클릭 가능한 오브젝트입니다.\n좌표는 0~1000 정규화 좌표계를 사용합니다 (RULE-009).\n\nAttributes:\n    id: 오브젝트 고유 ID\n    label: 오브젝트 라벨 (표시용)\n    box_2d: 바운딩 박스 [ymin, xmin, ymax, xmax]\n    interaction_hint: 상호작용 힌트 (선택)",
      "properties": {
        "id": {
          "description": "오브젝트 고유 ID",
          "title": "Id",
          "type": "string"
        },
        "label": {
          "description": "오브젝트 라벨 (표시용)",
          "title": "Label",
          "type": "string"
        },
        "box_2d": {
          "$ref": "#/$defs/Box2D",
          "description": "바운딩 박스"
        },
        "interaction_hint": {
          "anyOf": [
            {
              "type": "string"
            },
            {
              "type": "null"
            }
          ],
          "default": null,
          "description": "상호작용 힌트 (선택)",
          "title": "Interaction Hint"
        }
      },
      "required": [
        "id",
        "label",
        "box_2d"
      ],
      "title": "SceneObject",
      "type": "object"
    },
    "SceneOutput": {
      "additionalProperties": false,
      "description": "Scene 표시 정보 (RU-003-T1: Scene 이미지 SSOT).\n\nTurnOutput에서 Scene Canvas에 표시할 이미지 정보를 제공합니다.\nimage_url이 존재하면 SceneCanvas는 'scene' 상태로 전환됩니다.\nimage_url이 없으면 'default' 상태를 유지합니다.\n\nAttributes:\n    image_url: Scene 이미지 URL (존재 시 scene 상태로 전환)\n    alt_text: 이미지 대체 텍스트 (접근성용, 선택)",
      "properties": {
        "image_url": {
          "anyOf": [
            {
              "type": "string"
            },
            {
              "type": "null"
            }
          ],
          "default": null,
          "description": "Scene 이미지 URL (존재 시 scene 상태로 전환)",
          "title": "Image Url"
        },
        "alt_text": {
          "anyOf": [
            {
              "type": "string"
            },
            {
              "type": "null"
            }
          ],
          "default": null,
          "description": "이미지 대체 텍스트 (접근성용, 선택)",
          "title": "Alt Text"
        }
      },
      "title": "SceneOutput",
      "type": "object"
    },
    "UIOutput": {
      "additionalProperties": false,
      "description": "UI 출력 데이터.\n\nAI가 생성한 UI 요소들입니다.\n채팅 버블이 아닌 게임 UI로 표현됩니다 (RULE-002).\n\nRU-003-T1: scene 필드 추가 - Scene Canvas의 이미지 표시 정보 SSOT.\n\nAttributes:\n    action_deck: 액션 카드 덱 (Q1 결정: Option A 채택)\n    objects: 클릭 가능한 장면 오브젝트 목록\n    scene: Scene 표시 정보 (RU-003-T1)",
      "properties": {
        "action_deck": {
          "$ref": "#/$defs/ActionDeck",
          "description": "액션 카드 덱"
        },
        "objects": {
          "default": [],
          "description": "클릭 가능한 장면 오브젝트 목록",
          "items": {
            "$ref": "#/$defs/SceneObject"
          },
          "title": "Objects",
          "type": "array"
        },
        "scene": {
          "$ref": "#/$defs/SceneOutput",
          "default": {
            "image_url": null,
            "alt_text": null
          },
          "description": "Scene 표시 정보 (RU-003-T1)"
        }
      },
      "title": "UIOutput",
      "type": "object"
    },
    "ValidationBadge": {
      "description": "검증 배지 (RULE-008).\n\n턴 결과에 대한 검증 상태를 표시합니다.",
      "enum": [
        "schema_ok",
        "schema_fail",
        "economy_ok",
        "economy_fail",
        "safety_ok",
        "safety_blocked",
        "consistency_ok",
        "consistency_fail"
      ],
      "title": "ValidationBadge",
      "type": "string"
    },
    "WorldDelta": {
      "additionalProperties": false,
      "description": "세계 상태 변화 (Q2 결정: Option A - delta 중심).\n\n이번 턴에서 변경된 세계 상태를 나타냅니다.\nsnapshot은 SaveGame에만 저장하고, 매 턴은 delta만 전송합니다.\n\nAttributes:\n    rules_changed: 변경되거나 추가된 규칙 목록\n    inventory_added: 추가된 인벤토리 아이템\n    inventory_removed: 제거된 인벤토리 아이템\n    quests_updated: 업데이트된 퀘스트(목표) 목록\n    relationships_changed: 변경된 관계\n    memory_pins: 중요 설정 고정 후보",
      "properties": {
        "rules_changed": {
          "default": [],
          "description": "변경된 규칙 목록",
          "items": {
            "$ref": "#/$defs/WorldRule"
          },
          "title": "Rules Changed",
          "type": "array"
        },
        "inventory_added": {
          "default": [],
          "description": "추가된 인벤토리 아이템",
          "items": {
            "type": "string"
          },
          "title": "Inventory Added",
          "type": "array"
        },
        "inventory_removed": {
          "default": [],
          "description": "제거된 인벤토리 아이템",
          "items": {
            "type": "string"
          },
          "title": "Inventory Removed",
          "type": "array"
        },
        "quests_updated": {
          "default": [],
          "description": "업데이트된 퀘스트/목표 목록",
          "items": {
            "$ref": "#/$defs/Quest"
          },
          "title": "Quests Updated",
          "type": "array"
        },
        "relationships_changed": {
          "default": [],
          "description": "변경된 관계",
          "items": {
            "type": "string"
          },
          "title": "Relationships Changed",
          "type": "array"
        },
        "memory_pins": {
          "default": [],
          "description": "중요 설정 고정 후보",
          "items": {
            "$ref": "#/$defs/MemoryPin"
          },
          "title": "Memory Pins",
          "type": "array"
        }
      },
      "title": "WorldDelta",
      "type": "object"
    },
    "WorldRule": {
      "additionalProperties": false,
      "description": "세계 규칙 (Rule Board).\n\n현재 세계에 적용 중인 물리 법칙이나 메타 규칙입니다.\n\nAttributes:\n    id: 규칙 고유 ID\n    label: 규칙 이름\n    description: 규칙 상세 설명 (선택)",
      "properties": {
        "id": {
          "description": "규칙 고유 ID",
          "title": "Id",
          "type": "string"
        },
        "label": {
          "description": "규칙 이름",
          "title": "Label",
          "type": "string"
        },
        "description": {
          "anyOf": [
            {
              "type": "string"
            },
            {
              "type": "null"
            }
          ],
          "default": null,
          "description": "규칙 상세 설명 (선택)",
          "title": "Description"
        }
      },
      "required": [
        "id",
        "label"
      ],
      "title": "WorldRule",
      "type": "object"
    }
  },
  "additionalProperties": false,
  "description": "턴 출력 (서버 → 클라이언트).\n\n서버가 턴 처리 후 클라이언트로 반환하는 구조화된 응답입니다.\nGemini Structured Outputs(JSON Schema)로 강제됩니다.\n\nHard Gate 필드 (RULE-003/004/005):\n    - economy: cost와 balance_after 필수, 잔액 음수 금지\n    - safety: blocked 시 안전한 대체 결과 제공\n    - language: 요청 언어와 동일하게 고정 (혼합 출력 금지)\n\nAttributes:\n    language: 응답 언어 (요청과 동일)\n    narrative: 내러티브 텍스트 (표시용)\n    ui: UI 요소 (액션 덱, 오브젝트)\n    world: 세계 상태 변화 (delta 중심)\n    render: 렌더링 정보 (이미지 생성 작업)\n    economy: 경제 정보 (비용, 잔액)\n    safety: 안전 정책 정보\n    agent_console: 에이전트 실행 정보 (단계, 배지, 복구 횟수)\n\nExample:\n    >>> output = TurnOutput(\n    ...     language=Language.KO,\n    ...     narrative=\"문이 삐걱거리며 열립니다...\",\n    ...     economy=EconomyOutput(\n    ...         cost=CurrencyAmount(signal=5, memory_shard=0),\n    ...         balance_after=CurrencyAmount(signal=95, memory_shard=5),\n    ...     ),\n    ...     safety=SafetyOutput(blocked=False),\n    ... )\n    >>> schema = TurnOutput.model_json_schema()\n\nSchema Generation:\n    >>> # Gemini Structured Outputs용 JSON Schema 생성\n    >>> json_schema = TurnOutput.model_json_schema()\n    >>> # response_json_schema 파라미터에 전달\n    >>> config = {\n    ...     \"response_mime_type\": \"application/json\",\n    ...     \"response_json_schema\": json_schema,\n    ... }",
  "properties": {
    "language": {
      "$ref": "#/$defs/Language",
      "description": "응답 언어 (요청과 동일)"
    },
    "narrative": {
      "description": "내러티브 텍스트 (표시용)",
      "title": "Narrative",
      "type": "string"
    },
    "economy": {
      "$ref": "#/$defs/EconomyOutput",
      "description": "경제 정보 (비용, 잔액)"
    },
    "safety": {
      "$ref": "#/$defs/SafetyOutput",
      "description": "안전 정책 정보"
    },
    "ui": {
      "$ref": "#/$defs/UIOutput",
      "description": "UI 요소"
    },
    "world": {
      "$ref": "#/$defs/WorldDelta",
      "description": "세계 상태 변화 (delta)"
    },
    "render": {
      "$ref": "#/$defs/RenderOutput",
      "description": "렌더링 정보"
    },
    "agent_console": {
      "$ref": "#/$defs/AgentConsole",
      "description": "에이전트 실행 정보"
    }
  },
  "required": [
    "language",
    "narrative",
    "economy",
    "safety"
  ],
  "title": "TurnOutput",
  "type": "object"
}
</file>

<file path="frontend/public/ui/manifest.json">
{
  "$schema": "./manifest.schema.json",
  "version": "1.4.0",
  "generatedAt": "2026-01-14T14:55:00Z",
  "totalBytes": 570867,
  "budgetBytes": 1572864,
  "assets": [
    {
      "id": "signal-24",
      "path": "icons/signal-24.png",
      "type": "icon",
      "size": 24,
      "fallback": "⚡",
      "usedIn": ["EconomyHUD"],
      "bytes": 1573,
      "notes": "U-038: v2 재생성, nanobanana mcp(픽셀아트), rembg(birefnet-general), ImageMagick 최적화"
    },
    {
      "id": "signal-16",
      "path": "icons/signal-16.png",
      "type": "icon",
      "size": 16,
      "fallback": "⚡",
      "usedIn": ["ActionDeck"],
      "bytes": 1012,
      "notes": "U-038: v2 재생성, nanobanana mcp(픽셀아트), rembg(birefnet-general), ImageMagick 최적화"
    },
    {
      "id": "shard-24",
      "path": "icons/shard-24.png",
      "type": "icon",
      "size": 24,
      "fallback": "💎",
      "usedIn": ["EconomyHUD"],
      "bytes": 1362,
      "notes": "U-038: v2 재생성, nanobanana mcp(픽셀아트), rembg(birefnet-general), ImageMagick 최적화"
    },
    {
      "id": "shard-16",
      "path": "icons/shard-16.png",
      "type": "icon",
      "size": 16,
      "fallback": "💎",
      "usedIn": ["ActionDeck"],
      "bytes": 1147,
      "notes": "U-038: shard-24에서 리사이즈, 16px 최적화"
    },
    {
      "id": "badge-ok-24",
      "path": "icons/badge-ok-24.png",
      "type": "icon",
      "size": 24,
      "fallback": "✓",
      "usedIn": ["AgentConsole"],
      "bytes": 1461,
      "notes": "U-038: v2 재생성, nanobanana mcp(픽셀아트), rembg(birefnet-general), ImageMagick 최적화"
    },
    {
      "id": "badge-ok-16",
      "path": "icons/badge-ok-16.png",
      "type": "icon",
      "size": 16,
      "fallback": "✓",
      "usedIn": [],
      "bytes": 1096,
      "notes": "U-038: v2 재생성, nanobanana mcp(픽셀아트), rembg(birefnet-general), ImageMagick 최적화"
    },
    {
      "id": "badge-fail-24",
      "path": "icons/badge-fail-24.png",
      "type": "icon",
      "size": 24,
      "fallback": "✗",
      "usedIn": ["AgentConsole"],
      "bytes": 2006,
      "notes": "U-038: v2 재생성, nanobanana mcp(픽셀아트), rembg(birefnet-general), ImageMagick 최적화"
    },
    {
      "id": "risk-medium-24",
      "path": "icons/risk-medium-24.png",
      "type": "icon",
      "size": 24,
      "fallback": "⚠",
      "usedIn": [],
      "bytes": 1594,
      "notes": "U-038: 24px 페어 보강, nanobanana mcp 생성"
    },
    {
      "id": "risk-medium-16",
      "path": "icons/risk-medium-16.png",
      "type": "icon",
      "size": 16,
      "fallback": "⚠",
      "usedIn": ["ActionDeck"],
      "bytes": 1256,
      "notes": "U-038: v2 재생성, nanobanana mcp(픽셀아트), rembg(birefnet-general), ImageMagick 최적화"
    },
    {
      "id": "risk-low-24",
      "path": "icons/risk-low-24.png",
      "type": "icon",
      "size": 24,
      "fallback": "✓",
      "usedIn": [],
      "bytes": 1838,
      "notes": "U-038: v2 재생성, nanobanana mcp(픽셀아트), rembg(birefnet-general), ImageMagick 최적화"
    },
    {
      "id": "risk-low-16",
      "path": "icons/risk-low-16.png",
      "type": "icon",
      "size": 16,
      "fallback": "✓",
      "usedIn": ["ActionDeck"],
      "bytes": 1331,
      "notes": "U-038: v2 재생성, nanobanana mcp(픽셀아트), rembg(birefnet-general), ImageMagick 최적화"
    },
    {
      "id": "risk-high-24",
      "path": "icons/risk-high-24.png",
      "type": "icon",
      "size": 24,
      "fallback": "⚠",
      "usedIn": [],
      "bytes": 1737,
      "notes": "U-038: v2 재생성, nanobanana mcp(픽셀아트), rembg(birefnet-general), ImageMagick 최적화"
    },
    {
      "id": "risk-high-16",
      "path": "icons/risk-high-16.png",
      "type": "icon",
      "size": 16,
      "fallback": "⚠",
      "usedIn": ["ActionDeck"],
      "bytes": 1227,
      "notes": "U-038: v2 재생성, nanobanana mcp(픽셀아트), rembg(birefnet-general), ImageMagick 최적화"
    },
    {
      "id": "status-online-16",
      "path": "icons/status-online-16.png",
      "type": "icon",
      "size": 16,
      "fallback": "●",
      "usedIn": [],
      "bytes": 1375,
      "notes": "U-038: v2 재생성, nanobanana mcp(픽셀아트), rembg(birefnet-general), ImageMagick 최적화"
    },
    {
      "id": "scene-placeholder-default",
      "path": "placeholders/scene-placeholder-default.png",
      "type": "placeholder",
      "fallback": "[SCENE]",
      "usedIn": ["SceneCanvas"],
      "bytes": 261407,
      "notes": "nanobanana mcp 생성, 레트로 터미널 스타일"
    },
    {
      "id": "scene-loading",
      "path": "placeholders/scene-loading.webp",
      "type": "placeholder",
      "fallback": "⏳",
      "usedIn": ["SceneCanvas"],
      "bytes": 47850,
      "notes": "U-031: 로딩 상태 placeholder, nanobanana mcp 생성, ImageMagick(magick) 최적화"
    },
    {
      "id": "scene-offline",
      "path": "placeholders/scene-offline.webp",
      "type": "placeholder",
      "fallback": "🔌",
      "usedIn": ["SceneCanvas"],
      "bytes": 44658,
      "notes": "U-031: 오프라인 상태 placeholder, nanobanana mcp 생성, ImageMagick(magick) 최적화"
    },
    {
      "id": "scene-blocked",
      "path": "placeholders/scene-blocked.webp",
      "type": "placeholder",
      "fallback": "🚫",
      "usedIn": ["SceneCanvas"],
      "bytes": 17318,
      "notes": "U-031: 차단 상태 placeholder, nanobanana mcp 생성, ImageMagick(magick) 최적화"
    },
    {
      "id": "scene-low-signal",
      "path": "placeholders/scene-low-signal.webp",
      "type": "placeholder",
      "fallback": "📉",
      "usedIn": ["SceneCanvas"],
      "bytes": 68454,
      "notes": "U-031: 저신호 상태 placeholder, nanobanana mcp 생성, ImageMagick(magick) 최적화"
    },
    {
      "id": "panel-corner-br",
      "path": "chrome/panel-corner-br.png",
      "type": "chrome",
      "fallback": "",
      "usedIn": ["PanelHeader"],
      "bytes": 1899,
      "notes": "U-032: 패널 코너 장식, nanobanana mcp 생성, rembg 배경 제거, ImageMagick 최적화(48x48), CSS transform으로 4방향 적용"
    },
    {
      "id": "card-frame",
      "path": "chrome/card-frame.png",
      "type": "chrome",
      "fallback": "",
      "usedIn": ["ActionCard"],
      "bytes": 9101,
      "notes": "U-032: 액션 카드 프레임, nanobanana mcp 생성, rembg 배경 제거, ImageMagick 최적화(160x80)"
    },
    {
      "id": "scanner-frame",
      "path": "chrome/scanner-frame.png",
      "type": "chrome",
      "fallback": "",
      "usedIn": ["Scanner"],
      "bytes": 100165,
      "notes": "U-032: 스캐너 슬롯 프레임, nanobanana mcp 생성, rembg(birefnet-general) 배경 제거, ImageMagick 최적화(346x200) 완료"
    }
  ]
}
</file>

<file path="frontend/package.json">
{
  "name": "unknown-world-frontend",
  "private": true,
  "version": "0.0.0",
  "type": "module",
  "packageManager": "pnpm@10.27.0",
  "scripts": {
    "dev": "vite",
    "build": "tsc -b && vite build",
    "preview": "vite preview",
    "format": "prettier . --write",
    "format:check": "prettier . --check",
    "lint": "eslint .",
    "lint:fix": "eslint . --fix",
    "typecheck": "tsc --noEmit",
    "test": "vitest run",
    "test:watch": "vitest",
    "test:coverage": "vitest run --coverage"
  },
  "dependencies": {
    "@dnd-kit/core": "6.3.1",
    "@dnd-kit/sortable": "10.0.0",
    "@dnd-kit/utilities": "^3.2.2",
    "i18next": "25.7.3",
    "react": "19.2.3",
    "react-dom": "19.2.3",
    "react-i18next": "16.5.1",
    "zod": "4.3.4",
    "zustand": "5.0.9"
  },
  "devDependencies": {
    "@eslint/js": "9.39.2",
    "@testing-library/jest-dom": "^6.9.1",
    "@testing-library/react": "^16.3.1",
    "@types/node": "25.0.3",
    "@types/react": "19.2.7",
    "@types/react-dom": "19.2.3",
    "@vitejs/plugin-react": "5.1.2",
    "@vitest/coverage-v8": "^4.0.16",
    "eslint": "9.39.2",
    "eslint-config-prettier": "10.1.8",
    "eslint-plugin-react": "7.37.5",
    "eslint-plugin-react-hooks": "7.0.1",
    "eslint-plugin-unused-imports": "4.3.0",
    "globals": "16.5.0",
    "jsdom": "^27.4.0",
    "prettier": "3.7.4",
    "typescript": "5.9.3",
    "typescript-eslint": "8.51.0",
    "vite": "7.3.0",
    "vitest": "^4.0.16"
  },
  "pnpm": {
    "onlyBuiltDependencies": [
      "esbuild"
    ]
  }
}
</file>

<file path="frontend/src/api/turnStream.ts">
/**
 * Unknown World - HTTP Streaming 클라이언트 + NDJSON 파서.
 *
 * fetch 기반으로 POST 요청을 보내고 응답 스트림을 NDJSON으로 파싱합니다.
 * 중간 청크 파싱 실패가 전체 UI를 멈추지 않도록 설계되었습니다.
 *
 * 설계 원칙:
 *   - RULE-003: 구조화 출력(JSON Schema) 우선 + 이중 검증
 *   - RULE-004: 검증 실패 시 안전 폴백 제공
 *   - RULE-008: 단계/배지 가시화 (프롬프트/내부 추론 노출 금지)
 *   - RULE-011: 백엔드 포트 8011 사용
 *
 * @module api/turnStream
 */

import type { TurnInput, TurnOutput, Language } from '../schemas/turn';
import { safeParseTurnOutput } from '../schemas/turn';
import type { StreamCallbacks } from '../types/turn_stream';
import {
  StreamEventType,
  BaseEventSchema,
  safeParseStageEvent,
  safeParseRepairEvent,
  safeParseBadgesEvent,
  safeParseNarrativeDeltaEvent,
  safeParseFinalEventRaw,
  safeParseErrorEvent,
  normalizeStageStatus,
} from '../types/turn_stream';

// Re-export 스트림 이벤트 타입들 (하위 호환성 유지)
export type {
  StreamEventTypeName,
  StageStatusName,
  StageEvent,
  RepairEvent,
  BadgesEvent,
  NarrativeDeltaEvent,
  FinalEvent,
  ErrorEvent,
  StreamEvent,
  StreamCallbacks,
} from '../types/turn_stream';
export { StreamEventType, StageStatus } from '../types/turn_stream';

// =============================================================================
// NDJSON 파서 (Q1 결정: Option A - 직접 구현)
// =============================================================================

/**
 * NDJSON 라인 파서.
 * 부분 청크를 버퍼링하고 완전한 라인을 파싱합니다.
 */
export class NDJSONParser {
  private buffer = '';

  /**
   * 청크를 파싱하고 완전한 JSON 객체들을 반환합니다.
   *
   * @param chunk - 수신된 텍스트 청크
   * @returns 파싱된 JSON 객체 배열
   */
  parse(chunk: string): unknown[] {
    this.buffer += chunk;
    const results: unknown[] = [];

    // 줄바꿈으로 분할
    const lines = this.buffer.split('\n');

    // 마지막 라인은 불완전할 수 있으므로 버퍼에 유지
    this.buffer = lines.pop() ?? '';

    for (const line of lines) {
      const trimmed = line.trim();
      if (trimmed === '') continue;

      try {
        const parsed = JSON.parse(trimmed);
        results.push(parsed);
      } catch {
        // 파싱 실패 시 해당 라인 무시 (RULE-004: 전체 중단 방지)
        console.warn('[NDJSON] Failed to parse line:', trimmed);
      }
    }

    return results;
  }

  /**
   * 버퍼를 초기화합니다.
   */
  reset(): void {
    this.buffer = '';
  }

  /**
   * 남은 버퍼를 플러시하고 마지막 객체를 파싱합니다.
   */
  flush(): unknown | null {
    const trimmed = this.buffer.trim();
    this.buffer = '';

    if (trimmed === '') return null;

    try {
      return JSON.parse(trimmed);
    } catch {
      console.warn('[NDJSON] Failed to parse remaining buffer:', trimmed);
      return null;
    }
  }
}

// =============================================================================
// 스트림 이벤트 핸들러
// =============================================================================

/**
 * 파싱된 이벤트를 타입별로 분배합니다.
 *
 * RU-002-S2: 캐스팅 대신 Zod safeParse를 적용하여 검증 강화.
 * Unknown/확장 이벤트는 UI를 멈추지 않고 경고만 출력.
 *
 * @param event - 파싱된 이벤트 객체
 * @param callbacks - 콜백 함수들
 * @param language - 폴백 언어
 */
function dispatchEvent(event: unknown, callbacks: StreamCallbacks, language: Language): void {
  if (!event || typeof event !== 'object') return;

  // 기본 이벤트 타입 추출
  const baseResult = BaseEventSchema.safeParse(event);
  if (!baseResult.success) {
    console.warn('[TurnStream] Invalid event format (no type field):', event);
    return;
  }

  const type = baseResult.data.type;

  switch (type) {
    case StreamEventType.STAGE: {
      // RU-002-S2: stage 이벤트 검증
      const stageResult = safeParseStageEvent(event);
      if (stageResult.success) {
        // status 정규화: 'ok' → 'complete'
        const normalizedStatus = normalizeStageStatus(stageResult.data.status);
        callbacks.onStage?.({
          type: StreamEventType.STAGE,
          name: stageResult.data.name,
          status: normalizedStatus,
        });
      } else {
        console.warn('[TurnStream] Invalid stage event:', stageResult.error.message);
      }
      break;
    }

    case StreamEventType.REPAIR: {
      // RU-002-S2: repair 이벤트 검증
      const repairResult = safeParseRepairEvent(event);
      if (repairResult.success) {
        callbacks.onRepair?.(repairResult.data);
      } else {
        console.warn('[TurnStream] Invalid repair event:', repairResult.error.message);
      }
      break;
    }

    case StreamEventType.BADGES: {
      // RU-002-S2: badges 이벤트 검증 (v1/v2 정규화 포함)
      const badgesResult = safeParseBadgesEvent(event);
      if (badgesResult.success) {
        callbacks.onBadges?.(badgesResult.data);
      } else {
        console.warn('[TurnStream] Invalid badges event:', badgesResult.error.message);
      }
      break;
    }

    case StreamEventType.NARRATIVE_DELTA: {
      // RU-002-S2: narrative_delta 이벤트 검증
      const narrativeResult = safeParseNarrativeDeltaEvent(event);
      if (narrativeResult.success) {
        callbacks.onNarrativeDelta?.(narrativeResult.data);
      } else {
        console.warn('[TurnStream] Invalid narrative_delta event:', narrativeResult.error.message);
      }
      break;
    }

    case StreamEventType.FINAL: {
      // RU-002-S2: final 이벤트 구조 검증
      const finalRawResult = safeParseFinalEventRaw(event);
      if (!finalRawResult.success) {
        console.warn('[TurnStream] Invalid final event structure:', finalRawResult.error.message);
        // 구조가 잘못되어도 폴백 제공
        callbacks.onFinal?.({
          type: StreamEventType.FINAL,
          data: createFallbackTurnOutput(language),
        });
        break;
      }

      // RULE-003/004: Zod strict parse + 폴백
      const turnOutputPayload = finalRawResult.data.data;
      const parseResult = safeParseTurnOutput(turnOutputPayload, language);

      if (parseResult.success) {
        callbacks.onFinal?.({
          type: StreamEventType.FINAL,
          data: parseResult.data,
        });
      } else {
        console.warn('[TurnStream] TurnOutput validation failed:', parseResult.error);
        callbacks.onFinal?.({
          type: StreamEventType.FINAL,
          data: parseResult.fallback,
        });
      }
      break;
    }

    case StreamEventType.ERROR: {
      // RU-002-S2: error 이벤트 검증
      const errorResult = safeParseErrorEvent(event);
      if (errorResult.success) {
        callbacks.onError?.(errorResult.data);
      } else {
        console.warn('[TurnStream] Invalid error event:', errorResult.error.message);
        // 에러 이벤트가 깨진 경우에도 기본 에러 전달
        callbacks.onError?.({
          type: StreamEventType.ERROR,
          message: 'Unknown error (malformed error event)',
          code: 'INVALID_ERROR_EVENT',
        });
      }
      break;
    }

    default:
      // RU-002-S2: Unknown/확장 이벤트는 UI를 멈추지 않고 경고만 출력
      // 향후 protocol, repair, telemetry 등 확장 이벤트 도입 시 여기서 처리 가능
      console.warn('[TurnStream] Unknown/ignored event type:', type, event);
  }
}

/**
 * 클라이언트 측 폴백 TurnOutput 생성 (언어만 지정).
 * dispatchEvent 내부에서 사용하는 간단한 폴백.
 */
function createFallbackTurnOutput(language: Language): TurnOutput {
  const fallbackNarrative =
    language === 'ko-KR'
      ? '[시스템] 응답 데이터를 처리하는 중 문제가 발생했습니다.'
      : '[System] An error occurred while processing response data.';

  return {
    language,
    narrative: fallbackNarrative,
    economy: {
      cost: { signal: 0, memory_shard: 0 },
      balance_after: { signal: 0, memory_shard: 0 },
    },
    safety: {
      blocked: false,
      message: null,
    },
    ui: {
      action_deck: { cards: [] },
      objects: [],
      scene: { image_url: null, alt_text: null },
    },
    world: {
      rules_changed: [],
      inventory_added: [],
      inventory_removed: [],
      quests_updated: [],
      relationships_changed: [],
      memory_pins: [],
    },
    render: {
      image_job: null,
    },
    agent_console: {
      current_phase: 'commit',
      badges: ['schema_fail'],
      repair_count: 1,
    },
  };
}

// =============================================================================
// API 설정
// =============================================================================

/** 백엔드 API URL (RULE-011: 포트 8011) */
const API_BASE_URL = 'http://localhost:8011';

/** 턴 스트림 API 엔드포인트 */
const TURN_ENDPOINT = `${API_BASE_URL}/api/turn`;

// =============================================================================
// 스트림 클라이언트
// =============================================================================

/** 스트림 요청 옵션 */
export interface TurnStreamOptions {
  /** 요청 타임아웃 (ms) */
  timeout?: number;
  /** AbortSignal */
  signal?: AbortSignal;
}

/**
 * 턴 스트림 요청을 실행합니다.
 *
 * @param input - 턴 입력 데이터
 * @param callbacks - 이벤트 콜백
 * @param options - 요청 옵션
 * @returns 취소 함수
 */
export async function executeTurnStream(
  input: TurnInput,
  callbacks: StreamCallbacks,
  options?: TurnStreamOptions,
): Promise<void> {
  const parser = new NDJSONParser();
  const controller = new AbortController();
  const signal = options?.signal ?? controller.signal;

  // RU-002-S1: AbortError 발생 시 onComplete 호출 여부 추적
  let aborted = false;

  try {
    const response = await fetch(TURN_ENDPOINT, {
      method: 'POST',
      headers: {
        'Content-Type': 'application/json',
        Accept: 'application/x-ndjson',
      },
      body: JSON.stringify(input),
      signal,
    });

    if (!response.ok) {
      throw new Error(`HTTP ${response.status}: ${response.statusText}`);
    }

    if (!response.body) {
      throw new Error('Response body is null');
    }

    const reader = response.body.getReader();
    const decoder = new TextDecoder('utf-8');

    // 스트림 읽기 루프
    while (true) {
      const { done, value } = await reader.read();

      if (done) break;

      const chunk = decoder.decode(value, { stream: true });
      const events = parser.parse(chunk);

      for (const event of events) {
        dispatchEvent(event, callbacks, input.language);
      }
    }

    // 남은 버퍼 플러시
    const remaining = parser.flush();
    if (remaining) {
      dispatchEvent(remaining, callbacks, input.language);
    }
  } catch (error) {
    if (error instanceof DOMException && error.name === 'AbortError') {
      // RU-003-S1: Abort(취소) 정책
      // =========================================================================
      // 현재 정책(Option B): Abort 시 onComplete를 호출하지 않음
      // - 이유: 취소는 "사용자 의도"이므로 실패와 구분해야 함
      // - 주의: 이 정책에서는 Cancel 버튼 구현 시 호출자가 직접 UI 복구 필요
      //
      // 향후 Option A로 전환 가능:
      // - Abort 시에도 onComplete 호출 + 별도 플래그로 "취소 종료" 구분
      // - 장점: UI가 멈추지 않음 (복구 일관성)
      // - 단점: 취소와 실패를 구분하려면 이벤트 모델 확장 필요
      //
      // 결정 근거: RU-003-S1 Step 3
      // =========================================================================
      aborted = true;
      return;
    }

    const errorMessage = error instanceof Error ? error.message : 'Unknown error occurred';

    // RU-002-S1: 네트워크 에러 시에도 onError 호출
    callbacks.onError?.({
      type: StreamEventType.ERROR,
      message: errorMessage,
      code: 'STREAM_ERROR',
    });

    // RU-002-S1: 네트워크 에러 시 클라이언트 측 폴백 final 생성
    // 서버에서 final이 오지 못한 경우 UI가 멈추지 않도록 함
    const fallback = createClientFallbackTurnOutput(input.language, input.economy_snapshot);
    callbacks.onFinal?.({
      type: StreamEventType.FINAL,
      data: fallback,
    });
  } finally {
    // RU-002-S1: 스트림 종료 인바리언트 - 성공/실패 모두에서 onComplete 호출 보장
    if (!aborted) {
      callbacks.onComplete?.();
    }
  }
}

/**
 * 클라이언트 측 폴백 TurnOutput 생성 (RU-002-S1).
 * 서버에서 final이 오지 못한 경우 (네트워크 에러 등) 사용합니다.
 * Economy는 요청 직전 스냅샷을 그대로 유지합니다.
 */
function createClientFallbackTurnOutput(
  language: Language,
  economySnapshot: { signal: number; memory_shard: number },
): TurnOutput {
  const fallbackNarrative =
    language === 'ko-KR'
      ? '[시스템] 서버 연결에 실패했습니다. 다시 시도해 주세요.'
      : '[System] Failed to connect to server. Please try again.';

  return {
    language,
    narrative: fallbackNarrative,
    economy: {
      cost: { signal: 0, memory_shard: 0 },
      // RU-002-S1: 입력 스냅샷 그대로 유지 (비용 0, 잔액 변화 없음)
      balance_after: {
        signal: economySnapshot.signal,
        memory_shard: economySnapshot.memory_shard,
      },
    },
    safety: {
      blocked: false,
      message: null,
    },
    ui: {
      action_deck: { cards: [] },
      objects: [],
      scene: { image_url: null, alt_text: null },
    },
    world: {
      rules_changed: [],
      inventory_added: [],
      inventory_removed: [],
      quests_updated: [],
      relationships_changed: [],
      memory_pins: [],
    },
    render: {
      image_job: null,
    },
    agent_console: {
      current_phase: 'commit',
      badges: ['schema_fail'],
      repair_count: 1,
    },
  };
}

/**
 * 턴 스트림을 시작하고 취소 함수를 반환합니다.
 *
 * @param input - 턴 입력 데이터
 * @param callbacks - 이벤트 콜백
 * @returns 취소 함수
 */
export function startTurnStream(input: TurnInput, callbacks: StreamCallbacks): () => void {
  const controller = new AbortController();

  executeTurnStream(input, callbacks, { signal: controller.signal });

  return () => controller.abort();
}
</file>

<file path="frontend/src/components/SceneCanvas.tsx">
/**
 * Unknown World - Scene Canvas 컴포넌트
 *
 * RULE-002 준수: 채팅 버블이 아닌 게임 UI
 * RULE-009 준수: 좌표 규약 (0~1000 정규화, bbox=[ymin,xmin,ymax,xmax])
 *
 * U-010[Mvp]: 핫스팟 오버레이 + 클릭 처리
 * - TurnOutput의 objects[]/hotspots[]를 기반으로 오버레이 렌더
 * - hover 시 하이라이트/툴팁 표시
 * - click 시 object_id + box_2d를 TurnInput에 포함해 전송
 *
 * U-012[Mvp]: DnD 드롭 타겟 확장
 * - 핫스팟을 droppable 영역으로 만들어 인벤토리 아이템 드롭 처리
 * - 드래그 오버 시 하이라이트 강화
 * - 드롭 성공/실패 즉시 시각화
 *
 * @module components/SceneCanvas
 */

import { useState, useRef, useCallback, useEffect, useMemo } from 'react';
import { useTranslation } from 'react-i18next';
import { useDroppable } from '@dnd-kit/core';
import type { SceneCanvasStatus, PlaceholderInfo } from '../types/scene';
import type { SceneObject, Box2D } from '../schemas/turn';
import { box2dToPixel, type CanvasSize } from '../utils/box2d';
import {
  DND_TYPE,
  type HotspotDropData,
  isHotspotInteractionAllowed,
  compareHotspotPriority,
} from '../dnd/types';
import { useWorldStore } from '../stores/worldStore';
import { useAgentStore } from '../stores/agentStore';

// =============================================================================
// 상수 정의
// =============================================================================

/**
 * 상태별 placeholder 정보 (U-031: Placeholder Pack)
 * labelKey는 i18n 번역 키로 사용됩니다.
 */
export const SCENE_PLACEHOLDERS: Record<Exclude<SceneCanvasStatus, 'scene'>, PlaceholderInfo> = {
  default: {
    imagePath: '/ui/placeholders/scene-placeholder-default.png',
    fallbackEmoji: '📡',
    labelKey: 'scene.status.default',
  },
  loading: {
    imagePath: '/ui/placeholders/scene-loading.webp',
    fallbackEmoji: '⏳',
    labelKey: 'scene.status.loading',
  },
  offline: {
    imagePath: '/ui/placeholders/scene-offline.webp',
    fallbackEmoji: '🔌',
    labelKey: 'scene.status.offline',
  },
  blocked: {
    imagePath: '/ui/placeholders/scene-blocked.webp',
    fallbackEmoji: '🚫',
    labelKey: 'scene.status.blocked',
  },
  low_signal: {
    imagePath: '/ui/placeholders/scene-low-signal.webp',
    fallbackEmoji: '📉',
    labelKey: 'scene.status.low_signal',
  },
};

// =============================================================================
// 타입 정의
// =============================================================================

/**
 * 핫스팟 클릭 이벤트 데이터 (Q1 결정: Option B - object_id + box_2d)
 */
export interface HotspotClickData {
  /** 클릭한 오브젝트 ID */
  object_id: string;
  /** 클릭한 오브젝트의 바운딩 박스 (0~1000 정규화) */
  box_2d: Box2D;
}

interface SceneCanvasProps {
  /** 핫스팟 클릭 콜백 */
  onHotspotClick?: (data: HotspotClickData) => void;
  /** 스트리밍 중 여부 (비활성화용, 생략 시 agentStore.isStreaming 사용) */
  disabled?: boolean;
}

// =============================================================================
// 내부 컴포넌트: 핫스팟 오버레이
// =============================================================================

interface HotspotOverlayProps {
  object: SceneObject;
  canvasSize: CanvasSize;
  onClick: (data: HotspotClickData) => void;
  disabled: boolean;
  /** RU-003-S2: 데모 상태 여부 (시각적 힌트 필요) */
  isDemoState?: boolean;
  /** RU-003-S2 Step 2: 우선순위 기반 z-index 스타일 */
  style?: React.CSSProperties;
}

/**
 * 개별 핫스팟 오버레이 컴포넌트 (U-010 + U-012)
 *
 * - 클릭 시 object_id + box_2d 전송 (U-010)
 * - 드롭 타겟으로 동작 - dnd-kit useDroppable 사용 (U-012)
 */
function HotspotOverlay({
  object,
  canvasSize,
  onClick,
  disabled,
  isDemoState = false,
  style,
}: HotspotOverlayProps) {
  const [isHovered, setIsHovered] = useState(false);
  const { t } = useTranslation();

  // U-012: useDroppable 훅으로 드롭 타겟 설정 (RU-003-Q1: 상수/타입 기반)
  const dropData: HotspotDropData = {
    type: DND_TYPE.HOTSPOT,
    object_id: object.id,
    box_2d: object.box_2d,
    label: object.label,
  };
  const { isOver, setNodeRef } = useDroppable({
    id: `hotspot-${object.id}`,
    data: dropData,
    disabled,
  });

  // box_2d(0~1000) → px 변환
  const pixelBox = box2dToPixel(object.box_2d, canvasSize);

  const handleClick = useCallback(() => {
    if (disabled) return;
    onClick({
      object_id: object.id,
      box_2d: object.box_2d,
    });
  }, [disabled, onClick, object.id, object.box_2d]);

  const handleKeyDown = useCallback(
    (e: React.KeyboardEvent) => {
      if (disabled) return;
      if (e.key === 'Enter' || e.key === ' ') {
        e.preventDefault();
        handleClick();
      }
    },
    [disabled, handleClick],
  );

  // 드래그 오버 상태 또는 마우스 호버 상태
  const isHighlighted = isHovered || isOver;

  // RU-003-S2: 데모 상태 클래스 추가
  const demoClass = isDemoState ? 'demo-target' : '';

  return (
    <div
      ref={setNodeRef}
      className={`hotspot-overlay ${isHighlighted ? 'hovered' : ''} ${disabled ? 'disabled' : ''} ${isOver ? 'drop-target-active' : ''} ${demoClass}`}
      style={{
        position: 'absolute',
        top: `${pixelBox.top}px`,
        left: `${pixelBox.left}px`,
        width: `${pixelBox.width}px`,
        height: `${pixelBox.height}px`,
        ...style,
      }}
      onClick={handleClick}
      onMouseEnter={() => setIsHovered(true)}
      onMouseLeave={() => setIsHovered(false)}
      onKeyDown={handleKeyDown}
      role="button"
      tabIndex={disabled ? -1 : 0}
      aria-label={object.label}
      aria-disabled={disabled}
      data-drop-target={!disabled}
      data-demo-state={isDemoState}
    >
      {/* 호버 또는 드래그 오버 시 툴팁 표시 */}
      {isHighlighted && !disabled && (
        <div className="hotspot-tooltip">
          <span className="hotspot-tooltip-label">{object.label}</span>
          {/* RU-003-S2: 데모 상태 표시 */}
          {isDemoState && (
            <span className="hotspot-tooltip-demo">{t('scene.hotspot.demo_hint')}</span>
          )}
          {/* U-012: 드래그 오버 시 드롭 힌트 표시 */}
          {isOver && (
            <span className="hotspot-tooltip-drop-hint">{t('scene.hotspot.drop_hint')}</span>
          )}
          {!isOver && !isDemoState && object.interaction_hint && (
            <span className="hotspot-tooltip-hint">
              {t('scene.hotspot.hint_prefix')}: {object.interaction_hint}
            </span>
          )}
        </div>
      )}
    </div>
  );
}

// =============================================================================
// 메인 컴포넌트
// =============================================================================

/**
 * Scene Canvas 컴포넌트
 *
 * U-010[Mvp]: 핫스팟 오버레이 + 클릭 처리
 * U-031[Mvp]: Placeholder Pack
 *
 * - 상태에 따라 placeholder 이미지와 라벨을 표시합니다.
 * - 'scene' 상태에서는 실제 이미지를 렌더링하며, 로드 실패 시 폴백을 제공합니다.
 * - objects 배열이 있으면 핫스팟 오버레이를 렌더링합니다.
 */
export function SceneCanvas({ onHotspotClick, disabled: propsDisabled }: SceneCanvasProps) {
  const { t } = useTranslation();

  // Store 상태 (RU-003: 컴포넌트 내에서 직접 구독)
  const state = useWorldStore((state) => state.sceneState);
  const objects = useWorldStore((state) => state.sceneObjects);
  const isStreaming = useAgentStore((state) => state.isStreaming);

  const disabled = propsDisabled ?? isStreaming;

  const { status, imageUrl, message } = state;
  const [imageError, setImageError] = useState(false);
  const [canvasSize, setCanvasSize] = useState<CanvasSize>({ width: 0, height: 0 });
  const canvasRef = useRef<HTMLDivElement>(null);

  // RU-003-S2 Step 3: ResizeObserver에 디바운스 적용
  // 드래그 중 핫스팟 영역이 과도하게 흔들리는 것을 방지
  useEffect(() => {
    const element = canvasRef.current;
    if (!element) return;

    let resizeTimeout: ReturnType<typeof setTimeout> | null = null;
    const RESIZE_DEBOUNCE_MS = 100; // 디바운스 간격

    const resizeObserver = new ResizeObserver((entries) => {
      // 디바운스: 마지막 리사이즈 이벤트 후 일정 시간 후에만 업데이트
      if (resizeTimeout) {
        clearTimeout(resizeTimeout);
      }
      resizeTimeout = setTimeout(() => {
        for (const entry of entries) {
          const { width, height } = entry.contentRect;
          // 의미 있는 크기 변화만 적용 (5px 이상 차이)
          setCanvasSize((prev) => {
            if (Math.abs(prev.width - width) > 5 || Math.abs(prev.height - height) > 5) {
              return { width, height };
            }
            return prev;
          });
        }
      }, RESIZE_DEBOUNCE_MS);
    });

    resizeObserver.observe(element);

    // 초기 크기 설정
    const rect = element.getBoundingClientRect();
    setCanvasSize({ width: rect.width, height: rect.height });

    return () => {
      if (resizeTimeout) {
        clearTimeout(resizeTimeout);
      }
      resizeObserver.disconnect();
    };
  }, []);

  // 핫스팟 클릭 핸들러
  const handleHotspotClick = useCallback(
    (data: HotspotClickData) => {
      if (onHotspotClick) {
        onHotspotClick(data);
      }
    },
    [onHotspotClick],
  );

  // 정상 장면 표시 중이거나 이미지 에러가 발생한 경우
  const isSceneActive = status === 'scene' && imageUrl && !imageError;

  // placeholder 정보 결정 (scene 상태에서 에러 시 default로 폴백)
  const effectiveStatus = status === 'scene' && imageError ? 'default' : status;
  const isPlaceholderVisible = effectiveStatus !== 'scene';

  const placeholder = isPlaceholderVisible
    ? SCENE_PLACEHOLDERS[effectiveStatus as Exclude<SceneCanvasStatus, 'scene'>]
    : null;

  // RU-003-S2 Step 1: 핫스팟 렌더링 조건을 SSOT로 고정
  // - isHotspotInteractionAllowed()로 허용 상태 검사 (scene, default)
  // - objects 존재 + 캔버스 크기 확보
  const isInteractionAllowed = isHotspotInteractionAllowed(status);
  const shouldRenderHotspots = isInteractionAllowed && objects.length > 0 && canvasSize.width > 0;

  // RU-003-S2: 데모 상태 여부 (시각적 힌트 필요)
  const isDemoState = status === 'default' && !isSceneActive;

  // RU-003-S2 Step 2: 핫스팟을 면적 기준으로 정렬 (작은 것이 뒤에 = 높은 z-index)
  const sortedObjects = useMemo(() => {
    if (objects.length <= 1) return objects;
    return [...objects].sort((a, b) => compareHotspotPriority(a.box_2d, b.box_2d));
  }, [objects]);

  return (
    <div
      ref={canvasRef}
      className={`scene-canvas ${isSceneActive ? 'scene-active' : `scene-status-${effectiveStatus}`} ${shouldRenderHotspots ? 'has-hotspots' : ''}`}
      style={placeholder ? { backgroundImage: `url('${placeholder.imagePath}')` } : {}}
    >
      {isSceneActive && (
        <img
          src={imageUrl}
          alt={t('scene.status.alt')}
          className="scene-image"
          onError={() => setImageError(true)}
        />
      )}

      {isPlaceholderVisible && placeholder && (
        <div className="scene-placeholder">
          {/* 텍스트 폴백 (이미지 로드 실패 시에도 표시) */}
          <p className="text-glow scene-status-label">
            <span className="scene-status-emoji" aria-hidden="true">
              {placeholder.fallbackEmoji}
            </span>{' '}
            {t(placeholder.labelKey)}
          </p>
          {(message || (status === 'scene' && imageError)) && (
            <p className="scene-status-message">
              {message || (imageError ? t('scene.status.image_error') : '')}
            </p>
          )}
        </div>
      )}

      {/* 핫스팟 오버레이 레이어 (RU-003-S2: 면적순 정렬) */}
      {shouldRenderHotspots && (
        <div className="hotspot-layer" aria-label={t('scene.hotspot.layer_label')}>
          {sortedObjects.map((obj, index) => (
            <HotspotOverlay
              key={obj.id}
              object={obj}
              canvasSize={canvasSize}
              onClick={handleHotspotClick}
              disabled={disabled}
              isDemoState={isDemoState}
              // RU-003-S2 Step 2: 인덱스 기반 z-index로 작은 것이 위에 표시
              style={{ zIndex: index + 1 }}
            />
          ))}
        </div>
      )}
    </div>
  );
}
</file>

<file path="frontend/src/locales/ko-KR/translation.json">
{
  "demo": {
    "items": {
      "keycard-alpha": {
        "name": "키카드 A"
      },
      "medkit": {
        "name": "응급 키트"
      },
      "flashlight": {
        "name": "손전등"
      },
      "data-chip": {
        "name": "데이터칩"
      }
    },
    "scene": {
      "terminal": {
        "label": "터미널",
        "hint": "활성화된 터미널이다"
      },
      "door": {
        "label": "문",
        "hint": "잠겨있는 것 같다"
      }
    },
    "quest": {
      "terminal": {
        "label": "터미널에 접속하기"
      },
      "escape": {
        "label": "시설 탈출구 찾기"
      },
      "collect": {
        "label": "데이터칩 수집"
      }
    },
    "rule": {
      "gravity": {
        "label": "중력 법칙",
        "description": "물체는 아래로 떨어진다"
      },
      "time": {
        "label": "시간 흐름",
        "description": "시간은 정상 속도로 흐른다"
      }
    }
  },
  "quest": {
    "empty": "[ 목표 없음 ]",
    "completed": "완료",
    "section": {
      "active": "진행 중",
      "completed": "완료됨"
    }
  },
  "rule_board": {
    "empty": "[ 규칙 없음 ]",
    "active_count": "활성 규칙: {{count}}개"
  },
  "mutation": {
    "empty": "[ 변형 이력 없음 ]",
    "timeline_title": "변형 타임라인",
    "event_count": "{{count}}개 이벤트",
    "more_events": "+{{count}}개 더 보기",
    "turn_label": "T{{turn}}",
    "type": {
      "added": "추가됨",
      "modified": "수정됨",
      "removed": "제거됨"
    }
  },
  "scene": {
    "status": {
      "default": "데이터 대기 중",
      "loading": "동기화 중...",
      "offline": "연결 끊김",
      "blocked": "접근 제한됨",
      "low_signal": "신호 약함",
      "image_error": "장면 이미지를 불러올 수 없습니다.",
      "initial_sync": "전역 데이터 동기화 대기 중...",
      "syncing": "데이터 동기화 중...",
      "alt": "장면 이미지"
    },
    "hotspot": {
      "layer_label": "클릭 가능한 오브젝트 영역",
      "hint_prefix": "힌트",
      "click_action": "{{label}} 클릭",
      "drop_hint": "여기에 드롭하여 사용",
      "drop_action": "{{item}}을(를) {{target}}에 사용",
      "drop_invalid": "그곳에는 {{item}}을(를) 사용할 수 없습니다.",
      "demo_hint": "[데모 대상]"
    }
  },
  "agent": {
    "console": {
      "queue": "대기열",
      "badges": "검증 배지",
      "repair": "자동 복구",
      "status": {
        "idle": "대기 중",
        "processing": "처리 중"
      },
      "badges_empty": "[ 검증 대기 중 ]",
      "repaired": "(복구됨)",
      "phase": {
        "parse": "Parse",
        "validate": "Validate",
        "plan": "Plan",
        "resolve": "Resolve",
        "render": "Render",
        "verify": "Verify",
        "commit": "Commit"
      },
      "badge": {
        "schema": "Schema",
        "economy": "Economy",
        "safety": "Safety",
        "consistency": "Consistency",
        "ok": "OK",
        "fail": "FAIL"
      }
    }
  },
  "ui": {
    "logo": "UNKNOWN WORLD",
    "command_placeholder": "명령을 입력하세요...",
    "processing": "처리 중...",
    "execute": "실행",
    "wait": "대기",
    "panel_placeholder": "[ 준비 중 ]",
    "scale_decrease": "글자 크기 줄이기",
    "scale_increase": "글자 크기 늘리기",
    "scale_label": "UI 스케일 설정"
  },
  "economy": {
    "signal": "Signal",
    "shard": "Shard",
    "signal_cost": "Signal 소모",
    "shard_cost": "Shard 소모",
    "risk_level": "위험도",
    "hud_label": "재화 현황",
    "estimated_cost": "예상 비용",
    "confirmed_cost": "확정 비용",
    "insufficient_funds": "잔액 부족",
    "low_balance_warning": "잔액이 부족합니다",
    "alternatives_title": "대안 행동",
    "alternative_text_only": "텍스트만 생성 (이미지 없음)",
    "alternative_low_quality": "저품질/빠른 응답 선택",
    "ledger_title": "최근 원장 이력",
    "ledger_empty": "[ 이력 없음 ]",
    "model_label": {
      "FAST": "빠름",
      "QUALITY": "고품질",
      "CHEAP": "저비용",
      "REF": "참조"
    }
  },
  "connection": {
    "online": "온라인",
    "offline": "오프라인"
  },
  "inventory": {
    "empty": "[ 아이템 없음 ]",
    "grid_label": "인벤토리 아이템 목록",
    "item_label": "{{name}} (수량: {{quantity}})",
    "drag_hint": "드래그하여 사용"
  },
  "panel": {
    "inventory": {
      "title": "Inventory",
      "placeholder": "[ 드래그 앤 드롭 영역 ]"
    },
    "quest": {
      "title": "Quest",
      "placeholder": "[ 목표/퀘스트 목록 ]"
    },
    "rule_board": {
      "title": "Rule Board",
      "placeholder": "[ 월드 규칙/변형 타임라인 ]"
    },
    "agent_console": {
      "title": "Agent Console"
    },
    "memory_pin": {
      "title": "Memory Pin",
      "placeholder": "[ 고정된 기억/단서 ]"
    },
    "scanner": {
      "title": "Scanner",
      "placeholder": "[ 이미지 업로드 슬롯 ]"
    }
  },
  "action": {
    "default": {
      "explore": {
        "label": "탐색하기",
        "description": "주변을 살펴본다"
      },
      "investigate": {
        "label": "조사하기",
        "description": "자세히 살펴본다"
      },
      "talk": {
        "label": "대화하기",
        "description": "말을 걸어본다"
      }
    },
    "card_select": "카드 선택: {{cardId}}",
    "deck_label": "행동 선택 카드",
    "alternative": "대안",
    "insufficient_balance": "잔액 부족",
    "all_disabled_notice": "실행 가능한 행동이 없습니다. 대안을 확인하세요.",
    "risk": {
      "low": "낮음",
      "medium": "보통",
      "high": "높음"
    },
    "cost_range": "{{min}}~{{max}}"
  },
  "narrative": {
    "welcome": "미지의 세계에 오신 것을 환영합니다...",
    "turn_label": "[TURN {{turn}}]",
    "streaming_label": "[STREAMING]"
  }
}
</file>

<file path="frontend/src/App.tsx">
/**
 * Unknown World - 메인 게임 UI 레이아웃
 *
 * RULE-002 준수: 채팅 버블 UI 금지
 * - 내러티브는 "채팅"이 아니라 "게임 로그/내러티브 피드" 형태
 * - 고정 패널: Scene Canvas, Action Deck, Inventory, Quest,
 *   Rule Board, Economy HUD, Agent Console, Scanner Slot
 *
 * RULE-008: Agent Console에서 단계/배지/복구만 표시 (프롬프트 노출 금지)
 *
 * RU-003-Q4: App.tsx는 "레이아웃 + 이벤트 라우팅"에 집중
 * - 세션/월드 상태는 worldStore로 이동
 * - TurnOutput 반영은 worldStore.applyTurnOutput으로 단일화
 *
 * @see vibe/ref/frontend-style-guide.md
 * @see vibe/prd.md 6.7/6.8/9장
 */

import { useState, useCallback, useEffect, useMemo } from 'react';
import { useTranslation } from 'react-i18next';
import {
  DndContext,
  DragEndEvent,
  DragStartEvent,
  useSensor,
  useSensors,
  PointerSensor,
  KeyboardSensor,
} from '@dnd-kit/core';
import { Panel } from './components/Panel';
import { GameHeader } from './components/GameHeader';
import { NarrativeFeed } from './components/NarrativeFeed';
import { AgentConsole } from './components/AgentConsole';
import { EconomyHud } from './components/EconomyHud';
import { SceneCanvas, type HotspotClickData } from './components/SceneCanvas';
import { ActionDeck } from './components/ActionDeck';
import { InventoryPanel } from './components/InventoryPanel';
// U-013: Quest + Rule Board + Mutation Timeline
import { QuestPanel } from './components/QuestPanel';
import { RuleBoard } from './components/RuleBoard';
import { MutationTimeline } from './components/MutationTimeline';
import { useAgentStore } from './stores/agentStore';
import { useInventoryStore } from './stores/inventoryStore';
import { useUIPrefsStore, applyUIPrefsToDOM } from './stores/uiPrefsStore';
import { useWorldStore } from './stores/worldStore';
import { useTurnRunner } from './turn/turnRunner';
import type { ActionCard, DropInput } from './schemas/turn';
import { getCurrentThemeFromDOM } from './demo/demoFixtures';
import { isInventoryDragData, isHotspotDropData } from './dnd/types';
import { useDemoInitializer } from './demo/useDemoInitializer';

// =============================================================================
// 메인 App 컴포넌트
// =============================================================================

function App() {
  const { t } = useTranslation();

  // 데모 초기화 (RU-003: 훅으로 이동)
  useDemoInitializer();

  // 로컬 UI 상태
  const [inputText, setInputText] = useState('');

  // Store 상태
  const { economy, isConnected, sceneObjects, narrativeEntries, appendSystemNarrative } =
    useWorldStore();

  const { startDrag, endDrag } = useInventoryStore();
  const { isStreaming, narrativeBuffer } = useAgentStore();
  const { uiScale, increaseUIScale, decreaseUIScale } = useUIPrefsStore();

  // DOM에 UI 설정 적용 (U-028→U-037)
  useEffect(() => {
    applyUIPrefsToDOM({ uiScale });
  }, [uiScale]);

  // RU-003-Q3: Turn Runner (스트림 시작/취소/콜백 라우팅 담당)
  const turnRunnerDeps = useMemo(
    () => ({
      t,
      theme: getCurrentThemeFromDOM(),
    }),
    [t],
  );
  const turnRunner = useTurnRunner(turnRunnerDeps);

  /**
   * 턴을 실행합니다.
   */
  const executeTurn = useCallback(
    (text: string, actionId?: string, clickData?: HotspotClickData, dropData?: DropInput) => {
      turnRunner.runTurn({
        text,
        actionId,
        click: clickData,
        drop: dropData,
      });
      setInputText('');
    },
    [turnRunner],
  );

  /**
   * 입력 제출 핸들러
   */
  const handleSubmit = useCallback(() => {
    if (inputText.trim()) {
      executeTurn(inputText.trim());
    }
  }, [inputText, executeTurn]);

  /**
   * 카드 클릭 핸들러
   */
  const handleCardClick = useCallback(
    (card: ActionCard) => {
      executeTurn(card.label, card.id);
    },
    [executeTurn],
  );

  /**
   * 핫스팟 클릭 핸들러 (U-010)
   */
  const handleHotspotClick = useCallback(
    (data: HotspotClickData) => {
      const clickedObject = sceneObjects.find((obj) => obj.id === data.object_id);
      const clickText = clickedObject
        ? t('scene.hotspot.click_action', { label: clickedObject.label })
        : data.object_id;

      executeTurn(clickText, undefined, data);
    },
    [executeTurn, sceneObjects, t],
  );

  /**
   * 키보드 이벤트 핸들러
   */
  const handleKeyDown = useCallback(
    (e: React.KeyboardEvent) => {
      if (e.key === 'Enter' && !e.shiftKey) {
        e.preventDefault();
        handleSubmit();
      }
    },
    [handleSubmit],
  );

  /**
   * 드래그 시작 핸들러 (U-011)
   */
  const handleDragStart = useCallback(
    (event: DragStartEvent) => {
      const { active } = event;
      if (isInventoryDragData(active.data.current)) {
        startDrag(active.data.current.item_id);
      }
    },
    [startDrag],
  );

  /**
   * 드래그 종료 핸들러 (U-011 + U-012)
   */
  const handleDragEnd = useCallback(
    (event: DragEndEvent) => {
      const { active, over } = event;
      endDrag();

      const activeData = active.data.current;
      if (!isInventoryDragData(activeData)) {
        return;
      }

      const itemId = activeData.item_id;
      const itemName = activeData.item.name;

      const overData = over?.data.current;
      if (!over || !isHotspotDropData(overData)) {
        appendSystemNarrative(
          `[${t('connection.online')}] ${t('scene.hotspot.drop_invalid', { item: itemName })}`,
        );
        return;
      }

      const { object_id: targetObjectId, box_2d: targetBox2d, label: targetLabel } = overData;

      const dropText = t('scene.hotspot.drop_action', {
        item: itemName,
        target: targetLabel,
      });

      const dropInput: DropInput = {
        item_id: itemId,
        target_object_id: targetObjectId,
        target_box_2d: targetBox2d,
      };

      executeTurn(dropText, undefined, undefined, dropInput);
    },
    [endDrag, executeTurn, appendSystemNarrative, t],
  );

  // dnd-kit 센서 설정
  const sensors = useSensors(
    useSensor(PointerSensor, {
      activationConstraint: {
        distance: 8,
      },
    }),
    useSensor(KeyboardSensor),
  );

  return (
    <>
      <div className="crt-overlay" aria-hidden="true" />

      <DndContext sensors={sensors} onDragStart={handleDragStart} onDragEnd={handleDragEnd}>
        <div className="game-container">
          <GameHeader
            signal={economy.signal}
            memoryShard={economy.memory_shard}
            isConnected={isConnected}
            uiScale={uiScale}
            onIncreaseScale={increaseUIScale}
            onDecreaseScale={decreaseUIScale}
          />

          <aside className="sidebar-left">
            <Panel title={t('panel.inventory.title')} className="flex-1">
              <InventoryPanel />
            </Panel>
            {/* U-013: Quest Panel */}
            <Panel title={t('panel.quest.title')}>
              <QuestPanel />
            </Panel>
            {/* U-013: Rule Board + Mutation Timeline (별도 컴포넌트) */}
            <Panel title={t('panel.rule_board.title')}>
              <RuleBoard />
              <MutationTimeline />
            </Panel>
          </aside>

          <main className="game-center">
            <SceneCanvas onHotspotClick={handleHotspotClick} />
            <NarrativeFeed entries={narrativeEntries} streamingText={narrativeBuffer} />
          </main>

          <aside className="sidebar-right">
            <Panel title={t('panel.agent_console.title')} className="flex-1" hasChrome>
              <AgentConsole />
            </Panel>
            <Panel title={t('economy.hud_label')} hasChrome>
              <EconomyHud />
            </Panel>
            <Panel title={t('panel.scanner.title')} hasChrome>
              <div className="scanner-slot has-chrome">
                <p className="panel-placeholder">{t('panel.scanner.placeholder')}</p>
              </div>
            </Panel>
          </aside>

          <footer className="game-footer">
            <ActionDeck onCardClick={handleCardClick} />
            <div className="command-input-area">
              <span className="command-prompt">&gt;</span>
              <input
                type="text"
                className="command-input"
                placeholder={isStreaming ? t('ui.processing') : t('ui.command_placeholder')}
                aria-label={t('ui.command_placeholder')}
                value={inputText}
                onChange={(e) => setInputText(e.target.value)}
                onKeyDown={handleKeyDown}
                disabled={isStreaming}
              />
              <button type="button" onClick={handleSubmit} disabled={isStreaming}>
                {isStreaming ? t('ui.wait') : t('ui.execute')}
              </button>
            </div>
          </footer>
        </div>
      </DndContext>
    </>
  );
}

export default App;
</file>

</files>
