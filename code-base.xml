This file is a merged representation of a subset of the codebase, containing specifically included files and files not matching ignore patterns, combined into a single document by Repomix.

<file_summary>
This section contains a summary of this file.

<purpose>
This file contains a packed representation of a subset of the repository's contents that is considered the most important context.
It is designed to be easily consumable by AI systems for analysis, code review,
or other automated processes.
</purpose>

<file_format>
The content is organized as follows:
1. This summary section
2. Repository information
3. Directory structure
4. Repository files (if enabled)
5. Multiple file entries, each consisting of:
  - File path as an attribute
  - Full contents of the file
</file_format>

<usage_guidelines>
- This file should be treated as read-only. Any changes should be made to the
  original repository files, not this packed version.
- When processing this file, use the file path to distinguish
  between different files in the repository.
- Be aware that this file may contain sensitive information. Handle it with
  the same level of security as you would the original repository.
</usage_guidelines>

<notes>
- Some files may have been excluded based on .gitignore rules and Repomix's configuration
- Binary files are not included in this packed representation. Please refer to the Repository Structure section for a complete list of file paths, including binary files
- Only files matching these patterns are included: backend/src/**/*.py, backend/tests/**/*.py, frontend/src/**/*.{ts,tsx}, shared/schemas/**/*.json
- Files matching these patterns are excluded: .claude/**, .cursor/**, .gemini/**, .vscode/**, vibe/**, backend/.venv/**, frontend/node_modules/**
- Files matching patterns in .gitignore are excluded
- Files matching default ignore patterns are excluded
- Files are sorted by Git change count (files with more changes are at the bottom)
</notes>

</file_summary>

<directory_structure>
backend/src/unknown_world/__init__.py
backend/src/unknown_world/main.py
backend/src/unknown_world/models/__init__.py
backend/src/unknown_world/models/turn.py
backend/tests/integration/test_api.py
backend/tests/unit/models/test_turn.py
frontend/src/App.tsx
frontend/src/main.tsx
frontend/src/vite-env.d.ts
shared/schemas/turn/turn_input.schema.json
shared/schemas/turn/turn_output.schema.json
</directory_structure>

<files>
This section contains the contents of the repository's files.

<file path="backend/src/unknown_world/models/__init__.py">
"""Unknown World - 모델 패키지.

이 패키지는 TurnInput/TurnOutput 스키마 및 하위 타입을 정의합니다.
Gemini Structured Outputs(JSON Schema)용으로 설계되었습니다.

사용 예시:
    from unknown_world.models import TurnInput, TurnOutput

    # Pydantic → JSON Schema 변환 (Gemini response_json_schema용)
    schema = TurnOutput.model_json_schema()

    # 응답 검증
    output = TurnOutput.model_validate_json(response_text)

참조:
    - vibe/prd.md 8.7 (데이터 모델 설계)
    - vibe/ref/structured-outputs-guide.md
    - .cursor/rules/00-core-critical.mdc (RULE-003, RULE-005)
"""

from unknown_world.models.turn import (
    ActionCard,
    ActionDeck,
    AgentConsole,
    AgentPhase,
    Box2D,
    ClickInput,
    ClientInfo,
    Coordinate,
    CurrencyAmount,
    EconomyOutput,
    EconomySnapshot,
    ImageJob,
    Language,
    MemoryPin,
    ModelLabel,
    Quest,
    RenderOutput,
    RiskLevel,
    SafetyOutput,
    SceneObject,
    Theme,
    TurnInput,
    TurnOutput,
    UIOutput,
    ValidationBadge,
    WorldDelta,
    WorldRule,
)

__all__ = [
    # Enum 타입
    "Language",
    "Theme",
    "AgentPhase",
    "ValidationBadge",
    "ModelLabel",
    "RiskLevel",
    # 공통 하위 타입
    "Coordinate",
    "Box2D",
    "CurrencyAmount",
    # TurnInput 관련
    "TurnInput",
    "ClickInput",
    "ClientInfo",
    "EconomySnapshot",
    # TurnOutput 관련
    "TurnOutput",
    "UIOutput",
    "ActionDeck",
    "ActionCard",
    "SceneObject",
    "WorldDelta",
    "WorldRule",
    "Quest",
    "MemoryPin",
    "RenderOutput",
    "ImageJob",
    "EconomyOutput",
    "SafetyOutput",
    "AgentConsole",
]
</file>

<file path="backend/src/unknown_world/models/turn.py">
"""Unknown World - TurnInput/TurnOutput Pydantic 스키마.

이 모듈은 Unknown World의 핵심 데이터 모델을 정의합니다.
Gemini Structured Outputs에 투입 가능한 JSON Schema(부분집합)를 생성할 수 있습니다.

설계 원칙:
    - RULE-003: 구조화 출력(JSON Schema) 우선 + 이중 검증
    - RULE-005: 재화 인바리언트 (cost, balance_after 필수, 잔액 음수 금지)
    - RULE-006: ko/en 언어 정책 (Language enum으로 고정)
    - RULE-009: 좌표 규약 (0~1000, bbox [ymin,xmin,ymax,xmax])

사용 예시:
    # Gemini Structured Outputs용 JSON Schema 생성
    schema = TurnOutput.model_json_schema()

    # 응답 검증
    output = TurnOutput.model_validate_json(gemini_response_text)

참조:
    - vibe/prd.md 8.7 (데이터 모델 설계)
    - vibe/ref/structured-outputs-guide.md
    - .cursor/rules/00-core-critical.mdc
"""

from enum import Enum
from typing import Annotated

from pydantic import BaseModel, ConfigDict, Field

# =============================================================================
# 공통 Enum 타입
# =============================================================================


class Language(str, Enum):
    """지원 언어 (RULE-006).

    ko/en 혼합 출력 금지. TurnInput.language를 SSOT로 삼아
    모든 UI/내러티브/시스템 메시지는 동일 언어로 고정합니다.
    """

    KO = "ko-KR"
    EN = "en-US"


class Theme(str, Enum):
    """테마 설정."""

    DARK = "dark"
    LIGHT = "light"


class AgentPhase(str, Enum):
    """에이전트 실행 단계 (RULE-008).

    에이전트형 시스템임을 UI로 증명하기 위한 단계 표시.
    """

    PARSE = "parse"
    VALIDATE = "validate"
    PLAN = "plan"
    RESOLVE = "resolve"
    RENDER = "render"
    VERIFY = "verify"
    COMMIT = "commit"


class ValidationBadge(str, Enum):
    """검증 배지 (RULE-008).

    턴 결과에 대한 검증 상태를 표시합니다.
    """

    SCHEMA_OK = "schema_ok"
    SCHEMA_FAIL = "schema_fail"
    ECONOMY_OK = "economy_ok"
    ECONOMY_FAIL = "economy_fail"
    SAFETY_OK = "safety_ok"
    SAFETY_BLOCKED = "safety_blocked"
    CONSISTENCY_OK = "consistency_ok"
    CONSISTENCY_FAIL = "consistency_fail"


class ModelLabel(str, Enum):
    """모델/품질 선택 라벨 (RULE-008).

    프롬프트 노출 없이 "왜 이 선택이었는지"를 사용자 친화 라벨로 표시.
    """

    FAST = "FAST"
    QUALITY = "QUALITY"
    CHEAP = "CHEAP"
    REF = "REF"


class RiskLevel(str, Enum):
    """행동 위험도 수준."""

    LOW = "low"
    MEDIUM = "medium"
    HIGH = "high"


# =============================================================================
# 공통 하위 타입
# =============================================================================

# RULE-009: 좌표는 0~1000 정규화 좌표계 (이미지 이해 bbox 포맷과 호환)
Coordinate = Annotated[int, Field(ge=0, le=1000, description="정규화 좌표 (0~1000)")]


class Box2D(BaseModel):
    """2D 바운딩 박스 (RULE-009).

    좌표는 0~1000 정규화 좌표계이며, bbox는 [ymin, xmin, ymax, xmax] 순서입니다.
    이미지 이해 bbox 포맷과 호환됩니다.

    Attributes:
        ymin: Y 최소값 (상단)
        xmin: X 최소값 (좌측)
        ymax: Y 최대값 (하단)
        xmax: X 최대값 (우측)
    """

    model_config = ConfigDict(extra="forbid")

    ymin: Coordinate
    xmin: Coordinate
    ymax: Coordinate
    xmax: Coordinate


class CurrencyAmount(BaseModel):
    """재화 수량.

    Attributes:
        signal: 기본 재화 (텍스트 턴/이미지 생성/고급 기능에 소비)
        memory_shard: 희귀 재화 (중요 설정 고정, 고해상도 이미지 등에 소비)
    """

    model_config = ConfigDict(extra="forbid")

    signal: Annotated[int, Field(ge=0, description="시그널 (기본 재화, 0 이상)")]
    memory_shard: Annotated[int, Field(ge=0, description="기억 파편 (희귀 재화, 0 이상)")]


# =============================================================================
# TurnInput 관련 타입
# =============================================================================


class ClickInput(BaseModel):
    """클릭 입력 정보.

    화면 오브젝트 클릭 시 전달되는 정보입니다.

    Attributes:
        object_id: 클릭한 오브젝트 ID
        box_2d: 클릭 위치의 바운딩 박스 (선택)
    """

    model_config = ConfigDict(extra="forbid")

    object_id: str = Field(description="클릭한 오브젝트 ID")
    box_2d: Box2D | None = Field(default=None, description="클릭 위치 바운딩 박스 (선택)")


class ClientInfo(BaseModel):
    """클라이언트 정보.

    Attributes:
        viewport_w: 뷰포트 너비 (픽셀)
        viewport_h: 뷰포트 높이 (픽셀)
        theme: 현재 테마 (dark/light)
    """

    model_config = ConfigDict(extra="forbid")

    viewport_w: Annotated[int, Field(gt=0, description="뷰포트 너비 (픽셀)")]
    viewport_h: Annotated[int, Field(gt=0, description="뷰포트 높이 (픽셀)")]
    theme: Theme = Field(default=Theme.DARK, description="현재 테마")


class EconomySnapshot(BaseModel):
    """재화 스냅샷 (클라이언트 → 서버).

    클라이언트가 보유한 현재 재화 상태입니다.
    서버는 이를 검증하고 비용 계산에 사용합니다.

    Attributes:
        signal: 현재 시그널 잔액
        memory_shard: 현재 기억 파편 잔액
    """

    model_config = ConfigDict(extra="forbid")

    signal: Annotated[int, Field(ge=0, description="현재 시그널 잔액 (0 이상)")]
    memory_shard: Annotated[int, Field(ge=0, description="현재 기억 파편 잔액 (0 이상)")]


class TurnInput(BaseModel):
    """턴 입력 (클라이언트 → 서버).

    사용자가 턴을 진행할 때 서버로 전송하는 입력 데이터입니다.

    Attributes:
        language: 요청 언어 (응답도 동일 언어로 고정)
        text: 사용자 자연어 입력
        click: 오브젝트 클릭 정보 (선택)
        client: 클라이언트 환경 정보
        economy_snapshot: 현재 재화 상태

    Example:
        >>> input_data = TurnInput(
        ...     language=Language.KO,
        ...     text="문을 열어본다",
        ...     economy_snapshot=EconomySnapshot(signal=100, memory_shard=5),
        ...     client=ClientInfo(viewport_w=1920, viewport_h=1080),
        ... )
    """

    model_config = ConfigDict(extra="forbid")

    language: Language = Field(description="요청 언어 (응답도 동일 언어로 고정)")
    text: str = Field(default="", description="사용자 자연어 입력")
    click: ClickInput | None = Field(default=None, description="오브젝트 클릭 정보 (선택)")
    client: ClientInfo = Field(description="클라이언트 환경 정보")
    economy_snapshot: EconomySnapshot = Field(description="현재 재화 상태")


# =============================================================================
# TurnOutput 관련 타입 - UI
# =============================================================================


class ActionCard(BaseModel):
    """액션 카드 (Action Deck).

    매 턴 AI가 추천하는 행동 카드입니다.
    각 카드에 비용/위험/보상 힌트가 포함됩니다.

    Attributes:
        id: 카드 고유 ID
        label: 카드 라벨 (표시용)
        description: 카드 설명 (선택)
        cost: 예상 비용
        risk: 위험도
        hint: 예상 결과 힌트 (선택)
    """

    model_config = ConfigDict(extra="forbid")

    id: str = Field(description="카드 고유 ID")
    label: str = Field(description="카드 라벨 (표시용)")
    description: str | None = Field(default=None, description="카드 설명 (선택)")
    cost: CurrencyAmount = Field(description="예상 비용")
    risk: RiskLevel = Field(default=RiskLevel.LOW, description="위험도")
    hint: str | None = Field(default=None, description="예상 결과 힌트 (선택)")


class SceneObject(BaseModel):
    """장면 오브젝트 (클릭 가능한 핫스팟).

    화면에서 클릭 가능한 오브젝트입니다.
    좌표는 0~1000 정규화 좌표계를 사용합니다 (RULE-009).

    Attributes:
        id: 오브젝트 고유 ID
        label: 오브젝트 라벨 (표시용)
        box_2d: 바운딩 박스 [ymin, xmin, ymax, xmax]
        interaction_hint: 상호작용 힌트 (선택)
    """

    model_config = ConfigDict(extra="forbid")

    id: str = Field(description="오브젝트 고유 ID")
    label: str = Field(description="오브젝트 라벨 (표시용)")
    box_2d: Box2D = Field(description="바운딩 박스")
    interaction_hint: str | None = Field(default=None, description="상호작용 힌트 (선택)")


class ActionDeck(BaseModel):
    """액션 덱 (Q1 결정: ui.action_deck.cards[] 구조).

    매 턴 AI가 제시하는 추천 행동 카드 덱입니다.

    Attributes:
        cards: 액션 카드 목록 (3~6장 권장)
    """

    model_config = ConfigDict(extra="forbid")

    cards: list[ActionCard] = Field(
        default=[],
        min_length=0,
        max_length=10,
        description="액션 카드 목록 (3~6장 권장)",
    )


class UIOutput(BaseModel):
    """UI 출력 데이터.

    AI가 생성한 UI 요소들입니다.
    채팅 버블이 아닌 게임 UI로 표현됩니다 (RULE-002).

    Attributes:
        action_deck: 액션 카드 덱 (Q1 결정: Option A 채택)
        objects: 클릭 가능한 장면 오브젝트 목록
    """

    model_config = ConfigDict(extra="forbid")

    action_deck: ActionDeck = Field(default_factory=ActionDeck, description="액션 카드 덱")
    objects: list[SceneObject] = Field(default=[], description="클릭 가능한 장면 오브젝트 목록")


# =============================================================================
# TurnOutput 관련 타입 - World
# =============================================================================


class MemoryPin(BaseModel):
    """중요 설정 고정 후보.

    사용자가 Memory Shard를 소비해 고정할 수 있는 중요 설정입니다.

    Attributes:
        id: 핀 고유 ID
        content: 고정할 내용
        cost: 고정에 필요한 비용
    """

    model_config = ConfigDict(extra="forbid")

    id: str = Field(description="핀 고유 ID")
    content: str = Field(description="고정할 내용")
    cost: CurrencyAmount = Field(description="고정에 필요한 비용")


class WorldRule(BaseModel):
    """세계 규칙 (Rule Board).

    현재 세계에 적용 중인 물리 법칙이나 메타 규칙입니다.

    Attributes:
        id: 규칙 고유 ID
        label: 규칙 이름
        description: 규칙 상세 설명 (선택)
    """

    model_config = ConfigDict(extra="forbid")

    id: str = Field(description="규칙 고유 ID")
    label: str = Field(description="규칙 이름")
    description: str | None = Field(default=None, description="규칙 상세 설명 (선택)")


class Quest(BaseModel):
    """퀘스트/목표 (Quest Panel).

    플레이어가 달성해야 하는 현재 목표입니다.

    Attributes:
        id: 퀘스트 고유 ID
        label: 퀘스트 이름
        is_completed: 달성 여부
    """

    model_config = ConfigDict(extra="forbid")

    id: str = Field(description="퀘스트 고유 ID")
    label: str = Field(description="퀘스트 이름")
    is_completed: bool = Field(default=False, description="달성 여부")


class WorldDelta(BaseModel):
    """세계 상태 변화 (Q2 결정: Option A - delta 중심).

    이번 턴에서 변경된 세계 상태를 나타냅니다.
    snapshot은 SaveGame에만 저장하고, 매 턴은 delta만 전송합니다.

    Attributes:
        rules_changed: 변경되거나 추가된 규칙 목록
        inventory_added: 추가된 인벤토리 아이템
        inventory_removed: 제거된 인벤토리 아이템
        quests_updated: 업데이트된 퀘스트(목표) 목록
        relationships_changed: 변경된 관계
        memory_pins: 중요 설정 고정 후보
    """

    model_config = ConfigDict(extra="forbid")

    rules_changed: list[WorldRule] = Field(default=[], description="변경된 규칙 목록")
    inventory_added: list[str] = Field(default=[], description="추가된 인벤토리 아이템")
    inventory_removed: list[str] = Field(default=[], description="제거된 인벤토리 아이템")
    quests_updated: list[Quest] = Field(default=[], description="업데이트된 퀘스트/목표 목록")
    relationships_changed: list[str] = Field(default=[], description="변경된 관계")
    memory_pins: list[MemoryPin] = Field(default=[], description="중요 설정 고정 후보")


# =============================================================================
# TurnOutput 관련 타입 - Render
# =============================================================================


class ImageJob(BaseModel):
    """이미지 생성 작업.

    조건부 이미지 생성/편집 요청입니다.
    이미지 생성이 느릴 경우 텍스트 우선 출력 + Lazy Loading을 사용합니다.

    Attributes:
        should_generate: 이미지를 생성해야 하는지
        prompt: 이미지 생성 프롬프트
        model_label: 모델 선택 라벨 (FAST/QUALITY/CHEAP/REF)
        aspect_ratio: 가로세로 비율 (예: "16:9", "1:1")
        image_size: 이미지 크기 (예: "1024x1024")
        reference_image_ids: 참조 이미지 ID 목록 (선택)
    """

    model_config = ConfigDict(extra="forbid")

    should_generate: bool = Field(description="이미지를 생성해야 하는지")
    prompt: str = Field(default="", description="이미지 생성 프롬프트")
    model_label: ModelLabel = Field(default=ModelLabel.FAST, description="모델 선택 라벨")
    aspect_ratio: str = Field(default="16:9", description="가로세로 비율")
    image_size: str = Field(default="1024x1024", description="이미지 크기")
    reference_image_ids: list[str] = Field(default=[], description="참조 이미지 ID 목록 (선택)")


class RenderOutput(BaseModel):
    """렌더링 출력 데이터.

    이미지 생성/편집 관련 정보입니다.

    Attributes:
        image_job: 이미지 생성 작업 (선택)
    """

    model_config = ConfigDict(extra="forbid")

    image_job: ImageJob | None = Field(default=None, description="이미지 생성 작업 (선택)")


# =============================================================================
# TurnOutput 관련 타입 - Economy
# =============================================================================


class EconomyOutput(BaseModel):
    """경제 출력 데이터 (RULE-005).

    이번 턴의 비용과 잔액 정보입니다.
    잔액 음수는 절대 불가 (서버 Hard gate).

    Attributes:
        cost: 이번 턴에 소비된 비용
        balance_after: 소비 후 잔액

    Important:
        - cost와 balance_after는 항상 포함되어야 합니다.
        - balance_after의 signal과 memory_shard는 0 이상이어야 합니다.
    """

    model_config = ConfigDict(extra="forbid")

    cost: CurrencyAmount = Field(description="이번 턴에 소비된 비용")
    balance_after: CurrencyAmount = Field(description="소비 후 잔액")


# =============================================================================
# TurnOutput 관련 타입 - Safety
# =============================================================================


class SafetyOutput(BaseModel):
    """안전 출력 데이터.

    안전 정책 관련 정보입니다.
    차단 시 명시적 메시지와 함께 안전한 대체 결과를 제공합니다.

    Attributes:
        blocked: 안전 정책에 의해 차단되었는지
        message: 차단 시 사용자에게 표시할 메시지 (선택)
    """

    model_config = ConfigDict(extra="forbid")

    blocked: bool = Field(default=False, description="안전 정책에 의해 차단되었는지")
    message: str | None = Field(default=None, description="차단 시 사용자에게 표시할 메시지 (선택)")


# =============================================================================
# TurnOutput 관련 타입 - Agent Console
# =============================================================================


class AgentConsole(BaseModel):
    """에이전트 콘솔 데이터 (RULE-008).

    에이전트형 시스템임을 UI로 증명하기 위한 정보입니다.
    계획/실행/검증/복구의 흔적을 표시합니다.

    Attributes:
        current_phase: 현재 실행 단계
        badges: 검증 배지 목록
        repair_count: 자동 복구 시도 횟수
    """

    model_config = ConfigDict(extra="forbid")

    current_phase: AgentPhase = Field(default=AgentPhase.COMMIT, description="현재 실행 단계")
    badges: list[ValidationBadge] = Field(default=[], description="검증 배지 목록")
    repair_count: Annotated[int, Field(ge=0, description="자동 복구 시도 횟수")] = 0


# =============================================================================
# TurnOutput (메인 응답 스키마)
# =============================================================================


class TurnOutput(BaseModel):
    """턴 출력 (서버 → 클라이언트).

    서버가 턴 처리 후 클라이언트로 반환하는 구조화된 응답입니다.
    Gemini Structured Outputs(JSON Schema)로 강제됩니다.

    Hard Gate 필드 (RULE-003/004/005):
        - economy: cost와 balance_after 필수, 잔액 음수 금지
        - safety: blocked 시 안전한 대체 결과 제공
        - language: 요청 언어와 동일하게 고정 (혼합 출력 금지)

    Attributes:
        language: 응답 언어 (요청과 동일)
        narrative: 내러티브 텍스트 (표시용)
        ui: UI 요소 (액션 덱, 오브젝트)
        world: 세계 상태 변화 (delta 중심)
        render: 렌더링 정보 (이미지 생성 작업)
        economy: 경제 정보 (비용, 잔액)
        safety: 안전 정책 정보
        agent_console: 에이전트 실행 정보 (단계, 배지, 복구 횟수)

    Example:
        >>> output = TurnOutput(
        ...     language=Language.KO,
        ...     narrative="문이 삐걱거리며 열립니다...",
        ...     economy=EconomyOutput(
        ...         cost=CurrencyAmount(signal=5, memory_shard=0),
        ...         balance_after=CurrencyAmount(signal=95, memory_shard=5),
        ...     ),
        ...     safety=SafetyOutput(blocked=False),
        ... )
        >>> schema = TurnOutput.model_json_schema()

    Schema Generation:
        >>> # Gemini Structured Outputs용 JSON Schema 생성
        >>> json_schema = TurnOutput.model_json_schema()
        >>> # response_json_schema 파라미터에 전달
        >>> config = {
        ...     "response_mime_type": "application/json",
        ...     "response_json_schema": json_schema,
        ... }
    """

    model_config = ConfigDict(extra="forbid")

    # 필수 필드 (Hard Gate)
    language: Language = Field(description="응답 언어 (요청과 동일)")
    narrative: str = Field(description="내러티브 텍스트 (표시용)")
    economy: EconomyOutput = Field(description="경제 정보 (비용, 잔액)")
    safety: SafetyOutput = Field(description="안전 정책 정보")

    # UI 관련 필드
    ui: UIOutput = Field(default_factory=UIOutput, description="UI 요소")

    # 세계 상태 필드
    world: WorldDelta = Field(default_factory=WorldDelta, description="세계 상태 변화 (delta)")

    # 렌더링 필드
    render: RenderOutput = Field(default_factory=RenderOutput, description="렌더링 정보")

    # 에이전트 콘솔 필드
    agent_console: AgentConsole = Field(
        default_factory=AgentConsole, description="에이전트 실행 정보"
    )
</file>

<file path="backend/tests/integration/test_api.py">
from fastapi.testclient import TestClient

from unknown_world.main import app

client = TestClient(app)


def test_health_check():
    """/health 엔드포인트가 올바른 스키마와 상태를 반환하는지 테스트합니다."""
    response = client.get("/health")
    assert response.status_code == 200
    data = response.json()
    assert data["status"] == "ok"
    assert "version" in data
    assert data["service"] == "unknown-world-backend"


def test_root_endpoint():
    """루트 엔드포인트가 정상 작동하는지 테스트합니다."""
    response = client.get("/")
    assert response.status_code == 200
    assert "message" in response.json()


def test_cors_policy():
    """RULE-011에 따른 CORS 정책이 올바르게 설정되었는지 테스트합니다."""
    # 허용된 오리진 테스트 (포트 8001)
    headers = {
        "Origin": "http://localhost:8001",
        "Access-Control-Request-Method": "GET",
    }
    response = client.options("/health", headers=headers)
    assert response.status_code == 200
    assert response.headers.get("access-control-allow-origin") == "http://localhost:8001"

    # 허용되지 않은 오리진 테스트 (포트 9000)
    headers = {
        "Origin": "http://localhost:9000",
        "Access-Control-Request-Method": "GET",
    }
    response = client.options("/health", headers=headers)
    # FastAPI/Starlette CORS 미들웨어는 허용되지 않은 경우 origin 헤더를 반환하지 않음
    assert "access-control-allow-origin" not in response.headers
</file>

<file path="backend/tests/unit/models/test_turn.py">
"""TurnInput/TurnOutput 모델 단위 테스트."""

import pytest
from pydantic import ValidationError

from unknown_world.models.turn import (
    AgentConsole,
    Box2D,
    CurrencyAmount,
    EconomyOutput,
    Language,
    RenderOutput,
    TurnInput,
    TurnOutput,
    UIOutput,
    WorldDelta,
)

# =============================================================================
# Fixtures
# =============================================================================


@pytest.fixture
def valid_box_2d():
    return {"ymin": 100, "xmin": 200, "ymax": 300, "xmax": 400}


@pytest.fixture
def valid_currency_amount():
    return {"signal": 100, "memory_shard": 5}


@pytest.fixture
def valid_client_info():
    return {"viewport_w": 1920, "viewport_h": 1080, "theme": "dark"}


@pytest.fixture
def valid_turn_input_data(valid_client_info, valid_currency_amount):
    return {
        "language": "ko-KR",
        "text": "Hello",
        "client": valid_client_info,
        "economy_snapshot": valid_currency_amount,
    }


@pytest.fixture
def valid_turn_output_data(valid_currency_amount):
    return {
        "language": "ko-KR",
        "narrative": "Story continues...",
        "economy": {
            "cost": {"signal": 10, "memory_shard": 0},
            "balance_after": {"signal": 90, "memory_shard": 5},
        },
        "safety": {"blocked": False},
    }


# =============================================================================
# Coordinate & Box2D Tests
# =============================================================================


def test_box_2d_valid(valid_box_2d):
    box = Box2D(**valid_box_2d)
    assert box.ymin == 100
    assert box.xmax == 400


def test_box_2d_invalid_coordinate():
    with pytest.raises(ValidationError):
        # Out of range (ge=0, le=1000)
        Box2D(ymin=-1, xmin=0, ymax=1001, xmax=500)


def test_box_2d_extra_forbidden():
    with pytest.raises(ValidationError):
        Box2D(ymin=0, xmin=0, ymax=100, xmax=100, extra_field="not allowed")


# =============================================================================
# Currency & Economy Tests
# =============================================================================


def test_currency_amount_valid(valid_currency_amount):
    amount = CurrencyAmount(**valid_currency_amount)
    assert amount.signal == 100


def test_currency_amount_negative_fails():
    with pytest.raises(ValidationError):
        CurrencyAmount(signal=-1, memory_shard=0)


def test_economy_output_valid():
    data = {
        "cost": {"signal": 5, "memory_shard": 0},
        "balance_after": {"signal": 95, "memory_shard": 5},
    }
    economy = EconomyOutput(**data)
    assert economy.cost.signal == 5
    assert economy.balance_after.signal == 95


# =============================================================================
# TurnInput Tests
# =============================================================================


def test_turn_input_valid(valid_turn_input_data):
    turn_input = TurnInput(**valid_turn_input_data)
    assert turn_input.language == Language.KO
    assert turn_input.text == "Hello"


def test_turn_input_with_click(valid_turn_input_data, valid_box_2d):
    data = valid_turn_input_data.copy()
    data["click"] = {"object_id": "door_01", "box_2d": valid_box_2d}
    turn_input = TurnInput(**data)
    assert turn_input.click.object_id == "door_01"
    assert turn_input.click.box_2d.ymin == 100


def test_turn_input_invalid_language():
    with pytest.raises(ValidationError):
        TurnInput(
            language="fr-FR",  # Not in Language enum
            text="...",
            client={"viewport_w": 800, "viewport_h": 600},
            economy_snapshot={"signal": 0, "memory_shard": 0},
        )


# =============================================================================
# TurnOutput Tests
# =============================================================================


def test_turn_output_valid_minimal(valid_turn_output_data):
    turn_output = TurnOutput(**valid_turn_output_data)
    assert turn_output.language == Language.KO
    assert turn_output.narrative == "Story continues..."
    # Check defaults
    assert isinstance(turn_output.ui, UIOutput)
    assert isinstance(turn_output.world, WorldDelta)
    assert isinstance(turn_output.render, RenderOutput)
    assert isinstance(turn_output.agent_console, AgentConsole)


def test_turn_output_full(valid_currency_amount, valid_box_2d):
    data = {
        "language": "en-US",
        "narrative": "Narrative text",
        "ui": {
            "action_deck": {
                "cards": [
                    {
                        "id": "c1",
                        "label": "Action 1",
                        "cost": {"signal": 5, "memory_shard": 0},
                    }
                ]
            },
            "objects": [{"id": "obj1", "label": "Object 1", "box_2d": valid_box_2d}],
        },
        "world": {
            "inventory_added": ["key"],
            "rules_changed": [{"id": "r1", "label": "Gravity", "description": "Low gravity"}],
            "quests_updated": [{"id": "q1", "label": "Find key", "is_completed": False}],
            "memory_pins": [
                {"id": "p1", "content": "Fact", "cost": {"signal": 1, "memory_shard": 0}}
            ],
        },
        "render": {
            "image_job": {
                "should_generate": True,
                "prompt": "A landscape",
                "model_label": "QUALITY",
            }
        },
        "economy": {
            "cost": {"signal": 10, "memory_shard": 0},
            "balance_after": {"signal": 90, "memory_shard": 5},
        },
        "safety": {"blocked": False},
        "agent_console": {"repair_count": 1, "badges": ["schema_ok", "economy_ok"]},
    }
    turn_output = TurnOutput(**data)
    assert turn_output.language == Language.EN
    assert len(turn_output.ui.action_deck.cards) == 1
    assert turn_output.render.image_job.should_generate is True


def test_turn_output_missing_required():
    with pytest.raises(ValidationError):
        # Missing economy and safety
        TurnOutput(language="ko-KR", narrative="...")


# =============================================================================
# JSON Schema Tests
# =============================================================================


def test_turn_output_json_schema():
    schema = TurnOutput.model_json_schema()
    assert schema["type"] == "object"
    assert "language" in schema["required"]
    assert "narrative" in schema["required"]
    assert "economy" in schema["required"]
    assert "safety" in schema["required"]

    # Check Coordinate constraints in schema
    # Pydantic 2 schema structure: properties -> language -> ...
    # Coordinate might be in $defs or inline depending on how it's used
    ui_props = schema["$defs"]["UIOutput"]["properties"]
    assert "action_deck" in ui_props

    # Verify that Coordinate (int with ge/le) is correctly represented
    # Box2D uses Coordinate
    box_props = schema["$defs"]["Box2D"]["properties"]
    assert box_props["ymin"]["maximum"] == 1000
    assert box_props["ymin"]["minimum"] == 0
</file>

<file path="frontend/src/main.tsx">
import { StrictMode } from 'react';
import { createRoot } from 'react-dom/client';
import './style.css';
import App from './App.tsx';

createRoot(document.getElementById('root')!).render(
  <StrictMode>
    <App />
  </StrictMode>,
);
</file>

<file path="frontend/src/vite-env.d.ts">
/// <reference types="vite/client" />
</file>

<file path="shared/schemas/turn/turn_input.schema.json">
{
  "$schema": "http://json-schema.org/draft-07/schema#",
  "$id": "https://unknown-world.dev/schemas/turn/turn_input.schema.json",
  "title": "TurnInput",
  "description": "Client → Server 턴 요청 스키마 (MVP). PRD 8.7절 기반.",
  "type": "object",
  "properties": {
    "language": {
      "type": "string",
      "enum": ["ko-KR", "en-US"],
      "description": "게임 언어 설정 (ko-KR 또는 en-US)"
    },
    "text": {
      "type": "string",
      "description": "사용자 입력 (자연어)"
    },
    "click": {
      "type": ["object", "null"],
      "description": "클릭된 오브젝트 정보 (선택)",
      "properties": {
        "object_id": {
          "type": "string",
          "description": "클릭된 오브젝트 ID"
        },
        "box_2d": {
          "type": ["array", "null"],
          "description": "bbox [ymin, xmin, ymax, xmax] (0~1000 정규화)",
          "items": {
            "type": "integer",
            "minimum": 0,
            "maximum": 1000
          },
          "minItems": 4,
          "maxItems": 4
        }
      },
      "required": ["object_id"]
    },
    "client": {
      "type": "object",
      "description": "클라이언트 환경 정보",
      "properties": {
        "viewport_w": {
          "type": "integer",
          "description": "뷰포트 너비 (px)"
        },
        "viewport_h": {
          "type": "integer",
          "description": "뷰포트 높이 (px)"
        },
        "theme": {
          "type": "string",
          "enum": ["dark", "light"],
          "description": "테마 설정"
        }
      },
      "required": ["viewport_w", "viewport_h", "theme"]
    },
    "economy_snapshot": {
      "type": "object",
      "description": "현재 재화 상태 스냅샷",
      "properties": {
        "signal": {
          "type": "integer",
          "minimum": 0,
          "description": "Signal 재화 잔액"
        },
        "memory_shard": {
          "type": "integer",
          "minimum": 0,
          "description": "Memory Shard 재화 잔액"
        }
      },
      "required": ["signal", "memory_shard"]
    }
  },
  "required": ["language", "text", "client", "economy_snapshot"],
  "additionalProperties": false
}
</file>

<file path="shared/schemas/turn/turn_output.schema.json">
{
  "$schema": "http://json-schema.org/draft-07/schema#",
  "$id": "https://unknown-world.dev/schemas/turn/turn_output.schema.json",
  "title": "TurnOutput",
  "description": "Server → Client 턴 응답 스키마 (MVP). PRD 8.7절 기반. Gemini Structured Output 호환.",
  "type": "object",
  "properties": {
    "language": {
      "type": "string",
      "enum": ["ko-KR", "en-US"],
      "description": "응답 언어 (TurnInput.language와 동일해야 함)"
    },
    "narrative": {
      "type": "string",
      "description": "내러티브 텍스트 (표시용)"
    },
    "ui": {
      "type": "object",
      "description": "UI 요소 (선택지, 오브젝트)",
      "properties": {
        "choices": {
          "type": "array",
          "description": "버튼형 선택지 목록",
          "items": {
            "type": "object",
            "properties": {
              "id": {
                "type": "string",
                "description": "선택지 고유 ID"
              },
              "label": {
                "type": "string",
                "description": "선택지 라벨"
              },
              "cost": {
                "type": "object",
                "description": "예상 비용",
                "properties": {
                  "signal": {
                    "type": "integer",
                    "minimum": 0
                  },
                  "memory_shard": {
                    "type": "integer",
                    "minimum": 0
                  }
                },
                "required": ["signal", "memory_shard"]
              },
              "hint": {
                "type": ["string", "null"],
                "description": "예상 결과 힌트"
              }
            },
            "required": ["id", "label", "cost"]
          }
        },
        "objects": {
          "type": "array",
          "description": "클릭 가능한 오브젝트 목록",
          "items": {
            "type": "object",
            "properties": {
              "id": {
                "type": "string",
                "description": "오브젝트 고유 ID"
              },
              "label": {
                "type": "string",
                "description": "오브젝트 라벨"
              },
              "box_2d": {
                "type": "array",
                "description": "bbox [ymin, xmin, ymax, xmax] (0~1000 정규화, RULE-009)",
                "items": {
                  "type": "integer",
                  "minimum": 0,
                  "maximum": 1000
                },
                "minItems": 4,
                "maxItems": 4
              },
              "interaction_hint": {
                "type": ["string", "null"],
                "description": "상호작용 힌트"
              }
            },
            "required": ["id", "label", "box_2d"]
          }
        }
      },
      "required": ["choices", "objects"]
    },
    "world": {
      "type": "object",
      "description": "월드 상태 변경 사항",
      "properties": {
        "delta": {
          "type": "object",
          "description": "이번 턴 변경 사항",
          "properties": {
            "rules": {
              "type": ["array", "null"],
              "description": "룰 변경 목록",
              "items": {
                "type": "object",
                "properties": {
                  "id": {
                    "type": "string"
                  },
                  "name": {
                    "type": "string"
                  },
                  "description": {
                    "type": "string"
                  },
                  "action": {
                    "type": "string",
                    "enum": ["added", "modified", "removed"]
                  }
                },
                "required": ["id", "name", "action"]
              }
            },
            "inventory": {
              "type": ["array", "null"],
              "description": "인벤토리 변경 목록",
              "items": {
                "type": "object",
                "properties": {
                  "id": {
                    "type": "string"
                  },
                  "name": {
                    "type": "string"
                  },
                  "action": {
                    "type": "string",
                    "enum": ["added", "removed", "used"]
                  },
                  "quantity": {
                    "type": "integer"
                  }
                },
                "required": ["id", "name", "action"]
              }
            }
          }
        },
        "memory_pins": {
          "type": "array",
          "description": "중요 설정 고정 후보 목록",
          "items": {
            "type": "object",
            "properties": {
              "id": {
                "type": "string"
              },
              "content": {
                "type": "string"
              },
              "pinned": {
                "type": "boolean"
              }
            },
            "required": ["id", "content", "pinned"]
          }
        }
      },
      "required": ["delta", "memory_pins"]
    },
    "render": {
      "type": ["object", "null"],
      "description": "렌더링 작업 (선택적)",
      "properties": {
        "image_job": {
          "type": ["object", "null"],
          "description": "이미지 생성 작업",
          "properties": {
            "should_generate": {
              "type": "boolean",
              "description": "이미지 생성 여부"
            },
            "model": {
              "type": "string",
              "enum": ["gemini-3-pro-image-preview"],
              "description": "이미지 모델 ID (RULE-010: 고정)"
            },
            "aspect_ratio": {
              "type": "string",
              "enum": ["1:1", "16:9", "9:16", "4:3", "3:4"],
              "description": "이미지 비율"
            },
            "image_size": {
              "type": "string",
              "enum": ["1K", "2K", "4K"],
              "description": "이미지 해상도"
            },
            "prompt": {
              "type": "string",
              "description": "이미지 생성 프롬프트"
            },
            "reference_images": {
              "type": ["array", "null"],
              "description": "참조 이미지 URI 목록",
              "items": {
                "type": "string"
              }
            }
          },
          "required": ["should_generate"]
        }
      }
    },
    "economy": {
      "type": "object",
      "description": "재화 정보 (RULE-005: 예상 비용/잔액 필수)",
      "properties": {
        "cost": {
          "type": "object",
          "description": "이번 턴 소모 비용",
          "properties": {
            "signal": {
              "type": "integer",
              "minimum": 0
            },
            "memory_shard": {
              "type": "integer",
              "minimum": 0
            }
          },
          "required": ["signal", "memory_shard"]
        },
        "balance_after": {
          "type": "object",
          "description": "턴 후 잔액 (음수 금지, RULE-005)",
          "properties": {
            "signal": {
              "type": "integer",
              "minimum": 0
            },
            "memory_shard": {
              "type": "integer",
              "minimum": 0
            }
          },
          "required": ["signal", "memory_shard"]
        }
      },
      "required": ["cost", "balance_after"]
    },
    "safety": {
      "type": "object",
      "description": "안전 정책 상태",
      "properties": {
        "blocked": {
          "type": "boolean",
          "description": "차단 여부"
        },
        "message": {
          "type": ["string", "null"],
          "description": "차단 시 메시지"
        }
      },
      "required": ["blocked"]
    }
  },
  "required": ["language", "narrative", "ui", "world", "economy", "safety"],
  "additionalProperties": false
}
</file>

<file path="backend/src/unknown_world/main.py">
"""Unknown World - FastAPI 애플리케이션 엔트리포인트

이 모듈은 Unknown World 백엔드의 FastAPI 앱을 정의합니다.
MVP 단계에서는 기본 헬스체크와 개발용 CORS 설정만 포함합니다.

실행 방법:
    cd backend
    uv sync
    uv run uvicorn unknown_world.main:app --reload --port 8011

참조:
    - vibe/tech-stack.md (버전 SSOT)
    - vibe/prd.md (에이전트형 게임 엔진 요구사항)
    - .cursor/rules/20-backend-orchestrator.mdc (SSE/검증/복구 규칙)
"""

from typing import Literal

from fastapi import FastAPI
from fastapi.middleware.cors import CORSMiddleware
from pydantic import BaseModel

from unknown_world import __version__

# =============================================================================
# FastAPI 앱 인스턴스
# =============================================================================

app = FastAPI(
    title="Unknown World API",
    description="Gemini 기반 에이전트형 게임 엔진 오케스트레이터",
    version=__version__,
    docs_url="/docs",
    redoc_url="/redoc",
)

# =============================================================================
# CORS 설정 (개발 환경용)
# =============================================================================
# PRD 요구: 로컬 개발에서 프론트와 통신할 수 있도록 CORS 기본 정책 준비
# RULE-011: 프론트엔드는 8001~8010 포트 사용
# 주의: 프로덕션에서는 MMP 단계에서 엄격한 정책으로 변경해야 함

ALLOWED_ORIGINS = [
    # 프론트엔드 개발 서버 포트 범위 (RULE-011: 8001~8010)
    *[f"http://localhost:{port}" for port in range(8001, 8011)],
    *[f"http://127.0.0.1:{port}" for port in range(8001, 8011)],
]

app.add_middleware(
    CORSMiddleware,
    allow_origins=ALLOWED_ORIGINS,
    allow_credentials=True,
    allow_methods=["*"],
    allow_headers=["*"],
)


# =============================================================================
# 응답 스키마 (Pydantic)
# =============================================================================


class HealthResponse(BaseModel):
    """헬스체크 응답 스키마.

    Attributes:
        status: 서버 상태 ("ok" 또는 "degraded")
        version: 백엔드 버전
        service: 서비스 이름
    """

    status: Literal["ok", "degraded"]
    version: str
    service: str


# =============================================================================
# 라우트 정의
# =============================================================================


@app.get("/health", response_model=HealthResponse, tags=["System"])
async def health_check() -> HealthResponse:
    """서버 헬스체크 엔드포인트.

    서버가 정상적으로 작동 중인지 확인합니다.
    이 엔드포인트는 로드밸런서, 모니터링 시스템, 클라이언트 연결 확인에 사용됩니다.

    Returns:
        HealthResponse: 서버 상태 정보
    """
    return HealthResponse(
        status="ok",
        version=__version__,
        service="unknown-world-backend",
    )


@app.get("/", tags=["System"])
async def root() -> dict[str, str]:
    """루트 엔드포인트.

    API 정보를 간략히 안내합니다.

    Returns:
        dict: 기본 안내 메시지
    """
    return {
        "message": "Unknown World API",
        "docs": "/docs",
        "health": "/health",
    }
</file>

<file path="frontend/src/App.tsx">
/**
 * Unknown World - 메인 게임 UI 레이아웃
 *
 * RULE-002 준수: 채팅 버블 UI 금지
 * - 내러티브는 "채팅"이 아니라 "게임 로그/내러티브 피드" 형태
 * - 고정 패널: Scene Canvas, Action Deck, Inventory, Quest,
 *   Rule Board, Economy HUD, Agent Console, Scanner Slot
 *
 * @see vibe/ref/frontend-style-guide.md
 * @see vibe/prd.md 6.7/6.8/9장
 */

/**
 * 패널 컴포넌트 - 공통 패널 레이아웃
 */
interface PanelProps {
  title: string;
  children?: React.ReactNode;
  className?: string;
}

function Panel({ title, children, className = '' }: PanelProps) {
  return (
    <div className={`panel ${className}`}>
      <div className="panel-header">
        <span className="panel-title">{title}</span>
      </div>
      <div className="panel-content">
        {children || <p className="panel-placeholder">[ 준비 중 ]</p>}
      </div>
    </div>
  );
}

/**
 * 내러티브 피드 - 게임 로그 형태 (채팅 버블 아님)
 * RULE-002: 좌/우 버블 대신 턴 타임라인으로 배치
 */
function NarrativeFeed() {
  const sampleEntries = [
    { turn: 1, text: '미지의 세계에 오신 것을 환영합니다...' },
    { turn: 2, text: '당신은 어둠 속에서 깨어났습니다.' },
    { turn: 3, text: '희미한 녹색 빛이 주변을 비추고 있습니다.' },
  ];

  return (
    <div className="narrative-feed">
      {sampleEntries.map((entry) => (
        <div key={entry.turn} className="narrative-entry">
          <span className="narrative-timestamp">[TURN {entry.turn}]</span>
          <span className="narrative-text">{entry.text}</span>
        </div>
      ))}
    </div>
  );
}

/**
 * 액션 덱 - 선택 가능한 행동 카드들
 * PRD: 비용/위험/보상 표시
 */
function ActionDeck() {
  const sampleActions = [
    { id: 1, title: '탐색하기', cost: 1, risk: '낮음' },
    { id: 2, title: '조사하기', cost: 2, risk: '중간' },
    { id: 3, title: '대화하기', cost: 1, risk: '없음' },
    { id: 4, title: '이동하기', cost: 1, risk: '낮음' },
  ];

  return (
    <div className="action-deck">
      {sampleActions.map((action) => (
        <div key={action.id} className="action-card">
          <div className="action-card-title">{action.title}</div>
          <div className="action-card-cost">
            ⚡ {action.cost} Signal | ⚠ {action.risk}
          </div>
        </div>
      ))}
    </div>
  );
}

/**
 * 헤더 - 타이틀, 상태, 재화 HUD
 */
function GameHeader() {
  return (
    <header className="game-header">
      <h1 className="game-title glitch" data-text="UNKNOWN WORLD">
        UNKNOWN WORLD
      </h1>
      <div className="header-controls">
        <div className="economy-hud">
          <span className="signal-icon">⚡</span>
          <span>Signal: 100</span>
        </div>
        <div className="connection-status">
          <span className="status-indicator" />
          <span>ONLINE</span>
        </div>
      </div>
    </header>
  );
}

/**
 * 메인 App 컴포넌트
 * CSS Grid 기반 고정 레이아웃
 */
function App() {
  return (
    <>
      {/* CRT 스캔라인 오버레이 */}
      <div className="crt-overlay" aria-hidden="true" />

      {/* 게임 레이아웃 */}
      <div className="game-container">
        {/* Header: 타이틀/상태/재화 */}
        <GameHeader />

        {/* Sidebar Left: Inventory / Quest / Rule Board */}
        <aside className="sidebar-left">
          <Panel title="Inventory" className="flex-1">
            <p className="panel-placeholder">[ 드래그 앤 드롭 영역 ]</p>
          </Panel>
          <Panel title="Quest">
            <p className="panel-placeholder">[ 목표/퀘스트 목록 ]</p>
          </Panel>
          <Panel title="Rule Board">
            <p className="panel-placeholder">[ 월드 규칙/변형 타임라인 ]</p>
          </Panel>
        </aside>

        {/* Center: Scene Canvas + Narrative Feed */}
        <main className="game-center">
          <div className="scene-canvas">
            <div className="scene-placeholder">
              <p>[ Scene Canvas ]</p>
              <p className="text-dim">이미지 + 핫스팟 오버레이 영역</p>
            </div>
          </div>
          <NarrativeFeed />
        </main>

        {/* Sidebar Right: Agent Console / Memory Pin / Scanner */}
        <aside className="sidebar-right">
          <Panel title="Agent Console" className="flex-1">
            <p className="panel-placeholder">
              [ Plan / Queue / Badges ]
              <br />
              Parse → Validate → Plan → Resolve
            </p>
          </Panel>
          <Panel title="Memory Pin">
            <p className="panel-placeholder">[ 고정된 기억/단서 ]</p>
          </Panel>
          <Panel title="Scanner">
            <p className="panel-placeholder">[ 이미지 업로드 슬롯 ]</p>
          </Panel>
        </aside>

        {/* Footer: Action Deck + Command Input */}
        <footer className="game-footer">
          <ActionDeck />
          <div className="command-input-area">
            <span className="command-prompt">&gt;</span>
            <input
              type="text"
              className="command-input"
              placeholder="명령을 입력하세요..."
              aria-label="게임 명령 입력"
            />
            <button type="button">EXECUTE</button>
          </div>
        </footer>
      </div>
    </>
  );
}

export default App;
</file>

<file path="backend/src/unknown_world/__init__.py">
"""Unknown World - Backend Package

This is the main package for the Unknown World backend.
Architecture: FastAPI + Pydantic + SSE streaming

Reference:
- vibe/tech-stack.md (Python 3.14, FastAPI 0.128.0, Pydantic 2.12.5)
- vibe/prd.md (Agent-based Game Master Engine)
"""

__version__ = "0.1.0"
</file>

</files>
