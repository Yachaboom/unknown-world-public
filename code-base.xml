This file is a merged representation of a subset of the codebase, containing specifically included files and files not matching ignore patterns, combined into a single document by Repomix.

<file_summary>
This section contains a summary of this file.

<purpose>
This file contains a packed representation of a subset of the repository's contents that is considered the most important context.
It is designed to be easily consumable by AI systems for analysis, code review,
or other automated processes.
</purpose>

<file_format>
The content is organized as follows:
1. This summary section
2. Repository information
3. Directory structure
4. Repository files (if enabled)
5. Multiple file entries, each consisting of:
  - File path as an attribute
  - Full contents of the file
</file_format>

<usage_guidelines>
- This file should be treated as read-only. Any changes should be made to the
  original repository files, not this packed version.
- When processing this file, use the file path to distinguish
  between different files in the repository.
- Be aware that this file may contain sensitive information. Handle it with
  the same level of security as you would the original repository.
</usage_guidelines>

<notes>
- Some files may have been excluded based on .gitignore rules and Repomix's configuration
- Binary files are not included in this packed representation. Please refer to the Repository Structure section for a complete list of file paths, including binary files
- Only files matching these patterns are included: **/*.{py,toml,json,yaml,env.example}
- Files matching these patterns are excluded: .claude/**, .cursor/**, .gemini/**, .vscode/**, vibe/**, backend/.venv/**
- Files matching patterns in .gitignore are excluded
- Files matching default ignore patterns are excluded
- Files are sorted by Git change count (files with more changes are at the bottom)
</notes>

</file_summary>

<directory_structure>
backend/.env.example
backend/pyproject.toml
backend/src/unknown_world/__init__.py
backend/src/unknown_world/api/__init__.py
backend/src/unknown_world/api/turn_stream_events.py
backend/src/unknown_world/api/turn.py
backend/src/unknown_world/config/__init__.py
backend/src/unknown_world/config/models.py
backend/src/unknown_world/main.py
backend/src/unknown_world/models/__init__.py
backend/src/unknown_world/models/turn.py
backend/src/unknown_world/orchestrator/__init__.py
backend/src/unknown_world/orchestrator/mock.py
backend/src/unknown_world/services/__init__.py
backend/src/unknown_world/services/genai_client.py
backend/tests/integration/test_api.py
backend/tests/integration/test_turn_streaming.py
backend/tests/qa/test_asset_manifest.py
backend/tests/unit/models/test_turn.py
backend/tests/unit/services/test_genai_client.py
backend/tests/unit/test_u034_verification.py
frontend/coverage/coverage-final.json
frontend/package.json
frontend/public/ui/manifest.json
frontend/public/ui/manifest.schema.json
frontend/src/locales/en-US/translation.json
frontend/src/locales/ko-KR/translation.json
frontend/tsconfig.json
frontend/tsconfig.node.json
package.json
shared/schemas/turn/turn_input.schema.json
shared/schemas/turn/turn_output.schema.json
</directory_structure>

<files>
This section contains the contents of the repository's files.

<file path="backend/.env.example">
# Unknown World Backend - 환경변수 설정
# 이 파일을 .env로 복사하고 실제 값을 입력하세요.
# cp .env.example .env

# =============================================================================
# GenAI 클라이언트 설정 (U-016)
# =============================================================================

# 동작 모드: mock (테스트/개발용) | real (실제 API 호출)
# 기본값: real
UW_MODE=real

# Vertex AI 서비스 계정 키 파일 경로 (절대 경로 권장)
# - Windows: D:/Dev/unknown-world/backend/unknown-world-key-dev.key
# - Linux/Mac: /path/to/unknown-world-key-dev.key
# 주의: 이 파일은 .gitignore에 포함되어야 합니다!
GOOGLE_APPLICATION_CREDENTIALS=./unknown-world-key-dev.key

# Vertex AI 프로젝트 ID (선택)
# 설정하지 않으면 ADC(Application Default Credentials)에서 자동 추론
# VERTEX_PROJECT=your-gcp-project-id

# Vertex AI 리전 (선택)
# 기본값: us-central1
# VERTEX_LOCATION=us-central1

# =============================================================================
# 서버 설정
# =============================================================================

# 백엔드 서버 포트 (RULE-011: 8011~8020 범위)
# 기본값: 8011
# PORT=8011
</file>

<file path="backend/src/unknown_world/api/__init__.py">
"""Unknown World - API 패키지.

이 패키지는 FastAPI 라우터들을 포함합니다.
"""

from unknown_world.api.turn import router as turn_router

__all__ = ["turn_router"]
</file>

<file path="backend/src/unknown_world/config/__init__.py">
"""Unknown World - 설정 및 상수 패키지.

이 패키지는 프로젝트 전역에서 사용하는 설정값과 상수를 관리합니다.
모델 ID, 환경 설정, 정책 등 SSOT를 유지하기 위한 중앙 저장소입니다.

참조:
    - vibe/tech-stack.md (버전/모델 SSOT)
    - .cursor/rules/00-core-critical.mdc (RULE-010: 버전/스택 고정)
"""

from unknown_world.config.models import (
    MODEL_FAST,
    MODEL_IMAGE,
    MODEL_QUALITY,
    ModelLabel,
    get_model_id,
)

__all__ = [
    "MODEL_FAST",
    "MODEL_QUALITY",
    "MODEL_IMAGE",
    "ModelLabel",
    "get_model_id",
]
</file>

<file path="backend/src/unknown_world/config/models.py">
"""Unknown World - 모델 라벨 및 ID 상수 정의.

이 모듈은 Gemini 모델 ID와 라벨을 SSOT로 관리합니다.
tech-stack.md 기준으로 버전/모델 ID가 고정되어 있으며,
임의 변경은 RULE-010 위반입니다.

모델 라인업 (tech-stack.md 기준):
    - 텍스트 FAST: gemini-3-flash-preview
    - 텍스트 QUALITY: gemini-3-pro-preview
    - 이미지(생성/편집): gemini-3-pro-image-preview (고정)

참조:
    - vibe/tech-stack.md (버전 기준일: 2026-01-01)
    - .cursor/rules/00-core-critical.mdc (RULE-007/010)
"""

from enum import StrEnum
from typing import Final


class ModelLabel(StrEnum):
    """모델 라벨 열거형.

    UI/로그에는 모델 ID 원문 대신 이 라벨을 우선 노출합니다. (RULE-008)
    """

    FAST = "FAST"
    """빠른 응답용 텍스트 모델 (gemini-3-flash-preview)"""

    QUALITY = "QUALITY"
    """고품질 텍스트 모델 (gemini-3-pro-preview)"""

    IMAGE = "IMAGE"
    """이미지 생성/편집 모델 (gemini-3-pro-image-preview, 고정)"""

    VISION = "VISION"
    """비전/공간 분석 모델 (bbox/segmentation용, gemini-3-flash-preview)"""


# =============================================================================
# 모델 ID 상수 (tech-stack.md SSOT)
# =============================================================================
# 주의: 이 값들은 tech-stack.md와 1:1로 일치해야 합니다.
# 임의 변경 금지 (RULE-010)

MODEL_FAST: Final[str] = "gemini-3-flash-preview"
"""FAST 라벨 모델 ID - 빠른 텍스트 생성용"""

MODEL_QUALITY: Final[str] = "gemini-3-pro-preview"
"""QUALITY 라벨 모델 ID - 고품질 텍스트 생성용"""

MODEL_IMAGE: Final[str] = "gemini-3-pro-image-preview"
"""IMAGE 라벨 모델 ID - 이미지 생성/편집용 (고정, RULE-010)"""

MODEL_VISION: Final[str] = "gemini-3-flash-preview"
"""VISION 라벨 모델 ID - 비전/공간 분석용 (bbox/segmentation)"""


# 라벨-ID 매핑 테이블
_MODEL_MAP: Final[dict[ModelLabel, str]] = {
    ModelLabel.FAST: MODEL_FAST,
    ModelLabel.QUALITY: MODEL_QUALITY,
    ModelLabel.IMAGE: MODEL_IMAGE,
    ModelLabel.VISION: MODEL_VISION,
}


def get_model_id(label: ModelLabel) -> str:
    """라벨로 모델 ID를 조회합니다.

    Args:
        label: 모델 라벨 (FAST, QUALITY, IMAGE, VISION)

    Returns:
        해당 라벨에 매핑된 모델 ID 문자열

    Example:
        >>> get_model_id(ModelLabel.FAST)
        'gemini-3-flash-preview'
    """
    return _MODEL_MAP[label]
</file>

<file path="backend/src/unknown_world/models/__init__.py">
"""Unknown World - 모델 패키지.

이 패키지는 TurnInput/TurnOutput 스키마 및 하위 타입을 정의합니다.
Gemini Structured Outputs(JSON Schema)용으로 설계되었습니다.

사용 예시:
    from unknown_world.models import TurnInput, TurnOutput

    # Pydantic → JSON Schema 변환 (Gemini response_json_schema용)
    schema = TurnOutput.model_json_schema()

    # 응답 검증
    output = TurnOutput.model_validate_json(response_text)

참조:
    - vibe/prd.md 8.7 (데이터 모델 설계)
    - vibe/ref/structured-outputs-guide.md
    - .cursor/rules/00-core-critical.mdc (RULE-003, RULE-005)
"""

from unknown_world.models.turn import (
    ActionCard,
    ActionDeck,
    AgentConsole,
    AgentPhase,
    Box2D,
    ClickInput,
    ClientInfo,
    Coordinate,
    CurrencyAmount,
    EconomyOutput,
    EconomySnapshot,
    ImageJob,
    Language,
    MemoryPin,
    ModelLabel,
    Quest,
    RenderOutput,
    RiskLevel,
    SafetyOutput,
    SceneObject,
    Theme,
    TurnInput,
    TurnOutput,
    UIOutput,
    ValidationBadge,
    WorldDelta,
    WorldRule,
)

__all__ = [
    # Enum 타입
    "Language",
    "Theme",
    "AgentPhase",
    "ValidationBadge",
    "ModelLabel",
    "RiskLevel",
    # 공통 하위 타입
    "Coordinate",
    "Box2D",
    "CurrencyAmount",
    # TurnInput 관련
    "TurnInput",
    "ClickInput",
    "ClientInfo",
    "EconomySnapshot",
    # TurnOutput 관련
    "TurnOutput",
    "UIOutput",
    "ActionDeck",
    "ActionCard",
    "SceneObject",
    "WorldDelta",
    "WorldRule",
    "Quest",
    "MemoryPin",
    "RenderOutput",
    "ImageJob",
    "EconomyOutput",
    "SafetyOutput",
    "AgentConsole",
]
</file>

<file path="backend/src/unknown_world/orchestrator/__init__.py">
"""Unknown World - Orchestrator 패키지.

이 패키지는 턴 처리 오케스트레이터를 포함합니다.
"""

from unknown_world.orchestrator.mock import MockOrchestrator

__all__ = ["MockOrchestrator"]
</file>

<file path="backend/src/unknown_world/services/__init__.py">
"""Unknown World - 서비스 레이어 패키지.

이 패키지는 외부 서비스와의 통신을 담당하는 모듈을 관리합니다.
GenAI 클라이언트, 스토리지 클라이언트 등이 포함됩니다.

참조:
    - vibe/tech-stack.md (google-genai 버전, Vertex AI 인증)
    - .cursor/rules/20-backend-orchestrator.mdc (Vertex 인증/비밀정보 금지)
"""

from unknown_world.services.genai_client import (
    GenAIClient,
    GenAIClientType,
    GenAIMode,
    GenerateRequest,
    GenerateResponse,
    MockGenAIClient,
    get_genai_client,
    reset_genai_client,
)

__all__ = [
    "GenAIClient",
    "GenAIClientType",
    "GenAIMode",
    "GenerateRequest",
    "GenerateResponse",
    "MockGenAIClient",
    "get_genai_client",
    "reset_genai_client",
]
</file>

<file path="backend/src/unknown_world/services/genai_client.py">
"""Unknown World - GenAI 클라이언트 래퍼.

이 모듈은 Vertex AI 서비스 계정 인증 기반의 google-genai 클라이언트를 제공합니다.
환경변수로 실제 모델과 mock 모드를 전환할 수 있습니다.

인증 방식:
    - 로컬: ADC 또는 GOOGLE_APPLICATION_CREDENTIALS 환경변수
    - 배포: Cloud Run 서비스 계정 권한 (키 파일 커밋 없음)

모드 전환 (페어링 질문 Q1 결정: Option A):
    - 환경변수 UW_MODE=mock → MockGenAIClient (테스트/개발용)
    - 환경변수 UW_MODE=real → 실제 Vertex AI 호출 (기본값)

보안 규칙:
    - BYOK(사용자 API 키 입력) 금지 (RULE-007)
    - 프롬프트 원문/비밀정보 로깅 금지 (RULE-007/008)
    - 로그에는 라벨/버전/정책 메타만 노출

참조:
    - vibe/tech-stack.md (google-genai==1.56.0)
    - .cursor/rules/20-backend-orchestrator.mdc
    - .cursor/rules/00-core-critical.mdc (RULE-007/010)
"""

from __future__ import annotations

import logging
import os
from collections.abc import AsyncGenerator
from dataclasses import dataclass, field
from enum import StrEnum
from typing import Any

from unknown_world.config.models import ModelLabel, get_model_id

# =============================================================================
# 로거 설정 (프롬프트/비밀정보 노출 금지)
# =============================================================================

logger = logging.getLogger(__name__)


class GenAIMode(StrEnum):
    """GenAI 클라이언트 동작 모드.

    환경변수 UW_MODE로 제어합니다.
    """

    MOCK = "mock"
    """테스트/개발용 모의 모드 - 실제 API 호출 없음"""

    REAL = "real"
    """실제 Vertex AI 호출 모드 (기본값)"""


# =============================================================================
# 환경변수 키 상수
# =============================================================================

ENV_UW_MODE = "UW_MODE"
"""동작 모드 환경변수 (mock|real)"""

ENV_VERTEX_PROJECT = "VERTEX_PROJECT"
"""Vertex AI 프로젝트 ID 환경변수"""

ENV_VERTEX_LOCATION = "VERTEX_LOCATION"
"""Vertex AI 리전 환경변수 (기본값: us-central1)"""


# =============================================================================
# 요청/응답 데이터 클래스
# =============================================================================


@dataclass
class GenerateRequest:
    """텍스트 생성 요청.

    Attributes:
        prompt: 생성 프롬프트 (주의: 로깅 금지)
        model_label: 모델 라벨 (FAST, QUALITY 등)
        max_tokens: 최대 토큰 수 (선택)
        temperature: 온도 설정 (선택, 0.0~1.0)
    """

    prompt: str
    model_label: ModelLabel = ModelLabel.FAST
    max_tokens: int | None = None
    temperature: float | None = None


@dataclass
class GenerateResponse:
    """텍스트 생성 응답.

    Attributes:
        text: 생성된 텍스트
        model_label: 사용된 모델 라벨
        finish_reason: 종료 이유 (stop, length 등)
        usage: 토큰 사용량 정보 (선택)
    """

    text: str
    model_label: ModelLabel
    finish_reason: str = "stop"
    usage: dict[str, int] = field(default_factory=lambda: {})


# =============================================================================
# Mock 클라이언트 구현
# =============================================================================


class MockGenAIClient:
    """테스트/개발용 모의 GenAI 클라이언트.

    실제 API를 호출하지 않고 고정된 응답을 반환합니다.
    자격 증명 미설정 시 자동으로 이 클라이언트가 사용됩니다.
    """

    def __init__(self) -> None:
        """MockGenAIClient를 초기화합니다."""
        logger.info(
            "[GenAI] Mock 모드로 초기화됨 (실제 API 호출 없음)",
            extra={"mode": GenAIMode.MOCK},
        )

    @property
    def mode(self) -> GenAIMode:
        """현재 동작 모드."""
        return GenAIMode.MOCK

    async def generate(self, request: GenerateRequest) -> GenerateResponse:
        """모의 텍스트를 생성합니다.

        Args:
            request: 생성 요청

        Returns:
            고정된 모의 응답
        """
        # 로그에는 메타 정보만 기록 (프롬프트 원문 금지 - RULE-007/008)
        logger.debug(
            "[GenAI] Mock 생성 요청",
            extra={
                "model_label": request.model_label,
                "max_tokens": request.max_tokens,
            },
        )

        return GenerateResponse(
            text=f"[Mock Response] 이것은 {request.model_label} 모델의 모의 응답입니다.",
            model_label=request.model_label,
            finish_reason="stop",
            usage={"prompt_tokens": 10, "completion_tokens": 20, "total_tokens": 30},
        )

    async def generate_stream(self, request: GenerateRequest) -> AsyncGenerator[str]:
        """모의 텍스트를 스트리밍으로 생성합니다.

        Args:
            request: 생성 요청

        Yields:
            고정된 모의 텍스트 청크
        """
        logger.debug(
            "[GenAI] Mock 스트리밍 요청",
            extra={"model_label": request.model_label},
        )

        chunks = [
            "[Mock] ",
            "이것은 ",
            f"{request.model_label} ",
            "모델의 ",
            "스트리밍 ",
            "모의 응답입니다.",
        ]
        for chunk in chunks:
            yield chunk

    def is_available(self) -> bool:
        """Mock 클라이언트는 항상 사용 가능합니다."""
        return True


# =============================================================================
# 실제 GenAI 클라이언트 구현
# =============================================================================


class GenAIClient:
    """Vertex AI 기반 실제 GenAI 클라이언트.

    google-genai SDK를 사용하여 Gemini 모델을 호출합니다.
    서비스 계정 인증(ADC)을 사용하며, BYOK는 금지됩니다.
    """

    def __init__(
        self,
        project: str | None = None,
        location: str | None = None,
    ) -> None:
        """GenAIClient를 초기화합니다.

        Args:
            project: Vertex AI 프로젝트 ID (환경변수 VERTEX_PROJECT 사용 가능)
            location: Vertex AI 리전 (기본값: us-central1)

        Raises:
            RuntimeError: 인증 설정이 올바르지 않은 경우
        """
        self._project = project or os.environ.get(ENV_VERTEX_PROJECT)
        self._location = location or os.environ.get(ENV_VERTEX_LOCATION, "us-central1")
        self._client: Any | None = None
        self._available = False

        self._initialize_client()

    def _initialize_client(self) -> None:
        """google-genai 클라이언트를 초기화합니다."""
        try:
            from google import genai  # type: ignore[import-untyped]

            # Vertex AI 모드로 클라이언트 초기화
            # 인증은 ADC(Application Default Credentials)를 사용
            # - 로컬: gcloud auth application-default login
            # - 배포: Cloud Run 서비스 계정 자동 인증
            client_options: dict[str, Any] = {}
            if self._project:
                client_options["project"] = self._project
            if self._location:
                client_options["location"] = self._location

            # vertexai=True로 Vertex AI 모드 활성화
            self._client = genai.Client(vertexai=True, **client_options)
            self._available = True

            # 로그에는 프로젝트/리전만 기록 (키/토큰 노출 금지)
            logger.info(
                "[GenAI] Vertex AI 클라이언트 초기화 완료",
                extra={
                    "mode": GenAIMode.REAL,
                    "project": self._project or "(ADC 기본)",
                    "location": self._location,
                },
            )
        except Exception as e:
            # 인증 실패 시에도 앱이 멈추지 않도록 로깅만 수행
            # 오류 상세(스택트레이스)에 비밀정보가 포함될 수 있으므로 exc_info=False
            logger.warning(
                "[GenAI] Vertex AI 클라이언트 초기화 실패 - Mock 모드로 전환 권장",
                extra={"error_type": type(e).__name__},
            )
            self._available = False

    @property
    def mode(self) -> GenAIMode:
        """현재 동작 모드."""
        return GenAIMode.REAL

    async def generate(self, request: GenerateRequest) -> GenerateResponse:
        """텍스트를 생성합니다.

        Args:
            request: 생성 요청

        Returns:
            생성된 텍스트 응답

        Raises:
            RuntimeError: 클라이언트가 사용 불가능한 경우
        """
        if not self._available or self._client is None:
            raise RuntimeError("GenAI 클라이언트가 초기화되지 않았습니다.")

        model_id = get_model_id(request.model_label)

        # 로그에는 메타 정보만 기록 (프롬프트 원문 금지 - RULE-007/008)
        logger.debug(
            "[GenAI] 생성 요청",
            extra={
                "model_label": request.model_label,
                "model_id": model_id,
                "max_tokens": request.max_tokens,
            },
        )

        # google-genai SDK 호출
        config: dict[str, Any] = {}
        if request.max_tokens:
            config["max_output_tokens"] = request.max_tokens
        if request.temperature is not None:
            config["temperature"] = request.temperature

        response = await self._client.aio.models.generate_content(
            model=model_id,
            contents=request.prompt,
            config=config if config else None,
        )

        # 응답 파싱
        text = response.text if hasattr(response, "text") else str(response)
        finish_reason = "stop"
        if hasattr(response, "candidates") and response.candidates:
            candidate = response.candidates[0]
            if hasattr(candidate, "finish_reason"):
                finish_reason = str(candidate.finish_reason)

        # 토큰 사용량 추출
        usage: dict[str, int] = {}
        if hasattr(response, "usage_metadata"):
            meta = response.usage_metadata
            if hasattr(meta, "prompt_token_count"):
                usage["prompt_tokens"] = meta.prompt_token_count
            if hasattr(meta, "candidates_token_count"):
                usage["completion_tokens"] = meta.candidates_token_count
            if hasattr(meta, "total_token_count"):
                usage["total_tokens"] = meta.total_token_count

        return GenerateResponse(
            text=text,
            model_label=request.model_label,
            finish_reason=finish_reason,
            usage=usage,
        )

    async def generate_stream(self, request: GenerateRequest) -> AsyncGenerator[str]:
        """텍스트를 스트리밍으로 생성합니다.

        Args:
            request: 생성 요청

        Yields:
            생성된 텍스트 청크

        Raises:
            RuntimeError: 클라이언트가 사용 불가능한 경우
        """
        if not self._available or self._client is None:
            raise RuntimeError("GenAI 클라이언트가 초기화되지 않았습니다.")

        model_id = get_model_id(request.model_label)

        logger.debug(
            "[GenAI] 스트리밍 요청",
            extra={
                "model_label": request.model_label,
                "model_id": model_id,
            },
        )

        config: dict[str, Any] = {}
        if request.max_tokens:
            config["max_output_tokens"] = request.max_tokens
        if request.temperature is not None:
            config["temperature"] = request.temperature

        stream = await self._client.aio.models.generate_content_stream(
            model=model_id,
            contents=request.prompt,
            config=config if config else None,
        )
        async for chunk in stream:
            if hasattr(chunk, "text") and chunk.text:
                yield chunk.text

    def is_available(self) -> bool:
        """클라이언트가 사용 가능한 상태인지 확인합니다."""
        return self._available


# =============================================================================
# 팩토리 함수
# =============================================================================

# 클라이언트 타입 (Protocol 대신 Union 사용 - pyright 호환성)
GenAIClientType = MockGenAIClient | GenAIClient

# 싱글톤 클라이언트 인스턴스 캐시
_client_instance: GenAIClientType | None = None


def get_genai_client(
    *,
    force_mock: bool = False,
    force_new: bool = False,
) -> GenAIClientType:
    """GenAI 클라이언트 인스턴스를 반환합니다.

    환경변수 UW_MODE에 따라 실제 클라이언트 또는 Mock 클라이언트를 반환합니다.
    기본적으로 싱글톤 패턴으로 동작합니다.

    Args:
        force_mock: True면 환경변수와 무관하게 Mock 클라이언트 반환
        force_new: True면 캐시를 무시하고 새 인스턴스 생성

    Returns:
        GenAI 클라이언트 인스턴스

    Example:
        >>> client = get_genai_client()
        >>> response = await client.generate(GenerateRequest(prompt="Hello"))
    """
    global _client_instance

    if not force_new and _client_instance is not None:
        return _client_instance

    # 모드 결정: force_mock > 환경변수 > 기본값(real)
    if force_mock:
        mode = GenAIMode.MOCK
    else:
        mode_str = os.environ.get(ENV_UW_MODE, GenAIMode.REAL)
        mode = GenAIMode(mode_str) if mode_str in GenAIMode.__members__.values() else GenAIMode.REAL

    # 클라이언트 생성
    client_result: GenAIClientType
    if mode == GenAIMode.MOCK:
        client_result = MockGenAIClient()
    else:
        client = GenAIClient()
        # 실제 클라이언트 초기화 실패 시 Mock으로 폴백
        if not client.is_available():
            logger.warning(
                "[GenAI] 실제 클라이언트 초기화 실패, Mock 모드로 폴백",
            )
            client_result = MockGenAIClient()
        else:
            client_result = client

    _client_instance = client_result
    return client_result


def reset_genai_client() -> None:
    """GenAI 클라이언트 캐시를 초기화합니다.

    테스트 시 클라이언트를 재설정할 때 사용합니다.
    """
    global _client_instance
    _client_instance = None
</file>

<file path="backend/tests/integration/test_api.py">
from fastapi.testclient import TestClient

from unknown_world.main import app

client = TestClient(app)


def test_health_check():
    """/health 엔드포인트가 올바른 스키마와 상태를 반환하는지 테스트합니다."""
    response = client.get("/health")
    assert response.status_code == 200
    data = response.json()
    assert data["status"] == "ok"
    assert "version" in data
    assert data["service"] == "unknown-world-backend"


def test_root_endpoint():
    """루트 엔드포인트가 정상 작동하는지 테스트합니다."""
    response = client.get("/")
    assert response.status_code == 200
    assert "message" in response.json()


def test_cors_policy():
    """RULE-011에 따른 CORS 정책이 올바르게 설정되었는지 테스트합니다."""
    # 허용된 오리진 테스트 (포트 8001)
    headers = {
        "Origin": "http://localhost:8001",
        "Access-Control-Request-Method": "GET",
    }
    response = client.options("/health", headers=headers)
    assert response.status_code == 200
    assert response.headers.get("access-control-allow-origin") == "http://localhost:8001"

    # 허용되지 않은 오리진 테스트 (포트 9000)
    headers = {
        "Origin": "http://localhost:9000",
        "Access-Control-Request-Method": "GET",
    }
    response = client.options("/health", headers=headers)
    # FastAPI/Starlette CORS 미들웨어는 허용되지 않은 경우 origin 헤더를 반환하지 않음
    assert "access-control-allow-origin" not in response.headers
</file>

<file path="backend/tests/qa/test_asset_manifest.py">
import json
import os

import pytest
from jsonschema import validate

# Paths
# This file is in backend/tests/qa/
# We go up 3 levels to get to backend root: backend/tests/qa -> backend/tests -> backend -> root (wait, backend is in root)
# Actually:
# __file__ = D:\Dev\unknown-world\backend\tests\qa\test_asset_manifest.py
# os.path.dirname(__file__) = D:\Dev\unknown-world\backend\tests\qa
# ... up 1 = tests
# ... up 2 = backend
# ... up 3 = unknown-world (project root)

CURRENT_DIR = os.path.dirname(os.path.abspath(__file__))
PROJECT_ROOT = os.path.dirname(os.path.dirname(os.path.dirname(CURRENT_DIR)))

# If PROJECT_ROOT is correct, it should contain frontend/
FRONTEND_UI_DIR = os.path.join(PROJECT_ROOT, "frontend", "public", "ui")
MANIFEST_PATH = os.path.join(FRONTEND_UI_DIR, "manifest.json")
SCHEMA_PATH = os.path.join(FRONTEND_UI_DIR, "manifest.schema.json")


def test_manifest_schema_validation():
    """Validates manifest.json against manifest.schema.json"""
    if not os.path.exists(MANIFEST_PATH):
        pytest.fail(f"Manifest not found at {MANIFEST_PATH}")
    if not os.path.exists(SCHEMA_PATH):
        pytest.fail(f"Schema not found at {SCHEMA_PATH}")

    with open(MANIFEST_PATH, encoding="utf-8") as f:
        manifest = json.load(f)

    with open(SCHEMA_PATH, encoding="utf-8") as f:
        schema = json.load(f)

    # validate raises ValidationError on failure
    validate(instance=manifest, schema=schema)


def test_asset_files_existence_and_size():
    """Checks if assets listed in manifest exist and sizes match/budget"""
    with open(MANIFEST_PATH, encoding="utf-8") as f:
        manifest = json.load(f)

    assets = manifest.get("assets", [])
    total_bytes_calculated = 0

    for asset in assets:
        rel_path = asset["path"]
        abs_path = os.path.join(FRONTEND_UI_DIR, rel_path)

        # 1. Existence Check
        assert os.path.exists(abs_path), f"Asset file missing: {rel_path} (full: {abs_path})"

        # 2. Size Check
        actual_size = os.path.getsize(abs_path)
        recorded_size = asset.get("bytes")

        # Note: If size mismatches, we print a helpful message.
        # In a real QA scenario, we might want to auto-update, but for this test we fail.
        if recorded_size is not None:
            assert actual_size == recorded_size, (
                f"Size mismatch for {rel_path}: actual {actual_size} != manifest {recorded_size}"
            )

        total_bytes_calculated += actual_size

        # 3. Individual Budget Check (from QA_CHECKLIST.md)
        asset_type = asset["type"]
        if asset_type == "icon":
            # 30KB limit
            assert actual_size <= 30 * 1024, (
                f"Icon {rel_path} exceeds 30KB budget ({actual_size} bytes)"
            )
        elif asset_type == "placeholder":
            # 300KB limit
            assert actual_size <= 300 * 1024, (
                f"Placeholder {rel_path} exceeds 300KB budget ({actual_size} bytes)"
            )
        elif asset_type == "chrome":
            # 120KB limit (increased for scanner-frame)
            assert actual_size <= 120 * 1024, (
                f"Chrome asset {rel_path} exceeds 120KB budget ({actual_size} bytes)"
            )

    # 4. Total Budget Check
    recorded_total = manifest.get("totalBytes")
    if recorded_total is not None:
        assert total_bytes_calculated == recorded_total, (
            f"Total bytes mismatch: calculated {total_bytes_calculated} != manifest {recorded_total}"
        )

    budget_total = manifest.get("budgetBytes", 1572864)
    assert total_bytes_calculated <= budget_total, (
        f"Total size {total_bytes_calculated} exceeds budget {budget_total}"
    )


def test_asset_naming_convention():
    """Checks if asset IDs and paths use kebab-case"""
    with open(MANIFEST_PATH, encoding="utf-8") as f:
        manifest = json.load(f)

    for asset in manifest["assets"]:
        asset_id = asset["id"]
        # Check for lowercase and kebab-case (allow numbers)
        assert asset_id.islower(), f"Asset ID {asset_id} should be lowercase"
        assert " " not in asset_id, f"Asset ID {asset_id} should not contain spaces"
        assert "_" not in asset_id, (
            f"Asset ID {asset_id} should not contain underscores (use kebab-case)"
        )
</file>

<file path="backend/tests/unit/models/test_turn.py">
"""TurnInput/TurnOutput 모델 단위 테스트."""

import pytest
from pydantic import ValidationError

from unknown_world.models.turn import (
    AgentConsole,
    Box2D,
    CurrencyAmount,
    EconomyOutput,
    Language,
    RenderOutput,
    TurnInput,
    TurnOutput,
    UIOutput,
    WorldDelta,
)

# =============================================================================
# Fixtures
# =============================================================================


@pytest.fixture
def valid_box_2d():
    return {"ymin": 100, "xmin": 200, "ymax": 300, "xmax": 400}


@pytest.fixture
def valid_currency_amount():
    return {"signal": 100, "memory_shard": 5}


@pytest.fixture
def valid_client_info():
    return {"viewport_w": 1920, "viewport_h": 1080, "theme": "dark"}


@pytest.fixture
def valid_turn_input_data(valid_client_info, valid_currency_amount):
    return {
        "language": "ko-KR",
        "text": "Hello",
        "client": valid_client_info,
        "economy_snapshot": valid_currency_amount,
    }


@pytest.fixture
def valid_turn_output_data(valid_currency_amount):
    return {
        "language": "ko-KR",
        "narrative": "Story continues...",
        "economy": {
            "cost": {"signal": 10, "memory_shard": 0},
            "balance_after": {"signal": 90, "memory_shard": 5},
        },
        "safety": {"blocked": False},
    }


# =============================================================================
# Coordinate & Box2D Tests
# =============================================================================


def test_box_2d_valid(valid_box_2d):
    box = Box2D(**valid_box_2d)
    assert box.ymin == 100
    assert box.xmax == 400


def test_box_2d_invalid_coordinate():
    with pytest.raises(ValidationError):
        # Out of range (ge=0, le=1000)
        Box2D(ymin=-1, xmin=0, ymax=1001, xmax=500)


def test_box_2d_extra_forbidden():
    with pytest.raises(ValidationError):
        Box2D(ymin=0, xmin=0, ymax=100, xmax=100, extra_field="not allowed")


# =============================================================================
# Currency & Economy Tests
# =============================================================================


def test_currency_amount_valid(valid_currency_amount):
    amount = CurrencyAmount(**valid_currency_amount)
    assert amount.signal == 100


def test_currency_amount_negative_fails():
    with pytest.raises(ValidationError):
        CurrencyAmount(signal=-1, memory_shard=0)


def test_economy_output_valid():
    data = {
        "cost": {"signal": 5, "memory_shard": 0},
        "balance_after": {"signal": 95, "memory_shard": 5},
    }
    economy = EconomyOutput(**data)
    assert economy.cost.signal == 5
    assert economy.balance_after.signal == 95


# =============================================================================
# TurnInput Tests
# =============================================================================


def test_turn_input_valid(valid_turn_input_data):
    turn_input = TurnInput(**valid_turn_input_data)
    assert turn_input.language == Language.KO
    assert turn_input.text == "Hello"


def test_turn_input_with_click(valid_turn_input_data, valid_box_2d):
    data = valid_turn_input_data.copy()
    data["click"] = {"object_id": "door_01", "box_2d": valid_box_2d}
    turn_input = TurnInput(**data)
    assert turn_input.click.object_id == "door_01"
    assert turn_input.click.box_2d.ymin == 100


def test_turn_input_invalid_language():
    with pytest.raises(ValidationError):
        TurnInput(
            language="fr-FR",  # Not in Language enum
            text="...",
            client={"viewport_w": 800, "viewport_h": 600},
            economy_snapshot={"signal": 0, "memory_shard": 0},
        )


# =============================================================================
# TurnOutput Tests
# =============================================================================


def test_turn_output_valid_minimal(valid_turn_output_data):
    turn_output = TurnOutput(**valid_turn_output_data)
    assert turn_output.language == Language.KO
    assert turn_output.narrative == "Story continues..."
    # Check defaults
    assert isinstance(turn_output.ui, UIOutput)
    assert isinstance(turn_output.world, WorldDelta)
    assert isinstance(turn_output.render, RenderOutput)
    assert isinstance(turn_output.agent_console, AgentConsole)


def test_turn_output_full(valid_currency_amount, valid_box_2d):
    data = {
        "language": "en-US",
        "narrative": "Narrative text",
        "ui": {
            "action_deck": {
                "cards": [
                    {
                        "id": "c1",
                        "label": "Action 1",
                        "cost": {"signal": 5, "memory_shard": 0},
                    }
                ]
            },
            "objects": [{"id": "obj1", "label": "Object 1", "box_2d": valid_box_2d}],
        },
        "world": {
            "inventory_added": ["key"],
            "rules_changed": [{"id": "r1", "label": "Gravity", "description": "Low gravity"}],
            "quests_updated": [{"id": "q1", "label": "Find key", "is_completed": False}],
            "memory_pins": [
                {"id": "p1", "content": "Fact", "cost": {"signal": 1, "memory_shard": 0}}
            ],
        },
        "render": {
            "image_job": {
                "should_generate": True,
                "prompt": "A landscape",
                "model_label": "QUALITY",
            }
        },
        "economy": {
            "cost": {"signal": 10, "memory_shard": 0},
            "balance_after": {"signal": 90, "memory_shard": 5},
        },
        "safety": {"blocked": False},
        "agent_console": {"repair_count": 1, "badges": ["schema_ok", "economy_ok"]},
    }
    turn_output = TurnOutput(**data)
    assert turn_output.language == Language.EN
    assert len(turn_output.ui.action_deck.cards) == 1
    assert turn_output.render.image_job.should_generate is True


def test_turn_output_missing_required():
    with pytest.raises(ValidationError):
        # Missing economy and safety
        TurnOutput(language="ko-KR", narrative="...")


# =============================================================================
# JSON Schema Tests
# =============================================================================


def test_turn_output_json_schema():
    schema = TurnOutput.model_json_schema()
    assert schema["type"] == "object"
    assert "language" in schema["required"]
    assert "narrative" in schema["required"]
    assert "economy" in schema["required"]
    assert "safety" in schema["required"]

    # Check Coordinate constraints in schema
    # Pydantic 2 schema structure: properties -> language -> ...
    # Coordinate might be in $defs or inline depending on how it's used
    ui_props = schema["$defs"]["UIOutput"]["properties"]
    assert "action_deck" in ui_props

    # Verify that Coordinate (int with ge/le) is correctly represented
    # Box2D uses Coordinate
    box_props = schema["$defs"]["Box2D"]["properties"]
    assert box_props["ymin"]["maximum"] == 1000
    assert box_props["ymin"]["minimum"] == 0
</file>

<file path="backend/tests/unit/services/test_genai_client.py">
import os
from unittest.mock import AsyncMock, MagicMock, patch

import pytest

from unknown_world.config.models import (
    MODEL_FAST,
    MODEL_IMAGE,
    MODEL_QUALITY,
    MODEL_VISION,
    ModelLabel,
    get_model_id,
)
from unknown_world.services.genai_client import (
    ENV_UW_MODE,
    GenAIClient,
    GenAIMode,
    GenerateRequest,
    GenerateResponse,
    MockGenAIClient,
    get_genai_client,
    reset_genai_client,
)


def test_model_id_mapping():
    """ModelLabel이 tech-stack.md의 ID와 올바르게 매핑되는지 확인합니다."""
    assert get_model_id(ModelLabel.FAST) == MODEL_FAST
    assert get_model_id(ModelLabel.QUALITY) == MODEL_QUALITY
    assert get_model_id(ModelLabel.IMAGE) == MODEL_IMAGE
    assert get_model_id(ModelLabel.VISION) == MODEL_VISION

    assert MODEL_FAST == "gemini-3-flash-preview"
    assert MODEL_QUALITY == "gemini-3-pro-preview"
    assert MODEL_IMAGE == "gemini-3-pro-image-preview"


def test_get_genai_client_mock_mode():
    """UW_MODE=mock일 때 MockGenAIClient가 반환되는지 확인합니다."""
    reset_genai_client()
    with patch.dict(os.environ, {ENV_UW_MODE: "mock"}):
        client = get_genai_client(force_new=True)
        assert isinstance(client, MockGenAIClient)
        assert client.mode == GenAIMode.MOCK


@pytest.mark.asyncio
async def test_mock_client_generate():
    """MockGenAIClient의 generate 메서드 동작을 확인합니다."""
    client = MockGenAIClient()
    request = GenerateRequest(prompt="test prompt", model_label=ModelLabel.FAST)
    response = await client.generate(request)

    assert isinstance(response, GenerateResponse)
    assert "[Mock Response]" in response.text
    assert response.model_label == ModelLabel.FAST
    assert "total_tokens" in response.usage


@pytest.mark.asyncio
async def test_mock_client_generate_stream():
    """MockGenAIClient의 generate_stream 메서드 동작을 확인합니다."""
    client = MockGenAIClient()
    request = GenerateRequest(prompt="test prompt", model_label=ModelLabel.QUALITY)

    chunks = []
    async for chunk in client.generate_stream(request):
        chunks.append(chunk)

    assert len(chunks) > 0
    assert any(ModelLabel.QUALITY in c for c in chunks)


def test_singleton_pattern():
    """get_genai_client가 싱글톤으로 동작하는지 확인합니다."""
    reset_genai_client()
    with patch.dict(os.environ, {ENV_UW_MODE: "mock"}):
        client1 = get_genai_client()
        client2 = get_genai_client()
        assert client1 is client2


def test_genai_client_initialization():
    """GenAIClient(real)가 SDK를 올바르게 초기화하는지 확인합니다."""
    with patch("google.genai.Client") as mock_genai_client:
        # VERTEX_PROJECT와 LOCATION 설정
        project = "test-project"
        location = "global"

        client = GenAIClient(project=project, location=location)

        # genai.Client가 vertexai=True와 함께 호출되었는지 확인
        mock_genai_client.assert_called_once()
        args, kwargs = mock_genai_client.call_args
        assert kwargs["vertexai"] is True
        assert kwargs["project"] == project
        assert kwargs["location"] == location
        assert client.is_available() is True


@pytest.mark.asyncio
async def test_genai_client_generate_real_call():
    """GenAIClient가 SDK의 generate_content를 올바르게 호출하는지 확인합니다."""
    with patch("google.genai.Client") as mock_client_class:
        mock_instance = mock_client_class.return_value
        # mock aio.models.generate_content
        mock_response = MagicMock()
        mock_response.text = "Actual response"
        mock_response.candidates = [MagicMock(finish_reason="STOP")]
        mock_response.usage_metadata = MagicMock(
            prompt_token_count=10, candidates_token_count=20, total_token_count=30
        )

        mock_instance.aio.models.generate_content = AsyncMock(return_value=mock_response)

        client = GenAIClient(project="p", location="l")
        request = GenerateRequest(prompt="hello", model_label=ModelLabel.QUALITY, max_tokens=100)

        response = await client.generate(request)

        # 호출 인자 확인
        mock_instance.aio.models.generate_content.assert_called_once_with(
            model=MODEL_QUALITY, contents="hello", config={"max_output_tokens": 100}
        )
        assert response.text == "Actual response"
        assert response.usage["total_tokens"] == 30


def test_genai_client_initialization_failure():
    """인증 오류 등으로 SDK 초기화 실패 시 동작을 확인합니다."""
    with patch("google.genai.Client", side_effect=Exception("Auth error")):
        client = GenAIClient()
        assert client.is_available() is False
        assert client.mode == GenAIMode.REAL


def test_get_genai_client_force_new():
    """force_new=True일 때 새 인스턴스가 생성되는지 확인합니다."""
    reset_genai_client()
    with patch.dict(os.environ, {ENV_UW_MODE: "mock"}):
        client1 = get_genai_client()
        client2 = get_genai_client(force_new=True)
        assert client1 is not client2


@pytest.mark.asyncio
async def test_genai_client_generate_stream_real_call():
    """GenAIClient가 스트리밍 호출을 올바르게 수행하는지 확인합니다."""
    with patch("google.genai.Client") as mock_client_class:
        mock_instance = mock_client_class.return_value

        # mock aio.models.generate_content_stream
        async def mock_stream():
            yield MagicMock(text="chunk1")
            yield MagicMock(text="chunk2")

        mock_instance.aio.models.generate_content_stream = AsyncMock(return_value=mock_stream())

        client = GenAIClient(project="p", location="l")
        request = GenerateRequest(prompt="hello", model_label=ModelLabel.FAST)

        chunks = []
        async for chunk in client.generate_stream(request):
            chunks.append(chunk)

        assert chunks == ["chunk1", "chunk2"]
        mock_instance.aio.models.generate_content_stream.assert_called_once()


@pytest.mark.asyncio
async def test_genai_client_unavailable_raises_error():
    """사용 불가능한 클라이언트 호출 시 RuntimeError가 발생하는지 확인합니다."""
    with patch("google.genai.Client", side_effect=Exception("Init error")):
        client = GenAIClient()
        assert client.is_available() is False

        request = GenerateRequest(prompt="hi")
        with pytest.raises(RuntimeError, match="초기화되지 않았습니다"):
            await client.generate(request)

        with pytest.raises(RuntimeError, match="초기화되지 않았습니다"):
            async for _ in client.generate_stream(request):
                pass


@pytest.mark.asyncio
async def test_genai_client_full_config():
    """max_tokens와 temperature가 SDK 호출 시 올바르게 전달되는지 확인합니다."""
    with patch("google.genai.Client") as mock_client_class:
        mock_instance = mock_client_class.return_value
        mock_instance.aio.models.generate_content = AsyncMock(return_value=MagicMock(text="ok"))

        async def mock_stream():
            yield MagicMock(text="ok")

        mock_instance.aio.models.generate_content_stream = AsyncMock(return_value=mock_stream())

        client = GenAIClient(project="p")
        request = GenerateRequest(prompt="hi", max_tokens=50, temperature=0.7)

        # generate 호출 검증
        await client.generate(request)
        mock_instance.aio.models.generate_content.assert_called_with(
            model=MODEL_FAST, contents="hi", config={"max_output_tokens": 50, "temperature": 0.7}
        )

        # generate_stream 호출 검증
        async for _ in client.generate_stream(request):
            pass
        mock_instance.aio.models.generate_content_stream.assert_called_with(
            model=MODEL_FAST, contents="hi", config={"max_output_tokens": 50, "temperature": 0.7}
        )


def test_get_genai_client_real_init_failure_fallback():
    """실제 클라이언트 초기화 실패 시 Mock 클라이언트로 폴백되는지 확인합니다."""
    reset_genai_client()
    with (
        patch.dict(os.environ, {ENV_UW_MODE: "real"}),
        patch("unknown_world.services.genai_client.GenAIClient.is_available", return_value=False),
    ):
        client = get_genai_client(force_new=True)
        assert isinstance(client, MockGenAIClient)


def test_reset_genai_client():
    """reset_genai_client가 캐시를 올바르게 비우는지 확인합니다."""
    reset_genai_client()
    with patch.dict(os.environ, {ENV_UW_MODE: "mock"}):
        client1 = get_genai_client()
        reset_genai_client()
        client2 = get_genai_client()
        assert client1 is not client2


def test_mock_client_is_available():
    """MockGenAIClient가 항상 사용 가능한지 확인합니다."""
    client = MockGenAIClient()
    assert client.is_available() is True


def test_get_genai_client_invalid_mode():
    """유효하지 않은 UW_MODE일 때 기본값(REAL)으로 동작하는지 확인합니다."""
    reset_genai_client()
    with patch.dict(os.environ, {ENV_UW_MODE: "invalid"}), patch(
        "unknown_world.services.genai_client.GenAIClient", return_value=MagicMock()
    ) as mock_real:
        get_genai_client(force_new=True)
        mock_real.assert_called_once()


def test_get_genai_client_force_mock():
    """force_mock=True일 때 환경변수와 무관하게 Mock 클라이언트를 반환하는지 확인합니다."""
    reset_genai_client()
    with patch.dict(os.environ, {ENV_UW_MODE: "real"}):
        client = get_genai_client(force_mock=True, force_new=True)
        assert isinstance(client, MockGenAIClient)
</file>

<file path="frontend/coverage/coverage-final.json">
{"D:\\Dev\\unknown-world\\frontend\\src\\schemas\\turn.ts": {"path":"D:\\Dev\\unknown-world\\frontend\\src\\schemas\\turn.ts","statementMap":{"0":{"start":{"line":30,"column":30},"end":{"line":30,"column":null}},"1":{"start":{"line":41,"column":30},"end":{"line":41,"column":null}},"2":{"start":{"line":47,"column":27},"end":{"line":47,"column":null}},"3":{"start":{"line":54,"column":32},"end":{"line":62,"column":null}},"4":{"start":{"line":69,"column":37},"end":{"line":78,"column":null}},"5":{"start":{"line":85,"column":32},"end":{"line":85,"column":null}},"6":{"start":{"line":91,"column":31},"end":{"line":91,"column":null}},"7":{"start":{"line":102,"column":32},"end":{"line":107,"column":null}},"8":{"start":{"line":115,"column":27},"end":{"line":122,"column":null}},"9":{"start":{"line":129,"column":36},"end":{"line":138,"column":null}},"10":{"start":{"line":149,"column":32},"end":{"line":156,"column":null}},"11":{"start":{"line":162,"column":32},"end":{"line":176,"column":null}},"12":{"start":{"line":183,"column":37},"end":{"line":192,"column":null}},"13":{"start":{"line":199,"column":31},"end":{"line":209,"column":null}},"14":{"start":{"line":220,"column":32},"end":{"line":229,"column":null}},"15":{"start":{"line":236,"column":33},"end":{"line":247,"column":null}},"16":{"start":{"line":254,"column":32},"end":{"line":262,"column":null}},"17":{"start":{"line":270,"column":30},"end":{"line":278,"column":null}},"18":{"start":{"line":289,"column":31},"end":{"line":295,"column":null}},"19":{"start":{"line":302,"column":31},"end":{"line":312,"column":null}},"20":{"start":{"line":319,"column":27},"end":{"line":325,"column":null}},"21":{"start":{"line":332,"column":32},"end":{"line":359,"column":null}},"22":{"start":{"line":370,"column":30},"end":{"line":382,"column":null}},"23":{"start":{"line":389,"column":34},"end":{"line":395,"column":null}},"24":{"start":{"line":407,"column":35},"end":{"line":412,"column":null}},"25":{"start":{"line":424,"column":34},"end":{"line":436,"column":null}},"26":{"start":{"line":447,"column":34},"end":{"line":453,"column":null}},"27":{"start":{"line":469,"column":32},"end":{"line":502,"column":null}},"28":{"start":{"line":523,"column":4},"end":{"line":525,"column":null}},"29":{"start":{"line":528,"column":4},"end":{"line":530,"column":null}},"30":{"start":{"line":532,"column":2},"end":{"line":563,"column":null}},"31":{"start":{"line":590,"column":17},"end":{"line":590,"column":null}},"32":{"start":{"line":592,"column":2},"end":{"line":594,"column":null}},"33":{"start":{"line":593,"column":4},"end":{"line":593,"column":null}},"34":{"start":{"line":596,"column":2},"end":{"line":600,"column":null}},"35":{"start":{"line":611,"column":2},"end":{"line":611,"column":null}},"36":{"start":{"line":625,"column":2},"end":{"line":625,"column":null}}},"fnMap":{"0":{"name":"createFallbackTurnOutput","decl":{"start":{"line":517,"column":16},"end":{"line":517,"column":null}},"loc":{"start":{"line":521,"column":14},"end":{"line":564,"column":null}},"line":521},"1":{"name":"safeParseTurnOutput","decl":{"start":{"line":585,"column":16},"end":{"line":585,"column":null}},"loc":{"start":{"line":589,"column":25},"end":{"line":601,"column":null}},"line":589},"2":{"name":"parseTurnInput","decl":{"start":{"line":610,"column":16},"end":{"line":610,"column":31}},"loc":{"start":{"line":610,"column":57},"end":{"line":612,"column":null}},"line":610},"3":{"name":"safeParseTurnInput","decl":{"start":{"line":624,"column":16},"end":{"line":624,"column":35}},"loc":{"start":{"line":624,"column":76},"end":{"line":626,"column":null}},"line":624}},"branchMap":{"0":{"loc":{"start":{"line":519,"column":2},"end":{"line":519,"column":null}},"type":"default-arg","locations":[{"start":{"line":519,"column":24},"end":{"line":519,"column":null}}],"line":519},"1":{"loc":{"start":{"line":523,"column":4},"end":{"line":525,"column":null}},"type":"cond-expr","locations":[{"start":{"line":524,"column":8},"end":{"line":524,"column":null}},{"start":{"line":525,"column":8},"end":{"line":525,"column":null}}],"line":523},"2":{"loc":{"start":{"line":528,"column":4},"end":{"line":530,"column":null}},"type":"cond-expr","locations":[{"start":{"line":529,"column":8},"end":{"line":529,"column":null}},{"start":{"line":530,"column":8},"end":{"line":530,"column":null}}],"line":528},"3":{"loc":{"start":{"line":534,"column":15},"end":{"line":534,"column":null}},"type":"binary-expr","locations":[{"start":{"line":534,"column":15},"end":{"line":534,"column":31}},{"start":{"line":534,"column":31},"end":{"line":534,"column":null}}],"line":534},"4":{"loc":{"start":{"line":587,"column":2},"end":{"line":587,"column":null}},"type":"default-arg","locations":[{"start":{"line":587,"column":23},"end":{"line":587,"column":null}}],"line":587},"5":{"loc":{"start":{"line":588,"column":2},"end":{"line":588,"column":null}},"type":"default-arg","locations":[{"start":{"line":588,"column":24},"end":{"line":588,"column":null}}],"line":588},"6":{"loc":{"start":{"line":592,"column":2},"end":{"line":594,"column":null}},"type":"if","locations":[{"start":{"line":592,"column":2},"end":{"line":594,"column":null}},{"start":{},"end":{}}],"line":592}},"s":{"0":1,"1":1,"2":1,"3":1,"4":1,"5":1,"6":1,"7":1,"8":1,"9":1,"10":1,"11":1,"12":1,"13":1,"14":1,"15":1,"16":1,"17":1,"18":1,"19":1,"20":1,"21":1,"22":1,"23":1,"24":1,"25":1,"26":1,"27":1,"28":1,"29":1,"30":1,"31":2,"32":2,"33":1,"34":1,"35":2,"36":2},"f":{"0":1,"1":2,"2":2,"3":2},"b":{"0":[1],"1":[1,0],"2":[1,0],"3":[1,1],"4":[2],"5":[2],"6":[1,1]},"meta":{"lastBranch":7,"lastFunction":4,"lastStatement":37,"seen":{"s:30:30:30:Infinity":0,"s:41:30:41:Infinity":1,"s:47:27:47:Infinity":2,"s:54:32:62:Infinity":3,"s:69:37:78:Infinity":4,"s:85:32:85:Infinity":5,"s:91:31:91:Infinity":6,"s:102:32:107:Infinity":7,"s:115:27:122:Infinity":8,"s:129:36:138:Infinity":9,"s:149:32:156:Infinity":10,"s:162:32:176:Infinity":11,"s:183:37:192:Infinity":12,"s:199:31:209:Infinity":13,"s:220:32:229:Infinity":14,"s:236:33:247:Infinity":15,"s:254:32:262:Infinity":16,"s:270:30:278:Infinity":17,"s:289:31:295:Infinity":18,"s:302:31:312:Infinity":19,"s:319:27:325:Infinity":20,"s:332:32:359:Infinity":21,"s:370:30:382:Infinity":22,"s:389:34:395:Infinity":23,"s:407:35:412:Infinity":24,"s:424:34:436:Infinity":25,"s:447:34:453:Infinity":26,"s:469:32:502:Infinity":27,"f:517:16:517:Infinity":0,"b:519:24:519:Infinity":0,"s:523:4:525:Infinity":28,"b:524:8:524:Infinity:525:8:525:Infinity":1,"s:528:4:530:Infinity":29,"b:529:8:529:Infinity:530:8:530:Infinity":2,"s:532:2:563:Infinity":30,"b:534:15:534:31:534:31:534:Infinity":3,"f:585:16:585:Infinity":1,"b:587:23:587:Infinity":4,"b:588:24:588:Infinity":5,"s:590:17:590:Infinity":31,"b:592:2:594:Infinity:undefined:undefined:undefined:undefined":6,"s:592:2:594:Infinity":32,"s:593:4:593:Infinity":33,"s:596:2:600:Infinity":34,"f:610:16:610:31":2,"s:611:2:611:Infinity":35,"f:624:16:624:35":3,"s:625:2:625:Infinity":36}}}
}
</file>

<file path="frontend/tsconfig.node.json">
{
  "compilerOptions": {
    "target": "ES2022",
    "lib": ["ES2022"],
    "module": "ESNext",
    "skipLibCheck": true,

    /* Bundler mode */
    "moduleResolution": "Bundler",
    "allowImportingTsExtensions": true,
    "isolatedModules": true,
    "moduleDetection": "force",

    /* Composite for project references */
    "composite": true,
    "emitDeclarationOnly": true,
    "declaration": true,
    "declarationMap": true,

    /* Linting (엄격 모드) */
    "strict": true,
    "noUnusedLocals": true,
    "noUnusedParameters": true,
    "noFallthroughCasesInSwitch": true,
    "noUncheckedSideEffectImports": true
  },
  "include": ["vite.config.ts"]
}
</file>

<file path="backend/src/unknown_world/api/turn_stream_events.py">
"""Unknown World - Turn Stream 이벤트 계약(Contract).

NDJSON 스트리밍에서 사용되는 이벤트 타입, 모델, 유틸리티를 정의합니다.
이 모듈은 Orchestrator ↔ API ↔ Frontend 간의 스트림 이벤트 계약 SSOT입니다.

설계 원칙:
    - RU-002-Q4: 이벤트 계약을 transport 계층으로 분리
    - RULE-003: 구조화 출력(JSON Schema) 우선 + Pydantic 검증
    - RULE-008: 단계/배지 가시화

참조:
    - vibe/unit-plans/U-007[Mvp].md
    - vibe/refactors/RU-002-Q4.md
"""

from __future__ import annotations

import json
from typing import Annotated, Any

from pydantic import BaseModel, Field

# =============================================================================
# 스트림 이벤트 타입 상수
# =============================================================================


class StreamEventType:
    """스트림 이벤트 타입 상수.

    NDJSON 스트리밍에서 사용되는 이벤트 타입입니다.
    PRD 예시 단계: Parse→Validate→Plan→Resolve→Render→Verify→Commit
    """

    STAGE = "stage"
    BADGES = "badges"
    NARRATIVE_DELTA = "narrative_delta"
    FINAL = "final"
    ERROR = "error"
    REPAIR = "repair"


class StageStatus:
    """단계 상태 상수."""

    START = "start"
    COMPLETE = "complete"
    FAIL = "fail"


# =============================================================================
# 스트림 이벤트 모델 (Pydantic)
# =============================================================================


class StageEvent(BaseModel):
    """단계 진행 이벤트.

    Attributes:
        type: 이벤트 타입 ("stage")
        name: 단계 이름 (Parse, Validate, Plan, Resolve, Render, Verify, Commit)
        status: 상태 (start, complete)
    """

    type: Annotated[str, Field(default=StreamEventType.STAGE)]
    name: str
    status: str


class RepairEvent(BaseModel):
    """자동 복구(Repair) 이벤트.

    Attributes:
        type: 이벤트 타입 ("repair")
        attempt: 현재 시도 횟수
        message: 복구 메시지 (선택)
    """

    type: Annotated[str, Field(default=StreamEventType.REPAIR)]
    attempt: int
    message: str | None = None


class BadgesEvent(BaseModel):
    """배지 이벤트.

    Attributes:
        type: 이벤트 타입 ("badges")
        badges: 검증 배지 목록
    """

    type: Annotated[str, Field(default=StreamEventType.BADGES)]
    badges: list[str]


class NarrativeDeltaEvent(BaseModel):
    """내러티브 델타 이벤트 (타자 효과용).

    Attributes:
        type: 이벤트 타입 ("narrative_delta")
        text: 추가된 텍스트 조각
    """

    type: Annotated[str, Field(default=StreamEventType.NARRATIVE_DELTA)]
    text: str


class FinalEvent(BaseModel):
    """최종 TurnOutput 이벤트.

    Attributes:
        type: 이벤트 타입 ("final")
        data: 완전한 TurnOutput

    Note:
        TurnOutput은 TYPE_CHECKING 블록에서 import되며,
        런타임에는 Any로 처리됩니다.
    """

    type: Annotated[str, Field(default=StreamEventType.FINAL)]
    data: Any  # TurnOutput (순환 import 방지)


class ErrorEvent(BaseModel):
    """에러 이벤트.

    Attributes:
        type: 이벤트 타입 ("error")
        message: 에러 메시지 (프롬프트/내부 추론 노출 금지)
        code: 에러 코드 (선택)
    """

    type: Annotated[str, Field(default=StreamEventType.ERROR)]
    message: str
    code: str | None = None


# =============================================================================
# 유틸리티 함수
# =============================================================================


def serialize_event(event: dict[str, Any]) -> str:
    """이벤트를 NDJSON 라인으로 직렬화합니다.

    Args:
        event: 직렬화할 이벤트 딕셔너리

    Returns:
        str: NDJSON 형식 문자열 (줄바꿈 포함)
    """
    return json.dumps(event, ensure_ascii=False) + "\n"


# =============================================================================
# 모듈 공개 API
# =============================================================================

__all__ = [
    "StreamEventType",
    "StageStatus",
    "StageEvent",
    "RepairEvent",
    "BadgesEvent",
    "NarrativeDeltaEvent",
    "FinalEvent",
    "ErrorEvent",
    "serialize_event",
]
</file>

<file path="backend/src/unknown_world/models/turn.py">
"""Unknown World - TurnInput/TurnOutput Pydantic 스키마.

이 모듈은 Unknown World의 핵심 데이터 모델을 정의합니다.
Gemini Structured Outputs에 투입 가능한 JSON Schema(부분집합)를 생성할 수 있습니다.

설계 원칙:
    - RULE-003: 구조화 출력(JSON Schema) 우선 + 이중 검증
    - RULE-005: 재화 인바리언트 (cost, balance_after 필수, 잔액 음수 금지)
    - RULE-006: ko/en 언어 정책 (Language enum으로 고정)
    - RULE-009: 좌표 규약 (0~1000, bbox [ymin,xmin,ymax,xmax])

사용 예시:
    # Gemini Structured Outputs용 JSON Schema 생성
    schema = TurnOutput.model_json_schema()

    # 응답 검증
    output = TurnOutput.model_validate_json(gemini_response_text)

참조:
    - vibe/prd.md 8.7 (데이터 모델 설계)
    - vibe/ref/structured-outputs-guide.md
    - .cursor/rules/00-core-critical.mdc
"""

from enum import Enum
from typing import Annotated

from pydantic import BaseModel, ConfigDict, Field

# =============================================================================
# 공통 Enum 타입
# =============================================================================


class Language(str, Enum):
    """지원 언어 (RULE-006).

    ko/en 혼합 출력 금지. TurnInput.language를 SSOT로 삼아
    모든 UI/내러티브/시스템 메시지는 동일 언어로 고정합니다.
    """

    KO = "ko-KR"
    EN = "en-US"


class Theme(str, Enum):
    """테마 설정."""

    DARK = "dark"
    LIGHT = "light"


class AgentPhase(str, Enum):
    """에이전트 실행 단계 (RULE-008).

    에이전트형 시스템임을 UI로 증명하기 위한 단계 표시.
    """

    PARSE = "parse"
    VALIDATE = "validate"
    PLAN = "plan"
    RESOLVE = "resolve"
    RENDER = "render"
    VERIFY = "verify"
    COMMIT = "commit"


class ValidationBadge(str, Enum):
    """검증 배지 (RULE-008).

    턴 결과에 대한 검증 상태를 표시합니다.
    """

    SCHEMA_OK = "schema_ok"
    SCHEMA_FAIL = "schema_fail"
    ECONOMY_OK = "economy_ok"
    ECONOMY_FAIL = "economy_fail"
    SAFETY_OK = "safety_ok"
    SAFETY_BLOCKED = "safety_blocked"
    CONSISTENCY_OK = "consistency_ok"
    CONSISTENCY_FAIL = "consistency_fail"


class ModelLabel(str, Enum):
    """모델/품질 선택 라벨 (RULE-008).

    프롬프트 노출 없이 "왜 이 선택이었는지"를 사용자 친화 라벨로 표시.
    """

    FAST = "FAST"
    QUALITY = "QUALITY"
    CHEAP = "CHEAP"
    REF = "REF"


class RiskLevel(str, Enum):
    """행동 위험도 수준."""

    LOW = "low"
    MEDIUM = "medium"
    HIGH = "high"


# =============================================================================
# 공통 하위 타입
# =============================================================================

# RULE-009: 좌표는 0~1000 정규화 좌표계 (이미지 이해 bbox 포맷과 호환)
Coordinate = Annotated[int, Field(ge=0, le=1000, description="정규화 좌표 (0~1000)")]


class Box2D(BaseModel):
    """2D 바운딩 박스 (RULE-009).

    좌표는 0~1000 정규화 좌표계이며, bbox는 [ymin, xmin, ymax, xmax] 순서입니다.
    이미지 이해 bbox 포맷과 호환됩니다.

    Attributes:
        ymin: Y 최소값 (상단)
        xmin: X 최소값 (좌측)
        ymax: Y 최대값 (하단)
        xmax: X 최대값 (우측)
    """

    model_config = ConfigDict(extra="forbid")

    ymin: Coordinate
    xmin: Coordinate
    ymax: Coordinate
    xmax: Coordinate


class CurrencyAmount(BaseModel):
    """재화 수량.

    Attributes:
        signal: 기본 재화 (텍스트 턴/이미지 생성/고급 기능에 소비)
        memory_shard: 희귀 재화 (중요 설정 고정, 고해상도 이미지 등에 소비)
    """

    model_config = ConfigDict(extra="forbid")

    signal: Annotated[int, Field(ge=0, description="시그널 (기본 재화, 0 이상)")]
    memory_shard: Annotated[int, Field(ge=0, description="기억 파편 (희귀 재화, 0 이상)")]


# =============================================================================
# TurnInput 관련 타입
# =============================================================================


class ClickInput(BaseModel):
    """클릭 입력 정보.

    화면 오브젝트 클릭 시 전달되는 정보입니다.

    Attributes:
        object_id: 클릭한 오브젝트 ID
        box_2d: 클릭 위치의 바운딩 박스 (선택)
    """

    model_config = ConfigDict(extra="forbid")

    object_id: str = Field(description="클릭한 오브젝트 ID")
    box_2d: Box2D | None = Field(default=None, description="클릭 위치 바운딩 박스 (선택)")


class ClientInfo(BaseModel):
    """클라이언트 정보.

    Attributes:
        viewport_w: 뷰포트 너비 (픽셀)
        viewport_h: 뷰포트 높이 (픽셀)
        theme: 현재 테마 (dark/light)
    """

    model_config = ConfigDict(extra="forbid")

    viewport_w: Annotated[int, Field(gt=0, description="뷰포트 너비 (픽셀)")]
    viewport_h: Annotated[int, Field(gt=0, description="뷰포트 높이 (픽셀)")]
    theme: Theme = Field(default=Theme.DARK, description="현재 테마")


class EconomySnapshot(BaseModel):
    """재화 스냅샷 (클라이언트 → 서버).

    클라이언트가 보유한 현재 재화 상태입니다.
    서버는 이를 검증하고 비용 계산에 사용합니다.

    Attributes:
        signal: 현재 시그널 잔액
        memory_shard: 현재 기억 파편 잔액
    """

    model_config = ConfigDict(extra="forbid")

    signal: Annotated[int, Field(ge=0, description="현재 시그널 잔액 (0 이상)")]
    memory_shard: Annotated[int, Field(ge=0, description="현재 기억 파편 잔액 (0 이상)")]


class TurnInput(BaseModel):
    """턴 입력 (클라이언트 → 서버).

    사용자가 턴을 진행할 때 서버로 전송하는 입력 데이터입니다.

    Attributes:
        language: 요청 언어 (응답도 동일 언어로 고정)
        text: 사용자 자연어 입력
        action_id: 선택한 액션 카드 ID (선택)
        click: 오브젝트 클릭 정보 (선택)
        client: 클라이언트 환경 정보
        economy_snapshot: 현재 재화 상태

    Example:
        >>> input_data = TurnInput(
        ...     language=Language.KO,
        ...     text="문을 열어본다",
        ...     economy_snapshot=EconomySnapshot(signal=100, memory_shard=5),
        ...     client=ClientInfo(viewport_w=1920, viewport_h=1080),
        ... )
    """

    model_config = ConfigDict(extra="forbid")

    language: Language = Field(description="요청 언어 (응답도 동일 언어로 고정)")
    text: str = Field(default="", description="사용자 자연어 입력")
    action_id: str | None = Field(default=None, description="선택한 액션 카드 ID (선택)")
    click: ClickInput | None = Field(default=None, description="오브젝트 클릭 정보 (선택)")
    client: ClientInfo = Field(description="클라이언트 환경 정보")
    economy_snapshot: EconomySnapshot = Field(description="현재 재화 상태")


# =============================================================================
# TurnOutput 관련 타입 - UI
# =============================================================================


class CostEstimate(BaseModel):
    """비용 추정치 (최소/최대 범위)."""

    model_config = ConfigDict(extra="forbid")

    min: CurrencyAmount = Field(description="최소 예상 비용")
    max: CurrencyAmount = Field(description="최대 예상 비용")


class ActionCard(BaseModel):
    """액션 카드 (Action Deck).

    매 턴 AI가 추천하는 행동 카드입니다.
    각 카드에 비용/위험/보상 힌트가 포함됩니다.

    Attributes:
        id: 카드 고유 ID
        label: 카드 라벨 (표시용)
        description: 카드 설명 (선택)
        cost: 예상 비용 (기본)
        cost_estimate: 비용 추정 범위 (선택)
        risk: 위험도
        hint: 예상 결과 힌트 (선택)
        reward_hint: 보상 힌트 (선택)
        enabled: 실행 가능 여부 (서버 판단)
        disabled_reason: 비활성화 사유 (선택)
        is_alternative: 저비용 대안 카드 여부
    """

    model_config = ConfigDict(extra="forbid")

    id: str = Field(description="카드 고유 ID")
    label: str = Field(description="카드 라벨 (표시용)")
    description: str | None = Field(default=None, description="카드 설명 (선택)")
    cost: CurrencyAmount = Field(description="예상 비용 (기본)")
    cost_estimate: CostEstimate | None = Field(default=None, description="비용 추정 범위 (선택)")
    risk: RiskLevel = Field(default=RiskLevel.LOW, description="위험도")
    hint: str | None = Field(default=None, description="예상 결과 힌트 (선택)")
    reward_hint: str | None = Field(default=None, description="보상 힌트 (선택)")
    enabled: bool = Field(default=True, description="실행 가능 여부 (서버 판단)")
    disabled_reason: str | None = Field(default=None, description="비활성화 사유 (선택)")
    is_alternative: bool = Field(default=False, description="저비용 대안 카드 여부")


class SceneObject(BaseModel):
    """장면 오브젝트 (클릭 가능한 핫스팟).

    화면에서 클릭 가능한 오브젝트입니다.
    좌표는 0~1000 정규화 좌표계를 사용합니다 (RULE-009).

    Attributes:
        id: 오브젝트 고유 ID
        label: 오브젝트 라벨 (표시용)
        box_2d: 바운딩 박스 [ymin, xmin, ymax, xmax]
        interaction_hint: 상호작용 힌트 (선택)
    """

    model_config = ConfigDict(extra="forbid")

    id: str = Field(description="오브젝트 고유 ID")
    label: str = Field(description="오브젝트 라벨 (표시용)")
    box_2d: Box2D = Field(description="바운딩 박스")
    interaction_hint: str | None = Field(default=None, description="상호작용 힌트 (선택)")


class ActionDeck(BaseModel):
    """액션 덱 (Q1 결정: ui.action_deck.cards[] 구조).

    매 턴 AI가 제시하는 추천 행동 카드 덱입니다.

    Attributes:
        cards: 액션 카드 목록 (3~6장 권장)
    """

    model_config = ConfigDict(extra="forbid")

    cards: list[ActionCard] = Field(
        default=[],
        min_length=0,
        max_length=10,
        description="액션 카드 목록 (3~6장 권장)",
    )


class UIOutput(BaseModel):
    """UI 출력 데이터.

    AI가 생성한 UI 요소들입니다.
    채팅 버블이 아닌 게임 UI로 표현됩니다 (RULE-002).

    Attributes:
        action_deck: 액션 카드 덱 (Q1 결정: Option A 채택)
        objects: 클릭 가능한 장면 오브젝트 목록
    """

    model_config = ConfigDict(extra="forbid")

    action_deck: ActionDeck = Field(default_factory=ActionDeck, description="액션 카드 덱")
    objects: list[SceneObject] = Field(default=[], description="클릭 가능한 장면 오브젝트 목록")


# =============================================================================
# TurnOutput 관련 타입 - World
# =============================================================================


class MemoryPin(BaseModel):
    """중요 설정 고정 후보.

    사용자가 Memory Shard를 소비해 고정할 수 있는 중요 설정입니다.

    Attributes:
        id: 핀 고유 ID
        content: 고정할 내용
        cost: 고정에 필요한 비용
    """

    model_config = ConfigDict(extra="forbid")

    id: str = Field(description="핀 고유 ID")
    content: str = Field(description="고정할 내용")
    cost: CurrencyAmount = Field(description="고정에 필요한 비용")


class WorldRule(BaseModel):
    """세계 규칙 (Rule Board).

    현재 세계에 적용 중인 물리 법칙이나 메타 규칙입니다.

    Attributes:
        id: 규칙 고유 ID
        label: 규칙 이름
        description: 규칙 상세 설명 (선택)
    """

    model_config = ConfigDict(extra="forbid")

    id: str = Field(description="규칙 고유 ID")
    label: str = Field(description="규칙 이름")
    description: str | None = Field(default=None, description="규칙 상세 설명 (선택)")


class Quest(BaseModel):
    """퀘스트/목표 (Quest Panel).

    플레이어가 달성해야 하는 현재 목표입니다.

    Attributes:
        id: 퀘스트 고유 ID
        label: 퀘스트 이름
        is_completed: 달성 여부
    """

    model_config = ConfigDict(extra="forbid")

    id: str = Field(description="퀘스트 고유 ID")
    label: str = Field(description="퀘스트 이름")
    is_completed: bool = Field(default=False, description="달성 여부")


class WorldDelta(BaseModel):
    """세계 상태 변화 (Q2 결정: Option A - delta 중심).

    이번 턴에서 변경된 세계 상태를 나타냅니다.
    snapshot은 SaveGame에만 저장하고, 매 턴은 delta만 전송합니다.

    Attributes:
        rules_changed: 변경되거나 추가된 규칙 목록
        inventory_added: 추가된 인벤토리 아이템
        inventory_removed: 제거된 인벤토리 아이템
        quests_updated: 업데이트된 퀘스트(목표) 목록
        relationships_changed: 변경된 관계
        memory_pins: 중요 설정 고정 후보
    """

    model_config = ConfigDict(extra="forbid")

    rules_changed: list[WorldRule] = Field(default=[], description="변경된 규칙 목록")
    inventory_added: list[str] = Field(default=[], description="추가된 인벤토리 아이템")
    inventory_removed: list[str] = Field(default=[], description="제거된 인벤토리 아이템")
    quests_updated: list[Quest] = Field(default=[], description="업데이트된 퀘스트/목표 목록")
    relationships_changed: list[str] = Field(default=[], description="변경된 관계")
    memory_pins: list[MemoryPin] = Field(default=[], description="중요 설정 고정 후보")


# =============================================================================
# TurnOutput 관련 타입 - Render
# =============================================================================


class ImageJob(BaseModel):
    """이미지 생성 작업.

    조건부 이미지 생성/편집 요청입니다.
    이미지 생성이 느릴 경우 텍스트 우선 출력 + Lazy Loading을 사용합니다.

    Attributes:
        should_generate: 이미지를 생성해야 하는지
        prompt: 이미지 생성 프롬프트
        model_label: 모델 선택 라벨 (FAST/QUALITY/CHEAP/REF)
        aspect_ratio: 가로세로 비율 (예: "16:9", "1:1")
        image_size: 이미지 크기 (예: "1024x1024")
        reference_image_ids: 참조 이미지 ID 목록 (선택)
    """

    model_config = ConfigDict(extra="forbid")

    should_generate: bool = Field(description="이미지를 생성해야 하는지")
    prompt: str = Field(default="", description="이미지 생성 프롬프트")
    model_label: ModelLabel = Field(default=ModelLabel.FAST, description="모델 선택 라벨")
    aspect_ratio: str = Field(default="16:9", description="가로세로 비율")
    image_size: str = Field(default="1024x1024", description="이미지 크기")
    reference_image_ids: list[str] = Field(default=[], description="참조 이미지 ID 목록 (선택)")


class RenderOutput(BaseModel):
    """렌더링 출력 데이터.

    이미지 생성/편집 관련 정보입니다.

    Attributes:
        image_job: 이미지 생성 작업 (선택)
    """

    model_config = ConfigDict(extra="forbid")

    image_job: ImageJob | None = Field(default=None, description="이미지 생성 작업 (선택)")


# =============================================================================
# TurnOutput 관련 타입 - Economy
# =============================================================================


class EconomyOutput(BaseModel):
    """경제 출력 데이터 (RULE-005).

    이번 턴의 비용과 잔액 정보입니다.
    잔액 음수는 절대 불가 (서버 Hard gate).

    Attributes:
        cost: 이번 턴에 소비된 비용
        balance_after: 소비 후 잔액

    Important:
        - cost와 balance_after는 항상 포함되어야 합니다.
        - balance_after의 signal과 memory_shard는 0 이상이어야 합니다.
    """

    model_config = ConfigDict(extra="forbid")

    cost: CurrencyAmount = Field(description="이번 턴에 소비된 비용")
    balance_after: CurrencyAmount = Field(description="소비 후 잔액")


# =============================================================================
# TurnOutput 관련 타입 - Safety
# =============================================================================


class SafetyOutput(BaseModel):
    """안전 출력 데이터.

    안전 정책 관련 정보입니다.
    차단 시 명시적 메시지와 함께 안전한 대체 결과를 제공합니다.

    Attributes:
        blocked: 안전 정책에 의해 차단되었는지
        message: 차단 시 사용자에게 표시할 메시지 (선택)
    """

    model_config = ConfigDict(extra="forbid")

    blocked: bool = Field(default=False, description="안전 정책에 의해 차단되었는지")
    message: str | None = Field(default=None, description="차단 시 사용자에게 표시할 메시지 (선택)")


# =============================================================================
# TurnOutput 관련 타입 - Agent Console
# =============================================================================


class AgentConsole(BaseModel):
    """에이전트 콘솔 데이터 (RULE-008).

    에이전트형 시스템임을 UI로 증명하기 위한 정보입니다.
    계획/실행/검증/복구의 흔적을 표시합니다.

    Attributes:
        current_phase: 현재 실행 단계
        badges: 검증 배지 목록
        repair_count: 자동 복구 시도 횟수
    """

    model_config = ConfigDict(extra="forbid")

    current_phase: AgentPhase = Field(default=AgentPhase.COMMIT, description="현재 실행 단계")
    badges: list[ValidationBadge] = Field(default=[], description="검증 배지 목록")
    repair_count: Annotated[int, Field(ge=0, description="자동 복구 시도 횟수")] = 0


# =============================================================================
# TurnOutput (메인 응답 스키마)
# =============================================================================


class TurnOutput(BaseModel):
    """턴 출력 (서버 → 클라이언트).

    서버가 턴 처리 후 클라이언트로 반환하는 구조화된 응답입니다.
    Gemini Structured Outputs(JSON Schema)로 강제됩니다.

    Hard Gate 필드 (RULE-003/004/005):
        - economy: cost와 balance_after 필수, 잔액 음수 금지
        - safety: blocked 시 안전한 대체 결과 제공
        - language: 요청 언어와 동일하게 고정 (혼합 출력 금지)

    Attributes:
        language: 응답 언어 (요청과 동일)
        narrative: 내러티브 텍스트 (표시용)
        ui: UI 요소 (액션 덱, 오브젝트)
        world: 세계 상태 변화 (delta 중심)
        render: 렌더링 정보 (이미지 생성 작업)
        economy: 경제 정보 (비용, 잔액)
        safety: 안전 정책 정보
        agent_console: 에이전트 실행 정보 (단계, 배지, 복구 횟수)

    Example:
        >>> output = TurnOutput(
        ...     language=Language.KO,
        ...     narrative="문이 삐걱거리며 열립니다...",
        ...     economy=EconomyOutput(
        ...         cost=CurrencyAmount(signal=5, memory_shard=0),
        ...         balance_after=CurrencyAmount(signal=95, memory_shard=5),
        ...     ),
        ...     safety=SafetyOutput(blocked=False),
        ... )
        >>> schema = TurnOutput.model_json_schema()

    Schema Generation:
        >>> # Gemini Structured Outputs용 JSON Schema 생성
        >>> json_schema = TurnOutput.model_json_schema()
        >>> # response_json_schema 파라미터에 전달
        >>> config = {
        ...     "response_mime_type": "application/json",
        ...     "response_json_schema": json_schema,
        ... }
    """

    model_config = ConfigDict(extra="forbid")

    # 필수 필드 (Hard Gate)
    language: Language = Field(description="응답 언어 (요청과 동일)")
    narrative: str = Field(description="내러티브 텍스트 (표시용)")
    economy: EconomyOutput = Field(description="경제 정보 (비용, 잔액)")
    safety: SafetyOutput = Field(description="안전 정책 정보")

    # UI 관련 필드
    ui: UIOutput = Field(default_factory=UIOutput, description="UI 요소")

    # 세계 상태 필드
    world: WorldDelta = Field(default_factory=WorldDelta, description="세계 상태 변화 (delta)")

    # 렌더링 필드
    render: RenderOutput = Field(default_factory=RenderOutput, description="렌더링 정보")

    # 에이전트 콘솔 필드
    agent_console: AgentConsole = Field(
        default_factory=AgentConsole, description="에이전트 실행 정보"
    )
</file>

<file path="backend/tests/integration/test_turn_streaming.py">
"""Unknown World - /api/turn HTTP Streaming 통합 테스트.

NDJSON 스트리밍 이벤트의 순서, 구조, 데이터 정밀도를 검증합니다.
"""

import json

from fastapi.testclient import TestClient

from unknown_world.main import app
from unknown_world.models.turn import Language, TurnOutput

client = TestClient(app)


def test_turn_streaming_success():
    """정상적인 턴 요청 시 NDJSON 스트림이 올바른 순서로 반환되는지 테스트합니다."""
    payload = {
        "language": "ko-KR",
        "text": "테스트 입력",
        "client": {"viewport_w": 1920, "viewport_h": 1080, "theme": "dark"},
        "economy_snapshot": {"signal": 100, "memory_shard": 5},
    }

    # StreamingResponse 테스트
    response = client.post("/api/turn", json=payload)
    assert response.status_code == 200
    assert response.headers["content-type"] == "application/x-ndjson"

    events = []
    for line in response.iter_lines():
        if line:
            events.append(json.loads(line))

    # 1. 이벤트 존재 여부 확인
    assert len(events) > 0

    # 2. 첫 번째 이벤트는 항상 stage: parse: start 여야 함 (TTFB)
    assert events[0]["type"] == "stage"
    assert events[0]["name"] == "parse"
    assert events[0]["status"] == "start"

    # 3. 단계별 이벤트 순서 확인
    stages = [e["name"] for e in events if e["type"] == "stage" and e["status"] == "start"]
    expected_stages = ["parse", "validate", "plan", "resolve", "render", "verify", "commit"]
    assert stages == expected_stages

    # 4. 배지 이벤트 포함 여부 확인
    badges_events = [e for e in events if e["type"] == "badges"]
    assert len(badges_events) >= 2
    assert "schema_ok" in badges_events[0]["badges"]

    # 5. 최종 결과물 확인
    final_events = [e for e in events if e["type"] == "final"]
    assert len(final_events) == 1

    turn_output_data = final_events[0]["data"]
    # Pydantic 모델로 다시 검증 (RULE-003)
    turn_output = TurnOutput.model_validate(turn_output_data)
    assert turn_output.language == Language.KO
    assert len(turn_output.narrative) > 0


def test_turn_streaming_invalid_input():
    """잘못된 입력 요청 시 에러 이벤트가 스트리밍되는지 테스트합니다."""
    payload = {
        "language": "invalid-lang",  # 잘못된 언어 코드
        "text": "",
    }

    response = client.post("/api/turn", json=payload)
    # 입력 검증 실패 시에도 200 OK 스트림으로 에러를 보낼 수도 있고,
    # 400 Bad Request를 보낼 수도 있음. 현재 구현은 200 OK + type: error 임.
    assert response.status_code == 200

    events = [json.loads(line) for line in response.iter_lines() if line]
    assert any(e["type"] == "error" for e in events)
    assert any(e["code"] == "VALIDATION_ERROR" for e in events)


def test_turn_streaming_deterministic_seed():
    """seed 파라미터 사용 시 결과가 결정적인지 테스트합니다."""
    payload = {
        "language": "en-US",
        "text": "Hello",
        "client": {"viewport_w": 1920, "viewport_h": 1080},
        "economy_snapshot": {"signal": 100, "memory_shard": 5},
    }

    # 동일한 시드로 두 번 요청
    seed = 12345

    def get_final_output(s):
        resp = client.post(f"/api/turn?seed={s}", json=payload)
        events = [json.loads(line) for line in resp.iter_lines() if line]
        return next(e["data"] for e in events if e["type"] == "final")

    output1 = get_final_output(seed)
    output2 = get_final_output(seed)

    assert output1 == output2
    assert output1["language"] == "en-US"


def test_turn_streaming_generation_fallback(monkeypatch):
    """생성 중 ValidationError 발생 시 안전한 폴백이 반환되는지 테스트합니다."""
    from pydantic import ValidationError

    from unknown_world.orchestrator.mock import MockOrchestrator

    def mock_generate_failure(self, turn_input):
        # Pydantic ValidationError를 수동으로 생성하는 것은 복잡하므로
        # 간단한 필드 검증 오류를 시뮬레이션하거나 직접 raise 함
        # 여기서는 테스트를 위해 임의의 필드 누락 등으로 발생한다고 가정
        raise ValidationError.from_exception_data(title="MockError", line_errors=[])

    monkeypatch.setattr(MockOrchestrator, "generate_turn_output", mock_generate_failure)

    payload = {
        "language": "ko-KR",
        "text": "테스트",
        "client": {"viewport_w": 1920, "viewport_h": 1080},
        "economy_snapshot": {"signal": 100, "memory_shard": 5},
    }

    response = client.post("/api/turn", json=payload)
    events = [json.loads(line) for line in response.iter_lines() if line]

    final_event = next(e for e in events if e["type"] == "final")
    turn_output = final_event["data"]

    # 폴백 응답의 특징 확인
    assert turn_output["agent_console"]["badges"] == ["schema_fail"]
    assert turn_output["agent_console"]["repair_count"] == 1
    assert "혼란" in turn_output["narrative"] or "confusion" in turn_output["narrative"]


def test_turn_streaming_repair_loop(monkeypatch):
    """검증 실패 시 repair 이벤트가 스트림에 포함되는지 테스트합니다 (RU-002)."""
    from pydantic import ValidationError

    from unknown_world.orchestrator.mock import MockOrchestrator

    # 첫 번째 호출에서 실패하여 repair 트리거 시뮬레이션
    # (실제 구현에서는 N회 재시도 로직이 turn.py에 있어야 함)
    call_count = 0

    def mock_generate_with_repair(self, turn_input):
        nonlocal call_count
        call_count += 1
        if call_count == 1:
            raise ValidationError.from_exception_data(title="MockSchemaError", line_errors=[])
        return orchestrator_orig_generate(self, turn_input)

    import unknown_world.orchestrator.mock as mock_mod

    orchestrator_orig_generate = mock_mod.MockOrchestrator.generate_turn_output
    monkeypatch.setattr(MockOrchestrator, "generate_turn_output", mock_generate_with_repair)

    payload = {
        "language": "ko-KR",
        "text": "리페어 테스트",
        "client": {"viewport_w": 1920, "viewport_h": 1080},
        "economy_snapshot": {"signal": 100, "memory_shard": 5},
    }

    response = client.post("/api/turn", json=payload)
    events = [json.loads(line) for line in response.iter_lines() if line]

    # RU-002 요구사항: repair 이벤트가 명시적으로 존재해야 함
    repair_events = [e for e in events if e["type"] == "repair"]
    assert len(repair_events) >= 1
    assert "attempt" in repair_events[0]
    assert repair_events[0]["attempt"] == 1
</file>

<file path="backend/tests/unit/test_u034_verification.py">
import json
from pathlib import Path

# 프로젝트 루트 경로 설정 (backend/tests/unit/ 위치 기준)
ROOT_DIR = Path(__file__).parent.parent.parent.parent
SCHEMA_PATH = ROOT_DIR / "vibe/ref/nanobanana-asset-request.schema.json"
GUIDE_PATH = ROOT_DIR / "vibe/ref/nanobanana-mcp.md"


def test_schema_file_exists():
    """스키마 파일이 지정된 위치에 존재하는지 확인"""
    assert SCHEMA_PATH.exists(), f"Schema file not found at {SCHEMA_PATH}"


def test_schema_is_valid_json():
    """스키마 파일이 유효한 JSON 형식인지 확인"""
    with open(SCHEMA_PATH, encoding="utf-8") as f:
        schema = json.load(f)
    assert schema["title"] == "nanobanana mcp Asset Request Schema"


def test_schema_required_properties():
    """계획서에 명시된 필수 필드가 스키마에 정의되어 있는지 확인"""
    with open(SCHEMA_PATH, encoding="utf-8") as f:
        schema = json.load(f)

    properties = schema.get("properties", {})
    required_fields = ["id", "category", "purpose", "size_px", "requires_rembg", "rembg_model"]

    for field in required_fields:
        assert field in properties, f"Required field '{field}' missing in schema properties"


def test_guide_file_exists():
    """가이드 문서 파일이 존재하는지 확인"""
    assert GUIDE_PATH.exists(), f"Guide file not found at {GUIDE_PATH}"


def test_guide_content_completeness():
    """가이드 문서에 필수 섹션(아트 디렉션, 카테고리별 템플릿)이 포함되어 있는지 확인"""
    with open(GUIDE_PATH, encoding="utf-8") as f:
        content = f.read()

    # 계획서 구현 흐름 2단계, 3단계 관련 키워드 검사
    required_keywords = ["아트 디렉션", "스타일", "아이콘", "placeholder", "chrome", "템플릿"]

    missing_keywords = [kw for kw in required_keywords if kw.lower() not in content.lower()]

    # 현재 nanobanana-mcp.md에는 rembg 내용만 있으므로 실패할 가능성이 큼
    assert not missing_keywords, (
        f"Guide document is missing sections for: {', '.join(missing_keywords)}"
    )


def test_schema_rembg_rules():
    """배경 제거(rembg) 관련 강제 규칙(순백 배경)이 스키마/설명에 포함되어 있는지 확인"""
    with open(SCHEMA_PATH, encoding="utf-8") as f:
        schema = json.load(f)

    # background 필드와 requires_rembg 필드 설명 확인
    background_desc = schema["properties"]["background"].get("description", "")
    rembg_desc = schema["properties"]["requires_rembg"].get("description", "")

    assert "solid_white" in str(schema["properties"]["background"].get("enum", [])), (
        "background enum should include solid_white"
    )
    assert "rembg" in background_desc.lower(), "background description should mention rembg"
    assert "solid_white" in rembg_desc.lower(), (
        "requires_rembg description should recommend solid_white"
    )
</file>

<file path="frontend/public/ui/manifest.schema.json">
{
  "$schema": "http://json-schema.org/draft-07/schema#",
  "$id": "https://unknown-world.dev/schemas/ui-asset-manifest.json",
  "title": "UI Asset Manifest",
  "description": "nanobanana mcp로 제작된 UI 에셋의 매니페스트 스키마",
  "type": "object",
  "required": ["version", "assets"],
  "additionalProperties": false,
  "properties": {
    "$schema": {
      "type": "string",
      "description": "JSON Schema 참조"
    },
    "version": {
      "type": "string",
      "pattern": "^\\d+\\.\\d+\\.\\d+$",
      "description": "매니페스트 버전 (SemVer)",
      "examples": ["1.0.0"]
    },
    "generatedAt": {
      "type": "string",
      "format": "date-time",
      "description": "매니페스트 생성 시각 (ISO 8601)"
    },
    "totalBytes": {
      "type": "integer",
      "minimum": 0,
      "description": "모든 에셋의 총 바이트 수"
    },
    "budgetBytes": {
      "type": "integer",
      "minimum": 0,
      "default": 1572864,
      "description": "성능 예산 상한 (기본: 1.5MB = 1572864 bytes)"
    },
    "assets": {
      "type": "array",
      "description": "에셋 목록",
      "items": {
        "$ref": "#/$defs/Asset"
      }
    }
  },
  "$defs": {
    "Asset": {
      "type": "object",
      "required": ["id", "path", "type"],
      "additionalProperties": false,
      "properties": {
        "id": {
          "type": "string",
          "pattern": "^[a-z0-9]+(-[a-z0-9]+)*$",
          "description": "에셋 고유 ID (kebab-case)",
          "examples": ["signal-24", "badge-ok-16", "scene-loading"]
        },
        "path": {
          "type": "string",
          "pattern": "^[a-z0-9-/]+\\.(png|webp|svg)$",
          "description": "ui/ 디렉토리 기준 상대 경로",
          "examples": ["icons/signal-24.png", "placeholders/scene-loading.webp"]
        },
        "type": {
          "type": "string",
          "enum": ["icon", "placeholder", "chrome"],
          "description": "에셋 유형"
        },
        "size": {
          "type": "integer",
          "enum": [16, 24, 32, 64, 128, 256, 512],
          "description": "픽셀 사이즈 (아이콘용)"
        },
        "width": {
          "type": "integer",
          "minimum": 1,
          "description": "가로 픽셀 (placeholder/chrome용)"
        },
        "height": {
          "type": "integer",
          "minimum": 1,
          "description": "세로 픽셀 (placeholder/chrome용)"
        },
        "fallback": {
          "type": "string",
          "maxLength": 10,
          "description": "로딩 실패 시 대체 이모지/텍스트",
          "examples": ["📡", "⚠️", "OK"]
        },
        "usedIn": {
          "type": "array",
          "items": {
            "type": "string"
          },
          "description": "사용처 컴포넌트 목록",
          "examples": [["EconomyHUD", "AgentConsole"]]
        },
        "bytes": {
          "type": "integer",
          "minimum": 0,
          "description": "파일 크기 (bytes)"
        },
        "format": {
          "type": "string",
          "enum": ["png", "webp", "svg"],
          "description": "파일 포맷"
        },
        "retina": {
          "type": "boolean",
          "default": false,
          "description": "@2x Retina 버전 존재 여부"
        },
        "description": {
          "type": "string",
          "maxLength": 200,
          "description": "에셋 설명"
        },
        "createdAt": {
          "type": "string",
          "format": "date-time",
          "description": "생성 시각 (ISO 8601)"
        },
        "promptHash": {
          "type": "string",
          "pattern": "^[a-f0-9]{8}$",
          "description": "생성 프롬프트 해시 (재현성, 8자)"
        },
        "notes": {
          "type": "string",
          "maxLength": 500,
          "description": "에셋 관련 메모 (생성 도구, 배경 제거, 최적화 등 QA 관련 기록)"
        }
      }
    }
  }
}
</file>

<file path="frontend/tsconfig.json">
{
  "compilerOptions": {
    "target": "ES2022",
    "useDefineForClassFields": true,
    "lib": ["ES2022", "DOM", "DOM.Iterable"],
    "module": "ESNext",
    "skipLibCheck": true,

    /* Bundler mode */
    "moduleResolution": "Bundler",
    "allowImportingTsExtensions": true,
    "isolatedModules": true,
    "moduleDetection": "force",
    "noEmit": true,
    "jsx": "react-jsx",

    /* Linting (엄격 모드) */
    "strict": true,
    "noUnusedLocals": true,
    "noUnusedParameters": true,
    "noFallthroughCasesInSwitch": true,
    "noUncheckedSideEffectImports": true
  },
  "include": ["src"],
  "references": [{ "path": "./tsconfig.node.json" }]
}
</file>

<file path="backend/src/unknown_world/__init__.py">
"""Unknown World - Backend Package

This is the main package for the Unknown World backend.
Architecture: FastAPI + Pydantic + SSE streaming

Reference:
- vibe/tech-stack.md (Python 3.14, FastAPI 0.128.0, Pydantic 2.12.5)
- vibe/prd.md (Agent-based Game Master Engine)
"""

__version__ = "0.1.0"
</file>

<file path="backend/src/unknown_world/main.py">
"""Unknown World - FastAPI 애플리케이션 엔트리포인트

이 모듈은 Unknown World 백엔드의 FastAPI 앱을 정의합니다.
MVP 단계에서는 기본 헬스체크와 개발용 CORS 설정만 포함합니다.

실행 방법:
    cd backend
    uv sync
    uv run uvicorn unknown_world.main:app --reload --port 8011

참조:
    - vibe/tech-stack.md (버전 SSOT)
    - vibe/prd.md (에이전트형 게임 엔진 요구사항)
    - .cursor/rules/20-backend-orchestrator.mdc (SSE/검증/복구 규칙)
"""

from typing import Literal

from fastapi import FastAPI
from fastapi.middleware.cors import CORSMiddleware
from pydantic import BaseModel

from unknown_world import __version__
from unknown_world.api import turn_router

# =============================================================================
# FastAPI 앱 인스턴스
# =============================================================================

app = FastAPI(
    title="Unknown World API",
    description="Gemini 기반 에이전트형 게임 엔진 오케스트레이터",
    version=__version__,
    docs_url="/docs",
    redoc_url="/redoc",
)

# =============================================================================
# CORS 설정 (개발 환경용)
# =============================================================================
# PRD 요구: 로컬 개발에서 프론트와 통신할 수 있도록 CORS 기본 정책 준비
# RULE-011: 프론트엔드는 8001~8010 포트 사용
# 주의: 프로덕션에서는 MMP 단계에서 엄격한 정책으로 변경해야 함

ALLOWED_ORIGINS = [
    # 프론트엔드 개발 서버 포트 범위 (RULE-011: 8001~8010)
    *[f"http://localhost:{port}" for port in range(8001, 8011)],
    *[f"http://127.0.0.1:{port}" for port in range(8001, 8011)],
]

app.add_middleware(
    CORSMiddleware,
    allow_origins=ALLOWED_ORIGINS,
    allow_credentials=True,
    allow_methods=["*"],
    allow_headers=["*"],
)

# =============================================================================
# 라우터 등록
# =============================================================================

# U-007: /api/turn HTTP Streaming 엔드포인트
app.include_router(turn_router)


# =============================================================================
# 응답 스키마 (Pydantic)
# =============================================================================


class HealthResponse(BaseModel):
    """헬스체크 응답 스키마.

    Attributes:
        status: 서버 상태 ("ok" 또는 "degraded")
        version: 백엔드 버전
        service: 서비스 이름
    """

    status: Literal["ok", "degraded"]
    version: str
    service: str


# =============================================================================
# 라우트 정의
# =============================================================================


@app.get("/health", response_model=HealthResponse, tags=["System"])
async def health_check() -> HealthResponse:
    """서버 헬스체크 엔드포인트.

    서버가 정상적으로 작동 중인지 확인합니다.
    이 엔드포인트는 로드밸런서, 모니터링 시스템, 클라이언트 연결 확인에 사용됩니다.

    Returns:
        HealthResponse: 서버 상태 정보
    """
    return HealthResponse(
        status="ok",
        version=__version__,
        service="unknown-world-backend",
    )


@app.get("/", tags=["System"])
async def root() -> dict[str, str]:
    """루트 엔드포인트.

    API 정보를 간략히 안내합니다.

    Returns:
        dict: 기본 안내 메시지
    """
    return {
        "message": "Unknown World API",
        "docs": "/docs",
        "health": "/health",
    }
</file>

<file path="backend/src/unknown_world/orchestrator/mock.py">
"""Unknown World - 모의 Orchestrator.

실모델(Gemini) 없이 프론트엔드 개발/데모를 지속할 수 있도록
결정적(seed 기반) TurnOutput을 생성하는 모의 Orchestrator입니다.

설계 원칙:
    - RULE-004: 검증 실패 시 안전한 폴백 제공
    - RULE-005: 재화 인바리언트 (잔액 음수 금지)
    - RULE-008: 단계/배지 가시화
    - RULE-009: 좌표 규약 (0~1000, bbox [ymin,xmin,ymax,xmax])

참조:
    - vibe/unit-plans/U-007[Mvp].md
    - .cursor/rules/20-backend-orchestrator.mdc
"""

import random

from unknown_world.models.turn import (
    ActionCard,
    ActionDeck,
    AgentConsole,
    AgentPhase,
    Box2D,
    CurrencyAmount,
    EconomyOutput,
    ImageJob,
    Language,
    MemoryPin,
    ModelLabel,
    Quest,
    RenderOutput,
    RiskLevel,
    SafetyOutput,
    SceneObject,
    TurnInput,
    TurnOutput,
    UIOutput,
    ValidationBadge,
    WorldDelta,
    WorldRule,
)

# =============================================================================
# 모의 데이터 생성 헬퍼
# =============================================================================

# 한국어 내러티브 템플릿
KO_NARRATIVES = [
    "어둠 속에서 희미한 빛이 새어나옵니다. 오래된 문이 삐걱거리며 열리고, 그 너머로 알 수 없는 세계가 펼쳐집니다.",
    "발걸음 소리가 텅 빈 복도에 메아리칩니다. 벽에 걸린 초상화들의 눈이 당신을 따라 움직이는 것 같습니다.",
    "갑자기 바닥이 흔들리며, 벽에서 고대의 문자들이 빛나기 시작합니다. 무언가가 깨어나고 있습니다.",
    "안개가 걷히자, 거대한 탑이 모습을 드러냅니다. 탑 꼭대기에서 이상한 빛이 깜빡이고 있습니다.",
    "낡은 책장을 밀자, 숨겨진 통로가 나타났습니다. 통로 끝에서 기묘한 노래가 들려옵니다.",
]

# 영어 내러티브 템플릿
EN_NARRATIVES = [
    "A faint light seeps through the darkness. An ancient door creaks open, revealing an unknown world beyond.",
    "Footsteps echo through the empty corridor. The eyes of the portraits on the walls seem to follow you.",
    "Suddenly, the ground shakes and ancient runes on the walls begin to glow. Something is awakening.",
    "As the fog lifts, a massive tower reveals itself. A strange light flickers at its peak.",
    "Pushing aside the old bookshelf, you discover a hidden passage. An eerie song emanates from its depths.",
]

# 한국어 액션 카드 템플릿
KO_ACTION_CARDS = [
    {"label": "문을 열어본다", "description": "조심스럽게 문을 열어 안을 살펴본다"},
    {"label": "주변을 탐색한다", "description": "주변에 유용한 물건이 있는지 찾아본다"},
    {"label": "뒤로 물러선다", "description": "위험을 피해 안전한 곳으로 물러선다"},
    {"label": "말을 걸어본다", "description": "상대방에게 조심스럽게 말을 건다"},
    {"label": "숨어서 지켜본다", "description": "은신하여 상황을 관찰한다"},
    {"label": "공격한다", "description": "위협에 맞서 공격을 시도한다"},
]

# 영어 액션 카드 템플릿
EN_ACTION_CARDS = [
    {"label": "Open the door", "description": "Carefully open the door and look inside"},
    {"label": "Search the area", "description": "Look for useful items nearby"},
    {"label": "Step back", "description": "Retreat to a safe place to avoid danger"},
    {"label": "Speak to them", "description": "Cautiously initiate conversation"},
    {"label": "Hide and observe", "description": "Conceal yourself and watch the situation"},
    {"label": "Attack", "description": "Confront the threat with an attack"},
]

# 장면 오브젝트 템플릿
SCENE_OBJECTS_KO = [
    {"label": "낡은 문", "hint": "클릭하여 열어볼 수 있습니다"},
    {"label": "빛나는 보석", "hint": "수집할 수 있을 것 같습니다"},
    {"label": "수상한 상자", "hint": "무언가 들어있을 수 있습니다"},
    {"label": "벽의 스위치", "hint": "작동시킬 수 있습니다"},
]

SCENE_OBJECTS_EN = [
    {"label": "Old door", "hint": "Click to open"},
    {"label": "Glowing gem", "hint": "It looks collectible"},
    {"label": "Suspicious chest", "hint": "Something might be inside"},
    {"label": "Wall switch", "hint": "Can be activated"},
]


def _generate_random_box(rng: random.Random) -> Box2D:
    """랜덤 바운딩 박스 생성 (0~1000 좌표계)."""
    ymin = rng.randint(0, 700)
    xmin = rng.randint(0, 700)
    ymax = ymin + rng.randint(50, 250)
    xmax = xmin + rng.randint(50, 250)
    # 범위 보정
    ymax = min(ymax, 1000)
    xmax = min(xmax, 1000)
    return Box2D(ymin=ymin, xmin=xmin, ymax=ymax, xmax=xmax)


# =============================================================================
# MockOrchestrator 클래스
# =============================================================================


class MockOrchestrator:
    """모의 Orchestrator.

    실모델(Gemini) 없이 TurnOutput을 생성하는 모의 오케스트레이터입니다.
    seed 기반으로 결정적(재현 가능)인 결과를 생성합니다.

    Attributes:
        seed: 랜덤 시드 (재현성 보장)

    Example:
        >>> orchestrator = MockOrchestrator(seed=42)
        >>> turn_input = TurnInput(
        ...     language=Language.KO,
        ...     text="문을 열어본다",
        ...     client=ClientInfo(viewport_w=1920, viewport_h=1080),
        ...     economy_snapshot=EconomySnapshot(signal=100, memory_shard=5),
        ... )
        >>> output = orchestrator.generate_turn_output(turn_input)
    """

    # 단계 목록 (PRD 예시)
    PHASES = [
        AgentPhase.PARSE,
        AgentPhase.VALIDATE,
        AgentPhase.PLAN,
        AgentPhase.RESOLVE,
        AgentPhase.RENDER,
        AgentPhase.VERIFY,
        AgentPhase.COMMIT,
    ]

    def __init__(self, seed: int | None = None) -> None:
        """MockOrchestrator 초기화.

        Args:
            seed: 랜덤 시드. None이면 랜덤하게 생성.
        """
        self.seed = seed if seed is not None else random.randint(0, 2**32 - 1)
        self._rng = random.Random(self.seed)

    def generate_turn_output(self, turn_input: TurnInput) -> TurnOutput:
        """TurnInput을 받아 TurnOutput을 생성합니다.

        Args:
            turn_input: 사용자 입력

        Returns:
            TurnOutput: 모의 턴 결과
        """
        is_korean = turn_input.language == Language.KO

        # 내러티브 생성
        narratives = KO_NARRATIVES if is_korean else EN_NARRATIVES
        narrative = self._rng.choice(narratives)

        # 사용자 텍스트가 있으면 반영
        if turn_input.text:
            prefix = (
                f'당신은 "{turn_input.text}"라고 말했습니다. '
                if is_korean
                else f'You said "{turn_input.text}". '
            )
            narrative = prefix + narrative

        # 액션 덱 생성 (3~6장)
        action_templates = KO_ACTION_CARDS if is_korean else EN_ACTION_CARDS
        num_cards = self._rng.randint(3, 6)
        selected_templates = self._rng.sample(
            action_templates, min(num_cards, len(action_templates))
        )

        action_cards: list[ActionCard] = []
        for i, template in enumerate(selected_templates):
            cost_signal = self._rng.randint(1, 10)
            cost_shard = 1 if self._rng.random() < 0.2 else 0  # 20% 확률로 shard 소비

            action_cards.append(
                ActionCard(
                    id=f"action_{i + 1}",
                    label=template["label"],
                    description=template["description"],
                    cost=CurrencyAmount(signal=cost_signal, memory_shard=cost_shard),
                    risk=self._rng.choice(list(RiskLevel)),
                    hint=None,
                )
            )

        action_deck = ActionDeck(cards=action_cards)

        # 장면 오브젝트 생성 (1~3개)
        object_templates = SCENE_OBJECTS_KO if is_korean else SCENE_OBJECTS_EN
        num_objects = self._rng.randint(1, 3)
        selected_objects = self._rng.sample(
            object_templates, min(num_objects, len(object_templates))
        )

        scene_objects: list[SceneObject] = []
        for i, template in enumerate(selected_objects):
            scene_objects.append(
                SceneObject(
                    id=f"obj_{i + 1}",
                    label=template["label"],
                    box_2d=_generate_random_box(self._rng),
                    interaction_hint=template["hint"],
                )
            )

        ui_output = UIOutput(action_deck=action_deck, objects=scene_objects)

        # 세계 상태 변화 (delta)
        world_delta = self._generate_world_delta(is_korean)

        # 렌더링 출력 (이미지 생성은 선택적)
        should_generate_image = self._rng.random() < 0.3  # 30% 확률로 이미지 생성
        render_output = RenderOutput(
            image_job=ImageJob(
                should_generate=should_generate_image,
                prompt="A mysterious dungeon scene" if should_generate_image else "",
                model_label=ModelLabel.FAST,
                aspect_ratio="16:9",
                image_size="1024x576",
            )
            if should_generate_image
            else None
        )

        # 경제 출력 (비용 계산)
        turn_cost = CurrencyAmount(
            signal=self._rng.randint(1, 5),
            memory_shard=0,
        )

        # 잔액 계산 (음수 방지 - RULE-005)
        balance_signal = max(0, turn_input.economy_snapshot.signal - turn_cost.signal)
        balance_shard = max(0, turn_input.economy_snapshot.memory_shard - turn_cost.memory_shard)

        economy_output = EconomyOutput(
            cost=turn_cost,
            balance_after=CurrencyAmount(signal=balance_signal, memory_shard=balance_shard),
        )

        # 안전 출력
        safety_output = SafetyOutput(blocked=False, message=None)

        # 에이전트 콘솔
        agent_console = AgentConsole(
            current_phase=AgentPhase.COMMIT,
            badges=[
                ValidationBadge.SCHEMA_OK,
                ValidationBadge.ECONOMY_OK,
                ValidationBadge.SAFETY_OK,
                ValidationBadge.CONSISTENCY_OK,
            ],
            repair_count=0,
        )

        return TurnOutput(
            language=turn_input.language,
            narrative=narrative,
            ui=ui_output,
            world=world_delta,
            render=render_output,
            economy=economy_output,
            safety=safety_output,
            agent_console=agent_console,
        )

    def _generate_world_delta(self, is_korean: bool) -> WorldDelta:
        """세계 상태 변화 생성."""
        # 규칙 변경 (20% 확률)
        rules_changed: list[WorldRule] = []
        if self._rng.random() < 0.2:
            rules_changed.append(
                WorldRule(
                    id="rule_gravity",
                    label="중력 반전" if is_korean else "Gravity Inversion",
                    description=(
                        "이 구역에서는 중력이 반대로 작용합니다"
                        if is_korean
                        else "Gravity works in reverse in this area"
                    ),
                )
            )

        # 인벤토리 추가 (30% 확률)
        inventory_added: list[str] = []
        if self._rng.random() < 0.3:
            items_ko = ["낡은 열쇠", "신비로운 구슬", "고대의 두루마리"]
            items_en = ["Old Key", "Mysterious Orb", "Ancient Scroll"]
            items = items_ko if is_korean else items_en
            inventory_added.append(self._rng.choice(items))

        # 퀘스트 업데이트 (25% 확률)
        quests_updated: list[Quest] = []
        if self._rng.random() < 0.25:
            quests_updated.append(
                Quest(
                    id="quest_explore",
                    label="미지의 영역 탐험" if is_korean else "Explore Unknown Territory",
                    is_completed=self._rng.random() < 0.3,
                )
            )

        # 메모리 핀 (15% 확률)
        memory_pins: list[MemoryPin] = []
        if self._rng.random() < 0.15:
            memory_pins.append(
                MemoryPin(
                    id="pin_1",
                    content="이 장소의 이름은 '잊혀진 성소'"
                    if is_korean
                    else "This place is called 'Forgotten Sanctuary'",
                    cost=CurrencyAmount(signal=0, memory_shard=1),
                )
            )

        return WorldDelta(
            rules_changed=rules_changed,
            inventory_added=inventory_added,
            inventory_removed=[],
            quests_updated=quests_updated,
            relationships_changed=[],
            memory_pins=memory_pins,
        )

    def create_safe_fallback(
        self,
        language: Language,
        error_message: str | None = None,
        economy_snapshot: CurrencyAmount | None = None,
    ) -> TurnOutput:
        """안전한 폴백 TurnOutput 생성 (RULE-004, RU-002-S1).

        스키마 검증 실패 시 반환할 안전한 기본 응답입니다.
        폴백 시 economy.balance_after는 입력 스냅샷을 그대로 유지합니다 (비용 0, 잔액 변화 없음).

        Args:
            language: 응답 언어
            error_message: 에러 메시지 (내부용, UI에 노출하지 않음)
            economy_snapshot: 요청 직전 재화 스냅샷 (폴백 시 잔액 유지용)

        Returns:
            TurnOutput: 안전한 폴백 응답
        """
        is_korean = language == Language.KO

        narrative = (
            "잠시 혼란이 있었습니다. 다시 시도해주세요."
            if is_korean
            else "There was a momentary confusion. Please try again."
        )

        # RU-002-S1: 폴백 시 입력 스냅샷 그대로 유지 (비용 0, 잔액 변화 없음)
        balance_after = (
            economy_snapshot
            if economy_snapshot is not None
            else CurrencyAmount(signal=100, memory_shard=5)  # 기본값 (스냅샷 없을 때만)
        )

        return TurnOutput(
            language=language,
            narrative=narrative,
            ui=UIOutput(action_deck=ActionDeck(cards=[]), objects=[]),
            world=WorldDelta(),
            render=RenderOutput(image_job=None),
            economy=EconomyOutput(
                cost=CurrencyAmount(signal=0, memory_shard=0),
                balance_after=balance_after,
            ),
            safety=SafetyOutput(blocked=False, message=None),
            agent_console=AgentConsole(
                current_phase=AgentPhase.COMMIT,
                badges=[ValidationBadge.SCHEMA_FAIL],  # 실패 표시
                repair_count=1,  # 복구 시도 횟수
            ),
        )
</file>

<file path="shared/schemas/turn/turn_input.schema.json">
{
  "$schema": "http://json-schema.org/draft-07/schema#",
  "$id": "https://unknown-world.dev/schemas/turn/turn_input.schema.json",
  "title": "TurnInput",
  "description": "Client → Server 턴 요청 스키마 (MVP). PRD 8.7절 기반.",
  "type": "object",
  "properties": {
    "language": {
      "type": "string",
      "enum": ["ko-KR", "en-US"],
      "description": "게임 언어 설정 (ko-KR 또는 en-US)"
    },
    "text": {
      "type": "string",
      "description": "사용자 입력 (자연어)"
    },
    "click": {
      "type": ["object", "null"],
      "description": "클릭된 오브젝트 정보 (선택)",
      "properties": {
        "object_id": {
          "type": "string",
          "description": "클릭된 오브젝트 ID"
        },
        "box_2d": {
          "type": ["array", "null"],
          "description": "bbox [ymin, xmin, ymax, xmax] (0~1000 정규화)",
          "items": {
            "type": "integer",
            "minimum": 0,
            "maximum": 1000
          },
          "minItems": 4,
          "maxItems": 4
        }
      },
      "required": ["object_id"]
    },
    "client": {
      "type": "object",
      "description": "클라이언트 환경 정보",
      "properties": {
        "viewport_w": {
          "type": "integer",
          "description": "뷰포트 너비 (px)"
        },
        "viewport_h": {
          "type": "integer",
          "description": "뷰포트 높이 (px)"
        },
        "theme": {
          "type": "string",
          "enum": ["dark", "light"],
          "description": "테마 설정"
        }
      },
      "required": ["viewport_w", "viewport_h", "theme"]
    },
    "economy_snapshot": {
      "type": "object",
      "description": "현재 재화 상태 스냅샷",
      "properties": {
        "signal": {
          "type": "integer",
          "minimum": 0,
          "description": "Signal 재화 잔액"
        },
        "memory_shard": {
          "type": "integer",
          "minimum": 0,
          "description": "Memory Shard 재화 잔액"
        }
      },
      "required": ["signal", "memory_shard"]
    }
  },
  "required": ["language", "text", "client", "economy_snapshot"],
  "additionalProperties": false
}
</file>

<file path="backend/src/unknown_world/api/turn.py">
"""Unknown World - /api/turn HTTP Streaming 엔드포인트.

POST 요청을 받아 NDJSON(라인 단위 JSON) 스트리밍으로 턴 결과를 반환합니다.

설계 원칙:
    - RULE-003: 구조화 출력(JSON Schema) 우선 + Pydantic 검증
    - RULE-004: 검증 실패 시 Repair loop + 안전한 폴백
    - RULE-005: 재화 인바리언트 (잔액 음수 금지)
    - RULE-007: 프롬프트/내부 추론 노출 금지
    - RULE-008: 단계/배지 가시화, TTFB 2초 목표

스트림 이벤트 타입:
    - stage: 단계 진행 상태 (Parse→Validate→Plan→Resolve→Render→Verify→Commit)
    - badges: 검증 배지 목록
    - narrative_delta: 내러티브 텍스트 조각 (타자 효과용)
    - final: 최종 TurnOutput
    - error: 에러 발생 시

참조:
    - vibe/unit-plans/U-007[Mvp].md
    - .cursor/rules/20-backend-orchestrator.mdc
"""

import asyncio
import time
from collections.abc import AsyncGenerator
from typing import Any, cast

from fastapi import APIRouter, Request
from fastapi.responses import StreamingResponse
from pydantic import ValidationError

from unknown_world.api.turn_stream_events import (
    BadgesEvent,
    ErrorEvent,
    FinalEvent,
    NarrativeDeltaEvent,
    RepairEvent,
    StageEvent,
    StageStatus,
    StreamEventType,
    serialize_event,
)
from unknown_world.models.turn import (
    AgentPhase,
    CurrencyAmount,
    Language,
    TurnInput,
    ValidationBadge,
)
from unknown_world.orchestrator.mock import MockOrchestrator

# =============================================================================
# 라우터 정의
# =============================================================================

router = APIRouter(prefix="/api", tags=["Turn"])

# 단계 목록 (PRD 예시)
ORCHESTRATOR_PHASES = [
    AgentPhase.PARSE,
    AgentPhase.VALIDATE,
    AgentPhase.PLAN,
    AgentPhase.RESOLVE,
    AgentPhase.RENDER,
    AgentPhase.VERIFY,
    AgentPhase.COMMIT,
]

# 모의 단계 지연 시간 (ms) - 실제 처리 시뮬레이션
PHASE_DELAYS_MS = {
    AgentPhase.PARSE: 50,
    AgentPhase.VALIDATE: 30,
    AgentPhase.PLAN: 100,
    AgentPhase.RESOLVE: 150,
    AgentPhase.RENDER: 80,
    AgentPhase.VERIFY: 40,
    AgentPhase.COMMIT: 20,
}


async def _stream_turn_events(
    turn_input: TurnInput, seed: int | None = None
) -> AsyncGenerator[str]:
    """턴 처리 이벤트를 NDJSON 스트림으로 생성합니다.

    Args:
        turn_input: 사용자 턴 입력
        seed: 모의 Orchestrator 시드 (재현성 보장)

    Yields:
        str: NDJSON 라인
    """
    orchestrator = MockOrchestrator(seed=seed)
    collected_badges: list[str] = []

    # Phase 1: Parse (TTFB를 위해 즉시 시작 이벤트 전송)
    yield serialize_event(
        StageEvent(
            type=StreamEventType.STAGE, name=AgentPhase.PARSE.value, status=StageStatus.START
        ).model_dump()
    )

    # 각 단계별 처리 시뮬레이션
    for phase in ORCHESTRATOR_PHASES:
        # 단계 시작
        if phase != AgentPhase.PARSE:  # Parse는 이미 전송함
            yield serialize_event(
                StageEvent(
                    type=StreamEventType.STAGE, name=phase.value, status=StageStatus.START
                ).model_dump()
            )

        # 모의 처리 지연
        delay_ms = PHASE_DELAYS_MS.get(phase, 50)
        await asyncio.sleep(delay_ms / 1000.0)

        # 단계 완료
        yield serialize_event(
            StageEvent(
                type=StreamEventType.STAGE, name=phase.value, status=StageStatus.COMPLETE
            ).model_dump()
        )

        # 배지 추가 (Validate, Verify 단계에서)
        if phase == AgentPhase.VALIDATE:
            collected_badges.append(ValidationBadge.SCHEMA_OK.value)
            collected_badges.append(ValidationBadge.ECONOMY_OK.value)
            yield serialize_event(
                BadgesEvent(
                    type=StreamEventType.BADGES, badges=collected_badges.copy()
                ).model_dump()
            )
        elif phase == AgentPhase.VERIFY:
            collected_badges.append(ValidationBadge.SAFETY_OK.value)
            collected_badges.append(ValidationBadge.CONSISTENCY_OK.value)
            yield serialize_event(
                BadgesEvent(
                    type=StreamEventType.BADGES, badges=collected_badges.copy()
                ).model_dump()
            )

    # TurnOutput 생성 (Repair 루프 포함 - RULE-004)
    max_repair_attempts = 3
    repair_attempt = 0
    turn_output = None

    try:
        while repair_attempt <= max_repair_attempts:
            try:
                # 0회차는 정상 시도, 1회차부터는 repair
                if repair_attempt > 0:
                    yield serialize_event(
                        RepairEvent(
                            type=StreamEventType.REPAIR,
                            attempt=repair_attempt,
                            message="검증 실패로 인해 다시 시도 중입니다..."
                            if turn_input.language == Language.KO
                            else "Retrying due to validation failure",
                        ).model_dump()
                    )

                turn_output = orchestrator.generate_turn_output(turn_input)
                break  # 성공 시 루프 탈출

            except ValidationError as e:
                repair_attempt += 1
                if repair_attempt > max_repair_attempts:
                    # 최종 실패 시 폴백 (RULE-004)
                    turn_output = orchestrator.create_safe_fallback(
                        language=turn_input.language,
                        error_message=str(e),
                        economy_snapshot=CurrencyAmount(
                            signal=turn_input.economy_snapshot.signal,
                            memory_shard=turn_input.economy_snapshot.memory_shard,
                        ),
                    )
                    break
                # 루프 계속 진행 (재시도)
                continue

        if turn_output:
            # 내러티브 델타 스트리밍 (타자 효과)
            narrative = turn_output.narrative
            chunk_size = 20  # 한 번에 전송할 글자 수
            for i in range(0, len(narrative), chunk_size):
                chunk = narrative[i : i + chunk_size]
                yield serialize_event(
                    NarrativeDeltaEvent(
                        type=StreamEventType.NARRATIVE_DELTA, text=chunk
                    ).model_dump()
                )
                await asyncio.sleep(0.02)  # 타자 효과 딜레이

            # 최종 TurnOutput 전송
            yield serialize_event(
                FinalEvent(type=StreamEventType.FINAL, data=turn_output).model_dump(mode="json")
            )

    except Exception:
        # RU-002-S1: 예외 발생 시 error + final(폴백) 순서로 송출
        # (프롬프트/내부 추론 노출 금지 - RULE-007)
        yield serialize_event(
            ErrorEvent(
                type=StreamEventType.ERROR,
                message="처리 중 오류가 발생했습니다"
                if turn_input.language == Language.KO
                else "An error occurred during processing",
                code="INTERNAL_ERROR",
            ).model_dump()
        )
        # 항상 final(폴백)로 종료 - 스트림 종료 인바리언트 (RULE-004)
        fallback = orchestrator.create_safe_fallback(
            language=turn_input.language,
            error_message="Internal error",
            economy_snapshot=CurrencyAmount(
                signal=turn_input.economy_snapshot.signal,
                memory_shard=turn_input.economy_snapshot.memory_shard,
            ),
        )
        yield serialize_event(
            FinalEvent(type=StreamEventType.FINAL, data=fallback).model_dump(mode="json")
        )


async def _validate_and_parse_input(request: Request) -> TurnInput | dict[str, Any]:
    """요청 본문을 TurnInput으로 검증 및 파싱합니다.

    Returns:
        TurnInput 또는 에러 정보 dict (language, economy_snapshot 포함)
    """
    body: dict[str, Any] | None = None
    try:
        body = await request.json()
        return TurnInput.model_validate(body)
    except ValidationError as e:
        # RU-002-S1: 입력 검증 실패 시에도 language/economy 추출 시도
        raw_language = body.get("language") if isinstance(body, dict) else None
        raw_economy = body.get("economy_snapshot") if isinstance(body, dict) else None
        return {
            "error": True,
            "message": "Invalid input",
            "details": e.errors(),
            "language": raw_language if raw_language in ("ko-KR", "en-US") else "ko-KR",
            "economy_snapshot": raw_economy,
        }
    except Exception:
        return {
            "error": True,
            "message": "Failed to parse request body",
            "details": None,
            "language": "ko-KR",
            "economy_snapshot": None,
        }


@router.post(
    "/turn",
    response_class=StreamingResponse,
    summary="턴 처리 (HTTP Streaming)",
    description="""
턴 입력을 받아 NDJSON 스트리밍으로 결과를 반환합니다.

**스트림 이벤트 타입**:
- `stage`: 처리 단계 진행 상태
- `badges`: 검증 배지 목록
- `narrative_delta`: 내러티브 텍스트 조각 (타자 효과)
- `final`: 최종 TurnOutput
- `error`: 에러 발생 시

**예시 요청**:
```json
{
    "language": "ko-KR",
    "text": "문을 열어본다",
    "client": {"viewport_w": 1920, "viewport_h": 1080, "theme": "dark"},
    "economy_snapshot": {"signal": 100, "memory_shard": 5}
}
```
""",
    responses={
        200: {
            "description": "NDJSON 스트림",
            "content": {
                "application/x-ndjson": {
                    "example": '{"type":"stage","name":"parse","status":"start"}\n'
                }
            },
        },
        400: {"description": "잘못된 요청"},
    },
)
async def turn_stream(request: Request) -> StreamingResponse:
    """턴 처리 HTTP Streaming 엔드포인트.

    POST 요청으로 TurnInput을 받아 NDJSON 스트리밍으로 결과를 반환합니다.
    TTFB를 줄이기 위해 첫 stage 이벤트를 즉시 전송합니다.

    Args:
        request: FastAPI Request 객체

    Returns:
        StreamingResponse: NDJSON 스트림
    """
    # 입력 검증
    parse_result = await _validate_and_parse_input(request)

    if isinstance(parse_result, dict) and parse_result.get("error"):
        # RU-002-S1: 입력 검증 실패 시에도 error + final(폴백) 순서로 송출
        error_language = parse_result.get("language", "ko-KR")
        error_economy = parse_result.get("economy_snapshot")

        # economy_snapshot이 유효한지 확인
        economy_snapshot: CurrencyAmount | None = None
        if isinstance(error_economy, dict):
            try:
                # 명시적 타입 캐스팅으로 Pyright 경고 해소
                eco_dict = cast(dict[str, Any], error_economy)
                economy_snapshot = CurrencyAmount(
                    signal=int(eco_dict.get("signal", 100)),
                    memory_shard=int(eco_dict.get("memory_shard", 5)),
                )
            except (ValueError, TypeError):
                economy_snapshot = None

        async def error_stream() -> AsyncGenerator[str]:
            # 에러 이벤트 송출
            yield serialize_event(
                ErrorEvent(
                    type=StreamEventType.ERROR,
                    message=parse_result.get("message", "Invalid input"),
                    code="VALIDATION_ERROR",
                ).model_dump()
            )
            # 항상 final(폴백)로 종료 - 스트림 종료 인바리언트 (RULE-004)
            fallback_orchestrator = MockOrchestrator()
            fallback = fallback_orchestrator.create_safe_fallback(
                language=Language.KO if error_language == "ko-KR" else Language.EN,
                error_message="Validation error",
                economy_snapshot=economy_snapshot,
            )
            yield serialize_event(
                FinalEvent(type=StreamEventType.FINAL, data=fallback).model_dump(mode="json")
            )

        return StreamingResponse(
            error_stream(),
            media_type="application/x-ndjson",
            headers={
                "Cache-Control": "no-cache",
                "X-Accel-Buffering": "no",  # nginx 버퍼링 비활성화
            },
        )

    turn_input: TurnInput = parse_result  # type: ignore[assignment]

    # 시드 추출 (쿼리 파라미터에서, 테스트/재현용)
    seed_param = request.query_params.get("seed")
    seed = int(seed_param) if seed_param else None

    # NDJSON 스트리밍 응답
    return StreamingResponse(
        _stream_turn_events(turn_input, seed=seed),
        media_type="application/x-ndjson",
        headers={
            "Cache-Control": "no-cache",
            "X-Accel-Buffering": "no",  # nginx 버퍼링 비활성화
            "X-Request-Time": str(int(time.time() * 1000)),
        },
    )
</file>

<file path="package.json">
{
  "name": "unknown-world",
  "version": "0.1.0",
  "private": true,
  "description": "Unknown World - Gemini 기반 에이전트형 게임 엔진",
  "packageManager": "pnpm@10.27.0",
  "engines": {
    "node": "24.12.0"
  },
  "scripts": {
    "kill": "pnpm kill:port",
    "kill:port": "npx --yes kill-port 8001 8002 8003 8004 8005 8006 8007 8008 8009 8010 8011 8012 8013 8014 8015 8016 8017 8018 8019 8020",
    "kill:front": "npx --yes kill-port 8001 8002 8003 8004 8005 8006 8007 8008 8009 8010",
    "kill:back": "npx --yes kill-port 8011 8012 8013 8014 8015 8016 8017 8018 8019 8020",
    "dev:back": "cd backend && uv run uvicorn unknown_world.main:app --reload --port 8011",
    "dev:front": "pnpm -C frontend dev"
  }
}
</file>

<file path="shared/schemas/turn/turn_output.schema.json">
{
  "$defs": {
    "ActionCard": {
      "additionalProperties": false,
      "description": "액션 카드 (Action Deck).\n\n매 턴 AI가 추천하는 행동 카드입니다.\n각 카드에 비용/위험/보상 힌트가 포함됩니다.\n\nAttributes:\n    id: 카드 고유 ID\n    label: 카드 라벨 (표시용)\n    description: 카드 설명 (선택)\n    cost: 예상 비용\n    risk: 위험도\n    hint: 예상 결과 힌트 (선택)",
      "properties": {
        "id": {
          "description": "카드 고유 ID",
          "title": "Id",
          "type": "string"
        },
        "label": {
          "description": "카드 라벨 (표시용)",
          "title": "Label",
          "type": "string"
        },
        "description": {
          "anyOf": [
            {
              "type": "string"
            },
            {
              "type": "null"
            }
          ],
          "default": null,
          "description": "카드 설명 (선택)",
          "title": "Description"
        },
        "cost": {
          "$ref": "#/$defs/CurrencyAmount",
          "description": "예상 비용"
        },
        "risk": {
          "$ref": "#/$defs/RiskLevel",
          "default": "low",
          "description": "위험도"
        },
        "hint": {
          "anyOf": [
            {
              "type": "string"
            },
            {
              "type": "null"
            }
          ],
          "default": null,
          "description": "예상 결과 힌트 (선택)",
          "title": "Hint"
        }
      },
      "required": [
        "id",
        "label",
        "cost"
      ],
      "title": "ActionCard",
      "type": "object"
    },
    "ActionDeck": {
      "additionalProperties": false,
      "description": "액션 덱 (Q1 결정: ui.action_deck.cards[] 구조).\n\n매 턴 AI가 제시하는 추천 행동 카드 덱입니다.\n\nAttributes:\n    cards: 액션 카드 목록 (3~6장 권장)",
      "properties": {
        "cards": {
          "default": [],
          "description": "액션 카드 목록 (3~6장 권장)",
          "items": {
            "$ref": "#/$defs/ActionCard"
          },
          "maxItems": 10,
          "minItems": 0,
          "title": "Cards",
          "type": "array"
        }
      },
      "title": "ActionDeck",
      "type": "object"
    },
    "AgentConsole": {
      "additionalProperties": false,
      "description": "에이전트 콘솔 데이터 (RULE-008).\n\n에이전트형 시스템임을 UI로 증명하기 위한 정보입니다.\n계획/실행/검증/복구의 흔적을 표시합니다.\n\nAttributes:\n    current_phase: 현재 실행 단계\n    badges: 검증 배지 목록\n    repair_count: 자동 복구 시도 횟수",
      "properties": {
        "current_phase": {
          "$ref": "#/$defs/AgentPhase",
          "default": "commit",
          "description": "현재 실행 단계"
        },
        "badges": {
          "default": [],
          "description": "검증 배지 목록",
          "items": {
            "$ref": "#/$defs/ValidationBadge"
          },
          "title": "Badges",
          "type": "array"
        },
        "repair_count": {
          "default": 0,
          "description": "자동 복구 시도 횟수",
          "minimum": 0,
          "title": "Repair Count",
          "type": "integer"
        }
      },
      "title": "AgentConsole",
      "type": "object"
    },
    "AgentPhase": {
      "description": "에이전트 실행 단계 (RULE-008).\n\n에이전트형 시스템임을 UI로 증명하기 위한 단계 표시.",
      "enum": [
        "parse",
        "validate",
        "plan",
        "resolve",
        "render",
        "verify",
        "commit"
      ],
      "title": "AgentPhase",
      "type": "string"
    },
    "Box2D": {
      "additionalProperties": false,
      "description": "2D 바운딩 박스 (RULE-009).\n\n좌표는 0~1000 정규화 좌표계이며, bbox는 [ymin, xmin, ymax, xmax] 순서입니다.\n이미지 이해 bbox 포맷과 호환됩니다.\n\nAttributes:\n    ymin: Y 최소값 (상단)\n    xmin: X 최소값 (좌측)\n    ymax: Y 최대값 (하단)\n    xmax: X 최대값 (우측)",
      "properties": {
        "ymin": {
          "description": "정규화 좌표 (0~1000)",
          "maximum": 1000,
          "minimum": 0,
          "title": "Ymin",
          "type": "integer"
        },
        "xmin": {
          "description": "정규화 좌표 (0~1000)",
          "maximum": 1000,
          "minimum": 0,
          "title": "Xmin",
          "type": "integer"
        },
        "ymax": {
          "description": "정규화 좌표 (0~1000)",
          "maximum": 1000,
          "minimum": 0,
          "title": "Ymax",
          "type": "integer"
        },
        "xmax": {
          "description": "정규화 좌표 (0~1000)",
          "maximum": 1000,
          "minimum": 0,
          "title": "Xmax",
          "type": "integer"
        }
      },
      "required": [
        "ymin",
        "xmin",
        "ymax",
        "xmax"
      ],
      "title": "Box2D",
      "type": "object"
    },
    "CurrencyAmount": {
      "additionalProperties": false,
      "description": "재화 수량.\n\nAttributes:\n    signal: 기본 재화 (텍스트 턴/이미지 생성/고급 기능에 소비)\n    memory_shard: 희귀 재화 (중요 설정 고정, 고해상도 이미지 등에 소비)",
      "properties": {
        "signal": {
          "description": "시그널 (기본 재화, 0 이상)",
          "minimum": 0,
          "title": "Signal",
          "type": "integer"
        },
        "memory_shard": {
          "description": "기억 파편 (희귀 재화, 0 이상)",
          "minimum": 0,
          "title": "Memory Shard",
          "type": "integer"
        }
      },
      "required": [
        "signal",
        "memory_shard"
      ],
      "title": "CurrencyAmount",
      "type": "object"
    },
    "EconomyOutput": {
      "additionalProperties": false,
      "description": "경제 출력 데이터 (RULE-005).\n\n이번 턴의 비용과 잔액 정보입니다.\n잔액 음수는 절대 불가 (서버 Hard gate).\n\nAttributes:\n    cost: 이번 턴에 소비된 비용\n    balance_after: 소비 후 잔액\n\nImportant:\n    - cost와 balance_after는 항상 포함되어야 합니다.\n    - balance_after의 signal과 memory_shard는 0 이상이어야 합니다.",
      "properties": {
        "cost": {
          "$ref": "#/$defs/CurrencyAmount",
          "description": "이번 턴에 소비된 비용"
        },
        "balance_after": {
          "$ref": "#/$defs/CurrencyAmount",
          "description": "소비 후 잔액"
        }
      },
      "required": [
        "cost",
        "balance_after"
      ],
      "title": "EconomyOutput",
      "type": "object"
    },
    "ImageJob": {
      "additionalProperties": false,
      "description": "이미지 생성 작업.\n\n조건부 이미지 생성/편집 요청입니다.\n이미지 생성이 느릴 경우 텍스트 우선 출력 + Lazy Loading을 사용합니다.\n\nAttributes:\n    should_generate: 이미지를 생성해야 하는지\n    prompt: 이미지 생성 프롬프트\n    model_label: 모델 선택 라벨 (FAST/QUALITY/CHEAP/REF)\n    aspect_ratio: 가로세로 비율 (예: \"16:9\", \"1:1\")\n    image_size: 이미지 크기 (예: \"1024x1024\")\n    reference_image_ids: 참조 이미지 ID 목록 (선택)",
      "properties": {
        "should_generate": {
          "description": "이미지를 생성해야 하는지",
          "title": "Should Generate",
          "type": "boolean"
        },
        "prompt": {
          "default": "",
          "description": "이미지 생성 프롬프트",
          "title": "Prompt",
          "type": "string"
        },
        "model_label": {
          "$ref": "#/$defs/ModelLabel",
          "default": "FAST",
          "description": "모델 선택 라벨"
        },
        "aspect_ratio": {
          "default": "16:9",
          "description": "가로세로 비율",
          "title": "Aspect Ratio",
          "type": "string"
        },
        "image_size": {
          "default": "1024x1024",
          "description": "이미지 크기",
          "title": "Image Size",
          "type": "string"
        },
        "reference_image_ids": {
          "default": [],
          "description": "참조 이미지 ID 목록 (선택)",
          "items": {
            "type": "string"
          },
          "title": "Reference Image Ids",
          "type": "array"
        }
      },
      "required": [
        "should_generate"
      ],
      "title": "ImageJob",
      "type": "object"
    },
    "Language": {
      "description": "지원 언어 (RULE-006).\n\nko/en 혼합 출력 금지. TurnInput.language를 SSOT로 삼아\n모든 UI/내러티브/시스템 메시지는 동일 언어로 고정합니다.",
      "enum": [
        "ko-KR",
        "en-US"
      ],
      "title": "Language",
      "type": "string"
    },
    "MemoryPin": {
      "additionalProperties": false,
      "description": "중요 설정 고정 후보.\n\n사용자가 Memory Shard를 소비해 고정할 수 있는 중요 설정입니다.\n\nAttributes:\n    id: 핀 고유 ID\n    content: 고정할 내용\n    cost: 고정에 필요한 비용",
      "properties": {
        "id": {
          "description": "핀 고유 ID",
          "title": "Id",
          "type": "string"
        },
        "content": {
          "description": "고정할 내용",
          "title": "Content",
          "type": "string"
        },
        "cost": {
          "$ref": "#/$defs/CurrencyAmount",
          "description": "고정에 필요한 비용"
        }
      },
      "required": [
        "id",
        "content",
        "cost"
      ],
      "title": "MemoryPin",
      "type": "object"
    },
    "ModelLabel": {
      "description": "모델/품질 선택 라벨 (RULE-008).\n\n프롬프트 노출 없이 \"왜 이 선택이었는지\"를 사용자 친화 라벨로 표시.",
      "enum": [
        "FAST",
        "QUALITY",
        "CHEAP",
        "REF"
      ],
      "title": "ModelLabel",
      "type": "string"
    },
    "Quest": {
      "additionalProperties": false,
      "description": "퀘스트/목표 (Quest Panel).\n\n플레이어가 달성해야 하는 현재 목표입니다.\n\nAttributes:\n    id: 퀘스트 고유 ID\n    label: 퀘스트 이름\n    is_completed: 달성 여부",
      "properties": {
        "id": {
          "description": "퀘스트 고유 ID",
          "title": "Id",
          "type": "string"
        },
        "label": {
          "description": "퀘스트 이름",
          "title": "Label",
          "type": "string"
        },
        "is_completed": {
          "default": false,
          "description": "달성 여부",
          "title": "Is Completed",
          "type": "boolean"
        }
      },
      "required": [
        "id",
        "label"
      ],
      "title": "Quest",
      "type": "object"
    },
    "RenderOutput": {
      "additionalProperties": false,
      "description": "렌더링 출력 데이터.\n\n이미지 생성/편집 관련 정보입니다.\n\nAttributes:\n    image_job: 이미지 생성 작업 (선택)",
      "properties": {
        "image_job": {
          "anyOf": [
            {
              "$ref": "#/$defs/ImageJob"
            },
            {
              "type": "null"
            }
          ],
          "default": null,
          "description": "이미지 생성 작업 (선택)"
        }
      },
      "title": "RenderOutput",
      "type": "object"
    },
    "RiskLevel": {
      "description": "행동 위험도 수준.",
      "enum": [
        "low",
        "medium",
        "high"
      ],
      "title": "RiskLevel",
      "type": "string"
    },
    "SafetyOutput": {
      "additionalProperties": false,
      "description": "안전 출력 데이터.\n\n안전 정책 관련 정보입니다.\n차단 시 명시적 메시지와 함께 안전한 대체 결과를 제공합니다.\n\nAttributes:\n    blocked: 안전 정책에 의해 차단되었는지\n    message: 차단 시 사용자에게 표시할 메시지 (선택)",
      "properties": {
        "blocked": {
          "default": false,
          "description": "안전 정책에 의해 차단되었는지",
          "title": "Blocked",
          "type": "boolean"
        },
        "message": {
          "anyOf": [
            {
              "type": "string"
            },
            {
              "type": "null"
            }
          ],
          "default": null,
          "description": "차단 시 사용자에게 표시할 메시지 (선택)",
          "title": "Message"
        }
      },
      "title": "SafetyOutput",
      "type": "object"
    },
    "SceneObject": {
      "additionalProperties": false,
      "description": "장면 오브젝트 (클릭 가능한 핫스팟).\n\n화면에서 클릭 가능한 오브젝트입니다.\n좌표는 0~1000 정규화 좌표계를 사용합니다 (RULE-009).\n\nAttributes:\n    id: 오브젝트 고유 ID\n    label: 오브젝트 라벨 (표시용)\n    box_2d: 바운딩 박스 [ymin, xmin, ymax, xmax]\n    interaction_hint: 상호작용 힌트 (선택)",
      "properties": {
        "id": {
          "description": "오브젝트 고유 ID",
          "title": "Id",
          "type": "string"
        },
        "label": {
          "description": "오브젝트 라벨 (표시용)",
          "title": "Label",
          "type": "string"
        },
        "box_2d": {
          "$ref": "#/$defs/Box2D",
          "description": "바운딩 박스"
        },
        "interaction_hint": {
          "anyOf": [
            {
              "type": "string"
            },
            {
              "type": "null"
            }
          ],
          "default": null,
          "description": "상호작용 힌트 (선택)",
          "title": "Interaction Hint"
        }
      },
      "required": [
        "id",
        "label",
        "box_2d"
      ],
      "title": "SceneObject",
      "type": "object"
    },
    "SceneOutput": {
      "additionalProperties": false,
      "description": "Scene 표시 정보 (RU-003-T1: Scene 이미지 SSOT).\n\nTurnOutput에서 Scene Canvas에 표시할 이미지 정보를 제공합니다.\nimage_url이 존재하면 SceneCanvas는 'scene' 상태로 전환됩니다.\nimage_url이 없으면 'default' 상태를 유지합니다.\n\nAttributes:\n    image_url: Scene 이미지 URL (존재 시 scene 상태로 전환)\n    alt_text: 이미지 대체 텍스트 (접근성용, 선택)",
      "properties": {
        "image_url": {
          "anyOf": [
            {
              "type": "string"
            },
            {
              "type": "null"
            }
          ],
          "default": null,
          "description": "Scene 이미지 URL (존재 시 scene 상태로 전환)",
          "title": "Image Url"
        },
        "alt_text": {
          "anyOf": [
            {
              "type": "string"
            },
            {
              "type": "null"
            }
          ],
          "default": null,
          "description": "이미지 대체 텍스트 (접근성용, 선택)",
          "title": "Alt Text"
        }
      },
      "title": "SceneOutput",
      "type": "object"
    },
    "UIOutput": {
      "additionalProperties": false,
      "description": "UI 출력 데이터.\n\nAI가 생성한 UI 요소들입니다.\n채팅 버블이 아닌 게임 UI로 표현됩니다 (RULE-002).\n\nRU-003-T1: scene 필드 추가 - Scene Canvas의 이미지 표시 정보 SSOT.\n\nAttributes:\n    action_deck: 액션 카드 덱 (Q1 결정: Option A 채택)\n    objects: 클릭 가능한 장면 오브젝트 목록\n    scene: Scene 표시 정보 (RU-003-T1)",
      "properties": {
        "action_deck": {
          "$ref": "#/$defs/ActionDeck",
          "description": "액션 카드 덱"
        },
        "objects": {
          "default": [],
          "description": "클릭 가능한 장면 오브젝트 목록",
          "items": {
            "$ref": "#/$defs/SceneObject"
          },
          "title": "Objects",
          "type": "array"
        },
        "scene": {
          "$ref": "#/$defs/SceneOutput",
          "default": {
            "image_url": null,
            "alt_text": null
          },
          "description": "Scene 표시 정보 (RU-003-T1)"
        }
      },
      "title": "UIOutput",
      "type": "object"
    },
    "ValidationBadge": {
      "description": "검증 배지 (RULE-008).\n\n턴 결과에 대한 검증 상태를 표시합니다.",
      "enum": [
        "schema_ok",
        "schema_fail",
        "economy_ok",
        "economy_fail",
        "safety_ok",
        "safety_blocked",
        "consistency_ok",
        "consistency_fail"
      ],
      "title": "ValidationBadge",
      "type": "string"
    },
    "WorldDelta": {
      "additionalProperties": false,
      "description": "세계 상태 변화 (Q2 결정: Option A - delta 중심).\n\n이번 턴에서 변경된 세계 상태를 나타냅니다.\nsnapshot은 SaveGame에만 저장하고, 매 턴은 delta만 전송합니다.\n\nAttributes:\n    rules_changed: 변경되거나 추가된 규칙 목록\n    inventory_added: 추가된 인벤토리 아이템\n    inventory_removed: 제거된 인벤토리 아이템\n    quests_updated: 업데이트된 퀘스트(목표) 목록\n    relationships_changed: 변경된 관계\n    memory_pins: 중요 설정 고정 후보",
      "properties": {
        "rules_changed": {
          "default": [],
          "description": "변경된 규칙 목록",
          "items": {
            "$ref": "#/$defs/WorldRule"
          },
          "title": "Rules Changed",
          "type": "array"
        },
        "inventory_added": {
          "default": [],
          "description": "추가된 인벤토리 아이템",
          "items": {
            "type": "string"
          },
          "title": "Inventory Added",
          "type": "array"
        },
        "inventory_removed": {
          "default": [],
          "description": "제거된 인벤토리 아이템",
          "items": {
            "type": "string"
          },
          "title": "Inventory Removed",
          "type": "array"
        },
        "quests_updated": {
          "default": [],
          "description": "업데이트된 퀘스트/목표 목록",
          "items": {
            "$ref": "#/$defs/Quest"
          },
          "title": "Quests Updated",
          "type": "array"
        },
        "relationships_changed": {
          "default": [],
          "description": "변경된 관계",
          "items": {
            "type": "string"
          },
          "title": "Relationships Changed",
          "type": "array"
        },
        "memory_pins": {
          "default": [],
          "description": "중요 설정 고정 후보",
          "items": {
            "$ref": "#/$defs/MemoryPin"
          },
          "title": "Memory Pins",
          "type": "array"
        }
      },
      "title": "WorldDelta",
      "type": "object"
    },
    "WorldRule": {
      "additionalProperties": false,
      "description": "세계 규칙 (Rule Board).\n\n현재 세계에 적용 중인 물리 법칙이나 메타 규칙입니다.\n\nAttributes:\n    id: 규칙 고유 ID\n    label: 규칙 이름\n    description: 규칙 상세 설명 (선택)",
      "properties": {
        "id": {
          "description": "규칙 고유 ID",
          "title": "Id",
          "type": "string"
        },
        "label": {
          "description": "규칙 이름",
          "title": "Label",
          "type": "string"
        },
        "description": {
          "anyOf": [
            {
              "type": "string"
            },
            {
              "type": "null"
            }
          ],
          "default": null,
          "description": "규칙 상세 설명 (선택)",
          "title": "Description"
        }
      },
      "required": [
        "id",
        "label"
      ],
      "title": "WorldRule",
      "type": "object"
    }
  },
  "additionalProperties": false,
  "description": "턴 출력 (서버 → 클라이언트).\n\n서버가 턴 처리 후 클라이언트로 반환하는 구조화된 응답입니다.\nGemini Structured Outputs(JSON Schema)로 강제됩니다.\n\nHard Gate 필드 (RULE-003/004/005):\n    - economy: cost와 balance_after 필수, 잔액 음수 금지\n    - safety: blocked 시 안전한 대체 결과 제공\n    - language: 요청 언어와 동일하게 고정 (혼합 출력 금지)\n\nAttributes:\n    language: 응답 언어 (요청과 동일)\n    narrative: 내러티브 텍스트 (표시용)\n    ui: UI 요소 (액션 덱, 오브젝트)\n    world: 세계 상태 변화 (delta 중심)\n    render: 렌더링 정보 (이미지 생성 작업)\n    economy: 경제 정보 (비용, 잔액)\n    safety: 안전 정책 정보\n    agent_console: 에이전트 실행 정보 (단계, 배지, 복구 횟수)\n\nExample:\n    >>> output = TurnOutput(\n    ...     language=Language.KO,\n    ...     narrative=\"문이 삐걱거리며 열립니다...\",\n    ...     economy=EconomyOutput(\n    ...         cost=CurrencyAmount(signal=5, memory_shard=0),\n    ...         balance_after=CurrencyAmount(signal=95, memory_shard=5),\n    ...     ),\n    ...     safety=SafetyOutput(blocked=False),\n    ... )\n    >>> schema = TurnOutput.model_json_schema()\n\nSchema Generation:\n    >>> # Gemini Structured Outputs용 JSON Schema 생성\n    >>> json_schema = TurnOutput.model_json_schema()\n    >>> # response_json_schema 파라미터에 전달\n    >>> config = {\n    ...     \"response_mime_type\": \"application/json\",\n    ...     \"response_json_schema\": json_schema,\n    ... }",
  "properties": {
    "language": {
      "$ref": "#/$defs/Language",
      "description": "응답 언어 (요청과 동일)"
    },
    "narrative": {
      "description": "내러티브 텍스트 (표시용)",
      "title": "Narrative",
      "type": "string"
    },
    "economy": {
      "$ref": "#/$defs/EconomyOutput",
      "description": "경제 정보 (비용, 잔액)"
    },
    "safety": {
      "$ref": "#/$defs/SafetyOutput",
      "description": "안전 정책 정보"
    },
    "ui": {
      "$ref": "#/$defs/UIOutput",
      "description": "UI 요소"
    },
    "world": {
      "$ref": "#/$defs/WorldDelta",
      "description": "세계 상태 변화 (delta)"
    },
    "render": {
      "$ref": "#/$defs/RenderOutput",
      "description": "렌더링 정보"
    },
    "agent_console": {
      "$ref": "#/$defs/AgentConsole",
      "description": "에이전트 실행 정보"
    }
  },
  "required": [
    "language",
    "narrative",
    "economy",
    "safety"
  ],
  "title": "TurnOutput",
  "type": "object"
}
</file>

<file path="backend/pyproject.toml">
# backend/pyproject.toml
# SSOT: vibe/tech-stack.md (버전 기준일: 2026-01-01)

[build-system]
requires = ["hatchling"]
build-backend = "hatchling.build"

[project]
name = "unknown-world-backend"
version = "0.1.0"
description = "Unknown World Backend - Gemini 기반 에이전트형 게임 엔진"
requires-python = ">=3.14"
dependencies = [
    "fastapi==0.128.0",
    "uvicorn[standard]==0.40.0",
    "pydantic==2.12.5",
    "google-genai==1.56.0",
    "google-cloud-aiplatform==1.132.0",
    "google-cloud-storage==3.7.0",
    "python-dotenv>=1.2.1",
]

[tool.hatch.build.targets.wheel]
packages = ["src/unknown_world"]

[dependency-groups]
dev = [
    "ruff==0.14.10",
    "pyright==1.1.407",
    "pytest==9.0.2",
    "httpx==0.28.1",
    "jsonschema>=4.26.0",
    "pytest-asyncio>=1.3.0",
    "pytest-cov>=7.0.0",
]

[tool.ruff]
line-length = 100
target-version = "py314"
extend-exclude = [
    "__pycache__",
    ".ruff_cache",
    ".venv",
    "venv",
    "dist",
    "build",
]

[tool.ruff.lint]
select = [
    "E",      # pycodestyle errors
    "W",      # pycodestyle warnings
    "F",      # pyflakes
    "I",      # isort
    "UP",     # pyupgrade
    "B",      # flake8-bugbear
    "C4",     # flake8-comprehensions
    "SIM",    # flake8-simplify
]
ignore = [
    "E501",   # line too long (handled by formatter)
]

[tool.ruff.format]
quote-style = "double"
indent-style = "space"

[tool.pyright]
pythonVersion = "3.14"
typeCheckingMode = "strict"
include = ["src"]
</file>

<file path="frontend/public/ui/manifest.json">
{
  "$schema": "./manifest.schema.json",
  "version": "1.4.0",
  "generatedAt": "2026-01-14T14:55:00Z",
  "totalBytes": 570867,
  "budgetBytes": 1572864,
  "assets": [
    {
      "id": "signal-24",
      "path": "icons/signal-24.png",
      "type": "icon",
      "size": 24,
      "fallback": "⚡",
      "usedIn": ["EconomyHUD"],
      "bytes": 1573,
      "notes": "U-038: v2 재생성, nanobanana mcp(픽셀아트), rembg(birefnet-general), ImageMagick 최적화"
    },
    {
      "id": "signal-16",
      "path": "icons/signal-16.png",
      "type": "icon",
      "size": 16,
      "fallback": "⚡",
      "usedIn": ["ActionDeck"],
      "bytes": 1012,
      "notes": "U-038: v2 재생성, nanobanana mcp(픽셀아트), rembg(birefnet-general), ImageMagick 최적화"
    },
    {
      "id": "shard-24",
      "path": "icons/shard-24.png",
      "type": "icon",
      "size": 24,
      "fallback": "💎",
      "usedIn": ["EconomyHUD"],
      "bytes": 1362,
      "notes": "U-038: v2 재생성, nanobanana mcp(픽셀아트), rembg(birefnet-general), ImageMagick 최적화"
    },
    {
      "id": "shard-16",
      "path": "icons/shard-16.png",
      "type": "icon",
      "size": 16,
      "fallback": "💎",
      "usedIn": ["ActionDeck"],
      "bytes": 1147,
      "notes": "U-038: shard-24에서 리사이즈, 16px 최적화"
    },
    {
      "id": "badge-ok-24",
      "path": "icons/badge-ok-24.png",
      "type": "icon",
      "size": 24,
      "fallback": "✓",
      "usedIn": ["AgentConsole"],
      "bytes": 1461,
      "notes": "U-038: v2 재생성, nanobanana mcp(픽셀아트), rembg(birefnet-general), ImageMagick 최적화"
    },
    {
      "id": "badge-ok-16",
      "path": "icons/badge-ok-16.png",
      "type": "icon",
      "size": 16,
      "fallback": "✓",
      "usedIn": [],
      "bytes": 1096,
      "notes": "U-038: v2 재생성, nanobanana mcp(픽셀아트), rembg(birefnet-general), ImageMagick 최적화"
    },
    {
      "id": "badge-fail-24",
      "path": "icons/badge-fail-24.png",
      "type": "icon",
      "size": 24,
      "fallback": "✗",
      "usedIn": ["AgentConsole"],
      "bytes": 2006,
      "notes": "U-038: v2 재생성, nanobanana mcp(픽셀아트), rembg(birefnet-general), ImageMagick 최적화"
    },
    {
      "id": "risk-medium-24",
      "path": "icons/risk-medium-24.png",
      "type": "icon",
      "size": 24,
      "fallback": "⚠",
      "usedIn": [],
      "bytes": 1594,
      "notes": "U-038: 24px 페어 보강, nanobanana mcp 생성"
    },
    {
      "id": "risk-medium-16",
      "path": "icons/risk-medium-16.png",
      "type": "icon",
      "size": 16,
      "fallback": "⚠",
      "usedIn": ["ActionDeck"],
      "bytes": 1256,
      "notes": "U-038: v2 재생성, nanobanana mcp(픽셀아트), rembg(birefnet-general), ImageMagick 최적화"
    },
    {
      "id": "risk-low-24",
      "path": "icons/risk-low-24.png",
      "type": "icon",
      "size": 24,
      "fallback": "✓",
      "usedIn": [],
      "bytes": 1838,
      "notes": "U-038: v2 재생성, nanobanana mcp(픽셀아트), rembg(birefnet-general), ImageMagick 최적화"
    },
    {
      "id": "risk-low-16",
      "path": "icons/risk-low-16.png",
      "type": "icon",
      "size": 16,
      "fallback": "✓",
      "usedIn": ["ActionDeck"],
      "bytes": 1331,
      "notes": "U-038: v2 재생성, nanobanana mcp(픽셀아트), rembg(birefnet-general), ImageMagick 최적화"
    },
    {
      "id": "risk-high-24",
      "path": "icons/risk-high-24.png",
      "type": "icon",
      "size": 24,
      "fallback": "⚠",
      "usedIn": [],
      "bytes": 1737,
      "notes": "U-038: v2 재생성, nanobanana mcp(픽셀아트), rembg(birefnet-general), ImageMagick 최적화"
    },
    {
      "id": "risk-high-16",
      "path": "icons/risk-high-16.png",
      "type": "icon",
      "size": 16,
      "fallback": "⚠",
      "usedIn": ["ActionDeck"],
      "bytes": 1227,
      "notes": "U-038: v2 재생성, nanobanana mcp(픽셀아트), rembg(birefnet-general), ImageMagick 최적화"
    },
    {
      "id": "status-online-16",
      "path": "icons/status-online-16.png",
      "type": "icon",
      "size": 16,
      "fallback": "●",
      "usedIn": [],
      "bytes": 1375,
      "notes": "U-038: v2 재생성, nanobanana mcp(픽셀아트), rembg(birefnet-general), ImageMagick 최적화"
    },
    {
      "id": "scene-placeholder-default",
      "path": "placeholders/scene-placeholder-default.png",
      "type": "placeholder",
      "fallback": "[SCENE]",
      "usedIn": ["SceneCanvas"],
      "bytes": 261407,
      "notes": "nanobanana mcp 생성, 레트로 터미널 스타일"
    },
    {
      "id": "scene-loading",
      "path": "placeholders/scene-loading.webp",
      "type": "placeholder",
      "fallback": "⏳",
      "usedIn": ["SceneCanvas"],
      "bytes": 47850,
      "notes": "U-031: 로딩 상태 placeholder, nanobanana mcp 생성, ImageMagick(magick) 최적화"
    },
    {
      "id": "scene-offline",
      "path": "placeholders/scene-offline.webp",
      "type": "placeholder",
      "fallback": "🔌",
      "usedIn": ["SceneCanvas"],
      "bytes": 44658,
      "notes": "U-031: 오프라인 상태 placeholder, nanobanana mcp 생성, ImageMagick(magick) 최적화"
    },
    {
      "id": "scene-blocked",
      "path": "placeholders/scene-blocked.webp",
      "type": "placeholder",
      "fallback": "🚫",
      "usedIn": ["SceneCanvas"],
      "bytes": 17318,
      "notes": "U-031: 차단 상태 placeholder, nanobanana mcp 생성, ImageMagick(magick) 최적화"
    },
    {
      "id": "scene-low-signal",
      "path": "placeholders/scene-low-signal.webp",
      "type": "placeholder",
      "fallback": "📉",
      "usedIn": ["SceneCanvas"],
      "bytes": 68454,
      "notes": "U-031: 저신호 상태 placeholder, nanobanana mcp 생성, ImageMagick(magick) 최적화"
    },
    {
      "id": "panel-corner-br",
      "path": "chrome/panel-corner-br.png",
      "type": "chrome",
      "fallback": "",
      "usedIn": ["PanelHeader"],
      "bytes": 1899,
      "notes": "U-032: 패널 코너 장식, nanobanana mcp 생성, rembg 배경 제거, ImageMagick 최적화(48x48), CSS transform으로 4방향 적용"
    },
    {
      "id": "card-frame",
      "path": "chrome/card-frame.png",
      "type": "chrome",
      "fallback": "",
      "usedIn": ["ActionCard"],
      "bytes": 9101,
      "notes": "U-032: 액션 카드 프레임, nanobanana mcp 생성, rembg 배경 제거, ImageMagick 최적화(160x80)"
    },
    {
      "id": "scanner-frame",
      "path": "chrome/scanner-frame.png",
      "type": "chrome",
      "fallback": "",
      "usedIn": ["Scanner"],
      "bytes": 100165,
      "notes": "U-032: 스캐너 슬롯 프레임, nanobanana mcp 생성, rembg(birefnet-general) 배경 제거, ImageMagick 최적화(346x200) 완료"
    }
  ]
}
</file>

<file path="frontend/package.json">
{
  "name": "unknown-world-frontend",
  "private": true,
  "version": "0.0.0",
  "type": "module",
  "packageManager": "pnpm@10.27.0",
  "scripts": {
    "dev": "vite",
    "build": "tsc -b && vite build",
    "preview": "vite preview",
    "format": "prettier . --write",
    "format:check": "prettier . --check",
    "lint": "eslint .",
    "lint:fix": "eslint . --fix",
    "typecheck": "tsc --noEmit",
    "test": "vitest run",
    "test:watch": "vitest",
    "test:coverage": "vitest run --coverage"
  },
  "dependencies": {
    "@dnd-kit/core": "6.3.1",
    "@dnd-kit/sortable": "10.0.0",
    "@dnd-kit/utilities": "^3.2.2",
    "i18next": "25.7.3",
    "react": "19.2.3",
    "react-dom": "19.2.3",
    "react-i18next": "16.5.1",
    "zod": "4.3.4",
    "zustand": "5.0.9"
  },
  "devDependencies": {
    "@eslint/js": "9.39.2",
    "@testing-library/jest-dom": "^6.9.1",
    "@testing-library/react": "^16.3.1",
    "@types/node": "25.0.3",
    "@types/react": "19.2.7",
    "@types/react-dom": "19.2.3",
    "@vitejs/plugin-react": "5.1.2",
    "@vitest/coverage-v8": "^4.0.16",
    "eslint": "9.39.2",
    "eslint-config-prettier": "10.1.8",
    "eslint-plugin-react": "7.37.5",
    "eslint-plugin-react-hooks": "7.0.1",
    "eslint-plugin-unused-imports": "4.3.0",
    "globals": "16.5.0",
    "jsdom": "^27.4.0",
    "prettier": "3.7.4",
    "typescript": "5.9.3",
    "typescript-eslint": "8.51.0",
    "vite": "7.3.0",
    "vitest": "^4.0.16"
  },
  "pnpm": {
    "onlyBuiltDependencies": [
      "esbuild"
    ]
  }
}
</file>

<file path="frontend/src/locales/ko-KR/translation.json">
{
  "profile": {
    "select_title": "프로필을 선택하세요",
    "select_hint": "프로필마다 다른 시작 조건과 목표가 있습니다",
    "or": "또는",
    "continue_saved": "저장된 게임 계속하기",
    "change": "프로필 변경",
    "change_tooltip": "다른 프로필로 새 게임 시작",
    "narrator": {
      "name": "서사꾼",
      "description": "풍부한 자원으로 다양한 이야기를 탐험하세요",
      "welcome": "고대의 도서관에 오신 것을 환영합니다. 이곳에는 잊혀진 이야기들이 잠들어 있습니다...",
      "items": {
        "ancient_tome": "고대 서책",
        "quill_pen": "깃펜",
        "memory_fragment": "기억 조각"
      },
      "quest": {
        "discover_origin": "세계의 기원을 발견하기",
        "collect_memories": "기억 조각 3개 수집하기"
      },
      "rule": {
        "time_flows": "시간의 흐름",
        "time_flows_desc": "시간은 정상적으로 흐릅니다",
        "memories_persist": "기억의 지속",
        "memories_persist_desc": "한번 얻은 기억은 사라지지 않습니다"
      },
      "scene": {
        "bookshelf": "신비한 책장",
        "bookshelf_hint": "오래된 책들이 빛나고 있다",
        "portal": "빛나는 포탈",
        "portal_hint": "어딘가로 통하는 것 같다"
      }
    },
    "explorer": {
      "name": "탐험가",
      "description": "미지의 영역을 탐험하고 비밀을 발견하세요",
      "welcome": "어두운 미로에서 눈을 떴습니다. 출구를 찾아 이곳을 탈출해야 합니다...",
      "items": {
        "compass": "나침반",
        "rope": "밧줄",
        "lantern": "랜턴",
        "map_fragment": "지도 조각"
      },
      "quest": {
        "find_exit": "탈출구 찾기",
        "explore_areas": "3개 구역 탐험하기",
        "gather_supplies": "보급품 수집"
      },
      "rule": {
        "gravity": "중력 법칙",
        "gravity_desc": "물체는 아래로 떨어집니다",
        "darkness": "어둠의 법칙",
        "darkness_desc": "빛 없이는 앞을 볼 수 없습니다"
      },
      "scene": {
        "door": "고대의 문",
        "door_hint": "열쇠가 필요해 보인다",
        "mechanism": "이상한 장치",
        "mechanism_hint": "작동시킬 수 있을 것 같다",
        "passage": "숨겨진 통로",
        "passage_hint": "어디로 이어질까?"
      }
    },
    "tech": {
      "name": "기술 전문가",
      "description": "제한된 자원으로 효율적인 전략을 세우세요",
      "welcome": "시스템 부팅 완료. 제한된 에너지로 최적의 경로를 찾아야 합니다...",
      "items": {
        "data_core": "데이터 코어",
        "circuit_board": "회로 기판",
        "energy_cell": "에너지 셀",
        "scanner": "스캐너 장치"
      },
      "quest": {
        "analyze_system": "시스템 분석 완료하기",
        "optimize_resources": "자원 효율 최적화하기"
      },
      "rule": {
        "energy_conservation": "에너지 보존",
        "energy_conservation_desc": "에너지는 생성되거나 소멸되지 않습니다",
        "data_integrity": "데이터 무결성",
        "data_integrity_desc": "손상된 데이터는 복구할 수 없습니다",
        "system_limits": "시스템 한계",
        "system_limits_desc": "동시 처리량에 제한이 있습니다"
      },
      "scene": {
        "terminal": "메인 터미널",
        "terminal_hint": "시스템에 접속할 수 있다",
        "conduit": "전력 도관",
        "conduit_hint": "에너지가 흐르고 있다"
      }
    }
  },
  "reset": {
    "button": "리셋",
    "confirm": "다시 클릭하여 확인",
    "cancel": "취소",
    "tooltip": "현재 프로필의 초기 상태로 되돌립니다"
  },
  "demo": {
    "items": {
      "keycard-alpha": {
        "name": "키카드 A"
      },
      "medkit": {
        "name": "응급 키트"
      },
      "flashlight": {
        "name": "손전등"
      },
      "data-chip": {
        "name": "데이터칩"
      }
    },
    "scene": {
      "terminal": {
        "label": "터미널",
        "hint": "활성화된 터미널이다"
      },
      "door": {
        "label": "문",
        "hint": "잠겨있는 것 같다"
      }
    },
    "quest": {
      "terminal": {
        "label": "터미널에 접속하기"
      },
      "escape": {
        "label": "시설 탈출구 찾기"
      },
      "collect": {
        "label": "데이터칩 수집"
      }
    },
    "rule": {
      "gravity": {
        "label": "중력 법칙",
        "description": "물체는 아래로 떨어진다"
      },
      "time": {
        "label": "시간 흐름",
        "description": "시간은 정상 속도로 흐른다"
      }
    }
  },
  "quest": {
    "empty": "[ 목표 없음 ]",
    "completed": "완료",
    "section": {
      "active": "진행 중",
      "completed": "완료됨"
    }
  },
  "rule_board": {
    "empty": "[ 규칙 없음 ]",
    "active_count": "활성 규칙: {{count}}개"
  },
  "mutation": {
    "empty": "[ 변형 이력 없음 ]",
    "timeline_title": "변형 타임라인",
    "event_count": "{{count}}개 이벤트",
    "more_events": "+{{count}}개 더 보기",
    "turn_label": "T{{turn}}",
    "type": {
      "added": "추가됨",
      "modified": "수정됨",
      "removed": "제거됨"
    }
  },
  "scene": {
    "status": {
      "default": "데이터 대기 중",
      "loading": "동기화 중...",
      "offline": "연결 끊김",
      "blocked": "접근 제한됨",
      "low_signal": "신호 약함",
      "image_error": "장면 이미지를 불러올 수 없습니다.",
      "initial_sync": "전역 데이터 동기화 대기 중...",
      "syncing": "데이터 동기화 중...",
      "alt": "장면 이미지"
    },
    "hotspot": {
      "layer_label": "클릭 가능한 오브젝트 영역",
      "hint_prefix": "힌트",
      "click_action": "{{label}} 클릭",
      "drop_hint": "여기에 드롭하여 사용",
      "drop_action": "{{item}}을(를) {{target}}에 사용",
      "drop_invalid": "그곳에는 {{item}}을(를) 사용할 수 없습니다.",
      "demo_hint": "[데모 대상]"
    }
  },
  "agent": {
    "console": {
      "queue": "대기열",
      "badges": "검증 배지",
      "repair": "자동 복구",
      "status": {
        "idle": "대기 중",
        "processing": "처리 중"
      },
      "badges_empty": "[ 검증 대기 중 ]",
      "repaired": "(복구됨)",
      "phase": {
        "parse": "Parse",
        "validate": "Validate",
        "plan": "Plan",
        "resolve": "Resolve",
        "render": "Render",
        "verify": "Verify",
        "commit": "Commit"
      },
      "badge": {
        "schema": "Schema",
        "economy": "Economy",
        "safety": "Safety",
        "consistency": "Consistency",
        "ok": "OK",
        "fail": "FAIL"
      }
    }
  },
  "ui": {
    "logo": "UNKNOWN WORLD",
    "command_placeholder": "명령을 입력하세요...",
    "processing": "처리 중...",
    "execute": "실행",
    "wait": "대기",
    "panel_placeholder": "[ 준비 중 ]",
    "scale_decrease": "글자 크기 줄이기",
    "scale_increase": "글자 크기 늘리기",
    "scale_label": "UI 스케일 설정"
  },
  "economy": {
    "signal": "Signal",
    "shard": "Shard",
    "signal_cost": "Signal 소모",
    "shard_cost": "Shard 소모",
    "risk_level": "위험도",
    "hud_label": "재화 현황",
    "estimated_cost": "예상 비용",
    "confirmed_cost": "확정 비용",
    "insufficient_funds": "잔액 부족",
    "low_balance_warning": "잔액이 부족합니다",
    "alternatives_title": "대안 행동",
    "alternative_text_only": "텍스트만 생성 (이미지 없음)",
    "alternative_low_quality": "저품질/빠른 응답 선택",
    "ledger_title": "최근 원장 이력",
    "ledger_empty": "[ 이력 없음 ]",
    "model_label": {
      "FAST": "빠름",
      "QUALITY": "고품질",
      "CHEAP": "저비용",
      "REF": "참조"
    }
  },
  "connection": {
    "online": "온라인",
    "offline": "오프라인"
  },
  "inventory": {
    "empty": "[ 아이템 없음 ]",
    "grid_label": "인벤토리 아이템 목록",
    "item_label": "{{name}} (수량: {{quantity}})",
    "drag_hint": "드래그하여 사용"
  },
  "panel": {
    "inventory": {
      "title": "Inventory",
      "placeholder": "[ 드래그 앤 드롭 영역 ]"
    },
    "quest": {
      "title": "Quest",
      "placeholder": "[ 목표/퀘스트 목록 ]"
    },
    "rule_board": {
      "title": "Rule Board",
      "placeholder": "[ 월드 규칙/변형 타임라인 ]"
    },
    "agent_console": {
      "title": "Agent Console"
    },
    "memory_pin": {
      "title": "Memory Pin",
      "placeholder": "[ 고정된 기억/단서 ]"
    },
    "scanner": {
      "title": "Scanner",
      "placeholder": "[ 이미지 업로드 슬롯 ]"
    }
  },
  "action": {
    "default": {
      "explore": {
        "label": "탐색하기",
        "description": "주변을 살펴본다"
      },
      "investigate": {
        "label": "조사하기",
        "description": "자세히 살펴본다"
      },
      "talk": {
        "label": "대화하기",
        "description": "말을 걸어본다"
      }
    },
    "card_select": "카드 선택: {{cardId}}",
    "deck_label": "행동 선택 카드",
    "alternative": "대안",
    "insufficient_balance": "잔액 부족",
    "all_disabled_notice": "실행 가능한 행동이 없습니다. 대안을 확인하세요.",
    "risk": {
      "low": "낮음",
      "medium": "보통",
      "high": "높음"
    },
    "cost_range": "{{min}}~{{max}}"
  },
  "narrative": {
    "welcome": "미지의 세계에 오신 것을 환영합니다...",
    "turn_label": "[TURN {{turn}}]",
    "streaming_label": "[STREAMING]"
  }
}
</file>

</files>
