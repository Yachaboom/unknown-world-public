This file is a merged representation of a subset of the codebase, containing specifically included files and files not matching ignore patterns, combined into a single document by Repomix.

<file_summary>
This section contains a summary of this file.

<purpose>
This file contains a packed representation of a subset of the repository's contents that is considered the most important context.
It is designed to be easily consumable by AI systems for analysis, code review,
or other automated processes.
</purpose>

<file_format>
The content is organized as follows:
1. This summary section
2. Repository information
3. Directory structure
4. Repository files (if enabled)
5. Multiple file entries, each consisting of:
  - File path as an attribute
  - Full contents of the file
</file_format>

<usage_guidelines>
- This file should be treated as read-only. Any changes should be made to the
  original repository files, not this packed version.
- When processing this file, use the file path to distinguish
  between different files in the repository.
- Be aware that this file may contain sensitive information. Handle it with
  the same level of security as you would the original repository.
</usage_guidelines>

<notes>
- Some files may have been excluded based on .gitignore rules and Repomix's configuration
- Binary files are not included in this packed representation. Please refer to the Repository Structure section for a complete list of file paths, including binary files
- Only files matching these patterns are included: **/*.{ts,tsx,js,jsx,json,py,toml,yaml}
- Files matching these patterns are excluded: .claude/**, .cursor/**, .gemini/**, .vscode/**, vibe/**, node_modules/**, backend/.venv/**, frontend/dist/**, frontend/coverage/**
- Files matching patterns in .gitignore are excluded
- Files matching default ignore patterns are excluded
- Files are sorted by Git change count (files with more changes are at the bottom)
</notes>

</file_summary>

<directory_structure>
backend/debug_api_call.py
backend/debug_real_mode.py
backend/debug_schema_check.py
backend/debug_server_state.py
backend/debug_uvicorn_sim.py
backend/pyproject.toml
backend/run_full_test.py
backend/src/unknown_world/__init__.py
backend/src/unknown_world/api/__init__.py
backend/src/unknown_world/api/image.py
backend/src/unknown_world/api/item_icon.py
backend/src/unknown_world/api/scanner.py
backend/src/unknown_world/api/turn_stream_events.py
backend/src/unknown_world/api/turn_streaming_helpers.py
backend/src/unknown_world/api/turn.py
backend/src/unknown_world/config/__init__.py
backend/src/unknown_world/config/economy.py
backend/src/unknown_world/config/models.py
backend/src/unknown_world/main.py
backend/src/unknown_world/models/__init__.py
backend/src/unknown_world/models/scanner.py
backend/src/unknown_world/models/turn.py
backend/src/unknown_world/orchestrator/__init__.py
backend/src/unknown_world/orchestrator/fallback.py
backend/src/unknown_world/orchestrator/generate_turn_output.py
backend/src/unknown_world/orchestrator/mock.py
backend/src/unknown_world/orchestrator/pipeline.py
backend/src/unknown_world/orchestrator/prompt_loader.py
backend/src/unknown_world/orchestrator/repair_loop.py
backend/src/unknown_world/orchestrator/stages/__init__.py
backend/src/unknown_world/orchestrator/stages/commit.py
backend/src/unknown_world/orchestrator/stages/parse.py
backend/src/unknown_world/orchestrator/stages/plan.py
backend/src/unknown_world/orchestrator/stages/render_helpers.py
backend/src/unknown_world/orchestrator/stages/render.py
backend/src/unknown_world/orchestrator/stages/resolve.py
backend/src/unknown_world/orchestrator/stages/types.py
backend/src/unknown_world/orchestrator/stages/validate.py
backend/src/unknown_world/orchestrator/stages/verify.py
backend/src/unknown_world/services/__init__.py
backend/src/unknown_world/services/agentic_vision.py
backend/src/unknown_world/services/genai_client.py
backend/src/unknown_world/services/image_generation.py
backend/src/unknown_world/services/image_understanding.py
backend/src/unknown_world/services/item_icon_generator.py
backend/src/unknown_world/storage/__init__.py
backend/src/unknown_world/storage/local_storage.py
backend/src/unknown_world/storage/paths.py
backend/src/unknown_world/storage/storage.py
backend/src/unknown_world/storage/validation.py
backend/src/unknown_world/validation/__init__.py
backend/src/unknown_world/validation/business_rules.py
backend/src/unknown_world/validation/language_gate.py
backend/start_and_test.py
backend/test_api.py
backend/test_real_vision.json
backend/tests/conftest.py
backend/tests/fixtures/image_request_fast.json
backend/tests/fixtures/image_request_quality.json
backend/tests/fixtures/turn_request.json
backend/tests/integration/test_api.py
backend/tests/integration/test_item_icon_api.py
backend/tests/integration/test_real_mode_gate.py
backend/tests/integration/test_resolve_vision.py
backend/tests/integration/test_scanner_api.py
backend/tests/integration/test_turn_streaming.py
backend/tests/manual_test_image.py
backend/tests/qa/test_asset_manifest.py
backend/tests/qa/test_u052_manual_verification.py
backend/tests/unit/api/test_image.py
backend/tests/unit/models/test_turn.py
backend/tests/unit/models/test_u078_objectives.py
backend/tests/unit/orchestrator/test_generate_turn_output.py
backend/tests/unit/orchestrator/test_mock_orchestrator.py
backend/tests/unit/orchestrator/test_pipeline.py
backend/tests/unit/orchestrator/test_prompt_loader.py
backend/tests/unit/orchestrator/test_u051_bridge.py
backend/tests/unit/orchestrator/test_u052_render_helpers.py
backend/tests/unit/orchestrator/test_u052_render_integration.py
backend/tests/unit/orchestrator/test_u053_render_async.py
backend/tests/unit/orchestrator/test_u054_image_fallback.py
backend/tests/unit/orchestrator/test_u061_image_integration.py
backend/tests/unit/orchestrator/test_u069_model_tiering.py
backend/tests/unit/orchestrator/test_u090_hotspot_restriction.py
backend/tests/unit/services/test_agentic_vision.py
backend/tests/unit/services/test_genai_client.py
backend/tests/unit/services/test_image_extraction.py
backend/tests/unit/services/test_image_generation.py
backend/tests/unit/services/test_item_icon_generator.py
backend/tests/unit/services/test_scanner_service.py
backend/tests/unit/services/test_u075_verification.py
backend/tests/unit/services/test_u093_timeout_retry.py
backend/tests/unit/services/test_u094_scan_retry.py
backend/tests/unit/services/test_u095_scanner_randomize.py
backend/tests/unit/test_dotenv_autoload.py
backend/tests/unit/test_orchestrator_repair.py
backend/tests/unit/test_u034_verification.py
backend/tests/unit/test_u043_language_gate.py
backend/tests/unit/test_u065_schema_simplification.py
backend/tests/unit/test_u068_reference_image.py
backend/tests/unit/test_u079_economy_low_balance.py
backend/tests/unit/test_u096_consumption.py
frontend/package.json
frontend/public/ui/manifest.json
frontend/public/ui/manifest.schema.json
frontend/src/api/image.ts
frontend/src/api/scanner.test.ts
frontend/src/api/scanner.ts
frontend/src/api/turnStream.economy.test.ts
frontend/src/api/turnStream.test.ts
frontend/src/api/turnStream.ts
frontend/src/App.test.tsx
frontend/src/App.tsx
frontend/src/components/ActionDeck.test.tsx
frontend/src/components/ActionDeck.tsx
frontend/src/components/AgentConsole.test.tsx
frontend/src/components/AgentConsole.tsx
frontend/src/components/DemoProfileSelect.tsx
frontend/src/components/DndInteraction.test.tsx
frontend/src/components/EconomyHud.test.tsx
frontend/src/components/EconomyHud.tsx
frontend/src/components/GameHeader.tsx
frontend/src/components/Hotspot.test.tsx
frontend/src/components/Hotspot.tsx
frontend/src/components/InteractionHint.test.tsx
frontend/src/components/InteractionHint.tsx
frontend/src/components/InventoryPanel.test.tsx
frontend/src/components/InventoryPanel.tsx
frontend/src/components/MutationTimeline.test.tsx
frontend/src/components/MutationTimeline.tsx
frontend/src/components/NarrativeFeed.test.tsx
frontend/src/components/NarrativeFeed.tsx
frontend/src/components/ObjectiveTracker.test.tsx
frontend/src/components/ObjectiveTracker.tsx
frontend/src/components/OnboardingGuide.test.tsx
frontend/src/components/OnboardingGuide.tsx
frontend/src/components/Panel.tsx
frontend/src/components/QuestPanel.test.tsx
frontend/src/components/QuestPanel.tsx
frontend/src/components/ResetButton.tsx
frontend/src/components/RuleBoard.test.tsx
frontend/src/components/RuleBoard.tsx
frontend/src/components/ScannerSlot.test.tsx
frontend/src/components/ScannerSlot.tsx
frontend/src/components/SceneCanvas.hotspot.test.tsx
frontend/src/components/SceneCanvas.test.tsx
frontend/src/components/SceneCanvas.tsx
frontend/src/components/SceneImage.test.tsx
frontend/src/components/SceneImage.tsx
frontend/src/components/UIControls.tsx
frontend/src/data/demoProfiles.test.ts
frontend/src/data/demoProfiles.ts
frontend/src/data/itemIconPresets.ts
frontend/src/demo/demoFixtures.ts
frontend/src/demo/useDemoInitializer.ts
frontend/src/dnd/types.ts
frontend/src/i18n-scenario.test.ts
frontend/src/i18n.ts
frontend/src/locales/en-US/translation.json
frontend/src/locales/ko-KR/translation.json
frontend/src/main.tsx
frontend/src/save/constants.ts
frontend/src/save/migrations.test.ts
frontend/src/save/migrations.ts
frontend/src/save/saveGame.test.ts
frontend/src/save/saveGame.ts
frontend/src/save/sessionLifecycle.test.ts
frontend/src/save/sessionLifecycle.ts
frontend/src/schemas/index.ts
frontend/src/schemas/turn.economy.test.ts
frontend/src/schemas/turn.test.ts
frontend/src/schemas/turn.ts
frontend/src/schemas/verify_runbook.ts
frontend/src/setupTests.ts
frontend/src/stores/actionDeckStore.test.ts
frontend/src/stores/actionDeckStore.ts
frontend/src/stores/agentStore.test.ts
frontend/src/stores/agentStore.ts
frontend/src/stores/economyStore.test.ts
frontend/src/stores/economyStore.ts
frontend/src/stores/inventory_consumption.test.ts
frontend/src/stores/inventoryStore.test.ts
frontend/src/stores/inventoryStore.ts
frontend/src/stores/onboardingStore.test.ts
frontend/src/stores/onboardingStore.ts
frontend/src/stores/uiPrefsStore.test.ts
frontend/src/stores/uiPrefsStore.ts
frontend/src/stores/worldStore.test.ts
frontend/src/stores/worldStore.ts
frontend/src/stores/worldStore.u066.test.ts
frontend/src/turn/turnRunner.test.ts
frontend/src/turn/turnRunner.ts
frontend/src/types/scene.ts
frontend/src/types/turn_stream.ts
frontend/src/utils/box2d.test.ts
frontend/src/utils/box2d.ts
frontend/src/vite-env.d.ts
frontend/tsconfig.json
frontend/tsconfig.node.json
frontend/vite.config.ts
package.json
request.json
scripts/process_item_icons.py
shared/schemas/turn/turn_input.schema.json
shared/schemas/turn/turn_output.schema.json
</directory_structure>

<files>
This section contains the contents of the repository's files.

<file path="backend/src/unknown_world/__init__.py">
"""Unknown World - Backend Package

This is the main package for the Unknown World backend.
Architecture: FastAPI + Pydantic + SSE streaming

Reference:
- vibe/tech-stack.md (Python 3.14, FastAPI 0.128.0, Pydantic 2.12.5)
- vibe/prd.md (Agent-based Game Master Engine)
"""

__version__ = "0.1.0"
</file>

<file path="backend/src/unknown_world/api/turn_stream_events.py">
"""Unknown World - Turn Stream ì´ë²¤íŠ¸ ê³„ì•½(Contract).

NDJSON ìŠ¤íŠ¸ë¦¬ë°ì—ì„œ ì‚¬ìš©ë˜ëŠ” ì´ë²¤íŠ¸ íƒ€ì…, ëª¨ë¸, ìœ í‹¸ë¦¬í‹°ë¥¼ ì •ì˜í•©ë‹ˆë‹¤.
ì´ ëª¨ë“ˆì€ Orchestrator â†” API â†” Frontend ê°„ì˜ ìŠ¤íŠ¸ë¦¼ ì´ë²¤íŠ¸ ê³„ì•½ SSOTì…ë‹ˆë‹¤.

ì„¤ê³„ ì›ì¹™:
    - RU-002-Q4: ì´ë²¤íŠ¸ ê³„ì•½ì„ transport ê³„ì¸µìœ¼ë¡œ ë¶„ë¦¬
    - RULE-003: êµ¬ì¡°í™” ì¶œë ¥(JSON Schema) ìš°ì„  + Pydantic ê²€ì¦
    - RULE-008: ë‹¨ê³„/ë°°ì§€ ê°€ì‹œí™”

ì°¸ì¡°:
    - vibe/unit-plans/U-007[Mvp].md
    - vibe/refactors/RU-002-Q4.md
"""

from __future__ import annotations

import json
from typing import Annotated, Any

from pydantic import BaseModel, Field

# =============================================================================
# ìŠ¤íŠ¸ë¦¼ ì´ë²¤íŠ¸ íƒ€ì… ìƒìˆ˜
# =============================================================================


class StreamEventType:
    """ìŠ¤íŠ¸ë¦¼ ì´ë²¤íŠ¸ íƒ€ì… ìƒìˆ˜.

    NDJSON ìŠ¤íŠ¸ë¦¬ë°ì—ì„œ ì‚¬ìš©ë˜ëŠ” ì´ë²¤íŠ¸ íƒ€ì…ì…ë‹ˆë‹¤.
    PRD ì˜ˆì‹œ ë‹¨ê³„: Parseâ†’Validateâ†’Planâ†’Resolveâ†’Renderâ†’Verifyâ†’Commit
    """

    STAGE = "stage"
    BADGES = "badges"
    NARRATIVE_DELTA = "narrative_delta"
    FINAL = "final"
    ERROR = "error"
    REPAIR = "repair"


class StageStatus:
    """ë‹¨ê³„ ìƒíƒœ ìƒìˆ˜."""

    START = "start"
    COMPLETE = "complete"
    FAIL = "fail"


# =============================================================================
# ìŠ¤íŠ¸ë¦¼ ì´ë²¤íŠ¸ ëª¨ë¸ (Pydantic)
# =============================================================================


class StageEvent(BaseModel):
    """ë‹¨ê³„ ì§„í–‰ ì´ë²¤íŠ¸.

    Attributes:
        type: ì´ë²¤íŠ¸ íƒ€ì… ("stage")
        name: ë‹¨ê³„ ì´ë¦„ (Parse, Validate, Plan, Resolve, Render, Verify, Commit)
        status: ìƒíƒœ (start, complete)
    """

    type: Annotated[str, Field(default=StreamEventType.STAGE)]
    name: str
    status: str


class RepairEvent(BaseModel):
    """ìë™ ë³µêµ¬(Repair) ì´ë²¤íŠ¸.

    Attributes:
        type: ì´ë²¤íŠ¸ íƒ€ì… ("repair")
        attempt: í˜„ì¬ ì‹œë„ íšŸìˆ˜
        message: ë³µêµ¬ ë©”ì‹œì§€ (ì„ íƒ)
    """

    type: Annotated[str, Field(default=StreamEventType.REPAIR)]
    attempt: int
    message: str | None = None


class BadgesEvent(BaseModel):
    """ë°°ì§€ ì´ë²¤íŠ¸.

    Attributes:
        type: ì´ë²¤íŠ¸ íƒ€ì… ("badges")
        badges: ê²€ì¦ ë°°ì§€ ëª©ë¡
    """

    type: Annotated[str, Field(default=StreamEventType.BADGES)]
    badges: list[str]


class NarrativeDeltaEvent(BaseModel):
    """ë‚´ëŸ¬í‹°ë¸Œ ë¸íƒ€ ì´ë²¤íŠ¸ (íƒ€ì íš¨ê³¼ìš©).

    Attributes:
        type: ì´ë²¤íŠ¸ íƒ€ì… ("narrative_delta")
        text: ì¶”ê°€ëœ í…ìŠ¤íŠ¸ ì¡°ê°
    """

    type: Annotated[str, Field(default=StreamEventType.NARRATIVE_DELTA)]
    text: str


class FinalEvent(BaseModel):
    """ìµœì¢… TurnOutput ì´ë²¤íŠ¸.

    Attributes:
        type: ì´ë²¤íŠ¸ íƒ€ì… ("final")
        data: ì™„ì „í•œ TurnOutput

    Note:
        TurnOutputì€ TYPE_CHECKING ë¸”ë¡ì—ì„œ importë˜ë©°,
        ëŸ°íƒ€ì„ì—ëŠ” Anyë¡œ ì²˜ë¦¬ë©ë‹ˆë‹¤.
    """

    type: Annotated[str, Field(default=StreamEventType.FINAL)]
    data: Any  # TurnOutput (ìˆœí™˜ import ë°©ì§€)


class ErrorEvent(BaseModel):
    """ì—ëŸ¬ ì´ë²¤íŠ¸.

    Attributes:
        type: ì´ë²¤íŠ¸ íƒ€ì… ("error")
        message: ì—ëŸ¬ ë©”ì‹œì§€ (í”„ë¡¬í”„íŠ¸/ë‚´ë¶€ ì¶”ë¡  ë…¸ì¶œ ê¸ˆì§€)
        code: ì—ëŸ¬ ì½”ë“œ (ì„ íƒ)
    """

    type: Annotated[str, Field(default=StreamEventType.ERROR)]
    message: str
    code: str | None = None


# =============================================================================
# ìœ í‹¸ë¦¬í‹° í•¨ìˆ˜
# =============================================================================


def serialize_event(event: dict[str, Any]) -> str:
    """ì´ë²¤íŠ¸ë¥¼ NDJSON ë¼ì¸ìœ¼ë¡œ ì§ë ¬í™”í•©ë‹ˆë‹¤.

    Args:
        event: ì§ë ¬í™”í•  ì´ë²¤íŠ¸ ë”•ì…”ë„ˆë¦¬

    Returns:
        str: NDJSON í˜•ì‹ ë¬¸ìì—´ (ì¤„ë°”ê¿ˆ í¬í•¨)
    """
    return json.dumps(event, ensure_ascii=False) + "\n"


# =============================================================================
# ëª¨ë“ˆ ê³µê°œ API
# =============================================================================

__all__ = [
    "StreamEventType",
    "StageStatus",
    "StageEvent",
    "RepairEvent",
    "BadgesEvent",
    "NarrativeDeltaEvent",
    "FinalEvent",
    "ErrorEvent",
    "serialize_event",
]
</file>

<file path="backend/tests/integration/test_api.py">
from fastapi.testclient import TestClient

from unknown_world.main import app

client = TestClient(app)


def test_health_check():
    """/health ì—”ë“œí¬ì¸íŠ¸ê°€ ì˜¬ë°”ë¥¸ ìŠ¤í‚¤ë§ˆì™€ ìƒíƒœë¥¼ ë°˜í™˜í•˜ëŠ”ì§€ í…ŒìŠ¤íŠ¸í•©ë‹ˆë‹¤."""
    response = client.get("/health")
    assert response.status_code == 200
    data = response.json()
    assert data["status"] == "ok"
    assert "version" in data
    assert data["service"] == "unknown-world-backend"


def test_root_endpoint():
    """ë£¨íŠ¸ ì—”ë“œí¬ì¸íŠ¸ê°€ ì •ìƒ ì‘ë™í•˜ëŠ”ì§€ í…ŒìŠ¤íŠ¸í•©ë‹ˆë‹¤."""
    response = client.get("/")
    assert response.status_code == 200
    assert "message" in response.json()


def test_cors_policy():
    """RULE-011ì— ë”°ë¥¸ CORS ì •ì±…ì´ ì˜¬ë°”ë¥´ê²Œ ì„¤ì •ë˜ì—ˆëŠ”ì§€ í…ŒìŠ¤íŠ¸í•©ë‹ˆë‹¤."""
    # í—ˆìš©ëœ ì˜¤ë¦¬ì§„ í…ŒìŠ¤íŠ¸ (í¬íŠ¸ 8001)
    headers = {
        "Origin": "http://localhost:8001",
        "Access-Control-Request-Method": "GET",
    }
    response = client.options("/health", headers=headers)
    assert response.status_code == 200
    assert response.headers.get("access-control-allow-origin") == "http://localhost:8001"

    # í—ˆìš©ë˜ì§€ ì•Šì€ ì˜¤ë¦¬ì§„ í…ŒìŠ¤íŠ¸ (í¬íŠ¸ 9000)
    headers = {
        "Origin": "http://localhost:9000",
        "Access-Control-Request-Method": "GET",
    }
    response = client.options("/health", headers=headers)
    # FastAPI/Starlette CORS ë¯¸ë“¤ì›¨ì–´ëŠ” í—ˆìš©ë˜ì§€ ì•Šì€ ê²½ìš° origin í—¤ë”ë¥¼ ë°˜í™˜í•˜ì§€ ì•ŠìŒ
    assert "access-control-allow-origin" not in response.headers
</file>

<file path="frontend/package.json">
{
  "name": "unknown-world-frontend",
  "private": true,
  "version": "0.0.0",
  "type": "module",
  "packageManager": "pnpm@10.27.0",
  "scripts": {
    "dev": "vite",
    "build": "tsc -b && vite build",
    "preview": "vite preview",
    "format": "prettier . --write",
    "format:check": "prettier . --check",
    "lint": "eslint .",
    "lint:fix": "eslint . --fix",
    "typecheck": "tsc --noEmit",
    "test": "vitest run",
    "test:watch": "vitest",
    "test:coverage": "vitest run --coverage"
  },
  "dependencies": {
    "@dnd-kit/core": "6.3.1",
    "@dnd-kit/sortable": "10.0.0",
    "@dnd-kit/utilities": "^3.2.2",
    "i18next": "25.7.3",
    "react": "19.2.3",
    "react-dom": "19.2.3",
    "react-i18next": "16.5.1",
    "zod": "4.3.4",
    "zustand": "5.0.9"
  },
  "devDependencies": {
    "@eslint/js": "9.39.2",
    "@testing-library/jest-dom": "^6.9.1",
    "@testing-library/react": "^16.3.1",
    "@types/node": "25.0.3",
    "@types/react": "19.2.7",
    "@types/react-dom": "19.2.3",
    "@vitejs/plugin-react": "5.1.2",
    "@vitest/coverage-v8": "^4.0.16",
    "eslint": "9.39.2",
    "eslint-config-prettier": "10.1.8",
    "eslint-plugin-react": "7.37.5",
    "eslint-plugin-react-hooks": "7.0.1",
    "eslint-plugin-unused-imports": "4.3.0",
    "globals": "16.5.0",
    "jsdom": "^27.4.0",
    "prettier": "3.7.4",
    "typescript": "5.9.3",
    "typescript-eslint": "8.51.0",
    "vite": "7.3.0",
    "vitest": "^4.0.16"
  },
  "pnpm": {
    "onlyBuiltDependencies": [
      "esbuild"
    ]
  }
}
</file>

<file path="frontend/src/components/MutationTimeline.tsx">
/**
 * Unknown World - Mutation Timeline (U-013)
 *
 * ê·œì¹™ ë³€í˜• ì´ë²¤íŠ¸ë¥¼ ì‹œê°„ìˆœìœ¼ë¡œ í‘œì‹œí•˜ëŠ” íƒ€ì„ë¼ì¸ ì»´í¬ë„ŒíŠ¸ì…ë‹ˆë‹¤.
 * "ì„¸ê³„ê°€ ë³€í–ˆë‹¤"ë¥¼ UIë¡œ ì²´ê°í•  ìˆ˜ ìˆê²Œ í•©ë‹ˆë‹¤.
 *
 * ì„¤ê³„ ì›ì¹™:
 *   - RULE-002: ì±„íŒ… UIê°€ ì•„ë‹Œ ê²Œì„ UIë¡œ ìƒì‹œ ë…¸ì¶œ
 *   - RULE-006: i18n ê¸°ë°˜ ë¬¸ìì—´ ê´€ë¦¬
 *   - PRD 6.4: Rule Mutation Timeline
 *   - Q1 ê²°ì •: Option B - ë³„ë„ Timeline ì»´í¬ë„ŒíŠ¸ (ê°€ë…ì„±/í™•ì¥ ìš©ì´)
 *
 * @module components/MutationTimeline
 */

import { useTranslation } from 'react-i18next';
import { useWorldStore, selectMutationTimeline } from '../stores/worldStore';
import type { MutationEvent } from '../stores/worldStore';

// =============================================================================
// ìƒìˆ˜
// =============================================================================

/** í‘œì‹œí•  ìµœëŒ€ ì´ë²¤íŠ¸ ìˆ˜ (MMPì—ì„œ ìŠ¤í¬ë¡¤/ìš”ì•½ ì „ëµ ì ìš© ì˜ˆì •) */
const MAX_DISPLAY_EVENTS = 10;

// =============================================================================
// í•˜ìœ„ ì»´í¬ë„ŒíŠ¸
// =============================================================================

interface TimelineEventProps {
  event: MutationEvent;
}

/**
 * ê°œë³„ íƒ€ì„ë¼ì¸ ì´ë²¤íŠ¸ ë Œë”ë§
 */
function TimelineEvent({ event }: TimelineEventProps) {
  const { t } = useTranslation();

  // ì´ë²¤íŠ¸ ìœ í˜•ë³„ ì•„ì´ì½˜
  const typeIcon = {
    added: 'â•',
    modified: 'ğŸ”„',
    removed: 'â–',
  }[event.type];

  // ì´ë²¤íŠ¸ ìœ í˜•ë³„ CSS í´ë˜ìŠ¤
  const typeClass = `timeline-event-${event.type}`;

  return (
    <div className={`timeline-event ${typeClass}`} data-event-type={event.type}>
      <div className="timeline-event-marker">
        <span className="timeline-event-icon" aria-hidden="true">
          {typeIcon}
        </span>
        <span className="timeline-event-turn">
          {t('mutation.turn_label', { turn: event.turn })}
        </span>
      </div>
      <div className="timeline-event-content">
        <span className="timeline-event-label">{event.label}</span>
        <span className="timeline-event-type">{t(`mutation.type.${event.type}`)}</span>
        {event.description && <p className="timeline-event-description">{event.description}</p>}
      </div>
    </div>
  );
}

// =============================================================================
// ë©”ì¸ ì»´í¬ë„ŒíŠ¸
// =============================================================================

/**
 * Mutation Timeline
 *
 * ê·œì¹™ ë³€í˜• ì´ë²¤íŠ¸ë¥¼ ì‹œê°„ìˆœ(ìµœì‹  ë¨¼ì €)ìœ¼ë¡œ í‘œì‹œí•©ë‹ˆë‹¤.
 * worldStoreì˜ mutationTimeline ìƒíƒœë¥¼ êµ¬ë…í•˜ì—¬ ì‹¤ì‹œê°„ ì—…ë°ì´íŠ¸ë©ë‹ˆë‹¤.
 */
export function MutationTimeline() {
  const { t } = useTranslation();
  const mutationTimeline = useWorldStore(selectMutationTimeline);

  // í‘œì‹œí•  ì´ë²¤íŠ¸ (ìµœëŒ€ ê°œìˆ˜ ì œí•œ)
  const displayEvents = mutationTimeline.slice(0, MAX_DISPLAY_EVENTS);
  const hasMore = mutationTimeline.length > MAX_DISPLAY_EVENTS;

  // ë¹ˆ ìƒíƒœ
  if (mutationTimeline.length === 0) {
    return (
      <div className="mutation-timeline-content timeline-empty" data-ui-importance="critical">
        <div className="timeline-empty-icon" aria-hidden="true">
          ğŸ“Š
        </div>
        <p className="timeline-empty-text">{t('mutation.empty')}</p>
      </div>
    );
  }

  return (
    <div className="mutation-timeline-content" data-ui-importance="critical">
      <div className="timeline-header">
        <span className="timeline-title">{t('mutation.timeline_title')}</span>
        <span className="timeline-count">
          {t('mutation.event_count', { count: mutationTimeline.length })}
        </span>
      </div>
      <div className="timeline-events" role="list" aria-label={t('mutation.timeline_title')}>
        {displayEvents.map((event, index) => (
          <TimelineEvent key={`${event.ruleId}-${event.turn}-${index}`} event={event} />
        ))}
      </div>
      {hasMore && (
        <div className="timeline-more">
          <span className="timeline-more-text">
            {t('mutation.more_events', { count: mutationTimeline.length - MAX_DISPLAY_EVENTS })}
          </span>
        </div>
      )}
    </div>
  );
}

export default MutationTimeline;
</file>

<file path="frontend/src/components/Panel.tsx">
import { useTranslation } from 'react-i18next';

interface PanelProps {
  title: string;
  children?: React.ReactNode;
  className?: string;
  /** U-032: Chrome ì¥ì‹ ì ìš© ì—¬ë¶€ */
  hasChrome?: boolean;
  /** ê¸°ë³¸ placeholder i18n í‚¤ (childrenì´ ì—†ì„ ë•Œ ì‚¬ìš©) */
  placeholderKey?: string;
}

export function Panel({
  title,
  children,
  className = '',
  hasChrome = false,
  placeholderKey,
}: PanelProps) {
  const { t } = useTranslation();
  const panelClass = `panel ${className} ${hasChrome ? 'has-chrome' : ''}`.trim();
  const headerClass = `panel-header ${hasChrome ? 'has-chrome' : ''}`.trim();

  return (
    <div className={panelClass}>
      <div className={headerClass}>
        <span className="panel-title">{title}</span>
      </div>
      <div className="panel-content">
        {children || (
          <p className="panel-placeholder">
            {placeholderKey ? t(placeholderKey) : t('ui.panel_placeholder')}
          </p>
        )}
      </div>
    </div>
  );
}
</file>

<file path="frontend/src/components/ResetButton.tsx">
/**
 * Unknown World - ë¦¬ì…‹ ë²„íŠ¼ ì»´í¬ë„ŒíŠ¸ (U-015[Mvp]).
 *
 * 1íšŒ í´ë¦­ìœ¼ë¡œ í˜„ì¬ í”„ë¡œí•„ì˜ ì´ˆê¸° ìƒíƒœë¡œ ë³µêµ¬í•˜ëŠ” ë²„íŠ¼ì…ë‹ˆë‹¤.
 * ë°ëª¨ ë°˜ë³µ ê°€ëŠ¥ì„±ì„ ë³´ì¥í•©ë‹ˆë‹¤.
 *
 * ì„¤ê³„ ì›ì¹™:
 *   - PRD 6.9: ì¦‰ì‹œ ë¦¬ì…‹ 1íšŒë¡œ ë°ëª¨ ë°˜ë³µ ê°€ëŠ¥
 *   - RULE-006: i18n í‚¤ ê¸°ë°˜ ë‹¤êµ­ì–´ ì§€ì›
 *
 * @module components/ResetButton
 */

import { useCallback, useState } from 'react';
import { useTranslation } from 'react-i18next';

// =============================================================================
// íƒ€ì… ì •ì˜
// =============================================================================

export interface ResetButtonProps {
  /** ë¦¬ì…‹ í´ë¦­ ì‹œ í˜¸ì¶œë˜ëŠ” ì½œë°± */
  onReset: () => void;
  /** ë¹„í™œì„±í™” ì—¬ë¶€ */
  disabled?: boolean;
  /** í™•ì¸ í•„ìš” ì—¬ë¶€ (ê¸°ë³¸: true) */
  requireConfirm?: boolean;
  /** ì¶”ê°€ í´ë˜ìŠ¤ëª… */
  className?: string;
  /** ì»´íŒ©íŠ¸ ëª¨ë“œ (ì•„ì´ì½˜ë§Œ í‘œì‹œ) */
  compact?: boolean;
}

// =============================================================================
// ì»´í¬ë„ŒíŠ¸
// =============================================================================

/**
 * ê²Œì„ ë¦¬ì…‹ ë²„íŠ¼.
 * í˜„ì¬ í”„ë¡œí•„ì˜ ì´ˆê¸° ìƒíƒœë¡œ ë³µêµ¬í•©ë‹ˆë‹¤.
 */
export function ResetButton({
  onReset,
  disabled = false,
  requireConfirm = true,
  className = '',
  compact = false,
}: ResetButtonProps) {
  const { t } = useTranslation();
  const [isConfirming, setIsConfirming] = useState(false);

  const handleClick = useCallback(() => {
    if (requireConfirm && !isConfirming) {
      // í™•ì¸ ëª¨ë“œë¡œ ì „í™˜
      setIsConfirming(true);
      // 3ì´ˆ í›„ ìë™ ì·¨ì†Œ
      setTimeout(() => setIsConfirming(false), 3000);
      return;
    }

    // ë¦¬ì…‹ ì‹¤í–‰
    onReset();
    setIsConfirming(false);
  }, [onReset, requireConfirm, isConfirming]);

  const handleCancel = useCallback(() => {
    setIsConfirming(false);
  }, []);

  const buttonText = isConfirming ? t('reset.confirm') : compact ? '' : t('reset.button');

  const buttonAriaLabel = isConfirming ? t('reset.confirm') : t('reset.button');

  return (
    <div className={`reset-button-wrapper ${className}`.trim()}>
      <button
        type="button"
        className={`reset-button ${isConfirming ? 'confirming' : ''} ${compact ? 'compact' : ''}`}
        onClick={handleClick}
        disabled={disabled}
        aria-label={buttonAriaLabel}
        title={t('reset.tooltip')}
      >
        <span className="reset-icon" aria-hidden="true">
          ğŸ”„
        </span>
        {buttonText && <span className="reset-text">{buttonText}</span>}
      </button>

      {isConfirming && requireConfirm && (
        <button
          type="button"
          className="reset-cancel-button"
          onClick={handleCancel}
          aria-label={t('reset.cancel')}
        >
          âœ•
        </button>
      )}
    </div>
  );
}

// =============================================================================
// í”„ë¡œí•„ ë³€ê²½ ë²„íŠ¼ (ë³„ë„ ì»´í¬ë„ŒíŠ¸)
// =============================================================================

export interface ChangeProfileButtonProps {
  /** í´ë¦­ ì‹œ í˜¸ì¶œë˜ëŠ” ì½œë°± */
  onClick: () => void;
  /** ë¹„í™œì„±í™” ì—¬ë¶€ */
  disabled?: boolean;
  /** ì¶”ê°€ í´ë˜ìŠ¤ëª… */
  className?: string;
}

/**
 * í”„ë¡œí•„ ë³€ê²½ ë²„íŠ¼.
 * í´ë¦­ ì‹œ í”„ë¡œí•„ ì„ íƒ í™”ë©´ìœ¼ë¡œ ì´ë™í•©ë‹ˆë‹¤.
 */
export function ChangeProfileButton({
  onClick,
  disabled = false,
  className = '',
}: ChangeProfileButtonProps) {
  const { t } = useTranslation();

  return (
    <button
      type="button"
      className={`change-profile-button ${className}`.trim()}
      onClick={onClick}
      disabled={disabled}
      aria-label={t('profile.change')}
      title={t('profile.change_tooltip')}
    >
      <span className="change-profile-icon" aria-hidden="true">
        ğŸ‘¤
      </span>
      <span className="change-profile-text">{t('profile.change')}</span>
    </button>
  );
}
</file>

<file path="frontend/src/components/RuleBoard.tsx">
/**
 * Unknown World - Rule Board (U-013)
 *
 * í˜„ì¬ ì„¸ê³„ì— ì ìš© ì¤‘ì¸ ê·œì¹™/ë¬¼ë¦¬ ë²•ì¹™ì„ "ë£° ì¹´ë“œ"ë¡œ í‘œì‹œí•©ë‹ˆë‹¤.
 *
 * ì„¤ê³„ ì›ì¹™:
 *   - RULE-002: ì±„íŒ… UIê°€ ì•„ë‹Œ ê²Œì„ UIë¡œ ìƒì‹œ ë…¸ì¶œ
 *   - RULE-006: i18n ê¸°ë°˜ ë¬¸ìì—´ ê´€ë¦¬
 *   - PRD 6.4/6.7: Rule Mutation + Rule Board
 *
 * @module components/RuleBoard
 */

import { useTranslation } from 'react-i18next';
import { useWorldStore, selectActiveRules } from '../stores/worldStore';
import type { WorldRule } from '../schemas/turn';

// =============================================================================
// í•˜ìœ„ ì»´í¬ë„ŒíŠ¸
// =============================================================================

interface RuleCardProps {
  rule: WorldRule;
}

/**
 * ê°œë³„ ë£° ì¹´ë“œ ë Œë”ë§
 */
function RuleCard({ rule }: RuleCardProps) {
  return (
    <div className="rule-card" data-rule-id={rule.id}>
      <div className="rule-card-header">
        <span className="rule-card-icon" aria-hidden="true">
          âš™
        </span>
        <span className="rule-card-label">{rule.label}</span>
      </div>
      {rule.description && <p className="rule-card-description">{rule.description}</p>}
    </div>
  );
}

// =============================================================================
// ë©”ì¸ ì»´í¬ë„ŒíŠ¸
// =============================================================================

/**
 * Rule Board
 *
 * í˜„ì¬ ì„¸ê³„ì— ì ìš© ì¤‘ì¸ ê·œì¹™ì„ ì¹´ë“œ í˜•íƒœë¡œ í‘œì‹œí•©ë‹ˆë‹¤.
 * worldStoreì˜ activeRules ìƒíƒœë¥¼ êµ¬ë…í•˜ì—¬ ì‹¤ì‹œê°„ ì—…ë°ì´íŠ¸ë©ë‹ˆë‹¤.
 */
export function RuleBoard() {
  const { t } = useTranslation();
  const activeRules = useWorldStore(selectActiveRules);

  // ë¹ˆ ìƒíƒœ
  if (activeRules.length === 0) {
    return (
      <div className="rule-board-content rule-board-empty" data-ui-importance="critical">
        <div className="rule-board-empty-icon" aria-hidden="true">
          ğŸ“œ
        </div>
        <p className="rule-board-empty-text">{t('rule_board.empty')}</p>
      </div>
    );
  }

  return (
    <div className="rule-board-content" data-ui-importance="critical">
      <div className="rule-board-header">
        <span className="rule-board-count">
          {t('rule_board.active_count', { count: activeRules.length })}
        </span>
      </div>
      <div className="rule-card-list">
        {activeRules.map((rule) => (
          <RuleCard key={rule.id} rule={rule} />
        ))}
      </div>
    </div>
  );
}

export default RuleBoard;
</file>

<file path="frontend/src/components/UIControls.tsx">
import { useTranslation } from 'react-i18next';
import { UI_SCALES, type UIScale } from '../stores/uiPrefsStore';

interface UIControlsProps {
  uiScale: UIScale;
  onIncreaseScale: () => void;
  onDecreaseScale: () => void;
}

export function UIControls({ uiScale, onIncreaseScale, onDecreaseScale }: UIControlsProps) {
  const { t } = useTranslation();
  const isMinScale = uiScale === UI_SCALES[0];
  const isMaxScale = uiScale === UI_SCALES[UI_SCALES.length - 1];

  return (
    <div className="ui-controls" role="group" aria-label={t('ui.scale_label')}>
      {/* UI ìŠ¤ì¼€ì¼ ì¡°ì ˆ */}
      <button
        type="button"
        className="ui-scale-btn"
        onClick={onDecreaseScale}
        disabled={isMinScale}
        aria-label={t('ui.scale_decrease')}
        title={`${t('ui.scale_decrease')} (A-)`}
      >
        A-
      </button>
      <span className="ui-scale-display" aria-live="polite">
        {Math.round(uiScale * 100)}%
      </span>
      <button
        type="button"
        className="ui-scale-btn"
        onClick={onIncreaseScale}
        disabled={isMaxScale}
        aria-label={t('ui.scale_increase')}
        title={`${t('ui.scale_increase')} (A+)`}
      >
        A+
      </button>
    </div>
  );
}
</file>

<file path="frontend/src/data/demoProfiles.test.ts">
import { describe, it, expect, vi } from 'vitest';
import { PROFILE_EXPLORER, createSaveGameFromProfile, findProfileById } from './demoProfiles';
import { SAVEGAME_VERSION } from '../save/saveGame';

describe('demoProfiles (U-015[Mvp])', () => {
  const mockT = vi.fn((key: string) => `translated-${key}`);

  it('findProfileByIdëŠ” ì˜¬ë°”ë¥¸ í”„ë¡œí•„ì„ ë°˜í™˜í•´ì•¼ í•œë‹¤', () => {
    const profile = findProfileById('explorer');
    expect(profile).toBeDefined();
    expect(profile?.id).toBe('explorer');
    expect(profile?.icon).toBe('ğŸ§­');
  });

  it('ì¡´ì¬í•˜ì§€ ì•ŠëŠ” IDì— ëŒ€í•´ findProfileByIdëŠ” undefinedë¥¼ ë°˜í™˜í•´ì•¼ í•œë‹¤', () => {
    const profile = findProfileById('non-existent');
    expect(profile).toBeUndefined();
  });

  it('createSaveGameFromProfileì€ í”„ë¡œí•„ ì´ˆê¸° ìƒíƒœë¥¼ SaveGameìœ¼ë¡œ ì˜¬ë°”ë¥´ê²Œ ë³€í™˜í•´ì•¼ í•œë‹¤', () => {
    const saveGame = createSaveGameFromProfile(PROFILE_EXPLORER, 'ko-KR', mockT);

    // ê¸°ë³¸ ë©”íƒ€ë°ì´í„°
    expect(saveGame.version).toBe(SAVEGAME_VERSION);
    expect(saveGame.profileId).toBe('explorer');
    expect(saveGame.language).toBe('ko-KR');
    expect(saveGame.seed).toContain('demo-explorer-');

    // ê²½ì œ ìƒíƒœ
    expect(saveGame.economy.signal).toBe(PROFILE_EXPLORER.initialState.economy.signal);
    expect(saveGame.economy.memory_shard).toBe(PROFILE_EXPLORER.initialState.economy.memory_shard);

    // ì¸ë²¤í† ë¦¬ (ë²ˆì—­ ì ìš© í™•ì¸)
    expect(saveGame.inventory).toHaveLength(PROFILE_EXPLORER.initialState.inventoryDefs.length);
    expect(saveGame.inventory[0].name).toBe(
      `translated-${PROFILE_EXPLORER.initialState.inventoryDefs[0].nameKey}`,
    );

    // í€˜ìŠ¤íŠ¸
    expect(saveGame.quests).toHaveLength(PROFILE_EXPLORER.initialState.questDefs.length);
    expect(saveGame.quests[0].label).toBe(
      `translated-${PROFILE_EXPLORER.initialState.questDefs[0].labelKey}`,
    );

    // ê·œì¹™ ë° íƒ€ì„ë¼ì¸
    expect(saveGame.activeRules).toHaveLength(PROFILE_EXPLORER.initialState.ruleDefs.length);
    expect(saveGame.mutationTimeline).toHaveLength(PROFILE_EXPLORER.initialState.ruleDefs.length);
    expect(saveGame.mutationTimeline[0].type).toBe('added');

    // ë‚´ëŸ¬í‹°ë¸Œ (í™˜ì˜ ë©”ì‹œì§€)
    expect(saveGame.narrativeHistory).toHaveLength(1);
    expect(saveGame.narrativeHistory[0].turn).toBe(0);
    expect(saveGame.narrativeHistory[0].text).toBe(
      `translated-${PROFILE_EXPLORER.initialState.welcomeMessageKey}`,
    );

    // Scene Objects
    expect(saveGame.sceneObjects).toHaveLength(
      PROFILE_EXPLORER.initialState.sceneObjectDefs.length,
    );
    expect(saveGame.sceneObjects[0].box_2d).toEqual(
      PROFILE_EXPLORER.initialState.sceneObjectDefs[0].box_2d,
    );
  });
});
</file>

<file path="frontend/src/dnd/types.ts">
/**
 * Unknown World - DnD íƒ€ì… ë° ìƒìˆ˜ ì •ì˜ (RU-003-Q1).
 *
 * DnD ë°ì´í„° ê³„ì•½ì„ SSOTë¡œ ê´€ë¦¬í•˜ì—¬ íƒ€ì… ì•ˆì „ì„±ì„ í™•ë³´í•©ë‹ˆë‹¤.
 * ëª¨ë“  ë“œë˜ê·¸/ë“œë¡­ ì´ë²¤íŠ¸ì—ì„œ ë™ì¼í•œ ìƒìˆ˜/íƒ€ì…ì„ ì‚¬ìš©í•©ë‹ˆë‹¤.
 *
 * ì„¤ê³„ ì›ì¹™:
 *   - SSOT: ë“œë˜ê·¸/ë“œë¡­ íƒ€ì… ë¬¸ìì—´ì€ ì´ ëª¨ë“ˆì—ì„œë§Œ ì •ì˜
 *   - íƒ€ì… ì•ˆì „ì„±: dnd-kitì˜ data.currentë¥¼ íƒ€ì… ê°€ë“œë¡œ ê²€ì¦
 *   - ê³¼ë„í•œ ì¶”ìƒí™” ê¸ˆì§€: ìƒìˆ˜/íƒ€ì…ë§Œ ì œê³µ, ë¡œì§ì€ ì»´í¬ë„ŒíŠ¸ì— ìœ ì§€
 *
 * @module dnd/types
 */

import type { Box2D } from '../schemas/turn';
import type { InventoryItem } from '../stores/inventoryStore';

// =============================================================================
// DnD íƒ€ì… ìƒìˆ˜ (SSOT)
// =============================================================================

/**
 * DnD íƒ€ì… ìƒìˆ˜.
 * ë“œë˜ê·¸/ë“œë¡­ ë°ì´í„°ì˜ type í•„ë“œì— ì‚¬ìš©ë©ë‹ˆë‹¤.
 */
export const DND_TYPE = {
  /** ì¸ë²¤í† ë¦¬ ì•„ì´í…œ ë“œë˜ê·¸ */
  INVENTORY_ITEM: 'inventory-item',
  /** í•«ìŠ¤íŒŸ ë“œë¡­ íƒ€ê²Ÿ */
  HOTSPOT: 'hotspot',
} as const;

// =============================================================================
// RU-003-S2: ì¸í„°ë™ì…˜ í—ˆìš© ì •ì±… (SSOT)
// =============================================================================

/**
 * í•«ìŠ¤íŒŸ ì¸í„°ë™ì…˜ì´ í—ˆìš©ë˜ëŠ” Scene ìƒíƒœ ëª©ë¡.
 *
 * RU-003-S2 Step 1: Option A(ë°ëª¨ ìœ ì§€) ê²°ì •
 * - 'scene': ì‹¤ì œ ì¥ë©´ í™œì„±í™” ìƒíƒœ
 * - 'default': ë°ëª¨/í”Œë ˆì´ìŠ¤í™€ë” ìƒíƒœ (ì‹œê°ì  íŒíŠ¸ í•„ìš”)
 *
 * @see SceneCanvas.tsxì˜ shouldRenderHotspots ì¡°ê±´
 */
export const HOTSPOT_INTERACTION_ALLOWED_STATES = ['scene', 'default'] as const;

/**
 * ì¸í„°ë™ì…˜ í—ˆìš© ìƒíƒœ íƒ€ì….
 */
export type HotspotInteractionState = (typeof HOTSPOT_INTERACTION_ALLOWED_STATES)[number];

/**
 * ì£¼ì–´ì§„ ìƒíƒœì—ì„œ í•«ìŠ¤íŒŸ ì¸í„°ë™ì…˜ì´ í—ˆìš©ë˜ëŠ”ì§€ ê²€ì‚¬í•©ë‹ˆë‹¤.
 *
 * RU-003-S2: ì¸í„°ë™ì…˜ ê°€ëŠ¥ ì¡°ê±´ì„ SSOTë¡œ ê³ ì •
 *
 * @param status - Scene ìƒíƒœ
 * @returns ì¸í„°ë™ì…˜ í—ˆìš© ì—¬ë¶€
 */
export function isHotspotInteractionAllowed(status: string): boolean {
  return HOTSPOT_INTERACTION_ALLOWED_STATES.includes(status as HotspotInteractionState);
}

// =============================================================================
// RU-003-S2 Step 4: ìŠ¤íŠ¸ë¦¬ë° ë¹„í™œì„±í™” ì •ì±… (SSOT)
// =============================================================================

/**
 * ìŠ¤íŠ¸ë¦¬ë° ë¹„í™œì„±í™” ì •ì±….
 *
 * RU-003-S2 Step 4: disabled í”Œë˜ê·¸ì˜ SSOT ê³ ì •
 * - isStreamingì€ agentStoreì—ì„œë§Œ ì œê³µ
 * - ëª¨ë“  ì¸í„°ë™ì…˜ ì»´í¬ë„ŒíŠ¸(SceneCanvas, InventoryPanel, ActionDeck)ëŠ”
 *   ë™ì¼í•œ disabled í”Œë˜ê·¸ë¥¼ ê³µìœ í•´ì•¼ í•¨
 * - í–¥í›„ worldStore/Turn Runner ë„ì… ì‹œì—ë„ ì´ ì›ì¹™ì„ ìœ ì§€
 *
 * @see App.tsxì˜ isStreaming ì‚¬ìš© íŒ¨í„´
 * @see agentStore.tsì˜ isStreaming ìƒíƒœ
 */
export const STREAMING_DISABLED_POLICY = {
  /** ìŠ¤íŠ¸ë¦¬ë° ìƒíƒœ SSOT ì¶œì²˜ */
  source: 'agentStore.isStreaming',
  /** ë¹„í™œì„±í™” ì ìš© ëŒ€ìƒ ì»´í¬ë„ŒíŠ¸ */
  affectedComponents: ['SceneCanvas', 'InventoryPanel', 'ActionDeck', 'CommandInput'],
} as const;

/**
 * DnD íƒ€ì… ìœ ë‹ˆì˜¨.
 */
export type DndType = (typeof DND_TYPE)[keyof typeof DND_TYPE];

// =============================================================================
// ë“œë˜ê·¸ ë°ì´í„° íƒ€ì…
// =============================================================================

/**
 * ì¸ë²¤í† ë¦¬ ì•„ì´í…œ ë“œë˜ê·¸ ë°ì´í„°.
 * InventoryPanelì—ì„œ ë“œë˜ê·¸ ì‹œì‘ ì‹œ ì„¤ì •ë©ë‹ˆë‹¤.
 */
export interface InventoryDragData {
  /** ë“œë˜ê·¸ íƒ€ì… (í•­ìƒ 'inventory-item') */
  type: typeof DND_TYPE.INVENTORY_ITEM;
  /** ë“œë˜ê·¸ ì¤‘ì¸ ì•„ì´í…œ ID */
  item_id: string;
  /** ë“œë˜ê·¸ ì¤‘ì¸ ì•„ì´í…œ ê°ì²´ */
  item: InventoryItem;
}

// =============================================================================
// ë“œë¡­ ë°ì´í„° íƒ€ì…
// =============================================================================

/**
 * í•«ìŠ¤íŒŸ ë“œë¡­ íƒ€ê²Ÿ ë°ì´í„°.
 * SceneCanvasì˜ í•«ìŠ¤íŒŸì—ì„œ ì„¤ì •ë©ë‹ˆë‹¤.
 */
export interface HotspotDropData {
  /** ë“œë¡­ íƒ€ê²Ÿ íƒ€ì… (í•­ìƒ 'hotspot') */
  type: typeof DND_TYPE.HOTSPOT;
  /** í•«ìŠ¤íŒŸ ì˜¤ë¸Œì íŠ¸ ID */
  object_id: string;
  /** í•«ìŠ¤íŒŸ ë°”ìš´ë”© ë°•ìŠ¤ (0~1000 ì •ê·œí™”) */
  box_2d: Box2D;
  /** í•«ìŠ¤íŒŸ ë¼ë²¨ (í‘œì‹œìš©) */
  label: string;
}

// =============================================================================
// íƒ€ì… ê°€ë“œ í•¨ìˆ˜
// =============================================================================

/**
 * ë°ì´í„°ê°€ InventoryDragDataì¸ì§€ ê²€ì‚¬í•©ë‹ˆë‹¤.
 *
 * @param data - dnd-kitì˜ active.data.current
 * @returns InventoryDragDataì´ë©´ true
 */
export function isInventoryDragData(data: unknown): data is InventoryDragData {
  if (typeof data !== 'object' || data === null) {
    return false;
  }
  const obj = data as Record<string, unknown>;
  return (
    obj.type === DND_TYPE.INVENTORY_ITEM &&
    typeof obj.item_id === 'string' &&
    typeof obj.item === 'object' &&
    obj.item !== null
  );
}

/**
 * ë°ì´í„°ê°€ HotspotDropDataì¸ì§€ ê²€ì‚¬í•©ë‹ˆë‹¤.
 *
 * @param data - dnd-kitì˜ over.data.current
 * @returns HotspotDropDataì´ë©´ true
 */
export function isHotspotDropData(data: unknown): data is HotspotDropData {
  if (typeof data !== 'object' || data === null) {
    return false;
  }
  const obj = data as Record<string, unknown>;
  return (
    obj.type === DND_TYPE.HOTSPOT &&
    typeof obj.object_id === 'string' &&
    typeof obj.box_2d === 'object' &&
    obj.box_2d !== null &&
    typeof obj.label === 'string'
  );
}

// =============================================================================
// RU-003-S2 Step 2: í•«ìŠ¤íŒŸ ìš°ì„ ìˆœìœ„ ì •ì±… (SSOT)
// =============================================================================

/**
 * ë°”ìš´ë”© ë°•ìŠ¤ì˜ ë©´ì ì„ ê³„ì‚°í•©ë‹ˆë‹¤.
 *
 * @param box - { ymin, xmin, ymax, xmax } í˜•ì‹ì˜ ë°”ìš´ë”© ë°•ìŠ¤
 * @returns ë°•ìŠ¤ ë©´ì 
 */
export function calculateBoxArea(box: Box2D): number {
  const { ymin, xmin, ymax, xmax } = box;
  return Math.abs(ymax - ymin) * Math.abs(xmax - xmin);
}

/**
 * í•«ìŠ¤íŒŸ ìš°ì„ ìˆœìœ„ ê³„ì‚°ì„ ìœ„í•œ ë¹„êµ í•¨ìˆ˜.
 *
 * RU-003-S2 Step 2: ì‘ì€ bboxê°€ ë” ë†’ì€ ìš°ì„ ìˆœìœ„ë¥¼ ê°€ì§
 * - ë” ì‘ì€ ì˜¤ë¸Œì íŠ¸ê°€ ë” êµ¬ì²´ì ì¸ íƒ€ê²Ÿì´ë¼ê³  ê°€ì •
 * - z-index ê´€ì ì—ì„œ ì‘ì€ ê²ƒì´ ìœ„ì— ë Œë”ë˜ì–´ì•¼ í•¨
 *
 * @param a - ì²« ë²ˆì§¸ ë°”ìš´ë”© ë°•ìŠ¤
 * @param b - ë‘ ë²ˆì§¸ ë°”ìš´ë”© ë°•ìŠ¤
 * @returns ì •ë ¬ ìˆœì„œ (ì‘ì€ ê²ƒì´ ë’¤ë¡œ ê°€ì„œ z-indexê°€ ë†’ì•„ì§)
 */
export function compareHotspotPriority(a: Box2D, b: Box2D): number {
  return calculateBoxArea(b) - calculateBoxArea(a);
}
</file>

<file path="frontend/src/i18n.ts">
/**
 * Unknown World - i18n ì´ˆê¸°í™” ëª¨ë“ˆ
 *
 * ì–¸ì–´ ë¦¬ì†ŒìŠ¤ë¥¼ JSON íŒŒì¼ êµ¬ì¡°ë¡œ ê´€ë¦¬í•©ë‹ˆë‹¤.
 * RULE-006 ì¤€ìˆ˜: ko/en í˜¼í•© ì¶œë ¥ ê¸ˆì§€, i18n í‚¤ ê¸°ë°˜ SSOT
 *
 * ì–¸ì–´ ì½”ë“œ: BCP-47 í˜•ì‹ (ko-KR, en-US)
 * - TurnInput/SaveGameì˜ language í•„ë“œì™€ ë™ì¼í•œ ì¶•
 *
 * @see vibe/prd.md 3.1(ì§€ì› ì–¸ì–´), 8.7(TurnInput.language)
 * @see frontend/src/locales/README.md
 */

import i18n from 'i18next';
import { initReactI18next } from 'react-i18next';

// JSON ì–¸ì–´ ë¦¬ì†ŒìŠ¤ import (SSOT: locales/{lang}/translation.json)
import koKR from './locales/ko-KR/translation.json';
import enUS from './locales/en-US/translation.json';

/** ì§€ì› ì–¸ì–´ íƒ€ì… (TurnInput.languageì™€ ë™ê¸°í™”) */
export type SupportedLanguage = 'ko-KR' | 'en-US';

/** ê¸°ë³¸ ì–¸ì–´ (ë°ëª¨ ì¼ê´€ì„±ì„ ìœ„í•´ ko-KR ê³ ì •) */
export const DEFAULT_LANGUAGE: SupportedLanguage = 'ko-KR';

/** í´ë°± ì–¸ì–´ */
export const FALLBACK_LANGUAGE: SupportedLanguage = 'en-US';

/** ì§€ì› ì–¸ì–´ ëª©ë¡ */
export const SUPPORTED_LANGUAGES: SupportedLanguage[] = ['ko-KR', 'en-US'];

// i18n ë¦¬ì†ŒìŠ¤ ì •ì˜ (BCP-47 í˜•ì‹ ì–¸ì–´ ì½”ë“œ)
const resources = {
  'ko-KR': {
    translation: koKR,
  },
  'en-US': {
    translation: enUS,
  },
};

i18n.use(initReactI18next).init({
  resources,
  lng: DEFAULT_LANGUAGE,
  fallbackLng: FALLBACK_LANGUAGE,
  supportedLngs: SUPPORTED_LANGUAGES,
  interpolation: {
    escapeValue: false, // Reactì—ì„œ ì´ë¯¸ XSS ë°©ì§€
  },
  // ëˆ„ë½ í‚¤ ì²˜ë¦¬ (ê°œë°œ ëª¨ë“œì—ì„œ ê²½ê³ )
  saveMissing: false,
  missingKeyHandler: (_lngs, _ns, key) => {
    if (import.meta.env.DEV) {
      console.warn(`[i18n] Missing translation key: "${key}"`);
    }
  },
});

/**
 * í˜„ì¬ í•´ê²°ëœ ì–¸ì–´ ì½”ë“œë¥¼ ë°˜í™˜í•©ë‹ˆë‹¤.
 * TurnInput.languageì™€ ë™ê¸°í™”í•  ë•Œ ì‚¬ìš©í•©ë‹ˆë‹¤.
 */
export function getResolvedLanguage(): SupportedLanguage {
  return (i18n.resolvedLanguage as SupportedLanguage) || DEFAULT_LANGUAGE;
}

/**
 * ì–¸ì–´ë¥¼ ë³€ê²½í•©ë‹ˆë‹¤.
 * í–¥í›„ U-036 ì™„ë£Œ í›„ ì‚¬ìš©ìì—ê²Œ ë…¸ì¶œí•  í† ê¸€ì—ì„œ ì‚¬ìš©í•©ë‹ˆë‹¤.
 */
export async function changeLanguage(lang: SupportedLanguage): Promise<void> {
  await i18n.changeLanguage(lang);
}

export default i18n;
</file>

<file path="frontend/src/main.tsx">
import { StrictMode } from 'react';
import { createRoot } from 'react-dom/client';
import './i18n'; // i18n ì´ˆê¸°í™”
import './style.css';
import App from './App.tsx';

createRoot(document.getElementById('root')!).render(
  <StrictMode>
    <App />
  </StrictMode>,
);
</file>

<file path="frontend/src/schemas/turn.test.ts">
import { describe, it, expect } from 'vitest';
import {
  TurnInputSchema,
  TurnOutputSchema,
  safeParseTurnOutput,
  parseTurnInput,
  safeParseTurnInput,
  SCHEMA_VERSION,
} from './turn';

describe('Turn schemas', () => {
  describe('SCHEMA_VERSION', () => {
    it('should have correct version', () => {
      expect(SCHEMA_VERSION).toBe('1.0.0');
    });
  });

  describe('TurnInputSchema', () => {
    const validTurnInput = {
      language: 'ko-KR',
      text: 'í…ŒìŠ¤íŠ¸ ì…ë ¥',
      client: {
        viewport_w: 1920,
        viewport_h: 1080,
        theme: 'dark',
      },
      economy_snapshot: {
        signal: 100,
        memory_shard: 5,
      },
    };

    it('should validate a valid TurnInput', () => {
      const result = TurnInputSchema.safeParse(validTurnInput);
      expect(result.success).toBe(true);
    });

    it('should fail on invalid language', () => {
      const result = TurnInputSchema.safeParse({
        ...validTurnInput,
        language: 'fr-FR',
      });
      expect(result.success).toBe(false);
    });

    it('should fail on negative economy values', () => {
      const result = TurnInputSchema.safeParse({
        ...validTurnInput,
        economy_snapshot: {
          signal: -1,
          memory_shard: 0,
        },
      });
      expect(result.success).toBe(false);
    });

    it('should fail on extra fields (strict)', () => {
      const result = TurnInputSchema.safeParse({
        ...validTurnInput,
        extra_field: 'not allowed',
      });
      expect(result.success).toBe(false);
    });

    it('should validate click input with bbox', () => {
      const result = TurnInputSchema.safeParse({
        ...validTurnInput,
        click: {
          object_id: 'door_01',
          box_2d: {
            ymin: 100,
            xmin: 100,
            ymax: 500,
            xmax: 500,
          },
        },
      });
      expect(result.success).toBe(true);
    });

    it('should fail on invalid bbox coordinates (out of range 0-1000)', () => {
      const result = TurnInputSchema.safeParse({
        ...validTurnInput,
        click: {
          object_id: 'door_01',
          box_2d: {
            ymin: -1,
            xmin: 0,
            ymax: 1001,
            xmax: 500,
          },
        },
      });
      expect(result.success).toBe(false);
    });

    it('should fail on non-positive viewport dimensions', () => {
      const result = TurnInputSchema.safeParse({
        ...validTurnInput,
        client: {
          viewport_w: 0,
          viewport_h: -100,
          theme: 'dark',
        },
      });
      expect(result.success).toBe(false);
    });

    it('should fail on non-integer coordinates', () => {
      const result = TurnInputSchema.safeParse({
        ...validTurnInput,
        click: {
          object_id: 'obj',
          box_2d: {
            ymin: 10.5,
            xmin: 20,
            ymax: 30,
            xmax: 40,
          },
        },
      });
      expect(result.success).toBe(false);
    });
  });

  describe('TurnOutputSchema', () => {
    const validTurnOutput = {
      language: 'ko-KR',
      narrative: 'í…ŒìŠ¤íŠ¸ ë‚´ëŸ¬í‹°ë¸Œ',
      economy: {
        cost: { signal: 5, memory_shard: 0 },
        balance_after: { signal: 95, memory_shard: 5 },
      },
      safety: {
        blocked: false,
      },
      agent_console: {
        current_phase: 'commit',
        badges: ['schema_ok', 'economy_ok'],
        repair_count: 0,
      },
    };

    it('should validate a valid TurnOutput', () => {
      const result = TurnOutputSchema.safeParse(validTurnOutput);
      expect(result.success).toBe(true);
    });

    it('should fail if required fields are missing', () => {
      const { narrative: _narrative, ...invalidOutput } = validTurnOutput;
      const result = TurnOutputSchema.safeParse(invalidOutput);
      expect(result.success).toBe(false);
    });

    it('should handle default values for optional fields', () => {
      const result = TurnOutputSchema.safeParse(validTurnOutput);
      if (result.success) {
        expect(result.data.ui).toBeDefined();
        expect(result.data.ui.action_deck.cards).toEqual([]);
        expect(result.data.world.rules_changed).toEqual([]);
      } else {
        throw new Error('Validation failed');
      }
    });

    it('should fail if there are too many action cards (max 10)', () => {
      const cards = Array.from({ length: 11 }, (_, i) => ({
        id: `card_${i}`,
        label: `Card ${i}`,
        cost: { signal: 0, memory_shard: 0 },
        risk: 'low',
      }));
      const result = TurnOutputSchema.safeParse({
        ...validTurnOutput,
        ui: {
          action_deck: { cards },
        },
      });
      expect(result.success).toBe(false);
    });

    it('should fail on negative repair_count', () => {
      const result = TurnOutputSchema.safeParse({
        ...validTurnOutput,
        agent_console: {
          current_phase: 'commit',
          badges: [],
          repair_count: -1,
        },
      });
      expect(result.success).toBe(false);
    });
  });

  describe('safeParseTurnOutput', () => {
    it('should return success for valid data', () => {
      const validTurnOutput = {
        language: 'en-US',
        narrative: 'Test narrative',
        economy: {
          cost: { signal: 0, memory_shard: 0 },
          balance_after: { signal: 100, memory_shard: 0 },
        },
        safety: { blocked: false },
      };
      const result = safeParseTurnOutput(validTurnOutput);
      expect(result.success).toBe(true);
      if (result.success) {
        expect(result.data.language).toBe('en-US');
      }
    });

    it('should return fallback for invalid data', () => {
      const invalidData = { some: 'garbage' };
      const result = safeParseTurnOutput(invalidData, 'ko-KR', 1);
      expect(result.success).toBe(false);
      if (!result.success) {
        expect(result.fallback).toBeDefined();
        expect(result.fallback.language).toBe('ko-KR');
        expect(result.fallback.agent_console.badges).toContain('schema_fail');
        expect(result.fallback.agent_console.repair_count).toBe(1);
      }
    });
  });

  describe('Input Parsing Utilities', () => {
    const validTurnInput = {
      language: 'ko-KR',
      text: 'í…ŒìŠ¤íŠ¸ ì…ë ¥',
      client: {
        viewport_w: 1920,
        viewport_h: 1080,
        theme: 'dark',
      },
      economy_snapshot: {
        signal: 100,
        memory_shard: 5,
      },
    };

    describe('parseTurnInput', () => {
      it('should parse valid input', () => {
        const result = parseTurnInput(validTurnInput);
        expect(result.text).toBe('í…ŒìŠ¤íŠ¸ ì…ë ¥');
      });

      it('should throw error for invalid input', () => {
        expect(() => parseTurnInput({})).toThrow();
      });
    });

    describe('safeParseTurnInput', () => {
      it('should return success for valid input', () => {
        const result = safeParseTurnInput(validTurnInput);
        expect(result.success).toBe(true);
      });

      it('should return failure for invalid input', () => {
        const result = safeParseTurnInput({});
        expect(result.success).toBe(false);
      });
    });
  });
});
</file>

<file path="frontend/src/schemas/verify_runbook.ts">
import {
  TurnOutputSchema,
  safeParseTurnOutput,
  Box2DSchema,
  CurrencyAmountSchema,
  LanguageSchema,
  parseTurnInput,
} from './turn.js';

console.log('--- Scenario A: TurnOutput ìŠ¤í‚¤ë§ˆ ê²€ì¦ (ì •ìƒ ì¼€ì´ìŠ¤) ---');
const validOutput = {
  language: 'ko-KR',
  narrative: 'ë¬¸ì´ ì‚ê±±ê±°ë¦¬ë©° ì—´ë¦½ë‹ˆë‹¤...',
  economy: {
    cost: { signal: 5, memory_shard: 0 },
    balance_after: { signal: 95, memory_shard: 5 },
  },
  safety: { blocked: false, message: null },
};
const resultA = safeParseTurnOutput(validOutput);
console.log('Success:', resultA.success);
if (resultA.success) {
  console.log('Data (sample):', resultA.data.narrative);
}

console.log('\n--- Scenario B: TurnOutput ìŠ¤í‚¤ë§ˆ ê²€ì¦ ì‹¤íŒ¨ â†’ í´ë°± ---');
const invalidOutput = {
  language: 'ko-KR',
  narrative: 'í…ŒìŠ¤íŠ¸',
};
// eslint-disable-next-line @typescript-eslint/no-explicit-any
const resultB = safeParseTurnOutput(invalidOutput as any);
console.log('Success:', resultB.success);
if (!resultB.success) {
  console.log('Error count:', resultB.error.issues.length);
  console.log('Fallback exists:', !!resultB.fallback);
  console.log(
    'Fallback badges has schema_fail:',
    resultB.fallback?.agent_console?.badges?.includes('schema_fail'),
  );
}

console.log('\n--- Scenario C: ì¢Œí‘œ ë²”ìœ„ ê²€ì¦ (RULE-009) ---');
const validBox = { ymin: 100, xmin: 200, ymax: 300, xmax: 400 };
console.log('Valid box:', Box2DSchema.safeParse(validBox).success);
const invalidBox = { ymin: 100, xmin: 200, ymax: 1500, xmax: 400 };
console.log('Invalid box (1500):', Box2DSchema.safeParse(invalidBox).success);
const negativeBox = { ymin: -10, xmin: 200, ymax: 300, xmax: 400 };
console.log('Negative box:', Box2DSchema.safeParse(negativeBox).success);

console.log('\n--- Scenario D: ì¬í™” ì¸ë°”ë¦¬ì–¸íŠ¸ ê²€ì¦ (RULE-005) ---');
const validCurrency = { signal: 100, memory_shard: 5 };
console.log('Valid currency:', CurrencyAmountSchema.safeParse(validCurrency).success);
const negativeCurrency = { signal: -10, memory_shard: 5 };
console.log('Negative signal:', CurrencyAmountSchema.safeParse(negativeCurrency).success);

console.log('\n--- Scenario E: ì–¸ì–´ ì •ì±… ê²€ì¦ (RULE-006) ---');
console.log('ko-KR:', LanguageSchema.safeParse('ko-KR').success);
console.log('en-US:', LanguageSchema.safeParse('en-US').success);
console.log('ja-JP (invalid):', LanguageSchema.safeParse('ja-JP').success);
console.log('ko (invalid format):', LanguageSchema.safeParse('ko').success);

console.log('\n--- Scenario F: TurnInput ê²€ì¦ ---');
const validInput = {
  language: 'ko-KR',
  text: 'ë¬¸ì„ ì—´ì–´ë³¸ë‹¤',
  client: {
    viewport_w: 1920,
    viewport_h: 1080,
    theme: 'dark',
  },
  economy_snapshot: {
    signal: 100,
    memory_shard: 5,
  },
};
try {
  // eslint-disable-next-line @typescript-eslint/no-explicit-any
  const parsed = parseTurnInput(validInput as any);
  console.log('Parsed successfully:', parsed.text);
} catch (e) {
  console.log('Parse error:', e);
}

console.log('\n--- Scenario G: Strict ëª¨ë“œ ê²€ì¦ ---');
const outputWithExtra = {
  language: 'ko-KR',
  narrative: 'í…ŒìŠ¤íŠ¸',
  economy: {
    cost: { signal: 0, memory_shard: 0 },
    balance_after: { signal: 100, memory_shard: 5 },
  },
  safety: { blocked: false, message: null },
  unknown_field: 'ì´ í•„ë“œëŠ” ìŠ¤í‚¤ë§ˆì— ì—†ìŒ',
};
const resultG = TurnOutputSchema.safeParse(outputWithExtra);
console.log('With extra field success:', resultG.success);
if (!resultG.success) {
  console.log('Error code:', resultG.error.issues[0].code);
}
</file>

<file path="frontend/src/stores/uiPrefsStore.test.ts">
import { describe, it, expect, beforeEach } from 'vitest';
import { useUIPrefsStore, DEFAULT_UI_SCALE, migrateUIPrefs } from './uiPrefsStore';

// Mock localStorage for non-browser environment
// Note: With jsdom environment configured in vite.config.ts, this might not be strictly necessary
// if we trust jsdom's localStorage, but keeping it explicit is fine.
// However, since we are moving to direct function testing for migration, we rely less on persist middleware internals.

describe('uiPrefsStore', () => {
  beforeEach(() => {
    useUIPrefsStore.getState().resetPrefs();
    localStorage.clear();
  });

  it('should have default initial state', () => {
    const state = useUIPrefsStore.getState();
    expect(state.uiScale).toBe(DEFAULT_UI_SCALE);
  });

  it('should increase ui scale within limit', () => {
    const { increaseUIScale } = useUIPrefsStore.getState();

    // 1.0 -> 1.1
    increaseUIScale();
    expect(useUIPrefsStore.getState().uiScale).toBe(1.1);

    // 1.1 -> 1.2
    increaseUIScale();
    expect(useUIPrefsStore.getState().uiScale).toBe(1.2);

    // 1.2 -> 1.2 (Max)
    increaseUIScale();
    expect(useUIPrefsStore.getState().uiScale).toBe(1.2);
  });

  it('should decrease ui scale within limit', () => {
    const { decreaseUIScale, setUIScale } = useUIPrefsStore.getState();

    // Start at max
    setUIScale(1.2);

    // 1.2 -> 1.1
    decreaseUIScale();
    expect(useUIPrefsStore.getState().uiScale).toBe(1.1);

    // ... -> 0.9 (Min)
    setUIScale(0.9);
    decreaseUIScale();
    expect(useUIPrefsStore.getState().uiScale).toBe(0.9);
  });

  it('should set valid ui scale', () => {
    const { setUIScale } = useUIPrefsStore.getState();

    setUIScale(1.1);
    expect(useUIPrefsStore.getState().uiScale).toBe(1.1);
  });

  it('should ignore invalid ui scale', () => {
    const { setUIScale } = useUIPrefsStore.getState();

    // @ts-expect-error Testing invalid input
    setUIScale(2.0);
    expect(useUIPrefsStore.getState().uiScale).toBe(DEFAULT_UI_SCALE);
  });

  describe('migration (U-037)', () => {
    it('should remove readableMode from legacy storage', () => {
      // Legacy state simulation
      const legacyState = {
        uiScale: 1.1,
        readableMode: true,
      };

      // Call migrate function directly
      const migratedState = migrateUIPrefs(legacyState, 0);

      // Verify
      expect(migratedState).toHaveProperty('uiScale', 1.1);
      expect(migratedState).not.toHaveProperty('readableMode');
    });

    it('should handle undefined version (very old legacy)', () => {
      const legacyState = {
        uiScale: 0.9,
        readableMode: false,
      };

      // Call migrate function directly with undefined version
      const migratedState = migrateUIPrefs(legacyState, undefined);

      expect(migratedState).toHaveProperty('uiScale', 0.9);
      expect(migratedState).not.toHaveProperty('readableMode');
    });

    it('should pass through already migrated state', () => {
      const modernState = {
        uiScale: 1.0,
      };

      const migratedState = migrateUIPrefs(modernState, 1);
      expect(migratedState).toEqual(modernState);
    });
  });
});
</file>

<file path="frontend/src/stores/uiPrefsStore.ts">
/**
 * Unknown World - UI ì„¤ì • ìƒíƒœ ê´€ë¦¬ (Zustand + persist).
 *
 * UI ìŠ¤ì¼€ì¼ ì„¤ì •ì„ ì €ì¥í•˜ê³ , SaveGame êµ¬ì¡°ì™€ í†µí•© ê°€ëŠ¥í•˜ë„ë¡ ì§ë ¬í™” ì¸í„°í˜ì´ìŠ¤ë¥¼ ì œê³µí•©ë‹ˆë‹¤.
 *
 * ì„¤ê³„ ì›ì¹™:
 *   - PRD 9.4: ê°€ë…ì„±(í•„ìˆ˜) - ì „ì—­ UI ìŠ¤ì¼€ì¼ ì¡°ì ˆ ì œê³µ
 *   - U-037: Readable ëª¨ë“œ ì œê±° â†’ critical/ambient ì¤‘ìš”ë„ ê¸°ë°˜ ìŠ¤íƒ€ì¼ë¡œ ëŒ€ì²´
 *   - Q1 ê²°ì •: Option B (SaveGameì— í¬í•¨) - persist + ì§ë ¬í™”
 *
 * @module stores/uiPrefsStore
 */

import { create } from 'zustand';
import { persist, createJSONStorage } from 'zustand/middleware';

// =============================================================================
// ìƒìˆ˜ ì •ì˜
// =============================================================================

/** ì§€ì›í•˜ëŠ” UI ìŠ¤ì¼€ì¼ ê°’ */
export const UI_SCALES = [0.9, 1.0, 1.1, 1.2] as const;
export type UIScale = (typeof UI_SCALES)[number];

/** ê¸°ë³¸ UI ìŠ¤ì¼€ì¼ */
export const DEFAULT_UI_SCALE: UIScale = 1.0;

/** localStorage í‚¤ (SaveGame í†µí•© ì‹œì—ë„ ì‚¬ìš© ê°€ëŠ¥) */
export const UI_PREFS_STORAGE_KEY = 'unknown-world-ui-prefs';

// =============================================================================
// ìƒíƒœ íƒ€ì… ì •ì˜
// =============================================================================

/** UI ì„¤ì • ìƒíƒœ (SaveGame ì§ë ¬í™” ëŒ€ìƒ) */
export interface UIPrefsState {
  /**
   * UI ìŠ¤ì¼€ì¼ (0.9 ~ 1.2)
   * - 0.9: ì‘ì€ UI (ì •ë³´ ë°€ë„ ë†’ìŒ)
   * - 1.0: ê¸°ë³¸
   * - 1.1: ì•½ê°„ í™•ëŒ€
   * - 1.2: í° UI (ê°€ë…ì„± ìš°ì„ )
   */
  uiScale: UIScale;
}

/** UI ì„¤ì • ì•¡ì…˜ */
export interface UIPrefsActions {
  /** UI ìŠ¤ì¼€ì¼ ì„¤ì • */
  setUIScale: (scale: UIScale) => void;

  /** UI ìŠ¤ì¼€ì¼ ì¦ê°€ (ìµœëŒ€ 1.2) */
  increaseUIScale: () => void;

  /** UI ìŠ¤ì¼€ì¼ ê°ì†Œ (ìµœì†Œ 0.9) */
  decreaseUIScale: () => void;

  /** ì„¤ì • ì´ˆê¸°í™” */
  resetPrefs: () => void;

  /**
   * SaveGame ì§ë ¬í™”ìš© ìƒíƒœ ì¶”ì¶œ
   * (ì¶”í›„ SaveGame í†µí•© ì‹œ ì‚¬ìš©)
   */
  getSerializableState: () => UIPrefsState;

  /**
   * SaveGame ì—­ì§ë ¬í™”ìš© ìƒíƒœ ë³µì›
   * (ì¶”í›„ SaveGame í†µí•© ì‹œ ì‚¬ìš©)
   */
  restoreState: (state: Partial<UIPrefsState>) => void;
}

export type UIPrefsStore = UIPrefsState & UIPrefsActions;

// =============================================================================
// ì´ˆê¸° ìƒíƒœ
// =============================================================================

/** ì´ˆê¸° ìƒíƒœ ìƒì„± */
function createInitialState(): UIPrefsState {
  return {
    uiScale: DEFAULT_UI_SCALE,
  };
}

// =============================================================================
// ìœ í‹¸ë¦¬í‹° í•¨ìˆ˜
// =============================================================================

/**
 * ì£¼ì–´ì§„ ìŠ¤ì¼€ì¼ì´ ìœ íš¨í•œì§€ í™•ì¸
 */
function isValidScale(scale: number): scale is UIScale {
  return UI_SCALES.includes(scale as UIScale);
}

/**
 * ìŠ¤ì¼€ì¼ ì¸ë±ìŠ¤ ë°˜í™˜
 */
function getScaleIndex(scale: UIScale): number {
  return UI_SCALES.indexOf(scale);
}

/**
 * U-037: legacy ì €ì¥ê°’(readableMode) ë§ˆì´ê·¸ë ˆì´ì…˜/ë¬´ì‹œ
 * @internal exported for testing
 */
export function migrateUIPrefs(persistedState: unknown, version: number | undefined): UIPrefsState {
  // version 0 ë˜ëŠ” undefinedì—ì„œ version 1ë¡œ ë§ˆì´ê·¸ë ˆì´ì…˜
  // readableMode í•„ë“œê°€ ìˆìœ¼ë©´ ì œê±°
  if (version === 0 || version === undefined) {
    const state = persistedState as Record<string, unknown>;
    // readableMode í•„ë“œ ì œê±° (ë¬´ì‹œ)
    if ('readableMode' in state) {
      const { readableMode: _, ...rest } = state;
      return { ...rest, uiScale: state.uiScale ?? DEFAULT_UI_SCALE } as UIPrefsState;
    }
    return { ...state, uiScale: state.uiScale ?? DEFAULT_UI_SCALE } as UIPrefsState;
  }
  return persistedState as UIPrefsState;
}

// =============================================================================
// Zustand Store with persist
// =============================================================================

/**
 * UI ì„¤ì • ìŠ¤í† ì–´.
 *
 * U-037: Readable ëª¨ë“œ ì œê±°ë¨. CRT íš¨ê³¼ëŠ” critical/ambient ì¤‘ìš”ë„ ê¸°ë°˜ìœ¼ë¡œ ìë™ ì ìš©ë©ë‹ˆë‹¤.
 *
 * @example
 * ```tsx
 * // ì»´í¬ë„ŒíŠ¸ì—ì„œ ì‚¬ìš©
 * const { uiScale, setUIScale } = useUIPrefsStore();
 *
 * // DOM ì ìš© (App.tsxì—ì„œ)
 * useEffect(() => {
 *   document.documentElement.dataset.uiScale = uiScale.toString();
 *   document.documentElement.style.setProperty('--ui-scale-factor', uiScale.toString());
 * }, [uiScale]);
 * ```
 */
export const useUIPrefsStore = create<UIPrefsStore>()(
  persist(
    (set, get) => ({
      // ì´ˆê¸° ìƒíƒœ
      ...createInitialState(),

      // ì•¡ì…˜
      setUIScale: (scale) => {
        if (isValidScale(scale)) {
          set({ uiScale: scale });
        }
      },

      increaseUIScale: () => {
        const currentIndex = getScaleIndex(get().uiScale);
        const nextIndex = Math.min(currentIndex + 1, UI_SCALES.length - 1);
        set({ uiScale: UI_SCALES[nextIndex] });
      },

      decreaseUIScale: () => {
        const currentIndex = getScaleIndex(get().uiScale);
        const prevIndex = Math.max(currentIndex - 1, 0);
        set({ uiScale: UI_SCALES[prevIndex] });
      },

      resetPrefs: () => {
        set(createInitialState());
      },

      getSerializableState: () => {
        const { uiScale } = get();
        return { uiScale };
      },

      restoreState: (state) => {
        const updates: Partial<UIPrefsState> = {};

        if (state.uiScale !== undefined && isValidScale(state.uiScale)) {
          updates.uiScale = state.uiScale;
        }

        if (Object.keys(updates).length > 0) {
          set(updates);
        }
      },
    }),
    {
      name: UI_PREFS_STORAGE_KEY,
      storage: createJSONStorage(() => localStorage),
      // ì§ë ¬í™”í•  í•„ë“œ ì§€ì • (ì•¡ì…˜ ì œì™¸)
      partialize: (state) => ({
        uiScale: state.uiScale,
      }),
      // U-037: legacy ì €ì¥ê°’(readableMode) ë§ˆì´ê·¸ë ˆì´ì…˜/ë¬´ì‹œ
      version: 1,
      migrate: migrateUIPrefs,
    },
  ),
);

// =============================================================================
// ì…€ë ‰í„° (ì„±ëŠ¥ ìµœì í™”ìš©)
// =============================================================================

/** UI ìŠ¤ì¼€ì¼ ì…€ë ‰í„° */
export const selectUIScale = (state: UIPrefsStore) => state.uiScale;

// =============================================================================
// DOM ì ìš© í—¬í¼
// =============================================================================

/**
 * CSS ë³€ìˆ˜ë¡œ UI ìŠ¤ì¼€ì¼ ì ìš©
 * í˜¸ì¶œ ì‹œ html ìš”ì†Œì— --ui-scale-factor ë³€ìˆ˜ë¥¼ ì„¤ì •
 */
export function applyUIScaleToDOM(scale: UIScale): void {
  document.documentElement.style.setProperty('--ui-scale-factor', scale.toString());
  document.documentElement.dataset.uiScale = scale.toString();
}

/**
 * ì „ì²´ UI ì„¤ì • DOM ì ìš©
 * U-037: readableMode ì œê±°ë¨ - ìŠ¤ì¼€ì¼ë§Œ ì ìš©
 */
export function applyUIPrefsToDOM(state: UIPrefsState): void {
  applyUIScaleToDOM(state.uiScale);
}
</file>

<file path="frontend/src/types/turn_stream.ts">
/**
 * Unknown World - Turn Stream ì´ë²¤íŠ¸ ê³„ì•½(Contract).
 *
 * NDJSON ìŠ¤íŠ¸ë¦¬ë°ì—ì„œ ì‚¬ìš©ë˜ëŠ” ì´ë²¤íŠ¸ íƒ€ì…, ì¸í„°í˜ì´ìŠ¤ë¥¼ ì •ì˜í•©ë‹ˆë‹¤.
 * ì´ ëª¨ë“ˆì€ ë°±ì—”ë“œì™€ í”„ë¡ íŠ¸ì—”ë“œ ê°„ì˜ ìŠ¤íŠ¸ë¦¼ ì´ë²¤íŠ¸ ê³„ì•½ SSOTì…ë‹ˆë‹¤.
 *
 * ì„¤ê³„ ì›ì¹™:
 *   - RU-002-Q4: ì´ë²¤íŠ¸ ê³„ì•½ì„ transport ê³„ì¸µìœ¼ë¡œ ë¶„ë¦¬
 *   - RU-002-S2: ì´ë²¤íŠ¸ë³„ Zod ê²€ì¦ + Unknown/í™•ì¥ ì´ë²¤íŠ¸ í´ë°±
 *   - RULE-003: êµ¬ì¡°í™” ì¶œë ¥(JSON Schema) ìš°ì„  + ì´ì¤‘ ê²€ì¦
 *   - RULE-008: ë‹¨ê³„/ë°°ì§€ ê°€ì‹œí™”
 *
 * ì°¸ì¡°:
 *   - vibe/unit-plans/U-007[Mvp].md
 *   - vibe/refactors/RU-002-Q4.md
 *   - vibe/refactors/RU-002-S2.md
 *
 * @module types/turn_stream
 */

import { z } from 'zod';
import {
  AgentPhaseSchema,
  ValidationBadgeSchema,
  type TurnOutput,
  type AgentPhase,
  type ValidationBadge,
} from '../schemas/turn';

// =============================================================================
// ìŠ¤íŠ¸ë¦¼ ì´ë²¤íŠ¸ íƒ€ì… ìƒìˆ˜ (ì„œë²„ ê³„ì•½ê³¼ ì¼ì¹˜)
// =============================================================================

/** ìŠ¤íŠ¸ë¦¼ ì´ë²¤íŠ¸ íƒ€ì… ìƒìˆ˜ */
export const StreamEventType = {
  STAGE: 'stage',
  BADGES: 'badges',
  NARRATIVE_DELTA: 'narrative_delta',
  FINAL: 'final',
  ERROR: 'error',
  REPAIR: 'repair',
} as const;

export type StreamEventTypeName = (typeof StreamEventType)[keyof typeof StreamEventType];

/**
 * ë‹¨ê³„ ìƒíƒœ ìƒìˆ˜.
 * RU-002-S2/RU-002-Q2: v1(complete) ë° v2(ok/fail) ë³„ì¹­ ëª¨ë‘ ì§€ì›.
 */
export const StageStatus = {
  START: 'start',
  COMPLETE: 'complete',
  /** ë‹¨ê³„ ì‹¤íŒ¨ */
  FAIL: 'fail',
} as const;

export type StageStatusName = (typeof StageStatus)[keyof typeof StageStatus];

// =============================================================================
// RU-002-S2: ì´ë²¤íŠ¸ë³„ Zod ìŠ¤í‚¤ë§ˆ (ê²½ëŸ‰ ê²€ì¦ + í´ë°±)
// =============================================================================

/**
 * stage.status ìŠ¤í‚¤ë§ˆ.
 * v1(complete) ë° v2(ok/fail) ë³„ì¹­ ëª¨ë‘ í—ˆìš©.
 */
export const StageStatusSchema = z.enum(['start', 'complete', 'ok', 'fail']);

/**
 * StageEvent Zod ìŠ¤í‚¤ë§ˆ.
 * ë‹¨ê³„ ì§„í–‰ ì´ë²¤íŠ¸ ê²€ì¦ìš©.
 */
export const StageEventSchema = z.object({
  type: z.literal(StreamEventType.STAGE),
  name: AgentPhaseSchema,
  status: StageStatusSchema,
});

/**
 * RepairEvent Zod ìŠ¤í‚¤ë§ˆ.
 * ìë™ ë³µêµ¬ ì‹œë„ ì´ë²¤íŠ¸ ê²€ì¦ìš©.
 */
export const RepairEventSchema = z.object({
  type: z.literal(StreamEventType.REPAIR),
  attempt: z.number(),
  message: z.string().optional(),
});

/**
 * BadgesEvent Zod ìŠ¤í‚¤ë§ˆ (v1: ë°°ì—´).
 * v1ì€ badges: string[] í˜•ì‹.
 */
export const BadgesEventSchemaV1 = z.object({
  type: z.literal(StreamEventType.BADGES),
  badges: z.array(ValidationBadgeSchema),
});

/**
 * BadgesEvent Zod ìŠ¤í‚¤ë§ˆ (v2: ê°ì²´/ë§µ).
 * í–¥í›„ v2ëŠ” badges: { [key]: status } í˜•ì‹ì„ ì§€ì›í•  ìˆ˜ ìˆìŒ.
 * í˜„ì¬ëŠ” v1ë§Œ ì‚¬ìš©í•˜ë¯€ë¡œ ì´ ìŠ¤í‚¤ë§ˆëŠ” í™•ì¥ì„±ì„ ìœ„í•´ ì •ì˜.
 */
export const BadgesEventSchemaV2 = z.object({
  type: z.literal(StreamEventType.BADGES),
  badges: z.record(z.string(), z.boolean()),
});

/**
 * BadgesEvent í†µí•© ìŠ¤í‚¤ë§ˆ.
 * v1(ë°°ì—´) ë˜ëŠ” v2(ê°ì²´) ëª¨ë‘ í—ˆìš©.
 */
export const BadgesEventSchema = z.union([BadgesEventSchemaV1, BadgesEventSchemaV2]);

/**
 * NarrativeDeltaEvent Zod ìŠ¤í‚¤ë§ˆ.
 * íƒ€ì íš¨ê³¼ìš© ë‚´ëŸ¬í‹°ë¸Œ ë¸íƒ€ ì´ë²¤íŠ¸ ê²€ì¦ìš©.
 */
export const NarrativeDeltaEventSchema = z.object({
  type: z.literal(StreamEventType.NARRATIVE_DELTA),
  text: z.string(),
});

/**
 * FinalEvent ì›ì‹œ ìŠ¤í‚¤ë§ˆ.
 * v1(data) ë° v2(turn_output) ë³„ì¹­ ëª¨ë‘ í—ˆìš©.
 * TurnOutput ìì²´ ê²€ì¦ì€ turnStream.tsì—ì„œ safeParseTurnOutputìœ¼ë¡œ ìˆ˜í–‰.
 */
export const FinalEventRawSchema = z.object({
  type: z.literal(StreamEventType.FINAL),
  data: z.unknown(),
});

/**
 * ErrorEvent Zod ìŠ¤í‚¤ë§ˆ.
 * ì—ëŸ¬ ì´ë²¤íŠ¸ ê²€ì¦ìš©.
 */
export const ErrorEventSchema = z.object({
  type: z.literal(StreamEventType.ERROR),
  message: z.string(),
  code: z.string().optional(),
});

/**
 * ì´ë²¤íŠ¸ íƒ€ì… ì¶”ì¶œìš© ìµœì†Œ ìŠ¤í‚¤ë§ˆ.
 * Unknown ì´ë²¤íŠ¸ íŒë³„ì— ì‚¬ìš©.
 */
export const BaseEventSchema = z.object({
  type: z.string(),
});

// =============================================================================
// ì´ë²¤íŠ¸ íŒŒì‹± ìœ í‹¸ë¦¬í‹° (RU-002-S2)
// =============================================================================

/** ì´ë²¤íŠ¸ ê²€ì¦ ê²°ê³¼ íƒ€ì… */
export type EventParseResult<T> =
  | { success: true; data: T }
  | { success: false; error: z.ZodError };

/**
 * StageEventë¥¼ ì•ˆì „í•˜ê²Œ íŒŒì‹±í•©ë‹ˆë‹¤.
 */
export function safeParseStageEvent(
  data: unknown,
): EventParseResult<z.infer<typeof StageEventSchema>> {
  const result = StageEventSchema.safeParse(data);
  return result.success
    ? { success: true, data: result.data }
    : { success: false, error: result.error };
}

/**
 * RepairEventë¥¼ ì•ˆì „í•˜ê²Œ íŒŒì‹±í•©ë‹ˆë‹¤.
 */
export function safeParseRepairEvent(
  data: unknown,
): EventParseResult<z.infer<typeof RepairEventSchema>> {
  const result = RepairEventSchema.safeParse(data);
  return result.success
    ? { success: true, data: result.data }
    : { success: false, error: result.error };
}

/**
 * BadgesEventë¥¼ ì•ˆì „í•˜ê²Œ íŒŒì‹±í•©ë‹ˆë‹¤.
 * v1(ë°°ì—´) í˜•íƒœë¡œ ì •ê·œí™”í•˜ì—¬ ë°˜í™˜í•©ë‹ˆë‹¤.
 */
export function safeParseBadgesEvent(data: unknown): EventParseResult<BadgesEvent> {
  const result = BadgesEventSchema.safeParse(data);
  if (!result.success) {
    return { success: false, error: result.error };
  }

  // v2(ê°ì²´) í˜•íƒœì¸ ê²½ìš° v1(ë°°ì—´)ë¡œ ì •ê·œí™”
  const parsed = result.data;
  if (Array.isArray(parsed.badges)) {
    // v1 í˜•íƒœ: ê·¸ëŒ€ë¡œ ë°˜í™˜
    return {
      success: true,
      data: { type: StreamEventType.BADGES, badges: parsed.badges as ValidationBadge[] },
    };
  } else {
    // v2 í˜•íƒœ: trueì¸ í‚¤ë§Œ ì¶”ì¶œí•˜ì—¬ ë°°ì—´ë¡œ ë³€í™˜
    const badgeArray = Object.entries(parsed.badges)
      .filter(([, value]) => value)
      .map(([key]) => key as ValidationBadge);
    return {
      success: true,
      data: { type: StreamEventType.BADGES, badges: badgeArray },
    };
  }
}

/**
 * NarrativeDeltaEventë¥¼ ì•ˆì „í•˜ê²Œ íŒŒì‹±í•©ë‹ˆë‹¤.
 */
export function safeParseNarrativeDeltaEvent(
  data: unknown,
): EventParseResult<z.infer<typeof NarrativeDeltaEventSchema>> {
  const result = NarrativeDeltaEventSchema.safeParse(data);
  return result.success
    ? { success: true, data: result.data }
    : { success: false, error: result.error };
}

/**
 * FinalEvent ì›ì‹œ í˜•íƒœë¥¼ ì•ˆì „í•˜ê²Œ íŒŒì‹±í•©ë‹ˆë‹¤.
 * TurnOutput ìì²´ ê²€ì¦ì€ ë³„ë„ë¡œ ìˆ˜í–‰í•´ì•¼ í•©ë‹ˆë‹¤.
 */
export function safeParseFinalEventRaw(
  data: unknown,
): EventParseResult<z.infer<typeof FinalEventRawSchema>> {
  const result = FinalEventRawSchema.safeParse(data);
  return result.success
    ? { success: true, data: result.data }
    : { success: false, error: result.error };
}

/**
 * ErrorEventë¥¼ ì•ˆì „í•˜ê²Œ íŒŒì‹±í•©ë‹ˆë‹¤.
 */
export function safeParseErrorEvent(
  data: unknown,
): EventParseResult<z.infer<typeof ErrorEventSchema>> {
  const result = ErrorEventSchema.safeParse(data);
  return result.success
    ? { success: true, data: result.data }
    : { success: false, error: result.error };
}

/**
 * stage.status ì •ê·œí™” í—¬í¼.
 * 'ok'ë¥¼ 'complete'ë¡œ, 'fail'ì€ ê·¸ëŒ€ë¡œ ìœ ì§€.
 */
export function normalizeStageStatus(status: string): 'start' | 'complete' | 'fail' {
  if (status === 'ok') return 'complete';
  if (status === 'fail') return 'fail';
  if (status === 'start') return 'start';
  return 'complete';
}

// =============================================================================
// ìŠ¤íŠ¸ë¦¼ ì´ë²¤íŠ¸ ì¸í„°í˜ì´ìŠ¤
// =============================================================================

/**
 * ë‹¨ê³„ ì§„í–‰ ì´ë²¤íŠ¸.
 * RU-002-S2: statusì— 'fail' ì¶”ê°€í•˜ì—¬ ë‹¨ê³„ ì‹¤íŒ¨ í‘œí˜„ ì§€ì›.
 */
export interface StageEvent {
  type: typeof StreamEventType.STAGE;
  name: AgentPhase;
  /** 'start' | 'complete' | 'ok' | 'fail'. okëŠ” completeë¡œ ì •ê·œí™”ë¨. */
  status: StageStatusName;
}

/** ìë™ ë³µêµ¬(Repair) ì´ë²¤íŠ¸ */
export interface RepairEvent {
  type: typeof StreamEventType.REPAIR;
  attempt: number;
  message?: string;
}

/** ë°°ì§€ ì´ë²¤íŠ¸ */
export interface BadgesEvent {
  type: typeof StreamEventType.BADGES;
  badges: ValidationBadge[];
}

/** ë‚´ëŸ¬í‹°ë¸Œ ë¸íƒ€ ì´ë²¤íŠ¸ (íƒ€ì íš¨ê³¼ìš©) */
export interface NarrativeDeltaEvent {
  type: typeof StreamEventType.NARRATIVE_DELTA;
  text: string;
}

/** ìµœì¢… TurnOutput ì´ë²¤íŠ¸
 *
 * RU-002-Q2: v1ì€ `data`, v2ëŠ” `turn_output` ì‚¬ìš©.
 * í•˜ìœ„í˜¸í™˜ì„ ìœ„í•´ ë‘ í•„ë“œ ëª¨ë‘ ì„ ì–¸í•˜ë˜, ì •ê·œí™”ëœ ì¸í„°í˜ì´ìŠ¤ëŠ” `data`ë¥¼ ì‚¬ìš©.
 */
export interface FinalEvent {
  type: typeof StreamEventType.FINAL;
  /** v1 í˜„í–‰ ê³„ì•½: TurnOutput í˜ì´ë¡œë“œ */
  data: TurnOutput;
}

/** FinalEvent ì›ì‹œ ìˆ˜ì‹  í˜•íƒœ */
export interface FinalEventRaw {
  type: typeof StreamEventType.FINAL;
  /** TurnOutput í˜ì´ë¡œë“œ */
  data: TurnOutput;
}

/** ì—ëŸ¬ ì´ë²¤íŠ¸ */
export interface ErrorEvent {
  type: typeof StreamEventType.ERROR;
  message: string;
  code?: string;
}

/** ìŠ¤íŠ¸ë¦¼ ì´ë²¤íŠ¸ ìœ ë‹ˆì˜¨ íƒ€ì… */
export type StreamEvent =
  | StageEvent
  | RepairEvent
  | BadgesEvent
  | NarrativeDeltaEvent
  | FinalEvent
  | ErrorEvent;

// =============================================================================
// ìŠ¤íŠ¸ë¦¼ ì½œë°± ì¸í„°í˜ì´ìŠ¤
// =============================================================================

/** ìŠ¤íŠ¸ë¦¼ ì´ë²¤íŠ¸ ì½œë°± */
export interface StreamCallbacks {
  /** ë‹¨ê³„ ì§„í–‰ ì´ë²¤íŠ¸ */
  onStage?: (event: StageEvent) => void;
  /** ìë™ ë³µêµ¬ ì´ë²¤íŠ¸ */
  onRepair?: (event: RepairEvent) => void;
  /** ë°°ì§€ ì´ë²¤íŠ¸ */
  onBadges?: (event: BadgesEvent) => void;
  /** ë‚´ëŸ¬í‹°ë¸Œ ë¸íƒ€ ì´ë²¤íŠ¸ */
  onNarrativeDelta?: (event: NarrativeDeltaEvent) => void;
  /** ìµœì¢… TurnOutput ì´ë²¤íŠ¸ */
  onFinal?: (event: FinalEvent) => void;
  /** ì—ëŸ¬ ì´ë²¤íŠ¸ */
  onError?: (event: ErrorEvent) => void;
  /** ìŠ¤íŠ¸ë¦¼ ì™„ë£Œ */
  onComplete?: () => void;
}
</file>

<file path="frontend/src/utils/box2d.test.ts">
import { describe, it, expect } from 'vitest';
import {
  box2dToPixel,
  pixelToBox2d,
  isValidBox2D,
  box2dArea,
  box2dCenter,
  NORMALIZED_MAX,
} from './box2d';
import type { Box2D } from '../schemas/turn';

describe('box2d utils', () => {
  const canvas = { width: 800, height: 600 };

  describe('box2dToPixel', () => {
    it('should correctly convert normalized coordinates to pixels', () => {
      const normalized: Box2D = { ymin: 100, xmin: 200, ymax: 500, xmax: 800 };
      const pixel = box2dToPixel(normalized, canvas);

      // top = 100 * (600 / 1000) = 60
      // left = 200 * (800 / 1000) = 160
      // bottom = 500 * (600 / 1000) = 300
      // right = 800 * (800 / 1000) = 640
      // width = 640 - 160 = 480
      // height = 300 - 60 = 240

      expect(pixel).toEqual({
        top: 60,
        left: 160,
        width: 480,
        height: 240,
      });
    });

    it('should handle full canvas size', () => {
      const normalized: Box2D = { ymin: 0, xmin: 0, ymax: 1000, xmax: 1000 };
      const pixel = box2dToPixel(normalized, canvas);

      expect(pixel).toEqual({
        top: 0,
        left: 0,
        width: 800,
        height: 600,
      });
    });
  });

  describe('pixelToBox2d', () => {
    it('should correctly convert pixels back to normalized coordinates', () => {
      const pixel = { top: 60, left: 160, width: 480, height: 240 };
      const normalized = pixelToBox2d(pixel, canvas);

      expect(normalized).toEqual({
        ymin: 100,
        xmin: 200,
        ymax: 500,
        xmax: 800,
      });
    });

    it('should round and clamp values', () => {
      const pixel = { top: -10, left: -20, width: 900, height: 700 };
      const normalized = pixelToBox2d(pixel, canvas);

      expect(normalized.ymin).toBe(0);
      expect(normalized.xmin).toBe(0);
      expect(normalized.ymax).toBe(NORMALIZED_MAX);
      expect(normalized.xmax).toBe(NORMALIZED_MAX);
    });
  });

  describe('isValidBox2D', () => {
    it('should return true for valid boxes', () => {
      expect(isValidBox2D({ ymin: 100, xmin: 100, ymax: 200, xmax: 200 })).toBe(true);
      expect(isValidBox2D({ ymin: 0, xmin: 0, ymax: 1000, xmax: 1000 })).toBe(true);
    });

    it('should return false for out of range values', () => {
      expect(isValidBox2D({ ymin: -1, xmin: 0, ymax: 100, xmax: 100 })).toBe(false);
      expect(isValidBox2D({ ymin: 0, xmin: 0, ymax: 1001, xmax: 100 })).toBe(false);
    });

    it('should return false for invalid order', () => {
      expect(isValidBox2D({ ymin: 500, xmin: 100, ymax: 400, xmax: 200 })).toBe(false);
      expect(isValidBox2D({ ymin: 100, xmin: 500, ymax: 200, xmax: 400 })).toBe(false);
    });
  });

  describe('box2dArea', () => {
    it('should calculate area correctly', () => {
      const box = { ymin: 100, xmin: 100, ymax: 200, xmax: 300 };
      expect(box2dArea(box)).toBe(20000); // (200-100) * (300-100) = 100 * 200
    });
  });

  describe('box2dCenter', () => {
    it('should calculate center correctly', () => {
      const box = { ymin: 100, xmin: 100, ymax: 300, xmax: 500 };
      expect(box2dCenter(box)).toEqual({ x: 300, y: 200 });
    });
  });
});
</file>

<file path="frontend/src/utils/box2d.ts">
/**
 * Unknown World - Box2D ì¢Œí‘œ ë³€í™˜ ìœ í‹¸ë¦¬í‹°
 *
 * RULE-009 ì¤€ìˆ˜: ì¢Œí‘œ ê·œì•½ (0~1000 ì •ê·œí™”, bbox=[ymin,xmin,ymax,xmax])
 * - ì„œë²„/ì„¸ì´ë¸Œì—ëŠ” í•­ìƒ box_2d(0~1000)ë¥¼ ìœ ì§€
 * - ë Œë”ì—ì„œë§Œ viewport í¬ê¸°(canvasW/H)ì— ë§ì¶° pxë¡œ ë³€í™˜
 *
 * @module utils/box2d
 */

import type { Box2D } from '../schemas/turn';

// =============================================================================
// ìƒìˆ˜ ì •ì˜
// =============================================================================

/**
 * ì •ê·œí™” ì¢Œí‘œê³„ ìµœëŒ“ê°’ (0~1000).
 * RULE-009: ì¢Œí‘œ ê·œì•½
 */
export const NORMALIZED_MAX = 1000;

// =============================================================================
// íƒ€ì… ì •ì˜
// =============================================================================

/**
 * í”½ì…€ ë‹¨ìœ„ ë°”ìš´ë”© ë°•ìŠ¤.
 * ë Œë”ë§ìš©ìœ¼ë¡œë§Œ ì‚¬ìš©ë©ë‹ˆë‹¤.
 */
export interface Box2DPixel {
  /** Y ìµœì†Œê°’ (ìƒë‹¨, í”½ì…€) */
  top: number;
  /** X ìµœì†Œê°’ (ì¢Œì¸¡, í”½ì…€) */
  left: number;
  /** ë„ˆë¹„ (í”½ì…€) */
  width: number;
  /** ë†’ì´ (í”½ì…€) */
  height: number;
}

/**
 * ìº”ë²„ìŠ¤ í¬ê¸° ì •ë³´.
 */
export interface CanvasSize {
  /** ìº”ë²„ìŠ¤ ë„ˆë¹„ (í”½ì…€) */
  width: number;
  /** ìº”ë²„ìŠ¤ ë†’ì´ (í”½ì…€) */
  height: number;
}

// =============================================================================
// ë³€í™˜ í•¨ìˆ˜
// =============================================================================

/**
 * ì •ê·œí™” ì¢Œí‘œ(0~1000)ë¥¼ í”½ì…€ ì¢Œí‘œë¡œ ë³€í™˜í•©ë‹ˆë‹¤.
 *
 * RULE-009: bbox ìˆœì„œëŠ” [ymin, xmin, ymax, xmax]
 *
 * @param box - ì •ê·œí™” ì¢Œí‘œ ë°”ìš´ë”© ë°•ìŠ¤
 * @param canvas - ìº”ë²„ìŠ¤ í¬ê¸°
 * @returns í”½ì…€ ë‹¨ìœ„ ë°”ìš´ë”© ë°•ìŠ¤
 *
 * @example
 * ```ts
 * const normalized: Box2D = { ymin: 100, xmin: 200, ymax: 500, xmax: 800 };
 * const canvas = { width: 800, height: 600 };
 * const pixel = box2dToPixel(normalized, canvas);
 * // pixel = { top: 60, left: 160, width: 480, height: 240 }
 * ```
 */
export function box2dToPixel(box: Box2D, canvas: CanvasSize): Box2DPixel {
  const scaleX = canvas.width / NORMALIZED_MAX;
  const scaleY = canvas.height / NORMALIZED_MAX;

  const top = box.ymin * scaleY;
  const left = box.xmin * scaleX;
  const bottom = box.ymax * scaleY;
  const right = box.xmax * scaleX;

  return {
    top,
    left,
    width: right - left,
    height: bottom - top,
  };
}

/**
 * í”½ì…€ ì¢Œí‘œë¥¼ ì •ê·œí™” ì¢Œí‘œ(0~1000)ë¡œ ë³€í™˜í•©ë‹ˆë‹¤.
 *
 * ì—­ë³€í™˜ì´ í•„ìš”í•œ ê²½ìš° ì‚¬ìš©í•©ë‹ˆë‹¤ (ì˜ˆ: í´ë¦­ ìœ„ì¹˜ â†’ ì •ê·œí™” ì¢Œí‘œ).
 *
 * @param pixel - í”½ì…€ ë‹¨ìœ„ ë°”ìš´ë”© ë°•ìŠ¤
 * @param canvas - ìº”ë²„ìŠ¤ í¬ê¸°
 * @returns ì •ê·œí™” ì¢Œí‘œ ë°”ìš´ë”© ë°•ìŠ¤
 */
export function pixelToBox2d(pixel: Box2DPixel, canvas: CanvasSize): Box2D {
  const scaleX = NORMALIZED_MAX / canvas.width;
  const scaleY = NORMALIZED_MAX / canvas.height;

  const ymin = Math.round(pixel.top * scaleY);
  const xmin = Math.round(pixel.left * scaleX);
  const ymax = Math.round((pixel.top + pixel.height) * scaleY);
  const xmax = Math.round((pixel.left + pixel.width) * scaleX);

  // RULE-009: 0~1000 ë²”ìœ„ ë³´ì¥
  return {
    ymin: Math.max(0, Math.min(NORMALIZED_MAX, ymin)),
    xmin: Math.max(0, Math.min(NORMALIZED_MAX, xmin)),
    ymax: Math.max(0, Math.min(NORMALIZED_MAX, ymax)),
    xmax: Math.max(0, Math.min(NORMALIZED_MAX, xmax)),
  };
}

/**
 * Box2Dê°€ ìœ íš¨í•œì§€ ê²€ì¦í•©ë‹ˆë‹¤.
 *
 * @param box - ê²€ì¦í•  ë°”ìš´ë”© ë°•ìŠ¤
 * @returns ìœ íš¨ ì—¬ë¶€
 */
export function isValidBox2D(box: Box2D): boolean {
  // 0~1000 ë²”ìœ„ ì²´í¬
  if (
    box.ymin < 0 ||
    box.ymin > NORMALIZED_MAX ||
    box.xmin < 0 ||
    box.xmin > NORMALIZED_MAX ||
    box.ymax < 0 ||
    box.ymax > NORMALIZED_MAX ||
    box.xmax < 0 ||
    box.xmax > NORMALIZED_MAX
  ) {
    return false;
  }

  // ymin < ymax, xmin < xmax ì²´í¬
  if (box.ymin >= box.ymax || box.xmin >= box.xmax) {
    return false;
  }

  return true;
}

/**
 * Box2Dì˜ ë©´ì ì„ ê³„ì‚°í•©ë‹ˆë‹¤ (ì •ê·œí™” ì¢Œí‘œ ê¸°ì¤€).
 *
 * @param box - ë°”ìš´ë”© ë°•ìŠ¤
 * @returns ë©´ì  (0~1000000)
 */
export function box2dArea(box: Box2D): number {
  return (box.ymax - box.ymin) * (box.xmax - box.xmin);
}

/**
 * Box2Dì˜ ì¤‘ì‹¬ì ì„ ê³„ì‚°í•©ë‹ˆë‹¤ (ì •ê·œí™” ì¢Œí‘œ ê¸°ì¤€).
 *
 * @param box - ë°”ìš´ë”© ë°•ìŠ¤
 * @returns ì¤‘ì‹¬ì  ì¢Œí‘œ {x, y}
 */
export function box2dCenter(box: Box2D): { x: number; y: number } {
  return {
    x: (box.xmin + box.xmax) / 2,
    y: (box.ymin + box.ymax) / 2,
  };
}
</file>

<file path="frontend/src/vite-env.d.ts">
/// <reference types="vite/client" />
</file>

<file path="frontend/tsconfig.json">
{
  "compilerOptions": {
    "target": "ES2022",
    "useDefineForClassFields": true,
    "lib": ["ES2022", "DOM", "DOM.Iterable"],
    "module": "ESNext",
    "skipLibCheck": true,

    /* Bundler mode */
    "moduleResolution": "Bundler",
    "allowImportingTsExtensions": true,
    "isolatedModules": true,
    "moduleDetection": "force",
    "noEmit": true,
    "jsx": "react-jsx",

    /* Linting (ì—„ê²© ëª¨ë“œ) */
    "strict": true,
    "noUnusedLocals": true,
    "noUnusedParameters": true,
    "noFallthroughCasesInSwitch": true,
    "noUncheckedSideEffectImports": true
  },
  "include": ["src"],
  "references": [{ "path": "./tsconfig.node.json" }]
}
</file>

<file path="frontend/tsconfig.node.json">
{
  "compilerOptions": {
    "target": "ES2022",
    "lib": ["ES2022"],
    "module": "ESNext",
    "skipLibCheck": true,

    /* Bundler mode */
    "moduleResolution": "Bundler",
    "allowImportingTsExtensions": true,
    "isolatedModules": true,
    "moduleDetection": "force",

    /* Composite for project references */
    "composite": true,
    "emitDeclarationOnly": true,
    "declaration": true,
    "declarationMap": true,

    /* Linting (ì—„ê²© ëª¨ë“œ) */
    "strict": true,
    "noUnusedLocals": true,
    "noUnusedParameters": true,
    "noFallthroughCasesInSwitch": true,
    "noUncheckedSideEffectImports": true
  },
  "include": ["vite.config.ts"]
}
</file>

<file path="package.json">
{
  "name": "unknown-world",
  "version": "0.1.0",
  "private": true,
  "description": "Unknown World - Gemini ê¸°ë°˜ ì—ì´ì „íŠ¸í˜• ê²Œì„ ì—”ì§„",
  "packageManager": "pnpm@10.27.0",
  "engines": {
    "node": "24.12.0"
  },
  "scripts": {
    "kill": "pnpm kill:port",
    "kill:port": "npx --yes kill-port 8001 8002 8003 8004 8005 8006 8007 8008 8009 8010 8011 8012 8013 8014 8015 8016 8017 8018 8019 8020",
    "kill:front": "npx --yes kill-port 8001 8002 8003 8004 8005 8006 8007 8008 8009 8010",
    "kill:back": "npx --yes kill-port 8011 8012 8013 8014 8015 8016 8017 8018 8019 8020",
    "dev:back": "cd backend && uv run uvicorn unknown_world.main:app --reload --port 8011",
    "dev:front": "pnpm -C frontend dev"
  }
}
</file>

<file path="shared/schemas/turn/turn_input.schema.json">
{
  "$schema": "http://json-schema.org/draft-07/schema#",
  "$id": "https://unknown-world.dev/schemas/turn/turn_input.schema.json",
  "title": "TurnInput",
  "description": "Client â†’ Server í„´ ìš”ì²­ ìŠ¤í‚¤ë§ˆ (MVP). PRD 8.7ì ˆ ê¸°ë°˜.",
  "type": "object",
  "properties": {
    "language": {
      "type": "string",
      "enum": ["ko-KR", "en-US"],
      "description": "ê²Œì„ ì–¸ì–´ ì„¤ì • (ko-KR ë˜ëŠ” en-US)"
    },
    "text": {
      "type": "string",
      "description": "ì‚¬ìš©ì ì…ë ¥ (ìì—°ì–´)"
    },
    "click": {
      "type": ["object", "null"],
      "description": "í´ë¦­ëœ ì˜¤ë¸Œì íŠ¸ ì •ë³´ (ì„ íƒ)",
      "properties": {
        "object_id": {
          "type": "string",
          "description": "í´ë¦­ëœ ì˜¤ë¸Œì íŠ¸ ID"
        },
        "box_2d": {
          "type": ["array", "null"],
          "description": "bbox [ymin, xmin, ymax, xmax] (0~1000 ì •ê·œí™”)",
          "items": {
            "type": "integer",
            "minimum": 0,
            "maximum": 1000
          },
          "minItems": 4,
          "maxItems": 4
        }
      },
      "required": ["object_id"]
    },
    "client": {
      "type": "object",
      "description": "í´ë¼ì´ì–¸íŠ¸ í™˜ê²½ ì •ë³´",
      "properties": {
        "viewport_w": {
          "type": "integer",
          "description": "ë·°í¬íŠ¸ ë„ˆë¹„ (px)"
        },
        "viewport_h": {
          "type": "integer",
          "description": "ë·°í¬íŠ¸ ë†’ì´ (px)"
        },
        "theme": {
          "type": "string",
          "enum": ["dark", "light"],
          "description": "í…Œë§ˆ ì„¤ì •"
        }
      },
      "required": ["viewport_w", "viewport_h", "theme"]
    },
    "economy_snapshot": {
      "type": "object",
      "description": "í˜„ì¬ ì¬í™” ìƒíƒœ ìŠ¤ëƒ…ìƒ·",
      "properties": {
        "signal": {
          "type": "integer",
          "minimum": 0,
          "description": "Signal ì¬í™” ì”ì•¡"
        },
        "memory_shard": {
          "type": "integer",
          "minimum": 0,
          "description": "Memory Shard ì¬í™” ì”ì•¡"
        }
      },
      "required": ["signal", "memory_shard"]
    }
  },
  "required": ["language", "text", "client", "economy_snapshot"],
  "additionalProperties": false
}
</file>

<file path="shared/schemas/turn/turn_output.schema.json">
{
  "$defs": {
    "ActionCard": {
      "additionalProperties": false,
      "description": "ì•¡ì…˜ ì¹´ë“œ (Action Deck).\n\në§¤ í„´ AIê°€ ì¶”ì²œí•˜ëŠ” í–‰ë™ ì¹´ë“œì…ë‹ˆë‹¤.\nê° ì¹´ë“œì— ë¹„ìš©/ìœ„í—˜/ë³´ìƒ íŒíŠ¸ê°€ í¬í•¨ë©ë‹ˆë‹¤.\n\nAttributes:\n    id: ì¹´ë“œ ê³ ìœ  ID\n    label: ì¹´ë“œ ë¼ë²¨ (í‘œì‹œìš©)\n    description: ì¹´ë“œ ì„¤ëª… (ì„ íƒ)\n    cost: ì˜ˆìƒ ë¹„ìš©\n    risk: ìœ„í—˜ë„\n    hint: ì˜ˆìƒ ê²°ê³¼ íŒíŠ¸ (ì„ íƒ)",
      "properties": {
        "id": {
          "description": "ì¹´ë“œ ê³ ìœ  ID",
          "title": "Id",
          "type": "string"
        },
        "label": {
          "description": "ì¹´ë“œ ë¼ë²¨ (í‘œì‹œìš©)",
          "title": "Label",
          "type": "string"
        },
        "description": {
          "anyOf": [
            {
              "type": "string"
            },
            {
              "type": "null"
            }
          ],
          "default": null,
          "description": "ì¹´ë“œ ì„¤ëª… (ì„ íƒ)",
          "title": "Description"
        },
        "cost": {
          "$ref": "#/$defs/CurrencyAmount",
          "description": "ì˜ˆìƒ ë¹„ìš©"
        },
        "risk": {
          "$ref": "#/$defs/RiskLevel",
          "default": "low",
          "description": "ìœ„í—˜ë„"
        },
        "hint": {
          "anyOf": [
            {
              "type": "string"
            },
            {
              "type": "null"
            }
          ],
          "default": null,
          "description": "ì˜ˆìƒ ê²°ê³¼ íŒíŠ¸ (ì„ íƒ)",
          "title": "Hint"
        }
      },
      "required": [
        "id",
        "label",
        "cost"
      ],
      "title": "ActionCard",
      "type": "object"
    },
    "ActionDeck": {
      "additionalProperties": false,
      "description": "ì•¡ì…˜ ë± (Q1 ê²°ì •: ui.action_deck.cards[] êµ¬ì¡°).\n\në§¤ í„´ AIê°€ ì œì‹œí•˜ëŠ” ì¶”ì²œ í–‰ë™ ì¹´ë“œ ë±ì…ë‹ˆë‹¤.\n\nAttributes:\n    cards: ì•¡ì…˜ ì¹´ë“œ ëª©ë¡ (3~6ì¥ ê¶Œì¥)",
      "properties": {
        "cards": {
          "default": [],
          "description": "ì•¡ì…˜ ì¹´ë“œ ëª©ë¡ (3~6ì¥ ê¶Œì¥)",
          "items": {
            "$ref": "#/$defs/ActionCard"
          },
          "maxItems": 10,
          "minItems": 0,
          "title": "Cards",
          "type": "array"
        }
      },
      "title": "ActionDeck",
      "type": "object"
    },
    "AgentConsole": {
      "additionalProperties": false,
      "description": "ì—ì´ì „íŠ¸ ì½˜ì†” ë°ì´í„° (RULE-008).\n\nì—ì´ì „íŠ¸í˜• ì‹œìŠ¤í…œì„ì„ UIë¡œ ì¦ëª…í•˜ê¸° ìœ„í•œ ì •ë³´ì…ë‹ˆë‹¤.\nê³„íš/ì‹¤í–‰/ê²€ì¦/ë³µêµ¬ì˜ í”ì ì„ í‘œì‹œí•©ë‹ˆë‹¤.\n\nAttributes:\n    current_phase: í˜„ì¬ ì‹¤í–‰ ë‹¨ê³„\n    badges: ê²€ì¦ ë°°ì§€ ëª©ë¡\n    repair_count: ìë™ ë³µêµ¬ ì‹œë„ íšŸìˆ˜",
      "properties": {
        "current_phase": {
          "$ref": "#/$defs/AgentPhase",
          "default": "commit",
          "description": "í˜„ì¬ ì‹¤í–‰ ë‹¨ê³„"
        },
        "badges": {
          "default": [],
          "description": "ê²€ì¦ ë°°ì§€ ëª©ë¡",
          "items": {
            "$ref": "#/$defs/ValidationBadge"
          },
          "title": "Badges",
          "type": "array"
        },
        "repair_count": {
          "default": 0,
          "description": "ìë™ ë³µêµ¬ ì‹œë„ íšŸìˆ˜",
          "minimum": 0,
          "title": "Repair Count",
          "type": "integer"
        }
      },
      "title": "AgentConsole",
      "type": "object"
    },
    "AgentPhase": {
      "description": "ì—ì´ì „íŠ¸ ì‹¤í–‰ ë‹¨ê³„ (RULE-008).\n\nì—ì´ì „íŠ¸í˜• ì‹œìŠ¤í…œì„ì„ UIë¡œ ì¦ëª…í•˜ê¸° ìœ„í•œ ë‹¨ê³„ í‘œì‹œ.",
      "enum": [
        "parse",
        "validate",
        "plan",
        "resolve",
        "render",
        "verify",
        "commit"
      ],
      "title": "AgentPhase",
      "type": "string"
    },
    "Box2D": {
      "additionalProperties": false,
      "description": "2D ë°”ìš´ë”© ë°•ìŠ¤ (RULE-009).\n\nì¢Œí‘œëŠ” 0~1000 ì •ê·œí™” ì¢Œí‘œê³„ì´ë©°, bboxëŠ” [ymin, xmin, ymax, xmax] ìˆœì„œì…ë‹ˆë‹¤.\nì´ë¯¸ì§€ ì´í•´ bbox í¬ë§·ê³¼ í˜¸í™˜ë©ë‹ˆë‹¤.\n\nAttributes:\n    ymin: Y ìµœì†Œê°’ (ìƒë‹¨)\n    xmin: X ìµœì†Œê°’ (ì¢Œì¸¡)\n    ymax: Y ìµœëŒ€ê°’ (í•˜ë‹¨)\n    xmax: X ìµœëŒ€ê°’ (ìš°ì¸¡)",
      "properties": {
        "ymin": {
          "description": "ì •ê·œí™” ì¢Œí‘œ (0~1000)",
          "maximum": 1000,
          "minimum": 0,
          "title": "Ymin",
          "type": "integer"
        },
        "xmin": {
          "description": "ì •ê·œí™” ì¢Œí‘œ (0~1000)",
          "maximum": 1000,
          "minimum": 0,
          "title": "Xmin",
          "type": "integer"
        },
        "ymax": {
          "description": "ì •ê·œí™” ì¢Œí‘œ (0~1000)",
          "maximum": 1000,
          "minimum": 0,
          "title": "Ymax",
          "type": "integer"
        },
        "xmax": {
          "description": "ì •ê·œí™” ì¢Œí‘œ (0~1000)",
          "maximum": 1000,
          "minimum": 0,
          "title": "Xmax",
          "type": "integer"
        }
      },
      "required": [
        "ymin",
        "xmin",
        "ymax",
        "xmax"
      ],
      "title": "Box2D",
      "type": "object"
    },
    "CurrencyAmount": {
      "additionalProperties": false,
      "description": "ì¬í™” ìˆ˜ëŸ‰.\n\nAttributes:\n    signal: ê¸°ë³¸ ì¬í™” (í…ìŠ¤íŠ¸ í„´/ì´ë¯¸ì§€ ìƒì„±/ê³ ê¸‰ ê¸°ëŠ¥ì— ì†Œë¹„)\n    memory_shard: í¬ê·€ ì¬í™” (ì¤‘ìš” ì„¤ì • ê³ ì •, ê³ í•´ìƒë„ ì´ë¯¸ì§€ ë“±ì— ì†Œë¹„)",
      "properties": {
        "signal": {
          "description": "ì‹œê·¸ë„ (ê¸°ë³¸ ì¬í™”, 0 ì´ìƒ)",
          "minimum": 0,
          "title": "Signal",
          "type": "integer"
        },
        "memory_shard": {
          "description": "ê¸°ì–µ íŒŒí¸ (í¬ê·€ ì¬í™”, 0 ì´ìƒ)",
          "minimum": 0,
          "title": "Memory Shard",
          "type": "integer"
        }
      },
      "required": [
        "signal",
        "memory_shard"
      ],
      "title": "CurrencyAmount",
      "type": "object"
    },
    "EconomyOutput": {
      "additionalProperties": false,
      "description": "ê²½ì œ ì¶œë ¥ ë°ì´í„° (RULE-005).\n\nì´ë²ˆ í„´ì˜ ë¹„ìš©ê³¼ ì”ì•¡ ì •ë³´ì…ë‹ˆë‹¤.\nì”ì•¡ ìŒìˆ˜ëŠ” ì ˆëŒ€ ë¶ˆê°€ (ì„œë²„ Hard gate).\n\nAttributes:\n    cost: ì´ë²ˆ í„´ì— ì†Œë¹„ëœ ë¹„ìš©\n    balance_after: ì†Œë¹„ í›„ ì”ì•¡\n\nImportant:\n    - costì™€ balance_afterëŠ” í•­ìƒ í¬í•¨ë˜ì–´ì•¼ í•©ë‹ˆë‹¤.\n    - balance_afterì˜ signalê³¼ memory_shardëŠ” 0 ì´ìƒì´ì–´ì•¼ í•©ë‹ˆë‹¤.",
      "properties": {
        "cost": {
          "$ref": "#/$defs/CurrencyAmount",
          "description": "ì´ë²ˆ í„´ì— ì†Œë¹„ëœ ë¹„ìš©"
        },
        "balance_after": {
          "$ref": "#/$defs/CurrencyAmount",
          "description": "ì†Œë¹„ í›„ ì”ì•¡"
        }
      },
      "required": [
        "cost",
        "balance_after"
      ],
      "title": "EconomyOutput",
      "type": "object"
    },
    "ImageJob": {
      "additionalProperties": false,
      "description": "ì´ë¯¸ì§€ ìƒì„± ì‘ì—….\n\nì¡°ê±´ë¶€ ì´ë¯¸ì§€ ìƒì„±/í¸ì§‘ ìš”ì²­ì…ë‹ˆë‹¤.\nì´ë¯¸ì§€ ìƒì„±ì´ ëŠë¦´ ê²½ìš° í…ìŠ¤íŠ¸ ìš°ì„  ì¶œë ¥ + Lazy Loadingì„ ì‚¬ìš©í•©ë‹ˆë‹¤.\n\nAttributes:\n    should_generate: ì´ë¯¸ì§€ë¥¼ ìƒì„±í•´ì•¼ í•˜ëŠ”ì§€\n    prompt: ì´ë¯¸ì§€ ìƒì„± í”„ë¡¬í”„íŠ¸\n    model_label: ëª¨ë¸ ì„ íƒ ë¼ë²¨ (FAST/QUALITY/CHEAP/REF)\n    aspect_ratio: ê°€ë¡œì„¸ë¡œ ë¹„ìœ¨ (ì˜ˆ: \"16:9\", \"1:1\")\n    image_size: ì´ë¯¸ì§€ í¬ê¸° (ì˜ˆ: \"1024x1024\")\n    reference_image_ids: ì°¸ì¡° ì´ë¯¸ì§€ ID ëª©ë¡ (ì„ íƒ)",
      "properties": {
        "should_generate": {
          "description": "ì´ë¯¸ì§€ë¥¼ ìƒì„±í•´ì•¼ í•˜ëŠ”ì§€",
          "title": "Should Generate",
          "type": "boolean"
        },
        "prompt": {
          "default": "",
          "description": "ì´ë¯¸ì§€ ìƒì„± í”„ë¡¬í”„íŠ¸",
          "title": "Prompt",
          "type": "string"
        },
        "model_label": {
          "$ref": "#/$defs/ModelLabel",
          "default": "FAST",
          "description": "ëª¨ë¸ ì„ íƒ ë¼ë²¨"
        },
        "aspect_ratio": {
          "default": "16:9",
          "description": "ê°€ë¡œì„¸ë¡œ ë¹„ìœ¨",
          "title": "Aspect Ratio",
          "type": "string"
        },
        "image_size": {
          "default": "1024x1024",
          "description": "ì´ë¯¸ì§€ í¬ê¸°",
          "title": "Image Size",
          "type": "string"
        },
        "reference_image_ids": {
          "default": [],
          "description": "ì°¸ì¡° ì´ë¯¸ì§€ ID ëª©ë¡ (ì„ íƒ)",
          "items": {
            "type": "string"
          },
          "title": "Reference Image Ids",
          "type": "array"
        }
      },
      "required": [
        "should_generate"
      ],
      "title": "ImageJob",
      "type": "object"
    },
    "Language": {
      "description": "ì§€ì› ì–¸ì–´ (RULE-006).\n\nko/en í˜¼í•© ì¶œë ¥ ê¸ˆì§€. TurnInput.languageë¥¼ SSOTë¡œ ì‚¼ì•„\nëª¨ë“  UI/ë‚´ëŸ¬í‹°ë¸Œ/ì‹œìŠ¤í…œ ë©”ì‹œì§€ëŠ” ë™ì¼ ì–¸ì–´ë¡œ ê³ ì •í•©ë‹ˆë‹¤.",
      "enum": [
        "ko-KR",
        "en-US"
      ],
      "title": "Language",
      "type": "string"
    },
    "MemoryPin": {
      "additionalProperties": false,
      "description": "ì¤‘ìš” ì„¤ì • ê³ ì • í›„ë³´.\n\nì‚¬ìš©ìê°€ Memory Shardë¥¼ ì†Œë¹„í•´ ê³ ì •í•  ìˆ˜ ìˆëŠ” ì¤‘ìš” ì„¤ì •ì…ë‹ˆë‹¤.\n\nAttributes:\n    id: í•€ ê³ ìœ  ID\n    content: ê³ ì •í•  ë‚´ìš©\n    cost: ê³ ì •ì— í•„ìš”í•œ ë¹„ìš©",
      "properties": {
        "id": {
          "description": "í•€ ê³ ìœ  ID",
          "title": "Id",
          "type": "string"
        },
        "content": {
          "description": "ê³ ì •í•  ë‚´ìš©",
          "title": "Content",
          "type": "string"
        },
        "cost": {
          "$ref": "#/$defs/CurrencyAmount",
          "description": "ê³ ì •ì— í•„ìš”í•œ ë¹„ìš©"
        }
      },
      "required": [
        "id",
        "content",
        "cost"
      ],
      "title": "MemoryPin",
      "type": "object"
    },
    "ModelLabel": {
      "description": "ëª¨ë¸/í’ˆì§ˆ ì„ íƒ ë¼ë²¨ (RULE-008).\n\ní”„ë¡¬í”„íŠ¸ ë…¸ì¶œ ì—†ì´ \"ì™œ ì´ ì„ íƒì´ì—ˆëŠ”ì§€\"ë¥¼ ì‚¬ìš©ì ì¹œí™” ë¼ë²¨ë¡œ í‘œì‹œ.",
      "enum": [
        "FAST",
        "QUALITY",
        "CHEAP",
        "REF"
      ],
      "title": "ModelLabel",
      "type": "string"
    },
    "Quest": {
      "additionalProperties": false,
      "description": "í€˜ìŠ¤íŠ¸/ëª©í‘œ (Quest Panel).\n\ní”Œë ˆì´ì–´ê°€ ë‹¬ì„±í•´ì•¼ í•˜ëŠ” í˜„ì¬ ëª©í‘œì…ë‹ˆë‹¤.\n\nAttributes:\n    id: í€˜ìŠ¤íŠ¸ ê³ ìœ  ID\n    label: í€˜ìŠ¤íŠ¸ ì´ë¦„\n    is_completed: ë‹¬ì„± ì—¬ë¶€",
      "properties": {
        "id": {
          "description": "í€˜ìŠ¤íŠ¸ ê³ ìœ  ID",
          "title": "Id",
          "type": "string"
        },
        "label": {
          "description": "í€˜ìŠ¤íŠ¸ ì´ë¦„",
          "title": "Label",
          "type": "string"
        },
        "is_completed": {
          "default": false,
          "description": "ë‹¬ì„± ì—¬ë¶€",
          "title": "Is Completed",
          "type": "boolean"
        }
      },
      "required": [
        "id",
        "label"
      ],
      "title": "Quest",
      "type": "object"
    },
    "RenderOutput": {
      "additionalProperties": false,
      "description": "ë Œë”ë§ ì¶œë ¥ ë°ì´í„°.\n\nì´ë¯¸ì§€ ìƒì„±/í¸ì§‘ ê´€ë ¨ ì •ë³´ì…ë‹ˆë‹¤.\n\nAttributes:\n    image_job: ì´ë¯¸ì§€ ìƒì„± ì‘ì—… (ì„ íƒ)",
      "properties": {
        "image_job": {
          "anyOf": [
            {
              "$ref": "#/$defs/ImageJob"
            },
            {
              "type": "null"
            }
          ],
          "default": null,
          "description": "ì´ë¯¸ì§€ ìƒì„± ì‘ì—… (ì„ íƒ)"
        }
      },
      "title": "RenderOutput",
      "type": "object"
    },
    "RiskLevel": {
      "description": "í–‰ë™ ìœ„í—˜ë„ ìˆ˜ì¤€.",
      "enum": [
        "low",
        "medium",
        "high"
      ],
      "title": "RiskLevel",
      "type": "string"
    },
    "SafetyOutput": {
      "additionalProperties": false,
      "description": "ì•ˆì „ ì¶œë ¥ ë°ì´í„°.\n\nì•ˆì „ ì •ì±… ê´€ë ¨ ì •ë³´ì…ë‹ˆë‹¤.\nì°¨ë‹¨ ì‹œ ëª…ì‹œì  ë©”ì‹œì§€ì™€ í•¨ê»˜ ì•ˆì „í•œ ëŒ€ì²´ ê²°ê³¼ë¥¼ ì œê³µí•©ë‹ˆë‹¤.\n\nAttributes:\n    blocked: ì•ˆì „ ì •ì±…ì— ì˜í•´ ì°¨ë‹¨ë˜ì—ˆëŠ”ì§€\n    message: ì°¨ë‹¨ ì‹œ ì‚¬ìš©ìì—ê²Œ í‘œì‹œí•  ë©”ì‹œì§€ (ì„ íƒ)",
      "properties": {
        "blocked": {
          "default": false,
          "description": "ì•ˆì „ ì •ì±…ì— ì˜í•´ ì°¨ë‹¨ë˜ì—ˆëŠ”ì§€",
          "title": "Blocked",
          "type": "boolean"
        },
        "message": {
          "anyOf": [
            {
              "type": "string"
            },
            {
              "type": "null"
            }
          ],
          "default": null,
          "description": "ì°¨ë‹¨ ì‹œ ì‚¬ìš©ìì—ê²Œ í‘œì‹œí•  ë©”ì‹œì§€ (ì„ íƒ)",
          "title": "Message"
        }
      },
      "title": "SafetyOutput",
      "type": "object"
    },
    "SceneObject": {
      "additionalProperties": false,
      "description": "ì¥ë©´ ì˜¤ë¸Œì íŠ¸ (í´ë¦­ ê°€ëŠ¥í•œ í•«ìŠ¤íŒŸ).\n\ní™”ë©´ì—ì„œ í´ë¦­ ê°€ëŠ¥í•œ ì˜¤ë¸Œì íŠ¸ì…ë‹ˆë‹¤.\nì¢Œí‘œëŠ” 0~1000 ì •ê·œí™” ì¢Œí‘œê³„ë¥¼ ì‚¬ìš©í•©ë‹ˆë‹¤ (RULE-009).\n\nAttributes:\n    id: ì˜¤ë¸Œì íŠ¸ ê³ ìœ  ID\n    label: ì˜¤ë¸Œì íŠ¸ ë¼ë²¨ (í‘œì‹œìš©)\n    box_2d: ë°”ìš´ë”© ë°•ìŠ¤ [ymin, xmin, ymax, xmax]\n    interaction_hint: ìƒí˜¸ì‘ìš© íŒíŠ¸ (ì„ íƒ)",
      "properties": {
        "id": {
          "description": "ì˜¤ë¸Œì íŠ¸ ê³ ìœ  ID",
          "title": "Id",
          "type": "string"
        },
        "label": {
          "description": "ì˜¤ë¸Œì íŠ¸ ë¼ë²¨ (í‘œì‹œìš©)",
          "title": "Label",
          "type": "string"
        },
        "box_2d": {
          "$ref": "#/$defs/Box2D",
          "description": "ë°”ìš´ë”© ë°•ìŠ¤"
        },
        "interaction_hint": {
          "anyOf": [
            {
              "type": "string"
            },
            {
              "type": "null"
            }
          ],
          "default": null,
          "description": "ìƒí˜¸ì‘ìš© íŒíŠ¸ (ì„ íƒ)",
          "title": "Interaction Hint"
        }
      },
      "required": [
        "id",
        "label",
        "box_2d"
      ],
      "title": "SceneObject",
      "type": "object"
    },
    "SceneOutput": {
      "additionalProperties": false,
      "description": "Scene í‘œì‹œ ì •ë³´ (RU-003-T1: Scene ì´ë¯¸ì§€ SSOT).\n\nTurnOutputì—ì„œ Scene Canvasì— í‘œì‹œí•  ì´ë¯¸ì§€ ì •ë³´ë¥¼ ì œê³µí•©ë‹ˆë‹¤.\nimage_urlì´ ì¡´ì¬í•˜ë©´ SceneCanvasëŠ” 'scene' ìƒíƒœë¡œ ì „í™˜ë©ë‹ˆë‹¤.\nimage_urlì´ ì—†ìœ¼ë©´ 'default' ìƒíƒœë¥¼ ìœ ì§€í•©ë‹ˆë‹¤.\n\nAttributes:\n    image_url: Scene ì´ë¯¸ì§€ URL (ì¡´ì¬ ì‹œ scene ìƒíƒœë¡œ ì „í™˜)\n    alt_text: ì´ë¯¸ì§€ ëŒ€ì²´ í…ìŠ¤íŠ¸ (ì ‘ê·¼ì„±ìš©, ì„ íƒ)",
      "properties": {
        "image_url": {
          "anyOf": [
            {
              "type": "string"
            },
            {
              "type": "null"
            }
          ],
          "default": null,
          "description": "Scene ì´ë¯¸ì§€ URL (ì¡´ì¬ ì‹œ scene ìƒíƒœë¡œ ì „í™˜)",
          "title": "Image Url"
        },
        "alt_text": {
          "anyOf": [
            {
              "type": "string"
            },
            {
              "type": "null"
            }
          ],
          "default": null,
          "description": "ì´ë¯¸ì§€ ëŒ€ì²´ í…ìŠ¤íŠ¸ (ì ‘ê·¼ì„±ìš©, ì„ íƒ)",
          "title": "Alt Text"
        }
      },
      "title": "SceneOutput",
      "type": "object"
    },
    "UIOutput": {
      "additionalProperties": false,
      "description": "UI ì¶œë ¥ ë°ì´í„°.\n\nAIê°€ ìƒì„±í•œ UI ìš”ì†Œë“¤ì…ë‹ˆë‹¤.\nì±„íŒ… ë²„ë¸”ì´ ì•„ë‹Œ ê²Œì„ UIë¡œ í‘œí˜„ë©ë‹ˆë‹¤ (RULE-002).\n\nRU-003-T1: scene í•„ë“œ ì¶”ê°€ - Scene Canvasì˜ ì´ë¯¸ì§€ í‘œì‹œ ì •ë³´ SSOT.\n\nAttributes:\n    action_deck: ì•¡ì…˜ ì¹´ë“œ ë± (Q1 ê²°ì •: Option A ì±„íƒ)\n    objects: í´ë¦­ ê°€ëŠ¥í•œ ì¥ë©´ ì˜¤ë¸Œì íŠ¸ ëª©ë¡\n    scene: Scene í‘œì‹œ ì •ë³´ (RU-003-T1)",
      "properties": {
        "action_deck": {
          "$ref": "#/$defs/ActionDeck",
          "description": "ì•¡ì…˜ ì¹´ë“œ ë±"
        },
        "objects": {
          "default": [],
          "description": "í´ë¦­ ê°€ëŠ¥í•œ ì¥ë©´ ì˜¤ë¸Œì íŠ¸ ëª©ë¡",
          "items": {
            "$ref": "#/$defs/SceneObject"
          },
          "title": "Objects",
          "type": "array"
        },
        "scene": {
          "$ref": "#/$defs/SceneOutput",
          "default": {
            "image_url": null,
            "alt_text": null
          },
          "description": "Scene í‘œì‹œ ì •ë³´ (RU-003-T1)"
        }
      },
      "title": "UIOutput",
      "type": "object"
    },
    "ValidationBadge": {
      "description": "ê²€ì¦ ë°°ì§€ (RULE-008).\n\ní„´ ê²°ê³¼ì— ëŒ€í•œ ê²€ì¦ ìƒíƒœë¥¼ í‘œì‹œí•©ë‹ˆë‹¤.",
      "enum": [
        "schema_ok",
        "schema_fail",
        "economy_ok",
        "economy_fail",
        "safety_ok",
        "safety_blocked",
        "consistency_ok",
        "consistency_fail"
      ],
      "title": "ValidationBadge",
      "type": "string"
    },
    "WorldDelta": {
      "additionalProperties": false,
      "description": "ì„¸ê³„ ìƒíƒœ ë³€í™” (Q2 ê²°ì •: Option A - delta ì¤‘ì‹¬).\n\nì´ë²ˆ í„´ì—ì„œ ë³€ê²½ëœ ì„¸ê³„ ìƒíƒœë¥¼ ë‚˜íƒ€ëƒ…ë‹ˆë‹¤.\nsnapshotì€ SaveGameì—ë§Œ ì €ì¥í•˜ê³ , ë§¤ í„´ì€ deltaë§Œ ì „ì†¡í•©ë‹ˆë‹¤.\n\nAttributes:\n    rules_changed: ë³€ê²½ë˜ê±°ë‚˜ ì¶”ê°€ëœ ê·œì¹™ ëª©ë¡\n    inventory_added: ì¶”ê°€ëœ ì¸ë²¤í† ë¦¬ ì•„ì´í…œ\n    inventory_removed: ì œê±°ëœ ì¸ë²¤í† ë¦¬ ì•„ì´í…œ\n    quests_updated: ì—…ë°ì´íŠ¸ëœ í€˜ìŠ¤íŠ¸(ëª©í‘œ) ëª©ë¡\n    relationships_changed: ë³€ê²½ëœ ê´€ê³„\n    memory_pins: ì¤‘ìš” ì„¤ì • ê³ ì • í›„ë³´",
      "properties": {
        "rules_changed": {
          "default": [],
          "description": "ë³€ê²½ëœ ê·œì¹™ ëª©ë¡",
          "items": {
            "$ref": "#/$defs/WorldRule"
          },
          "title": "Rules Changed",
          "type": "array"
        },
        "inventory_added": {
          "default": [],
          "description": "ì¶”ê°€ëœ ì¸ë²¤í† ë¦¬ ì•„ì´í…œ",
          "items": {
            "type": "string"
          },
          "title": "Inventory Added",
          "type": "array"
        },
        "inventory_removed": {
          "default": [],
          "description": "ì œê±°ëœ ì¸ë²¤í† ë¦¬ ì•„ì´í…œ",
          "items": {
            "type": "string"
          },
          "title": "Inventory Removed",
          "type": "array"
        },
        "quests_updated": {
          "default": [],
          "description": "ì—…ë°ì´íŠ¸ëœ í€˜ìŠ¤íŠ¸/ëª©í‘œ ëª©ë¡",
          "items": {
            "$ref": "#/$defs/Quest"
          },
          "title": "Quests Updated",
          "type": "array"
        },
        "relationships_changed": {
          "default": [],
          "description": "ë³€ê²½ëœ ê´€ê³„",
          "items": {
            "type": "string"
          },
          "title": "Relationships Changed",
          "type": "array"
        },
        "memory_pins": {
          "default": [],
          "description": "ì¤‘ìš” ì„¤ì • ê³ ì • í›„ë³´",
          "items": {
            "$ref": "#/$defs/MemoryPin"
          },
          "title": "Memory Pins",
          "type": "array"
        }
      },
      "title": "WorldDelta",
      "type": "object"
    },
    "WorldRule": {
      "additionalProperties": false,
      "description": "ì„¸ê³„ ê·œì¹™ (Rule Board).\n\ní˜„ì¬ ì„¸ê³„ì— ì ìš© ì¤‘ì¸ ë¬¼ë¦¬ ë²•ì¹™ì´ë‚˜ ë©”íƒ€ ê·œì¹™ì…ë‹ˆë‹¤.\n\nAttributes:\n    id: ê·œì¹™ ê³ ìœ  ID\n    label: ê·œì¹™ ì´ë¦„\n    description: ê·œì¹™ ìƒì„¸ ì„¤ëª… (ì„ íƒ)",
      "properties": {
        "id": {
          "description": "ê·œì¹™ ê³ ìœ  ID",
          "title": "Id",
          "type": "string"
        },
        "label": {
          "description": "ê·œì¹™ ì´ë¦„",
          "title": "Label",
          "type": "string"
        },
        "description": {
          "anyOf": [
            {
              "type": "string"
            },
            {
              "type": "null"
            }
          ],
          "default": null,
          "description": "ê·œì¹™ ìƒì„¸ ì„¤ëª… (ì„ íƒ)",
          "title": "Description"
        }
      },
      "required": [
        "id",
        "label"
      ],
      "title": "WorldRule",
      "type": "object"
    }
  },
  "additionalProperties": false,
  "description": "í„´ ì¶œë ¥ (ì„œë²„ â†’ í´ë¼ì´ì–¸íŠ¸).\n\nì„œë²„ê°€ í„´ ì²˜ë¦¬ í›„ í´ë¼ì´ì–¸íŠ¸ë¡œ ë°˜í™˜í•˜ëŠ” êµ¬ì¡°í™”ëœ ì‘ë‹µì…ë‹ˆë‹¤.\nGemini Structured Outputs(JSON Schema)ë¡œ ê°•ì œë©ë‹ˆë‹¤.\n\nHard Gate í•„ë“œ (RULE-003/004/005):\n    - economy: costì™€ balance_after í•„ìˆ˜, ì”ì•¡ ìŒìˆ˜ ê¸ˆì§€\n    - safety: blocked ì‹œ ì•ˆì „í•œ ëŒ€ì²´ ê²°ê³¼ ì œê³µ\n    - language: ìš”ì²­ ì–¸ì–´ì™€ ë™ì¼í•˜ê²Œ ê³ ì • (í˜¼í•© ì¶œë ¥ ê¸ˆì§€)\n\nAttributes:\n    language: ì‘ë‹µ ì–¸ì–´ (ìš”ì²­ê³¼ ë™ì¼)\n    narrative: ë‚´ëŸ¬í‹°ë¸Œ í…ìŠ¤íŠ¸ (í‘œì‹œìš©)\n    ui: UI ìš”ì†Œ (ì•¡ì…˜ ë±, ì˜¤ë¸Œì íŠ¸)\n    world: ì„¸ê³„ ìƒíƒœ ë³€í™” (delta ì¤‘ì‹¬)\n    render: ë Œë”ë§ ì •ë³´ (ì´ë¯¸ì§€ ìƒì„± ì‘ì—…)\n    economy: ê²½ì œ ì •ë³´ (ë¹„ìš©, ì”ì•¡)\n    safety: ì•ˆì „ ì •ì±… ì •ë³´\n    agent_console: ì—ì´ì „íŠ¸ ì‹¤í–‰ ì •ë³´ (ë‹¨ê³„, ë°°ì§€, ë³µêµ¬ íšŸìˆ˜)\n\nExample:\n    >>> output = TurnOutput(\n    ...     language=Language.KO,\n    ...     narrative=\"ë¬¸ì´ ì‚ê±±ê±°ë¦¬ë©° ì—´ë¦½ë‹ˆë‹¤...\",\n    ...     economy=EconomyOutput(\n    ...         cost=CurrencyAmount(signal=5, memory_shard=0),\n    ...         balance_after=CurrencyAmount(signal=95, memory_shard=5),\n    ...     ),\n    ...     safety=SafetyOutput(blocked=False),\n    ... )\n    >>> schema = TurnOutput.model_json_schema()\n\nSchema Generation:\n    >>> # Gemini Structured Outputsìš© JSON Schema ìƒì„±\n    >>> json_schema = TurnOutput.model_json_schema()\n    >>> # response_json_schema íŒŒë¼ë¯¸í„°ì— ì „ë‹¬\n    >>> config = {\n    ...     \"response_mime_type\": \"application/json\",\n    ...     \"response_json_schema\": json_schema,\n    ... }",
  "properties": {
    "language": {
      "$ref": "#/$defs/Language",
      "description": "ì‘ë‹µ ì–¸ì–´ (ìš”ì²­ê³¼ ë™ì¼)"
    },
    "narrative": {
      "description": "ë‚´ëŸ¬í‹°ë¸Œ í…ìŠ¤íŠ¸ (í‘œì‹œìš©)",
      "title": "Narrative",
      "type": "string"
    },
    "economy": {
      "$ref": "#/$defs/EconomyOutput",
      "description": "ê²½ì œ ì •ë³´ (ë¹„ìš©, ì”ì•¡)"
    },
    "safety": {
      "$ref": "#/$defs/SafetyOutput",
      "description": "ì•ˆì „ ì •ì±… ì •ë³´"
    },
    "ui": {
      "$ref": "#/$defs/UIOutput",
      "description": "UI ìš”ì†Œ"
    },
    "world": {
      "$ref": "#/$defs/WorldDelta",
      "description": "ì„¸ê³„ ìƒíƒœ ë³€í™” (delta)"
    },
    "render": {
      "$ref": "#/$defs/RenderOutput",
      "description": "ë Œë”ë§ ì •ë³´"
    },
    "agent_console": {
      "$ref": "#/$defs/AgentConsole",
      "description": "ì—ì´ì „íŠ¸ ì‹¤í–‰ ì •ë³´"
    }
  },
  "required": [
    "language",
    "narrative",
    "economy",
    "safety"
  ],
  "title": "TurnOutput",
  "type": "object"
}
</file>

<file path="backend/src/unknown_world/api/item_icon.py">
"""Unknown World - ì•„ì´í…œ ì•„ì´ì½˜ ìƒì„± API (U-075[Mvp]).

ì•„ì´í…œ ì„¤ëª…ì„ ê¸°ë°˜ìœ¼ë¡œ ë™ì  ì•„ì´ì½˜ì„ ìƒì„±í•˜ëŠ” API ì—”ë“œí¬ì¸íŠ¸ì…ë‹ˆë‹¤.

ì„¤ê³„ ì›ì¹™:
    - RULE-004: ì‹¤íŒ¨ ì‹œ ì•ˆì „í•œ í´ë°± ì œê³µ
    - RULE-006: ko/en ì–¸ì–´ ì •ì±… ì¤€ìˆ˜
    - RULE-007: í”„ë¡¬í”„íŠ¸ ì›ë¬¸ ë…¸ì¶œ ê¸ˆì§€

í˜ì–´ë§ ì§ˆë¬¸ ê²°ì • (U-075[Mvp]):
    - Q1: Option B (placeholder ë¨¼ì € í‘œì‹œ í›„ ë°±ê·¸ë¼ìš´ë“œ ìƒì„±)

ì°¸ì¡°:
    - vibe/unit-plans/U-075[Mvp].md
"""

from __future__ import annotations

import logging
from typing import Annotated

from fastapi import APIRouter, Query
from pydantic import BaseModel, ConfigDict, Field

from unknown_world.services.item_icon_generator import (
    IconGenerationRequest,
    get_item_icon_generator,
)

# =============================================================================
# ë¡œê±° ì„¤ì •
# =============================================================================

logger = logging.getLogger(__name__)

# =============================================================================
# ë¼ìš°í„° ì„¤ì •
# =============================================================================

router = APIRouter(prefix="/api/item", tags=["item"])


# =============================================================================
# API ëª¨ë¸
# =============================================================================


class GenerateIconRequest(BaseModel):
    """ì•„ì´ì½˜ ìƒì„± ìš”ì²­ (API).

    Attributes:
        item_id: ì•„ì´í…œ ê³ ìœ  ID
        description: ì•„ì´í…œ ì„¤ëª… (ì•„ì´ì½˜ ìƒì„±ìš©)
        language: í˜„ì¬ ì„¸ì…˜ ì–¸ì–´
        wait: ìƒì„± ì™„ë£Œê¹Œì§€ ëŒ€ê¸°í• ì§€ ì—¬ë¶€
    """

    model_config = ConfigDict(extra="forbid")

    item_id: str = Field(description="ì•„ì´í…œ ê³ ìœ  ID")
    description: str = Field(description="ì•„ì´í…œ ì„¤ëª… (ì•„ì´ì½˜ ìƒì„±ìš©)")
    language: str = Field(default="ko-KR", description="í˜„ì¬ ì„¸ì…˜ ì–¸ì–´ (ko-KR/en-US)")
    wait: bool = Field(
        default=False,
        description="ìƒì„± ì™„ë£Œê¹Œì§€ ëŒ€ê¸° (false: placeholder ì¦‰ì‹œ ë°˜í™˜)",
    )


class IconResponse(BaseModel):
    """ì•„ì´ì½˜ ì‘ë‹µ (API).

    Attributes:
        status: ìƒì„± ìƒíƒœ
        icon_url: ì•„ì´ì½˜ URL
        item_id: ì•„ì´í…œ ID
        is_placeholder: placeholder ì•„ì´ì½˜ ì—¬ë¶€
        message: ìƒíƒœ ë©”ì‹œì§€
    """

    model_config = ConfigDict(extra="forbid")

    status: str = Field(description="ìƒì„± ìƒíƒœ")
    icon_url: str = Field(description="ì•„ì´ì½˜ URL")
    item_id: str = Field(description="ì•„ì´í…œ ID")
    is_placeholder: bool = Field(default=False, description="placeholder ì•„ì´ì½˜ ì—¬ë¶€")
    message: str | None = Field(default=None, description="ìƒíƒœ ë©”ì‹œì§€")


class IconStatusResponse(BaseModel):
    """ì•„ì´ì½˜ ìƒíƒœ ì‘ë‹µ (API).

    Attributes:
        item_id: ì•„ì´í…œ ID
        status: ìƒì„± ìƒíƒœ
    """

    model_config = ConfigDict(extra="forbid")

    item_id: str = Field(description="ì•„ì´í…œ ID")
    status: str = Field(description="ìƒì„± ìƒíƒœ")


# =============================================================================
# API ì—”ë“œí¬ì¸íŠ¸
# =============================================================================


@router.post("/icon", response_model=IconResponse)
async def generate_item_icon(request: GenerateIconRequest) -> IconResponse:
    """ì•„ì´í…œ ì•„ì´ì½˜ì„ ìƒì„±í•©ë‹ˆë‹¤.

    Q1 ê²°ì • (Option B): wait=falseë©´ placeholder ì¦‰ì‹œ ë°˜í™˜ í›„ ë°±ê·¸ë¼ìš´ë“œ ìƒì„±.

    Args:
        request: ì•„ì´ì½˜ ìƒì„± ìš”ì²­

    Returns:
        IconResponse: ì•„ì´ì½˜ URL ë° ìƒíƒœ
    """
    logger.info(
        "[ItemIconAPI] ì•„ì´ì½˜ ìƒì„± ìš”ì²­",
        extra={
            "item_id": request.item_id,
            "language": request.language,
            "wait": request.wait,
        },
    )

    generator = get_item_icon_generator()
    gen_request = IconGenerationRequest(
        item_id=request.item_id,
        item_description=request.description,
        language=request.language,
    )

    result = await generator.generate_icon(
        gen_request,
        wait_for_completion=request.wait,
    )

    return IconResponse(
        status=result.status.value,
        icon_url=result.icon_url,
        item_id=result.item_id,
        is_placeholder=result.is_placeholder,
        message=result.message,
    )


@router.get("/icon/{item_id}/status", response_model=IconStatusResponse)
async def get_icon_status(item_id: str) -> IconStatusResponse:
    """ì•„ì´ì½˜ ìƒì„± ìƒíƒœë¥¼ í™•ì¸í•©ë‹ˆë‹¤.

    Args:
        item_id: ì•„ì´í…œ ID

    Returns:
        IconStatusResponse: í˜„ì¬ ìƒíƒœ
    """
    generator = get_item_icon_generator()
    status = await generator.get_icon_status(item_id)

    return IconStatusResponse(
        item_id=item_id,
        status=status.value,
    )


@router.get("/icon", response_model=IconResponse)
async def get_or_generate_icon(
    item_id: Annotated[str, Query(description="ì•„ì´í…œ ê³ ìœ  ID")],
    description: Annotated[str, Query(description="ì•„ì´í…œ ì„¤ëª…")],
    language: Annotated[str, Query(description="ì„¸ì…˜ ì–¸ì–´")] = "ko-KR",
) -> IconResponse:
    """ì•„ì´ì½˜ì„ ì¡°íšŒí•˜ê±°ë‚˜ ìƒì„±í•©ë‹ˆë‹¤ (GET ë°©ì‹).

    ìºì‹œì— ìˆìœ¼ë©´ ì¦‰ì‹œ ë°˜í™˜, ì—†ìœ¼ë©´ ë°±ê·¸ë¼ìš´ë“œ ìƒì„± ì‹œì‘ í›„ placeholder ë°˜í™˜.

    Args:
        item_id: ì•„ì´í…œ ID
        description: ì•„ì´í…œ ì„¤ëª…
        language: ì„¸ì…˜ ì–¸ì–´

    Returns:
        IconResponse: ì•„ì´ì½˜ URL ë° ìƒíƒœ
    """
    generator = get_item_icon_generator()
    gen_request = IconGenerationRequest(
        item_id=item_id,
        item_description=description,
        language=language,
    )

    result = await generator.generate_icon(
        gen_request,
        wait_for_completion=False,  # GETì€ í•­ìƒ ë¹„ë™ê¸°
    )

    return IconResponse(
        status=result.status.value,
        icon_url=result.icon_url,
        item_id=result.item_id,
        is_placeholder=result.is_placeholder,
        message=result.message,
    )
</file>

<file path="backend/src/unknown_world/config/__init__.py">
"""Unknown World - ì„¤ì • ë° ìƒìˆ˜ íŒ¨í‚¤ì§€.

ì´ íŒ¨í‚¤ì§€ëŠ” í”„ë¡œì íŠ¸ ì „ì—­ì—ì„œ ì‚¬ìš©í•˜ëŠ” ì„¤ì •ê°’ê³¼ ìƒìˆ˜ë¥¼ ê´€ë¦¬í•©ë‹ˆë‹¤.
ëª¨ë¸ ID, í™˜ê²½ ì„¤ì •, ì •ì±… ë“± SSOTë¥¼ ìœ ì§€í•˜ê¸° ìœ„í•œ ì¤‘ì•™ ì €ì¥ì†Œì…ë‹ˆë‹¤.

ì°¸ì¡°:
    - vibe/tech-stack.md (ë²„ì „/ëª¨ë¸ SSOT)
    - .cursor/rules/00-core-critical.mdc (RULE-010: ë²„ì „/ìŠ¤íƒ ê³ ì •)
"""

from unknown_world.config.models import (
    MODEL_FAST,
    MODEL_IMAGE,
    MODEL_QUALITY,
    ModelLabel,
    get_model_id,
)

__all__ = [
    "MODEL_FAST",
    "MODEL_QUALITY",
    "MODEL_IMAGE",
    "ModelLabel",
    "get_model_id",
]
</file>

<file path="backend/src/unknown_world/config/economy.py">
"""Unknown World - ê²½ì œ ì •ì±… ë° ìƒìˆ˜ ì •ì˜.

ì´ ëª¨ë“ˆì€ ì¬í™”(Signal, Memory Shard)ì™€ ê´€ë ¨ëœ ì •ì±… ìƒìˆ˜ë¥¼ SSOTë¡œ ê´€ë¦¬í•©ë‹ˆë‹¤.

ì°¸ì¡°:
    - vibe/prd.md 5ì¥ (ì¬í™” ì‹œìŠ¤í…œ)
    - vibe/unit-plans/U-079[Mvp].md
"""

from typing import Final

# =============================================================================
# ì¬í™” ì •ì±… ìƒìˆ˜
# =============================================================================

LOW_BALANCE_THRESHOLD: Final[int] = 10
"""ì”ì•¡ ë¶€ì¡± ê²½ê³ ë¥¼ í™œì„±í™”í•˜ëŠ” Signal ì„ê³„ê°’."""

MAX_CREDIT: Final[int] = 50
"""í—ˆìš©ë˜ëŠ” ìµœëŒ€ í¬ë ˆë”§(ë¹š) í•œë„ (Signal ë‹¨ìœ„)."""

# =============================================================================
# ì´ë¯¸ì§€ ìƒì„± ë¹„ìš© (QUALITY)
# =============================================================================

IMAGE_GENERATION_COST_SIGNAL: Final[int] = 10
"""ì´ë¯¸ì§€ ìƒì„± ê¸°ë³¸ Signal ë¹„ìš©."""

IMAGE_GENERATION_COST_MEMORY_SHARD: Final[int] = 0
"""ì´ë¯¸ì§€ ìƒì„± ê¸°ë³¸ Memory Shard ë¹„ìš©."""

# =============================================================================
# ì´ë¯¸ì§€ ìƒì„± ë¹„ìš© (FAST í´ë°±)
# =============================================================================

FAST_IMAGE_COST_SIGNAL: Final[int] = 0
"""ì”ì•¡ ë¶€ì¡± ì‹œ FAST í´ë°± ì´ë¯¸ì§€ Signal ë¹„ìš© (ë¬´ë£Œ)."""
</file>

<file path="backend/src/unknown_world/models/__init__.py">
"""Unknown World - ëª¨ë¸ íŒ¨í‚¤ì§€.

ì´ íŒ¨í‚¤ì§€ëŠ” TurnInput/TurnOutput ìŠ¤í‚¤ë§ˆ ë° í•˜ìœ„ íƒ€ì…ì„ ì •ì˜í•©ë‹ˆë‹¤.
Gemini Structured Outputs(JSON Schema)ìš©ìœ¼ë¡œ ì„¤ê³„ë˜ì—ˆìŠµë‹ˆë‹¤.

ì‚¬ìš© ì˜ˆì‹œ:
    from unknown_world.models import TurnInput, TurnOutput

    # Pydantic â†’ JSON Schema ë³€í™˜ (Gemini response_json_schemaìš©)
    schema = TurnOutput.model_json_schema()

    # ì‘ë‹µ ê²€ì¦
    output = TurnOutput.model_validate_json(response_text)

ì°¸ì¡°:
    - vibe/prd.md 8.7 (ë°ì´í„° ëª¨ë¸ ì„¤ê³„)
    - vibe/ref/structured-outputs-guide.md
    - .cursor/rules/00-core-critical.mdc (RULE-003, RULE-005)
"""

from unknown_world.models.scanner import (
    DetectedObject,
    ItemCandidate,
    ScanRequest,
    ScanResponse,
    ScanResult,
    ScanStatus,
)
from unknown_world.models.turn import (
    ActionCard,
    ActionDeck,
    AgentConsole,
    AgentPhase,
    Box2D,
    ClickInput,
    ClientInfo,
    Coordinate,
    CurrencyAmount,
    EconomyOutput,
    EconomySnapshot,
    ImageJob,
    Language,
    MemoryPin,
    ModelLabel,
    Quest,
    RenderOutput,
    RiskLevel,
    SafetyOutput,
    SceneObject,
    Theme,
    TurnInput,
    TurnOutput,
    UIOutput,
    ValidationBadge,
    WorldDelta,
    WorldRule,
)

__all__ = [
    # Enum íƒ€ì…
    "Language",
    "Theme",
    "AgentPhase",
    "ValidationBadge",
    "ModelLabel",
    "RiskLevel",
    # ê³µí†µ í•˜ìœ„ íƒ€ì…
    "Coordinate",
    "Box2D",
    "CurrencyAmount",
    # TurnInput ê´€ë ¨
    "TurnInput",
    "ClickInput",
    "ClientInfo",
    "EconomySnapshot",
    # TurnOutput ê´€ë ¨
    "TurnOutput",
    "UIOutput",
    "ActionDeck",
    "ActionCard",
    "SceneObject",
    "WorldDelta",
    "WorldRule",
    "Quest",
    "MemoryPin",
    "RenderOutput",
    "ImageJob",
    "EconomyOutput",
    "SafetyOutput",
    "AgentConsole",
    # Scanner ê´€ë ¨ (U-021)
    "ScanStatus",
    "DetectedObject",
    "ItemCandidate",
    "ScanResult",
    "ScanRequest",
    "ScanResponse",
]
</file>

<file path="backend/src/unknown_world/orchestrator/stages/__init__.py">
"""Unknown World - Pipeline Stages íŒ¨í‚¤ì§€.

ì˜¤ì¼€ìŠ¤íŠ¸ë ˆì´í„° íŒŒì´í”„ë¼ì¸ì˜ ê° ë‹¨ê³„(stage)ë¥¼ ëª¨ë“ˆë¡œ ë¶„ë¦¬í•©ë‹ˆë‹¤.

ë‹¨ê³„ ëª©ë¡ (PRD ê¸°ì¤€):
    - parse: ì…ë ¥ íŒŒì‹± (ì´ë¯¸ TurnInputìœ¼ë¡œ ë³€í™˜ë¨, phase ì „ì´ë§Œ ë‹´ë‹¹)
    - validate: ë¹„ì¦ˆë‹ˆìŠ¤ ë£° ê²€ì¦ + Repair loop (í•µì‹¬)
    - plan: ê³„íš ìˆ˜ë¦½ (í˜„ì¬ pass-through)
    - resolve: í•´ê²° (í˜„ì¬ pass-through)
    - render: ë Œë”ë§ (í˜„ì¬ pass-through)
    - verify: ê²€ì¦ (í˜„ì¬ pass-through)
    - commit: ì»¤ë°‹ (ìµœì¢… í™•ì •)

ì„¤ê³„ ì›ì¹™:
    - Option A (RU-005 Q1 ê²°ì •): í•¨ìˆ˜ ì²´ì¸ ë°©ì‹, í´ë˜ìŠ¤ ë„ì… ì—†ìŒ
    - ë™ì‘ ë³´ì¡´: ê¸°ì¡´ mock/real ê²½ë¡œì˜ ê²°ê³¼(JSON) ì˜ë¯¸ ìœ ì§€
    - ê´€ì¸¡ ê°€ëŠ¥ì„± SSOT: stage start/complete/fail, badges, repairë¥¼ pipelineì—ì„œ ì¼ê´€ë˜ê²Œ ìƒì„±

ì°¸ì¡°:
    - vibe/refactors/RU-005-Q4.md
    - vibe/refactors/RU-005-SUMMARY.md
"""

from unknown_world.orchestrator.stages.commit import commit_stage
from unknown_world.orchestrator.stages.parse import parse_stage
from unknown_world.orchestrator.stages.plan import plan_stage
from unknown_world.orchestrator.stages.render import render_stage
from unknown_world.orchestrator.stages.resolve import resolve_stage
from unknown_world.orchestrator.stages.types import (
    EmitFn,
    PipelineContext,
    PipelineEvent,
    PipelineEventType,
    StageFn,
)
from unknown_world.orchestrator.stages.validate import validate_stage
from unknown_world.orchestrator.stages.verify import verify_stage

__all__ = [
    # Types
    "PipelineContext",
    "PipelineEvent",
    "PipelineEventType",
    "EmitFn",
    "StageFn",
    # Stages
    "parse_stage",
    "validate_stage",
    "plan_stage",
    "resolve_stage",
    "render_stage",
    "verify_stage",
    "commit_stage",
]
</file>

<file path="backend/src/unknown_world/orchestrator/stages/commit.py">
"""Unknown World - Commit Stage.

ì»¤ë°‹ ë‹¨ê³„ì…ë‹ˆë‹¤.
íŒŒì´í”„ë¼ì¸ì˜ ìµœì¢… ë‹¨ê³„ë¡œ, TurnOutputì„ í™•ì •í•©ë‹ˆë‹¤.

ì„¤ê³„ ì›ì¹™:
    - RULE-008: ë‹¨ê³„ ì´ë²¤íŠ¸ ì¼ê´€ì„±
    - ë™ì‘ ë³´ì¡´: ê¸°ì¡´ ì‹œë®¬ë ˆì´ì…˜ ì§€ì—° ìœ ì§€

ì°¸ì¡°:
    - vibe/refactors/RU-005-Q4.md
"""

from __future__ import annotations

import asyncio

from unknown_world.models.turn import AgentPhase
from unknown_world.orchestrator.stages.types import (
    EmitFn,
    PipelineContext,
    PipelineEvent,
    PipelineEventType,
)

# ëª¨ì˜ ì²˜ë¦¬ ì§€ì—° ì‹œê°„ (ms)
COMMIT_DELAY_MS = 20


async def commit_stage(ctx: PipelineContext, *, emit: EmitFn) -> PipelineContext:
    """Commit ë‹¨ê³„ë¥¼ ì‹¤í–‰í•©ë‹ˆë‹¤.

    íŒŒì´í”„ë¼ì¸ì˜ ìµœì¢… ë‹¨ê³„ë¡œ, TurnOutputì„ í™•ì •í•©ë‹ˆë‹¤.

    Args:
        ctx: íŒŒì´í”„ë¼ì¸ ì»¨í…ìŠ¤íŠ¸
        emit: ì´ë²¤íŠ¸ emit ì½œë°±

    Returns:
        ì—…ë°ì´íŠ¸ëœ ì»¨í…ìŠ¤íŠ¸
    """
    ctx.current_phase = AgentPhase.COMMIT

    # Stage ì‹œì‘ ì´ë²¤íŠ¸
    await emit(
        PipelineEvent(
            event_type=PipelineEventType.STAGE_START,
            phase=AgentPhase.COMMIT,
        )
    )

    # ëª¨ì˜ ì²˜ë¦¬ ì§€ì—° (ê¸°ì¡´ ë™ì‘ ë³´ì¡´)
    await asyncio.sleep(COMMIT_DELAY_MS / 1000.0)

    # Stage ì™„ë£Œ ì´ë²¤íŠ¸
    await emit(
        PipelineEvent(
            event_type=PipelineEventType.STAGE_COMPLETE,
            phase=AgentPhase.COMMIT,
        )
    )

    return ctx
</file>

<file path="backend/src/unknown_world/orchestrator/stages/parse.py">
"""Unknown World - Parse Stage.

ì…ë ¥ íŒŒì‹± ë‹¨ê³„ì…ë‹ˆë‹¤.
TurnInputì€ ì´ë¯¸ API ë ˆì´ì–´ì—ì„œ íŒŒì‹±ë˜ì—ˆìœ¼ë¯€ë¡œ, phase ì „ì´ë§Œ ë‹´ë‹¹í•©ë‹ˆë‹¤.

ì„¤ê³„ ì›ì¹™:
    - RULE-008: ë‹¨ê³„ ì´ë²¤íŠ¸ ì¼ê´€ì„± (stage start/complete)
    - ë™ì‘ ë³´ì¡´: ê¸°ì¡´ ë™ì‘ ìœ ì§€

ì°¸ì¡°:
    - vibe/refactors/RU-005-Q4.md
"""

from __future__ import annotations

from unknown_world.models.turn import AgentPhase
from unknown_world.orchestrator.stages.types import (
    EmitFn,
    PipelineContext,
    PipelineEvent,
    PipelineEventType,
)


async def parse_stage(ctx: PipelineContext, *, emit: EmitFn) -> PipelineContext:
    """Parse ë‹¨ê³„ë¥¼ ì‹¤í–‰í•©ë‹ˆë‹¤.

    ì…ë ¥ì€ ì´ë¯¸ TurnInputìœ¼ë¡œ íŒŒì‹±ë˜ì—ˆìœ¼ë¯€ë¡œ, phase ì „ì´ë§Œ ë‹´ë‹¹í•©ë‹ˆë‹¤.
    TTFBë¥¼ ìœ„í•´ ê°€ì¥ ë¨¼ì € stage ì´ë²¤íŠ¸ë¥¼ ì „ì†¡í•©ë‹ˆë‹¤.

    Args:
        ctx: íŒŒì´í”„ë¼ì¸ ì»¨í…ìŠ¤íŠ¸
        emit: ì´ë²¤íŠ¸ emit ì½œë°±

    Returns:
        ì—…ë°ì´íŠ¸ëœ ì»¨í…ìŠ¤íŠ¸
    """
    ctx.current_phase = AgentPhase.PARSE

    # Stage ì‹œì‘ ì´ë²¤íŠ¸ (TTFBë¥¼ ìœ„í•´ ì¦‰ì‹œ ì „ì†¡)
    await emit(
        PipelineEvent(
            event_type=PipelineEventType.STAGE_START,
            phase=AgentPhase.PARSE,
        )
    )

    # Parse ë‹¨ê³„ëŠ” ì´ë¯¸ API ë ˆì´ì–´ì—ì„œ ì™„ë£Œë¨
    # (TurnInput ê²€ì¦ì€ FastAPI/Pydanticì—ì„œ ì²˜ë¦¬)

    # Stage ì™„ë£Œ ì´ë²¤íŠ¸
    await emit(
        PipelineEvent(
            event_type=PipelineEventType.STAGE_COMPLETE,
            phase=AgentPhase.PARSE,
        )
    )

    return ctx
</file>

<file path="backend/src/unknown_world/orchestrator/stages/plan.py">
"""Unknown World - Plan Stage.

ê³„íš ìˆ˜ë¦½ ë‹¨ê³„ì…ë‹ˆë‹¤.
í˜„ì¬ MVPì—ì„œëŠ” ì‹¤ì œ ì²˜ë¦¬ ì—†ì´ pass-throughë¡œ ë™ì‘í•©ë‹ˆë‹¤.
ì¶”í›„ Autopilot(U-024) ë“±ì—ì„œ ë¡œì§ì„ ì¶”ê°€í•  ìë¦¬ì…ë‹ˆë‹¤.

ì„¤ê³„ ì›ì¹™:
    - RULE-008: ë‹¨ê³„ ì´ë²¤íŠ¸ ì¼ê´€ì„±
    - ë™ì‘ ë³´ì¡´: ê¸°ì¡´ ì‹œë®¬ë ˆì´ì…˜ ì§€ì—° ìœ ì§€

ì°¸ì¡°:
    - vibe/refactors/RU-005-Q4.md
"""

from __future__ import annotations

import asyncio

from unknown_world.models.turn import AgentPhase
from unknown_world.orchestrator.stages.types import (
    EmitFn,
    PipelineContext,
    PipelineEvent,
    PipelineEventType,
)

# ëª¨ì˜ ì²˜ë¦¬ ì§€ì—° ì‹œê°„ (ms)
PLAN_DELAY_MS = 100


async def plan_stage(ctx: PipelineContext, *, emit: EmitFn) -> PipelineContext:
    """Plan ë‹¨ê³„ë¥¼ ì‹¤í–‰í•©ë‹ˆë‹¤.

    í˜„ì¬ëŠ” pass-throughë¡œ ë™ì‘í•©ë‹ˆë‹¤.
    ì¶”í›„ Autopilot ë“±ì—ì„œ ê³„íš ìˆ˜ë¦½ ë¡œì§ì„ ì¶”ê°€í•©ë‹ˆë‹¤.

    Args:
        ctx: íŒŒì´í”„ë¼ì¸ ì»¨í…ìŠ¤íŠ¸
        emit: ì´ë²¤íŠ¸ emit ì½œë°±

    Returns:
        ì—…ë°ì´íŠ¸ëœ ì»¨í…ìŠ¤íŠ¸
    """
    ctx.current_phase = AgentPhase.PLAN

    # Stage ì‹œì‘ ì´ë²¤íŠ¸
    await emit(
        PipelineEvent(
            event_type=PipelineEventType.STAGE_START,
            phase=AgentPhase.PLAN,
        )
    )

    # ëª¨ì˜ ì²˜ë¦¬ ì§€ì—° (ê¸°ì¡´ ë™ì‘ ë³´ì¡´)
    await asyncio.sleep(PLAN_DELAY_MS / 1000.0)

    # Stage ì™„ë£Œ ì´ë²¤íŠ¸
    await emit(
        PipelineEvent(
            event_type=PipelineEventType.STAGE_COMPLETE,
            phase=AgentPhase.PLAN,
        )
    )

    return ctx
</file>

<file path="backend/src/unknown_world/storage/paths.py">
"""Unknown World - ìŠ¤í† ë¦¬ì§€ ê²½ë¡œ ìƒìˆ˜.

ëª¨ë“  ì €ì¥ ê²½ë¡œ ë° URL ê´€ë ¨ ìƒìˆ˜ë¥¼ ì¤‘ì•™ ê´€ë¦¬í•©ë‹ˆë‹¤.
MVP: ë¡œì»¬ íŒŒì¼ ì‹œìŠ¤í…œ ê²½ë¡œ
MMP: GCS ë²„í‚· ê²½ë¡œë¡œ í™•ì¥ ì˜ˆì •

í˜ì–´ë§ ì§ˆë¬¸ Q1 ê²°ì •: Option A (backend/.data/ ì „ìš© í´ë”)

ì°¸ì¡°:
    - vibe/refactors/RU-006-Q5.md
"""

from __future__ import annotations

from pathlib import Path
from typing import Final

# =============================================================================
# ê¸°ë³¸ ë””ë ‰í† ë¦¬ (MVP: ë¡œì»¬)
# =============================================================================

# í˜ì–´ë§ ì§ˆë¬¸ Q1: Option A - backend/.data/ ì „ìš© í´ë”
# .gitignoreì— backend/.data/ ì¶”ê°€ í•„ìˆ˜
BASE_DATA_DIR: Final[Path] = Path(".data")
"""ëª¨ë“  ë°ì´í„° íŒŒì¼ì˜ ë£¨íŠ¸ ë””ë ‰í† ë¦¬."""

# í•˜ìœ„ í˜¸í™˜ì„±ì„ ìœ„í•œ ë ˆê±°ì‹œ ê²½ë¡œ (deprecated, ë§ˆì´ê·¸ë ˆì´ì…˜ìš©)
LEGACY_OUTPUT_DIR: Final[Path] = Path("generated_images")
"""[Deprecated] ê¸°ì¡´ ì´ë¯¸ì§€ ì €ì¥ ê²½ë¡œ. .data/ë¡œ ë§ˆì´ê·¸ë ˆì´ì…˜ ê¶Œì¥."""

# =============================================================================
# ì¹´í…Œê³ ë¦¬ë³„ ì„œë¸Œ ê²½ë¡œ
# =============================================================================

IMAGES_GENERATED_SUBDIR: Final[str] = "images/generated"
"""ìƒì„±ëœ ì´ë¯¸ì§€ ì €ì¥ ì„œë¸Œ ë””ë ‰í† ë¦¬."""

IMAGES_UPLOADED_SUBDIR: Final[str] = "images/uploaded"
"""ì—…ë¡œë“œëœ ì´ë¯¸ì§€ ì €ì¥ ì„œë¸Œ ë””ë ‰í† ë¦¬."""

ARTIFACTS_SUBDIR: Final[str] = "artifacts"
"""ê²Œì„ ì•„í‹°íŒ©íŠ¸ ì €ì¥ ì„œë¸Œ ë””ë ‰í† ë¦¬."""

# =============================================================================
# URL í”„ë¦¬í”½ìŠ¤
# =============================================================================

STATIC_URL_PREFIX: Final[str] = "/static"
"""ì •ì  íŒŒì¼ ì„œë¹™ URL í”„ë¦¬í”½ìŠ¤."""

# ì „ì²´ ê²½ë¡œ (ìì£¼ ì‚¬ìš©ë˜ëŠ” ì¡°í•©)
STATIC_IMAGES_URL_PREFIX: Final[str] = f"{STATIC_URL_PREFIX}/images"
"""ì´ë¯¸ì§€ íŒŒì¼ URL í”„ë¦¬í”½ìŠ¤ (ì˜ˆ: /static/images/generated/xxx.png)."""

# =============================================================================
# íŒŒì¼ í™•ì¥ì
# =============================================================================

DEFAULT_IMAGE_EXTENSION: Final[str] = "png"
"""ê¸°ë³¸ ì´ë¯¸ì§€ íŒŒì¼ í™•ì¥ì."""

# =============================================================================
# ê²½ë¡œ í—¬í¼ í•¨ìˆ˜
# =============================================================================


def get_generated_images_dir() -> Path:
    """ìƒì„±ëœ ì´ë¯¸ì§€ ì €ì¥ ë””ë ‰í† ë¦¬ ê²½ë¡œë¥¼ ë°˜í™˜í•©ë‹ˆë‹¤."""
    return BASE_DATA_DIR / IMAGES_GENERATED_SUBDIR


def get_uploaded_images_dir() -> Path:
    """ì—…ë¡œë“œëœ ì´ë¯¸ì§€ ì €ì¥ ë””ë ‰í† ë¦¬ ê²½ë¡œë¥¼ ë°˜í™˜í•©ë‹ˆë‹¤."""
    return BASE_DATA_DIR / IMAGES_UPLOADED_SUBDIR


def get_artifacts_dir() -> Path:
    """ì•„í‹°íŒ©íŠ¸ ì €ì¥ ë””ë ‰í† ë¦¬ ê²½ë¡œë¥¼ ë°˜í™˜í•©ë‹ˆë‹¤."""
    return BASE_DATA_DIR / ARTIFACTS_SUBDIR


def build_image_url(
    filename: str,
    *,
    category: str = "generated",
) -> str:
    """ì´ë¯¸ì§€ íŒŒì¼ì˜ ì„œë¹™ URLì„ ìƒì„±í•©ë‹ˆë‹¤.

    Args:
        filename: íŒŒì¼ëª… (í™•ì¥ì í¬í•¨)
        category: ì´ë¯¸ì§€ ì¹´í…Œê³ ë¦¬ ("generated" ë˜ëŠ” "uploaded")

    Returns:
        ì„œë¹™ URL (ì˜ˆ: /static/images/generated/img_abc123.png)
    """
    return f"{STATIC_URL_PREFIX}/images/{category}/{filename}"


def build_legacy_image_url(filename: str) -> str:
    """[Deprecated] ë ˆê±°ì‹œ ì´ë¯¸ì§€ URLì„ ìƒì„±í•©ë‹ˆë‹¤.

    ê¸°ì¡´ ì½”ë“œ í˜¸í™˜ì„±ì„ ìœ„í•´ ìœ ì§€. ì‹ ê·œ ì½”ë“œì—ì„œëŠ” build_image_url() ì‚¬ìš©.

    Args:
        filename: íŒŒì¼ëª… (í™•ì¥ì í¬í•¨)

    Returns:
        ë ˆê±°ì‹œ URL (ì˜ˆ: /static/images/img_abc123.png)
    """
    return f"/static/images/{filename}"
</file>

<file path="backend/src/unknown_world/storage/storage.py">
"""Unknown World - ìŠ¤í† ë¦¬ì§€ ì¶”ìƒí™” ì¸í„°í˜ì´ìŠ¤.

MVPì—ì„œëŠ” ë¡œì»¬ íŒŒì¼ ì‹œìŠ¤í…œ, MMPì—ì„œëŠ” GCSë¡œ í™•ì¥ ê°€ëŠ¥í•œ êµ¬ì¡°.

ì„¤ê³„ ì›ì¹™:
    - RULE-007: íŒŒì¼ ë‚´ìš©/ê²½ë¡œ ë¡œê¹… ì‹œ ë©”íƒ€ë§Œ ê¸°ë¡
    - RULE-010: DB ëŒ€ì‹  íŒŒì¼ ê¸°ë°˜ ì €ì¥ ìš°ì„ 

ì°¸ì¡°:
    - vibe/refactors/RU-006-Q4.md
"""

from __future__ import annotations

from abc import ABC, abstractmethod
from dataclasses import dataclass
from datetime import datetime
from enum import StrEnum


class StorageCategory(StrEnum):
    """ì €ì¥ ì¹´í…Œê³ ë¦¬."""

    GENERATED_IMAGE = "generated_image"
    """ìƒì„±ëœ ì´ë¯¸ì§€ (U-019)"""

    UPLOADED_IMAGE = "uploaded_image"
    """ì—…ë¡œë“œëœ ì´ë¯¸ì§€ (U-021, ì„ íƒì )"""

    ARTIFACT = "artifact"
    """ê²Œì„ ì•„í‹°íŒ©íŠ¸ (ì—”ë”© ë¦¬í¬íŠ¸, ë¦¬í”Œë ˆì´ ë“±)"""


@dataclass
class StorageMetadata:
    """ì €ì¥ëœ íŒŒì¼ ë©”íƒ€ë°ì´í„°."""

    key: str
    """ìŠ¤í† ë¦¬ì§€ ë‚´ ê³ ìœ  í‚¤"""

    category: StorageCategory
    """ì €ì¥ ì¹´í…Œê³ ë¦¬"""

    size_bytes: int
    """íŒŒì¼ í¬ê¸°"""

    content_type: str
    """MIME íƒ€ì…"""

    created_at: datetime
    """ìƒì„± ì‹œê°"""

    url: str
    """ì ‘ê·¼ URL"""

    session_id: str | None = None
    """ì„¸ì…˜ ID (ì„ íƒ)"""


@dataclass
class PutResult:
    """ì €ì¥ ê²°ê³¼."""

    success: bool
    key: str
    url: str
    metadata: StorageMetadata | None = None
    error: str | None = None


class StorageInterface(ABC):
    """ìŠ¤í† ë¦¬ì§€ ì¸í„°í˜ì´ìŠ¤ (ì¶”ìƒ í´ë˜ìŠ¤).

    MVP: LocalStorage êµ¬í˜„
    MMP: GCSStorage êµ¬í˜„ ì˜ˆì •
    """

    @abstractmethod
    async def put(
        self,
        data: bytes,
        *,
        category: StorageCategory,
        content_type: str = "image/png",
        file_id: str | None = None,
        session_id: str | None = None,
    ) -> PutResult:
        """íŒŒì¼ì„ ì €ì¥í•©ë‹ˆë‹¤.

        Args:
            data: íŒŒì¼ ë°”ì´íŠ¸ ë°ì´í„°
            category: ì €ì¥ ì¹´í…Œê³ ë¦¬
            content_type: MIME íƒ€ì…
            file_id: íŒŒì¼ ID (ì—†ìœ¼ë©´ ìë™ ìƒì„±)
            session_id: ì„¸ì…˜ ID (ê²½ë¡œ ë¶„ë¥˜ìš©)

        Returns:
            PutResult: ì €ì¥ ê²°ê³¼
        """
        ...

    @abstractmethod
    async def get(self, key: str) -> bytes | None:
        """íŒŒì¼ì„ ì¡°íšŒí•©ë‹ˆë‹¤.

        Args:
            key: ìŠ¤í† ë¦¬ì§€ í‚¤

        Returns:
            íŒŒì¼ ë°”ì´íŠ¸ ë°ì´í„° (ì—†ìœ¼ë©´ None)
        """
        ...

    @abstractmethod
    async def exists(self, key: str) -> bool:
        """íŒŒì¼ ì¡´ì¬ ì—¬ë¶€ë¥¼ í™•ì¸í•©ë‹ˆë‹¤.

        Args:
            key: ìŠ¤í† ë¦¬ì§€ í‚¤

        Returns:
            ì¡´ì¬ ì—¬ë¶€
        """
        ...

    @abstractmethod
    async def delete(self, key: str) -> bool:
        """íŒŒì¼ì„ ì‚­ì œí•©ë‹ˆë‹¤.

        Args:
            key: ìŠ¤í† ë¦¬ì§€ í‚¤

        Returns:
            ì‚­ì œ ì„±ê³µ ì—¬ë¶€
        """
        ...

    @abstractmethod
    def get_url(self, key: str) -> str:
        """íŒŒì¼ ì ‘ê·¼ URLì„ ë°˜í™˜í•©ë‹ˆë‹¤.

        Args:
            key: ìŠ¤í† ë¦¬ì§€ í‚¤

        Returns:
            ì ‘ê·¼ URL
        """
        ...
</file>

<file path="backend/test_real_vision.json">
{
  "language": "ko-KR",
  "text": "",
  "action_id": "deep_analyze",
  "client": {
    "viewport_w": 1920,
    "viewport_h": 1080,
    "theme": "dark"
  },
  "economy_snapshot": {
    "signal": 100,
    "memory_shard": 5
  },
  "previous_image_url": "/static/images/test_scene.png"
}
</file>

<file path="backend/tests/conftest.py">
import os

import pytest


@pytest.fixture(autouse=True)
def setup_test_env():
    """ëª¨ë“  í…ŒìŠ¤íŠ¸ì—ì„œ UW_MODE=mockì„ ê¸°ë³¸ìœ¼ë¡œ ì‚¬ìš©í•˜ë„ë¡ ì„¤ì •í•©ë‹ˆë‹¤."""
    # ì´ë¯¸ ì„¤ì •ëœ ê²½ìš°(ì˜ˆ: CI)ëŠ” ìœ ì§€í•˜ê³ , ë¡œì»¬ì—ì„œ ìˆ˜ë™ ì‹¤í–‰ ì‹œ ê¸°ë³¸ê°’ ë³´ì¥
    if "UW_MODE" not in os.environ:
        os.environ["UW_MODE"] = "mock"

    # ì´ë¯¸ì§€ ìƒì„± í…ŒìŠ¤íŠ¸ë¥¼ ìœ„í•´ ì¶œë ¥ ë””ë ‰í† ë¦¬ ë³´ì¥
    from pathlib import Path

    output_dir = Path("test_output")
    output_dir.mkdir(parents=True, exist_ok=True)

    yield
</file>

<file path="backend/tests/fixtures/image_request_fast.json">
{
  "prompt": "A beautiful fantasy landscape with mountains and a glowing sunset",
  "aspect_ratio": "16:9",
  "model_label": "FAST"
}
</file>

<file path="backend/tests/fixtures/image_request_quality.json">
{
  "prompt": "A detailed cyberpunk city at night with neon lights",
  "aspect_ratio": "16:9",
  "model_label": "QUALITY"
}
</file>

<file path="backend/tests/fixtures/turn_request.json">
{
  "language": "ko-KR",
  "text": "ìƒˆë¡œìš´ ì„¸ê³„ë¥¼ íƒí—˜í•œë‹¤",
  "client": {
    "viewport_w": 1920,
    "viewport_h": 1080,
    "theme": "dark"
  },
  "economy_snapshot": {
    "signal": 100,
    "memory_shard": 5
  }
}
</file>

<file path="backend/tests/integration/test_item_icon_api.py">
from unittest.mock import AsyncMock, MagicMock, patch

import pytest
from httpx import ASGITransport, AsyncClient

from unknown_world.services.item_icon_generator import (
    reset_item_icon_generator,
)


@pytest.fixture(autouse=True)
def reset_generator():
    reset_item_icon_generator()
    yield
    reset_item_icon_generator()


@pytest.mark.asyncio
async def test_api_generate_icon_async():
    from unknown_world.main import app

    # ItemIconGenerator.generate_iconì„ ëª¨í‚¹í•˜ì—¬ ì‹¤ì œ ì´ë¯¸ì§€ ìƒì„± ë°©ì§€
    with patch("unknown_world.api.item_icon.get_item_icon_generator") as mock_get_generator:
        mock_generator = MagicMock()
        mock_get_generator.return_value = mock_generator

        from unknown_world.services.item_icon_generator import (
            IconGenerationResponse,
            IconGenerationStatus,
        )

        mock_generator.generate_icon = AsyncMock(
            return_value=IconGenerationResponse(
                status=IconGenerationStatus.PENDING,
                icon_url="/ui/icons/placeholder_item.png",
                item_id="item_123",
                is_placeholder=True,
                message="Generating...",
            )
        )

        transport = ASGITransport(app=app)
        async with AsyncClient(transport=transport, base_url="http://test") as ac:
            response = await ac.post(
                "/api/item/icon",
                json={
                    "item_id": "item_123",
                    "description": "A mysterious potion",
                    "language": "ko-KR",
                    "wait": False,
                },
            )

        assert response.status_code == 200
        data = response.json()
        assert data["status"] == "pending"
        assert data["item_id"] == "item_123"
        assert data["is_placeholder"] is True
        assert "/ui/icons/placeholder_item.png" in data["icon_url"]


@pytest.mark.asyncio
async def test_api_get_icon_status():
    from unknown_world.main import app

    with patch("unknown_world.api.item_icon.get_item_icon_generator") as mock_get_generator:
        mock_generator = MagicMock()
        mock_get_generator.return_value = mock_generator

        from unknown_world.services.item_icon_generator import IconGenerationStatus

        mock_generator.get_icon_status = AsyncMock(return_value=IconGenerationStatus.COMPLETED)

        transport = ASGITransport(app=app)
        async with AsyncClient(transport=transport, base_url="http://test") as ac:
            response = await ac.get("/api/item/icon/item_123/status")

        assert response.status_code == 200
        data = response.json()
        assert data["status"] == "completed"
        assert data["item_id"] == "item_123"
</file>

<file path="backend/tests/integration/test_resolve_vision.py">
"""Unknown World - Resolve Stage ì •ë°€ë¶„ì„ í†µí•© í…ŒìŠ¤íŠ¸ (U-076[Mvp])."""

from unittest.mock import AsyncMock, patch

import pytest

from unknown_world.models.turn import (
    AgentPhase,
    ClientInfo,
    CurrencyAmount,
    EconomySnapshot,
    ImageJob,
    Language,
    RenderOutput,
    TurnInput,
    TurnOutput,
    UIOutput,
    WorldDelta,
)
from unknown_world.orchestrator.stages.resolve import resolve_stage
from unknown_world.orchestrator.stages.types import PipelineContext
from unknown_world.services.agentic_vision import Affordance, Box2D, VisionAnalysisResult


@pytest.fixture
def mock_emit():
    return AsyncMock()


@pytest.fixture
def base_context():
    """ê¸°ë³¸ í…ŒìŠ¤íŠ¸ ì»¨í…ìŠ¤íŠ¸."""
    economy_snap = EconomySnapshot(signal=100, memory_shard=0)
    turn_input = TurnInput(
        language=Language.KO,
        text="ë°©ì„ ë‘˜ëŸ¬ë³¸ë‹¤",
        action_id="explore",
        client=ClientInfo(viewport_w=1920, viewport_h=1080),
        economy_snapshot=economy_snap,
    )
    # ì´ë¯¸ì§€ê°€ ìˆëŠ” ë Œë” ìƒíƒœ
    render = RenderOutput(
        image_url="/static/test_image.png",
        image_job=ImageJob(prompt="A test scene", should_generate=True),
    )
    # TurnOutput ìƒì„±
    output = TurnOutput(
        language=Language.KO,
        narrative="ê¸°ë³¸ ë‚´ëŸ¬í‹°ë¸Œ",
        ui=UIOutput(objects=[]),
        render=render,
        world=WorldDelta(),
        economy={
            "cost": {"signal": 0, "memory_shard": 0},
            "balance_after": {"signal": 100, "memory_shard": 0},
        },
        safety={"blocked": False},
    )
    return PipelineContext(
        turn_input=turn_input,
        economy_snapshot=CurrencyAmount(
            signal=economy_snap.signal, memory_shard=economy_snap.memory_shard
        ),
        output=output,
        current_phase=AgentPhase.VALIDATE,
    )


@pytest.mark.asyncio
async def test_resolve_vision_trigger_success(base_context, mock_emit):
    """ì •ë°€ë¶„ì„ íŠ¸ë¦¬ê±° ì‹œ ë¹„ì „ ì„œë¹„ìŠ¤ í˜¸ì¶œ ë° ê²°ê³¼ ë°˜ì˜ í…ŒìŠ¤íŠ¸."""
    # íŠ¸ë¦¬ê±° ì•¡ì…˜ìœ¼ë¡œ ë³€ê²½
    base_context.turn_input.action_id = "deep_analyze"

    # Vision ì„œë¹„ìŠ¤ Mock
    mock_result = VisionAnalysisResult(
        affordances=[
            Affordance(label="ìˆ¨ê²¨ì§„ ìƒì", box_2d=Box2D(ymin=100, xmin=100, ymax=200, xmax=200))
        ],
        success=True,
    )

    with patch(
        "unknown_world.services.agentic_vision.AgenticVisionService.analyze_scene",
        new_callable=AsyncMock,
    ) as mock_analyze:
        mock_analyze.return_value = mock_result

        updated_ctx = await resolve_stage(base_context, emit=mock_emit)

        # 1. ë¹„ì „ ì„œë¹„ìŠ¤ í˜¸ì¶œ í™•ì¸
        mock_analyze.assert_called_once_with("/static/test_image.png", Language.KO)

        # 2. í•«ìŠ¤íŒŸ ì¶”ê°€ í™•ì¸
        assert len(updated_ctx.output.ui.objects) == 1
        assert updated_ctx.output.ui.objects[0].label == "ìˆ¨ê²¨ì§„ ìƒì"

        # 3. ë‚´ëŸ¬í‹°ë¸Œ ë³´ê°• í™•ì¸
        assert "ì¥ë©´ì„ ìì„¸íˆ ì‚´í´ë´…ë‹ˆë‹¤" in updated_ctx.output.narrative
        assert "ìˆ¨ê²¨ì§„ ìƒì" in updated_ctx.output.narrative

        # 4. ì´ë¯¸ì§€ ìƒì„± ë¹„í™œì„±í™” í™•ì¸
        assert updated_ctx.output.render.image_job.should_generate is False

        # 5. ë¹„ìš© ë°°ìˆ˜ í™•ì¸ (1.5x)
        assert updated_ctx.cost_multiplier == 1.5


@pytest.mark.asyncio
async def test_resolve_vision_no_image(base_context, mock_emit):
    """ì´ë¯¸ì§€ê°€ ì—†ì„ ë•Œ ì •ë°€ë¶„ì„ íŠ¸ë¦¬ê±° ì‹œ ê±´ë„ˆë›°ê¸° í…ŒìŠ¤íŠ¸."""
    base_context.turn_input.action_id = "deep_analyze"
    base_context.output.render.image_url = None  # ì´ë¯¸ì§€ ì—†ìŒ

    with patch(
        "unknown_world.services.agentic_vision.AgenticVisionService.analyze_scene",
        new_callable=AsyncMock,
    ) as mock_analyze:
        updated_ctx = await resolve_stage(base_context, emit=mock_emit)

        # ë¹„ì „ ì„œë¹„ìŠ¤ê°€ í˜¸ì¶œë˜ì§€ ì•Šì•„ì•¼ í•¨
        mock_analyze.assert_not_called()
        # í•«ìŠ¤íŒŸì´ ì¶”ê°€ë˜ì§€ ì•Šì•„ì•¼ í•¨
        assert len(updated_ctx.output.ui.objects) == 0


@pytest.mark.asyncio
async def test_resolve_vision_failure_fallback(base_context, mock_emit):
    """ë¹„ì „ ë¶„ì„ ì‹¤íŒ¨ ì‹œ ì•ˆì „í•œ í´ë°± í™•ì¸ (RULE-004)."""
    base_context.turn_input.action_id = "deep_analyze"

    # ì‹¤íŒ¨ ê²°ê³¼ Mock
    mock_result = VisionAnalysisResult(affordances=[], success=False, message="API Error")

    with patch(
        "unknown_world.services.agentic_vision.AgenticVisionService.analyze_scene",
        new_callable=AsyncMock,
    ) as mock_analyze:
        mock_analyze.return_value = mock_result

        updated_ctx = await resolve_stage(base_context, emit=mock_emit)

        # í•«ìŠ¤íŒŸì€ ì¶”ê°€ë˜ì§€ ì•ŠìŒ
        assert len(updated_ctx.output.ui.objects) == 0
        # í´ë°± ë‚´ëŸ¬í‹°ë¸Œ í™•ì¸
        assert "ìì„¸íˆ ë´ë„ íŠ¹ë³„í•œ ê²ƒì€ ë³´ì´ì§€ ì•ŠìŠµë‹ˆë‹¤" in updated_ctx.output.narrative
        # ì´ë¯¸ì§€ ìƒì„±ì€ ì—¬ì „íˆ ë¹„í™œì„±í™” (ì •ë°€ë¶„ì„ ì‹œë„ ìì²´ë¡œ ì¸í•´)
        assert updated_ctx.output.render.image_job.should_generate is False
</file>

<file path="backend/tests/manual_test_image.py">
"""Unknown World - ì´ë¯¸ì§€ ìƒì„± API ìˆ˜ë™ ê²€ì¦ ìŠ¤í¬ë¦½íŠ¸."""

import json
import os

from fastapi.testclient import TestClient

from unknown_world.main import app


def run_manual_test():
    # UW_MODEë¥¼ mockìœ¼ë¡œ ê°•ì œ ì„¤ì •í•˜ì—¬ API í˜¸ì¶œ ì—†ì´ ë¡œì§ ê²€ì¦
    os.environ["UW_MODE"] = "mock"
    client = TestClient(app)

    print("=== [1] ì´ë¯¸ì§€ ìƒì„± ìš”ì²­ í…ŒìŠ¤íŠ¸ ===")
    payload = {
        "prompt": "A retro-future computer terminal with green text",
        "aspect_ratio": "1:1",
        "image_size": "1024x1024",
    }

    response = client.post("/api/image/generate", json=payload)
    print(f"Status Code: {response.status_code}")
    print(f"Response: {json.dumps(response.json(), indent=2, ensure_ascii=False)}")

    if response.status_code == 200:
        data = response.json()
        image_url = data["image_url"]
        image_id = data["image_id"]

        print(f"\n=== [2] ì •ì  íŒŒì¼ ì„œë¹™ í…ŒìŠ¤íŠ¸ ({image_url}) ===")
        static_resp = client.get(image_url)
        print(f"Static Content-Type: {static_resp.headers.get('content-type')}")
        print(f"Static Success: {static_resp.status_code == 200}")

        print(f"\n=== [3] ì´ë¯¸ì§€ ìƒíƒœ ì¡°íšŒ í…ŒìŠ¤íŠ¸ ({image_id}) ===")
        status_resp = client.get(f"/api/image/status/{image_id}")
        print(f"Status Response: {json.dumps(status_resp.json(), indent=2, ensure_ascii=False)}")

        print(f"\n=== [4] ì´ë¯¸ì§€ íŒŒì¼ ì§ì ‘ ì¡°íšŒ í…ŒìŠ¤íŠ¸ (/api/image/file/{image_id}) ===")
        file_resp = client.get(f"/api/image/file/{image_id}")
        print(f"File Content-Type: {file_resp.headers.get('content-type')}")
        print(f"File Success: {file_resp.status_code == 200}")


if __name__ == "__main__":
    run_manual_test()
</file>

<file path="backend/tests/qa/test_asset_manifest.py">
import json
import os

import pytest
from jsonschema import validate

# Paths
# This file is in backend/tests/qa/
# We go up 3 levels to get to backend root: backend/tests/qa -> backend/tests -> backend -> root (wait, backend is in root)
# Actually:
# __file__ = D:\Dev\unknown-world\backend\tests\qa\test_asset_manifest.py
# os.path.dirname(__file__) = D:\Dev\unknown-world\backend\tests\qa
# ... up 1 = tests
# ... up 2 = backend
# ... up 3 = unknown-world (project root)

CURRENT_DIR = os.path.dirname(os.path.abspath(__file__))
PROJECT_ROOT = os.path.dirname(os.path.dirname(os.path.dirname(CURRENT_DIR)))

# If PROJECT_ROOT is correct, it should contain frontend/
FRONTEND_UI_DIR = os.path.join(PROJECT_ROOT, "frontend", "public", "ui")
MANIFEST_PATH = os.path.join(FRONTEND_UI_DIR, "manifest.json")
SCHEMA_PATH = os.path.join(FRONTEND_UI_DIR, "manifest.schema.json")


def test_manifest_schema_validation():
    """Validates manifest.json against manifest.schema.json"""
    if not os.path.exists(MANIFEST_PATH):
        pytest.fail(f"Manifest not found at {MANIFEST_PATH}")
    if not os.path.exists(SCHEMA_PATH):
        pytest.fail(f"Schema not found at {SCHEMA_PATH}")

    with open(MANIFEST_PATH, encoding="utf-8") as f:
        manifest = json.load(f)

    with open(SCHEMA_PATH, encoding="utf-8") as f:
        schema = json.load(f)

    # validate raises ValidationError on failure
    validate(instance=manifest, schema=schema)


def test_asset_files_existence_and_size():
    """Checks if assets listed in manifest exist and sizes match/budget"""
    with open(MANIFEST_PATH, encoding="utf-8") as f:
        manifest = json.load(f)

    assets = manifest.get("assets", [])
    total_bytes_calculated = 0

    for asset in assets:
        rel_path = asset["path"]
        abs_path = os.path.join(FRONTEND_UI_DIR, rel_path)

        # 1. Existence Check
        assert os.path.exists(abs_path), f"Asset file missing: {rel_path} (full: {abs_path})"

        # 2. Size Check
        actual_size = os.path.getsize(abs_path)
        recorded_size = asset.get("bytes")

        # Note: If size mismatches, we print a helpful message.
        # In a real QA scenario, we might want to auto-update, but for this test we fail.
        if recorded_size is not None:
            assert actual_size == recorded_size, (
                f"Size mismatch for {rel_path}: actual {actual_size} != manifest {recorded_size}"
            )

        total_bytes_calculated += actual_size

        # 3. Individual Budget Check (from QA_CHECKLIST.md)
        asset_type = asset["type"]
        if asset_type in ("icon", "item-icon"):
            # 30KB limit
            assert actual_size <= 30 * 1024, (
                f"Icon {rel_path} exceeds 30KB budget ({actual_size} bytes)"
            )
        elif asset_type == "placeholder":
            # 300KB limit
            assert actual_size <= 300 * 1024, (
                f"Placeholder {rel_path} exceeds 300KB budget ({actual_size} bytes)"
            )
        elif asset_type == "chrome":
            # 120KB limit (increased for scanner-frame)
            assert actual_size <= 120 * 1024, (
                f"Chrome asset {rel_path} exceeds 120KB budget ({actual_size} bytes)"
            )

    # 4. Total Budget Check
    recorded_total = manifest.get("totalBytes")
    if recorded_total is not None:
        assert total_bytes_calculated == recorded_total, (
            f"Total bytes mismatch: calculated {total_bytes_calculated} != manifest {recorded_total}"
        )

    budget_total = manifest.get("budgetBytes", 1572864)
    assert total_bytes_calculated <= budget_total, (
        f"Total size {total_bytes_calculated} exceeds budget {budget_total}"
    )


def test_asset_naming_convention():
    """Checks if asset IDs and paths use kebab-case"""
    with open(MANIFEST_PATH, encoding="utf-8") as f:
        manifest = json.load(f)

    for asset in manifest["assets"]:
        asset_id = asset["id"]
        # Check for lowercase and kebab-case (allow numbers)
        assert asset_id.islower(), f"Asset ID {asset_id} should be lowercase"
        assert " " not in asset_id, f"Asset ID {asset_id} should not contain spaces"
        assert "_" not in asset_id, (
            f"Asset ID {asset_id} should not contain underscores (use kebab-case)"
        )
</file>

<file path="backend/tests/qa/test_u052_manual_verification.py">
"""U-052[Mvp]: ì¡°ê±´ë¶€ ì´ë¯¸ì§€ ìƒì„± ì œì–´ ë¡œì§ ìˆ˜ë™ ê²€ì¦ ìŠ¤í¬ë¦½íŠ¸.

ì´ ìŠ¤í¬ë¦½íŠ¸ëŠ” ëŸ°ë¶ì˜ ì‹œë‚˜ë¦¬ì˜¤ A, B, C, Dë¥¼ ì‹¤í–‰í•˜ê³  ë¡œê·¸ ì¶œë ¥ì„ í™•ì¸í•©ë‹ˆë‹¤.
íŠ¹íˆ RULE-007(í”„ë¡¬í”„íŠ¸ í•´ì‹œ)ê³¼ RULE-005(ì”ì•¡ ë¶€ì¡± í´ë°±)ë¥¼ ì¤‘ì ì ìœ¼ë¡œ í™•ì¸í•©ë‹ˆë‹¤.
"""

import logging
import sys

from unknown_world.models.turn import (
    CurrencyAmount,
    EconomyOutput,
    EconomySnapshot,
    ImageJob,
    Language,
    RenderOutput,
    SafetyOutput,
    TurnOutput,
)
from unknown_world.orchestrator.stages.render_helpers import decide_image_generation

# ë¡œê·¸ ì„¤ì • (í‘œì¤€ ì¶œë ¥ìœ¼ë¡œ ë¡œê·¸ ì¶œë ¥)
logging.basicConfig(level=logging.DEBUG, format="%(levelname)s - %(message)s", stream=sys.stdout)
logger = logging.getLogger("U-052-Verification")


def print_separator(title):
    print("\n" + "=" * 60)
    print(f"  SCENARIO: {title}")
    print("=" * 60)


def run_verification():
    # -------------------------------------------------------------------------
    # ì‹œë‚˜ë¦¬ì˜¤ A: ì´ë¯¸ì§€ ìƒì„± ìŠ¹ì¸ (should_generate=true, ì”ì•¡ ì¶©ë¶„)
    # -------------------------------------------------------------------------
    print_separator("A: Image Generation Approved")
    turn_output_a = TurnOutput(
        language=Language.KO,
        narrative="ì–´ë‘ìš´ ìˆ²ê¸¸ì— ë“¤ì–´ì„°ë‹¤.",
        economy=EconomyOutput(
            cost=CurrencyAmount(signal=5, memory_shard=0),
            balance_after=CurrencyAmount(signal=95, memory_shard=5),
        ),
        safety=SafetyOutput(blocked=False),
        render=RenderOutput(
            image_job=ImageJob(
                should_generate=True,
                prompt="A dark forest path with moonlight filtering through the trees",
                aspect_ratio="16:9",
            )
        ),
    )
    economy_a = EconomySnapshot(signal=100, memory_shard=5)

    logger.info("Starting Scenario A...")
    decision_a = decide_image_generation(turn_output_a, economy_a, "ko-KR")

    print(f"\nResult: should_generate={decision_a.should_generate}")
    print(f"Reason: {decision_a.reason}")
    print(f"Prompt Hash: {decision_a.prompt_hash}")

    # -------------------------------------------------------------------------
    # ì‹œë‚˜ë¦¬ì˜¤ B: ì´ë¯¸ì§€ ìƒì„± ë¯¸ìš”ì²­ (should_generate=false)
    # -------------------------------------------------------------------------
    print_separator("B: Image Generation Not Requested")
    turn_output_b = TurnOutput(
        language=Language.KO,
        narrative="ë°© ì•ˆì„ ë‘˜ëŸ¬ë³´ì•˜ë‹¤.",
        economy=EconomyOutput(
            cost=CurrencyAmount(signal=3, memory_shard=0),
            balance_after=CurrencyAmount(signal=97, memory_shard=5),
        ),
        safety=SafetyOutput(blocked=False),
        render=RenderOutput(image_job=ImageJob(should_generate=False, prompt="")),
    )
    economy_b = EconomySnapshot(signal=100, memory_shard=5)

    logger.info("Starting Scenario B...")
    decision_b = decide_image_generation(turn_output_b, economy_b, "ko-KR")

    print(f"\nResult: should_generate={decision_b.should_generate}")
    print(f"Reason: {decision_b.reason}")

    # -------------------------------------------------------------------------
    # ì‹œë‚˜ë¦¬ì˜¤ C: ì”ì•¡ ë¶€ì¡± (RULE-005)
    # -------------------------------------------------------------------------
    print_separator("C: Insufficient Balance (RULE-005)")
    turn_output_c = TurnOutput(
        language=Language.KO,
        narrative="ë³´ë¬¼ ìƒìë¥¼ ë°œê²¬í–ˆë‹¤!",
        economy=EconomyOutput(
            cost=CurrencyAmount(signal=3, memory_shard=0),
            balance_after=CurrencyAmount(signal=5, memory_shard=0),
        ),
        safety=SafetyOutput(blocked=False),
        render=RenderOutput(
            image_job=ImageJob(should_generate=True, prompt="A golden treasure chest")
        ),
    )
    economy_c = EconomySnapshot(signal=5, memory_shard=0)

    logger.info(f"Starting Scenario C (Balance: {economy_c.signal} Signal)...")
    decision_c = decide_image_generation(turn_output_c, economy_c, "ko-KR")

    print(f"\nResult: should_generate={decision_c.should_generate}")
    print(f"Reason: {decision_c.reason}")
    print(f"Fallback Message: {decision_c.fallback_message}")

    # -------------------------------------------------------------------------
    # ì‹œë‚˜ë¦¬ì˜¤ D: ë¹ˆ í”„ë¡¬í”„íŠ¸ ë°©ì–´
    # -------------------------------------------------------------------------
    print_separator("D: Empty Prompt Defense")
    turn_output_d = TurnOutput(
        language=Language.EN,
        narrative="You entered the dungeon.",
        economy=EconomyOutput(
            cost=CurrencyAmount(signal=5, memory_shard=0),
            balance_after=CurrencyAmount(signal=95, memory_shard=5),
        ),
        safety=SafetyOutput(blocked=False),
        render=RenderOutput(image_job=ImageJob(should_generate=True, prompt="   ")),
    )
    economy_d = EconomySnapshot(signal=100, memory_shard=5)

    logger.info("Starting Scenario D...")
    decision_d = decide_image_generation(turn_output_d, economy_d, "en-US")

    print(f"\nResult: should_generate={decision_d.should_generate}")
    print(f"Reason: {decision_d.reason}")


if __name__ == "__main__":
    run_verification()
</file>

<file path="backend/tests/unit/api/test_image.py">
"""Unknown World - ì´ë¯¸ì§€ ìƒì„± API ì—”ë“œí¬ì¸íŠ¸ ë‹¨ìœ„ í…ŒìŠ¤íŠ¸."""

import pytest
from fastapi.testclient import TestClient

from unknown_world.main import app
from unknown_world.services.image_generation import (
    ImageGenerationStatus,
    get_image_generator,
    reset_image_generator,
)


@pytest.fixture
def client():
    """FastAPI TestClient í”½ìŠ¤ì²˜."""
    return TestClient(app)


@pytest.fixture(autouse=True)
def setup_mock_generator():
    """ëª¨ë“  í…ŒìŠ¤íŠ¸ì—ì„œ Mock ìƒì„±ê¸°ë¥¼ ì‚¬ìš©í•˜ë„ë¡ ì„¤ì •."""
    reset_image_generator()
    get_image_generator(force_mock=True)
    yield
    reset_image_generator()


def test_generate_image_success(client):
    """ì´ë¯¸ì§€ ìƒì„± ì„±ê³µ ì¼€ì´ìŠ¤ í…ŒìŠ¤íŠ¸."""
    payload = {
        "prompt": "A futuristic laboratory with glowing screens",
        "aspect_ratio": "1:1",
        "image_size": "1024x1024",
        "skip_on_failure": True,
    }

    response = client.post("/api/image/generate", json=payload)

    assert response.status_code == 200
    data = response.json()
    assert data["success"] is True
    assert data["status"] == ImageGenerationStatus.COMPLETED
    assert data["image_id"] is not None
    assert data["image_url"] is not None


def test_generate_image_validation_error(client):
    """ì´ë¯¸ì§€ ìƒì„± ìš”ì²­ ê²€ì¦ ì‹¤íŒ¨ í…ŒìŠ¤íŠ¸."""
    # ë„ˆë¬´ ì§§ì€ í”„ë¡¬í”„íŠ¸
    payload = {"prompt": "A", "skip_on_failure": False}

    response = client.post("/api/image/generate", json=payload)

    assert response.status_code == 400
    assert "í”„ë¡¬í”„íŠ¸ê°€ ë„ˆë¬´ ì§§ìŠµë‹ˆë‹¤" in response.json()["detail"]


def test_generate_image_fallback_on_error(client):
    """ê²€ì¦ ì‹¤íŒ¨ ì‹œ skip_on_failure=Trueì¼ ë•Œ í´ë°± ë™ì‘ í…ŒìŠ¤íŠ¸."""
    payload = {"prompt": "A", "skip_on_failure": True}

    response = client.post("/api/image/generate", json=payload)

    assert response.status_code == 200
    data = response.json()
    assert data["success"] is False
    assert data["status"] == "skipped"
    assert "í”„ë¡¬í”„íŠ¸ê°€ ë„ˆë¬´ ì§§ìŠµë‹ˆë‹¤" in data["message"]


def test_get_image_status(client):
    """ì´ë¯¸ì§€ ìƒíƒœ ì¡°íšŒ í…ŒìŠ¤íŠ¸."""
    # ë¨¼ì € ìƒì„±
    gen_resp = client.post("/api/image/generate", json={"prompt": "Test status"})
    image_id = gen_resp.json()["image_id"]

    # ìƒíƒœ ì¡°íšŒ
    status_resp = client.get(f"/api/image/status/{image_id}")
    assert status_resp.status_code == 200
    assert status_resp.json()["exists"] is True
    assert status_resp.json()["image_url"] is not None


def test_static_image_access(client):
    """ì •ì  íŒŒì¼ ê²½ë¡œë¥¼ í†µí•œ ì´ë¯¸ì§€ ì ‘ê·¼ í…ŒìŠ¤íŠ¸."""
    # ì´ë¯¸ì§€ ìƒì„±
    gen_resp = client.post("/api/image/generate", json={"prompt": "Test static access"})
    image_url = gen_resp.json()["image_url"]

    # ì •ì  ê²½ë¡œë¡œ ì ‘ê·¼
    response = client.get(image_url)
    assert response.status_code == 200
    assert response.headers["content-type"] == "image/png"


def test_get_image_file_not_found(client):
    """ì¡´ì¬í•˜ì§€ ì•ŠëŠ” ì´ë¯¸ì§€ íŒŒì¼ ìš”ì²­ ì‹œ 404 í…ŒìŠ¤íŠ¸."""
    response = client.get("/api/image/file/non_existent_id")
    assert response.status_code == 404
</file>

<file path="backend/tests/unit/models/test_turn.py">
"""TurnInput/TurnOutput ëª¨ë¸ ë‹¨ìœ„ í…ŒìŠ¤íŠ¸."""

import pytest
from pydantic import ValidationError

from unknown_world.models.turn import (
    AgentConsole,
    Box2D,
    CurrencyAmount,
    EconomyOutput,
    Language,
    RenderOutput,
    TurnInput,
    TurnOutput,
    UIOutput,
    WorldDelta,
)

# =============================================================================
# Fixtures
# =============================================================================


@pytest.fixture
def valid_box_2d():
    return {"ymin": 100, "xmin": 200, "ymax": 300, "xmax": 400}


@pytest.fixture
def valid_currency_amount():
    return {"signal": 100, "memory_shard": 5}


@pytest.fixture
def valid_client_info():
    return {"viewport_w": 1920, "viewport_h": 1080, "theme": "dark"}


@pytest.fixture
def valid_turn_input_data(valid_client_info, valid_currency_amount):
    return {
        "language": "ko-KR",
        "text": "Hello",
        "client": valid_client_info,
        "economy_snapshot": valid_currency_amount,
    }


@pytest.fixture
def valid_turn_output_data(valid_currency_amount):
    return {
        "language": "ko-KR",
        "narrative": "Story continues...",
        "economy": {
            "cost": {"signal": 10, "memory_shard": 0},
            "balance_after": {"signal": 90, "memory_shard": 5},
        },
        "safety": {"blocked": False},
    }


# =============================================================================
# Coordinate & Box2D Tests
# =============================================================================


def test_box_2d_valid(valid_box_2d):
    box = Box2D(**valid_box_2d)
    assert box.ymin == 100
    assert box.xmax == 400


def test_box_2d_invalid_coordinate():
    with pytest.raises(ValidationError):
        # Out of range (ge=0, le=1000)
        Box2D(ymin=-1, xmin=0, ymax=1001, xmax=500)


def test_box_2d_extra_forbidden():
    with pytest.raises(ValidationError):
        Box2D(ymin=0, xmin=0, ymax=100, xmax=100, extra_field="not allowed")


# =============================================================================
# Currency & Economy Tests
# =============================================================================


def test_currency_amount_valid(valid_currency_amount):
    amount = CurrencyAmount(**valid_currency_amount)
    assert amount.signal == 100


def test_currency_amount_negative_fails():
    with pytest.raises(ValidationError):
        CurrencyAmount(signal=-1, memory_shard=0)


def test_economy_output_valid():
    data = {
        "cost": {"signal": 5, "memory_shard": 0},
        "balance_after": {"signal": 95, "memory_shard": 5},
    }
    economy = EconomyOutput(**data)
    assert economy.cost.signal == 5
    assert economy.balance_after.signal == 95


# =============================================================================
# TurnInput Tests
# =============================================================================


def test_turn_input_valid(valid_turn_input_data):
    turn_input = TurnInput(**valid_turn_input_data)
    assert turn_input.language == Language.KO
    assert turn_input.text == "Hello"


def test_turn_input_with_click(valid_turn_input_data, valid_box_2d):
    data = valid_turn_input_data.copy()
    data["click"] = {"object_id": "door_01", "box_2d": valid_box_2d}
    turn_input = TurnInput(**data)
    assert turn_input.click.object_id == "door_01"
    assert turn_input.click.box_2d.ymin == 100


def test_turn_input_invalid_language():
    with pytest.raises(ValidationError):
        TurnInput(
            language="fr-FR",  # Not in Language enum
            text="...",
            client={"viewport_w": 800, "viewport_h": 600},
            economy_snapshot={"signal": 0, "memory_shard": 0},
        )


# =============================================================================
# TurnOutput Tests
# =============================================================================


def test_turn_output_valid_minimal(valid_turn_output_data):
    turn_output = TurnOutput(**valid_turn_output_data)
    assert turn_output.language == Language.KO
    assert turn_output.narrative == "Story continues..."
    # Check defaults
    assert isinstance(turn_output.ui, UIOutput)
    assert isinstance(turn_output.world, WorldDelta)
    assert isinstance(turn_output.render, RenderOutput)
    assert isinstance(turn_output.agent_console, AgentConsole)


def test_turn_output_full(valid_currency_amount, valid_box_2d):
    data = {
        "language": "en-US",
        "narrative": "Narrative text",
        "ui": {
            "action_deck": {
                "cards": [
                    {
                        "id": "c1",
                        "label": "Action 1",
                        "cost": {"signal": 5, "memory_shard": 0},
                    }
                ]
            },
            "objects": [{"id": "obj1", "label": "Object 1", "box_2d": valid_box_2d}],
        },
        "world": {
            "inventory_added": [
                {
                    "id": "key",
                    "label": "ì—´ì‡ ",
                    "description": "ë‚¡ì€ ì² ì œ ì—´ì‡ ì…ë‹ˆë‹¤.",
                    "quantity": 1,
                }
            ],
            "rules_changed": [{"id": "r1", "label": "Gravity", "description": "Low gravity"}],
            "quests_updated": [{"id": "q1", "label": "Find key", "is_completed": False}],
            "memory_pins": [
                {"id": "p1", "content": "Fact", "cost": {"signal": 1, "memory_shard": 0}}
            ],
        },
        "render": {
            "image_job": {
                "should_generate": True,
                "prompt": "A landscape",
                "model_label": "QUALITY",
            }
        },
        "economy": {
            "cost": {"signal": 10, "memory_shard": 0},
            "balance_after": {"signal": 90, "memory_shard": 5},
        },
        "safety": {"blocked": False},
        "agent_console": {"repair_count": 1, "badges": ["schema_ok", "economy_ok"]},
    }
    turn_output = TurnOutput(**data)
    assert turn_output.language == Language.EN
    assert len(turn_output.ui.action_deck.cards) == 1
    assert turn_output.render.image_job.should_generate is True


def test_turn_output_missing_required():
    with pytest.raises(ValidationError):
        # Missing economy and safety
        TurnOutput(language="ko-KR", narrative="...")


# =============================================================================
# JSON Schema Tests
# =============================================================================


def test_turn_output_json_schema():
    schema = TurnOutput.model_json_schema()
    assert schema["type"] == "object"
    assert "language" in schema["required"]
    assert "narrative" in schema["required"]
    assert "economy" in schema["required"]
    assert "safety" in schema["required"]

    # Check Coordinate constraints in schema
    # Pydantic 2 schema structure: properties -> language -> ...
    # Coordinate might be in $defs or inline depending on how it's used
    ui_props = schema["$defs"]["UIOutput"]["properties"]
    assert "action_deck" in ui_props

    # Verify that Coordinate (int with ge/le) is correctly represented
    # Box2D uses Coordinate
    box_props = schema["$defs"]["Box2D"]["properties"]
    assert box_props["ymin"]["maximum"] == 1000
    assert box_props["ymin"]["minimum"] == 0
</file>

<file path="backend/tests/unit/models/test_u078_objectives.py">
"""U-078 ëª©í‘œ ì‹œìŠ¤í…œ ê°•í™” - Quest ëª¨ë¸ ë° ë¹„ì¦ˆë‹ˆìŠ¤ ë¡œì§ ë‹¨ìœ„ í…ŒìŠ¤íŠ¸."""

import pytest
from pydantic import ValidationError

from unknown_world.models.turn import Quest, TurnOutput, WorldDelta


def test_quest_model_u078_fields():
    """Quest ëª¨ë¸ì˜ U-078 ì‹ ê·œ í•„ë“œ ê²€ì¦."""
    data = {
        "id": "main_01",
        "label": "ì£¼ ëª©í‘œ",
        "description": "ìƒì„¸ ì„¤ëª…",
        "is_main": True,
        "progress": 50,
        "reward_signal": 100,
    }
    quest = Quest(**data)
    assert quest.id == "main_01"
    assert quest.is_main is True
    assert quest.progress == 50
    assert quest.reward_signal == 100
    assert quest.is_completed is False


def test_quest_progress_range():
    """ì§„í–‰ë¥ (progress) ë²”ìœ„ ê²€ì¦ (0~100)."""
    # 0 OK
    Quest(id="q", label="l", progress=0)
    # 100 OK
    Quest(id="q", label="l", progress=100)

    # -1 Fail
    with pytest.raises(ValidationError):
        Quest(id="q", label="l", progress=-1)

    # 101 Fail
    with pytest.raises(ValidationError):
        Quest(id="q", label="l", progress=101)


def test_quest_reward_signal_non_negative():
    """ë³´ìƒ(reward_signal) 0 ì´ìƒ ê²€ì¦."""
    Quest(id="q", label="l", reward_signal=0)
    Quest(id="q", label="l", reward_signal=100)

    with pytest.raises(ValidationError):
        Quest(id="q", label="l", reward_signal=-1)


def test_world_delta_quests_updated_limit():
    """WorldDeltaì˜ quests_updated ìµœëŒ€ í¬ê¸° ì œí•œ ê²€ì¦ (max_length=3)."""
    quests = [Quest(id=f"q{i}", label=f"l{i}") for i in range(3)]
    # 3ê°œ OK
    WorldDelta(quests_updated=quests)

    # 4ê°œ Fail
    with pytest.raises(ValidationError):
        WorldDelta(quests_updated=quests + [Quest(id="q4", label="l4")])


def test_turn_output_with_u078_objectives():
    """TurnOutputì— í¬í•¨ëœ U-078 ëª©í‘œ ë°ì´í„° ê²€ì¦."""
    data = {
        "language": "ko-KR",
        "narrative": "ëª©í‘œê°€ ì—…ë°ì´íŠ¸ë˜ì—ˆìŠµë‹ˆë‹¤.",
        "economy": {
            "cost": {"signal": 0, "memory_shard": 0},
            "balance_after": {"signal": 100, "memory_shard": 5},
        },
        "safety": {"blocked": False},
        "world": {
            "quests_updated": [
                {
                    "id": "main",
                    "label": "ì£¼ ëª©í‘œ",
                    "is_main": True,
                    "progress": 25,
                    "reward_signal": 50,
                },
                {"id": "sub", "label": "ì„œë¸Œ ëª©í‘œ", "is_completed": True, "reward_signal": 10},
            ]
        },
    }
    output = TurnOutput(**data)
    quests = output.world.quests_updated
    assert len(quests) == 2
    assert quests[0].is_main is True
    assert quests[1].is_completed is True
    assert quests[1].reward_signal == 10
</file>

<file path="backend/tests/unit/orchestrator/test_generate_turn_output.py">
"""Unknown World - TurnOutputGenerator ë‹¨ìœ„ í…ŒìŠ¤íŠ¸.

U-017[Mvp] ì™„ë£Œ ê¸°ì¤€ ê²€ì¦:
    - Structured Outputs í˜¸ì¶œ êµ¬ì„± (application/json, response_schema)
    - Pydantic ê²€ì¦ (model_validate_json)
    - ì‹¤íŒ¨ ë¶„ê¸° ì²˜ë¦¬ (SCHEMA_FAILURE)
    - language ì •ì±… ì¤€ìˆ˜
"""

import json
from unittest.mock import AsyncMock, patch

import pytest

from unknown_world.models.turn import (
    ClientInfo,
    CurrencyAmount,
    EconomySnapshot,
    Language,
    Theme,
    TurnInput,
    TurnOutput,
)
from unknown_world.orchestrator.generate_turn_output import (
    GenerationStatus,
    TurnOutputGenerator,
)
from unknown_world.services.genai_client import GenerateResponse


@pytest.fixture
def turn_input() -> TurnInput:
    """ê¸°ë³¸ í„´ ì…ë ¥ í”½ìŠ¤ì²˜."""
    return TurnInput(
        language=Language.KO,
        text="ë¬¸ì„ ì—´ì–´ë³¸ë‹¤",
        client=ClientInfo(viewport_w=1920, viewport_h=1080, theme=Theme.DARK),
        economy_snapshot=EconomySnapshot(signal=100, memory_shard=5),
    )


@pytest.fixture
def valid_turn_output_json() -> str:
    """ìœ íš¨í•œ TurnOutput JSON ë¬¸ìì—´ í”½ìŠ¤ì²˜."""
    return json.dumps(
        {
            "language": "ko-KR",
            "narrative": "ë‚¡ì€ ë¬¸ì´ ì—´ë¦¬ê³  ë¨¼ì§€ê°€ ë‚ ë¦½ë‹ˆë‹¤.",
            "economy": {
                "cost": {"signal": 5, "memory_shard": 0},
                "balance_after": {"signal": 95, "memory_shard": 5},
            },
            "safety": {"blocked": False, "message": None},
            "ui": {"action_deck": {"cards": []}, "objects": []},
            "world": {
                "rules_changed": [],
                "inventory_added": [],
                "inventory_removed": [],
                "quests_updated": [],
                "memory_pins": [],
            },
            "render": {"image_job": None},
            "agent_console": {
                "current_phase": "commit",
                "badges": ["schema_ok", "economy_ok", "safety_ok"],
                "repair_count": 0,
            },
        }
    )


@pytest.mark.asyncio
async def test_generate_success(turn_input, valid_turn_output_json):
    """ì„±ê³µì ì¸ ìƒì„± ë° Pydantic ê²€ì¦ í…ŒìŠ¤íŠ¸."""
    generator = TurnOutputGenerator(force_mock=True)

    # Mock GenAIClient.generate
    mock_response = GenerateResponse(text=valid_turn_output_json, model_label="fast")

    with patch(
        "unknown_world.orchestrator.generate_turn_output.get_genai_client"
    ) as mock_get_client:
        mock_client = AsyncMock()
        mock_client.generate.return_value = mock_response
        mock_get_client.return_value = mock_client

        result = await generator.generate(turn_input)

        assert result.status == GenerationStatus.SUCCESS
        assert isinstance(result.output, TurnOutput)
        assert result.output.narrative == "ë‚¡ì€ ë¬¸ì´ ì—´ë¦¬ê³  ë¨¼ì§€ê°€ ë‚ ë¦½ë‹ˆë‹¤."
        assert result.output.language == Language.KO

        # API í˜¸ì¶œ ì¸ì ê²€ì¦ (Structured Outputs ì„¤ì • í™•ì¸)
        call_args = mock_client.generate.call_args[0][0]
        assert call_args.response_mime_type == "application/json"
        assert call_args.response_schema is not None
        assert "narrative" in call_args.response_schema["properties"]


@pytest.mark.asyncio
async def test_generate_schema_validation_failure(turn_input):
    """Pydantic ê²€ì¦ ì‹¤íŒ¨(SCHEMA_FAILURE) í…ŒìŠ¤íŠ¸."""
    generator = TurnOutputGenerator(force_mock=True)

    # í•„ìˆ˜ í•„ë“œ(narrative)ê°€ ëˆ„ë½ëœ ì˜ëª»ëœ JSON
    invalid_json = json.dumps(
        {
            "language": "ko-KR",
            # "narrative" í•„ë“œ ëˆ„ë½
            "economy": {
                "cost": {"signal": 5, "memory_shard": 0},
                "balance_after": {"signal": 95, "memory_shard": 5},
            },
            "safety": {"blocked": False, "message": None},
        }
    )

    mock_response = GenerateResponse(text=invalid_json, model_label="fast")

    with patch(
        "unknown_world.orchestrator.generate_turn_output.get_genai_client"
    ) as mock_get_client:
        mock_client = AsyncMock()
        mock_client.generate.return_value = mock_response
        mock_get_client.return_value = mock_client

        result = await generator.generate(turn_input)

        assert result.status == GenerationStatus.SCHEMA_FAILURE
        assert result.output is None
        assert "validation_errors" in result.error_details


@pytest.mark.asyncio
async def test_generate_json_decode_error(turn_input):
    """JSON íŒŒì‹± ì‹¤íŒ¨ í…ŒìŠ¤íŠ¸."""
    generator = TurnOutputGenerator(force_mock=True)

    # ìœ íš¨í•˜ì§€ ì•Šì€ JSON í˜•ì‹
    invalid_text = "ì´ê²ƒì€ JSONì´ ì•„ë‹™ë‹ˆë‹¤ { narrative: ... "

    mock_response = GenerateResponse(text=invalid_text, model_label="fast")

    with patch(
        "unknown_world.orchestrator.generate_turn_output.get_genai_client"
    ) as mock_get_client:
        mock_client = AsyncMock()
        mock_client.generate.return_value = mock_response
        mock_get_client.return_value = mock_client

        result = await generator.generate(turn_input)

        assert result.status == GenerationStatus.SCHEMA_FAILURE
        # Pydantic model_validate_jsonì€ JSON íŒŒì‹± ì‹¤íŒ¨ë„ ValidationError(type=json_invalid)ë¡œ ë³´ê³ í•¨
        errors = result.error_details.get("validation_errors", [])
        assert any(err["type"] == "json_invalid" for err in errors)


@pytest.mark.asyncio
async def test_generate_markdown_json_extraction(turn_input, valid_turn_output_json):
    """ë§ˆí¬ë‹¤ìš´ ì½”ë“œ ë¸”ë¡ ë‚´ì˜ JSON ì¶”ì¶œ í…ŒìŠ¤íŠ¸."""
    generator = TurnOutputGenerator(force_mock=True)

    # ë§ˆí¬ë‹¤ìš´ ì½”ë“œ ë¸”ë¡ìœ¼ë¡œ ê°ì‹¸ì§„ ì‘ë‹µ
    markdown_text = f"```json\n{valid_turn_output_json}\n```"

    mock_response = GenerateResponse(text=markdown_text, model_label="fast")

    with patch(
        "unknown_world.orchestrator.generate_turn_output.get_genai_client"
    ) as mock_get_client:
        mock_client = AsyncMock()
        mock_client.generate.return_value = mock_response
        mock_get_client.return_value = mock_client

        result = await generator.generate(turn_input)

        assert result.status == GenerationStatus.SUCCESS
        assert result.output.narrative == "ë‚¡ì€ ë¬¸ì´ ì—´ë¦¬ê³  ë¨¼ì§€ê°€ ë‚ ë¦½ë‹ˆë‹¤."


@pytest.mark.asyncio
async def test_generate_api_error(turn_input):
    """API í˜¸ì¶œ ì—ëŸ¬ ì²˜ë¦¬ í…ŒìŠ¤íŠ¸."""
    generator = TurnOutputGenerator(force_mock=True)

    with patch(
        "unknown_world.orchestrator.generate_turn_output.get_genai_client"
    ) as mock_get_client:
        mock_client = AsyncMock()
        mock_client.generate.side_effect = RuntimeError("API connection failed")
        mock_get_client.return_value = mock_client

        result = await generator.generate(turn_input)

        assert result.status == GenerationStatus.API_ERROR
        assert "API connection failed" in result.error_details["api_error"]


def test_create_safe_fallback():
    """ì•ˆì „í•œ í´ë°± ìƒì„± í…ŒìŠ¤íŠ¸ (RULE-004)."""
    generator = TurnOutputGenerator()

    economy_snapshot = CurrencyAmount(signal=80, memory_shard=3)
    fallback = generator.create_safe_fallback(
        language=Language.KO, error_message="Test Error", economy_snapshot=economy_snapshot
    )

    assert isinstance(fallback, TurnOutput)
    assert fallback.language == Language.KO
    assert fallback.economy.cost.signal == 0
    assert fallback.economy.balance_after.signal == 80
    assert "í˜¼ë€ìŠ¤ëŸ¬ìš´" in fallback.narrative
</file>

<file path="backend/tests/unit/orchestrator/test_pipeline.py">
"""Unknown World - Pipeline ë‹¨ìœ„/í†µí•© í…ŒìŠ¤íŠ¸.

RU-005[Mvp] ë¦¬íŒ©í† ë§ ê²€ì¦:
    - Stage ê¸°ë°˜ ëª¨ë“ˆí™” ë™ì‘ ë³´ì¡´
    - PipelineContext ìƒíƒœ ì „ì´ í™•ì¸
    - ì´ë²¤íŠ¸ emit ìˆœì„œ ë° ì •í•©ì„± (RULE-008)
    - U-018 ë¹„ì¦ˆë‹ˆìŠ¤ ë£° ê²€ì¦ ë° Repair ë£¨í”„ í†µí•© í™•ì¸
"""

from unittest.mock import AsyncMock, patch

import pytest

from unknown_world.models.turn import (
    AgentPhase,
    ClientInfo,
    EconomySnapshot,
    Language,
    Theme,
    TurnInput,
    TurnOutput,
    ValidationBadge,
)
from unknown_world.orchestrator.pipeline import (
    create_pipeline_context,
    run_pipeline,
)
from unknown_world.orchestrator.stages.types import (
    PipelineEvent,
    PipelineEventType,
)


@pytest.fixture
def turn_input() -> TurnInput:
    """ê¸°ë³¸ í„´ ì…ë ¥ í”½ìŠ¤ì²˜."""
    return TurnInput(
        language=Language.KO,
        text="ë¬¸ì„ ì—´ì–´ë³¸ë‹¤",
        client=ClientInfo(viewport_w=1920, viewport_h=1080, theme=Theme.DARK),
        economy_snapshot=EconomySnapshot(signal=100, memory_shard=5),
    )


def test_create_pipeline_context(turn_input):
    """ì»¨í…ìŠ¤íŠ¸ ì´ˆê¸°í™” ê²€ì¦."""
    ctx = create_pipeline_context(turn_input, seed=42, is_mock=True)

    assert ctx.turn_input == turn_input
    assert ctx.economy_snapshot.signal == 100
    assert ctx.economy_snapshot.memory_shard == 5
    assert ctx.is_mock is True
    assert ctx.seed == 42
    assert ctx.output is None
    assert ctx.badges == []


@pytest.mark.asyncio
async def test_run_pipeline_happy_path_mock(turn_input):
    """Mock ëª¨ë“œì—ì„œ ì •ìƒì ì¸ íŒŒì´í”„ë¼ì¸ ì‹¤í–‰ í™•ì¸ (Happy Path)."""
    ctx = create_pipeline_context(turn_input, seed=42, is_mock=True)
    events = []

    async def emit(event: PipelineEvent):
        events.append(event)

    ctx = await run_pipeline(ctx, emit=emit)

    # 1. ìµœì¢… ê²°ê³¼ í™•ì¸
    assert ctx.output is not None
    assert isinstance(ctx.output, TurnOutput)
    assert ctx.is_fallback is False
    assert ctx.repair_attempts == 0

    # 2. ì´ë²¤íŠ¸ ìˆœì„œ í™•ì¸ (ì¼ë¶€ í•µì‹¬ ë‹¨ê³„ë§Œ)
    event_types = [e.event_type for e in events]
    phases = [e.phase for e in events if e.phase is not None]

    assert PipelineEventType.STAGE_START in event_types
    assert PipelineEventType.STAGE_COMPLETE in event_types
    assert PipelineEventType.BADGES in event_types

    # PRD ìˆœì„œ: Parse -> Validate -> ... -> Commit
    assert AgentPhase.PARSE in phases
    assert AgentPhase.VALIDATE in phases
    assert AgentPhase.COMMIT in phases

    # 3. ë°°ì§€ í™•ì¸
    badges_events = [e for e in events if e.event_type == PipelineEventType.BADGES]
    assert len(badges_events) > 0
    assert ValidationBadge.SCHEMA_OK in badges_events[0].badges


@pytest.mark.asyncio
async def test_run_pipeline_validation_failure_repair_mock(turn_input):
    """ë¹„ì¦ˆë‹ˆìŠ¤ ë£° ìœ„ë°˜ ì‹œ Repair ë£¨í”„ ë°œìƒ í™•ì¸ (Mock)."""
    ctx = create_pipeline_context(turn_input, seed=42, is_mock=True)
    events = []

    async def emit(event: PipelineEvent):
        events.append(event)

    # validate_business_rulesë¥¼ ëª¨í‚¹í•˜ì—¬ ì²« ë²ˆì§¸ ì‹œë„ì—ì„œ ì‹¤íŒ¨í•˜ê²Œ í•¨
    with patch(
        "unknown_world.orchestrator.stages.validate.validate_business_rules"
    ) as mock_validate:
        from unknown_world.validation.business_rules import BusinessRuleValidationResult

        mock_validate.side_effect = [
            BusinessRuleValidationResult(
                is_valid=False, errors=[{"type": "economy_insufficient", "message": "error"}]
            ),
            BusinessRuleValidationResult(is_valid=True, errors=[]),
        ]

        ctx = await run_pipeline(ctx, emit=emit)

    # Repair ì´ë²¤íŠ¸ê°€ ë°œìƒí–ˆëŠ”ì§€ í™•ì¸
    repair_events = [e for e in events if e.event_type == PipelineEventType.REPAIR]
    assert len(repair_events) == 1
    assert repair_events[0].repair_attempt == 1
    assert ctx.repair_attempts == 1
    assert ctx.is_fallback is False


@pytest.mark.asyncio
async def test_run_pipeline_exception_fallback(turn_input):
    """ìŠ¤í…Œì´ì§€ ì‹¤í–‰ ì¤‘ ì˜ˆì™¸ ë°œìƒ ì‹œ í´ë°± í™•ì¸."""
    ctx = create_pipeline_context(turn_input, is_mock=True)

    async def emit(event: PipelineEvent):
        pass

    # ì˜ˆì™¸ë¥¼ ë˜ì§€ëŠ” ê°€ì§œ ìŠ¤í…Œì´ì§€
    async def failing_stage(c, *, emit):
        raise RuntimeError("Unexpected error")

    # ê°€ì§œ ìŠ¤í…Œì´ì§€ë¥¼ ì§ì ‘ ì „ë‹¬í•˜ì—¬ ì‹¤í–‰
    ctx = await run_pipeline(ctx, emit=emit, stages=[failing_stage])

    assert ctx.is_fallback is True
    assert ctx.output is not None
    assert "í˜¼ë€ìŠ¤ëŸ¬ìš´ ìˆœê°„" in ctx.output.narrative
    # í´ë°± ì‹œ ë¹„ìš© 0 í™•ì¸ (RULE-005)
    assert ctx.output.economy.cost.signal == 0
    assert ctx.output.economy.balance_after.signal == 100


@pytest.mark.asyncio
async def test_validate_stage_real_delegation(turn_input):
    """validate_stageê°€ Real ëª¨ë“œì—ì„œ run_repair_loopë¥¼ í˜¸ì¶œí•˜ëŠ”ì§€ í™•ì¸."""
    from unknown_world.models.turn import AgentConsole, TurnOutput
    from unknown_world.orchestrator.repair_loop import RepairLoopResult
    from unknown_world.orchestrator.stages.validate import validate_stage

    ctx = create_pipeline_context(turn_input, is_mock=False)
    events = []

    async def emit(event: PipelineEvent):
        events.append(event)

    # ì‹¤ì œ ê°ì²´ ìƒì„± í›„ í•„ìš”í•œ í•„ë“œë§Œ ëª¨í‚¹
    mock_output = AsyncMock(spec=TurnOutput)
    # dataclass í•„ë“œë“¤ì— ëŒ€í•œ attribute ì—ëŸ¬ ë°©ì§€ë¥¼ ìœ„í•´ ìˆ˜ë™ ì„¤ì •
    mock_output.agent_console = AgentConsole(
        badges=[ValidationBadge.SCHEMA_OK], current_phase=AgentPhase.VALIDATE
    )

    with patch("unknown_world.orchestrator.stages.validate.run_repair_loop") as mock_run:
        mock_run.return_value = RepairLoopResult(
            output=mock_output,
            repair_attempts=1,
            is_fallback=False,
            badges=[ValidationBadge.SCHEMA_OK],
            error_messages=["repair test"],
        )

        ctx = await validate_stage(ctx, emit=emit)

    assert mock_run.called
    assert ctx.repair_attempts == 1
    assert PipelineEventType.REPAIR in [e.event_type for e in events]
    assert ctx.output == mock_output


@pytest.mark.asyncio
async def test_validate_stage_mock_max_retries_fallback(turn_input):
    """Mock ëª¨ë“œì—ì„œ ìµœëŒ€ ì¬ì‹œë„ íšŸìˆ˜ ì´ˆê³¼ ì‹œ í´ë°± í™•ì¸."""
    from unknown_world.orchestrator.repair_loop import MAX_REPAIR_ATTEMPTS
    from unknown_world.orchestrator.stages.validate import validate_stage

    ctx = create_pipeline_context(turn_input, seed=42, is_mock=True)
    events = []

    async def emit(event: PipelineEvent):
        events.append(event)

    # í•­ìƒ ì‹¤íŒ¨í•˜ëŠ” ë¹„ì¦ˆë‹ˆìŠ¤ ë£° ê²€ì¦ ê²°ê³¼ ë°˜í™˜
    with patch(
        "unknown_world.orchestrator.stages.validate.validate_business_rules"
    ) as mock_validate:
        from unknown_world.validation.business_rules import BusinessRuleValidationResult

        mock_validate.return_value = BusinessRuleValidationResult(
            is_valid=False, errors=[{"type": "economy_insufficient", "message": "error"}]
        )

        ctx = await validate_stage(ctx, emit=emit)

    assert ctx.is_fallback is True
    assert ctx.repair_attempts == MAX_REPAIR_ATTEMPTS + 1  # 0íšŒì°¨ + 1íšŒì°¨ + 2íšŒì°¨ ì‹œë„ í›„ ì‹¤íŒ¨
    assert ValidationBadge.ECONOMY_FAIL in ctx.badges
    assert ctx.output.economy.cost.signal == 0


@pytest.mark.asyncio
async def test_validate_stage_mock_unexpected_exception(turn_input):
    """Mock ê²€ì¦ ë£¨í”„ ë‚´ì—ì„œ ì˜ˆì™¸ ë°œìƒ ì‹œ í´ë°± í™•ì¸."""
    from unknown_world.orchestrator.stages.validate import validate_stage

    ctx = create_pipeline_context(turn_input, seed=42, is_mock=True)
    events = []

    async def emit(event: PipelineEvent):
        events.append(event)

    # generate_turn_output í˜¸ì¶œ ì‹œ ì˜ˆì™¸ ë°œìƒ
    with patch(
        "unknown_world.orchestrator.mock.MockOrchestrator.generate_turn_output",
        side_effect=RuntimeError("Mock error"),
    ):
        ctx = await validate_stage(ctx, emit=emit)

    assert ctx.is_fallback is True
    # _validate_mock ë‚´ë¶€ try-except ë£¨í”„ê°€ MAX_REPAIR_ATTEMPTSë§Œí¼ ëŒê³  ê²°êµ­ í´ë°±
    assert ctx.repair_attempts > 0
</file>

<file path="backend/tests/unit/orchestrator/test_u051_bridge.py">
"""U-051[Mvp] ë Œë”ë§ ë‹¨ê³„-ì´ë¯¸ì§€ ìƒì„± ì„œë¹„ìŠ¤ ë¸Œë¦¿ì§€ êµ¬ì¶• í…ŒìŠ¤íŠ¸.

ê²€ì¦ í•­ëª©:
    - PipelineContextì— image_generator í•„ë“œ ì¡´ì¬ ë° ì£¼ì… ê°€ëŠ¥ ì—¬ë¶€
    - create_pipeline_context í˜¸ì¶œ ì‹œ ì´ë¯¸ì§€ ìƒì„±ê¸° ìë™ íšë“ (Option A)
    - render_stageì—ì„œ ì£¼ì…ëœ ì´ë¯¸ì§€ ìƒì„±ê¸° ì ‘ê·¼ ê°€ëŠ¥ ì—¬ë¶€
    - RULE-008: ë‹¨ê³„ ì´ë²¤íŠ¸ ì¼ê´€ì„± ìœ ì§€
"""

from unittest.mock import MagicMock

import pytest

from unknown_world.models.turn import AgentPhase, ClientInfo, EconomySnapshot, Language, TurnInput
from unknown_world.orchestrator.pipeline import create_pipeline_context
from unknown_world.orchestrator.stages.render import render_stage
from unknown_world.orchestrator.stages.types import PipelineEvent, PipelineEventType
from unknown_world.services.image_generation import MockImageGenerator


@pytest.fixture
def turn_input() -> TurnInput:
    return TurnInput(
        language=Language.KO,
        text="í…ŒìŠ¤íŠ¸ ì…ë ¥",
        economy_snapshot=EconomySnapshot(signal=100, memory_shard=10),
        client=ClientInfo(viewport_w=1920, viewport_h=1080),
    )


def test_pipeline_context_image_generator_injection(turn_input):
    """PipelineContextì— ì´ë¯¸ì§€ ìƒì„±ê¸°ê°€ ëª…ì‹œì ìœ¼ë¡œ ì£¼ì…ë˜ëŠ”ì§€ í™•ì¸."""
    mock_gen = MagicMock(spec=MockImageGenerator)
    ctx = create_pipeline_context(turn_input, image_generator=mock_gen)

    assert ctx.image_generator == mock_gen


def test_create_pipeline_context_default_generator(turn_input):
    """image_generatorë¥¼ ì „ë‹¬í•˜ì§€ ì•Šì•˜ì„ ë•Œ get_image_generator()ë¥¼ í†µí•´ ìë™ íšë“í•˜ëŠ”ì§€ í™•ì¸.

    í˜„ì¬ êµ¬í˜„ì€ Noneì„ ë°˜í™˜í•˜ë¯€ë¡œ ì´ í…ŒìŠ¤íŠ¸ëŠ” ì‹¤íŒ¨í•´ì•¼ í•¨ (Red ë‹¨ê³„).
    """
    # get_image_generatorë¥¼ ëª¨í‚¹í•˜ì—¬ í˜¸ì¶œ ì—¬ë¶€ í™•ì¸
    with pytest.MonkeyPatch.context() as mp:
        mock_get_gen = MagicMock()
        mp.setattr("unknown_world.orchestrator.pipeline.get_image_generator", mock_get_gen)

        ctx = create_pipeline_context(turn_input)

        # í˜„ì¬ êµ¬í˜„ì—ì„œëŠ” mock_get_gen.called ê°€ Falseì´ê³  ctx.image_generatorê°€ Noneì¼ ê²ƒì„
        assert mock_get_gen.called, "get_image_generator()ê°€ í˜¸ì¶œë˜ì–´ì•¼ í•¨"
        assert ctx.image_generator == mock_get_gen.return_value


@pytest.mark.asyncio
async def test_render_stage_uses_injected_generator(turn_input):
    """render_stageê°€ ì£¼ì…ëœ ì´ë¯¸ì§€ ìƒì„±ê¸°ë¥¼ ì˜¬ë°”ë¥´ê²Œ ì¸ì‹í•˜ëŠ”ì§€ í™•ì¸."""
    mock_gen = MagicMock(spec=MockImageGenerator)
    mock_gen.is_available.return_value = True

    ctx = create_pipeline_context(turn_input, image_generator=mock_gen)

    events = []

    async def emit(event: PipelineEvent):
        events.append(event)

    ctx = await render_stage(ctx, emit=emit)

    # 1. ìƒíƒœ ì „ì´ ë° ì´ë²¤íŠ¸ í™•ì¸
    assert ctx.current_phase == AgentPhase.RENDER
    assert len(events) == 2
    assert events[0].event_type == PipelineEventType.STAGE_START
    assert events[1].event_type == PipelineEventType.STAGE_COMPLETE

    # 2. ì´ë¯¸ì§€ ìƒì„±ê¸° í˜¸ì¶œ í™•ì¸ (is_available í˜¸ì¶œ ì—¬ë¶€ë¡œ ê°„ì ‘ í™•ì¸)
    assert mock_gen.is_available.called
</file>

<file path="backend/tests/unit/orchestrator/test_u052_render_integration.py">
"""U-052[Mvp]: ì¡°ê±´ë¶€ ì´ë¯¸ì§€ ìƒì„± ì œì–´ ë¡œì§ í†µí•© í…ŒìŠ¤íŠ¸.

render_stageì—ì„œ decide_image_generationì´ ì˜¬ë°”ë¥´ê²Œ í˜¸ì¶œë˜ê³ 
íŒì • ë¡œì§ì´ íŒŒì´í”„ë¼ì¸ íë¦„ì— í†µí•©ë˜ì—ˆëŠ”ì§€ ê²€ì¦í•©ë‹ˆë‹¤.
"""

from unittest.mock import AsyncMock, MagicMock

import pytest

from unknown_world.models.turn import (
    ClientInfo,
    CurrencyAmount,
    EconomyOutput,
    EconomySnapshot,
    ImageJob,
    Language,
    RenderOutput,
    SafetyOutput,
    TurnInput,
    TurnOutput,
)
from unknown_world.orchestrator.stages.render import render_stage
from unknown_world.orchestrator.stages.types import PipelineContext, PipelineEventType


@pytest.fixture
def mock_emit():
    """ì´ë²¤íŠ¸ emitì„ ìœ„í•œ ëª¨ì˜ í•¨ìˆ˜."""
    return AsyncMock()


@pytest.fixture
def mock_generator():
    """ì´ë¯¸ì§€ ìƒì„±ê¸° ëª¨ì˜ ê°ì²´."""
    generator = MagicMock()
    generator.is_available.return_value = True
    return generator


@pytest.mark.asyncio
async def test_render_stage_integration_with_image_job(mock_emit, mock_generator):
    """ImageJobì´ ìˆì„ ë•Œ render_stageê°€ íŒì • ë¡œì§ì„ ìˆ˜í–‰í•˜ëŠ”ì§€ í™•ì¸."""
    # 1. ì¤€ë¹„
    turn_input = TurnInput(
        language=Language.KO,
        text="ìˆ²ìœ¼ë¡œ ê°„ë‹¤",
        economy_snapshot=EconomySnapshot(signal=100, memory_shard=5),
        client=ClientInfo(viewport_w=1920, viewport_h=1080),
    )

    turn_output = TurnOutput(
        language=Language.KO,
        narrative="ì–´ë‘ìš´ ìˆ²ì´ë‹¤.",
        economy=EconomyOutput(
            cost=CurrencyAmount(signal=5, memory_shard=0),
            balance_after=CurrencyAmount(signal=95, memory_shard=5),
        ),
        safety=SafetyOutput(blocked=False),
        render=RenderOutput(
            image_job=ImageJob(should_generate=True, prompt="A dark forest", aspect_ratio="16:9")
        ),
    )

    ctx = PipelineContext(
        turn_input=turn_input,
        economy_snapshot=CurrencyAmount(signal=100, memory_shard=5),
        output=turn_output,
        image_generator=mock_generator,
    )

    # 2. ì‹¤í–‰
    result_ctx = await render_stage(ctx, emit=mock_emit)

    # 3. ê²€ì¦
    # Stage ì´ë²¤íŠ¸ê°€ ë°œìƒí–ˆëŠ”ì§€ í™•ì¸
    assert mock_emit.call_count >= 2
    event_types = [call.args[0].event_type for call in mock_emit.call_args_list]
    assert PipelineEventType.STAGE_START in event_types
    assert PipelineEventType.STAGE_COMPLETE in event_types

    # ì»¨í…ìŠ¤íŠ¸ê°€ ìœ ì§€ë˜ì—ˆëŠ”ì§€ í™•ì¸
    assert result_ctx.output == turn_output
    assert result_ctx.image_generator == mock_generator


@pytest.mark.asyncio
async def test_render_stage_integration_insufficient_balance(mock_emit, mock_generator):
    """ì”ì•¡ ë¶€ì¡± ì‹œ render_stageê°€ ì •ìƒì ìœ¼ë¡œ íë¦„ì„ ìœ ì§€í•˜ëŠ”ì§€ í™•ì¸."""
    # 1. ì¤€ë¹„ (ì”ì•¡ 5, í•„ìš” 10)
    turn_input = TurnInput(
        language=Language.KO,
        text="ìˆ²ìœ¼ë¡œ ê°„ë‹¤",
        economy_snapshot=EconomySnapshot(signal=5, memory_shard=0),
        client=ClientInfo(viewport_w=1920, viewport_h=1080),
    )

    turn_output = TurnOutput(
        language=Language.KO,
        narrative="ì–´ë‘ìš´ ìˆ²ì´ë‹¤.",
        economy=EconomyOutput(
            cost=CurrencyAmount(signal=0, memory_shard=0),
            balance_after=CurrencyAmount(signal=5, memory_shard=0),
        ),
        safety=SafetyOutput(blocked=False),
        render=RenderOutput(image_job=ImageJob(should_generate=True, prompt="A forest")),
    )

    ctx = PipelineContext(
        turn_input=turn_input,
        economy_snapshot=CurrencyAmount(signal=5, memory_shard=0),
        output=turn_output,
        image_generator=mock_generator,
    )

    # 2. ì‹¤í–‰
    result_ctx = await render_stage(ctx, emit=mock_emit)

    # 3. ê²€ì¦
    assert mock_emit.call_count >= 2
    # í˜„ì¬ ë‹¨ê³„(U-052)ì—ì„œëŠ” pass-throughì´ë¯€ë¡œ outputì´ ë³€í•˜ì§€ ì•Šì•„ì•¼ í•¨
    # (í´ë°± ë©”ì‹œì§€ ë°˜ì˜ì€ U-054 ì˜ˆì •)
    assert result_ctx.output.render.image_job.should_generate is True


@pytest.mark.asyncio
async def test_render_stage_no_generator(mock_emit):
    """ì´ë¯¸ì§€ ìƒì„±ê¸°ê°€ ì—†ì„ ë•Œ pass-through ë™ì‘ í™•ì¸."""
    # 1. ì¤€ë¹„
    turn_input = TurnInput(
        language=Language.KO,
        text="í…ŒìŠ¤íŠ¸",
        economy_snapshot=EconomySnapshot(signal=100, memory_shard=5),
        client=ClientInfo(viewport_w=1920, viewport_h=1080),
    )

    ctx = PipelineContext(
        turn_input=turn_input,
        economy_snapshot=CurrencyAmount(signal=100, memory_shard=5),
        output=None,
        image_generator=None,
    )

    # 2. ì‹¤í–‰
    result_ctx = await render_stage(ctx, emit=mock_emit)

    # 3. ê²€ì¦
    assert result_ctx.image_generator is None
    event_types = [call.args[0].event_type for call in mock_emit.call_args_list]
    assert PipelineEventType.STAGE_COMPLETE in event_types
</file>

<file path="backend/tests/unit/orchestrator/test_u054_image_fallback.py">
"""U-054: ì´ë¯¸ì§€ ìƒì„± í´ë°± ë° ì‹¤íŒ¨ ë³µêµ¬ ì²´ê³„ ê°•í™” í…ŒìŠ¤íŠ¸.

ê²€ì¦ í•­ëª©:
- ì‹œë‚˜ë¦¬ì˜¤ 1: ì´ë¯¸ì§€ ìƒì„± ì„±ê³µ (Happy Path)
- ì‹œë‚˜ë¦¬ì˜¤ 2: ì•ˆì „ ì •ì±… ì°¨ë‹¨ (Safety Blocked) -> safety.blocked=True, ë°°ì§€ ë°˜ì˜
- ì‹œë‚˜ë¦¬ì˜¤ 3: ì¼ë°˜ ìƒì„± ì‹¤íŒ¨ -> image_url=None
- ì‹œë‚˜ë¦¬ì˜¤ 4: íƒ€ì„ì•„ì›ƒ ë°œìƒ -> ì•ˆì „í•œ í´ë°±
- ì‹œë‚˜ë¦¬ì˜¤ 5: ì”ì•¡ ë¶€ì¡± -> í…ìŠ¤íŠ¸-only í´ë°± ë©”ì‹œì§€ ë°˜ì˜ (U-054 í•µì‹¬)
"""

from unittest.mock import AsyncMock, MagicMock

import pytest

from unknown_world.models.turn import (
    AgentConsole,
    ClientInfo,
    CurrencyAmount,
    EconomyOutput,
    EconomySnapshot,
    ImageJob,
    Language,
    RenderOutput,
    SafetyOutput,
    Theme,
    TurnInput,
    TurnOutput,
    ValidationBadge,
)
from unknown_world.orchestrator.stages.render import render_stage
from unknown_world.orchestrator.stages.types import PipelineContext
from unknown_world.services.image_generation import (
    ImageGenerationResponse,
    ImageGenerationStatus,
)


@pytest.fixture
def base_turn_output():
    """ê¸°ë³¸ TurnOutput í”½ìŠ¤ì²˜."""
    return TurnOutput(
        language=Language.KO,
        narrative="í…ŒìŠ¤íŠ¸ ë‚´ëŸ¬í‹°ë¸Œì…ë‹ˆë‹¤.",
        economy=EconomyOutput(
            cost=CurrencyAmount(signal=0, memory_shard=0),
            balance_after=CurrencyAmount(signal=100, memory_shard=0),
        ),
        safety=SafetyOutput(blocked=False),
        render=RenderOutput(
            image_job=ImageJob(
                should_generate=True,
                prompt="í…ŒìŠ¤íŠ¸ ì´ë¯¸ì§€ í”„ë¡¬í”„íŠ¸",
            )
        ),
        agent_console=AgentConsole(badges=[ValidationBadge.SCHEMA_OK, ValidationBadge.SAFETY_OK]),
    )


@pytest.fixture
def base_turn_input():
    """ê¸°ë³¸ TurnInput í”½ìŠ¤ì²˜."""
    return TurnInput(
        language=Language.KO,
        text="í…ŒìŠ¤íŠ¸ ì…ë ¥",
        client=ClientInfo(viewport_w=1920, viewport_h=1080, theme=Theme.DARK),
        economy_snapshot=EconomySnapshot(signal=100, memory_shard=0),
    )


@pytest.fixture
def mock_emit():
    """ì´ë²¤íŠ¸ ë°œí–‰ í•¨ìˆ˜ ëª¨í¬."""
    return AsyncMock()


@pytest.fixture
def mock_image_generator():
    """ì´ë¯¸ì§€ ìƒì„±ê¸° ì„œë¹„ìŠ¤ ëª¨í¬."""
    generator = MagicMock()
    generator.is_available.return_value = True
    generator.generate = AsyncMock()
    return generator


@pytest.mark.asyncio
async def test_image_fallback_success(
    base_turn_output, base_turn_input, mock_emit, mock_image_generator
):
    """ì‹œë‚˜ë¦¬ì˜¤ 1: ì´ë¯¸ì§€ ìƒì„± ì„±ê³µ."""
    # Given
    mock_image_generator.generate.return_value = ImageGenerationResponse(
        status=ImageGenerationStatus.COMPLETED,
        image_id="img_123",
        image_url="http://example.com/image.png",
        generation_time_ms=500,
    )

    ctx = PipelineContext(
        turn_input=base_turn_input,
        output=base_turn_output,
        image_generator=mock_image_generator,
        economy_snapshot=CurrencyAmount(signal=100, memory_shard=0),
    )

    # When
    result_ctx = await render_stage(ctx, emit=mock_emit)

    # Then
    assert result_ctx.output.render.image_url == "http://example.com/image.png"
    assert result_ctx.output.render.image_id == "img_123"
    assert ValidationBadge.SAFETY_OK in result_ctx.output.agent_console.badges


@pytest.mark.asyncio
async def test_image_fallback_safety_blocked(
    base_turn_output, base_turn_input, mock_emit, mock_image_generator
):
    """ì‹œë‚˜ë¦¬ì˜¤ 2: ì•ˆì „ ì •ì±… ì°¨ë‹¨ (Safety Blocked)."""
    # Given
    mock_image_generator.generate.return_value = ImageGenerationResponse(
        status=ImageGenerationStatus.FAILED, message="Blocked by safety filters."
    )

    ctx = PipelineContext(
        turn_input=base_turn_input,
        output=base_turn_output,
        image_generator=mock_image_generator,
        economy_snapshot=CurrencyAmount(signal=100, memory_shard=0),
    )

    # When
    result_ctx = await render_stage(ctx, emit=mock_emit)

    # Then
    assert result_ctx.output.render.image_url is None
    assert result_ctx.output.safety.blocked is True
    assert ValidationBadge.SAFETY_BLOCKED in result_ctx.output.agent_console.badges
    assert ValidationBadge.SAFETY_OK not in result_ctx.output.agent_console.badges


@pytest.mark.asyncio
async def test_image_fallback_insufficient_balance(
    base_turn_output, base_turn_input, mock_emit, mock_image_generator
):
    """ì‹œë‚˜ë¦¬ì˜¤ 5: ì”ì•¡ ë¶€ì¡± (Insufficient Balance)."""
    # Given
    ctx = PipelineContext(
        turn_input=base_turn_input,
        output=base_turn_output,
        image_generator=mock_image_generator,
        economy_snapshot=CurrencyAmount(signal=5, memory_shard=0),
    )

    # When
    result_ctx = await render_stage(ctx, emit=mock_emit)

    # Then
    mock_image_generator.generate.assert_not_called()
    assert result_ctx.output.render.image_url is None
    assert "ì”ì•¡ì´ ë¶€ì¡±í•˜ì—¬" in result_ctx.output.narrative


@pytest.mark.asyncio
async def test_image_fallback_timeout(
    base_turn_output, base_turn_input, mock_emit, mock_image_generator
):
    """ì‹œë‚˜ë¦¬ì˜¤ 4: íƒ€ì„ì•„ì›ƒ ë°œìƒ."""
    # Given
    mock_image_generator.generate.side_effect = TimeoutError("API Timeout")

    ctx = PipelineContext(
        turn_input=base_turn_input,
        output=base_turn_output,
        image_generator=mock_image_generator,
        economy_snapshot=CurrencyAmount(signal=100, memory_shard=0),
    )

    # When
    result_ctx = await render_stage(ctx, emit=mock_emit)

    # Then
    assert result_ctx.output.render.image_url is None
</file>

<file path="backend/tests/unit/orchestrator/test_u061_image_integration.py">
import pytest

from unknown_world.models.turn import Language, TurnInput
from unknown_world.orchestrator.generate_turn_output import TurnOutputGenerator
from unknown_world.orchestrator.prompt_loader import load_image_prompt


def test_load_image_prompt_languages():
    """ì–¸ì–´ë³„ ì´ë¯¸ì§€ í”„ë¡¬í”„íŠ¸ ë¡œë“œ ë° í´ë°± í…ŒìŠ¤íŠ¸."""
    # í•œêµ­ì–´ ë¡œë“œ
    ko_prompt = load_image_prompt(Language.KO)
    assert "ë‹¤í¬ íŒíƒ€ì§€" in ko_prompt
    assert "dark fantasy" in ko_prompt.lower()

    # ì˜ì–´ ë¡œë“œ
    en_prompt = load_image_prompt(Language.EN)
    assert "Dark fantasy" in en_prompt
    assert "dark fantasy" in en_prompt.lower()

    # ë‘ ë‚´ìš©ì´ ì„œë¡œ ë‹¤ë¥¸ì§€ í™•ì¸ (ë²ˆì—­ë¨)
    assert ko_prompt != en_prompt


def test_generate_turn_output_prompt_integration():
    """TurnOutputGeneratorì—ì„œ ì´ë¯¸ì§€ ê°€ì´ë“œë¼ì¸ì´ ì‹œìŠ¤í…œ í”„ë¡¬í”„íŠ¸ì— í¬í•¨ë˜ëŠ”ì§€ í…ŒìŠ¤íŠ¸."""
    generator = TurnOutputGenerator(force_mock=True)

    from unknown_world.models.turn import ClientInfo, EconomySnapshot, Theme

    client_info = ClientInfo(viewport_w=1920, viewport_h=1080, theme=Theme.DARK)

    turn_input_ko = TurnInput(
        text="í…ŒìŠ¤íŠ¸ ì…ë ¥",
        language=Language.KO,
        client=client_info,
        economy_snapshot=EconomySnapshot(signal=100, memory_shard=10),
    )

    prompt_ko = generator._build_prompt(turn_input_ko)

    # ì´ë¯¸ì§€ ê°€ì´ë“œë¼ì¸ ì„¹ì…˜ì´ í¬í•¨ë˜ì–´ ìˆëŠ”ì§€ í™•ì¸
    assert "## ì´ë¯¸ì§€ ìƒì„± ì§€ì¹¨ (Image Generation Guidelines)" in prompt_ko
    # í•œêµ­ì–´ ì§€ì¹¨ ë‚´ìš©ì´ í¬í•¨ë˜ì–´ ìˆëŠ”ì§€ í™•ì¸
    assert "ë‹¤í¬ íŒíƒ€ì§€" in prompt_ko

    turn_input_en = TurnInput(
        text="Test input",
        language=Language.EN,
        client=client_info,
        economy_snapshot=EconomySnapshot(signal=100, memory_shard=10),
    )

    prompt_en = generator._build_prompt(turn_input_en)

    assert "## ì´ë¯¸ì§€ ìƒì„± ì§€ì¹¨ (Image Generation Guidelines)" in prompt_en
    # ì˜ì–´ ì§€ì¹¨ ë‚´ìš©ì´ í¬í•¨ë˜ì–´ ìˆëŠ”ì§€ í™•ì¸
    assert "Dark fantasy" in prompt_en
    assert "ë‹¤í¬ íŒíƒ€ì§€" not in prompt_en  # ì˜ì–´ í”„ë¡¬í”„íŠ¸ì—ëŠ” í•œêµ­ì–´ ì„¤ëª…ì´ ì—†ì–´ì•¼ í•¨ (ë³¸ë¬¸ ê¸°ì¤€)


@pytest.mark.asyncio
async def test_generate_turn_output_full_flow_mock(monkeypatch):
    """ì „ì²´ ìƒì„± íë¦„ì—ì„œ ì´ë¯¸ì§€ í”„ë¡¬í”„íŠ¸ê°€ ìƒì„±ë˜ëŠ”ì§€ í™•ì¸ (Mock)."""
    # GenAIClient.generateê°€ ìœ íš¨í•œ TurnOutput JSONì„ ë°˜í™˜í•˜ë„ë¡ ëª¨í‚¹
    import json

    from unknown_world.services.genai_client import GenerateResponse, MockGenAIClient

    mock_turn_output = {
        "language": "ko-KR",
        "narrative": "í…ŒìŠ¤íŠ¸ ë‚´ëŸ¬í‹°ë¸Œ",
        "ui": {"action_deck": {"cards": []}, "objects": []},
        "world": {
            "rules_changed": [],
            "inventory_added": [],
            "inventory_removed": [],
            "quests_updated": [],
            "relationships_changed": [],
            "memory_pins": [],
        },
        "render": {
            "image_job": {
                "should_generate": True,
                "prompt": "A beautiful dark fantasy landscape, cinematic lighting, highly detailed",
                "model_label": "FAST",
                "aspect_ratio": "16:9",
                "image_size": "1024x1024",
            }
        },
        "economy": {
            "cost": {"signal": 5, "memory_shard": 0},
            "balance_after": {"signal": 95, "memory_shard": 10},
        },
        "safety": {"blocked": False},
        "agent_console": {"current_phase": "commit", "badges": ["schema_ok"], "repair_count": 0},
    }

    async def mock_generate(*args, **kwargs):
        return GenerateResponse(text=json.dumps(mock_turn_output), model_label="FAST")

    monkeypatch.setattr(MockGenAIClient, "generate", mock_generate)

    generator = TurnOutputGenerator(force_mock=True)

    from unknown_world.models.turn import ClientInfo, EconomySnapshot, Theme

    client_info = ClientInfo(viewport_w=1920, viewport_h=1080, theme=Theme.DARK)

    turn_input = TurnInput(
        text="ì–´ë‘ìš´ ìˆ²ìœ¼ë¡œ ë“¤ì–´ê°‘ë‹ˆë‹¤.",
        language=Language.KO,
        client=client_info,
        economy_snapshot=EconomySnapshot(signal=100, memory_shard=10),
    )

    result = await generator.generate(turn_input)

    assert result.status == "success"
    assert result.output is not None
    assert result.output.render.image_job.should_generate is True
    assert "dark fantasy" in result.output.render.image_job.prompt.lower()
</file>

<file path="backend/tests/unit/orchestrator/test_u069_model_tiering.py">
"""Unknown World - U-069 ëª¨ë¸ í‹°ì–´ë§(FAST/QUALITY) ë‹¨ìœ„ í…ŒìŠ¤íŠ¸.

ê²€ì¦ í•­ëª©:
    - ê¸°ë³¸ ëª¨ë¸ì´ FASTì¸ì§€ í™•ì¸
    - íŠ¹ì • action_id ì…ë ¥ ì‹œ QUALITY ëª¨ë¸ë¡œ ì „í™˜ë˜ëŠ”ì§€ í™•ì¸
    - íŠ¹ì • í‚¤ì›Œë“œ í¬í•¨ ì‹œ QUALITY ëª¨ë¸ë¡œ ì „í™˜ë˜ëŠ”ì§€ í™•ì¸
    - ëª¨ë¸ ì„ íƒì— ë”°ë¥¸ ë¹„ìš© ë°°ìˆ˜(cost_multiplier)ê°€ ì •í™•íˆ ë°˜ì˜ë˜ëŠ”ì§€ í™•ì¸
"""

from unittest.mock import AsyncMock, patch

import pytest

from unknown_world.config.models import ModelLabel
from unknown_world.models.turn import (
    ClientInfo,
    EconomySnapshot,
    Language,
    Theme,
    TurnInput,
)
from unknown_world.orchestrator.generate_turn_output import (
    GenerationStatus,
    TurnOutputGenerator,
)
from unknown_world.services.genai_client import GenerateResponse


@pytest.fixture
def turn_input_base() -> TurnInput:
    """ê¸°ë³¸ í„´ ì…ë ¥ í”½ìŠ¤ì²˜."""
    return TurnInput(
        language=Language.KO,
        text="ì£¼ë³€ì„ ë‘˜ëŸ¬ë³¸ë‹¤",
        client=ClientInfo(viewport_w=1920, viewport_h=1080, theme=Theme.DARK),
        economy_snapshot=EconomySnapshot(signal=100, memory_shard=5),
    )


def test_select_text_model_default(turn_input_base):
    """ê¸°ë³¸ ì…ë ¥ ì‹œ FAST ëª¨ë¸ì´ ì„ íƒë˜ëŠ”ì§€ í…ŒìŠ¤íŠ¸."""
    generator = TurnOutputGenerator()
    label, multiplier = generator._select_text_model(turn_input_base)

    assert label == ModelLabel.FAST
    assert multiplier == 1.0


def test_select_text_model_by_action_id(turn_input_base):
    """QUALITY íŠ¸ë¦¬ê±° action_id ì…ë ¥ ì‹œ QUALITY ëª¨ë¸ì´ ì„ íƒë˜ëŠ”ì§€ í…ŒìŠ¤íŠ¸."""
    generator = TurnOutputGenerator()

    # QUALITY íŠ¸ë¦¬ê±° action_id ì„¤ì •
    turn_input_base.action_id = "deep_investigate"
    label, multiplier = generator._select_text_model(turn_input_base)

    assert label == ModelLabel.QUALITY
    assert multiplier == 2.0


def test_select_text_model_by_keyword(turn_input_base):
    """QUALITY íŠ¸ë¦¬ê±° í‚¤ì›Œë“œ í¬í•¨ ì‹œ QUALITY ëª¨ë¸ì´ ì„ íƒë˜ëŠ”ì§€ í…ŒìŠ¤íŠ¸."""
    generator = TurnOutputGenerator()

    # QUALITY íŠ¸ë¦¬ê±° í‚¤ì›Œë“œ í¬í•¨
    turn_input_base.text = "ì´ ë‹¨ì„œë¥¼ ìì„¸íˆ ì‚´í´ë³¸ë‹¤"
    label, multiplier = generator._select_text_model(turn_input_base)

    assert label == ModelLabel.QUALITY
    assert multiplier == 2.0


def test_select_text_model_by_keyword_english(turn_input_base):
    """ì˜ë¬¸ QUALITY íŠ¸ë¦¬ê±° í‚¤ì›Œë“œ í¬í•¨ ì‹œ QUALITY ëª¨ë¸ì´ ì„ íƒë˜ëŠ”ì§€ í…ŒìŠ¤íŠ¸."""
    generator = TurnOutputGenerator()

    # ì˜ë¬¸ QUALITY íŠ¸ë¦¬ê±° í‚¤ì›Œë“œ í¬í•¨
    turn_input_base.text = "scrutinize the evidence"
    label, multiplier = generator._select_text_model(turn_input_base)

    assert label == ModelLabel.QUALITY
    assert multiplier == 2.0


@pytest.mark.asyncio
async def test_generate_reflects_model_tiering(turn_input_base):
    """generate ë©”ì„œë“œ í˜¸ì¶œ ì‹œ ëª¨ë¸ í‹°ì–´ë§ì´ ê²°ê³¼ì— ë°˜ì˜ë˜ëŠ”ì§€ í…ŒìŠ¤íŠ¸."""
    generator = TurnOutputGenerator(force_mock=True)
    turn_input_base.action_id = "ì •ë°€ì¡°ì‚¬"  # QUALITY íŠ¸ë¦¬ê±°

    # Mock ì‘ë‹µ
    mock_response_text = '{"language": "ko-KR", "narrative": "ì •ë°€ ì¡°ì‚¬ ê²°ê³¼ì…ë‹ˆë‹¤.", "economy": {"cost": {"signal": 10, "memory_shard": 0}, "balance_after": {"signal": 90, "memory_shard": 5}}, "safety": {"blocked": false}, "ui": {"action_deck": {"cards": []}, "objects": []}, "world": {"rules_changed": [], "inventory_added": [], "inventory_removed": [], "quests_updated": [], "memory_pins": []}, "agent_console": {"current_phase": "commit", "badges": [], "repair_count": 0, "model_label": "QUALITY"}}'
    mock_response = GenerateResponse(text=mock_response_text, model_label="QUALITY")

    with patch(
        "unknown_world.orchestrator.generate_turn_output.get_genai_client"
    ) as mock_get_client:
        mock_client = AsyncMock()
        mock_client.generate.return_value = mock_response
        mock_get_client.return_value = mock_client

        result = await generator.generate(turn_input_base)

        assert result.status == GenerationStatus.SUCCESS
        assert result.model_label == ModelLabel.QUALITY
        assert result.cost_multiplier == 2.0

        # QUALITY ëª¨ë¸ IDë¡œ í˜¸ì¶œë˜ì—ˆëŠ”ì§€ í™•ì¸
        call_args = mock_client.generate.call_args[0][0]
        assert call_args.model_label == ModelLabel.QUALITY
</file>

<file path="backend/tests/unit/orchestrator/test_u090_hotspot_restriction.py">
"""Unknown World - U-090 í•«ìŠ¤íŒŸ ìƒì„± ì œí•œ ë‹¨ìœ„ í…ŒìŠ¤íŠ¸."""

from unittest.mock import AsyncMock

import pytest

from unknown_world.models.turn import (
    AgentPhase,
    ClientInfo,
    CurrencyAmount,
    EconomySnapshot,
    Language,
    RenderOutput,
    SceneObject,
    TurnInput,
    TurnOutput,
    UIOutput,
    WorldDelta,
)
from unknown_world.orchestrator.stages.resolve import resolve_stage
from unknown_world.orchestrator.stages.types import PipelineContext
from unknown_world.orchestrator.stages.verify import verify_stage
from unknown_world.services.agentic_vision import Box2D


@pytest.fixture
def mock_emit():
    return AsyncMock()


@pytest.fixture
def base_context():
    """ê¸°ë³¸ í…ŒìŠ¤íŠ¸ ì»¨í…ìŠ¤íŠ¸."""
    economy_snap = EconomySnapshot(signal=100, memory_shard=0)
    turn_input = TurnInput(
        language=Language.KO,
        text="ë°©ì„ ë‘˜ëŸ¬ë³¸ë‹¤",
        action_id="explore",  # ì¼ë°˜ ì•¡ì…˜
        client=ClientInfo(viewport_w=1920, viewport_h=1080),
        economy_snapshot=economy_snap,
    )
    # TurnOutput ìƒì„± (GMì´ ì„ì˜ë¡œ í•«ìŠ¤íŒŸì„ ìƒì„±í–ˆë‹¤ê³  ê°€ì •)
    output = TurnOutput(
        language=Language.KO,
        narrative="ë°©ì— ë‚¡ì€ ìƒìê°€ ìˆìŠµë‹ˆë‹¤.",
        ui=UIOutput(
            objects=[
                SceneObject(
                    id="hallucinated_box",
                    label="í™˜ê° ìƒì",
                    box_2d=Box2D(ymin=100, xmin=100, ymax=200, xmax=200),
                )
            ]
        ),
        render=RenderOutput(image_url="/static/test.png"),
        world=WorldDelta(),
        economy={
            "cost": {"signal": 5, "memory_shard": 0},
            "balance_after": {"signal": 95, "memory_shard": 0},
        },
        safety={"blocked": False},
    )
    return PipelineContext(
        turn_input=turn_input,
        economy_snapshot=CurrencyAmount(
            signal=economy_snap.signal, memory_shard=economy_snap.memory_shard
        ),
        output=output,
        current_phase=AgentPhase.VALIDATE,
    )


@pytest.mark.asyncio
async def test_resolve_stage_strips_hotspots_on_normal_turn(base_context, mock_emit):
    """ì¼ë°˜ í„´ì—ì„œ GMì´ ìƒì„±í•œ í•«ìŠ¤íŒŸì´ resolve_stageì—ì„œ ì œê±°ë˜ëŠ”ì§€ í™•ì¸."""
    # Given: action_id = "explore" (ì¼ë°˜ í„´), objectsì— 1ê°œ ì¡´ì¬
    assert len(base_context.output.ui.objects) == 1

    # When: resolve_stage ì‹¤í–‰
    updated_ctx = await resolve_stage(base_context, emit=mock_emit)

    # Then: objectsê°€ ë¹ˆ ë°°ì—´ì´ì–´ì•¼ í•¨
    assert len(updated_ctx.output.ui.objects) == 0


@pytest.mark.asyncio
async def test_verify_stage_strips_hotspots_on_normal_turn(base_context, mock_emit):
    """ì¼ë°˜ í„´ì—ì„œ í•«ìŠ¤íŒŸì´ verify_stageì—ì„œ ì´ì¤‘ìœ¼ë¡œ ì œê±°ë˜ëŠ”ì§€ í™•ì¸."""
    # Given: action_id = "explore" (ì¼ë°˜ í„´), objectsì— 1ê°œ ì¡´ì¬
    assert len(base_context.output.ui.objects) == 1

    # When: verify_stage ì‹¤í–‰
    updated_ctx = await verify_stage(base_context, emit=mock_emit)

    # Then: objectsê°€ ë¹ˆ ë°°ì—´ì´ì–´ì•¼ í•¨
    assert len(updated_ctx.output.ui.objects) == 0


@pytest.mark.asyncio
async def test_resolve_stage_keeps_objects_empty_on_normal_turn(base_context, mock_emit):
    """ì¼ë°˜ í„´ì—ì„œ ì›ë˜ ë¹„ì–´ìˆë˜ objectsê°€ ìœ ì§€ë˜ëŠ”ì§€ í™•ì¸."""
    # Given: objectsê°€ ì´ë¯¸ ë¹„ì–´ìˆìŒ
    base_context.output.ui.objects = []

    # When: resolve_stage ì‹¤í–‰
    updated_ctx = await resolve_stage(base_context, emit=mock_emit)

    # Then: ì—¬ì „íˆ ë¹„ì–´ìˆì–´ì•¼ í•¨
    assert len(updated_ctx.output.ui.objects) == 0
</file>

<file path="backend/tests/unit/services/test_agentic_vision.py">
"""Unknown World - Agentic Vision ì„œë¹„ìŠ¤ ë‹¨ìœ„ í…ŒìŠ¤íŠ¸ (U-076[Mvp])."""

from unknown_world.models.turn import Box2D, Language
from unknown_world.services.agentic_vision import (
    _normalize_bbox,
    _parse_vision_response,
    affordances_to_scene_objects,
)


def test_normalize_bbox_valid():
    """ì •ìƒì ì¸ bbox ë°ì´í„° ì •ê·œí™” í…ŒìŠ¤íŠ¸."""
    raw = {"ymin": 100, "xmin": 200, "ymax": 300, "xmax": 400}
    bbox = _normalize_bbox(raw)
    assert bbox is not None
    assert bbox.ymin == 100
    assert bbox.xmin == 200
    assert bbox.ymax == 300
    assert bbox.xmax == 400


def test_normalize_bbox_out_of_range():
    """ë²”ìœ„ë¥¼ ë²—ì–´ë‚œ bbox ë°ì´í„° í´ë¨í•‘ í…ŒìŠ¤íŠ¸ (RULE-009)."""
    raw = {"ymin": -10, "xmin": 500, "ymax": 1100, "xmax": 2000}
    bbox = _normalize_bbox(raw)
    assert bbox is not None
    assert bbox.ymin == 0
    assert bbox.xmin == 500
    assert bbox.ymax == 1000
    assert bbox.xmax == 1000


def test_normalize_bbox_invalid_order():
    """ymin >= ymax ê°™ì€ ì˜ëª»ëœ ìˆœì„œ ìë™ êµì • í…ŒìŠ¤íŠ¸."""
    raw = {"ymin": 500, "xmin": 200, "ymax": 400, "xmax": 300}
    bbox = _normalize_bbox(raw)
    assert bbox is not None
    assert bbox.ymin == 500
    assert bbox.ymax > 500
    assert bbox.xmin == 200
    assert bbox.xmax > 200


def test_parse_vision_response_success():
    """ì •ìƒì ì¸ JSON ì‘ë‹µ íŒŒì‹± í…ŒìŠ¤íŠ¸."""
    response_text = """
    ```json
    {
      "affordances": [
        {
          "label": "í…ŒìŠ¤íŠ¸ ì˜¤ë¸Œì íŠ¸",
          "box_2d": {"ymin": 10, "xmin": 20, "ymax": 100, "xmax": 200},
          "interaction_hint": "í´ë¦­í•˜ì„¸ìš”"
        }
      ]
    }
    ```
    """
    result = _parse_vision_response(response_text, Language.KO)
    assert result.success is True
    assert len(result.affordances) == 1
    assert result.affordances[0].label == "í…ŒìŠ¤íŠ¸ ì˜¤ë¸Œì íŠ¸"
    assert result.affordances[0].box_2d.ymin == 10
    assert result.affordances[0].interaction_hint == "í´ë¦­í•˜ì„¸ìš”"


def test_parse_vision_response_failure():
    """ì˜ëª»ëœ JSON ì‘ë‹µ íŒŒì‹± ì‹¤íŒ¨ ë° í´ë°± í…ŒìŠ¤íŠ¸ (RULE-004)."""
    response_text = "ì´ê²ƒì€ JSONì´ ì•„ë‹™ë‹ˆë‹¤."
    result = _parse_vision_response(response_text, Language.KO)
    assert result.success is False
    assert len(result.affordances) == 0


def test_affordances_to_scene_objects():
    """Affordance -> SceneObject ë³€í™˜ í…ŒìŠ¤íŠ¸."""
    from unknown_world.services.agentic_vision import Affordance

    affs = [
        Affordance(label="Obj1", box_2d=Box2D(ymin=0, xmin=0, ymax=100, xmax=100)),
        Affordance(label="Obj2", box_2d=Box2D(ymin=200, xmin=200, ymax=300, xmax=300)),
    ]
    objs = affordances_to_scene_objects(affs, id_prefix="test")

    assert len(objs) == 2
    assert objs[0].id == "test_0"
    assert objs[0].label == "Obj1"
    assert objs[1].id == "test_1"
    assert objs[1].label == "Obj2"
</file>

<file path="backend/tests/unit/services/test_item_icon_generator.py">
import hashlib
from unittest.mock import AsyncMock, MagicMock, patch

import pytest

from unknown_world.services.item_icon_generator import (
    IconCache,
    IconGenerationRequest,
    IconGenerationStatus,
    ItemIconGenerator,
)


@pytest.fixture
def mock_image_generator():
    generator = MagicMock()
    generator.generate = AsyncMock()
    return generator


@pytest.fixture
def temp_cache_dir(tmp_path):
    return tmp_path / "icons"


@pytest.fixture
def icon_cache(temp_cache_dir):
    return IconCache(cache_dir=temp_cache_dir)


@pytest.fixture
def icon_generator(mock_image_generator, icon_cache):
    return ItemIconGenerator(image_generator=mock_image_generator, cache=icon_cache)


def test_cache_key_generation(icon_cache):
    description = "A shiny sword"
    key1 = icon_cache._make_cache_key(description)
    key2 = icon_cache._make_cache_key(description)
    assert key1 == key2
    assert key1 == hashlib.md5(description.encode()).hexdigest()


@pytest.mark.asyncio
async def test_generate_icon_cached(icon_generator, icon_cache, temp_cache_dir):
    description = "Cached item"
    cache_key = icon_cache._make_cache_key(description)
    cache_file = temp_cache_dir / f"{cache_key}.png"
    cache_file.parent.mkdir(parents=True, exist_ok=True)
    cache_file.write_bytes(b"fake_image_data")

    request = IconGenerationRequest(
        item_id="item_1", item_description=description, language="ko-KR"
    )

    response = await icon_generator.generate_icon(request, wait_for_completion=True)

    assert response.status == IconGenerationStatus.CACHED
    assert response.is_placeholder is False
    assert f"{cache_key}.png" in response.icon_url


@pytest.mark.asyncio
async def test_generate_icon_new_async(icon_generator, mock_image_generator):
    request = IconGenerationRequest(
        item_id="item_2", item_description="New item async", language="ko-KR"
    )

    response = await icon_generator.generate_icon(request, wait_for_completion=False)

    assert response.status == IconGenerationStatus.PENDING
    assert response.is_placeholder is True
    assert "placeholder" in response.icon_url

    # ë°±ê·¸ë¼ìš´ë“œ íƒœìŠ¤í¬ê°€ ìƒì„±ë˜ì—ˆëŠ”ì§€ í™•ì¸ (ë‚´ë¶€ êµ¬í˜„ ì˜ì¡´ì ì´ì§€ë§Œ ìƒíƒœë¡œ í™•ì¸ ê°€ëŠ¥)
    status = await icon_generator.get_icon_status("item_2")
    assert status in [IconGenerationStatus.GENERATING, IconGenerationStatus.COMPLETED]


@pytest.mark.asyncio
async def test_generate_icon_new_sync_success(
    icon_generator, mock_image_generator, icon_cache, temp_cache_dir
):
    from unknown_world.services.image_generation import (
        ImageGenerationResponse,
        ImageGenerationStatus,
    )

    description = "New item sync"
    cache_key = icon_cache._make_cache_key(description)

    # Mock response
    mock_image_id = "test_image_id"
    mock_image_generator.generate.return_value = ImageGenerationResponse(
        status=ImageGenerationStatus.COMPLETED,
        image_url="http://example.com/test.png",
        image_id=mock_image_id,
    )

    # ì›ë³¸ íŒŒì¼ì´ ìƒì„±ëœ ê²ƒìœ¼ë¡œ ì‹œë®¬ë ˆì´ì…˜

    with patch(
        "unknown_world.services.item_icon_generator.get_generated_images_dir"
    ) as mock_get_dir:
        mock_get_dir.return_value = temp_cache_dir.parent  # iconsì˜ ìƒìœ„ ë””ë ‰í† ë¦¬
        gen_dir = temp_cache_dir.parent
        gen_dir.mkdir(parents=True, exist_ok=True)
        (gen_dir / f"{mock_image_id}.png").write_bytes(b"fake_image_content")

        # PIL.Image.open ëª¨í‚¹ (ì‹¤ì œ ì´ë¯¸ì§€ê°€ ì•„ë‹ˆë¯€ë¡œ)
        with patch("PIL.Image.open") as mock_open:
            mock_img = MagicMock()
            mock_img.size = (1024, 1024)
            mock_img.resize.return_value = mock_img
            mock_open.return_value.__enter__.return_value = mock_img

            request = IconGenerationRequest(
                item_id="item_3", item_description=description, language="en-US"
            )

            response = await icon_generator.generate_icon(request, wait_for_completion=True)

            assert response.status == IconGenerationStatus.COMPLETED
            assert response.is_placeholder is False
            assert f"{cache_key}.png" in response.icon_url
            assert (temp_cache_dir / f"{cache_key}.png").exists()


@pytest.mark.asyncio
async def test_generate_icon_failure(icon_generator, mock_image_generator):
    from unknown_world.services.image_generation import (
        ImageGenerationResponse,
        ImageGenerationStatus,
    )

    mock_image_generator.generate.return_value = ImageGenerationResponse(
        status=ImageGenerationStatus.FAILED, image_url="", message="Generation failed"
    )

    request = IconGenerationRequest(
        item_id="item_4", item_description="Failing item", language="ko-KR"
    )

    response = await icon_generator.generate_icon(request, wait_for_completion=True)

    assert response.status == IconGenerationStatus.FAILED
    assert response.is_placeholder is True
    assert "placeholder" in response.icon_url
</file>

<file path="backend/tests/unit/services/test_scanner_service.py">
"""U-021 ì´ë¯¸ì§€ ì´í•´(Scanner) ì„œë¹„ìŠ¤ ë‹¨ìœ„ í…ŒìŠ¤íŠ¸."""

import pytest

from unknown_world.models.scanner import ScanStatus
from unknown_world.models.turn import Language
from unknown_world.services.image_understanding import (
    MAX_FILE_SIZE_BYTES,
    ImageUnderstandingService,
    _parse_vision_response,
    normalize_bbox,
    validate_image,
)


def test_validate_image_valid():
    """ì •ìƒì ì¸ ì´ë¯¸ì§€ ê²€ì¦ í…ŒìŠ¤íŠ¸."""
    content = b"a" * 1000
    assert validate_image(content, "image/png") is None
    assert validate_image(content, "image/jpeg") is None
    assert validate_image(content, "image/webp") is None


def test_validate_image_invalid_type():
    """ì§€ì›í•˜ì§€ ì•ŠëŠ” íŒŒì¼ í˜•ì‹ ê²€ì¦ í…ŒìŠ¤íŠ¸."""
    content = b"a" * 1000
    error = validate_image(content, "text/plain")
    assert "ì§€ì›í•˜ì§€ ì•ŠëŠ” ì´ë¯¸ì§€ í˜•ì‹" in error


def test_validate_image_too_large():
    """íŒŒì¼ í¬ê¸° ì´ˆê³¼ ê²€ì¦ í…ŒìŠ¤íŠ¸."""
    content = b"a" * (MAX_FILE_SIZE_BYTES + 1)
    error = validate_image(content, "image/png")
    assert "íŒŒì¼ì´ ë„ˆë¬´ í½ë‹ˆë‹¤" in error


def test_validate_image_too_small():
    """ë„ˆë¬´ ì‘ì€ íŒŒì¼ ê²€ì¦ í…ŒìŠ¤íŠ¸."""
    content = b"a" * 10
    error = validate_image(content, "image/png")
    assert "ì´ë¯¸ì§€ íŒŒì¼ì´ ì†ìƒë˜ì—ˆê±°ë‚˜ ë¹„ì–´ìˆìŠµë‹ˆë‹¤" in error


def test_normalize_bbox_valid():
    """bbox ì •ê·œí™” í…ŒìŠ¤íŠ¸ (ì •ìƒ ë²”ìœ„)."""
    bbox = {"ymin": 100, "xmin": 200, "ymax": 300, "xmax": 400}
    normalized = normalize_bbox(bbox)
    assert normalized.ymin == 100
    assert normalized.xmin == 200
    assert normalized.ymax == 300
    assert normalized.xmax == 400


def test_normalize_bbox_clamping():
    """bbox ì •ê·œí™” í…ŒìŠ¤íŠ¸ (ë²”ìœ„ ì´ˆê³¼ í´ë¨í•‘)."""
    bbox = {"ymin": -100, "xmin": 1200, "ymax": 1500, "xmax": 500}
    normalized = normalize_bbox(bbox)
    assert normalized.ymin == 0
    assert normalized.xmin == 1000  # xminì´ xmaxë³´ë‹¤ ì»¤ì§€ëŠ” ê²½ìš° normalize_bbox ë¡œì§ í™•ì¸ í•„ìš”
    # xmaxê°€ 500ì´ë¯€ë¡œ xminì´ 1000ìœ¼ë¡œ í´ë¨í•‘ë˜ë©´ xmin > xmaxê°€ ë¨
    # normalize_bbox êµ¬í˜„:
    # xmin_val = max(0, min(1000, 1200)) -> 1000
    # xmax_val = max(0, min(1000, 500)) -> 500
    # if xmin_val >= xmax_val: xmax_val = min(xmin_val + 100, 1000) -> 1000
    assert normalized.xmax == 1000
    assert normalized.xmin == 1000


def test_normalize_bbox_order_correction():
    """bbox ì •ê·œí™” í…ŒìŠ¤íŠ¸ (ìˆœì„œ ë³´ì •)."""
    bbox = {"ymin": 500, "xmin": 500, "ymax": 200, "xmax": 200}
    normalized = normalize_bbox(bbox)
    assert normalized.ymin == 500
    assert normalized.ymax == 600  # 500 + 100
    assert normalized.xmin == 500
    assert normalized.xmax == 600  # 500 + 100


def test_parse_vision_response_valid():
    """ë¹„ì „ ëª¨ë¸ ì‘ë‹µ íŒŒì‹± í…ŒìŠ¤íŠ¸ (ì •ìƒ JSON)."""
    response_text = """
    {
      "caption": "A test image",
      "objects": [
        {
          "label": "Key",
          "box_2d": {"ymin": 100, "xmin": 100, "ymax": 200, "xmax": 200},
          "suggested_item_type": "key"
        }
      ],
      "item_candidates": [
        {
          "id": "item_1",
          "label": "Old Key",
          "description": "An old key",
          "item_type": "key",
          "source_object_index": 0
        }
      ]
    }
    """
    result = _parse_vision_response(response_text, Language.EN)
    assert result.status == ScanStatus.COMPLETED
    assert result.caption == "A test image"
    assert len(result.objects) == 1
    assert result.objects[0].label == "Key"
    assert result.objects[0].box_2d.ymin == 100
    assert len(result.item_candidates) == 1
    assert result.item_candidates[0].label == "Old Key"


def test_parse_vision_response_markdown():
    """ë¹„ì „ ëª¨ë¸ ì‘ë‹µ íŒŒì‹± í…ŒìŠ¤íŠ¸ (ë§ˆí¬ë‹¤ìš´ í¬í•¨)."""
    response_text = """```json
    {
      "caption": "Markdown test",
      "objects": []
    }
    ```"""
    result = _parse_vision_response(response_text, Language.KO)
    assert result.status == ScanStatus.COMPLETED
    assert result.caption == "Markdown test"


def test_parse_vision_response_invalid_json():
    """ë¹„ì „ ëª¨ë¸ ì‘ë‹µ íŒŒì‹± í…ŒìŠ¤íŠ¸ (ì˜ëª»ëœ JSON)."""
    response_text = "This is not JSON"
    result = _parse_vision_response(response_text, Language.KO)
    assert result.status == ScanStatus.PARTIAL
    assert result.caption == "This is not JSON"
    assert "íŒŒì‹±í•  ìˆ˜ ì—†ìŠµë‹ˆë‹¤" in result.message


@pytest.mark.asyncio
async def test_service_analyze_mock():
    """ì„œë¹„ìŠ¤ analyze ë©”ì„œë“œ í…ŒìŠ¤íŠ¸ (Mock ëª¨ë“œ)."""
    service = ImageUnderstandingService(force_mock=True)
    content = b"a" * 1000
    result = await service.analyze(content, "image/png", Language.KO)

    assert result.status == ScanStatus.COMPLETED
    assert "[Mock]" in result.caption
    assert len(result.objects) > 0
    assert result.analysis_time_ms >= 0
    assert result.message is None
</file>

<file path="backend/tests/unit/services/test_u093_timeout_retry.py">
from unittest.mock import AsyncMock, MagicMock, patch

import pytest

from unknown_world.services.image_generation import (
    ImageGenerationResponse,
    ImageGenerationStatus,
)
from unknown_world.services.item_icon_generator import (
    IconGenerationRequest,
    IconGenerationStatus,
    ItemIconGenerator,
)


@pytest.fixture
def mock_image_generator():
    generator = MagicMock()
    generator.generate = AsyncMock()
    return generator


@pytest.fixture
def icon_generator(mock_image_generator):
    # ìºì‹œëŠ” Mockìœ¼ë¡œ ì²˜ë¦¬í•˜ì—¬ íŒŒì¼ ì‹œìŠ¤í…œ ì˜ì¡´ì„± ì œê±°
    mock_cache = MagicMock()
    mock_cache.get.return_value = None
    return ItemIconGenerator(image_generator=mock_image_generator, cache=mock_cache)


@pytest.mark.asyncio
async def test_retry_on_timeout(icon_generator, mock_image_generator):
    """íƒ€ì„ì•„ì›ƒ ë°œìƒ ì‹œ ìµœëŒ€ 1íšŒ ì¬ì‹œë„(ì´ 2íšŒ) í›„ ì„±ê³µí•˜ëŠ”ì§€ ê²€ì¦."""
    request = IconGenerationRequest(
        item_id="item_timeout", item_description="Timeout Item", language="ko-KR"
    )

    # ì²« ë²ˆì§¸ëŠ” TimeoutError, ë‘ ë²ˆì§¸ëŠ” ì„±ê³µ ì‘ë‹µ ì„¤ì •
    mock_image_generator.generate.side_effect = [
        TimeoutError(),
        ImageGenerationResponse(
            status=ImageGenerationStatus.COMPLETED,
            image_url="http://example.com/retry_success.png",
            image_id="img_retry_success",
        ),
    ]

    # asyncio.sleep ëª¨í‚¹ (ëŒ€ê¸° ì‹œê°„ ì œê±°)
    with (
        patch("asyncio.sleep", AsyncMock()) as mock_sleep,
        patch("unknown_world.services.item_icon_generator.get_generated_images_dir") as mock_dir,
        patch("pathlib.Path.exists", return_value=True),
        patch("pathlib.Path.read_bytes", return_value=b"fake_data"),
    ):
        mock_dir.return_value = MagicMock()
        # IconCache.set ëª¨í‚¹
        icon_generator._cache.set.return_value = "http://example.com/cached.png"

        response = await icon_generator.generate_icon(request, wait_for_completion=True)

        # ê²°ê³¼ ê²€ì¦
        assert response.status == IconGenerationStatus.COMPLETED
        assert response.icon_url == "http://example.com/cached.png"
        assert mock_image_generator.generate.call_count == 2
        assert mock_sleep.call_count == 1
        mock_sleep.assert_called_with(2.0)  # ì²« ë²ˆì§¸ ë°±ì˜¤í”„: 2.0s


@pytest.mark.asyncio
async def test_retry_on_retryable_error(icon_generator, mock_image_generator):
    """ì¬ì‹œë„ ê°€ëŠ¥í•œ ì—ëŸ¬(ì˜ˆ: 500) ë°œìƒ ì‹œ ì¬ì‹œë„í•˜ëŠ”ì§€ ê²€ì¦."""
    request = IconGenerationRequest(
        item_id="item_retryable", item_description="Retryable Item", language="ko-KR"
    )

    # ì²« ë²ˆì§¸ëŠ” ì‹¤íŒ¨(ì¬ì‹œë„ ê°€ëŠ¥), ë‘ ë²ˆì§¸ëŠ” ì„±ê³µ
    mock_image_generator.generate.side_effect = [
        ImageGenerationResponse(
            status=ImageGenerationStatus.FAILED, message="Internal Server Error (500)"
        ),
        ImageGenerationResponse(
            status=ImageGenerationStatus.COMPLETED,
            image_url="http://example.com/retry_success.png",
            image_id="img_retry_success",
        ),
    ]

    with (
        patch("asyncio.sleep", AsyncMock()) as mock_sleep,
        patch("unknown_world.services.item_icon_generator.get_generated_images_dir"),
        patch("pathlib.Path.exists", return_value=True),
        patch("pathlib.Path.read_bytes", return_value=b"fake_data"),
    ):
        icon_generator._cache.set.return_value = "http://example.com/cached.png"

        response = await icon_generator.generate_icon(request, wait_for_completion=True)

        assert response.status == IconGenerationStatus.COMPLETED
        assert mock_image_generator.generate.call_count == 2
        assert mock_sleep.call_count == 1


@pytest.mark.asyncio
async def test_no_retry_on_non_retryable_error(icon_generator, mock_image_generator):
    """ì¬ì‹œë„ ë¶ˆê°€ëŠ¥í•œ ì—ëŸ¬(ì˜ˆ: safety block) ë°œìƒ ì‹œ ì¬ì‹œë„í•˜ì§€ ì•ŠëŠ”ì§€ ê²€ì¦."""
    request = IconGenerationRequest(
        item_id="item_non_retryable", item_description="Blocked Item", language="ko-KR"
    )

    # Safety ì°¨ë‹¨ ì—ëŸ¬ (ì¬ì‹œë„ ë¶ˆê°€)
    mock_image_generator.generate.return_value = ImageGenerationResponse(
        status=ImageGenerationStatus.FAILED, message="Safety filter blocked the request"
    )

    with patch("asyncio.sleep", AsyncMock()) as mock_sleep:
        response = await icon_generator.generate_icon(request, wait_for_completion=True)

        assert response.status == IconGenerationStatus.FAILED
        assert response.is_placeholder is True
        # ì¬ì‹œë„ ì—†ì´ 1íšŒ í˜¸ì¶œ í›„ ì¢…ë£Œë˜ì–´ì•¼ í•¨
        assert mock_image_generator.generate.call_count == 1
        assert mock_sleep.call_count == 0


@pytest.mark.asyncio
async def test_final_failure_after_max_retries(icon_generator, mock_image_generator):
    """ëª¨ë“  ì¬ì‹œë„(ì´ 2íšŒ) ì‹¤íŒ¨ ì‹œ ìµœì¢…ì ìœ¼ë¡œ FAILEDë¥¼ ë°˜í™˜í•˜ëŠ”ì§€ ê²€ì¦."""
    request = IconGenerationRequest(
        item_id="item_all_fail", item_description="Always Failing Item", language="ko-KR"
    )

    # 2íšŒ ëª¨ë‘ íƒ€ì„ì•„ì›ƒ ë°œìƒ
    mock_image_generator.generate.side_effect = [
        TimeoutError(),
        TimeoutError(),
    ]

    with patch("asyncio.sleep", AsyncMock()) as mock_sleep:
        response = await icon_generator.generate_icon(request, wait_for_completion=True)

        assert response.status == IconGenerationStatus.FAILED
        assert response.is_placeholder is True
        assert "ì•„ì´ì½˜ ìƒì„± ì‹¤íŒ¨ (2/2 ì‹œë„)" in response.message
        assert mock_image_generator.generate.call_count == 2
        assert mock_sleep.call_count == 1


@pytest.mark.asyncio
async def test_retry_on_retryable_exception(icon_generator, mock_image_generator):
    """ì¬ì‹œë„ ê°€ëŠ¥í•œ ì˜ˆì™¸(ì˜ˆ: ConnectionError) ë°œìƒ ì‹œ ì¬ì‹œë„í•˜ëŠ”ì§€ ê²€ì¦."""
    request = IconGenerationRequest(
        item_id="item_exc", item_description="Exception Item", language="ko-KR"
    )

    # ì²« ë²ˆì§¸ëŠ” ConnectionError, ë‘ ë²ˆì§¸ëŠ” ì„±ê³µ
    mock_image_generator.generate.side_effect = [
        ConnectionError("Network disconnected"),
        ImageGenerationResponse(
            status=ImageGenerationStatus.COMPLETED,
            image_url="http://example.com/retry_success.png",
            image_id="img_retry_success",
        ),
    ]

    with (
        patch("asyncio.sleep", AsyncMock()) as mock_sleep,
        patch("unknown_world.services.item_icon_generator.get_generated_images_dir"),
        patch("pathlib.Path.exists", return_value=True),
        patch("pathlib.Path.read_bytes", return_value=b"fake_data"),
    ):
        icon_generator._cache.set.return_value = "http://example.com/cached.png"

        response = await icon_generator.generate_icon(request, wait_for_completion=True)

        assert response.status == IconGenerationStatus.COMPLETED
        assert mock_image_generator.generate.call_count == 2
        assert mock_sleep.call_count == 1
</file>

<file path="backend/tests/unit/test_dotenv_autoload.py">
"""U-047: Backend .env ìë™ ë¡œë”© í…ŒìŠ¤íŠ¸

ì´ ëª¨ë“ˆì€ backend/.env íŒŒì¼ì˜ ìë™ ë¡œë”© ê¸°ëŠ¥ì„ ê²€ì¦í•©ë‹ˆë‹¤.

ì™„ë£Œ ê¸°ì¤€:
- ë¡œì»¬ì—ì„œ .env ì¡´ì¬ ì‹œ ìë™ ë¡œë”©ë¨ (ì¶”ê°€ export ë¶ˆí•„ìš”)
- UW_MODE/ENVIRONMENTê°€ .env ê¸°ì¤€ìœ¼ë¡œ ë°˜ì˜ë¨
- .env ë¯¸ì¡´ì¬ ì‹œ ì„œë²„ ì •ìƒ ì‹œì‘ (no-op)
- ë¯¼ê° ì •ë³´(í‚¤/í† í°/í”„ë¡¬í”„íŠ¸)ëŠ” ë¡œê·¸/ìŠ¤íŠ¸ë¦¼ì— ë…¸ì¶œë˜ì§€ ì•ŠìŒ (RULE-007)

í…ŒìŠ¤íŠ¸ ì‹œë‚˜ë¦¬ì˜¤:
1. .env íŒŒì¼ ì¡´ì¬ ì‹œ ë¡œë”© ì„±ê³µ
2. .env íŒŒì¼ ë¯¸ì¡´ì¬ ì‹œ ê¸°ë³¸ê°’ ì‚¬ìš© (ì •ìƒ ì‹œì‘)
3. override=False ì •ì±… ê²€ì¦ (ê¸°ì¡´ í™˜ê²½ë³€ìˆ˜ ìš°ì„ )
4. ë¡œê¹…ì— ë¯¼ê° ì •ë³´ ë¯¸í¬í•¨ ê²€ì¦
"""

import logging
import os
import tempfile
from collections.abc import Generator
from pathlib import Path

import pytest
from dotenv import load_dotenv


class TestDotenvAutoload:
    """dotenv ìë™ ë¡œë”© ê¸°ëŠ¥ í…ŒìŠ¤íŠ¸ ìŠ¤ìœ„íŠ¸."""

    # =========================================================================
    # Fixtures
    # =========================================================================

    @pytest.fixture
    def temp_env_file(self, tmp_path: Path) -> Generator[Path]:
        """ì„ì‹œ .env íŒŒì¼ì„ ìƒì„±í•˜ê³  ê²½ë¡œë¥¼ ë°˜í™˜í•©ë‹ˆë‹¤."""
        env_file = tmp_path / ".env"
        env_file.write_text(
            "UW_MODE=real\nENVIRONMENT=development\nGOOGLE_APPLICATION_CREDENTIALS=./test-key.key\n"
        )
        yield env_file
        # cleanup
        if env_file.exists():
            env_file.unlink()

    @pytest.fixture
    def clean_env(self) -> Generator[None]:
        """í…ŒìŠ¤íŠ¸ ì „ ê´€ë ¨ í™˜ê²½ë³€ìˆ˜ë¥¼ ì •ë¦¬í•©ë‹ˆë‹¤."""
        # ì €ì¥í•  ì›ë˜ ê°’ë“¤
        original_values: dict[str, str | None] = {}
        keys_to_clean = ["UW_MODE", "ENVIRONMENT", "GOOGLE_APPLICATION_CREDENTIALS"]

        for key in keys_to_clean:
            original_values[key] = os.environ.pop(key, None)

        yield

        # ë³µì›
        for key, value in original_values.items():
            if value is not None:
                os.environ[key] = value
            elif key in os.environ:
                del os.environ[key]

    # =========================================================================
    # 1. ì„±ê³µ ì‹œë‚˜ë¦¬ì˜¤ (Happy Path)
    # =========================================================================

    def test_dotenv_loads_when_file_exists(self, temp_env_file: Path, clean_env: None) -> None:
        """[Happy] .env íŒŒì¼ ì¡´ì¬ ì‹œ í™˜ê²½ë³€ìˆ˜ê°€ ë¡œë“œë©ë‹ˆë‹¤."""
        # Given: .env íŒŒì¼ì´ ì¡´ì¬í•˜ê³  í™˜ê²½ë³€ìˆ˜ê°€ ì„¤ì •ë˜ì–´ ìˆì§€ ì•ŠìŒ
        assert "UW_MODE" not in os.environ
        assert "ENVIRONMENT" not in os.environ

        # When: load_dotenv í˜¸ì¶œ
        result = load_dotenv(dotenv_path=temp_env_file, override=False)

        # Then: í™˜ê²½ë³€ìˆ˜ê°€ ë¡œë“œë¨
        assert result is True
        assert os.environ.get("UW_MODE") == "real"
        assert os.environ.get("ENVIRONMENT") == "development"

    def test_uw_mode_reflects_env_value(self, temp_env_file: Path, clean_env: None) -> None:
        """[Happy] UW_MODEê°€ .envì—ì„œ ë¡œë“œëœ ê°’ìœ¼ë¡œ ì„¤ì •ë©ë‹ˆë‹¤."""
        # Given: clean env + temp .env file
        load_dotenv(dotenv_path=temp_env_file, override=False)

        # When/Then: UW_MODE ê°’ í™•ì¸
        assert os.environ.get("UW_MODE") == "real"

    def test_environment_reflects_env_value(self, temp_env_file: Path, clean_env: None) -> None:
        """[Happy] ENVIRONMENTê°€ .envì—ì„œ ë¡œë“œëœ ê°’ìœ¼ë¡œ ì„¤ì •ë©ë‹ˆë‹¤."""
        # Given: clean env + temp .env file
        load_dotenv(dotenv_path=temp_env_file, override=False)

        # When/Then: ENVIRONMENT ê°’ í™•ì¸
        assert os.environ.get("ENVIRONMENT") == "development"

    # =========================================================================
    # 2. ì‹¤íŒ¨/ì˜ˆì™¸ ì‹œë‚˜ë¦¬ì˜¤ (Error Cases)
    # =========================================================================

    def test_server_starts_without_env_file(self, clean_env: None) -> None:
        """[Error] .env íŒŒì¼ ë¯¸ì¡´ì¬ ì‹œ load_dotenvëŠ” Falseë¥¼ ë°˜í™˜í•˜ê³  ì„œë²„ëŠ” ì •ìƒ ì‹œì‘í•©ë‹ˆë‹¤."""
        # Given: ì¡´ì¬í•˜ì§€ ì•ŠëŠ” ê²½ë¡œ
        non_existent_path = Path("/non/existent/path/.env")

        # When: load_dotenv í˜¸ì¶œ
        result = load_dotenv(dotenv_path=non_existent_path, override=False)

        # Then: False ë°˜í™˜ (ì—ëŸ¬ ì—†ì´)
        assert result is False

    def test_default_values_when_env_missing(self, clean_env: None) -> None:
        """[Error] .env ë¯¸ì¡´ì¬ ì‹œ ê¸°ë³¸ê°’ì„ ì‚¬ìš©í•©ë‹ˆë‹¤."""
        # Given: .env ì—†ì´ í™˜ê²½ë³€ìˆ˜ë„ ì—†ìŒ
        # When: ê¸°ë³¸ê°’ ì¡°íšŒ
        uw_mode = os.environ.get("UW_MODE", "mock")
        environment = os.environ.get("ENVIRONMENT", "development")

        # Then: ê¸°ë³¸ê°’ ì‚¬ìš©
        assert uw_mode == "mock"  # genai_client.pyì˜ ê¸°ë³¸ê°’
        assert environment == "development"

    # =========================================================================
    # 3. ê²½ê³„ê°’ í…ŒìŠ¤íŠ¸ (Boundary Conditions)
    # =========================================================================

    def test_override_false_preserves_existing_env(
        self, temp_env_file: Path, clean_env: None
    ) -> None:
        """[Boundary] override=False: ê¸°ì¡´ í™˜ê²½ë³€ìˆ˜ê°€ ìˆìœ¼ë©´ ë®ì–´ì“°ì§€ ì•ŠìŠµë‹ˆë‹¤."""
        # Given: í™˜ê²½ë³€ìˆ˜ê°€ ì´ë¯¸ ì„¤ì •ë¨
        os.environ["UW_MODE"] = "mock"
        os.environ["ENVIRONMENT"] = "production"

        # When: load_dotenv(override=False) í˜¸ì¶œ
        load_dotenv(dotenv_path=temp_env_file, override=False)

        # Then: ê¸°ì¡´ ê°’ ìœ ì§€ (ë®ì–´ì“°ì§€ ì•ŠìŒ)
        assert os.environ.get("UW_MODE") == "mock"  # .envì˜ "real"ë¡œ ë³€ê²½ë˜ì§€ ì•ŠìŒ
        assert os.environ.get("ENVIRONMENT") == "production"

    def test_override_true_overwrites_existing_env(
        self, temp_env_file: Path, clean_env: None
    ) -> None:
        """[Boundary] override=True: ê¸°ì¡´ í™˜ê²½ë³€ìˆ˜ë¥¼ ë®ì–´ì”ë‹ˆë‹¤ (ì°¸ì¡°ìš©, í”„ë¡œë•ì…˜ì—ì„œëŠ” ì‚¬ìš© ê¸ˆì§€)."""
        # Given: í™˜ê²½ë³€ìˆ˜ê°€ ì´ë¯¸ ì„¤ì •ë¨
        os.environ["UW_MODE"] = "mock"

        # When: load_dotenv(override=True) í˜¸ì¶œ - ì£¼ì˜: í”„ë¡œë•ì…˜ì—ì„œëŠ” ê¸ˆì§€
        load_dotenv(dotenv_path=temp_env_file, override=True)

        # Then: ìƒˆ ê°’ìœ¼ë¡œ ë®ì–´ì”€
        assert os.environ.get("UW_MODE") == "real"

    def test_empty_env_file_no_error(self, tmp_path: Path, clean_env: None) -> None:
        """[Boundary] ë¹ˆ .env íŒŒì¼ë„ ì—ëŸ¬ ì—†ì´ ì²˜ë¦¬ë©ë‹ˆë‹¤."""
        # Given: ë¹ˆ .env íŒŒì¼
        empty_env = tmp_path / ".env"
        empty_env.write_text("")

        # When: load_dotenv í˜¸ì¶œ
        # Note: python-dotenvëŠ” ë¹ˆ íŒŒì¼ì—ì„œë„ ì—ëŸ¬ë¥¼ ë°œìƒì‹œí‚¤ì§€ ì•ŠìŒ
        # ë°˜í™˜ê°’ì€ íŒŒì¼ ì¡´ì¬ ì—¬ë¶€ë³´ë‹¤ëŠ” "ë³€ìˆ˜ê°€ ë¡œë“œë˜ì—ˆëŠ”ì§€"ë¥¼ ë‚˜íƒ€ë‚¼ ìˆ˜ ìˆìŒ
        try:
            result = load_dotenv(dotenv_path=empty_env, override=False)
            # Then: ì—ëŸ¬ ì—†ì´ ì™„ë£Œë¨ (ë°˜í™˜ê°’ì€ êµ¬í˜„ì— ë”°ë¼ ë‹¤ë¦„)
            assert isinstance(result, bool)
        except Exception as e:
            pytest.fail(f"ë¹ˆ .env íŒŒì¼ ì²˜ë¦¬ ì¤‘ ì˜ˆì™¸ ë°œìƒ: {e}")

    def test_env_with_comments_and_whitespace(self, tmp_path: Path, clean_env: None) -> None:
        """[Boundary] ì£¼ì„ê³¼ ê³µë°±ì´ ìˆëŠ” .env íŒŒì¼ì„ ì˜¬ë°”ë¥´ê²Œ íŒŒì‹±í•©ë‹ˆë‹¤."""
        # Given: ì£¼ì„ê³¼ ê³µë°±ì´ ìˆëŠ” .env íŒŒì¼
        env_file = tmp_path / ".env"
        env_file.write_text(
            "# This is a comment\n\nUW_MODE=real\n  \n# Another comment\nENVIRONMENT=staging\n"
        )

        # When: load_dotenv í˜¸ì¶œ
        load_dotenv(dotenv_path=env_file, override=False)

        # Then: ì£¼ì„/ê³µë°± ë¬´ì‹œ, ê°’ë§Œ ë¡œë“œ
        assert os.environ.get("UW_MODE") == "real"
        assert os.environ.get("ENVIRONMENT") == "staging"

    # =========================================================================
    # 4. ë³´ì•ˆ í…ŒìŠ¤íŠ¸ (Security) - RULE-007
    # =========================================================================

    def test_sensitive_info_not_in_logs(
        self, temp_env_file: Path, clean_env: None, caplog: pytest.LogCaptureFixture
    ) -> None:
        """[Security] ë¯¼ê° ì •ë³´(í‚¤/í† í°/ê²½ë¡œ)ê°€ ë¡œê·¸ì— ë…¸ì¶œë˜ì§€ ì•ŠìŠµë‹ˆë‹¤.

        ì´ í…ŒìŠ¤íŠ¸ëŠ” main.pyì˜ ë¡œê¹… ì •ì±…(RULE-007)ì„ ê²€ì¦í•©ë‹ˆë‹¤:
        - ë¯¼ê° ì •ë³´(í‚¤/í† í°/ê²½ë¡œ)ëŠ” ë¡œê·¸ì— ì¶œë ¥í•˜ì§€ ì•ŠìŒ
        - ëª¨ë“œ/í™˜ê²½ ì •ë³´ ì •ë„ë§Œ ë¡œê¹…
        """
        # Given: .envì— ë¯¼ê° ì •ë³´ í¬í•¨
        load_dotenv(dotenv_path=temp_env_file, override=False)

        # When: main.pyì˜ ë¡œê¹… ë¡œì§ì„ ì‹œë®¬ë ˆì´ì…˜
        with caplog.at_level(logging.INFO):
            # ë¡œê·¸ ì¶œë ¥ ì‹œë®¬ë ˆì´ì…˜ (main.py ìŠ¤íƒ€ì¼)
            uw_mode = os.environ.get("UW_MODE", "mock")
            environment = os.environ.get("ENVIRONMENT", "development")

            logger = logging.getLogger("test_security")
            # ì˜¬ë°”ë¥¸ ë°©ì‹: ë©”ì‹œì§€ì— ì•ˆì „í•œ ì •ë³´ë§Œ í¬í•¨
            logger.info(
                f"[Config] .env íŒŒì¼ ë¡œë“œ ì™„ë£Œ - UW_MODE={uw_mode}, ENVIRONMENT={environment}"
            )

        # Then: ë¯¼ê° ì •ë³´ê°€ ë¡œê·¸ì— ì—†ìŒ
        log_text = caplog.text

        # í‚¤ íŒŒì¼ ê²½ë¡œê°€ ì—†ì–´ì•¼ í•¨ (RULE-007 ìœ„ë°˜ ì‹œ ì‹¤íŒ¨)
        assert "test-key.key" not in log_text, "ë¯¼ê° ì •ë³´(í‚¤ íŒŒì¼ ê²½ë¡œ)ê°€ ë¡œê·¸ì— ë…¸ì¶œë¨"
        assert "GOOGLE_APPLICATION_CREDENTIALS" not in log_text, (
            "ë¯¼ê° ì •ë³´(í™˜ê²½ë³€ìˆ˜ëª…)ê°€ ë¡œê·¸ì— ë…¸ì¶œë¨"
        )

        # í—ˆìš©ëœ ì •ë³´ëŠ” ë¡œê·¸ì— ìˆì–´ì•¼ í•¨ (ì˜¬ë°”ë¥¸ ë¡œê¹… í™•ì¸)
        assert "UW_MODE" in log_text, "ëª¨ë“œ ì •ë³´ê°€ ë¡œê·¸ì— ìˆì–´ì•¼ í•¨"
        assert "ENVIRONMENT" in log_text or "development" in log_text, (
            "í™˜ê²½ ì •ë³´ê°€ ë¡œê·¸ì— ìˆì–´ì•¼ í•¨"
        )


class TestMainModuleDotenvIntegration:
    """main.py ëª¨ë“ˆì˜ dotenv í†µí•© í…ŒìŠ¤íŠ¸."""

    @pytest.fixture
    def clean_env(self) -> Generator[None]:
        """í…ŒìŠ¤íŠ¸ ì „ ê´€ë ¨ í™˜ê²½ë³€ìˆ˜ë¥¼ ì •ë¦¬í•©ë‹ˆë‹¤."""
        original_values: dict[str, str | None] = {}
        keys_to_clean = ["UW_MODE", "ENVIRONMENT"]

        for key in keys_to_clean:
            original_values[key] = os.environ.pop(key, None)

        yield

        for key, value in original_values.items():
            if value is not None:
                os.environ[key] = value
            elif key in os.environ:
                del os.environ[key]

    def test_main_module_dotenv_path_calculation(self) -> None:
        """[Integration] main.pyì˜ .env ê²½ë¡œ ê³„ì‚°ì´ ì˜¬ë°”ë¦…ë‹ˆë‹¤."""
        # Given: main.pyì˜ ê²½ë¡œ ê³„ì‚° ë¡œì§ ì¬í˜„
        # main.py ìœ„ì¹˜: backend/src/unknown_world/main.py
        # .env ìœ„ì¹˜: backend/.env
        # ë”°ë¼ì„œ: main.py -> parent(unknown_world) -> parent(src) -> parent(backend) -> .env

        # ì‹¤ì œ main.py ê²½ë¡œ ê¸°ì¤€ìœ¼ë¡œ ê³„ì‚°
        main_py_path = Path(__file__).parent.parent.parent / "src" / "unknown_world" / "main.py"
        expected_dotenv_path = main_py_path.parent.parent.parent.parent / ".env"

        # When: ê³„ì‚°ëœ ê²½ë¡œ í™•ì¸
        actual_backend_dir = expected_dotenv_path.parent

        # Then: backend ë””ë ‰í† ë¦¬ë¥¼ ê°€ë¦¬í‚´
        assert actual_backend_dir.name == "backend" or ".env" in str(expected_dotenv_path)

    def test_load_dotenv_returns_boolean(self) -> None:
        """[Integration] load_dotenvëŠ” booleanì„ ë°˜í™˜í•˜ì—¬ ë¡œë”© ìƒíƒœë¥¼ ì•Œ ìˆ˜ ìˆìŠµë‹ˆë‹¤."""
        # Given: ì„ì‹œ íŒŒì¼
        with tempfile.NamedTemporaryFile(mode="w", suffix=".env", delete=False) as f:
            f.write("TEST_VAR=test_value\n")
            temp_path = Path(f.name)

        try:
            # When: load_dotenv í˜¸ì¶œ
            result = load_dotenv(dotenv_path=temp_path, override=False)

            # Then: boolean ë°˜í™˜
            assert isinstance(result, bool)
            assert result is True
        finally:
            temp_path.unlink()


class TestDotenvPolicyCompliance:
    """dotenv ì •ì±… ì¤€ìˆ˜ í…ŒìŠ¤íŠ¸."""

    def test_policy_local_development_autoload(self) -> None:
        """[Policy] ë¡œì»¬ ê°œë°œì—ì„œ .env ìë™ ë¡œë”© ì •ì±…ì´ ì¤€ìˆ˜ë©ë‹ˆë‹¤.

        U-047 ì™„ë£Œ ê¸°ì¤€:
        - ë¡œì»¬ì—ì„œ `cd backend && cp .env.example .env` í›„
          `uv run uvicorn unknown_world.main:app ...` ì‹¤í–‰ ì‹œ
          .envê°€ ìë™ ë¡œë”©ëœë‹¤(ì¶”ê°€ export ë¶ˆí•„ìš”).
        """
        # Given: python-dotenvê°€ ì„¤ì¹˜ë˜ì–´ ìˆìŒ (pyproject.tomlì— ëª…ì‹œ)
        # When: load_dotenv í•¨ìˆ˜ê°€ ì‚¬ìš© ê°€ëŠ¥í•œì§€ í™•ì¸
        from dotenv import load_dotenv

        # Then: í•¨ìˆ˜ê°€ ì¡´ì¬í•˜ê³  í˜¸ì¶œ ê°€ëŠ¥
        assert callable(load_dotenv)

    def test_policy_override_false_for_production_safety(self) -> None:
        """[Policy] override=False ì •ì±…ìœ¼ë¡œ ìš´ì˜ í™˜ê²½ SSOTê°€ ë³´ì¥ë©ë‹ˆë‹¤.

        U-047 ì •ì±…:
        - ìš´ì˜(Cloud Run ë“±)ì€ ëŸ°íƒ€ì„ envë¥¼ SSOTë¡œ ì‚¬ìš©(override ê¸ˆì§€)
        """
        # Given: ìš´ì˜ í™˜ê²½ì—ì„œ í™˜ê²½ë³€ìˆ˜ê°€ ì´ë¯¸ ì„¤ì •ë¨
        os.environ["POLICY_TEST_VAR"] = "production_value"

        with tempfile.NamedTemporaryFile(mode="w", suffix=".env", delete=False) as f:
            f.write("POLICY_TEST_VAR=dev_value\n")
            temp_path = Path(f.name)

        try:
            # When: override=Falseë¡œ ë¡œë“œ
            load_dotenv(dotenv_path=temp_path, override=False)

            # Then: ê¸°ì¡´ ê°’ ìœ ì§€ (ìš´ì˜ SSOT ë³´ì¥)
            assert os.environ.get("POLICY_TEST_VAR") == "production_value"
        finally:
            temp_path.unlink()
            del os.environ["POLICY_TEST_VAR"]

    def test_policy_no_crash_without_env_file(self) -> None:
        """[Policy] .env íŒŒì¼ ë¯¸ì¡´ì¬ ì‹œ ì„œë²„ê°€ ì •ìƒ ì‹œì‘í•©ë‹ˆë‹¤.

        U-047 ì™„ë£Œ ê¸°ì¤€:
        - .envëŠ” ì¡´ì¬í•˜ì§€ ì•Šì•„ë„ ì„œë²„ê°€ ì •ìƒì ìœ¼ë¡œ ì‹œì‘í•œë‹¤
          (ìš´ì˜/CIì—ì„œ íŒŒì¼ ë¯¸ì¡´ì¬ë¥¼ ê¸°ë³¸ìœ¼ë¡œ í—ˆìš©)
        """
        # Given: ì¡´ì¬í•˜ì§€ ì•ŠëŠ” .env ê²½ë¡œ
        non_existent = Path("/definitely/not/a/real/path/.env")

        # When/Then: ì—ëŸ¬ ì—†ì´ False ë°˜í™˜
        try:
            result = load_dotenv(dotenv_path=non_existent, override=False)
            assert result is False  # íŒŒì¼ ì—†ìŒ
        except Exception as e:
            pytest.fail(f"load_dotenv raised an exception: {e}")
</file>

<file path="backend/tests/unit/test_u034_verification.py">
import json
from pathlib import Path

# í”„ë¡œì íŠ¸ ë£¨íŠ¸ ê²½ë¡œ ì„¤ì • (backend/tests/unit/ ìœ„ì¹˜ ê¸°ì¤€)
ROOT_DIR = Path(__file__).parent.parent.parent.parent
SCHEMA_PATH = ROOT_DIR / "vibe/ref/nanobanana-asset-request.schema.json"
GUIDE_PATH = ROOT_DIR / "vibe/ref/nanobanana-mcp.md"


def test_schema_file_exists():
    """ìŠ¤í‚¤ë§ˆ íŒŒì¼ì´ ì§€ì •ëœ ìœ„ì¹˜ì— ì¡´ì¬í•˜ëŠ”ì§€ í™•ì¸"""
    assert SCHEMA_PATH.exists(), f"Schema file not found at {SCHEMA_PATH}"


def test_schema_is_valid_json():
    """ìŠ¤í‚¤ë§ˆ íŒŒì¼ì´ ìœ íš¨í•œ JSON í˜•ì‹ì¸ì§€ í™•ì¸"""
    with open(SCHEMA_PATH, encoding="utf-8") as f:
        schema = json.load(f)
    assert schema["title"] == "nanobanana mcp Asset Request Schema"


def test_schema_required_properties():
    """ìŠ¤í‚¤ë§ˆì˜ JSON Schema required í•„ë“œê°€ ì •ì˜ë˜ì–´ ìˆëŠ”ì§€ í™•ì¸

    NOTE: JSON Schemaì˜ `required` ë°°ì—´ê³¼ "ì›Œí¬í”Œë¡œìš° í•„ìˆ˜(ì¡°ê±´ë¶€)" í•„ë“œëŠ” êµ¬ë¶„ë¨.
    - Schema required: ["id", "category", "purpose", "size_px"] (SSOT)
    - Workflow required: requires_rembg, rembg_options.model ë“±ì€ ì¡°ê±´ë¶€ í•„ë“œ
    """
    with open(SCHEMA_PATH, encoding="utf-8") as f:
        schema = json.load(f)

    properties = schema.get("properties", {})
    # JSON Schemaì˜ required í•„ë“œë§Œ ê²€ì¦ (ìŠ¤í‚¤ë§ˆ SSOT ê¸°ì¤€)
    schema_required_fields = ["id", "category", "purpose", "size_px"]
    # ì›Œí¬í”Œë¡œìš°ì—ì„œ ìì£¼ ì‚¬ìš©í•˜ëŠ” ì„ íƒì  í•„ë“œ (propertiesì— ì •ì˜ë˜ì–´ ìˆì–´ì•¼ í•¨)
    optional_workflow_fields = ["requires_rembg", "rembg_options"]

    for field in schema_required_fields:
        assert field in properties, f"Schema required field '{field}' missing in properties"

    for field in optional_workflow_fields:
        assert field in properties, f"Workflow field '{field}' missing in properties"


def test_schema_rembg_options_model():
    """rembg ëª¨ë¸ ì„ íƒì˜ SSOTê°€ rembg_options.modelì¸ì§€ í™•ì¸

    NOTE: ì´ì „ì— top-level rembg_model í•„ë“œê°€ ë…¼ì˜ë˜ì—ˆìœ¼ë‚˜,
    SSOTëŠ” rembg_options.modelë¡œ í™•ì •ë¨ (U-040 í˜ì–´ë§ ê²°ì •).
    """
    with open(SCHEMA_PATH, encoding="utf-8") as f:
        schema = json.load(f)

    # rembg_optionsê°€ ì¡´ì¬í•˜ê³  model ì„œë¸Œí•„ë“œê°€ ìˆì–´ì•¼ í•¨
    rembg_options = schema["properties"].get("rembg_options", {})
    assert rembg_options.get("type") == "object", "rembg_options should be an object"

    rembg_options_props = rembg_options.get("properties", {})
    assert "model" in rembg_options_props, (
        "SSOT field 'rembg_options.model' missing - "
        "rembg ëª¨ë¸ ì„ íƒì€ top-level 'rembg_model'ì´ ì•„ë‹Œ 'rembg_options.model'ì´ SSOTì…ë‹ˆë‹¤"
    )

    # model í•„ë“œì˜ enumì´ ìœ íš¨í•œ rembg ëª¨ë¸ ëª©ë¡ì„ í¬í•¨í•˜ëŠ”ì§€ í™•ì¸
    model_field = rembg_options_props["model"]
    assert "enum" in model_field, "rembg_options.model should have enum constraint"
    assert "birefnet-general" in model_field["enum"], (
        "Default model 'birefnet-general' should be in enum"
    )


def test_guide_file_exists():
    """ê°€ì´ë“œ ë¬¸ì„œ íŒŒì¼ì´ ì¡´ì¬í•˜ëŠ”ì§€ í™•ì¸"""
    assert GUIDE_PATH.exists(), f"Guide file not found at {GUIDE_PATH}"


def test_guide_content_completeness():
    """ê°€ì´ë“œ ë¬¸ì„œì— í•„ìˆ˜ ì„¹ì…˜(ì•„íŠ¸ ë””ë ‰ì…˜, ì¹´í…Œê³ ë¦¬ë³„ í…œí”Œë¦¿)ì´ í¬í•¨ë˜ì–´ ìˆëŠ”ì§€ í™•ì¸"""
    with open(GUIDE_PATH, encoding="utf-8") as f:
        content = f.read()

    # ê³„íšì„œ êµ¬í˜„ íë¦„ 2ë‹¨ê³„, 3ë‹¨ê³„ ê´€ë ¨ í‚¤ì›Œë“œ ê²€ì‚¬
    required_keywords = ["ì•„íŠ¸ ë””ë ‰ì…˜", "ìŠ¤íƒ€ì¼", "ì•„ì´ì½˜", "placeholder", "chrome", "í…œí”Œë¦¿"]

    missing_keywords = [kw for kw in required_keywords if kw.lower() not in content.lower()]

    # í˜„ì¬ nanobanana-mcp.mdì—ëŠ” rembg ë‚´ìš©ë§Œ ìˆìœ¼ë¯€ë¡œ ì‹¤íŒ¨í•  ê°€ëŠ¥ì„±ì´ í¼
    assert not missing_keywords, (
        f"Guide document is missing sections for: {', '.join(missing_keywords)}"
    )


def test_schema_rembg_rules():
    """ë°°ê²½ ì œê±°(rembg) ê´€ë ¨ ê°•ì œ ê·œì¹™(ìˆœë°± ë°°ê²½)ì´ ìŠ¤í‚¤ë§ˆ/ì„¤ëª…ì— í¬í•¨ë˜ì–´ ìˆëŠ”ì§€ í™•ì¸"""
    with open(SCHEMA_PATH, encoding="utf-8") as f:
        schema = json.load(f)

    # background í•„ë“œì™€ requires_rembg í•„ë“œ ì„¤ëª… í™•ì¸
    background_desc = schema["properties"]["background"].get("description", "")
    rembg_desc = schema["properties"]["requires_rembg"].get("description", "")

    assert "solid_white" in str(schema["properties"]["background"].get("enum", [])), (
        "background enum should include solid_white"
    )
    assert "rembg" in background_desc.lower(), "background description should mention rembg"
    assert "solid_white" in rembg_desc.lower(), (
        "requires_rembg description should recommend solid_white"
    )
</file>

<file path="backend/tests/unit/test_u043_language_gate.py">
"""U-043: ì–¸ì–´ í˜¼í•© ê²€ì¦ ë° Repair ë£¨í”„ ë‹¨ìœ„ í…ŒìŠ¤íŠ¸."""

from unittest.mock import AsyncMock, patch

import pytest

from unknown_world.models.turn import (
    ActionCard,
    ActionDeck,
    AgentConsole,
    ClientInfo,
    CurrencyAmount,
    EconomyOutput,
    EconomySnapshot,
    Language,
    RenderOutput,
    SafetyOutput,
    TurnInput,
    TurnOutput,
    UIOutput,
    ValidationBadge,
    WorldDelta,
)
from unknown_world.orchestrator.generate_turn_output import GenerationResult, GenerationStatus
from unknown_world.orchestrator.repair_loop import run_repair_loop
from unknown_world.validation.business_rules import BusinessRuleError, validate_business_rules
from unknown_world.validation.language_gate import (
    measure_language_ratio,
    validate_language_consistency,
)


@pytest.fixture
def sample_turn_input() -> TurnInput:
    return TurnInput(
        language=Language.KO,
        text="í…ŒìŠ¤íŠ¸ ì…ë ¥",
        client=ClientInfo(viewport_w=1920, viewport_h=1080),
        economy_snapshot=EconomySnapshot(signal=100, memory_shard=5),
    )


@pytest.fixture
def base_turn_output(sample_turn_input: TurnInput) -> TurnOutput:
    return TurnOutput(
        language=Language.KO,
        narrative="ì •ìƒì ì¸ í•œêµ­ì–´ ë‚´ëŸ¬í‹°ë¸Œì…ë‹ˆë‹¤.",
        ui=UIOutput(
            action_deck=ActionDeck(
                cards=[
                    ActionCard(
                        id="test",
                        label="í…ŒìŠ¤íŠ¸ ì¹´ë“œ",
                        cost=CurrencyAmount(signal=10, memory_shard=0),
                    )
                ]
            ),
            objects=[],
        ),
        world=WorldDelta(),
        render=RenderOutput(image_job=None),
        economy=EconomyOutput(
            cost=CurrencyAmount(signal=10, memory_shard=0),
            balance_after=CurrencyAmount(signal=90, memory_shard=5),
        ),
        safety=SafetyOutput(blocked=False),
        agent_console=AgentConsole(repair_count=0),
    )


def test_measure_language_ratio_ko():
    """í•œêµ­ì–´ í…ìŠ¤íŠ¸ì˜ ì–¸ì–´ ë¹„ìœ¨ ì¸¡ì • í…ŒìŠ¤íŠ¸."""
    text = "ì•ˆë…•í•˜ì„¸ìš”. ì´ê²ƒì€ í…ŒìŠ¤íŠ¸ì…ë‹ˆë‹¤."
    ratio = measure_language_ratio(text)
    assert ratio.hangul_ratio > 0.8
    assert ratio.latin_ratio < 0.2


def test_measure_language_ratio_en():
    """ì˜ì–´ í…ìŠ¤íŠ¸ì˜ ì–¸ì–´ ë¹„ìœ¨ ì¸¡ì • í…ŒìŠ¤íŠ¸."""
    text = "Hello. This is a test."
    ratio = measure_language_ratio(text)
    assert ratio.latin_ratio > 0.8
    assert ratio.hangul_ratio == 0.0


def test_measure_language_ratio_mixed():
    """í˜¼í•©ëœ í…ìŠ¤íŠ¸ì˜ ì–¸ì–´ ë¹„ìœ¨ ì¸¡ì • í…ŒìŠ¤íŠ¸."""
    text = "ì•ˆë…•í•˜ì„¸ìš”. This is a mixed text."
    ratio = measure_language_ratio(text)
    assert ratio.hangul_count > 0
    assert ratio.latin_count > 0


def test_measure_language_ratio_whitelist():
    """í™”ì´íŠ¸ë¦¬ìŠ¤íŠ¸ ë‹¨ì–´ê°€ ë¹„ìœ¨ ì¸¡ì •ì—ì„œ ì œì™¸ë˜ëŠ”ì§€ í…ŒìŠ¤íŠ¸."""
    # "Signal"ì€ í™”ì´íŠ¸ë¦¬ìŠ¤íŠ¸ì— ìˆìœ¼ë¯€ë¡œ ë¼í‹´ ì¹´ìš´íŠ¸ì—ì„œ ì œì™¸ë˜ì–´ì•¼ í•¨
    text = "Signalì´ ê°ì§€ë˜ì—ˆìŠµë‹ˆë‹¤."
    ratio = measure_language_ratio(text)
    # "ì´ ê°ì§€ë˜ì—ˆìŠµë‹ˆë‹¤" (í•œê¸€ 7ì + ê³µë°± 1ì) -> í•œê¸€ 7
    # "signal" ì œê±°ë¨. "i" ë‚¨ìŒ?
    # re.sub(rf"(?<![a-zA-Z]){re.escape(term)}(?![a-zA-Z])", "", ...)
    # "signal" -> ""
    # "ì´ ê°ì§€ë˜ì—ˆìŠµë‹ˆë‹¤." ë§Œ ë‚¨ìŒ
    assert ratio.latin_count == 0
    assert ratio.hangul_count > 0


def test_validate_language_consistency_mixed_ko(base_turn_output):
    """í•œêµ­ì–´ ìš”ì²­ì— ì˜ì–´ê°€ ì„ì¸ ê²½ìš° ê²€ì¦ í…ŒìŠ¤íŠ¸."""
    # 1. narrative
    mixed_output = base_turn_output.model_copy(deep=True)
    mixed_output.narrative = "ì´ê²ƒì€ í•œêµ­ì–´ì¸ë° Suddenly English appeared."
    result = validate_language_consistency(mixed_output, Language.KO)
    assert result.is_valid is False
    assert any(v["field"] == "narrative" for v in result.violations)

    # 2. action_deck.cards[0].label
    mixed_output = base_turn_output.model_copy(deep=True)
    mixed_output.ui.action_deck.cards[0].label = "Mixed Label ì˜ì–´"
    result = validate_language_consistency(mixed_output, Language.KO)
    assert result.is_valid is False
    assert any(v["field"] == "ui.action_deck.cards[0].label" for v in result.violations)

    # 3. safety.message
    mixed_output = base_turn_output.model_copy(deep=True)
    mixed_output.safety.message = "This is a blocked message in English."
    result = validate_language_consistency(mixed_output, Language.KO)
    assert result.is_valid is False
    assert any(v["field"] == "safety.message" for v in result.violations)


def test_validate_language_consistency_en_with_ko(base_turn_output):
    """ì˜ì–´ ìš”ì²­ì— í•œêµ­ì–´ê°€ ì„ì¸ ê²½ìš° ê²€ì¦ í…ŒìŠ¤íŠ¸."""
    en_input_lang = Language.EN
    en_output = base_turn_output.model_copy(deep=True)
    en_output.language = Language.EN
    en_output.narrative = "This is English but í•œêµ­ì–´ê°€ ì„ì„."

    result = validate_language_consistency(en_output, en_input_lang)
    assert result.is_valid is False
    assert any(v["field"] == "narrative" for v in result.violations)


def test_build_language_error_summary_ko(base_turn_output):
    """í•œêµ­ì–´ ì—ëŸ¬ ìš”ì•½ ìƒì„± í…ŒìŠ¤íŠ¸."""
    from unknown_world.validation.language_gate import build_language_error_summary

    mixed_output = base_turn_output.model_copy(deep=True)
    mixed_output.narrative = "Mixed English."
    result = validate_language_consistency(mixed_output, Language.KO)

    summary = build_language_error_summary(result)
    assert "ì–¸ì–´ í˜¼í•©ì´ ê°ì§€ë˜ì—ˆìŠµë‹ˆë‹¤" in summary
    assert "narrative" in summary
    assert "í•œêµ­ì–´(ko-KR)ë¡œ ë‹¤ì‹œ ì‘ì„±í•˜ì„¸ìš”" in summary


def test_validate_business_rules_language_content_mixed(sample_turn_input, base_turn_output):
    """ë¹„ì¦ˆë‹ˆìŠ¤ ë£° ê²€ì¦ì—ì„œ ì–¸ì–´ í˜¼í•© ê°ì§€ í…ŒìŠ¤íŠ¸."""
    mixed_output = base_turn_output.model_copy(deep=True)
    mixed_output.narrative = "í•œêµ­ì–´ì™€ Englishê°€ ì„ì—¬ ìˆìŠµë‹ˆë‹¤. This should fail."

    result = validate_business_rules(sample_turn_input, mixed_output)
    assert result.is_valid is False
    assert any(err["type"] == BusinessRuleError.LANGUAGE_CONTENT_MIXED for err in result.errors)


@pytest.mark.asyncio
async def test_repair_loop_fixes_language_mixing(sample_turn_input, base_turn_output):
    """ì–¸ì–´ í˜¼í•© ì‹œ Repair ë£¨í”„ê°€ ì‘ë™í•˜ì—¬ ìˆ˜ì •ë˜ëŠ”ì§€ í…ŒìŠ¤íŠ¸."""
    mixed_output = base_turn_output.model_copy(deep=True)
    mixed_output.narrative = "í˜¼í•©ëœ ì–¸ì–´ English Mixed."

    valid_output = base_turn_output.model_copy(deep=True)
    valid_output.narrative = "ìˆ˜ì •ëœ í•œêµ­ì–´ ë‚´ëŸ¬í‹°ë¸Œ"

    with patch("unknown_world.orchestrator.repair_loop.get_turn_output_generator") as mock_get_gen:
        mock_gen = mock_get_gen.return_value
        # ì²« ë²ˆì§¸ëŠ” í˜¼í•© ì¶œë ¥, ë‘ ë²ˆì§¸ëŠ” ì •ìƒ ì¶œë ¥ ë°˜í™˜
        mock_gen.generate = AsyncMock(
            side_effect=[
                GenerationResult(status=GenerationStatus.SUCCESS, output=mixed_output),
                GenerationResult(status=GenerationStatus.SUCCESS, output=valid_output),
            ]
        )

        result = await run_repair_loop(sample_turn_input)

        assert result.repair_attempts == 1
        assert result.output.narrative == "ìˆ˜ì •ëœ í•œêµ­ì–´ ë‚´ëŸ¬í‹°ë¸Œ"
        assert ValidationBadge.CONSISTENCY_OK in result.badges
        assert ValidationBadge.CONSISTENCY_FAIL not in result.badges  # ìµœì¢… ë°°ì§€ëŠ” OKì—¬ì•¼ í•¨
</file>

<file path="backend/tests/unit/test_u068_reference_image.py">
"""U-068: ì´ì „ í„´ ì´ë¯¸ì§€ë¥¼ ì°¸ì¡°ì´ë¯¸ì§€ë¡œ ì‚¬ìš©í•˜ëŠ” ê¸°ëŠ¥ í…ŒìŠ¤íŠ¸."""

import pytest

from unknown_world.models.turn import ImageJob, ModelLabel
from unknown_world.services.image_generation import ImageGenerationRequest, MockImageGenerator


def test_image_job_reference_image_url_field():
    """ImageJob ëª¨ë¸ì— reference_image_url í•„ë“œê°€ ìˆëŠ”ì§€ í™•ì¸í•©ë‹ˆë‹¤."""
    job = ImageJob(
        should_generate=True,
        prompt="A mysterious forest",
        model_label=ModelLabel.QUALITY,
        reference_image_url="http://example.com/prev.png",  # ì´ ë¶€ë¶„ì´ ì‹¤íŒ¨í•´ì•¼ í•¨
    )
    assert job.reference_image_url == "http://example.com/prev.png"


@pytest.mark.asyncio
async def test_mock_generator_handles_reference_image_url():
    """MockImageGeneratorê°€ reference_image_urlì´ í¬í•¨ëœ ìš”ì²­ì„ ì²˜ë¦¬í•˜ëŠ”ì§€ í™•ì¸í•©ë‹ˆë‹¤."""
    generator = MockImageGenerator()
    request = ImageGenerationRequest(
        prompt="A mysterious forest", reference_image_url="http://example.com/prev.png"
    )

    # MockImageGenerator.generateëŠ” í˜„ì¬ reference_image_urlì„ ë¬´ì‹œí•˜ì§€ë§Œ ì—ëŸ¬ëŠ” ë‚˜ì§€ ì•Šì•„ì•¼ í•¨
    response = await generator.generate(request)
    assert response.status.value == "completed"
    assert response.image_url is not None
</file>

<file path="backend/tests/unit/test_u079_economy_low_balance.py">
"""U-079[Mvp]: ì¬í™” ë¶€ì¡± ì‹œ ì´ë¯¸ì§€ ìƒì„± í—ˆìš© ë° í•„ë“œ ê²€ì¦ í…ŒìŠ¤íŠ¸."""

import pytest

from unknown_world.models.turn import (
    AgentConsole,
    AgentPhase,
    ClientInfo,
    CurrencyAmount,
    EconomyOutput,
    EconomySnapshot,
    ImageJob,
    Language,
    RenderOutput,
    SafetyOutput,
    TurnInput,
    TurnOutput,
)
from unknown_world.orchestrator.stages.render import render_stage
from unknown_world.orchestrator.stages.types import PipelineContext
from unknown_world.services.image_generation import MockImageGenerator

# =============================================================================
# í•„ë“œ ì¶”ê°€ ê²€ì¦ (Red Phase)
# =============================================================================


def test_economy_output_has_u079_fields():
    """EconomyOutputì— creditê³¼ low_balance_warning í•„ë“œê°€ ìˆëŠ”ì§€ í™•ì¸."""
    data = {
        "cost": {"signal": 10, "memory_shard": 0},
        "balance_after": {"signal": 0, "memory_shard": 5},
        "credit": 5,
        "low_balance_warning": True,
    }
    # ì´ í…ŒìŠ¤íŠ¸ëŠ” ëª¨ë¸ ìˆ˜ì • ì „ì—ëŠ” ì‹¤íŒ¨í•´ì•¼ í•¨ (extra="forbid" ë•Œë¬¸ì´ê±°ë‚˜ í•„ë“œ ëˆ„ë½)
    economy = EconomyOutput(**data)
    assert economy.credit == 5
    assert economy.low_balance_warning is True


# =============================================================================
# Render Stage FAST í´ë°± ë¹„ìš© ì—…ë°ì´íŠ¸ ê²€ì¦
# =============================================================================


@pytest.mark.asyncio
async def test_render_stage_updates_cost_on_low_balance():
    """ì”ì•¡ ë¶€ì¡±ìœ¼ë¡œ FAST í´ë°± ì‹œ TurnOutputì˜ ë¹„ìš©ì´ 0ìœ¼ë¡œ ì—…ë°ì´íŠ¸ë˜ëŠ”ì§€ í™•ì¸."""
    # 1. Given: ì”ì•¡ ë¶€ì¡± ìƒí™© (Signal 5, í•„ìš” 10)
    economy_snapshot = CurrencyAmount(signal=5, memory_shard=0)

    turn_input = TurnInput(
        language=Language.KO,
        text="ë°©ì„ ì¡°ì‚¬í•œë‹¤",
        client=ClientInfo(viewport_w=1920, viewport_h=1080),
        economy_snapshot=EconomySnapshot(signal=5, memory_shard=0),
    )

    # AIê°€ ì´ë¯¸ì§€ ìƒì„±ì„ ì›í•œë‹¤ê³  ê°€ì • (QUALITY ëª¨ë¸, ë¹„ìš© 10)
    original_economy = EconomyOutput(
        cost=CurrencyAmount(signal=10, memory_shard=0),
        balance_after=CurrencyAmount(signal=0, memory_shard=0),  # LLMì€ ëŒ€ì¶© 0ìœ¼ë¡œ ì¤„ ìˆ˜ ìˆìŒ
    )

    turn_output = TurnOutput(
        language=Language.KO,
        narrative="ë¬´ì–¸ê°€ ë³´ì…ë‹ˆë‹¤.",
        economy=original_economy,
        safety=SafetyOutput(blocked=False),
        render=RenderOutput(
            image_job=ImageJob(should_generate=True, prompt="A dark room", model_label="QUALITY")
        ),
        agent_console=AgentConsole(current_phase=AgentPhase.RENDER),
    )

    ctx = PipelineContext(
        turn_input=turn_input,
        economy_snapshot=economy_snapshot,
        is_mock=True,
        output=turn_output,
        image_generator=MockImageGenerator(),
    )

    # 2. When: render_stage ì‹¤í–‰
    async def mock_emit(event):
        pass

    updated_ctx = await render_stage(ctx, emit=mock_emit)

    # 3. Then: ë¹„ìš©ì´ FAST_IMAGE_COST_SIGNAL(0)ë¡œ ì—…ë°ì´íŠ¸ë˜ì—ˆëŠ”ì§€ í™•ì¸
    # (ì´ ë¡œì§ì€ ì•„ì§ êµ¬í˜„ë˜ì§€ ì•Šì•˜ìœ¼ë¯€ë¡œ ì‹¤íŒ¨í•´ì•¼ í•¨)
    assert updated_ctx.output.economy.cost.signal == 0
    # balance_afterë„ ìŠ¤ëƒ…ìƒ· ìœ ì§€ (5 - 0 = 5)
    assert updated_ctx.output.economy.balance_after.signal == 5
    # low_balance_warningì´ ì„¤ì •ë˜ì—ˆëŠ”ì§€ í™•ì¸
    assert updated_ctx.output.economy.low_balance_warning is True


# =============================================================================
# í¬ë ˆë”§(ë¹š) ì‹œìŠ¤í…œ ê²€ì¦
# =============================================================================


def test_economy_validation_allows_credit():
    """ì”ì•¡ë³´ë‹¤ í° ë¹„ìš© ì§€ë¶ˆ ì‹œ í¬ë ˆë”§ì´ ì˜¬ë°”ë¥´ê²Œ ê²€ì¦ë˜ëŠ”ì§€ í™•ì¸."""
    from unknown_world.validation.business_rules import validate_business_rules

    # 1. Given: ì”ì•¡ 5, ë¹„ìš© 10 (í¬ë ˆë”§ 5 í•„ìš”)
    turn_input = TurnInput(
        language=Language.KO,
        text="í…ŒìŠ¤íŠ¸",
        client=ClientInfo(viewport_w=1920, viewport_h=1080),
        economy_snapshot=EconomySnapshot(signal=5, memory_shard=0),
    )

    turn_output = TurnOutput(
        language=Language.KO,
        narrative="ê²°ê³¼",
        economy=EconomyOutput(
            cost=CurrencyAmount(signal=10, memory_shard=0),
            balance_after=CurrencyAmount(signal=0, memory_shard=0),
            credit=5,  # ë¹š 5
            low_balance_warning=True,
        ),
        safety=SafetyOutput(blocked=False),
    )

    # 2. When: ë¹„ì¦ˆë‹ˆìŠ¤ ë£° ê²€ì¦
    result = validate_business_rules(turn_input, turn_output)

    # 3. Then: ê²€ì¦ í†µê³¼
    assert result.is_valid is True
    assert not result.errors


def test_economy_validation_fails_on_excessive_credit():
    """MAX_CREDIT(50)ì„ ì´ˆê³¼í•˜ëŠ” ë¹„ìš©ì€ ê±°ë¶€ë˜ì–´ì•¼ í•¨."""
    from unknown_world.validation.business_rules import validate_business_rules

    # 1. Given: ì”ì•¡ 5, ë¹„ìš© 60 (í¬ë ˆë”§ 55 í•„ìš”, í•œë„ 50 ì´ˆê³¼)
    turn_input = TurnInput(
        language=Language.KO,
        text="í…ŒìŠ¤íŠ¸",
        client=ClientInfo(viewport_w=1920, viewport_h=1080),
        economy_snapshot=EconomySnapshot(signal=5, memory_shard=0),
    )

    turn_output = TurnOutput(
        language=Language.KO,
        narrative="ê²°ê³¼",
        economy=EconomyOutput(
            cost=CurrencyAmount(signal=60, memory_shard=0),
            balance_after=CurrencyAmount(signal=0, memory_shard=0),
            credit=55,
            low_balance_warning=True,
        ),
        safety=SafetyOutput(blocked=False),
    )

    # 2. When: ë¹„ì¦ˆë‹ˆìŠ¤ ë£° ê²€ì¦
    result = validate_business_rules(turn_input, turn_output)

    # 3. Then: ê²€ì¦ ì‹¤íŒ¨
    assert result.is_valid is False
    assert any("economy_negative_balance" in err["type"] for err in result.errors)
</file>

<file path="backend/tests/unit/test_u096_consumption.py">
from unknown_world.models.turn import TurnOutput, WorldDelta


def test_world_delta_inventory_removed_serialization():
    """WorldDeltaì˜ inventory_removed í•„ë“œ ì§ë ¬í™”/ì—­ì§ë ¬í™” í…ŒìŠ¤íŠ¸ (U-096)."""
    delta_data = {
        "inventory_added": [],
        "inventory_removed": ["key_01", "potion_02"],
        "rules_changed": [],
        "quests_updated": [],
        "relationships_changed": [],
        "memory_pins": [],
    }
    delta = WorldDelta(**delta_data)

    assert delta.inventory_removed == ["key_01", "potion_02"]

    # JSON ì§ë ¬í™” í™•ì¸
    json_data = delta.model_dump()
    assert json_data["inventory_removed"] == ["key_01", "potion_02"]


def test_turn_output_with_consumption():
    """ì•„ì´í…œ ì†Œë¹„ê°€ í¬í•¨ëœ ì „ì²´ TurnOutput ìŠ¤í‚¤ë§ˆ ê²€ì¦."""
    output_data = {
        "language": "ko-KR",
        "narrative": "ì—´ì‡ ë¥¼ ì‚¬ìš©í–ˆìŠµë‹ˆë‹¤. ì—´ì‡ ê°€ ì‚¬ë¼ì¡ŒìŠµë‹ˆë‹¤.",
        "economy": {
            "cost": {"signal": 5, "memory_shard": 0},
            "balance_after": {"signal": 95, "memory_shard": 5},
        },
        "safety": {"blocked": False, "message": None},
        "ui": {"action_deck": {"cards": []}, "objects": []},
        "world": {
            "inventory_added": [],
            "inventory_removed": ["iron_key_01"],
            "rules_changed": [],
            "quests_updated": [],
            "relationships_changed": [],
            "memory_pins": [],
        },
        "render": {"image_job": None},
        "agent_console": {
            "current_phase": "commit",
            "badges": ["schema_ok"],
            "repair_count": 0,
            "model_label": "FAST",
        },
    }

    output = TurnOutput(**output_data)
    assert "iron_key_01" in output.world.inventory_removed
    assert output.narrative == "ì—´ì‡ ë¥¼ ì‚¬ìš©í–ˆìŠµë‹ˆë‹¤. ì—´ì‡ ê°€ ì‚¬ë¼ì¡ŒìŠµë‹ˆë‹¤."
</file>

<file path="frontend/public/ui/manifest.json">
{
  "$schema": "./manifest.schema.json",
  "version": "1.5.0",
  "generatedAt": "2026-02-07T21:00:00Z",
  "totalBytes": 775899,
  "budgetBytes": 1572864,
  "assets": [
    {
      "id": "signal-24",
      "path": "icons/signal-24.png",
      "type": "icon",
      "size": 24,
      "fallback": "âš¡",
      "usedIn": ["EconomyHUD"],
      "bytes": 1573,
      "notes": "U-038: v2 ì¬ìƒì„±, nanobanana mcp(í”½ì…€ì•„íŠ¸), rembg(birefnet-general), ImageMagick ìµœì í™”"
    },
    {
      "id": "signal-16",
      "path": "icons/signal-16.png",
      "type": "icon",
      "size": 16,
      "fallback": "âš¡",
      "usedIn": ["ActionDeck"],
      "bytes": 1012,
      "notes": "U-038: v2 ì¬ìƒì„±, nanobanana mcp(í”½ì…€ì•„íŠ¸), rembg(birefnet-general), ImageMagick ìµœì í™”"
    },
    {
      "id": "shard-24",
      "path": "icons/shard-24.png",
      "type": "icon",
      "size": 24,
      "fallback": "ğŸ’",
      "usedIn": ["EconomyHUD"],
      "bytes": 1362,
      "notes": "U-038: v2 ì¬ìƒì„±, nanobanana mcp(í”½ì…€ì•„íŠ¸), rembg(birefnet-general), ImageMagick ìµœì í™”"
    },
    {
      "id": "shard-16",
      "path": "icons/shard-16.png",
      "type": "icon",
      "size": 16,
      "fallback": "ğŸ’",
      "usedIn": ["ActionDeck"],
      "bytes": 1147,
      "notes": "U-038: shard-24ì—ì„œ ë¦¬ì‚¬ì´ì¦ˆ, 16px ìµœì í™”"
    },
    {
      "id": "badge-ok-24",
      "path": "icons/badge-ok-24.png",
      "type": "icon",
      "size": 24,
      "fallback": "âœ“",
      "usedIn": ["AgentConsole"],
      "bytes": 1461,
      "notes": "U-038: v2 ì¬ìƒì„±, nanobanana mcp(í”½ì…€ì•„íŠ¸), rembg(birefnet-general), ImageMagick ìµœì í™”"
    },
    {
      "id": "badge-ok-16",
      "path": "icons/badge-ok-16.png",
      "type": "icon",
      "size": 16,
      "fallback": "âœ“",
      "usedIn": [],
      "bytes": 1096,
      "notes": "U-038: v2 ì¬ìƒì„±, nanobanana mcp(í”½ì…€ì•„íŠ¸), rembg(birefnet-general), ImageMagick ìµœì í™”"
    },
    {
      "id": "badge-fail-24",
      "path": "icons/badge-fail-24.png",
      "type": "icon",
      "size": 24,
      "fallback": "âœ—",
      "usedIn": ["AgentConsole"],
      "bytes": 2006,
      "notes": "U-038: v2 ì¬ìƒì„±, nanobanana mcp(í”½ì…€ì•„íŠ¸), rembg(birefnet-general), ImageMagick ìµœì í™”"
    },
    {
      "id": "risk-medium-24",
      "path": "icons/risk-medium-24.png",
      "type": "icon",
      "size": 24,
      "fallback": "âš ",
      "usedIn": [],
      "bytes": 1594,
      "notes": "U-038: 24px í˜ì–´ ë³´ê°•, nanobanana mcp ìƒì„±"
    },
    {
      "id": "risk-medium-16",
      "path": "icons/risk-medium-16.png",
      "type": "icon",
      "size": 16,
      "fallback": "âš ",
      "usedIn": ["ActionDeck"],
      "bytes": 1256,
      "notes": "U-038: v2 ì¬ìƒì„±, nanobanana mcp(í”½ì…€ì•„íŠ¸), rembg(birefnet-general), ImageMagick ìµœì í™”"
    },
    {
      "id": "risk-low-24",
      "path": "icons/risk-low-24.png",
      "type": "icon",
      "size": 24,
      "fallback": "âœ“",
      "usedIn": [],
      "bytes": 1838,
      "notes": "U-038: v2 ì¬ìƒì„±, nanobanana mcp(í”½ì…€ì•„íŠ¸), rembg(birefnet-general), ImageMagick ìµœì í™”"
    },
    {
      "id": "risk-low-16",
      "path": "icons/risk-low-16.png",
      "type": "icon",
      "size": 16,
      "fallback": "âœ“",
      "usedIn": ["ActionDeck"],
      "bytes": 1331,
      "notes": "U-038: v2 ì¬ìƒì„±, nanobanana mcp(í”½ì…€ì•„íŠ¸), rembg(birefnet-general), ImageMagick ìµœì í™”"
    },
    {
      "id": "risk-high-24",
      "path": "icons/risk-high-24.png",
      "type": "icon",
      "size": 24,
      "fallback": "âš ",
      "usedIn": [],
      "bytes": 1737,
      "notes": "U-038: v2 ì¬ìƒì„±, nanobanana mcp(í”½ì…€ì•„íŠ¸), rembg(birefnet-general), ImageMagick ìµœì í™”"
    },
    {
      "id": "risk-high-16",
      "path": "icons/risk-high-16.png",
      "type": "icon",
      "size": 16,
      "fallback": "âš ",
      "usedIn": ["ActionDeck"],
      "bytes": 1227,
      "notes": "U-038: v2 ì¬ìƒì„±, nanobanana mcp(í”½ì…€ì•„íŠ¸), rembg(birefnet-general), ImageMagick ìµœì í™”"
    },
    {
      "id": "status-online-16",
      "path": "icons/status-online-16.png",
      "type": "icon",
      "size": 16,
      "fallback": "â—",
      "usedIn": [],
      "bytes": 1375,
      "notes": "U-038: v2 ì¬ìƒì„±, nanobanana mcp(í”½ì…€ì•„íŠ¸), rembg(birefnet-general), ImageMagick ìµœì í™”"
    },
    {
      "id": "scene-placeholder-default",
      "path": "placeholders/scene-placeholder-default.png",
      "type": "placeholder",
      "fallback": "[SCENE]",
      "usedIn": ["SceneCanvas"],
      "bytes": 261407,
      "notes": "nanobanana mcp ìƒì„±, ë ˆíŠ¸ë¡œ í„°ë¯¸ë„ ìŠ¤íƒ€ì¼"
    },
    {
      "id": "scene-loading",
      "path": "placeholders/scene-loading.webp",
      "type": "placeholder",
      "fallback": "â³",
      "usedIn": ["SceneCanvas"],
      "bytes": 47850,
      "notes": "U-031: ë¡œë”© ìƒíƒœ placeholder, nanobanana mcp ìƒì„±, ImageMagick(magick) ìµœì í™”"
    },
    {
      "id": "scene-offline",
      "path": "placeholders/scene-offline.webp",
      "type": "placeholder",
      "fallback": "ğŸ”Œ",
      "usedIn": ["SceneCanvas"],
      "bytes": 44658,
      "notes": "U-031: ì˜¤í”„ë¼ì¸ ìƒíƒœ placeholder, nanobanana mcp ìƒì„±, ImageMagick(magick) ìµœì í™”"
    },
    {
      "id": "scene-blocked",
      "path": "placeholders/scene-blocked.webp",
      "type": "placeholder",
      "fallback": "ğŸš«",
      "usedIn": ["SceneCanvas"],
      "bytes": 17318,
      "notes": "U-031: ì°¨ë‹¨ ìƒíƒœ placeholder, nanobanana mcp ìƒì„±, ImageMagick(magick) ìµœì í™”"
    },
    {
      "id": "scene-low-signal",
      "path": "placeholders/scene-low-signal.webp",
      "type": "placeholder",
      "fallback": "ğŸ“‰",
      "usedIn": ["SceneCanvas"],
      "bytes": 68454,
      "notes": "U-031: ì €ì‹ í˜¸ ìƒíƒœ placeholder, nanobanana mcp ìƒì„±, ImageMagick(magick) ìµœì í™”"
    },
    {
      "id": "panel-corner-br",
      "path": "chrome/panel-corner-br.png",
      "type": "chrome",
      "fallback": "",
      "usedIn": ["PanelHeader"],
      "bytes": 1899,
      "notes": "U-032: íŒ¨ë„ ì½”ë„ˆ ì¥ì‹, nanobanana mcp ìƒì„±, rembg ë°°ê²½ ì œê±°, ImageMagick ìµœì í™”(48x48), CSS transformìœ¼ë¡œ 4ë°©í–¥ ì ìš©"
    },
    {
      "id": "card-frame",
      "path": "chrome/card-frame.png",
      "type": "chrome",
      "fallback": "",
      "usedIn": ["ActionCard"],
      "bytes": 9101,
      "notes": "U-032: ì•¡ì…˜ ì¹´ë“œ í”„ë ˆì„, nanobanana mcp ìƒì„±, rembg ë°°ê²½ ì œê±°, ImageMagick ìµœì í™”(160x80)"
    },
    {
      "id": "scanner-frame",
      "path": "chrome/scanner-frame.png",
      "type": "chrome",
      "fallback": "",
      "usedIn": ["Scanner"],
      "bytes": 100165,
      "notes": "U-032: ìŠ¤ìºë„ˆ ìŠ¬ë¡¯ í”„ë ˆì„, nanobanana mcp ìƒì„±, rembg(birefnet-general) ë°°ê²½ ì œê±°, ImageMagick ìµœì í™”(346x200) ì™„ë£Œ"
    },
    {
      "id": "item-ancient-tome-64",
      "path": "items/ancient-tome-64.png",
      "type": "item-icon",
      "size": 64,
      "fallback": "ğŸ“•",
      "usedIn": ["InventoryPanel"],
      "bytes": 7166,
      "notes": "U-092: Narrator ì´ˆê¸° ì•„ì´í…œ, nanobanana mcp(pixel-art), rembg(birefnet-general), ImageMagick 64x64"
    },
    {
      "id": "item-quill-pen-64",
      "path": "items/quill-pen-64.png",
      "type": "item-icon",
      "size": 64,
      "fallback": "ğŸ–‹ï¸",
      "usedIn": ["InventoryPanel"],
      "bytes": 6474,
      "notes": "U-092: Narrator ì´ˆê¸° ì•„ì´í…œ, nanobanana mcp(pixel-art), rembg(birefnet-general), ImageMagick 64x64"
    },
    {
      "id": "item-memory-fragment-64",
      "path": "items/memory-fragment-64.png",
      "type": "item-icon",
      "size": 64,
      "fallback": "ğŸ’ ",
      "usedIn": ["InventoryPanel"],
      "bytes": 6977,
      "notes": "U-092: Narrator ì´ˆê¸° ì•„ì´í…œ, nanobanana mcp(pixel-art), rembg(birefnet-general), ImageMagick 64x64"
    },
    {
      "id": "item-compass-64",
      "path": "items/compass-64.png",
      "type": "item-icon",
      "size": 64,
      "fallback": "ğŸ§­",
      "usedIn": ["InventoryPanel"],
      "bytes": 9515,
      "notes": "U-092: Explorer ì´ˆê¸° ì•„ì´í…œ, nanobanana mcp(pixel-art), rembg(birefnet-general), ImageMagick 64x64"
    },
    {
      "id": "item-rope-64",
      "path": "items/rope-64.png",
      "type": "item-icon",
      "size": 64,
      "fallback": "ğŸª¢",
      "usedIn": ["InventoryPanel"],
      "bytes": 10713,
      "notes": "U-092: Explorer ì´ˆê¸° ì•„ì´í…œ, nanobanana mcp(pixel-art), rembg(birefnet-general), ImageMagick 64x64"
    },
    {
      "id": "item-lantern-64",
      "path": "items/lantern-64.png",
      "type": "item-icon",
      "size": 64,
      "fallback": "ğŸ®",
      "usedIn": ["InventoryPanel"],
      "bytes": 8054,
      "notes": "U-092: Explorer ì´ˆê¸° ì•„ì´í…œ, nanobanana mcp(pixel-art), rembg(birefnet-general), ImageMagick 64x64"
    },
    {
      "id": "item-map-fragment-64",
      "path": "items/map-fragment-64.png",
      "type": "item-icon",
      "size": 64,
      "fallback": "ğŸ—ºï¸",
      "usedIn": ["InventoryPanel"],
      "bytes": 9705,
      "notes": "U-092: Explorer ì´ˆê¸° ì•„ì´í…œ, nanobanana mcp(pixel-art), rembg(birefnet-general), ImageMagick 64x64"
    },
    {
      "id": "item-data-core-64",
      "path": "items/data-core-64.png",
      "type": "item-icon",
      "size": 64,
      "fallback": "ğŸ’¿",
      "usedIn": ["InventoryPanel"],
      "bytes": 10949,
      "notes": "U-092: Tech ì´ˆê¸° ì•„ì´í…œ, nanobanana mcp(pixel-art), rembg(birefnet-general), ImageMagick 64x64"
    },
    {
      "id": "item-circuit-board-64",
      "path": "items/circuit-board-64.png",
      "type": "item-icon",
      "size": 64,
      "fallback": "ğŸ”Œ",
      "usedIn": ["InventoryPanel"],
      "bytes": 8062,
      "notes": "U-092: Tech ì´ˆê¸° ì•„ì´í…œ, nanobanana mcp(pixel-art), rembg(birefnet-general), ImageMagick 64x64"
    },
    {
      "id": "item-energy-cell-64",
      "path": "items/energy-cell-64.png",
      "type": "item-icon",
      "size": 64,
      "fallback": "ğŸ”‹",
      "usedIn": ["InventoryPanel"],
      "bytes": 7394,
      "notes": "U-092: Tech ì´ˆê¸° ì•„ì´í…œ, nanobanana mcp(pixel-art), rembg(birefnet-general), ImageMagick 64x64"
    },
    {
      "id": "item-scanner-device-64",
      "path": "items/scanner-device-64.png",
      "type": "item-icon",
      "size": 64,
      "fallback": "ğŸ“¡",
      "usedIn": ["InventoryPanel"],
      "bytes": 4436,
      "notes": "U-092: Tech ì´ˆê¸° ì•„ì´í…œ, nanobanana mcp(pixel-art), rembg(birefnet-general), ImageMagick 64x64"
    },
    {
      "id": "item-sword-64",
      "path": "items/sword-64.png",
      "type": "item-icon",
      "size": 64,
      "fallback": "âš”ï¸",
      "usedIn": ["InventoryPanel"],
      "bytes": 5748,
      "notes": "U-092: ê³µí†µ ì•„ì´í…œ, nanobanana mcp(pixel-art), rembg(birefnet-general), ImageMagick 64x64"
    },
    {
      "id": "item-shield-64",
      "path": "items/shield-64.png",
      "type": "item-icon",
      "size": 64,
      "fallback": "ğŸ›¡ï¸",
      "usedIn": ["InventoryPanel"],
      "bytes": 10313,
      "notes": "U-092: ê³µí†µ ì•„ì´í…œ, nanobanana mcp(pixel-art), rembg(birefnet-general), ImageMagick 64x64"
    },
    {
      "id": "item-potion-64",
      "path": "items/potion-64.png",
      "type": "item-icon",
      "size": 64,
      "fallback": "ğŸ§ª",
      "usedIn": ["InventoryPanel"],
      "bytes": 6083,
      "notes": "U-092: ê³µí†µ ì•„ì´í…œ, nanobanana mcp(pixel-art), rembg(birefnet-general), ImageMagick 64x64"
    },
    {
      "id": "item-key-64",
      "path": "items/key-64.png",
      "type": "item-icon",
      "size": 64,
      "fallback": "ğŸ”‘",
      "usedIn": ["InventoryPanel"],
      "bytes": 8703,
      "notes": "U-092: ê³µí†µ ì•„ì´í…œ, nanobanana mcp(pixel-art), rembg(birefnet-general), ImageMagick 64x64"
    },
    {
      "id": "item-gem-64",
      "path": "items/gem-64.png",
      "type": "item-icon",
      "size": 64,
      "fallback": "ğŸ’",
      "usedIn": ["InventoryPanel"],
      "bytes": 6681,
      "notes": "U-092: ê³µí†µ ì•„ì´í…œ, nanobanana mcp(pixel-art), rembg(birefnet-general), ImageMagick 64x64"
    },
    {
      "id": "item-scroll-64",
      "path": "items/scroll-64.png",
      "type": "item-icon",
      "size": 64,
      "fallback": "ğŸ“œ",
      "usedIn": ["InventoryPanel"],
      "bytes": 9741,
      "notes": "U-092: ê³µí†µ ì•„ì´í…œ, nanobanana mcp(pixel-art), rembg(birefnet-general), ImageMagick 64x64"
    },
    {
      "id": "item-torch-64",
      "path": "items/torch-64.png",
      "type": "item-icon",
      "size": 64,
      "fallback": "ğŸ”¥",
      "usedIn": ["InventoryPanel"],
      "bytes": 5029,
      "notes": "U-092: ê³µí†µ ì•„ì´í…œ, nanobanana mcp(pixel-art), rembg(birefnet-general), ImageMagick 64x64"
    },
    {
      "id": "item-herb-64",
      "path": "items/herb-64.png",
      "type": "item-icon",
      "size": 64,
      "fallback": "ğŸŒ¿",
      "usedIn": ["InventoryPanel"],
      "bytes": 7688,
      "notes": "U-092: ê³µí†µ ì•„ì´í…œ, nanobanana mcp(pixel-art), rembg(birefnet-general), ImageMagick 64x64"
    },
    {
      "id": "item-coin-64",
      "path": "items/coin-64.png",
      "type": "item-icon",
      "size": 64,
      "fallback": "ğŸª™",
      "usedIn": ["InventoryPanel"],
      "bytes": 9757,
      "notes": "U-092: ê³µí†µ ì•„ì´í…œ, nanobanana mcp(pixel-art), rembg(birefnet-general), ImageMagick 64x64"
    },
    {
      "id": "item-ring-64",
      "path": "items/ring-64.png",
      "type": "item-icon",
      "size": 64,
      "fallback": "ğŸ’",
      "usedIn": ["InventoryPanel"],
      "bytes": 7854,
      "notes": "U-092: ê³µí†µ ì•„ì´í…œ, nanobanana mcp(pixel-art), rembg(birefnet-general), ImageMagick 64x64"
    },
    {
      "id": "item-amulet-64",
      "path": "items/amulet-64.png",
      "type": "item-icon",
      "size": 64,
      "fallback": "ğŸ”®",
      "usedIn": ["InventoryPanel"],
      "bytes": 8599,
      "notes": "U-092: ê³µí†µ ì•„ì´í…œ, nanobanana mcp(pixel-art), rembg(birefnet-general), ImageMagick 64x64"
    },
    {
      "id": "item-dagger-64",
      "path": "items/dagger-64.png",
      "type": "item-icon",
      "size": 64,
      "fallback": "ğŸ—¡ï¸",
      "usedIn": ["InventoryPanel"],
      "bytes": 6623,
      "notes": "U-092: ê³µí†µ ì•„ì´í…œ, nanobanana mcp(pixel-art), rembg(birefnet-general), ImageMagick 64x64"
    },
    {
      "id": "item-flask-64",
      "path": "items/flask-64.png",
      "type": "item-icon",
      "size": 64,
      "fallback": "âš—ï¸",
      "usedIn": ["InventoryPanel"],
      "bytes": 7141,
      "notes": "U-092: ê³µí†µ ì•„ì´í…œ, nanobanana mcp(pixel-art), rembg(birefnet-general), ImageMagick 64x64"
    },
    {
      "id": "item-crystal-64",
      "path": "items/crystal-64.png",
      "type": "item-icon",
      "size": 64,
      "fallback": "ğŸ”·",
      "usedIn": ["InventoryPanel"],
      "bytes": 9259,
      "notes": "U-092: ê³µí†µ ì•„ì´í…œ, nanobanana mcp(pixel-art), rembg(birefnet-general), ImageMagick 64x64"
    },
    {
      "id": "item-lockpick-64",
      "path": "items/lockpick-64.png",
      "type": "item-icon",
      "size": 64,
      "fallback": "ğŸ”§",
      "usedIn": ["InventoryPanel"],
      "bytes": 6368,
      "notes": "U-092: ê³µí†µ ì•„ì´í…œ, nanobanana mcp(pixel-art), rembg(birefnet-general), ImageMagick 64x64"
    }
  ]
}
</file>

<file path="frontend/public/ui/manifest.schema.json">
{
  "$schema": "http://json-schema.org/draft-07/schema#",
  "$id": "https://unknown-world.dev/schemas/ui-asset-manifest.json",
  "title": "UI Asset Manifest",
  "description": "nanobanana mcpë¡œ ì œì‘ëœ UI ì—ì…‹ì˜ ë§¤ë‹ˆí˜ìŠ¤íŠ¸ ìŠ¤í‚¤ë§ˆ",
  "type": "object",
  "required": ["version", "assets"],
  "additionalProperties": false,
  "properties": {
    "$schema": {
      "type": "string",
      "description": "JSON Schema ì°¸ì¡°"
    },
    "version": {
      "type": "string",
      "pattern": "^\\d+\\.\\d+\\.\\d+$",
      "description": "ë§¤ë‹ˆí˜ìŠ¤íŠ¸ ë²„ì „ (SemVer)",
      "examples": ["1.0.0"]
    },
    "generatedAt": {
      "type": "string",
      "format": "date-time",
      "description": "ë§¤ë‹ˆí˜ìŠ¤íŠ¸ ìƒì„± ì‹œê° (ISO 8601)"
    },
    "totalBytes": {
      "type": "integer",
      "minimum": 0,
      "description": "ëª¨ë“  ì—ì…‹ì˜ ì´ ë°”ì´íŠ¸ ìˆ˜"
    },
    "budgetBytes": {
      "type": "integer",
      "minimum": 0,
      "default": 1572864,
      "description": "ì„±ëŠ¥ ì˜ˆì‚° ìƒí•œ (ê¸°ë³¸: 1.5MB = 1572864 bytes)"
    },
    "assets": {
      "type": "array",
      "description": "ì—ì…‹ ëª©ë¡",
      "items": {
        "$ref": "#/$defs/Asset"
      }
    }
  },
  "$defs": {
    "Asset": {
      "type": "object",
      "required": ["id", "path", "type"],
      "additionalProperties": false,
      "properties": {
        "id": {
          "type": "string",
          "pattern": "^[a-z0-9]+(-[a-z0-9]+)*$",
          "description": "ì—ì…‹ ê³ ìœ  ID (kebab-case)",
          "examples": ["signal-24", "badge-ok-16", "scene-loading"]
        },
        "path": {
          "type": "string",
          "pattern": "^[a-z0-9-/]+\\.(png|webp|svg)$",
          "description": "ui/ ë””ë ‰í† ë¦¬ ê¸°ì¤€ ìƒëŒ€ ê²½ë¡œ",
          "examples": ["icons/signal-24.png", "placeholders/scene-loading.webp"]
        },
        "type": {
          "type": "string",
          "enum": ["icon", "placeholder", "chrome", "item-icon"],
          "description": "ì—ì…‹ ìœ í˜•"
        },
        "size": {
          "type": "integer",
          "enum": [16, 24, 32, 64, 128, 256, 512],
          "description": "í”½ì…€ ì‚¬ì´ì¦ˆ (ì•„ì´ì½˜ìš©)"
        },
        "width": {
          "type": "integer",
          "minimum": 1,
          "description": "ê°€ë¡œ í”½ì…€ (placeholder/chromeìš©)"
        },
        "height": {
          "type": "integer",
          "minimum": 1,
          "description": "ì„¸ë¡œ í”½ì…€ (placeholder/chromeìš©)"
        },
        "fallback": {
          "type": "string",
          "maxLength": 10,
          "description": "ë¡œë”© ì‹¤íŒ¨ ì‹œ ëŒ€ì²´ ì´ëª¨ì§€/í…ìŠ¤íŠ¸",
          "examples": ["ğŸ“¡", "âš ï¸", "OK"]
        },
        "usedIn": {
          "type": "array",
          "items": {
            "type": "string"
          },
          "description": "ì‚¬ìš©ì²˜ ì»´í¬ë„ŒíŠ¸ ëª©ë¡",
          "examples": [["EconomyHUD", "AgentConsole"]]
        },
        "bytes": {
          "type": "integer",
          "minimum": 0,
          "description": "íŒŒì¼ í¬ê¸° (bytes)"
        },
        "format": {
          "type": "string",
          "enum": ["png", "webp", "svg"],
          "description": "íŒŒì¼ í¬ë§·"
        },
        "retina": {
          "type": "boolean",
          "default": false,
          "description": "@2x Retina ë²„ì „ ì¡´ì¬ ì—¬ë¶€"
        },
        "description": {
          "type": "string",
          "maxLength": 200,
          "description": "ì—ì…‹ ì„¤ëª…"
        },
        "createdAt": {
          "type": "string",
          "format": "date-time",
          "description": "ìƒì„± ì‹œê° (ISO 8601)"
        },
        "promptHash": {
          "type": "string",
          "pattern": "^[a-f0-9]{8}$",
          "description": "ìƒì„± í”„ë¡¬í”„íŠ¸ í•´ì‹œ (ì¬í˜„ì„±, 8ì)"
        },
        "notes": {
          "type": "string",
          "maxLength": 500,
          "description": "ì—ì…‹ ê´€ë ¨ ë©”ëª¨ (ìƒì„± ë„êµ¬, ë°°ê²½ ì œê±°, ìµœì í™” ë“± QA ê´€ë ¨ ê¸°ë¡)"
        }
      }
    }
  }
}
</file>

<file path="frontend/src/api/turnStream.test.ts">
import { describe, it, expect, vi, beforeEach } from 'vitest';
import { NDJSONParser } from './turnStream';

describe('NDJSONParser', () => {
  let parser: NDJSONParser;

  beforeEach(() => {
    parser = new NDJSONParser();
  });

  it('should parse a single complete line', () => {
    const chunk = JSON.stringify({ type: 'test', value: 1 }) + '\n';
    const results = parser.parse(chunk);
    expect(results).toHaveLength(1);
    expect(results[0]).toEqual({ type: 'test', value: 1 });
  });

  it('should parse multiple complete lines in one chunk', () => {
    const chunk = JSON.stringify({ id: 1 }) + '\n' + JSON.stringify({ id: 2 }) + '\n';
    const results = parser.parse(chunk);
    expect(results).toHaveLength(2);
    expect(results[0]).toEqual({ id: 1 });
    expect(results[1]).toEqual({ id: 2 });
  });

  it('should buffer partial lines and parse them when completed', () => {
    const chunk1 = '{"id": 1';
    const chunk2 = ', "val": "ok"}\n';

    const results1 = parser.parse(chunk1);
    expect(results1).toHaveLength(0);

    const results2 = parser.parse(chunk2);
    expect(results2).toHaveLength(1);
    expect(results2[0]).toEqual({ id: 1, val: 'ok' });
  });

  it('should ignore empty lines', () => {
    const chunk = '\n\n{"a":1}\n\n';
    const results = parser.parse(chunk);
    expect(results).toHaveLength(1);
  });

  it('should not crash on invalid JSON and continue', () => {
    const consoleSpy = vi.spyOn(console, 'warn').mockImplementation(() => {});
    const chunk = 'invalid json\n{"valid": true}\n';
    const results = parser.parse(chunk);

    expect(results).toHaveLength(1);
    expect(results[0]).toEqual({ valid: true });
    expect(consoleSpy).toHaveBeenCalled();
    consoleSpy.mockRestore();
  });

  it('should flush remaining buffer', () => {
    parser.parse('{"id": 1}'); // No newline
    const result = parser.flush();
    expect(result).toEqual({ id: 1 });
  });

  it('should return null on flush with empty buffer', () => {
    const result = parser.flush();
    expect(result).toBeNull();
  });
});

describe('executeTurnStream', () => {
  const mockInput = {
    language: 'ko-KR' as const,
    text: 'Hello',
    action_id: null,
    click: null,
    drop: null, // U-012: ë“œë¡­ ì…ë ¥ í•„ë“œ ì¶”ê°€
    client: { viewport_w: 100, viewport_h: 100, theme: 'dark' as const },
    economy_snapshot: { signal: 100, memory_shard: 0 },
    previous_image_url: null,
  };

  const mockCallbacks = {
    onStage: vi.fn(),
    onRepair: vi.fn(),
    onBadges: vi.fn(),
    onNarrativeDelta: vi.fn(),
    onFinal: vi.fn(),
    onError: vi.fn(),
    onComplete: vi.fn(),
  };

  beforeEach(() => {
    vi.clearAllMocks();
    global.fetch = vi.fn();
  });

  it('should process stream events correctly (including repair)', async () => {
    const encoder = new TextEncoder();
    const stream = new ReadableStream({
      start(controller) {
        controller.enqueue(
          encoder.encode(JSON.stringify({ type: 'stage', name: 'parse', status: 'start' }) + '\n'),
        );
        controller.enqueue(
          encoder.encode(
            JSON.stringify({ type: 'repair', attempt: 1, message: 'Schema fail, retrying' }) + '\n',
          ),
        );
        controller.enqueue(
          encoder.encode(JSON.stringify({ type: 'narrative_delta', text: 'Hello' }) + '\n'),
        );
        controller.enqueue(
          encoder.encode(
            JSON.stringify({
              type: 'final',
              data: {
                language: 'ko-KR',
                narrative: 'Hello',
                economy: {
                  cost: { signal: 0, memory_shard: 0 },
                  balance_after: { signal: 100, memory_shard: 0 },
                },
                safety: { blocked: false },
              },
            }) + '\n',
          ),
        );
        controller.close();
      },
    });

    (global.fetch as unknown as ReturnType<typeof vi.fn>).mockResolvedValue({
      ok: true,
      body: stream,
    });

    const { executeTurnStream } = await import('./turnStream');
    await executeTurnStream(mockInput, mockCallbacks);

    expect(mockCallbacks.onStage).toHaveBeenCalledWith(expect.objectContaining({ name: 'parse' }));
    expect(mockCallbacks.onRepair).toHaveBeenCalledWith(
      expect.objectContaining({ attempt: 1, message: 'Schema fail, retrying' }),
    );
    expect(mockCallbacks.onNarrativeDelta).toHaveBeenCalledWith(
      expect.objectContaining({ text: 'Hello' }),
    );
    expect(mockCallbacks.onFinal).toHaveBeenCalled();
    expect(mockCallbacks.onComplete).toHaveBeenCalled();
  });

  it('should handle HTTP errors', async () => {
    (global.fetch as unknown as ReturnType<typeof vi.fn>).mockResolvedValue({
      ok: false,
      status: 500,
      statusText: 'Internal Server Error',
    });

    const { executeTurnStream } = await import('./turnStream');
    await executeTurnStream(mockInput, mockCallbacks);

    expect(mockCallbacks.onError).toHaveBeenCalledWith(
      expect.objectContaining({
        code: 'STREAM_ERROR',
        message: expect.stringContaining('500'),
      }),
    );
  });

  it('should handle fetch rejection', async () => {
    (global.fetch as unknown as ReturnType<typeof vi.fn>).mockRejectedValue(
      new Error('Network failure'),
    );

    const { executeTurnStream } = await import('./turnStream');
    await executeTurnStream(mockInput, mockCallbacks);

    expect(mockCallbacks.onError).toHaveBeenCalledWith(
      expect.objectContaining({
        message: 'Network failure',
      }),
    );
  });
});
</file>

<file path="frontend/src/components/DemoProfileSelect.tsx">
/**
 * Unknown World - ë°ëª¨ í”„ë¡œí•„ ì„ íƒ ì»´í¬ë„ŒíŠ¸ (U-015[Mvp]).
 *
 * ì²« í™”ë©´ì—ì„œ 3ì¢…ì˜ ë°ëª¨ í”„ë¡œí•„ì„ ì„ íƒí•  ìˆ˜ ìˆëŠ” UIë¥¼ ì œê³µí•©ë‹ˆë‹¤.
 * í”„ë¡œí•„ ì„ íƒ ì‹œ í•´ë‹¹ SaveGameì„ ì¦‰ì‹œ ë¡œë“œí•˜ê³  ê²Œì„ì„ ì‹œì‘í•©ë‹ˆë‹¤.
 *
 * ì„¤ê³„ ì›ì¹™:
 *   - RULE-002: ì±„íŒ… UI ê¸ˆì§€, ê²Œì„ UIë¡œ ìƒì‹œ ë…¸ì¶œ
 *   - RULE-006: i18n í‚¤ ê¸°ë°˜ ë‹¤êµ­ì–´ ì§€ì›
 *   - PRD 6.9: ë°ëª¨ í”„ë¡œí•„ ì„ íƒë§Œìœ¼ë¡œ ì¦‰ì‹œ ì‹œì‘
 *
 * @module components/DemoProfileSelect
 */

import { useCallback } from 'react';
import { useTranslation } from 'react-i18next';
import { DEMO_PROFILES, type DemoProfile } from '../data/demoProfiles';
import { SUPPORTED_LANGUAGES, type SupportedLanguage } from '../i18n';

// =============================================================================
// íƒ€ì… ì •ì˜
// =============================================================================

export interface DemoProfileSelectProps {
  /** í”„ë¡œí•„ ì„ íƒ ì‹œ í˜¸ì¶œë˜ëŠ” ì½œë°± */
  onSelectProfile: (profile: DemoProfile) => void;
  /** ê¸°ì¡´ ì„¸ì´ë¸Œ ë¡œë“œ ì‹œ í˜¸ì¶œë˜ëŠ” ì½œë°± (ì„¸ì´ë¸Œê°€ ìˆëŠ” ê²½ìš°) */
  onContinue?: () => void;
  /** ê¸°ì¡´ ì„¸ì´ë¸Œê°€ ìˆëŠ”ì§€ ì—¬ë¶€ */
  hasSavedGame?: boolean;
  /** U-044: í˜„ì¬ ì„ íƒëœ ì–¸ì–´ */
  currentLanguage?: SupportedLanguage;
  /** U-044: ì–¸ì–´ ë³€ê²½ ì½œë°± (profile_selectì—ì„œë§Œ í—ˆìš©) */
  onLanguageChange?: (language: SupportedLanguage) => void;
}

// =============================================================================
// ì»´í¬ë„ŒíŠ¸
// =============================================================================

/** U-044: ì–¸ì–´ í‘œì‹œ ë ˆì´ë¸” ë§¤í•‘ */
const LANGUAGE_LABELS: Record<SupportedLanguage, string> = {
  'ko-KR': 'í•œêµ­ì–´',
  'en-US': 'English',
};

/**
 * ë°ëª¨ í”„ë¡œí•„ ì„ íƒ í™”ë©´.
 * ê²Œì„ ì‹œì‘ ì „ì— 3ì¢…ì˜ í”„ë¡œí•„ ì¤‘ í•˜ë‚˜ë¥¼ ì„ íƒí•©ë‹ˆë‹¤.
 * U-044: ì–¸ì–´ ì„ íƒ UI í¬í•¨ (profile_selectì—ì„œë§Œ ë³€ê²½ ê°€ëŠ¥).
 */
export function DemoProfileSelect({
  onSelectProfile,
  onContinue,
  hasSavedGame = false,
  currentLanguage = 'ko-KR',
  onLanguageChange,
}: DemoProfileSelectProps) {
  const { t } = useTranslation();

  const handleSelectProfile = useCallback(
    (profile: DemoProfile) => {
      onSelectProfile(profile);
    },
    [onSelectProfile],
  );

  const handleContinue = useCallback(() => {
    onContinue?.();
  }, [onContinue]);

  /** U-044: ì–¸ì–´ í† ê¸€ í•¸ë“¤ëŸ¬ */
  const handleLanguageToggle = useCallback(() => {
    if (!onLanguageChange) return;
    // í˜„ì¬ ì–¸ì–´ì˜ ë‹¤ìŒ ì–¸ì–´ë¡œ ì „í™˜ (2ê°œ ì–¸ì–´ë§Œ ì§€ì›í•˜ë¯€ë¡œ í† ê¸€)
    const currentIndex = SUPPORTED_LANGUAGES.indexOf(currentLanguage);
    const nextIndex = (currentIndex + 1) % SUPPORTED_LANGUAGES.length;
    onLanguageChange(SUPPORTED_LANGUAGES[nextIndex]);
  }, [currentLanguage, onLanguageChange]);

  return (
    <div className="profile-select-container" data-ui-importance="critical">
      {/* U-044: ì–¸ì–´ ì„ íƒ í† ê¸€ (ìš°ì¸¡ ìƒë‹¨) */}
      {onLanguageChange && (
        <div className="language-toggle-container">
          <button
            type="button"
            className="language-toggle-btn"
            onClick={handleLanguageToggle}
            aria-label={t('language.toggle')}
            title={t('language.toggle_tooltip')}
          >
            <span className="language-toggle-icon" aria-hidden="true">
              ğŸŒ
            </span>
            <span className="language-toggle-label">{LANGUAGE_LABELS[currentLanguage]}</span>
          </button>
        </div>
      )}

      {/* íƒ€ì´í‹€ */}
      <header className="profile-select-header">
        <h1 className="profile-select-title glitch" data-text={t('ui.logo')}>
          {t('ui.logo')}
        </h1>
        <p className="profile-select-subtitle">{t('profile.select_title')}</p>
      </header>

      {/* í”„ë¡œí•„ ì¹´ë“œ ëª©ë¡ */}
      <div className="profile-card-grid">
        {DEMO_PROFILES.map((profile) => (
          <button
            key={profile.id}
            type="button"
            className="profile-card"
            onClick={() => handleSelectProfile(profile)}
            style={{ '--profile-accent': profile.themeColor } as React.CSSProperties}
            aria-label={t(profile.nameKey)}
          >
            <span className="profile-card-icon" aria-hidden="true">
              {profile.icon}
            </span>
            <span className="profile-card-name">{t(profile.nameKey)}</span>
            <span className="profile-card-description">{t(profile.descriptionKey)}</span>
          </button>
        ))}
      </div>

      {/* ê¸°ì¡´ ì„¸ì´ë¸Œ ê³„ì†í•˜ê¸° (ìˆëŠ” ê²½ìš°) */}
      {hasSavedGame && onContinue && (
        <div className="profile-continue-section">
          <div className="profile-continue-divider">
            <span>{t('profile.or')}</span>
          </div>
          <button type="button" className="profile-continue-btn" onClick={handleContinue}>
            {t('profile.continue_saved')}
          </button>
        </div>
      )}

      {/* ì•ˆë‚´ ë¬¸êµ¬ */}
      <footer className="profile-select-footer">
        <p className="profile-select-hint">{t('profile.select_hint')}</p>
      </footer>
    </div>
  );
}
</file>

<file path="frontend/src/components/GameHeader.tsx">
import type { ReactNode } from 'react';
import { useTranslation } from 'react-i18next';
import { UIControls } from './UIControls';
import { EconomyHudHeader } from './EconomyHud';
import type { UIScale } from '../stores/uiPrefsStore';
import { useEconomyStore, selectIsBalanceLow } from '../stores/economyStore';

interface GameHeaderProps {
  signal: number;
  memoryShard: number;
  credit: number;
  isConnected: boolean;
  uiScale: UIScale;
  onIncreaseScale: () => void;
  onDecreaseScale: () => void;
  /** U-015: ì¶”ê°€ ì»¨íŠ¸ë¡¤ (ë¦¬ì…‹/í”„ë¡œí•„ ë³€ê²½ ë²„íŠ¼ ë“±) */
  children?: ReactNode;
}

export function GameHeader({
  signal,
  memoryShard,
  credit,
  isConnected,
  uiScale,
  onIncreaseScale,
  onDecreaseScale,
  children,
}: GameHeaderProps) {
  const { t } = useTranslation();
  const isBalanceLow = useEconomyStore(selectIsBalanceLow);

  return (
    <header className="game-header has-chrome">
      <h1 className="game-title glitch" data-text={t('ui.logo')}>
        {t('ui.logo')}
      </h1>
      <div className="header-controls">
        {/* U-015: ë¦¬ì…‹/í”„ë¡œí•„ ë³€ê²½ ë“± ì¶”ê°€ ì»¨íŠ¸ë¡¤ */}
        {children}
        {/* UI ìŠ¤ì¼€ì¼ ì»¨íŠ¸ë¡¤ (U-028â†’U-037: Readable ì œê±°) */}
        <UIControls
          uiScale={uiScale}
          onIncreaseScale={onIncreaseScale}
          onDecreaseScale={onDecreaseScale}
        />
        {/* Economy HUD (U-014: ì˜ˆìƒ ë¹„ìš©/í™•ì • ë¹„ìš© í‘œì‹œ í¬í•¨) */}
        <EconomyHudHeader
          signal={signal}
          memoryShard={memoryShard}
          credit={credit}
          isLow={isBalanceLow}
        />
        <div className="connection-status">
          <span className={`status-indicator ${isConnected ? '' : 'offline'}`} />
          <span>{isConnected ? t('connection.online') : t('connection.offline')}</span>
        </div>
      </div>
    </header>
  );
}
</file>

<file path="frontend/src/components/InteractionHint.test.tsx">
import { describe, it, expect } from 'vitest';
import { render, screen } from '@testing-library/react';
import { InteractionHint } from './InteractionHint';

describe('InteractionHint', () => {
  it('ì „ë‹¬ëœ í…ìŠ¤íŠ¸ë¥¼ ì˜¬ë°”ë¥´ê²Œ ë Œë”ë§í•´ì•¼ í•œë‹¤', () => {
    const testText = 'í…ŒìŠ¤íŠ¸ íŒíŠ¸ í…ìŠ¤íŠ¸';
    render(<InteractionHint text={testText} />);

    expect(screen.getByText(testText)).toBeInTheDocument();
  });

  it('ì•„ì´ì½˜ íƒ€ì…ì— ë”°ë¼ ì ì ˆí•œ aria-hidden SVGë¥¼ í¬í•¨í•´ì•¼ í•œë‹¤', () => {
    const { container } = render(<InteractionHint text="í´ë¦­" icon="click" />);

    const svg = container.querySelector('svg');
    expect(svg).toBeInTheDocument();
    expect(svg).toHaveAttribute('aria-hidden', 'true');
    expect(container.querySelector('.interaction-hint-icon')).toBeInTheDocument();
  });

  it('ìœ„ì¹˜ propsì— ë”°ë¼ ì ì ˆí•œ í´ë˜ìŠ¤ë¥¼ ê°€ì ¸ì•¼ í•œë‹¤', () => {
    const { container: topContainer } = render(<InteractionHint text="ìœ„" position="top" />);
    expect(topContainer.firstChild).toHaveClass('interaction-hint--top');

    const { container: bottomContainer } = render(
      <InteractionHint text="ì•„ë˜" position="bottom" />,
    );
    expect(bottomContainer.firstChild).toHaveClass('interaction-hint--bottom');
  });

  it('aria-labelì´ ì„¤ì •ë˜ì–´ì•¼ í•œë‹¤', () => {
    render(<InteractionHint text="ì¡°ì‚¬í•˜ê¸°" ariaLabel="ì»¤ìŠ¤í…€ ë¼ë²¨" />);
    expect(screen.getByRole('tooltip')).toHaveAttribute('aria-label', 'ì»¤ìŠ¤í…€ ë¼ë²¨');
  });
});
</file>

<file path="frontend/src/components/InteractionHint.tsx">
/**
 * Unknown World - ì¸í„°ë™ì…˜ íŒíŠ¸ ì»´í¬ë„ŒíŠ¸
 *
 * U-074[Mvp]: í•«ìŠ¤íŒŸ/ì•„ì´í…œ ì¸í„°ë™ì…˜ ì•ˆë‚´ UX
 * - ì¬ì‚¬ìš© ê°€ëŠ¥í•œ íŒíŠ¸ íˆ´íŒ ì»´í¬ë„ŒíŠ¸
 * - í´ë¦­/ë“œë˜ê·¸/ë“œë¡­ ì•„ì´ì½˜ + í…ìŠ¤íŠ¸ í‘œì‹œ
 * - Q1 Option B: ì²« Në²ˆë§Œ í‘œì‹œ í›„ ìˆ¨ê¹€
 *
 * RULE-006 ì¤€ìˆ˜: i18n í‚¤ ê¸°ë°˜ í…ìŠ¤íŠ¸
 * RULE-002 ì¤€ìˆ˜: ì±„íŒ… UIê°€ ì•„ë‹Œ ê²Œì„ UI
 *
 * @module components/InteractionHint
 */

import { memo } from 'react';
import '../styles/interaction-hint.css';

// =============================================================================
// íƒ€ì… ì •ì˜
// =============================================================================

export type HintIconType = 'click' | 'drag' | 'drop' | 'scanner';
export type HintPosition = 'top' | 'bottom' | 'left' | 'right';

interface InteractionHintProps {
  /** íŒíŠ¸ í…ìŠ¤íŠ¸ (i18n ì²˜ë¦¬ëœ ë¬¸ìì—´) */
  text: string;

  /** ì•„ì´ì½˜ íƒ€ì… */
  icon?: HintIconType;

  /** íŒíŠ¸ ìœ„ì¹˜ */
  position?: HintPosition;

  /** ì¶”ê°€ CSS í´ë˜ìŠ¤ */
  className?: string;

  /** ì ‘ê·¼ì„±: aria-label ì˜¤ë²„ë¼ì´ë“œ */
  ariaLabel?: string;
}

// =============================================================================
// ì•„ì´ì½˜ ì»´í¬ë„ŒíŠ¸
// =============================================================================

/**
 * íŒíŠ¸ ì•„ì´ì½˜ SVG
 *
 * ê°„ë‹¨í•œ ì¸ë¼ì¸ SVGë¡œ ì•„ì´ì½˜ì„ í‘œí˜„í•©ë‹ˆë‹¤.
 * ì™¸ë¶€ ì´ë¯¸ì§€ ì—ì…‹ ì—†ì´ ìˆœìˆ˜ CSS/SVGë¡œ êµ¬í˜„.
 */
function HintIcon({ type }: { type: HintIconType }) {
  switch (type) {
    case 'click':
      // ë§ˆìš°ìŠ¤ í´ë¦­ ì•„ì´ì½˜ (ê°„ë‹¨í•œ í¬ì¸í„°)
      return (
        <svg
          className="interaction-hint-icon"
          viewBox="0 0 24 24"
          fill="none"
          stroke="currentColor"
          strokeWidth="2"
          strokeLinecap="round"
          strokeLinejoin="round"
          aria-hidden="true"
        >
          {/* ë§ˆìš°ìŠ¤ í¬ì¸í„° ëª¨ì–‘ */}
          <path d="M4 4l7.07 17 2.51-7.39L21 11.07z" />
          <line x1="13.5" y1="13.5" x2="19" y2="19" />
        </svg>
      );

    case 'drag':
      // ë“œë˜ê·¸ ì•„ì´ì½˜ (ì† + í™”ì‚´í‘œ)
      return (
        <svg
          className="interaction-hint-icon"
          viewBox="0 0 24 24"
          fill="none"
          stroke="currentColor"
          strokeWidth="2"
          strokeLinecap="round"
          strokeLinejoin="round"
          aria-hidden="true"
        >
          {/* ì† ëª¨ì–‘ */}
          <path d="M18 11V6a2 2 0 0 0-4 0v5" />
          <path d="M14 10V4a2 2 0 0 0-4 0v6" />
          <path d="M10 10.5V6a2 2 0 0 0-4 0v8" />
          <path d="M18 8a2 2 0 0 1 4 0v6a8 8 0 0 1-8 8h-2c-2.8 0-4.5-.86-5.99-2.34l-3.6-3.6a2 2 0 0 1 2.83-2.82L7 15" />
        </svg>
      );

    case 'drop':
      // ë“œë¡­ ì•„ì´ì½˜ (ë‹¤ìš´ í™”ì‚´í‘œ + ë°•ìŠ¤)
      return (
        <svg
          className="interaction-hint-icon"
          viewBox="0 0 24 24"
          fill="none"
          stroke="currentColor"
          strokeWidth="2"
          strokeLinecap="round"
          strokeLinejoin="round"
          aria-hidden="true"
        >
          {/* ë°•ìŠ¤ */}
          <rect x="3" y="11" width="18" height="10" rx="2" />
          {/* ë‹¤ìš´ í™”ì‚´í‘œ */}
          <path d="M12 3v8" />
          <path d="M8 7l4 4 4-4" />
        </svg>
      );

    case 'scanner':
      // ìŠ¤ìºë„ˆ ì•„ì´ì½˜ (ì¹´ë©”ë¼/ì—…ë¡œë“œ)
      return (
        <svg
          className="interaction-hint-icon"
          viewBox="0 0 24 24"
          fill="none"
          stroke="currentColor"
          strokeWidth="2"
          strokeLinecap="round"
          strokeLinejoin="round"
          aria-hidden="true"
        >
          {/* ì—…ë¡œë“œ ì•„ì´ì½˜ */}
          <path d="M21 15v4a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2v-4" />
          <polyline points="17 8 12 3 7 8" />
          <line x1="12" y1="3" x2="12" y2="15" />
        </svg>
      );

    default:
      return null;
  }
}

// =============================================================================
// ë©”ì¸ ì»´í¬ë„ŒíŠ¸
// =============================================================================

/**
 * ì¸í„°ë™ì…˜ íŒíŠ¸ ì»´í¬ë„ŒíŠ¸
 *
 * í•«ìŠ¤íŒŸ/ì•„ì´í…œ ìœ„ì— í‘œì‹œë˜ëŠ” ì‘ì€ íˆ´íŒ í˜•íƒœì˜ íŒíŠ¸ì…ë‹ˆë‹¤.
 * U-074[Mvp] Q1 Option Bì— ë”°ë¼ ì²« Në²ˆë§Œ í‘œì‹œë©ë‹ˆë‹¤.
 *
 * @example
 * ```tsx
 * <InteractionHint
 *   text={t('interaction.hotspot_click')}
 *   icon="click"
 *   position="top"
 * />
 * ```
 */
function InteractionHintComponent({
  text,
  icon,
  position = 'top',
  className = '',
  ariaLabel,
}: InteractionHintProps) {
  const positionClass = `interaction-hint--${position}`;

  return (
    <div
      className={`interaction-hint ${positionClass} ${className}`.trim()}
      role="tooltip"
      aria-label={ariaLabel ?? text}
    >
      <div className="interaction-hint-content">
        {icon && <HintIcon type={icon} />}
        <span className="interaction-hint-text">{text}</span>
      </div>
    </div>
  );
}

/**
 * Memoized ì¸í„°ë™ì…˜ íŒíŠ¸ ì»´í¬ë„ŒíŠ¸
 *
 * ë¹ˆë²ˆí•œ í˜¸ë²„ ì´ë²¤íŠ¸ì—ì„œ ë¶ˆí•„ìš”í•œ ë¦¬ë Œë”ë¥¼ ë°©ì§€í•©ë‹ˆë‹¤.
 */
export const InteractionHint = memo(InteractionHintComponent);

InteractionHint.displayName = 'InteractionHint';

// Re-export types
export type { InteractionHintProps };
</file>

<file path="frontend/src/components/MutationTimeline.test.tsx">
import { describe, it, expect, beforeEach, vi } from 'vitest';
import { render, screen } from '@testing-library/react';
import { MutationTimeline } from './MutationTimeline';
import { useWorldStore } from '../stores/worldStore';

vi.mock('react-i18next', () => ({
  useTranslation: () => ({
    t: (key: string, options?: Record<string, unknown>) => {
      if (options?.turn !== undefined) return `T${options.turn}`;
      if (options?.count !== undefined) return `${key} (count: ${options.count})`;
      return key;
    },
  }),
  initReactI18next: {
    type: '3rdParty',
    init: () => {},
  },
}));

describe('MutationTimeline (U-013)', () => {
  beforeEach(() => {
    useWorldStore.getState().reset();
  });

  it('ë³€í˜• ì´ë ¥ì´ ì—†ì„ ë•Œ ë¹ˆ ìƒíƒœë¥¼ í‘œì‹œí•´ì•¼ í•œë‹¤', () => {
    render(<MutationTimeline />);
    expect(screen.getByText('mutation.empty')).toBeInTheDocument();
  });

  it('ë³€í˜• ì´ë²¤íŠ¸ ëª©ë¡ì„ ìµœì‹ ìˆœìœ¼ë¡œ í‘œì‹œí•´ì•¼ í•œë‹¤', () => {
    useWorldStore.setState({
      mutationTimeline: [
        {
          turn: 2,
          ruleId: 'r2',
          type: 'modified',
          label: 'ìˆ˜ì •ëœ ê·œì¹™',
          timestamp: Date.now(),
        },
        {
          turn: 1,
          ruleId: 'r1',
          type: 'added',
          label: 'ìƒˆ ê·œì¹™',
          timestamp: Date.now() - 1000,
        },
      ],
    });

    render(<MutationTimeline />);
    expect(screen.getByText('mutation.timeline_title')).toBeInTheDocument();
    expect(screen.getAllByText('T2')).toHaveLength(1);
    expect(screen.getByText('ìˆ˜ì •ëœ ê·œì¹™')).toBeInTheDocument();
    expect(screen.getByText('mutation.type.modified')).toBeInTheDocument();

    expect(screen.getAllByText('T1')).toHaveLength(1);
    expect(screen.getByText('ìƒˆ ê·œì¹™')).toBeInTheDocument();
    expect(screen.getByText('mutation.type.added')).toBeInTheDocument();
  });

  it('ì´ë²¤íŠ¸ê°€ ë§ì„ ë•Œ "ë” ë³´ê¸°" í‘œì‹œë¥¼ í•´ì•¼ í•œë‹¤ (ìµœëŒ€ 10ê°œ ê¸°ì¤€)', () => {
    const manyEvents = Array.from({ length: 12 }, (_, i) => ({
      turn: i + 1,
      ruleId: `r${i}`,
      type: 'added' as const,
      label: `ê·œì¹™ ${i}`,
      timestamp: Date.now(),
    })).reverse(); // ìµœì‹ ìˆœ

    useWorldStore.setState({ mutationTimeline: manyEvents });

    const { container } = render(<MutationTimeline />);
    // 10ê°œë§Œ ë Œë”ë§ë¨
    expect(container.getElementsByClassName('timeline-event')).toHaveLength(10);
    // +2ê°œ ë” ë³´ê¸° í‘œì‹œ
    expect(screen.getByText('mutation.more_events (count: 2)')).toBeInTheDocument();
  });
});
</file>

<file path="frontend/src/components/ObjectiveTracker.test.tsx">
import { describe, it, expect, beforeEach, vi } from 'vitest';
import { render, screen } from '@testing-library/react';
import { ObjectiveTracker } from './ObjectiveTracker';
import { useWorldStore } from '../stores/worldStore';

// i18next ëª¨í‚¹
vi.mock('react-i18next', () => ({
  useTranslation: () => ({
    t: (key: string) => key,
  }),
  initReactI18next: {
    type: '3rdParty',
    init: () => {},
  },
}));

describe('ObjectiveTracker (U-078)', () => {
  beforeEach(() => {
    useWorldStore.getState().reset();
  });

  it('ëª©í‘œê°€ ì—†ì„ ë•Œ ì•„ë¬´ê²ƒë„ ë Œë”ë§í•˜ì§€ ì•Šì•„ì•¼ í•œë‹¤', () => {
    const { container } = render(<ObjectiveTracker />);
    expect(container.firstChild).toBeNull();
  });

  it('ì£¼ ëª©í‘œë§Œ ìˆì„ ë•Œ ì˜¬ë°”ë¥´ê²Œ í‘œì‹œí•´ì•¼ í•œë‹¤', () => {
    useWorldStore.setState({
      quests: [
        {
          id: 'main',
          label: 'ì£¼ ëª©í‘œ',
          is_completed: false,
          description: null,
          is_main: true,
          progress: 30,
          reward_signal: 0,
        },
      ],
    });

    render(<ObjectiveTracker />);
    expect(screen.getByText('ì£¼ ëª©í‘œ')).toBeInTheDocument();
    // ì§„í–‰ë¥  ë°” í™•ì¸
    const progressBar = screen.getByRole('progressbar');
    expect(progressBar).toBeInTheDocument();
    const fill = progressBar.querySelector('.objective-tracker__bar-fill');
    expect(fill).toHaveStyle({ width: '30%' });
  });

  it('ì„œë¸Œ ëª©í‘œ ì¹´ìš´íŠ¸ë¥¼ í‘œì‹œí•´ì•¼ í•œë‹¤', () => {
    useWorldStore.setState({
      quests: [
        {
          id: 'main',
          label: 'ì£¼ ëª©í‘œ',
          is_completed: false,
          description: null,
          is_main: true,
          progress: 0,
          reward_signal: 0,
        },
        {
          id: 'sub1',
          label: 'ì„œë¸Œ 1',
          is_completed: true,
          description: null,
          is_main: false,
          progress: 0,
          reward_signal: 0,
        },
        {
          id: 'sub2',
          label: 'ì„œë¸Œ 2',
          is_completed: false,
          description: null,
          is_main: false,
          progress: 0,
          reward_signal: 0,
        },
      ],
    });

    render(<ObjectiveTracker />);
    expect(screen.getByText('(1/2)')).toBeInTheDocument();
  });

  it('ì™„ë£Œëœ ëª©í‘œì¼ ë•Œ ì²´í¬ ì•„ì´ì½˜ì„ í‘œì‹œí•´ì•¼ í•œë‹¤', () => {
    useWorldStore.setState({
      quests: [
        {
          id: 'main',
          label: 'ì™„ë£Œëœ ì£¼ ëª©í‘œ',
          is_completed: true,
          description: null,
          is_main: true,
          progress: 100,
          reward_signal: 0,
        },
      ],
    });

    render(<ObjectiveTracker />);
    expect(screen.getByText('âœ…')).toBeInTheDocument();
    expect(screen.getByText('ì™„ë£Œëœ ì£¼ ëª©í‘œ')).toBeInTheDocument();
  });
});
</file>

<file path="frontend/src/components/ObjectiveTracker.tsx">
/**
 * Unknown World - Objective Tracker (U-078 ëª©í‘œ ì‹œìŠ¤í…œ ê°•í™”)
 *
 * í™”ë©´ ìƒë‹¨ì— í•­ìƒ ë³´ì´ëŠ” ë¯¸ë‹ˆ ëª©í‘œ íŠ¸ë˜ì»¤ì…ë‹ˆë‹¤.
 * ì£¼ ëª©í‘œì˜ ì œëª©ê³¼ ì§„í–‰ë¥ ì„ ê°„ê²°í•˜ê²Œ í‘œì‹œí•©ë‹ˆë‹¤.
 *
 * Q2 ê²°ì •: Option B - í™”ë©´ ìƒë‹¨ì— ë¯¸ë‹ˆ íŠ¸ë˜ì»¤ ì¶”ê°€ (í•­ìƒ ë³´ì„)
 *
 * ì„¤ê³„ ì›ì¹™:
 *   - RULE-002: ê²Œì„ HUD ìš”ì†Œë¡œ ìƒì‹œ ë…¸ì¶œ
 *   - RULE-006: i18n ê¸°ë°˜ ë¬¸ìì—´
 *   - ìµœì†Œ ë†’ì´ë¡œ ë©”ì¸ ì½˜í…ì¸ ë¥¼ ì¹¨ë²”í•˜ì§€ ì•ŠìŒ
 *
 * @module components/ObjectiveTracker
 */

import { useTranslation } from 'react-i18next';
import { useShallow } from 'zustand/react/shallow';
import { useWorldStore, selectMainObjective, selectSubObjectives } from '../stores/worldStore';

/**
 * ObjectiveTracker - ë¯¸ë‹ˆ ëª©í‘œ íŠ¸ë˜ì»¤
 *
 * game-center ì˜ì—­ ìƒë‹¨ì— ë°°ì¹˜í•˜ì—¬ í•­ìƒ í˜„ì¬ ëª©í‘œë¥¼ í™•ì¸í•  ìˆ˜ ìˆìŠµë‹ˆë‹¤.
 */
export function ObjectiveTracker() {
  const { t } = useTranslation();
  const mainObjective = useWorldStore(selectMainObjective);
  const subObjectives = useWorldStore(useShallow(selectSubObjectives));

  // ì„œë¸Œ ëª©í‘œ ì¤‘ ì™„ë£Œëœ ê²ƒì˜ ìˆ˜
  const completedCount = subObjectives.filter((q) => q.is_completed).length;
  const totalCount = subObjectives.length;

  // ëª©í‘œê°€ ì „í˜€ ì—†ìœ¼ë©´ í‘œì‹œí•˜ì§€ ì•ŠìŒ
  if (!mainObjective && totalCount === 0) {
    return null;
  }

  const progress = mainObjective?.progress ?? 0;
  const isComplete = mainObjective?.is_completed ?? false;

  return (
    <div
      className={`objective-tracker ${isComplete ? 'objective-tracker--completed' : ''}`}
      data-ui-importance="critical"
    >
      <div className="objective-tracker__icon" aria-hidden="true">
        {isComplete ? 'âœ…' : 'ğŸ¯'}
      </div>
      <div className="objective-tracker__content">
        <span className="objective-tracker__title">
          {mainObjective?.label ?? t('quest.tracker_no_objective')}
        </span>
        {totalCount > 0 && (
          <span className="objective-tracker__sub-count">
            ({completedCount}/{totalCount})
          </span>
        )}
      </div>
      <div
        className="objective-tracker__bar"
        role="progressbar"
        aria-valuenow={progress}
        aria-valuemin={0}
        aria-valuemax={100}
      >
        <div
          className="objective-tracker__bar-fill"
          style={{ width: `${Math.max(0, Math.min(100, progress))}%` }}
        />
      </div>
    </div>
  );
}

export default ObjectiveTracker;
</file>

<file path="frontend/src/components/OnboardingGuide.test.tsx">
import { describe, it, expect, vi, beforeEach } from 'vitest';
import { render, screen, fireEvent } from '@testing-library/react';
import { OnboardingGuide } from './OnboardingGuide';
import { useOnboardingStore } from '../stores/onboardingStore';

// i18next ëª¨í‚¹
vi.mock('react-i18next', () => ({
  useTranslation: () => ({
    t: (key: string) => key,
  }),
}));

describe('OnboardingGuide', () => {
  beforeEach(() => {
    vi.clearAllMocks();
    useOnboardingStore.getState().resetOnboarding();
  });

  it('showOnboardingì´ falseì´ë©´ ì•„ë¬´ê²ƒë„ ë Œë”ë§í•˜ì§€ ì•Šì•„ì•¼ í•œë‹¤', () => {
    const { container } = render(<OnboardingGuide />);
    expect(container.firstChild).toBeNull();
  });

  it('showOnboardingì´ trueì´ë©´ ê°€ì´ë“œê°€ ë Œë”ë§ë˜ì–´ì•¼ í•œë‹¤', () => {
    useOnboardingStore.getState().showOnboardingGuide();
    render(<OnboardingGuide />);

    expect(screen.getByRole('dialog')).toBeInTheDocument();
    expect(screen.getByText('interaction.onboarding_title')).toBeInTheDocument();
  });

  it('Next ë²„íŠ¼ í´ë¦­ ì‹œ ë‹¤ìŒ ë‹¨ê³„ë¡œ ì´ë™í•´ì•¼ í•œë‹¤', () => {
    useOnboardingStore.getState().showOnboardingGuide();
    render(<OnboardingGuide />);

    // ì²« ë‹¨ê³„ í…ìŠ¤íŠ¸ í™•ì¸ (í•«ìŠ¤íŒŸ)
    expect(screen.getByText('interaction.onboarding_hotspot')).toBeInTheDocument();

    // Next í´ë¦­
    const nextButton = screen.getByLabelText('common.next');
    fireEvent.click(nextButton);

    // ë‹¤ìŒ ë‹¨ê³„ í…ìŠ¤íŠ¸ í™•ì¸ (ì•„ì´í…œ)
    expect(screen.getByText('interaction.onboarding_item')).toBeInTheDocument();
    expect(useOnboardingStore.getState().onboardingStep).toBe(1);
  });

  it('Skip ë²„íŠ¼ í´ë¦­ ì‹œ ì˜¨ë³´ë”©ì´ ì™„ë£Œë˜ì–´ì•¼ í•œë‹¤', () => {
    useOnboardingStore.getState().showOnboardingGuide();
    render(<OnboardingGuide />);

    const skipButton = screen.getByLabelText('interaction.onboarding_skip');
    fireEvent.click(skipButton);

    const state = useOnboardingStore.getState();
    expect(state.onboardingComplete).toBe(true);
    expect(state.showOnboarding).toBe(false);
  });

  it('ë§ˆì§€ë§‰ ë‹¨ê³„ì—ì„œ Start ë²„íŠ¼ í´ë¦­ ì‹œ ì˜¨ë³´ë”©ì´ ì™„ë£Œë˜ì–´ì•¼ í•œë‹¤', () => {
    const store = useOnboardingStore.getState();
    store.showOnboardingGuide();
    store.nextOnboardingStep();
    store.nextOnboardingStep(); // ë§ˆì§€ë§‰ ë‹¨ê³„ (2)

    render(<OnboardingGuide />);

    expect(screen.getByText('interaction.onboarding_scanner')).toBeInTheDocument();

    const startButton = screen.getByLabelText('interaction.onboarding_start');
    fireEvent.click(startButton);

    const state = useOnboardingStore.getState();
    expect(state.onboardingComplete).toBe(true);
  });

  it('Enter í‚¤ ì…ë ¥ ì‹œ ë‹¤ìŒ ë‹¨ê³„ë¡œ ì´ë™í•´ì•¼ í•œë‹¤', () => {
    useOnboardingStore.getState().showOnboardingGuide();
    render(<OnboardingGuide />);

    fireEvent.keyDown(window, { key: 'Enter' });

    expect(useOnboardingStore.getState().onboardingStep).toBe(1);
  });
});
</file>

<file path="frontend/src/components/OnboardingGuide.tsx">
/**
 * Unknown World - ì˜¨ë³´ë”© ê°€ì´ë“œ ì»´í¬ë„ŒíŠ¸
 *
 * U-074[Mvp]: í•«ìŠ¤íŒŸ/ì•„ì´í…œ ì¸í„°ë™ì…˜ ì•ˆë‚´ UX
 * - Q2 Option B: í™”ë©´ ì½”ë„ˆì— ì‘ì€ íŒì—… ê°€ì´ë“œ
 * - Q3 Option B: ë°ëª¨ í”„ë¡œí•„ë„ ì²« ì ‘ì† ì‹œ ì˜¨ë³´ë”© í‘œì‹œ
 *
 * ì²« ì„¸ì…˜ ì‹œì‘ ì‹œ í•«ìŠ¤íŒŸ/ì•„ì´í…œ/ìŠ¤ìºë„ˆ ì‚¬ìš©ë²•ì„ ìˆœì„œëŒ€ë¡œ ì•ˆë‚´í•©ë‹ˆë‹¤.
 * "ìŠ¤í‚µ" ë²„íŠ¼ìœ¼ë¡œ ê±´ë„ˆë›°ê¸° ê°€ëŠ¥í•˜ë©°, localStorageë¡œ ì™„ë£Œ ìƒíƒœë¥¼ ì €ì¥í•©ë‹ˆë‹¤.
 *
 * RULE-006 ì¤€ìˆ˜: i18n í‚¤ ê¸°ë°˜ í…ìŠ¤íŠ¸
 * RULE-002 ì¤€ìˆ˜: ì±„íŒ… UIê°€ ì•„ë‹Œ ê²Œì„ UI
 *
 * @module components/OnboardingGuide
 */

import { useCallback, useEffect } from 'react';
import { useTranslation } from 'react-i18next';
import {
  useOnboardingStore,
  selectShowOnboarding,
  selectOnboardingStep,
} from '../stores/onboardingStore';
import '../styles/onboarding-guide.css';

// =============================================================================
// ìƒìˆ˜ ì •ì˜
// =============================================================================

/** ì˜¨ë³´ë”© ë‹¨ê³„ ì •ì˜ */
interface OnboardingStepData {
  /** ë‹¨ê³„ ì‹ë³„ì (CSS íƒ€ê²Ÿ í•˜ì´ë¼ì´íŠ¸ìš©) */
  target: 'hotspot' | 'inventory' | 'scanner';
  /** i18n í‚¤ */
  textKey: string;
  /** ì•„ì´ì½˜ ì´ëª¨ì§€ */
  icon: string;
}

const ONBOARDING_STEPS: OnboardingStepData[] = [
  {
    target: 'hotspot',
    textKey: 'interaction.onboarding_hotspot',
    icon: 'ğŸ¯',
  },
  {
    target: 'inventory',
    textKey: 'interaction.onboarding_item',
    icon: 'ğŸ“¦',
  },
  {
    target: 'scanner',
    textKey: 'interaction.onboarding_scanner',
    icon: 'ğŸ“·',
  },
];

// =============================================================================
// ë©”ì¸ ì»´í¬ë„ŒíŠ¸
// =============================================================================

/**
 * ì˜¨ë³´ë”© ê°€ì´ë“œ ì»´í¬ë„ŒíŠ¸
 *
 * í™”ë©´ ìš°í•˜ë‹¨ì— ì‘ì€ íŒì—… í˜•íƒœë¡œ í‘œì‹œë˜ë©°,
 * í•«ìŠ¤íŒŸ/ì•„ì´í…œ/ìŠ¤ìºë„ˆ ì‚¬ìš©ë²•ì„ ìˆœì„œëŒ€ë¡œ ì•ˆë‚´í•©ë‹ˆë‹¤.
 *
 * @example
 * ```tsx
 * // App.tsxì—ì„œ ì‚¬ìš©
 * <OnboardingGuide />
 * ```
 */
export function OnboardingGuide() {
  const { t } = useTranslation();

  // Store ìƒíƒœ
  const showOnboarding = useOnboardingStore(selectShowOnboarding);
  const currentStep = useOnboardingStore(selectOnboardingStep);
  const nextStep = useOnboardingStore((state) => state.nextOnboardingStep);
  const completeOnboarding = useOnboardingStore((state) => state.completeOnboarding);
  const dismissOnboarding = useOnboardingStore((state) => state.dismissOnboarding);

  // í˜„ì¬ ë‹¨ê³„ ë°ì´í„°
  const stepData = ONBOARDING_STEPS[currentStep];
  const isLastStep = currentStep >= ONBOARDING_STEPS.length - 1;

  // í‚¤ë³´ë“œ ë‹¨ì¶•í‚¤: ESCë¡œ ìŠ¤í‚µ, Enter/Spaceë¡œ ë‹¤ìŒ/ì™„ë£Œ
  useEffect(() => {
    if (!showOnboarding) return;

    const handleKeyDown = (e: KeyboardEvent) => {
      if (e.key === 'Escape') {
        e.preventDefault();
        handleSkip();
      } else if (e.key === 'Enter' || e.key === ' ') {
        e.preventDefault();
        handleNext();
      }
    };

    window.addEventListener('keydown', handleKeyDown);
    return () => window.removeEventListener('keydown', handleKeyDown);
    // eslint-disable-next-line react-hooks/exhaustive-deps
  }, [showOnboarding, currentStep, isLastStep]);

  // ìŠ¤í‚µ í•¸ë“¤ëŸ¬
  const handleSkip = useCallback(() => {
    dismissOnboarding();
    completeOnboarding();
  }, [dismissOnboarding, completeOnboarding]);

  // ë‹¤ìŒ/ì™„ë£Œ í•¸ë“¤ëŸ¬
  const handleNext = useCallback(() => {
    if (isLastStep) {
      completeOnboarding();
    } else {
      nextStep();
    }
  }, [isLastStep, completeOnboarding, nextStep]);

  // í‘œì‹œ ì¡°ê±´ í™•ì¸
  if (!showOnboarding || !stepData) {
    return null;
  }

  return (
    <div
      className="onboarding-guide"
      role="dialog"
      aria-modal="false"
      aria-labelledby="onboarding-title"
      aria-describedby="onboarding-description"
    >
      {/* í—¤ë” */}
      <div className="onboarding-guide-header">
        <span className="onboarding-guide-icon" aria-hidden="true">
          {stepData.icon}
        </span>
        <span id="onboarding-title" className="onboarding-guide-title">
          {t('interaction.onboarding_title')}
        </span>
        <span className="onboarding-guide-progress">
          {currentStep + 1}/{ONBOARDING_STEPS.length}
        </span>
      </div>

      {/* ë‚´ìš© */}
      <p id="onboarding-description" className="onboarding-guide-text">
        {t(stepData.textKey)}
      </p>

      {/* ì§„í–‰ ì¸ë””ì¼€ì´í„° */}
      <div className="onboarding-guide-dots" aria-hidden="true">
        {ONBOARDING_STEPS.map((_, index) => (
          <span
            key={index}
            className={`onboarding-guide-dot ${index === currentStep ? 'active' : ''} ${index < currentStep ? 'completed' : ''}`}
          />
        ))}
      </div>

      {/* ë²„íŠ¼ ì˜ì—­ */}
      <div className="onboarding-guide-actions">
        <button
          type="button"
          className="onboarding-guide-skip"
          onClick={handleSkip}
          aria-label={t('interaction.onboarding_skip')}
        >
          {t('interaction.onboarding_skip')}
        </button>
        <button
          type="button"
          className="onboarding-guide-next"
          onClick={handleNext}
          aria-label={isLastStep ? t('interaction.onboarding_start') : t('common.next')}
        >
          {isLastStep ? t('interaction.onboarding_start') : t('common.next')}
        </button>
      </div>
    </div>
  );
}

export default OnboardingGuide;
</file>

<file path="frontend/src/components/QuestPanel.tsx">
/**
 * Unknown World - Quest Panel (U-013, U-078 ëª©í‘œ ì‹œìŠ¤í…œ ê°•í™”)
 *
 * í”Œë ˆì´ì–´ì˜ í˜„ì¬ ëª©í‘œë¥¼ **ì£¼ ëª©í‘œ(Main Objective)** + **ì„œë¸Œ ëª©í‘œ** í˜•íƒœë¡œ í‘œì‹œí•©ë‹ˆë‹¤.
 *
 * U-078 ë³€ê²½ì‚¬í•­:
 *   - ì£¼ ëª©í‘œ(is_main=true): ìƒë‹¨ ê°•ì¡° ì˜ì—­, ì§„í–‰ë¥  ë°”, ë³´ìƒ ë¯¸ë¦¬ë³´ê¸°
 *   - ì„œë¸Œ ëª©í‘œ(is_main=false): ì²´í¬ë¦¬ìŠ¤íŠ¸, ì™„ë£Œ ì‹œ ì·¨ì†Œì„  + ë³´ìƒ í”¼ë“œë°±
 *   - ëª©í‘œ ì—†ì„ ë•Œ: "ììœ  íƒìƒ‰ ì¤‘" ì•ˆë‚´
 *   - ì™„ë£Œ ì‹œ ì²´í¬ ì• ë‹ˆë©”ì´ì…˜ (Q4: Option B)
 *
 * ì„¤ê³„ ì›ì¹™:
 *   - RULE-002: ì±„íŒ… UIê°€ ì•„ë‹Œ ê²Œì„ UIë¡œ ìƒì‹œ ë…¸ì¶œ
 *   - RULE-006: i18n ê¸°ë°˜ ë¬¸ìì—´ ê´€ë¦¬
 *   - PRD 6.7: Quest/Objective Panel
 *
 * @module components/QuestPanel
 */

import { useTranslation } from 'react-i18next';
import { useShallow } from 'zustand/react/shallow';
import { useWorldStore, selectMainObjective, selectSubObjectives } from '../stores/worldStore';
import type { Quest } from '../schemas/turn';

// =============================================================================
// ì§„í–‰ë¥  ë°” í•˜ìœ„ ì»´í¬ë„ŒíŠ¸
// =============================================================================

interface ProgressBarProps {
  value: number; // 0-100
}

/** ì£¼ ëª©í‘œ ì§„í–‰ë¥  ë°” */
function ProgressBar({ value }: ProgressBarProps) {
  const clampedValue = Math.max(0, Math.min(100, value));
  return (
    <div
      className="objective-progress-bar"
      role="progressbar"
      aria-valuenow={clampedValue}
      aria-valuemin={0}
      aria-valuemax={100}
    >
      <div className="objective-progress-fill" style={{ width: `${clampedValue}%` }} />
      <span className="objective-progress-text">{clampedValue}%</span>
    </div>
  );
}

// =============================================================================
// ì£¼ ëª©í‘œ í•˜ìœ„ ì»´í¬ë„ŒíŠ¸
// =============================================================================

interface MainObjectiveProps {
  quest: Quest;
}

/** ì£¼ ëª©í‘œ ì˜ì—­ - ê°•ì¡° í‘œì‹œ + ì§„í–‰ë¥  + ë³´ìƒ */
function MainObjective({ quest }: MainObjectiveProps) {
  const { t } = useTranslation();

  return (
    <div
      className={`main-objective ${quest.is_completed ? 'main-objective--completed' : ''}`}
      data-ui-importance="critical"
    >
      <div className="main-objective__header">
        <span className="main-objective__icon" aria-hidden="true">
          ğŸ¯
        </span>
        <span className="main-objective__badge">{t('quest.main_objective')}</span>
      </div>
      <h4 className="main-objective__title">{quest.label}</h4>
      {quest.description && <p className="main-objective__desc">{quest.description}</p>}
      <ProgressBar value={quest.progress} />
      {quest.reward_signal > 0 && !quest.is_completed && (
        <div className="main-objective__reward">
          <span className="main-objective__reward-icon" aria-hidden="true">
            ğŸ’°
          </span>
          <span>{t('quest.reward_preview', { signal: quest.reward_signal })}</span>
        </div>
      )}
      {quest.is_completed && (
        <div className="main-objective__complete-badge">
          <span aria-hidden="true">âœ…</span>
          <span>{t('quest.objective_complete')}</span>
        </div>
      )}
    </div>
  );
}

// =============================================================================
// ì„œë¸Œ ëª©í‘œ í•˜ìœ„ ì»´í¬ë„ŒíŠ¸
// =============================================================================

interface SubObjectiveItemProps {
  quest: Quest;
}

/** ê°œë³„ ì„œë¸Œ ëª©í‘œ ì•„ì´í…œ */
function SubObjectiveItem({ quest }: SubObjectiveItemProps) {
  const { t } = useTranslation();

  return (
    <li
      className={`sub-objective ${quest.is_completed ? 'sub-objective--completed' : 'sub-objective--active'}`}
      data-quest-id={quest.id}
    >
      <span
        className={`sub-objective__check ${quest.is_completed ? 'sub-objective__check--done' : ''}`}
        aria-hidden="true"
      >
        {quest.is_completed ? 'âœ“' : 'â—‹'}
      </span>
      <span className="sub-objective__label">{quest.label}</span>
      {quest.reward_signal > 0 && !quest.is_completed && (
        <span
          className="sub-objective__reward"
          title={t('quest.reward_preview', { signal: quest.reward_signal })}
        >
          +{quest.reward_signal}âš¡
        </span>
      )}
      {quest.is_completed && quest.reward_signal > 0 && (
        <span className="sub-objective__earned">
          {t('quest.reward_earned', { signal: quest.reward_signal })}
        </span>
      )}
    </li>
  );
}

// =============================================================================
// ë©”ì¸ ì»´í¬ë„ŒíŠ¸
// =============================================================================

/**
 * Quest Panel - U-078 ëª©í‘œ ì‹œìŠ¤í…œ ê°•í™”
 *
 * ì£¼ ëª©í‘œ(Main Objective) + ì„œë¸Œ ëª©í‘œ(Sub-objectives)ë¥¼ ë¶„ë¦¬ í‘œì‹œí•©ë‹ˆë‹¤.
 * worldStoreì˜ quests ìƒíƒœë¥¼ êµ¬ë…í•˜ì—¬ ì‹¤ì‹œê°„ ì—…ë°ì´íŠ¸ë©ë‹ˆë‹¤.
 */
export function QuestPanel() {
  const { t } = useTranslation();
  const mainObjective = useWorldStore(selectMainObjective);
  const subObjectives = useWorldStore(useShallow(selectSubObjectives));

  const activeSubObjectives = subObjectives.filter((q) => !q.is_completed);
  const completedSubObjectives = subObjectives.filter((q) => q.is_completed);

  // ì£¼ ëª©í‘œë„ ì—†ê³  ì„œë¸Œ ëª©í‘œë„ ì—†ëŠ” ë¹ˆ ìƒíƒœ
  if (!mainObjective && subObjectives.length === 0) {
    return (
      <div className="quest-panel-content quest-empty" data-ui-importance="critical">
        <div className="quest-empty-icon" aria-hidden="true">
          ğŸ§­
        </div>
        <p className="quest-empty-text">{t('quest.free_exploration')}</p>
        <p className="quest-empty-hint">{t('quest.free_exploration_desc')}</p>
      </div>
    );
  }

  return (
    <div className="quest-panel-content" data-ui-importance="critical">
      {/* ì£¼ ëª©í‘œ ì˜ì—­ */}
      {mainObjective && <MainObjective quest={mainObjective} />}

      {/* ì„œë¸Œ ëª©í‘œ: ì§„í–‰ ì¤‘ */}
      {activeSubObjectives.length > 0 && (
        <div className="quest-section quest-section-active">
          <h4 className="quest-section-title">{t('quest.sub_objectives')}</h4>
          <ul className="sub-objective-list" role="list" aria-label={t('quest.sub_objectives')}>
            {activeSubObjectives.map((quest) => (
              <SubObjectiveItem key={quest.id} quest={quest} />
            ))}
          </ul>
        </div>
      )}

      {/* ì„œë¸Œ ëª©í‘œ: ì™„ë£Œë¨ */}
      {completedSubObjectives.length > 0 && (
        <div className="quest-section quest-section-completed">
          <h4 className="quest-section-title">{t('quest.section.completed')}</h4>
          <ul
            className="sub-objective-list sub-objective-list--completed"
            role="list"
            aria-label={t('quest.section.completed')}
          >
            {completedSubObjectives.map((quest) => (
              <SubObjectiveItem key={quest.id} quest={quest} />
            ))}
          </ul>
        </div>
      )}
    </div>
  );
}

export default QuestPanel;
</file>

<file path="frontend/src/components/RuleBoard.test.tsx">
import { describe, it, expect, beforeEach, vi } from 'vitest';
import { render, screen } from '@testing-library/react';
import { RuleBoard } from './RuleBoard';
import { useWorldStore } from '../stores/worldStore';

vi.mock('react-i18next', () => ({
  useTranslation: () => ({
    t: (key: string, options?: Record<string, unknown>) => {
      if (options?.count !== undefined) return `${key} (count: ${options.count})`;
      return key;
    },
  }),
  initReactI18next: {
    type: '3rdParty',
    init: () => {},
  },
}));

describe('RuleBoard (U-013)', () => {
  beforeEach(() => {
    useWorldStore.getState().reset();
  });

  it('ê·œì¹™ì´ ì—†ì„ ë•Œ ë¹ˆ ìƒíƒœë¥¼ í‘œì‹œí•´ì•¼ í•œë‹¤', () => {
    render(<RuleBoard />);
    expect(screen.getByText('rule_board.empty')).toBeInTheDocument();
  });

  it('í™œì„± ê·œì¹™ ëª©ë¡ì„ í‘œì‹œí•´ì•¼ í•œë‹¤', () => {
    useWorldStore.setState({
      activeRules: [
        { id: 'r1', label: 'ì¤‘ë ¥', description: 'ë–¨ì–´ì§„ë‹¤' },
        { id: 'r2', label: 'ì‚°ì†Œ', description: 'í•„ìš”í•˜ë‹¤' },
      ],
    });

    render(<RuleBoard />);
    expect(screen.getByText('rule_board.active_count (count: 2)')).toBeInTheDocument();
    expect(screen.getByText('ì¤‘ë ¥')).toBeInTheDocument();
    expect(screen.getByText('ë–¨ì–´ì§„ë‹¤')).toBeInTheDocument();
    expect(screen.getByText('ì‚°ì†Œ')).toBeInTheDocument();
  });
});
</file>

<file path="frontend/src/components/SceneCanvas.hotspot.test.tsx">
import { describe, it, expect, vi, beforeEach } from 'vitest';
import { render, screen, fireEvent, act } from '@testing-library/react';
import { SceneCanvas } from './SceneCanvas';
import type { SceneObject } from '../schemas/turn';
import type { SceneCanvasState } from '../types/scene';
import { useWorldStore } from '../stores/worldStore';
import { useAgentStore } from '../stores/agentStore';

// i18next ëª¨í‚¹
vi.mock('react-i18next', () => ({
  useTranslation: () => ({
    t: (key: string) => key,
  }),
  initReactI18next: {
    type: '3rdParty',
    init: () => {},
  },
}));

// ResizeObserver ëª¨í‚¹
let resizeCallback: (entries: ResizeObserverEntry[]) => void;
class MockResizeObserver {
  constructor(callback: (entries: ResizeObserverEntry[]) => void) {
    resizeCallback = callback;
  }
  observe = vi.fn();
  unobserve = vi.fn();
  disconnect = vi.fn();
}

global.ResizeObserver = MockResizeObserver as unknown as typeof ResizeObserver;

/**
 * ë¦¬ì‚¬ì´ì¦ˆ ì´ë²¤íŠ¸ë¥¼ ìˆ˜ë™ìœ¼ë¡œ íŠ¸ë¦¬ê±°í•©ë‹ˆë‹¤.
 */
function triggerResize(width: number, height: number) {
  if (resizeCallback) {
    act(() => {
      resizeCallback([
        {
          contentRect: { width, height } as DOMRectReadOnly,
          target: document.querySelector('.scene-canvas') as Element,
        } as ResizeObserverEntry,
      ]);
    });
  }
}

// getBoundingClientRect ëª¨í‚¹
Element.prototype.getBoundingClientRect = vi.fn(() => ({
  width: 800,
  height: 600,
  top: 0,
  left: 0,
  bottom: 600,
  right: 800,
  x: 0,
  y: 0,
  toJSON: () => {},
})) as unknown as () => DOMRect;

describe('SceneCanvas Hotspots', () => {
  const defaultState: SceneCanvasState = {
    status: 'scene',
    imageUrl: 'https://example.com/scene.png',
  };

  const mockObjects: SceneObject[] = [
    {
      id: 'obj-1',
      label: 'Object 1',
      box_2d: { ymin: 100, xmin: 100, ymax: 200, xmax: 200 },
      interaction_hint: 'Click me',
    },
    {
      id: 'obj-2',
      label: 'Object 2',
      box_2d: { ymin: 500, xmin: 500, ymax: 700, xmax: 700 },
      interaction_hint: null,
    },
  ];

  beforeEach(() => {
    vi.clearAllMocks();
    // ìŠ¤í† ì–´ ì´ˆê¸°í™”
    useWorldStore.setState({
      sceneState: { status: 'default', message: '' },
      sceneObjects: [],
    });
    useAgentStore.setState({ isStreaming: false });
  });

  it('should render hotspots when objects are provided in worldStore and status is scene (sorted by area)', () => {
    useWorldStore.setState({
      sceneState: defaultState,
      sceneObjects: mockObjects,
    });

    render(<SceneCanvas />);

    // í•«ìŠ¤íŒŸ ë ˆì´ì–´ í™•ì¸
    const layer = screen.getByLabelText('scene.hotspot.layer_label');
    expect(layer).toBeInTheDocument();

    // ê°œë³„ í•«ìŠ¤íŒŸ í™•ì¸ (role="button")
    // RU-003-S2: ë©´ì  ê¸°ë°˜ ì •ë ¬ - í° ê²ƒì´ ë¨¼ì € ë Œë”ë§ë˜ì–´ ë‚®ì€ z-indexë¥¼ ê°€ì§
    // Object 1: 100x100 = 10,000
    // Object 2: 200x200 = 40,000
    // ë”°ë¼ì„œ Object 2ê°€ ë¨¼ì € ì˜¤ê³  Object 1ì´ ë‚˜ì¤‘ì— ì˜´
    const buttons = screen.getAllByRole('button');
    expect(buttons).toHaveLength(mockObjects.length);
    expect(buttons[0]).toHaveAttribute('aria-label', 'Object 2');
    expect(buttons[1]).toHaveAttribute('aria-label', 'Object 1');

    // z-index í™•ì¸ (RU-003-S2: HotspotOverlay ìì²´ì— styleë¡œ ì ìš©ë¨)
    expect(buttons[0]).toHaveStyle({ zIndex: '1' });
    expect(buttons[1]).toHaveStyle({ zIndex: '2' });
  });

  it('should not render hotspots when status is loading', () => {
    useWorldStore.setState({
      sceneState: { status: 'loading' },
      sceneObjects: mockObjects,
    });

    render(<SceneCanvas />);

    const layer = screen.queryByLabelText('scene.hotspot.layer_label');
    expect(layer).not.toBeInTheDocument();
  });

  it('should call onHotspotClick when a hotspot is clicked', () => {
    const onHotspotClick = vi.fn();
    useWorldStore.setState({
      sceneState: defaultState,
      sceneObjects: mockObjects,
    });

    render(<SceneCanvas onHotspotClick={onHotspotClick} />);

    const firstHotspot = screen.getByLabelText('Object 1');
    fireEvent.click(firstHotspot);

    expect(onHotspotClick).toHaveBeenCalledWith({
      object_id: 'obj-1',
      box_2d: mockObjects[0].box_2d,
    });
  });

  it('should show tooltip on hover', async () => {
    useWorldStore.setState({
      sceneState: defaultState,
      sceneObjects: mockObjects,
    });

    render(<SceneCanvas />);

    const firstHotspot = screen.getByLabelText('Object 1');

    // Hover ì‹œì‘
    fireEvent.mouseEnter(firstHotspot);

    // íˆ´íŒ ë¼ë²¨ í™•ì¸
    expect(screen.getByText('Object 1')).toBeInTheDocument();
    expect(screen.getByText(/scene.hotspot.hint_prefix/)).toBeInTheDocument();
    expect(screen.getByText(/Click me/)).toBeInTheDocument();

    // Hover ì¢…ë£Œ
    fireEvent.mouseLeave(firstHotspot);
    expect(screen.queryByText('Object 1')).not.toBeInTheDocument();
  });

  it('should be disabled when agentStore.isStreaming is true', () => {
    const onHotspotClick = vi.fn();
    useWorldStore.setState({
      sceneState: defaultState,
      sceneObjects: mockObjects,
    });
    useAgentStore.setState({ isStreaming: true });

    render(<SceneCanvas onHotspotClick={onHotspotClick} />);

    const firstHotspot = screen.getByLabelText('Object 1');
    expect(firstHotspot).toHaveAttribute('aria-disabled', 'true');
    expect(firstHotspot).toHaveAttribute('tabindex', '-1');

    fireEvent.click(firstHotspot);
    expect(onHotspotClick).not.toHaveBeenCalled();
  });

  it('should reposition hotspots when canvas size changes (reactive resize)', async () => {
    vi.useFakeTimers();
    useWorldStore.setState({
      sceneState: defaultState,
      sceneObjects: mockObjects,
    });

    render(<SceneCanvas />);

    // Object 1 ì°¾ê¸° (ì •ë ¬ì— ì˜í•´ ë‘ ë²ˆì§¸ ë²„íŠ¼ì¼ ìˆ˜ ìˆìŒ)
    const firstHotspot = screen.getByLabelText('Object 1');

    // ì´ˆê¸° í¬ê¸° (800x600) ê¸°ë°˜ ìœ„ì¹˜ í™•ì¸
    expect(firstHotspot).toHaveStyle({
      top: '60px',
      left: '80px',
      width: '80px',
      height: '60px',
    });

    // í¬ê¸° ë³€ê²½ íŠ¸ë¦¬ê±° (400x300)
    triggerResize(400, 300);

    // RU-003-S2: ResizeObserver ë””ë°”ìš´ìŠ¤(100ms) ëŒ€ê¸°
    act(() => {
      vi.advanceTimersByTime(150);
    });

    // ë³€ê²½ëœ í¬ê¸° ê¸°ë°˜ ìœ„ì¹˜ í™•ì¸
    expect(firstHotspot).toHaveStyle({
      top: '30px',
      left: '40px',
      width: '40px',
      height: '30px',
    });

    vi.useRealTimers();
  });
});
</file>

<file path="frontend/src/components/SceneCanvas.test.tsx">
import { describe, it, expect } from 'vitest';
import { SCENE_PLACEHOLDERS } from './SceneImage';

describe('SCENE_PLACEHOLDERS', () => {
  it('should have all required statuses', () => {
    const statuses = ['default', 'loading', 'offline', 'blocked', 'low_signal'];
    statuses.forEach((status) => {
      expect(SCENE_PLACEHOLDERS).toHaveProperty(status);
    });
  });

  it('should have correct image paths', () => {
    expect(SCENE_PLACEHOLDERS.default.imagePath).toBe(
      '/ui/placeholders/scene-placeholder-default.png',
    );
    expect(SCENE_PLACEHOLDERS.loading.imagePath).toBe('/ui/placeholders/scene-loading.webp');
    expect(SCENE_PLACEHOLDERS.offline.imagePath).toBe('/ui/placeholders/scene-offline.webp');
    expect(SCENE_PLACEHOLDERS.blocked.imagePath).toBe('/ui/placeholders/scene-blocked.webp');
    expect(SCENE_PLACEHOLDERS.low_signal.imagePath).toBe('/ui/placeholders/scene-low-signal.webp');
  });

  it('should have correct i18n label keys', () => {
    expect(SCENE_PLACEHOLDERS.default.labelKey).toBe('scene.status.default');
    expect(SCENE_PLACEHOLDERS.loading.labelKey).toBe('scene.status.loading');
    expect(SCENE_PLACEHOLDERS.offline.labelKey).toBe('scene.status.offline');
    expect(SCENE_PLACEHOLDERS.blocked.labelKey).toBe('scene.status.blocked');
    expect(SCENE_PLACEHOLDERS.low_signal.labelKey).toBe('scene.status.low_signal');
  });
});
</file>

<file path="frontend/src/data/itemIconPresets.ts">
/**
 * Unknown World - ì•„ì´í…œ ì•„ì´ì½˜ í”„ë¦¬ì…‹ ë ˆì§€ìŠ¤íŠ¸ë¦¬ (U-092[Mvp]).
 *
 * nanobanana mcpë¡œ ì‚¬ì „ ì œì‘ëœ ì•„ì´í…œ ì•„ì´ì½˜ì˜ ë§¤í•‘ í…Œì´ë¸”ì…ë‹ˆë‹¤.
 * ì´ˆê¸° ë°ëª¨ í”„ë¡œí•„ ì•„ì´í…œ + ìì£¼ ë“±ì¥í•˜ëŠ” ê³µí†µ ì•„ì´í…œì„ í¬í•¨í•©ë‹ˆë‹¤.
 *
 * ì„¤ê³„ ì›ì¹™:
 *   - RULE-007: nanobanana mcpëŠ” ê°œë°œ/ì—ì…‹ ì œì‘ìš©ìœ¼ë¡œë§Œ ì‚¬ìš© (ì •ì  ë°°í¬)
 *   - Q2 ê²°ì •: icon_urlì´ ìˆìœ¼ë©´ í•­ìƒ í”„ë¦¬ì…‹ ìš°ì„  (ë™ì  ìƒì„± ê±´ë„ˆë›°ê¸°)
 *   - ì—ì…‹ SSOT: frontend/public/ui/items/ ê²½ë¡œ, kebab-case, 64x64 PNG
 *
 * @module data/itemIconPresets
 */

// =============================================================================
// í”„ë¦¬ì…‹ ì•„ì´ì½˜ ê²½ë¡œ ìƒìˆ˜
// =============================================================================

/** ì•„ì´í…œ ì•„ì´ì½˜ ì—ì…‹ ê¸°ë³¸ ê²½ë¡œ (public ë””ë ‰í† ë¦¬ ê¸°ì¤€) */
const ITEMS_BASE = '/ui/items';

// =============================================================================
// í”„ë¦¬ì…‹ ë ˆì§€ìŠ¤íŠ¸ë¦¬
// =============================================================================

/**
 * ì•„ì´í…œ ID â†’ í”„ë¦¬ì…‹ ì•„ì´ì½˜ URL ë§¤í•‘.
 *
 * í‚¤: ì•„ì´í…œ ID (kebab-case, demoProfiles ë° GM ì¶œë ¥ì—ì„œ ì‚¬ìš©í•˜ëŠ” ID)
 * ê°’: ì •ì  ì—ì…‹ URL ê²½ë¡œ (/ui/items/xxx-64.png)
 *
 * ê²Œì„ ë„ì¤‘ GMì´ ìƒì„±í•˜ëŠ” ì•„ì´í…œì˜ IDê°€ ì´ ë§µì— ì¡´ì¬í•˜ë©´
 * ë™ì  ìƒì„±ì„ ê±´ë„ˆë›°ê³  í”„ë¦¬ì…‹ ì•„ì´ì½˜ì„ ì¦‰ì‹œ ì‚¬ìš©í•©ë‹ˆë‹¤.
 */
export const ITEM_ICON_PRESETS: Readonly<Record<string, string>> = {
  // â”€â”€â”€ ì´ˆê¸° ì•„ì´í…œ: Narrator í”„ë¡œí•„ â”€â”€â”€
  'ancient-tome': `${ITEMS_BASE}/ancient-tome-64.png`,
  'quill-pen': `${ITEMS_BASE}/quill-pen-64.png`,
  'memory-fragment': `${ITEMS_BASE}/memory-fragment-64.png`,

  // â”€â”€â”€ ì´ˆê¸° ì•„ì´í…œ: Explorer í”„ë¡œí•„ â”€â”€â”€
  compass: `${ITEMS_BASE}/compass-64.png`,
  rope: `${ITEMS_BASE}/rope-64.png`,
  lantern: `${ITEMS_BASE}/lantern-64.png`,
  'map-fragment': `${ITEMS_BASE}/map-fragment-64.png`,

  // â”€â”€â”€ ì´ˆê¸° ì•„ì´í…œ: Tech Enthusiast í”„ë¡œí•„ â”€â”€â”€
  'data-core': `${ITEMS_BASE}/data-core-64.png`,
  'circuit-board': `${ITEMS_BASE}/circuit-board-64.png`,
  'energy-cell': `${ITEMS_BASE}/energy-cell-64.png`,
  'scanner-device': `${ITEMS_BASE}/scanner-device-64.png`,

  // â”€â”€â”€ ê³µí†µ ì•„ì´í…œ (ê²Œì„ ì¤‘ ìì£¼ ë“±ì¥) â”€â”€â”€
  sword: `${ITEMS_BASE}/sword-64.png`,
  shield: `${ITEMS_BASE}/shield-64.png`,
  potion: `${ITEMS_BASE}/potion-64.png`,
  key: `${ITEMS_BASE}/key-64.png`,
  gem: `${ITEMS_BASE}/gem-64.png`,
  scroll: `${ITEMS_BASE}/scroll-64.png`,
  torch: `${ITEMS_BASE}/torch-64.png`,
  herb: `${ITEMS_BASE}/herb-64.png`,
  coin: `${ITEMS_BASE}/coin-64.png`,
  ring: `${ITEMS_BASE}/ring-64.png`,
  amulet: `${ITEMS_BASE}/amulet-64.png`,
  dagger: `${ITEMS_BASE}/dagger-64.png`,
  flask: `${ITEMS_BASE}/flask-64.png`,
  crystal: `${ITEMS_BASE}/crystal-64.png`,
  lockpick: `${ITEMS_BASE}/lockpick-64.png`,
} as const;

// =============================================================================
// ìœ í‹¸ë¦¬í‹° í•¨ìˆ˜
// =============================================================================

/**
 * ì•„ì´í…œ IDë¡œ í”„ë¦¬ì…‹ ì•„ì´ì½˜ URLì„ ì¡°íšŒí•©ë‹ˆë‹¤.
 *
 * @param itemId - ì•„ì´í…œ ID (kebab-case)
 * @returns í”„ë¦¬ì…‹ ì•„ì´ì½˜ URL ë˜ëŠ” undefined (í”„ë¦¬ì…‹ ì—†ìŒ)
 */
export function getPresetIconUrl(itemId: string): string | undefined {
  // ì •í™•í•œ ID ë§¤ì¹­
  if (itemId in ITEM_ICON_PRESETS) {
    return ITEM_ICON_PRESETS[itemId];
  }

  // ë¶€ë¶„ ë§¤ì¹­: ì•„ì´í…œ IDì— í”„ë¦¬ì…‹ í‚¤ê°€ í¬í•¨ëœ ê²½ìš° (ì˜ˆ: "rusty-sword" â†’ "sword")
  for (const [key, url] of Object.entries(ITEM_ICON_PRESETS)) {
    if (itemId.includes(key)) {
      return url;
    }
  }

  return undefined;
}

/**
 * ì•„ì´í…œ IDì— í”„ë¦¬ì…‹ ì•„ì´ì½˜ì´ ì¡´ì¬í•˜ëŠ”ì§€ í™•ì¸í•©ë‹ˆë‹¤.
 *
 * @param itemId - ì•„ì´í…œ ID
 * @returns í”„ë¦¬ì…‹ ì¡´ì¬ ì—¬ë¶€
 */
export function hasPresetIcon(itemId: string): boolean {
  return getPresetIconUrl(itemId) !== undefined;
}
</file>

<file path="frontend/src/demo/demoFixtures.ts">
/**
 * Unknown World - ë°ëª¨ìš© Fixtures (RU-003-Q5)
 *
 * DEV í™˜ê²½ì—ì„œ ì‚¬ìš©í•˜ëŠ” ë°ëª¨ ì´ˆê¸° ë°ì´í„°ì…ë‹ˆë‹¤.
 * ì–¸ì–´ ì¤‘ë¦½ì ì¸ ê°’(ID/ì•„ì´ì½˜/ìˆ˜ëŸ‰/ì¢Œí‘œ)ë§Œ í¬í•¨í•˜ë©°,
 * í‘œì‹œ ë¬¸ìì—´(name/label/hint)ì€ i18n í‚¤ë¥¼ í†µí•´ ë Œë”ë§í•©ë‹ˆë‹¤.
 *
 * ì„¤ê³„ ì›ì¹™:
 *   - RULE-006: ko/en í˜¼í•© ì¶œë ¥ ê¸ˆì§€ (i18n í‚¤ ê¸°ë°˜)
 *   - PRD 6.9: ë°ëª¨ í”„ë¡œí•„ ê²½ê³„ í™•ë³´
 *   - ì„œë²„ TurnOutput ëŒ€ì²´ ì‹œ ì´ ëª¨ë“ˆ ë¹„í™œì„±í™” ê°€ëŠ¥
 *
 * @module demo/demoFixtures
 */

import type { Box2D } from '../schemas/turn';

// =============================================================================
// íƒ€ì… ì •ì˜
// =============================================================================

/**
 * ë°ëª¨ ì¸ë²¤í† ë¦¬ ì•„ì´í…œ ì •ì˜ (ì–¸ì–´ ì¤‘ë¦½)
 *
 * nameì€ i18n í‚¤(`demo.items.{id}.name`)ë¡œ ë Œë”ë§í•©ë‹ˆë‹¤.
 */
export interface DemoInventoryItemDef {
  /** ì•„ì´í…œ ê³ ìœ  ID */
  id: string;
  /** ì•„ì´í…œ ì•„ì´ì½˜ (ì´ëª¨ì§€ ë˜ëŠ” URL) */
  icon: string;
  /** ì´ˆê¸° ìˆ˜ëŸ‰ */
  quantity: number;
}

/**
 * ë°ëª¨ ì”¬ ì˜¤ë¸Œì íŠ¸ ì •ì˜ (ì–¸ì–´ ì¤‘ë¦½)
 *
 * label/hintëŠ” i18n í‚¤ë¡œ ë Œë”ë§í•©ë‹ˆë‹¤:
 * - labelKey: `demo.scene.{id}.label`
 * - hintKey: `demo.scene.{id}.hint`
 */
export interface DemoSceneObjectDef {
  /** ì˜¤ë¸Œì íŠ¸ ê³ ìœ  ID */
  id: string;
  /** ë°”ìš´ë”© ë°•ìŠ¤ (0~1000 ì •ê·œí™”) */
  box_2d: Box2D;
  /** i18n ë¼ë²¨ í‚¤ */
  labelKey: string;
  /** i18n íŒíŠ¸ í‚¤ */
  hintKey: string;
}

// =============================================================================
// ë°ëª¨ ì¸ë²¤í† ë¦¬ ì•„ì´í…œ
// =============================================================================

/**
 * ë°ëª¨ìš© ì¸ë²¤í† ë¦¬ ì•„ì´í…œ ëª©ë¡.
 *
 * @remarks
 * - ID/ì•„ì´ì½˜/ìˆ˜ëŸ‰ë§Œ ì •ì˜ (ì–¸ì–´ ì¤‘ë¦½)
 * - í‘œì‹œ ì´ë¦„ì€ `demo.items.{id}.name` í‚¤ë¡œ i18n ì²˜ë¦¬
 */
export const DEMO_INVENTORY_ITEMS: readonly DemoInventoryItemDef[] = [
  { id: 'keycard-alpha', icon: 'ğŸ”‘', quantity: 1 },
  { id: 'medkit', icon: 'ğŸ©¹', quantity: 2 },
  { id: 'flashlight', icon: 'ğŸ”¦', quantity: 1 },
  { id: 'data-chip', icon: 'ğŸ’¾', quantity: 3 },
] as const;

// =============================================================================
// ë°ëª¨ ì”¬ ì˜¤ë¸Œì íŠ¸
// =============================================================================

/**
 * ë°ëª¨ìš© ì”¬ ì˜¤ë¸Œì íŠ¸ ëª©ë¡.
 *
 * @remarks
 * - ID/ì¢Œí‘œë§Œ ì •ì˜ (ì–¸ì–´ ì¤‘ë¦½)
 * - í‘œì‹œ ë¼ë²¨/íŒíŠ¸ëŠ” i18n í‚¤ë¡œ ì²˜ë¦¬
 */
export const DEMO_SCENE_OBJECTS: readonly DemoSceneObjectDef[] = [
  {
    id: 'demo-terminal',
    box_2d: { ymin: 300, xmin: 100, ymax: 600, xmax: 400 },
    labelKey: 'demo.scene.terminal.label',
    hintKey: 'demo.scene.terminal.hint',
  },
  {
    id: 'demo-door',
    box_2d: { ymin: 200, xmin: 600, ymax: 800, xmax: 900 },
    labelKey: 'demo.scene.door.label',
    hintKey: 'demo.scene.door.hint',
  },
] as const;

// =============================================================================
// ë°ëª¨ í€˜ìŠ¤íŠ¸ (U-013)
// =============================================================================

/**
 * ë°ëª¨ í€˜ìŠ¤íŠ¸ ì •ì˜ (ì–¸ì–´ ì¤‘ë¦½)
 *
 * labelì€ i18n í‚¤(`demo.quest.{id}.label`)ë¡œ ë Œë”ë§í•©ë‹ˆë‹¤.
 */
export interface DemoQuestDef {
  /** í€˜ìŠ¤íŠ¸ ê³ ìœ  ID */
  id: string;
  /** i18n ë¼ë²¨ í‚¤ */
  labelKey: string;
  /** ì™„ë£Œ ì—¬ë¶€ */
  is_completed: boolean;
  /** i18n ì„¤ëª… í‚¤ (ì„ íƒ, U-078) */
  descriptionKey?: string;
  /** ì£¼ ëª©í‘œ ì—¬ë¶€ (U-078) */
  is_main?: boolean;
  /** ì§„í–‰ë¥  0~100 (U-078) */
  progress?: number;
  /** Signal ë³´ìƒëŸ‰ (U-078) */
  reward_signal?: number;
}

/**
 * ë°ëª¨ìš© í€˜ìŠ¤íŠ¸ ëª©ë¡ (U-078: ëª©í‘œ ì‹œìŠ¤í…œ ê°•í™”).
 */
export const DEMO_QUESTS: readonly DemoQuestDef[] = [
  {
    id: 'demo-quest-terminal',
    labelKey: 'demo.quest.terminal.label',
    descriptionKey: 'demo.quest.terminal.description',
    is_completed: false,
    is_main: true,
    progress: 30,
    reward_signal: 50,
  },
  {
    id: 'demo-quest-escape',
    labelKey: 'demo.quest.escape.label',
    is_completed: false,
    is_main: false,
    progress: 0,
    reward_signal: 20,
  },
  {
    id: 'demo-quest-collect',
    labelKey: 'demo.quest.collect.label',
    is_completed: true,
    is_main: false,
    progress: 100,
    reward_signal: 10,
  },
] as const;

// =============================================================================
// ë°ëª¨ ê·œì¹™ (U-013)
// =============================================================================

/**
 * ë°ëª¨ ê·œì¹™ ì •ì˜ (ì–¸ì–´ ì¤‘ë¦½)
 *
 * label/descriptionì€ i18n í‚¤ë¡œ ë Œë”ë§í•©ë‹ˆë‹¤.
 */
export interface DemoRuleDef {
  /** ê·œì¹™ ê³ ìœ  ID */
  id: string;
  /** i18n ë¼ë²¨ í‚¤ */
  labelKey: string;
  /** i18n ì„¤ëª… í‚¤ (ì„ íƒ) */
  descriptionKey?: string;
}

/**
 * ë°ëª¨ìš© ê·œì¹™ ëª©ë¡.
 */
export const DEMO_RULES: readonly DemoRuleDef[] = [
  {
    id: 'demo-rule-gravity',
    labelKey: 'demo.rule.gravity.label',
    descriptionKey: 'demo.rule.gravity.description',
  },
  {
    id: 'demo-rule-time',
    labelKey: 'demo.rule.time.label',
    descriptionKey: 'demo.rule.time.description',
  },
] as const;

// =============================================================================
// í—¬í¼ í•¨ìˆ˜
// =============================================================================

/**
 * ë°ëª¨ ì¸ë²¤í† ë¦¬ ì•„ì´í…œì˜ i18n ì´ë¦„ í‚¤ë¥¼ ìƒì„±í•©ë‹ˆë‹¤.
 *
 * @param itemId - ì•„ì´í…œ ID
 * @returns i18n í‚¤ (ì˜ˆ: `demo.items.keycard-alpha.name`)
 */
export function getDemoItemNameKey(itemId: string): string {
  return `demo.items.${itemId}.name`;
}

/**
 * ë°ëª¨ í™˜ê²½ì¸ì§€ í™•ì¸í•©ë‹ˆë‹¤ (DEV ê°€ë“œ).
 *
 * @returns DEV í™˜ê²½ ì—¬ë¶€
 */
export function isDemoEnvironment(): boolean {
  return import.meta.env.DEV;
}

/**
 * DOMì—ì„œ í˜„ì¬ í…Œë§ˆë¥¼ ì½ìŠµë‹ˆë‹¤.
 *
 * RU-003-Q5: 'dark' í•˜ë“œì½”ë”© ì œê±°
 * - data-theme ì†ì„±ì„ í™•ì¸í•˜ì—¬ í…Œë§ˆ ê²°ì •
 * - 'crt', 'dark' ë˜ëŠ” ë¯¸ì§€ì • â†’ 'dark'
 * - 'light' â†’ 'light'
 *
 * @returns í˜„ì¬ í…Œë§ˆ ('dark' | 'light')
 */
export function getCurrentThemeFromDOM(): 'dark' | 'light' {
  const dataTheme = document.documentElement.getAttribute('data-theme');

  // 'crt' í…Œë§ˆëŠ” dark ê³„ì—´ë¡œ ì·¨ê¸‰
  if (dataTheme === 'light') {
    return 'light';
  }
  return 'dark';
}
</file>

<file path="frontend/src/save/migrations.test.ts">
import { describe, it, expect } from 'vitest';
import { extractVersion, upgradeToLatest, isMigratableVersion } from './migrations';
import { SAVEGAME_VERSION } from './constants';

describe('SaveGame Migrations (U-041[Mvp])', () => {
  describe('extractVersion', () => {
    it('ê°ì²´ì—ì„œ version í•„ë“œë¥¼ ì˜¬ë°”ë¥´ê²Œ ì¶”ì¶œí•´ì•¼ í•œë‹¤', () => {
      expect(extractVersion({ version: '1.0.0' })).toBe('1.0.0');
      expect(extractVersion({ version: '0.9.0' })).toBe('0.9.0');
    });

    it('ìœ íš¨í•˜ì§€ ì•Šì€ ì…ë ¥ì— ëŒ€í•´ nullì„ ë°˜í™˜í•´ì•¼ í•œë‹¤', () => {
      expect(extractVersion(null)).toBeNull();
      expect(extractVersion(undefined)).toBeNull();
      expect(extractVersion('string')).toBeNull();
      expect(extractVersion({})).toBeNull();
      expect(extractVersion({ ver: '1.0.0' })).toBeNull();
    });
  });

  describe('isMigratableVersion', () => {
    it('ì§€ì›ë˜ëŠ” ë²„ì „ì— ëŒ€í•´ trueë¥¼ ë°˜í™˜í•´ì•¼ í•œë‹¤', () => {
      expect(isMigratableVersion('0.9.0')).toBe(true);
      expect(isMigratableVersion('1.0.0')).toBe(true);
    });

    it('ì§€ì›ë˜ì§€ ì•ŠëŠ” ë²„ì „ì— ëŒ€í•´ falseë¥¼ ë°˜í™˜í•´ì•¼ í•œë‹¤', () => {
      expect(isMigratableVersion('0.1.0')).toBe(false);
      expect(isMigratableVersion('unknown')).toBe(false);
    });
  });

  describe('upgradeToLatest (0.9.0 -> 1.0.0)', () => {
    it('0.9.0 ë°ì´í„°ë¥¼ 1.0.0ìœ¼ë¡œ ì˜¬ë°”ë¥´ê²Œ ë³€í™˜í•´ì•¼ í•œë‹¤', () => {
      const oldData = {
        version: '0.9.0',
        language: 'ko-KR',
        economy: {
          signal: 50,
          memory_shards: 3, // êµ¬ë²„ì „ ì˜¤íƒ€ í•„ë“œ
        },
        // sceneObjects, economyLedger, mutationTimeline ëˆ„ë½ë¨
      };

      const result = upgradeToLatest(oldData, '0.9.0');

      expect(result.success).toBe(true);
      if (result.success) {
        const migrated = result.data as Record<string, unknown>;
        const economy = migrated.economy as Record<string, unknown>;
        expect(migrated.version).toBe('1.0.0');
        expect(economy.signal).toBe(50);
        expect(economy.memory_shard).toBe(3); // ì˜¤íƒ€ ìˆ˜ì •ë¨
        expect(economy.memory_shards).toBeUndefined();
        expect(migrated.sceneObjects).toEqual([]);
        expect(migrated.economyLedger).toEqual([]);
        expect(migrated.mutationTimeline).toEqual([]);
        expect(result.appliedMigrations).toContain('0.9.0 â†’ 1.0.0');
      }
    });

    it('ì˜ëª»ëœ economy ë°ì´í„°ê°€ ìˆì„ ê²½ìš° ê¸°ë³¸ê°’ìœ¼ë¡œ ë³´ì •í•´ì•¼ í•œë‹¤', () => {
      const brokenData = {
        version: '0.9.0',
        economy: {
          signal: -10, // ìŒìˆ˜
          memory_shard: 'invalid', // íƒ€ì… ì˜¤ë¥˜
        },
      };

      const result = upgradeToLatest(brokenData, '0.9.0');

      expect(result.success).toBe(true);
      if (result.success) {
        const migrated = result.data as Record<string, unknown>;
        const economy = migrated.economy as Record<string, unknown>;
        expect(economy.signal).toBe(100); // ê¸°ë³¸ê°’
        expect(economy.memory_shard).toBe(5); // ê¸°ë³¸ê°’
      }
    });

    it('ì´ë¯¸ ìµœì‹  ë²„ì „ì¸ ê²½ìš° ê·¸ëŒ€ë¡œ ë°˜í™˜í•´ì•¼ í•œë‹¤', () => {
      const currentData = { version: SAVEGAME_VERSION, language: 'en-US' };
      const result = upgradeToLatest(currentData, SAVEGAME_VERSION);

      expect(result.success).toBe(true);
      if (result.success) {
        expect(result.data).toBe(currentData);
        expect(result.appliedMigrations).toHaveLength(0);
      }
    });

    it('ì§€ì›ë˜ì§€ ì•ŠëŠ” ë²„ì „ì¸ ê²½ìš° ì‹¤íŒ¨ë¥¼ ë°˜í™˜í•´ì•¼ í•œë‹¤', () => {
      const result = upgradeToLatest({ version: '0.1.0' }, '0.1.0');
      expect(result.success).toBe(false);
      if (!result.success) {
        expect(result.error).toContain('Unsupported version');
      }
    });
  });
});
</file>

<file path="frontend/src/save/migrations.ts">
/**
 * Unknown World - SaveGame ë²„ì „ ë§ˆì´ê·¸ë ˆì´ì…˜ ëª¨ë“ˆ (U-041[Mvp]).
 *
 * SaveGame ìŠ¤í‚¤ë§ˆê°€ ë³€ê²½ë˜ì–´ë„ ê¸°ì¡´ ì €ì¥ ë°ì´í„°ë¥¼ ìµœì‹  ë²„ì „ìœ¼ë¡œ ë³€í™˜í•˜ì—¬
 * ë°ëª¨ ë£¨í”„ê°€ ëŠê¸°ì§€ ì•Šë„ë¡ í•©ë‹ˆë‹¤.
 *
 * ì„¤ê³„ ì›ì¹™:
 *   - RULE-005: economy ë§ˆì´ê·¸ë ˆì´ì…˜ ì‹œ ì”ì•¡ ìŒìˆ˜ ê¸ˆì§€
 *   - RULE-010: ë²„ì „/ìŠ¤íƒ ê³ ì •, ì„ì˜ ë³€ê²½ ê¸ˆì§€
 *   - U-041: "ë²„ì „ íŒë³„ â†’ ë§ˆì´ê·¸ë ˆì´ì…˜ â†’ ê²€ì¦" íë¦„
 *
 * @module save/migrations
 */

import { SAVEGAME_VERSION, SUPPORTED_SAVEGAME_VERSIONS } from './constants';

// =============================================================================
// íƒ€ì… ì •ì˜
// =============================================================================

/**
 * ë‹¨ì¼ ë§ˆì´ê·¸ë ˆì´ì…˜ ë‹¨ê³„.
 *
 * from ë²„ì „ì—ì„œ to ë²„ì „ìœ¼ë¡œ SaveGame ë°ì´í„°ë¥¼ ë³€í™˜í•©ë‹ˆë‹¤.
 */
export interface Migration {
  /** ì†ŒìŠ¤ ë²„ì „ */
  from: string;
  /** íƒ€ê²Ÿ ë²„ì „ */
  to: string;
  /** ë³€í™˜ í•¨ìˆ˜ - unknown ì…ë ¥ì„ ë°›ì•„ unknown ì¶œë ¥ (ìŠ¤í‚¤ë§ˆ ê²€ì¦ì€ ìµœì¢… ë‹¨ê³„ì—ì„œ) */
  migrate: (input: unknown) => unknown;
  /** ë§ˆì´ê·¸ë ˆì´ì…˜ ì„¤ëª… (ë¡œê¹…/ë””ë²„ê·¸ìš©) */
  description: string;
}

/**
 * ë§ˆì´ê·¸ë ˆì´ì…˜ ê²°ê³¼.
 */
export interface MigrationResult {
  success: true;
  data: unknown;
  migratedFrom: string;
  migratedTo: string;
  appliedMigrations: string[];
}

/**
 * ë§ˆì´ê·¸ë ˆì´ì…˜ ì‹¤íŒ¨ ê²°ê³¼.
 */
export interface MigrationFailure {
  success: false;
  error: string;
  originalVersion: string;
}

export type MigrationOutcome = MigrationResult | MigrationFailure;

// =============================================================================
// ë§ˆì´ê·¸ë ˆì´ì…˜ ì²´ì¸ ì •ì˜
// =============================================================================

/**
 * ë²„ì „ ìˆœì„œ ë§µ.
 *
 * ë§ˆì´ê·¸ë ˆì´ì…˜ ê²½ë¡œë¥¼ ê²°ì •í•˜ê¸° ìœ„í•œ ë²„ì „ ìˆœì„œì…ë‹ˆë‹¤.
 * ë‚®ì€ ì¸ë±ìŠ¤ = ë” ì˜¤ë˜ëœ ë²„ì „
 */
const VERSION_ORDER: readonly string[] = [
  '0.9.0', // ì˜ˆì‹œ êµ¬ë²„ì „ (í…ŒìŠ¤íŠ¸/ë°ëª¨ìš©)
  '1.0.0', // í˜„ì¬ ë²„ì „
] as const;

/**
 * ë²„ì „ë³„ ë§ˆì´ê·¸ë ˆì´ì…˜ ì •ì˜.
 *
 * ê° ë§ˆì´ê·¸ë ˆì´ì…˜ì€ from â†’ to ë³€í™˜ì„ ì •ì˜í•©ë‹ˆë‹¤.
 * ì²´ì¸ìœ¼ë¡œ ì—°ê²°ë˜ì–´ ì—¬ëŸ¬ ë²„ì „ì„ ê±´ë„ˆë›°ì–´ë„ ìˆœì°¨ ì ìš©ë©ë‹ˆë‹¤.
 */
const MIGRATIONS: readonly Migration[] = [
  {
    from: '0.9.0',
    to: '1.0.0',
    description: '0.9.0 â†’ 1.0.0: sceneObjects í•„ë“œ ì¶”ê°€, economy í•„ë“œëª… ì •ê·œí™”',
    migrate: (input: unknown): unknown => {
      const data = input as Record<string, unknown>;

      // 1. sceneObjects í•„ë“œê°€ ì—†ìœ¼ë©´ ë¹ˆ ë°°ì—´ë¡œ ì¶”ê°€
      if (!Array.isArray(data.sceneObjects)) {
        data.sceneObjects = [];
      }

      // 2. economy í•„ë“œ ì •ê·œí™” (legacy í˜•ì‹ ì§€ì›)
      if (data.economy && typeof data.economy === 'object') {
        const economy = data.economy as Record<string, unknown>;

        // legacy: memory_shards â†’ memory_shard (ì˜¤íƒ€ ìˆ˜ì •)
        if ('memory_shards' in economy && !('memory_shard' in economy)) {
          economy.memory_shard = economy.memory_shards;
          delete economy.memory_shards;
        }

        // ê¸°ë³¸ê°’ ë³´ì¥ (RULE-005: ì”ì•¡ ìŒìˆ˜ ê¸ˆì§€)
        if (typeof economy.signal !== 'number' || economy.signal < 0) {
          economy.signal = 100;
        }
        if (typeof economy.memory_shard !== 'number' || economy.memory_shard < 0) {
          economy.memory_shard = 5;
        }
      }

      // 3. economyLedger í•„ë“œê°€ ì—†ìœ¼ë©´ ë¹ˆ ë°°ì—´ë¡œ ì¶”ê°€
      if (!Array.isArray(data.economyLedger)) {
        data.economyLedger = [];
      }

      // 4. mutationTimeline í•„ë“œê°€ ì—†ìœ¼ë©´ ë¹ˆ ë°°ì—´ë¡œ ì¶”ê°€
      if (!Array.isArray(data.mutationTimeline)) {
        data.mutationTimeline = [];
      }

      // 5. ë²„ì „ ì—…ë°ì´íŠ¸
      data.version = '1.0.0';

      return data;
    },
  },
] as const;

// =============================================================================
// ë§ˆì´ê·¸ë ˆì´ì…˜ ìœ í‹¸ë¦¬í‹°
// =============================================================================

/**
 * ë²„ì „ ì¸ë±ìŠ¤ë¥¼ ë°˜í™˜í•©ë‹ˆë‹¤.
 *
 * @param version - ë²„ì „ ë¬¸ìì—´
 * @returns ë²„ì „ ì¸ë±ìŠ¤ ë˜ëŠ” -1 (ì•Œ ìˆ˜ ì—†ëŠ” ë²„ì „)
 */
function getVersionIndex(version: string): number {
  return VERSION_ORDER.indexOf(version);
}

/**
 * ë²„ì „ì´ ë§ˆì´ê·¸ë ˆì´ì…˜ ê°€ëŠ¥í•œì§€ í™•ì¸í•©ë‹ˆë‹¤.
 *
 * @param version - í™•ì¸í•  ë²„ì „
 * @returns ë§ˆì´ê·¸ë ˆì´ì…˜ ê°€ëŠ¥ ì—¬ë¶€
 */
export function isMigratableVersion(version: string): boolean {
  return VERSION_ORDER.includes(version);
}

/**
 * ë²„ì „ì´ ì§€ì›ë˜ëŠ” ë²„ì „ì¸ì§€ í™•ì¸í•©ë‹ˆë‹¤.
 *
 * @param version - í™•ì¸í•  ë²„ì „
 * @returns ì§€ì› ì—¬ë¶€
 */
export function isSupportedVersion(version: string): boolean {
  return SUPPORTED_SAVEGAME_VERSIONS.includes(version);
}

/**
 * ë²„ì „ ê°„ ë§ˆì´ê·¸ë ˆì´ì…˜ ê²½ë¡œë¥¼ ì°¾ìŠµë‹ˆë‹¤.
 *
 * @param fromVersion - ì†ŒìŠ¤ ë²„ì „
 * @param toVersion - íƒ€ê²Ÿ ë²„ì „
 * @returns ì ìš©í•  ë§ˆì´ê·¸ë ˆì´ì…˜ ëª©ë¡ (ìˆœì„œëŒ€ë¡œ)
 */
function findMigrationPath(fromVersion: string, toVersion: string): Migration[] {
  const fromIndex = getVersionIndex(fromVersion);
  const toIndex = getVersionIndex(toVersion);

  if (fromIndex === -1 || toIndex === -1) {
    return [];
  }

  if (fromIndex >= toIndex) {
    // ë‹¤ìš´ê·¸ë ˆì´ë“œëŠ” ì§€ì›í•˜ì§€ ì•ŠìŒ
    return [];
  }

  const path: Migration[] = [];
  let currentVersion = fromVersion;

  while (currentVersion !== toVersion) {
    const migration = MIGRATIONS.find((m) => m.from === currentVersion);
    if (!migration) {
      // ë§ˆì´ê·¸ë ˆì´ì…˜ ê²½ë¡œê°€ ëŠê¹€
      break;
    }
    path.push(migration);
    currentVersion = migration.to;
  }

  return path;
}

// =============================================================================
// ê³µê°œ API
// =============================================================================

/**
 * SaveGameì„ ìµœì‹  ë²„ì „ìœ¼ë¡œ ì—…ê·¸ë ˆì´ë“œí•©ë‹ˆë‹¤.
 *
 * @param input - ë§ˆì´ê·¸ë ˆì´ì…˜í•  SaveGame ë°ì´í„° (unknown)
 * @param fromVersion - í˜„ì¬ ë²„ì „
 * @returns ë§ˆì´ê·¸ë ˆì´ì…˜ ê²°ê³¼
 */
export function upgradeToLatest(input: unknown, fromVersion: string): MigrationOutcome {
  // ì´ë¯¸ ìµœì‹  ë²„ì „ì´ë©´ ê·¸ëŒ€ë¡œ ë°˜í™˜
  if (fromVersion === SAVEGAME_VERSION) {
    return {
      success: true,
      data: input,
      migratedFrom: fromVersion,
      migratedTo: SAVEGAME_VERSION,
      appliedMigrations: [],
    };
  }

  // ë§ˆì´ê·¸ë ˆì´ì…˜ ê°€ëŠ¥í•œ ë²„ì „ì¸ì§€ í™•ì¸
  if (!isMigratableVersion(fromVersion)) {
    return {
      success: false,
      error: `Unsupported version: ${fromVersion}. Cannot migrate.`,
      originalVersion: fromVersion,
    };
  }

  // ë§ˆì´ê·¸ë ˆì´ì…˜ ê²½ë¡œ ì°¾ê¸°
  const migrationPath = findMigrationPath(fromVersion, SAVEGAME_VERSION);
  if (migrationPath.length === 0) {
    return {
      success: false,
      error: `No migration path found from ${fromVersion} to ${SAVEGAME_VERSION}`,
      originalVersion: fromVersion,
    };
  }

  // ë§ˆì´ê·¸ë ˆì´ì…˜ ìˆœì°¨ ì ìš©
  let currentData: unknown = input;
  const appliedMigrations: string[] = [];

  for (const migration of migrationPath) {
    try {
      console.log(`[Migration] Applying: ${migration.description}`);
      currentData = migration.migrate(currentData);
      appliedMigrations.push(`${migration.from} â†’ ${migration.to}`);
    } catch (error) {
      return {
        success: false,
        error: `Migration failed at ${migration.from} â†’ ${migration.to}: ${error}`,
        originalVersion: fromVersion,
      };
    }
  }

  return {
    success: true,
    data: currentData,
    migratedFrom: fromVersion,
    migratedTo: SAVEGAME_VERSION,
    appliedMigrations,
  };
}

/**
 * JSON ë°ì´í„°ì—ì„œ ë²„ì „ì„ ì•ˆì „í•˜ê²Œ ì¶”ì¶œí•©ë‹ˆë‹¤.
 *
 * ìµœì†Œí•œì˜ íŒŒì‹±ë§Œ ìˆ˜í–‰í•˜ì—¬ ë²„ì „ì„ í™•ì¸í•©ë‹ˆë‹¤.
 * ì „ì²´ ìŠ¤í‚¤ë§ˆ ê²€ì¦ ì „ì— ë²„ì „ì„ ë¨¼ì € í™•ì¸í•˜ê¸° ìœ„í•œ í—¬í¼ì…ë‹ˆë‹¤.
 *
 * @param data - íŒŒì‹±ëœ JSON ë°ì´í„° (unknown)
 * @returns ë²„ì „ ë¬¸ìì—´ ë˜ëŠ” null
 */
export function extractVersion(data: unknown): string | null {
  if (typeof data !== 'object' || data === null) {
    return null;
  }

  const obj = data as Record<string, unknown>;
  if (typeof obj.version === 'string' && obj.version.length > 0) {
    return obj.version;
  }

  return null;
}

/**
 * ë§ˆì´ê·¸ë ˆì´ì…˜ í†µê³„ë¥¼ ë°˜í™˜í•©ë‹ˆë‹¤.
 *
 * ë””ë²„ê·¸/ë¡œê¹…ìš©ìœ¼ë¡œ í˜„ì¬ ë§ˆì´ê·¸ë ˆì´ì…˜ ì‹œìŠ¤í…œì˜ ìƒíƒœë¥¼ í™•ì¸í•©ë‹ˆë‹¤.
 */
export function getMigrationStats(): {
  currentVersion: string;
  supportedVersions: readonly string[];
  migratableVersions: readonly string[];
  migrationCount: number;
} {
  return {
    currentVersion: SAVEGAME_VERSION,
    supportedVersions: SUPPORTED_SAVEGAME_VERSIONS,
    migratableVersions: VERSION_ORDER,
    migrationCount: MIGRATIONS.length,
  };
}
</file>

<file path="frontend/src/schemas/turn.economy.test.ts">
import { describe, it, expect } from 'vitest';
import { safeParseTurnOutput } from './turn';

describe('U-063: Economy Balance Preservation in safeParseTurnOutput', () => {
  it('should preserve economy balance in fallback when validation fails', () => {
    const invalidData = { some: 'invalid data' };
    const economySnapshot = { signal: 42, memory_shard: 7 };

    const result = safeParseTurnOutput(invalidData, 'ko-KR', 0, economySnapshot);

    expect(result.success).toBe(false);
    if (!result.success) {
      expect(result.fallback.economy.balance_after.signal).toBe(42);
      expect(result.fallback.economy.balance_after.memory_shard).toBe(7);
      expect(result.fallback.economy.cost.signal).toBe(0);
      expect(result.fallback.economy.cost.memory_shard).toBe(0);
    }
  });

  it('should use default values if economySnapshot is not provided', () => {
    const invalidData = { some: 'invalid data' };

    const result = safeParseTurnOutput(invalidData, 'ko-KR', 0);

    expect(result.success).toBe(false);
    if (!result.success) {
      // ê¸°ë³¸ê°’ { signal: 100, memory_shard: 5 } í™•ì¸ (turn.tsì— ì •ì˜ë¨)
      expect(result.fallback.economy.balance_after.signal).toBe(100);
      expect(result.fallback.economy.balance_after.memory_shard).toBe(5);
    }
  });
});
</file>

<file path="frontend/src/stores/actionDeckStore.test.ts">
import { describe, it, expect, beforeEach } from 'vitest';
import { useActionDeckStore, filterAffordableCards } from './actionDeckStore';
import type { ActionCard } from '../schemas/turn';

describe('actionDeckStore', () => {
  beforeEach(() => {
    useActionDeckStore.getState().reset();
  });

  // U-065: ë‹¨ìˆœí™”ëœ ActionCard ìŠ¤í‚¤ë§ˆ (ì œê±°ë¨: description, cost_estimate, hint, reward_hint, disabled_reason)
  const mockCards: ActionCard[] = [
    {
      id: 'card-1',
      label: 'Card 1',
      cost: { signal: 10, memory_shard: 0 },
      risk: 'low',
      enabled: true,
      is_alternative: false,
    },
    {
      id: 'card-2',
      label: 'Card 2',
      cost: { signal: 50, memory_shard: 1 },
      risk: 'high',
      enabled: true,
      is_alternative: false,
    },
  ];

  it('sets cards and resets selected card', () => {
    const store = useActionDeckStore.getState();
    store.selectCard('some-id');
    expect(useActionDeckStore.getState().selectedCardId).toBe('some-id');

    store.setCards(mockCards);
    expect(useActionDeckStore.getState().cards).toEqual(mockCards);
    expect(useActionDeckStore.getState().selectedCardId).toBeNull();
  });

  it('marks a card as executed', () => {
    const store = useActionDeckStore.getState();
    store.selectCard('card-1');
    store.markExecuted('card-1');

    expect(useActionDeckStore.getState().lastExecutedCardId).toBe('card-1');
    expect(useActionDeckStore.getState().selectedCardId).toBeNull();
  });

  it('filters affordable cards correctly', () => {
    const balance = { signal: 20, memory_shard: 0 };
    const affordable = filterAffordableCards(mockCards, balance);

    expect(affordable).toHaveLength(1);
    expect(affordable[0].id).toBe('card-1');
  });

  it('respects server enabled flag in filterAffordableCards', () => {
    const disabledCards: ActionCard[] = [
      {
        ...mockCards[0],
        enabled: false,
      },
    ];
    const balance = { signal: 100, memory_shard: 100 };
    const affordable = filterAffordableCards(disabledCards, balance);

    expect(affordable).toHaveLength(0);
  });
});
</file>

<file path="frontend/src/stores/actionDeckStore.ts">
/**
 * Unknown World - Action Deck ìƒíƒœ ê´€ë¦¬ (Zustand) (U-009[Mvp]).
 *
 * Action Deckì˜ ì¹´ë“œ ëª©ë¡, ì„ íƒ ìƒíƒœ, ì”ì•¡ ê¸°ë°˜ í•„í„°ë§ì„ ê´€ë¦¬í•©ë‹ˆë‹¤.
 *
 * ì„¤ê³„ ì›ì¹™:
 *   - RULE-005: ì”ì•¡ ë¶€ì¡± ì‹œ ì‹¤í–‰ ë¶ˆê°€ í‘œì‹œ + ëŒ€ì•ˆ ì œê³µ
 *   - RULE-008: ì¹´ë“œ í´ë¦­ â†’ TurnInput ì—°ê²°
 *
 * @module stores/actionDeckStore
 */

import { create } from 'zustand';
import type { ActionCard } from '../schemas/turn';

// =============================================================================
// ìƒíƒœ íƒ€ì… ì •ì˜
// =============================================================================

/** Action Deck ìƒíƒœ */
export interface ActionDeckState {
  /** í˜„ì¬ ì¹´ë“œ ëª©ë¡ (ì„œë²„ì—ì„œ ë°›ì€ ì›ë³¸) */
  cards: ActionCard[];
  /** ì„ íƒëœ ì¹´ë“œ ID (í´ë¦­ í›„ ì‹¤í–‰ ì „ê¹Œì§€) */
  selectedCardId: string | null;
  /** ë§ˆì§€ë§‰ìœ¼ë¡œ ì‹¤í–‰ëœ ì¹´ë“œ ID */
  lastExecutedCardId: string | null;
}

/** Action Deck ì•¡ì…˜ */
export interface ActionDeckActions {
  /** ì¹´ë“œ ëª©ë¡ ì„¤ì • (TurnOutput ìˆ˜ì‹  ì‹œ) */
  setCards: (cards: ActionCard[]) => void;
  /** ì¹´ë“œ ì„ íƒ */
  selectCard: (cardId: string | null) => void;
  /** ì¹´ë“œ ì‹¤í–‰ ì™„ë£Œ ê¸°ë¡ */
  markExecuted: (cardId: string) => void;
  /** ìƒíƒœ ì´ˆê¸°í™” */
  reset: () => void;
}

export type ActionDeckStore = ActionDeckState & ActionDeckActions;

// =============================================================================
// ì´ˆê¸° ìƒíƒœ
// =============================================================================

function createInitialState(): ActionDeckState {
  return {
    cards: [],
    selectedCardId: null,
    lastExecutedCardId: null,
  };
}

// =============================================================================
// Zustand Store
// =============================================================================

/**
 * Action Deck ìƒíƒœ ìŠ¤í† ì–´.
 *
 * @example
 * ```tsx
 * const { cards, setCards, selectCard } = useActionDeckStore();
 *
 * // TurnOutput ìˆ˜ì‹  ì‹œ
 * setCards(turnOutput.ui.action_deck.cards);
 *
 * // ì¹´ë“œ í´ë¦­ ì‹œ
 * selectCard(card.id);
 * ```
 */
export const useActionDeckStore = create<ActionDeckStore>((set) => ({
  // ì´ˆê¸° ìƒíƒœ
  ...createInitialState(),

  // ì•¡ì…˜
  setCards: (cards) => {
    set({
      cards,
      selectedCardId: null, // ìƒˆ ì¹´ë“œ ëª©ë¡ ìˆ˜ì‹  ì‹œ ì„ íƒ ì´ˆê¸°í™”
    });
  },

  selectCard: (cardId) => {
    set({ selectedCardId: cardId });
  },

  markExecuted: (cardId) => {
    set({
      lastExecutedCardId: cardId,
      selectedCardId: null,
    });
  },

  reset: () => {
    set(createInitialState());
  },
}));

// =============================================================================
// ì…€ë ‰í„° (ì„±ëŠ¥ ìµœì í™”ìš©)
// =============================================================================

/** ì¹´ë“œ ëª©ë¡ ì…€ë ‰í„° */
export const selectCards = (state: ActionDeckStore) => state.cards;

/** ì„ íƒëœ ì¹´ë“œ ID ì…€ë ‰í„° */
export const selectSelectedCardId = (state: ActionDeckStore) => state.selectedCardId;

/** ì„ íƒëœ ì¹´ë“œ ê°ì²´ ì…€ë ‰í„° */
export const selectSelectedCard = (state: ActionDeckStore) =>
  state.cards.find((c) => c.id === state.selectedCardId) ?? null;

/** ë§ˆì§€ë§‰ ì‹¤í–‰ ì¹´ë“œ ID ì…€ë ‰í„° */
export const selectLastExecutedCardId = (state: ActionDeckStore) => state.lastExecutedCardId;

// =============================================================================
// ìœ í‹¸ë¦¬í‹° í•¨ìˆ˜
// =============================================================================

/**
 * ì”ì•¡ ê¸°ë°˜ìœ¼ë¡œ ì‹¤í–‰ ê°€ëŠ¥í•œ ì¹´ë“œë§Œ í•„í„°ë§í•©ë‹ˆë‹¤.
 * (ì»´í¬ë„ŒíŠ¸ì—ì„œ ì‚¬ìš©í•˜ê±°ë‚˜, ì„œë²„ ì‘ë‹µì´ enabledë¥¼ ì œê³µí•˜ì§€ ì•Šì„ ë•Œ í´ë°±ìœ¼ë¡œ ì‚¬ìš©)
 *
 * U-065: cost_estimate í•„ë“œ ì œê±°ë¨, costë§Œ ì‚¬ìš©
 *
 * @param cards - ì›ë³¸ ì¹´ë“œ ëª©ë¡
 * @param balance - í˜„ì¬ ì”ì•¡
 * @returns ì‹¤í–‰ ê°€ëŠ¥í•œ ì¹´ë“œ ëª©ë¡
 */
export function filterAffordableCards(
  cards: ActionCard[],
  balance: { signal: number; memory_shard: number },
): ActionCard[] {
  return cards.filter((card) => {
    // ì„œë²„ì—ì„œ ì´ë¯¸ enabled=falseë¡œ íŒë‹¨í–ˆìœ¼ë©´ ì œì™¸
    if (!card.enabled) return false;

    // U-065: cost_estimate ì œê±°ë¨, costë§Œ ì‚¬ìš©
    const cost = card.cost;
    return balance.signal >= cost.signal && balance.memory_shard >= cost.memory_shard;
  });
}

/**
 * ëŒ€ì•ˆ ì¹´ë“œ(is_alternative=true)ë§Œ í•„í„°ë§í•©ë‹ˆë‹¤.
 *
 * @param cards - ì›ë³¸ ì¹´ë“œ ëª©ë¡
 * @returns ëŒ€ì•ˆ ì¹´ë“œ ëª©ë¡
 */
export function filterAlternativeCards(cards: ActionCard[]): ActionCard[] {
  return cards.filter((card) => card.is_alternative);
}

/**
 * ì¼ë°˜ ì¹´ë“œ(is_alternative=false)ë§Œ í•„í„°ë§í•©ë‹ˆë‹¤.
 *
 * @param cards - ì›ë³¸ ì¹´ë“œ ëª©ë¡
 * @returns ì¼ë°˜ ì¹´ë“œ ëª©ë¡
 */
export function filterRegularCards(cards: ActionCard[]): ActionCard[] {
  return cards.filter((card) => !card.is_alternative);
}
</file>

<file path="frontend/src/stores/agentStore.ts">
/**
 * Unknown World - Agent Console ìƒíƒœ ê´€ë¦¬ (Zustand).
 *
 * ìŠ¤íŠ¸ë¦¬ë° ì¤‘ ìˆ˜ì‹ ë˜ëŠ” ë‹¨ê³„/ë°°ì§€/ë‚´ëŸ¬í‹°ë¸Œ/ë³µêµ¬ ì •ë³´ë¥¼ ì €ì¥í•˜ê³ ,
 * AgentConsole ì»´í¬ë„ŒíŠ¸ì—ì„œ êµ¬ë…í•  ìˆ˜ ìˆë„ë¡ í•©ë‹ˆë‹¤.
 *
 * ì„¤ê³„ ì›ì¹™:
 *   - RULE-008: ë‹¨ê³„/ë°°ì§€ ê°€ì‹œí™” (í”„ë¡¬í”„íŠ¸/ë‚´ë¶€ ì¶”ë¡  ë…¸ì¶œ ê¸ˆì§€)
 *   - RULE-003/004: ê²€ì¦ í›„ ìƒíƒœ ë°˜ì˜, ì‹¤íŒ¨ ì‹œ í´ë°±
 *
 * @module stores/agentStore
 */

import { create } from 'zustand';
import type { AgentPhase, ValidationBadge, TurnOutput } from '../schemas/turn';
import type {
  StageEvent,
  BadgesEvent,
  NarrativeDeltaEvent,
  FinalEvent,
  ErrorEvent,
} from '../types/turn_stream';
import { StageStatus } from '../types/turn_stream';

// =============================================================================
// ìƒíƒœ íƒ€ì… ì •ì˜
// =============================================================================

/** ë‹¨ê³„ ìƒíƒœ */
export type PhaseStatus = 'pending' | 'in_progress' | 'completed' | 'failed';

/** ë‹¨ê³„ ì •ë³´ */
export interface PhaseInfo {
  name: AgentPhase;
  status: PhaseStatus;
}

/** ì—ëŸ¬ ì •ë³´ */
export interface AgentError {
  message: string;
  code?: string;
}

/** Agent Console ìƒíƒœ */
export interface AgentState {
  /** í˜„ì¬ ìŠ¤íŠ¸ë¦¬ë° ì¤‘ì¸ì§€ */
  isStreaming: boolean;
  /** í˜„ì¬ ë‹¨ê³„ */
  currentPhase: AgentPhase | null;
  /** ë‹¨ê³„ë³„ ìƒíƒœ */
  phases: PhaseInfo[];
  /** ê²€ì¦ ë°°ì§€ ëª©ë¡ */
  badges: ValidationBadge[];
  /** ëˆ„ì  ë‚´ëŸ¬í‹°ë¸Œ í…ìŠ¤íŠ¸ (íƒ€ì íš¨ê³¼ìš©) */
  narrativeBuffer: string;
  /** ìë™ ë³µêµ¬ íšŸìˆ˜ */
  repairCount: number;
  /** ìµœì¢… TurnOutput */
  finalOutput: TurnOutput | null;
  /** ì—ëŸ¬ ì •ë³´ */
  error: AgentError | null;
}

/** Agent Console ì•¡ì…˜ */
export interface AgentActions {
  /** ìŠ¤íŠ¸ë¦¼ ì‹œì‘ */
  startStream: () => void;
  /** ë‹¨ê³„ ì´ë²¤íŠ¸ ì²˜ë¦¬ */
  handleStage: (event: StageEvent) => void;
  /** ë°°ì§€ ì´ë²¤íŠ¸ ì²˜ë¦¬ */
  handleBadges: (event: BadgesEvent) => void;
  /** ë‚´ëŸ¬í‹°ë¸Œ ë¸íƒ€ ì´ë²¤íŠ¸ ì²˜ë¦¬ */
  handleNarrativeDelta: (event: NarrativeDeltaEvent) => void;
  /** ìµœì¢… ì¶œë ¥ ì´ë²¤íŠ¸ ì²˜ë¦¬ */
  handleFinal: (event: FinalEvent) => void;
  /** ì—ëŸ¬ ì´ë²¤íŠ¸ ì²˜ë¦¬ */
  handleError: (event: ErrorEvent) => void;
  /** ìŠ¤íŠ¸ë¦¼ ì™„ë£Œ */
  completeStream: () => void;
  /** ìƒíƒœ ì´ˆê¸°í™” */
  reset: () => void;
}

export type AgentStore = AgentState & AgentActions;

// =============================================================================
// ì´ˆê¸° ìƒíƒœ
// =============================================================================

/** ê¸°ë³¸ ë‹¨ê³„ ëª©ë¡ (PRD ì˜ˆì‹œ) */
const DEFAULT_PHASES: AgentPhase[] = [
  'parse',
  'validate',
  'plan',
  'resolve',
  'render',
  'verify',
  'commit',
];

/** ì´ˆê¸° ìƒíƒœ ìƒì„± */
function createInitialState(): AgentState {
  return {
    isStreaming: false,
    currentPhase: null,
    phases: DEFAULT_PHASES.map((name) => ({
      name,
      status: 'pending' as const,
    })),
    badges: [],
    narrativeBuffer: '',
    repairCount: 0,
    finalOutput: null,
    error: null,
  };
}

// =============================================================================
// Zustand Store
// =============================================================================

/**
 * Agent Console ìƒíƒœ ìŠ¤í† ì–´.
 *
 * @example
 * ```tsx
 * // ì»´í¬ë„ŒíŠ¸ì—ì„œ ì‚¬ìš©
 * const { isStreaming, phases, badges } = useAgentStore();
 * const startStream = useAgentStore((state) => state.startStream);
 * ```
 */
export const useAgentStore = create<AgentStore>((set) => ({
  // ì´ˆê¸° ìƒíƒœ
  ...createInitialState(),

  // ì•¡ì…˜
  startStream: () => {
    set({
      ...createInitialState(),
      isStreaming: true,
    });
  },

  handleStage: (event) => {
    set((state) => {
      const phaseName = event.name;
      const eventStatus = event.status;

      // RU-002-S2: status ê°’ì— ë”°ë¥¸ ë‹¨ê³„ ìƒíƒœ ê²°ì •
      // 'start' â†’ in_progress
      // 'complete' ë˜ëŠ” 'ok' (ì •ê·œí™”ë¨) â†’ completed
      // 'fail' â†’ failed
      let newStatus: PhaseStatus;
      if (eventStatus === StageStatus.START) {
        newStatus = 'in_progress';
      } else if (eventStatus === 'fail') {
        newStatus = 'failed';
      } else {
        // 'complete' (ì •ê·œí™”ëœ 'ok' í¬í•¨)
        newStatus = 'completed';
      }

      // ë‹¨ê³„ ìƒíƒœ ì—…ë°ì´íŠ¸
      const phases = state.phases.map((phase) => {
        if (phase.name === phaseName) {
          return {
            ...phase,
            status: newStatus,
          };
        }
        return phase;
      });

      return {
        phases,
        currentPhase: eventStatus === StageStatus.START ? phaseName : state.currentPhase,
      };
    });
  },

  handleBadges: (event) => {
    set({
      badges: event.badges,
    });
  },

  handleNarrativeDelta: (event) => {
    set((state) => ({
      narrativeBuffer: state.narrativeBuffer + event.text,
    }));
  },

  handleFinal: (event) => {
    set({
      finalOutput: event.data,
      repairCount: event.data.agent_console?.repair_count ?? 0,
    });
  },

  handleError: (event) => {
    set({
      error: {
        message: event.message,
        code: event.code,
      },
    });
  },

  completeStream: () => {
    set({
      isStreaming: false,
      narrativeBuffer: '', // ìŠ¤íŠ¸ë¦¼ ì™„ë£Œ ì‹œ ë²„í¼ ì´ˆê¸°í™”
    });
  },

  reset: () => {
    set(createInitialState());
  },
}));

// =============================================================================
// ì…€ë ‰í„° (ì„±ëŠ¥ ìµœì í™”ìš©)
// =============================================================================

/** ìŠ¤íŠ¸ë¦¬ë° ìƒíƒœ ì…€ë ‰í„° */
export const selectIsStreaming = (state: AgentStore) => state.isStreaming;

/** í˜„ì¬ ë‹¨ê³„ ì…€ë ‰í„° */
export const selectCurrentPhase = (state: AgentStore) => state.currentPhase;

/** ë‹¨ê³„ ëª©ë¡ ì…€ë ‰í„° */
export const selectPhases = (state: AgentStore) => state.phases;

/** ë°°ì§€ ëª©ë¡ ì…€ë ‰í„° */
export const selectBadges = (state: AgentStore) => state.badges;

/** ë‚´ëŸ¬í‹°ë¸Œ ë²„í¼ ì…€ë ‰í„° */
export const selectNarrativeBuffer = (state: AgentStore) => state.narrativeBuffer;

/** ë³µêµ¬ íšŸìˆ˜ ì…€ë ‰í„° */
export const selectRepairCount = (state: AgentStore) => state.repairCount;

/** ìµœì¢… ì¶œë ¥ ì…€ë ‰í„° */
export const selectFinalOutput = (state: AgentStore) => state.finalOutput;

/** ì—ëŸ¬ ì…€ë ‰í„° */
export const selectError = (state: AgentStore) => state.error;

/** ëª¨ë¸ ë¼ë²¨ ì…€ë ‰í„° (U-069: FAST/QUALITY í‘œì‹œ) */
export const selectModelLabel = (state: AgentStore) =>
  state.finalOutput?.agent_console?.model_label ?? 'FAST';
</file>

<file path="frontend/src/stores/economyStore.test.ts">
import { describe, it, expect, beforeEach } from 'vitest';
import {
  useEconomyStore,
  LEDGER_MAX_ENTRIES,
  canAffordCost,
  canAffordEstimate,
} from './economyStore';
import type { CurrencyAmount, CostEstimate } from '../schemas/turn';

describe('economyStore', () => {
  beforeEach(() => {
    useEconomyStore.getState().reset();
    useEconomyStore.getState().clearLedger();
  });

  it('ì´ˆê¸° ìƒíƒœê°€ ì˜¬ë°”ë¥´ê²Œ ì„¤ì •ë˜ì–´ì•¼ í•œë‹¤', () => {
    const state = useEconomyStore.getState();
    expect(state.ledger).toEqual([]);
    expect(state.costEstimate).toBeNull();
    expect(state.lastCost).toBeNull();
    expect(state.isBalanceLow).toBe(false);
    expect(state.lowBalanceThreshold).toBe(10);
  });

  it('addLedgerEntryê°€ ì—”íŠ¸ë¦¬ë¥¼ ì¶”ê°€í•˜ê³  lastCostë¥¼ ì—…ë°ì´íŠ¸í•´ì•¼ í•œë‹¤', () => {
    const entry = {
      turnId: 1,
      reason: 'explore',
      cost: { signal: 5, memory_shard: 0 },
      balanceAfter: { signal: 95, memory_shard: 10 },
      modelLabel: 'FAST' as const,
    };

    useEconomyStore.getState().addLedgerEntry(entry);

    const state = useEconomyStore.getState();
    expect(state.ledger.length).toBe(1);
    expect(state.ledger[0].turnId).toBe(1);
    expect(state.ledger[0].timestamp).toBeDefined();
    expect(state.lastCost).toEqual({
      cost: entry.cost,
      balanceAfter: entry.balanceAfter,
      turnId: entry.turnId,
      modelLabel: entry.modelLabel,
    });
  });

  it(`LedgerëŠ” ìµœëŒ€ ${LEDGER_MAX_ENTRIES}ê°œê¹Œì§€ë§Œ ë³´ê´€í•´ì•¼ í•œë‹¤`, () => {
    const store = useEconomyStore.getState();

    // 25ê°œ ì—”íŠ¸ë¦¬ ì¶”ê°€
    for (let i = 1; i <= 25; i++) {
      store.addLedgerEntry({
        turnId: i,
        reason: `test-${i}`,
        cost: { signal: 1, memory_shard: 0 },
        balanceAfter: { signal: 100 - i, memory_shard: 0 },
      });
    }

    const state = useEconomyStore.getState();
    expect(state.ledger.length).toBe(LEDGER_MAX_ENTRIES);
    // ìµœì‹ ìˆœ(ë‚´ë¦¼ì°¨ìˆœ) ì •ë ¬ í™•ì¸
    expect(state.ledger[0].turnId).toBe(25);
    expect(state.ledger[LEDGER_MAX_ENTRIES - 1].turnId).toBe(25 - LEDGER_MAX_ENTRIES + 1);
  });

  it('setCostEstimateFromCardê°€ ì˜ˆìƒ ë¹„ìš©ì„ ì˜¬ë°”ë¥´ê²Œ ì„¤ì •í•´ì•¼ í•œë‹¤', () => {
    const cost: CurrencyAmount = { signal: 5, memory_shard: 0 };
    const estimate: CostEstimate = {
      min: { signal: 3, memory_shard: 0 },
      max: { signal: 7, memory_shard: 0 },
    };

    // 1. cost_estimateê°€ ì œê³µëœ ê²½ìš°
    useEconomyStore.getState().setCostEstimateFromCard(cost, estimate, 'action-1', 'Test Label');
    let state = useEconomyStore.getState();
    expect(state.costEstimate).toEqual({
      min: estimate.min,
      max: estimate.max,
      actionId: 'action-1',
      label: 'Test Label',
    });

    // 2. cost_estimateê°€ nullì¸ ê²½ìš° (ê¸°ë³¸ cost ì‚¬ìš©)
    useEconomyStore.getState().setCostEstimateFromCard(cost, null, 'action-2');
    state = useEconomyStore.getState();
    expect(state.costEstimate).toEqual({
      min: cost,
      max: cost,
      actionId: 'action-2',
      label: undefined,
    });
  });

  it('updateBalanceLowStatusê°€ ì„ê³„ê°’ì— ë”°ë¼ ìƒíƒœë¥¼ ì—…ë°ì´íŠ¸í•´ì•¼ í•œë‹¤', () => {
    const store = useEconomyStore.getState();

    // ê¸°ë³¸ ì„ê³„ê°’ 10
    store.updateBalanceLowStatus({ signal: 15, memory_shard: 0 });
    expect(useEconomyStore.getState().isBalanceLow).toBe(false);

    store.updateBalanceLowStatus({ signal: 5, memory_shard: 0 });
    expect(useEconomyStore.getState().isBalanceLow).toBe(true);

    // ì„ê³„ê°’ ë³€ê²½ í…ŒìŠ¤íŠ¸
    store.setLowBalanceThreshold(20);
    store.updateBalanceLowStatus({ signal: 15, memory_shard: 0 });
    expect(useEconomyStore.getState().isBalanceLow).toBe(true);
  });

  describe('Utility: canAffordCost & canAffordEstimate', () => {
    const balance: CurrencyAmount = { signal: 10, memory_shard: 2 };

    it('canAffordCost: ì”ì•¡ì´ ì¶©ë¶„í•  ë•Œ', () => {
      const cost: CurrencyAmount = { signal: 5, memory_shard: 1 };
      const result = canAffordCost(balance, cost);
      expect(result.affordable).toBe(true);
      expect(result.shortfall).toEqual({ signal: 0, memory_shard: 0 });
    });

    it('canAffordCost: ì”ì•¡ì´ ë¶€ì¡±í•  ë•Œ (Signal)', () => {
      const cost: CurrencyAmount = { signal: 15, memory_shard: 1 };
      const result = canAffordCost(balance, cost);
      expect(result.affordable).toBe(false);
      expect(result.shortfall.signal).toBe(5);
    });

    it('canAffordCost: ì”ì•¡ì´ ë¶€ì¡±í•  ë•Œ (Shard)', () => {
      const cost: CurrencyAmount = { signal: 5, memory_shard: 5 };
      const result = canAffordCost(balance, cost);
      expect(result.affordable).toBe(false);
      expect(result.shortfall.memory_shard).toBe(3);
    });

    it('canAffordEstimate: ìµœëŒ€ ì˜ˆìƒ ë¹„ìš© ê¸°ì¤€ìœ¼ë¡œ ì²´í¬í•´ì•¼ í•œë‹¤', () => {
      const estimate = {
        min: { signal: 5, memory_shard: 0 },
        max: { signal: 15, memory_shard: 0 },
      };
      // Signal 10 < Max 15 ì´ë¯€ë¡œ ê°ë‹¹ ë¶ˆê°€
      const result = canAffordEstimate(balance, estimate);
      expect(result.affordable).toBe(false);
      expect(result.shortfall.signal).toBe(5);
    });
  });
});
</file>

<file path="frontend/src/stores/onboardingStore.test.ts">
import { describe, it, expect, beforeEach } from 'vitest';
import { useOnboardingStore, ONBOARDING_HINT_THRESHOLD } from './onboardingStore';

describe('onboardingStore', () => {
  beforeEach(() => {
    useOnboardingStore.getState().resetOnboarding();
    // localStorage ëª¨í‚¹ì€ í•„ìš” ì‹œ ì¶”ê°€
  });

  describe('Hint Counts', () => {
    it('í•«ìŠ¤íŒŸ íŒíŠ¸ ì¹´ìš´íŠ¸ê°€ ì¦ê°€í•´ì•¼ í•œë‹¤', () => {
      const store = useOnboardingStore.getState();
      expect(store.hotspotHintCount).toBe(0);

      store.incrementHotspotHint();
      expect(useOnboardingStore.getState().hotspotHintCount).toBe(1);
    });

    it('ì•„ì´í…œ íŒíŠ¸ ì¹´ìš´íŠ¸ê°€ ì¦ê°€í•´ì•¼ í•œë‹¤', () => {
      const store = useOnboardingStore.getState();
      expect(store.itemHintCount).toBe(0);

      store.incrementItemHint();
      expect(useOnboardingStore.getState().itemHintCount).toBe(1);
    });

    it('ì¹´ìš´íŠ¸ê°€ ì„ê³„ê°’(THRESHOLD)ì„ ë„˜ì§€ ì•Šì•„ì•¼ í•œë‹¤', () => {
      const store = useOnboardingStore.getState();

      // ì„ê³„ê°’ë³´ë‹¤ ë§ì´ í˜¸ì¶œ
      for (let i = 0; i < ONBOARDING_HINT_THRESHOLD + 2; i++) {
        store.incrementHotspotHint();
      }

      expect(useOnboardingStore.getState().hotspotHintCount).toBe(ONBOARDING_HINT_THRESHOLD);
    });
  });

  describe('Onboarding Guide Flow', () => {
    it('ì˜¨ë³´ë”© ê°€ì´ë“œë¥¼ í‘œì‹œí•  ìˆ˜ ìˆì–´ì•¼ í•œë‹¤', () => {
      const store = useOnboardingStore.getState();
      expect(store.showOnboarding).toBe(false);

      store.showOnboardingGuide();
      expect(useOnboardingStore.getState().showOnboarding).toBe(true);
      expect(useOnboardingStore.getState().onboardingStep).toBe(0);
    });

    it('ì´ë¯¸ ì™„ë£Œëœ ì˜¨ë³´ë”©ì€ ë‹¤ì‹œ í‘œì‹œë˜ì§€ ì•Šì•„ì•¼ í•œë‹¤', () => {
      const store = useOnboardingStore.getState();
      store.completeOnboarding();
      expect(useOnboardingStore.getState().onboardingComplete).toBe(true);

      store.showOnboardingGuide();
      expect(useOnboardingStore.getState().showOnboarding).toBe(false);
    });

    it('ë‹¤ìŒ ë‹¨ê³„ë¡œ ì´ë™í•  ìˆ˜ ìˆì–´ì•¼ í•œë‹¤', () => {
      const store = useOnboardingStore.getState();
      store.showOnboardingGuide();
      expect(useOnboardingStore.getState().onboardingStep).toBe(0);

      store.nextOnboardingStep();
      expect(useOnboardingStore.getState().onboardingStep).toBe(1);
    });

    it('ì˜¨ë³´ë”©ì„ ì™„ë£Œí•˜ë©´ ìƒíƒœê°€ ì—…ë°ì´íŠ¸ë˜ì–´ì•¼ í•œë‹¤', () => {
      const store = useOnboardingStore.getState();
      store.showOnboardingGuide();
      store.completeOnboarding();

      const state = useOnboardingStore.getState();
      expect(state.onboardingComplete).toBe(true);
      expect(state.showOnboarding).toBe(false);
      expect(state.onboardingStep).toBe(0);
    });

    it('ì˜¨ë³´ë”©ì„ ë‹«ìœ¼ë©´(dismiss) ì™„ë£Œë˜ì§€ëŠ” ì•Šì§€ë§Œ í‘œì‹œë§Œ ì•ˆ ë˜ì–´ì•¼ í•œë‹¤', () => {
      const store = useOnboardingStore.getState();
      store.showOnboardingGuide();
      store.dismissOnboarding();

      const state = useOnboardingStore.getState();
      expect(state.onboardingComplete).toBe(false);
      expect(state.showOnboarding).toBe(false);
    });
  });
});
</file>

<file path="frontend/src/stores/onboardingStore.ts">
/**
 * Unknown World - ì˜¨ë³´ë”©/ì¸í„°ë™ì…˜ íŒíŠ¸ ìƒíƒœ ê´€ë¦¬ ìŠ¤í† ì–´
 *
 * U-074[Mvp]: í•«ìŠ¤íŒŸ/ì•„ì´í…œ ì¸í„°ë™ì…˜ ì•ˆë‚´ UX
 * - Q1 Option B: ì²« Në²ˆë§Œ hover íŒíŠ¸ í‘œì‹œ í›„ ìˆ¨ê¹€ (í•™ìŠµ í›„ ì‚¬ë¼ì§)
 * - Q2 Option B: í™”ë©´ ì½”ë„ˆì— ì‘ì€ íŒì—… ê°€ì´ë“œ
 * - Q3 Option B: ë°ëª¨ í”„ë¡œí•„ë„ ì²« ì ‘ì† ì‹œ ì˜¨ë³´ë”© í‘œì‹œ
 *
 * RULE-006 ì¤€ìˆ˜: i18n í‚¤ ê¸°ë°˜ í…ìŠ¤íŠ¸
 *
 * @module stores/onboardingStore
 */

import { create } from 'zustand';
import { persist, createJSONStorage } from 'zustand/middleware';

// =============================================================================
// ìƒìˆ˜ ì •ì˜
// =============================================================================

/** íŒíŠ¸ë¥¼ í‘œì‹œí•  ìµœëŒ€ íšŸìˆ˜ (ì´í›„ ìˆ¨ê¹€) */
const HINT_THRESHOLD = 3;

/** localStorage í‚¤ */
const STORAGE_KEY = 'unknown-world-onboarding';

// =============================================================================
// íƒ€ì… ì •ì˜
// =============================================================================

interface OnboardingState {
  /** ì˜¨ë³´ë”© ê°€ì´ë“œ ì™„ë£Œ ì—¬ë¶€ */
  onboardingComplete: boolean;

  /** í•«ìŠ¤íŒŸ hover íšŸìˆ˜ (ì²« Në²ˆ í›„ íŒíŠ¸ ìˆ¨ê¹€) */
  hotspotHintCount: number;

  /** ì•„ì´í…œ hover íšŸìˆ˜ (ì²« Në²ˆ í›„ íŒíŠ¸ ìˆ¨ê¹€) */
  itemHintCount: number;

  /** ì˜¨ë³´ë”© ê°€ì´ë“œ í‘œì‹œ ì—¬ë¶€ (ì„¸ì…˜ ì¤‘ ìƒíƒœ) */
  showOnboarding: boolean;

  /** ì˜¨ë³´ë”© í˜„ì¬ ë‹¨ê³„ (0-based) */
  onboardingStep: number;
}

interface OnboardingActions {
  /** í•«ìŠ¤íŒŸ íŒíŠ¸ í‘œì‹œ íšŸìˆ˜ ì¦ê°€ */
  incrementHotspotHint: () => void;

  /** ì•„ì´í…œ íŒíŠ¸ í‘œì‹œ íšŸìˆ˜ ì¦ê°€ */
  incrementItemHint: () => void;

  /** ì˜¨ë³´ë”© ì™„ë£Œ ì²˜ë¦¬ */
  completeOnboarding: () => void;

  /** ì˜¨ë³´ë”© ê°€ì´ë“œ ë‹«ê¸° (ìŠ¤í‚µ ë˜ëŠ” ì™„ë£Œ) */
  dismissOnboarding: () => void;

  /** ì˜¨ë³´ë”© ê°€ì´ë“œ í‘œì‹œ (ì„¸ì…˜ ì‹œì‘ ì‹œ í˜¸ì¶œ) */
  showOnboardingGuide: () => void;

  /** ì˜¨ë³´ë”© ë‹¤ìŒ ë‹¨ê³„ë¡œ ì´ë™ */
  nextOnboardingStep: () => void;

  /** ì˜¨ë³´ë”© ìƒíƒœ ì´ˆê¸°í™” (ê°œë°œ/í…ŒìŠ¤íŠ¸ìš©) */
  resetOnboarding: () => void;
}

type OnboardingStore = OnboardingState & OnboardingActions;

// =============================================================================
// ì´ˆê¸° ìƒíƒœ
// =============================================================================

const initialState: OnboardingState = {
  onboardingComplete: false,
  hotspotHintCount: 0,
  itemHintCount: 0,
  showOnboarding: false,
  onboardingStep: 0,
};

// =============================================================================
// ì…€ë ‰í„° í•¨ìˆ˜ (ì„±ëŠ¥ ìµœì í™”)
// =============================================================================

/**
 * í•«ìŠ¤íŒŸ íŒíŠ¸ í‘œì‹œ ì—¬ë¶€ (ì²« Në²ˆë§Œ true)
 */
export const selectShouldShowHotspotHint = (state: OnboardingState): boolean =>
  state.hotspotHintCount < HINT_THRESHOLD;

/**
 * ì•„ì´í…œ íŒíŠ¸ í‘œì‹œ ì—¬ë¶€ (ì²« Në²ˆë§Œ true)
 */
export const selectShouldShowItemHint = (state: OnboardingState): boolean =>
  state.itemHintCount < HINT_THRESHOLD;

/**
 * ì˜¨ë³´ë”© ê°€ì´ë“œ í‘œì‹œ ì—¬ë¶€
 */
export const selectShowOnboarding = (state: OnboardingState): boolean =>
  state.showOnboarding && !state.onboardingComplete;

/**
 * ì˜¨ë³´ë”© í˜„ì¬ ë‹¨ê³„
 */
export const selectOnboardingStep = (state: OnboardingState): number => state.onboardingStep;

/**
 * ì˜¨ë³´ë”© ì™„ë£Œ ì—¬ë¶€
 */
export const selectOnboardingComplete = (state: OnboardingState): boolean =>
  state.onboardingComplete;

// =============================================================================
// Zustand Store
// =============================================================================

export const useOnboardingStore = create<OnboardingStore>()(
  persist(
    (set, get) => ({
      ...initialState,

      incrementHotspotHint: () => {
        const { hotspotHintCount } = get();
        if (hotspotHintCount < HINT_THRESHOLD) {
          set({ hotspotHintCount: hotspotHintCount + 1 });
        }
      },

      incrementItemHint: () => {
        const { itemHintCount } = get();
        if (itemHintCount < HINT_THRESHOLD) {
          set({ itemHintCount: itemHintCount + 1 });
        }
      },

      completeOnboarding: () => {
        set({
          onboardingComplete: true,
          showOnboarding: false,
          onboardingStep: 0,
        });
      },

      dismissOnboarding: () => {
        set({
          showOnboarding: false,
          onboardingStep: 0,
        });
      },

      showOnboardingGuide: () => {
        const { onboardingComplete } = get();
        // ì˜¨ë³´ë”© ë¯¸ì™„ë£Œ ì‹œì—ë§Œ í‘œì‹œ
        if (!onboardingComplete) {
          set({
            showOnboarding: true,
            onboardingStep: 0,
          });
        }
      },

      nextOnboardingStep: () => {
        set((state) => ({
          onboardingStep: state.onboardingStep + 1,
        }));
      },

      resetOnboarding: () => {
        set(initialState);
      },
    }),
    {
      name: STORAGE_KEY,
      storage: createJSONStorage(() => localStorage),
      // ì„¸ì…˜ ì¤‘ ìƒíƒœ(showOnboarding, onboardingStep)ëŠ” ì €ì¥í•˜ì§€ ì•ŠìŒ
      partialize: (state) => ({
        onboardingComplete: state.onboardingComplete,
        hotspotHintCount: state.hotspotHintCount,
        itemHintCount: state.itemHintCount,
      }),
    },
  ),
);

// =============================================================================
// í—¬í¼ í•¨ìˆ˜ (ì»´í¬ë„ŒíŠ¸ ì™¸ë¶€ì—ì„œ ì‚¬ìš©)
// =============================================================================

/**
 * ì˜¨ë³´ë”© ìƒíƒœ ì´ˆê¸°í™” (ì„¸ì…˜ ì‹œì‘ ì‹œ í˜¸ì¶œ)
 *
 * Q3 Option B: ë°ëª¨ í”„ë¡œí•„ë„ ì²« ì ‘ì† ì‹œ ì˜¨ë³´ë”© í‘œì‹œ
 */
export function initializeOnboarding(): void {
  const store = useOnboardingStore.getState();
  if (!store.onboardingComplete) {
    store.showOnboardingGuide();
  }
}

/**
 * íŒíŠ¸ ì„ê³„ê°’ ìƒìˆ˜ ë…¸ì¶œ (í…ŒìŠ¤íŠ¸ìš©)
 */
export const ONBOARDING_HINT_THRESHOLD = HINT_THRESHOLD;
</file>

<file path="frontend/src/stores/worldStore.u066.test.ts">
import { describe, it, expect, beforeEach } from 'vitest';
import { useWorldStore } from './worldStore';

describe('worldStore (U-066: Late-binding Image)', () => {
  beforeEach(() => {
    useWorldStore.getState().reset();
  });

  it('setImageLoadingì´ ì˜¬ë°”ë¥¸ ìƒíƒœë¥¼ ì„¤ì •í•´ì•¼ í•œë‹¤', () => {
    const turnId = 5;
    useWorldStore.getState().setImageLoading(turnId);

    const state = useWorldStore.getState();
    expect(state.sceneState.imageLoading).toBe(true);
    expect(state.sceneState.pendingImageTurnId).toBe(turnId);
    expect(state.sceneState.sceneRevision).toBe(turnId);
  });

  it('applyLateBindingImageê°€ ì¼ì¹˜í•˜ëŠ” turnIdì— ëŒ€í•´ ì´ë¯¸ì§€ë¥¼ ì ìš©í•´ì•¼ í•œë‹¤', () => {
    const turnId = 5;
    const imageUrl = 'https://example.com/image.png';

    // 1. ë¡œë”© ì‹œì‘
    useWorldStore.getState().setImageLoading(turnId);

    // 2. ì´ë¯¸ì§€ ì ìš©
    const applied = useWorldStore.getState().applyLateBindingImage(imageUrl, turnId);

    expect(applied).toBe(true);
    const state = useWorldStore.getState();
    expect(state.sceneState.status).toBe('scene');
    expect(state.sceneState.imageUrl).toBe(imageUrl);
    expect(state.sceneState.imageLoading).toBe(false);
    expect(state.sceneState.pendingImageTurnId).toBeUndefined();
  });

  it('applyLateBindingImageê°€ ì¼ì¹˜í•˜ì§€ ì•ŠëŠ” turnIdì— ëŒ€í•´ ì´ë¯¸ì§€ë¥¼ ë¬´ì‹œí•´ì•¼ í•œë‹¤', () => {
    const oldTurnId = 5;
    const newTurnId = 6;
    const oldImageUrl = 'https://example.com/old.png';

    // 1. ì´ì „ í„´ ë¡œë”© ì‹œì‘
    useWorldStore.getState().setImageLoading(oldTurnId);

    // 2. ìƒˆ í„´ ì‹œì‘ (ë¡œë”© ìƒíƒœ ë®ì–´ì”€)
    useWorldStore.getState().setImageLoading(newTurnId);

    // 3. ì´ì „ í„´ì˜ ì´ë¯¸ì§€ê°€ ë„ì°©í•¨
    const applied = useWorldStore.getState().applyLateBindingImage(oldImageUrl, oldTurnId);

    expect(applied).toBe(false);
    const state = useWorldStore.getState();
    expect(state.sceneState.pendingImageTurnId).toBe(newTurnId); // ì—¬ì „íˆ ìƒˆ í„´ ëŒ€ê¸° ì¤‘
    expect(state.sceneState.imageUrl).not.toBe(oldImageUrl);
  });

  it('cancelImageLoadingì´ ë¡œë”© ìƒíƒœë¥¼ í•´ì œí•˜ê³  ì´ì „ ì´ë¯¸ì§€ë¥¼ ìœ ì§€í•´ì•¼ í•œë‹¤', () => {
    const turnId = 5;
    const initialImageUrl = 'https://example.com/initial.png';

    // ì´ˆê¸° ì´ë¯¸ì§€ ì„¤ì •
    useWorldStore.setState({
      sceneState: { status: 'scene', imageUrl: initialImageUrl },
    });

    // ë¡œë”© ì‹œì‘
    useWorldStore.getState().setImageLoading(turnId);
    expect(useWorldStore.getState().sceneState.imageLoading).toBe(true);
    expect(useWorldStore.getState().sceneState.previousImageUrl).toBe(initialImageUrl);

    // ë¡œë”© ì·¨ì†Œ
    useWorldStore.getState().cancelImageLoading();

    const state = useWorldStore.getState();
    expect(state.sceneState.imageLoading).toBe(false);
    expect(state.sceneState.imageUrl).toBe(initialImageUrl);
    expect(state.sceneState.previousImageUrl).toBeUndefined();
  });
});
</file>

<file path="frontend/src/turn/turnRunner.test.ts">
import { describe, it, expect, vi, beforeEach, type Mock } from 'vitest';
import { createTurnRunner } from './turnRunner';
import type { TurnInput } from '../schemas/turn';
import type { StreamCallbacks } from '../api/turnStream';

// ëª¨í‚¹
vi.mock('../api/turnStream', () => ({
  startTurnStream: vi.fn(() => vi.fn()),
}));

vi.mock('../api/image', () => ({
  startImageGeneration: vi.fn(),
}));

const mockWorldStore = {
  economy: { signal: 100, memory_shard: 5 },
  sceneState: { status: 'scene', imageUrl: 'old-url.png' },
  setIsAnalyzing: vi.fn(),
  setSceneState: vi.fn(),
  setProcessingPhase: vi.fn(),
  turnCount: 1,
};

vi.mock('../stores/worldStore', () => ({
  useWorldStore: {
    getState: vi.fn(() => mockWorldStore),
  },
}));

vi.mock('../stores/agentStore', () => ({
  useAgentStore: {
    getState: vi.fn(() => ({
      isStreaming: false,
      startStream: vi.fn(),
      completeStream: vi.fn(),
      handleStage: vi.fn(),
      handleBadges: vi.fn(),
      handleNarrativeDelta: vi.fn(),
      handleFinal: vi.fn(),
      handleError: vi.fn(),
    })),
  },
}));

vi.mock('react-i18next', () => ({
  useTranslation: () => ({
    t: (key: string) => key,
  }),
}));

describe('turnRunner (U-089[Mvp])', () => {
  beforeEach(() => {
    vi.clearAllMocks();
  });

  it('ì •ë°€ë¶„ì„ í‚¤ì›Œë“œ ê°ì§€ ì‹œ isAnalyzingì„ trueë¡œ ì„¤ì •í•´ì•¼ í•¨', () => {
    const runner = createTurnRunner({
      t: (key: string) => key,
      theme: 'dark',
      language: 'ko-KR',
    });

    // 1. "ì •ë°€ë¶„ì„" í…ìŠ¤íŠ¸ ì…ë ¥
    runner.runTurn({ text: 'ì •ë°€ë¶„ì„ í•´ì¤˜' });
    expect(mockWorldStore.setIsAnalyzing).toHaveBeenCalledWith(true);

    // 2. ì¼ë°˜ í…ìŠ¤íŠ¸ ì…ë ¥ ì‹œì—ëŠ” ì„¤ì •í•˜ì§€ ì•Šì•„ì•¼ í•¨
    vi.clearAllMocks();
    runner.runTurn({ text: 'ì•ˆë…•í•˜ì„¸ìš”' });
    expect(mockWorldStore.setIsAnalyzing).not.toHaveBeenCalled();
  });

  it('ì •ë°€ë¶„ì„ actionId ê°ì§€ ì‹œ isAnalyzingì„ trueë¡œ ì„¤ì •í•´ì•¼ í•¨', () => {
    const runner = createTurnRunner({
      t: (key: string) => key,
      theme: 'dark',
      language: 'ko-KR',
    });

    runner.runTurn({ text: '', actionId: 'deep_analyze' });
    expect(mockWorldStore.setIsAnalyzing).toHaveBeenCalledWith(true);
  });

  it('ì •ë°€ë¶„ì„ ì¤‘ì—ëŠ” setSceneState({status: "loading"})ì„ í˜¸ì¶œí•˜ì§€ ì•Šì•„ì•¼ í•¨ (ê¸°ì¡´ ì´ë¯¸ì§€ ìœ ì§€)', () => {
    const runner = createTurnRunner({
      t: (key: string) => key,
      theme: 'dark',
      language: 'ko-KR',
    });

    runner.runTurn({ text: 'ì •ë°€ë¶„ì„' });

    // isAnalyzingì€ true
    expect(mockWorldStore.setIsAnalyzing).toHaveBeenCalledWith(true);
    // status: 'loading'ì€ í˜¸ì¶œë˜ì§€ ì•Šì•„ì•¼ í•¨
    expect(mockWorldStore.setSceneState).not.toHaveBeenCalledWith(
      expect.objectContaining({ status: 'loading' }),
    );
  });

  it('í„´ ì™„ë£Œ ì‹œ ìµœì†Œ í‘œì‹œ ì‹œê°„ ì´í›„ isAnalyzingì„ falseë¡œ ì„¤ì •í•´ì•¼ í•¨', async () => {
    vi.useFakeTimers();
    const runner = createTurnRunner({
      t: (key: string) => key,
      theme: 'dark',
      language: 'ko-KR',
    });

    const { startTurnStream } = (await import('../api/turnStream')) as unknown as {
      startTurnStream: Mock;
    };
    let completeCallback: () => void = () => {};

    startTurnStream.mockImplementation((_input: TurnInput, callbacks: StreamCallbacks) => {
      completeCallback = callbacks.onComplete!;
      return vi.fn();
    });

    runner.runTurn({ text: 'ì •ë°€ë¶„ì„' });
    expect(mockWorldStore.setIsAnalyzing).toHaveBeenCalledWith(true);

    // í„´ ì™„ë£Œ í˜¸ì¶œ
    completeCallback();

    // ì¦‰ì‹œëŠ” falseê°€ ë˜ì§€ ì•Šì•„ì•¼ í•¨ (ìµœì†Œ í‘œì‹œ ì‹œê°„ ë•Œë¬¸)
    expect(mockWorldStore.setIsAnalyzing).not.toHaveBeenLastCalledWith(false);

    // 500ms ê²½ê³¼ í›„
    vi.advanceTimersByTime(500);
    expect(mockWorldStore.setIsAnalyzing).toHaveBeenLastCalledWith(false);

    vi.useRealTimers();
  });
});
</file>

<file path="request.json">
{"language": "ko-KR", "text": "ëª¨í—˜ì„ ì‹œì‘í•œë‹¤", "client": {"viewport_w": 1920, "viewport_h": 1080, "theme": "dark"}, "economy_snapshot": {"signal": 5, "memory_shard": 0}}
</file>

<file path="scripts/process_item_icons.py">
"""
U-092[Mvp]: ì•„ì´í…œ ì•„ì´ì½˜ ì¼ê´„ í›„ì²˜ë¦¬ ìŠ¤í¬ë¦½íŠ¸.
nanobanana-mcpë¡œ ìƒì„±ëœ ì›ë³¸ ì´ë¯¸ì§€ì— rembg ë°°ê²½ ì œê±° + ImageMagick ë¦¬ì‚¬ì´ì¦ˆë¥¼ ì ìš©í•©ë‹ˆë‹¤.

Usage:
    python scripts/process_item_icons.py
"""

import subprocess
import sys
from pathlib import Path

# ì†ŒìŠ¤ â†’ íƒ€ê²Ÿ íŒŒì¼ëª… ë§¤í•‘
ICON_MAP = {
    # === ì´ˆê¸° ì•„ì´í…œ (11ê°œ) ===
    "a_minimal_ancient_leatherbound_t.png": "ancient-tome-64.png",
    "a_minimal_feather_quill_pen_icon.png": "quill-pen-64.png",
    "a_minimal_glowing_crystal_memory.png": "memory-fragment-64.png",
    "a_minimal_compass_navigation_too.png": "compass-64.png",
    "a_minimal_coiled_rope_icon_pixel.png": "rope-64.png",
    "a_minimal_glowing_lantern_icon_p.png": "lantern-64.png",
    "a_minimal_torn_map_fragment_piec.png": "map-fragment-64.png",
    "a_minimal_glowing_data_core_sphe.png": "data-core-64.png",
    "a_minimal_green_circuit_board_ic.png": "circuit-board-64.png",
    "a_minimal_energy_cell_battery_ic.png": "energy-cell-64.png",
    "a_minimal_scanner_device_icon_pi.png": "scanner-device-64.png",
    # === ê³µí†µ ì•„ì´í…œ (15ê°œ) ===
    "a_minimal_medieval_sword_icon_pi.png": "sword-64.png",
    "a_minimal_round_shield_icon_pixe.png": "shield-64.png",
    "a_minimal_red_healing_potion_bot.png": "potion-64.png",
    "a_minimal_ornate_golden_key_icon.png": "key-64.png",
    "a_minimal_sparkling_gemstone_ico.png": "gem-64.png",
    "a_minimal_magic_scroll_icon_pixe.png": "scroll-64.png",
    "a_minimal_burning_torch_icon_pix.png": "torch-64.png",
    "a_minimal_green_herb_bundle_icon.png": "herb-64.png",
    "a_minimal_gold_coin_icon_pixel_a.png": "coin-64.png",
    "a_minimal_magic_ring_icon_pixel_.png": "ring-64.png",
    "a_minimal_glowing_amulet_pendant.png": "amulet-64.png",
    "a_minimal_dagger_icon_pixel_art_.png": "dagger-64.png",
    "a_minimal_alchemy_flask_icon_pix.png": "flask-64.png",
    "a_minimal_glowing_crystal_icon_p.png": "crystal-64.png",
    "a_minimal_lockpick_tool_icon_pix.png": "lockpick-64.png",
}

SRC_DIR = Path.home() / "nanobanana-output"
DST_DIR = Path("d:/Dev/unknown-world/frontend/public/ui/items")
TMP_DIR = Path("d:/Dev/unknown-world/frontend/public/ui/items/_tmp")


def run(cmd: list[str], label: str) -> bool:
    """ëª…ë ¹ì–´ë¥¼ ì‹¤í–‰í•˜ê³  ê²°ê³¼ë¥¼ ë°˜í™˜í•©ë‹ˆë‹¤."""
    print(f"  [{label}] {' '.join(cmd[:3])}...")
    result = subprocess.run(cmd, capture_output=True, text=True)
    if result.returncode != 0:
        print(f"  âŒ ì‹¤íŒ¨: {result.stderr[:200]}")
        return False
    return True


def main() -> None:
    import sys
    import io
    sys.stdout = io.TextIOWrapper(sys.stdout.buffer, encoding='utf-8', errors='replace')

    DST_DIR.mkdir(parents=True, exist_ok=True)
    TMP_DIR.mkdir(parents=True, exist_ok=True)

    success = 0
    fail = 0

    for src_name, dst_name in ICON_MAP.items():
        src_path = SRC_DIR / src_name
        if not src_path.exists():
            print(f"[WARN] source not found: {src_name}")
            fail += 1
            continue

        print(f"\n[PROCESS] {src_name} -> {dst_name}")

        # Step 1: rembg background removal
        tmp_nobg = TMP_DIR / f"nobg_{dst_name}"
        ok = run(
            ["rembg", "i", "-m", "birefnet-general", str(src_path), str(tmp_nobg)],
            "rembg",
        )
        if not ok:
            print("  [WARN] rembg failed, using original")
            tmp_nobg = src_path

        # Step 2: ImageMagick trim + resize 64x64
        dst_path = DST_DIR / dst_name
        ok = run(
            [
                "magick",
                str(tmp_nobg),
                "-trim",
                "+repage",
                "-resize", "64x64",
                "-gravity", "center",
                "-background", "transparent",
                "-extent", "64x64",
                str(dst_path),
            ],
            "magick",
        )
        if ok:
            size_kb = dst_path.stat().st_size / 1024
            print(f"  [OK] {dst_name} ({size_kb:.1f}KB)")
            success += 1
        else:
            fail += 1

    # cleanup temp dir
    import shutil
    if TMP_DIR.exists():
        shutil.rmtree(TMP_DIR)

    print(f"\n{'='*50}")
    print(f"[DONE] success={success} fail={fail} total={len(ICON_MAP)}")


if __name__ == "__main__":
    main()
</file>

<file path="backend/debug_api_call.py">
"""Debug: ì„œë²„ API í˜¸ì¶œ í…ŒìŠ¤íŠ¸."""

import json

import httpx


def main():
    url = "http://localhost:8011/api/turn"
    payload = {
        "language": "ko-KR",
        "text": "ë¬¸ì„ ì—´ì–´ë³¸ë‹¤",
        "client": {"viewport_w": 1920, "viewport_h": 1080, "theme": "dark"},
        "economy_snapshot": {"signal": 100, "memory_shard": 5},
    }

    print(f"Sending to: {url}")
    print(f"Payload: {json.dumps(payload, ensure_ascii=False)}")
    print()

    with httpx.Client(timeout=30.0) as client:
        response = client.post(url, json=payload)
        print(f"Status: {response.status_code}")
        print()

        lines = response.text.strip().split("\n")
        for line in lines:
            data = json.loads(line)
            event_type = data.get("type")

            if event_type == "badges":
                print(f"BADGES: {data.get('badges')}")
            elif event_type == "repair":
                print(f"REPAIR attempt={data.get('attempt')}: {data.get('message')}")
            elif event_type == "final":
                final_data = data.get("data", {})
                print(f"FINAL badges: {final_data.get('agent_console', {}).get('badges')}")
                print(
                    f"FINAL repair_count: {final_data.get('agent_console', {}).get('repair_count')}"
                )
                print(f"FINAL narrative: {final_data.get('narrative', '')[:100]}")
                print(
                    f"FINAL model_label: {final_data.get('agent_console', {}).get('model_label')}"
                )
            elif event_type == "error":
                print(f"ERROR: {data.get('message')} code={data.get('code')}")
            elif event_type == "stage":
                status = data.get("status")
                if status == "fail":
                    print(f"STAGE FAIL: {data.get('name')}")


if __name__ == "__main__":
    main()
</file>

<file path="backend/debug_schema_check.py">
"""Debug: ì„œë²„ì— ìºì‹œëœ ì œë„ˆë ˆì´í„°ì™€ ì§ì ‘ ìƒì„±í•œ ê²ƒì„ ë¹„êµí•©ë‹ˆë‹¤."""

import asyncio
import json
import os
from pathlib import Path

from dotenv import load_dotenv

load_dotenv(dotenv_path=Path(__file__).parent / ".env", override=False)
os.environ["UW_MODE"] = "real"

from pydantic import ValidationError

from unknown_world.models.turn import Language, TurnInput, TurnOutput
from unknown_world.orchestrator.generate_turn_output import (
    TurnOutputGenerator,
    _strip_additional_properties,
)
from unknown_world.services.genai_client import (
    reset_genai_client,
)


async def main():
    print("=== 1. Schema comparison ===")
    raw_schema = TurnOutput.model_json_schema()
    stripped = _strip_additional_properties(raw_schema)

    # Check $defs
    if "$defs" in stripped:
        print(f"Schema has $defs with {len(stripped['$defs'])} definitions")
        for name in stripped["$defs"]:
            print(f"  - {name}")
    else:
        print("Schema has NO $defs")

    print(f"Top-level keys: {list(stripped.keys())}")
    print(f"Required: {stripped.get('required', [])}")
    print()

    print("=== 2. Multiple API calls ===")
    reset_genai_client()
    generator = TurnOutputGenerator(force_mock=False)

    turn_input = TurnInput(
        language=Language.KO,
        text="ë¬¸ì„ ì—´ì–´ë³¸ë‹¤",
        client={"viewport_w": 1920, "viewport_h": 1080, "theme": "dark"},
        economy_snapshot={"signal": 100, "memory_shard": 5},
    )

    success_count = 0
    fail_count = 0
    for i in range(3):
        print(f"\n--- Attempt {i + 1} ---")
        result = await generator.generate(turn_input)
        print(f"Status: {result.status}")

        if result.status.value == "success":
            success_count += 1
            print("OK")
        else:
            fail_count += 1
            print(f"Error: {result.error_message}")
            print(f"Details: {json.dumps(result.error_details, indent=2, ensure_ascii=False)}")

            if result.raw_response:
                # Try to parse and identify what's wrong
                text = result.raw_response.strip()
                if text.startswith("```"):
                    lines = text.split("\n")
                    if lines[0].startswith("```"):
                        lines = lines[1:]
                    if lines and lines[-1].strip() == "```":
                        lines = lines[:-1]
                    text = "\n".join(lines)

                try:
                    data = json.loads(text)
                    print(f"JSON keys: {list(data.keys())}")

                    # Check each sub-model for extra fields
                    for key in data:
                        val = data[key]
                        if isinstance(val, dict):
                            # Check if any sub-dict has unexpected keys
                            pass

                    # Try validation manually
                    try:
                        TurnOutput.model_validate(data)
                        print("Pydantic OK (inconsistent!)")
                    except ValidationError as e:
                        print(f"Pydantic errors ({len(e.errors())}):")
                        for err in e.errors():
                            print(f"  loc={err['loc']} type={err['type']} msg={err['msg']}")
                            if "input" in err:
                                inp_str = str(err["input"])[:200]
                                print(f"  input={inp_str}")
                except json.JSONDecodeError:
                    print(f"Raw (first 500): {result.raw_response[:500]}")

    print(f"\n=== Summary: {success_count} success, {fail_count} fail ===")


if __name__ == "__main__":
    asyncio.run(main())
</file>

<file path="backend/debug_server_state.py">
"""Debug: ì„œë²„ì™€ ë™ì¼í•œ ì½”ë“œ ê²½ë¡œë¡œ ë¬¸ì œë¥¼ ì¬í˜„í•©ë‹ˆë‹¤."""

import asyncio
import json
import os
from pathlib import Path

from dotenv import load_dotenv

# ì„œë²„ì™€ ë™ì¼í•˜ê²Œ .env ë¡œë“œ
_DOTENV_PATH = Path(__file__).resolve().parent / ".env"
_dotenv_loaded = load_dotenv(dotenv_path=_DOTENV_PATH, override=False)
print(f".env path: {_DOTENV_PATH}")
print(f".env exists: {_DOTENV_PATH.exists()}")
print(f".env loaded: {_dotenv_loaded}")
print(f"UW_MODE: {os.environ.get('UW_MODE', 'NOT_SET')}")
print(f"GOOGLE_API_KEY set: {bool(os.environ.get('GOOGLE_API_KEY'))}")
print()

from pydantic import ValidationError

from unknown_world.models.turn import Language, TurnInput, TurnOutput
from unknown_world.orchestrator.generate_turn_output import (
    TurnOutputGenerator,
    _strip_additional_properties,
)


async def main():
    # 1. JSON Schema ê²€ì‚¬ - $defs/$ref í™•ì¸
    raw_schema = TurnOutput.model_json_schema()
    stripped = _strip_additional_properties(raw_schema)

    has_refs = "$defs" in stripped
    print(f"Schema has $defs: {has_refs}")

    # $ref ì°¸ì¡°ê°€ ìˆëŠ”ì§€ í™•ì¸
    schema_str = json.dumps(stripped)
    ref_count = schema_str.count('"$ref"')
    print(f"Schema $ref count: {ref_count}")

    if ref_count > 0:
        print("\n!!! WARNING: Schema has $ref references !!!")
        print("Gemini Structured Outputs may not support $ref/$defs.")
        print("This could cause intermittent failures.")
        print()

    # 2. ì„œë²„ì™€ ë™ì¼í•œ ê²½ë¡œë¡œ í˜¸ì¶œ
    turn_input = TurnInput(
        language=Language.KO,
        text="ë¬¸ì„ ì—´ì–´ë³¸ë‹¤",
        client={"viewport_w": 1920, "viewport_h": 1080, "theme": "dark"},
        economy_snapshot={"signal": 100, "memory_shard": 5},
    )

    generator = TurnOutputGenerator(force_mock=False)

    # 3. ìˆ˜ë™ìœ¼ë¡œ Gemini API ì§ì ‘ í˜¸ì¶œí•˜ì—¬ raw ì‘ë‹µ í™•ì¸
    from unknown_world.config.models import ModelLabel
    from unknown_world.services.genai_client import (
        GenerateRequest,
        get_genai_client,
        reset_genai_client,
    )

    reset_genai_client()
    client = get_genai_client(force_mock=False)
    print(f"Client type: {type(client).__name__}")
    print(f"Client mode: {client.mode}")
    print(f"Client available: {client.is_available()}")

    if not client.is_available():
        print("ERROR: Client not available!")
        return

    # 4. í”„ë¡¬í”„íŠ¸ ë¹Œë“œ
    prompt = generator._build_prompt(turn_input)
    json_schema = generator._get_json_schema()

    print(f"\nPrompt length: {len(prompt)} chars")
    print(f"Schema size: {len(json.dumps(json_schema))} chars")

    # 5. Gemini ì§ì ‘ í˜¸ì¶œ
    request = GenerateRequest(
        prompt=prompt,
        model_label=ModelLabel.FAST,
        temperature=0.7,
        response_mime_type="application/json",
        response_schema=json_schema,
    )

    print("\nCalling Gemini API...")
    response = await client.generate(request)
    raw_text = response.text
    print(f"Response length: {len(raw_text)} chars")
    print(f"First 200 chars: {raw_text[:200]}")
    print()

    # 6. JSON íŒŒì‹±
    try:
        text = raw_text.strip()
        if text.startswith("```"):
            lines = text.split("\n")
            if lines[0].startswith("```"):
                lines = lines[1:]
            if lines and lines[-1].strip() == "```":
                lines = lines[:-1]
            text = "\n".join(lines)

        data = json.loads(text)
        print(f"JSON parsed OK. Keys: {list(data.keys())}")
    except json.JSONDecodeError as e:
        print(f"JSON PARSE FAILED: {e}")
        print(f"Full response:\n{raw_text}")
        return

    # 7. Pydantic ê²€ì¦
    try:
        output = TurnOutput.model_validate(data)
        print(f"Pydantic OK! Narrative: {output.narrative[:80]}...")
    except ValidationError as e:
        print(f"\n=== PYDANTIC VALIDATION FAILED ({len(e.errors())} errors) ===")
        for err in e.errors():
            print(f"  loc: {err['loc']}")
            print(f"  type: {err['type']}")
            print(f"  msg: {err['msg']}")
            if "input" in err:
                inp = str(err["input"])[:200]
                print(f"  input: {inp}")
            print()

        # ì–´ë–¤ í•„ë“œì— extra propertiesê°€ ìˆëŠ”ì§€ í™•ì¸
        print("=== Checking for extra properties ===")
        _check_extra_fields(data)


def _check_extra_fields(data, path="root"):
    """ëª¨ë¸ê³¼ ë¹„êµí•˜ì—¬ ì¶”ê°€ í•„ë“œë¥¼ ì°¾ìŠµë‹ˆë‹¤."""
    from unknown_world.models import turn as turn_models

    model_map = {
        "root": turn_models.TurnOutput,
        "economy": turn_models.EconomyOutput,
        "economy.cost": turn_models.CurrencyAmount,
        "economy.balance_after": turn_models.CurrencyAmount,
        "safety": turn_models.SafetyOutput,
        "ui": turn_models.UIOutput,
        "ui.action_deck": turn_models.ActionDeck,
        "world": turn_models.WorldDelta,
        "render": turn_models.RenderOutput,
        "agent_console": turn_models.AgentConsole,
    }

    model_cls = model_map.get(path)
    if model_cls and isinstance(data, dict):
        expected = set(model_cls.model_fields.keys())
        actual = set(data.keys())
        extra = actual - expected
        missing = expected - actual
        if extra:
            print(f"  [{path}] EXTRA fields: {extra}")
        if missing:
            # Only report missing required fields
            required = {
                name for name, field in model_cls.model_fields.items() if field.is_required()
            }
            missing_required = missing & required
            if missing_required:
                print(f"  [{path}] MISSING required: {missing_required}")

    if isinstance(data, dict):
        for key, val in data.items():
            child_path = f"{path}.{key}" if path != "root" else key
            if isinstance(val, dict):
                _check_extra_fields(val, child_path)
            elif isinstance(val, list):
                for i, item in enumerate(val):
                    if isinstance(item, dict):
                        _check_extra_fields(item, f"{child_path}[{i}]")


if __name__ == "__main__":
    asyncio.run(main())
</file>

<file path="backend/debug_uvicorn_sim.py">
"""ì„œë²„ì™€ ë™ì¼í•œ ë°©ì‹ìœ¼ë¡œ ì‹¤í–‰í•˜ì—¬ ë¬¸ì œë¥¼ ì¬í˜„í•©ë‹ˆë‹¤.
main.pyì˜ .env ë¡œë”© â†’ pipeline context â†’ validate_real â†’ repair_loop ì „ì²´ ê²½ë¡œ."""

import asyncio
import os
import sys

# 1) main.pyì™€ ë™ì¼í•œ ë°©ì‹ìœ¼ë¡œ .env ë¡œë“œ
from pathlib import Path

from dotenv import load_dotenv

_DOTENV_PATH = Path(__file__).resolve().parent / ".env"
_dotenv_loaded = load_dotenv(dotenv_path=_DOTENV_PATH, override=False)
print(f"UW_MODE={os.environ.get('UW_MODE')}", file=sys.stderr)
print(f"GOOGLE_API_KEY set={bool(os.environ.get('GOOGLE_API_KEY'))}", file=sys.stderr)

# 2) ì„œë²„ì™€ ë™ì¼í•œ import ê²½ë¡œ
from unknown_world.models.turn import Language, TurnInput
from unknown_world.orchestrator.pipeline import create_pipeline_context, run_pipeline
from unknown_world.orchestrator.stages.types import PipelineEvent, PipelineEventType


async def main():
    turn_input = TurnInput(
        language=Language.KO,
        text="ë¬¸ì„ ì—´ì–´ë³¸ë‹¤",
        client={"viewport_w": 1920, "viewport_h": 1080, "theme": "dark"},
        economy_snapshot={"signal": 100, "memory_shard": 5},
    )

    # 3) Pipeline ì»¨í…ìŠ¤íŠ¸ ìƒì„± (ì„œë²„ì™€ ë™ì¼)
    ctx = create_pipeline_context(turn_input)
    print(f"is_mock={ctx.is_mock}", file=sys.stderr)

    # 4) ì´ë²¤íŠ¸ ìˆ˜ì§‘
    events = []

    async def emit(event: PipelineEvent):
        events.append(event)
        if event.event_type == PipelineEventType.BADGES:
            badge_vals = [b.value for b in event.badges] if event.badges else []
            print(f"EVENT badges: {badge_vals}", file=sys.stderr)
        elif event.event_type == PipelineEventType.REPAIR:
            print(
                f"EVENT repair: attempt={event.repair_attempt} msg={event.repair_message}",
                file=sys.stderr,
            )

    # 5) Pipeline ì‹¤í–‰
    ctx = await run_pipeline(ctx, emit=emit)

    # 6) ê²°ê³¼ ì¶œë ¥
    print(f"\nis_fallback={ctx.is_fallback}", file=sys.stderr)
    print(f"badges={[b.value for b in ctx.badges]}", file=sys.stderr)
    print(f"repair_attempts={ctx.repair_attempts}", file=sys.stderr)

    if ctx.output:
        print(f"narrative={ctx.output.narrative[:100]}", file=sys.stderr)
        print(
            f"output_badges={[b.value for b in ctx.output.agent_console.badges]}", file=sys.stderr
        )


if __name__ == "__main__":
    asyncio.run(main())
</file>

<file path="backend/run_full_test.py">
"""ì •í™•í•œ ì¬í˜„: uvicorn CLIì²˜ëŸ¼ ì„œë²„ë¥¼ ì‹œì‘í•˜ê³  í…ŒìŠ¤íŠ¸í•©ë‹ˆë‹¤."""

import json
import os
import subprocess
import time

import httpx


def main():
    # ì„œë²„ ì‹œì‘ (ì‚¬ìš©ìì™€ ë™ì¼í•œ ëª…ë ¹ì–´)
    env = os.environ.copy()
    proc = subprocess.Popen(
        [
            "uv",
            "run",
            "uvicorn",
            "src.unknown_world.main:app",
            "--host",
            "0.0.0.0",
            "--port",
            "8011",
        ],
        cwd=r"D:\Dev\unknown-world\backend",
        stdout=subprocess.PIPE,
        stderr=subprocess.PIPE,
        env=env,
    )
    print(f"Server PID: {proc.pid}")

    # ì„œë²„ ì‹œì‘ ëŒ€ê¸°
    for i in range(15):
        time.sleep(1)
        try:
            r = httpx.get("http://localhost:8011/health", timeout=2.0)
            if r.status_code == 200:
                print(f"Server ready after {i + 1}s")
                break
        except Exception:
            pass
    else:
        print("Server failed to start!")
        proc.terminate()
        stderr = proc.stderr.read().decode("utf-8", errors="replace")
        print(f"STDERR:\n{stderr[:2000]}")
        return

    # API í…ŒìŠ¤íŠ¸
    print("\n=== API Test ===")
    try:
        r = httpx.post(
            "http://localhost:8011/api/turn",
            json={
                "language": "ko-KR",
                "text": "ë¬¸ì„ ì—´ì–´ë³¸ë‹¤",
                "client": {"viewport_w": 1920, "viewport_h": 1080, "theme": "dark"},
                "economy_snapshot": {"signal": 100, "memory_shard": 5},
            },
            timeout=60.0,
        )

        for line in r.text.strip().split("\n"):
            d = json.loads(line)
            t = d.get("type")
            if t == "repair":
                print(f"  REPAIR: attempt={d.get('attempt')} msg={d.get('message')}")
            elif t == "badges":
                print(f"  BADGES: {d.get('badges')}")
            elif t == "final":
                fc = d.get("data", {}).get("agent_console", {})
                narr = d.get("data", {}).get("narrative", "")[:80]
                print(f"  FINAL badges={fc.get('badges')} repair={fc.get('repair_count')}")
                print(f"  NARRATIVE: {narr}")
            elif t == "error":
                print(f"  ERROR: {d.get('message')} code={d.get('code')}")
    except Exception as e:
        print(f"  EXCEPTION: {e}")

    # ì„œë²„ stderr ì¶œë ¥ (ë””ë²„ê·¸ ë¡œê·¸ í¬í•¨)
    proc.terminate()
    try:
        proc.wait(timeout=5)
    except subprocess.TimeoutExpired:
        proc.kill()

    stderr = proc.stderr.read().decode("utf-8", errors="replace")
    print("\n=== Server STDERR (last 3000 chars) ===")
    print(stderr[-3000:])


if __name__ == "__main__":
    main()
</file>

<file path="backend/src/unknown_world/api/turn_streaming_helpers.py">
"""Unknown World - Turn ìŠ¤íŠ¸ë¦¬ë° ê³µí†µ í—¬í¼.

NDJSON ìŠ¤íŠ¸ë¦¬ë°ì—ì„œ ë°˜ë³µë˜ëŠ” íŒ¨í„´ì„ ì¶”ì¶œí•œ í—¬í¼ í•¨ìˆ˜ë“¤ì…ë‹ˆë‹¤.

ì„¤ê³„ ì›ì¹™:
    - RU-005-Q3: ì¤‘ë³µë˜ëŠ” ìŠ¤íŠ¸ë¦¬ë° ì¡°ê°ì„ helperë¡œ ì¶”ì¶œ
    - RULE-004: ì—ëŸ¬ ê²½ë¡œì—ì„œë„ final 1íšŒ ì¢…ë£Œ ì¸ë°”ë¦¬ì–¸íŠ¸ ìœ ì§€
    - RULE-007/008: í”„ë¡¬í”„íŠ¸/ë‚´ë¶€ ì¶”ë¡  ë…¸ì¶œ ê¸ˆì§€

ì°¸ì¡°:
    - vibe/refactors/RU-005-Q3.md
    - vibe/unit-plans/U-007[Mvp].md
"""

from __future__ import annotations

import asyncio
from collections.abc import AsyncGenerator

from unknown_world.api.turn_stream_events import (
    ErrorEvent,
    FinalEvent,
    NarrativeDeltaEvent,
    StreamEventType,
    serialize_event,
)
from unknown_world.models.turn import (
    CurrencyAmount,
    Language,
    TurnOutput,
)
from unknown_world.orchestrator.fallback import create_safe_fallback

# =============================================================================
# ìŠ¤íŠ¸ë¦¬ë° í—¬í¼ ìƒìˆ˜
# =============================================================================

DEFAULT_CHUNK_SIZE = 20
"""ë‚´ëŸ¬í‹°ë¸Œ ë¸íƒ€ ì²­í¬ í¬ê¸° (ë¬¸ì ìˆ˜)."""

DEFAULT_TYPING_DELAY_SEC = 0.02
"""íƒ€ì íš¨ê³¼ ë”œë ˆì´ (ì´ˆ)."""

# =============================================================================
# ì—ëŸ¬ ë©”ì‹œì§€ (i18n)
# =============================================================================

ERROR_MESSAGES = {
    Language.KO: {
        "internal_error": "ì²˜ë¦¬ ì¤‘ ì˜¤ë¥˜ê°€ ë°œìƒí–ˆìŠµë‹ˆë‹¤",
        "validation_error": "ì…ë ¥ ê²€ì¦ì— ì‹¤íŒ¨í–ˆìŠµë‹ˆë‹¤",
    },
    Language.EN: {
        "internal_error": "An error occurred during processing",
        "validation_error": "Input validation failed",
    },
}


# =============================================================================
# ë‚´ëŸ¬í‹°ë¸Œ ë¸íƒ€ ìŠ¤íŠ¸ë¦¬ë° í—¬í¼
# =============================================================================


async def stream_narrative_delta(
    narrative: str,
    *,
    chunk_size: int = DEFAULT_CHUNK_SIZE,
    delay_sec: float = DEFAULT_TYPING_DELAY_SEC,
) -> AsyncGenerator[str]:
    """ë‚´ëŸ¬í‹°ë¸Œ í…ìŠ¤íŠ¸ë¥¼ íƒ€ì íš¨ê³¼ë¡œ ìŠ¤íŠ¸ë¦¬ë°í•©ë‹ˆë‹¤.

    Args:
        narrative: ì „ì²´ ë‚´ëŸ¬í‹°ë¸Œ í…ìŠ¤íŠ¸
        chunk_size: ì²­í¬ë‹¹ ë¬¸ì ìˆ˜ (ê¸°ë³¸ 20)
        delay_sec: ì²­í¬ ê°„ ë”œë ˆì´ (ì´ˆ, ê¸°ë³¸ 0.02)

    Yields:
        str: NDJSON ë¼ì¸ (narrative_delta ì´ë²¤íŠ¸)

    Example:
        >>> async for line in stream_narrative_delta("ì•ˆë…•í•˜ì„¸ìš”"):
        ...     print(line)
    """
    for i in range(0, len(narrative), chunk_size):
        chunk = narrative[i : i + chunk_size]
        yield serialize_event(
            NarrativeDeltaEvent(
                type=StreamEventType.NARRATIVE_DELTA,
                text=chunk,
            ).model_dump()
        )
        await asyncio.sleep(delay_sec)


# =============================================================================
# Error + Final í´ë°± í—¬í¼
# =============================================================================


async def emit_error_with_fallback(
    language: Language,
    *,
    error_message: str | None = None,
    error_code: str = "INTERNAL_ERROR",
    economy_snapshot: CurrencyAmount | None = None,
    repair_count: int = 0,
    is_blocked: bool = False,
) -> AsyncGenerator[str]:
    """ì—ëŸ¬ ì´ë²¤íŠ¸ì™€ ì•ˆì „í•œ í´ë°± finalì„ ìˆœì„œëŒ€ë¡œ ì†¡ì¶œí•©ë‹ˆë‹¤.

    RULE-004: ì—ëŸ¬ ê²½ë¡œì—ì„œë„ ë°˜ë“œì‹œ final 1íšŒ ì¢…ë£Œ ì¸ë°”ë¦¬ì–¸íŠ¸ë¥¼ ìœ ì§€í•©ë‹ˆë‹¤.

    Args:
        language: ì‘ë‹µ ì–¸ì–´
        error_message: ì—ëŸ¬ ë©”ì‹œì§€ (Noneì´ë©´ ê¸°ë³¸ ë©”ì‹œì§€ ì‚¬ìš©)
        error_code: ì—ëŸ¬ ì½”ë“œ (ê¸°ë³¸ "INTERNAL_ERROR")
        economy_snapshot: í˜„ì¬ ì¬í™” ìƒíƒœ
        repair_count: ë³µêµ¬ ì‹œë„ íšŸìˆ˜
        is_blocked: ì•ˆì „ ì •ì±…ì— ì˜í•´ ì°¨ë‹¨ë˜ì—ˆëŠ”ì§€

    Yields:
        str: NDJSON ë¼ì¸ (error ì´ë²¤íŠ¸ â†’ final ì´ë²¤íŠ¸)

    Example:
        >>> async for line in emit_error_with_fallback(Language.KO):
        ...     print(line)
    """
    # ì—ëŸ¬ ë©”ì‹œì§€ ê²°ì •
    messages = ERROR_MESSAGES[language]
    message = error_message or messages.get("internal_error", "Error occurred")

    # ì—ëŸ¬ ì´ë²¤íŠ¸ ì†¡ì¶œ
    yield serialize_event(
        ErrorEvent(
            type=StreamEventType.ERROR,
            message=message,
            code=error_code,
        ).model_dump()
    )

    # ì•ˆì „í•œ í´ë°± ìƒì„± ë° ì†¡ì¶œ
    fallback = create_safe_fallback(
        language=language,
        economy_snapshot=economy_snapshot,
        repair_count=repair_count,
        is_blocked=is_blocked,
    )
    # U-069: TurnOutputì„ ë¨¼ì € ì§ë ¬í™”í•˜ì—¬ ëª¨ë“  í•„ë“œ í¬í•¨
    fallback_dict = fallback.model_dump(mode="json")
    yield serialize_event(
        FinalEvent(
            type=StreamEventType.FINAL,
            data=fallback_dict,
        ).model_dump(mode="json")
    )


async def emit_final(output: TurnOutput) -> AsyncGenerator[str]:
    """ìµœì¢… TurnOutputì„ final ì´ë²¤íŠ¸ë¡œ ì†¡ì¶œí•©ë‹ˆë‹¤.

    Args:
        output: ìµœì¢… TurnOutput

    Yields:
        str: NDJSON ë¼ì¸ (final ì´ë²¤íŠ¸)

    Note:
        U-069 ë²„ê·¸ ìˆ˜ì •: TurnOutputì„ ë¨¼ì € model_dump()ë¡œ ì§ë ¬í™”í•˜ì—¬
        agent_console.model_label ë“± ëª¨ë“  í•„ë“œê°€ í¬í•¨ë˜ë„ë¡ í•©ë‹ˆë‹¤.
        FinalEvent.dataê°€ Any íƒ€ì…ì´ë¼ ì¤‘ì²© Pydantic ëª¨ë¸ì´
        ìë™ ì§ë ¬í™”ë˜ì§€ ì•ŠëŠ” ë¬¸ì œë¥¼ í•´ê²°í•©ë‹ˆë‹¤.
    """
    # U-069: TurnOutputì„ ë¨¼ì € ì§ë ¬í™”í•˜ì—¬ ëª¨ë“  í•„ë“œ í¬í•¨
    output_dict = output.model_dump(mode="json")
    yield serialize_event(
        FinalEvent(
            type=StreamEventType.FINAL,
            data=output_dict,
        ).model_dump(mode="json")
    )


# =============================================================================
# ë³µí•© í—¬í¼ (ë‚´ëŸ¬í‹°ë¸Œ + final)
# =============================================================================


async def stream_output_with_narrative(
    output: TurnOutput,
    *,
    chunk_size: int = DEFAULT_CHUNK_SIZE,
    delay_sec: float = DEFAULT_TYPING_DELAY_SEC,
) -> AsyncGenerator[str]:
    """ë‚´ëŸ¬í‹°ë¸Œ ë¸íƒ€ ìŠ¤íŠ¸ë¦¬ë° í›„ final ì´ë²¤íŠ¸ë¥¼ ì†¡ì¶œí•©ë‹ˆë‹¤.

    Args:
        output: ìµœì¢… TurnOutput
        chunk_size: ì²­í¬ë‹¹ ë¬¸ì ìˆ˜
        delay_sec: ì²­í¬ ê°„ ë”œë ˆì´ (ì´ˆ)

    Yields:
        str: NDJSON ë¼ì¸ (narrative_delta ì´ë²¤íŠ¸ë“¤ â†’ final ì´ë²¤íŠ¸)
    """
    # ë‚´ëŸ¬í‹°ë¸Œ ë¸íƒ€ ìŠ¤íŠ¸ë¦¬ë°
    async for line in stream_narrative_delta(
        output.narrative,
        chunk_size=chunk_size,
        delay_sec=delay_sec,
    ):
        yield line

    # final ì´ë²¤íŠ¸ ì†¡ì¶œ
    async for line in emit_final(output):
        yield line


# =============================================================================
# ëª¨ë“ˆ ê³µê°œ API
# =============================================================================

__all__ = [
    "DEFAULT_CHUNK_SIZE",
    "DEFAULT_TYPING_DELAY_SEC",
    "ERROR_MESSAGES",
    "stream_narrative_delta",
    "emit_error_with_fallback",
    "emit_final",
    "stream_output_with_narrative",
]
</file>

<file path="backend/src/unknown_world/models/scanner.py">
"""Unknown World - Scanner(ì´ë¯¸ì§€ ì´í•´) ìŠ¤í‚¤ë§ˆ.

ì´ ëª¨ë“ˆì€ ì´ë¯¸ì§€ ì—…ë¡œë“œ/ë¶„ì„ APIì˜ ìš”ì²­/ì‘ë‹µ ìŠ¤í‚¤ë§ˆë¥¼ ì •ì˜í•©ë‹ˆë‹¤.
ì‚¬ìš©ìê°€ ì—…ë¡œë“œí•œ ì´ë¯¸ì§€ë¥¼ ë¶„ì„í•˜ì—¬ "ë‹¨ì„œ/ì•„ì´í…œ í›„ë³´"ë¡œ ë³€í™˜í•©ë‹ˆë‹¤.

ì„¤ê³„ ì›ì¹™:
    - RULE-004: ì‹¤íŒ¨ ì‹œ ì•ˆì „í•œ í´ë°± (í…ìŠ¤íŠ¸-only ìº¡ì…˜)
    - RULE-009: bboxëŠ” 0~1000 ì •ê·œí™” + [ymin, xmin, ymax, xmax]

í˜ì–´ë§ ì§ˆë¬¸ ê²°ì •:
    - Q1: Option A (multipart ì—…ë¡œë“œë¡œ ì²˜ë¦¬, ë‹¨ìˆœ)

ì°¸ì¡°:
    - vibe/unit-plans/U-021[Mvp].md
    - vibe/prd.md 8.6 (ì´ë¯¸ì§€ ì´í•´ ìš”êµ¬)
    - .cursor/rules/00-core-critical.mdc (RULE-004, RULE-009)
"""

from enum import StrEnum

from pydantic import BaseModel, ConfigDict, Field

from unknown_world.models.turn import Box2D, Language


class ScanStatus(StrEnum):
    """ìŠ¤ìº” ìƒíƒœ.

    Attributes:
        COMPLETED: ë¶„ì„ ì„±ê³µ
        PARTIAL: ë¶€ë¶„ ì„±ê³µ (ì¼ë¶€ ì •ë³´ë§Œ ì¶”ì¶œë¨)
        FAILED: ë¶„ì„ ì‹¤íŒ¨
        BLOCKED: ì•ˆì „ ì •ì±…ì— ì˜í•´ ì°¨ë‹¨ë¨
    """

    COMPLETED = "completed"
    PARTIAL = "partial"
    FAILED = "failed"
    BLOCKED = "blocked"


class DetectedObject(BaseModel):
    """ê°ì§€ëœ ì˜¤ë¸Œì íŠ¸.

    ì´ë¯¸ì§€ì—ì„œ ê°ì§€ëœ ì˜¤ë¸Œì íŠ¸ ì •ë³´ì…ë‹ˆë‹¤.
    bboxëŠ” 0~1000 ì •ê·œí™” + [ymin, xmin, ymax, xmax] ê·œì•½ì„ ì¤€ìˆ˜í•©ë‹ˆë‹¤ (RULE-009).

    Attributes:
        label: ì˜¤ë¸Œì íŠ¸ ë¼ë²¨ (ì˜ˆ: "ì—´ì‡ ", "ë¬¸", "ìƒì")
        box_2d: ë°”ìš´ë”© ë°•ìŠ¤ (0~1000 ì •ê·œí™”)
        confidence: ì‹ ë¢°ë„ (0.0~1.0, ì„ íƒ)
        suggested_item_type: ì¶”ì²œ ì•„ì´í…œ ìœ í˜• (ì˜ˆ: "key", "weapon", "clue")
    """

    model_config = ConfigDict(extra="forbid")

    label: str = Field(description="ì˜¤ë¸Œì íŠ¸ ë¼ë²¨")
    box_2d: Box2D = Field(description="ë°”ìš´ë”© ë°•ìŠ¤ (0~1000 ì •ê·œí™”)")
    confidence: float | None = Field(
        default=None,
        ge=0.0,
        le=1.0,
        description="ì‹ ë¢°ë„ (0.0~1.0)",
    )
    suggested_item_type: str | None = Field(
        default=None,
        description="ì¶”ì²œ ì•„ì´í…œ ìœ í˜• (ì˜ˆ: key, weapon, clue)",
    )


class ItemCandidate(BaseModel):
    """ì•„ì´í…œ í›„ë³´.

    ê°ì§€ëœ ì˜¤ë¸Œì íŠ¸ë¥¼ ê¸°ë°˜ìœ¼ë¡œ ìƒì„±ëœ ê²Œì„ ì•„ì´í…œ í›„ë³´ì…ë‹ˆë‹¤.

    Attributes:
        id: ì•„ì´í…œ í›„ë³´ ID
        label: ì•„ì´í…œ ì´ë¦„
        description: ì•„ì´í…œ ì„¤ëª…
        item_type: ì•„ì´í…œ ìœ í˜• (ì˜ˆ: "key", "weapon", "clue", "material")
        source_object_index: ì›ë³¸ ì˜¤ë¸Œì íŠ¸ ì¸ë±ìŠ¤ (objects[] ê¸°ì¤€)
    """

    model_config = ConfigDict(extra="forbid")

    id: str = Field(description="ì•„ì´í…œ í›„ë³´ ID")
    label: str = Field(description="ì•„ì´í…œ ì´ë¦„")
    description: str = Field(default="", description="ì•„ì´í…œ ì„¤ëª…")
    item_type: str = Field(default="material", description="ì•„ì´í…œ ìœ í˜•")
    source_object_index: int | None = Field(
        default=None,
        ge=0,
        description="ì›ë³¸ ì˜¤ë¸Œì íŠ¸ ì¸ë±ìŠ¤",
    )


class ScanResult(BaseModel):
    """ìŠ¤ìº” ê²°ê³¼.

    ì´ë¯¸ì§€ ë¶„ì„ ê²°ê³¼ ì „ì²´ë¥¼ ë‹´ëŠ” ëª¨ë¸ì…ë‹ˆë‹¤.

    Attributes:
        status: ìŠ¤ìº” ìƒíƒœ
        caption: ì´ë¯¸ì§€ ì „ì²´ ìº¡ì…˜
        objects: ê°ì§€ëœ ì˜¤ë¸Œì íŠ¸ ëª©ë¡
        item_candidates: ì•„ì´í…œ í›„ë³´ ëª©ë¡
        message: ìƒíƒœ ë©”ì‹œì§€ (ì—ëŸ¬/ê²½ê³  ì‹œ)
        analysis_time_ms: ë¶„ì„ ì†Œìš” ì‹œê°„ (ms)
        original_image_key: ì €ì¥ëœ ì›ë³¸ ì´ë¯¸ì§€ì˜ ìŠ¤í† ë¦¬ì§€ í‚¤ (RU-006-S1)
        original_image_url: ì €ì¥ëœ ì›ë³¸ ì´ë¯¸ì§€ì˜ ì ‘ê·¼ URL (RU-006-S1)
    """

    model_config = ConfigDict(extra="forbid")

    status: ScanStatus = Field(description="ìŠ¤ìº” ìƒíƒœ")
    caption: str = Field(default="", description="ì´ë¯¸ì§€ ì „ì²´ ìº¡ì…˜")
    objects: list[DetectedObject] = Field(
        default_factory=lambda: [],
        description="ê°ì§€ëœ ì˜¤ë¸Œì íŠ¸ ëª©ë¡",
    )
    item_candidates: list[ItemCandidate] = Field(
        default_factory=lambda: [],
        description="ì•„ì´í…œ í›„ë³´ ëª©ë¡",
    )
    message: str | None = Field(default=None, description="ìƒíƒœ ë©”ì‹œì§€")
    analysis_time_ms: int = Field(default=0, description="ë¶„ì„ ì†Œìš” ì‹œê°„ (ms)")
    original_image_key: str | None = Field(
        default=None,
        description="ì €ì¥ëœ ì›ë³¸ ì´ë¯¸ì§€ì˜ ìŠ¤í† ë¦¬ì§€ í‚¤ (ì„ íƒì  ì €ì¥ ì‹œ)",
    )
    original_image_url: str | None = Field(
        default=None,
        description="ì €ì¥ëœ ì›ë³¸ ì´ë¯¸ì§€ì˜ ì ‘ê·¼ URL (ì„ íƒì  ì €ì¥ ì‹œ)",
    )


class ScanRequest(BaseModel):
    """ìŠ¤ìº” ìš”ì²­ (API ê³„ì¸µìš©).

    Attributes:
        language: ì‘ë‹µ ì–¸ì–´ (ìº¡ì…˜/ë¼ë²¨ì— ì ìš©)
    """

    model_config = ConfigDict(extra="forbid")

    language: Language = Field(
        default=Language.KO,
        description="ì‘ë‹µ ì–¸ì–´ (ìº¡ì…˜/ë¼ë²¨ì— ì ìš©)",
    )


class ScanResponse(BaseModel):
    """ìŠ¤ìº” ì‘ë‹µ (API ê³„ì¸µìš©).

    Attributes:
        success: ì„±ê³µ ì—¬ë¶€
        result: ìŠ¤ìº” ê²°ê³¼
        language: ì‘ë‹µ ì–¸ì–´
    """

    model_config = ConfigDict(extra="forbid")

    success: bool = Field(description="ì„±ê³µ ì—¬ë¶€")
    result: ScanResult = Field(description="ìŠ¤ìº” ê²°ê³¼")
    language: Language = Field(description="ì‘ë‹µ ì–¸ì–´")
</file>

<file path="backend/src/unknown_world/orchestrator/__init__.py">
"""Unknown World - Orchestrator íŒ¨í‚¤ì§€.

ì´ íŒ¨í‚¤ì§€ëŠ” í„´ ì²˜ë¦¬ ì˜¤ì¼€ìŠ¤íŠ¸ë ˆì´í„°ë¥¼ í¬í•¨í•©ë‹ˆë‹¤.
"""

from unknown_world.orchestrator.fallback import create_safe_fallback
from unknown_world.orchestrator.generate_turn_output import (
    GenerationResult,
    GenerationStatus,
    TurnOutputGenerator,
    generate_turn_output,
    get_turn_output_generator,
)
from unknown_world.orchestrator.mock import MockOrchestrator
from unknown_world.orchestrator.prompt_loader import (
    clear_prompt_cache,
    load_prompt,
    load_system_prompt,
    load_turn_instructions,
)
from unknown_world.orchestrator.repair_loop import (
    MAX_REPAIR_ATTEMPTS,
    RepairLoopResult,
    run_repair_loop,
)

__all__ = [
    # Mock Orchestrator
    "MockOrchestrator",
    # TurnOutput ìƒì„±
    "GenerationResult",
    "GenerationStatus",
    "TurnOutputGenerator",
    "generate_turn_output",
    "get_turn_output_generator",
    # Repair Loop (U-018)
    "MAX_REPAIR_ATTEMPTS",
    "RepairLoopResult",
    "run_repair_loop",
    # Fallback (U-018)
    "create_safe_fallback",
    # í”„ë¡¬í”„íŠ¸ ë¡œë”
    "clear_prompt_cache",
    "load_prompt",
    "load_system_prompt",
    "load_turn_instructions",
]
</file>

<file path="backend/src/unknown_world/orchestrator/pipeline.py">
"""Unknown World - Pipeline ì‹¤í–‰ê¸°.

Stage í•¨ìˆ˜ë“¤ì„ ì²´ì¸ìœ¼ë¡œ ì¡°í•©í•˜ì—¬ ì‹¤í–‰í•˜ëŠ” íŒŒì´í”„ë¼ì¸ì…ë‹ˆë‹¤.

ì„¤ê³„ ì›ì¹™:
    - Option A (RU-005 Q1 ê²°ì •): í•¨ìˆ˜ ì²´ì¸ ë°©ì‹, í´ë˜ìŠ¤ ë„ì… ì—†ìŒ
    - ë™ì‘ ë³´ì¡´: ê¸°ì¡´ mock/real ê²½ë¡œì˜ ê²°ê³¼(JSON) ì˜ë¯¸ ìœ ì§€
    - ê´€ì¸¡ ê°€ëŠ¥ì„± SSOT: stage start/complete/fail, badges, repairë¥¼ ì¼ê´€ë˜ê²Œ ìƒì„±
    - ë ˆì´ì–´ë§ ë³´í˜¸: ì˜¤ì¼€ìŠ¤íŠ¸ë ˆì´í„°ê°€ FastAPIì— ì§ì ‘ ì˜ì¡´í•˜ì§€ ì•ŠìŒ
    - U-051: ì´ë¯¸ì§€ ìƒì„± ì„œë¹„ìŠ¤ ì˜ì¡´ì„± ì£¼ì… (Option A: ë§¤ê°œë³€ìˆ˜ ì „ë‹¬, í…ŒìŠ¤íŠ¸ ìš©ì´)

ì°¸ì¡°:
    - vibe/refactors/RU-005-Q4.md
    - vibe/refactors/RU-005-SUMMARY.md
    - vibe/unit-results/U-019[Mvp].md
"""

from __future__ import annotations

import os
from collections.abc import Sequence
from typing import TYPE_CHECKING

from unknown_world.models.turn import CurrencyAmount, TurnInput
from unknown_world.orchestrator.fallback import create_safe_fallback
from unknown_world.orchestrator.stages.commit import commit_stage
from unknown_world.orchestrator.stages.parse import parse_stage
from unknown_world.orchestrator.stages.plan import plan_stage
from unknown_world.orchestrator.stages.render import render_stage
from unknown_world.orchestrator.stages.resolve import resolve_stage
from unknown_world.orchestrator.stages.types import (
    EmitFn,
    PipelineContext,
    StageFn,
)
from unknown_world.orchestrator.stages.validate import validate_stage
from unknown_world.orchestrator.stages.verify import verify_stage
from unknown_world.services.image_generation import get_image_generator

if TYPE_CHECKING:
    from unknown_world.services.image_generation import ImageGeneratorType

# =============================================================================
# ê¸°ë³¸ Stage ìˆœì„œ (PRD ê¸°ì¤€)
# =============================================================================

DEFAULT_STAGES: Sequence[StageFn] = [
    parse_stage,
    validate_stage,
    plan_stage,
    resolve_stage,
    render_stage,
    verify_stage,
    commit_stage,
]
"""ê¸°ë³¸ íŒŒì´í”„ë¼ì¸ ë‹¨ê³„ ìˆœì„œ.

Parse â†’ Validate â†’ Plan â†’ Resolve â†’ Render â†’ Verify â†’ Commit
"""


# =============================================================================
# Pipeline ì‹¤í–‰ í•¨ìˆ˜
# =============================================================================


def _is_mock_mode() -> bool:
    """Mock ëª¨ë“œ ì—¬ë¶€ë¥¼ í™•ì¸í•©ë‹ˆë‹¤.

    UW_MODE í™˜ê²½ë³€ìˆ˜ê°€ 'mock'ì´ë©´ Mock ëª¨ë“œë¡œ ë™ì‘í•©ë‹ˆë‹¤.
    ê¸°ë³¸ê°’ì€ 'mock'ì…ë‹ˆë‹¤ (MVP ë‹¨ê³„).
    """
    return os.environ.get("UW_MODE", "mock").lower() == "mock"


def create_pipeline_context(
    turn_input: TurnInput,
    *,
    seed: int | None = None,
    is_mock: bool | None = None,
    image_generator: ImageGeneratorType | None = None,
) -> PipelineContext:
    """íŒŒì´í”„ë¼ì¸ ì»¨í…ìŠ¤íŠ¸ë¥¼ ìƒì„±í•©ë‹ˆë‹¤.

    Args:
        turn_input: ì‚¬ìš©ì í„´ ì…ë ¥
        seed: Mock ëª¨ë“œ ì‹œë“œ (ì¬í˜„ì„± ë³´ì¥)
        is_mock: Mock ëª¨ë“œ ì—¬ë¶€ (Noneì´ë©´ í™˜ê²½ë³€ìˆ˜ ê¸°ì¤€)
        image_generator: ì´ë¯¸ì§€ ìƒì„± ì„œë¹„ìŠ¤ ì¸ìŠ¤í„´ìŠ¤ (U-051)
            Noneì´ë©´ render_stageì—ì„œ ì´ë¯¸ì§€ ìƒì„±ì„ ê±´ë„ˆëœë‹ˆë‹¤ (ê¸°ì¡´ ë™ì‘ ë³´ì¡´).
            í…ŒìŠ¤íŠ¸ ì‹œ MockImageGeneratorë¥¼ ì£¼ì…í•˜ì—¬ ëª¨í‚¹ ê°€ëŠ¥í•©ë‹ˆë‹¤.

    Returns:
        ì´ˆê¸°í™”ëœ íŒŒì´í”„ë¼ì¸ ì»¨í…ìŠ¤íŠ¸

    Example:
        >>> # ê¸°ë³¸ ì‚¬ìš© (ì´ë¯¸ì§€ ìƒì„± ì—†ìŒ)
        >>> ctx = create_pipeline_context(turn_input)
        >>>
        >>> # ì´ë¯¸ì§€ ìƒì„± ì„œë¹„ìŠ¤ ì£¼ì…
        >>> from unknown_world.services.image_generation import get_image_generator
        >>> generator = get_image_generator()
        >>> ctx = create_pipeline_context(turn_input, image_generator=generator)
        >>>
        >>> # í…ŒìŠ¤íŠ¸ìš© Mock ì£¼ì…
        >>> from unknown_world.services.image_generation import MockImageGenerator
        >>> mock_gen = MockImageGenerator()
        >>> ctx = create_pipeline_context(turn_input, image_generator=mock_gen)
    """
    economy_snapshot = CurrencyAmount(
        signal=turn_input.economy_snapshot.signal,
        memory_shard=turn_input.economy_snapshot.memory_shard,
    )

    is_mock = is_mock if is_mock is not None else _is_mock_mode()

    # ì´ë¯¸ì§€ ìƒì„±ê¸° ìë™ íšë“ (U-051)
    if image_generator is None:
        image_generator = get_image_generator(force_mock=is_mock)

    return PipelineContext(
        turn_input=turn_input,
        economy_snapshot=economy_snapshot,
        is_mock=is_mock,
        seed=seed,
        image_generator=image_generator,
    )


async def run_pipeline(
    ctx: PipelineContext,
    *,
    emit: EmitFn,
    stages: Sequence[StageFn] | None = None,
) -> PipelineContext:
    """íŒŒì´í”„ë¼ì¸ì„ ì‹¤í–‰í•©ë‹ˆë‹¤.

    Stage í•¨ìˆ˜ë“¤ì„ ìˆœì„œëŒ€ë¡œ ì‹¤í–‰í•˜ê³ , ê° ë‹¨ê³„ì—ì„œ emit ì½œë°±ì„ í†µí•´
    ë„ë©”ì¸ ì´ë²¤íŠ¸ë¥¼ ì „ë‹¬í•©ë‹ˆë‹¤.

    ì˜ˆì™¸ê°€ ë°œìƒí•˜ë©´ ì•ˆì „í•œ í´ë°±ìœ¼ë¡œ ì¢…ë£Œí•©ë‹ˆë‹¤ (RULE-004).

    Args:
        ctx: íŒŒì´í”„ë¼ì¸ ì»¨í…ìŠ¤íŠ¸
        emit: ì´ë²¤íŠ¸ emit ì½œë°±
        stages: ì‹¤í–‰í•  stage ëª©ë¡ (Noneì´ë©´ ê¸°ë³¸ ìˆœì„œ)

    Returns:
        ìµœì¢… íŒŒì´í”„ë¼ì¸ ì»¨í…ìŠ¤íŠ¸

    Example:
        >>> ctx = create_pipeline_context(turn_input, seed=42)
        >>> ctx = await run_pipeline(ctx, emit=my_emit_fn)
        >>> print(ctx.output.narrative)
    """
    if stages is None:
        stages = DEFAULT_STAGES

    try:
        for stage in stages:
            ctx = await stage(ctx, emit=emit)

            # outputì´ Noneì´ë©´ validate ì‹¤íŒ¨ ë“± â†’ ì´í›„ ë‹¨ê³„ëŠ” ìŠ¤í‚µ
            # (ë‹¨, parse ë‹¨ê³„ëŠ” outputì´ ì—†ì–´ë„ ì •ìƒ)
            if ctx.output is None and stage != parse_stage:
                # í´ë°± ìƒì„±
                ctx.output = create_safe_fallback(
                    language=ctx.turn_input.language,
                    economy_snapshot=ctx.economy_snapshot,
                    repair_count=ctx.repair_attempts,
                )
                ctx.is_fallback = True
                break

    except Exception:
        # ì˜ˆì™¸ ë°œìƒ ì‹œ ì•ˆì „í•œ í´ë°± (RULE-004)
        ctx.output = create_safe_fallback(
            language=ctx.turn_input.language,
            economy_snapshot=ctx.economy_snapshot,
            repair_count=ctx.repair_attempts,
        )
        ctx.is_fallback = True

    return ctx
</file>

<file path="backend/src/unknown_world/orchestrator/stages/verify.py">
"""Unknown World - Verify Stage.

ê²€ì¦ ë‹¨ê³„ì…ë‹ˆë‹¤.
U-090: ë¹„ì •ë°€ë¶„ì„ í„´ í•«ìŠ¤íŒŸ ìƒì„± ê¸ˆì§€ ë¹„ì¦ˆë‹ˆìŠ¤ ë£° ê²€ì¦ì´ ì¶”ê°€ë˜ì—ˆìŠµë‹ˆë‹¤.

ì„¤ê³„ ì›ì¹™:
    - RULE-008: ë‹¨ê³„ ì´ë²¤íŠ¸ ì¼ê´€ì„±
    - ë™ì‘ ë³´ì¡´: ê¸°ì¡´ ì‹œë®¬ë ˆì´ì…˜ ì§€ì—° ìœ ì§€
    - U-090: í•«ìŠ¤íŒŸì€ ì •ë°€ë¶„ì„ ì „ìš© (ì´ì¤‘ ì•ˆì „ì¥ì¹˜)

ì°¸ì¡°:
    - vibe/refactors/RU-005-Q4.md
    - vibe/unit-plans/U-090[Mvp].md
"""

from __future__ import annotations

import asyncio
import logging

from unknown_world.config.models import TextModelTiering
from unknown_world.models.turn import AgentPhase
from unknown_world.orchestrator.stages.types import (
    EmitFn,
    PipelineContext,
    PipelineEvent,
    PipelineEventType,
)

logger = logging.getLogger(__name__)

# ëª¨ì˜ ì²˜ë¦¬ ì§€ì—° ì‹œê°„ (ms)
VERIFY_DELAY_MS = 40


async def verify_stage(ctx: PipelineContext, *, emit: EmitFn) -> PipelineContext:
    """Verify ë‹¨ê³„ë¥¼ ì‹¤í–‰í•©ë‹ˆë‹¤.

    U-090: ë¹„ì •ë°€ë¶„ì„ í„´ì—ì„œ í•«ìŠ¤íŒŸì´ ë‚¨ì•„ìˆìœ¼ë©´ ê°•ì œ ì œê±° (ì´ì¤‘ ì•ˆì „ì¥ì¹˜).
    resolve stageì—ì„œ ì´ë¯¸ í•„í„°ë§í•˜ì§€ë§Œ, ë§Œì•½ ëˆ„ë½ëœ ê²½ìš°ë¥¼ ëŒ€ë¹„í•©ë‹ˆë‹¤.

    Args:
        ctx: íŒŒì´í”„ë¼ì¸ ì»¨í…ìŠ¤íŠ¸
        emit: ì´ë²¤íŠ¸ emit ì½œë°±

    Returns:
        ì—…ë°ì´íŠ¸ëœ ì»¨í…ìŠ¤íŠ¸
    """
    ctx.current_phase = AgentPhase.VERIFY

    # Stage ì‹œì‘ ì´ë²¤íŠ¸
    await emit(
        PipelineEvent(
            event_type=PipelineEventType.STAGE_START,
            phase=AgentPhase.VERIFY,
        )
    )

    # ëª¨ì˜ ì²˜ë¦¬ ì§€ì—° (ê¸°ì¡´ ë™ì‘ ë³´ì¡´)
    await asyncio.sleep(VERIFY_DELAY_MS / 1000.0)

    # U-090: ë¹„ì •ë°€ë¶„ì„ í„´ í•«ìŠ¤íŒŸ ì´ì¤‘ ì•ˆì „ì¥ì¹˜
    # resolve stageì—ì„œ ì´ë¯¸ í•„í„°ë§í•˜ì§€ë§Œ, ë†“ì¹œ ê²½ìš°ë¥¼ ëŒ€ë¹„
    is_vision = TextModelTiering.is_vision_trigger(
        ctx.turn_input.action_id,
        ctx.turn_input.text,
    )
    if not is_vision and ctx.output is not None and ctx.output.ui.objects:
        leaked_count = len(ctx.output.ui.objects)
        logger.error(
            "[Verify] U-090: ë¹„ì •ë°€ë¶„ì„ í„´ì—ì„œ í•«ìŠ¤íŒŸ %dê°œ ëˆ„ì¶œ ê°ì§€, ê°•ì œ ì œê±°",
            leaked_count,
        )
        new_ui = ctx.output.ui.model_copy(update={"objects": []})
        ctx.output = ctx.output.model_copy(update={"ui": new_ui})

    # Stage ì™„ë£Œ ì´ë²¤íŠ¸
    await emit(
        PipelineEvent(
            event_type=PipelineEventType.STAGE_COMPLETE,
            phase=AgentPhase.VERIFY,
        )
    )

    return ctx
</file>

<file path="backend/src/unknown_world/services/agentic_vision.py">
"""Unknown World - Agentic Vision ì„œë¹„ìŠ¤ (U-076[Mvp]).

"ì •ë°€ë¶„ì„" ì•¡ì…˜ ì‹¤í–‰ ì‹œ ê¸°ì¡´ Scene ì´ë¯¸ì§€ì—ì„œ affordances(ì˜¤ë¸Œì íŠ¸ í›„ë³´)ë¥¼
ì¶”ì¶œí•˜ëŠ” ì„œë¹„ìŠ¤ì…ë‹ˆë‹¤.

gemini-3-flash-preview + code_execution ë„êµ¬ë¥¼ í™œìš©í•˜ì—¬ ì´ë¯¸ì§€ ë‚´
í´ë¦­ ê°€ëŠ¥í•œ ì˜¤ë¸Œì íŠ¸(í•«ìŠ¤íŒŸ)ë¥¼ êµ¬ì¡°í™”ëœ í˜•ì‹ìœ¼ë¡œ ë°˜í™˜í•©ë‹ˆë‹¤.

ì„¤ê³„ ì›ì¹™:
    - RULE-004: ì‹¤íŒ¨ ì‹œ ë¹ˆ ë°°ì—´ ë°˜í™˜ (ì•ˆì „í•œ í´ë°±)
    - RULE-007/008: í”„ë¡¬í”„íŠ¸ ì›ë¬¸/ë¹„ë°€ì •ë³´ ë…¸ì¶œ ê¸ˆì§€
    - RULE-009: bbox 0~1000 ì •ê·œí™”, [ymin, xmin, ymax, xmax]
    - U-076 Q2: ë¹„ì „ ë¶„ì„ ë¹„ìš© 1.5x

ì°¸ì¡°:
    - vibe/unit-plans/U-076[Mvp].md
    - vibe/tech-stack.md (ë¹„ì „ ëª¨ë¸: gemini-3-flash-preview)
    - vibe/ref/gemini-api-guide.md (Structured Outputs with tools)
"""

from __future__ import annotations

import json
import logging
import os
import time
from dataclasses import dataclass, field
from pathlib import Path
from typing import TYPE_CHECKING, Any, cast

from unknown_world.config.models import ModelLabel, get_model_id
from unknown_world.models.turn import Box2D, Language, SceneObject
from unknown_world.services.genai_client import ENV_UW_MODE, GenAIMode
from unknown_world.storage.validation import BBOX_MAX, BBOX_MIN

if TYPE_CHECKING:
    from google.genai import Client

# =============================================================================
# ë¡œê±° ì„¤ì • (í”„ë¡¬í”„íŠ¸/ë¹„ë°€ì •ë³´ ë…¸ì¶œ ê¸ˆì§€ - RULE-007/008)
# =============================================================================

logger = logging.getLogger(__name__)

# =============================================================================
# í”„ë¡¬í”„íŠ¸ ë¡œë”©
# =============================================================================

# í”„ë¡¬í”„íŠ¸ íŒŒì¼ ë””ë ‰í† ë¦¬
_PROMPTS_DIR = Path(__file__).resolve().parent.parent.parent.parent / "prompts" / "vision"


def _load_prompt(language: Language) -> str:
    """ë¹„ì „ í”„ë¡¬í”„íŠ¸ë¥¼ íŒŒì¼ì—ì„œ ë¡œë“œí•©ë‹ˆë‹¤.

    Args:
        language: ìš”ì²­ ì–¸ì–´

    Returns:
        í”„ë¡¬í”„íŠ¸ í…ìŠ¤íŠ¸

    Raises:
        FileNotFoundError: í”„ë¡¬í”„íŠ¸ íŒŒì¼ì´ ì—†ì„ ë•Œ
    """
    lang_suffix = "ko" if language == Language.KO else "en"
    prompt_path = _PROMPTS_DIR / f"scene_affordances.{lang_suffix}.md"

    if not prompt_path.exists():
        # í´ë°±: í•œêµ­ì–´ í”„ë¡¬í”„íŠ¸ ì‹œë„
        fallback_path = _PROMPTS_DIR / "scene_affordances.ko.md"
        if fallback_path.exists():
            prompt_path = fallback_path
        else:
            raise FileNotFoundError(f"Vision prompt not found: {prompt_path}")

    return prompt_path.read_text(encoding="utf-8")


# =============================================================================
# Affordance ë°ì´í„° íƒ€ì…
# =============================================================================


@dataclass
class Affordance:
    """ì´ë¯¸ì§€ì—ì„œ ì¶”ì¶œëœ ì˜¤ë¸Œì íŠ¸ í›„ë³´ (affordance).

    Attributes:
        label: ì˜¤ë¸Œì íŠ¸ ì´ë¦„ (ì„¸ì…˜ ì–¸ì–´ì— ë§ê²Œ)
        box_2d: ë°”ìš´ë”© ë°•ìŠ¤ (0~1000 ì •ê·œí™”, [ymin, xmin, ymax, xmax])
        interaction_hint: ìƒí˜¸ì‘ìš© íŒíŠ¸ (ì„ íƒ)
    """

    label: str
    box_2d: Box2D
    interaction_hint: str | None = None


@dataclass
class VisionAnalysisResult:
    """ë¹„ì „ ë¶„ì„ ê²°ê³¼.

    Attributes:
        affordances: ì¶”ì¶œëœ affordances ëª©ë¡
        analysis_time_ms: ë¶„ì„ ì†Œìš” ì‹œê°„ (ë°€ë¦¬ì´ˆ)
        success: ë¶„ì„ ì„±ê³µ ì—¬ë¶€
        message: ìƒíƒœ/ì—ëŸ¬ ë©”ì‹œì§€ (ë‚´ë¶€ìš©, UI ë…¸ì¶œ ê¸ˆì§€)
    """

    affordances: list[Affordance] = field(default_factory=lambda: cast(list["Affordance"], []))
    analysis_time_ms: int = 0
    success: bool = True
    message: str = ""


# =============================================================================
# bbox ì •ê·œí™” ìœ í‹¸ë¦¬í‹°
# =============================================================================


def _normalize_bbox(bbox_raw: dict[str, Any]) -> Box2D | None:
    """bboxë¥¼ 0~1000 ë²”ìœ„ë¡œ ì •ê·œí™”í•©ë‹ˆë‹¤.

    Args:
        bbox_raw: ì›ë³¸ bbox dict

    Returns:
        ì •ê·œí™”ëœ Box2D ë˜ëŠ” None (ìœ íš¨í•˜ì§€ ì•Šì€ ê²½ìš°)
    """
    try:
        ymin_val = int(bbox_raw.get("ymin", 0) or 0)
        xmin_val = int(bbox_raw.get("xmin", 0) or 0)
        ymax_val = int(bbox_raw.get("ymax", BBOX_MAX) or BBOX_MAX)
        xmax_val = int(bbox_raw.get("xmax", BBOX_MAX) or BBOX_MAX)

        # ë²”ìœ„ í´ë¨í•‘ (RULE-009)
        ymin_val = max(BBOX_MIN, min(BBOX_MAX, ymin_val))
        xmin_val = max(BBOX_MIN, min(BBOX_MAX, xmin_val))
        ymax_val = max(BBOX_MIN, min(BBOX_MAX, ymax_val))
        xmax_val = max(BBOX_MIN, min(BBOX_MAX, xmax_val))

        # ymin < ymax, xmin < xmax ë³´ì¥
        if ymin_val >= ymax_val:
            ymax_val = min(ymin_val + 100, BBOX_MAX)
        if xmin_val >= xmax_val:
            xmax_val = min(xmin_val + 100, BBOX_MAX)

        return Box2D(ymin=ymin_val, xmin=xmin_val, ymax=ymax_val, xmax=xmax_val)
    except (ValueError, TypeError):
        return None


# =============================================================================
# Mock ì„œë¹„ìŠ¤
# =============================================================================


def _create_mock_result(language: Language) -> VisionAnalysisResult:
    """Mock ë¶„ì„ ê²°ê³¼ë¥¼ ìƒì„±í•©ë‹ˆë‹¤.

    Args:
        language: ì‘ë‹µ ì–¸ì–´

    Returns:
        ê³ ì •ëœ Mock ë¶„ì„ ê²°ê³¼
    """
    if language == Language.KO:
        affordances = [
            Affordance(
                label="ë‚¡ì€ ë¬¸",
                box_2d=Box2D(ymin=100, xmin=50, ymax=800, xmax=450),
                interaction_hint="ì—´ì–´ë³¼ ìˆ˜ ìˆì„ ê²ƒ ê°™ë‹¤",
            ),
            Affordance(
                label="ë²½ì— ê±¸ë¦° íšƒë¶ˆ",
                box_2d=Box2D(ymin=50, xmin=600, ymax=400, xmax=750),
                interaction_hint="ê°€ì ¸ê°ˆ ìˆ˜ ìˆì„ ê²ƒ ê°™ë‹¤",
            ),
            Affordance(
                label="ë°”ë‹¥ì˜ ê¸ˆì´ ê°„ íƒ€ì¼",
                box_2d=Box2D(ymin=700, xmin=200, ymax=900, xmax=600),
                interaction_hint="ë¬´ì–¸ê°€ ìˆ¨ê²¨ì ¸ ìˆì„ ìˆ˜ ìˆë‹¤",
            ),
        ]
    else:
        affordances = [
            Affordance(
                label="Old Door",
                box_2d=Box2D(ymin=100, xmin=50, ymax=800, xmax=450),
                interaction_hint="Looks like it can be opened",
            ),
            Affordance(
                label="Wall Torch",
                box_2d=Box2D(ymin=50, xmin=600, ymax=400, xmax=750),
                interaction_hint="Could be taken",
            ),
            Affordance(
                label="Cracked Floor Tile",
                box_2d=Box2D(ymin=700, xmin=200, ymax=900, xmax=600),
                interaction_hint="Something might be hidden underneath",
            ),
        ]

    return VisionAnalysisResult(
        affordances=affordances,
        analysis_time_ms=250,
        success=True,
        message="mock",
    )


# =============================================================================
# ì‘ë‹µ íŒŒì‹±
# =============================================================================


def _parse_vision_response(
    response_text: str,
    language: Language,
) -> VisionAnalysisResult:
    """ë¹„ì „ ëª¨ë¸ ì‘ë‹µì„ íŒŒì‹±í•©ë‹ˆë‹¤.

    Args:
        response_text: ëª¨ë¸ ì‘ë‹µ í…ìŠ¤íŠ¸ (JSON ì˜ˆìƒ)
        language: ì‘ë‹µ ì–¸ì–´

    Returns:
        íŒŒì‹±ëœ VisionAnalysisResult
    """
    try:
        # ë§ˆí¬ë‹¤ìš´ ì½”ë“œë¸”ë¡ ì œê±°
        text = response_text.strip()
        if text.startswith("```"):
            lines = text.split("\n")
            if lines[0].startswith("```"):
                lines = lines[1:]
            if lines and lines[-1].strip() == "```":
                lines = lines[:-1]
            text = "\n".join(lines)

        parsed = json.loads(text)

        # ì´ì¤‘ ì§ë ¬í™” ì²˜ë¦¬
        if isinstance(parsed, str):
            parsed = json.loads(parsed)

        if not isinstance(parsed, dict):
            raise ValueError(f"Expected dict, got {type(parsed).__name__}")

        data = cast(dict[str, Any], parsed)

        # affordances ì¶”ì¶œ
        affordances: list[Affordance] = []
        raw_affordances: list[dict[str, Any]] = data.get("affordances") or []  # type: ignore[assignment]

        for i, aff in enumerate(raw_affordances[:5]):  # ìµœëŒ€ 5ê°œ (SceneObject max_length)
            if not isinstance(aff, dict):  # type: ignore[reportUnnecessaryIsInstance]
                continue

            label_val = aff.get("label")
            label: str = str(label_val) if label_val else f"Object_{i}"

            bbox_raw: dict[str, Any] = aff.get("box_2d") or {}  # type: ignore[assignment]
            bbox = _normalize_bbox(bbox_raw)
            if bbox is None:
                logger.warning(
                    "[AgenticVision] bbox ì •ê·œí™” ì‹¤íŒ¨, ì˜¤ë¸Œì íŠ¸ ìŠ¤í‚µ",
                    extra={"index": i, "label": label},
                )
                continue

            hint_val = aff.get("interaction_hint")
            hint: str | None = str(hint_val) if hint_val else None

            affordances.append(
                Affordance(
                    label=label,
                    box_2d=bbox,
                    interaction_hint=hint,
                )
            )

        return VisionAnalysisResult(
            affordances=affordances,
            success=True,
            message="ok",
        )

    except (json.JSONDecodeError, ValueError) as e:
        logger.warning(
            "[AgenticVision] JSON íŒŒì‹± ì‹¤íŒ¨",
            extra={"error": str(e), "error_type": type(e).__name__},
        )
        return VisionAnalysisResult(
            affordances=[],
            success=False,
            message=f"parse_error: {type(e).__name__}",
        )
    except Exception as e:
        logger.error(
            "[AgenticVision] ì‘ë‹µ íŒŒì‹± ì¤‘ ì˜ˆì™¸",
            extra={"error_type": type(e).__name__},
        )
        return VisionAnalysisResult(
            affordances=[],
            success=False,
            message=f"unexpected_error: {type(e).__name__}",
        )


# =============================================================================
# Affordance â†’ SceneObject ë³€í™˜
# =============================================================================


def affordances_to_scene_objects(
    affordances: list[Affordance],
    id_prefix: str = "vision",
) -> list[SceneObject]:
    """Affordancesë¥¼ SceneObject ëª©ë¡ìœ¼ë¡œ ë³€í™˜í•©ë‹ˆë‹¤.

    Args:
        affordances: ì¶”ì¶œëœ affordances
        id_prefix: ì˜¤ë¸Œì íŠ¸ ID ì ‘ë‘ì‚¬

    Returns:
        SceneObject ëª©ë¡
    """
    objects: list[SceneObject] = []
    for i, aff in enumerate(affordances):
        obj = SceneObject(
            id=f"{id_prefix}_{i}",
            label=aff.label,
            box_2d=aff.box_2d,
            interaction_hint=aff.interaction_hint,
        )
        objects.append(obj)
    return objects


# =============================================================================
# Agentic Vision ì„œë¹„ìŠ¤
# =============================================================================


class AgenticVisionService:
    """Agentic Vision ì„œë¹„ìŠ¤ (U-076[Mvp]).

    Scene ì´ë¯¸ì§€ì—ì„œ affordances(ì˜¤ë¸Œì íŠ¸ í›„ë³´)ë¥¼ ì¶”ì¶œí•˜ëŠ”
    gemini-3-flash-preview + code_execution ê¸°ë°˜ ì„œë¹„ìŠ¤ì…ë‹ˆë‹¤.
    """

    def __init__(
        self,
        *,
        force_mock: bool = False,
    ) -> None:
        """AgenticVisionServiceë¥¼ ì´ˆê¸°í™”í•©ë‹ˆë‹¤.

        Args:
            force_mock: Trueë©´ Mock ëª¨ë“œ ê°•ì œ
        """
        if force_mock:
            self._is_mock = True
        else:
            mode_str = os.environ.get(ENV_UW_MODE, GenAIMode.REAL)
            self._is_mock = mode_str == GenAIMode.MOCK

        self._genai_client: Client | None = None

        if not self._is_mock:
            self._initialize_client()

        logger.info(
            "[AgenticVision] ì„œë¹„ìŠ¤ ì´ˆê¸°í™”",
            extra={"mode": "mock" if self._is_mock else "real"},
        )

    def _initialize_client(self) -> None:
        """google-genai í´ë¼ì´ì–¸íŠ¸ë¥¼ ì´ˆê¸°í™”í•©ë‹ˆë‹¤."""
        try:
            from google.genai import Client

            api_key = os.environ.get("GOOGLE_API_KEY")
            if not api_key:
                logger.warning(
                    "[AgenticVision] GOOGLE_API_KEY ë¯¸ì„¤ì • - Mock ëª¨ë“œë¡œ ì „í™˜",
                )
                self._is_mock = True
                self._genai_client = None
                return

            self._genai_client = Client(api_key=api_key)
            self._is_mock = False

            logger.info(
                "[AgenticVision] API í‚¤ í´ë¼ì´ì–¸íŠ¸ ì´ˆê¸°í™” ì™„ë£Œ",
                extra={"auth": "api_key"},
            )
        except Exception as e:
            logger.warning(
                "[AgenticVision] í´ë¼ì´ì–¸íŠ¸ ì´ˆê¸°í™” ì‹¤íŒ¨ - Mock ëª¨ë“œë¡œ ì „í™˜",
                extra={"error_type": type(e).__name__},
            )
            self._is_mock = True
            self._genai_client = None

    @property
    def is_mock(self) -> bool:
        """Mock ëª¨ë“œ ì—¬ë¶€."""
        return self._is_mock

    async def analyze_scene(
        self,
        image_url: str,
        language: Language = Language.KO,
    ) -> VisionAnalysisResult:
        """Scene ì´ë¯¸ì§€ì—ì„œ affordances(ì˜¤ë¸Œì íŠ¸ í›„ë³´)ë¥¼ ì¶”ì¶œí•©ë‹ˆë‹¤.

        Args:
            image_url: Scene ì´ë¯¸ì§€ URL (ë¡œì»¬ ê²½ë¡œ ë˜ëŠ” HTTP URL)
            language: ì„¸ì…˜ ì–¸ì–´

        Returns:
            VisionAnalysisResult: ë¶„ì„ ê²°ê³¼
        """
        start_time = time.time()

        logger.info(
            "[AgenticVision] ë¶„ì„ ì‹œì‘",
            extra={
                "language": language.value,
                "has_image_url": bool(image_url),
            },
        )

        # Mock ëª¨ë“œ
        if self._is_mock:
            logger.debug("[AgenticVision] Mock ë¶„ì„ ìˆ˜í–‰")
            result = _create_mock_result(language)
            result.analysis_time_ms = int((time.time() - start_time) * 1000)
            return result

        # ì´ë¯¸ì§€ ì½ê¸°
        image_bytes = self._load_image(image_url)
        if image_bytes is None:
            logger.warning(
                "[AgenticVision] ì´ë¯¸ì§€ ë¡œë“œ ì‹¤íŒ¨, ë¹ˆ ê²°ê³¼ ë°˜í™˜",
                extra={"image_url_prefix": image_url[:50] if image_url else ""},
            )
            return VisionAnalysisResult(
                affordances=[],
                analysis_time_ms=int((time.time() - start_time) * 1000),
                success=False,
                message="image_load_failed",
            )

        # ì‹¤ì œ ë¹„ì „ ëª¨ë¸ í˜¸ì¶œ
        try:
            result = await self._call_vision_model(image_bytes, language)
            result.analysis_time_ms = int((time.time() - start_time) * 1000)

            logger.info(
                "[AgenticVision] ë¶„ì„ ì™„ë£Œ",
                extra={
                    "affordance_count": len(result.affordances),
                    "analysis_time_ms": result.analysis_time_ms,
                    "success": result.success,
                },
            )

            return result

        except Exception as e:
            error_type = type(e).__name__
            logger.error(
                "[AgenticVision] ë¹„ì „ ëª¨ë¸ í˜¸ì¶œ ì‹¤íŒ¨",
                extra={"error_type": error_type},
            )
            return VisionAnalysisResult(
                affordances=[],
                analysis_time_ms=int((time.time() - start_time) * 1000),
                success=False,
                message=f"vision_error: {error_type}",
            )

    def _load_image(self, image_url: str) -> bytes | None:
        """ì´ë¯¸ì§€ URLì—ì„œ ë°”ì´íŠ¸ ë°ì´í„°ë¥¼ ë¡œë“œí•©ë‹ˆë‹¤.

        ë¡œì»¬ ê²½ë¡œì™€ HTTP URL ëª¨ë‘ ì§€ì›í•©ë‹ˆë‹¤.

        Args:
            image_url: ì´ë¯¸ì§€ ê²½ë¡œ/URL

        Returns:
            ì´ë¯¸ì§€ ë°”ì´íŠ¸ ë°ì´í„° ë˜ëŠ” None
        """
        try:
            # ë¡œì»¬ íŒŒì¼ ê²½ë¡œ ì²˜ë¦¬
            if image_url.startswith("/static/"):
                # /static/ prefix ì œê±° â†’ .data/ ë‚´ë¶€ ìƒëŒ€ê²½ë¡œ
                # ì˜ˆ: /static/images/generated/img_xxx.png â†’ images/generated/img_xxx.png
                relative_path = image_url[len("/static/") :]

                # backend ë£¨íŠ¸ ë””ë ‰í† ë¦¬
                base_dir = Path(__file__).resolve().parent.parent.parent.parent

                # 1) .data/ ë””ë ‰í† ë¦¬ì—ì„œ ì°¾ê¸° (í˜„ì¬ ìŠ¤í† ë¦¬ì§€)
                from unknown_world.storage.paths import BASE_DATA_DIR

                data_path = base_dir / str(BASE_DATA_DIR) / relative_path
                if data_path.exists():
                    return data_path.read_bytes()

                # 2) ë ˆê±°ì‹œ: generated_images/ í´ë°±
                filename = Path(image_url).name
                legacy_dir = base_dir / "generated_images"
                if legacy_dir.exists():
                    candidate = legacy_dir / filename
                    if candidate.exists():
                        return candidate.read_bytes()

                logger.warning(
                    "[AgenticVision] ë¡œì»¬ ì´ë¯¸ì§€ íŒŒì¼ ë¯¸ì¡´ì¬",
                    extra={"path_prefix": str(data_path)[:80]},
                )
                return None

            elif image_url.startswith(("http://", "https://")):
                # HTTP URLì˜ ê²½ìš° - MVPì—ì„œëŠ” ë¡œì»¬ íŒŒì¼ë§Œ ì§€ì›
                # ì›ê²© URLì€ MMPì—ì„œ êµ¬í˜„ ì˜ˆì •
                logger.warning(
                    "[AgenticVision] HTTP URLì€ í˜„ì¬ ë¯¸ì§€ì›",
                )
                return None
            else:
                # ì ˆëŒ€/ìƒëŒ€ ê²½ë¡œ ì‹œë„
                path = Path(image_url)
                if path.exists():
                    return path.read_bytes()
                return None
        except Exception as e:
            logger.warning(
                "[AgenticVision] ì´ë¯¸ì§€ ë¡œë“œ ì‹¤íŒ¨",
                extra={"error_type": type(e).__name__},
            )
            return None

    async def _call_vision_model(
        self,
        image_bytes: bytes,
        language: Language,
    ) -> VisionAnalysisResult:
        """ë¹„ì „ ëª¨ë¸ì„ í˜¸ì¶œí•©ë‹ˆë‹¤.

        gemini-3-flash-preview + code_execution í™œì„±í™”

        Args:
            image_bytes: ì´ë¯¸ì§€ ë°”ì´íŠ¸ ë°ì´í„°
            language: ì„¸ì…˜ ì–¸ì–´

        Returns:
            VisionAnalysisResult
        """
        if self._genai_client is None:
            return VisionAnalysisResult(
                affordances=[],
                success=False,
                message="client_not_initialized",
            )

        # í”„ë¡¬í”„íŠ¸ ë¡œë“œ
        try:
            prompt_text = _load_prompt(language)
        except FileNotFoundError:
            logger.warning("[AgenticVision] í”„ë¡¬í”„íŠ¸ íŒŒì¼ ë¯¸ì¡´ì¬, ì¸ë¼ì¸ í´ë°± ì‚¬ìš©")
            prompt_text = self._get_inline_prompt(language)

        # ëª¨ë¸ ID ì¡°íšŒ
        model_id = get_model_id(ModelLabel.VISION)

        logger.debug(
            "[AgenticVision] ë¹„ì „ ëª¨ë¸ í˜¸ì¶œ",
            extra={
                "model_id": model_id,
                "language": language.value,
                "image_size_kb": len(image_bytes) // 1024,
            },
        )

        # google-genai SDK í˜¸ì¶œ
        from google.genai.types import GenerateContentConfig, Part, Tool, ToolCodeExecution

        # ë©€í‹°ëª¨ë‹¬ ì…ë ¥ (ì´ë¯¸ì§€ + í…ìŠ¤íŠ¸)
        contents = [
            Part.from_bytes(
                data=image_bytes,
                mime_type="image/png",
            ),
            Part.from_text(text=prompt_text),
        ]

        # Structured Outputs + code_execution (Gemini 3 ì§€ì›)
        config = GenerateContentConfig(
            response_mime_type="application/json",
            max_output_tokens=4096,
            tools=[Tool(code_execution=ToolCodeExecution())],
        )

        response = await self._genai_client.aio.models.generate_content(  # type: ignore[reportUnknownMemberType]
            model=model_id,
            contents=contents,  # type: ignore[reportArgumentType]
            config=config,
        )

        # ì‘ë‹µ í…ìŠ¤íŠ¸ ì¶”ì¶œ
        response_text: str = ""
        if hasattr(response, "text") and response.text:
            response_text = str(response.text)
        else:
            response_text = str(response)

        if not response_text:
            return VisionAnalysisResult(
                affordances=[],
                success=False,
                message="empty_response",
            )

        return _parse_vision_response(response_text, language)

    def _get_inline_prompt(self, language: Language) -> str:
        """ì¸ë¼ì¸ í´ë°± í”„ë¡¬í”„íŠ¸ë¥¼ ë°˜í™˜í•©ë‹ˆë‹¤.

        í”„ë¡¬í”„íŠ¸ íŒŒì¼ì´ ì—†ì„ ë•Œ ì‚¬ìš©í•˜ëŠ” ìµœì†Œ í”„ë¡¬í”„íŠ¸ì…ë‹ˆë‹¤.

        Args:
            language: ì„¸ì…˜ ì–¸ì–´

        Returns:
            í”„ë¡¬í”„íŠ¸ í…ìŠ¤íŠ¸
        """
        if language == Language.KO:
            return (
                "ì´ ì´ë¯¸ì§€ì—ì„œ í´ë¦­ ê°€ëŠ¥í•œ ì˜¤ë¸Œì íŠ¸ë¥¼ ì°¾ì•„ JSONìœ¼ë¡œ ë°˜í™˜í•˜ì„¸ìš”.\n"
                'ì¶œë ¥: {"affordances": [{"label": "ì´ë¦„", "box_2d": {"ymin": 0, "xmin": 0, "ymax": 1000, "xmax": 1000}, "interaction_hint": "íŒíŠ¸"}]}\n'
                "ì¢Œí‘œëŠ” 0~1000 ì •ê·œí™”, bbox=[ymin,xmin,ymax,xmax]. ìµœëŒ€ 5ê°œ."
            )
        return (
            "Find clickable objects in this image and return as JSON.\n"
            'Output: {"affordances": [{"label": "name", "box_2d": {"ymin": 0, "xmin": 0, "ymax": 1000, "xmax": 1000}, "interaction_hint": "hint"}]}\n'
            "Coordinates: 0~1000 normalized, bbox=[ymin,xmin,ymax,xmax]. Max 5."
        )


# =============================================================================
# íŒ©í† ë¦¬ í•¨ìˆ˜
# =============================================================================

_service_instance: AgenticVisionService | None = None


def get_agentic_vision_service(
    *,
    force_new: bool = False,
) -> AgenticVisionService:
    """AgenticVisionService ì¸ìŠ¤í„´ìŠ¤ë¥¼ ë°˜í™˜í•©ë‹ˆë‹¤.

    ì‹±ê¸€í†¤ íŒ¨í„´ìœ¼ë¡œ ë™ì‘í•©ë‹ˆë‹¤.

    Args:
        force_new: Trueë©´ ìºì‹œë¥¼ ë¬´ì‹œí•˜ê³  ìƒˆ ì¸ìŠ¤í„´ìŠ¤ ìƒì„±

    Returns:
        AgenticVisionService ì¸ìŠ¤í„´ìŠ¤
    """
    global _service_instance

    if not force_new and _service_instance is not None:
        return _service_instance

    _service_instance = AgenticVisionService()
    return _service_instance


def reset_agentic_vision_service() -> None:
    """AgenticVisionService ìºì‹œë¥¼ ì´ˆê¸°í™”í•©ë‹ˆë‹¤."""
    global _service_instance
    _service_instance = None
</file>

<file path="backend/src/unknown_world/storage/local_storage.py">
"""Unknown World - ë¡œì»¬ íŒŒì¼ ì‹œìŠ¤í…œ ìŠ¤í† ë¦¬ì§€ êµ¬í˜„.

MVP ë‹¨ê³„ì—ì„œ ì‚¬ìš©í•˜ëŠ” ë¡œì»¬ ì €ì¥ì†Œ êµ¬í˜„ì²´.
í˜ì–´ë§ ì§ˆë¬¸ Q1: Option A (backend/.data/ ì „ìš© í´ë”)

ì°¸ì¡°:
    - vibe/refactors/RU-006-Q4.md
    - vibe/refactors/RU-006-Q5.md
"""

from __future__ import annotations

import logging
import uuid
from datetime import UTC, datetime
from pathlib import Path

from unknown_world.storage.paths import (
    ARTIFACTS_SUBDIR,
    BASE_DATA_DIR,
    IMAGES_GENERATED_SUBDIR,
    IMAGES_UPLOADED_SUBDIR,
    STATIC_URL_PREFIX,
)
from unknown_world.storage.storage import (
    PutResult,
    StorageCategory,
    StorageInterface,
    StorageMetadata,
)

logger = logging.getLogger(__name__)

# ì¹´í…Œê³ ë¦¬ë³„ ì„œë¸Œë””ë ‰í† ë¦¬ ë§¤í•‘ (RU-006-Q5: paths.py ìƒìˆ˜ ì°¸ì¡°)
CATEGORY_DIRS: dict[StorageCategory, str] = {
    StorageCategory.GENERATED_IMAGE: IMAGES_GENERATED_SUBDIR,
    StorageCategory.UPLOADED_IMAGE: IMAGES_UPLOADED_SUBDIR,
    StorageCategory.ARTIFACT: ARTIFACTS_SUBDIR,
}


class LocalStorage(StorageInterface):
    """ë¡œì»¬ íŒŒì¼ ì‹œìŠ¤í…œ ìŠ¤í† ë¦¬ì§€.

    MVPì—ì„œ ì‚¬ìš©í•˜ëŠ” ë¡œì»¬ ì €ì¥ì†Œ êµ¬í˜„ì²´.
    """

    def __init__(self, base_dir: Path | None = None) -> None:
        """LocalStorageë¥¼ ì´ˆê¸°í™”í•©ë‹ˆë‹¤.

        Args:
            base_dir: ê¸°ë³¸ ì €ì¥ ë””ë ‰í† ë¦¬ (ê¸°ë³¸ê°’: .data)
        """
        self._base_dir = base_dir or BASE_DATA_DIR
        self._ensure_directories()

        logger.info(
            "[LocalStorage] ì´ˆê¸°í™” ì™„ë£Œ",
            extra={"base_dir": str(self._base_dir)},
        )

    def _ensure_directories(self) -> None:
        """ì¹´í…Œê³ ë¦¬ë³„ ë””ë ‰í† ë¦¬ë¥¼ ìƒì„±í•©ë‹ˆë‹¤."""
        for subdir in CATEGORY_DIRS.values():
            dir_path = self._base_dir / subdir
            dir_path.mkdir(parents=True, exist_ok=True)

    def _get_category_dir(self, category: StorageCategory) -> Path:
        """ì¹´í…Œê³ ë¦¬ì— í•´ë‹¹í•˜ëŠ” ë””ë ‰í† ë¦¬ ê²½ë¡œë¥¼ ë°˜í™˜í•©ë‹ˆë‹¤."""
        subdir = CATEGORY_DIRS.get(category, "misc")
        return self._base_dir / subdir

    def _generate_key(
        self,
        category: StorageCategory,
        file_id: str | None,
        extension: str = "png",
    ) -> str:
        """ìŠ¤í† ë¦¬ì§€ í‚¤ë¥¼ ìƒì„±í•©ë‹ˆë‹¤."""
        actual_id = file_id or f"file_{uuid.uuid4().hex[:12]}"
        subdir = CATEGORY_DIRS.get(category, "misc")
        return f"{subdir}/{actual_id}.{extension}"

    async def put(
        self,
        data: bytes,
        *,
        category: StorageCategory,
        content_type: str = "image/png",
        file_id: str | None = None,
        session_id: str | None = None,
    ) -> PutResult:
        """íŒŒì¼ì„ ì €ì¥í•©ë‹ˆë‹¤."""
        try:
            # í™•ì¥ì ì¶”ì¶œ
            ext_map = {
                "image/png": "png",
                "image/jpeg": "jpg",
                "image/gif": "gif",
                "image/webp": "webp",
                "application/json": "json",
            }
            extension = ext_map.get(content_type, "bin")

            # í‚¤ ë° ê²½ë¡œ ìƒì„±
            key = self._generate_key(category, file_id, extension)
            file_path = self._base_dir / key
            file_path.parent.mkdir(parents=True, exist_ok=True)

            # íŒŒì¼ ì €ì¥
            file_path.write_bytes(data)

            # URL ìƒì„±
            url = self.get_url(key)

            # ë©”íƒ€ë°ì´í„° ìƒì„±
            metadata = StorageMetadata(
                key=key,
                category=category,
                size_bytes=len(data),
                content_type=content_type,
                created_at=datetime.now(UTC),
                url=url,
                session_id=session_id,
            )

            logger.debug(
                "[LocalStorage] íŒŒì¼ ì €ì¥ ì™„ë£Œ",
                extra={
                    "key": key,
                    "size_bytes": len(data),
                    "category": category.value,
                },
            )

            return PutResult(
                success=True,
                key=key,
                url=url,
                metadata=metadata,
            )

        except Exception as e:
            error_msg = f"íŒŒì¼ ì €ì¥ ì‹¤íŒ¨: {type(e).__name__}"
            logger.error(
                "[LocalStorage] ì €ì¥ ì‹¤íŒ¨",
                extra={"error_type": type(e).__name__},
            )
            return PutResult(
                success=False,
                key="",
                url="",
                error=error_msg,
            )

    async def get(self, key: str) -> bytes | None:
        """íŒŒì¼ì„ ì¡°íšŒí•©ë‹ˆë‹¤."""
        file_path = self._base_dir / key
        if not file_path.exists():
            return None
        return file_path.read_bytes()

    async def exists(self, key: str) -> bool:
        """íŒŒì¼ ì¡´ì¬ ì—¬ë¶€ë¥¼ í™•ì¸í•©ë‹ˆë‹¤."""
        file_path = self._base_dir / key
        return file_path.exists()

    async def delete(self, key: str) -> bool:
        """íŒŒì¼ì„ ì‚­ì œí•©ë‹ˆë‹¤."""
        file_path = self._base_dir / key
        if not file_path.exists():
            return False
        file_path.unlink()
        return True

    def get_url(self, key: str) -> str:
        """íŒŒì¼ ì ‘ê·¼ URLì„ ë°˜í™˜í•©ë‹ˆë‹¤."""
        # ë¡œì»¬ í™˜ê²½ì—ì„œëŠ” /static í”„ë¦¬í”½ìŠ¤ë¡œ ì„œë¹™
        return f"{STATIC_URL_PREFIX}/{key}"

    @property
    def base_dir(self) -> Path:
        """ê¸°ë³¸ ì €ì¥ ë””ë ‰í† ë¦¬."""
        return self._base_dir
</file>

<file path="backend/src/unknown_world/storage/validation.py">
"""Unknown World - íŒŒì¼ ê²€ì¦ ë° ì œí•œ ì •ì±….

ëª¨ë“  ì´ë¯¸ì§€/ì•„í‹°íŒ©íŠ¸ ê´€ë ¨ ê²€ì¦ ë¡œì§ê³¼ ìƒìˆ˜ë¥¼ ì¤‘ì•™ ê´€ë¦¬í•©ë‹ˆë‹¤.

ì„¤ê³„ ì›ì¹™:
    - RULE-007: ì—ëŸ¬ ë©”ì‹œì§€ì— íŒŒì¼ ë‚´ìš© ë…¸ì¶œ ê¸ˆì§€
    - RULE-004: ê²€ì¦ ì‹¤íŒ¨ ì‹œ ëª…í™•í•œ ì—ëŸ¬ ë©”ì‹œì§€ ë°˜í™˜

ì°¸ì¡°:
    - vibe/refactors/RU-006-Q1.md
"""

from __future__ import annotations

from typing import Final

from unknown_world.models.turn import Language

# =============================================================================
# ì´ë¯¸ì§€ ì—…ë¡œë“œ ì œí•œ (Scanner/Vision ê³µí†µ)
# =============================================================================

ALLOWED_IMAGE_MIME_TYPES: Final[frozenset[str]] = frozenset(
    {
        "image/jpeg",
        "image/jpg",
        "image/png",
        "image/gif",
        "image/webp",
    }
)
"""ì§€ì›í•˜ëŠ” ì´ë¯¸ì§€ MIME íƒ€ì…."""

MAX_IMAGE_FILE_SIZE_BYTES: Final[int] = 20 * 1024 * 1024  # 20MB
"""ìµœëŒ€ ì´ë¯¸ì§€ íŒŒì¼ í¬ê¸° (ë°”ì´íŠ¸)."""

MIN_IMAGE_FILE_SIZE_BYTES: Final[int] = 100
"""ìµœì†Œ ì´ë¯¸ì§€ íŒŒì¼ í¬ê¸° (ì†ìƒ íŒŒì¼ ê°ì§€ìš©)."""

# =============================================================================
# ì´ë¯¸ì§€ ìƒì„± ì œí•œ
# =============================================================================

SUPPORTED_IMAGE_SIZES: Final[dict[str, tuple[int, int]]] = {
    "1024x1024": (1024, 1024),
    "1280x768": (1280, 768),
    "768x1280": (768, 1280),
    "1536x1024": (1536, 1024),
    "1024x1536": (1024, 1536),
}
"""ì§€ì›í•˜ëŠ” ì´ë¯¸ì§€ ìƒì„± í¬ê¸°."""

DEFAULT_IMAGE_SIZE: Final[str] = "1024x1024"
"""ê¸°ë³¸ ì´ë¯¸ì§€ ìƒì„± í¬ê¸°."""

DEFAULT_ASPECT_RATIO: Final[str] = "1:1"
"""ê¸°ë³¸ ê°€ë¡œì„¸ë¡œ ë¹„ìœ¨."""

MIN_PROMPT_LENGTH: Final[int] = 3
"""ìµœì†Œ í”„ë¡¬í”„íŠ¸ ê¸¸ì´."""

MAX_PROMPT_LENGTH: Final[int] = 2000
"""ìµœëŒ€ í”„ë¡¬í”„íŠ¸ ê¸¸ì´."""

# =============================================================================
# bbox ì •ê·œí™” ë²”ìœ„ (RULE-009)
# =============================================================================

BBOX_MIN: Final[int] = 0
"""bbox ìµœì†Œê°’."""

BBOX_MAX: Final[int] = 1000
"""bbox ìµœëŒ€ê°’."""


# =============================================================================
# ê²€ì¦ í•¨ìˆ˜
# =============================================================================


def validate_image_upload(
    content: bytes,
    content_type: str,
    *,
    language: Language = Language.KO,
) -> str | None:
    """ì—…ë¡œë“œ ì´ë¯¸ì§€ë¥¼ ê²€ì¦í•©ë‹ˆë‹¤.

    Args:
        content: ì´ë¯¸ì§€ ë°”ì´íŠ¸ ë°ì´í„°
        content_type: MIME íƒ€ì…
        language: ì—ëŸ¬ ë©”ì‹œì§€ ì–¸ì–´

    Returns:
        ì—ëŸ¬ ë©”ì‹œì§€ (ì—†ìœ¼ë©´ None)
    """
    is_ko = language == Language.KO

    # MIME íƒ€ì… ê²€ì¦
    if content_type.lower() not in ALLOWED_IMAGE_MIME_TYPES:
        return (
            f"ì§€ì›í•˜ì§€ ì•ŠëŠ” ì´ë¯¸ì§€ í˜•ì‹ì…ë‹ˆë‹¤: {content_type}"
            if is_ko
            else f"Unsupported image format: {content_type}"
        )

    # íŒŒì¼ í¬ê¸° ê²€ì¦ (ìµœëŒ€)
    if len(content) > MAX_IMAGE_FILE_SIZE_BYTES:
        size_mb = len(content) / (1024 * 1024)
        return (
            f"íŒŒì¼ì´ ë„ˆë¬´ í½ë‹ˆë‹¤: {size_mb:.1f}MB (ìµœëŒ€ 20MB)"
            if is_ko
            else f"File too large: {size_mb:.1f}MB (max 20MB)"
        )

    # íŒŒì¼ í¬ê¸° ê²€ì¦ (ìµœì†Œ - ì†ìƒ íŒŒì¼ ê°ì§€)
    if len(content) < MIN_IMAGE_FILE_SIZE_BYTES:
        return (
            "ì´ë¯¸ì§€ íŒŒì¼ì´ ì†ìƒë˜ì—ˆê±°ë‚˜ ë¹„ì–´ìˆìŠµë‹ˆë‹¤"
            if is_ko
            else "Image file is corrupted or empty"
        )

    return None


def validate_image_generation_request(
    prompt: str,
    image_size: str,
    *,
    language: Language = Language.KO,
) -> str | None:
    """ì´ë¯¸ì§€ ìƒì„± ìš”ì²­ì„ ê²€ì¦í•©ë‹ˆë‹¤.

    Args:
        prompt: ì´ë¯¸ì§€ ìƒì„± í”„ë¡¬í”„íŠ¸
        image_size: ìš”ì²­ëœ ì´ë¯¸ì§€ í¬ê¸°
        language: ì—ëŸ¬ ë©”ì‹œì§€ ì–¸ì–´

    Returns:
        ì—ëŸ¬ ë©”ì‹œì§€ (ì—†ìœ¼ë©´ None)
    """
    is_ko = language == Language.KO

    # ì´ë¯¸ì§€ í¬ê¸° ê²€ì¦
    if image_size not in SUPPORTED_IMAGE_SIZES:
        return (
            f"ì§€ì›í•˜ì§€ ì•ŠëŠ” ì´ë¯¸ì§€ í¬ê¸°: {image_size}"
            if is_ko
            else f"Unsupported image size: {image_size}"
        )

    # í”„ë¡¬í”„íŠ¸ ê¸¸ì´ ê²€ì¦ (ë„ˆë¬´ ì§§ìŒ)
    if len(prompt) < MIN_PROMPT_LENGTH:
        return "í”„ë¡¬í”„íŠ¸ê°€ ë„ˆë¬´ ì§§ìŠµë‹ˆë‹¤." if is_ko else "Prompt is too short."

    # í”„ë¡¬í”„íŠ¸ ê¸¸ì´ ê²€ì¦ (ë„ˆë¬´ ê¹€)
    if len(prompt) > MAX_PROMPT_LENGTH:
        return (
            f"í”„ë¡¬í”„íŠ¸ê°€ ë„ˆë¬´ ê¹ë‹ˆë‹¤ (ìµœëŒ€ {MAX_PROMPT_LENGTH}ì)."
            if is_ko
            else f"Prompt is too long (max {MAX_PROMPT_LENGTH} chars)."
        )

    return None


def get_max_file_size_mb() -> int:
    """ìµœëŒ€ íŒŒì¼ í¬ê¸°ë¥¼ MB ë‹¨ìœ„ë¡œ ë°˜í™˜í•©ë‹ˆë‹¤."""
    return MAX_IMAGE_FILE_SIZE_BYTES // (1024 * 1024)
</file>

<file path="backend/src/unknown_world/validation/__init__.py">
"""Unknown World - ê²€ì¦ ëª¨ë“ˆ.

ë¹„ì¦ˆë‹ˆìŠ¤ ë£° ê²€ì¦ê¸° ë° ì–¸ì–´ í˜¼í•© ê²€ì¦ ê²Œì´íŠ¸ë¥¼ ì œê³µí•©ë‹ˆë‹¤.
"""

from unknown_world.validation.business_rules import (
    BusinessRuleError,
    BusinessRuleValidationResult,
    validate_business_rules,
)
from unknown_world.validation.language_gate import (
    MIXED_THRESHOLD_RATIO,
    LanguageGateResult,
    LanguageRatio,
    build_language_error_summary,
    is_language_mixed,
    measure_language_ratio,
    validate_language_consistency,
)

__all__ = [
    # Business Rules
    "BusinessRuleError",
    "BusinessRuleValidationResult",
    "validate_business_rules",
    # Language Gate (U-043)
    "MIXED_THRESHOLD_RATIO",
    "LanguageGateResult",
    "LanguageRatio",
    "build_language_error_summary",
    "is_language_mixed",
    "measure_language_ratio",
    "validate_language_consistency",
]
</file>

<file path="backend/src/unknown_world/validation/language_gate.py">
"""Unknown World - ì–¸ì–´ í˜¼í•© ê²€ì¦ ê²Œì´íŠ¸ (RULE-006).

ko/en í˜¼í•© ì¶œë ¥ì„ ê°ì§€í•˜ê³  ì°¨ë‹¨í•˜ëŠ” Hard Gateì…ë‹ˆë‹¤.
TurnInput.languageë¥¼ SSOTë¡œ ì‚¼ì•„ TurnOutputì˜ ì‚¬ìš©ì ë…¸ì¶œ í…ìŠ¤íŠ¸ê°€
ë™ì¼ ì–¸ì–´ë¡œ ìˆ˜ë ´í•˜ëŠ”ì§€ ê²€ì¦í•©ë‹ˆë‹¤.

ì„¤ê³„ ì›ì¹™:
    - RULE-006: ko/en ì–¸ì–´ ì •ì±… ì¤€ìˆ˜ (í˜¼í•© ì¶œë ¥ ê¸ˆì§€)
    - RULE-004: ê²€ì¦ ì‹¤íŒ¨ ì‹œ Repair loopë¡œ ë³µêµ¬
    - CP-MVP-05: ì–¸ì–´ í˜¼í•© ê¸ˆì§€ ê²€ì¦

í˜ì–´ë§ ê²°ì •:
    - Q1: Option A (ë³´ìˆ˜ì  - ì˜¤íƒ ìµœì†Œ, CPì—ì„œ íŠœë‹)
    - Q2: Option A (ê³ ìœ ëª… ìµœì†Œì¹˜ë§Œ í—ˆìš©)

ì°¸ì¡°:
    - vibe/unit-plans/U-043[Mvp].md
    - vibe/ref/en-ko-issue.png (í˜¼í•© ì¶œë ¥ ì‚¬ë¡€)
    - .cursor/rules/00-core-critical.mdc
"""

from __future__ import annotations

import logging
import re
import unicodedata
from dataclasses import dataclass, field
from typing import TYPE_CHECKING

from unknown_world.models.turn import Language

if TYPE_CHECKING:
    from unknown_world.models.turn import TurnOutput

# =============================================================================
# ë¡œê±° ì„¤ì •
# =============================================================================

logger = logging.getLogger(__name__)

# =============================================================================
# ìƒìˆ˜ ë° ì„¤ì •
# =============================================================================

# í˜ì–´ë§ ê²°ì • Q1: Option A (ë³´ìˆ˜ì  - ì˜¤íƒ ìµœì†Œ)
# í˜¼í•© íŒì • ì„ê³„ê°’ (ì´ ë¹„ìœ¨ ì´ìƒì´ë©´ "ì˜ëª»ëœ ì–¸ì–´"ë¡œ íŒì •)
MIXED_THRESHOLD_RATIO = 0.15  # 15% ì´ìƒì˜ ë°˜ëŒ€ ì–¸ì–´ ë¬¸ì â†’ í˜¼í•©ìœ¼ë¡œ íŒì •

# í˜ì–´ë§ ê²°ì • Q2: Option A (ê³ ìœ ëª… ìµœì†Œì¹˜ë§Œ í—ˆìš©)
# í—ˆìš© í™”ì´íŠ¸ë¦¬ìŠ¤íŠ¸ (ì˜ì–´ ê³ ìœ ëª… - ì¬í™”/ëª¨ë¸ ë¼ë²¨ ë“±)
# ì£¼ì˜: ë³µí•©ì–´ëŠ” ê°œë³„ ë‹¨ì–´ë„ í•¨ê»˜ ë“±ë¡í•´ì•¼ í•©ë‹ˆë‹¤ (í•œê¸€ ë¶™ì€ ê²½ìš° ë‹¨ì–´ ê²½ê³„ ë§¤ì¹­ ë¬¸ì œ)
ALLOWED_ENGLISH_TERMS: set[str] = {
    # ì¬í™” ì´ë¦„ (RULE-005)
    "signal",
    "shard",
    "memory",
    "memory shard",
    # ëª¨ë¸ ë¼ë²¨ (RULE-008)
    "fast",
    "quality",
    "cheap",
    "ref",
    # ì‹œìŠ¤í…œ ìƒìˆ˜
    "ok",
    "fail",
    "blocked",
    # ê¸°íƒ€ í—ˆìš© ì•½ì–´
    "ui",
    "api",
    "id",
    "json",
    "schema",
}

# í•œê¸€ ìœ ë‹ˆì½”ë“œ ë²”ìœ„
HANGUL_JAMO_START = 0x1100
HANGUL_JAMO_END = 0x11FF
HANGUL_SYLLABLES_START = 0xAC00
HANGUL_SYLLABLES_END = 0xD7AF
HANGUL_COMPAT_JAMO_START = 0x3130
HANGUL_COMPAT_JAMO_END = 0x318F


# =============================================================================
# ì–¸ì–´ ê°ì§€ íœ´ë¦¬ìŠ¤í‹±
# =============================================================================


def _is_hangul(char: str) -> bool:
    """í•œê¸€ ë¬¸ìì¸ì§€ í™•ì¸í•©ë‹ˆë‹¤."""
    code = ord(char)
    return (
        (HANGUL_SYLLABLES_START <= code <= HANGUL_SYLLABLES_END)
        or (HANGUL_JAMO_START <= code <= HANGUL_JAMO_END)
        or (HANGUL_COMPAT_JAMO_START <= code <= HANGUL_COMPAT_JAMO_END)
    )


def _is_latin(char: str) -> bool:
    """ë¼í‹´ ì•ŒíŒŒë²³ì¸ì§€ í™•ì¸í•©ë‹ˆë‹¤ (a-z, A-Z)."""
    return char.isalpha() and unicodedata.category(char).startswith("L") and not _is_hangul(char)


def _normalize_text_for_check(text: str) -> str:
    """ê²€ì‚¬ìš©ìœ¼ë¡œ í…ìŠ¤íŠ¸ë¥¼ ì •ê·œí™”í•©ë‹ˆë‹¤.

    - ì†Œë¬¸ì ë³€í™˜
    - í™”ì´íŠ¸ë¦¬ìŠ¤íŠ¸ ë‹¨ì–´ ì œê±°
    - ìˆ«ì/ê¸°í˜¸/ê³µë°±/ì´ëª¨ì§€ ì œê±°
    """
    normalized = text.lower()

    # í™”ì´íŠ¸ë¦¬ìŠ¤íŠ¸ ë‹¨ì–´ ì œê±° (ëŒ€ì†Œë¬¸ì ë¬´ì‹œ)
    # ë³µí•©ì–´ë¥¼ ë¨¼ì € ì²˜ë¦¬ (ê¸´ ê²ƒë¶€í„°)
    sorted_terms = sorted(ALLOWED_ENGLISH_TERMS, key=len, reverse=True)
    for term in sorted_terms:
        # í•œê¸€ì´ ë¶™ì–´ìˆëŠ” ê²½ìš°ë„ ì²˜ë¦¬í•˜ê¸° ìœ„í•´ ë‹¨ì–´ ê²½ê³„ ëŒ€ì‹ 
        # ì•ŒíŒŒë²³ì´ ì•„ë‹Œ ë¬¸ì ë˜ëŠ” ë¬¸ìì—´ ê²½ê³„ë¡œ ë§¤ì¹­
        # ì˜ˆ: "Signalê°€", "Memory Shardë¥¼" ë“±
        pattern = rf"(?<![a-zA-Z]){re.escape(term)}(?![a-zA-Z])"
        normalized = re.sub(pattern, "", normalized, flags=re.IGNORECASE)

    return normalized


@dataclass
class LanguageRatio:
    """ì–¸ì–´ ë¹„ìœ¨ ì¸¡ì • ê²°ê³¼.

    Attributes:
        hangul_count: í•œê¸€ ë¬¸ì ìˆ˜
        latin_count: ë¼í‹´ ë¬¸ì ìˆ˜
        total_alpha: ì´ ì•ŒíŒŒë²³ ë¬¸ì ìˆ˜ (í•œê¸€ + ë¼í‹´)
        hangul_ratio: í•œê¸€ ë¹„ìœ¨ (0.0 ~ 1.0)
        latin_ratio: ë¼í‹´ ë¹„ìœ¨ (0.0 ~ 1.0)
    """

    hangul_count: int = 0
    latin_count: int = 0
    total_alpha: int = 0
    hangul_ratio: float = 0.0
    latin_ratio: float = 0.0


def measure_language_ratio(text: str) -> LanguageRatio:
    """í…ìŠ¤íŠ¸ì˜ í•œê¸€/ë¼í‹´ ë¹„ìœ¨ì„ ì¸¡ì •í•©ë‹ˆë‹¤.

    í™”ì´íŠ¸ë¦¬ìŠ¤íŠ¸ ë‹¨ì–´ëŠ” ì œê±°í•œ í›„ ì¸¡ì •í•©ë‹ˆë‹¤.

    Args:
        text: ì¸¡ì •í•  í…ìŠ¤íŠ¸

    Returns:
        LanguageRatio: ì–¸ì–´ ë¹„ìœ¨ ì¸¡ì • ê²°ê³¼
    """
    if not text:
        return LanguageRatio()

    # ì •ê·œí™” (í™”ì´íŠ¸ë¦¬ìŠ¤íŠ¸ ì œê±°)
    normalized = _normalize_text_for_check(text)

    hangul_count = 0
    latin_count = 0

    for char in normalized:
        if _is_hangul(char):
            hangul_count += 1
        elif _is_latin(char):
            latin_count += 1

    total = hangul_count + latin_count

    if total == 0:
        return LanguageRatio()

    return LanguageRatio(
        hangul_count=hangul_count,
        latin_count=latin_count,
        total_alpha=total,
        hangul_ratio=hangul_count / total,
        latin_ratio=latin_count / total,
    )


def is_language_mixed(text: str, expected_language: Language) -> bool:
    """í…ìŠ¤íŠ¸ê°€ ì˜ˆìƒ ì–¸ì–´ì™€ ë‹¤ë¥¸ ì–¸ì–´ê°€ í˜¼í•©ë˜ì—ˆëŠ”ì§€ í™•ì¸í•©ë‹ˆë‹¤.

    Args:
        text: ê²€ì‚¬í•  í…ìŠ¤íŠ¸
        expected_language: ì˜ˆìƒ ì–¸ì–´ (TurnInput.language)

    Returns:
        bool: í˜¼í•©ë˜ì—ˆìœ¼ë©´ True
    """
    if not text or len(text.strip()) == 0:
        return False

    ratio = measure_language_ratio(text)

    # ì•ŒíŒŒë²³ì´ ê±°ì˜ ì—†ëŠ” ê²½ìš° (ìˆ«ì/ê¸°í˜¸ë§Œ) â†’ í˜¼í•© ì•„ë‹˜
    if ratio.total_alpha < 3:
        return False

    # ì˜ˆìƒ ì–¸ì–´ì— ë”°ë¼ ë°˜ëŒ€ ì–¸ì–´ ë¹„ìœ¨ ì²´í¬
    if expected_language == Language.KO:
        # í•œêµ­ì–´ ì˜ˆìƒì¸ë° ë¼í‹´ ë¹„ìœ¨ì´ ì„ê³„ê°’ ì´ìƒì´ë©´ í˜¼í•©
        return ratio.latin_ratio >= MIXED_THRESHOLD_RATIO
    else:
        # ì˜ì–´ ì˜ˆìƒì¸ë° í•œê¸€ ë¹„ìœ¨ì´ ì„ê³„ê°’ ì´ìƒì´ë©´ í˜¼í•©
        return ratio.hangul_ratio >= MIXED_THRESHOLD_RATIO


# =============================================================================
# TurnOutput í…ìŠ¤íŠ¸ ì¶”ì¶œ
# =============================================================================


@dataclass
class ExtractedText:
    """ì¶”ì¶œëœ ì‚¬ìš©ì ë…¸ì¶œ í…ìŠ¤íŠ¸.

    Attributes:
        field_path: í•„ë“œ ê²½ë¡œ (ì˜ˆ: "narrative", "ui.action_deck.cards[0].label")
        text: í…ìŠ¤íŠ¸ ë‚´ìš©
    """

    field_path: str
    text: str


def extract_user_facing_texts(turn_output: TurnOutput) -> list[ExtractedText]:
    """TurnOutputì—ì„œ ì‚¬ìš©ì ë…¸ì¶œ í…ìŠ¤íŠ¸ë¥¼ ì¶”ì¶œí•©ë‹ˆë‹¤.

    ê²€ì‚¬ ë²”ìœ„ (ìš°ì„ ìˆœìœ„):
        - narrative
        - ui.action_deck.cards[].label, description, hint, reward_hint, disabled_reason
        - ui.objects[].label, interaction_hint
        - world.quests_updated[].label
        - world.rules_changed[].label, description
        - world.memory_pins[].content

    Args:
        turn_output: ê²€ì‚¬í•  TurnOutput

    Returns:
        list[ExtractedText]: ì¶”ì¶œëœ í…ìŠ¤íŠ¸ ëª©ë¡
    """
    texts: list[ExtractedText] = []

    # 1. narrative (ê°€ì¥ ì¤‘ìš”)
    if turn_output.narrative:
        texts.append(ExtractedText(field_path="narrative", text=turn_output.narrative))

    # 2. ui.action_deck.cards[]
    # U-065: description, hint, reward_hint, disabled_reason í•„ë“œ ì œê±°ë¨
    for i, card in enumerate(turn_output.ui.action_deck.cards):
        texts.append(ExtractedText(field_path=f"ui.action_deck.cards[{i}].label", text=card.label))

    # 3. ui.objects[]
    for i, obj in enumerate(turn_output.ui.objects):
        texts.append(ExtractedText(field_path=f"ui.objects[{i}].label", text=obj.label))
        if obj.interaction_hint:
            texts.append(
                ExtractedText(
                    field_path=f"ui.objects[{i}].interaction_hint",
                    text=obj.interaction_hint,
                )
            )

    # 4. world.quests_updated[]
    for i, quest in enumerate(turn_output.world.quests_updated):
        texts.append(ExtractedText(field_path=f"world.quests_updated[{i}].label", text=quest.label))

    # 5. world.rules_changed[]
    for i, rule in enumerate(turn_output.world.rules_changed):
        texts.append(ExtractedText(field_path=f"world.rules_changed[{i}].label", text=rule.label))
        if rule.description:
            texts.append(
                ExtractedText(
                    field_path=f"world.rules_changed[{i}].description",
                    text=rule.description,
                )
            )

    # 6. world.memory_pins[]
    for i, pin in enumerate(turn_output.world.memory_pins):
        texts.append(ExtractedText(field_path=f"world.memory_pins[{i}].content", text=pin.content))

    # 7. safety.message
    if turn_output.safety.message:
        texts.append(ExtractedText(field_path="safety.message", text=turn_output.safety.message))

    return texts


# =============================================================================
# ì–¸ì–´ í˜¼í•© ê²€ì¦ ê²°ê³¼
# =============================================================================


@dataclass
class LanguageGateResult:
    """ì–¸ì–´ í˜¼í•© ê²€ì¦ ê²°ê³¼.

    Attributes:
        is_valid: ê²€ì¦ í†µê³¼ ì—¬ë¶€ (í˜¼í•© ì—†ìŒ)
        violations: ìœ„ë°˜ ì‚¬í•­ ëª©ë¡ (í•„ë“œ ê²½ë¡œ + ìƒ˜í”Œ í† í°)
        expected_language: ì˜ˆìƒ ì–¸ì–´
    """

    is_valid: bool = True
    violations: list[dict[str, str]] = field(default_factory=lambda: [])
    expected_language: Language = Language.KO

    def add_violation(self, field_path: str, sample_text: str) -> None:
        """ìœ„ë°˜ ì‚¬í•­ì„ ì¶”ê°€í•©ë‹ˆë‹¤."""
        self.is_valid = False
        # ë¡œê·¸ì— ì „ì²´ í…ìŠ¤íŠ¸ ë…¸ì¶œ ë°©ì§€ - ì• 50ìë§Œ ìƒ˜í”Œë§
        truncated = sample_text[:50] + "..." if len(sample_text) > 50 else sample_text
        self.violations.append({"field": field_path, "sample": truncated})


def validate_language_consistency(
    turn_output: TurnOutput,
    expected_language: Language,
) -> LanguageGateResult:
    """TurnOutputì˜ ì–¸ì–´ ì¼ê´€ì„±ì„ ê²€ì¦í•©ë‹ˆë‹¤.

    ì‚¬ìš©ì ë…¸ì¶œ í…ìŠ¤íŠ¸ê°€ expected_languageì™€ ì¼ì¹˜í•˜ëŠ”ì§€ í™•ì¸í•©ë‹ˆë‹¤.
    í˜¼í•© ë°œê²¬ ì‹œ ìœ„ë°˜ ëª©ë¡ì„ ë°˜í™˜í•©ë‹ˆë‹¤.

    Args:
        turn_output: ê²€ì‚¬í•  TurnOutput
        expected_language: ì˜ˆìƒ ì–¸ì–´ (TurnInput.language)

    Returns:
        LanguageGateResult: ê²€ì¦ ê²°ê³¼

    Example:
        >>> result = validate_language_consistency(turn_output, Language.KO)
        >>> if not result.is_valid:
        ...     print(f"í˜¼í•© ë°œê²¬: {len(result.violations)}ê±´")
    """
    result = LanguageGateResult(expected_language=expected_language)

    # ì‚¬ìš©ì ë…¸ì¶œ í…ìŠ¤íŠ¸ ì¶”ì¶œ
    texts = extract_user_facing_texts(turn_output)

    # ê° í…ìŠ¤íŠ¸ ê²€ì‚¬
    for extracted in texts:
        if is_language_mixed(extracted.text, expected_language):
            result.add_violation(extracted.field_path, extracted.text)

    if not result.is_valid:
        logger.warning(
            "[LanguageGate] ì–¸ì–´ í˜¼í•© ê°ì§€",
            extra={
                "expected_language": expected_language.value,
                "violation_count": len(result.violations),
            },
        )

    return result


# =============================================================================
# i18n ì—ëŸ¬ ë©”ì‹œì§€ (RULE-006)
# =============================================================================

LANGUAGE_GATE_MESSAGES: dict[Language, dict[str, str]] = {
    Language.KO: {
        "summary_header": "ì–¸ì–´ í˜¼í•©ì´ ê°ì§€ë˜ì—ˆìŠµë‹ˆë‹¤ (RULE-006 ìœ„ë°˜):",
        "violation_item": "- í•„ë“œ '{field}': í•œêµ­ì–´ë¡œ ì‘ì„±í•´ì•¼ í•©ë‹ˆë‹¤",
        "instruction": "ëª¨ë“  ì‚¬ìš©ì ë…¸ì¶œ í…ìŠ¤íŠ¸ë¥¼ í•œêµ­ì–´(ko-KR)ë¡œ ë‹¤ì‹œ ì‘ì„±í•˜ì„¸ìš”.",
    },
    Language.EN: {
        "summary_header": "Language mixing detected (RULE-006 violation):",
        "violation_item": "- Field '{field}': Must be written in English",
        "instruction": "Rewrite all user-facing text in English (en-US).",
    },
}


def build_language_error_summary(result: LanguageGateResult) -> str:
    """ì–¸ì–´ í˜¼í•© ê²€ì¦ ì‹¤íŒ¨ì— ëŒ€í•œ ì—ëŸ¬ ìš”ì•½ì„ ìƒì„±í•©ë‹ˆë‹¤.

    Repair í”„ë¡¬í”„íŠ¸ì— í¬í•¨í•  ìš”ì•½ì…ë‹ˆë‹¤.
    ì „ì²´ í…ìŠ¤íŠ¸ëŠ” ë…¸ì¶œí•˜ì§€ ì•Šê³  í•„ë“œ ê²½ë¡œë§Œ í‘œì‹œí•©ë‹ˆë‹¤.

    Args:
        result: ì–¸ì–´ ê²€ì¦ ê²°ê³¼

    Returns:
        str: ì—ëŸ¬ ìš”ì•½ ë¬¸ìì—´
    """
    if result.is_valid:
        return ""

    messages = LANGUAGE_GATE_MESSAGES[result.expected_language]
    lines = [messages["summary_header"]]

    # ìµœëŒ€ 5ê°œê¹Œì§€ë§Œ í‘œì‹œ (ë„ˆë¬´ ë§ìœ¼ë©´ í”„ë¡¬í”„íŠ¸ ë¹„ëŒ€)
    for violation in result.violations[:5]:
        lines.append(messages["violation_item"].format(field=violation["field"]))

    if len(result.violations) > 5:
        remaining = len(result.violations) - 5
        if result.expected_language == Language.KO:
            lines.append(f"- (ì™¸ {remaining}ê±´ ì¶”ê°€ ìœ„ë°˜)")
        else:
            lines.append(f"- (and {remaining} more violations)")

    lines.append("")
    lines.append(messages["instruction"])

    return "\n".join(lines)
</file>

<file path="backend/start_and_test.py">
"""ì„œë²„ë¥¼ ì§ì ‘ ì‹œì‘í•˜ê³ , ìš”ì²­ì„ ë³´ë‚´ê³ , ì¢…ë£Œí•©ë‹ˆë‹¤."""

import json
import time
from pathlib import Path

from dotenv import load_dotenv

load_dotenv(dotenv_path=Path(__file__).resolve().parent / ".env", override=False)

from multiprocessing import Process

import httpx
import uvicorn


def run_server():
    """ì„œë²„ í”„ë¡œì„¸ìŠ¤."""
    uvicorn.run(
        "src.unknown_world.main:app",
        host="0.0.0.0",
        port=8011,
        log_level="warning",
    )


def test_api():
    """API í…ŒìŠ¤íŠ¸."""
    time.sleep(4)  # ì„œë²„ ì‹œì‘ ëŒ€ê¸°

    print("=== Testing API ===")
    try:
        r = httpx.post(
            "http://localhost:8011/api/turn",
            json={
                "language": "ko-KR",
                "text": "ë¬¸ì„ ì—´ì–´ë³¸ë‹¤",
                "client": {"viewport_w": 1920, "viewport_h": 1080, "theme": "dark"},
                "economy_snapshot": {"signal": 100, "memory_shard": 5},
            },
            timeout=60.0,
        )

        for line in r.text.strip().split("\n"):
            d = json.loads(line)
            t = d.get("type")
            if t == "repair":
                print(f"  REPAIR: attempt={d.get('attempt')} msg={d.get('message')}")
            elif t == "badges":
                print(f"  BADGES: {d.get('badges')}")
            elif t == "final":
                fc = d.get("data", {}).get("agent_console", {})
                narr = d.get("data", {}).get("narrative", "")[:80]
                print(f"  FINAL: badges={fc.get('badges')} repair={fc.get('repair_count')}")
                print(f"  NARRATIVE: {narr}")
            elif t == "error":
                print(f"  ERROR: {d.get('message')} code={d.get('code')}")
    except Exception as e:
        print(f"  EXCEPTION: {e}")


if __name__ == "__main__":
    server = Process(target=run_server, daemon=True)
    server.start()
    print(f"Server PID: {server.pid}")

    try:
        test_api()
    finally:
        server.terminate()
        server.join(timeout=5)
        print("\nServer stopped.")
</file>

<file path="backend/test_api.py">
import json

import httpx

r = httpx.post(
    "http://localhost:8011/api/turn",
    json={
        "language": "ko-KR",
        "text": "ë¬¸ì„ ì—´ì–´ë³¸ë‹¤",
        "client": {"viewport_w": 1920, "viewport_h": 1080, "theme": "dark"},
        "economy_snapshot": {"signal": 100, "memory_shard": 5},
    },
    timeout=30.0,
)
for line in r.text.strip().split("\n"):
    d = json.loads(line)
    t = d.get("type")
    if t in ("repair", "badges", "error", "final"):
        if t == "final":
            fc = d.get("data", {}).get("agent_console", {})
            print(f"{t}: badges={fc.get('badges')} repair={fc.get('repair_count')}")
        else:
            print(f"{t}: {json.dumps(d, ensure_ascii=False)}")
</file>

<file path="backend/tests/integration/test_real_mode_gate.py">
"""CP-MVP-07: real ëª¨ë“œ ë¡œì»¬ ì‹¤í–‰ ê²Œì´íŠ¸ í†µí•© í…ŒìŠ¤íŠ¸.

ë¡œì»¬ ê°œë°œ í™˜ê²½ì—ì„œ `.env` ê¸°ë°˜ ì„¤ì •ìœ¼ë¡œ **real ëª¨ë“œ(ì‹¤ëª¨ë¸) ì‹¤í–‰**ì´
ì•ˆì •ì ìœ¼ë¡œ ì¬í˜„ë˜ëŠ”ì§€ ê²€ì¦í•©ë‹ˆë‹¤.

ì™„ë£Œ ê¸°ì¤€:
- `.env`ê°€ ë¡œë“œëœ ìƒíƒœì—ì„œ ì„œë²„ê°€ real ëª¨ë“œë¡œ ì‹¤í–‰ë˜ë©°, `/health`ê°€ ì •ìƒ ì‘ë‹µí•œë‹¤.
- í„´ 1íšŒ ì‹¤í–‰ ì‹œ NDJSON ìŠ¤íŠ¸ë¦¼ì´ ì •ìƒì ìœ¼ë¡œ íë¥´ê³  ìµœì¢… `final`ì´ ìŠ¤í‚¤ë§ˆ/ë¹„ì¦ˆë‹ˆìŠ¤ ë£°ì„ í†µê³¼í•œë‹¤.
- ì¸ì¦/í™˜ê²½ë³€ìˆ˜ ëˆ„ë½ ì¼€ì´ìŠ¤ì—ì„œë„ ì„œë²„ê°€ í¬ë˜ì‹œí•˜ì§€ ì•Šê³ , ì•ˆì „ í´ë°±ìœ¼ë¡œ ì¢…ë£Œí•œë‹¤. (RULE-004)
- mock ê³ ì • ë‚´ëŸ¬í‹°ë¸Œê°€ real ëª¨ë“œì—ì„œ ë°˜ë³µ ë…¸ì¶œë˜ì§€ ì•ŠëŠ”ë‹¤(ëª¨ë“œ ë“œë¦¬í”„íŠ¸ ë°©ì§€).
- ë¯¼ê° ì •ë³´ê°€ ë¡œê·¸ì— ë…¸ì¶œë˜ì§€ ì•ŠëŠ”ë‹¤ (RULE-007).

ì°¸ì¡°:
- vibe/unit-plans/CP-MVP-07.md
- vibe/unit-results/U-047[Mvp].md
- vibe/unit-results/CP-MVP-04.md
"""

from __future__ import annotations

import json
import os
from collections.abc import Generator
from pathlib import Path
from typing import Any

import pytest
from dotenv import load_dotenv
from fastapi.testclient import TestClient

from unknown_world.main import app
from unknown_world.models.turn import Language, TurnOutput
from unknown_world.services.genai_client import (
    GenAIMode,
    get_genai_client,
    reset_genai_client,
)

# =============================================================================
# Fixtures
# =============================================================================


@pytest.fixture
def client() -> TestClient:
    """FastAPI í…ŒìŠ¤íŠ¸ í´ë¼ì´ì–¸íŠ¸."""
    return TestClient(app)


@pytest.fixture
def mock_mode_env() -> Generator[None]:
    """UW_MODE=mock í™˜ê²½ì„ ì„¤ì •í•©ë‹ˆë‹¤."""
    original = os.environ.get("UW_MODE")
    os.environ["UW_MODE"] = "mock"
    reset_genai_client()  # í´ë¼ì´ì–¸íŠ¸ ìºì‹œ ì´ˆê¸°í™”

    yield

    if original is not None:
        os.environ["UW_MODE"] = original
    elif "UW_MODE" in os.environ:
        del os.environ["UW_MODE"]
    reset_genai_client()


@pytest.fixture
def real_mode_env() -> Generator[None]:
    """UW_MODE=real í™˜ê²½ì„ ì„¤ì •í•©ë‹ˆë‹¤ (ì‹¤ì œ API í˜¸ì¶œ ì—†ì´ í´ë¼ì´ì–¸íŠ¸ ëª¨ë“œë§Œ ë³€ê²½)."""
    original = os.environ.get("UW_MODE")
    os.environ["UW_MODE"] = "real"
    reset_genai_client()  # í´ë¼ì´ì–¸íŠ¸ ìºì‹œ ì´ˆê¸°í™”

    yield

    if original is not None:
        os.environ["UW_MODE"] = original
    elif "UW_MODE" in os.environ:
        del os.environ["UW_MODE"]
    reset_genai_client()


# =============================================================================
# ì‹œë‚˜ë¦¬ì˜¤ A: ì„œë²„ ê¸°ë™ ë° ìƒíƒœ í™•ì¸ (Health Check)
# =============================================================================


class TestServerHealthWithEnv:
    """ì„œë²„ ê¸°ë™ ë° ìƒíƒœ í™•ì¸ í…ŒìŠ¤íŠ¸ (ì‹œë‚˜ë¦¬ì˜¤ A)."""

    def test_health_endpoint_returns_ok(self, client: TestClient) -> None:
        """[Happy] /health ì—”ë“œí¬ì¸íŠ¸ê°€ ì •ìƒ ì‘ë‹µí•©ë‹ˆë‹¤."""
        # When: í—¬ìŠ¤ì²´í¬ ìš”ì²­
        response = client.get("/health")

        # Then: ì •ìƒ ì‘ë‹µ
        assert response.status_code == 200
        data = response.json()
        assert data["status"] in ("ok", "degraded")
        assert data["service"] == "unknown-world-backend"
        assert "version" in data

    def test_health_no_rembg_field(self, client: TestClient) -> None:
        """[Happy] /health ì‘ë‹µì— rembg ìƒíƒœê°€ í¬í•¨ë˜ì§€ ì•ŠìŠµë‹ˆë‹¤ (U-091 ì œê±°)."""
        # When: í—¬ìŠ¤ì²´í¬ ìš”ì²­
        response = client.get("/health")

        # Then: rembg ì •ë³´ê°€ ì—†ì–´ì•¼ í•¨ (U-091: ëŸ°íƒ€ì„ rembg ì œê±°)
        data = response.json()
        assert "rembg" not in data

    def test_uw_mode_environment_variable_loaded(self) -> None:
        """[Happy] UW_MODE í™˜ê²½ë³€ìˆ˜ê°€ ì˜¬ë°”ë¥´ê²Œ ë¡œë“œë©ë‹ˆë‹¤."""
        # Given: í˜„ì¬ í™˜ê²½ì˜ UW_MODE ê°’
        uw_mode = os.environ.get("UW_MODE", "mock")

        # Then: ìœ íš¨í•œ ê°’ì´ì–´ì•¼ í•¨
        assert uw_mode in ("mock", "real")


# =============================================================================
# ì‹œë‚˜ë¦¬ì˜¤ B: real ëª¨ë“œ í„´ ìŠ¤ëª¨í¬ í…ŒìŠ¤íŠ¸ (ìŠ¤íŠ¸ë¦¬ë°)
# =============================================================================


class TestTurnStreamingInMockMode:
    """í„´ ìŠ¤íŠ¸ë¦¬ë° í…ŒìŠ¤íŠ¸ (Mock ëª¨ë“œ, ì‹œë‚˜ë¦¬ì˜¤ Bì˜ ê¸°ë³¸ ê²½ë¡œ)."""

    def test_stage_events_order(self, client: TestClient, mock_mode_env: None) -> None:
        """[Happy] stage ì´ë²¤íŠ¸ê°€ ì˜¬ë°”ë¥¸ ìˆœì„œë¡œ ë°œìƒí•©ë‹ˆë‹¤."""
        # Given: ìœ íš¨í•œ í„´ ì…ë ¥
        payload = {
            "language": "ko-KR",
            "text": "í…ŒìŠ¤íŠ¸ ì…ë ¥",
            "client": {"viewport_w": 1920, "viewport_h": 1080, "theme": "dark"},
            "economy_snapshot": {"signal": 100, "memory_shard": 5},
        }

        # When: í„´ ìš”ì²­
        response = client.post("/api/turn", json=payload)

        # Then: ì •ìƒ ìŠ¤íŠ¸ë¦¬ë° ì‘ë‹µ
        assert response.status_code == 200
        assert response.headers["content-type"] == "application/x-ndjson"

        events = [json.loads(line) for line in response.iter_lines() if line]

        # stage ì´ë²¤íŠ¸ ìˆœì„œ í™•ì¸
        stages = [e["name"] for e in events if e["type"] == "stage" and e["status"] == "start"]
        expected_stages = [
            "parse",
            "validate",
            "plan",
            "resolve",
            "render",
            "verify",
            "commit",
        ]
        assert stages == expected_stages

    def test_final_event_has_valid_turn_output(
        self, client: TestClient, mock_mode_env: None
    ) -> None:
        """[Happy] final ì´ë²¤íŠ¸ê°€ ìœ íš¨í•œ TurnOutputì„ í¬í•¨í•©ë‹ˆë‹¤."""
        # Given: ìœ íš¨í•œ í„´ ì…ë ¥
        payload = {
            "language": "ko-KR",
            "text": "ë¬¸ì„ ì—´ì–´ë³¸ë‹¤",
            "client": {"viewport_w": 1920, "viewport_h": 1080},
            "economy_snapshot": {"signal": 100, "memory_shard": 5},
        }

        # When: í„´ ìš”ì²­
        response = client.post("/api/turn", json=payload)
        events = [json.loads(line) for line in response.iter_lines() if line]

        # Then: final ì´ë²¤íŠ¸ í™•ì¸
        final_events = [e for e in events if e["type"] == "final"]
        assert len(final_events) == 1

        # Pydantic ê²€ì¦ (RULE-003)
        turn_output = TurnOutput.model_validate(final_events[0]["data"])
        assert turn_output.language == Language.KO

    def test_badges_contain_all_categories(self, client: TestClient, mock_mode_env: None) -> None:
        """[Happy] badgesê°€ ëª¨ë“  ì¹´í…Œê³ ë¦¬(Schema/Economy/Safety/Consistency)ë¥¼ í¬í•¨í•©ë‹ˆë‹¤."""
        # Given: ìœ íš¨í•œ í„´ ì…ë ¥
        payload = {
            "language": "ko-KR",
            "text": "íƒìƒ‰í•œë‹¤",
            "client": {"viewport_w": 1920, "viewport_h": 1080},
            "economy_snapshot": {"signal": 100, "memory_shard": 5},
        }

        # When: í„´ ìš”ì²­
        response = client.post("/api/turn", json=payload)
        events = [json.loads(line) for line in response.iter_lines() if line]

        # Then: badges ì´ë²¤íŠ¸ í™•ì¸
        badges_events = [e for e in events if e["type"] == "badges"]
        assert len(badges_events) >= 1

        # ìµœì¢… badgesì— ëª¨ë“  ì¹´í…Œê³ ë¦¬ê°€ í¬í•¨ë˜ì–´ì•¼ í•¨
        final_badges = badges_events[-1]["badges"]
        badge_categories = {b.split("_")[0] for b in final_badges}

        # Schema, Economy, Safety, Consistency ì¤‘ ìµœì†Œ 3ê°œ ì´ìƒ
        expected_categories = {"schema", "economy", "safety", "consistency"}
        assert len(badge_categories.intersection(expected_categories)) >= 3


# =============================================================================
# ì‹œë‚˜ë¦¬ì˜¤ C: Hard Gate ì¸ë°”ë¦¬ì–¸íŠ¸ ê²€ì¦
# =============================================================================


class TestHardGateInvariants:
    """Hard Gate ì¸ë°”ë¦¬ì–¸íŠ¸ ê²€ì¦ í…ŒìŠ¤íŠ¸ (ì‹œë‚˜ë¦¬ì˜¤ C)."""

    def test_schema_ok_in_successful_turn(self, client: TestClient, mock_mode_env: None) -> None:
        """[Happy] ì„±ê³µì ì¸ í„´ì—ì„œ schema_ok ë°°ì§€ê°€ í¬í•¨ë©ë‹ˆë‹¤."""
        # Given: ìœ íš¨í•œ í„´ ì…ë ¥
        payload = {
            "language": "ko-KR",
            "text": "ì •ìƒ ì…ë ¥",
            "client": {"viewport_w": 1920, "viewport_h": 1080},
            "economy_snapshot": {"signal": 100, "memory_shard": 5},
        }

        # When: í„´ ìš”ì²­
        response = client.post("/api/turn", json=payload)
        events = [json.loads(line) for line in response.iter_lines() if line]

        # Then: finalì˜ ë°°ì§€ì— schema_ok í¬í•¨
        final_event = next(e for e in events if e["type"] == "final")
        badges = final_event["data"]["agent_console"]["badges"]
        assert "schema_ok" in badges

    def test_economy_ok_and_no_negative_balance(
        self, client: TestClient, mock_mode_env: None
    ) -> None:
        """[Happy] economy_ok ë°°ì§€ì™€ ì”ì•¡ ìŒìˆ˜ ê¸ˆì§€ (RULE-005)."""
        # Given: ìœ íš¨í•œ í„´ ì…ë ¥
        payload = {
            "language": "ko-KR",
            "text": "í–‰ë™",
            "client": {"viewport_w": 1920, "viewport_h": 1080},
            "economy_snapshot": {"signal": 50, "memory_shard": 2},
        }

        # When: í„´ ìš”ì²­
        response = client.post("/api/turn", json=payload)
        events = [json.loads(line) for line in response.iter_lines() if line]

        # Then: economy í™•ì¸
        final_event = next(e for e in events if e["type"] == "final")
        economy = final_event["data"]["economy"]

        # ì”ì•¡ì€ ìŒìˆ˜ê°€ ì•„ë‹ˆì–´ì•¼ í•¨
        assert economy["balance_after"]["signal"] >= 0
        assert economy["balance_after"]["memory_shard"] >= 0

        # economy_ok ë°°ì§€ í¬í•¨
        badges = final_event["data"]["agent_console"]["badges"]
        assert "economy_ok" in badges

    def test_language_consistency(self, client: TestClient, mock_mode_env: None) -> None:
        """[Happy] ì–¸ì–´ ì¼ê´€ì„± ìœ ì§€ (RULE-006)."""
        # Given: í•œêµ­ì–´ ìš”ì²­
        payload = {
            "language": "ko-KR",
            "text": "í…ŒìŠ¤íŠ¸",
            "client": {"viewport_w": 1920, "viewport_h": 1080},
            "economy_snapshot": {"signal": 100, "memory_shard": 5},
        }

        # When: í„´ ìš”ì²­
        response = client.post("/api/turn", json=payload)
        events = [json.loads(line) for line in response.iter_lines() if line]

        # Then: ì‘ë‹µ ì–¸ì–´ê°€ ìš”ì²­ê³¼ ì¼ì¹˜
        final_event = next(e for e in events if e["type"] == "final")
        assert final_event["data"]["language"] == "ko-KR"


# =============================================================================
# ì‹œë‚˜ë¦¬ì˜¤ D: ì¸ì¦ ì‹¤íŒ¨ ì¼€ì´ìŠ¤ (ì•ˆì „ í´ë°±)
# =============================================================================


class TestSafeFallback:
    """ì•ˆì „ í´ë°± í…ŒìŠ¤íŠ¸ (ì‹œë‚˜ë¦¬ì˜¤ D)."""

    def test_invalid_input_returns_error_and_fallback(self, client: TestClient) -> None:
        """[Error] ì˜ëª»ëœ ì…ë ¥ ì‹œ error + final(í´ë°±) ì´ë²¤íŠ¸ê°€ ë°˜í™˜ë©ë‹ˆë‹¤."""
        # Given: ì˜ëª»ëœ ì–¸ì–´ ì½”ë“œ
        payload = {
            "language": "invalid-lang",
            "text": "",
        }

        # When: í„´ ìš”ì²­
        response = client.post("/api/turn", json=payload)

        # Then: 200 ì‘ë‹µ (ìŠ¤íŠ¸ë¦¬ë°ì´ë¯€ë¡œ)
        assert response.status_code == 200

        events = [json.loads(line) for line in response.iter_lines() if line]

        # error ì´ë²¤íŠ¸ í¬í•¨
        error_events = [e for e in events if e["type"] == "error"]
        assert len(error_events) >= 1
        assert error_events[0]["code"] == "VALIDATION_ERROR"

        # final(í´ë°±) ì´ë²¤íŠ¸ í¬í•¨
        final_events = [e for e in events if e["type"] == "final"]
        assert len(final_events) == 1

    def test_fallback_has_zero_cost(self, client: TestClient) -> None:
        """[Error] í´ë°± ì‘ë‹µì˜ ë¹„ìš©ì€ 0ì…ë‹ˆë‹¤ (RULE-005)."""
        # Given: ì˜ëª»ëœ ì…ë ¥ìœ¼ë¡œ í´ë°± ìœ ë„
        payload = {
            "language": "invalid",
            "text": "",
        }

        # When: í„´ ìš”ì²­
        response = client.post("/api/turn", json=payload)
        events = [json.loads(line) for line in response.iter_lines() if line]

        # Then: í´ë°± ë¹„ìš© 0
        final_event = next(e for e in events if e["type"] == "final")
        economy = final_event["data"]["economy"]
        assert economy["cost"]["signal"] == 0
        assert economy["cost"]["memory_shard"] == 0

    def test_fallback_includes_all_badge_categories(self, client: TestClient) -> None:
        """[Error] í´ë°± ì‘ë‹µë„ ëª¨ë“  ë°°ì§€ ì¹´í…Œê³ ë¦¬ë¥¼ í¬í•¨í•©ë‹ˆë‹¤ (RU-005-S1)."""
        # Given: ì˜ëª»ëœ ì…ë ¥ìœ¼ë¡œ í´ë°± ìœ ë„
        payload = {
            "language": "invalid",
            "text": "",
        }

        # When: í„´ ìš”ì²­
        response = client.post("/api/turn", json=payload)
        events = [json.loads(line) for line in response.iter_lines() if line]

        # Then: í´ë°±ì˜ ë°°ì§€ í™•ì¸
        final_event = next(e for e in events if e["type"] == "final")
        badges = final_event["data"]["agent_console"]["badges"]

        # ëª¨ë“  ì¹´í…Œê³ ë¦¬ í¬í•¨ í™•ì¸
        badge_prefixes = {b.split("_")[0] for b in badges}
        expected_prefixes = {"schema", "economy", "safety", "consistency"}
        assert badge_prefixes == expected_prefixes


# =============================================================================
# ì‹œë‚˜ë¦¬ì˜¤: Mock í…œí”Œë¦¿ ë°˜ë³µ ë°©ì§€ (ëª¨ë“œ ë“œë¦¬í”„íŠ¸)
# =============================================================================


class TestModeDriftPrevention:
    """ëª¨ë“œ ë“œë¦¬í”„íŠ¸ ë°©ì§€ í…ŒìŠ¤íŠ¸."""

    def test_mock_mode_client_returns_mock(self, mock_mode_env: None) -> None:
        """[Happy] UW_MODE=mockì¼ ë•Œ Mock í´ë¼ì´ì–¸íŠ¸ê°€ ë°˜í™˜ë©ë‹ˆë‹¤."""
        # When: í´ë¼ì´ì–¸íŠ¸ ì¡°íšŒ
        client = get_genai_client()

        # Then: Mock ëª¨ë“œ
        assert client.mode == GenAIMode.MOCK

    def test_real_mode_setting_respected(self, real_mode_env: None) -> None:
        """[Happy] UW_MODE=realì¼ ë•Œ real ëª¨ë“œê°€ ì„¤ì •ë©ë‹ˆë‹¤.

        Note: ì‹¤ì œ Vertex AI ì—°ê²°ì´ ì—†ìœ¼ë©´ Mockìœ¼ë¡œ í´ë°±í•  ìˆ˜ ìˆì§€ë§Œ,
        í™˜ê²½ë³€ìˆ˜ ì„¤ì •ì€ ì˜¬ë°”ë¥´ê²Œ ë°˜ì˜ë˜ì–´ì•¼ í•©ë‹ˆë‹¤.
        """
        # When: í™˜ê²½ë³€ìˆ˜ í™•ì¸
        uw_mode = os.environ.get("UW_MODE")

        # Then: real ëª¨ë“œ ì„¤ì •ë¨
        assert uw_mode == "real"


# =============================================================================
# ì‹œë‚˜ë¦¬ì˜¤: ë³´ì•ˆ ê²€ì¦ (RULE-007)
# =============================================================================


class TestSecurityCompliance:
    """ë³´ì•ˆ ê·œì¹™ ì¤€ìˆ˜ í…ŒìŠ¤íŠ¸."""

    def test_sensitive_info_not_in_health_response(self, client: TestClient) -> None:
        """[Security] /health ì‘ë‹µì— ë¯¼ê° ì •ë³´ê°€ í¬í•¨ë˜ì§€ ì•ŠìŠµë‹ˆë‹¤."""
        # When: í—¬ìŠ¤ì²´í¬ ìš”ì²­
        response = client.get("/health")
        data = response.json()

        # Then: ë¯¼ê° ì •ë³´ ë¯¸í¬í•¨
        response_text = json.dumps(data)
        assert "GOOGLE_APPLICATION_CREDENTIALS" not in response_text
        assert "token" not in response_text.lower()
        assert "secret" not in response_text.lower()

    def test_error_response_no_internal_details(self, client: TestClient) -> None:
        """[Security] ì—ëŸ¬ ì‘ë‹µì— ë‚´ë¶€ êµ¬í˜„ ì„¸ë¶€ì‚¬í•­ì´ ë…¸ì¶œë˜ì§€ ì•ŠìŠµë‹ˆë‹¤."""
        # Given: ì˜ëª»ëœ ì…ë ¥
        payload = {"invalid": "data"}

        # When: í„´ ìš”ì²­
        response = client.post("/api/turn", json=payload)
        events = [json.loads(line) for line in response.iter_lines() if line]

        # Then: ì—ëŸ¬ ë©”ì‹œì§€ì— ìŠ¤íƒ íŠ¸ë ˆì´ìŠ¤ ì—†ìŒ
        error_events = [e for e in events if e["type"] == "error"]
        if error_events:
            error_message = str(error_events[0])
            assert "Traceback" not in error_message
            assert "File " not in error_message


# =============================================================================
# ì‹œë‚˜ë¦¬ì˜¤: .env ë¡œë”© ì •ì±… ê²€ì¦
# =============================================================================


class TestEnvLoadingPolicy:
    """í™˜ê²½ë³€ìˆ˜ ë¡œë”© ì •ì±… í…ŒìŠ¤íŠ¸."""

    def test_dotenv_override_false_policy(self) -> None:
        """[Policy] override=False ì •ì±…ì´ ì ìš©ë©ë‹ˆë‹¤.

        ìš´ì˜ í™˜ê²½ì˜ í™˜ê²½ë³€ìˆ˜ê°€ .env íŒŒì¼ë³´ë‹¤ ìš°ì„ í•©ë‹ˆë‹¤.
        """
        # Given: í™˜ê²½ë³€ìˆ˜ê°€ ì´ë¯¸ ì„¤ì •ë¨
        original = os.environ.get("TEST_OVERRIDE_VAR")
        os.environ["TEST_OVERRIDE_VAR"] = "production_value"

        try:
            # When: .env íŒŒì¼ ë¡œë“œ ì‹œë®¬ë ˆì´ì…˜ (override=False)
            from tempfile import NamedTemporaryFile

            with NamedTemporaryFile(mode="w", suffix=".env", delete=False) as f:
                f.write("TEST_OVERRIDE_VAR=dev_value\n")
                temp_path = Path(f.name)

            load_dotenv(dotenv_path=temp_path, override=False)

            # Then: ê¸°ì¡´ ê°’ ìœ ì§€
            assert os.environ.get("TEST_OVERRIDE_VAR") == "production_value"

        finally:
            temp_path.unlink()
            if original is not None:
                os.environ["TEST_OVERRIDE_VAR"] = original
            elif "TEST_OVERRIDE_VAR" in os.environ:
                del os.environ["TEST_OVERRIDE_VAR"]

    def test_server_works_without_env_file(self, client: TestClient) -> None:
        """[Policy] .env íŒŒì¼ ì—†ì´ë„ ì„œë²„ê°€ ì •ìƒ ì‘ë™í•©ë‹ˆë‹¤."""
        # When: í—¬ìŠ¤ì²´í¬ ìš”ì²­
        response = client.get("/health")

        # Then: ì •ìƒ ì‘ë‹µ (ì–´ë–¤ í™˜ê²½ì—ì„œë“ )
        assert response.status_code == 200


# =============================================================================
# ì‹œë‚˜ë¦¬ì˜¤: ìŠ¤íŠ¸ë¦¬ë° ë¬´ê²°ì„± ê²€ì¦
# =============================================================================


class TestStreamingIntegrity:
    """ìŠ¤íŠ¸ë¦¬ë° ë¬´ê²°ì„± í…ŒìŠ¤íŠ¸."""

    def test_first_event_is_stage_parse_start(
        self, client: TestClient, mock_mode_env: None
    ) -> None:
        """[Happy] ì²« ë²ˆì§¸ ì´ë²¤íŠ¸ëŠ” í•­ìƒ stage: parse: startì…ë‹ˆë‹¤ (TTFB)."""
        # Given: ìœ íš¨í•œ í„´ ì…ë ¥
        payload = {
            "language": "ko-KR",
            "text": "í…ŒìŠ¤íŠ¸",
            "client": {"viewport_w": 1920, "viewport_h": 1080},
            "economy_snapshot": {"signal": 100, "memory_shard": 5},
        }

        # When: í„´ ìš”ì²­
        response = client.post("/api/turn", json=payload)
        events = [json.loads(line) for line in response.iter_lines() if line]

        # Then: ì²« ì´ë²¤íŠ¸ í™•ì¸
        assert events[0]["type"] == "stage"
        assert events[0]["name"] == "parse"
        assert events[0]["status"] == "start"

    def test_final_event_is_last(self, client: TestClient, mock_mode_env: None) -> None:
        """[Happy] final ì´ë²¤íŠ¸ê°€ ë§ˆì§€ë§‰ì— ì˜µë‹ˆë‹¤."""
        # Given: ìœ íš¨í•œ í„´ ì…ë ¥
        payload = {
            "language": "ko-KR",
            "text": "í…ŒìŠ¤íŠ¸",
            "client": {"viewport_w": 1920, "viewport_h": 1080},
            "economy_snapshot": {"signal": 100, "memory_shard": 5},
        }

        # When: í„´ ìš”ì²­
        response = client.post("/api/turn", json=payload)
        events = [json.loads(line) for line in response.iter_lines() if line]

        # Then: ë§ˆì§€ë§‰ ì´ë²¤íŠ¸ê°€ final
        assert events[-1]["type"] == "final"

    def test_content_type_is_ndjson(self, client: TestClient, mock_mode_env: None) -> None:
        """[Happy] Content-Typeì´ application/x-ndjsonì…ë‹ˆë‹¤."""
        # Given: ìœ íš¨í•œ í„´ ì…ë ¥
        payload = {
            "language": "ko-KR",
            "text": "í…ŒìŠ¤íŠ¸",
            "client": {"viewport_w": 1920, "viewport_h": 1080},
            "economy_snapshot": {"signal": 100, "memory_shard": 5},
        }

        # When: í„´ ìš”ì²­
        response = client.post("/api/turn", json=payload)

        # Then: ì˜¬ë°”ë¥¸ Content-Type
        assert response.headers["content-type"] == "application/x-ndjson"

    def test_deterministic_with_seed(self, client: TestClient, mock_mode_env: None) -> None:
        """[Happy] seed ì‚¬ìš© ì‹œ ê²°ê³¼ê°€ ê²°ì •ì ì…ë‹ˆë‹¤."""
        # Given: ë™ì¼í•œ ì…ë ¥ê³¼ ì‹œë“œ
        payload = {
            "language": "en-US",
            "text": "Test",
            "client": {"viewport_w": 1920, "viewport_h": 1080},
            "economy_snapshot": {"signal": 100, "memory_shard": 5},
        }
        seed = 42

        # When: ë™ì¼í•œ ì‹œë“œë¡œ ë‘ ë²ˆ ìš”ì²­
        def get_final(s: int) -> dict[str, Any]:
            resp = client.post(f"/api/turn?seed={s}", json=payload)
            events = [json.loads(line) for line in resp.iter_lines() if line]
            return next(e["data"] for e in events if e["type"] == "final")

        output1 = get_final(seed)
        output2 = get_final(seed)

        # Then: ë™ì¼í•œ ê²°ê³¼
        assert output1 == output2
</file>

<file path="backend/tests/integration/test_scanner_api.py">
"""U-021 ì´ë¯¸ì§€ ì´í•´(Scanner) API í†µí•© í…ŒìŠ¤íŠ¸."""

import os

# U-080 ëŒ€ì‘: í…ŒìŠ¤íŠ¸ í™˜ê²½ì—ì„œ Mock ëª¨ë“œ ê°•ì œ (ë‹¤ë¥¸ ì„í¬íŠ¸ë³´ë‹¤ ë¨¼ì € ì‹¤í–‰)
os.environ["UW_MODE"] = "mock"

from fastapi.testclient import TestClient

from unknown_world.main import app
from unknown_world.models.scanner import ScanStatus

client = TestClient(app)


def test_scanner_health():
    """Scanner í—¬ìŠ¤ì²´í¬ ì—”ë“œí¬ì¸íŠ¸ í…ŒìŠ¤íŠ¸."""
    response = client.get("/api/scan/health")
    assert response.status_code == 200
    data = response.json()
    assert data["status"] == "ok"
    assert "mode" in data
    assert "supported_formats" in data


def test_scan_image_mock_ko():
    """ì´ë¯¸ì§€ ìŠ¤ìº” í…ŒìŠ¤íŠ¸ (Mock ëª¨ë“œ, í•œêµ­ì–´)."""
    # í…ŒìŠ¤íŠ¸ìš© ì´ë¯¸ì§€ ë°ì´í„° (100ë°”ì´íŠ¸ ì´ìƒ í•„ìš”)
    file_content = b"fake image content" * 10
    files = {"file": ("test.png", file_content, "image/png")}
    data = {"language": "ko-KR"}

    # UW_MODE=mock í™˜ê²½ì—ì„œ ì‹¤í–‰ëœë‹¤ê³  ê°€ì •
    response = client.post("/api/scan", files=files, data=data)

    assert response.status_code == 200
    res_data = response.json()
    assert res_data["success"] is True
    assert res_data["status"] == ScanStatus.COMPLETED
    assert "[Mock]" in res_data["caption"]
    assert res_data["language"] == "ko-KR"
    assert len(res_data["objects"]) > 0
    assert len(res_data["item_candidates"]) > 0


def test_scan_image_mock_en():
    """ì´ë¯¸ì§€ ìŠ¤ìº” í…ŒìŠ¤íŠ¸ (Mock ëª¨ë“œ, ì˜ì–´)."""
    file_content = b"fake image content" * 10
    files = {"file": ("test.png", file_content, "image/png")}
    data = {"language": "en-US"}

    response = client.post("/api/scan", files=files, data=data)

    assert response.status_code == 200
    res_data = response.json()
    assert res_data["success"] is True
    assert "[Mock]" in res_data["caption"]
    assert res_data["language"] == "en-US"


def test_scan_image_invalid_type():
    """ì§€ì›í•˜ì§€ ì•ŠëŠ” íŒŒì¼ í˜•ì‹ í…ŒìŠ¤íŠ¸."""
    file_content = b"some text"
    files = {"file": ("test.txt", file_content, "text/plain")}

    response = client.post("/api/scan", files=files)

    assert response.status_code == 200  # ì‹¤íŒ¨í•˜ë”ë¼ë„ 200 ì‘ë‹µ + success=False (RULE-004)
    res_data = response.json()
    assert res_data["success"] is False
    assert res_data["status"] == ScanStatus.FAILED
    assert "ì§€ì›í•˜ì§€ ì•ŠëŠ” ì´ë¯¸ì§€ í˜•ì‹" in res_data["message"]


def test_scan_image_too_large():
    """íŒŒì¼ í¬ê¸° ì´ˆê³¼ í…ŒìŠ¤íŠ¸."""
    # 20MB + 1 byte
    large_content = b"a" * (20 * 1024 * 1024 + 1)
    files = {"file": ("large.png", large_content, "image/png")}

    response = client.post("/api/scan", files=files)

    assert response.status_code == 200
    res_data = response.json()
    assert res_data["success"] is False
    assert "íŒŒì¼ì´ ë„ˆë¬´ í½ë‹ˆë‹¤" in res_data["message"]
</file>

<file path="backend/tests/unit/orchestrator/test_mock_orchestrator.py">
"""Unknown World - MockOrchestrator ë‹¨ìœ„ í…ŒìŠ¤íŠ¸.

U-048[Mvp] ì™„ë£Œ ê¸°ì¤€ ê²€ì¦:
    - action_id ì…ë ¥ ì‹œ "ë§í–ˆìŠµë‹ˆë‹¤" ëŒ€ì‹  í–‰ë™ ë¡œê·¸ í”„ë¦¬í”½ìŠ¤ ì ìš©
    - click ì…ë ¥ ì‹œ ì¡°ì‚¬/íƒìƒ‰ í–‰ë™ ë¡œê·¸ í”„ë¦¬í”½ìŠ¤ ì ìš©
    - drop ì…ë ¥ ì‹œ ì‚¬ìš©/ì¡°í•© í–‰ë™ ë¡œê·¸ í”„ë¦¬í”½ìŠ¤ ì ìš©
    - free text ì…ë ¥ ì‹œ ì…ë ¥/ëª…ë ¹ í–‰ë™ ë¡œê·¸ í”„ë¦¬í”½ìŠ¤ ì ìš© (Q1: Option B)
    - per-turn ê²°ì •ì  RNGë¡œ ë‹¤ì–‘ì„± í™•ë³´ (ë‹¤ë¥¸ ì…ë ¥ â†’ ë‹¤ë¥¸ ê²°ê³¼)
    - ë™ì¼ ì…ë ¥ â†’ ë™ì¼ ê²°ê³¼ (ì¬í˜„ì„± ìœ ì§€)

ì°¸ì¡°:
    - vibe/unit-plans/U-048[Mvp].md
    - vibe/unit-runbooks/U-048-mock-narrative-improvement-runbook.md
"""

import random

import pytest

from unknown_world.models.turn import (
    Box2D,
    ClickInput,
    ClientInfo,
    DropInput,
    EconomySnapshot,
    Language,
    Theme,
    TurnInput,
    TurnOutput,
)
from unknown_world.orchestrator.mock import (
    EN_ACTION_LOG_PREFIXES,
    KO_ACTION_LOG_PREFIXES,
    InputType,
    MockOrchestrator,
    _compute_turn_seed,
    _detect_input_type,
    _format_action_log_prefix,
)

# =============================================================================
# í”½ìŠ¤ì²˜
# =============================================================================


@pytest.fixture
def base_client_info() -> ClientInfo:
    """ê¸°ë³¸ í´ë¼ì´ì–¸íŠ¸ ì •ë³´ í”½ìŠ¤ì²˜."""
    return ClientInfo(viewport_w=1920, viewport_h=1080, theme=Theme.DARK)


@pytest.fixture
def base_economy_snapshot() -> EconomySnapshot:
    """ê¸°ë³¸ ê²½ì œ ìŠ¤ëƒ…ìƒ· í”½ìŠ¤ì²˜."""
    return EconomySnapshot(signal=100, memory_shard=5)


@pytest.fixture
def ko_action_input(base_client_info, base_economy_snapshot) -> TurnInput:
    """í•œêµ­ì–´ ì•¡ì…˜ ì¹´ë“œ ì…ë ¥ í”½ìŠ¤ì²˜."""
    return TurnInput(
        language=Language.KO,
        text="ë¬¸ì„ ì—´ì–´ë³¸ë‹¤",
        action_id="action_1",
        client=base_client_info,
        economy_snapshot=base_economy_snapshot,
    )


@pytest.fixture
def ko_click_input(base_client_info, base_economy_snapshot) -> TurnInput:
    """í•œêµ­ì–´ í´ë¦­ ì…ë ¥ í”½ìŠ¤ì²˜."""
    return TurnInput(
        language=Language.KO,
        click=ClickInput(object_id="obj_door"),
        client=base_client_info,
        economy_snapshot=base_economy_snapshot,
    )


@pytest.fixture
def ko_drop_input(base_client_info, base_economy_snapshot) -> TurnInput:
    """í•œêµ­ì–´ ë“œë¡­ ì…ë ¥ í”½ìŠ¤ì²˜."""
    return TurnInput(
        language=Language.KO,
        drop=DropInput(
            item_id="key_001",
            target_object_id="obj_lock",
            target_box_2d=Box2D(ymin=100, xmin=200, ymax=300, xmax=400),
        ),
        client=base_client_info,
        economy_snapshot=base_economy_snapshot,
    )


@pytest.fixture
def ko_free_text_input(base_client_info, base_economy_snapshot) -> TurnInput:
    """í•œêµ­ì–´ ììœ  í…ìŠ¤íŠ¸ ì…ë ¥ í”½ìŠ¤ì²˜."""
    return TurnInput(
        language=Language.KO,
        text="ì£¼ë³€ì„ ì‚´í´ë³¸ë‹¤",
        client=base_client_info,
        economy_snapshot=base_economy_snapshot,
    )


@pytest.fixture
def en_action_input(base_client_info, base_economy_snapshot) -> TurnInput:
    """ì˜ì–´ ì•¡ì…˜ ì¹´ë“œ ì…ë ¥ í”½ìŠ¤ì²˜."""
    return TurnInput(
        language=Language.EN,
        text="Open the door",
        action_id="action_1",
        client=base_client_info,
        economy_snapshot=base_economy_snapshot,
    )


# =============================================================================
# _detect_input_type í…ŒìŠ¤íŠ¸
# =============================================================================


class TestDetectInputType:
    """ì…ë ¥ íƒ€ì… ê°ì§€ í•¨ìˆ˜ í…ŒìŠ¤íŠ¸."""

    def test_detect_drop_input(self, ko_drop_input):
        """drop ì…ë ¥ ê°ì§€ í…ŒìŠ¤íŠ¸ (ìµœê³  ìš°ì„ ìˆœìœ„)."""
        result = _detect_input_type(ko_drop_input)
        assert result == InputType.DROP

    def test_detect_click_input(self, ko_click_input):
        """click ì…ë ¥ ê°ì§€ í…ŒìŠ¤íŠ¸."""
        result = _detect_input_type(ko_click_input)
        assert result == InputType.CLICK

    def test_detect_action_input(self, ko_action_input):
        """action_id ì…ë ¥ ê°ì§€ í…ŒìŠ¤íŠ¸."""
        result = _detect_input_type(ko_action_input)
        assert result == InputType.ACTION

    def test_detect_free_text_input(self, ko_free_text_input):
        """free text ì…ë ¥ ê°ì§€ í…ŒìŠ¤íŠ¸."""
        result = _detect_input_type(ko_free_text_input)
        assert result == InputType.FREE_TEXT

    def test_priority_drop_over_click(self, base_client_info, base_economy_snapshot):
        """dropì´ clickë³´ë‹¤ ìš°ì„ ìˆœìœ„ê°€ ë†’ì€ì§€ í…ŒìŠ¤íŠ¸."""
        turn_input = TurnInput(
            language=Language.KO,
            drop=DropInput(
                item_id="key_001",
                target_object_id="obj_lock",
                target_box_2d=Box2D(ymin=100, xmin=200, ymax=300, xmax=400),
            ),
            click=ClickInput(object_id="obj_door"),
            client=base_client_info,
            economy_snapshot=base_economy_snapshot,
        )
        result = _detect_input_type(turn_input)
        assert result == InputType.DROP

    def test_priority_click_over_action(self, base_client_info, base_economy_snapshot):
        """clickì´ action_idë³´ë‹¤ ìš°ì„ ìˆœìœ„ê°€ ë†’ì€ì§€ í…ŒìŠ¤íŠ¸."""
        turn_input = TurnInput(
            language=Language.KO,
            click=ClickInput(object_id="obj_door"),
            action_id="action_1",
            text="ë¬¸ì„ ì—´ì–´ë³¸ë‹¤",
            client=base_client_info,
            economy_snapshot=base_economy_snapshot,
        )
        result = _detect_input_type(turn_input)
        assert result == InputType.CLICK

    def test_priority_action_over_free_text(self, ko_action_input):
        """action_idê°€ free textë³´ë‹¤ ìš°ì„ ìˆœìœ„ê°€ ë†’ì€ì§€ í…ŒìŠ¤íŠ¸."""
        # ko_action_inputì€ action_idì™€ text ë‘˜ ë‹¤ ìˆìŒ
        result = _detect_input_type(ko_action_input)
        assert result == InputType.ACTION


# =============================================================================
# _compute_turn_seed í…ŒìŠ¤íŠ¸
# =============================================================================


class TestComputeTurnSeed:
    """per-turn ì‹œë“œ ê³„ì‚° í•¨ìˆ˜ í…ŒìŠ¤íŠ¸."""

    def test_same_input_same_seed(self, ko_action_input):
        """ë™ì¼ ì…ë ¥ â†’ ë™ì¼ ì‹œë“œ (ì¬í˜„ì„±)."""
        base_seed = 42
        seed1 = _compute_turn_seed(base_seed, ko_action_input)
        seed2 = _compute_turn_seed(base_seed, ko_action_input)
        assert seed1 == seed2

    def test_different_text_different_seed(self, base_client_info, base_economy_snapshot):
        """ë‹¤ë¥¸ í…ìŠ¤íŠ¸ â†’ ë‹¤ë¥¸ ì‹œë“œ (ë‹¤ì–‘ì„±)."""
        base_seed = 42
        input1 = TurnInput(
            language=Language.KO,
            text="ë¬¸ì„ ì—´ì–´ë³¸ë‹¤",
            client=base_client_info,
            economy_snapshot=base_economy_snapshot,
        )
        input2 = TurnInput(
            language=Language.KO,
            text="ì£¼ë³€ì„ íƒìƒ‰í•œë‹¤",
            client=base_client_info,
            economy_snapshot=base_economy_snapshot,
        )
        seed1 = _compute_turn_seed(base_seed, input1)
        seed2 = _compute_turn_seed(base_seed, input2)
        assert seed1 != seed2

    def test_different_action_id_different_seed(self, base_client_info, base_economy_snapshot):
        """ë‹¤ë¥¸ action_id â†’ ë‹¤ë¥¸ ì‹œë“œ."""
        base_seed = 42
        input1 = TurnInput(
            language=Language.KO,
            action_id="action_1",
            client=base_client_info,
            economy_snapshot=base_economy_snapshot,
        )
        input2 = TurnInput(
            language=Language.KO,
            action_id="action_2",
            client=base_client_info,
            economy_snapshot=base_economy_snapshot,
        )
        seed1 = _compute_turn_seed(base_seed, input1)
        seed2 = _compute_turn_seed(base_seed, input2)
        assert seed1 != seed2

    def test_different_click_object_different_seed(self, base_client_info, base_economy_snapshot):
        """ë‹¤ë¥¸ í´ë¦­ ì˜¤ë¸Œì íŠ¸ â†’ ë‹¤ë¥¸ ì‹œë“œ."""
        base_seed = 42
        input1 = TurnInput(
            language=Language.KO,
            click=ClickInput(object_id="obj_door"),
            client=base_client_info,
            economy_snapshot=base_economy_snapshot,
        )
        input2 = TurnInput(
            language=Language.KO,
            click=ClickInput(object_id="obj_chest"),
            client=base_client_info,
            economy_snapshot=base_economy_snapshot,
        )
        seed1 = _compute_turn_seed(base_seed, input1)
        seed2 = _compute_turn_seed(base_seed, input2)
        assert seed1 != seed2

    def test_different_drop_different_seed(self, base_client_info, base_economy_snapshot):
        """ë‹¤ë¥¸ ë“œë¡­ ì •ë³´ â†’ ë‹¤ë¥¸ ì‹œë“œ."""
        base_seed = 42
        input1 = TurnInput(
            language=Language.KO,
            drop=DropInput(
                item_id="key_001",
                target_object_id="obj_lock",
                target_box_2d=Box2D(ymin=100, xmin=200, ymax=300, xmax=400),
            ),
            client=base_client_info,
            economy_snapshot=base_economy_snapshot,
        )
        input2 = TurnInput(
            language=Language.KO,
            drop=DropInput(
                item_id="sword_001",
                target_object_id="obj_enemy",
                target_box_2d=Box2D(ymin=100, xmin=200, ymax=300, xmax=400),
            ),
            client=base_client_info,
            economy_snapshot=base_economy_snapshot,
        )
        seed1 = _compute_turn_seed(base_seed, input1)
        seed2 = _compute_turn_seed(base_seed, input2)
        assert seed1 != seed2

    def test_seed_within_valid_range(self, ko_action_input):
        """ì‹œë“œê°€ ìœ íš¨í•œ ë²”ìœ„ ë‚´ì¸ì§€ í…ŒìŠ¤íŠ¸."""
        base_seed = 42
        seed = _compute_turn_seed(base_seed, ko_action_input)
        assert 0 <= seed < 2**32


# =============================================================================
# _format_action_log_prefix í…ŒìŠ¤íŠ¸
# =============================================================================


class TestFormatActionLogPrefix:
    """í–‰ë™ ë¡œê·¸ í”„ë¦¬í”½ìŠ¤ í¬ë§· í•¨ìˆ˜ í…ŒìŠ¤íŠ¸."""

    def test_ko_action_prefix(self, ko_action_input):
        """í•œêµ­ì–´ ì•¡ì…˜ í”„ë¦¬í”½ìŠ¤ í…ŒìŠ¤íŠ¸."""
        rng = random.Random(42)
        prefix = _format_action_log_prefix(rng, InputType.ACTION, ko_action_input, is_korean=True)

        # í•œêµ­ì–´ ì•¡ì…˜ í”„ë¦¬í”½ìŠ¤ ì¤‘ í•˜ë‚˜ì—¬ì•¼ í•¨
        expected_patterns = ["[í–‰ë™]", "[ì‹¤í–‰]", "[ì‹œë„]"]
        assert any(pattern in prefix for pattern in expected_patterns)

    def test_ko_click_prefix(self, ko_click_input):
        """í•œêµ­ì–´ í´ë¦­ í”„ë¦¬í”½ìŠ¤ í…ŒìŠ¤íŠ¸."""
        rng = random.Random(42)
        prefix = _format_action_log_prefix(rng, InputType.CLICK, ko_click_input, is_korean=True)

        expected_patterns = ["[ì¡°ì‚¬]", "[íƒìƒ‰]", "[ìƒí˜¸ì‘ìš©]"]
        assert any(pattern in prefix for pattern in expected_patterns)
        # ì˜¤ë¸Œì íŠ¸ IDëŠ” ì—¬ì „íˆ í¬í•¨ë˜ì–´ì•¼ í•¨ (ì‹œìŠ¤í…œ ìƒì„± IDì´ë¯€ë¡œ ì–¸ì–´ í˜¼í•© ìœ„í—˜ ì—†ìŒ)
        assert "obj_door" in prefix

    def test_ko_drop_prefix(self, ko_drop_input):
        """í•œêµ­ì–´ ë“œë¡­ í”„ë¦¬í”½ìŠ¤ í…ŒìŠ¤íŠ¸."""
        rng = random.Random(42)
        prefix = _format_action_log_prefix(rng, InputType.DROP, ko_drop_input, is_korean=True)

        expected_patterns = ["[ì‚¬ìš©]", "[ì¡°í•©]", "[ì ìš©]"]
        assert any(pattern in prefix for pattern in expected_patterns)
        # ì•„ì´í…œ IDì™€ ëŒ€ìƒ IDëŠ” í¬í•¨ë˜ì–´ì•¼ í•¨
        assert "key_001" in prefix
        assert "obj_lock" in prefix

    def test_ko_free_text_prefix(self, ko_free_text_input):
        """í•œêµ­ì–´ ììœ  í…ìŠ¤íŠ¸ í”„ë¦¬í”½ìŠ¤ í…ŒìŠ¤íŠ¸."""
        rng = random.Random(42)
        prefix = _format_action_log_prefix(
            rng, InputType.FREE_TEXT, ko_free_text_input, is_korean=True
        )

        # U-062: [ì…ë ¥] ëŒ€ì‹  [í–‰ë™], [ì‹œë„], [íƒìƒ‰] ì‚¬ìš©
        expected_patterns = ["[í–‰ë™]", "[ì‹œë„]", "[íƒìƒ‰]"]
        assert any(pattern in prefix for pattern in expected_patterns)

    def test_en_action_prefix(self, en_action_input):
        """ì˜ì–´ ì•¡ì…˜ í”„ë¦¬í”½ìŠ¤ í…ŒìŠ¤íŠ¸."""
        rng = random.Random(42)
        prefix = _format_action_log_prefix(rng, InputType.ACTION, en_action_input, is_korean=False)

        expected_patterns = ["[ACTION]", "[EXECUTE]", "[ATTEMPT]"]
        assert any(pattern in prefix for pattern in expected_patterns)

    def test_deterministic_with_same_rng_state(self, ko_action_input):
        """ë™ì¼ RNG ìƒíƒœì—ì„œ ê²°ì •ì  ê²°ê³¼ í…ŒìŠ¤íŠ¸."""
        prefix1 = _format_action_log_prefix(
            random.Random(42), InputType.ACTION, ko_action_input, is_korean=True
        )
        prefix2 = _format_action_log_prefix(
            random.Random(42), InputType.ACTION, ko_action_input, is_korean=True
        )
        assert prefix1 == prefix2


# =============================================================================
# MockOrchestrator í†µí•© í…ŒìŠ¤íŠ¸
# =============================================================================


class TestMockOrchestratorNarrativePrefix:
    """MockOrchestrator ë‚´ëŸ¬í‹°ë¸Œ í”„ë¦¬í”½ìŠ¤ í†µí•© í…ŒìŠ¤íŠ¸."""

    def test_action_input_no_said_ko(self, ko_action_input):
        """í•œêµ­ì–´ ì•¡ì…˜ ì…ë ¥ ì‹œ 'ë§í–ˆìŠµë‹ˆë‹¤' ì—†ìŒ í…ŒìŠ¤íŠ¸."""
        orchestrator = MockOrchestrator(seed=42)
        output = orchestrator.generate_turn_output(ko_action_input)

        assert isinstance(output, TurnOutput)
        assert "ë§í–ˆìŠµë‹ˆë‹¤" not in output.narrative
        assert "ë¼ê³  ë§í–ˆìŠµë‹ˆë‹¤" not in output.narrative

        # í–‰ë™ ë¡œê·¸ í”„ë¦¬í”½ìŠ¤ê°€ ìˆì–´ì•¼ í•¨
        expected_prefixes = ["[í–‰ë™]", "[ì‹¤í–‰]", "[ì‹œë„]"]
        assert any(prefix in output.narrative for prefix in expected_prefixes)

    def test_click_input_no_said_ko(self, ko_click_input):
        """í•œêµ­ì–´ í´ë¦­ ì…ë ¥ ì‹œ 'ë§í–ˆìŠµë‹ˆë‹¤' ì—†ìŒ í…ŒìŠ¤íŠ¸."""
        orchestrator = MockOrchestrator(seed=42)
        output = orchestrator.generate_turn_output(ko_click_input)

        assert "ë§í–ˆìŠµë‹ˆë‹¤" not in output.narrative

        expected_prefixes = ["[ì¡°ì‚¬]", "[íƒìƒ‰]", "[ìƒí˜¸ì‘ìš©]"]
        assert any(prefix in output.narrative for prefix in expected_prefixes)
        # ì˜¤ë¸Œì íŠ¸ ID í¬í•¨ í™•ì¸
        assert "obj_door" in output.narrative

    def test_drop_input_no_said_ko(self, ko_drop_input):
        """í•œêµ­ì–´ ë“œë¡­ ì…ë ¥ ì‹œ 'ë§í–ˆìŠµë‹ˆë‹¤' ì—†ìŒ í…ŒìŠ¤íŠ¸."""
        orchestrator = MockOrchestrator(seed=42)
        output = orchestrator.generate_turn_output(ko_drop_input)

        assert "ë§í–ˆìŠµë‹ˆë‹¤" not in output.narrative

        expected_prefixes = ["[ì‚¬ìš©]", "[ì¡°í•©]", "[ì ìš©]"]
        assert any(prefix in output.narrative for prefix in expected_prefixes)
        # ì•„ì´í…œ ë° ëŒ€ìƒ ID í¬í•¨ í™•ì¸
        assert "key_001" in output.narrative
        assert "obj_lock" in output.narrative

    def test_free_text_input_no_said_ko(self, ko_free_text_input):
        """í•œêµ­ì–´ ììœ  í…ìŠ¤íŠ¸ ì…ë ¥ ì‹œ 'ë§í–ˆìŠµë‹ˆë‹¤' ì—†ìŒ í…ŒìŠ¤íŠ¸."""
        orchestrator = MockOrchestrator(seed=42)
        output = orchestrator.generate_turn_output(ko_free_text_input)

        assert "ë§í–ˆìŠµë‹ˆë‹¤" not in output.narrative

        # U-062: [í–‰ë™], [ì‹œë„], [íƒìƒ‰] ì¤‘ í•˜ë‚˜ì—¬ì•¼ í•¨
        expected_prefixes = ["[í–‰ë™]", "[ì‹œë„]", "[íƒìƒ‰]"]
        assert any(prefix in output.narrative for prefix in expected_prefixes)

    def test_action_input_no_said_en(self, en_action_input):
        """ì˜ì–´ ì•¡ì…˜ ì…ë ¥ ì‹œ 'You said' ì—†ìŒ í…ŒìŠ¤íŠ¸."""
        orchestrator = MockOrchestrator(seed=42)
        output = orchestrator.generate_turn_output(en_action_input)

        assert "You said" not in output.narrative
        assert "said" not in output.narrative.lower() or "[" in output.narrative[:10]

        expected_prefixes = ["[ACTION]", "[EXECUTE]", "[ATTEMPT]"]
        assert any(prefix in output.narrative for prefix in expected_prefixes)

    def test_empty_text_no_prefix(self, base_client_info, base_economy_snapshot):
        """ì˜ë¯¸ ì—†ëŠ” ì…ë ¥ ì‹œ í”„ë¦¬í”½ìŠ¤ ì—†ìŒ í…ŒìŠ¤íŠ¸."""
        turn_input = TurnInput(
            language=Language.KO,
            text="",  # ë¹ˆ í…ìŠ¤íŠ¸
            client=base_client_info,
            economy_snapshot=base_economy_snapshot,
        )

        orchestrator = MockOrchestrator(seed=42)
        output = orchestrator.generate_turn_output(turn_input)

        # ë¹ˆ ì…ë ¥ì´ë¯€ë¡œ í”„ë¦¬í”½ìŠ¤ê°€ ì—†ì–´ì•¼ í•¨
        assert not output.narrative.startswith("[")

    def test_english_input_korean_session_passes_language_gate(
        self, base_client_info, base_economy_snapshot
    ):
        """U-062: ì˜ì–´ ì…ë ¥ ì‹œì—ë„ í•œêµ­ì–´ ì„¸ì…˜ì—ì„œ LanguageGateë¥¼ í†µê³¼í•˜ëŠ”ì§€ í…ŒìŠ¤íŠ¸."""
        from unknown_world.validation.language_gate import validate_language_consistency

        turn_input = TurnInput(
            language=Language.KO,
            text="English instruction for a Korean session",
            client=base_client_info,
            economy_snapshot=base_economy_snapshot,
        )

        orchestrator = MockOrchestrator(seed=42)
        output = orchestrator.generate_turn_output(turn_input)

        # 1. ë‚´ëŸ¬í‹°ë¸Œì— ì˜ì–´ ì…ë ¥ì´ í¬í•¨ë˜ì§€ ì•Šì•„ì•¼ í•¨
        assert "English instruction" not in output.narrative

        # 2. LanguageGate ê²€ì¦ í†µê³¼í•´ì•¼ í•¨
        result = validate_language_consistency(output, Language.KO)
        assert result.is_valid is True, f"LanguageGate failed: {result.violations}"

    def test_korean_input_english_session_passes_language_gate(
        self, base_client_info, base_economy_snapshot
    ):
        """U-062: í•œêµ­ì–´ ì…ë ¥ ì‹œì—ë„ ì˜ì–´ ì„¸ì…˜ì—ì„œ LanguageGateë¥¼ í†µê³¼í•˜ëŠ”ì§€ í…ŒìŠ¤íŠ¸."""
        from unknown_world.validation.language_gate import validate_language_consistency

        turn_input = TurnInput(
            language=Language.EN,
            text="ì˜ì–´ ì„¸ì…˜ì— ë“¤ì–´ì˜¨ í•œêµ­ì–´ ëª…ë ¹",
            client=base_client_info,
            economy_snapshot=base_economy_snapshot,
        )

        orchestrator = MockOrchestrator(seed=42)
        output = orchestrator.generate_turn_output(turn_input)

        # 1. ë‚´ëŸ¬í‹°ë¸Œì— í•œêµ­ì–´ ì…ë ¥ì´ í¬í•¨ë˜ì§€ ì•Šì•„ì•¼ í•¨
        assert "í•œêµ­ì–´ ëª…ë ¹" not in output.narrative

        # 2. LanguageGate ê²€ì¦ í†µê³¼í•´ì•¼ í•¨
        result = validate_language_consistency(output, Language.EN)
        assert result.is_valid is True, f"LanguageGate failed: {result.violations}"


# =============================================================================
# ê²°ì •ì  ë‹¤ì–‘ì„± í…ŒìŠ¤íŠ¸
# =============================================================================


class TestDeterministicDiversity:
    """ê²°ì •ì  ë‹¤ì–‘ì„± í…ŒìŠ¤íŠ¸."""

    def test_same_input_same_output(self, ko_action_input):
        """ë™ì¼ ì…ë ¥ â†’ ë™ì¼ ì¶œë ¥ (ì¬í˜„ì„±)."""
        orchestrator1 = MockOrchestrator(seed=42)
        orchestrator2 = MockOrchestrator(seed=42)

        output1 = orchestrator1.generate_turn_output(ko_action_input)
        output2 = orchestrator2.generate_turn_output(ko_action_input)

        assert output1.narrative == output2.narrative
        assert len(output1.ui.action_deck.cards) == len(output2.ui.action_deck.cards)

    def test_different_input_different_output(self, base_client_info, base_economy_snapshot):
        """ë‹¤ë¥¸ ì…ë ¥ â†’ ë‹¤ë¥¸ ì¶œë ¥ (ë‹¤ì–‘ì„±)."""
        input1 = TurnInput(
            language=Language.KO,
            text="ë¬¸ì„ ì—´ì–´ë³¸ë‹¤",
            client=base_client_info,
            economy_snapshot=base_economy_snapshot,
        )
        input2 = TurnInput(
            language=Language.KO,
            text="ì£¼ë³€ì„ íƒìƒ‰í•œë‹¤",
            client=base_client_info,
            economy_snapshot=base_economy_snapshot,
        )

        # ê°™ì€ seedì˜ ì˜¤ì¼€ìŠ¤íŠ¸ë ˆì´í„° ì‚¬ìš©
        orchestrator = MockOrchestrator(seed=42)

        output1 = orchestrator.generate_turn_output(input1)
        output2 = orchestrator.generate_turn_output(input2)

        # per-turn RNGì´ë¯€ë¡œ ë‹¤ë¥¸ ë‚´ëŸ¬í‹°ë¸Œê°€ ë‚˜ì™€ì•¼ í•¨
        # (í”„ë¦¬í”½ìŠ¤ëŠ” ê°™ì„ ìˆ˜ ìˆì§€ë§Œ ë³¸ë¬¸ì´ ë‹¬ë¼ì§ˆ í™•ë¥ ì´ ë†’ìŒ)
        assert output1.narrative != output2.narrative

    def test_multiple_calls_deterministic(self, ko_action_input):
        """ì—¬ëŸ¬ ë²ˆ í˜¸ì¶œí•´ë„ ê°™ì€ ê²°ê³¼ (ë™ì¼ ì…ë ¥ì— ëŒ€í•´)."""
        orchestrator = MockOrchestrator(seed=42)

        outputs = [orchestrator.generate_turn_output(ko_action_input) for _ in range(3)]

        # ëª¨ë“  ì¶œë ¥ì´ ë™ì¼í•´ì•¼ í•¨
        for i in range(1, len(outputs)):
            assert outputs[0].narrative == outputs[i].narrative


# =============================================================================
# ìŠ¤í‚¤ë§ˆ/ì¸ë°”ë¦¬ì–¸íŠ¸ í…ŒìŠ¤íŠ¸
# =============================================================================


class TestSchemaAndInvariants:
    """ìŠ¤í‚¤ë§ˆ ë° ì¸ë°”ë¦¬ì–¸íŠ¸ í…ŒìŠ¤íŠ¸."""

    def test_output_is_valid_turn_output(self, ko_action_input):
        """ì¶œë ¥ì´ ìœ íš¨í•œ TurnOutputì¸ì§€ í…ŒìŠ¤íŠ¸."""
        orchestrator = MockOrchestrator(seed=42)
        output = orchestrator.generate_turn_output(ko_action_input)

        assert isinstance(output, TurnOutput)
        assert output.language == Language.KO
        assert output.narrative is not None
        assert output.economy is not None
        assert output.safety is not None

    def test_economy_invariant_no_negative_balance(self, base_client_info):
        """ê²½ì œ ì¸ë°”ë¦¬ì–¸íŠ¸: ì”ì•¡ ìŒìˆ˜ ê¸ˆì§€ (RULE-005)."""
        # ì”ì•¡ì´ ë§¤ìš° ì ì€ ê²½ìš°
        economy_snapshot = EconomySnapshot(signal=1, memory_shard=0)
        turn_input = TurnInput(
            language=Language.KO,
            text="ë¹„ì‹¼ í–‰ë™",
            client=base_client_info,
            economy_snapshot=economy_snapshot,
        )

        orchestrator = MockOrchestrator(seed=42)
        output = orchestrator.generate_turn_output(turn_input)

        # ì”ì•¡ì€ 0 ì´ìƒì´ì–´ì•¼ í•¨
        assert output.economy.balance_after.signal >= 0
        assert output.economy.balance_after.memory_shard >= 0

    def test_coordinate_invariant_0_to_1000(self, ko_action_input):
        """ì¢Œí‘œ ì¸ë°”ë¦¬ì–¸íŠ¸: 0~1000 ë²”ìœ„ (RULE-009)."""
        orchestrator = MockOrchestrator(seed=42)
        output = orchestrator.generate_turn_output(ko_action_input)

        for obj in output.ui.objects:
            assert 0 <= obj.box_2d.ymin <= 1000
            assert 0 <= obj.box_2d.xmin <= 1000
            assert 0 <= obj.box_2d.ymax <= 1000
            assert 0 <= obj.box_2d.xmax <= 1000
            # ymin < ymax, xmin < xmax
            assert obj.box_2d.ymin < obj.box_2d.ymax
            assert obj.box_2d.xmin < obj.box_2d.xmax

    def test_language_consistency(self, ko_action_input, en_action_input):
        """ì–¸ì–´ ì¼ê´€ì„± í…ŒìŠ¤íŠ¸ (RULE-006)."""
        orchestrator = MockOrchestrator(seed=42)

        ko_output = orchestrator.generate_turn_output(ko_action_input)
        en_output = orchestrator.generate_turn_output(en_action_input)

        assert ko_output.language == Language.KO
        assert en_output.language == Language.EN


# =============================================================================
# í…œí”Œë¦¿ ìƒìˆ˜ í…ŒìŠ¤íŠ¸
# =============================================================================


class TestTemplateConstants:
    """í…œí”Œë¦¿ ìƒìˆ˜ ê²€ì¦ í…ŒìŠ¤íŠ¸."""

    def test_ko_prefixes_have_all_input_types(self):
        """í•œêµ­ì–´ í”„ë¦¬í”½ìŠ¤ì— ëª¨ë“  ì…ë ¥ íƒ€ì…ì´ ìˆëŠ”ì§€ í…ŒìŠ¤íŠ¸."""
        for input_type in InputType:
            assert input_type in KO_ACTION_LOG_PREFIXES
            assert len(KO_ACTION_LOG_PREFIXES[input_type]) >= 1

    def test_en_prefixes_have_all_input_types(self):
        """ì˜ì–´ í”„ë¦¬í”½ìŠ¤ì— ëª¨ë“  ì…ë ¥ íƒ€ì…ì´ ìˆëŠ”ì§€ í…ŒìŠ¤íŠ¸."""
        for input_type in InputType:
            assert input_type in EN_ACTION_LOG_PREFIXES
            assert len(EN_ACTION_LOG_PREFIXES[input_type]) >= 1

    def test_ko_prefixes_no_said(self):
        """í•œêµ­ì–´ í”„ë¦¬í”½ìŠ¤ì— 'ë§í–ˆìŠµë‹ˆë‹¤'ê°€ ì—†ëŠ”ì§€ í…ŒìŠ¤íŠ¸."""
        for _input_type, templates in KO_ACTION_LOG_PREFIXES.items():
            for template in templates:
                assert "ë§í–ˆìŠµë‹ˆë‹¤" not in template

    def test_en_prefixes_no_said(self):
        """ì˜ì–´ í”„ë¦¬í”½ìŠ¤ì— 'said'ê°€ ì—†ëŠ”ì§€ í…ŒìŠ¤íŠ¸."""
        for _input_type, templates in EN_ACTION_LOG_PREFIXES.items():
            for template in templates:
                assert "said" not in template.lower()
</file>

<file path="backend/tests/unit/orchestrator/test_prompt_loader.py">
"""Unit tests for prompt_loader.py.

U-036: í”„ë¡¬í”„íŠ¸ ë¡œë” í•«ë¦¬ë¡œë“œ í…ŒìŠ¤íŠ¸
U-046: XML íƒœê·¸ íŒŒì‹± + ë ˆê±°ì‹œ í´ë°± í…ŒìŠ¤íŠ¸
"""

from __future__ import annotations

import os
import unittest

from unknown_world.models.turn import Language
from unknown_world.orchestrator.prompt_loader import (
    _parse_frontmatter,
    _parse_legacy_frontmatter,
    _parse_xml_meta,
    clear_prompt_cache,
    is_hot_reload_enabled,
    load_prompt,
    load_prompt_with_metadata,
)


class TestPromptLoader(unittest.TestCase):
    def setUp(self) -> None:
        # Clear cache before each test
        clear_prompt_cache()
        # Backup environment
        self._old_env = os.environ.get("ENVIRONMENT")

    def tearDown(self) -> None:
        # Restore environment
        if self._old_env is None:
            if "ENVIRONMENT" in os.environ:
                del os.environ["ENVIRONMENT"]
        else:
            os.environ["ENVIRONMENT"] = self._old_env
        # Clear cache
        clear_prompt_cache()

    def test_load_prompt_ko(self) -> None:
        """Verify loading Korean prompt."""
        # This assumes the file exists in backend/prompts/system/game_master.ko.md
        prompt = load_prompt("system", "game_master", Language.KO)
        self.assertGreater(len(prompt), 0)
        self.assertIn("#", prompt)  # Should be markdown

    def test_load_prompt_en(self) -> None:
        """Verify loading English prompt."""
        prompt = load_prompt("system", "game_master", Language.EN)
        self.assertGreater(len(prompt), 0)

    def test_load_with_metadata(self) -> None:
        """Verify frontmatter parsing."""
        data = load_prompt_with_metadata("system", "game_master", Language.KO)
        self.assertIsNotNone(data.content)
        self.assertIsInstance(data.metadata, dict)
        # Check for typical metadata fields if they exist in the file
        if "prompt_id" in data.metadata:
            self.assertGreater(len(data.metadata["prompt_id"]), 0)

    def test_hot_reload_development(self) -> None:
        """Verify hot-reload works in development mode."""
        os.environ["ENVIRONMENT"] = "development"
        self.assertTrue(is_hot_reload_enabled())

        # Use a temporary file to test hot-reload
        test_category = "system"
        test_name = "test_hot_reload"
        test_lang = Language.KO

        # Determine prompt path
        # In prompt_loader.py, _PROMPTS_ROOT is Path(__file__).parent.parent.parent.parent / "prompts"
        # Since we are in tests/unit/orchestrator/, we need to find the prompts root.
        # But let's mock _get_prompt_path or just use an existing one if possible.
        # Actually, creating a real file is better for verifying "hot-reload" of file system.

        from unknown_world.orchestrator.prompt_loader import _PROMPTS_ROOT

        test_dir = _PROMPTS_ROOT / test_category
        test_dir.mkdir(parents=True, exist_ok=True)
        test_file = test_dir / f"{test_name}.ko.md"

        try:
            # Initial content
            test_file.write_text("# Test\n\nContent 1", encoding="utf-8")

            p1 = load_prompt(test_category, test_name, test_lang)
            self.assertIn("Content 1", p1)

            # Modify file
            test_file.write_text("# Test\n\nContent 2", encoding="utf-8")

            # Load again - should be updated in dev mode
            p2 = load_prompt(test_category, test_name, test_lang)
            self.assertIn("Content 2", p2)
            self.assertNotEqual(p1, p2)

        finally:
            if test_file.exists():
                test_file.unlink()

    def test_caching_production(self) -> None:
        """Verify caching works in production mode (no hot-reload)."""
        os.environ["ENVIRONMENT"] = "production"
        self.assertFalse(is_hot_reload_enabled())

        test_category = "system"
        test_name = "test_caching"
        test_lang = Language.KO

        from unknown_world.orchestrator.prompt_loader import _PROMPTS_ROOT

        test_dir = _PROMPTS_ROOT / test_category
        test_dir.mkdir(parents=True, exist_ok=True)
        test_file = test_dir / f"{test_name}.ko.md"

        try:
            # Initial content
            test_file.write_text("# Test\n\nInitial", encoding="utf-8")

            p1 = load_prompt(test_category, test_name, test_lang)
            self.assertIn("Initial", p1)

            # Modify file
            test_file.write_text("# Test\n\nModified", encoding="utf-8")

            # Load again - should STILL be Initial because of caching
            p2 = load_prompt(test_category, test_name, test_lang)
            self.assertEqual(p1, p2)
            self.assertIn("Initial", p2)

            # After clearing cache, it should be updated
            clear_prompt_cache()
            p3 = load_prompt(test_category, test_name, test_lang)
            self.assertIn("Modified", p3)

        finally:
            if test_file.exists():
                test_file.unlink()

    def test_fallback_language(self) -> None:
        """Verify fallback to other language if requested file is missing."""
        # Create ONLY English version
        test_category = "system"
        test_name = "test_fallback"

        from unknown_world.orchestrator.prompt_loader import _PROMPTS_ROOT

        test_dir = _PROMPTS_ROOT / test_category
        test_dir.mkdir(parents=True, exist_ok=True)
        en_file = test_dir / f"{test_name}.en.md"
        ko_file = test_dir / f"{test_name}.ko.md"

        try:
            en_file.write_text("# English Content", encoding="utf-8")
            if ko_file.exists():
                ko_file.unlink()

            # Request KO, should get EN
            prompt = load_prompt(test_category, test_name, Language.KO)
            self.assertIn("English Content", prompt)

        finally:
            if en_file.exists():
                en_file.unlink()


class TestXmlParsing(unittest.TestCase):
    """U-046: XML íƒœê·¸ íŒŒì‹± í…ŒìŠ¤íŠ¸."""

    def test_parse_xml_meta_valid(self) -> None:
        """Valid XML meta tags should be parsed correctly."""
        text = """<prompt_meta>
  <prompt_id>test_prompt</prompt_id>
  <language>ko-KR</language>
  <version>0.2.0</version>
  <last_updated>2026-01-28</last_updated>
  <policy_preset>default</policy_preset>
</prompt_meta>

<prompt_body>
## ëª©ì 
í…ŒìŠ¤íŠ¸ í”„ë¡¬í”„íŠ¸ì…ë‹ˆë‹¤.

## ë‚´ìš©
ë³¸ë¬¸ ë‚´ìš©ì´ ì—¬ê¸°ì— ë“¤ì–´ê°‘ë‹ˆë‹¤.
</prompt_body>
"""
        result = _parse_xml_meta(text)
        self.assertIsNotNone(result)
        metadata, content = result  # type: ignore

        # ë©”íƒ€ë°ì´í„° ê²€ì¦
        self.assertEqual(metadata["prompt_id"], "test_prompt")
        self.assertEqual(metadata["language"], "ko-KR")
        self.assertEqual(metadata["version"], "0.2.0")
        self.assertEqual(metadata["last_updated"], "2026-01-28")
        self.assertEqual(metadata["policy_preset"], "default")

        # ë³¸ë¬¸ ê²€ì¦ (ë©”íƒ€ ë¸”ë¡ ì œì™¸)
        self.assertIn("## ëª©ì ", content)
        self.assertIn("í…ŒìŠ¤íŠ¸ í”„ë¡¬í”„íŠ¸ì…ë‹ˆë‹¤.", content)
        self.assertNotIn("<prompt_meta>", content)
        self.assertNotIn("<prompt_body>", content)

    def test_parse_xml_meta_no_body_tag(self) -> None:
        """XML meta without body tag should use remaining text as content."""
        text = """<prompt_meta>
  <prompt_id>test</prompt_id>
  <version>0.1.0</version>
</prompt_meta>

## Content Section
This is the content without body tag.
"""
        result = _parse_xml_meta(text)
        self.assertIsNotNone(result)
        metadata, content = result  # type: ignore

        self.assertEqual(metadata["prompt_id"], "test")
        self.assertIn("## Content Section", content)

    def test_parse_xml_meta_returns_none_for_legacy(self) -> None:
        """Legacy format should return None from _parse_xml_meta."""
        text = """# [Prompt] Test

- prompt_id: legacy_test
- version: 0.1.0

## Content
Legacy content here.
"""
        result = _parse_xml_meta(text)
        self.assertIsNone(result)

    def test_parse_legacy_frontmatter(self) -> None:
        """Legacy frontmatter should be parsed correctly."""
        text = """# [Prompt] Test

- prompt_id: legacy_test
- language: en-US
- version: 0.1.0

## Content
Legacy content here.
"""
        metadata, content = _parse_legacy_frontmatter(text)

        self.assertEqual(metadata["prompt_id"], "legacy_test")
        self.assertEqual(metadata["language"], "en-US")
        self.assertEqual(metadata["version"], "0.1.0")
        self.assertIn("## Content", content)
        self.assertIn("Legacy content here.", content)

    def test_parse_frontmatter_prefers_xml(self) -> None:
        """_parse_frontmatter should prefer XML format when available."""
        xml_text = """<prompt_meta>
  <prompt_id>xml_test</prompt_id>
  <version>0.2.0</version>
</prompt_meta>

<prompt_body>
## XML Content
This is XML format.
</prompt_body>
"""
        metadata, content = _parse_frontmatter(xml_text)

        self.assertEqual(metadata["prompt_id"], "xml_test")
        self.assertEqual(metadata["version"], "0.2.0")
        self.assertIn("## XML Content", content)

    def test_parse_frontmatter_fallback_to_legacy(self) -> None:
        """_parse_frontmatter should fallback to legacy when XML is missing."""
        legacy_text = """# [Prompt] Test

- prompt_id: fallback_test
- version: 0.1.0

## Content
Fallback content.
"""
        metadata, content = _parse_frontmatter(legacy_text)

        self.assertEqual(metadata["prompt_id"], "fallback_test")
        self.assertIn("## Content", content)

    def test_load_prompt_with_xml_metadata(self) -> None:
        """Integration test: load_prompt_with_metadata with XML format."""
        # Load actual prompt file (migrated to XML format)
        data = load_prompt_with_metadata("system", "game_master", Language.KO)

        self.assertIsNotNone(data.content)
        self.assertIsInstance(data.metadata, dict)

        # Check metadata fields
        self.assertEqual(data.metadata.get("prompt_id"), "game_master_system")
        self.assertEqual(data.metadata.get("language"), "ko-KR")
        self.assertIn("version", data.metadata)

        # Content should not contain meta tags
        self.assertNotIn("<prompt_meta>", data.content)
        self.assertNotIn("<prompt_body>", data.content)
        self.assertIn("## ëª©ì ", data.content)

    def test_load_prompt_with_xml_metadata_en(self) -> None:
        """Integration test: English XML format."""
        data = load_prompt_with_metadata("system", "game_master", Language.EN)

        self.assertEqual(data.metadata.get("prompt_id"), "game_master_system")
        self.assertEqual(data.metadata.get("language"), "en-US")
        self.assertIn("## Purpose", data.content)


if __name__ == "__main__":
    unittest.main()
</file>

<file path="backend/tests/unit/orchestrator/test_u052_render_helpers.py">
"""U-052[Mvp]: ì¡°ê±´ë¶€ ì´ë¯¸ì§€ ìƒì„± ì œì–´ ë¡œì§ ë‹¨ìœ„ í…ŒìŠ¤íŠ¸.

ì´ í…ŒìŠ¤íŠ¸ëŠ” TurnOutput ë‚´ì˜ image_jobì„ ë¶„ì„í•˜ì—¬ ì´ë¯¸ì§€ ìƒì„± ì—¬ë¶€ë¥¼ íŒì •í•˜ëŠ”
render_helpers.pyì˜ ê¸°ëŠ¥ë“¤ì„ ê²€ì¦í•©ë‹ˆë‹¤.

í…ŒìŠ¤íŠ¸ í•­ëª©:
    - extract_image_job: TurnOutputì—ì„œ ImageJob ì¶”ì¶œ ê²€ì¦
    - should_generate_image: should_generate í”Œë˜ê·¸ ë° í”„ë¡¬í”„íŠ¸ ìœ íš¨ì„± ê²€ì‚¬
    - get_prompt_hash: í”„ë¡¬í”„íŠ¸ í•´ì‹± ê²€ì¦ (RULE-007)
    - can_afford_image_generation: ì”ì•¡ ê¸°ë°˜ ë¹„ìš© íŒì • ê²€ì¦ (RULE-005)
    - decide_image_generation: ì¢…í•© íŒì • ë¡œì§ ë° í´ë°± ë©”ì‹œì§€ ê²€ì¦
"""

import pytest

from unknown_world.models.turn import (
    CurrencyAmount,
    EconomyOutput,
    EconomySnapshot,
    ImageJob,
    Language,
    RenderOutput,
    SafetyOutput,
    TurnOutput,
)
from unknown_world.orchestrator.stages.render_helpers import (
    IMAGE_GENERATION_COST_SIGNAL,
    can_afford_image_generation,
    decide_image_generation,
    extract_image_job,
    get_prompt_hash,
    should_generate_image,
)


@pytest.fixture
def base_turn_output():
    """ê¸°ë³¸ TurnOutput ê°ì²´ë¥¼ ìƒì„±í•˜ëŠ” í”½ìŠ¤ì²˜."""
    return TurnOutput(
        language=Language.KO,
        narrative="í…ŒìŠ¤íŠ¸ ë‚´ëŸ¬í‹°ë¸Œ",
        economy=EconomyOutput(
            cost=CurrencyAmount(signal=5, memory_shard=0),
            balance_after=CurrencyAmount(signal=95, memory_shard=5),
        ),
        safety=SafetyOutput(blocked=False),
    )


def test_extract_image_job_exists(base_turn_output):
    """ImageJobì´ ì¡´ì¬í•˜ëŠ” ê²½ìš° ì •ìƒì ìœ¼ë¡œ ì¶”ì¶œí•˜ëŠ”ì§€ í™•ì¸."""
    image_job = ImageJob(should_generate=True, prompt="A beautiful sunset")
    base_turn_output.render = RenderOutput(image_job=image_job)

    extracted = extract_image_job(base_turn_output)
    assert extracted == image_job
    assert extracted.prompt == "A beautiful sunset"


def test_extract_image_job_none(base_turn_output):
    """ImageJobì´ Noneì¸ ê²½ìš° Noneì„ ë°˜í™˜í•˜ëŠ”ì§€ í™•ì¸."""
    base_turn_output.render = RenderOutput(image_job=None)
    assert extract_image_job(base_turn_output) is None


def test_should_generate_image_true():
    """ëª¨ë“  ì¡°ê±´ì´ ë§Œì¡±ë  ë•Œ Trueë¥¼ ë°˜í™˜í•˜ëŠ”ì§€ í™•ì¸."""
    job = ImageJob(should_generate=True, prompt="Valid prompt")
    assert should_generate_image(job) is True


def test_should_generate_image_false_flag():
    """should_generate í”Œë˜ê·¸ê°€ Falseë©´ Falseë¥¼ ë°˜í™˜í•˜ëŠ”ì§€ í™•ì¸."""
    job = ImageJob(should_generate=False, prompt="Valid prompt")
    assert should_generate_image(job) is False


def test_should_generate_image_empty_prompt():
    """í”„ë¡¬í”„íŠ¸ê°€ ë¹„ì–´ìˆìœ¼ë©´ Falseë¥¼ ë°˜í™˜í•˜ëŠ”ì§€ í™•ì¸."""
    job1 = ImageJob(should_generate=True, prompt="")
    job2 = ImageJob(should_generate=True, prompt="   ")
    assert should_generate_image(job1) is False
    assert should_generate_image(job2) is False


def test_should_generate_image_none():
    """ImageJobì´ Noneì´ë©´ Falseë¥¼ ë°˜í™˜í•˜ëŠ”ì§€ í™•ì¸."""
    assert should_generate_image(None) is False


def test_get_prompt_hash():
    """í”„ë¡¬í”„íŠ¸ í•´ì‹œê°€ 8ìë¦¬ì´ë©° ì›ë¬¸ê³¼ ë‹¤ë¥¸ì§€ í™•ì¸."""
    prompt = "A mysterious cave in the mountains"
    h = get_prompt_hash(prompt)
    assert len(h) == 8
    assert h != prompt
    # ë™ì¼ í”„ë¡¬í”„íŠ¸ëŠ” ë™ì¼ í•´ì‹œ
    assert h == get_prompt_hash(prompt)
    # ë‹¤ë¥¸ í”„ë¡¬í”„íŠ¸ëŠ” ë‹¤ë¥¸ í•´ì‹œ
    assert h != get_prompt_hash("Something else")


def test_can_afford_image_generation():
    """ì”ì•¡ ê¸°ë°˜ ë¹„ìš© íŒì • í™•ì¸."""
    cost = IMAGE_GENERATION_COST_SIGNAL  # 10

    # ì¶©ë¶„
    snapshot_ok = EconomySnapshot(signal=cost, memory_shard=0)
    assert can_afford_image_generation(snapshot_ok) is True

    # ì—¬ìœ 
    snapshot_rich = EconomySnapshot(signal=100, memory_shard=5)
    assert can_afford_image_generation(snapshot_rich) is True

    # ë¶€ì¡±
    snapshot_poor = EconomySnapshot(signal=cost - 1, memory_shard=0)
    assert can_afford_image_generation(snapshot_poor) is False


def test_decide_image_generation_success(base_turn_output):
    """ëª¨ë“  ì¡°ê±´ì´ ì¶©ì¡±ë˜ì–´ ìƒì„±ì´ ìŠ¹ì¸ë˜ëŠ” ì¼€ì´ìŠ¤."""
    job = ImageJob(
        should_generate=True, prompt="A dragon flying over a castle", aspect_ratio="16:9"
    )
    base_turn_output.render = RenderOutput(image_job=job)
    economy = EconomySnapshot(signal=100, memory_shard=5)

    decision = decide_image_generation(base_turn_output, economy)

    assert decision.should_generate is True
    assert decision.reason == "all_conditions_met"
    assert decision.prompt_hash == get_prompt_hash(job.prompt)
    assert decision.aspect_ratio == "16:9"
    assert decision.estimated_cost_signal == IMAGE_GENERATION_COST_SIGNAL
    assert decision.fallback_message is None


def test_decide_image_generation_insufficient_balance(base_turn_output):
    """ì”ì•¡ ë¶€ì¡± ì‹œ FAST í´ë°±ìœ¼ë¡œ ë¬´ë£Œ ìƒì„± (U-079)."""
    job = ImageJob(should_generate=True, prompt="A treasure chest")
    base_turn_output.render = RenderOutput(image_job=job)
    # ë¹„ìš© 10ì¸ë° ì”ì•¡ 5 â†’ U-079: FAST í´ë°±
    economy = EconomySnapshot(signal=5, memory_shard=0)

    decision = decide_image_generation(base_turn_output, economy, language="ko-KR")

    assert decision.should_generate is True
    assert decision.reason == "low_balance_fast_fallback"
    assert decision.model_override == "FAST"
    assert decision.is_low_balance_fallback is True
    assert decision.estimated_cost_signal == 0
    assert decision.prompt_hash == get_prompt_hash(job.prompt)


def test_decide_image_generation_no_job(base_turn_output):
    """ImageJobì´ ì—†ëŠ” ì¼€ì´ìŠ¤."""
    base_turn_output.render = RenderOutput(image_job=None)
    economy = EconomySnapshot(signal=100, memory_shard=5)

    decision = decide_image_generation(base_turn_output, economy)

    assert decision.should_generate is False
    assert decision.reason == "no_image_job"


def test_decide_image_generation_empty_prompt(base_turn_output):
    """í”„ë¡¬í”„íŠ¸ê°€ ë¹„ì–´ìˆëŠ” ì¼€ì´ìŠ¤."""
    job = ImageJob(should_generate=True, prompt=" ")
    base_turn_output.render = RenderOutput(image_job=job)
    economy = EconomySnapshot(signal=100, memory_shard=5)

    decision = decide_image_generation(base_turn_output, economy)

    assert decision.should_generate is False
    assert decision.reason == "empty_prompt"


def test_decide_image_generation_language_fallback(base_turn_output):
    """ì”ì•¡ ë¶€ì¡± ì‹œ FAST í´ë°±ìœ¼ë¡œ ìƒì„± - ì–¸ì–´ ë¬´ê´€ (U-079)."""
    job = ImageJob(should_generate=True, prompt="Gold coins")
    base_turn_output.render = RenderOutput(image_job=job)
    economy = EconomySnapshot(signal=0, memory_shard=0)

    # í•œêµ­ì–´ - U-079: FAST í´ë°± (fallback_message ì—†ìŒ, ìƒì„± í—ˆìš©)
    decision_ko = decide_image_generation(base_turn_output, economy, language="ko-KR")
    assert decision_ko.should_generate is True
    assert decision_ko.reason == "low_balance_fast_fallback"
    assert decision_ko.model_override == "FAST"
    assert decision_ko.is_low_balance_fallback is True

    # ì˜ì–´ - ë™ì¼í•œ FAST í´ë°±
    decision_en = decide_image_generation(base_turn_output, economy, language="en-US")
    assert decision_en.should_generate is True
    assert decision_en.reason == "low_balance_fast_fallback"
    assert decision_en.model_override == "FAST"
</file>

<file path="backend/tests/unit/orchestrator/test_u053_render_async.py">
"""U-053[Mvp]: ë¹„ë™ê¸° ì´ë¯¸ì§€ ìƒì„± ë° ê²°ê³¼ ë°ì´í„° ë™ê¸°í™” í…ŒìŠ¤íŠ¸.

render_stageì—ì„œ ì‹¤ì œ ì´ë¯¸ì§€ ìƒì„±ê¸°ë¥¼ í˜¸ì¶œí•˜ê³ 
ê²°ê³¼(URL, ID ë“±)ê°€ TurnOutputì— ì˜¬ë°”ë¥´ê²Œ ë™ê¸°í™”ë˜ëŠ”ì§€ ê²€ì¦í•©ë‹ˆë‹¤.
"""

from unittest.mock import AsyncMock, MagicMock

import pytest

from unknown_world.models.turn import (
    ClientInfo,
    CurrencyAmount,
    EconomyOutput,
    EconomySnapshot,
    ImageJob,
    Language,
    RenderOutput,
    SafetyOutput,
    TurnInput,
    TurnOutput,
)
from unknown_world.orchestrator.stages.render import render_stage
from unknown_world.orchestrator.stages.types import PipelineContext
from unknown_world.services.image_generation import (
    ImageGenerationResponse,
    ImageGenerationStatus,
)


@pytest.fixture
def mock_emit():
    """ì´ë²¤íŠ¸ emitì„ ìœ„í•œ ëª¨ì˜ í•¨ìˆ˜."""
    return AsyncMock()


@pytest.fixture
def mock_generator():
    """ì´ë¯¸ì§€ ìƒì„±ê¸° ëª¨ì˜ ê°ì²´."""
    generator = MagicMock()
    generator.is_available.return_value = True
    # ê¸°ë³¸ì ìœ¼ë¡œ ì„±ê³µ ì‘ë‹µì„ ë°˜í™˜í•˜ë„ë¡ ì„¤ì •
    generator.generate = AsyncMock(
        return_value=ImageGenerationResponse(
            status=ImageGenerationStatus.COMPLETED,
            image_id="test_img_123",
            image_url="http://localhost/images/test_img_123.png",
            generation_time_ms=1200,
        )
    )
    return generator


@pytest.mark.asyncio
async def test_render_stage_sync_success(mock_emit, mock_generator):
    """ì´ë¯¸ì§€ ìƒì„± ì„±ê³µ ì‹œ TurnOutput.renderì— ë°ì´í„°ê°€ ë™ê¸°í™”ë˜ëŠ”ì§€ í™•ì¸."""
    # 1. ì¤€ë¹„
    turn_input = TurnInput(
        language=Language.KO,
        text="ìˆ²ìœ¼ë¡œ ê°„ë‹¤",
        economy_snapshot=EconomySnapshot(signal=100, memory_shard=5),
        client=ClientInfo(viewport_w=1920, viewport_h=1080),
    )

    # ì´ˆê¸° ìƒíƒœì—ì„œëŠ” image_urlì´ None
    turn_output = TurnOutput(
        language=Language.KO,
        narrative="ì–´ë‘ìš´ ìˆ²ì´ë‹¤.",
        economy=EconomyOutput(
            cost=CurrencyAmount(signal=5, memory_shard=0),
            balance_after=CurrencyAmount(signal=95, memory_shard=5),
        ),
        safety=SafetyOutput(blocked=False),
        render=RenderOutput(
            image_job=ImageJob(should_generate=True, prompt="A dark forest", aspect_ratio="16:9")
        ),
    )

    ctx = PipelineContext(
        turn_input=turn_input,
        economy_snapshot=CurrencyAmount(signal=100, memory_shard=5),
        output=turn_output,
        image_generator=mock_generator,
    )

    # 2. ì‹¤í–‰
    result_ctx = await render_stage(ctx, emit=mock_emit)

    # 3. ê²€ì¦
    # generator.generateê°€ í˜¸ì¶œë˜ì—ˆëŠ”ì§€ í™•ì¸
    mock_generator.generate.assert_called_once()

    # TurnOutput.renderì— ë°ì´í„°ê°€ ë°˜ì˜ë˜ì—ˆëŠ”ì§€ í™•ì¸
    assert result_ctx.output.render.image_url == "http://localhost/images/test_img_123.png"
    assert result_ctx.output.render.image_id == "test_img_123"
    assert result_ctx.output.render.generation_time_ms == 1200


@pytest.mark.asyncio
async def test_render_stage_generator_failure(mock_emit, mock_generator):
    """ì´ë¯¸ì§€ ìƒì„± ì‹¤íŒ¨ ì‹œ TurnOutputì´ ë³€ê²½ë˜ì§€ ì•ŠëŠ”ì§€ í™•ì¸."""
    # 1. ì¤€ë¹„ - ì‹¤íŒ¨ ì‘ë‹µ ì„¤ì •
    mock_generator.generate.return_value = ImageGenerationResponse(
        status=ImageGenerationStatus.FAILED,
        message="API Error",
    )

    turn_input = TurnInput(
        language=Language.KO,
        text="í…ŒìŠ¤íŠ¸",
        economy_snapshot=EconomySnapshot(signal=100, memory_shard=5),
        client=ClientInfo(viewport_w=1920, viewport_h=1080),
    )

    turn_output = TurnOutput(
        language=Language.KO,
        narrative="í…ŒìŠ¤íŠ¸ ë‚´ëŸ¬í‹°ë¸Œ",
        economy=EconomyOutput(
            cost=CurrencyAmount(signal=5, memory_shard=0),
            balance_after=CurrencyAmount(signal=95, memory_shard=5),
        ),
        safety=SafetyOutput(blocked=False),
        render=RenderOutput(image_job=ImageJob(should_generate=True, prompt="Test prompt")),
    )

    ctx = PipelineContext(
        turn_input=turn_input,
        economy_snapshot=CurrencyAmount(signal=100, memory_shard=5),
        output=turn_output,
        image_generator=mock_generator,
    )

    # 2. ì‹¤í–‰
    result_ctx = await render_stage(ctx, emit=mock_emit)

    # 3. ê²€ì¦
    assert mock_generator.generate.assert_called_once
    # ì‹¤íŒ¨í–ˆìœ¼ë¯€ë¡œ image_urlì€ ì—¬ì „íˆ Noneì´ì–´ì•¼ í•¨
    assert result_ctx.output.render.image_url is None


@pytest.mark.asyncio
async def test_render_stage_exception_handling(mock_emit, mock_generator):
    """ì´ë¯¸ì§€ ìƒì„± ì¤‘ ì˜ˆì™¸ ë°œìƒ ì‹œ ì•ˆì „í•˜ê²Œ ì²˜ë¦¬ë˜ëŠ”ì§€ í™•ì¸."""
    # 1. ì¤€ë¹„ - ì˜ˆì™¸ ë°œìƒ ì„¤ì •
    mock_generator.generate.side_effect = Exception("Network Timeout")

    turn_input = TurnInput(
        language=Language.KO,
        text="í…ŒìŠ¤íŠ¸",
        economy_snapshot=EconomySnapshot(signal=100, memory_shard=5),
        client=ClientInfo(viewport_w=1920, viewport_h=1080),
    )

    turn_output = TurnOutput(
        language=Language.KO,
        narrative="í…ŒìŠ¤íŠ¸ ë‚´ëŸ¬í‹°ë¸Œ",
        economy=EconomyOutput(
            cost=CurrencyAmount(signal=5, memory_shard=0),
            balance_after=CurrencyAmount(signal=95, memory_shard=5),
        ),
        safety=SafetyOutput(blocked=False),
        render=RenderOutput(image_job=ImageJob(should_generate=True, prompt="Test prompt")),
    )

    ctx = PipelineContext(
        turn_input=turn_input,
        economy_snapshot=CurrencyAmount(signal=100, memory_shard=5),
        output=turn_output,
        image_generator=mock_generator,
    )

    # 2. ì‹¤í–‰ & ê²€ì¦ (ì˜ˆì™¸ê°€ ë°–ìœ¼ë¡œ ë˜ì ¸ì§€ì§€ ì•Šì•„ì•¼ í•¨)
    result_ctx = await render_stage(ctx, emit=mock_emit)

    assert mock_generator.generate.assert_called_once
    assert result_ctx.output.render.image_url is None
</file>

<file path="backend/tests/unit/services/test_image_extraction.py">
"""Unknown World - ì´ë¯¸ì§€ ì¶”ì¶œ ë¡œì§ ë‹¨ìœ„ í…ŒìŠ¤íŠ¸."""

from unittest.mock import MagicMock

import pytest

from unknown_world.services.image_generation import ImageGenerator


@pytest.fixture
def generator():
    """ImageGenerator ì¸ìŠ¤í„´ìŠ¤ í”½ìŠ¤ì²˜ (í´ë¼ì´ì–¸íŠ¸ ì´ˆê¸°í™” ìƒëµ)."""
    with MagicMock():
        # Client ì´ˆê¸°í™”ë¥¼ ëª¨í‚¹í•˜ì—¬ ì‹¤ì œ Vertex AI ì—°ê²° ë°©ì§€
        return ImageGenerator()


def test_extract_image_success(generator):
    """ì •ìƒì ì¸ ì‘ë‹µì—ì„œ ì´ë¯¸ì§€ ë°”ì´íŠ¸ë¥¼ ì„±ê³µì ìœ¼ë¡œ ì¶”ì¶œí•˜ëŠ”ì§€ í…ŒìŠ¤íŠ¸."""
    # Gemini ì‘ë‹µ êµ¬ì¡° ëª¨í‚¹
    mock_part = MagicMock()
    mock_part.text = "A beautiful sunset"
    mock_part.inline_data.data = b"fake-image-bytes"

    mock_content = MagicMock()
    mock_content.parts = [mock_part]

    mock_candidate = MagicMock()
    mock_candidate.content = mock_content

    mock_response = MagicMock()
    mock_response.candidates = [mock_candidate]

    image_bytes = generator._extract_image_from_response(mock_response)

    assert image_bytes == b"fake-image-bytes"


def test_extract_image_text_only(generator):
    """í…ìŠ¤íŠ¸ë§Œ í¬í•¨ëœ ì‘ë‹µì—ì„œ Noneì„ ë°˜í™˜í•˜ëŠ”ì§€ í…ŒìŠ¤íŠ¸."""
    mock_part = MagicMock()
    mock_part.text = "Thinking about the image..."
    mock_part.inline_data = None  # ì´ë¯¸ì§€ ì—†ìŒ

    mock_content = MagicMock()
    mock_content.parts = [mock_part]

    mock_candidate = MagicMock()
    mock_candidate.content = mock_content

    mock_response = MagicMock()
    mock_response.candidates = [mock_candidate]

    image_bytes = generator._extract_image_from_response(mock_response)

    assert image_bytes is None


def test_extract_image_empty_response(generator):
    """ë¹„ì–´ìˆëŠ” ì‘ë‹µì—ì„œ Noneì„ ë°˜í™˜í•˜ëŠ”ì§€ í…ŒìŠ¤íŠ¸."""
    mock_response = MagicMock()
    mock_response.candidates = []

    image_bytes = generator._extract_image_from_response(mock_response)

    assert image_bytes is None


def test_extract_image_multiple_parts(generator):
    """ì—¬ëŸ¬ íŒŒíŠ¸ ì¤‘ ì´ë¯¸ì§€ê°€ ìˆëŠ” íŒŒíŠ¸ë¥¼ ì˜¬ë°”ë¥´ê²Œ ì°¾ëŠ”ì§€ í…ŒìŠ¤íŠ¸."""
    mock_part_text = MagicMock()
    mock_part_text.text = "Here is your image"
    mock_part_text.inline_data = None

    mock_part_image = MagicMock()
    mock_part_image.inline_data.data = b"image-data"

    mock_content = MagicMock()
    mock_content.parts = [mock_part_text, mock_part_image]

    mock_candidate = MagicMock()
    mock_candidate.content = mock_content

    mock_response = MagicMock()
    mock_response.candidates = [mock_candidate]

    image_bytes = generator._extract_image_from_response(mock_response)

    assert image_bytes == b"image-data"


def test_extract_image_malformed_part(generator):
    """í•„ë“œê°€ ëˆ„ë½ëœ ì˜ëª»ëœ í˜•ì‹ì˜ íŒŒíŠ¸ë¥¼ ì•ˆì „í•˜ê²Œ ê±´ë„ˆë›°ëŠ”ì§€ í…ŒìŠ¤íŠ¸."""
    mock_part = MagicMock(spec=[])  # ì•„ë¬´ ì†ì„±ë„ ì—†ëŠ” ê°ì²´

    mock_content = MagicMock()
    mock_content.parts = [mock_part]

    mock_candidate = MagicMock()
    mock_candidate.content = mock_content

    mock_response = MagicMock()
    mock_response.candidates = [mock_candidate]

    # AttributeError ë“±ì´ ë°œìƒí•˜ì§€ ì•Šê³  Noneì„ ë°˜í™˜í•´ì•¼ í•¨
    image_bytes = generator._extract_image_from_response(mock_response)

    assert image_bytes is None
</file>

<file path="backend/tests/unit/services/test_u075_verification.py">
from unittest.mock import AsyncMock, MagicMock, patch

import pytest

from unknown_world.models.turn import (
    CurrencyAmount,
    EconomyOutput,
    InventoryItemData,
    Language,
    SafetyOutput,
    TurnOutput,
    WorldDelta,
)
from unknown_world.services.item_icon_generator import (
    IconGenerationRequest,
    ItemIconGenerator,
)


@pytest.fixture
def mock_image_generator():
    generator = MagicMock()
    generator.generate = AsyncMock()
    return generator


@pytest.fixture
def icon_generator(mock_image_generator):
    return ItemIconGenerator(image_generator=mock_image_generator)


@pytest.mark.asyncio
async def test_inventory_item_data_serialization():
    """Verify that TurnOutput can handle InventoryItemData in WorldDelta."""
    item = InventoryItemData(
        id="item_1",
        label="ë¹›ë‚˜ëŠ” ê²€",
        description="íƒœì–‘ì˜ ë¹›ì„ ë¨¸ê¸ˆì€ ì „ì„¤ì ì¸ ê²€ì…ë‹ˆë‹¤.",
        quantity=1,
    )

    delta = WorldDelta(
        inventory_added=[item]  # DESIRED: list[InventoryItemData]
    )

    output = TurnOutput(
        language=Language.KO,
        narrative="ì•„ì´í…œì„ íšë“í–ˆìŠµë‹ˆë‹¤.",
        economy=EconomyOutput(
            cost=CurrencyAmount(signal=0, memory_shard=0),
            balance_after=CurrencyAmount(signal=100, memory_shard=5),
        ),
        safety=SafetyOutput(blocked=False),
        world=delta,
    )

    assert isinstance(output.world.inventory_added[0], InventoryItemData)
    assert output.world.inventory_added[0].label == "ë¹›ë‚˜ëŠ” ê²€"


@pytest.mark.asyncio
async def test_item_icon_generator_generates_icon(icon_generator, mock_image_generator):
    """Verify icon generator calls image generator without rembg (U-091)."""
    from unknown_world.services.image_generation import (
        ImageGenerationResponse,
        ImageGenerationStatus,
    )

    mock_image_generator.generate.return_value = ImageGenerationResponse(
        status=ImageGenerationStatus.COMPLETED,
        image_url="http://example.com/icon.png",
        image_id="img_1",
    )

    request = IconGenerationRequest(
        item_id="item_1", item_description="A shiny sword", language="ko-KR"
    )

    with patch.object(
        mock_image_generator, "generate", wraps=mock_image_generator.generate
    ) as mocked_gen:
        await icon_generator.generate_icon(request, wait_for_completion=True)

        called_request = mocked_gen.call_args[0][0]
        # U-091: rembg ëŸ°íƒ€ì„ ì œê±° - remove_background í•„ë“œê°€ ë” ì´ìƒ ì—†ìŒ
        assert called_request.model_label == "FAST"
</file>

<file path="backend/tests/unit/services/test_u094_scan_retry.py">
"""U-094: ImageUnderstanding ì‘ë‹µ íŒŒì‹± ì˜ˆì™¸ ì‹œ ìë™ ì¬ì‹œë„ ë‹¨ìœ„ í…ŒìŠ¤íŠ¸.

ì´ í…ŒìŠ¤íŠ¸ëŠ” ImageUnderstandingServiceì˜ ì¬ì‹œë„ ë¡œì§ì„ ê²€ì¦í•©ë‹ˆë‹¤.
"""

from unittest.mock import AsyncMock, MagicMock, patch

import pytest

from unknown_world.models.scanner import ScanStatus
from unknown_world.models.turn import Language
from unknown_world.services.image_understanding import (
    SCAN_MAX_RETRIES,
    SCAN_RETRY_BACKOFF_SECONDS,
    SCAN_RETRY_REINFORCEMENT,
    ImageUnderstandingService,
)


@pytest.fixture
def service():
    """ImageUnderstandingService ì¸ìŠ¤í„´ìŠ¤ (Real ëª¨ë“œ ê°•ì œ)."""
    with (
        patch(
            "unknown_world.services.image_understanding.ImageUnderstandingService._initialize_client"
        ),
        patch("unknown_world.services.image_understanding.load_prompt") as mock_load,
    ):
        # ê¸°ë³¸ í”„ë¡¬í”„íŠ¸ ë°˜í™˜ ì„¤ì • ({count} í¬í•¨)
        mock_load.return_value = "Analyze this image. Find {count} items."

        svc = ImageUnderstandingService(force_mock=False)
        # Real ëª¨ë“œ ê°•ì œ (ì¬ì‹œë„ ë¡œì§ í™œì„±í™”)
        svc._is_mock = False
        # Mock í´ë¼ì´ì–¸íŠ¸ ì£¼ì…
        svc._genai_client = MagicMock()
        svc._genai_client.aio = MagicMock()
        svc._genai_client.aio.models = MagicMock()
        svc._genai_client.aio.models.generate_content = AsyncMock()
        return svc


@pytest.mark.asyncio
async def test_retry_on_parsing_failure_success(service):
    """íŒŒì‹± ì‹¤íŒ¨ ì‹œ ì¬ì‹œë„í•˜ì—¬ ì„±ê³µí•˜ëŠ” ì‹œë‚˜ë¦¬ì˜¤ í…ŒìŠ¤íŠ¸."""
    # ì²« ë²ˆì§¸ í˜¸ì¶œ: ì˜ëª»ëœ JSON
    # ë‘ ë²ˆì§¸ í˜¸ì¶œ: ì •ìƒ JSON
    mock_response_1 = MagicMock()
    mock_response_1.text = "This is not JSON"
    mock_response_1.candidates = []
    mock_response_1.prompt_feedback = None

    mock_response_2 = MagicMock()
    mock_response_2.text = (
        '{"caption": "Success after retry", "objects": [], "item_candidates": []}'
    )
    mock_response_2.candidates = []
    mock_response_2.prompt_feedback = None

    service._genai_client.aio.models.generate_content.side_effect = [
        mock_response_1,
        mock_response_2,
    ]

    with patch("asyncio.sleep", AsyncMock()) as mock_sleep:
        result = await service.analyze(b"fake_image" * 20, "image/png", Language.KO)

        assert result.status == ScanStatus.COMPLETED
        assert result.caption == "Success after retry"
        assert service._genai_client.aio.models.generate_content.call_count == 2
        assert mock_sleep.call_count == 1
        mock_sleep.assert_called_with(SCAN_RETRY_BACKOFF_SECONDS[0])


@pytest.mark.asyncio
async def test_retry_on_api_exception_success(service):
    """API í˜¸ì¶œ ì˜ˆì™¸ ë°œìƒ ì‹œ ì¬ì‹œë„í•˜ì—¬ ì„±ê³µí•˜ëŠ” ì‹œë‚˜ë¦¬ì˜¤ í…ŒìŠ¤íŠ¸."""
    # ì²« ë²ˆì§¸ í˜¸ì¶œ: Exception
    # ë‘ ë²ˆì§¸ í˜¸ì¶œ: ì •ìƒ JSON
    mock_response = MagicMock()
    mock_response.text = (
        '{"caption": "Success after exception", "objects": [], "item_candidates": []}'
    )
    mock_response.candidates = []
    mock_response.prompt_feedback = None

    service._genai_client.aio.models.generate_content.side_effect = [
        Exception("Temporary API Error"),
        mock_response,
    ]

    with patch("asyncio.sleep", AsyncMock()) as mock_sleep:
        result = await service.analyze(b"fake_image" * 20, "image/png", Language.KO)

        assert result.status == ScanStatus.COMPLETED
        assert result.caption == "Success after exception"
        assert service._genai_client.aio.models.generate_content.call_count == 2
        assert mock_sleep.call_count == 1


@pytest.mark.asyncio
async def test_fail_after_max_retries(service):
    """ëª¨ë“  ì¬ì‹œë„ ì‹¤íŒ¨ ì‹œ í´ë°± ì‘ë‹µì„ ë°˜í™˜í•˜ëŠ”ì§€ í…ŒìŠ¤íŠ¸."""
    # ì´ 3íšŒ(ì´ˆê¸° 1 + ì¬ì‹œë„ 2) ëª¨ë‘ ì‹¤íŒ¨
    mock_response = MagicMock()
    mock_response.text = "Still not JSON"
    mock_response.candidates = []
    mock_response.prompt_feedback = None

    service._genai_client.aio.models.generate_content.return_value = mock_response

    with patch("asyncio.sleep", AsyncMock()) as mock_sleep:
        result = await service.analyze(b"fake_image" * 20, "image/png", Language.KO)

        # ëª¨ë“  ì¬ì‹œë„ ì‹¤íŒ¨ ì‹œ PARTIAL(ìº¡ì…˜ë§Œ ë°˜í™˜) ë˜ëŠ” FAILED
        # í˜„ì¬ _parse_vision_responseëŠ” JSONDecodeError ì‹œ PARTIALì„ ë°˜í™˜í•¨
        assert result.status == ScanStatus.PARTIAL
        assert "ì´ë¯¸ì§€ ë¶„ì„ì— ì‹¤íŒ¨í–ˆìŠµë‹ˆë‹¤" in result.message
        assert service._genai_client.aio.models.generate_content.call_count == SCAN_MAX_RETRIES + 1
        assert mock_sleep.call_count == SCAN_MAX_RETRIES


@pytest.mark.asyncio
async def test_no_retry_on_safety_block(service):
    """ì•ˆì „ ì°¨ë‹¨ ì‹œ ì¬ì‹œë„í•˜ì§€ ì•ŠëŠ”ì§€ í…ŒìŠ¤íŠ¸."""
    mock_response = MagicMock()
    # candidates[0].finish_reason = SAFETY ì‹œë®¬ë ˆì´ì…˜
    mock_candidate = MagicMock()
    mock_candidate.finish_reason = "SAFETY"
    mock_response.candidates = [mock_candidate]
    mock_response.text = ""
    # prompt_feedbackë„ ì¡´ì¬í•˜ë©´ block_reasonì„ ì²´í¬í•  ìˆ˜ ìˆìœ¼ë¯€ë¡œ ëª…ì‹œì ìœ¼ë¡œ None ì„¤ì •
    mock_response.prompt_feedback = None

    service._genai_client.aio.models.generate_content.return_value = mock_response

    with patch("asyncio.sleep", AsyncMock()) as mock_sleep:
        result = await service.analyze(b"fake_image" * 20, "image/png", Language.KO)

        assert result.status == ScanStatus.BLOCKED
        assert "ì•ˆì „ ì •ì±…" in result.message
        assert service._genai_client.aio.models.generate_content.call_count == 1
        assert mock_sleep.call_count == 0


@pytest.mark.asyncio
async def test_no_retry_on_non_retryable_api_error(service):
    """ì¬ì‹œë„ ë¶ˆê°€ API ì—ëŸ¬ ì‹œ ì¬ì‹œë„í•˜ì§€ ì•ŠëŠ”ì§€ í…ŒìŠ¤íŠ¸."""

    # PermissionDenied í´ë˜ìŠ¤ í‰ë‚´
    class PermissionDenied(Exception):
        pass

    service._genai_client.aio.models.generate_content.side_effect = PermissionDenied(
        "Invalid API Key"
    )

    with patch("asyncio.sleep", AsyncMock()) as mock_sleep:
        result = await service.analyze(b"fake_image" * 20, "image/png", Language.KO)

        assert result.status == ScanStatus.FAILED
        assert "API ì˜¤ë¥˜" in result.message
        assert service._genai_client.aio.models.generate_content.call_count == 1
        assert mock_sleep.call_count == 0


@pytest.mark.asyncio
async def test_prompt_reinforcement_on_retry(service):
    """ì¬ì‹œë„ ì‹œ í”„ë¡¬í”„íŠ¸ì— JSON ê°•ì¡° ì§€ì‹œê°€ ì¶”ê°€ë˜ëŠ”ì§€ í…ŒìŠ¤íŠ¸."""
    # ì²« ë²ˆì§¸ í˜¸ì¶œì€ ì‹¤íŒ¨í•´ì•¼ ì¬ì‹œë„ê°€ ì¼ì–´ë‚¨
    mock_response_fail = MagicMock()
    mock_response_fail.text = "fail"
    mock_response_fail.candidates = []
    mock_response_fail.prompt_feedback = None

    mock_response_ok = MagicMock()
    mock_response_ok.text = '{"caption": "ok", "objects": [], "item_candidates": []}'
    mock_response_ok.candidates = []
    mock_response_ok.prompt_feedback = None

    service._genai_client.aio.models.generate_content.side_effect = [
        mock_response_fail,
        mock_response_ok,
    ]

    with patch("asyncio.sleep", AsyncMock()):
        await service.analyze(b"fake_image" * 20, "image/png", Language.KO)

        # í˜¸ì¶œ ì¸ì í™•ì¸
        calls = service._genai_client.aio.models.generate_content.call_args_list
        assert len(calls) == 2

        # ì²« ë²ˆì§¸ í˜¸ì¶œ í”„ë¡¬í”„íŠ¸ (ê°•ì¡° ì—†ìŒ)
        first_call_contents = calls[0].kwargs["contents"]
        first_prompt = first_call_contents[1].text
        assert SCAN_RETRY_REINFORCEMENT[Language.KO] not in first_prompt

        # ë‘ ë²ˆì§¸ í˜¸ì¶œ í”„ë¡¬í”„íŠ¸ (ê°•ì¡° í¬í•¨)
        second_call_contents = calls[1].kwargs["contents"]
        second_prompt = second_call_contents[1].text
        assert SCAN_RETRY_REINFORCEMENT[Language.KO] in second_prompt
</file>

<file path="backend/tests/unit/services/test_u095_scanner_randomize.py">
"""U-095 Scanner ì•„ì´í…œ ìƒì„± ê°œìˆ˜ ëœë¤í™” ë‹¨ìœ„ í…ŒìŠ¤íŠ¸."""

from collections import Counter
from unittest.mock import MagicMock, patch

import pytest

from unknown_world.models.scanner import ItemCandidate, ScanStatus
from unknown_world.models.turn import Language
from unknown_world.services.image_understanding import (
    ImageUnderstandingService,
    ScanResult,
    _adjust_item_count,
    determine_item_count,
)


def test_determine_item_count_distribution():
    """ì•„ì´í…œ ìƒì„± ê°œìˆ˜ ë¶„í¬ í…ŒìŠ¤íŠ¸ (ê°€ì¤‘ì¹˜ ëœë¤ ê²€ì¦)."""
    iterations = 1000
    counts = [determine_item_count() for _ in range(iterations)]
    distribution = Counter(counts)

    # ê°€ì¤‘ì¹˜: 1ê°œ=60%, 2ê°œ=30%, 3ê°œ=10%
    # 1000íšŒ ì‹¤í–‰ ì‹œ ëŒ€ëµì ì¸ ë²”ìœ„ í™•ì¸ (ì—¬ìœ  ìˆê²Œ 5% ì˜¤ì°¨ í—ˆìš©)
    assert 500 <= distribution[1] <= 700
    assert 200 <= distribution[2] <= 400
    assert 50 <= distribution[3] <= 150
    assert len(distribution) == 3
    assert all(c in [1, 2, 3] for c in distribution)


def test_adjust_item_count_excess():
    """ì•„ì´í…œ ìˆ˜ê°€ ëª©í‘œë³´ë‹¤ ë§ì„ ë•Œ ì¡°ì • í…ŒìŠ¤íŠ¸."""
    items = [
        ItemCandidate(id="1", label="Item 1", description="Desc 1", item_type="tool"),
        ItemCandidate(id="2", label="Item 2", description="Desc 2", item_type="tool"),
        ItemCandidate(id="3", label="Item 3", description="Desc 3", item_type="tool"),
    ]
    result = ScanResult(
        status=ScanStatus.COMPLETED,
        caption="Test",
        objects=[],
        item_candidates=items,
        analysis_time_ms=100,
    )

    adjusted = _adjust_item_count(result, target_count=2)
    assert len(adjusted.item_candidates) == 2
    assert adjusted.item_candidates[0].id == "1"
    assert adjusted.item_candidates[1].id == "2"


def test_adjust_item_count_fewer():
    """ì•„ì´í…œ ìˆ˜ê°€ ëª©í‘œë³´ë‹¤ ì ì„ ë•Œ ì¡°ì • í…ŒìŠ¤íŠ¸ (ê·¸ëŒ€ë¡œ ìœ ì§€)."""
    items = [
        ItemCandidate(id="1", label="Item 1", description="Desc 1", item_type="tool"),
    ]
    result = ScanResult(
        status=ScanStatus.COMPLETED,
        caption="Test",
        objects=[],
        item_candidates=items,
        analysis_time_ms=100,
    )

    adjusted = _adjust_item_count(result, target_count=3)
    assert len(adjusted.item_candidates) == 1
    assert adjusted.item_candidates[0].id == "1"


def test_adjust_item_count_duplicate_labels():
    """ì¤‘ë³µëœ ì´ë¦„ì˜ ì•„ì´í…œ ì œê±° í…ŒìŠ¤íŠ¸."""
    items = [
        ItemCandidate(id="1", label="Key", description="Desc 1", item_type="key"),
        ItemCandidate(id="2", label="Key", description="Desc 2", item_type="key"),
        ItemCandidate(id="3", label="Lock", description="Desc 3", item_type="tool"),
    ]
    result = ScanResult(
        status=ScanStatus.COMPLETED,
        caption="Test",
        objects=[],
        item_candidates=items,
        analysis_time_ms=100,
    )

    adjusted = _adjust_item_count(result, target_count=3)
    assert len(adjusted.item_candidates) == 2
    assert adjusted.item_candidates[0].label == "Key"
    assert adjusted.item_candidates[1].label == "Lock"


@pytest.mark.asyncio
async def test_service_analyze_uses_correct_item_count():
    """analyze ë©”ì„œë“œê°€ ê²°ì •ëœ item_countë¥¼ ë¹„ì „ í˜¸ì¶œì— ì „ë‹¬í•˜ëŠ”ì§€ í…ŒìŠ¤íŠ¸."""
    service = ImageUnderstandingService(force_mock=False)
    service._is_mock = False
    # Mocking genai client
    service._genai_client = MagicMock()
    service._genai_client.aio.models.generate_content = MagicMock()

    # Mock response
    mock_response = MagicMock()
    mock_response.text = '{"caption": "test", "objects": [], "item_candidates": [{"id": "i1", "label": "L1", "description": "D1", "item_type": "tool"}]}'
    service._genai_client.aio.models.generate_content.return_value = mock_response

    with (
        patch(
            "unknown_world.services.image_understanding.determine_item_count", return_value=3
        ) as mock_count,
        patch(
            "unknown_world.services.image_understanding.load_prompt",
            return_value="Test prompt {count}",
        ) as mock_load,
    ):
        await service.analyze(b"fake_image" * 100, "image/png", Language.KO)

        # determine_item_countê°€ í˜¸ì¶œë˜ì—ˆëŠ”ì§€ í™•ì¸
        mock_count.assert_called_once()

        # load_promptê°€ "scan", "scan_instructions"ë¡œ í˜¸ì¶œë˜ì—ˆëŠ”ì§€ í™•ì¸
        mock_load.assert_any_call("scan", "scan_instructions", Language.KO)

        # ë¹„ì „ í˜¸ì¶œ ì‹œ í”„ë¡¬í”„íŠ¸ì— {count}ê°€ 3ìœ¼ë¡œ ì¹˜í™˜ë˜ì—ˆëŠ”ì§€ í™•ì¸
        call_args = service._genai_client.aio.models.generate_content.call_args
        prompt_part = call_args[1]["contents"][1]
        assert "Test prompt 3" in prompt_part.text
</file>

<file path="backend/tests/unit/test_orchestrator_repair.py">
"""U-018: Repair Loop ë° ë¹„ì¦ˆë‹ˆìŠ¤ ë£° ê²€ì¦ ë‹¨ìœ„ í…ŒìŠ¤íŠ¸."""

from unittest.mock import AsyncMock, patch

import pytest

from unknown_world.models.turn import (
    ActionDeck,
    AgentConsole,
    AgentPhase,
    ClientInfo,
    CurrencyAmount,
    EconomyOutput,
    EconomySnapshot,
    Language,
    RenderOutput,
    SafetyOutput,
    TurnInput,
    TurnOutput,
    UIOutput,
    ValidationBadge,
    WorldDelta,
)
from unknown_world.orchestrator.generate_turn_output import GenerationResult, GenerationStatus
from unknown_world.orchestrator.repair_loop import MAX_REPAIR_ATTEMPTS, run_repair_loop
from unknown_world.validation.business_rules import validate_business_rules


@pytest.fixture
def sample_turn_input() -> TurnInput:
    return TurnInput(
        language=Language.KO,
        text="í…ŒìŠ¤íŠ¸ ì…ë ¥",
        client=ClientInfo(viewport_w=1920, viewport_h=1080),
        economy_snapshot=EconomySnapshot(signal=100, memory_shard=5),
    )


@pytest.fixture
def valid_turn_output(sample_turn_input: TurnInput) -> TurnOutput:
    return TurnOutput(
        language=Language.KO,
        narrative="ì„±ê³µì ì¸ ë‚´ëŸ¬í‹°ë¸Œ",
        ui=UIOutput(action_deck=ActionDeck(cards=[]), objects=[]),
        world=WorldDelta(),
        render=RenderOutput(image_job=None),
        economy=EconomyOutput(
            cost=CurrencyAmount(signal=10, memory_shard=1),
            balance_after=CurrencyAmount(signal=90, memory_shard=4),
        ),
        safety=SafetyOutput(blocked=False),
        agent_console=AgentConsole(
            current_phase=AgentPhase.COMMIT,
            badges=[ValidationBadge.SCHEMA_OK],
            repair_count=0,
        ),
    )


@pytest.mark.asyncio
async def test_repair_loop_success_first_time(
    sample_turn_input: TurnInput, valid_turn_output: TurnOutput
) -> None:
    """ì´ˆê¸° ì‹œë„ì— ë°”ë¡œ ì„±ê³µí•˜ëŠ” ì¼€ì´ìŠ¤."""
    with patch("unknown_world.orchestrator.repair_loop.get_turn_output_generator") as mock_get_gen:
        mock_gen = mock_get_gen.return_value
        mock_gen.generate = AsyncMock(
            return_value=GenerationResult(status=GenerationStatus.SUCCESS, output=valid_turn_output)
        )

        result = await run_repair_loop(sample_turn_input)

        assert result.is_fallback is False
        assert result.repair_attempts == 0
        assert result.output.narrative == valid_turn_output.narrative
        assert ValidationBadge.SCHEMA_OK in result.badges


@pytest.mark.asyncio
async def test_repair_loop_schema_failure_then_success(
    sample_turn_input: TurnInput, valid_turn_output: TurnOutput
) -> None:
    """ìŠ¤í‚¤ë§ˆ ì‹¤íŒ¨ í›„ ë‘ ë²ˆì§¸ ì‹œë„ì— ì„±ê³µí•˜ëŠ” ì¼€ì´ìŠ¤."""
    with patch("unknown_world.orchestrator.repair_loop.get_turn_output_generator") as mock_get_gen:
        mock_gen = mock_get_gen.return_value
        # ì²« ë²ˆì§¸ëŠ” ì‹¤íŒ¨, ë‘ ë²ˆì§¸ëŠ” ì„±ê³µ
        mock_gen.generate = AsyncMock(
            side_effect=[
                GenerationResult(
                    status=GenerationStatus.SCHEMA_FAILURE, error_message="Invalid JSON"
                ),
                GenerationResult(status=GenerationStatus.SUCCESS, output=valid_turn_output),
            ]
        )

        result = await run_repair_loop(sample_turn_input)

        assert result.is_fallback is False
        assert result.repair_attempts == 1
        assert ValidationBadge.SCHEMA_FAIL not in result.badges
        assert ValidationBadge.SCHEMA_OK in result.badges


@pytest.mark.asyncio
async def test_repair_loop_business_failure_then_success(
    sample_turn_input: TurnInput, valid_turn_output: TurnOutput
) -> None:
    """ë¹„ì¦ˆë‹ˆìŠ¤ ë£°(ì–¸ì–´ ë¶ˆì¼ì¹˜) ì‹¤íŒ¨ í›„ ë‘ ë²ˆì§¸ ì‹œë„ì— ì„±ê³µí•˜ëŠ” ì¼€ì´ìŠ¤."""
    invalid_lang_output = valid_turn_output.model_copy(deep=True)
    invalid_lang_output.language = Language.EN  # KO ì…ë ¥ì— EN ì¶œë ¥ (ìœ„ë°˜)

    with patch("unknown_world.orchestrator.repair_loop.get_turn_output_generator") as mock_get_gen:
        mock_gen = mock_get_gen.return_value
        mock_gen.generate = AsyncMock(
            side_effect=[
                GenerationResult(status=GenerationStatus.SUCCESS, output=invalid_lang_output),
                GenerationResult(status=GenerationStatus.SUCCESS, output=valid_turn_output),
            ]
        )

        result = await run_repair_loop(sample_turn_input)

        assert result.is_fallback is False
        assert result.repair_attempts == 1
        # ì²« ì‹œë„ì—ì„œ SCHEMA_OKëŠ” ë°›ì•˜ì§€ë§Œ ë¹„ì¦ˆë‹ˆìŠ¤ ë£°ì—ì„œ ê±¸ë ¤ì•¼ í•¨
        assert result.repair_attempts == 1


@pytest.mark.asyncio
async def test_repair_loop_max_attempts_fallback(sample_turn_input: TurnInput) -> None:
    """ëª¨ë“  ì‹œë„ê°€ ì‹¤íŒ¨í•˜ì—¬ í´ë°±ì´ ë°˜í™˜ë˜ëŠ” ì¼€ì´ìŠ¤."""
    with patch("unknown_world.orchestrator.repair_loop.get_turn_output_generator") as mock_get_gen:
        mock_gen = mock_get_gen.return_value
        # ê³„ì† ìŠ¤í‚¤ë§ˆ ì‹¤íŒ¨
        mock_gen.generate = AsyncMock(
            return_value=GenerationResult(
                status=GenerationStatus.SCHEMA_FAILURE, error_message="Constant failure"
            )
        )

        result = await run_repair_loop(sample_turn_input)

        assert result.is_fallback is True
        assert result.repair_attempts == MAX_REPAIR_ATTEMPTS
        assert ValidationBadge.SCHEMA_FAIL in result.badges
        # í´ë°± ë‚´ëŸ¬í‹°ë¸Œ í™•ì¸
        assert "í˜¼ë€ìŠ¤ëŸ¬ìš´ ìˆœê°„" in result.output.narrative


@pytest.mark.asyncio
async def test_repair_loop_safety_blocked_immediate_fallback(sample_turn_input: TurnInput) -> None:
    """ì•ˆì „ ì°¨ë‹¨ ì‹œ ì¦‰ì‹œ í´ë°±ë˜ëŠ” ì¼€ì´ìŠ¤."""
    with patch("unknown_world.orchestrator.repair_loop.get_turn_output_generator") as mock_get_gen:
        mock_gen = mock_get_gen.return_value
        mock_gen.generate = AsyncMock(
            return_value=GenerationResult(
                status=GenerationStatus.SAFETY_BLOCKED, error_message="Safety block"
            )
        )

        result = await run_repair_loop(sample_turn_input)

        assert result.is_fallback is True
        assert result.repair_attempts == 0  # ì¦‰ì‹œ ì¤‘ë‹¨
        assert ValidationBadge.SAFETY_BLOCKED in result.badges
        assert result.output.safety.blocked is True


@pytest.mark.asyncio
async def test_validate_economy_negative_attempt(sample_turn_input: TurnInput) -> None:
    """ì¬í™”ê°€ ë¶€ì¡±í•œë° ë¹„ìš©ì„ ì²­êµ¬í•˜ì—¬ ìŒìˆ˜ ì”ì•¡ì„ ë§Œë“¤ë ¤ê³  ì‹œë„í•˜ëŠ” ê²½ìš°."""
    # snapshot: signal=100
    # cost: signal=120
    # balance_after: signal=-20 (ìœ„ë°˜)

    invalid_output = TurnOutput(
        language=Language.KO,
        narrative="ë¹„ì‹¼ í–‰ë™",
        ui=UIOutput(action_deck=ActionDeck(cards=[]), objects=[]),
        world=WorldDelta(),
        render=RenderOutput(image_job=None),
        economy=EconomyOutput(
            cost=CurrencyAmount(signal=120, memory_shard=0),
            balance_after=CurrencyAmount(
                signal=0, memory_shard=5
            ),  # 0ìœ¼ë¡œ ì–µì§€ ë³´ì • ë˜ëŠ” ìŒìˆ˜ í•„ë“œ ì˜¤ë¥˜
        ),
        safety=SafetyOutput(blocked=False),
        agent_console=AgentConsole(repair_count=0),
    )

    result = validate_business_rules(sample_turn_input, invalid_output)

    assert result.is_valid is False
    # Signal ì”ì•¡ ë¶ˆì¼ì¹˜ ë˜ëŠ” Credit ë¶ˆì¼ì¹˜ ê°ì§€
    assert any(
        "signal" in err["message"].lower() or "credit" in err["message"].lower()
        for err in result.errors
    )


@pytest.mark.asyncio
async def test_validate_economy_allow_credit(sample_turn_input: TurnInput) -> None:
    """ì”ì•¡ë³´ë‹¤ ë†’ì€ ë¹„ìš©ì´ì§€ë§Œ í¬ë ˆë”§ í•œë„ ë‚´ì¸ ê²½ìš° í—ˆìš© í™•ì¸ (U-079)."""
    # snapshot: signal=100
    # cost: signal=130 (ë¹š 30 í•„ìš”)
    # MAX_CREDIT = 50 ì´ë¯€ë¡œ í†µê³¼í•´ì•¼ í•¨

    valid_credit_output = TurnOutput(
        language=Language.KO,
        narrative="í¬ë ˆë”§ ì‚¬ìš©",
        ui=UIOutput(action_deck=ActionDeck(cards=[]), objects=[]),
        world=WorldDelta(),
        render=RenderOutput(image_job=None),
        economy=EconomyOutput(
            cost=CurrencyAmount(signal=130, memory_shard=0),
            balance_after=CurrencyAmount(signal=0, memory_shard=5),
            credit=30,  # ë¹š 30 ëª…ì‹œ
            low_balance_warning=True,
        ),
        safety=SafetyOutput(blocked=False),
        agent_console=AgentConsole(repair_count=0),
    )

    result = validate_business_rules(sample_turn_input, valid_credit_output)

    assert result.is_valid is True
    assert not result.errors
</file>

<file path="backend/tests/unit/test_u065_schema_simplification.py">
import pytest
from pydantic import ValidationError

from unknown_world.models.turn import (
    ActionCard,
    ActionDeck,
    AgentConsole,
    Language,
    TurnOutput,
    ValidationBadge,
    WorldDelta,
)


def test_turn_output_simplified_schema_validation_success():
    """ë‹¨ìˆœí™”ëœ ìŠ¤í‚¤ë§ˆë¥¼ ë”°ë¥´ëŠ” ì •ìƒì ì¸ ë°ì´í„° ê²€ì¦ ì„±ê³µ í™•ì¸"""
    data = {
        "language": "ko-KR",
        "narrative": "í…ŒìŠ¤íŠ¸ ë‚´ëŸ¬í‹°ë¸Œì…ë‹ˆë‹¤.",
        "economy": {
            "cost": {"signal": 5, "memory_shard": 0},
            "balance_after": {"signal": 95, "memory_shard": 5},
        },
        "safety": {"blocked": False},
        "ui": {
            "action_deck": {
                "cards": [
                    {
                        "id": "action_1",
                        "label": "í–‰ë™ 1",
                        "cost": {"signal": 1, "memory_shard": 0},
                        "risk": "low",
                        "enabled": True,
                        "is_alternative": False,
                    }
                ]
            },
            "objects": [],
        },
        "world": {
            "rules_changed": [],
            "inventory_added": [
                {
                    "id": "item_1",
                    "label": "ì•„ì´í…œ 1",
                    "description": "í…ŒìŠ¤íŠ¸ ì•„ì´í…œì…ë‹ˆë‹¤.",
                    "quantity": 1,
                }
            ],
            "quests_updated": [],
            "memory_pins": [],
        },
        "render": {"image_job": None},
        "agent_console": {"current_phase": "commit", "badges": ["schema_ok"], "repair_count": 0},
    }
    output = TurnOutput.model_validate(data)
    assert output.language == Language.KO
    assert len(output.ui.action_deck.cards) == 1
    # ì œê±°ëœ í•„ë“œê°€ ë°ì´í„°ì— ì—†ì–´ì•¼ í•¨ì„ í™•ì¸ (ActionCard)
    assert not hasattr(output.ui.action_deck.cards[0], "description")
    assert not hasattr(output.ui.action_deck.cards[0], "cost_estimate")


def test_turn_output_extra_fields_forbidden():
    """ì œê±°ëœ í•„ë“œê°€ í¬í•¨ë˜ì—ˆì„ ë•Œ extra='forbid' ì„¤ì •ì— ì˜í•´ ì‹¤íŒ¨í•˜ëŠ”ì§€ í™•ì¸ (ActionCard)"""
    # ActionCardëŠ” model_config = ConfigDict(extra="forbid")ê°€ ì„¤ì •ë˜ì–´ ìˆì§€ ì•ŠìŒ
    # í•˜ì§€ë§Œ TurnOutput ë° ì£¼ìš” í•˜ìœ„ ëª¨ë¸ë“¤ì€ ì„¤ì •ë˜ì–´ ìˆìŒ.
    # ActionCardì— í•„ë“œê°€ ì—†ìœ¼ë¯€ë¡œ validation ì‹œ ì—ëŸ¬ê°€ ë‚˜ê±°ë‚˜ ë¬´ì‹œë˜ì–´ì•¼ í•¨.
    # Pydantic v2ì—ì„œëŠ” í•„ë“œê°€ ì •ì˜ë˜ì§€ ì•Šìœ¼ë©´ ì—ëŸ¬ê°€ ë°œìƒí•¨ (extra="forbid"ì¸ ê²½ìš°)

    data = {
        "id": "action_1",
        "label": "í–‰ë™ 1",
        "description": "ì´ í•„ë“œëŠ” ì œê±°ë˜ì—ˆìŠµë‹ˆë‹¤.",  # ì œê±°ëœ í•„ë“œ
        "cost": {"signal": 1, "memory_shard": 0},
    }

    with pytest.raises(ValidationError):
        ActionCard.model_validate(data)

    # extra="forbid"ê°€ ì„¤ì •ë˜ì–´ ìˆë‹¤ë©´ 'extra fields not permitted' ì—ëŸ¬ ë°œìƒ
    # models/turn.pyë¥¼ í™•ì¸í•´ë³´ë©´ ActionCardì—ëŠ” extra="forbid"ê°€ ì—†ìœ¼ë¯€ë¡œ ë¬´ì‹œë  ìˆ˜ ìˆìŒ.
    # í•˜ì§€ë§Œ TurnOutput ìˆ˜ì¤€ì—ì„œ ê²€ì¦í•  ë•Œ ë¬¸ì œê°€ ë  ìˆ˜ ìˆìŒ.


def test_action_deck_max_length_violation():
    """ActionDeck.cardsì˜ max_length=5 ì œì•½ ìœ„ë°˜ í™•ì¸"""
    cards = [
        {"id": f"action_{i}", "label": f"í–‰ë™ {i}", "cost": {"signal": 1, "memory_shard": 0}}
        for i in range(6)  # 6ê°œ ìƒì„±
    ]

    with pytest.raises(ValidationError) as excinfo:
        ActionDeck(cards=cards)

    assert "List should have at most 5 items" in str(excinfo.value)


def test_world_delta_max_length_violations():
    """WorldDeltaì˜ ê°ì¢… ë°°ì—´ max_length ì œì•½ ìœ„ë°˜ í™•ì¸"""
    # rules_changed: max_length=3
    with pytest.raises(ValidationError):
        WorldDelta(rules_changed=[{"id": "r1", "label": "L"}] * 4)

    # inventory_added: max_length=5
    with pytest.raises(ValidationError):
        WorldDelta(inventory_added=["item"] * 6)

    # memory_pins: max_length=2
    with pytest.raises(ValidationError):
        WorldDelta(
            memory_pins=[{"id": "p1", "content": "C", "cost": {"signal": 1, "memory_shard": 0}}] * 3
        )


def test_agent_console_badges_max_length():
    """AgentConsole.badgesì˜ max_length=4 ì œì•½ ìœ„ë°˜ í™•ì¸"""
    with pytest.raises(ValidationError):
        AgentConsole(badges=[ValidationBadge.SCHEMA_OK] * 5)
</file>

<file path="frontend/src/api/image.ts">
/**
 * Unknown World - ì´ë¯¸ì§€ ìƒì„± API í´ë¼ì´ì–¸íŠ¸ (U-066)
 *
 * ì´ë¯¸ì§€ ìƒì„±ì„ í„´ê³¼ ë¶„ë¦¬í•˜ì—¬ ë¹„ë™ê¸°ì ìœ¼ë¡œ í˜¸ì¶œí•©ë‹ˆë‹¤.
 * í…ìŠ¤íŠ¸ í„´ì˜ TTFBë¥¼ ë¸”ë¡œí‚¹í•˜ì§€ ì•ŠìŠµë‹ˆë‹¤ (RULE-008).
 *
 * ì„¤ê³„ ì›ì¹™:
 *   - RULE-004: ì‹¤íŒ¨ ì‹œ ì•ˆì „í•œ í´ë°± (í…ìŠ¤íŠ¸-only ì§„í–‰)
 *   - RULE-007: í”„ë¡¬í”„íŠ¸ ì›ë¬¸ ë…¸ì¶œ ê¸ˆì§€ (ë¡œê·¸ì— í•´ì‹œë§Œ ê¸°ë¡)
 *   - RULE-008: í…ìŠ¤íŠ¸ ìš°ì„  + Lazy ì´ë¯¸ì§€ ì›ì¹™
 *
 * @module api/image
 */

import type { Language } from '../schemas/turn';

// =============================================================================
// ìƒìˆ˜ ì •ì˜
// =============================================================================

/** API ë² ì´ìŠ¤ URL */
const API_BASE_URL = import.meta.env.VITE_API_URL ?? 'http://localhost:8011';

/** ì´ë¯¸ì§€ ìƒì„± API ì—”ë“œí¬ì¸íŠ¸ */
const IMAGE_GENERATE_ENDPOINT = `${API_BASE_URL}/api/image/generate`;

// =============================================================================
// íƒ€ì… ì •ì˜
// =============================================================================

/** ì´ë¯¸ì§€ ìƒì„± ìƒíƒœ */
export type ImageGenerationStatus = 'pending' | 'generating' | 'completed' | 'failed' | 'skipped';

/** ëª¨ë¸ í‹°ì–´ë§ ë¼ë²¨ (U-066) */
export type ImageModelLabel = 'FAST' | 'QUALITY';

/** ì´ë¯¸ì§€ ìƒì„± ìš”ì²­ íŒŒë¼ë¯¸í„° */
export interface ImageGenerationRequest {
  /** ì´ë¯¸ì§€ ìƒì„± í”„ë¡¬í”„íŠ¸ (í•„ìˆ˜) */
  prompt: string;
  /** ì–¸ì–´ (ì—ëŸ¬ ë©”ì‹œì§€ìš©) */
  language?: Language;
  /** ê°€ë¡œì„¸ë¡œ ë¹„ìœ¨ */
  aspectRatio?: string;
  /** ì´ë¯¸ì§€ í¬ê¸° */
  imageSize?: string;
  /** ì°¸ì¡° ì´ë¯¸ì§€ ID ëª©ë¡ */
  referenceImageIds?: string[];
  /** ì°¸ì¡° ì´ë¯¸ì§€ URL (U-068: ì´ì „ í„´ ì´ë¯¸ì§€ë¥¼ ì°¸ì¡°í•˜ì—¬ ì—°ì†ì„± ìœ ì§€) */
  referenceImageUrl?: string;
  /** ì„¸ì…˜ ID */
  sessionId?: string;
  /** ì‹¤íŒ¨ ì‹œ ê±´ë„ˆë›°ê¸° (ê¸°ë³¸ê°’: true) */
  skipOnFailure?: boolean;
  /** ëª¨ë¸ í‹°ì–´ë§ ë¼ë²¨ (U-066: FAST/QUALITY) */
  modelLabel?: ImageModelLabel;
  /** í„´ ID (late-binding ê°€ë“œìš©, U-066) */
  turnId?: number;
}

/** ì´ë¯¸ì§€ ìƒì„± ì‘ë‹µ */
export interface ImageGenerationResponse {
  /** ì„±ê³µ ì—¬ë¶€ */
  success: boolean;
  /** ìƒì„± ìƒíƒœ */
  status: ImageGenerationStatus;
  /** ìƒì„±ëœ ì´ë¯¸ì§€ ID */
  imageId?: string;
  /** ìƒì„±ëœ ì´ë¯¸ì§€ URL */
  imageUrl?: string;
  /** ìƒíƒœ ë©”ì‹œì§€ */
  message?: string;
  /** ìƒì„± ì†Œìš” ì‹œê°„ (ms) */
  generationTimeMs: number;
  /** ì‚¬ìš©ëœ ëª¨ë¸ ë¼ë²¨ (U-066) */
  modelLabel: ImageModelLabel;
  /** ìš”ì²­ í„´ ID (U-066, late-binding ê°€ë“œìš©) */
  turnId?: number;
}

/** ì´ë¯¸ì§€ ìƒì„± ì˜µì…˜ */
export interface GenerateImageOptions {
  /** AbortSignal (ìš”ì²­ ì·¨ì†Œìš©) */
  signal?: AbortSignal;
  /** íƒ€ì„ì•„ì›ƒ (ms, ê¸°ë³¸ê°’: 60000) */
  timeout?: number;
}

// =============================================================================
// API í´ë¼ì´ì–¸íŠ¸ í•¨ìˆ˜
// =============================================================================

/**
 * ì´ë¯¸ì§€ë¥¼ ìƒì„±í•©ë‹ˆë‹¤.
 *
 * í„´ê³¼ ë¶„ë¦¬ëœ ë¹„ë™ê¸° í˜¸ì¶œë¡œ, í…ìŠ¤íŠ¸ ìŠ¤íŠ¸ë¦¬ë°ì„ ë¸”ë¡œí‚¹í•˜ì§€ ì•ŠìŠµë‹ˆë‹¤.
 * AbortControllerë¡œ ìš”ì²­ì„ ì·¨ì†Œí•  ìˆ˜ ìˆìŠµë‹ˆë‹¤.
 *
 * @param request - ì´ë¯¸ì§€ ìƒì„± ìš”ì²­ íŒŒë¼ë¯¸í„°
 * @param options - ìƒì„± ì˜µì…˜ (signal, timeout)
 * @returns ì´ë¯¸ì§€ ìƒì„± ì‘ë‹µ
 *
 * @example
 * ```ts
 * const controller = new AbortController();
 * const response = await generateImage(
 *   { prompt: 'A dark fantasy scene...', turnId: 5, modelLabel: 'FAST' },
 *   { signal: controller.signal }
 * );
 * if (response.success) {
 *   console.log('Image URL:', response.imageUrl);
 * }
 * // ì·¨ì†Œ ì‹œ: controller.abort();
 * ```
 */
export async function generateImage(
  request: ImageGenerationRequest,
  options: GenerateImageOptions = {},
): Promise<ImageGenerationResponse> {
  const { signal, timeout = 60000 } = options;

  // íƒ€ì„ì•„ì›ƒ AbortController (signalì´ ì—†ì„ ë•Œ ì‚¬ìš©)
  const timeoutController = new AbortController();
  const timeoutId = setTimeout(() => timeoutController.abort(), timeout);

  // ì™¸ë¶€ signalê³¼ íƒ€ì„ì•„ì›ƒ signal ì¤‘ ë¨¼ì € abortë˜ëŠ” ê²ƒì„ ì‚¬ìš©
  const combinedSignal = signal ?? timeoutController.signal;

  try {
    const response = await fetch(IMAGE_GENERATE_ENDPOINT, {
      method: 'POST',
      headers: {
        'Content-Type': 'application/json',
      },
      body: JSON.stringify({
        prompt: request.prompt,
        language: request.language ?? 'ko-KR',
        aspect_ratio: request.aspectRatio ?? '16:9',
        image_size: request.imageSize ?? '1024x1024',
        reference_image_ids: request.referenceImageIds ?? [],
        reference_image_url: request.referenceImageUrl ?? null,
        session_id: request.sessionId ?? null,
        skip_on_failure: request.skipOnFailure ?? true,
        model_label: request.modelLabel ?? 'QUALITY',
        turn_id: request.turnId ?? null,
      }),
      signal: combinedSignal,
    });

    clearTimeout(timeoutId);

    if (!response.ok) {
      // HTTP ì—ëŸ¬ ì‘ë‹µ ì²˜ë¦¬
      const errorText = await response.text().catch(() => 'Unknown error');
      return {
        success: false,
        status: 'failed',
        message: `HTTP ${response.status}: ${errorText}`,
        generationTimeMs: 0,
        modelLabel: request.modelLabel ?? 'QUALITY',
        turnId: request.turnId,
      };
    }

    const data = await response.json();

    // snake_case â†’ camelCase ë³€í™˜
    return {
      success: data.success,
      status: data.status,
      imageId: data.image_id,
      imageUrl: data.image_url,
      message: data.message,
      generationTimeMs: data.generation_time_ms ?? 0,
      modelLabel: data.model_label ?? request.modelLabel ?? 'QUALITY',
      turnId: data.turn_id ?? request.turnId,
    };
  } catch (error) {
    clearTimeout(timeoutId);

    // AbortError ì²˜ë¦¬ (ì·¨ì†Œë¨)
    if (error instanceof Error && error.name === 'AbortError') {
      return {
        success: false,
        status: 'skipped',
        message: 'ì´ë¯¸ì§€ ìƒì„±ì´ ì·¨ì†Œë˜ì—ˆìŠµë‹ˆë‹¤.',
        generationTimeMs: 0,
        modelLabel: request.modelLabel ?? 'QUALITY',
        turnId: request.turnId,
      };
    }

    // ê¸°íƒ€ ë„¤íŠ¸ì›Œí¬ ì—ëŸ¬
    return {
      success: false,
      status: 'failed',
      message: error instanceof Error ? error.message : 'ì´ë¯¸ì§€ ìƒì„± ì¤‘ ì˜¤ë¥˜ê°€ ë°œìƒí–ˆìŠµë‹ˆë‹¤.',
      generationTimeMs: 0,
      modelLabel: request.modelLabel ?? 'QUALITY',
      turnId: request.turnId,
    };
  }
}

/**
 * ì´ë¯¸ì§€ ìƒì„± ìš”ì²­ì„ ìƒì„±í•˜ê³  AbortControllerë¥¼ ë°˜í™˜í•©ë‹ˆë‹¤.
 *
 * í„´ ì™„ë£Œ í›„ ì´ë¯¸ì§€ ìƒì„±ì„ ì‹œì‘í•˜ê³ , ìƒˆ í„´ ì‹œì‘ ì‹œ ì·¨ì†Œí•  ìˆ˜ ìˆìŠµë‹ˆë‹¤.
 *
 * @param request - ì´ë¯¸ì§€ ìƒì„± ìš”ì²­ íŒŒë¼ë¯¸í„°
 * @param onComplete - ì™„ë£Œ ì½œë°±
 * @param onError - ì—ëŸ¬ ì½œë°±
 * @returns AbortController (ì·¨ì†Œìš©)
 *
 * @example
 * ```ts
 * const controller = startImageGeneration(
 *   { prompt: 'A dark fantasy scene...', turnId: 5 },
 *   (response) => {
 *     if (response.success) {
 *       worldStore.setSceneImage(response.imageUrl, response.turnId);
 *     }
 *   },
 *   (error) => console.error('Image generation failed:', error)
 * );
 *
 * // ìƒˆ í„´ ì‹œì‘ ì‹œ ì´ì „ ìš”ì²­ ì·¨ì†Œ
 * controller.abort();
 * ```
 */
export function startImageGeneration(
  request: ImageGenerationRequest,
  onComplete: (response: ImageGenerationResponse) => void,
  onError?: (error: Error) => void,
): AbortController {
  const controller = new AbortController();

  generateImage(request, { signal: controller.signal })
    .then(onComplete)
    .catch((error) => {
      if (error instanceof Error && error.name !== 'AbortError') {
        onError?.(error);
      }
    });

  return controller;
}
</file>

<file path="frontend/src/api/scanner.test.ts">
import { describe, it, expect, vi, beforeEach } from 'vitest';
import {
  scanImage,
  validateFile,
  isSupportedImageFile,
  candidateToInventoryItem,
  MAX_FILE_SIZE_BYTES,
  type ItemCandidate,
} from './scanner';

describe('Scanner API Client', () => {
  beforeEach(() => {
    vi.clearAllMocks();
    global.fetch = vi.fn();
  });

  describe('validateFile', () => {
    it('returns null for valid image files', () => {
      const file = new File([''], 'test.png', { type: 'image/png' });
      expect(validateFile(file)).toBeNull();
    });

    it('returns error for unsupported MIME types', () => {
      const file = new File([''], 'test.txt', { type: 'text/plain' });
      expect(validateFile(file)).toContain('ì§€ì›í•˜ì§€ ì•ŠëŠ” íŒŒì¼ í˜•ì‹');
    });

    it('returns error for files exceeding max size', () => {
      const largeFile = {
        size: MAX_FILE_SIZE_BYTES + 1,
        type: 'image/png',
        name: 'large.png',
      } as File;
      expect(validateFile(largeFile)).toContain('íŒŒì¼ì´ ë„ˆë¬´ í½ë‹ˆë‹¤');
    });
  });

  describe('isSupportedImageFile', () => {
    it('returns true for jpg, png, webp, gif', () => {
      expect(isSupportedImageFile(new File([''], 't.jpg', { type: 'image/jpeg' }))).toBe(true);
      expect(isSupportedImageFile(new File([''], 't.png', { type: 'image/png' }))).toBe(true);
      expect(isSupportedImageFile(new File([''], 't.webp', { type: 'image/webp' }))).toBe(true);
      expect(isSupportedImageFile(new File([''], 't.gif', { type: 'image/gif' }))).toBe(true);
    });

    it('returns false for others', () => {
      expect(isSupportedImageFile(new File([''], 't.pdf', { type: 'application/pdf' }))).toBe(
        false,
      );
    });
  });

  describe('scanImage', () => {
    const mockFile = new File(['mock content'], 'test.png', { type: 'image/png' });
    const mockSuccessResponse = {
      success: true,
      status: 'completed',
      caption: 'A test scan',
      objects: [],
      item_candidates: [{ id: 'item-1', label: 'Test Item', item_type: 'tool' }],
      analysis_time_ms: 100,
      language: 'ko-KR',
    };

    it('returns success data when API call succeeds', async () => {
      (global.fetch as unknown as ReturnType<typeof vi.fn>).mockResolvedValue({
        ok: true,
        json: async () => mockSuccessResponse,
      });

      const result = await scanImage(mockFile, 'ko-KR');

      expect(result.success).toBe(true);
      if (result.success) {
        expect(result.data.caption).toBe('A test scan');
        expect(result.data.item_candidates).toHaveLength(1);
      }
    });

    it('returns error when fetch fails', async () => {
      (global.fetch as unknown as ReturnType<typeof vi.fn>).mockResolvedValue({
        ok: false,
        status: 500,
        statusText: 'Internal Server Error',
      });

      const result = await scanImage(mockFile, 'ko-KR');

      expect(result.success).toBe(false);
      if (!result.success) {
        expect(result.error).toContain('ì„œë²„ ì˜¤ë¥˜: 500');
      }
    });

    it('returns error when response schema is invalid', async () => {
      (global.fetch as unknown as ReturnType<typeof vi.fn>).mockResolvedValue({
        ok: true,
        json: async () => ({ invalid: 'data' }),
      });

      const result = await scanImage(mockFile, 'ko-KR');

      expect(result.success).toBe(false);
      if (!result.success) {
        expect(result.error).toContain('ë°ì´í„° í˜•ì‹ì´ ì˜¬ë°”ë¥´ì§€ ì•ŠìŠµë‹ˆë‹¤');
      }
    });

    it('handles network error', async () => {
      (global.fetch as unknown as ReturnType<typeof vi.fn>).mockRejectedValue(
        new Error('Network error'),
      );

      const result = await scanImage(mockFile, 'ko-KR');

      expect(result.success).toBe(false);
      if (!result.success) {
        expect(result.error).toContain('ë„¤íŠ¸ì›Œí¬ ì˜¤ë¥˜');
      }
    });
  });

  describe('candidateToInventoryItem', () => {
    it('correctly maps ItemCandidate to InventoryItem with pending iconStatus (U-075)', () => {
      const candidate = {
        id: 'c-1',
        label: 'Rusty Key',
        description: 'An old key',
        item_type: 'key',
      };
      const item = candidateToInventoryItem(candidate);

      expect(item).toEqual({
        id: 'c-1',
        name: 'Rusty Key',
        description: 'An old key',
        icon: 'ğŸ”‘',
        quantity: 1,
        iconStatus: 'pending', // U-075: ì•„ì´ì½˜ ìƒì„± íŠ¸ë¦¬ê±°
      });
    });

    it('uses fallback icon for unknown item types', () => {
      const candidate: ItemCandidate = {
        id: 'c-2',
        label: 'Something',
        description: '',
        item_type: 'unknown',
      };
      const item = candidateToInventoryItem(candidate);
      expect(item.icon).toBe('ğŸ“¦');
      expect(item.iconStatus).toBe('pending'); // U-075
    });
  });
});
</file>

<file path="frontend/src/api/turnStream.economy.test.ts">
import { describe, it, expect, vi, beforeEach } from 'vitest';
import { executeTurnStream } from './turnStream';

describe('U-063: Economy Balance Preservation in executeTurnStream', () => {
  const economySnapshot = { signal: 150, memory_shard: 5 };

  const mockInput = {
    language: 'ko-KR' as const,
    text: 'Hello',
    action_id: null,
    click: null,
    drop: null,
    client: { viewport_w: 100, viewport_h: 100, theme: 'dark' as const },
    economy_snapshot: economySnapshot,
    previous_image_url: null,
  };

  const mockCallbacks = {
    onFinal: vi.fn(),
    onError: vi.fn(),
    onComplete: vi.fn(),
  };

  beforeEach(() => {
    vi.clearAllMocks();
    global.fetch = vi.fn();
  });

  it('should preserve economy balance when final event has invalid data', async () => {
    const encoder = new TextEncoder();
    const stream = new ReadableStream({
      start(controller) {
        controller.enqueue(
          encoder.encode(
            JSON.stringify({
              type: 'final',
              data: {
                // narrative í•„ë“œ ëˆ„ë½ ë“± ìŠ¤í‚¤ë§ˆ ìœ„ë°˜
                language: 'ko-KR',
                economy: {
                  cost: { signal: 0, memory_shard: 0 },
                  balance_after: { signal: 0, memory_shard: 0 },
                },
              },
            }) + '\n',
          ),
        );
        controller.close();
      },
    });

    (global.fetch as unknown as ReturnType<typeof vi.fn>).mockResolvedValue({
      ok: true,
      body: stream,
    });

    await executeTurnStream(mockInput, mockCallbacks);

    expect(mockCallbacks.onFinal).toHaveBeenCalled();
    const finalEvent = mockCallbacks.onFinal.mock.calls[0][0];
    expect(finalEvent.data.economy.balance_after.signal).toBe(150);
    expect(finalEvent.data.economy.balance_after.memory_shard).toBe(5);
    expect(finalEvent.data.agent_console.badges).toContain('schema_fail');
  });

  it('should preserve economy balance on network error (fetch rejection)', async () => {
    (global.fetch as unknown as ReturnType<typeof vi.fn>).mockRejectedValue(
      new Error('Network failure'),
    );

    await executeTurnStream(mockInput, mockCallbacks);

    expect(mockCallbacks.onError).toHaveBeenCalled();
    expect(mockCallbacks.onFinal).toHaveBeenCalled();

    const finalEvent = mockCallbacks.onFinal.mock.calls[0][0];
    expect(finalEvent.data.economy.balance_after.signal).toBe(150);
    expect(finalEvent.data.economy.balance_after.memory_shard).toBe(5);
    expect(finalEvent.data.narrative).toContain('ì„œë²„ ì—°ê²°ì— ì‹¤íŒ¨');
  });
});
</file>

<file path="frontend/src/components/AgentConsole.test.tsx">
import { describe, it, expect, vi } from 'vitest';
import { render, screen, fireEvent } from '@testing-library/react';
import { AgentConsole } from './AgentConsole';

// Mock i18n
vi.mock('react-i18next', () => ({
  useTranslation: () => ({
    t: (key: string) => key,
  }),
}));

// Mock dependencies
type MockSelector<T> = (state: unknown) => T;

vi.mock('../stores/agentStore', () => ({
  useAgentStore: <T,>(selector: MockSelector<T>) =>
    selector({
      phases: [],
      badges: [],
      repairCount: 0,
      error: null,
      isStreaming: false,
      modelLabel: 'FAST',
    }),
  selectIsStreaming: (state: { isStreaming: boolean }) => state.isStreaming,
  selectPhases: (state: { phases: unknown[] }) => state.phases,
  selectBadges: (state: { badges: unknown[] }) => state.badges,
  selectRepairCount: (state: { repairCount: number }) => state.repairCount,
  selectError: (state: { error: unknown }) => state.error,
  selectModelLabel: (state: { modelLabel: string }) => state.modelLabel,
}));

describe('AgentConsole (U-082)', () => {
  it('should start in collapsed state by default', () => {
    render(<AgentConsole />);

    // Badges panel (always visible) should be present
    expect(screen.getByText('agent.console.badges')).toBeInTheDocument();

    // Toggle button should show expand text
    expect(screen.getByText('agent.console.expand')).toBeInTheDocument();

    // Phase queue (expanded only) should NOT be present
    expect(screen.queryByText('agent.console.queue')).not.toBeInTheDocument();
  });

  it('should expand and show details when toggle button is clicked', () => {
    render(<AgentConsole />);

    const toggleButton = screen.getByRole('button', { name: /agent\.console\.expand/i });

    // Click to expand
    fireEvent.click(toggleButton);

    // Now phase queue should be present
    expect(screen.getByText('agent.console.queue')).toBeInTheDocument();
    // Toggle button should show collapse text
    expect(screen.getByText('agent.console.collapse')).toBeInTheDocument();

    // Click to collapse
    fireEvent.click(toggleButton);

    // Phase queue should be gone again
    expect(screen.queryByText('agent.console.queue')).not.toBeInTheDocument();
  });
});
</file>

<file path="frontend/src/components/AgentConsole.tsx">
/**
 * Unknown World - Agent Console ì»´í¬ë„ŒíŠ¸.
 *
 * ì—ì´ì „íŠ¸í˜• ì‹œìŠ¤í…œì„ì„ UIë¡œ ì¦ëª…í•˜ê¸° ìœ„í•œ ì»´í¬ë„ŒíŠ¸ì…ë‹ˆë‹¤.
 * Plan/Queue/Badges/Auto-repair íŠ¸ë ˆì´ìŠ¤ë¥¼ ì‹¤ì‹œê°„ìœ¼ë¡œ í‘œì‹œí•©ë‹ˆë‹¤.
 *
 * U-082: Agent Console ì¶•ì†Œ/í™•ì¥ í† ê¸€
 *   - ê¸°ë³¸ ì ‘í˜(collapsed): Badges + StreamingStatus + ModelLabelë§Œ compact í‘œì‹œ
 *   - í™•ì¥(expanded): Plan/Queue/RepairTrace ë“± ìƒì„¸ ì •ë³´ í‘œì‹œ
 *   - Q1: Option A (ê¸°ë³¸ ì ‘í˜), Q3: Option A (ìƒíƒœ ì €ì¥í•˜ì§€ ì•ŠìŒ)
 *
 * ì„¤ê³„ ì›ì¹™:
 *   - RULE-008: ë‹¨ê³„/ë°°ì§€/ë³µêµ¬ë§Œ ë³´ì—¬ì¤Œ (í”„ë¡¬í”„íŠ¸/ë‚´ë¶€ ì¶”ë¡  ë…¸ì¶œ ê¸ˆì§€)
 *   - RULE-002: ê²Œì„ UIë¡œ í‘œí˜„ (ì±„íŒ… ë²„ë¸” ê¸ˆì§€)
 *
 * @module components/AgentConsole
 */

import { useState } from 'react';
import { useTranslation } from 'react-i18next';
import {
  useAgentStore,
  selectIsStreaming,
  selectPhases,
  selectBadges,
  selectRepairCount,
  selectError,
  selectModelLabel,
  type PhaseInfo,
} from '../stores/agentStore';
import type { ValidationBadge, ModelLabel } from '../schemas/turn';

// =============================================================================
// ìƒìˆ˜ ì •ì˜
// =============================================================================

/** ë‹¨ê³„ í‘œì‹œ ì´ë¦„ i18n í‚¤ */
const PHASE_KEYS: Record<string, string> = {
  parse: 'agent.console.phase.parse',
  validate: 'agent.console.phase.validate',
  plan: 'agent.console.phase.plan',
  resolve: 'agent.console.phase.resolve',
  render: 'agent.console.phase.render',
  verify: 'agent.console.phase.verify',
  commit: 'agent.console.phase.commit',
};

/** ë°°ì§€ í‘œì‹œ ì •ë³´ (i18n í‚¤ ê¸°ë°˜) */
const BADGE_INFO: Record<ValidationBadge, { labelKey: string; isOk: boolean }> = {
  schema_ok: { labelKey: 'agent.console.badge.schema', isOk: true },
  schema_fail: { labelKey: 'agent.console.badge.schema', isOk: false },
  economy_ok: { labelKey: 'agent.console.badge.economy', isOk: true },
  economy_fail: { labelKey: 'agent.console.badge.economy', isOk: false },
  safety_ok: { labelKey: 'agent.console.badge.safety', isOk: true },
  safety_blocked: { labelKey: 'agent.console.badge.safety', isOk: false },
  consistency_ok: { labelKey: 'agent.console.badge.consistency', isOk: true },
  consistency_fail: { labelKey: 'agent.console.badge.consistency', isOk: false },
};

/** ëª¨ë¸ ë¼ë²¨ í‘œì‹œ ì •ë³´ (U-069: FAST/QUALITY) */
const MODEL_LABEL_INFO: Record<ModelLabel, { labelKey: string; icon: string; colorClass: string }> =
  {
    FAST: { labelKey: 'agent.console.model.fast', icon: '\u26A1', colorClass: 'model-fast' },
    QUALITY: {
      labelKey: 'agent.console.model.quality',
      icon: '\u2605',
      colorClass: 'model-quality',
    },
    CHEAP: { labelKey: 'agent.console.model.cheap', icon: '\u{1F4B0}', colorClass: 'model-cheap' },
    REF: { labelKey: 'agent.console.model.ref', icon: '\u{1F4F7}', colorClass: 'model-ref' },
  };

// =============================================================================
// í•˜ìœ„ ì»´í¬ë„ŒíŠ¸
// =============================================================================

/** ë‹¨ê³„ ìƒíƒœ ì•„ì´ì½˜ */
function PhaseIcon({ status }: { status: PhaseInfo['status'] }) {
  switch (status) {
    case 'pending':
      return <span className="phase-icon pending">â—‹</span>;
    case 'in_progress':
      return <span className="phase-icon in-progress">â—</span>;
    case 'completed':
      return <span className="phase-icon completed">â—</span>;
    case 'failed':
      return <span className="phase-icon failed">âœ•</span>;
    default:
      return <span className="phase-icon">â—‹</span>;
  }
}

/** ë‹¨ê³„ í í•­ëª© */
function PhaseQueueItem({ phase }: { phase: PhaseInfo }) {
  const { t } = useTranslation();
  const key = PHASE_KEYS[phase.name];
  const label = key ? t(key) : phase.name;
  const statusClass = `phase-item ${phase.status}`;

  return (
    <div className={statusClass}>
      <PhaseIcon status={phase.status} />
      <span className="phase-label">{label}</span>
    </div>
  );
}

/** ë‹¨ê³„ í */
function PhaseQueue() {
  const { t } = useTranslation();
  const phases = useAgentStore(selectPhases);

  return (
    <div className="phase-queue">
      <div className="queue-label">{t('agent.console.queue')}</div>
      <div className="queue-items">
        {phases.map((phase) => (
          <PhaseQueueItem key={phase.name} phase={phase} />
        ))}
      </div>
    </div>
  );
}

/** ë°°ì§€ ì•„ì´í…œ */
function BadgeItem({ badge }: { badge: ValidationBadge }) {
  const { t } = useTranslation();
  const info = BADGE_INFO[badge];
  if (!info) return null;

  const statusClass = info.isOk ? 'badge-ok' : 'badge-fail';
  const statusText = info.isOk ? t('agent.console.badge.ok') : t('agent.console.badge.fail');
  const iconName = info.isOk ? 'badge-ok-24.png' : 'badge-fail-24.png';
  const fallbackIcon = info.isOk ? 'âœ“' : 'âœ—';

  return (
    <div className={`badge-item ${statusClass}`}>
      <span className="badge-label">{t(info.labelKey)}</span>
      <span className="badge-status">
        <span className="icon-wrapper">
          <img
            src={`/ui/icons/${iconName}`}
            alt=""
            aria-hidden="true"
            className="badge-icon-img"
            onError={(e) => e.currentTarget.classList.add('hidden')}
          />
          <span className="icon-fallback" style={{ fontSize: '0.625rem' }}>
            {fallbackIcon}
          </span>
        </span>
        {statusText}
      </span>
    </div>
  );
}

/** ë°°ì§€ íŒ¨ë„ */
function BadgesPanel() {
  const { t } = useTranslation();
  const badges = useAgentStore(selectBadges);

  if (badges.length === 0) {
    return (
      <div className="badges-panel">
        <div className="badges-label">{t('agent.console.badges')}</div>
        <div className="badges-empty">{t('agent.console.badges_empty')}</div>
      </div>
    );
  }

  return (
    <div className="badges-panel">
      <div className="badges-label">{t('agent.console.badges')}</div>
      <div className="badges-grid">
        {badges.map((badge, index) => (
          <BadgeItem key={`${badge}-${index}`} badge={badge} />
        ))}
      </div>
    </div>
  );
}

/** Auto-repair íŠ¸ë ˆì´ìŠ¤ */
function RepairTrace() {
  const { t } = useTranslation();
  const repairCount = useAgentStore(selectRepairCount);
  const isStreaming = useAgentStore(selectIsStreaming);

  if (repairCount === 0 && !isStreaming) {
    return null;
  }

  return (
    <div className="repair-trace">
      <span className="repair-label">{t('agent.console.repair')}</span>
      <span className="repair-count">#{repairCount}</span>
      {repairCount > 0 && (
        <span className="repair-status text-warning"> {t('agent.console.repaired')}</span>
      )}
    </div>
  );
}

/**
 * ëª¨ë¸ ë¼ë²¨ ë°°ì§€ (U-069: FAST/QUALITY í‘œì‹œ)
 *
 * í˜„ì¬ í…ìŠ¤íŠ¸ ìƒì„±ì— ì‚¬ìš©ëœ ëª¨ë¸ì„ ì‹œê°ì ìœ¼ë¡œ í‘œì‹œí•©ë‹ˆë‹¤.
 * - FAST: ë¹ ë¥¸ ì‘ë‹µ, ê¸°ë³¸ ë¹„ìš© (âš¡)
 * - QUALITY: ê³ í’ˆì§ˆ ì‘ë‹µ, 2ë°° ë¹„ìš© (â˜…)
 */
function ModelLabelBadge() {
  const { t } = useTranslation();
  const modelLabel = useAgentStore(selectModelLabel);
  const info = MODEL_LABEL_INFO[modelLabel];

  if (!info) return null;

  // i18n í‚¤ê°€ ì—†ìœ¼ë©´ í´ë°± í…ìŠ¤íŠ¸ ì‚¬ìš©
  const label = t(info.labelKey, { defaultValue: modelLabel });

  return (
    <div className={`model-label-badge ${info.colorClass}`}>
      <span className="model-icon">{info.icon}</span>
      <span className="model-text">{label}</span>
    </div>
  );
}

/** ì—ëŸ¬ í‘œì‹œ */
function ErrorDisplay() {
  const error = useAgentStore(selectError);

  if (!error) return null;

  return (
    <div className="agent-error">
      <span className="error-icon">âš </span>
      <span className="error-message">{error.message}</span>
      {error.code && <span className="error-code">[{error.code}]</span>}
    </div>
  );
}

/** ìŠ¤íŠ¸ë¦¬ë° ìƒíƒœ í‘œì‹œ */
function StreamingStatus() {
  const { t } = useTranslation();
  const isStreaming = useAgentStore(selectIsStreaming);

  return (
    <div className="streaming-status">
      <span className={`status-dot ${isStreaming ? 'active' : ''}`} />
      <span className="status-text">
        {isStreaming ? t('agent.console.status.processing') : t('agent.console.status.idle')}
      </span>
    </div>
  );
}

// =============================================================================
// ë©”ì¸ ì»´í¬ë„ŒíŠ¸
// =============================================================================

/**
 * Agent Console ì»´í¬ë„ŒíŠ¸.
 *
 * U-082: ê¸°ë³¸ ì ‘í˜(collapsed)ìœ¼ë¡œ ì‹œì‘í•˜ë©°, Badges + StreamingStatusë§Œ compact í‘œì‹œ.
 * í† ê¸€ ë²„íŠ¼ìœ¼ë¡œ Plan/Queue/RepairTrace ë“± ìƒì„¸ ì •ë³´ë¥¼ í¼ì¹  ìˆ˜ ìˆìŠµë‹ˆë‹¤.
 *
 * Q1: Option A - ê¸°ë³¸ ì ‘í˜
 * Q3: Option A - ìƒíƒœ ì €ì¥í•˜ì§€ ì•ŠìŒ (ë§¤ë²ˆ ê¸°ë³¸ ìƒíƒœë¡œ ì‹œì‘)
 *
 * RULE-008ì— ë”°ë¼ í”„ë¡¬í”„íŠ¸/ë‚´ë¶€ ì¶”ë¡ ì€ ë…¸ì¶œí•˜ì§€ ì•ŠìŠµë‹ˆë‹¤.
 * U-037: data-ui-importance="critical" ë§ˆí‚¹ìœ¼ë¡œ ê°€ë…ì„± ë³´ì¥
 * U-069: í˜„ì¬ ì‚¬ìš© ì¤‘ì¸ ëª¨ë¸ ë¼ë²¨(FAST/QUALITY) í‘œì‹œ ì¶”ê°€
 */
export function AgentConsole() {
  const { t } = useTranslation();
  // U-082 Q1 Option A: ê¸°ë³¸ ì ‘í˜, Q3 Option A: ì €ì¥í•˜ì§€ ì•ŠìŒ
  const [isExpanded, setIsExpanded] = useState(false);

  return (
    <div
      className={`agent-console-content ${isExpanded ? 'agent-console-expanded' : 'agent-console-collapsed'}`}
      data-ui-importance="critical"
    >
      {/* U-082: í•­ìƒ í‘œì‹œ ì˜ì—­ - StreamingStatus + Badges + ModelLabel + í† ê¸€ */}
      <div className="agent-console-always">
        <div className="agent-console-summary">
          <StreamingStatus />
          <ModelLabelBadge />
        </div>
        <BadgesPanel />
        <button
          type="button"
          className="agent-console-toggle"
          onClick={() => setIsExpanded(!isExpanded)}
          aria-expanded={isExpanded}
          aria-label={isExpanded ? t('agent.console.collapse') : t('agent.console.expand')}
          title={isExpanded ? t('agent.console.collapse') : t('agent.console.expand')}
        >
          <span className="toggle-icon">{isExpanded ? 'â–²' : 'â–¼'}</span>
          <span className="toggle-text">
            {isExpanded ? t('agent.console.collapse') : t('agent.console.expand')}
          </span>
        </button>
      </div>

      {/* U-082: í™•ì¥ ì‹œì—ë§Œ í‘œì‹œ - Plan/Queue/RepairTrace */}
      {isExpanded && (
        <div className="agent-console-details">
          <PhaseQueue />
          <RepairTrace />
        </div>
      )}

      {/* ì—ëŸ¬ëŠ” í•­ìƒ í‘œì‹œ */}
      <ErrorDisplay />
    </div>
  );
}

export default AgentConsole;
</file>

<file path="frontend/src/components/Hotspot.test.tsx">
import { describe, it, expect, vi, beforeEach } from 'vitest';
import { render, screen, fireEvent } from '@testing-library/react';
import { Hotspot } from './Hotspot';
import { useOnboardingStore } from '../stores/onboardingStore';
import type { SceneObject } from '../schemas/turn';

// i18next ëª¨í‚¹
vi.mock('react-i18next', () => ({
  useTranslation: () => ({
    t: (key: string) => key,
  }),
}));

// dnd-kit ëª¨í‚¹
vi.mock('@dnd-kit/core', () => ({
  useDroppable: () => ({
    isOver: false,
    setNodeRef: vi.fn(),
  }),
}));

// box2d ìœ í‹¸ ëª¨í‚¹
vi.mock('../utils/box2d', () => ({
  box2dToPixel: vi.fn(() => ({
    top: 100,
    left: 100,
    width: 200,
    height: 200,
  })),
}));

describe('Hotspot UX - Hover Hint', () => {
  const mockObject: SceneObject = {
    id: 'test-obj',
    label: 'í…ŒìŠ¤íŠ¸ ì˜¤ë¸Œì íŠ¸',
    box_2d: { ymin: 100, xmin: 100, ymax: 300, xmax: 300 },
    interaction_hint: 'ì¡°ì‚¬ ê°€ëŠ¥',
  };

  const mockCanvasSize = { width: 1000, height: 1000 };
  const mockOnClick = vi.fn();

  beforeEach(() => {
    vi.clearAllMocks();
    useOnboardingStore.getState().resetOnboarding();
  });

  it('ë§ˆìš°ìŠ¤ ì§„ì… ì‹œ onboardingStoreì˜ ì¹´ìš´íŠ¸ ì¦ê°€ ì•¡ì…˜ì´ í˜¸ì¶œë˜ì–´ì•¼ í•œë‹¤', () => {
    render(
      <Hotspot
        object={mockObject}
        canvasSize={mockCanvasSize}
        onClick={mockOnClick}
        disabled={false}
      />,
    );

    const hotspot = screen.getByRole('button');
    fireEvent.mouseEnter(hotspot);

    expect(useOnboardingStore.getState().hotspotHintCount).toBe(1);
  });

  it('íŒíŠ¸ í‘œì‹œ ì¡°ê±´(ì²« Në²ˆ)ì„ ë§Œì¡±í•  ë•Œ InteractionHintê°€ ë Œë”ë§ë˜ì–´ì•¼ í•œë‹¤', () => {
    render(
      <Hotspot
        object={mockObject}
        canvasSize={mockCanvasSize}
        onClick={mockOnClick}
        disabled={false}
      />,
    );

    const hotspot = screen.getByRole('button');
    fireEvent.mouseEnter(hotspot);

    // interaction.hotspot_click í‚¤ê°€ ë Œë”ë§ë˜ëŠ”ì§€ í™•ì¸ (InteractionHint ì»´í¬ë„ŒíŠ¸ ë‚´ì˜ í…ìŠ¤íŠ¸)
    expect(screen.getByText('interaction.hotspot_click')).toBeInTheDocument();
  });

  it('íŒíŠ¸ ì„ê³„ê°’ì„ ì´ˆê³¼í•˜ë©´ InteractionHintê°€ ë Œë”ë§ë˜ì§€ ì•Šì•„ì•¼ í•œë‹¤', () => {
    // ì„ê³„ê°’ê¹Œì§€ ì¹´ìš´íŠ¸ ì˜¬ë¦¬ê¸°
    for (let i = 0; i < 3; i++) {
      useOnboardingStore.getState().incrementHotspotHint();
    }
    expect(useOnboardingStore.getState().hotspotHintCount).toBe(3);

    render(
      <Hotspot
        object={mockObject}
        canvasSize={mockCanvasSize}
        onClick={mockOnClick}
        disabled={false}
      />,
    );

    const hotspot = screen.getByRole('button');
    fireEvent.mouseEnter(hotspot);

    // íŒíŠ¸ê°€ ë³´ì´ì§€ ì•Šì•„ì•¼ í•¨
    expect(screen.queryByText('interaction.hotspot_click')).not.toBeInTheDocument();
  });

  it('ë¹„í™œì„±í™” ìƒíƒœì¼ ë•ŒëŠ” ì¹´ìš´íŠ¸ê°€ ì¦ê°€í•˜ì§€ ì•Šê³  íŒíŠ¸ë„ ë³´ì´ì§€ ì•Šì•„ì•¼ í•œë‹¤', () => {
    render(
      <Hotspot
        object={mockObject}
        canvasSize={mockCanvasSize}
        onClick={mockOnClick}
        disabled={true}
      />,
    );

    const hotspot = screen.getByRole('button');
    fireEvent.mouseEnter(hotspot);

    expect(useOnboardingStore.getState().hotspotHintCount).toBe(0);
    expect(screen.queryByText('interaction.hotspot_click')).not.toBeInTheDocument();
  });
});
</file>

<file path="frontend/src/components/NarrativeFeed.tsx">
/**
 * Unknown World - NarrativeFeed ì»´í¬ë„ŒíŠ¸ (U-066: íƒ€ì´í•‘ íš¨ê³¼)
 *
 * ë‚´ëŸ¬í‹°ë¸Œ í…ìŠ¤íŠ¸ì— íƒ€ì´í•‘(Typewriter) íš¨ê³¼ë¥¼ ì ìš©í•˜ì—¬,
 * ì´ë¯¸ì§€ ìƒì„± ì§€ì—°ì„ ìì—°ìŠ¤ëŸ½ê²Œ í¡ìˆ˜í•©ë‹ˆë‹¤.
 *
 * ì„¤ê³„ ì›ì¹™:
 *   - ìŠ¤íŠ¸ë¦¬ë°/ë¡œë”© ì¤‘: ëŠë¦° íƒ€ì´í•‘ ì†ë„ (TARGET_DURATION ~12ì´ˆ)
 *   - ìœ íœ´ ìƒíƒœ: ë¹ ë¥¸ íƒ€ì´í•‘ ì†ë„ (TARGET_DURATION ~2.5ì´ˆ)
 *   - Fast-forward: í´ë¦­/Enter/Spaceë¡œ ì¦‰ì‹œ ì „ì²´ í‘œì‹œ
 *   - ì ‘ê·¼ì„±: prefers-reduced-motion ì„¤ì • ì¡´ì¤‘
 *
 * @module components/NarrativeFeed
 */

import { useEffect, useRef, useState, useCallback, useMemo } from 'react';
import { useTranslation } from 'react-i18next';
import type { NarrativeEntry } from '../stores/worldStore';

// =============================================================================
// ìƒìˆ˜ ì •ì˜ (U-066)
// =============================================================================

/** íƒ€ì´í•‘ ì¸í„°ë²Œ (ms) - íƒ€ìê¸° ë¦¬ë“¬ê°ì„ ìœ„í•´ 90ms */
const TYPING_TICK_MS = 90;

/** ìŠ¤íŠ¸ë¦¬ë°/ë¡œë”© ì¤‘ ëŠë¦° ëª¨ë“œ ëª©í‘œ ì‹œê°„ (ms) - ì´ë¯¸ì§€ ìƒì„± ëŒ€ê¸° ì¤‘ ì²œì²œíˆ */
const TARGET_DURATION_MS_WHILE_STREAMING = 30000;

/** ìœ íœ´ ìƒíƒœ ëª©í‘œ ì‹œê°„ (ms) - íƒ€ìê¸° ëŠë‚Œ ìœ ì§€ */
const TARGET_DURATION_MS_IDLE = 20000;

/** ìµœì†Œ CPS (characters per second) - ë§¤ìš° ëŠë¦° íƒ€ì´í•‘ í—ˆìš© */
const MIN_CPS = 3;

/** ìµœëŒ€ CPS - íƒ€ìê¸° ì†ë„ (ì´ˆë‹¹ 10ê¸€ì, íƒ€ë‹¥íƒ€ë‹¥ ëŠë‚Œ) */
const MAX_CPS = 10;

// =============================================================================
// ìœ í‹¸ë¦¬í‹° í•¨ìˆ˜
// =============================================================================

/** ê°’ì„ min~max ë²”ìœ„ë¡œ ì œí•œí•©ë‹ˆë‹¤. */
function clamp(value: number, min: number, max: number): number {
  return Math.max(min, Math.min(max, value));
}

// =============================================================================
// íƒ€ì… ì •ì˜
// =============================================================================

interface NarrativeFeedProps {
  entries: NarrativeEntry[];
  streamingText: string;
  /** U-066: ìŠ¤íŠ¸ë¦¬ë° ì¤‘ì¸ì§€ ì—¬ë¶€ (íƒ€ì´í•‘ ì†ë„ ê²°ì •ì— ì‚¬ìš©) */
  isStreaming?: boolean;
  /** U-066: ì´ë¯¸ì§€ ë¡œë”© ì¤‘ì¸ì§€ ì—¬ë¶€ (íƒ€ì´í•‘ ì†ë„ ê²°ì •ì— ì‚¬ìš©) */
  isImageLoading?: boolean;
}

// =============================================================================
// ì»¤ìŠ¤í…€ í›…: useTypewriter (U-066)
// =============================================================================

/**
 * íƒ€ì´í•‘ íš¨ê³¼ë¥¼ ìœ„í•œ ì»¤ìŠ¤í…€ í›…
 *
 * @param targetText - íƒ€ì´í•‘ ëŒ€ìƒ í…ìŠ¤íŠ¸
 * @param shouldBuyTime - ëŠë¦° íƒ€ì´í•‘ ëª¨ë“œ ì‚¬ìš© ì—¬ë¶€
 * @returns íƒ€ì´í•‘ ìƒíƒœ ë° ì œì–´ í•¨ìˆ˜
 */
function useTypewriter(targetText: string, shouldBuyTime: boolean) {
  const [typedLen, setTypedLen] = useState(0);
  const [fastForward, setFastForward] = useState(false);
  const [lastTargetText, setLastTargetText] = useState('');

  // prefers-reduced-motion ê°ì§€
  const [prefersReducedMotion, setPrefersReducedMotion] = useState(() => {
    if (typeof window === 'undefined') return false;
    return window.matchMedia('(prefers-reduced-motion: reduce)').matches;
  });

  // CPS ê³„ì‚°
  const cps = useMemo(() => {
    if (!targetText || targetText.length === 0) return MIN_CPS;
    const durationMs = shouldBuyTime ? TARGET_DURATION_MS_WHILE_STREAMING : TARGET_DURATION_MS_IDLE;
    const calculatedCps = targetText.length / (durationMs / 1000);
    return clamp(calculatedCps, MIN_CPS, MAX_CPS);
  }, [targetText, shouldBuyTime]);

  // í‹±ë‹¹ ë¬¸ì ìˆ˜ ê³„ì‚°
  const charsPerTick = useMemo(() => {
    return Math.max(1, Math.round((cps * TYPING_TICK_MS) / 1000));
  }, [cps]);

  // reduced-motion ë¯¸ë””ì–´ ì¿¼ë¦¬ ê°ì§€
  useEffect(() => {
    if (typeof window === 'undefined') return;

    const mediaQuery = window.matchMedia('(prefers-reduced-motion: reduce)');
    const handleChange = (e: MediaQueryListEvent) => {
      setPrefersReducedMotion(e.matches);
    };

    mediaQuery.addEventListener('change', handleChange);
    return () => mediaQuery.removeEventListener('change', handleChange);
  }, []);

  // íƒ€ì´í•‘ ëŒ€ìƒ í…ìŠ¤íŠ¸ê°€ ë³€ê²½ë˜ë©´ ìƒíƒœ ì´ˆê¸°í™”
  // ì™¸ë¶€ ë°ì´í„°(targetText) ë³€ê²½ì— ëŒ€í•œ ë™ê¸°í™”ì´ë¯€ë¡œ eslint ê·œì¹™ ì˜ˆì™¸ ì ìš©
  useEffect(() => {
    if (targetText !== lastTargetText) {
      // eslint-disable-next-line react-hooks/set-state-in-effect -- ì™¸ë¶€ ë°ì´í„° ë™ê¸°í™”
      setLastTargetText(targetText);
      setTypedLen(0);
      setFastForward(false);
    }
  }, [targetText, lastTargetText]);

  // íƒ€ì´í•‘ ë£¨í”„
  useEffect(() => {
    // reduced-motionì´ê±°ë‚˜ fastForwardë©´ ì¦‰ì‹œ ì „ì²´ í‘œì‹œ
    const shouldSkipTyping = prefersReducedMotion || fastForward;

    // ì´ë¯¸ ì™„ë£Œëœ ê²½ìš°
    if (typedLen >= targetText.length) {
      return;
    }

    // ì• ë‹ˆë©”ì´ì…˜ ë¹„í™œì„±í™” ì‹œ ì¦‰ì‹œ ì™„ë£Œ
    if (shouldSkipTyping) {
      // ë‹¤ìŒ í”„ë ˆì„ì—ì„œ ìƒíƒœ ì—…ë°ì´íŠ¸ (ë Œë”ë§ ì¤‘ setState ë°©ì§€)
      const rafId = requestAnimationFrame(() => {
        setTypedLen(targetText.length);
      });
      return () => cancelAnimationFrame(rafId);
    }

    const intervalId = setInterval(() => {
      setTypedLen((prev) => {
        const next = prev + charsPerTick;
        return next >= targetText.length ? targetText.length : next;
      });
    }, TYPING_TICK_MS);

    return () => clearInterval(intervalId);
  }, [targetText, typedLen, charsPerTick, prefersReducedMotion, fastForward]);

  // í‘œì‹œí•  í…ìŠ¤íŠ¸ ê³„ì‚°
  const visibleText = useMemo(() => {
    if (prefersReducedMotion || fastForward) {
      return targetText;
    }
    return targetText.slice(0, typedLen);
  }, [targetText, typedLen, prefersReducedMotion, fastForward]);

  // íƒ€ì´í•‘ ì§„í–‰ ì¤‘ì¸ì§€ ì—¬ë¶€
  const isTyping = typedLen < targetText.length && !prefersReducedMotion && !fastForward;

  return {
    visibleText,
    isTyping,
    fastForward: () => setFastForward(true),
  };
}

// =============================================================================
// ì»´í¬ë„ŒíŠ¸ êµ¬í˜„
// =============================================================================

export function NarrativeFeed({
  entries,
  streamingText,
  isStreaming = false,
  isImageLoading = false,
}: NarrativeFeedProps) {
  const { t } = useTranslation();
  const feedRef = useRef<HTMLDivElement>(null);

  // U-066: íƒ€ì´í•‘ ëŒ€ìƒ í…ìŠ¤íŠ¸ ê²°ì •
  // ìŠ¤íŠ¸ë¦¬ë° ì¤‘ì´ë©´ streamingText, ì•„ë‹ˆë©´ ë§ˆì§€ë§‰ entriesì˜ í…ìŠ¤íŠ¸
  const targetText = useMemo(() => {
    if (streamingText) {
      return streamingText;
    }
    if (entries.length > 0) {
      return entries[entries.length - 1].text;
    }
    return '';
  }, [streamingText, entries]);

  // U-066: ì‹œê°„ì„ ë²Œì–´ì•¼ í•˜ëŠ”ì§€ ì—¬ë¶€ (ëŠë¦° íƒ€ì´í•‘)
  const shouldBuyTime = isStreaming || isImageLoading;

  // U-066: íƒ€ì´í•‘ íš¨ê³¼ í›… ì‚¬ìš©
  const { visibleText, isTyping, fastForward } = useTypewriter(targetText, shouldBuyTime);

  // U-066: Fast-forward í•¸ë“¤ëŸ¬
  const handleFastForward = useCallback(() => {
    if (isTyping) {
      fastForward();
    }
  }, [isTyping, fastForward]);

  // U-066: í‚¤ë³´ë“œ ì´ë²¤íŠ¸ í•¸ë“¤ëŸ¬
  const handleKeyDown = useCallback(
    (e: React.KeyboardEvent) => {
      if ((e.key === 'Enter' || e.key === ' ') && isTyping) {
        e.preventDefault();
        fastForward();
      }
    },
    [isTyping, fastForward],
  );

  // ìƒˆ ì—”íŠ¸ë¦¬ ì¶”ê°€ ì‹œ ìŠ¤í¬ë¡¤
  useEffect(() => {
    if (feedRef.current) {
      feedRef.current.scrollTop = feedRef.current.scrollHeight;
    }
  }, [entries, visibleText]);

  // U-066: ë§ˆì§€ë§‰ ì—”íŠ¸ë¦¬ íƒ€ì´í•‘ ì¤‘ ì¤‘ë³µ í‘œì‹œ ë°©ì§€
  // ìŠ¤íŠ¸ë¦¬ë° ì¤‘ì´ ì•„ë‹ ë•Œ, ë§ˆì§€ë§‰ entriesì™€ íƒ€ì´í•‘ í…ìŠ¤íŠ¸ê°€ ê°™ìœ¼ë©´ entriesì—ì„œ ë§ˆì§€ë§‰ í•­ëª© ìˆ¨ê¹€
  const shouldHideLastEntry = !streamingText && entries.length > 0 && isTyping;

  return (
    <div
      className="narrative-feed"
      ref={feedRef}
      onClick={handleFastForward}
      onKeyDown={handleKeyDown}
      role="log"
      aria-live="polite"
      tabIndex={0}
      title={isTyping ? t('narrative.fast_forward_title') : undefined}
      aria-label={isTyping ? t('narrative.fast_forward_aria') : undefined}
    >
      {entries.map((entry, index) => {
        // U-066: ë§ˆì§€ë§‰ ì—”íŠ¸ë¦¬ íƒ€ì´í•‘ ì¤‘ ìˆ¨ê¹€ ì²˜ë¦¬
        const isLastEntry = index === entries.length - 1;
        if (shouldHideLastEntry && isLastEntry) {
          return null;
        }

        // U-070: ì—”íŠ¸ë¦¬ íƒ€ì…ì— ë”°ë¥¸ í´ë˜ìŠ¤ ë° ìŠ¤íƒ€ì¼ ê²°ì •
        const entryType = entry.type ?? 'narrative';
        const isActionLog = entryType === 'action_log';
        const isSystem = entryType === 'system';
        const entryClassName = [
          'narrative-entry',
          isActionLog && 'action-log-entry',
          isSystem && 'system-entry',
        ]
          .filter(Boolean)
          .join(' ');

        return (
          <div key={`${entry.turn}-${index}`} className={entryClassName}>
            {/* U-070: ì•¡ì…˜ ë¡œê·¸ëŠ” â–¶ ì•„ì´ì½˜ í‘œì‹œ, í„´ ë¼ë²¨ ìˆ¨ê¹€ */}
            {isActionLog ? (
              <span className="action-log-icon" aria-hidden="true">
                â–¶
              </span>
            ) : (
              <span className="narrative-timestamp">
                {t('narrative.turn_label', { turn: entry.turn })}
              </span>
            )}
            <span className="narrative-text">{entry.text}</span>
          </div>
        );
      })}

      {/* U-066: íƒ€ì´í•‘ íš¨ê³¼ê°€ ì ìš©ëœ í˜„ì¬ í…ìŠ¤íŠ¸ */}
      {(streamingText || shouldHideLastEntry) && (
        <div className={`narrative-entry ${streamingText ? 'streaming' : 'typing'}`}>
          <span className="narrative-timestamp">
            {streamingText
              ? t('narrative.streaming_label')
              : t('narrative.turn_label', { turn: entries[entries.length - 1]?.turn ?? 0 })}
          </span>
          <span className="narrative-text">{visibleText}</span>
          {isTyping && <span className="cursor-blink">â–Œ</span>}
        </div>
      )}
    </div>
  );
}
</file>

<file path="frontend/src/components/QuestPanel.test.tsx">
import { describe, it, expect, beforeEach, vi } from 'vitest';
import { render, screen } from '@testing-library/react';
import { QuestPanel } from './QuestPanel';
import { useWorldStore } from '../stores/worldStore';

// i18next ëª¨í‚¹ (t í•¨ìˆ˜ê°€ í‚¤ë¥¼ ë°˜í™˜í•˜ë„ë¡)
vi.mock('react-i18next', () => ({
  useTranslation: () => ({
    t: (key: string) => key,
  }),
  initReactI18next: {
    type: '3rdParty',
    init: () => {},
  },
}));

describe('QuestPanel (U-013)', () => {
  beforeEach(() => {
    useWorldStore.getState().reset();
  });

  it('í€˜ìŠ¤íŠ¸ê°€ ì—†ì„ ë•Œ ììœ  íƒìƒ‰ ìƒíƒœë¥¼ í‘œì‹œí•´ì•¼ í•œë‹¤', () => {
    render(<QuestPanel />);
    // U-078: ë¹ˆ ìƒíƒœ â†’ "ììœ  íƒìƒ‰" ì•ˆë‚´ë¡œ ë³€ê²½
    expect(screen.getByText('quest.free_exploration')).toBeInTheDocument();
    expect(screen.getByText('quest.free_exploration_desc')).toBeInTheDocument();
  });

  it('ì§„í–‰ ì¤‘ì¸ í€˜ìŠ¤íŠ¸ë¥¼ ëª©ë¡ì— í‘œì‹œí•´ì•¼ í•œë‹¤', () => {
    useWorldStore.setState({
      quests: [
        {
          id: 'q1',
          label: 'ì•¡í‹°ë¸Œ í€˜ìŠ¤íŠ¸',
          is_completed: false,
          description: null,
          is_main: false,
          progress: 0,
          reward_signal: 0,
        },
      ],
    });

    render(<QuestPanel />);
    expect(screen.getByText('ì•¡í‹°ë¸Œ í€˜ìŠ¤íŠ¸')).toBeInTheDocument();
  });

  it('ì™„ë£Œëœ í€˜ìŠ¤íŠ¸ë¥¼ ëª©ë¡ì— í‘œì‹œí•´ì•¼ í•œë‹¤', () => {
    useWorldStore.setState({
      quests: [
        {
          id: 'q2',
          label: 'ì™„ë£Œëœ í€˜ìŠ¤íŠ¸',
          is_completed: true,
          description: null,
          is_main: false,
          progress: 100,
          reward_signal: 10,
        },
      ],
    });

    render(<QuestPanel />);
    expect(screen.getByText('ì™„ë£Œëœ í€˜ìŠ¤íŠ¸')).toBeInTheDocument();
  });

  it('ì£¼ ëª©í‘œì™€ ì„¸ë¶€ ëª©í‘œë¥¼ êµ¬ë¶„í•˜ì—¬ í‘œì‹œí•´ì•¼ í•œë‹¤', () => {
    useWorldStore.setState({
      quests: [
        {
          id: 'q1',
          label: 'ì£¼ ëª©í‘œ',
          is_completed: false,
          description: 'ì£¼ ëª©í‘œ ì„¤ëª…',
          is_main: true,
          progress: 50,
          reward_signal: 100,
        },
        {
          id: 'q2',
          label: 'ì„¸ë¶€ ëª©í‘œ',
          is_completed: false,
          description: null,
          is_main: false,
          progress: 0,
          reward_signal: 20,
        },
      ],
    });

    render(<QuestPanel />);
    expect(screen.getByText('ì£¼ ëª©í‘œ')).toBeInTheDocument();
    expect(screen.getByText('ì„¸ë¶€ ëª©í‘œ')).toBeInTheDocument();
  });
});
</file>

<file path="frontend/src/demo/useDemoInitializer.ts">
import { useEffect } from 'react';
import { useTranslation } from 'react-i18next';
import { useInventoryStore } from '../stores/inventoryStore';
import { useWorldStore } from '../stores/worldStore';
import type { Quest, WorldRule } from '../schemas/turn';
import type { MutationEvent } from '../stores/worldStore';
import {
  DEMO_INVENTORY_ITEMS,
  DEMO_SCENE_OBJECTS,
  DEMO_QUESTS,
  DEMO_RULES,
  getDemoItemNameKey,
  isDemoEnvironment,
} from '../demo/demoFixtures';

/**
 * ë°ëª¨ í™˜ê²½ì—ì„œ ì´ˆê¸° mock ë°ì´í„°ë¥¼ ë¡œë“œí•˜ëŠ” í›… (RU-003-Q5, U-013).
 */
export function useDemoInitializer() {
  const { t } = useTranslation();
  const { items: inventoryItems, addItems: addInventoryItems } = useInventoryStore();
  const worldStore = useWorldStore();
  const {
    sceneObjects,
    setSceneObjects,
    narrativeEntries,
    initialize: initializeWorld,
    quests,
    activeRules,
  } = worldStore;

  useEffect(() => {
    // ì›”ë“œ ì´ˆê¸°í™” (í™˜ì˜ ë©”ì‹œì§€)
    if (narrativeEntries.length === 0) {
      initializeWorld(t('narrative.welcome'));
    }

    // DEV: ë°ëª¨ìš© mock ë°ì´í„° ì´ˆê¸°í™” (RU-003-Q5: DEV ê°€ë“œ + i18n í‚¤ ê¸°ë°˜)
    if (isDemoEnvironment()) {
      // ë°ëª¨ìš© mock ì¸ë²¤í† ë¦¬ ì´ˆê¸°í™” (U-011)
      // U-075: ë°ëª¨ ì•„ì´í…œì€ ì´ëª¨ì§€ ì•„ì´ì½˜ì„ ìœ ì§€í•˜ë¯€ë¡œ iconStatus: 'completed'ë¡œ ì„¤ì •
      if (inventoryItems.length === 0) {
        const demoInventory = DEMO_INVENTORY_ITEMS.map((item) => ({
          id: item.id,
          name: t(getDemoItemNameKey(item.id)),
          icon: item.icon,
          quantity: item.quantity,
          iconStatus: 'completed' as const, // U-075: ì•„ì´ì½˜ ìƒì„± íŠ¸ë¦¬ê±° ë°©ì§€
        }));
        addInventoryItems(demoInventory);
      }

      // ë°ëª¨ìš© mock Scene Objects ì´ˆê¸°í™” (U-010)
      if (sceneObjects.length === 0) {
        const demoSceneObjects = DEMO_SCENE_OBJECTS.map((obj) => ({
          id: obj.id,
          label: t(obj.labelKey),
          box_2d: obj.box_2d,
          interaction_hint: t(obj.hintKey),
        }));
        setSceneObjects(demoSceneObjects);
      }

      // ë°ëª¨ìš© mock í€˜ìŠ¤íŠ¸ ì´ˆê¸°í™” (U-013, U-078)
      if (quests.length === 0) {
        const demoQuests: Quest[] = DEMO_QUESTS.map((q) => ({
          id: q.id,
          label: t(q.labelKey),
          is_completed: q.is_completed,
          description: q.descriptionKey ? t(q.descriptionKey) : null,
          is_main: q.is_main ?? false,
          progress: q.progress ?? 0,
          reward_signal: q.reward_signal ?? 0,
        }));
        useWorldStore.setState({ quests: demoQuests });
      }

      // ë°ëª¨ìš© mock ê·œì¹™ ì´ˆê¸°í™” (U-013)
      if (activeRules.length === 0) {
        const demoRules: WorldRule[] = DEMO_RULES.map((r) => ({
          id: r.id,
          label: t(r.labelKey),
          description: r.descriptionKey ? t(r.descriptionKey) : null,
        }));
        // ë°ëª¨ ë®¤í…Œì´ì…˜ íƒ€ì„ë¼ì¸ ìƒì„± (ê·œì¹™ ì¶”ê°€ ì´ë²¤íŠ¸)
        const now = Date.now();
        const demoMutations: MutationEvent[] = DEMO_RULES.map((r, index) => ({
          turn: 0,
          ruleId: r.id,
          type: 'added' as const,
          label: t(r.labelKey),
          description: r.descriptionKey ? t(r.descriptionKey) : undefined,
          timestamp: now - index * 1000, // ì‹œê°„ ìˆœì„œ êµ¬ë¶„ìš©
        }));
        useWorldStore.setState({
          activeRules: demoRules,
          mutationTimeline: demoMutations,
        });
      }
    }
    // eslint-disable-next-line react-hooks/exhaustive-deps
  }, [t]);
}
</file>

<file path="frontend/src/i18n-scenario.test.ts">
import { describe, it, expect, beforeEach, vi } from 'vitest';
import { getSessionLanguage, startSessionFromProfile } from './save/sessionLifecycle';
import { buildTurnInput } from './turn/turnRunner';
import { SAVEGAME_STORAGE_KEY, SAVEGAME_VERSION } from './save/constants';
import { PROFILE_EXPLORER } from './data/demoProfiles';
import { useWorldStore } from './stores/worldStore';
import { useInventoryStore } from './stores/inventoryStore';
import { useEconomyStore } from './stores/economyStore';

// i18n ëª¨ë“ˆ mock
vi.mock('./i18n', async () => {
  const actual = await vi.importActual('./i18n');
  return {
    ...actual,
    changeLanguage: vi.fn().mockResolvedValue(undefined),
    getResolvedLanguage: vi.fn().mockReturnValue('ko-KR'),
  };
});

describe('U-044[Mvp] i18n Session SSOT Scenario', () => {
  const mockT = (key: string) => `translated-${key}`;

  beforeEach(() => {
    localStorage.clear();
    vi.clearAllMocks();

    // Store ì´ˆê¸°í™”
    useWorldStore.getState().reset();
    useInventoryStore.getState().reset();
    useEconomyStore.getState().reset();
  });

  describe('Language SSOT (getSessionLanguage)', () => {
    it('SaveGameì´ ì—†ì„ ë•ŒëŠ” ê¸°ë³¸ ì–¸ì–´(ko-KR)ë¥¼ ë°˜í™˜í•´ì•¼ í•œë‹¤', () => {
      expect(getSessionLanguage()).toBe('ko-KR');
    });

    it('SaveGameì— ì €ì¥ëœ ì–¸ì–´ê°€ ìˆìœ¼ë©´ í•´ë‹¹ ì–¸ì–´ë¥¼ ë°˜í™˜í•´ì•¼ í•œë‹¤ (en-US)', () => {
      const saveGame = {
        version: SAVEGAME_VERSION,
        language: 'en-US',
        profileId: 'explorer',
        savedAt: new Date().toISOString(),
        economy: { signal: 100, memory_shard: 5 },
        economyLedger: [],
        turnCount: 1,
        narrativeHistory: [],
        inventory: [],
        quests: [],
        activeRules: [],
        mutationTimeline: [],
        sceneObjects: [],
      };
      localStorage.setItem(SAVEGAME_STORAGE_KEY, JSON.stringify(saveGame));

      expect(getSessionLanguage()).toBe('en-US');
    });

    it('i18n resolvedLanguageê°€ ë³€ê²½ë˜ì–´ë„ SaveGame ì–¸ì–´ë¥¼ ìš°ì„ í•´ì•¼ í•œë‹¤ (ë“œë¦¬í”„íŠ¸ ë°©ì§€)', () => {
      const saveGame = {
        version: SAVEGAME_VERSION,
        language: 'ko-KR',
        profileId: 'explorer',
        savedAt: new Date().toISOString(),
        economy: { signal: 100, memory_shard: 5 },
        economyLedger: [],
        turnCount: 1,
        narrativeHistory: [],
        inventory: [],
        quests: [],
        activeRules: [],
        mutationTimeline: [],
        sceneObjects: [],
      };
      localStorage.setItem(SAVEGAME_STORAGE_KEY, JSON.stringify(saveGame));

      // i18n.getResolvedLanguage()ê°€ 'en-US'ë¥¼ ë°˜í™˜í•˜ë„ë¡ ìƒí™© ê°€ì • (ë“œë¦¬í”„íŠ¸)
      // ì‹¤ì œë¡œëŠ” mockì´ë¯€ë¡œ ì§ì ‘ ë¹„êµëŠ” ì–´ë µì§€ë§Œ logicìƒ validSaveGame í™•ì¸ ìš°ì„ ìˆœìœ„ ê²€ì¦
      expect(getSessionLanguage()).toBe('ko-KR');
    });
  });

  describe('TurnInput Language Injection', () => {
    it('buildTurnInputì€ ì™¸ë¶€ì—ì„œ ì£¼ì…ëœ ì–¸ì–´ë¥¼ ì‚¬ìš©í•´ì•¼ í•œë‹¤', () => {
      const turnInput = buildTurnInput({
        text: 'hello',
        economySnapshot: { signal: 100, memory_shard: 0 },
        theme: 'dark',
        language: 'en-US', // ì£¼ì…ëœ ì–¸ì–´
      });

      expect(turnInput.language).toBe('en-US');
    });
  });

  describe('Session Language Policy (Toggle = Reset)', () => {
    it('startSessionFromProfile í˜¸ì¶œ ì‹œ ëª…ì‹œì  ì–¸ì–´ë¥¼ SaveGameì— ë°˜ì˜í•´ì•¼ í•œë‹¤', () => {
      startSessionFromProfile({
        profile: PROFILE_EXPLORER,

        t: mockT,

        language: 'en-US',
      });

      const saved = JSON.parse(localStorage.getItem(SAVEGAME_STORAGE_KEY)!);

      expect(saved.language).toBe('en-US');

      expect(getSessionLanguage()).toBe('en-US');
    });
  });

  describe('turnStream Error Message Language', () => {
    it('ë„¤íŠ¸ì›Œí¬ ì—ëŸ¬ ì‹œ ì…ë ¥ ì–¸ì–´ì— ë§ëŠ” í•œêµ­ì–´ ë©”ì‹œì§€ë¥¼ ë°˜í™˜í•´ì•¼ í•œë‹¤ (ko-KR)', async () => {
      const { executeTurnStream } = await import('./api/turnStream');

      const mockInput = {
        language: 'ko-KR' as const,
        text: 'Hello',
        action_id: null,
        click: null,
        drop: null,
        client: { viewport_w: 100, viewport_h: 100, theme: 'dark' as const },
        economy_snapshot: { signal: 100, memory_shard: 0 },
        previous_image_url: null,
      };

      const onError = vi.fn();

      const onFinal = vi.fn();

      // fetch ì‹¤íŒ¨ ìœ ë„

      vi.stubGlobal('fetch', vi.fn().mockRejectedValue(new Error('Network Error')));

      await executeTurnStream(mockInput, { onError, onFinal });

      // onError ë³´ë‹¤ëŠ” onFinalì˜ narrativeë¥¼ ê²€ì¦ (createClientFallbackTurnOutput)

      // onErrorëŠ” error.messageë¥¼ ê·¸ëŒ€ë¡œ ì“°ë¯€ë¡œ 'Network Error'ê°€ ë‚˜ì˜´

      expect(onFinal).toHaveBeenCalledWith(
        expect.objectContaining({
          data: expect.objectContaining({
            language: 'ko-KR',

            narrative: '[ì‹œìŠ¤í…œ] ì„œë²„ ì—°ê²°ì— ì‹¤íŒ¨í–ˆìŠµë‹ˆë‹¤. ë‹¤ì‹œ ì‹œë„í•´ ì£¼ì„¸ìš”.',
          }),
        }),
      );

      vi.unstubAllGlobals();
    });

    it('ë„¤íŠ¸ì›Œí¬ ì—ëŸ¬ ì‹œ ì…ë ¥ ì–¸ì–´ì— ë§ëŠ” ì˜ì–´ ë©”ì‹œì§€ë¥¼ ë°˜í™˜í•´ì•¼ í•œë‹¤ (en-US)', async () => {
      const { executeTurnStream } = await import('./api/turnStream');

      const mockInput = {
        language: 'en-US' as const,
        text: 'Hello',
        action_id: null,
        click: null,
        drop: null,
        client: { viewport_w: 100, viewport_h: 100, theme: 'dark' as const },
        economy_snapshot: { signal: 100, memory_shard: 0 },
        previous_image_url: null,
      };

      const onFinal = vi.fn();

      // fetch ì‹¤íŒ¨ ìœ ë„

      vi.stubGlobal('fetch', vi.fn().mockRejectedValue(new Error('Network Error')));

      await executeTurnStream(mockInput, { onFinal });

      expect(onFinal).toHaveBeenCalledWith(
        expect.objectContaining({
          data: expect.objectContaining({
            language: 'en-US',

            narrative: '[System] Failed to connect to server. Please try again.',
          }),
        }),
      );

      vi.unstubAllGlobals();
    });
  });
});
</file>

<file path="frontend/src/save/sessionLifecycle.test.ts">
import { describe, it, expect, beforeEach, vi } from 'vitest';
import {
  bootstrapSession,
  startSessionFromProfile,
  continueSession,
  resetToCurrentProfile,
  clearSessionAndReturnToSelect,
  saveCurrentSession,
  getInitialProfileId,
} from './sessionLifecycle';
import { useWorldStore } from '../stores/worldStore';
import { useInventoryStore } from '../stores/inventoryStore';
import { useEconomyStore } from '../stores/economyStore';
import { SAVEGAME_STORAGE_KEY, CURRENT_PROFILE_KEY, SAVEGAME_VERSION } from './constants';
import { PROFILE_EXPLORER } from '../data/demoProfiles';
import * as i18nModule from '../i18n';

// i18n ëª¨ë“ˆ mock
vi.mock('../i18n', async () => {
  const actual = await vi.importActual('../i18n');
  return {
    ...actual,
    changeLanguage: vi.fn().mockResolvedValue(undefined),
    getResolvedLanguage: vi.fn().mockReturnValue('ko-KR'),
  };
});

describe('sessionLifecycle (RU-004[Mvp])', () => {
  const mockT = (key: string) => `translated-${key}`;

  beforeEach(() => {
    localStorage.clear();
    vi.clearAllMocks();

    // Store ì´ˆê¸°í™”
    useWorldStore.getState().reset();
    useInventoryStore.getState().reset();
    useEconomyStore.getState().reset();
  });

  describe('bootstrapSession', () => {
    it('ì„¸ì´ë¸Œ ë°ì´í„°ê°€ ì—†ìœ¼ë©´ profile_select phaseë¥¼ ë°˜í™˜í•´ì•¼ í•œë‹¤', () => {
      const result = bootstrapSession();
      expect(result.phase).toBe('profile_select');
      if (result.phase === 'profile_select') {
        expect(result.savedGameAvailable).toBe(false);
      }
    });

    it('ìœ íš¨í•œ ì„¸ì´ë¸Œ ë°ì´í„°ê°€ ìˆìœ¼ë©´ playing phaseë¥¼ ë°˜í™˜í•´ì•¼ í•œë‹¤', () => {
      // ìœ íš¨í•œ ì„¸ì´ë¸Œ ìƒì„± ë° ì €ì¥
      const saveGame = {
        version: SAVEGAME_VERSION,
        language: 'ko-KR',
        profileId: 'explorer',
        savedAt: new Date().toISOString(),
        economy: { signal: 100, memory_shard: 5, credit: 0 },
        economyLedger: [],
        turnCount: 1,
        narrativeHistory: [],
        inventory: [],
        quests: [],
        activeRules: [],
        mutationTimeline: [],
        sceneObjects: [],
      };
      localStorage.setItem(SAVEGAME_STORAGE_KEY, JSON.stringify(saveGame));

      const result = bootstrapSession();
      expect(result.phase).toBe('playing');
      if (result.phase === 'playing') {
        expect(result.profileId).toBe('explorer');
      }
    });
  });

  describe('startSessionFromProfile', () => {
    it('í”„ë¡œí•„ ê¸°ë°˜ìœ¼ë¡œ ì„¸ì…˜ì„ ì‹œì‘í•˜ê³  storeì™€ localStorageë¥¼ ì—…ë°ì´íŠ¸í•´ì•¼ í•œë‹¤', () => {
      const result = startSessionFromProfile({
        profile: PROFILE_EXPLORER,
        t: mockT,
      });

      expect(result.success).toBe(true);
      expect(result.profileId).toBe(PROFILE_EXPLORER.id);

      // Store ìƒíƒœ í™•ì¸
      const worldState = useWorldStore.getState();
      expect(worldState.economy.signal).toBe(PROFILE_EXPLORER.initialState.economy.signal);
      expect(worldState.turnCount).toBe(0);
      expect(worldState.narrativeEntries).toHaveLength(1);

      const inventoryState = useInventoryStore.getState();
      expect(inventoryState.items).toHaveLength(PROFILE_EXPLORER.initialState.inventoryDefs.length);

      // localStorage í™•ì¸
      expect(localStorage.getItem(CURRENT_PROFILE_KEY)).toBe(PROFILE_EXPLORER.id);
      expect(localStorage.getItem(SAVEGAME_STORAGE_KEY)).not.toBeNull();
    });
  });

  describe('continueSession', () => {
    it('ì €ì¥ëœ ë°ì´í„°ë¥¼ ë¡œë“œí•˜ê³  storeë¥¼ ë³µì›í•´ì•¼ í•œë‹¤', async () => {
      const saveGame = {
        version: SAVEGAME_VERSION,
        language: 'en-US',
        profileId: 'explorer',
        savedAt: new Date().toISOString(),
        economy: { signal: 123, memory_shard: 45, credit: 0 },
        economyLedger: [],
        turnCount: 5,
        narrativeHistory: [{ turn: 1, text: 'old message' }],
        inventory: [{ id: 'item1', name: 'Item 1', quantity: 2 }],
        quests: [],
        activeRules: [],
        mutationTimeline: [],
        sceneObjects: [],
      };
      localStorage.setItem(SAVEGAME_STORAGE_KEY, JSON.stringify(saveGame));

      const result = await continueSession();

      expect(result?.success).toBe(true);
      expect(result?.profileId).toBe('explorer');

      // ì–¸ì–´ ë³€ê²½ í˜¸ì¶œ í™•ì¸
      expect(i18nModule.changeLanguage).toHaveBeenCalledWith('en-US');

      // Store ìƒíƒœ í™•ì¸
      const worldState = useWorldStore.getState();
      expect(worldState.economy.signal).toBe(123);
      expect(worldState.turnCount).toBe(5);
      expect(worldState.narrativeEntries).toHaveLength(1);

      const inventoryState = useInventoryStore.getState();
      expect(inventoryState.items).toHaveLength(1);
      expect(inventoryState.items[0].id).toBe('item1');
    });

    it('ë°ì´í„°ê°€ ì—†ìœ¼ë©´ nullì„ ë°˜í™˜í•˜ê³  í´ë¦°ì—…í•´ì•¼ í•œë‹¤', async () => {
      localStorage.setItem(CURRENT_PROFILE_KEY, 'some-profile');

      const result = await continueSession();

      expect(result).toBeNull();
      expect(localStorage.getItem(SAVEGAME_STORAGE_KEY)).toBeNull();
      expect(localStorage.getItem(CURRENT_PROFILE_KEY)).toBeNull();
    });
  });

  describe('resetToCurrentProfile', () => {
    it('í˜„ì¬ í”„ë¡œí•„ë¡œ ì„¸ì…˜ì„ ë¦¬ì…‹í•´ì•¼ í•œë‹¤', () => {
      // ë¨¼ì € ì„¸ì…˜ ì‹œì‘
      startSessionFromProfile({
        profile: PROFILE_EXPLORER,
        t: mockT,
      });

      // ìƒíƒœ ë³€ê²½ ì‹œë®¬ë ˆì´ì…˜
      useWorldStore.setState({ turnCount: 10, economy: { signal: 0, memory_shard: 0, credit: 0 } });

      const result = resetToCurrentProfile({
        t: mockT,
        currentProfileId: PROFILE_EXPLORER.id,
      });

      expect(result.success).toBe(true);
      expect(result.profileId).toBe(PROFILE_EXPLORER.id);

      // ì´ˆê¸° ìƒíƒœë¡œ ë³µì›ë˜ì—ˆëŠ”ì§€ í™•ì¸
      const worldState = useWorldStore.getState();
      expect(worldState.turnCount).toBe(0);
      expect(worldState.economy.signal).toBe(PROFILE_EXPLORER.initialState.economy.signal);
    });
  });

  describe('clearSessionAndReturnToSelect', () => {
    it('ëª¨ë“  ë°ì´í„°ë¥¼ ì‚­ì œí•˜ê³  storeë¥¼ ì´ˆê¸°í™”í•´ì•¼ í•œë‹¤', () => {
      // ë°ì´í„° ì±„ìš°ê¸°
      startSessionFromProfile({
        profile: PROFILE_EXPLORER,
        t: mockT,
      });

      clearSessionAndReturnToSelect();

      expect(localStorage.getItem(SAVEGAME_STORAGE_KEY)).toBeNull();
      expect(localStorage.getItem(CURRENT_PROFILE_KEY)).toBeNull();

      const worldState = useWorldStore.getState();
      expect(worldState.narrativeEntries).toHaveLength(0);
    });
  });

  describe('saveCurrentSession', () => {
    it('í˜„ì¬ ìƒíƒœë¥¼ localStorageì— ì €ì¥í•´ì•¼ í•œë‹¤', () => {
      startSessionFromProfile({
        profile: PROFILE_EXPLORER,
        t: mockT,
      });

      // ìƒíƒœ ë³€ê²½
      useWorldStore.setState({ turnCount: 1 });

      const success = saveCurrentSession(PROFILE_EXPLORER.id);
      expect(success).toBe(true);

      const saved = JSON.parse(localStorage.getItem(SAVEGAME_STORAGE_KEY)!);
      expect(saved.turnCount).toBe(1);
    });
  });

  describe('getInitialProfileId', () => {
    it('ì„¸ì´ë¸Œ ë°ì´í„°ê°€ ìˆìœ¼ë©´ ê·¸ ì•ˆì˜ profileIdë¥¼ ìš°ì„ í•´ì•¼ í•œë‹¤', () => {
      localStorage.setItem(
        SAVEGAME_STORAGE_KEY,
        JSON.stringify({
          version: SAVEGAME_VERSION,
          language: 'ko-KR',
          profileId: 'saved-profile',
          savedAt: new Date().toISOString(),
          economy: { signal: 100, memory_shard: 5, credit: 0 },
          economyLedger: [],
          turnCount: 1,
          narrativeHistory: [],
          inventory: [],
          quests: [],
          activeRules: [],
          mutationTimeline: [],
          sceneObjects: [],
        }),
      );
      localStorage.setItem(CURRENT_PROFILE_KEY, 'fallback-profile');

      expect(getInitialProfileId()).toBe('saved-profile');
    });

    it('ì„¸ì´ë¸Œ ë°ì´í„°ê°€ ì—†ìœ¼ë©´ CURRENT_PROFILE_KEYë¥¼ ì‚¬ìš©í•´ì•¼ í•œë‹¤', () => {
      localStorage.setItem(CURRENT_PROFILE_KEY, 'fallback-profile');
      expect(getInitialProfileId()).toBe('fallback-profile');
    });
  });
});
</file>

<file path="frontend/src/schemas/index.ts">
/**
 * Unknown World - ìŠ¤í‚¤ë§ˆ ëª¨ë“ˆ ì§„ì…ì .
 *
 * TurnInput/TurnOutput Zod ìŠ¤í‚¤ë§ˆ ë° ê´€ë ¨ ìœ í‹¸ë¦¬í‹°ë¥¼ ì¬ë‚´ë³´ë‚´ê¸°í•©ë‹ˆë‹¤.
 *
 * @module schemas
 */

// =============================================================================
// ìŠ¤í‚¤ë§ˆ ë²„ì „
// =============================================================================

export { SCHEMA_VERSION } from './turn';

// =============================================================================
// Enum ìŠ¤í‚¤ë§ˆ ë° íƒ€ì…
// =============================================================================

export {
  LanguageSchema,
  ThemeSchema,
  AgentPhaseSchema,
  ValidationBadgeSchema,
  ModelLabelSchema,
  RiskLevelSchema,
} from './turn';

export type { Language, Theme, AgentPhase, ValidationBadge, ModelLabel, RiskLevel } from './turn';

// =============================================================================
// ê³µí†µ í•˜ìœ„ íƒ€ì… ìŠ¤í‚¤ë§ˆ ë° íƒ€ì…
// =============================================================================

export { CoordinateSchema, Box2DSchema, CurrencyAmountSchema } from './turn';

export type { Coordinate, Box2D, CurrencyAmount } from './turn';

// =============================================================================
// TurnInput ê´€ë ¨ ìŠ¤í‚¤ë§ˆ ë° íƒ€ì…
// =============================================================================

export { ClickInputSchema, ClientInfoSchema, EconomySnapshotSchema, TurnInputSchema } from './turn';

export type { ClickInput, ClientInfo, EconomySnapshot, TurnInput } from './turn';

// =============================================================================
// TurnOutput ê´€ë ¨ ìŠ¤í‚¤ë§ˆ ë° íƒ€ì…
// =============================================================================

export {
  // UI
  ActionCardSchema,
  SceneObjectSchema,
  ActionDeckSchema,
  UIOutputSchema,
  // World
  MemoryPinSchema,
  WorldRuleSchema,
  QuestSchema,
  WorldDeltaSchema,
  // Render
  ImageJobSchema,
  RenderOutputSchema,
  // Economy
  LedgerEntrySchema,
  EconomyOutputSchema,
  // Safety
  SafetyOutputSchema, // Agent Console
  AgentConsoleSchema,
  // Main
  TurnOutputSchema,
} from './turn';

export type {
  // UI
  ActionCard,
  SceneObject,
  ActionDeck,
  UIOutput,
  // World
  MemoryPin,
  WorldRule,
  Quest,
  WorldDelta,
  // Render
  ImageJob,
  RenderOutput,
  // Economy
  LedgerEntry,
  EconomyOutput,
  // Safety
  SafetyOutput, // Agent Console
  AgentConsole,
  // Main
  TurnOutput,
} from './turn';

// =============================================================================
// ìœ í‹¸ë¦¬í‹° í•¨ìˆ˜
// =============================================================================

export {
  createFallbackTurnOutput,
  safeParseTurnOutput,
  parseTurnInput,
  safeParseTurnInput,
} from './turn';

export type { TurnOutputParseResult, TurnInputSafeParseResult } from './turn';
</file>

<file path="frontend/src/setupTests.ts">
import '@testing-library/jest-dom';
import { vi } from 'vitest';

// window.matchMedia ëª¨í‚¹ (NarrativeFeed ë“±ì—ì„œ ì‚¬ìš©)
Object.defineProperty(window, 'matchMedia', {
  writable: true,
  value: vi.fn().mockImplementation((query: string) => ({
    matches: false,
    media: query,
    onchange: null,
    addListener: vi.fn(), // deprecated
    removeListener: vi.fn(), // deprecated
    addEventListener: vi.fn(),
    removeEventListener: vi.fn(),
    dispatchEvent: vi.fn(),
  })),
});

// react-i18next ì „ì—­ ëª¨í‚¹
vi.mock('react-i18next', () => ({
  useTranslation: () => ({
    t: (key: string) => key,
    i18n: {
      changeLanguage: vi.fn(),
      language: 'ko-KR',
    },
  }),
  initReactI18next: {
    type: '3rdParty',
    init: vi.fn(),
  },
  Trans: ({ children }: { children: React.ReactNode }) => children,
}));
</file>

<file path="frontend/src/stores/inventory_consumption.test.ts">
import { describe, it, expect, beforeEach, vi } from 'vitest';
import { useInventoryStore } from './inventoryStore';
import { useWorldStore } from './worldStore';
import type { TurnOutput } from '../schemas/turn';

// í•˜ìœ„ ìŠ¤í† ì–´ ëª¨í‚¹ ë°©ì§€ (ì‹¤ì œ ë¡œì§ í…ŒìŠ¤íŠ¸ë¥¼ ìœ„í•´)
vi.unmock('./inventoryStore');
vi.unmock('./economyStore');
vi.unmock('./actionDeckStore');

describe('Item Consumption (U-096)', () => {
  beforeEach(() => {
    useInventoryStore.getState().reset();
    useWorldStore.getState().reset();
    vi.useFakeTimers();
  });

  describe('InventoryStore Consumption Logic', () => {
    it('markConsuming: ì•„ì´í…œì„ ì†Œë¹„ ì¤‘ì¸ ìƒíƒœë¡œ í‘œì‹œí•´ì•¼ í•œë‹¤', () => {
      const { markConsuming } = useInventoryStore.getState();
      markConsuming(['item1', 'item2']);

      const state = useInventoryStore.getState();
      expect(state.consumingItemIds).toContain('item1');
      expect(state.consumingItemIds).toContain('item2');
    });

    it('clearConsuming: ì†Œë¹„ ì• ë‹ˆë©”ì´ì…˜ ì™„ë£Œ í›„ ì•„ì´í…œì„ ì‹¤ì œë¡œ ì œê±°í•´ì•¼ í•œë‹¤ (ìˆ˜ëŸ‰ 1)', () => {
      const { addItems, markConsuming, clearConsuming } = useInventoryStore.getState();
      addItems([{ id: 'item1', name: 'Key', quantity: 1 }]);
      markConsuming(['item1']);

      clearConsuming(['item1']);

      const state = useInventoryStore.getState();
      expect(state.items).toHaveLength(0);
      expect(state.consumingItemIds).not.toContain('item1');
    });

    it('clearConsuming: ìˆ˜ëŸ‰ì´ ì—¬ëŸ¬ ê°œì¸ ê²½ìš° ìˆ˜ëŸ‰ë§Œ ê°ì†Œì‹œì¼œì•¼ í•œë‹¤', () => {
      const { addItems, markConsuming, clearConsuming } = useInventoryStore.getState();
      addItems([{ id: 'potion', name: 'Potion', quantity: 3 }]);
      markConsuming(['potion']);

      clearConsuming(['potion']);

      const state = useInventoryStore.getState();
      expect(state.items).toHaveLength(1);
      expect(state.items[0].quantity).toBe(2);
      expect(state.consumingItemIds).not.toContain('potion');
    });

    it('clearConsuming: ì¤‘ë³µ ID ì œê±° ì‹œ ìˆ˜ëŸ‰ì´ ê·¸ë§Œí¼ ê°ì†Œí•´ì•¼ í•œë‹¤', () => {
      const { addItems, markConsuming, clearConsuming } = useInventoryStore.getState();
      addItems([{ id: 'potion', name: 'Potion', quantity: 3 }]);
      markConsuming(['potion']);

      clearConsuming(['potion', 'potion']);

      const state = useInventoryStore.getState();
      expect(state.items).toHaveLength(1);
      expect(state.items[0].quantity).toBe(1);
    });
  });

  describe('WorldStore Integration', () => {
    it('applyTurnOutput: inventory_removedê°€ í¬í•¨ë˜ë©´ ì†Œë¹„ ì• ë‹ˆë©”ì´ì…˜ì„ íŠ¸ë¦¬ê±°í•´ì•¼ í•œë‹¤', () => {
      const { addItems } = useInventoryStore.getState();
      addItems([{ id: 'key_01', name: 'Iron Key', quantity: 1 }]);

      const mockOutput: Partial<TurnOutput> = {
        narrative: 'ì—´ì‡ ë¥¼ ì‚¬ìš©í–ˆìŠµë‹ˆë‹¤.',
        language: 'ko-KR' as 'ko-KR' | 'en-US',
        economy: {
          cost: { signal: 0, memory_shard: 0 },
          balance_after: { signal: 100, memory_shard: 5 },
          credit: 0,
          low_balance_warning: false,
        },
        ui: {
          action_deck: { cards: [] },
          objects: [],
          scene: { image_url: '', alt_text: '' },
        },
        world: {
          inventory_added: [],
          inventory_removed: ['key_01'],
          quests_updated: [],
          rules_changed: [],
          relationships_changed: [],
          memory_pins: [],
        },
        agent_console: {
          current_phase: 'commit' as
            | 'parse'
            | 'validate'
            | 'plan'
            | 'resolve'
            | 'render'
            | 'verify'
            | 'commit',
          badges: [],
          repair_count: 0,
          model_label: 'FAST' as 'FAST' | 'QUALITY' | 'CHEAP' | 'REF',
        },
        safety: { blocked: false, message: null },
      };

      useWorldStore.getState().applyTurnOutput(mockOutput as TurnOutput);

      // 1ë‹¨ê³„: markConsuming í˜¸ì¶œ í™•ì¸
      expect(useInventoryStore.getState().consumingItemIds).toContain('key_01');
      expect(useInventoryStore.getState().items).toHaveLength(1); // ì•„ì§ ì œê±° ì „

      // 2ë‹¨ê³„: 500ms ê²½ê³¼ í›„ ì œê±° í™•ì¸
      vi.advanceTimersByTime(500);
      expect(useInventoryStore.getState().items).toHaveLength(0); // ì œê±°ë¨
      expect(useInventoryStore.getState().consumingItemIds).not.toContain('key_01');
    });
  });
});
</file>

<file path="frontend/vite.config.ts">
/// <reference types="vitest" />
import { defineConfig } from 'vite';
import react from '@vitejs/plugin-react';

// https://vite.dev/config/
export default defineConfig({
  plugins: [react()],
  server: {
    port: 8001, // RULE-011: í”„ë¡ íŠ¸ì—”ë“œëŠ” 8001~8010 ì‚¬ìš©
    strictPort: true, // í¬íŠ¸ ì¶©ëŒ ì‹œ fail-fast (ëŒ€ì—­ ë°– ì´ë™ ë°©ì§€)
    // ì¶©ëŒ ì‹œ: pnpm -C frontend dev --port 8002 (8002~8010 ì¤‘ ì„ íƒ)
    proxy: {
      // ë°±ì—”ë“œ API í”„ë¡ì‹œ (RULE-011: ë°±ì—”ë“œëŠ” 8011~8020)
      '/api': {
        target: 'http://localhost:8011',
        changeOrigin: true,
      },
      // ì •ì  íŒŒì¼ í”„ë¡ì‹œ (ì´ë¯¸ì§€ ë“±)
      '/static': {
        target: 'http://localhost:8011',
        changeOrigin: true,
      },
    },
  },
  build: {
    outDir: 'dist',
    sourcemap: true,
  },
  test: {
    globals: true,
    environment: 'jsdom',
    setupFiles: './src/setupTests.ts',
  },
});
</file>

<file path="backend/debug_real_mode.py">
"""Debug script: real ëª¨ë“œì—ì„œ Gemini ì‘ë‹µì„ í™•ì¸í•©ë‹ˆë‹¤."""

import asyncio
import json
import os

# .env ë¡œë“œ
from pathlib import Path

from dotenv import load_dotenv

load_dotenv(dotenv_path=Path(__file__).parent / ".env", override=False)

# UW_MODE=real ê°•ì œ
os.environ["UW_MODE"] = "real"

from pydantic import ValidationError

from unknown_world.models.turn import Language, TurnInput, TurnOutput
from unknown_world.orchestrator.generate_turn_output import TurnOutputGenerator
from unknown_world.services.genai_client import get_genai_client, reset_genai_client


async def main():
    # í´ë¼ì´ì–¸íŠ¸ ì´ˆê¸°í™” í™•ì¸
    reset_genai_client()
    client = get_genai_client()
    print(f"Client mode: {client.mode}")
    print(f"Client available: {client.is_available()}")
    print(f"GOOGLE_API_KEY set: {bool(os.environ.get('GOOGLE_API_KEY'))}")
    print()

    # TurnInput ìƒì„±
    turn_input = TurnInput(
        language=Language.KO,
        text="ë¬¸ì„ ì—´ì–´ë³¸ë‹¤",
        client={"viewport_w": 1920, "viewport_h": 1080, "theme": "dark"},
        economy_snapshot={"signal": 100, "memory_shard": 5},
    )

    # TurnOutputGeneratorë¡œ ìƒì„±
    generator = TurnOutputGenerator(force_mock=False)
    result = await generator.generate(turn_input)

    print(f"Status: {result.status}")
    print(f"Model: {result.model_label}")
    print(f"Error: {result.error_message}")
    print(f"Error details: {json.dumps(result.error_details, indent=2, ensure_ascii=False)}")
    print()

    if result.raw_response:
        print("=== RAW RESPONSE (first 3000 chars) ===")
        print(result.raw_response[:3000])
        print()

        # ì§ì ‘ íŒŒì‹± ì‹œë„
        try:
            text = result.raw_response.strip()
            if text.startswith("```"):
                lines = text.split("\n")
                if lines[0].startswith("```"):
                    lines = lines[1:]
                if lines and lines[-1].strip() == "```":
                    lines = lines[:-1]
                text = "\n".join(lines)

            data = json.loads(text)
            print("=== JSON PARSED OK ===")
            print(f"Top-level keys: {list(data.keys())}")
            print()

            # Pydantic ê²€ì¦ ì‹œë„
            try:
                TurnOutput.model_validate(data)
                print("=== PYDANTIC VALIDATION OK ===")
            except ValidationError as e:
                print("=== PYDANTIC VALIDATION ERRORS ===")
                for err in e.errors():
                    print(f"  Location: {err['loc']}")
                    print(f"  Type: {err['type']}")
                    print(f"  Message: {err['msg']}")
                    if "input" in err:
                        inp = str(err["input"])
                        print(f"  Input: {inp[:200]}")
                    print()
        except json.JSONDecodeError as e:
            print(f"=== JSON PARSE FAILED: {e} ===")

    if result.output:
        print("=== OUTPUT ===")
        print(f"Narrative: {result.output.narrative[:200]}")
        print(f"Badges: {result.output.agent_console.badges}")


if __name__ == "__main__":
    asyncio.run(main())
</file>

<file path="backend/src/unknown_world/api/__init__.py">
"""Unknown World - API íŒ¨í‚¤ì§€.

ì´ íŒ¨í‚¤ì§€ëŠ” FastAPI ë¼ìš°í„°ë“¤ì„ í¬í•¨í•©ë‹ˆë‹¤.
"""

from unknown_world.api.image import router as image_router
from unknown_world.api.item_icon import router as item_icon_router
from unknown_world.api.scanner import router as scanner_router
from unknown_world.api.turn import router as turn_router

__all__ = ["image_router", "item_icon_router", "scanner_router", "turn_router"]
</file>

<file path="backend/src/unknown_world/api/scanner.py">
"""Unknown World - Scanner(ì´ë¯¸ì§€ ì´í•´) API ì—”ë“œí¬ì¸íŠ¸.

ì´ ëª¨ë“ˆì€ ì‚¬ìš©ìê°€ ì—…ë¡œë“œí•œ ì´ë¯¸ì§€ë¥¼ ë¶„ì„í•˜ì—¬ "ë‹¨ì„œ/ì•„ì´í…œ í›„ë³´"ë¡œ
ë³€í™˜í•˜ëŠ” API ì—”ë“œí¬ì¸íŠ¸ë¥¼ ì œê³µí•©ë‹ˆë‹¤.

ì„¤ê³„ ì›ì¹™:
    - RULE-004: ì‹¤íŒ¨ ì‹œ ì•ˆì „í•œ í´ë°± (í…ìŠ¤íŠ¸-only ìº¡ì…˜)
    - RULE-007: í”„ë¡¬í”„íŠ¸ ì›ë¬¸/ì—…ë¡œë“œ íŒŒì¼ ë‚´ìš© ë¡œê¹… ê¸ˆì§€
    - RULE-009: bboxëŠ” 0~1000 ì •ê·œí™” + [ymin, xmin, ymax, xmax]

í˜ì–´ë§ ì§ˆë¬¸ ê²°ì •:
    - Q1: Option A (multipart ì—…ë¡œë“œë¡œ ì²˜ë¦¬)

ì°¸ì¡°:
    - vibe/unit-plans/U-021[Mvp].md
    - vibe/prd.md 6.7 (Scanner ìŠ¬ë¡¯)
    - .cursor/rules/00-core-critical.mdc
"""

from __future__ import annotations

import logging
from typing import Annotated

from fastapi import APIRouter, Depends, File, Form, UploadFile
from pydantic import BaseModel, ConfigDict, Field

from unknown_world.models.scanner import (
    DetectedObject,
    ItemCandidate,
    ScanResult,
    ScanStatus,
)
from unknown_world.models.turn import Language
from unknown_world.services.image_understanding import (
    ImageUnderstandingService,
    get_image_understanding_service,
)
from unknown_world.storage.validation import (
    ALLOWED_IMAGE_MIME_TYPES,
    MAX_IMAGE_FILE_SIZE_BYTES,
    validate_image_upload,
)

# =============================================================================
# ë¡œê±° ì„¤ì •
# =============================================================================

logger = logging.getLogger(__name__)

# =============================================================================
# ë¼ìš°í„° ì •ì˜
# =============================================================================

router = APIRouter(
    prefix="/api/scan",
    tags=["Scanner"],
)


# =============================================================================
# ì˜ì¡´ì„± ì£¼ì…
# =============================================================================


async def get_scanner_service() -> ImageUnderstandingService:
    """Scanner ì„œë¹„ìŠ¤ ì˜ì¡´ì„±."""
    return get_image_understanding_service()


# =============================================================================
# ì‘ë‹µ ìŠ¤í‚¤ë§ˆ (API ê³„ì¸µìš©)
# =============================================================================


class ScannerResponse(BaseModel):
    """Scanner API ì‘ë‹µ.

    Attributes:
        success: ì„±ê³µ ì—¬ë¶€
        status: ìŠ¤ìº” ìƒíƒœ
        caption: ì´ë¯¸ì§€ ìº¡ì…˜
        objects: ê°ì§€ëœ ì˜¤ë¸Œì íŠ¸ ëª©ë¡
        item_candidates: ì•„ì´í…œ í›„ë³´ ëª©ë¡
        message: ìƒíƒœ/ì—ëŸ¬ ë©”ì‹œì§€
        analysis_time_ms: ë¶„ì„ ì†Œìš” ì‹œê°„ (ms)
        language: ì‘ë‹µ ì–¸ì–´
        original_image_key: ì €ì¥ëœ ì›ë³¸ ì´ë¯¸ì§€ ìŠ¤í† ë¦¬ì§€ í‚¤ (RU-006-S1)
        original_image_url: ì €ì¥ëœ ì›ë³¸ ì´ë¯¸ì§€ URL (RU-006-S1)
    """

    model_config = ConfigDict(extra="forbid")

    success: bool = Field(description="ì„±ê³µ ì—¬ë¶€")
    status: ScanStatus = Field(description="ìŠ¤ìº” ìƒíƒœ")
    caption: str = Field(default="", description="ì´ë¯¸ì§€ ìº¡ì…˜")
    objects: list[DetectedObject] = Field(
        default_factory=lambda: [],
        description="ê°ì§€ëœ ì˜¤ë¸Œì íŠ¸ ëª©ë¡",
    )
    item_candidates: list[ItemCandidate] = Field(
        default_factory=lambda: [],
        description="ì•„ì´í…œ í›„ë³´ ëª©ë¡",
    )
    message: str | None = Field(default=None, description="ìƒíƒœ/ì—ëŸ¬ ë©”ì‹œì§€")
    analysis_time_ms: int = Field(default=0, description="ë¶„ì„ ì†Œìš” ì‹œê°„ (ms)")
    language: Language = Field(description="ì‘ë‹µ ì–¸ì–´")
    original_image_key: str | None = Field(
        default=None,
        description="ì €ì¥ëœ ì›ë³¸ ì´ë¯¸ì§€ ìŠ¤í† ë¦¬ì§€ í‚¤",
    )
    original_image_url: str | None = Field(
        default=None,
        description="ì €ì¥ëœ ì›ë³¸ ì´ë¯¸ì§€ URL",
    )


class ScannerHealthResponse(BaseModel):
    """Scanner ì„œë¹„ìŠ¤ í—¬ìŠ¤ì²´í¬ ì‘ë‹µ.

    Attributes:
        status: ì„œë¹„ìŠ¤ ìƒíƒœ
        mode: ë™ì‘ ëª¨ë“œ (mock/real)
        model: ì‚¬ìš© ì¤‘ì¸ ëª¨ë¸ ë¼ë²¨
        supported_formats: ì§€ì›í•˜ëŠ” ì´ë¯¸ì§€ í˜•ì‹
        max_file_size_mb: ìµœëŒ€ íŒŒì¼ í¬ê¸° (MB)
    """

    model_config = ConfigDict(extra="forbid")

    status: str = Field(description="ì„œë¹„ìŠ¤ ìƒíƒœ")
    mode: str = Field(description="ë™ì‘ ëª¨ë“œ")
    model: str = Field(description="ì‚¬ìš© ì¤‘ì¸ ëª¨ë¸")
    supported_formats: list[str] = Field(description="ì§€ì›í•˜ëŠ” ì´ë¯¸ì§€ í˜•ì‹")
    max_file_size_mb: int = Field(description="ìµœëŒ€ íŒŒì¼ í¬ê¸° (MB)")


# =============================================================================
# ì—”ë“œí¬ì¸íŠ¸ ì •ì˜
# =============================================================================


@router.post(
    "",
    response_model=ScannerResponse,
    summary="ì´ë¯¸ì§€ ìŠ¤ìº”",
    description="ì´ë¯¸ì§€ë¥¼ ì—…ë¡œë“œí•˜ì—¬ ì˜¤ë¸Œì íŠ¸ì™€ ì•„ì´í…œ í›„ë³´ë¥¼ ì¶”ì¶œí•©ë‹ˆë‹¤.",
)
async def scan_image(
    file: Annotated[UploadFile, File(description="ë¶„ì„í•  ì´ë¯¸ì§€ íŒŒì¼")],
    language: Annotated[
        str,
        Form(description="ì‘ë‹µ ì–¸ì–´ (ko-KR ë˜ëŠ” en-US)"),
    ] = "ko-KR",
    preserve_original: Annotated[
        bool,
        Form(description="ì›ë³¸ ì´ë¯¸ì§€ ì €ì¥ ì—¬ë¶€ (ë””ë²„ê¹…/ì¬ë¶„ì„ìš©, RU-006-S1)"),
    ] = False,
    session_id: Annotated[
        str | None,
        Form(description="ì„¸ì…˜ ID (ì´ë¯¸ì§€ ê·¸ë£¹í™”ìš©)"),
    ] = None,
    service: ImageUnderstandingService = Depends(get_scanner_service),
) -> ScannerResponse:
    """ì´ë¯¸ì§€ë¥¼ ìŠ¤ìº”í•˜ì—¬ ì˜¤ë¸Œì íŠ¸ì™€ ì•„ì´í…œ í›„ë³´ë¥¼ ì¶”ì¶œí•©ë‹ˆë‹¤.

    ì´ ì—”ë“œí¬ì¸íŠ¸ëŠ” Scanner ìŠ¬ë¡¯ UIì—ì„œ ì´ë¯¸ì§€ë¥¼ ë“œë¡­/ì—…ë¡œë“œí•  ë•Œ í˜¸ì¶œë©ë‹ˆë‹¤.
    ì¶”ì¶œëœ ì•„ì´í…œ í›„ë³´ëŠ” ì¸ë²¤í† ë¦¬ì— ì¶”ê°€í•˜ê±°ë‚˜ ì„¸ê³„ì— ë°°ì¹˜í•  ìˆ˜ ìˆìŠµë‹ˆë‹¤.

    Args:
        file: ë¶„ì„í•  ì´ë¯¸ì§€ íŒŒì¼ (multipart/form-data)
        language: ì‘ë‹µ ì–¸ì–´ (ko-KR ë˜ëŠ” en-US)
        preserve_original: ì›ë³¸ ì´ë¯¸ì§€ ì €ì¥ ì—¬ë¶€ (RU-006-S1)
        session_id: ì„¸ì…˜ ID (ì´ë¯¸ì§€ ê·¸ë£¹í™”ìš©)
        service: Scanner ì„œë¹„ìŠ¤ (ì˜ì¡´ì„± ì£¼ì…)

    Returns:
        ScannerResponse: ìŠ¤ìº” ê²°ê³¼

    Raises:
        HTTPException: íŒŒì¼ í˜•ì‹ì´ ì˜ëª»ë˜ì—ˆê±°ë‚˜ í¬ê¸° ì´ˆê³¼ ì‹œ
    """
    # ì–¸ì–´ íŒŒì‹±
    try:
        lang = Language(language)
    except ValueError:
        lang = Language.KO

    # íŒŒì¼ ì½ê¸°
    try:
        content = await file.read()
    except Exception as e:
        logger.error(
            "[ScannerAPI] íŒŒì¼ ì½ê¸° ì‹¤íŒ¨",
            extra={"error_type": type(e).__name__},
        )
        return ScannerResponse(
            success=False,
            status=ScanStatus.FAILED,
            message="íŒŒì¼ì„ ì½ì„ ìˆ˜ ì—†ìŠµë‹ˆë‹¤",
            language=lang,
        )

    # ì¤‘ì•™í™”ëœ íŒŒì¼ ê²€ì¦ (RULE-004, RU-006-Q1)
    content_type = file.content_type or "application/octet-stream"
    validation_error = validate_image_upload(
        content=content,
        content_type=content_type,
        language=lang,
    )

    if validation_error:
        logger.warning(
            "[ScannerAPI] íŒŒì¼ ê²€ì¦ ì‹¤íŒ¨",
            extra={"error": validation_error},
        )
        return ScannerResponse(
            success=False,
            status=ScanStatus.FAILED,
            message=validation_error,
            language=lang,
        )

    # ë¡œê·¸: ë©”íƒ€ ì •ë³´ë§Œ ê¸°ë¡ (RULE-007: íŒŒì¼ ë‚´ìš© ë¡œê¹… ê¸ˆì§€)
    logger.info(
        "[ScannerAPI] ìŠ¤ìº” ìš”ì²­",
        extra={
            "filename": file.filename,
            "content_type": content_type,
            "size_kb": len(content) // 1024,
            "language": lang.value,
        },
    )

    # ì´ë¯¸ì§€ ë¶„ì„ ìˆ˜í–‰
    try:
        result: ScanResult = await service.analyze(
            image_content=content,
            content_type=content_type,
            language=lang,
            preserve_original=preserve_original,
            session_id=session_id,
        )

        # ì„±ê³µ ì—¬ë¶€ ê²°ì •
        success = result.status in (ScanStatus.COMPLETED, ScanStatus.PARTIAL)

        return ScannerResponse(
            success=success,
            status=result.status,
            caption=result.caption,
            objects=result.objects,
            item_candidates=result.item_candidates,
            message=result.message,
            analysis_time_ms=result.analysis_time_ms,
            language=lang,
            original_image_key=result.original_image_key,
            original_image_url=result.original_image_url,
        )

    except Exception as e:
        error_type = type(e).__name__
        logger.error(
            "[ScannerAPI] ìŠ¤ìº” ì¤‘ ì˜ˆì™¸ ë°œìƒ",
            extra={"error_type": error_type},
        )

        # ì•ˆì „í•œ í´ë°± ì‘ë‹µ (RULE-004)
        return ScannerResponse(
            success=False,
            status=ScanStatus.FAILED,
            message=f"ì´ë¯¸ì§€ ë¶„ì„ ì¤‘ ì˜¤ë¥˜ê°€ ë°œìƒí–ˆìŠµë‹ˆë‹¤: {error_type}",
            language=lang,
        )


@router.get(
    "/health",
    response_model=ScannerHealthResponse,
    summary="Scanner ì„œë¹„ìŠ¤ í—¬ìŠ¤ì²´í¬",
    description="Scanner ì„œë¹„ìŠ¤ì˜ ìƒíƒœë¥¼ í™•ì¸í•©ë‹ˆë‹¤.",
)
async def scanner_health(
    service: ImageUnderstandingService = Depends(get_scanner_service),
) -> ScannerHealthResponse:
    """Scanner ì„œë¹„ìŠ¤ í—¬ìŠ¤ì²´í¬.

    Args:
        service: Scanner ì„œë¹„ìŠ¤

    Returns:
        ScannerHealthResponse: ì„œë¹„ìŠ¤ ìƒíƒœ ì •ë³´
    """
    return ScannerHealthResponse(
        status="ok",
        mode="mock" if service.is_mock else "real",
        model="VISION (gemini-3-flash-preview)",
        supported_formats=list(ALLOWED_IMAGE_MIME_TYPES),
        max_file_size_mb=MAX_IMAGE_FILE_SIZE_BYTES // (1024 * 1024),
    )
</file>

<file path="backend/src/unknown_world/orchestrator/stages/types.py">
"""Unknown World - Pipeline Stage íƒ€ì… ì •ì˜.

Pipelineì—ì„œ ì‚¬ìš©í•˜ëŠ” ì»¨í…ìŠ¤íŠ¸ì™€ emit ì½œë°± ì¸í„°í˜ì´ìŠ¤ë¥¼ ì •ì˜í•©ë‹ˆë‹¤.

ì„¤ê³„ ì›ì¹™:
    - Option A (RU-005 Q1 ê²°ì •): í´ë˜ìŠ¤ ë„ì… ì—†ì´ í•¨ìˆ˜ ì²´ì¸ ë°©ì‹
    - ë ˆì´ì–´ë§ ë³´í˜¸: ì˜¤ì¼€ìŠ¤íŠ¸ë ˆì´í„°ê°€ FastAPIì— ì§ì ‘ ì˜ì¡´í•˜ì§€ ì•Šë„ë¡ emit ì½œë°± ì‚¬ìš©
    - RULE-007/008: í”„ë¡¬í”„íŠ¸/ë‚´ë¶€ ì¶”ë¡  ë…¸ì¶œ ê¸ˆì§€, ë‹¨ê³„/ë°°ì§€ë§Œ í‘œì‹œ
    - U-051: ì´ë¯¸ì§€ ìƒì„± ì„œë¹„ìŠ¤ ì˜ì¡´ì„± ì£¼ì… (ìˆœí™˜ ì˜ì¡´ ë°©ì§€ë¥¼ ìœ„í•´ TYPE_CHECKING í™œìš©)

ì°¸ì¡°:
    - vibe/refactors/RU-005-Q4.md
    - vibe/unit-results/U-018[Mvp].md
    - vibe/unit-results/U-019[Mvp].md
"""

from __future__ import annotations

from collections.abc import Awaitable, Callable
from dataclasses import dataclass, field
from enum import Enum
from typing import TYPE_CHECKING, Any, Protocol

from unknown_world.models.turn import (
    AgentPhase,
    CurrencyAmount,
    ModelLabel,
    TurnInput,
    TurnOutput,
    ValidationBadge,
)

if TYPE_CHECKING:
    from unknown_world.services.image_generation import ImageGeneratorType

# =============================================================================
# Emit ì½œë°± íƒ€ì… (ì˜¤ì¼€ìŠ¤íŠ¸ë ˆì´í„° â†’ API ë ˆì´ì–´)
# =============================================================================


class PipelineEventType(str, Enum):
    """íŒŒì´í”„ë¼ì¸ ì´ë²¤íŠ¸ íƒ€ì….

    ì˜¤ì¼€ìŠ¤íŠ¸ë ˆì´í„°ê°€ API ë ˆì´ì–´ë¡œ ì „ë‹¬í•˜ëŠ” ë„ë©”ì¸ ì´ë²¤íŠ¸ íƒ€ì…ì…ë‹ˆë‹¤.
    API ë ˆì´ì–´ëŠ” ì´ë¥¼ StageEvent/BadgesEvent/RepairEvent ë“±ìœ¼ë¡œ ë³€í™˜í•©ë‹ˆë‹¤.
    """

    STAGE_START = "stage_start"
    STAGE_COMPLETE = "stage_complete"
    STAGE_FAIL = "stage_fail"
    BADGES = "badges"
    REPAIR = "repair"
    NARRATIVE_DELTA = "narrative_delta"


@dataclass
class PipelineEvent:
    """íŒŒì´í”„ë¼ì¸ ì´ë²¤íŠ¸.

    ì˜¤ì¼€ìŠ¤íŠ¸ë ˆì´í„°ê°€ emit ì½œë°±ìœ¼ë¡œ ì „ë‹¬í•˜ëŠ” ë„ë©”ì¸ ì´ë²¤íŠ¸ì…ë‹ˆë‹¤.
    API ë ˆì´ì–´ì—ì„œ ìŠ¤íŠ¸ë¦¼ ì´ë²¤íŠ¸ë¡œ ë³€í™˜ë©ë‹ˆë‹¤.

    Attributes:
        event_type: ì´ë²¤íŠ¸ íƒ€ì…
        phase: ê´€ë ¨ ë‹¨ê³„ (stage ì´ë²¤íŠ¸ìš©)
        badges: ë°°ì§€ ëª©ë¡ (badges ì´ë²¤íŠ¸ìš©)
        repair_attempt: ë³µêµ¬ ì‹œë„ íšŸìˆ˜ (repair ì´ë²¤íŠ¸ìš©)
        repair_message: ë³µêµ¬ ë©”ì‹œì§€ (repair ì´ë²¤íŠ¸ìš©)
        text: í…ìŠ¤íŠ¸ (narrative_delta ì´ë²¤íŠ¸ìš©)
        extra: ì¶”ê°€ ë°ì´í„°
    """

    event_type: PipelineEventType
    phase: AgentPhase | None = None
    badges: list[ValidationBadge] | None = None
    repair_attempt: int = 0
    repair_message: str | None = None
    text: str | None = None
    extra: dict[str, Any] = field(default_factory=lambda: {})


# Emit í•¨ìˆ˜ íƒ€ì…: async callableë¡œ ë„ë©”ì¸ ì´ë²¤íŠ¸ë¥¼ ì „ë‹¬
EmitFn = Callable[[PipelineEvent], Awaitable[None]]


# =============================================================================
# Pipeline Context
# =============================================================================


@dataclass
class PipelineContext:
    """íŒŒì´í”„ë¼ì¸ ì»¨í…ìŠ¤íŠ¸.

    Stage í•¨ìˆ˜ë“¤ì´ ê³µìœ í•˜ëŠ” ì»¨í…ìŠ¤íŠ¸ì…ë‹ˆë‹¤.
    ê° stageëŠ” ctxë¥¼ ë°›ì•„ ìˆ˜ì •í•˜ê³  ë°˜í™˜í•©ë‹ˆë‹¤ (Option A: í•¨ìˆ˜ ì²´ì¸).

    Attributes:
        turn_input: ì‚¬ìš©ì í„´ ì…ë ¥
        economy_snapshot: ìš”ì²­ ì‹œì  ì¬í™” ìŠ¤ëƒ…ìƒ· (í´ë°± ì‹œ ë³´ì¡´ìš©)
        output: ìƒì„±ëœ TurnOutput (validate stage ì´í›„)
        badges: í˜„ì¬ê¹Œì§€ ìˆ˜ì§‘ëœ ë°°ì§€ ëª©ë¡
        repair_messages: ë³µêµ¬ ì‹œë„ ì‹œ ë°œìƒí•œ ë©”ì‹œì§€ ëª©ë¡
        repair_attempts: ë³µêµ¬ ì‹œë„ íšŸìˆ˜
        current_phase: í˜„ì¬ ë‹¨ê³„
        is_fallback: í´ë°±ìœ¼ë¡œ ì¢…ë£Œë˜ì—ˆëŠ”ì§€
        is_mock: Mock ëª¨ë“œì¸ì§€
        seed: Mock ëª¨ë“œ ì‹œë“œ (ì¬í˜„ì„± ë³´ì¥)
        image_generator: ì´ë¯¸ì§€ ìƒì„± ì„œë¹„ìŠ¤ (U-051, ì„ íƒì  ì£¼ì…)
            Noneì´ë©´ ì´ë¯¸ì§€ ìƒì„±ì„ ê±´ë„ˆë›°ê³  pass-throughë¡œ ë™ì‘í•©ë‹ˆë‹¤.
            í…ŒìŠ¤íŠ¸ ì‹œ MockImageGeneratorë¥¼ ì£¼ì…í•˜ì—¬ ì‹¤ì œ API í˜¸ì¶œ ì—†ì´ ê²€ì¦ ê°€ëŠ¥í•©ë‹ˆë‹¤.
        model_label: í˜„ì¬ ì‚¬ìš© ì¤‘ì¸ í…ìŠ¤íŠ¸ ëª¨ë¸ ë¼ë²¨ (U-069: FAST/QUALITY)
        cost_multiplier: ë¹„ìš© ë°°ìˆ˜ (U-069: FAST=1.0, QUALITY=2.0)
    """

    turn_input: TurnInput
    economy_snapshot: CurrencyAmount
    output: TurnOutput | None = None
    badges: list[ValidationBadge] = field(default_factory=lambda: [])
    repair_messages: list[str] = field(default_factory=lambda: [])
    repair_attempts: int = 0
    current_phase: AgentPhase = AgentPhase.PARSE
    is_fallback: bool = False
    is_mock: bool = False
    seed: int | None = None
    image_generator: ImageGeneratorType | None = None
    model_label: ModelLabel = ModelLabel.FAST
    cost_multiplier: float = 1.0


# =============================================================================
# Stage í•¨ìˆ˜ íƒ€ì…
# =============================================================================


class StageFn(Protocol):
    """Stage í•¨ìˆ˜ í”„ë¡œí† ì½œ.

    ê° stage í•¨ìˆ˜ëŠ” ì´ í”„ë¡œí† ì½œì„ ë”°ë¦…ë‹ˆë‹¤.
    ctxë¥¼ ë°›ì•„ ìˆ˜ì •í•˜ê³  ë°˜í™˜í•˜ë©°, emit ì½œë°±ìœ¼ë¡œ ì´ë²¤íŠ¸ë¥¼ ì „ë‹¬í•©ë‹ˆë‹¤.
    """

    async def __call__(self, ctx: PipelineContext, *, emit: EmitFn) -> PipelineContext: ...
</file>

<file path="backend/src/unknown_world/orchestrator/stages/validate.py">
"""Unknown World - Validate Stage.

ë¹„ì¦ˆë‹ˆìŠ¤ ë£° ê²€ì¦ + Repair loop ë‹¨ê³„ì…ë‹ˆë‹¤.
U-018ì˜ run_repair_loop()ë¥¼ í˜¸ì¶œí•´ output/badges/repair_countë¥¼ ê²°ì •í•©ë‹ˆë‹¤.

ì„¤ê³„ ì›ì¹™:
    - RULE-003: êµ¬ì¡°í™” ì¶œë ¥(JSON Schema) + ì´ì¤‘ ê²€ì¦
    - RULE-004: ê²€ì¦ ì‹¤íŒ¨ ì‹œ Repair loop + ì•ˆì „í•œ í´ë°±
    - RULE-005: ì¬í™” ì¸ë°”ë¦¬ì–¸íŠ¸ (ì”ì•¡ ìŒìˆ˜ ê¸ˆì§€)
    - RULE-008: ë‹¨ê³„/ë°°ì§€ ê°€ì‹œí™”

ì°¸ì¡°:
    - vibe/refactors/RU-005-Q4.md
    - vibe/unit-plans/U-018[Mvp].md
"""

from __future__ import annotations

from unknown_world.models.turn import AgentPhase, Language, ValidationBadge
from unknown_world.orchestrator.fallback import create_safe_fallback
from unknown_world.orchestrator.mock import MockOrchestrator
from unknown_world.orchestrator.repair_loop import (
    MAX_REPAIR_ATTEMPTS,
    add_business_badges,
    run_repair_loop,
)
from unknown_world.orchestrator.stages.types import (
    EmitFn,
    PipelineContext,
    PipelineEvent,
    PipelineEventType,
)
from unknown_world.validation.business_rules import validate_business_rules


async def validate_stage(ctx: PipelineContext, *, emit: EmitFn) -> PipelineContext:
    """Validate ë‹¨ê³„ë¥¼ ì‹¤í–‰í•©ë‹ˆë‹¤.

    Mock ëª¨ë“œì™€ Real ëª¨ë“œë¥¼ êµ¬ë¶„í•˜ì—¬ ì²˜ë¦¬í•©ë‹ˆë‹¤.
    - Mock: MockOrchestratorë¡œ ìƒì„± + ë¹„ì¦ˆë‹ˆìŠ¤ ë£° ê²€ì¦
    - Real: run_repair_loop() í˜¸ì¶œ (Gemini API + Repair loop)

    Args:
        ctx: íŒŒì´í”„ë¼ì¸ ì»¨í…ìŠ¤íŠ¸
        emit: ì´ë²¤íŠ¸ emit ì½œë°±

    Returns:
        ì—…ë°ì´íŠ¸ëœ ì»¨í…ìŠ¤íŠ¸ (output, badges, repair_attempts í¬í•¨)
    """
    ctx.current_phase = AgentPhase.VALIDATE

    # Stage ì‹œì‘ ì´ë²¤íŠ¸
    await emit(
        PipelineEvent(
            event_type=PipelineEventType.STAGE_START,
            phase=AgentPhase.VALIDATE,
        )
    )

    try:
        if ctx.is_mock:
            await _validate_mock(ctx, emit)
        else:
            await _validate_real(ctx, emit)
    except Exception:
        # ì˜ˆì™¸ ë°œìƒ ì‹œ í´ë°± (RULE-004, RU-005-S1)
        ctx.output = create_safe_fallback(
            language=ctx.turn_input.language,
            economy_snapshot=ctx.economy_snapshot,
            repair_count=ctx.repair_attempts,
        )
        ctx.is_fallback = True
        # RU-005-S1: í´ë°±ì˜ ë°°ì§€ë¥¼ ìŠ¤íŠ¸ë¦¼ ì´ë²¤íŠ¸ì™€ ë™ê¸°í™”
        ctx.badges = list(ctx.output.agent_console.badges)

    # Stage ì™„ë£Œ ì´ë²¤íŠ¸
    await emit(
        PipelineEvent(
            event_type=PipelineEventType.STAGE_COMPLETE,
            phase=AgentPhase.VALIDATE,
        )
    )

    # ë°°ì§€ ì´ë²¤íŠ¸ ì „ì†¡
    if ctx.badges:
        await emit(
            PipelineEvent(
                event_type=PipelineEventType.BADGES,
                badges=ctx.badges,
            )
        )

    return ctx


async def _validate_mock(ctx: PipelineContext, emit: EmitFn) -> None:
    """Mock ëª¨ë“œ ê²€ì¦ì„ ìˆ˜í–‰í•©ë‹ˆë‹¤."""
    orchestrator = MockOrchestrator(seed=ctx.seed)
    repair_attempt = 0

    while repair_attempt <= MAX_REPAIR_ATTEMPTS:
        # 0íšŒì°¨ëŠ” ì •ìƒ ì‹œë„, 1íšŒì°¨ë¶€í„°ëŠ” repair
        if repair_attempt > 0:
            await emit(
                PipelineEvent(
                    event_type=PipelineEventType.REPAIR,
                    repair_attempt=repair_attempt,
                    repair_message=(
                        "ê²€ì¦ ì‹¤íŒ¨ë¡œ ì¸í•´ ë‹¤ì‹œ ì‹œë„ ì¤‘ì…ë‹ˆë‹¤..."
                        if ctx.turn_input.language == Language.KO
                        else "Retrying due to validation failure..."
                    ),
                )
            )
            ctx.repair_messages.append(
                "ê²€ì¦ ì‹¤íŒ¨ë¡œ ì¸í•´ ë‹¤ì‹œ ì‹œë„ ì¤‘ì…ë‹ˆë‹¤..."
                if ctx.turn_input.language == Language.KO
                else "Retrying due to validation failure..."
            )

        try:
            # Mock ìƒì„±
            turn_output = orchestrator.generate_turn_output(ctx.turn_input)

            # ë¹„ì¦ˆë‹ˆìŠ¤ ë£° ê²€ì¦ (U-018)
            biz_result = validate_business_rules(ctx.turn_input, turn_output)
            if not biz_result.is_valid:
                # ë¹„ì¦ˆë‹ˆìŠ¤ ë£° ì‹¤íŒ¨ â†’ ì¬ì‹œë„
                repair_attempt += 1
                ctx.repair_attempts = repair_attempt
                if repair_attempt > MAX_REPAIR_ATTEMPTS:
                    # ìµœì¢… ì‹¤íŒ¨ ì‹œ í´ë°± (RULE-004, RU-005-S1)
                    ctx.output = create_safe_fallback(
                        language=ctx.turn_input.language,
                        economy_snapshot=ctx.economy_snapshot,
                        repair_count=repair_attempt,
                    )
                    ctx.is_fallback = True
                    # RU-005-S1: ë¹„ì¦ˆë‹ˆìŠ¤ ë£° ì‹¤íŒ¨ ë°°ì§€ë¥¼ ì •í™•íˆ ì„¤ì •í•˜ê³ 
                    # outputê³¼ ctx ë°°ì§€ë¥¼ ë™ê¸°í™”
                    failure_badges: list[ValidationBadge] = [ValidationBadge.SCHEMA_OK]
                    add_business_badges(biz_result, failure_badges)
                    ctx.output.agent_console.badges = failure_badges
                    ctx.badges = list(failure_badges)
                    return
                continue

            # ëª¨ë“  ê²€ì¦ í†µê³¼
            ctx.output = turn_output
            ctx.badges = [
                ValidationBadge.SCHEMA_OK,
                ValidationBadge.ECONOMY_OK,
                ValidationBadge.SAFETY_OK,
                ValidationBadge.CONSISTENCY_OK,
            ]
            ctx.repair_attempts = repair_attempt
            return

        except Exception:
            repair_attempt += 1
            ctx.repair_attempts = repair_attempt
            if repair_attempt > MAX_REPAIR_ATTEMPTS:
                # ìµœì¢… ì‹¤íŒ¨ ì‹œ í´ë°± (RULE-004, RU-005-S1)
                ctx.output = create_safe_fallback(
                    language=ctx.turn_input.language,
                    economy_snapshot=ctx.economy_snapshot,
                    repair_count=repair_attempt,
                )
                ctx.is_fallback = True
                # RU-005-S1: í´ë°±ì˜ ë°°ì§€ë¥¼ ìŠ¤íŠ¸ë¦¼ ì´ë²¤íŠ¸ì™€ ë™ê¸°í™”
                ctx.badges = list(ctx.output.agent_console.badges)
                return
            continue

    # ë£¨í”„ ì¢…ë£Œ ì‹œì—ë„ í´ë°± (RU-005-S1)
    ctx.output = create_safe_fallback(
        language=ctx.turn_input.language,
        economy_snapshot=ctx.economy_snapshot,
        repair_count=repair_attempt,
    )
    ctx.is_fallback = True
    # RU-005-S1: í´ë°±ì˜ ë°°ì§€ë¥¼ ìŠ¤íŠ¸ë¦¼ ì´ë²¤íŠ¸ì™€ ë™ê¸°í™”
    ctx.badges = list(ctx.output.agent_console.badges)


async def _validate_real(ctx: PipelineContext, emit: EmitFn) -> None:
    """Real ëª¨ë“œ ê²€ì¦ì„ ìˆ˜í–‰í•©ë‹ˆë‹¤ (Gemini API + Repair loop)."""
    result = await run_repair_loop(ctx.turn_input)

    # Repair ì´ë²¤íŠ¸ ì†¡ì¶œ (ì‹œë„ê°€ ìˆì—ˆë‹¤ë©´)
    for i in range(result.repair_attempts):
        message = result.error_messages[i] if i < len(result.error_messages) else ""
        await emit(
            PipelineEvent(
                event_type=PipelineEventType.REPAIR,
                repair_attempt=i + 1,
                repair_message=message[:100] if message else None,
            )
        )
        if message:
            ctx.repair_messages.append(message[:100])

    ctx.output = result.output
    ctx.badges = list(result.badges)
    ctx.repair_attempts = result.repair_attempts
    ctx.is_fallback = result.is_fallback

    # U-069: ëª¨ë¸ í‹°ì–´ë§ ì •ë³´ ì „ë‹¬ (PipelineContext + TurnOutput)
    # config.models.ModelLabelì„ models.turn.ModelLabelë¡œ ë³€í™˜í•˜ì—¬ í• ë‹¹ (Pyright ëŒ€ì‘)
    from unknown_world.models.turn import ModelLabel as TurnModelLabel

    ctx.model_label = TurnModelLabel(result.model_label.value)
    ctx.cost_multiplier = result.cost_multiplier
    if ctx.output:
        ctx.output.agent_console.model_label = TurnModelLabel(result.model_label.value)
</file>

<file path="backend/src/unknown_world/services/__init__.py">
"""Unknown World - ì„œë¹„ìŠ¤ ë ˆì´ì–´ íŒ¨í‚¤ì§€.

ì´ íŒ¨í‚¤ì§€ëŠ” ì™¸ë¶€ ì„œë¹„ìŠ¤ì™€ì˜ í†µì‹ ì„ ë‹´ë‹¹í•˜ëŠ” ëª¨ë“ˆì„ ê´€ë¦¬í•©ë‹ˆë‹¤.
GenAI í´ë¼ì´ì–¸íŠ¸, ì´ë¯¸ì§€ ìƒì„±ê¸°, ìŠ¤í† ë¦¬ì§€ í´ë¼ì´ì–¸íŠ¸ ë“±ì´ í¬í•¨ë©ë‹ˆë‹¤.

ì°¸ì¡°:
    - vibe/tech-stack.md (google-genai ë²„ì „, Vertex AI ì¸ì¦)
    - .cursor/rules/20-backend-orchestrator.mdc (Vertex ì¸ì¦/ë¹„ë°€ì •ë³´ ê¸ˆì§€)
"""

from unknown_world.services.genai_client import (
    GenAIClient,
    GenAIClientType,
    GenAIMode,
    GenerateRequest,
    GenerateResponse,
    MockGenAIClient,
    get_genai_client,
    reset_genai_client,
)
from unknown_world.services.image_generation import (
    ImageGenerationRequest,
    ImageGenerationResponse,
    ImageGenerationStatus,
    ImageGenerator,
    ImageGeneratorType,
    MockImageGenerator,
    create_fallback_response,
    get_image_generator,
    reset_image_generator,
)
from unknown_world.services.image_understanding import (
    ImageUnderstandingService,
    get_image_understanding_service,
    reset_image_understanding_service,
)

__all__ = [
    # GenAI í´ë¼ì´ì–¸íŠ¸
    "GenAIClient",
    "GenAIClientType",
    "GenAIMode",
    "GenerateRequest",
    "GenerateResponse",
    "MockGenAIClient",
    "get_genai_client",
    "reset_genai_client",
    # ì´ë¯¸ì§€ ìƒì„± (U-019)
    "ImageGenerationRequest",
    "ImageGenerationResponse",
    "ImageGenerationStatus",
    "ImageGenerator",
    "ImageGeneratorType",
    "MockImageGenerator",
    "create_fallback_response",
    "get_image_generator",
    "reset_image_generator",
    # ì´ë¯¸ì§€ ì´í•´/Scanner (U-021)
    "ImageUnderstandingService",
    "get_image_understanding_service",
    "reset_image_understanding_service",
]
</file>

<file path="backend/src/unknown_world/storage/__init__.py">
"""Unknown World - ìŠ¤í† ë¦¬ì§€ ëª¨ë“ˆ.

ìŠ¤í† ë¦¬ì§€ ì¶”ìƒí™” ê³„ì¸µì„ ì œê³µí•©ë‹ˆë‹¤.
MVP: LocalStorage, MMP: GCSStorage(ì˜ˆì •)

ì°¸ì¡°:
    - vibe/refactors/RU-006-Q4.md
    - vibe/refactors/RU-006-Q5.md
"""

from unknown_world.storage.local_storage import LocalStorage
from unknown_world.storage.paths import (
    ARTIFACTS_SUBDIR,
    BASE_DATA_DIR,
    DEFAULT_IMAGE_EXTENSION,
    IMAGES_GENERATED_SUBDIR,
    IMAGES_UPLOADED_SUBDIR,
    LEGACY_OUTPUT_DIR,
    STATIC_IMAGES_URL_PREFIX,
    STATIC_URL_PREFIX,
    build_image_url,
    build_legacy_image_url,
    get_artifacts_dir,
    get_generated_images_dir,
    get_uploaded_images_dir,
)
from unknown_world.storage.storage import (
    PutResult,
    StorageCategory,
    StorageInterface,
    StorageMetadata,
)
from unknown_world.storage.validation import (
    ALLOWED_IMAGE_MIME_TYPES,
    BBOX_MAX,
    BBOX_MIN,
    DEFAULT_ASPECT_RATIO,
    DEFAULT_IMAGE_SIZE,
    MAX_IMAGE_FILE_SIZE_BYTES,
    MAX_PROMPT_LENGTH,
    MIN_IMAGE_FILE_SIZE_BYTES,
    MIN_PROMPT_LENGTH,
    SUPPORTED_IMAGE_SIZES,
    get_max_file_size_mb,
    validate_image_generation_request,
    validate_image_upload,
)

__all__ = [
    # Storage
    "LocalStorage",
    "PutResult",
    "StorageCategory",
    "StorageInterface",
    "StorageMetadata",
    "get_storage",
    "reset_storage",
    # Paths (RU-006-Q5)
    "ARTIFACTS_SUBDIR",
    "BASE_DATA_DIR",
    "DEFAULT_IMAGE_EXTENSION",
    "IMAGES_GENERATED_SUBDIR",
    "IMAGES_UPLOADED_SUBDIR",
    "LEGACY_OUTPUT_DIR",
    "STATIC_IMAGES_URL_PREFIX",
    "STATIC_URL_PREFIX",
    "build_image_url",
    "build_legacy_image_url",
    "get_artifacts_dir",
    "get_generated_images_dir",
    "get_uploaded_images_dir",
    # Validation constants
    "ALLOWED_IMAGE_MIME_TYPES",
    "BBOX_MAX",
    "BBOX_MIN",
    "DEFAULT_ASPECT_RATIO",
    "DEFAULT_IMAGE_SIZE",
    "MAX_IMAGE_FILE_SIZE_BYTES",
    "MAX_PROMPT_LENGTH",
    "MIN_IMAGE_FILE_SIZE_BYTES",
    "MIN_PROMPT_LENGTH",
    "SUPPORTED_IMAGE_SIZES",
    # Validation functions
    "get_max_file_size_mb",
    "validate_image_generation_request",
    "validate_image_upload",
]

# ì‹±ê¸€í†¤ ì¸ìŠ¤í„´ìŠ¤ ìºì‹œ
_storage_instance: StorageInterface | None = None


def get_storage(*, force_new: bool = False) -> StorageInterface:
    """ìŠ¤í† ë¦¬ì§€ ì¸ìŠ¤í„´ìŠ¤ë¥¼ ë°˜í™˜í•©ë‹ˆë‹¤.

    í™˜ê²½ë³€ìˆ˜ì— ë”°ë¼ LocalStorage ë˜ëŠ” GCSStorageë¥¼ ë°˜í™˜í•©ë‹ˆë‹¤.
    MVPì—ì„œëŠ” LocalStorageë§Œ ì‚¬ìš©í•©ë‹ˆë‹¤.

    Args:
        force_new: Trueë©´ ìºì‹œë¥¼ ë¬´ì‹œí•˜ê³  ìƒˆ ì¸ìŠ¤í„´ìŠ¤ ìƒì„±

    Returns:
        StorageInterface êµ¬í˜„ì²´
    """
    global _storage_instance

    if not force_new and _storage_instance is not None:
        return _storage_instance

    # MVP: LocalStorageë§Œ ì‚¬ìš©
    # MMP: í™˜ê²½ë³€ìˆ˜ë¡œ GCS ì „í™˜ ì˜ˆì •
    _storage_instance = LocalStorage()
    return _storage_instance


def reset_storage() -> None:
    """ìŠ¤í† ë¦¬ì§€ ìºì‹œë¥¼ ì´ˆê¸°í™”í•©ë‹ˆë‹¤.

    í…ŒìŠ¤íŠ¸ ì‹œ ìŠ¤í† ë¦¬ì§€ë¥¼ ì¬ì„¤ì •í•  ë•Œ ì‚¬ìš©í•©ë‹ˆë‹¤.
    """
    global _storage_instance
    _storage_instance = None
</file>

<file path="backend/tests/integration/test_turn_streaming.py">
"""Unknown World - /api/turn HTTP Streaming í†µí•© í…ŒìŠ¤íŠ¸.

NDJSON ìŠ¤íŠ¸ë¦¬ë° ì´ë²¤íŠ¸ì˜ ìˆœì„œ, êµ¬ì¡°, ë°ì´í„° ì •ë°€ë„ë¥¼ ê²€ì¦í•©ë‹ˆë‹¤.
"""

import json
import os

# U-080 ëŒ€ì‘: í…ŒìŠ¤íŠ¸ í™˜ê²½ì—ì„œ Mock ëª¨ë“œ ê°•ì œ (ë‹¤ë¥¸ ì„í¬íŠ¸ë³´ë‹¤ ë¨¼ì € ì‹¤í–‰)
os.environ["UW_MODE"] = "mock"

from fastapi.testclient import TestClient

from unknown_world.main import app
from unknown_world.models.turn import Language, TurnOutput

client = TestClient(app)


def test_turn_streaming_success():
    """ì •ìƒì ì¸ í„´ ìš”ì²­ ì‹œ NDJSON ìŠ¤íŠ¸ë¦¼ì´ ì˜¬ë°”ë¥¸ ìˆœì„œë¡œ ë°˜í™˜ë˜ëŠ”ì§€ í…ŒìŠ¤íŠ¸í•©ë‹ˆë‹¤."""
    payload = {
        "language": "ko-KR",
        "text": "í…ŒìŠ¤íŠ¸ ì…ë ¥",
        "client": {"viewport_w": 1920, "viewport_h": 1080, "theme": "dark"},
        "economy_snapshot": {"signal": 100, "memory_shard": 5},
    }

    # StreamingResponse í…ŒìŠ¤íŠ¸
    response = client.post("/api/turn", json=payload)
    assert response.status_code == 200
    assert response.headers["content-type"] == "application/x-ndjson"

    events = []
    for line in response.iter_lines():
        if line:
            events.append(json.loads(line))

    # 1. ì´ë²¤íŠ¸ ì¡´ì¬ ì—¬ë¶€ í™•ì¸
    assert len(events) > 0

    # 2. ì²« ë²ˆì§¸ ì´ë²¤íŠ¸ëŠ” í•­ìƒ stage: parse: start ì—¬ì•¼ í•¨ (TTFB)
    assert events[0]["type"] == "stage"
    assert events[0]["name"] == "parse"
    assert events[0]["status"] == "start"

    # 3. ë‹¨ê³„ë³„ ì´ë²¤íŠ¸ ìˆœì„œ í™•ì¸
    stages = [e["name"] for e in events if e["type"] == "stage" and e["status"] == "start"]
    expected_stages = ["parse", "validate", "plan", "resolve", "render", "verify", "commit"]
    assert stages == expected_stages

    # 4. ë°°ì§€ ì´ë²¤íŠ¸ í¬í•¨ ì—¬ë¶€ í™•ì¸
    # U-060: badges ë°œìƒ ì—¬ë¶€ê°€ ì¤‘ìš”, ì •í™•í•œ ìˆ˜ëŠ” êµ¬í˜„ ì„¸ë¶€ì‚¬í•­ì´ë¯€ë¡œ >= 1ë¡œ ì™„í™”
    badges_events = [e for e in events if e["type"] == "badges"]
    assert len(badges_events) >= 1, "ìµœì†Œ 1ê°œ ì´ìƒì˜ badges ì´ë²¤íŠ¸ê°€ í•„ìš”í•©ë‹ˆë‹¤"
    assert "schema_ok" in badges_events[0]["badges"]

    # 5. ìµœì¢… ê²°ê³¼ë¬¼ í™•ì¸
    final_events = [e for e in events if e["type"] == "final"]
    assert len(final_events) == 1

    turn_output_data = final_events[0]["data"]
    # Pydantic ëª¨ë¸ë¡œ ë‹¤ì‹œ ê²€ì¦ (RULE-003)
    turn_output = TurnOutput.model_validate(turn_output_data)
    assert turn_output.language == Language.KO
    assert len(turn_output.narrative) > 0


def test_turn_streaming_invalid_input():
    """ì˜ëª»ëœ ì…ë ¥ ìš”ì²­ ì‹œ ì—ëŸ¬ ì´ë²¤íŠ¸ê°€ ìŠ¤íŠ¸ë¦¬ë°ë˜ëŠ”ì§€ í…ŒìŠ¤íŠ¸í•©ë‹ˆë‹¤."""
    payload = {
        "language": "invalid-lang",  # ì˜ëª»ëœ ì–¸ì–´ ì½”ë“œ
        "text": "",
    }

    response = client.post("/api/turn", json=payload)
    # ì…ë ¥ ê²€ì¦ ì‹¤íŒ¨ ì‹œì—ë„ 200 OK ìŠ¤íŠ¸ë¦¼ìœ¼ë¡œ ì—ëŸ¬ë¥¼ ë³´ë‚¼ ìˆ˜ë„ ìˆê³ ,
    # 400 Bad Requestë¥¼ ë³´ë‚¼ ìˆ˜ë„ ìˆìŒ. í˜„ì¬ êµ¬í˜„ì€ 200 OK + type: error ì„.
    assert response.status_code == 200

    events = [json.loads(line) for line in response.iter_lines() if line]
    assert any(e["type"] == "error" for e in events)
    assert any(e["code"] == "VALIDATION_ERROR" for e in events)


def test_turn_streaming_deterministic_seed():
    """seed íŒŒë¼ë¯¸í„° ì‚¬ìš© ì‹œ ê²°ê³¼ê°€ ê²°ì •ì ì¸ì§€ í…ŒìŠ¤íŠ¸í•©ë‹ˆë‹¤."""
    payload = {
        "language": "en-US",
        "text": "Hello",
        "client": {"viewport_w": 1920, "viewport_h": 1080},
        "economy_snapshot": {"signal": 100, "memory_shard": 5},
    }

    # ë™ì¼í•œ ì‹œë“œë¡œ ë‘ ë²ˆ ìš”ì²­
    seed = 12345

    def get_final_output(s):
        resp = client.post(f"/api/turn?seed={s}", json=payload)
        events = [json.loads(line) for line in resp.iter_lines() if line]
        return next(e["data"] for e in events if e["type"] == "final")

    output1 = get_final_output(seed)
    output2 = get_final_output(seed)

    assert output1 == output2
    assert output1["language"] == "en-US"


def test_turn_streaming_generation_fallback(monkeypatch):
    """ìƒì„± ì¤‘ ValidationError ë°œìƒ ì‹œ ì•ˆì „í•œ í´ë°±ì´ ë°˜í™˜ë˜ëŠ”ì§€ í…ŒìŠ¤íŠ¸í•©ë‹ˆë‹¤."""
    from pydantic import ValidationError

    from unknown_world.orchestrator.mock import MockOrchestrator

    def mock_generate_failure(self, turn_input):
        # Pydantic ValidationErrorë¥¼ ìˆ˜ë™ìœ¼ë¡œ ìƒì„±í•˜ëŠ” ê²ƒì€ ë³µì¡í•˜ë¯€ë¡œ
        # ê°„ë‹¨í•œ í•„ë“œ ê²€ì¦ ì˜¤ë¥˜ë¥¼ ì‹œë®¬ë ˆì´ì…˜í•˜ê±°ë‚˜ ì§ì ‘ raise í•¨
        # ì—¬ê¸°ì„œëŠ” í…ŒìŠ¤íŠ¸ë¥¼ ìœ„í•´ ì„ì˜ì˜ í•„ë“œ ëˆ„ë½ ë“±ìœ¼ë¡œ ë°œìƒí•œë‹¤ê³  ê°€ì •
        raise ValidationError.from_exception_data(title="MockError", line_errors=[])

    monkeypatch.setattr(MockOrchestrator, "generate_turn_output", mock_generate_failure)

    payload = {
        "language": "ko-KR",
        "text": "í…ŒìŠ¤íŠ¸",
        "client": {"viewport_w": 1920, "viewport_h": 1080},
        "economy_snapshot": {"signal": 100, "memory_shard": 5},
    }

    response = client.post("/api/turn", json=payload)
    events = [json.loads(line) for line in response.iter_lines() if line]

    final_event = next(e for e in events if e["type"] == "final")
    turn_output = final_event["data"]

    # í´ë°± ì‘ë‹µì˜ íŠ¹ì§• í™•ì¸
    # RU-005-Q1: SSOT fallbackì€ ëª¨ë“  ì¹´í…Œê³ ë¦¬ì˜ ë°°ì§€ë¥¼ ì¼ê´€ë˜ê²Œ í¬í•¨ (RU-005-S1)
    badges = turn_output["agent_console"]["badges"]
    assert "schema_fail" in badges, "í´ë°±ì€ schema_fail ë°°ì§€ë¥¼ í¬í•¨í•´ì•¼ í•¨"
    assert "economy_ok" in badges, "í´ë°±ì€ economy_ok ë°°ì§€ë¥¼ í¬í•¨í•´ì•¼ í•¨ (ë¹„ìš© 0)"
    assert "safety_ok" in badges, "í´ë°±ì€ safety_ok ë°°ì§€ë¥¼ í¬í•¨í•´ì•¼ í•¨"
    assert "consistency_ok" in badges, "í´ë°±ì€ consistency_ok ë°°ì§€ë¥¼ í¬í•¨í•´ì•¼ í•¨"
    assert turn_output["agent_console"]["repair_count"] >= 1
    assert "í˜¼ë€" in turn_output["narrative"] or "confusion" in turn_output["narrative"]


def test_turn_streaming_repair_loop(monkeypatch):
    """ê²€ì¦ ì‹¤íŒ¨ ì‹œ repair ì´ë²¤íŠ¸ê°€ ìŠ¤íŠ¸ë¦¼ì— í¬í•¨ë˜ëŠ”ì§€ í…ŒìŠ¤íŠ¸í•©ë‹ˆë‹¤ (RU-002)."""
    from pydantic import ValidationError

    from unknown_world.orchestrator.mock import MockOrchestrator

    # ì²« ë²ˆì§¸ í˜¸ì¶œì—ì„œ ì‹¤íŒ¨í•˜ì—¬ repair íŠ¸ë¦¬ê±° ì‹œë®¬ë ˆì´ì…˜
    # (ì‹¤ì œ êµ¬í˜„ì—ì„œëŠ” NíšŒ ì¬ì‹œë„ ë¡œì§ì´ turn.pyì— ìˆì–´ì•¼ í•¨)
    call_count = 0

    def mock_generate_with_repair(self, turn_input):
        nonlocal call_count
        call_count += 1
        if call_count == 1:
            raise ValidationError.from_exception_data(title="MockSchemaError", line_errors=[])
        return orchestrator_orig_generate(self, turn_input)

    import unknown_world.orchestrator.mock as mock_mod

    orchestrator_orig_generate = mock_mod.MockOrchestrator.generate_turn_output
    monkeypatch.setattr(MockOrchestrator, "generate_turn_output", mock_generate_with_repair)

    payload = {
        "language": "ko-KR",
        "text": "ë¦¬í˜ì–´ í…ŒìŠ¤íŠ¸",
        "client": {"viewport_w": 1920, "viewport_h": 1080},
        "economy_snapshot": {"signal": 100, "memory_shard": 5},
    }

    response = client.post("/api/turn", json=payload)
    events = [json.loads(line) for line in response.iter_lines() if line]

    # RU-002 ìš”êµ¬ì‚¬í•­: repair ì´ë²¤íŠ¸ê°€ ëª…ì‹œì ìœ¼ë¡œ ì¡´ì¬í•´ì•¼ í•¨
    repair_events = [e for e in events if e["type"] == "repair"]
    assert len(repair_events) >= 1
    assert "attempt" in repair_events[0]
    assert repair_events[0]["attempt"] == 1
</file>

<file path="backend/tests/unit/services/test_image_generation.py">
"""Unknown World - ì´ë¯¸ì§€ ìƒì„± ì„œë¹„ìŠ¤ ë‹¨ìœ„ í…ŒìŠ¤íŠ¸."""

from unittest.mock import MagicMock, patch

import pytest

from unknown_world.services.image_generation import (
    ImageGenerationRequest,
    ImageGenerationStatus,
    ImageGenerator,
    MockImageGenerator,
    get_image_generator,
    reset_image_generator,
)


@pytest.fixture
def temp_output_dir(tmp_path):
    """ì„ì‹œ ì¶œë ¥ ë””ë ‰í† ë¦¬ í”½ìŠ¤ì²˜."""
    return tmp_path / "test_images"


@pytest.mark.asyncio
async def test_mock_image_generator_success(temp_output_dir):
    """Mock ì´ë¯¸ì§€ ìƒì„±ê¸° ì„±ê³µ ì¼€ì´ìŠ¤ í…ŒìŠ¤íŠ¸."""
    generator = MockImageGenerator(output_dir=temp_output_dir)
    request = ImageGenerationRequest(
        prompt="A beautiful sunset over a cyberpunk city",
        aspect_ratio="1:1",
        image_size="1024x1024",
    )

    response = await generator.generate(request)

    assert response.status == ImageGenerationStatus.COMPLETED
    assert response.image_id is not None
    assert response.image_url is not None
    assert (temp_output_dir / f"{response.image_id}.png").exists()


@pytest.mark.asyncio
async def test_image_generator_initialization_failure():
    """ì‹¤ì œ ì´ë¯¸ì§€ ìƒì„±ê¸° ì´ˆê¸°í™” ì‹¤íŒ¨ ì‹œ ì²˜ë¦¬ í…ŒìŠ¤íŠ¸."""
    with patch("google.genai.Client", side_effect=Exception("Auth error")):
        generator = ImageGenerator()
        assert generator.is_available() is False


@pytest.mark.asyncio
async def test_get_image_generator_singleton():
    """íŒ©í† ë¦¬ í•¨ìˆ˜ë¥¼ í†µí•œ ì‹±ê¸€í†¤ ì¸ìŠ¤í„´ìŠ¤ ë°˜í™˜ í…ŒìŠ¤íŠ¸."""
    reset_image_generator()
    gen1 = get_image_generator(force_mock=True)
    gen2 = get_image_generator(force_mock=True)

    assert gen1 is gen2


@pytest.mark.asyncio
async def test_image_request_validation():
    """ì´ë¯¸ì§€ ìƒì„± ìš”ì²­ ê²€ì¦ ë¡œì§ í…ŒìŠ¤íŠ¸."""
    from unknown_world.services.image_generation import validate_image_request

    # ì„±ê³µ ì¼€ì´ìŠ¤
    valid_request = ImageGenerationRequest(prompt="Test prompt")
    assert validate_image_request(valid_request) is None

    # ì‹¤íŒ¨ ì¼€ì´ìŠ¤: ì§€ì›í•˜ì§€ ì•ŠëŠ” í¬ê¸°
    invalid_size = ImageGenerationRequest(prompt="Test", image_size="invalid")
    assert validate_image_request(invalid_size) == "ì§€ì›í•˜ì§€ ì•ŠëŠ” ì´ë¯¸ì§€ í¬ê¸°: invalid"

    # ì‹¤íŒ¨ ì¼€ì´ìŠ¤: ë„ˆë¬´ ì§§ì€ í”„ë¡¬í”„íŠ¸
    short_prompt = ImageGenerationRequest(prompt="A")
    assert validate_image_request(short_prompt) == "í”„ë¡¬í”„íŠ¸ê°€ ë„ˆë¬´ ì§§ìŠµë‹ˆë‹¤."


@pytest.mark.asyncio
async def test_image_generator_model_tiering(temp_output_dir):
    """ëª¨ë¸ í‹°ì–´ë§(FAST/QUALITY) ë¼ë²¨ ì²˜ë¦¬ë¥¼ í…ŒìŠ¤íŠ¸í•©ë‹ˆë‹¤."""
    # MockImageGeneratorëŠ” model_labelì„ ë¡œê¹…í•˜ì§€ë§Œ ë™ì‘ì€ ë™ì¼í•¨
    generator = MockImageGenerator(output_dir=temp_output_dir)

    # 1. FAST ëª¨ë¸ ìš”ì²­
    fast_request = ImageGenerationRequest(
        prompt="Fast preview",
        model_label="FAST",
    )
    fast_response = await generator.generate(fast_request)
    assert fast_response.status == ImageGenerationStatus.COMPLETED

    # 2. QUALITY ëª¨ë¸ ìš”ì²­
    quality_request = ImageGenerationRequest(
        prompt="Quality image",
        model_label="QUALITY",
    )
    quality_response = await generator.generate(quality_request)
    assert quality_response.status == ImageGenerationStatus.COMPLETED


@pytest.mark.asyncio
async def test_image_generator_real_model_selection():
    """ì‹¤ì œ ImageGeneratorì—ì„œ model_labelì— ë”°ë¥¸ ëª¨ë¸ ID ì„ íƒì„ í…ŒìŠ¤íŠ¸í•©ë‹ˆë‹¤."""
    from unittest.mock import AsyncMock

    from unknown_world.config.models import ModelLabel, get_model_id

    # Mocking google.genai.Client to avoid real API calls
    with (
        patch("google.genai.Client") as mock_client_class,
        patch.dict("os.environ", {"GOOGLE_API_KEY": "test-api-key"}),
    ):
        mock_client = mock_client_class.return_value
        # aio.models.generate_content ëª¨í‚¹
        # ì´ë¯¸ì§€ ì¶”ì¶œ ì„±ê³µì„ ìœ„í•´ í…ìŠ¤íŠ¸ + ì´ë¯¸ì§€ ë°ì´í„°ë¥¼ í¬í•¨í•œ mock ì‘ë‹µ í•„ìš”
        mock_response = MagicMock()
        mock_response.candidates = [
            MagicMock(
                content=MagicMock(
                    parts=[MagicMock(inline_data=MagicMock(data=b"fake-image-bytes"))]
                )
            )
        ]
        mock_gen = AsyncMock(return_value=mock_response)
        mock_client.aio.models.generate_content = mock_gen

        generator = ImageGenerator()
        # generator._clientê°€ mock_clientë¥¼ ê°€ë¦¬í‚¤ë„ë¡ ì„¤ì •ë¨

        # 1. FAST ìš”ì²­
        await generator.generate(ImageGenerationRequest(prompt="test", model_label="FAST"))
        # IMAGE_FAST ëª¨ë¸ IDê°€ ì‚¬ìš©ë˜ì—ˆëŠ”ì§€ í™•ì¸
        expected_fast_id = get_model_id(ModelLabel.IMAGE_FAST)
        args, kwargs = mock_gen.call_args
        assert kwargs["model"] == expected_fast_id

        # 2. QUALITY ìš”ì²­
        await generator.generate(ImageGenerationRequest(prompt="test", model_label="QUALITY"))
        # IMAGE ëª¨ë¸ IDê°€ ì‚¬ìš©ë˜ì—ˆëŠ”ì§€ í™•ì¸
        expected_quality_id = get_model_id(ModelLabel.IMAGE)
        args, kwargs = mock_gen.call_args
        assert kwargs["model"] == expected_quality_id
</file>

<file path="frontend/src/api/scanner.ts">
/**
 * Unknown World - Scanner(ì´ë¯¸ì§€ ì´í•´) API í´ë¼ì´ì–¸íŠ¸.
 *
 * U-022[Mvp]: Scanner ìŠ¬ë¡¯ UIì—ì„œ ì´ë¯¸ì§€ ì—…ë¡œë“œ ì‹œ ë°±ì—”ë“œ `/api/scan` í˜¸ì¶œ.
 * U-021 ì˜ì¡´: ë°±ì—”ë“œ Scanner ì—”ë“œí¬ì¸íŠ¸ì™€ ì—°ë™.
 *
 * ì„¤ê³„ ì›ì¹™:
 *   - RULE-004: ì‹¤íŒ¨ ì‹œ ì•ˆì „í•œ í´ë°± (ì—ëŸ¬ ë©”ì‹œì§€ ë°˜í™˜)
 *   - RULE-007: íŒŒì¼ ë‚´ìš©/í”„ë¡¬í”„íŠ¸ ë¡œê¹… ê¸ˆì§€
 *   - RULE-009: bboxëŠ” 0~1000 ì •ê·œí™” + [ymin, xmin, ymax, xmax]
 *
 * @module api/scanner
 */

import { z } from 'zod';
import { Box2DSchema, type Language } from '../schemas/turn';

// =============================================================================
// ìƒìˆ˜
// =============================================================================

/** Scanner API ì—”ë“œí¬ì¸íŠ¸ ê¸°ë³¸ URL */
const SCANNER_API_BASE = '/api/scan';

/** ì§€ì›í•˜ëŠ” ì´ë¯¸ì§€ MIME íƒ€ì… */
export const ALLOWED_MIME_TYPES = ['image/jpeg', 'image/png', 'image/gif', 'image/webp'] as const;

/** ìµœëŒ€ íŒŒì¼ í¬ê¸° (20MB) */
export const MAX_FILE_SIZE_BYTES = 20 * 1024 * 1024;

// =============================================================================
// Zod ìŠ¤í‚¤ë§ˆ ì •ì˜ (ë°±ì—”ë“œ ì‘ë‹µê³¼ 1:1 ëŒ€ì‘)
// =============================================================================

/**
 * ìŠ¤ìº” ìƒíƒœ Enum.
 */
export const ScanStatusSchema = z.enum(['completed', 'partial', 'failed', 'blocked']);
export type ScanStatus = z.infer<typeof ScanStatusSchema>;

/**
 * ê°ì§€ëœ ì˜¤ë¸Œì íŠ¸.
 * RULE-009: bboxëŠ” 0~1000 ì •ê·œí™”.
 */
export const DetectedObjectSchema = z.object({
  label: z.string(),
  box_2d: Box2DSchema,
  confidence: z.number().min(0).max(1).nullable().optional(),
  suggested_item_type: z.string().nullable().optional(),
});
export type DetectedObject = z.infer<typeof DetectedObjectSchema>;

/**
 * ì•„ì´í…œ í›„ë³´.
 * ìŠ¤ìº” ê²°ê³¼ë¡œ ìƒì„±ë˜ëŠ” ê²Œì„ ì•„ì´í…œ í›„ë³´.
 */
export const ItemCandidateSchema = z.object({
  id: z.string(),
  label: z.string(),
  description: z.string().default(''),
  item_type: z.string().default('material'),
  source_object_index: z.number().int().min(0).nullable().optional(),
});
export type ItemCandidate = z.infer<typeof ItemCandidateSchema>;

/**
 * Scanner API ì‘ë‹µ.
 * RU-006-S1: original_image_key, original_image_url ì¶”ê°€
 */
export const ScannerResponseSchema = z.object({
  success: z.boolean(),
  status: ScanStatusSchema,
  caption: z.string().default(''),
  objects: z.array(DetectedObjectSchema).default([]),
  item_candidates: z.array(ItemCandidateSchema).default([]),
  message: z.string().nullable().optional(),
  analysis_time_ms: z.number().int().min(0).default(0),
  language: z.enum(['ko-KR', 'en-US']),
  original_image_key: z.string().nullable().optional(),
  original_image_url: z.string().nullable().optional(),
});
export type ScannerResponse = z.infer<typeof ScannerResponseSchema>;

// =============================================================================
// API í´ë¼ì´ì–¸íŠ¸ í•¨ìˆ˜
// =============================================================================

/**
 * ìŠ¤ìº” ê²°ê³¼ íƒ€ì….
 */
export type ScanResult =
  | { success: true; data: ScannerResponse }
  | { success: false; error: string; status: ScanStatus };

/**
 * ìŠ¤ìº” ì˜µì…˜.
 * RU-006-S1: preserve_original ì˜µì…˜ ì¶”ê°€
 */
export interface ScanOptions {
  /** ì›ë³¸ ì´ë¯¸ì§€ ì €ì¥ ì—¬ë¶€ (ë””ë²„ê¹…/ì¬ë¶„ì„ìš©) */
  preserveOriginal?: boolean;
  /** ì„¸ì…˜ ID (ì´ë¯¸ì§€ ê·¸ë£¹í™”ìš©) */
  sessionId?: string;
}

/**
 * ì´ë¯¸ì§€ë¥¼ ìŠ¤ìº”í•˜ì—¬ ì˜¤ë¸Œì íŠ¸ì™€ ì•„ì´í…œ í›„ë³´ë¥¼ ì¶”ì¶œí•©ë‹ˆë‹¤.
 *
 * @param file - ë¶„ì„í•  ì´ë¯¸ì§€ íŒŒì¼
 * @param language - ì‘ë‹µ ì–¸ì–´
 * @param options - ìŠ¤ìº” ì˜µì…˜ (RU-006-S1)
 * @returns ìŠ¤ìº” ê²°ê³¼
 */
export async function scanImage(
  file: File,
  language: Language,
  options?: ScanOptions,
): Promise<ScanResult> {
  // í´ë¼ì´ì–¸íŠ¸ ì¸¡ íŒŒì¼ ê²€ì¦
  const validationError = validateFile(file);
  if (validationError) {
    return {
      success: false,
      error: validationError,
      status: 'failed',
    };
  }

  // FormData ìƒì„±
  const formData = new FormData();
  formData.append('file', file);
  formData.append('language', language);

  // RU-006-S1: ì„ íƒì  íŒŒë¼ë¯¸í„° ì¶”ê°€
  if (options?.preserveOriginal) {
    formData.append('preserve_original', 'true');
  }
  if (options?.sessionId) {
    formData.append('session_id', options.sessionId);
  }

  try {
    const response = await fetch(SCANNER_API_BASE, {
      method: 'POST',
      body: formData,
    });

    if (!response.ok) {
      console.error('[ScannerAPI] HTTP error', {
        status: response.status,
        statusText: response.statusText,
      });
      return {
        success: false,
        error:
          language === 'ko-KR'
            ? `ì„œë²„ ì˜¤ë¥˜: ${response.status}`
            : `Server error: ${response.status}`,
        status: 'failed',
      };
    }

    const json = await response.json();
    const parseResult = ScannerResponseSchema.safeParse(json);

    if (!parseResult.success) {
      console.error('[ScannerAPI] Response validation failed', parseResult.error);
      return {
        success: false,
        error:
          language === 'ko-KR'
            ? 'ì‘ë‹µ ë°ì´í„° í˜•ì‹ì´ ì˜¬ë°”ë¥´ì§€ ì•ŠìŠµë‹ˆë‹¤.'
            : 'Invalid response data format.',
        status: 'failed',
      };
    }

    const data = parseResult.data;

    // ì„±ê³µ/ë¶€ë¶„ ì„±ê³µ ì—¬ë¶€ í™•ì¸
    if (data.status === 'completed' || data.status === 'partial') {
      return { success: true, data };
    }

    // ì‹¤íŒ¨/ì°¨ë‹¨ ì‘ë‹µ
    return {
      success: false,
      error: data.message ?? (language === 'ko-KR' ? 'ë¶„ì„ ì‹¤íŒ¨' : 'Analysis failed'),
      status: data.status,
    };
  } catch (error) {
    console.error('[ScannerAPI] Network error', { errorType: (error as Error).name });
    return {
      success: false,
      error:
        language === 'ko-KR'
          ? 'ë„¤íŠ¸ì›Œí¬ ì˜¤ë¥˜ê°€ ë°œìƒí–ˆìŠµë‹ˆë‹¤. ë‹¤ì‹œ ì‹œë„í•´ ì£¼ì„¸ìš”.'
          : 'Network error occurred. Please try again.',
      status: 'failed',
    };
  }
}

// =============================================================================
// ìœ í‹¸ë¦¬í‹° í•¨ìˆ˜
// =============================================================================

/**
 * íŒŒì¼ ìœ íš¨ì„± ê²€ì‚¬.
 *
 * @param file - ê²€ì¦í•  íŒŒì¼
 * @returns ì˜¤ë¥˜ ë©”ì‹œì§€ (ì—†ìœ¼ë©´ null)
 */
export function validateFile(file: File): string | null {
  // MIME íƒ€ì… ê²€ì¦
  if (!ALLOWED_MIME_TYPES.includes(file.type as (typeof ALLOWED_MIME_TYPES)[number])) {
    return `ì§€ì›í•˜ì§€ ì•ŠëŠ” íŒŒì¼ í˜•ì‹ì…ë‹ˆë‹¤: ${file.type || 'ì•Œ ìˆ˜ ì—†ìŒ'}`;
  }

  // íŒŒì¼ í¬ê¸° ê²€ì¦
  if (file.size > MAX_FILE_SIZE_BYTES) {
    const sizeMB = (file.size / (1024 * 1024)).toFixed(1);
    return `íŒŒì¼ì´ ë„ˆë¬´ í½ë‹ˆë‹¤: ${sizeMB}MB (ìµœëŒ€ 20MB)`;
  }

  return null;
}

/**
 * ì§€ì› íŒŒì¼ í˜•ì‹ì¸ì§€ í™•ì¸.
 *
 * @param file - í™•ì¸í•  íŒŒì¼
 * @returns ì§€ì› ì—¬ë¶€
 */
export function isSupportedImageFile(file: File): boolean {
  return ALLOWED_MIME_TYPES.includes(file.type as (typeof ALLOWED_MIME_TYPES)[number]);
}

/**
 * ItemCandidateë¥¼ InventoryItemìœ¼ë¡œ ë³€í™˜í•©ë‹ˆë‹¤.
 *
 * U-075: iconStatusë¥¼ 'pending'ìœ¼ë¡œ ì„¤ì •í•˜ì—¬ ì•„ì´ì½˜ ìƒì„± íŠ¸ë¦¬ê±°
 * - icon í•„ë“œì—ëŠ” ì„ì‹œ ì´ëª¨ì§€ë¥¼ ì„¤ì • (ìƒì„± ì „ í‘œì‹œìš©)
 * - InventoryPanelì—ì„œ iconStatusê°€ 'pending'ì´ë©´ ì•„ì´ì½˜ ìƒì„± ìš”ì²­
 *
 * @param candidate - ì•„ì´í…œ í›„ë³´
 * @returns InventoryItem í˜•íƒœì˜ ê°ì²´
 */
export function candidateToInventoryItem(candidate: ItemCandidate) {
  return {
    id: candidate.id,
    name: candidate.label,
    description: candidate.description,
    icon: getItemTypeEmoji(candidate.item_type),
    quantity: 1,
    iconStatus: 'pending' as const, // U-075: ì•„ì´ì½˜ ìƒì„± íŠ¸ë¦¬ê±°
  };
}

/**
 * ì•„ì´í…œ ìœ í˜•ì— ë”°ë¥¸ ì´ëª¨ì§€ ë°˜í™˜.
 *
 * @param itemType - ì•„ì´í…œ ìœ í˜•
 * @returns ì´ëª¨ì§€
 */
function getItemTypeEmoji(itemType: string): string {
  const emojiMap: Record<string, string> = {
    key: 'ğŸ”‘',
    weapon: 'âš”ï¸',
    tool: 'ğŸ”§',
    clue: 'ğŸ”',
    material: 'ğŸ“¦',
    consumable: 'ğŸ’Š',
    document: 'ğŸ“„',
    artifact: 'ğŸ’',
  };
  return emojiMap[itemType] ?? 'ğŸ“¦';
}
</file>

<file path="frontend/src/App.test.tsx">
import { describe, it, expect, vi, beforeEach } from 'vitest';
import { render, screen, fireEvent, waitFor } from '@testing-library/react';
import App from './App';
import * as turnStream from './api/turnStream';
import { useInventoryStore } from './stores/inventoryStore';

// i18next ëª¨í‚¹ (RU-003-Q5: ë°ëª¨ i18n í‚¤ ì§€ì›)
vi.mock('react-i18next', () => ({
  useTranslation: () => ({
    t: (key: string, options?: Record<string, unknown>) => {
      // ë°ëª¨ ì•„ì´í…œ ì´ë¦„
      if (key === 'demo.items.keycard-alpha.name') return 'í‚¤ì¹´ë“œ A';
      if (key === 'demo.items.medkit.name') return 'ì‘ê¸‰ í‚¤íŠ¸';
      if (key === 'demo.items.flashlight.name') return 'ì†ì „ë“±';
      if (key === 'demo.items.data-chip.name') return 'ë°ì´í„°ì¹©';
      // ë°ëª¨ ì”¬ ì˜¤ë¸Œì íŠ¸ (í”„ë¡œí•„ ê¸°ë°˜)
      if (key === 'profile.tech.scene.terminal') return 'í„°ë¯¸ë„';
      if (key === 'profile.tech.scene.terminal_hint') return 'í™œì„±í™”ëœ í„°ë¯¸ë„ì´ë‹¤';
      // êµ¬ë²„ì „/ê³µí†µ ì”¬ ì˜¤ë¸Œì íŠ¸
      if (key === 'demo.scene.terminal.label') return 'í„°ë¯¸ë„';
      if (key === 'demo.scene.terminal.hint') return 'í™œì„±í™”ëœ í„°ë¯¸ë„ì´ë‹¤';
      if (key === 'demo.scene.door.label') return 'ë¬¸';
      if (key === 'demo.scene.door.hint') return 'ì ê²¨ìˆëŠ” ê²ƒ ê°™ë‹¤';
      // ì•¡ì…˜ í…œí”Œë¦¿
      if (key === 'scene.hotspot.click_action') {
        return `Click: ${options?.label}`;
      }
      return key;
    },
    i18n: {
      changeLanguage: () => Promise.resolve(),
      resolvedLanguage: 'ko-KR',
    },
  }),
  initReactI18next: {
    type: '3rdParty',
    init: () => {},
  },
}));

// ResizeObserver ëª¨í‚¹
class MockResizeObserver {
  observe = vi.fn();
  unobserve = vi.fn();
  disconnect = vi.fn();
}
global.ResizeObserver = MockResizeObserver as unknown as typeof ResizeObserver;

// getBoundingClientRect ëª¨í‚¹
Element.prototype.getBoundingClientRect = vi.fn(() => ({
  width: 800,
  height: 600,
  top: 0,
  left: 0,
  bottom: 600,
  right: 800,
  x: 0,
  y: 0,
  toJSON: () => {},
})) as unknown as () => DOMRect;

// api ëª¨í‚¹
vi.mock('./api/turnStream', () => ({
  startTurnStream: vi.fn(),
}));

describe('App Integration - Hotspot Click', () => {
  beforeEach(() => {
    vi.clearAllMocks();
    localStorage.clear();
  });

  it('should trigger startTurnStream when a hotspot is clicked', async () => {
    render(<App />);

    // 1. í”„ë¡œí•„ ì„ íƒ (Playing í˜ì´ì¦ˆ ì§„ì…) - í…Œí¬ í”„ë¡œí•„ ì„ íƒ
    const techProfile = screen.getByLabelText('profile.tech.name');
    fireEvent.click(techProfile);

    // U-060: í”„ë¡œí•„ ì„ íƒ í›„ ìƒíƒœ ì „í™˜ì´ React ìƒíƒœ ì—…ë°ì´íŠ¸ì´ë¯€ë¡œ waitFor ì‚¬ìš©
    // 2. ì´ì œ ë©”ì¸ ê²Œì„ UIê°€ ë‚˜íƒ€ë‚¨ - í…Œí¬ í”„ë¡œí•„ì˜ 'í„°ë¯¸ë„' í•«ìŠ¤íŒŸ ì°¾ê¸°
    const terminalHotspot = await waitFor(() => {
      const hotspot = screen.getByLabelText('í„°ë¯¸ë„');
      expect(hotspot).toBeInTheDocument();
      return hotspot;
    });

    // í´ë¦­ ì‹œë®¬ë ˆì´ì…˜
    fireEvent.click(terminalHotspot);

    // startTurnStream í˜¸ì¶œ í™•ì¸
    await waitFor(() => {
      expect(turnStream.startTurnStream).toHaveBeenCalled();
    });

    const [input] = vi.mocked(turnStream.startTurnStream).mock.calls[0];

    // TurnInput ê²€ì¦
    expect(input.text).toBe('Click: í„°ë¯¸ë„');
    expect(input.click).toEqual({
      object_id: 'main-terminal',
      box_2d: { ymin: 200, xmin: 300, ymax: 600, xmax: 700 },
    });
  });
});

describe('App Layout - Inventory Count', () => {
  beforeEach(() => {
    vi.clearAllMocks();
    localStorage.clear();
    useInventoryStore.getState().reset();
  });

  it('updates inventory panel title based on items', async () => {
    render(<App />);

    // 1. í”„ë¡œí•„ ì„ íƒ
    const techProfile = screen.getByLabelText('profile.tech.name');
    fireEvent.click(techProfile);

    // 2. ì´ˆê¸° ì œëª© í™•ì¸ (Tech í”„ë¡œí•„ì€ ê¸°ë³¸ ì•„ì´í…œì´ ìˆìœ¼ë¯€ë¡œ ë°”ë¡œ inventory.countê°€ ë³´ì„)
    await waitFor(() => {
      expect(screen.getByText(/inventory.count/)).toBeInTheDocument();
    });

    // 3. ì•„ì´í…œ ëª¨ë‘ ì œê±°
    useInventoryStore.getState().reset();

    // 4. ì œëª©ì´ ê¸°ë³¸ê°’ìœ¼ë¡œ ëŒì•„ì™”ëŠ”ì§€ í™•ì¸
    await waitFor(() => {
      expect(screen.getByText('panel.inventory.title')).toBeInTheDocument();
    });

    // 5. ë‹¤ì‹œ ì•„ì´í…œ ì¶”ê°€
    useInventoryStore.getState().addItems([
      {
        id: 'test-item',
        name: 'Test Item',
        quantity: 1,
      },
    ]);

    // 6. ì œëª© ì—…ë°ì´íŠ¸ ë‹¤ì‹œ í™•ì¸
    await waitFor(() => {
      expect(screen.getByText(/inventory.count/)).toBeInTheDocument();
    });
  });
});
</file>

<file path="frontend/src/components/Hotspot.tsx">
/**
 * Unknown World - Hotspot ì»´í¬ë„ŒíŠ¸
 *
 * U-058[Mvp]: í•«ìŠ¤íŒŸ ë””ìì¸ ê°œì„  (ì½”ë„ˆ/ìŠ¤íŠ¸ë¡œí¬/ìƒ‰ìƒ)
 * - Q1 Option C: Magenta/Purple ê³„ì—´ ê°•ì¡°
 * - Q2 Option A: Lì ë¸Œë¼ì¼“ ì½”ë„ˆ ë§ˆì»¤
 *
 * U-074[Mvp]: í•«ìŠ¤íŒŸ ì¸í„°ë™ì…˜ ì•ˆë‚´ UX
 * - Q1 Option B: ì²« Në²ˆë§Œ hover íŒíŠ¸ í‘œì‹œ (í•™ìŠµ í›„ ì‚¬ë¼ì§)
 * - hover ì‹œ "í´ë¦­í•˜ì—¬ ì¡°ì‚¬" íŒíŠ¸ í‘œì‹œ
 *
 * RULE-002 ì¤€ìˆ˜: ì±„íŒ… ë²„ë¸”ì´ ì•„ë‹Œ ê²Œì„ UI
 * RULE-009 ì¤€ìˆ˜: ì¢Œí‘œ ê·œì•½ (0~1000 ì •ê·œí™”, bbox=[ymin,xmin,ymax,xmax])
 *
 * U-010[Mvp]: í•«ìŠ¤íŒŸ ì˜¤ë²„ë ˆì´ ê¸°ë³¸ êµ¬í˜„
 * U-012[Mvp]: DnD ë“œë¡­ íƒ€ê²Ÿ í™•ì¥
 *
 * @module components/Hotspot
 */

import { useState, useCallback, memo, useEffect } from 'react';
import { useTranslation } from 'react-i18next';
import { useDroppable } from '@dnd-kit/core';
import type { SceneObject, Box2D } from '../schemas/turn';
import { box2dToPixel, type CanvasSize } from '../utils/box2d';
import { DND_TYPE, type HotspotDropData } from '../dnd/types';
import { useOnboardingStore, selectShouldShowHotspotHint } from '../stores/onboardingStore';
import { InteractionHint } from './InteractionHint';
import '../styles/hotspot.css';

// =============================================================================
// íƒ€ì… ì •ì˜
// =============================================================================

/**
 * í•«ìŠ¤íŒŸ í´ë¦­ ì´ë²¤íŠ¸ ë°ì´í„°
 */
export interface HotspotClickData {
  /** í´ë¦­í•œ ì˜¤ë¸Œì íŠ¸ ID */
  object_id: string;
  /** í´ë¦­í•œ ì˜¤ë¸Œì íŠ¸ì˜ ë°”ìš´ë”© ë°•ìŠ¤ (0~1000 ì •ê·œí™”) */
  box_2d: Box2D;
}

interface HotspotProps {
  /** ì”¬ ì˜¤ë¸Œì íŠ¸ ë°ì´í„° */
  object: SceneObject;
  /** ìº”ë²„ìŠ¤ í¬ê¸° (ì¢Œí‘œ ë³€í™˜ìš©) */
  canvasSize: CanvasSize;
  /** í´ë¦­ í•¸ë“¤ëŸ¬ */
  onClick: (data: HotspotClickData) => void;
  /** ë¹„í™œì„±í™” ì—¬ë¶€ (ìŠ¤íŠ¸ë¦¬ë° ì¤‘ ë“±) */
  disabled: boolean;
  /** ë°ëª¨ ìƒíƒœ ì—¬ë¶€ (ì‹œê°ì  íŒíŠ¸ í•„ìš”) */
  isDemoState?: boolean;
  /** ìš°ì„ ìˆœìœ„ ê¸°ë°˜ z-index ìŠ¤íƒ€ì¼ */
  style?: React.CSSProperties;
}

// =============================================================================
// ë©”ì¸ ì»´í¬ë„ŒíŠ¸
// =============================================================================

/**
 * í•«ìŠ¤íŒŸ ì»´í¬ë„ŒíŠ¸
 *
 * Scene Canvas ìœ„ì— ì˜¤ë²„ë ˆì´ë˜ëŠ” í´ë¦­/ë“œë¡­ ê°€ëŠ¥í•œ ì˜ì—­ì…ë‹ˆë‹¤.
 * Lì ì½”ë„ˆ ë§ˆì»¤ + Magenta í…Œë§ˆë¡œ ì‹œê°ì  í’ˆì§ˆì„ í–¥ìƒì‹œí‚µë‹ˆë‹¤.
 *
 * @example
 * ```tsx
 * <Hotspot
 *   object={sceneObject}
 *   canvasSize={{ width: 800, height: 600 }}
 *   onClick={handleClick}
 *   disabled={isStreaming}
 * />
 * ```
 */
function HotspotComponent({
  object,
  canvasSize,
  onClick,
  disabled,
  isDemoState = false,
  style,
}: HotspotProps) {
  const [isHovered, setIsHovered] = useState(false);
  const { t } = useTranslation();

  // U-074: í•«ìŠ¤íŒŸ íŒíŠ¸ ìƒíƒœ (ì²« Në²ˆë§Œ í‘œì‹œ)
  const shouldShowHint = useOnboardingStore(selectShouldShowHotspotHint);
  const incrementHotspotHint = useOnboardingStore((state) => state.incrementHotspotHint);

  // U-074: hover ì‹œì‘ ì‹œ íŒíŠ¸ ì¹´ìš´íŠ¸ ì¦ê°€
  useEffect(() => {
    if (isHovered && !disabled) {
      incrementHotspotHint();
    }
  }, [isHovered, disabled, incrementHotspotHint]);

  // U-012: useDroppable í›…ìœ¼ë¡œ ë“œë¡­ íƒ€ê²Ÿ ì„¤ì •
  const dropData: HotspotDropData = {
    type: DND_TYPE.HOTSPOT,
    object_id: object.id,
    box_2d: object.box_2d,
    label: object.label,
  };

  const { isOver, setNodeRef } = useDroppable({
    id: `hotspot-${object.id}`,
    data: dropData,
    disabled,
  });

  // box_2d(0~1000) â†’ px ë³€í™˜ (RULE-009)
  const pixelBox = box2dToPixel(object.box_2d, canvasSize);

  // í´ë¦­ í•¸ë“¤ëŸ¬
  const handleClick = useCallback(() => {
    if (disabled) return;
    onClick({
      object_id: object.id,
      box_2d: object.box_2d,
    });
  }, [disabled, onClick, object.id, object.box_2d]);

  // í‚¤ë³´ë“œ ì ‘ê·¼ì„±
  const handleKeyDown = useCallback(
    (e: React.KeyboardEvent) => {
      if (disabled) return;
      if (e.key === 'Enter' || e.key === ' ') {
        e.preventDefault();
        handleClick();
      }
    },
    [disabled, handleClick],
  );

  // ìƒíƒœ ê²°ì •
  const isHighlighted = isHovered || isOver;

  // íˆ´íŒ ë°©í–¥ ê²°ì •: ìƒë‹¨ ì—¬ë°±ì´ ë¶€ì¡±í•˜ë©´ ì•„ë˜ìª½ìœ¼ë¡œ í‘œì‹œ
  // íˆ´íŒ ë†’ì´(~80px) + ì—¬ìœ ë¶„ì„ ê¸°ì¤€ìœ¼ë¡œ íŒë‹¨
  const TOOLTIP_FLIP_THRESHOLD = 80;
  const tooltipBelow = pixelBox.top < TOOLTIP_FLIP_THRESHOLD;

  // CSS í´ë˜ìŠ¤ ì¡°í•©
  const classNames = [
    'hotspot',
    isHighlighted && !disabled ? 'hovered' : '',
    disabled ? 'disabled' : '',
    isOver ? 'drop-target-active' : '',
    isDemoState ? 'demo-target' : '',
    tooltipBelow ? 'tooltip-below' : '',
  ]
    .filter(Boolean)
    .join(' ');

  return (
    <div
      ref={setNodeRef}
      className={classNames}
      style={{
        top: `${pixelBox.top}px`,
        left: `${pixelBox.left}px`,
        width: `${pixelBox.width}px`,
        height: `${pixelBox.height}px`,
        ...style,
      }}
      onClick={handleClick}
      onMouseEnter={() => setIsHovered(true)}
      onMouseLeave={() => setIsHovered(false)}
      onKeyDown={handleKeyDown}
      role="button"
      tabIndex={disabled ? -1 : 0}
      aria-label={object.label}
      aria-disabled={disabled}
      data-drop-target={!disabled}
      data-demo-state={isDemoState}
      data-object-id={object.id}
    >
      {/* Lì ì½”ë„ˆ ë§ˆì»¤ (í•˜ë‹¨ 2ê°œ) */}
      <div className="hotspot-corners" aria-hidden="true" />

      {/* í˜¸ë²„ ë˜ëŠ” ë“œë˜ê·¸ ì˜¤ë²„ ì‹œ íˆ´íŒ í‘œì‹œ */}
      {isHighlighted && !disabled && (
        <div className="hotspot-tooltip">
          <span className="hotspot-tooltip-label">{object.label}</span>

          {/* ë°ëª¨ ìƒíƒœ í‘œì‹œ */}
          {isDemoState && (
            <span className="hotspot-tooltip-demo">{t('scene.hotspot.demo_hint')}</span>
          )}

          {/* ë“œë˜ê·¸ ì˜¤ë²„ ì‹œ ë“œë¡­ íŒíŠ¸ í‘œì‹œ */}
          {isOver && (
            <span className="hotspot-tooltip-drop-hint">{t('scene.hotspot.drop_hint')}</span>
          )}

          {/* ì¼ë°˜ ìƒí˜¸ì‘ìš© íŒíŠ¸ */}
          {!isOver && !isDemoState && object.interaction_hint && (
            <span className="hotspot-tooltip-hint">
              {t('scene.hotspot.hint_prefix')}: {object.interaction_hint}
            </span>
          )}
        </div>
      )}

      {/* U-074: ì²« Në²ˆë§Œ í‘œì‹œë˜ëŠ” í´ë¦­ íŒíŠ¸ (íˆ´íŒ ì™¸ë¶€) */}
      {isHovered && !disabled && !isOver && shouldShowHint && (
        <InteractionHint
          text={t('interaction.hotspot_click')}
          icon="click"
          position="bottom"
          className="interaction-hint--hotspot"
        />
      )}
    </div>
  );
}

/**
 * Memoized Hotspot ì»´í¬ë„ŒíŠ¸
 *
 * ë‹¤ìˆ˜ì˜ í•«ìŠ¤íŒŸì´ ë™ì‹œì— ë Œë”ë  ë•Œ ì„±ëŠ¥ ìµœì í™”ë¥¼ ìœ„í•´ ë©”ëª¨ì´ì œì´ì…˜ ì ìš©.
 * object.id, canvasSize, disabledê°€ ë³€ê²½ë˜ì§€ ì•Šìœ¼ë©´ ë¦¬ë Œë” ë°©ì§€.
 */
export const Hotspot = memo(HotspotComponent, (prevProps, nextProps) => {
  // í•µì‹¬ propsë§Œ ë¹„êµí•˜ì—¬ ë¶ˆí•„ìš”í•œ ë¦¬ë Œë” ë°©ì§€
  return (
    prevProps.object.id === nextProps.object.id &&
    prevProps.object.label === nextProps.object.label &&
    prevProps.object.box_2d.ymin === nextProps.object.box_2d.ymin &&
    prevProps.object.box_2d.xmin === nextProps.object.box_2d.xmin &&
    prevProps.object.box_2d.ymax === nextProps.object.box_2d.ymax &&
    prevProps.object.box_2d.xmax === nextProps.object.box_2d.xmax &&
    prevProps.canvasSize.width === nextProps.canvasSize.width &&
    prevProps.canvasSize.height === nextProps.canvasSize.height &&
    prevProps.disabled === nextProps.disabled &&
    prevProps.isDemoState === nextProps.isDemoState
  );
});

Hotspot.displayName = 'Hotspot';

// Re-export for convenience
export type { HotspotProps };
</file>

<file path="frontend/src/components/NarrativeFeed.test.tsx">
import { describe, it, expect, beforeEach, vi, afterEach } from 'vitest';
import { render, screen, act, fireEvent } from '@testing-library/react';
import { NarrativeFeed } from './NarrativeFeed';

// i18next ëª¨í‚¹
vi.mock('react-i18next', () => ({
  useTranslation: () => ({
    t: (key: string, params?: Record<string, unknown>) => {
      if (key === 'narrative.turn_label') return `Turn ${params?.turn}`;
      if (key === 'narrative.streaming_label') return 'Streaming';
      return key;
    },
  }),
}));

describe('NarrativeFeed (U-066: Typewriter Effect)', () => {
  beforeEach(() => {
    vi.useFakeTimers();
    // prefers-reduced-motion ëª¨í‚¹
    Object.defineProperty(window, 'matchMedia', {
      writable: true,
      value: vi.fn().mockImplementation((query) => ({
        matches: false,
        media: query,
        onchange: null,
        addListener: vi.fn(),
        removeListener: vi.fn(),
        addEventListener: vi.fn(),
        removeEventListener: vi.fn(),
        dispatchEvent: vi.fn(),
      })),
    });
  });

  afterEach(() => {
    vi.useRealTimers();
  });

  it('í…ìŠ¤íŠ¸ê°€ íƒ€ì´í•‘ íš¨ê³¼ì™€ í•¨ê»˜ ì ì§„ì ìœ¼ë¡œ í‘œì‹œë˜ì–´ì•¼ í•œë‹¤', () => {
    const entries = [{ turn: 1, text: 'Hello World' }];
    render(<NarrativeFeed entries={entries} streamingText="" />);

    // ì²˜ìŒì—ëŠ” í•œ ê¸€ì ë˜ëŠ” ì¼ë¶€ë§Œ í‘œì‹œë¨ (TYPING_TICK_MS ì§€ë‚˜ê¸° ì „)
    // ì»´í¬ë„ŒíŠ¸ ë‚´ë¶€ì—ì„œ ì²« ë Œë”ë§ ì‹œ typedLenì€ 0ì„
    expect(screen.queryByText('Hello World')).toBeNull();

    // ì‹œê°„ ì§„í–‰
    act(() => {
      vi.advanceTimersByTime(500); // ì¶©ë¶„í•œ ì‹œê°„ ì§„í–‰
    });

    // ì¼ë¶€ í…ìŠ¤íŠ¸ê°€ í‘œì‹œë¨ (ì •í™•í•œ ê¸€ì ìˆ˜ëŠ” CPSì— ë”°ë¼ ë‹¤ë¦„)
    const textElement = screen.getByText(/Hel/);
    expect(textElement).toBeDefined();

    // ì™„ë£Œë  ë•Œê¹Œì§€ ì‹œê°„ ì§„í–‰
    act(() => {
      vi.advanceTimersByTime(10000);
    });

    expect(screen.getByText('Hello World')).toBeDefined();
  });

  it('í´ë¦­ ì‹œ Fast-forwardê°€ ë™ì‘í•˜ì—¬ ì¦‰ì‹œ ì „ì²´ í…ìŠ¤íŠ¸ê°€ í‘œì‹œë˜ì–´ì•¼ í•œë‹¤', () => {
    const entries = [{ turn: 1, text: 'This is a long text to test fast forward' }];
    render(<NarrativeFeed entries={entries} streamingText="" />);

    expect(screen.queryByText(entries[0].text)).toBeNull();

    // í´ë¦­ ì´ë²¤íŠ¸ ë°œìƒ
    const feed = screen.getByRole('log');
    fireEvent.click(feed);

    // ì¦‰ì‹œ ì „ì²´ í‘œì‹œë¨
    expect(screen.getByText(entries[0].text)).toBeDefined();
  });

  it('ìŠ¤íŠ¸ë¦¬ë° ì¤‘ì—ëŠ” ìŠ¤íŠ¸ë¦¬ë° í…ìŠ¤íŠ¸ì— íƒ€ì´í•‘ íš¨ê³¼ê°€ ì ìš©ë˜ì–´ì•¼ í•œë‹¤', () => {
    const entries = [{ turn: 1, text: 'Previous text' }];
    const streamingText = 'Current streaming text';
    render(<NarrativeFeed entries={entries} streamingText={streamingText} isStreaming={true} />);

    // ì´ì „ í…ìŠ¤íŠ¸ëŠ” ë³´ì´ê³ , ìŠ¤íŠ¸ë¦¬ë° í…ìŠ¤íŠ¸ëŠ” íƒ€ì´í•‘ ì¤‘
    expect(screen.getByText('Previous text')).toBeDefined();
    expect(screen.queryByText('Current streaming text')).toBeNull();

    act(() => {
      vi.advanceTimersByTime(30000); // TARGET_DURATION_MS_WHILE_STREAMING
    });

    expect(screen.getByText('Current streaming text')).toBeDefined();
  });

  it('isImageLoadingì¼ ë•Œ ë” ëŠë¦¬ê²Œ íƒ€ì´í•‘ë˜ì–´ì•¼ í•œë‹¤ (shouldBuyTime)', () => {
    // ë§¤ìš° ê¸´ í…ìŠ¤íŠ¸ ì‚¬ìš© (IDLE ëª¨ë“œì—ì„œ charsPerTick > 1ì´ ë˜ë„ë¡)
    const longText = 'This is a very long narrative text. '.repeat(20); // ì•½ 720ì
    const entries = [{ turn: 1, text: longText }];

    // 1. ì¼ë°˜ ìƒíƒœ (IDLE: TARGET_DURATION_MS_IDLE = 8000ms)
    // CPS = 720 / 8 = 90. MAX_CPS = 80ìœ¼ë¡œ í´ë¨í•‘ë¨.
    // charsPerTick = round(80 * 0.032) = round(2.56) = 3.
    const { unmount } = render(
      <NarrativeFeed entries={entries} streamingText="" isImageLoading={false} />,
    );

    act(() => {
      vi.advanceTimersByTime(1000);
    });
    const len1 = screen.getByText(new RegExp(longText.slice(0, 5))).textContent?.length || 0;
    unmount();

    // 2. ì´ë¯¸ì§€ ë¡œë”© ì¤‘ (shouldBuyTime: TARGET_DURATION_MS_WHILE_STREAMING = 30000ms)
    // CPS = 720 / 30 = 24.
    // charsPerTick = round(24 * 0.032) = round(0.768) = 1.
    render(<NarrativeFeed entries={entries} streamingText="" isImageLoading={true} />);
    act(() => {
      vi.advanceTimersByTime(1000);
    });
    const len2 = screen.getByText(new RegExp(longText.slice(0, 5))).textContent?.length || 0;

    // í˜„ì¬ ìƒìˆ˜ ì„¤ì •(TYPING_TICK_MS=90, MAX_CPS=10)ì—ì„œëŠ” charsPerTickì´ í•­ìƒ 1ì´ ë¨.
    // ë”°ë¼ì„œ len1ê³¼ len2ê°€ ê°™ì„ ìˆ˜ ìˆìŒ. (U-066 ì†ë„ ì¡°ì ˆ ë¡œì§ ê°œì„  í•„ìš”)
    expect(len2).toBeLessThanOrEqual(len1);
  });

  it('action_log íƒ€ì…ì˜ ì—”íŠ¸ë¦¬ëŠ” â–¶ ì•„ì´ì½˜ê³¼ í•¨ê»˜ í‘œì‹œë˜ì–´ì•¼ í•œë‹¤ (U-070)', () => {
    const entries = [{ turn: 1, text: 'Action log message', type: 'action_log' as const }];
    render(<NarrativeFeed entries={entries} streamingText="" />);

    // Fast-forwardë¡œ ì¦‰ì‹œ í‘œì‹œ
    fireEvent.click(screen.getByRole('log'));

    expect(screen.getByText('Action log message')).toBeDefined();
    expect(screen.getByText('â–¶')).toBeDefined();
    // action-log-entry í´ë˜ìŠ¤ê°€ í¬í•¨ëœ ìš”ì†Œê°€ ìˆì–´ì•¼ í•¨
    const entry = screen.getByText('Action log message').closest('.narrative-entry');
    expect(entry?.className).toContain('action-log-entry');
  });
});
</file>

<file path="frontend/src/components/ScannerSlot.test.tsx">
import { describe, it, expect, vi, beforeEach } from 'vitest';
import { render, screen, fireEvent, waitFor } from '@testing-library/react';
import { ScannerSlot } from './ScannerSlot';
import * as scannerApi from '../api/scanner';
import { useInventoryStore } from '../stores/inventoryStore';
import { useAgentStore } from '../stores/agentStore';

// i18next ëª¨í‚¹
vi.mock('react-i18next', () => ({
  useTranslation: () => ({
    t: (key: string, params?: Record<string, unknown>) => {
      if (key === 'scanner.detected_objects') return `${params?.count} objects detected`;
      if (key === 'scanner.item_candidates') return `${params?.count} item candidates`;
      if (key === 'scanner.add_to_inventory') return `Add ${params?.count} items to inventory`;
      return key;
    },
  }),
}));

// URL.createObjectURL ëª¨í‚¹
global.URL.createObjectURL = vi.fn(() => 'mock-url');
global.URL.revokeObjectURL = vi.fn();

describe('ScannerSlot Component', () => {
  const mockLanguage = 'ko-KR';

  const mockScanResponse: scannerApi.ScannerResponse = {
    success: true,
    status: 'completed',
    caption: 'A mysterious artifact found in the desert.',
    objects: [
      {
        label: 'Artifact',
        box_2d: { ymin: 100, xmin: 100, ymax: 200, xmax: 200 },
        confidence: 0.9,
      },
    ],
    item_candidates: [
      {
        id: 'item-1',
        label: 'Glowing Stone',
        description: 'A stone that glows in the dark',
        item_type: 'artifact',
      },
      {
        id: 'item-2',
        label: 'Ancient Script',
        description: 'Unreadable text on a fragment',
        item_type: 'document',
      },
    ],
    analysis_time_ms: 1200,
    language: 'ko-KR',
  };

  beforeEach(() => {
    vi.clearAllMocks();
    useInventoryStore.setState({ items: [] });
    useAgentStore.setState({ isStreaming: false });
  });

  it('renders dropzone in idle state', () => {
    render(<ScannerSlot language={mockLanguage} />);
    expect(screen.getByText('scanner.dropzone_text')).toBeInTheDocument();
    expect(screen.getByText('scanner.dropzone_hint')).toBeInTheDocument();
  });

  it('handles file drop and triggers scanImage', async () => {
    const scanImageSpy = vi.spyOn(scannerApi, 'scanImage').mockResolvedValue({
      success: true,
      data: mockScanResponse,
    });

    render(<ScannerSlot language={mockLanguage} />);

    const dropzone = screen.getByRole('button', { name: /scanner.dropzone_label/i });
    const file = new File(['mock content'], 'test.png', { type: 'image/png' });

    // ë“œë¡­ ì´ë²¤íŠ¸ ì‹œë®¬ë ˆì´ì…˜
    fireEvent.drop(dropzone, {
      dataTransfer: {
        files: [file],
      },
    });

    // ì—…ë¡œë“œ/ë¶„ì„ ìƒíƒœ í™•ì¸
    expect(screen.getByText(/scanner.(uploading|analyzing)/i)).toBeInTheDocument();

    // ê²°ê³¼ ë Œë”ë§ ëŒ€ê¸°
    await waitFor(() => {
      expect(screen.getByText('A mysterious artifact found in the desert.')).toBeInTheDocument();
    });

    expect(scanImageSpy).toHaveBeenCalledWith(file, mockLanguage);
    expect(screen.getByText('Glowing Stone')).toBeInTheDocument();
    expect(screen.getByText('Ancient Script')).toBeInTheDocument();
  });

  it('allows toggling candidate selection', async () => {
    vi.spyOn(scannerApi, 'scanImage').mockResolvedValue({
      success: true,
      data: mockScanResponse,
    });

    render(<ScannerSlot language={mockLanguage} />);

    const dropzone = screen.getByRole('button', { name: /scanner.dropzone_label/i });
    const file = new File(['mock content'], 'test.png', { type: 'image/png' });
    fireEvent.drop(dropzone, { dataTransfer: { files: [file] } });

    await waitFor(() => {
      expect(screen.getByText('Glowing Stone')).toBeInTheDocument();
    });

    // ê¸°ë³¸ì ìœ¼ë¡œ ëª¨ë‘ ì„ íƒë¨ (Option B: UXëŠ” 1ë‹¨ê³„ ì¶”ê°€ë¥¼ ìœ„í•´ ê¸°ë³¸ ì„ íƒ)
    const addButton = screen.getByText('Add 2 items to inventory');
    expect(addButton).not.toBeDisabled();

    // í•˜ë‚˜ í•´ì œ
    fireEvent.click(screen.getByText('Glowing Stone'));
    expect(screen.getByText('Add 1 items to inventory')).toBeInTheDocument();

    // ëª¨ë‘ í•´ì œ
    fireEvent.click(screen.getByText('Ancient Script'));
    expect(screen.getByText('Add 0 items to inventory')).toBeInTheDocument();
    expect(screen.getByText('Add 0 items to inventory')).toBeDisabled();
  });

  it('adds selected items to inventoryStore and resets state', async () => {
    vi.spyOn(scannerApi, 'scanImage').mockResolvedValue({
      success: true,
      data: mockScanResponse,
    });
    const addItemsSpy = vi.spyOn(useInventoryStore.getState(), 'addItems');

    render(<ScannerSlot language={mockLanguage} />);

    const dropzone = screen.getByRole('button', { name: /scanner.dropzone_label/i });
    const file = new File(['mock content'], 'test.png', { type: 'image/png' });
    fireEvent.drop(dropzone, { dataTransfer: { files: [file] } });

    await waitFor(() => {
      expect(screen.getByText('Add 2 items to inventory')).toBeInTheDocument();
    });

    fireEvent.click(screen.getByText('Add 2 items to inventory'));

    expect(addItemsSpy).toHaveBeenCalledWith([
      expect.objectContaining({ id: 'item-1', name: 'Glowing Stone' }),
      expect.objectContaining({ id: 'item-2', name: 'Ancient Script' }),
    ]);

    // ìƒíƒœ ë¦¬ì…‹ í™•ì¸ (idle ìƒíƒœë¡œ ë³µê·€)
    expect(screen.getByText('scanner.dropzone_text')).toBeInTheDocument();
  });

  it('displays error message on scan failure', async () => {
    vi.spyOn(scannerApi, 'scanImage').mockResolvedValue({
      success: false,
      error: 'Analysis failed due to noise',
      status: 'failed',
    });

    render(<ScannerSlot language={mockLanguage} />);

    const dropzone = screen.getByRole('button', { name: /scanner.dropzone_label/i });
    const file = new File(['mock content'], 'test.png', { type: 'image/png' });
    fireEvent.drop(dropzone, { dataTransfer: { files: [file] } });

    await waitFor(() => {
      expect(screen.getByText('Analysis failed due to noise')).toBeInTheDocument();
    });

    expect(screen.getByText('scanner.retry')).toBeInTheDocument();
  });

  it('resets state when cancel is clicked', async () => {
    vi.spyOn(scannerApi, 'scanImage').mockResolvedValue({
      success: true,
      data: mockScanResponse,
    });

    render(<ScannerSlot language={mockLanguage} />);

    const dropzone = screen.getByRole('button', { name: /scanner.dropzone_label/i });
    const file = new File(['mock content'], 'test.png', { type: 'image/png' });
    fireEvent.drop(dropzone, { dataTransfer: { files: [file] } });

    await waitFor(() => {
      expect(screen.getByText('scanner.cancel')).toBeInTheDocument();
    });

    fireEvent.click(screen.getByText('scanner.cancel'));

    // ìƒíƒœ ë¦¬ì…‹ í™•ì¸
    expect(screen.getByText('scanner.dropzone_text')).toBeInTheDocument();
  });

  it('displays correct discovery message based on item count (U-095)', async () => {
    localStorage.setItem('uw_scanner_onboarding_done', 'true'); // ì˜¨ë³´ë”© ë¹„í™œì„±í™”
    render(<ScannerSlot language={mockLanguage} />);

    // 1ê°œ ë°œê²¬
    const singleResponse = {
      ...mockScanResponse,
      item_candidates: [mockScanResponse.item_candidates[0]],
    };
    vi.spyOn(scannerApi, 'scanImage').mockResolvedValueOnce({
      success: true,
      data: singleResponse,
    });

    let dropzone = screen.getByRole('button', { name: /scanner.dropzone_label/i });
    fireEvent.drop(dropzone, {
      dataTransfer: { files: [new File(['content'], 'test.png', { type: 'image/png' })] },
    });
    await waitFor(() =>
      expect(screen.getByText('scanner.discovery_message.one')).toBeInTheDocument(),
    );

    // 2ê°œ ë°œê²¬
    fireEvent.click(screen.getByText('scanner.cancel'));
    vi.spyOn(scannerApi, 'scanImage').mockResolvedValueOnce({
      success: true,
      data: mockScanResponse,
    });
    dropzone = screen.getByRole('button', { name: /scanner.dropzone_label/i });
    fireEvent.drop(dropzone, {
      dataTransfer: { files: [new File(['content'], 'test.png', { type: 'image/png' })] },
    });
    await waitFor(() =>
      expect(screen.getByText('scanner.discovery_message.two')).toBeInTheDocument(),
    );

    // 3ê°œ ë°œê²¬
    fireEvent.click(screen.getByText('scanner.cancel'));
    const tripleResponse = {
      ...mockScanResponse,
      item_candidates: [
        ...mockScanResponse.item_candidates,
        { id: 'item-3', label: 'Extra Item', description: 'Desc', item_type: 'tool' },
      ],
    };
    vi.spyOn(scannerApi, 'scanImage').mockResolvedValueOnce({
      success: true,
      data: tripleResponse,
    });
    dropzone = screen.getByRole('button', { name: /scanner.dropzone_label/i });
    fireEvent.drop(dropzone, {
      dataTransfer: { files: [new File(['content'], 'test.png', { type: 'image/png' })] },
    });
    await waitFor(() =>
      expect(screen.getByText('scanner.discovery_message.three')).toBeInTheDocument(),
    );
  });

  it('is disabled when isStreaming is true', () => {
    useAgentStore.setState({ isStreaming: true });
    render(<ScannerSlot language={mockLanguage} />);

    const dropzone = screen.getByRole('button', { name: /scanner.dropzone_label/i });
    expect(dropzone).toHaveClass('disabled');
  });

  describe('U-072 Scanner Semantic Guidance UX', () => {
    beforeEach(() => {
      localStorage.clear();
      vi.clearAllMocks();
    });

    it('shows onboarding guide when first used', () => {
      render(<ScannerSlot language={mockLanguage} />);
      expect(screen.getByText('scanner.onboarding.message')).toBeInTheDocument();
      expect(screen.getByText('scanner.onboarding.detail')).toBeInTheDocument();
    });

    it('dismisses onboarding and saves to localStorage', () => {
      const setItemSpy = vi.spyOn(Storage.prototype, 'setItem');
      render(<ScannerSlot language={mockLanguage} />);

      const dismissButton = screen.getByText('scanner.onboarding.dismiss');
      fireEvent.click(dismissButton);

      expect(screen.queryByText('scanner.onboarding.message')).not.toBeInTheDocument();
      expect(setItemSpy).toHaveBeenCalledWith('uw_scanner_onboarding_done', 'true');
    });

    it('shows tooltip on mouse enter in idle state', () => {
      // ì˜¨ë³´ë”©ì´ ìˆìœ¼ë©´ íˆ´íŒì´ ê°€ë ¤ì§€ë¯€ë¡œ ë¨¼ì € ì˜¨ë³´ë”© ì™„ë£Œ ì²˜ë¦¬
      localStorage.setItem('uw_scanner_onboarding_done', 'true');
      render(<ScannerSlot language={mockLanguage} />);

      const container = screen.getByRole('button', {
        name: /scanner.dropzone_label/i,
      }).parentElement!;

      fireEvent.mouseEnter(container);
      expect(screen.getByText('scanner.tooltip.title')).toBeInTheDocument();
      expect(screen.getByText('scanner.tooltip.description')).toBeInTheDocument();

      fireEvent.mouseLeave(container);
      expect(screen.queryByText('scanner.tooltip.title')).not.toBeInTheDocument();
    });

    it('displays drag active affordance when dragging over', () => {
      render(<ScannerSlot language={mockLanguage} />);
      const dropzone = screen.getByRole('button', { name: /scanner.dropzone_label/i });

      fireEvent.dragOver(dropzone);
      expect(dropzone).toHaveClass('drag-over');
      expect(screen.getByText('scanner.affordance.drag_active')).toBeInTheDocument();
    });

    it('displays idle affordance hint in idle state', () => {
      render(<ScannerSlot language={mockLanguage} />);
      expect(screen.getByText('scanner.affordance.idle_hint')).toBeInTheDocument();
    });
  });
});
</file>

<file path="frontend/src/components/ScannerSlot.tsx">
/**
 * Unknown World - Scanner ìŠ¬ë¡¯ ì»´í¬ë„ŒíŠ¸ (U-022[Mvp], U-072[Mvp]).
 *
 * ì´ë¯¸ì§€ ë“œë/ì—…ë¡œë“œ â†’ ë°±ì—”ë“œ ë¶„ì„ â†’ ì•„ì´í…œ í›„ë³´ í‘œì‹œ â†’ ì¸ë²¤í† ë¦¬ ì¶”ê°€.
 *
 * ì„¤ê³„ ì›ì¹™:
 *   - RULE-002: ì±„íŒ… UI ê¸ˆì§€, ê²Œì„ UIë¡œ í‘œì‹œ
 *   - RULE-004: ì‹¤íŒ¨ ì‹œ ì•ˆì „í•œ í´ë°± (ì—ëŸ¬ í‘œì‹œ)
 *   - PRD 6.7: Scanner ìŠ¬ë¡¯ ë©€í‹°ëª¨ë‹¬ ë°ëª¨ í•µì‹¬
 *
 * í˜ì–´ë§ ì§ˆë¬¸ ê²°ì • (U-022):
 *   - Q1: Option B - ì‚¬ìš©ì í™•ì¸ í›„ ì¸ë²¤í† ë¦¬ ì¶”ê°€ (ì˜ë„ í†µì œ)
 *
 * í˜ì–´ë§ ì§ˆë¬¸ ê²°ì • (U-072):
 *   - Q1: Option A - ë°±ì—”ë“œ(LLM)ì—ì„œ scanner_hint í”Œë˜ê·¸ ìƒì„±
 *   - Q2: Option C - í™”ì‚´í‘œ+ë§í’ì„  í˜•íƒœì˜ ì‹œê° ê°€ì´ë“œ (ì˜¨ë³´ë”©)
 *
 * @module components/ScannerSlot
 */

import { useState, useCallback, useRef, type DragEvent, type ChangeEvent } from 'react';
import { useTranslation } from 'react-i18next';
import {
  scanImage,
  isSupportedImageFile,
  candidateToInventoryItem,
  type ScannerResponse,
  type ItemCandidate,
  ALLOWED_MIME_TYPES,
  MAX_FILE_SIZE_BYTES,
} from '../api/scanner';
import { useInventoryStore } from '../stores/inventoryStore';
import { useAgentStore } from '../stores/agentStore';
import type { Language } from '../schemas/turn';

// =============================================================================
// ìƒìˆ˜
// =============================================================================

/** localStorage í‚¤: Scanner ì˜¨ë³´ë”© ì™„ë£Œ ì—¬ë¶€ */
const SCANNER_ONBOARDING_KEY = 'uw_scanner_onboarding_done';

// =============================================================================
// íƒ€ì… ì •ì˜
// =============================================================================

/** Scanner ìŠ¬ë¡¯ ìƒíƒœ */
type ScannerState = 'idle' | 'uploading' | 'analyzing' | 'result' | 'error';

/** ì»´í¬ë„ŒíŠ¸ Props */
interface ScannerSlotProps {
  /** ì„¸ì…˜ ì–¸ì–´ (SSOT) */
  language: Language;
  /** ë¹„í™œì„±í™” ì—¬ë¶€ (ìŠ¤íŠ¸ë¦¬ë° ì¤‘ ë“±) */
  disabled?: boolean;
}

// =============================================================================
// ì»´í¬ë„ŒíŠ¸
// =============================================================================

/**
 * Scanner ìŠ¬ë¡¯ ì»´í¬ë„ŒíŠ¸.
 *
 * ì´ë¯¸ì§€ë¥¼ ë“œë˜ê·¸/ì—…ë¡œë“œí•˜ë©´ ë°±ì—”ë“œ Scanner APIë¥¼ í˜¸ì¶œí•˜ì—¬
 * ì•„ì´í…œ í›„ë³´ë¥¼ ì¶”ì¶œí•˜ê³ , ì‚¬ìš©ìê°€ ì„ íƒí•˜ì—¬ ì¸ë²¤í† ë¦¬ì— ì¶”ê°€í•©ë‹ˆë‹¤.
 */
export function ScannerSlot({ language, disabled = false }: ScannerSlotProps) {
  const { t } = useTranslation();
  const { addItems } = useInventoryStore();
  const { isStreaming } = useAgentStore();

  // ìƒíƒœ
  const [state, setState] = useState<ScannerState>('idle');
  const [isDragOver, setIsDragOver] = useState(false);
  const [errorMessage, setErrorMessage] = useState<string | null>(null);
  const [scanResult, setScanResult] = useState<ScannerResponse | null>(null);
  const [selectedCandidates, setSelectedCandidates] = useState<Set<string>>(new Set());
  const [previewUrl, setPreviewUrl] = useState<string | null>(null);

  // íŒŒì¼ ì…ë ¥ ref
  const fileInputRef = useRef<HTMLInputElement>(null);

  // ì‹¤ì œ ë¹„í™œì„±í™” ìƒíƒœ
  const isDisabled = disabled || isStreaming;

  // ì˜¨ë³´ë”© ìƒíƒœ (U-072)
  const [showOnboarding, setShowOnboarding] = useState(() => {
    try {
      const onboardingDone = localStorage.getItem(SCANNER_ONBOARDING_KEY);
      return !onboardingDone;
    } catch {
      // localStorage ì ‘ê·¼ ì‹¤íŒ¨ ì‹œ ë¬´ì‹œ (SSR ë“±)
      return false;
    }
  });
  const [showTooltip, setShowTooltip] = useState(false);

  /**
   * ì˜¨ë³´ë”© ë‹«ê¸° ë° ì™„ë£Œ ê¸°ë¡.
   */
  const handleDismissOnboarding = useCallback(() => {
    setShowOnboarding(false);
    try {
      localStorage.setItem(SCANNER_ONBOARDING_KEY, 'true');
    } catch {
      // localStorage ì ‘ê·¼ ì‹¤íŒ¨ ì‹œ ë¬´ì‹œ
    }
  }, []);

  // =========================================================================
  // í•¸ë“¤ëŸ¬
  // =========================================================================

  /**
   * íŒŒì¼ ì²˜ë¦¬ (ì—…ë¡œë“œ ë° ë¶„ì„).
   */
  const handleFile = useCallback(
    async (file: File) => {
      if (isDisabled) return;

      // íŒŒì¼ í˜•ì‹ ê²€ì¦
      if (!isSupportedImageFile(file)) {
        setErrorMessage(t('scanner.error.unsupported_format'));
        setState('error');
        return;
      }

      // íŒŒì¼ í¬ê¸° ê²€ì¦
      if (file.size > MAX_FILE_SIZE_BYTES) {
        setErrorMessage(t('scanner.error.file_too_large'));
        setState('error');
        return;
      }

      // í”„ë¦¬ë·° ìƒì„±
      const preview = URL.createObjectURL(file);
      setPreviewUrl(preview);

      // ìƒíƒœ ì´ˆê¸°í™”
      setErrorMessage(null);
      setScanResult(null);
      setSelectedCandidates(new Set());
      setState('uploading');

      try {
        setState('analyzing');
        const result = await scanImage(file, language);

        if (result.success) {
          setScanResult(result.data);
          // ê¸°ë³¸ì ìœ¼ë¡œ ëª¨ë“  í›„ë³´ë¥¼ ì„ íƒ
          const allIds = new Set(result.data.item_candidates.map((c) => c.id));
          setSelectedCandidates(allIds);
          setState('result');
        } else {
          setErrorMessage(result.error);
          setState('error');
        }
      } catch {
        setErrorMessage(t('scanner.error.unknown'));
        setState('error');
      }
    },
    [isDisabled, language, t],
  );

  /**
   * ë“œë˜ê·¸ ì˜¤ë²„ í•¸ë“¤ëŸ¬.
   */
  const handleDragOver = useCallback(
    (e: DragEvent<HTMLDivElement>) => {
      e.preventDefault();
      e.stopPropagation();
      if (!isDisabled) {
        setIsDragOver(true);
      }
    },
    [isDisabled],
  );

  /**
   * ë“œë˜ê·¸ ì¢…ë£Œ í•¸ë“¤ëŸ¬.
   */
  const handleDragLeave = useCallback((e: DragEvent<HTMLDivElement>) => {
    e.preventDefault();
    e.stopPropagation();
    setIsDragOver(false);
  }, []);

  /**
   * ë“œë¡­ í•¸ë“¤ëŸ¬.
   */
  const handleDrop = useCallback(
    (e: DragEvent<HTMLDivElement>) => {
      e.preventDefault();
      e.stopPropagation();
      setIsDragOver(false);

      if (isDisabled) return;

      const files = e.dataTransfer.files;
      if (files.length > 0) {
        void handleFile(files[0]);
      }
    },
    [isDisabled, handleFile],
  );

  /**
   * íŒŒì¼ ì„ íƒ í•¸ë“¤ëŸ¬.
   */
  const handleFileChange = useCallback(
    (e: ChangeEvent<HTMLInputElement>) => {
      const files = e.target.files;
      if (files && files.length > 0) {
        void handleFile(files[0]);
      }
      // ì…ë ¥ ì´ˆê¸°í™” (ê°™ì€ íŒŒì¼ ì¬ì„ íƒ í—ˆìš©)
      if (fileInputRef.current) {
        fileInputRef.current.value = '';
      }
    },
    [handleFile],
  );

  /**
   * íŒŒì¼ ì„ íƒ ë²„íŠ¼ í´ë¦­.
   */
  const handleBrowseClick = useCallback(() => {
    if (!isDisabled && fileInputRef.current) {
      fileInputRef.current.click();
    }
  }, [isDisabled]);

  /**
   * í›„ë³´ ì„ íƒ í† ê¸€.
   */
  const handleCandidateToggle = useCallback((candidateId: string) => {
    setSelectedCandidates((prev) => {
      const next = new Set(prev);
      if (next.has(candidateId)) {
        next.delete(candidateId);
      } else {
        next.add(candidateId);
      }
      return next;
    });
  }, []);

  /**
   * ì„ íƒí•œ ì•„ì´í…œì„ ì¸ë²¤í† ë¦¬ì— ì¶”ê°€.
   * Q1 Option B: ì‚¬ìš©ì í™•ì¸ í›„ ì¶”ê°€.
   */
  const handleAddToInventory = useCallback(() => {
    if (!scanResult || selectedCandidates.size === 0) return;

    const selectedItems = scanResult.item_candidates
      .filter((c) => selectedCandidates.has(c.id))
      .map(candidateToInventoryItem);

    addItems(selectedItems);

    // ìƒíƒœ ì´ˆê¸°í™”
    setState('idle');
    setScanResult(null);
    setSelectedCandidates(new Set());
    if (previewUrl) {
      URL.revokeObjectURL(previewUrl);
      setPreviewUrl(null);
    }
  }, [scanResult, selectedCandidates, addItems, previewUrl]);

  /**
   * ì·¨ì†Œ/ë¦¬ì…‹.
   */
  const handleReset = useCallback(() => {
    setState('idle');
    setScanResult(null);
    setSelectedCandidates(new Set());
    setErrorMessage(null);
    if (previewUrl) {
      URL.revokeObjectURL(previewUrl);
      setPreviewUrl(null);
    }
  }, [previewUrl]);

  // =========================================================================
  // ë Œë”ë§
  // =========================================================================

  return (
    <div
      className="scanner-slot-container"
      onMouseEnter={() => setShowTooltip(true)}
      onMouseLeave={() => setShowTooltip(false)}
    >
      {/* íˆ´íŒ (U-072) */}
      {showTooltip && state === 'idle' && !showOnboarding && (
        <div className="scanner-tooltip" role="tooltip">
          <div className="scanner-tooltip-title">{t('scanner.tooltip.title')}</div>
          <div className="scanner-tooltip-desc">{t('scanner.tooltip.description')}</div>
        </div>
      )}

      {/* ì˜¨ë³´ë”© ê°€ì´ë“œ - í™”ì‚´í‘œ+ë§í’ì„  (U-072 Q2 Option C) */}
      {showOnboarding && state === 'idle' && (
        <div className="scanner-onboarding" role="dialog" aria-labelledby="scanner-onboarding-msg">
          <div className="scanner-onboarding-arrow">â–¼</div>
          <div className="scanner-onboarding-bubble">
            <div className="scanner-onboarding-message" id="scanner-onboarding-msg">
              {t('scanner.onboarding.message')}
            </div>
            <div className="scanner-onboarding-detail">{t('scanner.onboarding.detail')}</div>
            <button
              type="button"
              className="scanner-onboarding-dismiss"
              onClick={handleDismissOnboarding}
            >
              {t('scanner.onboarding.dismiss')}
            </button>
          </div>
        </div>
      )}

      {/* ìˆ¨ê²¨ì§„ íŒŒì¼ ì…ë ¥ */}
      <input
        ref={fileInputRef}
        type="file"
        accept={ALLOWED_MIME_TYPES.join(',')}
        onChange={handleFileChange}
        className="visually-hidden"
        aria-label={t('scanner.upload_label')}
      />

      {/* ìƒíƒœë³„ ë Œë”ë§ */}
      {state === 'idle' && (
        <div
          className={`scanner-dropzone ${isDragOver ? 'drag-over' : ''} ${isDisabled ? 'disabled' : ''}`}
          onDragOver={handleDragOver}
          onDragLeave={handleDragLeave}
          onDrop={handleDrop}
          onClick={handleBrowseClick}
          role="button"
          tabIndex={isDisabled ? -1 : 0}
          aria-label={t('scanner.dropzone_label')}
          onKeyDown={(e) => {
            if (e.key === 'Enter' || e.key === ' ') {
              e.preventDefault();
              handleBrowseClick();
            }
          }}
        >
          <div className="scanner-dropzone-icon">ğŸ“·</div>
          <div className="scanner-dropzone-text">
            {isDragOver ? t('scanner.affordance.drag_active') : t('scanner.dropzone_text')}
          </div>
          <div className={`scanner-dropzone-hint ${isDragOver ? 'hidden' : ''}`}>
            {t('scanner.dropzone_hint')}
          </div>
          {/* ì‹œê°ì  ì–´í¬ë˜ìŠ¤: idle íŒíŠ¸ (U-072) - í•­ìƒ ë Œë”ë§í•˜ì—¬ ë ˆì´ì•„ì›ƒ ì‹œí”„íŠ¸ ë°©ì§€ */}
          <div
            className={`scanner-affordance-hint ${isDragOver || isDisabled ? 'hidden' : ''}`}
            aria-hidden={isDragOver || isDisabled}
          >
            {t('scanner.affordance.idle_hint')}
          </div>
        </div>
      )}

      {(state === 'uploading' || state === 'analyzing') && (
        <div className="scanner-loading">
          {previewUrl && (
            <div className="scanner-preview">
              <img
                src={previewUrl}
                alt={t('scanner.preview_alt')}
                className="scanner-preview-img"
              />
            </div>
          )}
          <div className="scanner-loading-content">
            <div className="scanner-loading-spinner" />
            <div className="scanner-loading-text">
              {state === 'uploading' ? t('scanner.uploading') : t('scanner.analyzing')}
            </div>
          </div>
        </div>
      )}

      {state === 'error' && (
        <div className="scanner-error">
          {previewUrl && (
            <div className="scanner-preview">
              <img
                src={previewUrl}
                alt={t('scanner.preview_alt')}
                className="scanner-preview-img"
              />
            </div>
          )}
          <div className="scanner-error-content">
            <div className="scanner-error-icon">âš ï¸</div>
            <div className="scanner-error-message">{errorMessage}</div>
            <button type="button" className="scanner-btn scanner-btn-retry" onClick={handleReset}>
              {t('scanner.retry')}
            </button>
          </div>
        </div>
      )}

      {state === 'result' && scanResult && (
        <div className="scanner-result">
          {/* U-095: ë‹¤ìˆ˜ ì•„ì´í…œ ë°œê²¬ í”¼ë“œë°± ë©”ì‹œì§€ */}
          <div className="scanner-discovery-message" role="status">
            {getDiscoveryMessage(scanResult.item_candidates.length, t)}
          </div>

          {/* í”„ë¦¬ë·° + ìº¡ì…˜ */}
          <div className="scanner-result-header">
            {previewUrl && (
              <div className="scanner-preview-small">
                <img
                  src={previewUrl}
                  alt={t('scanner.preview_alt')}
                  className="scanner-preview-img-small"
                />
              </div>
            )}
            <div className="scanner-result-info">
              <div className="scanner-caption">{scanResult.caption}</div>
              <div className="scanner-stats">
                {t('scanner.detected_objects', { count: scanResult.objects.length })} â€¢{' '}
                {t('scanner.item_candidates', { count: scanResult.item_candidates.length })}
              </div>
            </div>
          </div>

          {/* ì•„ì´í…œ í›„ë³´ ëª©ë¡ */}
          {scanResult.item_candidates.length > 0 ? (
            <div className="scanner-candidates">
              <div className="scanner-candidates-title">{t('scanner.select_items')}</div>
              <div className="scanner-candidates-list">
                {scanResult.item_candidates.map((candidate) => (
                  <CandidateItem
                    key={candidate.id}
                    candidate={candidate}
                    selected={selectedCandidates.has(candidate.id)}
                    onToggle={() => handleCandidateToggle(candidate.id)}
                  />
                ))}
              </div>
            </div>
          ) : (
            <div className="scanner-no-candidates">{t('scanner.no_candidates')}</div>
          )}

          {/* ì•¡ì…˜ ë²„íŠ¼ */}
          <div className="scanner-actions">
            <button type="button" className="scanner-btn scanner-btn-cancel" onClick={handleReset}>
              {t('scanner.cancel')}
            </button>
            <button
              type="button"
              className="scanner-btn scanner-btn-add"
              onClick={handleAddToInventory}
              disabled={selectedCandidates.size === 0}
            >
              {t('scanner.add_to_inventory', { count: selectedCandidates.size })}
            </button>
          </div>
        </div>
      )}
    </div>
  );
}

// =============================================================================
// ì„œë¸Œ ì»´í¬ë„ŒíŠ¸
// =============================================================================

interface CandidateItemProps {
  candidate: ItemCandidate;
  selected: boolean;
  onToggle: () => void;
}

/**
 * ì•„ì´í…œ í›„ë³´ ì»´í¬ë„ŒíŠ¸.
 */
function CandidateItem({ candidate, selected, onToggle }: CandidateItemProps) {
  const { t } = useTranslation();

  // ì•„ì´í…œ íƒ€ì…ì— ë”°ë¥¸ ì´ëª¨ì§€
  const emoji = getItemTypeEmoji(candidate.item_type);

  return (
    <button
      type="button"
      className={`scanner-candidate ${selected ? 'selected' : ''}`}
      onClick={onToggle}
      aria-pressed={selected}
    >
      <span className="scanner-candidate-checkbox">{selected ? 'â˜‘' : 'â˜'}</span>
      <span className="scanner-candidate-icon">{emoji}</span>
      <span className="scanner-candidate-info">
        <span className="scanner-candidate-name">{candidate.label}</span>
        {candidate.description && (
          <span className="scanner-candidate-desc">{candidate.description}</span>
        )}
        <span className="scanner-candidate-type">
          {t(`scanner.item_type.${candidate.item_type}`, { defaultValue: candidate.item_type })}
        </span>
      </span>
    </button>
  );
}

// =============================================================================
// ìœ í‹¸ë¦¬í‹°
// =============================================================================

function getItemTypeEmoji(itemType: string): string {
  const emojiMap: Record<string, string> = {
    key: 'ğŸ”‘',
    weapon: 'âš”ï¸',
    tool: 'ğŸ”§',
    clue: 'ğŸ”',
    material: 'ğŸ“¦',
    consumable: 'ğŸ’Š',
    document: 'ğŸ“„',
    artifact: 'ğŸ’',
  };
  return emojiMap[itemType] ?? 'ğŸ“¦';
}

/**
 * ì•„ì´í…œ ë°œê²¬ ê°œìˆ˜ì— ë”°ë¥¸ í”¼ë“œë°± ë©”ì‹œì§€ (U-095).
 *
 * @param count - ë°œê²¬ëœ ì•„ì´í…œ ìˆ˜
 * @param t - i18n ë²ˆì—­ í•¨ìˆ˜
 * @returns í”¼ë“œë°± ë©”ì‹œì§€
 */
function getDiscoveryMessage(count: number, t: (key: string) => string): string {
  if (count >= 3) return t('scanner.discovery_message.three');
  if (count === 2) return t('scanner.discovery_message.two');
  return t('scanner.discovery_message.one');
}
</file>

<file path="frontend/src/components/SceneImage.test.tsx">
import { describe, it, expect, vi, beforeEach, afterEach } from 'vitest';
import { render, screen, act } from '@testing-library/react';
import { SceneImage } from './SceneImage';

// react-i18next ëª¨í‚¹
vi.mock('react-i18next', () => ({
  useTranslation: () => ({
    t: (key: string) => key,
  }),
}));

// ì „ì—­ì ìœ¼ë¡œ ì¸ìŠ¤í„´ìŠ¤ë¥¼ ì¶”ì í•˜ê¸° ìœ„í•œ ë°°ì—´
let imageInstances: Array<MockImage> = [];

// Image ê°ì²´ ëª¨í‚¹
class MockImage {
  onload: (() => void) | null = null;
  onerror: (() => void) | null = null;
  _src: string = '';

  constructor() {
    imageInstances.push(this);
  }

  addEventListener(event: string, cb: () => void) {
    if (event === 'load') this.onload = cb;
    if (event === 'error') this.onerror = cb;
  }

  removeEventListener() {}

  set src(val: string) {
    this._src = val;
  }

  get src() {
    return this._src;
  }
}

describe('SceneImage Component (U-020)', () => {
  const originalImage = global.Image;

  beforeEach(() => {
    imageInstances = [];
    global.Image = MockImage as unknown as typeof Image;
  });

  afterEach(() => {
    global.Image = originalImage;
  });

  it('ì´ë¯¸ì§€ URLì´ ì—†ì„ ë•Œ placeholderë¥¼ í‘œì‹œí•´ì•¼ í•¨', () => {
    render(<SceneImage status="default" />);
    expect(screen.getByText('scene.status.default')).toBeInTheDocument();
  });

  it('ìƒˆë¡œìš´ ì´ë¯¸ì§€ URLì´ ì˜¤ë©´ ë¡œë”© ì¸ë””ì¼€ì´í„°ë¥¼ í‘œì‹œí•˜ê³  ì´ì „ ì´ë¯¸ì§€ë¥¼ ìœ ì§€í•´ì•¼ í•¨ (Option A)', async () => {
    const { rerender } = render(<SceneImage status="scene" imageUrl="url-1.png" />);

    // ë¡œë”© ì¤‘ í™•ì¸
    expect(screen.getByText('scene.status.image_loading')).toBeInTheDocument();

    // ì²« ë²ˆì§¸ ì´ë¯¸ì§€ ë¡œë“œ ì™„ë£Œ ì‹œë®¬ë ˆì´ì…˜
    await act(async () => {
      if (imageInstances[0]?.onload) imageInstances[0].onload();
    });

    const img = screen.getByAltText('scene.status.alt');
    expect(img).toHaveAttribute('src', 'url-1.png');

    // ë‘ ë²ˆì§¸ ì´ë¯¸ì§€ ìš”ì²­
    await act(async () => {
      rerender(<SceneImage status="scene" imageUrl="url-2.png" />);
    });

    // ë¡œë”© ì¤‘ í‘œì‹œ í™•ì¸
    expect(screen.getByText('scene.status.image_loading')).toBeInTheDocument();
    // ì´ì „ ì´ë¯¸ì§€(url-1)ê°€ ì—¬ì „íˆ ë³´ì—¬ì•¼ í•¨
    expect(screen.getByAltText('scene.status.alt')).toHaveAttribute('src', 'url-1.png');
  });

  it('ì´ë¯¸ì§€ ë¡œë”©ì´ ì™„ë£Œë˜ë©´ ìƒˆë¡œìš´ ì´ë¯¸ì§€ë¡œ êµì²´ë˜ì–´ì•¼ í•¨', async () => {
    const { rerender } = render(<SceneImage status="scene" imageUrl="url-1.png" />);

    await act(async () => {
      if (imageInstances[0]?.onload) imageInstances[0].onload();
    });

    await act(async () => {
      rerender(<SceneImage status="scene" imageUrl="url-2.png" />);
    });

    // ë‘ ë²ˆì§¸ ì´ë¯¸ì§€ ë¡œë“œ ì™„ë£Œ ì‹œë®¬ë ˆì´ì…˜
    await act(async () => {
      // ìƒˆë¡œìš´ Image ì¸ìŠ¤í„´ìŠ¤ê°€ ìƒì„±ë˜ì—ˆì„ ê²ƒì„
      const secondInstance = imageInstances.find((inst) => inst.src === 'url-2.png');
      if (secondInstance?.onload) secondInstance.onload();
    });

    const img = screen.getByAltText('scene.status.alt');
    expect(img).toHaveAttribute('src', 'url-2.png');
    expect(screen.queryByText('scene.status.image_loading')).not.toBeInTheDocument();
  });

  it('ì´ë¯¸ì§€ ë¡œë”© ì‹¤íŒ¨ ì‹œ ì—ëŸ¬ ë°°ì§€ë¥¼ í‘œì‹œí•˜ê³  ì´ì „ ì´ë¯¸ì§€ë¥¼ ìœ ì§€í•´ì•¼ í•¨ (RULE-004)', async () => {
    const { rerender } = render(<SceneImage status="scene" imageUrl="url-1.png" />);

    await act(async () => {
      if (imageInstances[0]?.onload) imageInstances[0].onload();
    });

    await act(async () => {
      rerender(<SceneImage status="scene" imageUrl="url-2.png" />);
    });

    // ë‘ ë²ˆì§¸ ì´ë¯¸ì§€ ë¡œë“œ ì‹¤íŒ¨ ì‹œë®¬ë ˆì´ì…˜
    await act(async () => {
      const secondInstance = imageInstances.find((inst) => inst.src === 'url-2.png');
      if (secondInstance?.onerror) secondInstance.onerror();
    });

    expect(screen.getByText('scene.status.image_error')).toBeInTheDocument();
    expect(screen.getByAltText('scene.status.alt')).toHaveAttribute('src', 'url-1.png');
  });

  it('ì´ë¯¸ì§€ê°€ ì „í˜€ ì—†ëŠ” ìƒíƒœì—ì„œ ì—ëŸ¬ ë°œìƒ ì‹œ placeholderë¥¼ í‘œì‹œí•´ì•¼ í•¨', async () => {
    render(<SceneImage status="scene" imageUrl="invalid.png" />);

    await act(async () => {
      if (imageInstances[0]?.onerror) imageInstances[0].onerror();
    });

    expect(screen.getByText('scene.status.default')).toBeInTheDocument();
    expect(screen.getByText('âš ï¸')).toBeInTheDocument();
  });

  describe('Processing Overlay (U-071[Mvp])', () => {
    it('processingPhaseê°€ processingì¼ ë•Œ ì²˜ë¦¬ ì¤‘ ì˜¤ë²„ë ˆì´ì™€ ì˜¬ë°”ë¥¸ ë©”ì‹œì§€ë¥¼ í‘œì‹œí•´ì•¼ í•¨', () => {
      render(<SceneImage status="scene" processingPhase="processing" />);

      expect(screen.getByText('scene.processing.processing')).toBeInTheDocument();
      // CRT ìŠ¤í”¼ë„ˆ ìš”ì†Œ ì¡´ì¬ í™•ì¸
      expect(document.querySelector('.scene-processing-spinner')).toBeInTheDocument();
    });

    it('processingPhaseê°€ image_pendingì¼ ë•Œ ì´ë¯¸ì§€ í˜•ì„± ì¤‘ ë©”ì‹œì§€ë¥¼ í‘œì‹œí•´ì•¼ í•¨', () => {
      render(<SceneImage status="scene" processingPhase="image_pending" />);

      expect(screen.getByText('scene.processing.image_pending')).toBeInTheDocument();
    });

    it('ì²˜ë¦¬ ì¤‘ì¼ ë•ŒëŠ” ì´ì „ ì´ë¯¸ì§€ê°€ ìˆë”ë¼ë„ ìˆ¨ê²¨ì•¼ í•¨ (Option C)', async () => {
      const { rerender } = render(<SceneImage status="scene" imageUrl="old-url.png" />);

      // 1. ì²« ë²ˆì§¸ ì´ë¯¸ì§€ ë¡œë“œ ì™„ë£Œ
      await act(async () => {
        if (imageInstances[0]?.onload) imageInstances[0].onload();
      });

      expect(screen.getByAltText('scene.status.alt')).toHaveAttribute('src', 'old-url.png');

      // 2. ì²˜ë¦¬ ì¤‘ìœ¼ë¡œ ì „í™˜
      rerender(<SceneImage status="scene" imageUrl="old-url.png" processingPhase="processing" />);

      // ì´ë¯¸ì§€ ìš”ì†Œê°€ ë Œë”ë§ë˜ì§€ ì•Šì•„ì•¼ í•¨ (Option C: ì²˜ë¦¬ ì¤‘ ìˆ¨ê¹€)
      expect(screen.queryByAltText('scene.status.alt')).not.toBeInTheDocument();
      // ì˜¤ë²„ë ˆì´ëŠ” í‘œì‹œë˜ì–´ì•¼ í•¨
      expect(screen.getByText('scene.processing.processing')).toBeInTheDocument();
    });
  });

  describe('Analyzing Overlay (U-089[Mvp])', () => {
    it('isAnalyzingì´ trueì¼ ë•Œ ë¶„ì„ ì „ìš© ì˜¤ë²„ë ˆì´ì™€ ë©”ì‹œì§€ë¥¼ í‘œì‹œí•´ì•¼ í•¨', () => {
      render(<SceneImage status="scene" isAnalyzing={true} />);

      expect(screen.getByText('scene.analyzing.message')).toBeInTheDocument();
      expect(screen.getByText('scene.analyzing.hint')).toBeInTheDocument();
      // ìŠ¤ìº”ë¼ì¸ ìš”ì†Œ ì¡´ì¬ í™•ì¸
      expect(document.querySelector('.scene-analyzing-scanline')).toBeInTheDocument();
    });

    it('ì •ë°€ë¶„ì„ ì¤‘ì—ëŠ” ê¸°ì¡´ ì´ë¯¸ì§€ë¥¼ ìœ ì§€í•´ì•¼ í•¨ (Option B)', async () => {
      const { rerender } = render(<SceneImage status="scene" imageUrl="old-url.png" />);

      // 1. ì²« ë²ˆì§¸ ì´ë¯¸ì§€ ë¡œë“œ ì™„ë£Œ
      await act(async () => {
        if (imageInstances[0]?.onload) imageInstances[0].onload();
      });

      expect(screen.getByAltText('scene.status.alt')).toHaveAttribute('src', 'old-url.png');

      // 2. ì •ë°€ë¶„ì„ ì‹œì‘
      rerender(<SceneImage status="scene" imageUrl="old-url.png" isAnalyzing={true} />);

      // ì´ë¯¸ì§€ ìš”ì†Œê°€ ì—¬ì „íˆ ì¡´ì¬í•´ì•¼ í•¨ (ê¸°ì¡´ ì´ë¯¸ì§€ ìœ ì§€)
      expect(screen.getByAltText('scene.status.alt')).toHaveAttribute('src', 'old-url.png');
      // ë¶„ì„ ì˜¤ë²„ë ˆì´ í‘œì‹œ í™•ì¸
      expect(screen.getByText('scene.analyzing.message')).toBeInTheDocument();
    });

    it('isAnalyzingì´ trueì¼ ë•ŒëŠ” processingPhase ì˜¤ë²„ë ˆì´ë³´ë‹¤ ìš°ì„ í•´ì•¼ í•¨', () => {
      render(<SceneImage status="scene" isAnalyzing={true} processingPhase="processing" />);

      // ë¶„ì„ ì˜¤ë²„ë ˆì´ëŠ” í‘œì‹œë¨
      expect(screen.getByText('scene.analyzing.message')).toBeInTheDocument();
      // ì¼ë°˜ ì²˜ë¦¬ ì˜¤ë²„ë ˆì´ëŠ” ìˆ¨ê²¨ì§
      expect(screen.queryByText('scene.processing.processing')).not.toBeInTheDocument();
    });
  });
});
</file>

<file path="frontend/src/data/demoProfiles.ts">
/**
 * Unknown World - ë°ëª¨ í”„ë¡œí•„ ì •ì˜ (U-015[Mvp]).
 *
 * ë¡œê·¸ì¸ ì—†ì´ ì¦‰ì‹œ ì‹œì‘ ê°€ëŠ¥í•œ ë°ëª¨ í”„ë¡œí•„ 3ì¢…ì„ ì •ì˜í•©ë‹ˆë‹¤.
 * ê° í”„ë¡œí•„ì€ ì„œë¡œ ë‹¤ë¥¸ ì´ˆê¸° ìƒíƒœ(ì¬í™”/ì¸ë²¤í† ë¦¬/í€˜ìŠ¤íŠ¸/ë£°)ë¥¼ ê°€ì§‘ë‹ˆë‹¤.
 *
 * í”„ë¡œí•„:
 *   1. Narrator: ë‚´ëŸ¬í‹°ë¸Œ/ìŠ¤í† ë¦¬ ì¤‘ì‹¬ ì²´í—˜
 *   2. Explorer: íƒìƒ‰/ë°œê²¬ ì¤‘ì‹¬ ì²´í—˜
 *   3. Tech Enthusiast: ì‹œìŠ¤í…œ/ë©”ì»¤ë‹‰ ì¤‘ì‹¬ ì²´í—˜
 *
 * ì„¤ê³„ ì›ì¹™:
 *   - RULE-006: í‘œì‹œ ë¬¸ìì—´ì€ i18n í‚¤ ê¸°ë°˜
 *   - RULE-010: SaveGame JSON ì§ë ¬í™”ë¡œ ì €ì¥
 *   - PRD 6.9: ë°ëª¨ í”„ë¡œí•„ 3ì¢… + ì¦‰ì‹œ ë¦¬ì…‹
 *   - RU-004-Q5: seed ìƒì„±ì€ constants.ts SSOT ì‚¬ìš©
 *
 * @module data/demoProfiles
 */

import type { SupportedLanguage } from '../i18n';
import type { SaveGame, SaveGameInput } from '../save/saveGame';
import { createSaveGame } from '../save/saveGame';
// RU-004-Q5: seed ìƒì„± ì •ì±… SSOT
import { generateDemoSeed } from '../save/constants';
// U-092: í”„ë¦¬ì…‹ ì•„ì´ì½˜ ë ˆì§€ìŠ¤íŠ¸ë¦¬
import { getPresetIconUrl } from './itemIconPresets';

// =============================================================================
// í”„ë¡œí•„ íƒ€ì… ì •ì˜
// =============================================================================

/**
 * ë°ëª¨ í”„ë¡œí•„ ì •ì˜ (ì–¸ì–´ ì¤‘ë¦½).
 * í‘œì‹œìš© ë¬¸ìì—´ì€ i18n í‚¤ë¡œ ì°¸ì¡°í•©ë‹ˆë‹¤.
 */
export interface DemoProfileDef {
  /** í”„ë¡œí•„ ê³ ìœ  ID */
  id: string;
  /** í”„ë¡œí•„ ì´ë¦„ i18n í‚¤ */
  nameKey: string;
  /** í”„ë¡œí•„ ì„¤ëª… i18n í‚¤ */
  descriptionKey: string;
  /** í”„ë¡œí•„ ì•„ì´ì½˜ (ì´ëª¨ì§€) */
  icon: string;
  /** í”„ë¡œí•„ í…Œë§ˆ ìƒ‰ìƒ (CSS ë³€ìˆ˜ëª… ë˜ëŠ” hex) */
  themeColor: string;
}

/**
 * í”„ë¡œí•„ ì´ˆê¸° ìƒíƒœ.
 * SaveGameìœ¼ë¡œ ë³€í™˜ ê°€ëŠ¥í•œ êµ¬ì¡°ì…ë‹ˆë‹¤.
 */
export interface DemoProfileInitialState {
  /** ì´ˆê¸° ì¬í™” */
  economy: {
    signal: number;
    memory_shard: number;
    credit: number;
  };
  /** ì´ˆê¸° ì¸ë²¤í† ë¦¬ ì•„ì´í…œ ì •ì˜ (IDì™€ i18n í‚¤) */
  inventoryDefs: Array<{
    id: string;
    nameKey: string;
    icon: string;
    quantity: number;
  }>;
  /** ì´ˆê¸° í€˜ìŠ¤íŠ¸ ì •ì˜ (U-078: ëª©í‘œ ì‹œìŠ¤í…œ ê°•í™”) */
  questDefs: Array<{
    id: string;
    labelKey: string;
    is_completed: boolean;
    descriptionKey?: string;
    is_main?: boolean;
    progress?: number;
    reward_signal?: number;
  }>;
  /** ì´ˆê¸° ê·œì¹™ ì •ì˜ */
  ruleDefs: Array<{
    id: string;
    labelKey: string;
    descriptionKey?: string;
  }>;
  /** ì´ˆê¸° Scene Objects ì •ì˜ */
  sceneObjectDefs: Array<{
    id: string;
    labelKey: string;
    hintKey: string;
    box_2d: {
      ymin: number;
      xmin: number;
      ymax: number;
      xmax: number;
    };
  }>;
  /** í™˜ì˜ ë©”ì‹œì§€ i18n í‚¤ */
  welcomeMessageKey: string;
}

/**
 * ë°ëª¨ í”„ë¡œí•„ ì „ì²´ ì •ì˜.
 */
export interface DemoProfile extends DemoProfileDef {
  initialState: DemoProfileInitialState;
}

// =============================================================================
// ë°ëª¨ í”„ë¡œí•„ ì •ì˜ (3ì¢…)
// =============================================================================

/**
 * Narrator í”„ë¡œí•„: ë‚´ëŸ¬í‹°ë¸Œ/ìŠ¤í† ë¦¬ ì¤‘ì‹¬ ì²´í—˜.
 * í’ë¶€í•œ ì¬í™”ë¡œ ë‹¤ì–‘í•œ ì„ íƒì§€ë¥¼ íƒìƒ‰í•  ìˆ˜ ìˆìŠµë‹ˆë‹¤.
 */
export const PROFILE_NARRATOR: DemoProfile = {
  id: 'narrator',
  nameKey: 'profile.narrator.name',
  descriptionKey: 'profile.narrator.description',
  icon: 'ğŸ“–',
  themeColor: 'var(--accent-color)',
  initialState: {
    economy: {
      signal: 200,
      memory_shard: 10,
      credit: 0,
    },
    inventoryDefs: [
      {
        id: 'ancient-tome',
        nameKey: 'profile.narrator.items.ancient_tome',
        icon: 'ğŸ“•',
        quantity: 1,
      },
      { id: 'quill-pen', nameKey: 'profile.narrator.items.quill_pen', icon: 'ğŸ–‹ï¸', quantity: 1 },
      {
        id: 'memory-fragment',
        nameKey: 'profile.narrator.items.memory_fragment',
        icon: 'ğŸ’ ',
        quantity: 3,
      },
    ],
    questDefs: [
      {
        id: 'quest-discover-origin',
        labelKey: 'profile.narrator.quest.discover_origin',
        descriptionKey: 'profile.narrator.quest.discover_origin_desc',
        is_completed: false,
        is_main: true,
        progress: 0,
        reward_signal: 50,
      },
      {
        id: 'quest-collect-memories',
        labelKey: 'profile.narrator.quest.collect_memories',
        is_completed: false,
        reward_signal: 15,
      },
      {
        id: 'quest-read-ancient-tome',
        labelKey: 'profile.narrator.quest.read_ancient_tome',
        is_completed: false,
        reward_signal: 10,
      },
    ],
    ruleDefs: [
      {
        id: 'rule-time-flows',
        labelKey: 'profile.narrator.rule.time_flows',
        descriptionKey: 'profile.narrator.rule.time_flows_desc',
      },
      {
        id: 'rule-memories-persist',
        labelKey: 'profile.narrator.rule.memories_persist',
        descriptionKey: 'profile.narrator.rule.memories_persist_desc',
      },
    ],
    sceneObjectDefs: [
      {
        id: 'mysterious-bookshelf',
        labelKey: 'profile.narrator.scene.bookshelf',
        hintKey: 'profile.narrator.scene.bookshelf_hint',
        box_2d: { ymin: 200, xmin: 100, ymax: 700, xmax: 400 },
      },
      {
        id: 'glowing-portal',
        labelKey: 'profile.narrator.scene.portal',
        hintKey: 'profile.narrator.scene.portal_hint',
        box_2d: { ymin: 300, xmin: 600, ymax: 800, xmax: 900 },
      },
    ],
    welcomeMessageKey: 'profile.narrator.welcome',
  },
};

/**
 * Explorer í”„ë¡œí•„: íƒìƒ‰/ë°œê²¬ ì¤‘ì‹¬ ì²´í—˜.
 * ì ë‹¹í•œ ì¬í™”ì™€ íƒìƒ‰ ë„êµ¬ë¡œ ìƒˆë¡œìš´ ì˜ì—­ì„ ë°œê²¬í•©ë‹ˆë‹¤.
 */
export const PROFILE_EXPLORER: DemoProfile = {
  id: 'explorer',
  nameKey: 'profile.explorer.name',
  descriptionKey: 'profile.explorer.description',
  icon: 'ğŸ§­',
  themeColor: 'var(--text-color)',
  initialState: {
    economy: {
      signal: 150,
      memory_shard: 5,
      credit: 0,
    },
    inventoryDefs: [
      { id: 'compass', nameKey: 'profile.explorer.items.compass', icon: 'ğŸ§­', quantity: 1 },
      { id: 'rope', nameKey: 'profile.explorer.items.rope', icon: 'ğŸª¢', quantity: 2 },
      { id: 'lantern', nameKey: 'profile.explorer.items.lantern', icon: 'ğŸ®', quantity: 1 },
      {
        id: 'map-fragment',
        nameKey: 'profile.explorer.items.map_fragment',
        icon: 'ğŸ—ºï¸',
        quantity: 1,
      },
    ],
    questDefs: [
      {
        id: 'quest-find-exit',
        labelKey: 'profile.explorer.quest.find_exit',
        descriptionKey: 'profile.explorer.quest.find_exit_desc',
        is_completed: false,
        is_main: true,
        progress: 15,
        reward_signal: 50,
      },
      {
        id: 'quest-explore-areas',
        labelKey: 'profile.explorer.quest.explore_areas',
        is_completed: false,
        reward_signal: 20,
      },
      {
        id: 'quest-gather-supplies',
        labelKey: 'profile.explorer.quest.gather_supplies',
        is_completed: true,
        reward_signal: 10,
      },
    ],
    ruleDefs: [
      {
        id: 'rule-gravity',
        labelKey: 'profile.explorer.rule.gravity',
        descriptionKey: 'profile.explorer.rule.gravity_desc',
      },
      {
        id: 'rule-darkness',
        labelKey: 'profile.explorer.rule.darkness',
        descriptionKey: 'profile.explorer.rule.darkness_desc',
      },
    ],
    sceneObjectDefs: [
      {
        id: 'ancient-door',
        labelKey: 'profile.explorer.scene.door',
        hintKey: 'profile.explorer.scene.door_hint',
        box_2d: { ymin: 150, xmin: 400, ymax: 850, xmax: 600 },
      },
      {
        id: 'strange-mechanism',
        labelKey: 'profile.explorer.scene.mechanism',
        hintKey: 'profile.explorer.scene.mechanism_hint',
        box_2d: { ymin: 500, xmin: 100, ymax: 700, xmax: 300 },
      },
      {
        id: 'hidden-passage',
        labelKey: 'profile.explorer.scene.passage',
        hintKey: 'profile.explorer.scene.passage_hint',
        box_2d: { ymin: 600, xmin: 700, ymax: 800, xmax: 950 },
      },
    ],
    welcomeMessageKey: 'profile.explorer.welcome',
  },
};

/**
 * Tech Enthusiast í”„ë¡œí•„: ì‹œìŠ¤í…œ/ë©”ì»¤ë‹‰ ì¤‘ì‹¬ ì²´í—˜.
 * ì œí•œëœ ì¬í™”ë¡œ íš¨ìœ¨ì ì¸ ì „ëµì„ ì„¸ì›Œì•¼ í•©ë‹ˆë‹¤.
 */
export const PROFILE_TECH: DemoProfile = {
  id: 'tech',
  nameKey: 'profile.tech.name',
  descriptionKey: 'profile.tech.description',
  icon: 'âš™ï¸',
  themeColor: 'var(--warning-color)',
  initialState: {
    economy: {
      signal: 80,
      memory_shard: 15,
      credit: 0,
    },
    inventoryDefs: [
      { id: 'data-core', nameKey: 'profile.tech.items.data_core', icon: 'ğŸ’¿', quantity: 1 },
      { id: 'circuit-board', nameKey: 'profile.tech.items.circuit_board', icon: 'ğŸ”Œ', quantity: 2 },
      { id: 'energy-cell', nameKey: 'profile.tech.items.energy_cell', icon: 'ğŸ”‹', quantity: 3 },
      { id: 'scanner-device', nameKey: 'profile.tech.items.scanner', icon: 'ğŸ“¡', quantity: 1 },
    ],
    questDefs: [
      {
        id: 'quest-analyze-system',
        labelKey: 'profile.tech.quest.analyze_system',
        descriptionKey: 'profile.tech.quest.analyze_system_desc',
        is_completed: false,
        is_main: true,
        progress: 0,
        reward_signal: 40,
      },
      {
        id: 'quest-optimize-resources',
        labelKey: 'profile.tech.quest.optimize_resources',
        is_completed: false,
        reward_signal: 15,
      },
      {
        id: 'quest-scan-terminal',
        labelKey: 'profile.tech.quest.scan_terminal',
        is_completed: false,
        reward_signal: 10,
      },
    ],
    ruleDefs: [
      {
        id: 'rule-energy-conservation',
        labelKey: 'profile.tech.rule.energy_conservation',
        descriptionKey: 'profile.tech.rule.energy_conservation_desc',
      },
      {
        id: 'rule-data-integrity',
        labelKey: 'profile.tech.rule.data_integrity',
        descriptionKey: 'profile.tech.rule.data_integrity_desc',
      },
      {
        id: 'rule-system-limits',
        labelKey: 'profile.tech.rule.system_limits',
        descriptionKey: 'profile.tech.rule.system_limits_desc',
      },
    ],
    sceneObjectDefs: [
      {
        id: 'main-terminal',
        labelKey: 'profile.tech.scene.terminal',
        hintKey: 'profile.tech.scene.terminal_hint',
        box_2d: { ymin: 200, xmin: 300, ymax: 600, xmax: 700 },
      },
      {
        id: 'power-conduit',
        labelKey: 'profile.tech.scene.conduit',
        hintKey: 'profile.tech.scene.conduit_hint',
        box_2d: { ymin: 100, xmin: 50, ymax: 400, xmax: 200 },
      },
    ],
    welcomeMessageKey: 'profile.tech.welcome',
  },
};

/**
 * ëª¨ë“  ë°ëª¨ í”„ë¡œí•„ ëª©ë¡.
 */
export const DEMO_PROFILES: readonly DemoProfile[] = [
  PROFILE_NARRATOR,
  PROFILE_EXPLORER,
  PROFILE_TECH,
] as const;

/**
 * í”„ë¡œí•„ IDë¡œ í”„ë¡œí•„ì„ ì°¾ìŠµë‹ˆë‹¤.
 */
export function findProfileById(profileId: string): DemoProfile | undefined {
  return DEMO_PROFILES.find((p) => p.id === profileId);
}

// =============================================================================
// í”„ë¡œí•„ â†’ SaveGameInput ë³€í™˜ (RU-004-Q1: SSOT ë‹¨ì¼í™”)
// =============================================================================

/**
 * ë°ëª¨ í”„ë¡œí•„ì„ SaveGameInputìœ¼ë¡œ ë³€í™˜í•©ë‹ˆë‹¤.
 *
 * RU-004-Q1: SaveGame ìƒì„±ì€ createSaveGame(SSOT)ë§Œ ìˆ˜í–‰í•˜ë„ë¡ ë¶„ë¦¬.
 * ì´ í•¨ìˆ˜ëŠ” "ì…ë ¥ ë³€í™˜(input adapter)" ì—­í• ë§Œ ë‹´ë‹¹í•©ë‹ˆë‹¤.
 *
 * @param profile - ë°ëª¨ í”„ë¡œí•„
 * @param language - ì–¸ì–´ ì„¤ì •
 * @param t - i18n ë²ˆì—­ í•¨ìˆ˜
 * @returns SaveGameInput ê°ì²´ (createSaveGameì— ì „ë‹¬ ê°€ëŠ¥)
 */
export function profileToSaveGameInput(
  profile: DemoProfile,
  language: SupportedLanguage,
  t: (key: string) => string,
): SaveGameInput {
  const now = Date.now();

  return {
    language,
    profileId: profile.id,
    // RU-004-Q5: seed ìƒì„± ì •ì±… SSOT (constants.ts)
    seed: generateDemoSeed(profile.id),
    economy: {
      signal: profile.initialState.economy.signal,
      memory_shard: profile.initialState.economy.memory_shard,
      credit: profile.initialState.economy.credit,
    },
    economyLedger: [],
    turnCount: 0,
    narrativeHistory: [
      {
        turn: 0,
        text: t(profile.initialState.welcomeMessageKey),
      },
    ],
    // U-092: í”„ë¦¬ì…‹ ì•„ì´ì½˜ì´ ìˆìœ¼ë©´ iconì— URL ê²½ë¡œë¥¼ ì„¤ì • (ì¦‰ì‹œ í‘œì‹œ)
    inventory: profile.initialState.inventoryDefs.map((item) => ({
      id: item.id,
      name: t(item.nameKey),
      icon: getPresetIconUrl(item.id) ?? item.icon,
      quantity: item.quantity,
    })),
    // U-078: ëª©í‘œ ì‹œìŠ¤í…œ ê°•í™” - ì£¼ ëª©í‘œ/ì„œë¸Œ ëª©í‘œ/ì§„í–‰ë¥ /ë³´ìƒ ë°˜ì˜
    quests: profile.initialState.questDefs.map((quest) => ({
      id: quest.id,
      label: t(quest.labelKey),
      is_completed: quest.is_completed,
      description: quest.descriptionKey ? t(quest.descriptionKey) : null,
      is_main: quest.is_main ?? false,
      progress: quest.progress ?? 0,
      reward_signal: quest.reward_signal ?? 0,
    })),
    activeRules: profile.initialState.ruleDefs.map((rule) => ({
      id: rule.id,
      label: t(rule.labelKey),
      description: rule.descriptionKey ? t(rule.descriptionKey) : null,
    })),
    mutationTimeline: profile.initialState.ruleDefs.map((rule, index) => ({
      turn: 0,
      ruleId: rule.id,
      type: 'added' as const,
      label: t(rule.labelKey),
      description: rule.descriptionKey ? t(rule.descriptionKey) : undefined,
      timestamp: now - index * 1000,
    })),
    sceneObjects: profile.initialState.sceneObjectDefs.map((obj) => ({
      id: obj.id,
      label: t(obj.labelKey),
      box_2d: obj.box_2d,
      interaction_hint: t(obj.hintKey),
    })),
  };
}

/**
 * ë°ëª¨ í”„ë¡œí•„ì„ SaveGame í˜•íƒœë¡œ ë³€í™˜í•©ë‹ˆë‹¤.
 *
 * RU-004-Q1: createSaveGame(SSOT)ë¥¼ í˜¸ì¶œí•˜ëŠ” ì–‡ì€ wrapperì…ë‹ˆë‹¤.
 * ê¸°ì¡´ í˜¸ì¶œìì™€ì˜ í˜¸í™˜ì„±ì„ ìœ ì§€í•©ë‹ˆë‹¤.
 *
 * @param profile - ë°ëª¨ í”„ë¡œí•„
 * @param language - ì–¸ì–´ ì„¤ì •
 * @param t - i18n ë²ˆì—­ í•¨ìˆ˜
 * @returns SaveGame ê°ì²´
 */
export function createSaveGameFromProfile(
  profile: DemoProfile,
  language: SupportedLanguage,
  t: (key: string) => string,
): SaveGame {
  return createSaveGame(profileToSaveGameInput(profile, language, t));
}

/**
 * í”„ë¡œí•„ ëª©ë¡ ì •ë³´ë§Œ ê°€ì ¸ì˜µë‹ˆë‹¤ (ì„ íƒ UIìš©).
 */
export function getProfileSummaries(): Array<DemoProfileDef> {
  return DEMO_PROFILES.map((p) => ({
    id: p.id,
    nameKey: p.nameKey,
    descriptionKey: p.descriptionKey,
    icon: p.icon,
    themeColor: p.themeColor,
  }));
}
</file>

<file path="frontend/src/save/constants.ts">
/**
 * Unknown World - SaveGame/ì„¸ì…˜ ê´€ë ¨ ìƒìˆ˜ SSOT (RU-004-Q5).
 *
 * ì •ì±…/ì´ˆê¸°ê°’ì„ í•œ ê³³ìœ¼ë¡œ ëª¨ì•„ ë³€ê²½ ì‹œ ëˆ„ë½ ìœ„í—˜ì„ ë°©ì§€í•©ë‹ˆë‹¤.
 * ëª¨ë“  SaveGame/ì„¸ì…˜ ê´€ë ¨ ìƒìˆ˜ëŠ” ì´ íŒŒì¼ì—ì„œ ê´€ë¦¬í•©ë‹ˆë‹¤.
 *
 * ì„¤ê³„ ì›ì¹™:
 *   - RU-004-Q5: í•˜ë“œì½”ë”© ì •ë¦¬ - ìƒìˆ˜ ì¤‘ì•™í™”
 *   - RULE-010: DB ë„ì… ê¸ˆì§€, SaveGame JSON ì§ë ¬í™” ê¸°ë°˜
 *   - í–¥í›„ í™•ì¥: U-026(ë¦¬í”Œë ˆì´), U-025(ì—”ë”© ë¦¬í¬íŠ¸) í˜¸í™˜
 *
 * @module save/constants
 */

// =============================================================================
// SaveGame ë²„ì „ ê´€ë¦¬
// =============================================================================

/**
 * í˜„ì¬ SaveGame ìŠ¤í‚¤ë§ˆ ë²„ì „.
 *
 * ë²„ì „ ë³€ê²½ ì‹œ:
 * 1. migrations.tsì— ë§ˆì´ê·¸ë ˆì´ì…˜ í•¨ìˆ˜ ì¶”ê°€
 * 2. SUPPORTED_SAVEGAME_VERSIONSì— ì´ì „ ë²„ì „ ì¶”ê°€
 * 3. migrations.tsì˜ VERSION_ORDERì— ìƒˆ ë²„ì „ ì¶”ê°€
 *
 * ë²„ì „ í˜•ì‹: semver (major.minor.patch)
 *
 * @see saveGame.ts#migrateSaveGame
 * @see migrations.ts#upgradeToLatest
 */
export const SAVEGAME_VERSION = '1.0.0' as const;

/**
 * ì§€ì›í•˜ëŠ” SaveGame ë²„ì „ ëª©ë¡.
 *
 * ë§ˆì´ê·¸ë ˆì´ì…˜ ê°€ëŠ¥í•œ ì´ì „ ë²„ì „ë“¤ì„ í¬í•¨í•©ë‹ˆë‹¤.
 * ì´ ëª©ë¡ì— ì—†ëŠ” ë²„ì „ì€ ë§ˆì´ê·¸ë ˆì´ì…˜ ë¶ˆê°€ë¡œ ì²˜ë¦¬ë©ë‹ˆë‹¤.
 *
 * U-041: ë§ˆì´ê·¸ë ˆì´ì…˜ ì²´ì¸ì´ ìˆëŠ” ëª¨ë“  ë²„ì „ì„ í¬í•¨
 * - 0.9.0: í…ŒìŠ¤íŠ¸/ë°ëª¨ìš© êµ¬ë²„ì „ (sceneObjects, economyLedger ë“± ëˆ„ë½)
 * - 1.0.0: í˜„ì¬ ë²„ì „
 */
export const SUPPORTED_SAVEGAME_VERSIONS: readonly string[] = ['0.9.0', '1.0.0'] as const;

/**
 * ë§ˆì´ê·¸ë ˆì´ì…˜ ê°€ëŠ¥í•œ ìµœì†Œ ë²„ì „.
 *
 * ì´ ë²„ì „ë³´ë‹¤ ë‚®ì€ ë²„ì „ì€ ë§ˆì´ê·¸ë ˆì´ì…˜ì´ ë¶ˆê°€ëŠ¥í•˜ë©°,
 * ì €ì¥ ë°ì´í„°ê°€ íê¸°ë˜ê³  ìƒˆë¡œ ì‹œì‘í•´ì•¼ í•©ë‹ˆë‹¤.
 *
 * U-041: migrations.tsì˜ VERSION_ORDERì™€ ë™ê¸°í™” í•„ìš”
 */
export const MIN_MIGRATABLE_VERSION = '0.9.0' as const;

// =============================================================================
// localStorage í‚¤ (Storage Keys)
// =============================================================================

/**
 * SaveGame ì €ì¥ í‚¤.
 *
 * localStorageì—ì„œ ì„¸ì´ë¸Œ ë°ì´í„°ë¥¼ ì €ì¥/ë¡œë“œí•  ë•Œ ì‚¬ìš©í•©ë‹ˆë‹¤.
 * ì´ í‚¤ë¥¼ ë³€ê²½í•˜ë©´ ê¸°ì¡´ ì„¸ì´ë¸Œ ë°ì´í„°ê°€ ë¬´íš¨í™”ë©ë‹ˆë‹¤.
 */
export const SAVEGAME_STORAGE_KEY = 'unknown_world_savegame' as const;

/**
 * í˜„ì¬ ì„ íƒëœ í”„ë¡œí•„ ID ì €ì¥ í‚¤.
 *
 * localStorageì—ì„œ í˜„ì¬ í”„ë¡œí•„ IDë¥¼ ì €ì¥/ë¡œë“œí•  ë•Œ ì‚¬ìš©í•©ë‹ˆë‹¤.
 * SaveGame.profileIdê°€ SSOTì´ë©°, ì´ í‚¤ëŠ” í´ë°±/í˜¸í™˜ì„±ìš©ì…ë‹ˆë‹¤.
 *
 * @see sessionLifecycle.ts#getInitialProfileId
 */
export const CURRENT_PROFILE_KEY = 'unknown_world_current_profile' as const;

// =============================================================================
// Seed ìƒì„± ì •ì±…
// =============================================================================

/**
 * ë°ëª¨ seed ì ‘ë‘ì‚¬.
 *
 * ë°ëª¨ í”„ë¡œí•„ì—ì„œ ìƒì„±ë˜ëŠ” seedì˜ ì ‘ë‘ì‚¬ì…ë‹ˆë‹¤.
 * seed í˜•ì‹: `{DEMO_SEED_PREFIX}-{profileId}-{timestamp}`
 *
 * @example 'demo-narrator-1706000000000'
 */
export const DEMO_SEED_PREFIX = 'demo' as const;

/**
 * Seed ìƒì„± ì •ì±… (ë¬¸ì„œí™”ìš© ì£¼ì„).
 *
 * ## í˜„ì¬ ì •ì±…: now ê¸°ë°˜ seed (ì„¸ì…˜ ë‹¤ì–‘ì„± ì¤‘ì‹œ)
 *
 * í”„ë¡œí•„ ì‹œì‘ ì‹œë§ˆë‹¤ ìƒˆë¡œìš´ seedê°€ ìƒì„±ë©ë‹ˆë‹¤.
 * - ì¥ì : ë§¤ ì„¸ì…˜ë§ˆë‹¤ ë‹¤ë¥¸ ì´ˆê¸° ìƒíƒœ/ì´ë²¤íŠ¸ ê°€ëŠ¥
 * - ë‹¨ì : ë°ëª¨ ë°˜ë³µì„±(ë™ì¼ ì‹œì‘) ë³´ì¥ ì–´ë ¤ì›€
 *
 * ## ëŒ€ì•ˆ: ê³ ì • seed (ë°ëª¨ ë°˜ë³µì„± ì¤‘ì‹œ)
 *
 * í”„ë¡œí•„ IDë§Œìœ¼ë¡œ seedë¥¼ ìƒì„±í•©ë‹ˆë‹¤.
 * - ì¥ì : ë™ì¼ í”„ë¡œí•„ì€ í•­ìƒ ë™ì¼í•œ ì‹œì‘ ìƒíƒœ
 * - ë‹¨ì : ì„¸ì…˜ ë‹¤ì–‘ì„± ë¶€ì¡±
 *
 * ## í–¥í›„ í™•ì¥ (U-026: ë¦¬í”Œë ˆì´)
 *
 * seedë¥¼ SaveGameì— ì €ì¥í•˜ì—¬ ë¦¬í”Œë ˆì´ ì‹œ ë™ì¼ ê²°ê³¼ ì¬í˜„ ê°€ëŠ¥.
 * ì—”ë”© ë¦¬í¬íŠ¸(U-025)ì—ì„œë„ seedë¥¼ ê¸°ë¡í•˜ì—¬ ê²°ê³¼ ë¶„ì„ì— í™œìš©.
 *
 * @see demoProfiles.ts#profileToSaveGameInput
 */
export const SEED_POLICY = {
  /** í˜„ì¬ ì ìš© ì¤‘ì¸ ì •ì±… */
  current: 'timestamp' as const,
  /** ê°€ëŠ¥í•œ ì •ì±… ëª©ë¡ */
  options: ['timestamp', 'fixed', 'hybrid'] as const,
} as const;

/**
 * Seedë¥¼ ìƒì„±í•©ë‹ˆë‹¤.
 *
 * í˜„ì¬ ì •ì±…(now ê¸°ë°˜)ì— ë”°ë¼ seed ë¬¸ìì—´ì„ ìƒì„±í•©ë‹ˆë‹¤.
 *
 * @param profileId - í”„ë¡œí•„ ID
 * @returns seed ë¬¸ìì—´
 */
export function generateDemoSeed(profileId: string): string {
  const now = Date.now();
  return `${DEMO_SEED_PREFIX}-${profileId}-${now}`;
}

// =============================================================================
// Economy ì •ì±… ìƒìˆ˜
// =============================================================================

/**
 * ì”ì•¡ ë¶€ì¡± ê²½ê³  ì„ê³„ê°’ (Signal ê¸°ì¤€).
 *
 * Signal ì”ì•¡ì´ ì´ ê°’ ë¯¸ë§Œì´ë©´ isBalanceLowê°€ trueê°€ ë©ë‹ˆë‹¤.
 * HUDì—ì„œ ê²½ê³  í‘œì‹œ ë° ëŒ€ì²´ í–‰ë™ ì œì•ˆì— ì‚¬ìš©ë©ë‹ˆë‹¤.
 *
 * @see economyStore.ts#updateBalanceLowStatus
 */
export const LOW_BALANCE_THRESHOLD = 10 as const;

/**
 * ê±°ë˜ ì¥ë¶€(Ledger) ìµœëŒ€ ë³´ê´€ ê°œìˆ˜.
 * ìµœê·¼ Nê°œì˜ í„´ ê±°ë˜ ì¥ë¶€ë§Œ ë³´ê´€í•©ë‹ˆë‹¤ (ë©”ëª¨ë¦¬ ìµœì í™”).
 * @see economyStore.ts#addLedgerEntry
 */
export const LEDGER_MAX_ENTRIES = 20 as const;

// =============================================================================
// U-079: ì•„ì´í…œ íŒë§¤ ì •ì±…
// =============================================================================

/**
 * ì•„ì´í…œ íŒë§¤ ê¸°ë³¸ ê°€ê²© (Signal).
 *
 * MVPì—ì„œëŠ” ëª¨ë“  ì•„ì´í…œì˜ íŒë§¤ ê°€ê²©ì´ ê³ ì •ì…ë‹ˆë‹¤.
 * í–¥í›„ ì•„ì´í…œë³„ ê°€ê²© ì°¨ë“±í™”ê°€ ê°€ëŠ¥í•©ë‹ˆë‹¤.
 *
 * @see InventoryPanel.tsx - íŒë§¤ ë²„íŠ¼
 */
export const ITEM_SELL_PRICE_SIGNAL = 5 as const;

// =============================================================================
// ì´ˆê¸°ê°’ ì •ì±… (Placeholder vs ì£¼ì…)
// =============================================================================

/**
 * World/Economy ì´ˆê¸°ê°’ ì •ì±… (ë¬¸ì„œí™”ìš© ì£¼ì„).
 *
 * ## ì„¤ê³„ ì›ì¹™
 *
 * Storeì˜ createInitialState()ì—ì„œ ì •ì˜í•˜ëŠ” economy ë“±ì˜ ê°’ì€
 * **"í”Œë ˆì´ ì „ placeholder"**ë¡œ ì·¨ê¸‰í•©ë‹ˆë‹¤.
 *
 * ì‹¤ì œ ê²Œì„ ì‹œì‘ ê°’ì€ í•­ìƒ ë‹¤ìŒ ì¤‘ í•˜ë‚˜ì—ì„œ ì£¼ì…ë©ë‹ˆë‹¤:
 * 1. í”„ë¡œí•„ ì´ˆê¸° SaveGame (startSessionFromProfile)
 * 2. ì €ì¥ëœ SaveGame ë³µì› (continueSession)
 *
 * ## Placeholder ê°’ì˜ ì˜ë¯¸
 *
 * - worldStore.economy: { signal: 100, memory_shard: 5 }
 *   â†’ playing ì§„ì… ì „ profile_select ìƒíƒœì—ì„œëŠ” HUDê°€ ë…¸ì¶œë˜ì§€ ì•ŠìŒ
 *   â†’ ë”°ë¼ì„œ ì´ ê°’ì´ í™”ë©´ì— í‘œì‹œë  ì¼ì€ ì—†ìŒ
 *
 * ## í–¥í›„ ê°œì„  (S2 ì„ í–‰ í•„ìš”)
 *
 * S2(ì˜ëª»ëœ playing ì§„ì…)ê°€ í•´ê²°ë˜ë©´:
 * - economy: null ê°™ì€ "ë¯¸ì´ˆê¸°í™” ìƒíƒœ"ë¡œ ë³€ê²½ ê°€ëŠ¥
 * - playing ì§„ì… ì „ì— ë°˜ë“œì‹œ í”„ë¡œí•„/ì„¸ì´ë¸Œ ì£¼ì…ì„ ê°•ì œ
 * - "placeholderê°€ í™”ë©´ì— ë³´ì´ëŠ”" ë¬¸ì œë¥¼ ì›ì²œ ì°¨ë‹¨
 *
 * @see worldStore.ts#createInitialState
 * @see sessionLifecycle.ts
 */
export const INITIAL_VALUE_POLICY = {
  description: 'Placeholder values for pre-play state',
  worldEconomy: {
    signal: 100,
    memory_shard: 5,
  },
} as const;

// =============================================================================
// ë°ëª¨ í”„ë¡œí•„ ê¸°ë³¸ ì¬í™” ë²”ìœ„ (ì°¸ê³ ìš©)
// =============================================================================

/**
 * ë°ëª¨ í”„ë¡œí•„ ì¬í™” ë²”ìœ„ ì°¸ê³  (ë¬¸ì„œí™”ìš©).
 *
 * ê° í”„ë¡œí•„ì˜ ì´ˆê¸° ì¬í™”ëŠ” demoProfiles.tsì—ì„œ ì§ì ‘ ì •ì˜í•©ë‹ˆë‹¤.
 * ì´ ìƒìˆ˜ëŠ” "ì •ì±… ë²”ìœ„"ë¥¼ ë¬¸ì„œí™”í•˜ê¸° ìœ„í•œ ì°¸ê³ ìš©ì…ë‹ˆë‹¤.
 *
 * - Narrator: í’ë¶€í•œ ì¬í™” (ë‹¤ì–‘í•œ ì„ íƒì§€ íƒìƒ‰)
 * - Explorer: ì ë‹¹í•œ ì¬í™” (ê· í˜• ì¡íŒ í”Œë ˆì´)
 * - Tech: ì œí•œëœ ì¬í™” (íš¨ìœ¨ì  ì „ëµ í•„ìš”)
 *
 * @see demoProfiles.ts
 */
export const DEMO_PROFILE_ECONOMY_REFERENCE = {
  narrator: { signal: 200, memory_shard: 10 },
  explorer: { signal: 150, memory_shard: 5 },
  tech: { signal: 80, memory_shard: 15 },
} as const;
</file>

<file path="frontend/src/save/saveGame.test.ts">
import { describe, it, expect, beforeEach, vi } from 'vitest';
import {
  SaveGameSchema,
  createSaveGame,
  saveSaveGame,
  loadSaveGame,
  clearSaveGame,
  hasSaveGame,
  SAVEGAME_STORAGE_KEY,
  SAVEGAME_VERSION,
  type SaveGameInput,
} from './saveGame';

describe('saveGame utility (U-015[Mvp])', () => {
  beforeEach(() => {
    // localStorage ì´ˆê¸°í™”
    localStorage.clear();
    vi.clearAllMocks();
  });

  const mockInput: SaveGameInput = {
    language: 'ko-KR',
    profileId: 'explorer',
    seed: 'test-seed',
    economy: { signal: 100, memory_shard: 5, credit: 0 },
    economyLedger: [],
    turnCount: 1,
    narrativeHistory: [{ turn: 1, text: 'í…ŒìŠ¤íŠ¸ ë‚´ëŸ¬í‹°ë¸Œ' }],
    inventory: [{ id: 'item1', name: 'ì•„ì´í…œ1', quantity: 1 }],
    quests: [
      {
        id: 'q1',
        label: 'í€˜ìŠ¤íŠ¸1',
        is_completed: false,
        description: null,
        is_main: false,
        progress: 0,
        reward_signal: 0,
      },
    ],
    activeRules: [{ id: 'r1', label: 'ê·œì¹™1', description: 'ì„¤ëª…1' }],
    mutationTimeline: [],
    sceneObjects: [],
  };

  it('createSaveGameì€ ì˜¬ë°”ë¥¸ ìŠ¤í‚¤ë§ˆë¥¼ ê°€ì§„ ê°ì²´ë¥¼ ìƒì„±í•´ì•¼ í•œë‹¤', () => {
    const saveGame = createSaveGame(mockInput);

    expect(saveGame.version).toBe(SAVEGAME_VERSION);
    expect(saveGame.language).toBe('ko-KR');
    expect(saveGame.profileId).toBe('explorer');
    expect(saveGame.economy.signal).toBe(100);
    expect(saveGame.inventory).toHaveLength(1);
    expect(saveGame.inventory[0].name).toBe('ì•„ì´í…œ1');

    // Zod ìŠ¤í‚¤ë§ˆ ê²€ì¦
    const result = SaveGameSchema.safeParse(saveGame);
    expect(result.success).toBe(true);
  });

  it('saveSaveGameì€ ë°ì´í„°ë¥¼ localStorageì— ì €ì¥í•´ì•¼ í•œë‹¤', () => {
    const saveGame = createSaveGame(mockInput);
    const success = saveSaveGame(saveGame);

    expect(success).toBe(true);
    expect(localStorage.getItem(SAVEGAME_STORAGE_KEY)).not.toBeNull();

    const storedData = JSON.parse(localStorage.getItem(SAVEGAME_STORAGE_KEY)!);
    expect(storedData.profileId).toBe('explorer');
  });

  it('loadSaveGameì€ ì €ì¥ëœ ë°ì´í„°ë¥¼ ì˜¬ë°”ë¥´ê²Œ ë¡œë“œí•´ì•¼ í•œë‹¤', () => {
    const saveGame = createSaveGame(mockInput);
    saveSaveGame(saveGame);

    const loaded = loadSaveGame();
    expect(loaded).not.toBeNull();
    expect(loaded?.profileId).toBe('explorer');
    expect(loaded?.version).toBe(SAVEGAME_VERSION);
  });

  it('ë°ì´í„°ê°€ ì—†ì„ ë•Œ loadSaveGameì€ nullì„ ë°˜í™˜í•´ì•¼ í•œë‹¤', () => {
    const loaded = loadSaveGame();
    expect(loaded).toBeNull();
  });

  it('ìœ íš¨í•˜ì§€ ì•Šì€ ë°ì´í„°ê°€ ì €ì¥ë˜ì–´ ìˆìœ¼ë©´ loadSaveGameì€ nullì„ ë°˜í™˜í•´ì•¼ í•œë‹¤', () => {
    localStorage.setItem(SAVEGAME_STORAGE_KEY, JSON.stringify({ version: 'unknown' }));

    // safeParse ì‹¤íŒ¨ë¡œ ì¸í•´ null ë°˜í™˜ ì˜ˆìƒ
    const loaded = loadSaveGame();
    expect(loaded).toBeNull();
  });

  it('êµ¬ë²„ì „(0.9.0) ë°ì´í„°ê°€ ì €ì¥ë˜ì–´ ìˆìœ¼ë©´ ë§ˆì´ê·¸ë ˆì´ì…˜ í›„ ë¡œë“œí•´ì•¼ í•œë‹¤', () => {
    const oldSave = {
      version: '0.9.0',
      language: 'ko-KR',
      seed: 'old-seed',
      profileId: 'narrator',
      savedAt: new Date().toISOString(),
      economy: {
        signal: 120,
        memory_shards: 8, // êµ¬ë²„ì „ ì˜¤íƒ€ í•„ë“œ
      },
      turnCount: 5,
      narrativeHistory: [],
      inventory: [],
      quests: [],
      activeRules: [],
      mutationTimeline: [],
      // sceneObjects ëˆ„ë½
    };

    localStorage.setItem(SAVEGAME_STORAGE_KEY, JSON.stringify(oldSave));

    const loaded = loadSaveGame();
    expect(loaded).not.toBeNull();
    expect(loaded?.version).toBe(SAVEGAME_VERSION);
    expect(loaded?.economy.memory_shard).toBe(8); // ë§ˆì´ê·¸ë ˆì´ì…˜ í™•ì¸
    expect(Array.isArray(loaded?.sceneObjects)).toBe(true); // í•„ë“œ ì¶”ê°€ í™•ì¸
    expect(loaded?.sceneObjects).toHaveLength(0);

    // ì €ì¥ì†Œì—ë„ ìµœì‹  ë°ì´í„°ë¡œ ì—…ë°ì´íŠ¸ë˜ì—ˆëŠ”ì§€ í™•ì¸ (ì„ íƒ ì‚¬í•­: í˜„ì¬ loadSaveGameì€ ë©”ëª¨ë¦¬ì—ì„œë§Œ ë³€í™˜í•˜ê³  ì €ì¥ì†Œ ì—…ë°ì´íŠ¸ëŠ” í•˜ì§€ ì•ŠìŒ)
    // ë§Œì•½ loadSaveGameì´ ì €ì¥ì†Œ ì—…ë°ì´íŠ¸ê¹Œì§€ ìˆ˜í–‰í•œë‹¤ë©´ ì•„ë˜ ê²€ì¦ ì¶”ê°€ ê°€ëŠ¥
  });

  it('clearSaveGameì€ ì €ì¥ëœ ë°ì´í„°ë¥¼ ì‚­ì œí•´ì•¼ í•œë‹¤', () => {
    const saveGame = createSaveGame(mockInput);
    saveSaveGame(saveGame);
    expect(hasSaveGame()).toBe(true);

    clearSaveGame();
    expect(hasSaveGame()).toBe(false);
    expect(localStorage.getItem(SAVEGAME_STORAGE_KEY)).toBeNull();
  });

  it('hasSaveGameì€ ë°ì´í„° ì¡´ì¬ ì—¬ë¶€ë¥¼ ì •í™•íˆ ë°˜í™˜í•´ì•¼ í•œë‹¤', () => {
    expect(hasSaveGame()).toBe(false);

    const saveGame = createSaveGame(mockInput);
    saveSaveGame(saveGame);
    expect(hasSaveGame()).toBe(true);
  });
});
</file>

<file path="frontend/src/save/sessionLifecycle.ts">
/**
 * Unknown World - ì„¸ì…˜ ë¼ì´í”„ì‚¬ì´í´ ê´€ë¦¬ ëª¨ë“ˆ (RU-004-Q4).
 *
 * ì„¸ì…˜ ì´ˆê¸°í™”/ë³µì›/ë¦¬ì…‹/ë³€ê²½ì„ SSOTë¡œ ê´€ë¦¬í•©ë‹ˆë‹¤.
 * App.tsxì˜ ì„¸ì…˜ ê´€ë ¨ ë¡œì§ì„ ì´ ëª¨ë“ˆë¡œ ì´ë™í•˜ì—¬ ì±…ì„ ê²½ê³„ë¥¼ ëª…í™•íˆ í•©ë‹ˆë‹¤.
 *
 * ì„¤ê³„ ì›ì¹™:
 *   - RULE-005: Economy ì¸ë°”ë¦¬ì–¸íŠ¸ (ì”ì•¡ ìŒìˆ˜ ê¸ˆì§€)
 *   - RULE-006: ko/en i18n ì •ì±… ì¤€ìˆ˜ (ì–¸ì–´ ì ìš© í›„ UI ë Œë”ë§)
 *   - RU-004-S1: ì–¸ì–´ async ì ìš© ì™„ë£Œ í›„ store ì£¼ì…
 *   - RU-004-S2: profileId SSOT + ìœ íš¨ SaveGameë§Œ Continue
 *
 * @module save/sessionLifecycle
 */

import {
  loadSaveGame,
  saveSaveGame,
  clearSaveGame,
  getValidSaveGameOrNull,
  createSaveGame,
  loadCurrentProfileId,
  saveCurrentProfileId,
  clearCurrentProfileId,
} from './saveGame';
import { findProfileById, createSaveGameFromProfile, type DemoProfile } from '../data/demoProfiles';
import {
  getResolvedLanguage,
  changeLanguage,
  type SupportedLanguage,
  DEFAULT_LANGUAGE,
} from '../i18n';
import { useWorldStore } from '../stores/worldStore';
import { useInventoryStore } from '../stores/inventoryStore';
import { useEconomyStore } from '../stores/economyStore';
import { useActionDeckStore } from '../stores/actionDeckStore';
import { useAgentStore } from '../stores/agentStore';

// =============================================================================
// íƒ€ì… ì •ì˜
// =============================================================================

/**
 * ë¶€íŒ… ê²°ê³¼ íƒ€ì….
 * ì•± ì‹œì‘ ì‹œ ì–´ë–¤ phaseë¡œ ì‹œì‘í• ì§€ ê²°ì •í•©ë‹ˆë‹¤.
 */
export type SessionBootstrap =
  | { phase: 'profile_select'; savedGameAvailable: boolean }
  | { phase: 'playing'; profileId: string | null };

/**
 * ì„¸ì…˜ ì‹œì‘ ê²°ê³¼ íƒ€ì….
 */
export interface SessionStartResult {
  success: true;
  profileId: string;
}

/**
 * ì„¸ì…˜ ë³µì› ê²°ê³¼ íƒ€ì….
 */
export interface SessionContinueResult {
  success: true;
  profileId: string;
}

/**
 * ì„¸ì…˜ ë¦¬ì…‹ ê²°ê³¼ íƒ€ì….
 */
export interface SessionResetResult {
  success: boolean;
  profileId: string | null;
}

// =============================================================================
// ë‚´ë¶€ í—¬í¼: ëª¨ë“  ì„¸ì…˜ ê´€ë ¨ storeë¥¼ ì´ˆê¸°í™”
// =============================================================================

/**
 * ëª¨ë“  ì„¸ì…˜ ê´€ë ¨ storeë¥¼ ì´ˆê¸°í™”í•©ë‹ˆë‹¤.
 *
 * RU-004-Q4 Step 2: store reset/hydrate ë²”ìœ„ í‘œì¤€í™”
 * - worldStore, inventoryStore, economyStore, actionDeckStore, agentStore
 *
 * ì„¸ì…˜ ê²½ê³„ì—ì„œ í•­ìƒ ì´ í•¨ìˆ˜ë¥¼ í˜¸ì¶œí•˜ì—¬ ì´ì „ ì„¸ì…˜ ì”ì¬ë¥¼ ì™„ì „íˆ ì œê±°í•©ë‹ˆë‹¤.
 */
function resetAllSessionStores(): void {
  useWorldStore.getState().reset();
  useInventoryStore.getState().reset();
  useEconomyStore.getState().reset();
  useActionDeckStore.getState().reset();
  useAgentStore.getState().reset();
}

// =============================================================================
// ì„¸ì…˜ ë¼ì´í”„ì‚¬ì´í´ API
// =============================================================================

/**
 * ë¶€íŒ… ì‹œ ì„¸ì…˜ ìƒíƒœë¥¼ í™•ì¸í•˜ê³  ì‹œì‘ phaseë¥¼ ê²°ì •í•©ë‹ˆë‹¤.
 *
 * RU-004-S2: hasSaveGame() ëŒ€ì‹  getValidSaveGameOrNull()ë¡œ "ìœ íš¨í•œ ì„¸ì´ë¸Œë§Œ" íŒë‹¨
 *
 * @returns SessionBootstrap - ì‹œì‘ phaseì™€ ê´€ë ¨ ì •ë³´
 */
export function bootstrapSession(): SessionBootstrap {
  const validSaveGame = getValidSaveGameOrNull();

  if (validSaveGame) {
    // ìœ íš¨í•œ ì„¸ì´ë¸Œê°€ ìˆìœ¼ë©´ playing ìƒíƒœë¡œ ì‹œì‘
    return {
      phase: 'playing',
      profileId: validSaveGame.profileId,
    };
  }

  // ìœ íš¨í•œ ì„¸ì´ë¸Œê°€ ì—†ìœ¼ë©´ profile_selectë¡œ ì‹œì‘
  // ë‹¨, localStorageì— ê¹¨ì§„ ì„¸ì´ë¸Œê°€ ìˆì„ ìˆ˜ ìˆìœ¼ë¯€ë¡œ savedGameAvailableì€ false
  return {
    phase: 'profile_select',
    savedGameAvailable: false,
  };
}

/**
 * ì €ì¥ëœ ê²Œì„ì´ ìˆëŠ”ì§€ í™•ì¸í•©ë‹ˆë‹¤ (Continue ë²„íŠ¼ í‘œì‹œìš©).
 *
 * RU-004-S2: ìœ íš¨í•œ ì„¸ì´ë¸Œë§Œ "ìˆìŒ"ìœ¼ë¡œ íŒë‹¨
 *
 * @returns ìœ íš¨í•œ ì„¸ì´ë¸Œê°€ ìˆìœ¼ë©´ true
 */
export function hasValidSaveGame(): boolean {
  return getValidSaveGameOrNull() !== null;
}

/**
 * í”„ë¡œí•„ì„ ì„ íƒí•˜ê³  ìƒˆ ì„¸ì…˜ì„ ì‹œì‘í•©ë‹ˆë‹¤.
 *
 * RU-004-Q4 Step 1: startSessionFromProfile
 * U-044: ì„¸ì…˜ ì–¸ì–´ë¥¼ ëª…ì‹œì ìœ¼ë¡œ ë°›ì•„ SSOT ìœ ì§€
 * - ëª¨ë“  storeë¥¼ ì´ˆê¸°í™”
 * - í”„ë¡œí•„ ê¸°ë°˜ SaveGame ìƒì„±
 * - storeì— ì´ˆê¸° ìƒíƒœ ì£¼ì…
 * - localStorageì— ì €ì¥
 *
 * @param args.profile - ì„ íƒí•œ ë°ëª¨ í”„ë¡œí•„
 * @param args.t - i18n ë²ˆì—­ í•¨ìˆ˜
 * @param args.language - ì„¸ì…˜ ì–¸ì–´ (U-044: ëª…ì‹œì  ì „ë‹¬ë¡œ SSOT ìœ ì§€)
 * @returns ì„¸ì…˜ ì‹œì‘ ê²°ê³¼
 */
export function startSessionFromProfile(args: {
  profile: DemoProfile;
  t: (key: string) => string;
  language?: SupportedLanguage;
}): SessionStartResult {
  const { profile, t, language: explicitLanguage } = args;

  // U-044: ëª…ì‹œì  ì–¸ì–´ê°€ ìˆìœ¼ë©´ ì‚¬ìš©, ì—†ìœ¼ë©´ i18n í˜„ì¬ ê°’ ì‚¬ìš©
  const language = explicitLanguage ?? getResolvedLanguage();

  // í”„ë¡œí•„ì—ì„œ SaveGame ìƒì„±
  const saveGame = createSaveGameFromProfile(profile, language, t);

  // ëª¨ë“  ì„¸ì…˜ store ì´ˆê¸°í™” (ì´ì „ ì„¸ì…˜ ì”ì¬ ì œê±°)
  resetAllSessionStores();

  // Storeì— ì´ˆê¸° ìƒíƒœ ì£¼ì…
  useWorldStore.setState({
    economy: {
      signal: saveGame.economy.signal,
      memory_shard: saveGame.economy.memory_shard,
      credit: saveGame.economy.credit ?? 0,
    },
    turnCount: 0,
    narrativeEntries: saveGame.narrativeHistory,
    quests: saveGame.quests,
    activeRules: saveGame.activeRules,
    mutationTimeline: saveGame.mutationTimeline,
    sceneObjects: saveGame.sceneObjects,
  });

  useInventoryStore.getState().setItems(saveGame.inventory);

  // í”„ë¡œí•„ ID ì €ì¥ (localStorage)
  saveCurrentProfileId(profile.id);

  // SaveGame ì €ì¥ (localStorage)
  saveSaveGame(saveGame);

  return {
    success: true,
    profileId: profile.id,
  };
}

/**
 * ì €ì¥ëœ ê²Œì„ì„ ë³µì›í•˜ì—¬ ì„¸ì…˜ì„ ê³„ì†í•©ë‹ˆë‹¤.
 *
 * RU-004-Q4 Step 1: continueSession
 * RU-004-S1: asyncë¡œ ì–¸ì–´ ì ìš© ì™„ë£Œ í›„ store ì£¼ì…
 * RU-004-S2: profileId SSOT + ë¡œë“œ ì‹¤íŒ¨ ì‹œ null ë°˜í™˜
 *
 * @returns ì„¸ì…˜ ë³µì› ê²°ê³¼ ë˜ëŠ” null (ì‹¤íŒ¨ ì‹œ)
 */
export async function continueSession(): Promise<SessionContinueResult | null> {
  const saveGame = loadSaveGame();
  if (!saveGame) {
    // ë¡œë“œ ì‹¤íŒ¨ ì‹œ í´ë¦°ì—…
    clearSaveGame();
    clearCurrentProfileId();
    console.warn('[SessionLifecycle] SaveGame ë¡œë“œ ì‹¤íŒ¨, ìƒˆë¡œ ì‹œì‘ í•„ìš”');
    return null;
  }

  // RU-004-S1: ì–¸ì–´ ì„¤ì • ë¹„ë™ê¸° ì ìš© ì™„ë£Œ í›„ ì§„í–‰ (RULE-006)
  await changeLanguage(saveGame.language as SupportedLanguage);

  // ëª¨ë“  ì„¸ì…˜ store ì´ˆê¸°í™” (ì´ì „ ì„¸ì…˜ ì”ì¬ ì œê±°)
  resetAllSessionStores();

  // Storeì— ì €ì¥ëœ ìƒíƒœ ë³µì›
  useWorldStore.setState({
    economy: {
      signal: saveGame.economy.signal,
      memory_shard: saveGame.economy.memory_shard,
      credit: saveGame.economy.credit ?? 0,
    },
    turnCount: saveGame.turnCount,
    narrativeEntries: saveGame.narrativeHistory,
    quests: saveGame.quests,
    activeRules: saveGame.activeRules,
    mutationTimeline: saveGame.mutationTimeline,
    sceneObjects: saveGame.sceneObjects,
  });

  // ì¸ë²¤í† ë¦¬ ë³µì›
  useInventoryStore.getState().setItems(saveGame.inventory);

  // Economy ë³µì› (RU-004-S1: hydrateLedgerë¡œ ìˆœì„œ/timestamp/lastCost/isBalanceLow ì •í•©ì„± ë³´ì¥)
  useEconomyStore.getState().hydrateLedger(saveGame.economyLedger, saveGame.economy);

  // RU-004-S2: profileId SSOT - SaveGame.profileIdë¥¼ ê¶Œìœ„ìë¡œ ì‚¬ìš©
  const profileId = saveGame.profileId;
  if (profileId) {
    saveCurrentProfileId(profileId); // localStorage ë™ê¸°í™” (ë“œë¦¬í”„íŠ¸ ë°©ì§€)
  }

  return {
    success: true,
    profileId: profileId ?? loadCurrentProfileId() ?? '',
  };
}

/**
 * í˜„ì¬ í”„ë¡œí•„ì˜ ì´ˆê¸° ìƒíƒœë¡œ ë¦¬ì…‹í•©ë‹ˆë‹¤.
 *
 * RU-004-Q4 Step 1: resetToCurrentProfile
 *
 * @param args.t - i18n ë²ˆì—­ í•¨ìˆ˜
 * @param args.currentProfileId - í˜„ì¬ í”„ë¡œí•„ ID
 * @returns ë¦¬ì…‹ ì„±ê³µ ì—¬ë¶€
 */
export function resetToCurrentProfile(args: {
  t: (key: string) => string;
  currentProfileId: string | null;
}): SessionResetResult {
  const { t, currentProfileId } = args;

  if (!currentProfileId) {
    return { success: false, profileId: null };
  }

  const profile = findProfileById(currentProfileId);
  if (!profile) {
    return { success: false, profileId: null };
  }

  // ë™ì¼ í”„ë¡œí•„ë¡œ ìƒˆ ì„¸ì…˜ ì‹œì‘
  const result = startSessionFromProfile({ profile, t });

  return {
    success: result.success,
    profileId: result.profileId,
  };
}

/**
 * ì„¸ì…˜ì„ ì¢…ë£Œí•˜ê³  í”„ë¡œí•„ ì„ íƒ í™”ë©´ìœ¼ë¡œ ëŒì•„ê°‘ë‹ˆë‹¤.
 *
 * RU-004-Q4 Step 1: clearSessionAndReturnToSelect
 * - ëª¨ë“  ì„¸ì…˜ ë°ì´í„° í´ë¦°ì—… (localStorage + store)
 */
export function clearSessionAndReturnToSelect(): void {
  // localStorage í´ë¦°ì—…
  clearSaveGame();
  clearCurrentProfileId();

  // ëª¨ë“  ì„¸ì…˜ store ì´ˆê¸°í™”
  resetAllSessionStores();
}

/**
 * í˜„ì¬ ìƒíƒœë¥¼ ì €ì¥í•©ë‹ˆë‹¤.
 *
 * í„´ ì™„ë£Œ ì‹œ ìë™ ì €ì¥ì— ì‚¬ìš©ë©ë‹ˆë‹¤.
 *
 * RU-004-Q5: seedëŠ” ì„¸ì…˜ ì‹œì‘ ì‹œ ìƒì„±ë˜ê³ , ì´í›„ ë³€ê²½ë˜ì§€ ì•Šì•„ì•¼ í•©ë‹ˆë‹¤.
 * ê¸°ì¡´ SaveGameì—ì„œ seedë¥¼ ì½ì–´ì™€ì„œ ìœ ì§€í•©ë‹ˆë‹¤.
 *
 * @param profileId - í˜„ì¬ í”„ë¡œí•„ ID
 * @returns ì €ì¥ ì„±ê³µ ì—¬ë¶€
 */
export function saveCurrentSession(profileId: string | null): boolean {
  if (!profileId) return false;

  const worldState = useWorldStore.getState();
  const economyState = useEconomyStore.getState();
  const inventoryState = useInventoryStore.getState();

  // RU-004-Q5: ê¸°ì¡´ SaveGameì—ì„œ seedë¥¼ ê°€ì ¸ì™€ ìœ ì§€ (SSOT)
  const existingSaveGame = getValidSaveGameOrNull();
  const seed = existingSaveGame?.seed ?? null;

  const saveGame = createSaveGame({
    language: getResolvedLanguage(),
    profileId,
    seed, // RU-004-Q5: seed ìœ ì§€
    economy: worldState.economy,
    economyLedger: economyState.ledger,
    turnCount: worldState.turnCount,
    narrativeHistory: worldState.narrativeEntries,
    inventory: inventoryState.items,
    quests: worldState.quests,
    activeRules: worldState.activeRules,
    mutationTimeline: worldState.mutationTimeline,
    sceneObjects: worldState.sceneObjects,
  });

  return saveSaveGame(saveGame);
}

/**
 * ì´ˆê¸° profileIdë¥¼ ê²°ì •í•©ë‹ˆë‹¤.
 *
 * RU-004-S2: SaveGame.profileIdê°€ SSOT, CURRENT_PROFILE_KEYëŠ” í´ë°±
 *
 * @returns ì´ˆê¸° profileId ë˜ëŠ” null
 */
export function getInitialProfileId(): string | null {
  // ìœ íš¨í•œ SaveGameì´ ìˆìœ¼ë©´ ê·¸ profileIdë¥¼ ì‚¬ìš©
  const validSaveGame = getValidSaveGameOrNull();
  if (validSaveGame?.profileId) {
    return validSaveGame.profileId;
  }
  // í´ë°±: CURRENT_PROFILE_KEY (í˜¸í™˜ì„±)
  return loadCurrentProfileId();
}

// =============================================================================
// U-044: ì„¸ì…˜ ì–¸ì–´ SSOT API
// =============================================================================

/**
 * í˜„ì¬ ì„¸ì…˜ ì–¸ì–´ë¥¼ ë°˜í™˜í•©ë‹ˆë‹¤ (SSOT).
 *
 * U-044: SaveGame.languageë¥¼ ê¶Œìœ„ìë¡œ ì‚¬ìš©í•˜ì—¬ ì–¸ì–´ ë“œë¦¬í”„íŠ¸ë¥¼ ë°©ì§€í•©ë‹ˆë‹¤.
 * - ìœ íš¨í•œ SaveGameì´ ìˆìœ¼ë©´ í•´ë‹¹ ì–¸ì–´ ë°˜í™˜
 * - ì—†ìœ¼ë©´ i18nì˜ í˜„ì¬ ì–¸ì–´ ë°˜í™˜ (í´ë°±)
 *
 * TurnRunnerì—ì„œ TurnInput.languageë¥¼ ìƒì„±í•  ë•Œ ì´ í•¨ìˆ˜ë¥¼ ì‚¬ìš©í•©ë‹ˆë‹¤.
 *
 * @returns í˜„ì¬ ì„¸ì…˜ ì–¸ì–´ (ko-KR | en-US)
 */
export function getSessionLanguage(): SupportedLanguage {
  const validSaveGame = getValidSaveGameOrNull();
  if (validSaveGame?.language) {
    return validSaveGame.language as SupportedLanguage;
  }
  // í´ë°±: i18nì˜ í˜„ì¬ ì–¸ì–´
  return getResolvedLanguage();
}

/**
 * ì„¸ì…˜ ì–¸ì–´ë¥¼ ë³€ê²½í•©ë‹ˆë‹¤.
 *
 * U-044: ì–¸ì–´ ë³€ê²½ì€ ì„¸ì…˜ ê²½ê³„ì—ì„œë§Œ í—ˆìš© (í† ê¸€=ë¦¬ì…‹ ì •ì±…).
 * ì´ í•¨ìˆ˜ëŠ” i18n ì–¸ì–´ë¥¼ ë³€ê²½í•˜ê³ , ì´í›„ startSessionFromProfile ì‹œ
 * ìƒˆ SaveGameì— í•´ë‹¹ ì–¸ì–´ê°€ ì €ì¥ë©ë‹ˆë‹¤.
 *
 * ì£¼ì˜: playing ìƒíƒœì—ì„œëŠ” ì´ í•¨ìˆ˜ë¥¼ í˜¸ì¶œí•˜ì§€ ë§ˆì„¸ìš”.
 * ì–¸ì–´ ë³€ê²½ì€ profile_selectì—ì„œë§Œ í—ˆìš©ë©ë‹ˆë‹¤.
 *
 * @param language - ë³€ê²½í•  ì–¸ì–´
 */
export async function setSessionLanguage(language: SupportedLanguage): Promise<void> {
  await changeLanguage(language);
}

/**
 * ì´ˆê¸° ì„¸ì…˜ ì–¸ì–´ë¥¼ ê²°ì •í•©ë‹ˆë‹¤.
 *
 * U-044: ì•± ë¶€íŒ… ì‹œ ì‚¬ìš©í•©ë‹ˆë‹¤.
 * - ìœ íš¨í•œ SaveGameì´ ìˆìœ¼ë©´ í•´ë‹¹ ì–¸ì–´
 * - ì—†ìœ¼ë©´ DEFAULT_LANGUAGE
 *
 * @returns ì´ˆê¸° ì„¸ì…˜ ì–¸ì–´
 */
export function getInitialSessionLanguage(): SupportedLanguage {
  const validSaveGame = getValidSaveGameOrNull();
  if (validSaveGame?.language) {
    return validSaveGame.language as SupportedLanguage;
  }
  return DEFAULT_LANGUAGE;
}
</file>

<file path="frontend/src/stores/inventoryStore.test.ts">
import { describe, it, expect, beforeEach } from 'vitest';
import { useInventoryStore, parseInventoryAdded } from './inventoryStore';

describe('inventoryStore', () => {
  beforeEach(() => {
    useInventoryStore.getState().reset();
  });

  it('ì´ˆê¸° ìƒíƒœëŠ” ë¹„ì–´ ìˆì–´ì•¼ í•œë‹¤', () => {
    const state = useInventoryStore.getState();
    expect(state.items).toEqual([]);
    expect(state.draggingItemId).toBeNull();
    expect(state.selectedItemId).toBeNull();
  });

  it('addItems: ìƒˆ ì•„ì´í…œì„ ì¶”ê°€í•  ìˆ˜ ìˆì–´ì•¼ í•œë‹¤', () => {
    const { addItems } = useInventoryStore.getState();
    const newItem = { id: 'item1', name: 'Item 1', quantity: 1 };

    addItems([newItem]);

    const state = useInventoryStore.getState();
    expect(state.items).toHaveLength(1);
    expect(state.items[0]).toEqual(newItem);
  });

  it('addItems: ì¤‘ë³µëœ IDì˜ ì•„ì´í…œ ì¶”ê°€ ì‹œ ìˆ˜ëŸ‰ì´ ì¦ê°€í•´ì•¼ í•œë‹¤', () => {
    const { addItems } = useInventoryStore.getState();
    const item1 = { id: 'item1', name: 'Item 1', quantity: 1 };

    addItems([item1]);
    addItems([{ id: 'item1', name: 'Item 1', quantity: 2 }]);

    const state = useInventoryStore.getState();
    expect(state.items).toHaveLength(1);
    expect(state.items[0].quantity).toBe(3);
  });

  it('removeItems: ì•„ì´í…œì„ ì œê±°í•  ìˆ˜ ìˆì–´ì•¼ í•œë‹¤', () => {
    const { addItems, removeItems } = useInventoryStore.getState();
    addItems([
      { id: 'item1', name: 'Item 1', quantity: 1 },
      { id: 'item2', name: 'Item 2', quantity: 1 },
    ]);

    removeItems(['item1']);

    const state = useInventoryStore.getState();
    expect(state.items).toHaveLength(1);
    expect(state.items[0].id).toBe('item2');
  });

  it('removeItems: ì œê±°ëœ ì•„ì´í…œì´ ì„ íƒ/ë“œë˜ê·¸ ì¤‘ì´ë©´ ì´ˆê¸°í™”í•´ì•¼ í•œë‹¤', () => {
    const { addItems, removeItems, selectItem, startDrag } = useInventoryStore.getState();
    addItems([{ id: 'item1', name: 'Item 1', quantity: 1 }]);

    selectItem('item1');
    startDrag('item1');

    removeItems(['item1']);

    const state = useInventoryStore.getState();
    expect(state.selectedItemId).toBeNull();
    expect(state.draggingItemId).toBeNull();
  });

  it('startDrag/endDrag: ë“œë˜ê·¸ ìƒíƒœë¥¼ ê´€ë¦¬í•´ì•¼ í•œë‹¤', () => {
    const { startDrag, endDrag } = useInventoryStore.getState();

    startDrag('item1');
    expect(useInventoryStore.getState().draggingItemId).toBe('item1');

    endDrag();
    expect(useInventoryStore.getState().draggingItemId).toBeNull();
  });

  it('parseInventoryAdded: InventoryItemData ë°°ì—´ì„ InventoryItem ë°°ì—´ë¡œ ë³€í™˜í•´ì•¼ í•œë‹¤ (U-075)', () => {
    const added = [
      { id: 'item-a', label: 'ì•„ì´í…œ A', description: 'ì„¤ëª… A', icon_url: null, quantity: 1 },
      {
        id: 'item-b',
        label: 'ì•„ì´í…œ B',
        description: 'ì„¤ëª… B',
        icon_url: '/static/icon.png',
        quantity: 2,
      },
    ];
    const parsed = parseInventoryAdded(added);

    expect(parsed).toHaveLength(2);
    expect(parsed[0]).toEqual({
      id: 'item-a',
      name: 'ì•„ì´í…œ A',
      description: 'ì„¤ëª… A',
      icon: undefined,
      quantity: 1,
      iconStatus: 'pending',
    });
    expect(parsed[1]).toEqual({
      id: 'item-b',
      name: 'ì•„ì´í…œ B',
      description: 'ì„¤ëª… B',
      icon: '/static/icon.png',
      quantity: 2,
      iconStatus: 'ready',
    });
  });
});
</file>

<file path="frontend/src/types/scene.ts">
/**
 * Scene Canvas ê´€ë ¨ íƒ€ì… ì •ì˜ (U-031: Placeholder Pack, U-020: Lazy Render)
 */

/**
 * Scene ì²˜ë¦¬ ë‹¨ê³„ íƒ€ì… (U-071: ë¡œë”© ì¸ë””ì¼€ì´í„° ê°•í™”)
 * - idle: ìœ íœ´ ìƒíƒœ (ì²˜ë¦¬ ì—†ìŒ)
 * - processing: í„´ ì²˜ë¦¬ ì¤‘ (í…ìŠ¤íŠ¸ ìŠ¤íŠ¸ë¦¬ë°)
 * - image_pending: ì´ë¯¸ì§€ ìƒì„± ëŒ€ê¸°/ì§„í–‰ ì¤‘
 * - rendering: ê²°ê³¼ ë Œë”ë§ ì¤‘
 */
export type SceneProcessingPhase = 'idle' | 'processing' | 'image_pending' | 'rendering';

/**
 * Scene Canvas ìƒíƒœ íƒ€ì…
 * - default: ê¸°ë³¸ ìƒíƒœ (ì¥ë©´ ì´ë¯¸ì§€ ì—†ìŒ)
 * - loading: ë°ì´í„° ë¡œë”© ì¤‘
 * - offline: ì˜¤í”„ë¼ì¸/ì—°ê²° ëŠê¹€
 * - blocked: ì•ˆì „/ì •ì±… ì°¨ë‹¨
 * - low_signal: ì¬í™”/ì‹ í˜¸ ë¶€ì¡±
 * - scene: ì •ìƒ ì¥ë©´ í‘œì‹œ (ì´ë¯¸ì§€ URL í¬í•¨)
 */
export type SceneCanvasStatus =
  | 'default'
  | 'loading'
  | 'offline'
  | 'blocked'
  | 'low_signal'
  | 'scene';

/**
 * ì´ë¯¸ì§€ ë¡œë”© ìƒíƒœ (U-020: Lazy Render)
 * - idle: ì´ë¯¸ì§€ ì—†ìŒ/ëŒ€ê¸°
 * - loading: ì´ë¯¸ì§€ ë¡œë”© ì¤‘
 * - loaded: ì´ë¯¸ì§€ ë¡œë“œ ì™„ë£Œ
 * - error: ì´ë¯¸ì§€ ë¡œë“œ ì‹¤íŒ¨
 */
export type ImageLoadingState = 'idle' | 'loading' | 'loaded' | 'error';

/**
 * Scene Canvas ìƒíƒœ ë°ì´í„° êµ¬ì¡°
 *
 * U-020[Mvp] í™•ì¥:
 * - imageLoading: ì´ë¯¸ì§€ ë¡œë”© ìƒíƒœ í”Œë˜ê·¸ (ë¡œë”© ì¸ë””ì¼€ì´í„° í‘œì‹œìš©)
 * - previousImageUrl: ì´ì „ ì´ë¯¸ì§€ URL (Option A: ì´ì „ ì´ë¯¸ì§€ ìœ ì§€)
 *
 * U-066[Mvp] í™•ì¥:
 * - sceneRevision: late-binding ê°€ë“œìš© í† í° (turnCount ê¸°ë°˜)
 * - pendingImageTurnId: ëŒ€ê¸° ì¤‘ì¸ ì´ë¯¸ì§€ ìš”ì²­ì˜ í„´ ID
 */
export interface SceneCanvasState {
  status: SceneCanvasStatus;
  imageUrl?: string;
  message?: string;
  /** U-020: ì´ë¯¸ì§€ ë¡œë”© ì¤‘ ì—¬ë¶€ (ë¡œë”© ì¸ë””ì¼€ì´í„° í‘œì‹œìš©) */
  imageLoading?: boolean;
  /** U-020: ì´ì „ ì´ë¯¸ì§€ URL (ìƒˆ ì´ë¯¸ì§€ ë¡œë”© ì¤‘ í‘œì‹œìš©) */
  previousImageUrl?: string;
  /** U-066: late-binding ê°€ë“œìš© í† í° (turnCount ê¸°ë°˜) */
  sceneRevision?: number;
  /** U-066: ëŒ€ê¸° ì¤‘ì¸ ì´ë¯¸ì§€ ìš”ì²­ì˜ í„´ ID */
  pendingImageTurnId?: number;
  /** U-071: í˜„ì¬ ì²˜ë¦¬ ë‹¨ê³„ (ë¡œë”© ì¸ë””ì¼€ì´í„° í‘œì‹œìš©) */
  processingPhase?: SceneProcessingPhase;
}

/**
 * ìƒíƒœë³„ placeholder ì •ë³´ êµ¬ì¡°
 */
export interface PlaceholderInfo {
  imagePath: string;
  fallbackEmoji: string;
  labelKey: string;
}
</file>

<file path="backend/src/unknown_world/api/turn.py">
"""Unknown World - /api/turn HTTP Streaming ì—”ë“œí¬ì¸íŠ¸.

POST ìš”ì²­ì„ ë°›ì•„ NDJSON(ë¼ì¸ ë‹¨ìœ„ JSON) ìŠ¤íŠ¸ë¦¬ë°ìœ¼ë¡œ í„´ ê²°ê³¼ë¥¼ ë°˜í™˜í•©ë‹ˆë‹¤.

ì„¤ê³„ ì›ì¹™:
    - RULE-003: êµ¬ì¡°í™” ì¶œë ¥(JSON Schema) ìš°ì„  + Pydantic ê²€ì¦
    - RULE-004: ê²€ì¦ ì‹¤íŒ¨ ì‹œ Repair loop + ì•ˆì „í•œ í´ë°±
    - RULE-005: ì¬í™” ì¸ë°”ë¦¬ì–¸íŠ¸ (ì”ì•¡ ìŒìˆ˜ ê¸ˆì§€)
    - RULE-007: í”„ë¡¬í”„íŠ¸/ë‚´ë¶€ ì¶”ë¡  ë…¸ì¶œ ê¸ˆì§€
    - RULE-008: ë‹¨ê³„/ë°°ì§€ ê°€ì‹œí™”, TTFB 2ì´ˆ ëª©í‘œ

ìŠ¤íŠ¸ë¦¼ ì´ë²¤íŠ¸ íƒ€ì…:
    - stage: ë‹¨ê³„ ì§„í–‰ ìƒíƒœ (Parseâ†’Validateâ†’Planâ†’Resolveâ†’Renderâ†’Verifyâ†’Commit)
    - badges: ê²€ì¦ ë°°ì§€ ëª©ë¡
    - narrative_delta: ë‚´ëŸ¬í‹°ë¸Œ í…ìŠ¤íŠ¸ ì¡°ê° (íƒ€ì íš¨ê³¼ìš©)
    - repair: Auto-repair ì´ë²¤íŠ¸ (U-018)
    - final: ìµœì¢… TurnOutput
    - error: ì—ëŸ¬ ë°œìƒ ì‹œ

ë¦¬íŒ©í† ë§ (RU-005-Q4):
    - ê¸°ì¡´ _stream_turn_events_mock/_realì„ pipeline ê¸°ë°˜ìœ¼ë¡œ í†µí•©
    - API ë ˆì´ì–´ëŠ” ìŠ¤íŠ¸ë¦¬ë° ì§ë ¬í™”/ì „ì†¡ì— ì§‘ì¤‘
    - ì˜¤ì¼€ìŠ¤íŠ¸ë ˆì´ì…˜ ë¡œì§ì€ pipeline.pyë¡œ ìœ„ì„

ì°¸ì¡°:
    - vibe/unit-plans/U-007[Mvp].md
    - vibe/unit-plans/U-018[Mvp].md
    - vibe/refactors/RU-005-Q4.md
    - .cursor/rules/20-backend-orchestrator.mdc
"""

from __future__ import annotations

import asyncio
import contextlib
import time
from collections.abc import AsyncGenerator
from typing import Any, cast

from fastapi import APIRouter, Request
from fastapi.responses import StreamingResponse
from pydantic import ValidationError

from unknown_world.api.turn_stream_events import (
    BadgesEvent,
    NarrativeDeltaEvent,
    RepairEvent,
    StageEvent,
    StageStatus,
    StreamEventType,
    serialize_event,
)
from unknown_world.api.turn_streaming_helpers import (
    emit_error_with_fallback,
    stream_output_with_narrative,
)
from unknown_world.models.turn import (
    CurrencyAmount,
    Language,
    TurnInput,
)
from unknown_world.orchestrator.fallback import create_safe_fallback
from unknown_world.orchestrator.pipeline import create_pipeline_context, run_pipeline
from unknown_world.orchestrator.repair_loop import MAX_REPAIR_ATTEMPTS
from unknown_world.orchestrator.stages.types import (
    PipelineEvent,
    PipelineEventType,
)

# =============================================================================
# ë¼ìš°í„° ì •ì˜
# =============================================================================

router = APIRouter(prefix="/api", tags=["Turn"])


# =============================================================================
# Pipeline Event â†’ Stream Event ë³€í™˜
# =============================================================================


def _convert_pipeline_event(event: PipelineEvent) -> dict[str, Any] | None:
    """íŒŒì´í”„ë¼ì¸ ì´ë²¤íŠ¸ë¥¼ ìŠ¤íŠ¸ë¦¼ ì´ë²¤íŠ¸ë¡œ ë³€í™˜í•©ë‹ˆë‹¤.

    Args:
        event: íŒŒì´í”„ë¼ì¸ ë„ë©”ì¸ ì´ë²¤íŠ¸

    Returns:
        ìŠ¤íŠ¸ë¦¼ ì´ë²¤íŠ¸ dict (serialize_eventì— ì „ë‹¬) ë˜ëŠ” None
    """
    if event.event_type == PipelineEventType.STAGE_START:
        if event.phase is None:
            return None
        return StageEvent(
            type=StreamEventType.STAGE,
            name=event.phase.value,
            status=StageStatus.START,
        ).model_dump()

    if event.event_type == PipelineEventType.STAGE_COMPLETE:
        if event.phase is None:
            return None
        return StageEvent(
            type=StreamEventType.STAGE,
            name=event.phase.value,
            status=StageStatus.COMPLETE,
        ).model_dump()

    if event.event_type == PipelineEventType.STAGE_FAIL:
        if event.phase is None:
            return None
        return StageEvent(
            type=StreamEventType.STAGE,
            name=event.phase.value,
            status=StageStatus.FAIL,
        ).model_dump()

    if event.event_type == PipelineEventType.BADGES:
        if event.badges is None:
            return None
        return BadgesEvent(
            type=StreamEventType.BADGES,
            badges=[b.value for b in event.badges],
        ).model_dump()

    if event.event_type == PipelineEventType.REPAIR:
        return RepairEvent(
            type=StreamEventType.REPAIR,
            attempt=event.repair_attempt,
            message=event.repair_message,
        ).model_dump()

    if event.event_type == PipelineEventType.NARRATIVE_DELTA:
        if event.text is None:
            return None
        return NarrativeDeltaEvent(
            type=StreamEventType.NARRATIVE_DELTA,
            text=event.text,
        ).model_dump()

    return None


# =============================================================================
# ìŠ¤íŠ¸ë¦¬ë° ìƒì„±ê¸°
# =============================================================================


async def _stream_turn_events(
    turn_input: TurnInput, seed: int | None = None
) -> AsyncGenerator[str]:
    """í„´ ì²˜ë¦¬ ì´ë²¤íŠ¸ë¥¼ NDJSON ìŠ¤íŠ¸ë¦¼ìœ¼ë¡œ ìƒì„±í•©ë‹ˆë‹¤.

    Pipelineì„ ì‹¤í–‰í•˜ê³ , ë„ë©”ì¸ ì´ë²¤íŠ¸ë¥¼ ìŠ¤íŠ¸ë¦¼ ì´ë²¤íŠ¸ë¡œ ë³€í™˜í•˜ì—¬ ì „ì†¡í•©ë‹ˆë‹¤.

    Args:
        turn_input: ì‚¬ìš©ì í„´ ì…ë ¥
        seed: Mock ëª¨ë“œ ì‹œë“œ (ì¬í˜„ì„± ë³´ì¥)

    Yields:
        str: NDJSON ë¼ì¸
    """
    # ì´ë²¤íŠ¸ í (emit ì½œë°±ì—ì„œ ì´ë²¤íŠ¸ë¥¼ ìŒ“ê³ , ë©”ì¸ ë£¨í”„ì—ì„œ ì†Œë¹„)
    event_queue: asyncio.Queue[PipelineEvent | None] = asyncio.Queue()

    async def emit(event: PipelineEvent) -> None:
        """íŒŒì´í”„ë¼ì¸ ì´ë²¤íŠ¸ë¥¼ íì— ì¶”ê°€í•©ë‹ˆë‹¤."""
        await event_queue.put(event)

    # Pipeline ì»¨í…ìŠ¤íŠ¸ ìƒì„±
    ctx = create_pipeline_context(turn_input, seed=seed)

    # Pipeline ì‹¤í–‰ì„ ë°±ê·¸ë¼ìš´ë“œ íƒœìŠ¤í¬ë¡œ ì‹œì‘
    async def run_pipeline_task() -> None:
        nonlocal ctx
        try:
            ctx = await run_pipeline(ctx, emit=emit)
        except asyncio.CancelledError:
            # RU-005-S2: í´ë¼ì´ì–¸íŠ¸ Abort ì‹œ íƒœìŠ¤í¬ë„ ì·¨ì†Œë¨
            # - í´ë°± ìƒì„± ì—†ì´ ì¦‰ì‹œ ì¢…ë£Œ (í”„ë¡ íŠ¸ ì •ì±…ê³¼ ë§ì¶¤)
            raise  # finally ë¸”ë¡ì€ ì‹¤í–‰, ì¢…ë£Œ ì‹ í˜¸ë§Œ ë³´ëƒ„
        except Exception:
            # ì˜ˆì™¸ ë°œìƒ ì‹œ í´ë°± (RULE-004)
            ctx.output = create_safe_fallback(
                language=turn_input.language,
                economy_snapshot=ctx.economy_snapshot,
                repair_count=ctx.repair_attempts,
            )
            ctx.is_fallback = True
        finally:
            # ì¢…ë£Œ ì‹ í˜¸ (CancelledError í¬í•¨ ëª¨ë“  ê²½ìš°ì— ì „ì†¡)
            await event_queue.put(None)

    pipeline_task = asyncio.create_task(run_pipeline_task())

    # ì´ë²¤íŠ¸ ì†Œë¹„ ë£¨í”„
    try:
        while True:
            event = await event_queue.get()
            if event is None:
                # Pipeline ì¢…ë£Œ
                break

            stream_event = _convert_pipeline_event(event)
            if stream_event is not None:
                yield serialize_event(stream_event)

        # Pipeline ì™„ë£Œ í›„ ë‚´ëŸ¬í‹°ë¸Œ + final ì „ì†¡ (RU-005-Q3: í—¬í¼ ì‚¬ìš©)
        if ctx.output is not None:
            async for line in stream_output_with_narrative(ctx.output):
                yield line

    except asyncio.CancelledError:
        # RU-005-S2: í´ë¼ì´ì–¸íŠ¸ Abort(ì—°ê²° ì·¨ì†Œ) ì‹œ ì¡°ìš©íˆ ì¢…ë£Œ
        # - ì¶”ê°€ ì´ë²¤íŠ¸(error/final) ì†¡ì¶œí•˜ì§€ ì•ŠìŒ
        # - ë¡œê·¸ë„ noisyí•˜ì§€ ì•Šê²Œ ë‚¨ê¸°ì§€ ì•ŠìŒ (í”„ë¡ íŠ¸ ì •ì±…ê³¼ ë§ì¶¤)
        pass

    except Exception:
        # ì˜ˆì™¸ ë°œìƒ ì‹œ error + final(í´ë°±) ìˆœì„œë¡œ ì†¡ì¶œ (RULE-004, RU-005-Q3: í—¬í¼ ì‚¬ìš©)
        async for line in emit_error_with_fallback(
            turn_input.language,
            economy_snapshot=ctx.economy_snapshot,
            repair_count=MAX_REPAIR_ATTEMPTS,
        ):
            yield line

    finally:
        # Pipeline íƒœìŠ¤í¬ ì •ë¦¬
        if not pipeline_task.done():
            pipeline_task.cancel()
            with contextlib.suppress(asyncio.CancelledError):
                await pipeline_task


# =============================================================================
# ì…ë ¥ ê²€ì¦
# =============================================================================


async def _validate_and_parse_input(request: Request) -> TurnInput | dict[str, Any]:
    """ìš”ì²­ ë³¸ë¬¸ì„ TurnInputìœ¼ë¡œ ê²€ì¦ ë° íŒŒì‹±í•©ë‹ˆë‹¤.

    Returns:
        TurnInput ë˜ëŠ” ì—ëŸ¬ ì •ë³´ dict (language, economy_snapshot í¬í•¨)
    """
    body: dict[str, Any] | None = None
    try:
        body = await request.json()
        return TurnInput.model_validate(body)
    except ValidationError as e:
        # RU-002-S1: ì…ë ¥ ê²€ì¦ ì‹¤íŒ¨ ì‹œì—ë„ language/economy ì¶”ì¶œ ì‹œë„
        raw_language = body.get("language") if isinstance(body, dict) else None
        raw_economy = body.get("economy_snapshot") if isinstance(body, dict) else None
        return {
            "error": True,
            "message": "Invalid input",
            "details": e.errors(),
            "language": raw_language if raw_language in ("ko-KR", "en-US") else "ko-KR",
            "economy_snapshot": raw_economy,
        }
    except Exception:
        return {
            "error": True,
            "message": "Failed to parse request body",
            "details": None,
            "language": "ko-KR",
            "economy_snapshot": None,
        }


# =============================================================================
# API ì—”ë“œí¬ì¸íŠ¸
# =============================================================================


@router.post(
    "/turn",
    response_class=StreamingResponse,
    summary="í„´ ì²˜ë¦¬ (HTTP Streaming)",
    description="""
í„´ ì…ë ¥ì„ ë°›ì•„ NDJSON ìŠ¤íŠ¸ë¦¬ë°ìœ¼ë¡œ ê²°ê³¼ë¥¼ ë°˜í™˜í•©ë‹ˆë‹¤.

**ìŠ¤íŠ¸ë¦¼ ì´ë²¤íŠ¸ íƒ€ì…**:
- `stage`: ì²˜ë¦¬ ë‹¨ê³„ ì§„í–‰ ìƒíƒœ
- `badges`: ê²€ì¦ ë°°ì§€ ëª©ë¡
- `narrative_delta`: ë‚´ëŸ¬í‹°ë¸Œ í…ìŠ¤íŠ¸ ì¡°ê° (íƒ€ì íš¨ê³¼)
- `final`: ìµœì¢… TurnOutput
- `error`: ì—ëŸ¬ ë°œìƒ ì‹œ

**ì˜ˆì‹œ ìš”ì²­**:
```json
{
    "language": "ko-KR",
    "text": "ë¬¸ì„ ì—´ì–´ë³¸ë‹¤",
    "client": {"viewport_w": 1920, "viewport_h": 1080, "theme": "dark"},
    "economy_snapshot": {"signal": 100, "memory_shard": 5}
}
```
""",
    responses={
        200: {
            "description": "NDJSON ìŠ¤íŠ¸ë¦¼",
            "content": {
                "application/x-ndjson": {
                    "example": '{"type":"stage","name":"parse","status":"start"}\n'
                }
            },
        },
        400: {"description": "ì˜ëª»ëœ ìš”ì²­"},
    },
)
async def turn_stream(request: Request) -> StreamingResponse:
    """í„´ ì²˜ë¦¬ HTTP Streaming ì—”ë“œí¬ì¸íŠ¸.

    POST ìš”ì²­ìœ¼ë¡œ TurnInputì„ ë°›ì•„ NDJSON ìŠ¤íŠ¸ë¦¬ë°ìœ¼ë¡œ ê²°ê³¼ë¥¼ ë°˜í™˜í•©ë‹ˆë‹¤.
    TTFBë¥¼ ì¤„ì´ê¸° ìœ„í•´ ì²« stage ì´ë²¤íŠ¸ë¥¼ ì¦‰ì‹œ ì „ì†¡í•©ë‹ˆë‹¤.

    Args:
        request: FastAPI Request ê°ì²´

    Returns:
        StreamingResponse: NDJSON ìŠ¤íŠ¸ë¦¼
    """
    # ì…ë ¥ ê²€ì¦
    parse_result = await _validate_and_parse_input(request)

    if isinstance(parse_result, dict) and parse_result.get("error"):
        # RU-002-S1: ì…ë ¥ ê²€ì¦ ì‹¤íŒ¨ ì‹œì—ë„ error + final(í´ë°±) ìˆœì„œë¡œ ì†¡ì¶œ
        error_language = parse_result.get("language", "ko-KR")
        error_economy = parse_result.get("economy_snapshot")

        # economy_snapshotì´ ìœ íš¨í•œì§€ í™•ì¸
        economy_snapshot: CurrencyAmount | None = None
        if isinstance(error_economy, dict):
            try:
                # ëª…ì‹œì  íƒ€ì… ìºìŠ¤íŒ…ìœ¼ë¡œ Pyright ê²½ê³  í•´ì†Œ
                eco_dict = cast(dict[str, Any], error_economy)
                economy_snapshot = CurrencyAmount(
                    signal=int(eco_dict.get("signal", 100)),
                    memory_shard=int(eco_dict.get("memory_shard", 5)),
                )
            except (ValueError, TypeError):
                economy_snapshot = None

        async def error_stream() -> AsyncGenerator[str]:
            # RU-005-Q3: í—¬í¼ë¥¼ ì‚¬ìš©í•˜ì—¬ error + final(í´ë°±) ì†¡ì¶œ
            async for line in emit_error_with_fallback(
                Language.KO if error_language == "ko-KR" else Language.EN,
                error_message=parse_result.get("message", "Invalid input"),
                error_code="VALIDATION_ERROR",
                economy_snapshot=economy_snapshot,
                repair_count=0,
            ):
                yield line

        return StreamingResponse(
            error_stream(),
            media_type="application/x-ndjson",
            headers={
                "Cache-Control": "no-cache",
                "X-Accel-Buffering": "no",  # nginx ë²„í¼ë§ ë¹„í™œì„±í™”
            },
        )

    turn_input: TurnInput = parse_result  # type: ignore[assignment]

    # ì‹œë“œ ì¶”ì¶œ (ì¿¼ë¦¬ íŒŒë¼ë¯¸í„°ì—ì„œ, í…ŒìŠ¤íŠ¸/ì¬í˜„ìš©)
    seed_param = request.query_params.get("seed")
    seed = int(seed_param) if seed_param else None

    # NDJSON ìŠ¤íŠ¸ë¦¬ë° ì‘ë‹µ
    return StreamingResponse(
        _stream_turn_events(turn_input, seed=seed),
        media_type="application/x-ndjson",
        headers={
            "Cache-Control": "no-cache",
            "X-Accel-Buffering": "no",  # nginx ë²„í¼ë§ ë¹„í™œì„±í™”
            "X-Request-Time": str(int(time.time() * 1000)),
        },
    )
</file>

<file path="backend/src/unknown_world/config/models.py">
"""Unknown World - ëª¨ë¸ ë¼ë²¨ ë° ID ìƒìˆ˜ ì •ì˜.

ì´ ëª¨ë“ˆì€ Gemini ëª¨ë¸ IDì™€ ë¼ë²¨ì„ SSOTë¡œ ê´€ë¦¬í•©ë‹ˆë‹¤.
tech-stack.md ê¸°ì¤€ìœ¼ë¡œ ë²„ì „/ëª¨ë¸ IDê°€ ê³ ì •ë˜ì–´ ìˆìœ¼ë©°,
ì„ì˜ ë³€ê²½ì€ RULE-010 ìœ„ë°˜ì…ë‹ˆë‹¤.

ëª¨ë¸ ë¼ì¸ì—… (tech-stack.md ê¸°ì¤€):
    - í…ìŠ¤íŠ¸ FAST: gemini-3-flash-preview
    - í…ìŠ¤íŠ¸ QUALITY: gemini-3-pro-preview
    - ì´ë¯¸ì§€(ìƒì„±/í¸ì§‘): gemini-3-pro-image-preview (ê³ ì •)

ì°¸ì¡°:
    - vibe/tech-stack.md (ë²„ì „ ê¸°ì¤€ì¼: 2026-01-01)
    - .cursor/rules/00-core-critical.mdc (RULE-007/010)
"""

from enum import StrEnum
from typing import Final


class ModelLabel(StrEnum):
    """ëª¨ë¸ ë¼ë²¨ ì—´ê±°í˜•.

    UI/ë¡œê·¸ì—ëŠ” ëª¨ë¸ ID ì›ë¬¸ ëŒ€ì‹  ì´ ë¼ë²¨ì„ ìš°ì„  ë…¸ì¶œí•©ë‹ˆë‹¤. (RULE-008)
    """

    FAST = "FAST"
    """ë¹ ë¥¸ ì‘ë‹µìš© í…ìŠ¤íŠ¸ ëª¨ë¸ (gemini-3-flash-preview)"""

    QUALITY = "QUALITY"
    """ê³ í’ˆì§ˆ í…ìŠ¤íŠ¸ ëª¨ë¸ (gemini-3-pro-preview)"""

    IMAGE = "IMAGE"
    """ì´ë¯¸ì§€ ìƒì„±/í¸ì§‘ ëª¨ë¸ (gemini-3-pro-image-preview, ê³ ì •)"""

    IMAGE_FAST = "IMAGE_FAST"
    """ì €ì§€ì—° ì´ë¯¸ì§€ í”„ë¦¬ë·° ëª¨ë¸ (gemini-2.5-flash-image, U-066)"""

    VISION = "VISION"
    """ë¹„ì „/ê³µê°„ ë¶„ì„ ëª¨ë¸ (bbox/segmentationìš©, gemini-3-flash-preview)"""


# =============================================================================
# ëª¨ë¸ ID ìƒìˆ˜ (tech-stack.md SSOT)
# =============================================================================
# ì£¼ì˜: ì´ ê°’ë“¤ì€ tech-stack.mdì™€ 1:1ë¡œ ì¼ì¹˜í•´ì•¼ í•©ë‹ˆë‹¤.
# ì„ì˜ ë³€ê²½ ê¸ˆì§€ (RULE-010)

MODEL_FAST: Final[str] = "gemini-3-flash-preview"
"""FAST ë¼ë²¨ ëª¨ë¸ ID - ë¹ ë¥¸ í…ìŠ¤íŠ¸ ìƒì„±ìš©"""

MODEL_QUALITY: Final[str] = "gemini-3-pro-preview"
"""QUALITY ë¼ë²¨ ëª¨ë¸ ID - ê³ í’ˆì§ˆ í…ìŠ¤íŠ¸ ìƒì„±ìš©"""

MODEL_IMAGE: Final[str] = "gemini-3-pro-image-preview"
"""IMAGE ë¼ë²¨ ëª¨ë¸ ID - ì´ë¯¸ì§€ ìƒì„±/í¸ì§‘ìš© (ê³ ì •, RULE-010)"""

MODEL_IMAGE_FAST: Final[str] = "gemini-2.5-flash-image"
"""IMAGE_FAST ë¼ë²¨ ëª¨ë¸ ID - ì €ì§€ì—° ì´ë¯¸ì§€ í”„ë¦¬ë·°ìš© (U-066)"""

MODEL_VISION: Final[str] = "gemini-3-flash-preview"
"""VISION ë¼ë²¨ ëª¨ë¸ ID - ë¹„ì „/ê³µê°„ ë¶„ì„ìš© (bbox/segmentation)"""


# =============================================================================
# í…ìŠ¤íŠ¸ ëª¨ë¸ í‹°ì–´ë§ ì„¤ì • (U-069)
# =============================================================================
# Q1 ê²°ì •: Option B - ì•¡ì…˜ ID + í‚¤ì›Œë“œ ë§¤ì¹­


class TextModelTiering:
    """í…ìŠ¤íŠ¸ ëª¨ë¸ í‹°ì–´ë§ ì„¤ì •.

    FAST ëª¨ë¸ ê¸°ë³¸ + "ì •ë°€ì¡°ì‚¬" íŠ¸ë¦¬ê±° ì‹œ QUALITY ëª¨ë¸ ì „í™˜.

    í˜ì–´ë§ ì§ˆë¬¸ ê²°ì •:
        - Q1: Option B - ì•¡ì…˜ ID + í‚¤ì›Œë“œ ë§¤ì¹­
        - Q2: Option A - 2x (ê¸°ë³¸ ë¹„ìš©ì˜ 2ë°°)
        - Q3: Option B + C - íŠ¹ì • ìƒí™© ë“±ì¥ + ì•„ì´í…œ í™œì„±í™”
    """

    # QUALITY íŠ¸ë¦¬ê±° ì•¡ì…˜ ID ëª©ë¡
    # "ì •ë°€ì¡°ì‚¬" ë° ê´€ë ¨ ì•¡ì…˜
    QUALITY_TRIGGER_ACTION_IDS: Final[frozenset[str]] = frozenset(
        {
            "deep_investigate",
            "ì •ë°€ì¡°ì‚¬",
            "analyze",
            "examine_closely",
            "investigate_detail",
            "scrutinize",
            "thorough_search",
            # ë‹ë³´ê¸° ì•„ì´í…œ ì‚¬ìš© ì•¡ì…˜ (Q3 ê²°ì •: Option C)
            "use_magnifier",
            "use_magnifying_glass",
        }
    )

    # U-076: "ì •ë°€ë¶„ì„" íŠ¸ë¦¬ê±° ì•¡ì…˜ ID ëª©ë¡ (Agentic Vision)
    # QUALITY íŠ¸ë¦¬ê±°ì™€ ë³„ë„ ê´€ë¦¬ (ë‹¤ë¥¸ ë¹„ìš© ì •ì±…: 1.5x)
    VISION_TRIGGER_ACTION_IDS: Final[frozenset[str]] = frozenset(
        {
            "deep_analyze",
            "ì •ë°€ë¶„ì„",
            "analyze_scene",
            "examine_scene",
            "look_closely",
        }
    )

    # U-076: ë¹„ì „ ë¶„ì„ ë¹„ìš© ë°°ìˆ˜ (Q2 ê²°ì •: Option B - 1.5x)
    VISION_COST_MULTIPLIER: Final[float] = 1.5
    """ë¹„ì „ ë¶„ì„(ì •ë°€ë¶„ì„) ë¹„ìš© ë°°ìˆ˜"""

    # QUALITY íŠ¸ë¦¬ê±° í‚¤ì›Œë“œ ëª©ë¡ (ì†Œë¬¸ì)
    # Q1 ê²°ì •: Option B - í‚¤ì›Œë“œ ë§¤ì¹­ í¬í•¨
    QUALITY_TRIGGER_KEYWORDS: Final[tuple[str, ...]] = (
        "ì •ë°€ì¡°ì‚¬",
        "ìì„¸íˆ",
        "ê¹Šì´",
        "ê¼¼ê¼¼íˆ",
        "ë©´ë°€íˆ",
        "ì„¸ë°€í•˜ê²Œ",
        "thoroughly",
        "in detail",
        "closely examine",
        "scrutinize",
    )

    # U-076: ë¹„ì „ ë¶„ì„(ì •ë°€ë¶„ì„) íŠ¸ë¦¬ê±° í‚¤ì›Œë“œ (ì†Œë¬¸ì)
    VISION_TRIGGER_KEYWORDS: Final[tuple[str, ...]] = (
        "ì •ë°€ë¶„ì„",
        "ì¥ë©´ ë¶„ì„",
        "ì´ë¯¸ì§€ ë¶„ì„",
        "ìì„¸íˆ ë³´ê¸°",
        "analyze scene",
        "deep analyze",
        "look closely",
        "examine scene",
    )

    # ë¹„ìš© ë°°ìˆ˜ (Q2 ê²°ì •: Option A - 2x)
    FAST_COST_MULTIPLIER: Final[float] = 1.0
    """FAST ëª¨ë¸ ë¹„ìš© ë°°ìˆ˜ (ê¸°ë³¸)"""

    QUALITY_COST_MULTIPLIER: Final[float] = 2.0
    """QUALITY ëª¨ë¸ ë¹„ìš© ë°°ìˆ˜ (Q2 ê²°ì •: Option A - 2x)"""

    @classmethod
    def is_vision_trigger(
        cls,
        action_id: str | None,
        text: str | None,
    ) -> bool:
        """ë¹„ì „ ë¶„ì„(ì •ë°€ë¶„ì„) íŠ¸ë¦¬ê±° ì—¬ë¶€ë¥¼ íŒë‹¨í•©ë‹ˆë‹¤ (U-076).

        Args:
            action_id: ì„ íƒëœ ì•¡ì…˜ ID (ì„ íƒ)
            text: ì‚¬ìš©ì ì…ë ¥ í…ìŠ¤íŠ¸ (ì„ íƒ)

        Returns:
            ì •ë°€ë¶„ì„(ë¹„ì „ ë¶„ì„)ì„ ì‹¤í–‰í•´ì•¼ í•˜ëŠ”ì§€ ì—¬ë¶€
        """
        # ì•¡ì…˜ ID ê²€ì‚¬
        if action_id and action_id in cls.VISION_TRIGGER_ACTION_IDS:
            return True

        # í‚¤ì›Œë“œ ê²€ì‚¬ (ëŒ€ì†Œë¬¸ì ë¬´ì‹œ)
        if text:
            text_lower = text.lower()
            for keyword in cls.VISION_TRIGGER_KEYWORDS:
                if keyword.lower() in text_lower:
                    return True

        return False

    @classmethod
    def is_quality_trigger(
        cls,
        action_id: str | None,
        text: str | None,
    ) -> bool:
        """QUALITY ëª¨ë¸ íŠ¸ë¦¬ê±° ì—¬ë¶€ë¥¼ íŒë‹¨í•©ë‹ˆë‹¤.

        Args:
            action_id: ì„ íƒëœ ì•¡ì…˜ ID (ì„ íƒ)
            text: ì‚¬ìš©ì ì…ë ¥ í…ìŠ¤íŠ¸ (ì„ íƒ)

        Returns:
            QUALITY ëª¨ë¸ì„ ì‚¬ìš©í•´ì•¼ í•˜ëŠ”ì§€ ì—¬ë¶€
        """
        # ì•¡ì…˜ ID ê²€ì‚¬
        if action_id and action_id in cls.QUALITY_TRIGGER_ACTION_IDS:
            return True

        # í‚¤ì›Œë“œ ê²€ì‚¬ (ëŒ€ì†Œë¬¸ì ë¬´ì‹œ)
        if text:
            text_lower = text.lower()
            for keyword in cls.QUALITY_TRIGGER_KEYWORDS:
                if keyword.lower() in text_lower:
                    return True

        return False

    @classmethod
    def get_cost_multiplier(cls, model_label: ModelLabel) -> float:
        """ëª¨ë¸ ë¼ë²¨ì— ë”°ë¥¸ ë¹„ìš© ë°°ìˆ˜ë¥¼ ë°˜í™˜í•©ë‹ˆë‹¤.

        Args:
            model_label: ëª¨ë¸ ë¼ë²¨ (FAST, QUALITY)

        Returns:
            ë¹„ìš© ë°°ìˆ˜
        """
        if model_label == ModelLabel.QUALITY:
            return cls.QUALITY_COST_MULTIPLIER
        return cls.FAST_COST_MULTIPLIER


# ë¼ë²¨-ID ë§¤í•‘ í…Œì´ë¸”
_MODEL_MAP: Final[dict[ModelLabel, str]] = {
    ModelLabel.FAST: MODEL_FAST,
    ModelLabel.QUALITY: MODEL_QUALITY,
    ModelLabel.IMAGE: MODEL_IMAGE,
    ModelLabel.IMAGE_FAST: MODEL_IMAGE_FAST,
    ModelLabel.VISION: MODEL_VISION,
}


def get_model_id(label: ModelLabel) -> str:
    """ë¼ë²¨ë¡œ ëª¨ë¸ IDë¥¼ ì¡°íšŒí•©ë‹ˆë‹¤.

    Args:
        label: ëª¨ë¸ ë¼ë²¨ (FAST, QUALITY, IMAGE, VISION)

    Returns:
        í•´ë‹¹ ë¼ë²¨ì— ë§¤í•‘ëœ ëª¨ë¸ ID ë¬¸ìì—´

    Example:
        >>> get_model_id(ModelLabel.FAST)
        'gemini-3-flash-preview'
    """
    return _MODEL_MAP[label]
</file>

<file path="backend/src/unknown_world/orchestrator/fallback.py">
"""Unknown World - ì•ˆì „í•œ í´ë°± TurnOutput ìƒì„±ê¸°.

ìµœì¢… ë³µêµ¬ ì‹¤íŒ¨ ì‹œì—ë„ UIê°€ ë¹ˆ í™”ë©´ì´ ë˜ì§€ ì•Šë„ë¡
ìŠ¤í‚¤ë§ˆë¥¼ ë§Œì¡±í•˜ëŠ” ì•ˆì „í•œ TurnOutputì„ ìƒì„±í•©ë‹ˆë‹¤.

ì„¤ê³„ ì›ì¹™:
    - RULE-004: ê²€ì¦ ì‹¤íŒ¨ ì‹œ ì•ˆì „í•œ í´ë°± ì œê³µ
    - RULE-005: ì¬í™” ì¸ë°”ë¦¬ì–¸íŠ¸ (ë¹„ìš© 0, ì”ì•¡ ìœ ì§€)
    - RULE-006: ko/en ì–¸ì–´ ì •ì±… ì¤€ìˆ˜

ì°¸ì¡°:
    - vibe/unit-plans/U-018[Mvp].md
    - vibe/prd.md 8.7 (TurnOutput ìŠ¤í‚¤ë§ˆ)
"""

from __future__ import annotations

from unknown_world.config.economy import LOW_BALANCE_THRESHOLD
from unknown_world.models.turn import (
    ActionCard,
    ActionDeck,
    AgentConsole,
    AgentPhase,
    CurrencyAmount,
    EconomyOutput,
    Language,
    RenderOutput,
    RiskLevel,
    SafetyOutput,
    TurnOutput,
    UIOutput,
    ValidationBadge,
    WorldDelta,
)

# =============================================================================
# í´ë°± ë©”ì‹œì§€ (i18n)
# =============================================================================

FALLBACK_MESSAGES = {
    Language.KO: {
        "narrative": "ì ì‹œ í˜¼ë€ìŠ¤ëŸ¬ìš´ ìˆœê°„ì´ ì§€ë‚˜ê°‘ë‹ˆë‹¤. ë‹¤ì‹œ ì§‘ì¤‘í•´ë´…ì‹œë‹¤.",
        "narrative_blocked": "ì•ˆì „ ì •ì±…ì— ë”°ë¼ ì´ ìš”ì²­ì„ ì²˜ë¦¬í•  ìˆ˜ ì—†ìŠµë‹ˆë‹¤. ë‹¤ë¥¸ í–‰ë™ì„ ì‹œë„í•´ë³´ì„¸ìš”.",
        "alternative_label": "í…ìŠ¤íŠ¸ë¡œ ì§„í–‰í•˜ê¸°",
        "alternative_desc": "ì´ë¯¸ì§€ ìƒì„± ì—†ì´ ì €ë¹„ìš©ìœ¼ë¡œ ì§„í–‰í•©ë‹ˆë‹¤",
    },
    Language.EN: {
        "narrative": "A moment of confusion passes. Let's focus again.",
        "narrative_blocked": "This request cannot be processed due to safety policies. Please try a different action.",
        "alternative_label": "Continue with text",
        "alternative_desc": "Proceed at low cost without image generation",
    },
}


# =============================================================================
# í´ë°± ìƒì„± í•¨ìˆ˜
# =============================================================================


def create_safe_fallback(
    language: Language,
    economy_snapshot: CurrencyAmount | None = None,
    repair_count: int = 0,
    is_blocked: bool = False,
) -> TurnOutput:
    """ì•ˆì „í•œ í´ë°± TurnOutputì„ ìƒì„±í•©ë‹ˆë‹¤.

    ìµœì¢… ë³µêµ¬ ì‹¤íŒ¨ ì‹œ ì‚¬ìš©í•©ë‹ˆë‹¤.
    ìŠ¤í‚¤ë§ˆë¥¼ ë§Œì¡±í•˜ê³ , ë¹„ìš© 0ìœ¼ë¡œ ì”ì•¡ì„ ìœ ì§€í•©ë‹ˆë‹¤.

    Args:
        language: ì‘ë‹µ ì–¸ì–´
        economy_snapshot: í˜„ì¬ ì¬í™” ìƒíƒœ (ë¹„ìš© 0ìœ¼ë¡œ ìœ ì§€)
        repair_count: ë³µêµ¬ ì‹œë„ íšŸìˆ˜
        is_blocked: ì•ˆì „ ì •ì±…ì— ì˜í•´ ì°¨ë‹¨ë˜ì—ˆëŠ”ì§€

    Returns:
        ì•ˆì „í•œ í´ë°± TurnOutput

    Example:
        >>> fallback = create_safe_fallback(
        ...     language=Language.KO,
        ...     economy_snapshot=CurrencyAmount(signal=50, memory_shard=3),
        ...     repair_count=2,
        ... )
        >>> print(fallback.narrative)
    """
    messages = FALLBACK_MESSAGES[language]

    # ë‚´ëŸ¬í‹°ë¸Œ ì„ íƒ
    narrative = messages["narrative_blocked"] if is_blocked else messages["narrative"]

    # ì¬í™” ìœ ì§€ (ë¹„ìš© 0)
    balance = economy_snapshot or CurrencyAmount(signal=100, memory_shard=5)

    # ì €ë¹„ìš© ëŒ€ì•ˆ ì¹´ë“œ ì œê³µ (RULE-005)
    # U-065: description í•„ë“œ ì œê±°ë¨ (narrativeì—ì„œ ìì—°ì–´ë¡œ í‘œí˜„)
    alternative_card = ActionCard(
        id="fallback_text_only",
        label=messages["alternative_label"],
        cost=CurrencyAmount(signal=1, memory_shard=0),
        risk=RiskLevel.LOW,
        enabled=True,
        is_alternative=True,
    )

    # ë°°ì§€ ê²°ì • (RU-005-S1: í´ë°±ì—ì„œë„ ëª¨ë“  ì¹´í…Œê³ ë¦¬ì˜ ë°°ì§€ë¥¼ ì¼ê´€ë˜ê²Œ ì„¤ì •)
    badges: list[ValidationBadge] = []

    # Schema: í´ë°±ì´ë¯€ë¡œ SCHEMA_FAIL (ë‹¨, ì•ˆì „ ì°¨ë‹¨ì€ ìŠ¤í‚¤ë§ˆ ë¬¸ì œê°€ ì•„ë‹˜)
    if not is_blocked:
        badges.append(ValidationBadge.SCHEMA_FAIL)
    else:
        badges.append(ValidationBadge.SCHEMA_OK)

    # Economy: í´ë°±ì—ì„œëŠ” ë¹„ìš© 0ì´ë¯€ë¡œ ECONOMY_OK
    badges.append(ValidationBadge.ECONOMY_OK)

    # Safety: is_blockedì— ë”°ë¼ ê²°ì •
    if is_blocked:
        badges.append(ValidationBadge.SAFETY_BLOCKED)
    else:
        badges.append(ValidationBadge.SAFETY_OK)

    # Consistency: í´ë°±ì—ì„œëŠ” ì–¸ì–´/ì¢Œí‘œ ë¬¸ì œê°€ ì—†ìœ¼ë¯€ë¡œ CONSISTENCY_OK
    badges.append(ValidationBadge.CONSISTENCY_OK)

    # U-079: ì”ì•¡ ë¶€ì¡± ê²½ê³  ì—¬ë¶€ ê²°ì •
    is_low = balance.signal < LOW_BALANCE_THRESHOLD

    return TurnOutput(
        language=language,
        narrative=narrative,
        ui=UIOutput(
            action_deck=ActionDeck(cards=[alternative_card]),
            objects=[],
        ),
        world=WorldDelta(),
        render=RenderOutput(image_job=None),  # ì´ë¯¸ì§€ ìƒì„± ì•ˆ í•¨
        economy=EconomyOutput(
            cost=CurrencyAmount(signal=0, memory_shard=0),
            balance_after=balance,
            credit=0,
            low_balance_warning=is_low,
        ),
        safety=SafetyOutput(
            blocked=is_blocked,
            message=messages["narrative_blocked"] if is_blocked else None,
        ),
        agent_console=AgentConsole(
            current_phase=AgentPhase.COMMIT,
            badges=badges,
            repair_count=repair_count,
        ),
    )
</file>

<file path="backend/src/unknown_world/orchestrator/prompt_loader.py">
"""Unknown World - í”„ë¡¬í”„íŠ¸ ë¡œë” ìœ í‹¸ë¦¬í‹°.

ì´ ëª¨ë“ˆì€ ì–¸ì–´ë³„ë¡œ ë¶„ë¦¬ëœ í”„ë¡¬í”„íŠ¸ íŒŒì¼ì„ ë¡œë“œí•©ë‹ˆë‹¤.
XML íƒœê·¸ ê¸°ë°˜ ë©”íƒ€ë°ì´í„° íŒŒì‹± ë° í•«ë¦¬ë¡œë“œë¥¼ ì§€ì›í•©ë‹ˆë‹¤.

ì„¤ê³„ ì›ì¹™:
    - RULE-006: ko/en ì–¸ì–´ ì •ì±… ì¤€ìˆ˜ (í˜¼í•© ì¶œë ¥ ê¸ˆì§€)
    - RULE-007/008: í”„ë¡¬í”„íŠ¸ ì›ë¬¸ UI/ë¡œê·¸ ë…¸ì¶œ ê¸ˆì§€
    - U-036: í•«ë¦¬ë¡œë“œ (ê°œë°œ ëª¨ë“œ), í”„ë¡ íŠ¸ë§¤í„° íŒŒì‹± ì§€ì›
    - U-046: XML íƒœê·¸ ê·œê²© í†µì¼ (ë©”íƒ€/ì„¹ì…˜) + ë ˆê±°ì‹œ í´ë°±

í”„ë¡¬í”„íŠ¸ ë””ë ‰í† ë¦¬ êµ¬ì¡°:
    backend/prompts/
    â”œâ”€â”€ system/
    â”‚   â”œâ”€â”€ game_master.ko.md
    â”‚   â””â”€â”€ game_master.en.md
    â”œâ”€â”€ turn/
    â”‚   â”œâ”€â”€ turn_output_instructions.ko.md
    â”‚   â””â”€â”€ turn_output_instructions.en.md
    â””â”€â”€ image/
        â”œâ”€â”€ scene_prompt.ko.md
        â””â”€â”€ scene_prompt.en.md

XML íƒœê·¸ ê·œê²© (U-046):
    <prompt_meta>
      <prompt_id>game_master_system</prompt_id>
      <language>ko-KR</language>
      <version>0.1.0</version>
      <last_updated>YYYY-MM-DD</last_updated>
      <policy_preset>default</policy_preset>
    </prompt_meta>

    <prompt_body>
    ## ëª©ì 
    ...
    </prompt_body>

í˜ì–´ë§ ì§ˆë¬¸ ê²°ì •:
    - U-036 Q1: Option A (ê°œë°œ ëª¨ë“œì—ì„œë§Œ ë§¤ í˜¸ì¶œ ì‹œ ë¦¬ë¡œë“œ)
    - U-036 Q2: Option B (í”„ë¡ íŠ¸ë§¤í„° í¬í•¨ ë§ˆí¬ë‹¤ìš´)
    - U-046 Q1: Option A (ë©”íƒ€ ë¸”ë¡ì„ ëª¨ë¸ ì…ë ¥ì—ì„œ ì œê±°)
    - U-046 Q2: Option A (XML íŒŒì‹± ì‹¤íŒ¨ ì‹œ ë ˆê±°ì‹œ í´ë°±)

ì°¸ì¡°:
    - vibe/prd.md 3.2 (í”„ë¡¬í”„íŠ¸ íŒŒì¼ ê´€ë¦¬)
    - vibe/prd.md 10.4 (í”„ë¡¬í”„íŠ¸ í•«ë¦¬ë¡œë“œ)
    - .cursor/rules/30-prompts-i18n.mdc
"""

from __future__ import annotations

import logging
import os
import re
from dataclasses import dataclass, field
from functools import lru_cache
from pathlib import Path
from typing import Literal

from unknown_world.models.turn import Language

# =============================================================================
# ë¡œê±° ì„¤ì • (í”„ë¡¬í”„íŠ¸ ì›ë¬¸ ë¡œê¹… ê¸ˆì§€ - RULE-007/008)
# =============================================================================

logger = logging.getLogger(__name__)

# =============================================================================
# ê²½ë¡œ ìƒìˆ˜
# =============================================================================

# í”„ë¡¬í”„íŠ¸ ë£¨íŠ¸ ë””ë ‰í† ë¦¬ (backend/prompts/)
_PROMPTS_ROOT = Path(__file__).parent.parent.parent.parent / "prompts"

# í”„ë¡¬í”„íŠ¸ ì¹´í…Œê³ ë¦¬
PromptCategory = Literal["system", "turn", "image", "scan", "vision"]

# ì–¸ì–´ ì½”ë“œ ë§¤í•‘
_LANGUAGE_CODE_MAP: dict[Language, str] = {
    Language.KO: "ko",
    Language.EN: "en",
}

# =============================================================================
# í”„ë¡ íŠ¸ë§¤í„° íŒŒì‹± ê²°ê³¼ íƒ€ì…
# =============================================================================


@dataclass
class PromptData:
    """í”„ë¡ íŠ¸ë§¤í„°ê°€ íŒŒì‹±ëœ í”„ë¡¬í”„íŠ¸ ë°ì´í„°.

    Attributes:
        content: í”„ë¡¬í”„íŠ¸ ë³¸ë¬¸ (í”„ë¡ íŠ¸ë§¤í„° ì œì™¸)
        metadata: í”„ë¡ íŠ¸ë§¤í„°ì—ì„œ ì¶”ì¶œí•œ ë©”íƒ€ë°ì´í„°
        raw: ì›ë³¸ ì „ì²´ í…ìŠ¤íŠ¸
    """

    content: str
    metadata: dict[str, str] = field(default_factory=lambda: {})
    raw: str = ""

    def to_dict(self) -> dict[str, str | dict[str, str]]:
        """JSON ì§ë ¬í™” ê°€ëŠ¥í•œ ë”•ì…”ë„ˆë¦¬ë¡œ ë³€í™˜í•©ë‹ˆë‹¤.

        Returns:
            í”„ë¡¬í”„íŠ¸ ë°ì´í„° ë”•ì…”ë„ˆë¦¬
        """
        return {
            "content": self.content,
            "metadata": self.metadata,
        }


# =============================================================================
# í™˜ê²½ ëª¨ë“œ í™•ì¸
# =============================================================================


def _is_development_mode() -> bool:
    """ê°œë°œ ëª¨ë“œì¸ì§€ í™•ì¸í•©ë‹ˆë‹¤.

    ENVIRONMENT í™˜ê²½ë³€ìˆ˜ê°€ 'development'ì´ë©´ ê°œë°œ ëª¨ë“œì…ë‹ˆë‹¤.
    ê°œë°œ ëª¨ë“œì—ì„œëŠ” í”„ë¡¬í”„íŠ¸ í•«ë¦¬ë¡œë“œê°€ í™œì„±í™”ë©ë‹ˆë‹¤.

    Returns:
        ê°œë°œ ëª¨ë“œ ì—¬ë¶€
    """
    return os.environ.get("ENVIRONMENT", "production").lower() == "development"


# =============================================================================
# XML íƒœê·¸ ë° í”„ë¡ íŠ¸ë§¤í„° íŒŒì‹± (U-046)
# =============================================================================

# XML íƒœê·¸ íŒ¨í„´ (U-046 í‘œì¤€)
_XML_META_PATTERN = re.compile(
    r"<prompt_meta>\s*(.*?)\s*</prompt_meta>",
    re.DOTALL,
)
_XML_BODY_PATTERN = re.compile(
    r"<prompt_body>\s*(.*?)\s*</prompt_body>",
    re.DOTALL,
)
_XML_TAG_PATTERN = re.compile(r"<(\w+)>([^<]*)</\1>")

# ë ˆê±°ì‹œ í”„ë¡ íŠ¸ë§¤í„° íŒ¨í„´: íŒŒì¼ ì‹œì‘ ë¶€ë¶„ì˜ "- key: value" í˜•íƒœ
_FRONTMATTER_LINE_PATTERN = re.compile(r"^-\s*(\w+):\s*(.+)$")


def _parse_xml_meta(text: str) -> tuple[dict[str, str], str] | None:
    """XML íƒœê·¸ ê¸°ë°˜ ë©”íƒ€ë°ì´í„°ì™€ ë³¸ë¬¸ì„ íŒŒì‹±í•©ë‹ˆë‹¤.

    U-046 í‘œì¤€ XML íƒœê·¸ ê·œê²©:
        <prompt_meta>
          <prompt_id>game_master_system</prompt_id>
          <language>ko-KR</language>
          <version>0.1.0</version>
          <last_updated>YYYY-MM-DD</last_updated>
          <policy_preset>default</policy_preset>
        </prompt_meta>

        <prompt_body>
        ## ëª©ì 
        ...
        </prompt_body>

    Args:
        text: ì›ë³¸ í…ìŠ¤íŠ¸

    Returns:
        (ë©”íƒ€ë°ì´í„° ë”•ì…”ë„ˆë¦¬, ë³¸ë¬¸ í…ìŠ¤íŠ¸) íŠœí”Œ
        XML íƒœê·¸ê°€ ì—†ìœ¼ë©´ None ë°˜í™˜ (ë ˆê±°ì‹œ í´ë°± í•„ìš”)
    """
    meta_match = _XML_META_PATTERN.search(text)
    body_match = _XML_BODY_PATTERN.search(text)

    # XML íƒœê·¸ê°€ ì—†ìœ¼ë©´ None ë°˜í™˜
    if not meta_match:
        return None

    # ë©”íƒ€ë°ì´í„° íŒŒì‹±
    meta_content = meta_match.group(1)
    metadata: dict[str, str] = {}
    for tag_match in _XML_TAG_PATTERN.finditer(meta_content):
        key = tag_match.group(1)
        value = tag_match.group(2).strip()
        metadata[key] = value

    # ë³¸ë¬¸ ì¶”ì¶œ (U-046 Q1: ë©”íƒ€ ë¸”ë¡ì„ ëª¨ë¸ ì…ë ¥ì—ì„œ ì œê±°)
    if body_match:
        content = body_match.group(1).strip()
    else:
        # <prompt_body>ê°€ ì—†ìœ¼ë©´ <prompt_meta> ì´í›„ ì „ì²´ë¥¼ ë³¸ë¬¸ìœ¼ë¡œ ì·¨ê¸‰
        meta_end = meta_match.end()
        content = text[meta_end:].strip()

    return metadata, content


def _parse_legacy_frontmatter(text: str) -> tuple[dict[str, str], str]:
    """ë ˆê±°ì‹œ í”„ë¡ íŠ¸ë§¤í„°ë¥¼ íŒŒì‹±í•©ë‹ˆë‹¤ (U-036 í˜¸í™˜).

    í”„ë¡ íŠ¸ë§¤í„°ëŠ” ì²« ë²ˆì§¸ ì œëª©(#) ì´í›„, ë‘ ë²ˆì§¸ ì œëª©(##) ì´ì „ì˜
    "- key: value" í˜•íƒœì˜ ë¼ì¸ë“¤ì…ë‹ˆë‹¤.

    ì˜ˆì‹œ êµ¬ì¡°:
        # [Prompt] Title

        - prompt_id: xxx
        - version: 0.1.0

        ## ë³¸ë¬¸ ì„¹ì…˜
        ...

    Args:
        text: ì›ë³¸ ë§ˆí¬ë‹¤ìš´ í…ìŠ¤íŠ¸

    Returns:
        (ë©”íƒ€ë°ì´í„° ë”•ì…”ë„ˆë¦¬, ë³¸ë¬¸ í…ìŠ¤íŠ¸) íŠœí”Œ
    """
    lines = text.split("\n")
    metadata: dict[str, str] = {}
    content_start_idx = 0
    found_first_heading = False

    for i, line in enumerate(lines):
        stripped = line.strip()

        # ë¹ˆ ì¤„ì€ ê±´ë„ˆëœ€
        if not stripped:
            continue

        # ì²« ë²ˆì§¸ ì œëª©(#) ë°œê²¬
        if stripped.startswith("#") and not stripped.startswith("##"):
            found_first_heading = True
            continue

        # ë‘ ë²ˆì§¸ ì œëª©(##) ë°œê²¬ ì‹œ í”„ë¡ íŠ¸ë§¤í„° ì˜ì—­ ì¢…ë£Œ, ë³¸ë¬¸ ì‹œì‘
        if stripped.startswith("##"):
            content_start_idx = i
            break

        # í”„ë¡ íŠ¸ë§¤í„° ë¼ì¸ ë§¤ì¹­ (ì²« ë²ˆì§¸ ì œëª© ì´í›„)
        if found_first_heading:
            match = _FRONTMATTER_LINE_PATTERN.match(stripped)
            if match:
                key = match.group(1)
                value = match.group(2).strip()
                metadata[key] = value

    # ë³¸ë¬¸ ì¶”ì¶œ (ë‘ ë²ˆì§¸ ì œëª©ë¶€í„°)
    content = "\n".join(lines[content_start_idx:]).strip()

    return metadata, content


def _parse_frontmatter(text: str) -> tuple[dict[str, str], str]:
    """ë©”íƒ€ë°ì´í„°ì™€ ë³¸ë¬¸ì„ íŒŒì‹±í•©ë‹ˆë‹¤ (XML ìš°ì„ , ë ˆê±°ì‹œ í´ë°±).

    U-046 Q2 ê²°ì •: XML íƒœê·¸ íŒŒì‹± ì‹¤íŒ¨ ì‹œ ë ˆê±°ì‹œ í´ë°± í›„ ì§„í–‰

    íŒŒì‹± ìš°ì„ ìˆœìœ„:
        1. XML íƒœê·¸ ê¸°ë°˜ (<prompt_meta>, <prompt_body>)
        2. ë ˆê±°ì‹œ í”„ë¡ íŠ¸ë§¤í„° (- key: value)

    Args:
        text: ì›ë³¸ í…ìŠ¤íŠ¸

    Returns:
        (ë©”íƒ€ë°ì´í„° ë”•ì…”ë„ˆë¦¬, ë³¸ë¬¸ í…ìŠ¤íŠ¸) íŠœí”Œ
    """
    # 1. XML íƒœê·¸ íŒŒì‹± ì‹œë„
    xml_result = _parse_xml_meta(text)
    if xml_result is not None:
        metadata, content = xml_result
        logger.debug(
            "[PromptLoader] XML íƒœê·¸ ê¸°ë°˜ íŒŒì‹± ì™„ë£Œ",
            extra={"format": "xml", "meta_keys": list(metadata.keys())},
        )
        return metadata, content

    # 2. ë ˆê±°ì‹œ í´ë°± (U-046 Q2: Option A)
    logger.debug(
        "[PromptLoader] ë ˆê±°ì‹œ í”„ë¡ íŠ¸ë§¤í„° íŒŒì‹±ìœ¼ë¡œ í´ë°±",
        extra={"format": "legacy"},
    )
    return _parse_legacy_frontmatter(text)


# =============================================================================
# í”„ë¡¬í”„íŠ¸ ë¡œë” í•¨ìˆ˜
# =============================================================================


def _get_prompt_path(
    category: PromptCategory,
    name: str,
    language: Language,
) -> Path:
    """í”„ë¡¬í”„íŠ¸ íŒŒì¼ ê²½ë¡œë¥¼ ë°˜í™˜í•©ë‹ˆë‹¤.

    Args:
        category: í”„ë¡¬í”„íŠ¸ ì¹´í…Œê³ ë¦¬ (system, turn, image)
        name: í”„ë¡¬í”„íŠ¸ íŒŒì¼ ì´ë¦„ (í™•ì¥ì ì œì™¸)
        language: ì–¸ì–´ (ko-KR, en-US)

    Returns:
        í”„ë¡¬í”„íŠ¸ íŒŒì¼ ê²½ë¡œ

    Example:
        >>> _get_prompt_path("system", "game_master", Language.KO)
        Path(".../prompts/system/game_master.ko.md")
    """
    lang_code = _LANGUAGE_CODE_MAP.get(language, "ko")
    return _PROMPTS_ROOT / category / f"{name}.{lang_code}.md"


def _load_prompt_file(
    category: PromptCategory,
    name: str,
    language: Language,
) -> str:
    """í”„ë¡¬í”„íŠ¸ íŒŒì¼ì„ ì§ì ‘ ë¡œë“œí•©ë‹ˆë‹¤ (ìºì‹± ì—†ìŒ).

    í•«ë¦¬ë¡œë“œ ëª¨ë“œì—ì„œ ì‚¬ìš©ë©ë‹ˆë‹¤.

    Args:
        category: í”„ë¡¬í”„íŠ¸ ì¹´í…Œê³ ë¦¬
        name: í”„ë¡¬í”„íŠ¸ ì´ë¦„
        language: ì–¸ì–´

    Returns:
        í”„ë¡¬í”„íŠ¸ í…ìŠ¤íŠ¸

    Raises:
        FileNotFoundError: í”„ë¡¬í”„íŠ¸ íŒŒì¼ì´ ì—†ëŠ” ê²½ìš°
    """
    path = _get_prompt_path(category, name, language)

    if not path.exists():
        # í´ë°±: ë°˜ëŒ€ ì–¸ì–´ ì‹œë„
        fallback_lang = Language.EN if language == Language.KO else Language.KO
        fallback_path = _get_prompt_path(category, name, fallback_lang)

        if fallback_path.exists():
            logger.warning(
                "[PromptLoader] í´ë°± ì–¸ì–´ ì‚¬ìš©",
                extra={
                    "original_language": language.value,
                    "fallback_language": fallback_lang.value,
                },
            )
            return fallback_path.read_text(encoding="utf-8")

        raise FileNotFoundError(f"í”„ë¡¬í”„íŠ¸ íŒŒì¼ì„ ì°¾ì„ ìˆ˜ ì—†ìŠµë‹ˆë‹¤: {path}")

    return path.read_text(encoding="utf-8")


@lru_cache(maxsize=32)
def _load_prompt_cached(
    category: PromptCategory,
    name: str,
    language: Language,
) -> str:
    """í”„ë¡¬í”„íŠ¸ íŒŒì¼ì„ ìºì‹±í•˜ì—¬ ë¡œë“œí•©ë‹ˆë‹¤.

    ìš´ì˜ ëª¨ë“œì—ì„œ ì‚¬ìš©ë©ë‹ˆë‹¤.

    Args:
        category: í”„ë¡¬í”„íŠ¸ ì¹´í…Œê³ ë¦¬
        name: í”„ë¡¬í”„íŠ¸ ì´ë¦„
        language: ì–¸ì–´

    Returns:
        í”„ë¡¬í”„íŠ¸ í…ìŠ¤íŠ¸
    """
    return _load_prompt_file(category, name, language)


def load_prompt(
    category: PromptCategory,
    name: str,
    language: Language,
) -> str:
    """í”„ë¡¬í”„íŠ¸ íŒŒì¼ì„ ë¡œë“œí•©ë‹ˆë‹¤.

    ê°œë°œ ëª¨ë“œ(ENVIRONMENT=development)ì—ì„œëŠ” ë§¤ í˜¸ì¶œ ì‹œ íŒŒì¼ì„ ë‹¤ì‹œ ì½ìŠµë‹ˆë‹¤ (í•«ë¦¬ë¡œë“œ).
    ìš´ì˜ ëª¨ë“œì—ì„œëŠ” ìºì‹±ì„ í†µí•´ ë°˜ë³µ ë¡œë“œë¥¼ ë°©ì§€í•©ë‹ˆë‹¤.
    í”„ë¡¬í”„íŠ¸ ì›ë¬¸ì€ ë¡œê·¸ì— ê¸°ë¡í•˜ì§€ ì•ŠìŠµë‹ˆë‹¤ (RULE-007/008).

    Args:
        category: í”„ë¡¬í”„íŠ¸ ì¹´í…Œê³ ë¦¬ (system, turn, image)
        name: í”„ë¡¬í”„íŠ¸ íŒŒì¼ ì´ë¦„ (í™•ì¥ì ì œì™¸)
        language: ì–¸ì–´ (ko-KR, en-US)

    Returns:
        í”„ë¡¬í”„íŠ¸ í…ìŠ¤íŠ¸

    Raises:
        FileNotFoundError: í”„ë¡¬í”„íŠ¸ íŒŒì¼ì´ ì—†ëŠ” ê²½ìš°

    Example:
        >>> prompt = load_prompt("system", "game_master", Language.KO)
    """
    # ë¡œê·¸ì—ëŠ” ê²½ë¡œ/ë©”íƒ€ë§Œ ê¸°ë¡ (ì›ë¬¸ ê¸ˆì§€)
    logger.debug(
        "[PromptLoader] í”„ë¡¬í”„íŠ¸ ë¡œë“œ",
        extra={
            "category": category,
            "name": name,
            "language": language.value,
            "hot_reload": _is_development_mode(),
        },
    )

    # U-036 Q1 ê²°ì •: ê°œë°œ ëª¨ë“œì—ì„œë§Œ í•«ë¦¬ë¡œë“œ
    if _is_development_mode():
        return _load_prompt_file(category, name, language)
    else:
        return _load_prompt_cached(category, name, language)


def load_prompt_with_metadata(
    category: PromptCategory,
    name: str,
    language: Language,
) -> PromptData:
    """í”„ë¡¬í”„íŠ¸ íŒŒì¼ì„ ë©”íƒ€ë°ì´í„°ì™€ í•¨ê»˜ ë¡œë“œí•©ë‹ˆë‹¤.

    í”„ë¡ íŠ¸ë§¤í„°ë¥¼ íŒŒì‹±í•˜ì—¬ ë©”íƒ€ë°ì´í„°ì™€ ë³¸ë¬¸ì„ ë¶„ë¦¬í•©ë‹ˆë‹¤.
    JSON í˜•íƒœë¡œ í”„ë¡¬í”„íŠ¸ë¥¼ ì „ë‹¬í•  ë•Œ ìœ ìš©í•©ë‹ˆë‹¤.

    Args:
        category: í”„ë¡¬í”„íŠ¸ ì¹´í…Œê³ ë¦¬ (system, turn, image)
        name: í”„ë¡¬í”„íŠ¸ íŒŒì¼ ì´ë¦„ (í™•ì¥ì ì œì™¸)
        language: ì–¸ì–´ (ko-KR, en-US)

    Returns:
        PromptData: ë©”íƒ€ë°ì´í„°ì™€ ë³¸ë¬¸ì´ ë¶„ë¦¬ëœ í”„ë¡¬í”„íŠ¸ ë°ì´í„°

    Example:
        >>> data = load_prompt_with_metadata("system", "game_master", Language.KO)
        >>> print(data.metadata.get("version"))
        >>> print(data.content[:100])
    """
    raw_text = load_prompt(category, name, language)
    metadata, content = _parse_frontmatter(raw_text)

    logger.debug(
        "[PromptLoader] í”„ë¡¬í”„íŠ¸ ë©”íƒ€ë°ì´í„° íŒŒì‹± ì™„ë£Œ",
        extra={
            "category": category,
            "name": name,
            "language": language.value,
            "prompt_id": metadata.get("prompt_id", "unknown"),
            "version": metadata.get("version", "unknown"),
        },
    )

    return PromptData(
        content=content,
        metadata=metadata,
        raw=raw_text,
    )


def load_prompt_as_json(
    category: PromptCategory,
    name: str,
    language: Language,
) -> dict[str, str | dict[str, str]]:
    """í”„ë¡¬í”„íŠ¸ë¥¼ JSON ì§ë ¬í™” ê°€ëŠ¥í•œ ë”•ì…”ë„ˆë¦¬ë¡œ ë¡œë“œí•©ë‹ˆë‹¤.

    API ì‘ë‹µì´ë‚˜ ëª¨ë¸ ì…ë ¥ìœ¼ë¡œ í”„ë¡¬í”„íŠ¸ë¥¼ ì „ë‹¬í•  ë•Œ ìœ ìš©í•©ë‹ˆë‹¤.

    Args:
        category: í”„ë¡¬í”„íŠ¸ ì¹´í…Œê³ ë¦¬ (system, turn, image)
        name: í”„ë¡¬í”„íŠ¸ íŒŒì¼ ì´ë¦„ (í™•ì¥ì ì œì™¸)
        language: ì–¸ì–´ (ko-KR, en-US)

    Returns:
        í”„ë¡¬í”„íŠ¸ ë”•ì…”ë„ˆë¦¬ (content, metadata í¬í•¨)

    Example:
        >>> prompt_json = load_prompt_as_json("image", "scene_prompt", Language.KO)
        >>> print(prompt_json["metadata"]["prompt_id"])
    """
    data = load_prompt_with_metadata(category, name, language)
    return data.to_dict()


def load_system_prompt(language: Language) -> str:
    """Game Master ì‹œìŠ¤í…œ í”„ë¡¬í”„íŠ¸ë¥¼ ë¡œë“œí•©ë‹ˆë‹¤.

    Args:
        language: ì–¸ì–´ (ko-KR, en-US)

    Returns:
        ì‹œìŠ¤í…œ í”„ë¡¬í”„íŠ¸ í…ìŠ¤íŠ¸
    """
    return load_prompt("system", "game_master", language)


def load_turn_instructions(language: Language) -> str:
    """TurnOutput ì§€ì‹œ í”„ë¡¬í”„íŠ¸ë¥¼ ë¡œë“œí•©ë‹ˆë‹¤.

    Args:
        language: ì–¸ì–´ (ko-KR, en-US)

    Returns:
        TurnOutput ì§€ì‹œ í…ìŠ¤íŠ¸
    """
    return load_prompt("turn", "turn_output_instructions", language)


def load_image_prompt(language: Language) -> str:
    """ì´ë¯¸ì§€ ìƒì„± í”„ë¡¬í”„íŠ¸ë¥¼ ë¡œë“œí•©ë‹ˆë‹¤.

    Args:
        language: ì–¸ì–´ (ko-KR, en-US)

    Returns:
        ì´ë¯¸ì§€ ìƒì„± í”„ë¡¬í”„íŠ¸ í…ìŠ¤íŠ¸
    """
    return load_prompt("image", "scene_prompt", language)


def load_image_prompt_with_metadata(language: Language) -> PromptData:
    """ì´ë¯¸ì§€ ìƒì„± í”„ë¡¬í”„íŠ¸ë¥¼ ë©”íƒ€ë°ì´í„°ì™€ í•¨ê»˜ ë¡œë“œí•©ë‹ˆë‹¤.

    Args:
        language: ì–¸ì–´ (ko-KR, en-US)

    Returns:
        PromptData: ë©”íƒ€ë°ì´í„°ì™€ ë³¸ë¬¸ì´ ë¶„ë¦¬ëœ ì´ë¯¸ì§€ í”„ë¡¬í”„íŠ¸ ë°ì´í„°
    """
    return load_prompt_with_metadata("image", "scene_prompt", language)


def clear_prompt_cache() -> None:
    """í”„ë¡¬í”„íŠ¸ ìºì‹œë¥¼ ì´ˆê¸°í™”í•©ë‹ˆë‹¤.

    ê°œë°œ ì¤‘ í•«ë¦¬ë¡œë“œ ë˜ëŠ” í…ŒìŠ¤íŠ¸ ì‹œ ì‚¬ìš©í•©ë‹ˆë‹¤.
    """
    _load_prompt_cached.cache_clear()
    logger.info("[PromptLoader] í”„ë¡¬í”„íŠ¸ ìºì‹œ ì´ˆê¸°í™”ë¨")


def get_prompt_metadata(
    category: PromptCategory,
    name: str,
    language: Language,
) -> dict[str, str]:
    """í”„ë¡¬í”„íŠ¸ì˜ ë©”íƒ€ë°ì´í„°ë§Œ ë°˜í™˜í•©ë‹ˆë‹¤.

    ë³¸ë¬¸ ì—†ì´ ë²„ì „, ì–¸ì–´, ì—…ë°ì´íŠ¸ ë‚ ì§œ ë“± ë©”íƒ€ì •ë³´ë§Œ í•„ìš”í•  ë•Œ ì‚¬ìš©í•©ë‹ˆë‹¤.

    Args:
        category: í”„ë¡¬í”„íŠ¸ ì¹´í…Œê³ ë¦¬
        name: í”„ë¡¬í”„íŠ¸ ì´ë¦„
        language: ì–¸ì–´

    Returns:
        ë©”íƒ€ë°ì´í„° ë”•ì…”ë„ˆë¦¬
    """
    data = load_prompt_with_metadata(category, name, language)
    return data.metadata


def is_hot_reload_enabled() -> bool:
    """í•«ë¦¬ë¡œë“œê°€ í™œì„±í™”ë˜ì–´ ìˆëŠ”ì§€ í™•ì¸í•©ë‹ˆë‹¤.

    Returns:
        í•«ë¦¬ë¡œë“œ í™œì„±í™” ì—¬ë¶€
    """
    return _is_development_mode()
</file>

<file path="backend/src/unknown_world/orchestrator/stages/resolve.py">
"""Unknown World - Resolve Stage.

í•´ê²° ë‹¨ê³„ì…ë‹ˆë‹¤.
U-076ì—ì„œ "ì •ë°€ë¶„ì„" íŠ¸ë¦¬ê±° ë¶„ê¸°ê°€ ì¶”ê°€ë˜ì—ˆìŠµë‹ˆë‹¤.
U-090ì—ì„œ ë¹„ì •ë°€ë¶„ì„ í„´ì˜ í•«ìŠ¤íŒŸ ìƒì„±ì„ ê°•ì œ í•„í„°ë§í•©ë‹ˆë‹¤.

ì„¤ê³„ ì›ì¹™:
    - RULE-008: ë‹¨ê³„ ì´ë²¤íŠ¸ ì¼ê´€ì„±
    - RULE-009: bbox 0~1000 ì •ê·œí™”
    - RULE-004: ì‹¤íŒ¨ ì‹œ ì•ˆì „í•œ í´ë°± (ë¹ˆ í•«ìŠ¤íŒŸ + í´ë°± ë‚´ëŸ¬í‹°ë¸Œ)
    - ë™ì‘ ë³´ì¡´: ê¸°ì¡´ ì‹œë®¬ë ˆì´ì…˜ ì§€ì—° ìœ ì§€
    - U-076: "ì •ë°€ë¶„ì„" íŠ¸ë¦¬ê±° ì‹œ Agentic Vision ì‹¤í–‰ â†’ í•«ìŠ¤íŒŸ ì¶”ê°€
    - U-090: ë¹„ì •ë°€ë¶„ì„ í„´ì—ì„œ GM ìƒì„± í•«ìŠ¤íŒŸ ì¡°ìš©íˆ ì œê±° (ì„œë²„ ì•ˆì „ì¥ì¹˜)

ì°¸ì¡°:
    - vibe/refactors/RU-005-Q4.md
    - vibe/unit-plans/U-076[Mvp].md
    - vibe/unit-plans/U-090[Mvp].md
"""

from __future__ import annotations

import asyncio
import logging

from unknown_world.config.models import TextModelTiering
from unknown_world.models.turn import (
    AgentPhase,
    Language,
)
from unknown_world.orchestrator.stages.types import (
    EmitFn,
    PipelineContext,
    PipelineEvent,
    PipelineEventType,
)

# ëª¨ì˜ ì²˜ë¦¬ ì§€ì—° ì‹œê°„ (ms)
RESOLVE_DELAY_MS = 150

# ë¡œê±° (í”„ë¡¬í”„íŠ¸/ë¹„ë°€ì •ë³´ ë…¸ì¶œ ê¸ˆì§€ - RULE-007)
logger = logging.getLogger(__name__)


# =============================================================================
# ì •ë°€ë¶„ì„ (Agentic Vision) ì²˜ë¦¬ (U-076)
# =============================================================================


def _is_vision_trigger(ctx: PipelineContext) -> bool:
    """ì •ë°€ë¶„ì„(ë¹„ì „ ë¶„ì„) íŠ¸ë¦¬ê±° ì—¬ë¶€ë¥¼ í™•ì¸í•©ë‹ˆë‹¤.

    Args:
        ctx: íŒŒì´í”„ë¼ì¸ ì»¨í…ìŠ¤íŠ¸

    Returns:
        ì •ë°€ë¶„ì„ íŠ¸ë¦¬ê±° ì—¬ë¶€
    """
    action_id = ctx.turn_input.action_id
    text = ctx.turn_input.text
    return TextModelTiering.is_vision_trigger(action_id, text)


def _get_current_image_url(ctx: PipelineContext) -> str | None:
    """í˜„ì¬ Scene ì´ë¯¸ì§€ URLì„ í™•ì¸í•©ë‹ˆë‹¤.

    ì •ë°€ë¶„ì„ì€ ì´ë¯¸ì§€ê°€ ìˆì„ ë•Œë§Œ ì‹¤í–‰ ê°€ëŠ¥í•©ë‹ˆë‹¤.

    Args:
        ctx: íŒŒì´í”„ë¼ì¸ ì»¨í…ìŠ¤íŠ¸

    Returns:
        ì´ë¯¸ì§€ URL ë˜ëŠ” None
    """
    # 1. TurnInputì—ì„œ ì´ì „ ì´ë¯¸ì§€ URL í™•ì¸ (U-068)
    if ctx.turn_input.previous_image_url:
        return ctx.turn_input.previous_image_url

    # 2. TurnOutput.renderì—ì„œ ì´ë¯¸ì§€ URL í™•ì¸
    if ctx.output and ctx.output.render and ctx.output.render.image_url:
        return ctx.output.render.image_url

    return None


async def _execute_vision_analysis(
    ctx: PipelineContext,
    image_url: str,
) -> PipelineContext:
    """Agentic Vision ë¶„ì„ì„ ì‹¤í–‰í•˜ê³  ê²°ê³¼ë¥¼ TurnOutputì— ë°˜ì˜í•©ë‹ˆë‹¤.

    Args:
        ctx: íŒŒì´í”„ë¼ì¸ ì»¨í…ìŠ¤íŠ¸
        image_url: ë¶„ì„í•  Scene ì´ë¯¸ì§€ URL

    Returns:
        ì—…ë°ì´íŠ¸ëœ ì»¨í…ìŠ¤íŠ¸
    """
    if ctx.output is None:
        return ctx

    language = ctx.turn_input.language

    try:
        from unknown_world.services.agentic_vision import (
            affordances_to_scene_objects,
            get_agentic_vision_service,
        )

        vision_service = get_agentic_vision_service()
        result = await vision_service.analyze_scene(image_url, language)

        if result.success and result.affordances:
            # affordances â†’ SceneObject ë³€í™˜
            new_objects = affordances_to_scene_objects(result.affordances)

            # ì •ë°€ë¶„ì„: ë¹„ì „ ê²°ê³¼ë¡œ ëŒ€ì²´ (í…ìŠ¤íŠ¸ ëª¨ë¸ì€ ì´ë¯¸ì§€ë¥¼ ë³´ì§€ ì•Šì•„ ë¶ˆì¼ì¹˜)
            # í…ìŠ¤íŠ¸ ëª¨ë¸ì´ ìƒì„±í•œ objectsëŠ” ë‚´ëŸ¬í‹°ë¸Œ ê¸°ë°˜ì´ë¯€ë¡œ
            # ì‹¤ì œ ì´ë¯¸ì§€ë¥¼ ë¶„ì„í•œ ë¹„ì „ ê²°ê³¼ë§Œ ì‚¬ìš©í•´ì•¼ ì •í•©ì„± ìœ ì§€
            merged_objects = new_objects[:5]

            # UI ì—…ë°ì´íŠ¸
            new_ui = ctx.output.ui.model_copy(update={"objects": merged_objects})
            ctx.output = ctx.output.model_copy(update={"ui": new_ui})

            # ë‚´ëŸ¬í‹°ë¸Œ ë³´ê°•: "ì¥ë©´ì„ ìì„¸íˆ ì‚´í´ë³´ë‹ˆ..."
            discovered_labels = [aff.label for aff in result.affordances]
            if language == Language.KO:
                vision_narrative = (
                    f"\n\nì¥ë©´ì„ ìì„¸íˆ ì‚´í´ë´…ë‹ˆë‹¤... "
                    f"{', '.join(discovered_labels)}ì´(ê°€) ëˆˆì— ë“¤ì–´ì˜µë‹ˆë‹¤."
                )
            else:
                vision_narrative = (
                    f"\n\nYou examine the scene closely... "
                    f"You notice {', '.join(discovered_labels)}."
                )

            new_narrative = ctx.output.narrative + vision_narrative
            ctx.output = ctx.output.model_copy(update={"narrative": new_narrative})

            logger.info(
                "[Resolve] ì •ë°€ë¶„ì„ ì„±ê³µ (U-076)",
                extra={
                    "affordance_count": len(result.affordances),
                    "merged_object_count": len(merged_objects),
                    "analysis_time_ms": result.analysis_time_ms,
                },
            )

        else:
            # ë¶„ì„ ì‹¤íŒ¨ ë˜ëŠ” ê²°ê³¼ ì—†ìŒ â†’ í´ë°± ë‚´ëŸ¬í‹°ë¸Œ (RULE-004)
            if language == Language.KO:
                fallback_text = "\n\nìì„¸íˆ ë´ë„ íŠ¹ë³„í•œ ê²ƒì€ ë³´ì´ì§€ ì•ŠìŠµë‹ˆë‹¤."
            else:
                fallback_text = "\n\nEven looking closely, nothing special catches your eye."

            new_narrative = ctx.output.narrative + fallback_text
            ctx.output = ctx.output.model_copy(update={"narrative": new_narrative})

            logger.info(
                "[Resolve] ì •ë°€ë¶„ì„ ê²°ê³¼ ì—†ìŒ/ì‹¤íŒ¨, í´ë°± ë‚´ëŸ¬í‹°ë¸Œ ì ìš© (U-076)",
                extra={
                    "success": result.success,
                    "message": result.message,
                },
            )

    except Exception as e:
        # ì˜ˆì™¸ ë°œìƒ ì‹œ ì•ˆì „í•œ í´ë°± (RULE-004)
        logger.error(
            "[Resolve] ì •ë°€ë¶„ì„ ì¤‘ ì˜ˆì™¸ ë°œìƒ, í´ë°± ì ìš©",
            extra={"error_type": type(e).__name__},
        )
        if language == Language.KO:
            fallback_text = "\n\nìì„¸íˆ ë´ë„ íŠ¹ë³„í•œ ê²ƒì€ ë³´ì´ì§€ ì•ŠìŠµë‹ˆë‹¤."
        else:
            fallback_text = "\n\nEven looking closely, nothing special catches your eye."

        new_narrative = ctx.output.narrative + fallback_text
        ctx.output = ctx.output.model_copy(update={"narrative": new_narrative})

    # ì´ë¯¸ì§€ ìƒì„± ê°•ì œ ë¹„í™œì„± (ì •ë°€ë¶„ì„ì€ ì´ë¯¸ì§€ ìƒì„± ì—†ìŒ)
    if ctx.output and ctx.output.render and ctx.output.render.image_job:
        no_gen_job = ctx.output.render.image_job.model_copy(update={"should_generate": False})
        new_render = ctx.output.render.model_copy(update={"image_job": no_gen_job})
        ctx.output = ctx.output.model_copy(update={"render": new_render})

    # ë¹„ìš© ë°°ìˆ˜ ì ìš© (U-076 Q2: 1.5x)
    ctx.cost_multiplier = TextModelTiering.VISION_COST_MULTIPLIER

    return ctx


# =============================================================================
# Stage í•¨ìˆ˜
# =============================================================================


async def resolve_stage(ctx: PipelineContext, *, emit: EmitFn) -> PipelineContext:
    """Resolve ë‹¨ê³„ë¥¼ ì‹¤í–‰í•©ë‹ˆë‹¤.

    U-076: "ì •ë°€ë¶„ì„" íŠ¸ë¦¬ê±°ê°€ ê°ì§€ë˜ë©´ Agentic Vision ì„œë¹„ìŠ¤ë¥¼ í˜¸ì¶œí•˜ì—¬
    ì´ë¯¸ì§€ ë‚´ ì˜¤ë¸Œì íŠ¸ë¥¼ ë¶„ì„í•˜ê³  í•«ìŠ¤íŒŸì„ ì¶”ê°€í•©ë‹ˆë‹¤.
    ê·¸ ì™¸ì—ëŠ” pass-throughë¡œ ë™ì‘í•©ë‹ˆë‹¤.

    Args:
        ctx: íŒŒì´í”„ë¼ì¸ ì»¨í…ìŠ¤íŠ¸
        emit: ì´ë²¤íŠ¸ emit ì½œë°±

    Returns:
        ì—…ë°ì´íŠ¸ëœ ì»¨í…ìŠ¤íŠ¸
    """
    ctx.current_phase = AgentPhase.RESOLVE

    # Stage ì‹œì‘ ì´ë²¤íŠ¸
    await emit(
        PipelineEvent(
            event_type=PipelineEventType.STAGE_START,
            phase=AgentPhase.RESOLVE,
        )
    )

    # U-076: ì •ë°€ë¶„ì„ íŠ¸ë¦¬ê±° ê°ì§€
    if _is_vision_trigger(ctx) and ctx.output is not None:
        image_url = _get_current_image_url(ctx)

        if image_url:
            logger.info(
                "[Resolve] ì •ë°€ë¶„ì„ íŠ¸ë¦¬ê±° ê°ì§€, Agentic Vision ì‹¤í–‰ (U-076)",
                extra={
                    "action_id": ctx.turn_input.action_id,
                    "has_image": True,
                },
            )
            ctx = await _execute_vision_analysis(ctx, image_url)
        else:
            logger.info(
                "[Resolve] ì •ë°€ë¶„ì„ íŠ¸ë¦¬ê±° ê°ì§€, ê·¸ëŸ¬ë‚˜ ì´ë¯¸ì§€ ì—†ìŒ - ê±´ë„ˆëœ€",
            )
    else:
        # ê¸°ì¡´ ë™ì‘: pass-through + ëª¨ì˜ ì§€ì—°
        await asyncio.sleep(RESOLVE_DELAY_MS / 1000.0)

        # U-090: ë¹„ì •ë°€ë¶„ì„ í„´ì—ì„œ GMì´ ìƒì„±í•œ í•«ìŠ¤íŒŸ ì¡°ìš©íˆ ì œê±°
        # GMì´ í”„ë¡¬í”„íŠ¸ ì§€ì‹œë¥¼ ë¬´ì‹œí•˜ê³  objects[]ì— í•«ìŠ¤íŒŸì„ ì¶”ê°€í•  ìˆ˜ ìˆìœ¼ë¯€ë¡œ
        # ì„œë²„ì—ì„œ ê°•ì œë¡œ ë¹ˆ ë°°ì—´ë¡œ ì„¤ì •í•©ë‹ˆë‹¤ (Q2 ê²°ì •: Option A - ì¡°ìš©íˆ ì œê±°)
        if ctx.output is not None and ctx.output.ui.objects:
            stripped_count = len(ctx.output.ui.objects)
            logger.warning(
                "[Resolve] U-090: ë¹„ì •ë°€ë¶„ì„ í„´ì—ì„œ GM ìƒì„± í•«ìŠ¤íŒŸ %dê°œ ì œê±°ë¨",
                stripped_count,
                extra={
                    "stripped_object_count": stripped_count,
                    "action_id": ctx.turn_input.action_id,
                },
            )
            new_ui = ctx.output.ui.model_copy(update={"objects": []})
            ctx.output = ctx.output.model_copy(update={"ui": new_ui})

    # Stage ì™„ë£Œ ì´ë²¤íŠ¸
    await emit(
        PipelineEvent(
            event_type=PipelineEventType.STAGE_COMPLETE,
            phase=AgentPhase.RESOLVE,
        )
    )

    return ctx
</file>

<file path="backend/src/unknown_world/services/item_icon_generator.py">
"""Unknown World - ì•„ì´í…œ ì•„ì´ì½˜ ë™ì  ìƒì„± ì„œë¹„ìŠ¤ (U-075[Mvp]).

ì´ ëª¨ë“ˆì€ ì¸ë²¤í† ë¦¬ ì•„ì´í…œ ì„¤ëª…ì„ ê¸°ë°˜ìœ¼ë¡œ 64x64 í”½ì…€ ì•„íŠ¸ ì•„ì´ì½˜ì„ ë™ì  ìƒì„±í•©ë‹ˆë‹¤.
ìºì‹±, ì–¸ì–´ ì •í•©ì„±ì„ ë³´ì¥í•©ë‹ˆë‹¤.

U-091: ëŸ°íƒ€ì„ rembg ì œê±° - ë°°ê²½ ì œê±° ì—†ì´ í”„ë¡¬í”„íŠ¸ë¡œ ì–´ë‘ìš´ ë°°ê²½ ìœ ë„.
U-093: íƒ€ì„ì•„ì›ƒ 90ì´ˆ ìƒí–¥, ìµœëŒ€ 1íšŒ ì¬ì‹œë„(ì´ 2íšŒ), ì§€ìˆ˜ ë°±ì˜¤í”„, í´ë°± ë³´ê°•.

ì„¤ê³„ ì›ì¹™:
    - RULE-004: ì‹¤íŒ¨ ì‹œ ì•ˆì „í•œ í´ë°± ì œê³µ (placeholder ì•„ì´ì½˜)
    - RULE-006: ko/en ì–¸ì–´ ì •ì±… ì¤€ìˆ˜ (ì•„ì´í…œ ì´ë¦„ ì–¸ì–´ ì •í•©ì„±)
    - RULE-007: í”„ë¡¬í”„íŠ¸ ì›ë¬¸ ë…¸ì¶œ ê¸ˆì§€
    - RULE-010: ì´ë¯¸ì§€ ëª¨ë¸ ID ê³ ì • (gemini-2.5-flash-image for FAST)

í˜ì–´ë§ ì§ˆë¬¸ ê²°ì • (U-075[Mvp]):
    - Q1: Option B (placeholder ë¨¼ì € í‘œì‹œ í›„ ë°±ê·¸ë¼ìš´ë“œ ìƒì„±)
    - Q2: Option A (64x64 í”½ì…€)
    - Q3: Option A (í”½ì…€ ì•„íŠ¸ ìŠ¤íƒ€ì¼ - CRT í…Œë§ˆ)

í˜ì–´ë§ ì§ˆë¬¸ ê²°ì • (U-093[Mvp]):
    - Q1: Option B (ìµœëŒ€ 1íšŒ ì¬ì‹œë„, ì´ 2íšŒ ì‹œë„)

ì°¸ì¡°:
    - vibe/unit-plans/U-075[Mvp].md
    - vibe/unit-plans/U-093[Mvp].md
    - vibe/ref/nanobanana-mcp.md (CRT í…Œë§ˆ ì•„íŠ¸ ë””ë ‰ì…˜)
"""

from __future__ import annotations

import asyncio
import hashlib
import logging
from datetime import UTC, datetime
from enum import StrEnum
from pathlib import Path
from typing import TYPE_CHECKING

from pydantic import BaseModel, ConfigDict, Field

from unknown_world.storage.paths import build_image_url, get_generated_images_dir

if TYPE_CHECKING:
    from unknown_world.services.image_generation import ImageGeneratorType

# =============================================================================
# ë¡œê±° ì„¤ì •
# =============================================================================

logger = logging.getLogger(__name__)


# =============================================================================
# ìƒìˆ˜ ì •ì˜
# =============================================================================

# Q2 ê²°ì •: ì•„ì´ì½˜ ì‚¬ì´ì¦ˆ 64x64
ICON_SIZE = 64
"""ì•„ì´ì½˜ í¬ê¸° (í”½ì…€)."""

ICON_IMAGE_SIZE = f"{ICON_SIZE}x{ICON_SIZE}"
"""ì´ë¯¸ì§€ ìƒì„±ìš© ì‚¬ì´ì¦ˆ ë¬¸ìì—´."""

# Q3 ê²°ì •: í”½ì…€ ì•„íŠ¸ ìŠ¤íƒ€ì¼ (CRT phosphor ì•„íŠ¸ ë””ë ‰ì…˜)
# U-092: nanobanana-mcp í”„ë¡¬í”„íŠ¸ ìŠ¤íƒ€ì¼ ì ìš© (í€„ë¦¬í‹° í–¥ìƒ)
# ì°¸ì¡°: vibe/ref/nanobanana-mcp.md Â§1 ê³µí†µ ì•„íŠ¸ ë””ë ‰ì…˜, Â§2.1 UI ì•„ì´ì½˜ í…œí”Œë¦¿
ICON_STYLE_PROMPT = """
minimal retro CRT phosphor style icon,
high contrast pixel art aesthetic,
sharp edges, clean silhouette, no anti-aliasing,
single centered object on solid dark background (#0d0d0d),
vibrant colors from CRT phosphor palette (#33ff00 green, #ff00ff magenta, #ffaa00 amber, #ff3333 red),
no text, no decorations, no shadows, no complex gradients
"""

# ì•„ì´ì½˜ ìºì‹œ ë””ë ‰í† ë¦¬
ICON_CACHE_SUBDIR = "icons"

# ë°±ê·¸ë¼ìš´ë“œ ìƒì„± íƒ€ì„ì•„ì›ƒ (U-093: 30ì´ˆ â†’ 90ì´ˆ ìƒí–¥)
ICON_GENERATION_TIMEOUT_SECONDS = 90

# U-093: ì¬ì‹œë„ ì„¤ì • (Q1: Option B - ìµœëŒ€ 1íšŒ ì¬ì‹œë„, ì´ 2íšŒ ì‹œë„)
ICON_MAX_RETRIES = 1
"""ìµœëŒ€ ì¬ì‹œë„ íšŸìˆ˜."""

ICON_RETRY_BASE_DELAY_SECONDS = 2.0
"""ì¬ì‹œë„ ê¸°ë³¸ ëŒ€ê¸° ì‹œê°„ (ì´ˆ). ì§€ìˆ˜ ë°±ì˜¤í”„ ì ìš©: delay * 2^(attempt-1)."""

# ì¬ì‹œë„ ì œì™¸ í‚¤ì›Œë“œ (4xx í´ë¼ì´ì–¸íŠ¸ ì—ëŸ¬, quota ì´ˆê³¼, ì•ˆì „ ì°¨ë‹¨)
_NON_RETRYABLE_KEYWORDS = frozenset(
    {
        "quota",
        "rate_limit",
        "rate limit",
        "billing",
        "safety",
        "blocked",
        "invalid",
        "permission",
        "authentication",
        "authorization",
    }
)


class IconGenerationStatus(StrEnum):
    """ì•„ì´ì½˜ ìƒì„± ìƒíƒœ."""

    PENDING = "pending"
    """ìƒì„± ëŒ€ê¸° ì¤‘ (placeholder ë°˜í™˜)"""

    GENERATING = "generating"
    """ìƒì„± ì¤‘"""

    COMPLETED = "completed"
    """ìƒì„± ì™„ë£Œ"""

    FAILED = "failed"
    """ìƒì„± ì‹¤íŒ¨ (placeholder ì‚¬ìš©)"""

    CACHED = "cached"
    """ìºì‹œì—ì„œ ë°˜í™˜"""


# =============================================================================
# ìš”ì²­/ì‘ë‹µ ëª¨ë¸
# =============================================================================


class IconGenerationRequest(BaseModel):
    """ì•„ì´ì½˜ ìƒì„± ìš”ì²­.

    Attributes:
        item_id: ì•„ì´í…œ ê³ ìœ  ID
        item_description: ì•„ì´í…œ ì„¤ëª… (ì•„ì´ì½˜ ìƒì„±ìš©)
        language: í˜„ì¬ ì„¸ì…˜ ì–¸ì–´ (ko-KR/en-US)
    """

    model_config = ConfigDict(extra="forbid")

    item_id: str = Field(description="ì•„ì´í…œ ê³ ìœ  ID")
    item_description: str = Field(description="ì•„ì´í…œ ì„¤ëª… (ì•„ì´ì½˜ ìƒì„±ìš©)")
    language: str = Field(default="ko-KR", description="í˜„ì¬ ì„¸ì…˜ ì–¸ì–´")


class IconGenerationResponse(BaseModel):
    """ì•„ì´ì½˜ ìƒì„± ì‘ë‹µ.

    Attributes:
        status: ìƒì„± ìƒíƒœ
        icon_url: ì•„ì´ì½˜ URL (ì„±ê³µ ë˜ëŠ” placeholder)
        item_id: ì•„ì´í…œ ID
        is_placeholder: placeholder ì•„ì´ì½˜ ì—¬ë¶€
        generation_time_ms: ìƒì„± ì†Œìš” ì‹œê°„ (ë°€ë¦¬ì´ˆ)
        message: ìƒíƒœ ë©”ì‹œì§€
    """

    model_config = ConfigDict(extra="forbid")

    status: IconGenerationStatus
    icon_url: str = Field(description="ì•„ì´ì½˜ URL")
    item_id: str = Field(description="ì•„ì´í…œ ID")
    is_placeholder: bool = Field(default=False, description="placeholder ì•„ì´ì½˜ ì—¬ë¶€")
    generation_time_ms: int = Field(default=0, description="ìƒì„± ì†Œìš” ì‹œê°„ (ms)")
    message: str | None = Field(default=None, description="ìƒíƒœ ë©”ì‹œì§€")


# =============================================================================
# ì•„ì´ì½˜ ìºì‹œ
# =============================================================================


class IconCache:
    """ì•„ì´í…œ ì•„ì´ì½˜ ìºì‹œ.

    ë©”ëª¨ë¦¬ ìºì‹œ + íŒŒì¼ ì‹œìŠ¤í…œ ìºì‹œë¥¼ ì‚¬ìš©í•˜ì—¬ ë™ì¼ ì•„ì´í…œ ì¬ìƒì„±ì„ ë°©ì§€í•©ë‹ˆë‹¤.
    ìºì‹œ í‚¤ëŠ” ì•„ì´í…œ ì„¤ëª…ì˜ MD5 í•´ì‹œì…ë‹ˆë‹¤.
    """

    def __init__(self, cache_dir: Path | None = None) -> None:
        """IconCacheë¥¼ ì´ˆê¸°í™”í•©ë‹ˆë‹¤.

        Args:
            cache_dir: ìºì‹œ ë””ë ‰í† ë¦¬ (ê¸°ë³¸: .data/images/generated/icons)
        """
        self._cache_dir = cache_dir or get_generated_images_dir() / ICON_CACHE_SUBDIR
        self._cache_dir.mkdir(parents=True, exist_ok=True)
        self._memory_cache: dict[str, str] = {}  # cache_key â†’ icon_url

        logger.info(
            "[IconCache] ì´ˆê¸°í™” ì™„ë£Œ",
            extra={"cache_dir": str(self._cache_dir)},
        )

    def _make_cache_key(self, item_description: str) -> str:
        """ìºì‹œ í‚¤ë¥¼ ìƒì„±í•©ë‹ˆë‹¤ (MD5 í•´ì‹œ).

        Args:
            item_description: ì•„ì´í…œ ì„¤ëª…

        Returns:
            str: MD5 í•´ì‹œ (32ì)
        """
        return hashlib.md5(item_description.encode()).hexdigest()

    def get(self, item_description: str) -> str | None:
        """ìºì‹œì—ì„œ ì•„ì´ì½˜ URLì„ ì¡°íšŒí•©ë‹ˆë‹¤.

        Args:
            item_description: ì•„ì´í…œ ì„¤ëª…

        Returns:
            str | None: ìºì‹œëœ ì•„ì´ì½˜ URL ë˜ëŠ” None
        """
        cache_key = self._make_cache_key(item_description)

        # ë©”ëª¨ë¦¬ ìºì‹œ í™•ì¸
        if cache_key in self._memory_cache:
            logger.debug(
                "[IconCache] ë©”ëª¨ë¦¬ ìºì‹œ íˆíŠ¸",
                extra={"cache_key": cache_key[:8]},
            )
            return self._memory_cache[cache_key]

        # íŒŒì¼ ìºì‹œ í™•ì¸
        cache_path = self._cache_dir / f"{cache_key}.png"
        if cache_path.exists():
            icon_url = build_image_url(f"{ICON_CACHE_SUBDIR}/{cache_key}.png", category="generated")
            self._memory_cache[cache_key] = icon_url
            logger.debug(
                "[IconCache] íŒŒì¼ ìºì‹œ íˆíŠ¸",
                extra={"cache_key": cache_key[:8]},
            )
            return icon_url

        return None

    def set(self, item_description: str, image_data: bytes) -> str:
        """ìºì‹œì— ì•„ì´ì½˜ì„ ì €ì¥í•©ë‹ˆë‹¤ (64x64 ë¦¬ì‚¬ì´ì§• í¬í•¨).

        Args:
            item_description: ì•„ì´í…œ ì„¤ëª…
            image_data: ì´ë¯¸ì§€ ë°”ì´íŠ¸ ë°ì´í„°

        Returns:
            str: ì €ì¥ëœ ì•„ì´ì½˜ì˜ URL
        """
        import io

        from PIL import Image

        cache_key = self._make_cache_key(item_description)
        cache_path = self._cache_dir / f"{cache_key}.png"

        # ë¦¬ì‚¬ì´ì§• (U-075 í•«í”½ìŠ¤: ëª¨ë¸ ìƒì„±ë³¸ 1024x1024 -> 64x64)
        try:
            with Image.open(io.BytesIO(image_data)) as img:
                # 64x64ë¡œ ë¦¬ì‚¬ì´ì§• (LANCZOS í•„í„°ë¡œ í’ˆì§ˆ ìœ ì§€)
                if img.size != (ICON_SIZE, ICON_SIZE):
                    img = img.resize((ICON_SIZE, ICON_SIZE), Image.Resampling.LANCZOS)  # type: ignore[reportUnknownMemberType]

                # ë°”ì´íŠ¸ë¡œ ë‹¤ì‹œ ë³€í™˜í•˜ì—¬ ì €ì¥
                output = io.BytesIO()
                img.save(output, format="PNG")
                processed_data = output.getvalue()
                cache_path.write_bytes(processed_data)

                logger.debug(
                    "[IconCache] ì´ë¯¸ì§€ ë¦¬ì‚¬ì´ì§• ì™„ë£Œ",
                    extra={
                        "original_size": f"{img.size[0]}x{img.size[1]}",
                        "target_size": f"{ICON_SIZE}x{ICON_SIZE}",
                    },
                )
        except Exception as e:
            logger.warning(
                "[IconCache] ë¦¬ì‚¬ì´ì§• ì‹¤íŒ¨, ì›ë³¸ ì €ì¥",
                extra={"error": str(e)},
            )
            cache_path.write_bytes(image_data)
            processed_data = image_data

        # URL ìƒì„± ë° ë©”ëª¨ë¦¬ ìºì‹œ ì €ì¥
        icon_url = build_image_url(f"{ICON_CACHE_SUBDIR}/{cache_key}.png", category="generated")
        self._memory_cache[cache_key] = icon_url

        logger.info(
            "[IconCache] ì•„ì´ì½˜ ìºì‹œ ì €ì¥",
            extra={
                "cache_key": cache_key[:8],
                "size_bytes": len(processed_data),
            },
        )

        return icon_url

    def get_cache_path(self, item_description: str) -> Path:
        """ìºì‹œ íŒŒì¼ ê²½ë¡œë¥¼ ë°˜í™˜í•©ë‹ˆë‹¤.

        Args:
            item_description: ì•„ì´í…œ ì„¤ëª…

        Returns:
            Path: ìºì‹œ íŒŒì¼ ê²½ë¡œ
        """
        cache_key = self._make_cache_key(item_description)
        return self._cache_dir / f"{cache_key}.png"


# =============================================================================
# ì¬ì‹œë„ íŒë³„ í—¬í¼ (U-093)
# =============================================================================


def _is_retryable_message(message: str) -> bool:
    """ì—ëŸ¬ ë©”ì‹œì§€ ê¸°ë°˜ìœ¼ë¡œ ì¬ì‹œë„ ê°€ëŠ¥ ì—¬ë¶€ë¥¼ íŒë‹¨í•©ë‹ˆë‹¤.

    ì¬ì‹œë„ ì œì™¸: 4xx í´ë¼ì´ì–¸íŠ¸ ì—ëŸ¬, quota ì´ˆê³¼, ì•ˆì „ ì°¨ë‹¨ ë“±.

    Args:
        message: ì—ëŸ¬ ë©”ì‹œì§€

    Returns:
        bool: ì¬ì‹œë„ ê°€ëŠ¥ ì—¬ë¶€
    """
    message_lower = message.lower()
    return not any(keyword in message_lower for keyword in _NON_RETRYABLE_KEYWORDS)


def _is_retryable_exception(exc: Exception) -> bool:
    """ì˜ˆì™¸ íƒ€ì… ê¸°ë°˜ìœ¼ë¡œ ì¬ì‹œë„ ê°€ëŠ¥ ì—¬ë¶€ë¥¼ íŒë‹¨í•©ë‹ˆë‹¤.

    ì¬ì‹œë„ ê°€ëŠ¥: ë„¤íŠ¸ì›Œí¬/ì„œë²„ ì—ëŸ¬ (ConnectionError, OSError ë“±).
    ì¬ì‹œë„ ì œì™¸: í´ë¼ì´ì–¸íŠ¸ ë¡œì§ ì—ëŸ¬ (ValueError, TypeError ë“±).

    Args:
        exc: ë°œìƒí•œ ì˜ˆì™¸

    Returns:
        bool: ì¬ì‹œë„ ê°€ëŠ¥ ì—¬ë¶€
    """
    non_retryable_types = (ValueError, TypeError, AttributeError, KeyError)
    return not isinstance(exc, non_retryable_types)


# =============================================================================
# ì•„ì´ì½˜ ìƒì„±ê¸°
# =============================================================================


class ItemIconGenerator:
    """ì•„ì´í…œ ì•„ì´ì½˜ ë™ì  ìƒì„±ê¸°.

    ì•„ì´í…œ ì„¤ëª…ì„ ê¸°ë°˜ìœ¼ë¡œ 64x64 í”½ì…€ ì•„íŠ¸ ì•„ì´ì½˜ì„ ìƒì„±í•©ë‹ˆë‹¤.
    Q1 ê²°ì •: placeholder ë¨¼ì € ë°˜í™˜ í›„ ë°±ê·¸ë¼ìš´ë“œì—ì„œ ìƒì„± (Option B)
    """

    def __init__(
        self,
        image_generator: ImageGeneratorType | None = None,
        cache: IconCache | None = None,
    ) -> None:
        """ItemIconGeneratorë¥¼ ì´ˆê¸°í™”í•©ë‹ˆë‹¤.

        Args:
            image_generator: ì´ë¯¸ì§€ ìƒì„±ê¸° (ê¸°ë³¸: get_image_generator())
            cache: ì•„ì´ì½˜ ìºì‹œ (ê¸°ë³¸: ìƒˆ ì¸ìŠ¤í„´ìŠ¤)
        """
        self._image_generator = image_generator
        self._cache = cache or IconCache()
        self._pending_generations: dict[str, asyncio.Task[IconGenerationResponse]] = {}
        self._completed_urls: dict[str, str] = {}  # item_id -> icon_url (ìµœê·¼ ì™„ë£Œëœ í•­ëª©)

        logger.info("[ItemIconGenerator] ì´ˆê¸°í™” ì™„ë£Œ")

    def _get_image_generator(self) -> ImageGeneratorType:
        """ì´ë¯¸ì§€ ìƒì„±ê¸°ë¥¼ lazy ë¡œë”©í•©ë‹ˆë‹¤."""
        if self._image_generator is None:
            from unknown_world.services.image_generation import get_image_generator

            self._image_generator = get_image_generator()
        return self._image_generator

    def _build_icon_prompt(self, item_description: str, language: str) -> str:
        """ì•„ì´ì½˜ ìƒì„± í”„ë¡¬í”„íŠ¸ë¥¼ êµ¬ì„±í•©ë‹ˆë‹¤.

        U-092: nanobanana-mcp í”„ë¡¬í”„íŠ¸ ìŠ¤íƒ€ì¼ ì ìš©.
        ì°¸ì¡°: vibe/ref/nanobanana-mcp.md Â§2.1 UI ì•„ì´ì½˜ í…œí”Œë¦¿

        Args:
            item_description: ì•„ì´í…œ ì„¤ëª…
            language: ì„¸ì…˜ ì–¸ì–´

        Returns:
            str: ì´ë¯¸ì§€ ìƒì„± í”„ë¡¬í”„íŠ¸
        """
        # ì–¸ì–´ë³„ ì§€ì‹œë¬¸
        lang_instruction = "í•œêµ­ì–´" if language == "ko-KR" else "English"

        # nanobanana í…œí”Œë¦¿ ê¸°ë°˜: "A minimal [SUBJECT] icon, retro CRT phosphor style..."
        # ëŸ°íƒ€ì„ ì œì•½: rembg ì—†ìœ¼ë¯€ë¡œ white ëŒ€ì‹  dark background ì‚¬ìš©
        return f"""\
A minimal icon of "{item_description}" ({lang_instruction}).

{ICON_STYLE_PROMPT}

Use the item's natural colors accented with CRT phosphor tones.
Background: solid dark #0d0d0d only. DO NOT use white or bright backgrounds.
{ICON_SIZE}x{ICON_SIZE} pixels, single centered object."""

    def get_placeholder_url(self, item_id: str) -> str:
        """placeholder ì•„ì´ì½˜ URLì„ ë°˜í™˜í•©ë‹ˆë‹¤.

        Args:
            item_id: ì•„ì´í…œ ID

        Returns:
            str: placeholder ì•„ì´ì½˜ URL
        """
        # ê¸°ë³¸ placeholder (ğŸ“¦ ì´ëª¨ì§€ ì‚¬ìš©)
        # ì‹¤ì œ êµ¬í˜„ì—ì„œëŠ” ì •ì  placeholder ì´ë¯¸ì§€ ê²½ë¡œë¥¼ ë°˜í™˜í•  ìˆ˜ ìˆìŒ
        return "/ui/icons/placeholder_item.png"

    async def generate_icon(
        self,
        request: IconGenerationRequest,
        *,
        wait_for_completion: bool = False,
    ) -> IconGenerationResponse:
        """ì•„ì´í…œ ì•„ì´ì½˜ì„ ìƒì„±í•©ë‹ˆë‹¤.

        Q1 ê²°ì • (Option B):
        - wait_for_completion=False: placeholder ì¦‰ì‹œ ë°˜í™˜, ë°±ê·¸ë¼ìš´ë“œ ìƒì„±
        - wait_for_completion=True: ìƒì„± ì™„ë£Œê¹Œì§€ ëŒ€ê¸°

        Args:
            request: ì•„ì´ì½˜ ìƒì„± ìš”ì²­
            wait_for_completion: ìƒì„± ì™„ë£Œê¹Œì§€ ëŒ€ê¸°í• ì§€ ì—¬ë¶€

        Returns:
            IconGenerationResponse: ìƒì„± ê²°ê³¼
        """
        start_time = datetime.now(UTC)

        # í”„ë¡¬í”„íŠ¸ í•´ì‹œ (ë¡œê¹…ìš©, ì›ë¬¸ ë…¸ì¶œ ê¸ˆì§€ - RULE-007)
        desc_hash = hashlib.md5(request.item_description.encode()).hexdigest()[:8]

        logger.debug(
            "[ItemIconGenerator] ì•„ì´ì½˜ ìƒì„± ìš”ì²­",
            extra={
                "item_id": request.item_id,
                "desc_hash": desc_hash,
                "language": request.language,
                "wait": wait_for_completion,
            },
        )

        # ìºì‹œ í™•ì¸
        cached_url = self._cache.get(request.item_description)
        if cached_url:
            elapsed_ms = int((datetime.now(UTC) - start_time).total_seconds() * 1000)
            return IconGenerationResponse(
                status=IconGenerationStatus.CACHED,
                icon_url=cached_url,
                item_id=request.item_id,
                is_placeholder=False,
                generation_time_ms=elapsed_ms,
                message="ìºì‹œì—ì„œ ì•„ì´ì½˜ì„ ë°˜í™˜í–ˆìŠµë‹ˆë‹¤.",
            )

        # Q1 Option B: ì¦‰ì‹œ ì‘ë‹µ ëª¨ë“œ (placeholder ë°˜í™˜)
        if not wait_for_completion:
            # ë°±ê·¸ë¼ìš´ë“œ ìƒì„± íƒœìŠ¤í¬ê°€ ì—†ìœ¼ë©´ ì‹œì‘
            if request.item_id not in self._pending_generations:
                task = asyncio.create_task(
                    self._generate_icon_internal(request),
                    name=f"icon_gen_{request.item_id}",
                )
                self._pending_generations[request.item_id] = task

                # íƒœìŠ¤í¬ ì™„ë£Œ ì‹œ ì •ë¦¬ ì½œë°±
                task.add_done_callback(
                    lambda t, item_id=request.item_id: self._pending_generations.pop(item_id, None)
                )

            elapsed_ms = int((datetime.now(UTC) - start_time).total_seconds() * 1000)
            return IconGenerationResponse(
                status=IconGenerationStatus.PENDING,
                icon_url=self.get_placeholder_url(request.item_id),
                item_id=request.item_id,
                is_placeholder=True,
                generation_time_ms=elapsed_ms,
                message="ë°±ê·¸ë¼ìš´ë“œì—ì„œ ì•„ì´ì½˜ì„ ìƒì„± ì¤‘ì…ë‹ˆë‹¤.",
            )

        # ë™ê¸° ìƒì„± ëª¨ë“œ (ì™„ë£Œê¹Œì§€ ëŒ€ê¸°)
        return await self._generate_icon_internal(request)

    async def _generate_icon_internal(
        self, request: IconGenerationRequest
    ) -> IconGenerationResponse:
        """ë‚´ë¶€ ì•„ì´ì½˜ ìƒì„± ë¡œì§ (U-093: ì¬ì‹œë„ ì§€ì›).

        ìµœëŒ€ ICON_MAX_RETRIESíšŒ ì¬ì‹œë„í•˜ë©°, ì§€ìˆ˜ ë°±ì˜¤í”„ë¥¼ ì ìš©í•©ë‹ˆë‹¤.
        ì¬ì‹œë„ ëŒ€ìƒ: íƒ€ì„ì•„ì›ƒ, ë„¤íŠ¸ì›Œí¬ ì—ëŸ¬, 5xx ì‘ë‹µ.
        ì¬ì‹œë„ ì œì™¸: 4xx í´ë¼ì´ì–¸íŠ¸ ì—ëŸ¬, quota ì´ˆê³¼, ì•ˆì „ ì°¨ë‹¨.

        Args:
            request: ì•„ì´ì½˜ ìƒì„± ìš”ì²­

        Returns:
            IconGenerationResponse: ìƒì„± ê²°ê³¼
        """
        start_time = datetime.now(UTC)
        desc_hash = hashlib.md5(request.item_description.encode()).hexdigest()[:8]
        max_attempts = ICON_MAX_RETRIES + 1  # ì´ ì‹œë„ íšŸìˆ˜ (U-093 Q1: Option B â†’ 2íšŒ)

        from unknown_world.services.image_generation import (
            ImageGenerationRequest,
            ImageGenerationStatus,
        )

        # í”„ë¡¬í”„íŠ¸ ë° ìš”ì²­ êµ¬ì„± (1íšŒë§Œ - ì¬ì‹œë„ ì‹œ ë™ì¼ í”„ë¡¬í”„íŠ¸ ì¬ì‚¬ìš©)
        prompt = self._build_icon_prompt(request.item_description, request.language)

        # U-091: rembg ëŸ°íƒ€ì„ ì œê±° - ë°°ê²½ ì œê±° ì—†ì´ í”„ë¡¬í”„íŠ¸ë¡œ ì–´ë‘ìš´ ë°°ê²½ ìœ ë„
        gen_request = ImageGenerationRequest(
            prompt=prompt,
            image_size="1024x1024",  # ëª¨ë¸ ì§€ì› í‘œì¤€ í•´ìƒë„ (U-075 í•«í”½ìŠ¤: 64x64 ë¯¸ì§€ì›)
            aspect_ratio="1:1",
            model_label="FAST",  # Q2: ì•„ì´ì½˜ì€ ì €ì§€ì—° ëª¨ë¸
        )

        last_error_message: str | None = None

        for attempt in range(1, max_attempts + 1):
            try:
                generator = self._get_image_generator()
                response = await asyncio.wait_for(
                    generator.generate(gen_request),
                    timeout=ICON_GENERATION_TIMEOUT_SECONDS,
                )

                elapsed_ms = int((datetime.now(UTC) - start_time).total_seconds() * 1000)

                if response.status == ImageGenerationStatus.COMPLETED and response.image_url:
                    # ì„±ê³µ: ìºì‹œì— ì €ì¥
                    if response.image_id:
                        src_path = get_generated_images_dir() / f"{response.image_id}.png"
                        if src_path.exists():
                            image_data = src_path.read_bytes()
                            cached_url = self._cache.set(request.item_description, image_data)
                            self._completed_urls[request.item_id] = cached_url
                            logger.info(
                                "[ItemIconGenerator] ì•„ì´ì½˜ ìƒì„± ì™„ë£Œ",
                                extra={
                                    "item_id": request.item_id,
                                    "desc_hash": desc_hash,
                                    "elapsed_ms": elapsed_ms,
                                    "attempt": attempt,
                                },
                            )
                            return IconGenerationResponse(
                                status=IconGenerationStatus.COMPLETED,
                                icon_url=cached_url,
                                item_id=request.item_id,
                                is_placeholder=False,
                                generation_time_ms=elapsed_ms,
                                message="ì•„ì´ì½˜ì´ ì„±ê³µì ìœ¼ë¡œ ìƒì„±ë˜ì—ˆìŠµë‹ˆë‹¤.",
                            )

                    # URL ì§ì ‘ ë°˜í™˜ (íŒŒì¼ ë³µì‚¬ ì‹¤íŒ¨ ì‹œ)
                    return IconGenerationResponse(
                        status=IconGenerationStatus.COMPLETED,
                        icon_url=response.image_url,
                        item_id=request.item_id,
                        is_placeholder=False,
                        generation_time_ms=elapsed_ms,
                        message="ì•„ì´ì½˜ì´ ìƒì„±ë˜ì—ˆìŠµë‹ˆë‹¤.",
                    )

                # API ë ˆë²¨ ì‹¤íŒ¨
                last_error_message = response.message or "ì•„ì´ì½˜ ìƒì„±ì— ì‹¤íŒ¨í–ˆìŠµë‹ˆë‹¤."

                # U-093: ì¬ì‹œë„ ê°€ëŠ¥ ì—¬ë¶€ íŒë‹¨ í›„ ì¬ì‹œë„
                if attempt < max_attempts and _is_retryable_message(last_error_message):
                    delay = ICON_RETRY_BASE_DELAY_SECONDS * (2 ** (attempt - 1))
                    logger.warning(
                        "[ItemIconGenerator] ì•„ì´ì½˜ ìƒì„± ì‹¤íŒ¨, ì¬ì‹œë„ ì˜ˆì •",
                        extra={
                            "item_id": request.item_id,
                            "desc_hash": desc_hash,
                            "attempt": f"{attempt}/{max_attempts}",
                            "retry_delay_s": delay,
                            "error_msg": last_error_message,
                        },
                    )
                    await asyncio.sleep(delay)
                    continue

                # ì¬ì‹œë„ ë¶ˆê°€ ë˜ëŠ” ë§ˆì§€ë§‰ ì‹œë„
                break

            except TimeoutError:
                last_error_message = f"ì•„ì´ì½˜ ìƒì„± íƒ€ì„ì•„ì›ƒ ({ICON_GENERATION_TIMEOUT_SECONDS}ì´ˆ)"

                # U-093: íƒ€ì„ì•„ì›ƒì€ í•­ìƒ ì¬ì‹œë„ ëŒ€ìƒ
                if attempt < max_attempts:
                    delay = ICON_RETRY_BASE_DELAY_SECONDS * (2 ** (attempt - 1))
                    logger.warning(
                        "[ItemIconGenerator] ì•„ì´ì½˜ ìƒì„± íƒ€ì„ì•„ì›ƒ, ì¬ì‹œë„ ì˜ˆì •",
                        extra={
                            "item_id": request.item_id,
                            "desc_hash": desc_hash,
                            "attempt": f"{attempt}/{max_attempts}",
                            "retry_delay_s": delay,
                            "timeout_seconds": ICON_GENERATION_TIMEOUT_SECONDS,
                        },
                    )
                    await asyncio.sleep(delay)
                    continue
                break

            except Exception as e:
                error_type = type(e).__name__
                last_error_message = f"ì•„ì´ì½˜ ìƒì„± ì¤‘ ì˜¤ë¥˜: {error_type}"

                # U-093: ì¬ì‹œë„ ê°€ëŠ¥ ì˜ˆì™¸ì¸ ê²½ìš°ë§Œ ì¬ì‹œë„
                if attempt < max_attempts and _is_retryable_exception(e):
                    delay = ICON_RETRY_BASE_DELAY_SECONDS * (2 ** (attempt - 1))
                    logger.warning(
                        "[ItemIconGenerator] ì•„ì´ì½˜ ìƒì„± ì¤‘ ì˜¤ë¥˜, ì¬ì‹œë„ ì˜ˆì •",
                        extra={
                            "item_id": request.item_id,
                            "desc_hash": desc_hash,
                            "attempt": f"{attempt}/{max_attempts}",
                            "retry_delay_s": delay,
                            "error_type": error_type,
                        },
                    )
                    await asyncio.sleep(delay)
                    continue

                # ì¬ì‹œë„ ë¶ˆê°€ ì—ëŸ¬ (ë¡œê¹… í›„ ì¢…ë£Œ)
                logger.exception(
                    "[ItemIconGenerator] ì•„ì´ì½˜ ìƒì„± ì¤‘ ë³µêµ¬ ë¶ˆê°€ ì˜¤ë¥˜",
                    extra={
                        "item_id": request.item_id,
                        "error_type": error_type,
                    },
                )
                break

        # ëª¨ë“  ì‹œë„ ì‹¤íŒ¨ â†’ placeholder ìœ ì§€ (RULE-004: ì•ˆì „í•œ í´ë°±)
        elapsed_ms = int((datetime.now(UTC) - start_time).total_seconds() * 1000)
        logger.warning(
            "[ItemIconGenerator] ì•„ì´ì½˜ ìƒì„± ìµœì¢… ì‹¤íŒ¨",
            extra={
                "item_id": request.item_id,
                "desc_hash": desc_hash,
                "total_attempts": max_attempts,
                "elapsed_ms": elapsed_ms,
            },
        )
        return IconGenerationResponse(
            status=IconGenerationStatus.FAILED,
            icon_url=self.get_placeholder_url(request.item_id),
            item_id=request.item_id,
            is_placeholder=True,
            generation_time_ms=elapsed_ms,
            message=f"ì•„ì´ì½˜ ìƒì„± ì‹¤íŒ¨ ({max_attempts}/{max_attempts} ì‹œë„): {last_error_message}",
        )

    async def get_icon_status(
        self, item_id: str, request: IconGenerationRequest | None = None
    ) -> IconGenerationStatus:
        """ì•„ì´ì½˜ ìƒì„± ìƒíƒœë¥¼ í™•ì¸í•©ë‹ˆë‹¤.

        Args:
            item_id: ì•„ì´í…œ ID
            request: ì•„ì´ì½˜ ìƒì„± ìš”ì²­ (ìºì‹œ í™•ì¸ìš©)

        Returns:
            IconGenerationStatus: í˜„ì¬ ìƒíƒœ
        """
        # í˜„ì¬ ì§„í–‰ ì¤‘ì¸ íƒœìŠ¤í¬ í™•ì¸
        if item_id in self._pending_generations:
            task = self._pending_generations[item_id]
            if task.done():
                return IconGenerationStatus.COMPLETED
            return IconGenerationStatus.GENERATING

        # ìµœê·¼ ì™„ë£Œëœ í•­ëª© í™•ì¸
        if item_id in self._completed_urls:
            return IconGenerationStatus.COMPLETED

        # ìºì‹œ í™•ì¸ (requestê°€ ìˆëŠ” ê²½ìš°)
        if request and self._cache.get(request.item_description):
            return IconGenerationStatus.COMPLETED

        return IconGenerationStatus.PENDING


# =============================================================================
# ì‹±ê¸€í†¤ ì¸ìŠ¤í„´ìŠ¤
# =============================================================================

_generator_instance: ItemIconGenerator | None = None


def get_item_icon_generator() -> ItemIconGenerator:
    """ItemIconGenerator ì‹±ê¸€í†¤ ì¸ìŠ¤í„´ìŠ¤ë¥¼ ë°˜í™˜í•©ë‹ˆë‹¤."""
    global _generator_instance
    if _generator_instance is None:
        _generator_instance = ItemIconGenerator()
    return _generator_instance


def reset_item_icon_generator() -> None:
    """í…ŒìŠ¤íŠ¸ìš© ì‹±ê¸€í†¤ ë¦¬ì…‹."""
    global _generator_instance
    _generator_instance = None
</file>

<file path="backend/src/unknown_world/validation/business_rules.py">
"""Unknown World - ë¹„ì¦ˆë‹ˆìŠ¤ ë£° ê²€ì¦ê¸° (Hard Gate).

ìŠ¤í‚¤ë§ˆ ê²€ì¦ ì´í›„ì—ë„ ë‚¨ëŠ” "ì˜ë¯¸ì  ì‹¤íŒ¨"ë¥¼ ê²€ì¦í•©ë‹ˆë‹¤:
- Economy: cost/balance_after ì¼ê´€ì„±, ì”ì•¡ ìŒìˆ˜ ê¸ˆì§€
- Language: TurnInput.languageì™€ TurnOutput.language ë¶ˆì¼ì¹˜ ì°¨ë‹¨
- Box2D: 0~1000 ë²”ìœ„ + [ymin,xmin,ymax,xmax] ìˆœì„œ ê²€ì¦
- Safety: blocked ì‹œ ì•ˆì „í•œ ëŒ€ì²´ ê²°ê³¼ ì œê³µ í™•ì¸

ì„¤ê³„ ì›ì¹™:
    - RULE-003: êµ¬ì¡°í™” ì¶œë ¥(JSON Schema) ìš°ì„  + ì´ì¤‘ ê²€ì¦
    - RULE-004: ê²€ì¦ ì‹¤íŒ¨ ì‹œ Repair loop + ì•ˆì „í•œ í´ë°±
    - RULE-005: ì¬í™” ì¸ë°”ë¦¬ì–¸íŠ¸ (ì”ì•¡ ìŒìˆ˜ ê¸ˆì§€)
    - RULE-006: ko/en ì–¸ì–´ ì •ì±… ì¤€ìˆ˜
    - RULE-009: ì¢Œí‘œ ê·œì•½ (0~1000, bbox [ymin,xmin,ymax,xmax])

ì°¸ì¡°:
    - vibe/unit-plans/U-018[Mvp].md
    - vibe/unit-results/U-017[Mvp].md
"""

from __future__ import annotations

import logging
from dataclasses import dataclass, field
from enum import StrEnum
from typing import TYPE_CHECKING

from unknown_world.config.economy import MAX_CREDIT
from unknown_world.models.turn import Language
from unknown_world.validation.language_gate import (
    LanguageGateResult,
    build_language_error_summary,
    validate_language_consistency,
)

if TYPE_CHECKING:
    from unknown_world.models.turn import TurnInput, TurnOutput

# =============================================================================
# ë¡œê±° ì„¤ì •
# =============================================================================

logger = logging.getLogger(__name__)


# =============================================================================
# i18n ì—ëŸ¬ ë©”ì‹œì§€ (RULE-006: ko/en ì–¸ì–´ ì •ì±… ì¤€ìˆ˜)
# =============================================================================

BUSINESS_RULE_MESSAGES: dict[Language, dict[str, str]] = {
    Language.KO: {
        "summary_header": "ë‹¤ìŒ ë¹„ì¦ˆë‹ˆìŠ¤ ë£°ì„ ìœ„ë°˜í–ˆìŠµë‹ˆë‹¤:",
        "signal_insufficient": "Signal ì¬í™”ê°€ ë¶€ì¡±í•©ë‹ˆë‹¤: ë³´ìœ  {have}, í•„ìš” {need}",
        "memory_shard_insufficient": "Memory Shard ì¬í™”ê°€ ë¶€ì¡±í•©ë‹ˆë‹¤: ë³´ìœ  {have}, í•„ìš” {need}",
        "signal_negative": "Signal ì”ì•¡ì´ ìŒìˆ˜ì…ë‹ˆë‹¤: {value}",
        "memory_shard_negative": "Memory Shard ì”ì•¡ì´ ìŒìˆ˜ì…ë‹ˆë‹¤: {value}",
        "signal_mismatch": "Signal ì”ì•¡ ë¶ˆì¼ì¹˜: ì˜ˆìƒ {expected}, ì‹¤ì œ {actual}",
        "memory_shard_mismatch": "Memory Shard ì”ì•¡ ë¶ˆì¼ì¹˜: ì˜ˆìƒ {expected}, ì‹¤ì œ {actual}",
        "language_mismatch": "ì–¸ì–´ ë¶ˆì¼ì¹˜: ì…ë ¥ {input_lang}, ì¶œë ¥ {output_lang}",
        "language_content_mixed": "ì–¸ì–´ í˜¼í•© ê°ì§€: {violation_count}ê°œ í•„ë“œì—ì„œ ko/en í˜¼í•© ë°œê²¬",
        "box2d_out_of_range": "ì˜¤ë¸Œì íŠ¸ '{obj_id}'ì˜ ì¢Œí‘œê°€ ë²”ìœ„ë¥¼ ë²—ì–´ë‚¨: {coord}",
        "box2d_invalid_yorder": "ì˜¤ë¸Œì íŠ¸ '{obj_id}'ì˜ ymin({ymin}) >= ymax({ymax})",
        "box2d_invalid_xorder": "ì˜¤ë¸Œì íŠ¸ '{obj_id}'ì˜ xmin({xmin}) >= xmax({xmax})",
        "safety_blocked_no_fallback": "ì•ˆì „ ì •ì±…ì— ì˜í•´ ì°¨ë‹¨ë˜ì—ˆì§€ë§Œ ëŒ€ì²´ í…ìŠ¤íŠ¸ê°€ ì—†ìŠµë‹ˆë‹¤",
    },
    Language.EN: {
        "summary_header": "The following business rules were violated:",
        "signal_insufficient": "Insufficient Signal: have {have}, need {need}",
        "memory_shard_insufficient": "Insufficient Memory Shard: have {have}, need {need}",
        "signal_negative": "Signal balance is negative: {value}",
        "memory_shard_negative": "Memory Shard balance is negative: {value}",
        "signal_mismatch": "Signal balance mismatch: expected {expected}, actual {actual}",
        "memory_shard_mismatch": "Memory Shard balance mismatch: expected {expected}, actual {actual}",
        "language_mismatch": "Language mismatch: input {input_lang}, output {output_lang}",
        "language_content_mixed": "Language mixing detected: {violation_count} fields contain ko/en mixing",
        "box2d_out_of_range": "Object '{obj_id}' coordinate out of range: {coord}",
        "box2d_invalid_yorder": "Object '{obj_id}' ymin({ymin}) >= ymax({ymax})",
        "box2d_invalid_xorder": "Object '{obj_id}' xmin({xmin}) >= xmax({xmax})",
        "safety_blocked_no_fallback": "Blocked by safety policy but no fallback text provided",
    },
}


# =============================================================================
# ì—ëŸ¬ íƒ€ì…
# =============================================================================


class BusinessRuleError(StrEnum):
    """ë¹„ì¦ˆë‹ˆìŠ¤ ë£° ìœ„ë°˜ íƒ€ì…."""

    # Economy ê·œì¹™ (RULE-005)
    ECONOMY_NEGATIVE_BALANCE = "economy_negative_balance"
    """ì”ì•¡ì´ ìŒìˆ˜ì…ë‹ˆë‹¤ (ê¸ˆì§€)"""

    ECONOMY_COST_MISMATCH = "economy_cost_mismatch"
    """ë¹„ìš©ê³¼ ì”ì•¡ ë³€í™”ê°€ ì¼ì¹˜í•˜ì§€ ì•ŠìŠµë‹ˆë‹¤"""

    ECONOMY_COST_MISSING = "economy_cost_missing"
    """ë¹„ìš© ì •ë³´ê°€ ëˆ„ë½ë˜ì—ˆìŠµë‹ˆë‹¤"""

    # Language ê·œì¹™ (RULE-006)
    LANGUAGE_MISMATCH = "language_mismatch"
    """ì…ë ¥ê³¼ ì¶œë ¥ ì–¸ì–´ê°€ ì¼ì¹˜í•˜ì§€ ì•ŠìŠµë‹ˆë‹¤"""

    LANGUAGE_CONTENT_MIXED = "language_content_mixed"
    """ì‚¬ìš©ì ë…¸ì¶œ í…ìŠ¤íŠ¸ì— ko/enì´ í˜¼í•©ë˜ì–´ ìˆìŠµë‹ˆë‹¤ (U-043)"""

    # Box2D ê·œì¹™ (RULE-009)
    BOX2D_OUT_OF_RANGE = "box2d_out_of_range"
    """ì¢Œí‘œê°€ 0~1000 ë²”ìœ„ë¥¼ ë²—ì–´ë‚¬ìŠµë‹ˆë‹¤"""

    BOX2D_INVALID_ORDER = "box2d_invalid_order"
    """bbox ìˆœì„œê°€ ì˜¬ë°”ë¥´ì§€ ì•ŠìŠµë‹ˆë‹¤ (ymin < ymax, xmin < xmax í•„ìš”)"""

    # Safety ê·œì¹™
    SAFETY_BLOCKED_NO_FALLBACK = "safety_blocked_no_fallback"
    """ì°¨ë‹¨ë˜ì—ˆì§€ë§Œ ì•ˆì „í•œ ëŒ€ì²´ ê²°ê³¼ê°€ ì œê³µë˜ì§€ ì•Šì•˜ìŠµë‹ˆë‹¤"""


# =============================================================================
# ê²€ì¦ ê²°ê³¼ íƒ€ì…
# =============================================================================


@dataclass
class BusinessRuleValidationResult:
    """ë¹„ì¦ˆë‹ˆìŠ¤ ë£° ê²€ì¦ ê²°ê³¼.

    Attributes:
        is_valid: ëª¨ë“  ê²€ì¦ í†µê³¼ ì—¬ë¶€
        errors: ë°œê²¬ëœ ìœ„ë°˜ ëª©ë¡
        error_summary: ì—ëŸ¬ ìš”ì•½ (Repair í”„ë¡¬í”„íŠ¸ìš©)
        language: ì‘ë‹µ ì–¸ì–´ (RULE-006)
        language_gate_result: ì–¸ì–´ í˜¼í•© ê²€ì¦ ê²°ê³¼ (U-043)
    """

    is_valid: bool = True
    errors: list[dict[str, str]] = field(default_factory=lambda: [])
    error_summary: str = ""
    language: Language = Language.KO
    language_gate_result: LanguageGateResult | None = None

    def add_error(self, error_type: BusinessRuleError, message: str) -> None:
        """ì—ëŸ¬ë¥¼ ì¶”ê°€í•©ë‹ˆë‹¤."""
        self.is_valid = False
        self.errors.append({"type": error_type.value, "message": message})

    def build_summary(self) -> str:
        """ì—ëŸ¬ ìš”ì•½ì„ ìƒì„±í•©ë‹ˆë‹¤ (Repair í”„ë¡¬í”„íŠ¸ìš©).

        ì–¸ì–´ì— ë”°ë¼ í—¤ë” ë©”ì‹œì§€ë¥¼ ë¶„ê¸°í•©ë‹ˆë‹¤ (RULE-006).
        ì–¸ì–´ í˜¼í•© ì—ëŸ¬ê°€ ìˆìœ¼ë©´ ìƒì„¸ ì§€ì‹œë¥¼ ì¶”ê°€í•©ë‹ˆë‹¤ (U-043).
        """
        if not self.errors:
            self.error_summary = ""
            return ""

        messages = BUSINESS_RULE_MESSAGES[self.language]
        summary_lines = [messages["summary_header"]]
        for err in self.errors:
            summary_lines.append(f"- {err['message']}")

        # U-043: ì–¸ì–´ í˜¼í•© ì—ëŸ¬ê°€ ìˆìœ¼ë©´ ìƒì„¸ ì§€ì‹œ ì¶”ê°€
        if self.language_gate_result and not self.language_gate_result.is_valid:
            summary_lines.append("")
            summary_lines.append(build_language_error_summary(self.language_gate_result))

        self.error_summary = "\n".join(summary_lines)
        return self.error_summary


# =============================================================================
# ê°œë³„ ê²€ì¦ í•¨ìˆ˜
# =============================================================================


def _validate_economy(
    turn_input: TurnInput,
    turn_output: TurnOutput,
    result: BusinessRuleValidationResult,
) -> None:
    """Economy ê·œì¹™ì„ ê²€ì¦í•©ë‹ˆë‹¤ (RULE-005).

    ê²€ì¦ í•­ëª©:
    - ì”ì•¡ ìŒìˆ˜ ê¸ˆì§€
    - snapshot ëŒ€ë¹„ ê³¼ë„í•œ ë¹„ìš© ì²­êµ¬ ê¸ˆì§€ (U-079: í¬ë ˆë”§ í—ˆìš©)
    - costì™€ balance_after ì¼ê´€ì„±
    """
    economy = turn_output.economy
    snapshot = turn_input.economy_snapshot
    messages = BUSINESS_RULE_MESSAGES[result.language]

    # 1. ê³¼ë„í•œ ë¹„ìš© ì²­êµ¬ ê¸ˆì§€ (snapshot < cost)
    # U-079: í¬ë ˆë”§(ë¹š)ì„ í—ˆìš©í•˜ì—¬ ì”ì•¡ë³´ë‹¤ í° ë¹„ìš© ì§€ë¶ˆ ê°€ëŠ¥
    # í—ˆìš© ë²”ìœ„: snapshot.signal + MAX_CREDIT >= cost.signal
    effective_signal = snapshot.signal + MAX_CREDIT

    if effective_signal < economy.cost.signal:
        result.add_error(
            BusinessRuleError.ECONOMY_NEGATIVE_BALANCE,
            messages["signal_insufficient"].format(have=snapshot.signal, need=economy.cost.signal),
        )

    if snapshot.memory_shard < economy.cost.memory_shard:
        result.add_error(
            BusinessRuleError.ECONOMY_NEGATIVE_BALANCE,
            messages["memory_shard_insufficient"].format(
                have=snapshot.memory_shard, need=economy.cost.memory_shard
            ),
        )

    # 2. ì”ì•¡ ìŒìˆ˜ ê¸ˆì§€ (ì´ë¯¸ í•„ë“œ ìˆ˜ì¤€ ge=0 ê²€ì¦ì´ ìˆì§€ë§Œ, ë¹„ì¦ˆë‹ˆìŠ¤ ë£°ì—ì„œë„ ëª…ì‹œ)
    if economy.balance_after.signal < 0:
        result.add_error(
            BusinessRuleError.ECONOMY_NEGATIVE_BALANCE,
            messages["signal_negative"].format(value=economy.balance_after.signal),
        )

    if economy.balance_after.memory_shard < 0:
        result.add_error(
            BusinessRuleError.ECONOMY_NEGATIVE_BALANCE,
            messages["memory_shard_negative"].format(value=economy.balance_after.memory_shard),
        )

    # 3. costì™€ balance_after ì¼ê´€ì„± ê²€ì¦
    # balance_after = snapshot - cost + credit_delta ì—¬ì•¼ í•¨
    # (ë˜ëŠ” credit í•„ë“œê°€ ì‚¬ìš© ì¤‘ì¸ ì´ ë¹šì„ ë‚˜íƒ€ëƒ„)
    # U-079 ë‹¨ìˆœí™”: balance_after.signal = max(0, snapshot.signal - cost.signal)
    # credit = max(0, cost.signal - snapshot.signal)
    expected_signal = max(0, snapshot.signal - economy.cost.signal)
    expected_shard = max(0, snapshot.memory_shard - economy.cost.memory_shard)
    expected_credit = max(0, economy.cost.signal - snapshot.signal)

    if economy.balance_after.signal != expected_signal:
        result.add_error(
            BusinessRuleError.ECONOMY_COST_MISMATCH,
            messages["signal_mismatch"].format(
                expected=expected_signal, actual=economy.balance_after.signal
            ),
        )

    if economy.balance_after.memory_shard != expected_shard:
        result.add_error(
            BusinessRuleError.ECONOMY_COST_MISMATCH,
            messages["memory_shard_mismatch"].format(
                expected=expected_shard, actual=economy.balance_after.memory_shard
            ),
        )

    # credit ì¼ê´€ì„± ê²€ì¦
    if economy.credit != expected_credit:
        result.add_error(
            BusinessRuleError.ECONOMY_COST_MISMATCH,
            f"Credit mismatch: expected {expected_credit}, actual {economy.credit}",
        )


def _validate_language(
    turn_input: TurnInput,
    turn_output: TurnOutput,
    result: BusinessRuleValidationResult,
) -> None:
    """Language ê·œì¹™ì„ ê²€ì¦í•©ë‹ˆë‹¤ (RULE-006).

    ê²€ì¦ í•­ëª©:
    - TurnInput.languageì™€ TurnOutput.language ì¼ì¹˜
    """
    if turn_input.language != turn_output.language:
        messages = BUSINESS_RULE_MESSAGES[result.language]
        result.add_error(
            BusinessRuleError.LANGUAGE_MISMATCH,
            messages["language_mismatch"].format(
                input_lang=turn_input.language.value,
                output_lang=turn_output.language.value,
            ),
        )


def _validate_language_content(
    turn_input: TurnInput,
    turn_output: TurnOutput,
    result: BusinessRuleValidationResult,
) -> None:
    """Language ì½˜í…ì¸  í˜¼í•©ì„ ê²€ì¦í•©ë‹ˆë‹¤ (RULE-006, U-043).

    ê²€ì¦ í•­ëª©:
    - ì‚¬ìš©ì ë…¸ì¶œ í…ìŠ¤íŠ¸ê°€ TurnInput.languageì™€ ë™ì¼ ì–¸ì–´ì¸ì§€ í™•ì¸
    - ko/en í˜¼í•© ì‹œ LANGUAGE_CONTENT_MIXED ì—ëŸ¬ ì¶”ê°€
    """
    # ì–¸ì–´ í˜¼í•© ê²€ì¦ (U-043)
    lang_result = validate_language_consistency(turn_output, turn_input.language)

    if not lang_result.is_valid:
        messages = BUSINESS_RULE_MESSAGES[result.language]
        result.add_error(
            BusinessRuleError.LANGUAGE_CONTENT_MIXED,
            messages["language_content_mixed"].format(violation_count=len(lang_result.violations)),
        )
        # ìƒì„¸ ì—ëŸ¬ ìš”ì•½ ìƒì„±ì„ ìœ„í•´ ê²°ê³¼ ì €ì¥
        result.language_gate_result = lang_result


def _validate_box2d(
    turn_output: TurnOutput,
    result: BusinessRuleValidationResult,
) -> None:
    """Box2D ì¢Œí‘œ ê·œì¹™ì„ ê²€ì¦í•©ë‹ˆë‹¤ (RULE-009).

    ê²€ì¦ í•­ëª©:
    - 0~1000 ë²”ìœ„
    - ymin < ymax, xmin < xmax ìˆœì„œ
    """
    messages = BUSINESS_RULE_MESSAGES[result.language]

    # UI ì˜¤ë¸Œì íŠ¸ì˜ box2d ê²€ì¦
    for obj in turn_output.ui.objects:
        box = obj.box_2d

        # ë²”ìœ„ ê²€ì¦ (0~1000)
        coords = [box.ymin, box.xmin, box.ymax, box.xmax]
        for coord in coords:
            if coord < 0 or coord > 1000:
                result.add_error(
                    BusinessRuleError.BOX2D_OUT_OF_RANGE,
                    messages["box2d_out_of_range"].format(obj_id=obj.id, coord=coord),
                )
                break  # í•œ ì˜¤ë¸Œì íŠ¸ì— ëŒ€í•´ í•œ ë²ˆë§Œ ë³´ê³ 

        # ìˆœì„œ ê²€ì¦ (ymin < ymax, xmin < xmax)
        if box.ymin >= box.ymax:
            result.add_error(
                BusinessRuleError.BOX2D_INVALID_ORDER,
                messages["box2d_invalid_yorder"].format(
                    obj_id=obj.id, ymin=box.ymin, ymax=box.ymax
                ),
            )

        if box.xmin >= box.xmax:
            result.add_error(
                BusinessRuleError.BOX2D_INVALID_ORDER,
                messages["box2d_invalid_xorder"].format(
                    obj_id=obj.id, xmin=box.xmin, xmax=box.xmax
                ),
            )


def _validate_safety(
    turn_output: TurnOutput,
    result: BusinessRuleValidationResult,
) -> None:
    """Safety ê·œì¹™ì„ ê²€ì¦í•©ë‹ˆë‹¤.

    ê²€ì¦ í•­ëª©:
    - blocked ì‹œ ì•ˆì „í•œ ëŒ€ì²´ ê²°ê³¼(narrative) ì œê³µ í™•ì¸
    """
    safety = turn_output.safety
    messages = BUSINESS_RULE_MESSAGES[result.language]

    # ì°¨ë‹¨ ì‹œì—ë„ narrativeê°€ ìˆì–´ì•¼ í•¨ (ì•ˆì „í•œ ëŒ€ì²´ ê²°ê³¼)
    if safety.blocked and (not turn_output.narrative or len(turn_output.narrative.strip()) == 0):
        result.add_error(
            BusinessRuleError.SAFETY_BLOCKED_NO_FALLBACK,
            messages["safety_blocked_no_fallback"],
        )


# =============================================================================
# ë©”ì¸ ê²€ì¦ í•¨ìˆ˜
# =============================================================================


def validate_business_rules(
    turn_input: TurnInput,
    turn_output: TurnOutput,
) -> BusinessRuleValidationResult:
    """ë¹„ì¦ˆë‹ˆìŠ¤ ë£°ì„ ê²€ì¦í•©ë‹ˆë‹¤.

    ìŠ¤í‚¤ë§ˆ ê²€ì¦ ì´í›„ í˜¸ì¶œë˜ë©°, ì˜ë¯¸ì  ê·œì¹™ì„ ê²€ì¦í•©ë‹ˆë‹¤.
    ì—ëŸ¬ ë©”ì‹œì§€ëŠ” turn_input.languageì— ë”°ë¼ ë¶„ê¸°ë©ë‹ˆë‹¤ (RULE-006).

    Args:
        turn_input: ì‚¬ìš©ì í„´ ì…ë ¥
        turn_output: ìƒì„±ëœ í„´ ì¶œë ¥

    Returns:
        BusinessRuleValidationResult: ê²€ì¦ ê²°ê³¼

    Example:
        >>> result = validate_business_rules(turn_input, turn_output)
        >>> if not result.is_valid:
        ...     print(result.build_summary())
    """
    # RU-005-S2: turn_input.languageì— ë”°ë¼ ì—ëŸ¬ ë©”ì‹œì§€ i18n ë¶„ê¸°
    result = BusinessRuleValidationResult(language=turn_input.language)

    # 1. Economy ê²€ì¦ (RULE-005)
    _validate_economy(turn_input, turn_output, result)

    # 2. Language enum ê²€ì¦ (RULE-006)
    _validate_language(turn_input, turn_output, result)

    # 3. Language ì½˜í…ì¸  í˜¼í•© ê²€ì¦ (RULE-006, U-043)
    _validate_language_content(turn_input, turn_output, result)

    # 4. Box2D ê²€ì¦ (RULE-009)
    _validate_box2d(turn_output, result)

    # 5. Safety ê²€ì¦
    _validate_safety(turn_output, result)

    # ì—ëŸ¬ ìš”ì•½ ìƒì„±
    if not result.is_valid:
        result.build_summary()
        logger.warning(
            "[BusinessRules] ê²€ì¦ ì‹¤íŒ¨",
            extra={"error_count": len(result.errors)},
        )

    return result
</file>

<file path="backend/tests/unit/services/test_genai_client.py">
import os
from unittest.mock import AsyncMock, MagicMock, patch

import pytest

from unknown_world.config.models import (
    MODEL_FAST,
    MODEL_IMAGE,
    MODEL_QUALITY,
    MODEL_VISION,
    ModelLabel,
    get_model_id,
)
from unknown_world.services.genai_client import (
    ENV_GOOGLE_API_KEY,
    ENV_UW_MODE,
    GenAIClient,
    GenAIMode,
    GenerateRequest,
    GenerateResponse,
    MockGenAIClient,
    get_genai_client,
    reset_genai_client,
)


def test_model_id_mapping():
    """ModelLabelì´ tech-stack.mdì˜ IDì™€ ì˜¬ë°”ë¥´ê²Œ ë§¤í•‘ë˜ëŠ”ì§€ í™•ì¸í•©ë‹ˆë‹¤."""
    assert get_model_id(ModelLabel.FAST) == MODEL_FAST
    assert get_model_id(ModelLabel.QUALITY) == MODEL_QUALITY
    assert get_model_id(ModelLabel.IMAGE) == MODEL_IMAGE
    assert get_model_id(ModelLabel.VISION) == MODEL_VISION

    assert MODEL_FAST == "gemini-3-flash-preview"
    assert MODEL_QUALITY == "gemini-3-pro-preview"
    assert MODEL_IMAGE == "gemini-3-pro-image-preview"


def test_get_genai_client_mock_mode():
    """UW_MODE=mockì¼ ë•Œ MockGenAIClientê°€ ë°˜í™˜ë˜ëŠ”ì§€ í™•ì¸í•©ë‹ˆë‹¤."""
    reset_genai_client()
    with patch.dict(os.environ, {ENV_UW_MODE: "mock"}):
        client = get_genai_client(force_new=True)
        assert isinstance(client, MockGenAIClient)
        assert client.mode == GenAIMode.MOCK


@pytest.mark.asyncio
async def test_mock_client_generate():
    """MockGenAIClientì˜ generate ë©”ì„œë“œ ë™ì‘ì„ í™•ì¸í•©ë‹ˆë‹¤."""
    client = MockGenAIClient()
    request = GenerateRequest(prompt="test prompt", model_label=ModelLabel.FAST)
    response = await client.generate(request)

    assert isinstance(response, GenerateResponse)
    assert "[Mock Response]" in response.text
    assert response.model_label == ModelLabel.FAST
    assert "total_tokens" in response.usage


@pytest.mark.asyncio
async def test_mock_client_generate_stream():
    """MockGenAIClientì˜ generate_stream ë©”ì„œë“œ ë™ì‘ì„ í™•ì¸í•©ë‹ˆë‹¤."""
    client = MockGenAIClient()
    request = GenerateRequest(prompt="test prompt", model_label=ModelLabel.QUALITY)

    chunks = []
    async for chunk in client.generate_stream(request):
        chunks.append(chunk)

    assert len(chunks) > 0
    assert any(ModelLabel.QUALITY in c for c in chunks)


def test_singleton_pattern():
    """get_genai_clientê°€ ì‹±ê¸€í†¤ìœ¼ë¡œ ë™ì‘í•˜ëŠ”ì§€ í™•ì¸í•©ë‹ˆë‹¤."""
    reset_genai_client()
    with patch.dict(os.environ, {ENV_UW_MODE: "mock"}):
        client1 = get_genai_client()
        client2 = get_genai_client()
        assert client1 is client2


def test_genai_client_initialization():
    """GenAIClient(real)ê°€ API í‚¤ë¡œ SDKë¥¼ ì˜¬ë°”ë¥´ê²Œ ì´ˆê¸°í™”í•˜ëŠ”ì§€ í™•ì¸í•©ë‹ˆë‹¤."""
    with patch("google.genai.Client") as mock_genai_client:
        api_key = "test-api-key"
        with patch.dict(os.environ, {ENV_GOOGLE_API_KEY: api_key}):
            client = GenAIClient()

            # genai.Clientê°€ api_keyì™€ í•¨ê»˜ í˜¸ì¶œë˜ì—ˆëŠ”ì§€ í™•ì¸
            mock_genai_client.assert_called_once_with(api_key=api_key)
            assert client.is_available() is True


@pytest.mark.asyncio
async def test_genai_client_generate_real_call():
    """GenAIClientê°€ SDKì˜ generate_contentë¥¼ ì˜¬ë°”ë¥´ê²Œ í˜¸ì¶œí•˜ëŠ”ì§€ í™•ì¸í•©ë‹ˆë‹¤."""
    with patch("google.genai.Client") as mock_client_class:
        mock_instance = mock_client_class.return_value
        # mock aio.models.generate_content
        mock_response = MagicMock()
        mock_response.text = "Actual response"
        mock_response.candidates = [MagicMock(finish_reason="STOP")]
        mock_response.usage_metadata = MagicMock(
            prompt_token_count=10, candidates_token_count=20, total_token_count=30
        )

        mock_instance.aio.models.generate_content = AsyncMock(return_value=mock_response)

        api_key = "test-api-key"
        with patch.dict(os.environ, {ENV_GOOGLE_API_KEY: api_key}):
            client = GenAIClient()
            request = GenerateRequest(
                prompt="hello", model_label=ModelLabel.QUALITY, max_tokens=100
            )

            response = await client.generate(request)

            # U-060: í˜¸ì¶œ ì¸ì í™•ì¸
            mock_instance.aio.models.generate_content.assert_called_once()
            call_kwargs = mock_instance.aio.models.generate_content.call_args.kwargs
            assert call_kwargs["model"] == MODEL_QUALITY
            assert call_kwargs["contents"] == "hello"
            # configëŠ” GenerateContentConfig ê°ì²´ì´ë¯€ë¡œ ì†ì„± ê²€ì¦
            config = call_kwargs["config"]
            assert config is not None
            assert config.max_output_tokens == 100
            assert response.text == "Actual response"
            assert response.usage["total_tokens"] == 30


def test_genai_client_initialization_failure():
    """ì¸ì¦ ì˜¤ë¥˜ ë“±ìœ¼ë¡œ SDK ì´ˆê¸°í™” ì‹¤íŒ¨ ì‹œ ë™ì‘ì„ í™•ì¸í•©ë‹ˆë‹¤."""
    with patch("google.genai.Client", side_effect=Exception("Auth error")):
        client = GenAIClient()
        assert client.is_available() is False
        assert client.mode == GenAIMode.REAL


def test_get_genai_client_force_new():
    """force_new=Trueì¼ ë•Œ ìƒˆ ì¸ìŠ¤í„´ìŠ¤ê°€ ìƒì„±ë˜ëŠ”ì§€ í™•ì¸í•©ë‹ˆë‹¤."""
    reset_genai_client()
    with patch.dict(os.environ, {ENV_UW_MODE: "mock"}):
        client1 = get_genai_client()
        client2 = get_genai_client(force_new=True)
        assert client1 is not client2


@pytest.mark.asyncio
async def test_genai_client_generate_stream_real_call():
    """GenAIClientê°€ ìŠ¤íŠ¸ë¦¬ë° í˜¸ì¶œì„ ì˜¬ë°”ë¥´ê²Œ ìˆ˜í–‰í•˜ëŠ”ì§€ í™•ì¸í•©ë‹ˆë‹¤."""
    with patch("google.genai.Client") as mock_client_class:
        mock_instance = mock_client_class.return_value

        # mock aio.models.generate_content_stream
        async def mock_stream():
            yield MagicMock(text="chunk1")
            yield MagicMock(text="chunk2")

        mock_instance.aio.models.generate_content_stream = AsyncMock(return_value=mock_stream())

        api_key = "test-api-key"
        with patch.dict(os.environ, {ENV_GOOGLE_API_KEY: api_key}):
            client = GenAIClient()
            request = GenerateRequest(prompt="hello", model_label=ModelLabel.FAST)

            chunks = []
            async for chunk in client.generate_stream(request):
                chunks.append(chunk)

            assert chunks == ["chunk1", "chunk2"]
            mock_instance.aio.models.generate_content_stream.assert_called_once()


@pytest.mark.asyncio
async def test_genai_client_unavailable_raises_error():
    """ì‚¬ìš© ë¶ˆê°€ëŠ¥í•œ í´ë¼ì´ì–¸íŠ¸ í˜¸ì¶œ ì‹œ RuntimeErrorê°€ ë°œìƒí•˜ëŠ”ì§€ í™•ì¸í•©ë‹ˆë‹¤."""
    with patch("google.genai.Client", side_effect=Exception("Init error")):
        client = GenAIClient()
        assert client.is_available() is False

        request = GenerateRequest(prompt="hi")
        with pytest.raises(RuntimeError, match="ì´ˆê¸°í™”ë˜ì§€ ì•Šì•˜ìŠµë‹ˆë‹¤"):
            await client.generate(request)

        with pytest.raises(RuntimeError, match="ì´ˆê¸°í™”ë˜ì§€ ì•Šì•˜ìŠµë‹ˆë‹¤"):
            async for _ in client.generate_stream(request):
                pass


@pytest.mark.asyncio
async def test_genai_client_full_config():
    """max_tokensì™€ temperatureê°€ SDK í˜¸ì¶œ ì‹œ ì˜¬ë°”ë¥´ê²Œ ì „ë‹¬ë˜ëŠ”ì§€ í™•ì¸í•©ë‹ˆë‹¤."""
    with patch("google.genai.Client") as mock_client_class:
        mock_instance = mock_client_class.return_value
        mock_instance.aio.models.generate_content = AsyncMock(return_value=MagicMock(text="ok"))

        async def mock_stream():
            yield MagicMock(text="ok")

        mock_instance.aio.models.generate_content_stream = AsyncMock(return_value=mock_stream())

        api_key = "test-api-key"
        with patch.dict(os.environ, {ENV_GOOGLE_API_KEY: api_key}):
            client = GenAIClient()
            request = GenerateRequest(prompt="hi", max_tokens=50, temperature=0.7)

            # generate í˜¸ì¶œ ê²€ì¦
            # U-060: GenerateContentConfig ê°ì²´ë¡œ ì „ë‹¬ë˜ë¯€ë¡œ íƒ€ì… + í•µì‹¬ ì†ì„± ê²€ì¦
            await client.generate(request)
            mock_instance.aio.models.generate_content.assert_called_once()
            gen_call_kwargs = mock_instance.aio.models.generate_content.call_args.kwargs
            assert gen_call_kwargs["model"] == MODEL_FAST
            assert gen_call_kwargs["contents"] == "hi"
            gen_config = gen_call_kwargs["config"]
            assert gen_config is not None
            assert gen_config.max_output_tokens == 50
            assert gen_config.temperature == 0.7

            # generate_stream í˜¸ì¶œ ê²€ì¦
            async for _ in client.generate_stream(request):
                pass
            mock_instance.aio.models.generate_content_stream.assert_called_once()
            stream_call_kwargs = mock_instance.aio.models.generate_content_stream.call_args.kwargs
            assert stream_call_kwargs["model"] == MODEL_FAST
            assert stream_call_kwargs["contents"] == "hi"
            stream_config = stream_call_kwargs["config"]
            assert stream_config is not None
            assert stream_config.max_output_tokens == 50
            assert stream_config.temperature == 0.7


def test_get_genai_client_real_init_failure_fallback():
    """ì‹¤ì œ í´ë¼ì´ì–¸íŠ¸ ì´ˆê¸°í™” ì‹¤íŒ¨ ì‹œ Mock í´ë¼ì´ì–¸íŠ¸ë¡œ í´ë°±ë˜ëŠ”ì§€ í™•ì¸í•©ë‹ˆë‹¤."""
    reset_genai_client()
    with (
        patch.dict(os.environ, {ENV_UW_MODE: "real"}),
        patch("unknown_world.services.genai_client.GenAIClient.is_available", return_value=False),
    ):
        client = get_genai_client(force_new=True)
        assert isinstance(client, MockGenAIClient)


def test_reset_genai_client():
    """reset_genai_clientê°€ ìºì‹œë¥¼ ì˜¬ë°”ë¥´ê²Œ ë¹„ìš°ëŠ”ì§€ í™•ì¸í•©ë‹ˆë‹¤."""
    reset_genai_client()
    with patch.dict(os.environ, {ENV_UW_MODE: "mock"}):
        client1 = get_genai_client()
        reset_genai_client()
        client2 = get_genai_client()
        assert client1 is not client2


def test_mock_client_is_available():
    """MockGenAIClientê°€ í•­ìƒ ì‚¬ìš© ê°€ëŠ¥í•œì§€ í™•ì¸í•©ë‹ˆë‹¤."""
    client = MockGenAIClient()
    assert client.is_available() is True


def test_get_genai_client_invalid_mode():
    """ìœ íš¨í•˜ì§€ ì•Šì€ UW_MODEì¼ ë•Œ ê¸°ë³¸ê°’(REAL)ìœ¼ë¡œ ë™ì‘í•˜ëŠ”ì§€ í™•ì¸í•©ë‹ˆë‹¤."""
    reset_genai_client()
    with (
        patch.dict(os.environ, {ENV_UW_MODE: "invalid"}),
        patch(
            "unknown_world.services.genai_client.GenAIClient", return_value=MagicMock()
        ) as mock_real,
    ):
        get_genai_client(force_new=True)
        mock_real.assert_called_once()


def test_get_genai_client_force_mock():
    """force_mock=Trueì¼ ë•Œ í™˜ê²½ë³€ìˆ˜ì™€ ë¬´ê´€í•˜ê²Œ Mock í´ë¼ì´ì–¸íŠ¸ë¥¼ ë°˜í™˜í•˜ëŠ”ì§€ í™•ì¸í•©ë‹ˆë‹¤."""
    reset_genai_client()
    with patch.dict(os.environ, {ENV_UW_MODE: "real"}):
        client = get_genai_client(force_mock=True, force_new=True)
        assert isinstance(client, MockGenAIClient)
</file>

<file path="frontend/src/components/ActionDeck.test.tsx">
import { describe, it, expect, vi, beforeEach } from 'vitest';
import { render, screen, fireEvent } from '@testing-library/react';
import { ActionDeck } from './ActionDeck';
import type { ActionCard } from '../schemas/turn';
import { useActionDeckStore } from '../stores/actionDeckStore';
import { useWorldStore } from '../stores/worldStore';
import { useAgentStore } from '../stores/agentStore';

// i18next ëª¨í‚¹
vi.mock('react-i18next', () => ({
  useTranslation: () => ({
    t: (key: string, params?: Record<string, unknown>) => {
      if (params?.turn !== undefined) return `Turn ${params.turn}`;
      if (key === 'action.risk.low') return 'Low';
      if (key === 'action.risk.medium') return 'Medium';
      if (key === 'action.risk.high') return 'High';
      if (key === 'action.insufficient_balance') return 'Insufficient Balance';
      if (key === 'action.alternative') return 'Alt';
      return key;
    },
  }),
  initReactI18next: {
    type: '3rdParty',
    init: () => {},
  },
}));

// U-065: ë‹¨ìˆœí™”ëœ ActionCard ìŠ¤í‚¤ë§ˆ (ì œê±°ë¨: description, cost_estimate, hint, reward_hint, disabled_reason)
describe('ActionDeck Component', () => {
  const mockCards: ActionCard[] = [
    {
      id: 'card-1',
      label: 'Regular Action',
      cost: { signal: 10, memory_shard: 0 },
      risk: 'low',
      enabled: true,
      is_alternative: false,
    },
    {
      id: 'card-2',
      label: 'Expensive Action',
      cost: { signal: 50, memory_shard: 1 },
      risk: 'high',
      enabled: true,
      is_alternative: false,
    },
    {
      id: 'card-alt',
      label: 'Alternative Action',
      cost: { signal: 2, memory_shard: 0 },
      risk: 'low',
      enabled: true,
      is_alternative: true,
    },
  ];

  beforeEach(() => {
    // ìŠ¤í† ì–´ ì´ˆê¸°í™”
    useActionDeckStore.setState({ cards: [] });
    useWorldStore.setState({ economy: { signal: 100, memory_shard: 5, credit: 0 } });
    useAgentStore.setState({ isStreaming: false });
  });

  it('renders provided cards from store', () => {
    useActionDeckStore.setState({ cards: mockCards });
    render(<ActionDeck />);
    expect(screen.getByText('Regular Action')).toBeInTheDocument();
    expect(screen.getByText('Expensive Action')).toBeInTheDocument();
    expect(screen.getByText('Alternative Action')).toBeInTheDocument();
  });

  // U-065: cost_estimate ì œê±°ë¨, costë§Œ í‘œì‹œ
  it('displays cost values', () => {
    useActionDeckStore.setState({ cards: mockCards });
    render(<ActionDeck />);
    // card-1 has cost: 10
    expect(screen.getByText('10')).toBeInTheDocument();
    // card-2 has cost: 50
    expect(screen.getByText('50')).toBeInTheDocument();
  });

  // U-065: cost_estimate ì œê±°ë¨, costë§Œ ì‚¬ìš©
  it('disables cards when balance is insufficient in worldStore', () => {
    useActionDeckStore.setState({ cards: mockCards });
    useWorldStore.setState({ economy: { signal: 5, memory_shard: 0, credit: 0 } });

    render(<ActionDeck />);

    // Regular Action (cost 10) -> disabled
    const card1 = screen.getByRole('button', { name: /Regular Action/i });
    expect(card1).toBeDisabled();
    expect(screen.getAllByText('Insufficient Balance').length).toBeGreaterThan(0);

    // Alternative Action (cost 2) -> enabled
    const cardAlt = screen.getByRole('button', { name: /Alternative Action/i });
    expect(cardAlt).not.toBeDisabled();
  });

  it('renders alternative badge for alternative cards', () => {
    useActionDeckStore.setState({ cards: mockCards });
    render(<ActionDeck />);
    expect(screen.getByText('Alt')).toBeInTheDocument();
  });

  it('calls onCardClick when an enabled card is clicked', () => {
    const onCardClick = vi.fn();
    useActionDeckStore.setState({ cards: mockCards });
    render(<ActionDeck onCardClick={onCardClick} />);

    fireEvent.click(screen.getByText('Regular Action'));
    expect(onCardClick).toHaveBeenCalledWith(expect.objectContaining({ id: 'card-1' }));
  });

  // U-065: disabled_reason ì œê±°ë¨, ì„œë²„ì—ì„œ enabled=falseë©´ ê¸°ë³¸ ë©”ì‹œì§€ í‘œì‹œ
  it('displays default disabled message when server disables card', () => {
    const disabledCard: ActionCard[] = [
      {
        ...mockCards[0],
        enabled: false,
      },
    ];
    useActionDeckStore.setState({ cards: disabledCard });
    render(<ActionDeck />);
    // action.server_disabled í‚¤ê°€ ê·¸ëŒ€ë¡œ ì¶œë ¥ë¨ (ëª¨í‚¹ì—ì„œ ì²˜ë¦¬ ì•ˆ ë¨)
    const card = screen.getByRole('button', { name: /Regular Action/i });
    expect(card).toBeDisabled();
  });

  it('renders default cards when store cards are empty', () => {
    useActionDeckStore.setState({ cards: [] });
    render(<ActionDeck />);
    // useDefaultCards should provide some default labels
    expect(screen.getByText('action.default.explore.label')).toBeInTheDocument();
  });

  it('disables all cards when isStreaming is true in agentStore', () => {
    useActionDeckStore.setState({ cards: mockCards });
    useAgentStore.setState({ isStreaming: true });

    render(<ActionDeck />);

    const card1 = screen.getByRole('button', { name: /Regular Action/i });
    const cardAlt = screen.getByRole('button', { name: /Alternative Action/i });

    expect(card1).toBeDisabled();
    expect(cardAlt).toBeDisabled();
  });

  describe('Badge Layout (U-083)', () => {
    it('renders multiple badges (VISION + EARN) simultaneously', () => {
      // earn_ ì ‘ë‘ì‚¬ê°€ ìˆê³  VISION_TRIGGER_ACTION_IDSì— í¬í•¨ëœ ID
      const complexCard: ActionCard[] = [
        {
          id: 'earn_ì •ë°€ë¶„ì„',
          label: 'Complex Action',
          cost: { signal: 5, memory_shard: 0 },
          risk: 'medium',
          enabled: true,
          is_alternative: false,
        },
      ];
      useActionDeckStore.setState({ cards: complexCard });
      render(<ActionDeck />);

      // VISION ë±ƒì§€ (ğŸ” action.vision_badge)
      expect(screen.getByText(/action\.vision_badge/)).toBeInTheDocument();
      // EARN ë±ƒì§€ (âš¡ action.earn_badge)
      expect(screen.getByText(/action\.earn_badge/)).toBeInTheDocument();
    });

    it('limits visible badges to 2 and shows overflow count', () => {
      // VISION + EARN + ALT = 3ê°œ
      const threeBadgesCard: ActionCard[] = [
        {
          id: 'earn_ì •ë°€ë¶„ì„',
          label: 'Three Badges',
          cost: { signal: 5, memory_shard: 0 },
          risk: 'medium',
          enabled: true,
          is_alternative: true, // ìˆ˜ì •ëœ ë¡œì§ì— ì˜í•´ ë‹¤ë¥¸ ë±ƒì§€ê°€ ìˆì–´ë„ ì¶”ê°€ë¨
        },
      ];
      useActionDeckStore.setState({ cards: threeBadgesCard });
      render(<ActionDeck />);

      // VISIONê³¼ EARNì€ í‘œì‹œë˜ì–´ì•¼ í•¨ (collectBadges ìˆœì„œìƒ)
      expect(screen.getByText(/action\.vision_badge/)).toBeInTheDocument();
      expect(screen.getByText(/action\.earn_badge/)).toBeInTheDocument();

      // ALTëŠ” 3ë²ˆì§¸ì´ë¯€ë¡œ ìˆ¨ê²¨ì§€ê³  +1ì´ ë‚˜íƒ€ë‚˜ì•¼ í•¨
      expect(screen.queryByText('Alt')).not.toBeInTheDocument();
      expect(screen.getByText('+1')).toBeInTheDocument();
    });

    it('shows alternative badge only when no other badges are present', () => {
      const altOnlyCard: ActionCard[] = [
        {
          id: 'simple-alt',
          label: 'Alt Only',
          cost: { signal: 1, memory_shard: 0 },
          risk: 'low',
          enabled: true,
          is_alternative: true,
        },
      ];
      useActionDeckStore.setState({ cards: altOnlyCard });
      render(<ActionDeck />);

      expect(screen.getByText('Alt')).toBeInTheDocument();
    });
  });
});
</file>

<file path="frontend/src/components/DndInteraction.test.tsx">
import React from 'react';
import { describe, it, expect, vi, beforeEach, afterEach } from 'vitest';
import { render, screen, act, fireEvent, waitFor } from '@testing-library/react';
import App from '../App';
import * as turnStream from '../api/turnStream';

// dnd-kit ëª¨í‚¹ìš© íƒ€ì…
interface MockDndCallbacks {
  onDragEnd: (event: {
    active: { id: string; data: { current: unknown } };
    over: { id: string; data: { current: unknown } } | null;
  }) => void;
}

// dnd-kit ëª¨í‚¹ (ì½œë°± ê°€ë¡œì±„ê¸°ìš©)
vi.mock('@dnd-kit/core', async () => {
  const actual = (await vi.importActual('@dnd-kit/core')) as Record<string, unknown>;
  return {
    ...actual,
    DndContext: (props: MockDndCallbacks & { children: React.ReactNode }) => {
      // ì½œë°± ì €ì¥ (í…ŒìŠ¤íŠ¸ì—ì„œ ì ‘ê·¼ ê°€ëŠ¥í•˜ë„ë¡ globalì— ì €ì¥)
      (global as unknown as Record<string, unknown>).dndCallbacks = props;
      return <div data-testid="mock-dnd-context">{props.children}</div>;
    },
  };
});

// i18next ëª¨í‚¹ (RU-003-Q5: ë°ëª¨ i18n í‚¤ ì§€ì›)
vi.mock('react-i18next', () => ({
  useTranslation: () => ({
    t: (key: string, options?: Record<string, unknown>) => {
      // ë°ëª¨ ì•„ì´í…œ ì´ë¦„
      if (key === 'demo.items.keycard-alpha.name') return 'í‚¤ì¹´ë“œ A';
      if (key === 'demo.items.medkit.name') return 'ì‘ê¸‰ í‚¤íŠ¸';
      if (key === 'demo.items.flashlight.name') return 'ì†ì „ë“±';
      if (key === 'demo.items.data-chip.name') return 'ë°ì´í„°ì¹©';
      // ë°ëª¨ ì”¬ ì˜¤ë¸Œì íŠ¸
      if (key === 'demo.scene.terminal.label') return 'í„°ë¯¸ë„';
      if (key === 'demo.scene.terminal.hint') return 'í™œì„±í™”ëœ í„°ë¯¸ë„ì´ë‹¤';
      if (key === 'demo.scene.door.label') return 'ë¬¸';
      if (key === 'demo.scene.door.hint') return 'ì ê²¨ìˆëŠ” ê²ƒ ê°™ë‹¤';
      // ì•¡ì…˜ í…œí”Œë¦¿
      if (key === 'inventory.item_label') return `Item: ${options?.name}`;
      if (key === 'scene.hotspot.drop_action') {
        return `Drop: ${options?.item} on ${options?.target}`;
      }
      if (key === 'scene.hotspot.drop_invalid') {
        return `Invalid: ${options?.item}`;
      }
      if (key === 'action_log.use_item_on_hotspot') {
        return `Action: Use ${options?.item} on ${options?.hotspot}`;
      }
      if (key === 'connection.online') return 'ONLINE';
      return key;
    },
    i18n: {
      changeLanguage: () => Promise.resolve(),
      resolvedLanguage: 'ko-KR',
    },
  }),
  initReactI18next: {
    type: '3rdParty',
    init: () => {},
  },
}));

// ResizeObserver ëª¨í‚¹
class MockResizeObserver {
  observe = vi.fn();
  unobserve = vi.fn();
  disconnect = vi.fn();
}
global.ResizeObserver = MockResizeObserver as unknown as typeof ResizeObserver;
window.ResizeObserver = MockResizeObserver as unknown as typeof ResizeObserver;

// api ëª¨í‚¹
vi.mock('../api/turnStream', () => ({
  startTurnStream: vi.fn(),
}));

describe('DnD Interaction - Logic Test', () => {
  beforeEach(() => {
    vi.clearAllMocks();
    localStorage.clear();

    // prefers-reduced-motion ëª¨í‚¹ (NarrativeFeedì—ì„œ ì‚¬ìš©)
    // trueë¡œ ì„¤ì •í•˜ì—¬ íƒ€ì´í•‘ íš¨ê³¼ë¥¼ ìƒëµí•˜ê³  ì¦‰ì‹œ í…ìŠ¤íŠ¸ê°€ í‘œì‹œë˜ê²Œ í•¨
    Object.defineProperty(window, 'matchMedia', {
      writable: true,
      value: vi.fn().mockImplementation((query) => ({
        matches: query === '(prefers-reduced-motion: reduce)',
        media: query,
        onchange: null,
        addListener: vi.fn(),
        removeListener: vi.fn(),
        addEventListener: vi.fn(),
        removeEventListener: vi.fn(),
        dispatchEvent: vi.fn(),
      })),
    });
  });

  afterEach(() => {
    //
  });

  it('should trigger turn execution when handleDragEnd is called with a hotspot target', async () => {
    render(<App />);

    // 1. í”„ë¡œí•„ ì„ íƒ (Playing í˜ì´ì¦ˆ ì§„ì…)
    const narratorProfile = screen.getByLabelText('profile.narrator.name');
    fireEvent.click(narratorProfile);

    // U-060: í”„ë¡œí•„ ì„ íƒ í›„ DndContext ë§ˆìš´íŠ¸ë¥¼ ê¸°ë‹¤ë¦¼
    // DndContextê°€ ë Œë”ë§ëœ í›„ ì½œë°± ê°€ì ¸ì˜¤ê¸°
    const dndCallbacks = await waitFor(() => {
      const callbacks = (global as unknown as Record<string, MockDndCallbacks>).dndCallbacks;
      expect(callbacks).toBeDefined();
      expect(callbacks.onDragEnd).toBeDefined();
      return callbacks;
    });

    // RU-003-Q1: ë“œë˜ê·¸ ë°ì´í„°ì— item ê°ì²´ í¬í•¨ (íƒ€ì… ê°€ë“œ ìš”êµ¬ì‚¬í•­)
    const mockItem = {
      id: 'keycard-alpha',
      name: 'í‚¤ì¹´ë“œ A',
      icon: 'ğŸ”‘',
      quantity: 1,
    };

    // ì„±ê³µ ì‹œë‚˜ë¦¬ì˜¤ ì‹œë®¬ë ˆì´ì…˜
    act(() => {
      dndCallbacks.onDragEnd({
        active: {
          id: 'keycard-alpha',
          data: {
            current: {
              type: 'inventory-item',
              item_id: 'keycard-alpha',
              item: mockItem,
            },
          },
        },
        over: {
          id: 'hotspot-demo-terminal',
          data: {
            current: {
              type: 'hotspot',
              object_id: 'demo-terminal',
              label: 'í„°ë¯¸ë„',
              box_2d: { ymin: 300, xmin: 100, ymax: 600, xmax: 400 },
            },
          },
        },
      });
    });

    // startTurnStream í˜¸ì¶œ í™•ì¸
    await waitFor(() => {
      expect(turnStream.startTurnStream).toHaveBeenCalled();
    });
    const [input] = vi.mocked(turnStream.startTurnStream).mock.calls[0];

    expect(input.text).toBe('Drop: í‚¤ì¹´ë“œ A on í„°ë¯¸ë„');
    expect(input.drop).toEqual({
      item_id: 'keycard-alpha',
      target_object_id: 'demo-terminal',
      target_box_2d: { ymin: 300, xmin: 100, ymax: 600, xmax: 400 },
    });

    // U-070: ë“œë¡­ ì¦‰ì‹œ NarrativeFeedì— ì•¡ì…˜ ë¡œê·¸ê°€ í‘œì‹œë˜ì–´ì•¼ í•¨
    const actionLog = await screen.findByText(/Action: Use í‚¤ì¹´ë“œ A on í„°ë¯¸ë„/);
    expect(actionLog).toBeInTheDocument();
    expect(actionLog.closest('.narrative-entry')).toHaveClass('action-log-entry');
  });

  it('should show failure feedback when handleDragEnd is called with an invalid target', async () => {
    render(<App />);

    // 1. í”„ë¡œí•„ ì„ íƒ (Playing í˜ì´ì¦ˆ ì§„ì…)
    const narratorProfile = screen.getByLabelText('profile.narrator.name');
    fireEvent.click(narratorProfile);

    // U-060: í”„ë¡œí•„ ì„ íƒ í›„ DndContext ë§ˆìš´íŠ¸ë¥¼ ê¸°ë‹¤ë¦¼
    // DndContextê°€ ë Œë”ë§ëœ í›„ ì½œë°± ê°€ì ¸ì˜¤ê¸°
    const dndCallbacks = await waitFor(() => {
      const callbacks = (global as unknown as Record<string, MockDndCallbacks>).dndCallbacks;
      expect(callbacks).toBeDefined();
      expect(callbacks.onDragEnd).toBeDefined();
      return callbacks;
    });

    // RU-003-Q1: ë“œë˜ê·¸ ë°ì´í„°ì— item ê°ì²´ í¬í•¨ (íƒ€ì… ê°€ë“œ ìš”êµ¬ì‚¬í•­)
    const mockItem = {
      id: 'keycard-alpha',
      name: 'í‚¤ì¹´ë“œ A',
      icon: 'ğŸ”‘',
      quantity: 1,
    };

    // ì‹¤íŒ¨ ì‹œë‚˜ë¦¬ì˜¤ ì‹œë®¬ë ˆì´ì…˜ (overê°€ null)
    act(() => {
      dndCallbacks.onDragEnd({
        active: {
          id: 'keycard-alpha',
          data: {
            current: {
              type: 'inventory-item',
              item_id: 'keycard-alpha',
              item: mockItem,
            },
          },
        },
        over: null,
      });
    });

    // turn ì‹¤í–‰ì€ ë°œìƒí•˜ì§€ ì•Šì•„ì•¼ í•¨
    expect(turnStream.startTurnStream).not.toHaveBeenCalled();

    // ë‚´ëŸ¬í‹°ë¸Œ í”¼ë“œì— ì‹¤íŒ¨ ë©”ì‹œì§€ê°€ ë‚˜íƒ€ë‚˜ì•¼ í•¨
    const failureMessage = await screen.findByText(/Invalid: í‚¤ì¹´ë“œ A/);
    expect(failureMessage).toBeInTheDocument();
  });
});
</file>

<file path="frontend/src/components/EconomyHud.test.tsx">
import { describe, it, expect, beforeEach, vi } from 'vitest';
import { render, screen } from '@testing-library/react';
import { EconomyHud } from './EconomyHud';
import { useWorldStore } from '../stores/worldStore';
import { useEconomyStore } from '../stores/economyStore';

// react-i18next ëª¨í‚¹
vi.mock('react-i18next', () => ({
  useTranslation: () => ({
    t: (key: string) => key,
  }),
  initReactI18next: {
    type: '3rdParty',
    init: () => {},
  },
}));

describe('EconomyHud', () => {
  beforeEach(() => {
    useWorldStore.getState().reset();
    useEconomyStore.getState().reset();
    useEconomyStore.getState().clearLedger();
  });

  it('í˜„ì¬ ì”ì•¡ì„ ì˜¬ë°”ë¥´ê²Œ í‘œì‹œí•´ì•¼ í•œë‹¤', () => {
    useWorldStore.getState().setEconomy({ signal: 50, memory_shard: 5, credit: 0 });

    render(<EconomyHud />);

    expect(screen.getByTestId('signal-balance')).toHaveTextContent('50');
    expect(screen.getByTestId('shard-balance')).toHaveTextContent('5');
  });

  it('ì˜ˆìƒ ë¹„ìš©ì´ ìˆì„ ë•Œ í‘œì‹œí•´ì•¼ í•œë‹¤', () => {
    useEconomyStore.getState().setCostEstimate({
      min: { signal: 5, memory_shard: 0 },
      max: { signal: 10, memory_shard: 0 },
      label: 'Test Action',
    });

    render(<EconomyHud />);

    expect(screen.getByText('economy.estimated_cost')).toBeInTheDocument();
    expect(screen.getByText('Test Action')).toBeInTheDocument();
    expect(screen.getByText('5~10')).toBeInTheDocument();
  });

  it('ê°ë‹¹í•  ìˆ˜ ì—†ëŠ” ì˜ˆìƒ ë¹„ìš©ì¼ ë•Œ ê²½ê³ ë¥¼ í‘œì‹œí•´ì•¼ í•œë‹¤', () => {
    useWorldStore.getState().setEconomy({ signal: 5, memory_shard: 0, credit: 0 });
    useEconomyStore.getState().setCostEstimate({
      min: { signal: 10, memory_shard: 0 },
      max: { signal: 15, memory_shard: 0 },
    });

    const { container } = render(<EconomyHud />);

    expect(screen.getByText('economy.insufficient_funds')).toBeInTheDocument();
    expect(container.querySelector('.cost-unaffordable')).toBeInTheDocument();
  });

  it('ì˜ˆìƒ ë¹„ìš©ì´ ì—†ì„ ë•Œ ë§ˆì§€ë§‰ í™•ì • ë¹„ìš©ì„ í‘œì‹œí•´ì•¼ í•œë‹¤', () => {
    useEconomyStore.getState().setLastCost({
      turnId: 1,
      cost: { signal: 8, memory_shard: 1 },
      balanceAfter: { signal: 92, memory_shard: 4 },
      modelLabel: 'QUALITY',
    });

    render(<EconomyHud />);

    expect(screen.getByText('economy.confirmed_cost')).toBeInTheDocument();
    expect(screen.getByText('8')).toBeInTheDocument();
    expect(screen.getByText('1')).toBeInTheDocument();
    expect(screen.getByText('economy.model_label.QUALITY')).toBeInTheDocument();
  });

  it('ì”ì•¡ ë¶€ì¡± ì‹œ ê²½ê³  ë° ëŒ€ì•ˆì„ í‘œì‹œí•´ì•¼ í•œë‹¤', () => {
    // ì„ê³„ê°’ 10, í˜„ì¬ ì”ì•¡ 5
    useWorldStore.getState().setEconomy({ signal: 5, memory_shard: 0, credit: 0 });
    useEconomyStore.getState().updateBalanceLowStatus({ signal: 5, memory_shard: 0 });

    render(<EconomyHud />);

    expect(screen.getByText('economy.low_balance_warning')).toBeInTheDocument();
    expect(screen.getByText('economy.low_balance_title')).toBeInTheDocument();
    expect(screen.getByText('economy.fast_fallback_notice')).toBeInTheDocument();
    expect(screen.getByText('economy.hint_sell_items')).toBeInTheDocument();
  });

  it('í¬ë ˆë”§ì´ ìˆì„ ë•Œ í‘œì‹œí•´ì•¼ í•œë‹¤', () => {
    useWorldStore.getState().setEconomy({ signal: 0, memory_shard: 5, credit: 10 });

    render(<EconomyHud />);

    expect(screen.getByText(/economy.credit/)).toBeInTheDocument();
    expect(screen.getByText('-10')).toBeInTheDocument();
  });

  it('compact ëª¨ë“œì—ì„œëŠ” ì”ì•¡ë§Œ í‘œì‹œí•´ì•¼ í•œë‹¤', () => {
    useEconomyStore.getState().setCostEstimate({
      min: { signal: 5, memory_shard: 0 },
      max: { signal: 10, memory_shard: 0 },
    });

    render(<EconomyHud compact />);

    // ì”ì•¡ì€ í‘œì‹œë¨
    expect(screen.getByTestId('signal-balance')).toBeInTheDocument();
    // ì˜ˆìƒ ë¹„ìš©ì€ í‘œì‹œë˜ì§€ ì•ŠìŒ
    expect(screen.queryByText('economy.estimated_cost')).not.toBeInTheDocument();
  });

  it('ê±°ë˜ ì¥ë¶€ ì´ë ¥ì´ ìˆì„ ë•Œ í‘œì‹œí•´ì•¼ í•œë‹¤', () => {
    useEconomyStore.getState().addLedgerEntry({
      turnId: 1,
      reason: 'test reason',
      cost: { signal: 5, memory_shard: 0 },
      balanceAfter: { signal: 95, memory_shard: 5 },
      modelLabel: 'FAST',
    });

    render(<EconomyHud />);

    expect(screen.getByText('economy.ledger_title')).toBeInTheDocument();
    expect(screen.getByText('T1')).toBeInTheDocument();
    expect(screen.getByText('test reason')).toBeInTheDocument();
    expect(screen.getByText('-5')).toBeInTheDocument();
  });
});
</file>

<file path="frontend/src/components/EconomyHud.tsx">
/**
 * Unknown World - Economy HUD ì»´í¬ë„ŒíŠ¸ (U-014[Mvp]).
 *
 * Signal/Memory Shard ì¬í™” ì”ì•¡, ì˜ˆìƒ ë¹„ìš©, í™•ì • ë¹„ìš©ì„ í‘œì‹œí•˜ê³ ,
 * ì”ì•¡ ë¶€ì¡± ì‹œ ê²½ê³  ë° ëŒ€ì•ˆì„ ì•ˆë‚´í•˜ëŠ” ê²Œì„ HUD ì»´í¬ë„ŒíŠ¸ì…ë‹ˆë‹¤.
 *
 * RULE-002 ì¤€ìˆ˜: ì±„íŒ… ë²„ë¸”ì´ ì•„ë‹Œ ê²Œì„ HUD í˜•íƒœ
 * RULE-005 ì¤€ìˆ˜: ì˜ˆìƒ ë¹„ìš© ì‚¬ì „ í‘œì‹œ, ì”ì•¡ ìŒìˆ˜ í‘œì‹œ ë°©ì§€
 * RULE-008 ì¤€ìˆ˜: ë¹„ìš©/ëª¨ë¸ ì„ íƒ ì´ìœ ëŠ” ë¼ë²¨ë¡œë§Œ í‘œì‹œ (í”„ë¡¬í”„íŠ¸ ë…¸ì¶œ ê¸ˆì§€)
 *
 * @see vibe/prd.md 5ì¥ - ì¬í™” ëª©ì /UX ìš”êµ¬
 * @module components/EconomyHud
 */

import { useMemo, useEffect, useRef } from 'react';
import { useTranslation } from 'react-i18next';
import { useShallow } from 'zustand/react/shallow';
import { useWorldStore, type EconomyState } from '../stores/worldStore';
import {
  useEconomyStore,
  selectCostEstimate,
  selectLastCost,
  selectIsBalanceLow,
  selectRecentLedger,
  canAffordEstimate,
  type LedgerEntry,
} from '../stores/economyStore';
import type { CurrencyAmount } from '../schemas/turn';

// =============================================================================
// íƒ€ì… ì •ì˜
// =============================================================================

export interface EconomyHudProps {
  /** ê°„ì†Œí™” ëª¨ë“œ (í—¤ë”ìš© - ì”ì•¡ë§Œ í‘œì‹œ) */
  compact?: boolean;
  /** ì¶”ê°€ CSS í´ë˜ìŠ¤ */
  className?: string;
}

// =============================================================================
// ì•„ì´ì½˜ ì»´í¬ë„ŒíŠ¸
// =============================================================================

interface CurrencyIconProps {
  type: 'signal' | 'shard';
  size?: number;
}

/** U-082: ê¸°ë³¸ ì•„ì´ì½˜ í¬ê¸°ë¥¼ 24â†’28pxë¡œ í™•ëŒ€ (ê°€ì‹œì„± í–¥ìƒ) */
function CurrencyIcon({ type, size = 28 }: CurrencyIconProps) {
  const { t } = useTranslation();

  const iconSrc = type === 'signal' ? '/ui/icons/signal-24.png' : '/ui/icons/shard-24.png';
  const fallback = type === 'signal' ? 'âš¡' : 'ğŸ’';
  const label = type === 'signal' ? t('economy.signal') : t('economy.shard');

  return (
    <span className="icon-wrapper" aria-label={label}>
      <img
        src={iconSrc}
        alt=""
        aria-hidden="true"
        className="icon-img"
        style={{ width: size, height: size }}
        onError={(e) => e.currentTarget.classList.add('hidden')}
      />
      <span className="icon-fallback">{fallback}</span>
    </span>
  );
}

// =============================================================================
// ì”ì•¡ í‘œì‹œ ì»´í¬ë„ŒíŠ¸
// =============================================================================

interface BalanceDisplayProps {
  balance: EconomyState;
  isLow?: boolean;
}

function BalanceDisplay({ balance, isLow }: BalanceDisplayProps) {
  const { t } = useTranslation();

  return (
    <div className={`economy-balance ${isLow ? 'balance-low' : ''}`} data-ui-importance="critical">
      <div className="balance-item">
        <CurrencyIcon type="signal" />
        <span className="balance-value" data-testid="signal-balance">
          {balance.signal}
        </span>
        <span className="balance-label">{t('economy.signal')}</span>
      </div>
      {balance.credit > 0 && (
        <div className="balance-credit" title={t('economy.credit_desc')}>
          <span className="credit-label">{t('economy.credit')}: </span>
          <span className="credit-value">-{balance.credit}</span>
        </div>
      )}
      <div className="balance-item">
        <CurrencyIcon type="shard" />
        <span className="balance-value" data-testid="shard-balance">
          {balance.memory_shard}
        </span>
        <span className="balance-label">{t('economy.shard')}</span>
      </div>
      {isLow && (
        <div className="balance-warning" aria-live="polite">
          <span className="warning-icon">âš </span>
          <span className="warning-text">{t('economy.low_balance_warning')}</span>
        </div>
      )}
    </div>
  );
}

// =============================================================================
// ë¹„ìš© í‘œì‹œ ì»´í¬ë„ŒíŠ¸
// =============================================================================

interface CostDisplayProps {
  /** ë¹„ìš© ìœ í˜• */
  type: 'estimate' | 'confirmed';
  /** ë¹„ìš© ë²”ìœ„ (ì˜ˆìƒ) */
  min?: CurrencyAmount;
  max?: CurrencyAmount;
  /** í™•ì • ë¹„ìš© */
  cost?: CurrencyAmount;
  /** ê°ë‹¹ ê°€ëŠ¥ ì—¬ë¶€ */
  affordable?: boolean;
  /** ë¼ë²¨ */
  label?: string;
}

function CostDisplay({ type, min, max, cost, affordable, label }: CostDisplayProps) {
  const { t } = useTranslation();

  const isRange =
    min && max && (min.signal !== max.signal || min.memory_shard !== max.memory_shard);

  const titleKey = type === 'estimate' ? 'economy.estimated_cost' : 'economy.confirmed_cost';
  const cssClass = type === 'estimate' ? 'cost-estimate' : 'cost-confirmed';

  return (
    <div
      className={`economy-cost ${cssClass} ${affordable === false ? 'cost-unaffordable' : ''}`}
      data-ui-importance="critical"
    >
      <div className="cost-header">
        <span className="cost-title">{t(titleKey)}</span>
        {label && <span className="cost-label">{label}</span>}
      </div>
      <div className="cost-values">
        {/* Signal ë¹„ìš© - U-082: ì•„ì´ì½˜ í¬ê¸° 14â†’18px */}
        <div className="cost-item">
          <CurrencyIcon type="signal" size={18} />
          <span className="cost-value">
            {type === 'estimate' && min && max
              ? isRange
                ? `${min.signal}~${max.signal}`
                : min.signal
              : cost
                ? cost.signal
                : '-'}
          </span>
        </div>
        {/* Shard ë¹„ìš© (0ë³´ë‹¤ í´ ë•Œë§Œ í‘œì‹œ) */}
        {((type === 'estimate' && max && max.memory_shard > 0) ||
          (type === 'confirmed' && cost && cost.memory_shard > 0)) && (
          <div className="cost-item">
            <span className="cost-separator">|</span>
            <CurrencyIcon type="shard" size={18} />
            <span className="cost-value">
              {type === 'estimate' && min && max
                ? isRange
                  ? `${min.memory_shard}~${max.memory_shard}`
                  : min.memory_shard
                : cost
                  ? cost.memory_shard
                  : '-'}
            </span>
          </div>
        )}
      </div>
      {affordable === false && (
        <div className="cost-warning">
          <span className="warning-text">{t('economy.insufficient_funds')}</span>
        </div>
      )}
    </div>
  );
}

// =============================================================================
// ê±°ë˜ ì¥ë¶€(Ledger) í•­ëª© ì»´í¬ë„ŒíŠ¸
// =============================================================================

function LedgerItem({ entry }: { entry: LedgerEntry }) {
  const { t } = useTranslation();

  return (
    <div className="ledger-item">
      <div className="ledger-info">
        <span className="ledger-turn">T{entry.turnId}</span>
        <span className="ledger-reason">{entry.reason}</span>
      </div>
      <div className="ledger-values">
        <span className="ledger-cost">
          -{entry.cost.signal}
          {entry.cost.memory_shard > 0 && ` / -${entry.cost.memory_shard}`}
        </span>
        <span
          className="ledger-model"
          title={entry.modelLabel ? t(`economy.model_label.${entry.modelLabel}`) : undefined}
        >
          {entry.modelLabel?.charAt(0)}
        </span>
      </div>
    </div>
  );
}

// =============================================================================
// ì…€ë ‰í„° ì •ì˜ (ì»´í¬ë„ŒíŠ¸ ì™¸ë¶€ì—ì„œ ìƒì„±í•˜ì—¬ ì°¸ì¡° ìœ ì§€)
// =============================================================================

const selectHistory = selectRecentLedger(10);

// =============================================================================
// ë©”ì¸ Economy HUD ì»´í¬ë„ŒíŠ¸
// =============================================================================

export function EconomyHud({ compact = false, className = '' }: EconomyHudProps) {
  const { t } = useTranslation();

  // Store ìƒíƒœ
  const economy = useWorldStore((state) => state.economy);
  const costEstimate = useEconomyStore(selectCostEstimate);
  const lastCost = useEconomyStore(selectLastCost);
  const isBalanceLow = useEconomyStore(selectIsBalanceLow);
  const recentLedger = useEconomyStore(useShallow(selectHistory));

  // U-049: ê±°ë˜ ì¥ë¶€(Ledger) ìµœì‹  í•­ëª©ì´ ë³´ì´ë„ë¡ ìŠ¤í¬ë¡¤ (í•˜ë‹¨ ìŠ¤í¬ë¡¤)
  const ledgerListRef = useRef<HTMLDivElement>(null);
  useEffect(() => {
    if (ledgerListRef.current) {
      ledgerListRef.current.scrollTop = ledgerListRef.current.scrollHeight;
    }
  }, [recentLedger]);

  // ì˜ˆìƒ ë¹„ìš© ê°ë‹¹ ê°€ëŠ¥ ì—¬ë¶€ ê³„ì‚°
  const estimateAffordability = useMemo(() => {
    if (!costEstimate) return null;
    return canAffordEstimate(economy, costEstimate);
  }, [economy, costEstimate]);

  // Compact ëª¨ë“œ (í—¤ë”ìš©): ì”ì•¡ë§Œ í‘œì‹œ
  if (compact) {
    return (
      <div
        className={`economy-hud economy-hud-compact ${className}`}
        role="status"
        aria-live="polite"
      >
        <BalanceDisplay balance={economy} isLow={isBalanceLow} />
      </div>
    );
  }

  // Full ëª¨ë“œ: ì”ì•¡ + ì˜ˆìƒ ë¹„ìš© + í™•ì • ë¹„ìš© + ê±°ë˜ ì¥ë¶€ ì´ë ¥
  return (
    <div
      className={`economy-hud economy-hud-full ${className}`}
      role="region"
      aria-label={t('economy.hud_label')}
    >
      {/* í˜„ì¬ ì”ì•¡ */}
      <BalanceDisplay balance={economy} isLow={isBalanceLow} />

      {/* ì˜ˆìƒ ë¹„ìš© (ì¹´ë“œ ì„ íƒ/í˜¸ë²„ ì‹œ) */}
      {costEstimate && (
        <CostDisplay
          type="estimate"
          min={costEstimate.min}
          max={costEstimate.max}
          affordable={estimateAffordability?.affordable}
          label={costEstimate.label}
        />
      )}

      {/* ë§ˆì§€ë§‰ í™•ì • ë¹„ìš© (ì˜ˆìƒ ë¹„ìš©ì´ ì—†ì„ ë•Œë§Œ í‘œì‹œ) */}
      {!costEstimate && lastCost && (
        <CostDisplay
          type="confirmed"
          cost={lastCost.cost}
          label={lastCost.modelLabel ? t(`economy.model_label.${lastCost.modelLabel}`) : undefined}
        />
      )}

      {/* U-079: ì”ì•¡ ë¶€ì¡± ì‹œ ëŒ€ì•ˆ ì•ˆë‚´ + FAST í´ë°± ë¼ë²¨ */}
      {isBalanceLow && (
        <div
          className="economy-alternatives economy-alternatives-enhanced"
          data-ui-importance="critical"
        >
          <div className="alternatives-header">
            <span className="alternatives-icon">{'\u26A1'}</span>
            <span className="alternatives-title">{t('economy.low_balance_title')}</span>
          </div>
          <div className="fast-fallback-notice">
            <span className="fast-fallback-badge">FAST</span>
            <span className="fast-fallback-text">{t('economy.fast_fallback_notice')}</span>
          </div>
          <ul className="alternatives-list">
            <li>{t('economy.hint_sell_items')}</li>
            <li>{t('economy.hint_earn_actions')}</li>
            <li>{t('economy.hint_complete_quests')}</li>
          </ul>
        </div>
      )}

      {/* ê±°ë˜ ì¥ë¶€ ì´ë ¥ (Ledger) */}
      <div className="economy-ledger">
        <div className="ledger-header">
          <span className="ledger-title">{t('economy.ledger_title')}</span>
        </div>
        {recentLedger.length > 0 ? (
          <div className="ledger-list" ref={ledgerListRef}>
            {recentLedger.map((entry) => (
              <LedgerItem key={`${entry.turnId}-${entry.timestamp}`} entry={entry} />
            ))}
          </div>
        ) : (
          <div className="ledger-empty">{t('economy.ledger_empty')}</div>
        )}
      </div>
    </div>
  );
}

// =============================================================================
// í—¤ë”ìš© ê°„ì†Œí™” ì»´í¬ë„ŒíŠ¸ (GameHeader í†µí•©ìš©)
// =============================================================================

export interface EconomyHudHeaderProps {
  signal: number;
  memoryShard: number;
  credit: number;
  isLow?: boolean;
}

/**
 * GameHeaderì—ì„œ ì‚¬ìš©í•˜ëŠ” ê°„ì†Œí™”ëœ Economy HUD.
 * ê¸°ì¡´ GameHeaderì˜ economy-hudë¥¼ ëŒ€ì²´í•©ë‹ˆë‹¤.
 */
export function EconomyHudHeader({ signal, memoryShard, credit, isLow }: EconomyHudHeaderProps) {
  const { t } = useTranslation();
  const costEstimate = useEconomyStore(selectCostEstimate);

  // ì˜ˆìƒ ë¹„ìš© ê°ë‹¹ ê°€ëŠ¥ ì—¬ë¶€
  const estimateAffordability = useMemo(() => {
    if (!costEstimate) return null;
    const balance = { signal, memory_shard: memoryShard };
    return canAffordEstimate(balance, costEstimate);
  }, [signal, memoryShard, costEstimate]);

  return (
    <div className={`economy-hud ${isLow ? 'economy-hud-low' : ''}`} data-ui-importance="critical">
      {/* ì”ì•¡ í‘œì‹œ */}
      <span className="icon-wrapper signal-icon" aria-label={t('economy.signal')}>
        <img
          src="/ui/icons/signal-24.png"
          alt=""
          aria-hidden="true"
          className="icon-img"
          onError={(e) => e.currentTarget.classList.add('hidden')}
        />
        <span className="icon-fallback">âš¡</span>
      </span>
      <span className="currency-value" data-testid="header-signal">
        {t('economy.signal')}: {signal}
      </span>
      {credit > 0 && (
        <span className="credit-value header-credit" title={t('economy.credit_desc')}>
          -{credit}
        </span>
      )}
      <span className="icon-wrapper shard-icon" aria-label={t('economy.shard')}>
        <img
          src="/ui/icons/shard-24.png"
          alt=""
          aria-hidden="true"
          className="icon-img"
          onError={(e) => e.currentTarget.classList.add('hidden')}
        />
        <span className="icon-fallback">ğŸ’</span>
      </span>
      <span className="currency-value" data-testid="header-shard">
        {t('economy.shard')}: {memoryShard}
      </span>

      {/* ì˜ˆìƒ ë¹„ìš© ë¯¸ë‹ˆ í‘œì‹œ */}
      {costEstimate && (
        <span
          className={`economy-estimate-mini ${
            estimateAffordability?.affordable === false ? 'unaffordable' : ''
          }`}
          title={t('economy.estimated_cost')}
        >
          <span className="estimate-prefix">â†’</span>
          <span className="estimate-value">
            -{costEstimate.max.signal}
            {costEstimate.max.memory_shard > 0 && `/${costEstimate.max.memory_shard}`}
          </span>
        </span>
      )}

      {/* ì”ì•¡ ë¶€ì¡± ê²½ê³  ì•„ì´ì½˜ */}
      {isLow && (
        <span className="balance-warning-icon" title={t('economy.low_balance_warning')}>
          âš 
        </span>
      )}
    </div>
  );
}

export default EconomyHud;
</file>

<file path="frontend/src/components/SceneCanvas.tsx">
/**
 * Unknown World - Scene Canvas ì»´í¬ë„ŒíŠ¸
 *
 * RULE-002 ì¤€ìˆ˜: ì±„íŒ… ë²„ë¸”ì´ ì•„ë‹Œ ê²Œì„ UI
 * RULE-009 ì¤€ìˆ˜: ì¢Œí‘œ ê·œì•½ (0~1000 ì •ê·œí™”, bbox=[ymin,xmin,ymax,xmax])
 *
 * U-010[Mvp]: í•«ìŠ¤íŒŸ ì˜¤ë²„ë ˆì´ + í´ë¦­ ì²˜ë¦¬
 * - TurnOutputì˜ objects[]/hotspots[]ë¥¼ ê¸°ë°˜ìœ¼ë¡œ ì˜¤ë²„ë ˆì´ ë Œë”
 * - hover ì‹œ í•˜ì´ë¼ì´íŠ¸/íˆ´íŒ í‘œì‹œ
 * - click ì‹œ object_id + box_2dë¥¼ TurnInputì— í¬í•¨í•´ ì „ì†¡
 *
 * U-012[Mvp]: DnD ë“œë¡­ íƒ€ê²Ÿ í™•ì¥
 * - í•«ìŠ¤íŒŸì„ droppable ì˜ì—­ìœ¼ë¡œ ë§Œë“¤ì–´ ì¸ë²¤í† ë¦¬ ì•„ì´í…œ ë“œë¡­ ì²˜ë¦¬
 * - ë“œë˜ê·¸ ì˜¤ë²„ ì‹œ í•˜ì´ë¼ì´íŠ¸ ê°•í™”
 * - ë“œë¡­ ì„±ê³µ/ì‹¤íŒ¨ ì¦‰ì‹œ ì‹œê°í™”
 *
 * U-020[Mvp]: ì´ë¯¸ì§€ Lazy Render (placeholder/í´ë°±)
 * - RULE-004/008 ì¤€ìˆ˜: í…ìŠ¤íŠ¸ ìš°ì„  + Lazy ì´ë¯¸ì§€ ì •ì±…
 * - Q1 Option A: ì´ì „ ì´ë¯¸ì§€ ìœ ì§€ + ë¡œë”© ì¸ë””ì¼€ì´í„° í‘œì‹œ
 * - ì´ë¯¸ì§€ ì‹¤íŒ¨ ì‹œì—ë„ í•«ìŠ¤íŒŸ/íŒ¨ë„/ë¡œê·¸ëŠ” ê³„ì† ë™ì‘ (í…ìŠ¤íŠ¸-only ì§„í–‰)
 *
 * U-058[Mvp]: í•«ìŠ¤íŒŸ ë””ìì¸ ê°œì„ 
 * - Q1 Option C: Magenta/Purple ê³„ì—´ ê°•ì¡°
 * - Q2 Option A: Lì ë¸Œë¼ì¼“ ì½”ë„ˆ ë§ˆì»¤
 * - Hotspot ì»´í¬ë„ŒíŠ¸ ë¶„ë¦¬ë¡œ ì‹œê°ì  í’ˆì§ˆ í–¥ìƒ
 *
 * @module components/SceneCanvas
 */

import { useState, useRef, useCallback, useEffect, useMemo } from 'react';
import { useTranslation } from 'react-i18next';
import { type CanvasSize } from '../utils/box2d';
import { isHotspotInteractionAllowed, compareHotspotPriority } from '../dnd/types';
import { useWorldStore } from '../stores/worldStore';
import { useAgentStore } from '../stores/agentStore';
import { SceneImage } from './SceneImage';
import { Hotspot, type HotspotClickData } from './Hotspot';

// =============================================================================
// íƒ€ì… ì •ì˜ (Re-export for backward compatibility)
// =============================================================================

export type { HotspotClickData };

interface SceneCanvasProps {
  /** í•«ìŠ¤íŒŸ í´ë¦­ ì½œë°± */
  onHotspotClick?: (data: HotspotClickData) => void;
  /** ìŠ¤íŠ¸ë¦¬ë° ì¤‘ ì—¬ë¶€ (ë¹„í™œì„±í™”ìš©, ìƒëµ ì‹œ agentStore.isStreaming ì‚¬ìš©) */
  disabled?: boolean;
}

// =============================================================================
// ë©”ì¸ ì»´í¬ë„ŒíŠ¸
// =============================================================================

/**
 * Scene Canvas ì»´í¬ë„ŒíŠ¸
 *
 * U-010[Mvp]: í•«ìŠ¤íŒŸ ì˜¤ë²„ë ˆì´ + í´ë¦­ ì²˜ë¦¬
 * U-020[Mvp]: Lazy Render (placeholder/í´ë°±)
 * U-031[Mvp]: Placeholder Pack
 *
 * - ìƒíƒœì— ë”°ë¼ placeholder ì´ë¯¸ì§€ì™€ ë¼ë²¨ì„ í‘œì‹œí•©ë‹ˆë‹¤.
 * - 'scene' ìƒíƒœì—ì„œëŠ” ì‹¤ì œ ì´ë¯¸ì§€ë¥¼ ë Œë”ë§í•˜ë©°, ë¡œë“œ ì‹¤íŒ¨ ì‹œ í´ë°±ì„ ì œê³µí•©ë‹ˆë‹¤.
 * - U-020: Q1 Option A - ì´ì „ ì´ë¯¸ì§€ ìœ ì§€ + ë¡œë”© ì¸ë””ì¼€ì´í„° í‘œì‹œ
 * - objects ë°°ì—´ì´ ìˆìœ¼ë©´ í•«ìŠ¤íŒŸ ì˜¤ë²„ë ˆì´ë¥¼ ë Œë”ë§í•©ë‹ˆë‹¤.
 */
export function SceneCanvas({ onHotspotClick, disabled: propsDisabled }: SceneCanvasProps) {
  const { t } = useTranslation();

  // Store ìƒíƒœ (RU-003: ì»´í¬ë„ŒíŠ¸ ë‚´ì—ì„œ ì§ì ‘ êµ¬ë…)
  const state = useWorldStore((state) => state.sceneState);
  const objects = useWorldStore((state) => state.sceneObjects);
  const isAnalyzing = useWorldStore((state) => state.isAnalyzing);
  const isStreaming = useAgentStore((state) => state.isStreaming);

  const disabled = propsDisabled ?? isStreaming;

  // U-071: ì²˜ë¦¬ ë‹¨ê³„ ë° ì´ë¯¸ì§€ ë¡œë”© ìƒíƒœ ì¶”ì¶œ
  const { status, imageUrl, message, processingPhase, imageLoading } = state;

  const [canvasSize, setCanvasSize] = useState<CanvasSize>({ width: 0, height: 0 });
  const canvasRef = useRef<HTMLDivElement>(null);

  // RU-003-S2 Step 3: ResizeObserverì— ë””ë°”ìš´ìŠ¤ ì ìš©
  // ë“œë˜ê·¸ ì¤‘ í•«ìŠ¤íŒŸ ì˜ì—­ì´ ê³¼ë„í•˜ê²Œ í”ë“¤ë¦¬ëŠ” ê²ƒì„ ë°©ì§€
  useEffect(() => {
    const element = canvasRef.current;
    if (!element) return;

    let resizeTimeout: ReturnType<typeof setTimeout> | null = null;
    const RESIZE_DEBOUNCE_MS = 100; // ë””ë°”ìš´ìŠ¤ ê°„ê²©

    const resizeObserver = new ResizeObserver((entries) => {
      // ë””ë°”ìš´ìŠ¤: ë§ˆì§€ë§‰ ë¦¬ì‚¬ì´ì¦ˆ ì´ë²¤íŠ¸ í›„ ì¼ì • ì‹œê°„ í›„ì—ë§Œ ì—…ë°ì´íŠ¸
      if (resizeTimeout) {
        clearTimeout(resizeTimeout);
      }
      resizeTimeout = setTimeout(() => {
        for (const entry of entries) {
          const { width, height } = entry.contentRect;
          // ì˜ë¯¸ ìˆëŠ” í¬ê¸° ë³€í™”ë§Œ ì ìš© (5px ì´ìƒ ì°¨ì´)
          setCanvasSize((prev) => {
            if (Math.abs(prev.width - width) > 5 || Math.abs(prev.height - height) > 5) {
              return { width, height };
            }
            return prev;
          });
        }
      }, RESIZE_DEBOUNCE_MS);
    });

    resizeObserver.observe(element);

    // ì´ˆê¸° í¬ê¸° ì„¤ì •
    const rect = element.getBoundingClientRect();
    setCanvasSize({ width: rect.width, height: rect.height });

    return () => {
      if (resizeTimeout) {
        clearTimeout(resizeTimeout);
      }
      resizeObserver.disconnect();
    };
  }, []);

  // í•«ìŠ¤íŒŸ í´ë¦­ í•¸ë“¤ëŸ¬
  const handleHotspotClick = useCallback(
    (data: HotspotClickData) => {
      if (onHotspotClick) {
        onHotspotClick(data);
      }
    },
    [onHotspotClick],
  );

  // RU-003-S2 Step 1: í•«ìŠ¤íŒŸ ë Œë”ë§ ì¡°ê±´ì„ SSOTë¡œ ê³ ì •
  // - isHotspotInteractionAllowed()ë¡œ í—ˆìš© ìƒíƒœ ê²€ì‚¬ (scene, default)
  // - objects ì¡´ì¬ + ìº”ë²„ìŠ¤ í¬ê¸° í™•ë³´
  // U-020: ì´ë¯¸ì§€ ìœ ë¬´ì™€ ë¬´ê´€í•˜ê²Œ í•«ìŠ¤íŒŸì€ ë™ì‘ (RULE-004)
  const isInteractionAllowed = isHotspotInteractionAllowed(status);
  const shouldRenderHotspots = isInteractionAllowed && objects.length > 0 && canvasSize.width > 0;

  // RU-003-S2: ë°ëª¨ ìƒíƒœ ì—¬ë¶€ (ì‹œê°ì  íŒíŠ¸ í•„ìš”)
  const isDemoState = status === 'default';

  // RU-003-S2 Step 2: í•«ìŠ¤íŒŸì„ ë©´ì  ê¸°ì¤€ìœ¼ë¡œ ì •ë ¬ (ì‘ì€ ê²ƒì´ ë’¤ì— = ë†’ì€ z-index)
  const sortedObjects = useMemo(() => {
    if (objects.length <= 1) return objects;
    return [...objects].sort((a, b) => compareHotspotPriority(a.box_2d, b.box_2d));
  }, [objects]);

  return (
    <div ref={canvasRef} className="scene-canvas">
      {/* U-020: ì¥ë©´ ì´ë¯¸ì§€ (Lazy loading + placeholder/í´ë°± í¬í•¨) */}
      {/* U-071: ì²˜ë¦¬ ë‹¨ê³„ ë° ì´ë¯¸ì§€ ìƒì„± ìƒíƒœ ì „ë‹¬ */}
      {/* U-089: ì •ë°€ë¶„ì„ ìƒíƒœ ì „ë‹¬ (ê¸°ì¡´ ì´ë¯¸ì§€ ìœ ì§€ + ë¶„ì„ ì˜¤ë²„ë ˆì´) */}
      <SceneImage
        status={status}
        imageUrl={imageUrl}
        message={message}
        processingPhase={processingPhase}
        isGenerating={imageLoading}
        isAnalyzing={isAnalyzing}
      />

      {/* í•«ìŠ¤íŒŸ ì˜¤ë²„ë ˆì´ ë ˆì´ì–´ (RU-003-S2: ë©´ì ìˆœ ì •ë ¬) */}
      {/* U-020: ì´ë¯¸ì§€ ìœ ë¬´ì™€ ë¬´ê´€í•˜ê²Œ í•«ìŠ¤íŒŸì€ í•­ìƒ ë Œë” (RULE-004) */}
      {/* U-058: Hotspot ì»´í¬ë„ŒíŠ¸ ë¶„ë¦¬ (Magenta í…Œë§ˆ + Lì ì½”ë„ˆ) */}
      {shouldRenderHotspots && (
        <div className="hotspot-layer" aria-label={t('scene.hotspot.layer_label')}>
          {sortedObjects.map((obj, index) => (
            <Hotspot
              key={obj.id}
              object={obj}
              canvasSize={canvasSize}
              onClick={handleHotspotClick}
              disabled={disabled}
              isDemoState={isDemoState}
              // RU-003-S2 Step 2: ì¸ë±ìŠ¤ ê¸°ë°˜ z-indexë¡œ ì‘ì€ ê²ƒì´ ìœ„ì— í‘œì‹œ
              style={{ zIndex: index + 1 }}
            />
          ))}
        </div>
      )}
    </div>
  );
}
</file>

<file path="frontend/src/stores/agentStore.test.ts">
import { describe, it, expect, beforeEach } from 'vitest';
import { useAgentStore } from './agentStore';
import { StreamEventType, StageStatus } from '../api/turnStream';
import type { TurnOutput } from '../schemas/turn';

describe('agentStore', () => {
  beforeEach(() => {
    useAgentStore.getState().reset();
  });

  it('should have correct initial state', () => {
    const state = useAgentStore.getState();
    expect(state.isStreaming).toBe(false);
    expect(state.phases).toHaveLength(7);
    expect(state.phases[0].status).toBe('pending');
    expect(state.badges).toEqual([]);
    expect(state.repairCount).toBe(0);
  });

  it('should handle startStream', () => {
    useAgentStore.getState().startStream();
    const state = useAgentStore.getState();
    expect(state.isStreaming).toBe(true);
  });

  it('should handle handleStage events', () => {
    const store = useAgentStore.getState();

    // Start parse phase
    store.handleStage({
      type: StreamEventType.STAGE,
      name: 'parse',
      status: StageStatus.START,
    });

    let state = useAgentStore.getState();
    expect(state.currentPhase).toBe('parse');
    expect(state.phases.find((p) => p.name === 'parse')?.status).toBe('in_progress');

    // Complete parse phase
    store.handleStage({
      type: StreamEventType.STAGE,
      name: 'parse',
      status: StageStatus.COMPLETE,
    });

    state = useAgentStore.getState();
    expect(state.phases.find((p) => p.name === 'parse')?.status).toBe('completed');
  });

  it('should handle handleBadges events', () => {
    const store = useAgentStore.getState();
    store.handleBadges({
      type: StreamEventType.BADGES,
      badges: ['schema_ok', 'economy_ok'],
    });

    const state = useAgentStore.getState();
    expect(state.badges).toEqual(['schema_ok', 'economy_ok']);
  });

  it('should handle handleNarrativeDelta events', () => {
    const store = useAgentStore.getState();
    store.handleNarrativeDelta({
      type: StreamEventType.NARRATIVE_DELTA,
      text: 'Hello ',
    });
    store.handleNarrativeDelta({
      type: StreamEventType.NARRATIVE_DELTA,
      text: 'World',
    });

    const state = useAgentStore.getState();
    expect(state.narrativeBuffer).toBe('Hello World');
  });

  it('should handle handleFinal events', () => {
    const store = useAgentStore.getState();
    const mockOutput = {
      language: 'ko-KR',
      narrative: 'Final message',
      economy: {
        cost: { signal: 0, memory_shard: 0 },
        balance_after: { signal: 100, memory_shard: 0 },
        credit: 0,
        low_balance_warning: false,
      },
      safety: { blocked: false, message: null },
      ui: { action_deck: { cards: [] }, objects: [], scene: { image_url: null, alt_text: null } },
      world: {
        rules_changed: [],
        inventory_added: [],
        inventory_removed: [],
        quests_updated: [],
        relationships_changed: [],
        memory_pins: [],
      },
      render: {
        image_job: null,
        image_url: null,
        image_id: null,
        generation_time_ms: null,
      },
      agent_console: {
        repair_count: 2,
        current_phase: 'commit',
        badges: [],
        model_label: 'FAST',
      },
    } as TurnOutput;

    store.handleFinal({
      type: StreamEventType.FINAL,
      data: mockOutput,
    });

    const state = useAgentStore.getState();
    expect(state.finalOutput).toEqual(mockOutput);
    expect(state.repairCount).toBe(2);
  });

  it('should handle handleError events', () => {
    const store = useAgentStore.getState();
    store.handleError({
      type: StreamEventType.ERROR,
      message: 'Network error',
      code: 'ERR_NET',
    });

    const state = useAgentStore.getState();
    expect(state.error).toEqual({
      message: 'Network error',
      code: 'ERR_NET',
    });
  });

  it('should reset state on completeStream', () => {
    const store = useAgentStore.getState();
    store.handleNarrativeDelta({ type: StreamEventType.NARRATIVE_DELTA, text: 'Some text' });
    store.startStream();

    store.completeStream();

    const state = useAgentStore.getState();
    expect(state.isStreaming).toBe(false);
    expect(state.narrativeBuffer).toBe('');
  });
});
</file>

<file path="frontend/src/stores/economyStore.ts">
/**
 * Unknown World - Economy ìƒíƒœ ê´€ë¦¬ (Zustand) (U-014[Mvp]).
 *
 * Signal/Memory Shard ì¬í™” HUDì™€ í„´ë³„ ë¹„ìš©/ì”ì•¡ ë³€í™”ë¥¼
 * **ê±°ë˜ ì¥ë¶€(ledger)**ë¡œ ì¶”ì í•˜ì—¬ "ë¹„ìš©/ì§€ì—°ì„ ê²Œì„ ë©”ì»¤ë‹‰"ìœ¼ë¡œ UXì— ë°˜ì˜í•©ë‹ˆë‹¤.
 *
 * ì„¤ê³„ ì›ì¹™:
 *   - RULE-005: Economy ì¸ë°”ë¦¬ì–¸íŠ¸ (ì”ì•¡ ìŒìˆ˜ ê¸ˆì§€, ì˜ˆìƒ ë¹„ìš© ì‚¬ì „ í‘œì‹œ)
 *   - RULE-008: ë¹„ìš©/ëª¨ë¸ ì„ íƒ ì´ìœ ëŠ” ë¼ë²¨(FAST/QUALITY/REF)ë¡œë§Œ ì„¤ëª…
 *   - Q1 ê²°ì •: Option A - ìµœê·¼ Ní„´ë§Œ ë³´ê´€ (UI/ë©”ëª¨ë¦¬ ì ˆê°)
 *   - RU-004-Q5: ìƒìˆ˜ëŠ” save/constants.tsì—ì„œ ì¤‘ì•™ ê´€ë¦¬
 *
 * @module stores/economyStore
 */

import { create } from 'zustand';
import type { CurrencyAmount, ModelLabel, CostEstimate } from '../schemas/turn';
// RU-004-Q5: ìƒìˆ˜ ì¤‘ì•™í™” - constants.tsì—ì„œ import
import { LEDGER_MAX_ENTRIES, LOW_BALANCE_THRESHOLD } from '../save/constants';

// RU-004-Q5: ìƒìˆ˜ re-export (ê¸°ì¡´ í˜¸ì¶œì í˜¸í™˜ì„± ìœ ì§€)
export { LEDGER_MAX_ENTRIES };

// =============================================================================
// íƒ€ì… ì •ì˜
// =============================================================================

/**
 * ê±°ë˜ ì¥ë¶€(Ledger) ì—”íŠ¸ë¦¬.
 * ê° í„´ì—ì„œ ë°œìƒí•œ ë¹„ìš©ê³¼ ì”ì•¡ ë³€í™”ë¥¼ ê¸°ë¡í•©ë‹ˆë‹¤.
 */
export interface LedgerEntry {
  /** í„´ ID (í„´ ì¹´ìš´íŠ¸) */
  turnId: number;
  /** ì•¡ì…˜ ID (ì„ íƒëœ ì¹´ë“œ ID, ì„ íƒì‚¬í•­) */
  actionId?: string;
  /** ë¹„ìš© ì‚¬ìœ  (ì˜ˆ: "íƒìƒ‰", "ì´ë¯¸ì§€ ìƒì„±") */
  reason: string;
  /** ì†Œë¹„ëœ ë¹„ìš© */
  cost: CurrencyAmount;
  /** ì†Œë¹„ í›„ ì”ì•¡ */
  balanceAfter: CurrencyAmount;
  /** ëª¨ë¸ ë¼ë²¨ (FAST/QUALITY/CHEAP/REF) */
  modelLabel?: ModelLabel;
  /** ì”ì•¡ ë¶€ì¡± ê²½ê³  ì—¬ë¶€ (U-079) */
  lowBalanceWarning?: boolean;
  /** ê¸°ë¡ ì‹œê°„ */
  timestamp: number;
}

/**
 * ì˜ˆìƒ ë¹„ìš© ìƒíƒœ.
 * í˜„ì¬ ì„ íƒëœ ì•¡ì…˜ì˜ ì˜ˆìƒ ë¹„ìš©ì„ ì¶”ì í•©ë‹ˆë‹¤.
 */
export interface CostEstimateState {
  /** ìµœì†Œ ì˜ˆìƒ ë¹„ìš© */
  min: CurrencyAmount;
  /** ìµœëŒ€ ì˜ˆìƒ ë¹„ìš© */
  max: CurrencyAmount;
  /** ì˜ˆìƒ ë¹„ìš©ì„ ê³„ì‚°í•œ ì•¡ì…˜ ID */
  actionId?: string;
  /** ì˜ˆìƒ ë¹„ìš© ë¼ë²¨/ì„¤ëª… */
  label?: string;
}

/**
 * ë§ˆì§€ë§‰ í™•ì • ë¹„ìš© ìƒíƒœ.
 * ê°€ì¥ ìµœê·¼ í„´ì—ì„œ í™•ì •ëœ ë¹„ìš© ì •ë³´ì…ë‹ˆë‹¤.
 */
export interface LastCostState {
  /** í™•ì •ëœ ë¹„ìš© */
  cost: CurrencyAmount;
  /** í™•ì • í›„ ì”ì•¡ */
  balanceAfter: CurrencyAmount;
  /** í„´ ID */
  turnId: number;
  /** ëª¨ë¸ ë¼ë²¨ */
  modelLabel?: ModelLabel;
}

/** Economy Store ìƒíƒœ */
export interface EconomyStoreState {
  /** ê±°ë˜ ì¥ë¶€ (ìµœê·¼ Nê°œ ì—”íŠ¸ë¦¬, ìµœì‹ ìˆœ) */
  ledger: LedgerEntry[];
  /** í˜„ì¬ ì˜ˆìƒ ë¹„ìš© (ì„ íƒí•œ ì•¡ì…˜ ê¸°ë°˜) */
  costEstimate: CostEstimateState | null;
  /** ë§ˆì§€ë§‰ í™•ì • ë¹„ìš© */
  lastCost: LastCostState | null;
  /** ì”ì•¡ ë¶€ì¡± ê²½ê³  ì—¬ë¶€ */
  isBalanceLow: boolean;
  /** ì”ì•¡ ë¶€ì¡± ì„ê³„ê°’ (Signal ê¸°ì¤€) */
  lowBalanceThreshold: number;
}

/** Economy Store ì•¡ì…˜ */
export interface EconomyStoreActions {
  /**
   * í„´ ì™„ë£Œ ì‹œ ê±°ë˜ ì¥ë¶€ì— ì—”íŠ¸ë¦¬ë¥¼ ì¶”ê°€í•©ë‹ˆë‹¤.
   */
  addLedgerEntry: (entry: Omit<LedgerEntry, 'timestamp'>) => void;

  /**
   * SaveGame ë³µì› ì‹œ ê±°ë˜ ì¥ë¶€ë¥¼ ê·¸ëŒ€ë¡œ ì£¼ì…í•©ë‹ˆë‹¤ (RU-004-S1).
   *
   * - ledgerëŠ” ì €ì¥ëœ ìˆœì„œ(ìµœì‹ ìˆœ)ë¥¼ ìœ ì§€í•©ë‹ˆë‹¤.
   * - timestampëŠ” ì €ì¥ëœ ê°’ì„ ë³´ì¡´í•©ë‹ˆë‹¤.
   * - lastCostëŠ” ìµœì‹  ì—”íŠ¸ë¦¬(ì²« ì›ì†Œ) ê¸°ì¤€ìœ¼ë¡œ ì„¤ì •í•©ë‹ˆë‹¤.
   * - isBalanceLowëŠ” ì „ë‹¬ëœ currentBalanceë¡œ ì¬ê³„ì‚°í•©ë‹ˆë‹¤.
   *
   * @param ledger - ì €ì¥ëœ ê±°ë˜ ì¥ë¶€ ë°°ì—´ (ìµœì‹ ìˆœ, timestamp í¬í•¨)
   * @param currentBalance - ë³µì›ëœ ì”ì•¡ (isBalanceLow ê³„ì‚°ìš©)
   */
  hydrateLedger: (ledger: LedgerEntry[], currentBalance: CurrencyAmount) => void;

  /**
   * ì˜ˆìƒ ë¹„ìš©ì„ ì„¤ì •í•©ë‹ˆë‹¤ (ì¹´ë“œ ì„ íƒ/í˜¸ë²„ ì‹œ).
   */
  setCostEstimate: (estimate: CostEstimateState | null) => void;

  /**
   * ì¹´ë“œì˜ ë¹„ìš© ì •ë³´ë¡œ ì˜ˆìƒ ë¹„ìš©ì„ ì„¤ì •í•©ë‹ˆë‹¤.
   */
  setCostEstimateFromCard: (
    cost: CurrencyAmount,
    costEstimate: CostEstimate | null,
    actionId: string,
    label?: string,
  ) => void;

  /**
   * ë§ˆì§€ë§‰ í™•ì • ë¹„ìš©ì„ ì„¤ì •í•©ë‹ˆë‹¤ (TurnOutput ë°˜ì˜ ì‹œ).
   */
  setLastCost: (lastCost: LastCostState) => void;

  /**
   * ì”ì•¡ ë¶€ì¡± ìƒíƒœë¥¼ ì—…ë°ì´íŠ¸í•©ë‹ˆë‹¤.
   */
  updateBalanceLowStatus: (currentBalance: CurrencyAmount) => void;

  /**
   * ì”ì•¡ ë¶€ì¡± ì„ê³„ê°’ì„ ì„¤ì •í•©ë‹ˆë‹¤.
   */
  setLowBalanceThreshold: (threshold: number) => void;

  /**
   * ê±°ë˜ ì¥ë¶€ë¥¼ ì´ˆê¸°í™”í•©ë‹ˆë‹¤.
   */
  clearLedger: () => void;

  /**
   * ì „ì²´ ìƒíƒœë¥¼ ì´ˆê¸°í™”í•©ë‹ˆë‹¤.
   */
  reset: () => void;
}

export type EconomyStore = EconomyStoreState & EconomyStoreActions;

// =============================================================================
// ì´ˆê¸° ìƒíƒœ
// =============================================================================

function createInitialState(): EconomyStoreState {
  // U-049: ìŠ¤í¬ë¡¤ í…ŒìŠ¤íŠ¸ë¥¼ ìœ„í•œ ë”ë¯¸ ë°ì´í„° ì¶”ê°€
  const dummyLedger: LedgerEntry[] = [
    {
      turnId: 5,
      reason: '[í–‰ë™] ì€ì‹ í•˜ì—¬ ì ‘ê·¼: ê·¸ë¦¼ì ì†ì— ìˆ¨ì–´ ê²½ë¹„ë³‘ë“¤ì˜ ëˆˆì„ í”¼í–ˆìŠµë‹ˆë‹¤.',
      cost: { signal: 2, memory_shard: 0 },
      balanceAfter: { signal: 180, memory_shard: 10 },
      modelLabel: 'FAST',
      timestamp: Date.now() - 100,
    },
    {
      turnId: 4,
      reason: '[í–‰ë™] ì¥ì¹˜ í•´í‚¹: ë³µì¡í•œ ì•”í˜¸ë¥¼ í’€ì–´ë‚´ê³  í†µì œ ì‹œìŠ¤í…œì— ì ‘ì†í–ˆìŠµë‹ˆë‹¤.',
      cost: { signal: 6, memory_shard: 1 },
      balanceAfter: { signal: 182, memory_shard: 10 },
      modelLabel: 'QUALITY',
      timestamp: Date.now() - 500,
    },
    {
      turnId: 3,
      reason: '[í–‰ë™] ì£¼ë³€ì„ ì¡°ì‚¬í•œë‹¤: ë¨¼ì§€ ìŒ“ì¸ ì±…ìƒ ìœ„ì—ì„œ ë‚¡ì€ ì—´ì‡ ë¥¼ ë°œê²¬í–ˆìŠµë‹ˆë‹¤.',
      cost: { signal: 4, memory_shard: 0 },
      balanceAfter: { signal: 188, memory_shard: 10 },
      modelLabel: 'QUALITY',
      timestamp: Date.now() - 1000,
    },
    {
      turnId: 2,
      reason: '[í–‰ë™] ë§ì„ ê±¸ì–´ë³¸ë‹¤: ìƒëŒ€ë°©ì€ ë‹¹ì‹ ì˜ ë§ì— ì ì‹œ ì¹¨ë¬µí•˜ë”ë‹ˆ ê³ ê°œë¥¼ ë„ë•ì…ë‹ˆë‹¤.',
      cost: { signal: 3, memory_shard: 0 },
      balanceAfter: { signal: 192, memory_shard: 10 },
      modelLabel: 'FAST',
      timestamp: Date.now() - 2000,
    },
    {
      turnId: 1,
      reason: '[í–‰ë™] íƒìƒ‰í•˜ê¸°: ì–´ë‘ìš´ ë³µë„ë¥¼ ë”°ë¼ ê±·ì ë²½ë©´ì—ì„œ í¬ë¯¸í•œ ë¹›ì´ ìƒˆì–´ ë‚˜ì˜µë‹ˆë‹¤.',
      cost: { signal: 5, memory_shard: 0 },
      balanceAfter: { signal: 195, memory_shard: 10 },
      modelLabel: 'QUALITY',
      timestamp: Date.now() - 3000,
    },
    {
      turnId: 0,
      reason: 'ì´ˆê¸° ë°ì´í„° ë™ê¸°í™” ì™„ë£Œ',
      cost: { signal: 0, memory_shard: 0 },
      balanceAfter: { signal: 200, memory_shard: 10 },
      modelLabel: 'FAST',
      timestamp: Date.now() - 4000,
    },
  ];

  return {
    ledger: dummyLedger,
    costEstimate: null,
    lastCost: dummyLedger[0]
      ? {
          cost: dummyLedger[0].cost,
          balanceAfter: dummyLedger[0].balanceAfter,
          turnId: dummyLedger[0].turnId,
          modelLabel: dummyLedger[0].modelLabel,
        }
      : null,
    isBalanceLow: false,
    // RU-004-Q5: ì„ê³„ê°’ ìƒìˆ˜ SSOT (save/constants.ts)
    lowBalanceThreshold: LOW_BALANCE_THRESHOLD,
  };
}

// =============================================================================
// Zustand Store
// =============================================================================

/**
 * Economy ìƒíƒœ ìŠ¤í† ì–´.
 *
 * í„´ë³„ ë¹„ìš©/ì”ì•¡ ë³€í™”ë¥¼ ê±°ë˜ ì¥ë¶€(ledger)ìœ¼ë¡œ ì¶”ì í•˜ê³ ,
 * ì˜ˆìƒ ë¹„ìš©ê³¼ í™•ì • ë¹„ìš©ì„ UIì— ì œê³µí•©ë‹ˆë‹¤.
 *
 * @example
 * ```tsx
 * // ì˜ˆìƒ ë¹„ìš© ì„¤ì • (ì¹´ë“œ í˜¸ë²„ ì‹œ)
 * const setCostEstimateFromCard = useEconomyStore(s => s.setCostEstimateFromCard);
 * setCostEstimateFromCard(card.cost, card.cost_estimate, card.id, card.label);
 *
 * // í„´ ì™„ë£Œ ì‹œ ê±°ë˜ ì¥ë¶€ ê¸°ë¡
 * const addLedgerEntry = useEconomyStore(s => s.addLedgerEntry);
 * addLedgerEntry({
 *   turnId: turnCount,
 *   reason: 'explore',
 *   cost: turnOutput.economy.cost,
 *   balanceAfter: turnOutput.economy.balance_after,
 * });
 * ```
 */
export const useEconomyStore = create<EconomyStore>((set, get) => ({
  // ì´ˆê¸° ìƒíƒœ
  ...createInitialState(),

  // ì•¡ì…˜

  addLedgerEntry: (entry) => {
    const timestamp = Date.now();
    const newEntry: LedgerEntry = { ...entry, timestamp };

    set((state) => {
      // ìµœì‹ ìˆœìœ¼ë¡œ ì¶”ê°€í•˜ê³  ìµœëŒ€ ê°œìˆ˜ ìœ ì§€ (Q1: Option A)
      const updatedLedger = [newEntry, ...state.ledger].slice(0, LEDGER_MAX_ENTRIES);

      return {
        ledger: updatedLedger,
        lastCost: {
          cost: entry.cost,
          balanceAfter: entry.balanceAfter,
          turnId: entry.turnId,
          modelLabel: entry.modelLabel,
        },
        // U-079: ì„œë²„ì—ì„œ ì „ë‹¬ëœ ê²½ê³  ìƒíƒœ ë°˜ì˜
        isBalanceLow: entry.lowBalanceWarning ?? state.isBalanceLow,
        // í„´ ì™„ë£Œ í›„ ì˜ˆìƒ ë¹„ìš© ì´ˆê¸°í™”
        costEstimate: null,
      };
    });
  },

  hydrateLedger: (ledger, currentBalance) => {
    const { lowBalanceThreshold } = get();

    // LEDGER_MAX_ENTRIES ì •ì±… ì ìš© (ì €ì¥ëœ ê²ƒì´ ë” ë§ì„ ê²½ìš° ëŒ€ë¹„)
    const hydratedLedger = ledger.slice(0, LEDGER_MAX_ENTRIES);

    // lastCostëŠ” ê°€ì¥ ìµœì‹  ì—”íŠ¸ë¦¬(ì²« ì›ì†Œ) ê¸°ì¤€ìœ¼ë¡œ ì„¤ì •
    const latestEntry = hydratedLedger[0] ?? null;
    const lastCost: LastCostState | null = latestEntry
      ? {
          cost: latestEntry.cost,
          balanceAfter: latestEntry.balanceAfter,
          turnId: latestEntry.turnId,
          modelLabel: latestEntry.modelLabel,
        }
      : null;

    // isBalanceLowëŠ” ë³µì›ëœ ì”ì•¡ ê¸°ì¤€ìœ¼ë¡œ ì¬ê³„ì‚°
    const isBalanceLow = currentBalance.signal < lowBalanceThreshold;

    set({
      ledger: hydratedLedger,
      lastCost,
      isBalanceLow,
      costEstimate: null,
    });
  },

  setCostEstimate: (estimate) => {
    set({ costEstimate: estimate });
  },

  setCostEstimateFromCard: (cost, costEstimate, actionId, label) => {
    if (costEstimate) {
      set({
        costEstimate: {
          min: costEstimate.min,
          max: costEstimate.max,
          actionId,
          label,
        },
      });
    } else {
      // cost_estimateê°€ ì—†ìœ¼ë©´ ê¸°ë³¸ costë¥¼ min/maxë¡œ ì‚¬ìš©
      set({
        costEstimate: {
          min: cost,
          max: cost,
          actionId,
          label,
        },
      });
    }
  },

  setLastCost: (lastCost) => {
    set({ lastCost });
  },

  updateBalanceLowStatus: (currentBalance) => {
    const { lowBalanceThreshold } = get();
    const isLow = currentBalance.signal < lowBalanceThreshold;
    set({ isBalanceLow: isLow });
  },

  setLowBalanceThreshold: (threshold) => {
    set({ lowBalanceThreshold: threshold });
  },

  clearLedger: () => {
    set({ ledger: [], lastCost: null });
  },

  reset: () => {
    set(createInitialState());
  },
}));

// =============================================================================
// ì…€ë ‰í„° (ì„±ëŠ¥ ìµœì í™”ìš©)
// =============================================================================

/** ê±°ë˜ ì¥ë¶€ ì…€ë ‰í„° */
export const selectLedger = (state: EconomyStore) => state.ledger;

/** ì˜ˆìƒ ë¹„ìš© ì…€ë ‰í„° */
export const selectCostEstimate = (state: EconomyStore) => state.costEstimate;

/** ë§ˆì§€ë§‰ í™•ì • ë¹„ìš© ì…€ë ‰í„° */
export const selectLastCost = (state: EconomyStore) => state.lastCost;

/** ì”ì•¡ ë¶€ì¡± ìƒíƒœ ì…€ë ‰í„° */
export const selectIsBalanceLow = (state: EconomyStore) => state.isBalanceLow;

/** ìµœê·¼ Nê°œ ê±°ë˜ ì¥ë¶€ ì—”íŠ¸ë¦¬ ì…€ë ‰í„° */
export const selectRecentLedger =
  (count: number) =>
  (state: EconomyStore): LedgerEntry[] =>
    state.ledger.slice(0, count);

/** ì´ ì†Œë¹„ ë¹„ìš© ê³„ì‚° ì…€ë ‰í„° (í˜„ì¬ ì„¸ì…˜) */
export const selectTotalSpent = (state: EconomyStore): CurrencyAmount => {
  return state.ledger.reduce(
    (acc, entry) => ({
      signal: acc.signal + entry.cost.signal,
      memory_shard: acc.memory_shard + entry.cost.memory_shard,
    }),
    { signal: 0, memory_shard: 0 },
  );
};

// =============================================================================
// ìœ í‹¸ë¦¬í‹° í•¨ìˆ˜
// =============================================================================

/**
 * í˜„ì¬ ì”ì•¡ìœ¼ë¡œ ì˜ˆìƒ ë¹„ìš©ì„ ê°ë‹¹í•  ìˆ˜ ìˆëŠ”ì§€ í™•ì¸í•©ë‹ˆë‹¤.
 * RULE-005: ì”ì•¡ ë¶€ì¡± ì‹œ ì‹¤í–‰ ê°•í–‰ì´ ì•„ë‹ˆë¼ ëŒ€ì²´ í–‰ë™ì„ ì œì•ˆ.
 */
export function canAffordCost(
  balance: CurrencyAmount,
  cost: CurrencyAmount,
): { affordable: boolean; shortfall: CurrencyAmount } {
  const signalShortfall = Math.max(0, cost.signal - balance.signal);
  const shardShortfall = Math.max(0, cost.memory_shard - balance.memory_shard);

  return {
    affordable: signalShortfall === 0 && shardShortfall === 0,
    shortfall: { signal: signalShortfall, memory_shard: shardShortfall },
  };
}

/**
 * ì˜ˆìƒ ë¹„ìš©ì˜ ìµœëŒ€ê°’ìœ¼ë¡œ ê°ë‹¹ ê°€ëŠ¥ ì—¬ë¶€ë¥¼ í™•ì¸í•©ë‹ˆë‹¤.
 */
export function canAffordEstimate(
  balance: CurrencyAmount,
  estimate: CostEstimateState,
): { affordable: boolean; shortfall: CurrencyAmount } {
  return canAffordCost(balance, estimate.max);
}

// DEV: ë””ë²„ê·¸ìš© ê¸€ë¡œë²Œ ë…¸ì¶œ
if (import.meta.env.DEV) {
  (window as unknown as Record<string, unknown>).__economyStore = useEconomyStore;
}
</file>

<file path="frontend/src/stores/inventoryStore.ts">
/**
 * Unknown World - Inventory ìƒíƒœ ê´€ë¦¬ (Zustand) (U-011[Mvp]).
 *
 * Inventoryì˜ ì•„ì´í…œ ëª©ë¡, ë“œë˜ê·¸ ìƒíƒœ, ì„ íƒ ìƒíƒœë¥¼ ê´€ë¦¬í•©ë‹ˆë‹¤.
 *
 * ì„¤ê³„ ì›ì¹™:
 *   - RULE-002: InventoryëŠ” ê²Œì„ UIë¡œ ìƒì‹œ ë…¸ì¶œ
 *   - U-006 ì˜ì¡´: WorldDelta.inventory_added / inventory_removed í•„ë“œ ì—°ë™
 *   - U-012 ì—°ê²°: ë“œë˜ê·¸ ë°ì´í„°ì— item_idë¥¼ ì‹¤ì–´ ë“œë¡­ íƒ€ê²Ÿ(í•«ìŠ¤íŒŸ)ì— ì „ë‹¬
 *
 * U-075[Mvp]: ì•„ì´í…œ ì•„ì´ì½˜ ë™ì  ìƒì„±
 *   - Q1: Option B (placeholder ë¨¼ì € í‘œì‹œ í›„ ë°±ê·¸ë¼ìš´ë“œ ìƒì„±)
 *   - ì•„ì´ì½˜ ìƒì„± ìƒíƒœ ì¶”ì  ë° URL ì—…ë°ì´íŠ¸
 *
 * @module stores/inventoryStore
 */

import { create } from 'zustand';
// U-092: í”„ë¦¬ì…‹ ì•„ì´ì½˜ ë ˆì§€ìŠ¤íŠ¸ë¦¬
import { getPresetIconUrl } from '../data/itemIconPresets';

// =============================================================================
// íƒ€ì… ì •ì˜
// =============================================================================

/**
 * ì•„ì´ì½˜ ìƒì„± ìƒíƒœ.
 */
export type IconStatus = 'pending' | 'generating' | 'completed' | 'failed' | 'cached';

/**
 * ì¸ë²¤í† ë¦¬ ì•„ì´í…œ.
 * MVPì—ì„œëŠ” ìµœì†Œ í•„ë“œë§Œ ì •ì˜í•©ë‹ˆë‹¤.
 *
 * U-075: icon í•„ë“œëŠ” URL ë˜ëŠ” ì´ëª¨ì§€, iconStatusë¡œ ìƒì„± ìƒíƒœ ì¶”ì 
 */
export interface InventoryItem {
  /** ì•„ì´í…œ ê³ ìœ  ID */
  id: string;
  /** ì•„ì´í…œ ì´ë¦„ (í‘œì‹œìš©) */
  name: string;
  /** ì•„ì´í…œ ì„¤ëª… (ì„ íƒ) */
  description?: string;
  /** ì•„ì´í…œ ì•„ì´ì½˜ URL ë˜ëŠ” ì´ëª¨ì§€ (ì„ íƒ) */
  icon?: string;
  /** ì•„ì´í…œ ìˆ˜ëŸ‰ (ê¸°ë³¸ê°’: 1) */
  quantity: number;
  /** U-075: ì•„ì´ì½˜ ìƒì„± ìƒíƒœ (ì„ íƒ) */
  iconStatus?: IconStatus;
}

/** Inventory ìƒíƒœ */
export interface InventoryState {
  /** í˜„ì¬ ì•„ì´í…œ ëª©ë¡ */
  items: InventoryItem[];
  /** í˜„ì¬ ë“œë˜ê·¸ ì¤‘ì¸ ì•„ì´í…œ ID (nullì´ë©´ ë“œë˜ê·¸ ì¤‘ ì•„ë‹˜) */
  draggingItemId: string | null;
  /** ì„ íƒëœ ì•„ì´í…œ ID (í´ë¦­ ì„ íƒ, ë“œë˜ê·¸ì™€ ë³„ê°œ) */
  selectedItemId: string | null;
  /** U-096: ì†Œë¹„(ì‚­ì œ) ì• ë‹ˆë©”ì´ì…˜ ì§„í–‰ ì¤‘ì¸ ì•„ì´í…œ ID ì§‘í•© */
  consumingItemIds: string[];
}

/** Inventory ì•¡ì…˜ */
export interface InventoryActions {
  /** ì•„ì´í…œ ëª©ë¡ ì„¤ì • (ì „ì²´ êµì²´) */
  setItems: (items: InventoryItem[]) => void;
  /** ì•„ì´í…œ ì¶”ê°€ (ì¤‘ë³µ IDë©´ ìˆ˜ëŸ‰ ì¦ê°€) */
  addItems: (items: InventoryItem[]) => void;
  /** ì•„ì´í…œ ì œê±° (ID ëª©ë¡) */
  removeItems: (itemIds: string[]) => void;
  /** ë“œë˜ê·¸ ì‹œì‘ */
  startDrag: (itemId: string) => void;
  /** ë“œë˜ê·¸ ì¢…ë£Œ */
  endDrag: () => void;
  /** ì•„ì´í…œ ì„ íƒ */
  selectItem: (itemId: string | null) => void;
  /** ìƒíƒœ ì´ˆê¸°í™” */
  reset: () => void;
  /** U-075: ì•„ì´í…œ ì•„ì´ì½˜ ì—…ë°ì´íŠ¸ */
  updateItemIcon: (itemId: string, icon: string, status: IconStatus) => void;
  /** U-075: ì•„ì´í…œ ì•„ì´ì½˜ ìƒíƒœë§Œ ì—…ë°ì´íŠ¸ */
  setItemIconStatus: (itemId: string, status: IconStatus) => void;
  /**
   * U-096: ì•„ì´í…œì„ ì†Œë¹„(ì‚­ì œ) ì• ë‹ˆë©”ì´ì…˜ ìƒíƒœë¡œ ì „í™˜í•©ë‹ˆë‹¤.
   * fade-out ì• ë‹ˆë©”ì´ì…˜ ì‹œì‘ ì‹œ í˜¸ì¶œí•©ë‹ˆë‹¤.
   */
  markConsuming: (itemIds: string[]) => void;
  /**
   * U-096: ì†Œë¹„ ì• ë‹ˆë©”ì´ì…˜ ì™„ë£Œ í›„ ì•„ì´í…œì„ ì‹¤ì œë¡œ ì œê±°í•©ë‹ˆë‹¤.
   * markConsuming â†’ (ì• ë‹ˆë©”ì´ì…˜ ëŒ€ê¸°) â†’ clearConsuming ìˆœì„œë¡œ í˜¸ì¶œí•©ë‹ˆë‹¤.
   */
  clearConsuming: (itemIds: string[]) => void;
}

export type InventoryStore = InventoryState & InventoryActions;

// =============================================================================
// ì´ˆê¸° ìƒíƒœ
// =============================================================================

function createInitialState(): InventoryState {
  return {
    items: [],
    draggingItemId: null,
    selectedItemId: null,
    consumingItemIds: [],
  };
}

// =============================================================================
// Zustand Store
// =============================================================================

/**
 * Inventory ìƒíƒœ ìŠ¤í† ì–´.
 *
 * @example
 * ```tsx
 * const { items, addItems, removeItems, startDrag, endDrag } = useInventoryStore();
 *
 * // TurnOutput.world.inventory_added ìˆ˜ì‹  ì‹œ
 * addItems(inventoryAddedItems);
 *
 * // TurnOutput.world.inventory_removed ìˆ˜ì‹  ì‹œ
 * removeItems(inventoryRemovedIds);
 *
 * // dnd-kit onDragStart
 * startDrag(itemId);
 *
 * // dnd-kit onDragEnd
 * endDrag();
 * ```
 */
export const useInventoryStore = create<InventoryStore>((set) => ({
  // ì´ˆê¸° ìƒíƒœ
  ...createInitialState(),

  // ì•¡ì…˜
  setItems: (items) => {
    set({
      items,
      draggingItemId: null,
      selectedItemId: null,
    });
  },

  addItems: (newItems) => {
    set((state) => {
      const itemsMap = new Map(state.items.map((item) => [item.id, item]));

      for (const newItem of newItems) {
        const existing = itemsMap.get(newItem.id);
        if (existing) {
          // ê¸°ì¡´ ì•„ì´í…œì´ë©´ ìˆ˜ëŸ‰ ì¦ê°€
          itemsMap.set(newItem.id, {
            ...existing,
            quantity: existing.quantity + newItem.quantity,
          });
        } else {
          // ìƒˆ ì•„ì´í…œ ì¶”ê°€
          itemsMap.set(newItem.id, newItem);
        }
      }

      return { items: Array.from(itemsMap.values()) };
    });
  },

  removeItems: (itemIds) => {
    set((state) => {
      const countsToRemove = itemIds.reduce(
        (acc, id) => {
          acc[id] = (acc[id] || 0) + 1;
          return acc;
        },
        {} as Record<string, number>,
      );

      const nextItems = state.items
        .map((item) => {
          const toRemove = countsToRemove[item.id];
          if (!toRemove) return item;

          const nextQuantity = item.quantity - toRemove;
          if (nextQuantity <= 0) return null; // ìˆ˜ëŸ‰ì´ 0 ì´í•˜ë©´ ì œê±°
          return { ...item, quantity: nextQuantity };
        })
        .filter((item): item is InventoryItem => item !== null);

      const removedIds = new Set(
        state.items
          .filter((item) => !nextItems.find((ni) => ni.id === item.id))
          .map((item) => item.id),
      );

      return {
        items: nextItems,
        // ì™„ì „íˆ ì œê±°ëœ ì•„ì´í…œì´ ì„ íƒ/ë“œë˜ê·¸ ì¤‘ì´ì—ˆë‹¤ë©´ ì´ˆê¸°í™”
        selectedItemId: removedIds.has(state.selectedItemId ?? '') ? null : state.selectedItemId,
        draggingItemId: removedIds.has(state.draggingItemId ?? '') ? null : state.draggingItemId,
      };
    });
  },

  startDrag: (itemId) => {
    set({ draggingItemId: itemId });
  },

  endDrag: () => {
    set({ draggingItemId: null });
  },

  selectItem: (itemId) => {
    set({ selectedItemId: itemId });
  },

  reset: () => {
    set(createInitialState());
  },

  // U-075: ì•„ì´í…œ ì•„ì´ì½˜ ì—…ë°ì´íŠ¸
  updateItemIcon: (itemId, icon, status) => {
    set((state) => ({
      items: state.items.map((item) =>
        item.id === itemId ? { ...item, icon, iconStatus: status } : item,
      ),
    }));
  },

  // U-075: ì•„ì´í…œ ì•„ì´ì½˜ ìƒíƒœë§Œ ì—…ë°ì´íŠ¸
  setItemIconStatus: (itemId, status) => {
    set((state) => ({
      items: state.items.map((item) =>
        item.id === itemId ? { ...item, iconStatus: status } : item,
      ),
    }));
  },

  // U-096: ì•„ì´í…œ ì†Œë¹„ ì• ë‹ˆë©”ì´ì…˜ ì‹œì‘
  markConsuming: (itemIds) => {
    set((state) => ({
      consumingItemIds: [...new Set([...state.consumingItemIds, ...itemIds])],
    }));
  },

  // U-096: ì†Œë¹„ ì• ë‹ˆë©”ì´ì…˜ ì™„ë£Œ í›„ ì‹¤ì œ ì œê±°
  clearConsuming: (itemIds) => {
    set((state) => {
      const countsToRemove = itemIds.reduce(
        (acc, id) => {
          acc[id] = (acc[id] || 0) + 1;
          return acc;
        },
        {} as Record<string, number>,
      );

      const nextItems = state.items
        .map((item) => {
          const toRemove = countsToRemove[item.id];
          if (!toRemove) return item;

          const nextQuantity = item.quantity - toRemove;
          if (nextQuantity <= 0) return null;
          return { ...item, quantity: nextQuantity };
        })
        .filter((item): item is InventoryItem => item !== null);

      const removedIds = new Set(
        state.items
          .filter((item) => !nextItems.find((ni) => ni.id === item.id))
          .map((item) => item.id),
      );

      const removeSet = new Set(itemIds);
      return {
        items: nextItems,
        consumingItemIds: state.consumingItemIds.filter((id) => !removeSet.has(id)),
        // ì™„ì „íˆ ì œê±°ëœ ì•„ì´í…œì´ ì„ íƒ/ë“œë˜ê·¸ ì¤‘ì´ì—ˆë‹¤ë©´ ì´ˆê¸°í™”
        selectedItemId: removedIds.has(state.selectedItemId ?? '') ? null : state.selectedItemId,
        draggingItemId: removedIds.has(state.draggingItemId ?? '') ? null : state.draggingItemId,
      };
    });
  },
}));

// =============================================================================
// ì…€ë ‰í„° (ì„±ëŠ¥ ìµœì í™”ìš©)
// =============================================================================

/** ì•„ì´í…œ ëª©ë¡ ì…€ë ‰í„° */
export const selectItems = (state: InventoryStore) => state.items;

/** ë“œë˜ê·¸ ì¤‘ì¸ ì•„ì´í…œ ID ì…€ë ‰í„° */
export const selectDraggingItemId = (state: InventoryStore) => state.draggingItemId;

/** ë“œë˜ê·¸ ì¤‘ì¸ ì•„ì´í…œ ê°ì²´ ì…€ë ‰í„° */
export const selectDraggingItem = (state: InventoryStore) =>
  state.items.find((item) => item.id === state.draggingItemId) ?? null;

/** ì„ íƒëœ ì•„ì´í…œ ID ì…€ë ‰í„° */
export const selectSelectedItemId = (state: InventoryStore) => state.selectedItemId;

/** ì„ íƒëœ ì•„ì´í…œ ê°ì²´ ì…€ë ‰í„° */
export const selectSelectedItem = (state: InventoryStore) =>
  state.items.find((item) => item.id === state.selectedItemId) ?? null;

/** ì•„ì´í…œ ê°œìˆ˜ ì…€ë ‰í„° */
export const selectItemCount = (state: InventoryStore) => state.items.length;

/** U-096: ì†Œë¹„ ì¤‘ì¸ ì•„ì´í…œ ID ëª©ë¡ ì…€ë ‰í„° */
export const selectConsumingItemIds = (state: InventoryStore) => state.consumingItemIds;

// =============================================================================
// ìœ í‹¸ë¦¬í‹° í•¨ìˆ˜
// =============================================================================

/**
 * ì„œë²„ ì‘ë‹µ(inventory_added InventoryItemData ë°°ì—´)ì„ InventoryItem ë°°ì—´ë¡œ ë³€í™˜í•©ë‹ˆë‹¤.
 *
 * @param added - ì¶”ê°€ëœ ì•„ì´í…œ ë°ì´í„° ëª©ë¡ (ì„œë²„ ì‘ë‹µ)
 * @returns InventoryItem ë°°ì—´
 */
export function parseInventoryAdded(added: InventoryItemDataInput[]): InventoryItem[] {
  return added.map((item) => {
    // U-092: í”„ë¦¬ì…‹ ì•„ì´ì½˜ ìš°ì„  (Q2: icon_urlì´ ìˆìœ¼ë©´ í•­ìƒ í”„ë¦¬ì…‹ ìš°ì„ , ë™ì  ìƒì„± ê±´ë„ˆë›°ê¸°)
    const presetUrl = getPresetIconUrl(item.id);
    const iconUrl = presetUrl ?? item.icon_url ?? undefined;
    const status: IconStatus = iconUrl ? 'completed' : 'pending';

    return {
      id: item.id,
      name: item.label,
      description: item.description || item.label,
      icon: iconUrl,
      quantity: item.quantity ?? 1,
      iconStatus: status,
    };
  });
}

/** ì„œë²„ì—ì„œ ì˜¤ëŠ” InventoryItemData í˜•íƒœ (Zod ìŠ¤í‚¤ë§ˆì™€ ë™ì¼) */
export interface InventoryItemDataInput {
  id: string;
  label: string;
  description?: string;
  icon_url?: string | null;
  quantity?: number;
}

/**
 * ì•„ì´í…œ IDë¡œ ì•„ì´í…œì„ ì°¾ìŠµë‹ˆë‹¤.
 *
 * @param items - ì•„ì´í…œ ëª©ë¡
 * @param itemId - ì°¾ì„ ì•„ì´í…œ ID
 * @returns ì•„ì´í…œ ë˜ëŠ” undefined
 */
export function findItemById(items: InventoryItem[], itemId: string): InventoryItem | undefined {
  return items.find((item) => item.id === itemId);
}

// =============================================================================
// U-075: ì•„ì´ì½˜ ìƒì„± API
// =============================================================================

/** ì•„ì´ì½˜ ìƒì„± API ì‘ë‹µ */
interface IconApiResponse {
  status: string;
  icon_url: string;
  item_id: string;
  is_placeholder: boolean;
  message?: string;
}

/**
 * ì•„ì´í…œ ì•„ì´ì½˜ ìƒì„±ì„ ìš”ì²­í•©ë‹ˆë‹¤ (U-075[Mvp]).
 *
 * Q1 ê²°ì •: Option B - placeholder ë¨¼ì € ë°˜í™˜, ë°±ê·¸ë¼ìš´ë“œ ìƒì„±
 *
 * @param itemId - ì•„ì´í…œ ID
 * @param description - ì•„ì´í…œ ì„¤ëª…
 * @param language - ì„¸ì…˜ ì–¸ì–´
 * @returns ì•„ì´ì½˜ URL ë° ìƒíƒœ
 */
export async function requestItemIcon(
  itemId: string,
  description: string,
  language: string = 'ko-KR',
): Promise<{ iconUrl: string; status: IconStatus; isPlaceholder: boolean }> {
  const apiUrl = import.meta.env.VITE_API_BASE_URL || 'http://localhost:8011';

  try {
    const response = await fetch(`${apiUrl}/api/item/icon`, {
      method: 'POST',
      headers: {
        'Content-Type': 'application/json',
      },
      body: JSON.stringify({
        item_id: itemId,
        description: description,
        language: language,
        wait: false, // Q1: placeholder ì¦‰ì‹œ ë°˜í™˜
      }),
    });

    if (!response.ok) {
      console.warn(`[ItemIcon] API ìš”ì²­ ì‹¤íŒ¨: ${response.status}`);
      return { iconUrl: '', status: 'failed', isPlaceholder: true };
    }

    const data: IconApiResponse = await response.json();
    return {
      iconUrl: data.icon_url,
      status: data.status as IconStatus,
      isPlaceholder: data.is_placeholder,
    };
  } catch (error) {
    console.warn('[ItemIcon] ì•„ì´ì½˜ ìƒì„± ìš”ì²­ ì‹¤íŒ¨:', error);
    return { iconUrl: '', status: 'failed', isPlaceholder: true };
  }
}

/**
 * ì•„ì´ì½˜ ìƒì„± ìƒíƒœë¥¼ í´ë§í•©ë‹ˆë‹¤ (U-075[Mvp]).
 *
 * @param itemId - ì•„ì´í…œ ID
 * @returns í˜„ì¬ ìƒíƒœ
 */
export async function pollIconStatus(itemId: string): Promise<IconStatus> {
  const apiUrl = import.meta.env.VITE_API_BASE_URL || 'http://localhost:8011';

  try {
    const response = await fetch(`${apiUrl}/api/item/icon/${itemId}/status`);

    if (!response.ok) {
      return 'failed';
    }

    const data = await response.json();
    return data.status as IconStatus;
  } catch {
    return 'failed';
  }
}
</file>

<file path="backend/src/unknown_world/orchestrator/mock.py">
"""Unknown World - ëª¨ì˜ Orchestrator.

ì‹¤ëª¨ë¸(Gemini) ì—†ì´ í”„ë¡ íŠ¸ì—”ë“œ ê°œë°œ/ë°ëª¨ë¥¼ ì§€ì†í•  ìˆ˜ ìˆë„ë¡
ê²°ì •ì (seed ê¸°ë°˜) TurnOutputì„ ìƒì„±í•˜ëŠ” ëª¨ì˜ Orchestratorì…ë‹ˆë‹¤.

ì„¤ê³„ ì›ì¹™:
    - RULE-004: ê²€ì¦ ì‹¤íŒ¨ ì‹œ ì•ˆì „í•œ í´ë°± ì œê³µ
    - RULE-005: ì¬í™” ì¸ë°”ë¦¬ì–¸íŠ¸ (ì”ì•¡ ìŒìˆ˜ ê¸ˆì§€)
    - RULE-008: ë‹¨ê³„/ë°°ì§€ ê°€ì‹œí™”
    - RULE-009: ì¢Œí‘œ ê·œì•½ (0~1000, bbox [ymin,xmin,ymax,xmax])

ì°¸ì¡°:
    - vibe/unit-plans/U-007[Mvp].md
    - vibe/unit-plans/U-048[Mvp].md
    - .cursor/rules/20-backend-orchestrator.mdc
"""

import hashlib
import random
from enum import Enum

from unknown_world.models.turn import (
    ActionCard,
    ActionDeck,
    AgentConsole,
    AgentPhase,
    Box2D,
    CurrencyAmount,
    EconomyOutput,
    ImageJob,
    InventoryItemData,
    Language,
    MemoryPin,
    ModelLabel,
    Quest,
    RenderOutput,
    RiskLevel,
    SafetyOutput,
    SceneObject,
    TurnInput,
    TurnOutput,
    UIOutput,
    ValidationBadge,
    WorldDelta,
    WorldRule,
)
from unknown_world.orchestrator.fallback import (
    create_safe_fallback as _create_safe_fallback,
)

# =============================================================================
# ì…ë ¥ íƒ€ì… ë¶„ë¥˜ (U-048: í–‰ë™ ë¡œê·¸ í…œí”Œë¦¿ ë¶„ê¸°ìš©)
# =============================================================================


class InputType(str, Enum):
    """ì…ë ¥ íƒ€ì… ë¶„ë¥˜ (ìš°ì„ ìˆœìœ„: DROP > CLICK > ACTION > FREE_TEXT)."""

    DROP = "drop"  # ì•„ì´í…œ ë“œë¡­ (ì‚¬ìš©/ì¡°í•©)
    CLICK = "click"  # í•«ìŠ¤íŒŸ í´ë¦­ (ì¡°ì‚¬/ìƒí˜¸ì‘ìš©)
    ACTION = "action"  # ì•¡ì…˜ ì¹´ë“œ ì‹¤í–‰
    FREE_TEXT = "free_text"  # ììœ  ì…ë ¥


def _detect_input_type(turn_input: TurnInput) -> InputType:
    """TurnInputì—ì„œ ì…ë ¥ íƒ€ì…ì„ ê°ì§€ (ìš°ì„ ìˆœìœ„ ê¸°ë°˜).

    ìš°ì„ ìˆœìœ„: drop > click > action_id > free_text

    Args:
        turn_input: ì‚¬ìš©ì ì…ë ¥

    Returns:
        InputType: ê°ì§€ëœ ì…ë ¥ íƒ€ì…
    """
    if turn_input.drop is not None:
        return InputType.DROP
    if turn_input.click is not None:
        return InputType.CLICK
    if turn_input.action_id is not None:
        return InputType.ACTION
    return InputType.FREE_TEXT


def _compute_turn_seed(base_seed: int, turn_input: TurnInput) -> int:
    """per-turn ê²°ì •ì  ì‹œë“œ ìƒì„± (ì…ë ¥ íŠ¹ì§• í•´ì‹œ ê¸°ë°˜).

    base_seedì™€ ì…ë ¥ì˜ ì£¼ìš” íŠ¹ì§•ì„ í•´ì‹œí•˜ì—¬ í„´ë§ˆë‹¤ ë‹¤ë¥¸ ê²°ê³¼ë¥¼
    ìƒì„±í•˜ë©´ì„œë„ ì¬í˜„ì„±ì„ ìœ ì§€í•©ë‹ˆë‹¤.

    Args:
        base_seed: ê¸°ë³¸ ì‹œë“œ
        turn_input: ì‚¬ìš©ì ì…ë ¥

    Returns:
        int: per-turn ì‹œë“œ
    """
    # ì…ë ¥ íŠ¹ì§• ë¬¸ìì—´ ìƒì„±
    features: list[str] = [str(base_seed)]

    if turn_input.text:
        features.append(turn_input.text)
    if turn_input.action_id:
        features.append(turn_input.action_id)
    if turn_input.click:
        features.append(turn_input.click.object_id)
    if turn_input.drop:
        features.append(turn_input.drop.item_id)
        features.append(turn_input.drop.target_object_id)

    # íŠ¹ì§• ë¬¸ìì—´ì„ í•´ì‹œí•˜ì—¬ ì‹œë“œ ìƒì„±
    feature_str = "|".join(features)
    hash_bytes = hashlib.sha256(feature_str.encode("utf-8")).digest()
    # í•´ì‹œì˜ ì²˜ìŒ 8ë°”ì´íŠ¸ë¥¼ ì •ìˆ˜ë¡œ ë³€í™˜
    return int.from_bytes(hash_bytes[:8], byteorder="big") % (2**32)


# =============================================================================
# í–‰ë™ ë¡œê·¸ í”„ë¦¬í”½ìŠ¤ í…œí”Œë¦¿ (U-048: "ë§í–ˆìŠµë‹ˆë‹¤" ì œê±°)
# =============================================================================

# í•œêµ­ì–´ í–‰ë™ ë¡œê·¸ í”„ë¦¬í”½ìŠ¤ (ì…ë ¥ íƒ€ì…ë³„)
# U-062: ì–¸ì–´ í˜¼í•© ë°©ì§€ë¥¼ ìœ„í•´ ì‚¬ìš©ì ì…ë ¥ í…ìŠ¤íŠ¸ë¥¼ í”„ë¦¬í”½ìŠ¤ì— í¬í•¨í•˜ì§€ ì•ŠìŒ
KO_ACTION_LOG_PREFIXES: dict[InputType, list[str]] = {
    InputType.DROP: [
        "[ì‚¬ìš©] {item} â†’ {target}:",
        "[ì¡°í•©] {item}ì„(ë¥¼) {target}ì— ì‚¬ìš©:",
        "[ì ìš©] {item} â†’ {target}:",
    ],
    InputType.CLICK: [
        "[ì¡°ì‚¬] {object}:",
        "[íƒìƒ‰] {object}ì„(ë¥¼) ì‚´í´ë´„:",
        "[ìƒí˜¸ì‘ìš©] {object}:",
    ],
    InputType.ACTION: [
        "[í–‰ë™]",
        "[ì‹¤í–‰]",
        "[ì‹œë„]",
    ],
    InputType.FREE_TEXT: [
        "[í–‰ë™]",
        "[ì‹œë„]",
        "[íƒìƒ‰]",
    ],
}

# ì˜ì–´ í–‰ë™ ë¡œê·¸ í”„ë¦¬í”½ìŠ¤ (ì…ë ¥ íƒ€ì…ë³„)
# U-062: ì–¸ì–´ í˜¼í•© ë°©ì§€ë¥¼ ìœ„í•´ ì‚¬ìš©ì ì…ë ¥ í…ìŠ¤íŠ¸ë¥¼ í”„ë¦¬í”½ìŠ¤ì— í¬í•¨í•˜ì§€ ì•ŠìŒ
EN_ACTION_LOG_PREFIXES: dict[InputType, list[str]] = {
    InputType.DROP: [
        "[USE] {item} â†’ {target}:",
        "[APPLY] {item} on {target}:",
        "[COMBINE] {item} with {target}:",
    ],
    InputType.CLICK: [
        "[EXAMINE] {object}:",
        "[INSPECT] {object}:",
        "[INTERACT] {object}:",
    ],
    InputType.ACTION: [
        "[ACTION]",
        "[EXECUTE]",
        "[ATTEMPT]",
    ],
    InputType.FREE_TEXT: [
        "[ACTION]",
        "[ATTEMPT]",
        "[EXPLORE]",
    ],
}


def _format_action_log_prefix(
    rng: random.Random,
    input_type: InputType,
    turn_input: TurnInput,
    is_korean: bool,
) -> str:
    """ì…ë ¥ íƒ€ì…ì— ë§ëŠ” í–‰ë™ ë¡œê·¸ í”„ë¦¬í”½ìŠ¤ ìƒì„±.

    U-062: ì–¸ì–´ í˜¼í•© ë°©ì§€ë¥¼ ìœ„í•´ ì‚¬ìš©ì ì…ë ¥ í…ìŠ¤íŠ¸(text, action_id)ëŠ”
    í”„ë¦¬í”½ìŠ¤ì— í¬í•¨í•˜ì§€ ì•ŠìŠµë‹ˆë‹¤. ì˜¤ì§ DROP/CLICKì˜ ì˜¤ë¸Œì íŠ¸ IDë§Œ í¬í•¨í•©ë‹ˆë‹¤.
    (ì˜¤ë¸Œì íŠ¸ IDëŠ” ì‹œìŠ¤í…œì´ ìƒì„±í•œ ê²ƒì´ë¯€ë¡œ ì–¸ì–´ í˜¼í•© ìœ„í—˜ ì—†ìŒ)

    Args:
        rng: ëœë¤ ìƒì„±ê¸°
        input_type: ì…ë ¥ íƒ€ì…
        turn_input: ì‚¬ìš©ì ì…ë ¥
        is_korean: í•œêµ­ì–´ ì—¬ë¶€

    Returns:
        str: í¬ë§·ëœ í–‰ë™ ë¡œê·¸ í”„ë¦¬í”½ìŠ¤
    """
    templates = KO_ACTION_LOG_PREFIXES if is_korean else EN_ACTION_LOG_PREFIXES
    template = rng.choice(templates[input_type])

    # ì…ë ¥ íƒ€ì…ë³„ í¬ë§· ì¸ì ì¤€ë¹„
    # U-062: ACTION/FREE_TEXTëŠ” ì‚¬ìš©ì ì…ë ¥ í…ìŠ¤íŠ¸ë¥¼ í¬í•¨í•˜ì§€ ì•ŠìŒ (ì–¸ì–´ í˜¼í•© ë°©ì§€)
    format_args: dict[str, str] = {}

    if input_type == InputType.DROP and turn_input.drop:
        format_args["item"] = turn_input.drop.item_id
        format_args["target"] = turn_input.drop.target_object_id
    elif input_type == InputType.CLICK and turn_input.click:
        format_args["object"] = turn_input.click.object_id
    # InputType.ACTION, InputType.FREE_TEXTëŠ” í¬ë§· ì¸ì ì—†ìŒ

    return template.format(**format_args)


# =============================================================================
# ëª¨ì˜ ë°ì´í„° ìƒì„± í—¬í¼
# =============================================================================

# í•œêµ­ì–´ ë‚´ëŸ¬í‹°ë¸Œ í…œí”Œë¦¿
KO_NARRATIVES = [
    "ì–´ë‘  ì†ì—ì„œ í¬ë¯¸í•œ ë¹›ì´ ìƒˆì–´ë‚˜ì˜µë‹ˆë‹¤. ì˜¤ë˜ëœ ë¬¸ì´ ì‚ê±±ê±°ë¦¬ë©° ì—´ë¦¬ê³ , ê·¸ ë„ˆë¨¸ë¡œ ì•Œ ìˆ˜ ì—†ëŠ” ì„¸ê³„ê°€ í¼ì³ì§‘ë‹ˆë‹¤.",
    "ë°œê±¸ìŒ ì†Œë¦¬ê°€ í…… ë¹ˆ ë³µë„ì— ë©”ì•„ë¦¬ì¹©ë‹ˆë‹¤. ë²½ì— ê±¸ë¦° ì´ˆìƒí™”ë“¤ì˜ ëˆˆì´ ë‹¹ì‹ ì„ ë”°ë¼ ì›€ì§ì´ëŠ” ê²ƒ ê°™ìŠµë‹ˆë‹¤.",
    "ê°‘ìê¸° ë°”ë‹¥ì´ í”ë“¤ë¦¬ë©°, ë²½ì—ì„œ ê³ ëŒ€ì˜ ë¬¸ìë“¤ì´ ë¹›ë‚˜ê¸° ì‹œì‘í•©ë‹ˆë‹¤. ë¬´ì–¸ê°€ê°€ ê¹¨ì–´ë‚˜ê³  ìˆìŠµë‹ˆë‹¤.",
    "ì•ˆê°œê°€ ê±·íˆì, ê±°ëŒ€í•œ íƒ‘ì´ ëª¨ìŠµì„ ë“œëŸ¬ëƒ…ë‹ˆë‹¤. íƒ‘ ê¼­ëŒ€ê¸°ì—ì„œ ì´ìƒí•œ ë¹›ì´ ê¹œë¹¡ì´ê³  ìˆìŠµë‹ˆë‹¤.",
    "ë‚¡ì€ ì±…ì¥ì„ ë°€ì, ìˆ¨ê²¨ì§„ í†µë¡œê°€ ë‚˜íƒ€ë‚¬ìŠµë‹ˆë‹¤. í†µë¡œ ëì—ì„œ ê¸°ë¬˜í•œ ë…¸ë˜ê°€ ë“¤ë ¤ì˜µë‹ˆë‹¤.",
]

# ì˜ì–´ ë‚´ëŸ¬í‹°ë¸Œ í…œí”Œë¦¿
EN_NARRATIVES = [
    "A faint light seeps through the darkness. An ancient door creaks open, revealing an unknown world beyond.",
    "Footsteps echo through the empty corridor. The eyes of the portraits on the walls seem to follow you.",
    "Suddenly, the ground shakes and ancient runes on the walls begin to glow. Something is awakening.",
    "As the fog lifts, a massive tower reveals itself. A strange light flickers at its peak.",
    "Pushing aside the old bookshelf, you discover a hidden passage. An eerie song emanates from its depths.",
]

# í•œêµ­ì–´ ì•¡ì…˜ ì¹´ë“œ í…œí”Œë¦¿
KO_ACTION_CARDS = [
    {"label": "ë¬¸ì„ ì—´ì–´ë³¸ë‹¤", "description": "ì¡°ì‹¬ìŠ¤ëŸ½ê²Œ ë¬¸ì„ ì—´ì–´ ì•ˆì„ ì‚´í´ë³¸ë‹¤"},
    {"label": "ì£¼ë³€ì„ íƒìƒ‰í•œë‹¤", "description": "ì£¼ë³€ì— ìœ ìš©í•œ ë¬¼ê±´ì´ ìˆëŠ”ì§€ ì°¾ì•„ë³¸ë‹¤"},
    {"label": "ë’¤ë¡œ ë¬¼ëŸ¬ì„ ë‹¤", "description": "ìœ„í—˜ì„ í”¼í•´ ì•ˆì „í•œ ê³³ìœ¼ë¡œ ë¬¼ëŸ¬ì„ ë‹¤"},
    {"label": "ë§ì„ ê±¸ì–´ë³¸ë‹¤", "description": "ìƒëŒ€ë°©ì—ê²Œ ì¡°ì‹¬ìŠ¤ëŸ½ê²Œ ë§ì„ ê±´ë‹¤"},
    {"label": "ìˆ¨ì–´ì„œ ì§€ì¼œë³¸ë‹¤", "description": "ì€ì‹ í•˜ì—¬ ìƒí™©ì„ ê´€ì°°í•œë‹¤"},
    {"label": "ê³µê²©í•œë‹¤", "description": "ìœ„í˜‘ì— ë§ì„œ ê³µê²©ì„ ì‹œë„í•œë‹¤"},
]

# ì˜ì–´ ì•¡ì…˜ ì¹´ë“œ í…œí”Œë¦¿
EN_ACTION_CARDS = [
    {"label": "Open the door", "description": "Carefully open the door and look inside"},
    {"label": "Search the area", "description": "Look for useful items nearby"},
    {"label": "Step back", "description": "Retreat to a safe place to avoid danger"},
    {"label": "Speak to them", "description": "Cautiously initiate conversation"},
    {"label": "Hide and observe", "description": "Conceal yourself and watch the situation"},
    {"label": "Attack", "description": "Confront the threat with an attack"},
]

# ì¥ë©´ ì˜¤ë¸Œì íŠ¸ í…œí”Œë¦¿
SCENE_OBJECTS_KO = [
    {"label": "ë‚¡ì€ ë¬¸", "hint": "í´ë¦­í•˜ì—¬ ì—´ì–´ë³¼ ìˆ˜ ìˆìŠµë‹ˆë‹¤"},
    {"label": "ë¹›ë‚˜ëŠ” ë³´ì„", "hint": "ìˆ˜ì§‘í•  ìˆ˜ ìˆì„ ê²ƒ ê°™ìŠµë‹ˆë‹¤"},
    {"label": "ìˆ˜ìƒí•œ ìƒì", "hint": "ë¬´ì–¸ê°€ ë“¤ì–´ìˆì„ ìˆ˜ ìˆìŠµë‹ˆë‹¤"},
    {"label": "ë²½ì˜ ìŠ¤ìœ„ì¹˜", "hint": "ì‘ë™ì‹œí‚¬ ìˆ˜ ìˆìŠµë‹ˆë‹¤"},
]

SCENE_OBJECTS_EN = [
    {"label": "Old door", "hint": "Click to open"},
    {"label": "Glowing gem", "hint": "It looks collectible"},
    {"label": "Suspicious chest", "hint": "Something might be inside"},
    {"label": "Wall switch", "hint": "Can be activated"},
]


def _generate_random_box(rng: random.Random) -> Box2D:
    """ëœë¤ ë°”ìš´ë”© ë°•ìŠ¤ ìƒì„± (0~1000 ì¢Œí‘œê³„)."""
    ymin = rng.randint(0, 700)
    xmin = rng.randint(0, 700)
    ymax = ymin + rng.randint(50, 250)
    xmax = xmin + rng.randint(50, 250)
    # ë²”ìœ„ ë³´ì •
    ymax = min(ymax, 1000)
    xmax = min(xmax, 1000)
    return Box2D(ymin=ymin, xmin=xmin, ymax=ymax, xmax=xmax)


# =============================================================================
# MockOrchestrator í´ë˜ìŠ¤
# =============================================================================


class MockOrchestrator:
    """ëª¨ì˜ Orchestrator.

    ì‹¤ëª¨ë¸(Gemini) ì—†ì´ TurnOutputì„ ìƒì„±í•˜ëŠ” ëª¨ì˜ ì˜¤ì¼€ìŠ¤íŠ¸ë ˆì´í„°ì…ë‹ˆë‹¤.
    seed ê¸°ë°˜ìœ¼ë¡œ ê²°ì •ì (ì¬í˜„ ê°€ëŠ¥)ì¸ ê²°ê³¼ë¥¼ ìƒì„±í•©ë‹ˆë‹¤.

    Note:
        Phase ìˆœì„œëŠ” pipeline.pyì˜ DEFAULT_STAGESê°€ SSOTì…ë‹ˆë‹¤ (RU-005-Q1).

    Attributes:
        seed: ëœë¤ ì‹œë“œ (ì¬í˜„ì„± ë³´ì¥)

    Example:
        >>> orchestrator = MockOrchestrator(seed=42)
        >>> turn_input = TurnInput(
        ...     language=Language.KO,
        ...     text="ë¬¸ì„ ì—´ì–´ë³¸ë‹¤",
        ...     client=ClientInfo(viewport_w=1920, viewport_h=1080),
        ...     economy_snapshot=EconomySnapshot(signal=100, memory_shard=5),
        ... )
        >>> output = orchestrator.generate_turn_output(turn_input)
    """

    def __init__(self, seed: int | None = None) -> None:
        """MockOrchestrator ì´ˆê¸°í™”.

        Args:
            seed: ëœë¤ ì‹œë“œ. Noneì´ë©´ ëœë¤í•˜ê²Œ ìƒì„±.
        """
        self.seed = seed if seed is not None else random.randint(0, 2**32 - 1)
        self._rng = random.Random(self.seed)

    def generate_turn_output(self, turn_input: TurnInput) -> TurnOutput:
        """TurnInputì„ ë°›ì•„ TurnOutputì„ ìƒì„±í•©ë‹ˆë‹¤.

        Args:
            turn_input: ì‚¬ìš©ì ì…ë ¥

        Returns:
            TurnOutput: ëª¨ì˜ í„´ ê²°ê³¼
        """
        is_korean = turn_input.language == Language.KO

        # U-048: per-turn ê²°ì •ì  RNG ìƒì„± (ì…ë ¥ì— ë”°ë¼ ë‹¤ë¥¸ ê²°ê³¼)
        turn_seed = _compute_turn_seed(self.seed, turn_input)
        turn_rng = random.Random(turn_seed)

        # ë‚´ëŸ¬í‹°ë¸Œ ìƒì„± (per-turn RNG ì‚¬ìš©ìœ¼ë¡œ ì…ë ¥ë³„ ë‹¤ì–‘ì„± í™•ë³´)
        narratives = KO_NARRATIVES if is_korean else EN_NARRATIVES
        narrative = turn_rng.choice(narratives)

        # U-048: ì…ë ¥ íƒ€ì…ë³„ í–‰ë™ ë¡œê·¸ í”„ë¦¬í”½ìŠ¤ ì ìš© ("ë§í–ˆìŠµë‹ˆë‹¤" ì œê±°)
        input_type = _detect_input_type(turn_input)
        has_meaningful_input = (
            turn_input.drop is not None
            or turn_input.click is not None
            or turn_input.action_id is not None
            or (turn_input.text and turn_input.text.strip())
        )

        if has_meaningful_input:
            prefix = _format_action_log_prefix(turn_rng, input_type, turn_input, is_korean)
            narrative = f"{prefix} {narrative}"

        # U-048: ëª¨ë“  ìƒì„±ì— turn_rng ì‚¬ìš© (ì…ë ¥ë³„ ê²°ì •ì  ë‹¤ì–‘ì„±)
        # ì•¡ì…˜ ë± ìƒì„± (3~6ì¥)
        action_templates = KO_ACTION_CARDS if is_korean else EN_ACTION_CARDS
        num_cards = turn_rng.randint(3, 6)
        selected_templates = turn_rng.sample(
            action_templates, min(num_cards, len(action_templates))
        )

        action_cards: list[ActionCard] = []
        for i, template in enumerate(selected_templates):
            cost_signal = turn_rng.randint(1, 10)
            cost_shard = 1 if turn_rng.random() < 0.2 else 0  # 20% í™•ë¥ ë¡œ shard ì†Œë¹„

            # U-065: description, hint í•„ë“œ ì œê±°ë¨ (narrativeì—ì„œ ìì—°ì–´ë¡œ í‘œí˜„)
            action_cards.append(
                ActionCard(
                    id=f"action_{i + 1}",
                    label=template["label"],
                    cost=CurrencyAmount(signal=cost_signal, memory_shard=cost_shard),
                    risk=turn_rng.choice(list(RiskLevel)),
                )
            )

        action_deck = ActionDeck(cards=action_cards)

        # ì¥ë©´ ì˜¤ë¸Œì íŠ¸ ìƒì„± (1~3ê°œ)
        object_templates = SCENE_OBJECTS_KO if is_korean else SCENE_OBJECTS_EN
        num_objects = turn_rng.randint(1, 3)
        selected_objects = turn_rng.sample(
            object_templates, min(num_objects, len(object_templates))
        )

        scene_objects: list[SceneObject] = []
        for i, template in enumerate(selected_objects):
            scene_objects.append(
                SceneObject(
                    id=f"obj_{i + 1}",
                    label=template["label"],
                    box_2d=_generate_random_box(turn_rng),
                    interaction_hint=template["hint"],
                )
            )

        ui_output = UIOutput(action_deck=action_deck, objects=scene_objects)

        # ì„¸ê³„ ìƒíƒœ ë³€í™” (delta) - turn_rng ì „ë‹¬
        world_delta = self._generate_world_delta(is_korean, turn_rng)

        # ë Œë”ë§ ì¶œë ¥ (ì´ë¯¸ì§€ ìƒì„±ì€ ì„ íƒì )
        should_generate_image = turn_rng.random() < 0.3  # 30% í™•ë¥ ë¡œ ì´ë¯¸ì§€ ìƒì„±
        render_output = RenderOutput(
            image_job=ImageJob(
                should_generate=should_generate_image,
                prompt="A mysterious dungeon scene" if should_generate_image else "",
                model_label=ModelLabel.FAST,
                aspect_ratio="16:9",
                image_size="1024x576",
            )
            if should_generate_image
            else None
        )

        # ê²½ì œ ì¶œë ¥ (ë¹„ìš© ê³„ì‚°)
        turn_cost = CurrencyAmount(
            signal=turn_rng.randint(1, 5),
            memory_shard=0,
        )

        # ì”ì•¡ ê³„ì‚° (ìŒìˆ˜ ë°©ì§€ - RULE-005)
        balance_signal = max(0, turn_input.economy_snapshot.signal - turn_cost.signal)
        balance_shard = max(0, turn_input.economy_snapshot.memory_shard - turn_cost.memory_shard)

        economy_output = EconomyOutput(
            cost=turn_cost,
            balance_after=CurrencyAmount(signal=balance_signal, memory_shard=balance_shard),
        )

        # ì•ˆì „ ì¶œë ¥
        safety_output = SafetyOutput(blocked=False, message=None)

        # ì—ì´ì „íŠ¸ ì½˜ì†”
        agent_console = AgentConsole(
            current_phase=AgentPhase.COMMIT,
            badges=[
                ValidationBadge.SCHEMA_OK,
                ValidationBadge.ECONOMY_OK,
                ValidationBadge.SAFETY_OK,
                ValidationBadge.CONSISTENCY_OK,
            ],
            repair_count=0,
        )

        return TurnOutput(
            language=turn_input.language,
            narrative=narrative,
            ui=ui_output,
            world=world_delta,
            render=render_output,
            economy=economy_output,
            safety=safety_output,
            agent_console=agent_console,
        )

    def _generate_world_delta(
        self, is_korean: bool, rng: random.Random | None = None
    ) -> WorldDelta:
        """ì„¸ê³„ ìƒíƒœ ë³€í™” ìƒì„±.

        Args:
            is_korean: í•œêµ­ì–´ ì—¬ë¶€
            rng: ì‚¬ìš©í•  RNG (Noneì´ë©´ self._rng ì‚¬ìš©, U-048 í•˜ìœ„í˜¸í™˜)

        Returns:
            WorldDelta: ìƒì„±ëœ ì„¸ê³„ ìƒíƒœ ë³€í™”
        """
        # U-048: per-turn RNG ì§€ì› (í•˜ìœ„í˜¸í™˜ ìœ ì§€)
        use_rng = rng if rng is not None else self._rng

        # ê·œì¹™ ë³€ê²½ (20% í™•ë¥ )
        rules_changed: list[WorldRule] = []
        if use_rng.random() < 0.2:
            rules_changed.append(
                WorldRule(
                    id="rule_gravity",
                    label="ì¤‘ë ¥ ë°˜ì „" if is_korean else "Gravity Inversion",
                    description=(
                        "ì´ êµ¬ì—­ì—ì„œëŠ” ì¤‘ë ¥ì´ ë°˜ëŒ€ë¡œ ì‘ìš©í•©ë‹ˆë‹¤"
                        if is_korean
                        else "Gravity works in reverse in this area"
                    ),
                )
            )

        # ì¸ë²¤í† ë¦¬ ì¶”ê°€ (30% í™•ë¥ )
        inventory_added: list[InventoryItemData] = []
        if use_rng.random() < 0.3:
            items_ko = [
                {
                    "id": "old_key",
                    "label": "ë‚¡ì€ ì—´ì‡ ",
                    "description": "ë…¹ìŠ¬ê³  ì˜¤ë˜ëœ ì² ì œ ì—´ì‡ ì…ë‹ˆë‹¤.",
                },
                {
                    "id": "mystic_orb",
                    "label": "ì‹ ë¹„ë¡œìš´ êµ¬ìŠ¬",
                    "description": "ì€ì€í•œ í‘¸ë¥¸ ë¹›ì„ ë‚´ë¿œëŠ” íˆ¬ëª…í•œ êµ¬ìŠ¬ì…ë‹ˆë‹¤.",
                },
                {
                    "id": "ancient_scroll",
                    "label": "ê³ ëŒ€ì˜ ë‘ë£¨ë§ˆë¦¬",
                    "description": "ì•Œ ìˆ˜ ì—†ëŠ” ë¬¸ìê°€ ì íŒ ë‚¡ì€ ì–‘í”¼ì§€ ë‘ë£¨ë§ˆë¦¬ì…ë‹ˆë‹¤.",
                },
            ]
            items_en = [
                {"id": "old_key", "label": "Old Key", "description": "A rusty and old iron key."},
                {
                    "id": "mystic_orb",
                    "label": "Mysterious Orb",
                    "description": "A transparent orb emitting a faint blue light.",
                },
                {
                    "id": "ancient_scroll",
                    "label": "Ancient Scroll",
                    "description": "An old parchment scroll with unknown characters.",
                },
            ]
            templates = items_ko if is_korean else items_en
            selected = use_rng.choice(templates)
            inventory_added.append(
                InventoryItemData(
                    id=selected["id"],
                    label=selected["label"],
                    description=selected["description"],
                    quantity=1,
                )
            )

        # í€˜ìŠ¤íŠ¸ ì—…ë°ì´íŠ¸ (25% í™•ë¥ )
        quests_updated: list[Quest] = []
        if use_rng.random() < 0.25:
            quests_updated.append(
                Quest(
                    id="quest_explore",
                    label="ë¯¸ì§€ì˜ ì˜ì—­ íƒí—˜" if is_korean else "Explore Unknown Territory",
                    is_completed=use_rng.random() < 0.3,
                )
            )

        # ë©”ëª¨ë¦¬ í•€ (15% í™•ë¥ )
        memory_pins: list[MemoryPin] = []
        if use_rng.random() < 0.15:
            memory_pins.append(
                MemoryPin(
                    id="pin_1",
                    content="ì´ ì¥ì†Œì˜ ì´ë¦„ì€ 'ìŠí˜€ì§„ ì„±ì†Œ'"
                    if is_korean
                    else "This place is called 'Forgotten Sanctuary'",
                    cost=CurrencyAmount(signal=0, memory_shard=1),
                )
            )

        return WorldDelta(
            rules_changed=rules_changed,
            inventory_added=inventory_added,
            inventory_removed=[],
            quests_updated=quests_updated,
            relationships_changed=[],
            memory_pins=memory_pins,
        )

    def create_safe_fallback(
        self,
        language: Language,
        error_message: str | None = None,  # noqa: ARG002 - í•˜ìœ„ í˜¸í™˜ìš© (ì‹¤ì œë¡œ ì‚¬ìš©í•˜ì§€ ì•ŠìŒ)
        economy_snapshot: CurrencyAmount | None = None,
    ) -> TurnOutput:
        """ì•ˆì „í•œ í´ë°± TurnOutput ìƒì„± (RULE-004, RU-002-S1).

        ìŠ¤í‚¤ë§ˆ ê²€ì¦ ì‹¤íŒ¨ ì‹œ ë°˜í™˜í•  ì•ˆì „í•œ ê¸°ë³¸ ì‘ë‹µì…ë‹ˆë‹¤.
        í´ë°± ì‹œ economy.balance_afterëŠ” ì…ë ¥ ìŠ¤ëƒ…ìƒ·ì„ ê·¸ëŒ€ë¡œ ìœ ì§€í•©ë‹ˆë‹¤ (ë¹„ìš© 0, ì”ì•¡ ë³€í™” ì—†ìŒ).

        Note:
            ì´ ë©”ì„œë“œëŠ” fallback.create_safe_fallback SSOTë¡œ ìœ„ì„í•©ë‹ˆë‹¤ (RU-005-Q1).

        Args:
            language: ì‘ë‹µ ì–¸ì–´
            error_message: ì—ëŸ¬ ë©”ì‹œì§€ (í•˜ìœ„ í˜¸í™˜ìš©, ì‹¤ì œ ë¯¸ì‚¬ìš©)
            economy_snapshot: ìš”ì²­ ì§ì „ ì¬í™” ìŠ¤ëƒ…ìƒ· (í´ë°± ì‹œ ì”ì•¡ ìœ ì§€ìš©)

        Returns:
            TurnOutput: ì•ˆì „í•œ í´ë°± ì‘ë‹µ
        """
        # RU-005-Q1: fallback SSOTë¡œ ìœ„ì„
        return _create_safe_fallback(
            language=language,
            economy_snapshot=economy_snapshot,
            repair_count=1,  # Mockì—ì„œëŠ” ê¸°ë³¸ ë³µêµ¬ ì‹œë„ 1íšŒë¡œ í‘œì‹œ
            is_blocked=False,
        )
</file>

<file path="backend/src/unknown_world/orchestrator/stages/render_helpers.py">
"""Unknown World - ì´ë¯¸ì§€ ìƒì„± íŒì • í—¬í¼.

ì´ ëª¨ë“ˆì€ TurnOutputì˜ image_jobì„ ë¶„ì„í•˜ì—¬ ì´ë¯¸ì§€ ìƒì„± ì—¬ë¶€ë¥¼ íŒì •í•˜ê³ ,
Economy ê¸°ë°˜ìœ¼ë¡œ ì”ì•¡ ê²€ì¦ì„ ìˆ˜í–‰í•˜ëŠ” í—¬í¼ í•¨ìˆ˜ë“¤ì„ ì œê³µí•©ë‹ˆë‹¤.

ì„¤ê³„ ì›ì¹™:
    - RULE-005: ì¬í™” ì¸ë°”ë¦¬ì–¸íŠ¸ (ì”ì•¡ ìŒìˆ˜ ê¸ˆì§€, ì˜ˆìƒ ë¹„ìš© ì‚¬ì „ í‘œì‹œ)
    - RULE-007: í”„ë¡¬í”„íŠ¸ ì›ë¬¸ ë¡œê·¸ ë…¸ì¶œ ê¸ˆì§€ (í•´ì‹œë§Œ ì‚¬ìš©)
    - RULE-008: í…ìŠ¤íŠ¸ ìš°ì„  + Lazy ì´ë¯¸ì§€ ì›ì¹™
    - ìˆœìˆ˜ í•¨ìˆ˜: í…ŒìŠ¤íŠ¸ ìš©ì´ì„±ì„ ìœ„í•´ ë¶€ì‘ìš© ì—†ëŠ” ìˆœìˆ˜ í•¨ìˆ˜ë¡œ êµ¬í˜„

í˜ì–´ë§ ì§ˆë¬¸ ê²°ì •:
    - Q1: Option A (ê³ ì • ë¹„ìš© 10 Signal) - MVP ë‹¨ìˆœí™”

ì°¸ì¡°:
    - vibe/unit-plans/U-052[Mvp].md
    - vibe/prd.md 6.7 - Economy HUD/ë¹„ìš© ì •ì±…
    - .cursor/rules/00-core-critical.mdc - RULE-005/007/008
"""

from __future__ import annotations

import hashlib
import logging
from dataclasses import dataclass
from typing import TYPE_CHECKING

from pydantic import BaseModel, ConfigDict, Field

from unknown_world.config.economy import (
    FAST_IMAGE_COST_SIGNAL,
    IMAGE_GENERATION_COST_SIGNAL,
)

if TYPE_CHECKING:
    from unknown_world.models.turn import (
        EconomySnapshot,
        ImageJob,
        TurnOutput,
    )

# =============================================================================
# ë¡œê±° ì„¤ì • (í”„ë¡¬í”„íŠ¸/ë¹„ë°€ì •ë³´ ë…¸ì¶œ ê¸ˆì§€ - RULE-007)
# =============================================================================

logger = logging.getLogger(__name__)


# =============================================================================
# ì •ì±… ë° ìƒìˆ˜ ì •ì˜
# =============================================================================


class ImagePolicy(BaseModel):
    """ì´ë¯¸ì§€ ìƒì„± ì •ì±… (U-068).

    Attributes:
        use_reference: ì°¸ì¡° ì´ë¯¸ì§€(ì´ì „ í„´ ì´ë¯¸ì§€) ì‚¬ìš© ì—¬ë¶€
        max_reference_images: ìµœëŒ€ ì°¸ì¡° ì´ë¯¸ì§€ ìˆ˜ (ê¸°ë³¸ 1)
    """

    model_config = ConfigDict(extra="forbid")

    use_reference: bool = Field(default=True, description="ì°¸ì¡° ì´ë¯¸ì§€ ì‚¬ìš© ì—¬ë¶€")
    max_reference_images: int = Field(default=1, description="ìµœëŒ€ ì°¸ì¡° ì´ë¯¸ì§€ ìˆ˜")


# ê¸°ë³¸ ì •ì±… ì¸ìŠ¤í„´ìŠ¤
DEFAULT_IMAGE_POLICY = ImagePolicy()


# =============================================================================
# í…ìŠ¤íŠ¸-only í´ë°± ë©”ì‹œì§€ (i18n)
# =============================================================================

FALLBACK_MESSAGE_KO = "ì”ì•¡ì´ ë¶€ì¡±í•˜ì—¬ ì´ë¯¸ì§€ë¥¼ ìƒì„±í•  ìˆ˜ ì—†ìŠµë‹ˆë‹¤. í…ìŠ¤íŠ¸ë¡œ ì§„í–‰í•©ë‹ˆë‹¤."
"""ì”ì•¡ ë¶€ì¡± ì‹œ í´ë°± ë©”ì‹œì§€ (í•œêµ­ì–´)."""

FALLBACK_MESSAGE_EN = "Insufficient balance for image generation. Proceeding with text only."
"""ì”ì•¡ ë¶€ì¡± ì‹œ í´ë°± ë©”ì‹œì§€ (ì˜ì–´)."""

# =============================================================================
# ì´ë¯¸ì§€ ìƒì„± ì‹¤íŒ¨ í´ë°± ë©”ì‹œì§€ (i18n) - U-054
# =============================================================================

IMAGE_GENERATION_FAILURE_MESSAGE_KO = "ì´ë¯¸ì§€ ìƒì„±ì— ì‹¤íŒ¨í–ˆìŠµë‹ˆë‹¤. í…ìŠ¤íŠ¸ë¡œ ì§„í–‰í•©ë‹ˆë‹¤."
"""ì´ë¯¸ì§€ ìƒì„± ì‹¤íŒ¨ ì‹œ í´ë°± ë©”ì‹œì§€ (í•œêµ­ì–´)."""

IMAGE_GENERATION_FAILURE_MESSAGE_EN = "Image generation failed. Proceeding with text only."
"""ì´ë¯¸ì§€ ìƒì„± ì‹¤íŒ¨ ì‹œ í´ë°± ë©”ì‹œì§€ (ì˜ì–´)."""

# =============================================================================
# ì•ˆì „ ì •ì±… ì°¨ë‹¨ ë©”ì‹œì§€ (i18n) - U-054
# =============================================================================

SAFETY_BLOCKED_MESSAGE_KO = "ì•ˆì „ ì •ì±…ì— ë”°ë¼ ì´ë¯¸ì§€ë¥¼ ìƒì„±í•  ìˆ˜ ì—†ìŠµë‹ˆë‹¤."
"""ì•ˆì „ ì •ì±… ì°¨ë‹¨ ì‹œ ë©”ì‹œì§€ (í•œêµ­ì–´)."""

SAFETY_BLOCKED_MESSAGE_EN = "Image generation blocked due to safety policies."
"""ì•ˆì „ ì •ì±… ì°¨ë‹¨ ì‹œ ë©”ì‹œì§€ (ì˜ì–´)."""


# =============================================================================
# íŒì • ê²°ê³¼ ë°ì´í„° í´ë˜ìŠ¤
# =============================================================================


@dataclass(frozen=True)
class ImageGenerationDecision:
    """ì´ë¯¸ì§€ ìƒì„± íŒì • ê²°ê³¼.

    ì´ë¯¸ì§€ ìƒì„± ì—¬ë¶€ì™€ ê´€ë ¨ ì •ë³´ë¥¼ ë‹´ì€ ë¶ˆë³€ ë°ì´í„° í´ë˜ìŠ¤ì…ë‹ˆë‹¤.

    Attributes:
        should_generate: ì´ë¯¸ì§€ë¥¼ ìƒì„±í•´ì•¼ í•˜ëŠ”ì§€
        reason: íŒì • ì‚¬ìœ  (ë¡œê¹…/ë””ë²„ê¹…ìš©)
        prompt_hash: í”„ë¡¬í”„íŠ¸ í•´ì‹œ (ì›ë¬¸ ë…¸ì¶œ ê¸ˆì§€, ë¡œê¹…ìš©)
        aspect_ratio: ê°€ë¡œì„¸ë¡œ ë¹„ìœ¨ (ìƒì„± ì‹œ)
        image_size: ì´ë¯¸ì§€ í¬ê¸° (ìƒì„± ì‹œ)
        estimated_cost_signal: ì˜ˆìƒ Signal ë¹„ìš©
        fallback_message: ìƒì„± ë¶ˆê°€ ì‹œ í´ë°± ë©”ì‹œì§€ (ì„ íƒ)
        model_override: ëª¨ë¸ ì˜¤ë²„ë¼ì´ë“œ (U-079: ì”ì•¡ ë¶€ì¡± ì‹œ FAST ê°•ì œ)
        is_low_balance_fallback: ì”ì•¡ ë¶€ì¡± FAST í´ë°± ì—¬ë¶€ (U-079)
    """

    should_generate: bool
    reason: str
    prompt_hash: str | None = None
    aspect_ratio: str | None = None
    image_size: str | None = None
    reference_image_url: str | None = None
    estimated_cost_signal: int = IMAGE_GENERATION_COST_SIGNAL
    fallback_message: str | None = None
    model_override: str | None = None
    is_low_balance_fallback: bool = False


# =============================================================================
# ImageJob ë¶„ì„ í—¬í¼ í•¨ìˆ˜
# =============================================================================


def extract_image_job(turn_output: TurnOutput) -> ImageJob | None:
    """TurnOutputì—ì„œ ImageJobì„ ì¶”ì¶œí•©ë‹ˆë‹¤.

    Args:
        turn_output: ê²€ì¦í•  TurnOutput

    Returns:
        ìœ íš¨í•œ ImageJob ë˜ëŠ” None
    """
    # TurnOutput.renderëŠ” default_factory=RenderOutputì´ë¯€ë¡œ í•­ìƒ ì¡´ì¬
    # render.image_jobì€ ì„ íƒì  (None ê°€ëŠ¥)
    return turn_output.render.image_job


def should_generate_image(image_job: ImageJob | None) -> bool:
    """ì´ë¯¸ì§€ ìƒì„± ì—¬ë¶€ë¥¼ íŒì •í•©ë‹ˆë‹¤.

    ë‹¤ìŒ ì¡°ê±´ì„ ëª¨ë‘ ë§Œì¡±í•´ì•¼ Trueë¥¼ ë°˜í™˜í•©ë‹ˆë‹¤:
    1. image_jobì´ Noneì´ ì•„ë‹˜
    2. image_job.should_generateê°€ True
    3. image_job.promptê°€ ë¹„ì–´ìˆì§€ ì•ŠìŒ (ë¹ˆ í”„ë¡¬í”„íŠ¸ ë°©ì–´)

    Args:
        image_job: ê²€ì‚¬í•  ImageJob (None ê°€ëŠ¥)

    Returns:
        ì´ë¯¸ì§€ë¥¼ ìƒì„±í•´ì•¼ í•˜ë©´ True
    """
    if image_job is None:
        return False

    if not image_job.should_generate:
        return False

    # ë¹ˆ í”„ë¡¬í”„íŠ¸ ë°©ì–´: ëª¨ë¸ì´ should_generate=trueì§€ë§Œ í”„ë¡¬í”„íŠ¸ê°€ ì—†ëŠ” ê²½ìš°
    return bool(image_job.prompt and image_job.prompt.strip())


def get_prompt_hash(prompt: str) -> str:
    """í”„ë¡¬í”„íŠ¸ì˜ SHA-256 í•´ì‹œë¥¼ ìƒì„±í•©ë‹ˆë‹¤.

    RULE-007: í”„ë¡¬í”„íŠ¸ ì›ë¬¸ì€ ë¡œê·¸ì— ë…¸ì¶œí•˜ì§€ ì•Šê³  í•´ì‹œë§Œ ì‚¬ìš©í•©ë‹ˆë‹¤.

    Args:
        prompt: í•´ì‹œí•  í”„ë¡¬í”„íŠ¸

    Returns:
        8ìë¦¬ í•´ì‹œ ë¬¸ìì—´
    """
    return hashlib.sha256(prompt.encode()).hexdigest()[:8]


# =============================================================================
# Economy ê¸°ë°˜ íŒì • í•¨ìˆ˜
# =============================================================================


def can_afford_image_generation(
    economy_snapshot: EconomySnapshot,
    estimated_cost_signal: int = IMAGE_GENERATION_COST_SIGNAL,
) -> bool:
    """ì´ë¯¸ì§€ ìƒì„± ë¹„ìš©ì„ ê°ë‹¹í•  ìˆ˜ ìˆëŠ”ì§€ íŒì •í•©ë‹ˆë‹¤.

    RULE-005: ì”ì•¡ ë¶€ì¡± ì‹œ ìƒì„±ì„ ê°•í–‰í•˜ì§€ ì•Šê³ , ëŒ€ì•ˆ(í…ìŠ¤íŠ¸-only)ì„ ì œì•ˆí•©ë‹ˆë‹¤.

    Args:
        economy_snapshot: í˜„ì¬ ì¬í™” ìŠ¤ëƒ…ìƒ·
        estimated_cost_signal: ì˜ˆìƒ Signal ë¹„ìš© (ê¸°ë³¸ê°’: 10)

    Returns:
        ë¹„ìš©ì„ ê°ë‹¹í•  ìˆ˜ ìˆìœ¼ë©´ True
    """
    return economy_snapshot.signal >= estimated_cost_signal


def get_fallback_message(language: str) -> str:
    """ì–¸ì–´ì— ë§ëŠ” í´ë°± ë©”ì‹œì§€ë¥¼ ë°˜í™˜í•©ë‹ˆë‹¤.

    RULE-006: ko/en ì–¸ì–´ ì •ì±… ì¤€ìˆ˜

    Args:
        language: ì–¸ì–´ ì½”ë“œ ("ko-KR" ë˜ëŠ” "en-US")

    Returns:
        í•´ë‹¹ ì–¸ì–´ì˜ í´ë°± ë©”ì‹œì§€
    """
    if language == "ko-KR":
        return FALLBACK_MESSAGE_KO
    return FALLBACK_MESSAGE_EN


# =============================================================================
# í†µí•© íŒì • í•¨ìˆ˜
# =============================================================================


def decide_image_generation(
    turn_output: TurnOutput,
    economy_snapshot: EconomySnapshot,
    language: str = "ko-KR",
    previous_image_url: str | None = None,
) -> ImageGenerationDecision:
    """ì´ë¯¸ì§€ ìƒì„± ì—¬ë¶€ë¥¼ ì¢…í•©ì ìœ¼ë¡œ íŒì •í•©ë‹ˆë‹¤.

    ë‹¤ìŒ ìˆœì„œë¡œ ê²€ì¦í•©ë‹ˆë‹¤:
    1. ImageJob ì¡´ì¬ ì—¬ë¶€
    2. should_generate í”Œë˜ê·¸
    3. í”„ë¡¬í”„íŠ¸ ìœ íš¨ì„±
    4. ì”ì•¡ ì¶©ë¶„ ì—¬ë¶€ (RULE-005)

    Args:
        turn_output: ê²€ì¦í•  TurnOutput
        economy_snapshot: í˜„ì¬ ì¬í™” ìŠ¤ëƒ…ìƒ·
        language: í´ë°± ë©”ì‹œì§€ ì–¸ì–´ (ê¸°ë³¸: ko-KR)
        previous_image_url: ì´ì „ í„´ ì´ë¯¸ì§€ URL (U-068: ì°¸ì¡° ì´ë¯¸ì§€ë¡œ ì‚¬ìš©)

    Returns:
        ImageGenerationDecision: íŒì • ê²°ê³¼
    """
    # 1. ImageJob ì¶”ì¶œ
    image_job = extract_image_job(turn_output)

    if image_job is None:
        logger.debug("[RenderHelpers] ImageJob ì—†ìŒ, ì´ë¯¸ì§€ ìƒì„± ê±´ë„ˆëœ€")
        return ImageGenerationDecision(
            should_generate=False,
            reason="no_image_job",
        )

    # 2. should_generate í”Œë˜ê·¸ í™•ì¸
    if not image_job.should_generate:
        logger.debug("[RenderHelpers] should_generate=false, ì´ë¯¸ì§€ ìƒì„± ê±´ë„ˆëœ€")
        return ImageGenerationDecision(
            should_generate=False,
            reason="should_generate_false",
        )

    # 3. í”„ë¡¬í”„íŠ¸ ìœ íš¨ì„± ê²€ì‚¬
    if not image_job.prompt or not image_job.prompt.strip():
        logger.warning("[RenderHelpers] í”„ë¡¬í”„íŠ¸ ë¹„ì–´ìˆìŒ, ì´ë¯¸ì§€ ìƒì„± ê±´ë„ˆëœ€ (ë°©ì–´)")
        return ImageGenerationDecision(
            should_generate=False,
            reason="empty_prompt",
        )

    # í”„ë¡¬í”„íŠ¸ í•´ì‹œ ìƒì„± (ì›ë¬¸ ë¡œê¹… ê¸ˆì§€ - RULE-007)
    prompt_hash = get_prompt_hash(image_job.prompt)

    # U-068: ì°¸ì¡° ì´ë¯¸ì§€ URL ê²°ì • (TurnInput ìš°ì„ , image_job í´ë°±)
    # í´ë¼ì´ì–¸íŠ¸ì—ì„œ ì œê³µí•œ ì´ì „ ì´ë¯¸ì§€ë¥¼ ìš°ì„  ì‚¬ìš©í•˜ì—¬ ì—°ì†ì„± ìœ ì§€
    effective_reference_url = previous_image_url or image_job.reference_image_url

    # 4. ì”ì•¡ í™•ì¸ + U-079: FAST í´ë°± ì •ì±…
    # RULE-005(ì”ì•¡ ìŒìˆ˜ ê¸ˆì§€) ì¤€ìˆ˜í•˜ë©´ì„œ ê²Œì„ íë¦„ ì°¨ë‹¨ ë°©ì§€
    # - ì”ì•¡ >= IMAGE_GENERATION_COST_SIGNAL: QUALITY ëª¨ë¸ (ì •ìƒ)
    # - ì”ì•¡ < IMAGE_GENERATION_COST_SIGNAL: FAST ëª¨ë¸ í´ë°± (ë¬´ë£Œ)
    if not can_afford_image_generation(economy_snapshot, IMAGE_GENERATION_COST_SIGNAL):
        # U-079: ì”ì•¡ ë¶€ì¡± â†’ FAST ëª¨ë¸ë¡œ í´ë°± (ë¹„ìš© 0, ë¬´ë£Œ ê¸°ë³¸ ì´ë¯¸ì§€)
        logger.info(
            "[RenderHelpers] ì”ì•¡ ë¶€ì¡±, FAST ëª¨ë¸ í´ë°± (U-079)",
            extra={
                "current_signal": economy_snapshot.signal,
                "required_signal": IMAGE_GENERATION_COST_SIGNAL,
                "fallback_cost": FAST_IMAGE_COST_SIGNAL,
                "prompt_hash": prompt_hash,
            },
        )
        return ImageGenerationDecision(
            should_generate=True,
            reason="low_balance_fast_fallback",
            prompt_hash=prompt_hash,
            aspect_ratio=image_job.aspect_ratio,
            image_size=image_job.image_size,
            reference_image_url=effective_reference_url,
            estimated_cost_signal=FAST_IMAGE_COST_SIGNAL,
            model_override="FAST",
            is_low_balance_fallback=True,
        )

    # ëª¨ë“  ì¡°ê±´ í†µê³¼ - QUALITY ì´ë¯¸ì§€ ìƒì„± ì§„í–‰
    logger.info(
        "[RenderHelpers] ì´ë¯¸ì§€ ìƒì„± íŒì • í†µê³¼ (QUALITY)",
        extra={
            "prompt_hash": prompt_hash,
            "aspect_ratio": image_job.aspect_ratio,
            "image_size": image_job.image_size,
            "reference_image_url": effective_reference_url,
            "has_previous_image": bool(previous_image_url),
            "estimated_cost": IMAGE_GENERATION_COST_SIGNAL,
        },
    )

    return ImageGenerationDecision(
        should_generate=True,
        reason="all_conditions_met",
        prompt_hash=prompt_hash,
        aspect_ratio=image_job.aspect_ratio,
        image_size=image_job.image_size,
        reference_image_url=effective_reference_url,
        estimated_cost_signal=IMAGE_GENERATION_COST_SIGNAL,
    )


# =============================================================================
# ì´ë¯¸ì§€ ìƒì„± ì‹¤íŒ¨/ì•ˆì „ ì°¨ë‹¨ í—¬í¼ í•¨ìˆ˜ (U-054)
# =============================================================================


def is_safety_blocked(message: str | None) -> bool:
    """ì‘ë‹µ ë©”ì‹œì§€ê°€ ì•ˆì „ ì •ì±… ì°¨ë‹¨ì„ ë‚˜íƒ€ë‚´ëŠ”ì§€ í™•ì¸í•©ë‹ˆë‹¤.

    RULE-004: ì•ˆì „ ì°¨ë‹¨ ì‹œ ì ì ˆí•œ ë©”ì‹œì§€ê°€ TurnOutput.safetyì— ê¸°ë¡ë˜ì–´ì•¼ í•©ë‹ˆë‹¤.

    Args:
        message: ì´ë¯¸ì§€ ìƒì„± ì‘ë‹µ ë©”ì‹œì§€ (None ê°€ëŠ¥)

    Returns:
        ì•ˆì „ ì •ì±… ì°¨ë‹¨ì´ë©´ True
    """
    if not message:
        return False

    message_lower = message.lower()
    safety_keywords = ["safety", "blocked", "policy", "violation", "prohibited"]
    return any(keyword in message_lower for keyword in safety_keywords)


def get_image_failure_message(language: str) -> str:
    """ì–¸ì–´ì— ë§ëŠ” ì´ë¯¸ì§€ ìƒì„± ì‹¤íŒ¨ í´ë°± ë©”ì‹œì§€ë¥¼ ë°˜í™˜í•©ë‹ˆë‹¤.

    RULE-006: ko/en ì–¸ì–´ ì •ì±… ì¤€ìˆ˜

    Args:
        language: ì–¸ì–´ ì½”ë“œ ("ko-KR" ë˜ëŠ” "en-US")

    Returns:
        í•´ë‹¹ ì–¸ì–´ì˜ ì´ë¯¸ì§€ ìƒì„± ì‹¤íŒ¨ ë©”ì‹œì§€
    """
    if language == "ko-KR":
        return IMAGE_GENERATION_FAILURE_MESSAGE_KO
    return IMAGE_GENERATION_FAILURE_MESSAGE_EN


def get_safety_blocked_message(language: str) -> str:
    """ì–¸ì–´ì— ë§ëŠ” ì•ˆì „ ì •ì±… ì°¨ë‹¨ ë©”ì‹œì§€ë¥¼ ë°˜í™˜í•©ë‹ˆë‹¤.

    RULE-006: ko/en ì–¸ì–´ ì •ì±… ì¤€ìˆ˜

    Args:
        language: ì–¸ì–´ ì½”ë“œ ("ko-KR" ë˜ëŠ” "en-US")

    Returns:
        í•´ë‹¹ ì–¸ì–´ì˜ ì•ˆì „ ì°¨ë‹¨ ë©”ì‹œì§€
    """
    if language == "ko-KR":
        return SAFETY_BLOCKED_MESSAGE_KO
    return SAFETY_BLOCKED_MESSAGE_EN


@dataclass(frozen=True)
class ImageFallbackResult:
    """ì´ë¯¸ì§€ ìƒì„± ì‹¤íŒ¨ ì‹œ í´ë°± ê²°ê³¼.

    U-054: ì´ë¯¸ì§€ ìƒì„± ì‹¤íŒ¨ ì‹œ ì•ˆì „í•œ í´ë°± ì •ë³´ë¥¼ ë‹´ì€ ë°ì´í„° í´ë˜ìŠ¤ì…ë‹ˆë‹¤.

    Attributes:
        is_safety_blocked: ì•ˆì „ ì •ì±…ì— ì˜í•´ ì°¨ë‹¨ë˜ì—ˆëŠ”ì§€
        fallback_message: ì‚¬ìš©ìì—ê²Œ í‘œì‹œí•  í´ë°± ë©”ì‹œì§€
        should_update_safety: TurnOutput.safetyë¥¼ ì—…ë°ì´íŠ¸í•´ì•¼ í•˜ëŠ”ì§€
        reason: í´ë°± ì‚¬ìœ  (ë¡œê¹…ìš©)
    """

    is_safety_blocked: bool
    fallback_message: str
    should_update_safety: bool
    reason: str


def create_image_fallback_result(
    status_message: str | None,
    language: str = "ko-KR",
) -> ImageFallbackResult:
    """ì´ë¯¸ì§€ ìƒì„± ì‹¤íŒ¨ì— ëŒ€í•œ í´ë°± ê²°ê³¼ë¥¼ ìƒì„±í•©ë‹ˆë‹¤.

    U-054: RULE-004ì— ë”°ë¼ ì´ë¯¸ì§€ ìƒì„± ì‹¤íŒ¨ ì‹œ ì•ˆì „í•œ í´ë°±ì„ ì œê³µí•©ë‹ˆë‹¤.
    ì¬ì‹œë„ ì—†ì´ ì¦‰ì‹œ í´ë°±í•©ë‹ˆë‹¤ (Q1: Option A).

    Args:
        status_message: ì´ë¯¸ì§€ ìƒì„± ì‘ë‹µ ë©”ì‹œì§€ (ì‹¤íŒ¨ ì‚¬ìœ )
        language: í´ë°± ë©”ì‹œì§€ ì–¸ì–´ (ê¸°ë³¸: ko-KR)

    Returns:
        ImageFallbackResult: í´ë°± ì²˜ë¦¬ì— í•„ìš”í•œ ì •ë³´
    """
    is_blocked = is_safety_blocked(status_message)

    if is_blocked:
        return ImageFallbackResult(
            is_safety_blocked=True,
            fallback_message=get_safety_blocked_message(language),
            should_update_safety=True,
            reason="safety_blocked",
        )

    return ImageFallbackResult(
        is_safety_blocked=False,
        fallback_message=get_image_failure_message(language),
        should_update_safety=False,
        reason="generation_failed",
    )
</file>

<file path="backend/src/unknown_world/services/genai_client.py">
"""Unknown World - GenAI í´ë¼ì´ì–¸íŠ¸ ë˜í¼.

ì´ ëª¨ë“ˆì€ API í‚¤ ì¸ì¦ ê¸°ë°˜ì˜ google-genai í´ë¼ì´ì–¸íŠ¸ë¥¼ ì œê³µí•©ë‹ˆë‹¤.
í™˜ê²½ë³€ìˆ˜ë¡œ ì‹¤ì œ ëª¨ë¸ê³¼ mock ëª¨ë“œë¥¼ ì „í™˜í•  ìˆ˜ ìˆìŠµë‹ˆë‹¤.

ì¸ì¦ ë°©ì‹ (U-080 í•«í”½ìŠ¤: Vertex AI ì œê±°):
    - GOOGLE_API_KEY í™˜ê²½ë³€ìˆ˜ë¡œ API í‚¤ ì¸ì¦ (í•„ìˆ˜)
    - https://aistudio.google.com/apikey ì—ì„œ ë°œê¸‰

ëª¨ë“œ ì „í™˜ (í˜ì–´ë§ ì§ˆë¬¸ Q1 ê²°ì •: Option A):
    - í™˜ê²½ë³€ìˆ˜ UW_MODE=mock â†’ MockGenAIClient (í…ŒìŠ¤íŠ¸/ê°œë°œìš©)
    - í™˜ê²½ë³€ìˆ˜ UW_MODE=real â†’ ì‹¤ì œ Gemini API í˜¸ì¶œ (ê¸°ë³¸ê°’)

ë³´ì•ˆ ê·œì¹™:
    - API í‚¤ëŠ” í™˜ê²½ë³€ìˆ˜ë¡œë§Œ ê´€ë¦¬ (RULE-007)
    - í”„ë¡¬í”„íŠ¸ ì›ë¬¸/ë¹„ë°€ì •ë³´ ë¡œê¹… ê¸ˆì§€ (RULE-007/008)
    - ë¡œê·¸ì—ëŠ” ë¼ë²¨/ë²„ì „/ì •ì±… ë©”íƒ€ë§Œ ë…¸ì¶œ

ì°¸ì¡°:
    - vibe/tech-stack.md (google-genai==1.56.0)
    - vibe/unit-plans/U-080[Mvp].md (Vertex AI ì œê±°)
    - .cursor/rules/20-backend-orchestrator.mdc
    - .cursor/rules/00-core-critical.mdc (RULE-007/010)
"""

from __future__ import annotations

import logging
import os
from collections.abc import AsyncGenerator
from dataclasses import dataclass, field
from enum import StrEnum
from typing import TYPE_CHECKING, Any

from unknown_world.config.models import ModelLabel, get_model_id

if TYPE_CHECKING:
    from google.genai import Client
    from google.genai.types import GenerateContentConfig

# =============================================================================
# ë¡œê±° ì„¤ì • (í”„ë¡¬í”„íŠ¸/ë¹„ë°€ì •ë³´ ë…¸ì¶œ ê¸ˆì§€)
# =============================================================================

logger = logging.getLogger(__name__)


class GenAIMode(StrEnum):
    """GenAI í´ë¼ì´ì–¸íŠ¸ ë™ì‘ ëª¨ë“œ.

    í™˜ê²½ë³€ìˆ˜ UW_MODEë¡œ ì œì–´í•©ë‹ˆë‹¤.
    """

    MOCK = "mock"
    """í…ŒìŠ¤íŠ¸/ê°œë°œìš© ëª¨ì˜ ëª¨ë“œ - ì‹¤ì œ API í˜¸ì¶œ ì—†ìŒ"""

    REAL = "real"
    """ì‹¤ì œ Vertex AI í˜¸ì¶œ ëª¨ë“œ (ê¸°ë³¸ê°’)"""


# =============================================================================
# í™˜ê²½ë³€ìˆ˜ í‚¤ ìƒìˆ˜
# =============================================================================

ENV_UW_MODE = "UW_MODE"
"""ë™ì‘ ëª¨ë“œ í™˜ê²½ë³€ìˆ˜ (mock|real)"""

ENV_GOOGLE_API_KEY = "GOOGLE_API_KEY"
"""Gemini API í‚¤ í™˜ê²½ë³€ìˆ˜ (í•„ìˆ˜)"""


# =============================================================================
# ìš”ì²­/ì‘ë‹µ ë°ì´í„° í´ë˜ìŠ¤
# =============================================================================


@dataclass
class GenerateRequest:
    """í…ìŠ¤íŠ¸ ìƒì„± ìš”ì²­.

    Attributes:
        prompt: ìƒì„± í”„ë¡¬í”„íŠ¸ (ì£¼ì˜: ë¡œê¹… ê¸ˆì§€)
        model_label: ëª¨ë¸ ë¼ë²¨ (FAST, QUALITY ë“±)
        max_tokens: ìµœëŒ€ í† í° ìˆ˜ (ì„ íƒ)
        temperature: ì˜¨ë„ ì„¤ì • (ì„ íƒ, 0.0~1.0)
        response_mime_type: ì‘ë‹µ MIME íƒ€ì… (ì˜ˆ: "application/json")
        response_schema: ì‘ë‹µ JSON ìŠ¤í‚¤ë§ˆ (dict ë˜ëŠ” Pydantic ëª¨ë¸ íƒ€ì…)
    """

    prompt: str
    model_label: ModelLabel = ModelLabel.FAST
    max_tokens: int | None = None
    temperature: float | None = None
    response_mime_type: str | None = None
    response_schema: Any | None = None


@dataclass
class GenerateResponse:
    """í…ìŠ¤íŠ¸ ìƒì„± ì‘ë‹µ.

    Attributes:
        text: ìƒì„±ëœ í…ìŠ¤íŠ¸
        model_label: ì‚¬ìš©ëœ ëª¨ë¸ ë¼ë²¨
        finish_reason: ì¢…ë£Œ ì´ìœ  (stop, length ë“±)
        usage: í† í° ì‚¬ìš©ëŸ‰ ì •ë³´ (ì„ íƒ)
    """

    text: str
    model_label: ModelLabel
    finish_reason: str = "stop"
    usage: dict[str, int] = field(default_factory=lambda: {})


# =============================================================================
# Mock í´ë¼ì´ì–¸íŠ¸ êµ¬í˜„
# =============================================================================


class MockGenAIClient:
    """í…ŒìŠ¤íŠ¸/ê°œë°œìš© ëª¨ì˜ GenAI í´ë¼ì´ì–¸íŠ¸.

    ì‹¤ì œ APIë¥¼ í˜¸ì¶œí•˜ì§€ ì•Šê³  ê³ ì •ëœ ì‘ë‹µì„ ë°˜í™˜í•©ë‹ˆë‹¤.
    ìê²© ì¦ëª… ë¯¸ì„¤ì • ì‹œ ìë™ìœ¼ë¡œ ì´ í´ë¼ì´ì–¸íŠ¸ê°€ ì‚¬ìš©ë©ë‹ˆë‹¤.
    """

    def __init__(self) -> None:
        """MockGenAIClientë¥¼ ì´ˆê¸°í™”í•©ë‹ˆë‹¤."""
        logger.info(
            "[GenAI] Mock ëª¨ë“œë¡œ ì´ˆê¸°í™”ë¨ (ì‹¤ì œ API í˜¸ì¶œ ì—†ìŒ)",
            extra={"mode": GenAIMode.MOCK},
        )

    @property
    def mode(self) -> GenAIMode:
        """í˜„ì¬ ë™ì‘ ëª¨ë“œ."""
        return GenAIMode.MOCK

    async def generate(self, request: GenerateRequest) -> GenerateResponse:
        """ëª¨ì˜ í…ìŠ¤íŠ¸ë¥¼ ìƒì„±í•©ë‹ˆë‹¤.

        Args:
            request: ìƒì„± ìš”ì²­

        Returns:
            ê³ ì •ëœ ëª¨ì˜ ì‘ë‹µ
        """
        # ë¡œê·¸ì—ëŠ” ë©”íƒ€ ì •ë³´ë§Œ ê¸°ë¡ (í”„ë¡¬í”„íŠ¸ ì›ë¬¸ ê¸ˆì§€ - RULE-007/008)
        logger.debug(
            "[GenAI] Mock ìƒì„± ìš”ì²­",
            extra={
                "model_label": request.model_label,
                "max_tokens": request.max_tokens,
            },
        )

        return GenerateResponse(
            text=f"[Mock Response] ì´ê²ƒì€ {request.model_label} ëª¨ë¸ì˜ ëª¨ì˜ ì‘ë‹µì…ë‹ˆë‹¤.",
            model_label=request.model_label,
            finish_reason="stop",
            usage={"prompt_tokens": 10, "completion_tokens": 20, "total_tokens": 30},
        )

    async def generate_stream(self, request: GenerateRequest) -> AsyncGenerator[str]:
        """ëª¨ì˜ í…ìŠ¤íŠ¸ë¥¼ ìŠ¤íŠ¸ë¦¬ë°ìœ¼ë¡œ ìƒì„±í•©ë‹ˆë‹¤.

        Args:
            request: ìƒì„± ìš”ì²­

        Yields:
            ê³ ì •ëœ ëª¨ì˜ í…ìŠ¤íŠ¸ ì²­í¬
        """
        logger.debug(
            "[GenAI] Mock ìŠ¤íŠ¸ë¦¬ë° ìš”ì²­",
            extra={"model_label": request.model_label},
        )

        chunks = [
            "[Mock] ",
            "ì´ê²ƒì€ ",
            f"{request.model_label} ",
            "ëª¨ë¸ì˜ ",
            "ìŠ¤íŠ¸ë¦¬ë° ",
            "ëª¨ì˜ ì‘ë‹µì…ë‹ˆë‹¤.",
        ]
        for chunk in chunks:
            yield chunk

    def is_available(self) -> bool:
        """Mock í´ë¼ì´ì–¸íŠ¸ëŠ” í•­ìƒ ì‚¬ìš© ê°€ëŠ¥í•©ë‹ˆë‹¤."""
        return True


# =============================================================================
# ì‹¤ì œ GenAI í´ë¼ì´ì–¸íŠ¸ êµ¬í˜„
# =============================================================================


class GenAIClient:
    """API í‚¤ ê¸°ë°˜ ì‹¤ì œ GenAI í´ë¼ì´ì–¸íŠ¸.

    google-genai SDKë¥¼ ì‚¬ìš©í•˜ì—¬ Gemini ëª¨ë¸ì„ í˜¸ì¶œí•©ë‹ˆë‹¤.
    GOOGLE_API_KEY í™˜ê²½ë³€ìˆ˜ë¡œ API í‚¤ ì¸ì¦ì„ ìˆ˜í–‰í•©ë‹ˆë‹¤.

    U-080 í•«í”½ìŠ¤: Vertex AI ì„œë¹„ìŠ¤ ê³„ì • ì¸ì¦ ì™„ì „ ì œê±°, API í‚¤ ì „ìš©
    """

    def __init__(
        self,
        api_key: str | None = None,
    ) -> None:
        """GenAIClientë¥¼ ì´ˆê¸°í™”í•©ë‹ˆë‹¤.

        Args:
            api_key: Gemini API í‚¤ (í™˜ê²½ë³€ìˆ˜ GOOGLE_API_KEY ì‚¬ìš© ê°€ëŠ¥)

        Raises:
            RuntimeError: API í‚¤ê°€ ì„¤ì •ë˜ì§€ ì•Šì€ ê²½ìš°
        """
        self._api_key = api_key or os.environ.get(ENV_GOOGLE_API_KEY)
        self._client: Client | None = None
        self._available = False

        self._initialize_client()

    def _initialize_client(self) -> None:
        """google-genai í´ë¼ì´ì–¸íŠ¸ë¥¼ ì´ˆê¸°í™”í•©ë‹ˆë‹¤."""
        try:
            if not self._api_key:
                logger.warning(
                    "[GenAI] GOOGLE_API_KEY í™˜ê²½ë³€ìˆ˜ê°€ ì„¤ì •ë˜ì§€ ì•ŠìŒ - Mock ëª¨ë“œë¡œ ì „í™˜ ê¶Œì¥",
                )
                self._available = False
                return

            from google.genai import Client

            # API í‚¤ ëª¨ë“œë¡œ í´ë¼ì´ì–¸íŠ¸ ì´ˆê¸°í™” (Vertex AI ì œê±°)
            # vertexai=False (ê¸°ë³¸ê°’)ë¡œ API í‚¤ ì¸ì¦ ì‚¬ìš©
            self._client = Client(api_key=self._api_key)
            self._available = True

            # ë¡œê·¸ì—ëŠ” ì´ˆê¸°í™” ì„±ê³µ ì—¬ë¶€ë§Œ ê¸°ë¡ (API í‚¤ ë…¸ì¶œ ê¸ˆì§€ - RULE-007)
            logger.info(
                "[GenAI] API í‚¤ í´ë¼ì´ì–¸íŠ¸ ì´ˆê¸°í™” ì™„ë£Œ",
                extra={
                    "mode": GenAIMode.REAL,
                    "auth": "api_key",
                },
            )
        except Exception as e:
            # ì¸ì¦ ì‹¤íŒ¨ ì‹œì—ë„ ì•±ì´ ë©ˆì¶”ì§€ ì•Šë„ë¡ ë¡œê¹…ë§Œ ìˆ˜í–‰
            # ì˜¤ë¥˜ ìƒì„¸(ìŠ¤íƒíŠ¸ë ˆì´ìŠ¤)ì— ë¹„ë°€ì •ë³´ê°€ í¬í•¨ë  ìˆ˜ ìˆìœ¼ë¯€ë¡œ exc_info=False
            logger.warning(
                "[GenAI] API í‚¤ í´ë¼ì´ì–¸íŠ¸ ì´ˆê¸°í™” ì‹¤íŒ¨ - Mock ëª¨ë“œë¡œ ì „í™˜ ê¶Œì¥",
                extra={"error_type": type(e).__name__},
            )
            self._available = False

    @property
    def mode(self) -> GenAIMode:
        """í˜„ì¬ ë™ì‘ ëª¨ë“œ."""
        return GenAIMode.REAL

    async def generate(self, request: GenerateRequest) -> GenerateResponse:
        """í…ìŠ¤íŠ¸ë¥¼ ìƒì„±í•©ë‹ˆë‹¤.

        Args:
            request: ìƒì„± ìš”ì²­

        Returns:
            ìƒì„±ëœ í…ìŠ¤íŠ¸ ì‘ë‹µ

        Raises:
            RuntimeError: í´ë¼ì´ì–¸íŠ¸ê°€ ì‚¬ìš© ë¶ˆê°€ëŠ¥í•œ ê²½ìš°
        """
        if not self._available or self._client is None:
            raise RuntimeError("GenAI í´ë¼ì´ì–¸íŠ¸ê°€ ì´ˆê¸°í™”ë˜ì§€ ì•Šì•˜ìŠµë‹ˆë‹¤.")

        model_id = get_model_id(request.model_label)

        # ë¡œê·¸ì—ëŠ” ë©”íƒ€ ì •ë³´ë§Œ ê¸°ë¡ (í”„ë¡¬í”„íŠ¸ ì›ë¬¸ ê¸ˆì§€ - RULE-007/008)
        logger.debug(
            "[GenAI] ìƒì„± ìš”ì²­",
            extra={
                "model_label": request.model_label,
                "model_id": model_id,
                "max_tokens": request.max_tokens,
            },
        )

        # google-genai SDK í˜¸ì¶œ
        from google.genai.types import GenerateContentConfig

        config_dict: dict[str, Any] = {}
        if request.max_tokens:
            config_dict["max_output_tokens"] = request.max_tokens
        if request.temperature is not None:
            config_dict["temperature"] = request.temperature
        if request.response_mime_type:
            config_dict["response_mime_type"] = request.response_mime_type
        if request.response_schema:
            config_dict["response_schema"] = request.response_schema

        config: GenerateContentConfig | None = (
            GenerateContentConfig(**config_dict) if config_dict else None
        )

        response = await self._client.aio.models.generate_content(  # type: ignore[reportUnknownMemberType]
            model=model_id,
            contents=request.prompt,
            config=config,
        )

        # ì‘ë‹µ íŒŒì‹±
        text = response.text if hasattr(response, "text") and response.text else str(response)
        finish_reason = "stop"
        if hasattr(response, "candidates") and response.candidates:
            candidate = response.candidates[0]
            if hasattr(candidate, "finish_reason"):
                finish_reason = str(candidate.finish_reason)

        # í† í° ì‚¬ìš©ëŸ‰ ì¶”ì¶œ
        usage: dict[str, int] = {}
        if hasattr(response, "usage_metadata") and response.usage_metadata:
            meta = response.usage_metadata
            if hasattr(meta, "prompt_token_count") and meta.prompt_token_count is not None:
                usage["prompt_tokens"] = meta.prompt_token_count
            if hasattr(meta, "candidates_token_count") and meta.candidates_token_count is not None:
                usage["completion_tokens"] = meta.candidates_token_count
            if hasattr(meta, "total_token_count") and meta.total_token_count is not None:
                usage["total_tokens"] = meta.total_token_count

        return GenerateResponse(
            text=text,
            model_label=request.model_label,
            finish_reason=finish_reason,
            usage=usage,
        )

    async def generate_stream(self, request: GenerateRequest) -> AsyncGenerator[str]:
        """í…ìŠ¤íŠ¸ë¥¼ ìŠ¤íŠ¸ë¦¬ë°ìœ¼ë¡œ ìƒì„±í•©ë‹ˆë‹¤.

        Args:
            request: ìƒì„± ìš”ì²­

        Yields:
            ìƒì„±ëœ í…ìŠ¤íŠ¸ ì²­í¬

        Raises:
            RuntimeError: í´ë¼ì´ì–¸íŠ¸ê°€ ì‚¬ìš© ë¶ˆê°€ëŠ¥í•œ ê²½ìš°
        """
        if not self._available or self._client is None:
            raise RuntimeError("GenAI í´ë¼ì´ì–¸íŠ¸ê°€ ì´ˆê¸°í™”ë˜ì§€ ì•Šì•˜ìŠµë‹ˆë‹¤.")

        model_id = get_model_id(request.model_label)

        logger.debug(
            "[GenAI] ìŠ¤íŠ¸ë¦¬ë° ìš”ì²­",
            extra={
                "model_label": request.model_label,
                "model_id": model_id,
            },
        )

        from google.genai.types import GenerateContentConfig

        config_dict: dict[str, Any] = {}
        if request.max_tokens:
            config_dict["max_output_tokens"] = request.max_tokens
        if request.temperature is not None:
            config_dict["temperature"] = request.temperature
        if request.response_mime_type:
            config_dict["response_mime_type"] = request.response_mime_type
        if request.response_schema:
            config_dict["response_schema"] = request.response_schema

        config: GenerateContentConfig | None = (
            GenerateContentConfig(**config_dict) if config_dict else None
        )

        stream = await self._client.aio.models.generate_content_stream(  # type: ignore[reportUnknownMemberType]
            model=model_id,
            contents=request.prompt,
            config=config,
        )
        async for chunk in stream:
            if hasattr(chunk, "text") and chunk.text:
                yield chunk.text

    def is_available(self) -> bool:
        """í´ë¼ì´ì–¸íŠ¸ê°€ ì‚¬ìš© ê°€ëŠ¥í•œ ìƒíƒœì¸ì§€ í™•ì¸í•©ë‹ˆë‹¤."""
        return self._available


# =============================================================================
# íŒ©í† ë¦¬ í•¨ìˆ˜
# =============================================================================

# í´ë¼ì´ì–¸íŠ¸ íƒ€ì… (Protocol ëŒ€ì‹  Union ì‚¬ìš© - pyright í˜¸í™˜ì„±)
GenAIClientType = MockGenAIClient | GenAIClient

# ì‹±ê¸€í†¤ í´ë¼ì´ì–¸íŠ¸ ì¸ìŠ¤í„´ìŠ¤ ìºì‹œ
_client_instance: GenAIClientType | None = None


def get_genai_client(
    *,
    force_mock: bool = False,
    force_new: bool = False,
) -> GenAIClientType:
    """GenAI í´ë¼ì´ì–¸íŠ¸ ì¸ìŠ¤í„´ìŠ¤ë¥¼ ë°˜í™˜í•©ë‹ˆë‹¤.

    í™˜ê²½ë³€ìˆ˜ UW_MODEì— ë”°ë¼ ì‹¤ì œ í´ë¼ì´ì–¸íŠ¸ ë˜ëŠ” Mock í´ë¼ì´ì–¸íŠ¸ë¥¼ ë°˜í™˜í•©ë‹ˆë‹¤.
    ê¸°ë³¸ì ìœ¼ë¡œ ì‹±ê¸€í†¤ íŒ¨í„´ìœ¼ë¡œ ë™ì‘í•©ë‹ˆë‹¤.

    Args:
        force_mock: Trueë©´ í™˜ê²½ë³€ìˆ˜ì™€ ë¬´ê´€í•˜ê²Œ Mock í´ë¼ì´ì–¸íŠ¸ ë°˜í™˜
        force_new: Trueë©´ ìºì‹œë¥¼ ë¬´ì‹œí•˜ê³  ìƒˆ ì¸ìŠ¤í„´ìŠ¤ ìƒì„±

    Returns:
        GenAI í´ë¼ì´ì–¸íŠ¸ ì¸ìŠ¤í„´ìŠ¤

    Example:
        >>> client = get_genai_client()
        >>> response = await client.generate(GenerateRequest(prompt="Hello"))
    """
    global _client_instance

    if not force_new and _client_instance is not None:
        return _client_instance

    # ëª¨ë“œ ê²°ì •: force_mock > í™˜ê²½ë³€ìˆ˜ > ê¸°ë³¸ê°’(real)
    if force_mock:
        mode = GenAIMode.MOCK
    else:
        mode_str = os.environ.get(ENV_UW_MODE, GenAIMode.REAL)
        mode = GenAIMode(mode_str) if mode_str in GenAIMode.__members__.values() else GenAIMode.REAL

    # í´ë¼ì´ì–¸íŠ¸ ìƒì„±
    client_result: GenAIClientType
    if mode == GenAIMode.MOCK:
        client_result = MockGenAIClient()
    else:
        client = GenAIClient()
        # ì‹¤ì œ í´ë¼ì´ì–¸íŠ¸ ì´ˆê¸°í™” ì‹¤íŒ¨ ì‹œ Mockìœ¼ë¡œ í´ë°±
        if not client.is_available():
            logger.warning(
                "[GenAI] ì‹¤ì œ í´ë¼ì´ì–¸íŠ¸ ì´ˆê¸°í™” ì‹¤íŒ¨, Mock ëª¨ë“œë¡œ í´ë°±",
            )
            client_result = MockGenAIClient()
        else:
            client_result = client

    _client_instance = client_result
    return client_result


def reset_genai_client() -> None:
    """GenAI í´ë¼ì´ì–¸íŠ¸ ìºì‹œë¥¼ ì´ˆê¸°í™”í•©ë‹ˆë‹¤.

    í…ŒìŠ¤íŠ¸ ì‹œ í´ë¼ì´ì–¸íŠ¸ë¥¼ ì¬ì„¤ì •í•  ë•Œ ì‚¬ìš©í•©ë‹ˆë‹¤.
    """
    global _client_instance
    _client_instance = None
</file>

<file path="frontend/src/components/InventoryPanel.test.tsx">
import { describe, it, expect, vi, beforeEach } from 'vitest';
import { render, screen } from '@testing-library/react';
import { InventoryPanel } from './InventoryPanel';
import { useInventoryStore, InventoryStore } from '../stores/inventoryStore';

// Mocking useTranslation
vi.mock('react-i18next', () => ({
  useTranslation: () => ({
    t: (key: string) => key,
    i18n: { language: 'ko' },
  }),
}));

// Mocking store
vi.mock('../stores/inventoryStore', async () => {
  return {
    useInventoryStore: vi.fn(),
    requestItemIcon: vi.fn().mockResolvedValue({ isPlaceholder: false, iconUrl: '/test.png' }),
    pollIconStatus: vi.fn().mockResolvedValue('completed'),
    selectItems: (state: InventoryStore) => state.items,
    selectDraggingItem: (state: InventoryStore) =>
      state.items.find((i) => i.id === state.draggingItemId) || null,
    selectConsumingItemIds: (state: InventoryStore) => state.consumingItemIds || [],
    selectSelectedItemId: (state: InventoryStore) => state.selectedItemId || null,
  };
});

// Mocking onboarding store
vi.mock('../stores/onboardingStore', () => ({
  useOnboardingStore: vi.fn(() => false),
  selectShouldShowItemHint: vi.fn(() => false),
}));

// Mocking components that might cause issues
vi.mock('./InteractionHint', () => ({
  InteractionHint: () => <div data-testid="interaction-hint" />,
}));

describe('InventoryPanel', () => {
  beforeEach(() => {
    vi.clearAllMocks();
  });

  it('renders items with dynamic icons', () => {
    const mockItems = [
      {
        id: 'item1',
        name: 'Magic Potion',
        quantity: 1,
        icon: '/api/image/file/icon123.png',
        iconStatus: 'completed' as const,
        description: 'A blue potion',
      },
      {
        id: 'item2',
        name: 'Sword',
        quantity: 1,
        icon: 'âš”ï¸',
        iconStatus: 'completed' as const,
        description: 'A sharp sword',
      },
    ];

    vi.mocked(useInventoryStore).mockImplementation(
      (selector: (state: InventoryStore) => unknown) => {
        const state = {
          items: mockItems,
          draggingItemId: null,
          consumingItemIds: [],
          selectedItemId: null,
          selectItem: vi.fn(),
          updateItemIcon: vi.fn(),
          setItemIconStatus: vi.fn(),
        } as unknown as InventoryStore;
        return selector(state);
      },
    );

    render(<InventoryPanel />);

    // Check for image icon
    const img = screen.getByAltText('Magic Potion');
    expect(img).toBeInTheDocument();
    expect(img).toHaveAttribute('src', '/api/image/file/icon123.png');

    // Check for emoji icon
    expect(screen.getByText('âš”ï¸')).toBeInTheDocument();
  });

  it('shows loading state when icon is generating', () => {
    const mockItems = [
      {
        id: 'item1',
        name: 'Loading Item',
        quantity: 1,
        icon: undefined,
        iconStatus: 'generating' as const,
        description: 'Loading...',
      },
    ];

    vi.mocked(useInventoryStore).mockImplementation(
      (selector: (state: InventoryStore) => unknown) => {
        const state = {
          items: mockItems,
          draggingItemId: null,
          consumingItemIds: [],
          selectedItemId: null,
          selectItem: vi.fn(),
          updateItemIcon: vi.fn(),
          setItemIconStatus: vi.fn(),
        } as unknown as InventoryStore;
        return selector(state);
      },
    );

    const { container } = render(<InventoryPanel />);

    // Check for loading class
    const loadingOverlay = container.querySelector('.inventory-item-icon-loading');
    expect(loadingOverlay).toBeInTheDocument();
  });

  it('displays empty state with hint when there are no items', () => {
    vi.mocked(useInventoryStore).mockImplementation(
      (selector: (state: InventoryStore) => unknown) => {
        const state = {
          items: [],
          draggingItemId: null,
          consumingItemIds: [],
          selectedItemId: null,
          selectItem: vi.fn(),
        } as unknown as InventoryStore;
        return selector(state);
      },
    );

    render(<InventoryPanel />);

    expect(screen.getByText('inventory.empty')).toBeInTheDocument();
    expect(screen.getByText('inventory.empty_hint')).toBeInTheDocument();
  });

  it('renders items in a row layout (U-088)', () => {
    const mockItems = [
      {
        id: 'item1',
        name: 'Magic Potion',
        quantity: 5,
        icon: 'ğŸ§ª',
        iconStatus: 'completed' as const,
      },
    ];

    vi.mocked(useInventoryStore).mockImplementation(
      (selector: (state: InventoryStore) => unknown) => {
        const state = {
          items: mockItems,
          draggingItemId: null,
          consumingItemIds: [],
          selectedItemId: null,
          selectItem: vi.fn(),
        } as unknown as InventoryStore;
        return selector(state);
      },
    );

    render(<InventoryPanel />);

    // 1. ì•„ì´í…œ ì»¨í…Œì´ë„ˆ í™•ì¸
    const item = screen.getByLabelText('inventory.item_label');
    expect(item).toHaveClass('inventory-item');

    // 2. ì•„ì´ì½˜ ì˜ì—­(ë“œë˜ê·¸ í•¸ë“¤) í™•ì¸
    const iconContainer = item.querySelector('.inventory-item-icon');
    expect(iconContainer).toBeInTheDocument();
    expect(iconContainer).toHaveTextContent('ğŸ§ª');

    // 3. ì •ë³´ ì˜ì—­(ì´ë¦„, ìˆ˜ëŸ‰) í™•ì¸
    const infoContainer = item.querySelector('.inventory-item-info');
    expect(infoContainer).toBeInTheDocument();
    expect(infoContainer).toHaveTextContent('Magic Potion');
    expect(infoContainer).toHaveTextContent('x5');

    // 4. êµ¬ì¡°ì  ìˆœì„œ í™•ì¸ (ì•„ì´ì½˜ -> ì •ë³´)
    const children = Array.from(item.children);
    expect(children[0]).toHaveClass('inventory-item-icon');
    expect(children[1]).toHaveClass('inventory-item-info');
  });

  it('handles item selection (U-088)', async () => {
    const mockSelectItem = vi.fn();
    const mockItems = [
      {
        id: 'item1',
        name: 'Magic Potion',
        quantity: 1,
        icon: 'ğŸ§ª',
        iconStatus: 'completed' as const,
      },
    ];

    vi.mocked(useInventoryStore).mockImplementation(
      (selector: (state: InventoryStore) => unknown) => {
        const state = {
          items: mockItems,
          draggingItemId: null,
          consumingItemIds: [],
          selectedItemId: 'item1', // item1ì´ ì´ë¯¸ ì„ íƒëœ ìƒíƒœë¼ê³  ê°€ì •
          selectItem: mockSelectItem,
        } as unknown as InventoryStore;
        return selector(state);
      },
    );

    render(<InventoryPanel />);

    const item = screen.getByLabelText('inventory.item_label');

    // 1. ì„ íƒëœ ìƒíƒœ í´ë˜ìŠ¤ í™•ì¸
    expect(item).toHaveClass('selected');
    expect(item).toHaveAttribute('aria-selected', 'true');

    // 2. í´ë¦­ ì‹œ selectItem í˜¸ì¶œ í™•ì¸ (í† ê¸€ ê¸°ëŠ¥ì´ë¯€ë¡œ nullë¡œ í˜¸ì¶œë˜ì–´ì•¼ í•¨)
    item.click();
    expect(mockSelectItem).toHaveBeenCalledWith(null);
  });
});
</file>

<file path="frontend/src/components/SceneImage.tsx">
/**
 * Unknown World - Scene Image ì»´í¬ë„ŒíŠ¸ (U-020: Lazy Render)
 *
 * RULE-004 ì¤€ìˆ˜: ì‹¤íŒ¨ ì‹œì—ë„ ì•ˆì „í•œ í´ë°± ì œê³µ
 * RULE-008 ì¤€ìˆ˜: í…ìŠ¤íŠ¸ ìš°ì„  + Lazy ì´ë¯¸ì§€ ì •ì±…
 *
 * @module components/SceneImage
 */

import { useState, useEffect, useMemo } from 'react';
import { useTranslation } from 'react-i18next';
import type {
  SceneCanvasStatus,
  PlaceholderInfo,
  ImageLoadingState,
  SceneProcessingPhase,
} from '../types/scene';

// =============================================================================
// ìƒìˆ˜ ì •ì˜
// =============================================================================

export const SCENE_PLACEHOLDERS: Record<Exclude<SceneCanvasStatus, 'scene'>, PlaceholderInfo> = {
  default: {
    imagePath: '/ui/placeholders/scene-placeholder-default.png',
    fallbackEmoji: 'ğŸ“¡',
    labelKey: 'scene.status.default',
  },
  loading: {
    imagePath: '/ui/placeholders/scene-loading.webp',
    fallbackEmoji: 'â³',
    labelKey: 'scene.status.loading',
  },
  offline: {
    imagePath: '/ui/placeholders/scene-offline.webp',
    fallbackEmoji: 'ğŸ”Œ',
    labelKey: 'scene.status.offline',
  },
  blocked: {
    imagePath: '/ui/placeholders/scene-blocked.webp',
    fallbackEmoji: 'ğŸš«',
    labelKey: 'scene.status.blocked',
  },
  low_signal: {
    imagePath: '/ui/placeholders/scene-low-signal.webp',
    fallbackEmoji: 'ğŸ“‰',
    labelKey: 'scene.status.low_signal',
  },
};

// =============================================================================
// íƒ€ì… ì •ì˜
// =============================================================================

interface SceneImageProps {
  status: SceneCanvasStatus;
  imageUrl?: string;
  message?: string;
  className?: string;
  /** U-066: ì´ë¯¸ì§€ ìƒì„± ì¤‘ ì—¬ë¶€ (ì™¸ë¶€ ìƒíƒœ) */
  isGenerating?: boolean;
  /** U-071: í˜„ì¬ ì²˜ë¦¬ ë‹¨ê³„ (ë¡œë”© ì¸ë””ì¼€ì´í„° ê°•í™”) */
  processingPhase?: SceneProcessingPhase;
  /** U-089: ì •ë°€ë¶„ì„(Agentic Vision) ì‹¤í–‰ ì¤‘ ì—¬ë¶€ */
  isAnalyzing?: boolean;
}

// =============================================================================
// ì»´í¬ë„ŒíŠ¸ êµ¬í˜„
// =============================================================================

/**
 * ì¥ë©´ ì´ë¯¸ì§€ ë Œë”ë§ ì»´í¬ë„ŒíŠ¸
 *
 * - Lazy loading: ìƒˆ ì´ë¯¸ì§€ë¥¼ í”„ë¦¬ë¡œë“œí•˜ê³  ì™„ë£Œ ì‹œ êµì²´í•©ë‹ˆë‹¤.
 * - Option A: ìƒˆ ì´ë¯¸ì§€ ë¡œë”© ì¤‘ì—ë„ ì´ì „ ì´ë¯¸ì§€ë¥¼ ìœ ì§€í•©ë‹ˆë‹¤.
 * - í´ë°±: ë¡œë“œ ì‹¤íŒ¨ ì‹œ ì—ëŸ¬ ë°°ì§€ë¥¼ í‘œì‹œí•˜ê³  ì´ì „ ì´ë¯¸ì§€ë¥¼ ìœ ì§€í•©ë‹ˆë‹¤.
 * - U-066: isGenerating ìƒíƒœì—ì„œ "ìƒˆ ì¥ë©´ ìƒì„± ì¤‘" ì¸ë””ì¼€ì´í„°ë¥¼ í‘œì‹œí•©ë‹ˆë‹¤.
 */
export function SceneImage({
  status,
  imageUrl,
  message,
  className = '',
  isGenerating = false,
  processingPhase = 'idle',
  isAnalyzing = false,
}: SceneImageProps) {
  const { t } = useTranslation();

  // U-071: ì²˜ë¦¬ ì¤‘ ì—¬ë¶€ (processing ë˜ëŠ” image_pending)
  // U-089: ì •ë°€ë¶„ì„ ì‹œì—ëŠ” ë³„ë„ ì˜¤ë²„ë ˆì´ë¥¼ ì‚¬ìš©í•˜ë¯€ë¡œ isProcessingì—ì„œ ì œì™¸
  const isProcessing =
    !isAnalyzing && (processingPhase === 'processing' || processingPhase === 'image_pending');

  // ë‚´ë¶€ ìƒíƒœ ê´€ë¦¬
  const [imageError, setImageError] = useState(false);
  const [displayImageUrl, setDisplayImageUrl] = useState<string | null>(null);

  // íŒŒìƒ ìƒíƒœ: ë¡œë”© ì¤‘ ì—¬ë¶€
  // - ëª©í‘œ URL(imageUrl)ì´ ì¡´ì¬í•˜ê³ , í˜„ì¬ í‘œì‹œ ì¤‘ì¸ ì´ë¯¸ì§€ì™€ ë‹¤ë¥´ë©°, ì—ëŸ¬ê°€ ì•„ë‹Œ ê²½ìš°
  const isImageLoading = useMemo(() => {
    return !!imageUrl && imageUrl !== displayImageUrl && !imageError;
  }, [imageUrl, displayImageUrl, imageError]);

  // ì´ë¯¸ì§€ URL ë³€ê²½ ì‹œ ë¡œë”© í”„ë¡œì„¸ìŠ¤ ì‹œì‘
  useEffect(() => {
    // 1. URLì´ ì—†ê±°ë‚˜ ì´ë¯¸ í‘œì‹œ ì¤‘ì¸ ê²½ìš° ì´ˆê¸°í™” ë° ì¢…ë£Œ
    if (!imageUrl || imageUrl === displayImageUrl) {
      // eslint-disable-next-line react-hooks/set-state-in-effect
      setImageError(false);
      return;
    }

    // 2. ìƒˆ ì´ë¯¸ì§€ í”„ë¦¬ë¡œë“œ ì‹œì‘

    setImageError(false);

    let isMounted = true;
    const img = new Image();
    const currentUrl = imageUrl;

    const handleLoad = () => {
      if (!isMounted) return;
      setDisplayImageUrl(currentUrl);
      setImageError(false);
    };

    const handleError = () => {
      if (!isMounted) return;
      setImageError(true);
    };

    img.addEventListener('load', handleLoad);
    img.addEventListener('error', handleError);
    img.src = imageUrl;

    return () => {
      isMounted = false;
      img.removeEventListener('load', handleLoad);
      img.removeEventListener('error', handleError);
    };
  }, [imageUrl, displayImageUrl]);

  // ì´ë¯¸ì§€ ë¡œë”© ìƒíƒœ íƒ€ì… íŒŒìƒ (CSS í´ë˜ìŠ¤ìš©)
  const imageLoadingState: ImageLoadingState = useMemo(() => {
    if (isImageLoading) return 'loading';
    if (imageError) return 'error';
    if (displayImageUrl) return 'loaded';
    return 'idle';
  }, [isImageLoading, imageError, displayImageUrl]);

  const hasDisplayImage = !!displayImageUrl;
  // U-071: ì²˜ë¦¬ ì¤‘ì¼ ë•ŒëŠ” scene-active í•´ì œ (placeholder í‘œì‹œë¥¼ ìœ„í•´)
  // U-089: ì •ë°€ë¶„ì„ ì¤‘ì—ëŠ” scene-active ìœ ì§€ (ê¸°ì¡´ ì´ë¯¸ì§€ í‘œì‹œ)
  const isSceneActive =
    status === 'scene' && hasDisplayImage && !imageError && !isProcessing && !isAnalyzing;

  // placeholder ì •ë³´ ê²°ì •
  // U-071 Option C: ì²˜ë¦¬ ì¤‘ì¼ ë•Œë„ placeholder ìƒíƒœë¡œ ì „í™˜
  // U-089: ì •ë°€ë¶„ì„ ì‹œì—ëŠ” placeholder ë¯¸í‘œì‹œ (ê¸°ì¡´ ì´ë¯¸ì§€ ìœ ì§€)
  const effectiveStatus = isProcessing
    ? 'loading'
    : status === 'scene' && !hasDisplayImage
      ? 'default'
      : status;

  // U-071 Option C: ì²˜ë¦¬ ì¤‘ì¼ ë•Œ placeholder + ì˜¤ë²„ë ˆì´ í‘œì‹œ
  // U-089: ì •ë°€ë¶„ì„ ì‹œì—ëŠ” ê¸°ì¡´ ì´ë¯¸ì§€ë¥¼ ìœ ì§€í•˜ë¯€ë¡œ placeholder ë¯¸í‘œì‹œ
  const isPlaceholderVisible = (!hasDisplayImage || isProcessing) && !isAnalyzing;

  const placeholder = isPlaceholderVisible
    ? SCENE_PLACEHOLDERS[effectiveStatus as Exclude<SceneCanvasStatus, 'scene'>]
    : null;

  // U-071: ì²˜ë¦¬ ë‹¨ê³„ë³„ ë©”ì‹œì§€ í‚¤ ë§¤í•‘
  const processingMessageKey =
    processingPhase === 'image_pending'
      ? 'scene.processing.image_pending'
      : processingPhase === 'rendering'
        ? 'scene.processing.rendering'
        : 'scene.processing.processing';

  return (
    <div
      className={`scene-image-container ${isSceneActive || isAnalyzing ? 'scene-active' : `scene-status-${effectiveStatus}`} ${isImageLoading ? 'image-loading' : ''} ${isProcessing ? 'scene-processing' : ''} ${isAnalyzing ? 'scene-analyzing' : ''} ${className}`}
      style={placeholder ? { backgroundImage: `url('${placeholder.imagePath}')` } : {}}
    >
      {/* ì¥ë©´ ì´ë¯¸ì§€
        - U-071 Option C: ì²˜ë¦¬ ì¤‘ì¼ ë•Œ ìˆ¨ê¹€
        - U-089: ì •ë°€ë¶„ì„ ì¤‘ì—ëŠ” ê¸°ì¡´ ì´ë¯¸ì§€ ìœ ì§€ (opacity/tintëŠ” CSSì—ì„œ ì²˜ë¦¬)
      */}
      {hasDisplayImage && (!isProcessing || isAnalyzing) && (
        <img
          src={displayImageUrl}
          alt={t('scene.status.alt')}
          className={`scene-image ${imageLoadingState === 'loaded' ? 'scene-image-loaded' : ''}`}
        />
      )}

      {/* U-089: ì •ë°€ë¶„ì„ ì „ìš© ì˜¤ë²„ë ˆì´ (ìŠ¤ìº”ë¼ì¸ ìŠ¤ìœ• + ì‹œì•ˆ ê¸€ë¡œìš° ë¼ë²¨) */}
      {isAnalyzing && (
        <div className="scene-analyzing-overlay" aria-live="polite" role="status">
          {/* ìŠ¤ìº”ë¼ì¸ ìŠ¤ìœ• íš¨ê³¼ (ìœ„â†’ì•„ë˜ ë°˜ë³µ) */}
          <div className="scene-analyzing-scanline" aria-hidden="true" />
          {/* ì‹œì•ˆ ê¸€ë¡œìš° ë¼ë²¨ */}
          <span className="scene-analyzing-text">{t('scene.analyzing.message')}</span>
          {/* ì„œë¸Œ í…ìŠ¤íŠ¸ (ë‹¨ê³„ íŒíŠ¸) */}
          <span className="scene-analyzing-subtext">{t('scene.analyzing.hint')}</span>
        </div>
      )}

      {/* U-071: ì²˜ë¦¬ ì¤‘ ì˜¤ë²„ë ˆì´ (CRT í…Œë§ˆ) - ì •ë°€ë¶„ì„ì´ ì•„ë‹ ë•Œë§Œ */}
      {isProcessing && !isAnalyzing && (
        <div className="scene-processing-overlay" aria-live="polite" role="status">
          <div className="scene-processing-spinner" aria-hidden="true">
            <div className="spinner-ring spinner-ring-outer" />
            <div className="spinner-ring spinner-ring-inner" />
            <div className="spinner-glow" />
          </div>
          <span className="scene-processing-text">{t(processingMessageKey)}</span>
          {/* CRT ìŠ¤ìº”ë¼ì¸ íš¨ê³¼ */}
          <div className="scene-processing-scanlines" aria-hidden="true" />
        </div>
      )}

      {/* ë¡œë”© ì¸ë””ì¼€ì´í„° (ì´ë¯¸ì§€ URL ë¡œë”©) - ì²˜ë¦¬ ì¤‘/ë¶„ì„ ì¤‘ì´ ì•„ë‹ ë•Œë§Œ */}
      {isImageLoading && !isGenerating && !isProcessing && !isAnalyzing && (
        <div className="scene-loading-indicator" aria-live="polite">
          <div className="scene-loading-spinner" aria-hidden="true" />
          <span className="scene-loading-text">{t('scene.status.image_loading')}</span>
        </div>
      )}

      {/* U-066: ì´ë¯¸ì§€ ìƒì„± ì¤‘ ì¸ë””ì¼€ì´í„° - ì²˜ë¦¬ ì¤‘/ë¶„ì„ ì¤‘ì´ ì•„ë‹ ë•Œë§Œ */}
      {isGenerating && !isProcessing && !isAnalyzing && (
        <div className="scene-generating-indicator" aria-live="polite">
          <div className="scene-generating-spinner" aria-hidden="true" />
          <span className="scene-generating-text">{t('scene.status.image_generating')}</span>
        </div>
      )}

      {/* ì´ë¯¸ì§€ ì—ëŸ¬ ë°°ì§€ - ì²˜ë¦¬ ì¤‘/ë¶„ì„ ì¤‘ì´ ì•„ë‹ ë•Œë§Œ */}
      {imageError && !isProcessing && !isAnalyzing && (
        <div className="scene-error-badge" role="alert">
          <span className="scene-error-icon" aria-hidden="true">
            âš ï¸
          </span>
          <span className="scene-error-text">{t('scene.status.image_error')}</span>
        </div>
      )}

      {/* Placeholder ì˜ì—­ - ì²˜ë¦¬ ì¤‘ì¼ ë•ŒëŠ” ì˜¤ë²„ë ˆì´ë§Œ í‘œì‹œ, ë¶„ì„ ì¤‘ì¼ ë•ŒëŠ” ë¯¸í‘œì‹œ */}
      {isPlaceholderVisible && placeholder && !isProcessing && (
        <div className="scene-placeholder">
          <p className="text-glow scene-status-label">
            <span className="scene-status-emoji" aria-hidden="true">
              {placeholder.fallbackEmoji}
            </span>{' '}
            {t(placeholder.labelKey)}
          </p>
          {message && <p className="scene-status-message">{message}</p>}
        </div>
      )}
    </div>
  );
}
</file>

<file path="backend/src/unknown_world/api/image.py">
"""Unknown World - ì´ë¯¸ì§€ ìƒì„± API ì—”ë“œí¬ì¸íŠ¸.

ì´ ëª¨ë“ˆì€ ì¥ë©´ ì´ë¯¸ì§€ë¥¼ ì¡°ê±´ë¶€ë¡œ ìƒì„±í•˜ëŠ” ì—”ë“œí¬ì¸íŠ¸ë¥¼ ì œê³µí•©ë‹ˆë‹¤.
í…ìŠ¤íŠ¸ í„´ì˜ TTFBë¥¼ ë¸”ë¡œí‚¹í•˜ì§€ ì•Šë„ë¡ ë¶„ë¦¬ëœ ê²½ë¡œë¡œ ë™ì‘í•©ë‹ˆë‹¤.

ì„¤ê³„ ì›ì¹™:
    - RULE-004: ì‹¤íŒ¨ ì‹œ ì•ˆì „í•œ í´ë°± (í…ìŠ¤íŠ¸-only ì§„í–‰ ê°€ëŠ¥)
    - RULE-008: í…ìŠ¤íŠ¸ ìš°ì„  + Lazy ì´ë¯¸ì§€ ì›ì¹™
    - RULE-010: ì´ë¯¸ì§€ ëª¨ë¸ ID ê³ ì • (gemini-3-pro-image-preview)
    - RULE-007: í”„ë¡¬í”„íŠ¸ ì›ë¬¸/ë¹„ë°€ì •ë³´ ë…¸ì¶œ ê¸ˆì§€

í˜ì–´ë§ ì§ˆë¬¸ ê²°ì •:
    - Q1: Option A (ë¡œì»¬ íŒŒì¼ë¡œ ì €ì¥ í›„ image_urlë¡œ ì„œë¹™)

ì°¸ì¡°:
    - vibe/unit-plans/U-019[Mvp].md
    - .cursor/rules/20-backend-orchestrator.mdc
"""

from __future__ import annotations

import logging

from fastapi import APIRouter, Depends, HTTPException
from fastapi.responses import FileResponse
from pydantic import BaseModel, ConfigDict, Field

from unknown_world.models.turn import Language
from unknown_world.services.image_generation import (
    ImageGenerationRequest,
    ImageGenerationStatus,
    ImageGeneratorType,
    MockImageGenerator,
    create_fallback_response,
    get_image_generator,
)
from unknown_world.storage.paths import (
    DEFAULT_IMAGE_EXTENSION,
    build_image_url,
    get_generated_images_dir,
)
from unknown_world.storage.validation import (
    validate_image_generation_request,
)

# =============================================================================
# ë¡œê±° ì„¤ì •
# =============================================================================

logger = logging.getLogger(__name__)

# =============================================================================
# ë¼ìš°í„° ì •ì˜
# =============================================================================

router = APIRouter(
    prefix="/api/image",
    tags=["Image Generation"],
)


# =============================================================================
# ì˜ì¡´ì„± ì£¼ì…
# =============================================================================


async def get_generator():
    """ì´ë¯¸ì§€ ìƒì„±ê¸° ì˜ì¡´ì„±."""
    return get_image_generator()


# =============================================================================
# ìš”ì²­/ì‘ë‹µ ìŠ¤í‚¤ë§ˆ (API ê³„ì¸µìš©)
# =============================================================================


class GenerateImageRequest(BaseModel):
    """ì´ë¯¸ì§€ ìƒì„± API ìš”ì²­.

    TurnOutput.render.image_jobê³¼ ì •í•©ë˜ë„ë¡ ì„¤ê³„í•©ë‹ˆë‹¤.

    Attributes:
        prompt: ì´ë¯¸ì§€ ìƒì„± í”„ë¡¬í”„íŠ¸ (í•„ìˆ˜)
        language: ì–¸ì–´ (ì—ëŸ¬ ë©”ì‹œì§€ìš©, RULE-006)
        aspect_ratio: ê°€ë¡œì„¸ë¡œ ë¹„ìœ¨
        image_size: ì´ë¯¸ì§€ í¬ê¸°
        reference_image_ids: ì°¸ì¡° ì´ë¯¸ì§€ ID ëª©ë¡ (í¸ì§‘ìš©)
        reference_image_url: ì°¸ì¡° ì´ë¯¸ì§€ URL (U-068: ì´ì „ í„´ ì´ë¯¸ì§€ ì—°ê²°ì„±)
        session_id: ì„¸ì…˜ ID (íŒŒì¼ ê·¸ë£¹í™”ìš©)
        skip_on_failure: ì‹¤íŒ¨ ì‹œ ê±´ë„ˆë›°ê¸° (í…ìŠ¤íŠ¸-only ì§„í–‰)
        model_label: ëª¨ë¸ í‹°ì–´ë§ ë¼ë²¨ (U-066: FAST/QUALITY)
        turn_id: í„´ ID (late-binding ê°€ë“œìš©, U-066)
    """

    model_config = ConfigDict(extra="forbid")

    prompt: str = Field(min_length=1, max_length=2000, description="ì´ë¯¸ì§€ ìƒì„± í”„ë¡¬í”„íŠ¸")
    language: Language = Field(default=Language.KO, description="ìš”ì²­ ì–¸ì–´")
    aspect_ratio: str = Field(default="1:1", description="ê°€ë¡œì„¸ë¡œ ë¹„ìœ¨")
    image_size: str = Field(default="1024x1024", description="ì´ë¯¸ì§€ í¬ê¸°")
    reference_image_ids: list[str] = Field(default_factory=list, description="ì°¸ì¡° ì´ë¯¸ì§€ ID ëª©ë¡")
    reference_image_url: str | None = Field(
        default=None,
        description="ì°¸ì¡° ì´ë¯¸ì§€ URL (U-068: ì´ì „ í„´ ì´ë¯¸ì§€ë¥¼ ì°¸ì¡°í•˜ì—¬ ì—°ì†ì„± ìœ ì§€)",
    )
    session_id: str | None = Field(default=None, description="ì„¸ì…˜ ID")
    skip_on_failure: bool = Field(default=True, description="ì‹¤íŒ¨ ì‹œ ê±´ë„ˆë›°ê¸° (í…ìŠ¤íŠ¸-only ì§„í–‰)")
    model_label: str = Field(default="QUALITY", description="ëª¨ë¸ í‹°ì–´ë§ ë¼ë²¨ (FAST/QUALITY)")
    turn_id: int | None = Field(default=None, description="í„´ ID (late-binding ê°€ë“œìš©)")


class GenerateImageResponse(BaseModel):
    """ì´ë¯¸ì§€ ìƒì„± API ì‘ë‹µ.

    Attributes:
        success: ì„±ê³µ ì—¬ë¶€
        status: ìƒì„± ìƒíƒœ
        image_id: ìƒì„±ëœ ì´ë¯¸ì§€ ID
        image_url: ìƒì„±ëœ ì´ë¯¸ì§€ URL
        message: ìƒíƒœ ë©”ì‹œì§€
        generation_time_ms: ìƒì„± ì†Œìš” ì‹œê°„
        model_label: ì‚¬ìš©ëœ ëª¨ë¸ ë¼ë²¨ (U-066)
        turn_id: ìš”ì²­ í„´ ID (U-066, late-binding ê°€ë“œìš©)
    """

    model_config = ConfigDict(extra="forbid")

    success: bool = Field(description="ì„±ê³µ ì—¬ë¶€")
    status: ImageGenerationStatus = Field(description="ìƒì„± ìƒíƒœ")
    image_id: str | None = Field(default=None, description="ìƒì„±ëœ ì´ë¯¸ì§€ ID")
    image_url: str | None = Field(default=None, description="ìƒì„±ëœ ì´ë¯¸ì§€ URL")
    message: str | None = Field(default=None, description="ìƒíƒœ ë©”ì‹œì§€")
    generation_time_ms: int = Field(default=0, description="ìƒì„± ì†Œìš” ì‹œê°„ (ms)")
    model_label: str = Field(default="QUALITY", description="ì‚¬ìš©ëœ ëª¨ë¸ ë¼ë²¨")
    turn_id: int | None = Field(default=None, description="ìš”ì²­ í„´ ID")


class ImageStatusResponse(BaseModel):
    """ì´ë¯¸ì§€ ìƒíƒœ ì¡°íšŒ ì‘ë‹µ.

    Attributes:
        image_id: ì´ë¯¸ì§€ ID
        exists: ì´ë¯¸ì§€ ì¡´ì¬ ì—¬ë¶€
        image_url: ì´ë¯¸ì§€ URL (ì¡´ì¬í•˜ëŠ” ê²½ìš°)
    """

    model_config = ConfigDict(extra="forbid")

    image_id: str = Field(description="ì´ë¯¸ì§€ ID")
    exists: bool = Field(description="ì´ë¯¸ì§€ ì¡´ì¬ ì—¬ë¶€")
    image_url: str | None = Field(default=None, description="ì´ë¯¸ì§€ URL")


# =============================================================================
# ì—”ë“œí¬ì¸íŠ¸ ì •ì˜
# =============================================================================


@router.post(
    "/generate",
    response_model=GenerateImageResponse,
    summary="ì´ë¯¸ì§€ ìƒì„±",
    description="ì¥ë©´ ì´ë¯¸ì§€ë¥¼ ìƒì„±í•©ë‹ˆë‹¤. í…ìŠ¤íŠ¸ í„´ê³¼ ë³„ê°œë¡œ ë¹„ë™ê¸°ì ìœ¼ë¡œ í˜¸ì¶œë©ë‹ˆë‹¤.",
)
async def generate_image(
    request: GenerateImageRequest,
    generator: ImageGeneratorType = Depends(get_generator),
) -> GenerateImageResponse:
    """ì´ë¯¸ì§€ë¥¼ ìƒì„±í•©ë‹ˆë‹¤.

    ì´ ì—”ë“œí¬ì¸íŠ¸ëŠ” TurnOutputì˜ render.image_jobì—ì„œ should_generate=trueì¸ ê²½ìš°
    í”„ë¡ íŠ¸ì—”ë“œì—ì„œ ë³„ë„ë¡œ í˜¸ì¶œí•©ë‹ˆë‹¤.

    í…ìŠ¤íŠ¸ í„´ì˜ TTFBë¥¼ ë¸”ë¡œí‚¹í•˜ì§€ ì•ŠìŠµë‹ˆë‹¤ (RULE-008).

    Args:
        request: ì´ë¯¸ì§€ ìƒì„± ìš”ì²­
        generator: ì´ë¯¸ì§€ ìƒì„±ê¸° (ì˜ì¡´ì„± ì£¼ì…)

    Returns:
        GenerateImageResponse: ìƒì„± ê²°ê³¼
    """
    # ìš”ì²­ ê²€ì¦
    validation_error = validate_image_generation_request(
        prompt=request.prompt,
        image_size=request.image_size,
        language=request.language,
    )

    if validation_error:
        logger.warning(
            "[ImageAPI] ìš”ì²­ ê²€ì¦ ì‹¤íŒ¨",
            extra={"error": validation_error},
        )

        if request.skip_on_failure:
            # ì‹¤íŒ¨ ì‹œì—ë„ í…ìŠ¤íŠ¸-onlyë¡œ ì§„í–‰ ê°€ëŠ¥í•˜ë„ë¡ í´ë°± (RULE-004)
            fallback = create_fallback_response(validation_error)
            return GenerateImageResponse(
                success=False,
                status=fallback.status,
                message=fallback.message,
            )
        else:
            raise HTTPException(status_code=400, detail=validation_error)

    # ì´ë¯¸ì§€ ìƒì„± ì‹¤í–‰
    try:
        result = await generator.generate(
            ImageGenerationRequest(
                prompt=request.prompt,
                aspect_ratio=request.aspect_ratio,
                image_size=request.image_size,
                reference_image_ids=request.reference_image_ids,
                reference_image_url=request.reference_image_url,
                session_id=request.session_id,
                model_label=request.model_label,
            )
        )

        success = result.status == ImageGenerationStatus.COMPLETED

        return GenerateImageResponse(
            success=success,
            status=result.status,
            image_id=result.image_id,
            image_url=result.image_url,
            message=result.message,
            generation_time_ms=result.generation_time_ms,
            model_label=request.model_label,
            turn_id=request.turn_id,
        )

    except Exception as e:
        error_type = type(e).__name__
        logger.error(
            "[ImageAPI] ì´ë¯¸ì§€ ìƒì„± ì¤‘ ì˜ˆì™¸ ë°œìƒ",
            extra={"error_type": error_type},
        )

        if request.skip_on_failure:
            # ì˜ˆì™¸ ë°œìƒ ì‹œì—ë„ ì•ˆì „í•œ í´ë°± (RULE-004)
            return GenerateImageResponse(
                success=False,
                status=ImageGenerationStatus.FAILED,
                message=f"ì´ë¯¸ì§€ ìƒì„± ì¤‘ ì˜¤ë¥˜ê°€ ë°œìƒí–ˆìŠµë‹ˆë‹¤: {error_type}",
            )
        else:
            raise HTTPException(
                status_code=500,
                detail=f"ì´ë¯¸ì§€ ìƒì„± ì‹¤íŒ¨: {error_type}",
            ) from e


@router.get(
    "/status/{image_id}",
    response_model=ImageStatusResponse,
    summary="ì´ë¯¸ì§€ ìƒíƒœ ì¡°íšŒ",
    description="ìƒì„±ëœ ì´ë¯¸ì§€ì˜ ì¡´ì¬ ì—¬ë¶€ì™€ URLì„ ì¡°íšŒí•©ë‹ˆë‹¤.",
)
async def get_image_status(
    image_id: str,
) -> ImageStatusResponse:
    """ì´ë¯¸ì§€ ìƒíƒœë¥¼ ì¡°íšŒí•©ë‹ˆë‹¤.

    Args:
        image_id: ì´ë¯¸ì§€ ID

    Returns:
        ImageStatusResponse: ì´ë¯¸ì§€ ìƒíƒœ
    """
    # íŒŒì¼ ì¡´ì¬ í™•ì¸ (RU-006-Q5: ì¤‘ì•™í™”ëœ ê²½ë¡œ í•¨ìˆ˜ ì‚¬ìš©)
    output_dir = get_generated_images_dir()
    filename = f"{image_id}.{DEFAULT_IMAGE_EXTENSION}"
    file_path = output_dir / filename
    exists = file_path.exists()

    return ImageStatusResponse(
        image_id=image_id,
        exists=exists,
        image_url=build_image_url(filename, category="generated") if exists else None,
    )


@router.get(
    "/file/{image_id}",
    summary="ì´ë¯¸ì§€ íŒŒì¼ ì¡°íšŒ",
    description="ìƒì„±ëœ ì´ë¯¸ì§€ íŒŒì¼ì„ ë°˜í™˜í•©ë‹ˆë‹¤.",
    response_class=FileResponse,
)
async def get_image_file(
    image_id: str,
) -> FileResponse:
    """ì´ë¯¸ì§€ íŒŒì¼ì„ ë°˜í™˜í•©ë‹ˆë‹¤.

    MVPì—ì„œëŠ” ë¡œì»¬ íŒŒì¼ì„ ì§ì ‘ ì„œë¹™í•©ë‹ˆë‹¤.
    MMPì—ì„œ GCS URL ë¦¬ë‹¤ì´ë ‰íŠ¸ë¡œ ë³€ê²½ ì˜ˆì •.

    Args:
        image_id: ì´ë¯¸ì§€ ID

    Returns:
        FileResponse: ì´ë¯¸ì§€ íŒŒì¼
    """
    # RU-006-Q5: ì¤‘ì•™í™”ëœ ê²½ë¡œ í•¨ìˆ˜ ì‚¬ìš©
    output_dir = get_generated_images_dir()
    filename = f"{image_id}.{DEFAULT_IMAGE_EXTENSION}"
    file_path = output_dir / filename

    if not file_path.exists():
        raise HTTPException(status_code=404, detail="ì´ë¯¸ì§€ë¥¼ ì°¾ì„ ìˆ˜ ì—†ìŠµë‹ˆë‹¤.")

    return FileResponse(
        path=str(file_path),
        media_type="image/png",
        filename=filename,
    )


@router.get(
    "/health",
    summary="ì´ë¯¸ì§€ ì„œë¹„ìŠ¤ í—¬ìŠ¤ì²´í¬",
    description="ì´ë¯¸ì§€ ìƒì„± ì„œë¹„ìŠ¤ì˜ ìƒíƒœë¥¼ í™•ì¸í•©ë‹ˆë‹¤.",
)
async def image_health(
    generator: ImageGeneratorType = Depends(get_generator),
) -> dict[str, str | bool]:
    """ì´ë¯¸ì§€ ì„œë¹„ìŠ¤ í—¬ìŠ¤ì²´í¬.

    Args:
        generator: ì´ë¯¸ì§€ ìƒì„±ê¸°

    Returns:
        í—¬ìŠ¤ ìƒíƒœ ì •ë³´
    """
    is_available = generator.is_available()
    # MockImageGenerator ì¸ìŠ¤í„´ìŠ¤ì¸ì§€ ì§ì ‘ í™•ì¸ (ì‹±ê¸€í†¤ ìºì‹œ ì˜¤ì—¼ ë°©ì§€)
    mode = "mock" if isinstance(generator, MockImageGenerator) else "real"

    return {
        "status": "ok" if is_available else "degraded",
        "available": is_available,
        "mode": mode,
        "model": "gemini-3-pro-image-preview",
    }
</file>

<file path="backend/src/unknown_world/orchestrator/generate_turn_output.py">
"""Unknown World - TurnOutput ìƒì„± ëª¨ë“ˆ (Structured Outputs).

ì´ ëª¨ë“ˆì€ Gemini í…ìŠ¤íŠ¸ ëª¨ë¸ì„ Structured Outputs(JSON Schema) ëª¨ë“œë¡œ í˜¸ì¶œí•´
TurnOutputì„ ìƒì„±í•˜ê³ , Pydantic ê²€ì¦ì„ í†µê³¼í•œ ê²°ê³¼ë§Œ ë°˜í™˜í•©ë‹ˆë‹¤.

ì„¤ê³„ ì›ì¹™:
    - RULE-003: êµ¬ì¡°í™” ì¶œë ¥(JSON Schema) ìš°ì„  + ì´ì¤‘ ê²€ì¦(Pydantic+Zod)
    - RULE-004: ê²€ì¦ ì‹¤íŒ¨ ì‹œ ìë™ ë³µêµ¬(Repair loop) + ì•ˆì „í•œ í´ë°±
    - RULE-005: ì¬í™” ì¸ë°”ë¦¬ì–¸íŠ¸ (ì”ì•¡ ìŒìˆ˜ ê¸ˆì§€)
    - RULE-006: ko/en ì–¸ì–´ ì •ì±… ì¤€ìˆ˜
    - RULE-007/008: í”„ë¡¬í”„íŠ¸/ë‚´ë¶€ ì¶”ë¡  ë…¸ì¶œ ê¸ˆì§€

í˜ì–´ë§ ì§ˆë¬¸ ê²°ì •:
    - Q1: ê¸°ë³¸ í…ìŠ¤íŠ¸ ìƒì„± ëª¨ë¸ ë¼ë²¨ = FAST (Option A)

ì°¸ì¡°:
    - vibe/unit-plans/U-017[Mvp].md
    - vibe/unit-results/U-016[Mvp].md
    - vibe/unit-results/U-005[Mvp].md
    - .cursor/rules/20-backend-orchestrator.mdc
"""

from __future__ import annotations

import json
import logging
from dataclasses import dataclass, field
from enum import StrEnum
from typing import Any, cast

from pydantic import ValidationError

from unknown_world.config.models import ModelLabel, TextModelTiering
from unknown_world.models.turn import (
    CurrencyAmount,
    Language,
    TurnInput,
    TurnOutput,
)
from unknown_world.orchestrator.fallback import create_safe_fallback
from unknown_world.orchestrator.prompt_loader import (
    load_image_prompt,
    load_system_prompt,
    load_turn_instructions,
)
from unknown_world.services.genai_client import (
    GenerateRequest,
    get_genai_client,
)

# =============================================================================
# ë¡œê±° ì„¤ì • (í”„ë¡¬í”„íŠ¸/ë‚´ë¶€ ì¶”ë¡  ë…¸ì¶œ ê¸ˆì§€ - RULE-007/008)
# =============================================================================

logger = logging.getLogger(__name__)


# =============================================================================
# Gemini API ìŠ¤í‚¤ë§ˆ í˜¸í™˜ì„± (U-080 í•«í”½ìŠ¤)
# =============================================================================


def _strip_additional_properties(schema: dict[str, Any]) -> dict[str, Any]:
    """JSON Schemaì—ì„œ additionalProperties í•„ë“œë¥¼ ì¬ê·€ì ìœ¼ë¡œ ì œê±°í•©ë‹ˆë‹¤.

    Gemini APIëŠ” Pydanticì´ ìƒì„±í•˜ëŠ” `additionalProperties` í•„ë“œë¥¼ ì¸ì‹í•˜ì§€ ëª»í•˜ì—¬
    `400 INVALID_ARGUMENT: Unknown name "additional_properties"` ì—ëŸ¬ê°€ ë°œìƒí•©ë‹ˆë‹¤.
    ì´ í•¨ìˆ˜ëŠ” ìŠ¤í‚¤ë§ˆì—ì„œ í•´ë‹¹ í•„ë“œë¥¼ ì œê±°í•˜ì—¬ Gemini APIì™€ í˜¸í™˜ë˜ê²Œ í•©ë‹ˆë‹¤.

    Args:
        schema: Pydantic model_json_schema()ë¡œ ìƒì„±ëœ JSON Schema

    Returns:
        additionalPropertiesê°€ ì œê±°ëœ JSON Schema
    """
    # í˜„ì¬ ë ˆë²¨ì—ì„œ additionalProperties ì œê±°
    cleaned: dict[str, Any] = {}
    for key, value in schema.items():
        if key == "additionalProperties":
            continue

        # ê°’ íƒ€ì…ì— ë”°ë¼ ì¬ê·€ ì²˜ë¦¬
        cleaned_value: Any
        if isinstance(value, dict):
            # dictì¸ ê²½ìš° ì¬ê·€ í˜¸ì¶œ
            nested_dict = cast(dict[str, Any], value)
            cleaned_value = _strip_additional_properties(nested_dict)
        elif isinstance(value, list):
            # listì¸ ê²½ìš° ê° ìš”ì†Œ ì²˜ë¦¬
            cleaned_list: list[Any] = []
            value_list = cast(list[Any], value)
            for item in value_list:
                if isinstance(item, dict):
                    nested_item = cast(dict[str, Any], item)
                    cleaned_list.append(_strip_additional_properties(nested_item))
                else:
                    cleaned_list.append(item)
            cleaned_value = cleaned_list
        else:
            cleaned_value = value

        cleaned[key] = cleaned_value

    return cleaned


# =============================================================================
# ìƒì„± ê²°ê³¼ íƒ€ì…
# =============================================================================


class GenerationStatus(StrEnum):
    """ìƒì„± ê²°ê³¼ ìƒíƒœ."""

    SUCCESS = "success"
    """Pydantic ê²€ì¦ í†µê³¼"""

    SCHEMA_FAILURE = "schema_failure"
    """JSON íŒŒì‹± ë˜ëŠ” ìŠ¤í‚¤ë§ˆ ê²€ì¦ ì‹¤íŒ¨ (ë³µêµ¬ ëŒ€ìƒ)"""

    BUSINESS_FAILURE = "business_failure"
    """ë¹„ì¦ˆë‹ˆìŠ¤ ë£° ìœ„ë°˜ (U-018ì—ì„œ ì²˜ë¦¬)"""

    SAFETY_BLOCKED = "safety_blocked"
    """ì•ˆì „ ì •ì±…ì— ì˜í•´ ì°¨ë‹¨ë¨"""

    API_ERROR = "api_error"
    """API í˜¸ì¶œ ì‹¤íŒ¨"""


@dataclass
class GenerationResult:
    """TurnOutput ìƒì„± ê²°ê³¼.

    Attributes:
        status: ìƒì„± ìƒíƒœ
        output: ìƒì„±ëœ TurnOutput (ì„±ê³µ ì‹œ)
        error_message: ì—ëŸ¬ ë©”ì‹œì§€ (ì‹¤íŒ¨ ì‹œ, ì‚¬ìš©ì í‘œì‹œìš©)
        error_details: ìƒì„¸ ì—ëŸ¬ ì •ë³´ (ë‚´ë¶€ìš©, UI ë…¸ì¶œ ê¸ˆì§€)
        model_label: ì‚¬ìš©ëœ ëª¨ë¸ ë¼ë²¨
        cost_multiplier: ë¹„ìš© ë°°ìˆ˜ (U-069: FAST=1.0, QUALITY=2.0)
        raw_response: ì›ë³¸ ì‘ë‹µ í…ìŠ¤íŠ¸ (ë””ë²„ê·¸ìš©, UI ë…¸ì¶œ ê¸ˆì§€)
    """

    status: GenerationStatus
    output: TurnOutput | None = None
    error_message: str = ""
    error_details: dict[str, Any] = field(default_factory=lambda: {})
    model_label: ModelLabel = ModelLabel.FAST
    cost_multiplier: float = 1.0
    raw_response: str = ""


# =============================================================================
# TurnOutput ìƒì„±ê¸°
# =============================================================================


class TurnOutputGenerator:
    """Structured Outputsë¥¼ ì‚¬ìš©í•œ TurnOutput ìƒì„±ê¸°.

    Gemini ëª¨ë¸ì„ JSON Schema ëª¨ë“œë¡œ í˜¸ì¶œí•˜ê³ ,
    Pydanticìœ¼ë¡œ ì‘ë‹µì„ ê²€ì¦í•©ë‹ˆë‹¤.

    Example:
        >>> generator = TurnOutputGenerator()
        >>> result = await generator.generate(turn_input)
        >>> if result.status == GenerationStatus.SUCCESS:
        ...     print(result.output.narrative)
    """

    def __init__(
        self,
        *,
        default_model_label: ModelLabel = ModelLabel.FAST,
        force_mock: bool = False,
    ) -> None:
        """TurnOutputGeneratorë¥¼ ì´ˆê¸°í™”í•©ë‹ˆë‹¤.

        Args:
            default_model_label: ê¸°ë³¸ ëª¨ë¸ ë¼ë²¨ (Q1 ê²°ì •: FAST)
            force_mock: Mock í´ë¼ì´ì–¸íŠ¸ ê°•ì œ ì‚¬ìš© ì—¬ë¶€
        """
        self._default_model_label = default_model_label
        self._force_mock = force_mock
        self._json_schema: dict[str, Any] | None = None

    def _select_text_model(self, turn_input: TurnInput) -> tuple[ModelLabel, float]:
        """ì•¡ì…˜ ê¸°ë°˜ í…ìŠ¤íŠ¸ ëª¨ë¸ì„ ì„ íƒí•©ë‹ˆë‹¤ (U-069).

        FAST ëª¨ë¸ ê¸°ë³¸ + "ì •ë°€ì¡°ì‚¬" íŠ¸ë¦¬ê±° ì‹œ QUALITY ëª¨ë¸ ì „í™˜.

        í˜ì–´ë§ ì§ˆë¬¸ ê²°ì •:
            - Q1: Option B - ì•¡ì…˜ ID + í‚¤ì›Œë“œ ë§¤ì¹­
            - Q2: Option A - 2x (ê¸°ë³¸ ë¹„ìš©ì˜ 2ë°°)

        Args:
            turn_input: ì‚¬ìš©ì í„´ ì…ë ¥

        Returns:
            (model_label, cost_multiplier) íŠœí”Œ
        """
        action_id = turn_input.action_id
        text = turn_input.text

        # QUALITY íŠ¸ë¦¬ê±° ê²€ì‚¬
        if TextModelTiering.is_quality_trigger(action_id, text):
            model_label = ModelLabel.QUALITY
            logger.info(
                "[TurnOutputGenerator] QUALITY ëª¨ë¸ íŠ¸ë¦¬ê±° ê°ì§€ (U-069)",
                extra={
                    "action_id": action_id,
                    "has_trigger_keyword": bool(text),
                    "model_label": model_label,
                },
            )
        else:
            model_label = self._default_model_label

        cost_multiplier = TextModelTiering.get_cost_multiplier(model_label)
        return model_label, cost_multiplier

    def _get_json_schema(self) -> dict[str, Any]:
        """TurnOutput JSON Schemaë¥¼ ë°˜í™˜í•©ë‹ˆë‹¤ (ìºì‹±).

        U-080 í•«í”½ìŠ¤: Gemini API í˜¸í™˜ì„±ì„ ìœ„í•´ additionalProperties í•„ë“œë¥¼ ì œê±°í•©ë‹ˆë‹¤.
        Gemini APIëŠ” ì´ í•„ë“œë¥¼ ì¸ì‹í•˜ì§€ ëª»í•˜ì—¬ 400 ì—ëŸ¬ê°€ ë°œìƒí•©ë‹ˆë‹¤.
        """
        if self._json_schema is not None:
            return self._json_schema

        raw_schema = TurnOutput.model_json_schema()
        # Gemini API í˜¸í™˜ì„±: additionalProperties ì œê±°
        self._json_schema = _strip_additional_properties(raw_schema)
        return self._json_schema

    def _build_prompt(
        self,
        turn_input: TurnInput,
        world_context: str = "",
    ) -> str:
        """ì „ì²´ í”„ë¡¬í”„íŠ¸ë¥¼ êµ¬ì„±í•©ë‹ˆë‹¤.

        Args:
            turn_input: ì‚¬ìš©ì í„´ ì…ë ¥
            world_context: í˜„ì¬ ì„¸ê³„ ìƒíƒœ ìš”ì•½ (ì„ íƒ)

        Returns:
            ì¡°í•©ëœ í”„ë¡¬í”„íŠ¸ ë¬¸ìì—´
        """
        # ì–¸ì–´ë³„ í”„ë¡¬í”„íŠ¸ ë¡œë“œ
        system_prompt = load_system_prompt(turn_input.language)
        turn_instructions = load_turn_instructions(turn_input.language)

        # U-061: ì´ë¯¸ì§€ ìƒì„± ê°€ì´ë“œë¼ì¸ ë¡œë“œ ë° ì‹œìŠ¤í…œ í”„ë¡¬í”„íŠ¸ì— ì¶”ê°€
        # Q1 ê²°ì •: Option A (Game Master ì‹œìŠ¤í…œ í”„ë¡¬í”„íŠ¸ì— ì„¹ì…˜ ì¶”ê°€)
        # Q2 ê²°ì •: Option A (ì˜ë¬¸ ì—†ìœ¼ë©´ í•œêµ­ì–´ë¡œ í´ë°± - prompt_loaderì—ì„œ ì²˜ë¦¬)
        try:
            image_guidelines = load_image_prompt(turn_input.language)
            # ì´ë¯¸ì§€ ê°€ì´ë“œë¼ì¸ì„ ì‹œìŠ¤í…œ í”„ë¡¬í”„íŠ¸ ëì— ì„¹ì…˜ìœ¼ë¡œ ì¶”ê°€
            system_prompt = f"""{system_prompt}

---

## ì´ë¯¸ì§€ ìƒì„± ì§€ì¹¨ (Image Generation Guidelines)

ì•„ë˜ ê°€ì´ë“œë¼ì¸ì— ë”°ë¼ `image_job.prompt` í•„ë“œë¥¼ ì‘ì„±í•˜ì„¸ìš”.
LLMì´ ì´ë¯¸ì§€ ëª¨ë¸ì— ìµœì í™”ëœ ê³ í’ˆì§ˆ í”„ë¡¬í”„íŠ¸ë¥¼ ìƒì„±í•  ìˆ˜ ìˆë„ë¡ í•©ë‹ˆë‹¤.

{image_guidelines}"""
            logger.debug(
                "[TurnOutputGenerator] ì´ë¯¸ì§€ ê°€ì´ë“œë¼ì¸ ë¡œë“œ ì™„ë£Œ",
                extra={"language": turn_input.language.value},
            )
        except FileNotFoundError:
            # ê°€ì´ë“œë¼ì¸ ì—†ìœ¼ë©´ ê¸°ë³¸ í”„ë¡¬í”„íŠ¸ë§Œ ì‚¬ìš© (ì•ˆì „í•œ í´ë°±)
            logger.warning(
                "[TurnOutputGenerator] ì´ë¯¸ì§€ ê°€ì´ë“œë¼ì¸ íŒŒì¼ ë¯¸ì¡´ì¬, ê¸°ë³¸ í”„ë¡¬í”„íŠ¸ ì‚¬ìš©",
                extra={"language": turn_input.language.value},
            )

        # ì…ë ¥ ì •ë³´ êµ¬ì„± (í”„ë¡¬í”„íŠ¸ì— í¬í•¨)
        input_summary = f"""
## í˜„ì¬ í„´ ì…ë ¥

- language: {turn_input.language.value}
- text: "{turn_input.text}"
- action_id: {turn_input.action_id or "ì—†ìŒ"}
- economy_snapshot:
  - signal: {turn_input.economy_snapshot.signal}
  - memory_shard: {turn_input.economy_snapshot.memory_shard}
"""

        # ì„¸ê³„ ìƒíƒœ ì»¨í…ìŠ¤íŠ¸ (ìˆëŠ” ê²½ìš°)
        world_section = ""
        if world_context:
            world_section = f"""
## í˜„ì¬ ì„¸ê³„ ìƒíƒœ

{world_context}
"""

        # ì „ì²´ í”„ë¡¬í”„íŠ¸ ì¡°í•©
        full_prompt = f"""{system_prompt}

---

{turn_instructions}

---

{input_summary}
{world_section}

---

ìœ„ ì§€ì‹œì— ë”°ë¼ TurnOutput JSONì„ ìƒì„±í•˜ì„¸ìš”.
"""
        return full_prompt

    async def generate(
        self,
        turn_input: TurnInput,
        *,
        world_context: str = "",
    ) -> GenerationResult:
        """TurnOutputì„ ìƒì„±í•©ë‹ˆë‹¤.

        Structured Outputs(JSON Schema) ëª¨ë“œë¡œ Geminië¥¼ í˜¸ì¶œí•˜ê³ ,
        Pydanticìœ¼ë¡œ ì‘ë‹µì„ ê²€ì¦í•©ë‹ˆë‹¤.

        U-069: FAST ëª¨ë¸ ê¸°ë³¸ + "ì •ë°€ì¡°ì‚¬" íŠ¸ë¦¬ê±° ì‹œ QUALITY ëª¨ë¸ ì „í™˜.
            - Q1: Option B - ì•¡ì…˜ ID + í‚¤ì›Œë“œ ë§¤ì¹­
            - Q2: Option A - 2x (ê¸°ë³¸ ë¹„ìš©ì˜ 2ë°°)

        Args:
            turn_input: ì‚¬ìš©ì í„´ ì…ë ¥
            world_context: í˜„ì¬ ì„¸ê³„ ìƒíƒœ ìš”ì•½ (ì„ íƒ)

        Returns:
            GenerationResult: ìƒì„± ê²°ê³¼ (status, output, error ë“±)
        """
        # U-069: ëª¨ë¸ í‹°ì–´ë§ - ì•¡ì…˜/í‚¤ì›Œë“œ ê¸°ë°˜ ëª¨ë¸ ì„ íƒ
        label, cost_multiplier = self._select_text_model(turn_input)

        # ë¡œê·¸ì—ëŠ” ë©”íƒ€ë§Œ ê¸°ë¡ (í”„ë¡¬í”„íŠ¸ ì›ë¬¸ ê¸ˆì§€ - RULE-007/008)
        logger.info(
            "[TurnOutputGenerator] ìƒì„± ìš”ì²­",
            extra={
                "language": turn_input.language.value,
                "model_label": label,
                "cost_multiplier": cost_multiplier,
                "has_text": bool(turn_input.text),
                "has_action_id": bool(turn_input.action_id),
            },
        )

        try:
            # GenAI í´ë¼ì´ì–¸íŠ¸ ê°€ì ¸ì˜¤ê¸°
            client = get_genai_client(force_mock=self._force_mock)

            # í”„ë¡¬í”„íŠ¸ êµ¬ì„±
            prompt = self._build_prompt(turn_input, world_context)

            # Structured Outputs ìš”ì²­ êµ¬ì„± (RULE-003)
            # SDK ë ˆë²¨ì—ì„œ JSON Schemaë¥¼ ê°•ì œí•˜ì—¬ íŒŒì‹± ì˜¤ë¥˜ë¥¼ ìµœì†Œí™”í•©ë‹ˆë‹¤.
            json_schema = self._get_json_schema()
            request = GenerateRequest(
                prompt=prompt,
                model_label=label,
                temperature=0.7,  # ì°½ì˜ì„± ì ë‹¹íˆ
                response_mime_type="application/json",
                response_schema=json_schema,
            )

            # API í˜¸ì¶œ
            response = await client.generate(request)
            raw_text = response.text

            # Pydantic ê²€ì¦ (model_validate_json ì‚¬ìš© - U-017 ì™„ë£Œ ê¸°ì¤€)
            # Structured Outputsë¡œ ì¸í•´ ì‘ë‹µì´ ì´ë¯¸ JSONì´ë¯€ë¡œ
            # ë§ˆí¬ë‹¤ìš´ ì½”ë“œë¸”ë¡ ì²˜ë¦¬ í›„ ì§ì ‘ ê²€ì¦í•©ë‹ˆë‹¤.
            try:
                # ì‘ë‹µì—ì„œ JSON ë¶€ë¶„ ì¶”ì¶œ (ë§ˆí¬ë‹¤ìš´ ì½”ë“œë¸”ë¡ ì²˜ë¦¬)
                json_text = self._extract_json(raw_text)

                # model_validate_json: JSON ë¬¸ìì—´ì„ ì§ì ‘ íŒŒì‹±+ê²€ì¦ (U-017 ì™„ë£Œ ê¸°ì¤€)
                turn_output = TurnOutput.model_validate_json(json_text)

                # U-069: QUALITY ëª¨ë¸ ë¹„ìš© ë°°ìˆ˜ ì ìš©
                # ë¹„ì¦ˆë‹ˆìŠ¤ ë£° ê²€ì¦ ì „ì— ë¹„ìš©ê³¼ balance_afterë¥¼ ì¡°ì •í•©ë‹ˆë‹¤.
                if cost_multiplier > 1.0:
                    original_signal = turn_output.economy.cost.signal
                    original_shard = turn_output.economy.cost.memory_shard

                    # ì¶”ê°€ ë¹„ìš© ê³„ì‚°
                    additional_signal = int(original_signal * (cost_multiplier - 1))
                    additional_shard = int(original_shard * (cost_multiplier - 1))

                    # ë¹„ìš© ì¦ê°€
                    turn_output.economy.cost.signal = original_signal + additional_signal
                    turn_output.economy.cost.memory_shard = original_shard + additional_shard

                    # balance_after ê°ì†Œ (ì¶”ê°€ ë¹„ìš©ë§Œí¼)
                    turn_output.economy.balance_after.signal -= additional_signal
                    turn_output.economy.balance_after.memory_shard -= additional_shard

                    logger.info(
                        "[TurnOutputGenerator] ë¹„ìš© ë°°ìˆ˜ ì ìš© (U-069)",
                        extra={
                            "original_signal": original_signal,
                            "multiplied_signal": turn_output.economy.cost.signal,
                            "additional_signal": additional_signal,
                            "cost_multiplier": cost_multiplier,
                        },
                    )

                # ì„±ê³µ
                logger.info(
                    "[TurnOutputGenerator] ìƒì„± ì„±ê³µ",
                    extra={
                        "model_label": label,
                        "cost_multiplier": cost_multiplier,
                        "has_narrative": bool(turn_output.narrative),
                        "cost_signal": turn_output.economy.cost.signal,
                    },
                )

                return GenerationResult(
                    status=GenerationStatus.SUCCESS,
                    output=turn_output,
                    model_label=label,
                    cost_multiplier=cost_multiplier,
                    raw_response=raw_text,
                )

            except ValidationError as e:
                # ìŠ¤í‚¤ë§ˆ ê²€ì¦ ì‹¤íŒ¨ (ë³µêµ¬ ëŒ€ìƒ - U-018ì—ì„œ ì²˜ë¦¬)
                logger.warning(
                    "[TurnOutputGenerator] Pydantic ê²€ì¦ ì‹¤íŒ¨ (ë³µêµ¬ ëŒ€ìƒ)",
                    extra={
                        "error_count": len(e.errors()),
                        "model_label": label,
                    },
                )
                return GenerationResult(
                    status=GenerationStatus.SCHEMA_FAILURE,
                    error_message="ì‘ë‹µ í˜•ì‹ì´ ì˜¬ë°”ë¥´ì§€ ì•ŠìŠµë‹ˆë‹¤"
                    if turn_input.language == Language.KO
                    else "Invalid response format",
                    error_details={
                        "validation_errors": [
                            {"loc": err["loc"], "type": err["type"]} for err in e.errors()
                        ]
                    },
                    model_label=label,
                    cost_multiplier=cost_multiplier,
                    raw_response=raw_text,
                )
            except json.JSONDecodeError as e:
                # JSON íŒŒì‹± ì‹¤íŒ¨ (ë³µêµ¬ ëŒ€ìƒ)
                logger.warning(
                    "[TurnOutputGenerator] JSON íŒŒì‹± ì‹¤íŒ¨ (ë³µêµ¬ ëŒ€ìƒ)",
                    extra={"error_type": "JSONDecodeError"},
                )
                return GenerationResult(
                    status=GenerationStatus.SCHEMA_FAILURE,
                    error_message="ì‘ë‹µì„ íŒŒì‹±í•  ìˆ˜ ì—†ìŠµë‹ˆë‹¤"
                    if turn_input.language == Language.KO
                    else "Failed to parse response",
                    error_details={"json_error": str(e)},
                    model_label=label,
                    cost_multiplier=cost_multiplier,
                    raw_response=raw_text,
                )

        except RuntimeError as e:
            # API í˜¸ì¶œ ì‹¤íŒ¨
            logger.error(
                "[TurnOutputGenerator] API í˜¸ì¶œ ì‹¤íŒ¨",
                extra={"error_type": type(e).__name__},
            )
            return GenerationResult(
                status=GenerationStatus.API_ERROR,
                error_message="ì„œë¹„ìŠ¤ì— ì—°ê²°í•  ìˆ˜ ì—†ìŠµë‹ˆë‹¤"
                if turn_input.language == Language.KO
                else "Unable to connect to service",
                error_details={"api_error": str(e)},
                model_label=label,
                cost_multiplier=cost_multiplier,
            )

        except Exception as e:
            # ì˜ˆìƒì¹˜ ëª»í•œ ì˜¤ë¥˜
            logger.exception(
                "[TurnOutputGenerator] ì˜ˆìƒì¹˜ ëª»í•œ ì˜¤ë¥˜",
                extra={"error_type": type(e).__name__},
            )
            return GenerationResult(
                status=GenerationStatus.API_ERROR,
                error_message="ì²˜ë¦¬ ì¤‘ ì˜¤ë¥˜ê°€ ë°œìƒí–ˆìŠµë‹ˆë‹¤"
                if turn_input.language == Language.KO
                else "An error occurred during processing",
                error_details={"unexpected_error": type(e).__name__},
                model_label=label,
                cost_multiplier=cost_multiplier,
            )

    def _extract_json(self, text: str) -> str:
        """ì‘ë‹µ í…ìŠ¤íŠ¸ì—ì„œ JSON ë¶€ë¶„ì„ ì¶”ì¶œí•©ë‹ˆë‹¤.

        ë§ˆí¬ë‹¤ìš´ ì½”ë“œë¸”ë¡ìœ¼ë¡œ ê°ì‹¸ì§„ ê²½ìš°ë¥¼ ì²˜ë¦¬í•©ë‹ˆë‹¤.

        Args:
            text: ì›ë³¸ ì‘ë‹µ í…ìŠ¤íŠ¸

        Returns:
            JSON ë¬¸ìì—´
        """
        text = text.strip()

        # ë§ˆí¬ë‹¤ìš´ ì½”ë“œë¸”ë¡ ì²˜ë¦¬ (```json ... ```)
        if text.startswith("```"):
            lines = text.split("\n")
            # ì²« ì¤„(```json)ê³¼ ë§ˆì§€ë§‰ ì¤„(```) ì œê±°
            if lines[0].startswith("```"):
                lines = lines[1:]
            if lines and lines[-1].strip() == "```":
                lines = lines[:-1]
            text = "\n".join(lines)

        return text.strip()

    def create_safe_fallback(
        self,
        language: Language,
        error_message: str,  # noqa: ARG002 - í•˜ìœ„ í˜¸í™˜ìš© (ì‹¤ì œë¡œ ì‚¬ìš©í•˜ì§€ ì•ŠìŒ)
        economy_snapshot: CurrencyAmount | None = None,
    ) -> TurnOutput:
        """ì•ˆì „í•œ í´ë°± TurnOutputì„ ìƒì„±í•©ë‹ˆë‹¤.

        ê²€ì¦ ì‹¤íŒ¨ ë˜ëŠ” ì—ëŸ¬ ë°œìƒ ì‹œ ì‚¬ìš©í•©ë‹ˆë‹¤.
        (RULE-004: ì•ˆì „í•œ í´ë°± ì œê³µ)

        Note:
            ì´ ë©”ì„œë“œëŠ” fallback.create_safe_fallback SSOTë¡œ ìœ„ì„í•©ë‹ˆë‹¤ (RU-005-Q1).

        Args:
            language: ì–¸ì–´
            error_message: ì—ëŸ¬ ë©”ì‹œì§€ (í•˜ìœ„ í˜¸í™˜ìš©, ì‹¤ì œ ë¯¸ì‚¬ìš©)
            economy_snapshot: í˜„ì¬ ì¬í™” ìƒíƒœ (ë¹„ìš© 0ìœ¼ë¡œ ìœ ì§€)

        Returns:
            ì•ˆì „í•œ í´ë°± TurnOutput
        """
        # RU-005-Q1: fallback SSOTë¡œ ìœ„ì„
        return create_safe_fallback(
            language=language,
            economy_snapshot=economy_snapshot,
            repair_count=0,
            is_blocked=False,
        )


# =============================================================================
# í¸ì˜ í•¨ìˆ˜
# =============================================================================

# ê¸°ë³¸ ìƒì„±ê¸° ì¸ìŠ¤í„´ìŠ¤ (ì‹±ê¸€í†¤)
_default_generator: TurnOutputGenerator | None = None


def get_turn_output_generator(
    *,
    force_mock: bool = False,
    force_new: bool = False,
) -> TurnOutputGenerator:
    """TurnOutputGenerator ì¸ìŠ¤í„´ìŠ¤ë¥¼ ë°˜í™˜í•©ë‹ˆë‹¤.

    Args:
        force_mock: Mock í´ë¼ì´ì–¸íŠ¸ ê°•ì œ ì‚¬ìš© ì—¬ë¶€
        force_new: ìƒˆ ì¸ìŠ¤í„´ìŠ¤ ìƒì„± ì—¬ë¶€

    Returns:
        TurnOutputGenerator ì¸ìŠ¤í„´ìŠ¤
    """
    global _default_generator

    if force_new or _default_generator is None or force_mock:
        _default_generator = TurnOutputGenerator(
            default_model_label=ModelLabel.FAST,  # Q1 ê²°ì •: FAST ê¸°ë³¸
            force_mock=force_mock,
        )

    return _default_generator


async def generate_turn_output(
    turn_input: TurnInput,
    *,
    world_context: str = "",
    force_mock: bool = False,
) -> GenerationResult:
    """TurnOutputì„ ìƒì„±í•˜ëŠ” í¸ì˜ í•¨ìˆ˜.

    Note:
        í˜„ì¬ í•­ìƒ FAST ëª¨ë¸ì„ ì‚¬ìš©í•©ë‹ˆë‹¤.
        QUALITY ëª¨ë¸ì€ ì¶”í›„ "ì •ë°€ ì¡°ì‚¬" ê¸°ëŠ¥ êµ¬í˜„ ì‹œ ë³„ë„ ê²½ë¡œë¡œ ì¶”ê°€ ì˜ˆì •.

    Args:
        turn_input: ì‚¬ìš©ì í„´ ì…ë ¥
        world_context: í˜„ì¬ ì„¸ê³„ ìƒíƒœ ìš”ì•½ (ì„ íƒ)
        force_mock: Mock í´ë¼ì´ì–¸íŠ¸ ê°•ì œ ì‚¬ìš© ì—¬ë¶€

    Returns:
        GenerationResult: ìƒì„± ê²°ê³¼

    Example:
        >>> result = await generate_turn_output(turn_input)
        >>> if result.status == GenerationStatus.SUCCESS:
        ...     print(result.output.narrative)
    """
    generator = get_turn_output_generator(force_mock=force_mock)
    return await generator.generate(
        turn_input,
        world_context=world_context,
    )
</file>

<file path="backend/src/unknown_world/orchestrator/repair_loop.py">
"""Unknown World - Repair Loop (ì œí•œëœ ì¬ì‹œë„).

ìŠ¤í‚¤ë§ˆ/ë¹„ì¦ˆë‹ˆìŠ¤ ë£° ê²€ì¦ ì‹¤íŒ¨ ì‹œ ìë™ìœ¼ë¡œ ì¬ì‹œë„í•˜ëŠ” ë£¨í”„ì…ë‹ˆë‹¤.
max_repair_attempts ë‚´ì—ì„œ repair ì¬ìš”ì²­ì„ ìˆ˜í–‰í•˜ê³ ,
ìµœì¢… ì‹¤íŒ¨ ì‹œ ì•ˆì „í•œ í´ë°±ìœ¼ë¡œ ì¢…ë£Œí•©ë‹ˆë‹¤.

ì„¤ê³„ ì›ì¹™:
    - RULE-004: ê²€ì¦ ì‹¤íŒ¨ ì‹œ Repair loop + ì•ˆì „í•œ í´ë°±
    - RULE-007/008: í”„ë¡¬í”„íŠ¸ ì›ë¬¸/ë‚´ë¶€ ì¶”ë¡  ë…¸ì¶œ ê¸ˆì§€, ê²°ê³¼/íšŸìˆ˜ë§Œ í‘œì‹œ

í˜ì–´ë§ ê²°ì •:
    - Q1: max_repair_attempts = 2 (Option A)

ì°¸ì¡°:
    - vibe/unit-plans/U-018[Mvp].md
    - vibe/unit-results/U-017[Mvp].md
"""

from __future__ import annotations

import logging
from dataclasses import dataclass, field
from typing import TYPE_CHECKING

from unknown_world.config.models import ModelLabel
from unknown_world.models.turn import (
    CurrencyAmount,
    Language,
    TurnInput,
    TurnOutput,
    ValidationBadge,
)
from unknown_world.orchestrator.fallback import create_safe_fallback
from unknown_world.orchestrator.generate_turn_output import (
    GenerationResult,
    GenerationStatus,
    get_turn_output_generator,
)
from unknown_world.validation.business_rules import (
    BusinessRuleValidationResult,
    validate_business_rules,
)

if TYPE_CHECKING:
    pass

# =============================================================================
# ë¡œê±° ì„¤ì • (í”„ë¡¬í”„íŠ¸/ë‚´ë¶€ ì¶”ë¡  ë…¸ì¶œ ê¸ˆì§€ - RULE-007/008)
# =============================================================================

logger = logging.getLogger(__name__)


# =============================================================================
# ì„¤ì • ìƒìˆ˜
# =============================================================================

# í˜ì–´ë§ ê²°ì •: Q1 = Option A (2íšŒ)
MAX_REPAIR_ATTEMPTS = 2
"""ìµœëŒ€ ë³µêµ¬ ì‹œë„ íšŸìˆ˜."""


# =============================================================================
# i18n Repair ì»¨í…ìŠ¤íŠ¸ ë©”ì‹œì§€ (RULE-006, RU-005-S2)
# =============================================================================

REPAIR_CONTEXT_MESSAGES: dict[Language, dict[str, str]] = {
    Language.KO: {
        "schema_header": "## ì´ì „ ì‹œë„ ê²°ê³¼",
        "schema_error": "ì‘ë‹µ í˜•ì‹ì´ ì˜¬ë°”ë¥´ì§€ ì•Šì•˜ìŠµë‹ˆë‹¤.",
        "schema_instruction": "TurnOutput JSON Schemaë¥¼ ì •í™•íˆ ì¤€ìˆ˜í•˜ì—¬ ë‹¤ì‹œ ìƒì„±í•˜ì„¸ìš”.",
        "business_header": "## ì´ì „ ì‹œë„ ê²°ê³¼",
        "business_instruction": "ìœ„ ê·œì¹™ì„ ì¤€ìˆ˜í•˜ì—¬ ë‹¤ì‹œ ìƒì„±í•˜ì„¸ìš”.",
        # U-043: ì–¸ì–´ êµì • ì „ìš© í”¼ë“œë°±
        "language_header": "## ì–¸ì–´ í˜¼í•© ì˜¤ë¥˜",
        "language_instruction": (
            "ì‚¬ìš©ì ë…¸ì¶œ í…ìŠ¤íŠ¸ì— ì˜ì–´ê°€ ì„ì—¬ ìˆìŠµë‹ˆë‹¤. "
            "ëª¨ë“  í…ìŠ¤íŠ¸ë¥¼ í•œêµ­ì–´(ko-KR)ë¡œë§Œ ì‘ì„±í•˜ì„¸ìš”. "
            "ìŠ¤í‚¤ë§ˆ êµ¬ì¡°ëŠ” ìœ ì§€í•˜ê³  í…ìŠ¤íŠ¸ ê°’ë§Œ í•œêµ­ì–´ë¡œ ìˆ˜ì •í•©ë‹ˆë‹¤. "
            "ì˜ˆì™¸: Signal, Shard ë“± ì¬í™” ì´ë¦„ì€ ì˜ì–´ë¡œ ìœ ì§€ ê°€ëŠ¥í•©ë‹ˆë‹¤."
        ),
    },
    Language.EN: {
        "schema_header": "## Previous Attempt Result",
        "schema_error": "The response format was invalid.",
        "schema_instruction": "Please regenerate following the TurnOutput JSON Schema exactly.",
        "business_header": "## Previous Attempt Result",
        "business_instruction": "Please regenerate following the rules above.",
        # U-043: ì–¸ì–´ êµì • ì „ìš© í”¼ë“œë°±
        "language_header": "## Language Mixing Error",
        "language_instruction": (
            "User-facing text contains Korean characters. "
            "Rewrite all text in English (en-US) only. "
            "Keep the schema structure intact and only modify text values to English. "
            "Exception: Currency names like Signal, Shard may remain in English."
        ),
    },
}


# =============================================================================
# Repair Loop ê²°ê³¼ íƒ€ì…
# =============================================================================


@dataclass
class RepairLoopResult:
    """Repair Loop ê²°ê³¼.

    Attributes:
        output: ìµœì¢… TurnOutput (ì„±ê³µ ë˜ëŠ” í´ë°±)
        total_attempts: ì´ ì‹œë„ íšŸìˆ˜ (ì´ˆê¸° ì‹œë„ í¬í•¨)
        repair_attempts: ë³µêµ¬ ì‹œë„ íšŸìˆ˜ (ì´ˆê¸° ì‹œë„ ì œì™¸)
        is_fallback: í´ë°±ìœ¼ë¡œ ì¢…ë£Œë˜ì—ˆëŠ”ì§€
        badges: ê²€ì¦ ë°°ì§€ ëª©ë¡
        error_messages: ê° ì‹œë„ì˜ ì—ëŸ¬ ë©”ì‹œì§€ (UI ë…¸ì¶œìš©)
        model_label: ì‚¬ìš©ëœ í…ìŠ¤íŠ¸ ëª¨ë¸ ë¼ë²¨ (U-069: FAST/QUALITY)
        cost_multiplier: ë¹„ìš© ë°°ìˆ˜ (U-069: FAST=1.0, QUALITY=2.0)
    """

    output: TurnOutput
    total_attempts: int = 1
    repair_attempts: int = 0
    is_fallback: bool = False
    badges: list[ValidationBadge] = field(default_factory=lambda: [])
    error_messages: list[str] = field(default_factory=lambda: [])
    model_label: ModelLabel = ModelLabel.FAST
    cost_multiplier: float = 1.0


# =============================================================================
# Repair Loop í•¨ìˆ˜
# =============================================================================


async def run_repair_loop(
    turn_input: TurnInput,
    *,
    world_context: str = "",
    force_mock: bool = False,
    max_attempts: int = MAX_REPAIR_ATTEMPTS,
) -> RepairLoopResult:
    """Repair Loopë¥¼ ì‹¤í–‰í•©ë‹ˆë‹¤.

    ì´ˆê¸° ìƒì„±ì„ ì‹œë„í•˜ê³ , ì‹¤íŒ¨ ì‹œ max_attemptsê¹Œì§€ ì¬ì‹œë„í•©ë‹ˆë‹¤.
    ìµœì¢… ì‹¤íŒ¨ ì‹œ ì•ˆì „í•œ í´ë°±ì„ ë°˜í™˜í•©ë‹ˆë‹¤.

    U-069: ëª¨ë¸ í‹°ì–´ë§
        - ê¸°ë³¸: FAST ëª¨ë¸ (gemini-3-flash-preview)
        - íŠ¸ë¦¬ê±°: action_id ë˜ëŠ” í‚¤ì›Œë“œ ë§¤ì¹­ ì‹œ QUALITY ëª¨ë¸ (gemini-3-pro-preview)
        - ë¹„ìš© ë°°ìˆ˜: FAST=1.0, QUALITY=2.0

    Args:
        turn_input: ì‚¬ìš©ì í„´ ì…ë ¥
        world_context: í˜„ì¬ ì„¸ê³„ ìƒíƒœ ìš”ì•½ (ì„ íƒ)
        force_mock: Mock í´ë¼ì´ì–¸íŠ¸ ê°•ì œ ì‚¬ìš© ì—¬ë¶€
        max_attempts: ìµœëŒ€ ë³µêµ¬ ì‹œë„ íšŸìˆ˜

    Returns:
        RepairLoopResult: ìµœì¢… ê²°ê³¼ (ì„±ê³µ ë˜ëŠ” í´ë°±, ëª¨ë¸ ë¼ë²¨/ë¹„ìš© ë°°ìˆ˜ í¬í•¨)

    Example:
        >>> result = await run_repair_loop(turn_input)
        >>> if result.is_fallback:
        ...     print(f"í´ë°±ìœ¼ë¡œ ì¢…ë£Œ (ì‹œë„: {result.repair_attempts})")
        >>> print(f"ì‚¬ìš© ëª¨ë¸: {result.model_label}, ë¹„ìš© ë°°ìˆ˜: {result.cost_multiplier}")
        >>> print(result.output.narrative)
    """
    generator = get_turn_output_generator(force_mock=force_mock)
    economy_snapshot = CurrencyAmount(
        signal=turn_input.economy_snapshot.signal,
        memory_shard=turn_input.economy_snapshot.memory_shard,
    )

    error_messages: list[str] = []
    badges: list[ValidationBadge] = []
    repair_context = ""  # ì¬ì‹œë„ ì‹œ ì¶”ê°€í•  ì»¨í…ìŠ¤íŠ¸

    # U-069: ëª¨ë¸ í‹°ì–´ë§ - ìµœì´ˆ ì‹œë„ì—ì„œ ê²°ì •ëœ ëª¨ë¸ ì •ë³´ ì €ì¥
    selected_model_label: ModelLabel = ModelLabel.FAST
    selected_cost_multiplier: float = 1.0

    last_attempt = 0
    for attempt in range(max_attempts + 1):  # 0 = ì´ˆê¸° ì‹œë„, 1~max = ë³µêµ¬ ì‹œë„
        badges = []  # ë§¤ ì‹œë„ë§ˆë‹¤ ë°°ì§€ ì´ˆê¸°í™” (ìµœì¢… ì‹œë„ ìƒíƒœë§Œ ìœ ì§€)
        last_attempt = attempt
        is_repair = attempt > 0

        # ë¡œê·¸ ê¸°ë¡ (í”„ë¡¬í”„íŠ¸ ë…¸ì¶œ ê¸ˆì§€)
        logger.info(
            "[RepairLoop] ì‹œë„",
            extra={
                "attempt": attempt,
                "is_repair": is_repair,
                "language": turn_input.language.value,
            },
        )

        # ì»¨í…ìŠ¤íŠ¸ êµ¬ì„± (ë³µêµ¬ ì‹œ ì—ëŸ¬ ìš”ì•½ ì¶”ê°€)
        current_context = world_context
        if is_repair and repair_context:
            current_context = f"{world_context}\n\n{repair_context}"

        # ìƒì„± ì‹œë„
        gen_result = await generator.generate(
            turn_input,
            world_context=current_context,
        )

        # U-069: ëª¨ë¸ í‹°ì–´ë§ - ìƒì„± ê²°ê³¼ì—ì„œ ëª¨ë¸ ì •ë³´ ì €ì¥ (ë§¤ ì‹œë„ ë™ì¼í•˜ë‚˜ ëª…ì‹œì ìœ¼ë¡œ ê°±ì‹ )
        selected_model_label = gen_result.model_label
        selected_cost_multiplier = gen_result.cost_multiplier

        # 1. ìŠ¤í‚¤ë§ˆ ê²€ì¦ ì‹¤íŒ¨ (JSON íŒŒì‹±/Pydantic ì‹¤íŒ¨)
        if gen_result.status == GenerationStatus.SCHEMA_FAILURE:
            badges.append(ValidationBadge.SCHEMA_FAIL)
            error_messages.append(gen_result.error_message)
            # RU-005-S2: languageì— ë”°ë¼ repair ë©”ì‹œì§€ ë¶„ê¸°
            repair_context = _build_repair_context_schema(gen_result, turn_input.language)
            continue

        # 2. API ì—ëŸ¬
        if gen_result.status == GenerationStatus.API_ERROR:
            badges.append(ValidationBadge.SCHEMA_FAIL)
            error_messages.append(gen_result.error_message)
            # API ì—ëŸ¬ëŠ” ì¬ì‹œë„í•´ë„ ë™ì¼í•œ ê²°ê³¼ì¼ ê°€ëŠ¥ì„±ì´ ë†’ìŒ
            # í•˜ì§€ë§Œ ì¼ì‹œì  ì˜¤ë¥˜ì¼ ìˆ˜ ìˆìœ¼ë¯€ë¡œ ì¬ì‹œë„ í—ˆìš©
            repair_context = ""
            continue

        # 3. ìŠ¤í‚¤ë§ˆ ê²€ì¦ ì„±ê³µ â†’ ë¹„ì¦ˆë‹ˆìŠ¤ ë£° ê²€ì¦
        if gen_result.status == GenerationStatus.SUCCESS and gen_result.output:
            badges.append(ValidationBadge.SCHEMA_OK)

            # ë¹„ì¦ˆë‹ˆìŠ¤ ë£° ê²€ì¦
            biz_result = validate_business_rules(turn_input, gen_result.output)

            if biz_result.is_valid:
                # ëª¨ë“  ê²€ì¦ í†µê³¼
                badges.extend(
                    [
                        ValidationBadge.ECONOMY_OK,
                        ValidationBadge.SAFETY_OK,
                        ValidationBadge.CONSISTENCY_OK,
                    ]
                )

                # ì„œë²„ ê²€ì¦ ê²°ê³¼ë¡œ ì—…ë°ì´íŠ¸ (RULE-003/004/008)
                gen_result.output.agent_console.badges = badges
                gen_result.output.agent_console.repair_count = attempt

                logger.info(
                    "[RepairLoop] ì„±ê³µ",
                    extra={
                        "total_attempts": attempt + 1,
                        "repair_attempts": attempt,
                    },
                )

                return RepairLoopResult(
                    output=gen_result.output,
                    total_attempts=attempt + 1,
                    repair_attempts=attempt,
                    is_fallback=False,
                    badges=badges,
                    error_messages=error_messages,
                    model_label=selected_model_label,
                    cost_multiplier=selected_cost_multiplier,
                )

            # ë¹„ì¦ˆë‹ˆìŠ¤ ë£° ì‹¤íŒ¨
            add_business_badges(biz_result, badges)
            error_messages.append(biz_result.error_summary)
            # RU-005-S2: languageì— ë”°ë¼ repair ë©”ì‹œì§€ ë¶„ê¸°
            repair_context = _build_repair_context_business(biz_result, turn_input.language)
            continue

        # 4. ì•ˆì „ ì°¨ë‹¨
        if gen_result.status == GenerationStatus.SAFETY_BLOCKED:
            badges.append(ValidationBadge.SAFETY_BLOCKED)
            # ì•ˆì „ ì°¨ë‹¨ì€ ì¬ì‹œë„ ë¶ˆê°€ â†’ ì¦‰ì‹œ í´ë°±
            logger.warning(
                "[RepairLoop] ì•ˆì „ ì°¨ë‹¨ìœ¼ë¡œ í´ë°±",
                extra={"attempt": attempt},
            )
            break

    # ìµœì¢… ì‹¤íŒ¨ â†’ ì•ˆì „í•œ í´ë°± ë°˜í™˜
    logger.warning(
        "[RepairLoop] ìµœì¢… í´ë°± ë°˜í™˜",
        extra={
            "max_attempts": max_attempts,
            "actual_attempts": last_attempt,
        },
    )

    fallback = create_safe_fallback(
        language=turn_input.language,
        economy_snapshot=economy_snapshot,
        repair_count=last_attempt,
        is_blocked=ValidationBadge.SAFETY_BLOCKED in badges,
    )

    return RepairLoopResult(
        output=fallback,
        total_attempts=last_attempt + 1,
        repair_attempts=last_attempt,
        is_fallback=True,
        badges=badges,
        error_messages=error_messages,
        model_label=selected_model_label,
        cost_multiplier=selected_cost_multiplier,
    )


# =============================================================================
# í—¬í¼ í•¨ìˆ˜
# =============================================================================


def _build_repair_context_schema(gen_result: GenerationResult, language: Language) -> str:
    """ìŠ¤í‚¤ë§ˆ ì‹¤íŒ¨ì— ëŒ€í•œ Repair ì»¨í…ìŠ¤íŠ¸ë¥¼ êµ¬ì„±í•©ë‹ˆë‹¤.

    í”„ë¡¬í”„íŠ¸ ì›ë¬¸/ìƒì„¸ ì˜¤ë¥˜ëŠ” ë…¸ì¶œí•˜ì§€ ì•Šê³ , ê°„ë‹¨í•œ ì§€ì‹œë§Œ í¬í•¨í•©ë‹ˆë‹¤.
    ì–¸ì–´ì— ë”°ë¼ ë©”ì‹œì§€ë¥¼ ë¶„ê¸°í•©ë‹ˆë‹¤ (RULE-006, RU-005-S2).

    Args:
        gen_result: ìƒì„± ê²°ê³¼
        language: ì‘ë‹µ ì–¸ì–´
    """
    # ì§§ì€ ìš”ì•½ë§Œ í¬í•¨ (RULE-007/008)
    messages = REPAIR_CONTEXT_MESSAGES[language]
    return f"""
{messages["schema_header"]}

{messages["schema_error"]}
{messages["schema_instruction"]}
"""


def _build_repair_context_business(
    biz_result: BusinessRuleValidationResult, language: Language
) -> str:
    """ë¹„ì¦ˆë‹ˆìŠ¤ ë£° ì‹¤íŒ¨ì— ëŒ€í•œ Repair ì»¨í…ìŠ¤íŠ¸ë¥¼ êµ¬ì„±í•©ë‹ˆë‹¤.

    ì–¸ì–´ì— ë”°ë¼ ë©”ì‹œì§€ë¥¼ ë¶„ê¸°í•©ë‹ˆë‹¤ (RULE-006, RU-005-S2).
    ì–¸ì–´ í˜¼í•© ì—ëŸ¬ê°€ ìˆìœ¼ë©´ íŠ¹ë³„í•œ ì§€ì‹œë¥¼ ì¶”ê°€í•©ë‹ˆë‹¤ (U-043).

    Args:
        biz_result: ë¹„ì¦ˆë‹ˆìŠ¤ ë£° ê²€ì¦ ê²°ê³¼
        language: ì‘ë‹µ ì–¸ì–´
    """
    messages = REPAIR_CONTEXT_MESSAGES[language]

    # U-043: ì–¸ì–´ í˜¼í•© ì—ëŸ¬ê°€ ìˆëŠ”ì§€ í™•ì¸
    has_language_content_error = any(
        "language_content_mixed" in err["type"] for err in biz_result.errors
    )

    # ì–¸ì–´ í˜¼í•© ì—ëŸ¬ê°€ ìˆìœ¼ë©´ íŠ¹ë³„í•œ ì§€ì‹œ ì¶”ê°€
    if has_language_content_error:
        return f"""
{messages["language_header"]}

{biz_result.error_summary}

{messages["language_instruction"]}
"""

    # ì¼ë°˜ ë¹„ì¦ˆë‹ˆìŠ¤ ë£° ì—ëŸ¬
    return f"""
{messages["business_header"]}

{biz_result.error_summary}

{messages["business_instruction"]}
"""


def add_business_badges(
    biz_result: BusinessRuleValidationResult,
    badges: list[ValidationBadge],
) -> None:
    """ë¹„ì¦ˆë‹ˆìŠ¤ ë£° ê²€ì¦ ê²°ê³¼ì— ë”°ë¼ ë°°ì§€ë¥¼ ì¶”ê°€í•©ë‹ˆë‹¤.

    ì—ëŸ¬ íƒ€ì… ì ‘ë‘ì–´ â†’ ë°°ì§€ ë§¤í•‘:
        - economy_* â†’ ECONOMY_FAIL
        - safety_* â†’ SAFETY_BLOCKED
        - language_* (mismatch/content_mixed) ë˜ëŠ” box2d_* â†’ CONSISTENCY_FAIL

    RU-005-S1: consistency ì—ëŸ¬ê°€ ëˆ„ë½ë˜ì§€ ì•Šë„ë¡ ë§¤í•‘ì„ ì™„ì „í•˜ê²Œ êµ¬í˜„.
    U-043: language_content_mixedë„ CONSISTENCY_FAILë¡œ ë§¤í•‘.

    Args:
        biz_result: ë¹„ì¦ˆë‹ˆìŠ¤ ë£° ê²€ì¦ ê²°ê³¼
        badges: ë°°ì§€ ëª©ë¡ (in-place ìˆ˜ì •)
    """
    # ì—ëŸ¬ íƒ€ì…ë³„ ë°°ì§€ ë§¤í•‘ (RU-005-S1, U-043)
    has_economy_error = any("economy" in err["type"] for err in biz_result.errors)
    has_safety_error = any("safety" in err["type"] for err in biz_result.errors)
    # U-043: language_mismatch, language_content_mixed, box2d_* ëª¨ë‘ consistencyë¡œ ë§¤í•‘
    has_consistency_error = any(
        "language" in err["type"] or "box2d" in err["type"] for err in biz_result.errors
    )

    # Economy ë°°ì§€
    if has_economy_error:
        badges.append(ValidationBadge.ECONOMY_FAIL)
    else:
        badges.append(ValidationBadge.ECONOMY_OK)

    # Safety ë°°ì§€
    if has_safety_error:
        badges.append(ValidationBadge.SAFETY_BLOCKED)
    else:
        badges.append(ValidationBadge.SAFETY_OK)

    # Consistency ë°°ì§€ (RU-005-S1: ì–¸ì–´/ì¢Œí‘œ ê·œì•½ ìœ„ë°˜ í‘œì‹œ)
    if has_consistency_error:
        badges.append(ValidationBadge.CONSISTENCY_FAIL)
    else:
        badges.append(ValidationBadge.CONSISTENCY_OK)
</file>

<file path="frontend/src/api/turnStream.ts">
/**
 * Unknown World - HTTP Streaming í´ë¼ì´ì–¸íŠ¸ + NDJSON íŒŒì„œ.
 *
 * fetch ê¸°ë°˜ìœ¼ë¡œ POST ìš”ì²­ì„ ë³´ë‚´ê³  ì‘ë‹µ ìŠ¤íŠ¸ë¦¼ì„ NDJSONìœ¼ë¡œ íŒŒì‹±í•©ë‹ˆë‹¤.
 * ì¤‘ê°„ ì²­í¬ íŒŒì‹± ì‹¤íŒ¨ê°€ ì „ì²´ UIë¥¼ ë©ˆì¶”ì§€ ì•Šë„ë¡ ì„¤ê³„ë˜ì—ˆìŠµë‹ˆë‹¤.
 *
 * ì„¤ê³„ ì›ì¹™:
 *   - RULE-003: êµ¬ì¡°í™” ì¶œë ¥(JSON Schema) ìš°ì„  + ì´ì¤‘ ê²€ì¦
 *   - RULE-004: ê²€ì¦ ì‹¤íŒ¨ ì‹œ ì•ˆì „ í´ë°± ì œê³µ
 *   - RULE-008: ë‹¨ê³„/ë°°ì§€ ê°€ì‹œí™” (í”„ë¡¬í”„íŠ¸/ë‚´ë¶€ ì¶”ë¡  ë…¸ì¶œ ê¸ˆì§€)
 *   - RULE-011: ë°±ì—”ë“œ í¬íŠ¸ 8011 ì‚¬ìš©
 *
 * @module api/turnStream
 */

import type { TurnInput, TurnOutput, Language } from '../schemas/turn';
import { safeParseTurnOutput } from '../schemas/turn';
import type { StreamCallbacks } from '../types/turn_stream';
import {
  StreamEventType,
  BaseEventSchema,
  safeParseStageEvent,
  safeParseRepairEvent,
  safeParseBadgesEvent,
  safeParseNarrativeDeltaEvent,
  safeParseFinalEventRaw,
  safeParseErrorEvent,
  normalizeStageStatus,
} from '../types/turn_stream';

// Re-export ìŠ¤íŠ¸ë¦¼ ì´ë²¤íŠ¸ íƒ€ì…ë“¤ (í•˜ìœ„ í˜¸í™˜ì„± ìœ ì§€)
export type {
  StreamEventTypeName,
  StageStatusName,
  StageEvent,
  RepairEvent,
  BadgesEvent,
  NarrativeDeltaEvent,
  FinalEvent,
  ErrorEvent,
  StreamEvent,
  StreamCallbacks,
} from '../types/turn_stream';
export { StreamEventType, StageStatus } from '../types/turn_stream';

// =============================================================================
// NDJSON íŒŒì„œ (Q1 ê²°ì •: Option A - ì§ì ‘ êµ¬í˜„)
// =============================================================================

/**
 * NDJSON ë¼ì¸ íŒŒì„œ.
 * ë¶€ë¶„ ì²­í¬ë¥¼ ë²„í¼ë§í•˜ê³  ì™„ì „í•œ ë¼ì¸ì„ íŒŒì‹±í•©ë‹ˆë‹¤.
 */
export class NDJSONParser {
  private buffer = '';

  /**
   * ì²­í¬ë¥¼ íŒŒì‹±í•˜ê³  ì™„ì „í•œ JSON ê°ì²´ë“¤ì„ ë°˜í™˜í•©ë‹ˆë‹¤.
   *
   * @param chunk - ìˆ˜ì‹ ëœ í…ìŠ¤íŠ¸ ì²­í¬
   * @returns íŒŒì‹±ëœ JSON ê°ì²´ ë°°ì—´
   */
  parse(chunk: string): unknown[] {
    this.buffer += chunk;
    const results: unknown[] = [];

    // ì¤„ë°”ê¿ˆìœ¼ë¡œ ë¶„í• 
    const lines = this.buffer.split('\n');

    // ë§ˆì§€ë§‰ ë¼ì¸ì€ ë¶ˆì™„ì „í•  ìˆ˜ ìˆìœ¼ë¯€ë¡œ ë²„í¼ì— ìœ ì§€
    this.buffer = lines.pop() ?? '';

    for (const line of lines) {
      const trimmed = line.trim();
      if (trimmed === '') continue;

      try {
        const parsed = JSON.parse(trimmed);
        results.push(parsed);
      } catch {
        // íŒŒì‹± ì‹¤íŒ¨ ì‹œ í•´ë‹¹ ë¼ì¸ ë¬´ì‹œ (RULE-004: ì „ì²´ ì¤‘ë‹¨ ë°©ì§€)
        console.warn('[NDJSON] Failed to parse line:', trimmed);
      }
    }

    return results;
  }

  /**
   * ë²„í¼ë¥¼ ì´ˆê¸°í™”í•©ë‹ˆë‹¤.
   */
  reset(): void {
    this.buffer = '';
  }

  /**
   * ë‚¨ì€ ë²„í¼ë¥¼ í”ŒëŸ¬ì‹œí•˜ê³  ë§ˆì§€ë§‰ ê°ì²´ë¥¼ íŒŒì‹±í•©ë‹ˆë‹¤.
   */
  flush(): unknown | null {
    const trimmed = this.buffer.trim();
    this.buffer = '';

    if (trimmed === '') return null;

    try {
      return JSON.parse(trimmed);
    } catch {
      console.warn('[NDJSON] Failed to parse remaining buffer:', trimmed);
      return null;
    }
  }
}

// =============================================================================
// ìŠ¤íŠ¸ë¦¼ ì´ë²¤íŠ¸ í•¸ë“¤ëŸ¬
// =============================================================================

/**
 * íŒŒì‹±ëœ ì´ë²¤íŠ¸ë¥¼ íƒ€ì…ë³„ë¡œ ë¶„ë°°í•©ë‹ˆë‹¤.
 *
 * RU-002-S2: ìºìŠ¤íŒ… ëŒ€ì‹  Zod safeParseë¥¼ ì ìš©í•˜ì—¬ ê²€ì¦ ê°•í™”.
 * Unknown/í™•ì¥ ì´ë²¤íŠ¸ëŠ” UIë¥¼ ë©ˆì¶”ì§€ ì•Šê³  ê²½ê³ ë§Œ ì¶œë ¥.
 * U-063: economySnapshot íŒŒë¼ë¯¸í„° ì¶”ê°€ - í´ë°± ì‹œì—ë„ ì¬í™” ì”ì•¡ ìœ ì§€.
 *
 * @param event - íŒŒì‹±ëœ ì´ë²¤íŠ¸ ê°ì²´
 * @param callbacks - ì½œë°± í•¨ìˆ˜ë“¤
 * @param language - í´ë°± ì–¸ì–´
 * @param economySnapshot - í˜„ì¬ ì¬í™” ìŠ¤ëƒ…ìƒ· (í´ë°± ì‹œ ì”ì•¡ ìœ ì§€)
 */
function dispatchEvent(
  event: unknown,
  callbacks: StreamCallbacks,
  language: Language,
  economySnapshot: { signal: number; memory_shard: number },
): void {
  if (!event || typeof event !== 'object') return;

  // ê¸°ë³¸ ì´ë²¤íŠ¸ íƒ€ì… ì¶”ì¶œ
  const baseResult = BaseEventSchema.safeParse(event);
  if (!baseResult.success) {
    console.warn('[TurnStream] Invalid event format (no type field):', event);
    return;
  }

  const type = baseResult.data.type;

  switch (type) {
    case StreamEventType.STAGE: {
      // RU-002-S2: stage ì´ë²¤íŠ¸ ê²€ì¦
      const stageResult = safeParseStageEvent(event);
      if (stageResult.success) {
        // status ì •ê·œí™”: 'ok' â†’ 'complete'
        const normalizedStatus = normalizeStageStatus(stageResult.data.status);
        callbacks.onStage?.({
          type: StreamEventType.STAGE,
          name: stageResult.data.name,
          status: normalizedStatus,
        });
      } else {
        console.warn('[TurnStream] Invalid stage event:', stageResult.error.message);
      }
      break;
    }

    case StreamEventType.REPAIR: {
      // RU-002-S2: repair ì´ë²¤íŠ¸ ê²€ì¦
      const repairResult = safeParseRepairEvent(event);
      if (repairResult.success) {
        callbacks.onRepair?.(repairResult.data);
      } else {
        console.warn('[TurnStream] Invalid repair event:', repairResult.error.message);
      }
      break;
    }

    case StreamEventType.BADGES: {
      // RU-002-S2: badges ì´ë²¤íŠ¸ ê²€ì¦ (v1/v2 ì •ê·œí™” í¬í•¨)
      const badgesResult = safeParseBadgesEvent(event);
      if (badgesResult.success) {
        callbacks.onBadges?.(badgesResult.data);
      } else {
        console.warn('[TurnStream] Invalid badges event:', badgesResult.error.message);
      }
      break;
    }

    case StreamEventType.NARRATIVE_DELTA: {
      // RU-002-S2: narrative_delta ì´ë²¤íŠ¸ ê²€ì¦
      const narrativeResult = safeParseNarrativeDeltaEvent(event);
      if (narrativeResult.success) {
        callbacks.onNarrativeDelta?.(narrativeResult.data);
      } else {
        console.warn('[TurnStream] Invalid narrative_delta event:', narrativeResult.error.message);
      }
      break;
    }

    case StreamEventType.FINAL: {
      // RU-002-S2: final ì´ë²¤íŠ¸ êµ¬ì¡° ê²€ì¦
      const finalRawResult = safeParseFinalEventRaw(event);
      if (!finalRawResult.success) {
        console.warn('[TurnStream] Invalid final event structure:', finalRawResult.error.message);
        // U-063: êµ¬ì¡°ê°€ ì˜ëª»ë˜ì–´ë„ í´ë°± ì œê³µ (ì¬í™” ì”ì•¡ ìœ ì§€)
        callbacks.onFinal?.({
          type: StreamEventType.FINAL,
          data: createFallbackTurnOutput(language, economySnapshot),
        });
        break;
      }

      // RULE-003/004: Zod strict parse + í´ë°±
      // U-063: economySnapshot ì „ë‹¬í•˜ì—¬ í´ë°± ì‹œì—ë„ ì¬í™” ì”ì•¡ ìœ ì§€
      const turnOutputPayload = finalRawResult.data.data;
      const parseResult = safeParseTurnOutput(turnOutputPayload, language, 0, economySnapshot);

      if (parseResult.success) {
        callbacks.onFinal?.({
          type: StreamEventType.FINAL,
          data: parseResult.data,
        });
      } else {
        console.warn('[TurnStream] TurnOutput validation failed:', parseResult.error);
        callbacks.onFinal?.({
          type: StreamEventType.FINAL,
          data: parseResult.fallback,
        });
      }
      break;
    }

    case StreamEventType.ERROR: {
      // RU-002-S2: error ì´ë²¤íŠ¸ ê²€ì¦
      const errorResult = safeParseErrorEvent(event);
      if (errorResult.success) {
        callbacks.onError?.(errorResult.data);
      } else {
        console.warn('[TurnStream] Invalid error event:', errorResult.error.message);
        // U-044: ì—ëŸ¬ ì´ë²¤íŠ¸ê°€ ê¹¨ì§„ ê²½ìš°ì—ë„ ê¸°ë³¸ ì—ëŸ¬ ì „ë‹¬ (i18n ë©”ì‹œì§€ ì‚¬ìš©)
        callbacks.onError?.({
          type: StreamEventType.ERROR,
          message: getErrorMessage('unknown_error', language),
          code: 'INVALID_ERROR_EVENT',
        });
      }
      break;
    }

    default:
      // RU-002-S2: Unknown/í™•ì¥ ì´ë²¤íŠ¸ëŠ” UIë¥¼ ë©ˆì¶”ì§€ ì•Šê³  ê²½ê³ ë§Œ ì¶œë ¥
      // í–¥í›„ protocol, repair, telemetry ë“± í™•ì¥ ì´ë²¤íŠ¸ ë„ì… ì‹œ ì—¬ê¸°ì„œ ì²˜ë¦¬ ê°€ëŠ¥
      console.warn('[TurnStream] Unknown/ignored event type:', type, event);
  }
}

// =============================================================================
// U-044: i18n ì—ëŸ¬/í´ë°± ë©”ì‹œì§€ (Q2: Option B - translation.json í‚¤ ì‚¬ìš©)
// =============================================================================

/**
 * U-044: ì—ëŸ¬ ë©”ì‹œì§€ ë²ˆì—­ ë¦¬ì†ŒìŠ¤.
 * í´ë¼ì´ì–¸íŠ¸ì—ì„œ ë°œìƒí•˜ëŠ” ì—ëŸ¬ ë©”ì‹œì§€ë¥¼ ì–¸ì–´ë³„ë¡œ ì œê³µí•©ë‹ˆë‹¤.
 *
 * ì£¼ì˜: turnStream.tsëŠ” React ì»´í¬ë„ŒíŠ¸ê°€ ì•„ë‹ˆë¯€ë¡œ useTranslation ì‚¬ìš© ë¶ˆê°€.
 * ëŒ€ì‹  language ë§¤ê°œë³€ìˆ˜ë¡œ ë¶„ê¸° ì²˜ë¦¬í•©ë‹ˆë‹¤.
 * translation.jsonì˜ í‚¤ì™€ ë™ê¸°í™” ìœ ì§€ í•„ìš” (error.* ë„¤ì„ìŠ¤í˜ì´ìŠ¤).
 */
const ERROR_MESSAGES: Record<string, Record<Language, string>> = {
  // ì—ëŸ¬ ì´ë²¤íŠ¸ íŒŒì‹± ì‹¤íŒ¨
  unknown_error: {
    'ko-KR': 'ì•Œ ìˆ˜ ì—†ëŠ” ì˜¤ë¥˜ê°€ ë°œìƒí–ˆìŠµë‹ˆë‹¤.',
    'en-US': 'An unknown error occurred.',
  },
  // ì‘ë‹µ ë°ì´í„° ì²˜ë¦¬ ì‹¤íŒ¨ (final ì´ë²¤íŠ¸ ìŠ¤í‚¤ë§ˆ ê²€ì¦ ì‹¤íŒ¨)
  response_processing: {
    'ko-KR': '[ì‹œìŠ¤í…œ] ì‘ë‹µ ë°ì´í„°ë¥¼ ì²˜ë¦¬í•˜ëŠ” ì¤‘ ë¬¸ì œê°€ ë°œìƒí–ˆìŠµë‹ˆë‹¤.',
    'en-US': '[System] An error occurred while processing response data.',
  },
  // ì„œë²„ ì—°ê²° ì‹¤íŒ¨ (ë„¤íŠ¸ì›Œí¬ ì—ëŸ¬)
  connection_failed: {
    'ko-KR': '[ì‹œìŠ¤í…œ] ì„œë²„ ì—°ê²°ì— ì‹¤íŒ¨í–ˆìŠµë‹ˆë‹¤. ë‹¤ì‹œ ì‹œë„í•´ ì£¼ì„¸ìš”.',
    'en-US': '[System] Failed to connect to server. Please try again.',
  },
};

/**
 * U-044: ì—ëŸ¬ ë©”ì‹œì§€ë¥¼ ì–¸ì–´ì— ë§ê²Œ ë°˜í™˜í•©ë‹ˆë‹¤.
 */
function getErrorMessage(key: string, language: Language): string {
  return ERROR_MESSAGES[key]?.[language] ?? ERROR_MESSAGES[key]?.['en-US'] ?? key;
}

/**
 * í´ë¼ì´ì–¸íŠ¸ ì¸¡ í´ë°± TurnOutput ìƒì„± (ì–¸ì–´ + ìŠ¤ëƒ…ìƒ· ì§€ì •).
 * dispatchEvent ë‚´ë¶€ì—ì„œ ì‚¬ìš©í•˜ëŠ” ê°„ë‹¨í•œ í´ë°±.
 * U-044: í•˜ë“œì½”ë”© ë©”ì‹œì§€ ì œê±°, i18n ë¦¬ì†ŒìŠ¤ ì‚¬ìš©.
 * U-063: economySnapshot íŒŒë¼ë¯¸í„° ì¶”ê°€ - í´ë°±ì—ì„œë„ ì¬í™” ì”ì•¡ ìœ ì§€ (RULE-005).
 */
function createFallbackTurnOutput(
  language: Language,
  economySnapshot?: { signal: number; memory_shard: number },
): TurnOutput {
  const fallbackNarrative = getErrorMessage('response_processing', language);

  // U-063: í´ë°±ì—ì„œë„ ì¬í™” ì”ì•¡ ìœ ì§€ (RULE-005)
  const balanceAfter = economySnapshot
    ? { signal: economySnapshot.signal, memory_shard: economySnapshot.memory_shard }
    : { signal: 100, memory_shard: 5 }; // ê¸°ë³¸ê°’ (í”„ë¡œí•„ ë¯¸ë¡œë“œ ìƒíƒœì˜ placeholder)

  return {
    language,
    narrative: fallbackNarrative,
    economy: {
      cost: { signal: 0, memory_shard: 0 },
      balance_after: balanceAfter,
      credit: 0,
      low_balance_warning: false,
    },
    safety: {
      blocked: false,
      message: null,
    },
    ui: {
      action_deck: { cards: [] },
      objects: [],
      scene: { image_url: null, alt_text: null },
    },
    world: {
      rules_changed: [],
      inventory_added: [],
      inventory_removed: [],
      quests_updated: [],
      relationships_changed: [],
      memory_pins: [],
    },
    render: {
      image_job: null,
      image_url: null,
      image_id: null,
      generation_time_ms: null,
    },
    agent_console: {
      current_phase: 'commit',
      badges: ['schema_fail'],
      repair_count: 1,
      model_label: 'FAST',
    },
  };
}

// =============================================================================
// API ì„¤ì •
// =============================================================================

/** ë°±ì—”ë“œ API URL (RULE-011: í¬íŠ¸ 8011) */
const API_BASE_URL = 'http://localhost:8011';

/** í„´ ìŠ¤íŠ¸ë¦¼ API ì—”ë“œí¬ì¸íŠ¸ */
const TURN_ENDPOINT = `${API_BASE_URL}/api/turn`;

// =============================================================================
// ìŠ¤íŠ¸ë¦¼ í´ë¼ì´ì–¸íŠ¸
// =============================================================================

/** ìŠ¤íŠ¸ë¦¼ ìš”ì²­ ì˜µì…˜ */
export interface TurnStreamOptions {
  /** ìš”ì²­ íƒ€ì„ì•„ì›ƒ (ms) */
  timeout?: number;
  /** AbortSignal */
  signal?: AbortSignal;
}

/**
 * í„´ ìŠ¤íŠ¸ë¦¼ ìš”ì²­ì„ ì‹¤í–‰í•©ë‹ˆë‹¤.
 *
 * @param input - í„´ ì…ë ¥ ë°ì´í„°
 * @param callbacks - ì´ë²¤íŠ¸ ì½œë°±
 * @param options - ìš”ì²­ ì˜µì…˜
 * @returns ì·¨ì†Œ í•¨ìˆ˜
 */
export async function executeTurnStream(
  input: TurnInput,
  callbacks: StreamCallbacks,
  options?: TurnStreamOptions,
): Promise<void> {
  const parser = new NDJSONParser();
  const controller = new AbortController();
  const signal = options?.signal ?? controller.signal;

  // RU-002-S1: AbortError ë°œìƒ ì‹œ onComplete í˜¸ì¶œ ì—¬ë¶€ ì¶”ì 
  let aborted = false;

  try {
    const response = await fetch(TURN_ENDPOINT, {
      method: 'POST',
      headers: {
        'Content-Type': 'application/json',
        Accept: 'application/x-ndjson',
      },
      body: JSON.stringify(input),
      signal,
    });

    if (!response.ok) {
      throw new Error(`HTTP ${response.status}: ${response.statusText}`);
    }

    if (!response.body) {
      throw new Error('Response body is null');
    }

    const reader = response.body.getReader();
    const decoder = new TextDecoder('utf-8');

    // ìŠ¤íŠ¸ë¦¼ ì½ê¸° ë£¨í”„
    // U-063: economySnapshotì„ dispatchEventì— ì „ë‹¬í•˜ì—¬ í´ë°± ì‹œ ì¬í™” ì”ì•¡ ìœ ì§€
    while (true) {
      const { done, value } = await reader.read();

      if (done) break;

      const chunk = decoder.decode(value, { stream: true });
      const events = parser.parse(chunk);

      for (const event of events) {
        dispatchEvent(event, callbacks, input.language, input.economy_snapshot);
      }
    }

    // ë‚¨ì€ ë²„í¼ í”ŒëŸ¬ì‹œ
    const remaining = parser.flush();
    if (remaining) {
      dispatchEvent(remaining, callbacks, input.language, input.economy_snapshot);
    }
  } catch (error) {
    if (error instanceof DOMException && error.name === 'AbortError') {
      // RU-003-S1: Abort(ì·¨ì†Œ) ì •ì±…
      // =========================================================================
      // í˜„ì¬ ì •ì±…(Option B): Abort ì‹œ onCompleteë¥¼ í˜¸ì¶œí•˜ì§€ ì•ŠìŒ
      // - ì´ìœ : ì·¨ì†ŒëŠ” "ì‚¬ìš©ì ì˜ë„"ì´ë¯€ë¡œ ì‹¤íŒ¨ì™€ êµ¬ë¶„í•´ì•¼ í•¨
      // - ì£¼ì˜: ì´ ì •ì±…ì—ì„œëŠ” Cancel ë²„íŠ¼ êµ¬í˜„ ì‹œ í˜¸ì¶œìê°€ ì§ì ‘ UI ë³µêµ¬ í•„ìš”
      //
      // í–¥í›„ Option Aë¡œ ì „í™˜ ê°€ëŠ¥:
      // - Abort ì‹œì—ë„ onComplete í˜¸ì¶œ + ë³„ë„ í”Œë˜ê·¸ë¡œ "ì·¨ì†Œ ì¢…ë£Œ" êµ¬ë¶„
      // - ì¥ì : UIê°€ ë©ˆì¶”ì§€ ì•ŠìŒ (ë³µêµ¬ ì¼ê´€ì„±)
      // - ë‹¨ì : ì·¨ì†Œì™€ ì‹¤íŒ¨ë¥¼ êµ¬ë¶„í•˜ë ¤ë©´ ì´ë²¤íŠ¸ ëª¨ë¸ í™•ì¥ í•„ìš”
      //
      // ê²°ì • ê·¼ê±°: RU-003-S1 Step 3
      // =========================================================================
      aborted = true;
      return;
    }

    const errorMessage = error instanceof Error ? error.message : 'Unknown error occurred';

    // RU-002-S1: ë„¤íŠ¸ì›Œí¬ ì—ëŸ¬ ì‹œì—ë„ onError í˜¸ì¶œ
    callbacks.onError?.({
      type: StreamEventType.ERROR,
      message: errorMessage,
      code: 'STREAM_ERROR',
    });

    // RU-002-S1: ë„¤íŠ¸ì›Œí¬ ì—ëŸ¬ ì‹œ í´ë¼ì´ì–¸íŠ¸ ì¸¡ í´ë°± final ìƒì„±
    // ì„œë²„ì—ì„œ finalì´ ì˜¤ì§€ ëª»í•œ ê²½ìš° UIê°€ ë©ˆì¶”ì§€ ì•Šë„ë¡ í•¨
    const fallback = createClientFallbackTurnOutput(input.language, input.economy_snapshot);
    callbacks.onFinal?.({
      type: StreamEventType.FINAL,
      data: fallback,
    });
  } finally {
    // RU-002-S1: ìŠ¤íŠ¸ë¦¼ ì¢…ë£Œ ì¸ë°”ë¦¬ì–¸íŠ¸ - ì„±ê³µ/ì‹¤íŒ¨ ëª¨ë‘ì—ì„œ onComplete í˜¸ì¶œ ë³´ì¥
    if (!aborted) {
      callbacks.onComplete?.();
    }
  }
}

/**
 * í´ë¼ì´ì–¸íŠ¸ ì¸¡ í´ë°± TurnOutput ìƒì„± (RU-002-S1).
 * ì„œë²„ì—ì„œ finalì´ ì˜¤ì§€ ëª»í•œ ê²½ìš° (ë„¤íŠ¸ì›Œí¬ ì—ëŸ¬ ë“±) ì‚¬ìš©í•©ë‹ˆë‹¤.
 * EconomyëŠ” ìš”ì²­ ì§ì „ ìŠ¤ëƒ…ìƒ·ì„ ê·¸ëŒ€ë¡œ ìœ ì§€í•©ë‹ˆë‹¤.
 * U-044: í•˜ë“œì½”ë”© ë©”ì‹œì§€ ì œê±°, i18n ë¦¬ì†ŒìŠ¤ ì‚¬ìš©.
 */
function createClientFallbackTurnOutput(
  language: Language,
  economySnapshot: { signal: number; memory_shard: number },
): TurnOutput {
  const fallbackNarrative = getErrorMessage('connection_failed', language);

  return {
    language,
    narrative: fallbackNarrative,
    economy: {
      cost: { signal: 0, memory_shard: 0 },
      // RU-002-S1: ì…ë ¥ ìŠ¤ëƒ…ìƒ· ê·¸ëŒ€ë¡œ ìœ ì§€ (ë¹„ìš© 0, ì”ì•¡ ë³€í™” ì—†ìŒ)
      balance_after: {
        signal: economySnapshot.signal,
        memory_shard: economySnapshot.memory_shard,
      },
      credit: 0,
      low_balance_warning: false,
    },
    safety: {
      blocked: false,
      message: null,
    },
    ui: {
      action_deck: { cards: [] },
      objects: [],
      scene: { image_url: null, alt_text: null },
    },
    world: {
      rules_changed: [],
      inventory_added: [],
      inventory_removed: [],
      quests_updated: [],
      relationships_changed: [],
      memory_pins: [],
    },
    render: {
      image_job: null,
      image_url: null,
      image_id: null,
      generation_time_ms: null,
    },
    agent_console: {
      current_phase: 'commit',
      badges: ['schema_fail'],
      repair_count: 1,
      model_label: 'FAST',
    },
  };
}

/**
 * í„´ ìŠ¤íŠ¸ë¦¼ì„ ì‹œì‘í•˜ê³  ì·¨ì†Œ í•¨ìˆ˜ë¥¼ ë°˜í™˜í•©ë‹ˆë‹¤.
 *
 * @param input - í„´ ì…ë ¥ ë°ì´í„°
 * @param callbacks - ì´ë²¤íŠ¸ ì½œë°±
 * @returns ì·¨ì†Œ í•¨ìˆ˜
 */
export function startTurnStream(input: TurnInput, callbacks: StreamCallbacks): () => void {
  const controller = new AbortController();

  executeTurnStream(input, callbacks, { signal: controller.signal });

  return () => controller.abort();
}
</file>

<file path="frontend/src/save/saveGame.ts">
/**
 * Unknown World - SaveGame ì €ì¥/ë³µì› ëª¨ë“ˆ (U-015[Mvp]).
 *
 * ë¡œê·¸ì¸ ì—†ì´ ì¦‰ì‹œ ì‹œì‘ ê°€ëŠ¥í•œ ë°ëª¨ í”„ë¡œí•„ê³¼ ì„¸ì´ë¸Œ/ë¡œë“œ ê¸°ëŠ¥ì„ ì œê³µí•©ë‹ˆë‹¤.
 * DB ì—†ì´ SaveGame JSON ì§ë ¬í™” ê¸°ë°˜ìœ¼ë¡œ localStorageì— ì €ì¥í•©ë‹ˆë‹¤.
 *
 * ì„¤ê³„ ì›ì¹™:
 *   - RULE-010: DB/ORM ë„ì… ê¸ˆì§€ (SaveGame JSON ì§ë ¬í™” ê¸°ë°˜)
 *   - RULE-006: language í•„ë“œë¡œ ko/en í˜¼í•© ë°©ì§€
 *   - Q1 ê²°ì •: Option A - localStorage ì‚¬ìš© (ë‹¨ìˆœ/ë°ëª¨ ì í•©)
 *   - RU-004-Q5: ìƒìˆ˜ëŠ” constants.tsì—ì„œ ì¤‘ì•™ ê´€ë¦¬
 *
 * @module save/saveGame
 */

import { z } from 'zod';
import type { SupportedLanguage } from '../i18n';
import type { LedgerEntry } from '../stores/economyStore';
import { LedgerEntrySchema, type Quest, type WorldRule } from '../schemas';
import type { InventoryItem } from '../stores/inventoryStore';
import type { MutationEvent, NarrativeEntry, EconomyState } from '../stores/worldStore';
import type { SceneObject } from '../schemas/turn';

// RU-004-Q5: ìƒìˆ˜ ì¤‘ì•™í™” - constants.tsì—ì„œ import
import { SAVEGAME_VERSION, SAVEGAME_STORAGE_KEY, CURRENT_PROFILE_KEY } from './constants';

// U-041: ë§ˆì´ê·¸ë ˆì´ì…˜ ëª¨ë“ˆ
import {
  upgradeToLatest,
  extractVersion,
  isMigratableVersion,
  type MigrationResult,
} from './migrations';

// RU-004-Q5: ìƒìˆ˜ re-export (ê¸°ì¡´ í˜¸ì¶œì í˜¸í™˜ì„± ìœ ì§€)
export { SAVEGAME_VERSION, SAVEGAME_STORAGE_KEY, CURRENT_PROFILE_KEY };

// =============================================================================
// SaveGame ìŠ¤í‚¤ë§ˆ ì •ì˜
// =============================================================================

/**
 * SaveGame Zod ìŠ¤í‚¤ë§ˆ.
 * ìµœì†Œ í•„ë“œë§Œ í¬í•¨í•˜ì—¬ MVP ìš”êµ¬ì‚¬í•­ì„ ì¶©ì¡±í•©ë‹ˆë‹¤.
 */
export const SaveGameSchema = z
  .object({
    /** ìŠ¤í‚¤ë§ˆ ë²„ì „ (ë§ˆì´ê·¸ë ˆì´ì…˜ìš©) */
    version: z.string().describe('SaveGame ìŠ¤í‚¤ë§ˆ ë²„ì „'),
    /** ì„¸ì…˜ ì‹œë“œ (ë¦¬í”Œë ˆì´ ì¬í˜„ìš©, ì„ íƒ) */
    seed: z.string().nullable().default(null).describe('ì„¸ì…˜ ì‹œë“œ'),
    /** ì–¸ì–´ ì„¤ì • (RULE-006: ë³µì› ì‹œ UI i18nì—ë„ ì ìš©) */
    language: z.enum(['ko-KR', 'en-US']).describe('ì–¸ì–´ ì„¤ì •'),
    /** ì‚¬ìš©ëœ ë°ëª¨ í”„ë¡œí•„ ID */
    profileId: z.string().nullable().default(null).describe('ë°ëª¨ í”„ë¡œí•„ ID'),
    /** ì €ì¥ ì‹œê° (ISO 8601) */
    savedAt: z.string().describe('ì €ì¥ ì‹œê°'),

    /** ì¬í™” ìƒíƒœ */
    economy: z
      .object({
        signal: z.number().int().min(0),
        memory_shard: z.number().int().min(0),
        credit: z.number().int().default(0).describe('ì‚¬ìš© ì¤‘ì¸ í¬ë ˆë”§ (ë¹š)'),
      })
      .describe('ì¬í™” ìƒíƒœ'),

    /** ê²½ì œ ê±°ë˜ ì¥ë¶€ ì´ë ¥ */
    economyLedger: z.array(LedgerEntrySchema).default([]).describe('ê²½ì œ ê±°ë˜ ì¥ë¶€ ì´ë ¥'),

    /** í˜„ì¬ í„´ ì¹´ìš´íŠ¸ */
    turnCount: z.number().int().min(0).default(0).describe('í˜„ì¬ í„´ ì¹´ìš´íŠ¸'),

    /** ë‚´ëŸ¬í‹°ë¸Œ íˆìŠ¤í† ë¦¬ */
    narrativeHistory: z
      .array(
        z.object({
          turn: z.number().int(),
          text: z.string(),
        }),
      )
      .default([])
      .describe('ë‚´ëŸ¬í‹°ë¸Œ íˆìŠ¤í† ë¦¬'),

    /** ì¸ë²¤í† ë¦¬ ì•„ì´í…œ */
    inventory: z
      .array(
        z.object({
          id: z.string(),
          name: z.string(),
          description: z.string().optional(),
          icon: z.string().optional(),
          quantity: z.number().int().min(1),
          // U-075: ì•„ì´ì½˜ ìƒì„± ìƒíƒœ (ì„ íƒ, ë³µì› ì‹œ ì—†ìœ¼ë©´ 'pending'ìœ¼ë¡œ ê°„ì£¼)
          iconStatus: z.enum(['pending', 'generating', 'completed', 'failed', 'cached']).optional(),
        }),
      )
      .default([])
      .describe('ì¸ë²¤í† ë¦¬ ì•„ì´í…œ'),

    /** í™œì„± í€˜ìŠ¤íŠ¸ (U-078: ëª©í‘œ ì‹œìŠ¤í…œ ê°•í™”) */
    quests: z
      .array(
        z.object({
          id: z.string(),
          label: z.string(),
          is_completed: z.boolean().default(false),
          description: z.string().nullable().default(null),
          is_main: z.boolean().default(false),
          progress: z.number().int().min(0).max(100).default(0),
          reward_signal: z.number().int().min(0).default(0),
        }),
      )
      .default([])
      .describe('í™œì„± í€˜ìŠ¤íŠ¸'),

    /** í™œì„± ê·œì¹™ */
    activeRules: z
      .array(
        z.object({
          id: z.string(),
          label: z.string(),
          description: z.string().nullable().default(null),
        }),
      )
      .default([])
      .describe('í™œì„± ê·œì¹™'),

    /** ë£° ë³€í˜• íƒ€ì„ë¼ì¸ */
    mutationTimeline: z
      .array(
        z.object({
          turn: z.number().int(),
          ruleId: z.string(),
          type: z.enum(['added', 'modified', 'removed']),
          label: z.string(),
          description: z.string().optional(),
          timestamp: z.number(),
        }),
      )
      .default([])
      .describe('ë£° ë³€í˜• íƒ€ì„ë¼ì¸'),

    /** Scene Objects (í•«ìŠ¤íŒŸ) */
    sceneObjects: z
      .array(
        z.object({
          id: z.string(),
          label: z.string(),
          box_2d: z.object({
            ymin: z.number().int().min(0).max(1000),
            xmin: z.number().int().min(0).max(1000),
            ymax: z.number().int().min(0).max(1000),
            xmax: z.number().int().min(0).max(1000),
          }),
          interaction_hint: z.string().nullable().default(null),
        }),
      )
      .default([])
      .describe('Scene Objects'),
  })
  .strict();

export type SaveGame = z.infer<typeof SaveGameSchema>;

// =============================================================================
// ì €ì¥/ë³µì› í•¨ìˆ˜
// =============================================================================

/**
 * SaveGame ì¸í„°í˜ì´ìŠ¤ (ì €ì¥í•  ìƒíƒœ ì „ì²´ë¥¼ ìº¡ì²˜).
 */
export interface SaveGameInput {
  language: SupportedLanguage;
  profileId?: string | null;
  seed?: string | null;
  economy: EconomyState;
  economyLedger: LedgerEntry[];
  turnCount: number;
  narrativeHistory: NarrativeEntry[];
  inventory: InventoryItem[];
  quests: Quest[];
  activeRules: WorldRule[];
  mutationTimeline: MutationEvent[];
  sceneObjects: SceneObject[];
}

/**
 * í˜„ì¬ ìƒíƒœë¥¼ SaveGame ê°ì²´ë¡œ ì§ë ¬í™”í•©ë‹ˆë‹¤.
 */
export function createSaveGame(input: SaveGameInput): SaveGame {
  return {
    version: SAVEGAME_VERSION,
    seed: input.seed ?? null,
    language: input.language,
    profileId: input.profileId ?? null,
    savedAt: new Date().toISOString(),
    economy: {
      signal: input.economy.signal,
      memory_shard: input.economy.memory_shard,
      credit: input.economy.credit,
    },
    economyLedger: input.economyLedger.map((entry) => ({
      turnId: entry.turnId,
      actionId: entry.actionId,
      reason: entry.reason,
      cost: {
        signal: entry.cost.signal,
        memory_shard: entry.cost.memory_shard,
      },
      balanceAfter: {
        signal: entry.balanceAfter.signal,
        memory_shard: entry.balanceAfter.memory_shard,
      },
      modelLabel: entry.modelLabel,
      timestamp: entry.timestamp,
    })),
    turnCount: input.turnCount,
    narrativeHistory: input.narrativeHistory.map((entry) => ({
      turn: entry.turn,
      text: entry.text,
    })),
    inventory: input.inventory.map((item) => ({
      id: item.id,
      name: item.name,
      description: item.description,
      icon: item.icon,
      quantity: item.quantity,
      iconStatus: item.iconStatus, // U-075: ì•„ì´ì½˜ ìƒì„± ìƒíƒœ ì €ì¥
    })),
    // U-078: ëª©í‘œ ì‹œìŠ¤í…œ ê°•í™” - ìƒˆ í•„ë“œ í¬í•¨
    quests: input.quests.map((quest) => ({
      id: quest.id,
      label: quest.label,
      is_completed: quest.is_completed,
      description: quest.description ?? null,
      is_main: quest.is_main ?? false,
      progress: quest.progress ?? 0,
      reward_signal: quest.reward_signal ?? 0,
    })),
    activeRules: input.activeRules.map((rule) => ({
      id: rule.id,
      label: rule.label,
      description: rule.description,
    })),
    mutationTimeline: input.mutationTimeline.map((event) => ({
      turn: event.turn,
      ruleId: event.ruleId,
      type: event.type,
      label: event.label,
      description: event.description,
      timestamp: event.timestamp,
    })),
    sceneObjects: input.sceneObjects.map((obj) => ({
      id: obj.id,
      label: obj.label,
      box_2d: {
        ymin: obj.box_2d.ymin,
        xmin: obj.box_2d.xmin,
        ymax: obj.box_2d.ymax,
        xmax: obj.box_2d.xmax,
      },
      interaction_hint: obj.interaction_hint,
    })),
  };
}

/**
 * SaveGameì„ localStorageì— ì €ì¥í•©ë‹ˆë‹¤.
 *
 * @returns ì €ì¥ ì„±ê³µ ì—¬ë¶€
 */
export function saveSaveGame(saveGame: SaveGame): boolean {
  try {
    const json = JSON.stringify(saveGame);
    localStorage.setItem(SAVEGAME_STORAGE_KEY, json);
    return true;
  } catch (error) {
    console.error('[SaveGame] ì €ì¥ ì‹¤íŒ¨:', error);
    return false;
  }
}

/**
 * localStorageì—ì„œ SaveGameì„ ë¡œë“œí•©ë‹ˆë‹¤.
 *
 * U-041: "ë²„ì „ íŒë³„ â†’ ë§ˆì´ê·¸ë ˆì´ì…˜ â†’ ê²€ì¦" íë¦„ìœ¼ë¡œ ë³€ê²½
 * - êµ¬ë²„ì „ SaveGameë„ ë§ˆì´ê·¸ë ˆì´ì…˜ í›„ ìµœì‹  ìŠ¤í‚¤ë§ˆë¥¼ í†µê³¼í•  ìˆ˜ ìˆìŒ
 * - ìŠ¤í‚¤ë§ˆ ê²€ì¦ì€ ë§ˆì´ê·¸ë ˆì´ì…˜ ì™„ë£Œ í›„ ìˆ˜í–‰
 *
 * @returns SaveGame ê°ì²´ ë˜ëŠ” null (ì—†ê±°ë‚˜ ìœ íš¨í•˜ì§€ ì•Šì€ ê²½ìš°)
 */
export function loadSaveGame(): SaveGame | null {
  try {
    const json = localStorage.getItem(SAVEGAME_STORAGE_KEY);
    if (!json) {
      return null;
    }

    // Step 1: JSON íŒŒì‹±
    let parsed: unknown;
    try {
      parsed = JSON.parse(json);
    } catch {
      console.warn('[SaveGame] JSON íŒŒì‹± ì‹¤íŒ¨');
      return null;
    }

    // Step 2: ë²„ì „ ì¶”ì¶œ (U-041: ìµœì†Œ íŒŒì„œë¡œ ë²„ì „ë§Œ ë¨¼ì € í™•ì¸)
    const version = extractVersion(parsed);
    if (!version) {
      console.warn('[SaveGame] ë²„ì „ ì •ë³´ ì—†ìŒ');
      return null;
    }

    // Step 3: ë§ˆì´ê·¸ë ˆì´ì…˜ ìˆ˜í–‰ (ë²„ì „ ë¶ˆì¼ì¹˜ ì‹œ)
    let dataToValidate: unknown = parsed;

    if (version !== SAVEGAME_VERSION) {
      // ë§ˆì´ê·¸ë ˆì´ì…˜ ì‹œë„
      const migrationResult = migrateSaveGame(parsed, version);
      if (!migrationResult) {
        console.warn('[SaveGame] ë§ˆì´ê·¸ë ˆì´ì…˜ ì‹¤íŒ¨, ìƒˆë¡œ ì‹œì‘ í•„ìš”');
        return null;
      }
      dataToValidate = migrationResult;
    }

    // Step 4: ìµœì¢… ìŠ¤í‚¤ë§ˆ ê²€ì¦ (ë§ˆì´ê·¸ë ˆì´ì…˜ í›„)
    const result = SaveGameSchema.safeParse(dataToValidate);
    if (!result.success) {
      console.warn('[SaveGame] ìŠ¤í‚¤ë§ˆ ê²€ì¦ ì‹¤íŒ¨:', result.error);
      return null;
    }

    return result.data;
  } catch (error) {
    console.error('[SaveGame] ë¡œë“œ ì‹¤íŒ¨:', error);
    return null;
  }
}

/**
 * ì €ì¥ëœ SaveGameì„ ì‚­ì œí•©ë‹ˆë‹¤.
 */
export function clearSaveGame(): void {
  try {
    localStorage.removeItem(SAVEGAME_STORAGE_KEY);
  } catch (error) {
    console.error('[SaveGame] ì‚­ì œ ì‹¤íŒ¨:', error);
  }
}

/**
 * SaveGameì´ ì¡´ì¬í•˜ëŠ”ì§€ í™•ì¸í•©ë‹ˆë‹¤.
 *
 * @deprecated RU-004-S2: ì´ í•¨ìˆ˜ëŠ” í‚¤ ì¡´ì¬ë§Œ í™•ì¸í•˜ë¯€ë¡œ "ìœ íš¨í•œ ì„¸ì´ë¸Œ" íŒë‹¨ì— ë¶€ì í•©í•©ë‹ˆë‹¤.
 *             ëŒ€ì‹  `getValidSaveGameOrNull()`ì„ ì‚¬ìš©í•˜ì„¸ìš”.
 */
export function hasSaveGame(): boolean {
  try {
    return localStorage.getItem(SAVEGAME_STORAGE_KEY) !== null;
  } catch {
    return false;
  }
}

/**
 * ìœ íš¨í•œ SaveGameì„ ë°˜í™˜í•©ë‹ˆë‹¤. ì—†ê±°ë‚˜ ê²€ì¦/ë§ˆì´ê·¸ë ˆì´ì…˜ ì‹¤íŒ¨ ì‹œ nullì„ ë°˜í™˜í•©ë‹ˆë‹¤ (RU-004-S2).
 *
 * `hasSaveGame()` ëŒ€ì‹  ì´ í•¨ìˆ˜ë¥¼ ì‚¬ìš©í•˜ë©´ "Continue ë²„íŠ¼ ë…¸ì¶œ" íŒë‹¨ì´ ì •í™•í•´ì§‘ë‹ˆë‹¤:
 * - localStorageì— ë°ì´í„°ê°€ ìˆì–´ë„ ìŠ¤í‚¤ë§ˆ ê²€ì¦ ì‹¤íŒ¨ ì‹œ null ë°˜í™˜
 * - ë²„ì „ ë¶ˆì¼ì¹˜ë¡œ ë§ˆì´ê·¸ë ˆì´ì…˜ ì‹¤íŒ¨ ì‹œ null ë°˜í™˜
 *
 * @returns ìœ íš¨í•œ SaveGame ë˜ëŠ” null
 */
export function getValidSaveGameOrNull(): SaveGame | null {
  return loadSaveGame();
}

// =============================================================================
// í”„ë¡œí•„ ê´€ë ¨ ìœ í‹¸ë¦¬í‹°
// =============================================================================

/**
 * í˜„ì¬ ì„ íƒëœ í”„ë¡œí•„ IDë¥¼ ì €ì¥í•©ë‹ˆë‹¤.
 */
export function saveCurrentProfileId(profileId: string): void {
  try {
    localStorage.setItem(CURRENT_PROFILE_KEY, profileId);
  } catch (error) {
    console.error('[SaveGame] í”„ë¡œí•„ ID ì €ì¥ ì‹¤íŒ¨:', error);
  }
}

/**
 * í˜„ì¬ ì„ íƒëœ í”„ë¡œí•„ IDë¥¼ ë¡œë“œí•©ë‹ˆë‹¤.
 */
export function loadCurrentProfileId(): string | null {
  try {
    return localStorage.getItem(CURRENT_PROFILE_KEY);
  } catch {
    return null;
  }
}

/**
 * í˜„ì¬ ì„ íƒëœ í”„ë¡œí•„ IDë¥¼ ì‚­ì œí•©ë‹ˆë‹¤.
 */
export function clearCurrentProfileId(): void {
  try {
    localStorage.removeItem(CURRENT_PROFILE_KEY);
  } catch (error) {
    console.error('[SaveGame] í”„ë¡œí•„ ID ì‚­ì œ ì‹¤íŒ¨:', error);
  }
}

// =============================================================================
// ë²„ì „ ë§ˆì´ê·¸ë ˆì´ì…˜ (U-041)
// =============================================================================

/**
 * SaveGame ë°ì´í„°ë¥¼ ìµœì‹  ë²„ì „ìœ¼ë¡œ ë§ˆì´ê·¸ë ˆì´ì…˜í•©ë‹ˆë‹¤.
 *
 * U-041: migrations.tsì˜ upgradeToLatestë¥¼ ì‚¬ìš©í•˜ì—¬ ë²„ì „ë³„ ë³€í™˜ ìˆ˜í–‰
 *
 * @param data - ë§ˆì´ê·¸ë ˆì´ì…˜í•  SaveGame ë°ì´í„° (unknown - ìŠ¤í‚¤ë§ˆ ê²€ì¦ ì „)
 * @param version - í˜„ì¬ ë°ì´í„°ì˜ ë²„ì „
 * @returns ë§ˆì´ê·¸ë ˆì´ì…˜ëœ ë°ì´í„° ë˜ëŠ” null (ë§ˆì´ê·¸ë ˆì´ì…˜ ë¶ˆê°€)
 */
export function migrateSaveGame(data: unknown, version: string): unknown | null {
  // í˜„ì¬ ë²„ì „ì´ë©´ ê·¸ëŒ€ë¡œ ë°˜í™˜
  if (version === SAVEGAME_VERSION) {
    return data;
  }

  // ë§ˆì´ê·¸ë ˆì´ì…˜ ê°€ëŠ¥í•œ ë²„ì „ì¸ì§€ í™•ì¸
  if (!isMigratableVersion(version)) {
    console.warn(`[SaveGame] ì§€ì›í•˜ì§€ ì•ŠëŠ” ë²„ì „: ${version}`);
    return null;
  }

  // ë§ˆì´ê·¸ë ˆì´ì…˜ ìˆ˜í–‰
  console.log(`[SaveGame] ë§ˆì´ê·¸ë ˆì´ì…˜ ì‹œì‘: ${version} â†’ ${SAVEGAME_VERSION}`);
  const result = upgradeToLatest(data, version);

  if (!result.success) {
    console.warn(`[SaveGame] ë§ˆì´ê·¸ë ˆì´ì…˜ ì‹¤íŒ¨: ${result.error}`);
    return null;
  }

  // ì„±ê³µ ë¡œê·¸
  const migrationResult = result as MigrationResult;
  console.log(`[SaveGame] ë§ˆì´ê·¸ë ˆì´ì…˜ ì™„ë£Œ: ${migrationResult.appliedMigrations.join(' â†’ ')}`);

  return migrationResult.data;
}

/**
 * @deprecated U-041: ì´ì „ ë²„ì „ í˜¸í™˜ì„±ì„ ìœ„í•œ ë˜í¼.
 *             ìƒˆ ì½”ë“œì—ì„œëŠ” migrateSaveGame(data, version)ì„ ì§ì ‘ ì‚¬ìš©í•˜ì„¸ìš”.
 *
 * SaveGame íƒ€ì…ì´ ì´ë¯¸ í™•ì •ëœ ê²½ìš° (ìµœì‹  ìŠ¤í‚¤ë§ˆë¡œ ê²€ì¦ëœ ê²½ìš°)ì—ë§Œ ì‚¬ìš©í•©ë‹ˆë‹¤.
 */
export function migrateSaveGameLegacy(saveGame: SaveGame): SaveGame | null {
  if (saveGame.version === SAVEGAME_VERSION) {
    return saveGame;
  }
  // ì´ë¯¸ SaveGame íƒ€ì…ì´ë©´ ìµœì‹  ìŠ¤í‚¤ë§ˆë¥¼ í†µê³¼í•œ ê²ƒì´ë¯€ë¡œ ë²„ì „ë§Œ ì²´í¬
  console.warn(`[SaveGame] ë²„ì „ ë¶ˆì¼ì¹˜ (legacy): ${saveGame.version}`);
  return null;
}
</file>

<file path="frontend/src/components/ActionDeck.tsx">
/**
 * Unknown World - Action Deck ì»´í¬ë„ŒíŠ¸ (U-009[Mvp]).
 *
 * PRD ìš”êµ¬ì‚¬í•­:
 *   - Action Deck(3~6ì¥ ì¹´ë“œ)ì„ Footer ì˜ì—­ì— ìƒì‹œ ë…¸ì¶œ
 *   - ê° ì¹´ë“œì— ì˜ˆìƒ ë¹„ìš©(ìµœì†Œ/ìµœëŒ€), ìœ„í—˜ë„, ë³´ìƒ íŒíŠ¸ í‘œê¸° (RULE-005)
 *   - ì¹´ë“œ í´ë¦­ ì‹œ TurnInputìœ¼ë¡œ ì„ íƒëœ í–‰ë™ ì „ì†¡ (RULE-008)
 *   - ì”ì•¡ ë¶€ì¡± ì‹œ ì‹¤í–‰ ë¶ˆê°€ í‘œì‹œ + ì €ë¹„ìš© ëŒ€ì•ˆ ë…¸ì¶œ (RULE-005)
 *
 * RULE-002 ì¤€ìˆ˜: ì±„íŒ… ë²„ë¸”/ë©”ì‹œì§€ ë²„íŠ¼ì´ ì•„ë‹Œ "ê²Œì„ ì¹´ë“œ" UI
 *
 * @see vibe/prd.md 6.7 - Action Deck ìš”êµ¬ì‚¬í•­
 * @see .cursor/rules/10-frontend-game-ui.mdc
 * @module components/ActionDeck
 */

import { useMemo, useCallback, useRef, useState } from 'react';
import { useTranslation } from 'react-i18next';
import type { ActionCard } from '../schemas/turn';
import { useActionDeckStore } from '../stores/actionDeckStore';
import { useWorldStore } from '../stores/worldStore';
import { useAgentStore } from '../stores/agentStore';
import { useEconomyStore } from '../stores/economyStore';

// =============================================================================
// ë“œë˜ê·¸ ìŠ¤í¬ë¡¤ í›… (U-049: ìŠ¤í¬ë¡¤ë°” ìˆ¨ê¸°ê³  ë“œë˜ê·¸ë¡œ ì´ë™)
// U-063-fix: í´ë¦­ê³¼ ë“œë˜ê·¸ë¥¼ êµ¬ë¶„í•˜ì—¬ ì¹´ë“œ í´ë¦­ì´ ì •ìƒ ë™ì‘í•˜ë„ë¡ ìˆ˜ì •
// =============================================================================

/** ë“œë˜ê·¸ë¡œ ì¸ì‹í•  ìµœì†Œ ì´ë™ ê±°ë¦¬ (í”½ì…€) */
const DRAG_THRESHOLD = 5;

function useDragScroll() {
  const containerRef = useRef<HTMLDivElement>(null);
  const [isDragging, setIsDragging] = useState(false);

  // refë¡œ ê´€ë¦¬í•˜ì—¬ ë¶ˆí•„ìš”í•œ ë¦¬ë Œë”ë§ ë°©ì§€
  const isMouseDownRef = useRef(false);
  const startXRef = useRef(0);
  const scrollLeftRef = useRef(0);
  const hasDraggedRef = useRef(false);

  const handleMouseDown = useCallback((e: React.MouseEvent) => {
    if (!containerRef.current) return;
    // mouseDown ì‹œì—ëŠ” isDraggingì„ ì„¤ì •í•˜ì§€ ì•ŠìŒ (í´ë¦­ í—ˆìš©)
    isMouseDownRef.current = true;
    hasDraggedRef.current = false;
    startXRef.current = e.pageX - containerRef.current.offsetLeft;
    scrollLeftRef.current = containerRef.current.scrollLeft;
  }, []);

  const handleMouseMove = useCallback((e: React.MouseEvent) => {
    if (!isMouseDownRef.current || !containerRef.current) return;

    const x = e.pageX - containerRef.current.offsetLeft;
    const distance = Math.abs(x - startXRef.current);

    // ì„ê³„ê°’ì„ ë„˜ì–´ì•¼ ë“œë˜ê·¸ë¡œ ì¸ì‹
    if (distance > DRAG_THRESHOLD) {
      if (!hasDraggedRef.current) {
        hasDraggedRef.current = true;
        setIsDragging(true);
      }
      e.preventDefault();
      const walk = (x - startXRef.current) * 1.5; // ìŠ¤í¬ë¡¤ ì†ë„ ì¡°ì ˆ
      containerRef.current.scrollLeft = scrollLeftRef.current - walk;
    }
  }, []);

  const handleMouseUp = useCallback(() => {
    isMouseDownRef.current = false;
    // ë“œë˜ê·¸ê°€ ë°œìƒí–ˆìœ¼ë©´ ì•½ê°„ì˜ ì§€ì—° í›„ isDragging í•´ì œ (í´ë¦­ ì´ë²¤íŠ¸ ì°¨ë‹¨ ìœ ì§€)
    if (hasDraggedRef.current) {
      setTimeout(() => {
        setIsDragging(false);
        hasDraggedRef.current = false;
      }, 0);
    }
  }, []);

  const handleMouseLeave = useCallback(() => {
    isMouseDownRef.current = false;
    setIsDragging(false);
    hasDraggedRef.current = false;
  }, []);

  return {
    containerRef,
    isDragging,
    handlers: {
      onMouseDown: handleMouseDown,
      onMouseMove: handleMouseMove,
      onMouseUp: handleMouseUp,
      onMouseLeave: handleMouseLeave,
    },
  };
}

// =============================================================================
// ìƒìˆ˜ ì •ì˜ (U-069: QUALITY íŠ¸ë¦¬ê±° ì•¡ì…˜)
// =============================================================================

/**
 * QUALITY ëª¨ë¸ íŠ¸ë¦¬ê±° ì•¡ì…˜ ID ëª©ë¡ (U-069).
 * ë°±ì—”ë“œ TextModelTiering.QUALITY_TRIGGER_ACTION_IDSì™€ ë™ê¸°í™” í•„ìš”.
 * ì´ ëª©ë¡ì— í¬í•¨ëœ ì•¡ì…˜ì€ QUALITY ë°°ì§€ì™€ 2x ë¹„ìš©ì´ í‘œì‹œë©ë‹ˆë‹¤.
 */
const QUALITY_TRIGGER_ACTION_IDS: ReadonlySet<string> = new Set([
  'deep_investigate',
  'ì •ë°€ì¡°ì‚¬',
  'analyze',
  'examine_closely',
  'investigate_detail',
  'scrutinize',
  'thorough_search',
  'use_magnifier',
  'use_magnifying_glass',
]);

/** QUALITY ëª¨ë¸ ë¹„ìš© ë°°ìˆ˜ (U-069: 2x) */
const QUALITY_COST_MULTIPLIER = 2;

/**
 * VISION(ì •ë°€ë¶„ì„) íŠ¸ë¦¬ê±° ì•¡ì…˜ ID ëª©ë¡ (U-076).
 * ë°±ì—”ë“œ TextModelTiering.VISION_TRIGGER_ACTION_IDSì™€ ë™ê¸°í™” í•„ìš”.
 * ì´ ëª©ë¡ì— í¬í•¨ëœ ì•¡ì…˜ì€ VISION ë°°ì§€ì™€ 1.5x ë¹„ìš©ì´ í‘œì‹œë©ë‹ˆë‹¤.
 */
const VISION_TRIGGER_ACTION_IDS: ReadonlySet<string> = new Set([
  'deep_analyze',
  'ì •ë°€ë¶„ì„',
  'analyze_scene',
  'examine_scene',
  'look_closely',
]);

/** VISION ë¹„ìš© ë°°ìˆ˜ (U-076 Q2: 1.5x) */
const VISION_COST_MULTIPLIER = 1.5;

/**
 * U-079: ì¬í™” íšë“ ì•¡ì…˜ ì¹´ë“œ ID ì ‘ë‘ì‚¬.
 * ì´ ì ‘ë‘ì‚¬ë¡œ ì‹œì‘í•˜ëŠ” ì¹´ë“œëŠ” ì¬í™” íšë“ ì¹´ë“œë¡œ í‘œì‹œí•©ë‹ˆë‹¤.
 */
const EARN_ACTION_PREFIX = 'earn_';

// =============================================================================
// íƒ€ì… ì •ì˜
// =============================================================================

export interface ActionDeckProps {
  /** ì¹´ë“œ í´ë¦­ ì½œë°± */
  onCardClick?: (card: ActionCard) => void;
  /** ì „ì²´ ë¹„í™œì„±í™” (ìŠ¤íŠ¸ë¦¬ë° ì¤‘ ë“±, ìƒëµ ì‹œ agentStore.isStreaming ì‚¬ìš©) */
  disabled?: boolean;
}

interface CardDisplayInfo extends ActionCard {
  /** í´ë¼ì´ì–¸íŠ¸ ì¸¡ ì‹¤í–‰ ê°€ëŠ¥ ì—¬ë¶€ (ì„œë²„ enabledê°€ ì—†ì„ ë•Œ í´ë°±) */
  isAffordable: boolean;
  /** ìµœì¢… ë¹„í™œì„±í™” ì—¬ë¶€ */
  isDisabled: boolean;
  /** ìµœì¢… ë¹„í™œì„±í™” ì‚¬ìœ  */
  finalDisabledReason: string | null;
  /** U-069: QUALITY ëª¨ë¸ ì‚¬ìš© ì—¬ë¶€ */
  isQualityAction: boolean;
  /** U-076: VISION(ì •ë°€ë¶„ì„) ì‚¬ìš© ì—¬ë¶€ */
  isVisionAction: boolean;
  /** U-079: ì¬í™” íšë“ ì•¡ì…˜ ì—¬ë¶€ */
  isEarnAction: boolean;
  /** U-069/U-076: ë°°ìˆ˜ ì ìš©ëœ í‘œì‹œ ë¹„ìš© */
  displayCost: { signal: number; memory_shard: number };
}

// =============================================================================
// ê¸°ë³¸ ì¹´ë“œ ìƒì„± (i18n ê¸°ë°˜)
// =============================================================================

/**
 * ê¸°ë³¸ ì¹´ë“œ ìƒì„± (i18n ê¸°ë°˜) - U-065 ë‹¨ìˆœí™”.
 * U-065: description, cost_estimate, hint, reward_hint, disabled_reason í•„ë“œ ì œê±°ë¨
 */
function useDefaultCards(): ActionCard[] {
  const { t } = useTranslation();

  return useMemo(
    () => [
      {
        id: 'default-explore',
        label: t('action.default.explore.label'),
        cost: { signal: 1, memory_shard: 0 },
        risk: 'low' as const,
        enabled: true,
        is_alternative: false,
      },
      {
        id: 'default-investigate',
        label: t('action.default.investigate.label'),
        cost: { signal: 2, memory_shard: 0 },
        risk: 'medium' as const,
        enabled: true,
        is_alternative: false,
      },
      {
        id: 'default-talk',
        label: t('action.default.talk.label'),
        cost: { signal: 1, memory_shard: 0 },
        risk: 'low' as const,
        enabled: true,
        is_alternative: false,
      },
    ],
    [t],
  );
}

// =============================================================================
// ì¹´ë“œ ë¹„ìš© í‘œì‹œ ì»´í¬ë„ŒíŠ¸
// =============================================================================

interface CardCostDisplayProps {
  card: CardDisplayInfo;
}

/**
 * ë¹„ìš© í‘œì‹œ ì»´í¬ë„ŒíŠ¸ - U-065 ë‹¨ìˆœí™”, U-069 QUALITY ë°°ìˆ˜ ì§€ì›.
 * cost_estimate í•„ë“œ ì œê±°ë¨, displayCost(ë°°ìˆ˜ ì ìš©) ì‚¬ìš©
 */
function CardCostDisplay({ card }: CardCostDisplayProps) {
  const { t } = useTranslation();

  // U-069: displayCost ì‚¬ìš© (QUALITY ì•¡ì…˜ì€ 2x ë°°ìˆ˜ ì ìš©ë¨)
  const costDisplay = `${card.displayCost.signal}`;
  const shardCost = card.displayCost.memory_shard;

  return (
    <div className="action-card-cost" data-ui-importance="critical">
      {/* Signal ë¹„ìš© */}
      <span className="cost-item">
        <span className="icon-wrapper" aria-label={t('economy.signal_cost')}>
          <img
            src="/ui/icons/signal-16.png"
            alt=""
            aria-hidden="true"
            className="icon-img"
            style={{ width: 14, height: 14 }}
            onError={(e) => e.currentTarget.classList.add('hidden')}
          />
          <span className="icon-fallback">{'\u26A1'}</span>
        </span>
        <span
          className={`cost-value ${card.isQualityAction ? 'quality-cost' : ''} ${card.isVisionAction ? 'vision-cost' : ''}`}
        >
          {costDisplay}
          {card.isQualityAction && <span className="cost-multiplier">x2</span>}
          {card.isVisionAction && <span className="cost-multiplier">x1.5</span>}
        </span>
      </span>

      {/* Shard ë¹„ìš© (0ë³´ë‹¤ í´ ë•Œë§Œ í‘œì‹œ) */}
      {shardCost > 0 && (
        <span className="cost-item">
          <span className="cost-separator">|</span>
          <span className="icon-wrapper" aria-label={t('economy.shard_cost')}>
            <img
              src="/ui/icons/shard-16.png"
              alt=""
              aria-hidden="true"
              className="icon-img"
              style={{ width: 14, height: 14 }}
              onError={(e) => e.currentTarget.classList.add('hidden')}
            />
            <span className="icon-fallback">{'\u{1F48E}'}</span>
          </span>
          <span
            className={`cost-value ${card.isQualityAction ? 'quality-cost' : ''} ${card.isVisionAction ? 'vision-cost' : ''}`}
          >
            {shardCost}
            {card.isQualityAction && <span className="cost-multiplier">x2</span>}
            {card.isVisionAction && <span className="cost-multiplier">x1.5</span>}
          </span>
        </span>
      )}

      {/* ìœ„í—˜ë„ */}
      <span className="cost-item">
        <span className="cost-separator">|</span>
        <span className="icon-wrapper" aria-label={t('economy.risk_level')}>
          <img
            src={`/ui/icons/risk-${card.risk}-16.png`}
            alt=""
            aria-hidden="true"
            className={`icon-img risk-${card.risk}`}
            style={{ width: 14, height: 14 }}
            onError={(e) => e.currentTarget.classList.add('hidden')}
          />
          <span className="icon-fallback">{'\u26A0'}</span>
        </span>
        <span className={`risk-label risk-${card.risk}`}>{t(`action.risk.${card.risk}`)}</span>
      </span>
    </div>
  );
}

// =============================================================================
// ë‹¨ì¼ ì¹´ë“œ ì»´í¬ë„ŒíŠ¸
// =============================================================================

interface ActionCardItemProps {
  card: CardDisplayInfo;
  onClick: () => void;
  onHover: (card: CardDisplayInfo | null) => void;
  disabled: boolean;
}

/**
 * U-083: ë±ƒì§€ ìµœëŒ€ í‘œì‹œ ê°œìˆ˜ (Q1: Option B - ìµœëŒ€ 2ê°œ + "ì™¸ Nê°œ")
 */
const MAX_VISIBLE_BADGES = 2;

/**
 * ì¹´ë“œì— í‘œì‹œí•  ë±ƒì§€ ëª©ë¡ì„ ìˆ˜ì§‘í•œë‹¤.
 * U-083: ê° ë±ƒì§€ë¥¼ í†µí•© ë°°ì—´ë¡œ ëª¨ì•„ ìµœëŒ€ 2ê°œê¹Œì§€ë§Œ ë Œë”ë§ + ì´ˆê³¼ë¶„ "ì™¸ Nê°œ" í‘œì‹œ.
 */
interface BadgeInfo {
  key: string;
  className: string;
  label: string;
  tooltip: string;
}

function collectBadges(card: CardDisplayInfo, t: (key: string) => string): BadgeInfo[] {
  const badges: BadgeInfo[] = [];

  // U-076: VISION(ì •ë°€ë¶„ì„) ë°°ì§€ (ìµœìš°ì„ )
  if (card.isVisionAction) {
    const label = `\uD83D\uDD0D ${t('action.vision_badge')}`;
    badges.push({
      key: 'vision',
      className: 'badge-vision',
      label,
      tooltip: t('action.vision_badge'),
    });
  }

  // U-069: QUALITY ëª¨ë¸ ë°°ì§€ (VISIONì´ ì•„ë‹ ë•Œ)
  if (!card.isVisionAction && card.isQualityAction) {
    badges.push({
      key: 'quality',
      className: 'badge-quality',
      label: '\u2605 QUALITY',
      tooltip: t('economy.model_label.QUALITY'),
    });
  }

  // U-079: ì¬í™” íšë“ ì¹´ë“œ ë°°ì§€
  if (card.isEarnAction) {
    const label = `\u26A1 ${t('action.earn_badge')}`;
    badges.push({
      key: 'earn',
      className: 'badge-earn',
      label,
      tooltip: t('action.earn_badge'),
    });
  }

  // U-083: ëŒ€ì•ˆ ì¹´ë“œ í‘œì‹œ (ì¡°ê±´ ì™„í™”: ë‹¤ë¥¸ ë±ƒì§€ê°€ ìˆì–´ë„ í‘œì‹œë  ìˆ˜ ìˆë„ë¡ í•¨)
  // ì¬í™” ë¶€ì¡± ë“±ìœ¼ë¡œ 'ëŒ€ì•ˆ'ì´ë©´ì„œ 'QUALITY'ì¼ ìˆ˜ ìˆëŠ” ìƒí™© ì§€ì›
  if (card.is_alternative) {
    badges.push({
      key: 'alt',
      className: 'badge-alternative',
      label: t('action.alternative'),
      tooltip: t('action.alternative'),
    });
  }

  return badges;
}

/**
 * ë‹¨ì¼ ì¹´ë“œ ì»´í¬ë„ŒíŠ¸ - U-065 ë‹¨ìˆœí™”, U-069 QUALITY ë°°ì§€ ì§€ì›.
 * U-083: ë±ƒì§€ë¥¼ ë¹„ìš© ì•„ë˜ ë³„ë„ í–‰ìœ¼ë¡œ ì´ë™, ìµœëŒ€ 2ê°œ + "ì™¸ Nê°œ", ellipsis + íˆ´íŒ
 */
function ActionCardItem({ card, onClick, onHover, disabled }: ActionCardItemProps) {
  const { t } = useTranslation();

  const cardClasses = [
    'action-card',
    'has-chrome',
    card.isDisabled ? 'card-disabled' : '',
    card.is_alternative ? 'card-alternative' : '',
    card.isQualityAction ? 'card-quality' : '',
    card.isVisionAction ? 'card-vision' : '',
    card.isEarnAction ? 'card-earn' : '',
    `risk-border-${card.risk}`,
  ]
    .filter(Boolean)
    .join(' ');

  // U-083: ë±ƒì§€ ìˆ˜ì§‘ ë° ìµœëŒ€ 2ê°œ ì œí•œ
  const allBadges = useMemo(() => collectBadges(card, t), [card, t]);
  const visibleBadges = allBadges.slice(0, MAX_VISIBLE_BADGES);
  const overflowCount = allBadges.length - MAX_VISIBLE_BADGES;

  return (
    <button
      type="button"
      className={cardClasses}
      onClick={onClick}
      onMouseEnter={() => onHover(card)}
      onMouseLeave={() => onHover(null)}
      onFocus={() => onHover(card)}
      onBlur={() => onHover(null)}
      disabled={disabled || card.isDisabled}
      aria-disabled={disabled || card.isDisabled}
      title={card.finalDisabledReason ?? undefined}
    >
      {/* ì¹´ë“œ íƒ€ì´í‹€ */}
      <div className="action-card-title">{card.label}</div>

      {/* ë¹„ìš©/ìœ„í—˜ë„ ì •ë³´ */}
      <CardCostDisplay card={card} />

      {/* U-083: ë±ƒì§€ ì»¨í…Œì´ë„ˆ - ë¹„ìš© ì•„ë˜ ë³„ë„ í–‰ (Q3: Option C) */}
      {allBadges.length > 0 && (
        <div className="action-card-badges">
          {visibleBadges.map((badge) => (
            <span
              key={badge.key}
              className={`action-card-badge ${badge.className}`}
              title={badge.tooltip}
            >
              {badge.label}
            </span>
          ))}
          {/* Q1: Option B - ì´ˆê³¼ë¶„ "ì™¸ Nê°œ" í‘œì‹œ */}
          {overflowCount > 0 && (
            <span
              className="action-card-badge badge-overflow"
              title={allBadges
                .slice(MAX_VISIBLE_BADGES)
                .map((b) => b.label)
                .join(', ')}
            >
              +{overflowCount}
            </span>
          )}
        </div>
      )}

      {/* ë¹„í™œì„±í™” ì˜¤ë²„ë ˆì´ */}
      {card.isDisabled && (
        <div className="card-disabled-overlay">
          <span className="disabled-reason">
            {card.finalDisabledReason ?? t('action.insufficient_balance')}
          </span>
        </div>
      )}
    </button>
  );
}

// =============================================================================
// ë©”ì¸ Action Deck ì»´í¬ë„ŒíŠ¸
// =============================================================================

export function ActionDeck({ onCardClick, disabled: propsDisabled }: ActionDeckProps) {
  const { t } = useTranslation();
  const defaultCards = useDefaultCards();

  // Store ìƒíƒœ (RU-003: ì»´í¬ë„ŒíŠ¸ ë‚´ì—ì„œ ì§ì ‘ êµ¬ë…)
  const cards = useActionDeckStore((state) => state.cards);
  const currentBalance = useWorldStore((state) => state.economy);
  const isStreaming = useAgentStore((state) => state.isStreaming);
  const setCostEstimateFromCard = useEconomyStore((state) => state.setCostEstimateFromCard);
  const setCostEstimate = useEconomyStore((state) => state.setCostEstimate);

  // U-049: ë“œë˜ê·¸ ìŠ¤í¬ë¡¤
  const { containerRef, isDragging, handlers: dragHandlers } = useDragScroll();

  const disabled = propsDisabled ?? isStreaming;

  // ì¹´ë“œ í˜¸ë²„ í•¸ë“¤ëŸ¬ (U-014: ì˜ˆìƒ ë¹„ìš© í‘œì‹œ)
  // U-065: cost_estimate ì œê±°ë¨
  // U-069: displayCost (ë°°ìˆ˜ ì ìš©) ì‚¬ìš©
  const handleCardHover = useCallback(
    (card: CardDisplayInfo | null) => {
      if (card) {
        setCostEstimateFromCard(card.displayCost, null, card.id, card.label);
      } else {
        setCostEstimate(null);
      }
    },
    [setCostEstimateFromCard, setCostEstimate],
  );

  // ì¹´ë“œê°€ ì—†ìœ¼ë©´ ê¸°ë³¸ ì¹´ë“œ ì‚¬ìš©
  const displayCards = cards.length > 0 ? cards : defaultCards;

  // ì¹´ë“œë³„ ì‹¤í–‰ ê°€ëŠ¥ ì—¬ë¶€ ê³„ì‚° (Q1: Option A - ì„œë²„ ìš°ì„ , í´ë¼ì´ì–¸íŠ¸ í´ë°±)
  // U-065: cost_estimate, disabled_reason í•„ë“œ ì œê±°ë¨
  // U-069: QUALITY ëª¨ë¸ íŠ¸ë¦¬ê±° ë° ë¹„ìš© ë°°ìˆ˜ ê³„ì‚° ì¶”ê°€
  const processedCards: CardDisplayInfo[] = useMemo(() => {
    return displayCards.map((card) => {
      // U-079: ì¬í™” íšë“ ì¹´ë“œ ê°ì§€ (earn_ ì ‘ë‘ì‚¬)
      const isEarnAction = card.id.startsWith(EARN_ACTION_PREFIX);

      // U-083: ì ‘ë‘ì‚¬ë¥¼ ì œê±°í•œ ìˆœìˆ˜ ID (VISION/QUALITY ì²´í¬ìš©)
      const baseId = isEarnAction ? card.id.slice(EARN_ACTION_PREFIX.length) : card.id;

      // U-076: VISION(ì •ë°€ë¶„ì„) íŠ¸ë¦¬ê±° ì²´í¬ (QUALITYë³´ë‹¤ ìš°ì„ )
      const isVisionAction =
        VISION_TRIGGER_ACTION_IDS.has(card.id) || VISION_TRIGGER_ACTION_IDS.has(baseId);

      // U-069: QUALITY ëª¨ë¸ íŠ¸ë¦¬ê±° ì²´í¬ (VISIONì´ë©´ QUALITY ì•„ë‹˜)
      const isQualityAction =
        !isVisionAction &&
        (QUALITY_TRIGGER_ACTION_IDS.has(card.id) || QUALITY_TRIGGER_ACTION_IDS.has(baseId));

      // U-069/U-076: ë°°ìˆ˜ ì ìš©ëœ í‘œì‹œ ë¹„ìš© ê³„ì‚°
      const displayCost = isVisionAction
        ? {
            signal: Math.ceil(card.cost.signal * VISION_COST_MULTIPLIER),
            memory_shard: Math.ceil(card.cost.memory_shard * VISION_COST_MULTIPLIER),
          }
        : isQualityAction
          ? {
              signal: card.cost.signal * QUALITY_COST_MULTIPLIER,
              memory_shard: card.cost.memory_shard * QUALITY_COST_MULTIPLIER,
            }
          : { ...card.cost };

      // ì„œë²„ì—ì„œ enabledë¥¼ ëª…ì‹œì ìœ¼ë¡œ falseë¡œ ë³´ëƒˆìœ¼ë©´ ê·¸ëŒ€ë¡œ ì‚¬ìš©
      const serverEnabled = card.enabled;

      // í´ë¼ì´ì–¸íŠ¸ ì¸¡ ì”ì•¡ ì²´í¬ (ì„œë²„ê°€ íŒë‹¨í•˜ì§€ ì•Šì•˜ì„ ë•Œ í´ë°±)
      // U-069: QUALITY ì•¡ì…˜ì€ ë°°ìˆ˜ ì ìš©ëœ ë¹„ìš©ìœ¼ë¡œ ì²´í¬
      const costToCheck = displayCost;
      const isAffordable =
        currentBalance.signal >= costToCheck.signal &&
        currentBalance.memory_shard >= costToCheck.memory_shard;

      // ìµœì¢… ë¹„í™œì„±í™” ì—¬ë¶€: ì„œë²„ íŒë‹¨ ìš°ì„ , ì—†ìœ¼ë©´ í´ë¼ì´ì–¸íŠ¸ íŒë‹¨
      const isDisabled = !serverEnabled || !isAffordable;

      // ë¹„í™œì„±í™” ì‚¬ìœ  ê²°ì • (U-065: disabled_reason ì œê±°ë¨)
      let finalDisabledReason: string | null = null;
      if (!serverEnabled) {
        finalDisabledReason = t('action.server_disabled');
      } else if (!isAffordable) {
        finalDisabledReason = t('action.insufficient_balance');
      }

      return {
        ...card,
        isAffordable,
        isDisabled,
        finalDisabledReason,
        isQualityAction,
        isVisionAction,
        isEarnAction,
        displayCost,
      };
    });
  }, [displayCards, currentBalance, t]);

  // ì¼ë°˜ ì¹´ë“œì™€ ëŒ€ì•ˆ ì¹´ë“œ ë¶„ë¦¬ (ëŒ€ì•ˆ ì¹´ë“œëŠ” ë’¤ì— ë°°ì¹˜)
  const sortedCards = useMemo(() => {
    const regular = processedCards.filter((c) => !c.is_alternative);
    const alternatives = processedCards.filter((c) => c.is_alternative);
    return [...regular, ...alternatives];
  }, [processedCards]);

  return (
    <div
      ref={containerRef}
      className={`action-deck ${isDragging ? 'is-dragging' : ''}`}
      role="group"
      aria-label={t('action.deck_label')}
      {...dragHandlers}
    >
      {sortedCards.map((card) => (
        <ActionCardItem
          key={card.id}
          card={card}
          onClick={() => onCardClick?.(card)}
          onHover={handleCardHover}
          disabled={disabled || isDragging} /* ë“œë˜ê·¸ ì¤‘ í´ë¦­ ë°©ì§€ */
        />
      ))}

      {/* ëª¨ë“  ì¹´ë“œê°€ ë¹„í™œì„±í™”ë˜ì—ˆì„ ë•Œ ì•ˆë‚´ */}
      {sortedCards.every((c) => c.isDisabled) && !disabled && (
        <div className="deck-empty-notice">{t('action.all_disabled_notice')}</div>
      )}
    </div>
  );
}

export default ActionDeck;
</file>

<file path="frontend/src/components/InventoryPanel.tsx">
/**
 * Unknown World - Inventory Panel ì»´í¬ë„ŒíŠ¸ (U-011[Mvp], U-088[Mvp]).
 *
 * dnd-kit ê¸°ë°˜ ë“œë˜ê·¸ ê°€ëŠ¥í•œ ì¸ë²¤í† ë¦¬ ì•„ì´í…œ UIë¥¼ Row(í–‰) í˜•íƒœë¡œ ì œê³µí•©ë‹ˆë‹¤.
 *
 * ì„¤ê³„ ì›ì¹™:
 *   - RULE-002: InventoryëŠ” ê²Œì„ UIë¡œ ìƒì‹œ ë…¸ì¶œ (ì±„íŒ… ì…ë ¥ ëŒ€ì²´ ê¸ˆì§€)
 *   - tech-stack: dnd-kit ê¸°ë°˜ draggable êµ¬í˜„
 *   - U-012 ì—°ê²°: ë“œë˜ê·¸ ë°ì´í„°ì— item_id í¬í•¨í•˜ì—¬ ë“œë¡­ íƒ€ê²Ÿì— ì „ë‹¬
 *
 * U-088[Mvp]: Row í˜•íƒœ ì „í™˜
 *   - Q1: Row 48px, ì•„ì´ì½˜ 32px (ì»´íŒ©íŠ¸)
 *   - Q2: êµ¬ë¶„ì„  + ì¤„ë¬´ëŠ¬ ì¡°í•©
 *   - Q3: Hover íˆ´íŒë§Œ (U-056 ìœ ì§€)
 *   - Q4: ì•„ì´ì½˜ ì˜ì—­ë§Œ ë“œë˜ê·¸ ê°€ëŠ¥, ì•„ì´ì½˜ë§Œ ë“œë˜ê·¸ ì´ë¯¸ì§€
 *
 * U-074[Mvp]: ì•„ì´í…œ ì¸í„°ë™ì…˜ ì•ˆë‚´ UX
 *   - Q1 Option B: ì²« Në²ˆë§Œ hover íŒíŠ¸ í‘œì‹œ (í•™ìŠµ í›„ ì‚¬ë¼ì§)
 *   - hover ì‹œ "ë“œë˜ê·¸í•˜ì—¬ ì‚¬ìš©" íŒíŠ¸ í‘œì‹œ
 *
 * U-075[Mvp]: ì•„ì´í…œ ì•„ì´ì½˜ ë™ì  ìƒì„±
 *   - Q1: Option B (placeholder ë¨¼ì € í‘œì‹œ í›„ ë°±ê·¸ë¼ìš´ë“œ ìƒì„±)
 *   - Q2: Option A (64x64 í”½ì…€)
 *   - Q3: Option A (í”½ì…€ ì•„íŠ¸ ìŠ¤íƒ€ì¼)
 *
 * @module components/InventoryPanel
 */

import { useMemo, useState, useEffect, useRef } from 'react';
import { useDraggable, DragOverlay } from '@dnd-kit/core';
import { CSS } from '@dnd-kit/utilities';
import { useTranslation } from 'react-i18next';
import {
  useInventoryStore,
  type InventoryItem,
  selectItems,
  selectDraggingItem,
  selectConsumingItemIds,
  requestItemIcon,
  pollIconStatus,
} from '../stores/inventoryStore';
import { useOnboardingStore, selectShouldShowItemHint } from '../stores/onboardingStore';
import { useWorldStore } from '../stores/worldStore';
import { useEconomyStore } from '../stores/economyStore';
import { ITEM_SELL_PRICE_SIGNAL } from '../save/constants';
import { InteractionHint } from './InteractionHint';
import { DND_TYPE, type InventoryDragData } from '../dnd/types';

// =============================================================================
// ë“œë˜ê·¸ ê°€ëŠ¥í•œ ì•„ì´í…œ ì»´í¬ë„ŒíŠ¸
// =============================================================================

interface DraggableItemProps {
  item: InventoryItem;
  disabled?: boolean;
  /** U-096: ì†Œë¹„ ì¤‘(fade-out ì§„í–‰ ì¤‘) ì—¬ë¶€ */
  isConsuming?: boolean;
  /** U-088: ì„ íƒ ì—¬ë¶€ */
  isSelected?: boolean;
  /** U-088: ì„ íƒ í•¸ë“¤ëŸ¬ */
  onSelect?: (itemId: string) => void;
  /** U-079: íŒë§¤ ê°€ëŠ¥ ì—¬ë¶€ (ì”ì•¡ ë¶€ì¡± ì‹œ í‘œì‹œ) */
  showSellButton?: boolean;
  /** U-079: íŒë§¤ í•¸ë“¤ëŸ¬ */
  onSell?: (itemId: string, itemName: string) => void;
}

/**
 * ë“œë˜ê·¸ ê°€ëŠ¥í•œ ì¸ë²¤í† ë¦¬ ì•„ì´í…œ.
 * dnd-kitì˜ useDraggable í›…ì„ ì‚¬ìš©í•©ë‹ˆë‹¤.
 * U-056: ì˜ë¦° ì•„ì´í…œ ì´ë¦„ì— ëŒ€í•œ íˆ´íŒ ì§€ì›
 * U-074: ì²« Në²ˆë§Œ hover íŒíŠ¸ í‘œì‹œ
 */
function DraggableItem({
  item,
  disabled = false,
  isConsuming = false,
  isSelected = false,
  onSelect,
  showSellButton = false,
  onSell,
}: DraggableItemProps) {
  const { t } = useTranslation();
  const [isHovered, setIsHovered] = useState(false);

  // U-074: ì•„ì´í…œ íŒíŠ¸ ìƒíƒœ (ì²« Në²ˆë§Œ í‘œì‹œ)
  const shouldShowHint = useOnboardingStore(selectShouldShowItemHint);
  const incrementItemHint = useOnboardingStore((state) => state.incrementItemHint);

  // U-074: hover ì‹œì‘ ì‹œ íŒíŠ¸ ì¹´ìš´íŠ¸ ì¦ê°€
  useEffect(() => {
    if (isHovered && !disabled) {
      incrementItemHint();
    }
  }, [isHovered, disabled, incrementItemHint]);

  // dnd-kit ë“œë˜ê·¸ ì„¤ì • (RU-003-Q1: ìƒìˆ˜/íƒ€ì… ê¸°ë°˜)
  const dragData: InventoryDragData = {
    type: DND_TYPE.INVENTORY_ITEM,
    item_id: item.id,
    item,
  };
  const { attributes, listeners, setNodeRef, transform, isDragging } = useDraggable({
    id: item.id,
    data: dragData,
    disabled,
  });

  // ë³€í™˜ ìŠ¤íƒ€ì¼ ê³„ì‚°
  // ë“œë˜ê·¸ ì¤‘ì¼ ë•ŒëŠ” ì›ë³¸ ì•„ì´í…œì´ ì œìë¦¬ì— ìˆë„ë¡ transform ì ìš©í•˜ì§€ ì•ŠìŒ
  // DragOverlayê°€ ë³„ë„ë¡œ ë Œë”ë§ë˜ë¯€ë¡œ ì›ë³¸ì€ ìœ„ì¹˜ ê³ ì •
  const style = useMemo(
    () => ({
      transform: isDragging ? undefined : CSS.Translate.toString(transform),
      opacity: isDragging ? 0.3 : 1,
    }),
    [transform, isDragging],
  );

  // U-075: ì•„ì´ì½˜ ë Œë”ë§ (ì´ëª¨ì§€ ë˜ëŠ” ì´ë¯¸ì§€, ë¡œë”© ìƒíƒœ í¬í•¨)
  const renderIcon = () => {
    const isLoading = item.iconStatus === 'generating' || item.iconStatus === 'pending';

    if (item.icon) {
      // URL í˜•íƒœë©´ ì´ë¯¸ì§€
      if (item.icon.startsWith('http') || item.icon.startsWith('/')) {
        return (
          <div className="inventory-item-icon-wrapper">
            <img
              src={item.icon}
              alt={item.name}
              className={`inventory-item-icon-img ${isLoading ? 'loading' : ''}`}
              onError={(e) => {
                e.currentTarget.style.display = 'none';
              }}
            />
            {isLoading && <div className="inventory-item-icon-loading" />}
          </div>
        );
      }
      // ì´ëª¨ì§€ + ë¡œë”© ìƒíƒœ (U-075: ì´ëª¨ì§€ì—¬ë„ ìƒì„± ì¤‘ì´ë©´ ìŠ¤í”¼ë„ˆ í‘œì‹œ)
      return (
        <div className="inventory-item-icon-wrapper">
          <span className="inventory-item-icon-emoji">{item.icon}</span>
          {isLoading && <div className="inventory-item-icon-loading" />}
        </div>
      );
    }

    // ê¸°ë³¸ ì•„ì´ì½˜ (ğŸ“¦) + ë¡œë”© ìƒíƒœ
    return (
      <div className="inventory-item-icon-wrapper">
        <span className="inventory-item-icon-emoji">ğŸ“¦</span>
        {isLoading && <div className="inventory-item-icon-loading" />}
      </div>
    );
  };

  return (
    <div
      ref={setNodeRef}
      style={style}
      className={`inventory-item ${isSelected ? 'selected' : ''} ${isDragging ? 'dragging' : ''} ${disabled ? 'disabled' : ''} ${isConsuming ? 'item-consumed' : ''}`}
      onMouseEnter={() => setIsHovered(true)}
      onMouseLeave={() => setIsHovered(false)}
      onClick={() => !disabled && onSelect?.(item.id)}
      aria-label={t('inventory.item_label', { name: item.name, quantity: item.quantity })}
      aria-selected={isSelected}
      // U-056: ë„¤ì´í‹°ë¸Œ íˆ´íŒ (ë‹¨ìˆ˜ëŠ” ì´ë¦„ë§Œ, ë³µìˆ˜ëŠ” "ì´ë¦„ x ê°¯ìˆ˜")
      title={item.quantity > 1 ? `${item.name} x ${item.quantity}` : item.name}
    >
      {/* U-088 Q4: ì•„ì´ì½˜ ì˜ì—­ë§Œ ë“œë˜ê·¸ í•¸ë“¤ */}
      <div className="inventory-item-icon" {...attributes} {...listeners}>
        {renderIcon()}
      </div>
      <div className="inventory-item-info">
        <span className="inventory-item-name">{item.name}</span>
        {item.quantity > 1 && <span className="inventory-item-quantity">x{item.quantity}</span>}
      </div>

      {/* U-079: íŒë§¤ ë²„íŠ¼ (ì”ì•¡ ë¶€ì¡± ì‹œ í‘œì‹œ) */}
      {showSellButton && !disabled && !isDragging && !isConsuming && (
        <button
          type="button"
          className="inventory-sell-btn"
          onClick={(e) => {
            e.stopPropagation();
            onSell?.(item.id, item.name);
          }}
          title={t('inventory.sell_tooltip', { price: ITEM_SELL_PRICE_SIGNAL })}
          aria-label={t('inventory.sell_aria', { item: item.name, price: ITEM_SELL_PRICE_SIGNAL })}
        >
          <span className="sell-icon">{'\u26A1'}</span>
          <span className="sell-price">+{ITEM_SELL_PRICE_SIGNAL}</span>
        </button>
      )}

      {/* U-074: ì²« Në²ˆë§Œ í‘œì‹œë˜ëŠ” ë“œë˜ê·¸ íŒíŠ¸ */}
      {isHovered && !disabled && !isDragging && shouldShowHint && !showSellButton && (
        <InteractionHint
          text={t('interaction.item_drag')}
          icon="drag"
          position="top"
          className="interaction-hint--inventory"
        />
      )}
    </div>
  );
}

// =============================================================================
// ë“œë˜ê·¸ ì˜¤ë²„ë ˆì´ (ë“œë˜ê·¸ ì¤‘ í‘œì‹œë˜ëŠ” ì•„ì´í…œ)
// =============================================================================

interface ItemOverlayProps {
  item: InventoryItem;
}

/**
 * ë“œë˜ê·¸ ì˜¤ë²„ë ˆì´ â€” ì•„ì´ì½˜ë§Œ í‘œì‹œ (U-088 Q4: Option B).
 * ë“œë˜ê·¸ ì¤‘ì¼ ë•Œ ì»¤ì„œë¥¼ ë”°ë¼ë‹¤ë‹ˆëŠ” ì•„ì´ì½˜ì…ë‹ˆë‹¤.
 */
function ItemOverlay({ item }: ItemOverlayProps) {
  const renderIcon = () => {
    if (item.icon) {
      if (item.icon.startsWith('http') || item.icon.startsWith('/')) {
        return <img src={item.icon} alt={item.name} className="inventory-item-icon-img" />;
      }
      return <span className="inventory-item-icon-emoji">{item.icon}</span>;
    }
    return <span className="inventory-item-icon-emoji">ğŸ“¦</span>;
  };

  return (
    <div className="inventory-overlay-icon" title={item.name}>
      {renderIcon()}
    </div>
  );
}

// =============================================================================
// ë©”ì¸ Inventory Panel ì»´í¬ë„ŒíŠ¸
// =============================================================================

interface InventoryPanelProps {
  /** ìƒí˜¸ì‘ìš© ë¹„í™œì„±í™” (ìŠ¤íŠ¸ë¦¬ë° ì¤‘ ë“±) */
  disabled?: boolean;
}

/**
 * Inventory Panel ì»´í¬ë„ŒíŠ¸.
 *
 * U-088: ì¸ë²¤í† ë¦¬ ì•„ì´í…œì„ Row(í–‰) í˜•íƒœë¡œ í‘œì‹œí•©ë‹ˆë‹¤.
 * ì•„ì´ì½˜ ì˜ì—­ë§Œ ë“œë˜ê·¸ í•¸ë“¤(Q4: Option B), DndContextëŠ” App ìµœìƒë‹¨(Q1: Option A).
 *
 * U-075: ì•„ì´í…œ ì¶”ê°€ ì‹œ ì•„ì´ì½˜ ë™ì  ìƒì„± ìš”ì²­
 *
 * @example
 * ```tsx
 * <InventoryPanel disabled={isStreaming} />
 * ```
 */
export function InventoryPanel({ disabled = false }: InventoryPanelProps) {
  const { t, i18n } = useTranslation();

  // Store ìƒíƒœ
  const items = useInventoryStore(selectItems);
  const draggingItem = useInventoryStore(selectDraggingItem);
  const selectedItemId = useInventoryStore((state) => state.selectedItemId);
  const consumingItemIds = useInventoryStore(selectConsumingItemIds);
  const selectItem = useInventoryStore((state) => state.selectItem);
  const updateItemIcon = useInventoryStore((state) => state.updateItemIcon);
  const setItemIconStatus = useInventoryStore((state) => state.setItemIconStatus);

  // U-079: ì”ì•¡ ë¶€ì¡± ì‹œ íŒë§¤ ë²„íŠ¼ í‘œì‹œ
  const isBalanceLow = useEconomyStore((state) => state.isBalanceLow);
  const sellItem = useWorldStore((state) => state.sellItem);

  // U-075: ì•„ì´ì½˜ ìƒì„± ìš”ì²­ ì¶”ì  (ì¤‘ë³µ ìš”ì²­ ë°©ì§€)
  const iconRequestedRef = useRef<Set<string>>(new Set());

  // U-075: ì•„ì´í…œ ì¶”ê°€ ì‹œ ì•„ì´ì½˜ ìƒì„± ìš”ì²­
  useEffect(() => {
    const requestIconsForNewItems = async () => {
      for (const item of items) {
        // ì´ë¯¸ ìš”ì²­í•œ ê²½ìš° ìŠ¤í‚µ
        if (iconRequestedRef.current.has(item.id)) continue;

        // ì´ë¯¸ ì™„ë£Œëœ ì•„ì´ì½˜ì´ ìˆëŠ” ê²½ìš° ìŠ¤í‚µ
        if (item.iconStatus === 'completed' || item.iconStatus === 'cached') continue;

        // URL í˜•íƒœì˜ ì‹¤ì œ ì•„ì´ì½˜ì´ ìˆìœ¼ë©´ ìŠ¤í‚µ (ì´ëª¨ì§€ëŠ” ë¬´ì‹œ)
        const hasRealIcon =
          item.icon &&
          (item.icon.startsWith('http') || item.icon.startsWith('/')) &&
          !item.icon.includes('placeholder');
        if (hasRealIcon) continue;

        // iconStatusê°€ ì—†ê±°ë‚˜ pending/generating/failedì¸ ê²½ìš° ì•„ì´ì½˜ ìƒì„± ì‹œë„
        // (failedì¸ ê²½ìš°ë„ ì¬ì‹œë„ í—ˆìš©)

        // ìš”ì²­ ì¶”ì 
        iconRequestedRef.current.add(item.id);

        // ì•„ì´ì½˜ ìƒì„± ìš”ì²­ (ë¹„ë™ê¸°)
        const description = item.description || item.name;
        const language = i18n.language === 'ko' ? 'ko-KR' : 'en-US';

        setItemIconStatus(item.id, 'generating');

        try {
          const result = await requestItemIcon(item.id, description, language);

          if (result.isPlaceholder) {
            // Placeholder ë°˜í™˜ë¨ - í´ë§ ì‹œì‘
            setItemIconStatus(item.id, 'generating');

            // ë°±ê·¸ë¼ìš´ë“œì—ì„œ í´ë§ (ìµœëŒ€ 30ì´ˆ)
            let attempts = 0;
            const maxAttempts = 15;
            const pollInterval = 2000; // 2ì´ˆ

            const poll = async () => {
              if (attempts >= maxAttempts) {
                setItemIconStatus(item.id, 'failed');
                return;
              }
              attempts++;

              const status = await pollIconStatus(item.id);
              if (status === 'completed' || status === 'cached') {
                // ì™„ë£Œë¨ - ì•„ì´ì½˜ URL ë‹¤ì‹œ ìš”ì²­
                const finalResult = await requestItemIcon(item.id, description, language);
                if (!finalResult.isPlaceholder && finalResult.iconUrl) {
                  updateItemIcon(item.id, finalResult.iconUrl, 'completed');
                }
              } else if (status === 'failed') {
                setItemIconStatus(item.id, 'failed');
              } else {
                // ê³„ì† ìƒì„± ì¤‘ - ë‹¤ì‹œ í´ë§
                setTimeout(poll, pollInterval);
              }
            };

            setTimeout(poll, pollInterval);
          } else if (result.iconUrl) {
            // ì¦‰ì‹œ ì™„ë£Œ (ìºì‹œ)
            updateItemIcon(item.id, result.iconUrl, result.status);
          }
        } catch (error) {
          console.warn(`[InventoryPanel] ì•„ì´ì½˜ ìƒì„± ì‹¤íŒ¨: ${item.id}`, error);
          setItemIconStatus(item.id, 'failed');
        }
      }
    };

    requestIconsForNewItems();
  }, [items, i18n.language, updateItemIcon, setItemIconStatus]);

  // ì•„ì´í…œ ì„ íƒ í•¸ë“¤ëŸ¬ (í† ê¸€ ê¸°ëŠ¥ í¬í•¨)
  const handleSelect = (itemId: string) => {
    selectItem(itemId === selectedItemId ? null : itemId);
  };

  // ë¹ˆ ì¸ë²¤í† ë¦¬ (U-077: Q3 Option B - ì•„ì´í…œ íšë“ íŒíŠ¸ í¬í•¨)
  if (items.length === 0) {
    return (
      <div className="inventory-panel-content">
        <div className="inventory-empty">
          <span className="inventory-empty-icon">ğŸ“¦</span>
          <span className="inventory-empty-text">{t('inventory.empty')}</span>
          <span className="inventory-empty-hint">{t('inventory.empty_hint')}</span>
        </div>
      </div>
    );
  }

  return (
    <div className="inventory-panel-content" data-ui-importance="critical">
      <div
        className="inventory-list"
        role="listbox"
        aria-label={t('inventory.list_label')}
        aria-multiselectable={false}
      >
        {items.map((item) => (
          <DraggableItem
            key={item.id}
            item={item}
            disabled={disabled || consumingItemIds.includes(item.id)}
            isConsuming={consumingItemIds.includes(item.id)}
            isSelected={selectedItemId === item.id}
            onSelect={handleSelect}
            showSellButton={isBalanceLow}
            onSell={sellItem}
          />
        ))}
      </div>

      {/* ë“œë˜ê·¸ ì˜¤ë²„ë ˆì´ */}
      <DragOverlay dropAnimation={null}>
        {draggingItem ? <ItemOverlay item={draggingItem} /> : null}
      </DragOverlay>
    </div>
  );
}

export default InventoryPanel;
</file>

<file path="frontend/src/turn/turnRunner.ts">
/**
 * Unknown World - Turn Runner ëª¨ë“ˆ
 *
 * RU-003-Q3: Turn ì‹¤í–‰/ìŠ¤íŠ¸ë¦¬ë° ê²°í•©ì„ App.tsxì—ì„œ ë¶„ë¦¬í•˜ì—¬
 * "ë ˆì´ì•„ì›ƒ + ì´ë²¤íŠ¸ ë¼ìš°íŒ…"ê³¼ "ì˜¤ì¼€ìŠ¤íŠ¸ë ˆì´ì…˜"ì„ ëª…í™•íˆ ë¶„ë¦¬í•©ë‹ˆë‹¤.
 *
 * ì±…ì„:
 *   - TurnInput ìƒì„± (ì–¸ì–´/í´ë¦­/ë“œë¡­/í´ë¼ì´ì–¸íŠ¸ ì •ë³´/ì¬í™” ìŠ¤ëƒ…ìƒ·)
 *   - ìŠ¤íŠ¸ë¦¼ ì‹œì‘/ì·¨ì†Œ/ì½œë°± ë¼ìš°íŒ…
 *   - agentStore/worldStoreë¡œ ì´ë²¤íŠ¸ ë¶„ë°°
 *
 * ì„¤ê³„ ì›ì¹™:
 *   - RULE-002: ì±„íŒ… ì•±ì´ ì•„ë‹Œ ìƒíƒœ ê¸°ë°˜ ê²Œì„ ì‹œìŠ¤í…œ
 *   - RULE-003/004: êµ¬ì¡°í™” ì¶œë ¥ + ê²€ì¦/ë³µêµ¬
 *   - RULE-006: ko/en i18n ì •ì±… ì¤€ìˆ˜
 *
 * @module turn/turnRunner
 */

import { useCallback, useEffect, useRef } from 'react';
import type { TurnInput, DropInput, Language } from '../schemas/turn';
import type { HotspotClickData } from '../components/SceneCanvas';
import { startTurnStream, type StreamCallbacks } from '../api/turnStream';
import { startImageGeneration, type ImageModelLabel } from '../api/image';
import { useAgentStore } from '../stores/agentStore';
import { useWorldStore } from '../stores/worldStore';

// =============================================================================
// U-089: ì •ë°€ë¶„ì„(Agentic Vision) íŠ¸ë¦¬ê±° ê°ì§€ ìƒìˆ˜
// ë°±ì—”ë“œ config/models.py VISION_TRIGGER_ACTION_IDS / VISION_TRIGGER_KEYWORDSì™€ ë™ê¸°í™”
// =============================================================================

const VISION_TRIGGER_ACTION_IDS = new Set([
  'deep_analyze',
  'ì •ë°€ë¶„ì„',
  'analyze_scene',
  'examine_scene',
  'look_closely',
]);

const VISION_TRIGGER_KEYWORDS = [
  'ì •ë°€ë¶„ì„',
  'ì¥ë©´ ë¶„ì„',
  'ì´ë¯¸ì§€ ë¶„ì„',
  'ìì„¸íˆ ë³´ê¸°',
  'analyze scene',
  'deep analyze',
  'look closely',
  'examine scene',
];

/** U-089: ì •ë°€ë¶„ì„ ì˜¤ë²„ë ˆì´ ìµœì†Œ í‘œì‹œ ì‹œê°„ (ms) - ê¹œë¹¡ì„ ë°©ì§€ */
const ANALYZING_MIN_DISPLAY_MS = 500;

/**
 * U-089: ì •ë°€ë¶„ì„(Agentic Vision) íŠ¸ë¦¬ê±° ì—¬ë¶€ë¥¼ íŒë‹¨í•©ë‹ˆë‹¤.
 * ë°±ì—”ë“œì˜ ModelConfig.is_vision_trigger()ì™€ ë™ì¼í•œ ë¡œì§ì…ë‹ˆë‹¤.
 */
function isVisionTrigger(actionId?: string, text?: string): boolean {
  if (actionId && VISION_TRIGGER_ACTION_IDS.has(actionId)) return true;
  if (text) {
    const textLower = text.toLowerCase();
    for (const keyword of VISION_TRIGGER_KEYWORDS) {
      if (textLower.includes(keyword.toLowerCase())) return true;
    }
  }
  return false;
}

// =============================================================================
// íƒ€ì… ì •ì˜
// =============================================================================

/** TurnInput ìƒì„±ì„ ìœ„í•œ íŒŒë¼ë¯¸í„° */
export interface BuildTurnInputParams {
  /** ì‚¬ìš©ì ì…ë ¥ í…ìŠ¤íŠ¸ */
  text: string;
  /** ì•¡ì…˜ ì¹´ë“œ ID (ì„ íƒ) */
  actionId?: string;
  /** í•«ìŠ¤íŒŸ í´ë¦­ ë°ì´í„° (U-010) */
  click?: HotspotClickData;
  /** ë“œë¡­ ë°ì´í„° (U-012) */
  drop?: DropInput;
  /** ì¬í™” ìŠ¤ëƒ…ìƒ· */
  economySnapshot: { signal: number; memory_shard: number };
  /** UI í…Œë§ˆ */
  theme: 'dark' | 'light';
  /** U-044: ì„¸ì…˜ ì–¸ì–´ (ì™¸ë¶€ ì£¼ì…, SSOT) */
  language: Language;
  /** U-068: ì´ì „ í„´ ì´ë¯¸ì§€ URL (ì°¸ì¡° ì´ë¯¸ì§€ë¡œ ì‚¬ìš©) */
  previousImageUrl?: string | null;
}

/** Turn ì‹¤í–‰ì„ ìœ„í•œ íŒŒë¼ë¯¸í„° (Appì—ì„œ í˜¸ì¶œ ì‹œ ì‚¬ìš©) */
export interface RunTurnParams {
  /** ì‚¬ìš©ì ì…ë ¥ í…ìŠ¤íŠ¸ */
  text: string;
  /** ì•¡ì…˜ ì¹´ë“œ ID (ì„ íƒ) */
  actionId?: string;
  /** í•«ìŠ¤íŒŸ í´ë¦­ ë°ì´í„° (U-010) */
  click?: HotspotClickData;
  /** ë“œë¡­ ë°ì´í„° (U-012) */
  drop?: DropInput;
}

/** Turn Runner ì¸í„°í˜ì´ìŠ¤ */
export interface TurnRunner {
  /** í„´ ì‹¤í–‰ (ìŠ¤íŠ¸ë¦¼ ì‹œì‘) */
  runTurn: (params: RunTurnParams) => void;
  /** ìŠ¤íŠ¸ë¦¼ ì·¨ì†Œ */
  cancel: () => void;
}

// =============================================================================
// TurnInput ìƒì„±
// =============================================================================

/**
 * TurnInputì„ ìƒì„±í•©ë‹ˆë‹¤.
 *
 * U-044: ì–¸ì–´ëŠ” ì™¸ë¶€ì—ì„œ ì£¼ì…ë°›ì•„ SSOT ìœ ì§€ (getResolvedLanguage() ì§ì ‘ í˜¸ì¶œ ì œê±°).
 * í´ë¦­, ë“œë¡­, í´ë¼ì´ì–¸íŠ¸ ì •ë³´, ì¬í™” ìŠ¤ëƒ…ìƒ·ì„ ì¡°í•©í•˜ì—¬
 * ì„œë²„ë¡œ ì „ì†¡í•  TurnInputì„ ìƒì„±í•©ë‹ˆë‹¤.
 */
export function buildTurnInput(params: BuildTurnInputParams): TurnInput {
  const { text, actionId, click, drop, economySnapshot, theme, language, previousImageUrl } =
    params;

  return {
    language,
    text,
    action_id: actionId ?? null,
    // U-010: í•«ìŠ¤íŒŸ í´ë¦­ ë°ì´í„° í¬í•¨ (Q1: Option B)
    click: click
      ? {
          object_id: click.object_id,
          box_2d: click.box_2d,
        }
      : null,
    // U-012: ì•„ì´í…œ ë“œë¡­ ë°ì´í„° í¬í•¨ (Q1: Option B - target_box_2d í¬í•¨)
    drop: drop ?? null,
    client: {
      viewport_w: window.innerWidth,
      viewport_h: window.innerHeight,
      theme,
    },
    economy_snapshot: economySnapshot,
    // U-068: ì´ì „ í„´ ì´ë¯¸ì§€ URL (ì°¸ì¡° ì´ë¯¸ì§€ë¡œ ì‚¬ìš©í•˜ì—¬ ì—°ì†ì„± ìœ ì§€)
    previous_image_url: previousImageUrl ?? null,
  };
}

// =============================================================================
// Turn Runner ìƒì„±
// =============================================================================

/**
 * Turn Runnerë¥¼ ìƒì„±í•©ë‹ˆë‹¤.
 *
 * RU-003-Q3: Appì—ì„œ Turn Runner ì¸ìŠ¤í„´ìŠ¤ë¥¼ ìƒì„±í•˜ì—¬ ì‚¬ìš©í•©ë‹ˆë‹¤.
 * U-044: ì„¸ì…˜ ì–¸ì–´ë¥¼ ì™¸ë¶€ì—ì„œ ì£¼ì…ë°›ì•„ TurnInput ìƒì„± ì‹œ SSOT ìœ ì§€.
 * ìŠ¤íŠ¸ë¦¼ ì½œë°±ì€ agentStoreì™€ worldStoreë¡œ ë¼ìš°íŒ…ë©ë‹ˆë‹¤.
 *
 * @param deps - ì˜ì¡´ì„± (i18n ë²ˆì—­ í•¨ìˆ˜, í…Œë§ˆ, ì„¸ì…˜ ì–¸ì–´)
 * @returns Turn Runner ì¸í„°í˜ì´ìŠ¤
 *
 * @example
 * ```tsx
 * // App.tsxì—ì„œ ì‚¬ìš©
 * const runner = useMemo(() => createTurnRunner({
 *   t,
 *   theme: 'dark',
 *   language: sessionLanguage, // U-044: ì„¸ì…˜ ì–¸ì–´ SSOT
 * }), [t, sessionLanguage]);
 *
 * runner.runTurn({ text: 'hello' });
 * ```
 */
export function createTurnRunner(deps: {
  /** i18n ë²ˆì—­ í•¨ìˆ˜ */
  t: (key: string, options?: Record<string, unknown>) => string;
  /** UI í…Œë§ˆ */
  theme: 'dark' | 'light';
  /** U-044: ì„¸ì…˜ ì–¸ì–´ (SSOT) */
  language: Language;
}): TurnRunner {
  const { t, theme, language } = deps;

  // ì·¨ì†Œ í•¨ìˆ˜ ì €ì¥
  let cancelFn: (() => void) | null = null;

  // U-066: ì´ë¯¸ì§€ ì¡ AbortController
  let imageJobController: AbortController | null = null;

  // U-080: ì´ë¯¸ì§€ ìƒì„± ìš”ì²­ ì¤‘ë³µ ë°©ì§€ (StrictMode ëŒ€ì‘)
  let imageJobPending = false;

  // U-089: ì •ë°€ë¶„ì„ ì˜¤ë²„ë ˆì´ ìµœì†Œ í‘œì‹œ ì‹œê°„ ê´€ë¦¬
  let analyzingStartTime = 0;

  /**
   * í„´ì„ ì‹¤í–‰í•©ë‹ˆë‹¤.
   */
  const runTurn = (params: RunTurnParams): void => {
    // ìŠ¤íŠ¸ë¦¬ë° ì¤‘ì´ë©´ ë¬´ì‹œ
    const isStreaming = useAgentStore.getState().isStreaming;
    if (isStreaming) return;

    // Store ì•¡ì…˜ ê°€ì ¸ì˜¤ê¸° (í´ë¡œì € ì™¸ë¶€ì—ì„œ í˜¸ì¶œ ì‹œì ì— ìµœì‹  ìƒíƒœ ì°¸ì¡°)
    const agentStore = useAgentStore.getState();
    const worldStore = useWorldStore.getState();

    // U-089: ì •ë°€ë¶„ì„ íŠ¸ë¦¬ê±° ê°ì§€
    const visionAnalysis = isVisionTrigger(params.actionId, params.text);

    /**
     * U-089: ë¶„ì„ ìƒíƒœë¥¼ í•´ì œí•©ë‹ˆë‹¤.
     * ìµœì†Œ í‘œì‹œ ì‹œê°„(500ms)ì„ ë³´ì¥í•˜ì—¬ ì˜¤ë²„ë ˆì´ ê¹œë¹¡ì„ì„ ë°©ì§€í•©ë‹ˆë‹¤.
     */
    const finishAnalyzing = () => {
      const elapsed = Date.now() - analyzingStartTime;
      const remaining = ANALYZING_MIN_DISPLAY_MS - elapsed;
      if (remaining > 0) {
        setTimeout(() => {
          useWorldStore.getState().setIsAnalyzing(false);
        }, remaining);
      } else {
        useWorldStore.getState().setIsAnalyzing(false);
      }
    };

    // ì¬í™” ìŠ¤ëƒ…ìƒ· ê°€ì ¸ì˜¤ê¸°
    const economySnapshot = worldStore.economy;

    // U-068: ì´ì „ ì´ë¯¸ì§€ URL ê°€ì ¸ì˜¤ê¸° (ì°¸ì¡° ì´ë¯¸ì§€ë¡œ ì‚¬ìš©)
    const previousImageUrl =
      worldStore.sceneState.imageUrl ?? worldStore.sceneState.previousImageUrl;

    // TurnInput ìƒì„± (U-044: ì£¼ì…ëœ ì„¸ì…˜ ì–¸ì–´ ì‚¬ìš©)
    const turnInput = buildTurnInput({
      text:
        params.text ||
        (params.actionId ? t('action.card_select', { cardId: params.actionId }) : ''),
      actionId: params.actionId,
      click: params.click,
      drop: params.drop,
      economySnapshot,
      theme,
      language,
      previousImageUrl,
    });

    // Agent Store ì‹œì‘
    agentStore.startStream();

    // U-089: ì •ë°€ë¶„ì„ ì‹œ isAnalyzing í™œì„±í™” (ê¸°ì¡´ ì´ë¯¸ì§€ ìœ ì§€ + ë¶„ì„ ì˜¤ë²„ë ˆì´)
    if (visionAnalysis) {
      worldStore.setIsAnalyzing(true);
      analyzingStartTime = Date.now();
    }

    // U-071: ì²˜ë¦¬ ë‹¨ê³„ë¥¼ 'processing'ìœ¼ë¡œ ì „í™˜
    worldStore.setProcessingPhase('processing');

    // U-089: ì •ë°€ë¶„ì„ ì‹œ Scene ìƒíƒœë¥¼ ë³€ê²½í•˜ì§€ ì•ŠìŒ (ê¸°ì¡´ ì´ë¯¸ì§€ ìœ ì§€)
    // ì¼ë°˜ í„´: Scene Canvasë¥¼ ë¡œë”© ìƒíƒœë¡œ ì „í™˜ (U-031)
    if (!visionAnalysis) {
      worldStore.setSceneState({ status: 'loading', message: t('scene.status.syncing') });
    }

    // ìŠ¤íŠ¸ë¦¼ ì½œë°± ì„¤ì • (RU-003-Q3: agentStore + worldStoreë¡œ ë¼ìš°íŒ…)
    // RU-003-T1: sceneState ì „ì´ëŠ” worldStore.applyTurnOutputì—ì„œ SSOTë¡œ ì²˜ë¦¬
    const callbacks: StreamCallbacks = {
      // Stage/Badges/NarrativeDelta â†’ agentStoreë¡œë§Œ ì „ë‹¬
      onStage: (event) => {
        useAgentStore.getState().handleStage(event);
      },
      onBadges: (event) => {
        useAgentStore.getState().handleBadges(event);
      },
      onNarrativeDelta: (event) => {
        useAgentStore.getState().handleNarrativeDelta(event);
      },
      // Final â†’ agentStore.handleFinal + worldStore.applyTurnOutput + U-066 ì´ë¯¸ì§€ ì¡
      onFinal: (event) => {
        useAgentStore.getState().handleFinal(event);
        // U-071: ê²°ê³¼ ë Œë”ë§ ë‹¨ê³„ë¡œ ì „í™˜
        useWorldStore.getState().setProcessingPhase('rendering');
        // RU-003-Q4: TurnOutput ë°˜ì˜ SSOT
        useWorldStore.getState().applyTurnOutput(event.data);
        // RU-003-S1: ì„±ê³µì ì¸ final ìˆ˜ì‹  ì‹œ ì—°ê²° ìƒíƒœ ë‚™ê´€ì  ë³µêµ¬
        useWorldStore.getState().setConnected(true);

        // U-066: ì´ë¯¸ì§€ ì¡ ë¹„ë™ê¸° ì‹¤í–‰ (í„´ê³¼ ë¶„ë¦¬)
        // U-080: StrictMode ëŒ€ì‘ - ì¤‘ë³µ ìš”ì²­ ë°©ì§€
        const imageJob = event.data.render?.image_job;
        if (imageJob?.should_generate && imageJob.prompt) {
          // U-071: ì´ë¯¸ì§€ ìƒì„± ëŒ€ê¸° ë‹¨ê³„ë¡œ ì „í™˜
          useWorldStore.getState().setProcessingPhase('image_pending');
          // ì´ë¯¸ ì´ë¯¸ì§€ ìƒì„± ìš”ì²­ì´ ì§„í–‰ ì¤‘ì´ë©´ ë¬´ì‹œ (StrictMode ì¤‘ë³µ ë°©ì§€)
          if (imageJobPending) {
            return;
          }
          imageJobPending = true;

          const worldStore = useWorldStore.getState();
          const currentTurnId = worldStore.turnCount;

          // U-068: ì´ì „ ì¥ë©´ ì´ë¯¸ì§€ URL ê°€ì ¸ì˜¤ê¸° (ì°¸ì¡° ì´ë¯¸ì§€ë¡œ ì‚¬ìš©)
          // Q1 ê²°ì •: í•­ìƒ ì´ì „ ì´ë¯¸ì§€ë¥¼ ì°¸ì¡°ë¡œ ì‚¬ìš© (ì—°ì†ì„± ìµœëŒ€í™”)
          const previousImageUrl =
            worldStore.sceneState.imageUrl ?? worldStore.sceneState.previousImageUrl;

          // ì´ì „ ì´ë¯¸ì§€ ì¡ ì·¨ì†Œ
          imageJobController?.abort();

          // ì´ë¯¸ì§€ ë¡œë”© ìƒíƒœë¡œ ì „í™˜
          worldStore.setImageLoading(currentTurnId);

          // ëª¨ë¸ ë¼ë²¨ ê²°ì • (U-066 Q2/Q3: time budget ê¸°ë°˜ + í”„ë¦¬ë·°â†’ìµœì¢… ì—…ê·¸ë ˆì´ë“œ)
          // TODO: Key scene íŒë³„ ë¡œì§ ì¶”ê°€ (í˜„ì¬ëŠ” ê¸°ë³¸ QUALITY)
          const modelLabel: ImageModelLabel = imageJob.model_label === 'FAST' ? 'FAST' : 'QUALITY';

          // ì´ë¯¸ì§€ ìƒì„± ì‹œì‘
          // U-068: Q2 ê²°ì • - FAST ëª¨ë¸ì—ì„œë„ 1ì¥ ì œí•œìœ¼ë¡œ ì°¸ì¡° ì´ë¯¸ì§€ ì‚¬ìš©
          imageJobController = startImageGeneration(
            {
              prompt: imageJob.prompt,
              language,
              aspectRatio: imageJob.aspect_ratio ?? '16:9',
              modelLabel,
              turnId: currentTurnId,
              referenceImageUrl: previousImageUrl,
            },
            (response) => {
              imageJobPending = false; // ì™„ë£Œ ì‹œ í”Œë˜ê·¸ í•´ì œ
              // ì„±ê³µ/ì‹¤íŒ¨ ëª¨ë‘ ì²˜ë¦¬
              if (response.success && response.imageUrl && response.turnId !== undefined) {
                // late-binding ê°€ë“œ: turnIdê°€ ì¼ì¹˜í•  ë•Œë§Œ ì ìš©
                useWorldStore.getState().applyLateBindingImage(response.imageUrl, response.turnId);
              } else {
                // ì‹¤íŒ¨ ì‹œ ë¡œë”© ì·¨ì†Œ (ì´ì „ ì´ë¯¸ì§€ ìœ ì§€)
                useWorldStore.getState().cancelImageLoading();
              }
              // U-071: ì´ë¯¸ì§€ ìƒì„± ì™„ë£Œ í›„ idleë¡œ ì „í™˜
              useWorldStore.getState().setProcessingPhase('idle');
            },
            () => {
              imageJobPending = false; // ì—ëŸ¬ ì‹œ í”Œë˜ê·¸ í•´ì œ
              // ì—ëŸ¬ ì‹œ ë¡œë”© ì·¨ì†Œ
              useWorldStore.getState().cancelImageLoading();
              // U-071: ì—ëŸ¬ ì‹œì—ë„ idleë¡œ ì „í™˜
              useWorldStore.getState().setProcessingPhase('idle');
            },
          );
        }
      },
      // Error â†’ agentStore.handleError + worldStore ìƒíƒœ ë³µêµ¬
      onError: (event) => {
        useAgentStore.getState().handleError(event);
        useWorldStore.getState().setConnected(false);
        // U-071: ì—ëŸ¬ ì‹œ idleë¡œ ì „í™˜
        useWorldStore.getState().setProcessingPhase('idle');
        // U-089: ì—ëŸ¬ ì‹œ ë¶„ì„ ìƒíƒœ í•´ì œ (ìµœì†Œ í‘œì‹œ ì‹œê°„ ì ìš©)
        if (visionAnalysis) {
          finishAnalyzing();
        }
        // Scene Canvasë¥¼ ì˜¤í”„ë¼ì¸/ì—ëŸ¬ ìƒíƒœë¡œ ì „í™˜ (U-031)
        const errorCode = event.code;
        if (errorCode === 'SAFETY_BLOCKED') {
          useWorldStore.getState().setSceneState({ status: 'blocked', message: event.message });
        } else if (errorCode === 'INSUFFICIENT_BALANCE') {
          useWorldStore.getState().setSceneState({ status: 'low_signal', message: event.message });
        } else {
          useWorldStore.getState().setSceneState({ status: 'offline', message: event.message });
        }
      },
      // Complete â†’ agentStore.completeStream
      // RU-003-T1: sceneState ì „ì´ëŠ” worldStore.applyTurnOutputì—ì„œ SSOTë¡œ ì²˜ë¦¬
      // - ì„±ê³µ ì‹œ: onFinal â†’ applyTurnOutputì—ì„œ ui.scene.image_url ê¸°ë°˜ìœ¼ë¡œ ì„¤ì •
      // - ì—ëŸ¬ ì‹œ: onErrorì—ì„œ ì´ë¯¸ offline/blocked/low_signalìœ¼ë¡œ ì„¤ì •ë¨
      onComplete: () => {
        useAgentStore.getState().completeStream();
        // RU-003-T1: sceneStateëŠ” applyTurnOutput(ì„±ê³µ) ë˜ëŠ” onError(ì‹¤íŒ¨)ì—ì„œ ì´ë¯¸ ì„¤ì •ë¨
        // ì—¬ê¸°ì„œ ì¶”ê°€ë¡œ ì„¤ì •í•˜ë©´ applyTurnOutputì˜ ì„¤ì •ì„ ë®ì–´ì“°ê²Œ ë˜ë¯€ë¡œ ì œê±°

        // U-071: ì´ë¯¸ì§€ ì¡ì´ ì—†ëŠ” ê²½ìš°ì—ë§Œ idleë¡œ ì „í™˜
        // ì´ë¯¸ì§€ ì¡ì´ ìˆìœ¼ë©´ ì´ë¯¸ì§€ ìƒì„± ì™„ë£Œ/ì‹¤íŒ¨ ì‹œ idleë¡œ ì „í™˜ë¨
        if (!imageJobPending) {
          useWorldStore.getState().setProcessingPhase('idle');
        }

        // U-089: í„´ ì™„ë£Œ ì‹œ ë¶„ì„ ìƒíƒœ í•´ì œ (ìµœì†Œ í‘œì‹œ ì‹œê°„ ì ìš©)
        if (visionAnalysis) {
          finishAnalyzing();
        }
      },
    };

    // ìŠ¤íŠ¸ë¦¼ ì‹œì‘
    cancelFn = startTurnStream(turnInput, callbacks);
  };

  /**
   * ìŠ¤íŠ¸ë¦¼ì„ ì·¨ì†Œí•©ë‹ˆë‹¤.
   *
   * ì¶”í›„ Cancel/Pause/Autopilot UXë¥¼ ìœ„í•œ ê¸°ë³¸ ê³¨ê²©ì…ë‹ˆë‹¤.
   * í˜„ì¬ executeTurnStreamì€ Abort ì‹œ onCompleteë¥¼ í˜¸ì¶œí•˜ì§€ ì•Šìœ¼ë¯€ë¡œ,
   * Cancel ë²„íŠ¼ì„ ë„£ì„ ê³„íšì´ë¼ë©´ "ì·¨ì†Œ ì‹œ UI ë³µêµ¬ ì •ì±…"ì„ ë³„ë„ë¡œ ëª…ì‹œí•´ì•¼ í•©ë‹ˆë‹¤.
   */
  const cancel = (): void => {
    cancelFn?.();
    cancelFn = null;
  };

  return {
    runTurn,
    cancel,
  };
}

// =============================================================================
// React Hook (ì„ íƒì  ì‚¬ìš©)
// =============================================================================

/**
 * Turn Runnerë¥¼ React ì»´í¬ë„ŒíŠ¸ì—ì„œ ì‚¬ìš©í•˜ê¸° ìœ„í•œ í›….
 *
 * U-044: ì„¸ì…˜ ì–¸ì–´ë¥¼ ì™¸ë¶€ì—ì„œ ì£¼ì…ë°›ì•„ TurnInput ìƒì„± ì‹œ SSOT ìœ ì§€.
 *
 * @param deps - ì˜ì¡´ì„± (i18n ë²ˆì—­ í•¨ìˆ˜, í…Œë§ˆ, ì„¸ì…˜ ì–¸ì–´)
 * @returns Turn Runner ì¸í„°í˜ì´ìŠ¤ ë° ì·¨ì†Œ íš¨ê³¼
 *
 * @example
 * ```tsx
 * // ì»´í¬ë„ŒíŠ¸ì—ì„œ ì‚¬ìš©
 * const { runTurn, cancel } = useTurnRunner({
 *   t,
 *   theme: 'dark',
 *   language: sessionLanguage, // U-044: ì„¸ì…˜ ì–¸ì–´ SSOT
 * });
 * ```
 */

export function useTurnRunner(deps: {
  t: (key: string, options?: Record<string, unknown>) => string;
  theme: 'dark' | 'light';
  /** U-044: ì„¸ì…˜ ì–¸ì–´ (SSOT) */
  language: Language;
}): TurnRunner {
  const { t, theme, language } = deps;

  // ì·¨ì†Œ í•¨ìˆ˜ ì €ì¥ ref
  const cancelFnRef = useRef<(() => void) | null>(null);

  // U-066: ì´ë¯¸ì§€ ì¡ AbortController ref
  const imageJobControllerRef = useRef<AbortController | null>(null);

  // U-080: ì´ë¯¸ì§€ ìƒì„± ìš”ì²­ ì¤‘ë³µ ë°©ì§€ (StrictMode ëŒ€ì‘)
  const imageJobPendingRef = useRef<boolean>(false);

  // U-089: ì •ë°€ë¶„ì„ ì˜¤ë²„ë ˆì´ ìµœì†Œ í‘œì‹œ ì‹œê°„ ê´€ë¦¬
  const analyzingStartTimeRef = useRef<number>(0);

  // runTurnì„ useCallbackìœ¼ë¡œ ì •ì˜
  const runTurn = useCallback(
    (params: RunTurnParams): void => {
      // ìŠ¤íŠ¸ë¦¬ë° ì¤‘ì´ë©´ ë¬´ì‹œ
      const isStreaming = useAgentStore.getState().isStreaming;
      if (isStreaming) return;

      // Store ì•¡ì…˜ ê°€ì ¸ì˜¤ê¸°
      const agentStore = useAgentStore.getState();
      const worldStore = useWorldStore.getState();

      // U-089: ì •ë°€ë¶„ì„ íŠ¸ë¦¬ê±° ê°ì§€
      const visionAnalysis = isVisionTrigger(params.actionId, params.text);

      /**
       * U-089: ë¶„ì„ ìƒíƒœë¥¼ í•´ì œí•©ë‹ˆë‹¤.
       * ìµœì†Œ í‘œì‹œ ì‹œê°„(500ms)ì„ ë³´ì¥í•˜ì—¬ ì˜¤ë²„ë ˆì´ ê¹œë¹¡ì„ì„ ë°©ì§€í•©ë‹ˆë‹¤.
       */
      const finishAnalyzing = () => {
        const elapsed = Date.now() - analyzingStartTimeRef.current;
        const remaining = ANALYZING_MIN_DISPLAY_MS - elapsed;
        if (remaining > 0) {
          setTimeout(() => {
            useWorldStore.getState().setIsAnalyzing(false);
          }, remaining);
        } else {
          useWorldStore.getState().setIsAnalyzing(false);
        }
      };

      // ì¬í™” ìŠ¤ëƒ…ìƒ· ê°€ì ¸ì˜¤ê¸°
      const economySnapshot = worldStore.economy;

      // U-068: ì´ì „ ì´ë¯¸ì§€ URL ê°€ì ¸ì˜¤ê¸° (ì°¸ì¡° ì´ë¯¸ì§€ë¡œ ì‚¬ìš©)
      const previousImageUrl =
        worldStore.sceneState.imageUrl ?? worldStore.sceneState.previousImageUrl;

      // TurnInput ìƒì„± (U-044: ì£¼ì…ëœ ì„¸ì…˜ ì–¸ì–´ ì‚¬ìš©)
      const turnInput = buildTurnInput({
        text:
          params.text ||
          (params.actionId ? t('action.card_select', { cardId: params.actionId }) : ''),
        actionId: params.actionId,
        click: params.click,
        drop: params.drop,
        economySnapshot,
        theme,
        language,
        previousImageUrl,
      });

      // Agent Store ì‹œì‘
      agentStore.startStream();

      // U-089: ì •ë°€ë¶„ì„ ì‹œ isAnalyzing í™œì„±í™” (ê¸°ì¡´ ì´ë¯¸ì§€ ìœ ì§€ + ë¶„ì„ ì˜¤ë²„ë ˆì´)
      if (visionAnalysis) {
        worldStore.setIsAnalyzing(true);
        analyzingStartTimeRef.current = Date.now();
      }

      // U-071: ì²˜ë¦¬ ë‹¨ê³„ë¥¼ 'processing'ìœ¼ë¡œ ì „í™˜
      worldStore.setProcessingPhase('processing');

      // U-089: ì •ë°€ë¶„ì„ ì‹œ Scene ìƒíƒœë¥¼ ë³€ê²½í•˜ì§€ ì•ŠìŒ (ê¸°ì¡´ ì´ë¯¸ì§€ ìœ ì§€)
      // ì¼ë°˜ í„´: Scene Canvasë¥¼ ë¡œë”© ìƒíƒœë¡œ ì „í™˜ (U-031)
      if (!visionAnalysis) {
        worldStore.setSceneState({ status: 'loading', message: t('scene.status.syncing') });
      }

      // ìŠ¤íŠ¸ë¦¼ ì½œë°± ì„¤ì • (RU-003-Q3: agentStore + worldStoreë¡œ ë¼ìš°íŒ…)
      // RU-003-T1: sceneState ì „ì´ëŠ” worldStore.applyTurnOutputì—ì„œ SSOTë¡œ ì²˜ë¦¬
      const callbacks: StreamCallbacks = {
        onStage: (event) => {
          useAgentStore.getState().handleStage(event);
        },
        onBadges: (event) => {
          useAgentStore.getState().handleBadges(event);
        },
        onNarrativeDelta: (event) => {
          useAgentStore.getState().handleNarrativeDelta(event);
        },
        onFinal: (event) => {
          useAgentStore.getState().handleFinal(event);
          // U-071: ê²°ê³¼ ë Œë”ë§ ë‹¨ê³„ë¡œ ì „í™˜
          useWorldStore.getState().setProcessingPhase('rendering');
          useWorldStore.getState().applyTurnOutput(event.data);
          // RU-003-S1: ì„±ê³µì ì¸ final ìˆ˜ì‹  ì‹œ ì—°ê²° ìƒíƒœ ë‚™ê´€ì  ë³µêµ¬
          useWorldStore.getState().setConnected(true);

          // U-066: ì´ë¯¸ì§€ ì¡ ë¹„ë™ê¸° ì‹¤í–‰ (í„´ê³¼ ë¶„ë¦¬)
          // U-080: StrictMode ëŒ€ì‘ - ì¤‘ë³µ ìš”ì²­ ë°©ì§€
          const imageJob = event.data.render?.image_job;
          if (imageJob?.should_generate && imageJob.prompt) {
            // ì´ë¯¸ ì´ë¯¸ì§€ ìƒì„± ìš”ì²­ì´ ì§„í–‰ ì¤‘ì´ë©´ ë¬´ì‹œ (StrictMode ì¤‘ë³µ ë°©ì§€)
            if (imageJobPendingRef.current) {
              return;
            }
            imageJobPendingRef.current = true;

            // U-071: ì´ë¯¸ì§€ ìƒì„± ëŒ€ê¸° ë‹¨ê³„ë¡œ ì „í™˜
            useWorldStore.getState().setProcessingPhase('image_pending');

            const worldStore = useWorldStore.getState();
            const currentTurnId = worldStore.turnCount;

            // U-068: ì´ì „ ì¥ë©´ ì´ë¯¸ì§€ URL ê°€ì ¸ì˜¤ê¸° (ì°¸ì¡° ì´ë¯¸ì§€ë¡œ ì‚¬ìš©)
            // Q1 ê²°ì •: í•­ìƒ ì´ì „ ì´ë¯¸ì§€ë¥¼ ì°¸ì¡°ë¡œ ì‚¬ìš© (ì—°ì†ì„± ìµœëŒ€í™”)
            const previousImageUrl =
              worldStore.sceneState.imageUrl ?? worldStore.sceneState.previousImageUrl;

            // ì´ì „ ì´ë¯¸ì§€ ì¡ ì·¨ì†Œ
            imageJobControllerRef.current?.abort();

            // ì´ë¯¸ì§€ ë¡œë”© ìƒíƒœë¡œ ì „í™˜
            worldStore.setImageLoading(currentTurnId);

            // ëª¨ë¸ ë¼ë²¨ ê²°ì •
            const modelLabel: ImageModelLabel =
              imageJob.model_label === 'FAST' ? 'FAST' : 'QUALITY';

            // ì´ë¯¸ì§€ ìƒì„± ì‹œì‘
            // U-068: Q2 ê²°ì • - FAST ëª¨ë¸ì—ì„œë„ 1ì¥ ì œí•œìœ¼ë¡œ ì°¸ì¡° ì´ë¯¸ì§€ ì‚¬ìš©
            imageJobControllerRef.current = startImageGeneration(
              {
                prompt: imageJob.prompt,
                language,
                aspectRatio: imageJob.aspect_ratio ?? '16:9',
                modelLabel,
                turnId: currentTurnId,
                referenceImageUrl: previousImageUrl,
              },
              (response) => {
                imageJobPendingRef.current = false; // ì™„ë£Œ ì‹œ í”Œë˜ê·¸ í•´ì œ
                if (response.success && response.imageUrl && response.turnId !== undefined) {
                  useWorldStore
                    .getState()
                    .applyLateBindingImage(response.imageUrl, response.turnId);
                } else {
                  useWorldStore.getState().cancelImageLoading();
                }
                // U-071: ì´ë¯¸ì§€ ìƒì„± ì™„ë£Œ í›„ idleë¡œ ì „í™˜
                useWorldStore.getState().setProcessingPhase('idle');
              },
              () => {
                imageJobPendingRef.current = false; // ì—ëŸ¬ ì‹œ í”Œë˜ê·¸ í•´ì œ
                useWorldStore.getState().cancelImageLoading();
                // U-071: ì—ëŸ¬ ì‹œì—ë„ idleë¡œ ì „í™˜
                useWorldStore.getState().setProcessingPhase('idle');
              },
            );
          }
        },
        onError: (event) => {
          useAgentStore.getState().handleError(event);
          useWorldStore.getState().setConnected(false);
          // U-071: ì—ëŸ¬ ì‹œ idleë¡œ ì „í™˜
          useWorldStore.getState().setProcessingPhase('idle');
          // U-089: ì—ëŸ¬ ì‹œ ë¶„ì„ ìƒíƒœ í•´ì œ (ìµœì†Œ í‘œì‹œ ì‹œê°„ ì ìš©)
          if (visionAnalysis) {
            finishAnalyzing();
          }
          // Scene Canvasë¥¼ ì˜¤í”„ë¼ì¸/ì—ëŸ¬ ìƒíƒœë¡œ ì „í™˜ (U-031)
          const errorCode = event.code;
          if (errorCode === 'SAFETY_BLOCKED') {
            useWorldStore.getState().setSceneState({ status: 'blocked', message: event.message });
          } else if (errorCode === 'INSUFFICIENT_BALANCE') {
            useWorldStore
              .getState()
              .setSceneState({ status: 'low_signal', message: event.message });
          } else {
            useWorldStore.getState().setSceneState({ status: 'offline', message: event.message });
          }
        },
        // Complete â†’ agentStore.completeStream
        // RU-003-T1: sceneState ì „ì´ëŠ” worldStore.applyTurnOutputì—ì„œ SSOTë¡œ ì²˜ë¦¬
        // - ì„±ê³µ ì‹œ: onFinal â†’ applyTurnOutputì—ì„œ ui.scene.image_url ê¸°ë°˜ìœ¼ë¡œ ì„¤ì •
        // - ì—ëŸ¬ ì‹œ: onErrorì—ì„œ ì´ë¯¸ offline/blocked/low_signalìœ¼ë¡œ ì„¤ì •ë¨
        onComplete: () => {
          useAgentStore.getState().completeStream();
          // RU-003-T1: sceneStateëŠ” applyTurnOutput(ì„±ê³µ) ë˜ëŠ” onError(ì‹¤íŒ¨)ì—ì„œ ì´ë¯¸ ì„¤ì •ë¨
          // ì—¬ê¸°ì„œ ì¶”ê°€ë¡œ ì„¤ì •í•˜ë©´ applyTurnOutputì˜ ì„¤ì •ì„ ë®ì–´ì“°ê²Œ ë˜ë¯€ë¡œ ì œê±°

          // U-071: ì´ë¯¸ì§€ ì¡ì´ ì—†ëŠ” ê²½ìš°ì—ë§Œ idleë¡œ ì „í™˜
          // ì´ë¯¸ì§€ ì¡ì´ ìˆìœ¼ë©´ ì´ë¯¸ì§€ ìƒì„± ì™„ë£Œ/ì‹¤íŒ¨ ì‹œ idleë¡œ ì „í™˜ë¨
          if (!imageJobPendingRef.current) {
            useWorldStore.getState().setProcessingPhase('idle');
          }

          // U-089: í„´ ì™„ë£Œ ì‹œ ë¶„ì„ ìƒíƒœ í•´ì œ (ìµœì†Œ í‘œì‹œ ì‹œê°„ ì ìš©)
          if (visionAnalysis) {
            finishAnalyzing();
          }
        },
      };

      // ìŠ¤íŠ¸ë¦¼ ì‹œì‘ ë° ì·¨ì†Œ í•¨ìˆ˜ ì €ì¥
      cancelFnRef.current = startTurnStream(turnInput, callbacks);
    },
    [t, theme, language],
  );

  // cancel í•¨ìˆ˜
  const cancel = useCallback((): void => {
    cancelFnRef.current?.();
    cancelFnRef.current = null;
  }, []);

  // ì»´í¬ë„ŒíŠ¸ ì–¸ë§ˆìš´íŠ¸ ì‹œ ìŠ¤íŠ¸ë¦¼ ë° ì´ë¯¸ì§€ ì¡ ì·¨ì†Œ
  useEffect(() => {
    return () => {
      cancelFnRef.current?.();
      imageJobControllerRef.current?.abort();
    };
  }, []);

  return { runTurn, cancel };
}
</file>

<file path="backend/pyproject.toml">
# backend/pyproject.toml
# SSOT: vibe/tech-stack.md (ë²„ì „ ê¸°ì¤€ì¼: 2026-01-01)

[build-system]
requires = ["hatchling"]
build-backend = "hatchling.build"

[project]
name = "unknown-world-backend"
version = "0.1.0"
description = "Unknown World Backend - Gemini ê¸°ë°˜ ì—ì´ì „íŠ¸í˜• ê²Œì„ ì—”ì§„"
requires-python = ">=3.14"
dependencies = [
    "fastapi==0.128.0",
    "uvicorn[standard]==0.40.0",
    "pydantic==2.12.5",
    "google-genai==1.60.0",
    "python-dotenv>=1.2.1",
    "python-multipart>=0.0.22",
    "pillow>=12.1.0",
]

[tool.hatch.build.targets.wheel]
packages = ["src/unknown_world"]

[dependency-groups]
dev = [
    "ruff==0.14.10",
    "pyright==1.1.408",
    "pytest==9.0.2",
    "httpx==0.28.1",
    "jsonschema>=4.26.0",
    "pytest-asyncio>=1.3.0",
    "pytest-cov>=7.0.0",
]

[tool.ruff]
line-length = 100
target-version = "py314"
extend-exclude = [
    "__pycache__",
    ".ruff_cache",
    ".venv",
    "venv",
    "dist",
    "build",
    ".claude",
    ".cursor",
    ".gemini",
    "prompts",
    "vibe",
]

[tool.ruff.lint]
select = [
    "E",      # pycodestyle errors
    "W",      # pycodestyle warnings
    "F",      # pyflakes
    "I",      # isort
    "UP",     # pyupgrade
    "B",      # flake8-bugbear
    "C4",     # flake8-comprehensions
    "SIM",    # flake8-simplify
]
ignore = [
    "E501",   # line too long (handled by formatter)
    "B008",   # function call in default argument (FastAPI Depends pattern)
]

[tool.ruff.lint.per-file-ignores]
"debug_*.py" = ["E402"]
"start_and_test.py" = ["E402"]

[tool.ruff.format]
quote-style = "double"
indent-style = "space"

[tool.pyright]
pythonVersion = "3.14"
typeCheckingMode = "strict"
include = ["src"]
venvPath = "."
venv = ".venv"
</file>

<file path="backend/src/unknown_world/main.py">
"""Unknown World - FastAPI ì• í”Œë¦¬ì¼€ì´ì…˜ ì—”íŠ¸ë¦¬í¬ì¸íŠ¸

ì´ ëª¨ë“ˆì€ Unknown World ë°±ì—”ë“œì˜ FastAPI ì•±ì„ ì •ì˜í•©ë‹ˆë‹¤.
MVP ë‹¨ê³„ì—ì„œëŠ” ê¸°ë³¸ í—¬ìŠ¤ì²´í¬ì™€ ê°œë°œìš© CORS ì„¤ì •ë§Œ í¬í•¨í•©ë‹ˆë‹¤.

ì‹¤í–‰ ë°©ë²•:
    cd backend
    uv sync
    uv run uvicorn unknown_world.main:app --reload --port 8011

ì°¸ì¡°:
    - vibe/tech-stack.md (ë²„ì „ SSOT)
    - vibe/prd.md (ì—ì´ì „íŠ¸í˜• ê²Œì„ ì—”ì§„ ìš”êµ¬ì‚¬í•­)
    - .cursor/rules/20-backend-orchestrator.mdc (SSE/ê²€ì¦/ë³µêµ¬ ê·œì¹™)
"""

# ruff: noqa: E402
# E402 ë¬´ì‹œ: .env ë¡œë”©ì€ ì˜ë„ì ìœ¼ë¡œ ë‹¤ë¥¸ importë³´ë‹¤ ë¨¼ì € ì‹¤í–‰ë˜ì–´ì•¼ í•¨ (U-047)

# =============================================================================
# .env ìë™ ë¡œë”© (U-047)
# =============================================================================
# ë¡œì»¬ ê°œë°œì—ì„œ backend/.env íŒŒì¼ì´ ìˆìœ¼ë©´ ìë™ ë¡œë”©í•©ë‹ˆë‹¤.
# - override=False: ì´ë¯¸ ì„¤ì •ëœ í™˜ê²½ë³€ìˆ˜ëŠ” ë®ì–´ì“°ì§€ ì•ŠìŒ (ìš´ì˜ í™˜ê²½ SSOT ë³´ì¥)
# - íŒŒì¼ ë¯¸ì¡´ì¬ ì‹œ no-op (ìš´ì˜/CIì—ì„œ íŒŒì¼ ë¯¸ì¡´ì¬ë¥¼ ê¸°ë³¸ìœ¼ë¡œ í—ˆìš©)
# - í˜ì–´ë§ ì§ˆë¬¸ Q1 ê²°ì •: Option A (import ì‹œì ì— ë¡œë“œ)
#
# ë³´ì•ˆ ê·œì¹™:
#   - .env íŒŒì¼ì€ ë ˆí¬ì— ì»¤ë°‹ ê¸ˆì§€ (.gitignore í•„ìˆ˜)
#   - ë¯¼ê° ì •ë³´(í‚¤/í† í°/í”„ë¡¬í”„íŠ¸)ëŠ” ë¡œê·¸/ìŠ¤íŠ¸ë¦¼/UIì— ë…¸ì¶œ ê¸ˆì§€ (RULE-007)
import os
from pathlib import Path

from dotenv import load_dotenv

# .env íŒŒì¼ ê²½ë¡œ (backend ë””ë ‰í† ë¦¬ ê¸°ì¤€)
# main.py ìœ„ì¹˜: backend/src/unknown_world/main.py
# backend/.env ìœ„ì¹˜: backend/.env (3ë‹¨ê³„ ìƒìœ„)
# resolve()ë¡œ ì ˆëŒ€ ê²½ë¡œ ë³´ì¥
_DOTENV_PATH = Path(__file__).resolve().parent.parent.parent / ".env"

# .env ë¡œë”© (override=False: ê¸°ì¡´ í™˜ê²½ë³€ìˆ˜ ìš°ì„ )
_dotenv_loaded = load_dotenv(dotenv_path=_DOTENV_PATH, override=False)

# ë””ë²„ê·¸: .env ë¡œë”© ìƒíƒœ ì¦‰ì‹œ ì¶œë ¥ (U-047 ê²€ì¦ìš©)
import sys

print(f"[Startup] .env path: {_DOTENV_PATH}", file=sys.stderr)
print(f"[Startup] .env exists: {_DOTENV_PATH.exists()}", file=sys.stderr)
print(f"[Startup] dotenv loaded: {_dotenv_loaded}", file=sys.stderr)
import os as _os_temp

print(f"[Startup] UW_MODE: {_os_temp.environ.get('UW_MODE', 'NOT_SET')}", file=sys.stderr)

import logging
from collections.abc import AsyncGenerator
from contextlib import asynccontextmanager
from typing import Literal

from fastapi import FastAPI
from fastapi.middleware.cors import CORSMiddleware
from fastapi.staticfiles import StaticFiles
from pydantic import BaseModel

from unknown_world import __version__
from unknown_world.api import image_router, item_icon_router, scanner_router, turn_router
from unknown_world.storage.paths import BASE_DATA_DIR, STATIC_URL_PREFIX

# =============================================================================
# ë¡œê±° ì„¤ì •
# =============================================================================

logger = logging.getLogger(__name__)

# =============================================================================
# .env ë¡œë”© ìƒíƒœ ë¡œê¹… (U-047)
# =============================================================================
# ë¯¼ê° ì •ë³´(í‚¤/í† í°/ê²½ë¡œ)ëŠ” ì¶œë ¥í•˜ì§€ ì•ŠìŒ (RULE-007/008)
# ëª¨ë“œ/í™˜ê²½ ì •ë„ë§Œ ë¡œê¹…í•˜ì—¬ ë””ë²„ê¹… ìš©ì´ì„± í™•ë³´

_uw_mode = os.environ.get("UW_MODE", "mock")  # ê¸°ë³¸ê°’: mock (genai_client.py ì •ì±…)
_environment = os.environ.get("ENVIRONMENT", "development")

if _dotenv_loaded:
    logger.info(
        "[Config] .env íŒŒì¼ ë¡œë“œ ì™„ë£Œ",
        extra={
            "dotenv_path": str(_DOTENV_PATH),
            "UW_MODE": _uw_mode,
            "ENVIRONMENT": _environment,
        },
    )
else:
    logger.debug(
        "[Config] .env íŒŒì¼ ë¯¸ì¡´ì¬ ë˜ëŠ” ë¡œë“œ ì‹¤íŒ¨ (ê¸°ë³¸ê°’ ì‚¬ìš©)",
        extra={
            "UW_MODE": _uw_mode,
            "ENVIRONMENT": _environment,
        },
    )

# =============================================================================
# Lifespan (ì„œë²„ ì‹œì‘/ì¢…ë£Œ ì´ë²¤íŠ¸)
# =============================================================================


@asynccontextmanager
async def lifespan(app: FastAPI) -> AsyncGenerator[None]:
    """FastAPI ì•± lifespan ê´€ë¦¬.

    ì„œë²„ ì‹œì‘ ì‹œ:
        - ê¸°ë³¸ ì´ˆê¸°í™” (U-091: rembg preflight ì œê±°ë¨)

    ì„œë²„ ì¢…ë£Œ ì‹œ:
        - í•„ìš”í•œ ì •ë¦¬ ì‘ì—… ìˆ˜í–‰
    """
    # =========================================================================
    # Startup
    # =========================================================================
    logger.info("[Startup] Unknown World ë°±ì—”ë“œ ì‹œì‘")
    # U-091: rembg preflight ì œê±° - ëŸ°íƒ€ì„ì—ì„œ rembgë¥¼ ì‚¬ìš©í•˜ì§€ ì•Šìœ¼ë¯€ë¡œ
    # ëª¨ë¸ ë‹¤ìš´ë¡œë“œ/ì‚¬ì „ ì ê²€ ë¶ˆí•„ìš”. ì„œë²„ ì‹œì‘ ì‹œê°„ ë‹¨ì¶•.
    logger.info("[Startup] Unknown World ë°±ì—”ë“œ ì‹œì‘ ì™„ë£Œ")

    yield

    # =========================================================================
    # Shutdown
    # =========================================================================
    logger.info("[Shutdown] Unknown World ë°±ì—”ë“œ ì¢…ë£Œ")


# =============================================================================
# FastAPI ì•± ì¸ìŠ¤í„´ìŠ¤
# =============================================================================

app = FastAPI(
    title="Unknown World API",
    description="Gemini ê¸°ë°˜ ì—ì´ì „íŠ¸í˜• ê²Œì„ ì—”ì§„ ì˜¤ì¼€ìŠ¤íŠ¸ë ˆì´í„°",
    version=__version__,
    docs_url="/docs",
    redoc_url="/redoc",
    lifespan=lifespan,
)

# =============================================================================
# ì •ì  íŒŒì¼ ì„œë¹™ (U-019, RU-006-Q5)
# =============================================================================
# ë°ì´í„° ë””ë ‰í† ë¦¬ ìƒì„± ë° ì •ì  íŒŒì¼ ì„œë¹™
# ì „ì²´ .data ë””ë ‰í† ë¦¬ë¥¼ /staticìœ¼ë¡œ ì„œë¹™í•˜ì—¬ ì¹´í…Œê³ ë¦¬ë³„ ê²½ë¡œ ì§€ì›
# ì˜ˆ: /static/images/generated/img_xxx.png
BASE_DATA_DIR.mkdir(parents=True, exist_ok=True)
app.mount(STATIC_URL_PREFIX, StaticFiles(directory=str(BASE_DATA_DIR)), name="static")

# =============================================================================
# CORS ì„¤ì • (ê°œë°œ í™˜ê²½ìš©)
# =============================================================================
# PRD ìš”êµ¬: ë¡œì»¬ ê°œë°œì—ì„œ í”„ë¡ íŠ¸ì™€ í†µì‹ í•  ìˆ˜ ìˆë„ë¡ CORS ê¸°ë³¸ ì •ì±… ì¤€ë¹„
# RULE-011: í”„ë¡ íŠ¸ì—”ë“œëŠ” 8001~8010 í¬íŠ¸ ì‚¬ìš©
# ì£¼ì˜: í”„ë¡œë•ì…˜ì—ì„œëŠ” MMP ë‹¨ê³„ì—ì„œ ì—„ê²©í•œ ì •ì±…ìœ¼ë¡œ ë³€ê²½í•´ì•¼ í•¨

ALLOWED_ORIGINS = [
    # í”„ë¡ íŠ¸ì—”ë“œ ê°œë°œ ì„œë²„ í¬íŠ¸ ë²”ìœ„ (RULE-011: 8001~8010)
    *[f"http://localhost:{port}" for port in range(8001, 8011)],
    *[f"http://127.0.0.1:{port}" for port in range(8001, 8011)],
]

app.add_middleware(
    CORSMiddleware,
    allow_origins=ALLOWED_ORIGINS,
    allow_credentials=True,
    allow_methods=["*"],
    allow_headers=["*"],
)

# =============================================================================
# ë¼ìš°í„° ë“±ë¡
# =============================================================================

# U-007: /api/turn HTTP Streaming ì—”ë“œí¬ì¸íŠ¸
app.include_router(turn_router)

# U-019: /api/image ì´ë¯¸ì§€ ìƒì„± ì—”ë“œí¬ì¸íŠ¸
app.include_router(image_router)

# U-021: /api/scan ì´ë¯¸ì§€ ì´í•´(Scanner) ì—”ë“œí¬ì¸íŠ¸
app.include_router(scanner_router)

# U-075: /api/item ì•„ì´í…œ ì•„ì´ì½˜ ìƒì„± ì—”ë“œí¬ì¸íŠ¸
app.include_router(item_icon_router)


# =============================================================================
# ì‘ë‹µ ìŠ¤í‚¤ë§ˆ (Pydantic)
# =============================================================================


class HealthResponse(BaseModel):
    """í—¬ìŠ¤ì²´í¬ ì‘ë‹µ ìŠ¤í‚¤ë§ˆ.

    Attributes:
        status: ì„œë²„ ìƒíƒœ ("ok" ë˜ëŠ” "degraded")
        version: ë°±ì—”ë“œ ë²„ì „
        service: ì„œë¹„ìŠ¤ ì´ë¦„
    """

    status: Literal["ok", "degraded"]
    version: str
    service: str


# =============================================================================
# ë¼ìš°íŠ¸ ì •ì˜
# =============================================================================


@app.get("/health", response_model=HealthResponse, tags=["System"])
async def health_check() -> HealthResponse:
    """ì„œë²„ í—¬ìŠ¤ì²´í¬ ì—”ë“œí¬ì¸íŠ¸.

    ì„œë²„ê°€ ì •ìƒì ìœ¼ë¡œ ì‘ë™ ì¤‘ì¸ì§€ í™•ì¸í•©ë‹ˆë‹¤.
    ì´ ì—”ë“œí¬ì¸íŠ¸ëŠ” ë¡œë“œë°¸ëŸ°ì„œ, ëª¨ë‹ˆí„°ë§ ì‹œìŠ¤í…œ, í´ë¼ì´ì–¸íŠ¸ ì—°ê²° í™•ì¸ì— ì‚¬ìš©ë©ë‹ˆë‹¤.

    U-091: rembg ëŸ°íƒ€ì„ ì œê±° - ë°°ê²½ ì œê±° ìƒíƒœ ì •ë³´ ë” ì´ìƒ í¬í•¨í•˜ì§€ ì•ŠìŒ.

    Returns:
        HealthResponse: ì„œë²„ ìƒíƒœ ì •ë³´
    """
    return HealthResponse(
        status="ok",
        version=__version__,
        service="unknown-world-backend",
    )


@app.get("/", tags=["System"])
async def root() -> dict[str, str]:
    """ë£¨íŠ¸ ì—”ë“œí¬ì¸íŠ¸.

    API ì •ë³´ë¥¼ ê°„ëµíˆ ì•ˆë‚´í•©ë‹ˆë‹¤.

    Returns:
        dict: ê¸°ë³¸ ì•ˆë‚´ ë©”ì‹œì§€
    """
    return {
        "message": "Unknown World API",
        "docs": "/docs",
        "health": "/health",
    }
</file>

<file path="frontend/src/stores/worldStore.test.ts">
import { describe, it, expect, beforeEach, vi } from 'vitest';
import { useWorldStore, selectMainObjective, selectSubObjectives } from './worldStore';
import type { TurnOutput } from '../schemas/turn';

// i18next ëª¨í‚¹ (U-072)
vi.mock('../i18n', () => ({
  default: {
    t: (key: string) => key,
  },
}));

// í•˜ìœ„ ìŠ¤í† ì–´ ëª¨í‚¹ (ìˆœí™˜ import ë°©ì§€ ë¡œì§ ëŒ€ì‘)
vi.mock('./actionDeckStore', () => ({
  useActionDeckStore: {
    getState: () => ({
      setCards: vi.fn(),
    }),
  },
}));

vi.mock('./inventoryStore', () => ({
  useInventoryStore: {
    getState: () => ({
      addItems: vi.fn(),
      removeItems: vi.fn(),
    }),
  },
  parseInventoryAdded: (items: unknown) => items,
}));

describe('worldStore (U-013: Quest + Rules)', () => {
  beforeEach(() => {
    useWorldStore.getState().reset();
  });

  it('ì´ˆê¸° ìƒíƒœê°€ ì˜¬ë°”ë¼ì•¼ í•œë‹¤', () => {
    const state = useWorldStore.getState();
    expect(state.quests).toEqual([]);
    expect(state.activeRules).toEqual([]);
    expect(state.mutationTimeline).toEqual([]);
  });

  it('applyTurnOutputì„ í†µí•´ ìƒˆ í€˜ìŠ¤íŠ¸ê°€ ì¶”ê°€ë˜ì–´ì•¼ í•œë‹¤', () => {
    const mockOutput: Partial<TurnOutput> = {
      narrative: 'ìƒˆ í€˜ìŠ¤íŠ¸ ë°œìƒ',
      economy: {
        cost: { signal: 0, memory_shard: 0 },
        balance_after: { signal: 100, memory_shard: 5 },
        credit: 0,
        low_balance_warning: false,
      },
      ui: {
        scene: { image_url: '', alt_text: '' },
        action_deck: { cards: [] },
        objects: [],
      },
      world: {
        inventory_added: [],
        inventory_removed: [],
        quests_updated: [
          {
            id: 'q1',
            label: 'ì²« ë²ˆì§¸ ì„ë¬´',
            is_completed: false,
            description: null,
            is_main: false,
            progress: 0,
            reward_signal: 0,
          },
        ],
        rules_changed: [],
        relationships_changed: [],
        memory_pins: [],
      },
      agent_console: {
        current_phase: 'commit',
        badges: ['schema_ok'],
        repair_count: 0,
        model_label: 'FAST',
      },
      safety: { blocked: false, message: null },
    };

    useWorldStore.getState().applyTurnOutput(mockOutput as TurnOutput);

    const state = useWorldStore.getState();
    expect(state.quests).toHaveLength(1);
    expect(state.quests[0].id).toBe('q1');
    expect(state.quests[0].is_completed).toBe(false);
  });

  it('ê¸°ì¡´ í€˜ìŠ¤íŠ¸ê°€ ì—…ë°ì´íŠ¸(ì™„ë£Œ)ë˜ì–´ì•¼ í•œë‹¤', () => {
    // 1. ì´ˆê¸° í€˜ìŠ¤íŠ¸ ì¶”ê°€
    const initialState: Partial<TurnOutput> = {
      narrative: 'ì´ˆê¸°í™”',
      economy: {
        cost: { signal: 0, memory_shard: 0 },
        balance_after: { signal: 100, memory_shard: 5 },
        credit: 0,
        low_balance_warning: false,
      },
      ui: {
        scene: { image_url: '', alt_text: '' },
        action_deck: { cards: [] },
        objects: [],
      },
      world: {
        inventory_added: [],
        inventory_removed: [],
        quests_updated: [
          {
            id: 'q1',
            label: 'ì„ë¬´',
            is_completed: false,
            description: null,
            is_main: false,
            progress: 0,
            reward_signal: 0,
          },
        ],
        rules_changed: [],
        relationships_changed: [],
        memory_pins: [],
      },
      agent_console: {
        current_phase: 'commit',
        badges: ['schema_ok'],
        repair_count: 0,
        model_label: 'FAST',
      },
      safety: { blocked: false, message: null },
    };
    useWorldStore.getState().applyTurnOutput(initialState as TurnOutput);

    // 2. í€˜ìŠ¤íŠ¸ ì™„ë£Œ ì—…ë°ì´íŠ¸
    const updateOutput: Partial<TurnOutput> = {
      narrative: 'ì„ë¬´ ì™„ë£Œ!',
      economy: {
        cost: { signal: 0, memory_shard: 0 },
        balance_after: { signal: 100, memory_shard: 5 },
        credit: 0,
        low_balance_warning: false,
      },
      ui: {
        scene: { image_url: '', alt_text: '' },
        action_deck: { cards: [] },
        objects: [],
      },
      world: {
        inventory_added: [],
        inventory_removed: [],
        quests_updated: [
          {
            id: 'q1',
            label: 'ì„ë¬´',
            is_completed: true,
            description: null,
            is_main: false,
            progress: 100,
            reward_signal: 0,
          },
        ],
        rules_changed: [],
        relationships_changed: [],
        memory_pins: [],
      },
      agent_console: {
        current_phase: 'commit',
        badges: ['schema_ok'],
        repair_count: 0,
        model_label: 'FAST',
      },
      safety: { blocked: false, message: null },
    };
    useWorldStore.getState().applyTurnOutput(updateOutput as TurnOutput);

    const state = useWorldStore.getState();
    expect(state.quests).toHaveLength(1);
    expect(state.quests[0].is_completed).toBe(true);
  });

  it('ìƒˆ ê·œì¹™ì´ ì¶”ê°€ë˜ê³  íƒ€ì„ë¼ì¸ì— ê¸°ë¡ë˜ì–´ì•¼ í•œë‹¤', () => {
    const mockOutput: Partial<TurnOutput> = {
      narrative: 'ìƒˆ ê·œì¹™ ì ìš©',
      economy: {
        cost: { signal: 0, memory_shard: 0 },
        balance_after: { signal: 100, memory_shard: 5 },
        credit: 0,
        low_balance_warning: false,
      },
      ui: {
        scene: { image_url: '', alt_text: '' },
        action_deck: { cards: [] },
        objects: [],
      },
      world: {
        inventory_added: [],
        inventory_removed: [],
        quests_updated: [],
        rules_changed: [
          {
            id: 'rule1',
            label: 'ì¤‘ë ¥ ê°•í™”',
            description: 'ì í”„ ë†’ì´ê°€ ì ˆë°˜ìœ¼ë¡œ ê°ì†Œí•©ë‹ˆë‹¤.',
          },
        ],
        relationships_changed: [],
        memory_pins: [],
      },
      agent_console: {
        current_phase: 'commit',
        badges: ['schema_ok'],
        repair_count: 0,
        model_label: 'FAST',
      },
      safety: { blocked: false, message: null },
    };

    useWorldStore.getState().applyTurnOutput(mockOutput as TurnOutput);

    const state = useWorldStore.getState();
    expect(state.activeRules).toHaveLength(1);
    expect(state.activeRules[0].id).toBe('rule1');

    expect(state.mutationTimeline).toHaveLength(1);
    expect(state.mutationTimeline[0].ruleId).toBe('rule1');
    expect(state.mutationTimeline[0].type).toBe('added');
  });

  it('ê¸°ì¡´ ê·œì¹™ ìˆ˜ì • ì‹œ íƒ€ì„ë¼ì¸ì— ê¸°ë¡ë˜ì–´ì•¼ í•œë‹¤', () => {
    // 1. ì´ˆê¸° ê·œì¹™ ì¶”ê°€
    const initialState: Partial<TurnOutput> = {
      narrative: 'ì´ˆê¸°í™”',
      economy: {
        cost: { signal: 0, memory_shard: 0 },
        balance_after: { signal: 100, memory_shard: 5 },
        credit: 0,
        low_balance_warning: false,
      },
      ui: {
        scene: { image_url: '', alt_text: '' },
        action_deck: { cards: [] },
        objects: [],
      },
      world: {
        inventory_added: [],
        inventory_removed: [],
        quests_updated: [],
        rules_changed: [{ id: 'rule1', label: 'ê·œì¹™', description: 'ê¸°ì¡´' }],
        relationships_changed: [],
        memory_pins: [],
      },
      agent_console: {
        current_phase: 'commit',
        badges: ['schema_ok'],
        repair_count: 0,
        model_label: 'FAST',
      },
      safety: { blocked: false, message: null },
    };
    useWorldStore.getState().applyTurnOutput(initialState as TurnOutput);

    // 2. ê·œì¹™ ìˆ˜ì •
    const updateOutput: Partial<TurnOutput> = {
      narrative: 'ê·œì¹™ ìˆ˜ì •',
      economy: {
        cost: { signal: 0, memory_shard: 0 },
        balance_after: { signal: 100, memory_shard: 5 },
        credit: 0,
        low_balance_warning: false,
      },
      ui: {
        scene: { image_url: '', alt_text: '' },
        action_deck: { cards: [] },
        objects: [],
      },
      world: {
        inventory_added: [],
        inventory_removed: [],
        quests_updated: [],
        rules_changed: [{ id: 'rule1', label: 'ê·œì¹™', description: 'ìˆ˜ì •ë¨' }],
        relationships_changed: [],
        memory_pins: [],
      },
      agent_console: {
        current_phase: 'commit',
        badges: ['schema_ok'],
        repair_count: 0,
        model_label: 'FAST',
      },
      safety: { blocked: false, message: null },
    };
    useWorldStore.getState().applyTurnOutput(updateOutput as TurnOutput);

    const state = useWorldStore.getState();
    expect(state.activeRules[0].description).toBe('ìˆ˜ì •ë¨');
    expect(state.mutationTimeline).toHaveLength(2);
    expect(state.mutationTimeline[0].type).toBe('modified');
  });

  describe('Initialization and Reset (U-015[Mvp])', () => {
    it('reset ì•¡ì…˜ì€ ëª¨ë“  ìƒíƒœë¥¼ ì´ˆê¸°ê°’ìœ¼ë¡œ ë˜ëŒë ¤ì•¼ í•œë‹¤', () => {
      // 1. ì„ì˜ì˜ ìƒíƒœ ì„¤ì •
      useWorldStore.setState({
        turnCount: 10,
        economy: { signal: 50, memory_shard: 0, credit: 0 },
        quests: [
          {
            id: 'q1',
            label: 'í€˜ìŠ¤íŠ¸',
            is_completed: false,
            description: null,
            is_main: false,
            progress: 0,
            reward_signal: 0,
          },
        ],
      });

      // 2. ë¦¬ì…‹ ì‹¤í–‰
      useWorldStore.getState().reset();

      // 3. ê²€ì¦
      const state = useWorldStore.getState();
      expect(state.turnCount).toBe(0);
      expect(state.economy.signal).toBe(100);
      expect(state.quests).toEqual([]);
      expect(state.narrativeEntries).toEqual([]);
    });

    it('initialize ì•¡ì…˜ì€ ì›°ì»´ ë©”ì‹œì§€ì™€ í•¨ê»˜ ì´ˆê¸° ìƒíƒœë¥¼ ì„¤ì •í•´ì•¼ í•œë‹¤', () => {
      const welcomeMsg = 'í™˜ì˜í•©ë‹ˆë‹¤!';
      useWorldStore.getState().initialize(welcomeMsg);

      const state = useWorldStore.getState();
      expect(state.turnCount).toBe(0);
      expect(state.narrativeEntries).toHaveLength(1);
      expect(state.narrativeEntries[0].text).toBe(welcomeMsg);
      expect(state.narrativeEntries[0].turn).toBe(0);
    });
  });

  describe('Action Log (U-070[Mvp])', () => {
    it('appendActionLog ì•¡ì…˜ì€ action_log íƒ€ì…ì˜ ì—”íŠ¸ë¦¬ë¥¼ ì¶”ê°€í•´ì•¼ í•œë‹¤', () => {
      const logMsg = 'í–‰ë™ ì‹¤í–‰: ì•„ì´í…œ ì‚¬ìš©';
      useWorldStore.getState().appendActionLog(logMsg);

      const state = useWorldStore.getState();
      const lastEntry = state.narrativeEntries[state.narrativeEntries.length - 1];
      expect(lastEntry.text).toBe(logMsg);
      expect(lastEntry.type).toBe('action_log');
      expect(lastEntry.turn).toBe(state.turnCount);
    });
  });

  describe('Processing Phase (U-071[Mvp])', () => {
    it('setProcessingPhase ì•¡ì…˜ì€ sceneStateì˜ processingPhaseë¥¼ ì—…ë°ì´íŠ¸í•´ì•¼ í•œë‹¤', () => {
      const store = useWorldStore.getState();

      // 1. ì´ˆê¸° ìƒíƒœ í™•ì¸
      expect(store.sceneState.processingPhase).toBeUndefined(); // ë˜ëŠ” 'idle' (ì´ˆê¸°ê°’ ì •ì±…ì— ë”°ë¼ ë‹¤ë¦„)

      // 2. ë‹¨ê³„ ë³€ê²½
      store.setProcessingPhase('processing');
      expect(useWorldStore.getState().sceneState.processingPhase).toBe('processing');

      // 3. ë‹¨ê³„ ë³€ê²½ (image_pending)
      store.setProcessingPhase('image_pending');
      expect(useWorldStore.getState().sceneState.processingPhase).toBe('image_pending');

      // 4. ìœ íœ´ ìƒíƒœë¡œ ë³µê·€
      store.setProcessingPhase('idle');
      expect(useWorldStore.getState().sceneState.processingPhase).toBe('idle');
    });
  });

  describe('Scanner Hints (U-072[Mvp])', () => {
    it('applyTurnOutputì—ì„œ hints.scannerê°€ trueì´ë©´ íŒíŠ¸ ë‚´ëŸ¬í‹°ë¸Œê°€ ì¶”ê°€ë˜ì–´ì•¼ í•œë‹¤', () => {
      const mockOutput: Partial<TurnOutput> = {
        narrative: 'ì¼ë°˜ ë‚´ëŸ¬í‹°ë¸Œ',
        economy: {
          cost: { signal: 0, memory_shard: 0 },
          balance_after: { signal: 100, memory_shard: 5 },
          credit: 0,
          low_balance_warning: false,
        },
        ui: {
          scene: { image_url: '', alt_text: '' },
          action_deck: { cards: [] },
          objects: [],
        },
        world: {
          inventory_added: [],
          inventory_removed: [],
          quests_updated: [],
          rules_changed: [],
          relationships_changed: [],
          memory_pins: [],
        },
        agent_console: {
          current_phase: 'commit',
          badges: ['schema_ok'],
          repair_count: 0,
          model_label: 'FAST',
        },
        safety: { blocked: false, message: null },
        hints: {
          scanner: true,
        },
      };

      useWorldStore.getState().applyTurnOutput(mockOutput as TurnOutput);

      const state = useWorldStore.getState();
      // ì¼ë°˜ ë‚´ëŸ¬í‹°ë¸Œ + ìŠ¤ìºë„ˆ íŒíŠ¸ ì´ 2ê°œì—¬ì•¼ í•¨
      expect(state.narrativeEntries).toHaveLength(2);
      expect(state.narrativeEntries[0].text).toBe('ì¼ë°˜ ë‚´ëŸ¬í‹°ë¸Œ');
      expect(state.narrativeEntries[1].text).toBe('scanner.hint_narrative');
      expect(state.narrativeEntries[1].type).toBe('system');
    });

    it('hints.scannerê°€ ì—†ìœ¼ë©´ íŒíŠ¸ ë‚´ëŸ¬í‹°ë¸Œê°€ ì¶”ê°€ë˜ì§€ ì•Šì•„ì•¼ í•œë‹¤', () => {
      const mockOutput: Partial<TurnOutput> = {
        narrative: 'ì¼ë°˜ ë‚´ëŸ¬í‹°ë¸Œ',
        economy: {
          cost: { signal: 0, memory_shard: 0 },
          balance_after: { signal: 100, memory_shard: 5 },
          credit: 0,
          low_balance_warning: false,
        },
        ui: {
          scene: { image_url: '', alt_text: '' },
          action_deck: { cards: [] },
          objects: [],
        },
        world: {
          inventory_added: [],
          inventory_removed: [],
          quests_updated: [],
          rules_changed: [],
          relationships_changed: [],
          memory_pins: [],
        },
        agent_console: {
          current_phase: 'commit',
          badges: ['schema_ok'],
          repair_count: 0,
          model_label: 'FAST',
        },
        safety: { blocked: false, message: null },
      };

      useWorldStore.getState().applyTurnOutput(mockOutput as TurnOutput);

      const state = useWorldStore.getState();
      expect(state.narrativeEntries).toHaveLength(1);
      expect(state.narrativeEntries[0].text).toBe('ì¼ë°˜ ë‚´ëŸ¬í‹°ë¸Œ');
    });
  });

  describe('Objective System (U-078[Mvp])', () => {
    it('selectMainObjectiveëŠ” is_main=trueì¸ í€˜ìŠ¤íŠ¸ë¥¼ ë°˜í™˜í•´ì•¼ í•œë‹¤', () => {
      useWorldStore.setState({
        quests: [
          {
            id: 'q1',
            label: 'ì„œë¸Œ',
            is_main: false,
            is_completed: false,
            progress: 0,
            reward_signal: 0,
            description: null,
          },
          {
            id: 'q2',
            label: 'ë©”ì¸',
            is_main: true,
            is_completed: false,
            progress: 50,
            reward_signal: 100,
            description: null,
          },
        ],
      });

      const main = selectMainObjective(useWorldStore.getState());
      expect(main?.id).toBe('q2');
    });

    it('selectSubObjectivesëŠ” is_main=falseì¸ í€˜ìŠ¤íŠ¸ë“¤ì„ ë°˜í™˜í•´ì•¼ í•œë‹¤', () => {
      useWorldStore.setState({
        quests: [
          {
            id: 'q1',
            label: 'ì„œë¸Œ1',
            is_main: false,
            is_completed: false,
            progress: 0,
            reward_signal: 0,
            description: null,
          },
          {
            id: 'q2',
            label: 'ë©”ì¸',
            is_main: true,
            is_completed: false,
            progress: 50,
            reward_signal: 100,
            description: null,
          },
          {
            id: 'q3',
            label: 'ì„œë¸Œ2',
            is_main: false,
            is_completed: false,
            progress: 0,
            reward_signal: 0,
            description: null,
          },
        ],
      });

      const subs = selectSubObjectives(useWorldStore.getState());
      expect(subs).toHaveLength(2);
      expect(subs.map((s) => s.id)).toContain('q1');
      expect(subs.map((s) => s.id)).toContain('q3');
    });

    it('í€˜ìŠ¤íŠ¸ ì™„ë£Œ ì‹œ reward_signalì´ ìˆìœ¼ë©´ ì•Œë¦¼ ë©”ì‹œì§€ê°€ ì¶”ê°€ë˜ì–´ì•¼ í•œë‹¤', () => {
      // 1. ì´ˆê¸° ìƒíƒœ: ë¯¸ì™„ë£Œ í€˜ìŠ¤íŠ¸
      useWorldStore.setState({
        quests: [
          {
            id: 'q1',
            label: 'ì„ë¬´',
            is_main: false,
            is_completed: false,
            progress: 0,
            reward_signal: 50,
            description: null,
          },
        ],
      });

      // 2. ì™„ë£Œ ì—…ë°ì´íŠ¸
      const output: Partial<TurnOutput> = {
        narrative: 'ì„ë¬´ ì™„ë£Œ',
        economy: {
          cost: { signal: 0, memory_shard: 0 },
          balance_after: { signal: 150, memory_shard: 5 },
          credit: 0,
          low_balance_warning: false,
        },
        ui: {
          scene: { image_url: '', alt_text: '' },
          action_deck: { cards: [] },
          objects: [],
        },
        world: {
          inventory_added: [],
          inventory_removed: [],
          quests_updated: [
            {
              id: 'q1',
              label: 'ì„ë¬´',
              is_main: false,
              is_completed: true,
              progress: 100,
              reward_signal: 50,
              description: null,
            },
          ],
          rules_changed: [],
          relationships_changed: [],
          memory_pins: [],
        },
        agent_console: {
          current_phase: 'commit',
          badges: ['schema_ok'],
          repair_count: 0,
          model_label: 'FAST',
        },
        safety: { blocked: false, message: null },
      };

      useWorldStore.getState().applyTurnOutput(output as TurnOutput);

      const state = useWorldStore.getState();
      // ì¼ë°˜ ë‚´ëŸ¬í‹°ë¸Œ + ë³´ìƒ ì•Œë¦¼ ì´ 2ê°œ
      expect(state.narrativeEntries).toHaveLength(2);
      expect(state.narrativeEntries[1].text).toContain('quest.objective_complete');
      expect(state.narrativeEntries[1].text).toContain('quest.reward_earned');
      expect(state.narrativeEntries[1].type).toBe('system');
    });
  });

  describe('Hotspot Policy (U-090[Mvp])', () => {
    it('ìƒˆ ì´ë¯¸ì§€ ìƒì„± ì‹œ í•«ìŠ¤íŒŸì´ ì´ˆê¸°í™”ë˜ì–´ì•¼ í•œë‹¤ (Q1: Option A)', () => {
      // 1. ê¸°ì¡´ í•«ìŠ¤íŒŸ ì„¤ì •
      useWorldStore.setState({
        sceneObjects: [
          {
            id: 'old',
            label: 'ê³¼ê±°',
            box_2d: { ymin: 0, xmin: 0, ymax: 100, xmax: 100 },
            interaction_hint: null,
          },
        ],
      });

      // 2. ìƒˆ ì´ë¯¸ì§€ ìƒì„±ì´ í¬í•¨ëœ í„´ (image_url ì¡´ì¬)
      const mockOutput: Partial<TurnOutput> = {
        narrative: 'ìƒˆ ì¥ë©´',
        economy: {
          cost: { signal: 0, memory_shard: 0 },
          balance_after: { signal: 100, memory_shard: 5 },
          credit: 0,
          low_balance_warning: false,
        },
        ui: {
          scene: { image_url: 'new_img.png', alt_text: '' },
          action_deck: { cards: [] },
          objects: [],
        },
        render: {
          image_url: 'new_img.png',
          image_job: null,
          image_id: 'img_1',
          generation_time_ms: 1000,
        },
        world: {
          inventory_added: [],
          inventory_removed: [],
          quests_updated: [],
          rules_changed: [],
          relationships_changed: [],
          memory_pins: [],
        },
        agent_console: {
          current_phase: 'commit',
          badges: ['schema_ok'],
          repair_count: 0,
          model_label: 'FAST',
        },
        safety: { blocked: false, message: null },
      };

      useWorldStore.getState().applyTurnOutput(mockOutput as TurnOutput);

      const state = useWorldStore.getState();
      expect(state.sceneObjects).toHaveLength(0); // ì´ˆê¸°í™”ë¨
    });

    it('ìƒˆ ì´ë¯¸ì§€ ìƒì„±ì´ í¬í•¨ëœ í„´ (should_generate=true)ì—ì„œë„ í•«ìŠ¤íŒŸì´ ì´ˆê¸°í™”ë˜ì–´ì•¼ í•œë‹¤', () => {
      // 1. ê¸°ì¡´ í•«ìŠ¤íŒŸ ì„¤ì •
      useWorldStore.setState({
        sceneObjects: [
          {
            id: 'old',
            label: 'ê³¼ê±°',
            box_2d: { ymin: 0, xmin: 0, ymax: 100, xmax: 100 },
            interaction_hint: null,
          },
        ],
      });

      // 2. ì´ë¯¸ì§€ ìƒì„± ì˜ˆì •ì¸ í„´
      const mockOutput: Partial<TurnOutput> = {
        narrative: 'ì¥ë©´ ì „í™˜ ì¤‘...',
        economy: {
          cost: { signal: 0, memory_shard: 0 },
          balance_after: { signal: 100, memory_shard: 5 },
          credit: 0,
          low_balance_warning: false,
        },
        ui: {
          scene: { image_url: '', alt_text: '' },
          action_deck: { cards: [] },
          objects: [],
        },
        render: {
          image_url: null,
          image_job: {
            should_generate: true,
            prompt: 'A new scene',
            model_label: 'FAST',
            aspect_ratio: '16:9',
            image_size: '1024x1024',
            reference_image_ids: [],
            reference_image_url: null,
          },
          image_id: null,
          generation_time_ms: null,
        },
        world: {
          inventory_added: [],
          inventory_removed: [],
          quests_updated: [],
          rules_changed: [],
          relationships_changed: [],
          memory_pins: [],
        },
        agent_console: {
          current_phase: 'commit',
          badges: ['schema_ok'],
          repair_count: 0,
          model_label: 'FAST',
        },
        safety: { blocked: false, message: null },
      };

      useWorldStore.getState().applyTurnOutput(mockOutput as TurnOutput);

      const state = useWorldStore.getState();
      expect(state.sceneObjects).toHaveLength(0); // ì´ˆê¸°í™”ë¨
    });

    it('ì¼ë°˜ í„´(objects ë¹„ì–´ìˆìŒ)ì—ì„œëŠ” ê¸°ì¡´ í•«ìŠ¤íŒŸì´ ìœ ì§€ë˜ì–´ì•¼ í•œë‹¤', () => {
      // 1. ê¸°ì¡´ í•«ìŠ¤íŒŸ ì„¤ì •
      const oldObjects = [
        {
          id: 'obj1',
          label: 'ë¬¼ì²´1',
          box_2d: { ymin: 100, xmin: 100, ymax: 200, xmax: 200 },
          interaction_hint: null,
        },
      ];
      useWorldStore.setState({
        sceneObjects: oldObjects,
      });

      // 2. ì¼ë°˜ í„´ (objects ë¹„ì–´ìˆìŒ, ì´ë¯¸ì§€ ìƒì„± ì—†ìŒ)
      const mockOutput: Partial<TurnOutput> = {
        narrative: 'ì•„ë¬´ ì¼ë„ ì¼ì–´ë‚˜ì§€ ì•ŠìŠµë‹ˆë‹¤.',
        economy: {
          cost: { signal: 0, memory_shard: 0 },
          balance_after: { signal: 100, memory_shard: 5 },
          credit: 0,
          low_balance_warning: false,
        },
        ui: {
          scene: { image_url: '', alt_text: '' },
          action_deck: { cards: [] },
          objects: [],
        },
        world: {
          inventory_added: [],
          inventory_removed: [],
          quests_updated: [],
          rules_changed: [],
          relationships_changed: [],
          memory_pins: [],
        },
        agent_console: {
          current_phase: 'commit',
          badges: ['schema_ok'],
          repair_count: 0,
          model_label: 'FAST',
        },
        safety: { blocked: false, message: null },
      };

      useWorldStore.getState().applyTurnOutput(mockOutput as TurnOutput);

      const state = useWorldStore.getState();
      expect(state.sceneObjects).toEqual(oldObjects); // ìœ ì§€ë¨
    });

    it('ì •ë°€ë¶„ì„ ê²°ê³¼(objects ì¡´ì¬)ëŠ” ê¸°ì¡´ í•«ìŠ¤íŒŸì— ë³‘í•©ë˜ì–´ì•¼ í•œë‹¤', () => {
      // 1. ê¸°ì¡´ í•«ìŠ¤íŒŸ ì„¤ì •
      const oldObjects = [
        {
          id: 'obj1',
          label: 'ë¬¼ì²´1',
          box_2d: { ymin: 100, xmin: 100, ymax: 200, xmax: 200 },
          interaction_hint: null,
        },
      ];
      useWorldStore.setState({
        sceneObjects: oldObjects,
      });

      // 2. ì •ë°€ë¶„ì„ ê²°ê³¼ í„´
      const newObject = {
        id: 'obj2',
        label: 'ë¬¼ì²´2',
        box_2d: { ymin: 300, xmin: 300, ymax: 400, xmax: 400 },
        interaction_hint: null,
      };
      const mockOutput: Partial<TurnOutput> = {
        narrative: 'ìì„¸íˆ ë³´ë‹ˆ ìƒˆë¡œìš´ ê²ƒì´ ë³´ì…ë‹ˆë‹¤.',
        economy: {
          cost: { signal: 0, memory_shard: 0 },
          balance_after: { signal: 100, memory_shard: 5 },
          credit: 0,
          low_balance_warning: false,
        },
        ui: {
          scene: { image_url: '', alt_text: '' },
          action_deck: { cards: [] },
          objects: [newObject],
        },
        world: {
          inventory_added: [],
          inventory_removed: [],
          quests_updated: [],
          rules_changed: [],
          relationships_changed: [],
          memory_pins: [],
        },
        agent_console: {
          current_phase: 'commit',
          badges: ['schema_ok'],
          repair_count: 0,
          model_label: 'FAST',
        },
        safety: { blocked: false, message: null },
      };

      useWorldStore.getState().applyTurnOutput(mockOutput as TurnOutput);

      const state = useWorldStore.getState();
      expect(state.sceneObjects).toHaveLength(2);
      expect(state.sceneObjects).toContainEqual(oldObjects[0]);
      expect(state.sceneObjects).toContainEqual(newObject);
    });
  });
});
</file>

<file path="frontend/src/App.tsx">
/**
 * Unknown World - ë©”ì¸ ê²Œì„ UI ë ˆì´ì•„ì›ƒ
 *
 * RULE-002 ì¤€ìˆ˜: ì±„íŒ… ë²„ë¸” UI ê¸ˆì§€
 * - ë‚´ëŸ¬í‹°ë¸ŒëŠ” "ì±„íŒ…"ì´ ì•„ë‹ˆë¼ "ê²Œì„ ë¡œê·¸/ë‚´ëŸ¬í‹°ë¸Œ í”¼ë“œ" í˜•íƒœ
 * - ê³ ì • íŒ¨ë„: Scene Canvas, Action Deck, Inventory, Quest,
 *   Rule Board, Economy HUD, Agent Console, Scanner Slot
 *
 * RULE-008: Agent Consoleì—ì„œ ë‹¨ê³„/ë°°ì§€/ë³µêµ¬ë§Œ í‘œì‹œ (í”„ë¡¬í”„íŠ¸ ë…¸ì¶œ ê¸ˆì§€)
 *
 * RU-003-Q4: App.tsxëŠ” "ë ˆì´ì•„ì›ƒ + ì´ë²¤íŠ¸ ë¼ìš°íŒ…"ì— ì§‘ì¤‘
 * - ì„¸ì…˜/ì›”ë“œ ìƒíƒœëŠ” worldStoreë¡œ ì´ë™
 * - TurnOutput ë°˜ì˜ì€ worldStore.applyTurnOutputìœ¼ë¡œ ë‹¨ì¼í™”
 *
 * RU-004-Q4: ì„¸ì…˜ ë¼ì´í”„ì‚¬ì´í´ SSOT
 * - ì„¸ì…˜ ì´ˆê¸°í™”/ë³µì›/ë¦¬ì…‹/ë³€ê²½ì€ sessionLifecycle ëª¨ë“ˆë¡œ ë‹¨ì¼í™”
 * - App.tsxëŠ” ì„¸ì…˜ API í˜¸ì¶œ + UI ì „í™˜ë§Œ ë‹´ë‹¹
 *
 * U-015[Mvp]: SaveGame + Reset + Demo Profiles
 * - í”„ë¡œí•„ ì„ íƒ í™”ë©´ â†’ ê²Œì„ ì‹œì‘ í”Œë¡œìš°
 * - ë¦¬ì…‹ ë²„íŠ¼ìœ¼ë¡œ í”„ë¡œí•„ ì´ˆê¸° ìƒíƒœë¡œ ë³µêµ¬
 * - localStorage ê¸°ë°˜ ì„¸ì´ë¸Œ/ë¡œë“œ
 *
 * @see vibe/ref/frontend-style-guide.md
 * @see vibe/prd.md 6.7/6.8/9ì¥
 */

import { useState, useCallback, useEffect, useMemo } from 'react';
import { useTranslation } from 'react-i18next';
import {
  DndContext,
  DragEndEvent,
  DragStartEvent,
  useSensor,
  useSensors,
  PointerSensor,
  KeyboardSensor,
} from '@dnd-kit/core';
import { Panel } from './components/Panel';
import { GameHeader } from './components/GameHeader';
import { NarrativeFeed } from './components/NarrativeFeed';
import { AgentConsole } from './components/AgentConsole';
import { EconomyHud } from './components/EconomyHud';
import { SceneCanvas, type HotspotClickData } from './components/SceneCanvas';
import { ActionDeck } from './components/ActionDeck';
import { InventoryPanel } from './components/InventoryPanel';
// U-013: Quest + Rule Board + Mutation Timeline
import { QuestPanel } from './components/QuestPanel';
// U-078: Objective Tracker (ë¯¸ë‹ˆ íŠ¸ë˜ì»¤)
import { ObjectiveTracker } from './components/ObjectiveTracker';
import { RuleBoard } from './components/RuleBoard';
import { MutationTimeline } from './components/MutationTimeline';
// U-022: Scanner Slot
import { ScannerSlot } from './components/ScannerSlot';
// U-015: SaveGame + Demo Profiles
import { DemoProfileSelect } from './components/DemoProfileSelect';
import { ResetButton, ChangeProfileButton } from './components/ResetButton';
// U-074: ì˜¨ë³´ë”© ê°€ì´ë“œ
import { OnboardingGuide } from './components/OnboardingGuide';
import { useAgentStore } from './stores/agentStore';
import { useInventoryStore, selectItemCount } from './stores/inventoryStore';
import { useUIPrefsStore, applyUIPrefsToDOM } from './stores/uiPrefsStore';
import { useWorldStore } from './stores/worldStore';
import { useTurnRunner } from './turn/turnRunner';
import type { ActionCard, DropInput } from './schemas/turn';
import { getCurrentThemeFromDOM } from './demo/demoFixtures';
import { isInventoryDragData, isHotspotDropData } from './dnd/types';
// U-074: ì˜¨ë³´ë”© ìƒíƒœ
import { initializeOnboarding } from './stores/onboardingStore';
// RU-004-Q4: ì„¸ì…˜ ë¼ì´í”„ì‚¬ì´í´ SSOT
// U-044: ì„¸ì…˜ ì–¸ì–´ SSOT API ì¶”ê°€
import {
  bootstrapSession,
  hasValidSaveGame,
  startSessionFromProfile,
  continueSession,
  resetToCurrentProfile,
  clearSessionAndReturnToSelect,
  saveCurrentSession,
  getInitialProfileId,
  getSessionLanguage,
  setSessionLanguage,
  getInitialSessionLanguage,
} from './save/sessionLifecycle';
import type { DemoProfile } from './data/demoProfiles';
import type { SupportedLanguage } from './i18n';

// =============================================================================
// ê²Œì„ ìƒíƒœ íƒ€ì…
// =============================================================================

type GamePhase = 'profile_select' | 'playing';

// =============================================================================
// ë©”ì¸ App ì»´í¬ë„ŒíŠ¸
// =============================================================================

function App() {
  const { t } = useTranslation();

  // U-015: ê²Œì„ ì§„í–‰ ìƒíƒœ (í”„ë¡œí•„ ì„ íƒ vs í”Œë ˆì´ ì¤‘)
  // RU-004-Q4: bootstrapSession()ìœ¼ë¡œ ì´ˆê¸° phase ê²°ì • (SSOT)
  const [gamePhase, setGamePhase] = useState<GamePhase>(() => {
    const bootstrap = bootstrapSession();
    return bootstrap.phase;
  });

  // í˜„ì¬ ì„ íƒëœ í”„ë¡œí•„ ID
  // RU-004-Q4: getInitialProfileId()ë¡œ ì´ˆê¸° profileId ê²°ì • (SSOT)
  const [currentProfileId, setCurrentProfileId] = useState<string | null>(() => {
    return getInitialProfileId();
  });

  // U-044: ì„¸ì…˜ ì–¸ì–´ SSOT
  // - SaveGame.languageë¥¼ ê¶Œìœ„ìë¡œ ì‚¬ìš©í•˜ì—¬ ë“œë¦¬í”„íŠ¸ ë°©ì§€
  // - profile_selectì—ì„œë§Œ ë³€ê²½ ê°€ëŠ¥ (í† ê¸€=ë¦¬ì…‹ ì •ì±…)
  const [sessionLanguage, setSessionLanguageState] = useState<SupportedLanguage>(() => {
    return getInitialSessionLanguage();
  });

  // ë¡œì»¬ UI ìƒíƒœ
  const [inputText, setInputText] = useState('');

  // Store ìƒíƒœ
  const worldStore = useWorldStore();
  const {
    economy,
    isConnected,
    sceneObjects,
    narrativeEntries,
    appendSystemNarrative,
    appendActionLog,
  } = worldStore;

  const { startDrag, endDrag } = useInventoryStore();
  const inventoryItemCount = useInventoryStore(selectItemCount);
  const { isStreaming, narrativeBuffer } = useAgentStore();
  const { uiScale, increaseUIScale, decreaseUIScale } = useUIPrefsStore();

  // DOMì— UI ì„¤ì • ì ìš© (U-028â†’U-037)
  useEffect(() => {
    applyUIPrefsToDOM({ uiScale });
  }, [uiScale]);

  // ==========================================================================
  // U-015 + RU-004-Q4: í”„ë¡œí•„/ì„¸ì´ë¸Œ ê´€ë ¨ ë¡œì§ (sessionLifecycle SSOT)
  // ==========================================================================

  /**
   * í”„ë¡œí•„ì„ ì„ íƒí•˜ê³  ê²Œì„ì„ ì‹œì‘í•©ë‹ˆë‹¤.
   *
   * RU-004-Q4: sessionLifecycle.startSessionFromProfile í˜¸ì¶œ
   * U-044: ì„¸ì…˜ ì–¸ì–´ë¥¼ ëª…ì‹œì ìœ¼ë¡œ ì „ë‹¬í•˜ì—¬ SSOT ìœ ì§€
   */
  const handleSelectProfile = useCallback(
    (profile: DemoProfile) => {
      const result = startSessionFromProfile({ profile, t, language: sessionLanguage });
      if (result.success) {
        setCurrentProfileId(result.profileId);
        setGamePhase('playing');
      }
    },
    [t, sessionLanguage],
  );

  /**
   * U-044: profile_selectì—ì„œ ì–¸ì–´ë¥¼ ë³€ê²½í•©ë‹ˆë‹¤.
   * í† ê¸€=ë¦¬ì…‹ ì •ì±…ì— ë”°ë¼ profile_selectì—ì„œë§Œ í˜¸ì¶œ ê°€ëŠ¥í•©ë‹ˆë‹¤.
   */
  const handleLanguageChange = useCallback(async (language: SupportedLanguage) => {
    await setSessionLanguage(language);
    setSessionLanguageState(language);
  }, []);

  /**
   * ì €ì¥ëœ ê²Œì„ì„ ê³„ì†í•©ë‹ˆë‹¤.
   *
   * RU-004-Q4: sessionLifecycle.continueSession í˜¸ì¶œ
   * U-044: ì„¸ì…˜ ë³µì› í›„ ì–¸ì–´ ìƒíƒœë„ ë™ê¸°í™”
   */
  const handleContinue = useCallback(async () => {
    const result = await continueSession();
    if (result) {
      setCurrentProfileId(result.profileId);
      // U-044: ì„¸ì…˜ ë³µì› í›„ ì–¸ì–´ ìƒíƒœ ë™ê¸°í™” (SaveGame.languageê°€ SSOT)
      setSessionLanguageState(getSessionLanguage());
      setGamePhase('playing');
    } else {
      // ë¡œë“œ ì‹¤íŒ¨ ì‹œ profile_selectë¡œ í´ë°±
      setCurrentProfileId(null);
      setGamePhase('profile_select');
      console.warn('[App] SaveGame ë³µì› ì‹¤íŒ¨, ìƒˆë¡œ ì‹œì‘');
    }
  }, []);

  /**
   * í˜„ì¬ í”„ë¡œí•„ì˜ ì´ˆê¸° ìƒíƒœë¡œ ë¦¬ì…‹í•©ë‹ˆë‹¤.
   *
   * RU-004-Q4: sessionLifecycle.resetToCurrentProfile í˜¸ì¶œ
   */
  const handleReset = useCallback(() => {
    const result = resetToCurrentProfile({ t, currentProfileId });
    if (result.success && result.profileId) {
      setCurrentProfileId(result.profileId);
      // ê²Œì„ ìƒíƒœëŠ” ì´ë¯¸ playingì´ë¯€ë¡œ ë³„ë„ ì„¤ì • ë¶ˆí•„ìš”
    }
  }, [t, currentProfileId]);

  /**
   * í”„ë¡œí•„ ì„ íƒ í™”ë©´ìœ¼ë¡œ ëŒì•„ê°‘ë‹ˆë‹¤.
   *
   * RU-004-Q4: sessionLifecycle.clearSessionAndReturnToSelect í˜¸ì¶œ
   */
  const handleChangeProfile = useCallback(() => {
    clearSessionAndReturnToSelect();
    setCurrentProfileId(null);
    setGamePhase('profile_select');
  }, []);

  // ê²Œì„ ì‹œì‘ ì‹œ ì €ì¥ëœ ê²Œì„ ë³µì›
  // RU-004-Q4: sessionLifecycle.continueSession í˜¸ì¶œ
  useEffect(() => {
    if (gamePhase === 'playing' && currentProfileId) {
      void continueSession().then((result) => {
        if (result) {
          setCurrentProfileId(result.profileId);
        }
      });
    }
    // eslint-disable-next-line react-hooks/exhaustive-deps
  }, []);

  // U-074: ê²Œì„ ì‹œì‘ ì‹œ ì˜¨ë³´ë”© ê°€ì´ë“œ ì´ˆê¸°í™” (Q3 Option B: ë°ëª¨ í”„ë¡œí•„ë„ í‘œì‹œ)
  useEffect(() => {
    if (gamePhase === 'playing') {
      initializeOnboarding();
    }
  }, [gamePhase]);

  // í„´ ì™„ë£Œ ì‹œ ìë™ ì €ì¥ (turnCount ë³€í™” ê°ì§€)
  // RU-004-Q4: sessionLifecycle.saveCurrentSession í˜¸ì¶œ
  useEffect(() => {
    if (gamePhase === 'playing' && narrativeEntries.length > 0) {
      saveCurrentSession(currentProfileId);
    }
  }, [gamePhase, narrativeEntries.length, currentProfileId]);

  // RU-003-Q3: Turn Runner (ìŠ¤íŠ¸ë¦¼ ì‹œì‘/ì·¨ì†Œ/ì½œë°± ë¼ìš°íŒ… ë‹´ë‹¹)
  // U-044: ì„¸ì…˜ ì–¸ì–´ë¥¼ SSOTë¡œ ì£¼ì…í•˜ì—¬ ë“œë¦¬í”„íŠ¸ ë°©ì§€
  const turnRunnerDeps = useMemo(
    () => ({
      t,
      theme: getCurrentThemeFromDOM(),
      language: sessionLanguage,
    }),
    [t, sessionLanguage],
  );
  const turnRunner = useTurnRunner(turnRunnerDeps);

  /**
   * í„´ì„ ì‹¤í–‰í•©ë‹ˆë‹¤.
   */
  const executeTurn = useCallback(
    (text: string, actionId?: string, clickData?: HotspotClickData, dropData?: DropInput) => {
      turnRunner.runTurn({
        text,
        actionId,
        click: clickData,
        drop: dropData,
      });
      setInputText('');
    },
    [turnRunner],
  );

  /**
   * ì…ë ¥ ì œì¶œ í•¸ë“¤ëŸ¬
   */
  const handleSubmit = useCallback(() => {
    if (inputText.trim()) {
      executeTurn(inputText.trim());
    }
  }, [inputText, executeTurn]);

  /**
   * ì¹´ë“œ í´ë¦­ í•¸ë“¤ëŸ¬
   * U-070: Q2 Option A - ëª¨ë“  í”Œë ˆì´ì–´ í–‰ë™ì— ì•¡ì…˜ ë¡œê·¸ ì ìš©
   */
  const handleCardClick = useCallback(
    (card: ActionCard) => {
      // U-070: ì•¡ì…˜ ë¡œê·¸ ì¶”ê°€ (TurnInput ì „ì†¡ ì „ì— ì¦‰ê°ì  í”¼ë“œë°±)
      appendActionLog(t('action_log.click_action', { action: card.label }));
      executeTurn(card.label, card.id);
    },
    [executeTurn, appendActionLog, t],
  );

  /**
   * í•«ìŠ¤íŒŸ í´ë¦­ í•¸ë“¤ëŸ¬ (U-010)
   * U-070: í•«ìŠ¤íŒŸ í´ë¦­ì—ë„ ì•¡ì…˜ ë¡œê·¸ ì ìš©
   */
  const handleHotspotClick = useCallback(
    (data: HotspotClickData) => {
      const clickedObject = sceneObjects.find((obj) => obj.id === data.object_id);
      const clickText = clickedObject
        ? t('scene.hotspot.click_action', { label: clickedObject.label })
        : data.object_id;

      // U-070: ì•¡ì…˜ ë¡œê·¸ ì¶”ê°€ (TurnInput ì „ì†¡ ì „ì— ì¦‰ê°ì  í”¼ë“œë°±)
      const hotspotLabel = clickedObject?.label ?? data.object_id;
      appendActionLog(t('action_log.click_hotspot', { hotspot: hotspotLabel }));

      executeTurn(clickText, undefined, data);
    },
    [executeTurn, sceneObjects, t, appendActionLog],
  );

  /**
   * í‚¤ë³´ë“œ ì´ë²¤íŠ¸ í•¸ë“¤ëŸ¬
   */
  const handleKeyDown = useCallback(
    (e: React.KeyboardEvent) => {
      if (e.key === 'Enter' && !e.shiftKey) {
        e.preventDefault();
        handleSubmit();
      }
    },
    [handleSubmit],
  );

  /**
   * ë“œë˜ê·¸ ì‹œì‘ í•¸ë“¤ëŸ¬ (U-011)
   */
  const handleDragStart = useCallback(
    (event: DragStartEvent) => {
      const { active } = event;
      if (isInventoryDragData(active.data.current)) {
        startDrag(active.data.current.item_id);
      }
    },
    [startDrag],
  );

  /**
   * ë“œë˜ê·¸ ì¢…ë£Œ í•¸ë“¤ëŸ¬ (U-011 + U-012)
   * U-070: ì•„ì´í…œâ†’í•«ìŠ¤íŒŸ ë“œë¡­ ì‹œ ì•¡ì…˜ ë¡œê·¸ ì¶”ê°€
   */
  const handleDragEnd = useCallback(
    (event: DragEndEvent) => {
      const { active, over } = event;
      endDrag();

      const activeData = active.data.current;
      if (!isInventoryDragData(activeData)) {
        return;
      }

      const itemId = activeData.item_id;
      const itemName = activeData.item.name;

      const overData = over?.data.current;
      if (!over || !isHotspotDropData(overData)) {
        appendSystemNarrative(
          `[${t('connection.online')}] ${t('scene.hotspot.drop_invalid', { item: itemName })}`,
        );
        return;
      }

      const { object_id: targetObjectId, box_2d: targetBox2d, label: targetLabel } = overData;

      // U-070: ì•¡ì…˜ ë¡œê·¸ ì¶”ê°€ (TurnInput ì „ì†¡ ì „ì— ì¦‰ê°ì  í”¼ë“œë°±)
      appendActionLog(
        t('action_log.use_item_on_hotspot', {
          item: itemName,
          hotspot: targetLabel,
        }),
      );

      const dropText = t('scene.hotspot.drop_action', {
        item: itemName,
        target: targetLabel,
      });

      const dropInput: DropInput = {
        item_id: itemId,
        target_object_id: targetObjectId,
        target_box_2d: targetBox2d,
      };

      executeTurn(dropText, undefined, undefined, dropInput);
    },
    [endDrag, executeTurn, appendSystemNarrative, appendActionLog, t],
  );

  // dnd-kit ì„¼ì„œ ì„¤ì •
  const sensors = useSensors(
    useSensor(PointerSensor, {
      activationConstraint: {
        distance: 8,
      },
    }),
    useSensor(KeyboardSensor),
  );

  // ==========================================================================
  // ë Œë”ë§: í”„ë¡œí•„ ì„ íƒ í™”ë©´
  // RU-004-Q4: hasValidSaveGame()ìœ¼ë¡œ "ìœ íš¨í•œ ì„¸ì´ë¸Œë§Œ" Continue ë…¸ì¶œ
  // U-044: ì–¸ì–´ ì„ íƒ UI ì¶”ê°€ (profile_selectì—ì„œë§Œ, Q1: Option A)
  // ==========================================================================
  if (gamePhase === 'profile_select') {
    const hasSavedGame = hasValidSaveGame();
    return (
      <>
        <div className="crt-overlay" aria-hidden="true" />
        <DemoProfileSelect
          onSelectProfile={handleSelectProfile}
          onContinue={hasSavedGame ? handleContinue : undefined}
          hasSavedGame={hasSavedGame}
          currentLanguage={sessionLanguage}
          onLanguageChange={handleLanguageChange}
        />
      </>
    );
  }

  // ==========================================================================
  // ë Œë”ë§: ê²Œì„ í”Œë ˆì´ í™”ë©´
  // ==========================================================================
  return (
    <>
      <div className="crt-overlay" aria-hidden="true" />

      <DndContext sensors={sensors} onDragStart={handleDragStart} onDragEnd={handleDragEnd}>
        <div className="game-container">
          <GameHeader
            signal={economy.signal}
            memoryShard={economy.memory_shard}
            credit={economy.credit}
            isConnected={isConnected}
            uiScale={uiScale}
            onIncreaseScale={increaseUIScale}
            onDecreaseScale={decreaseUIScale}
          >
            {/* U-015: ë¦¬ì…‹/í”„ë¡œí•„ ë³€ê²½ ë²„íŠ¼ */}
            <ResetButton onReset={handleReset} disabled={isStreaming} compact requireConfirm />
            <ChangeProfileButton onClick={handleChangeProfile} disabled={isStreaming} />
          </GameHeader>

          {/* U-077: ì¢Œì¸¡ ì‚¬ì´ë“œë°” íŒ¨ë„ ì˜ì—­ ë¶„ë°° (U-081 í¡ìˆ˜) */}
          <aside className="sidebar-left">
            {/* U-077: Inventory - flex-1 + min-height ë³´ì¥, ì•„ì´í…œ ê°œìˆ˜ ë™ì  íƒ€ì´í‹€ */}
            <Panel
              title={
                inventoryItemCount > 0
                  ? t('inventory.count', { count: inventoryItemCount })
                  : t('panel.inventory.title')
              }
              className="panel-inventory flex-1"
            >
              <InventoryPanel />
            </Panel>
            {/* U-013: Quest Panel (U-077: max-height + ë‚´ë¶€ ìŠ¤í¬ë¡¤) */}
            <Panel title={t('panel.quest.title')} className="panel-quest">
              <QuestPanel />
            </Panel>
            {/* U-013: Rule Board + Mutation Timeline (U-077: max-height + ë‚´ë¶€ ìŠ¤í¬ë¡¤) */}
            <Panel title={t('panel.rule_board.title')} className="panel-rule-board">
              <RuleBoard />
              <MutationTimeline />
            </Panel>
          </aside>

          <main className="game-center">
            {/* U-078: ëª©í‘œ ë¯¸ë‹ˆ íŠ¸ë˜ì»¤ (í•­ìƒ ìƒë‹¨ì— í‘œì‹œ, Q2: Option B) */}
            <ObjectiveTracker />
            <SceneCanvas onHotspotClick={handleHotspotClick} />
            <NarrativeFeed entries={narrativeEntries} streamingText={narrativeBuffer} />
          </main>

          {/* U-082: ìš°ì¸¡ ì‚¬ì´ë“œë°” - Agent Console ì¶•ì†Œ + Economy HUD flex-1 í™•ëŒ€
               (U-049 Q1 Option A ë°˜ì „: Economyê°€ ìœ ì—° í™•ì¥, Agent Consoleì€ ì½˜í…ì¸  ê¸°ë°˜) */}
          <aside className="sidebar-right">
            <Panel title={t('panel.agent_console.title')} className="panel-agent-console" hasChrome>
              <AgentConsole />
            </Panel>
            <Panel title={t('economy.hud_label')} className="panel-economy flex-1" hasChrome>
              <EconomyHud />
            </Panel>
            <Panel title={t('panel.scanner.title')} className="panel-scanner" hasChrome>
              <ScannerSlot language={sessionLanguage} disabled={isStreaming} />
            </Panel>
          </aside>

          <footer className="game-footer">
            <ActionDeck onCardClick={handleCardClick} />
            <div className="command-input-area">
              <span className="command-prompt">&gt;</span>
              <input
                type="text"
                className="command-input"
                placeholder={isStreaming ? t('ui.processing') : t('ui.command_placeholder')}
                aria-label={t('ui.command_placeholder')}
                value={inputText}
                onChange={(e) => setInputText(e.target.value)}
                onKeyDown={handleKeyDown}
                disabled={isStreaming}
              />
              <button type="button" onClick={handleSubmit} disabled={isStreaming}>
                {isStreaming ? t('ui.wait') : t('ui.execute')}
              </button>
            </div>
          </footer>
        </div>
      </DndContext>

      {/* U-074: ì˜¨ë³´ë”© ê°€ì´ë“œ (í™”ë©´ ìš°í•˜ë‹¨ íŒì—…) */}
      <OnboardingGuide />

      {/* U-079: ì¬í™” íšë“ í† ìŠ¤íŠ¸ ì•Œë¦¼ */}
      <CurrencyToastUI />
    </>
  );
}

/**
 * U-079: ì¬í™” íšë“ í† ìŠ¤íŠ¸ ì•Œë¦¼ ì»´í¬ë„ŒíŠ¸.
 * worldStore.currencyToast ìƒíƒœë¥¼ êµ¬ë…í•˜ì—¬ íŒì—… í‘œì‹œ.
 */
function CurrencyToastUI() {
  const toast = useWorldStore((state) => state.currencyToast);
  const dismiss = useWorldStore((state) => state.dismissCurrencyToast);

  if (!toast) return null;

  return (
    <div className="currency-toast" role="alert" aria-live="assertive">
      <span className="currency-toast-icon">
        {toast.signalDelta > 0 ? '\u26A1' : '\uD83D\uDCB8'}
      </span>
      <span className="currency-toast-amount">
        {toast.signalDelta > 0 ? '+' : ''}
        {toast.signalDelta} Signal
      </span>
      <span className="currency-toast-reason">{toast.reason}</span>
      <button type="button" className="currency-toast-close" onClick={dismiss} aria-label="Close">
        {'\u2715'}
      </button>
    </div>
  );
}

export default App;
</file>

<file path="backend/src/unknown_world/models/turn.py">
"""Unknown World - TurnInput/TurnOutput Pydantic ìŠ¤í‚¤ë§ˆ.

ì´ ëª¨ë“ˆì€ Unknown Worldì˜ í•µì‹¬ ë°ì´í„° ëª¨ë¸ì„ ì •ì˜í•©ë‹ˆë‹¤.
Gemini Structured Outputsì— íˆ¬ì… ê°€ëŠ¥í•œ JSON Schema(ë¶€ë¶„ì§‘í•©)ë¥¼ ìƒì„±í•  ìˆ˜ ìˆìŠµë‹ˆë‹¤.

ì„¤ê³„ ì›ì¹™:
    - RULE-003: êµ¬ì¡°í™” ì¶œë ¥(JSON Schema) ìš°ì„  + ì´ì¤‘ ê²€ì¦
    - RULE-005: ì¬í™” ì¸ë°”ë¦¬ì–¸íŠ¸ (cost, balance_after í•„ìˆ˜, ì”ì•¡ ìŒìˆ˜ ê¸ˆì§€)
    - RULE-006: ko/en ì–¸ì–´ ì •ì±… (Language enumìœ¼ë¡œ ê³ ì •)
    - RULE-009: ì¢Œí‘œ ê·œì•½ (0~1000, bbox [ymin,xmin,ymax,xmax])

ì‚¬ìš© ì˜ˆì‹œ:
    # Gemini Structured Outputsìš© JSON Schema ìƒì„±
    schema = TurnOutput.model_json_schema()

    # ì‘ë‹µ ê²€ì¦
    output = TurnOutput.model_validate_json(gemini_response_text)

ì°¸ì¡°:
    - vibe/prd.md 8.7 (ë°ì´í„° ëª¨ë¸ ì„¤ê³„)
    - vibe/ref/structured-outputs-guide.md
    - .cursor/rules/00-core-critical.mdc
"""

from enum import Enum
from typing import Annotated

from pydantic import BaseModel, ConfigDict, Field

# =============================================================================
# ê³µí†µ Enum íƒ€ì…
# =============================================================================


class Language(str, Enum):
    """ì§€ì› ì–¸ì–´ (RULE-006).

    ko/en í˜¼í•© ì¶œë ¥ ê¸ˆì§€. TurnInput.languageë¥¼ SSOTë¡œ ì‚¼ì•„
    ëª¨ë“  UI/ë‚´ëŸ¬í‹°ë¸Œ/ì‹œìŠ¤í…œ ë©”ì‹œì§€ëŠ” ë™ì¼ ì–¸ì–´ë¡œ ê³ ì •í•©ë‹ˆë‹¤.
    """

    KO = "ko-KR"
    EN = "en-US"


class Theme(str, Enum):
    """í…Œë§ˆ ì„¤ì •."""

    DARK = "dark"
    LIGHT = "light"


class AgentPhase(str, Enum):
    """ì—ì´ì „íŠ¸ ì‹¤í–‰ ë‹¨ê³„ (RULE-008).

    ì—ì´ì „íŠ¸í˜• ì‹œìŠ¤í…œì„ì„ UIë¡œ ì¦ëª…í•˜ê¸° ìœ„í•œ ë‹¨ê³„ í‘œì‹œ.
    """

    PARSE = "parse"
    VALIDATE = "validate"
    PLAN = "plan"
    RESOLVE = "resolve"
    RENDER = "render"
    VERIFY = "verify"
    COMMIT = "commit"


class ValidationBadge(str, Enum):
    """ê²€ì¦ ë°°ì§€ (RULE-008).

    í„´ ê²°ê³¼ì— ëŒ€í•œ ê²€ì¦ ìƒíƒœë¥¼ í‘œì‹œí•©ë‹ˆë‹¤.
    """

    SCHEMA_OK = "schema_ok"
    SCHEMA_FAIL = "schema_fail"
    ECONOMY_OK = "economy_ok"
    ECONOMY_FAIL = "economy_fail"
    SAFETY_OK = "safety_ok"
    SAFETY_BLOCKED = "safety_blocked"
    CONSISTENCY_OK = "consistency_ok"
    CONSISTENCY_FAIL = "consistency_fail"


class ModelLabel(str, Enum):
    """ëª¨ë¸/í’ˆì§ˆ ì„ íƒ ë¼ë²¨ (RULE-008).

    í”„ë¡¬í”„íŠ¸ ë…¸ì¶œ ì—†ì´ "ì™œ ì´ ì„ íƒì´ì—ˆëŠ”ì§€"ë¥¼ ì‚¬ìš©ì ì¹œí™” ë¼ë²¨ë¡œ í‘œì‹œ.
    """

    FAST = "FAST"
    QUALITY = "QUALITY"
    CHEAP = "CHEAP"
    REF = "REF"


class RiskLevel(str, Enum):
    """í–‰ë™ ìœ„í—˜ë„ ìˆ˜ì¤€."""

    LOW = "low"
    MEDIUM = "medium"
    HIGH = "high"


# =============================================================================
# ê³µí†µ í•˜ìœ„ íƒ€ì…
# =============================================================================

# RULE-009: ì¢Œí‘œëŠ” 0~1000 ì •ê·œí™” ì¢Œí‘œê³„ (ì´ë¯¸ì§€ ì´í•´ bbox í¬ë§·ê³¼ í˜¸í™˜)
Coordinate = Annotated[int, Field(ge=0, le=1000, description="ì •ê·œí™” ì¢Œí‘œ (0~1000)")]


class Box2D(BaseModel):
    """2D ë°”ìš´ë”© ë°•ìŠ¤ (RULE-009).

    ì¢Œí‘œëŠ” 0~1000 ì •ê·œí™” ì¢Œí‘œê³„ì´ë©°, bboxëŠ” [ymin, xmin, ymax, xmax] ìˆœì„œì…ë‹ˆë‹¤.
    ì´ë¯¸ì§€ ì´í•´ bbox í¬ë§·ê³¼ í˜¸í™˜ë©ë‹ˆë‹¤.

    Attributes:
        ymin: Y ìµœì†Œê°’ (ìƒë‹¨)
        xmin: X ìµœì†Œê°’ (ì¢Œì¸¡)
        ymax: Y ìµœëŒ€ê°’ (í•˜ë‹¨)
        xmax: X ìµœëŒ€ê°’ (ìš°ì¸¡)
    """

    model_config = ConfigDict(extra="forbid")

    ymin: Coordinate
    xmin: Coordinate
    ymax: Coordinate
    xmax: Coordinate


class CurrencyAmount(BaseModel):
    """ì¬í™” ìˆ˜ëŸ‰.

    Attributes:
        signal: ê¸°ë³¸ ì¬í™” (í…ìŠ¤íŠ¸ í„´/ì´ë¯¸ì§€ ìƒì„±/ê³ ê¸‰ ê¸°ëŠ¥ì— ì†Œë¹„)
        memory_shard: í¬ê·€ ì¬í™” (ì¤‘ìš” ì„¤ì • ê³ ì •, ê³ í•´ìƒë„ ì´ë¯¸ì§€ ë“±ì— ì†Œë¹„)
    """

    model_config = ConfigDict(extra="forbid")

    signal: Annotated[int, Field(ge=0, description="ì‹œê·¸ë„ (ê¸°ë³¸ ì¬í™”, 0 ì´ìƒ)")]
    memory_shard: Annotated[int, Field(ge=0, description="ê¸°ì–µ íŒŒí¸ (í¬ê·€ ì¬í™”, 0 ì´ìƒ)")]


# =============================================================================
# TurnInput ê´€ë ¨ íƒ€ì…
# =============================================================================


class ClickInput(BaseModel):
    """í´ë¦­ ì…ë ¥ ì •ë³´.

    í™”ë©´ ì˜¤ë¸Œì íŠ¸ í´ë¦­ ì‹œ ì „ë‹¬ë˜ëŠ” ì •ë³´ì…ë‹ˆë‹¤.

    Attributes:
        object_id: í´ë¦­í•œ ì˜¤ë¸Œì íŠ¸ ID
        box_2d: í´ë¦­ ìœ„ì¹˜ì˜ ë°”ìš´ë”© ë°•ìŠ¤ (ì„ íƒ)
    """

    model_config = ConfigDict(extra="forbid")

    object_id: str = Field(description="í´ë¦­í•œ ì˜¤ë¸Œì íŠ¸ ID")
    box_2d: Box2D | None = Field(default=None, description="í´ë¦­ ìœ„ì¹˜ ë°”ìš´ë”© ë°•ìŠ¤ (ì„ íƒ)")


class DropInput(BaseModel):
    """ë“œë¡­ ì…ë ¥ ì •ë³´ (U-012).

    ì¸ë²¤í† ë¦¬ ì•„ì´í…œì„ í•«ìŠ¤íŒŸì— ë“œë¡­í•  ë•Œ ì „ë‹¬ë˜ëŠ” ì •ë³´ì…ë‹ˆë‹¤.

    Attributes:
        item_id: ë“œë¡­í•œ ì¸ë²¤í† ë¦¬ ì•„ì´í…œ ID
        target_object_id: ë“œë¡­ ëŒ€ìƒ í•«ìŠ¤íŒŸ ì˜¤ë¸Œì íŠ¸ ID
        target_box_2d: ë“œë¡­ ëŒ€ìƒì˜ ë°”ìš´ë”© ë°•ìŠ¤ (0~1000 ì •ê·œí™”)
    """

    model_config = ConfigDict(extra="forbid")

    item_id: str = Field(description="ë“œë¡­í•œ ì¸ë²¤í† ë¦¬ ì•„ì´í…œ ID")
    target_object_id: str = Field(description="ë“œë¡­ ëŒ€ìƒ í•«ìŠ¤íŒŸ ì˜¤ë¸Œì íŠ¸ ID")
    target_box_2d: Box2D = Field(description="ë“œë¡­ ëŒ€ìƒì˜ ë°”ìš´ë”© ë°•ìŠ¤ (0~1000 ì •ê·œí™”)")


class ClientInfo(BaseModel):
    """í´ë¼ì´ì–¸íŠ¸ ì •ë³´.

    Attributes:
        viewport_w: ë·°í¬íŠ¸ ë„ˆë¹„ (í”½ì…€)
        viewport_h: ë·°í¬íŠ¸ ë†’ì´ (í”½ì…€)
        theme: í˜„ì¬ í…Œë§ˆ (dark/light)
    """

    model_config = ConfigDict(extra="forbid")

    viewport_w: Annotated[int, Field(gt=0, description="ë·°í¬íŠ¸ ë„ˆë¹„ (í”½ì…€)")]
    viewport_h: Annotated[int, Field(gt=0, description="ë·°í¬íŠ¸ ë†’ì´ (í”½ì…€)")]
    theme: Theme = Field(default=Theme.DARK, description="í˜„ì¬ í…Œë§ˆ")


class EconomySnapshot(BaseModel):
    """ì¬í™” ìŠ¤ëƒ…ìƒ· (í´ë¼ì´ì–¸íŠ¸ â†’ ì„œë²„).

    í´ë¼ì´ì–¸íŠ¸ê°€ ë³´ìœ í•œ í˜„ì¬ ì¬í™” ìƒíƒœì…ë‹ˆë‹¤.
    ì„œë²„ëŠ” ì´ë¥¼ ê²€ì¦í•˜ê³  ë¹„ìš© ê³„ì‚°ì— ì‚¬ìš©í•©ë‹ˆë‹¤.

    Attributes:
        signal: í˜„ì¬ ì‹œê·¸ë„ ì”ì•¡
        memory_shard: í˜„ì¬ ê¸°ì–µ íŒŒí¸ ì”ì•¡
    """

    model_config = ConfigDict(extra="forbid")

    signal: Annotated[int, Field(ge=0, description="í˜„ì¬ ì‹œê·¸ë„ ì”ì•¡ (0 ì´ìƒ)")]
    memory_shard: Annotated[int, Field(ge=0, description="í˜„ì¬ ê¸°ì–µ íŒŒí¸ ì”ì•¡ (0 ì´ìƒ)")]


class TurnInput(BaseModel):
    """í„´ ì…ë ¥ (í´ë¼ì´ì–¸íŠ¸ â†’ ì„œë²„).

    ì‚¬ìš©ìê°€ í„´ì„ ì§„í–‰í•  ë•Œ ì„œë²„ë¡œ ì „ì†¡í•˜ëŠ” ì…ë ¥ ë°ì´í„°ì…ë‹ˆë‹¤.

    Attributes:
        language: ìš”ì²­ ì–¸ì–´ (ì‘ë‹µë„ ë™ì¼ ì–¸ì–´ë¡œ ê³ ì •)
        text: ì‚¬ìš©ì ìì—°ì–´ ì…ë ¥
        action_id: ì„ íƒí•œ ì•¡ì…˜ ì¹´ë“œ ID (ì„ íƒ)
        click: ì˜¤ë¸Œì íŠ¸ í´ë¦­ ì •ë³´ (ì„ íƒ)
        client: í´ë¼ì´ì–¸íŠ¸ í™˜ê²½ ì •ë³´
        economy_snapshot: í˜„ì¬ ì¬í™” ìƒíƒœ

    Example:
        >>> input_data = TurnInput(
        ...     language=Language.KO,
        ...     text="ë¬¸ì„ ì—´ì–´ë³¸ë‹¤",
        ...     economy_snapshot=EconomySnapshot(signal=100, memory_shard=5),
        ...     client=ClientInfo(viewport_w=1920, viewport_h=1080),
        ... )
    """

    model_config = ConfigDict(extra="forbid")

    language: Language = Field(description="ìš”ì²­ ì–¸ì–´ (ì‘ë‹µë„ ë™ì¼ ì–¸ì–´ë¡œ ê³ ì •)")
    text: str = Field(default="", description="ì‚¬ìš©ì ìì—°ì–´ ì…ë ¥")
    action_id: str | None = Field(default=None, description="ì„ íƒí•œ ì•¡ì…˜ ì¹´ë“œ ID (ì„ íƒ)")
    click: ClickInput | None = Field(default=None, description="ì˜¤ë¸Œì íŠ¸ í´ë¦­ ì •ë³´ (ì„ íƒ)")
    drop: DropInput | None = Field(default=None, description="ì•„ì´í…œ ë“œë¡­ ì •ë³´ (ì„ íƒ, U-012)")
    client: ClientInfo = Field(description="í´ë¼ì´ì–¸íŠ¸ í™˜ê²½ ì •ë³´")
    economy_snapshot: EconomySnapshot = Field(description="í˜„ì¬ ì¬í™” ìƒíƒœ")
    previous_image_url: str | None = Field(
        default=None,
        description="ì´ì „ í„´ ì´ë¯¸ì§€ URL (U-068: ì°¸ì¡° ì´ë¯¸ì§€ë¡œ ì‚¬ìš©í•˜ì—¬ ì—°ì†ì„± ìœ ì§€)",
    )


# =============================================================================
# TurnOutput ê´€ë ¨ íƒ€ì… - UI
# =============================================================================


class CostEstimate(BaseModel):
    """ë¹„ìš© ì¶”ì •ì¹˜ (ìµœì†Œ/ìµœëŒ€ ë²”ìœ„)."""

    model_config = ConfigDict(extra="forbid")

    min: CurrencyAmount = Field(description="ìµœì†Œ ì˜ˆìƒ ë¹„ìš©")
    max: CurrencyAmount = Field(description="ìµœëŒ€ ì˜ˆìƒ ë¹„ìš©")


class ActionCard(BaseModel):
    """ì•¡ì…˜ ì¹´ë“œ (Action Deck) - U-065 ë‹¨ìˆœí™”.

    ë§¤ í„´ AIê°€ ì¶”ì²œí•˜ëŠ” í–‰ë™ ì¹´ë“œì…ë‹ˆë‹¤.
    Gemini Structured Outputs ì œí•œ ëŒ€ì‘ì„ ìœ„í•´ í•µì‹¬ í•„ë“œë§Œ ìœ ì§€í•©ë‹ˆë‹¤.

    U-065 ë‹¨ìˆœí™”:
        - ì œê±°ëœ í•„ë“œ: description, cost_estimate, hint, reward_hint, disabled_reason
        - risk, is_alternativeëŠ” ìœ ì§€ (ê²Œì„ ë©”ì¹´ë‹‰ì— í•„ìˆ˜)
        - ì œê±°ëœ ì •ë³´ëŠ” narrativeì—ì„œ ìì—°ì–´ë¡œ í‘œí˜„

    Attributes:
        id: ì¹´ë“œ ê³ ìœ  ID
        label: ì¹´ë“œ ë¼ë²¨ (í‘œì‹œìš©)
        cost: ì˜ˆìƒ ë¹„ìš© (ê¸°ë³¸)
        risk: ìœ„í—˜ë„
        enabled: ì‹¤í–‰ ê°€ëŠ¥ ì—¬ë¶€ (ì„œë²„ íŒë‹¨)
        is_alternative: ì €ë¹„ìš© ëŒ€ì•ˆ ì¹´ë“œ ì—¬ë¶€
    """

    model_config = ConfigDict(extra="forbid")

    id: str = Field(description="ì¹´ë“œ ê³ ìœ  ID")
    label: str = Field(description="ì¹´ë“œ ë¼ë²¨ (í‘œì‹œìš©)")
    cost: CurrencyAmount = Field(description="ì˜ˆìƒ ë¹„ìš© (ê¸°ë³¸)")
    risk: RiskLevel = Field(default=RiskLevel.LOW, description="ìœ„í—˜ë„")
    enabled: bool = Field(default=True, description="ì‹¤í–‰ ê°€ëŠ¥ ì—¬ë¶€ (ì„œë²„ íŒë‹¨)")
    is_alternative: bool = Field(default=False, description="ì €ë¹„ìš© ëŒ€ì•ˆ ì¹´ë“œ ì—¬ë¶€")


class SceneObject(BaseModel):
    """ì¥ë©´ ì˜¤ë¸Œì íŠ¸ (í´ë¦­ ê°€ëŠ¥í•œ í•«ìŠ¤íŒŸ).

    í™”ë©´ì—ì„œ í´ë¦­ ê°€ëŠ¥í•œ ì˜¤ë¸Œì íŠ¸ì…ë‹ˆë‹¤.
    ì¢Œí‘œëŠ” 0~1000 ì •ê·œí™” ì¢Œí‘œê³„ë¥¼ ì‚¬ìš©í•©ë‹ˆë‹¤ (RULE-009).

    Attributes:
        id: ì˜¤ë¸Œì íŠ¸ ê³ ìœ  ID
        label: ì˜¤ë¸Œì íŠ¸ ë¼ë²¨ (í‘œì‹œìš©)
        box_2d: ë°”ìš´ë”© ë°•ìŠ¤ [ymin, xmin, ymax, xmax]
        interaction_hint: ìƒí˜¸ì‘ìš© íŒíŠ¸ (ì„ íƒ)
    """

    model_config = ConfigDict(extra="forbid")

    id: str = Field(description="ì˜¤ë¸Œì íŠ¸ ê³ ìœ  ID")
    label: str = Field(description="ì˜¤ë¸Œì íŠ¸ ë¼ë²¨ (í‘œì‹œìš©)")
    box_2d: Box2D = Field(description="ë°”ìš´ë”© ë°•ìŠ¤")
    interaction_hint: str | None = Field(default=None, description="ìƒí˜¸ì‘ìš© íŒíŠ¸ (ì„ íƒ)")


class ActionDeck(BaseModel):
    """ì•¡ì…˜ ë± (Q1 ê²°ì •: ui.action_deck.cards[] êµ¬ì¡°) - U-065 ë‹¨ìˆœí™”.

    ë§¤ í„´ AIê°€ ì œì‹œí•˜ëŠ” ì¶”ì²œ í–‰ë™ ì¹´ë“œ ë±ì…ë‹ˆë‹¤.

    U-065 ë‹¨ìˆœí™”:
        - max_length: 10 â†’ 5 (Gemini ìŠ¤í‚¤ë§ˆ ì œí•œ ëŒ€ì‘, Q2 ê²°ì •)

    Attributes:
        cards: ì•¡ì…˜ ì¹´ë“œ ëª©ë¡ (3~5ì¥ ê¶Œì¥)
    """

    model_config = ConfigDict(extra="forbid")

    cards: list[ActionCard] = Field(
        default=[],
        min_length=0,
        max_length=5,
        description="ì•¡ì…˜ ì¹´ë“œ ëª©ë¡ (3~5ì¥ ê¶Œì¥)",
    )


class UIOutput(BaseModel):
    """UI ì¶œë ¥ ë°ì´í„° - U-065 ë‹¨ìˆœí™”.

    AIê°€ ìƒì„±í•œ UI ìš”ì†Œë“¤ì…ë‹ˆë‹¤.
    ì±„íŒ… ë²„ë¸”ì´ ì•„ë‹Œ ê²Œì„ UIë¡œ í‘œí˜„ë©ë‹ˆë‹¤ (RULE-002).

    U-065 ë‹¨ìˆœí™”:
        - objects max_length: 5ë¡œ ì œí•œ (Q2 ê²°ì •)

    Attributes:
        action_deck: ì•¡ì…˜ ì¹´ë“œ ë± (Q1 ê²°ì •: Option A ì±„íƒ)
        objects: í´ë¦­ ê°€ëŠ¥í•œ ì¥ë©´ ì˜¤ë¸Œì íŠ¸ ëª©ë¡ (ìµœëŒ€ 5ê°œ)
    """

    model_config = ConfigDict(extra="forbid")

    action_deck: ActionDeck = Field(default_factory=ActionDeck, description="ì•¡ì…˜ ì¹´ë“œ ë±")
    objects: list[SceneObject] = Field(
        default=[], max_length=5, description="í´ë¦­ ê°€ëŠ¥í•œ ì¥ë©´ ì˜¤ë¸Œì íŠ¸ ëª©ë¡ (ìµœëŒ€ 5ê°œ)"
    )


# =============================================================================
# TurnOutput ê´€ë ¨ íƒ€ì… - World
# =============================================================================


class MemoryPin(BaseModel):
    """ì¤‘ìš” ì„¤ì • ê³ ì • í›„ë³´.

    ì‚¬ìš©ìê°€ Memory Shardë¥¼ ì†Œë¹„í•´ ê³ ì •í•  ìˆ˜ ìˆëŠ” ì¤‘ìš” ì„¤ì •ì…ë‹ˆë‹¤.

    Attributes:
        id: í•€ ê³ ìœ  ID
        content: ê³ ì •í•  ë‚´ìš©
        cost: ê³ ì •ì— í•„ìš”í•œ ë¹„ìš©
    """

    model_config = ConfigDict(extra="forbid")

    id: str = Field(description="í•€ ê³ ìœ  ID")
    content: str = Field(description="ê³ ì •í•  ë‚´ìš©")
    cost: CurrencyAmount = Field(description="ê³ ì •ì— í•„ìš”í•œ ë¹„ìš©")


class WorldRule(BaseModel):
    """ì„¸ê³„ ê·œì¹™ (Rule Board).

    í˜„ì¬ ì„¸ê³„ì— ì ìš© ì¤‘ì¸ ë¬¼ë¦¬ ë²•ì¹™ì´ë‚˜ ë©”íƒ€ ê·œì¹™ì…ë‹ˆë‹¤.

    Attributes:
        id: ê·œì¹™ ê³ ìœ  ID
        label: ê·œì¹™ ì´ë¦„
        description: ê·œì¹™ ìƒì„¸ ì„¤ëª… (ì„ íƒ)
    """

    model_config = ConfigDict(extra="forbid")

    id: str = Field(description="ê·œì¹™ ê³ ìœ  ID")
    label: str = Field(description="ê·œì¹™ ì´ë¦„")
    description: str | None = Field(default=None, description="ê·œì¹™ ìƒì„¸ ì„¤ëª… (ì„ íƒ)")


class Quest(BaseModel):
    """í€˜ìŠ¤íŠ¸/ëª©í‘œ (Quest Panel) - U-078 ëª©í‘œ ì‹œìŠ¤í…œ ê°•í™”.

    í”Œë ˆì´ì–´ê°€ ë‹¬ì„±í•´ì•¼ í•˜ëŠ” í˜„ì¬ ëª©í‘œì…ë‹ˆë‹¤.
    is_main=trueì¸ í€˜ìŠ¤íŠ¸ê°€ ì£¼ ëª©í‘œ(Main Objective)ì´ë©°,
    ë‚˜ë¨¸ì§€ëŠ” ì„œë¸Œ ëª©í‘œ(Sub-objectives)ë¡œ í‘œì‹œë©ë‹ˆë‹¤.

    Attributes:
        id: í€˜ìŠ¤íŠ¸ ê³ ìœ  ID
        label: í€˜ìŠ¤íŠ¸ ì´ë¦„
        is_completed: ë‹¬ì„± ì—¬ë¶€
        description: ëª©í‘œ ìƒì„¸ ì„¤ëª… (ì„ íƒ)
        is_main: ì£¼ ëª©í‘œ ì—¬ë¶€ (trueì´ë©´ Quest íŒ¨ë„ ìƒë‹¨ì— ê°•ì¡° í‘œì‹œ)
        progress: ì§„í–‰ë¥  (0~100, ì£¼ ëª©í‘œì—ì„œ ì‚¬ìš©)
        reward_signal: ë‹¬ì„± ì‹œ Signal ë³´ìƒëŸ‰ (0ì´ë©´ ë³´ìƒ ì—†ìŒ)
    """

    model_config = ConfigDict(extra="forbid")

    id: str = Field(description="í€˜ìŠ¤íŠ¸ ê³ ìœ  ID")
    label: str = Field(description="í€˜ìŠ¤íŠ¸ ì´ë¦„")
    is_completed: bool = Field(default=False, description="ë‹¬ì„± ì—¬ë¶€")
    description: str | None = Field(default=None, description="ëª©í‘œ ìƒì„¸ ì„¤ëª… (ì„ íƒ)")
    is_main: bool = Field(default=False, description="ì£¼ ëª©í‘œ ì—¬ë¶€")
    progress: Annotated[int, Field(ge=0, le=100, description="ì§„í–‰ë¥  (0~100)")] = 0
    reward_signal: Annotated[int, Field(ge=0, description="ë‹¬ì„± ì‹œ Signal ë³´ìƒëŸ‰")] = 0


class InventoryItemData(BaseModel):
    """ì¸ë²¤í† ë¦¬ ì•„ì´í…œ ë°ì´í„° (U-075[Mvp]).

    TurnOutputì—ì„œ ì¶”ê°€ë˜ëŠ” ì•„ì´í…œì˜ ìƒì„¸ ì •ë³´ì…ë‹ˆë‹¤.
    ì•„ì´ì½˜ URLì€ ë³„ë„ APIë¡œ ìƒì„±ë©ë‹ˆë‹¤ (Q1: placeholder ë¨¼ì € í‘œì‹œ).

    Attributes:
        id: ì•„ì´í…œ ê³ ìœ  ID
        label: ì•„ì´í…œ í‘œì‹œ ì´ë¦„ (í˜„ì¬ ì–¸ì–´ì— ë§ê²Œ)
        description: ì•„ì´í…œ ì„¤ëª… (ì•„ì´ì½˜ ìƒì„±ìš©)
        icon_url: ì•„ì´ì½˜ URL (ì„ íƒ, ìºì‹œëœ ê²½ìš°)
        quantity: ì•„ì´í…œ ìˆ˜ëŸ‰
    """

    model_config = ConfigDict(extra="forbid")

    id: str = Field(description="ì•„ì´í…œ ê³ ìœ  ID")
    label: str = Field(description="ì•„ì´í…œ í‘œì‹œ ì´ë¦„ (í˜„ì¬ ì–¸ì–´ì— ë§ê²Œ)")
    description: str = Field(default="", description="ì•„ì´í…œ ì„¤ëª… (ì•„ì´ì½˜ ìƒì„±ìš©)")
    icon_url: str | None = Field(default=None, description="ì•„ì´ì½˜ URL (ì„ íƒ, ìºì‹œëœ ê²½ìš°)")
    quantity: int = Field(default=1, ge=1, description="ì•„ì´í…œ ìˆ˜ëŸ‰")


class WorldDelta(BaseModel):
    """ì„¸ê³„ ìƒíƒœ ë³€í™” (Q2 ê²°ì •: Option A - delta ì¤‘ì‹¬) - U-065 ë‹¨ìˆœí™”.

    ì´ë²ˆ í„´ì—ì„œ ë³€ê²½ëœ ì„¸ê³„ ìƒíƒœë¥¼ ë‚˜íƒ€ëƒ…ë‹ˆë‹¤.
    snapshotì€ SaveGameì—ë§Œ ì €ì¥í•˜ê³ , ë§¤ í„´ì€ deltaë§Œ ì „ì†¡í•©ë‹ˆë‹¤.

    U-065 ë‹¨ìˆœí™” (Q3 ê²°ì •: Option A):
        - rules_changed, quests_updated â†’ ë°°ì—´ í¬ê¸° ì œí•œ (ìµœëŒ€ 3ê°œ)
        - memory_pins â†’ ë°°ì—´ í¬ê¸° ì œí•œ (ìµœëŒ€ 2ê°œ)
        - ë³µì¡í•œ ì¤‘ì²© ê°ì²´ì˜ ë°°ì—´ í¬ê¸° ì¶•ì†Œ
        - ìƒì„¸ ì •ë³´ëŠ” narrativeì—ì„œ ìì—°ì–´ë¡œ í‘œí˜„

    Attributes:
        rules_changed: ë³€ê²½ë˜ê±°ë‚˜ ì¶”ê°€ëœ ê·œì¹™ ëª©ë¡ (ìµœëŒ€ 3ê°œ)
        inventory_added: ì¶”ê°€ëœ ì¸ë²¤í† ë¦¬ ì•„ì´í…œ (ìµœëŒ€ 5ê°œ)
        inventory_removed: ì œê±°ëœ ì¸ë²¤í† ë¦¬ ì•„ì´í…œ (ìµœëŒ€ 5ê°œ)
        quests_updated: ì—…ë°ì´íŠ¸ëœ í€˜ìŠ¤íŠ¸(ëª©í‘œ) ëª©ë¡ (ìµœëŒ€ 3ê°œ)
        relationships_changed: ë³€ê²½ëœ ê´€ê³„ (ìµœëŒ€ 3ê°œ)
        memory_pins: ì¤‘ìš” ì„¤ì • ê³ ì • í›„ë³´ (ìµœëŒ€ 2ê°œ)
    """

    model_config = ConfigDict(extra="forbid")

    rules_changed: list[WorldRule] = Field(
        default=[], max_length=3, description="ë³€ê²½ëœ ê·œì¹™ ëª©ë¡ (ìµœëŒ€ 3ê°œ)"
    )
    inventory_added: list[InventoryItemData] = Field(
        default=[], max_length=5, description="ì¶”ê°€ëœ ì¸ë²¤í† ë¦¬ ì•„ì´í…œ (ìµœëŒ€ 5ê°œ)"
    )
    inventory_removed: list[str] = Field(
        default=[], max_length=5, description="ì œê±°ëœ ì¸ë²¤í† ë¦¬ ì•„ì´í…œ (ìµœëŒ€ 5ê°œ)"
    )
    quests_updated: list[Quest] = Field(
        default=[], max_length=3, description="ì—…ë°ì´íŠ¸ëœ í€˜ìŠ¤íŠ¸/ëª©í‘œ ëª©ë¡ (ìµœëŒ€ 3ê°œ)"
    )
    relationships_changed: list[str] = Field(
        default=[], max_length=3, description="ë³€ê²½ëœ ê´€ê³„ (ìµœëŒ€ 3ê°œ)"
    )
    memory_pins: list[MemoryPin] = Field(
        default=[], max_length=2, description="ì¤‘ìš” ì„¤ì • ê³ ì • í›„ë³´ (ìµœëŒ€ 2ê°œ)"
    )


# =============================================================================
# TurnOutput ê´€ë ¨ íƒ€ì… - Render
# =============================================================================


class ImageJob(BaseModel):
    """ì´ë¯¸ì§€ ìƒì„± ì‘ì—… - U-065 ë‹¨ìˆœí™”.

    ì¡°ê±´ë¶€ ì´ë¯¸ì§€ ìƒì„±/í¸ì§‘ ìš”ì²­ì…ë‹ˆë‹¤.
    ì´ë¯¸ì§€ ìƒì„±ì´ ëŠë¦´ ê²½ìš° í…ìŠ¤íŠ¸ ìš°ì„  ì¶œë ¥ + Lazy Loadingì„ ì‚¬ìš©í•©ë‹ˆë‹¤.

    U-065 ë‹¨ìˆœí™”:
        - reference_image_ids: ë°°ì—´ í¬ê¸° ì œí•œ (ìµœëŒ€ 2ê°œ)
        - ê¸°íƒ€ í•„ë“œëŠ” ìœ ì§€ (ì´ë¯¸ì§€ íŒŒì´í”„ë¼ì¸ í•„ìˆ˜)

    Attributes:
        should_generate: ì´ë¯¸ì§€ë¥¼ ìƒì„±í•´ì•¼ í•˜ëŠ”ì§€
        prompt: ì´ë¯¸ì§€ ìƒì„± í”„ë¡¬í”„íŠ¸
        model_label: ëª¨ë¸ ì„ íƒ ë¼ë²¨ (FAST/QUALITY/CHEAP/REF)
        aspect_ratio: ê°€ë¡œì„¸ë¡œ ë¹„ìœ¨ (ì˜ˆ: "16:9", "1:1")
        image_size: ì´ë¯¸ì§€ í¬ê¸° (ì˜ˆ: "1024x1024")
        reference_image_ids: ì°¸ì¡° ì´ë¯¸ì§€ ID ëª©ë¡ (ìµœëŒ€ 2ê°œ)
    """

    model_config = ConfigDict(extra="forbid")

    should_generate: bool = Field(description="ì´ë¯¸ì§€ë¥¼ ìƒì„±í•´ì•¼ í•˜ëŠ”ì§€")
    prompt: str = Field(default="", description="ì´ë¯¸ì§€ ìƒì„± í”„ë¡¬í”„íŠ¸")
    model_label: ModelLabel = Field(default=ModelLabel.FAST, description="ëª¨ë¸ ì„ íƒ ë¼ë²¨")
    aspect_ratio: str = Field(default="16:9", description="ê°€ë¡œì„¸ë¡œ ë¹„ìœ¨")
    image_size: str = Field(default="1024x1024", description="ì´ë¯¸ì§€ í¬ê¸°")
    reference_image_ids: list[str] = Field(
        default=[], max_length=2, description="ì°¸ì¡° ì´ë¯¸ì§€ ID ëª©ë¡ (ìµœëŒ€ 2ê°œ)"
    )
    reference_image_url: str | None = Field(
        default=None,
        description="ì°¸ì¡° ì´ë¯¸ì§€ URL (U-068: ì´ì „ í„´ ì´ë¯¸ì§€ë¥¼ ì°¸ì¡°í•˜ì—¬ ì—°ì†ì„± ìœ ì§€)",
    )


class RenderOutput(BaseModel):
    """ë Œë”ë§ ì¶œë ¥ ë°ì´í„°.

    ì´ë¯¸ì§€ ìƒì„±/í¸ì§‘ ê´€ë ¨ ì •ë³´ì…ë‹ˆë‹¤.
    image_jobì€ AI ëª¨ë¸ì´ ìƒì„±í•˜ê³ , image_url/image_idëŠ” í›„ì²˜ë¦¬ì—ì„œ ì±„ì›Œì§‘ë‹ˆë‹¤.

    Attributes:
        image_job: ì´ë¯¸ì§€ ìƒì„± ì‘ì—… (ì„ íƒ, AI ëª¨ë¸ ìƒì„±)
        image_url: ìƒì„±ëœ ì´ë¯¸ì§€ URL (ì„ íƒ, í›„ì²˜ë¦¬ì—ì„œ ì±„ì›€, U-053)
        image_id: ìƒì„±ëœ ì´ë¯¸ì§€ ID (ì„ íƒ, í›„ì²˜ë¦¬ì—ì„œ ì±„ì›€, U-053)
        generation_time_ms: ì´ë¯¸ì§€ ìƒì„± ì†Œìš” ì‹œê°„ (ë°€ë¦¬ì´ˆ, ì„ íƒ, U-053)
    """

    model_config = ConfigDict(extra="forbid")

    image_job: ImageJob | None = Field(default=None, description="ì´ë¯¸ì§€ ìƒì„± ì‘ì—… (ì„ íƒ)")
    image_url: str | None = Field(
        default=None, description="ìƒì„±ëœ ì´ë¯¸ì§€ URL (í›„ì²˜ë¦¬ì—ì„œ ì±„ì›€, U-053)"
    )
    image_id: str | None = Field(
        default=None, description="ìƒì„±ëœ ì´ë¯¸ì§€ ID (í›„ì²˜ë¦¬ì—ì„œ ì±„ì›€, U-053)"
    )
    generation_time_ms: int | None = Field(
        default=None, description="ì´ë¯¸ì§€ ìƒì„± ì†Œìš” ì‹œê°„ (ms, U-053)"
    )


# =============================================================================
# TurnOutput ê´€ë ¨ íƒ€ì… - Economy
# =============================================================================


class EconomyOutput(BaseModel):
    """ê²½ì œ ì¶œë ¥ ë°ì´í„° (RULE-005).

    ì´ë²ˆ í„´ì˜ ë¹„ìš©ê³¼ ì”ì•¡ ì •ë³´ì…ë‹ˆë‹¤.
    ì”ì•¡ ìŒìˆ˜ëŠ” ì ˆëŒ€ ë¶ˆê°€ (ì„œë²„ Hard gate).

    Attributes:
        cost: ì´ë²ˆ í„´ì— ì†Œë¹„ëœ ë¹„ìš©
        balance_after: ì†Œë¹„ í›„ ì”ì•¡
        credit: ì‚¬ìš© ì¤‘ì¸ í¬ë ˆë”§ (ë¹š, Signal ë‹¨ìœ„, U-079)
        low_balance_warning: ì”ì•¡ ë¶€ì¡± ê²½ê³  ì—¬ë¶€ (U-079)

    Important:
        - costì™€ balance_afterëŠ” í•­ìƒ í¬í•¨ë˜ì–´ì•¼ í•©ë‹ˆë‹¤.
        - balance_afterì˜ signalê³¼ memory_shardëŠ” 0 ì´ìƒì´ì–´ì•¼ í•©ë‹ˆë‹¤.
    """

    model_config = ConfigDict(extra="forbid")

    cost: CurrencyAmount = Field(description="ì´ë²ˆ í„´ì— ì†Œë¹„ëœ ë¹„ìš©")
    balance_after: CurrencyAmount = Field(description="ì†Œë¹„ í›„ ì”ì•¡")
    credit: int = Field(default=0, description="ì‚¬ìš© ì¤‘ì¸ í¬ë ˆë”§ (ë¹š, Signal ë‹¨ìœ„)")
    low_balance_warning: bool = Field(default=False, description="ì”ì•¡ ë¶€ì¡± ê²½ê³  ì—¬ë¶€")


# =============================================================================
# TurnOutput ê´€ë ¨ íƒ€ì… - Safety
# =============================================================================


class SafetyOutput(BaseModel):
    """ì•ˆì „ ì¶œë ¥ ë°ì´í„°.

    ì•ˆì „ ì •ì±… ê´€ë ¨ ì •ë³´ì…ë‹ˆë‹¤.
    ì°¨ë‹¨ ì‹œ ëª…ì‹œì  ë©”ì‹œì§€ì™€ í•¨ê»˜ ì•ˆì „í•œ ëŒ€ì²´ ê²°ê³¼ë¥¼ ì œê³µí•©ë‹ˆë‹¤.

    Attributes:
        blocked: ì•ˆì „ ì •ì±…ì— ì˜í•´ ì°¨ë‹¨ë˜ì—ˆëŠ”ì§€
        message: ì°¨ë‹¨ ì‹œ ì‚¬ìš©ìì—ê²Œ í‘œì‹œí•  ë©”ì‹œì§€ (ì„ íƒ)
    """

    model_config = ConfigDict(extra="forbid")

    blocked: bool = Field(default=False, description="ì•ˆì „ ì •ì±…ì— ì˜í•´ ì°¨ë‹¨ë˜ì—ˆëŠ”ì§€")
    message: str | None = Field(default=None, description="ì°¨ë‹¨ ì‹œ ì‚¬ìš©ìì—ê²Œ í‘œì‹œí•  ë©”ì‹œì§€ (ì„ íƒ)")


# =============================================================================
# TurnOutput ê´€ë ¨ íƒ€ì… - Agent Console
# =============================================================================


class AgentConsole(BaseModel):
    """ì—ì´ì „íŠ¸ ì½˜ì†” ë°ì´í„° (RULE-008) - U-065 ë‹¨ìˆœí™”.

    ì—ì´ì „íŠ¸í˜• ì‹œìŠ¤í…œì„ì„ UIë¡œ ì¦ëª…í•˜ê¸° ìœ„í•œ ì •ë³´ì…ë‹ˆë‹¤.
    ê³„íš/ì‹¤í–‰/ê²€ì¦/ë³µêµ¬ì˜ í”ì ì„ í‘œì‹œí•©ë‹ˆë‹¤.

    U-065 ë‹¨ìˆœí™”:
        - badges: ë°°ì—´ í¬ê¸° ì œí•œ (ìµœëŒ€ 4ê°œ)

    U-069 ì¶”ê°€:
        - model_label: í˜„ì¬ ì‚¬ìš© ì¤‘ì¸ í…ìŠ¤íŠ¸ ëª¨ë¸ ë¼ë²¨ (FAST/QUALITY)

    Attributes:
        current_phase: í˜„ì¬ ì‹¤í–‰ ë‹¨ê³„
        badges: ê²€ì¦ ë°°ì§€ ëª©ë¡ (ìµœëŒ€ 4ê°œ)
        repair_count: ìë™ ë³µêµ¬ ì‹œë„ íšŸìˆ˜
        model_label: í˜„ì¬ ì‚¬ìš© ì¤‘ì¸ í…ìŠ¤íŠ¸ ëª¨ë¸ ë¼ë²¨ (U-069)
    """

    model_config = ConfigDict(extra="forbid")

    current_phase: AgentPhase = Field(default=AgentPhase.COMMIT, description="í˜„ì¬ ì‹¤í–‰ ë‹¨ê³„")
    badges: list[ValidationBadge] = Field(
        default=[], max_length=4, description="ê²€ì¦ ë°°ì§€ ëª©ë¡ (ìµœëŒ€ 4ê°œ)"
    )
    repair_count: Annotated[int, Field(ge=0, description="ìë™ ë³µêµ¬ ì‹œë„ íšŸìˆ˜")] = 0
    model_label: ModelLabel = Field(
        default=ModelLabel.FAST,
        description="í˜„ì¬ ì‚¬ìš© ì¤‘ì¸ í…ìŠ¤íŠ¸ ëª¨ë¸ ë¼ë²¨ (U-069: FAST/QUALITY)",
    )


# =============================================================================
# TurnOutput (ë©”ì¸ ì‘ë‹µ ìŠ¤í‚¤ë§ˆ)
# =============================================================================


class TurnOutput(BaseModel):
    """í„´ ì¶œë ¥ (ì„œë²„ â†’ í´ë¼ì´ì–¸íŠ¸).

    ì„œë²„ê°€ í„´ ì²˜ë¦¬ í›„ í´ë¼ì´ì–¸íŠ¸ë¡œ ë°˜í™˜í•˜ëŠ” êµ¬ì¡°í™”ëœ ì‘ë‹µì…ë‹ˆë‹¤.
    Gemini Structured Outputs(JSON Schema)ë¡œ ê°•ì œë©ë‹ˆë‹¤.

    Hard Gate í•„ë“œ (RULE-003/004/005):
        - economy: costì™€ balance_after í•„ìˆ˜, ì”ì•¡ ìŒìˆ˜ ê¸ˆì§€
        - safety: blocked ì‹œ ì•ˆì „í•œ ëŒ€ì²´ ê²°ê³¼ ì œê³µ
        - language: ìš”ì²­ ì–¸ì–´ì™€ ë™ì¼í•˜ê²Œ ê³ ì • (í˜¼í•© ì¶œë ¥ ê¸ˆì§€)

    Attributes:
        language: ì‘ë‹µ ì–¸ì–´ (ìš”ì²­ê³¼ ë™ì¼)
        narrative: ë‚´ëŸ¬í‹°ë¸Œ í…ìŠ¤íŠ¸ (í‘œì‹œìš©)
        ui: UI ìš”ì†Œ (ì•¡ì…˜ ë±, ì˜¤ë¸Œì íŠ¸)
        world: ì„¸ê³„ ìƒíƒœ ë³€í™” (delta ì¤‘ì‹¬)
        render: ë Œë”ë§ ì •ë³´ (ì´ë¯¸ì§€ ìƒì„± ì‘ì—…)
        economy: ê²½ì œ ì •ë³´ (ë¹„ìš©, ì”ì•¡)
        safety: ì•ˆì „ ì •ì±… ì •ë³´
        agent_console: ì—ì´ì „íŠ¸ ì‹¤í–‰ ì •ë³´ (ë‹¨ê³„, ë°°ì§€, ë³µêµ¬ íšŸìˆ˜)

    Example:
        >>> output = TurnOutput(
        ...     language=Language.KO,
        ...     narrative="ë¬¸ì´ ì‚ê±±ê±°ë¦¬ë©° ì—´ë¦½ë‹ˆë‹¤...",
        ...     economy=EconomyOutput(
        ...         cost=CurrencyAmount(signal=5, memory_shard=0),
        ...         balance_after=CurrencyAmount(signal=95, memory_shard=5),
        ...     ),
        ...     safety=SafetyOutput(blocked=False),
        ... )
        >>> schema = TurnOutput.model_json_schema()

    Schema Generation:
        >>> # Gemini Structured Outputsìš© JSON Schema ìƒì„±
        >>> json_schema = TurnOutput.model_json_schema()
        >>> # response_json_schema íŒŒë¼ë¯¸í„°ì— ì „ë‹¬
        >>> config = {
        ...     "response_mime_type": "application/json",
        ...     "response_json_schema": json_schema,
        ... }
    """

    model_config = ConfigDict(extra="forbid")

    # í•„ìˆ˜ í•„ë“œ (Hard Gate)
    language: Language = Field(description="ì‘ë‹µ ì–¸ì–´ (ìš”ì²­ê³¼ ë™ì¼)")
    narrative: str = Field(description="ë‚´ëŸ¬í‹°ë¸Œ í…ìŠ¤íŠ¸ (í‘œì‹œìš©)")
    economy: EconomyOutput = Field(description="ê²½ì œ ì •ë³´ (ë¹„ìš©, ì”ì•¡)")
    safety: SafetyOutput = Field(description="ì•ˆì „ ì •ì±… ì •ë³´")

    # UI ê´€ë ¨ í•„ë“œ
    ui: UIOutput = Field(default_factory=UIOutput, description="UI ìš”ì†Œ")

    # ì„¸ê³„ ìƒíƒœ í•„ë“œ
    world: WorldDelta = Field(default_factory=WorldDelta, description="ì„¸ê³„ ìƒíƒœ ë³€í™” (delta)")

    # ë Œë”ë§ í•„ë“œ
    render: RenderOutput = Field(default_factory=RenderOutput, description="ë Œë”ë§ ì •ë³´")

    # ì—ì´ì „íŠ¸ ì½˜ì†” í•„ë“œ
    agent_console: AgentConsole = Field(
        default_factory=AgentConsole, description="ì—ì´ì „íŠ¸ ì‹¤í–‰ ì •ë³´"
    )
</file>

<file path="backend/src/unknown_world/services/image_understanding.py">
"""Unknown World - ì´ë¯¸ì§€ ì´í•´(Scanner) ì„œë¹„ìŠ¤.

ì´ ëª¨ë“ˆì€ ì‚¬ìš©ìê°€ ì—…ë¡œë“œí•œ ì´ë¯¸ì§€ë¥¼ ë¶„ì„í•˜ì—¬ ìº¡ì…˜, ì˜¤ë¸Œì íŠ¸(bbox),
ì•„ì´í…œ í›„ë³´ë¥¼ ì¶”ì¶œí•˜ëŠ” ì„œë¹„ìŠ¤ë¥¼ ì œê³µí•©ë‹ˆë‹¤.

ì„¤ê³„ ì›ì¹™:
    - RULE-004: ì‹¤íŒ¨ ì‹œ ì•ˆì „í•œ í´ë°± (í…ìŠ¤íŠ¸-only ìº¡ì…˜)
    - RULE-007: í”„ë¡¬í”„íŠ¸ ì›ë¬¸/ë¹„ë°€ì •ë³´ ë…¸ì¶œ ê¸ˆì§€
    - RULE-009: bboxëŠ” 0~1000 ì •ê·œí™” + [ymin, xmin, ymax, xmax]

í˜ì–´ë§ ì§ˆë¬¸ ê²°ì •:
    - Q1: Option A (multipart ì—…ë¡œë“œë¡œ ì²˜ë¦¬)

ì°¸ì¡°:
    - vibe/unit-plans/U-021[Mvp].md
    - vibe/tech-stack.md (ë¹„ì „ ëª¨ë¸: gemini-3-flash-preview)
    - .cursor/rules/00-core-critical.mdc
"""

from __future__ import annotations

import asyncio
import json
import logging
import os
import random
import time
import uuid
from typing import TYPE_CHECKING, Any, cast

from unknown_world.config.models import ModelLabel, get_model_id
from unknown_world.models.scanner import (
    DetectedObject,
    ItemCandidate,
    ScanResult,
    ScanStatus,
)
from unknown_world.models.turn import Box2D, Language
from unknown_world.orchestrator.prompt_loader import load_prompt
from unknown_world.services.genai_client import ENV_UW_MODE, GenAIMode
from unknown_world.storage.validation import (
    ALLOWED_IMAGE_MIME_TYPES,
    BBOX_MAX,
    BBOX_MIN,
    MAX_IMAGE_FILE_SIZE_BYTES,
    validate_image_upload,
)

if TYPE_CHECKING:
    from google.genai import Client

# =============================================================================
# ë¡œê±° ì„¤ì • (í”„ë¡¬í”„íŠ¸/ë¹„ë°€ì •ë³´ ë…¸ì¶œ ê¸ˆì§€)
# =============================================================================

logger = logging.getLogger(__name__)

# =============================================================================
# í˜¸í™˜ì„±ì„ ìœ„í•œ ìƒìˆ˜ ë³„ì¹­ (api/scanner.pyì—ì„œ import)
# =============================================================================

ALLOWED_MIME_TYPES = ALLOWED_IMAGE_MIME_TYPES
"""ì§€ì›í•˜ëŠ” ì´ë¯¸ì§€ MIME íƒ€ì… (í˜¸í™˜ì„± ë³„ì¹­)."""

MAX_FILE_SIZE_BYTES = MAX_IMAGE_FILE_SIZE_BYTES
"""ìµœëŒ€ ì´ë¯¸ì§€ íŒŒì¼ í¬ê¸° (í˜¸í™˜ì„± ë³„ì¹­)."""

# =============================================================================
# ì¬ì‹œë„ ì„¤ì • (U-094: ImageUnderstanding ì‘ë‹µ íŒŒì‹± ì˜ˆì™¸ ì‹œ ìë™ ì¬ì‹œë„)
# =============================================================================

SCAN_MAX_RETRIES = 2
"""ìµœëŒ€ ì¬ì‹œë„ íšŸìˆ˜ (ì´ 3íšŒ ì‹œë„: 1 ì´ˆê¸° + 2 ì¬ì‹œë„)."""

SCAN_RETRY_BACKOFF_SECONDS: list[float] = [1.0, 2.0]
"""ì¬ì‹œë„ ê°„ ë°±ì˜¤í”„ ì‹œê°„ (ì´ˆ)."""

SCAN_RETRY_REINFORCEMENT: dict[Language, str] = {
    Language.KO: (
        "\n\nâš ï¸ ì¤‘ìš”: ë°˜ë“œì‹œ ìœ íš¨í•œ JSON í˜•ì‹ìœ¼ë¡œë§Œ ì‘ë‹µí•˜ì„¸ìš”. "
        "ë§ˆí¬ë‹¤ìš´ ì½”ë“œ ë¸”ë¡(```)ì„ ì‚¬ìš©í•˜ì§€ ë§ê³  ìˆœìˆ˜ JSONë§Œ ë°˜í™˜í•˜ì„¸ìš”."
    ),
    Language.EN: (
        "\n\nâš ï¸ IMPORTANT: You MUST respond with valid JSON format only. "
        "Do NOT use markdown code blocks (```). Return pure JSON only."
    ),
}
"""ì¬ì‹œë„ ì‹œ ì¶”ê°€ë˜ëŠ” JSON í˜•ì‹ ê°•ì¡° ì§€ì‹œ (U-094 Q1: Option B)."""

# =============================================================================
# ì•„ì´í…œ ìˆ˜ ëœë¤í™” ì„¤ì • (U-095: Scanner ì•„ì´í…œ ìƒì„± ê°œìˆ˜ ëœë¤í™”)
# =============================================================================

SCAN_ITEM_COUNT_POPULATION: list[int] = [1, 2, 3]
"""ìƒì„± ê°€ëŠ¥í•œ ì•„ì´í…œ ê°œìˆ˜."""

SCAN_ITEM_COUNT_WEIGHTS: list[int] = [60, 30, 10]
"""ì•„ì´í…œ ê°œìˆ˜ë³„ ê°€ì¤‘ì¹˜ (1ê°œ=60%, 2ê°œ=30%, 3ê°œ=10%)."""


def determine_item_count() -> int:
    """Scanner ì•„ì´í…œ ìƒì„± ê°œìˆ˜ë¥¼ ê°€ì¤‘ì¹˜ ëœë¤ìœ¼ë¡œ ê²°ì •í•©ë‹ˆë‹¤ (U-095).

    í™•ë¥  ë¶„í¬:
        - 1ê°œ: 60%
        - 2ê°œ: 30%
        - 3ê°œ: 10%

    Returns:
        1~3 ì‚¬ì´ì˜ ì •ìˆ˜
    """
    return random.choices(
        population=SCAN_ITEM_COUNT_POPULATION,
        weights=SCAN_ITEM_COUNT_WEIGHTS,
        k=1,
    )[0]


_NON_RETRYABLE_ERROR_NAMES: frozenset[str] = frozenset(
    {
        "Unauthenticated",
        "PermissionDenied",
        "ResourceExhausted",
        "InvalidArgument",
        "NotFound",
    }
)
"""ì¬ì‹œë„ ë¶ˆê°€ API ì—ëŸ¬ íƒ€ì… ì´ë¦„ (ì¸ì¦/í• ë‹¹ëŸ‰/ê¶Œí•œ ë“±)."""


# =============================================================================
# Mock ì„œë¹„ìŠ¤ êµ¬í˜„
# =============================================================================


def _create_mock_scan_result(language: Language, item_count: int = 2) -> ScanResult:
    """Mock ìŠ¤ìº” ê²°ê³¼ë¥¼ ìƒì„±í•©ë‹ˆë‹¤.

    U-095: item_countì— ë”°ë¼ 1~3ê°œì˜ ì•„ì´í…œì„ ë°˜í™˜í•©ë‹ˆë‹¤.

    Args:
        language: ì‘ë‹µ ì–¸ì–´
        item_count: ìƒì„±í•  ì•„ì´í…œ ìˆ˜ (1~3)

    Returns:
        Mock ìŠ¤ìº” ê²°ê³¼ (item_countì— ë§ì¶˜ ì•„ì´í…œ ëª©ë¡)
    """
    # Mock ì•„ì´í…œ í’€ (ìµœëŒ€ 3ê°œ) - ì–¸ì–´ë³„
    _MOCK_ITEMS_KO: list[tuple[str, str, str, str]] = [
        ("ë…¹ìŠ¨ ì—´ì‡ ", "ì˜¤ë˜ëœ ìë¬¼ì‡ ë¥¼ ì—´ ìˆ˜ ìˆì„ ê²ƒ ê°™ì€ ì—´ì‡ ì…ë‹ˆë‹¤.", "key", "ì—´ì‡ "),
        ("ë‚˜ë¬´ ìƒì", "ë¬´ì–¸ê°€ ë“¤ì–´ìˆì„ ê²ƒ ê°™ì€ ì‘ì€ ìƒìì…ë‹ˆë‹¤.", "container", "ìƒì"),
        ("ê¹¨ì§„ ìˆ˜ì •", "í¬ë¯¸í•˜ê²Œ ë¹›ë‚˜ëŠ” ìˆ˜ì • ì¡°ê°ì…ë‹ˆë‹¤.", "material", "ìˆ˜ì •"),
    ]
    _MOCK_ITEMS_EN: list[tuple[str, str, str, str]] = [
        ("Rusty Key", "An old key that might open an ancient lock.", "key", "Key"),
        ("Wooden Box", "A small box that might contain something.", "container", "Box"),
        ("Broken Crystal", "A faintly glowing crystal shard.", "material", "Crystal"),
    ]

    # Mock bbox í’€
    _MOCK_BBOXES: list[Box2D] = [
        Box2D(ymin=100, xmin=200, ymax=300, xmax=400),
        Box2D(ymin=400, xmin=100, ymax=700, xmax=500),
        Box2D(ymin=200, xmin=500, ymax=450, xmax=750),
    ]
    _MOCK_CONFIDENCES: list[float] = [0.95, 0.88, 0.82]

    items_pool = _MOCK_ITEMS_KO if language == Language.KO else _MOCK_ITEMS_EN
    count = max(1, min(3, item_count))  # 1~3 í´ë¨í•‘

    objects: list[DetectedObject] = []
    candidates: list[ItemCandidate] = []
    for i in range(count):
        label, desc, item_type, obj_label = items_pool[i]
        objects.append(
            DetectedObject(
                label=obj_label,
                box_2d=_MOCK_BBOXES[i],
                confidence=_MOCK_CONFIDENCES[i],
                suggested_item_type=item_type,
            ),
        )
        candidates.append(
            ItemCandidate(
                id=f"item_{uuid.uuid4().hex[:8]}",
                label=label,
                description=desc,
                item_type=item_type,
                source_object_index=i,
            ),
        )

    caption_ko = "[Mock] í…ŒìŠ¤íŠ¸ ì´ë¯¸ì§€ì…ë‹ˆë‹¤. ì—¬ëŸ¬ ì˜¤ë¸Œì íŠ¸ê°€ ê°ì§€ë˜ì—ˆìŠµë‹ˆë‹¤."
    caption_en = "[Mock] Test image. Multiple objects detected."

    return ScanResult(
        status=ScanStatus.COMPLETED,
        caption=caption_ko if language == Language.KO else caption_en,
        objects=objects,
        item_candidates=candidates,
        message=None,
        analysis_time_ms=150,
    )


# =============================================================================
# ìœ í‹¸ë¦¬í‹° í•¨ìˆ˜
# =============================================================================


def validate_image(
    content: bytes,
    content_type: str,
) -> str | None:
    """ì´ë¯¸ì§€ íŒŒì¼ì„ ê²€ì¦í•©ë‹ˆë‹¤.

    NOTE: ì´ í•¨ìˆ˜ëŠ” í˜¸í™˜ì„±ì„ ìœ„í•´ ìœ ì§€ë˜ë©°, ë‚´ë¶€ì ìœ¼ë¡œ
    ì¤‘ì•™í™”ëœ validate_image_uploadë¥¼ í˜¸ì¶œí•©ë‹ˆë‹¤.

    Args:
        content: ì´ë¯¸ì§€ ë°”ì´íŠ¸ ë°ì´í„°
        content_type: MIME íƒ€ì…

    Returns:
        ì—ëŸ¬ ë©”ì‹œì§€ (ì—†ìœ¼ë©´ None)
    """
    return validate_image_upload(content, content_type, language=Language.KO)


def normalize_bbox(bbox: dict[str, Any]) -> Box2D:
    """bboxë¥¼ 0~1000 ë²”ìœ„ë¡œ ì •ê·œí™”í•©ë‹ˆë‹¤.

    Args:
        bbox: ì›ë³¸ bbox dict

    Returns:
        ì •ê·œí™”ëœ Box2D
    """
    # ê¸°ë³¸ê°’
    ymin_val: int = int(bbox.get("ymin", 0) or 0)
    xmin_val: int = int(bbox.get("xmin", 0) or 0)
    ymax_val: int = int(bbox.get("ymax", BBOX_MAX) or BBOX_MAX)
    xmax_val: int = int(bbox.get("xmax", BBOX_MAX) or BBOX_MAX)

    # ë²”ìœ„ í´ë¨í•‘ (RULE-009)
    ymin_val = max(BBOX_MIN, min(BBOX_MAX, ymin_val))
    xmin_val = max(BBOX_MIN, min(BBOX_MAX, xmin_val))
    ymax_val = max(BBOX_MIN, min(BBOX_MAX, ymax_val))
    xmax_val = max(BBOX_MIN, min(BBOX_MAX, xmax_val))

    # ymin < ymax, xmin < xmax ë³´ì¥
    if ymin_val >= ymax_val:
        ymax_val = min(ymin_val + 100, BBOX_MAX)
    if xmin_val >= xmax_val:
        xmax_val = min(xmin_val + 100, BBOX_MAX)

    return Box2D(ymin=ymin_val, xmin=xmin_val, ymax=ymax_val, xmax=xmax_val)


def _create_fallback_result(
    message: str,
    status: ScanStatus = ScanStatus.FAILED,
) -> ScanResult:
    """ì•ˆì „í•œ í´ë°± ê²°ê³¼ë¥¼ ìƒì„±í•©ë‹ˆë‹¤ (RULE-004).

    Args:
        message: ì—ëŸ¬/ìƒíƒœ ë©”ì‹œì§€
        status: ìŠ¤ìº” ìƒíƒœ

    Returns:
        ìŠ¤í‚¤ë§ˆë¥¼ ì¤€ìˆ˜í•˜ëŠ” í´ë°± ScanResult
    """
    return ScanResult(
        status=status,
        caption="",
        objects=[],
        item_candidates=[],
        message=message,
        analysis_time_ms=0,
    )


def _parse_vision_response(
    response_text: str,
    language: Language,  # noqa: ARG001
) -> ScanResult:
    """ë¹„ì „ ëª¨ë¸ ì‘ë‹µì„ íŒŒì‹±í•©ë‹ˆë‹¤.

    Args:
        response_text: ëª¨ë¸ ì‘ë‹µ í…ìŠ¤íŠ¸ (JSON ì˜ˆìƒ)
        language: ì‘ë‹µ ì–¸ì–´ (í˜„ì¬ ì‚¬ìš©ë˜ì§€ ì•ŠìŒ)

    Returns:
        íŒŒì‹±ëœ ScanResult
    """
    try:
        # JSON íŒŒì‹±
        # ì‘ë‹µì— ```json ... ``` ë§ˆí¬ë‹¤ìš´ì´ í¬í•¨ëœ ê²½ìš° ì²˜ë¦¬
        text = response_text.strip()
        if text.startswith("```"):
            # ì²« ë²ˆì§¸ ì¤„ ì œê±° (```json)
            lines = text.split("\n")
            if lines[0].startswith("```"):
                lines = lines[1:]
            # ë§ˆì§€ë§‰ ì¤„ ì œê±° (```)
            if lines and lines[-1].strip() == "```":
                lines = lines[:-1]
            text = "\n".join(lines)

        parsed = json.loads(text)

        # dictê°€ ì•„ë‹Œ ê²½ìš° ì²˜ë¦¬ (ì´ì¤‘ ì§ë ¬í™”ëœ ë¬¸ìì—´ ë“±)
        if isinstance(parsed, str):
            # í•œ ë²ˆ ë” íŒŒì‹± ì‹œë„
            parsed = json.loads(parsed)

        if not isinstance(parsed, dict):
            raise ValueError(f"Expected dict, got {type(parsed).__name__}")

        data = cast(dict[str, Any], parsed)

        # caption ì¶”ì¶œ
        caption: str = str(data.get("caption", "") or "")

        # objects ì¶”ì¶œ ë° ì •ê·œí™”
        objects: list[DetectedObject] = []
        raw_objects: list[dict[str, Any]] = data.get("objects") or []  # type: ignore[assignment]
        for i, obj in enumerate(raw_objects[:10]):  # ìµœëŒ€ 10ê°œ
            if not isinstance(obj, dict):  # type: ignore[reportUnnecessaryIsInstance]
                continue

            label_val = obj.get("label")
            label: str = str(label_val) if label_val else f"Object_{i}"
            bbox_raw: dict[str, Any] = obj.get("box_2d") or {}  # type: ignore[assignment]
            bbox = normalize_bbox(bbox_raw)
            confidence_raw = obj.get("confidence")
            suggested_type_raw = obj.get("suggested_item_type")

            objects.append(
                DetectedObject(
                    label=label,
                    box_2d=bbox,
                    confidence=float(confidence_raw) if confidence_raw is not None else None,  # type: ignore[arg-type]
                    suggested_item_type=str(suggested_type_raw) if suggested_type_raw else None,  # type: ignore[arg-type]
                )
            )

        # item_candidates ì¶”ì¶œ
        item_candidates: list[ItemCandidate] = []
        raw_items: list[dict[str, Any]] = data.get("item_candidates") or []  # type: ignore[assignment]
        for i, item in enumerate(raw_items[:10]):  # ìµœëŒ€ 10ê°œ
            if not isinstance(item, dict):  # type: ignore[reportUnnecessaryIsInstance]
                continue

            id_val = item.get("id")
            label_val = item.get("label")
            desc_val = item.get("description")
            type_val = item.get("item_type")
            source_idx = item.get("source_object_index")

            item_candidates.append(
                ItemCandidate(
                    id=str(id_val) if id_val else f"item_{uuid.uuid4().hex[:8]}",
                    label=str(label_val) if label_val else f"Item_{i}",
                    description=str(desc_val) if desc_val else "",
                    item_type=str(type_val) if type_val else "material",
                    source_object_index=int(source_idx) if source_idx is not None else None,  # type: ignore[arg-type]
                )
            )

        return ScanResult(
            status=ScanStatus.COMPLETED,
            caption=caption,
            objects=objects,
            item_candidates=item_candidates,
            message=None,
            analysis_time_ms=0,  # í˜¸ì¶œìì—ì„œ ì„¤ì •
        )

    except (json.JSONDecodeError, ValueError) as e:
        logger.warning(
            "[ImageUnderstanding] JSON íŒŒì‹± ì‹¤íŒ¨",
            extra={"error": str(e), "error_type": type(e).__name__},
        )
        # ë¶€ë¶„ ê²°ê³¼ë¡œ ìº¡ì…˜ë§Œ ë°˜í™˜ (RULE-004)
        return ScanResult(
            status=ScanStatus.PARTIAL,
            caption=response_text[:500] if response_text else "",
            objects=[],
            item_candidates=[],
            message="ì˜¤ë¸Œì íŠ¸ ê°ì§€ ê²°ê³¼ë¥¼ íŒŒì‹±í•  ìˆ˜ ì—†ìŠµë‹ˆë‹¤. ìº¡ì…˜ë§Œ ì œê³µë©ë‹ˆë‹¤.",
            analysis_time_ms=0,
        )
    except Exception as e:
        logger.error(
            "[ImageUnderstanding] ì‘ë‹µ íŒŒì‹± ì¤‘ ì˜ˆì™¸",
            extra={"error_type": type(e).__name__},
        )
        return _create_fallback_result(f"ì‘ë‹µ ì²˜ë¦¬ ì¤‘ ì˜¤ë¥˜: {type(e).__name__}")


# =============================================================================
# ì•„ì´í…œ ê°œìˆ˜ ê²€ì¦/ì¡°ì • (U-095)
# =============================================================================


def _adjust_item_count(result: ScanResult, target_count: int) -> ScanResult:
    """ëª¨ë¸ì´ ë°˜í™˜í•œ ì•„ì´í…œ ìˆ˜ë¥¼ target_countì— ë§ê²Œ ì¡°ì •í•©ë‹ˆë‹¤ (U-095).

    - ì•„ì´í…œì´ target_countë³´ë‹¤ ë§ìœ¼ë©´ â†’ ì•ì—ì„œë¶€í„° target_countê°œë§Œ ìœ ì§€
    - ì•„ì´í…œì´ target_countë³´ë‹¤ ì ìœ¼ë©´ â†’ ìˆëŠ” ë§Œí¼ë§Œ ìœ ì§€ (ê°•ì œ ìƒì„± X)
    - ì¤‘ë³µ ì´ë¦„ ì•„ì´í…œ ì œê±° (ë™ì¼ label ê¸ˆì§€)

    Args:
        result: íŒŒì‹±ëœ ScanResult
        target_count: ëª©í‘œ ì•„ì´í…œ ìˆ˜

    Returns:
        ì¡°ì •ëœ ScanResult
    """
    if result.status not in (ScanStatus.COMPLETED, ScanStatus.PARTIAL):
        return result

    candidates = result.item_candidates

    # ì¤‘ë³µ ì´ë¦„ ì œê±° (ì²« ë“±ì¥ ìœ ì§€)
    seen_labels: set[str] = set()
    unique_candidates: list[ItemCandidate] = []
    for c in candidates:
        label_lower = c.label.strip().lower()
        if label_lower not in seen_labels:
            seen_labels.add(label_lower)
            unique_candidates.append(c)

    # target_count ì´í•˜ë¡œ ì˜ë¼ë‚´ê¸°
    adjusted = unique_candidates[:target_count]

    if len(adjusted) != len(candidates):
        logger.info(
            "[Scan] ì•„ì´í…œ ìˆ˜ ì¡°ì •: %d â†’ %d (ëª©í‘œ: %d)",
            len(candidates),
            len(adjusted),
            target_count,
        )

    result.item_candidates = adjusted
    return result


# =============================================================================
# ì¬ì‹œë„ í—¬í¼ í•¨ìˆ˜ (U-094)
# =============================================================================


def _is_non_retryable_api_error(error: Exception) -> bool:
    """ì¬ì‹œë„ ë¶ˆê°€ API ì—ëŸ¬ì¸ì§€ í™•ì¸í•©ë‹ˆë‹¤ (U-094).

    ì¸ì¦ ì‹¤íŒ¨(401), ê¶Œí•œ ê±°ë¶€(403), í• ë‹¹ëŸ‰ ì´ˆê³¼(429) ë“±ì€
    ì¬ì‹œë„í•´ë„ ë™ì¼í•œ ê²°ê³¼ì´ë¯€ë¡œ ì¦‰ì‹œ í´ë°±í•©ë‹ˆë‹¤.

    Args:
        error: ë°œìƒí•œ ì˜ˆì™¸

    Returns:
        Trueì´ë©´ ì¬ì‹œë„ ë¶ˆê°€
    """
    return any(cls.__name__ in _NON_RETRYABLE_ERROR_NAMES for cls in type(error).__mro__)


def _is_safety_blocked_response(response: Any) -> bool:
    """Gemini ì‘ë‹µì´ ì•ˆì „ ì •ì±…ì— ì˜í•´ ì°¨ë‹¨ë˜ì—ˆëŠ”ì§€ í™•ì¸í•©ë‹ˆë‹¤ (U-094).

    ì•ˆì „ ì°¨ë‹¨ì€ ì¬ì‹œë„í•´ë„ ë™ì¼í•œ ê²°ê³¼ì´ë¯€ë¡œ ì¦‰ì‹œ í´ë°±í•©ë‹ˆë‹¤.

    Args:
        response: Gemini API ì‘ë‹µ ê°ì²´

    Returns:
        Trueì´ë©´ ì•ˆì „ ì°¨ë‹¨ë¨
    """
    try:
        # candidates[0].finish_reason í™•ì¸
        if hasattr(response, "candidates") and response.candidates:
            candidate = response.candidates[0]
            finish_reason = getattr(candidate, "finish_reason", None)
            if finish_reason is not None:
                reason_str = str(finish_reason).upper()
                if reason_str in ("SAFETY", "BLOCKED", "RECITATION"):
                    return True
        # prompt_feedback.block_reason í™•ì¸
        if hasattr(response, "prompt_feedback"):
            feedback = response.prompt_feedback
            if hasattr(feedback, "block_reason") and feedback.block_reason:
                return True
    except Exception:
        pass
    return False


def _get_final_failure_message(language: Language) -> str:
    """ìµœì¢… ì‹¤íŒ¨ ì‹œ ì‚¬ìš©ìì—ê²Œ í‘œì‹œí•  ë©”ì‹œì§€ë¥¼ ë°˜í™˜í•©ë‹ˆë‹¤ (U-094, RULE-006).

    Args:
        language: ì‘ë‹µ ì–¸ì–´

    Returns:
        i18n í´ë°± ë©”ì‹œì§€
    """
    if language == Language.KO:
        return "ì´ë¯¸ì§€ ë¶„ì„ì— ì‹¤íŒ¨í–ˆìŠµë‹ˆë‹¤. ë‹¤ì‹œ ì‹œë„í•´ì£¼ì„¸ìš”."
    return "Image analysis failed. Please try again."


# =============================================================================
# ì´ë¯¸ì§€ ì´í•´ ì„œë¹„ìŠ¤ í´ë˜ìŠ¤
# =============================================================================


class ImageUnderstandingService:
    """ì´ë¯¸ì§€ ì´í•´ ì„œë¹„ìŠ¤.

    ë¹„ì „ ëª¨ë¸ì„ ì‚¬ìš©í•˜ì—¬ ì´ë¯¸ì§€ë¥¼ ë¶„ì„í•˜ê³ 
    ìº¡ì…˜, ì˜¤ë¸Œì íŠ¸, ì•„ì´í…œ í›„ë³´ë¥¼ ì¶”ì¶œí•©ë‹ˆë‹¤.
    """

    def __init__(
        self,
        *,
        force_mock: bool = False,
    ) -> None:
        """ImageUnderstandingServiceë¥¼ ì´ˆê¸°í™”í•©ë‹ˆë‹¤.

        Args:
            force_mock: Trueë©´ Mock ëª¨ë“œ ê°•ì œ
        """
        # ëª¨ë“œ ê²°ì •
        if force_mock:
            self._is_mock = True
        else:
            mode_str = os.environ.get(ENV_UW_MODE, GenAIMode.REAL)
            self._is_mock = mode_str == GenAIMode.MOCK

        self._genai_client: Client | None = None

        # Real ëª¨ë“œì—ì„œë§Œ í´ë¼ì´ì–¸íŠ¸ ì´ˆê¸°í™”
        if not self._is_mock:
            self._initialize_client()

        logger.info(
            "[ImageUnderstanding] ì„œë¹„ìŠ¤ ì´ˆê¸°í™”",
            extra={"mode": "mock" if self._is_mock else "real"},
        )

    def _initialize_client(self) -> None:
        """google-genai í´ë¼ì´ì–¸íŠ¸ë¥¼ ì´ˆê¸°í™”í•©ë‹ˆë‹¤."""
        try:
            from google.genai import Client

            # U-080 í•«í”½ìŠ¤: API í‚¤ ëª¨ë“œë¡œ í´ë¼ì´ì–¸íŠ¸ ì´ˆê¸°í™” (Vertex AI ì œê±°)
            api_key = os.environ.get("GOOGLE_API_KEY")
            if not api_key:
                logger.warning(
                    "[ImageUnderstanding] GOOGLE_API_KEY í™˜ê²½ë³€ìˆ˜ê°€ ì„¤ì •ë˜ì§€ ì•ŠìŒ - Mock ëª¨ë“œë¡œ ì „í™˜",
                )
                self._is_mock = True
                self._genai_client = None
                return

            self._genai_client = Client(api_key=api_key)
            self._is_mock = False

            logger.info(
                "[ImageUnderstanding] API í‚¤ í´ë¼ì´ì–¸íŠ¸ ì´ˆê¸°í™” ì™„ë£Œ",
                extra={
                    "auth": "api_key",
                },
            )
        except Exception as e:
            logger.warning(
                "[ImageUnderstanding] í´ë¼ì´ì–¸íŠ¸ ì´ˆê¸°í™” ì‹¤íŒ¨ - Mock ëª¨ë“œë¡œ ì „í™˜",
                extra={"error_type": type(e).__name__},
            )
            self._is_mock = True
            self._genai_client = None

    @property
    def is_mock(self) -> bool:
        """Mock ëª¨ë“œ ì—¬ë¶€."""
        return self._is_mock

    async def analyze(
        self,
        image_content: bytes,
        content_type: str,
        language: Language = Language.KO,
        *,
        preserve_original: bool = False,
        session_id: str | None = None,
    ) -> ScanResult:
        """ì´ë¯¸ì§€ë¥¼ ë¶„ì„í•©ë‹ˆë‹¤.

        Args:
            image_content: ì´ë¯¸ì§€ ë°”ì´íŠ¸ ë°ì´í„°
            content_type: MIME íƒ€ì…
            language: ì‘ë‹µ ì–¸ì–´
            preserve_original: ì›ë³¸ ì´ë¯¸ì§€ ì €ì¥ ì—¬ë¶€ (RU-006-S1)
            session_id: ì„¸ì…˜ ID (ì €ì¥ ì‹œ ê·¸ë£¹í™”ìš©)

        Returns:
            ScanResult: ë¶„ì„ ê²°ê³¼ (ì €ì¥ ì‹œ original_image_key/url í¬í•¨)
        """
        start_time = time.time()

        # ì´ë¯¸ì§€ ê²€ì¦
        validation_error = validate_image(image_content, content_type)
        if validation_error:
            return _create_fallback_result(validation_error)

        # ì›ë³¸ ì´ë¯¸ì§€ ì €ì¥ (ì„ íƒì , RU-006-S1)
        original_image_key: str | None = None
        original_image_url: str | None = None

        if preserve_original:
            try:
                from unknown_world.storage import StorageCategory, get_storage

                storage = get_storage()
                put_result = await storage.put(
                    data=image_content,
                    category=StorageCategory.UPLOADED_IMAGE,
                    content_type=content_type,
                    session_id=session_id,
                )

                if put_result.success:
                    original_image_key = put_result.key
                    original_image_url = put_result.url
                    logger.debug(
                        "[ImageUnderstanding] ì›ë³¸ ì´ë¯¸ì§€ ì €ì¥ ì™„ë£Œ",
                        extra={
                            "key": original_image_key,
                            "size_kb": len(image_content) // 1024,
                        },
                    )
            except Exception as e:
                # ì €ì¥ ì‹¤íŒ¨í•´ë„ ë¶„ì„ì€ ê³„ì† (RULE-004)
                logger.warning(
                    "[ImageUnderstanding] ì›ë³¸ ì´ë¯¸ì§€ ì €ì¥ ì‹¤íŒ¨",
                    extra={"error_type": type(e).__name__},
                )

        # U-095: ì•„ì´í…œ ìƒì„± ê°œìˆ˜ ëœë¤ ê²°ì • (ì„œë²„ì—ì„œ í™•ì •ì ìœ¼ë¡œ ê²°ì •)
        item_count = determine_item_count()
        logger.info(
            "[ImageUnderstanding] ì•„ì´í…œ ìƒì„± ê°œìˆ˜ ê²°ì •",
            extra={"item_count": item_count},
        )

        # Mock ëª¨ë“œ ì²˜ë¦¬
        if self._is_mock:
            logger.debug("[ImageUnderstanding] Mock ë¶„ì„ ìˆ˜í–‰")
            result = _create_mock_scan_result(language, item_count=item_count)
            result.analysis_time_ms = int((time.time() - start_time) * 1000)
            result.original_image_key = original_image_key
            result.original_image_url = original_image_url
            return result

        # ì‹¤ì œ ë¹„ì „ ëª¨ë¸ í˜¸ì¶œ
        try:
            result = await self._call_vision_model(
                image_content,
                content_type,
                language,
                item_count=item_count,
            )
            result.analysis_time_ms = int((time.time() - start_time) * 1000)
            result.original_image_key = original_image_key
            result.original_image_url = original_image_url
            return result

        except Exception as e:
            error_type = type(e).__name__
            logger.error(
                "[ImageUnderstanding] ë¹„ì „ ëª¨ë¸ í˜¸ì¶œ ì‹¤íŒ¨",
                extra={"error_type": error_type},
            )
            # ì•ˆì „í•œ í´ë°± (RULE-004)
            return _create_fallback_result(f"ì´ë¯¸ì§€ ë¶„ì„ ì¤‘ ì˜¤ë¥˜ê°€ ë°œìƒí–ˆìŠµë‹ˆë‹¤: {error_type}")

    async def _call_vision_model(
        self,
        image_content: bytes,
        content_type: str,
        language: Language,
        *,
        item_count: int = 1,
    ) -> ScanResult:
        """ë¹„ì „ ëª¨ë¸ì„ í˜¸ì¶œí•©ë‹ˆë‹¤ (íŒŒì‹± ì‹¤íŒ¨ ì‹œ ìë™ ì¬ì‹œë„ í¬í•¨).

        U-094: ImageUnderstanding ì‘ë‹µ íŒŒì‹± ì˜ˆì™¸ ì‹œ ìë™ ì¬ì‹œë„.
        U-095: item_countì— ë”°ë¼ í”„ë¡¬í”„íŠ¸ì— ì•„ì´í…œ ìˆ˜ ì§€ì‹œ ì¶”ê°€.

        - ìµœëŒ€ 2íšŒ ì¬ì‹œë„ (ì´ 3íšŒ ì‹œë„)
        - ì¬ì‹œë„ ì‹œ JSON í˜•ì‹ ê°•ì¡° ì§€ì‹œ ì¶”ê°€ (Q1: Option B)
        - ë°±ì˜¤í”„: 1ì´ˆ, 2ì´ˆ
        - ì¬ì‹œë„ ì œì™¸: ì¸ì¦ ì‹¤íŒ¨(401), í• ë‹¹ëŸ‰ ì´ˆê³¼(429), ì•ˆì „ ì°¨ë‹¨

        Args:
            image_content: ì´ë¯¸ì§€ ë°”ì´íŠ¸ ë°ì´í„°
            content_type: MIME íƒ€ì…
            language: ì‘ë‹µ ì–¸ì–´
            item_count: ìƒì„±í•  ì•„ì´í…œ ìˆ˜ (1~3, U-095)

        Returns:
            ScanResult: ë¶„ì„ ê²°ê³¼ (ì„±ê³µ ë˜ëŠ” í´ë°±)
        """
        if self._genai_client is None:
            return _create_fallback_result("ë¹„ì „ í´ë¼ì´ì–¸íŠ¸ê°€ ì´ˆê¸°í™”ë˜ì§€ ì•Šì•˜ìŠµë‹ˆë‹¤")

        last_result: ScanResult | None = None

        for attempt in range(SCAN_MAX_RETRIES + 1):  # 0=ì´ˆê¸°, 1~2=ì¬ì‹œë„
            is_retry = attempt > 0

            # ì¬ì‹œë„ ì‹œ ë°±ì˜¤í”„ ëŒ€ê¸°
            if is_retry:
                backoff_seconds = SCAN_RETRY_BACKOFF_SECONDS[attempt - 1]
                logger.info(
                    "[Scan] íŒŒì‹± ì‹¤íŒ¨, ì¬ì‹œë„ %d/%d (ë°±ì˜¤í”„ %.1fì´ˆ)",
                    attempt,
                    SCAN_MAX_RETRIES,
                    backoff_seconds,
                )
                await asyncio.sleep(backoff_seconds)

            try:
                result = await self._execute_single_vision_call(
                    image_content,
                    content_type,
                    language,
                    is_retry=is_retry,
                    item_count=item_count,
                )

                # ì™„ì „ ì„±ê³µ â†’ ì•„ì´í…œ ìˆ˜ ì¡°ì • í›„ ë°˜í™˜ (U-095)
                if result.status == ScanStatus.COMPLETED:
                    if is_retry:
                        logger.info(
                            "[Scan] ì¬ì‹œë„ ì„±ê³µ (%d/%d ì‹œë„)",
                            attempt + 1,
                            SCAN_MAX_RETRIES + 1,
                        )
                    return _adjust_item_count(result, item_count)

                # ì•ˆì „ ì°¨ë‹¨ â†’ ì¬ì‹œë„ ë¶ˆê°€, ì¦‰ì‹œ ë°˜í™˜
                if result.status == ScanStatus.BLOCKED:
                    logger.warning("[Scan] ì•ˆì „ ì°¨ë‹¨, ì¬ì‹œë„ ê±´ë„ˆëœ€")
                    return result

                # PARTIAL/FAILED â†’ ì¬ì‹œë„ ëŒ€ìƒ
                last_result = result
                logger.warning(
                    "[Scan] íŒŒì‹± ì‹¤íŒ¨ (ì‹œë„ %d/%d, ìƒíƒœ: %s)",
                    attempt + 1,
                    SCAN_MAX_RETRIES + 1,
                    result.status.value,
                )

            except Exception as e:
                error_type = type(e).__name__

                # ì¬ì‹œë„ ë¶ˆê°€ API ì—ëŸ¬ (ì¸ì¦/í• ë‹¹ëŸ‰/ê¶Œí•œ)
                if _is_non_retryable_api_error(e):
                    logger.error(
                        "[Scan] ì¬ì‹œë„ ë¶ˆê°€ API ì˜¤ë¥˜: %s",
                        error_type,
                    )
                    return _create_fallback_result(
                        f"API ì˜¤ë¥˜ë¡œ ì´ë¯¸ì§€ ë¶„ì„ì— ì‹¤íŒ¨í–ˆìŠµë‹ˆë‹¤: {error_type}",
                    )

                # ê¸°íƒ€ ì˜ˆì™¸ â†’ ì¬ì‹œë„
                logger.warning(
                    "[Scan] API í˜¸ì¶œ ì˜ˆì™¸ (ì‹œë„ %d/%d)",
                    attempt + 1,
                    SCAN_MAX_RETRIES + 1,
                    extra={"error_type": error_type},
                )
                last_result = _create_fallback_result(
                    f"API í˜¸ì¶œ ì˜¤ë¥˜: {error_type}",
                )

        # ëª¨ë“  ì¬ì‹œë„ ì‹¤íŒ¨ â†’ í´ë°± ë°˜í™˜
        total_attempts = SCAN_MAX_RETRIES + 1
        logger.error(
            "[Scan] ëª¨ë“  ì¬ì‹œë„ ì‹¤íŒ¨ (%d/%d ì‹œë„), í´ë°± ì‘ë‹µ ë°˜í™˜",
            total_attempts,
            total_attempts,
        )

        if last_result is not None:
            last_result.message = _get_final_failure_message(language)
            return last_result

        return _create_fallback_result(_get_final_failure_message(language))

    async def _execute_single_vision_call(
        self,
        image_content: bytes,
        content_type: str,
        language: Language,
        *,
        is_retry: bool = False,
        item_count: int = 1,
    ) -> ScanResult:
        """ë‹¨ì¼ ë¹„ì „ ëª¨ë¸ API í˜¸ì¶œì„ ì‹¤í–‰í•©ë‹ˆë‹¤.

        U-094: ì¬ì‹œë„ ì‹œ JSON í˜•ì‹ ê°•ì¡° ì§€ì‹œë¥¼ í”„ë¡¬í”„íŠ¸ì— ì¶”ê°€í•©ë‹ˆë‹¤.
        U-095: item_countì— ë”°ë¼ ì•„ì´í…œ ìˆ˜ ì§€ì‹œë¥¼ í”„ë¡¬í”„íŠ¸ì— ì¶”ê°€í•©ë‹ˆë‹¤.

        Args:
            image_content: ì´ë¯¸ì§€ ë°”ì´íŠ¸ ë°ì´í„°
            content_type: MIME íƒ€ì…
            language: ì‘ë‹µ ì–¸ì–´
            is_retry: ì¬ì‹œë„ ì—¬ë¶€ (Trueë©´ JSON ê°•ì¡° ì§€ì‹œ ì¶”ê°€)
            item_count: ìƒì„±í•  ì•„ì´í…œ ìˆ˜ (1~3, U-095)

        Returns:
            ScanResult: íŒŒì‹±ëœ ë¶„ì„ ê²°ê³¼

        Raises:
            Exception: API í˜¸ì¶œ ì¤‘ ë°œìƒí•œ ì˜ˆì™¸ (í˜¸ì¶œìì—ì„œ ì¬ì‹œë„/í´ë°± ì²˜ë¦¬)
        """
        # í”„ë¡¬í”„íŠ¸ ë¡œë“œ (U-095: ì•„ì´í…œ ìˆ˜ ì§€ì‹œ í¬í•¨)
        prompt_text = load_prompt("scan", "scan_instructions", language).replace(
            "{count}", str(item_count)
        )

        if is_retry:
            reinforcement = SCAN_RETRY_REINFORCEMENT.get(
                language,
                SCAN_RETRY_REINFORCEMENT[Language.KO],
            )
            prompt_text = prompt_text + reinforcement

        # ëª¨ë¸ ID ì¡°íšŒ
        model_id = get_model_id(ModelLabel.VISION)

        logger.debug(
            "[ImageUnderstanding] ë¹„ì „ ëª¨ë¸ í˜¸ì¶œ",
            extra={
                "model_id": model_id,
                "language": language.value,
                "image_size_kb": len(image_content) // 1024,
                "is_retry": is_retry,
            },
        )

        # google-genai SDK í˜¸ì¶œ (ë©€í‹°ëª¨ë‹¬ ì…ë ¥)
        from google.genai.types import GenerateContentConfig, Part

        # ë©€í‹°ëª¨ë‹¬ ì…ë ¥ êµ¬ì„± (ì´ë¯¸ì§€ ë¨¼ì €, í…ìŠ¤íŠ¸ ë’¤ì— - PRD 8.6 ê¶Œì¥)
        contents = [
            Part.from_bytes(
                data=image_content,
                mime_type=content_type,
            ),
            Part.from_text(text=prompt_text),
        ]

        # JSON ì‘ë‹µ ê°•ì œ + ì¶©ë¶„í•œ ì¶œë ¥ í† í° í™•ë³´
        config = GenerateContentConfig(
            response_mime_type="application/json",
            max_output_tokens=32768,  # JSON ì‘ë‹µ ì˜ë¦¼ ë°©ì§€
        )

        response = await self._genai_client.aio.models.generate_content(  # type: ignore[reportUnknownMemberType]
            model=model_id,
            contents=contents,  # type: ignore[reportArgumentType]
            config=config,
        )

        # ì•ˆì „ ì°¨ë‹¨ í™•ì¸ (U-094: ì•ˆì „ ì°¨ë‹¨ì€ ì¬ì‹œë„ ì œì™¸)
        if _is_safety_blocked_response(response):
            msg = (
                "ì•ˆì „ ì •ì±…ì— ì˜í•´ ì´ë¯¸ì§€ ë¶„ì„ì´ ì°¨ë‹¨ë˜ì—ˆìŠµë‹ˆë‹¤."
                if language == Language.KO
                else "Image analysis was blocked by safety policy."
            )
            return ScanResult(
                status=ScanStatus.BLOCKED,
                caption="",
                objects=[],
                item_candidates=[],
                message=msg,
                analysis_time_ms=0,
            )

        # ì‘ë‹µ í…ìŠ¤íŠ¸ ì¶”ì¶œ
        response_text: str = ""
        if hasattr(response, "text") and response.text:
            response_text = str(response.text)
        else:
            response_text = str(response)

        if not response_text:
            return _create_fallback_result("ëª¨ë¸ ì‘ë‹µì´ ë¹„ì–´ìˆìŠµë‹ˆë‹¤")

        # ì‘ë‹µ íŒŒì‹±
        return _parse_vision_response(response_text, language)


# =============================================================================
# íŒ©í† ë¦¬ í•¨ìˆ˜
# =============================================================================

# ì‹±ê¸€í†¤ ì¸ìŠ¤í„´ìŠ¤ ìºì‹œ
_service_instance: ImageUnderstandingService | None = None


def get_image_understanding_service(
    *,
    force_new: bool = False,
) -> ImageUnderstandingService:
    """ImageUnderstandingService ì¸ìŠ¤í„´ìŠ¤ë¥¼ ë°˜í™˜í•©ë‹ˆë‹¤.

    ì‹±ê¸€í†¤ íŒ¨í„´ìœ¼ë¡œ ë™ì‘í•©ë‹ˆë‹¤.

    Args:
        force_new: Trueë©´ ìºì‹œë¥¼ ë¬´ì‹œí•˜ê³  ìƒˆ ì¸ìŠ¤í„´ìŠ¤ ìƒì„±

    Returns:
        ImageUnderstandingService ì¸ìŠ¤í„´ìŠ¤
    """
    global _service_instance

    if not force_new and _service_instance is not None:
        return _service_instance

    _service_instance = ImageUnderstandingService()
    return _service_instance


def reset_image_understanding_service() -> None:
    """ImageUnderstandingService ìºì‹œë¥¼ ì´ˆê¸°í™”í•©ë‹ˆë‹¤.

    í…ŒìŠ¤íŠ¸ ì‹œ ì„œë¹„ìŠ¤ë¥¼ ì¬ì„¤ì •í•  ë•Œ ì‚¬ìš©í•©ë‹ˆë‹¤.
    """
    global _service_instance
    _service_instance = None
</file>

<file path="backend/src/unknown_world/orchestrator/stages/render.py">
"""Unknown World - Render Stage.

ë Œë”ë§ ë‹¨ê³„ì…ë‹ˆë‹¤.
U-051ì—ì„œ ì´ë¯¸ì§€ ìƒì„± ì„œë¹„ìŠ¤ ë¸Œë¦¿ì§€ê°€ êµ¬ì¶•ë˜ì—ˆìœ¼ë©°,
U-052ì—ì„œ ì´ë¯¸ì§€ ìƒì„± ì—¬ë¶€ íŒì • ë¡œì§ì´ ì¶”ê°€ë˜ì—ˆìŠµë‹ˆë‹¤.
U-053ì—ì„œ ì‹¤ì œ ì´ë¯¸ì§€ ìƒì„± í˜¸ì¶œ ë° ê²°ê³¼ ë™ê¸°í™”ê°€ êµ¬í˜„ë˜ì—ˆìŠµë‹ˆë‹¤.

ì„¤ê³„ ì›ì¹™:
    - RULE-005: ì¬í™” ì¸ë°”ë¦¬ì–¸íŠ¸ (ì”ì•¡ ë¶€ì¡± ì‹œ í…ìŠ¤íŠ¸-only í´ë°±)
    - RULE-007: í”„ë¡¬í”„íŠ¸ ì›ë¬¸ ë¡œê·¸ ë…¸ì¶œ ê¸ˆì§€
    - RULE-008: ë‹¨ê³„ ì´ë²¤íŠ¸ ì¼ê´€ì„±, í…ìŠ¤íŠ¸ ìš°ì„  + Lazy ì´ë¯¸ì§€
    - ë™ì‘ ë³´ì¡´: image_generatorê°€ Noneì´ê±°ë‚˜ should_generateê°€ falseë©´ pass-through
    - U-051: ì´ë¯¸ì§€ ìƒì„± ì„œë¹„ìŠ¤ ì˜ì¡´ì„± ì£¼ì… ë° ì—°ê²° ê°€ëŠ¥ ìƒíƒœ í™•ë³´
    - U-052: ì¡°ê±´ë¶€ ì´ë¯¸ì§€ ìƒì„± íŒì • ë¡œì§
    - U-053: ë¹„ë™ê¸° ì´ë¯¸ì§€ ìƒì„± í˜¸ì¶œ ë° TurnOutput.render ë™ê¸°í™”

ì°¸ì¡°:
    - vibe/refactors/RU-005-Q4.md
    - vibe/unit-results/U-019[Mvp].md
    - vibe/unit-results/U-051[Mvp].md
    - vibe/unit-results/U-052[Mvp].md
    - vibe/unit-plans/U-053[Mvp].md
"""

from __future__ import annotations

import asyncio
import logging
from datetime import UTC, datetime

from unknown_world.models.turn import (
    AgentPhase,
    EconomySnapshot,
    RenderOutput,
    SafetyOutput,
    ValidationBadge,
)
from unknown_world.orchestrator.stages.render_helpers import (
    ImageFallbackResult,
    ImageGenerationDecision,
    create_image_fallback_result,
    decide_image_generation,
    extract_image_job,
)
from unknown_world.orchestrator.stages.types import (
    EmitFn,
    PipelineContext,
    PipelineEvent,
    PipelineEventType,
)
from unknown_world.services.image_generation import (
    ImageGenerationRequest,
    ImageGenerationStatus,
)

# ëª¨ì˜ ì²˜ë¦¬ ì§€ì—° ì‹œê°„ (ms)
RENDER_DELAY_MS = 80

# ë¡œê±° (í”„ë¡¬í”„íŠ¸/ë¹„ë°€ì •ë³´ ë…¸ì¶œ ê¸ˆì§€ - RULE-007)
logger = logging.getLogger(__name__)


# =============================================================================
# ì´ë¯¸ì§€ ìƒì„± í—¬í¼ í•¨ìˆ˜ (U-053)
# =============================================================================


async def _execute_image_generation(
    ctx: PipelineContext,
    image_decision: ImageGenerationDecision,
    emit: EmitFn,
) -> PipelineContext:
    """ì´ë¯¸ì§€ ìƒì„±ì„ ì‹¤í–‰í•˜ê³  ê²°ê³¼ë¥¼ TurnOutputì— ë°˜ì˜í•©ë‹ˆë‹¤.

    Args:
        ctx: íŒŒì´í”„ë¼ì¸ ì»¨í…ìŠ¤íŠ¸
        image_decision: ì´ë¯¸ì§€ ìƒì„± íŒì • ê²°ê³¼ (U-052)
        emit: ì´ë²¤íŠ¸ emit ì½œë°±

    Returns:
        ì—…ë°ì´íŠ¸ëœ ì»¨í…ìŠ¤íŠ¸ (TurnOutput.renderì— image_url ë°˜ì˜)

    ì„¤ê³„:
        - í˜ì–´ë§ ì§ˆë¬¸ Q1: Option A (ctx.output ê°±ì‹ ) ì±„íƒ
        - RULE-004: ì‹¤íŒ¨ ì‹œ ì¦‰ì‹œ í´ë°± (ì¬ì‹œë„ 0íšŒ, U-054 Q1: Option A)
        - RULE-007: í”„ë¡¬í”„íŠ¸ ì›ë¬¸ ë¡œê·¸ ë…¸ì¶œ ê¸ˆì§€ (í•´ì‹œë§Œ ì‚¬ìš©)
        - RULE-008: í…ìŠ¤íŠ¸ ìš°ì„  + Lazy ì´ë¯¸ì§€ ì›ì¹™
    """
    if ctx.image_generator is None or ctx.output is None:
        logger.debug("[Render] ì´ë¯¸ì§€ ìƒì„± ì¡°ê±´ ë¶ˆì¶©ì¡±, ê±´ë„ˆëœ€")
        return ctx

    # ImageJobì—ì„œ í”„ë¡¬í”„íŠ¸ ì¶”ì¶œ (íŒì •ì—ì„œ ì´ë¯¸ ìœ íš¨ì„± ê²€ì¦ë¨)
    image_job = extract_image_job(ctx.output)
    if image_job is None or not image_job.prompt:
        logger.warning("[Render] ImageJob ë˜ëŠ” í”„ë¡¬í”„íŠ¸ ì—†ìŒ, ìƒì„± ê±´ë„ˆëœ€")
        return ctx

    # ì–¸ì–´ ì •ë³´ ì¶”ì¶œ (í´ë°± ë©”ì‹œì§€ìš©)
    language = ctx.turn_input.language.value

    # ìƒì„± ì‹œì‘ ì‹œê°„ ê¸°ë¡
    start_time = datetime.now(UTC)

    logger.info(
        "[Render] ì´ë¯¸ì§€ ìƒì„± ì‹œì‘",
        extra={
            "prompt_hash": image_decision.prompt_hash,
            "aspect_ratio": image_decision.aspect_ratio,
            "image_size": image_decision.image_size,
            "reference_image_url": image_decision.reference_image_url,
        },
    )

    # U-079: FAST í´ë°± ì‹œ model_label ì˜¤ë²„ë¼ì´ë“œ
    effective_model_label = image_decision.model_override or "QUALITY"

    if image_decision.is_low_balance_fallback:
        logger.info(
            "[Render] U-079: ì”ì•¡ ë¶€ì¡± FAST í´ë°± ì ìš©",
            extra={
                "model_override": effective_model_label,
                "estimated_cost": image_decision.estimated_cost_signal,
            },
        )

    # ImageGenerationRequest ìƒì„±
    # U-091: rembg ëŸ°íƒ€ì„ ì œê±° - remove_background, image_type_hint ì œê±°
    request = ImageGenerationRequest(
        prompt=image_job.prompt,
        aspect_ratio=image_decision.aspect_ratio or image_job.aspect_ratio,
        image_size=image_decision.image_size or image_job.image_size,
        reference_image_ids=image_job.reference_image_ids,
        reference_image_url=image_decision.reference_image_url,
        session_id=None,  # ì„¸ì…˜ IDëŠ” í•„ìš” ì‹œ TurnInputì—ì„œ ì¶”ì¶œ
        seed=ctx.seed,
        model_label=effective_model_label,
    )

    try:
        # ë¹„ë™ê¸° ì´ë¯¸ì§€ ìƒì„± í˜¸ì¶œ
        response = await ctx.image_generator.generate(request)

        # ìƒì„± ì†Œìš” ì‹œê°„ ê³„ì‚°
        elapsed_ms = int((datetime.now(UTC) - start_time).total_seconds() * 1000)

        # ê²°ê³¼ ì²˜ë¦¬
        if response.status == ImageGenerationStatus.COMPLETED:
            logger.info(
                "[Render] ì´ë¯¸ì§€ ìƒì„± ì„±ê³µ",
                extra={
                    "image_id": response.image_id,
                    "image_url": response.image_url,
                    "generation_time_ms": response.generation_time_ms,
                    "total_elapsed_ms": elapsed_ms,
                },
            )

            # TurnOutput.renderì— ê²°ê³¼ ë°˜ì˜ (Option A: ctx.output ê°±ì‹ )
            ctx = _update_render_output(
                ctx=ctx,
                image_url=response.image_url,
                image_id=response.image_id,
                generation_time_ms=response.generation_time_ms,
            )

        else:
            # U-054: ì´ë¯¸ì§€ ìƒì„± ì‹¤íŒ¨ - ì¦‰ì‹œ í´ë°± (ì¬ì‹œë„ 0íšŒ, Q1: Option A)
            logger.warning(
                "[Render] ì´ë¯¸ì§€ ìƒì„± ì‹¤íŒ¨, í…ìŠ¤íŠ¸-only í´ë°±",
                extra={
                    "status": response.status.value,
                    "status_message": response.message,
                    "elapsed_ms": elapsed_ms,
                    "prompt_hash": image_decision.prompt_hash,
                },
            )

            # í´ë°± ê²°ê³¼ ìƒì„± ë° TurnOutput ì—…ë°ì´íŠ¸
            fallback_result = create_image_fallback_result(
                status_message=response.message,
                language=language,
            )
            ctx = _apply_image_fallback(ctx, fallback_result)

    except TimeoutError:
        # íƒ€ì„ì•„ì›ƒ ì˜ˆì™¸ - ì•ˆì „í•˜ê²Œ í´ë°± (RULE-004)
        elapsed_ms = int((datetime.now(UTC) - start_time).total_seconds() * 1000)

        logger.warning(
            "[Render] ì´ë¯¸ì§€ ìƒì„± íƒ€ì„ì•„ì›ƒ, í…ìŠ¤íŠ¸-only í´ë°±",
            extra={
                "elapsed_ms": elapsed_ms,
                "prompt_hash": image_decision.prompt_hash,
            },
        )

        fallback_result = create_image_fallback_result(
            status_message="timeout",
            language=language,
        )
        ctx = _apply_image_fallback(ctx, fallback_result)

    except (ValueError, TypeError) as e:
        # ì˜ëª»ëœ ìš”ì²­/ê²€ì¦ ì˜¤ë¥˜ - ì•ˆì „í•˜ê²Œ í´ë°± (RULE-004)
        elapsed_ms = int((datetime.now(UTC) - start_time).total_seconds() * 1000)
        error_type = type(e).__name__

        logger.warning(
            "[Render] ì´ë¯¸ì§€ ìƒì„± ìš”ì²­ ì˜¤ë¥˜, í…ìŠ¤íŠ¸-only í´ë°±",
            extra={
                "error_type": error_type,
                "error_message": str(e),
                "elapsed_ms": elapsed_ms,
                "prompt_hash": image_decision.prompt_hash,
            },
        )

        fallback_result = create_image_fallback_result(
            status_message=str(e),
            language=language,
        )
        ctx = _apply_image_fallback(ctx, fallback_result)

    except Exception as e:
        # ê¸°íƒ€ ì˜ˆì™¸ ë°œìƒ ì‹œ ì•ˆì „í•˜ê²Œ ì²˜ë¦¬ (RULE-004)
        elapsed_ms = int((datetime.now(UTC) - start_time).total_seconds() * 1000)
        error_type = type(e).__name__

        logger.error(
            "[Render] ì´ë¯¸ì§€ ìƒì„± ì¤‘ ì˜ˆì™¸ ë°œìƒ, í…ìŠ¤íŠ¸-only í´ë°±",
            extra={
                "error_type": error_type,
                "error_message": str(e),
                "elapsed_ms": elapsed_ms,
                "prompt_hash": image_decision.prompt_hash,
            },
        )

        fallback_result = create_image_fallback_result(
            status_message=None,
            language=language,
        )
        ctx = _apply_image_fallback(ctx, fallback_result)

    return ctx


def _apply_image_fallback(
    ctx: PipelineContext,
    fallback_result: ImageFallbackResult,
) -> PipelineContext:
    """ì´ë¯¸ì§€ ìƒì„± ì‹¤íŒ¨ ì‹œ í´ë°±ì„ ì ìš©í•©ë‹ˆë‹¤.

    U-054: RULE-004ì— ë”°ë¼ ì´ë¯¸ì§€ ìƒì„± ì‹¤íŒ¨ ì‹œ ì•ˆì „í•œ í´ë°±ì„ ì œê³µí•©ë‹ˆë‹¤.
    - ì•ˆì „ ì°¨ë‹¨ ì‹œ TurnOutput.safety ì—…ë°ì´íŠ¸
    - ë°°ì§€ì— ì‹¤íŒ¨ ìƒíƒœ ë°˜ì˜

    Args:
        ctx: íŒŒì´í”„ë¼ì¸ ì»¨í…ìŠ¤íŠ¸
        fallback_result: í´ë°± ì²˜ë¦¬ ê²°ê³¼

    Returns:
        ì—…ë°ì´íŠ¸ëœ ì»¨í…ìŠ¤íŠ¸
    """
    if ctx.output is None:
        return ctx

    logger.info(
        "[Render] ì´ë¯¸ì§€ í´ë°± ì ìš©",
        extra={
            "is_safety_blocked": fallback_result.is_safety_blocked,
            "reason": fallback_result.reason,
        },
    )

    # ì•ˆì „ ì°¨ë‹¨ ì‹œ TurnOutput.safety ì—…ë°ì´íŠ¸
    if fallback_result.should_update_safety:
        new_safety = SafetyOutput(
            blocked=True,
            message=fallback_result.fallback_message,
        )
        ctx.output = ctx.output.model_copy(update={"safety": new_safety})

        # ë°°ì§€ì— SAFETY_BLOCKED ì¶”ê°€
        ctx = _add_badge(ctx, ValidationBadge.SAFETY_BLOCKED)
    else:
        # ì¼ë°˜ ì‹¤íŒ¨ ì‹œì—ë„ ê¸°ì¡´ ë°°ì§€ëŠ” ìœ ì§€í•˜ê³  ë¡œê·¸ë§Œ ê¸°ë¡
        # (SAFETY_OKëŠ” ì´ë¯¸ ì„¤ì •ë˜ì–´ ìˆì„ ìˆ˜ ìˆìŒ)
        pass

    return ctx


def _add_badge(ctx: PipelineContext, badge: ValidationBadge) -> PipelineContext:
    """TurnOutput.agent_console.badgesì— ë°°ì§€ë¥¼ ì¶”ê°€í•©ë‹ˆë‹¤.

    U-054: ì´ë¯¸ì§€ ìƒì„± ìƒíƒœë¥¼ ë°°ì§€ë¡œ ë°˜ì˜í•©ë‹ˆë‹¤.
    ì¤‘ë³µ ë°°ì§€ëŠ” ì¶”ê°€í•˜ì§€ ì•ŠìŠµë‹ˆë‹¤.

    Args:
        ctx: íŒŒì´í”„ë¼ì¸ ì»¨í…ìŠ¤íŠ¸
        badge: ì¶”ê°€í•  ë°°ì§€

    Returns:
        ì—…ë°ì´íŠ¸ëœ ì»¨í…ìŠ¤íŠ¸
    """
    if ctx.output is None:
        return ctx

    current_badges = list(ctx.output.agent_console.badges)

    # ê´€ë ¨ ë°°ì§€ êµì²´ (ì˜ˆ: SAFETY_OK -> SAFETY_BLOCKED)
    if badge == ValidationBadge.SAFETY_BLOCKED:
        current_badges = [b for b in current_badges if b != ValidationBadge.SAFETY_OK]

    # ì¤‘ë³µ ë°©ì§€
    if badge not in current_badges:
        current_badges.append(badge)

    # agent_console ì—…ë°ì´íŠ¸
    new_console = ctx.output.agent_console.model_copy(update={"badges": current_badges})
    ctx.output = ctx.output.model_copy(update={"agent_console": new_console})

    logger.debug(
        "[Render] ë°°ì§€ ì¶”ê°€ë¨",
        extra={"badge": badge.value, "total_badges": len(current_badges)},
    )

    return ctx


def _update_render_output(
    ctx: PipelineContext,
    *,
    image_url: str | None,
    image_id: str | None,
    generation_time_ms: int,
) -> PipelineContext:
    """TurnOutput.renderì— ì´ë¯¸ì§€ ìƒì„± ê²°ê³¼ë¥¼ ë°˜ì˜í•©ë‹ˆë‹¤.

    í˜ì–´ë§ ì§ˆë¬¸ Q1: Option A (ctx.output ê°±ì‹ ) ì±„íƒ
    - Pydantic ëª¨ë¸ì€ frozenì´ ì•„ë‹ˆë¯€ë¡œ ì§ì ‘ ìˆ˜ì • ê°€ëŠ¥
    - model_copy()ë¥¼ ì‚¬ìš©í•˜ì—¬ ìƒˆ RenderOutput ìƒì„± í›„ êµì²´

    Args:
        ctx: íŒŒì´í”„ë¼ì¸ ì»¨í…ìŠ¤íŠ¸
        image_url: ìƒì„±ëœ ì´ë¯¸ì§€ URL
        image_id: ìƒì„±ëœ ì´ë¯¸ì§€ ID
        generation_time_ms: ìƒì„± ì†Œìš” ì‹œê°„ (ms)

    Returns:
        ì—…ë°ì´íŠ¸ëœ ì»¨í…ìŠ¤íŠ¸
    """
    if ctx.output is None:
        return ctx

    # ê¸°ì¡´ RenderOutputì„ ë³µì‚¬í•˜ê³  ìƒˆ í•„ë“œ ì¶”ê°€
    # U-069: ë°±ì—”ë“œì—ì„œ ì´ë¯¸ì§€ ìƒì„± ì™„ë£Œ í›„ should_generate=Falseë¡œ ì„¤ì •
    # í´ë¼ì´ì–¸íŠ¸ê°€ ì¤‘ë³µ ìƒì„± ìš”ì²­ì„ ë³´ë‚´ì§€ ì•Šë„ë¡ í•¨
    old_render = ctx.output.render
    updated_image_job = None
    if old_render.image_job is not None:
        # should_generateë¥¼ Falseë¡œ ë³€ê²½í•˜ì—¬ í´ë¼ì´ì–¸íŠ¸ ì¤‘ë³µ ìƒì„± ë°©ì§€
        updated_image_job = old_render.image_job.model_copy(update={"should_generate": False})

    new_render = RenderOutput(
        image_job=updated_image_job,
        image_url=image_url,
        image_id=image_id,
        generation_time_ms=generation_time_ms,
    )

    # TurnOutput ì „ì²´ë¥¼ model_copyë¡œ ê°±ì‹ 
    ctx.output = ctx.output.model_copy(update={"render": new_render})

    logger.debug(
        "[Render] TurnOutput.render ì—…ë°ì´íŠ¸ ì™„ë£Œ",
        extra={
            "image_id": image_id,
            "image_url": image_url,
        },
    )

    return ctx


async def render_stage(ctx: PipelineContext, *, emit: EmitFn) -> PipelineContext:
    """Render ë‹¨ê³„ë¥¼ ì‹¤í–‰í•©ë‹ˆë‹¤.

    ì´ë¯¸ì§€ ìƒì„± ì„œë¹„ìŠ¤ê°€ ì£¼ì…ë˜ì—ˆìœ¼ë©´ ì´ë¯¸ì§€ ìƒì„± íŒŒì´í”„ë¼ì¸ì„ ì‹¤í–‰í•©ë‹ˆë‹¤.
    ì£¼ì…ë˜ì§€ ì•Šì•˜ê±°ë‚˜ ì´ë¯¸ì§€ ìƒì„±ì´ í•„ìš” ì—†ëŠ” ê²½ìš° pass-throughë¡œ ë™ì‘í•©ë‹ˆë‹¤.

    U-051ì—ì„œ ë¸Œë¦¿ì§€ê°€ êµ¬ì¶•ë˜ì—ˆìœ¼ë©°, ì‹¤ì œ ì´ë¯¸ì§€ ìƒì„± ë¡œì§ì€ U-052/U-053ì—ì„œ ì¶”ê°€ë©ë‹ˆë‹¤:
    - U-052: should_generate íŒì • ë° í”„ë¡¬í”„íŠ¸/í•´ìƒë„ ì¶”ì¶œ
    - U-053: ë¹„ë™ê¸° ì´ë¯¸ì§€ ìƒì„± í˜¸ì¶œ ë° ê²°ê³¼ ë™ê¸°í™”

    Args:
        ctx: íŒŒì´í”„ë¼ì¸ ì»¨í…ìŠ¤íŠ¸ (image_generator í¬í•¨ ê°€ëŠ¥)
        emit: ì´ë²¤íŠ¸ emit ì½œë°±

    Returns:
        ì—…ë°ì´íŠ¸ëœ ì»¨í…ìŠ¤íŠ¸
    """
    ctx.current_phase = AgentPhase.RENDER

    # Stage ì‹œì‘ ì´ë²¤íŠ¸
    await emit(
        PipelineEvent(
            event_type=PipelineEventType.STAGE_START,
            phase=AgentPhase.RENDER,
        )
    )

    # U-051/U-052: ì´ë¯¸ì§€ ìƒì„± ì„œë¹„ìŠ¤ ë° íŒì • ë¡œì§
    image_decision: ImageGenerationDecision | None = None

    if ctx.image_generator is not None:
        # ì´ë¯¸ì§€ ìƒì„± ì„œë¹„ìŠ¤ê°€ ì£¼ì…ë¨ - ì—°ê²° ì¤€ë¹„ ì™„ë£Œ
        logger.debug(
            "[Render] ì´ë¯¸ì§€ ìƒì„± ì„œë¹„ìŠ¤ ì—°ê²°ë¨",
            extra={
                "generator_type": type(ctx.image_generator).__name__,
                "is_available": ctx.image_generator.is_available(),
            },
        )

        # U-052: ì´ë¯¸ì§€ ìƒì„± ì—¬ë¶€ íŒì •
        if ctx.output is not None:
            # Economy ìŠ¤ëƒ…ìƒ·ì„ EconomySnapshotìœ¼ë¡œ ë³€í™˜
            economy_snapshot = EconomySnapshot(
                signal=ctx.economy_snapshot.signal,
                memory_shard=ctx.economy_snapshot.memory_shard,
            )

            # íŒì • ìˆ˜í–‰ (U-068: ì´ì „ ì´ë¯¸ì§€ URLì„ ì°¸ì¡° ì´ë¯¸ì§€ë¡œ ì „ë‹¬)
            image_decision = decide_image_generation(
                turn_output=ctx.output,
                economy_snapshot=economy_snapshot,
                language=ctx.turn_input.language.value,
                previous_image_url=ctx.turn_input.previous_image_url,
            )

            # íŒì • ê²°ê³¼ ë¡œê¹… (í”„ë¡¬í”„íŠ¸ ì›ë¬¸ ì œì™¸ - RULE-007)
            logger.info(
                "[Render] ì´ë¯¸ì§€ ìƒì„± íŒì • ì™„ë£Œ",
                extra={
                    "should_generate": image_decision.should_generate,
                    "reason": image_decision.reason,
                    "prompt_hash": image_decision.prompt_hash,
                    "estimated_cost": image_decision.estimated_cost_signal,
                    "is_low_balance_fallback": image_decision.is_low_balance_fallback,
                    "model_override": image_decision.model_override,
                },
            )

            # U-053: ì´ë¯¸ì§€ ìƒì„±ì´ í•„ìš”í•œ ê²½ìš° ë¹„ë™ê¸° í˜¸ì¶œ
            # U-079: FAST í´ë°± í¬í•¨ (ì”ì•¡ ë¶€ì¡±ì´ì–´ë„ should_generate=True)
            if image_decision.should_generate:
                ctx = await _execute_image_generation(
                    ctx=ctx,
                    image_decision=image_decision,
                    emit=emit,
                )

                # U-079: ì”ì•¡ ë¶€ì¡± í´ë°± ë°œìƒ ì‹œ ê²½ì œ ì •ë³´ ì‚¬í›„ ì¡°ì •
                if image_decision.is_low_balance_fallback:
                    ctx = _adjust_economy_for_fallback(ctx, image_decision)
        else:
            logger.debug("[Render] TurnOutput ì—†ìŒ, ì´ë¯¸ì§€ íŒì • ê±´ë„ˆëœ€")
    else:
        # ì´ë¯¸ì§€ ìƒì„± ì„œë¹„ìŠ¤ ë¯¸ì£¼ì… - pass-through ë™ì‘
        logger.debug("[Render] ì´ë¯¸ì§€ ìƒì„± ì„œë¹„ìŠ¤ ë¯¸ì£¼ì…, pass-through ë™ì‘")

    # ëª¨ì˜ ì²˜ë¦¬ ì§€ì—° (ê¸°ì¡´ ë™ì‘ ë³´ì¡´)
    await asyncio.sleep(RENDER_DELAY_MS / 1000.0)

    # Stage ì™„ë£Œ ì´ë²¤íŠ¸
    await emit(
        PipelineEvent(
            event_type=PipelineEventType.STAGE_COMPLETE,
            phase=AgentPhase.RENDER,
        )
    )

    return ctx


def _adjust_economy_for_fallback(
    ctx: PipelineContext,
    image_decision: ImageGenerationDecision,
) -> PipelineContext:
    """ì”ì•¡ ë¶€ì¡± í´ë°± ë°œìƒ ì‹œ ê²½ì œ ì •ë³´ë¥¼ ì¡°ì •í•©ë‹ˆë‹¤.

    U-079: FAST ëª¨ë¸ í´ë°± ì‹œ ë¹„ìš©ì„ 0ìœ¼ë¡œ ì¡°ì •í•˜ê³  ì”ì•¡ì„ ë³´ì¡´í•©ë‹ˆë‹¤.
    ë˜í•œ low_balance_warningì„ í™œì„±í™”í•©ë‹ˆë‹¤.

    Args:
        ctx: íŒŒì´í”„ë¼ì¸ ì»¨í…ìŠ¤íŠ¸
        image_decision: ì´ë¯¸ì§€ ìƒì„± íŒì • ê²°ê³¼

    Returns:
        ì—…ë°ì´íŠ¸ëœ ì»¨í…ìŠ¤íŠ¸
    """
    if ctx.output is None:
        return ctx

    logger.info(
        "[Render] U-079: ê²½ì œ ì •ë³´ ì¡°ì • (FAST í´ë°± ì ìš©)",
        extra={
            "original_cost": ctx.output.economy.cost.signal,
            "new_cost": image_decision.estimated_cost_signal,
        },
    )

    # 1. ë¹„ìš© ì¡°ì • (FAST_IMAGE_COST_SIGNAL = 0)
    new_cost = ctx.output.economy.cost.model_copy(
        update={"signal": image_decision.estimated_cost_signal}
    )

    # 2. ì”ì•¡ ì¬ê³„ì‚° (snapshot - new_cost)
    # RULE-005 ì¤€ìˆ˜ë¥¼ ìœ„í•´ balance_afterë¥¼ ë‹¤ì‹œ ê³„ì‚°
    new_signal = max(0, ctx.economy_snapshot.signal - image_decision.estimated_cost_signal)
    new_shard = max(0, ctx.economy_snapshot.memory_shard - new_cost.memory_shard)

    new_balance = ctx.output.economy.balance_after.model_copy(
        update={"signal": new_signal, "memory_shard": new_shard}
    )

    # 3. EconomyOutput ì—…ë°ì´íŠ¸
    new_economy = ctx.output.economy.model_copy(
        update={
            "cost": new_cost,
            "balance_after": new_balance,
            "low_balance_warning": True,
        }
    )

    ctx.output = ctx.output.model_copy(update={"economy": new_economy})

    return ctx
</file>

<file path="frontend/src/stores/worldStore.ts">
/**
 * Unknown World - World/Session ìƒíƒœ ê´€ë¦¬ (Zustand) (RU-003-Q4).
 *
 * TurnOutput ë°˜ì˜ìœ¼ë¡œ ê°±ì‹ ë˜ëŠ” ì„¸ì…˜ ì›”ë“œ/UI ìƒíƒœë¥¼ SSOTë¡œ ê´€ë¦¬í•©ë‹ˆë‹¤.
 * App.tsxì˜ ë¡œì»¬ ìƒíƒœë¥¼ ì´ ìŠ¤í† ì–´ë¡œ ì´ë™í•˜ì—¬ ì±…ì„ ê²½ê³„ë¥¼ ëª…í™•íˆ í•©ë‹ˆë‹¤.
 *
 * ì„¤ê³„ ì›ì¹™:
 *   - RU-003 Q1 ê²°ì •: ë„ë©”ì¸ë³„ store ë¶„ë¦¬ (Option A)
 *   - RULE-005: Economy ì¸ë°”ë¦¬ì–¸íŠ¸ (ì”ì•¡ ìŒìˆ˜ ê¸ˆì§€)
 *   - RULE-006: ko/en i18n ì •ì±… ì¤€ìˆ˜
 *
 * í™•ì¥ (U-013):
 *   - Quest/Rules/MutationEvent ìƒíƒœ ì¶”ê°€
 *   - applyTurnOutputì—ì„œ quests_updated, rules_changed ë°˜ì˜
 *
 * ìˆœí™˜ import ë°©ì§€:
 *   - worldStore â†’ (actionDeckStore/inventoryStore) ë‹¨ë°©í–¥ë§Œ í—ˆìš©
 *   - ì—­ë°©í–¥ import ê¸ˆì§€
 *
 * @module stores/worldStore
 */

import { create } from 'zustand';
import type { TurnOutput, SceneObject, Quest, WorldRule } from '../schemas/turn';
import type { SceneCanvasState, SceneProcessingPhase } from '../types/scene';
import { useActionDeckStore } from './actionDeckStore';
import { useInventoryStore, parseInventoryAdded } from './inventoryStore';
import { useEconomyStore } from './economyStore';
import { ITEM_SELL_PRICE_SIGNAL } from '../save/constants';
import i18n from '../i18n';

// =============================================================================
// íƒ€ì… ì •ì˜
// =============================================================================

/** ì¬í™” ìƒíƒœ */
export interface EconomyState {
  signal: number;
  memory_shard: number;
  /** ì‚¬ìš© ì¤‘ì¸ í¬ë ˆë”§ (ë¹š, Signal ë‹¨ìœ„, U-079) */
  credit: number;
}

/**
 * ë‚´ëŸ¬í‹°ë¸Œ ì—”íŠ¸ë¦¬ íƒ€ì…
 *
 * U-070[Mvp]: ì•¡ì…˜ ë¡œê·¸ ì§€ì›ì„ ìœ„í•´ type í•„ë“œ ì¶”ê°€
 * - "narrative": ì¼ë°˜ ê²Œì„ ë‚´ëŸ¬í‹°ë¸Œ (ì„œë²„ì—ì„œ ìƒì„±)
 * - "action_log": í”Œë ˆì´ì–´ í–‰ë™ ë¡œê·¸ (í´ë¼ì´ì–¸íŠ¸ì—ì„œ ìƒì„±, ì¦‰ê°ì  í”¼ë“œë°±)
 * - "system": ì‹œìŠ¤í…œ ë©”ì‹œì§€ (ë“œë¡­ ì‹¤íŒ¨ ë“±)
 */
export type NarrativeEntryType = 'narrative' | 'action_log' | 'system';

/** ë‚´ëŸ¬í‹°ë¸Œ ì—”íŠ¸ë¦¬ */
export interface NarrativeEntry {
  turn: number;
  text: string;
  /** U-070: ì—”íŠ¸ë¦¬ íƒ€ì… (ê¸°ë³¸ê°’: "narrative") */
  type?: NarrativeEntryType;
}

/**
 * ë£° ë³€í˜• ì´ë²¤íŠ¸ (U-013: Mutation Timeline)
 * ê·œì¹™ì´ ë³€ê²½ëœ ì‹œì ê³¼ ë‚´ìš©ì„ ê¸°ë¡í•©ë‹ˆë‹¤.
 */
export interface MutationEvent {
  /** ë³€í˜• ë°œìƒ í„´ */
  turn: number;
  /** ë³€í˜•ëœ ê·œì¹™ ID */
  ruleId: string;
  /** ë³€í˜• ìœ í˜•: ì¶”ê°€/ìˆ˜ì •/ì œê±° */
  type: 'added' | 'modified' | 'removed';
  /** ê·œì¹™ ë¼ë²¨ (í‘œì‹œìš©) */
  label: string;
  /** ê·œì¹™ ì„¤ëª… (ì„ íƒ) */
  description?: string;
  /** íƒ€ì„ìŠ¤íƒ¬í”„ */
  timestamp: number;
}

/**
 * U-079: ì¬í™” íšë“ í† ìŠ¤íŠ¸ ì•Œë¦¼ ë°ì´í„°.
 * ì•„ì´í…œ íŒë§¤, í€˜ìŠ¤íŠ¸ ë³´ìƒ ë“± ì¬í™” ë³€ë™ ì‹œ íŒì—… í‘œì‹œ.
 */
export interface CurrencyToast {
  /** í† ìŠ¤íŠ¸ ê³ ìœ  ID (ì¤‘ë³µ ë°©ì§€) */
  id: string;
  /** ë³€ë™ëœ Signal ì–‘ (ì–‘ìˆ˜: íšë“, ìŒìˆ˜: ì†Œë¹„) */
  signalDelta: number;
  /** ë³€ë™ ì‚¬ìœ  í‘œì‹œ í…ìŠ¤íŠ¸ */
  reason: string;
  /** ìƒì„± ì‹œê°„ (ìë™ ë‹«í˜ ê³„ì‚°ìš©) */
  createdAt: number;
}

/** World/Session ìƒíƒœ */
export interface WorldState {
  /** ì¬í™” ìƒíƒœ (RULE-005) */
  economy: EconomyState;
  /** ì—°ê²° ìƒíƒœ */
  isConnected: boolean;
  /** Scene Canvas ìƒíƒœ (U-031) */
  sceneState: SceneCanvasState;
  /** Scene Objects (U-010: í•«ìŠ¤íŒŸ ì˜¤ë²„ë ˆì´) */
  sceneObjects: SceneObject[];
  /** ë‚´ëŸ¬í‹°ë¸Œ íˆìŠ¤í† ë¦¬ */
  narrativeEntries: NarrativeEntry[];
  /** í˜„ì¬ í„´ ì¹´ìš´íŠ¸ */
  turnCount: number;

  // ============ U-013: Quest + Rule Board í™•ì¥ ============

  /** í˜„ì¬ í€˜ìŠ¤íŠ¸/ëª©í‘œ ëª©ë¡ */
  quests: Quest[];
  /** í˜„ì¬ ì ìš© ì¤‘ì¸ ê·œì¹™ ëª©ë¡ */
  activeRules: WorldRule[];
  /** ë£° ë³€í˜• ì´ë²¤íŠ¸ íƒ€ì„ë¼ì¸ (ìµœì‹ ìˆœ) */
  mutationTimeline: MutationEvent[];

  // ============ U-089: ì •ë°€ë¶„ì„ ìƒíƒœ ============

  /**
   * ì •ë°€ë¶„ì„(Agentic Vision) ì‹¤í–‰ ì¤‘ ì—¬ë¶€ (U-089).
   * trueì¼ ë•Œ SceneImageëŠ” ê¸°ì¡´ ì´ë¯¸ì§€ë¥¼ ìœ ì§€í•˜ê³  ë¶„ì„ ì „ìš© ì˜¤ë²„ë ˆì´ë¥¼ í‘œì‹œí•©ë‹ˆë‹¤.
   */
  isAnalyzing: boolean;

  // ============ U-079: ì¬í™” íšë“ í† ìŠ¤íŠ¸ ì•Œë¦¼ ============

  /**
   * í˜„ì¬ í‘œì‹œ ì¤‘ì¸ í† ìŠ¤íŠ¸ ì•Œë¦¼ (U-079).
   * nullì´ë©´ í† ìŠ¤íŠ¸ ì—†ìŒ, ê°’ì´ ìˆìœ¼ë©´ ì¼ì • ì‹œê°„ í›„ ìë™ ì‚¬ë¼ì§.
   */
  currencyToast: CurrencyToast | null;
}

/** World Store ì•¡ì…˜ */
export interface WorldActions {
  /**
   * TurnOutputì„ ë°›ì•„ ëª¨ë“  ê´€ë ¨ ìƒíƒœë¥¼ ì—…ë°ì´íŠ¸í•©ë‹ˆë‹¤.
   * ì´ ë©”ì„œë“œê°€ TurnOutput ë°˜ì˜ì˜ SSOTì…ë‹ˆë‹¤.
   */
  applyTurnOutput: (output: TurnOutput) => void;

  /**
   * ì‹œìŠ¤í…œ ë‚´ëŸ¬í‹°ë¸Œë¥¼ ì¶”ê°€í•©ë‹ˆë‹¤ (í„´ ë¯¸ë°œìƒ í”¼ë“œë°±ìš©).
   * ë“œë¡­ ì‹¤íŒ¨ ë“± í„´ì„ ë°œìƒì‹œí‚¤ì§€ ì•ŠëŠ” í”¼ë“œë°±ì— ì‚¬ìš©í•©ë‹ˆë‹¤.
   */
  appendSystemNarrative: (text: string) => void;

  /**
   * U-070[Mvp]: ì•¡ì…˜ ë¡œê·¸ë¥¼ ì¶”ê°€í•©ë‹ˆë‹¤.
   * í”Œë ˆì´ì–´ í–‰ë™ì— ëŒ€í•œ ì¦‰ê°ì  í”¼ë“œë°±ìœ¼ë¡œ, TurnInput ì „ì†¡ ì „ì— í˜¸ì¶œí•©ë‹ˆë‹¤.
   * PRD 9.0: "í–‰ë™ ì‹¤í–‰: ..." í˜•ì‹ìœ¼ë¡œ í‘œì‹œë©ë‹ˆë‹¤.
   */
  appendActionLog: (text: string) => void;

  /** Scene ìƒíƒœ ì„¤ì • */
  setSceneState: (state: SceneCanvasState) => void;

  /** ì—°ê²° ìƒíƒœ ì„¤ì • */
  setConnected: (connected: boolean) => void;

  /** ê²½ì œ ìƒíƒœ ì„¤ì • (ì§ì ‘ ì¡°ì‘ìš©, ì¼ë°˜ì ìœ¼ë¡œ applyTurnOutput ì‚¬ìš©) */
  setEconomy: (economy: EconomyState) => void;

  /** Scene Objects ì„¤ì • (ì§ì ‘ ì¡°ì‘ìš©) */
  setSceneObjects: (objects: SceneObject[]) => void;

  /** ì´ˆê¸°í™” (ì´ˆê¸° ë‚´ëŸ¬í‹°ë¸Œ ë©”ì‹œì§€ í¬í•¨) */
  initialize: (welcomeMessage: string) => void;

  /** ìƒíƒœ ì™„ì „ ì´ˆê¸°í™” */
  reset: () => void;

  // ============ U-066: Late-binding ì´ë¯¸ì§€ ê´€ë¦¬ ============

  /**
   * ì´ë¯¸ì§€ ë¡œë”© ìƒíƒœë¥¼ ì„¤ì •í•©ë‹ˆë‹¤ (U-066).
   * ì´ë¯¸ì§€ ìƒì„± ì‹œì‘ ì‹œ í˜¸ì¶œí•˜ì—¬ ë¡œë”© ì¸ë””ì¼€ì´í„°ë¥¼ í‘œì‹œí•©ë‹ˆë‹¤.
   *
   * @param turnId - ì´ë¯¸ì§€ë¥¼ ìš”ì²­í•œ í„´ ID
   */
  setImageLoading: (turnId: number) => void;

  /**
   * Late-binding ì´ë¯¸ì§€ë¥¼ ì ìš©í•©ë‹ˆë‹¤ (U-066).
   * ì´ë¯¸ì§€ ìƒì„± ì™„ë£Œ ì‹œ í˜¸ì¶œí•˜ì—¬, turnIdê°€ ì¼ì¹˜í•  ë•Œë§Œ ì´ë¯¸ì§€ë¥¼ ë°˜ì˜í•©ë‹ˆë‹¤.
   *
   * @param imageUrl - ìƒì„±ëœ ì´ë¯¸ì§€ URL
   * @param turnId - ì´ë¯¸ì§€ë¥¼ ìš”ì²­í•œ í„´ ID (ê°€ë“œìš©)
   * @returns ì´ë¯¸ì§€ê°€ ì ìš©ë˜ì—ˆëŠ”ì§€ ì—¬ë¶€
   */
  applyLateBindingImage: (imageUrl: string, turnId: number) => boolean;

  /**
   * ì´ë¯¸ì§€ ë¡œë”©ì„ ì·¨ì†Œí•©ë‹ˆë‹¤ (U-066).
   * ìƒˆ í„´ ì‹œì‘ ë˜ëŠ” ì´ë¯¸ì§€ ìƒì„± ì‹¤íŒ¨ ì‹œ í˜¸ì¶œí•©ë‹ˆë‹¤.
   */
  cancelImageLoading: () => void;

  // ============ U-071: ì²˜ë¦¬ ë‹¨ê³„ UI ê´€ë¦¬ ============

  /**
   * ì²˜ë¦¬ ë‹¨ê³„ë¥¼ ì„¤ì •í•©ë‹ˆë‹¤ (U-071).
   * Scene Canvasì— í˜„ì¬ ì²˜ë¦¬ ìƒíƒœë¥¼ í‘œì‹œí•˜ê¸° ìœ„í•´ ì‚¬ìš©í•©ë‹ˆë‹¤.
   *
   * @param phase - í˜„ì¬ ì²˜ë¦¬ ë‹¨ê³„ (idle, processing, image_pending, rendering)
   */
  setProcessingPhase: (phase: SceneProcessingPhase) => void;

  // ============ U-089: ì •ë°€ë¶„ì„ ìƒíƒœ ê´€ë¦¬ ============

  /**
   * ì •ë°€ë¶„ì„(Agentic Vision) ì‹¤í–‰ ìƒíƒœë¥¼ ì„¤ì •í•©ë‹ˆë‹¤ (U-089).
   * trueë¡œ ì„¤ì •í•˜ë©´ SceneImageê°€ ê¸°ì¡´ ì´ë¯¸ì§€ë¥¼ ìœ ì§€í•˜ë©´ì„œ ë¶„ì„ ì „ìš© ì˜¤ë²„ë ˆì´ë¥¼ í‘œì‹œí•©ë‹ˆë‹¤.
   *
   * @param analyzing - ë¶„ì„ ì‹¤í–‰ ì¤‘ ì—¬ë¶€
   */
  setIsAnalyzing: (analyzing: boolean) => void;

  // ============ U-079: ì•„ì´í…œ íŒë§¤ + í† ìŠ¤íŠ¸ ============

  /**
   * ì•„ì´í…œì„ íŒë§¤í•˜ì—¬ Signalì„ íšë“í•©ë‹ˆë‹¤ (U-079).
   * ì¸ë²¤í† ë¦¬ì—ì„œ ìˆ˜ëŸ‰ 1 ê°ì†Œ, economyì— íŒë§¤ ê°€ê²© ì¶”ê°€, Ledger ê¸°ë¡.
   *
   * @param itemId - íŒë§¤í•  ì•„ì´í…œ ID
   * @param itemName - ì•„ì´í…œ ì´ë¦„ (í† ìŠ¤íŠ¸ í‘œì‹œìš©)
   */
  sellItem: (itemId: string, itemName: string) => void;

  /**
   * ì¬í™” íšë“ í† ìŠ¤íŠ¸ë¥¼ í‘œì‹œí•©ë‹ˆë‹¤ (U-079).
   * ì¼ì • ì‹œê°„ í›„ ìë™ìœ¼ë¡œ ì‚¬ë¼ì§‘ë‹ˆë‹¤.
   */
  showCurrencyToast: (toast: Omit<CurrencyToast, 'id' | 'createdAt'>) => void;

  /**
   * í† ìŠ¤íŠ¸ë¥¼ ë‹«ìŠµë‹ˆë‹¤ (U-079).
   */
  dismissCurrencyToast: () => void;
}

export type WorldStore = WorldState & WorldActions;

// =============================================================================
// ì´ˆê¸° ìƒíƒœ
// =============================================================================

/**
 * ì´ˆê¸° ìƒíƒœë¥¼ ìƒì„±í•©ë‹ˆë‹¤.
 *
 * RU-004-Q5: ì´ˆê¸°ê°’ ì •ì±… SSOT
 *
 * ## ì¤‘ìš”: ì´ ê°’ë“¤ì€ "í”Œë ˆì´ ì „ placeholder"ì…ë‹ˆë‹¤.
 *
 * ì‹¤ì œ ê²Œì„ ì‹œì‘ ê°’ì€ í•­ìƒ ë‹¤ìŒ ì¤‘ í•˜ë‚˜ì—ì„œ ì£¼ì…ë©ë‹ˆë‹¤:
 * 1. í”„ë¡œí•„ ì´ˆê¸° SaveGame (startSessionFromProfile)
 * 2. ì €ì¥ëœ SaveGame ë³µì› (continueSession)
 *
 * profile_select ìƒíƒœì—ì„œëŠ” HUDê°€ ë…¸ì¶œë˜ì§€ ì•Šìœ¼ë¯€ë¡œ
 * ì´ placeholder ê°’ì´ í™”ë©´ì— í‘œì‹œë  ì¼ì€ ì—†ìŠµë‹ˆë‹¤.
 *
 * @see save/constants.ts#INITIAL_VALUE_POLICY
 * @see save/sessionLifecycle.ts
 */
function createInitialState(): WorldState {
  return {
    // RU-004-Q5: Placeholder - ì‹¤ì œ ê°’ì€ í”„ë¡œí•„/ì„¸ì´ë¸Œì—ì„œ ì£¼ì…ë¨
    economy: { signal: 100, memory_shard: 5, credit: 0 },
    isConnected: true,
    sceneState: { status: 'default', message: '' },
    sceneObjects: [],
    narrativeEntries: [],
    turnCount: 0,
    // U-013: Quest + Rule Board ì´ˆê¸° ìƒíƒœ
    quests: [],
    activeRules: [],
    mutationTimeline: [],
    // U-089: ì •ë°€ë¶„ì„ ìƒíƒœ
    isAnalyzing: false,
    // U-079: ì¬í™” íšë“ í† ìŠ¤íŠ¸
    currencyToast: null,
  };
}

// =============================================================================
// Zustand Store
// =============================================================================

/**
 * World/Session ìƒíƒœ ìŠ¤í† ì–´.
 *
 * TurnOutput ë°˜ì˜ì˜ SSOTë¡œ, App.tsxì˜ ë¡œì»¬ ìƒíƒœë¥¼ ëŒ€ì²´í•©ë‹ˆë‹¤.
 *
 * @example
 * ```tsx
 * // ì»´í¬ë„ŒíŠ¸ì—ì„œ ìƒíƒœ êµ¬ë…
 * const { economy, narrativeEntries } = useWorldStore();
 *
 * // TurnOutput ë°˜ì˜ (ìŠ¤íŠ¸ë¦¼ ì™„ë£Œ ì‹œ)
 * const applyTurnOutput = useWorldStore((state) => state.applyTurnOutput);
 * applyTurnOutput(turnOutput);
 *
 * // ì‹œìŠ¤í…œ í”¼ë“œë°± ì¶”ê°€ (ë“œë¡­ ì‹¤íŒ¨ ë“±)
 * const appendSystemNarrative = useWorldStore((state) => state.appendSystemNarrative);
 * appendSystemNarrative('ì•„ì´í…œì„ ì‚¬ìš©í•  ìˆ˜ ì—†ìŠµë‹ˆë‹¤.');
 * ```
 */
export const useWorldStore = create<WorldStore>((set, get) => ({
  // ì´ˆê¸° ìƒíƒœ
  ...createInitialState(),

  // ì•¡ì…˜

  applyTurnOutput: (output) => {
    const state = get();

    // 1. í„´ ì¹´ìš´íŠ¸ ì¦ê°€
    const newTurnCount = state.turnCount + 1;

    // 2. ë‚´ëŸ¬í‹°ë¸Œ ì¶”ê°€ (U-070: type ëª…ì‹œ)
    const newNarrativeEntry: NarrativeEntry = {
      turn: newTurnCount,
      text: output.narrative,
      type: 'narrative',
    };

    const newNarrativeEntries = [...state.narrativeEntries, newNarrativeEntry];

    // U-072: Scanner íŒíŠ¸ ìœ ë„ (Option A: ë°±ì—”ë“œ í”Œë˜ê·¸ ê¸°ë°˜)
    if (output.hints?.scanner) {
      newNarrativeEntries.push({
        turn: newTurnCount,
        text: i18n.t('scanner.hint_narrative'),
        type: 'system',
      });
    }

    // 3. ê²½ì œ ìƒíƒœ ì—…ë°ì´íŠ¸ (RULE-005: balance_after ë°˜ì˜)
    const newEconomy: EconomyState = {
      signal: output.economy.balance_after.signal,
      memory_shard: output.economy.balance_after.memory_shard,
      credit: output.economy.credit,
    };

    // 4. Scene Objects ì—…ë°ì´íŠ¸ (U-010: í•«ìŠ¤íŒŸ ì˜¤ë²„ë ˆì´)
    // U-090: í•«ìŠ¤íŒŸ ìƒíƒœ ê´€ë¦¬ ì •ì±…
    //   - ìƒˆ ì´ë¯¸ì§€ ìƒì„±(ì¥ë©´ ì „í™˜) â†’ í•«ìŠ¤íŒŸ ì „ì²´ ì´ˆê¸°í™” (Q1: Option A)
    //   - ì„œë²„ì—ì„œ objects ë¹„ì–´ìˆìŒ(ì¼ë°˜ í„´) â†’ ê¸°ì¡´ í•«ìŠ¤íŒŸ ìœ ì§€
    //   - ì„œë²„ì—ì„œ objects ìˆìŒ(ì •ë°€ë¶„ì„ í„´) â†’ ê¸°ì¡´ í•«ìŠ¤íŒŸì— ë³‘í•©
    //
    // ì¥ë©´ ì „í™˜ ê°ì§€:
    //   - render.image_urlì´ ì¡´ì¬ â†’ ì´ë²ˆ í„´ì—ì„œ ìƒˆ ì´ë¯¸ì§€ê°€ ìƒì„±ë¨ (ë™ê¸° ìƒì„± ì™„ë£Œ)
    //   - render.image_job.should_generate === true â†’ ë¹„ë™ê¸°(late-binding) ì´ë¯¸ì§€ ìƒì„± ì˜ˆì •
    //   ì–´ëŠ ê²½ìš°ë“  ìƒˆ ì¥ë©´ì´ë¯€ë¡œ ê¸°ì¡´ í•«ìŠ¤íŒŸì„ ì´ˆê¸°í™”í•œë‹¤.
    const isNewImageGeneration =
      !!output.render?.image_url || output.render?.image_job?.should_generate === true;

    let newSceneObjects: SceneObject[];

    if (isNewImageGeneration) {
      // Q1 Option A: ì¥ë©´ ì „í™˜(ìƒˆ ì´ë¯¸ì§€ ìƒì„±) â†’ í•«ìŠ¤íŒŸ ì „ì²´ ì´ˆê¸°í™”
      // ìƒˆ ì¥ë©´ì—ì„œëŠ” ì •ë°€ë¶„ì„ì„ ë‹¤ì‹œ í•´ì•¼ í•¨
      newSceneObjects = [];
    } else if (output.ui.objects.length > 0) {
      // ì •ë°€ë¶„ì„ ê²°ê³¼ ìˆìŒ â†’ ê¸°ì¡´ í•«ìŠ¤íŒŸì— ë³‘í•©
      // ë™ì¼ IDëŠ” ìƒˆ ê²°ê³¼ë¡œ ì—…ë°ì´íŠ¸, ìƒˆ IDëŠ” ì¶”ê°€
      const mergedMap = new Map(state.sceneObjects.map((o) => [o.id, o]));
      for (const obj of output.ui.objects) {
        mergedMap.set(obj.id, obj);
      }
      newSceneObjects = Array.from(mergedMap.values());
    } else {
      // ì¼ë°˜ í„´(objects ë¹„ì–´ìˆìŒ) â†’ ê¸°ì¡´ í•«ìŠ¤íŒŸ ìœ ì§€
      newSceneObjects = state.sceneObjects;
    }

    // 5. Scene ìƒíƒœ ì „ì´ (RU-003-T1: Scene ì´ë¯¸ì§€ SSOT)
    // - output.ui.scene.image_urlì´ ì¡´ì¬í•˜ë©´ 'scene' ìƒíƒœë¡œ ì „í™˜
    // - ì—†ìœ¼ë©´ 'default' ìƒíƒœ ìœ ì§€
    // - safety.blockedì¸ ê²½ìš° 'blocked' ìƒíƒœë¡œ ì „í™˜
    let newSceneState: SceneCanvasState;
    const currentImageUrl = state.sceneState.imageUrl ?? state.sceneState.previousImageUrl;

    if (output.safety.blocked) {
      newSceneState = {
        status: 'blocked',
        message: output.safety.message ?? undefined,
        previousImageUrl: currentImageUrl,
      };
    } else if (output.ui.scene?.image_url || output.render?.image_url) {
      // U-053: render.image_url ë˜ëŠ” ui.scene.image_url ì¤‘ í•˜ë‚˜ë¼ë„ ìˆìœ¼ë©´ scene ìƒíƒœë¡œ ì „í™˜
      const imageUrl = output.ui.scene?.image_url || output.render?.image_url;
      newSceneState = {
        status: 'scene',
        imageUrl: imageUrl!,
        message: output.ui.scene?.alt_text ?? undefined,
        // ìƒˆë¡œìš´ ì´ë¯¸ì§€ê°€ ì™”ìœ¼ë¯€ë¡œ ì´ì „ ì´ë¯¸ì§€ëŠ” ë³´ì¡´ (ë¡œë”© ì¤‘ì´ ì•„ë‹˜)
        previousImageUrl: currentImageUrl,
      };
    } else {
      newSceneState = {
        status: 'default',
        message: '',
        previousImageUrl: currentImageUrl,
      };
    }

    // 7. í•˜ìœ„ ìŠ¤í† ì–´ ì—…ë°ì´íŠ¸ (ìˆœí™˜ import ë°©ì§€: worldStore â†’ í•˜ìœ„ store ë‹¨ë°©í–¥)
    // Action Deck ì¹´ë“œ ì—…ë°ì´íŠ¸ (U-009)
    useActionDeckStore.getState().setCards(output.ui.action_deck.cards);

    // Inventory ì—…ë°ì´íŠ¸ (U-011)
    if (output.world.inventory_added.length > 0) {
      useInventoryStore.getState().addItems(parseInventoryAdded(output.world.inventory_added));
    }
    // U-096: ì•„ì´í…œ ì†Œë¹„ ì‹œ fade-out ì• ë‹ˆë©”ì´ì…˜ í›„ ì œê±°
    if (output.world.inventory_removed.length > 0) {
      const removedIds = output.world.inventory_removed;
      const invStore = useInventoryStore.getState();

      // 1ë‹¨ê³„: ì†Œë¹„ ì• ë‹ˆë©”ì´ì…˜ ì‹œì‘ (fade-out CSS í´ë˜ìŠ¤ ì ìš©)
      invStore.markConsuming(removedIds);

      // 2ë‹¨ê³„: ì• ë‹ˆë©”ì´ì…˜ ì™„ë£Œ í›„ ì‹¤ì œ ì œê±° (500ms = CSS transition ì‹œê°„)
      setTimeout(() => {
        useInventoryStore.getState().clearConsuming(removedIds);
      }, 500);
    }

    // Economy Store ì—…ë°ì´íŠ¸ (U-014: Ledger ê¸°ë¡)
    // U-069: ì„œë²„ì—ì„œ ì „ë‹¬ëœ model_label ì‚¬ìš© (FAST/QUALITY í‹°ì–´ë§)
    const economyStore = useEconomyStore.getState();
    economyStore.addLedgerEntry({
      turnId: newTurnCount,
      reason: output.narrative.slice(0, 50), // ë‚´ëŸ¬í‹°ë¸Œ ì• 50ìë¥¼ ì‚¬ìœ ë¡œ ì‚¬ìš©
      cost: output.economy.cost,
      balanceAfter: output.economy.balance_after,
      modelLabel: output.agent_console.model_label ?? 'FAST',
      lowBalanceWarning: output.economy.low_balance_warning,
    });
    // ì”ì•¡ ë¶€ì¡± ìƒíƒœ ì—…ë°ì´íŠ¸
    economyStore.updateBalanceLowStatus(newEconomy);

    // 6. Quest ìƒíƒœ ì—…ë°ì´íŠ¸ (U-013, U-078: ëª©í‘œ ì‹œìŠ¤í…œ ê°•í™”)
    // quests_updatedëŠ” ì „ì²´ í€˜ìŠ¤íŠ¸ ëª©ë¡ì´ ì•„ë‹Œ "ì—…ë°ì´íŠ¸ëœ" í€˜ìŠ¤íŠ¸ë§Œ í¬í•¨
    // ê¸°ì¡´ í€˜ìŠ¤íŠ¸ë¥¼ ì—…ë°ì´íŠ¸í•˜ê±°ë‚˜ ìƒˆ í€˜ìŠ¤íŠ¸ë¥¼ ì¶”ê°€
    // U-078: ì„œë¸Œ ëª©í‘œ ì™„ë£Œ ì‹œ ë³´ìƒ ì•Œë¦¼ ì‹œìŠ¤í…œ ë‚´ëŸ¬í‹°ë¸Œ ì¶”ê°€
    const newQuests = [...state.quests];
    for (const updatedQuest of output.world.quests_updated) {
      const existingIndex = newQuests.findIndex((q) => q.id === updatedQuest.id);
      if (existingIndex >= 0) {
        // U-078: ë¯¸ì™„ë£Œ â†’ ì™„ë£Œ ì „í™˜ ê°ì§€ (ë³´ìƒ í”¼ë“œë°±ìš©)
        const prevQuest = newQuests[existingIndex];
        if (
          !prevQuest.is_completed &&
          updatedQuest.is_completed &&
          updatedQuest.reward_signal > 0
        ) {
          newNarrativeEntries.push({
            turn: newTurnCount,
            text: `ğŸ¯ ${i18n.t('quest.objective_complete')} ${i18n.t('quest.reward_earned', { signal: updatedQuest.reward_signal })}`,
            type: 'system',
          });
        }
        // ê¸°ì¡´ í€˜ìŠ¤íŠ¸ ì—…ë°ì´íŠ¸
        newQuests[existingIndex] = updatedQuest;
      } else {
        // ìƒˆ í€˜ìŠ¤íŠ¸ ì¶”ê°€
        newQuests.push(updatedQuest);
      }
    }

    // 7. Rules ìƒíƒœ ì—…ë°ì´íŠ¸ + Mutation Timeline ê¸°ë¡ (U-013)
    const newActiveRules = [...state.activeRules];
    const newMutationEvents: MutationEvent[] = [];
    const now = Date.now();

    for (const changedRule of output.world.rules_changed) {
      const existingIndex = newActiveRules.findIndex((r) => r.id === changedRule.id);
      if (existingIndex >= 0) {
        // ê¸°ì¡´ ê·œì¹™ ìˆ˜ì •
        newActiveRules[existingIndex] = changedRule;
        newMutationEvents.push({
          turn: newTurnCount,
          ruleId: changedRule.id,
          type: 'modified',
          label: changedRule.label,
          description: changedRule.description ?? undefined,
          timestamp: now,
        });
      } else {
        // ìƒˆ ê·œì¹™ ì¶”ê°€
        newActiveRules.push(changedRule);
        newMutationEvents.push({
          turn: newTurnCount,
          ruleId: changedRule.id,
          type: 'added',
          label: changedRule.label,
          description: changedRule.description ?? undefined,
          timestamp: now,
        });
      }
    }

    // íƒ€ì„ë¼ì¸ì— ìƒˆ ì´ë²¤íŠ¸ ì¶”ê°€ (ìµœì‹ ìˆœ ì •ë ¬)
    const updatedTimeline = [...newMutationEvents, ...state.mutationTimeline];

    // 8. ìƒíƒœ ì—…ë°ì´íŠ¸ (RU-003-T1: sceneState í¬í•¨, U-013: quest/rules)
    set({
      turnCount: newTurnCount,
      narrativeEntries: newNarrativeEntries,
      economy: newEconomy,
      sceneObjects: newSceneObjects,
      sceneState: newSceneState,
      // U-013 í™•ì¥
      quests: newQuests,
      activeRules: newActiveRules,
      mutationTimeline: updatedTimeline,
    });

    // === í–¥í›„ í™•ì¥ ìŠ¬ë¡¯ (RU-003-Q4 Step 4) ===
    // TODO: output.world.memory_pins â†’ Memory Pin íŒ¨ë„ ì—…ë°ì´íŠ¸
  },

  appendSystemNarrative: (text) => {
    set((state) => ({
      narrativeEntries: [
        ...state.narrativeEntries,
        {
          turn: state.turnCount, // í˜„ì¬ í„´ìœ¼ë¡œ ê¸°ë¡ (í„´ ì¦ê°€ ì—†ìŒ)
          text,
          type: 'system',
        },
      ],
    }));
  },

  // U-070[Mvp]: ì•¡ì…˜ ë¡œê·¸ ì¶”ê°€
  appendActionLog: (text) => {
    set((state) => ({
      narrativeEntries: [
        ...state.narrativeEntries,
        {
          turn: state.turnCount, // í˜„ì¬ í„´ìœ¼ë¡œ ê¸°ë¡ (í„´ ì¦ê°€ ì—†ìŒ)
          text,
          type: 'action_log',
        },
      ],
    }));
  },

  setSceneState: (sceneState) => {
    // U-071 ë²„ê·¸ ìˆ˜ì •: processingPhaseë¥¼ ë³´ì¡´í•˜ë©° ë³‘í•©
    set((state) => ({
      sceneState: {
        ...state.sceneState,
        ...sceneState,
      },
    }));
  },

  setConnected: (isConnected) => {
    set({ isConnected });
  },

  setEconomy: (economy) => {
    set({ economy });
  },

  setSceneObjects: (sceneObjects) => {
    set({ sceneObjects });
  },

  initialize: (welcomeMessage) => {
    set({
      ...createInitialState(),
      narrativeEntries: [{ turn: 0, text: welcomeMessage, type: 'narrative' }],
    });
  },

  reset: () => {
    set(createInitialState());
  },

  // ============ U-066: Late-binding ì´ë¯¸ì§€ ê´€ë¦¬ ============

  setImageLoading: (turnId) => {
    set((state) => ({
      sceneState: {
        ...state.sceneState,
        imageLoading: true,
        pendingImageTurnId: turnId,
        sceneRevision: turnId,
        // ì´ì „ ì´ë¯¸ì§€ URL ë³´ì¡´ (Option A: ì´ì „ ì´ë¯¸ì§€ ìœ ì§€)
        previousImageUrl: state.sceneState.imageUrl ?? state.sceneState.previousImageUrl,
      },
    }));
  },

  applyLateBindingImage: (imageUrl, turnId) => {
    const state = get();

    // late-binding ê°€ë“œ: pendingImageTurnIdì™€ ì¼ì¹˜í•  ë•Œë§Œ ì ìš©
    if (state.sceneState.pendingImageTurnId !== turnId) {
      // ì´ë¯¸ ìƒˆ í„´ì´ ì‹œì‘ë˜ì–´ ì´ì „ ìš”ì²­ì€ ë¬´ì‹œ
      return false;
    }

    set({
      sceneState: {
        status: 'scene',
        imageUrl,
        imageLoading: false,
        pendingImageTurnId: undefined,
        sceneRevision: turnId,
        // ì´ì „ ì´ë¯¸ì§€ URLì€ ì„±ê³µ ì‹œ í˜„ì¬ ì´ë¯¸ì§€ë¡œ ëŒ€ì²´
        previousImageUrl: undefined,
      },
    });

    return true;
  },

  cancelImageLoading: () => {
    set((state) => ({
      sceneState: {
        ...state.sceneState,
        imageLoading: false,
        pendingImageTurnId: undefined,
        // ì´ì „ ì´ë¯¸ì§€ ìœ ì§€ (í´ë°±)
        imageUrl: state.sceneState.previousImageUrl ?? state.sceneState.imageUrl,
        previousImageUrl: undefined,
      },
    }));
  },

  // ============ U-071: ì²˜ë¦¬ ë‹¨ê³„ UI ê´€ë¦¬ ============

  setProcessingPhase: (phase) => {
    set((state) => ({
      sceneState: {
        ...state.sceneState,
        processingPhase: phase,
      },
    }));
  },

  // ============ U-089: ì •ë°€ë¶„ì„ ìƒíƒœ ê´€ë¦¬ ============

  setIsAnalyzing: (analyzing) => {
    set({ isAnalyzing: analyzing });
  },

  // ============ U-079: ì•„ì´í…œ íŒë§¤ + í† ìŠ¤íŠ¸ ============

  sellItem: (itemId, itemName) => {
    const state = get();

    // 1. ì¸ë²¤í† ë¦¬ì—ì„œ ì•„ì´í…œ ìˆ˜ëŸ‰ ê°ì†Œ (1ê°œ ì œê±°)
    const invStore = useInventoryStore.getState();
    const item = invStore.items.find((i) => i.id === itemId);
    if (!item) return; // ì•„ì´í…œ ì—†ìœ¼ë©´ ë¬´ì‹œ

    // fade-out ì• ë‹ˆë©”ì´ì…˜ í›„ ì œê±°
    invStore.markConsuming([itemId]);
    setTimeout(() => {
      useInventoryStore.getState().clearConsuming([itemId]);
    }, 500);

    // 2. Signal ì¶”ê°€ (RULE-005: ì”ì•¡ ìŒìˆ˜ ê¸ˆì§€ì´ë¯€ë¡œ ì¶”ê°€ë§Œ)
    const sellPrice = ITEM_SELL_PRICE_SIGNAL;
    const newEconomy: EconomyState = {
      signal: state.economy.signal + sellPrice,
      memory_shard: state.economy.memory_shard,
      credit: state.economy.credit,
    };

    // 3. ë‚´ëŸ¬í‹°ë¸Œì— íŒë§¤ ê¸°ë¡ ì¶”ê°€
    const sellText = i18n.t('inventory.sell_narrative', {
      item: itemName,
      signal: sellPrice,
    });

    set({
      economy: newEconomy,
      narrativeEntries: [
        ...state.narrativeEntries,
        {
          turn: state.turnCount,
          text: sellText,
          type: 'system' as const,
        },
      ],
    });

    // 4. Economy Storeì— Ledger ê¸°ë¡
    const economyStore = useEconomyStore.getState();
    economyStore.addLedgerEntry({
      turnId: state.turnCount,
      reason: `${i18n.t('inventory.sell_ledger_reason')}: ${itemName}`,
      cost: { signal: -sellPrice, memory_shard: 0 }, // ìŒìˆ˜ cost = ìˆ˜ì…
      balanceAfter: newEconomy,
      modelLabel: 'FAST',
    });
    economyStore.updateBalanceLowStatus(newEconomy);

    // 5. í† ìŠ¤íŠ¸ ì•Œë¦¼
    get().showCurrencyToast({
      signalDelta: sellPrice,
      reason: i18n.t('inventory.sell_toast', { item: itemName }),
    });
  },

  showCurrencyToast: (toastData) => {
    const toast: CurrencyToast = {
      ...toastData,
      id: `toast-${Date.now()}`,
      createdAt: Date.now(),
    };
    set({ currencyToast: toast });

    // 3ì´ˆ í›„ ìë™ ë‹«í˜
    setTimeout(() => {
      const current = useWorldStore.getState().currencyToast;
      if (current?.id === toast.id) {
        useWorldStore.getState().dismissCurrencyToast();
      }
    }, 3000);
  },

  dismissCurrencyToast: () => {
    set({ currencyToast: null });
  },
}));

// =============================================================================
// ì…€ë ‰í„° (ì„±ëŠ¥ ìµœì í™”ìš©)
// =============================================================================

/** ê²½ì œ ìƒíƒœ ì…€ë ‰í„° */
export const selectEconomy = (state: WorldStore) => state.economy;

/** Signal ì”ì•¡ ì…€ë ‰í„° */
export const selectSignal = (state: WorldStore) => state.economy.signal;

/** Memory Shard ì”ì•¡ ì…€ë ‰í„° */
export const selectMemoryShard = (state: WorldStore) => state.economy.memory_shard;

/** ì—°ê²° ìƒíƒœ ì…€ë ‰í„° */
export const selectIsConnected = (state: WorldStore) => state.isConnected;

/** Scene ìƒíƒœ ì…€ë ‰í„° */
export const selectSceneState = (state: WorldStore) => state.sceneState;

/** Scene Objects ì…€ë ‰í„° */
export const selectSceneObjects = (state: WorldStore) => state.sceneObjects;

/** ë‚´ëŸ¬í‹°ë¸Œ ì—”íŠ¸ë¦¬ ì…€ë ‰í„° */
export const selectNarrativeEntries = (state: WorldStore) => state.narrativeEntries;

/** í„´ ì¹´ìš´íŠ¸ ì…€ë ‰í„° */
export const selectTurnCount = (state: WorldStore) => state.turnCount;

// ============ U-013: Quest + Rule Board ì…€ë ‰í„° ============

/** í€˜ìŠ¤íŠ¸ ëª©ë¡ ì…€ë ‰í„° */
export const selectQuests = (state: WorldStore) => state.quests;

/** í™œì„± ê·œì¹™ ëª©ë¡ ì…€ë ‰í„° */
export const selectActiveRules = (state: WorldStore) => state.activeRules;

/** ë®¤í…Œì´ì…˜ íƒ€ì„ë¼ì¸ ì…€ë ‰í„° */
export const selectMutationTimeline = (state: WorldStore) => state.mutationTimeline;

/** ì§„í–‰ ì¤‘ì¸ í€˜ìŠ¤íŠ¸ ì…€ë ‰í„° */
export const selectActiveQuests = (state: WorldStore) =>
  state.quests.filter((q) => !q.is_completed);

/** ì™„ë£Œëœ í€˜ìŠ¤íŠ¸ ì…€ë ‰í„° */
export const selectCompletedQuests = (state: WorldStore) =>
  state.quests.filter((q) => q.is_completed);

// ============ U-078: ëª©í‘œ ì‹œìŠ¤í…œ ì…€ë ‰í„° ============

/** ì£¼ ëª©í‘œ(Main Objective) ì…€ë ‰í„° - is_main=trueì¸ ì²« ë²ˆì§¸ í€˜ìŠ¤íŠ¸ */
export const selectMainObjective = (state: WorldStore) =>
  state.quests.find((q) => q.is_main) ?? null;

/** ì„œë¸Œ ëª©í‘œ(Sub-objectives) ì…€ë ‰í„° - is_main=falseì¸ í€˜ìŠ¤íŠ¸ */
export const selectSubObjectives = (state: WorldStore) => state.quests.filter((q) => !q.is_main);

// ============ U-089: ì •ë°€ë¶„ì„ ì…€ë ‰í„° ============

/** ì •ë°€ë¶„ì„ ì‹¤í–‰ ì¤‘ ì—¬ë¶€ ì…€ë ‰í„° */
export const selectIsAnalyzing = (state: WorldStore) => state.isAnalyzing;

/** U-079: ì¬í™” íšë“ í† ìŠ¤íŠ¸ ì…€ë ‰í„° */
export const selectCurrencyToast = (state: WorldStore) => state.currencyToast;

// =============================================================================
// DEV: ë””ë²„ê·¸ìš© ê¸€ë¡œë²Œ ë…¸ì¶œ (í”„ë¡œë•ì…˜ì—ì„œ ì œê±°ë¨)
// =============================================================================

if (import.meta.env.DEV) {
  (window as unknown as Record<string, unknown>).__worldStore = useWorldStore;
}
</file>

<file path="frontend/src/schemas/turn.ts">
/**
 * Unknown World - TurnInput/TurnOutput Zod ìŠ¤í‚¤ë§ˆ.
 *
 * ì´ ëª¨ë“ˆì€ ë°±ì—”ë“œ Pydantic ëª¨ë¸(U-005)ê³¼ 1:1 ëŒ€ì‘í•˜ëŠ” Zod ìŠ¤í‚¤ë§ˆë¥¼ ì •ì˜í•©ë‹ˆë‹¤.
 * í´ë¼ì´ì–¸íŠ¸ ì¸¡ ê²€ì¦ ë° íƒ€ì… ì•ˆì „ì„±ì„ ì œê³µí•©ë‹ˆë‹¤.
 *
 * ì„¤ê³„ ì›ì¹™:
 *   - RULE-003: êµ¬ì¡°í™” ì¶œë ¥(JSON Schema) ìš°ì„  + ì´ì¤‘ ê²€ì¦ (ì„œë²„ Pydantic + í´ë¼ Zod)
 *   - RULE-004: ê²€ì¦ ì‹¤íŒ¨ ì‹œ ì•ˆì „ í´ë°± ì œê³µ (UI ë©ˆì¶¤ ë°©ì§€)
 *   - RULE-005: ì¬í™” ì¸ë°”ë¦¬ì–¸íŠ¸ (cost, balance_after í•„ìˆ˜, ì”ì•¡ ìŒìˆ˜ ê¸ˆì§€)
 *   - RULE-006: ko/en ì–¸ì–´ ì •ì±… (Language enumìœ¼ë¡œ ê³ ì •)
 *   - RULE-009: ì¢Œí‘œ ê·œì•½ (0~1000, bbox [ymin,xmin,ymax,xmax])
 *
 * Q1 ê²°ì • ì‚¬í•­:
 *   - schema_version í¬í•¨ (Option A): SaveGame/ë§ˆì´ê·¸ë ˆì´ì…˜/ê²€ì¦ì— ìœ ë¦¬
 *
 * @module schemas/turn
 */

import { z } from 'zod';

// =============================================================================
// ìŠ¤í‚¤ë§ˆ ë²„ì „ (Q1 ê²°ì •: Option A - í¬í•¨)
// =============================================================================

/**
 * í˜„ì¬ ìŠ¤í‚¤ë§ˆ ë²„ì „.
 * SaveGame/ë§ˆì´ê·¸ë ˆì´ì…˜/ê²€ì¦ì— ì‚¬ìš©ë©ë‹ˆë‹¤.
 */
export const SCHEMA_VERSION = '1.0.0' as const;

// =============================================================================
// ê³µí†µ Enum íƒ€ì…
// =============================================================================

/**
 * ì§€ì› ì–¸ì–´ (RULE-006).
 * ko/en í˜¼í•© ì¶œë ¥ ê¸ˆì§€. TurnInput.languageë¥¼ SSOTë¡œ ì‚¼ì•„
 * ëª¨ë“  UI/ë‚´ëŸ¬í‹°ë¸Œ/ì‹œìŠ¤í…œ ë©”ì‹œì§€ëŠ” ë™ì¼ ì–¸ì–´ë¡œ ê³ ì •í•©ë‹ˆë‹¤.
 */
export const LanguageSchema = z.enum(['ko-KR', 'en-US']);
export type Language = z.infer<typeof LanguageSchema>;

/**
 * í…Œë§ˆ ì„¤ì •.
 */
export const ThemeSchema = z.enum(['dark', 'light']);
export type Theme = z.infer<typeof ThemeSchema>;

/**
 * ì—ì´ì „íŠ¸ ì‹¤í–‰ ë‹¨ê³„ (RULE-008).
 * ì—ì´ì „íŠ¸í˜• ì‹œìŠ¤í…œì„ì„ UIë¡œ ì¦ëª…í•˜ê¸° ìœ„í•œ ë‹¨ê³„ í‘œì‹œ.
 */
export const AgentPhaseSchema = z.enum([
  'parse',
  'validate',
  'plan',
  'resolve',
  'render',
  'verify',
  'commit',
]);
export type AgentPhase = z.infer<typeof AgentPhaseSchema>;

/**
 * ê²€ì¦ ë°°ì§€ (RULE-008).
 * í„´ ê²°ê³¼ì— ëŒ€í•œ ê²€ì¦ ìƒíƒœë¥¼ í‘œì‹œí•©ë‹ˆë‹¤.
 */
export const ValidationBadgeSchema = z.enum([
  'schema_ok',
  'schema_fail',
  'economy_ok',
  'economy_fail',
  'safety_ok',
  'safety_blocked',
  'consistency_ok',
  'consistency_fail',
]);
export type ValidationBadge = z.infer<typeof ValidationBadgeSchema>;

/**
 * ëª¨ë¸/í’ˆì§ˆ ì„ íƒ ë¼ë²¨ (RULE-008).
 * í”„ë¡¬í”„íŠ¸ ë…¸ì¶œ ì—†ì´ "ì™œ ì´ ì„ íƒì´ì—ˆëŠ”ì§€"ë¥¼ ì‚¬ìš©ì ì¹œí™” ë¼ë²¨ë¡œ í‘œì‹œ.
 */
export const ModelLabelSchema = z.enum(['FAST', 'QUALITY', 'CHEAP', 'REF']);
export type ModelLabel = z.infer<typeof ModelLabelSchema>;

/**
 * í–‰ë™ ìœ„í—˜ë„ ìˆ˜ì¤€.
 */
export const RiskLevelSchema = z.enum(['low', 'medium', 'high']);
export type RiskLevel = z.infer<typeof RiskLevelSchema>;

// =============================================================================
// ê³µí†µ í•˜ìœ„ íƒ€ì…
// =============================================================================

/**
 * ì •ê·œí™” ì¢Œí‘œ (RULE-009).
 * 0~1000 ë²”ìœ„ì˜ ì •ìˆ˜ì…ë‹ˆë‹¤.
 */
export const CoordinateSchema = z.number().int().min(0).max(1000).describe('ì •ê·œí™” ì¢Œí‘œ (0~1000)');
export type Coordinate = z.infer<typeof CoordinateSchema>;

/**
 * 2D ë°”ìš´ë”© ë°•ìŠ¤ (RULE-009).
 * ì¢Œí‘œëŠ” 0~1000 ì •ê·œí™” ì¢Œí‘œê³„ì´ë©°, bboxëŠ” [ymin, xmin, ymax, xmax] ìˆœì„œì…ë‹ˆë‹¤.
 * ì´ë¯¸ì§€ ì´í•´ bbox í¬ë§·ê³¼ í˜¸í™˜ë©ë‹ˆë‹¤.
 */
export const Box2DSchema = z
  .object({
    ymin: CoordinateSchema.describe('Y ìµœì†Œê°’ (ìƒë‹¨)'),
    xmin: CoordinateSchema.describe('X ìµœì†Œê°’ (ì¢Œì¸¡)'),
    ymax: CoordinateSchema.describe('Y ìµœëŒ€ê°’ (í•˜ë‹¨)'),
    xmax: CoordinateSchema.describe('X ìµœëŒ€ê°’ (ìš°ì¸¡)'),
  })
  .strict();
export type Box2D = z.infer<typeof Box2DSchema>;

/**
 * ì¬í™” ìˆ˜ëŸ‰.
 * signalê³¼ memory_shardëŠ” 0 ì´ìƒì´ì–´ì•¼ í•©ë‹ˆë‹¤ (RULE-005).
 */
export const CurrencyAmountSchema = z
  .object({
    signal: z.number().int().min(0).describe('ì‹œê·¸ë„ (ê¸°ë³¸ ì¬í™”, 0 ì´ìƒ)'),
    memory_shard: z.number().int().min(0).describe('ê¸°ì–µ íŒŒí¸ (í¬ê·€ ì¬í™”, 0 ì´ìƒ)'),
  })
  .strict();
export type CurrencyAmount = z.infer<typeof CurrencyAmountSchema>;

// =============================================================================
// TurnInput ê´€ë ¨ íƒ€ì…
// =============================================================================

/**
 * í´ë¦­ ì…ë ¥ ì •ë³´.
 * í™”ë©´ ì˜¤ë¸Œì íŠ¸ í´ë¦­ ì‹œ ì „ë‹¬ë˜ëŠ” ì •ë³´ì…ë‹ˆë‹¤.
 */
export const ClickInputSchema = z
  .object({
    object_id: z.string().describe('í´ë¦­í•œ ì˜¤ë¸Œì íŠ¸ ID'),
    box_2d: Box2DSchema.nullable().default(null).describe('í´ë¦­ ìœ„ì¹˜ ë°”ìš´ë”© ë°•ìŠ¤ (ì„ íƒ)'),
  })
  .strict();
export type ClickInput = z.infer<typeof ClickInputSchema>;

/**
 * ë“œë¡­ ì…ë ¥ ì •ë³´ (U-012).
 * ì¸ë²¤í† ë¦¬ ì•„ì´í…œì„ í•«ìŠ¤íŒŸì— ë“œë¡­í•  ë•Œ ì „ë‹¬ë˜ëŠ” ì •ë³´ì…ë‹ˆë‹¤.
 * Q1 ê²°ì •: Option B - target_box_2d í¬í•¨í•˜ì—¬ ì„œë²„ê°€ ì •í™•í•œ ìœ„ì¹˜ í•´ì„ ê°€ëŠ¥.
 */
export const DropInputSchema = z
  .object({
    item_id: z.string().describe('ë“œë¡­í•œ ì¸ë²¤í† ë¦¬ ì•„ì´í…œ ID'),
    target_object_id: z.string().describe('ë“œë¡­ ëŒ€ìƒ í•«ìŠ¤íŒŸ ì˜¤ë¸Œì íŠ¸ ID'),
    target_box_2d: Box2DSchema.describe('ë“œë¡­ ëŒ€ìƒì˜ ë°”ìš´ë”© ë°•ìŠ¤ (0~1000 ì •ê·œí™”)'),
  })
  .strict();
export type DropInput = z.infer<typeof DropInputSchema>;

/**
 * í´ë¼ì´ì–¸íŠ¸ ì •ë³´.
 */
export const ClientInfoSchema = z
  .object({
    viewport_w: z.number().int().positive().describe('ë·°í¬íŠ¸ ë„ˆë¹„ (í”½ì…€, ì–‘ìˆ˜)'),
    viewport_h: z.number().int().positive().describe('ë·°í¬íŠ¸ ë†’ì´ (í”½ì…€, ì–‘ìˆ˜)'),
    theme: ThemeSchema.default('dark').describe('í˜„ì¬ í…Œë§ˆ'),
  })
  .strict();
export type ClientInfo = z.infer<typeof ClientInfoSchema>;

/**
 * ì¬í™” ìŠ¤ëƒ…ìƒ· (í´ë¼ì´ì–¸íŠ¸ â†’ ì„œë²„).
 * í´ë¼ì´ì–¸íŠ¸ê°€ ë³´ìœ í•œ í˜„ì¬ ì¬í™” ìƒíƒœì…ë‹ˆë‹¤.
 */
export const EconomySnapshotSchema = z
  .object({
    signal: z.number().int().min(0).describe('í˜„ì¬ ì‹œê·¸ë„ ì”ì•¡ (0 ì´ìƒ)'),
    memory_shard: z.number().int().min(0).describe('í˜„ì¬ ê¸°ì–µ íŒŒí¸ ì”ì•¡ (0 ì´ìƒ)'),
  })
  .strict();
export type EconomySnapshot = z.infer<typeof EconomySnapshotSchema>;

/**
 * í„´ ì…ë ¥ (í´ë¼ì´ì–¸íŠ¸ â†’ ì„œë²„).
 * ì‚¬ìš©ìê°€ í„´ì„ ì§„í–‰í•  ë•Œ ì„œë²„ë¡œ ì „ì†¡í•˜ëŠ” ì…ë ¥ ë°ì´í„°ì…ë‹ˆë‹¤.
 *
 * U-012: drop í•„ë“œ ì¶”ê°€ - ì¸ë²¤í† ë¦¬ ì•„ì´í…œì„ í•«ìŠ¤íŒŸì— ë“œë¡­í•  ë•Œ ì‚¬ìš©.
 */
export const TurnInputSchema = z
  .object({
    language: LanguageSchema.describe('ìš”ì²­ ì–¸ì–´ (ì‘ë‹µë„ ë™ì¼ ì–¸ì–´ë¡œ ê³ ì •)'),
    text: z.string().default('').describe('ì‚¬ìš©ì ìì—°ì–´ ì…ë ¥'),
    action_id: z.string().nullable().default(null).describe('ì„ íƒí•œ ì•¡ì…˜ ì¹´ë“œ ID (ì„ íƒ)'),
    click: ClickInputSchema.nullable().default(null).describe('ì˜¤ë¸Œì íŠ¸ í´ë¦­ ì •ë³´ (ì„ íƒ)'),
    drop: DropInputSchema.nullable().default(null).describe('ì•„ì´í…œ ë“œë¡­ ì •ë³´ (ì„ íƒ, U-012)'),
    client: ClientInfoSchema.describe('í´ë¼ì´ì–¸íŠ¸ í™˜ê²½ ì •ë³´'),
    economy_snapshot: EconomySnapshotSchema.describe('í˜„ì¬ ì¬í™” ìƒíƒœ'),
    previous_image_url: z
      .string()
      .nullable()
      .default(null)
      .describe('ì´ì „ í„´ ì´ë¯¸ì§€ URL (U-068: ì°¸ì¡° ì´ë¯¸ì§€ë¡œ ì‚¬ìš©í•˜ì—¬ ì—°ì†ì„± ìœ ì§€)'),
  })
  .strict();
export type TurnInput = z.infer<typeof TurnInputSchema>;

// =============================================================================
// TurnOutput ê´€ë ¨ íƒ€ì… - UI
// =============================================================================

/**
 * ë¹„ìš© ì¶”ì •ì¹˜ (U-009: ìµœì†Œ/ìµœëŒ€ ë²”ìœ„).
 * í–‰ë™ì˜ ì˜ˆìƒ ë¹„ìš© ë²”ìœ„ë¥¼ í‘œì‹œí•©ë‹ˆë‹¤.
 */
export const CostEstimateSchema = z
  .object({
    min: CurrencyAmountSchema.describe('ìµœì†Œ ì˜ˆìƒ ë¹„ìš©'),
    max: CurrencyAmountSchema.describe('ìµœëŒ€ ì˜ˆìƒ ë¹„ìš©'),
  })
  .strict();
export type CostEstimate = z.infer<typeof CostEstimateSchema>;

/**
 * ì•¡ì…˜ ì¹´ë“œ (Action Deck) - U-065 ë‹¨ìˆœí™”.
 * ë§¤ í„´ AIê°€ ì¶”ì²œí•˜ëŠ” í–‰ë™ ì¹´ë“œì…ë‹ˆë‹¤.
 *
 * U-065 ë‹¨ìˆœí™”:
 *   - ì œê±°ëœ í•„ë“œ: description, cost_estimate, hint, reward_hint, disabled_reason
 *   - risk, is_alternativeëŠ” ìœ ì§€ (ê²Œì„ ë©”ì¹´ë‹‰ì— í•„ìˆ˜)
 *   - ì œê±°ëœ ì •ë³´ëŠ” narrativeì—ì„œ ìì—°ì–´ë¡œ í‘œí˜„
 */
export const ActionCardSchema = z
  .object({
    id: z.string().describe('ì¹´ë“œ ê³ ìœ  ID'),
    label: z.string().describe('ì¹´ë“œ ë¼ë²¨ (í‘œì‹œìš©)'),
    cost: CurrencyAmountSchema.describe('ì˜ˆìƒ ë¹„ìš© (ê¸°ë³¸)'),
    risk: RiskLevelSchema.default('low').describe('ìœ„í—˜ë„'),
    enabled: z.boolean().default(true).describe('ì‹¤í–‰ ê°€ëŠ¥ ì—¬ë¶€ (ì„œë²„ íŒë‹¨)'),
    is_alternative: z.boolean().default(false).describe('ì €ë¹„ìš© ëŒ€ì•ˆ ì¹´ë“œ ì—¬ë¶€'),
  })
  .strict();
export type ActionCard = z.infer<typeof ActionCardSchema>;

/**
 * ì¥ë©´ ì˜¤ë¸Œì íŠ¸ (í´ë¦­ ê°€ëŠ¥í•œ í•«ìŠ¤íŒŸ).
 * ì¢Œí‘œëŠ” 0~1000 ì •ê·œí™” ì¢Œí‘œê³„ë¥¼ ì‚¬ìš©í•©ë‹ˆë‹¤ (RULE-009).
 */
export const SceneObjectSchema = z
  .object({
    id: z.string().describe('ì˜¤ë¸Œì íŠ¸ ê³ ìœ  ID'),
    label: z.string().describe('ì˜¤ë¸Œì íŠ¸ ë¼ë²¨ (í‘œì‹œìš©)'),
    box_2d: Box2DSchema.describe('ë°”ìš´ë”© ë°•ìŠ¤'),
    interaction_hint: z.string().nullable().default(null).describe('ìƒí˜¸ì‘ìš© íŒíŠ¸ (ì„ íƒ)'),
  })
  .strict();
export type SceneObject = z.infer<typeof SceneObjectSchema>;

/**
 * ì•¡ì…˜ ë± (Q1 ê²°ì •: ui.action_deck.cards[] êµ¬ì¡°) - U-065 ë‹¨ìˆœí™”.
 * ë§¤ í„´ AIê°€ ì œì‹œí•˜ëŠ” ì¶”ì²œ í–‰ë™ ì¹´ë“œ ë±ì…ë‹ˆë‹¤.
 *
 * U-065 ë‹¨ìˆœí™”:
 *   - max_length: 10 â†’ 5 (Gemini ìŠ¤í‚¤ë§ˆ ì œí•œ ëŒ€ì‘, Q2 ê²°ì •)
 */
export const ActionDeckSchema = z
  .object({
    cards: z.array(ActionCardSchema).max(5).default([]).describe('ì•¡ì…˜ ì¹´ë“œ ëª©ë¡ (3~5ì¥ ê¶Œì¥)'),
  })
  .strict();
export type ActionDeck = z.infer<typeof ActionDeckSchema>;

/**
 * Scene í‘œì‹œ ì •ë³´ (RU-003-T1: Scene ì´ë¯¸ì§€ SSOT).
 *
 * TurnOutputì—ì„œ Scene Canvasì— í‘œì‹œí•  ì´ë¯¸ì§€ ì •ë³´ë¥¼ ì œê³µí•©ë‹ˆë‹¤.
 * image_urlì´ ì¡´ì¬í•˜ë©´ SceneCanvasëŠ” 'scene' ìƒíƒœë¡œ ì „í™˜ë©ë‹ˆë‹¤.
 * image_urlì´ ì—†ìœ¼ë©´ 'default' ìƒíƒœë¥¼ ìœ ì§€í•©ë‹ˆë‹¤.
 */
export const SceneOutputSchema = z
  .object({
    image_url: z
      .string()
      .nullable()
      .default(null)
      .describe('Scene ì´ë¯¸ì§€ URL (ì¡´ì¬ ì‹œ scene ìƒíƒœë¡œ ì „í™˜)'),
    alt_text: z.string().nullable().default(null).describe('ì´ë¯¸ì§€ ëŒ€ì²´ í…ìŠ¤íŠ¸ (ì ‘ê·¼ì„±ìš©, ì„ íƒ)'),
  })
  .strict();
export type SceneOutput = z.infer<typeof SceneOutputSchema>;

/**
 * Scene ê¸°ë³¸ê°’ (null ëŒ€ì‘).
 */
const DEFAULT_SCENE_OUTPUT: SceneOutput = { image_url: null, alt_text: null };

/**
 * UI ì¶œë ¥ ë°ì´í„° - U-065 ë‹¨ìˆœí™”.
 * AIê°€ ìƒì„±í•œ UI ìš”ì†Œë“¤ì…ë‹ˆë‹¤.
 * ì±„íŒ… ë²„ë¸”ì´ ì•„ë‹Œ ê²Œì„ UIë¡œ í‘œí˜„ë©ë‹ˆë‹¤ (RULE-002).
 *
 * RU-003-T1: scene í•„ë“œ ì¶”ê°€ - Scene Canvasì˜ ì´ë¯¸ì§€ í‘œì‹œ ì •ë³´ SSOT.
 * U-065 ë‹¨ìˆœí™”: objects ë°°ì—´ í¬ê¸° ì œí•œ (ìµœëŒ€ 5ê°œ, Q2 ê²°ì •)
 *
 * ìˆ˜ì •: scene í•„ë“œëŠ” ë°±ì—”ë“œì—ì„œ nullë¡œ ì˜¬ ìˆ˜ ìˆìœ¼ë¯€ë¡œ nullish()ë¥¼ ì‚¬ìš©í•˜ì—¬
 * null/undefined ì‹œ ê¸°ë³¸ê°’ìœ¼ë¡œ ë³€í™˜í•©ë‹ˆë‹¤.
 */
export const UIOutputSchema = z
  .object({
    action_deck: ActionDeckSchema.default({ cards: [] }).describe('ì•¡ì…˜ ì¹´ë“œ ë±'),
    objects: z
      .array(SceneObjectSchema)
      .max(5)
      .default([])
      .describe('í´ë¦­ ê°€ëŠ¥í•œ ì¥ë©´ ì˜¤ë¸Œì íŠ¸ ëª©ë¡ (ìµœëŒ€ 5ê°œ)'),
    scene: SceneOutputSchema.nullish()
      .transform((val) => val ?? DEFAULT_SCENE_OUTPUT)
      .describe('Scene í‘œì‹œ ì •ë³´ (RU-003-T1, null í—ˆìš©)'),
  })
  .strict();
export type UIOutput = z.infer<typeof UIOutputSchema>;

// =============================================================================
// TurnOutput ê´€ë ¨ íƒ€ì… - World
// =============================================================================

/**
 * ì¤‘ìš” ì„¤ì • ê³ ì • í›„ë³´.
 * ì‚¬ìš©ìê°€ Memory Shardë¥¼ ì†Œë¹„í•´ ê³ ì •í•  ìˆ˜ ìˆëŠ” ì¤‘ìš” ì„¤ì •ì…ë‹ˆë‹¤.
 */
export const MemoryPinSchema = z
  .object({
    id: z.string().describe('í•€ ê³ ìœ  ID'),
    content: z.string().describe('ê³ ì •í•  ë‚´ìš©'),
    cost: CurrencyAmountSchema.describe('ê³ ì •ì— í•„ìš”í•œ ë¹„ìš©'),
  })
  .strict();
export type MemoryPin = z.infer<typeof MemoryPinSchema>;

/**
 * ì„¸ê³„ ê·œì¹™ (Rule Board).
 * í˜„ì¬ ì„¸ê³„ì— ì ìš© ì¤‘ì¸ ë¬¼ë¦¬ ë²•ì¹™ì´ë‚˜ ë©”íƒ€ ê·œì¹™ì…ë‹ˆë‹¤.
 */
export const WorldRuleSchema = z
  .object({
    id: z.string().describe('ê·œì¹™ ê³ ìœ  ID'),
    label: z.string().describe('ê·œì¹™ ì´ë¦„'),
    description: z.string().nullable().default(null).describe('ê·œì¹™ ìƒì„¸ ì„¤ëª… (ì„ íƒ)'),
  })
  .strict();
export type WorldRule = z.infer<typeof WorldRuleSchema>;

/**
 * í€˜ìŠ¤íŠ¸/ëª©í‘œ (Quest Panel) - U-078 ëª©í‘œ ì‹œìŠ¤í…œ ê°•í™”.
 * í”Œë ˆì´ì–´ê°€ ë‹¬ì„±í•´ì•¼ í•˜ëŠ” í˜„ì¬ ëª©í‘œì…ë‹ˆë‹¤.
 * is_main=trueì¸ í€˜ìŠ¤íŠ¸ê°€ ì£¼ ëª©í‘œ(Main Objective)ë¡œ Quest íŒ¨ë„ ìƒë‹¨ì— ê°•ì¡° í‘œì‹œë©ë‹ˆë‹¤.
 */
export const QuestSchema = z
  .object({
    id: z.string().describe('í€˜ìŠ¤íŠ¸ ê³ ìœ  ID'),
    label: z.string().describe('í€˜ìŠ¤íŠ¸ ì´ë¦„'),
    is_completed: z.boolean().default(false).describe('ë‹¬ì„± ì—¬ë¶€'),
    description: z.string().nullable().default(null).describe('ëª©í‘œ ìƒì„¸ ì„¤ëª… (ì„ íƒ)'),
    is_main: z.boolean().default(false).describe('ì£¼ ëª©í‘œ ì—¬ë¶€'),
    progress: z.number().int().min(0).max(100).default(0).describe('ì§„í–‰ë¥  (0~100)'),
    reward_signal: z.number().int().min(0).default(0).describe('ë‹¬ì„± ì‹œ Signal ë³´ìƒëŸ‰'),
  })
  .strict();
export type Quest = z.infer<typeof QuestSchema>;

/**
 * ì¸ë²¤í† ë¦¬ ì•„ì´í…œ ë°ì´í„° (U-075[Mvp]).
 * TurnOutputì—ì„œ ì¶”ê°€ë˜ëŠ” ì•„ì´í…œì˜ ìƒì„¸ ì •ë³´ì…ë‹ˆë‹¤.
 */
export const InventoryItemDataSchema = z
  .object({
    id: z.string().describe('ì•„ì´í…œ ê³ ìœ  ID'),
    label: z.string().describe('ì•„ì´í…œ í‘œì‹œ ì´ë¦„ (í˜„ì¬ ì–¸ì–´ì— ë§ê²Œ)'),
    description: z.string().default('').describe('ì•„ì´í…œ ì„¤ëª… (ì•„ì´ì½˜ ìƒì„±ìš©)'),
    icon_url: z.string().nullable().default(null).describe('ì•„ì´ì½˜ URL (ì„ íƒ, ìºì‹œëœ ê²½ìš°)'),
    quantity: z.number().int().min(1).default(1).describe('ì•„ì´í…œ ìˆ˜ëŸ‰'),
  })
  .strict();
export type InventoryItemData = z.infer<typeof InventoryItemDataSchema>;

/**
 * ì„¸ê³„ ìƒíƒœ ë³€í™” (Q2 ê²°ì •: Option A - delta ì¤‘ì‹¬) - U-065 ë‹¨ìˆœí™”.
 * ì´ë²ˆ í„´ì—ì„œ ë³€ê²½ëœ ì„¸ê³„ ìƒíƒœë¥¼ ë‚˜íƒ€ëƒ…ë‹ˆë‹¤.
 *
 * U-065 ë‹¨ìˆœí™” (Q3 ê²°ì •: Option A):
 *   - rules_changed, quests_updated â†’ ë°°ì—´ í¬ê¸° ì œí•œ (ìµœëŒ€ 3ê°œ)
 *   - memory_pins â†’ ë°°ì—´ í¬ê¸° ì œí•œ (ìµœëŒ€ 2ê°œ)
 *   - ìƒì„¸ ì •ë³´ëŠ” narrativeì—ì„œ ìì—°ì–´ë¡œ í‘œí˜„
 */
export const WorldDeltaSchema = z
  .object({
    rules_changed: z
      .array(WorldRuleSchema)
      .max(3)
      .default([])
      .describe('ë³€ê²½ëœ ê·œì¹™ ëª©ë¡ (ìµœëŒ€ 3ê°œ)'),
    inventory_added: z
      .array(InventoryItemDataSchema)
      .max(5)
      .default([])
      .describe('ì¶”ê°€ëœ ì¸ë²¤í† ë¦¬ ì•„ì´í…œ (ìµœëŒ€ 5ê°œ)'),
    inventory_removed: z
      .array(z.string())
      .max(5)
      .default([])
      .describe('ì œê±°ëœ ì¸ë²¤í† ë¦¬ ì•„ì´í…œ (ìµœëŒ€ 5ê°œ)'),
    quests_updated: z
      .array(QuestSchema)
      .max(3)
      .default([])
      .describe('ì—…ë°ì´íŠ¸ëœ í€˜ìŠ¤íŠ¸/ëª©í‘œ ëª©ë¡ (ìµœëŒ€ 3ê°œ)'),
    relationships_changed: z
      .array(z.string())
      .max(3)
      .default([])
      .describe('ë³€ê²½ëœ ê´€ê³„ (ìµœëŒ€ 3ê°œ)'),
    memory_pins: z
      .array(MemoryPinSchema)
      .max(2)
      .default([])
      .describe('ì¤‘ìš” ì„¤ì • ê³ ì • í›„ë³´ (ìµœëŒ€ 2ê°œ)'),
  })
  .strict();
export type WorldDelta = z.infer<typeof WorldDeltaSchema>;

// =============================================================================
// TurnOutput ê´€ë ¨ íƒ€ì… - Render
// =============================================================================

/**
 * ì´ë¯¸ì§€ ìƒì„± ì‘ì—… - U-065 ë‹¨ìˆœí™”.
 * ì¡°ê±´ë¶€ ì´ë¯¸ì§€ ìƒì„±/í¸ì§‘ ìš”ì²­ì…ë‹ˆë‹¤.
 *
 * U-065 ë‹¨ìˆœí™”: reference_image_ids ë°°ì—´ í¬ê¸° ì œí•œ (ìµœëŒ€ 2ê°œ)
 * U-091: rembg ëŸ°íƒ€ì„ ì œê±° - remove_background, image_type_hint í•„ë“œ ì‚­ì œ
 */
export const ImageJobSchema = z
  .object({
    should_generate: z.boolean().describe('ì´ë¯¸ì§€ë¥¼ ìƒì„±í•´ì•¼ í•˜ëŠ”ì§€'),
    prompt: z.string().default('').describe('ì´ë¯¸ì§€ ìƒì„± í”„ë¡¬í”„íŠ¸'),
    model_label: ModelLabelSchema.default('FAST').describe('ëª¨ë¸ ì„ íƒ ë¼ë²¨'),
    aspect_ratio: z.string().default('16:9').describe('ê°€ë¡œì„¸ë¡œ ë¹„ìœ¨'),
    image_size: z.string().default('1024x1024').describe('ì´ë¯¸ì§€ í¬ê¸°'),
    reference_image_ids: z
      .array(z.string())
      .max(2)
      .default([])
      .describe('ì°¸ì¡° ì´ë¯¸ì§€ ID ëª©ë¡ (ìµœëŒ€ 2ê°œ)'),
    reference_image_url: z
      .string()
      .nullable()
      .default(null)
      .describe('ì°¸ì¡° ì´ë¯¸ì§€ URL (ì„ íƒ, AI ëª¨ë¸ ì‘ë‹µ í˜¸í™˜ìš©)'),
  })
  .strict();
export type ImageJob = z.infer<typeof ImageJobSchema>;

/**
 * ë Œë”ë§ ì¶œë ¥ ë°ì´í„°.
 * ì´ë¯¸ì§€ ìƒì„±/í¸ì§‘ ê´€ë ¨ ì •ë³´ì…ë‹ˆë‹¤.
 *
 * U-053: image_url, image_id, generation_time_ms í•„ë“œ ì¶”ê°€ (í›„ì²˜ë¦¬ì—ì„œ ì±„ì›€)
 * U-091: rembg ëŸ°íƒ€ì„ ì œê±° - background_removed í•„ë“œ ì‚­ì œ
 */
export const RenderOutputSchema = z
  .object({
    image_job: ImageJobSchema.nullable().default(null).describe('ì´ë¯¸ì§€ ìƒì„± ì‘ì—… (ì„ íƒ)'),
    image_url: z
      .string()
      .nullable()
      .default(null)
      .describe('ìƒì„±ëœ ì´ë¯¸ì§€ URL (í›„ì²˜ë¦¬ì—ì„œ ì±„ì›€, U-053)'),
    image_id: z
      .string()
      .nullable()
      .default(null)
      .describe('ìƒì„±ëœ ì´ë¯¸ì§€ ID (í›„ì²˜ë¦¬ì—ì„œ ì±„ì›€, U-053)'),
    generation_time_ms: z
      .number()
      .int()
      .nullable()
      .default(null)
      .describe('ì´ë¯¸ì§€ ìƒì„± ì†Œìš” ì‹œê°„ (ms, U-053)'),
  })
  .strict();
export type RenderOutput = z.infer<typeof RenderOutputSchema>;

// =============================================================================
// TurnOutput ê´€ë ¨ íƒ€ì… - Economy
// =============================================================================

/**
 * ê±°ë˜ ì¥ë¶€(Ledger) ì—”íŠ¸ë¦¬ (RULE-005).
 * ê° í„´ì—ì„œ ë°œìƒí•œ ë¹„ìš©ê³¼ ì”ì•¡ ë³€í™”ë¥¼ ê¸°ë¡í•©ë‹ˆë‹¤.
 */
export const LedgerEntrySchema = z
  .object({
    turnId: z.number().int().min(0).describe('í„´ ID'),
    actionId: z.string().optional().describe('ì•¡ì…˜ ID (ì„ íƒ)'),
    reason: z.string().describe('ë¹„ìš© ë°œìƒ ì‚¬ìœ '),
    cost: CurrencyAmountSchema.describe('ì†Œë¹„ëœ ë¹„ìš©'),
    balanceAfter: CurrencyAmountSchema.describe('ì†Œë¹„ í›„ ì”ì•¡'),
    modelLabel: ModelLabelSchema.optional().describe('ëª¨ë¸ ë¼ë²¨ (ì„ íƒ)'),
    timestamp: z.number().describe('ê¸°ë¡ ì‹œê° (timestamp)'),
  })
  .strict();
export type LedgerEntry = z.infer<typeof LedgerEntrySchema>;

/**
 * ê²½ì œ ì¶œë ¥ ë°ì´í„° (RULE-005).
 * ì´ë²ˆ í„´ì˜ ë¹„ìš©ê³¼ ì”ì•¡ ì •ë³´ì…ë‹ˆë‹¤.
 * ì”ì•¡ ìŒìˆ˜ëŠ” ì ˆëŒ€ ë¶ˆê°€ (ì„œë²„ Hard gate).
 */
export const EconomyOutputSchema = z
  .object({
    cost: CurrencyAmountSchema.describe('ì´ë²ˆ í„´ì— ì†Œë¹„ëœ ë¹„ìš©'),
    balance_after: CurrencyAmountSchema.describe('ì†Œë¹„ í›„ ì”ì•¡'),
    credit: z.number().int().default(0).describe('ì‚¬ìš© ì¤‘ì¸ í¬ë ˆë”§ (ë¹š, Signal ë‹¨ìœ„)'),
    low_balance_warning: z.boolean().default(false).describe('ì”ì•¡ ë¶€ì¡± ê²½ê³  ì—¬ë¶€'),
  })
  .strict();
export type EconomyOutput = z.infer<typeof EconomyOutputSchema>;

// =============================================================================
// TurnOutput ê´€ë ¨ íƒ€ì… - Safety
// =============================================================================

/**
 * ì•ˆì „ ì¶œë ¥ ë°ì´í„°.
 * ì•ˆì „ ì •ì±… ê´€ë ¨ ì •ë³´ì…ë‹ˆë‹¤.
 * ì°¨ë‹¨ ì‹œ ëª…ì‹œì  ë©”ì‹œì§€ì™€ í•¨ê»˜ ì•ˆì „í•œ ëŒ€ì²´ ê²°ê³¼ë¥¼ ì œê³µí•©ë‹ˆë‹¤.
 */
export const SafetyOutputSchema = z
  .object({
    blocked: z.boolean().default(false).describe('ì•ˆì „ ì •ì±…ì— ì˜í•´ ì°¨ë‹¨ë˜ì—ˆëŠ”ì§€'),
    message: z
      .string()
      .nullable()
      .default(null)
      .describe('ì°¨ë‹¨ ì‹œ ì‚¬ìš©ìì—ê²Œ í‘œì‹œí•  ë©”ì‹œì§€ (ì„ íƒ)'),
  })
  .strict();
export type SafetyOutput = z.infer<typeof SafetyOutputSchema>;

// =============================================================================
// TurnOutput ê´€ë ¨ íƒ€ì… - Agent Console
// =============================================================================

/**
 * ì—ì´ì „íŠ¸ ì½˜ì†” ë°ì´í„° (RULE-008) - U-065 ë‹¨ìˆœí™”.
 * ì—ì´ì „íŠ¸í˜• ì‹œìŠ¤í…œì„ì„ UIë¡œ ì¦ëª…í•˜ê¸° ìœ„í•œ ì •ë³´ì…ë‹ˆë‹¤.
 *
 * U-065 ë‹¨ìˆœí™”: badges ë°°ì—´ í¬ê¸° ì œí•œ (ìµœëŒ€ 4ê°œ)
 * U-069: model_label í•„ë“œ ì¶”ê°€ - í˜„ì¬ ì‚¬ìš© ì¤‘ì¸ í…ìŠ¤íŠ¸ ëª¨ë¸ í‘œì‹œ
 */
export const AgentConsoleSchema = z
  .object({
    current_phase: AgentPhaseSchema.default('commit').describe('í˜„ì¬ ì‹¤í–‰ ë‹¨ê³„'),
    badges: z.array(ValidationBadgeSchema).max(4).default([]).describe('ê²€ì¦ ë°°ì§€ ëª©ë¡ (ìµœëŒ€ 4ê°œ)'),
    repair_count: z.number().int().min(0).default(0).describe('ìë™ ë³µêµ¬ ì‹œë„ íšŸìˆ˜'),
    model_label: ModelLabelSchema.default('FAST').describe(
      'í˜„ì¬ ì‚¬ìš© ì¤‘ì¸ í…ìŠ¤íŠ¸ ëª¨ë¸ ë¼ë²¨ (U-069)',
    ),
  })
  .strict();
export type AgentConsole = z.infer<typeof AgentConsoleSchema>;

// =============================================================================
// TurnOutput (ë©”ì¸ ì‘ë‹µ ìŠ¤í‚¤ë§ˆ)
// =============================================================================

/**
 * í„´ ì¶œë ¥ (ì„œë²„ â†’ í´ë¼ì´ì–¸íŠ¸).
 * ì„œë²„ê°€ í„´ ì²˜ë¦¬ í›„ í´ë¼ì´ì–¸íŠ¸ë¡œ ë°˜í™˜í•˜ëŠ” êµ¬ì¡°í™”ëœ ì‘ë‹µì…ë‹ˆë‹¤.
 *
 * Hard Gate í•„ë“œ (RULE-003/004/005):
 *   - economy: costì™€ balance_after í•„ìˆ˜, ì”ì•¡ ìŒìˆ˜ ê¸ˆì§€
 *   - safety: blocked ì‹œ ì•ˆì „í•œ ëŒ€ì²´ ê²°ê³¼ ì œê³µ
 *   - language: ìš”ì²­ ì–¸ì–´ì™€ ë™ì¼í•˜ê²Œ ê³ ì • (í˜¼í•© ì¶œë ¥ ê¸ˆì§€)
 */
export const TurnOutputSchema = z
  .object({
    // í•„ìˆ˜ í•„ë“œ (Hard Gate)
    language: LanguageSchema.describe('ì‘ë‹µ ì–¸ì–´ (ìš”ì²­ê³¼ ë™ì¼)'),
    narrative: z.string().describe('ë‚´ëŸ¬í‹°ë¸Œ í…ìŠ¤íŠ¸ (í‘œì‹œìš©)'),
    economy: EconomyOutputSchema.describe('ê²½ì œ ì •ë³´ (ë¹„ìš©, ì”ì•¡)'),
    safety: SafetyOutputSchema.describe('ì•ˆì „ ì •ì±… ì •ë³´'),

    // UI ê´€ë ¨ í•„ë“œ (RU-003-T1: scene í•„ë“œ ì¶”ê°€)
    ui: UIOutputSchema.default({
      action_deck: { cards: [] },
      objects: [],
      scene: { image_url: null, alt_text: null },
    }).describe('UI ìš”ì†Œ'),

    // ì„¸ê³„ ìƒíƒœ í•„ë“œ
    world: WorldDeltaSchema.default({
      rules_changed: [],
      inventory_added: [],
      inventory_removed: [],
      quests_updated: [],
      relationships_changed: [],
      memory_pins: [],
    }).describe('ì„¸ê³„ ìƒíƒœ ë³€í™” (delta)'),

    // ë Œë”ë§ í•„ë“œ
    render: RenderOutputSchema.default({
      image_job: null,
      image_url: null,
      image_id: null,
      generation_time_ms: null,
    }).describe('ë Œë”ë§ ì •ë³´'),

    // ì—ì´ì „íŠ¸ ì½˜ì†” í•„ë“œ
    agent_console: AgentConsoleSchema.default({
      current_phase: 'commit',
      badges: [],
      repair_count: 0,
      model_label: 'FAST',
    }).describe('ì—ì´ì „íŠ¸ ì‹¤í–‰ ì •ë³´'),

    // U-072: ì„¸ì…˜ ìœ ë„ë¥¼ ìœ„í•œ íŒíŠ¸ í•„ë“œ (ì„ íƒ)
    hints: z
      .object({
        scanner: z.boolean().optional().describe('Scanner ì‚¬ìš© ìœ ë„ íŒíŠ¸ ì—¬ë¶€'),
      })
      .optional()
      .describe('í”Œë ˆì´ ìœ ë„ë¥¼ ìœ„í•œ íŒíŠ¸ í”Œë˜ê·¸'),
  })
  .strict();
export type TurnOutput = z.infer<typeof TurnOutputSchema>;

// =============================================================================
// ì•ˆì „ í´ë°± (RULE-004)
// =============================================================================

/**
 * ê²€ì¦ ì‹¤íŒ¨ ì‹œ ì œê³µë˜ëŠ” ì•ˆì „ í´ë°± TurnOutput.
 * UIê°€ ë©ˆì¶”ì§€ ì•Šë„ë¡ ìµœì†Œí•œì˜ ì •ë³´ë¥¼ ì œê³µí•©ë‹ˆë‹¤.
 *
 * U-063: í´ë°±ì—ì„œë„ ì¬í™” ì”ì•¡ì„ ìœ ì§€í•˜ë„ë¡ economySnapshot íŒŒë¼ë¯¸í„° ì¶”ê°€.
 * RULE-005: ì¬í™” ì¸ë°”ë¦¬ì–¸íŠ¸ - í´ë°± ì‹œì—ë„ ì”ì•¡ì´ 0ìœ¼ë¡œ ì´ˆê¸°í™”ë˜ì§€ ì•Šì•„ì•¼ í•¨.
 *
 * @param language - ìš”ì²­ ì–¸ì–´
 * @param repairCount - ë³µêµ¬ ì‹œë„ íšŸìˆ˜
 * @param errorMessage - ì˜¤ë¥˜ ë©”ì‹œì§€ (ì„ íƒ)
 * @param economySnapshot - í˜„ì¬ ì¬í™” ìŠ¤ëƒ…ìƒ· (ì„ íƒ, ì œê³µ ì‹œ ì”ì•¡ ìœ ì§€)
 */
export function createFallbackTurnOutput(
  language: Language,
  repairCount: number = 0,
  errorMessage?: string,
  economySnapshot?: { signal: number; memory_shard: number },
): TurnOutput {
  const fallbackNarrative =
    language === 'ko-KR'
      ? '[ì‹œìŠ¤í…œ] ì‘ë‹µì„ ì²˜ë¦¬í•˜ëŠ” ì¤‘ ë¬¸ì œê°€ ë°œìƒí–ˆìŠµë‹ˆë‹¤. ë‹¤ì‹œ ì‹œë„í•´ ì£¼ì„¸ìš”.'
      : '[System] An error occurred while processing the response. Please try again.';

  const safetyMessage =
    language === 'ko-KR'
      ? 'ìŠ¤í‚¤ë§ˆ ê²€ì¦ ì‹¤íŒ¨ë¡œ ì¸í•œ í´ë°± ì‘ë‹µì…ë‹ˆë‹¤.'
      : 'This is a fallback response due to schema validation failure.';

  // U-063: í´ë°±ì—ì„œë„ ì¬í™” ì”ì•¡ ìœ ì§€ (RULE-005)
  // economySnapshotì´ ì œê³µë˜ë©´ í•´ë‹¹ ê°’ì„ ì‚¬ìš©, ì—†ìœ¼ë©´ ê¸°ë³¸ê°’ ì‚¬ìš©
  const balanceAfter = economySnapshot
    ? { signal: economySnapshot.signal, memory_shard: economySnapshot.memory_shard }
    : { signal: 100, memory_shard: 5 }; // ê¸°ë³¸ê°’ (í”„ë¡œí•„ ë¯¸ë¡œë“œ ìƒíƒœì˜ placeholder)

  return {
    language,
    narrative: errorMessage ?? fallbackNarrative,
    economy: {
      cost: { signal: 0, memory_shard: 0 },
      balance_after: balanceAfter,
      credit: 0,
      low_balance_warning: false,
    },
    safety: {
      blocked: false,
      message: safetyMessage,
    },
    ui: {
      action_deck: { cards: [] },
      objects: [],
      scene: { image_url: null, alt_text: null },
    },
    world: {
      rules_changed: [],
      inventory_added: [],
      inventory_removed: [],
      quests_updated: [],
      relationships_changed: [],
      memory_pins: [],
    },
    render: {
      image_job: null,
      image_url: null,
      image_id: null,
      generation_time_ms: null,
    },
    agent_console: {
      current_phase: 'commit',
      badges: ['schema_fail'],
      repair_count: repairCount,
      model_label: 'FAST',
    },
  };
}

// =============================================================================
// ê²€ì¦ í—¬í¼ í•¨ìˆ˜
// =============================================================================

/**
 * TurnOutput ê²€ì¦ ê²°ê³¼ íƒ€ì….
 */
export type TurnOutputParseResult =
  | { success: true; data: TurnOutput }
  | { success: false; error: z.ZodError; fallback: TurnOutput };

/**
 * TurnOutputì„ ì•ˆì „í•˜ê²Œ íŒŒì‹±í•©ë‹ˆë‹¤.
 * ì‹¤íŒ¨ ì‹œ í´ë°± TurnOutputì„ ë°˜í™˜í•©ë‹ˆë‹¤ (RULE-004).
 *
 * U-063: economySnapshot íŒŒë¼ë¯¸í„° ì¶”ê°€ - í´ë°± ì‹œì—ë„ ì¬í™” ì”ì•¡ ìœ ì§€.
 *
 * @param data - íŒŒì‹±í•  ë°ì´í„°
 * @param language - í´ë°± ì‹œ ì‚¬ìš©í•  ì–¸ì–´ (ê¸°ë³¸: ko-KR)
 * @param repairCount - í˜„ì¬ ë³µêµ¬ ì‹œë„ íšŸìˆ˜
 * @param economySnapshot - í˜„ì¬ ì¬í™” ìŠ¤ëƒ…ìƒ· (ì„ íƒ, í´ë°± ì‹œ ì”ì•¡ ìœ ì§€)
 */
export function safeParseTurnOutput(
  data: unknown,
  language: Language = 'ko-KR',
  repairCount: number = 0,
  economySnapshot?: { signal: number; memory_shard: number },
): TurnOutputParseResult {
  const result = TurnOutputSchema.safeParse(data);

  if (result.success) {
    return { success: true, data: result.data };
  }

  return {
    success: false,
    error: result.error,
    fallback: createFallbackTurnOutput(language, repairCount, undefined, economySnapshot),
  };
}

/**
 * TurnInputì„ ê²€ì¦í•©ë‹ˆë‹¤.
 * ì…ë ¥ ë°ì´í„°ì˜ ìœ íš¨ì„±ì„ ì—„ê²©í•˜ê²Œ ê²€ì‚¬í•©ë‹ˆë‹¤.
 *
 * @param data - ê²€ì¦í•  ë°ì´í„°
 * @throws {z.ZodError} ê²€ì¦ ì‹¤íŒ¨ ì‹œ
 */
export function parseTurnInput(data: unknown): TurnInput {
  return TurnInputSchema.parse(data);
}

/**
 * TurnInput ì•ˆì „ íŒŒì‹± ê²°ê³¼ íƒ€ì….
 */
export type TurnInputSafeParseResult = ReturnType<typeof TurnInputSchema.safeParse>;

/**
 * TurnInputì„ ì•ˆì „í•˜ê²Œ íŒŒì‹±í•©ë‹ˆë‹¤.
 *
 * @param data - íŒŒì‹±í•  ë°ì´í„°
 */
export function safeParseTurnInput(data: unknown): TurnInputSafeParseResult {
  return TurnInputSchema.safeParse(data);
}
</file>

<file path="backend/src/unknown_world/services/image_generation.py">
"""Unknown World - ì´ë¯¸ì§€ ìƒì„± ì„œë¹„ìŠ¤.

ì´ ëª¨ë“ˆì€ Gemini ì´ë¯¸ì§€ ìƒì„± ëª¨ë¸ì„ í˜¸ì¶œí•˜ê³  ê²°ê³¼ë¥¼ ë¡œì»¬ì— ì €ì¥í•˜ëŠ” ì„œë¹„ìŠ¤ì…ë‹ˆë‹¤.
í…ìŠ¤íŠ¸ í„´ì˜ TTFBë¥¼ ë¸”ë¡œí‚¹í•˜ì§€ ì•Šë„ë¡ ë¶„ë¦¬ëœ ê²½ë¡œë¡œ ë™ì‘í•©ë‹ˆë‹¤.

ì„¤ê³„ ì›ì¹™:
    - RULE-004: ì‹¤íŒ¨ ì‹œ ì•ˆì „í•œ í´ë°± ì œê³µ (should_generate=false)
    - RULE-008: í…ìŠ¤íŠ¸ ìš°ì„  + Lazy ì´ë¯¸ì§€ ì›ì¹™
    - RULE-010: ì´ë¯¸ì§€ ëª¨ë¸ ID ê³ ì • (gemini-3-pro-image-preview)
    - RULE-007: í”„ë¡¬í”„íŠ¸ ì›ë¬¸ ë…¸ì¶œ ê¸ˆì§€

í˜ì–´ë§ ì§ˆë¬¸ ê²°ì • (U-064[Mvp]):
    - Q1: Option A (íƒ€ì„ì•„ì›ƒ 60ì´ˆ - ì´ë¯¸ì§€ ìƒì„±ì€ 15-20ì´ˆ ì†Œìš” ê°€ëŠ¥)
    - Q2: Option A (MVPì—ì„œëŠ” ì¬ì‹œë„ ì—†ì´ ì¦‰ì‹œ í´ë°±)
    - Q3: Option B (í…ìŠ¤íŠ¸ ì‘ë‹µë„ ë¡œê¹… - ë””ë²„ê¹…ìš©)

API í˜¸ì¶œ ë°©ì‹ (U-064[Mvp] ìˆ˜ì •):
    - generate_images() ëŒ€ì‹  generate_content() ì‚¬ìš©
    - response_modalities=[Modality.TEXT, Modality.IMAGE] ì„¤ì •
    - ì‘ë‹µì—ì„œ part.inline_data.dataë¡œ ì´ë¯¸ì§€ ë°”ì´íŠ¸ ì¶”ì¶œ

ì°¸ì¡°:
    - vibe/tech-stack.md (ëª¨ë¸ ID ê³ ì •)
    - vibe/unit-plans/U-019[Mvp].md
    - vibe/unit-plans/U-064[Mvp].md
    - https://ai.google.dev/gemini-api/docs/image-generation
    - .cursor/rules/20-backend-orchestrator.mdc
"""

from __future__ import annotations

import asyncio
import base64
import hashlib
import logging
import os
import random
import uuid
from dataclasses import dataclass
from datetime import UTC, datetime
from enum import StrEnum
from pathlib import Path
from typing import TYPE_CHECKING, Any

from pydantic import BaseModel, ConfigDict, Field

from unknown_world.config.models import MODEL_IMAGE, ModelLabel, get_model_id
from unknown_world.storage.paths import (
    LEGACY_OUTPUT_DIR,
    build_image_url,
    get_generated_images_dir,
)
from unknown_world.storage.validation import (
    DEFAULT_ASPECT_RATIO,
    DEFAULT_IMAGE_SIZE,
    SUPPORTED_IMAGE_SIZES,
)

if TYPE_CHECKING:
    from google.genai import Client

# =============================================================================
# ë¡œê±° ì„¤ì • (í”„ë¡¬í”„íŠ¸/ë¹„ë°€ì •ë³´ ë…¸ì¶œ ê¸ˆì§€ - RULE-007/008)
# =============================================================================

logger = logging.getLogger(__name__)


# =============================================================================
# ìƒìˆ˜ ì •ì˜
# =============================================================================

# í•˜ìœ„ í˜¸í™˜ì„±ì„ ìœ„í•œ ë ˆê±°ì‹œ ê²½ë¡œ ë³„ì¹­ (RU-006-Q5)
# ì‹ ê·œ ì½”ë“œì—ì„œëŠ” get_generated_images_dir() ì‚¬ìš© ê¶Œì¥
DEFAULT_OUTPUT_DIR = LEGACY_OUTPUT_DIR

# í˜¸í™˜ì„±ì„ ìœ„í•œ ìƒìˆ˜ ë³„ì¹­
SUPPORTED_SIZES = SUPPORTED_IMAGE_SIZES
"""ì§€ì› ì´ë¯¸ì§€ í¬ê¸° (í˜¸í™˜ì„± ë³„ì¹­)."""

DEFAULT_SIZE = DEFAULT_IMAGE_SIZE
"""ê¸°ë³¸ ì´ë¯¸ì§€ í¬ê¸° (í˜¸í™˜ì„± ë³„ì¹­)."""

# U-064[Mvp] Q1 ê²°ì •: ì´ë¯¸ì§€ ìƒì„± íƒ€ì„ì•„ì›ƒ
# ì´ë¯¸ì§€ ìƒì„±ì€ 15-20ì´ˆ ì†Œìš” ê°€ëŠ¥í•˜ë¯€ë¡œ ì¶©ë¶„í•œ ì—¬ìœ ë¥¼ ë‘ 
# TODO: í…ŒìŠ¤íŠ¸ í›„ ì ì ˆí•œ ê°’ìœ¼ë¡œ ì¡°ì • (í˜„ì¬ 5ë¶„ìœ¼ë¡œ ì„¤ì •)
IMAGE_GENERATION_TIMEOUT_SECONDS = 300
"""ì´ë¯¸ì§€ ìƒì„± API í˜¸ì¶œ íƒ€ì„ì•„ì›ƒ (ì´ˆ)."""


class ImageGenerationStatus(StrEnum):
    """ì´ë¯¸ì§€ ìƒì„± ìƒíƒœ."""

    PENDING = "pending"
    """ìƒì„± ëŒ€ê¸° ì¤‘"""

    GENERATING = "generating"
    """ìƒì„± ì¤‘"""

    COMPLETED = "completed"
    """ìƒì„± ì™„ë£Œ"""

    FAILED = "failed"
    """ìƒì„± ì‹¤íŒ¨"""

    SKIPPED = "skipped"
    """ìƒì„± ê±´ë„ˆëœ€ (ì”ì•¡ ë¶€ì¡± ë“±)"""


# =============================================================================
# ìš”ì²­/ì‘ë‹µ Pydantic ëª¨ë¸
# =============================================================================


class ImageGenerationRequest(BaseModel):
    """ì´ë¯¸ì§€ ìƒì„± ìš”ì²­.

    TurnOutputì˜ render.image_jobê³¼ ì •í•©ë˜ë„ë¡ í•„ë“œë¥¼ ì„¤ê³„í•©ë‹ˆë‹¤.

    Attributes:
        prompt: ì´ë¯¸ì§€ ìƒì„± í”„ë¡¬í”„íŠ¸ (í•„ìˆ˜)
        aspect_ratio: ê°€ë¡œì„¸ë¡œ ë¹„ìœ¨ (ì˜ˆ: "16:9", "1:1")
        image_size: ì´ë¯¸ì§€ í¬ê¸° (ì˜ˆ: "1024x1024")
        reference_image_ids: ì°¸ì¡° ì´ë¯¸ì§€ ID ëª©ë¡ (ì„ íƒ, í¸ì§‘ìš©)
        reference_image_url: ì°¸ì¡° ì´ë¯¸ì§€ URL (U-068: ì´ì „ í„´ ì´ë¯¸ì§€ ì—°ê²°ì„±)
        session_id: ì„¸ì…˜ ID (íŒŒì¼ ê·¸ë£¹í™”ìš©)
        model_label: ëª¨ë¸ í‹°ì–´ë§ ë¼ë²¨ (U-066: FAST/QUALITY)
    """

    model_config = ConfigDict(extra="forbid")

    prompt: str = Field(min_length=1, description="ì´ë¯¸ì§€ ìƒì„± í”„ë¡¬í”„íŠ¸")
    aspect_ratio: str = Field(default=DEFAULT_ASPECT_RATIO, description="ê°€ë¡œì„¸ë¡œ ë¹„ìœ¨")
    image_size: str = Field(default=DEFAULT_SIZE, description="ì´ë¯¸ì§€ í¬ê¸°")
    reference_image_ids: list[str] = Field(default_factory=list, description="ì°¸ì¡° ì´ë¯¸ì§€ ID ëª©ë¡")
    reference_image_url: str | None = Field(
        default=None,
        description="ì°¸ì¡° ì´ë¯¸ì§€ URL (U-068: ì´ì „ í„´ ì´ë¯¸ì§€ë¥¼ ì°¸ì¡°í•˜ì—¬ ì—°ì†ì„± ìœ ì§€)",
    )
    session_id: str | None = Field(default=None, description="ì„¸ì…˜ ID")
    seed: int | None = Field(default=None, description="ê²°ì •ì  ìƒì„±ì„ ìœ„í•œ ì‹œë“œ (ì„ íƒ)")
    model_label: str = Field(
        default="QUALITY",
        description="ëª¨ë¸ í‹°ì–´ë§ ë¼ë²¨ (U-066: FAST=ì €ì§€ì—° í”„ë¦¬ë·°, QUALITY=ê³ í’ˆì§ˆ)",
    )


class ImageGenerationResponse(BaseModel):
    """ì´ë¯¸ì§€ ìƒì„± ì‘ë‹µ.

    Attributes:
        status: ìƒì„± ìƒíƒœ
        image_id: ìƒì„±ëœ ì´ë¯¸ì§€ ID (ì„±ê³µ ì‹œ)
        image_url: ìƒì„±ëœ ì´ë¯¸ì§€ URL (ì„±ê³µ ì‹œ)
        message: ìƒíƒœ ë©”ì‹œì§€ (ì‹¤íŒ¨ ì‹œ ì˜¤ë¥˜ ì„¤ëª…)
        generation_time_ms: ìƒì„± ì†Œìš” ì‹œê°„ (ë°€ë¦¬ì´ˆ)
    """

    model_config = ConfigDict(extra="forbid")

    status: ImageGenerationStatus
    image_id: str | None = Field(default=None, description="ìƒì„±ëœ ì´ë¯¸ì§€ ID")
    image_url: str | None = Field(default=None, description="ìƒì„±ëœ ì´ë¯¸ì§€ URL")
    message: str | None = Field(default=None, description="ìƒíƒœ ë©”ì‹œì§€")
    generation_time_ms: int = Field(default=0, description="ìƒì„± ì†Œìš” ì‹œê°„ (ms)")


# =============================================================================
# ë‚´ë¶€ ë°ì´í„° í´ë˜ìŠ¤
# =============================================================================


@dataclass
class GeneratedImage:
    """ìƒì„±ëœ ì´ë¯¸ì§€ ì •ë³´.

    Attributes:
        id: ì´ë¯¸ì§€ ê³ ìœ  ID
        path: ë¡œì»¬ íŒŒì¼ ê²½ë¡œ
        url: ì„œë¹™ URL
        prompt_hash: í”„ë¡¬í”„íŠ¸ í•´ì‹œ (ë¡œê·¸ìš©, ì›ë¬¸ ë…¸ì¶œ ê¸ˆì§€)
        created_at: ìƒì„± ì‹œê°
        size: íŒŒì¼ í¬ê¸° (bytes)
        metadata: ì¶”ê°€ ë©”íƒ€ë°ì´í„°
    """

    id: str
    path: Path
    url: str
    prompt_hash: str
    created_at: datetime
    size: int = 0

    def __post_init__(self) -> None:
        """ì´ˆê¸°í™” í›„ ë©”íƒ€ë°ì´í„° í•„ë“œ ì„¤ì •."""
        self._metadata: dict[str, str] = {}

    @property
    def metadata(self) -> dict[str, str]:
        """ì¶”ê°€ ë©”íƒ€ë°ì´í„°."""
        if not hasattr(self, "_metadata"):
            self._metadata = {}
        return self._metadata


# =============================================================================
# Mock ì´ë¯¸ì§€ ìƒì„±ê¸°
# =============================================================================


class MockImageGenerator:
    """í…ŒìŠ¤íŠ¸/ê°œë°œìš© ëª¨ì˜ ì´ë¯¸ì§€ ìƒì„±ê¸°.

    ì‹¤ì œ APIë¥¼ í˜¸ì¶œí•˜ì§€ ì•Šê³  í”Œë ˆì´ìŠ¤í™€ë” ì´ë¯¸ì§€ë¥¼ ìƒì„±í•©ë‹ˆë‹¤.
    """

    def __init__(self, output_dir: Path | None = None) -> None:
        """MockImageGeneratorë¥¼ ì´ˆê¸°í™”í•©ë‹ˆë‹¤.

        Args:
            output_dir: ì´ë¯¸ì§€ ì €ì¥ ë””ë ‰í† ë¦¬ (ê¸°ë³¸ê°’: .data/images/generated)
        """
        self._output_dir = output_dir or get_generated_images_dir()
        self._output_dir.mkdir(parents=True, exist_ok=True)
        logger.info(
            "[ImageGen] Mock ëª¨ë“œë¡œ ì´ˆê¸°í™”ë¨",
            extra={"output_dir": str(self._output_dir)},
        )

    async def generate(self, request: ImageGenerationRequest) -> ImageGenerationResponse:
        """ëª¨ì˜ ì´ë¯¸ì§€ë¥¼ ìƒì„±í•©ë‹ˆë‹¤.

        Args:
            request: ì´ë¯¸ì§€ ìƒì„± ìš”ì²­

        Returns:
            ImageGenerationResponse: ìƒì„± ê²°ê³¼
        """
        start_time = datetime.now(UTC)

        # í”„ë¡¬í”„íŠ¸ í•´ì‹œ ìƒì„± (ì›ë¬¸ ë¡œê¹… ê¸ˆì§€ - RULE-007)
        prompt_hash = hashlib.sha256(request.prompt.encode()).hexdigest()[:8]
        logger.debug(
            "[ImageGen] Mock ì´ë¯¸ì§€ ìƒì„± ìš”ì²­",
            extra={
                "prompt_hash": prompt_hash,
                "size": request.image_size,
                "aspect_ratio": request.aspect_ratio,
                "model_label": request.model_label,
                "reference_image_url": request.reference_image_url,
            },
        )

        # ê³ ìœ  ì´ë¯¸ì§€ ID ìƒì„± (U-060: seedê°€ ìˆìœ¼ë©´ ê²°ì •ì  ìƒì„±)
        if request.seed is not None:
            # ì‹œë“œì™€ í”„ë¡¬í”„íŠ¸ í•´ì‹œë¥¼ ì¡°í•©í•˜ì—¬ ê³ ìœ ì„± í™•ë³´
            seed_rng = random.Random(f"{request.seed}_{prompt_hash}")
            image_id = f"img_{seed_rng.getrandbits(48):012x}"
        else:
            image_id = f"img_{uuid.uuid4().hex[:12]}"

        # í”Œë ˆì´ìŠ¤í™€ë” ì´ë¯¸ì§€ ìƒì„± (1x1 íˆ¬ëª… PNG)
        # ì‹¤ì œ í™˜ê²½ì—ì„œëŠ” Gemini API ì‘ë‹µìœ¼ë¡œ ëŒ€ì²´ë¨
        placeholder_png = self._create_placeholder_png(request.image_size)

        # íŒŒì¼ ì €ì¥
        file_name = f"{image_id}.png"
        file_path = self._output_dir / file_name
        file_path.write_bytes(placeholder_png)

        # U-091: rembg ëŸ°íƒ€ì„ ì œê±° - ë°°ê²½ ì œê±° í›„ì²˜ë¦¬ ì—†ì´ ë°”ë¡œ ì €ì¥

        # ì„œë¹™ URL ìƒì„± (RU-006-Q5: ì¤‘ì•™í™”ëœ URL ë¹Œë” ì‚¬ìš©)
        image_url = build_image_url(file_name, category="generated")

        elapsed_ms = int((datetime.now(UTC) - start_time).total_seconds() * 1000)

        logger.info(
            "[ImageGen] Mock ì´ë¯¸ì§€ ìƒì„± ì™„ë£Œ",
            extra={
                "image_id": image_id,
                "elapsed_ms": elapsed_ms,
            },
        )

        return ImageGenerationResponse(
            status=ImageGenerationStatus.COMPLETED,
            image_id=image_id,
            image_url=image_url,
            message="Mock ì´ë¯¸ì§€ê°€ ìƒì„±ë˜ì—ˆìŠµë‹ˆë‹¤.",
            generation_time_ms=elapsed_ms,
        )

    def _create_placeholder_png(self, size_str: str) -> bytes:
        """í”Œë ˆì´ìŠ¤í™€ë” PNGë¥¼ ìƒì„±í•©ë‹ˆë‹¤.

        Args:
            size_str: ì´ë¯¸ì§€ í¬ê¸° ë¬¸ìì—´ (ì˜ˆ: "1024x1024")

        Returns:
            PNG ë°”ì´íŠ¸ ë°ì´í„°
        """
        # ìµœì†Œí•œì˜ ìœ íš¨í•œ PNG (1x1 íšŒìƒ‰ í”½ì…€)
        # ì‹¤ì œ í¬ê¸°ëŠ” ë¬´ì‹œí•˜ê³  í”Œë ˆì´ìŠ¤í™€ë”ë§Œ ë°˜í™˜
        # 16x16 íšŒìƒ‰ PNG (mock ì‹ë³„ìš©)
        # Base64ë¡œ ì¸ì½”ë”©ëœ ë¯¸ë‹ˆë©€ PNG
        minimal_png = base64.b64decode(
            "iVBORw0KGgoAAAANSUhEUgAAABAAAAAQCAYAAAAf8/9hAAAADklEQVQ4y2NgGAWjAAcA"
            "CHABAMXKQ5oAAAAASUVORK5CYII="
        )
        return minimal_png

    def is_available(self) -> bool:
        """Mock ìƒì„±ê¸°ëŠ” í•­ìƒ ì‚¬ìš© ê°€ëŠ¥í•©ë‹ˆë‹¤."""
        return True


# =============================================================================
# ì‹¤ì œ ì´ë¯¸ì§€ ìƒì„±ê¸°
# =============================================================================


class ImageGenerator:
    """Gemini ê¸°ë°˜ ì‹¤ì œ ì´ë¯¸ì§€ ìƒì„±ê¸°.

    gemini-3-pro-image-preview ëª¨ë¸ì„ ì‚¬ìš©í•˜ì—¬ ì´ë¯¸ì§€ë¥¼ ìƒì„±í•©ë‹ˆë‹¤.
    ëª¨ë¸ IDëŠ” RULE-010ì— ë”°ë¼ ê³ ì •ë©ë‹ˆë‹¤.

    U-080 í•«í”½ìŠ¤: Vertex AI ì„œë¹„ìŠ¤ ê³„ì • ì¸ì¦ ì™„ì „ ì œê±°, API í‚¤ ì „ìš©
    U-068: ì°¸ì¡° ì´ë¯¸ì§€(ì´ì „ í„´ ì´ë¯¸ì§€)ë¥¼ ì‚¬ìš©í•œ ì‹œê°ì  ì—°ì†ì„± ì§€ì›
    """

    def __init__(
        self,
        output_dir: Path | None = None,
        api_key: str | None = None,
    ) -> None:
        """ImageGeneratorë¥¼ ì´ˆê¸°í™”í•©ë‹ˆë‹¤.

        Args:
            output_dir: ì´ë¯¸ì§€ ì €ì¥ ë””ë ‰í† ë¦¬ (ê¸°ë³¸ê°’: .data/images/generated)
            api_key: Gemini API í‚¤ (í™˜ê²½ë³€ìˆ˜ GOOGLE_API_KEY ì‚¬ìš© ê°€ëŠ¥)
        """
        self._output_dir = output_dir or get_generated_images_dir()
        self._output_dir.mkdir(parents=True, exist_ok=True)
        self._api_key = api_key or os.environ.get("GOOGLE_API_KEY")
        self._client: Client | None = None
        self._available = False
        # U-068: ì°¸ì¡° ì´ë¯¸ì§€ ìºì‹œ (URL â†’ bytes)
        self._reference_image_cache: dict[str, bytes] = {}

        self._initialize_client()

    def _initialize_client(self) -> None:
        """google-genai í´ë¼ì´ì–¸íŠ¸ë¥¼ ì´ˆê¸°í™”í•©ë‹ˆë‹¤."""
        try:
            if not self._api_key:
                logger.warning(
                    "[ImageGen] GOOGLE_API_KEY í™˜ê²½ë³€ìˆ˜ê°€ ì„¤ì •ë˜ì§€ ì•ŠìŒ - Mock ëª¨ë“œ ê¶Œì¥",
                )
                self._available = False
                return

            from google.genai import Client

            # API í‚¤ ëª¨ë“œë¡œ í´ë¼ì´ì–¸íŠ¸ ì´ˆê¸°í™” (Vertex AI ì œê±°)
            self._client = Client(api_key=self._api_key)
            self._available = True

            # ë¡œê·¸ì—ëŠ” ëª¨ë¸ IDë§Œ ê¸°ë¡ (API í‚¤ ë…¸ì¶œ ê¸ˆì§€ - RULE-007)
            logger.info(
                "[ImageGen] API í‚¤ ì´ë¯¸ì§€ ìƒì„±ê¸° ì´ˆê¸°í™” ì™„ë£Œ",
                extra={
                    "model": MODEL_IMAGE,
                    "auth": "api_key",
                },
            )
        except Exception as e:
            logger.warning(
                "[ImageGen] API í‚¤ í´ë¼ì´ì–¸íŠ¸ ì´ˆê¸°í™” ì‹¤íŒ¨ - Mock ëª¨ë“œ ê¶Œì¥",
                extra={"error_type": type(e).__name__},
            )
            self._available = False

    async def _load_reference_image(self, url: str) -> bytes | None:
        """ì°¸ì¡° ì´ë¯¸ì§€ë¥¼ URLì—ì„œ ë¡œë“œí•©ë‹ˆë‹¤ (U-068).

        ë¡œì»¬ íŒŒì¼ ë˜ëŠ” HTTP URLì—ì„œ ì´ë¯¸ì§€ë¥¼ ë¡œë“œí•©ë‹ˆë‹¤.
        ìºì‹œë¥¼ ì‚¬ìš©í•˜ì—¬ ë™ì¼ URLì˜ ì¤‘ë³µ ë¡œë”©ì„ ë°©ì§€í•©ë‹ˆë‹¤.

        Args:
            url: ì´ë¯¸ì§€ URL (ë¡œì»¬ ê²½ë¡œ ë˜ëŠ” HTTP URL)

        Returns:
            bytes | None: ì´ë¯¸ì§€ ë°”ì´íŠ¸ ë˜ëŠ” ì‹¤íŒ¨ ì‹œ None
        """
        # ìºì‹œ í™•ì¸
        if url in self._reference_image_cache:
            logger.debug(
                "[ImageGen] ì°¸ì¡° ì´ë¯¸ì§€ ìºì‹œ íˆíŠ¸",
                extra={"url_hash": hashlib.sha256(url.encode()).hexdigest()[:8]},
            )
            return self._reference_image_cache[url]

        try:
            # ë¡œì»¬ íŒŒì¼ ê²½ë¡œ ì²˜ë¦¬ (API URL í˜•ì‹: /api/image/file/{image_id})
            if url.startswith("/api/image/file/"):
                # URLì—ì„œ ì´ë¯¸ì§€ ID ì¶”ì¶œ
                image_id = url.split("/")[-1]
                file_path = self._output_dir / f"{image_id}.png"
                if file_path.exists():
                    image_bytes = file_path.read_bytes()
                    self._reference_image_cache[url] = image_bytes
                    logger.debug(
                        "[ImageGen] ë¡œì»¬ ì°¸ì¡° ì´ë¯¸ì§€ ë¡œë“œ ì„±ê³µ",
                        extra={"image_id": image_id, "size_bytes": len(image_bytes)},
                    )
                    return image_bytes
                else:
                    logger.warning(
                        "[ImageGen] ë¡œì»¬ ì°¸ì¡° ì´ë¯¸ì§€ íŒŒì¼ ì—†ìŒ",
                        extra={"image_id": image_id},
                    )
                    return None

            # HTTP/HTTPS URL ì²˜ë¦¬
            if url.startswith(("http://", "https://")):
                import httpx

                async with httpx.AsyncClient(timeout=30.0) as client:
                    response = await client.get(url)
                    response.raise_for_status()
                    image_bytes = response.content
                    self._reference_image_cache[url] = image_bytes
                    logger.debug(
                        "[ImageGen] HTTP ì°¸ì¡° ì´ë¯¸ì§€ ë¡œë“œ ì„±ê³µ",
                        extra={
                            "url_hash": hashlib.sha256(url.encode()).hexdigest()[:8],
                            "size_bytes": len(image_bytes),
                        },
                    )
                    return image_bytes

            logger.warning(
                "[ImageGen] ì§€ì›í•˜ì§€ ì•ŠëŠ” ì°¸ì¡° ì´ë¯¸ì§€ URL í˜•ì‹",
                extra={"url_prefix": url[:20] if len(url) > 20 else url},
            )
            return None

        except Exception as e:
            logger.warning(
                "[ImageGen] ì°¸ì¡° ì´ë¯¸ì§€ ë¡œë“œ ì‹¤íŒ¨",
                extra={"error_type": type(e).__name__},
            )
            return None

    async def generate(self, request: ImageGenerationRequest) -> ImageGenerationResponse:
        """ì´ë¯¸ì§€ë¥¼ ìƒì„±í•©ë‹ˆë‹¤.

        U-064[Mvp] ìˆ˜ì •: generate_content() APIë¥¼ ì‚¬ìš©í•˜ì—¬ ì´ë¯¸ì§€ ìƒì„±.
        gemini-3-pro-image-preview ëª¨ë¸ì€ generate_images()ê°€ ì•„ë‹Œ
        generate_content()ë¥¼ ì‚¬ìš©í•´ì•¼ í•¨.

        U-068: ì°¸ì¡° ì´ë¯¸ì§€ê°€ ìˆìœ¼ë©´ ë©€í‹°ëª¨ë‹¬ ì…ë ¥ìœ¼ë¡œ ì „ë‹¬í•˜ì—¬ ì‹œê°ì  ì—°ì†ì„± ìœ ì§€.

        Args:
            request: ì´ë¯¸ì§€ ìƒì„± ìš”ì²­

        Returns:
            ImageGenerationResponse: ìƒì„± ê²°ê³¼
        """
        if not self._available or self._client is None:
            return ImageGenerationResponse(
                status=ImageGenerationStatus.FAILED,
                message="ì´ë¯¸ì§€ ìƒì„± í´ë¼ì´ì–¸íŠ¸ê°€ ì´ˆê¸°í™”ë˜ì§€ ì•Šì•˜ìŠµë‹ˆë‹¤.",
            )

        start_time = datetime.now(UTC)

        # í”„ë¡¬í”„íŠ¸ í•´ì‹œ (ì›ë¬¸ ë¡œê¹… ê¸ˆì§€ - RULE-007)
        prompt_hash = hashlib.sha256(request.prompt.encode()).hexdigest()[:8]

        # U-066: model_labelì— ë”°ë¥¸ ëª¨ë¸ ì„ íƒ
        # FAST â†’ gemini-2.5-flash-image (ì €ì§€ì—° í”„ë¦¬ë·°)
        # QUALITY (ê¸°ë³¸) â†’ gemini-3-pro-image-preview (ê³ í’ˆì§ˆ)
        selected_model_label = (
            ModelLabel.IMAGE_FAST if request.model_label == "FAST" else ModelLabel.IMAGE
        )
        selected_model_id = get_model_id(selected_model_label)

        # U-068: ì°¸ì¡° ì´ë¯¸ì§€ ë¡œë“œ (ìˆëŠ” ê²½ìš°)
        reference_image_bytes: bytes | None = None
        has_reference = False
        if request.reference_image_url:
            reference_image_bytes = await self._load_reference_image(request.reference_image_url)
            has_reference = reference_image_bytes is not None

        logger.debug(
            "[ImageGen] ì´ë¯¸ì§€ ìƒì„± ìš”ì²­",
            extra={
                "prompt_hash": prompt_hash,
                "size": request.image_size,
                "aspect_ratio": request.aspect_ratio,
                "model": selected_model_id,
                "model_label": request.model_label,
                "has_reference": has_reference,
            },
        )

        try:
            from google.genai.types import GenerateContentConfig, Modality, Part

            # U-068: ì°¸ì¡° ì´ë¯¸ì§€ê°€ ìˆìœ¼ë©´ ë©€í‹°ëª¨ë‹¬ contents êµ¬ì„±
            # ì°¸ì¡° ì´ë¯¸ì§€ë¥¼ ë¨¼ì € ë„£ê³ , í”„ë¡¬í”„íŠ¸ë¥¼ ê·¸ ë‹¤ìŒì— ë°°ì¹˜
            if has_reference and reference_image_bytes is not None:
                # ë©€í‹°ëª¨ë‹¬ contents: [ì°¸ì¡° ì´ë¯¸ì§€, í”„ë¡¬í”„íŠ¸ í…ìŠ¤íŠ¸]
                # type: ignore[reportUnknownVariableType]
                contents = [
                    Part.from_bytes(data=reference_image_bytes, mime_type="image/png"),
                    Part.from_text(
                        text=f"ì´ì „ ì¥ë©´ì˜ ì´ë¯¸ì§€ì…ë‹ˆë‹¤. ì´ ì´ë¯¸ì§€ì˜ ìŠ¤íƒ€ì¼, í†¤, ìºë¦­í„°/ì˜¤ë¸Œì íŠ¸ ì™¸í˜•ì„ ì°¸ì¡°í•˜ì—¬ ë‹¤ìŒ ì¥ë©´ì„ ìƒì„±í•´ì£¼ì„¸ìš”:\n\n{request.prompt}"
                    ),
                ]
            else:
                # ì°¸ì¡° ì´ë¯¸ì§€ ì—†ì´ í”„ë¡¬í”„íŠ¸ë§Œ ì „ë‹¬
                contents = request.prompt

            # U-064: generate_content() APIë¥¼ ì‚¬ìš©í•˜ì—¬ ì´ë¯¸ì§€ ìƒì„±
            # response_modalitiesì— TEXTì™€ IMAGEë¥¼ ëª¨ë‘ í¬í•¨
            # ì°¸ê³ : https://ai.google.dev/gemini-api/docs/image-generation
            # Q1 ê²°ì •: íƒ€ì„ì•„ì›ƒ 60ì´ˆ ì ìš©
            response = await asyncio.wait_for(
                self._client.aio.models.generate_content(  # type: ignore[reportUnknownMemberType]
                    model=selected_model_id,
                    contents=contents,  # type: ignore[reportArgumentType]
                    config=GenerateContentConfig(
                        response_modalities=[Modality.TEXT, Modality.IMAGE],
                    ),
                ),
                timeout=IMAGE_GENERATION_TIMEOUT_SECONDS,
            )

            # U-064: ì‘ë‹µì—ì„œ ì´ë¯¸ì§€ ì¶”ì¶œ (ë©”ì„œë“œ ë¶„ë¦¬)
            image_bytes = self._extract_image_from_response(response)

            if image_bytes is None:
                elapsed_ms = int((datetime.now(UTC) - start_time).total_seconds() * 1000)
                logger.warning(
                    "[ImageGen] ì´ë¯¸ì§€ ìƒì„± ì‘ë‹µì— ì´ë¯¸ì§€ ë°ì´í„°ê°€ ì—†ìŒ",
                    extra={"elapsed_ms": elapsed_ms},
                )
                return ImageGenerationResponse(
                    status=ImageGenerationStatus.FAILED,
                    message="ì´ë¯¸ì§€ ìƒì„± ì‘ë‹µì— ì´ë¯¸ì§€ ë°ì´í„°ê°€ ì—†ìŠµë‹ˆë‹¤.",
                    generation_time_ms=elapsed_ms,
                )

            # ê³ ìœ  ID ë° íŒŒì¼ ì €ì¥ (U-060: seedê°€ ìˆìœ¼ë©´ ê²°ì •ì  ìƒì„±)
            if request.seed is not None:
                # ì‹œë“œì™€ í”„ë¡¬í”„íŠ¸ í•´ì‹œë¥¼ ì¡°í•©í•˜ì—¬ ê³ ìœ ì„± í™•ë³´
                seed_rng = random.Random(f"{request.seed}_{prompt_hash}")
                image_id = f"img_{seed_rng.getrandbits(48):012x}"
            else:
                image_id = f"img_{uuid.uuid4().hex[:12]}"

            file_name = f"{image_id}.png"
            file_path = self._output_dir / file_name
            file_path.write_bytes(image_bytes)

            # U-091: rembg ëŸ°íƒ€ì„ ì œê±° - ë°°ê²½ ì œê±° í›„ì²˜ë¦¬ ì—†ì´ ë°”ë¡œ ì €ì¥

            # ì„œë¹™ URL ìƒì„± (RU-006-Q5: ì¤‘ì•™í™”ëœ URL ë¹Œë” ì‚¬ìš©)
            image_url = build_image_url(file_name, category="generated")
            elapsed_ms = int((datetime.now(UTC) - start_time).total_seconds() * 1000)

            logger.info(
                "[ImageGen] ì´ë¯¸ì§€ ìƒì„± ì™„ë£Œ",
                extra={
                    "image_id": image_id,
                    "elapsed_ms": elapsed_ms,
                    "size_bytes": len(image_bytes),
                },
            )

            return ImageGenerationResponse(
                status=ImageGenerationStatus.COMPLETED,
                image_id=image_id,
                image_url=image_url,
                message="ì´ë¯¸ì§€ê°€ ì„±ê³µì ìœ¼ë¡œ ìƒì„±ë˜ì—ˆìŠµë‹ˆë‹¤.",
                generation_time_ms=elapsed_ms,
            )

        except TimeoutError:
            # Q1 ê²°ì •: 60ì´ˆ íƒ€ì„ì•„ì›ƒ ì´ˆê³¼ ì‹œ ì²˜ë¦¬
            elapsed_ms = int((datetime.now(UTC) - start_time).total_seconds() * 1000)
            logger.warning(
                "[ImageGen] ì´ë¯¸ì§€ ìƒì„± íƒ€ì„ì•„ì›ƒ",
                extra={
                    "timeout_seconds": IMAGE_GENERATION_TIMEOUT_SECONDS,
                    "elapsed_ms": elapsed_ms,
                },
            )
            return ImageGenerationResponse(
                status=ImageGenerationStatus.FAILED,
                message=f"ì´ë¯¸ì§€ ìƒì„± íƒ€ì„ì•„ì›ƒ ({IMAGE_GENERATION_TIMEOUT_SECONDS}ì´ˆ ì´ˆê³¼)",
                generation_time_ms=elapsed_ms,
            )

        except Exception as e:
            elapsed_ms = int((datetime.now(UTC) - start_time).total_seconds() * 1000)
            error_type = type(e).__name__

            logger.error(
                "[ImageGen] ì´ë¯¸ì§€ ìƒì„± ì‹¤íŒ¨",
                extra={
                    "error_type": error_type,
                    "elapsed_ms": elapsed_ms,
                },
            )

            # ì‹¤íŒ¨ ì‹œì—ë„ ì•ˆì „í•œ ì‘ë‹µ ë°˜í™˜ (RULE-004)
            return ImageGenerationResponse(
                status=ImageGenerationStatus.FAILED,
                message=f"ì´ë¯¸ì§€ ìƒì„± ì¤‘ ì˜¤ë¥˜ê°€ ë°œìƒí–ˆìŠµë‹ˆë‹¤: {error_type}",
                generation_time_ms=elapsed_ms,
            )

    def _extract_image_from_response(self, response: Any) -> bytes | None:
        """generate_content ì‘ë‹µì—ì„œ ì´ë¯¸ì§€ ë°”ì´íŠ¸ ì¶”ì¶œ.

        Args:
            response: Gemini API ì‘ë‹µ ê°ì²´

        Returns:
            bytes | None: ì¶”ì¶œëœ ì´ë¯¸ì§€ ë°”ì´íŠ¸ ë˜ëŠ” None
        """
        try:
            if not response or not hasattr(response, "candidates") or not response.candidates:
                return None

            for candidate in response.candidates:
                if not hasattr(candidate, "content") or not candidate.content:
                    continue
                if not hasattr(candidate.content, "parts") or not candidate.content.parts:
                    continue

                for part in candidate.content.parts:
                    # Q3 ê²°ì •: í…ìŠ¤íŠ¸ ì‘ë‹µë„ ë¡œê¹… (ë””ë²„ê¹…ìš©)
                    if hasattr(part, "text") and part.text:
                        text_preview = (
                            part.text[:100] + "..." if len(part.text) > 100 else part.text
                        )
                        logger.debug(
                            "[ImageGen] í…ìŠ¤íŠ¸ ì‘ë‹µ (ë””ë²„ê¹…ìš©)",
                            extra={"text_preview": text_preview},
                        )

                    # ì´ë¯¸ì§€ ë°ì´í„° ì¶”ì¶œ
                    if (
                        hasattr(part, "inline_data")
                        and part.inline_data
                        and hasattr(part.inline_data, "data")
                        and part.inline_data.data
                    ):
                        logger.debug(
                            "[ImageGen] ì´ë¯¸ì§€ ë°ì´í„° ì¶”ì¶œ ì„±ê³µ",
                            extra={"size_bytes": len(part.inline_data.data)},
                        )
                        return part.inline_data.data

            return None
        except Exception as e:
            logger.warning(
                "[ImageGen] ì‘ë‹µ íŒŒì‹± ì¤‘ ì˜¤ë¥˜ ë°œìƒ",
                extra={"error_type": type(e).__name__, "message": str(e)},
            )
            return None

    def is_available(self) -> bool:
        """ìƒì„±ê¸°ê°€ ì‚¬ìš© ê°€ëŠ¥í•œ ìƒíƒœì¸ì§€ í™•ì¸í•©ë‹ˆë‹¤."""
        return self._available


# =============================================================================
# íŒ©í† ë¦¬ í•¨ìˆ˜
# =============================================================================

# ìƒì„±ê¸° íƒ€ì…
ImageGeneratorType = MockImageGenerator | ImageGenerator

# ì‹±ê¸€í†¤ ì¸ìŠ¤í„´ìŠ¤ ìºì‹œ
_generator_instance: ImageGeneratorType | None = None


def get_image_generator(
    *,
    force_mock: bool = False,
    force_new: bool = False,
    output_dir: Path | None = None,
) -> ImageGeneratorType:
    """ì´ë¯¸ì§€ ìƒì„±ê¸° ì¸ìŠ¤í„´ìŠ¤ë¥¼ ë°˜í™˜í•©ë‹ˆë‹¤.

    í™˜ê²½ë³€ìˆ˜ UW_MODEì— ë”°ë¼ ì‹¤ì œ ìƒì„±ê¸° ë˜ëŠ” Mock ìƒì„±ê¸°ë¥¼ ë°˜í™˜í•©ë‹ˆë‹¤.

    Args:
        force_mock: Trueë©´ í™˜ê²½ë³€ìˆ˜ì™€ ë¬´ê´€í•˜ê²Œ Mock ìƒì„±ê¸° ë°˜í™˜
        force_new: Trueë©´ ìºì‹œë¥¼ ë¬´ì‹œí•˜ê³  ìƒˆ ì¸ìŠ¤í„´ìŠ¤ ìƒì„±
        output_dir: ì´ë¯¸ì§€ ì €ì¥ ë””ë ‰í† ë¦¬

    Returns:
        ì´ë¯¸ì§€ ìƒì„±ê¸° ì¸ìŠ¤í„´ìŠ¤
    """
    global _generator_instance

    if not force_new and _generator_instance is not None:
        return _generator_instance

    # ëª¨ë“œ ê²°ì •
    mode = os.environ.get("UW_MODE", "real")

    if force_mock or mode == "mock":
        generator: ImageGeneratorType = MockImageGenerator(output_dir)
    else:
        real_gen = ImageGenerator(output_dir)
        # ì‹¤ì œ ìƒì„±ê¸° ì´ˆê¸°í™” ì‹¤íŒ¨ ì‹œ Mockìœ¼ë¡œ í´ë°±
        if not real_gen.is_available():
            logger.warning("[ImageGen] ì‹¤ì œ ìƒì„±ê¸° ì´ˆê¸°í™” ì‹¤íŒ¨, Mock ëª¨ë“œë¡œ í´ë°±")
            generator = MockImageGenerator(output_dir)
        else:
            generator = real_gen

    _generator_instance = generator
    return generator


def reset_image_generator() -> None:
    """ì´ë¯¸ì§€ ìƒì„±ê¸° ìºì‹œë¥¼ ì´ˆê¸°í™”í•©ë‹ˆë‹¤.

    í…ŒìŠ¤íŠ¸ ì‹œ ìƒì„±ê¸°ë¥¼ ì¬ì„¤ì •í•  ë•Œ ì‚¬ìš©í•©ë‹ˆë‹¤.
    """
    global _generator_instance
    _generator_instance = None


# =============================================================================
# í—¬í¼ í•¨ìˆ˜
# =============================================================================


def create_fallback_response(message: str | None = None) -> ImageGenerationResponse:
    """ì‹¤íŒ¨ ì‹œ ì•ˆì „í•œ í´ë°± ì‘ë‹µì„ ìƒì„±í•©ë‹ˆë‹¤.

    RULE-004: ê²€ì¦ ì‹¤íŒ¨ë‚˜ ì˜¤ë¥˜ ì‹œì—ë„ ì•ˆì „í•œ ì‘ë‹µ ì œê³µ

    Args:
        message: ì˜¤ë¥˜ ë©”ì‹œì§€ (ì„ íƒ)

    Returns:
        ImageGenerationResponse: í´ë°± ì‘ë‹µ
    """
    return ImageGenerationResponse(
        status=ImageGenerationStatus.SKIPPED,
        message=message or "ì´ë¯¸ì§€ ìƒì„±ì„ ê±´ë„ˆë›°ì—ˆìŠµë‹ˆë‹¤. í…ìŠ¤íŠ¸ë¡œ ì§„í–‰í•©ë‹ˆë‹¤.",
    )


def validate_image_request(request: ImageGenerationRequest) -> str | None:
    """ì´ë¯¸ì§€ ìƒì„± ìš”ì²­ì„ ê²€ì¦í•©ë‹ˆë‹¤.

    Args:
        request: ì´ë¯¸ì§€ ìƒì„± ìš”ì²­ ê°ì²´

    Returns:
        str | None: ì˜¤ë¥˜ ë©”ì‹œì§€ ë˜ëŠ” ì„±ê³µ ì‹œ None
    """
    if not request.prompt or len(request.prompt.strip()) < 2:
        return "í”„ë¡¬í”„íŠ¸ê°€ ë„ˆë¬´ ì§§ìŠµë‹ˆë‹¤."

    if request.image_size not in SUPPORTED_IMAGE_SIZES:
        return f"ì§€ì›í•˜ì§€ ì•ŠëŠ” ì´ë¯¸ì§€ í¬ê¸°: {request.image_size}"

    return None
</file>

<file path="frontend/src/locales/en-US/translation.json">
{
  "language": {
    "toggle": "Change Language",
    "toggle_tooltip": "Click to change language. A new game will start after change.",
    "ko-KR": "í•œêµ­ì–´",
    "en-US": "English"
  },
  "error": {
    "unknown_error": "An unknown error occurred.",
    "response_processing": "[System] An error occurred while processing response data.",
    "connection_failed": "[System] Failed to connect to server. Please try again."
  },
  "profile": {
    "select_title": "Select Your Profile",
    "select_hint": "Each profile has different starting conditions and objectives",
    "or": "or",
    "continue_saved": "Continue Saved Game",
    "change": "Change Profile",
    "change_tooltip": "Start a new game with a different profile",
    "narrator": {
      "name": "Narrator",
      "description": "Explore diverse stories with abundant resources",
      "welcome": "Welcome to the Ancient Library. Forgotten tales slumber within these walls...",
      "items": {
        "ancient_tome": "Ancient Tome",
        "quill_pen": "Quill Pen",
        "memory_fragment": "Memory Fragment"
      },
      "quest": {
        "discover_origin": "Discover the World's Origin",
        "discover_origin_desc": "Find clues and uncover how this world was created",
        "collect_memories": "Collect 3 Memory Fragments",
        "read_ancient_tome": "Decipher the Ancient Tome"
      },
      "rule": {
        "time_flows": "Flow of Time",
        "time_flows_desc": "Time flows normally",
        "memories_persist": "Memory Persistence",
        "memories_persist_desc": "Once obtained, memories never fade"
      },
      "scene": {
        "bookshelf": "Mysterious Bookshelf",
        "bookshelf_hint": "Ancient books are glowing",
        "portal": "Glowing Portal",
        "portal_hint": "It seems to lead somewhere"
      }
    },
    "explorer": {
      "name": "Explorer",
      "description": "Explore unknown territories and uncover secrets",
      "welcome": "You wake up in a dark maze. You must find the exit and escape...",
      "items": {
        "compass": "Compass",
        "rope": "Rope",
        "lantern": "Lantern",
        "map_fragment": "Map Fragment"
      },
      "quest": {
        "find_exit": "Find the Exit",
        "find_exit_desc": "Explore the maze and find the hidden exit to escape",
        "explore_areas": "Explore 3 Areas",
        "gather_supplies": "Gather Supplies"
      },
      "rule": {
        "gravity": "Gravity Law",
        "gravity_desc": "Objects fall downward",
        "darkness": "Darkness Law",
        "darkness_desc": "You cannot see without light"
      },
      "scene": {
        "door": "Ancient Door",
        "door_hint": "Looks like it needs a key",
        "mechanism": "Strange Mechanism",
        "mechanism_hint": "It might be operable",
        "passage": "Hidden Passage",
        "passage_hint": "Where does it lead?"
      }
    },
    "tech": {
      "name": "Tech Expert",
      "description": "Strategize efficiently with limited resources",
      "welcome": "System boot complete. Find the optimal path with limited energy...",
      "items": {
        "data_core": "Data Core",
        "circuit_board": "Circuit Board",
        "energy_cell": "Energy Cell",
        "scanner": "Scanner Device"
      },
      "quest": {
        "analyze_system": "Complete System Analysis",
        "analyze_system_desc": "Access the core terminal and analyze the system structure",
        "optimize_resources": "Optimize Resource Efficiency",
        "scan_terminal": "Perform Terminal Scan"
      },
      "rule": {
        "energy_conservation": "Energy Conservation",
        "energy_conservation_desc": "Energy is neither created nor destroyed",
        "data_integrity": "Data Integrity",
        "data_integrity_desc": "Corrupted data cannot be recovered",
        "system_limits": "System Limits",
        "system_limits_desc": "There are limits to concurrent processing"
      },
      "scene": {
        "terminal": "Main Terminal",
        "terminal_hint": "You can access the system",
        "conduit": "Power Conduit",
        "conduit_hint": "Energy is flowing through it"
      }
    }
  },
  "reset": {
    "button": "Reset",
    "confirm": "Click again to confirm",
    "cancel": "Cancel",
    "tooltip": "Return to the initial state of current profile"
  },
  "demo": {
    "items": {
      "keycard-alpha": {
        "name": "Keycard A"
      },
      "medkit": {
        "name": "Medkit"
      },
      "flashlight": {
        "name": "Flashlight"
      },
      "data-chip": {
        "name": "Data Chip"
      }
    },
    "scene": {
      "terminal": {
        "label": "Terminal",
        "hint": "An active terminal"
      },
      "door": {
        "label": "Door",
        "hint": "It appears to be locked"
      }
    },
    "quest": {
      "terminal": {
        "label": "Access the terminal"
      },
      "escape": {
        "label": "Find facility exit"
      },
      "collect": {
        "label": "Collect data chips"
      }
    },
    "rule": {
      "gravity": {
        "label": "Gravity Law",
        "description": "Objects fall downward"
      },
      "time": {
        "label": "Time Flow",
        "description": "Time flows at normal speed"
      }
    }
  },
  "quest": {
    "empty": "[ NO OBJECTIVES ]",
    "completed": "DONE",
    "section": {
      "active": "Active",
      "completed": "Completed"
    },
    "main_objective": "Main Objective",
    "sub_objectives": "Sub-objectives",
    "progress": "Progress {{progress}}%",
    "reward_preview": "Reward: {{signal}} Signal",
    "reward_earned": "+{{signal}} Signal earned!",
    "objective_complete": "Objective Complete!",
    "free_exploration": "Free Exploration",
    "free_exploration_desc": "Explore the world freely without a set objective",
    "no_sub_objectives": "No sub-objectives yet",
    "tracker_no_objective": "No Objective"
  },
  "rule_board": {
    "empty": "[ NO RULES ]",
    "active_count": "Active Rules: {{count}}"
  },
  "mutation": {
    "empty": "[ NO MUTATIONS ]",
    "timeline_title": "Mutation Timeline",
    "event_count": "{{count}} events",
    "more_events": "+{{count}} more",
    "turn_label": "T{{turn}}",
    "type": {
      "added": "Added",
      "modified": "Modified",
      "removed": "Removed"
    }
  },
  "scene": {
    "status": {
      "default": "NO SIGNAL DATA",
      "loading": "SYNCHRONIZING...",
      "offline": "CONNECTION LOST",
      "blocked": "ACCESS RESTRICTED",
      "low_signal": "LOW SIGNAL",
      "image_error": "Unable to load scene image.",
      "image_loading": "Loading scene image...",
      "image_generating": "Generating new scene...",
      "initial_sync": "Awaiting global data synchronization...",
      "syncing": "Synchronizing data...",
      "alt": "Scene Image"
    },
    "processing": {
      "processing": "Generating scene...",
      "image_pending": "Forming image...",
      "rendering": "Applying results..."
    },
    "analyzing": {
      "message": "ANALYZING SCENE...",
      "hint": "Scanning for objects"
    },
    "hotspot": {
      "layer_label": "Clickable Objects Area",
      "hint_prefix": "Hint",
      "click_action": "Click {{label}}",
      "drop_hint": "Drop here to use",
      "drop_action": "Use {{item}} on {{target}}",
      "drop_invalid": "You cannot use {{item}} there.",
      "demo_hint": "[DEMO TARGET]"
    }
  },
  "agent": {
    "console": {
      "queue": "Queue",
      "badges": "Badges",
      "repair": "Auto-repair",
      "status": {
        "idle": "IDLE",
        "processing": "PROCESSING"
      },
      "badges_empty": "[ Awaiting Validation ]",
      "repaired": "(Repaired)",
      "phase": {
        "parse": "Parse",
        "validate": "Validate",
        "plan": "Plan",
        "resolve": "Resolve",
        "render": "Render",
        "verify": "Verify",
        "commit": "Commit"
      },
      "badge": {
        "schema": "Schema",
        "economy": "Economy",
        "safety": "Safety",
        "consistency": "Consistency",
        "ok": "OK",
        "fail": "FAIL"
      },
      "model": {
        "fast": "Fast (FAST)",
        "quality": "Quality (QUALITY)",
        "cheap": "Cheap",
        "ref": "Reference"
      },
      "expand": "Details",
      "collapse": "Collapse"
    }
  },
  "ui": {
    "logo": "UNKNOWN WORLD",
    "command_placeholder": "Enter command...",
    "processing": "Processing...",
    "execute": "EXECUTE",
    "wait": "WAIT",
    "panel_placeholder": "[ Ready ]",
    "scale_decrease": "Decrease text size",
    "scale_increase": "Increase text size",
    "scale_label": "UI Scale Settings"
  },
  "economy": {
    "signal": "Signal",
    "shard": "Shard",
    "signal_cost": "Signal cost",
    "shard_cost": "Shard cost",
    "risk_level": "Risk level",
    "hud_label": "Economy Status",
    "estimated_cost": "Est. Cost",
    "confirmed_cost": "Confirmed",
    "insufficient_funds": "Insufficient funds",
    "low_balance_warning": "Low balance",
    "low_balance_title": "Low Signal - Alternatives",
    "credit": "Credit",
    "credit_desc": "Current credit (debt) being used. Will be repaid first when earning currency.",
    "fast_fallback_notice": "Images will be generated in basic quality (FAST) for free",
    "hint_sell_items": "Sell inventory items to earn Signal",
    "hint_earn_actions": "Select currency earning cards (\u26A1)",
    "hint_complete_quests": "Complete objectives to earn rewards",
    "alternatives_title": "Alternatives",
    "alternative_text_only": "Text-only (no images)",
    "alternative_low_quality": "Low quality / Fast response",
    "ledger_title": "Resource Log",
    "ledger_empty": "[ NO HISTORY ]",
    "model_label": {
      "FAST": "Fast",
      "QUALITY": "Quality",
      "CHEAP": "Cheap",
      "REF": "Ref"
    }
  },
  "connection": {
    "online": "ONLINE",
    "offline": "OFFLINE"
  },
  "inventory": {
    "empty": "[ NO ITEMS ]",
    "empty_hint": "Explore scenes to find items",
    "count": "Inventory ({{count}})",
    "grid_label": "Inventory Items",
    "list_label": "Inventory Items",
    "item_label": "{{name}} (Qty: {{quantity}})",
    "drag_hint": "Drag to use",
    "item_consumed": "{{name}} consumed",
    "sell_tooltip": "Sell (+{{price}} Signal)",
    "sell_aria": "Sell {{item}} (+{{price}} Signal)",
    "sell_narrative": "\uD83D\uDCB0 Sold {{item}} and earned {{signal}} Signal.",
    "sell_toast": "Sold {{item}}!",
    "sell_ledger_reason": "Item sold"
  },
  "interaction": {
    "hotspot_click": "Click to investigate",
    "item_drag": "Drag to use",
    "drop_here": "Drop here",
    "onboarding_title": "Controls Guide",
    "onboarding_hotspot": "Click the highlighted areas on the scene to investigate them",
    "onboarding_item": "Drag inventory items onto scene objects to use them",
    "onboarding_scanner": "Upload images to the Scanner to convert them into items",
    "onboarding_skip": "Skip",
    "onboarding_start": "Start"
  },
  "common": {
    "next": "Next"
  },
  "panel": {
    "inventory": {
      "title": "Inventory",
      "placeholder": "[ Drag & Drop Area ]"
    },
    "quest": {
      "title": "Quest",
      "placeholder": "[ Objectives / Quest List ]"
    },
    "rule_board": {
      "title": "Rule Board",
      "placeholder": "[ World Rules / Mutation Timeline ]"
    },
    "agent_console": {
      "title": "Agent Console"
    },
    "memory_pin": {
      "title": "Memory Pin",
      "placeholder": "[ Pinned Memories / Clues ]"
    },
    "scanner": {
      "title": "Scanner",
      "placeholder": "[ Image Upload Slot ]"
    }
  },
  "scanner": {
    "dropzone_label": "Drop image or click to upload",
    "dropzone_text": "Drop Image Here",
    "dropzone_hint": "Or click to browse files",
    "upload_label": "Upload image",
    "preview_alt": "Upload image preview",
    "uploading": "Uploading...",
    "analyzing": "Analyzing...",
    "retry": "Retry",
    "cancel": "Cancel",
    "select_items": "Select items to add to inventory",
    "add_to_inventory": "Add ({{count}})",
    "detected_objects": "Objects detected: {{count}}",
    "item_candidates": "Item candidates: {{count}}",
    "no_candidates": "No item candidates found",
    "discovery_message": {
      "one": "You found an item!",
      "two": "You found two items!",
      "three": "You found three items! What an amazing discovery!"
    },
    "error": {
      "unsupported_format": "Unsupported image format",
      "file_too_large": "File too large (max 20MB)",
      "unknown": "An unknown error occurred"
    },
    "item_type": {
      "key": "Key",
      "weapon": "Weapon",
      "tool": "Tool",
      "clue": "Clue",
      "material": "Material",
      "consumable": "Consumable",
      "document": "Document",
      "artifact": "Artifact"
    },
    "tooltip": {
      "title": "Scanner",
      "description": "Upload a real-world photo to transform it into in-game items or clues"
    },
    "onboarding": {
      "message": "Try dragging an image here!",
      "detail": "Real photos become in-game items",
      "dismiss": "Got it"
    },
    "affordance": {
      "idle_hint": "Image â†’ Item",
      "drag_active": "Drop here!"
    }
  },
  "action": {
    "default": {
      "explore": {
        "label": "Explore",
        "description": "Look around"
      },
      "investigate": {
        "label": "Investigate",
        "description": "Examine closely"
      },
      "talk": {
        "label": "Talk",
        "description": "Start a conversation"
      }
    },
    "card_select": "Card selected: {{cardId}}",
    "deck_label": "Action Cards",
    "alternative": "ALT",
    "insufficient_balance": "Insufficient balance",
    "server_disabled": "Unavailable",
    "vision_badge": "VISION",
    "earn_badge": "Earn Signal",
    "all_disabled_notice": "No actions available. Check alternatives.",
    "risk": {
      "low": "Low",
      "medium": "Med",
      "high": "High"
    },
    "cost_range": "{{min}}~{{max}}"
  },
  "narrative": {
    "welcome": "Welcome to the Unknown World...",
    "turn_label": "[TURN {{turn}}]",
    "streaming_label": "[STREAMING]",
    "fast_forward_title": "Click to fast-forward",
    "fast_forward_aria": "Click or press Enter/Space to display text instantly"
  },
  "action_log": {
    "use_item_on_hotspot": "Action: Use {{item}} on {{hotspot}}",
    "click_hotspot": "Action: Examine {{hotspot}}",
    "click_action": "Action: {{action}}"
  }
}
</file>

<file path="frontend/src/locales/ko-KR/translation.json">
{
  "language": {
    "toggle": "ì–¸ì–´ ë³€ê²½",
    "toggle_tooltip": "í´ë¦­í•˜ì—¬ ì–¸ì–´ë¥¼ ë³€ê²½í•©ë‹ˆë‹¤. ë³€ê²½ í›„ ìƒˆ ê²Œì„ì´ ì‹œì‘ë©ë‹ˆë‹¤.",
    "ko-KR": "í•œêµ­ì–´",
    "en-US": "English"
  },
  "error": {
    "unknown_error": "ì•Œ ìˆ˜ ì—†ëŠ” ì˜¤ë¥˜ê°€ ë°œìƒí–ˆìŠµë‹ˆë‹¤.",
    "response_processing": "[ì‹œìŠ¤í…œ] ì‘ë‹µ ë°ì´í„°ë¥¼ ì²˜ë¦¬í•˜ëŠ” ì¤‘ ë¬¸ì œê°€ ë°œìƒí–ˆìŠµë‹ˆë‹¤.",
    "connection_failed": "[ì‹œìŠ¤í…œ] ì„œë²„ ì—°ê²°ì— ì‹¤íŒ¨í–ˆìŠµë‹ˆë‹¤. ë‹¤ì‹œ ì‹œë„í•´ ì£¼ì„¸ìš”."
  },
  "profile": {
    "select_title": "í”„ë¡œí•„ì„ ì„ íƒí•˜ì„¸ìš”",
    "select_hint": "í”„ë¡œí•„ë§ˆë‹¤ ë‹¤ë¥¸ ì‹œì‘ ì¡°ê±´ê³¼ ëª©í‘œê°€ ìˆìŠµë‹ˆë‹¤",
    "or": "ë˜ëŠ”",
    "continue_saved": "ì €ì¥ëœ ê²Œì„ ê³„ì†í•˜ê¸°",
    "change": "í”„ë¡œí•„ ë³€ê²½",
    "change_tooltip": "ë‹¤ë¥¸ í”„ë¡œí•„ë¡œ ìƒˆ ê²Œì„ ì‹œì‘",
    "narrator": {
      "name": "ì„œì‚¬ê¾¼",
      "description": "í’ë¶€í•œ ìì›ìœ¼ë¡œ ë‹¤ì–‘í•œ ì´ì•¼ê¸°ë¥¼ íƒí—˜í•˜ì„¸ìš”",
      "welcome": "ê³ ëŒ€ì˜ ë„ì„œê´€ì— ì˜¤ì‹  ê²ƒì„ í™˜ì˜í•©ë‹ˆë‹¤. ì´ê³³ì—ëŠ” ìŠí˜€ì§„ ì´ì•¼ê¸°ë“¤ì´ ì ë“¤ì–´ ìˆìŠµë‹ˆë‹¤...",
      "items": {
        "ancient_tome": "ê³ ëŒ€ ì„œì±…",
        "quill_pen": "ê¹ƒíœ",
        "memory_fragment": "ê¸°ì–µ ì¡°ê°"
      },
      "quest": {
        "discover_origin": "ì„¸ê³„ì˜ ê¸°ì›ì„ ë°œê²¬í•˜ê¸°",
        "discover_origin_desc": "ì´ ì„¸ê³„ê°€ ì–´ë–»ê²Œ ë§Œë“¤ì–´ì¡ŒëŠ”ì§€ ë‹¨ì„œë¥¼ ì°¾ì•„ ë°í˜€ë‚´ì„¸ìš”",
        "collect_memories": "ê¸°ì–µ ì¡°ê° 3ê°œ ìˆ˜ì§‘í•˜ê¸°",
        "read_ancient_tome": "ê³ ëŒ€ ì„œì±…ì„ í•´ë…í•˜ê¸°"
      },
      "rule": {
        "time_flows": "ì‹œê°„ì˜ íë¦„",
        "time_flows_desc": "ì‹œê°„ì€ ì •ìƒì ìœ¼ë¡œ íë¦…ë‹ˆë‹¤",
        "memories_persist": "ê¸°ì–µì˜ ì§€ì†",
        "memories_persist_desc": "í•œë²ˆ ì–»ì€ ê¸°ì–µì€ ì‚¬ë¼ì§€ì§€ ì•ŠìŠµë‹ˆë‹¤"
      },
      "scene": {
        "bookshelf": "ì‹ ë¹„í•œ ì±…ì¥",
        "bookshelf_hint": "ì˜¤ë˜ëœ ì±…ë“¤ì´ ë¹›ë‚˜ê³  ìˆë‹¤",
        "portal": "ë¹›ë‚˜ëŠ” í¬íƒˆ",
        "portal_hint": "ì–´ë”˜ê°€ë¡œ í†µí•˜ëŠ” ê²ƒ ê°™ë‹¤"
      }
    },
    "explorer": {
      "name": "íƒí—˜ê°€",
      "description": "ë¯¸ì§€ì˜ ì˜ì—­ì„ íƒí—˜í•˜ê³  ë¹„ë°€ì„ ë°œê²¬í•˜ì„¸ìš”",
      "welcome": "ì–´ë‘ìš´ ë¯¸ë¡œì—ì„œ ëˆˆì„ ë–´ìŠµë‹ˆë‹¤. ì¶œêµ¬ë¥¼ ì°¾ì•„ ì´ê³³ì„ íƒˆì¶œí•´ì•¼ í•©ë‹ˆë‹¤...",
      "items": {
        "compass": "ë‚˜ì¹¨ë°˜",
        "rope": "ë°§ì¤„",
        "lantern": "ëœí„´",
        "map_fragment": "ì§€ë„ ì¡°ê°"
      },
      "quest": {
        "find_exit": "íƒˆì¶œêµ¬ ì°¾ê¸°",
        "find_exit_desc": "ë¯¸ë¡œë¥¼ íƒí—˜í•˜ê³  ìˆ¨ê²¨ì§„ ì¶œêµ¬ë¥¼ ì°¾ì•„ íƒˆì¶œí•˜ì„¸ìš”",
        "explore_areas": "3ê°œ êµ¬ì—­ íƒí—˜í•˜ê¸°",
        "gather_supplies": "ë³´ê¸‰í’ˆ ìˆ˜ì§‘"
      },
      "rule": {
        "gravity": "ì¤‘ë ¥ ë²•ì¹™",
        "gravity_desc": "ë¬¼ì²´ëŠ” ì•„ë˜ë¡œ ë–¨ì–´ì§‘ë‹ˆë‹¤",
        "darkness": "ì–´ë‘ ì˜ ë²•ì¹™",
        "darkness_desc": "ë¹› ì—†ì´ëŠ” ì•ì„ ë³¼ ìˆ˜ ì—†ìŠµë‹ˆë‹¤"
      },
      "scene": {
        "door": "ê³ ëŒ€ì˜ ë¬¸",
        "door_hint": "ì—´ì‡ ê°€ í•„ìš”í•´ ë³´ì¸ë‹¤",
        "mechanism": "ì´ìƒí•œ ì¥ì¹˜",
        "mechanism_hint": "ì‘ë™ì‹œí‚¬ ìˆ˜ ìˆì„ ê²ƒ ê°™ë‹¤",
        "passage": "ìˆ¨ê²¨ì§„ í†µë¡œ",
        "passage_hint": "ì–´ë””ë¡œ ì´ì–´ì§ˆê¹Œ?"
      }
    },
    "tech": {
      "name": "ê¸°ìˆ  ì „ë¬¸ê°€",
      "description": "ì œí•œëœ ìì›ìœ¼ë¡œ íš¨ìœ¨ì ì¸ ì „ëµì„ ì„¸ìš°ì„¸ìš”",
      "welcome": "ì‹œìŠ¤í…œ ë¶€íŒ… ì™„ë£Œ. ì œí•œëœ ì—ë„ˆì§€ë¡œ ìµœì ì˜ ê²½ë¡œë¥¼ ì°¾ì•„ì•¼ í•©ë‹ˆë‹¤...",
      "items": {
        "data_core": "ë°ì´í„° ì½”ì–´",
        "circuit_board": "íšŒë¡œ ê¸°íŒ",
        "energy_cell": "ì—ë„ˆì§€ ì…€",
        "scanner": "ìŠ¤ìºë„ˆ ì¥ì¹˜"
      },
      "quest": {
        "analyze_system": "ì‹œìŠ¤í…œ ë¶„ì„ ì™„ë£Œí•˜ê¸°",
        "analyze_system_desc": "í•µì‹¬ í„°ë¯¸ë„ì— ì ‘ê·¼í•˜ì—¬ ì‹œìŠ¤í…œì˜ êµ¬ì¡°ë¥¼ íŒŒì•…í•˜ì„¸ìš”",
        "optimize_resources": "ìì› íš¨ìœ¨ ìµœì í™”í•˜ê¸°",
        "scan_terminal": "í„°ë¯¸ë„ ìŠ¤ìº” ìˆ˜í–‰í•˜ê¸°"
      },
      "rule": {
        "energy_conservation": "ì—ë„ˆì§€ ë³´ì¡´",
        "energy_conservation_desc": "ì—ë„ˆì§€ëŠ” ìƒì„±ë˜ê±°ë‚˜ ì†Œë©¸ë˜ì§€ ì•ŠìŠµë‹ˆë‹¤",
        "data_integrity": "ë°ì´í„° ë¬´ê²°ì„±",
        "data_integrity_desc": "ì†ìƒëœ ë°ì´í„°ëŠ” ë³µêµ¬í•  ìˆ˜ ì—†ìŠµë‹ˆë‹¤",
        "system_limits": "ì‹œìŠ¤í…œ í•œê³„",
        "system_limits_desc": "ë™ì‹œ ì²˜ë¦¬ëŸ‰ì— ì œí•œì´ ìˆìŠµë‹ˆë‹¤"
      },
      "scene": {
        "terminal": "ë©”ì¸ í„°ë¯¸ë„",
        "terminal_hint": "ì‹œìŠ¤í…œì— ì ‘ì†í•  ìˆ˜ ìˆë‹¤",
        "conduit": "ì „ë ¥ ë„ê´€",
        "conduit_hint": "ì—ë„ˆì§€ê°€ íë¥´ê³  ìˆë‹¤"
      }
    }
  },
  "reset": {
    "button": "ë¦¬ì…‹",
    "confirm": "ë‹¤ì‹œ í´ë¦­í•˜ì—¬ í™•ì¸",
    "cancel": "ì·¨ì†Œ",
    "tooltip": "í˜„ì¬ í”„ë¡œí•„ì˜ ì´ˆê¸° ìƒíƒœë¡œ ë˜ëŒë¦½ë‹ˆë‹¤"
  },
  "demo": {
    "items": {
      "keycard-alpha": {
        "name": "í‚¤ì¹´ë“œ A"
      },
      "medkit": {
        "name": "ì‘ê¸‰ í‚¤íŠ¸"
      },
      "flashlight": {
        "name": "ì†ì „ë“±"
      },
      "data-chip": {
        "name": "ë°ì´í„°ì¹©"
      }
    },
    "scene": {
      "terminal": {
        "label": "í„°ë¯¸ë„",
        "hint": "í™œì„±í™”ëœ í„°ë¯¸ë„ì´ë‹¤"
      },
      "door": {
        "label": "ë¬¸",
        "hint": "ì ê²¨ìˆëŠ” ê²ƒ ê°™ë‹¤"
      }
    },
    "quest": {
      "terminal": {
        "label": "í„°ë¯¸ë„ì— ì ‘ì†í•˜ê¸°"
      },
      "escape": {
        "label": "ì‹œì„¤ íƒˆì¶œêµ¬ ì°¾ê¸°"
      },
      "collect": {
        "label": "ë°ì´í„°ì¹© ìˆ˜ì§‘"
      }
    },
    "rule": {
      "gravity": {
        "label": "ì¤‘ë ¥ ë²•ì¹™",
        "description": "ë¬¼ì²´ëŠ” ì•„ë˜ë¡œ ë–¨ì–´ì§„ë‹¤"
      },
      "time": {
        "label": "ì‹œê°„ íë¦„",
        "description": "ì‹œê°„ì€ ì •ìƒ ì†ë„ë¡œ íë¥¸ë‹¤"
      }
    }
  },
  "quest": {
    "empty": "[ ëª©í‘œ ì—†ìŒ ]",
    "completed": "ì™„ë£Œ",
    "section": {
      "active": "ì§„í–‰ ì¤‘",
      "completed": "ì™„ë£Œë¨"
    },
    "main_objective": "ì£¼ ëª©í‘œ",
    "sub_objectives": "ì„¸ë¶€ ëª©í‘œ",
    "progress": "ì§„í–‰ë¥  {{progress}}%",
    "reward_preview": "ë³´ìƒ: {{signal}} Signal",
    "reward_earned": "+{{signal}} Signal íšë“!",
    "objective_complete": "ëª©í‘œ ë‹¬ì„±!",
    "free_exploration": "ììœ  íƒìƒ‰ ì¤‘",
    "free_exploration_desc": "ì •í•´ì§„ ëª©í‘œ ì—†ì´ ì„¸ê³„ë¥¼ ììœ ë¡­ê²Œ íƒí—˜í•˜ì„¸ìš”",
    "no_sub_objectives": "ì„¸ë¶€ ëª©í‘œê°€ ì•„ì§ ì—†ìŠµë‹ˆë‹¤",
    "tracker_no_objective": "ëª©í‘œ ì—†ìŒ"
  },
  "rule_board": {
    "empty": "[ ê·œì¹™ ì—†ìŒ ]",
    "active_count": "í™œì„± ê·œì¹™: {{count}}ê°œ"
  },
  "mutation": {
    "empty": "[ ë³€í˜• ì´ë ¥ ì—†ìŒ ]",
    "timeline_title": "ë³€í˜• íƒ€ì„ë¼ì¸",
    "event_count": "{{count}}ê°œ ì´ë²¤íŠ¸",
    "more_events": "+{{count}}ê°œ ë” ë³´ê¸°",
    "turn_label": "T{{turn}}",
    "type": {
      "added": "ì¶”ê°€ë¨",
      "modified": "ìˆ˜ì •ë¨",
      "removed": "ì œê±°ë¨"
    }
  },
  "scene": {
    "status": {
      "default": "ë°ì´í„° ëŒ€ê¸° ì¤‘",
      "loading": "ë™ê¸°í™” ì¤‘...",
      "offline": "ì—°ê²° ëŠê¹€",
      "blocked": "ì ‘ê·¼ ì œí•œë¨",
      "low_signal": "ì‹ í˜¸ ì•½í•¨",
      "image_error": "ì¥ë©´ ì´ë¯¸ì§€ë¥¼ ë¶ˆëŸ¬ì˜¬ ìˆ˜ ì—†ìŠµë‹ˆë‹¤.",
      "image_loading": "ì¥ë©´ ì´ë¯¸ì§€ ë¡œë”© ì¤‘...",
      "image_generating": "ìƒˆ ì¥ë©´ ìƒì„± ì¤‘...",
      "initial_sync": "ì „ì—­ ë°ì´í„° ë™ê¸°í™” ëŒ€ê¸° ì¤‘...",
      "syncing": "ë°ì´í„° ë™ê¸°í™” ì¤‘...",
      "alt": "ì¥ë©´ ì´ë¯¸ì§€"
    },
    "processing": {
      "processing": "ì¥ë©´ ìƒì„± ì¤‘...",
      "image_pending": "ì´ë¯¸ì§€ í˜•ì„± ì¤‘...",
      "rendering": "ê²°ê³¼ ì ìš© ì¤‘..."
    },
    "analyzing": {
      "message": "ì¥ë©´ ë¶„ì„ ì¤‘...",
      "hint": "ì˜¤ë¸Œì íŠ¸ë¥¼ íƒìƒ‰í•˜ê³  ìˆìŠµë‹ˆë‹¤"
    },
    "hotspot": {
      "layer_label": "í´ë¦­ ê°€ëŠ¥í•œ ì˜¤ë¸Œì íŠ¸ ì˜ì—­",
      "hint_prefix": "íŒíŠ¸",
      "click_action": "{{label}} í´ë¦­",
      "drop_hint": "ì—¬ê¸°ì— ë“œë¡­í•˜ì—¬ ì‚¬ìš©",
      "drop_action": "{{item}}ì„(ë¥¼) {{target}}ì— ì‚¬ìš©",
      "drop_invalid": "ê·¸ê³³ì—ëŠ” {{item}}ì„(ë¥¼) ì‚¬ìš©í•  ìˆ˜ ì—†ìŠµë‹ˆë‹¤.",
      "demo_hint": "[ë°ëª¨ ëŒ€ìƒ]"
    }
  },
  "agent": {
    "console": {
      "queue": "ëŒ€ê¸°ì—´",
      "badges": "ê²€ì¦ ë°°ì§€",
      "repair": "ìë™ ë³µêµ¬",
      "status": {
        "idle": "ëŒ€ê¸° ì¤‘",
        "processing": "ì²˜ë¦¬ ì¤‘"
      },
      "badges_empty": "[ ê²€ì¦ ëŒ€ê¸° ì¤‘ ]",
      "repaired": "(ë³µêµ¬ë¨)",
      "phase": {
        "parse": "Parse",
        "validate": "Validate",
        "plan": "Plan",
        "resolve": "Resolve",
        "render": "Render",
        "verify": "Verify",
        "commit": "Commit"
      },
      "badge": {
        "schema": "Schema",
        "economy": "Economy",
        "safety": "Safety",
        "consistency": "Consistency",
        "ok": "OK",
        "fail": "FAIL"
      },
      "model": {
        "fast": "ë¹ ë¦„ (FAST)",
        "quality": "ê³ í’ˆì§ˆ (QUALITY)",
        "cheap": "ì €ë¹„ìš©",
        "ref": "ì°¸ì¡°"
      },
      "expand": "ìƒì„¸ ë³´ê¸°",
      "collapse": "ì ‘ê¸°"
    }
  },
  "ui": {
    "logo": "UNKNOWN WORLD",
    "command_placeholder": "ëª…ë ¹ì„ ì…ë ¥í•˜ì„¸ìš”...",
    "processing": "ì²˜ë¦¬ ì¤‘...",
    "execute": "ì‹¤í–‰",
    "wait": "ëŒ€ê¸°",
    "panel_placeholder": "[ ì¤€ë¹„ ì¤‘ ]",
    "scale_decrease": "ê¸€ì í¬ê¸° ì¤„ì´ê¸°",
    "scale_increase": "ê¸€ì í¬ê¸° ëŠ˜ë¦¬ê¸°",
    "scale_label": "UI ìŠ¤ì¼€ì¼ ì„¤ì •"
  },
  "economy": {
    "signal": "Signal",
    "shard": "Shard",
    "signal_cost": "Signal ì†Œëª¨",
    "shard_cost": "Shard ì†Œëª¨",
    "risk_level": "ìœ„í—˜ë„",
    "hud_label": "ì¬í™” í˜„í™©",
    "estimated_cost": "ì˜ˆìƒ ë¹„ìš©",
    "confirmed_cost": "í™•ì • ë¹„ìš©",
    "insufficient_funds": "ì”ì•¡ ë¶€ì¡±",
    "low_balance_warning": "ì”ì•¡ì´ ë¶€ì¡±í•©ë‹ˆë‹¤",
    "low_balance_title": "Signal ë¶€ì¡± - ëŒ€ì•ˆ ì•ˆë‚´",
    "credit": "í¬ë ˆë”§",
    "credit_desc": "í˜„ì¬ ì‚¬ìš© ì¤‘ì¸ í¬ë ˆë”§(ë¶€ì±„)ì…ë‹ˆë‹¤. ì¬í™” íšë“ ì‹œ ìš°ì„  ìƒí™˜ë©ë‹ˆë‹¤.",
    "fast_fallback_notice": "ì´ë¯¸ì§€ëŠ” ê¸°ë³¸ í’ˆì§ˆ(FAST)ë¡œ ë¬´ë£Œ ìƒì„±ë©ë‹ˆë‹¤",
    "hint_sell_items": "ì¸ë²¤í† ë¦¬ ì•„ì´í…œì„ íŒë§¤í•˜ì—¬ Signalì„ íšë“í•˜ì„¸ìš”",
    "hint_earn_actions": "ì¬í™” íšë“ ì¹´ë“œ(âš¡)ë¥¼ ì„ íƒí•˜ì„¸ìš”",
    "hint_complete_quests": "ëª©í‘œë¥¼ ë‹¬ì„±í•˜ì—¬ ë³´ìƒì„ ë°›ìœ¼ì„¸ìš”",
    "alternatives_title": "ëŒ€ì•ˆ í–‰ë™",
    "alternative_text_only": "í…ìŠ¤íŠ¸ë§Œ ìƒì„± (ì´ë¯¸ì§€ ì—†ìŒ)",
    "alternative_low_quality": "ì €í’ˆì§ˆ/ë¹ ë¥¸ ì‘ë‹µ ì„ íƒ",
    "ledger_title": "ê±°ë˜ ì¥ë¶€",
    "ledger_empty": "[ ì´ë ¥ ì—†ìŒ ]",
    "model_label": {
      "FAST": "ë¹ ë¦„",
      "QUALITY": "ê³ í’ˆì§ˆ",
      "CHEAP": "ì €ë¹„ìš©",
      "REF": "ì°¸ì¡°"
    }
  },
  "connection": {
    "online": "ì˜¨ë¼ì¸",
    "offline": "ì˜¤í”„ë¼ì¸"
  },
  "inventory": {
    "empty": "[ ì•„ì´í…œ ì—†ìŒ ]",
    "empty_hint": "ì¥ë©´ì„ íƒìƒ‰í•˜ì—¬ ì•„ì´í…œì„ ì°¾ìœ¼ì„¸ìš”",
    "count": "Inventory ({{count}})",
    "grid_label": "ì¸ë²¤í† ë¦¬ ì•„ì´í…œ ëª©ë¡",
    "list_label": "ì¸ë²¤í† ë¦¬ ì•„ì´í…œ ëª©ë¡",
    "item_label": "{{name}} (ìˆ˜ëŸ‰: {{quantity}})",
    "drag_hint": "ë“œë˜ê·¸í•˜ì—¬ ì‚¬ìš©",
    "item_consumed": "{{name}} ì‚¬ìš©ë¨",
    "sell_tooltip": "íŒë§¤ (+{{price}} Signal)",
    "sell_aria": "{{item}} íŒë§¤ (+{{price}} Signal)",
    "sell_narrative": "ğŸ’° {{item}}ì„(ë¥¼) íŒë§¤í•˜ì—¬ {{signal}} Signalì„ íšë“í–ˆìŠµë‹ˆë‹¤.",
    "sell_toast": "{{item}} íŒë§¤ ì™„ë£Œ!",
    "sell_ledger_reason": "ì•„ì´í…œ íŒë§¤"
  },
  "interaction": {
    "hotspot_click": "í´ë¦­í•˜ì—¬ ì¡°ì‚¬",
    "item_drag": "ë“œë˜ê·¸í•˜ì—¬ ì‚¬ìš©",
    "drop_here": "ì—¬ê¸°ì— ë†“ê¸°",
    "onboarding_title": "ì¡°ì‘ ì•ˆë‚´",
    "onboarding_hotspot": "í™”ë©´ì˜ ë°˜ì§ì´ëŠ” ì˜ì—­ì„ í´ë¦­í•˜ë©´ ì¡°ì‚¬í•  ìˆ˜ ìˆìŠµë‹ˆë‹¤",
    "onboarding_item": "ì¸ë²¤í† ë¦¬ ì•„ì´í…œì„ í™”ë©´ì˜ ì˜¤ë¸Œì íŠ¸ë¡œ ë“œë˜ê·¸í•˜ë©´ ì‚¬ìš©í•  ìˆ˜ ìˆìŠµë‹ˆë‹¤",
    "onboarding_scanner": "Scannerì— ì´ë¯¸ì§€ë¥¼ ì—…ë¡œë“œí•˜ë©´ ì•„ì´í…œìœ¼ë¡œ ë³€í™˜ë©ë‹ˆë‹¤",
    "onboarding_skip": "ê±´ë„ˆë›°ê¸°",
    "onboarding_start": "ì‹œì‘í•˜ê¸°"
  },
  "common": {
    "next": "ë‹¤ìŒ"
  },
  "panel": {
    "inventory": {
      "title": "Inventory",
      "placeholder": "[ ë“œë˜ê·¸ ì•¤ ë“œë¡­ ì˜ì—­ ]"
    },
    "quest": {
      "title": "Quest",
      "placeholder": "[ ëª©í‘œ/í€˜ìŠ¤íŠ¸ ëª©ë¡ ]"
    },
    "rule_board": {
      "title": "Rule Board",
      "placeholder": "[ ì›”ë“œ ê·œì¹™/ë³€í˜• íƒ€ì„ë¼ì¸ ]"
    },
    "agent_console": {
      "title": "Agent Console"
    },
    "memory_pin": {
      "title": "Memory Pin",
      "placeholder": "[ ê³ ì •ëœ ê¸°ì–µ/ë‹¨ì„œ ]"
    },
    "scanner": {
      "title": "Scanner",
      "placeholder": "[ ì´ë¯¸ì§€ ì—…ë¡œë“œ ìŠ¬ë¡¯ ]"
    }
  },
  "scanner": {
    "dropzone_label": "ì´ë¯¸ì§€ë¥¼ ë“œë¡­í•˜ê±°ë‚˜ í´ë¦­í•˜ì—¬ ì—…ë¡œë“œ",
    "dropzone_text": "ì´ë¯¸ì§€ë¥¼ ë“œë¡­í•˜ì„¸ìš”",
    "dropzone_hint": "ë˜ëŠ” í´ë¦­í•˜ì—¬ íŒŒì¼ ì„ íƒ",
    "upload_label": "ì´ë¯¸ì§€ ì—…ë¡œë“œ",
    "preview_alt": "ì—…ë¡œë“œ ì´ë¯¸ì§€ ë¯¸ë¦¬ë³´ê¸°",
    "uploading": "ì—…ë¡œë“œ ì¤‘...",
    "analyzing": "ë¶„ì„ ì¤‘...",
    "retry": "ë‹¤ì‹œ ì‹œë„",
    "cancel": "ì·¨ì†Œ",
    "select_items": "ì¸ë²¤í† ë¦¬ì— ì¶”ê°€í•  ì•„ì´í…œì„ ì„ íƒí•˜ì„¸ìš”",
    "add_to_inventory": "ì¶”ê°€ ({{count}}ê°œ)",
    "detected_objects": "ê°ì§€ëœ ì˜¤ë¸Œì íŠ¸: {{count}}ê°œ",
    "item_candidates": "ì•„ì´í…œ í›„ë³´: {{count}}ê°œ",
    "no_candidates": "ì•„ì´í…œ í›„ë³´ë¥¼ ì°¾ì§€ ëª»í–ˆìŠµë‹ˆë‹¤",
    "discovery_message": {
      "one": "ì•„ì´í…œì„ ë°œê²¬í–ˆìŠµë‹ˆë‹¤!",
      "two": "ë‘ ê°€ì§€ë¥¼ ë°œê²¬í–ˆìŠµë‹ˆë‹¤!",
      "three": "ì„¸ ê°€ì§€ë¥¼ ë°œê²¬í–ˆìŠµë‹ˆë‹¤! ëŒ€ë‹¨í•œ ë°œê²¬ì´ë„¤ìš”!"
    },
    "error": {
      "unsupported_format": "ì§€ì›í•˜ì§€ ì•ŠëŠ” ì´ë¯¸ì§€ í˜•ì‹ì…ë‹ˆë‹¤",
      "file_too_large": "íŒŒì¼ì´ ë„ˆë¬´ í½ë‹ˆë‹¤ (ìµœëŒ€ 20MB)",
      "unknown": "ì•Œ ìˆ˜ ì—†ëŠ” ì˜¤ë¥˜ê°€ ë°œìƒí–ˆìŠµë‹ˆë‹¤"
    },
    "item_type": {
      "key": "ì—´ì‡ ",
      "weapon": "ë¬´ê¸°",
      "tool": "ë„êµ¬",
      "clue": "ë‹¨ì„œ",
      "material": "ì¬ë£Œ",
      "consumable": "ì†Œëª¨í’ˆ",
      "document": "ë¬¸ì„œ",
      "artifact": "ìœ ë¬¼"
    },
    "tooltip": {
      "title": "ìŠ¤ìºë„ˆ",
      "description": "í˜„ì‹¤ì˜ ì‚¬ì§„ì„ ì—…ë¡œë“œí•˜ë©´ ê²Œì„ ì† ì•„ì´í…œì´ë‚˜ ë‹¨ì„œë¡œ ë³€í™˜ë©ë‹ˆë‹¤"
    },
    "onboarding": {
      "message": "ì´ë¯¸ì§€ë¥¼ ë“œë˜ê·¸í•´ ë³´ì„¸ìš”!",
      "detail": "í˜„ì‹¤ì˜ ì‚¬ì§„ì´ ê²Œì„ ì† ì•„ì´í…œìœ¼ë¡œ ë³€í™˜ë©ë‹ˆë‹¤",
      "dismiss": "ì•Œê² ìŠµë‹ˆë‹¤"
    },
    "affordance": {
      "idle_hint": "ì´ë¯¸ì§€ â†’ ì•„ì´í…œ",
      "drag_active": "ì—¬ê¸°ì— ë†“ìœ¼ì„¸ìš”!"
    }
  },
  "action": {
    "default": {
      "explore": {
        "label": "íƒìƒ‰í•˜ê¸°",
        "description": "ì£¼ë³€ì„ ì‚´í´ë³¸ë‹¤"
      },
      "investigate": {
        "label": "ì¡°ì‚¬í•˜ê¸°",
        "description": "ìì„¸íˆ ì‚´í´ë³¸ë‹¤"
      },
      "talk": {
        "label": "ëŒ€í™”í•˜ê¸°",
        "description": "ë§ì„ ê±¸ì–´ë³¸ë‹¤"
      }
    },
    "card_select": "ì¹´ë“œ ì„ íƒ: {{cardId}}",
    "deck_label": "í–‰ë™ ì„ íƒ ì¹´ë“œ",
    "alternative": "ëŒ€ì•ˆ",
    "insufficient_balance": "ì”ì•¡ ë¶€ì¡±",
    "server_disabled": "ì‚¬ìš© ë¶ˆê°€",
    "vision_badge": "ì •ë°€ë¶„ì„",
    "earn_badge": "Signal íšë“",
    "all_disabled_notice": "ì‹¤í–‰ ê°€ëŠ¥í•œ í–‰ë™ì´ ì—†ìŠµë‹ˆë‹¤. ëŒ€ì•ˆì„ í™•ì¸í•˜ì„¸ìš”.",
    "risk": {
      "low": "ë‚®ìŒ",
      "medium": "ë³´í†µ",
      "high": "ë†’ìŒ"
    },
    "cost_range": "{{min}}~{{max}}"
  },
  "narrative": {
    "welcome": "ë¯¸ì§€ì˜ ì„¸ê³„ì— ì˜¤ì‹  ê²ƒì„ í™˜ì˜í•©ë‹ˆë‹¤...",
    "turn_label": "[TURN {{turn}}]",
    "streaming_label": "[STREAMING]",
    "fast_forward_title": "í´ë¦­í•˜ì—¬ ë¹ ë¥´ê²Œ ë„˜ê¸°ê¸°",
    "fast_forward_aria": "í´ë¦­í•˜ê±°ë‚˜ Enter/Spaceë¥¼ ëˆŒëŸ¬ í…ìŠ¤íŠ¸ë¥¼ ì¦‰ì‹œ í‘œì‹œí•©ë‹ˆë‹¤"
  },
  "action_log": {
    "use_item_on_hotspot": "í–‰ë™ ì‹¤í–‰: {{item}}ì„(ë¥¼) {{hotspot}}ì— ì‚¬ìš©í•œë‹¤",
    "click_hotspot": "í–‰ë™ ì‹¤í–‰: {{hotspot}}ì„(ë¥¼) ì¡°ì‚¬í•œë‹¤",
    "click_action": "í–‰ë™ ì‹¤í–‰: {{action}}"
  }
}
</file>

</files>
