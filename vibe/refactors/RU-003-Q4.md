# [ID: RU-003-Q4] UI 상태 슬라이스/경계 재정의: App.tsx 로컬 상태 축소 + TurnOutput 반영 파이프라인 SSOT화

## 📌 기본 정보

| 항목               | 내용                     |
| ------------------ | ------------------------ |
| **ID**             | RU-003-Q4                |
| **심각도**         | High                     |
| **카테고리**       | 모듈 설계 (Module Design) |
| **영향 범위**      | `frontend/src/App.tsx`, `frontend/src/stores/agentStore.ts`, `frontend/src/stores/actionDeckStore.ts`, `frontend/src/stores/inventoryStore.ts`, (신규) `frontend/src/stores/worldStore.ts` |
| **예상 작업 시간** | 45~90분                  |

---

## 🔍 문제점 상세 분석

### 현재 상황

현재 프론트는 “게임 UI 고정” 요구사항(RULE-002)을 만족시키는 방향으로 빠르게 기능을 붙였지만, **상태 경계(react local state vs zustand store)와 TurnOutput 반영 경로가 App.tsx에 과도하게 집중**되어 있습니다.

- `frontend/src/App.tsx`에서 다음이 동시에 일어납니다:
  - **World/세션 상태**(경제, 씬 상태, 씬 오브젝트, 내러티브 히스토리) 관리  
    - 예: `economy`, `sceneState`, `sceneObjects`, `narrativeEntries` (`App.tsx` 256~318)
  - **TurnOutput 반영(reducer 역할)**: `applyTurnOutput`가 여러 상태/스토어를 업데이트 (`App.tsx` 344~375)
  - **Turn 실행(오케스트레이션)**: 입력 조합 + 스트리밍 시작 + 콜백 연결 (`App.tsx` 383~462)

즉, `App.tsx`가 “루트 레이아웃”을 넘어 **World/UI/Orchestration의 결합 지점**이 되어, RU-003의 목표(슬라이스/경계 정리)와 다음 확장(U-013~U-015: Quest/Rule/SaveGame/DemoProfile)이 들어올 때 유지보수 비용이 급증할 형태입니다.

### 문제가 되는 이유

1. **책임 경계 붕괴(확장 시 폭발 반경 증가)**  
   Quest/Rule/Memory Pin/Scanner까지 붙으면, TurnOutput 반영 로직이 `App.tsx`에 계속 누적되어 “한 파일이 시스템 전체를 흔드는” 구조가 됩니다.
2. **슬라이스는 늘었는데 SSOT가 없음**  
   `agentStore`/`actionDeckStore`/`inventoryStore`는 존재하지만, 정작 “세션 월드/UI 상태”는 `App.tsx`의 local state에 남아 있어 경계가 혼재됩니다.
3. **페어링 결정(Q1 Option A: 도메인별 store 분리)과의 불일치**  
   RU-003 계획서의 Q1 결정은 “도메인별 store 파일 분리”인데, 현 상태는 “도메인/세션 상태의 상당 부분이 App local state”로 남아 있어 결정의 이점을 살리기 어렵습니다.

### 영향받는 코드 위치

- `frontend/src/App.tsx`
  - local state: 253~318
  - TurnOutput 반영: 344~375
  - Turn 실행/콜백 결합: 383~462
- `frontend/src/stores/actionDeckStore.ts`: TurnOutput로부터 `setCards`를 받는 구조(현재 App에서 호출)
- `frontend/src/stores/inventoryStore.ts`: TurnOutput world delta를 반영(현재 App에서 `addItems/removeItems` 호출)

### 현재 코드 예시

```ts
// frontend/src/App.tsx (요약 발췌)
const applyTurnOutput = useCallback(
  (output: TurnOutput) => {
    turnCountRef.current += 1;
    const newTurn = turnCountRef.current;
    setNarrativeEntries((entries) => [...entries, { turn: newTurn, text: output.narrative }]);

    setActionCards(output.ui.action_deck.cards);
    setEconomy({
      signal: output.economy.balance_after.signal,
      memory_shard: output.economy.balance_after.memory_shard,
    });
    setSceneObjects(output.ui.objects);

    if (output.world.inventory_added.length > 0) {
      addInventoryItems(parseInventoryAdded(output.world.inventory_added));
    }
    if (output.world.inventory_removed.length > 0) {
      removeInventoryItems(output.world.inventory_removed);
    }
  },
  [setActionCards, addInventoryItems, removeInventoryItems],
);
```

---

## 💡 개선 방안

### 제안하는 접근법

**“World/UI 세션 상태”를 담당하는 `worldStore`를 신설**하고, TurnOutput 반영(`applyTurnOutput`)을 `worldStore`로 이동시켜 **SSOT를 App 밖으로 빼냅니다.**

권장 목표 상태(Option A 결정과 정합):

- `agentStore`: 스트리밍 단계/배지/내러티브 델타/복구 횟수(이미 구현됨)
- `worldStore`: TurnOutput 반영으로 갱신되는 세션 월드/UI 상태(경제, 씬, 오브젝트, 내러티브 히스토리 등)
- `uiPrefsStore`: UI 환경설정(스케일 등, 이미 구현됨)
- `actionDeckStore`/`inventoryStore`: “서브 도메인”으로 유지하되, TurnOutput 반영 트리거는 `worldStore`로 단일화

### 구체적 실행 단계

#### Step 1: `frontend/src/stores/worldStore.ts` 신설

권장 최소 상태(현 App local state 기준):

- `economy`: `{ signal, memory_shard }`
- `isConnected`: 연결 상태
- `sceneState`: `SceneCanvasState`
- `sceneObjects`: `SceneObject[]`
- `narrativeEntries`: `{ turn, text }[]`
- `turnCount`: number (현재 `turnCountRef` 역할)

권장 액션:

- `applyTurnOutput(output: TurnOutput): void`
- `appendSystemNarrative(text: string): void` (드롭 실패 등 “턴 미발생” 피드백)
- `setSceneState(...)`, `setConnected(boolean)` 등 최소 유틸

#### Step 2: TurnOutput 반영 경로를 `worldStore.applyTurnOutput`로 단일화

`worldStore.applyTurnOutput` 내부에서 “세션 상태 업데이트” + “하위 스토어 업데이트”를 한 번에 수행합니다.

권장(점진적, RU-003 범위 친화):

- `actionDeckStore.getState().setCards(output.ui.action_deck.cards)`
- `inventoryStore.getState().addItems(parseInventoryAdded(...))`
- `inventoryStore.getState().removeItems(...)`

> 주의: `worldStore`가 다른 store를 import 하므로 **순환 import**가 생기지 않게 “worldStore → (actionDeck/inventory)” 단방향만 허용합니다.

#### Step 3: App.tsx는 “레이아웃 + 이벤트 라우팅”에 집중

App에서 제거/축소할 것:

- `useState`로 들고 있던 `economy/isConnected/sceneState/sceneObjects/narrativeEntries` (worldStore로 이동)
- `applyTurnOutput` (worldStore로 이동)

App에 남길 것(권장):

- 입력 필드(`inputText`)처럼 “패널 내부/로컬 UI”에 가까운 상태
- `DndContext` 배치(전역 DnD 컨텍스트)와 이벤트 핸들러(단, 상태 업데이트는 store로 위임)

#### Step 4: “다음 확장”을 위한 슬롯 확보(Quest/Rule/Memory Pin)

`worldStore.applyTurnOutput`가 확장될 때, `TurnOutput.world`의 아래 필드를 **한 곳에서만 반영**하도록 규칙을 고정합니다.

- `world.rules_changed`
- `world.quests_updated`
- `world.memory_pins`

> RU-003에서 필드 반영까지 구현하지 않더라도, “어디에서 반영할지”를 `worldStore`로 고정하면 이후 유닛이 흔들리지 않습니다.

### 대안적 접근법 (선택사항)

- **대안 1(최소 변경)**: `applyTurnOutput`만 `frontend/src/turn/applyTurnOutput.ts`로 추출(스토어는 유지, App는 얇게)  
  - 장점: 가장 빠르게 App 복잡도 감소
  - 단점: “월드 상태가 store로 이동”하지 않아 RU-003 완료 기준(슬라이스/경계) 만족이 약해질 수 있음
- **대안 2(강경/장기)**: `actionDeckStore`/`inventoryStore`를 `worldStore` 내부 슬라이스로 통합(스토어 수 감소)  
  - 장점: TurnOutput 반영/상태 구독 경계가 가장 명확
  - 단점: 수정 범위 큼(기존 테스트/사용처 업데이트 부담)

---

## 📈 기대 효과

### 즉각적 효과

- ✅ `App.tsx`가 “레이아웃 + 이벤트 라우팅”으로 정리되어 확장 여유 확보
- ✅ TurnOutput 반영 경로가 단일화되어 중복/누락/드리프트 위험 감소
- ✅ RU-003 페어링 결정(Q1 Option A: 도메인별 store 분리)을 실제 구조로 반영

### 장기적 효과

- 🎯 Quest/Rule/Memory Pin/SaveGame 확장 시 “어디에 상태를 두고, 어디에서 반영하는지”가 흔들리지 않음
- 🎯 패널 컴포넌트가 필요한 selector만 구독하도록 정리하기 쉬워져 렌더 성능/디버깅 비용 개선

---

## ⚠️ 주의사항 및 고려사항

### 리팩토링 시 주의할 점

1. **Behavior Preservation 우선**: RU-003은 기능 추가가 아니라 경계/중복/복잡도 감소가 목적입니다.
2. **순환 import 방지**: `worldStore`는 “하위 도메인 store”를 import 할 수 있지만, 역방향은 금지합니다.
3. **i18n 혼합 출력 방지**: DEV 목 데이터(인벤토리/오브젝트 라벨)가 남아 있으면 언어 혼합이 생길 수 있으니, RU-003-Q5와 함께 처리하는 것이 안전합니다.

### 호환성 체크리스트

- [ ] TurnOutput 반영이 App에서 worldStore로 이동했지만, UI 결과가 동일한가?
- [ ] 스트리밍 중 인터랙션 차단(클릭/드래그/카드)이 동일하게 유지되는가?
- [ ] Economy 잔액이 음수가 되거나 갑자기 0으로 리셋되는 UI가 없는가?

---

## 🧪 검증 방법 (수동 검증 중심)

### 변경 후 검증 시나리오(핵심만)

1. **Action Deck 카드 클릭** → 스트리밍 시작 → `final` 수신 후 카드/재화/오브젝트/인벤토리 갱신
2. **Hotspot 클릭** → TurnInput(click) 전송 → `final` 후 씬 오브젝트 갱신
3. **Inventory 아이템 드롭**(핫스팟 성공/실패) → 성공 시 턴 실행 / 실패 시 즉시 피드백(무반응 금지)

> 상세 체크리스트는 `RU-003-S3`를 따릅니다.

---

## 🔧 실행 가이드

### 개발자를 위한 실행 지침

1. **준비 사항**
   - RU-003 계획서의 페어링 Q1 결정(Option A)을 기준으로 “worldStore 신설”을 우선 적용
2. **실행 절차**
   - `worldStore.ts` 생성 → App local state 단계적 이동 → `applyTurnOutput` 이동 → App은 selector 구독으로 전환
3. **검증 절차**
   - `RU-003-S3` 수동 시나리오 수행(카드/클릭/드롭/에러)
4. **롤백 계획**
   - `worldStore` 도입 커밋을 되돌리고, `applyTurnOutput`를 App으로 되돌려 즉시 복구

---

## 📚 참고 자료

- `vibe/unit-plans/RU-003[Mvp].md` (슬라이스/경계 목표 + Q1 결정)
- `frontend/src/App.tsx` (TurnOutput 반영 및 오케스트레이션 결합 지점)
- `.cursor/rules/10-frontend-game-ui.mdc` (UI 고정/게임 UI 규칙)

---

## 🏷️ 태그

`#refactoring` `#module-design` `#high` `#zustand` `#ui-boundary` `#turnoutput`

---

## 📝 노트

- 이 제안은 “스토어를 더 늘리는 것”이 목적이 아니라, **세션 월드/UI 상태의 SSOT를 App 밖으로 이동**시켜 이후 기능이 붙어도 경계가 무너지지 않게 만드는 것이 목적입니다.

