# [ID: RU-002-Q4] Turn Stream 이벤트 계약(타입/모델/유틸)의 모듈 경계 정리: Orchestrator ↔ API ↔ Frontend 분리 + (선택) Protocol 메타 이벤트

## 📌 기본 정보

| 항목               | 내용                     |
| ------------------ | ------------------------ |
| **ID**             | RU-002-Q4                |
| **심각도**         | High                     |
| **카테고리**       | 모듈 설계 (Module Design) |
| **영향 범위**      | `backend/src/unknown_world/api/turn.py`, `backend/src/unknown_world/orchestrator/mock.py`, (권장) `backend/src/unknown_world/api/turn_stream_events.py`, `frontend/src/api/turnStream.ts`, (권장) `frontend/src/types/turn_stream.ts`, `frontend/src/stores/agentStore.ts` |
| **예상 작업 시간** | 45~75분                  |

---

## 🔍 문제점 상세 분석

### 현재 상황

현재 스트리밍 이벤트 계약은 “동작은 맞지만”, **정의 위치와 책임 경계가 흐릿**합니다.

- 서버 이벤트 모델(`StageEvent`, `BadgesEvent`, `FinalEvent`, `ErrorEvent`)이 `orchestrator/mock.py`에 정의되어 있고(`backend/src/unknown_world/orchestrator/mock.py` 52~135), API 라우터가 이를 import 합니다(`backend/src/unknown_world/api/turn.py` 40~49).
- 프론트에서도 이벤트 타입 상수/인터페이스가 `api/turnStream.ts`에 직접 정의되어 있어(`frontend/src/api/turnStream.ts` 23~79), 계약 변경 시 drift 위험이 큽니다.
- stage 목록도 서버(`ORCHESTRATOR_PHASES`)와 클라(`DEFAULT_PHASES`)에 각각 존재합니다.

### 문제가 되는 이유

1. **계약/모델이 Orchestrator에 섞여 책임이 역전**: Orchestrator는 “TurnOutput 생성”이 핵심인데, transport(NDJSON) 이벤트까지 책임지며 결합도가 올라갑니다.  
2. **계약 drift가 구조적으로 쉬움**: 서버/클라에 동일 상수가 중복되어 있어, 작은 변경이 쉽게 불일치로 이어집니다(RU-002의 목적 정면 위배).  
3. **확장(실모델/repair) 시 비용 증가**: 이벤트가 늘어날수록 분산 정의는 수정 범위를 키워 “깨짐”을 유발합니다.

### 영향받는 코드 위치

- `backend/src/unknown_world/orchestrator/mock.py`: 52-135 (스트림 이벤트 모델이 Orchestrator에 존재)
- `backend/src/unknown_world/api/turn.py`: 40-49 (이벤트 모델 import), 57-77 (단계 상수 중복)
- `frontend/src/api/turnStream.ts`: 23-79 (이벤트 타입 중복), 180-226 (검증/디스패치가 혼재)
- `frontend/src/stores/agentStore.ts`: 90-99 (DEFAULT_PHASES 중복)

### 현재 코드 예시

```py
# backend/src/unknown_world/api/turn.py
from unknown_world.orchestrator.mock import (
    BadgesEvent,
    ErrorEvent,
    FinalEvent,
    NarrativeDeltaEvent,
    StageEvent,
    StageStatus,
    StreamEventType,
)
```

```ts
// frontend/src/api/turnStream.ts
export const StreamEventType = {
  STAGE: 'stage',
  BADGES: 'badges',
  NARRATIVE_DELTA: 'narrative_delta',
  FINAL: 'final',
  ERROR: 'error',
} as const;
```

---

## 💡 개선 방안

### 제안하는 접근법

**Turn Stream “계약(Contract)”을 transport 계층으로 분리**해 SSOT를 만들고, Orchestrator는 TurnOutput 생성에만 집중시키는 구조로 재정렬합니다.

권장 목표 상태:

- **Backend**: `api/turn_stream_events.py`에 “NDJSON 이벤트 모델/유틸” 집중
- **Orchestrator**: `TurnOutput` 생성/검증/폴백(도메인)만 담당 (스트림 이벤트 모델 제거)
- **Frontend**: `types/turn_stream.ts`에 “이벤트 타입 + (선택) 디코더(Zod)” 집중, `api/turnStream.ts`는 스트림 IO만 담당

### 구체적 실행 단계

#### Step 1: 서버 스트림 이벤트를 `api/turn_stream_events.py`로 이동(권장)

**변경 전:**

- `unknown_world/orchestrator/mock.py`에 이벤트 모델이 존재

**변경 후(권장):**

- `backend/src/unknown_world/api/turn_stream_events.py`에 아래를 정의:
  - `StreamEventType`, `StageStatus`(enum/리터럴)
  - `StageEvent`, `BadgesEvent`, `NarrativeDeltaEvent`, `FinalEvent`, `ErrorEvent`(Pydantic)
  - `_serialize_event` 같은 유틸(또는 `turn.py`에 두되 import 통일)
- `orchestrator/mock.py`는 **TurnOutput 생성기 + 안전 폴백 생성기**만 남김

#### Step 2: 프론트 이벤트 타입/디코더를 `types/turn_stream.ts`로 분리(권장)

**변경 전:**

- `api/turnStream.ts`에 이벤트 타입/파서/네트워크 IO가 혼재

**변경 후(권장):**

- `frontend/src/types/turn_stream.ts`:
  - `StreamEventType`, `StageStatus`
  - `StageEvent`, `BadgesEvent`, `NarrativeDeltaEvent`, `FinalEvent`, `ErrorEvent`, `StreamEvent`
  - (선택) Zod 기반 `decodeStreamEvent(...)` / `safeDecodeStreamEvent(...)`
- `frontend/src/api/turnStream.ts`:
  - NDJSON 파서 + fetch stream 소비 + `dispatchEvent`(가능하면 디코더 호출만)

#### Step 3: stage 목록 SSOT 전략 확정(페어링 Q1 해결을 위한 구조)

- **권장**: 서버 SSOT + 클라 폴백
  - 서버가 시작 시점에 `(선택) protocol/meta 이벤트`로 stage 목록을 제공
  - 클라는 protocol이 오면 그 목록을 표시하고, 없으면 DEFAULT_PHASES를 사용

예시(선택):

```json
{"type":"protocol","version":"1","stages":["parse","validate","plan","resolve","render","verify","commit"]}
```

> 이 메타 이벤트는 “SSOT를 어디에 둘지”를 코드로 고정하는 역할을 합니다.

### 대안적 접근법 (선택사항)

- **대안 1(최소 변경)**: 파일 이동 없이, “각 정의를 한 곳에서 import”만 강제
  - 장점: 빠름
  - 단점: 책임 경계 문제는 남아 drift 위험이 완전히 사라지지 않음
- **대안 2(강경)**: shared JSON Schema에 stream protocol까지 포함하고, 양쪽에서 이를 참조/검증
  - 장점: 가장 강한 SSOT
  - 단점: MVP 범위를 넘어설 수 있음(도입 비용)

---

## 📈 기대 효과

### 즉각적 효과

- ✅ 이벤트 계약 변경 시 수정 범위 축소(“어디를 고치면 되는지” 명확)
- ✅ Orchestrator ↔ API 결합도 감소(역할 명확화)
- ✅ RU-002 목표(타입/용어 통일) 달성 경로가 단순해짐

### 장기적 효과

- 🎯 실모델/repair loop 도입 시 이벤트 확장이 안전해짐
- 🎯 팀 온보딩 비용 감소(계약이 한 군데에 존재)

---

## ⚠️ 주의사항 및 고려사항

### 리팩토링 시 주의할 점

1. “모듈 분리”는 계약을 바꾸지 않는 방향(Behavior Preservation)으로 먼저 수행하고, 계약 변경(Q2)을 이후 단계로 분리하는 것이 안전합니다.  
2. FastAPI 라우트의 import 경로 이동은 packaging/uv 실행에 영향이 있을 수 있으니, 경로를 얕게 유지합니다.  
3. Frontend에서 event 타입/디코더를 분리할 때 순환 import가 생기지 않게 주의합니다.

### 호환성 체크리스트

- [ ] 기존 event JSON shape가 바뀌지 않았는가? (변경할 계획이면 RU-002-Q2 선행)
- [ ] stage 목록이 서버/클라에서 동일하게 유지되는가?

---

## 🧪 검증 방법 (수동 검증 중심)

### 변경 전 확인 사항

- 현재 서버/클라 정상 스트리밍 시나리오를 수행해 기준 상태를 확보(런북 U-007/U-008)

### 변경 후 검증 시나리오

#### 시나리오 1: 서버 스트림 정상 동작

- **실행 방법**: `vibe/unit-runbooks/U-007-mock-orchestrator-runbook.md` 시나리오 A
- **기대 결과**: 이벤트 시퀀스(stage→badges→narrative_delta→final) 유지

#### 시나리오 2: 프론트 Agent Console 정상 렌더

- **실행 방법**: `vibe/unit-runbooks/U-008-http-streaming-client-runbook.md` 시나리오 A/B
- **기대 결과**: Queue/Badges 정상 표시, 스트리밍 종료 후 IDLE 복귀

---

## 🔧 실행 가이드

### 개발자를 위한 실행 지침

1. **준비 사항**
   - RU-002 페어링 Q1 결정(SSOT 위치) 확인
2. **실행 절차**
   - 서버: 이벤트 모델 이동 → import 정리
   - 클라: 이벤트 타입/디코더 분리 → import 정리
   - (선택) protocol/meta 이벤트 도입
3. **검증 절차**
   - U-007/U-008 런북 시나리오 재수행
4. **롤백 계획**
   - 이동 커밋을 되돌리고, 계약 변경은 RU-002-Q2로 분리

---

## 📚 참고 자료

- `vibe/prd.md` 8.4.3(스트림 프로토콜), 6.8/10장(관측/복구 UX)
- `.cursor/rules/00-core-critical.mdc` (RULE-003/004/008)
- `vibe/unit-plans/RU-002[Mvp].md` (권장 파일/흐름)

---

## 🏷️ 태그

`#refactoring` `#module-design` `#high` `#streaming` `#contract`

---

## 📝 노트

- 이 제안은 “계약을 바꾸는 것”이 아니라, **계약을 안정적으로 유지/확장할 수 있게 ‘정의 위치’를 정리**하는 것이 1차 목표입니다.


