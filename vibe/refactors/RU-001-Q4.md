# [ID: RU-001-Q4] `shared/` 기반 JSON Schema SSOT(Option B) 디렉토리 도입 및 소비(backend/ frontend) 경로 고정

## 📌 기본 정보

| 항목               | 내용                     |
| ------------------ | ------------------------ |
| **ID**             | RU-001-Q4                |
| **심각도**         | High                     |
| **카테고리**       | 모듈 설계 (Module Design) |
| **영향 범위**      | (신규) `shared/`, `.gitignore`, U-005/U-006(스키마), U-007/U-008(SSE) |
| **예상 작업 시간** | 45~120분 (단계적 적용)   |

---

## 🔍 문제점 상세 분석

### 현재 상황

RU-001 계획서의 페어링 질문(Q1)은 **Option B(초기부터 `shared/` JSON Schema SSOT)**로 결정되어 있습니다.

```text
vibe/unit-plans/RU-001[Mvp].md
- Q1: 공통 스키마 SSOT?
  - A1: Option B
```

하지만 현재 레포 구조에는 `shared/`(공통 스키마 저장소)가 없고, 동시에 `.gitignore`는 `*.json`을 광범위하게 ignore 합니다. 즉, **Option B를 선택했지만 실제 구조가 이를 실현하지 못하는 상태**입니다.

### 문제가 되는 이유

1. **Turn 계약이 분기될 위험**: U-005(Pydantic)와 U-006(Zod)가 각각 스키마를 만들면 drift가 쉽게 발생합니다(RULE-003 위반 위험).
2. **오케스트레이터/프론트가 다른 계약을 믿는 상태로 진행**: SSE/Agent Console/Badges 구현(U-007/U-008) 시 “서로 다른 TurnOutput 가정”이 누적됩니다.
3. **스키마를 LLM에 강제하기 어렵다**: Structured Output(LLM response_json_schema)을 “한 곳”에서 관리하지 않으면, 모델 호출마다 제약이 달라질 수 있습니다(RULE-010 관점).

### 영향받는 코드 위치

- 파일: `vibe/unit-plans/RU-001[Mvp].md`
  - 라인: 83-89 (페어링 Q1 결정)
- 파일: `.gitignore`
  - 라인: 11-15 (`*.json` ignore 정책 — SSOT JSON 도입의 직접 장애물)

### 현재 코드 예시

현재 구조에는 `shared/`가 존재하지 않으며, `.gitignore`는 다음과 같이 JSON 전체를 차단합니다.

```gitignore
*.json
!package.json
!tsconfig.json
!pyrightconfig.json
```

---

## 💡 개선 방안

### 제안하는 접근법

**`shared/`에 “Turn 계약(JSON Schema)”을 고정하고, 백엔드/프론트는 이를 소비(또는 생성물로 변환)만 하게 합니다.**

핵심 원칙:

- **SSOT는 `shared/schemas/`** (사람이 읽고 리뷰 가능한 파일)
- 백엔드/프론트의 타입/검증 코드는 **SSOT로부터 생성/동기화** (drift 방지)
- 언어/런타임 차이(파이썬 vs TS)는 “생성 단계”에서 해결

### 구체적 실행 단계

#### Step 1: `shared/` 디렉토리 구조 확정 (초기 범위는 TurnInput/TurnOutput)

권장 구조(예시):

```text
shared/
  schemas/
    turn/
      turn_input.schema.json
      turn_output.schema.json
  README.md
```

초기에는 PRD의 Turn 계약(필드 구조)에서 “MVP 최소키”만 먼저 고정하고, U-005~U-008에서 점진적으로 확장합니다.

#### Step 2: `.gitignore`에서 `shared/**/*.json` allowlist 적용 (S1 제안과 연동)

**변경 후 예시:**

```gitignore
!shared/**/*.json
**/service-account*.json
**/credentials*.json
```

> 이 단계는 **RU-001-S1**과 함께 수행되어야 Option B가 실현됩니다.

#### Step 3: 소비 전략 결정 — “생성물 기반 동기화”로 drift 제거

Option B(SSOT=JSON Schema)를 현실적으로 운영하기 위한 2가지 경로:

##### 경로 A(권장, 생성물 기반)

- **Backend(Python)**: JSON Schema → Pydantic 모델 생성(예: `datamodel-code-generator`)
- **Frontend(TS)**: JSON Schema → Zod 스키마 생성(예: `json-schema-to-zod`)
- 생성물은 `backend/src/unknown_world/schemas/generated/*.py`, `frontend/src/schemas/generated/*.ts` 등에 저장

장점: “SSOT는 JSON Schema” 원칙을 엄격히 지킴  
단점: generator 도구/스크립트가 필요(단, dev-only로 충분)

##### 경로 B(과도기, 수동 동기화)

- U-005/U-006에서 Pydantic/Zod를 각각 작성하되,
- **PR 리뷰에서 반드시 shared schema와 수동 비교**(체크리스트)

장점: 도구 도입을 미룸  
단점: 사람에 의존 → drift 가능(Option A에 가까워짐)

RU-001의 결론(Option B)을 존중한다면, MVP라도 **경로 A의 최소 형태(한 번의 생성 스크립트라도)**는 도입하는 편이 안전합니다.

---

## 📈 기대 효과

### 즉각적 효과

- ✅ U-005/U-006에서 “서로 다른 Turn 계약”이 만들어지는 것을 구조적으로 차단
- ✅ LLM Structured Output JSON Schema를 한 곳에서 관리 가능
- ✅ 이후 RU-010[Mmp](스키마/상수 SSOT 강화)의 선행 기반 구축

### 장기적 효과

- 🎯 스키마 변경 시 영향 범위가 명확해지고, “클라/서버 동시 변경”이 자동으로 안내됨
- 🎯 Repair loop/Hard gate 설계가 안정화(스키마 drift 제거)

### 정량적 개선 (가능한 경우)

| 지표                   | 현재      | 개선 후                         | 변화율 |
| ---------------------- | --------- | ------------------------------- | ------ |
| Turn 계약 drift 빈도   | 높아질 수 있음 | 낮음(shared schema 기반)         | ↓      |
| 스키마 변경 반영 시간  | 수동/느림 | 생성/동기화 경로로 빠름          | ↓      |

---

## ⚠️ 주의사항 및 고려사항

### 리팩토링 시 주의할 점

1. JSON Schema는 “지원되는 부분집합” 범위로 단순하게 유지해야 합니다(PRD/가이드 준수).
2. `additionalProperties: false` 등 엄격 모드 도입 시, 초기에는 파손이 잦을 수 있으므로 단계적으로 강화합니다.
3. 스키마 파일은 “프롬프트 원문”이 아니라 계약 문서이므로 커밋해도 보안 위험이 없습니다(단, 비밀값 포함 금지).

### 영향받는 다른 모듈

- **Backend Orchestrator(U-017/U-018)**: response_json_schema의 SSOT 경로가 고정됨
- **Frontend Zod 검증(U-006)**: 생성물 경로/임포트 구조가 고정됨

### 호환성 체크리스트

- [ ] `shared/` 경로가 루트 기준으로 고정되었는가?
- [ ] `.gitignore`가 `shared/**/*.json`을 허용하는가?
- [ ] 생성물 경로가 “소스 오염(생성물 커밋 여부)” 정책과 합의되었는가?

---

## 🧪 검증 방법 (수동 검증 중심)

### 변경 전 확인 사항

1. 현재 레포에 `shared/`가 없어서 스키마 공유가 불가능함을 확인
2. `.gitignore`가 JSON을 차단해 스키마 커밋이 불가능함을 확인

### 변경 후 검증 시나리오

#### 시나리오 1: `shared/schemas`가 정상적으로 Git에 추적되는지 확인

- **실행 방법**:

```bash
mkdir -p shared/schemas/turn
echo "{\"type\":\"object\"}" > shared/schemas/turn/_check.schema.json
git status --porcelain
git check-ignore -v shared/schemas/turn/_check.schema.json || echo "NOT IGNORED ✅"
```

- **기대 결과**:
  - 새 파일이 추적 대상으로 표시된다.

#### 시나리오 2: (도입 시) 생성물 경로가 한 번에 갱신되는지 확인

- **실행 방법**: 팀이 합의한 생성 스크립트 실행
- **기대 결과**:
  - backend/ frontend의 생성물이 동일 스키마에 맞게 갱신된다.

### 회귀 확인 체크리스트

- [ ] U-005/U-006이 “각자 스키마 작성”으로 회귀하지 않는가?
- [ ] `shared/`가 단순 문서 폴더로 방치되지 않는가?

---

## 🔧 실행 가이드

### 개발자를 위한 실행 지침

1. **준비 사항**
   - RU-001 페어링 Q1 결정(Option B) 재확인
   - RU-001-S1(.gitignore)과 함께 적용할 것

2. **실행 절차**

```bash
# 1) shared/ 디렉토리 추가
mkdir -p shared/schemas/turn

# 2) 스키마 파일 추가(초기 최소)
# 3) .gitignore allowlist 적용
```

3. **검증 절차**
   - `git check-ignore`로 추적 여부 확인

4. **롤백 계획** (필요시)
   - `shared/` 폴더를 제거하고 관련 문서/스크립트만 되돌리면 됨

### 예상 소요 시간

- 디렉토리/초기 스키마 생성: 15~30분
- (선택) 생성물 스크립트 도입: 30~90분
- 총 예상 시간: 45~120분

---

## 📚 참고 자료

- `vibe/unit-plans/RU-001[Mvp].md` (페어링 Q1)
- `vibe/prd.md` (TurnInput/TurnOutput 초안)
- `vibe/ref/structured-outputs-guide.md` (JSON Schema 제약)
- `.cursor/rules/00-core-critical.mdc` (RULE-003/010)

---

## 🏷️ 태그

`#refactoring` `#module-design` `#schema-ssot` `#shared` `#high`

---

## 📝 노트

- 이 제안은 “Option B를 선택했다면 구조가 Option B를 강제해야 한다”는 관점의 최소 설계입니다.


