# [ID: RU-004-Q4] 모듈 설계: 세션 초기화/복원/리셋 SSOT 단일화(App.tsx 의존성 축소)

## 📌 기본 정보

| 항목               | 내용                                                                                          |
| ------------------ | --------------------------------------------------------------------------------------------- |
| **ID**             | RU-004-Q4                                                                                     |
| **심각도**         | High                                                                                          |
| **카테고리**       | 모듈 설계 (Module Design)                                                                     |
| **영향 범위**      | `frontend/src/App.tsx`, `frontend/src/save/saveGame.ts`, `frontend/src/data/demoProfiles.ts`, (권장 신규) `frontend/src/save/sessionLifecycle.ts`, (선택) `frontend/src/save/migrations.ts` |
| **예상 작업 시간** | 45~90분                                                                                       |

---

## 🔍 문제점 상세 분석

### 현재 상황

현재 세션 생명주기(부팅/프로필 시작/Continue/Reset/프로필 변경)는 `App.tsx` 내부에 흩어져 있습니다.

- 부팅 시 phase 결정(`profile_select` vs `playing`)
- 프로필 선택 시 SaveGame 생성 + store 초기화/주입 + localStorage 저장
- Continue 시 SaveGame 로드 + store 초기화/주입
- Reset 시 “현재 프로필”을 다시 선택하는 방식으로 재시작
- 프로필 변경 시 localStorage 삭제 + store reset + phase 전환

이 구조는 U-015를 빠르게 완성하기에는 좋았지만, RU-004 목표(초기 상태 SSOT/중복 제거/데모 반복성 강화) 관점에서는 다음 문제가 있습니다.

### 문제가 되는 이유

1. **초기 상태 SSOT가 분산**: “초기 상태”가 `demoProfiles.ts`(정의) + `createSaveGameFromProfile`(변환) + `App.tsx`(store 주입)로 나뉘어, 한 곳만 수정해도 다른 경로가 깨질 수 있습니다.
2. **Behavior Preservation이 어려움**: Reset/Continue/ChangeProfile 각각이 다른 방식으로 store를 다루면, 작은 변경이 특정 경로에서만 회귀를 만듭니다.
3. **확장 시 폭발 반경 증가**: SaveGame에 필드가 추가되거나(quest/rules/memory pins 확장), 세션 스토어가 늘어나면 App.tsx 변경이 누적됩니다.
4. **S1/S2의 안정성 패치가 흩어짐**: ledger hydrate, 유효 SaveGame 판단, profileId SSOT 등은 “세션 라이프사이클”에 속하는 정책인데 App에 남아 있으면 누락 위험이 큽니다.

### 영향받는 코드 위치

- `frontend/src/App.tsx`
  - `restoreSaveGame`, `handleSelectProfile`, `handleReset`, `handleChangeProfile`, 부팅/자동 저장 effect 등
- `frontend/src/save/saveGame.ts`
  - 로드/마이그레이션 훅의 책임 경계
- `frontend/src/data/demoProfiles.ts`
  - 프로필 → SaveGame 변환 로직(번역 함수 포함)

---

## 💡 개선 방안

### 제안하는 접근법

세션 생명주기를 담당하는 SSOT를 App 밖으로 이동합니다.

권장 구조(최소 변경, Behavior Preservation 친화):

- 신규 모듈 `frontend/src/save/sessionLifecycle.ts`
  - **부팅/선택/복원/리셋/변경**을 모두 여기서 수행
  - store reset/hydrate 범위를 표준화
  - localStorage 키/유효성/클린업 정책을 표준화
- (선택) 신규 모듈 `frontend/src/save/migrations.ts`
  - SaveGame 버전 마이그레이션 훅을 명시적으로 분리(계약/정책 문서화)

App.tsx의 역할(목표):

- 게임 UI 레이아웃 + 이벤트 라우팅(클릭/드롭/턴 실행)
- 세션 라이프사이클 호출(“start/continue/reset/change”)만 수행

### 구체적 실행 단계

#### Step 1: `sessionLifecycle.ts`에 “세션 작업” API 정의

권장 API(예시):

```ts
// sessionLifecycle.ts (개념 예시)
export type SessionBootstrap =
  | { phase: 'profile_select'; savedGameAvailable: boolean }
  | { phase: 'playing'; saveGame: SaveGame; profileId: string | null };

export function bootstrapSession(): SessionBootstrap;

export async function startSessionFromProfile(args: {
  profile: DemoProfile;
  t: (key: string) => string;
}): Promise<{ profileId: string }>;

export async function continueSession(): Promise<{ profileId: string } | null>;

export async function resetToCurrentProfile(args: {
  t: (key: string) => string;
  currentProfileId: string | null;
}): Promise<boolean>;

export function clearSessionAndReturnToSelect(): void;
```

핵심은 “store 주입/초기화”를 이 모듈에서 단일화하는 것입니다.

#### Step 2: store reset/hydrate 범위를 표준화(세션 경계 고정)

세션 경계에서 항상 처리:

- `worldStore.reset()` + saveGame 기반 hydrate
- `inventoryStore.reset()`/`setItems(...)`
- `economyStore.reset()` + (S1) ledger hydrate + low balance 재계산
- `actionDeckStore.reset()`
- `agentStore.reset()`

#### Step 3: “유효 SaveGame만 Continue” 정책을 bootstrap/continue에 포함 (S2 연동)

- `bootstrapSession()`이 `hasSaveGame()` 같은 키 존재 여부가 아니라,
  - `loadAndMigrateSaveGame()` 결과를 기준으로 phase/continue 노출을 결정
- invalid면 즉시 클린업 후 profile_select

#### Step 4: App.tsx에서 중복 로직 제거

- App.tsx에서 제거할 것:
  - store 초기화/주입 로직(setState, setItems, ledger loop 등)
  - localStorage clear/save 로직(가능한 한 sessionLifecycle로 이동)
- App.tsx에 남길 것:
  - `gamePhase`(또는 sessionLifecycle가 반환하는 상태)
  - `currentProfileId`(가능하면 세션 모듈 반환 값으로만 갱신)

### 대안적 접근법 (선택사항)

- **대안 1(더 강한 SSOT)**: `sessionStore(zustand)`를 도입해 `gamePhase/currentProfileId`까지 store로 이동  
  - 장점: App local state가 더 얇아짐
  - 단점: 변경 범위가 커져 RU-004 “45분” 목표를 초과할 수 있음
- **대안 2(최소 추출)**: `applySaveGameToStores(saveGame)`만 별도 파일로 추출  
  - 장점: 리팩토링 최소
  - 단점: 부팅/클린업/유효성 정책이 App에 남아 누락 위험 지속

---

## 📈 기대 효과

### 즉각적 효과

- ✅ Reset/Continue/ChangeProfile이 동일한 SSOT 경로를 거쳐 동작 → 경로별 회귀 감소
- ✅ App.tsx 복잡도 감소(레이아웃/이벤트 라우팅에 집중)
- ✅ S1/S2 개선(ledger hydrate/유효성/클린업)을 한 곳에서 관리 가능

### 장기적 효과

- 🎯 SaveGame 필드 확장(룰/퀘스트/메모리 핀 등) 시 “store 주입 지점”이 1곳으로 고정
- 🎯 U-025/U-026에서 세션/아티팩트 경계를 재사용 가능

---

## ⚠️ 주의사항 및 고려사항

### 리팩토링 시 주의할 점

1. RU-004는 기능 추가가 아니라 “경계 정리”입니다. 세션 UX를 새로 만들지 않고 현재 동작을 유지합니다.
2. `sessionLifecycle.ts`는 UI 레이어(React)와 분리되어야 하며, store와 save util만 의존하도록 유지합니다.
3. 언어 변경은 async이므로, 세션 모듈에서 await 후 store 주입 순서를 고정합니다(S1 연동).

### 호환성 체크리스트

- [ ] 프로필 선택/Continue/Reset/프로필 변경의 동작이 기존과 동일한가?
- [ ] SaveGame이 깨진 경우에도 profile_select로 안전 폴백되는가?
- [ ] Reset 직후 Action Deck/Agent Console 잔재가 없는가?

---

## 🧪 검증 방법 (수동 검증 중심)

> 상세 시나리오는 `RU-004-S3.md`를 참조합니다.

핵심만 빠르게 확인:

1. 프로필 선택 → 턴 1회 진행 → 새로고침 → Continue → 동일 상태 복원
2. Reset → 초기 상태로 복귀 + UI 잔재 없음
3. 프로필 변경 → profile_select로 이동 + 이전 세이브/프로필 키 정리

---

## 🔧 실행 가이드

### 개발자를 위한 실행 지침

1. **준비 사항**
   - 기존 코드에서 세션 관련 함수 목록 정리(`handleSelectProfile`, `restoreSaveGame`, `handleReset`, `handleChangeProfile`)
2. **실행 절차**
   - `sessionLifecycle.ts` 생성 → 로직을 단계적으로 이동
   - App.tsx는 “세션 모듈 호출 + UI 전환”만 남기기
3. **검증 절차**
   - `RU-004-S3` 수동 시나리오 수행
4. **롤백 계획**
   - sessionLifecycle 도입 커밋을 되돌리고 App.tsx 로직으로 복귀 가능(변경을 한 파일로 집중시키는 것이 목적)

---

## 📚 참고 자료

- `vibe/unit-plans/RU-004[Mvp].md` (초기 상태 SSOT, migration hook 준비)
- `vibe/unit-results/U-015[Mvp].md`
- `frontend/src/App.tsx`
- `frontend/src/save/saveGame.ts`
- `frontend/src/data/demoProfiles.ts`

---

## 🏷️ 태그

`#refactoring` `#module-design` `#high` `#savegame` `#session` `#ssot`

---

## 📝 노트

- RU-003이 “TurnOutput 반영 SSOT”를 worldStore로 이동시킨 것처럼, RU-004는 “세션 초기화/복원 SSOT”를 sessionLifecycle로 이동시키는 작업입니다. 둘 다 목적은 동일합니다: **데모 표면이 확장되어도 경계가 무너지지 않게 하기**.

