# [ID: RU-002-S1] 스트리밍 실패(네트워크/서버/검증)에서도 “항상 final(폴백 TurnOutput)로 종료” + UI 멈춤 방지 + Economy 안전화

## 📌 기본 정보

| 항목               | 내용                           |
| ------------------ | ------------------------------ |
| **ID**             | RU-002-S1                      |
| **심각도**         | Critical                       |
| **카테고리**       | 잠재적 오류 (Potential Bugs)   |
| **영향 범위**      | `backend/src/unknown_world/api/turn.py`, `backend/src/unknown_world/orchestrator/mock.py`, `frontend/src/api/turnStream.ts`, `frontend/src/App.tsx`, `frontend/src/schemas/turn.ts`, `frontend/src/stores/agentStore.ts` |
| **예상 작업 시간** | 45~90분                        |

---

## 🔍 문제점 상세 분석

### 현재 상황

현행 스트리밍 계약은 “정상 완료” 경로에서는 잘 동작하지만, **일부 실패 경로에서 UI가 멈추거나(E2E 체감: 입력/카드가 영구 disable), 또는 Economy HUD가 잘못 갱신되는** 위험이 있습니다.

특히 RU-002의 완료 기준(“실패 시 폴백 TurnOutput으로 종료”, RULE-004)과 PRD의 데모 하드 게이트(“멈춤/깨짐” 방지) 관점에서, 아래 3가지가 동시에 문제가 됩니다:

1) **클라이언트 네트워크/HTTP 오류 시 `onComplete`가 호출되지 않아 `isStreaming`이 true로 남을 수 있음**  
2) **서버가 `error` 이벤트만 내보내고 `final`로 종료하지 않는 경로가 존재**  
3) **폴백 TurnOutput의 economy.balance_after가 “현재 세션 잔액”과 무관한 값으로 채워져 HUD가 왜곡될 수 있음**

### 문제가 되는 이유

1. **UI 멈춤은 데모에서 즉시 실패로 보임**: PRD는 스트리밍 UX에서 “단계/배지/복구”가 보여야 하고, 실패 시에도 안전한 대체 결과를 제공해야 함(RULE-004/008).  
2. **Economy 인바리언트/UX 위반**: 폴백이 잔액을 임의 값으로 덮어쓰면, 사용자 입장에서 “재화가 갑자기 증발/증가”로 보이며 RULE-005(잔액 음수 금지/일관성) 정신을 훼손합니다.  
3. **향후 실모델/리페어 루프 확장 시, 실패 종료 규칙이 불명확하면 프론트/백의 복구 로직이 계속 깨짐**.

### 영향받는 코드 위치

- 서버: `backend/src/unknown_world/api/turn.py`
  - 라인: 175-185 (예외 발생 시 `error`만 송출)
  - 라인: 262-281 (입력 검증 실패 시 `error`만 송출)
  - 라인: 160-163 / 171-173 (`final`은 특정 경로에서만 송출)
- 서버: `backend/src/unknown_world/orchestrator/mock.py`
  - 라인: 437-475 (폴백 TurnOutput 생성, economy.balance_after가 하드코딩)
- 클라이언트: `frontend/src/api/turnStream.ts`
  - 라인: 310-323 (catch에서 `onError`만 호출, `onComplete` 미호출)
- 클라이언트: `frontend/src/App.tsx`
  - 라인: 259-277 (startStream으로 isStreaming=true, onComplete에서만 completeStream 호출)
  - 라인: 271-274 (onError에서 completeStream 호출 없음)
- 클라이언트: `frontend/src/schemas/turn.ts`
  - 라인: 464-495 (폴백 TurnOutput economy.balance_after=0/0)

### 현재 코드 예시

**(1) 클라이언트: 네트워크/HTTP 에러 시 complete가 호출되지 않음**

```ts
// frontend/src/api/turnStream.ts
// ...
} catch (error) {
  // ...
  callbacks.onError?.({
    type: StreamEventType.ERROR,
    message: errorMessage,
    code: 'STREAM_ERROR',
  });
}
```

**(2) 서버: 일부 실패 경로에서 error만 송출**

```py
# backend/src/unknown_world/api/turn.py
except Exception:
    yield _serialize_event(
        ErrorEvent(type=StreamEventType.ERROR, message="처리 중 오류...", code="INTERNAL_ERROR").model_dump()
    )
```

**(3) 폴백 economy가 세션 잔액과 무관**

```py
# backend/src/unknown_world/orchestrator/mock.py
balance_after=CurrencyAmount(signal=100, memory_shard=5)  # 기본 잔액 (하드코딩)
```

```ts
// frontend/src/schemas/turn.ts
economy: {
  cost: { signal: 0, memory_shard: 0 },
  balance_after: { signal: 0, memory_shard: 0 }, // 하드코딩
},
```

---

## 💡 개선 방안

### 제안하는 접근법

**“스트림 종료 인바리언트”를 명시하고, 서버/클라가 이를 강제**합니다.

- **스트림 종료 인바리언트**: “각 `/api/turn` 스트림은 정확히 1개의 `final` 이벤트로 종료한다.”  
  - 성공: 검증된 TurnOutput
  - 실패: 안전 폴백 TurnOutput (RULE-004)
- `error` 이벤트는 “UI용 경고/설명”으로 유지하되, **terminal 이벤트로 쓰지 않는다**(최종 상태는 항상 `final`).
- 폴백 TurnOutput의 Economy는 **입력 스냅샷을 그대로 유지**(비용 0, 잔액 변화 없음)하여 RULE-005 정신을 보존한다.

### 구체적 실행 단계

#### Step 1: 서버에서 “error-only 종료”를 제거하고, 실패 시에도 final(폴백) 송출

- 입력 검증 실패, 내부 예외, 생성/검증 실패 모두:
  - (선택) `error` 이벤트 송출
  - **반드시 `final` 이벤트로 폴백 TurnOutput 송출 후 종료**

**변경 전:**

- 입력 검증 실패: `error`만 송출
- 내부 예외: `error`만 송출

**변경 후(권장):**

- `final`은 항상 송출(성공/실패 통일)
- `error`는 “왜 폴백이었는지” UI 힌트용으로만 송출

#### Step 2: 폴백 TurnOutput의 economy.balance_after를 “현재 입력 스냅샷 기반”으로 표준화

- 서버 폴백: `balance_after = turn_input.economy_snapshot`, `cost = 0`
- 클라 폴백: “서버 final이 오지 못한 케이스(네트워크)”까지 커버해야 하므로,
  - `TurnInput.economy_snapshot` 또는 “요청 직전 HUD 값”을 그대로 넣어 종료용 폴백을 만든다.

#### Step 3: 클라이언트 스트림 실행기에서 `onComplete`를 finally에서 보장 + 필요 시 final 폴백을 생성해 UI 종료

- `executeTurnStream`의 try/catch를 `try { ... } catch { ... } finally { callbacks.onComplete?.() }` 형태로 정리
- `STREAM_ERROR`(HTTP error, fetch rejection 등) 시:
  - `onError` 호출
  - **즉시 `onFinal` 폴백도 호출(선택)** → App이 `applyTurnOutput`로 HUD를 안전하게 유지

#### Step 4: AgentStore/App에서 “에러 시 스트리밍 종료”를 보장

- App의 `onError`에서 `completeStream()` 호출(또는 `onComplete` 보장으로 충분)
- “오프라인 상태”가 되더라도 입력이 영구 lock 되지 않게 한다.

### 대안적 접근법 (선택사항)

- **대안 1(보수적)**: onComplete만 finally에서 보장하고, final 폴백은 만들지 않음
  - 장점: 계약 변경 최소
  - 단점: “최종 상태”가 TurnOutput 없이 끝나 UI가 덜 일관됨(특히 Economy/내러티브)
- **대안 2(강경)**: `error` 이벤트를 제거하고 모든 실패는 `final` 한 번만 송출
  - 장점: 프로토콜 단순
  - 단점: 실패 원인 가시성이 낮아짐(관측성 약화, RULE-008 손실)

---

## 📈 기대 효과

### 즉각적 효과

- ✅ 네트워크/서버 오류에서도 **UI가 “멈추지 않음”** (입력/카드 영구 disable 방지)
- ✅ “항상 final로 종료” 규칙으로 스트리밍 UX가 예측 가능해짐(RULE-004/008)
- ✅ 폴백 시에도 Economy HUD가 왜곡되지 않아 데모 신뢰도 상승(RULE-005)

### 장기적 효과

- 🎯 RU-003(실모델 연동)에서 “리페어 루프”를 추가할 때도 종료 규칙이 흔들리지 않음
- 🎯 스트리밍 계약 변경 시 프론트/백 디버깅 비용 감소

### 정량적 개선 (가능한 경우)

| 지표                    | 현재                                   | 개선 후                                     | 변화율 |
| ----------------------- | -------------------------------------- | ------------------------------------------- | ------ |
| “멈춤/잠금” 체감 이슈   | 네트워크 실패 시 발생 가능             | 실패 시에도 종료 처리(complete/final) 보장  | ↓      |
| Economy HUD 왜곡        | 폴백 시 0/0 또는 100/5로 덮어쓸 수 있음 | 폴백 시 입력 스냅샷 유지                     | ↓      |

---

## ⚠️ 주의사항 및 고려사항

### 리팩토링 시 주의할 점

1. **스트림이 항상 final로 종료**되면, 프론트는 “error 표시 + final 적용”의 우선순위를 명확히 해야 합니다(예: error는 배너, final은 상태 반영).  
2. 폴백 TurnOutput은 **프롬프트/내부 추론/스택트레이스**를 절대 포함하면 안 됩니다(RULE-007/008).  
3. “비용 0 + 잔액 유지”는 보수적인 정책입니다. 추후 “실패에도 비용 일부 발생”을 도입하려면 Economy 정책 합의가 필요합니다.

### 영향받는 다른 모듈

- **Agent Console**: Auto-repair/에러 트레이스 UX가 더 일관되게 동작(“끝났는지” 명확)
- **CP-MVP-01**: 스트리밍/스키마/폴백 체크포인트를 안정적으로 수행 가능

### 호환성 체크리스트

- [ ] 실패 시에도 `final` 이벤트가 정확히 1개 송출되는가?
- [ ] `onComplete`는 성공/실패 모두에서 호출되는가?
- [ ] 폴백 시 economy.balance_after가 “요청 직전 잔액”을 유지하는가?

---

## 🧪 검증 방법 (수동 검증 중심)

### 변경 전 확인 사항

1. **네트워크 실패(UI 멈춤) 재현**: 백엔드 종료 후 프론트에서 실행 → 입력창/카드가 영구 disable 되는지 확인  
2. **폴백 Economy 왜곡 재현**: 폴백이 발생하면 HUD가 0/0 또는 100/5로 바뀌는지 확인

### 변경 후 검증 시나리오

#### 시나리오 1: 백엔드 다운 상태에서 실행(네트워크 실패)

- **실행 방법**: `vibe/unit-runbooks/U-008-http-streaming-client-runbook.md` 시나리오 E 따라 수행  
- **기대 결과**:
  - ✅ Agent Console에 에러 표시
  - ✅ UI가 IDLE로 복귀(입력/카드 다시 활성화)
  - ✅ Economy HUD가 “요청 직전 값” 유지

#### 시나리오 2: 입력 검증 실패(필수 필드 누락/잘못된 language)

- **실행 방법**: `vibe/unit-runbooks/U-007-mock-orchestrator-runbook.md` 시나리오 D에 준해 잘못된 payload 전송  
- **기대 결과**:
  - ✅ `error` 이벤트(선택)
  - ✅ 반드시 `final` 폴백 이벤트 도착
  - ✅ 프론트는 final을 적용해 “스트림 종료 상태”가 명확

#### 시나리오 3: 서버 내부 예외(강제 실패 시뮬레이션)

- **실행 방법**: (개발자 로컬에서) `_stream_turn_events` 내부에서 예외를 강제로 발생시키는 임시 훅으로 확인  
- **기대 결과**:
  - ✅ error + final(폴백) 순서로 스트림 종료
  - ✅ UI 멈춤 없음

### 회귀 확인 체크리스트

- [ ] 정상 케이스에서 이벤트 순서(stage/badges/narrative_delta/final)가 유지되는가?
- [ ] 프론트에서 한 번의 턴 실행이 항상 “종료 상태”로 귀결되는가?

---

## 🔧 실행 가이드

### 개발자를 위한 실행 지침

1. **준비 사항**
   - PRD: `vibe/prd.md` 8.4.3(스트림 프로토콜), 6.8/10장(복구/배지 UX)
   - RULE: `.cursor/rules/00-core-critical.mdc` (RULE-004/005/008)
   - 런북: `vibe/unit-runbooks/U-007-mock-orchestrator-runbook.md`, `vibe/unit-runbooks/U-008-http-streaming-client-runbook.md`

2. **실행 절차**
   - 서버: 실패 경로에서도 final 송출 + 폴백 Economy 정책 적용
   - 클라: executeTurnStream 종료 보장(finally) + (선택) STREAM_ERROR 시 final 폴백 생성

3. **검증 절차**
   - 위 “수동 검증 시나리오” 3개 수행

4. **롤백 계획** (필요시)
   - final 송출 강제/폴백 Economy 변경만 되돌리면 됨(프로토콜 버전 이벤트 도입 시에는 v1 유지)

### 예상 소요 시간

- 코드 수정: 30~60분
- 수동 검증: 15~30분
- 총 예상 시간: 45~90분

---

## 📚 참고 자료

- `vibe/prd.md` 6.8, 8.4.3, 10장
- `.cursor/rules/00-core-critical.mdc` (RULE-004/005/008)
- `vibe/unit-runbooks/U-007-mock-orchestrator-runbook.md`
- `vibe/unit-runbooks/U-008-http-streaming-client-runbook.md`

---

## 🏷️ 태그

`#refactoring` `#stability` `#critical` `#streaming` `#fallback` `#economy`

---

## 📝 노트

- 본 제안은 “스트림이 실패해도 게임 UI가 유지되는 경험”을 만들기 위한 **최소 인바리언트(항상 final)**를 고정합니다.


