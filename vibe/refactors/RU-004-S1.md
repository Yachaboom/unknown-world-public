# [ID: RU-004-S1] 잠재 버그: SaveGame 복원 시 ledger/lastCost/언어 적용 불일치(데모 반복성 붕괴 위험)

## 📌 기본 정보

| 항목               | 내용                                                                 |
| ------------------ | -------------------------------------------------------------------- |
| **ID**             | RU-004-S1                                                            |
| **심각도**         | High                                                                 |
| **카테고리**       | 잠재적 오류 (Potential Bugs)                                         |
| **영향 범위**      | `frontend/src/App.tsx`, `frontend/src/stores/economyStore.ts`, `frontend/src/i18n.ts`, (보조) `frontend/src/save/saveGame.ts` |
| **예상 작업 시간** | 30~60분                                                              |

---

## 🔍 문제점 상세 분석

### 현재 상황

U-015에서 “Continue/Reload”를 위한 `restoreSaveGame()`이 구현되었지만, 다음 3개 이슈로 인해 **복원 후 HUD/원장/언어가 실제 저장 상태와 어긋날 수 있습니다.**

#### (1) Economy Ledger 복원 순서가 역전되고 lastCost가 왜곡됨

- `frontend/src/App.tsx`의 복원 로직은 저장된 `saveGame.economyLedger`를 순회하며 `economyStore.addLedgerEntry()`를 호출합니다.
- 그런데 `economyStore.addLedgerEntry()`는 **항상 새 엔트리를 “앞에(prepend)”** 추가하며 최신순을 유지합니다.
- 결과적으로 “이미 최신순으로 저장된 배열”을 그대로 순회해 prepend 하면 **복원 후 ledger가 역순(오래된 것이 앞)**이 되고, `lastCost`가 “가장 최근”이 아니라 “가장 오래된” 엔트리로 남을 수 있습니다.

#### (2) Ledger 복원 시 timestamp가 원본이 아니라 ‘복원 시각’으로 덮여씀

- `addLedgerEntry`는 `timestamp = Date.now()`로 재생성합니다.
- SaveGame에는 원래 timestamp가 존재하지만(`saveGame.economyLedger[].timestamp`), 복원 과정에서 유실됩니다.

#### (3) 언어 적용이 비동기인데 await 없이 호출됨(짧은 구간 언어 불일치 가능)

- `changeLanguage()`는 Promise 기반 비동기입니다(`frontend/src/i18n.ts`).
- `restoreSaveGame()`에서 이를 await 하지 않으므로, “복원 직후 1~2프레임” 동안 UI 문자열이 이전 언어로 잠깐 렌더될 여지가 있습니다(특히 i18n 리소스 로딩 지연 시).

### 문제가 되는 이유

1. **데모 반복성/신뢰도 저하(PRD 6.9)**: Continue/Reload가 “보이기에는 되는데 HUD(원장/비용)가 이상함”으로 이어지면 심사자가 시스템을 불안정하게 인식합니다.
2. **Economy UX 위반 가능성(PRD 5장, RULE-005)**: ‘마지막 확정 비용/원장’은 사용자의 선택을 유도하는 핵심 HUD인데, 순서/lastCost 왜곡은 전략 UX를 무너뜨립니다.
3. **i18n 일관성(RULE-006) 리스크**: “혼합 출력”은 금지이며, 복원 직후 언어가 흔들리면 데모에서 체감됩니다.

### 영향받는 코드 위치

- `frontend/src/App.tsx`
  - `restoreSaveGame()` 언어 적용: 129~131
  - Economy 복원(ledger loop): 150~154
- `frontend/src/stores/economyStore.ts`
  - `addLedgerEntry()` prepend + timestamp 재생성: 190~210
- `frontend/src/i18n.ts`
  - `changeLanguage()` 비동기: 72~74

### 현재 코드 예시

```ts
// frontend/src/App.tsx (발췌)
const restoreSaveGame = useCallback(() => {
  const saveGame = loadSaveGame();
  if (!saveGame) return false;

  // 언어 설정 적용 (RULE-006)
  changeLanguage(saveGame.language as SupportedLanguage);

  // ...
  useEconomyStore.getState().reset();
  for (const entry of saveGame.economyLedger) {
    useEconomyStore.getState().addLedgerEntry(entry);
  }

  return true;
}, [worldStore]);
```

```ts
// frontend/src/stores/economyStore.ts (발췌)
addLedgerEntry: (entry) => {
  const timestamp = Date.now();
  const newEntry: LedgerEntry = { ...entry, timestamp };

  set((state) => {
    const updatedLedger = [newEntry, ...state.ledger].slice(0, LEDGER_MAX_ENTRIES);
    return { ledger: updatedLedger, lastCost: { /* ... */ }, costEstimate: null };
  });
},
```

---

## 💡 개선 방안

### 제안하는 접근법

복원(Rehydrate)은 “새 턴 기록(append)”이 아니라 **“스냅샷 적용(hydrate)”**입니다.  
따라서 SaveGame 복원 시에는 `addLedgerEntry()` 같은 “턴 이벤트용 API”를 사용하지 말고, **원장/lastCost/잔액부족 상태를 한 번에 주입하는 전용 경로**를 둡니다.

권장 방향:

- `restoreSaveGame()`을 `async`로 만들고 `await changeLanguage(...)` 후 상태를 반영
- EconomyStore에 `hydrateFromSaveGame(...)`(또는 외부 유틸) 추가
  - `ledger`는 저장된 순서를 유지(일반적으로 최신순)
  - `timestamp`는 저장된 값을 보존
  - `lastCost`는 최신 엔트리(첫 원소) 기준으로 계산
  - `isBalanceLow`는 복원된 잔액으로 즉시 재계산

### 구체적 실행 단계

#### Step 1: Economy 복원 전용 hydrate 경로 추가

- Option A(권장): `economyStore.ts`에 `hydrateLedger(ledger: LedgerEntry[])` 액션을 추가
- Option B(대안): `frontend/src/save/rehydrateEconomy.ts` 같은 유틸로 `useEconomyStore.setState(...)`를 수행

**변경 전(문제):**

```ts
for (const entry of saveGame.economyLedger) {
  useEconomyStore.getState().addLedgerEntry(entry);
}
```

**변경 후(권장 개념 예시):**

```ts
// 1) 저장된 ledger를 그대로 주입(순서/타임스탬프 보존)
economyStore.hydrateLedger(saveGame.economyLedger);

// 2) 잔액 부족 상태 즉시 재계산
economyStore.updateBalanceLowStatus(saveGame.economy);
```

#### Step 2: `restoreSaveGame()`을 async로 전환하고 언어 적용을 await

**변경 전:**

```ts
changeLanguage(saveGame.language as SupportedLanguage);
```

**변경 후:**

```ts
await changeLanguage(saveGame.language as SupportedLanguage);
```

#### Step 3: 복원 직후 `lastCost` 및 표시용 상태 일관성 확인

- `lastCost`는 “복원된 ledger의 최신 엔트리”와 일치해야 합니다.
- ledger가 비어있다면 `lastCost=null`이어야 합니다.

### 대안적 접근법 (선택사항)

- **대안 1**: SaveGame에 economy ledger를 저장하지 않고, 마지막 잔액만 저장(원장은 세션 내 한정)  
  - 장점: 복원 로직 단순화
  - 단점: PRD의 “원장 기반 가시성” 목표가 약화됨(데모 설득력↓)
- **대안 2**: `addLedgerEntry`에 “rehydrate 모드” 옵션을 추가(append 방식 변경)  
  - 장점: API 추가 최소화
  - 단점: 함수 책임이 혼재되어 이후 유지보수 난이도 상승

---

## 📈 기대 효과

### 즉각적 효과

- ✅ Continue/Reload 후 Economy HUD(원장/마지막 비용/잔액 경고)가 저장 상태와 일치
- ✅ 언어 적용이 안정화되어 복원 직후 UI 언어 흔들림 감소(RULE-006 리스크↓)

### 장기적 효과

- 🎯 U-025(엔딩 리포트)/U-026(리플레이)에서 “저장 스냅샷 적용” 패턴을 재사용 가능

### 정량적 개선 (가능한 경우)

| 지표                              | 현재(리스크)                 | 개선 후                          | 변화율 |
| --------------------------------- | ---------------------------- | -------------------------------- | ------ |
| Reload 후 ledger 최신순 보장      | 깨질 수 있음(역전 가능)      | 항상 보장(저장 순서 유지)        | ↑      |
| Reload 후 lastCost 정확도         | 깨질 수 있음(오래된 값)      | 최신 엔트리 기반으로 정확        | ↑      |
| Reload 후 언어 일관성 체감(깜빡임) | 환경에 따라 발생 가능        | await 적용으로 체감 리스크 감소  | ↓      |

---

## ⚠️ 주의사항 및 고려사항

### 리팩토링 시 주의할 점

1. **Behavior Preservation**: 실제 게임 진행/턴 처리 로직은 바꾸지 말고, “복원 경로”만 수정합니다.
2. `LEDGER_MAX_ENTRIES` 정책(최근 N개 유지)을 복원에서도 동일하게 적용해야 합니다.
3. `isBalanceLow`는 economyStore의 derived state이므로, 복원 후 반드시 재계산합니다.

### 영향받는 다른 모듈

- **`EconomyHud`/`GameHeader`**: `isBalanceLow`, `lastCost`, `recentLedger` 표시가 복원 후에도 정확해짐

### 호환성 체크리스트

- [ ] 저장된 ledger 순서가 최신순(저장 당시) 그대로 유지되는가?
- [ ] `lastCost`가 최신 엔트리를 가리키는가?
- [ ] 복원 직후 언어가 SaveGame.language로 확정되는가?
- [ ] 잔액 부족 경고(`isBalanceLow`)가 복원 잔액에 맞는가?

---

## 🧪 검증 방법 (수동 검증 중심)

### 변경 전 확인 사항

1. Economy HUD의 원장 항목이 존재하는 상태로 새로고침 후, “최근 항목이 위”인지 확인
2. 마지막 확정 비용이 실제 마지막 턴의 비용인지 확인

### 변경 후 검증 시나리오

#### 시나리오 1: 원장/lastCost 복원 정합성

- **실행 방법**
  - 게임을 3턴 이상 진행하여 Economy HUD의 원장이 2개 이상 쌓인 상태로 만든다.
  - 새로고침 후 Continue로 복원한다.
- **기대 결과**
  - ✅ 원장 1번 항목이 “가장 최근 턴(Tn)”으로 표시된다.
  - ✅ 마지막 확정 비용이 “가장 최근 턴”과 일치한다.

#### 시나리오 2: 잔액 부족 경고 복원 정합성

- **실행 방법**
  - Signal을 임계값 이하로 만든 뒤(예: 의도적으로 많이 소비), 새로고침 후 Continue한다.
- **기대 결과**
  - ✅ 복원 직후 즉시 `잔액 부족` 경고가 표시된다.

#### 시나리오 3: 언어 복원 정합성

- **실행 방법**
  - 언어를 `en-US`로 전환(가능한 범위에서) 후 저장된 상태를 만든다.
  - 새로고침 후 Continue한다.
- **기대 결과**
  - ✅ 복원 직후 UI 문자열이 en-US로 표시된다(혼합 출력 없음).

### 회귀 확인 체크리스트

- [ ] 턴 실행/스트리밍/에러 폴백 동작은 변하지 않았는가?
- [ ] SaveGame이 없는 경우 Continue가 나타나지 않는가?

---

## 🔧 실행 가이드

### 개발자를 위한 실행 지침

1. **준비 사항**
   - 관련 파일: `App.tsx`, `economyStore.ts`, `i18n.ts`
2. **실행 절차**
   - Economy 복원 전용 hydrate 경로 추가
   - `restoreSaveGame()` async 전환 + `await changeLanguage`
   - 복원 직후 `updateBalanceLowStatus` 호출(또는 hydrate 내부에서 처리)
3. **검증 절차**
   - 본 문서의 시나리오 1~3 수행
4. **롤백 계획**
   - `restoreSaveGame()`과 economy hydrate 변경만 되돌리면 기능 영향 범위를 최소화 가능

### 예상 소요 시간

- 코드 수정: 20~40분
- 수동 검증: 10~20분
- 총 예상 시간: 30~60분

---

## 📚 참고 자료

- `vibe/prd.md` 5장(재화 UX), 6.6(세이브/로드), 6.9(데모 프로필/리셋)
- `vibe/unit-results/U-015[Mvp].md`
- `frontend/src/App.tsx`
- `frontend/src/stores/economyStore.ts`
- `frontend/src/i18n.ts`

---

## 🏷️ 태그

`#refactoring` `#stability` `#high` `#savegame` `#economy` `#i18n`

---

## 📝 노트

- 이 제안은 “새 기능 추가”가 아니라, U-015가 이미 제공하는 Continue/Reload의 **정합성(저장된 상태를 정확히 복원)**을 보장하기 위한 수정입니다.

