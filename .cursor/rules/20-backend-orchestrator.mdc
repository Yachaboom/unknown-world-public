---
applyTo: "backend/**/*.py"
description: "FastAPI 오케스트레이터 규칙: SSE 스트리밍, Vertex 서비스계정, 구조화 출력(Pydantic), 검증/복구, 비용/안전 제어"
priority: high
tags: [backend, fastapi, sse, vertex, gemini, structured-output, repair, economy]
---

# 백엔드(Orchestrator API) 세부 지침

## 적용 대상

- `backend/**/*.py`

## Core 규칙 연계 (SSOT)

- 이 문서는 `.cursor/rules/00-core-critical.mdc`의 아래 규칙을 **백엔드/오케스트레이터 관점에서 구체화**합니다:
  - RULE-001 (상태/오케스트레이터/아티팩트 기반 시스템)
  - RULE-003 (Structured Outputs + 이중 검증의 서버 측)
  - RULE-004 (Repair loop + 안전 폴백)
  - RULE-005 (Economy Hard gate)
  - RULE-007 (Vertex 서비스 계정 / 비밀정보 보호 / BYOK 금지)
  - RULE-008 (단계/배지/복구 가시화, 단 프롬프트/내부추론 노출 금지)
  - RULE-010 (모델 ID/버전 고정)
- 충돌 시: `00-core-critical.mdc`의 RULE이 우선합니다.

## 규칙

### 규칙 1: FastAPI async + SSE 스트리밍을 기본으로 한다

**설명**: 텍스트 타자 효과 + 단계(Queue/Badges) 진행 상황은 SSE로 스트리밍합니다. WebSocket은 “양방향이 정말 필요할 때만” 확장합니다.

**올바른 예시**:

```text
- /api/turn (SSE): phase/badge/narrative/turn_output 이벤트를 순차 전송
- TTFB를 줄이기 위해 phase 이벤트를 즉시 먼저 보냄
```

**잘못된 예시**:

```text
- 모든 결과가 끝날 때까지 블로킹 후 JSON 1번 반환
- 디버그 편의로 내부 프롬프트/추론을 스트림에 섞어 전송
```

**이유**: PRD는 스트리밍(타자 효과)과 “에이전트 동작 가시화”를 MVP 핵심으로 요구합니다. (참조: `vibe/prd.md`, `vibe/tech-stack.md`)

---

### 규칙 2: Vertex AI 서비스 계정 인증(BYOK 금지)

**설명**: 인증은 백엔드에서만 처리하며, 사용자의 API 키 입력을 요구하지 않습니다(MVP).

**올바른 예시**:

```text
- 런타임에서 서비스 계정/권한으로 Vertex 인증
- 비밀정보는 환경변수/비밀관리로 주입, 레포/로그/응답에 남기지 않음
```

**잘못된 예시**:

```text
- 프론트에서 API 키를 입력받아 그대로 백엔드로 전달
- 서비스 계정 키 파일을 커밋
```

**이유**: PRD 8.2의 필수 요구사항입니다. (참조: `vibe/prd.md`)

---

### 규칙 3: TurnOutput은 “구조화 출력(JSON Schema)”으로 강제한다

**설명**: 모델 응답은 `application/json` + JSON Schema로 강제하고, 서버에서 Pydantic 검증을 수행합니다.

**올바른 예시**:

```text
- Pydantic(BaseModel)로 TurnOutput 정의
- google-genai 호출 config에 response_mime_type/response_json_schema 지정
- response.text를 model_validate_json으로 검증
```

**잘못된 예시**:

```text
- “JSON처럼 보이는 텍스트”를 정규식으로 파싱
- 스키마 검증 없이 그대로 저장/클라 전달
```

**이유**: UI/상태/비용을 기계적으로 처리하기 위한 핵심 메커니즘입니다. (참조: `vibe/prd.md`, `vibe/ref/structured-outputs-guide.md`)

---

### 규칙 4: 스키마/비즈니스 룰 위반은 Repair loop로 자동 복구한다

**설명**: 검증 실패는 예외 처리로 끝내지 말고, 제한된 재시도 횟수 내에서 “수정 요청”을 수행합니다.

**올바른 예시**:

```text
- validate 실패 → repair #1(무엇이 깨졌는지 짧게) → 재검증
- 최대 N회 후에도 실패하면 안전한 폴백 TurnOutput 생성(텍스트-only + UI 최소)
```

**잘못된 예시**:

```text
- 실패를 500으로 던지고 종료
- 실패를 숨기고 이전 turn 결과를 재사용(일관성 붕괴)
```

**이유**: PRD는 “검증 후 자동 복구(repair loop)”를 설계하라고 명시합니다. (참조: `vibe/prd.md`)

---

### 규칙 5: Economy(재화) 검증은 서버에서 “Hard gate”로 보장한다

**설명**: 잔액 음수/비용 불일치는 절대 허용하지 않습니다.

**올바른 예시**:

```text
- cost 계산/검증: 0 이상, balance_after 일관성
- 이미지/Thinking High 같은 고비용 행동은 사전 체크 후 거절/대체 제안
```

**잘못된 예시**:

```text
- 모델이 준 cost를 그대로 신뢰
- 잔액 부족인데도 이미지 생성부터 실행
```

**이유**: 비용 리스크를 UX/게임 메커닉으로 전환하려면 서버가 인바리언트를 강제해야 합니다. (참조: `vibe/prd.md`)

---

### 규칙 6: 모델/라벨/ID는 tech-stack에 고정하고 중앙 상수로 관리한다

**설명**: 모델 ID는 `vibe/tech-stack.md`를 SSOT로 고정합니다.

**올바른 예시**:

```text
- FAST: gemini-3-flash-preview
- QUALITY: gemini-3-pro-preview
- IMAGE(생성/편집): gemini-3-pro-image-preview (고정)
```

**잘못된 예시**:

```text
- 요청마다 임의 모델 변경
- 이미지 모델을 다른 것으로 혼용
```

**이유**: 데모 안정성과 재현성을 위해 “고정 라인업”이 필요합니다. (참조: `vibe/tech-stack.md`)

---

### 규칙 7: 프롬프트는 .md 파일로 분리하고 버전/정책 라벨만 로그에 남긴다

**설명**: 프롬프트 원문은 코드에 하드코딩하지 않고 파일로 관리하며, UI/로그에는 원문을 노출하지 않습니다.

**올바른 예시**:

```text
- backend/prompts/system/game_master.ko.md
- backend/prompts/system/game_master.en.md
- 로그: prompt_version, policy_preset, model_label(FAST/QUALITY/REF)
```

**잘못된 예시**:

```text
- 프롬프트 문자열을 코드에 인라인으로 넣고 수정할 때마다 배포
- 디버그를 위해 프롬프트 원문을 SSE로 전송
```

**이유**: PRD의 “프롬프트는 백엔드의 별도 .md 파일로 관리” 요구와 “프롬프트 노출 금지”를 동시에 만족해야 합니다. (참조: `vibe/prd.md`)

---

### 규칙 8: 이미지 생성/편집은 “선택적”이며 실패 시 텍스트 대체를 제공한다

**설명**: 이미지 생성은 느릴 수 있으므로 텍스트 우선 출력 + Lazy loading을 기본으로 합니다.

**올바른 예시**:

```text
- should_generate=false 인 경우 텍스트/핫스팟만으로 진행
- 이미지 실패 시: 텍스트-only 결과 + (옵션) 재시도 버튼/정책 다운그레이드
```

**잘못된 예시**:

```text
- 매 턴 강제 이미지 생성(지연/비용 폭발)
- 이미지 실패 시 턴 전체 실패 처리
```

**이유**: PRD/Tech-stack의 비용·지연 제어 정책을 준수해야 합니다. (참조: `vibe/prd.md`, `vibe/tech-stack.md`)

---

### 규칙 9: 도구 결합 제약을 고려해 “built-in tools”와 function calling을 분리 설계한다

**설명**: Gemini 3는 built-in tools와 structured outputs 결합이 가능하지만, built-in tools와 function calling의 동시 사용은 제한될 수 있습니다.

**올바른 예시**:

```text
- (A) 구조화 출력 전용 호출: TurnOutput 생성
- (B) 외부 행동 필요 시 별도 단계로 분리(툴 호출 → 결과 반영 → 재생성)
```

**잘못된 예시**:

```text
- 단일 호출에서 built-in tool + function calling + 구조화 출력을 한꺼번에 강제
```

**이유**: 모델 제약을 무시하면 불안정/실패가 늘어나 복구 비용이 급증합니다. (참조: `vibe/prd.md` 8.4)

## 예외 처리

- WebSocket 도입은 “양방향 실시간 상호작용”이 명확할 때만 허용합니다.
- 모델/스키마 대개편은 PRD/Tech-stack 업데이트가 선행되어야 합니다.

## 체크리스트

- [ ] SSE로 phase/badge/결과를 스트리밍하는가?
- [ ] Vertex 서비스 계정 인증이며 BYOK를 강제하지 않는가?
- [ ] TurnOutput이 JSON Schema로 강제/검증되는가?
- [ ] 검증 실패/이미지 실패/비용 초과에 대한 복구/폴백이 있는가?
- [ ] Economy 인바리언트(잔액 음수 금지)가 서버에서 강제되는가?
- [ ] 프롬프트 원문/내부 추론/비밀정보가 UI/로그/응답에 노출되지 않는가?

## 관련 지침

- `.cursor/rules/00-core-critical.mdc`
- `vibe/prd.md`
- `vibe/tech-stack.md`

